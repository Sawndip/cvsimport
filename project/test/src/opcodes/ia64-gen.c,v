head	1.32;
access;
symbols
	sid-snapshot-20180601:1.32
	sid-snapshot-20180501:1.32
	sid-snapshot-20180401:1.32
	sid-snapshot-20180301:1.32
	sid-snapshot-20180201:1.32
	sid-snapshot-20180101:1.32
	sid-snapshot-20171201:1.32
	sid-snapshot-20171101:1.32
	sid-snapshot-20171001:1.32
	sid-snapshot-20170901:1.32
	sid-snapshot-20170801:1.32
	sid-snapshot-20170701:1.32
	sid-snapshot-20170601:1.32
	sid-snapshot-20170501:1.32
	sid-snapshot-20170401:1.32
	sid-snapshot-20170301:1.32
	sid-snapshot-20170201:1.32
	sid-snapshot-20170101:1.32
	sid-snapshot-20161201:1.32
	sid-snapshot-20161101:1.32
	sid-snapshot-20160901:1.32
	sid-snapshot-20160801:1.32
	sid-snapshot-20160701:1.32
	sid-snapshot-20160601:1.32
	sid-snapshot-20160501:1.32
	sid-snapshot-20160401:1.32
	sid-snapshot-20160301:1.32
	sid-snapshot-20160201:1.32
	sid-snapshot-20160101:1.32
	sid-snapshot-20151201:1.32
	sid-snapshot-20151101:1.32
	sid-snapshot-20151001:1.32
	sid-snapshot-20150901:1.32
	sid-snapshot-20150801:1.32
	sid-snapshot-20150701:1.32
	sid-snapshot-20150601:1.32
	sid-snapshot-20150501:1.32
	sid-snapshot-20150401:1.32
	sid-snapshot-20150301:1.32
	sid-snapshot-20150201:1.32
	sid-snapshot-20150101:1.32
	sid-snapshot-20141201:1.32
	sid-snapshot-20141101:1.32
	sid-snapshot-20141001:1.32
	sid-snapshot-20140901:1.32
	sid-snapshot-20140801:1.32
	sid-snapshot-20140701:1.32
	sid-snapshot-20140601:1.32
	sid-snapshot-20140501:1.32
	sid-snapshot-20140401:1.32
	sid-snapshot-20140301:1.32
	sid-snapshot-20140201:1.32
	sid-snapshot-20140101:1.32
	sid-snapshot-20131201:1.32
	sid-snapshot-20131101:1.32
	sid-snapshot-20131001:1.32
	binutils-2_24-branch:1.32.0.4
	binutils-2_24-branchpoint:1.32
	binutils-2_21_1:1.29
	sid-snapshot-20130901:1.32
	gdb_7_6_1-2013-08-30-release:1.32
	sid-snapshot-20130801:1.32
	sid-snapshot-20130701:1.32
	sid-snapshot-20130601:1.32
	sid-snapshot-20130501:1.32
	gdb_7_6-2013-04-26-release:1.32
	sid-snapshot-20130401:1.32
	binutils-2_23_2:1.30.4.1
	gdb_7_6-branch:1.32.0.2
	gdb_7_6-2013-03-12-branchpoint:1.32
	sid-snapshot-20130301:1.32
	sid-snapshot-20130201:1.32
	sid-snapshot-20130101:1.32
	sid-snapshot-20121201:1.32
	gdb_7_5_1-2012-11-29-release:1.30
	binutils-2_23_1:1.30.4.1
	sid-snapshot-20121101:1.31
	binutils-2_23:1.30.4.1
	sid-snapshot-20121001:1.31
	sid-snapshot-20120901:1.30
	gdb_7_5-2012-08-17-release:1.30
	sid-snapshot-20120801:1.30
	binutils-2_23-branch:1.30.0.4
	binutils-2_23-branchpoint:1.30
	gdb_7_5-branch:1.30.0.2
	gdb_7_5-2012-07-18-branchpoint:1.30
	sid-snapshot-20120701:1.30
	sid-snapshot-20120601:1.30
	sid-snapshot-20120501:1.29
	binutils-2_22_branch:1.29.0.14
	gdb_7_4_1-2012-04-26-release:1.29
	sid-snapshot-20120401:1.29
	sid-snapshot-20120301:1.29
	sid-snapshot-20120201:1.29
	gdb_7_4-2012-01-24-release:1.29
	sid-snapshot-20120101:1.29
	gdb_7_4-branch:1.29.0.12
	gdb_7_4-2011-12-13-branchpoint:1.29
	sid-snapshot-20111201:1.29
	binutils-2_22:1.29
	sid-snapshot-20111101:1.29
	sid-snapshot-20111001:1.29
	binutils-2_22-branch:1.29.0.10
	binutils-2_22-branchpoint:1.29
	gdb_7_3_1-2011-09-04-release:1.29
	sid-snapshot-20110901:1.29
	sid-snapshot-20110801:1.29
	gdb_7_3-2011-07-26-release:1.29
	sid-snapshot-20110701:1.29
	sid-snapshot-20110601:1.29
	sid-snapshot-20110501:1.29
	gdb_7_3-branch:1.29.0.8
	gdb_7_3-2011-04-01-branchpoint:1.29
	sid-snapshot-20110401:1.29
	sid-snapshot-20110301:1.29
	sid-snapshot-20110201:1.29
	sid-snapshot-20110101:1.29
	binutils-2_21:1.29
	sid-snapshot-20101201:1.29
	binutils-2_21-branch:1.29.0.6
	binutils-2_21-branchpoint:1.29
	sid-snapshot-20101101:1.29
	sid-snapshot-20101001:1.29
	binutils-2_20_1:1.28
	gdb_7_2-2010-09-02-release:1.29
	sid-snapshot-20100901:1.29
	sid-snapshot-20100801:1.29
	gdb_7_2-branch:1.29.0.4
	gdb_7_2-2010-07-07-branchpoint:1.29
	sid-snapshot-20100701:1.29
	sid-snapshot-20100601:1.29
	sid-snapshot-20100501:1.29
	sid-snapshot-20100401:1.29
	gdb_7_1-2010-03-18-release:1.29
	sid-snapshot-20100301:1.29
	gdb_7_1-branch:1.29.0.2
	gdb_7_1-2010-02-18-branchpoint:1.29
	sid-snapshot-20100201:1.29
	sid-snapshot-20100101:1.29
	gdb_7_0_1-2009-12-22-release:1.28
	sid-snapshot-20091201:1.28
	sid-snapshot-20091101:1.28
	binutils-2_20:1.28
	gdb_7_0-2009-10-06-release:1.28
	sid-snapshot-20091001:1.28
	gdb_7_0-branch:1.28.0.4
	gdb_7_0-2009-09-16-branchpoint:1.28
	arc-sim-20090309:1.25
	binutils-arc-20081103-branch:1.26.0.12
	binutils-arc-20081103-branchpoint:1.26
	binutils-2_20-branch:1.28.0.2
	binutils-2_20-branchpoint:1.28
	sid-snapshot-20090901:1.27
	sid-snapshot-20090801:1.27
	msnyder-checkpoint-072509-branch:1.27.0.4
	msnyder-checkpoint-072509-branchpoint:1.27
	sid-snapshot-20090701:1.27
	dje-cgen-play1-branch:1.27.0.2
	dje-cgen-play1-branchpoint:1.27
	sid-snapshot-20090601:1.26
	sid-snapshot-20090501:1.26
	sid-snapshot-20090401:1.26
	arc-20081103-branch:1.26.0.10
	arc-20081103-branchpoint:1.26
	arc-insight_6_8-branch:1.25.0.10
	arc-insight_6_8-branchpoint:1.25
	insight_6_8-branch:1.25.0.8
	insight_6_8-branchpoint:1.25
	sid-snapshot-20090301:1.26
	binutils-2_19_1:1.26
	sid-snapshot-20090201:1.26
	sid-snapshot-20090101:1.26
	reverse-20081226-branch:1.26.0.8
	reverse-20081226-branchpoint:1.26
	sid-snapshot-20081201:1.26
	multiprocess-20081120-branch:1.26.0.6
	multiprocess-20081120-branchpoint:1.26
	sid-snapshot-20081101:1.26
	binutils-2_19:1.26
	sid-snapshot-20081001:1.26
	reverse-20080930-branch:1.26.0.4
	reverse-20080930-branchpoint:1.26
	binutils-2_19-branch:1.26.0.2
	binutils-2_19-branchpoint:1.26
	sid-snapshot-20080901:1.26
	sid-snapshot-20080801:1.25
	reverse-20080717-branch:1.25.0.6
	reverse-20080717-branchpoint:1.25
	sid-snapshot-20080701:1.25
	msnyder-reverse-20080609-branch:1.25.0.4
	msnyder-reverse-20080609-branchpoint:1.25
	drow-reverse-20070409-branch:1.20.0.4
	drow-reverse-20070409-branchpoint:1.20
	sid-snapshot-20080601:1.25
	sid-snapshot-20080501:1.25
	sid-snapshot-20080403:1.25
	sid-snapshot-20080401:1.25
	gdb_6_8-2008-03-27-release:1.25
	sid-snapshot-20080301:1.25
	gdb_6_8-branch:1.25.0.2
	gdb_6_8-2008-02-26-branchpoint:1.25
	sid-snapshot-20080201:1.25
	sid-snapshot-20080101:1.25
	sid-snapshot-20071201:1.25
	sid-snapshot-20071101:1.24
	gdb_6_7_1-2007-10-29-release:1.22
	gdb_6_7-2007-10-10-release:1.22
	sid-snapshot-20071001:1.24
	gdb_6_7-branch:1.22.0.4
	gdb_6_7-2007-09-07-branchpoint:1.22
	binutils-2_18:1.22
	binutils-2_18-branch:1.22.0.2
	binutils-2_18-branchpoint:1.22
	insight_6_6-20070208-release:1.20
	binutils-csl-coldfire-4_1-32:1.19
	binutils-csl-sourcerygxx-4_1-32:1.19
	gdb_6_6-2006-12-18-release:1.20
	binutils-csl-innovasic-fido-3_4_4-33:1.19
	binutils-csl-sourcerygxx-3_4_4-32:1.14
	binutils-csl-coldfire-4_1-30:1.19
	binutils-csl-sourcerygxx-4_1-30:1.19
	binutils-csl-coldfire-4_1-28:1.19
	binutils-csl-sourcerygxx-4_1-29:1.19
	binutils-csl-sourcerygxx-4_1-28:1.19
	gdb_6_6-branch:1.20.0.2
	gdb_6_6-2006-11-15-branchpoint:1.20
	binutils-csl-arm-2006q3-27:1.19
	binutils-csl-sourcerygxx-4_1-27:1.19
	binutils-csl-arm-2006q3-26:1.19
	binutils-csl-sourcerygxx-4_1-26:1.19
	binutils-csl-sourcerygxx-4_1-25:1.19
	binutils-csl-sourcerygxx-4_1-24:1.19
	binutils-csl-sourcerygxx-4_1-23:1.19
	insight_6_5-20061003-release:1.19
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	binutils-csl-sourcerygxx-4_1-21:1.19
	binutils-csl-arm-2006q3-21:1.19
	binutils-csl-sourcerygxx-4_1-22:1.19
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.19
	binutils-csl-sourcerygxx-4_1-20:1.19
	binutils-csl-arm-2006q3-19:1.19
	binutils-csl-sourcerygxx-4_1-19:1.19
	binutils-csl-sourcerygxx-4_1-18:1.19
	binutils-csl-renesas-4_1-9:1.19
	gdb-csl-sourcerygxx-3_4_4-25:1.16
	binutils-csl-sourcerygxx-3_4_4-25:1.14
	nickrob-async-20060828-mergepoint:1.19
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	binutils-csl-renesas-4_1-8:1.19
	binutils-csl-renesas-4_1-7:1.19
	binutils-csl-renesas-4_1-6:1.19
	gdb-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-17:1.19
	gdb-csl-20060226-branch-local-2:1.19
	gdb-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-15:1.19
	gdb-csl-sourcerygxx-4_1-13:1.19
	binutils-csl-sourcerygxx-4_1-13:1.19
	binutils-2_17:1.19
	gdb-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-4_1-12:1.19
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.19
	gdb_6_5-20060621-release:1.19
	binutils-csl-wrs-linux-3_4_4-24:1.14
	binutils-csl-wrs-linux-3_4_4-23:1.14
	gdb-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-9:1.19
	gdb-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-8:1.19
	gdb-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-sourcerygxx-4_1-7:1.19
	gdb-csl-arm-2006q1-6:1.19
	binutils-csl-arm-2006q1-6:1.19
	gdb-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-wrs-linux-3_4_4-22:1.14
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	binutils-csl-coldfire-4_1-11:1.19
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.19
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.19.0.20
	gdb_6_5-2006-05-14-branchpoint:1.19
	binutils-csl-coldfire-4_1-10:1.19
	gdb-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-5:1.19
	nickrob-async-20060513-branch:1.19.0.18
	nickrob-async-20060513-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-sourcerygxx-4_1-4:1.19
	msnyder-reverse-20060502-branch:1.19.0.16
	msnyder-reverse-20060502-branchpoint:1.19
	binutils-csl-wrs-linux-3_4_4-21:1.14
	gdb-csl-morpho-4_1-4:1.19
	binutils-csl-morpho-4_1-4:1.19
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-wrs-linux-3_4_4-20:1.14
	readline_5_1-import-branch:1.19.0.14
	readline_5_1-import-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	binutils-2_17-branch:1.19.0.12
	binutils-2_17-branchpoint:1.19
	gdb-csl-symbian-20060226-branch:1.19.0.10
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.19.0.8
	msnyder-reverse-20060331-branchpoint:1.19
	binutils-csl-2_17-branch:1.19.0.6
	binutils-csl-2_17-branchpoint:1.19
	gdb-csl-available-20060303-branch:1.19.0.4
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.2
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.16
	msnyder-fork-checkpoint-branch:1.16.0.8
	msnyder-fork-checkpoint-branchpoint:1.16
	gdb-csl-gxxpro-6_3-branch:1.16.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.16
	gdb_6_4-branch:1.16.0.4
	gdb_6_4-2005-11-01-branchpoint:1.16
	gdb-csl-arm-20051020-branch:1.16.0.2
	gdb-csl-arm-20051020-branchpoint:1.16
	binutils-csl-gxxpro-3_4-branch:1.14.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.14
	binutils-2_16_1:1.14
	msnyder-tracepoint-checkpoint-branch:1.15.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.15
	gdb-csl-arm-20050325-2005-q1b:1.14
	binutils-csl-arm-2005q1b:1.14
	binutils-2_16:1.14
	gdb-csl-arm-20050325-2005-q1a:1.14
	binutils-csl-arm-2005q1a:1.14
	csl-arm-20050325-branch:1.14.0.6
	csl-arm-20050325-branchpoint:1.14
	binutils-csl-arm-2005q1-branch:1.14.0.4
	binutils-csl-arm-2005q1-branchpoint:1.14
	binutils-2_16-branch:1.14.0.2
	binutils-2_16-branchpoint:1.14
	csl-arm-2004-q3d:1.12
	gdb_6_3-20041109-release:1.12
	gdb_6_3-branch:1.12.0.4
	gdb_6_3-20041019-branchpoint:1.12
	csl-arm-2004-q3:1.12
	drow_intercu-merge-20040921:1.12
	drow_intercu-merge-20040915:1.12
	jimb-gdb_6_2-e500-branch:1.12.0.6
	jimb-gdb_6_2-e500-branchpoint:1.12
	gdb_6_2-20040730-release:1.12
	gdb_6_2-branch:1.12.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.12
	gdb_6_1_1-20040616-release:1.11
	binutils-2_15:1.11
	binutils-2_15-branchpoint:1.11
	csl-arm-2004-q1a:1.11
	csl-arm-2004-q1:1.11
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.11
	drow_intercu-merge-20040327:1.11
	ezannoni_pie-20040323-branch:1.11.0.56
	ezannoni_pie-20040323-branchpoint:1.11
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.54
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.52
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.50
	drow_intercu-20040221-branchpoint:1.11
	binutils-2_15-branch:1.11.0.48
	cagney_bfdfile-20040213-branch:1.11.0.46
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.44
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	csl-arm-2003-q4:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.11
	drow-cplus-merge-20031214:1.11
	carlton-dictionary-20031111-merge:1.11
	gdb_6_0-2003-10-04-release:1.11
	kettenis_sparc-20030918-branch:1.11.0.42
	kettenis_sparc-20030918-branchpoint:1.11
	carlton_dictionary-20030917-merge:1.11
	ezannoni_pie-20030916-branchpoint:1.11
	ezannoni_pie-20030916-branch:1.11.0.40
	cagney_x86i386-20030821-branch:1.11.0.38
	cagney_x86i386-20030821-branchpoint:1.11
	carlton_dictionary-20030805-merge:1.11
	carlton_dictionary-20030627-merge:1.11
	gdb_6_0-branch:1.11.0.36
	gdb_6_0-2003-06-23-branchpoint:1.11
	jimb-ppc64-linux-20030613-branch:1.11.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.11
	binutils-2_14:1.11
	cagney_convert-20030606-branch:1.11.0.32
	cagney_convert-20030606-branchpoint:1.11
	cagney_writestrings-20030508-branch:1.11.0.30
	cagney_writestrings-20030508-branchpoint:1.11
	jimb-ppc64-linux-20030528-branch:1.11.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.11
	carlton_dictionary-20030523-merge:1.11
	cagney_fileio-20030521-branch:1.11.0.26
	cagney_fileio-20030521-branchpoint:1.11
	kettenis_i386newframe-20030517-mergepoint:1.11
	jimb-ppc64-linux-20030509-branch:1.11.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.11
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	binutils-2_14-branch:1.11.0.22
	binutils-2_14-branchpoint:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.20
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.18
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.16
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.11.0.14
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.11.0.12
	cagney_lazyid-20030317-branchpoint:1.11
	kettenis-i386newframe-20030316-mergepoint:1.11
	offbyone-20030313-branch:1.11.0.10
	offbyone-20030313-branchpoint:1.11
	kettenis-i386newframe-20030308-branch:1.11.0.8
	kettenis-i386newframe-20030308-branchpoint:1.11
	carlton_dictionary-20030305-merge:1.11
	cagney_offbyone-20030303-branch:1.11.0.6
	cagney_offbyone-20030303-branchpoint:1.11
	carlton_dictionary-20030207-merge:1.11
	interps-20030202-branch:1.11.0.4
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.11.0.2
	cagney-unwind-20030108-branchpoint:1.11
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.10
	binutils-2_13_1:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.24
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.22
	carlton_dictionary-20020920-branchpoint:1.9
	sid-20020905-branchpoint:1.9
	sid-20020905-branch:1.9.0.20
	gdb_5_3-branch:1.9.0.18
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.16
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.14
	readline_4_3-import-branchpoint:1.9
	binutils-2_13:1.9
	gdb_5_2_1-2002-07-23-release:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.12
	kseitz_interps-20020528-branch:1.9.0.10
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.8
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.9
	jimb-macro-020506-branch:1.9.0.6
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	binutils-2_12:1.9
	gdb_5_2-branch:1.9.0.4
	gdb_5_2-2002-03-03-branchpoint:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.4
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.2
	gdb_5_1-2001-07-29-branchpoint:1.8
	binutils-2_11_2:1.6.2.2
	binutils-2_11_1:1.6.2.2
	binutils-2_11:1.6.2.1
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	insight-precleanup-2001-01-01:1.6
	binutils_latest_snapshot:1.32
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.32
date	2012.11.09.08.29.34;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2012.09.04.13.52.05;	author hjl;	state Exp;
branches;
next	1.30;

1.30
date	2012.05.18.01.59.38;	author amodra;	state Exp;
branches
	1.30.4.1;
next	1.29;

1.29
date	2009.12.11.13.42.17;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.02.07.20.29;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.02.07.48.05;	author gingold;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.28.14.07.49;	author hjl;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.14.22.31.53;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.26.18.11.04;	author wilson;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.26.16.07.18;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.03.18.54.22;	author wilson;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.05.09.49.01;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.23.14.49.32;	author hjl;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.23.00.17.24;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.23.04.58.37;	author wilson;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.07.19.27.50;	author wilson;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.07.07.34.28;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.22.13.01.52;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.31.08.48.32;	author jbeulich;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.08.20.40.59;	author jakub;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.05.02.08.02;	author wilson;	state Exp;
branches
	1.11.50.1;
next	1.10;

1.10
date	2002.11.07.14.33.48;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.05.33.36;	author hjl;	state Exp;
branches
	1.9.22.1
	1.9.24.1;
next	1.8;

1.8
date	2001.03.20.02.32.27;	author wilson;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.13.22.58.35;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.12.22.56.36;	author wilson;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.10.04.06.38.00;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.22.19.43.50;	author wilson;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.30.18.35.33;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.23.02.39.12;	author twall;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.21.20.22.23;	author wilson;	state Exp;
branches;
next	;

1.30.4.1
date	2012.09.04.13.57.45;	author gingold;	state Exp;
branches;
next	;

1.11.50.1
date	2004.09.16.17.02.00;	author drow;	state Exp;
branches;
next	;

1.9.22.1
date	2002.11.15.19.19.24;	author carlton;	state Exp;
branches;
next	1.9.22.2;

1.9.22.2
date	2002.12.23.19.39.33;	author carlton;	state Exp;
branches;
next	;

1.9.24.1
date	2003.12.14.20.28.06;	author drow;	state Exp;
branches;
next	;

1.6.2.1
date	2001.03.20.02.33.43;	author wilson;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.06.07.03.18.34;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@/* ia64-gen.c -- Generate a shrunk set of opcode tables
   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012
   Free Software Foundation, Inc.
   Written by Bob Manson, Cygnus Solutions, <manson@@cygnus.com>

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this file; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */


/* While the ia64-opc-* set of opcode tables are easy to maintain,
   they waste a tremendous amount of space.  ia64-gen rearranges the
   instructions into a directed acyclic graph (DAG) of instruction opcodes and 
   their possible completers, as well as compacting the set of strings used.  

   The disassembler table consists of a state machine that does
   branching based on the bits of the opcode being disassembled.  The
   state encodings have been chosen to minimize the amount of space
   required.  

   The resource table is constructed based on some text dependency tables, 
   which are also easier to maintain than the final representation.  */

#include "sysdep.h"
#include <stdio.h>
#include <stdarg.h>
#include <errno.h>

#include "libiberty.h"
#include "safe-ctype.h"
#include "getopt.h"
#include "ia64-opc.h"
#include "ia64-opc-a.c"
#include "ia64-opc-i.c"
#include "ia64-opc-m.c"
#include "ia64-opc-b.c"
#include "ia64-opc-f.c"
#include "ia64-opc-x.c"
#include "ia64-opc-d.c"

#include <libintl.h>
#define _(String) gettext (String)

/* This is a copy of fprintf_vma from bfd/bfd-in2.h.  We have to use this
   always, because we might be compiled without BFD64 defined, if configured
   for a 32-bit target and --enable-targets=all is used.  This will work for
   both 32-bit and 64-bit hosts.  */
#define _opcode_int64_low(x) ((unsigned long) (((x) & 0xffffffff)))
#define _opcode_int64_high(x) ((unsigned long) (((x) >> 32) & 0xffffffff))
#define opcode_fprintf_vma(s,x) \
  fprintf ((s), "%08lx%08lx", _opcode_int64_high (x), _opcode_int64_low (x))

const char * program_name = NULL;
int debug = 0;

#define NELEMS(a) (sizeof (a) / sizeof ((a)[0]))
#define tmalloc(X) (X *) xmalloc (sizeof (X))

typedef unsigned long long  ci_t;
/* The main opcode table entry.  Each entry is a unique combination of
   name and flags (no two entries in the table compare as being equal
   via opcodes_eq).  */
struct main_entry
{
  /* The base name of this opcode.  The names of its completers are
     appended to it to generate the full instruction name.  */
  struct string_entry *name;
  /* The base opcode entry.  Which one to use is a fairly arbitrary choice;
     it uses the first one passed to add_opcode_entry.  */
  struct ia64_opcode *opcode;
  /* The list of completers that can be applied to this opcode.  */
  struct completer_entry *completers;
  /* Next entry in the chain.  */
  struct main_entry *next;
  /* Index in the  main table.  */
  int main_index;
} *maintable, **ordered_table;

int otlen = 0;
int ottotlen = 0;
int opcode_count = 0;

/* The set of possible completers for an opcode.  */
struct completer_entry
{
  /* This entry's index in the ia64_completer_table[] array.  */
  int num;

  /* The name of the completer.  */
  struct string_entry *name;

  /* This entry's parent.  */
  struct completer_entry *parent;

  /* Set if this is a terminal completer (occurs at the end of an
     opcode).  */
  int is_terminal;

  /* An alternative completer.  */
  struct completer_entry *alternative;

  /* Additional completers that can be appended to this one.  */
  struct completer_entry *addl_entries;

  /* Before compute_completer_bits () is invoked, this contains the actual
     instruction opcode for this combination of opcode and completers.
     Afterwards, it contains those bits that are different from its
     parent opcode.  */
  ia64_insn bits;

  /* Bits set to 1 correspond to those bits in this completer's opcode
     that are different from its parent completer's opcode (or from
     the base opcode if the entry is the root of the opcode's completer
     list).  This field is filled in by compute_completer_bits ().  */
  ia64_insn mask;

  /* Index into the opcode dependency list, or -1 if none.  */
  int dependencies;

  /* Remember the order encountered in the opcode tables.  */
  int order;
};

/* One entry in the disassembler name table.  */
struct disent
{
  /* The index into the ia64_name_dis array for this entry.  */
  int ournum;

  /* The index into the main_table[] array.  */
  int insn;

  /* The disassmbly priority of this entry.  */
  int priority;

  /* The completer_index value for this entry.  */
  ci_t completer_index;

  /* How many other entries share this decode.  */
  int nextcnt;

  /* The next entry sharing the same decode.  */
  struct disent *nexte;

  /* The next entry in the name list.  */
  struct disent *next_ent;
} *disinsntable = NULL;

/* A state machine that will eventually be used to generate the
   disassembler table.  */
struct bittree
{
  struct disent *disent;
  struct bittree *bits[3]; /* 0, 1, and X (don't care).  */
  int bits_to_skip;
  int skip_flag;
} *bittree;

/* The string table contains all opcodes and completers sorted in
   alphabetical order.  */

/* One entry in the string table.  */
struct string_entry 
{
  /* The index in the ia64_strings[] array for this entry.  */
  int num;
  /* And the string.  */
  char *s;
} **string_table = NULL;

int strtablen = 0;
int strtabtotlen = 0;


/* Resource dependency entries.  */
struct rdep
{
  char *name;                       /* Resource name.  */
  unsigned 
    mode:2,                         /* RAW, WAW, or WAR.  */
    semantics:3;                    /* Dependency semantics.  */
  char *extra;                      /* Additional semantics info.  */
  int nchks;                   
  int total_chks;                   /* Total #of terminal insns.  */
  int *chks;                        /* Insn classes which read (RAW), write
                                       (WAW), or write (WAR) this rsrc.  */
  int *chknotes;                    /* Dependency notes for each class.  */
  int nregs;
  int total_regs;                   /* Total #of terminal insns.  */
  int *regs;                        /* Insn class which write (RAW), write2
                                       (WAW), or read (WAR) this rsrc.  */
  int *regnotes;                    /* Dependency notes for each class.  */

  int waw_special;                  /* Special WAW dependency note.  */
} **rdeps = NULL;

static int rdepslen = 0;
static int rdepstotlen = 0;

/* Array of all instruction classes.  */
struct iclass
{ 
  char *name;                       /* Instruction class name.  */
  int is_class;                     /* Is a class, not a terminal.  */
  int nsubs;                        
  int *subs;                        /* Other classes within this class.  */
  int nxsubs;                       
  int xsubs[4];                     /* Exclusions.  */
  char *comment;                    /* Optional comment.  */
  int note;                         /* Optional note.  */
  int terminal_resolved;            /* Did we match this with anything?  */
  int orphan;                       /* Detect class orphans.  */
} **ics = NULL;

static int iclen = 0;
static int ictotlen = 0;

/* An opcode dependency (chk/reg pair of dependency lists).  */
struct opdep
{
  int chk;                          /* index into dlists */
  int reg;                          /* index into dlists */
} **opdeps;

static int opdeplen = 0;
static int opdeptotlen = 0;

/* A generic list of dependencies w/notes encoded.  These may be shared.  */
struct deplist
{
  int len;
  unsigned short *deps;
} **dlists;

static int dlistlen = 0;
static int dlisttotlen = 0;


static void fail (const char *, ...) ATTRIBUTE_PRINTF_1;
static void warn (const char *, ...) ATTRIBUTE_PRINTF_1;
static struct rdep * insert_resource (const char *, enum ia64_dependency_mode);
static int  deplist_equals (struct deplist *, struct deplist *);
static short insert_deplist (int, unsigned short *);
static short insert_dependencies (int, unsigned short *, int, unsigned short *);
static void  mark_used (struct iclass *, int);
static int  fetch_insn_class (const char *, int);
static int  sub_compare (const void *, const void *);
static void load_insn_classes (void);
static void parse_resource_users (const char *, int **, int *, int **);
static int  parse_semantics (char *);
static void add_dep (const char *, const char *, const char *, int, int, char *, int);
static void load_depfile (const char *, enum ia64_dependency_mode);
static void load_dependencies (void);
static int  irf_operand (int, const char *);
static int  in_iclass_mov_x (struct ia64_opcode *, struct iclass *, const char *, const char *);
static int  in_iclass (struct ia64_opcode *, struct iclass *, const char *, const char *, int *);
static int  lookup_regindex (const char *, int);
static int  lookup_specifier (const char *);
static void print_dependency_table (void);
static struct string_entry * insert_string (char *);
static void gen_dis_table (struct bittree *);
static void print_dis_table (void);
static void generate_disassembler (void);
static void print_string_table (void);
static int  completer_entries_eq (struct completer_entry *, struct completer_entry *);
static struct completer_entry * insert_gclist (struct completer_entry *);
static int  get_prefix_len (const char *);
static void compute_completer_bits (struct main_entry *, struct completer_entry *);
static void collapse_redundant_completers (void);
static int  insert_opcode_dependencies (struct ia64_opcode *, struct completer_entry *);
static void insert_completer_entry (struct ia64_opcode *, struct main_entry *, int);
static void print_completer_entry (struct completer_entry *);
static void print_completer_table (void);
static int  opcodes_eq (struct ia64_opcode *, struct ia64_opcode *);
static void add_opcode_entry (struct ia64_opcode *);
static void print_main_table (void);
static void shrink (struct ia64_opcode *);
static void print_version (void);
static void usage (FILE *, int);
static void finish_distable (void);
static void insert_bit_table_ent (struct bittree *, int, ia64_insn, ia64_insn, int, int, ci_t);
static void add_dis_entry (struct bittree *, ia64_insn, ia64_insn, int, struct completer_entry *, ci_t);
static void compact_distree (struct bittree *);
static struct bittree * make_bittree_entry (void);
static struct disent * add_dis_table_ent (struct disent *, int, int, ci_t);


static void
fail (const char *message, ...)
{
  va_list args;
  
  va_start (args, message);
  fprintf (stderr, _("%s: Error: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
  xexit (1);
}

static void
warn (const char *message, ...)
{
  va_list args;

  va_start (args, message);

  fprintf (stderr, _("%s: Warning: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
}

/* Add NAME to the resource table, where TYPE is RAW or WAW.  */
static struct rdep *
insert_resource (const char *name, enum ia64_dependency_mode type)
{
  if (rdepslen == rdepstotlen)
    {
      rdepstotlen += 20;
      rdeps = (struct rdep **)
        xrealloc (rdeps, sizeof(struct rdep **) * rdepstotlen);
    }
  rdeps[rdepslen] = tmalloc(struct rdep);
  memset((void *)rdeps[rdepslen], 0, sizeof(struct rdep));
  rdeps[rdepslen]->name = xstrdup (name);
  rdeps[rdepslen]->mode = type;
  rdeps[rdepslen]->waw_special = 0;
  
  return rdeps[rdepslen++];
}

/* Are the lists of dependency indexes equivalent?  */
static int
deplist_equals (struct deplist *d1, struct deplist *d2)
{
  int i;

  if (d1->len != d2->len)
    return 0;

  for (i = 0; i < d1->len; i++)
    if (d1->deps[i] != d2->deps[i])
      return 0;

  return 1;
}

/* Add the list of dependencies to the list of dependency lists.  */
static short
insert_deplist (int count, unsigned short *deps)
{
  /* Sort the list, then see if an equivalent list exists already.
     this results in a much smaller set of dependency lists.  */
  struct deplist *list;
  char set[0x10000];
  int i;

  memset ((void *)set, 0, sizeof (set));
  for (i = 0; i < count; i++)
    set[deps[i]] = 1;

  count = 0;
  for (i = 0; i < (int) sizeof (set); i++)
    if (set[i])
      ++count;

  list = tmalloc (struct deplist);
  list->len = count;
  list->deps = (unsigned short *) malloc (sizeof (unsigned short) * count);

  for (i = 0, count = 0; i < (int) sizeof (set); i++)
    if (set[i])
      list->deps[count++] = i;

  /* Does this list exist already?  */
  for (i = 0; i < dlistlen; i++)
    if (deplist_equals (list, dlists[i]))
      {
	free (list->deps);
	free (list);
	return i;
      }

  if (dlistlen == dlisttotlen)
    {
      dlisttotlen += 20;
      dlists = (struct deplist **)
        xrealloc (dlists, sizeof(struct deplist **) * dlisttotlen);
    }
  dlists[dlistlen] = list;

  return dlistlen++;
}

/* Add the given pair of dependency lists to the opcode dependency list.  */
static short
insert_dependencies (int nchks, unsigned short *chks, 
                     int nregs, unsigned short *regs)
{
  struct opdep *pair;
  int i;
  int regind = -1;
  int chkind = -1;

  if (nregs > 0)
    regind = insert_deplist (nregs, regs);
  if (nchks > 0)
    chkind = insert_deplist (nchks, chks);

  for (i = 0; i < opdeplen; i++)
    if (opdeps[i]->chk == chkind 
	&& opdeps[i]->reg == regind)
      return i;

  pair = tmalloc (struct opdep);
  pair->chk = chkind;
  pair->reg = regind;
  
  if (opdeplen == opdeptotlen)
    {
      opdeptotlen += 20;
      opdeps = (struct opdep **)
        xrealloc (opdeps, sizeof(struct opdep **) * opdeptotlen);
    }
  opdeps[opdeplen] = pair;

  return opdeplen++;
}

static void 
mark_used (struct iclass *ic, int clear_terminals)
{
  int i;

  ic->orphan = 0;
  if (clear_terminals)
    ic->terminal_resolved = 1;

  for (i = 0; i < ic->nsubs; i++)
    mark_used (ics[ic->subs[i]], clear_terminals);

  for (i = 0; i < ic->nxsubs; i++)
    mark_used (ics[ic->xsubs[i]], clear_terminals);
}

/* Look up an instruction class; if CREATE make a new one if none found;
   returns the index into the insn class array.  */
static int
fetch_insn_class (const char *full_name, int create)
{
  char *name;
  char *notestr;
  char *xsect;
  char *comment;
  int i, note = 0;
  int ind;
  int is_class = 0;

  if (CONST_STRNEQ (full_name, "IC:"))
    {
      name = xstrdup (full_name + 3);
      is_class = 1;
    }
  else
    name = xstrdup (full_name);

  if ((xsect = strchr(name, '\\')) != NULL)
    is_class = 1;
  if ((comment = strchr(name, '[')) != NULL)
    is_class = 1;
  if ((notestr = strchr(name, '+')) != NULL)
    is_class = 1;

  /* If it is a composite class, then ignore comments and notes that come after
     the '\\', since they don't apply to the part we are decoding now.  */
  if (xsect)
    {
      if (comment > xsect)
	comment = 0;
      if (notestr > xsect)
	notestr = 0;
    }

  if (notestr)
    {
      char *nextnotestr;

      note = atoi (notestr + 1);
      if ((nextnotestr = strchr (notestr + 1, '+')) != NULL)
        {
          if (strcmp (notestr, "+1+13") == 0)
            note = 13;
          else if (!xsect || nextnotestr < xsect)
            warn (_("multiple note %s not handled\n"), notestr);
        }
    }

  /* If it's a composite class, leave the notes and comments in place so that
     we have a unique name for the composite class.  Otherwise, we remove
     them.  */
  if (!xsect)
    {
      if (notestr)
        *notestr = 0;
      if (comment)
        *comment = 0;
    }

  for (i = 0; i < iclen; i++)
    if (strcmp (name, ics[i]->name) == 0
        && ((comment == NULL && ics[i]->comment == NULL)
            || (comment != NULL && ics[i]->comment != NULL
                && strncmp (ics[i]->comment, comment, 
                            strlen (ics[i]->comment)) == 0))
        && note == ics[i]->note)
      return i;

  if (!create)
    return -1;

  /* Doesn't exist, so make a new one.  */
  if (iclen == ictotlen)
    {
      ictotlen += 20;
      ics = (struct iclass **)
        xrealloc (ics, (ictotlen) * sizeof (struct iclass *));
    }

  ind = iclen++;
  ics[ind] = tmalloc (struct iclass);
  memset ((void *)ics[ind], 0, sizeof (struct iclass));
  ics[ind]->name = xstrdup (name);
  ics[ind]->is_class = is_class;
  ics[ind]->orphan = 1;

  if (comment)
    {
      ics[ind]->comment = xstrdup (comment + 1);
      ics[ind]->comment[strlen (ics[ind]->comment)-1] = 0;
    }

  if (notestr)
    ics[ind]->note = note;

  /* If it's a composite class, there's a comment or note, look for an
     existing class or terminal with the same name.  */
  if ((xsect || comment || notestr) && is_class)
    {
      /* First, populate with the class we're based on.  */
      char *subname = name;

      if (xsect)
        *xsect = 0;
      else if (comment)
        *comment = 0;
      else if (notestr)
        *notestr = 0;

      ics[ind]->nsubs = 1;
      ics[ind]->subs = tmalloc(int);
      ics[ind]->subs[0] = fetch_insn_class (subname, 1);
    }

  while (xsect)
    {
      char *subname = xsect + 1;

      xsect = strchr (subname, '\\');
      if (xsect)
        *xsect = 0;
      ics[ind]->xsubs[ics[ind]->nxsubs] = fetch_insn_class (subname,1);
      ics[ind]->nxsubs++;
    }
  free (name);

  return ind;
}

/* For sorting a class's sub-class list only; make sure classes appear before
   terminals.  */
static int
sub_compare (const void *e1, const void *e2)
{
  struct iclass *ic1 = ics[*(int *)e1];
  struct iclass *ic2 = ics[*(int *)e2];

  if (ic1->is_class)
    {
      if (!ic2->is_class)
        return -1;
    }
  else if (ic2->is_class)
    return 1;

  return strcmp (ic1->name, ic2->name);
}

static void
load_insn_classes (void)
{
  FILE *fp = fopen ("ia64-ic.tbl", "r");
  char buf[2048];

  if (fp == NULL)
    fail (_("can't find ia64-ic.tbl for reading\n"));

  /* Discard first line.  */
  fgets (buf, sizeof(buf), fp);

  while (!feof (fp))
    {
      int iclass;
      char *name;
      char *tmp;
      
      if (fgets (buf, sizeof (buf), fp) == NULL)
        break;
      
      while (ISSPACE (buf[strlen (buf) - 1]))
        buf[strlen (buf) - 1] = '\0';

      name = tmp = buf;
      while (*tmp != ';')
        {
          ++tmp;
          if (tmp == buf + sizeof (buf))
            abort ();
        }
      *tmp++ = '\0';

      iclass = fetch_insn_class (name, 1);
      ics[iclass]->is_class = 1;

      if (strcmp (name, "none") == 0)
        {
          ics[iclass]->is_class = 0;
          ics[iclass]->terminal_resolved = 1;
          continue;
        }

      /* For this class, record all sub-classes.  */
      while (*tmp)
        {
          char *subname;
          int sub;

          while (*tmp && ISSPACE (*tmp))
            {
              ++tmp;
              if (tmp == buf + sizeof (buf))
                abort ();
            }
          subname = tmp;
          while (*tmp && *tmp != ',')
            {
              ++tmp;
              if (tmp == buf + sizeof (buf))
                abort ();
            }
          if (*tmp == ',')
            *tmp++ = '\0';
          
          ics[iclass]->subs = (int *)
            xrealloc ((void *)ics[iclass]->subs, 
		      (ics[iclass]->nsubs + 1) * sizeof (int));

          sub = fetch_insn_class (subname, 1);
          ics[iclass]->subs = (int *)
            xrealloc (ics[iclass]->subs, (ics[iclass]->nsubs + 1) * sizeof (int));
          ics[iclass]->subs[ics[iclass]->nsubs++] = sub;
        }

      /* Make sure classes come before terminals.  */
      qsort ((void *)ics[iclass]->subs, 
             ics[iclass]->nsubs, sizeof(int), sub_compare);
    }
  fclose (fp);

  if (debug)
    printf ("%d classes\n", iclen);
}

/* Extract the insn classes from the given line.  */
static void
parse_resource_users (const char *ref, int **usersp, int *nusersp,
                      int **notesp)
{
  int c;
  char *line = xstrdup (ref);
  char *tmp = line;
  int *users = *usersp;
  int count = *nusersp;
  int *notes = *notesp;

  c = *tmp;
  while (c != 0)
    {
      char *notestr;
      int note;
      char *xsect;
      int iclass;
      int create = 0;
      char *name;
      
      while (ISSPACE (*tmp))
        ++tmp;
      name = tmp;
      while (*tmp && *tmp != ',')
        ++tmp;
      c = *tmp;
      *tmp++ = '\0';
      
      xsect = strchr (name, '\\');
      if ((notestr = strstr (name, "+")) != NULL)
        {
          char *nextnotestr;

          note = atoi (notestr + 1);
          if ((nextnotestr = strchr (notestr + 1, '+')) != NULL)
            {
              /* Note 13 always implies note 1.  */
              if (strcmp (notestr, "+1+13") == 0)
                note = 13;
              else if (!xsect || nextnotestr < xsect)
                warn (_("multiple note %s not handled\n"), notestr);
            }
          if (!xsect)
            *notestr = '\0';
        }
      else 
        note = 0;

      /* All classes are created when the insn class table is parsed;
         Individual instructions might not appear until the dependency tables
         are read.  Only create new classes if it's *not* an insn class,
         or if it's a composite class (which wouldn't necessarily be in the IC
         table).  */
      if (! CONST_STRNEQ (name, "IC:") || xsect != NULL)
        create = 1;
      
      iclass = fetch_insn_class (name, create);
      if (iclass != -1)
        {
          users = (int *)
            xrealloc ((void *) users,(count + 1) * sizeof (int));
          notes = (int *)
            xrealloc ((void *) notes,(count + 1) * sizeof (int));
          notes[count] = note;
          users[count++] = iclass;
          mark_used (ics[iclass], 0);
        }
      else if (debug)
	printf("Class %s not found\n", name);
    }
  /* Update the return values.  */
  *usersp = users;
  *nusersp = count;
  *notesp = notes;

  free (line);
}

static int
parse_semantics (char *sem)
{
  if (strcmp (sem, "none") == 0)
    return IA64_DVS_NONE;
  else if (strcmp (sem, "implied") == 0)
    return IA64_DVS_IMPLIED;
  else if (strcmp (sem, "impliedF") == 0)
    return IA64_DVS_IMPLIEDF;
  else if (strcmp (sem, "data") == 0)
    return IA64_DVS_DATA;
  else if (strcmp (sem, "instr") == 0)
    return IA64_DVS_INSTR;
  else if (strcmp (sem, "specific") == 0)
    return IA64_DVS_SPECIFIC;
  else if (strcmp (sem, "stop") == 0)
    return IA64_DVS_STOP;
  else 
    return IA64_DVS_OTHER;
}

static void
add_dep (const char *name, const char *chk, const char *reg,
         int semantics, int mode, char *extra, int flag)
{
  struct rdep *rs;

  rs = insert_resource (name, mode);

  parse_resource_users (chk, &rs->chks, &rs->nchks, &rs->chknotes);
  parse_resource_users (reg, &rs->regs, &rs->nregs, &rs->regnotes);

  rs->semantics = semantics;
  rs->extra = extra;
  rs->waw_special = flag;
}

static void
load_depfile (const char *filename, enum ia64_dependency_mode mode)
{
  FILE *fp = fopen (filename, "r");
  char buf[1024];

  if (fp == NULL)
    fail (_("can't find %s for reading\n"), filename);

  fgets (buf, sizeof(buf), fp);
  while (!feof (fp))
    {
      char *name, *tmp;
      int semantics;
      char *extra;
      char *regp, *chkp;

      if (fgets (buf, sizeof(buf), fp) == NULL)
        break;

      while (ISSPACE (buf[strlen (buf) - 1]))
        buf[strlen (buf) - 1] = '\0';

      name = tmp = buf;
      while (*tmp != ';')
        ++tmp;
      *tmp++ = '\0';
      
      while (ISSPACE (*tmp))
        ++tmp;
      regp = tmp;
      tmp = strchr (tmp, ';');
      if (!tmp)
        abort ();
      *tmp++ = 0;
      while (ISSPACE (*tmp))
        ++tmp;
      chkp = tmp;
      tmp = strchr (tmp, ';');
      if (!tmp)
        abort ();
      *tmp++ = 0;
      while (ISSPACE (*tmp))
        ++tmp;
      semantics = parse_semantics (tmp);
      extra = semantics == IA64_DVS_OTHER ? xstrdup (tmp) : NULL;

      /* For WAW entries, if the chks and regs differ, we need to enter the
         entries in both positions so that the tables will be parsed properly,
         without a lot of extra work.  */
      if (mode == IA64_DV_WAW && strcmp (regp, chkp) != 0)
        {
          add_dep (name, chkp, regp, semantics, mode, extra, 0);
          add_dep (name, regp, chkp, semantics, mode, extra, 1);
        }
      else
        {
          add_dep (name, chkp, regp, semantics, mode, extra, 0);
        }
    }
  fclose (fp);
}

static void
load_dependencies (void)
{
  load_depfile ("ia64-raw.tbl", IA64_DV_RAW);
  load_depfile ("ia64-waw.tbl", IA64_DV_WAW);
  load_depfile ("ia64-war.tbl", IA64_DV_WAR);

  if (debug)
    printf ("%d RAW/WAW/WAR dependencies\n", rdepslen);
}

/* Is the given operand an indirect register file operand?  */
static int 
irf_operand (int op, const char *field)
{
  if (!field)
    {
      return op == IA64_OPND_RR_R3 || op == IA64_OPND_DBR_R3
        || op == IA64_OPND_IBR_R3  || op == IA64_OPND_PKR_R3
	|| op == IA64_OPND_PMC_R3  || op == IA64_OPND_PMD_R3
	|| op == IA64_OPND_MSR_R3 || op == IA64_OPND_CPUID_R3;
    }
  else
    {
      return ((op == IA64_OPND_RR_R3 && strstr (field, "rr"))
              || (op == IA64_OPND_DBR_R3 && strstr (field, "dbr"))
              || (op == IA64_OPND_IBR_R3 && strstr (field, "ibr"))
              || (op == IA64_OPND_PKR_R3 && strstr (field, "pkr"))
              || (op == IA64_OPND_PMC_R3 && strstr (field, "pmc"))
              || (op == IA64_OPND_PMD_R3 && strstr (field, "pmd"))
              || (op == IA64_OPND_MSR_R3 && strstr (field, "msr"))
              || (op == IA64_OPND_CPUID_R3 && strstr (field, "cpuid"))
              || (op == IA64_OPND_DAHR_R3  && strstr (field, "dahr")));
    }
}

/* Handle mov_ar, mov_br, mov_cr, move_dahr, mov_indirect, mov_ip, mov_pr,
 * mov_psr, and  mov_um insn classes.  */
static int
in_iclass_mov_x (struct ia64_opcode *idesc, struct iclass *ic, 
                 const char *format, const char *field)
{
  int plain_mov = strcmp (idesc->name, "mov") == 0;

  if (!format)
    return 0;

  switch (ic->name[4])
    {
    default:
      abort ();
    case 'a':
      {
        int i = strcmp (idesc->name, "mov.i") == 0;
        int m = strcmp (idesc->name, "mov.m") == 0;
        int i2627 = i && idesc->operands[0] == IA64_OPND_AR3;
        int i28 = i && idesc->operands[1] == IA64_OPND_AR3;
        int m2930 = m && idesc->operands[0] == IA64_OPND_AR3;
        int m31 = m && idesc->operands[1] == IA64_OPND_AR3;
        int pseudo0 = plain_mov && idesc->operands[1] == IA64_OPND_AR3;
        int pseudo1 = plain_mov && idesc->operands[0] == IA64_OPND_AR3;

        /* IC:mov ar */
        if (i2627)
          return strstr (format, "I26") || strstr (format, "I27");
        if (i28)
          return strstr (format, "I28") != NULL;
        if (m2930)
          return strstr (format, "M29") || strstr (format, "M30");
        if (m31)
          return strstr (format, "M31") != NULL;
        if (pseudo0 || pseudo1)
          return 1;
      }
      break;
    case 'b':
      {
        int i21 = idesc->operands[0] == IA64_OPND_B1;
        int i22 = plain_mov && idesc->operands[1] == IA64_OPND_B2;
        if (i22)
          return strstr (format, "I22") != NULL;
        if (i21)
          return strstr (format, "I21") != NULL;
      }
      break;
    case 'c':
      {
        int m32 = plain_mov && idesc->operands[0] == IA64_OPND_CR3;
        int m33 = plain_mov && idesc->operands[1] == IA64_OPND_CR3;
        if (m32)
          return strstr (format, "M32") != NULL;
        if (m33)
          return strstr (format, "M33") != NULL;
      }
      break;
    case 'd':
      {
        int m50 = plain_mov && idesc->operands[0] == IA64_OPND_DAHR3;
        if (m50)
          return strstr (format, "M50") != NULL;
      }
      break;
    case 'i':
      if (ic->name[5] == 'n')
        {
          int m42 = plain_mov && irf_operand (idesc->operands[0], field);
          int m43 = plain_mov && irf_operand (idesc->operands[1], field);
          if (m42)
            return strstr (format, "M42") != NULL;
          if (m43)
            return strstr (format, "M43") != NULL;
        }
      else if (ic->name[5] == 'p')
        {
          return idesc->operands[1] == IA64_OPND_IP;
        }
      else
        abort ();
      break;
    case 'p':
      if (ic->name[5] == 'r')
        {
          int i25 = plain_mov && idesc->operands[1] == IA64_OPND_PR;
          int i23 = plain_mov && idesc->operands[0] == IA64_OPND_PR;
          int i24 = plain_mov && idesc->operands[0] == IA64_OPND_PR_ROT;
          if (i23)
            return strstr (format, "I23") != NULL;
          if (i24)
            return strstr (format, "I24") != NULL;
          if (i25)
            return strstr (format, "I25") != NULL;
        }
      else if (ic->name[5] == 's')
        {
          int m35 = plain_mov && idesc->operands[0] == IA64_OPND_PSR_L;
          int m36 = plain_mov && idesc->operands[1] == IA64_OPND_PSR;
          if (m35)
            return strstr (format, "M35") != NULL;
          if (m36)
            return strstr (format, "M36") != NULL;
        }
      else
        abort ();
      break;
    case 'u':
      {
        int m35 = plain_mov && idesc->operands[0] == IA64_OPND_PSR_UM;
        int m36 = plain_mov && idesc->operands[1] == IA64_OPND_PSR_UM;
        if (m35)
          return strstr (format, "M35") != NULL;
        if (m36)
          return strstr (format, "M36") != NULL;
      }
      break;
    }
  return 0;
}

/* Is the given opcode in the given insn class?  */
static int
in_iclass (struct ia64_opcode *idesc, struct iclass *ic, 
	   const char *format, const char *field, int *notep)
{
  int i;
  int resolved = 0;

  if (ic->comment)
    {
      if (CONST_STRNEQ (ic->comment, "Format"))
        {
          /* Assume that the first format seen is the most restrictive, and
             only keep a later one if it looks like it's more restrictive.  */
          if (format)
            {
              if (strlen (ic->comment) < strlen (format))
                {
                  warn (_("most recent format '%s'\nappears more restrictive than '%s'\n"),
			ic->comment, format);
                  format = ic->comment; 
                }
            }
          else
            format = ic->comment;
        }
      else if (CONST_STRNEQ (ic->comment, "Field"))
        {
          if (field)
            warn (_("overlapping field %s->%s\n"),
		  ic->comment, field);
          field = ic->comment;
        }
    }

  /* An insn class matches anything that is the same followed by completers,
     except when the absence and presence of completers constitutes different
     instructions.  */
  if (ic->nsubs == 0 && ic->nxsubs == 0)
    {
      int is_mov = CONST_STRNEQ (idesc->name, "mov");
      int plain_mov = strcmp (idesc->name, "mov") == 0;
      int len = strlen(ic->name);

      resolved = ((strncmp (ic->name, idesc->name, len) == 0)
                  && (idesc->name[len] == '\0' 
                      || idesc->name[len] == '.'));

      /* All break, nop, and hint variations must match exactly.  */
      if (resolved &&
          (strcmp (ic->name, "break") == 0
           || strcmp (ic->name, "nop") == 0
	   || strcmp (ic->name, "hint") == 0))
        resolved = strcmp (ic->name, idesc->name) == 0;

      /* Assume restrictions in the FORMAT/FIELD negate resolution,
         unless specifically allowed by clauses in this block.  */
      if (resolved && field)
        {
          /* Check Field(sf)==sN against opcode sN.  */
          if (strstr(field, "(sf)==") != NULL)
            {
              char *sf;

              if ((sf = strstr (idesc->name, ".s")) != 0)
		resolved = strcmp (sf + 1, strstr (field, "==") + 2) == 0;
            }
          /* Check Field(lftype)==XXX.  */
          else if (strstr (field, "(lftype)") != NULL)
            {
              if (strstr (idesc->name, "fault") != NULL)
                resolved = strstr (field, "fault") != NULL;
              else
                resolved = strstr (field, "fault") == NULL;
            }
          /* Handle Field(ctype)==XXX.  */
          else if (strstr (field, "(ctype)") != NULL)
            {
              if (strstr (idesc->name, "or.andcm"))
                resolved = strstr (field, "or.andcm") != NULL;
              else if (strstr (idesc->name, "and.orcm"))
                resolved = strstr (field, "and.orcm") != NULL;
              else if (strstr (idesc->name, "orcm"))
                resolved = strstr (field, "or orcm") != NULL;
              else if (strstr (idesc->name, "or"))
                resolved = strstr (field, "or orcm") != NULL;
              else if (strstr (idesc->name, "andcm"))
                resolved = strstr (field, "and andcm") != NULL;
              else if (strstr (idesc->name, "and"))
                resolved = strstr (field, "and andcm") != NULL;
              else if (strstr (idesc->name, "unc"))
                resolved = strstr (field, "unc") != NULL;
              else
                resolved = strcmp (field, "Field(ctype)==") == 0;
            }
        }

      if (resolved && format)
        {
          if (CONST_STRNEQ (idesc->name, "dep")
                   && strstr (format, "I13") != NULL)
            resolved = idesc->operands[1] == IA64_OPND_IMM8;
          else if (CONST_STRNEQ (idesc->name, "chk")
                   && strstr (format, "M21") != NULL)
            resolved = idesc->operands[0] == IA64_OPND_F2;
          else if (CONST_STRNEQ (idesc->name, "lfetch"))
            resolved = (strstr (format, "M14 M15") != NULL
                        && (idesc->operands[1] == IA64_OPND_R2
                            || idesc->operands[1] == IA64_OPND_IMM9b));
          else if (CONST_STRNEQ (idesc->name, "br.call")
                   && strstr (format, "B5") != NULL)
            resolved = idesc->operands[1] == IA64_OPND_B2;
          else if (CONST_STRNEQ (idesc->name, "br.call")
                   && strstr (format, "B3") != NULL)
            resolved = idesc->operands[1] == IA64_OPND_TGT25c;
          else if (CONST_STRNEQ (idesc->name, "brp")
                   && strstr (format, "B7") != NULL)
            resolved = idesc->operands[0] == IA64_OPND_B2;
          else if (strcmp (ic->name, "invala") == 0)
            resolved = strcmp (idesc->name, ic->name) == 0;
	  else if (CONST_STRNEQ (idesc->name, "st")
		   && (strstr (format, "M5") != NULL
		       || strstr (format, "M10") != NULL))
	    resolved = idesc->flags & IA64_OPCODE_POSTINC;
	  else if (CONST_STRNEQ (idesc->name, "ld")
		   && (strstr (format, "M2 M3") != NULL
		       || strstr (format, "M12") != NULL
		       || strstr (format, "M7 M8") != NULL))
	    resolved = idesc->flags & IA64_OPCODE_POSTINC;
          else
            resolved = 0;
        }

      /* Misc brl variations ('.cond' is optional); 
         plain brl matches brl.cond.  */
      if (!resolved
          && (strcmp (idesc->name, "brl") == 0
              || CONST_STRNEQ (idesc->name, "brl."))
          && strcmp (ic->name, "brl.cond") == 0)
        {
          resolved = 1;
        }

      /* Misc br variations ('.cond' is optional).  */
      if (!resolved 
          && (strcmp (idesc->name, "br") == 0
              || CONST_STRNEQ (idesc->name, "br."))
          && strcmp (ic->name, "br.cond") == 0)
        {
          if (format)
            resolved = (strstr (format, "B4") != NULL
                        && idesc->operands[0] == IA64_OPND_B2)
              || (strstr (format, "B1") != NULL
                  && idesc->operands[0] == IA64_OPND_TGT25c);
          else
            resolved = 1;
        }

      /* probe variations.  */
      if (!resolved && CONST_STRNEQ (idesc->name, "probe"))
        {
          resolved = strcmp (ic->name, "probe") == 0 
            && !((strstr (idesc->name, "fault") != NULL) 
                 ^ (format && strstr (format, "M40") != NULL));
        }

      /* mov variations.  */
      if (!resolved && is_mov)
        {
          if (plain_mov)
            {
              /* mov alias for fmerge.  */
              if (strcmp (ic->name, "fmerge") == 0)
                {
                  resolved = idesc->operands[0] == IA64_OPND_F1
                    && idesc->operands[1] == IA64_OPND_F3;
                }
              /* mov alias for adds (r3 or imm14).  */
              else if (strcmp (ic->name, "adds") == 0)
                {
                  resolved = (idesc->operands[0] == IA64_OPND_R1
                              && (idesc->operands[1] == IA64_OPND_R3
                                  || (idesc->operands[1] == IA64_OPND_IMM14)));
                }
              /* mov alias for addl.  */
              else if (strcmp (ic->name, "addl") == 0)
                {
                  resolved = idesc->operands[0] == IA64_OPND_R1
                    && idesc->operands[1] == IA64_OPND_IMM22;
                }
            }

          /* Some variants of mov and mov.[im].  */
          if (!resolved && CONST_STRNEQ (ic->name, "mov_"))
	    resolved = in_iclass_mov_x (idesc, ic, format, field);
        }

      /* Keep track of this so we can flag any insn classes which aren't 
         mapped onto at least one real insn.  */
      if (resolved)
	ic->terminal_resolved = 1;
    }
  else for (i = 0; i < ic->nsubs; i++)
    {
      if (in_iclass (idesc, ics[ic->subs[i]], format, field, notep))
        {
          int j;

          for (j = 0; j < ic->nxsubs; j++)
	    if (in_iclass (idesc, ics[ic->xsubs[j]], NULL, NULL, NULL))
	      return 0;

          if (debug > 1)
            printf ("%s is in IC %s\n", idesc->name, ic->name);

          resolved = 1;
          break;
        }
    }
  
  /* If it's in this IC, add the IC note (if any) to the insn.  */
  if (resolved)
    {
      if (ic->note && notep)
        {
          if (*notep && *notep != ic->note)
	    warn (_("overwriting note %d with note %d (IC:%s)\n"),
		  *notep, ic->note, ic->name);

          *notep = ic->note;
        }
    }

  return resolved;
}


static int
lookup_regindex (const char *name, int specifier)
{
  switch (specifier)
    {
    case IA64_RS_ARX:
      if (strstr (name, "[RSC]"))
        return 16;
      if (strstr (name, "[BSP]"))
        return 17;
      else if (strstr (name, "[BSPSTORE]"))
        return 18;
      else if (strstr (name, "[RNAT]"))
        return 19;
      else if (strstr (name, "[FCR]"))
        return 21;
      else if (strstr (name, "[EFLAG]"))
        return 24;
      else if (strstr (name, "[CSD]"))
        return 25;
      else if (strstr (name, "[SSD]"))
        return 26;
      else if (strstr (name, "[CFLG]"))
        return 27;
      else if (strstr (name, "[FSR]"))
        return 28;
      else if (strstr (name, "[FIR]"))
        return 29;
      else if (strstr (name, "[FDR]"))
        return 30;
      else if (strstr (name, "[CCV]"))
        return 32;
      else if (strstr (name, "[ITC]"))
        return 44;
      else if (strstr (name, "[RUC]"))
        return 45;
      else if (strstr (name, "[PFS]"))
        return 64;
      else if (strstr (name, "[LC]"))
        return 65;
      else if (strstr (name, "[EC]"))
        return 66;
      abort ();
    case IA64_RS_CRX:
      if (strstr (name, "[DCR]"))
        return 0;
      else if (strstr (name, "[ITM]"))
        return 1;
      else if (strstr (name, "[IVA]"))
        return 2;
      else if (strstr (name, "[PTA]"))
        return 8;
      else if (strstr (name, "[GPTA]"))
        return 9;
      else if (strstr (name, "[IPSR]"))
        return 16;
      else if (strstr (name, "[ISR]"))
        return 17;
      else if (strstr (name, "[IIP]"))
        return 19;
      else if (strstr (name, "[IFA]"))
        return 20;
      else if (strstr (name, "[ITIR]"))
        return 21;
      else if (strstr (name, "[IIPA]"))
        return 22;
      else if (strstr (name, "[IFS]"))
        return 23;
      else if (strstr (name, "[IIM]"))
        return 24;
      else if (strstr (name, "[IHA]"))
        return 25;
      else if (strstr (name, "[LID]"))
        return 64;
      else if (strstr (name, "[IVR]"))
        return 65;
      else if (strstr (name, "[TPR]"))
        return 66;
      else if (strstr (name, "[EOI]"))
        return 67;
      else if (strstr (name, "[ITV]"))
        return 72;
      else if (strstr (name, "[PMV]"))
        return 73;
      else if (strstr (name, "[CMCV]"))
        return 74;
      abort ();
    case IA64_RS_PSR:
      if (strstr (name, ".be"))
        return 1;
      else if (strstr (name, ".up"))
        return 2;
      else if (strstr (name, ".ac"))
        return 3;
      else if (strstr (name, ".mfl"))
        return 4;
      else if (strstr (name, ".mfh"))
        return 5;
      else if (strstr (name, ".ic"))
        return 13;
      else if (strstr (name, ".i"))
        return 14;
      else if (strstr (name, ".pk"))
        return 15;
      else if (strstr (name, ".dt"))
        return 17;
      else if (strstr (name, ".dfl"))
        return 18;
      else if (strstr (name, ".dfh"))
        return 19;
      else if (strstr (name, ".sp"))
        return 20;
      else if (strstr (name, ".pp"))
        return 21;
      else if (strstr (name, ".di"))
        return 22;
      else if (strstr (name, ".si"))
        return 23;
      else if (strstr (name, ".db"))
        return 24;
      else if (strstr (name, ".lp"))
        return 25;
      else if (strstr (name, ".tb"))
        return 26;
      else if (strstr (name, ".rt"))
        return 27;
      else if (strstr (name, ".cpl"))
        return 32;
      else if (strstr (name, ".rs"))
        return 34;
      else if (strstr (name, ".mc"))
        return 35;
      else if (strstr (name, ".it"))
        return 36;
      else if (strstr (name, ".id"))
        return 37;
      else if (strstr (name, ".da"))
        return 38;
      else if (strstr (name, ".dd"))
        return 39;
      else if (strstr (name, ".ss"))
        return 40;
      else if (strstr (name, ".ri"))
        return 41;
      else if (strstr (name, ".ed"))
        return 43;
      else if (strstr (name, ".bn"))
        return 44;
      else if (strstr (name, ".ia"))
        return 45;
      else if (strstr (name, ".vm"))
        return 46;
      else
        abort ();
    default:
      break;
    }
  return REG_NONE;
}

static int
lookup_specifier (const char *name)
{
  if (strchr (name, '%'))
    {
      if (strstr (name, "AR[K%]") != NULL)
        return IA64_RS_AR_K;
      if (strstr (name, "AR[UNAT]") != NULL)
        return IA64_RS_AR_UNAT;
      if (strstr (name, "AR%, % in 8") != NULL)
        return IA64_RS_AR;
      if (strstr (name, "AR%, % in 48") != NULL)
        return IA64_RS_ARb;
      if (strstr (name, "BR%") != NULL)
        return IA64_RS_BR;
      if (strstr (name, "CR[IIB%]") != NULL)
        return IA64_RS_CR_IIB;
      if (strstr (name, "CR[IRR%]") != NULL)
        return IA64_RS_CR_IRR;
      if (strstr (name, "CR[LRR%]") != NULL)
        return IA64_RS_CR_LRR;
      if (strstr (name, "CR%") != NULL)
        return IA64_RS_CR;
      if (strstr (name, "DAHR%, % in 0") != NULL)
        return IA64_RS_DAHR;
      if (strstr (name, "FR%, % in 0") != NULL)
        return IA64_RS_FR;
      if (strstr (name, "FR%, % in 2") != NULL)
        return IA64_RS_FRb;
      if (strstr (name, "GR%") != NULL)
        return IA64_RS_GR;
      if (strstr (name, "PR%, % in 1 ") != NULL)
        return IA64_RS_PR;
      if (strstr (name, "PR%, % in 16 ") != NULL)
	return IA64_RS_PRr;

      warn (_("don't know how to specify %% dependency %s\n"),
	    name);
    }
  else if (strchr (name, '#'))
    {
      if (strstr (name, "CPUID#") != NULL)
        return IA64_RS_CPUID;
      if (strstr (name, "DBR#") != NULL)
        return IA64_RS_DBR;
      if (strstr (name, "IBR#") != NULL)
        return IA64_RS_IBR;
      if (strstr (name, "MSR#") != NULL)
	return IA64_RS_MSR;
      if (strstr (name, "PKR#") != NULL)
        return IA64_RS_PKR;
      if (strstr (name, "PMC#") != NULL)
        return IA64_RS_PMC;
      if (strstr (name, "PMD#") != NULL)
        return IA64_RS_PMD;
      if (strstr (name, "RR#") != NULL)
        return IA64_RS_RR;
      
      warn (_("Don't know how to specify # dependency %s\n"),
	    name);
    }
  else if (CONST_STRNEQ (name, "AR[FPSR]"))
    return IA64_RS_AR_FPSR;
  else if (CONST_STRNEQ (name, "AR["))
    return IA64_RS_ARX;
  else if (CONST_STRNEQ (name, "CR["))
    return IA64_RS_CRX;
  else if (CONST_STRNEQ (name, "PSR."))
    return IA64_RS_PSR;
  else if (strcmp (name, "InService*") == 0)
    return IA64_RS_INSERVICE;
  else if (strcmp (name, "GR0") == 0)
    return IA64_RS_GR0;
  else if (strcmp (name, "CFM") == 0)
    return IA64_RS_CFM;
  else if (strcmp (name, "PR63") == 0)
    return IA64_RS_PR63;
  else if (strcmp (name, "RSE") == 0)
    return IA64_RS_RSE;

  return IA64_RS_ANY;
}

static void
print_dependency_table (void)
{
  int i, j;

  if (debug) 
    {
      for (i=0;i < iclen;i++)
        {
          if (ics[i]->is_class)
            {
              if (!ics[i]->nsubs)
                {
                  if (ics[i]->comment)
		    warn (_("IC:%s [%s] has no terminals or sub-classes\n"),
			  ics[i]->name, ics[i]->comment);
		  else
		    warn (_("IC:%s has no terminals or sub-classes\n"),
			  ics[i]->name);
                }
            }
          else 
            {
              if (!ics[i]->terminal_resolved && !ics[i]->orphan)
                {
                  if (ics[i]->comment)
		    warn (_("no insns mapped directly to terminal IC %s [%s]"),
			  ics[i]->name, ics[i]->comment);
		  else
		    warn (_("no insns mapped directly to terminal IC %s\n"),
			  ics[i]->name);
                }
            }
        }

      for (i = 0; i < iclen; i++)
        {
          if (ics[i]->orphan)
            {
              mark_used (ics[i], 1);
              warn (_("class %s is defined but not used\n"),
		    ics[i]->name);
            }
        }

      if (debug > 1)
	for (i = 0; i < rdepslen; i++)
	  {  
	    static const char *mode_str[] = { "RAW", "WAW", "WAR" };

	    if (rdeps[i]->total_chks == 0)
	      {
		if (rdeps[i]->total_regs)
		  warn (_("Warning: rsrc %s (%s) has no chks\n"), 
			rdeps[i]->name, mode_str[rdeps[i]->mode]);
		else
		  warn (_("Warning: rsrc %s (%s) has no chks or regs\n"), 
			rdeps[i]->name, mode_str[rdeps[i]->mode]);
	      }
	    else if (rdeps[i]->total_regs == 0)
	      warn (_("rsrc %s (%s) has no regs\n"),
		    rdeps[i]->name, mode_str[rdeps[i]->mode]);
	  }
    }

  /* The dependencies themselves.  */
  printf ("static const struct ia64_dependency\ndependencies[] = {\n");
  for (i = 0; i < rdepslen; i++)
    {
      /* '%', '#', AR[], CR[], or PSR. indicates we need to specify the actual
         resource used.  */ 
      int specifier = lookup_specifier (rdeps[i]->name);
      int regindex = lookup_regindex (rdeps[i]->name, specifier);

      printf ("  { \"%s\", %d, %d, %d, %d, ",
              rdeps[i]->name, specifier,
              (int)rdeps[i]->mode, (int)rdeps[i]->semantics, regindex);
      if (rdeps[i]->semantics == IA64_DVS_OTHER)
	{
	  const char *quote, *rest;

	  putchar ('\"');
	  rest = rdeps[i]->extra;
	  quote = strchr (rest, '\"');
	  while (quote != NULL)
	    {
	      printf ("%.*s\\\"", (int) (quote - rest), rest);
	      rest = quote + 1;
	      quote = strchr (rest, '\"');
	    }
	  printf ("%s\", ", rest);
	}
      else
	printf ("NULL, ");
      printf("},\n");
    }
  printf ("};\n\n");

  /* And dependency lists.  */
  for (i=0;i < dlistlen;i++)
    {
      int len = 2;
      printf ("static const unsigned short dep%d[] = {\n  ", i);
      for (j=0;j < dlists[i]->len; j++)
        {
          len += printf ("%d, ", dlists[i]->deps[j]);
          if (len > 75)
            {
              printf("\n  ");
              len = 2;
            }
        }
      printf ("\n};\n\n");
    }

  /* And opcode dependency list.  */
  printf ("#define NELS(X) (sizeof(X)/sizeof(X[0]))\n");
  printf ("static const struct ia64_opcode_dependency\n");
  printf ("op_dependencies[] = {\n");
  for (i = 0; i < opdeplen; i++)
    {
      printf ("  { ");
      if (opdeps[i]->chk == -1)
        printf ("0, NULL, ");
      else 
        printf ("NELS(dep%d), dep%d, ", opdeps[i]->chk, opdeps[i]->chk);
      if (opdeps[i]->reg == -1)
        printf ("0, NULL, ");
      else 
        printf ("NELS(dep%d), dep%d, ", opdeps[i]->reg, opdeps[i]->reg);
      printf ("},\n");
    }
  printf ("};\n\n");
}


/* Add STR to the string table.  */
static struct string_entry *
insert_string (char *str)
{
  int start = 0, end = strtablen;
  int i, x;

  if (strtablen == strtabtotlen)
    {
      strtabtotlen += 20;
      string_table = (struct string_entry **)
	xrealloc (string_table, 
		  sizeof (struct string_entry **) * strtabtotlen);
    }

  if (strtablen == 0)
    {
      strtablen = 1;
      string_table[0] = tmalloc (struct string_entry);
      string_table[0]->s = xstrdup (str);
      string_table[0]->num = 0;
      return string_table[0];
    }

  if (strcmp (str, string_table[strtablen - 1]->s) > 0)
    i = end;
  else if (strcmp (str, string_table[0]->s) < 0)
    i = 0;
  else
    {
      while (1)
	{
	  int c;

	  i = (start + end) / 2;
	  c = strcmp (str, string_table[i]->s);

	  if (c < 0)
	    end = i - 1;
	  else if (c == 0)
	    return string_table[i];
	  else
	    start = i + 1;

	  if (start > end)
	    break;
	}
    }

  for (; i > 0 && i < strtablen; i--)
    if (strcmp (str, string_table[i - 1]->s) > 0)
      break;

  for (; i < strtablen; i++)
    if (strcmp (str, string_table[i]->s) < 0)
      break;

  for (x = strtablen - 1; x >= i; x--)
    {
      string_table[x + 1] = string_table[x];
      string_table[x + 1]->num = x + 1;
    }

  string_table[i] = tmalloc (struct string_entry);
  string_table[i]->s = xstrdup (str);
  string_table[i]->num = i;
  strtablen++;

  return string_table[i];
}

static struct bittree *
make_bittree_entry (void)
{
  struct bittree *res = tmalloc (struct bittree);

  res->disent = NULL;
  res->bits[0] = NULL;
  res->bits[1] = NULL;
  res->bits[2] = NULL;
  res->skip_flag = 0;
  res->bits_to_skip = 0;
  return res;
}
 

static struct disent *
add_dis_table_ent (struct disent *which, int insn, int order,
                   ci_t completer_index)
{
  int ci = 0;
  struct disent *ent;

  if (which != NULL)
    {
      ent = which;

      ent->nextcnt++;
      while (ent->nexte != NULL)
	ent = ent->nexte;

      ent = (ent->nexte = tmalloc (struct disent));
    }
  else
    {
      ent = tmalloc (struct disent);
      ent->next_ent = disinsntable;
      disinsntable = ent;
      which = ent;
    }
  ent->nextcnt = 0;
  ent->nexte = NULL;
  ent->insn = insn;
  ent->priority = order;

  while (completer_index != 1)
    {
      ci = (ci << 1) | (completer_index & 1);
      completer_index >>= 1;
    }
  ent->completer_index = ci;
  return which;
}

static void
finish_distable (void)
{
  struct disent *ent = disinsntable;
  struct disent *prev = ent;

  ent->ournum = 32768;
  while ((ent = ent->next_ent) != NULL)
    {
      ent->ournum = prev->ournum + prev->nextcnt + 1;
      prev = ent;
    }
}

static void
insert_bit_table_ent (struct bittree *curr_ent, int bit, ia64_insn opcode,
                      ia64_insn mask, int opcodenum, int order,
                      ci_t completer_index)
{
  ia64_insn m;
  int b;
  struct bittree *next;

  if (bit == -1)
    {
      struct disent *nent = add_dis_table_ent (curr_ent->disent, 
                                               opcodenum, order,
					       completer_index);
      curr_ent->disent = nent;
      return;
    }

  m = ((ia64_insn) 1) << bit;

  if (mask & m)
    b = (opcode & m) ? 1 : 0;
  else
    b = 2;

  next = curr_ent->bits[b];
  if (next == NULL)
    {
      next = make_bittree_entry ();
      curr_ent->bits[b] = next;
    }
  insert_bit_table_ent (next, bit - 1, opcode, mask, opcodenum, order,
			completer_index);
}

static void
add_dis_entry (struct bittree *first, ia64_insn opcode, ia64_insn mask,
               int opcodenum, struct completer_entry *ent, ci_t completer_index)
{
  if (completer_index & ((ci_t)1 << 32) )
    abort ();

  while (ent != NULL)
    {
      ia64_insn newopcode = (opcode & (~ ent->mask)) | ent->bits;
      add_dis_entry (first, newopcode, mask, opcodenum, ent->addl_entries,
		     (completer_index << 1) | 1);

      if (ent->is_terminal)
	{
	  insert_bit_table_ent (bittree, 40, newopcode, mask, 
                                opcodenum, opcode_count - ent->order - 1, 
				(completer_index << 1) | 1);
	}
      completer_index <<= 1;
      ent = ent->alternative;
    }
}

/* This optimization pass combines multiple "don't care" nodes.  */
static void
compact_distree (struct bittree *ent)
{
#define IS_SKIP(ent) \
    ((ent->bits[2] !=NULL) \
     && (ent->bits[0] == NULL && ent->bits[1] == NULL && ent->skip_flag == 0))

  int bitcnt = 0;
  struct bittree *nent = ent;
  int x;

  while (IS_SKIP (nent))
    {
      bitcnt++;
      nent = nent->bits[2];
    }

  if (bitcnt)
    {
      struct bittree *next = ent->bits[2];

      ent->bits[0] = nent->bits[0];
      ent->bits[1] = nent->bits[1];
      ent->bits[2] = nent->bits[2];
      ent->disent = nent->disent;
      ent->skip_flag = 1;
      ent->bits_to_skip = bitcnt;
      while (next != nent)
	{
	  struct bittree *b = next;
	  next = next->bits[2];
	  free (b);
	}
      free (nent);
    }

  for (x = 0; x < 3; x++)
    {
      struct bittree *i = ent->bits[x];

      if (i != NULL)
	compact_distree (i);
    }
}

static unsigned char *insn_list;
static int insn_list_len = 0;
static int tot_insn_list_len = 0;

/* Generate the disassembler state machine corresponding to the tree
   in ENT.  */
static void
gen_dis_table (struct bittree *ent)
{
  int x;
  int our_offset = insn_list_len;
  int bitsused = 5;
  int totbits = bitsused;
  int needed_bytes;
  int zero_count = 0;
  int zero_dest = 0;	/* Initialize this with 0 to keep gcc quiet...  */

  /* If this is a terminal entry, there's no point in skipping any
     bits.  */
  if (ent->skip_flag && ent->bits[0] == NULL && ent->bits[1] == NULL &&
      ent->bits[2] == NULL)
    {
      if (ent->disent == NULL)
	abort ();
      else
	ent->skip_flag = 0;
    }

  /* Calculate the amount of space needed for this entry, or at least
     a conservatively large approximation.  */
  if (ent->skip_flag)
    totbits += 5;

  for (x = 1; x < 3; x++)
    if (ent->bits[x] != NULL)
      totbits += 16;

  if (ent->disent != NULL)
    {
      if (ent->bits[2] != NULL)
	abort ();

      totbits += 16;
    }

  /* Now allocate the space.  */
  needed_bytes = (totbits + 7) / 8;
  if ((needed_bytes + insn_list_len) > tot_insn_list_len)
    {
      tot_insn_list_len += 256;
      insn_list = (unsigned char *) xrealloc (insn_list, tot_insn_list_len);
    }
  our_offset = insn_list_len;
  insn_list_len += needed_bytes;
  memset (insn_list + our_offset, 0, needed_bytes);

  /* Encode the skip entry by setting bit 6 set in the state op field,
     and store the # of bits to skip immediately after.  */
  if (ent->skip_flag)
    {
      bitsused += 5;
      insn_list[our_offset + 0] |= 0x40 | ((ent->bits_to_skip >> 2) & 0xf);
      insn_list[our_offset + 1] |= ((ent->bits_to_skip & 3) << 6);
    }

#define IS_ONLY_IFZERO(ENT) \
  ((ENT)->bits[0] != NULL && (ENT)->bits[1] == NULL && (ENT)->bits[2] == NULL \
   && (ENT)->disent == NULL && (ENT)->skip_flag == 0)

  /* Store an "if (bit is zero)" instruction by setting bit 7 in the
     state op field.  */
  if (ent->bits[0] != NULL)
    {
      struct bittree *nent = ent->bits[0];
      zero_count = 0;

      insn_list[our_offset] |= 0x80;

      /* We can encode sequences of multiple "if (bit is zero)" tests
	 by storing the # of zero bits to check in the lower 3 bits of
	 the instruction.  However, this only applies if the state
	 solely tests for a zero bit.  */

      if (IS_ONLY_IFZERO (ent))
	{
	  while (IS_ONLY_IFZERO (nent) && zero_count < 7)
	    {
	      nent = nent->bits[0];
	      zero_count++;
	    }

	  insn_list[our_offset + 0] |= zero_count;
	}
      zero_dest = insn_list_len;
      gen_dis_table (nent);
    }

  /* Now store the remaining tests.  We also handle a sole "termination
     entry" by storing it as an "any bit" test.  */

  for (x = 1; x < 3; x++)
    {
      if (ent->bits[x] != NULL || (x == 2 && ent->disent != NULL))
	{
	  struct bittree *i = ent->bits[x];
	  int idest;
	  int currbits = 15;

	  if (i != NULL)
	    {
	      /* If the instruction being branched to only consists of
		 a termination entry, use the termination entry as the
		 place to branch to instead.  */
	      if (i->bits[0] == NULL && i->bits[1] == NULL
		  && i->bits[2] == NULL && i->disent != NULL)
		{
		  idest = i->disent->ournum;
		  i = NULL;
		}
	      else
		idest = insn_list_len - our_offset;
	    }
	  else
	    idest = ent->disent->ournum;

	  /* If the destination offset for the if (bit is 1) test is less 
	     than 256 bytes away, we can store it as 8-bits instead of 16;
	     the instruction has bit 5 set for the 16-bit address, and bit
	     4 for the 8-bit address.  Since we've already allocated 16
	     bits for the address we need to deallocate the space.

	     Note that branchings within the table are relative, and
	     there are no branches that branch past our instruction yet
	     so we do not need to adjust any other offsets.  */
	  if (x == 1)
	    {
	      if (idest <= 256)
		{
		  int start = our_offset + bitsused / 8 + 1;

		  memmove (insn_list + start,
			   insn_list + start + 1,
			   insn_list_len - (start + 1));
		  currbits = 7;
		  totbits -= 8;
		  needed_bytes--;
		  insn_list_len--;
		  insn_list[our_offset] |= 0x10;
		  idest--;
		}
	      else
		insn_list[our_offset] |= 0x20;
	    }
	  else
	    {
	      /* An instruction which solely consists of a termination
		 marker and whose disassembly name index is < 4096
		 can be stored in 16 bits.  The encoding is slightly
		 odd; the upper 4 bits of the instruction are 0x3, and
		 bit 3 loses its normal meaning.  */

	      if (ent->bits[0] == NULL && ent->bits[1] == NULL
		  && ent->bits[2] == NULL && ent->skip_flag == 0
		  && ent->disent != NULL
		  && ent->disent->ournum < (32768 + 4096))
		{
		  int start = our_offset + bitsused / 8 + 1;

		  memmove (insn_list + start,
			   insn_list + start + 1,
			   insn_list_len - (start + 1));
		  currbits = 11;
		  totbits -= 5;
		  bitsused--;
		  needed_bytes--;
		  insn_list_len--;
		  insn_list[our_offset] |= 0x30;
		  idest &= ~32768;
		}
	      else
		insn_list[our_offset] |= 0x08;
	    }

	  if (debug)
	    {
	      int id = idest;

	      if (i == NULL)
		id |= 32768;
	      else if (! (id & 32768))
		id += our_offset;

	      if (x == 1)
		printf ("%d: if (1) goto %d\n", our_offset, id);
	      else
		printf ("%d: try %d\n", our_offset, id);
	    }

	  /* Store the address of the entry being branched to.  */
	  while (currbits >= 0)
	    {
	      unsigned char *byte = insn_list + our_offset + bitsused / 8;

	      if (idest & (1 << currbits))
		*byte |= (1 << (7 - (bitsused % 8)));

	      bitsused++;
	      currbits--;
	    }

	  /* Now generate the states for the entry being branched to.  */
	  if (i != NULL)
	    gen_dis_table (i);
	}
    }

  if (debug)
    {
      if (ent->skip_flag)
	printf ("%d: skipping %d\n", our_offset, ent->bits_to_skip);
  
      if (ent->bits[0] != NULL)
	printf ("%d: if (0:%d) goto %d\n", our_offset, zero_count + 1,
		zero_dest);
    }

  if (bitsused != totbits)
    abort ();
}

static void
print_dis_table (void)
{
  int x;
  struct disent *cent = disinsntable;

  printf ("static const char dis_table[] = {\n");
  for (x = 0; x < insn_list_len; x++)
    {
      if ((x > 0) && ((x % 12) == 0))
	printf ("\n");

      printf ("0x%02x, ", insn_list[x]);
    }
  printf ("\n};\n\n");

  printf ("static const struct ia64_dis_names ia64_dis_names[] = {\n");
  while (cent != NULL)
    {
      struct disent *ent = cent;

      while (ent != NULL)
	{
	  printf ("{ 0x%lx, %d, %d, %d },\n", ( long ) ent->completer_index,
		  ent->insn, (ent->nexte != NULL ? 1 : 0),
                  ent->priority);
	  ent = ent->nexte;
	}
      cent = cent->next_ent;
    }
  printf ("};\n\n");
}

static void
generate_disassembler (void)
{
  int i;

  bittree = make_bittree_entry ();

  for (i = 0; i < otlen; i++)
    {
      struct main_entry *ptr = ordered_table[i];

      if (ptr->opcode->type != IA64_TYPE_DYN)
	add_dis_entry (bittree,
		       ptr->opcode->opcode, ptr->opcode->mask, 
		       ptr->main_index,
		       ptr->completers, 1);
    }

  compact_distree (bittree);
  finish_distable ();
  gen_dis_table (bittree);

  print_dis_table ();
}

static void
print_string_table (void)
{
  int x;
  char lbuf[80], buf[80];
  int blen = 0;

  printf ("static const char * const ia64_strings[] = {\n");
  lbuf[0] = '\0';

  for (x = 0; x < strtablen; x++)
    {
      int len;
      
      if (strlen (string_table[x]->s) > 75)
	abort ();

      sprintf (buf, " \"%s\",", string_table[x]->s);
      len = strlen (buf);

      if ((blen + len) > 75)
	{
	  printf (" %s\n", lbuf);
	  lbuf[0] = '\0';
	  blen = 0;
	}
      strcat (lbuf, buf);
      blen += len;
    }

  if (blen > 0)
    printf (" %s\n", lbuf);

  printf ("};\n\n");
}

static struct completer_entry **glist;
static int glistlen = 0;
static int glisttotlen = 0;

/* If the completer trees ENT1 and ENT2 are equal, return 1.  */

static int
completer_entries_eq (struct completer_entry *ent1,
                      struct completer_entry *ent2)
{
  while (ent1 != NULL && ent2 != NULL)
    {
      if (ent1->name->num != ent2->name->num
	  || ent1->bits != ent2->bits
	  || ent1->mask != ent2->mask
	  || ent1->is_terminal != ent2->is_terminal
          || ent1->dependencies != ent2->dependencies
          || ent1->order != ent2->order)
	return 0;

      if (! completer_entries_eq (ent1->addl_entries, ent2->addl_entries))
	return 0;

      ent1 = ent1->alternative;
      ent2 = ent2->alternative;
    }

  return ent1 == ent2;
}

/* Insert ENT into the global list of completers and return it.  If an
   equivalent entry (according to completer_entries_eq) already exists,
   it is returned instead.  */
static struct completer_entry *
insert_gclist (struct completer_entry *ent)
{
  if (ent != NULL)
    {
      int i;
      int x;
      int start = 0, end;

      ent->addl_entries = insert_gclist (ent->addl_entries);
      ent->alternative = insert_gclist (ent->alternative);

      i = glistlen / 2;
      end = glistlen;

      if (glisttotlen == glistlen)
	{
	  glisttotlen += 20;
	  glist = (struct completer_entry **)
	    xrealloc (glist, sizeof (struct completer_entry *) * glisttotlen);
	}

      if (glistlen == 0)
	{
	  glist[0] = ent;
	  glistlen = 1;
	  return ent;
	}

      if (ent->name->num < glist[0]->name->num)
	i = 0;
      else if (ent->name->num > glist[end - 1]->name->num)
	i = end;
      else
	{
	  int c;

	  while (1)
	    {
	      i = (start + end) / 2;
	      c = ent->name->num - glist[i]->name->num;

	      if (c < 0)
		end = i - 1;
	      else if (c == 0)
		{
		  while (i > 0 
			 && ent->name->num == glist[i - 1]->name->num)
		    i--;

		  break;
		}
	      else
		start = i + 1;

	      if (start > end)
		break;
	    }

	  if (c == 0)
	    {
	      while (i < glistlen)
		{
		  if (ent->name->num != glist[i]->name->num)
		    break;

		  if (completer_entries_eq (ent, glist[i]))
		    return glist[i];

		  i++;
		}
	    }
	}

      for (; i > 0 && i < glistlen; i--)
	if (ent->name->num >= glist[i - 1]->name->num)
	  break;

      for (; i < glistlen; i++)
	if (ent->name->num < glist[i]->name->num)
	  break;

      for (x = glistlen - 1; x >= i; x--)
	glist[x + 1] = glist[x];

      glist[i] = ent;
      glistlen++;
    }
  return ent;
}

static int
get_prefix_len (const char *name)
{
  char *c;

  if (name[0] == '\0')
    return 0;

  c = strchr (name, '.');
  if (c != NULL)
    return c - name;
  else
    return strlen (name);
}

static void
compute_completer_bits (struct main_entry *ment, struct completer_entry *ent)
{
  while (ent != NULL)
    {
      compute_completer_bits (ment, ent->addl_entries);

      if (ent->is_terminal)
	{
	  ia64_insn mask = 0;
	  ia64_insn our_bits = ent->bits;
	  struct completer_entry *p = ent->parent;
	  ia64_insn p_bits;
	  int x;

	  while (p != NULL && ! p->is_terminal)
	    p = p->parent;
      
	  if (p != NULL)
	    p_bits = p->bits;
	  else
	    p_bits = ment->opcode->opcode;

	  for (x = 0; x < 64; x++)
	    {
	      ia64_insn m = ((ia64_insn) 1) << x;

	      if ((p_bits & m) != (our_bits & m))
		mask |= m;
	      else
		our_bits &= ~m;
	    }
	  ent->bits = our_bits;
	  ent->mask = mask;
	}
      else
	{
	  ent->bits = 0;
	  ent->mask = 0;
	}

      ent = ent->alternative;
    }
}

/* Find identical completer trees that are used in different
   instructions and collapse their entries.  */
static void
collapse_redundant_completers (void)
{
  struct main_entry *ptr;
  int x;

  for (ptr = maintable; ptr != NULL; ptr = ptr->next)
    {
      if (ptr->completers == NULL)
	abort ();

      compute_completer_bits (ptr, ptr->completers);
      ptr->completers = insert_gclist (ptr->completers);
    }

  /* The table has been finalized, now number the indexes.  */
  for (x = 0; x < glistlen; x++)
    glist[x]->num = x;
}


/* Attach two lists of dependencies to each opcode.
   1) all resources which, when already marked in use, conflict with this
   opcode (chks) 
   2) all resources which must be marked in use when this opcode is used
   (regs).  */
static int
insert_opcode_dependencies (struct ia64_opcode *opc,
                            struct completer_entry *cmp ATTRIBUTE_UNUSED)
{
  /* Note all resources which point to this opcode.  rfi has the most chks
     (79) and cmpxchng has the most regs (54) so 100 here should be enough.  */
  int i;
  int nregs = 0;
  unsigned short regs[256];                  
  int nchks = 0;
  unsigned short chks[256];
  /* Flag insns for which no class matched; there should be none.  */
  int no_class_found = 1;

  for (i = 0; i < rdepslen; i++)
    {
      struct rdep *rs = rdeps[i];
      int j;

      if (strcmp (opc->name, "cmp.eq.and") == 0
          && CONST_STRNEQ (rs->name, "PR%")
          && rs->mode == 1)
        no_class_found = 99;

      for (j=0; j < rs->nregs;j++)
        {
          int ic_note = 0;

          if (in_iclass (opc, ics[rs->regs[j]], NULL, NULL, &ic_note))
            {
              /* We can ignore ic_note 11 for non PR resources.  */
              if (ic_note == 11 && ! CONST_STRNEQ (rs->name, "PR"))
                ic_note = 0;

              if (ic_note != 0 && rs->regnotes[j] != 0
                  && ic_note != rs->regnotes[j]
                  && !(ic_note == 11 && rs->regnotes[j] == 1))
                warn (_("IC note %d in opcode %s (IC:%s) conflicts with resource %s note %d\n"),
		      ic_note, opc->name, ics[rs->regs[j]]->name,
		      rs->name, rs->regnotes[j]);
              /* Instruction class notes override resource notes.
                 So far, only note 11 applies to an IC instead of a resource,
                 and note 11 implies note 1.  */
              if (ic_note)
                regs[nregs++] = RDEP(ic_note, i);
              else
                regs[nregs++] = RDEP(rs->regnotes[j], i);
              no_class_found = 0;
              ++rs->total_regs;
            }
        }

      for (j = 0; j < rs->nchks; j++)
        {
          int ic_note = 0;

          if (in_iclass (opc, ics[rs->chks[j]], NULL, NULL, &ic_note))
            {
              /* We can ignore ic_note 11 for non PR resources.  */
              if (ic_note == 11 && ! CONST_STRNEQ (rs->name, "PR"))
                ic_note = 0;

              if (ic_note != 0 && rs->chknotes[j] != 0
                  && ic_note != rs->chknotes[j]
                  && !(ic_note == 11 && rs->chknotes[j] == 1))
                warn (_("IC note %d for opcode %s (IC:%s) conflicts with resource %s note %d\n"),
		      ic_note, opc->name, ics[rs->chks[j]]->name,
		      rs->name, rs->chknotes[j]);
              if (ic_note)
                chks[nchks++] = RDEP(ic_note, i);
              else
                chks[nchks++] = RDEP(rs->chknotes[j], i);
              no_class_found = 0;
              ++rs->total_chks;
            }
        }
    }

  if (no_class_found)
    warn (_("opcode %s has no class (ops %d %d %d)\n"),
	  opc->name, 
	  opc->operands[0], opc->operands[1], opc->operands[2]);

  return insert_dependencies (nchks, chks, nregs, regs);
}

static void
insert_completer_entry (struct ia64_opcode *opc, struct main_entry *tabent,
                        int order)
{
  struct completer_entry **ptr = &tabent->completers;
  struct completer_entry *parent = NULL;
  char pcopy[129], *prefix;
  int at_end = 0;

  if (strlen (opc->name) > 128)
    abort ();

  strcpy (pcopy, opc->name);
  prefix = pcopy + get_prefix_len (pcopy);

  if (prefix[0] != '\0')
    prefix++;

  while (! at_end)
    {
      int need_new_ent = 1;
      int plen = get_prefix_len (prefix);
      struct string_entry *sent;

      at_end = (prefix[plen] == '\0');
      prefix[plen] = '\0';
      sent = insert_string (prefix);

      while (*ptr != NULL)
	{
	  int cmpres = sent->num - (*ptr)->name->num;

	  if (cmpres == 0)
	    {
	      need_new_ent = 0;
	      break;
	    }
	  else
	    ptr = &((*ptr)->alternative);
	}

      if (need_new_ent)
	{
	  struct completer_entry *nent = tmalloc (struct completer_entry);

	  nent->name = sent;
	  nent->parent = parent;
	  nent->addl_entries = NULL;
	  nent->alternative = *ptr;
	  *ptr = nent;
	  nent->is_terminal = 0;
          nent->dependencies = -1;
	}

      if (! at_end)
	{
	  parent = *ptr;
	  ptr = &((*ptr)->addl_entries);
	  prefix += plen + 1;
	}
    }

  if ((*ptr)->is_terminal)
    abort ();

  (*ptr)->is_terminal = 1;
  (*ptr)->mask = (ia64_insn)-1;
  (*ptr)->bits = opc->opcode;
  (*ptr)->dependencies = insert_opcode_dependencies (opc, *ptr);
  (*ptr)->order = order;
}

static void
print_completer_entry (struct completer_entry *ent)
{
  int moffset = 0;
  ia64_insn mask = ent->mask, bits = ent->bits;

  if (mask != 0)
    {
      while (! (mask & 1))
	{
	  moffset++;
	  mask = mask >> 1;
	  bits = bits >> 1;
	}

      if (bits & 0xffffffff00000000LL)
	abort ();
    }
  
  printf ("  { 0x%x, 0x%x, %d, %d, %d, %d, %d, %d },\n",
	  (int)bits,
	  (int)mask,
	  ent->name->num,
	  ent->alternative != NULL ? ent->alternative->num : -1,
	  ent->addl_entries != NULL ? ent->addl_entries->num : -1,
	  moffset,
	  ent->is_terminal ? 1 : 0,
          ent->dependencies);
}

static void
print_completer_table (void)
{
  int x;

  printf ("static const struct ia64_completer_table\ncompleter_table[] = {\n");
  for (x = 0; x < glistlen; x++)
    print_completer_entry (glist[x]);
  printf ("};\n\n");
}

static int
opcodes_eq (struct ia64_opcode *opc1, struct ia64_opcode *opc2)
{
  int x;
  int plen1, plen2;

  if ((opc1->mask != opc2->mask) || (opc1->type != opc2->type) 
      || (opc1->num_outputs != opc2->num_outputs)
      || (opc1->flags != opc2->flags))
    return 0;

  for (x = 0; x < 5; x++)
    if (opc1->operands[x] != opc2->operands[x])
      return 0;

  plen1 = get_prefix_len (opc1->name);
  plen2 = get_prefix_len (opc2->name);

  if (plen1 == plen2 && (memcmp (opc1->name, opc2->name, plen1) == 0))
    return 1;

  return 0;
}

static void
add_opcode_entry (struct ia64_opcode *opc)
{
  struct main_entry **place;
  struct string_entry *name;
  char prefix[129];
  int found_it = 0;

  if (strlen (opc->name) > 128)
    abort ();

  place = &maintable;
  strcpy (prefix, opc->name);
  prefix[get_prefix_len (prefix)] = '\0';
  name = insert_string (prefix);

  /* Walk the list of opcode table entries.  If it's a new
     instruction, allocate and fill in a new entry.  Note 
     the main table is alphabetical by opcode name.  */

  while (*place != NULL)
    {
      if ((*place)->name->num == name->num
	  && opcodes_eq ((*place)->opcode, opc))
	{
	  found_it = 1;
	  break;
	}
      if ((*place)->name->num > name->num)
	break;

      place = &((*place)->next);
    }
  if (! found_it)
    {
      struct main_entry *nent = tmalloc (struct main_entry);

      nent->name = name;
      nent->opcode = opc;
      nent->next = *place;
      nent->completers = 0;
      *place = nent;

      if (otlen == ottotlen)
        {
          ottotlen += 20;
          ordered_table = (struct main_entry **)
            xrealloc (ordered_table, sizeof (struct main_entry *) * ottotlen);
        }
      ordered_table[otlen++] = nent;
    }

  insert_completer_entry (opc, *place, opcode_count++);
}

static void
print_main_table (void)
{
  struct main_entry *ptr = maintable;
  int tindex = 0;

  printf ("static const struct ia64_main_table\nmain_table[] = {\n");
  while (ptr != NULL)
    {
      printf ("  { %d, %d, %d, 0x",
	      ptr->name->num,
	      ptr->opcode->type,
	      ptr->opcode->num_outputs);
      opcode_fprintf_vma (stdout, ptr->opcode->opcode);
      printf ("ull, 0x");
      opcode_fprintf_vma (stdout, ptr->opcode->mask);
      printf ("ull, { %d, %d, %d, %d, %d }, 0x%x, %d, },\n",
	      ptr->opcode->operands[0],
	      ptr->opcode->operands[1],
	      ptr->opcode->operands[2],
	      ptr->opcode->operands[3],
	      ptr->opcode->operands[4],
	      ptr->opcode->flags,
	      ptr->completers->num);

      ptr->main_index = tindex++;

      ptr = ptr->next;
    }
  printf ("};\n\n");
}

static void
shrink (struct ia64_opcode *table)
{
  int curr_opcode;

  for (curr_opcode = 0; table[curr_opcode].name != NULL; curr_opcode++)
    {
      add_opcode_entry (table + curr_opcode);
      if (table[curr_opcode].num_outputs == 2
	  && ((table[curr_opcode].operands[0] == IA64_OPND_P1
	       && table[curr_opcode].operands[1] == IA64_OPND_P2)
	      || (table[curr_opcode].operands[0] == IA64_OPND_P2
		  && table[curr_opcode].operands[1] == IA64_OPND_P1)))
	{
	  struct ia64_opcode *alias = tmalloc(struct ia64_opcode);
	  unsigned i;

	  *alias = table[curr_opcode];
	  for (i = 2; i < NELEMS (alias->operands); ++i)
	    alias->operands[i - 1] = alias->operands[i];
	  alias->operands[NELEMS (alias->operands) - 1] = IA64_OPND_NIL;
	  --alias->num_outputs;
	  alias->flags |= PSEUDO;
	  add_opcode_entry (alias);
	}
    }
}


/* Program options.  */
#define OPTION_SRCDIR	200

struct option long_options[] = 
{
  {"srcdir",  required_argument, NULL, OPTION_SRCDIR},
  {"debug",   no_argument,       NULL, 'd'},
  {"version", no_argument,       NULL, 'V'},
  {"help",    no_argument,       NULL, 'h'},
  {0,         no_argument,       NULL, 0}
};

static void
print_version (void)
{
  printf ("%s: version 1.0\n", program_name);
  xexit (0);
}

static void
usage (FILE * stream, int status)
{
  fprintf (stream, "Usage: %s [-V | --version] [-d | --debug] [--srcdir=dirname] [--help]\n",
	   program_name);
  xexit (status);
}

int
main (int argc, char **argv)
{
  extern int chdir (char *);
  char *srcdir = NULL;
  int c;
  
  program_name = *argv;
  xmalloc_set_program_name (program_name);

  while ((c = getopt_long (argc, argv, "vVdh", long_options, 0)) != EOF)
    switch (c)
      {
      case OPTION_SRCDIR:
	srcdir = optarg;
	break;
      case 'V':
      case 'v':
	print_version ();
	break;
      case 'd':
	debug = 1;
	break;
      case 'h':
      case '?':
	usage (stderr, 0);
      default:
      case 0:
	break;
      }

  if (optind != argc)
    usage (stdout, 1);

  if (srcdir != NULL) 
    if (chdir (srcdir) != 0)
      fail (_("unable to change directory to \"%s\", errno = %s\n"),
	    srcdir, strerror (errno));

  load_insn_classes ();
  load_dependencies ();

  shrink (ia64_opcodes_a);
  shrink (ia64_opcodes_b);
  shrink (ia64_opcodes_f);
  shrink (ia64_opcodes_i);
  shrink (ia64_opcodes_m);
  shrink (ia64_opcodes_x);
  shrink (ia64_opcodes_d);

  collapse_redundant_completers ();

  printf ("/* This file is automatically generated by ia64-gen.  Do not edit!  */\n");
  printf ("/* Copyright 2007  Free Software Foundation, Inc.\n\
\n\
   This file is part of the GNU opcodes library.\n\
\n\
   This library is free software; you can redistribute it and/or modify\n\
   it under the terms of the GNU General Public License as published by\n\
   the Free Software Foundation; either version 3, or (at your option)\n\
   any later version.\n\
\n\
   It is distributed in the hope that it will be useful, but WITHOUT\n\
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n\
   License for more details.\n\
\n\
   You should have received a copy of the GNU General Public License\n\
   along with this program; see the file COPYING.  If not, write to the\n\
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA\n\
   02110-1301, USA.  */\n");

  print_string_table ();
  print_dependency_table ();
  print_completer_table ();
  print_main_table ();

  generate_disassembler ();

  exit (0);
}
@


1.31
log
@Add Intel Itanium Series 9500 support

bfd/

2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* cpu-ia64-opc.c (ins_cnt6a): New function.
	(ext_cnt6a): Ditto.
	(ins_strd5b): Ditto.
	(ext_strd5b): Ditto.
	(elf64_ia64_operands): Add new operand types.

gas/

2012-09-04  Sergey A. Guriev  <sergey.a.guriev@@intel.com>

	* config/tc-ia64.c (reg_symbol): Add a new register.
	(indirect_reg): Ditto.
	(pseudo_func): Add new symbolic constants.
	(operand_match): Add new operand types recognition.
	(operand_insn): Add new register recognition.
	(md_begin): Add new register definition.
	(specify_resource): Add new register recognition.

gas/testsuite/

2012-09-04  Sergey A. Guriev  <sergey.a.guriev@@intel.com>

	* gas/testsuite/gas/ia64/psn.d: New file.
	* gas/testsuite/gas/ia64/psn.s: New file.
	* gas/testsuite/gas/ia64/ia64.exp: Add new testcase.
	* gas/testsuite/gas/ia64/opc-i.d: Fixed failing tests.
	* gas/testsuite/gas/ia64/opc-m.d: Ditto.

include/opcode/

2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* ia64.h (ia64_opnd): Add new operand types.

opcodes/

2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* ia64-asmtab.h (completer_index): Extend bitfield to full uint.
	* ia64-gen.c: Promote completer index type to longlong.
	(irf_operand): Add new register recognition.
	(in_iclass_mov_x): Add an entry for the new mov_* instruction type.
	(lookup_specifier): Add new resource recognition.
	(insert_bit_table_ent): Relax abort condition according to the
	changed completer index type.
	(print_dis_table): Fix printf format for completer index.
	* ia64-ic.tbl: Add a new instruction class.
	* ia64-opc-i.c (ia64_opcodes_i): Define new I-instructions.
	* ia64-opc-m.c (ia64_opcodes_m): Define new M-instructions.
	* ia64-opc.h: Define short names for new operand types.
	* ia64-raw.tbl: Add new RAW resource for DAHR register.
	* ia64-waw.tbl: Add new WAW resource for DAHR register.
	* ia64-asmtab.c: Regenerate.
@
text
@d573 1
a573 1
      ics[ind]->subs[0] = fetch_insn_class (subname, 1);;
@


1.30
log
@	* arc-dis.c: Include sysdep.h first, remove some redundant includes.
	* bfin-dis.c: Likewise.
	* i860-dis.c: Likewise.
	* ia64-dis.c: Likewise.
	* ia64-gen.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* mmix-dis.c: Likewise.
	* msp430-dis.c: Likewise.
	* or32-dis.c: Likewise.
	* rl78-dis.c: Likewise.
	* rx-dis.c: Likewise.
	* tic4x-dis.c: Likewise.
	* tilegx-opc.c: Likewise.
	* tilepro-opc.c: Likewise.
	* rx-decode.c: Regenerate.
@
text
@d72 1
d150 1
a150 1
  int completer_index;
d294 2
a295 2
static void insert_bit_table_ent (struct bittree *, int, ia64_insn, ia64_insn, int, int, int);
static void add_dis_entry (struct bittree *, ia64_insn, ia64_insn, int, struct completer_entry *, int);
d298 1
a298 1
static struct disent * add_dis_table_ent (struct disent *, int, int, int);
d906 2
a907 1
              || (op == IA64_OPND_CPUID_R3 && strstr (field, "cpuid")));
d911 2
a912 2
/* Handle mov_ar, mov_br, mov_cr, mov_indirect, mov_ip, mov_pr, mov_psr, and
   mov_um insn classes.  */
d970 7
d1453 2
d1737 1
a1737 1
                   int completer_index)
d1790 1
a1790 1
                      int completer_index)
d1824 1
a1824 1
               int opcodenum, struct completer_entry *ent, int completer_index)
d1826 1
a1826 1
  if (completer_index & (1 << 20))
d2145 1
a2145 1
	  printf ("{ 0x%x, %d, %d, %d },\n", ent->completer_index,
@


1.30.4.1
log
@bfd/
2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* cpu-ia64-opc.c (ins_cnt6a): New function.
	(ext_cnt6a): Ditto.
	(ins_strd5b): Ditto.
	(ext_strd5b): Ditto.
	(elf64_ia64_operands): Add new operand types.

gas/
2012-09-04  Sergey A. Guriev  <sergey.a.guriev@@intel.com>

	* config/tc-ia64.c (reg_symbol): Add a new register.
	(indirect_reg): Ditto.
	(pseudo_func): Add new symbolic constants.
	(operand_match): Add new operand types recognition.
	(operand_insn): Add new register recognition.
	(md_begin): Add new register definition.
	(specify_resource): Add new register recognition.

gas/
2012-09-04  Sergey A. Guriev  <sergey.a.guriev@@intel.com>

	* gas/testsuite/gas/ia64/psn.d: New file.
	* gas/testsuite/gas/ia64/psn.s: New file.
	* gas/testsuite/gas/ia64/ia64.exp: Add new testcase.
	* gas/testsuite/gas/ia64/opc-i.d: Fixed failing tests.
	* gas/testsuite/gas/ia64/opc-m.d: Ditto.

include/
2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* ia64.h (ia64_opnd): Add new operand types.

opcodes/
2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* ia64-asmtab.h (completer_index): Extend bitfield to full uint.
	* ia64-gen.c: Promote completer index type to longlong.
	(irf_operand): Add new register recognition.
	(in_iclass_mov_x): Add an entry for the new mov_* instruction type.
	(lookup_specifier): Add new resource recognition.
	(insert_bit_table_ent): Relax abort condition according to the
	changed completer index type.
	(print_dis_table): Fix printf format for completer index.
	* ia64-ic.tbl: Add a new instruction class.
	* ia64-opc-i.c (ia64_opcodes_i): Define new I-instructions.
	* ia64-opc-m.c (ia64_opcodes_m): Define new M-instructions.
	* ia64-opc.h: Define short names for new operand types.
	* ia64-raw.tbl: Add new RAW resource for DAHR register.
	* ia64-waw.tbl: Add new WAW resource for DAHR register.
	* ia64-asmtab.c: Regenerate.
@
text
@a71 1
typedef unsigned long long  ci_t;
d149 1
a149 1
  ci_t completer_index;
d293 2
a294 2
static void insert_bit_table_ent (struct bittree *, int, ia64_insn, ia64_insn, int, int, ci_t);
static void add_dis_entry (struct bittree *, ia64_insn, ia64_insn, int, struct completer_entry *, ci_t);
d297 1
a297 1
static struct disent * add_dis_table_ent (struct disent *, int, int, ci_t);
d905 1
a905 2
              || (op == IA64_OPND_CPUID_R3 && strstr (field, "cpuid"))
              || (op == IA64_OPND_DAHR_R3  && strstr (field, "dahr")));
d909 2
a910 2
/* Handle mov_ar, mov_br, mov_cr, move_dahr, mov_indirect, mov_ip, mov_pr,
 * mov_psr, and  mov_um insn classes.  */
a967 7
    case 'd':
      {
        int m50 = plain_mov && idesc->operands[0] == IA64_OPND_DAHR3;
        if (m50)
          return strstr (format, "M50") != NULL;
      }
      break;
a1443 2
      if (strstr (name, "DAHR%, % in 0") != NULL)
        return IA64_RS_DAHR;
d1726 1
a1726 1
                   ci_t completer_index)
d1779 1
a1779 1
                      ci_t completer_index)
d1813 1
a1813 1
               int opcodenum, struct completer_entry *ent, ci_t completer_index)
d1815 1
a1815 1
  if (completer_index & ((ci_t)1 << 32) )
d2134 1
a2134 1
	  printf ("{ 0x%lx, %d, %d, %d },\n", ( long ) ent->completer_index,
@


1.29
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009
d37 1
a41 1
#include "ansidecl.h"
a43 1
#include "sysdep.h"
@


1.28
log
@update copyright dates
@
text
@d2700 1
a2700 1
  int index = 0;
d2721 1
a2721 1
      ptr->main_index = index++;
@


1.27
log
@2009-05-29  Tristan Gingold  <gingold@@adacore.com>

	* ia64-gen.c (parse_resource_users, print_dependency_table,
	add_dis_table_ent, finish_distable, insert_bit_table_ent,
	add_dis_entry, compact_distree, gen_dis_table, completer_entries_eq,
	get_prefix_len, compute_completer_bits, insert_opcode_dependencies,
	insert_completer_entry, print_completer_entry, print_completer_table,
	opcodes_eq, add_opcode_entry, shrink): Use ISO C syntax for functions.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007
@


1.26
log
@gas/

2008-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (CR_IIB0): New.
	(CR_IIB1): Likewise.
	(cr): Add cr.iib0 and cr.iib1.
	(specify_resource): Handle IA64_RS_CR_IIB and CR_IIB0/CR_IIB1.

gas/testsuite/

2008-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/dv-raw-err.s: Add tests for cr.iib0 and cr.iib1.
	* gas/ia64/dv-waw-err.s: Likewise.
	* gas/ia64/regs.s: Likewise.

	* gas/ia64/dv-raw-err.l: Updated.
	* gas/ia64/dv-waw-err.l: Likewise.
	* gas/ia64/regs.d: Likewise.

include/opcode/

2008-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64.h (ia64_resource_specifier): Add IA64_RS_CR_IIB.  Update
	IA64_RS_CR.

opcodes/

2008-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64-dis.c (print_insn_ia64): Handle cr.iib0 and cr.iib1.
	* ia64-gen.c (lookup_specifier): Likewise.

	* ia64-ic.tbl: Add support for cr.iib0 and cr.iib1.
	* ia64-raw.tbl: Likewise.
	* ia64-waw.tbl: Likewise.
	* ia64-asmtab.c: Regenerated.
@
text
@d697 2
a698 5
parse_resource_users (ref, usersp, nusersp, notesp)
  const char *ref;
  int **usersp;
  int *nusersp;
  int **notesp;
d1504 1
a1504 1
print_dependency_table ()
d1726 2
a1727 5
add_dis_table_ent (which, insn, order, completer_index)
     struct disent *which;
     int insn;
     int order;
     int completer_index;
d1764 1
a1764 1
finish_distable ()
d1778 3
a1780 9
insert_bit_table_ent (curr_ent, bit, opcode, mask, 
                      opcodenum, order, completer_index)
     struct bittree *curr_ent;
     int bit;
     ia64_insn opcode; 
     ia64_insn mask;
     int opcodenum;
     int order;
     int completer_index;
d1813 2
a1814 7
add_dis_entry (first, opcode, mask, opcodenum, ent, completer_index)
     struct bittree *first;
     ia64_insn opcode;
     ia64_insn mask;
     int opcodenum;
     struct completer_entry *ent;
     int completer_index;
d1838 1
a1838 2
compact_distree (ent)
     struct bittree *ent;
d1889 1
a1889 2
gen_dis_table (ent)
     struct bittree *ent;
d2213 2
a2214 2
completer_entries_eq (ent1, ent2)
     struct completer_entry *ent1, *ent2;
d2331 1
a2331 2
get_prefix_len (name)
     const char *name;
d2346 1
a2346 3
compute_completer_bits (ment, ent)
     struct main_entry *ment;
     struct completer_entry *ent;
d2419 2
a2420 3
insert_opcode_dependencies (opc, cmp)
     struct ia64_opcode *opc;
     struct completer_entry *cmp ATTRIBUTE_UNUSED;
d2505 2
a2506 4
insert_completer_entry (opc, tabent, order)
     struct ia64_opcode *opc;
     struct main_entry *tabent;
     int order;
d2577 1
a2577 2
print_completer_entry (ent)
     struct completer_entry *ent;
d2607 1
a2607 1
print_completer_table ()
d2618 1
a2618 3
opcodes_eq (opc1, opc2)
     struct ia64_opcode *opc1;
     struct ia64_opcode *opc2;
d2642 1
a2642 2
add_opcode_entry (opc)
     struct ia64_opcode *opc;
d2729 1
a2729 2
shrink (table)
     struct ia64_opcode *table;
@


1.25
log
@gas/

2007-11-14  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ia64.c (AR_RUC): Defined.
	(ar): Add "ar.ruc".
	(specify_resource): Handle AR_RUC like AR_ITC.

gas/testsuite/

2007-11-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/dv-raw-err.s: Add tests for ar.ruc.
	* gas/ia64/dv-waw-err.s: Likewise.
	* gas/ia64/invalid-ar.s: Likewise.

	* gas/ia64/regs.s: Add tests for ar.ruc and ar44.

	* gas/ia64/dv-raw-err.l: Updated.
	* gas/ia64/dv-waw-err.l: Likewise.
	* gas/ia64/invalid-ar.l: Likewise.
	* gas/ia64/regs.d: Likewise.

opcodes/

2007-11-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64-ic.tbl: Updated for Itanium 9100 series.
	* ia64-raw.tbl: Likewise.
	* ia64-waw.tbl: Likewise.
	* ia64-asmtab.c: Regenerated.

2007-11-14  Tristan Gingold  <gingold@@adacore.com>

	* ia64-dis.c (print_insn_ia64): Handle ar.ruc.
	* ia64-gen.c (lookup_regindex): Likewise.
@
text
@d1440 2
@


1.24
log
@Fix typo in last patch.
@
text
@d1299 2
@


1.23
log
@* mt-asm.c (parse_imm16): Reword error message in order to allow it to be translated properly.
* ia64-gen.c (print_dependency_table): Likewise.
* mips-dis.c (print_insn_args): Likewise.
@
text
@d1555 1
a1555 1
		  warn (_("Warning: rsrc %s (%s) has no chks%\n"), 
@


1.22
log
@Fix resource dependency problems for xmpy.
@
text
@d1553 8
a1560 3
	      warn (_("Warning: rsrc %s (%s) has no chks%s\n"), 
		    rdeps[i]->name, mode_str[rdeps[i]->mode],
		    rdeps[i]->total_regs ? "" : " or regs");
@


1.21
log
@Change source files over to GPLv3.
@
text
@d2875 1
a2875 1
   02110-1301, USA.  */");
@


1.20
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006
d6 1
a6 1
   This file is part of GDB, GAS, and the GNU binutils.
d8 9
a16 9
   GDB, GAS, and the GNU binutils are free software; you can redistribute
   them and/or modify them under the terms of the GNU General Public
   License as published by the Free Software Foundation; either version
   2, or (at your option) any later version.

   GDB, GAS, and the GNU binutils are distributed in the hope that they
   will be useful, but WITHOUT ANY WARRANTY; without even the implied
   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.
d23 1
d2858 19
@


1.19
log
@Update copyright years.
@
text
@d470 1
a470 1
  if (strncmp (full_name, "IC:", 3) == 0)
d752 1
a752 1
      if (strncmp (name, "IC:", 3) != 0 || xsect != NULL)
d1037 1
a1037 1
      if (!strncmp (ic->comment, "Format", 6))
d1053 1
a1053 1
      else if (!strncmp (ic->comment, "Field", 5))
d1067 1
a1067 1
      int is_mov = strncmp (idesc->name, "mov", 3) == 0;
d1126 1
a1126 1
          if (strncmp (idesc->name, "dep", 3) == 0
d1129 1
a1129 1
          else if (strncmp (idesc->name, "chk", 3) == 0
d1132 1
a1132 1
          else if (strncmp (idesc->name, "lfetch", 6) == 0)
d1136 1
a1136 1
          else if (strncmp (idesc->name, "br.call", 7) == 0
d1139 1
a1139 1
          else if (strncmp (idesc->name, "br.call", 7) == 0
d1142 1
a1142 1
          else if (strncmp (idesc->name, "brp", 3) == 0
d1147 1
a1147 1
	  else if (strncmp (idesc->name, "st", 2) == 0
d1151 1
a1151 1
	  else if (strncmp (idesc->name, "ld", 2) == 0
d1164 1
a1164 1
              || strncmp (idesc->name, "brl.", 4) == 0)
d1173 1
a1173 1
              || strncmp (idesc->name, "br.", 3) == 0)
d1186 1
a1186 1
      if (!resolved && strncmp (idesc->name, "probe", 5) == 0)
d1220 1
a1220 1
          if (!resolved && strncmp (ic->name, "mov_", 4) == 0)
d1479 1
a1479 1
  else if (strncmp (name, "AR[FPSR]", 8) == 0)
d1481 1
a1481 1
  else if (strncmp (name, "AR[", 3) == 0)
d1483 1
a1483 1
  else if (strncmp (name, "CR[", 3) == 0)
d1485 1
a1485 1
  else if (strncmp (name, "PSR.", 4) == 0)
d2451 1
a2451 1
          && strncmp (rs->name, "PR%", 3) == 0
d2462 1
a2462 1
              if (ic_note == 11 && strncmp (rs->name, "PR", 2) != 0)
d2490 1
a2490 1
              if (ic_note == 11 && strncmp (rs->name, "PR", 2) != 0)
@


1.18
log
@gas/

2006-02-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (specify_resource): Add the rule 17 from
	SDM 2.2.

gas/testsuite/

2006-02-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/dv-raw-err.s: Add check for vmsw.0.
	* gas/ia64/dv-raw-err.l: Updated.

	* gas/ia64/opc-b.s: Add vmsw.0 and vmsw.1.
	* gas/ia64/opc-b.d: Updated.

opcodes/

2006-02-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64-gen.c (lookup_regindex): Handle ".vm".
	(print_dependency_table): Handle '\"'.

	* ia64-ic.tbl: Updated from SDM 2.2.
	* ia64-raw.tbl: Likewise.
	* ia64-waw.tbl: Likewise.
	* ia64-asmtab.c: Regenerated.

	* ia64-opc-b.c (ia64_opcodes_b): Add vmsw.0 and vmsw.1.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005
@


1.17
log
@Fix 32-bit host/target --enable-targets=all build failure from Doug Evans.
* ia64-gen.c (_opcode_int64_low, _opcode_int64_high,
opcode_fprintf_vma): New.
(print_main_table): New opcode_fprintf_vma instead of fprintf_vma.
@
text
@d1412 2
d1574 14
a1587 1
        printf ("\"%s\", ", rdeps[i]->extra);
@


1.16
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d57 9
d2713 1
a2713 1
      fprintf_vma (stdout, ptr->opcode->opcode);
d2715 1
a2715 1
      fprintf_vma (stdout, ptr->opcode->mask);
@


1.15
log
@Update the address and phone number of the FSF
@
text
@d242 2
a243 2
static void fail (const char *, ...);
static void warn (const char *, ...);
@


1.14
log
@	* arc-ext.c: Warning fixes.
	* arc-ext.h: Likewise.
	* cgen-opc.c: Likewise.
	* ia64-gen.c: Likewise.
	* maxq-dis.c: Likewise.
	* ns32k-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* ia64-asmtab.c: Regenerate.
@
text
@d20 2
a21 2
   Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.13
log
@gas/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (parse_operands): Also handle alloc without first
	input being ar.pfs.

gas/testsuite/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/pseudo.[ds]: New.
	* gas/ia64/ia64.exp: Run new test.

opcodes/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* ia64-gen.c (NELEMS): Define.
	(shrink): Generate alias with missing second predicate register when
	opcode has two outputs and these are both predicates.
	* ia64-opc-i.c (FULL17): Define.
	(ia64_opcodes_i): Add mov-to-pr alias without second input. Use FULL17
	here to generate output template.
	(TBITCM, TNATCM): Undefine after use.
	* ia64-opc-m.c (ia64_opcodes_i): Add alloc alias without ar.pfs as
	first input. Add ld16 aliases without ar.csd as second output. Add
	st16 aliases without ar.csd as second input. Add cmpxchg aliases
	without ar.ccv as third input. Add cmp8xchg16 aliases without ar.csd/
	ar.ccv as third/fourth inputs. Consolidate through...
	(CMPXCHG_acq, CMPXCHG_rel, CMPXCHG_1, CMPXCHG_2, CMPXCHG_4, CMPXCHG_8,
	CMPXCHGn, CMP8XCHG16, CMPXCHG_ALL): Define.
	* ia64-asmtab.c: Regenerate.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d1574 1
a1574 1
      printf ("static const short dep%d[] = {\n  ", i);
d1917 1
a1917 1
      insn_list = (char *) xrealloc (insn_list, tot_insn_list_len);
d2068 1
a2068 1
	      char *byte = insn_list + our_offset + bitsused / 8;
@


1.12
log
@opcodes/
	* ia64-gen.c (in_iclass): Handle more postinc st
	and ld variants.
	* ia64-asmtab.c: Rebuilt.
gas/testsuite/
	* gas/ia64/dv-raw-err.s: Add some new postinc tests.
	* gas/ia64/dv-raw-err.l: Updated.
@
text
@d59 1
d2729 20
a2748 1
    add_opcode_entry (table + curr_opcode);
@


1.11
log
@Patch to update IA-64 port to SDM 2.1.
bfd/ChangeLog
	* cpu-ia64-opc.c: Add operand constant "ar.csd".
gas/ChangeLog
	* config/tc-ia64.c (pseudo_func): Add "@@pause" constant for "hint"
	instruction.
	(emit_one_bundle): Handle "hint" instruction.
	(operand_match): Match IA64_OPND_AR_CSD.
gas/testsuite/ChangeLog
	* gas/ia64/opc-b.d: Update for instructions added by SDM2.1.
	* gas/ia64/opc-b.s: Ditto.
	* gas/ia64/opc-f.d: Ditto.
	* gas/ia64/opc-f.s: Ditto.
	* gas/ia64/opc-i.d: Ditto.
	* gas/ia64/opc-i.s: Ditto.
	* gas/ia64/opc-m.d: Ditto.
	* gas/ia64/opc-m.s: Ditto.
	* gas/ia64/opc-x.d: Ditto.
	* gas/ia64/opc-x.s: Ditto.
include/opcode/ChangeLog
	* ia64.h: Fix copyright message.
	(IA64_OPND_AR_CSD): New operand kind.
opcodes/ChangeLog
	* ia64-opc-d.c (ia64_opcodes_d): Add "hint" instruction.
	* ia64-opc-b.c: Add "hint.b" instruction.
	* ia64-opc-f.c: Add "hint.f" instruction.
	* ia64-opc-i.c: Add "hint.i" instruction.
	* ia64-opc-m.c: Add "hint.m", "fc.i", "ld16", "st16", and
	"cmp8xchg16" instructions.
	* ia64-opc-x.c: Add "hint.x" instruction.
	* ia64-opc.h (AR_CSD): New macro.
	* ia64-ic.tbl: Update according to SDM2.1.
	* ia64-raw.tbl: Ditto.
	* ia64-waw.tbl: Ditto.
	* ia64-gen.c (in_iclass): Handle "hint" like "nop".
	(lookup_regindex): Recognize AR[FCR], AR[EFLAG], AR[CSD],
	AR[SSD], AR[CFLG], AR[FSR], AR[FIR], and AR[FDR].
	* ia64-asmtab.c: Regenerate.
@
text
@d1137 7
a1143 1
		   && strstr (format, "M5") != NULL)
@


1.11.50.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1137 1
a1137 7
		   && (strstr (format, "M5") != NULL
		       || strstr (format, "M10") != NULL))
	    resolved = idesc->flags & IA64_OPCODE_POSTINC;
	  else if (strncmp (idesc->name, "ld", 2) == 0
		   && (strstr (format, "M2 M3") != NULL
		       || strstr (format, "M12") != NULL
		       || strstr (format, "M7 M8") != NULL))
@


1.10
log
@Convert ia64-gen to use getopt().  Add standard GNU options plus --srcdir.
Convert Makefile.am to pass --srcdir to ia64-gen.  Fix compile time warnings.
@
text
@d1064 1
a1064 1
      /* All break and nop variations must match exactly.  */
d1067 2
a1068 1
           || strcmp (ic->name, "nop") == 0))
d1261 16
@


1.9
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d33 1
a33 3
   which are also easier to maintain than the final representation.

*/
d36 2
d43 1
d53 4
d63 1
a63 1
   via opcodes_eq). */
d67 1
a67 1
     appended to it to generate the full instruction name. */
d70 1
a70 1
     it uses the first one passed to add_opcode_entry. */
d72 1
a72 1
  /* The list of completers that can be applied to this opcode. */
d74 1
a74 1
  /* Next entry in the chain. */
d76 1
a76 1
  /* Index in the  main table. */
d79 1
d84 1
a84 1
/* The set of possible completers for an opcode. */
d87 1
a87 1
  /* This entry's index in the ia64_completer_table[] array. */
d90 1
a90 1
  /* The name of the completer. */
d93 1
a93 1
  /* This entry's parent. */
d97 1
a97 1
     opcode). */
d100 1
a100 1
  /* An alternative completer. */
d109 1
a109 1
     parent opcode. */
d115 1
a115 1
     list).  This field is filled in by compute_completer_bits (). */
d118 1
a118 1
  /* Index into the opcode dependency list, or -1 if none. */
d125 1
a125 1
/* One entry in the disassembler name table. */
d128 1
a128 1
  /* The index into the ia64_name_dis array for this entry. */
d131 1
a131 1
  /* The index into the main_table[] array. */
d134 1
a134 1
  /* The disassmbly priority of this entry. */
d137 1
a137 1
  /* The completer_index value for this entry. */
d140 1
a140 1
  /* How many other entries share this decode. */
d143 1
a143 1
  /* The next entry sharing the same decode. */
d146 1
a146 1
  /* The next entry in the name list. */
d151 1
a151 1
   disassembler table. */
d155 1
a155 1
  struct bittree *bits[3]; /* 0, 1, and X (don't care) */
d163 1
a163 1
/* One entry in the string table. */
d166 1
a166 1
  /* The index in the ia64_strings[] array for this entry. */
d168 1
a168 1
  /* And the string. */
d171 1
d176 1
a176 1
/* resource dependency entries */
d179 1
a179 1
  char *name;                       /* resource name */
d181 3
a183 3
    mode:2,                         /* RAW, WAW, or WAR */
    semantics:3;                    /* dependency semantics */
  char *extra;                      /* additional semantics info */
d185 4
a188 4
  int total_chks;                   /* total #of terminal insns */
  int *chks;                        /* insn classes which read (RAW), write
                                       (WAW), or write (WAR) this rsrc */
  int *chknotes;                    /* dependency notes for each class */
d190 4
a193 4
  int total_regs;                   /* total #of terminal insns */
  int *regs;                        /* insn class which write (RAW), write2
                                       (WAW), or read (WAR) this rsrc */
  int *regnotes;                    /* dependency notes for each class */
d195 1
a195 1
  int waw_special;                  /* special WAW dependency note */
d201 1
a201 1
/* array of all instruction classes */
d204 2
a205 2
  char *name;                       /* instruction class name */
  int is_class;                     /* is a class, not a terminal */
d207 1
a207 1
  int *subs;                        /* other classes within this class */
d209 5
a213 5
  int xsubs[4];                     /* exclusions */
  char *comment;                    /* optional comment */
  int note;                         /* optional note */
  int terminal_resolved;            /* did we match this with anything? */
  int orphan;                       /* detect class orphans */
d219 1
a219 1
/* an opcode dependency (chk/reg pair of dependency lists) */
d229 1
a229 1
/* a generic list of dependencies w/notes encoded.  these may be shared. */
d239 75
a313 1
/* add NAME to the resource table, where TYPE is RAW or WAW */
d332 1
a332 1
/* are the lists of dependency indexes equivalent? */
d341 3
a343 5
  for (i=0;i < d1->len;i++)
    {
      if (d1->deps[i] != d2->deps[i])
        return 0;
    }
d348 1
a348 1
/* add the list of dependencies to the list of dependency lists */
d350 1
a350 1
insert_deplist(int count, unsigned short *deps)
d352 2
a353 3
  /* sort the list, then see if an equivalent list exists already.
     this results in a much smaller set of dependency lists
   */
d358 2
a359 2
  memset ((void *)set, 0, sizeof(set));
  for (i=0;i < count;i++)
d361 1
d363 1
a363 1
  for (i=0;i < (int)sizeof(set);i++)
d367 1
a367 1
  list = tmalloc(struct deplist);
d369 5
a373 8
  list->deps = (unsigned short *)malloc (sizeof(unsigned short) * count);
  for (i=0, count=0;i < (int)sizeof(set);i++)
    {
      if (set[i])
        {
          list->deps[count++] = i;
        }
    }
d375 8
a382 10
  /* does this list exist already? */
  for (i=0;i < dlistlen;i++)
    {
      if (deplist_equals (list, dlists[i]))
        {
          free (list->deps);
          free (list);
          return i;
        }
    }
d395 1
a395 1
/* add the given pair of dependency lists to the opcode dependency list */
d410 6
a415 7
  for (i=0;i < opdeplen;i++)
    {
      if (opdeps[i]->chk == chkind 
          && opdeps[i]->reg == regind)
        return i;
    }
  pair = tmalloc(struct opdep);
d439 5
a443 8
  for (i=0;i < ic->nsubs;i++)
    {
      mark_used (ics[ic->subs[i]], clear_terminals);
    }
  for (i=0;i < ic->nxsubs;i++)
    {
      mark_used (ics[ic->xsubs[i]], clear_terminals);
    }
d446 2
a447 2
/* look up an instruction class; if CREATE make a new one if none found;
   returns the index into the insn class array */
d449 1
a449 1
fetch_insn_class(const char *full_name, int create)
d487 1
d494 1
a494 2
            fprintf (stderr, "Warning: multiple note %s not handled\n",
                     notestr);
d509 2
a510 2
  for (i=0;i < iclen;i++)
    if (strcmp(name, ics[i]->name) == 0
d521 1
a521 1
  /* doesn't exist, so make a new one */
d526 1
a526 1
        xrealloc(ics, (ictotlen)*sizeof(struct iclass *));
d528 1
d530 3
a532 3
  ics[ind] = tmalloc(struct iclass);
  memset((void *)ics[ind], 0, sizeof(struct iclass));
  ics[ind]->name = xstrdup(name);
d539 1
a539 1
      ics[ind]->comment[strlen(ics[ind]->comment)-1] = 0;
d541 1
d545 2
a546 2
  /* if it's a composite class, there's a comment or note, look for an
     existing class or terminal with the same name. */ 
d551 1
d558 1
d567 1
d579 2
a580 2
/* for sorting a class's sub-class list only; make sure classes appear before
   terminals  */
d599 1
a599 1
load_insn_classes()
d601 1
a601 1
  FILE *fp = fopen("ia64-ic.tbl", "r");
d604 2
a605 4
  if (fp == NULL){
    fprintf (stderr, "Can't find ia64-ic.tbl for reading\n");
    exit(1);
  }
d607 1
a607 1
  /* discard first line */
d610 1
a610 1
  while (!feof(fp))
d616 1
a616 1
      if (fgets (buf, sizeof(buf), fp) == NULL)
d619 2
a620 2
      while (ISSPACE (buf[strlen(buf)-1]))
        buf[strlen(buf)-1] = '\0';
d626 1
a626 1
          if (tmp == buf + sizeof(buf))
d631 1
a631 1
      iclass = fetch_insn_class(name, 1);
d641 1
a641 1
      /* for this class, record all sub-classes */
d650 2
a651 2
              if (tmp == buf + sizeof(buf))
                abort();
d657 2
a658 2
              if (tmp == buf + sizeof(buf))
                abort();
d664 2
a665 2
            xrealloc((void *)ics[iclass]->subs, 
                     (ics[iclass]->nsubs+1)*sizeof(int));
d667 1
a667 1
          sub = fetch_insn_class(subname, 1);
d669 1
a669 1
            xrealloc(ics[iclass]->subs, (ics[iclass]->nsubs+1)*sizeof(int));
d672 2
a673 1
      /* make sure classes come before terminals */
d677 1
a677 1
  fclose(fp);
d680 1
a680 3
    {
      printf ("%d classes\n", iclen);
    }
d683 1
a683 1
/* extract the insn classes from the given line */
d685 2
a686 2
parse_resource_users(ref, usersp, nusersp, notesp)
  char *ref;
d716 2
a717 2
      xsect = strchr(name, '\\');
      if ((notestr = strstr(name, "+")) != NULL)
d720 1
d724 1
a724 1
              /* note 13 always implies note 1 */
d728 1
a728 2
                fprintf (stderr, "Warning: multiple note %s not handled\n",
                         notestr);
d735 1
a735 1
      
d740 2
a741 3
         table).
      */
      if (strncmp(name, "IC:", 3) != 0 || xsect != NULL)
d744 1
a744 1
      iclass = fetch_insn_class(name, create);
d748 1
a748 1
            xrealloc ((void *)users,(count+1)*sizeof(int));
d750 1
a750 1
            xrealloc ((void *)notes,(count+1)*sizeof(int));
d755 2
a756 5
      else
        {
          if (debug)
            printf("Class %s not found\n", name);
        }
d758 1
a758 1
  /* update the return values */
d794 4
a797 4
  parse_resource_users (chk, &rs->chks, &rs->nchks,
                        &rs->chknotes);
  parse_resource_users (reg, &rs->regs, &rs->nregs,
                        &rs->regnotes);
d806 1
a806 1
  FILE *fp = fopen(filename, "r");
d809 2
a810 4
  if (fp == NULL){
    fprintf (stderr, "Can't find %s for reading\n", filename);
    exit(1);
  }
d812 2
a813 2
  fgets(buf, sizeof(buf), fp);
  while (!feof(fp))
d823 2
a824 2
      while (ISSPACE (buf[strlen(buf)-1]))
        buf[strlen(buf)-1] = '\0';
d852 1
a852 1
         without a lot of extra work */
d863 1
a863 1
  fclose(fp);
d867 1
a867 1
load_dependencies()
d874 1
a874 1
      printf ("%d RAW/WAW/WAR dependencies\n", rdepslen);
d877 1
a877 1
/* is the given operand an indirect register file operand? */
d901 2
a902 2
/* handle mov_ar, mov_br, mov_cr, mov_indirect, mov_ip, mov_pr, mov_psr, and
   mov_um insn classes */
d1016 1
a1016 2

/* is the given opcode in the given insn class? */
d1018 2
a1019 2
in_iclass(struct ia64_opcode *idesc, struct iclass *ic, 
          const char *format, const char *field, int *notep)
d1028 2
a1029 2
          /* assume that the first format seen is the most restrictive, and
             only keep a later one if it looks like it's more restrictive. */
d1034 2
a1035 3
                  fprintf (stderr, "Warning: most recent format '%s'\n"
                           "appears more restrictive than '%s'\n",
                           ic->comment, format);
d1045 2
a1046 2
            fprintf (stderr, "Overlapping field %s->%s\n",
                     ic->comment, field);
d1051 1
a1051 1
  /* an insn class matches anything that is the same followed by completers,
d1053 1
a1053 1
     instructions */
d1064 1
a1064 1
      /* all break and nop variations must match exactly */
d1070 2
a1071 2
      /* assume restrictions in the FORMAT/FIELD negate resolution,
         unless specifically allowed by clauses in this block */
d1074 1
a1074 1
          /* check Field(sf)==sN against opcode sN */
d1078 1
d1080 1
a1080 3
                {
                  resolved = strcmp (sf + 1, strstr (field, "==") + 2) == 0;
                }
d1082 1
a1082 1
          /* check Field(lftype)==XXX */
d1090 1
a1090 1
          /* handle Field(ctype)==XXX */
d1111 1
d1142 2
a1143 2
      /* misc brl variations ('.cond' is optional); 
         plain brl matches brl.cond */
d1152 1
a1152 1
      /* misc br variations ('.cond' is optional) */
d1167 1
a1167 1
      /* probe variations */
d1174 2
a1175 1
      /* mov variations */
d1180 1
a1180 1
              /* mov alias for fmerge */
d1186 1
a1186 1
              /* mov alias for adds (r3 or imm14) */
d1193 1
a1193 1
              /* mov alias for addl */
d1200 2
a1201 1
          /* some variants of mov and mov.[im] */
d1203 1
a1203 3
            {
              resolved = in_iclass_mov_x (idesc, ic, format, field);
            }
d1206 2
a1207 2
      /* keep track of this so we can flag any insn classes which aren't 
         mapped onto at least one real insn */
d1209 1
a1209 3
        {
          ic->terminal_resolved = 1;
        }
d1211 1
a1211 1
  else for (i=0;i < ic->nsubs;i++)
d1213 1
a1213 1
      if (in_iclass(idesc, ics[ic->subs[i]], format, field, notep))
d1216 5
a1220 5
          for (j=0;j < ic->nxsubs;j++)
            {
              if (in_iclass(idesc, ics[ic->xsubs[j]], NULL, NULL, NULL))
                return 0;
            }
d1222 2
a1223 2
            printf ("%s is in IC %s\n",
                    idesc->name, ic->name);
d1229 1
a1229 1
  /* If it's in this IC, add the IC note (if any) to the insn */
d1235 3
a1237 5
            {
              fprintf (stderr, "Warning: overwriting note %d with note %d"
                       "(IC:%s)\n",
                       *notep, ic->note, ic->name);
            }
d1418 2
a1419 2
      fprintf (stderr, "Warning! Don't know how to specify %% dependency %s\n",
               name);
d1440 2
a1441 2
      fprintf (stderr, "Warning! Don't know how to specify # dependency %s\n",
               name);
d1465 1
a1465 1
void
a1477 1
                  fprintf (stderr, "Warning: IC:%s", ics[i]->name);
d1479 5
a1483 2
                    fprintf (stderr, "[%s]", ics[i]->comment);
                  fprintf (stderr, " has no terminals or sub-classes\n");
a1489 2
                  fprintf(stderr, "Warning: no insns mapped directly to "
                          "terminal IC %s", ics[i]->name);
d1491 5
a1495 2
                    fprintf(stderr, "[%s] ", ics[i]->comment);
                  fprintf(stderr, "\n");
d1500 1
a1500 1
      for (i=0;i < iclen;i++)
d1505 2
a1506 2
              fprintf (stderr, "Warning: class %s is defined but not used\n", 
                       ics[i]->name);
d1510 13
a1522 15
      if (debug > 1) for (i=0;i < rdepslen;i++)
        {  
          static const char *mode_str[] = { "RAW", "WAW", "WAR" };
          if (rdeps[i]->total_chks == 0)
            {
              fprintf (stderr, "Warning: rsrc %s (%s) has no chks%s\n", 
                       rdeps[i]->name, mode_str[rdeps[i]->mode],
                       rdeps[i]->total_regs ? "" : " or regs");
            }
          else if (rdeps[i]->total_regs == 0)
            {
              fprintf (stderr, "Warning: rsrc %s (%s) has no regs\n", 
                       rdeps[i]->name, mode_str[rdeps[i]->mode]);
            }
        }
d1525 1
a1525 1
  /* the dependencies themselves */
d1527 1
a1527 1
  for (i=0;i < rdepslen;i++)
d1530 1
a1530 1
         resource used */ 
d1545 1
a1545 1
  /* and dependency lists */
d1562 1
a1562 1
  /* and opcode dependency list */
d1566 1
a1566 1
  for (i=0;i < opdeplen;i++)
d1583 1
a1583 2
/* Add STR to the string table. */

d1585 1
a1585 2
insert_string (str)
     char *str;
d1608 1
a1608 3
    {
      i = end;
    }
d1610 1
a1610 3
    {
      i = 0;
    }
d1619 1
d1621 1
a1621 3
	    {
	      end = i - 1;
	    }
d1623 1
a1623 3
	    {
	      return string_table[i];
	    }
d1625 2
a1626 3
	    {
	      start = i + 1;
	    }
d1628 1
a1628 3
	    {
	      break;
	    }
d1631 1
d1633 3
a1635 6
    {
      if (strcmp (str, string_table[i - 1]->s) > 0)
	{
	  break;
	}
    }
d1637 3
a1639 6
    {
      if (strcmp (str, string_table[i]->s) < 0)
	{
	  break;
	}
    }
d1645 1
d1650 1
d1654 2
a1655 2
struct bittree *
make_bittree_entry ()
d1667 1
d1669 1
a1669 1
struct disent *
d1685 2
a1686 3
	{
	  ent = ent->nexte;
	}
d1710 1
a1710 1
void
d1724 1
a1724 1
void
d1751 1
a1751 3
    {
      b = (opcode & m) ? 1 : 0;
    }
d1753 2
a1754 3
    {
      b = 2;
    }
d1765 1
a1765 1
void
d1775 1
a1775 3
    {
      abort ();
    }
d1782 1
d1794 2
a1795 2
/* This optimization pass combines multiple "don't care" nodes. */
void
d1835 1
d1837 1
a1837 3
	{
	  compact_distree (i);
	}
d1847 1
a1847 1
void
d1857 1
a1857 1
  int zero_dest = 0;	/* initialize this with 0 to keep gcc quiet... */
d1860 1
a1860 1
     bits. */
d1865 1
a1865 3
	{
	  abort ();
	}
d1867 1
a1867 3
	{
	  ent->skip_flag = 0;
	}
d1871 1
a1871 1
     a conservatively large approximation. */
d1873 2
a1874 3
    {
      totbits += 5;
    }
d1876 2
a1877 6
    {
      if (ent->bits[x] != NULL)
	{
	  totbits += 16;
	}
    }
d1882 2
a1883 3
	{
	  abort ();
	}
d1887 1
a1887 1
  /* Now allocate the space. */
d1899 1
a1899 1
     and store the # of bits to skip immediately after. */
d1912 1
a1912 2
     state op field. */

d1962 1
a1962 3
		{
		  idest = insn_list_len - our_offset;
		}
d1965 1
a1965 3
	    {
	      idest = ent->disent->ournum;
	    }
d1975 1
a1975 2
	     so we do not need to adjust any other offsets. */

d1993 1
a1993 3
		{
		  insn_list[our_offset] |= 0x20;
		}
d2022 1
a2022 3
		{
		  insn_list[our_offset] |= 0x08;
		}
d2024 1
d2030 1
a2030 3
		{
		  id |= 32768;
		}
d2032 2
a2033 3
		{
		  id += our_offset;
		}
d2035 1
a2035 3
		{
		  printf ("%d: if (1) goto %d\n", our_offset, id);
		}
d2037 1
a2037 3
		{
		  printf ("%d: try %d\n", our_offset, id);
		}
d2040 1
a2040 1
	  /* Store the address of the entry being branched to. */
d2046 2
a2047 3
		{
		  *byte |= (1 << (7 - (bitsused % 8)));
		}
d2052 1
a2052 1
	  /* Now generate the states for the entry being branched to. */
d2054 1
a2054 4
	    {
	      gen_dis_table (i);
	    }

d2057 1
d2061 1
a2061 3
	{
	  printf ("%d: skipping %d\n", our_offset, ent->bits_to_skip);
	}
d2064 2
a2065 4
	{
	  printf ("%d: if (0:%d) goto %d\n", our_offset, zero_count + 1,
		  zero_dest);
	}
d2067 1
d2069 1
a2069 3
    {
      abort ();
    }
d2072 2
a2073 2
void
print_dis_table ()
d2082 2
a2083 3
	{
	  printf ("\n");
	}
d2105 2
a2106 2
void
generate_disassembler ()
d2112 1
a2112 1
  for (i=0; i < otlen;i++)
d2117 4
a2120 6
	{
	  add_dis_entry (bittree,
			 ptr->opcode->opcode, ptr->opcode->mask, 
                         ptr->main_index,
			 ptr->completers, 1);
	}
d2130 2
a2131 2
void
print_string_table ()
d2137 1
a2137 1
  printf ("static const char *ia64_strings[] = {\n");
d2139 1
d2145 2
a2146 3
	{
	  abort ();
	}
d2149 1
d2159 1
d2161 2
a2162 3
    {
      printf (" %s\n", lbuf);
    }
d2170 1
a2170 1
/* If the completer trees ENT1 and ENT2 are equal, return 1. */
d2172 1
a2172 1
int
d2184 2
a2185 3
	{
	  return 0;
	}
d2187 2
a2188 3
	{
	  return 0;
	}
d2192 1
d2198 3
a2200 4
   it is returned instead. */
struct completer_entry *
insert_gclist (ent)
     struct completer_entry *ent;
d2229 1
a2229 3
	{
	  i = 0;
	}
d2231 1
a2231 3
	{
	  i = end;
	}
d2240 1
d2242 1
a2242 3
		{
		  end = i - 1;
		}
d2247 2
a2248 3
		    {
		      i--;
		    }
d2252 2
a2253 3
		{
		  start = i + 1;
		}
d2255 1
a2255 3
		{
		  break;
		}
d2257 1
d2263 2
a2264 3
		    {
		      break;
		    }
d2266 2
a2267 3
		    {
		      return glist[i];
		    }
d2272 1
d2274 3
a2276 6
	{
	  if (ent->name->num >= glist[i - 1]->name->num)
	    {
	      break;
	    }
	}
d2278 3
a2280 6
	{
	  if (ent->name->num < glist[i]->name->num)
	    {
	      break;
	    }
	}
d2282 2
a2283 3
	{
	  glist[x + 1] = glist[x];
	}
d2297 1
a2297 3
    {
      return 0;
    }
d2301 1
a2301 3
    {
      return c - name;
    }
d2303 1
a2303 3
    {
      return strlen (name);
    }
d2324 1
a2324 3
	    {
	      p = p->parent;
	    }
d2327 1
a2327 3
	    {
	      p_bits = p->bits;
	    }
d2329 1
a2329 3
	    {
	      p_bits = ment->opcode->opcode;
	    }
d2334 1
d2336 1
a2336 3
		{
		  mask |= m;
		}
d2338 1
a2338 3
		{
		  our_bits &= ~m;
		}
d2354 3
a2356 3
   instructions and collapse their entries. */
void
collapse_redundant_completers ()
d2364 2
a2365 3
	{
	  abort ();
	}
d2372 1
a2372 3
    {
      glist[x]->num = x;
    }
d2376 1
a2376 1
/* attach two lists of dependencies to each opcode.
d2380 2
a2381 3
   (regs) 
*/
int
d2386 2
a2387 2
  /* note all resources which point to this opcode.  rfi has the most chks
     (79) and cmpxchng has the most regs (54) so 100 here should be enough */
d2393 1
a2393 1
  /* flag insns for which no class matched; there should be none */
d2396 1
a2396 1
  for (i=0;i < rdepslen;i++)
d2412 1
a2412 1
              /* We can ignore ic_note 11 for non PR resources */
d2419 3
a2421 4
                fprintf (stderr, "Warning: IC note %d in opcode %s (IC:%s)"
                         " conflicts with resource %s note %d\n", 
                         ic_note, opc->name, ics[rs->regs[j]]->name,
                         rs->name, rs->regnotes[j]);
d2424 1
a2424 2
                 and note 11 implies note 1.
               */
d2433 2
a2434 1
      for (j=0;j < rs->nchks;j++)
d2440 1
a2440 1
              /* We can ignore ic_note 11 for non PR resources */
d2447 3
a2449 4
                fprintf (stderr, "Warning: IC note %d for opcode %s (IC:%s)"
                         " conflicts with resource %s note %d\n", 
                         ic_note, opc->name, ics[rs->chks[j]]->name,
                         rs->name, rs->chknotes[j]);
d2461 3
a2463 3
    fprintf (stderr, "Warning: opcode %s has no class (ops %d %d %d)\n", 
             opc->name, 
             opc->operands[0], opc->operands[1], opc->operands[2]);
d2468 1
a2468 1
void
d2480 2
a2481 3
    {
      abort ();
    }
d2484 1
d2486 1
a2486 3
    {
      prefix++;
    }
d2508 1
a2508 3
	    {
	      ptr = &((*ptr)->alternative);
	    }
d2510 1
d2514 1
d2533 1
a2533 3
    {
      abort ();
    }
d2542 1
a2542 1
void
d2557 1
d2559 1
a2559 3
	{
	  abort ();
	}
d2573 1
a2573 1
void
d2580 1
a2580 3
    {
      print_completer_entry (glist[x]);
    }
d2584 1
a2584 1
int
d2595 4
a2598 1
    {
d2600 1
a2600 8
    }
  for (x = 0; x < 5; x++)
    {
      if (opc1->operands[x] != opc2->operands[x])
	{
	  return 0;
	}
    }
d2603 1
d2605 2
a2606 3
    {
      return 1;
    }
d2610 1
a2610 1
void
d2620 2
a2621 3
    {
      abort ();
    }
d2629 1
a2629 1
     the main table is alphabetical by opcode name. */
d2640 2
a2641 3
	{
	  break;
	}
d2666 2
a2667 2
void
print_main_table ()
d2698 1
a2698 1
void
d2705 1
a2705 3
    {
      add_opcode_entry (table + curr_opcode);
    }
d2708 28
d2737 1
a2737 3
main (argc, argv)
     int argc;
     char **argv ATTRIBUTE_UNUSED;
d2739 35
a2773 4
  if (argc > 1)
    {
      debug = 1;
    }
d2775 2
a2776 2
  load_insn_classes();
  load_dependencies();
d2788 1
a2788 1
  printf ("/* This file is automatically generated by ia64-gen.  Do not edit! */\n");
@


1.9.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d33 3
a35 1
   which are also easier to maintain than the final representation.  */
a37 2
#include <stdarg.h>
#include <errno.h>
a42 1
#include "getopt.h"
a51 4
#include <libintl.h>
#define _(String) gettext (String)

const char * program_name = NULL;
d58 1
a58 1
   via opcodes_eq).  */
d62 1
a62 1
     appended to it to generate the full instruction name.  */
d65 1
a65 1
     it uses the first one passed to add_opcode_entry.  */
d67 1
a67 1
  /* The list of completers that can be applied to this opcode.  */
d69 1
a69 1
  /* Next entry in the chain.  */
d71 1
a71 1
  /* Index in the  main table.  */
a73 1

d78 1
a78 1
/* The set of possible completers for an opcode.  */
d81 1
a81 1
  /* This entry's index in the ia64_completer_table[] array.  */
d84 1
a84 1
  /* The name of the completer.  */
d87 1
a87 1
  /* This entry's parent.  */
d91 1
a91 1
     opcode).  */
d94 1
a94 1
  /* An alternative completer.  */
d103 1
a103 1
     parent opcode.  */
d109 1
a109 1
     list).  This field is filled in by compute_completer_bits ().  */
d112 1
a112 1
  /* Index into the opcode dependency list, or -1 if none.  */
d119 1
a119 1
/* One entry in the disassembler name table.  */
d122 1
a122 1
  /* The index into the ia64_name_dis array for this entry.  */
d125 1
a125 1
  /* The index into the main_table[] array.  */
d128 1
a128 1
  /* The disassmbly priority of this entry.  */
d131 1
a131 1
  /* The completer_index value for this entry.  */
d134 1
a134 1
  /* How many other entries share this decode.  */
d137 1
a137 1
  /* The next entry sharing the same decode.  */
d140 1
a140 1
  /* The next entry in the name list.  */
d145 1
a145 1
   disassembler table.  */
d149 1
a149 1
  struct bittree *bits[3]; /* 0, 1, and X (don't care).  */
d157 1
a157 1
/* One entry in the string table.  */
d160 1
a160 1
  /* The index in the ia64_strings[] array for this entry.  */
d162 1
a162 1
  /* And the string.  */
a164 1

d169 1
a169 1
/* Resource dependency entries.  */
d172 1
a172 1
  char *name;                       /* Resource name.  */
d174 3
a176 3
    mode:2,                         /* RAW, WAW, or WAR.  */
    semantics:3;                    /* Dependency semantics.  */
  char *extra;                      /* Additional semantics info.  */
d178 4
a181 4
  int total_chks;                   /* Total #of terminal insns.  */
  int *chks;                        /* Insn classes which read (RAW), write
                                       (WAW), or write (WAR) this rsrc.  */
  int *chknotes;                    /* Dependency notes for each class.  */
d183 4
a186 4
  int total_regs;                   /* Total #of terminal insns.  */
  int *regs;                        /* Insn class which write (RAW), write2
                                       (WAW), or read (WAR) this rsrc.  */
  int *regnotes;                    /* Dependency notes for each class.  */
d188 1
a188 1
  int waw_special;                  /* Special WAW dependency note.  */
d194 1
a194 1
/* Array of all instruction classes.  */
d197 2
a198 2
  char *name;                       /* Instruction class name.  */
  int is_class;                     /* Is a class, not a terminal.  */
d200 1
a200 1
  int *subs;                        /* Other classes within this class.  */
d202 5
a206 5
  int xsubs[4];                     /* Exclusions.  */
  char *comment;                    /* Optional comment.  */
  int note;                         /* Optional note.  */
  int terminal_resolved;            /* Did we match this with anything?  */
  int orphan;                       /* Detect class orphans.  */
d212 1
a212 1
/* An opcode dependency (chk/reg pair of dependency lists).  */
d222 1
a222 1
/* A generic list of dependencies w/notes encoded.  These may be shared.  */
d232 1
a232 75

static void fail (const char *, ...);
static void warn (const char *, ...);
static struct rdep * insert_resource (const char *, enum ia64_dependency_mode);
static int  deplist_equals (struct deplist *, struct deplist *);
static short insert_deplist (int, unsigned short *);
static short insert_dependencies (int, unsigned short *, int, unsigned short *);
static void  mark_used (struct iclass *, int);
static int  fetch_insn_class (const char *, int);
static int  sub_compare (const void *, const void *);
static void load_insn_classes (void);
static void parse_resource_users (const char *, int **, int *, int **);
static int  parse_semantics (char *);
static void add_dep (const char *, const char *, const char *, int, int, char *, int);
static void load_depfile (const char *, enum ia64_dependency_mode);
static void load_dependencies (void);
static int  irf_operand (int, const char *);
static int  in_iclass_mov_x (struct ia64_opcode *, struct iclass *, const char *, const char *);
static int  in_iclass (struct ia64_opcode *, struct iclass *, const char *, const char *, int *);
static int  lookup_regindex (const char *, int);
static int  lookup_specifier (const char *);
static void print_dependency_table (void);
static struct string_entry * insert_string (char *);
static void gen_dis_table (struct bittree *);
static void print_dis_table (void);
static void generate_disassembler (void);
static void print_string_table (void);
static int  completer_entries_eq (struct completer_entry *, struct completer_entry *);
static struct completer_entry * insert_gclist (struct completer_entry *);
static int  get_prefix_len (const char *);
static void compute_completer_bits (struct main_entry *, struct completer_entry *);
static void collapse_redundant_completers (void);
static int  insert_opcode_dependencies (struct ia64_opcode *, struct completer_entry *);
static void insert_completer_entry (struct ia64_opcode *, struct main_entry *, int);
static void print_completer_entry (struct completer_entry *);
static void print_completer_table (void);
static int  opcodes_eq (struct ia64_opcode *, struct ia64_opcode *);
static void add_opcode_entry (struct ia64_opcode *);
static void print_main_table (void);
static void shrink (struct ia64_opcode *);
static void print_version (void);
static void usage (FILE *, int);
static void finish_distable (void);
static void insert_bit_table_ent (struct bittree *, int, ia64_insn, ia64_insn, int, int, int);
static void add_dis_entry (struct bittree *, ia64_insn, ia64_insn, int, struct completer_entry *, int);
static void compact_distree (struct bittree *);
static struct bittree * make_bittree_entry (void);
static struct disent * add_dis_table_ent (struct disent *, int, int, int);


static void
fail (const char *message, ...)
{
  va_list args;
  
  va_start (args, message);
  fprintf (stderr, _("%s: Error: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
  xexit (1);
}

static void
warn (const char *message, ...)
{
  va_list args;

  va_start (args, message);

  fprintf (stderr, _("%s: Warning: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
}

/* Add NAME to the resource table, where TYPE is RAW or WAW.  */
d251 1
a251 1
/* Are the lists of dependency indexes equivalent?  */
d260 5
a264 3
  for (i = 0; i < d1->len; i++)
    if (d1->deps[i] != d2->deps[i])
      return 0;
d269 1
a269 1
/* Add the list of dependencies to the list of dependency lists.  */
d271 1
a271 1
insert_deplist (int count, unsigned short *deps)
d273 3
a275 2
  /* Sort the list, then see if an equivalent list exists already.
     this results in a much smaller set of dependency lists.  */
d280 2
a281 2
  memset ((void *)set, 0, sizeof (set));
  for (i = 0; i < count; i++)
a282 1

d284 1
a284 1
  for (i = 0; i < (int) sizeof (set); i++)
d288 1
a288 1
  list = tmalloc (struct deplist);
d290 8
a297 1
  list->deps = (unsigned short *) malloc (sizeof (unsigned short) * count);
d299 10
a308 12
  for (i = 0, count = 0; i < (int) sizeof (set); i++)
    if (set[i])
      list->deps[count++] = i;

  /* Does this list exist already?  */
  for (i = 0; i < dlistlen; i++)
    if (deplist_equals (list, dlists[i]))
      {
	free (list->deps);
	free (list);
	return i;
      }
d321 1
a321 1
/* Add the given pair of dependency lists to the opcode dependency list.  */
d336 7
a342 6
  for (i = 0; i < opdeplen; i++)
    if (opdeps[i]->chk == chkind 
	&& opdeps[i]->reg == regind)
      return i;

  pair = tmalloc (struct opdep);
d366 8
a373 5
  for (i = 0; i < ic->nsubs; i++)
    mark_used (ics[ic->subs[i]], clear_terminals);

  for (i = 0; i < ic->nxsubs; i++)
    mark_used (ics[ic->xsubs[i]], clear_terminals);
d376 2
a377 2
/* Look up an instruction class; if CREATE make a new one if none found;
   returns the index into the insn class array.  */
d379 1
a379 1
fetch_insn_class (const char *full_name, int create)
a416 1

d423 2
a424 1
            warn (_("multiple note %s not handled\n"), notestr);
d439 2
a440 2
  for (i = 0; i < iclen; i++)
    if (strcmp (name, ics[i]->name) == 0
d451 1
a451 1
  /* Doesn't exist, so make a new one.  */
d456 1
a456 1
        xrealloc (ics, (ictotlen) * sizeof (struct iclass *));
a457 1

d459 3
a461 3
  ics[ind] = tmalloc (struct iclass);
  memset ((void *)ics[ind], 0, sizeof (struct iclass));
  ics[ind]->name = xstrdup (name);
d468 1
a468 1
      ics[ind]->comment[strlen (ics[ind]->comment)-1] = 0;
a469 1

d473 2
a474 2
  /* If it's a composite class, there's a comment or note, look for an
     existing class or terminal with the same name.  */
a478 1

a484 1

a492 1

d504 2
a505 2
/* For sorting a class's sub-class list only; make sure classes appear before
   terminals.  */
d524 1
a524 1
load_insn_classes (void)
d526 1
a526 1
  FILE *fp = fopen ("ia64-ic.tbl", "r");
d529 4
a532 2
  if (fp == NULL)
    fail (_("can't find ia64-ic.tbl for reading\n"));
d534 1
a534 1
  /* Discard first line.  */
d537 1
a537 1
  while (!feof (fp))
d543 1
a543 1
      if (fgets (buf, sizeof (buf), fp) == NULL)
d546 2
a547 2
      while (ISSPACE (buf[strlen (buf) - 1]))
        buf[strlen (buf) - 1] = '\0';
d553 1
a553 1
          if (tmp == buf + sizeof (buf))
d558 1
a558 1
      iclass = fetch_insn_class (name, 1);
d568 1
a568 1
      /* For this class, record all sub-classes.  */
d577 2
a578 2
              if (tmp == buf + sizeof (buf))
                abort ();
d584 2
a585 2
              if (tmp == buf + sizeof (buf))
                abort ();
d591 2
a592 2
            xrealloc ((void *)ics[iclass]->subs, 
		      (ics[iclass]->nsubs + 1) * sizeof (int));
d594 1
a594 1
          sub = fetch_insn_class (subname, 1);
d596 1
a596 1
            xrealloc (ics[iclass]->subs, (ics[iclass]->nsubs + 1) * sizeof (int));
d599 1
a599 2

      /* Make sure classes come before terminals.  */
d603 1
a603 1
  fclose (fp);
d606 3
a608 1
    printf ("%d classes\n", iclen);
d611 1
a611 1
/* Extract the insn classes from the given line.  */
d613 2
a614 2
parse_resource_users (ref, usersp, nusersp, notesp)
  const char *ref;
d644 2
a645 2
      xsect = strchr (name, '\\');
      if ((notestr = strstr (name, "+")) != NULL)
a647 1

d651 1
a651 1
              /* Note 13 always implies note 1.  */
d655 2
a656 1
                warn (_("multiple note %s not handled\n"), notestr);
d663 1
a663 1

d668 3
a670 2
         table).  */
      if (strncmp (name, "IC:", 3) != 0 || xsect != NULL)
d673 1
a673 1
      iclass = fetch_insn_class (name, create);
d677 1
a677 1
            xrealloc ((void *) users,(count + 1) * sizeof (int));
d679 1
a679 1
            xrealloc ((void *) notes,(count + 1) * sizeof (int));
d684 5
a688 2
      else if (debug)
	printf("Class %s not found\n", name);
d690 1
a690 1
  /* Update the return values.  */
d726 4
a729 4

  parse_resource_users (chk, &rs->chks, &rs->nchks, &rs->chknotes);
  parse_resource_users (reg, &rs->regs, &rs->nregs, &rs->regnotes);

d738 1
a738 1
  FILE *fp = fopen (filename, "r");
d741 4
a744 2
  if (fp == NULL)
    fail (_("can't find %s for reading\n"), filename);
d746 2
a747 2
  fgets (buf, sizeof(buf), fp);
  while (!feof (fp))
d757 2
a758 2
      while (ISSPACE (buf[strlen (buf) - 1]))
        buf[strlen (buf) - 1] = '\0';
d786 1
a786 1
         without a lot of extra work.  */
d797 1
a797 1
  fclose (fp);
d801 1
a801 1
load_dependencies (void)
d808 1
a808 1
    printf ("%d RAW/WAW/WAR dependencies\n", rdepslen);
d811 1
a811 1
/* Is the given operand an indirect register file operand?  */
d835 2
a836 2
/* Handle mov_ar, mov_br, mov_cr, mov_indirect, mov_ip, mov_pr, mov_psr, and
   mov_um insn classes.  */
d950 2
a951 1
/* Is the given opcode in the given insn class?  */
d953 2
a954 2
in_iclass (struct ia64_opcode *idesc, struct iclass *ic, 
	   const char *format, const char *field, int *notep)
d963 2
a964 2
          /* Assume that the first format seen is the most restrictive, and
             only keep a later one if it looks like it's more restrictive.  */
d969 3
a971 2
                  warn (_("most recent format '%s'\nappears more restrictive than '%s'\n"),
			ic->comment, format);
d981 2
a982 2
            warn (_("overlapping field %s->%s\n"),
		  ic->comment, field);
d987 1
a987 1
  /* An insn class matches anything that is the same followed by completers,
d989 1
a989 1
     instructions.  */
d1000 1
a1000 1
      /* All break, nop, and hint variations must match exactly.  */
d1003 1
a1003 2
           || strcmp (ic->name, "nop") == 0
	   || strcmp (ic->name, "hint") == 0))
d1006 2
a1007 2
      /* Assume restrictions in the FORMAT/FIELD negate resolution,
         unless specifically allowed by clauses in this block.  */
d1010 1
a1010 1
          /* Check Field(sf)==sN against opcode sN.  */
a1013 1

d1015 3
a1017 1
		resolved = strcmp (sf + 1, strstr (field, "==") + 2) == 0;
d1019 1
a1019 1
          /* Check Field(lftype)==XXX.  */
d1027 1
a1027 1
          /* Handle Field(ctype)==XXX.  */
a1047 1

d1078 2
a1079 2
      /* Misc brl variations ('.cond' is optional); 
         plain brl matches brl.cond.  */
d1088 1
a1088 1
      /* Misc br variations ('.cond' is optional).  */
d1103 1
a1103 1
      /* probe variations.  */
d1110 1
a1110 2

      /* mov variations.  */
d1115 1
a1115 1
              /* mov alias for fmerge.  */
d1121 1
a1121 1
              /* mov alias for adds (r3 or imm14).  */
d1128 1
a1128 1
              /* mov alias for addl.  */
d1135 1
a1135 2

          /* Some variants of mov and mov.[im].  */
d1137 3
a1139 1
	    resolved = in_iclass_mov_x (idesc, ic, format, field);
d1142 2
a1143 2
      /* Keep track of this so we can flag any insn classes which aren't 
         mapped onto at least one real insn.  */
d1145 3
a1147 1
	ic->terminal_resolved = 1;
d1149 1
a1149 1
  else for (i = 0; i < ic->nsubs; i++)
d1151 1
a1151 1
      if (in_iclass (idesc, ics[ic->subs[i]], format, field, notep))
d1154 5
a1158 5

          for (j = 0; j < ic->nxsubs; j++)
	    if (in_iclass (idesc, ics[ic->xsubs[j]], NULL, NULL, NULL))
	      return 0;

d1160 2
a1161 2
            printf ("%s is in IC %s\n", idesc->name, ic->name);

d1167 1
a1167 1
  /* If it's in this IC, add the IC note (if any) to the insn.  */
d1173 5
a1177 3
	    warn (_("overwriting note %d with note %d (IC:%s)\n"),
		  *notep, ic->note, ic->name);

a1199 16
      else if (strstr (name, "[FCR]"))
        return 21;
      else if (strstr (name, "[EFLAG]"))
        return 24;
      else if (strstr (name, "[CSD]"))
        return 25;
      else if (strstr (name, "[SSD]"))
        return 26;
      else if (strstr (name, "[CFLG]"))
        return 27;
      else if (strstr (name, "[FSR]"))
        return 28;
      else if (strstr (name, "[FIR]"))
        return 29;
      else if (strstr (name, "[FDR]"))
        return 30;
d1358 2
a1359 2
      warn (_("don't know how to specify %% dependency %s\n"),
	    name);
d1380 2
a1381 2
      warn (_("Don't know how to specify # dependency %s\n"),
	    name);
d1405 1
a1405 1
static void
d1418 1
d1420 2
a1421 5
		    warn (_("IC:%s [%s] has no terminals or sub-classes\n"),
			  ics[i]->name, ics[i]->comment);
		  else
		    warn (_("IC:%s has no terminals or sub-classes\n"),
			  ics[i]->name);
d1428 2
d1431 2
a1432 5
		    warn (_("no insns mapped directly to terminal IC %s [%s]"),
			  ics[i]->name, ics[i]->comment);
		  else
		    warn (_("no insns mapped directly to terminal IC %s\n"),
			  ics[i]->name);
d1437 1
a1437 1
      for (i = 0; i < iclen; i++)
d1442 2
a1443 2
              warn (_("class %s is defined but not used\n"),
		    ics[i]->name);
d1447 15
a1461 13
      if (debug > 1)
	for (i = 0; i < rdepslen; i++)
	  {  
	    static const char *mode_str[] = { "RAW", "WAW", "WAR" };

	    if (rdeps[i]->total_chks == 0)
	      warn (_("Warning: rsrc %s (%s) has no chks%s\n"), 
		    rdeps[i]->name, mode_str[rdeps[i]->mode],
		    rdeps[i]->total_regs ? "" : " or regs");
	    else if (rdeps[i]->total_regs == 0)
	      warn (_("rsrc %s (%s) has no regs\n"),
		    rdeps[i]->name, mode_str[rdeps[i]->mode]);
	  }
d1464 1
a1464 1
  /* The dependencies themselves.  */
d1466 1
a1466 1
  for (i = 0; i < rdepslen; i++)
d1469 1
a1469 1
         resource used.  */ 
d1484 1
a1484 1
  /* And dependency lists.  */
d1501 1
a1501 1
  /* And opcode dependency list.  */
d1505 1
a1505 1
  for (i = 0; i < opdeplen; i++)
d1522 2
a1523 1
/* Add STR to the string table.  */
d1525 2
a1526 1
insert_string (char *str)
d1549 3
a1551 1
    i = end;
d1553 3
a1555 1
    i = 0;
a1563 1

d1565 3
a1567 1
	    end = i - 1;
d1569 3
a1571 1
	    return string_table[i];
d1573 3
a1575 2
	    start = i + 1;

d1577 3
a1579 1
	    break;
a1581 1

d1583 6
a1588 3
    if (strcmp (str, string_table[i - 1]->s) > 0)
      break;

d1590 6
a1595 3
    if (strcmp (str, string_table[i]->s) < 0)
      break;

a1600 1

a1604 1

d1608 2
a1609 2
static struct bittree *
make_bittree_entry (void)
a1620 1
 
d1622 1
a1622 1
static struct disent *
d1638 3
a1640 2
	ent = ent->nexte;

d1664 1
a1664 1
static void
d1678 1
a1678 1
static void
d1705 3
a1707 1
    b = (opcode & m) ? 1 : 0;
d1709 3
a1711 2
    b = 2;

d1722 1
a1722 1
static void
d1732 3
a1734 1
    abort ();
a1740 1

d1752 2
a1753 2
/* This optimization pass combines multiple "don't care" nodes.  */
static void
a1792 1

d1794 3
a1796 1
	compact_distree (i);
d1806 1
a1806 1
static void
d1816 1
a1816 1
  int zero_dest = 0;	/* Initialize this with 0 to keep gcc quiet...  */
d1819 1
a1819 1
     bits.  */
d1824 3
a1826 1
	abort ();
d1828 3
a1830 1
	ent->skip_flag = 0;
d1834 1
a1834 1
     a conservatively large approximation.  */
d1836 3
a1838 2
    totbits += 5;

d1840 6
a1845 2
    if (ent->bits[x] != NULL)
      totbits += 16;
d1850 3
a1852 2
	abort ();

d1856 1
a1856 1
  /* Now allocate the space.  */
d1868 1
a1868 1
     and store the # of bits to skip immediately after.  */
d1881 2
a1882 1
     state op field.  */
d1932 3
a1934 1
		idest = insn_list_len - our_offset;
d1937 3
a1939 1
	    idest = ent->disent->ournum;
d1949 2
a1950 1
	     so we do not need to adjust any other offsets.  */
d1968 3
a1970 1
		insn_list[our_offset] |= 0x20;
d1999 3
a2001 1
		insn_list[our_offset] |= 0x08;
a2002 1

d2008 3
a2010 1
		id |= 32768;
d2012 3
a2014 2
		id += our_offset;

d2016 3
a2018 1
		printf ("%d: if (1) goto %d\n", our_offset, id);
d2020 3
a2022 1
		printf ("%d: try %d\n", our_offset, id);
d2025 1
a2025 1
	  /* Store the address of the entry being branched to.  */
d2031 3
a2033 2
		*byte |= (1 << (7 - (bitsused % 8)));

d2038 1
a2038 1
	  /* Now generate the states for the entry being branched to.  */
d2040 4
a2043 1
	    gen_dis_table (i);
a2045 1

d2049 3
a2051 1
	printf ("%d: skipping %d\n", our_offset, ent->bits_to_skip);
d2054 4
a2057 2
	printf ("%d: if (0:%d) goto %d\n", our_offset, zero_count + 1,
		zero_dest);
a2058 1

d2060 3
a2062 1
    abort ();
d2065 2
a2066 2
static void
print_dis_table (void)
d2075 3
a2077 2
	printf ("\n");

d2099 2
a2100 2
static void
generate_disassembler (void)
d2106 1
a2106 1
  for (i = 0; i < otlen; i++)
d2111 6
a2116 4
	add_dis_entry (bittree,
		       ptr->opcode->opcode, ptr->opcode->mask, 
		       ptr->main_index,
		       ptr->completers, 1);
d2126 2
a2127 2
static void
print_string_table (void)
d2133 1
a2133 1
  printf ("static const char * const ia64_strings[] = {\n");
a2134 1

d2140 3
a2142 2
	abort ();

a2144 1

a2153 1

d2155 3
a2157 2
    printf (" %s\n", lbuf);

d2165 1
a2165 1
/* If the completer trees ENT1 and ENT2 are equal, return 1.  */
d2167 1
a2167 1
static int
d2179 3
a2181 2
	return 0;

d2183 3
a2185 2
	return 0;

a2188 1

d2194 4
a2197 3
   it is returned instead.  */
static struct completer_entry *
insert_gclist (struct completer_entry *ent)
d2226 3
a2228 1
	i = 0;
d2230 3
a2232 1
	i = end;
a2240 1

d2242 3
a2244 1
		end = i - 1;
d2249 3
a2251 2
		    i--;

d2255 3
a2257 2
		start = i + 1;

d2259 3
a2261 1
		break;
a2262 1

d2268 3
a2270 2
		    break;

d2272 3
a2274 2
		    return glist[i];

a2278 1

d2280 6
a2285 3
	if (ent->name->num >= glist[i - 1]->name->num)
	  break;

d2287 6
a2292 3
	if (ent->name->num < glist[i]->name->num)
	  break;

d2294 3
a2296 2
	glist[x + 1] = glist[x];

d2310 3
a2312 1
    return 0;
d2316 3
a2318 1
    return c - name;
d2320 3
a2322 1
    return strlen (name);
d2343 3
a2345 1
	    p = p->parent;
d2348 3
a2350 1
	    p_bits = p->bits;
d2352 3
a2354 1
	    p_bits = ment->opcode->opcode;
a2358 1

d2360 3
a2362 1
		mask |= m;
d2364 3
a2366 1
		our_bits &= ~m;
d2382 3
a2384 3
   instructions and collapse their entries.  */
static void
collapse_redundant_completers (void)
d2392 3
a2394 2
	abort ();

d2401 3
a2403 1
    glist[x]->num = x;
d2407 1
a2407 1
/* Attach two lists of dependencies to each opcode.
d2411 3
a2413 2
   (regs).  */
static int
d2418 2
a2419 2
  /* Note all resources which point to this opcode.  rfi has the most chks
     (79) and cmpxchng has the most regs (54) so 100 here should be enough.  */
d2425 1
a2425 1
  /* Flag insns for which no class matched; there should be none.  */
d2428 1
a2428 1
  for (i = 0; i < rdepslen; i++)
d2444 1
a2444 1
              /* We can ignore ic_note 11 for non PR resources.  */
d2451 4
a2454 3
                warn (_("IC note %d in opcode %s (IC:%s) conflicts with resource %s note %d\n"),
		      ic_note, opc->name, ics[rs->regs[j]]->name,
		      rs->name, rs->regnotes[j]);
d2457 2
a2458 1
                 and note 11 implies note 1.  */
d2467 1
a2467 2

      for (j = 0; j < rs->nchks; j++)
d2473 1
a2473 1
              /* We can ignore ic_note 11 for non PR resources.  */
d2480 4
a2483 3
                warn (_("IC note %d for opcode %s (IC:%s) conflicts with resource %s note %d\n"),
		      ic_note, opc->name, ics[rs->chks[j]]->name,
		      rs->name, rs->chknotes[j]);
d2495 3
a2497 3
    warn (_("opcode %s has no class (ops %d %d %d)\n"),
	  opc->name, 
	  opc->operands[0], opc->operands[1], opc->operands[2]);
d2502 1
a2502 1
static void
d2514 3
a2516 2
    abort ();

a2518 1

d2520 3
a2522 1
    prefix++;
d2544 3
a2546 1
	    ptr = &((*ptr)->alternative);
a2547 1

a2550 1

d2569 3
a2571 1
    abort ();
d2580 1
a2580 1
static void
a2594 1

d2596 3
a2598 1
	abort ();
d2612 1
a2612 1
static void
d2619 3
a2621 1
    print_completer_entry (glist[x]);
d2625 1
a2625 1
static int
d2636 3
a2638 2
    return 0;

d2640 6
a2645 3
    if (opc1->operands[x] != opc2->operands[x])
      return 0;

a2647 1

d2649 3
a2651 2
    return 1;

d2655 1
a2655 1
static void
d2665 3
a2667 2
    abort ();

d2675 1
a2675 1
     the main table is alphabetical by opcode name.  */
d2686 3
a2688 2
	break;

d2713 2
a2714 2
static void
print_main_table (void)
d2745 1
a2745 1
static void
d2752 3
a2754 1
    add_opcode_entry (table + curr_opcode);
a2756 28

/* Program options.  */
#define OPTION_SRCDIR	200

struct option long_options[] = 
{
  {"srcdir",  required_argument, NULL, OPTION_SRCDIR},
  {"debug",   no_argument,       NULL, 'd'},
  {"version", no_argument,       NULL, 'V'},
  {"help",    no_argument,       NULL, 'h'},
  {0,         no_argument,       NULL, 0}
};

static void
print_version (void)
{
  printf ("%s: version 1.0\n", program_name);
  xexit (0);
}

static void
usage (FILE * stream, int status)
{
  fprintf (stream, "Usage: %s [-V | --version] [-d | --debug] [--srcdir=dirname] [--help]\n",
	   program_name);
  xexit (status);
}

d2758 3
a2760 1
main (int argc, char **argv)
d2762 4
a2765 35
  extern int chdir (char *);
  char *srcdir = NULL;
  int c;
  
  program_name = *argv;
  xmalloc_set_program_name (program_name);

  while ((c = getopt_long (argc, argv, "vVdh", long_options, 0)) != EOF)
    switch (c)
      {
      case OPTION_SRCDIR:
	srcdir = optarg;
	break;
      case 'V':
      case 'v':
	print_version ();
	break;
      case 'd':
	debug = 1;
	break;
      case 'h':
      case '?':
	usage (stderr, 0);
      default:
      case 0:
	break;
      }

  if (optind != argc)
    usage (stdout, 1);

  if (srcdir != NULL) 
    if (chdir (srcdir) != 0)
      fail (_("unable to change directory to \"%s\", errno = %s\n"),
	    srcdir, strerror (errno));
d2767 2
a2768 2
  load_insn_classes ();
  load_dependencies ();
d2780 1
a2780 1
  printf ("/* This file is automatically generated by ia64-gen.  Do not edit!  */\n");
@


1.9.22.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d33 3
a35 1
   which are also easier to maintain than the final representation.  */
a37 2
#include <stdarg.h>
#include <errno.h>
a42 1
#include "getopt.h"
a51 4
#include <libintl.h>
#define _(String) gettext (String)

const char * program_name = NULL;
d58 1
a58 1
   via opcodes_eq).  */
d62 1
a62 1
     appended to it to generate the full instruction name.  */
d65 1
a65 1
     it uses the first one passed to add_opcode_entry.  */
d67 1
a67 1
  /* The list of completers that can be applied to this opcode.  */
d69 1
a69 1
  /* Next entry in the chain.  */
d71 1
a71 1
  /* Index in the  main table.  */
a73 1

d78 1
a78 1
/* The set of possible completers for an opcode.  */
d81 1
a81 1
  /* This entry's index in the ia64_completer_table[] array.  */
d84 1
a84 1
  /* The name of the completer.  */
d87 1
a87 1
  /* This entry's parent.  */
d91 1
a91 1
     opcode).  */
d94 1
a94 1
  /* An alternative completer.  */
d103 1
a103 1
     parent opcode.  */
d109 1
a109 1
     list).  This field is filled in by compute_completer_bits ().  */
d112 1
a112 1
  /* Index into the opcode dependency list, or -1 if none.  */
d119 1
a119 1
/* One entry in the disassembler name table.  */
d122 1
a122 1
  /* The index into the ia64_name_dis array for this entry.  */
d125 1
a125 1
  /* The index into the main_table[] array.  */
d128 1
a128 1
  /* The disassmbly priority of this entry.  */
d131 1
a131 1
  /* The completer_index value for this entry.  */
d134 1
a134 1
  /* How many other entries share this decode.  */
d137 1
a137 1
  /* The next entry sharing the same decode.  */
d140 1
a140 1
  /* The next entry in the name list.  */
d145 1
a145 1
   disassembler table.  */
d149 1
a149 1
  struct bittree *bits[3]; /* 0, 1, and X (don't care).  */
d157 1
a157 1
/* One entry in the string table.  */
d160 1
a160 1
  /* The index in the ia64_strings[] array for this entry.  */
d162 1
a162 1
  /* And the string.  */
a164 1

d169 1
a169 1
/* Resource dependency entries.  */
d172 1
a172 1
  char *name;                       /* Resource name.  */
d174 3
a176 3
    mode:2,                         /* RAW, WAW, or WAR.  */
    semantics:3;                    /* Dependency semantics.  */
  char *extra;                      /* Additional semantics info.  */
d178 4
a181 4
  int total_chks;                   /* Total #of terminal insns.  */
  int *chks;                        /* Insn classes which read (RAW), write
                                       (WAW), or write (WAR) this rsrc.  */
  int *chknotes;                    /* Dependency notes for each class.  */
d183 4
a186 4
  int total_regs;                   /* Total #of terminal insns.  */
  int *regs;                        /* Insn class which write (RAW), write2
                                       (WAW), or read (WAR) this rsrc.  */
  int *regnotes;                    /* Dependency notes for each class.  */
d188 1
a188 1
  int waw_special;                  /* Special WAW dependency note.  */
d194 1
a194 1
/* Array of all instruction classes.  */
d197 2
a198 2
  char *name;                       /* Instruction class name.  */
  int is_class;                     /* Is a class, not a terminal.  */
d200 1
a200 1
  int *subs;                        /* Other classes within this class.  */
d202 5
a206 5
  int xsubs[4];                     /* Exclusions.  */
  char *comment;                    /* Optional comment.  */
  int note;                         /* Optional note.  */
  int terminal_resolved;            /* Did we match this with anything?  */
  int orphan;                       /* Detect class orphans.  */
d212 1
a212 1
/* An opcode dependency (chk/reg pair of dependency lists).  */
d222 1
a222 1
/* A generic list of dependencies w/notes encoded.  These may be shared.  */
d232 1
a232 75

static void fail (const char *, ...);
static void warn (const char *, ...);
static struct rdep * insert_resource (const char *, enum ia64_dependency_mode);
static int  deplist_equals (struct deplist *, struct deplist *);
static short insert_deplist (int, unsigned short *);
static short insert_dependencies (int, unsigned short *, int, unsigned short *);
static void  mark_used (struct iclass *, int);
static int  fetch_insn_class (const char *, int);
static int  sub_compare (const void *, const void *);
static void load_insn_classes (void);
static void parse_resource_users (const char *, int **, int *, int **);
static int  parse_semantics (char *);
static void add_dep (const char *, const char *, const char *, int, int, char *, int);
static void load_depfile (const char *, enum ia64_dependency_mode);
static void load_dependencies (void);
static int  irf_operand (int, const char *);
static int  in_iclass_mov_x (struct ia64_opcode *, struct iclass *, const char *, const char *);
static int  in_iclass (struct ia64_opcode *, struct iclass *, const char *, const char *, int *);
static int  lookup_regindex (const char *, int);
static int  lookup_specifier (const char *);
static void print_dependency_table (void);
static struct string_entry * insert_string (char *);
static void gen_dis_table (struct bittree *);
static void print_dis_table (void);
static void generate_disassembler (void);
static void print_string_table (void);
static int  completer_entries_eq (struct completer_entry *, struct completer_entry *);
static struct completer_entry * insert_gclist (struct completer_entry *);
static int  get_prefix_len (const char *);
static void compute_completer_bits (struct main_entry *, struct completer_entry *);
static void collapse_redundant_completers (void);
static int  insert_opcode_dependencies (struct ia64_opcode *, struct completer_entry *);
static void insert_completer_entry (struct ia64_opcode *, struct main_entry *, int);
static void print_completer_entry (struct completer_entry *);
static void print_completer_table (void);
static int  opcodes_eq (struct ia64_opcode *, struct ia64_opcode *);
static void add_opcode_entry (struct ia64_opcode *);
static void print_main_table (void);
static void shrink (struct ia64_opcode *);
static void print_version (void);
static void usage (FILE *, int);
static void finish_distable (void);
static void insert_bit_table_ent (struct bittree *, int, ia64_insn, ia64_insn, int, int, int);
static void add_dis_entry (struct bittree *, ia64_insn, ia64_insn, int, struct completer_entry *, int);
static void compact_distree (struct bittree *);
static struct bittree * make_bittree_entry (void);
static struct disent * add_dis_table_ent (struct disent *, int, int, int);


static void
fail (const char *message, ...)
{
  va_list args;
  
  va_start (args, message);
  fprintf (stderr, _("%s: Error: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
  xexit (1);
}

static void
warn (const char *message, ...)
{
  va_list args;

  va_start (args, message);

  fprintf (stderr, _("%s: Warning: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
}

/* Add NAME to the resource table, where TYPE is RAW or WAW.  */
d251 1
a251 1
/* Are the lists of dependency indexes equivalent?  */
d260 5
a264 3
  for (i = 0; i < d1->len; i++)
    if (d1->deps[i] != d2->deps[i])
      return 0;
d269 1
a269 1
/* Add the list of dependencies to the list of dependency lists.  */
d271 1
a271 1
insert_deplist (int count, unsigned short *deps)
d273 3
a275 2
  /* Sort the list, then see if an equivalent list exists already.
     this results in a much smaller set of dependency lists.  */
d280 2
a281 2
  memset ((void *)set, 0, sizeof (set));
  for (i = 0; i < count; i++)
a282 1

d284 1
a284 1
  for (i = 0; i < (int) sizeof (set); i++)
d288 1
a288 1
  list = tmalloc (struct deplist);
d290 8
a297 1
  list->deps = (unsigned short *) malloc (sizeof (unsigned short) * count);
d299 10
a308 12
  for (i = 0, count = 0; i < (int) sizeof (set); i++)
    if (set[i])
      list->deps[count++] = i;

  /* Does this list exist already?  */
  for (i = 0; i < dlistlen; i++)
    if (deplist_equals (list, dlists[i]))
      {
	free (list->deps);
	free (list);
	return i;
      }
d321 1
a321 1
/* Add the given pair of dependency lists to the opcode dependency list.  */
d336 7
a342 6
  for (i = 0; i < opdeplen; i++)
    if (opdeps[i]->chk == chkind 
	&& opdeps[i]->reg == regind)
      return i;

  pair = tmalloc (struct opdep);
d366 8
a373 5
  for (i = 0; i < ic->nsubs; i++)
    mark_used (ics[ic->subs[i]], clear_terminals);

  for (i = 0; i < ic->nxsubs; i++)
    mark_used (ics[ic->xsubs[i]], clear_terminals);
d376 2
a377 2
/* Look up an instruction class; if CREATE make a new one if none found;
   returns the index into the insn class array.  */
d379 1
a379 1
fetch_insn_class (const char *full_name, int create)
a416 1

d423 2
a424 1
            warn (_("multiple note %s not handled\n"), notestr);
d439 2
a440 2
  for (i = 0; i < iclen; i++)
    if (strcmp (name, ics[i]->name) == 0
d451 1
a451 1
  /* Doesn't exist, so make a new one.  */
d456 1
a456 1
        xrealloc (ics, (ictotlen) * sizeof (struct iclass *));
a457 1

d459 3
a461 3
  ics[ind] = tmalloc (struct iclass);
  memset ((void *)ics[ind], 0, sizeof (struct iclass));
  ics[ind]->name = xstrdup (name);
d468 1
a468 1
      ics[ind]->comment[strlen (ics[ind]->comment)-1] = 0;
a469 1

d473 2
a474 2
  /* If it's a composite class, there's a comment or note, look for an
     existing class or terminal with the same name.  */
a478 1

a484 1

a492 1

d504 2
a505 2
/* For sorting a class's sub-class list only; make sure classes appear before
   terminals.  */
d524 1
a524 1
load_insn_classes (void)
d526 1
a526 1
  FILE *fp = fopen ("ia64-ic.tbl", "r");
d529 4
a532 2
  if (fp == NULL)
    fail (_("can't find ia64-ic.tbl for reading\n"));
d534 1
a534 1
  /* Discard first line.  */
d537 1
a537 1
  while (!feof (fp))
d543 1
a543 1
      if (fgets (buf, sizeof (buf), fp) == NULL)
d546 2
a547 2
      while (ISSPACE (buf[strlen (buf) - 1]))
        buf[strlen (buf) - 1] = '\0';
d553 1
a553 1
          if (tmp == buf + sizeof (buf))
d558 1
a558 1
      iclass = fetch_insn_class (name, 1);
d568 1
a568 1
      /* For this class, record all sub-classes.  */
d577 2
a578 2
              if (tmp == buf + sizeof (buf))
                abort ();
d584 2
a585 2
              if (tmp == buf + sizeof (buf))
                abort ();
d591 2
a592 2
            xrealloc ((void *)ics[iclass]->subs, 
		      (ics[iclass]->nsubs + 1) * sizeof (int));
d594 1
a594 1
          sub = fetch_insn_class (subname, 1);
d596 1
a596 1
            xrealloc (ics[iclass]->subs, (ics[iclass]->nsubs + 1) * sizeof (int));
d599 1
a599 2

      /* Make sure classes come before terminals.  */
d603 1
a603 1
  fclose (fp);
d606 3
a608 1
    printf ("%d classes\n", iclen);
d611 1
a611 1
/* Extract the insn classes from the given line.  */
d613 2
a614 2
parse_resource_users (ref, usersp, nusersp, notesp)
  const char *ref;
d644 2
a645 2
      xsect = strchr (name, '\\');
      if ((notestr = strstr (name, "+")) != NULL)
a647 1

d651 1
a651 1
              /* Note 13 always implies note 1.  */
d655 2
a656 1
                warn (_("multiple note %s not handled\n"), notestr);
d663 1
a663 1

d668 3
a670 2
         table).  */
      if (strncmp (name, "IC:", 3) != 0 || xsect != NULL)
d673 1
a673 1
      iclass = fetch_insn_class (name, create);
d677 1
a677 1
            xrealloc ((void *) users,(count + 1) * sizeof (int));
d679 1
a679 1
            xrealloc ((void *) notes,(count + 1) * sizeof (int));
d684 5
a688 2
      else if (debug)
	printf("Class %s not found\n", name);
d690 1
a690 1
  /* Update the return values.  */
d726 4
a729 4

  parse_resource_users (chk, &rs->chks, &rs->nchks, &rs->chknotes);
  parse_resource_users (reg, &rs->regs, &rs->nregs, &rs->regnotes);

d738 1
a738 1
  FILE *fp = fopen (filename, "r");
d741 4
a744 2
  if (fp == NULL)
    fail (_("can't find %s for reading\n"), filename);
d746 2
a747 2
  fgets (buf, sizeof(buf), fp);
  while (!feof (fp))
d757 2
a758 2
      while (ISSPACE (buf[strlen (buf) - 1]))
        buf[strlen (buf) - 1] = '\0';
d786 1
a786 1
         without a lot of extra work.  */
d797 1
a797 1
  fclose (fp);
d801 1
a801 1
load_dependencies (void)
d808 1
a808 1
    printf ("%d RAW/WAW/WAR dependencies\n", rdepslen);
d811 1
a811 1
/* Is the given operand an indirect register file operand?  */
d835 2
a836 2
/* Handle mov_ar, mov_br, mov_cr, mov_indirect, mov_ip, mov_pr, mov_psr, and
   mov_um insn classes.  */
d950 2
a951 1
/* Is the given opcode in the given insn class?  */
d953 2
a954 2
in_iclass (struct ia64_opcode *idesc, struct iclass *ic, 
	   const char *format, const char *field, int *notep)
d963 2
a964 2
          /* Assume that the first format seen is the most restrictive, and
             only keep a later one if it looks like it's more restrictive.  */
d969 3
a971 2
                  warn (_("most recent format '%s'\nappears more restrictive than '%s'\n"),
			ic->comment, format);
d981 2
a982 2
            warn (_("overlapping field %s->%s\n"),
		  ic->comment, field);
d987 1
a987 1
  /* An insn class matches anything that is the same followed by completers,
d989 1
a989 1
     instructions.  */
d1000 1
a1000 1
      /* All break and nop variations must match exactly.  */
d1006 2
a1007 2
      /* Assume restrictions in the FORMAT/FIELD negate resolution,
         unless specifically allowed by clauses in this block.  */
d1010 1
a1010 1
          /* Check Field(sf)==sN against opcode sN.  */
a1013 1

d1015 3
a1017 1
		resolved = strcmp (sf + 1, strstr (field, "==") + 2) == 0;
d1019 1
a1019 1
          /* Check Field(lftype)==XXX.  */
d1027 1
a1027 1
          /* Handle Field(ctype)==XXX.  */
a1047 1

d1078 2
a1079 2
      /* Misc brl variations ('.cond' is optional); 
         plain brl matches brl.cond.  */
d1088 1
a1088 1
      /* Misc br variations ('.cond' is optional).  */
d1103 1
a1103 1
      /* probe variations.  */
d1110 1
a1110 2

      /* mov variations.  */
d1115 1
a1115 1
              /* mov alias for fmerge.  */
d1121 1
a1121 1
              /* mov alias for adds (r3 or imm14).  */
d1128 1
a1128 1
              /* mov alias for addl.  */
d1135 1
a1135 2

          /* Some variants of mov and mov.[im].  */
d1137 3
a1139 1
	    resolved = in_iclass_mov_x (idesc, ic, format, field);
d1142 2
a1143 2
      /* Keep track of this so we can flag any insn classes which aren't 
         mapped onto at least one real insn.  */
d1145 3
a1147 1
	ic->terminal_resolved = 1;
d1149 1
a1149 1
  else for (i = 0; i < ic->nsubs; i++)
d1151 1
a1151 1
      if (in_iclass (idesc, ics[ic->subs[i]], format, field, notep))
d1154 5
a1158 5

          for (j = 0; j < ic->nxsubs; j++)
	    if (in_iclass (idesc, ics[ic->xsubs[j]], NULL, NULL, NULL))
	      return 0;

d1160 2
a1161 2
            printf ("%s is in IC %s\n", idesc->name, ic->name);

d1167 1
a1167 1
  /* If it's in this IC, add the IC note (if any) to the insn.  */
d1173 5
a1177 3
	    warn (_("overwriting note %d with note %d (IC:%s)\n"),
		  *notep, ic->note, ic->name);

d1358 2
a1359 2
      warn (_("don't know how to specify %% dependency %s\n"),
	    name);
d1380 2
a1381 2
      warn (_("Don't know how to specify # dependency %s\n"),
	    name);
d1405 1
a1405 1
static void
d1418 1
d1420 2
a1421 5
		    warn (_("IC:%s [%s] has no terminals or sub-classes\n"),
			  ics[i]->name, ics[i]->comment);
		  else
		    warn (_("IC:%s has no terminals or sub-classes\n"),
			  ics[i]->name);
d1428 2
d1431 2
a1432 5
		    warn (_("no insns mapped directly to terminal IC %s [%s]"),
			  ics[i]->name, ics[i]->comment);
		  else
		    warn (_("no insns mapped directly to terminal IC %s\n"),
			  ics[i]->name);
d1437 1
a1437 1
      for (i = 0; i < iclen; i++)
d1442 2
a1443 2
              warn (_("class %s is defined but not used\n"),
		    ics[i]->name);
d1447 15
a1461 13
      if (debug > 1)
	for (i = 0; i < rdepslen; i++)
	  {  
	    static const char *mode_str[] = { "RAW", "WAW", "WAR" };

	    if (rdeps[i]->total_chks == 0)
	      warn (_("Warning: rsrc %s (%s) has no chks%s\n"), 
		    rdeps[i]->name, mode_str[rdeps[i]->mode],
		    rdeps[i]->total_regs ? "" : " or regs");
	    else if (rdeps[i]->total_regs == 0)
	      warn (_("rsrc %s (%s) has no regs\n"),
		    rdeps[i]->name, mode_str[rdeps[i]->mode]);
	  }
d1464 1
a1464 1
  /* The dependencies themselves.  */
d1466 1
a1466 1
  for (i = 0; i < rdepslen; i++)
d1469 1
a1469 1
         resource used.  */ 
d1484 1
a1484 1
  /* And dependency lists.  */
d1501 1
a1501 1
  /* And opcode dependency list.  */
d1505 1
a1505 1
  for (i = 0; i < opdeplen; i++)
d1522 2
a1523 1
/* Add STR to the string table.  */
d1525 2
a1526 1
insert_string (char *str)
d1549 3
a1551 1
    i = end;
d1553 3
a1555 1
    i = 0;
a1563 1

d1565 3
a1567 1
	    end = i - 1;
d1569 3
a1571 1
	    return string_table[i];
d1573 3
a1575 2
	    start = i + 1;

d1577 3
a1579 1
	    break;
a1581 1

d1583 6
a1588 3
    if (strcmp (str, string_table[i - 1]->s) > 0)
      break;

d1590 6
a1595 3
    if (strcmp (str, string_table[i]->s) < 0)
      break;

a1600 1

a1604 1

d1608 2
a1609 2
static struct bittree *
make_bittree_entry (void)
a1620 1
 
d1622 1
a1622 1
static struct disent *
d1638 3
a1640 2
	ent = ent->nexte;

d1664 1
a1664 1
static void
d1678 1
a1678 1
static void
d1705 3
a1707 1
    b = (opcode & m) ? 1 : 0;
d1709 3
a1711 2
    b = 2;

d1722 1
a1722 1
static void
d1732 3
a1734 1
    abort ();
a1740 1

d1752 2
a1753 2
/* This optimization pass combines multiple "don't care" nodes.  */
static void
a1792 1

d1794 3
a1796 1
	compact_distree (i);
d1806 1
a1806 1
static void
d1816 1
a1816 1
  int zero_dest = 0;	/* Initialize this with 0 to keep gcc quiet...  */
d1819 1
a1819 1
     bits.  */
d1824 3
a1826 1
	abort ();
d1828 3
a1830 1
	ent->skip_flag = 0;
d1834 1
a1834 1
     a conservatively large approximation.  */
d1836 3
a1838 2
    totbits += 5;

d1840 6
a1845 2
    if (ent->bits[x] != NULL)
      totbits += 16;
d1850 3
a1852 2
	abort ();

d1856 1
a1856 1
  /* Now allocate the space.  */
d1868 1
a1868 1
     and store the # of bits to skip immediately after.  */
d1881 2
a1882 1
     state op field.  */
d1932 3
a1934 1
		idest = insn_list_len - our_offset;
d1937 3
a1939 1
	    idest = ent->disent->ournum;
d1949 2
a1950 1
	     so we do not need to adjust any other offsets.  */
d1968 3
a1970 1
		insn_list[our_offset] |= 0x20;
d1999 3
a2001 1
		insn_list[our_offset] |= 0x08;
a2002 1

d2008 3
a2010 1
		id |= 32768;
d2012 3
a2014 2
		id += our_offset;

d2016 3
a2018 1
		printf ("%d: if (1) goto %d\n", our_offset, id);
d2020 3
a2022 1
		printf ("%d: try %d\n", our_offset, id);
d2025 1
a2025 1
	  /* Store the address of the entry being branched to.  */
d2031 3
a2033 2
		*byte |= (1 << (7 - (bitsused % 8)));

d2038 1
a2038 1
	  /* Now generate the states for the entry being branched to.  */
d2040 4
a2043 1
	    gen_dis_table (i);
a2045 1

d2049 3
a2051 1
	printf ("%d: skipping %d\n", our_offset, ent->bits_to_skip);
d2054 4
a2057 2
	printf ("%d: if (0:%d) goto %d\n", our_offset, zero_count + 1,
		zero_dest);
a2058 1

d2060 3
a2062 1
    abort ();
d2065 2
a2066 2
static void
print_dis_table (void)
d2075 3
a2077 2
	printf ("\n");

d2099 2
a2100 2
static void
generate_disassembler (void)
d2106 1
a2106 1
  for (i = 0; i < otlen; i++)
d2111 6
a2116 4
	add_dis_entry (bittree,
		       ptr->opcode->opcode, ptr->opcode->mask, 
		       ptr->main_index,
		       ptr->completers, 1);
d2126 2
a2127 2
static void
print_string_table (void)
d2133 1
a2133 1
  printf ("static const char * const ia64_strings[] = {\n");
a2134 1

d2140 3
a2142 2
	abort ();

a2144 1

a2153 1

d2155 3
a2157 2
    printf (" %s\n", lbuf);

d2165 1
a2165 1
/* If the completer trees ENT1 and ENT2 are equal, return 1.  */
d2167 1
a2167 1
static int
d2179 3
a2181 2
	return 0;

d2183 3
a2185 2
	return 0;

a2188 1

d2194 4
a2197 3
   it is returned instead.  */
static struct completer_entry *
insert_gclist (struct completer_entry *ent)
d2226 3
a2228 1
	i = 0;
d2230 3
a2232 1
	i = end;
a2240 1

d2242 3
a2244 1
		end = i - 1;
d2249 3
a2251 2
		    i--;

d2255 3
a2257 2
		start = i + 1;

d2259 3
a2261 1
		break;
a2262 1

d2268 3
a2270 2
		    break;

d2272 3
a2274 2
		    return glist[i];

a2278 1

d2280 6
a2285 3
	if (ent->name->num >= glist[i - 1]->name->num)
	  break;

d2287 6
a2292 3
	if (ent->name->num < glist[i]->name->num)
	  break;

d2294 3
a2296 2
	glist[x + 1] = glist[x];

d2310 3
a2312 1
    return 0;
d2316 3
a2318 1
    return c - name;
d2320 3
a2322 1
    return strlen (name);
d2343 3
a2345 1
	    p = p->parent;
d2348 3
a2350 1
	    p_bits = p->bits;
d2352 3
a2354 1
	    p_bits = ment->opcode->opcode;
a2358 1

d2360 3
a2362 1
		mask |= m;
d2364 3
a2366 1
		our_bits &= ~m;
d2382 3
a2384 3
   instructions and collapse their entries.  */
static void
collapse_redundant_completers (void)
d2392 3
a2394 2
	abort ();

d2401 3
a2403 1
    glist[x]->num = x;
d2407 1
a2407 1
/* Attach two lists of dependencies to each opcode.
d2411 3
a2413 2
   (regs).  */
static int
d2418 2
a2419 2
  /* Note all resources which point to this opcode.  rfi has the most chks
     (79) and cmpxchng has the most regs (54) so 100 here should be enough.  */
d2425 1
a2425 1
  /* Flag insns for which no class matched; there should be none.  */
d2428 1
a2428 1
  for (i = 0; i < rdepslen; i++)
d2444 1
a2444 1
              /* We can ignore ic_note 11 for non PR resources.  */
d2451 4
a2454 3
                warn (_("IC note %d in opcode %s (IC:%s) conflicts with resource %s note %d\n"),
		      ic_note, opc->name, ics[rs->regs[j]]->name,
		      rs->name, rs->regnotes[j]);
d2457 2
a2458 1
                 and note 11 implies note 1.  */
d2467 1
a2467 2

      for (j = 0; j < rs->nchks; j++)
d2473 1
a2473 1
              /* We can ignore ic_note 11 for non PR resources.  */
d2480 4
a2483 3
                warn (_("IC note %d for opcode %s (IC:%s) conflicts with resource %s note %d\n"),
		      ic_note, opc->name, ics[rs->chks[j]]->name,
		      rs->name, rs->chknotes[j]);
d2495 3
a2497 3
    warn (_("opcode %s has no class (ops %d %d %d)\n"),
	  opc->name, 
	  opc->operands[0], opc->operands[1], opc->operands[2]);
d2502 1
a2502 1
static void
d2514 3
a2516 2
    abort ();

a2518 1

d2520 3
a2522 1
    prefix++;
d2544 3
a2546 1
	    ptr = &((*ptr)->alternative);
a2547 1

a2550 1

d2569 3
a2571 1
    abort ();
d2580 1
a2580 1
static void
a2594 1

d2596 3
a2598 1
	abort ();
d2612 1
a2612 1
static void
d2619 3
a2621 1
    print_completer_entry (glist[x]);
d2625 1
a2625 1
static int
d2636 3
a2638 2
    return 0;

d2640 6
a2645 3
    if (opc1->operands[x] != opc2->operands[x])
      return 0;

a2647 1

d2649 3
a2651 2
    return 1;

d2655 1
a2655 1
static void
d2665 3
a2667 2
    abort ();

d2675 1
a2675 1
     the main table is alphabetical by opcode name.  */
d2686 3
a2688 2
	break;

d2713 2
a2714 2
static void
print_main_table (void)
d2745 1
a2745 1
static void
d2752 3
a2754 1
    add_opcode_entry (table + curr_opcode);
a2756 28

/* Program options.  */
#define OPTION_SRCDIR	200

struct option long_options[] = 
{
  {"srcdir",  required_argument, NULL, OPTION_SRCDIR},
  {"debug",   no_argument,       NULL, 'd'},
  {"version", no_argument,       NULL, 'V'},
  {"help",    no_argument,       NULL, 'h'},
  {0,         no_argument,       NULL, 0}
};

static void
print_version (void)
{
  printf ("%s: version 1.0\n", program_name);
  xexit (0);
}

static void
usage (FILE * stream, int status)
{
  fprintf (stream, "Usage: %s [-V | --version] [-d | --debug] [--srcdir=dirname] [--help]\n",
	   program_name);
  xexit (status);
}

d2758 3
a2760 1
main (int argc, char **argv)
d2762 4
a2765 35
  extern int chdir (char *);
  char *srcdir = NULL;
  int c;
  
  program_name = *argv;
  xmalloc_set_program_name (program_name);

  while ((c = getopt_long (argc, argv, "vVdh", long_options, 0)) != EOF)
    switch (c)
      {
      case OPTION_SRCDIR:
	srcdir = optarg;
	break;
      case 'V':
      case 'v':
	print_version ();
	break;
      case 'd':
	debug = 1;
	break;
      case 'h':
      case '?':
	usage (stderr, 0);
      default:
      case 0:
	break;
      }

  if (optind != argc)
    usage (stdout, 1);

  if (srcdir != NULL) 
    if (chdir (srcdir) != 0)
      fail (_("unable to change directory to \"%s\", errno = %s\n"),
	    srcdir, strerror (errno));
d2767 2
a2768 2
  load_insn_classes ();
  load_dependencies ();
d2780 1
a2780 1
  printf ("/* This file is automatically generated by ia64-gen.  Do not edit!  */\n");
@


1.9.22.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1064 1
a1064 1
      /* All break, nop, and hint variations must match exactly.  */
d1067 1
a1067 2
           || strcmp (ic->name, "nop") == 0
	   || strcmp (ic->name, "hint") == 0))
a1259 16
      else if (strstr (name, "[FCR]"))
        return 21;
      else if (strstr (name, "[EFLAG]"))
        return 24;
      else if (strstr (name, "[CSD]"))
        return 25;
      else if (strstr (name, "[SSD]"))
        return 26;
      else if (strstr (name, "[CFLG]"))
        return 27;
      else if (strstr (name, "[FSR]"))
        return 28;
      else if (strstr (name, "[FIR]"))
        return 29;
      else if (strstr (name, "[FDR]"))
        return 30;
@


1.8
log
@Fix 2 bugs with parsing the resource dependency tables.
	* ia64-gen.c (fetch_insn_class): If xsect, then ignore comment and
	notestr if larger than xsect.
	(in_class): Handle format M5.
	* ia64-asmtab.c: Regnerate.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
a37 1
#include <ctype.h>
d41 1
d546 1
a546 1
      while (isspace(buf[strlen(buf)-1]))
d574 1
a574 1
          while (*tmp && isspace(*tmp))
d636 1
a636 1
      while (isspace(*tmp))
d757 1
a757 1
      while (isspace(buf[strlen(buf)-1]))
d765 1
a765 1
      while (isspace (*tmp))
d772 1
a772 1
      while (isspace (*tmp))
d779 1
a779 1
      while (isspace (*tmp))
@


1.7
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d402 13
a416 1
      is_class = 1;
d428 3
a430 2
  /* if it's a composite class, leave the notes and comments in place so that
     we have a unique name for the composite class */
d1071 3
@


1.6
log
@Eliminate ia64 compiler warnings.  Fix ia64 gas testsuite again.
	*  elfxx-ia64.c (get_dyn_sym_info): Cast %p argument to void *.
	* config/tc-ia64.h (ia64_init): Add prototype.
	* gas/ia64/dv-imply.d, gas/ia64/dv-mutex.d, gas/ia64/dv-safe.d,
	gas/ia64/dv-srlz.d, gas/ia64/opc-m.d: Update.
	* ia64-dis.c (print_insn_ia64): Cast away const on ia64_free_opcode
	argument.
	* ia64_gen.c (insert_deplist): Cast sizeof result to int.
	(print_dependency_table): Print NULL if semantics field not set.
	(insert_opcode_dependencies): Mark cmp parameter as unused.
	(print_main_table): Use fprintf_vma to print long long fields.
	(main): Mark argv paramter as unused.  Convert to old style definition.
	* ia64-opc.c (ia64_find_dependency): Cast sizeof result to int.
	* ia64-asmtab.c: Regnerate.
@
text
@d2 1
a2 1
   Copyright (c) 1999 Free Software Foundation, Inc.
@


1.6.2.1
log
@Fix 2 bugs with parsing the resource dependency tables.
	* ia64-gen.c (fetch_insn_class): If xsect, then ignore comment and
	notestr if larger than xsect.
	(in_class): Handle format M5.
	* ia64-asmtab.c: Regnerate.
@
text
@a401 13
    is_class = 1;

  /* If it is a composite class, then ignore comments and notes that come after
     the '\\', since they don't apply to the part we are decoding now.  */
  if (xsect)
    {
      if (comment > xsect)
	comment = 0;
      if (notestr > xsect)
	notestr = 0;
    }

  if (notestr)
d404 1
d416 2
a417 3
  /* If it's a composite class, leave the notes and comments in place so that
     we have a unique name for the composite class.  Otherwise, we remove
     them.  */
a1057 3
	  else if (strncmp (idesc->name, "st", 2) == 0
		   && strstr (format, "M5") != NULL)
	    resolved = idesc->flags & IA64_OPCODE_POSTINC;
@


1.6.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.5
log
@2000-10-04  Kazu Hirata  <kazu@@hxi.com>

	* ia64-gen.c: Convert C++-style comments to C-style comments.
	* tic54x-dis.c: Likewise.
@
text
@d284 1
a284 1
  for (i=0;i < sizeof(set);i++)
d291 1
a291 1
  for (i=0, count=0;i < sizeof(set);i++)
d1462 2
d2400 1
a2400 1
     struct completer_entry *cmp;
d2706 1
a2706 1
      printf ("  { %d, %d, %d, 0x%llxull, 0x%llxull, { %d, %d, %d, %d, %d }, 0x%x, %d, },\n",
d2709 5
a2713 3
	      ptr->opcode->num_outputs,
	      ptr->opcode->opcode,
	      ptr->opcode->mask,
d2742 3
a2744 1
main (int argc, char **argv)
@


1.4
log
@Fix ia64 gas testsuite.  Update ia64 DV tables.  Fix ia64 gas testsuite again.
gas/ChangeLog
	* config/tc-ia64.c (dv_sem): Add "stop".
	(specify_resource, case IA64_RS_PR): Only handles regs 1 to 15 now.
	(specify_resource, case IA64_RS_PRr): New for regs 16 to 62.
	(specify_resource, case IA64_RS_PR63): Reorder (note == 7) test to
	match above.
	(mark_resources): Check IA64_RS_PRr.
gas/testsuite/ChangeLog
	* gas/ia64/dv-raw-err.s: Add new testcases for PR%, 16 - 62.
	* gas/ia64/dv-waw-err.s: Likewise.
	* gas/ia64/dv-imply.d: Regenerate.
	* gas/ia64/dv-mutex.d, gas/ia64/dv-raw-err.l, gas/ia64/dv-safe.d,
	gas/ia64/dv-srlz.d, gas/ia64/dv-war-err.l, gas/ia64/dv-waw-err.l,
	gas/ia64/opc-f.d, gas/ia64/opc-i.d, gas/ia64/opc-m.d: Likewise.
include/opcode/ChangeLog
	* ia64.h (enum ia64_dependency_semantics): Add IA64_DVS_STOP.
opcodes/ChangeLog
	* ia64-dis.c (print_insn_ia64): Revert Aug 7 byte skip count change.
	* ia64-gen.c (parse_semantics): Handle IA64_DVS_STOP.
	(lookup_specifier): Handle "PR%, 1 to 15" and "PR%, 16 to 62".
	* ia64-ic.tbl, ia64-raw.tbl, ia64-war.tbl, ia64-waw.tbl: Update.
	* ia64-asmtab.c: Regnerate.
@
text
@d180 1
a180 1
                                       (WAW), or write (WAR) this rsrc */ // 
d464 1
a464 1
      // first, populate with the class we're based on
@


1.3
log
@Replace defines with those from intl/libgettext.h to quieten gcc warnings.
@
text
@d700 2
d1337 1
a1337 1
      if (strstr (name, "PR%") != NULL)
d1339 2
@


1.2
log
@Misc assembly/disassembly fixes.
@
text
@d803 2
a804 2
        || op == IA64_OPND_IBR_R3 || op == IA64_OPND_PKR_R3
        || op == IA64_OPND_PMC_R3 || op == IA64_OPND_PMD_R3
d1713 1
a2553 1

d2687 1
@


1.1
log
@IA-64 ELF support.
@
text
@d71 6
a76 1
} *maintable;
d112 1
a112 1
  /* Index into the opcode dependency list, or -1 if none */
d114 3
d128 3
d149 1
a149 1
  struct bittree *bits[3];
d516 5
d726 5
d1601 1
a1601 1
add_dis_table_ent (which, insn, completer_index)
d1604 1
d1631 2
d1657 2
a1658 1
insert_bit_table_ent (curr_ent, bit, opcode, mask, opcodenum, completer_index)
d1664 1
d1673 2
a1674 1
      struct disent *nent = add_dis_table_ent (curr_ent->disent, opcodenum,
d1696 1
a1696 1
  insert_bit_table_ent (next, bit - 1, opcode, mask, opcodenum,
d1702 1
a1702 1
     int first;
d1720 2
a1721 1
	  insert_bit_table_ent (bittree, 40, newopcode, mask, opcodenum, 
d2066 3
a2068 3
	  printf ("{ 0x%x, %d, %d },\n", ent->completer_index,
		  ent->insn,
		  (ent->nexte != NULL ? 1 : 0));
d2079 1
a2079 2
  int mainnum = 0;
  struct main_entry *ptr = maintable;
d2083 1
a2083 1
  while (ptr != NULL)
d2085 2
d2090 2
a2091 1
			 ptr->opcode->opcode, ptr->opcode->mask, mainnum,
a2093 2
      mainnum++;
      ptr = ptr->next;
d2154 2
a2155 1
          || ent1->dependencies != ent2->dependencies)
d2480 1
a2480 1
insert_completer_entry (opc, tabent)
d2483 1
a2519 4
	  else if (cmpres < 0)
	    {
	      break;
	    }
d2555 1
d2652 2
a2653 1
     instruction, allocate and fill in a new entry.  */
d2678 8
d2687 1
a2687 1
  insert_completer_entry (opc, *place);
d2694 1
d2712 2
@

