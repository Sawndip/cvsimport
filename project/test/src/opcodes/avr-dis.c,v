head	1.25;
access;
symbols
	sid-snapshot-20180601:1.25
	sid-snapshot-20180501:1.25
	sid-snapshot-20180401:1.25
	sid-snapshot-20180301:1.25
	sid-snapshot-20180201:1.25
	sid-snapshot-20180101:1.25
	sid-snapshot-20171201:1.25
	sid-snapshot-20171101:1.25
	sid-snapshot-20171001:1.25
	sid-snapshot-20170901:1.25
	sid-snapshot-20170801:1.25
	sid-snapshot-20170701:1.25
	sid-snapshot-20170601:1.25
	sid-snapshot-20170501:1.25
	sid-snapshot-20170401:1.25
	sid-snapshot-20170301:1.25
	sid-snapshot-20170201:1.25
	sid-snapshot-20170101:1.25
	sid-snapshot-20161201:1.25
	sid-snapshot-20161101:1.25
	sid-snapshot-20160901:1.25
	sid-snapshot-20160801:1.25
	sid-snapshot-20160701:1.25
	sid-snapshot-20160601:1.25
	sid-snapshot-20160501:1.25
	sid-snapshot-20160401:1.25
	sid-snapshot-20160301:1.25
	sid-snapshot-20160201:1.25
	sid-snapshot-20160101:1.25
	sid-snapshot-20151201:1.25
	sid-snapshot-20151101:1.25
	sid-snapshot-20151001:1.25
	sid-snapshot-20150901:1.25
	sid-snapshot-20150801:1.25
	sid-snapshot-20150701:1.25
	sid-snapshot-20150601:1.25
	sid-snapshot-20150501:1.25
	sid-snapshot-20150401:1.25
	sid-snapshot-20150301:1.25
	sid-snapshot-20150201:1.25
	sid-snapshot-20150101:1.25
	sid-snapshot-20141201:1.25
	sid-snapshot-20141101:1.25
	sid-snapshot-20141001:1.25
	sid-snapshot-20140901:1.25
	sid-snapshot-20140801:1.25
	sid-snapshot-20140701:1.25
	sid-snapshot-20140601:1.25
	sid-snapshot-20140501:1.25
	sid-snapshot-20140401:1.25
	sid-snapshot-20140301:1.25
	sid-snapshot-20140201:1.25
	sid-snapshot-20140101:1.25
	sid-snapshot-20131201:1.25
	sid-snapshot-20131101:1.25
	sid-snapshot-20131001:1.25
	binutils-2_24-branch:1.25.0.8
	binutils-2_24-branchpoint:1.25
	binutils-2_21_1:1.22
	sid-snapshot-20130901:1.25
	gdb_7_6_1-2013-08-30-release:1.25
	sid-snapshot-20130801:1.25
	sid-snapshot-20130701:1.25
	sid-snapshot-20130601:1.25
	sid-snapshot-20130501:1.25
	gdb_7_6-2013-04-26-release:1.25
	sid-snapshot-20130401:1.25
	binutils-2_23_2:1.25
	gdb_7_6-branch:1.25.0.6
	gdb_7_6-2013-03-12-branchpoint:1.25
	sid-snapshot-20130301:1.25
	sid-snapshot-20130201:1.25
	sid-snapshot-20130101:1.25
	sid-snapshot-20121201:1.25
	gdb_7_5_1-2012-11-29-release:1.25
	binutils-2_23_1:1.25
	sid-snapshot-20121101:1.25
	binutils-2_23:1.25
	sid-snapshot-20121001:1.25
	sid-snapshot-20120901:1.25
	gdb_7_5-2012-08-17-release:1.25
	sid-snapshot-20120801:1.25
	binutils-2_23-branch:1.25.0.4
	binutils-2_23-branchpoint:1.25
	gdb_7_5-branch:1.25.0.2
	gdb_7_5-2012-07-18-branchpoint:1.25
	sid-snapshot-20120701:1.25
	sid-snapshot-20120601:1.25
	sid-snapshot-20120501:1.24
	binutils-2_22_branch:1.24.0.6
	gdb_7_4_1-2012-04-26-release:1.24
	sid-snapshot-20120401:1.24
	sid-snapshot-20120301:1.24
	sid-snapshot-20120201:1.24
	gdb_7_4-2012-01-24-release:1.24
	sid-snapshot-20120101:1.24
	gdb_7_4-branch:1.24.0.4
	gdb_7_4-2011-12-13-branchpoint:1.24
	sid-snapshot-20111201:1.24
	binutils-2_22:1.24
	sid-snapshot-20111101:1.24
	sid-snapshot-20111001:1.24
	binutils-2_22-branch:1.24.0.2
	binutils-2_22-branchpoint:1.24
	gdb_7_3_1-2011-09-04-release:1.23
	sid-snapshot-20110901:1.24
	sid-snapshot-20110801:1.24
	gdb_7_3-2011-07-26-release:1.23
	sid-snapshot-20110701:1.23
	sid-snapshot-20110601:1.23
	sid-snapshot-20110501:1.23
	gdb_7_3-branch:1.23.0.2
	gdb_7_3-2011-04-01-branchpoint:1.23
	sid-snapshot-20110401:1.23
	sid-snapshot-20110301:1.22
	sid-snapshot-20110201:1.22
	sid-snapshot-20110101:1.22
	binutils-2_21:1.22
	sid-snapshot-20101201:1.22
	binutils-2_21-branch:1.22.0.18
	binutils-2_21-branchpoint:1.22
	sid-snapshot-20101101:1.22
	sid-snapshot-20101001:1.22
	binutils-2_20_1:1.22
	gdb_7_2-2010-09-02-release:1.22
	sid-snapshot-20100901:1.22
	sid-snapshot-20100801:1.22
	gdb_7_2-branch:1.22.0.16
	gdb_7_2-2010-07-07-branchpoint:1.22
	sid-snapshot-20100701:1.22
	sid-snapshot-20100601:1.22
	sid-snapshot-20100501:1.22
	sid-snapshot-20100401:1.22
	gdb_7_1-2010-03-18-release:1.22
	sid-snapshot-20100301:1.22
	gdb_7_1-branch:1.22.0.14
	gdb_7_1-2010-02-18-branchpoint:1.22
	sid-snapshot-20100201:1.22
	sid-snapshot-20100101:1.22
	gdb_7_0_1-2009-12-22-release:1.22
	sid-snapshot-20091201:1.22
	sid-snapshot-20091101:1.22
	binutils-2_20:1.22
	gdb_7_0-2009-10-06-release:1.22
	sid-snapshot-20091001:1.22
	gdb_7_0-branch:1.22.0.12
	gdb_7_0-2009-09-16-branchpoint:1.22
	arc-sim-20090309:1.21
	binutils-arc-20081103-branch:1.21.0.22
	binutils-arc-20081103-branchpoint:1.21
	binutils-2_20-branch:1.22.0.10
	binutils-2_20-branchpoint:1.22
	sid-snapshot-20090901:1.22
	sid-snapshot-20090801:1.22
	msnyder-checkpoint-072509-branch:1.22.0.8
	msnyder-checkpoint-072509-branchpoint:1.22
	sid-snapshot-20090701:1.22
	dje-cgen-play1-branch:1.22.0.6
	dje-cgen-play1-branchpoint:1.22
	sid-snapshot-20090601:1.22
	sid-snapshot-20090501:1.22
	sid-snapshot-20090401:1.22
	arc-20081103-branch:1.21.0.20
	arc-20081103-branchpoint:1.21
	arc-insight_6_8-branch:1.21.0.18
	arc-insight_6_8-branchpoint:1.21
	insight_6_8-branch:1.21.0.16
	insight_6_8-branchpoint:1.21
	sid-snapshot-20090301:1.22
	binutils-2_19_1:1.21
	sid-snapshot-20090201:1.22
	sid-snapshot-20090101:1.22
	reverse-20081226-branch:1.22.0.4
	reverse-20081226-branchpoint:1.22
	sid-snapshot-20081201:1.22
	multiprocess-20081120-branch:1.22.0.2
	multiprocess-20081120-branchpoint:1.22
	sid-snapshot-20081101:1.21
	binutils-2_19:1.21
	sid-snapshot-20081001:1.21
	reverse-20080930-branch:1.21.0.14
	reverse-20080930-branchpoint:1.21
	binutils-2_19-branch:1.21.0.12
	binutils-2_19-branchpoint:1.21
	sid-snapshot-20080901:1.21
	sid-snapshot-20080801:1.21
	reverse-20080717-branch:1.21.0.10
	reverse-20080717-branchpoint:1.21
	sid-snapshot-20080701:1.21
	msnyder-reverse-20080609-branch:1.21.0.8
	msnyder-reverse-20080609-branchpoint:1.21
	drow-reverse-20070409-branch:1.20.0.2
	drow-reverse-20070409-branchpoint:1.20
	sid-snapshot-20080601:1.21
	sid-snapshot-20080501:1.21
	sid-snapshot-20080403:1.21
	sid-snapshot-20080401:1.21
	gdb_6_8-2008-03-27-release:1.21
	sid-snapshot-20080301:1.21
	gdb_6_8-branch:1.21.0.6
	gdb_6_8-2008-02-26-branchpoint:1.21
	sid-snapshot-20080201:1.21
	sid-snapshot-20080101:1.21
	sid-snapshot-20071201:1.21
	sid-snapshot-20071101:1.21
	gdb_6_7_1-2007-10-29-release:1.21
	gdb_6_7-2007-10-10-release:1.21
	sid-snapshot-20071001:1.21
	gdb_6_7-branch:1.21.0.4
	gdb_6_7-2007-09-07-branchpoint:1.21
	binutils-2_18:1.21
	binutils-2_18-branch:1.21.0.2
	binutils-2_18-branchpoint:1.21
	insight_6_6-20070208-release:1.18
	binutils-csl-coldfire-4_1-32:1.15.14.1
	binutils-csl-sourcerygxx-4_1-32:1.15.14.1
	gdb_6_6-2006-12-18-release:1.18
	binutils-csl-innovasic-fido-3_4_4-33:1.15.14.1
	binutils-csl-sourcerygxx-3_4_4-32:1.13
	binutils-csl-coldfire-4_1-30:1.15.14.1
	binutils-csl-sourcerygxx-4_1-30:1.15.14.1
	binutils-csl-coldfire-4_1-28:1.15.14.1
	binutils-csl-sourcerygxx-4_1-29:1.15.14.1
	binutils-csl-sourcerygxx-4_1-28:1.15.14.1
	gdb_6_6-branch:1.18.0.2
	gdb_6_6-2006-11-15-branchpoint:1.18
	binutils-csl-arm-2006q3-27:1.15.14.1
	binutils-csl-sourcerygxx-4_1-27:1.15.14.1
	binutils-csl-arm-2006q3-26:1.15.14.1
	binutils-csl-sourcerygxx-4_1-26:1.15.14.1
	binutils-csl-sourcerygxx-4_1-25:1.15.14.1
	binutils-csl-sourcerygxx-4_1-24:1.15.14.1
	binutils-csl-sourcerygxx-4_1-23:1.15.14.1
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.15
	binutils-csl-sourcerygxx-4_1-21:1.15.14.1
	binutils-csl-arm-2006q3-21:1.15.14.1
	binutils-csl-sourcerygxx-4_1-22:1.15.14.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.15.14.1
	binutils-csl-sourcerygxx-4_1-20:1.15.14.1
	binutils-csl-arm-2006q3-19:1.15.14.1
	binutils-csl-sourcerygxx-4_1-19:1.15.14.1
	binutils-csl-sourcerygxx-4_1-18:1.15.14.1
	binutils-csl-renesas-4_1-9:1.15.14.1
	gdb-csl-sourcerygxx-3_4_4-25:1.15
	binutils-csl-sourcerygxx-3_4_4-25:1.13
	nickrob-async-20060828-mergepoint:1.18
	gdb-csl-symbian-6_4_50_20060226-11:1.15
	binutils-csl-renesas-4_1-8:1.15
	binutils-csl-renesas-4_1-7:1.15
	binutils-csl-renesas-4_1-6:1.15
	gdb-csl-sourcerygxx-4_1-17:1.15
	binutils-csl-sourcerygxx-4_1-17:1.15
	gdb-csl-20060226-branch-local-2:1.15
	gdb-csl-sourcerygxx-4_1-14:1.15
	binutils-csl-sourcerygxx-4_1-14:1.15
	binutils-csl-sourcerygxx-4_1-15:1.15
	gdb-csl-sourcerygxx-4_1-13:1.15
	binutils-csl-sourcerygxx-4_1-13:1.15
	binutils-2_17:1.16.2.1
	gdb-csl-sourcerygxx-4_1-12:1.15
	binutils-csl-sourcerygxx-4_1-12:1.15
	gdb-csl-sourcerygxx-3_4_4-21:1.15
	binutils-csl-sourcerygxx-3_4_4-21:1.15
	gdb_6_5-20060621-release:1.17
	binutils-csl-wrs-linux-3_4_4-24:1.13
	binutils-csl-wrs-linux-3_4_4-23:1.13
	gdb-csl-sourcerygxx-4_1-9:1.15
	binutils-csl-sourcerygxx-4_1-9:1.15
	gdb-csl-sourcerygxx-4_1-8:1.15
	binutils-csl-sourcerygxx-4_1-8:1.15
	gdb-csl-sourcerygxx-4_1-7:1.15
	binutils-csl-sourcerygxx-4_1-7:1.15
	gdb-csl-arm-2006q1-6:1.15
	binutils-csl-arm-2006q1-6:1.15
	gdb-csl-sourcerygxx-4_1-6:1.15
	binutils-csl-sourcerygxx-4_1-6:1.15
	binutils-csl-wrs-linux-3_4_4-22:1.13
	gdb-csl-symbian-6_4_50_20060226-10:1.15
	gdb-csl-symbian-6_4_50_20060226-9:1.15
	gdb-csl-symbian-6_4_50_20060226-8:1.15
	gdb-csl-coldfire-4_1-11:1.15
	binutils-csl-coldfire-4_1-11:1.15
	gdb-csl-sourcerygxx-3_4_4-19:1.15
	binutils-csl-sourcerygxx-3_4_4-19:1.15
	gdb-csl-coldfire-4_1-10:1.15
	gdb_6_5-branch:1.17.0.8
	gdb_6_5-2006-05-14-branchpoint:1.17
	binutils-csl-coldfire-4_1-10:1.15
	gdb-csl-sourcerygxx-4_1-5:1.15
	binutils-csl-sourcerygxx-4_1-5:1.15
	nickrob-async-20060513-branch:1.17.0.6
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.15
	binutils-csl-sourcerygxx-4_1-4:1.15
	msnyder-reverse-20060502-branch:1.17.0.4
	msnyder-reverse-20060502-branchpoint:1.17
	binutils-csl-wrs-linux-3_4_4-21:1.13
	gdb-csl-morpho-4_1-4:1.15
	binutils-csl-morpho-4_1-4:1.15
	gdb-csl-sourcerygxx-3_4_4-17:1.15
	binutils-csl-sourcerygxx-3_4_4-17:1.15
	binutils-csl-wrs-linux-3_4_4-20:1.13
	readline_5_1-import-branch:1.17.0.2
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.15
	binutils-2_17-branch:1.16.0.2
	binutils-2_17-branchpoint:1.16
	gdb-csl-symbian-20060226-branch:1.15.0.18
	gdb-csl-symbian-20060226-branchpoint:1.15
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.15
	msnyder-reverse-20060331-branch:1.15.0.16
	msnyder-reverse-20060331-branchpoint:1.15
	binutils-csl-2_17-branch:1.15.0.14
	binutils-csl-2_17-branchpoint:1.15
	gdb-csl-available-20060303-branch:1.15.0.12
	gdb-csl-available-20060303-branchpoint:1.15
	gdb-csl-20060226-branch:1.15.0.10
	gdb-csl-20060226-branchpoint:1.15
	gdb_6_4-20051202-release:1.15
	msnyder-fork-checkpoint-branch:1.15.0.8
	msnyder-fork-checkpoint-branchpoint:1.15
	gdb-csl-gxxpro-6_3-branch:1.15.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.15
	gdb_6_4-branch:1.15.0.4
	gdb_6_4-2005-11-01-branchpoint:1.15
	gdb-csl-arm-20051020-branch:1.15.0.2
	gdb-csl-arm-20051020-branchpoint:1.15
	binutils-csl-gxxpro-3_4-branch:1.13.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.13
	binutils-2_16_1:1.13
	msnyder-tracepoint-checkpoint-branch:1.14.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.14
	gdb-csl-arm-20050325-2005-q1b:1.13
	binutils-csl-arm-2005q1b:1.13
	binutils-2_16:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	binutils-csl-arm-2005q1a:1.13
	csl-arm-20050325-branch:1.13.0.6
	csl-arm-20050325-branchpoint:1.13
	binutils-csl-arm-2005q1-branch:1.13.0.4
	binutils-csl-arm-2005q1-branchpoint:1.13
	binutils-2_16-branch:1.13.0.2
	binutils-2_16-branchpoint:1.13
	csl-arm-2004-q3d:1.10
	gdb_6_3-20041109-release:1.10
	gdb_6_3-branch:1.10.0.60
	gdb_6_3-20041019-branchpoint:1.10
	csl-arm-2004-q3:1.10
	drow_intercu-merge-20040921:1.10
	drow_intercu-merge-20040915:1.10
	jimb-gdb_6_2-e500-branch:1.10.0.62
	jimb-gdb_6_2-e500-branchpoint:1.10
	gdb_6_2-20040730-release:1.10
	gdb_6_2-branch:1.10.0.58
	gdb_6_2-2004-07-10-gmt-branchpoint:1.10
	gdb_6_1_1-20040616-release:1.10
	binutils-2_15:1.10
	binutils-2_15-branchpoint:1.10
	csl-arm-2004-q1a:1.10
	csl-arm-2004-q1:1.10
	gdb_6_1-2004-04-05-release:1.10
	drow_intercu-merge-20040402:1.10
	drow_intercu-merge-20040327:1.10
	ezannoni_pie-20040323-branch:1.10.0.56
	ezannoni_pie-20040323-branchpoint:1.10
	cagney_tramp-20040321-mergepoint:1.10
	cagney_tramp-20040309-branch:1.10.0.54
	cagney_tramp-20040309-branchpoint:1.10
	gdb_6_1-branch:1.10.0.52
	gdb_6_1-2004-03-01-gmt-branchpoint:1.10
	drow_intercu-20040221-branch:1.10.0.50
	drow_intercu-20040221-branchpoint:1.10
	binutils-2_15-branch:1.10.0.48
	cagney_bfdfile-20040213-branch:1.10.0.46
	cagney_bfdfile-20040213-branchpoint:1.10
	drow-cplus-merge-20040208:1.10
	carlton_dictionary-20040126-merge:1.10
	cagney_bigcore-20040122-branch:1.10.0.44
	cagney_bigcore-20040122-branchpoint:1.10
	drow-cplus-merge-20040113:1.10
	csl-arm-2003-q4:1.10
	drow-cplus-merge-20031224:1.10
	drow-cplus-merge-20031220:1.10
	carlton_dictionary-20031215-merge:1.10
	drow-cplus-merge-20031214:1.10
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.10
	kettenis_sparc-20030918-branch:1.10.0.42
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.40
	cagney_x86i386-20030821-branch:1.10.0.38
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.10
	carlton_dictionary-20030627-merge:1.10
	gdb_6_0-branch:1.10.0.36
	gdb_6_0-2003-06-23-branchpoint:1.10
	jimb-ppc64-linux-20030613-branch:1.10.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.10
	binutils-2_14:1.10
	cagney_convert-20030606-branch:1.10.0.32
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.30
	cagney_writestrings-20030508-branchpoint:1.10
	jimb-ppc64-linux-20030528-branch:1.10.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.26
	cagney_fileio-20030521-branchpoint:1.10
	kettenis_i386newframe-20030517-mergepoint:1.10
	jimb-ppc64-linux-20030509-branch:1.10.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.10
	kettenis_i386newframe-20030504-mergepoint:1.10
	carlton_dictionary-20030430-merge:1.10
	binutils-2_14-branch:1.10.0.22
	binutils-2_14-branchpoint:1.10
	kettenis_i386newframe-20030419-branch:1.10.0.20
	kettenis_i386newframe-20030419-branchpoint:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.10
	kettenis_i386newframe-20030406-branch:1.10.0.18
	kettenis_i386newframe-20030406-branchpoint:1.10
	cagney_frameaddr-20030403-branchpoint:1.10
	cagney_frameaddr-20030403-branch:1.10.0.16
	cagney_framebase-20030330-mergepoint:1.10
	cagney_framebase-20030326-branch:1.10.0.14
	cagney_framebase-20030326-branchpoint:1.10
	cagney_lazyid-20030317-branch:1.10.0.12
	cagney_lazyid-20030317-branchpoint:1.10
	kettenis-i386newframe-20030316-mergepoint:1.10
	offbyone-20030313-branch:1.10.0.10
	offbyone-20030313-branchpoint:1.10
	kettenis-i386newframe-20030308-branch:1.10.0.8
	kettenis-i386newframe-20030308-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.6
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.10
	interps-20030202-branch:1.10.0.4
	interps-20030202-branchpoint:1.10
	cagney-unwind-20030108-branch:1.10.0.2
	cagney-unwind-20030108-branchpoint:1.10
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.9
	binutils-2_13_1:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.30
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.28
	carlton_dictionary-20020920-branchpoint:1.9
	sid-20020905-branchpoint:1.9
	sid-20020905-branch:1.9.0.26
	gdb_5_3-branch:1.9.0.24
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.22
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.20
	readline_4_3-import-branchpoint:1.9
	binutils-2_13:1.9
	gdb_5_2_1-2002-07-23-release:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.18
	kseitz_interps-20020528-branch:1.9.0.16
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.14
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.9
	jimb-macro-020506-branch:1.9.0.12
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	binutils-2_12:1.9
	gdb_5_2-branch:1.9.0.10
	gdb_5_2-2002-03-03-branchpoint:1.9
	binutils-2_12-branch:1.9.0.8
	binutils-2_12-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.4
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.2
	gdb_5_1-2001-07-29-branchpoint:1.9
	binutils-2_11_2:1.8.2.1
	binutils-2_11_1:1.8.2.1
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	insight-precleanup-2001-01-01:1.8
	binutils-2_10_1:1.1.2.2
	binutils-2_10:1.1.2.2
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.1.0.2
	binutils-2_10-branchpoint:1.1
	binutils_latest_snapshot:1.25;
locks; strict;
comment	@ * @;


1.25
date	2012.05.17.15.13.24;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.01.16.11.27;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2011.03.22.18.10.48;	author eweddington;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.06.12.03.24;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.16.10.24.48;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.02.22.54.50;	author hjl;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.17.23.44.58;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.19.02.15.05;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.12.13.09.10;	author nickc;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2005.07.01.11.16.31;	author nickc;	state Exp;
branches
	1.15.14.1;
next	1.14;

1.14
date	2005.05.07.07.34.27;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.03.11.49.47;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.14.22.30.28;	author sveinse;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.14.22.27.05;	author sveinse;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.18.16.54.08;	author kdienes;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.13.22.58.34;	author nickc;	state Exp;
branches
	1.9.28.1
	1.9.30.1;
next	1.8;

1.8
date	2000.08.06.14.12.36;	author denisc;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.07.03.22.25.33;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.09.17.58.33;	author denisc;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.07.17.45.44;	author denisc;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.01.08.45.11;	author denisc;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.03.14.17.43;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.27.08.39.14;	author amodra;	state Exp;
branches
	1.1.2.1;
next	;

1.16.2.1
date	2006.05.17.23.52.19;	author amodra;	state Exp;
branches;
next	;

1.15.14.1
date	2006.08.22.15.08.46;	author jsm28;	state Exp;
branches;
next	;

1.9.28.1
date	2002.12.23.19.39.30;	author carlton;	state Exp;
branches;
next	;

1.9.30.1
date	2003.12.14.20.28.04;	author drow;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.18.33;	author amodra;	state Exp;
branches;
next	;

1.1.2.1
date	2000.04.04.11.25.30;	author amodra;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;


desc
@@


1.25
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* Disassemble AVR instructions.
   Copyright 1999, 2000, 2002, 2004, 2005, 2006, 2007, 2008, 2012
   Free Software Foundation, Inc.

   Contributed by Denis Chertykov <denisc@@overta.ru>

   This file is part of libopcodes.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <assert.h>
#include "dis-asm.h"
#include "opintl.h"
#include "libiberty.h"

struct avr_opcodes_s
{
  char *name;
  char *constraints;
  char *opcode;
  int insn_size;		/* In words.  */
  int isa;
  unsigned int bin_opcode;
};

#define AVR_INSN(NAME, CONSTR, OPCODE, SIZE, ISA, BIN) \
{#NAME, CONSTR, OPCODE, SIZE, ISA, BIN},

const struct avr_opcodes_s avr_opcodes[] =
{
  #include "opcode/avr.h"
  {NULL, NULL, NULL, 0, 0, 0}
};

static const char * comment_start = "0x";

static int
avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constraint,
             char *opcode_str, char *buf, char *comment, int regs, int *sym, bfd_vma *sym_addr)
{
  int ok = 1;
  *sym = 0;

  switch (constraint)
    {
      /* Any register operand.  */
    case 'r':
      if (regs)
	insn = (insn & 0xf) | ((insn & 0x0200) >> 5); /* Source register.  */
      else
	insn = (insn & 0x01f0) >> 4; /* Destination register.  */
      
      sprintf (buf, "r%d", insn);
      break;

    case 'd':
      if (regs)
	sprintf (buf, "r%d", 16 + (insn & 0xf));
      else
	sprintf (buf, "r%d", 16 + ((insn & 0xf0) >> 4));
      break;
      
    case 'w':
      sprintf (buf, "r%d", 24 + ((insn & 0x30) >> 3));
      break;
      
    case 'a':
      if (regs)
	sprintf (buf, "r%d", 16 + (insn & 7));
      else
	sprintf (buf, "r%d", 16 + ((insn >> 4) & 7));
      break;

    case 'v':
      if (regs)
	sprintf (buf, "r%d", (insn & 0xf) * 2);
      else
	sprintf (buf, "r%d", ((insn & 0xf0) >> 3));
      break;

    case 'e':
      {
	char *xyz;

	switch (insn & 0x100f)
	  {
	    case 0x0000: xyz = "Z";  break;
	    case 0x1001: xyz = "Z+"; break;
	    case 0x1002: xyz = "-Z"; break;
	    case 0x0008: xyz = "Y";  break;
	    case 0x1009: xyz = "Y+"; break;
	    case 0x100a: xyz = "-Y"; break;
	    case 0x100c: xyz = "X";  break;
	    case 0x100d: xyz = "X+"; break;
	    case 0x100e: xyz = "-X"; break;
	    default: xyz = "??"; ok = 0;
	  }
	strcpy (buf, xyz);

	if (AVR_UNDEF_P (insn))
	  sprintf (comment, _("undefined"));
      }
      break;

    case 'z':
      *buf++ = 'Z';

      /* Check for post-increment. */
      char *s;
      for (s = opcode_str; *s; ++s)
        {
          if (*s == '+')
            {
	      if (insn & (1 << (15 - (s - opcode_str))))
		*buf++ = '+';
              break;
            }
        }

      *buf = '\0';
      if (AVR_UNDEF_P (insn))
	sprintf (comment, _("undefined"));
      break;

    case 'b':
      {
	unsigned int x;
	
	x = (insn & 7);
	x |= (insn >> 7) & (3 << 3);
	x |= (insn >> 8) & (1 << 5);
	
	if (insn & 0x8)
	  *buf++ = 'Y';
	else
	  *buf++ = 'Z';
	sprintf (buf, "+%d", x);
	sprintf (comment, "0x%02x", x);
      }
      break;
      
    case 'h':
      *sym = 1;
      *sym_addr = ((((insn & 1) | ((insn & 0x1f0) >> 3)) << 16) | insn2) * 2;
      /* See PR binutils/2454.  Ideally we would like to display the hex
	 value of the address only once, but this would mean recoding
	 objdump_print_address() which would affect many targets.  */
      sprintf (buf, "%#lx", (unsigned long) *sym_addr);      
      strcpy (comment, comment_start);
      break;
      
    case 'L':
      {
	int rel_addr = (((insn & 0xfff) ^ 0x800) - 0x800) * 2;
	sprintf (buf, ".%+-8d", rel_addr);
        *sym = 1;
        *sym_addr = pc + 2 + rel_addr;
	strcpy (comment, comment_start);
      }
      break;

    case 'l':
      {
	int rel_addr = ((((insn >> 3) & 0x7f) ^ 0x40) - 0x40) * 2;

	sprintf (buf, ".%+-8d", rel_addr);
        *sym = 1;
        *sym_addr = pc + 2 + rel_addr;
	strcpy (comment, comment_start);
      }
      break;

    case 'i':
      sprintf (buf, "0x%04X", insn2);
      break;
      
    case 'M':
      sprintf (buf, "0x%02X", ((insn & 0xf00) >> 4) | (insn & 0xf));
      sprintf (comment, "%d", ((insn & 0xf00) >> 4) | (insn & 0xf));
      break;

    case 'n':
      sprintf (buf, "??");
      fprintf (stderr, _("Internal disassembler error"));
      ok = 0;
      break;
      
    case 'K':
      {
	unsigned int x;

	x = (insn & 0xf) | ((insn >> 2) & 0x30);
	sprintf (buf, "0x%02x", x);
	sprintf (comment, "%d", x);
      }
      break;
      
    case 's':
      sprintf (buf, "%d", insn & 7);
      break;
      
    case 'S':
      sprintf (buf, "%d", (insn >> 4) & 7);
      break;
      
    case 'P':
      {
	unsigned int x;

	x = (insn & 0xf);
	x |= (insn >> 5) & 0x30;
	sprintf (buf, "0x%02x", x);
	sprintf (comment, "%d", x);
      }
      break;

    case 'p':
      {
	unsigned int x;
	
	x = (insn >> 3) & 0x1f;
	sprintf (buf, "0x%02x", x);
	sprintf (comment, "%d", x);
      }
      break;
      
    case 'E':
      sprintf (buf, "%d", (insn >> 4) & 15);
      break;
      
    case '?':
      *buf = '\0';
      break;
      
    default:
      sprintf (buf, "??");
      fprintf (stderr, _("unknown constraint `%c'"), constraint);
      ok = 0;
    }

    return ok;
}

static unsigned short
avrdis_opcode (bfd_vma addr, disassemble_info *info)
{
  bfd_byte buffer[2];
  int status;

  status = info->read_memory_func (addr, buffer, 2, info);

  if (status == 0)
    return bfd_getl16 (buffer);

  info->memory_error_func (status, addr, info);
  return -1;
}


int
print_insn_avr (bfd_vma addr, disassemble_info *info)
{
  unsigned int insn, insn2;
  const struct avr_opcodes_s *opcode;
  static unsigned int *maskptr;
  void *stream = info->stream;
  fprintf_ftype prin = info->fprintf_func;
  static unsigned int *avr_bin_masks;
  static int initialized;
  int cmd_len = 2;
  int ok = 0;
  char op1[20], op2[20], comment1[40], comment2[40];
  int sym_op1 = 0, sym_op2 = 0;
  bfd_vma sym_addr1, sym_addr2;


  if (!initialized)
    {
      unsigned int nopcodes;

      /* PR 4045: Try to avoid duplicating the 0x prefix that
	 objdump_print_addr() will put on addresses when there
	 is no symbol table available.  */
      if (info->symtab_size == 0)
	comment_start = " ";

      nopcodes = sizeof (avr_opcodes) / sizeof (struct avr_opcodes_s);
      
      avr_bin_masks = xmalloc (nopcodes * sizeof (unsigned int));

      for (opcode = avr_opcodes, maskptr = avr_bin_masks;
	   opcode->name;
	   opcode++, maskptr++)
	{
	  char * s;
	  unsigned int bin = 0;
	  unsigned int mask = 0;
	
	  for (s = opcode->opcode; *s; ++s)
	    {
	      bin <<= 1;
	      mask <<= 1;
	      bin |= (*s == '1');
	      mask |= (*s == '1' || *s == '0');
	    }
	  assert (s - opcode->opcode == 16);
	  assert (opcode->bin_opcode == bin);
	  *maskptr = mask;
	}

      initialized = 1;
    }

  insn = avrdis_opcode (addr, info);
  
  for (opcode = avr_opcodes, maskptr = avr_bin_masks;
       opcode->name;
       opcode++, maskptr++)
    if ((insn & *maskptr) == opcode->bin_opcode)
      break;
  
  /* Special case: disassemble `ldd r,b+0' as `ld r,b', and
     `std b+0,r' as `st b,r' (next entry in the table).  */

  if (AVR_DISP0_P (insn))
    opcode++;

  op1[0] = 0;
  op2[0] = 0;
  comment1[0] = 0;
  comment2[0] = 0;

  if (opcode->name)
    {
      char *constraints = opcode->constraints;
      char *opcode_str = opcode->opcode;

      insn2 = 0;
      ok = 1;

      if (opcode->insn_size > 1)
	{
	  insn2 = avrdis_opcode (addr + 2, info);
	  cmd_len = 4;
	}

      if (*constraints && *constraints != '?')
	{
	  int regs = REGISTER_P (*constraints);

	  ok = avr_operand (insn, insn2, addr, *constraints, opcode_str, op1, comment1, 0, &sym_op1, &sym_addr1);

	  if (ok && *(++constraints) == ',')
	    ok = avr_operand (insn, insn2, addr, *(++constraints), opcode_str, op2,
			      *comment1 ? comment2 : comment1, regs, &sym_op2, &sym_addr2);
	}
    }

  if (!ok)
    {
      /* Unknown opcode, or invalid combination of operands.  */
      sprintf (op1, "0x%04x", insn);
      op2[0] = 0;
      sprintf (comment1, "????");
      comment2[0] = 0;
    }

  (*prin) (stream, "%s", ok ? opcode->name : ".word");

  if (*op1)
      (*prin) (stream, "\t%s", op1);

  if (*op2)
    (*prin) (stream, ", %s", op2);

  if (*comment1)
    (*prin) (stream, "\t; %s", comment1);

  if (sym_op1)
    info->print_address_func (sym_addr1, info);

  if (*comment2)
    (*prin) (stream, " %s", comment2);

  if (sym_op2)
    info->print_address_func (sym_addr2, info);

  return cmd_len;
}
@


1.24
log
@	PR binutils/12329
	* avr-dis.c (avr_operand): Fix disassembly of ELPM, LPM and SPM
	insns using post-increment addressing.

	* avr.h (AVR_ISA_AVR6): Fix typo, adding AVR_ISA_SPMX.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2004, 2005, 2006, 2007, 2008
d24 1
a25 1
#include "sysdep.h"
@


1.23
log
@/bfd:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* archures.c: Add AVR XMEGA architecture information.
	* cpu-avr.c (arch_info_struct): Likewise.
	* elf32-avr.c (bfd_elf_avr_final_write_processing): Likewise.
	(elf32_avr_object_p): Likewise.

/gas:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (struct avr_opcodes_s): Add opcode field.
	(AVR_INSN): Change definition to match.
	(avr_opcodes): Likewise, change to match.
	(mcu_types): Add XMEGA architecture names and new XMEGA device names.
	(md_show_usage): Add XMEGA architecture names.
	(avr_operand): Add 'E' constraint for DES instruction of XMEGA devices.
	Add support for SPM Z+ instruction.
	* doc/c-avr.texi: Add documentation for XMEGA architectures and
	devices.

/include/opcode:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* avr.h (AVR_ISA_SPMX,AVR_ISA_DES,AVR_ISA_M256,AVR_ISA_XMEGA):
	New instruction set flags.
	(AVR_INSN): Add new instructions for SPM Z+, DES for XMEGA.

/ld:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* Makefile.am (ALL_EMULATION_SOURCES): Add AVR XMEGA architectures.
	(eavrxmega?.c): Likewise.
	* configure.tgt (targ_extra_emuls): Likewise.
	* emulparams/avrxmega1.sh: New file.
	* emulparams/avrxmega2.sh: Likewise.
	* emulparams/avrxmega3.sh: Likewise.
	* emulparams/avrxmega4.sh: Likewise.
	* emulparams/avrxmega5.sh: Likewise.
	* emulparams/avrxmega6.sh: Likewise.
	* emulparams/avrxmega7.sh: Likewise.
	* emultempl/avrelf.em (avr_elf_${EMULATION_NAME}_before_allocation):
	Add avrxmega6, avrxmega7 to list of architectures for no stubs.

/opcodes:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* avr-dis.c (avr_operand): Add opcode_str parameter. Check for
	post-increment to support LPM Z+ instruction. Add support for 'E'
	constraint for DES instruction.
	(print_insn_avr): Adjust calls to avr_operand. Rename variable.
@
text
@d128 2
a129 1
	*buf++ = '+';
@


1.22
log
@        * avr-dis.c: Replace uses of sprintf without a format string with
        calls to strcpy.
@
text
@d53 1
a53 1
             char *buf, char *comment, int regs, int *sym, bfd_vma *sym_addr)
d121 7
a127 1
      if (insn & 0x1)
d129 4
d240 4
d348 2
a349 1
      char *op = opcode->constraints;
d360 1
a360 1
      if (*op && *op != '?')
d362 1
a362 1
	  int regs = REGISTER_P (*op);
d364 1
a364 1
	  ok = avr_operand (insn, insn2, addr, *op, op1, comment1, 0, &sym_op1, &sym_addr1);
d366 2
a367 2
	  if (ok && *(++op) == ',')
	    ok = avr_operand (insn, insn2, addr, *(++op), op2,
@


1.21
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2004, 2005, 2006, 2007
d112 1
a112 1
	sprintf (buf, xyz);
d152 1
a152 1
      sprintf (comment, comment_start);
d161 1
a161 1
	sprintf (comment, comment_start);
d172 1
a172 1
	sprintf (comment, comment_start);
@


1.20
log
@PR binutils/4045
* avr-dis.c (comment_start): New variable, contains the prefix to use when
    printing addresses in comments.
  (print_insn_avr): Set comment_start to an empty space if there is no symbol
     table available as the generic address printing code will prefix the
     numeric value of the address with 0x.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2004, 2005, 2006
d7 3
a9 1
   This program is free software; you can redistribute it and/or modify
d11 2
a12 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d14 4
a17 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.19
log
@2007-02-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* avr-dis.c (avr_operand): Correct PR number in comment.
@
text
@d46 2
d149 1
a149 2
      sprintf (comment, "0x");

d158 1
a158 1
	sprintf (comment, "0x");
d165 1
d169 1
a169 1
	sprintf (comment, "0x");
d272 1
d277 6
@


1.18
log
@	* avr-dis.c: Formatting fix.
@
text
@d143 1
a143 1
      /* See PR binutils/2545.  Ideally we would like to display the hex
@


1.17
log
@	* avr-dis.c (avr_operand): Warning fix.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2002, 2004, 2005 Free Software Foundation, Inc.
d146 1
a146 1
      sprintf (buf, "%#lx", (unsigned long ) *sym_addr);      
@


1.16
log
@PR binutils/2454
* avr-dis.c (avr_operand): Arrange for a comment to appear before the symolic
form of an address, so that the output of objdump -d can be reassembled.
@
text
@d145 1
a145 1
      sprintf (buf, "%#lx", * sym_addr);      
@


1.16.2.1
log
@	* avr-dis.c (avr_operand): Warning fix.
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2002, 2004, 2005, 2006
   Free Software Foundation, Inc.
d145 1
a145 1
      sprintf (buf, "%#lx", (unsigned long) *sym_addr);      
@


1.15
log
@Update function declarations to ISO C90 formatting
@
text
@d142 6
a147 1
      sprintf (buf, "0x");
@


1.15.14.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2002, 2004, 2005, 2006
   Free Software Foundation, Inc.
d142 1
a142 6
      /* See PR binutils/2545.  Ideally we would like to display the hex
	 value of the address only once, but this would mean recoding
	 objdump_print_address() which would affect many targets.  */
      sprintf (buf, "%#lx", (unsigned long) *sym_addr);      
      sprintf (comment, "0x");

@


1.14
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2002, 2004 Free Software Foundation, Inc.
d6 13
a18 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d31 1
a31 1
  int insn_size;		/* in words */
a44 3
static int avr_operand (unsigned int, unsigned int, unsigned int, int,
                        char *, char *, int, int *, bfd_vma *);

d57 1
a57 1
	insn = (insn & 0xf) | ((insn & 0x0200) >> 5); /* source register */
d59 1
a59 1
	insn = (insn & 0x01f0) >> 4; /* destination register */
d201 1
a231 2
static unsigned short avrdis_opcode PARAMS ((bfd_vma, disassemble_info *));

d233 1
a233 3
avrdis_opcode (addr, info)
     bfd_vma addr;
     disassemble_info *info;
d237 8
a244 7
  status = info->read_memory_func(addr, buffer, 2, info);
  if (status != 0)
    {
      info->memory_error_func(status, addr, info);
      return -1;
    }
  return bfd_getl16 (buffer);
d249 1
a249 3
print_insn_avr(addr, info)
     bfd_vma addr;
     disassemble_info *info;
d270 1
a270 2
      avr_bin_masks = (unsigned int *)
	xmalloc (nopcodes * sizeof (unsigned int));
d300 2
a301 4
    {
      if ((insn & *maskptr) == opcode->bin_opcode)
	break;
    }
@


1.13
log
@update copyright dates
@
text
@d18 1
a18 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.12
log
@Added printing of symbols on AVR disasm
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.11
log
@Added printing of symbols on AVR disasm
@
text
@d370 1
a370 1
    info->print_address_func(sym_addr1, info);
d376 1
a376 1
    info->print_address_func(sym_addr2, info);
@


1.10
log
@2002-11-12  Klee Dienes  <kdienes@@apple.com>

	* avr-dis.c: Include libiberty.h (for xmalloc).
	(struct avr_opcodes_s): Remove 'bin_mask' field (it's
	automatically computed in the init routine).
	(AVR_INSN): No longer provide bin_mask field in initializer.
	(avr_opcodes_s): Declare as const.
	(print_insn_avr): Store the bin_mask field in a separate table
	(allocated with xmalloc); iterate through it at the same time as
	we iterate through the opcodes.
@
text
@d45 2
a46 2
static int avr_operand PARAMS ((unsigned int, unsigned int,
				unsigned int, int, char *, char *, int));
d49 2
a50 8
avr_operand (insn, insn2, pc, constraint, buf, comment, regs)
     unsigned int insn;
     unsigned int insn2;
     unsigned int pc;
     int constraint;
     char *buf;
     char *comment;
     int regs;
d53 1
d143 3
a145 2
      sprintf (buf, "0x%x",
	       ((((insn & 1) | ((insn & 0x1f0) >> 3)) << 16) | insn2) * 2);
d152 3
a154 1
	sprintf (comment, "0x%x", pc + 2 + rel_addr);
d162 3
a164 1
	sprintf (comment, "0x%x", pc + 2 + rel_addr);
d268 2
d341 1
a341 1
	  ok = avr_operand (insn, insn2, addr, *op, op1, comment1, 0);
d345 1
a345 1
			      *comment1 ? comment2 : comment1, regs);
d361 1
a361 1
    (*prin) (stream, "\t%s", op1);
d369 3
d375 3
@


1.9
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d24 1
a24 1

a33 1
  unsigned int bin_mask;
d37 1
a37 1
{#NAME, CONSTR, OPCODE, SIZE, ISA, BIN, 0},
d39 1
a39 1
struct avr_opcodes_s avr_opcodes[] =
d42 1
a42 1
  {NULL, NULL, NULL, 0, 0, 0, 0}
d259 2
a260 1
  struct avr_opcodes_s *opcode;
d263 1
d271 3
a273 1
      initialized = 1;
d275 6
a280 1
      for (opcode = avr_opcodes; opcode->name; opcode++)
d295 1
a295 1
	  opcode->bin_mask = mask;
d297 2
d303 3
a305 1
  for (opcode = avr_opcodes; opcode->name; opcode++)
d307 1
a307 1
      if ((insn & opcode->bin_mask) == opcode->bin_opcode)
@


1.9.30.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d24 1
a24 1
#include "libiberty.h"
d34 1
d38 1
a38 1
{#NAME, CONSTR, OPCODE, SIZE, ISA, BIN},
d40 1
a40 1
const struct avr_opcodes_s avr_opcodes[] =
d43 1
a43 1
  {NULL, NULL, NULL, 0, 0, 0}
d260 1
a260 2
  const struct avr_opcodes_s *opcode;
  static unsigned int *maskptr;
a262 1
  static unsigned int *avr_bin_masks;
d270 1
a270 3
      unsigned int nopcodes;

      nopcodes = sizeof (avr_opcodes) / sizeof (struct avr_opcodes_s);
d272 1
a272 6
      avr_bin_masks = (unsigned int *)
	xmalloc (nopcodes * sizeof (unsigned int));

      for (opcode = avr_opcodes, maskptr = avr_bin_masks;
	   opcode->name;
	   opcode++, maskptr++)
d287 1
a287 1
	  *maskptr = mask;
a288 2

      initialized = 1;
d293 1
a293 3
  for (opcode = avr_opcodes, maskptr = avr_bin_masks;
       opcode->name;
       opcode++, maskptr++)
d295 1
a295 1
      if ((insn & *maskptr) == opcode->bin_opcode)
@


1.9.28.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d24 1
a24 1
#include "libiberty.h"
d34 1
d38 1
a38 1
{#NAME, CONSTR, OPCODE, SIZE, ISA, BIN},
d40 1
a40 1
const struct avr_opcodes_s avr_opcodes[] =
d43 1
a43 1
  {NULL, NULL, NULL, 0, 0, 0}
d260 1
a260 2
  const struct avr_opcodes_s *opcode;
  static unsigned int *maskptr;
a262 1
  static unsigned int *avr_bin_masks;
d270 1
a270 3
      unsigned int nopcodes;

      nopcodes = sizeof (avr_opcodes) / sizeof (struct avr_opcodes_s);
d272 1
a272 6
      avr_bin_masks = (unsigned int *)
	xmalloc (nopcodes * sizeof (unsigned int));

      for (opcode = avr_opcodes, maskptr = avr_bin_masks;
	   opcode->name;
	   opcode++, maskptr++)
d287 1
a287 1
	  *maskptr = mask;
a288 2

      initialized = 1;
d293 1
a293 3
  for (opcode = avr_opcodes, maskptr = avr_bin_masks;
       opcode->name;
       opcode++, maskptr++)
d295 1
a295 1
      if ((insn & *maskptr) == opcode->bin_opcode)
@


1.8
log
@	* avr-dis.c (avr_operand): Use PARAMS macro in declaration.
	Change return type from void to int.  Check the combination
	of operands, return 1 if valid.  Fix to avoid BUF overflow.
	Report undefined combinations of operands in COMMENT.
	Report internal errors to stderr.  Output the adiw/sbiw
	constant operand in both decimal and hex.
	(print_insn_avr): Disassemble ldd/std with displacement of 0
	as ld/st.  Check avr_operand () return value, handle invalid
	combinations of operands like unknown opcodes.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.7
log
@Tidy up formatting.
Add  -mall-opcodes, -mno-skip-bug, -mno-wrap.
@
text
@d46 2
d49 1
a49 5
static void avr_operand (unsigned int insn, unsigned int insn2,
			 unsigned int pc, int constraint, char *buf,
			 char *comment, int regs);

static void
d59 2
d99 21
a119 12
      if (insn & 0x2)
	*buf++ = '-';
      switch ((insn >> 2) & 0x3)
	{
	case 0: *buf++ = 'Z'; break;
	case 2: *buf++ = 'Y'; break;
	case 3: *buf++ = 'X'; break;
	default: buf += sprintf (buf, _(" unknown register ")); break;
	}
      if (insn & 0x1)
	*buf++ = '+';
      *buf = '\0';
d127 2
d133 1
a133 1
	unsigned int x = insn;
d179 3
a181 1
      sprintf (buf, _("Internal disassembler error"));
d185 7
a191 1
      sprintf (buf, "%d", (insn & 0xf) | ((insn >> 2) & 0x30));
d227 3
a229 1
      sprintf (buf, _("unknown constraint `%c'"), constraint);
d231 2
d265 2
d299 11
a311 1
      char op1[20], op2[20], comment1[40], comment2[40];
a313 4
      op1[0] = 0;
      op2[0] = 0;
      comment1[0] = 0;
      comment2[0] = 0;
d315 1
d327 1
a327 1
	  avr_operand (insn, insn2, addr, *op, op1, comment1, 0);
d329 3
a331 3
	  if (*(++op) == ',')
	    avr_operand (insn, insn2, addr, *(++op), op2,
			 *comment1 ? comment2 : comment1, regs);
d333 1
d335 8
a342 1
      (*prin) (stream, "    %-8s", opcode->name);
d344 1
a344 2
      if (*op1)
	(*prin) (stream, "%s", op1);
d346 2
a347 2
      if (*op2)
	(*prin) (stream, ", %s", op2);
d349 8
a356 2
      if (*comment1)
	(*prin) (stream, "\t; %s", comment1);
a357 6
      if (*comment2)
	(*prin) (stream, " %s", comment2);
    }
  else
   (*prin) (stream, ".word 0x%04x\t; ????", insn);
  
@


1.6
log
@	* avr-dis.c (avr_operand): Bugfix for jmp/call address.
@
text
@d106 1
a106 1
	default: buf += sprintf (buf, _ (" unknown register ")); break;
d168 1
a168 1
      sprintf (buf, _ ("Internal disassembler error"));
d208 1
a208 1
      sprintf (buf, _ ("unknown constraint `%c'"), constraint);
d283 1
@


1.5
log
@	* avr-dis.c: completely rewritten.
@
text
@d138 2
a139 1
      sprintf (buf, "0x%x%x", (insn & 1) | ((insn & (0x1f << 4)) >> 3), insn2);
@


1.4
log
@	* avr-dis.c (reg_fmul_d): New. Extract destination register from
	FMUL instruction.
	(reg_fmul_r): New. Extract source register from FMUL instruction.
	(reg_muls_d): New. Extract destination register from MULS instruction.
	(reg_muls_r): New. Extract source register from MULS instruction.
	(reg_movw_d): New. Extract destination register from MOVW instruction.
	(reg_movw_r): New. Extract source register from MOVW instruction.
	(print_insn_avr): Handle MOVW, MULS, MULSU, FMUL, FMULS, FMULSU,
	EICALL, EIJMP, LPM r,Z, ELPM r,Z, SPM, ESPM instructions.
@
text
@d20 1
a20 1

a24 19
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned long u32;

#define IFMASK(a,b)     ((opcode & (a)) == (b))

static char* SREG_flags = "CZNVSHTI";
static char* sect94[] = {"COM","NEG","SWAP","INC",0,"ASR","LSR","ROR",
			 0,0,"DEC",0,0,0,0,0};
static char* sect98[] = {"CBI","SBIC","SBI","SBIS"};
static char* branchs[] = {
  "BRCS","BREQ","BRMI","BRVS",
  "BRLT","BRHS","BRTS","BRIE",
  "BRCC","BRNE","BRPL","BRVC",
  "BRGE","BRHC","BRTC","BRID"
};

static char* last4[] = {"BLD","BST","SBRC","SBRS"};

d26 1
a26 6
static void dispLDD PARAMS ((u16, char *));

static void
dispLDD (opcode, dest)
     u16 opcode;
     char *dest;
d28 8
a35 5
  opcode = (((opcode & 0x2000) >> 8) | ((opcode & 0x0c00) >> 7)
	    | (opcode & 7));
  sprintf(dest, "%d", opcode);
}

d37 2
a38 1
static void regPP PARAMS ((u16, char *));
d40 1
a40 4
static void
regPP (opcode, dest)
     u16 opcode;
     char *dest;
d42 3
a44 3
  opcode = ((opcode & 0x0600) >> 5) | (opcode & 0xf);
  sprintf(dest, "0x%02X", opcode);
}
d47 3
a49 1
static void reg50 PARAMS ((u16, char *));
d52 8
a59 3
reg50 (opcode, dest)
     u16 opcode;
     char *dest;
d61 29
a89 3
  opcode = (opcode & 0x01f0) >> 4;
  sprintf(dest, "R%d", opcode);
}
d91 6
d98 111
a208 21
static void reg104 PARAMS ((u16, char *));

static void
reg104 (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = (opcode & 0xf) | ((opcode & 0x0200) >> 5);
  sprintf(dest, "R%d", opcode);
}


static void reg40 PARAMS ((u16, char *));

static void
reg40 (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = (opcode & 0xf0) >> 4;
  sprintf(dest, "R%d", opcode + 16);
d211 1
d213 1
a213 131
static void reg20w PARAMS ((u16, char *));

static void
reg20w (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = (opcode & 0x30) >> 4;
  sprintf(dest, "R%d", 24 + opcode * 2);
}


static void reg_fmul_d PARAMS ((u16, char *));

static void
reg_fmul_d (opcode, dest)
     u16 opcode;
     char *dest;
{
  sprintf(dest, "R%d", 16 + ((opcode >> 4) & 7));
}


static void reg_fmul_r PARAMS ((u16, char *));

static void
reg_fmul_r (opcode, dest)
     u16 opcode;
     char *dest;
{
  sprintf(dest, "R%d", 16 + (opcode & 7));
}


static void reg_muls_d PARAMS ((u16, char *));

static void
reg_muls_d (opcode, dest)
     u16 opcode;
     char *dest;
{
  sprintf(dest, "R%d", 16 + ((opcode >> 4) & 0xf));
}


static void reg_muls_r PARAMS ((u16, char *));

static void
reg_muls_r (opcode, dest)
     u16 opcode;
     char *dest;
{
  sprintf(dest, "R%d", 16 + (opcode & 0xf));
}


static void reg_movw_d PARAMS ((u16, char *));

static void
reg_movw_d (opcode, dest)
     u16 opcode;
     char *dest;
{
  sprintf(dest, "R%d", 2 * ((opcode >> 4) & 0xf));
}


static void reg_movw_r PARAMS ((u16, char *));

static void
reg_movw_r (opcode, dest)
     u16 opcode;
     char *dest;
{
  sprintf(dest, "R%d", 2 * (opcode & 0xf));
}


static void lit404 PARAMS ((u16, char *));

static void
lit404 (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = ((opcode & 0xf00) >> 4) | (opcode & 0xf);
  sprintf(dest, "0x%02X", opcode);
}


static void lit204 PARAMS ((u16, char *));

static void
lit204 (opcode, dest)
     u16 opcode;
     char *dest;
{
  opcode = ((opcode & 0xc0) >> 2) | (opcode & 0xf);
  sprintf(dest, "0x%02X", opcode);
}


static void add0fff PARAMS ((u16, char *, int));

static void
add0fff (op, dest, pc)
     u16 op;
     char *dest;
     int pc;
{
  int rel_addr = (((op & 0xfff) ^ 0x800) - 0x800) * 2;
  sprintf(dest, ".%+-8d ; 0x%06X", rel_addr, pc + 2 + rel_addr);
}


static void add03f8 PARAMS ((u16, char *, int));

static void
add03f8 (op, dest, pc)
     u16 op;
     char *dest;
     int pc;
{
  int rel_addr = ((((op >> 3) & 0x7f) ^ 0x40) - 0x40) * 2;
  sprintf(dest, ".%+-8d ; 0x%06X", rel_addr, pc + 2 + rel_addr);
}


static u16 avrdis_opcode PARAMS ((bfd_vma, disassemble_info *));

static u16
d235 2
a236 3
  char rr[200];
  char rd[200];
  u16 opcode;
d239 1
d242 22
a263 1
  opcode = avrdis_opcode (addr, info);
d265 3
a267 1
  if (IFMASK(0xd000, 0x8000))
d269 2
a270 11
      char letter;
      reg50(opcode, rd);
      dispLDD(opcode, rr);
      if (opcode & 8)
	letter = 'Y';
      else
	letter = 'Z';
      if (opcode & 0x0200)
	(*prin) (stream, "    STD     %c+%s,%s", letter, rr, rd);
      else
	(*prin) (stream, "    LDD     %s,%c+%s", rd, letter, rr);
d272 2
a273 1
  else
d275 38
a312 371
      switch (opcode & 0xf000)
        {
        case 0x0000:
	  {
	    reg50(opcode, rd);
	    reg104(opcode, rr);
	    switch (opcode & 0x0c00)
	      {
	      case 0x0000:
		switch (opcode & 0x0300)
		  {
		  case 0x0000:
		    (*prin) (stream, "    NOP");
		    break;
		  case 0x0100:
		    reg_movw_d(opcode, rd);
		    reg_movw_r(opcode, rr);
		    (*prin) (stream, "    MOVW    %s,%s", rd, rr);
		    break;
		  case 0x0200:
		    reg_muls_d(opcode, rd);
		    reg_muls_r(opcode, rr);
		    (*prin) (stream, "    MULS    %s,%s", rd, rr);
		    break;
		  case 0x0300:
		    reg_fmul_d(opcode, rd);
		    reg_fmul_r(opcode, rr);
		    if (IFMASK(0x88, 0))
		      (*prin) (stream, "    MULSU   %s,%s", rd, rr);
		    else if (IFMASK(0x88, 8))
		      (*prin) (stream, "    FMUL    %s,%s", rd, rr);
		    else if (IFMASK(0x88, 0x80))
		      (*prin) (stream, "    FMULS   %s,%s", rd, rr);
		    else
		      (*prin) (stream, "    FMULSU  %s,%s", rd, rr);
		  }
		break;
	      case 0x0400:
		(*prin) (stream, "    CPC     %s,%s", rd, rr);
		break;
	      case 0x0800:
		(*prin) (stream, "    SBC     %s,%s", rd, rr);
		break;
	      case 0x0c00:
		(*prin) (stream, "    ADD     %s,%s", rd, rr);
		break;
	      }
	  }
	  break;
        case 0x1000:
	  {
	    reg50(opcode, rd);
	    reg104(opcode, rr);
	    switch (opcode & 0x0c00)
	      {
	      case 0x0000:
		(*prin) (stream, "    CPSE    %s,%s", rd, rr);
		break;
	      case 0x0400:
		(*prin) (stream, "    CP      %s,%s", rd, rr);
		break;
	      case 0x0800:
		(*prin) (stream, "    SUB     %s,%s", rd, rr);
		break;
	      case 0x0c00:
		(*prin) (stream, "    ADC     %s,%s", rd, rr);
		break;
	      }
	  }
	  break;
        case 0x2000:
	  {
	    reg50(opcode, rd);
	    reg104(opcode, rr);
	    switch (opcode & 0x0c00)
	      {
	      case 0x0000:
		(*prin) (stream, "    AND     %s,%s", rd, rr);
		break;
	      case 0x0400:
		(*prin) (stream, "    EOR     %s,%s", rd, rr);
		break;
	      case 0x0800:
		(*prin) (stream, "    OR      %s,%s", rd, rr);
		break;
	      case 0x0c00:
		(*prin) (stream, "    MOV     %s,%s", rd, rr);
		break;
	      }
	  }
	  break;
        case 0x3000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    CPI     %s,%s", rd, rr);
	  }
	  break;
        case 0x4000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    SBCI    %s,%s", rd, rr);
	  }
	  break;
        case 0x5000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    SUBI    %s,%s", rd, rr);
	  }
	  break;
        case 0x6000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    ORI     %s,%s", rd, rr);
	  }
	  break;
        case 0x7000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    ANDI    %s,%s", rd, rr);
	  }
	  break;
        case 0x9000:
	  {
	    switch (opcode & 0x0e00)
	      {
	      case 0x0000:
		{
		  reg50(opcode, rd);
		  switch (opcode & 0xf)
		    {
		    case 0x0:
		      {
			(*prin) (stream, "    LDS     %s,0x%04X", rd,
				 avrdis_opcode(addr + 2, info));
			cmd_len = 4;
		      }
		      break;
		    case 0x1:
		      (*prin) (stream, "    LD      %s,Z+", rd);
		      break;
		    case 0x2:
		      (*prin) (stream, "    LD      %s,-Z", rd);
		      break;
		    case 0x4:
		      (*prin) (stream, "    LPM     %s,Z", rd);
		      break;
		    case 0x5:
		      (*prin) (stream, "    LPM     %s,Z+", rd);
		      break;
		    case 0x6:
		      (*prin) (stream, "    ELPM    %s,Z", rd);
		      break;
		    case 0x7:
		      (*prin) (stream, "    ELPM    %s,Z+", rd);
		      break;
		    case 0x9:
		      (*prin) (stream, "    LD      %s,Y+", rd);
		      break;
		    case 0xa:
		      (*prin) (stream, "    LD      %s,-Y", rd);
		      break;
		    case 0xc:
		      (*prin) (stream, "    LD      %s,X", rd);
		      break;
		    case 0xd:
		      (*prin) (stream, "    LD      %s,X+", rd);
		      break;
		    case 0xe:
		      (*prin) (stream, "    LD      %s,-X", rd);
		      break;
		    case 0xf:
		      (*prin) (stream, "    POP     %s", rd);
		      break;
		    default:
		      (*prin) (stream, "    ????");
		      break;
		    }
		}
		break;
	      case 0x0200:
		{
		  reg50(opcode, rd);
		  switch (opcode & 0xf)
		    {
		    case 0x0:
		      {
			(*prin) (stream, "    STS     0x%04X,%s",
				 avrdis_opcode(addr + 2, info), rd);
			cmd_len = 4;
		      }
		      break;
		    case 0x1:
		      (*prin) (stream, "    ST      Z+,%s", rd);
		      break;
		    case 0x2:
		      (*prin) (stream, "    ST      -Z,%s", rd);
		      break;
		    case 0x9:
		      (*prin) (stream, "    ST      Y+,%s", rd);
		      break;
		    case 0xa:
		      (*prin) (stream, "    ST      -Y,%s", rd);
		      break;
		    case 0xc:
		      (*prin) (stream, "    ST      X,%s", rd);
		      break;
		    case 0xd:
		      (*prin) (stream, "    ST      X+,%s", rd);
		      break;
		    case 0xe:
		      (*prin) (stream, "    ST      -X,%s", rd);
		      break;
		    case 0xf:
		      (*prin) (stream, "    PUSH    %s", rd);
		      break;
		    default:
		      (*prin) (stream, "    ????");
		      break;
		    }
		}
		break;
	      case 0x0400:
		{
		  if (IFMASK(0x020c, 0x000c))
		    {
		      u32 k = ((opcode & 0x01f0) >> 3) | (opcode & 1);
		      k = (k << 16) | avrdis_opcode(addr + 2, info);
		      if (opcode & 0x0002)
			(*prin) (stream, "    CALL    0x%06X", k*2);
		      else
			(*prin) (stream, "    JMP     0x%06X", k*2);
		      cmd_len = 4;
		    }
		  else if (IFMASK(0x010f, 0x0008))
		    {
		      int sf = (opcode & 0x70) >> 4;
		      if (opcode & 0x0080)
			(*prin) (stream, "    CL%c", SREG_flags[sf]);
		      else
			(*prin) (stream, "    SE%c", SREG_flags[sf]);
		    }
		  else if (IFMASK(0x001f, 0x0009))
		    {
		      if (opcode & 0x0100)
			(*prin) (stream, "    ICALL");
		      else
			(*prin) (stream, "    IJMP");
		    }
		  else if (IFMASK(0x001f, 0x0019))
		    {
		      if (opcode & 0x0100)
			(*prin) (stream, "    EICALL");
		      else
			(*prin) (stream, "    EIJMP");
		    }
		  else if (IFMASK(0x010f, 0x0108))
		    {
		      if (IFMASK(0x0090, 0x0000))
			(*prin) (stream, "    RET");
		      else if (IFMASK(0x0090, 0x0010))
			(*prin) (stream, "    RETI");
		      else if (IFMASK(0x00e0, 0x0080))
			(*prin) (stream, "    SLEEP");
		      else if (IFMASK(0x00e0, 0x00a0))
			(*prin) (stream, "    WDR");
		      else if (IFMASK(0x00f0, 0x00c0))
			(*prin) (stream, "    LPM");
		      else if (IFMASK(0x00f0, 0x00d0))
			(*prin) (stream, "    ELPM");
		      else if (IFMASK(0x00f0, 0x00e0))
			(*prin) (stream, "    SPM");
		      else if (IFMASK(0x00f0, 0x00f0))
			(*prin) (stream, "    ESPM");
		      else
			(*prin) (stream, "    ????");
		    }
		  else
		    {
		      const char* p;
		      reg50(opcode, rd);
		      p = sect94[opcode & 0xf];
		      if (!p)
			p = "????";
		      (*prin) (stream, "    %-8s%s", p, rd);
		    }
		}
		break;
	      case 0x0600:
		{
		  if (opcode & 0x0200)
		    {
		      lit204(opcode, rd);
		      reg20w(opcode, rr);
		      if (opcode & 0x0100)
			(*prin) (stream, "    SBIW    %s,%s", rr, rd);
		      else
			(*prin) (stream, "    ADIW    %s,%s", rr, rd);
		    }
		}
		break;
	      case 0x0800:
	      case 0x0a00:
		{
		  (*prin) (stream, "    %-8s0x%02X,%d",
			   sect98[(opcode & 0x0300) >> 8],
			   (opcode & 0xf8) >> 3,
			   opcode & 7);
		}
		break;
	      default:
		{
		  reg50(opcode, rd);
		  reg104(opcode, rr);
		  (*prin) (stream, "    MUL     %s,%s", rd, rr);
		}
	      }
	  }
	  break;
        case 0xb000:
	  {
	    reg50(opcode, rd);
	    regPP(opcode, rr);
	    if (opcode & 0x0800)
	      (*prin) (stream, "    OUT     %s,%s", rr, rd);
	    else
	      (*prin) (stream, "    IN      %s,%s", rd, rr);
	  }
	  break;
        case 0xc000:
	  {
	    add0fff(opcode, rd, addr);
	    (*prin) (stream, "    RJMP    %s", rd);
	  }
	  break;
        case 0xd000:
	  {
	    add0fff(opcode, rd, addr);
	    (*prin) (stream, "    RCALL   %s", rd);
	  }
	  break;
        case 0xe000:
	  {
	    reg40(opcode, rd);
	    lit404(opcode, rr);
	    (*prin) (stream, "    LDI     %s,%s", rd, rr);
	  }
	  break;
        case 0xf000:
	  {
	    if (opcode & 0x0800)
	      {
		reg50(opcode, rd);
		(*prin) (stream, "    %-8s%s,%d",
			 last4[(opcode & 0x0600) >> 9],
			 rd, opcode & 7);
	      }
	    else
	      {
		char* p;
		add03f8(opcode, rd, addr);
		p = branchs[((opcode & 0x0400) >> 7) | (opcode & 7)];
		(*prin) (stream, "    %-8s%s", p, rd);
	      }
	  }
	  break;
        }
d314 3
@


1.3
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d32 1
a32 1
static char* sect94[] = {"COM","NEG","SWAP","INC","NULL","ASR","LSR","ROR",
d118 66
d292 27
a318 1
		(*prin) (stream, "    NOP");
d431 12
d529 1
a529 1
		  else if (IFMASK(0x000f, 0x0009))
d536 7
d557 4
@


1.2
log
@Tidy some code.  Print pc rel addresses as signed.
@
text
@d21 1
@


1.1
log
@ATMEL AVR microcontroller support.
@
text
@a28 1
#define CODE_MAX        65537
d40 1
a43 1

d149 2
a150 2
  int opcode = op & 0x0fff;
  sprintf(dest, ".%+-8d ; 0x%06X", opcode * 2, pc + 2 + opcode * 2);
d162 2
a163 2
  int opcode = (op >> 3) & 0x7f;
  sprintf(dest, ".%+-8d ; 0x%06X", opcode * 2, pc + 2 + opcode * 2);
d333 1
a333 3
		      {
			(*prin) (stream, "    LD      %s,Z+", rd);
		      }
d336 1
a336 3
		      {
			(*prin) (stream, "    LD      %s,-Z", rd);
		      }
d339 1
a339 3
		      {
			(*prin) (stream, "    LD      %s,Y+", rd);
		      }
d342 1
a342 3
		      {
			(*prin) (stream, "    LD      %s,-Y", rd);
		      }
d345 1
a345 3
		      {
			(*prin) (stream, "    LD      %s,X", rd);
		      }
d348 1
a348 3
		      {
			(*prin) (stream, "    LD      %s,X+", rd);
		      }
d351 1
a351 3
		      {
			(*prin) (stream, "    LD      %s,-X", rd);
		      }
d354 1
a354 3
		      {
			(*prin) (stream, "    POP     %s", rd);
		      }
d357 1
a357 3
		      {
			(*prin) (stream, "    ????");
		      }
d375 1
a375 3
		      {
			(*prin) (stream, "    ST      Z+,%s", rd);
		      }
d378 1
a378 3
		      {
			(*prin) (stream, "    ST      -Z,%s", rd);
		      }
d381 1
a381 3
		      {
			(*prin) (stream, "    ST      Y+,%s", rd);
		      }
d384 1
a384 3
		      {
			(*prin) (stream, "    ST      -Y,%s", rd);
		      }
d387 1
a387 3
		      {
			(*prin) (stream, "    ST      X,%s", rd);
		      }
d390 1
a390 3
		      {
			(*prin) (stream, "    ST      X+,%s", rd);
		      }
d393 1
a393 3
		      {
			(*prin) (stream, "    ST      -X,%s", rd);
		      }
d396 1
a396 3
		      {
			(*prin) (stream, "    PUSH    %s", rd);
		      }
d399 1
a399 3
		      {
			(*prin) (stream, "    ????");
		      }
@


1.1.2.1
log
@Tidy some code.  Print pc rel addresses as signed.
@
text
@d29 1
d41 1
a42 1
static char* last4[] = {"BLD","BST","SBRC","SBRS"};
d150 2
a151 2
  int rel_addr = (((op & 0xfff) ^ 0x800) - 0x800) * 2;
  sprintf(dest, ".%+-8d ; 0x%06X", rel_addr, pc + 2 + rel_addr);
d163 2
a164 2
  int rel_addr = ((((op >> 3) & 0x7f) ^ 0x40) - 0x40) * 2;
  sprintf(dest, ".%+-8d ; 0x%06X", rel_addr, pc + 2 + rel_addr);
d334 3
a336 1
		      (*prin) (stream, "    LD      %s,Z+", rd);
d339 3
a341 1
		      (*prin) (stream, "    LD      %s,-Z", rd);
d344 3
a346 1
		      (*prin) (stream, "    LD      %s,Y+", rd);
d349 3
a351 1
		      (*prin) (stream, "    LD      %s,-Y", rd);
d354 3
a356 1
		      (*prin) (stream, "    LD      %s,X", rd);
d359 3
a361 1
		      (*prin) (stream, "    LD      %s,X+", rd);
d364 3
a366 1
		      (*prin) (stream, "    LD      %s,-X", rd);
d369 3
a371 1
		      (*prin) (stream, "    POP     %s", rd);
d374 3
a376 1
		      (*prin) (stream, "    ????");
d394 3
a396 1
		      (*prin) (stream, "    ST      Z+,%s", rd);
d399 3
a401 1
		      (*prin) (stream, "    ST      -Z,%s", rd);
d404 3
a406 1
		      (*prin) (stream, "    ST      Y+,%s", rd);
d409 3
a411 1
		      (*prin) (stream, "    ST      -Y,%s", rd);
d414 3
a416 1
		      (*prin) (stream, "    ST      X,%s", rd);
d419 3
a421 1
		      (*prin) (stream, "    ST      X+,%s", rd);
d424 3
a426 1
		      (*prin) (stream, "    ST      -X,%s", rd);
d429 3
a431 1
		      (*prin) (stream, "    PUSH    %s", rd);
d434 3
a436 1
		      (*prin) (stream, "    ????");
@


1.1.2.2
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@a20 1
#include "sysdep.h"
@


