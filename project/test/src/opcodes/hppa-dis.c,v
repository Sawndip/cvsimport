head	1.51;
access;
symbols
	sid-snapshot-20180601:1.51
	sid-snapshot-20180501:1.51
	sid-snapshot-20180401:1.51
	sid-snapshot-20180301:1.51
	sid-snapshot-20180201:1.51
	sid-snapshot-20180101:1.51
	sid-snapshot-20171201:1.51
	sid-snapshot-20171101:1.51
	sid-snapshot-20171001:1.51
	sid-snapshot-20170901:1.51
	sid-snapshot-20170801:1.51
	sid-snapshot-20170701:1.51
	sid-snapshot-20170601:1.51
	sid-snapshot-20170501:1.51
	sid-snapshot-20170401:1.51
	sid-snapshot-20170301:1.51
	sid-snapshot-20170201:1.51
	sid-snapshot-20170101:1.51
	sid-snapshot-20161201:1.51
	sid-snapshot-20161101:1.51
	sid-snapshot-20160901:1.51
	sid-snapshot-20160801:1.51
	sid-snapshot-20160701:1.51
	sid-snapshot-20160601:1.51
	sid-snapshot-20160501:1.51
	sid-snapshot-20160401:1.51
	sid-snapshot-20160301:1.51
	sid-snapshot-20160201:1.51
	sid-snapshot-20160101:1.51
	sid-snapshot-20151201:1.51
	sid-snapshot-20151101:1.51
	sid-snapshot-20151001:1.51
	sid-snapshot-20150901:1.51
	sid-snapshot-20150801:1.51
	sid-snapshot-20150701:1.51
	sid-snapshot-20150601:1.51
	sid-snapshot-20150501:1.51
	sid-snapshot-20150401:1.51
	sid-snapshot-20150301:1.51
	sid-snapshot-20150201:1.51
	sid-snapshot-20150101:1.51
	sid-snapshot-20141201:1.51
	sid-snapshot-20141101:1.51
	sid-snapshot-20141001:1.51
	sid-snapshot-20140901:1.51
	sid-snapshot-20140801:1.51
	sid-snapshot-20140701:1.51
	sid-snapshot-20140601:1.51
	sid-snapshot-20140501:1.51
	sid-snapshot-20140401:1.51
	sid-snapshot-20140301:1.51
	sid-snapshot-20140201:1.51
	sid-snapshot-20140101:1.51
	sid-snapshot-20131201:1.51
	sid-snapshot-20131101:1.51
	sid-snapshot-20131001:1.51
	binutils-2_24-branch:1.51.0.6
	binutils-2_24-branchpoint:1.51
	binutils-2_21_1:1.49
	sid-snapshot-20130901:1.51
	gdb_7_6_1-2013-08-30-release:1.51
	sid-snapshot-20130801:1.51
	sid-snapshot-20130701:1.51
	sid-snapshot-20130601:1.51
	sid-snapshot-20130501:1.51
	gdb_7_6-2013-04-26-release:1.51
	sid-snapshot-20130401:1.51
	binutils-2_23_2:1.51
	gdb_7_6-branch:1.51.0.4
	gdb_7_6-2013-03-12-branchpoint:1.51
	sid-snapshot-20130301:1.51
	sid-snapshot-20130201:1.51
	sid-snapshot-20130101:1.51
	sid-snapshot-20121201:1.51
	gdb_7_5_1-2012-11-29-release:1.50
	binutils-2_23_1:1.51
	sid-snapshot-20121101:1.51
	binutils-2_23:1.51
	sid-snapshot-20121001:1.51
	sid-snapshot-20120901:1.51
	gdb_7_5-2012-08-17-release:1.50
	sid-snapshot-20120801:1.51
	binutils-2_23-branch:1.51.0.2
	binutils-2_23-branchpoint:1.51
	gdb_7_5-branch:1.50.0.10
	gdb_7_5-2012-07-18-branchpoint:1.50
	sid-snapshot-20120701:1.50
	sid-snapshot-20120601:1.50
	sid-snapshot-20120501:1.50
	binutils-2_22_branch:1.50.0.8
	gdb_7_4_1-2012-04-26-release:1.50
	sid-snapshot-20120401:1.50
	sid-snapshot-20120301:1.50
	sid-snapshot-20120201:1.50
	gdb_7_4-2012-01-24-release:1.50
	sid-snapshot-20120101:1.50
	gdb_7_4-branch:1.50.0.6
	gdb_7_4-2011-12-13-branchpoint:1.50
	sid-snapshot-20111201:1.50
	binutils-2_22:1.50
	sid-snapshot-20111101:1.50
	sid-snapshot-20111001:1.50
	binutils-2_22-branch:1.50.0.4
	binutils-2_22-branchpoint:1.50
	gdb_7_3_1-2011-09-04-release:1.50
	sid-snapshot-20110901:1.50
	sid-snapshot-20110801:1.50
	gdb_7_3-2011-07-26-release:1.50
	sid-snapshot-20110701:1.50
	sid-snapshot-20110601:1.50
	sid-snapshot-20110501:1.50
	gdb_7_3-branch:1.50.0.2
	gdb_7_3-2011-04-01-branchpoint:1.50
	sid-snapshot-20110401:1.50
	sid-snapshot-20110301:1.50
	sid-snapshot-20110201:1.50
	sid-snapshot-20110101:1.50
	binutils-2_21:1.49
	sid-snapshot-20101201:1.49
	binutils-2_21-branch:1.49.0.40
	binutils-2_21-branchpoint:1.49
	sid-snapshot-20101101:1.49
	sid-snapshot-20101001:1.49
	binutils-2_20_1:1.49
	gdb_7_2-2010-09-02-release:1.49
	sid-snapshot-20100901:1.49
	sid-snapshot-20100801:1.49
	gdb_7_2-branch:1.49.0.38
	gdb_7_2-2010-07-07-branchpoint:1.49
	sid-snapshot-20100701:1.49
	sid-snapshot-20100601:1.49
	sid-snapshot-20100501:1.49
	sid-snapshot-20100401:1.49
	gdb_7_1-2010-03-18-release:1.49
	sid-snapshot-20100301:1.49
	gdb_7_1-branch:1.49.0.36
	gdb_7_1-2010-02-18-branchpoint:1.49
	sid-snapshot-20100201:1.49
	sid-snapshot-20100101:1.49
	gdb_7_0_1-2009-12-22-release:1.49
	sid-snapshot-20091201:1.49
	sid-snapshot-20091101:1.49
	binutils-2_20:1.49
	gdb_7_0-2009-10-06-release:1.49
	sid-snapshot-20091001:1.49
	gdb_7_0-branch:1.49.0.34
	gdb_7_0-2009-09-16-branchpoint:1.49
	arc-sim-20090309:1.49
	binutils-arc-20081103-branch:1.49.0.32
	binutils-arc-20081103-branchpoint:1.49
	binutils-2_20-branch:1.49.0.30
	binutils-2_20-branchpoint:1.49
	sid-snapshot-20090901:1.49
	sid-snapshot-20090801:1.49
	msnyder-checkpoint-072509-branch:1.49.0.28
	msnyder-checkpoint-072509-branchpoint:1.49
	sid-snapshot-20090701:1.49
	dje-cgen-play1-branch:1.49.0.26
	dje-cgen-play1-branchpoint:1.49
	sid-snapshot-20090601:1.49
	sid-snapshot-20090501:1.49
	sid-snapshot-20090401:1.49
	arc-20081103-branch:1.49.0.24
	arc-20081103-branchpoint:1.49
	arc-insight_6_8-branch:1.49.0.22
	arc-insight_6_8-branchpoint:1.49
	insight_6_8-branch:1.49.0.20
	insight_6_8-branchpoint:1.49
	sid-snapshot-20090301:1.49
	binutils-2_19_1:1.49
	sid-snapshot-20090201:1.49
	sid-snapshot-20090101:1.49
	reverse-20081226-branch:1.49.0.18
	reverse-20081226-branchpoint:1.49
	sid-snapshot-20081201:1.49
	multiprocess-20081120-branch:1.49.0.16
	multiprocess-20081120-branchpoint:1.49
	sid-snapshot-20081101:1.49
	binutils-2_19:1.49
	sid-snapshot-20081001:1.49
	reverse-20080930-branch:1.49.0.14
	reverse-20080930-branchpoint:1.49
	binutils-2_19-branch:1.49.0.12
	binutils-2_19-branchpoint:1.49
	sid-snapshot-20080901:1.49
	sid-snapshot-20080801:1.49
	reverse-20080717-branch:1.49.0.10
	reverse-20080717-branchpoint:1.49
	sid-snapshot-20080701:1.49
	msnyder-reverse-20080609-branch:1.49.0.8
	msnyder-reverse-20080609-branchpoint:1.49
	drow-reverse-20070409-branch:1.48.0.32
	drow-reverse-20070409-branchpoint:1.48
	sid-snapshot-20080601:1.49
	sid-snapshot-20080501:1.49
	sid-snapshot-20080403:1.49
	sid-snapshot-20080401:1.49
	gdb_6_8-2008-03-27-release:1.49
	sid-snapshot-20080301:1.49
	gdb_6_8-branch:1.49.0.6
	gdb_6_8-2008-02-26-branchpoint:1.49
	sid-snapshot-20080201:1.49
	sid-snapshot-20080101:1.49
	sid-snapshot-20071201:1.49
	sid-snapshot-20071101:1.49
	gdb_6_7_1-2007-10-29-release:1.49
	gdb_6_7-2007-10-10-release:1.49
	sid-snapshot-20071001:1.49
	gdb_6_7-branch:1.49.0.4
	gdb_6_7-2007-09-07-branchpoint:1.49
	binutils-2_18:1.49
	binutils-2_18-branch:1.49.0.2
	binutils-2_18-branchpoint:1.49
	insight_6_6-20070208-release:1.48
	binutils-csl-coldfire-4_1-32:1.48
	binutils-csl-sourcerygxx-4_1-32:1.48
	gdb_6_6-2006-12-18-release:1.48
	binutils-csl-innovasic-fido-3_4_4-33:1.48
	binutils-csl-sourcerygxx-3_4_4-32:1.43
	binutils-csl-coldfire-4_1-30:1.48
	binutils-csl-sourcerygxx-4_1-30:1.48
	binutils-csl-coldfire-4_1-28:1.48
	binutils-csl-sourcerygxx-4_1-29:1.48
	binutils-csl-sourcerygxx-4_1-28:1.48
	gdb_6_6-branch:1.48.0.30
	gdb_6_6-2006-11-15-branchpoint:1.48
	binutils-csl-arm-2006q3-27:1.48
	binutils-csl-sourcerygxx-4_1-27:1.48
	binutils-csl-arm-2006q3-26:1.48
	binutils-csl-sourcerygxx-4_1-26:1.48
	binutils-csl-sourcerygxx-4_1-25:1.48
	binutils-csl-sourcerygxx-4_1-24:1.48
	binutils-csl-sourcerygxx-4_1-23:1.48
	insight_6_5-20061003-release:1.48
	gdb-csl-symbian-6_4_50_20060226-12:1.48
	binutils-csl-sourcerygxx-4_1-21:1.48
	binutils-csl-arm-2006q3-21:1.48
	binutils-csl-sourcerygxx-4_1-22:1.48
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.48
	binutils-csl-sourcerygxx-4_1-20:1.48
	binutils-csl-arm-2006q3-19:1.48
	binutils-csl-sourcerygxx-4_1-19:1.48
	binutils-csl-sourcerygxx-4_1-18:1.48
	binutils-csl-renesas-4_1-9:1.48
	gdb-csl-sourcerygxx-3_4_4-25:1.48
	binutils-csl-sourcerygxx-3_4_4-25:1.43
	nickrob-async-20060828-mergepoint:1.48
	gdb-csl-symbian-6_4_50_20060226-11:1.48
	binutils-csl-renesas-4_1-8:1.48
	binutils-csl-renesas-4_1-7:1.48
	binutils-csl-renesas-4_1-6:1.48
	gdb-csl-sourcerygxx-4_1-17:1.48
	binutils-csl-sourcerygxx-4_1-17:1.48
	gdb-csl-20060226-branch-local-2:1.48
	gdb-csl-sourcerygxx-4_1-14:1.48
	binutils-csl-sourcerygxx-4_1-14:1.48
	binutils-csl-sourcerygxx-4_1-15:1.48
	gdb-csl-sourcerygxx-4_1-13:1.48
	binutils-csl-sourcerygxx-4_1-13:1.48
	binutils-2_17:1.48
	gdb-csl-sourcerygxx-4_1-12:1.48
	binutils-csl-sourcerygxx-4_1-12:1.48
	gdb-csl-sourcerygxx-3_4_4-21:1.48
	binutils-csl-sourcerygxx-3_4_4-21:1.48
	gdb_6_5-20060621-release:1.48
	binutils-csl-wrs-linux-3_4_4-24:1.43
	binutils-csl-wrs-linux-3_4_4-23:1.43
	gdb-csl-sourcerygxx-4_1-9:1.48
	binutils-csl-sourcerygxx-4_1-9:1.48
	gdb-csl-sourcerygxx-4_1-8:1.48
	binutils-csl-sourcerygxx-4_1-8:1.48
	gdb-csl-sourcerygxx-4_1-7:1.48
	binutils-csl-sourcerygxx-4_1-7:1.48
	gdb-csl-arm-2006q1-6:1.48
	binutils-csl-arm-2006q1-6:1.48
	gdb-csl-sourcerygxx-4_1-6:1.48
	binutils-csl-sourcerygxx-4_1-6:1.48
	binutils-csl-wrs-linux-3_4_4-22:1.43
	gdb-csl-symbian-6_4_50_20060226-10:1.48
	gdb-csl-symbian-6_4_50_20060226-9:1.48
	gdb-csl-symbian-6_4_50_20060226-8:1.48
	gdb-csl-coldfire-4_1-11:1.48
	binutils-csl-coldfire-4_1-11:1.48
	gdb-csl-sourcerygxx-3_4_4-19:1.48
	binutils-csl-sourcerygxx-3_4_4-19:1.48
	gdb-csl-coldfire-4_1-10:1.48
	gdb_6_5-branch:1.48.0.28
	gdb_6_5-2006-05-14-branchpoint:1.48
	binutils-csl-coldfire-4_1-10:1.48
	gdb-csl-sourcerygxx-4_1-5:1.48
	binutils-csl-sourcerygxx-4_1-5:1.48
	nickrob-async-20060513-branch:1.48.0.26
	nickrob-async-20060513-branchpoint:1.48
	gdb-csl-sourcerygxx-4_1-4:1.48
	binutils-csl-sourcerygxx-4_1-4:1.48
	msnyder-reverse-20060502-branch:1.48.0.24
	msnyder-reverse-20060502-branchpoint:1.48
	binutils-csl-wrs-linux-3_4_4-21:1.43
	gdb-csl-morpho-4_1-4:1.48
	binutils-csl-morpho-4_1-4:1.48
	gdb-csl-sourcerygxx-3_4_4-17:1.48
	binutils-csl-sourcerygxx-3_4_4-17:1.48
	binutils-csl-wrs-linux-3_4_4-20:1.43
	readline_5_1-import-branch:1.48.0.22
	readline_5_1-import-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.48
	binutils-2_17-branch:1.48.0.20
	binutils-2_17-branchpoint:1.48
	gdb-csl-symbian-20060226-branch:1.48.0.18
	gdb-csl-symbian-20060226-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.48
	msnyder-reverse-20060331-branch:1.48.0.16
	msnyder-reverse-20060331-branchpoint:1.48
	binutils-csl-2_17-branch:1.48.0.14
	binutils-csl-2_17-branchpoint:1.48
	gdb-csl-available-20060303-branch:1.48.0.12
	gdb-csl-available-20060303-branchpoint:1.48
	gdb-csl-20060226-branch:1.48.0.10
	gdb-csl-20060226-branchpoint:1.48
	gdb_6_4-20051202-release:1.48
	msnyder-fork-checkpoint-branch:1.48.0.8
	msnyder-fork-checkpoint-branchpoint:1.48
	gdb-csl-gxxpro-6_3-branch:1.48.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.48
	gdb_6_4-branch:1.48.0.4
	gdb_6_4-2005-11-01-branchpoint:1.48
	gdb-csl-arm-20051020-branch:1.48.0.2
	gdb-csl-arm-20051020-branchpoint:1.48
	binutils-csl-gxxpro-3_4-branch:1.43.0.66
	binutils-csl-gxxpro-3_4-branchpoint:1.43
	binutils-2_16_1:1.43
	msnyder-tracepoint-checkpoint-branch:1.44.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.44
	gdb-csl-arm-20050325-2005-q1b:1.43
	binutils-csl-arm-2005q1b:1.43
	binutils-2_16:1.43
	gdb-csl-arm-20050325-2005-q1a:1.43
	binutils-csl-arm-2005q1a:1.43
	csl-arm-20050325-branch:1.43.0.64
	csl-arm-20050325-branchpoint:1.43
	binutils-csl-arm-2005q1-branch:1.43.0.62
	binutils-csl-arm-2005q1-branchpoint:1.43
	binutils-2_16-branch:1.43.0.60
	binutils-2_16-branchpoint:1.43
	csl-arm-2004-q3d:1.43
	gdb_6_3-20041109-release:1.43
	gdb_6_3-branch:1.43.0.56
	gdb_6_3-20041019-branchpoint:1.43
	csl-arm-2004-q3:1.43
	drow_intercu-merge-20040921:1.43
	drow_intercu-merge-20040915:1.43
	jimb-gdb_6_2-e500-branch:1.43.0.58
	jimb-gdb_6_2-e500-branchpoint:1.43
	gdb_6_2-20040730-release:1.43
	gdb_6_2-branch:1.43.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.43
	gdb_6_1_1-20040616-release:1.43
	binutils-2_15:1.43
	binutils-2_15-branchpoint:1.43
	csl-arm-2004-q1a:1.43
	csl-arm-2004-q1:1.43
	gdb_6_1-2004-04-05-release:1.43
	drow_intercu-merge-20040402:1.43
	drow_intercu-merge-20040327:1.43
	ezannoni_pie-20040323-branch:1.43.0.52
	ezannoni_pie-20040323-branchpoint:1.43
	cagney_tramp-20040321-mergepoint:1.43
	cagney_tramp-20040309-branch:1.43.0.50
	cagney_tramp-20040309-branchpoint:1.43
	gdb_6_1-branch:1.43.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.43
	drow_intercu-20040221-branch:1.43.0.46
	drow_intercu-20040221-branchpoint:1.43
	binutils-2_15-branch:1.43.0.44
	cagney_bfdfile-20040213-branch:1.43.0.42
	cagney_bfdfile-20040213-branchpoint:1.43
	drow-cplus-merge-20040208:1.43
	carlton_dictionary-20040126-merge:1.43
	cagney_bigcore-20040122-branch:1.43.0.40
	cagney_bigcore-20040122-branchpoint:1.43
	drow-cplus-merge-20040113:1.43
	csl-arm-2003-q4:1.43
	drow-cplus-merge-20031224:1.43
	drow-cplus-merge-20031220:1.43
	carlton_dictionary-20031215-merge:1.43
	drow-cplus-merge-20031214:1.43
	carlton-dictionary-20031111-merge:1.43
	gdb_6_0-2003-10-04-release:1.43
	kettenis_sparc-20030918-branch:1.43.0.38
	kettenis_sparc-20030918-branchpoint:1.43
	carlton_dictionary-20030917-merge:1.43
	ezannoni_pie-20030916-branchpoint:1.43
	ezannoni_pie-20030916-branch:1.43.0.36
	cagney_x86i386-20030821-branch:1.43.0.34
	cagney_x86i386-20030821-branchpoint:1.43
	carlton_dictionary-20030805-merge:1.43
	carlton_dictionary-20030627-merge:1.43
	gdb_6_0-branch:1.43.0.32
	gdb_6_0-2003-06-23-branchpoint:1.43
	jimb-ppc64-linux-20030613-branch:1.43.0.30
	jimb-ppc64-linux-20030613-branchpoint:1.43
	binutils-2_14:1.43
	cagney_convert-20030606-branch:1.43.0.28
	cagney_convert-20030606-branchpoint:1.43
	cagney_writestrings-20030508-branch:1.43.0.26
	cagney_writestrings-20030508-branchpoint:1.43
	jimb-ppc64-linux-20030528-branch:1.43.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.43
	carlton_dictionary-20030523-merge:1.43
	cagney_fileio-20030521-branch:1.43.0.22
	cagney_fileio-20030521-branchpoint:1.43
	kettenis_i386newframe-20030517-mergepoint:1.43
	jimb-ppc64-linux-20030509-branch:1.43.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.43
	kettenis_i386newframe-20030504-mergepoint:1.43
	carlton_dictionary-20030430-merge:1.43
	binutils-2_14-branch:1.43.0.18
	binutils-2_14-branchpoint:1.43
	kettenis_i386newframe-20030419-branch:1.43.0.16
	kettenis_i386newframe-20030419-branchpoint:1.43
	carlton_dictionary-20030416-merge:1.43
	cagney_frameaddr-20030409-mergepoint:1.43
	kettenis_i386newframe-20030406-branch:1.43.0.14
	kettenis_i386newframe-20030406-branchpoint:1.43
	cagney_frameaddr-20030403-branchpoint:1.43
	cagney_frameaddr-20030403-branch:1.43.0.12
	cagney_framebase-20030330-mergepoint:1.43
	cagney_framebase-20030326-branch:1.43.0.10
	cagney_framebase-20030326-branchpoint:1.43
	cagney_lazyid-20030317-branch:1.43.0.8
	cagney_lazyid-20030317-branchpoint:1.43
	kettenis-i386newframe-20030316-mergepoint:1.43
	offbyone-20030313-branch:1.43.0.6
	offbyone-20030313-branchpoint:1.43
	kettenis-i386newframe-20030308-branch:1.43.0.4
	kettenis-i386newframe-20030308-branchpoint:1.43
	carlton_dictionary-20030305-merge:1.43
	cagney_offbyone-20030303-branch:1.43.0.2
	cagney_offbyone-20030303-branchpoint:1.43
	carlton_dictionary-20030207-merge:1.41
	interps-20030202-branch:1.41.0.28
	interps-20030202-branchpoint:1.41
	cagney-unwind-20030108-branch:1.41.0.26
	cagney-unwind-20030108-branchpoint:1.41
	binutils-2_13_2_1:1.41
	binutils-2_13_2:1.41
	carlton_dictionary-20021223-merge:1.41
	gdb_5_3-2002-12-12-release:1.41
	carlton_dictionary-20021115-merge:1.41
	binutils-2_13_1:1.41
	kseitz_interps-20021105-merge:1.41
	kseitz_interps-20021103-merge:1.41
	drow-cplus-merge-20021020:1.41
	drow-cplus-merge-20021025:1.41
	carlton_dictionary-20021025-merge:1.41
	carlton_dictionary-20021011-merge:1.41
	drow-cplus-branch:1.41.0.24
	drow-cplus-branchpoint:1.41
	kseitz_interps-20020930-merge:1.41
	carlton_dictionary-20020927-merge:1.41
	carlton_dictionary-branch:1.41.0.22
	carlton_dictionary-20020920-branchpoint:1.41
	sid-20020905-branchpoint:1.41
	sid-20020905-branch:1.41.0.20
	gdb_5_3-branch:1.41.0.18
	gdb_5_3-2002-09-04-branchpoint:1.41
	kseitz_interps-20020829-merge:1.41
	cagney_sysregs-20020825-branch:1.41.0.16
	cagney_sysregs-20020825-branchpoint:1.41
	readline_4_3-import-branch:1.41.0.14
	readline_4_3-import-branchpoint:1.41
	binutils-2_13:1.41
	gdb_5_2_1-2002-07-23-release:1.41
	binutils-2_13-branchpoint:1.41
	binutils-2_13-branch:1.41.0.12
	kseitz_interps-20020528-branch:1.41.0.10
	kseitz_interps-20020528-branchpoint:1.41
	cagney_regbuf-20020515-branch:1.41.0.8
	cagney_regbuf-20020515-branchpoint:1.41
	binutils-2_12_1:1.41
	jimb-macro-020506-branch:1.41.0.6
	jimb-macro-020506-branchpoint:1.41
	gdb_5_2-2002-04-29-release:1.41
	binutils-2_12:1.41
	gdb_5_2-branch:1.41.0.4
	gdb_5_2-2002-03-03-branchpoint:1.41
	binutils-2_12-branch:1.41.0.2
	binutils-2_12-branchpoint:1.41
	gdb_5_1_1-2002-01-24-release:1.40
	gdb_5_1_0_1-2002-01-03-release:1.40
	cygnus_cvs_20020108_pre:1.41
	gdb_5_1_0_1-2002-01-03-branch:1.40.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.40
	gdb_5_1-2001-11-21-release:1.40
	gdb_s390-2001-09-26-branch:1.40.0.4
	gdb_s390-2001-09-26-branchpoint:1.40
	gdb_5_1-2001-07-29-branch:1.40.0.2
	gdb_5_1-2001-07-29-branchpoint:1.40
	binutils-2_11_2:1.39.2.1
	binutils-2_11_1:1.39.2.1
	binutils-2_11:1.39
	x86_64versiong3:1.39
	binutils-2_11-branch:1.39.0.2
	insight-precleanup-2001-01-01:1.38
	binutils-2_10_1:1.35.2.1
	binutils-2_10:1.35.2.1
	gdb-premipsmulti-2000-06-06-branch:1.37.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.37
	gdb_5_0-2000-05-19-release:1.35
	gdb_4_18_2-2000-05-18-release:1.35
	gdb_4_95_1-2000-05-11-snapshot:1.35
	gdb_4_95_0-2000-04-27-snapshot:1.35
	gdb_5_0-2000-04-10-branch:1.35.0.4
	gdb_5_0-2000-04-10-branchpoint:1.35
	binutils-2_10-branch:1.35.0.2
	binutils-2_10-branchpoint:1.35
	binutils_latest_snapshot:1.51
	repo-unification-2000-02-06:1.35
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.51
date	2012.07.24.12.56.47;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2010.12.31.16.43.46;	author danglin;	state Exp;
branches;
next	1.49;

1.49
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2005.08.14.01.15.34;	author danglin;	state Exp;
branches;
next	1.47;

1.47
date	2005.08.05.17.52.06;	author danglin;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.17.02.26.26;	author danglin;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.01.11.16.32;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.07.07.34.28;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2003.02.25.03.22.06;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.25.00.20.29;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.31.23.44.08;	author law;	state Exp;
branches
	1.41.22.1
	1.41.24.1;
next	1.40;

1.40
date	2001.03.13.22.58.35;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.14.05.14.45;	author amodra;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2000.07.09.07.29.39;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2000.04.21.22.04.29;	author law;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	99.11.25.03.29.14;	author law;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	99.10.10.07.58.37;	author law;	state Exp;
branches;
next	1.33;

1.33
date	99.09.23.15.58.08;	author law;	state Exp;
branches;
next	1.32;

1.32
date	99.09.23.14.28.25;	author law;	state Exp;
branches;
next	1.31;

1.31
date	99.09.19.20.17.48;	author law;	state Exp;
branches;
next	1.30;

1.30
date	99.09.19.20.14.30;	author law;	state Exp;
branches;
next	1.29;

1.29
date	99.09.19.20.10.45;	author law;	state Exp;
branches;
next	1.28;

1.28
date	99.09.19.19.52.39;	author law;	state Exp;
branches;
next	1.27;

1.27
date	99.09.19.19.29.37;	author law;	state Exp;
branches;
next	1.26;

1.26
date	99.09.19.18.50.17;	author law;	state Exp;
branches;
next	1.25;

1.25
date	99.09.19.18.11.48;	author law;	state Exp;
branches;
next	1.24;

1.24
date	99.09.19.17.36.54;	author law;	state Exp;
branches;
next	1.23;

1.23
date	99.09.19.17.06.11;	author law;	state Exp;
branches;
next	1.22;

1.22
date	99.09.19.16.59.47;	author law;	state Exp;
branches;
next	1.21;

1.21
date	99.09.19.16.44.16;	author law;	state Exp;
branches;
next	1.20;

1.20
date	99.09.18.19.11.39;	author law;	state Exp;
branches;
next	1.19;

1.19
date	99.09.18.18.19.56;	author law;	state Exp;
branches;
next	1.18;

1.18
date	99.09.18.18.09.38;	author law;	state Exp;
branches;
next	1.17;

1.17
date	99.09.18.17.57.08;	author law;	state Exp;
branches;
next	1.16;

1.16
date	99.09.18.17.38.51;	author law;	state Exp;
branches;
next	1.15;

1.15
date	99.09.07.19.57.23;	author law;	state Exp;
branches;
next	1.14;

1.14
date	99.09.07.19.52.51;	author law;	state Exp;
branches;
next	1.13;

1.13
date	99.08.29.07.53.24;	author law;	state Exp;
branches;
next	1.12;

1.12
date	99.08.28.10.59.07;	author law;	state Exp;
branches;
next	1.11;

1.11
date	99.08.28.10.17.07;	author law;	state Exp;
branches;
next	1.10;

1.10
date	99.08.28.08.47.50;	author law;	state Exp;
branches;
next	1.9;

1.9
date	99.08.28.08.17.36;	author law;	state Exp;
branches;
next	1.8;

1.8
date	99.08.28.08.00.27;	author law;	state Exp;
branches;
next	1.7;

1.7
date	99.08.28.06.45.18;	author law;	state Exp;
branches;
next	1.6;

1.6
date	99.08.28.06.29.15;	author law;	state Exp;
branches;
next	1.5;

1.5
date	99.08.06.15.50.21;	author law;	state Exp;
branches;
next	1.4;

1.4
date	99.08.05.23.02.01;	author law;	state Exp;
branches;
next	1.3;

1.3
date	99.07.28.10.36.38;	author law;	state Exp;
branches;
next	1.2;

1.2
date	99.07.28.10.36.10;	author law;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.41.22.1
date	2003.03.06.00.56.39;	author carlton;	state Exp;
branches;
next	;

1.41.24.1
date	2003.12.14.20.28.06;	author drow;	state Exp;
branches;
next	;

1.39.2.1
date	2001.06.07.03.18.34;	author amodra;	state Exp;
branches;
next	;

1.35.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches;
next	;


desc
@@


1.51
log
@	PR binutils/13135
	* arm-dis.c: Add necessary casts for printing integer values.
	Use %s when printing string values.
	* hppa-dis.c: Likewise.
	* m68k-dis.c: Likewise.
	* microblaze-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* sparc-dis.c: Likewise.

	* dis-asm.h (fprintf_ftype): Add ATTRIBUTE_FPTR_PRINTF_2.
@
text
@/* Disassembler for the PA-RISC. Somewhat derived from sparc-pinsn.c.
   Copyright 1989, 1990, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2003,
   2005, 2007, 2012  Free Software Foundation, Inc.

   Contributed by the Center for Software Science at the
   University of Utah (pa-gdb-bugs@@cs.utah.edu).

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "libhppa.h"
#include "opcode/hppa.h"

/* Integer register names, indexed by the numbers which appear in the
   opcodes.  */
static const char *const reg_names[] =
{
  "flags", "r1", "rp", "r3", "r4", "r5", "r6", "r7", "r8", "r9",
  "r10", "r11", "r12", "r13", "r14", "r15", "r16", "r17", "r18", "r19",
  "r20", "r21", "r22", "r23", "r24", "r25", "r26", "dp", "ret0", "ret1",
  "sp", "r31"
};

/* Floating point register names, indexed by the numbers which appear in the
   opcodes.  */
static const char *const fp_reg_names[] =
{
  "fpsr", "fpe2", "fpe4", "fpe6",
  "fr4", "fr5", "fr6", "fr7", "fr8",
  "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
  "fr16", "fr17", "fr18", "fr19", "fr20", "fr21", "fr22", "fr23",
  "fr24", "fr25", "fr26", "fr27", "fr28", "fr29", "fr30", "fr31"
};

typedef unsigned int CORE_ADDR;

/* Get at various relevent fields of an instruction word.  */

#define MASK_5  0x1f
#define MASK_10 0x3ff
#define MASK_11 0x7ff
#define MASK_14 0x3fff
#define MASK_16 0xffff
#define MASK_21 0x1fffff

/* These macros get bit fields using HP's numbering (MSB = 0).  */

#define GET_FIELD(X, FROM, TO) \
  ((X) >> (31 - (TO)) & ((1 << ((TO) - (FROM) + 1)) - 1))

#define GET_BIT(X, WHICH) \
  GET_FIELD (X, WHICH, WHICH)

/* Some of these have been converted to 2-d arrays because they
   consume less storage this way.  If the maintenance becomes a
   problem, convert them back to const 1-d pointer arrays.  */
static const char *const control_reg[] =
{
  "rctr", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7",
  "pidr1", "pidr2", "ccr", "sar", "pidr3", "pidr4",
  "iva", "eiem", "itmr", "pcsq", "pcoq", "iir", "isr",
  "ior", "ipsw", "eirr", "tr0", "tr1", "tr2", "tr3",
  "tr4", "tr5", "tr6", "tr7"
};

static const char *const compare_cond_names[] =
{
  "", ",=", ",<", ",<=", ",<<", ",<<=", ",sv", ",od",
  ",tr", ",<>", ",>=", ",>", ",>>=", ",>>", ",nsv", ",ev"
};
static const char *const compare_cond_64_names[] =
{
  ",*", ",*=", ",*<", ",*<=", ",*<<", ",*<<=", ",*sv", ",*od",
  ",*tr", ",*<>", ",*>=", ",*>", ",*>>=", ",*>>", ",*nsv", ",*ev"
};
static const char *const cmpib_cond_64_names[] =
{
  ",*<<", ",*=", ",*<", ",*<=", ",*>>=", ",*<>", ",*>=", ",*>"
};
static const char *const add_cond_names[] =
{
  "", ",=", ",<", ",<=", ",nuv", ",znv", ",sv", ",od",
  ",tr", ",<>", ",>=", ",>", ",uv", ",vnz", ",nsv", ",ev"
};
static const char *const add_cond_64_names[] =
{
  ",*", ",*=", ",*<", ",*<=", ",*nuv", ",*znv", ",*sv", ",*od",
  ",*tr", ",*<>", ",*>=", ",*>", ",*uv", ",*vnz", ",*nsv", ",*ev"
};
static const char *const wide_add_cond_names[] =
{
  "", ",=", ",<", ",<=", ",nuv", ",*=", ",*<", ",*<=",
  ",tr", ",<>", ",>=", ",>", ",uv", ",*<>", ",*>=", ",*>"
};
static const char *const logical_cond_names[] =
{
  "", ",=", ",<", ",<=", 0, 0, 0, ",od",
  ",tr", ",<>", ",>=", ",>", 0, 0, 0, ",ev"};
static const char *const logical_cond_64_names[] =
{
  ",*", ",*=", ",*<", ",*<=", 0, 0, 0, ",*od",
  ",*tr", ",*<>", ",*>=", ",*>", 0, 0, 0, ",*ev"};
static const char *const unit_cond_names[] =
{
  "", ",swz", ",sbz", ",shz", ",sdc", ",swc", ",sbc", ",shc",
  ",tr", ",nwz", ",nbz", ",nhz", ",ndc", ",nwc", ",nbc", ",nhc"
};
static const char *const unit_cond_64_names[] =
{
  ",*", ",*swz", ",*sbz", ",*shz", ",*sdc", ",*swc", ",*sbc", ",*shc",
  ",*tr", ",*nwz", ",*nbz", ",*nhz", ",*ndc", ",*nwc", ",*nbc", ",*nhc"
};
static const char *const shift_cond_names[] =
{
  "", ",=", ",<", ",od", ",tr", ",<>", ",>=", ",ev"
};
static const char *const shift_cond_64_names[] =
{
  ",*", ",*=", ",*<", ",*od", ",*tr", ",*<>", ",*>=", ",*ev"
};
static const char *const bb_cond_64_names[] =
{
  ",*<", ",*>="
};
static const char *const index_compl_names[] = {"", ",m", ",s", ",sm"};
static const char *const short_ldst_compl_names[] = {"", ",ma", "", ",mb"};
static const char *const short_bytes_compl_names[] =
{
  "", ",b,m", ",e", ",e,m"
};
static const char *const float_format_names[] = {",sgl", ",dbl", "", ",quad"};
static const char *const fcnv_fixed_names[] = {",w", ",dw", "", ",qw"};
static const char *const fcnv_ufixed_names[] = {",uw", ",udw", "", ",uqw"};
static const char *const float_comp_names[] =
{
  ",false?", ",false", ",?", ",!<=>", ",=", ",=t", ",?=", ",!<>",
  ",!?>=", ",<", ",?<", ",!>=", ",!?>", ",<=", ",?<=", ",!>",
  ",!?<=", ",>", ",?>", ",!<=", ",!?<", ",>=", ",?>=", ",!<",
  ",!?=", ",<>", ",!=", ",!=t", ",!?", ",<=>", ",true?", ",true"
};
static const char *const signed_unsigned_names[] = {",u", ",s"};
static const char *const mix_half_names[] = {",l", ",r"};
static const char *const saturation_names[] = {",us", ",ss", 0, ""};
static const char *const read_write_names[] = {",r", ",w"};
static const char *const add_compl_names[] = { 0, "", ",l", ",tsv" };

/* For a bunch of different instructions form an index into a
   completer name table.  */
#define GET_COMPL(insn) (GET_FIELD (insn, 26, 26) | \
			 GET_FIELD (insn, 18, 18) << 1)

#define GET_COND(insn) (GET_FIELD ((insn), 16, 18) + \
			(GET_FIELD ((insn), 19, 19) ? 8 : 0))

/* Utility function to print registers.  Put these first, so gcc's function
   inlining can do its stuff.  */

#define fputs_filtered(STR,F)	(*info->fprintf_func) (info->stream, "%s", STR)

static void
fput_reg (unsigned reg, disassemble_info *info)
{
  (*info->fprintf_func) (info->stream, "%s", reg ? reg_names[reg] : "r0");
}

static void
fput_fp_reg (unsigned reg, disassemble_info *info)
{
  (*info->fprintf_func) (info->stream, "%s", reg ? fp_reg_names[reg] : "fr0");
}

static void
fput_fp_reg_r (unsigned reg, disassemble_info *info)
{
  /* Special case floating point exception registers.  */
  if (reg < 4)
    (*info->fprintf_func) (info->stream, "fpe%d", reg * 2 + 1);
  else
    (*info->fprintf_func) (info->stream, "%sR",
			   reg ? fp_reg_names[reg] : "fr0");
}

static void
fput_creg (unsigned reg, disassemble_info *info)
{
  (*info->fprintf_func) (info->stream, "%s", control_reg[reg]);
}

/* Print constants with sign.  */

static void
fput_const (unsigned num, disassemble_info *info)
{
  if ((int) num < 0)
    (*info->fprintf_func) (info->stream, "-%x", - (int) num);
  else
    (*info->fprintf_func) (info->stream, "%x", num);
}

/* Routines to extract various sized constants out of hppa
   instructions.  */

/* Extract a 3-bit space register number from a be, ble, mtsp or mfsp.  */
static int
extract_3 (unsigned word)
{
  return GET_FIELD (word, 18, 18) << 2 | GET_FIELD (word, 16, 17);
}

static int
extract_5_load (unsigned word)
{
  return low_sign_extend (word >> 16 & MASK_5, 5);
}

/* Extract the immediate field from a st{bhw}s instruction.  */

static int
extract_5_store (unsigned word)
{
  return low_sign_extend (word & MASK_5, 5);
}

/* Extract the immediate field from a break instruction.  */

static unsigned
extract_5r_store (unsigned word)
{
  return (word & MASK_5);
}

/* Extract the immediate field from a {sr}sm instruction.  */

static unsigned
extract_5R_store (unsigned word)
{
  return (word >> 16 & MASK_5);
}

/* Extract the 10 bit immediate field from a {sr}sm instruction.  */

static unsigned
extract_10U_store (unsigned word)
{
  return (word >> 16 & MASK_10);
}

/* Extract the immediate field from a bb instruction.  */

static unsigned
extract_5Q_store (unsigned word)
{
  return (word >> 21 & MASK_5);
}

/* Extract an 11 bit immediate field.  */

static int
extract_11 (unsigned word)
{
  return low_sign_extend (word & MASK_11, 11);
}

/* Extract a 14 bit immediate field.  */

static int
extract_14 (unsigned word)
{
  return low_sign_extend (word & MASK_14, 14);
}

/* Extract a 16 bit immediate field (PA2.0 wide only).  */

static int
extract_16 (unsigned word)
{
  int m15, m0, m1;

  m0 = GET_BIT (word, 16);
  m1 = GET_BIT (word, 17);
  m15 = GET_BIT (word, 31);
  word = (word >> 1) & 0x1fff;
  word = word | (m15 << 15) | ((m15 ^ m0) << 14) | ((m15 ^ m1) << 13);
  return sign_extend (word, 16);
}

/* Extract a 21 bit constant.  */

static int
extract_21 (unsigned word)
{
  int val;

  word &= MASK_21;
  word <<= 11;
  val = GET_FIELD (word, 20, 20);
  val <<= 11;
  val |= GET_FIELD (word, 9, 19);
  val <<= 2;
  val |= GET_FIELD (word, 5, 6);
  val <<= 5;
  val |= GET_FIELD (word, 0, 4);
  val <<= 2;
  val |= GET_FIELD (word, 7, 8);
  return sign_extend (val, 21) << 11;
}

/* Extract a 12 bit constant from branch instructions.  */

static int
extract_12 (unsigned word)
{
  return sign_extend (GET_FIELD (word, 19, 28)
		      | GET_FIELD (word, 29, 29) << 10
		      | (word & 0x1) << 11, 12) << 2;
}

/* Extract a 17 bit constant from branch instructions, returning the
   19 bit signed value.  */

static int
extract_17 (unsigned word)
{
  return sign_extend (GET_FIELD (word, 19, 28)
		      | GET_FIELD (word, 29, 29) << 10
		      | GET_FIELD (word, 11, 15) << 11
		      | (word & 0x1) << 16, 17) << 2;
}

static int
extract_22 (unsigned word)
{
  return sign_extend (GET_FIELD (word, 19, 28)
		      | GET_FIELD (word, 29, 29) << 10
		      | GET_FIELD (word, 11, 15) << 11
		      | GET_FIELD (word, 6, 10) << 16
		      | (word & 0x1) << 21, 22) << 2;
}

/* Print one instruction.  */

int
print_insn_hppa (bfd_vma memaddr, disassemble_info *info)
{
  bfd_byte buffer[4];
  unsigned int insn, i;

  {
    int status =
      (*info->read_memory_func) (memaddr, buffer, sizeof (buffer), info);
    if (status != 0)
      {
	(*info->memory_error_func) (status, memaddr, info);
	return -1;
      }
  }

  insn = bfd_getb32 (buffer);

  for (i = 0; i < NUMOPCODES; ++i)
    {
      const struct pa_opcode *opcode = &pa_opcodes[i];

      if ((insn & opcode->mask) == opcode->match)
	{
	  const char *s;
#ifndef BFD64
	  if (opcode->arch == pa20w)
	    continue;
#endif
	  (*info->fprintf_func) (info->stream, "%s", opcode->name);

	  if (!strchr ("cfCY?-+nHNZFIuv{", opcode->args[0]))
	    (*info->fprintf_func) (info->stream, " ");
	  for (s = opcode->args; *s != '\0'; ++s)
	    {
	      switch (*s)
		{
		case 'x':
		  fput_reg (GET_FIELD (insn, 11, 15), info);
		  break;
		case 'a':
		case 'b':
		  fput_reg (GET_FIELD (insn, 6, 10), info);
		  break;
		case '^':
		  fput_creg (GET_FIELD (insn, 6, 10), info);
		  break;
		case 't':
		  fput_reg (GET_FIELD (insn, 27, 31), info);
		  break;

		  /* Handle floating point registers.  */
		case 'f':
		  switch (*++s)
		    {
		    case 't':
		      fput_fp_reg (GET_FIELD (insn, 27, 31), info);
		      break;
		    case 'T':
		      if (GET_FIELD (insn, 25, 25))
			fput_fp_reg_r (GET_FIELD (insn, 27, 31), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 27, 31), info);
		      break;
		    case 'a':
		      if (GET_FIELD (insn, 25, 25))
			fput_fp_reg_r (GET_FIELD (insn, 6, 10), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		      break;

		      /* 'fA' will not generate a space before the regsiter
			 name.  Normally that is fine.  Except that it
			 causes problems with xmpyu which has no FP format
			 completer.  */
		    case 'X':
		      fputs_filtered (" ", info);
		      /* FALLTHRU */

		    case 'A':
		      if (GET_FIELD (insn, 24, 24))
			fput_fp_reg_r (GET_FIELD (insn, 6, 10), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		      break;
		    case 'b':
		      if (GET_FIELD (insn, 25, 25))
			fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
		    case 'B':
		      if (GET_FIELD (insn, 19, 19))
			fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
		    case 'C':
		      {
			int reg = GET_FIELD (insn, 21, 22);
			reg |= GET_FIELD (insn, 16, 18) << 2;
			if (GET_FIELD (insn, 23, 23) != 0)
			  fput_fp_reg_r (reg, info);
			else
			  fput_fp_reg (reg, info);
			break;
		      }
		    case 'i':
		      {
			int reg = GET_FIELD (insn, 6, 10);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'j':
		      {
			int reg = GET_FIELD (insn, 11, 15);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'k':
		      {
			int reg = GET_FIELD (insn, 27, 31);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'l':
		      {
			int reg = GET_FIELD (insn, 21, 25);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }
		    case 'm':
		      {
			int reg = GET_FIELD (insn, 16, 20);

			reg |= (GET_FIELD (insn, 26, 26) << 4);
			fput_fp_reg (reg, info);
			break;
		      }

		      /* 'fe' will not generate a space before the register
			 name.  Normally that is fine.  Except that it
			 causes problems with fstw fe,y(b) which has no FP
			 format completer.  */
		    case 'E':
		      fputs_filtered (" ", info);
		      /* FALLTHRU */

		    case 'e':
		      if (GET_FIELD (insn, 30, 30))
			fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		      else
			fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
		    case 'x':
		      fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		      break;
		    }
		  break;

		case '5':
		  fput_const (extract_5_load (insn), info);
		  break;
		case 's':
		  {
		    int space = GET_FIELD (insn, 16, 17);
		    /* Zero means implicit addressing, not use of sr0.  */
		    if (space != 0)
		      (*info->fprintf_func) (info->stream, "sr%d", space);
		  }
		  break;

		case 'S':
		  (*info->fprintf_func) (info->stream, "sr%d",
					 extract_3 (insn));
		  break;

		  /* Handle completers.  */
		case 'c':
		  switch (*++s)
		    {
		    case 'x':
		      (*info->fprintf_func)
			(info->stream, "%s",
			 index_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'X':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 index_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'm':
		      (*info->fprintf_func)
			(info->stream, "%s",
			 short_ldst_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'M':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_ldst_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'A':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_bytes_compl_names[GET_COMPL (insn)]);
		      break;
		    case 's':
		      (*info->fprintf_func)
			(info->stream, "%s",
			 short_bytes_compl_names[GET_COMPL (insn)]);
		      break;
		    case 'c':
		    case 'C':
		      switch (GET_FIELD (insn, 20, 21))
			{
			case 1:
			  (*info->fprintf_func) (info->stream, ",bc ");
			  break;
			case 2:
			  (*info->fprintf_func) (info->stream, ",sl ");
			  break;
			default:
			  (*info->fprintf_func) (info->stream, " ");
			}
		      break;
		    case 'd':
		      switch (GET_FIELD (insn, 20, 21))
			{
			case 1:
			  (*info->fprintf_func) (info->stream, ",co ");
			  break;
			default:
			  (*info->fprintf_func) (info->stream, " ");
			}
		      break;
		    case 'o':
		      (*info->fprintf_func) (info->stream, ",o");
		      break;
		    case 'g':
		      (*info->fprintf_func) (info->stream, ",gate");
		      break;
		    case 'p':
		      (*info->fprintf_func) (info->stream, ",l,push");
		      break;
		    case 'P':
		      (*info->fprintf_func) (info->stream, ",pop");
		      break;
		    case 'l':
		    case 'L':
		      (*info->fprintf_func) (info->stream, ",l");
		      break;
		    case 'w':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 read_write_names[GET_FIELD (insn, 25, 25)]);
		      break;
		    case 'W':
		      (*info->fprintf_func) (info->stream, ",w ");
		      break;
		    case 'r':
		      if (GET_FIELD (insn, 23, 26) == 5)
			(*info->fprintf_func) (info->stream, ",r");
		      break;
		    case 'Z':
		      if (GET_FIELD (insn, 26, 26))
			(*info->fprintf_func) (info->stream, ",m ");
		      else
			(*info->fprintf_func) (info->stream, " ");
		      break;
		    case 'i':
		      if (GET_FIELD (insn, 25, 25))
			(*info->fprintf_func) (info->stream, ",i");
		      break;
		    case 'z':
		      if (!GET_FIELD (insn, 21, 21))
			(*info->fprintf_func) (info->stream, ",z");
		      break;
		    case 'a':
		      (*info->fprintf_func)
			(info->stream, "%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
		      break;
		    case 'Y':
		      (*info->fprintf_func)
			(info->stream, ",dc%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
		      break;
		    case 'y':
		      (*info->fprintf_func)
			(info->stream, ",c%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
		      break;
		    case 'v':
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 't':
		      (*info->fprintf_func) (info->stream, ",tc");
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 'B':
		      (*info->fprintf_func) (info->stream, ",db");
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 'b':
		      (*info->fprintf_func) (info->stream, ",b");
		      if (GET_FIELD (insn, 20, 20))
			(*info->fprintf_func) (info->stream, ",tsv");
		      break;
		    case 'T':
		      if (GET_FIELD (insn, 25, 25))
			(*info->fprintf_func) (info->stream, ",tc");
		      break;
		    case 'S':
		      /* EXTRD/W has a following condition.  */
		      if (*(s + 1) == '?')
			(*info->fprintf_func)
			  (info->stream, "%s",
			   signed_unsigned_names[GET_FIELD (insn, 21, 21)]);
		      else
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   signed_unsigned_names[GET_FIELD (insn, 21, 21)]);
		      break;
		    case 'h':
		      (*info->fprintf_func)
			(info->stream, "%s",
			 mix_half_names[GET_FIELD (insn, 17, 17)]);
		      break;
		    case 'H':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 saturation_names[GET_FIELD (insn, 24, 25)]);
		      break;
		    case '*':
		      (*info->fprintf_func)
			(info->stream, ",%d%d%d%d ",
			 GET_FIELD (insn, 17, 18), GET_FIELD (insn, 20, 21),
			 GET_FIELD (insn, 22, 23), GET_FIELD (insn, 24, 25));
		      break;

		    case 'q':
		      {
			int m, a;

			m = GET_FIELD (insn, 28, 28);
			a = GET_FIELD (insn, 29, 29);

			if (m && !a)
			  fputs_filtered (",ma ", info);
			else if (m && a)
			  fputs_filtered (",mb ", info);
			else
			  fputs_filtered (" ", info);
			break;
		      }

		    case 'J':
		      {
			int opc = GET_FIELD (insn, 0, 5);

			if (opc == 0x16 || opc == 0x1e)
			  {
			    if (GET_FIELD (insn, 29, 29) == 0)
			      fputs_filtered (",ma ", info);
			    else
			      fputs_filtered (",mb ", info);
			  }
			else
			  fputs_filtered (" ", info);
			break;
		      }

		    case 'e':
		      {
			int opc = GET_FIELD (insn, 0, 5);

			if (opc == 0x13 || opc == 0x1b)
			  {
			    if (GET_FIELD (insn, 18, 18) == 1)
			      fputs_filtered (",mb ", info);
			    else
			      fputs_filtered (",ma ", info);
			  }
			else if (opc == 0x17 || opc == 0x1f)
			  {
			    if (GET_FIELD (insn, 31, 31) == 1)
			      fputs_filtered (",ma ", info);
			    else
			      fputs_filtered (",mb ", info);
			  }
			else
			  fputs_filtered (" ", info);

			break;
		      }
		    }
		  break;

		  /* Handle conditions.  */
		case '?':
		  {
		    s++;
		    switch (*s)
		      {
		      case 'f':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   float_comp_names[GET_FIELD (insn, 27, 31)]);
			break;

			/* These four conditions are for the set of instructions
			   which distinguish true/false conditions by opcode
			   rather than by the 'f' bit (sigh): comb, comib,
			   addb, addib.  */
		      case 't':
			fputs_filtered
			  (compare_cond_names[GET_FIELD (insn, 16, 18)], info);
			break;
		      case 'n':
			fputs_filtered
			  (compare_cond_names[GET_FIELD (insn, 16, 18)
					      + GET_FIELD (insn, 4, 4) * 8],
			   info);
			break;
		      case 'N':
			fputs_filtered
			  (compare_cond_64_names[GET_FIELD (insn, 16, 18)
						 + GET_FIELD (insn, 2, 2) * 8],
			   info);
			break;
		      case 'Q':
			fputs_filtered
			  (cmpib_cond_64_names[GET_FIELD (insn, 16, 18)],
			   info);
			break;
		      case '@@':
			fputs_filtered
			  (add_cond_names[GET_FIELD (insn, 16, 18)
					  + GET_FIELD (insn, 4, 4) * 8],
			   info);
			break;
		      case 's':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   compare_cond_names[GET_COND (insn)]);
			break;
		      case 'S':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   compare_cond_64_names[GET_COND (insn)]);
			break;
		      case 'a':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   add_cond_names[GET_COND (insn)]);
			break;
		      case 'A':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   add_cond_64_names[GET_COND (insn)]);
			break;
		      case 'd':
			(*info->fprintf_func)
			  (info->stream, "%s",
			   add_cond_names[GET_FIELD (insn, 16, 18)]);
			break;

		      case 'W':
			(*info->fprintf_func)
			  (info->stream, "%s",
			   wide_add_cond_names[GET_FIELD (insn, 16, 18) +
					       GET_FIELD (insn, 4, 4) * 8]);
			break;

		      case 'l':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   logical_cond_names[GET_COND (insn)]);
			break;
		      case 'L':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   logical_cond_64_names[GET_COND (insn)]);
			break;
		      case 'u':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   unit_cond_names[GET_COND (insn)]);
			break;
		      case 'U':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   unit_cond_64_names[GET_COND (insn)]);
			break;
		      case 'y':
		      case 'x':
		      case 'b':
			(*info->fprintf_func)
			  (info->stream, "%s",
			   shift_cond_names[GET_FIELD (insn, 16, 18)]);

			/* If the next character in args is 'n', it will handle
			   putting out the space.  */
			if (s[1] != 'n')
			  (*info->fprintf_func) (info->stream, " ");
			break;
		      case 'X':
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   shift_cond_64_names[GET_FIELD (insn, 16, 18)]);
			break;
		      case 'B':
			(*info->fprintf_func)
			  (info->stream, "%s",
			   bb_cond_64_names[GET_FIELD (insn, 16, 16)]);

			/* If the next character in args is 'n', it will handle
			   putting out the space.  */
			if (s[1] != 'n')
			  (*info->fprintf_func) (info->stream, " ");
			break;
		      }
		    break;
		  }

		case 'V':
		  fput_const (extract_5_store (insn), info);
		  break;
		case 'r':
		  fput_const (extract_5r_store (insn), info);
		  break;
		case 'R':
		  fput_const (extract_5R_store (insn), info);
		  break;
		case 'U':
		  fput_const (extract_10U_store (insn), info);
		  break;
		case 'B':
		case 'Q':
		  fput_const (extract_5Q_store (insn), info);
		  break;
		case 'i':
		  fput_const (extract_11 (insn), info);
		  break;
		case 'j':
		  fput_const (extract_14 (insn), info);
		  break;
		case 'k':
		  fputs_filtered ("L%", info);
		  fput_const (extract_21 (insn), info);
		  break;
		case '<':
		case 'l':
		  /* 16-bit long disp., PA2.0 wide only.  */
		  fput_const (extract_16 (insn), info);
		  break;
		case 'n':
		  if (insn & 0x2)
		    (*info->fprintf_func) (info->stream, ",n ");
		  else
		    (*info->fprintf_func) (info->stream, " ");
		  break;
		case 'N':
		  if ((insn & 0x20) && s[1])
		    (*info->fprintf_func) (info->stream, ",n ");
		  else if (insn & 0x20)
		    (*info->fprintf_func) (info->stream, ",n");
		  else if (s[1])
		    (*info->fprintf_func) (info->stream, " ");
		  break;
		case 'w':
		  (*info->print_address_func)
		    (memaddr + 8 + extract_12 (insn), info);
		  break;
		case 'W':
		  /* 17 bit PC-relative branch.  */
		  (*info->print_address_func)
		    ((memaddr + 8 + extract_17 (insn)), info);
		  break;
		case 'z':
		  /* 17 bit displacement.  This is an offset from a register
		     so it gets disasssembled as just a number, not any sort
		     of address.  */
		  fput_const (extract_17 (insn), info);
		  break;

		case 'Z':
		  /* addil %r1 implicit output.  */
		  fputs_filtered ("r1", info);
		  break;

		case 'Y':
		  /* be,l %sr0,%r31 implicit output.  */
		  fputs_filtered ("sr0,r31", info);
		  break;

		case '@@':
		  (*info->fprintf_func) (info->stream, "0");
		  break;

		case '.':
		  (*info->fprintf_func) (info->stream, "%d",
					 GET_FIELD (insn, 24, 25));
		  break;
		case '*':
		  (*info->fprintf_func) (info->stream, "%d",
					 GET_FIELD (insn, 22, 25));
		  break;
		case '!':
		  fputs_filtered ("sar", info);
		  break;
		case 'p':
		  (*info->fprintf_func) (info->stream, "%d",
					 31 - GET_FIELD (insn, 22, 26));
		  break;
		case '~':
		  {
		    int num;
		    num = GET_FIELD (insn, 20, 20) << 5;
		    num |= GET_FIELD (insn, 22, 26);
		    (*info->fprintf_func) (info->stream, "%d", 63 - num);
		    break;
		  }
		case 'P':
		  (*info->fprintf_func) (info->stream, "%d",
					 GET_FIELD (insn, 22, 26));
		  break;
		case 'q':
		  {
		    int num;
		    num = GET_FIELD (insn, 20, 20) << 5;
		    num |= GET_FIELD (insn, 22, 26);
		    (*info->fprintf_func) (info->stream, "%d", num);
		    break;
		  }
		case 'T':
		  (*info->fprintf_func) (info->stream, "%d",
					 32 - GET_FIELD (insn, 27, 31));
		  break;
		case '%':
		  {
		    int num;
		    num = (GET_FIELD (insn, 23, 23) + 1) * 32;
		    num -= GET_FIELD (insn, 27, 31);
		    (*info->fprintf_func) (info->stream, "%d", num);
		    break;
		  }
		case '|':
		  {
		    int num;
		    num = (GET_FIELD (insn, 19, 19) + 1) * 32;
		    num -= GET_FIELD (insn, 27, 31);
		    (*info->fprintf_func) (info->stream, "%d", num);
		    break;
		  }
		case '$':
		  fput_const (GET_FIELD (insn, 20, 28), info);
		  break;
		case 'A':
		  fput_const (GET_FIELD (insn, 6, 18), info);
		  break;
		case 'D':
		  fput_const (GET_FIELD (insn, 6, 31), info);
		  break;
		case 'v':
		  (*info->fprintf_func) (info->stream, ",%d",
					 GET_FIELD (insn, 23, 25));
		  break;
		case 'O':
		  fput_const ((GET_FIELD (insn, 6,20) << 5 |
			       GET_FIELD (insn, 27, 31)), info);
		  break;
		case 'o':
		  fput_const (GET_FIELD (insn, 6, 20), info);
		  break;
		case '2':
		  fput_const ((GET_FIELD (insn, 6, 22) << 5 |
			       GET_FIELD (insn, 27, 31)), info);
		  break;
		case '1':
		  fput_const ((GET_FIELD (insn, 11, 20) << 5 |
			       GET_FIELD (insn, 27, 31)), info);
		  break;
		case '0':
		  fput_const ((GET_FIELD (insn, 16, 20) << 5 |
			       GET_FIELD (insn, 27, 31)), info);
		  break;
		case 'u':
		  (*info->fprintf_func) (info->stream, ",%d",
					 GET_FIELD (insn, 23, 25));
		  break;
		case 'F':
		  /* If no destination completer and not before a completer
		     for fcmp, need a space here.  */
		  if (s[1] == 'G' || s[1] == '?')
		    fputs_filtered
		      (float_format_names[GET_FIELD (insn, 19, 20)], info);
		  else
		    (*info->fprintf_func)
		      (info->stream, "%s ",
		       float_format_names[GET_FIELD (insn, 19, 20)]);
		  break;
		case 'G':
		  (*info->fprintf_func)
		    (info->stream, "%s ",
		     float_format_names[GET_FIELD (insn, 17, 18)]);
		  break;
		case 'H':
		  if (GET_FIELD (insn, 26, 26) == 1)
		    (*info->fprintf_func) (info->stream, "%s ",
					   float_format_names[0]);
		  else
		    (*info->fprintf_func) (info->stream, "%s ",
					   float_format_names[1]);
		  break;
		case 'I':
		  /* If no destination completer and not before a completer
		     for fcmp, need a space here.  */
		  if (s[1] == '?')
		    fputs_filtered
		      (float_format_names[GET_FIELD (insn, 20, 20)], info);
		  else
		    (*info->fprintf_func)
		      (info->stream, "%s ",
		       float_format_names[GET_FIELD (insn, 20, 20)]);
		  break;

		case 'J':
		  fput_const (extract_14 (insn), info);
		  break;

		case '#':
		  {
		    int sign = GET_FIELD (insn, 31, 31);
		    int imm10 = GET_FIELD (insn, 18, 27);
		    int disp;

		    if (sign)
		      disp = (-1 << 10) | imm10;
		    else
		      disp = imm10;

		    disp <<= 3;
		    fput_const (disp, info);
		    break;
		  }
		case 'K':
		case 'd':
		  {
		    int sign = GET_FIELD (insn, 31, 31);
		    int imm11 = GET_FIELD (insn, 18, 28);
		    int disp;

		    if (sign)
		      disp = (-1 << 11) | imm11;
		    else
		      disp = imm11;

		    disp <<= 2;
		    fput_const (disp, info);
		    break;
		  }

		case '>':
		case 'y':
		  {
		    /* 16-bit long disp., PA2.0 wide only.  */
		    int disp = extract_16 (insn);
		    disp &= ~3;
		    fput_const (disp, info);
		    break;
		  }

		case '&':
		  {
		    /* 16-bit long disp., PA2.0 wide only.  */
		    int disp = extract_16 (insn);
		    disp &= ~7;
		    fput_const (disp, info);
		    break;
		  }

		case '_':
		  break; /* Dealt with by '{' */

		case '{':
		  {
		    int sub = GET_FIELD (insn, 14, 16);
		    int df = GET_FIELD (insn, 17, 18);
		    int sf = GET_FIELD (insn, 19, 20);
		    const char * const * source = float_format_names;
		    const char * const * dest = float_format_names;
		    char *t = "";

		    if (sub == 4)
		      {
			fputs_filtered (",UND ", info);
			break;
		      }
		    if ((sub & 3) == 3)
		      t = ",t";
		    if ((sub & 3) == 1)
		      source = sub & 4 ? fcnv_ufixed_names : fcnv_fixed_names;
		    if (sub & 2)
		      dest = sub & 4 ? fcnv_ufixed_names : fcnv_fixed_names;

		    (*info->fprintf_func) (info->stream, "%s%s%s ",
					   t, source[sf], dest[df]);
		    break;
		  }

		case 'm':
		  {
		    int y = GET_FIELD (insn, 16, 18);

		    if (y != 1)
		      fput_const ((y ^ 1) - 1, info);
		  }
		  break;

		case 'h':
		  {
		    int cbit;

		    cbit = GET_FIELD (insn, 16, 18);

		    if (cbit > 0)
		      (*info->fprintf_func) (info->stream, ",%d", cbit - 1);
		    break;
		  }

		case '=':
		  {
		    int cond = GET_FIELD (insn, 27, 31);

		    switch (cond)
		      {
		      case  0: fputs_filtered (" ", info); break;
		      case  1: fputs_filtered ("acc ", info); break;
		      case  2: fputs_filtered ("rej ", info); break;
		      case  5: fputs_filtered ("acc8 ", info); break;
		      case  6: fputs_filtered ("rej8 ", info); break;
		      case  9: fputs_filtered ("acc6 ", info); break;
		      case 13: fputs_filtered ("acc4 ", info); break;
		      case 17: fputs_filtered ("acc2 ", info); break;
		      default: break;
		      }
		    break;
		  }

		case 'X':
		  (*info->print_address_func)
		    (memaddr + 8 + extract_22 (insn), info);
		  break;
		case 'L':
		  fputs_filtered (",rp", info);
		  break;
		default:
		  (*info->fprintf_func) (info->stream, "%c", *s);
		  break;
		}
	    }
	  return sizeof (insn);
	}
    }
  (*info->fprintf_func) (info->stream, "#%8x", insn);
  return sizeof (insn);
}
@


1.50
log
@	PR gas/11395
	* config/tc-hppa.c (pa_ip): Revert last change.  Add variable need_cond
	to determine whether a 64-bit condition is needed for 'A' and 'S'
	conditions.  Default to 32-bit never condition for logical and unit
	instructions.  Add error message for missing branch on bit condition.

	* hppa.h (pa_opcodes): Revert last change.  Exchange 32 and 64-bit
	"bb" entries.

	* hppa-dis.c (compare_cond_64_names): Change never condition to ",*".
	(add_cond_64_names): Likewise.
	(logical_cond_64_names): Likewise.
	(unit_cond_64_names): Likewise.
@
text
@d3 1
a3 1
   2005, 2007  Free Software Foundation, Inc.
d179 1
a179 1
  (*info->fprintf_func) (info->stream, reg ? reg_names[reg] : "r0");
d185 1
a185 1
  (*info->fprintf_func) (info->stream, reg ? fp_reg_names[reg] : "fr0");
d202 1
a202 1
  (*info->fprintf_func) (info->stream, control_reg[reg]);
@


1.49
log
@Change source files over to GPLv3.
@
text
@d89 1
a89 1
  "", ",*=", ",*<", ",*<=", ",*<<", ",*<<=", ",*sv", ",*od",
d103 1
a103 1
  "", ",*=", ",*<", ",*<=", ",*nuv", ",*znv", ",*sv", ",*od",
d117 1
a117 1
  "", ",*=", ",*<", ",*<=", 0, 0, 0, ",*od",
d126 1
a126 1
  "", ",*swz", ",*sbz", ",*shz", ",*sdc", ",*swc", ",*sbc", ",*shc",
d135 1
a135 1
  "", ",*=", ",*<", ",*od", ",*tr", ",*<>", ",*>=", ",*ev"
@


1.48
log
@	* hppa-dis.c (print_insn_hppa): Don't print '%' before register names.
	Use "rp" instead of "%r2" in "b,l" insns.
@
text
@d3 1
a3 1
   2005 Free Software Foundation, Inc.
d8 3
a10 1
   This program is free software; you can redistribute it and/or modify
d12 2
a13 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d15 4
a18 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.47
log
@	* hppa-dis.c (print_insn_hppa): Prefix 21-bit values with "L%".
@
text
@d955 1
a955 1
		  (*info->fprintf_func) (info->stream, "%%r1");
d960 1
a960 1
		  (*info->fprintf_func) (info->stream, "%%sr0,%%r31");
d976 1
a976 1
		  (*info->fprintf_func) (info->stream, "%%sar");
d1222 1
a1222 1
		  fputs_filtered (",%r2", info);
@


1.46
log
@	* hppa-dis.c (print_insn_hppa): Add space after 'w' in wide-mode
	mfctl disassembly.
@
text
@d915 1
@


1.45
log
@Update function declarations to ISO C90 formatting
@
text
@d621 1
a621 1
		      (*info->fprintf_func) (info->stream, ",w");
@


1.44
log
@Update the address and phone number of the FSF
@
text
@d2 2
a3 2
   Copyright 1989, 1990, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2003
   Free Software Foundation, Inc.
d8 14
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d31 2
a32 1
 {"flags", "r1", "rp", "r3", "r4", "r5", "r6", "r7", "r8", "r9",
d35 2
a36 1
  "sp", "r31"};
d41 2
a42 1
 {"fpsr", "fpe2", "fpe4", "fpe6",
d46 2
a47 1
  "fr24", "fr25", "fr26", "fr27", "fr28", "fr29", "fr30", "fr31"};
d53 1
a53 1
#define MASK_5 0x1f
d60 1
a60 1
/* These macros get bit fields using HP's numbering (MSB = 0) */
d71 2
a72 1
static const char *const control_reg[] = {
d80 2
a81 1
static const char *const compare_cond_names[] = {
d85 2
a86 1
static const char *const compare_cond_64_names[] = {
d90 2
a91 1
static const char *const cmpib_cond_64_names[] = {
d94 2
a95 1
static const char *const add_cond_names[] = {
d99 2
a100 1
static const char *const add_cond_64_names[] = {
d104 2
a105 1
static const char *const wide_add_cond_names[] = {
d109 2
a110 1
static const char *const logical_cond_names[] = {
d113 2
a114 1
static const char *const logical_cond_64_names[] = {
d117 2
a118 1
static const char *const unit_cond_names[] = {
d122 2
a123 1
static const char *const unit_cond_64_names[] = {
d127 2
a128 1
static const char *const shift_cond_names[] = {
d131 2
a132 1
static const char *const shift_cond_64_names[] = {
d135 2
a136 1
static const char *const bb_cond_64_names[] = {
d141 2
a142 1
static const char *const short_bytes_compl_names[] = {
a168 20
static void fput_reg PARAMS ((unsigned int, disassemble_info *));
static void fput_fp_reg PARAMS ((unsigned int, disassemble_info *));
static void fput_fp_reg_r PARAMS ((unsigned int, disassemble_info *));
static void fput_creg PARAMS ((unsigned int, disassemble_info *));
static void fput_const PARAMS ((unsigned int, disassemble_info *));
static int extract_3 PARAMS ((unsigned int));
static int extract_5_load PARAMS ((unsigned int));
static int extract_5_store PARAMS ((unsigned int));
static unsigned extract_5r_store PARAMS ((unsigned int));
static unsigned extract_5R_store PARAMS ((unsigned int));
static unsigned extract_10U_store PARAMS ((unsigned int));
static unsigned extract_5Q_store PARAMS ((unsigned int));
static int extract_11 PARAMS ((unsigned int));
static int extract_14 PARAMS ((unsigned int));
static int extract_16 PARAMS ((unsigned int));
static int extract_21 PARAMS ((unsigned int));
static int extract_12 PARAMS ((unsigned int));
static int extract_17 PARAMS ((unsigned int));
static int extract_22 PARAMS ((unsigned int));

d175 1
a175 3
fput_reg (reg, info)
     unsigned reg;
     disassemble_info *info;
d181 1
a181 3
fput_fp_reg (reg, info)
     unsigned reg;
     disassemble_info *info;
d187 1
a187 3
fput_fp_reg_r (reg, info)
     unsigned reg;
     disassemble_info *info;
d198 1
a198 3
fput_creg (reg, info)
     unsigned reg;
     disassemble_info *info;
d206 1
a206 3
fput_const (num, info)
     unsigned num;
     disassemble_info *info;
d208 2
a209 2
  if ((int)num < 0)
    (*info->fprintf_func) (info->stream, "-%x", -(int)num);
d219 1
a219 2
extract_3 (word)
     unsigned word;
d225 1
a225 2
extract_5_load (word)
     unsigned word;
d231 1
d233 1
a233 2
extract_5_store (word)
     unsigned word;
d239 1
d241 1
a241 2
extract_5r_store (word)
     unsigned word;
d247 1
d249 1
a249 2
extract_5R_store (word)
     unsigned word;
d255 1
d257 1
a257 2
extract_10U_store (word)
     unsigned word;
d263 1
d265 1
a265 2
extract_5Q_store (word)
     unsigned word;
d271 1
d273 1
a273 2
extract_11 (word)
     unsigned word;
d279 1
d281 1
a281 2
extract_14 (word)
     unsigned word;
d287 1
d289 1
a289 2
extract_16 (word)
     unsigned word;
d292 1
d304 1
a304 2
extract_21 (word)
     unsigned word;
d325 1
a325 2
extract_12 (word)
     unsigned word;
d327 3
a329 3
  return sign_extend (GET_FIELD (word, 19, 28) |
		      GET_FIELD (word, 29, 29) << 10 |
		      (word & 0x1) << 11, 12) << 2;
d336 1
a336 2
extract_17 (word)
     unsigned word;
d338 4
a341 4
  return sign_extend (GET_FIELD (word, 19, 28) |
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
		      (word & 0x1) << 16, 17) << 2;
d345 1
a345 2
extract_22 (word)
     unsigned word;
d347 5
a351 5
  return sign_extend (GET_FIELD (word, 19, 28) |
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
		      GET_FIELD (word, 6, 10) << 16 |
		      (word & 0x1) << 21, 22) << 2;
d355 1
d357 1
a357 3
print_insn_hppa (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d377 1
d380 1
a380 1
	  register const char *s;
d777 1
a777 1
			/* these four conditions are for the set of instructions
d780 1
a780 1
			   addb, addib */
d1058 2
a1059 2
		  /* if no destination completer and not before a completer
		     for fcmp, need a space here */
d1082 2
a1083 2
		  /* if no destination completer and not before a completer
		     for fcmp, need a space here */
d1159 1
d1201 12
a1212 16
		    if (cond == 0)
		      fputs_filtered (" ", info);
		    else if (cond == 1)
		      fputs_filtered ("acc ", info);
		    else if (cond == 2)
		      fputs_filtered ("rej ", info);
		    else if (cond == 5)
		      fputs_filtered ("acc8 ", info);
		    else if (cond == 6)
		      fputs_filtered ("rej8 ", info);
		    else if (cond == 9)
		      fputs_filtered ("acc6 ", info);
		    else if (cond == 13)
		      fputs_filtered ("acc4 ", info);
		    else if (cond == 17)
		      fputs_filtered ("acc2 ", info);
d1228 1
a1228 1
	  return sizeof(insn);
d1232 1
a1232 1
  return sizeof(insn);
@


1.43
log
@	* hppa-dis.c: Formatting.
	* hppa-dis.c (print_insn_hppa): Implement fcnv instruction modifiers.
@
text
@d20 1
a20 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.42
log
@	* hppa-dis.c (print_insn_hppa <2 bit space register>): Do not print
	the space register when the value is zero.
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001
d29 1
a29 1
static const char *const reg_names[] = 
d37 4
a40 4
static const char *const fp_reg_names[] = 
 {"fpsr", "fpe2", "fpe4", "fpe6", 
  "fr4", "fr5", "fr6", "fr7", "fr8", 
  "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15", 
d126 2
d141 1
a141 1
/* For a bunch of different instructions form an index into a 
d199 2
a200 2
    (*info->fprintf_func) (info->stream, "%sR", reg ? fp_reg_names[reg] 
						    : "fr0");
d341 2
a342 2
                      GET_FIELD (word, 29, 29) << 10 |
                      (word & 0x1) << 11, 12) << 2;
d353 3
a355 3
                      GET_FIELD (word, 29, 29) << 10 |
                      GET_FIELD (word, 11, 15) << 11 |
                      (word & 0x1) << 16, 17) << 2;
d363 4
a366 4
                      GET_FIELD (word, 29, 29) << 10 |
                      GET_FIELD (word, 11, 15) << 11 |
                      GET_FIELD (word, 6, 10) << 16 |
                      (word & 0x1) << 21, 22) << 2;
d402 1
a402 1
	  if (!strchr ("cfCY?-+nHNZFIuv", opcode->args[0]))
d422 1
a422 1
		/* Handle floating point registers.  */
d442 4
a445 4
		    /* 'fA' will not generate a space before the regsiter
			name.  Normally that is fine.  Except that it
			causes problems with xmpyu which has no FP format
			completer.  */
d448 1
a448 2

		    /* FALLTHRU */
a454 1
		      
d519 4
a522 4
		    /* 'fe' will not generate a space before the register
			name.  Normally that is fine.  Except that it
			causes problems with fstw fe,y(b) which has no FP
			format completer.  */
d525 1
a525 2

		    /* FALLTHRU */
d552 2
a553 1
		  (*info->fprintf_func) (info->stream, "sr%d", extract_3 (insn));
d556 1
a556 1
		/* Handle completers.  */
d561 3
a563 2
		      (*info->fprintf_func) (info->stream, "%s",
					     index_compl_names[GET_COMPL (insn)]);
d566 3
a568 2
		      (*info->fprintf_func) (info->stream, "%s ",
					     index_compl_names[GET_COMPL (insn)]);
d571 3
a573 2
		      (*info->fprintf_func) (info->stream, "%s",
					     short_ldst_compl_names[GET_COMPL (insn)]);
d576 3
a578 2
		      (*info->fprintf_func) (info->stream, "%s ",
					     short_ldst_compl_names[GET_COMPL (insn)]);
d581 3
a583 2
		      (*info->fprintf_func) (info->stream, "%s ",
					     short_bytes_compl_names[GET_COMPL (insn)]);
d586 3
a588 2
		      (*info->fprintf_func) (info->stream, "%s",
					     short_bytes_compl_names[GET_COMPL (insn)]);
d631 3
a633 2
		      (*info->fprintf_func) (info->stream, "%s ",
					     read_write_names[GET_FIELD (insn, 25, 25)]);
d658 2
a659 2
			(info->stream, "%s", add_compl_names[GET_FIELD
							    (insn, 20, 21)]);
d663 2
a664 2
			(info->stream, ",dc%s", add_compl_names[GET_FIELD
							       (insn, 20, 21)]);
d668 2
a669 2
			(info->stream, ",c%s", add_compl_names[GET_FIELD
							      (insn, 20, 21)]);
d698 2
a699 2
			  (info->stream, "%s", signed_unsigned_names[GET_FIELD
								    (insn, 21, 21)]);
d702 2
a703 2
			  (info->stream, "%s ", signed_unsigned_names[GET_FIELD
								     (insn, 21, 21)]);
d707 2
a708 2
			  (info->stream, "%s", mix_half_names[GET_FIELD
							     (insn, 17, 17)]);
d712 2
a713 2
			  (info->stream, "%s ", saturation_names[GET_FIELD
							       (insn, 24, 25)]);
d717 3
a719 3
			  (info->stream, ",%d%d%d%d ",
			   GET_FIELD (insn, 17, 18), GET_FIELD (insn, 20, 21),
			   GET_FIELD (insn, 22, 23), GET_FIELD (insn, 24, 25));
d780 1
a780 1
		/* Handle conditions.  */
d787 3
a789 3
			(*info->fprintf_func) (info->stream, "%s ",
					       float_comp_names[GET_FIELD
							       (insn, 27, 31)]);
d792 1
a792 1
		      /* these four conditions are for the set of instructions
d797 2
a798 2
			fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)],
					info);
d801 4
a804 2
			fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)
					+ GET_FIELD (insn, 4, 4) * 8], info);
d807 4
a810 2
			fputs_filtered (compare_cond_64_names[GET_FIELD (insn, 16, 18)
					+ GET_FIELD (insn, 2, 2) * 8], info);
d813 3
a815 2
			fputs_filtered (cmpib_cond_64_names[GET_FIELD (insn, 16, 18)],
					info);
d818 4
a821 2
			fputs_filtered (add_cond_names[GET_FIELD (insn, 16, 18)
					+ GET_FIELD (insn, 4, 4) * 8], info);
d824 3
a826 2
			(*info->fprintf_func) (info->stream, "%s ",
					       compare_cond_names[GET_COND (insn)]);
d829 3
a831 2
			(*info->fprintf_func) (info->stream, "%s ",
					       compare_cond_64_names[GET_COND (insn)]);
d834 3
a836 2
			(*info->fprintf_func) (info->stream, "%s ",
					       add_cond_names[GET_COND (insn)]);
d839 3
a841 2
			(*info->fprintf_func) (info->stream, "%s ",
					       add_cond_64_names[GET_COND (insn)]);
d844 3
a846 2
			(*info->fprintf_func) (info->stream, "%s",
					       add_cond_names[GET_FIELD (insn, 16, 18)]);
d850 1
a850 1
			(*info->fprintf_func) 
d852 2
a853 2
			   wide_add_cond_names[GET_FIELD (insn, 16, 18) + 
					      GET_FIELD (insn, 4, 4) * 8]);
d857 3
a859 2
			(*info->fprintf_func) (info->stream, "%s ",
					       logical_cond_names[GET_COND (insn)]);
d862 3
a864 2
			(*info->fprintf_func) (info->stream, "%s ",
					       logical_cond_64_names[GET_COND (insn)]);
d867 3
a869 2
			(*info->fprintf_func) (info->stream, "%s ",
					       unit_cond_names[GET_COND (insn)]);
d872 3
a874 2
			(*info->fprintf_func) (info->stream, "%s ",
					       unit_cond_64_names[GET_COND (insn)]);
d889 3
a891 2
			(*info->fprintf_func) (info->stream, "%s ",
					       shift_cond_64_names[GET_FIELD (insn, 16, 18)]);
d952 2
a953 2
		  (*info->print_address_func) (memaddr + 8 + extract_12 (insn),
					       info);
d957 2
a958 3
		  (*info->print_address_func) ((memaddr + 8 
						+ extract_17 (insn)),
					       info);
d976 1
a976 1
		  
d983 1
a983 1
				    GET_FIELD (insn, 24, 25));
d987 1
a987 1
				    GET_FIELD (insn, 22, 25));
d994 1
a994 1
				    31 - GET_FIELD (insn, 22, 26));
d1006 1
a1006 1
				    GET_FIELD (insn, 22, 26));
d1018 1
a1018 1
				    32 - GET_FIELD (insn, 27, 31));
d1046 2
a1047 1
		  (*info->fprintf_func) (info->stream, ",%d", GET_FIELD (insn, 23, 25));
d1069 2
a1070 1
		  (*info->fprintf_func) (info->stream, ",%d", GET_FIELD (insn, 23, 25));
d1076 2
a1077 2
		    fputs_filtered (float_format_names[GET_FIELD (insn, 19, 20)],
				    info);
d1079 3
a1081 3
		    (*info->fprintf_func) (info->stream, "%s ",
					   float_format_names[GET_FIELD
							      (insn, 19, 20)]);
d1084 3
a1086 3
		  (*info->fprintf_func) (info->stream, "%s ",
				    float_format_names[GET_FIELD (insn,
								  17, 18)]);
d1091 1
a1091 1
				    float_format_names[0]);
d1094 1
a1094 1
				    float_format_names[1]);
d1100 2
a1101 2
		    fputs_filtered (float_format_names[GET_FIELD (insn, 20, 20)],
				    info);
d1103 3
a1105 3
		    (*info->fprintf_func) (info->stream, "%s ",
					   float_format_names[GET_FIELD
							      (insn, 20, 20)]);
d1108 3
a1110 3
                case 'J':
                  fput_const (extract_14 (insn), info);
                  break;
d1127 1
a1127 1
                case 'K':
a1162 1
		/* ?!? FIXME */
d1164 2
d1167 23
a1189 2
		  fputs_filtered ("Disassembler botch.\n", info);
		  break;
d1235 2
a1236 3
		  (*info->print_address_func) ((memaddr + 8 
						+ extract_22 (insn)),
					       info);
@


1.41
log
@        * hppa-dis.c (print_insn_hppa): Handle new 'c' mode completers,
        'X', 'M', and 'A'.  No longer emit a space after 'x' or 's'.
        Always emit a space after 'H'.
@
text
@d544 6
a549 2
		  (*info->fprintf_func) (info->stream,
					 "sr%d", GET_FIELD (insn, 16, 17));
@


1.41.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2003
d29 1
a29 1
static const char *const reg_names[] =
d37 4
a40 4
static const char *const fp_reg_names[] =
 {"fpsr", "fpe2", "fpe4", "fpe6",
  "fr4", "fr5", "fr6", "fr7", "fr8",
  "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
a125 2
static const char *const fcnv_fixed_names[] = {",w", ",dw", "", ",qw"};
static const char *const fcnv_ufixed_names[] = {",uw", ",udw", "", ",uqw"};
d139 1
a139 1
/* For a bunch of different instructions form an index into a
d197 2
a198 2
    (*info->fprintf_func) (info->stream, "%sR",
			   reg ? fp_reg_names[reg] : "fr0");
d339 2
a340 2
		      GET_FIELD (word, 29, 29) << 10 |
		      (word & 0x1) << 11, 12) << 2;
d351 3
a353 3
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
		      (word & 0x1) << 16, 17) << 2;
d361 4
a364 4
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
		      GET_FIELD (word, 6, 10) << 16 |
		      (word & 0x1) << 21, 22) << 2;
d400 1
a400 1
	  if (!strchr ("cfCY?-+nHNZFIuv{", opcode->args[0]))
d420 1
a420 1
		  /* Handle floating point registers.  */
d440 4
a443 4
		      /* 'fA' will not generate a space before the regsiter
			 name.  Normally that is fine.  Except that it
			 causes problems with xmpyu which has no FP format
			 completer.  */
d446 2
a447 1
		      /* FALLTHRU */
d454 1
d519 4
a522 4
		      /* 'fe' will not generate a space before the register
			 name.  Normally that is fine.  Except that it
			 causes problems with fstw fe,y(b) which has no FP
			 format completer.  */
d525 2
a526 1
		      /* FALLTHRU */
d544 2
a545 6
		  {
		    int space = GET_FIELD (insn, 16, 17);
		    /* Zero means implicit addressing, not use of sr0.  */
		    if (space != 0)
		      (*info->fprintf_func) (info->stream, "sr%d", space);
		  }
d549 1
a549 2
		  (*info->fprintf_func) (info->stream, "sr%d",
					 extract_3 (insn));
d552 1
a552 1
		  /* Handle completers.  */
d557 2
a558 3
		      (*info->fprintf_func)
			(info->stream, "%s",
			 index_compl_names[GET_COMPL (insn)]);
d561 2
a562 3
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 index_compl_names[GET_COMPL (insn)]);
d565 2
a566 3
		      (*info->fprintf_func)
			(info->stream, "%s",
			 short_ldst_compl_names[GET_COMPL (insn)]);
d569 2
a570 3
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_ldst_compl_names[GET_COMPL (insn)]);
d573 2
a574 3
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_bytes_compl_names[GET_COMPL (insn)]);
d577 2
a578 3
		      (*info->fprintf_func)
			(info->stream, "%s",
			 short_bytes_compl_names[GET_COMPL (insn)]);
d621 2
a622 3
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 read_write_names[GET_FIELD (insn, 25, 25)]);
d647 2
a648 2
			(info->stream, "%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
d652 2
a653 2
			(info->stream, ",dc%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
d657 2
a658 2
			(info->stream, ",c%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
d687 2
a688 2
			  (info->stream, "%s",
			   signed_unsigned_names[GET_FIELD (insn, 21, 21)]);
d691 2
a692 2
			  (info->stream, "%s ",
			   signed_unsigned_names[GET_FIELD (insn, 21, 21)]);
d696 2
a697 2
			(info->stream, "%s",
			 mix_half_names[GET_FIELD (insn, 17, 17)]);
d701 2
a702 2
			(info->stream, "%s ",
			 saturation_names[GET_FIELD (insn, 24, 25)]);
d706 3
a708 3
			(info->stream, ",%d%d%d%d ",
			 GET_FIELD (insn, 17, 18), GET_FIELD (insn, 20, 21),
			 GET_FIELD (insn, 22, 23), GET_FIELD (insn, 24, 25));
d769 1
a769 1
		  /* Handle conditions.  */
d776 3
a778 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   float_comp_names[GET_FIELD (insn, 27, 31)]);
d781 1
a781 1
			/* these four conditions are for the set of instructions
d786 2
a787 2
			fputs_filtered
			  (compare_cond_names[GET_FIELD (insn, 16, 18)], info);
d790 2
a791 4
			fputs_filtered
			  (compare_cond_names[GET_FIELD (insn, 16, 18)
					      + GET_FIELD (insn, 4, 4) * 8],
			   info);
d794 2
a795 4
			fputs_filtered
			  (compare_cond_64_names[GET_FIELD (insn, 16, 18)
						 + GET_FIELD (insn, 2, 2) * 8],
			   info);
d798 2
a799 3
			fputs_filtered
			  (cmpib_cond_64_names[GET_FIELD (insn, 16, 18)],
			   info);
d802 2
a803 4
			fputs_filtered
			  (add_cond_names[GET_FIELD (insn, 16, 18)
					  + GET_FIELD (insn, 4, 4) * 8],
			   info);
d806 2
a807 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   compare_cond_names[GET_COND (insn)]);
d810 2
a811 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   compare_cond_64_names[GET_COND (insn)]);
d814 2
a815 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   add_cond_names[GET_COND (insn)]);
d818 2
a819 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   add_cond_64_names[GET_COND (insn)]);
d822 2
a823 3
			(*info->fprintf_func)
			  (info->stream, "%s",
			   add_cond_names[GET_FIELD (insn, 16, 18)]);
d827 1
a827 1
			(*info->fprintf_func)
d829 2
a830 2
			   wide_add_cond_names[GET_FIELD (insn, 16, 18) +
					       GET_FIELD (insn, 4, 4) * 8]);
d834 2
a835 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   logical_cond_names[GET_COND (insn)]);
d838 2
a839 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   logical_cond_64_names[GET_COND (insn)]);
d842 2
a843 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   unit_cond_names[GET_COND (insn)]);
d846 2
a847 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   unit_cond_64_names[GET_COND (insn)]);
d862 2
a863 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   shift_cond_64_names[GET_FIELD (insn, 16, 18)]);
d924 2
a925 2
		  (*info->print_address_func)
		    (memaddr + 8 + extract_12 (insn), info);
d929 3
a931 2
		  (*info->print_address_func)
		    ((memaddr + 8 + extract_17 (insn)), info);
d949 1
a949 1

d956 1
a956 1
					 GET_FIELD (insn, 24, 25));
d960 1
a960 1
					 GET_FIELD (insn, 22, 25));
d967 1
a967 1
					 31 - GET_FIELD (insn, 22, 26));
d979 1
a979 1
					 GET_FIELD (insn, 22, 26));
d991 1
a991 1
					 32 - GET_FIELD (insn, 27, 31));
d1019 1
a1019 2
		  (*info->fprintf_func) (info->stream, ",%d",
					 GET_FIELD (insn, 23, 25));
d1041 1
a1041 2
		  (*info->fprintf_func) (info->stream, ",%d",
					 GET_FIELD (insn, 23, 25));
d1047 2
a1048 2
		    fputs_filtered
		      (float_format_names[GET_FIELD (insn, 19, 20)], info);
d1050 3
a1052 3
		    (*info->fprintf_func)
		      (info->stream, "%s ",
		       float_format_names[GET_FIELD (insn, 19, 20)]);
d1055 3
a1057 3
		  (*info->fprintf_func)
		    (info->stream, "%s ",
		     float_format_names[GET_FIELD (insn, 17, 18)]);
d1062 1
a1062 1
					   float_format_names[0]);
d1065 1
a1065 1
					   float_format_names[1]);
d1071 2
a1072 2
		    fputs_filtered
		      (float_format_names[GET_FIELD (insn, 20, 20)], info);
d1074 3
a1076 3
		    (*info->fprintf_func)
		      (info->stream, "%s ",
		       float_format_names[GET_FIELD (insn, 20, 20)]);
d1079 3
a1081 3
		case 'J':
		  fput_const (extract_14 (insn), info);
		  break;
d1098 1
a1098 1
		case 'K':
d1134 1
a1135 2
		  break; /* Dealt with by '{' */

d1137 2
a1138 23
		  {
		    int sub = GET_FIELD (insn, 14, 16);
		    int df = GET_FIELD (insn, 17, 18);
		    int sf = GET_FIELD (insn, 19, 20);
		    const char * const * source = float_format_names;
		    const char * const * dest = float_format_names;
		    char *t = "";
		    if (sub == 4)
		      {
			fputs_filtered (",UND ", info);
			break;
		      }
		    if ((sub & 3) == 3)
		      t = ",t";
		    if ((sub & 3) == 1)
		      source = sub & 4 ? fcnv_ufixed_names : fcnv_fixed_names;
		    if (sub & 2)
		      dest = sub & 4 ? fcnv_ufixed_names : fcnv_fixed_names;

		    (*info->fprintf_func) (info->stream, "%s%s%s ",
					   t, source[sf], dest[df]);
		    break;
		  }
d1184 3
a1186 2
		  (*info->print_address_func)
		    (memaddr + 8 + extract_22 (insn), info);
@


1.41.22.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2003
d29 1
a29 1
static const char *const reg_names[] =
d37 4
a40 4
static const char *const fp_reg_names[] =
 {"fpsr", "fpe2", "fpe4", "fpe6",
  "fr4", "fr5", "fr6", "fr7", "fr8",
  "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
a125 2
static const char *const fcnv_fixed_names[] = {",w", ",dw", "", ",qw"};
static const char *const fcnv_ufixed_names[] = {",uw", ",udw", "", ",uqw"};
d139 1
a139 1
/* For a bunch of different instructions form an index into a
d197 2
a198 2
    (*info->fprintf_func) (info->stream, "%sR",
			   reg ? fp_reg_names[reg] : "fr0");
d339 2
a340 2
		      GET_FIELD (word, 29, 29) << 10 |
		      (word & 0x1) << 11, 12) << 2;
d351 3
a353 3
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
		      (word & 0x1) << 16, 17) << 2;
d361 4
a364 4
		      GET_FIELD (word, 29, 29) << 10 |
		      GET_FIELD (word, 11, 15) << 11 |
		      GET_FIELD (word, 6, 10) << 16 |
		      (word & 0x1) << 21, 22) << 2;
d400 1
a400 1
	  if (!strchr ("cfCY?-+nHNZFIuv{", opcode->args[0]))
d420 1
a420 1
		  /* Handle floating point registers.  */
d440 4
a443 4
		      /* 'fA' will not generate a space before the regsiter
			 name.  Normally that is fine.  Except that it
			 causes problems with xmpyu which has no FP format
			 completer.  */
d446 2
a447 1
		      /* FALLTHRU */
d454 1
d519 4
a522 4
		      /* 'fe' will not generate a space before the register
			 name.  Normally that is fine.  Except that it
			 causes problems with fstw fe,y(b) which has no FP
			 format completer.  */
d525 2
a526 1
		      /* FALLTHRU */
d544 2
a545 6
		  {
		    int space = GET_FIELD (insn, 16, 17);
		    /* Zero means implicit addressing, not use of sr0.  */
		    if (space != 0)
		      (*info->fprintf_func) (info->stream, "sr%d", space);
		  }
d549 1
a549 2
		  (*info->fprintf_func) (info->stream, "sr%d",
					 extract_3 (insn));
d552 1
a552 1
		  /* Handle completers.  */
d557 2
a558 3
		      (*info->fprintf_func)
			(info->stream, "%s",
			 index_compl_names[GET_COMPL (insn)]);
d561 2
a562 3
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 index_compl_names[GET_COMPL (insn)]);
d565 2
a566 3
		      (*info->fprintf_func)
			(info->stream, "%s",
			 short_ldst_compl_names[GET_COMPL (insn)]);
d569 2
a570 3
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_ldst_compl_names[GET_COMPL (insn)]);
d573 2
a574 3
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_bytes_compl_names[GET_COMPL (insn)]);
d577 2
a578 3
		      (*info->fprintf_func)
			(info->stream, "%s",
			 short_bytes_compl_names[GET_COMPL (insn)]);
d621 2
a622 3
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 read_write_names[GET_FIELD (insn, 25, 25)]);
d647 2
a648 2
			(info->stream, "%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
d652 2
a653 2
			(info->stream, ",dc%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
d657 2
a658 2
			(info->stream, ",c%s",
			 add_compl_names[GET_FIELD (insn, 20, 21)]);
d687 2
a688 2
			  (info->stream, "%s",
			   signed_unsigned_names[GET_FIELD (insn, 21, 21)]);
d691 2
a692 2
			  (info->stream, "%s ",
			   signed_unsigned_names[GET_FIELD (insn, 21, 21)]);
d696 2
a697 2
			(info->stream, "%s",
			 mix_half_names[GET_FIELD (insn, 17, 17)]);
d701 2
a702 2
			(info->stream, "%s ",
			 saturation_names[GET_FIELD (insn, 24, 25)]);
d706 3
a708 3
			(info->stream, ",%d%d%d%d ",
			 GET_FIELD (insn, 17, 18), GET_FIELD (insn, 20, 21),
			 GET_FIELD (insn, 22, 23), GET_FIELD (insn, 24, 25));
d769 1
a769 1
		  /* Handle conditions.  */
d776 3
a778 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   float_comp_names[GET_FIELD (insn, 27, 31)]);
d781 1
a781 1
			/* these four conditions are for the set of instructions
d786 2
a787 2
			fputs_filtered
			  (compare_cond_names[GET_FIELD (insn, 16, 18)], info);
d790 2
a791 4
			fputs_filtered
			  (compare_cond_names[GET_FIELD (insn, 16, 18)
					      + GET_FIELD (insn, 4, 4) * 8],
			   info);
d794 2
a795 4
			fputs_filtered
			  (compare_cond_64_names[GET_FIELD (insn, 16, 18)
						 + GET_FIELD (insn, 2, 2) * 8],
			   info);
d798 2
a799 3
			fputs_filtered
			  (cmpib_cond_64_names[GET_FIELD (insn, 16, 18)],
			   info);
d802 2
a803 4
			fputs_filtered
			  (add_cond_names[GET_FIELD (insn, 16, 18)
					  + GET_FIELD (insn, 4, 4) * 8],
			   info);
d806 2
a807 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   compare_cond_names[GET_COND (insn)]);
d810 2
a811 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   compare_cond_64_names[GET_COND (insn)]);
d814 2
a815 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   add_cond_names[GET_COND (insn)]);
d818 2
a819 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   add_cond_64_names[GET_COND (insn)]);
d822 2
a823 3
			(*info->fprintf_func)
			  (info->stream, "%s",
			   add_cond_names[GET_FIELD (insn, 16, 18)]);
d827 1
a827 1
			(*info->fprintf_func)
d829 2
a830 2
			   wide_add_cond_names[GET_FIELD (insn, 16, 18) +
					       GET_FIELD (insn, 4, 4) * 8]);
d834 2
a835 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   logical_cond_names[GET_COND (insn)]);
d838 2
a839 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   logical_cond_64_names[GET_COND (insn)]);
d842 2
a843 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   unit_cond_names[GET_COND (insn)]);
d846 2
a847 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   unit_cond_64_names[GET_COND (insn)]);
d862 2
a863 3
			(*info->fprintf_func)
			  (info->stream, "%s ",
			   shift_cond_64_names[GET_FIELD (insn, 16, 18)]);
d924 2
a925 2
		  (*info->print_address_func)
		    (memaddr + 8 + extract_12 (insn), info);
d929 3
a931 2
		  (*info->print_address_func)
		    ((memaddr + 8 + extract_17 (insn)), info);
d949 1
a949 1

d956 1
a956 1
					 GET_FIELD (insn, 24, 25));
d960 1
a960 1
					 GET_FIELD (insn, 22, 25));
d967 1
a967 1
					 31 - GET_FIELD (insn, 22, 26));
d979 1
a979 1
					 GET_FIELD (insn, 22, 26));
d991 1
a991 1
					 32 - GET_FIELD (insn, 27, 31));
d1019 1
a1019 2
		  (*info->fprintf_func) (info->stream, ",%d",
					 GET_FIELD (insn, 23, 25));
d1041 1
a1041 2
		  (*info->fprintf_func) (info->stream, ",%d",
					 GET_FIELD (insn, 23, 25));
d1047 2
a1048 2
		    fputs_filtered
		      (float_format_names[GET_FIELD (insn, 19, 20)], info);
d1050 3
a1052 3
		    (*info->fprintf_func)
		      (info->stream, "%s ",
		       float_format_names[GET_FIELD (insn, 19, 20)]);
d1055 3
a1057 3
		  (*info->fprintf_func)
		    (info->stream, "%s ",
		     float_format_names[GET_FIELD (insn, 17, 18)]);
d1062 1
a1062 1
					   float_format_names[0]);
d1065 1
a1065 1
					   float_format_names[1]);
d1071 2
a1072 2
		    fputs_filtered
		      (float_format_names[GET_FIELD (insn, 20, 20)], info);
d1074 3
a1076 3
		    (*info->fprintf_func)
		      (info->stream, "%s ",
		       float_format_names[GET_FIELD (insn, 20, 20)]);
d1079 3
a1081 3
		case 'J':
		  fput_const (extract_14 (insn), info);
		  break;
d1098 1
a1098 1
		case 'K':
d1134 1
a1135 2
		  break; /* Dealt with by '{' */

d1137 2
a1138 23
		  {
		    int sub = GET_FIELD (insn, 14, 16);
		    int df = GET_FIELD (insn, 17, 18);
		    int sf = GET_FIELD (insn, 19, 20);
		    const char * const * source = float_format_names;
		    const char * const * dest = float_format_names;
		    char *t = "";
		    if (sub == 4)
		      {
			fputs_filtered (",UND ", info);
			break;
		      }
		    if ((sub & 3) == 3)
		      t = ",t";
		    if ((sub & 3) == 1)
		      source = sub & 4 ? fcnv_ufixed_names : fcnv_fixed_names;
		    if (sub & 2)
		      dest = sub & 4 ? fcnv_ufixed_names : fcnv_fixed_names;

		    (*info->fprintf_func) (info->stream, "%s%s%s ",
					   t, source[sf], dest[df]);
		    break;
		  }
d1184 3
a1186 2
		  (*info->print_address_func)
		    (memaddr + 8 + extract_22 (insn), info);
@


1.40
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d557 4
d565 4
d572 4
d577 1
a577 1
		      (*info->fprintf_func) (info->stream, "%s ",
d701 1
a701 1
			  (info->stream, "%s", saturation_names[GET_FIELD
@


1.39
log
@Adds assembly and dis-assembly support for the HPPA wide
mode, 16 bit forms of ldi, ldo, ldw and stw instructions.
@
text
@d2 1
a2 1
   Copyright 1989, 90, 92, 93, 94, 95, 98, 99, 2000, 2001
@


1.39.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1989, 1990, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001
@


1.38
log
@Add some prototypes, and fix a few warnings.
@
text
@d2 1
a2 1
   Copyright 1989, 90, 92, 93, 94, 95, 98, 99, 2000
d892 1
d1103 1
@


1.37
log
@
        * hppa-dis.c (extract_16): New function.
        (print_insn_hppa): Fix incorrect handling of 'fe'. Added handling of
        new operand types l,y,&,fe,fE,fx.
@
text
@d2 2
a3 1
   Copyright 1989, 1990, 1992, 1993 Free Software Foundation, Inc.
d55 1
a55 1
/* This macro gets bit fields using HP's numbering (MSB = 0) */
d60 3
d147 20
d717 1
a717 1
			int opcode = GET_FIELD (insn, 0, 5);
d719 1
a719 1
			if (opcode == 0x16 || opcode == 0x1e)
d733 1
a733 1
			int opcode = GET_FIELD (insn, 0, 5);
d735 1
a735 1
			if (opcode == 0x13 || opcode == 0x1b)
d742 1
a742 1
			else if (opcode == 0x17 || opcode == 0x1f)
@


1.36
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d45 1
a45 1
/* Get at various relevent fields of an instruction word. */
d51 1
d136 1
a136 1
   completer name table. */
d185 1
a185 1
/* print constants with sign */
d199 1
a199 1
   instructions. */
d201 1
a201 1
/* extract a 3-bit space register number from a be, ble, mtsp or mfsp */
d216 1
a216 1
/* extract the immediate field from a st{bhw}s instruction */
d224 1
a224 1
/* extract the immediate field from a break instruction */
d232 1
a232 1
/* extract the immediate field from a {sr}sm instruction */
d240 1
a240 1
/* extract the 10 bit immediate field from a {sr}sm instruction */
d248 1
a248 1
/* extract the immediate field from a bb instruction */
d256 1
a256 1
/* extract an 11 bit immediate field */
d264 1
a264 1
/* extract a 14 bit immediate field */
d272 15
a286 1
/* extract a 21 bit constant */
d308 1
a308 1
/* extract a 12 bit constant from branch instructions */
d319 2
a320 2
/* extract a 17 bit constant from branch instructions, returning the
   19 bit signed value. */
d370 4
a373 1
	  
d494 10
d505 1
a505 1
		      if (GET_FIELD (insn, 25, 25))
d510 3
a512 1

d868 4
d1074 18
@


1.35
log
@        * hppa-dis.c (unit_cond_names): Add PA2.0 unit condition names.
        (print_insn_hppa): Handle 'B' operand.
@
text
@a20 1
#include <ansidecl.h>
@


1.35.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@d21 1
@


1.34
log
@        * hppa-dis.c (print_insn_hppa):  Add new codes 'cc', 'cd', 'cC',
        'co', '@@'.

        * hppa-dis.c (print_insn_hppa): Removed unused args.  Fix '?W'.

        * hppa-dis.c (print_insn_hppa):  Implement codes "?N", "?Q".
@
text
@d100 2
a101 2
  "", 0, ",sbz", ",shz", ",sdc", 0, ",sbc", ",shc",
  ",tr", 0, ",nbz", ",nhz", ",ndc", 0, ",nbc", ",nhc"
d826 1
@


1.33
log
@Remove accidental case duplication.
@
text
@d515 27
d544 1
d678 1
a678 1
		    case 'c':
d724 1
a724 1
		      case 'T':
d726 1
a726 5
							  + 8], info);
			break;
		      case 'r':
			fputs_filtered (compare_cond_64_names[GET_FIELD (insn, 16, 18)],
					info);
d728 1
a728 1
		      case 'R':
d730 1
a730 1
							     + 8], info);
a735 4
		      case 'n':
			fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)
					+ GET_FIELD (insn, 4, 4) * 8], info);
			break;
a760 11
		      case 'D':
			(*info->fprintf_func) (info->stream, "%s",
					       add_cond_names[GET_FIELD (insn, 16, 18)
							     + 8]);
			break;
		      case 'w':
			(*info->fprintf_func) 
			  (info->stream, "%s",
			   wide_add_cond_names[GET_FIELD (insn, 16, 18)]);
			break;

d764 2
a765 1
			   wide_add_cond_names[GET_FIELD (insn, 16, 18) + 8]);
d879 4
@


1.32
log
@       * hppa-dis.c (print_insn_hppa): Replace 'B', 'M', 'g' and 'l' with
        cleaner code using completer prefixes.  Add 'Y'.
@
text
@a1083 4
		case 'Y':
		  /* be,l %sr0,%r31 implicit output.  */
		  (*info->fprintf_func) (info->stream, "%%sr0,%%r31");
		  break;
@


1.31
log
@        * hppa-dis.c: (print_insn_hppa): Correct 'cJ', 'cc'.
@
text
@d515 9
d863 5
d1084 3
a1086 5
		case 'B':
		  fputs_filtered (",pop", info);
		  break;
		case 'M':
		  fputs_filtered (",push", info);
a1089 6
		  break;
		case 'g':
		  fputs_filtered (",gate", info);
		  break;
		case 'l':
		  fputs_filtered (",l", info);
@


1.30
log
@        * hppa-dis.c (extract_22): New function.
@
text
@a510 12
		    case 'q':
		      (*info->fprintf_func)
			(info->stream, "%s ",
			 short_ldst_compl_names[(GET_FIELD (insn, 28, 28)
						 | GET_FIELD (insn, 29, 29))]);
		      break;
		    case 'J':
		      if (insn & 0x4)
		        (*info->fprintf_func) (info->stream, ",mb ");
		      else
		        (*info->fprintf_func) (info->stream, ",ma ");
		      break;
d608 56
@


1.29
log
@        * hppa-dis.c (print_insn_hppa): Handle 'J', 'K', and 'cc'.
@
text
@d318 11
a938 1

@


1.28
log
@        * hppa-dis.c (print_insn_hppa): Handle 'fe' and 'cJ'.
@
text
@d924 6
d945 1
@


1.27
log
@        * hppa-dis.c (print_insn_hppa): Handle '#', 'd', and 'cq'.
@
text
@d466 7
d505 6
@


1.26
log
@        * hppa-dis.c (print_insn_hppa): Handle 'm', 'h', '='.
@
text
@d493 6
d911 31
@


1.25
log
@        * hppa-dis.c (print_insn_hppa): Handle 'X' operand.
@
text
@d905 49
@


1.24
log
@        * hppa-dis.c (print_insn_hppa): Handle 'B' operand.
@
text
@d905 5
@


1.23
log
@        * hppa-dis.c (print_insn_hppa): Handle 'M' and 'L' operands.
@
text
@d905 3
@


1.22
log
@        * hppa-dis.c (print_insn_hppa): Handle 'l' operand.
@
text
@d905 6
@


1.21
log
@
        * hppa-dis.c (print_insn_hppa): Handle 'g' operand.
@
text
@d908 3
@


1.20
log
@        * hppa-dis.c (print_insn_hppa): Output a space after 'X' completer.
@
text
@d905 3
@


1.19
log
@        * hppa-dis.c: (print_insn_hppa): Do output a space before a 'v'
        operand.
@
text
@d704 1
a704 1
			(*info->fprintf_func) (info->stream, "%s",
@


1.18
log
@        * hppa-dis.c: (print_insn_hppa): Handle 'fX'.
@
text
@d348 1
a348 1
	  if (!strchr ("cfCY?-+nHNZFIu", opcode->args[0]))
@


1.17
log
@        * hppa-dis.c: (print_insn_hppa): Add missing break after
        FP register case.
@
text
@d387 10
@


1.16
log
@
        * hppa-dis.c: Finish constifying various completers, register
        names, etc etc.
@
text
@d457 1
@


1.15
log
@        * hppa-dis.c (print_insn_hppa): Escape '%' in output strings.
@
text
@d62 1
a62 1
static const char control_reg[][6] = {
d70 1
a70 1
static const char compare_cond_names[][5] = {
d74 1
a74 1
static const char compare_cond_64_names[][6] = {
d78 1
a78 1
static const char cmpib_cond_64_names[][6] = {
d81 1
a81 1
static const char add_cond_names[][5] = {
d85 1
a85 1
static const char add_cond_64_names[][6] = {
d89 1
a89 1
static const char wide_add_cond_names[][5] = {
d107 1
a107 1
static const char shift_cond_names[][4] = {
d110 1
a110 1
static const char shift_cond_64_names[][5] = {
d113 1
a113 1
static const char bb_cond_64_names[][5] = {
d116 2
a117 2
static const char index_compl_names[][4] = {"", ",m", ",s", ",sm"};
static const char short_ldst_compl_names[][4] = {"", ",ma", "", ",mb"};
d122 1
a122 1
static const char float_comp_names[][8] =
d129 5
a133 7
static const char *const signed_unsigned_names[][3] = {",u", ",s"};
static const char *const mix_half_names[][3] = {",l", ",r"};
static const char *const saturation_names[][4] = {",us", ",ss", 0, ""};
static const char *const read_write_names[][3] = {",r", ",w"};
static const char *const add_compl_names[] = {
  0, "", ",l", ",tsv"
};
@


1.14
log
@
        * hppa-dis.c (print_insn_hppa): Handle 'Z' argument.
@
text
@d769 1
a769 1
		  (*info->fprintf_func) (info->stream, "%r1");
d781 1
a781 1
		  (*info->fprintf_func) (info->stream, "%sar");
@


1.13
log
@        * hppa-dis.c (print_insn_hppa): Replace 'f' by 'v'.  Prefix float
        register args by 'f'.
@
text
@d86 1
a86 1
  ",*", ",*=", ",*<", ",*<=", ",*nuv", ",*znv", ",*sv", ",*od",
d97 1
a97 1
  ",*", ",*=", ",*<", ",*<=", 0, 0, 0, ",*od",
d104 1
a104 1
  ",*", ",*swz", ",*sbz", ",*shz", ",*sdc", ",*swc", ",*sbc", ",*shc",
d111 1
a111 1
  ",*", ",*=", ",*<", ",*od", ",*tr", ",*<>", ",*>=", ",*ev"
d766 6
@


1.12
log
@        * hppa-dis.c (print_insn_hppa): Add args q, %, !, and |.
@
text
@a358 6
		case 'X':
                  if (GET_FIELD (insn, 25, 25))
		      fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		  else
		      fput_fp_reg (GET_FIELD (insn, 11, 15), info);
		  break;
a365 6
		case 'E':
		  fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		  break;
		case '!':
		  fput_creg (11, info);
		  break;
d369 6
a374 4
		case 'v':
                  if (GET_FIELD (insn, 25, 25))
		      fput_fp_reg_r (GET_FIELD (insn, 27, 31), info);
		  else
d376 53
a428 7
		  break;
		case 'y':
		  fput_fp_reg (GET_FIELD (insn, 27, 31), info);
		  break;
		case '4':
		  {
		    int reg = GET_FIELD (insn, 6, 10);
d430 7
a436 7
		    reg |= (GET_FIELD (insn, 26, 26) << 4);
		    fput_fp_reg (reg, info);
		    break;
		  }
		case '6':
		  {
		    int reg = GET_FIELD (insn, 11, 15);
d438 7
a444 7
		    reg |= (GET_FIELD (insn, 26, 26) << 4);
		    fput_fp_reg (reg, info);
		    break;
		  }
		case '7':
		  {
		    int reg = GET_FIELD (insn, 27, 31);
d446 7
a452 7
		    reg |= (GET_FIELD (insn, 26, 26) << 4);
		    fput_fp_reg (reg, info);
		    break;
		  }
		case '8':
		  {
		    int reg = GET_FIELD (insn, 16, 20);
d454 5
a458 7
		    reg |= (GET_FIELD (insn, 26, 26) << 4);
		    fput_fp_reg (reg, info);
		    break;
		  }
		case '9':
		  {
		    int reg = GET_FIELD (insn, 21, 25);
a459 4
		    reg |= (GET_FIELD (insn, 26, 26) << 4);
		    fput_fp_reg (reg, info);
		    break;
		  }
d601 1
a601 2
			fputs_filtered (compare_cond_names[GET_FIELD (insn, 16,
								      18)],
d621 1
a621 2
			fputs_filtered (compare_cond_names[GET_FIELD (insn, 16,
								      18)
d646 1
a646 3
					       add_cond_names[GET_FIELD (insn,
									 16,
									 18)]);
d648 1
d651 2
a652 3
					       add_cond_names[GET_FIELD (insn,
									 16, 18)
							      + 8]);
d655 1
a655 1
			(*info->fprintf_func)
d661 1
a661 1
			(*info->fprintf_func)
d830 1
a830 1
		case 'f':
a839 11
		case '3':
		  {
		    int reg = GET_FIELD (insn, 21, 22);
		    reg |= GET_FIELD (insn, 16, 18) << 2;
		    if (GET_FIELD (insn, 23, 23) != 0)
		      fput_fp_reg_r (reg, info);
		    else
		      fput_fp_reg (reg, info);
		    break;
		  }

a888 13
		  break;
		case 'J':
                  if (GET_FIELD (insn, 24, 24))
		      fput_fp_reg_r (GET_FIELD (insn, 6, 10), info);
		  else
		      fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		      
		  break;
		case 'K':
                  if (GET_FIELD (insn, 19, 19))
		      fput_fp_reg_r (GET_FIELD (insn, 11, 15), info);
		  else
		      fput_fp_reg (GET_FIELD (insn, 11, 15), info);
@


1.11
log
@        * hppa-dis.c (MASK_10, read_write_names, add_compl_names,
        extract_10U_store):  New.
        (print_insn_hppa):  Add new completers.
@
text
@d375 3
d482 4
d767 8
d779 16
@


1.10
log
@        * hppa-dis.c (signed_unsigned_names,mix_half_names,
        saturation_names):  New.
        (print_insn_hppa): Add completer codes 'a', 'ch', 'cH', 'cS', and 'c*'.
@
text
@d49 1
d131 5
a135 2
static const char *const saturation_names[][3] = {",us", ",ss", 0, ""};

d242 8
d455 14
d475 42
d688 3
d736 4
@


1.9
log
@        * hppa-dis.c (print_insn_hppa): Place completers behind prefix 'c'.
@
text
@d128 4
d353 1
d448 27
@


1.8
log
@Add missing '!' change.
@
text
@d421 2
d424 21
a444 10
		  (*info->fprintf_func) (info->stream, "%s ",
				    index_compl_names[GET_COMPL (insn)]);
		  break;
		case 'C':
		  (*info->fprintf_func) (info->stream, "%s ",
				    short_ldst_compl_names[GET_COMPL (insn)]);
		  break;
		case 'Y':
		  (*info->fprintf_func) (info->stream, "%s ",
				    short_bytes_compl_names[GET_COMPL (insn)]);
a661 6
		  break;
		case 'Z':
		  if (GET_FIELD (insn, 26, 26))
		    (*info->fprintf_func) (info->stream, ",m ");
		  else
		    (*info->fprintf_func) (info->stream, " ");
@


1.7
log
@        * hppa-dis.c (print_insn_hppa): Add cases for '.', '~'. '$'. and '!'
@
text
@d621 3
@


1.6
log
@        * hppa-dis.c (print_insn_hppa):  Look at next arg instead of bits
        to decide to print a space.
@
text
@d617 4
d625 8
d640 3
@


1.5
log
@        * hppa-dis.c (compare_cond_64_names, cmpib_cond_64_names,
        add_cond_64_names, wide_add_cond_names, logical_cond_64_names,
        unit_cond_64_names, shift_cond_64_names, bb_cond_64_names): New.
        (print_insn_hppa): Add 64 bit condition completers.
@
text
@d680 1
a680 1
		  if (GET_FIELD (insn, 21, 22) == 1 || s[1] == '?')
d704 1
a704 1
		  if (GET_FIELD (insn, 21, 22) == 1 || s[1] == '?')
@


1.4
log
@
        * hppa-dis.c (print_insn_hppa): Change condition args to use
        '?' prefix.
@
text
@d70 9
a78 3
  "", ",=", ",<", ",<=", ",<<", ",<<=", ",sv",
  ",od", ",tr", ",<>", ",>=", ",>", ",>>=",
  ",>>", ",nsv", ",ev"
d81 10
a90 3
  "", ",=", ",<", ",<=", ",nuv", ",znv", ",sv",
  ",od", ",tr", ",<>", ",>=", ",>", ",uv",
  ",vnz", ",nsv", ",ev"
d95 3
d102 4
d109 6
d417 1
d455 16
d484 4
d492 4
d502 17
d524 4
d532 4
d548 8
d557 5
@


1.3
log
@Fix oops.
@
text
@d308 1
a308 1
	  if (!strchr ("cfCY<?!@@-+&U>~nHNZFIMadu|", opcode->args[0]))
d406 2
a407 7
		/* these four conditions are for the set of instructions
		   which distinguish true/false conditions by opcode rather
		   than by the 'f' bit (sigh): comb, comib, addb, addib */
		case '<':
		  fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)],
				  info);
		  break;
d409 67
a475 19
		  fputs_filtered (compare_cond_names[GET_FIELD (insn, 16, 18)
				  + GET_FIELD (insn, 4, 4) * 8], info);
		  break;
		case '@@':
		  fputs_filtered (add_cond_names[GET_FIELD (insn, 16, 18)
				  + GET_FIELD (insn, 4, 4) * 8], info);
		  break;
		case 'a':
		  (*info->fprintf_func) (info->stream, "%s ",
					 compare_cond_names[GET_COND (insn)]);
		  break;
		case 'd':
		  (*info->fprintf_func) (info->stream, "%s ",
					 add_cond_names[GET_COND (insn)]);
		  break;
		case '!':
		  (*info->fprintf_func) (info->stream, "%s",
				    add_cond_names[GET_FIELD (insn, 16, 18)]);
		  break;
a476 20
		case '&':
		  (*info->fprintf_func) (info->stream, "%s ",
				    logical_cond_names[GET_COND (insn)]);
		  break;
		case 'U':
		  (*info->fprintf_func) (info->stream, "%s ",
				    unit_cond_names[GET_COND (insn)]);
		  break;
		case '|':
		case '>':
		case '~':
		  (*info->fprintf_func)
		    (info->stream, "%s",
		     shift_cond_names[GET_FIELD (insn, 16, 18)]);

		  /* If the next character in args is 'n', it will handle
		     putting out the space.  */
		  if (s[1] != 'n')
		    (*info->fprintf_func) (info->stream, " ");
		  break;
d591 1
a591 1
		  if (GET_FIELD (insn, 21, 22) == 1 || s[1] == 'M')
d615 1
a615 1
		  if (GET_FIELD (insn, 21, 22) == 1 || s[1] == 'M')
a634 5
		  break;
		case 'M':
		    (*info->fprintf_func) (info->stream, "%s ",
					   float_comp_names[GET_FIELD
							      (insn, 27, 31)]);
@


1.2
log
@
        * hppa-dis.c (print_insn_hppa): Remove unnecessary test in 'E'
        code.
@
text
@d331 1
@


1.1
log
@Initial revision
@
text
@d330 1
a330 5
                  if (GET_FIELD (insn, 25, 25))
		      fput_fp_reg_r (GET_FIELD (insn, 6, 10), info);
		  else
		      fput_fp_reg (GET_FIELD (insn, 6, 10), info);
		  break;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

