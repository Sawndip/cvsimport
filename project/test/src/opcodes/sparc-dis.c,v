head	1.26;
access;
symbols
	sid-snapshot-20180601:1.26
	sid-snapshot-20180501:1.26
	sid-snapshot-20180401:1.26
	sid-snapshot-20180301:1.26
	sid-snapshot-20180201:1.26
	sid-snapshot-20180101:1.26
	sid-snapshot-20171201:1.26
	sid-snapshot-20171101:1.26
	sid-snapshot-20171001:1.26
	sid-snapshot-20170901:1.26
	sid-snapshot-20170801:1.26
	sid-snapshot-20170701:1.26
	sid-snapshot-20170601:1.26
	sid-snapshot-20170501:1.26
	sid-snapshot-20170401:1.26
	sid-snapshot-20170301:1.26
	sid-snapshot-20170201:1.26
	sid-snapshot-20170101:1.26
	sid-snapshot-20161201:1.26
	sid-snapshot-20161101:1.26
	sid-snapshot-20160901:1.26
	sid-snapshot-20160801:1.26
	sid-snapshot-20160701:1.26
	sid-snapshot-20160601:1.26
	sid-snapshot-20160501:1.26
	sid-snapshot-20160401:1.26
	sid-snapshot-20160301:1.26
	sid-snapshot-20160201:1.26
	sid-snapshot-20160101:1.26
	sid-snapshot-20151201:1.26
	sid-snapshot-20151101:1.26
	sid-snapshot-20151001:1.26
	sid-snapshot-20150901:1.26
	sid-snapshot-20150801:1.26
	sid-snapshot-20150701:1.26
	sid-snapshot-20150601:1.26
	sid-snapshot-20150501:1.26
	sid-snapshot-20150401:1.26
	sid-snapshot-20150301:1.26
	sid-snapshot-20150201:1.26
	sid-snapshot-20150101:1.26
	sid-snapshot-20141201:1.26
	sid-snapshot-20141101:1.26
	sid-snapshot-20141001:1.26
	sid-snapshot-20140901:1.26
	sid-snapshot-20140801:1.26
	sid-snapshot-20140701:1.26
	sid-snapshot-20140601:1.26
	sid-snapshot-20140501:1.26
	sid-snapshot-20140401:1.26
	sid-snapshot-20140301:1.26
	sid-snapshot-20140201:1.26
	sid-snapshot-20140101:1.26
	sid-snapshot-20131201:1.26
	sid-snapshot-20131101:1.26
	sid-snapshot-20131001:1.26
	binutils-2_24-branch:1.26.0.2
	binutils-2_24-branchpoint:1.26
	binutils-2_21_1:1.17
	sid-snapshot-20130901:1.26
	gdb_7_6_1-2013-08-30-release:1.24
	sid-snapshot-20130801:1.25
	sid-snapshot-20130701:1.25
	sid-snapshot-20130601:1.25
	sid-snapshot-20130501:1.25
	gdb_7_6-2013-04-26-release:1.24
	sid-snapshot-20130401:1.24
	binutils-2_23_2:1.24
	gdb_7_6-branch:1.24.0.4
	gdb_7_6-2013-03-12-branchpoint:1.24
	sid-snapshot-20130301:1.24
	sid-snapshot-20130201:1.24
	sid-snapshot-20130101:1.24
	sid-snapshot-20121201:1.24
	gdb_7_5_1-2012-11-29-release:1.23
	binutils-2_23_1:1.24
	sid-snapshot-20121101:1.24
	binutils-2_23:1.24
	sid-snapshot-20121001:1.24
	sid-snapshot-20120901:1.24
	gdb_7_5-2012-08-17-release:1.23
	sid-snapshot-20120801:1.24
	binutils-2_23-branch:1.24.0.2
	binutils-2_23-branchpoint:1.24
	gdb_7_5-branch:1.23.0.2
	gdb_7_5-2012-07-18-branchpoint:1.23
	sid-snapshot-20120701:1.23
	sid-snapshot-20120601:1.23
	sid-snapshot-20120501:1.22
	binutils-2_22_branch:1.18.0.6
	gdb_7_4_1-2012-04-26-release:1.18
	sid-snapshot-20120401:1.18
	sid-snapshot-20120301:1.18
	sid-snapshot-20120201:1.18
	gdb_7_4-2012-01-24-release:1.18
	sid-snapshot-20120101:1.18
	gdb_7_4-branch:1.18.0.4
	gdb_7_4-2011-12-13-branchpoint:1.18
	sid-snapshot-20111201:1.18
	binutils-2_22:1.18
	sid-snapshot-20111101:1.18
	sid-snapshot-20111001:1.18
	binutils-2_22-branch:1.18.0.2
	binutils-2_22-branchpoint:1.18
	gdb_7_3_1-2011-09-04-release:1.17
	sid-snapshot-20110901:1.18
	sid-snapshot-20110801:1.17
	gdb_7_3-2011-07-26-release:1.17
	sid-snapshot-20110701:1.17
	sid-snapshot-20110601:1.17
	sid-snapshot-20110501:1.17
	gdb_7_3-branch:1.17.0.6
	gdb_7_3-2011-04-01-branchpoint:1.17
	sid-snapshot-20110401:1.17
	sid-snapshot-20110301:1.17
	sid-snapshot-20110201:1.17
	sid-snapshot-20110101:1.17
	binutils-2_21:1.17
	sid-snapshot-20101201:1.17
	binutils-2_21-branch:1.17.0.4
	binutils-2_21-branchpoint:1.17
	sid-snapshot-20101101:1.17
	sid-snapshot-20101001:1.17
	binutils-2_20_1:1.16
	gdb_7_2-2010-09-02-release:1.17
	sid-snapshot-20100901:1.17
	sid-snapshot-20100801:1.17
	gdb_7_2-branch:1.17.0.2
	gdb_7_2-2010-07-07-branchpoint:1.17
	sid-snapshot-20100701:1.17
	sid-snapshot-20100601:1.16
	sid-snapshot-20100501:1.16
	sid-snapshot-20100401:1.16
	gdb_7_1-2010-03-18-release:1.16
	sid-snapshot-20100301:1.16
	gdb_7_1-branch:1.16.0.6
	gdb_7_1-2010-02-18-branchpoint:1.16
	sid-snapshot-20100201:1.16
	sid-snapshot-20100101:1.16
	gdb_7_0_1-2009-12-22-release:1.16
	sid-snapshot-20091201:1.16
	sid-snapshot-20091101:1.16
	binutils-2_20:1.16
	gdb_7_0-2009-10-06-release:1.16
	sid-snapshot-20091001:1.16
	gdb_7_0-branch:1.16.0.4
	gdb_7_0-2009-09-16-branchpoint:1.16
	arc-sim-20090309:1.14
	binutils-arc-20081103-branch:1.15.0.20
	binutils-arc-20081103-branchpoint:1.15
	binutils-2_20-branch:1.16.0.2
	binutils-2_20-branchpoint:1.16
	sid-snapshot-20090901:1.15
	sid-snapshot-20090801:1.15
	msnyder-checkpoint-072509-branch:1.15.0.18
	msnyder-checkpoint-072509-branchpoint:1.15
	sid-snapshot-20090701:1.15
	dje-cgen-play1-branch:1.15.0.16
	dje-cgen-play1-branchpoint:1.15
	sid-snapshot-20090601:1.15
	sid-snapshot-20090501:1.15
	sid-snapshot-20090401:1.15
	arc-20081103-branch:1.15.0.14
	arc-20081103-branchpoint:1.15
	arc-insight_6_8-branch:1.14.0.10
	arc-insight_6_8-branchpoint:1.14
	insight_6_8-branch:1.14.0.8
	insight_6_8-branchpoint:1.14
	sid-snapshot-20090301:1.15
	binutils-2_19_1:1.15
	sid-snapshot-20090201:1.15
	sid-snapshot-20090101:1.15
	reverse-20081226-branch:1.15.0.12
	reverse-20081226-branchpoint:1.15
	sid-snapshot-20081201:1.15
	multiprocess-20081120-branch:1.15.0.10
	multiprocess-20081120-branchpoint:1.15
	sid-snapshot-20081101:1.15
	binutils-2_19:1.15
	sid-snapshot-20081001:1.15
	reverse-20080930-branch:1.15.0.8
	reverse-20080930-branchpoint:1.15
	binutils-2_19-branch:1.15.0.6
	binutils-2_19-branchpoint:1.15
	sid-snapshot-20080901:1.15
	sid-snapshot-20080801:1.15
	reverse-20080717-branch:1.15.0.4
	reverse-20080717-branchpoint:1.15
	sid-snapshot-20080701:1.15
	msnyder-reverse-20080609-branch:1.15.0.2
	msnyder-reverse-20080609-branchpoint:1.15
	drow-reverse-20070409-branch:1.13.0.24
	drow-reverse-20070409-branchpoint:1.13
	sid-snapshot-20080601:1.15
	sid-snapshot-20080501:1.15
	sid-snapshot-20080403:1.14
	sid-snapshot-20080401:1.14
	gdb_6_8-2008-03-27-release:1.14
	sid-snapshot-20080301:1.14
	gdb_6_8-branch:1.14.0.6
	gdb_6_8-2008-02-26-branchpoint:1.14
	sid-snapshot-20080201:1.14
	sid-snapshot-20080101:1.14
	sid-snapshot-20071201:1.14
	sid-snapshot-20071101:1.14
	gdb_6_7_1-2007-10-29-release:1.14
	gdb_6_7-2007-10-10-release:1.14
	sid-snapshot-20071001:1.14
	gdb_6_7-branch:1.14.0.4
	gdb_6_7-2007-09-07-branchpoint:1.14
	binutils-2_18:1.14
	binutils-2_18-branch:1.14.0.2
	binutils-2_18-branchpoint:1.14
	insight_6_6-20070208-release:1.13
	binutils-csl-coldfire-4_1-32:1.13
	binutils-csl-sourcerygxx-4_1-32:1.13
	gdb_6_6-2006-12-18-release:1.13
	binutils-csl-innovasic-fido-3_4_4-33:1.13
	binutils-csl-sourcerygxx-3_4_4-32:1.9
	binutils-csl-coldfire-4_1-30:1.13
	binutils-csl-sourcerygxx-4_1-30:1.13
	binutils-csl-coldfire-4_1-28:1.13
	binutils-csl-sourcerygxx-4_1-29:1.13
	binutils-csl-sourcerygxx-4_1-28:1.13
	gdb_6_6-branch:1.13.0.22
	gdb_6_6-2006-11-15-branchpoint:1.13
	binutils-csl-arm-2006q3-27:1.13
	binutils-csl-sourcerygxx-4_1-27:1.13
	binutils-csl-arm-2006q3-26:1.13
	binutils-csl-sourcerygxx-4_1-26:1.13
	binutils-csl-sourcerygxx-4_1-25:1.13
	binutils-csl-sourcerygxx-4_1-24:1.13
	binutils-csl-sourcerygxx-4_1-23:1.13
	insight_6_5-20061003-release:1.13
	gdb-csl-symbian-6_4_50_20060226-12:1.13
	binutils-csl-sourcerygxx-4_1-21:1.13
	binutils-csl-arm-2006q3-21:1.13
	binutils-csl-sourcerygxx-4_1-22:1.13
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.13
	binutils-csl-sourcerygxx-4_1-20:1.13
	binutils-csl-arm-2006q3-19:1.13
	binutils-csl-sourcerygxx-4_1-19:1.13
	binutils-csl-sourcerygxx-4_1-18:1.13
	binutils-csl-renesas-4_1-9:1.13
	gdb-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.13
	gdb-csl-symbian-6_4_50_20060226-11:1.13
	binutils-csl-renesas-4_1-8:1.13
	binutils-csl-renesas-4_1-7:1.13
	binutils-csl-renesas-4_1-6:1.13
	gdb-csl-sourcerygxx-4_1-17:1.13
	binutils-csl-sourcerygxx-4_1-17:1.13
	gdb-csl-20060226-branch-local-2:1.13
	gdb-csl-sourcerygxx-4_1-14:1.13
	binutils-csl-sourcerygxx-4_1-14:1.13
	binutils-csl-sourcerygxx-4_1-15:1.13
	gdb-csl-sourcerygxx-4_1-13:1.13
	binutils-csl-sourcerygxx-4_1-13:1.13
	binutils-2_17:1.13
	gdb-csl-sourcerygxx-4_1-12:1.13
	binutils-csl-sourcerygxx-4_1-12:1.13
	gdb-csl-sourcerygxx-3_4_4-21:1.13
	binutils-csl-sourcerygxx-3_4_4-21:1.13
	gdb_6_5-20060621-release:1.13
	binutils-csl-wrs-linux-3_4_4-24:1.9
	binutils-csl-wrs-linux-3_4_4-23:1.9
	gdb-csl-sourcerygxx-4_1-9:1.13
	binutils-csl-sourcerygxx-4_1-9:1.13
	gdb-csl-sourcerygxx-4_1-8:1.13
	binutils-csl-sourcerygxx-4_1-8:1.13
	gdb-csl-sourcerygxx-4_1-7:1.13
	binutils-csl-sourcerygxx-4_1-7:1.13
	gdb-csl-arm-2006q1-6:1.13
	binutils-csl-arm-2006q1-6:1.13
	gdb-csl-sourcerygxx-4_1-6:1.13
	binutils-csl-sourcerygxx-4_1-6:1.13
	binutils-csl-wrs-linux-3_4_4-22:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.13
	gdb-csl-symbian-6_4_50_20060226-9:1.13
	gdb-csl-symbian-6_4_50_20060226-8:1.13
	gdb-csl-coldfire-4_1-11:1.13
	binutils-csl-coldfire-4_1-11:1.13
	gdb-csl-sourcerygxx-3_4_4-19:1.13
	binutils-csl-sourcerygxx-3_4_4-19:1.13
	gdb-csl-coldfire-4_1-10:1.13
	gdb_6_5-branch:1.13.0.20
	gdb_6_5-2006-05-14-branchpoint:1.13
	binutils-csl-coldfire-4_1-10:1.13
	gdb-csl-sourcerygxx-4_1-5:1.13
	binutils-csl-sourcerygxx-4_1-5:1.13
	nickrob-async-20060513-branch:1.13.0.18
	nickrob-async-20060513-branchpoint:1.13
	gdb-csl-sourcerygxx-4_1-4:1.13
	binutils-csl-sourcerygxx-4_1-4:1.13
	msnyder-reverse-20060502-branch:1.13.0.16
	msnyder-reverse-20060502-branchpoint:1.13
	binutils-csl-wrs-linux-3_4_4-21:1.9
	gdb-csl-morpho-4_1-4:1.13
	binutils-csl-morpho-4_1-4:1.13
	gdb-csl-sourcerygxx-3_4_4-17:1.13
	binutils-csl-sourcerygxx-3_4_4-17:1.13
	binutils-csl-wrs-linux-3_4_4-20:1.9
	readline_5_1-import-branch:1.13.0.14
	readline_5_1-import-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.13
	binutils-2_17-branch:1.13.0.12
	binutils-2_17-branchpoint:1.13
	gdb-csl-symbian-20060226-branch:1.13.0.10
	gdb-csl-symbian-20060226-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.13
	msnyder-reverse-20060331-branch:1.13.0.8
	msnyder-reverse-20060331-branchpoint:1.13
	binutils-csl-2_17-branch:1.13.0.6
	binutils-csl-2_17-branchpoint:1.13
	gdb-csl-available-20060303-branch:1.13.0.4
	gdb-csl-available-20060303-branchpoint:1.13
	gdb-csl-20060226-branch:1.13.0.2
	gdb-csl-20060226-branchpoint:1.13
	gdb_6_4-20051202-release:1.12
	msnyder-fork-checkpoint-branch:1.12.0.8
	msnyder-fork-checkpoint-branchpoint:1.12
	gdb-csl-gxxpro-6_3-branch:1.12.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.12
	gdb_6_4-branch:1.12.0.4
	gdb_6_4-2005-11-01-branchpoint:1.12
	gdb-csl-arm-20051020-branch:1.12.0.2
	gdb-csl-arm-20051020-branchpoint:1.12
	binutils-csl-gxxpro-3_4-branch:1.9.0.16
	binutils-csl-gxxpro-3_4-branchpoint:1.9
	binutils-2_16_1:1.9
	msnyder-tracepoint-checkpoint-branch:1.10.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb-csl-arm-20050325-2005-q1b:1.9
	binutils-csl-arm-2005q1b:1.9
	binutils-2_16:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	binutils-csl-arm-2005q1a:1.9
	csl-arm-20050325-branch:1.9.0.14
	csl-arm-20050325-branchpoint:1.9
	binutils-csl-arm-2005q1-branch:1.9.0.12
	binutils-csl-arm-2005q1-branchpoint:1.9
	binutils-2_16-branch:1.9.0.10
	binutils-2_16-branchpoint:1.9
	csl-arm-2004-q3d:1.9
	gdb_6_3-20041109-release:1.9
	gdb_6_3-branch:1.9.0.6
	gdb_6_3-20041019-branchpoint:1.9
	csl-arm-2004-q3:1.9
	drow_intercu-merge-20040921:1.9
	drow_intercu-merge-20040915:1.9
	jimb-gdb_6_2-e500-branch:1.9.0.8
	jimb-gdb_6_2-e500-branchpoint:1.9
	gdb_6_2-20040730-release:1.9
	gdb_6_2-branch:1.9.0.4
	gdb_6_2-2004-07-10-gmt-branchpoint:1.9
	gdb_6_1_1-20040616-release:1.8
	binutils-2_15:1.8.46.1
	binutils-2_15-branchpoint:1.8
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	gdb_6_1-2004-04-05-release:1.8
	drow_intercu-merge-20040402:1.9
	drow_intercu-merge-20040327:1.9
	ezannoni_pie-20040323-branch:1.9.0.2
	ezannoni_pie-20040323-branchpoint:1.9
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.8.0.52
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.50
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow_intercu-20040221-branch:1.8.0.48
	drow_intercu-20040221-branchpoint:1.8
	binutils-2_15-branch:1.8.0.46
	cagney_bfdfile-20040213-branch:1.8.0.44
	cagney_bfdfile-20040213-branchpoint:1.8
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.8
	cagney_bigcore-20040122-branch:1.8.0.42
	cagney_bigcore-20040122-branchpoint:1.8
	drow-cplus-merge-20040113:1.8
	csl-arm-2003-q4:1.8
	drow-cplus-merge-20031224:1.8
	drow-cplus-merge-20031220:1.8
	carlton_dictionary-20031215-merge:1.8
	drow-cplus-merge-20031214:1.8
	carlton-dictionary-20031111-merge:1.8
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.8.0.40
	kettenis_sparc-20030918-branchpoint:1.8
	carlton_dictionary-20030917-merge:1.8
	ezannoni_pie-20030916-branchpoint:1.8
	ezannoni_pie-20030916-branch:1.8.0.38
	cagney_x86i386-20030821-branch:1.8.0.36
	cagney_x86i386-20030821-branchpoint:1.8
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.34
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.8
	binutils-2_14:1.8
	cagney_convert-20030606-branch:1.8.0.30
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.28
	cagney_writestrings-20030508-branchpoint:1.8
	jimb-ppc64-linux-20030528-branch:1.8.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.24
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.8.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.8
	kettenis_i386newframe-20030504-mergepoint:1.8
	carlton_dictionary-20030430-merge:1.8
	binutils-2_14-branch:1.8.0.20
	binutils-2_14-branchpoint:1.8
	kettenis_i386newframe-20030419-branch:1.8.0.18
	kettenis_i386newframe-20030419-branchpoint:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.16
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.14
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.12
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.10
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.8
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.6
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.4
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.8
	interps-20030202-branch:1.8.0.2
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.7.0.16
	cagney-unwind-20030108-branchpoint:1.7
	binutils-2_13_2_1:1.7
	binutils-2_13_2:1.7
	carlton_dictionary-20021223-merge:1.7
	gdb_5_3-2002-12-12-release:1.7
	carlton_dictionary-20021115-merge:1.7
	binutils-2_13_1:1.7
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.7.0.14
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	carlton_dictionary-branch:1.7.0.12
	carlton_dictionary-20020920-branchpoint:1.7
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.10
	gdb_5_3-branch:1.7.0.8
	gdb_5_3-2002-09-04-branchpoint:1.7
	kseitz_interps-20020829-merge:1.7
	cagney_sysregs-20020825-branch:1.7.0.6
	cagney_sysregs-20020825-branchpoint:1.7
	readline_4_3-import-branch:1.7.0.4
	readline_4_3-import-branchpoint:1.7
	binutils-2_13:1.7
	gdb_5_2_1-2002-07-23-release:1.6
	binutils-2_13-branchpoint:1.7
	binutils-2_13-branch:1.7.0.2
	kseitz_interps-20020528-branch:1.6.0.8
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.6
	cagney_regbuf-20020515-branchpoint:1.6
	binutils-2_12_1:1.5.8.1
	jimb-macro-020506-branch:1.6.0.4
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	binutils-2_12:1.5.8.1
	gdb_5_2-branch:1.6.0.2
	gdb_5_2-2002-03-03-branchpoint:1.6
	binutils-2_12-branch:1.5.0.8
	binutils-2_12-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	binutils-2_11_2:1.4.2.1
	binutils-2_11_1:1.4.2.1
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	insight-precleanup-2001-01-01:1.4
	binutils-2_10_1:1.2.2.1
	binutils-2_10:1.2.2.1
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.26
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2013.08.05.16.11.07;	author ebotcazou;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.06.22.22.03;	author davem;	state Exp;
branches;
next	1.24;

1.24
date	2012.07.24.12.56.47;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.27.20.43.33;	author davem;	state Exp;
branches;
next	1.21;

1.21
date	2012.04.27.18.04.00;	author davem;	state Exp;
branches;
next	1.20;

1.20
date	2012.04.27.18.02.35;	author davem;	state Exp;
branches;
next	1.19;

1.19
date	2012.04.12.16.26.01;	author davem;	state Exp;
branches;
next	1.18;

1.18
date	2011.08.05.16.52.49;	author davem;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.27.04.07.55;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.25.19.58.03;	author davem;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.25.01.33.24;	author davem;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.07.19.27.51;	author wilson;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.01.11.16.33;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.07.07.34.31;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.15.13.36.28;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.29.12.51.57;	author nickc;	state Exp;
branches
	1.8.46.1
	1.8.48.1
	1.8.52.1;
next	1.7;

1.7
date	2002.06.08.07.29.27;	author amodra;	state Exp;
branches
	1.7.12.1
	1.7.14.1;
next	1.6;

1.6
date	2002.02.11.13.24.51;	author aoliva;	state Exp;
branches
	1.6.6.1
	1.6.8.1;
next	1.5;

1.5
date	2001.03.13.22.58.37;	author nickc;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2000.10.20.10.38.47;	author jakub;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.07.08.16.14.07;	author rth;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.8.46.1
date	2004.03.15.13.37.51;	author amodra;	state Exp;
branches;
next	;

1.8.48.1
date	2004.03.27.17.38.13;	author drow;	state Exp;
branches;
next	;

1.8.52.1
date	2004.03.21.23.57.44;	author cagney;	state Exp;
branches;
next	;

1.7.12.1
date	2003.02.07.19.18.04;	author carlton;	state Exp;
branches;
next	;

1.7.14.1
date	2003.12.14.20.28.10;	author drow;	state Exp;
branches;
next	;

1.6.6.1
date	2002.06.15.16.43.20;	author cagney;	state Exp;
branches;
next	;

1.6.8.1
date	2002.06.20.01.38.30;	author kseitz;	state Exp;
branches;
next	;

1.5.8.1
date	2002.02.11.13.10.30;	author aoliva;	state Exp;
branches;
next	;

1.4.2.1
date	2001.06.07.03.18.36;	author amodra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches;
next	;


desc
@@


1.26
log
@gas/
	* config/tc-sparc.c (sparc_arch_types): Add leon.
	(sparc_arch): Move sparc4 around and add leon.
	(sparc_target_format): Document -Aleon.
	* doc/c-sparc.texi: Likewise.
include/
	* opcode/sparc.h (sparc_opcode_arch_val): Add SPARC_OPCODE_ARCH_LEON.
opcodes/
	* sparc-dis.c (compute_arch_mask): Set SPARC_OPCODE_ARCH_LEON bit for
	bfd_mach_sparc.
	* sparc-opc.c (MASK_LEON): Define.
	(v6, v6notlet, v7, v8, v6notv9): Add MASK_LEON.
	(letandleon): New macro.
	(v9andleon): Likewise.
	(sparc_opc): Add leon.
	(umac): Enable for letandleon.
	(smac): Likewise.
	(casa): Enable for v9andleon.
	(cas): Likewise.
	(casl): Likewise.
@
text
@/* Print SPARC instructions.
   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2012
   Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdio.h>
#include "opcode/sparc.h"
#include "dis-asm.h"
#include "libiberty.h"
#include "opintl.h"

/* Bitmask of v9 architectures.  */
#define MASK_V9 ((1 << SPARC_OPCODE_ARCH_V9) \
		 | (1 << SPARC_OPCODE_ARCH_V9A) \
		 | (1 << SPARC_OPCODE_ARCH_V9B))
/* 1 if INSN is for v9 only.  */
#define V9_ONLY_P(insn) (! ((insn)->architecture & ~MASK_V9))
/* 1 if INSN is for v9.  */
#define V9_P(insn) (((insn)->architecture & MASK_V9) != 0)

/* The sorted opcode table.  */
static const sparc_opcode **sorted_opcodes;

/* For faster lookup, after insns are sorted they are hashed.  */
/* ??? I think there is room for even more improvement.  */

#define HASH_SIZE 256
/* It is important that we only look at insn code bits as that is how the
   opcode table is hashed.  OPCODE_BITS is a table of valid bits for each
   of the main types (0,1,2,3).  */
static int opcode_bits[4] = { 0x01c00000, 0x0, 0x01f80000, 0x01f80000 };
#define HASH_INSN(INSN) \
  ((((INSN) >> 24) & 0xc0) | (((INSN) & opcode_bits[((INSN) >> 30) & 3]) >> 19))
typedef struct sparc_opcode_hash
{
  struct sparc_opcode_hash *next;
  const sparc_opcode *opcode;
} sparc_opcode_hash;

static sparc_opcode_hash *opcode_hash_table[HASH_SIZE];

/* Sign-extend a value which is N bits long.  */
#define	SEX(value, bits) \
	((((int)(value)) << ((8 * sizeof (int)) - bits))	\
			 >> ((8 * sizeof (int)) - bits) )

static  char *reg_names[] =
{ "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",
  "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",
  "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",
  "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23",
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",
  "f32", "f33", "f34", "f35", "f36", "f37", "f38", "f39",
  "f40", "f41", "f42", "f43", "f44", "f45", "f46", "f47",
  "f48", "f49", "f50", "f51", "f52", "f53", "f54", "f55",
  "f56", "f57", "f58", "f59", "f60", "f61", "f62", "f63",
/* psr, wim, tbr, fpsr, cpsr are v8 only.  */
  "y", "psr", "wim", "tbr", "pc", "npc", "fpsr", "cpsr"
};

#define	freg_names	(&reg_names[4 * 8])

/* These are ordered according to there register number in
   rdpr and wrpr insns.  */
static char *v9_priv_reg_names[] =
{
  "tpc", "tnpc", "tstate", "tt", "tick", "tba", "pstate", "tl",
  "pil", "cwp", "cansave", "canrestore", "cleanwin", "otherwin",
  "wstate", "fq", "gl"
  /* "ver" - special cased */
};

/* These are ordered according to there register number in
   rdhpr and wrhpr insns.  */
static char *v9_hpriv_reg_names[] =
{
  "hpstate", "htstate", "resv2", "hintp", "resv4", "htba", "hver",
  "resv7", "resv8", "resv9", "resv10", "resv11", "resv12", "resv13", 
  "resv14", "resv15", "resv16", "resv17", "resv18", "resv19", "resv20",
  "resv21", "resv22", "resv23", "resv24", "resv25", "resv26", "resv27",
  "resv28", "resv29", "resv30", "hstick_cmpr"
};

/* These are ordered according to there register number in
   rd and wr insns (-16).  */
static char *v9a_asr_reg_names[] =
{
  "pcr", "pic", "dcr", "gsr", "set_softint", "clear_softint",
  "softint", "tick_cmpr", "stick", "stick_cmpr", "cfr",
  "pause", "cps"
};

/* Macros used to extract instruction fields.  Not all fields have
   macros defined here, only those which are actually used.  */

#define X_RD(i)      (((i) >> 25) & 0x1f)
#define X_RS1(i)     (((i) >> 14) & 0x1f)
#define X_LDST_I(i)  (((i) >> 13) & 1)
#define X_ASI(i)     (((i) >> 5) & 0xff)
#define X_RS2(i)     (((i) >> 0) & 0x1f)
#define X_RS3(i)     (((i) >> 9) & 0x1f)
#define X_IMM(i,n)   (((i) >> 0) & ((1 << (n)) - 1))
#define X_SIMM(i,n)  SEX (X_IMM ((i), (n)), (n))
#define X_DISP22(i)  (((i) >> 0) & 0x3fffff)
#define X_IMM22(i)   X_DISP22 (i)
#define X_DISP30(i)  (((i) >> 0) & 0x3fffffff)

/* These are for v9.  */
#define X_DISP16(i)  (((((i) >> 20) & 3) << 14) | (((i) >> 0) & 0x3fff))
#define X_DISP10(i)  (((((i) >> 19) & 3) << 8) | (((i) >> 5) & 0xff))
#define X_DISP19(i)  (((i) >> 0) & 0x7ffff)
#define X_MEMBAR(i)  ((i) & 0x7f)

/* Here is the union which was used to extract instruction fields
   before the shift and mask macros were written.

   union sparc_insn
     {
       unsigned long int code;
       struct
	 {
	   unsigned int anop:2;
	   #define	op	ldst.anop
	   unsigned int anrd:5;
	   #define	rd	ldst.anrd
	   unsigned int op3:6;
	   unsigned int anrs1:5;
	   #define	rs1	ldst.anrs1
	   unsigned int i:1;
	   unsigned int anasi:8;
	   #define	asi	ldst.anasi
	   unsigned int anrs2:5;
	   #define	rs2	ldst.anrs2
	   #define	shcnt	rs2
	 } ldst;
       struct
	 {
	   unsigned int anop:2, anrd:5, op3:6, anrs1:5, i:1;
	   unsigned int IMM13:13;
	   #define	imm13	IMM13.IMM13
	 } IMM13;
       struct
	 {
	   unsigned int anop:2;
	   unsigned int a:1;
	   unsigned int cond:4;
	   unsigned int op2:3;
	   unsigned int DISP22:22;
	   #define	disp22	branch.DISP22
	   #define	imm22	disp22
	 } branch;
       struct
	 {
	   unsigned int anop:2;
	   unsigned int a:1;
	   unsigned int z:1;
	   unsigned int rcond:3;
	   unsigned int op2:3;
	   unsigned int DISP16HI:2;
	   unsigned int p:1;
	   unsigned int _rs1:5;
	   unsigned int DISP16LO:14;
	 } branch16;
       struct
	 {
	   unsigned int anop:2;
	   unsigned int adisp30:30;
	   #define	disp30	call.adisp30
	 } call;
     };  */

/* Nonzero if INSN is the opcode for a delayed branch.  */

static int
is_delayed_branch (unsigned long insn)
{
  sparc_opcode_hash *op;

  for (op = opcode_hash_table[HASH_INSN (insn)]; op; op = op->next)
    {
      const sparc_opcode *opcode = op->opcode;

      if ((opcode->match & insn) == opcode->match
	  && (opcode->lose & insn) == 0)
	return opcode->flags & F_DELAYED;
    }
  return 0;
}

/* extern void qsort (); */

/* Records current mask of SPARC_OPCODE_ARCH_FOO values, used to pass value
   to compare_opcodes.  */
static unsigned int current_arch_mask;

/* Given BFD mach number, return a mask of SPARC_OPCODE_ARCH_FOO values.  */

static int
compute_arch_mask (unsigned long mach)
{
  switch (mach)
    {
    case 0 :
    case bfd_mach_sparc :
      return (SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V8)
              | SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_LEON));
    case bfd_mach_sparc_sparclet :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_SPARCLET);
    case bfd_mach_sparc_sparclite :
    case bfd_mach_sparc_sparclite_le :
      /* sparclites insns are recognized by default (because that's how
	 they've always been treated, for better or worse).  Kludge this by
	 indicating generic v8 is also selected.  */
      return (SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_SPARCLITE)
	      | SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V8));
    case bfd_mach_sparc_v8plus :
    case bfd_mach_sparc_v9 :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9);
    case bfd_mach_sparc_v8plusa :
    case bfd_mach_sparc_v9a :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9A);
    case bfd_mach_sparc_v8plusb :
    case bfd_mach_sparc_v9b :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9B);
    }
  abort ();
}

/* Compare opcodes A and B.  */

static int
compare_opcodes (const void * a, const void * b)
{
  sparc_opcode *op0 = * (sparc_opcode **) a;
  sparc_opcode *op1 = * (sparc_opcode **) b;
  unsigned long int match0 = op0->match, match1 = op1->match;
  unsigned long int lose0 = op0->lose, lose1 = op1->lose;
  register unsigned int i;

  /* If one (and only one) insn isn't supported by the current architecture,
     prefer the one that is.  If neither are supported, but they're both for
     the same architecture, continue processing.  Otherwise (both unsupported
     and for different architectures), prefer lower numbered arch's (fudged
     by comparing the bitmasks).  */
  if (op0->architecture & current_arch_mask)
    {
      if (! (op1->architecture & current_arch_mask))
	return -1;
    }
  else
    {
      if (op1->architecture & current_arch_mask)
	return 1;
      else if (op0->architecture != op1->architecture)
	return op0->architecture - op1->architecture;
    }

  /* If a bit is set in both match and lose, there is something
     wrong with the opcode table.  */
  if (match0 & lose0)
    {
      fprintf
	(stderr,
	 /* xgettext:c-format */
	 _("Internal error:  bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n"),
	 op0->name, match0, lose0);
      op0->lose &= ~op0->match;
      lose0 = op0->lose;
    }

  if (match1 & lose1)
    {
      fprintf
	(stderr,
	 /* xgettext:c-format */
	 _("Internal error: bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n"),
	 op1->name, match1, lose1);
      op1->lose &= ~op1->match;
      lose1 = op1->lose;
    }

  /* Because the bits that are variable in one opcode are constant in
     another, it is important to order the opcodes in the right order.  */
  for (i = 0; i < 32; ++i)
    {
      unsigned long int x = 1 << i;
      int x0 = (match0 & x) != 0;
      int x1 = (match1 & x) != 0;

      if (x0 != x1)
	return x1 - x0;
    }

  for (i = 0; i < 32; ++i)
    {
      unsigned long int x = 1 << i;
      int x0 = (lose0 & x) != 0;
      int x1 = (lose1 & x) != 0;

      if (x0 != x1)
	return x1 - x0;
    }

  /* They are functionally equal.  So as long as the opcode table is
     valid, we can put whichever one first we want, on aesthetic grounds.  */

  /* Our first aesthetic ground is that aliases defer to real insns.  */
  {
    int alias_diff = (op0->flags & F_ALIAS) - (op1->flags & F_ALIAS);

    if (alias_diff != 0)
      /* Put the one that isn't an alias first.  */
      return alias_diff;
  }

  /* Except for aliases, two "identical" instructions had
     better have the same opcode.  This is a sanity check on the table.  */
  i = strcmp (op0->name, op1->name);
  if (i)
    {
      if (op0->flags & F_ALIAS)
	{
	  if (op0->flags & F_PREFERRED)
	    return -1;
	  if (op1->flags & F_PREFERRED)
	    return 1;

	  /* If they're both aliases, and neither is marked as preferred,
	     be arbitrary.  */
	  return i;
	}
      else
	fprintf (stderr,
		 /* xgettext:c-format */
		 _("Internal error: bad sparc-opcode.h: \"%s\" == \"%s\"\n"),
		 op0->name, op1->name);
    }

  /* Fewer arguments are preferred.  */
  {
    int length_diff = strlen (op0->args) - strlen (op1->args);

    if (length_diff != 0)
      /* Put the one with fewer arguments first.  */
      return length_diff;
  }

  /* Put 1+i before i+1.  */
  {
    char *p0 = (char *) strchr (op0->args, '+');
    char *p1 = (char *) strchr (op1->args, '+');

    if (p0 && p1)
      {
	/* There is a plus in both operands.  Note that a plus
	   sign cannot be the first character in args,
	   so the following [-1]'s are valid.  */
	if (p0[-1] == 'i' && p1[1] == 'i')
	  /* op0 is i+1 and op1 is 1+i, so op1 goes first.  */
	  return 1;
	if (p0[1] == 'i' && p1[-1] == 'i')
	  /* op0 is 1+i and op1 is i+1, so op0 goes first.  */
	  return -1;
      }
  }

  /* Put 1,i before i,1.  */
  {
    int i0 = strncmp (op0->args, "i,1", 3) == 0;
    int i1 = strncmp (op1->args, "i,1", 3) == 0;

    if (i0 ^ i1)
      return i0 - i1;
  }

  /* They are, as far as we can tell, identical.
     Since qsort may have rearranged the table partially, there is
     no way to tell which one was first in the opcode table as
     written, so just say there are equal.  */
  /* ??? This is no longer true now that we sort a vector of pointers,
     not the table itself.  */
  return 0;
}

/* Build a hash table from the opcode table.
   OPCODE_TABLE is a sorted list of pointers into the opcode table.  */

static void
build_hash_table (const sparc_opcode **opcode_table,
		  sparc_opcode_hash **hash_table,
		  int num_opcodes)
{
  int i;
  int hash_count[HASH_SIZE];
  static sparc_opcode_hash *hash_buf = NULL;

  /* Start at the end of the table and work backwards so that each
     chain is sorted.  */

  memset (hash_table, 0, HASH_SIZE * sizeof (hash_table[0]));
  memset (hash_count, 0, HASH_SIZE * sizeof (hash_count[0]));
  if (hash_buf != NULL)
    free (hash_buf);
  hash_buf = xmalloc (sizeof (* hash_buf) * num_opcodes);
  for (i = num_opcodes - 1; i >= 0; --i)
    {
      int hash = HASH_INSN (opcode_table[i]->match);
      sparc_opcode_hash *h = &hash_buf[i];

      h->next = hash_table[hash];
      h->opcode = opcode_table[i];
      hash_table[hash] = h;
      ++hash_count[hash];
    }

#if 0 /* for debugging */
  {
    int min_count = num_opcodes, max_count = 0;
    int total;

    for (i = 0; i < HASH_SIZE; ++i)
      {
        if (hash_count[i] < min_count)
	  min_count = hash_count[i];
	if (hash_count[i] > max_count)
	  max_count = hash_count[i];
	total += hash_count[i];
      }

    printf ("Opcode hash table stats: min %d, max %d, ave %f\n",
	    min_count, max_count, (double) total / HASH_SIZE);
  }
#endif
}

/* Print one instruction from MEMADDR on INFO->STREAM.

   We suffix the instruction with a comment that gives the absolute
   address involved, as well as its symbolic form, if the instruction
   is preceded by a findable `sethi' and it either adds an immediate
   displacement to that register, or it is an `add' or `or' instruction
   on that register.  */

int
print_insn_sparc (bfd_vma memaddr, disassemble_info *info)
{
  FILE *stream = info->stream;
  bfd_byte buffer[4];
  unsigned long insn;
  sparc_opcode_hash *op;
  /* Nonzero of opcode table has been initialized.  */
  static int opcodes_initialized = 0;
  /* bfd mach number of last call.  */
  static unsigned long current_mach = 0;
  bfd_vma (*getword) (const void *);

  if (!opcodes_initialized
      || info->mach != current_mach)
    {
      int i;

      current_arch_mask = compute_arch_mask (info->mach);

      if (!opcodes_initialized)
	sorted_opcodes =
	  xmalloc (sparc_num_opcodes * sizeof (sparc_opcode *));
      /* Reset the sorted table so we can resort it.  */
      for (i = 0; i < sparc_num_opcodes; ++i)
	sorted_opcodes[i] = &sparc_opcodes[i];
      qsort ((char *) sorted_opcodes, sparc_num_opcodes,
	     sizeof (sorted_opcodes[0]), compare_opcodes);

      build_hash_table (sorted_opcodes, opcode_hash_table, sparc_num_opcodes);
      current_mach = info->mach;
      opcodes_initialized = 1;
    }

  {
    int status =
      (*info->read_memory_func) (memaddr, buffer, sizeof (buffer), info);

    if (status != 0)
      {
	(*info->memory_error_func) (status, memaddr, info);
	return -1;
      }
  }

  /* On SPARClite variants such as DANlite (sparc86x), instructions
     are always big-endian even when the machine is in little-endian mode.  */
  if (info->endian == BFD_ENDIAN_BIG || info->mach == bfd_mach_sparc_sparclite)
    getword = bfd_getb32;
  else
    getword = bfd_getl32;

  insn = getword (buffer);

  info->insn_info_valid = 1;			/* We do return this info.  */
  info->insn_type = dis_nonbranch;		/* Assume non branch insn.  */
  info->branch_delay_insns = 0;			/* Assume no delay.  */
  info->target = 0;				/* Assume no target known.  */

  for (op = opcode_hash_table[HASH_INSN (insn)]; op; op = op->next)
    {
      const sparc_opcode *opcode = op->opcode;

      /* If the insn isn't supported by the current architecture, skip it.  */
      if (! (opcode->architecture & current_arch_mask))
	continue;

      if ((opcode->match & insn) == opcode->match
	  && (opcode->lose & insn) == 0)
	{
	  /* Nonzero means that we have found an instruction which has
	     the effect of adding or or'ing the imm13 field to rs1.  */
	  int imm_added_to_rs1 = 0;
	  int imm_ored_to_rs1 = 0;

	  /* Nonzero means that we have found a plus sign in the args
	     field of the opcode table.  */
	  int found_plus = 0;

	  /* Nonzero means we have an annulled branch.  */
	  int is_annulled = 0;

	  /* Do we have an `add' or `or' instruction combining an
             immediate with rs1?  */
	  if (opcode->match == 0x80102000) /* or */
	    imm_ored_to_rs1 = 1;
	  if (opcode->match == 0x80002000) /* add */
	    imm_added_to_rs1 = 1;

	  if (X_RS1 (insn) != X_RD (insn)
	      && strchr (opcode->args, 'r') != 0)
	      /* Can't do simple format if source and dest are different.  */
	      continue;
	  if (X_RS2 (insn) != X_RD (insn)
	      && strchr (opcode->args, 'O') != 0)
	      /* Can't do simple format if source and dest are different.  */
	      continue;

	  (*info->fprintf_func) (stream, "%s", opcode->name);

	  {
	    const char *s;

	    if (opcode->args[0] != ',')
	      (*info->fprintf_func) (stream, " ");

	    for (s = opcode->args; *s != '\0'; ++s)
	      {
		while (*s == ',')
		  {
		    (*info->fprintf_func) (stream, ",");
		    ++s;
		    switch (*s)
		      {
		      case 'a':
			(*info->fprintf_func) (stream, "a");
			is_annulled = 1;
			++s;
			continue;
		      case 'N':
			(*info->fprintf_func) (stream, "pn");
			++s;
			continue;

		      case 'T':
			(*info->fprintf_func) (stream, "pt");
			++s;
			continue;

		      default:
			break;
		      }
		  }

		(*info->fprintf_func) (stream, " ");

		switch (*s)
		  {
		  case '+':
		    found_plus = 1;
		    /* Fall through.  */

		  default:
		    (*info->fprintf_func) (stream, "%c", *s);
		    break;

		  case '#':
		    (*info->fprintf_func) (stream, "0");
		    break;

#define	reg(n)	(*info->fprintf_func) (stream, "%%%s", reg_names[n])
		  case '1':
		  case 'r':
		    reg (X_RS1 (insn));
		    break;

		  case '2':
		  case 'O':
		    reg (X_RS2 (insn));
		    break;

		  case 'd':
		    reg (X_RD (insn));
		    break;
#undef	reg

#define	freg(n)		(*info->fprintf_func) (stream, "%%%s", freg_names[n])
#define	fregx(n)	(*info->fprintf_func) (stream, "%%%s", freg_names[((n) & ~1) | (((n) & 1) << 5)])
		  case 'e':
		    freg (X_RS1 (insn));
		    break;
		  case 'v':	/* Double/even.  */
		  case 'V':	/* Quad/multiple of 4.  */
		    fregx (X_RS1 (insn));
		    break;

		  case 'f':
		    freg (X_RS2 (insn));
		    break;
		  case 'B':	/* Double/even.  */
		  case 'R':	/* Quad/multiple of 4.  */
		    fregx (X_RS2 (insn));
		    break;

		  case '4':
		    freg (X_RS3 (insn));
		    break;
		  case '5':	/* Double/even.  */
		    fregx (X_RS3 (insn));
		    break;

		  case 'g':
		    freg (X_RD (insn));
		    break;
		  case 'H':	/* Double/even.  */
		  case 'J':	/* Quad/multiple of 4.  */
		    fregx (X_RD (insn));
		    break;
#undef	freg
#undef	fregx

#define	creg(n)	(*info->fprintf_func) (stream, "%%c%u", (unsigned int) (n))
		  case 'b':
		    creg (X_RS1 (insn));
		    break;

		  case 'c':
		    creg (X_RS2 (insn));
		    break;

		  case 'D':
		    creg (X_RD (insn));
		    break;
#undef	creg

		  case 'h':
		    (*info->fprintf_func) (stream, "%%hi(%#x)",
					   ((unsigned) 0xFFFFFFFF
					    & ((int) X_IMM22 (insn) << 10)));
		    break;

		  case 'i':	/* 13 bit immediate.  */
		  case 'I':	/* 11 bit immediate.  */
		  case 'j':	/* 10 bit immediate.  */
		    {
		      int imm;

		      if (*s == 'i')
		        imm = X_SIMM (insn, 13);
		      else if (*s == 'I')
			imm = X_SIMM (insn, 11);
		      else
			imm = X_SIMM (insn, 10);

		      /* Check to see whether we have a 1+i, and take
			 note of that fact.

			 Note: because of the way we sort the table,
			 we will be matching 1+i rather than i+1,
			 so it is OK to assume that i is after +,
			 not before it.  */
		      if (found_plus)
			imm_added_to_rs1 = 1;

		      if (imm <= 9)
			(*info->fprintf_func) (stream, "%d", imm);
		      else
			(*info->fprintf_func) (stream, "%#x", imm);
		    }
		    break;

		  case ')':	/* 5 bit unsigned immediate from RS3.  */
		    (info->fprintf_func) (stream, "%#x", (unsigned int) X_RS3 (insn));
		    break;

		  case 'X':	/* 5 bit unsigned immediate.  */
		  case 'Y':	/* 6 bit unsigned immediate.  */
		    {
		      int imm = X_IMM (insn, *s == 'X' ? 5 : 6);

		      if (imm <= 9)
			(info->fprintf_func) (stream, "%d", imm);
		      else
			(info->fprintf_func) (stream, "%#x", (unsigned) imm);
		    }
		    break;

		  case '3':
		    (info->fprintf_func) (stream, "%ld", X_IMM (insn, 3));
		    break;

		  case 'K':
		    {
		      int mask = X_MEMBAR (insn);
		      int bit = 0x40, printed_one = 0;
		      const char *name;

		      if (mask == 0)
			(info->fprintf_func) (stream, "0");
		      else
			while (bit)
			  {
			    if (mask & bit)
			      {
				if (printed_one)
				  (info->fprintf_func) (stream, "|");
				name = sparc_decode_membar (bit);
				(info->fprintf_func) (stream, "%s", name);
				printed_one = 1;
			      }
			    bit >>= 1;
			  }
		      break;
		    }

		  case '=':
		    info->target = memaddr + SEX (X_DISP10 (insn), 10) * 4;
		    (*info->print_address_func) (info->target, info);
		    break;

		  case 'k':
		    info->target = memaddr + SEX (X_DISP16 (insn), 16) * 4;
		    (*info->print_address_func) (info->target, info);
		    break;

		  case 'G':
		    info->target = memaddr + SEX (X_DISP19 (insn), 19) * 4;
		    (*info->print_address_func) (info->target, info);
		    break;

		  case '6':
		  case '7':
		  case '8':
		  case '9':
		    (*info->fprintf_func) (stream, "%%fcc%c", *s - '6' + '0');
		    break;

		  case 'z':
		    (*info->fprintf_func) (stream, "%%icc");
		    break;

		  case 'Z':
		    (*info->fprintf_func) (stream, "%%xcc");
		    break;

		  case 'E':
		    (*info->fprintf_func) (stream, "%%ccr");
		    break;

		  case 's':
		    (*info->fprintf_func) (stream, "%%fprs");
		    break;

		  case 'o':
		    (*info->fprintf_func) (stream, "%%asi");
		    break;

		  case 'W':
		    (*info->fprintf_func) (stream, "%%tick");
		    break;

		  case 'P':
		    (*info->fprintf_func) (stream, "%%pc");
		    break;

		  case '?':
		    if (X_RS1 (insn) == 31)
		      (*info->fprintf_func) (stream, "%%ver");
		    else if ((unsigned) X_RS1 (insn) < 17)
		      (*info->fprintf_func) (stream, "%%%s",
					     v9_priv_reg_names[X_RS1 (insn)]);
		    else
		      (*info->fprintf_func) (stream, "%%reserved");
		    break;

		  case '!':
		    if ((unsigned) X_RD (insn) < 17)
		      (*info->fprintf_func) (stream, "%%%s",
					     v9_priv_reg_names[X_RD (insn)]);
		    else
		      (*info->fprintf_func) (stream, "%%reserved");
		    break;

		  case '$':
		    if ((unsigned) X_RS1 (insn) < 32)
		      (*info->fprintf_func) (stream, "%%%s",
					     v9_hpriv_reg_names[X_RS1 (insn)]);
		    else
		      (*info->fprintf_func) (stream, "%%reserved");
		    break;

		  case '%':
		    if ((unsigned) X_RD (insn) < 32)
		      (*info->fprintf_func) (stream, "%%%s",
					     v9_hpriv_reg_names[X_RD (insn)]);
		    else
		      (*info->fprintf_func) (stream, "%%reserved");
		    break;

		  case '/':
		    if (X_RS1 (insn) < 16 || X_RS1 (insn) > 28)
		      (*info->fprintf_func) (stream, "%%reserved");
		    else
		      (*info->fprintf_func) (stream, "%%%s",
					     v9a_asr_reg_names[X_RS1 (insn)-16]);
		    break;

		  case '_':
		    if (X_RD (insn) < 16 || X_RD (insn) > 28)
		      (*info->fprintf_func) (stream, "%%reserved");
		    else
		      (*info->fprintf_func) (stream, "%%%s",
					     v9a_asr_reg_names[X_RD (insn)-16]);
		    break;

		  case '*':
		    {
		      const char *name = sparc_decode_prefetch (X_RD (insn));

		      if (name)
			(*info->fprintf_func) (stream, "%s", name);
		      else
			(*info->fprintf_func) (stream, "%ld", X_RD (insn));
		      break;
		    }

		  case 'M':
		    (*info->fprintf_func) (stream, "%%asr%ld", X_RS1 (insn));
		    break;

		  case 'm':
		    (*info->fprintf_func) (stream, "%%asr%ld", X_RD (insn));
		    break;

		  case 'L':
		    info->target = memaddr + SEX (X_DISP30 (insn), 30) * 4;
		    (*info->print_address_func) (info->target, info);
		    break;

		  case 'n':
		    (*info->fprintf_func)
		      (stream, "%#x", SEX (X_DISP22 (insn), 22));
		    break;

		  case 'l':
		    info->target = memaddr + SEX (X_DISP22 (insn), 22) * 4;
		    (*info->print_address_func) (info->target, info);
		    break;

		  case 'A':
		    {
		      const char *name = sparc_decode_asi (X_ASI (insn));

		      if (name)
			(*info->fprintf_func) (stream, "%s", name);
		      else
			(*info->fprintf_func) (stream, "(%ld)", X_ASI (insn));
		      break;
		    }

		  case 'C':
		    (*info->fprintf_func) (stream, "%%csr");
		    break;

		  case 'F':
		    (*info->fprintf_func) (stream, "%%fsr");
		    break;

		  case '(':
		    (*info->fprintf_func) (stream, "%%efsr");
		    break;

		  case 'p':
		    (*info->fprintf_func) (stream, "%%psr");
		    break;

		  case 'q':
		    (*info->fprintf_func) (stream, "%%fq");
		    break;

		  case 'Q':
		    (*info->fprintf_func) (stream, "%%cq");
		    break;

		  case 't':
		    (*info->fprintf_func) (stream, "%%tbr");
		    break;

		  case 'w':
		    (*info->fprintf_func) (stream, "%%wim");
		    break;

		  case 'x':
		    (*info->fprintf_func) (stream, "%ld",
					   ((X_LDST_I (insn) << 8)
					    + X_ASI (insn)));
		    break;

		  case 'y':
		    (*info->fprintf_func) (stream, "%%y");
		    break;

		  case 'u':
		  case 'U':
		    {
		      int val = *s == 'U' ? X_RS1 (insn) : X_RD (insn);
		      const char *name = sparc_decode_sparclet_cpreg (val);

		      if (name)
			(*info->fprintf_func) (stream, "%s", name);
		      else
			(*info->fprintf_func) (stream, "%%cpreg(%d)", val);
		      break;
		    }
		  }
	      }
	  }

	  /* If we are adding or or'ing something to rs1, then
	     check to see whether the previous instruction was
	     a sethi to the same register as in the sethi.
	     If so, attempt to print the result of the add or
	     or (in this context add and or do the same thing)
	     and its symbolic value.  */
	  if (imm_ored_to_rs1 || imm_added_to_rs1)
	    {
	      unsigned long prev_insn;
	      int errcode;

	      if (memaddr >= 4)
		errcode =
		  (*info->read_memory_func)
		  (memaddr - 4, buffer, sizeof (buffer), info);
	      else
		errcode = 1;

	      prev_insn = getword (buffer);

	      if (errcode == 0)
		{
		  /* If it is a delayed branch, we need to look at the
		     instruction before the delayed branch.  This handles
		     sequences such as:

		     sethi %o1, %hi(_foo), %o1
		     call _printf
		     or %o1, %lo(_foo), %o1  */

		  if (is_delayed_branch (prev_insn))
		    {
		      if (memaddr >= 8)
			errcode = (*info->read_memory_func)
			  (memaddr - 8, buffer, sizeof (buffer), info);
		      else
			errcode = 1;

		      prev_insn = getword (buffer);
		    }
		}

	      /* If there was a problem reading memory, then assume
		 the previous instruction was not sethi.  */
	      if (errcode == 0)
		{
		  /* Is it sethi to the same register?  */
		  if ((prev_insn & 0xc1c00000) == 0x01000000
		      && X_RD (prev_insn) == X_RS1 (insn))
		    {
		      (*info->fprintf_func) (stream, "\t! ");
		      info->target =
			((unsigned) 0xFFFFFFFF
			 & ((int) X_IMM22 (prev_insn) << 10));
		      if (imm_added_to_rs1)
			info->target += X_SIMM (insn, 13);
		      else
			info->target |= X_SIMM (insn, 13);
		      (*info->print_address_func) (info->target, info);
		      info->insn_type = dis_dref;
		      info->data_size = 4;  /* FIXME!!! */
		    }
		}
	    }

	  if (opcode->flags & (F_UNBR|F_CONDBR|F_JSR))
	    {
	      /* FIXME -- check is_annulled flag.  */
	      (void) is_annulled;
	      if (opcode->flags & F_UNBR)
		info->insn_type = dis_branch;
	      if (opcode->flags & F_CONDBR)
		info->insn_type = dis_condbranch;
	      if (opcode->flags & F_JSR)
		info->insn_type = dis_jsr;
	      if (opcode->flags & F_DELAYED)
		info->branch_delay_insns = 1;
	    }

	  return sizeof (buffer);
	}
    }

  info->insn_type = dis_noninsn;	/* Mark as non-valid instruction.  */
  (*info->fprintf_func) (stream, _("unknown"));
  return sizeof (buffer);
}
@


1.25
log
@Increase the accuracy of sparc instruction aliases.

Make current with UA2011 specification.

Add an F_PREFERRED opcode flag that indicates a preferred alias
when multiple aliases for the same opcode exists.

For 'lzd':

	Add 'lzcnt' as primary instruction, and make 'lzd' an alias.

Add 'ldtw', 'ldtwa', 'sttw', 'sttwa':

	The modern opcode for for 'ldd', 'ldda', 'std', and 'stda' on
	integer registers.  Mark the latter now as aliases.

For 'flush':

	Support "[address]" syntax as well as plain "address".

Rework 'mov' aliases for 'wr':

	Eliminate bogus three operand moves, and encode the
	instructions properly for the "mov REG, %ASR" cases,
	specifically we should encode the register in rs2 not rs1 as
	per The SPARC V8 Architecture Manual.

Add missing cbcond aliases:

	c{w,x}bz, c{w,x}blu, c{w,x}bnz, c{w,x}bgeu

Add 'd' suffix VIS logical ops:

	The primary opcode for 'fzero' is now 'fzerod' (compare with
	'fzeros'), for example.  And thus 'fzero' is now an alias.

Add modern opcodes for condition code setting edge instructions:

	They are now edgeN{,l}cc instead of plain edgeN{,l}.

Add modern opcodes for VIS comparisons:

	All VIS comparisons now start with prefix "fp", retain the
	older variants as aliases.

	The signed variants for equal and not-equal have "u" aliases
	to show that these comparisons are equally suited for unsigned
	compares.

Update existing test cases as needed, and add several new ones.

include/opcode/

	* sparc.h (F_PREFERRED): Define.
	(F_PREF_ALIAS): Define.

opcodes/

	* sparc-dis.c (compare_opcodes): When encountering multiple aliases
	of an opcode, prefer the one with F_PREFERRED set.
	* sparc-opc.c (sparc_opcodes): Add ldtw, ldtwa, sttw, sttwa,
	lzcnt, flush with '[address]' syntax, and missing cbcond pseudo
	ops.  Make 64-bit VIS logical ops have "d" suffix in their names,
	mark existing mnenomics as aliases.  Add "cc" suffix to edge
	instructions generating condition codes, mark existing mnenomics
	as aliases.  Add "fp" prefix to VIS compare instructions, mark
	existing mnenomics as aliases.

gas/testsuite/

	* gas/sparc/cbcond.s: Add tests for new opcode aliases.
	* gas/sparc/cbcond.d: Updated.
	* gas/sparc/hpcvis3.s: Add tests for new opcode aliases.
	* gas/sparc/hpcvis3.d: Updated.
	* gas/sparc/v8-movwr-imm.d: Fix expected disassembly.
	* gas/sparc/edge.s: New test.
	* gas/sparc/edge.d: Expected disassembly.
	* gas/sparc/flush.s: New test.
	* gas/sparc/flush.d: Expected disassembly.
	* gas/sparc/ldd_std.s: New test.
	* gas/sparc/ldd_std.d: Expected disassembly.
	* gas/sparc/ldtw_sttw.s: New test.
	* gas/sparc/ldtw_sttw.d: Expected disassembly.
	* gas/sparc/sparc.exp: Run new tests.
@
text
@d226 2
a227 1
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V8);
@


1.24
log
@	PR binutils/13135
	* arm-dis.c: Add necessary casts for printing integer values.
	Use %s when printing string values.
	* hppa-dis.c: Likewise.
	* m68k-dis.c: Likewise.
	* microblaze-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* sparc-dis.c: Likewise.

	* dis-asm.h (fprintf_ftype): Add ATTRIBUTE_FPTR_PRINTF_2.
@
text
@d341 11
a351 2
      if (op0->flags & F_ALIAS) /* If they're both aliases, be arbitrary.  */
	return i;
@


1.23
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d553 1
a553 1
	  (*info->fprintf_func) (stream, opcode->name);
d707 1
a707 1
		    (info->fprintf_func) (stream, "%#x", X_RS3 (insn));
@


1.22
log
@Add support for sparc %cfr ASR register.

opcodes/

	* sparc-dis.c (v9a_asr_reg_names): Add 'cfr'.
	* sparc-opc.c (sparc_opcodes): Add rd/wr cases for %cfr.

gas/

	* config/tc-sparc.c (v9a_asr_table): Add 'cfr'.

gas/testsuite/

	* gas/sparc/sparc.exp: Run cfr test.
	* gas/sparc/cfr.s: New testcase.
	* gas/sparc/cfr.d: Likewise.
@
text
@d3 1
a3 1
   2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010
d23 1
a24 2

#include "sysdep.h"
@


1.21
log
@Add support for sparc pause instruction.

opcodes/

	* sparc-opc.c (sparc_opcodes): Add 'wr X, %pause' and 'pause'.
	* sparc-dis.c (v9a_asr_reg_names): Add 'pause'.

gas/

	* config/tc-sparc.c (sparc_arch_table): Add HWCAP_PAUSE to sparc4,
	v8pluse, v8plusv, v9e, and v9v.
	(v9a_asr_table): Add 'pause'.

gas/testsuite/

	* gas/sparc/sparc.exp: Run pause test.
	* gas/sparc/pause.s: New testcase.
	* gas/sparc/pause.d: Likewise.
@
text
@d111 1
a111 1
  "softint", "tick_cmpr", "stick", "stick_cmpr", "resv26",
@


1.20
log
@Add support for SPARC T4 crypto instructions.

include/opcode/

	* sparc.h: Document new arg code' )' for crypto RS3
	immediates.

opcodes/

	* sparc-dis.c (print_insn_sparc): Handle ')'.
	* sparc-opc.c (sparc_opcodes): Add crypto instructions.

gas/

	* config/tc-sparc.c (sparc_ip): Likewise.  Accept instruction
	names containing "_".
	(sparc_arch_table): Add sparc4, v8pluse, and v9e.  Add crypto
	hwcap masks to v8plusv and v9v.

gas/testsuite/

	* gas/sparc/crypto.s: New file.
	* gas/sparc/crypto.d: New file.
	* gas/sparc/sparc.exp: Run crypto test.
@
text
@d112 1
a112 1
  "resv27", "cps"
@


1.19
log
@Support R_SPARC_WDISP10 and R_SPARC_H34.

include/

	* elf/sparc.h (R_SPARC_WDISP10): New reloc.
	* opcode/sparc.h: Define '=' as generating R_SPARC_WDISP10.

opcodes/

	* sparc-dis.c (X_DISP10): Define.
	(print_insn_sparc): Handle '='.

bfd/

	* reloc.c (BFD_RELOC_SPARC_H34, BFD_RELOC_SPARC_SIZE32,
	BFD_RELOC_SPARC_SIZE64, BFD_RELOC_SPARC_WDISP10): New relocs.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Likewise.
	* elfxx-sparc.c (sparc_elf_wdisp10_reloc): New function.
	(_bfd_sparc_elf_howto_table): Add entries for R_SPARC_H34,
	R_SPARC_SIZE32, R_SPARC_64, and R_SPARC_WDISP10.
	(_bfd_sparc_elf_reloc_type_lookup): Handle new relocs.
	(_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_gc_sweep_hook): Likewise.
	(_bfd_sparc_elf_relocate_section): Likewise.

gas/

	* config/tc-sparc.c (sparc_ip): Handle '=', "%h34", "%l34", and
	BFD_RELOC_SPARC_H34.
	(md_apply_fix): Handle BFD_RELOC_SPARC_WDISP10 and BFD_RELOC_SPARC_H34.
	(tc_gen_reloc): Likewise.

gas/testsuite/

	* gas/sparc/reloc64.s: Add abs34 code model tests.
	* gas/sparc/reloc64.d: Update.

elfcpp/

	* sparc.h (R_SPARC_WDISP10): New relocation.

gold/

	* sparc.cc (Reloc::wdisp10): New relocation method.
	(Reloc::h34): Likewise.
	(Target_sparc::Scan::check_non_pic): Handle R_SPARC_H34.
	(Target_sparc::Scan::get_reference_flags): Handle R_SPARC_H34 and
	R_SPARC_WDISP10.
	(Target_sparc::Scan::local): Likewise.
	(Target_sparc::Scan::global): Likewise.
	(Target_sparc::Relocate::relocate): Likewise.
@
text
@d707 4
@


1.18
log
@include/opcode/
	* sparc.h: Document new format codes '4', '5', and '('.
	(OPF_LOW4, RS3): New macros.
opcodes/
	* sparc-dis.c (v9a_ast_reg_names): Add "cps".
	(X_RS3): New macro.
	(print_insn_sparc): Handle '4', '5', and '(' format codes.
	Accept %asr numbers below 28.
	* sparc-opc.c (sparc_opcodes): Add entries for HPC and VIS3
	instructions.
gas/
	* config/tc-sparc.c (v9a_asr_table): Add "cps".
	(sparc_ip): Handle '4', '5' and '(' format codes.
gas/testsuite
	* gas/sparc/hpcvis3.d: New test.
	* gas/sparc/hpcvis3.s: New test source.
	* gas/sparc/sparc.exp: Run new test.
@
text
@d132 1
d747 5
@


1.17
log
@fix set but unused variable warnings
@
text
@d111 2
a112 1
  "softint", "tick_cmpr", "stick", "stick_cmpr"
d123 1
d639 7
d826 1
a826 1
		    if (X_RS1 (insn) < 16 || X_RS1 (insn) > 25)
d834 1
a834 1
		    if (X_RD (insn) < 16 || X_RD (insn) > 25)
d894 4
@


1.16
log
@update copyright dates
@
text
@d3 1
a3 1
   2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d998 2
a999 1
		/* FIXME -- check is_annulled flag.  */
@


1.15
log
@gas/

	* config/tc-sparc.c: Accept 'softint_clear' and 'softint_set'
	%asr aliases.

	* doc/c-sparc.texi: Consistently refer to architecture 'versions',
	rather than occaisionally 'levels'.  Consistently refer to Sun's
	UNIX variant as SunOS, every version of Solaris is also SunOS.
	Document new 'softint_clear' and 'softint_set' aliases.  Clarify
	which architecture versions support '%dcr', '%cq', and '%gl'. Add
	section on 32-bit/64-bit opcode translations.

opcodes/

	* sparc-dis.c: Emit %stick instead of %sys_tick, and %stick_cmpr
	instead of %sys_tick_cmpr, as suggested in architecture manuals.
@
text
@d3 2
a4 1
   2000, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.14
log
@Change source files over to GPLv3.
@
text
@d110 1
a110 1
  "softint", "tick_cmpr", "sys_tick", "sys_tick_cmpr"
@


1.13
log
@2006-02-24  David S. Miller  <davem@@sunset.davemloft.net>

	* sparc-dis.c (v9_priv_reg_names): Add "gl" entry.
	(v9_hpriv_reg_names): New table.
	(print_insn_sparc): Allow values up to 16 for '?' and '!'.
	New cases '$' and '%' for read/write hyperprivileged register.
	* sparc-opc.c (sparc_opcodes): Add new entries for UA2005
	window handling and rdhpr/wrhpr instructions.
@
text
@d3 1
a3 1
   2000, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d5 3
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.12
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d88 1
a88 1
  "wstate", "fq"
d93 11
d782 1
a782 1
		    else if ((unsigned) X_RS1 (insn) < 16)
d790 1
a790 1
		    if ((unsigned) X_RD (insn) < 15)
d797 16
@


1.11
log
@Update function declarations to ISO C90 formatting
@
text
@d696 1
a696 1
		    (info->fprintf_func) (stream, "%d", X_IMM (insn, 3));
d809 1
a809 1
			(*info->fprintf_func) (stream, "%d", X_RD (insn));
d814 1
a814 1
		    (*info->fprintf_func) (stream, "%%asr%d", X_RS1 (insn));
d818 1
a818 1
		    (*info->fprintf_func) (stream, "%%asr%d", X_RD (insn));
d843 1
a843 1
			(*info->fprintf_func) (stream, "(%d)", X_ASI (insn));
d876 1
a876 1
		    (*info->fprintf_func) (stream, "%d",
@


1.10
log
@Update the address and phone number of the FSF
@
text
@d3 1
a3 1
   2000, 2002, 2003, 2004 Free Software Foundation, Inc.
d17 2
a18 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d38 1
a38 1
static const struct sparc_opcode **sorted_opcodes;
d50 1
a50 1
struct opcode_hash
d52 3
a54 4
  struct opcode_hash *next;
  const struct sparc_opcode *opcode;
};
static struct opcode_hash *opcode_hash_table[HASH_SIZE];
d56 1
a56 5
static void build_hash_table
  PARAMS ((const struct sparc_opcode **, struct opcode_hash **, int));
static int is_delayed_branch PARAMS ((unsigned long));
static int compare_opcodes PARAMS ((const PTR, const PTR));
static int compute_arch_mask PARAMS ((unsigned long));
d64 6
a69 6
{ "g0", "g1", "g2", "g3", "g4", "g5", "g6", "g7",	
  "o0", "o1", "o2", "o3", "o4", "o5", "sp", "o7",	
  "l0", "l1", "l2", "l3", "l4", "l5", "l6", "l7",	
  "i0", "i1", "i2", "i3", "i4", "i5", "fp", "i7",	
  "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",	
  "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",	
d72 2
a73 2
  "f32", "f33", "f34", "f35", "f36", "f37", "f38", "f39",	
  "f40", "f41", "f42", "f43", "f44", "f45", "f46", "f47",	
d103 10
a112 10
#define X_RD(i) (((i) >> 25) & 0x1f)
#define X_RS1(i) (((i) >> 14) & 0x1f)
#define X_LDST_I(i) (((i) >> 13) & 1)
#define X_ASI(i) (((i) >> 5) & 0xff)
#define X_RS2(i) (((i) >> 0) & 0x1f)
#define X_IMM(i,n) (((i) >> 0) & ((1 << (n)) - 1))
#define X_SIMM(i,n) SEX (X_IMM ((i), (n)), (n))
#define X_DISP22(i) (((i) >> 0) & 0x3fffff)
#define X_IMM22(i) X_DISP22 (i)
#define X_DISP30(i) (((i) >> 0) & 0x3fffffff)
d115 3
a117 3
#define X_DISP16(i) (((((i) >> 20) & 3) << 14) | (((i) >> 0) & 0x3fff))
#define X_DISP19(i) (((i) >> 0) & 0x7ffff)
#define X_MEMBAR(i) ((i) & 0x7f)
d175 1
a175 1
     };
d177 1
a177 1
   */
a178 1
/* Nonzero if INSN is the opcode for a delayed branch.  */
d180 1
a180 2
is_delayed_branch (insn)
     unsigned long insn;
d182 1
a182 1
  struct opcode_hash *op;
d186 2
a187 1
      const struct sparc_opcode *opcode = op->opcode;
d190 1
a190 1
	return (opcode->flags & F_DELAYED);
d201 230
d440 1
a440 3
print_insn_sparc (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d445 1
a445 1
  register struct opcode_hash *op;
d460 2
a461 2
	sorted_opcodes = (const struct sparc_opcode **)
	  xmalloc (sparc_num_opcodes * sizeof (struct sparc_opcode *));
d476 1
d500 1
a500 1
      const struct sparc_opcode *opcode = op->opcode;
d517 1
a517 1
	  
d540 1
a540 1
	    register const char *s;
d574 1
a574 1
			
d579 1
a580 1
		    /* note fall-through */
d610 2
a611 2
		  case 'v':	/* double/even */
		  case 'V':	/* quad/multiple of 4 */
d618 2
a619 2
		  case 'B':	/* double/even */
		  case 'R':	/* quad/multiple of 4 */
d626 2
a627 2
		  case 'H':	/* double/even */
		  case 'J':	/* quad/multiple of 4 */
d653 3
a655 3
		  case 'i':	/* 13 bit immediate */
		  case 'I':	/* 11 bit immediate */
		  case 'j':	/* 10 bit immediate */
d675 1
a675 1
		      
d683 2
a684 2
		  case 'X':	/* 5 bit unsigned immediate */
		  case 'Y':	/* 6 bit unsigned immediate */
d759 1
a759 1
		    
d812 1
a812 1
		    
d816 1
a816 1
		    
d820 1
a820 1
		    
d952 1
a952 1
		      info->target = 
d968 1
a968 1
		/* FIXME -- check is_annulled flag */
a986 231

/* Given BFD mach number, return a mask of SPARC_OPCODE_ARCH_FOO values.  */

static int
compute_arch_mask (mach)
     unsigned long mach;
{
  switch (mach)
    {
    case 0 :
    case bfd_mach_sparc :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V8);
    case bfd_mach_sparc_sparclet :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_SPARCLET);
    case bfd_mach_sparc_sparclite :
    case bfd_mach_sparc_sparclite_le :
      /* sparclites insns are recognized by default (because that's how
	 they've always been treated, for better or worse).  Kludge this by
	 indicating generic v8 is also selected.  */
      return (SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_SPARCLITE)
	      | SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V8));
    case bfd_mach_sparc_v8plus :
    case bfd_mach_sparc_v9 :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9);
    case bfd_mach_sparc_v8plusa :
    case bfd_mach_sparc_v9a :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9A);
    case bfd_mach_sparc_v8plusb :
    case bfd_mach_sparc_v9b :
      return SPARC_OPCODE_ARCH_MASK (SPARC_OPCODE_ARCH_V9B);
    }
  abort ();
}

/* Compare opcodes A and B.  */

static int
compare_opcodes (a, b)
     const PTR a;
     const PTR b;
{
  struct sparc_opcode *op0 = * (struct sparc_opcode **) a;
  struct sparc_opcode *op1 = * (struct sparc_opcode **) b;
  unsigned long int match0 = op0->match, match1 = op1->match;
  unsigned long int lose0 = op0->lose, lose1 = op1->lose;
  register unsigned int i;

  /* If one (and only one) insn isn't supported by the current architecture,
     prefer the one that is.  If neither are supported, but they're both for
     the same architecture, continue processing.  Otherwise (both unsupported
     and for different architectures), prefer lower numbered arch's (fudged
     by comparing the bitmasks).  */
  if (op0->architecture & current_arch_mask)
    {
      if (! (op1->architecture & current_arch_mask))
	return -1;
    }
  else
    {
      if (op1->architecture & current_arch_mask)
	return 1;
      else if (op0->architecture != op1->architecture)
	return op0->architecture - op1->architecture;
    }

  /* If a bit is set in both match and lose, there is something
     wrong with the opcode table.  */
  if (match0 & lose0)
    {
      fprintf
	(stderr,
	 /* xgettext:c-format */
	 _("Internal error:  bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n"),
	 op0->name, match0, lose0);
      op0->lose &= ~op0->match;
      lose0 = op0->lose;
    }

  if (match1 & lose1)
    {
      fprintf
	(stderr,
	 /* xgettext:c-format */
	 _("Internal error: bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n"),
	 op1->name, match1, lose1);
      op1->lose &= ~op1->match;
      lose1 = op1->lose;
    }

  /* Because the bits that are variable in one opcode are constant in
     another, it is important to order the opcodes in the right order.  */
  for (i = 0; i < 32; ++i)
    {
      unsigned long int x = 1 << i;
      int x0 = (match0 & x) != 0;
      int x1 = (match1 & x) != 0;

      if (x0 != x1)
	return x1 - x0;
    }

  for (i = 0; i < 32; ++i)
    {
      unsigned long int x = 1 << i;
      int x0 = (lose0 & x) != 0;
      int x1 = (lose1 & x) != 0;

      if (x0 != x1)
	return x1 - x0;
    }

  /* They are functionally equal.  So as long as the opcode table is
     valid, we can put whichever one first we want, on aesthetic grounds.  */

  /* Our first aesthetic ground is that aliases defer to real insns.  */
  {
    int alias_diff = (op0->flags & F_ALIAS) - (op1->flags & F_ALIAS);
    if (alias_diff != 0)
      /* Put the one that isn't an alias first.  */
      return alias_diff;
  }

  /* Except for aliases, two "identical" instructions had
     better have the same opcode.  This is a sanity check on the table.  */
  i = strcmp (op0->name, op1->name);
  if (i)
    {
      if (op0->flags & F_ALIAS) /* If they're both aliases, be arbitrary. */
	return i;
      else
	fprintf (stderr,
		 /* xgettext:c-format */
		 _("Internal error: bad sparc-opcode.h: \"%s\" == \"%s\"\n"),
		 op0->name, op1->name);
    }

  /* Fewer arguments are preferred.  */
  {
    int length_diff = strlen (op0->args) - strlen (op1->args);
    if (length_diff != 0)
      /* Put the one with fewer arguments first.  */
      return length_diff;
  }

  /* Put 1+i before i+1.  */
  {
    char *p0 = (char *) strchr (op0->args, '+');
    char *p1 = (char *) strchr (op1->args, '+');

    if (p0 && p1)
      {
	/* There is a plus in both operands.  Note that a plus
	   sign cannot be the first character in args,
	   so the following [-1]'s are valid.  */
	if (p0[-1] == 'i' && p1[1] == 'i')
	  /* op0 is i+1 and op1 is 1+i, so op1 goes first.  */
	  return 1;
	if (p0[1] == 'i' && p1[-1] == 'i')
	  /* op0 is 1+i and op1 is i+1, so op0 goes first.  */
	  return -1;
      }
  }

  /* Put 1,i before i,1.  */
  {
    int i0 = strncmp (op0->args, "i,1", 3) == 0;
    int i1 = strncmp (op1->args, "i,1", 3) == 0;

    if (i0 ^ i1)
      return i0 - i1;
  }

  /* They are, as far as we can tell, identical.
     Since qsort may have rearranged the table partially, there is
     no way to tell which one was first in the opcode table as
     written, so just say there are equal.  */
  /* ??? This is no longer true now that we sort a vector of pointers,
     not the table itself.  */
  return 0;
}

/* Build a hash table from the opcode table.
   OPCODE_TABLE is a sorted list of pointers into the opcode table.  */

static void
build_hash_table (opcode_table, hash_table, num_opcodes)
     const struct sparc_opcode **opcode_table;
     struct opcode_hash **hash_table;
     int num_opcodes;
{
  register int i;
  int hash_count[HASH_SIZE];
  static struct opcode_hash *hash_buf = NULL;

  /* Start at the end of the table and work backwards so that each
     chain is sorted.  */

  memset (hash_table, 0, HASH_SIZE * sizeof (hash_table[0]));
  memset (hash_count, 0, HASH_SIZE * sizeof (hash_count[0]));
  if (hash_buf != NULL)
    free (hash_buf);
  hash_buf = (struct opcode_hash *) xmalloc (sizeof (struct opcode_hash) * num_opcodes);
  for (i = num_opcodes - 1; i >= 0; --i)
    {
      register int hash = HASH_INSN (opcode_table[i]->match);
      register struct opcode_hash *h = &hash_buf[i];
      h->next = hash_table[hash];
      h->opcode = opcode_table[i];
      hash_table[hash] = h;
      ++hash_count[hash];
    }

#if 0 /* for debugging */
  {
    int min_count = num_opcodes, max_count = 0;
    int total;

    for (i = 0; i < HASH_SIZE; ++i)
      {
        if (hash_count[i] < min_count)
	  min_count = hash_count[i];
	if (hash_count[i] > max_count)
	  max_count = hash_count[i];
	total += hash_count[i];
      }

    printf ("Opcode hash table stats: min %d, max %d, ave %f\n",
	    min_count, max_count, (double) total / HASH_SIZE);
  }
#endif
}
@


1.9
log
@	* sparc-dis.c (print_insn_sparc): Update getword prototype.
@
text
@d17 1
a17 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.8
log
@(print_insn_sparc): When examining values added in to rs1, make sure that
there are previous instructions.
@
text
@d3 1
a3 1
   2000, 2002, 2003 Free Software Foundation, Inc.
d227 1
a227 1
  bfd_vma (*getword) PARAMS ((const unsigned char *));
@


1.8.48.1
log
@Merge mainline to intercu branch.
@
text
@d3 1
a3 1
   2000, 2002, 2003, 2004 Free Software Foundation, Inc.
d227 1
a227 1
  bfd_vma (*getword) (const void *);
@


1.8.52.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d3 1
a3 1
   2000, 2002, 2003, 2004 Free Software Foundation, Inc.
d227 1
a227 1
  bfd_vma (*getword) (const void *);
@


1.8.46.1
log
@	* sparc-dis.c (print_insn_sparc): Update getword prototype.
@
text
@d3 1
a3 1
   2000, 2002, 2003, 2004 Free Software Foundation, Inc.
d227 1
a227 1
  bfd_vma (*getword) (const void *);
@


1.7
log
@	* a29k-dis.c: Replace CONST with const.
	* h8300-dis.c: Likewise.
	* m68k-dis.c: Likewise.
	* or32-dis.c: Likewise.
	* sparc-dis.c: Likewise.
@
text
@d3 1
a3 1
   2000, 2002 Free Software Foundation, Inc.
d5 13
a17 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 2
a50 1
struct opcode_hash {
d261 1
a261 1
     are always big-endian even when the machine is in little-endian mode. */
d269 4
a272 4
  info->insn_info_valid = 1;			/* We do return this info */
  info->insn_type = dis_nonbranch;		/* Assume non branch insn */
  info->branch_delay_insns = 0;			/* Assume no delay */
  info->target = 0;				/* Assume no target known */
d320 1
d327 21
a347 20
		    switch (*s) {
		    case 'a':
		      (*info->fprintf_func) (stream, "a");
		      is_annulled = 1;
		      ++s;
		      continue;
		    case 'N':
		      (*info->fprintf_func) (stream, "pn");
		      ++s;
		      continue;

		    case 'T':
		      (*info->fprintf_func) (stream, "pt");
		      ++s;
		      continue;

		    default:
		      break;
		    }		/* switch on arg */
		  }		/* while there are comma started args */
d688 3
a690 2
	      errcode =
		(*info->read_memory_func)
d692 3
d701 1
a701 1
		     sequences such as
d705 1
a705 2
		     or %o1, %lo(_foo), %o1
		     */
d709 6
a714 2
		      errcode = (*info->read_memory_func)
			(memaddr - 8, buffer, sizeof (buffer), info);
d759 1
a759 1
  info->insn_type = dis_noninsn;	/* Mark as non-valid instruction */
@


1.7.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2002, 2003 Free Software Foundation, Inc.
d5 13
a17 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 1
a49 2
struct opcode_hash
{
d260 1
a260 1
     are always big-endian even when the machine is in little-endian mode.  */
d268 4
a271 4
  info->insn_info_valid = 1;			/* We do return this info.  */
  info->insn_type = dis_nonbranch;		/* Assume non branch insn.  */
  info->branch_delay_insns = 0;			/* Assume no delay.  */
  info->target = 0;				/* Assume no target known.  */
a318 1

d325 20
a344 21
		    switch (*s)
		      {
		      case 'a':
			(*info->fprintf_func) (stream, "a");
			is_annulled = 1;
			++s;
			continue;
		      case 'N':
			(*info->fprintf_func) (stream, "pn");
			++s;
			continue;

		      case 'T':
			(*info->fprintf_func) (stream, "pt");
			++s;
			continue;

		      default:
			break;
		      }
		  }
d685 2
a686 3
	      if (memaddr >= 4)
		errcode =
		  (*info->read_memory_func)
a687 3
	      else
		errcode = 1;

d694 1
a694 1
		     sequences such as:
d698 2
a699 1
		     or %o1, %lo(_foo), %o1  */
d703 2
a704 6
		      if (memaddr >= 8)
			errcode = (*info->read_memory_func)
			  (memaddr - 8, buffer, sizeof (buffer), info);
		      else
			errcode = 1;

d749 1
a749 1
  info->insn_type = dis_noninsn;	/* Mark as non-valid instruction.  */
@


1.7.12.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   2000, 2002, 2003 Free Software Foundation, Inc.
d5 13
a17 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 1
a49 2
struct opcode_hash
{
d260 1
a260 1
     are always big-endian even when the machine is in little-endian mode.  */
d268 4
a271 4
  info->insn_info_valid = 1;			/* We do return this info.  */
  info->insn_type = dis_nonbranch;		/* Assume non branch insn.  */
  info->branch_delay_insns = 0;			/* Assume no delay.  */
  info->target = 0;				/* Assume no target known.  */
a318 1

d325 20
a344 21
		    switch (*s)
		      {
		      case 'a':
			(*info->fprintf_func) (stream, "a");
			is_annulled = 1;
			++s;
			continue;
		      case 'N':
			(*info->fprintf_func) (stream, "pn");
			++s;
			continue;

		      case 'T':
			(*info->fprintf_func) (stream, "pt");
			++s;
			continue;

		      default:
			break;
		      }
		  }
d685 2
a686 3
	      if (memaddr >= 4)
		errcode =
		  (*info->read_memory_func)
a687 3
	      else
		errcode = 1;

d694 1
a694 1
		     sequences such as:
d698 2
a699 1
		     or %o1, %lo(_foo), %o1  */
d703 2
a704 6
		      if (memaddr >= 8)
			errcode = (*info->read_memory_func)
			  (memaddr - 8, buffer, sizeof (buffer), info);
		      else
			errcode = 1;

d749 1
a749 1
  info->insn_type = dis_noninsn;	/* Mark as non-valid instruction.  */
@


1.6
log
@* sparc-dis.c (print_insn_sparc): Make sure 0xFFFFFFFF is not
sign-extended.
@
text
@d3 1
a3 1
   2000 Free Software Foundation, Inc.
d191 1
a191 1
      CONST struct sparc_opcode *opcode = op->opcode;
d275 1
a275 1
      CONST struct sparc_opcode *opcode = op->opcode;
d315 1
a315 1
	    register CONST char *s;
@


1.6.8.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d3 1
a3 1
   2000, 2002 Free Software Foundation, Inc.
d191 1
a191 1
      const struct sparc_opcode *opcode = op->opcode;
d275 1
a275 1
      const struct sparc_opcode *opcode = op->opcode;
d315 1
a315 1
	    register const char *s;
@


1.6.6.1
log
@merge from trunk
@
text
@d3 1
a3 1
   2000, 2002 Free Software Foundation, Inc.
d191 1
a191 1
      const struct sparc_opcode *opcode = op->opcode;
d275 1
a275 1
      const struct sparc_opcode *opcode = op->opcode;
d315 1
a315 1
	    register const char *s;
@


1.5
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d422 1
a422 1
					   (0xFFFFFFFF
d719 2
a720 1
			(0xFFFFFFFF & (int) X_IMM22 (prev_insn) << 10);
@


1.5.8.1
log
@* sparc-dis.c (print_insn_sparc): Make sure 0xFFFFFFFF is not
sign-extended.
@
text
@d422 1
a422 1
					   ((unsigned) 0xFFFFFFFF
d719 1
a719 2
			((unsigned) 0xFFFFFFFF
			 & ((int) X_IMM22 (prev_insn) << 10));
@


1.4
log
@gas/
	* config/tc-sparc.c (sparc_ip): Fix a bug which caused v9_arg_p
	instructions to loose any special insn->architecture mask.

	* config/tc-sparc.c (v9a_asr_table): Add v9b ASRs.
	(sparc_md_end, sparc_arch_types, sparc_arch,
	sparc_elf_final_processing): Handle v8plusb and v9b architectures.
	(sparc_ip): Handle siam mode operands. Support v9b ASRs (and
	request v9b architecture if they are used).

bfd/
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data,
	elf32_sparc_object_p, elf32_sparc_final_write_processing):
	Support v8plusb.
	* elf64-sparc.c (sparc64_elf_merge_private_bfd_data,
	sparc64_elf_object_p): Support v9b.
	* archures.c: Declare v8plusb and v9b machines.
	* bfd-in2.h: Ditto.
	* cpu-sparc.c: Ditto.

include/opcode/
	* sparc.h (enum sparc_opcode_arch_val): Add SPARC_OPCODE_ARCH_V9B.
	Note that '3' is used for siam operand.

opcodes/
	* sparc-dis.c (v9a_asr_reg_names): Add v9b ASRs.
	(compute_arch_mask): Add v8plusb and v9b machines.
	(print_insn_sparc): siam mode decoding, accept ASRs up to 25.
	* opcodes/sparc-opc.c: Support for Cheetah instruction set.
	(prefetch_table): Add #invalidate.
@
text
@d2 2
a3 1
   Copyright (C) 1989, 91-97, 1998, 2000 Free Software Foundation, Inc.
@


1.4.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000 Free Software Foundation, Inc.
@


1.3
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 1
a2 1
   Copyright (C) 1989, 91-97, 1998 Free Software Foundation, Inc.
d28 2
a29 1
		 | (1 << SPARC_OPCODE_ARCH_V9A))
d99 1
a99 1
  "softint", "tick_cmpr"
d467 4
d559 1
a559 1
		    if (X_RS1 (insn) < 16 || X_RS1 (insn) > 23)
d567 1
a567 1
		    if (X_RD (insn) < 16 || X_RD (insn) > 23)
d778 3
@


1.2
log
@Jakub Jelinek  <jj@@ultra.linux.cz>
        * sparc-dis.c (print_insn_sparc): Differentiate between
        addition and oring when guessing symbol for comment.
@
text
@a19 1
#include "ansidecl.h"
@


1.2.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@d20 1
@


1.1
log
@Initial revision
@
text
@d286 1
d297 3
a299 2
	  if (opcode->match == 0x80102000 || opcode->match == 0x80002000)
	  /*			  (or)				 (add)  */
d675 1
a675 1
	  if (imm_added_to_rs1)
d714 5
a718 2
			(0xFFFFFFFF & (int) X_IMM22 (prev_insn) << 10)
			| X_SIMM (insn, 13);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

