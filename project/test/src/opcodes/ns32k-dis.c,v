head	1.12;
access;
symbols
	sid-snapshot-20180601:1.12
	sid-snapshot-20180501:1.12
	sid-snapshot-20180401:1.12
	sid-snapshot-20180301:1.12
	sid-snapshot-20180201:1.12
	sid-snapshot-20180101:1.12
	sid-snapshot-20171201:1.12
	sid-snapshot-20171101:1.12
	sid-snapshot-20171001:1.12
	sid-snapshot-20170901:1.12
	sid-snapshot-20170801:1.12
	sid-snapshot-20170701:1.12
	sid-snapshot-20170601:1.12
	sid-snapshot-20170501:1.12
	sid-snapshot-20170401:1.12
	sid-snapshot-20170301:1.12
	sid-snapshot-20170201:1.12
	sid-snapshot-20170101:1.12
	sid-snapshot-20161201:1.12
	sid-snapshot-20161101:1.12
	sid-snapshot-20160901:1.12
	sid-snapshot-20160801:1.12
	sid-snapshot-20160701:1.12
	sid-snapshot-20160601:1.12
	sid-snapshot-20160501:1.12
	sid-snapshot-20160401:1.12
	sid-snapshot-20160301:1.12
	sid-snapshot-20160201:1.12
	sid-snapshot-20160101:1.12
	sid-snapshot-20151201:1.12
	sid-snapshot-20151101:1.12
	sid-snapshot-20151001:1.12
	sid-snapshot-20150901:1.12
	sid-snapshot-20150801:1.12
	sid-snapshot-20150701:1.12
	sid-snapshot-20150601:1.12
	sid-snapshot-20150501:1.12
	sid-snapshot-20150401:1.12
	sid-snapshot-20150301:1.12
	sid-snapshot-20150201:1.12
	sid-snapshot-20150101:1.12
	sid-snapshot-20141201:1.12
	sid-snapshot-20141101:1.12
	sid-snapshot-20141001:1.12
	sid-snapshot-20140901:1.12
	sid-snapshot-20140801:1.12
	sid-snapshot-20140701:1.12
	sid-snapshot-20140601:1.12
	sid-snapshot-20140501:1.12
	sid-snapshot-20140401:1.12
	sid-snapshot-20140301:1.12
	sid-snapshot-20140201:1.12
	sid-snapshot-20140101:1.12
	sid-snapshot-20131201:1.12
	sid-snapshot-20131101:1.12
	sid-snapshot-20131001:1.12
	binutils-2_24-branch:1.12.0.22
	binutils-2_24-branchpoint:1.12
	binutils-2_21_1:1.12
	sid-snapshot-20130901:1.12
	gdb_7_6_1-2013-08-30-release:1.12
	sid-snapshot-20130801:1.12
	sid-snapshot-20130701:1.12
	sid-snapshot-20130601:1.12
	sid-snapshot-20130501:1.12
	gdb_7_6-2013-04-26-release:1.12
	sid-snapshot-20130401:1.12
	binutils-2_23_2:1.12
	gdb_7_6-branch:1.12.0.20
	gdb_7_6-2013-03-12-branchpoint:1.12
	sid-snapshot-20130301:1.12
	sid-snapshot-20130201:1.12
	sid-snapshot-20130101:1.12
	sid-snapshot-20121201:1.12
	gdb_7_5_1-2012-11-29-release:1.12
	binutils-2_23_1:1.12
	sid-snapshot-20121101:1.12
	binutils-2_23:1.12
	sid-snapshot-20121001:1.12
	sid-snapshot-20120901:1.12
	gdb_7_5-2012-08-17-release:1.12
	sid-snapshot-20120801:1.12
	binutils-2_23-branch:1.12.0.18
	binutils-2_23-branchpoint:1.12
	gdb_7_5-branch:1.12.0.16
	gdb_7_5-2012-07-18-branchpoint:1.12
	sid-snapshot-20120701:1.12
	sid-snapshot-20120601:1.12
	sid-snapshot-20120501:1.12
	binutils-2_22_branch:1.12.0.14
	gdb_7_4_1-2012-04-26-release:1.12
	sid-snapshot-20120401:1.12
	sid-snapshot-20120301:1.12
	sid-snapshot-20120201:1.12
	gdb_7_4-2012-01-24-release:1.12
	sid-snapshot-20120101:1.12
	gdb_7_4-branch:1.12.0.12
	gdb_7_4-2011-12-13-branchpoint:1.12
	sid-snapshot-20111201:1.12
	binutils-2_22:1.12
	sid-snapshot-20111101:1.12
	sid-snapshot-20111001:1.12
	binutils-2_22-branch:1.12.0.10
	binutils-2_22-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.12
	sid-snapshot-20110901:1.12
	sid-snapshot-20110801:1.12
	gdb_7_3-2011-07-26-release:1.12
	sid-snapshot-20110701:1.12
	sid-snapshot-20110601:1.12
	sid-snapshot-20110501:1.12
	gdb_7_3-branch:1.12.0.8
	gdb_7_3-2011-04-01-branchpoint:1.12
	sid-snapshot-20110401:1.12
	sid-snapshot-20110301:1.12
	sid-snapshot-20110201:1.12
	sid-snapshot-20110101:1.12
	binutils-2_21:1.12
	sid-snapshot-20101201:1.12
	binutils-2_21-branch:1.12.0.6
	binutils-2_21-branchpoint:1.12
	sid-snapshot-20101101:1.12
	sid-snapshot-20101001:1.12
	binutils-2_20_1:1.11
	gdb_7_2-2010-09-02-release:1.12
	sid-snapshot-20100901:1.12
	sid-snapshot-20100801:1.12
	gdb_7_2-branch:1.12.0.4
	gdb_7_2-2010-07-07-branchpoint:1.12
	sid-snapshot-20100701:1.12
	sid-snapshot-20100601:1.12
	sid-snapshot-20100501:1.12
	sid-snapshot-20100401:1.12
	gdb_7_1-2010-03-18-release:1.12
	sid-snapshot-20100301:1.12
	gdb_7_1-branch:1.12.0.2
	gdb_7_1-2010-02-18-branchpoint:1.12
	sid-snapshot-20100201:1.12
	sid-snapshot-20100101:1.12
	gdb_7_0_1-2009-12-22-release:1.11
	sid-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	binutils-2_20:1.11
	gdb_7_0-2009-10-06-release:1.11
	sid-snapshot-20091001:1.11
	gdb_7_0-branch:1.11.0.34
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.11
	binutils-arc-20081103-branch:1.11.0.32
	binutils-arc-20081103-branchpoint:1.11
	binutils-2_20-branch:1.11.0.30
	binutils-2_20-branchpoint:1.11
	sid-snapshot-20090901:1.11
	sid-snapshot-20090801:1.11
	msnyder-checkpoint-072509-branch:1.11.0.28
	msnyder-checkpoint-072509-branchpoint:1.11
	sid-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.26
	dje-cgen-play1-branchpoint:1.11
	sid-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	arc-20081103-branch:1.11.0.24
	arc-20081103-branchpoint:1.11
	arc-insight_6_8-branch:1.11.0.22
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.20
	insight_6_8-branchpoint:1.11
	sid-snapshot-20090301:1.11
	binutils-2_19_1:1.11
	sid-snapshot-20090201:1.11
	sid-snapshot-20090101:1.11
	reverse-20081226-branch:1.11.0.18
	reverse-20081226-branchpoint:1.11
	sid-snapshot-20081201:1.11
	multiprocess-20081120-branch:1.11.0.16
	multiprocess-20081120-branchpoint:1.11
	sid-snapshot-20081101:1.11
	binutils-2_19:1.11
	sid-snapshot-20081001:1.11
	reverse-20080930-branch:1.11.0.14
	reverse-20080930-branchpoint:1.11
	binutils-2_19-branch:1.11.0.12
	binutils-2_19-branchpoint:1.11
	sid-snapshot-20080901:1.11
	sid-snapshot-20080801:1.11
	reverse-20080717-branch:1.11.0.10
	reverse-20080717-branchpoint:1.11
	sid-snapshot-20080701:1.11
	msnyder-reverse-20080609-branch:1.11.0.8
	msnyder-reverse-20080609-branchpoint:1.11
	drow-reverse-20070409-branch:1.9.0.32
	drow-reverse-20070409-branchpoint:1.9
	sid-snapshot-20080601:1.11
	sid-snapshot-20080501:1.11
	sid-snapshot-20080403:1.11
	sid-snapshot-20080401:1.11
	gdb_6_8-2008-03-27-release:1.11
	sid-snapshot-20080301:1.11
	gdb_6_8-branch:1.11.0.6
	gdb_6_8-2008-02-26-branchpoint:1.11
	sid-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	sid-snapshot-20071001:1.11
	gdb_6_7-branch:1.11.0.4
	gdb_6_7-2007-09-07-branchpoint:1.11
	binutils-2_18:1.11
	binutils-2_18-branch:1.11.0.2
	binutils-2_18-branchpoint:1.11
	insight_6_6-20070208-release:1.9
	binutils-csl-coldfire-4_1-32:1.9
	binutils-csl-sourcerygxx-4_1-32:1.9
	gdb_6_6-2006-12-18-release:1.9
	binutils-csl-innovasic-fido-3_4_4-33:1.9
	binutils-csl-sourcerygxx-3_4_4-32:1.7
	binutils-csl-coldfire-4_1-30:1.9
	binutils-csl-sourcerygxx-4_1-30:1.9
	binutils-csl-coldfire-4_1-28:1.9
	binutils-csl-sourcerygxx-4_1-29:1.9
	binutils-csl-sourcerygxx-4_1-28:1.9
	gdb_6_6-branch:1.9.0.30
	gdb_6_6-2006-11-15-branchpoint:1.9
	binutils-csl-arm-2006q3-27:1.9
	binutils-csl-sourcerygxx-4_1-27:1.9
	binutils-csl-arm-2006q3-26:1.9
	binutils-csl-sourcerygxx-4_1-26:1.9
	binutils-csl-sourcerygxx-4_1-25:1.9
	binutils-csl-sourcerygxx-4_1-24:1.9
	binutils-csl-sourcerygxx-4_1-23:1.9
	insight_6_5-20061003-release:1.9
	gdb-csl-symbian-6_4_50_20060226-12:1.9
	binutils-csl-sourcerygxx-4_1-21:1.9
	binutils-csl-arm-2006q3-21:1.9
	binutils-csl-sourcerygxx-4_1-22:1.9
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.9
	binutils-csl-sourcerygxx-4_1-20:1.9
	binutils-csl-arm-2006q3-19:1.9
	binutils-csl-sourcerygxx-4_1-19:1.9
	binutils-csl-sourcerygxx-4_1-18:1.9
	binutils-csl-renesas-4_1-9:1.9
	gdb-csl-sourcerygxx-3_4_4-25:1.9
	binutils-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.9
	gdb-csl-symbian-6_4_50_20060226-11:1.9
	binutils-csl-renesas-4_1-8:1.9
	binutils-csl-renesas-4_1-7:1.9
	binutils-csl-renesas-4_1-6:1.9
	gdb-csl-sourcerygxx-4_1-17:1.9
	binutils-csl-sourcerygxx-4_1-17:1.9
	gdb-csl-20060226-branch-local-2:1.9
	gdb-csl-sourcerygxx-4_1-14:1.9
	binutils-csl-sourcerygxx-4_1-14:1.9
	binutils-csl-sourcerygxx-4_1-15:1.9
	gdb-csl-sourcerygxx-4_1-13:1.9
	binutils-csl-sourcerygxx-4_1-13:1.9
	binutils-2_17:1.9
	gdb-csl-sourcerygxx-4_1-12:1.9
	binutils-csl-sourcerygxx-4_1-12:1.9
	gdb-csl-sourcerygxx-3_4_4-21:1.9
	binutils-csl-sourcerygxx-3_4_4-21:1.9
	gdb_6_5-20060621-release:1.9
	binutils-csl-wrs-linux-3_4_4-24:1.7
	binutils-csl-wrs-linux-3_4_4-23:1.7
	gdb-csl-sourcerygxx-4_1-9:1.9
	binutils-csl-sourcerygxx-4_1-9:1.9
	gdb-csl-sourcerygxx-4_1-8:1.9
	binutils-csl-sourcerygxx-4_1-8:1.9
	gdb-csl-sourcerygxx-4_1-7:1.9
	binutils-csl-sourcerygxx-4_1-7:1.9
	gdb-csl-arm-2006q1-6:1.9
	binutils-csl-arm-2006q1-6:1.9
	gdb-csl-sourcerygxx-4_1-6:1.9
	binutils-csl-sourcerygxx-4_1-6:1.9
	binutils-csl-wrs-linux-3_4_4-22:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.9
	gdb-csl-symbian-6_4_50_20060226-9:1.9
	gdb-csl-symbian-6_4_50_20060226-8:1.9
	gdb-csl-coldfire-4_1-11:1.9
	binutils-csl-coldfire-4_1-11:1.9
	gdb-csl-sourcerygxx-3_4_4-19:1.9
	binutils-csl-sourcerygxx-3_4_4-19:1.9
	gdb-csl-coldfire-4_1-10:1.9
	gdb_6_5-branch:1.9.0.28
	gdb_6_5-2006-05-14-branchpoint:1.9
	binutils-csl-coldfire-4_1-10:1.9
	gdb-csl-sourcerygxx-4_1-5:1.9
	binutils-csl-sourcerygxx-4_1-5:1.9
	nickrob-async-20060513-branch:1.9.0.26
	nickrob-async-20060513-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-4:1.9
	binutils-csl-sourcerygxx-4_1-4:1.9
	msnyder-reverse-20060502-branch:1.9.0.24
	msnyder-reverse-20060502-branchpoint:1.9
	binutils-csl-wrs-linux-3_4_4-21:1.7
	gdb-csl-morpho-4_1-4:1.9
	binutils-csl-morpho-4_1-4:1.9
	gdb-csl-sourcerygxx-3_4_4-17:1.9
	binutils-csl-sourcerygxx-3_4_4-17:1.9
	binutils-csl-wrs-linux-3_4_4-20:1.7
	readline_5_1-import-branch:1.9.0.22
	readline_5_1-import-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.9
	binutils-2_17-branch:1.9.0.20
	binutils-2_17-branchpoint:1.9
	gdb-csl-symbian-20060226-branch:1.9.0.18
	gdb-csl-symbian-20060226-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.9
	msnyder-reverse-20060331-branch:1.9.0.16
	msnyder-reverse-20060331-branchpoint:1.9
	binutils-csl-2_17-branch:1.9.0.14
	binutils-csl-2_17-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.9.0.12
	gdb-csl-available-20060303-branchpoint:1.9
	gdb-csl-20060226-branch:1.9.0.10
	gdb-csl-20060226-branchpoint:1.9
	gdb_6_4-20051202-release:1.9
	msnyder-fork-checkpoint-branch:1.9.0.8
	msnyder-fork-checkpoint-branchpoint:1.9
	gdb-csl-gxxpro-6_3-branch:1.9.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.9
	gdb_6_4-branch:1.9.0.4
	gdb_6_4-2005-11-01-branchpoint:1.9
	gdb-csl-arm-20051020-branch:1.9.0.2
	gdb-csl-arm-20051020-branchpoint:1.9
	binutils-csl-gxxpro-3_4-branch:1.7.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.7
	binutils-2_16_1:1.7
	msnyder-tracepoint-checkpoint-branch:1.8.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.8
	gdb-csl-arm-20050325-2005-q1b:1.7
	binutils-csl-arm-2005q1b:1.7
	binutils-2_16:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	binutils-csl-arm-2005q1a:1.7
	csl-arm-20050325-branch:1.7.0.6
	csl-arm-20050325-branchpoint:1.7
	binutils-csl-arm-2005q1-branch:1.7.0.4
	binutils-csl-arm-2005q1-branchpoint:1.7
	binutils-2_16-branch:1.7.0.2
	binutils-2_16-branchpoint:1.7
	csl-arm-2004-q3d:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.60
	gdb_6_3-20041019-branchpoint:1.6
	csl-arm-2004-q3:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.62
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.58
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	binutils-2_15:1.6
	binutils-2_15-branchpoint:1.6
	csl-arm-2004-q1a:1.6
	csl-arm-2004-q1:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.56
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.54
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.52
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.50
	drow_intercu-20040221-branchpoint:1.6
	binutils-2_15-branch:1.6.0.48
	cagney_bfdfile-20040213-branch:1.6.0.46
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.44
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	csl-arm-2003-q4:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.6.0.42
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.40
	cagney_x86i386-20030821-branch:1.6.0.38
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.36
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.6
	binutils-2_14:1.6
	cagney_convert-20030606-branch:1.6.0.32
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.30
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.26
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	binutils-2_14-branch:1.6.0.22
	binutils-2_14-branchpoint:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	binutils-2_13_2_1:1.4
	binutils-2_13_2:1.4
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.4
	carlton_dictionary-20021115-merge:1.4
	binutils-2_13_1:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.24
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.22
	carlton_dictionary-20020920-branchpoint:1.4
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.20
	gdb_5_3-branch:1.4.0.18
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.16
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.14
	readline_4_3-import-branchpoint:1.4
	binutils-2_13:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	binutils-2_13-branchpoint:1.4
	binutils-2_13-branch:1.4.0.12
	kseitz_interps-20020528-branch:1.4.0.10
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.8
	cagney_regbuf-20020515-branchpoint:1.4
	binutils-2_12_1:1.4
	jimb-macro-020506-branch:1.4.0.6
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	binutils-2_12:1.4
	gdb_5_2-branch:1.4.0.4
	gdb_5_2-2002-03-03-branchpoint:1.4
	binutils-2_12-branch:1.4.0.2
	binutils-2_12-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	binutils-2_11_2:1.1.1.1.8.1
	binutils-2_11_1:1.1.1.1.8.1
	binutils-2_11:1.1.1.1
	x86_64versiong3:1.1.1.1
	binutils-2_11-branch:1.1.1.1.0.8
	insight-precleanup-2001-01-01:1.1.1.1
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.12
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2009.12.11.13.42.17;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.26.14.47.00;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.01.11.16.33;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.07.07.34.30;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.22.13.01.53;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.16.09.54.12;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.02.13.13.37;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.20.15.28.25;	author nickc;	state Exp;
branches
	1.4.22.1
	1.4.24.1;
next	1.3;

1.3
date	2001.08.26.11.47.38;	author aj;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.13.22.58.37;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.4.22.1
date	2002.12.23.19.39.36;	author carlton;	state Exp;
branches;
next	;

1.4.24.1
date	2003.12.14.20.28.09;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1.8.1;
next	;

1.1.1.1.8.1
date	2001.06.07.03.18.36;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@/* Print National Semiconductor 32000 instructions.
   Copyright 1986, 1988, 1991, 1992, 1994, 1998, 2001, 2002, 2005, 2007,
   2009  Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "dis-asm.h"
#if !defined(const) && !defined(__STDC__)
#define const
#endif
#include "opcode/ns32k.h"
#include "opintl.h"

static disassemble_info *dis_info;

/* Hacks to get it to compile <= READ THESE AS FIXES NEEDED.  */
#define INVALID_FLOAT(val, size) invalid_float ((bfd_byte *) val, size)

static long
read_memory_integer (unsigned char * addr, int nr)
{
  long val;
  int i;

  for (val = 0, i = nr - 1; i >= 0; i--)
    {
      val =  (val << 8);
      val |= (0xff & *(addr + i));
    }
  return val;
}

/* 32000 instructions are never longer than this.  */
#define MAXLEN 62

#include <setjmp.h>

struct private
{
  /* Points to first byte not fetched.  */
  bfd_byte *max_fetched;
  bfd_byte the_buffer[MAXLEN];
  bfd_vma insn_start;
  jmp_buf bailout;
};


/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)
   to ADDR (exclusive) are valid.  Returns 1 for success, longjmps
   on error.  */
#define FETCH_DATA(info, addr) \
  ((addr) <= ((struct private *)(info->private_data))->max_fetched \
   ? 1 : fetch_data ((info), (addr)))

static int
fetch_data (struct disassemble_info *info, bfd_byte *addr)
{
  int status;
  struct private *priv = (struct private *) info->private_data;
  bfd_vma start = priv->insn_start + (priv->max_fetched - priv->the_buffer);

  status = (*info->read_memory_func) (start,
				      priv->max_fetched,
				      addr - priv->max_fetched,
				      info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, start, info);
      longjmp (priv->bailout, 1);
    }
  else
    priv->max_fetched = addr;
  return 1;
}

/* Number of elements in the opcode table.  */
#define NOPCODES (sizeof ns32k_opcodes / sizeof ns32k_opcodes[0])

#define NEXT_IS_ADDR	'|'


struct ns32k_option
{
  char *pattern;		/* The option itself.  */
  unsigned long value;		/* Binary value of the option.  */
  unsigned long match;		/* These bits must match.  */
};


static const struct ns32k_option opt_u[]= /* Restore, exit.  */
{
  { "r0",	0x80,	0x80	},
  { "r1",	0x40,	0x40	},
  { "r2",	0x20,	0x20	},
  { "r3",	0x10,	0x10	},
  { "r4",	0x08,	0x08	},
  { "r5",	0x04,	0x04	},
  { "r6",	0x02,	0x02	},
  { "r7",	0x01,	0x01	},
  {  0 ,	0x00,	0x00	}
};

static const struct ns32k_option opt_U[]= /* Save, enter.  */
{
  { "r0",	0x01,	0x01	},
  { "r1",	0x02,	0x02	},
  { "r2",	0x04,	0x04	},
  { "r3",	0x08,	0x08	},
  { "r4",	0x10,	0x10	},
  { "r5",	0x20,	0x20	},
  { "r6",	0x40,	0x40	},
  { "r7",	0x80,	0x80	},
  {  0 ,	0x00,	0x00	}
};

static const struct ns32k_option opt_O[]= /* Setcfg.  */
{
  { "c",	0x8,	0x8	},
  { "m",	0x4,	0x4	},
  { "f",	0x2,	0x2	},
  { "i",	0x1,	0x1	},
  {  0 ,	0x0,	0x0	}
};

static const struct ns32k_option opt_C[]= /* Cinv.  */
{
  { "a",	0x4,	0x4	},
  { "i",	0x2,	0x2	},
  { "d",	0x1,	0x1	},
  {  0 ,	0x0,	0x0	}
};

static const struct ns32k_option opt_S[]= /* String inst.  */
{
  { "b",	0x1,	0x1	},
  { "u",	0x6,	0x6	},
  { "w",	0x2,	0x2	},
  {  0 ,	0x0,	0x0	}
};

static const struct ns32k_option list_P532[]= /* Lpr spr.  */
{
  { "us",	0x0,	0xf	},
  { "dcr",	0x1,	0xf	},
  { "bpc",	0x2,	0xf	},
  { "dsr",	0x3,	0xf	},
  { "car",	0x4,	0xf	},
  { "fp",	0x8,	0xf	},
  { "sp",	0x9,	0xf	},
  { "sb",	0xa,	0xf	},
  { "usp",	0xb,	0xf	},
  { "cfg",	0xc,	0xf	},
  { "psr",	0xd,	0xf	},
  { "intbase",	0xe,	0xf	},
  { "mod",	0xf,	0xf	},
  {  0 ,	0x00,	0xf	}
};

static const struct ns32k_option list_M532[]= /* Lmr smr.  */
{
  { "mcr",	0x9,	0xf	},
  { "msr",	0xa,	0xf	},
  { "tear",	0xb,	0xf	},
  { "ptb0",	0xc,	0xf	},
  { "ptb1",	0xd,	0xf	},
  { "ivar0",	0xe,	0xf	},
  { "ivar1",	0xf,	0xf	},
  {  0 ,	0x0,	0xf	}
};

static const struct ns32k_option list_P032[]= /* Lpr spr.  */
{
  { "upsr",	0x0,	0xf	},
  { "fp",	0x8,	0xf	},
  { "sp",	0x9,	0xf	},
  { "sb",	0xa,	0xf	},
  { "psr",	0xb,	0xf	},
  { "intbase",	0xe,	0xf	},
  { "mod",	0xf,	0xf	},
  {  0 ,	0x0,	0xf	}
};

static const struct ns32k_option list_M032[]= /* Lmr smr.  */
{
  { "bpr0",	0x0,	0xf	},
  { "bpr1",	0x1,	0xf	},
  { "pf0",	0x4,	0xf	},
  { "pf1",	0x5,	0xf	},
  { "sc",	0x8,	0xf	},
  { "msr",	0xa,	0xf	},
  { "bcnt",	0xb,	0xf	},
  { "ptb0",	0xc,	0xf	},
  { "ptb1",	0xd,	0xf	},
  { "eia",	0xf,	0xf	},
  {  0 ,	0x0,	0xf	}
};


/* Figure out which options are present.   */

static void
optlist (int options, const struct ns32k_option * optionP, char * result)
{
  if (options == 0)
    {
      sprintf (result, "[]");
      return;
    }

  sprintf (result, "[");

  for (; (options != 0) && optionP->pattern; optionP++)
    {
      if ((options & optionP->match) == optionP->value)
	{
	  /* We found a match, update result and options.  */
	  strcat (result, optionP->pattern);
	  options &= ~optionP->value;
	  if (options != 0)	/* More options to come.  */
	    strcat (result, ",");
	}
    }

  if (options != 0)
    strcat (result, "undefined");

  strcat (result, "]");
}

static void
list_search (int reg_value, const struct ns32k_option *optionP, char *result)
{
  for (; optionP->pattern; optionP++)
    {
      if ((reg_value & optionP->match) == optionP->value)
	{
	  sprintf (result, "%s", optionP->pattern);
	  return;
	}
    }
  sprintf (result, "undefined");
}

/* Extract "count" bits starting "offset" bits into buffer.  */

static int
bit_extract (bfd_byte *buffer, int offset, int count)
{
  int result;
  int bit;

  buffer += offset >> 3;
  offset &= 7;
  bit = 1;
  result = 0;
  while (count--)
    {
      FETCH_DATA (dis_info, buffer + 1);
      if ((*buffer & (1 << offset)))
	result |= bit;
      if (++offset == 8)
	{
	  offset = 0;
	  buffer++;
	}
      bit <<= 1;
    }
  return result;
}

/* Like bit extract but the buffer is valid and doen't need to be fetched.  */

static int
bit_extract_simple (bfd_byte *buffer, int offset, int count)
{
  int result;
  int bit;

  buffer += offset >> 3;
  offset &= 7;
  bit = 1;
  result = 0;
  while (count--)
    {
      if ((*buffer & (1 << offset)))
	result |= bit;
      if (++offset == 8)
	{
	  offset = 0;
	  buffer++;
	}
      bit <<= 1;
    }
  return result;
}

static void
bit_copy (bfd_byte *buffer, int offset, int count, char *to)
{
  for (; count > 8; count -= 8, to++, offset += 8)
    *to = bit_extract (buffer, offset, 8);
  *to = bit_extract (buffer, offset, count);
}

static int
sign_extend (int value, int bits)
{
  value = value & ((1 << bits) - 1);
  return (value & (1 << (bits - 1))
	  ? value | (~((1 << bits) - 1))
	  : value);
}

static void
flip_bytes (char *ptr, int count)
{
  char tmp;

  while (count > 0)
    {
      tmp = ptr[0];
      ptr[0] = ptr[count - 1];
      ptr[count - 1] = tmp;
      ptr++;
      count -= 2;
    }
}

/* Given a character C, does it represent a general addressing mode?  */
#define Is_gen(c) \
  ((c) == 'F' || (c) == 'L' || (c) == 'B' \
   || (c) == 'W' || (c) == 'D' || (c) == 'A' || (c) == 'I' || (c) == 'Z')

/* Adressing modes.  */
#define Adrmod_index_byte        0x1c
#define Adrmod_index_word        0x1d
#define Adrmod_index_doubleword  0x1e
#define Adrmod_index_quadword    0x1f

/* Is MODE an indexed addressing mode?  */
#define Adrmod_is_index(mode) \
  (   mode == Adrmod_index_byte \
   || mode == Adrmod_index_word \
   || mode == Adrmod_index_doubleword \
   || mode == Adrmod_index_quadword)


static int
get_displacement (bfd_byte *buffer, int *aoffsetp)
{
  int Ivalue;
  short Ivalue2;

  Ivalue = bit_extract (buffer, *aoffsetp, 8);
  switch (Ivalue & 0xc0)
    {
    case 0x00:
    case 0x40:
      Ivalue = sign_extend (Ivalue, 7);
      *aoffsetp += 8;
      break;
    case 0x80:
      Ivalue2 = bit_extract (buffer, *aoffsetp, 16);
      flip_bytes ((char *) & Ivalue2, 2);
      Ivalue = sign_extend (Ivalue2, 14);
      *aoffsetp += 16;
      break;
    case 0xc0:
      Ivalue = bit_extract (buffer, *aoffsetp, 32);
      flip_bytes ((char *) & Ivalue, 4);
      Ivalue = sign_extend (Ivalue, 30);
      *aoffsetp += 32;
      break;
    }
  return Ivalue;
}

#if 1 /* A version that should work on ns32k f's&d's on any machine.  */
static int
invalid_float (bfd_byte *p, int len)
{
  int val;

  if (len == 4)
    val = (bit_extract_simple (p, 23, 8)/*exponent*/ == 0xff
	   || (bit_extract_simple (p, 23, 8)/*exponent*/ == 0
	       && bit_extract_simple (p, 0, 23)/*mantisa*/ != 0));
  else if (len == 8)
    val = (bit_extract_simple (p, 52, 11)/*exponent*/ == 0x7ff
	   || (bit_extract_simple (p, 52, 11)/*exponent*/ == 0
	       && (bit_extract_simple (p, 0, 32)/*low mantisa*/ != 0
		   || bit_extract_simple (p, 32, 20)/*high mantisa*/ != 0)));
  else
    val = 1;
  return (val);
}
#else
/* Assumes the bytes have been swapped to local order.  */
typedef union
{ 
  double d;
  float f;
  struct { unsigned m:23, e:8, :1;} sf;
  struct { unsigned lm; unsigned m:20, e:11, :1;} sd;
} float_type_u;

static int
invalid_float (float_type_u *p, int len)
{
  int val;

  if (len == sizeof (float))
    val = (p->sf.e == 0xff
	   || (p->sf.e == 0 && p->sf.m != 0));
  else if (len == sizeof (double))
    val = (p->sd.e == 0x7ff
	   || (p->sd.e == 0 && (p->sd.m != 0 || p->sd.lm != 0)));
  else
    val = 1;
  return val;
}
#endif

/* Print an instruction operand of category given by d.  IOFFSET is
   the bit position below which small (<1 byte) parts of the operand can
   be found (usually in the basic instruction, but for indexed
   addressing it can be in the index byte).  AOFFSETP is a pointer to the
   bit position of the addressing extension.  BUFFER contains the
   instruction.  ADDR is where BUFFER was read from.  Put the disassembled
   version of the operand in RESULT.  INDEX_OFFSET is the bit position
   of the index byte (it contains garbage if this operand is not a
   general operand using scaled indexed addressing mode).  */

static int
print_insn_arg (int d,
		int ioffset,
		int *aoffsetp,
		bfd_byte *buffer,
		bfd_vma addr,
		char *result,
		int index_offset)
{
  union
  {
    float f;
    double d;
    int i[2];
  } value;
  int Ivalue;
  int addr_mode;
  int disp1, disp2;
  int size;

  switch (d)
    {
    case 'f':
      /* A "gen" operand but 5 bits from the end of instruction.  */
      ioffset -= 5;
    case 'Z':
    case 'F':
    case 'L':
    case 'I':
    case 'B':
    case 'W':
    case 'D':
    case 'A':
      addr_mode = bit_extract (buffer, ioffset - 5, 5);
      ioffset -= 5;
      switch (addr_mode)
	{
	case 0x0: case 0x1: case 0x2: case 0x3:
	case 0x4: case 0x5: case 0x6: case 0x7:
	  /* Register mode R0 -- R7.  */
	  switch (d)
	    {
	    case 'F':
	    case 'L':
	    case 'Z':
	      sprintf (result, "f%d", addr_mode);
	      break;
	    default:
	      sprintf (result, "r%d", addr_mode);
	    }
	  break;
	case 0x8: case 0x9: case 0xa: case 0xb:
	case 0xc: case 0xd: case 0xe: case 0xf:
	  /* Register relative disp(R0 -- R7).  */
	  disp1 = get_displacement (buffer, aoffsetp);
	  sprintf (result, "%d(r%d)", disp1, addr_mode & 7);
	  break;
	case 0x10:
	case 0x11:
	case 0x12:
	  /* Memory relative disp2(disp1(FP, SP, SB)).  */
	  disp1 = get_displacement (buffer, aoffsetp);
	  disp2 = get_displacement (buffer, aoffsetp);
	  sprintf (result, "%d(%d(%s))", disp2, disp1,
		   addr_mode == 0x10 ? "fp" : addr_mode == 0x11 ? "sp" : "sb");
	  break;
	case 0x13:
	  /* Reserved.  */
	  sprintf (result, "reserved");
	  break;
	case 0x14:
	  /* Immediate.  */
	  switch (d)
	    {
	    case 'I':
	    case 'Z':
	    case 'A':
	      /* I and Z are output operands and can`t be immediate
	         A is an address and we can`t have the address of
	         an immediate either. We don't know how much to increase
	         aoffsetp by since whatever generated this is broken
	         anyway!  */
	      sprintf (result, _("$<undefined>"));
	      break;
	    case 'B':
	      Ivalue = bit_extract (buffer, *aoffsetp, 8);
	      Ivalue = sign_extend (Ivalue, 8);
	      *aoffsetp += 8;
	      sprintf (result, "$%d", Ivalue);
	      break;
	    case 'W':
	      Ivalue = bit_extract (buffer, *aoffsetp, 16);
	      flip_bytes ((char *) & Ivalue, 2);
	      *aoffsetp += 16;
	      Ivalue = sign_extend (Ivalue, 16);
	      sprintf (result, "$%d", Ivalue);
	      break;
	    case 'D':
	      Ivalue = bit_extract (buffer, *aoffsetp, 32);
	      flip_bytes ((char *) & Ivalue, 4);
	      *aoffsetp += 32;
	      sprintf (result, "$%d", Ivalue);
	      break;
	    case 'F':
	      bit_copy (buffer, *aoffsetp, 32, (char *) &value.f);
	      flip_bytes ((char *) &value.f, 4);
	      *aoffsetp += 32;
	      if (INVALID_FLOAT (&value.f, 4))
		sprintf (result, "<<invalid float 0x%.8x>>", value.i[0]);
	      else /* Assume host has ieee float.  */
		sprintf (result, "$%g", value.f);
	      break;
	    case 'L':
	      bit_copy (buffer, *aoffsetp, 64, (char *) &value.d);
	      flip_bytes ((char *) &value.d, 8);
	      *aoffsetp += 64;
	      if (INVALID_FLOAT (&value.d, 8))
		sprintf (result, "<<invalid double 0x%.8x%.8x>>",
			 value.i[1], value.i[0]);
	      else /* Assume host has ieee float.  */
		sprintf (result, "$%g", value.d);
	      break;
	    }
	  break;
	case 0x15:
	  /* Absolute @@disp.  */
	  disp1 = get_displacement (buffer, aoffsetp);
	  sprintf (result, "@@|%d|", disp1);
	  break;
	case 0x16:
	  /* External EXT(disp1) + disp2 (Mod table stuff).  */
	  disp1 = get_displacement (buffer, aoffsetp);
	  disp2 = get_displacement (buffer, aoffsetp);
	  sprintf (result, "EXT(%d) + %d", disp1, disp2);
	  break;
	case 0x17:
	  /* Top of stack tos.  */
	  sprintf (result, "tos");
	  break;
	case 0x18:
	  /* Memory space disp(FP).  */
	  disp1 = get_displacement (buffer, aoffsetp);
	  sprintf (result, "%d(fp)", disp1);
	  break;
	case 0x19:
	  /* Memory space disp(SP).  */
	  disp1 = get_displacement (buffer, aoffsetp);
	  sprintf (result, "%d(sp)", disp1);
	  break;
	case 0x1a:
	  /* Memory space disp(SB).  */
	  disp1 = get_displacement (buffer, aoffsetp);
	  sprintf (result, "%d(sb)", disp1);
	  break;
	case 0x1b:
	  /* Memory space disp(PC).  */
	  disp1 = get_displacement (buffer, aoffsetp);
	  *result++ = NEXT_IS_ADDR;
	  sprintf_vma (result, addr + disp1);
	  result += strlen (result);
	  *result++ = NEXT_IS_ADDR;
	  *result = '\0';
	  break;
	case 0x1c:
	case 0x1d:
	case 0x1e:
	case 0x1f:
	  {
	    int bit_index;
	    static const char *ind = "bwdq";
	    char *off;
	    
	    /* Scaled index basemode[R0 -- R7:B,W,D,Q].  */
	    bit_index = bit_extract (buffer, index_offset - 8, 3);
	    print_insn_arg (d, index_offset, aoffsetp, buffer, addr,
			    result, 0);
	    off = result + strlen (result);
	    sprintf (off, "[r%d:%c]", bit_index, ind[addr_mode & 3]);
	  }
	  break;
	}
      break;
    case 'H':
    case 'q':
      Ivalue = bit_extract (buffer, ioffset-4, 4);
      Ivalue = sign_extend (Ivalue, 4);
      sprintf (result, "%d", Ivalue);
      ioffset -= 4;
      break;
    case 'r':
      Ivalue = bit_extract (buffer, ioffset-3, 3);
      sprintf (result, "r%d", Ivalue&7);
      ioffset -= 3;
      break;
    case 'd':
      sprintf (result, "%d", get_displacement (buffer, aoffsetp));
      break;
    case 'b':
      Ivalue = get_displacement (buffer, aoffsetp);
      /* Warning!!  HACK ALERT!
         Operand type 'b' is only used by the cmp{b,w,d} and
         movm{b,w,d} instructions; we need to know whether
         it's a `b' or `w' or `d' instruction; and for both
         cmpm and movm it's stored at the same place so we
         just grab two bits of the opcode and look at it...  */
      size = bit_extract(buffer, ioffset-6, 2);
      if (size == 0)		/* 00 => b.  */
	size = 1;
      else if (size == 1)	/* 01 => w.  */
	size = 2;
      else
	size = 4;		/* 11 => d.  */

      sprintf (result, "%d", (Ivalue / size) + 1);
      break;
    case 'p':
      *result++ = NEXT_IS_ADDR;
      sprintf_vma (result, addr + get_displacement (buffer, aoffsetp));
      result += strlen (result);
      *result++ = NEXT_IS_ADDR;
      *result = '\0';
      break;
    case 'i':
      Ivalue = bit_extract (buffer, *aoffsetp, 8);
      *aoffsetp += 8;
      sprintf (result, "0x%x", Ivalue);
      break;
    case 'u':
      Ivalue = bit_extract (buffer, *aoffsetp, 8);
      optlist (Ivalue, opt_u, result);
      *aoffsetp += 8;
      break;
    case 'U':
      Ivalue = bit_extract (buffer, *aoffsetp, 8);
      optlist (Ivalue, opt_U, result);
      *aoffsetp += 8;
      break;
    case 'O':
      Ivalue = bit_extract (buffer, ioffset - 9, 9);
      optlist (Ivalue, opt_O, result);
      ioffset -= 9;
      break;
    case 'C':
      Ivalue = bit_extract (buffer, ioffset - 4, 4);
      optlist (Ivalue, opt_C, result);
      ioffset -= 4;
      break;
    case 'S':
      Ivalue = bit_extract (buffer, ioffset - 8, 8);
      optlist (Ivalue, opt_S, result);
      ioffset -= 8;
      break;
    case 'M':
      Ivalue = bit_extract (buffer, ioffset - 4, 4);
      list_search (Ivalue, 0 ? list_M032 : list_M532, result);
      ioffset -= 4;
      break;
    case 'P':
      Ivalue = bit_extract (buffer, ioffset - 4, 4);
      list_search (Ivalue, 0 ? list_P032 : list_P532, result);
      ioffset -= 4;
      break;
    case 'g':
      Ivalue = bit_extract (buffer, *aoffsetp, 3);
      sprintf (result, "%d", Ivalue);
      *aoffsetp += 3;
      break;
    case 'G':
      Ivalue = bit_extract(buffer, *aoffsetp, 5);
      sprintf (result, "%d", Ivalue + 1);
      *aoffsetp += 5;
      break;
    }
  return ioffset;
}


/* Print the 32000 instruction at address MEMADDR in debugged memory,
   on STREAM.  Returns length of the instruction, in bytes.  */

int
print_insn_ns32k (bfd_vma memaddr, disassemble_info *info)
{
  unsigned int i;
  const char *d;
  unsigned short first_word;
  int ioffset;		/* Bits into instruction.  */
  int aoffset;		/* Bits into arguments.  */
  char arg_bufs[MAX_ARGS+1][ARG_LEN];
  int argnum;
  int maxarg;
  struct private priv;
  bfd_byte *buffer = priv.the_buffer;
  dis_info = info;

  info->private_data = & priv;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = memaddr;
  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;

  /* Look for 8bit opcodes first. Other wise, fetching two bytes could take
     us over the end of accessible data unnecessarilly.  */
  FETCH_DATA (info, buffer + 1);
  for (i = 0; i < NOPCODES; i++)
    if (ns32k_opcodes[i].opcode_id_size <= 8
	&& ((buffer[0]
	     & (((unsigned long) 1 << ns32k_opcodes[i].opcode_id_size) - 1))
	    == ns32k_opcodes[i].opcode_seed))
      break;
  if (i == NOPCODES)
    {
      /* Maybe it is 9 to 16 bits big.  */
      FETCH_DATA (info, buffer + 2);
      first_word = read_memory_integer(buffer, 2);

      for (i = 0; i < NOPCODES; i++)
	if ((first_word
	     & (((unsigned long) 1 << ns32k_opcodes[i].opcode_id_size) - 1))
	    == ns32k_opcodes[i].opcode_seed)
	  break;

      /* Handle undefined instructions.  */
      if (i == NOPCODES)
	{
	  (*dis_info->fprintf_func)(dis_info->stream, "0%o", buffer[0]);
	  return 1;
	}
    }

  (*dis_info->fprintf_func)(dis_info->stream, "%s", ns32k_opcodes[i].name);

  ioffset = ns32k_opcodes[i].opcode_size;
  aoffset = ns32k_opcodes[i].opcode_size;
  d = ns32k_opcodes[i].operands;

  if (*d)
    {
      /* Offset in bits of the first thing beyond each index byte.
	 Element 0 is for operand A and element 1 is for operand B.
	 The rest are irrelevant, but we put them here so we don't
	 index outside the array.  */
      int index_offset[MAX_ARGS];

      /* 0 for operand A, 1 for operand B, greater for other args.  */
      int whicharg = 0;
      
      (*dis_info->fprintf_func)(dis_info->stream, "\t");

      maxarg = 0;

      /* First we have to find and keep track of the index bytes,
	 if we are using scaled indexed addressing mode, since the index
	 bytes occur right after the basic instruction, not as part
	 of the addressing extension.  */
      if (Is_gen(d[1]))
	{
	  int addr_mode = bit_extract (buffer, ioffset - 5, 5);

	  if (Adrmod_is_index (addr_mode))
	    {
	      aoffset += 8;
	      index_offset[0] = aoffset;
	    }
	}

      if (d[2] && Is_gen(d[3]))
	{
	  int addr_mode = bit_extract (buffer, ioffset - 10, 5);

	  if (Adrmod_is_index (addr_mode))
	    {
	      aoffset += 8;
	      index_offset[1] = aoffset;
	    }
	}

      while (*d)
	{
	  argnum = *d - '1';
	  d++;
	  if (argnum > maxarg && argnum < MAX_ARGS)
	    maxarg = argnum;
	  ioffset = print_insn_arg (*d, ioffset, &aoffset, buffer,
				    memaddr, arg_bufs[argnum],
				    index_offset[whicharg]);
	  d++;
	  whicharg++;
	}
      for (argnum = 0; argnum <= maxarg; argnum++)
	{
	  bfd_vma addr;
	  char *ch;

	  for (ch = arg_bufs[argnum]; *ch;)
	    {
	      if (*ch == NEXT_IS_ADDR)
		{
		  ++ch;
		  addr = bfd_scan_vma (ch, NULL, 16);
		  (*dis_info->print_address_func) (addr, dis_info);
		  while (*ch && *ch != NEXT_IS_ADDR)
		    ++ch;
		  if (*ch)
		    ++ch;
		}
	      else
		(*dis_info->fprintf_func)(dis_info->stream, "%c", *ch++);
	    }
	  if (argnum < maxarg)
	    (*dis_info->fprintf_func)(dis_info->stream, ", ");
	}
    }
  return aoffset / 8;
}
@


1.11
log
@Change source files over to GPLv3.
@
text
@d2 2
a3 2
   Copyright 1986, 1988, 1991, 1992, 1994, 1998, 2001, 2002, 2005, 2007
   Free Software Foundation, Inc.
a468 1
  int index;
a617 4
	  /* Scaled index basemode[R0 -- R7:B,W,D,Q].  */
	  index = bit_extract (buffer, index_offset - 8, 3);
	  print_insn_arg (d, index_offset, aoffsetp, buffer, addr,
			  result, 0);
d619 1
d622 5
a626 1

d628 1
a628 2
	    sprintf (off, "[r%d:%c]", index,
		     ind[addr_mode & 3]);
@


1.10
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5 1
a5 1
   This file is part of opcodes library.
d7 1
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
a21 1

@


1.9
log
@Update function declarations to ISO C90 formatting
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1991, 1992, 1994, 1998, 2001, 2002, 2005
d23 1
a24 1
#include "sysdep.h"
@


1.8
log
@Update the address and phone number of the FSF
@
text
@d5 1
a5 1
This file is part of opcodes library.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d34 5
a38 23
/*
 * Hacks to get it to compile <= READ THESE AS FIXES NEEDED
 */
#define INVALID_FLOAT(val, size) invalid_float((bfd_byte *)val, size)

static int print_insn_arg
  PARAMS ((int, int, int *, bfd_byte *, bfd_vma, char *, int));
static int get_displacement PARAMS ((bfd_byte *, int *));
static int invalid_float PARAMS ((bfd_byte *, int));
static long int read_memory_integer PARAMS ((unsigned char *, int));
static int fetch_data PARAMS ((struct disassemble_info *, bfd_byte *));
struct ns32k_option;
static void optlist PARAMS ((int, const struct ns32k_option *, char *));
static void list_search PARAMS ((int, const struct ns32k_option *, char *));
static int bit_extract PARAMS ((bfd_byte *, int, int));
static int bit_extract_simple PARAMS ((bfd_byte *, int, int));
static void bit_copy PARAMS ((bfd_byte *, int, int, char *));
static int sign_extend PARAMS ((int, int));
static void flip_bytes PARAMS ((char *, int));

static long read_memory_integer(addr, nr)
     unsigned char *addr;
     int nr;
d42 6
a47 4
  for (val = 0, i = nr - 1; i >= 0; i--) {
    val =  (val << 8);
    val |= (0xff & *(addr + i));
  }
a53 1

d74 1
a74 3
fetch_data (info, addr)
     struct disassemble_info *info;
     bfd_byte *addr;
d77 1
a77 1
  struct private *priv = (struct private *)info->private_data;
d93 1
d100 5
a104 4
struct ns32k_option {
  char *pattern;		/* the option itself */
  unsigned long value;		/* binary value of the option */
  unsigned long match;		/* these bits must match */
d108 1
a108 1
static const struct ns32k_option opt_u[]= /* restore, exit */
d121 1
a121 1
static const struct ns32k_option opt_U[]= /* save, enter */
d134 1
a134 1
static const struct ns32k_option opt_O[]= /* setcfg */
d143 1
a143 1
static const struct ns32k_option opt_C[]= /* cinv */
d151 1
a151 1
static const struct ns32k_option opt_S[]= /* string inst */
d159 1
a159 1
static const struct ns32k_option list_P532[]= /* lpr spr */
d177 1
a177 1
static const struct ns32k_option list_M532[]= /* lmr smr */
d189 1
a189 1
static const struct ns32k_option list_P032[]= /* lpr spr */
d201 1
a201 1
static const struct ns32k_option list_M032[]= /* lmr smr */
d217 2
a218 3
/*
 * figure out which options are present
 */
d220 19
a238 18
optlist(options, optionP, result)
     int options;
     const struct ns32k_option *optionP;
     char *result;
{
    if (options == 0) {
	sprintf(result, "[]");
	return;
    }
    sprintf(result, "[");

    for (; (options != 0) && optionP->pattern; optionP++) {
	if ((options & optionP->match) == optionP->value) {
	    /* we found a match, update result and options */
	    strcat(result, optionP->pattern);
	    options &= ~optionP->value;
	    if (options != 0)	/* more options to come */
		strcat(result, ",");
a240 2
    if (options != 0)
	strcat(result, "undefined");
d242 4
a245 1
    strcat(result, "]");
d249 8
a256 9
list_search (reg_value, optionP, result)
     int reg_value;
     const struct ns32k_option *optionP;
     char *result;
{
    for (; optionP->pattern; optionP++) {
	if ((reg_value & optionP->match) == optionP->value) {
	    sprintf(result, "%s", optionP->pattern);
	    return;
d259 1
a259 1
    sprintf(result, "undefined");
d262 1
a262 4
/*
 * extract "count" bits starting "offset" bits
 * into buffer
 */
d265 1
a265 4
bit_extract (buffer, offset, count)
     bfd_byte *buffer;
     int offset;
     int count;
d276 1
a276 1
      FETCH_DATA(dis_info, buffer + 1);
d289 2
a290 3
/* Like bit extract but the buffer is valid and doen't need to be
 * fetched
 */
d292 1
a292 4
bit_extract_simple (buffer, offset, count)
     bfd_byte *buffer;
     int offset;
     int count;
d316 1
a316 5
bit_copy (buffer, offset, count, to)
     bfd_byte *buffer;
     int offset;
     int count;
     char *to;
d318 1
a318 1
  for(; count > 8; count -= 8, to++, offset += 8)
a322 1

d324 1
a324 2
sign_extend (value, bits)
     int value, bits;
d327 1
a327 1
  return (value & (1 << (bits-1))
d333 1
a333 3
flip_bytes (ptr, count)
     char *ptr;
     int count;
d340 2
a341 2
      ptr[0] = ptr[count-1];
      ptr[count-1] = tmp;
d353 4
a356 4
#define Adrmod_index_byte 0x1c
#define Adrmod_index_word 0x1d
#define Adrmod_index_doubleword 0x1e
#define Adrmod_index_quadword 0x1f
d360 1
a360 1
  (mode == Adrmod_index_byte \
d366 2
a367 7
/* Print the 32000 instruction at address MEMADDR in debugged memory,
   on STREAM.  Returns length of the instruction, in bytes.  */

int
print_insn_ns32k (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d369 2
a370 11
  unsigned int i;
  const char *d;
  unsigned short first_word;
  int ioffset;		/* bits into instruction */
  int aoffset;		/* bits into arguments */
  char arg_bufs[MAX_ARGS+1][ARG_LEN];
  int argnum;
  int maxarg;
  struct private priv;
  bfd_byte *buffer = priv.the_buffer;
  dis_info = info;
d372 19
a390 16
  info->private_data = (PTR) &priv;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = memaddr;
  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;

  /* Look for 8bit opcodes first. Other wise, fetching two bytes could take
   * us over the end of accessible data unnecessarilly
   */
  FETCH_DATA(info, buffer + 1);
  for (i = 0; i < NOPCODES; i++)
    if (ns32k_opcodes[i].opcode_id_size <= 8
	&& ((buffer[0]
	     & (((unsigned long) 1 << ns32k_opcodes[i].opcode_id_size) - 1))
	    == ns32k_opcodes[i].opcode_seed))
d392 3
a394 18
  if (i == NOPCODES) {
    /* Maybe it is 9 to 16 bits big */
    FETCH_DATA(info, buffer + 2);
    first_word = read_memory_integer(buffer, 2);

    for (i = 0; i < NOPCODES; i++)
      if ((first_word
	   & (((unsigned long) 1 << ns32k_opcodes[i].opcode_id_size) - 1))
	  == ns32k_opcodes[i].opcode_seed)
	break;

    /* Handle undefined instructions.  */
    if (i == NOPCODES)
      {
	(*dis_info->fprintf_func)(dis_info->stream, "0%o", buffer[0]);
	return 1;
      }
  }
d396 5
a400 1
  (*dis_info->fprintf_func)(dis_info->stream, "%s", ns32k_opcodes[i].name);
d402 22
a423 3
  ioffset = ns32k_opcodes[i].opcode_size;
  aoffset = ns32k_opcodes[i].opcode_size;
  d = ns32k_opcodes[i].operands;
d425 4
a428 7
  if (*d)
    {
      /* Offset in bits of the first thing beyond each index byte.
	 Element 0 is for operand A and element 1 is for operand B.
	 The rest are irrelevant, but we put them here so we don't
	 index outside the array.  */
      int index_offset[MAX_ARGS];
d430 9
a438 68
      /* 0 for operand A, 1 for operand B, greater for other args.  */
      int whicharg = 0;
      
      (*dis_info->fprintf_func)(dis_info->stream, "\t");

      maxarg = 0;

      /* First we have to find and keep track of the index bytes,
	 if we are using scaled indexed addressing mode, since the index
	 bytes occur right after the basic instruction, not as part
	 of the addressing extension.  */
      if (Is_gen(d[1]))
	{
	  int addr_mode = bit_extract (buffer, ioffset - 5, 5);

	  if (Adrmod_is_index (addr_mode))
	    {
	      aoffset += 8;
	      index_offset[0] = aoffset;
	    }
	}
      if (d[2] && Is_gen(d[3]))
	{
	  int addr_mode = bit_extract (buffer, ioffset - 10, 5);

	  if (Adrmod_is_index (addr_mode))
	    {
	      aoffset += 8;
	      index_offset[1] = aoffset;
	    }
	}

      while (*d)
	{
	  argnum = *d - '1';
	  d++;
	  if (argnum > maxarg && argnum < MAX_ARGS)
	    maxarg = argnum;
	  ioffset = print_insn_arg (*d, ioffset, &aoffset, buffer,
				    memaddr, arg_bufs[argnum],
				    index_offset[whicharg]);
	  d++;
	  whicharg++;
	}
      for (argnum = 0; argnum <= maxarg; argnum++)
	{
	  bfd_vma addr;
	  char *ch;
	  for (ch = arg_bufs[argnum]; *ch;)
	    {
	      if (*ch == NEXT_IS_ADDR)
		{
		  ++ch;
		  addr = bfd_scan_vma (ch, NULL, 16);
		  (*dis_info->print_address_func) (addr, dis_info);
		  while (*ch && *ch != NEXT_IS_ADDR)
		    ++ch;
		  if (*ch)
		    ++ch;
		}
	      else
		(*dis_info->fprintf_func)(dis_info->stream, "%c", *ch++);
	    }
	  if (argnum < maxarg)
	    (*dis_info->fprintf_func)(dis_info->stream, ", ");
	}
    }
  return aoffset / 8;
d440 1
d453 7
a459 7
print_insn_arg (d, ioffset, aoffsetp, buffer, addr, result, index_offset)
     int d;
     int ioffset, *aoffsetp;
     bfd_byte *buffer;
     bfd_vma addr;
     char *result;
     int index_offset;
d461 2
a462 1
  union {
d476 1
a476 1
      /* a "gen" operand but 5 bits from the end of instruction */
d486 1
a486 1
      addr_mode = bit_extract (buffer, ioffset-5, 5);
d492 1
a492 1
	  /* register mode R0 -- R7 */
d506 1
a506 1
	  /* Register relative disp(R0 -- R7) */
d513 1
a513 1
	  /* Memory relative disp2(disp1(FP, SP, SB)) */
d517 1
a517 1
		   addr_mode==0x10?"fp":addr_mode==0x11?"sp":"sb");
d520 1
a520 1
	  /* reserved */
d524 1
a524 1
	  /* Immediate */
d527 3
a529 1
	    case 'I': case 'Z': case 'A':
d531 4
a534 5
	       * A is an address and we can`t have the address of
	       * an immediate either. We don't know how much to increase
	       * aoffsetp by since whatever generated this is broken
	       * anyway!
	       */
d562 1
a562 1
	      else /* assume host has ieee float */
d572 1
a572 1
	      else /* assume host has ieee float */
d578 1
a578 1
	  /* Absolute @@disp */
d583 1
a583 1
	  /* External EXT(disp1) + disp2 (Mod table stuff) */
d589 1
a589 1
	  /* Top of stack tos */
d593 1
a593 1
	  /* Memory space disp(FP) */
d598 1
a598 1
	  /* Memory space disp(SP) */
d603 1
a603 1
	  /* Memory space disp(SB) */
d608 1
a608 1
	  /* Memory space disp(PC) */
d620 1
a620 1
	  /* Scaled index basemode[R0 -- R7:B,W,D,Q] */
d652 6
a657 9
      /*
       * Warning!!  HACK ALERT!
       * Operand type 'b' is only used by the cmp{b,w,d} and
       * movm{b,w,d} instructions; we need to know whether
       * it's a `b' or `w' or `d' instruction; and for both
       * cmpm and movm it's stored at the same place so we
       * just grab two bits of the opcode and look at it...
       * 
       */
d659 1
a659 1
      if (size == 0)		/* 00 => b */
d661 1
a661 1
      else if (size == 1)	/* 01 => w */
d664 1
a664 1
	size = 4;		/* 11 => d */
d682 1
a682 1
      optlist(Ivalue, opt_u, result);
d686 2
a687 2
      Ivalue = bit_extract(buffer, *aoffsetp, 8);
      optlist(Ivalue, opt_U, result);
d691 2
a692 2
      Ivalue = bit_extract(buffer, ioffset-9, 9);
      optlist(Ivalue, opt_O, result);
d696 2
a697 2
      Ivalue = bit_extract(buffer, ioffset-4, 4);
      optlist(Ivalue, opt_C, result);
d701 2
a702 2
      Ivalue = bit_extract(buffer, ioffset - 8, 8);
      optlist(Ivalue, opt_S, result);
d706 2
a707 2
      Ivalue = bit_extract(buffer, ioffset-4, 4);
      list_search(Ivalue, 0 ? list_M032 : list_M532, result);
d711 2
a712 2
      Ivalue = bit_extract(buffer, ioffset-4, 4);
      list_search(Ivalue, 0 ? list_P032 : list_P532, result);
d716 2
a717 2
      Ivalue = bit_extract(buffer, *aoffsetp, 3);
      sprintf(result, "%d", Ivalue);
d722 1
a722 1
      sprintf(result, "%d", Ivalue + 1);
d729 6
a734 4
static int
get_displacement (buffer, aoffsetp)
     bfd_byte *buffer;
     int *aoffsetp;
d736 18
a753 2
  int Ivalue;
  short Ivalue2;
d755 10
a764 2
  Ivalue = bit_extract (buffer, *aoffsetp, 8);
  switch (Ivalue & 0xc0)
d766 16
a781 17
    case 0x00:
    case 0x40:
      Ivalue = sign_extend (Ivalue, 7);
      *aoffsetp += 8;
      break;
    case 0x80:
      Ivalue2 = bit_extract (buffer, *aoffsetp, 16);
      flip_bytes ((char *) & Ivalue2, 2);
      Ivalue = sign_extend (Ivalue2, 14);
      *aoffsetp += 16;
      break;
    case 0xc0:
      Ivalue = bit_extract (buffer, *aoffsetp, 32);
      flip_bytes ((char *) & Ivalue, 4);
      Ivalue = sign_extend (Ivalue, 30);
      *aoffsetp += 32;
      break;
a782 3
  return Ivalue;
}

d784 39
a822 22
#if 1 /* a version that should work on ns32k f's&d's on any machine */
static int
invalid_float (p, len)
     register bfd_byte *p;
     register int len;
{
  register int val;

  if ( len == 4 )
    val = (bit_extract_simple(p, 23, 8)/*exponent*/ == 0xff
	   || (bit_extract_simple(p, 23, 8)/*exponent*/ == 0 &&
	       bit_extract_simple(p, 0, 23)/*mantisa*/ != 0));
  else if ( len == 8 )
    val = (bit_extract_simple(p, 52, 11)/*exponent*/ == 0x7ff
	   || (bit_extract_simple(p, 52, 11)/*exponent*/ == 0
	       && (bit_extract_simple(p, 0, 32)/*low mantisa*/ != 0
		   || bit_extract_simple(p, 32, 20)/*high mantisa*/ != 0)));
  else
    val = 1;
  return (val);
}
#else
d824 6
a829 6
/* assumes the bytes have been swapped to local order */
typedef union { double d;
		float f;
		struct { unsigned m:23, e:8, :1;} sf;
		struct { unsigned lm; unsigned m:20, e:11, :1;} sd;
	      } float_type_u;
d831 37
a867 15
static int
invalid_float (p, len)
     register float_type_u *p;
     register int len;
{
  register int val;
  if ( len == sizeof (float) )
    val = (p->sf.e == 0xff
	   || (p->sf.e == 0 && p->sf.m != 0));
  else if ( len == sizeof (double) )
    val = (p->sd.e == 0x7ff
	   || (p->sd.e == 0 && (p->sd.m != 0 || p->sd.lm != 0)));
  else
    val = 1;
  return (val);
a868 1
#endif
@


1.7
log
@	* arc-ext.c: Warning fixes.
	* arc-ext.h: Likewise.
	* cgen-opc.c: Likewise.
	* ia64-gen.c: Likewise.
	* maxq-dis.c: Likewise.
	* ns32k-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* ia64-asmtab.c: Regenerate.
@
text
@d19 1
a19 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.6
log
@	* ns32k-dis.c (print_insn_ns32k): Constify "d", remove register
	keyword.
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1991, 1992, 1994, 1998, 2001, 2002
d36 1
a36 1
#define INVALID_FLOAT(val, size) invalid_float((char *)val, size)
d39 3
a41 3
  PARAMS ((int, int, int *, char *, bfd_vma, char *, int));
static int get_displacement PARAMS ((char *, int *));
static int invalid_float PARAMS ((char *, int));
d49 1
a49 1
static void bit_copy PARAMS ((char *, int, int, char *));
d343 1
a343 1
     char *buffer;
d554 1
a554 1
     char *buffer;
d830 1
a830 1
     char *buffer;
d864 1
a864 1
     register char *p;
@


1.5
log
@	* arm-dis.c (print_insn_arm): Constify "insn".  Formatting.
	(print_insn_thumb): Likewise.
	* h8500-dis.c (print_insn_h8500): Constify "opcode".
	* mcore-dis.c (print_insn_mcore): Constify "op".  Formatting.
	* ns32k-dis.c (print_insn_arg <case 'F'>): Use a union to avoid
	type-punned pointer warnings.
	<case 'L'>: Likewise.  Fix error message too.
	* pdp11-dis.c (print_reg): Warning fix.
	* sh-dis.c (print_movxy): Constify "op" param.
	(print_insn_ddt): Constify sh_opcode_info vars.
	(print_insn_ppi): Likewise.
	(print_insn_sh): Likewise.
	* tic30-dis.c (cnvt_tmsfloat_ieee): Use a union to avoid
	type-punned pointer warnings.
	* w65-dis.c (print_insn_w65): Constify "op".
@
text
@d408 2
a409 2
  register unsigned int i;
  register char *d;
@


1.4
log
@Fix compile time warnings
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1991, 1992, 1994, 1998, 2001
d559 6
a565 3
  float Fvalue;
  double Lvalue;
  int Ivalue;
d653 2
a654 2
	      bit_copy (buffer, *aoffsetp, 32, (char *) &Fvalue);
	      flip_bytes ((char *) & Fvalue, 4);
d656 2
a657 2
	      if (INVALID_FLOAT (&Fvalue, 4))
		sprintf (result, "<<invalid float 0x%.8x>>", *(int *) &Fvalue);
d659 1
a659 1
		sprintf (result, "$%g", Fvalue);
d662 2
a663 2
	      bit_copy (buffer, *aoffsetp, 64, (char *) &Lvalue);
	      flip_bytes ((char *) & Lvalue, 8);
d665 3
a667 3
	      if (INVALID_FLOAT (&Lvalue, 8))
		sprintf (result, "<<invalid long 0x%.8x%.8x>>",
			 *(((int *) &Lvalue) + 1), *(int *) &Lvalue);
d669 1
a669 1
		sprintf (result, "$%g", Lvalue);
@


1.4.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1991, 1992, 1994, 1998, 2001, 2002
d408 2
a409 2
  unsigned int i;
  const char *d;
d559 3
a561 5
  union {
    float f;
    double d;
    int i[2];
  } value;
a562 1
  int addr_mode;
d650 2
a651 2
	      bit_copy (buffer, *aoffsetp, 32, (char *) &value.f);
	      flip_bytes ((char *) &value.f, 4);
d653 2
a654 2
	      if (INVALID_FLOAT (&value.f, 4))
		sprintf (result, "<<invalid float 0x%.8x>>", value.i[0]);
d656 1
a656 1
		sprintf (result, "$%g", value.f);
d659 2
a660 2
	      bit_copy (buffer, *aoffsetp, 64, (char *) &value.d);
	      flip_bytes ((char *) &value.d, 8);
d662 3
a664 3
	      if (INVALID_FLOAT (&value.d, 8))
		sprintf (result, "<<invalid double 0x%.8x%.8x>>",
			 value.i[1], value.i[0]);
d666 1
a666 1
		sprintf (result, "$%g", value.d);
@


1.4.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1991, 1992, 1994, 1998, 2001, 2002
d408 2
a409 2
  unsigned int i;
  const char *d;
d559 3
a561 5
  union {
    float f;
    double d;
    int i[2];
  } value;
a562 1
  int addr_mode;
d650 2
a651 2
	      bit_copy (buffer, *aoffsetp, 32, (char *) &value.f);
	      flip_bytes ((char *) &value.f, 4);
d653 2
a654 2
	      if (INVALID_FLOAT (&value.f, 4))
		sprintf (result, "<<invalid float 0x%.8x>>", value.i[0]);
d656 1
a656 1
		sprintf (result, "$%g", value.f);
d659 2
a660 2
	      bit_copy (buffer, *aoffsetp, 64, (char *) &value.d);
	      flip_bytes ((char *) &value.d, 8);
d662 3
a664 3
	      if (INVALID_FLOAT (&value.d, 8))
		sprintf (result, "<<invalid double 0x%.8x%.8x>>",
			 value.i[1], value.i[0]);
d666 1
a666 1
		sprintf (result, "$%g", value.d);
@


1.3
log
@For include/opcode:
	* d30v.h: Fix declaration of reg_name_cnt.

	* d10v.h: Fix declaration of d10v_reg_name_cnt.

	* arc.h: Add prototypes from opcodes/arc-opc.c.

For opcodes:
	* tic54x-dis.c: Add unused attributes where needed.

	* z8k-dis.c (output_instr): Add unused attribute.

	* h8300-dis.c: Add missing prototypes.
	(bfd_h8_disassemble): Make static.

	* cris-dis.c: Add missing prototype.
	* h8500-dis.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* z8k-dis.c: Likewise.

	* d10v-dis.c: Add missing prototype.
	(dis_long): Remove unused variable.
	(dis_2_short): Likewise.

	* sh-dis.c: Add missing prototypes.
	* v850-opc.c: Likewise.
	Add unused attributes where needed.

	* ns32k-dis.c: Add missing prototypes.
	(bit_extract_simple): Remove unused variable.
@
text
@d638 1
a638 1
	      flip_bytes (&Ivalue, 2);
d645 1
a645 1
	      flip_bytes (&Ivalue, 4);
d651 1
a651 1
	      flip_bytes (&Fvalue, 4);
d660 1
a660 1
	      flip_bytes (&Lvalue, 8);
d843 1
a843 1
      flip_bytes (&Ivalue2, 2);
d849 1
a849 1
      flip_bytes (&Ivalue, 4);
@


1.2
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 1986, 1988, 1991, 1992, 1994, 1998
d42 10
a320 1
  int mask;
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (c) 1986, 88, 91, 92, 94, 95, 1998 Free Software Foundation, Inc.
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.8.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1986, 1988, 1991, 1992, 1994, 1998
   Free Software Foundation, Inc.
@


