head	1.38;
access;
symbols
	sid-snapshot-20180601:1.38
	sid-snapshot-20180501:1.38
	sid-snapshot-20180401:1.38
	sid-snapshot-20180301:1.38
	sid-snapshot-20180201:1.38
	sid-snapshot-20180101:1.38
	sid-snapshot-20171201:1.38
	sid-snapshot-20171101:1.38
	sid-snapshot-20171001:1.38
	sid-snapshot-20170901:1.38
	sid-snapshot-20170801:1.38
	sid-snapshot-20170701:1.38
	sid-snapshot-20170601:1.38
	sid-snapshot-20170501:1.38
	sid-snapshot-20170401:1.38
	sid-snapshot-20170301:1.38
	sid-snapshot-20170201:1.38
	sid-snapshot-20170101:1.38
	sid-snapshot-20161201:1.38
	sid-snapshot-20161101:1.38
	sid-snapshot-20160901:1.38
	sid-snapshot-20160801:1.38
	sid-snapshot-20160701:1.38
	sid-snapshot-20160601:1.38
	sid-snapshot-20160501:1.38
	sid-snapshot-20160401:1.38
	sid-snapshot-20160301:1.38
	sid-snapshot-20160201:1.38
	sid-snapshot-20160101:1.38
	sid-snapshot-20151201:1.38
	sid-snapshot-20151101:1.38
	sid-snapshot-20151001:1.38
	sid-snapshot-20150901:1.38
	sid-snapshot-20150801:1.38
	sid-snapshot-20150701:1.38
	sid-snapshot-20150601:1.38
	sid-snapshot-20150501:1.38
	sid-snapshot-20150401:1.38
	sid-snapshot-20150301:1.38
	sid-snapshot-20150201:1.38
	sid-snapshot-20150101:1.38
	sid-snapshot-20141201:1.38
	sid-snapshot-20141101:1.38
	sid-snapshot-20141001:1.38
	sid-snapshot-20140901:1.38
	sid-snapshot-20140801:1.38
	sid-snapshot-20140701:1.38
	sid-snapshot-20140601:1.38
	sid-snapshot-20140501:1.38
	sid-snapshot-20140401:1.38
	sid-snapshot-20140301:1.38
	sid-snapshot-20140201:1.38
	sid-snapshot-20140101:1.38
	sid-snapshot-20131201:1.38
	sid-snapshot-20131101:1.38
	sid-snapshot-20131001:1.38
	binutils-2_24-branch:1.38.0.6
	binutils-2_24-branchpoint:1.38
	binutils-2_21_1:1.37
	sid-snapshot-20130901:1.38
	gdb_7_6_1-2013-08-30-release:1.38
	sid-snapshot-20130801:1.38
	sid-snapshot-20130701:1.38
	sid-snapshot-20130601:1.38
	sid-snapshot-20130501:1.38
	gdb_7_6-2013-04-26-release:1.38
	sid-snapshot-20130401:1.38
	binutils-2_23_2:1.38
	gdb_7_6-branch:1.38.0.4
	gdb_7_6-2013-03-12-branchpoint:1.38
	sid-snapshot-20130301:1.38
	sid-snapshot-20130201:1.38
	sid-snapshot-20130101:1.38
	sid-snapshot-20121201:1.38
	gdb_7_5_1-2012-11-29-release:1.37
	binutils-2_23_1:1.38
	sid-snapshot-20121101:1.38
	binutils-2_23:1.38
	sid-snapshot-20121001:1.38
	sid-snapshot-20120901:1.38
	gdb_7_5-2012-08-17-release:1.37
	sid-snapshot-20120801:1.38
	binutils-2_23-branch:1.38.0.2
	binutils-2_23-branchpoint:1.38
	gdb_7_5-branch:1.37.0.14
	gdb_7_5-2012-07-18-branchpoint:1.37
	sid-snapshot-20120701:1.37
	sid-snapshot-20120601:1.37
	sid-snapshot-20120501:1.37
	binutils-2_22_branch:1.37.0.12
	gdb_7_4_1-2012-04-26-release:1.37
	sid-snapshot-20120401:1.37
	sid-snapshot-20120301:1.37
	sid-snapshot-20120201:1.37
	gdb_7_4-2012-01-24-release:1.37
	sid-snapshot-20120101:1.37
	gdb_7_4-branch:1.37.0.10
	gdb_7_4-2011-12-13-branchpoint:1.37
	sid-snapshot-20111201:1.37
	binutils-2_22:1.37
	sid-snapshot-20111101:1.37
	sid-snapshot-20111001:1.37
	binutils-2_22-branch:1.37.0.8
	binutils-2_22-branchpoint:1.37
	gdb_7_3_1-2011-09-04-release:1.37
	sid-snapshot-20110901:1.37
	sid-snapshot-20110801:1.37
	gdb_7_3-2011-07-26-release:1.37
	sid-snapshot-20110701:1.37
	sid-snapshot-20110601:1.37
	sid-snapshot-20110501:1.37
	gdb_7_3-branch:1.37.0.6
	gdb_7_3-2011-04-01-branchpoint:1.37
	sid-snapshot-20110401:1.37
	sid-snapshot-20110301:1.37
	sid-snapshot-20110201:1.37
	sid-snapshot-20110101:1.37
	binutils-2_21:1.37
	sid-snapshot-20101201:1.37
	binutils-2_21-branch:1.37.0.4
	binutils-2_21-branchpoint:1.37
	sid-snapshot-20101101:1.37
	sid-snapshot-20101001:1.37
	binutils-2_20_1:1.33
	gdb_7_2-2010-09-02-release:1.37
	sid-snapshot-20100901:1.37
	sid-snapshot-20100801:1.37
	gdb_7_2-branch:1.37.0.2
	gdb_7_2-2010-07-07-branchpoint:1.37
	sid-snapshot-20100701:1.37
	sid-snapshot-20100601:1.36
	sid-snapshot-20100501:1.35
	sid-snapshot-20100401:1.35
	gdb_7_1-2010-03-18-release:1.35
	sid-snapshot-20100301:1.35
	gdb_7_1-branch:1.35.0.2
	gdb_7_1-2010-02-18-branchpoint:1.35
	sid-snapshot-20100201:1.35
	sid-snapshot-20100101:1.35
	gdb_7_0_1-2009-12-22-release:1.33
	sid-snapshot-20091201:1.34
	sid-snapshot-20091101:1.33
	binutils-2_20:1.33
	gdb_7_0-2009-10-06-release:1.33
	sid-snapshot-20091001:1.33
	gdb_7_0-branch:1.33.0.4
	gdb_7_0-2009-09-16-branchpoint:1.33
	arc-sim-20090309:1.29
	binutils-arc-20081103-branch:1.29.0.20
	binutils-arc-20081103-branchpoint:1.29
	binutils-2_20-branch:1.33.0.2
	binutils-2_20-branchpoint:1.33
	sid-snapshot-20090901:1.32
	sid-snapshot-20090801:1.31
	msnyder-checkpoint-072509-branch:1.31.0.6
	msnyder-checkpoint-072509-branchpoint:1.31
	sid-snapshot-20090701:1.31
	dje-cgen-play1-branch:1.31.0.4
	dje-cgen-play1-branchpoint:1.31
	sid-snapshot-20090601:1.31
	sid-snapshot-20090501:1.31
	sid-snapshot-20090401:1.31
	arc-20081103-branch:1.29.0.18
	arc-20081103-branchpoint:1.29
	arc-insight_6_8-branch:1.29.0.16
	arc-insight_6_8-branchpoint:1.29
	insight_6_8-branch:1.29.0.14
	insight_6_8-branchpoint:1.29
	sid-snapshot-20090301:1.31
	binutils-2_19_1:1.29.8.2
	sid-snapshot-20090201:1.31
	sid-snapshot-20090101:1.31
	reverse-20081226-branch:1.31.0.2
	reverse-20081226-branchpoint:1.31
	sid-snapshot-20081201:1.31
	multiprocess-20081120-branch:1.29.0.12
	multiprocess-20081120-branchpoint:1.29
	sid-snapshot-20081101:1.29
	binutils-2_19:1.29
	sid-snapshot-20081001:1.29
	reverse-20080930-branch:1.29.0.10
	reverse-20080930-branchpoint:1.29
	binutils-2_19-branch:1.29.0.8
	binutils-2_19-branchpoint:1.29
	sid-snapshot-20080901:1.29
	sid-snapshot-20080801:1.29
	reverse-20080717-branch:1.29.0.6
	reverse-20080717-branchpoint:1.29
	sid-snapshot-20080701:1.29
	msnyder-reverse-20080609-branch:1.29.0.4
	msnyder-reverse-20080609-branchpoint:1.29
	drow-reverse-20070409-branch:1.24.0.2
	drow-reverse-20070409-branchpoint:1.24
	sid-snapshot-20080601:1.29
	sid-snapshot-20080501:1.29
	sid-snapshot-20080403:1.29
	sid-snapshot-20080401:1.29
	gdb_6_8-2008-03-27-release:1.29
	sid-snapshot-20080301:1.29
	gdb_6_8-branch:1.29.0.2
	gdb_6_8-2008-02-26-branchpoint:1.29
	sid-snapshot-20080201:1.29
	sid-snapshot-20080101:1.29
	sid-snapshot-20071201:1.29
	sid-snapshot-20071101:1.29
	gdb_6_7_1-2007-10-29-release:1.28
	gdb_6_7-2007-10-10-release:1.28
	sid-snapshot-20071001:1.29
	gdb_6_7-branch:1.28.0.4
	gdb_6_7-2007-09-07-branchpoint:1.28
	binutils-2_18:1.28
	binutils-2_18-branch:1.28.0.2
	binutils-2_18-branchpoint:1.28
	insight_6_6-20070208-release:1.23
	binutils-csl-coldfire-4_1-32:1.21.6.4
	binutils-csl-sourcerygxx-4_1-32:1.21.6.4
	gdb_6_6-2006-12-18-release:1.23
	binutils-csl-innovasic-fido-3_4_4-33:1.21.6.4
	binutils-csl-sourcerygxx-3_4_4-32:1.16
	binutils-csl-coldfire-4_1-30:1.21.6.4
	binutils-csl-sourcerygxx-4_1-30:1.21.6.4
	binutils-csl-coldfire-4_1-28:1.21.6.4
	binutils-csl-sourcerygxx-4_1-29:1.21.6.4
	binutils-csl-sourcerygxx-4_1-28:1.21.6.4
	gdb_6_6-branch:1.23.0.2
	gdb_6_6-2006-11-15-branchpoint:1.23
	binutils-csl-arm-2006q3-27:1.21.6.4
	binutils-csl-sourcerygxx-4_1-27:1.21.6.4
	binutils-csl-arm-2006q3-26:1.21.6.4
	binutils-csl-sourcerygxx-4_1-26:1.21.6.4
	binutils-csl-sourcerygxx-4_1-25:1.21.6.3
	binutils-csl-sourcerygxx-4_1-24:1.21.6.3
	binutils-csl-sourcerygxx-4_1-23:1.21.6.3
	insight_6_5-20061003-release:1.22
	gdb-csl-symbian-6_4_50_20060226-12:1.21
	binutils-csl-sourcerygxx-4_1-21:1.21.6.3
	binutils-csl-arm-2006q3-21:1.21.6.3
	binutils-csl-sourcerygxx-4_1-22:1.21.6.3
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.21.6.3
	binutils-csl-sourcerygxx-4_1-20:1.21.6.3
	binutils-csl-arm-2006q3-19:1.21.6.3
	binutils-csl-sourcerygxx-4_1-19:1.21.6.3
	binutils-csl-sourcerygxx-4_1-18:1.21.6.3
	binutils-csl-renesas-4_1-9:1.21.6.3
	gdb-csl-sourcerygxx-3_4_4-25:1.20
	binutils-csl-sourcerygxx-3_4_4-25:1.16
	nickrob-async-20060828-mergepoint:1.23
	gdb-csl-symbian-6_4_50_20060226-11:1.21
	binutils-csl-renesas-4_1-8:1.21.6.2
	binutils-csl-renesas-4_1-7:1.21.6.2
	binutils-csl-renesas-4_1-6:1.21.6.2
	gdb-csl-sourcerygxx-4_1-17:1.21.2.2
	binutils-csl-sourcerygxx-4_1-17:1.21.6.2
	gdb-csl-20060226-branch-local-2:1.21.2.2
	gdb-csl-sourcerygxx-4_1-14:1.21.2.2
	binutils-csl-sourcerygxx-4_1-14:1.21.6.2
	binutils-csl-sourcerygxx-4_1-15:1.21.6.2
	gdb-csl-sourcerygxx-4_1-13:1.21.2.2
	binutils-csl-sourcerygxx-4_1-13:1.21.6.2
	binutils-2_17:1.21.12.1
	gdb-csl-sourcerygxx-4_1-12:1.21.2.2
	binutils-csl-sourcerygxx-4_1-12:1.21.6.2
	gdb-csl-sourcerygxx-3_4_4-21:1.21.2.2
	binutils-csl-sourcerygxx-3_4_4-21:1.21.6.2
	gdb_6_5-20060621-release:1.22
	binutils-csl-wrs-linux-3_4_4-24:1.16
	binutils-csl-wrs-linux-3_4_4-23:1.16
	gdb-csl-sourcerygxx-4_1-9:1.21.2.2
	binutils-csl-sourcerygxx-4_1-9:1.21.6.2
	gdb-csl-sourcerygxx-4_1-8:1.21.2.2
	binutils-csl-sourcerygxx-4_1-8:1.21.6.2
	gdb-csl-sourcerygxx-4_1-7:1.21.2.2
	binutils-csl-sourcerygxx-4_1-7:1.21.6.2
	gdb-csl-arm-2006q1-6:1.21.2.2
	binutils-csl-arm-2006q1-6:1.21.6.2
	gdb-csl-sourcerygxx-4_1-6:1.21.2.2
	binutils-csl-sourcerygxx-4_1-6:1.21.6.2
	binutils-csl-wrs-linux-3_4_4-22:1.16
	gdb-csl-symbian-6_4_50_20060226-10:1.21
	gdb-csl-symbian-6_4_50_20060226-9:1.21
	gdb-csl-symbian-6_4_50_20060226-8:1.21
	gdb-csl-coldfire-4_1-11:1.21.2.1
	binutils-csl-coldfire-4_1-11:1.21.6.1
	gdb-csl-sourcerygxx-3_4_4-19:1.21.2.1
	binutils-csl-sourcerygxx-3_4_4-19:1.21.6.1
	gdb-csl-coldfire-4_1-10:1.21.2.1
	gdb_6_5-branch:1.22.0.6
	gdb_6_5-2006-05-14-branchpoint:1.22
	binutils-csl-coldfire-4_1-10:1.21.6.1
	gdb-csl-sourcerygxx-4_1-5:1.21.2.1
	binutils-csl-sourcerygxx-4_1-5:1.21.6.1
	nickrob-async-20060513-branch:1.22.0.4
	nickrob-async-20060513-branchpoint:1.22
	gdb-csl-sourcerygxx-4_1-4:1.21
	binutils-csl-sourcerygxx-4_1-4:1.21.6.1
	msnyder-reverse-20060502-branch:1.22.0.2
	msnyder-reverse-20060502-branchpoint:1.22
	binutils-csl-wrs-linux-3_4_4-21:1.16
	gdb-csl-morpho-4_1-4:1.21
	binutils-csl-morpho-4_1-4:1.21.6.1
	gdb-csl-sourcerygxx-3_4_4-17:1.21
	binutils-csl-sourcerygxx-3_4_4-17:1.21
	binutils-csl-wrs-linux-3_4_4-20:1.16
	readline_5_1-import-branch:1.21.0.14
	readline_5_1-import-branchpoint:1.21
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.21
	binutils-2_17-branch:1.21.0.12
	binutils-2_17-branchpoint:1.21
	gdb-csl-symbian-20060226-branch:1.21.0.10
	gdb-csl-symbian-20060226-branchpoint:1.21
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.21
	msnyder-reverse-20060331-branch:1.21.0.8
	msnyder-reverse-20060331-branchpoint:1.21
	binutils-csl-2_17-branch:1.21.0.6
	binutils-csl-2_17-branchpoint:1.21
	gdb-csl-available-20060303-branch:1.21.0.4
	gdb-csl-available-20060303-branchpoint:1.21
	gdb-csl-20060226-branch:1.21.0.2
	gdb-csl-20060226-branchpoint:1.21
	gdb_6_4-20051202-release:1.19
	msnyder-fork-checkpoint-branch:1.20.0.4
	msnyder-fork-checkpoint-branchpoint:1.20
	gdb-csl-gxxpro-6_3-branch:1.20.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.20
	gdb_6_4-branch:1.19.0.4
	gdb_6_4-2005-11-01-branchpoint:1.19
	gdb-csl-arm-20051020-branch:1.19.0.2
	gdb-csl-arm-20051020-branchpoint:1.19
	binutils-csl-gxxpro-3_4-branch:1.16.0.10
	binutils-csl-gxxpro-3_4-branchpoint:1.16
	binutils-2_16_1:1.16
	msnyder-tracepoint-checkpoint-branch:1.17.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.17
	gdb-csl-arm-20050325-2005-q1b:1.16
	binutils-csl-arm-2005q1b:1.16
	binutils-2_16:1.16
	gdb-csl-arm-20050325-2005-q1a:1.16
	binutils-csl-arm-2005q1a:1.16
	csl-arm-20050325-branch:1.16.0.8
	csl-arm-20050325-branchpoint:1.16
	binutils-csl-arm-2005q1-branch:1.16.0.6
	binutils-csl-arm-2005q1-branchpoint:1.16
	binutils-2_16-branch:1.16.0.4
	binutils-2_16-branchpoint:1.16
	csl-arm-2004-q3d:1.16
	gdb_6_3-20041109-release:1.16
	gdb_6_3-branch:1.16.0.2
	gdb_6_3-20041019-branchpoint:1.16
	csl-arm-2004-q3:1.16
	drow_intercu-merge-20040921:1.16
	drow_intercu-merge-20040915:1.16
	jimb-gdb_6_2-e500-branch:1.15.2.1.0.4
	jimb-gdb_6_2-e500-branchpoint:1.15.2.1
	gdb_6_2-20040730-release:1.15.2.1
	gdb_6_2-branch:1.15.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.15
	gdb_6_1_1-20040616-release:1.11
	binutils-2_15:1.11
	binutils-2_15-branchpoint:1.11
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.11
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.11
	drow_intercu-merge-20040327:1.11
	ezannoni_pie-20040323-branch:1.11.0.14
	ezannoni_pie-20040323-branchpoint:1.11
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.12
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.8
	drow_intercu-20040221-branchpoint:1.11
	binutils-2_15-branch:1.11.0.6
	cagney_bfdfile-20040213-branch:1.11.0.4
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.2
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	csl-arm-2003-q4:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.11
	drow-cplus-merge-20031214:1.11
	carlton-dictionary-20031111-merge:1.11
	gdb_6_0-2003-10-04-release:1.10
	kettenis_sparc-20030918-branch:1.10.0.56
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.54
	cagney_x86i386-20030821-branch:1.10.0.52
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.10
	carlton_dictionary-20030627-merge:1.10
	gdb_6_0-branch:1.10.0.50
	gdb_6_0-2003-06-23-branchpoint:1.10
	jimb-ppc64-linux-20030613-branch:1.10.0.48
	jimb-ppc64-linux-20030613-branchpoint:1.10
	binutils-2_14:1.10
	cagney_convert-20030606-branch:1.10.0.46
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.44
	cagney_writestrings-20030508-branchpoint:1.10
	jimb-ppc64-linux-20030528-branch:1.10.0.42
	jimb-ppc64-linux-20030528-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.40
	cagney_fileio-20030521-branchpoint:1.10
	kettenis_i386newframe-20030517-mergepoint:1.10
	jimb-ppc64-linux-20030509-branch:1.10.0.38
	jimb-ppc64-linux-20030509-branchpoint:1.10
	kettenis_i386newframe-20030504-mergepoint:1.10
	carlton_dictionary-20030430-merge:1.10
	binutils-2_14-branch:1.10.0.36
	binutils-2_14-branchpoint:1.10
	kettenis_i386newframe-20030419-branch:1.10.0.34
	kettenis_i386newframe-20030419-branchpoint:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.10
	kettenis_i386newframe-20030406-branch:1.10.0.32
	kettenis_i386newframe-20030406-branchpoint:1.10
	cagney_frameaddr-20030403-branchpoint:1.10
	cagney_frameaddr-20030403-branch:1.10.0.30
	cagney_framebase-20030330-mergepoint:1.10
	cagney_framebase-20030326-branch:1.10.0.28
	cagney_framebase-20030326-branchpoint:1.10
	cagney_lazyid-20030317-branch:1.10.0.26
	cagney_lazyid-20030317-branchpoint:1.10
	kettenis-i386newframe-20030316-mergepoint:1.10
	offbyone-20030313-branch:1.10.0.24
	offbyone-20030313-branchpoint:1.10
	kettenis-i386newframe-20030308-branch:1.10.0.22
	kettenis-i386newframe-20030308-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.20
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.10
	interps-20030202-branch:1.10.0.18
	interps-20030202-branchpoint:1.10
	cagney-unwind-20030108-branch:1.10.0.16
	cagney-unwind-20030108-branchpoint:1.10
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	binutils-2_13_1:1.10
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.14
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.12
	carlton_dictionary-20020920-branchpoint:1.10
	sid-20020905-branchpoint:1.10
	sid-20020905-branch:1.10.0.10
	gdb_5_3-branch:1.10.0.8
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.6
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.4
	readline_4_3-import-branchpoint:1.10
	binutils-2_13:1.10
	gdb_5_2_1-2002-07-23-release:1.8
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	kseitz_interps-20020528-branch:1.9.0.2
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.8.0.14
	cagney_regbuf-20020515-branchpoint:1.8
	binutils-2_12_1:1.8
	jimb-macro-020506-branch:1.8.0.12
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.8
	binutils-2_12:1.8
	gdb_5_2-branch:1.8.0.10
	gdb_5_2-2002-03-03-branchpoint:1.8
	binutils-2_12-branch:1.8.0.8
	binutils-2_12-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.4
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.2
	gdb_5_1-2001-07-29-branchpoint:1.8
	binutils-2_11_2:1.4.4.2
	binutils-2_11_1:1.4.4.2
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.4
	insight-precleanup-2001-01-01:1.4
	binutils-2_10_1:1.2.2.1
	binutils-2_10:1.2.2.1
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.38
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2012.07.24.12.56.47;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.16.15.12.49;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.27.10.43.27;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.11.13.42.17;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.10.18.05.24;	author mkuvyrkov;	state Exp;
branches;
next	1.33;

1.33
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.26.13.16.29;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2008.11.26.10.43.18;	author schwab;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.25.10.33.06;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.27.11.14.10;	author kazu;	state Exp;
branches
	1.29.8.1;
next	1.28;

1.28
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.03.07.54.19;	author nathan;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.20.14.09.00;	author nathan;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.09.17.09.56;	author kazu;	state Exp;
branches;
next	1.24;

1.24
date	2006.12.27.07.15.02;	author kazu;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.25.08.09.03;	author rsandifo;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.29.03.11.31;	author wilson;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.07.19.01.10;	author nathan;	state Exp;
branches
	1.21.2.1
	1.21.6.1
	1.21.12.1;
next	1.20;

1.20
date	2005.11.10.14.32.28;	author schwab;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.01.11.16.32;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.23.11.18.26;	author bje;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.07.07.34.29;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.11.14.29.50;	author schwab;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.09.18.42.13;	author schwab;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2004.05.24.14.33.22;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.05.14.33.14;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.22.10.33.16;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.21.13.28.59;	author nickc;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	2002.06.08.07.29.27;	author amodra;	state Exp;
branches
	1.10.12.1
	1.10.14.1;
next	1.9;

1.9
date	2002.05.25.12.55.19;	author amodra;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.07.24.00.48.04;	author kazu;	state Exp;
branches
	1.8.14.1;
next	1.7;

1.7
date	2001.06.06.14.28.00;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.13.22.58.36;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.20.13.31;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.08.07.22.54;	author amodra;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.05.27.22.33.13;	author ian;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.29.8.1
date	2008.11.25.10.34.50;	author nickc;	state Exp;
branches;
next	1.29.8.2;

1.29.8.2
date	2008.11.26.10.45.27;	author schwab;	state Exp;
branches;
next	;

1.21.2.1
date	2006.05.08.09.32.49;	author rsandifo;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2006.05.22.11.59.13;	author rsandifo;	state Exp;
branches;
next	;

1.21.6.1
date	2006.04.27.17.04.51;	author rsandifo;	state Exp;
branches;
next	1.21.6.2;

1.21.6.2
date	2006.05.22.11.58.46;	author rsandifo;	state Exp;
branches;
next	1.21.6.3;

1.21.6.3
date	2006.08.22.15.08.46;	author jsm28;	state Exp;
branches;
next	1.21.6.4;

1.21.6.4
date	2006.10.30.19.46.10;	author kazu;	state Exp;
branches;
next	;

1.21.12.1
date	2006.05.26.03.37.45;	author rsandifo;	state Exp;
branches;
next	;

1.15.2.1
date	2004.07.18.23.03.00;	author schwab;	state Exp;
branches;
next	;

1.11.8.1
date	2004.09.16.17.02.00;	author drow;	state Exp;
branches;
next	;

1.10.12.1
date	2003.11.11.23.51.17;	author carlton;	state Exp;
branches;
next	;

1.10.14.1
date	2003.12.14.20.28.07;	author drow;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.20.01.38.29;	author kseitz;	state Exp;
branches;
next	;

1.8.14.1
date	2002.06.15.16.43.20;	author cagney;	state Exp;
branches;
next	;

1.4.4.1
date	2001.06.07.03.18.35;	author amodra;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.06.11.10.05.18;	author amodra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches;
next	;


desc
@@


1.38
log
@	PR binutils/13135
	* arm-dis.c: Add necessary casts for printing integer values.
	Use %s when printing string values.
	* hppa-dis.c: Likewise.
	* m68k-dis.c: Likewise.
	* microblaze-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* sparc-dis.c: Likewise.

	* dis-asm.h (fprintf_ftype): Add ATTRIBUTE_FPTR_PRINTF_2.
@
text
@/* Print Motorola 68k instructions.
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2012  Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "floatformat.h"
#include "libiberty.h"
#include "opintl.h"

#include "opcode/m68k.h"

/* Local function prototypes.  */

const char * const fpcr_names[] =
{
  "", "%fpiar", "%fpsr", "%fpiar/%fpsr", "%fpcr",
  "%fpiar/%fpcr", "%fpsr/%fpcr", "%fpiar/%fpsr/%fpcr"
};

static char *const reg_names[] =
{
  "%d0", "%d1", "%d2", "%d3", "%d4", "%d5", "%d6", "%d7",
  "%a0", "%a1", "%a2", "%a3", "%a4", "%a5", "%fp", "%sp",
  "%ps", "%pc"
};

/* Name of register halves for MAC/EMAC.
   Seperate from reg_names since 'spu', 'fpl' look weird.  */
static char *const reg_half_names[] =
{
  "%d0", "%d1", "%d2", "%d3", "%d4", "%d5", "%d6", "%d7",
  "%a0", "%a1", "%a2", "%a3", "%a4", "%a5", "%a6", "%a7",
  "%ps", "%pc"
};

/* Sign-extend an (unsigned char).  */
#if __STDC__ == 1
#define COERCE_SIGNED_CHAR(ch) ((signed char) (ch))
#else
#define COERCE_SIGNED_CHAR(ch) ((int) (((ch) ^ 0x80) & 0xFF) - 128)
#endif

/* Get a 1 byte signed integer.  */
#define NEXTBYTE(p, val)			\
  do						\
    {						\
      p += 2;					\
      if (!FETCH_DATA (info, p))		\
	return -3;				\
      val = COERCE_SIGNED_CHAR (p[-1]);		\
    }						\
  while (0)

/* Get a 2 byte signed integer.  */
#define COERCE16(x) ((int) (((x) ^ 0x8000) - 0x8000))

#define NEXTWORD(p, val, ret_val)		\
  do						\
    {						\
      p += 2;					\
      if (!FETCH_DATA (info, p))		\
	return ret_val;				\
      val = COERCE16 ((p[-2] << 8) + p[-1]);	\
    }						\
  while (0)						

/* Get a 4 byte signed integer.  */
#define COERCE32(x) ((bfd_signed_vma) ((x) ^ 0x80000000) - 0x80000000)

#define NEXTLONG(p, val, ret_val)					\
  do									\
    {									\
      p += 4;								\
      if (!FETCH_DATA (info, p))					\
	return ret_val;							\
      val = COERCE32 ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]); \
    }									\
  while (0)

/* Get a 4 byte unsigned integer.  */
#define NEXTULONG(p, val)						\
  do									\
    {									\
      p += 4;								\
      if (!FETCH_DATA (info, p))					\
	return -3;							\
      val = (unsigned int) ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]); \
    }									\
  while (0)

/* Get a single precision float.  */
#define NEXTSINGLE(val, p)					\
  do								\
    {								\
      p += 4;							\
      if (!FETCH_DATA (info, p))				\
	return -3;						\
      floatformat_to_double (& floatformat_ieee_single_big,	\
			     (char *) p - 4, & val);		\
    }								\
  while (0)

/* Get a double precision float.  */
#define NEXTDOUBLE(val, p)					\
  do								\
    {								\
      p += 8;							\
      if (!FETCH_DATA (info, p))				\
	return -3;						\
      floatformat_to_double (& floatformat_ieee_double_big,	\
			     (char *) p - 8, & val);		\
    }								\
  while (0)

/* Get an extended precision float.  */
#define NEXTEXTEND(val, p)				\
  do							\
    {							\
      p += 12;						\
      if (!FETCH_DATA (info, p))			\
	return -3;					\
      floatformat_to_double (& floatformat_m68881_ext,	\
			     (char *) p - 12, & val);	\
    }							\
  while (0)

/* Need a function to convert from packed to double
   precision.   Actually, it's easier to print a
   packed number than a double anyway, so maybe
   there should be a special case to handle this... */
#define NEXTPACKED(p, val)			\
  do						\
    {						\
      p += 12;					\
      if (!FETCH_DATA (info, p))		\
	return -3;				\
      val = 0.0;				\
    }						\
  while (0)


/* Maximum length of an instruction.  */
#define MAXLEN 22

#include <setjmp.h>

struct private
{
  /* Points to first byte not fetched.  */
  bfd_byte *max_fetched;
  bfd_byte the_buffer[MAXLEN];
  bfd_vma insn_start;
};

/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)
   to ADDR (exclusive) are valid.  Returns 1 for success, 0 on error.  */
#define FETCH_DATA(info, addr) \
  ((addr) <= ((struct private *) (info->private_data))->max_fetched \
   ? 1 : fetch_data ((info), (addr)))

static int
fetch_data (struct disassemble_info *info, bfd_byte *addr)
{
  int status;
  struct private *priv = (struct private *)info->private_data;
  bfd_vma start = priv->insn_start + (priv->max_fetched - priv->the_buffer);

  status = (*info->read_memory_func) (start,
				      priv->max_fetched,
				      addr - priv->max_fetched,
				      info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, start, info);
      return 0;
    }
  else
    priv->max_fetched = addr;
  return 1;
}

/* This function is used to print to the bit-bucket.  */
static int
dummy_printer (FILE *file ATTRIBUTE_UNUSED,
	       const char *format ATTRIBUTE_UNUSED,
	       ...)
{
  return 0;
}

static void
dummy_print_address (bfd_vma vma ATTRIBUTE_UNUSED,
		     struct disassemble_info *info ATTRIBUTE_UNUSED)
{
}

/* Fetch BITS bits from a position in the instruction specified by CODE.
   CODE is a "place to put an argument", or 'x' for a destination
   that is a general address (mode and register).
   BUFFER contains the instruction.
   Returns -1 on failure.  */

static int
fetch_arg (unsigned char *buffer,
	   int code,
	   int bits,
	   disassemble_info *info)
{
  int val = 0;

  switch (code)
    {
    case '/': /* MAC/EMAC mask bit.  */
      val = buffer[3] >> 5;
      break;

    case 'G': /* EMAC ACC load.  */
      val = ((buffer[3] >> 3) & 0x2) | ((~buffer[1] >> 7) & 0x1);
      break;

    case 'H': /* EMAC ACC !load.  */
      val = ((buffer[3] >> 3) & 0x2) | ((buffer[1] >> 7) & 0x1);
      break;

    case ']': /* EMAC ACCEXT bit.  */
      val = buffer[0] >> 2;
      break;

    case 'I': /* MAC/EMAC scale factor.  */
      val = buffer[2] >> 1;
      break;

    case 'F': /* EMAC ACCx.  */
      val = buffer[0] >> 1;
      break;

    case 'f':
      val = buffer[1];
      break;

    case 's':
      val = buffer[1];
      break;

    case 'd':			/* Destination, for register or quick.  */
      val = (buffer[0] << 8) + buffer[1];
      val >>= 9;
      break;

    case 'x':			/* Destination, for general arg.  */
      val = (buffer[0] << 8) + buffer[1];
      val >>= 6;
      break;

    case 'k':
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
      val = (buffer[3] >> 4);
      break;

    case 'C':
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
      val = buffer[3];
      break;

    case '1':
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
      val = (buffer[2] << 8) + buffer[3];
      val >>= 12;
      break;

    case '2':
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
      val = (buffer[2] << 8) + buffer[3];
      val >>= 6;
      break;

    case '3':
    case 'j':
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
      val = (buffer[2] << 8) + buffer[3];
      break;

    case '4':
      if (! FETCH_DATA (info, buffer + 5))
	return -1;
      val = (buffer[4] << 8) + buffer[5];
      val >>= 12;
      break;

    case '5':
      if (! FETCH_DATA (info, buffer + 5))
	return -1;
      val = (buffer[4] << 8) + buffer[5];
      val >>= 6;
      break;

    case '6':
      if (! FETCH_DATA (info, buffer + 5))
	return -1;
      val = (buffer[4] << 8) + buffer[5];
      break;

    case '7':
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
      val = (buffer[2] << 8) + buffer[3];
      val >>= 7;
      break;

    case '8':
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
      val = (buffer[2] << 8) + buffer[3];
      val >>= 10;
      break;

    case '9':
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
      val = (buffer[2] << 8) + buffer[3];
      val >>= 5;
      break;

    case 'e':
      val = (buffer[1] >> 6);
      break;

    case 'E':
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
      val = (buffer[2] >> 1);
      break;

    case 'm':
      val = (buffer[1] & 0x40 ? 0x8 : 0)
	| ((buffer[0] >> 1) & 0x7)
	| (buffer[3] & 0x80 ? 0x10 : 0);
      break;

    case 'n':
      val = (buffer[1] & 0x40 ? 0x8 : 0) | ((buffer[0] >> 1) & 0x7);
      break;

    case 'o':
      val = (buffer[2] >> 4) | (buffer[3] & 0x80 ? 0x10 : 0);
      break;

    case 'M':
      val = (buffer[1] & 0xf) | (buffer[3] & 0x40 ? 0x10 : 0);
      break;

    case 'N':
      val = (buffer[3] & 0xf) | (buffer[3] & 0x40 ? 0x10 : 0);
      break;

    case 'h':
      val = buffer[2] >> 2;
      break;

    default:
      abort ();
    }

  /* bits is never too big.  */
  return val & ((1 << bits) - 1);
}

/* Check if an EA is valid for a particular code.  This is required
   for the EMAC instructions since the type of source address determines
   if it is a EMAC-load instruciton if the EA is mode 2-5, otherwise it
   is a non-load EMAC instruction and the bits mean register Ry.
   A similar case exists for the movem instructions where the register
   mask is interpreted differently for different EAs.  */

static bfd_boolean
m68k_valid_ea (char code, int val)
{
  int mode, mask;
#define M(n0,n1,n2,n3,n4,n5,n6,n70,n71,n72,n73,n74) \
  (n0 | n1 << 1 | n2 << 2 | n3 << 3 | n4 << 4 | n5 << 5 | n6 << 6 \
   | n70 << 7 | n71 << 8 | n72 << 9 | n73 << 10 | n74 << 11)

  switch (code)
    {
    case '*':
      mask = M (1,1,1,1,1,1,1,1,1,1,1,1);
      break;
    case '~':
      mask = M (0,0,1,1,1,1,1,1,1,0,0,0);
      break;
    case '%':
      mask = M (1,1,1,1,1,1,1,1,1,0,0,0);
      break;
    case ';':
      mask = M (1,0,1,1,1,1,1,1,1,1,1,1);
      break;
    case '@@':
      mask = M (1,0,1,1,1,1,1,1,1,1,1,0);
      break;
    case '!':
      mask = M (0,0,1,0,0,1,1,1,1,1,1,0);
      break;
    case '&':
      mask = M (0,0,1,0,0,1,1,1,1,0,0,0);
      break;
    case '$':
      mask = M (1,0,1,1,1,1,1,1,1,0,0,0);
      break;
    case '?':
      mask = M (1,0,1,0,0,1,1,1,1,0,0,0);
      break;
    case '/':
      mask = M (1,0,1,0,0,1,1,1,1,1,1,0);
      break;
    case '|':
      mask = M (0,0,1,0,0,1,1,1,1,1,1,0);
      break;
    case '>':
      mask = M (0,0,1,0,1,1,1,1,1,0,0,0);
      break;
    case '<':
      mask = M (0,0,1,1,0,1,1,1,1,1,1,0);
      break;
    case 'm':
      mask = M (1,1,1,1,1,0,0,0,0,0,0,0);
      break;
    case 'n':
      mask = M (0,0,0,0,0,1,0,0,0,1,0,0);
      break;
    case 'o':
      mask = M (0,0,0,0,0,0,1,1,1,0,1,1);
      break;
    case 'p':
      mask = M (1,1,1,1,1,1,0,0,0,0,0,0);
      break;
    case 'q':
      mask = M (1,0,1,1,1,1,0,0,0,0,0,0);
      break;
    case 'v':
      mask = M (1,0,1,1,1,1,0,1,1,0,0,0);
      break;
    case 'b':
      mask = M (1,0,1,1,1,1,0,0,0,1,0,0);
      break;
    case 'w':
      mask = M (0,0,1,1,1,1,0,0,0,1,0,0);
      break;
    case 'y':
      mask = M (0,0,1,0,0,1,0,0,0,0,0,0);
      break;
    case 'z':
      mask = M (0,0,1,0,0,1,0,0,0,1,0,0);
      break;
    case '4':
      mask = M (0,0,1,1,1,1,0,0,0,0,0,0);
      break;
    default:
      abort ();
    }
#undef M

  mode = (val >> 3) & 7;
  if (mode == 7)
    mode += val & 7;
  return (mask & (1 << mode)) != 0;
}

/* Print a base register REGNO and displacement DISP, on INFO->STREAM.
   REGNO = -1 for pc, -2 for none (suppressed).  */

static void
print_base (int regno, bfd_vma disp, disassemble_info *info)
{
  if (regno == -1)
    {
      (*info->fprintf_func) (info->stream, "%%pc@@(");
      (*info->print_address_func) (disp, info);
    }
  else
    {
      char buf[50];

      if (regno == -2)
	(*info->fprintf_func) (info->stream, "@@(");
      else if (regno == -3)
	(*info->fprintf_func) (info->stream, "%%zpc@@(");
      else
	(*info->fprintf_func) (info->stream, "%s@@(", reg_names[regno]);

      sprintf_vma (buf, disp);
      (*info->fprintf_func) (info->stream, "%s", buf);
    }
}

/* Print an indexed argument.  The base register is BASEREG (-1 for pc).
   P points to extension word, in buffer.
   ADDR is the nominal core address of that extension word.
   Returns NULL upon error.  */

static unsigned char *
print_indexed (int basereg,
	       unsigned char *p,
	       bfd_vma addr,
	       disassemble_info *info)
{
  int word;
  static char *const scales[] = { "", ":2", ":4", ":8" };
  bfd_vma base_disp;
  bfd_vma outer_disp;
  char buf[40];
  char vmabuf[50];

  NEXTWORD (p, word, NULL);

  /* Generate the text for the index register.
     Where this will be output is not yet determined.  */
  sprintf (buf, "%s:%c%s",
	   reg_names[(word >> 12) & 0xf],
	   (word & 0x800) ? 'l' : 'w',
	   scales[(word >> 9) & 3]);

  /* Handle the 68000 style of indexing.  */

  if ((word & 0x100) == 0)
    {
      base_disp = word & 0xff;
      if ((base_disp & 0x80) != 0)
	base_disp -= 0x100;
      if (basereg == -1)
	base_disp += addr;
      print_base (basereg, base_disp, info);
      (*info->fprintf_func) (info->stream, ",%s)", buf);
      return p;
    }

  /* Handle the generalized kind.  */
  /* First, compute the displacement to add to the base register.  */
  if (word & 0200)
    {
      if (basereg == -1)
	basereg = -3;
      else
	basereg = -2;
    }
  if (word & 0100)
    buf[0] = '\0';
  base_disp = 0;
  switch ((word >> 4) & 3)
    {
    case 2:
      NEXTWORD (p, base_disp, NULL);
      break;
    case 3:
      NEXTLONG (p, base_disp, NULL);
    }
  if (basereg == -1)
    base_disp += addr;

  /* Handle single-level case (not indirect).  */
  if ((word & 7) == 0)
    {
      print_base (basereg, base_disp, info);
      if (buf[0] != '\0')
	(*info->fprintf_func) (info->stream, ",%s", buf);
      (*info->fprintf_func) (info->stream, ")");
      return p;
    }

  /* Two level.  Compute displacement to add after indirection.  */
  outer_disp = 0;
  switch (word & 3)
    {
    case 2:
      NEXTWORD (p, outer_disp, NULL);
      break;
    case 3:
      NEXTLONG (p, outer_disp, NULL);
    }

  print_base (basereg, base_disp, info);
  if ((word & 4) == 0 && buf[0] != '\0')
    {
      (*info->fprintf_func) (info->stream, ",%s", buf);
      buf[0] = '\0';
    }
  sprintf_vma (vmabuf, outer_disp);
  (*info->fprintf_func) (info->stream, ")@@(%s", vmabuf);
  if (buf[0] != '\0')
    (*info->fprintf_func) (info->stream, ",%s", buf);
  (*info->fprintf_func) (info->stream, ")");

  return p;
}

#define FETCH_ARG(size, val)				\
  do							\
    {							\
      val = fetch_arg (buffer, place, size, info);	\
      if (val < 0)					\
	return -3;					\
    }							\
  while (0)

/* Returns number of bytes "eaten" by the operand, or
   return -1 if an invalid operand was found, or -2 if
   an opcode tabe error was found or -3 to simply abort.
   ADDR is the pc for this arg to be relative to.  */

static int
print_insn_arg (const char *d,
		unsigned char *buffer,
		unsigned char *p0,
		bfd_vma addr,
		disassemble_info *info)
{
  int val = 0;
  int place = d[1];
  unsigned char *p = p0;
  int regno;
  const char *regname;
  unsigned char *p1;
  double flval;
  int flt_p;
  bfd_signed_vma disp;
  unsigned int uval;

  switch (*d)
    {
    case 'c':		/* Cache identifier.  */
      {
        static char *const cacheFieldName[] = { "nc", "dc", "ic", "bc" };
        FETCH_ARG (2, val);
	(*info->fprintf_func) (info->stream, "%s", cacheFieldName[val]);
        break;
      }

    case 'a':		/* Address register indirect only. Cf. case '+'.  */
      {
	FETCH_ARG (3, val);
	(*info->fprintf_func) (info->stream, "%s@@", reg_names[val + 8]);
        break;
      }

    case '_':		/* 32-bit absolute address for move16.  */
      {
        NEXTULONG (p, uval);
	(*info->print_address_func) (uval, info);
        break;
      }

    case 'C':
      (*info->fprintf_func) (info->stream, "%%ccr");
      break;

    case 'S':
      (*info->fprintf_func) (info->stream, "%%sr");
      break;

    case 'U':
      (*info->fprintf_func) (info->stream, "%%usp");
      break;

    case 'E':
      (*info->fprintf_func) (info->stream, "%%acc");
      break;

    case 'G':
      (*info->fprintf_func) (info->stream, "%%macsr");
      break;

    case 'H':
      (*info->fprintf_func) (info->stream, "%%mask");
      break;

    case 'J':
      {
	/* FIXME: There's a problem here, different m68k processors call the
	   same address different names.  The tables below try to get it right
	   using info->mach, but only for v4e.  */
	struct regname { char * name; int value; };
	static const struct regname names[] =
	  {
	    {"%sfc", 0x000}, {"%dfc", 0x001}, {"%cacr", 0x002},
	    {"%tc",  0x003}, {"%itt0",0x004}, {"%itt1", 0x005},
	    {"%dtt0",0x006}, {"%dtt1",0x007}, {"%buscr",0x008},
	    {"%rgpiobar", 0x009}, {"%acr4",0x00c},
	    {"%acr5",0x00d}, {"%acr6",0x00e}, {"%acr7", 0x00f},
	    {"%usp", 0x800}, {"%vbr", 0x801}, {"%caar", 0x802},
	    {"%msp", 0x803}, {"%isp", 0x804},
	    {"%pc", 0x80f},
	    /* Reg c04 is sometimes called flashbar or rambar.
	       Reg c05 is also sometimes called rambar.  */
	    {"%rambar0", 0xc04}, {"%rambar1", 0xc05},

	    /* reg c0e is sometimes called mbar2 or secmbar.
	       reg c0f is sometimes called mbar.  */
	    {"%mbar0", 0xc0e}, {"%mbar1", 0xc0f},

	    /* Should we be calling this psr like we do in case 'Y'?  */
	    {"%mmusr",0x805},

	    {"%urp", 0x806}, {"%srp", 0x807}, {"%pcr", 0x808},

	    /* Fido added these.  */
	    {"%cac", 0xffe}, {"%mbo", 0xfff}
	};
	/* Alternate names for v4e (MCF5407/5445x/MCF547x/MCF548x), at least.  */
	static const struct regname names_v4e[] =
	  {
	    {"%asid",0x003}, {"%acr0",0x004}, {"%acr1",0x005},
	    {"%acr2",0x006}, {"%acr3",0x007}, {"%mmubar",0x008},
	  };
	unsigned int arch_mask;

	arch_mask = bfd_m68k_mach_to_features (info->mach);
	FETCH_ARG (12, val);
	if (arch_mask & (mcfisa_b | mcfisa_c))
	  {
	    for (regno = ARRAY_SIZE (names_v4e); --regno >= 0;)
	      if (names_v4e[regno].value == val)
		{
		  (*info->fprintf_func) (info->stream, "%s", names_v4e[regno].name);
		  break;
		}
	    if (regno >= 0)
	      break;
	  }
	for (regno = ARRAY_SIZE (names) - 1; regno >= 0; regno--)
	  if (names[regno].value == val)
	    {
	      (*info->fprintf_func) (info->stream, "%s", names[regno].name);
	      break;
	    }
	if (regno < 0)
	  (*info->fprintf_func) (info->stream, "0x%x", val);
      }
      break;

    case 'Q':
      FETCH_ARG (3, val);
      /* 0 means 8, except for the bkpt instruction... */
      if (val == 0 && d[1] != 's')
	val = 8;
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

    case 'x':
      FETCH_ARG (3, val);
      /* 0 means -1.  */
      if (val == 0)
	val = -1;
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

    case 'j':
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "#%d", val+1);
      break;

    case 'K':
      FETCH_ARG (9, val);
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

    case 'M':
      if (place == 'h')
	{
	  static char *const scalefactor_name[] = { "<<", ">>" };

	  FETCH_ARG (1, val);
	  (*info->fprintf_func) (info->stream, "%s", scalefactor_name[val]);
	}
      else
	{
	  FETCH_ARG (8, val);
	  if (val & 0x80)
	    val = val - 0x100;
	  (*info->fprintf_func) (info->stream, "#%d", val);
	}
      break;

    case 'T':
      FETCH_ARG (4, val);
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

    case 'D':
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%s", reg_names[val]);
      break;

    case 'A':
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%s", reg_names[val + 010]);
      break;

    case 'R':
      FETCH_ARG (4, val);
      (*info->fprintf_func) (info->stream, "%s", reg_names[val]);
      break;

    case 'r':
      FETCH_ARG (4, regno);
      if (regno > 7)
	(*info->fprintf_func) (info->stream, "%s@@", reg_names[regno]);
      else
	(*info->fprintf_func) (info->stream, "@@(%s)", reg_names[regno]);
      break;

    case 'F':
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%%fp%d", val);
      break;

    case 'O':
      FETCH_ARG (6, val);
      if (val & 0x20)
	(*info->fprintf_func) (info->stream, "%s", reg_names[val & 7]);
      else
	(*info->fprintf_func) (info->stream, "%d", val);
      break;

    case '+':
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%s@@+", reg_names[val + 8]);
      break;

    case '-':
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%s@@-", reg_names[val + 8]);
      break;

    case 'k':
      if (place == 'k')
	{
	  FETCH_ARG (3, val);
	  (*info->fprintf_func) (info->stream, "{%s}", reg_names[val]);
	}
      else if (place == 'C')
	{
	  FETCH_ARG (7, val);
	  if (val > 63)		/* This is a signed constant.  */
	    val -= 128;
	  (*info->fprintf_func) (info->stream, "{#%d}", val);
	}
      else
	return -1;
      break;

    case '#':
    case '^':
      p1 = buffer + (*d == '#' ? 2 : 4);
      if (place == 's')
	FETCH_ARG (4, val);
      else if (place == 'C')
	FETCH_ARG (7, val);
      else if (place == '8')
	FETCH_ARG (3, val);
      else if (place == '3')
	FETCH_ARG (8, val);
      else if (place == 'b')
	NEXTBYTE (p1, val);
      else if (place == 'w' || place == 'W')
	NEXTWORD (p1, val, -3);
      else if (place == 'l')
	NEXTLONG (p1, val, -3);
      else
	return -2;

      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

    case 'B':
      if (place == 'b')
	NEXTBYTE (p, disp);
      else if (place == 'B')
	disp = COERCE_SIGNED_CHAR (buffer[1]);
      else if (place == 'w' || place == 'W')
	NEXTWORD (p, disp, -3);
      else if (place == 'l' || place == 'L' || place == 'C')
	NEXTLONG (p, disp, -3);
      else if (place == 'g')
	{
	  NEXTBYTE (buffer, disp);
	  if (disp == 0)
	    NEXTWORD (p, disp, -3);
	  else if (disp == -1)
	    NEXTLONG (p, disp, -3);
	}
      else if (place == 'c')
	{
	  if (buffer[1] & 0x40)		/* If bit six is one, long offset.  */
	    NEXTLONG (p, disp, -3);
	  else
	    NEXTWORD (p, disp, -3);
	}
      else
	return -2;

      (*info->print_address_func) (addr + disp, info);
      break;

    case 'd':
      {
	int val1;

	NEXTWORD (p, val, -3);
	FETCH_ARG (3, val1);
	(*info->fprintf_func) (info->stream, "%s@@(%d)", reg_names[val1 + 8], val);
	break;
      }

    case 's':
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%s", fpcr_names[val]);
      break;

    case 'e':
      FETCH_ARG (2, val);
      (*info->fprintf_func) (info->stream, "%%acc%d", val);
      break;

    case 'g':
      FETCH_ARG (1, val);
      (*info->fprintf_func) (info->stream, "%%accext%s", val == 0 ? "01" : "23");
      break;

    case 'i':
      FETCH_ARG (2, val);
      if (val == 1)
	(*info->fprintf_func) (info->stream, "<<");
      else if (val == 3)
	(*info->fprintf_func) (info->stream, ">>");
      else
	return -1;
      break;

    case 'I':
      /* Get coprocessor ID... */
      val = fetch_arg (buffer, 'd', 3, info);
      if (val < 0)
	return -3;
      if (val != 1)				/* Unusual coprocessor ID?  */
	(*info->fprintf_func) (info->stream, "(cpid=%d) ", val);
      break;

    case '4':
    case '*':
    case '~':
    case '%':
    case ';':
    case '@@':
    case '!':
    case '$':
    case '?':
    case '/':
    case '&':
    case '|':
    case '<':
    case '>':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'v':
    case 'b':
    case 'w':
    case 'y':
    case 'z':
      if (place == 'd')
	{
	  val = fetch_arg (buffer, 'x', 6, info);
	  if (val < 0)
	    return -3;
	  val = ((val & 7) << 3) + ((val >> 3) & 7);
	}
      else
	{
	  val = fetch_arg (buffer, 's', 6, info);
	  if (val < 0)
	    return -3;
	}

      /* If the <ea> is invalid for *d, then reject this match.  */
      if (!m68k_valid_ea (*d, val))
	return -1;

      /* Get register number assuming address register.  */
      regno = (val & 7) + 8;
      regname = reg_names[regno];
      switch (val >> 3)
	{
	case 0:
	  (*info->fprintf_func) (info->stream, "%s", reg_names[val]);
	  break;

	case 1:
	  (*info->fprintf_func) (info->stream, "%s", regname);
	  break;

	case 2:
	  (*info->fprintf_func) (info->stream, "%s@@", regname);
	  break;

	case 3:
	  (*info->fprintf_func) (info->stream, "%s@@+", regname);
	  break;

	case 4:
	  (*info->fprintf_func) (info->stream, "%s@@-", regname);
	  break;

	case 5:
	  NEXTWORD (p, val, -3);
	  (*info->fprintf_func) (info->stream, "%s@@(%d)", regname, val);
	  break;

	case 6:
	  p = print_indexed (regno, p, addr, info);
	  if (p == NULL)
	    return -3;
	  break;

	case 7:
	  switch (val & 7)
	    {
	    case 0:
	      NEXTWORD (p, val, -3);
	      (*info->print_address_func) (val, info);
	      break;

	    case 1:
	      NEXTULONG (p, uval);
	      (*info->print_address_func) (uval, info);
	      break;

	    case 2:
	      NEXTWORD (p, val, -3);
	      (*info->fprintf_func) (info->stream, "%%pc@@(");
	      (*info->print_address_func) (addr + val, info);
	      (*info->fprintf_func) (info->stream, ")");
	      break;

	    case 3:
	      p = print_indexed (-1, p, addr, info);
	      if (p == NULL)
		return -3;
	      break;

	    case 4:
	      flt_p = 1;	/* Assume it's a float... */
	      switch (place)
	      {
		case 'b':
		  NEXTBYTE (p, val);
		  flt_p = 0;
		  break;

		case 'w':
		  NEXTWORD (p, val, -3);
		  flt_p = 0;
		  break;

		case 'l':
		  NEXTLONG (p, val, -3);
		  flt_p = 0;
		  break;

		case 'f':
		  NEXTSINGLE (flval, p);
		  break;

		case 'F':
		  NEXTDOUBLE (flval, p);
		  break;

		case 'x':
		  NEXTEXTEND (flval, p);
		  break;

		case 'p':
		  NEXTPACKED (p, flval);
		  break;

		default:
		  return -1;
	      }
	      if (flt_p)	/* Print a float? */
		(*info->fprintf_func) (info->stream, "#0e%g", flval);
	      else
		(*info->fprintf_func) (info->stream, "#%d", val);
	      break;

	    default:
	      return -1;
	    }
	}

      /* If place is '/', then this is the case of the mask bit for
	 mac/emac loads. Now that the arg has been printed, grab the
	 mask bit and if set, add a '&' to the arg.  */
      if (place == '/')
	{
	  FETCH_ARG (1, val);
	  if (val)
	    info->fprintf_func (info->stream, "&");
	}
      break;

    case 'L':
    case 'l':
	if (place == 'w')
	  {
	    char doneany;
	    p1 = buffer + 2;
	    NEXTWORD (p1, val, -3);
	    /* Move the pointer ahead if this point is farther ahead
	       than the last.  */
	    p = p1 > p ? p1 : p;
	    if (val == 0)
	      {
		(*info->fprintf_func) (info->stream, "#0");
		break;
	      }
	    if (*d == 'l')
	      {
		int newval = 0;

		for (regno = 0; regno < 16; ++regno)
		  if (val & (0x8000 >> regno))
		    newval |= 1 << regno;
		val = newval;
	      }
	    val &= 0xffff;
	    doneany = 0;
	    for (regno = 0; regno < 16; ++regno)
	      if (val & (1 << regno))
		{
		  int first_regno;

		  if (doneany)
		    (*info->fprintf_func) (info->stream, "/");
		  doneany = 1;
		  (*info->fprintf_func) (info->stream, "%s", reg_names[regno]);
		  first_regno = regno;
		  while (val & (1 << (regno + 1)))
		    ++regno;
		  if (regno > first_regno)
		    (*info->fprintf_func) (info->stream, "-%s",
					   reg_names[regno]);
		}
	  }
	else if (place == '3')
	  {
	    /* `fmovem' insn.  */
	    char doneany;

	    FETCH_ARG (8, val);
	    if (val == 0)
	      {
		(*info->fprintf_func) (info->stream, "#0");
		break;
	      }
	    if (*d == 'l')
	      {
		int newval = 0;

		for (regno = 0; regno < 8; ++regno)
		  if (val & (0x80 >> regno))
		    newval |= 1 << regno;
		val = newval;
	      }
	    val &= 0xff;
	    doneany = 0;
	    for (regno = 0; regno < 8; ++regno)
	      if (val & (1 << regno))
		{
		  int first_regno;
		  if (doneany)
		    (*info->fprintf_func) (info->stream, "/");
		  doneany = 1;
		  (*info->fprintf_func) (info->stream, "%%fp%d", regno);
		  first_regno = regno;
		  while (val & (1 << (regno + 1)))
		    ++regno;
		  if (regno > first_regno)
		    (*info->fprintf_func) (info->stream, "-%%fp%d", regno);
		}
	  }
	else if (place == '8')
	  {
	    FETCH_ARG (3, val);
	    /* fmoveml for FP status registers.  */
	    (*info->fprintf_func) (info->stream, "%s", fpcr_names[val]);
	  }
	else
	  return -2;
      break;

    case 'X':
      place = '8';
    case 'Y':
    case 'Z':
    case 'W':
    case '0':
    case '1':
    case '2':
    case '3':
      {
	char *name = 0;

	FETCH_ARG (5, val);
	switch (val)
	  {
	  case 2: name = "%tt0"; break;
	  case 3: name = "%tt1"; break;
	  case 0x10: name = "%tc"; break;
	  case 0x11: name = "%drp"; break;
	  case 0x12: name = "%srp"; break;
	  case 0x13: name = "%crp"; break;
	  case 0x14: name = "%cal"; break;
	  case 0x15: name = "%val"; break;
	  case 0x16: name = "%scc"; break;
	  case 0x17: name = "%ac"; break;
 	  case 0x18: name = "%psr"; break;
	  case 0x19: name = "%pcsr"; break;
	  case 0x1c:
	  case 0x1d:
	    {
	      int break_reg = ((buffer[3] >> 2) & 7);

	      (*info->fprintf_func)
		(info->stream, val == 0x1c ? "%%bad%d" : "%%bac%d",
		 break_reg);
	    }
	    break;
	  default:
	    (*info->fprintf_func) (info->stream, "<mmu register %d>", val);
	  }
	if (name)
	  (*info->fprintf_func) (info->stream, "%s", name);
      }
      break;

    case 'f':
      {
	int fc;

	FETCH_ARG (5, fc);
	if (fc == 1)
	  (*info->fprintf_func) (info->stream, "%%dfc");
	else if (fc == 0)
	  (*info->fprintf_func) (info->stream, "%%sfc");
	else
	  /* xgettext:c-format */
	  (*info->fprintf_func) (info->stream, _("<function code %d>"), fc);
      }
      break;

    case 'V':
      (*info->fprintf_func) (info->stream, "%%val");
      break;

    case 't':
      {
	int level;

	FETCH_ARG (3, level);
	(*info->fprintf_func) (info->stream, "%d", level);
      }
      break;

    case 'u':
      {
	short is_upper = 0;
	int reg;

	FETCH_ARG (5, reg);
	if (reg & 0x10)
	  {
	    is_upper = 1;
	    reg &= 0xf;
	  }
	(*info->fprintf_func) (info->stream, "%s%s",
			       reg_half_names[reg],
			       is_upper ? "u" : "l");
      }
      break;

    default:
      return -2;
    }

  return p - p0;
}

/* Try to match the current instruction to best and if so, return the
   number of bytes consumed from the instruction stream, else zero.  */

static int
match_insn_m68k (bfd_vma memaddr,
		 disassemble_info * info,
		 const struct m68k_opcode * best)
{
  unsigned char *save_p;
  unsigned char *p;
  const char *d;
  const char *args = best->args;

  struct private *priv = (struct private *) info->private_data;
  bfd_byte *buffer = priv->the_buffer;
  fprintf_ftype save_printer = info->fprintf_func;
  void (* save_print_address) (bfd_vma, struct disassemble_info *)
    = info->print_address_func;

  if (*args == '.')
    args++;
  
  /* Point at first word of argument data,
     and at descriptor for first argument.  */
  p = buffer + 2;

  /* Figure out how long the fixed-size portion of the instruction is.
     The only place this is stored in the opcode table is
     in the arguments--look for arguments which specify fields in the 2nd
     or 3rd words of the instruction.  */
  for (d = args; *d; d += 2)
    {
      /* I don't think it is necessary to be checking d[0] here;
	 I suspect all this could be moved to the case statement below.  */
      if (d[0] == '#')
	{
	  if (d[1] == 'l' && p - buffer < 6)
	    p = buffer + 6;
	  else if (p - buffer < 4 && d[1] != 'C' && d[1] != '8')
	    p = buffer + 4;
	}

      if ((d[0] == 'L' || d[0] == 'l') && d[1] == 'w' && p - buffer < 4)
	p = buffer + 4;

      switch (d[1])
	{
	case '1':
	case '2':
	case '3':
	case '7':
	case '8':
	case '9':
	case 'i':
	  if (p - buffer < 4)
	    p = buffer + 4;
	  break;
	case '4':
	case '5':
	case '6':
	  if (p - buffer < 6)
	    p = buffer + 6;
	  break;
	default:
	  break;
	}
    }

  /* pflusha is an exceptions.  It takes no arguments but is two words
     long.  Recognize it by looking at the lower 16 bits of the mask.  */
  if (p - buffer < 4 && (best->match & 0xFFFF) != 0)
    p = buffer + 4;

  /* lpstop is another exception.  It takes a one word argument but is
     three words long.  */
  if (p - buffer < 6
      && (best->match & 0xffff) == 0xffff
      && args[0] == '#'
      && args[1] == 'w')
    {
      /* Copy the one word argument into the usual location for a one
	 word argument, to simplify printing it.  We can get away with
	 this because we know exactly what the second word is, and we
	 aren't going to print anything based on it.  */
      p = buffer + 6;
      FETCH_DATA (info, p);
      buffer[2] = buffer[4];
      buffer[3] = buffer[5];
    }

  FETCH_DATA (info, p);

  save_p = p;
  info->print_address_func = dummy_print_address;
  info->fprintf_func = (fprintf_ftype) dummy_printer;

  /* We scan the operands twice.  The first time we don't print anything,
     but look for errors.  */
  for (d = args; *d; d += 2)
    {
      int eaten = print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);

      if (eaten >= 0)
	p += eaten;
      else if (eaten == -1 || eaten == -3)
	{
	  info->fprintf_func = save_printer;
	  info->print_address_func = save_print_address;
	  return 0;
	}
      else
	{
	  /* We must restore the print functions before trying to print the
	     error message.  */
	  info->fprintf_func = save_printer;
	  info->print_address_func = save_print_address;
	  info->fprintf_func (info->stream,
			      /* xgettext:c-format */
			      _("<internal error in opcode table: %s %s>\n"),
			      best->name, best->args);
	  return 2;
	}
    }

  p = save_p;
  info->fprintf_func = save_printer;
  info->print_address_func = save_print_address;

  d = args;

  info->fprintf_func (info->stream, "%s", best->name);

  if (*d)
    info->fprintf_func (info->stream, " ");

  while (*d)
    {
      p += print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);
      d += 2;

      if (*d && *(d - 2) != 'I' && *d != 'k')
	info->fprintf_func (info->stream, ",");
    }

  return p - buffer;
}

/* Try to interpret the instruction at address MEMADDR as one that
   can execute on a processor with the features given by ARCH_MASK.
   If successful, print the instruction to INFO->STREAM and return
   its length in bytes.  Return 0 otherwise.  */

static int
m68k_scan_mask (bfd_vma memaddr, disassemble_info *info,
		unsigned int arch_mask)
{
  int i;
  const char *d;
  static const struct m68k_opcode **opcodes[16];
  static int numopcodes[16];
  int val;
  int major_opcode;

  struct private *priv = (struct private *) info->private_data;
  bfd_byte *buffer = priv->the_buffer;

  if (!opcodes[0])
    {
      /* Speed up the matching by sorting the opcode
	 table on the upper four bits of the opcode.  */
      const struct m68k_opcode **opc_pointer[16];

      /* First count how many opcodes are in each of the sixteen buckets.  */
      for (i = 0; i < m68k_numopcodes; i++)
	numopcodes[(m68k_opcodes[i].opcode >> 28) & 15]++;

      /* Then create a sorted table of pointers
	 that point into the unsorted table.  */
      opc_pointer[0] = xmalloc (sizeof (struct m68k_opcode *)
				* m68k_numopcodes);
      opcodes[0] = opc_pointer[0];

      for (i = 1; i < 16; i++)
	{
	  opc_pointer[i] = opc_pointer[i - 1] + numopcodes[i - 1];
	  opcodes[i] = opc_pointer[i];
	}

      for (i = 0; i < m68k_numopcodes; i++)
	*opc_pointer[(m68k_opcodes[i].opcode >> 28) & 15]++ = &m68k_opcodes[i];
    }

  FETCH_DATA (info, buffer + 2);
  major_opcode = (buffer[0] >> 4) & 15;

  for (i = 0; i < numopcodes[major_opcode]; i++)
    {
      const struct m68k_opcode *opc = opcodes[major_opcode][i];
      unsigned long opcode = opc->opcode;
      unsigned long match = opc->match;
      const char *args = opc->args;

      if (*args == '.')
	args++;

      if (((0xff & buffer[0] & (match >> 24)) == (0xff & (opcode >> 24)))
	  && ((0xff & buffer[1] & (match >> 16)) == (0xff & (opcode >> 16)))
	  /* Only fetch the next two bytes if we need to.  */
	  && (((0xffff & match) == 0)
	      ||
	      (FETCH_DATA (info, buffer + 4)
	       && ((0xff & buffer[2] & (match >> 8)) == (0xff & (opcode >> 8)))
	       && ((0xff & buffer[3] & match) == (0xff & opcode)))
	      )
	  && (opc->arch & arch_mask) != 0)
	{
	  /* Don't use for printout the variants of divul and divsl
	     that have the same register number in two places.
	     The more general variants will match instead.  */
	  for (d = args; *d; d += 2)
	    if (d[1] == 'D')
	      break;

	  /* Don't use for printout the variants of most floating
	     point coprocessor instructions which use the same
	     register number in two places, as above.  */
	  if (*d == '\0')
	    for (d = args; *d; d += 2)
	      if (d[1] == 't')
		break;

	  /* Don't match fmovel with more than one register;
	     wait for fmoveml.  */
	  if (*d == '\0')
	    {
	      for (d = args; *d; d += 2)
		{
		  if (d[0] == 's' && d[1] == '8')
		    {
		      val = fetch_arg (buffer, d[1], 3, info);
		      if (val < 0)
			return 0;
		      if ((val & (val - 1)) != 0)
			break;
		    }
		}
	    }

	  /* Don't match FPU insns with non-default coprocessor ID.  */
	  if (*d == '\0')
	    {
	      for (d = args; *d; d += 2)
		{
		  if (d[0] == 'I')
		    {
		      val = fetch_arg (buffer, 'd', 3, info);
		      if (val != 1)
			break;
		    }
		}
	    }

	  if (*d == '\0')
	    if ((val = match_insn_m68k (memaddr, info, opc)))
	      return val;
	}
    }
  return 0;
}		

/* Print the m68k instruction at address MEMADDR in debugged memory,
   on INFO->STREAM.  Returns length of the instruction, in bytes.  */

int
print_insn_m68k (bfd_vma memaddr, disassemble_info *info)
{
  unsigned int arch_mask;
  struct private priv;
  int val;

  bfd_byte *buffer = priv.the_buffer;

  info->private_data = & priv;
  /* Tell objdump to use two bytes per chunk
     and six bytes per line for displaying raw data.  */
  info->bytes_per_chunk = 2;
  info->bytes_per_line = 6;
  info->display_endian = BFD_ENDIAN_BIG;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = memaddr;

  arch_mask = bfd_m68k_mach_to_features (info->mach);
  if (!arch_mask)
    {
      /* First try printing an m680x0 instruction.  Try printing a Coldfire
	 one if that fails.  */
      val = m68k_scan_mask (memaddr, info, m68k_mask);
      if (val == 0)
	val = m68k_scan_mask (memaddr, info, mcf_mask);
    }
  else
    {
      val = m68k_scan_mask (memaddr, info, arch_mask);
    }

  if (val == 0)
    /* Handle undefined instructions.  */
    info->fprintf_func (info->stream, ".short 0x%04x", (buffer[0] << 8) + buffer[1]);

  return val ? val : 2;
}
@


1.37
log
@2010-06-16  Vincent Rivire  <vincent.riviere@@freesbee.fr>

        PR binutils/11676
        * m68k-dis.c (print_insn_arg): Prefix float constants with #0e.

2010-06-16  Nick Clifton  <nickc@@redhat.com>

        PR binutils/11676
        * gas/m68k/pr11676.s: New test.
        * gas/m68k/pr11676.d: Expected disassembly.
        * gas/m68k/all.exp: Run the new test.
@
text
@d3 2
a4 2
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
d657 1
a657 1
	(*info->fprintf_func) (info->stream, cacheFieldName[val]);
d795 1
a795 1
	  (*info->fprintf_func) (info->stream, scalefactor_name[val]);
@


1.36
log
@        * m68k-dis.c (print_insn_m68k): Emit undefined instructions as
        .short directives so that they can be reassembled.
@
text
@d1114 1
a1114 1
		(*info->fprintf_func) (info->stream, "#%g", flval);
@


1.35
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1629 1
a1629 1
    info->fprintf_func (info->stream, "0%o", (buffer[0] << 8) + buffer[1]);
@


1.34
log
@	* config/m68k-parse.h (enum m68k_register): Add ACR[4-7], RGPIOBAR.
	* config/tc-m68k.c (mcf5206_ctrl): Fix whitespace.
	(mcf52223_ctrl): Remove non-existent registers.
	(mcf54418): Define.
	(mcf54455): Remove MBAR.
	(m68k_cpus): Add lines for MCF5441x family.
	(m68k_ip, init_table): Handle RGPIOBAR, ACR[4-7].

	* m68k-dis.c (print_insn_arg): Handle RGPIOBAR, ACR[4-7] and MBAR[01].
@
text
@a1234 1
	int val;
@


1.33
log
@update copyright dates
@
text
@d710 2
d716 1
a716 1
	       Rec c05 is also sometimes called rambar.  */
d719 3
a721 1
	    {"%mbar", 0xc0f},
@


1.32
log
@        * m68k-dis.c (print_insn_arg): Add movecr register names for
        coldfire v4e families.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
@


1.31
log
@(NEXTBYTE, NEXTWORD, NEXTLONG, NEXTULONG, NEXTSINGLE)
(NEXTDOUBLE, NEXTEXTEND, NEXTPACKED): Fix error handling.
(save_printer, save_print_address): Remove.
(fetch_data): Don't use them.
(match_insn_m68k): Always restore printing functions.
(print_insn_m68k): Don't save/restore printing functions.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d702 32
a733 19
	   same address different names. This table can't get it right
	   because it doesn't know which processor it's disassembling for.  */
	static const struct { char *name; int value; } names[]
	  = {{"%sfc", 0x000}, {"%dfc", 0x001}, {"%cacr", 0x002},
	     {"%tc",  0x003}, {"%itt0",0x004}, {"%itt1", 0x005},
             {"%dtt0",0x006}, {"%dtt1",0x007}, {"%buscr",0x008},
	     {"%usp", 0x800}, {"%vbr", 0x801}, {"%caar", 0x802},
	     {"%msp", 0x803}, {"%isp", 0x804},
	     /* reg c04 is sometimes called flashbar or rambar.
		rec c05 is also sometimes called rambar.  */
	     {"%rambar0", 0xc04}, {"%rambar1", 0xc05},

	     /* Should we be calling this psr like we do in case 'Y'?  */
	     {"%mmusr",0x805},

             {"%urp", 0x806}, {"%srp", 0x807}, {"%pcr", 0x808},

	     /* Fido added these.  */
             {"%cac", 0xffe}, {"%mbo", 0xfff}};
d735 1
d737 12
a748 1
	for (regno = sizeof names / sizeof names[0] - 1; regno >= 0; regno--)
d755 1
a755 1
	  (*info->fprintf_func) (info->stream, "%d", val);
@


1.30
log
@        * m68k-dis.c: Rewrite to remove use of setjmp/longjmp.
@
text
@d67 1
a67 1
      if (FETCH_DATA (info, p) < 0)		\
d80 1
a80 1
      if (FETCH_DATA (info, p) < 0)		\
d93 1
a93 1
      if (FETCH_DATA (info, p) < 0)					\
d104 1
a104 1
      if (FETCH_DATA (info, p) < 0)					\
d115 1
a115 1
      if (FETCH_DATA (info, p) < 0)				\
d127 1
a127 1
      if (FETCH_DATA (info, p) , 0)				\
d139 1
a139 1
      if (FETCH_DATA (info, p) < 0)			\
d154 1
a154 1
      if (FETCH_DATA (info, p) < 0)		\
a173 3
static fprintf_ftype save_printer;
static void (* save_print_address) (bfd_vma, struct disassemble_info *);

a193 2
      info->fprintf_func = save_printer;
      info->print_address_func = save_print_address;
d1398 1
a1398 1
      else if (eaten == -1)
a1403 2
      else if (eaten == -3)
	return 0;
a1569 2
  fprintf_ftype save_printer;
  void (* save_print_address) (bfd_vma, struct disassemble_info *);
a1575 5
  /* Save these printing functions in case we need to restore them
     later.  */
  save_printer = info->fprintf_func;
  save_print_address = info->print_address_func;

a1602 4
  /* Restore print functions.  */
  info->fprintf_func = save_printer;
  info->print_address_func = save_print_address;

@


1.29
log
@gas/
	* config/m68k-parse.h (m68k_register): Use MBO instead of MBB.
	(last_movec_reg): Change to MBO.
	* config/tc-m68k.c (fido_ctrl): Use MBO instead of MBB.
	(m68k_ip): Use MBO instead of MBO.
	(init_table): Use MBO instead of MBO.  Add an entry for mbo.

gas/testsuite/
	* gas/m68k/fido.s: Add tests for %mbo.
	* gas/m68k/fido.d: Update accordingly.

opcodes/
	* m68k-dis.c (print_insn_arg): Use %mbo instead of %mbb.
@
text
@d63 9
a71 1
#define NEXTBYTE(p)  (p += 2, FETCH_DATA (info, p), COERCE_SIGNED_CHAR(p[-1]))
d75 10
a84 3
#define NEXTWORD(p)  \
  (p += 2, FETCH_DATA (info, p), \
   COERCE16 ((p[-2] << 8) + p[-1]))
d88 10
a97 3
#define NEXTLONG(p)  \
  (p += 4, FETCH_DATA (info, p), \
   (COERCE32 ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1])))
d100 9
a108 3
#define NEXTULONG(p)  \
  (p += 4, FETCH_DATA (info, p), \
   (unsigned int) ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]))
d111 10
a120 3
#define NEXTSINGLE(val, p) \
  (p += 4, FETCH_DATA (info, p), \
   floatformat_to_double (&floatformat_ieee_single_big, (char *) p - 4, &val))
d123 10
a132 3
#define NEXTDOUBLE(val, p) \
  (p += 8, FETCH_DATA (info, p), \
   floatformat_to_double (&floatformat_ieee_double_big, (char *) p - 8, &val))
d135 10
a144 3
#define NEXTEXTEND(val, p) \
  (p += 12, FETCH_DATA (info, p), \
   floatformat_to_double (&floatformat_m68881_ext, (char *) p - 12, &val))
d150 10
a159 2
#define NEXTPACKED(p) \
  (p += 12, FETCH_DATA (info, p), 0.0)
a171 1
  jmp_buf bailout;
d174 3
d178 1
a178 2
   to ADDR (exclusive) are valid.  Returns 1 for success, longjmps
   on error.  */
d197 3
a199 1
      longjmp (priv->bailout, 1);
d224 2
a225 1
   BUFFER contains the instruction.  */
d280 2
a281 1
      FETCH_DATA (info, buffer + 3);
d286 2
a287 1
      FETCH_DATA (info, buffer + 3);
d292 2
a293 1
      FETCH_DATA (info, buffer + 3);
d299 2
a300 1
      FETCH_DATA (info, buffer + 3);
d307 2
a308 1
      FETCH_DATA (info, buffer + 3);
d313 2
a314 1
      FETCH_DATA (info, buffer + 5);
d320 2
a321 1
      FETCH_DATA (info, buffer + 5);
d327 2
a328 1
      FETCH_DATA (info, buffer + 5);
d333 2
a334 1
      FETCH_DATA (info, buffer + 3);
d340 2
a341 1
      FETCH_DATA (info, buffer + 3);
d347 2
a348 1
      FETCH_DATA (info, buffer + 3);
d358 2
a359 1
      FETCH_DATA (info, buffer + 3);
d526 2
a527 1
   ADDR is the nominal core address of that extension word.  */
d542 1
a542 1
  word = NEXTWORD (p);
d580 1
a580 1
      base_disp = NEXTWORD (p);
d583 1
a583 1
      base_disp = NEXTLONG (p);
d603 1
a603 1
      outer_disp = NEXTWORD (p);
d606 1
a606 1
      outer_disp = NEXTLONG (p);
d624 9
d635 1
a635 1
   an opcode tabe error was found.
d661 2
a662 2
        val = fetch_arg (buffer, place, 2, info);
        (*info->fprintf_func) (info->stream, cacheFieldName[val]);
d668 2
a669 4
        (*info->fprintf_func)
	  (info->stream,
	   "%s@@",
	   reg_names[fetch_arg (buffer, place, 3, info) + 8]);
d675 1
a675 1
        uval = NEXTULONG (p);
d727 1
a727 1
	val = fetch_arg (buffer, place, 12, info);
d740 1
a740 1
      val = fetch_arg (buffer, place, 3, info);
d748 1
a748 1
      val = fetch_arg (buffer, place, 3, info);
d756 1
a756 1
      val = fetch_arg (buffer, place, 3, info);
d761 1
a761 1
      val = fetch_arg (buffer, place, 9, info);
d769 2
a770 1
	  val = fetch_arg (buffer, place, 1, info);
d775 1
a775 1
	  val = fetch_arg (buffer, place, 8, info);
d783 1
a783 1
      val = fetch_arg (buffer, place, 4, info);
d788 2
a789 2
      (*info->fprintf_func) (info->stream, "%s",
			     reg_names[fetch_arg (buffer, place, 3, info)]);
d793 2
a794 3
      (*info->fprintf_func)
	(info->stream, "%s",
	 reg_names[fetch_arg (buffer, place, 3, info) + 010]);
d798 2
a799 3
      (*info->fprintf_func)
	(info->stream, "%s",
	 reg_names[fetch_arg (buffer, place, 4, info)]);
d803 1
a803 1
      regno = fetch_arg (buffer, place, 4, info);
d811 2
a812 3
      (*info->fprintf_func)
	(info->stream, "%%fp%d",
	 fetch_arg (buffer, place, 3, info));
d816 1
a816 1
      val = fetch_arg (buffer, place, 6, info);
d824 2
a825 3
      (*info->fprintf_func)
	(info->stream, "%s@@+",
	 reg_names[fetch_arg (buffer, place, 3, info) + 8]);
d829 2
a830 3
      (*info->fprintf_func)
	(info->stream, "%s@@-",
	 reg_names[fetch_arg (buffer, place, 3, info) + 8]);
d835 4
a838 3
	(*info->fprintf_func)
	  (info->stream, "{%s}",
	   reg_names[fetch_arg (buffer, place, 3, info)]);
d841 1
a841 1
	  val = fetch_arg (buffer, place, 7, info);
d847 1
a847 1
	return -2;
d854 1
a854 1
	val = fetch_arg (buffer, place, 4, info);
d856 1
a856 1
	val = fetch_arg (buffer, place, 7, info);
d858 1
a858 1
	val = fetch_arg (buffer, place, 3, info);
d860 1
a860 1
	val = fetch_arg (buffer, place, 8, info);
d862 1
a862 1
	val = NEXTBYTE (p1);
d864 1
a864 1
	val = NEXTWORD (p1);
d866 1
a866 1
	val = NEXTLONG (p1);
d869 1
d875 1
a875 1
	disp = NEXTBYTE (p);
d879 1
a879 1
	disp = NEXTWORD (p);
d881 1
a881 1
	disp = NEXTLONG (p);
d884 1
a884 1
	  disp = NEXTBYTE (buffer);
d886 1
a886 1
	    disp = NEXTWORD (p);
d888 1
a888 1
	    disp = NEXTLONG (p);
d893 1
a893 1
	    disp = NEXTLONG (p);
d895 1
a895 1
	    disp = NEXTWORD (p);
d904 8
a911 5
      val = NEXTWORD (p);
      (*info->fprintf_func)
	(info->stream, "%s@@(%d)",
	 reg_names[fetch_arg (buffer, place, 3, info) + 8], val);
      break;
d914 2
a915 2
      (*info->fprintf_func) (info->stream, "%s",
			     fpcr_names[fetch_arg (buffer, place, 3, info)]);
d919 1
a919 1
      val = fetch_arg(buffer, place, 2, info);
d924 2
a925 2
      val = fetch_arg(buffer, place, 1, info);
      (*info->fprintf_func) (info->stream, "%%accext%s", val==0 ? "01" : "23");
d929 1
a929 1
      val = fetch_arg(buffer, place, 2, info);
d941 2
a942 1

d974 2
d979 5
a983 1
	val = fetch_arg (buffer, 's', 6, info);
d1015 1
a1015 1
	  val = NEXTWORD (p);
d1021 2
d1029 1
a1029 1
	      val = NEXTWORD (p);
d1034 1
a1034 1
	      uval = NEXTULONG (p);
d1039 1
a1039 1
	      val = NEXTWORD (p);
d1047 2
d1056 1
a1056 1
		  val = NEXTBYTE (p);
d1061 1
a1061 1
		  val = NEXTWORD (p);
d1066 1
a1066 1
		  val = NEXTLONG (p);
d1083 1
a1083 1
		  flval = NEXTPACKED (p);
d1105 1
a1105 1
	  val = fetch_arg (buffer, place, 1, info);
d1117 1
a1117 1
	    val = NEXTWORD (p1);
d1158 2
a1159 1
	    val = fetch_arg (buffer, place, 8, info);
d1193 1
d1195 1
a1195 3
	    (*info->fprintf_func) (info->stream, "%s",
				   fpcr_names[fetch_arg (buffer, place, 3,
							 info)]);
d1211 1
a1211 1
	int val = fetch_arg (buffer, place, 5, info);
d1214 1
d1249 1
a1249 1
	int fc = fetch_arg (buffer, place, 5, info);
d1251 1
d1268 1
a1268 1
	int level = fetch_arg (buffer, place, 3, info);
d1270 1
d1278 1
a1278 1
	int reg = fetch_arg (buffer, place, 5, info);
d1280 1
d1409 2
d1420 1
a1420 1
			      best->name,  best->args);
d1541 2
d1577 2
d1587 2
a1588 3
  fprintf_ftype save_printer = info->fprintf_func;
  void (* save_print_address) (bfd_vma, struct disassemble_info *)
    = info->print_address_func;
d1590 1
a1590 1
  info->private_data = (PTR) &priv;
a1598 22
  if (setjmp (priv.bailout) != 0)
    {
      /* longjmp may be called while these printing functions are
	 temporarily replaced with dummy functions.  Restore them
	 before we leave.

	 Admittedly, this save-and-restore operation is somewhat ugly
	 in that we are exposing the fact that match_insn_m68k
	 temporarily replaces insn->fprintf_func and
	 insn->print_address_func.  Perhaps, a real fix is to report a
	 FETCH_DATA failure with a return value of some sort, without
	 using setjmp/longjmp.  A better fix may be to teach the m68k
	 disassembler do its job without temporarily replacing
	 insn->fprintf_func and insn->print_address_func, but that's a
	 task for another day.  */
      info->fprintf_func = save_printer;
      info->print_address_func = save_print_address;

      /* Error return.  */
      return -1;
    }

d1605 2
a1606 6
      if (val)
	return val;

      val = m68k_scan_mask (memaddr, info, mcf_mask);
      if (val)
	return val;
a1610 2
      if (val)
	return val;
d1613 9
a1621 3
  /* Handle undefined instructions.  */
  info->fprintf_func (info->stream, "0%o", (buffer[0] << 8) + buffer[1]);
  return 2;
@


1.29.8.1
log
@* m68k-dis.c: Rewrite to remove use of setjmp/longjmp.
@
text
@d63 1
a63 9
#define NEXTBYTE(p, val)			\
  do						\
    {						\
      p += 2;					\
      if (FETCH_DATA (info, p) < 0)		\
	return -3;				\
      val = COERCE_SIGNED_CHAR (p[-1]);		\
    }						\
  while (0)
d67 3
a69 10

#define NEXTWORD(p, val, ret_val)		\
  do						\
    {						\
      p += 2;					\
      if (FETCH_DATA (info, p) < 0)		\
	return ret_val;				\
      val = COERCE16 ((p[-2] << 8) + p[-1]);	\
    }						\
  while (0)						
d73 3
a75 10

#define NEXTLONG(p, val, ret_val)					\
  do									\
    {									\
      p += 4;								\
      if (FETCH_DATA (info, p) < 0)					\
	return ret_val;							\
      val = COERCE32 ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]); \
    }									\
  while (0)
d78 3
a80 9
#define NEXTULONG(p, val)						\
  do									\
    {									\
      p += 4;								\
      if (FETCH_DATA (info, p) < 0)					\
	return -3;							\
      val = (unsigned int) ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]); \
    }									\
  while (0)
d83 3
a85 10
#define NEXTSINGLE(val, p)					\
  do								\
    {								\
      p += 4;							\
      if (FETCH_DATA (info, p) < 0)				\
	return -3;						\
      floatformat_to_double (& floatformat_ieee_single_big,	\
			     (char *) p - 4, & val);		\
    }								\
  while (0)
d88 3
a90 10
#define NEXTDOUBLE(val, p)					\
  do								\
    {								\
      p += 8;							\
      if (FETCH_DATA (info, p) , 0)				\
	return -3;						\
      floatformat_to_double (& floatformat_ieee_double_big,	\
			     (char *) p - 8, & val);		\
    }								\
  while (0)
d93 3
a95 10
#define NEXTEXTEND(val, p)				\
  do							\
    {							\
      p += 12;						\
      if (FETCH_DATA (info, p) < 0)			\
	return -3;					\
      floatformat_to_double (& floatformat_m68881_ext,	\
			     (char *) p - 12, & val);	\
    }							\
  while (0)
d101 2
a102 10
#define NEXTPACKED(p, val)			\
  do						\
    {						\
      p += 12;					\
      if (FETCH_DATA (info, p) < 0)		\
	return -3;				\
      val = 0.0;				\
    }						\
  while (0)

d115 1
a117 3
static fprintf_ftype save_printer;
static void (* save_print_address) (bfd_vma, struct disassemble_info *);

d119 2
a120 1
   to ADDR (exclusive) are valid.  Returns 1 for success, 0 on error.  */
d139 1
a139 3
      info->fprintf_func = save_printer;
      info->print_address_func = save_print_address;
      return 0;
d164 1
a164 2
   BUFFER contains the instruction.
   Returns -1 on failure.  */
d219 1
a219 2
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
d224 1
a224 2
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
d229 1
a229 2
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
d235 1
a235 2
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
d242 1
a242 2
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
d247 1
a247 2
      if (! FETCH_DATA (info, buffer + 5))
	return -1;
d253 1
a253 2
      if (! FETCH_DATA (info, buffer + 5))
	return -1;
d259 1
a259 2
      if (! FETCH_DATA (info, buffer + 5))
	return -1;
d264 1
a264 2
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
d270 1
a270 2
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
d276 1
a276 2
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
d286 1
a286 2
      if (! FETCH_DATA (info, buffer + 3))
	return -1;
d453 1
a453 2
   ADDR is the nominal core address of that extension word.
   Returns NULL upon error.  */
d468 1
a468 1
  NEXTWORD (p, word, NULL);
d506 1
a506 1
      NEXTWORD (p, base_disp, NULL);
d509 1
a509 1
      NEXTLONG (p, base_disp, NULL);
d529 1
a529 1
      NEXTWORD (p, outer_disp, NULL);
d532 1
a532 1
      NEXTLONG (p, outer_disp, NULL);
a549 9
#define FETCH_ARG(size, val)				\
  do							\
    {							\
      val = fetch_arg (buffer, place, size, info);	\
      if (val < 0)					\
	return -3;					\
    }							\
  while (0)

d552 1
a552 1
   an opcode tabe error was found or -3 to simply abort.
d578 2
a579 2
        FETCH_ARG (2, val);
	(*info->fprintf_func) (info->stream, cacheFieldName[val]);
d585 4
a588 2
	FETCH_ARG (3, val);
	(*info->fprintf_func) (info->stream, "%s@@", reg_names[val + 8]);
d594 1
a594 1
        NEXTULONG (p, uval);
d646 1
a646 1
	FETCH_ARG (12, val);
d659 1
a659 1
      FETCH_ARG (3, val);
d667 1
a667 1
      FETCH_ARG (3, val);
d675 1
a675 1
      FETCH_ARG (3, val);
d680 1
a680 1
      FETCH_ARG (9, val);
d688 1
a688 2

	  FETCH_ARG (1, val);
d693 1
a693 1
	  FETCH_ARG (8, val);
d701 1
a701 1
      FETCH_ARG (4, val);
d706 2
a707 2
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%s", reg_names[val]);
d711 3
a713 2
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%s", reg_names[val + 010]);
d717 3
a719 2
      FETCH_ARG (4, val);
      (*info->fprintf_func) (info->stream, "%s", reg_names[val]);
d723 1
a723 1
      FETCH_ARG (4, regno);
d731 3
a733 2
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%%fp%d", val);
d737 1
a737 1
      FETCH_ARG (6, val);
d745 3
a747 2
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%s@@+", reg_names[val + 8]);
d751 3
a753 2
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%s@@-", reg_names[val + 8]);
d758 3
a760 4
	{
	  FETCH_ARG (3, val);
	  (*info->fprintf_func) (info->stream, "{%s}", reg_names[val]);
	}
d763 1
a763 1
	  FETCH_ARG (7, val);
d769 1
a769 1
	return -1;
d776 1
a776 1
	FETCH_ARG (4, val);
d778 1
a778 1
	FETCH_ARG (7, val);
d780 1
a780 1
	FETCH_ARG (3, val);
d782 1
a782 1
	FETCH_ARG (8, val);
d784 1
a784 1
	NEXTBYTE (p1, val);
d786 1
a786 1
	NEXTWORD (p1, val, -3);
d788 1
a788 1
	NEXTLONG (p1, val, -3);
a790 1

d796 1
a796 1
	NEXTBYTE (p, disp);
d800 1
a800 1
	NEXTWORD (p, disp, -3);
d802 1
a802 1
	NEXTLONG (p, disp, -3);
d805 1
a805 1
	  NEXTBYTE (buffer, disp);
d807 1
a807 1
	    NEXTWORD (p, disp, -3);
d809 1
a809 1
	    NEXTLONG (p, disp, -3);
d814 1
a814 1
	    NEXTLONG (p, disp, -3);
d816 1
a816 1
	    NEXTWORD (p, disp, -3);
d825 5
a829 8
      {
	int val1;

	NEXTWORD (p, val, -3);
	FETCH_ARG (3, val1);
	(*info->fprintf_func) (info->stream, "%s@@(%d)", reg_names[val1 + 8], val);
	break;
      }
d832 2
a833 2
      FETCH_ARG (3, val);
      (*info->fprintf_func) (info->stream, "%s", fpcr_names[val]);
d837 1
a837 1
      FETCH_ARG (2, val);
d842 2
a843 2
      FETCH_ARG (1, val);
      (*info->fprintf_func) (info->stream, "%%accext%s", val == 0 ? "01" : "23");
d847 1
a847 1
      FETCH_ARG (2, val);
d859 1
a859 2
      if (val < 0)
	return -3;
a890 2
	  if (val < 0)
	    return -3;
d894 1
a894 5
	{
	  val = fetch_arg (buffer, 's', 6, info);
	  if (val < 0)
	    return -3;
	}
d926 1
a926 1
	  NEXTWORD (p, val, -3);
a931 2
	  if (p == NULL)
	    return -3;
d938 1
a938 1
	      NEXTWORD (p, val, -3);
d943 1
a943 1
	      NEXTULONG (p, uval);
d948 1
a948 1
	      NEXTWORD (p, val, -3);
a955 2
	      if (p == NULL)
		return -3;
d963 1
a963 1
		  NEXTBYTE (p, val);
d968 1
a968 1
		  NEXTWORD (p, val, -3);
d973 1
a973 1
		  NEXTLONG (p, val, -3);
d990 1
a990 1
		  NEXTPACKED (p, flval);
d1012 1
a1012 1
	  FETCH_ARG (1, val);
d1024 1
a1024 1
	    NEXTWORD (p1, val, -3);
d1065 1
a1065 2

	    FETCH_ARG (8, val);
a1098 1
	    FETCH_ARG (3, val);
d1100 3
a1102 1
	    (*info->fprintf_func) (info->stream, "%s", fpcr_names[val]);
d1118 1
a1118 1
	int val;
a1120 1
	FETCH_ARG (5, val);
d1155 1
a1155 1
	int fc;
a1156 1
	FETCH_ARG (5, fc);
d1173 1
a1173 1
	int level;
a1174 1
	FETCH_ARG (3, level);
d1182 1
a1182 1
	int reg;
a1183 1
	FETCH_ARG (5, reg);
a1311 2
      else if (eaten == -3)
	return 0;
d1321 1
a1321 1
			      best->name, best->args);
a1441 2
		      if (val < 0)
			return 0;
a1475 2
  fprintf_ftype save_printer;
  void (* save_print_address) (bfd_vma, struct disassemble_info *);
d1484 3
a1486 2
  save_printer = info->fprintf_func;
  save_print_address = info->print_address_func;
d1488 1
a1488 1
  info->private_data = & priv;
d1497 22
d1525 6
a1530 2
      if (val == 0)
	val = m68k_scan_mask (memaddr, info, mcf_mask);
d1535 2
d1539 3
a1541 9
  if (val == 0)
    /* Handle undefined instructions.  */
    info->fprintf_func (info->stream, "0%o", (buffer[0] << 8) + buffer[1]);

  /* Restore print functions.  */
  info->fprintf_func = save_printer;
  info->print_address_func = save_print_address;

  return val ? val : 2;
@


1.29.8.2
log
@(NEXTBYTE, NEXTWORD, NEXTLONG, NEXTULONG, NEXTSINGLE)
(NEXTDOUBLE, NEXTEXTEND, NEXTPACKED): Fix error handling.
(save_printer, save_print_address): Remove.
(fetch_data): Don't use them.
(match_insn_m68k): Always restore printing functions.
(print_insn_m68k): Don't save/restore printing functions.
@
text
@d67 1
a67 1
      if (!FETCH_DATA (info, p))		\
d80 1
a80 1
      if (!FETCH_DATA (info, p))		\
d93 1
a93 1
      if (!FETCH_DATA (info, p))					\
d104 1
a104 1
      if (!FETCH_DATA (info, p))					\
d115 1
a115 1
      if (!FETCH_DATA (info, p))				\
d127 1
a127 1
      if (!FETCH_DATA (info, p))				\
d139 1
a139 1
      if (!FETCH_DATA (info, p))			\
d154 1
a154 1
      if (!FETCH_DATA (info, p))		\
d174 3
d197 2
d1403 1
a1403 1
      else if (eaten == -1 || eaten == -3)
d1409 2
d1577 2
d1585 5
d1617 4
@


1.28
log
@Change source files over to GPLv3.
@
text
@d644 1
a644 1
             {"%cac", 0xffe}, {"%mbb", 0xfff}};
@


1.27
log
@	gas/testsuite/
	* gas/m68k/mcf-coproc.d: New.
	* gas/m68k/mcf-coproc.s: New.
	* gas/m68k/all.exp: Add it.

	gas/
	* config/tc-m68k.c (m68k_ip): Add j & K operand types.
	(install_operand): Add E encoding.
	(md_begin): Check and skip initial '.' arg character.
	(get_num): Add 0..511 case.

	include/
	* opcode/m68k.h: Document j K & E.

	opcodes/
	* m68k-dis.c (fetch_arg): Add E.  Replace length switch with
	direct masking.
	(print_ins_arg): Add j & K operand types.
	(match_insn_m68k): Check and skip initial '.' arg character.
	(m68k_scan_mask): Likewise.
	* m68k-opc.c (m68k_opcodes): Add coprocessor instructions.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d6 3
a8 1
   This file is free software; you can redistribute it and/or modify
d10 2
a11 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d13 4
a16 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.26
log
@	gas/
	* config/m68k-parse.h (RAMBAR_ALT): New.
	* config/tc-m68k.c (mcf5206_ctrl, mcf5307_ctrl): New.
	(mcf_ctrl, mcf5208_ctrl, mcf5210a_ctrl, mcf5213_ctrl, mcf52235_ctrl,
	mcf5225_ctrl, mcf5235_ctrl, mcf5271_ctrl, mcf5275_ctrl,
	mcf5282_ctrl, mcf5329_ctrl, mcf5373_ctrl, mcfv4e_ctrl,
	mcf5475_ctrl, mcf5485_ctrl): Add RAMBAR synonym for
	RAMBAR1.
	(mcf5272_ctrl): Add RAMBAR0, replace add RAMBAR with RAMBAR_ALT.
	(m68k_cpus): Adjust 5206, 5206e & 5307 entries.
	(m68k_ip) <Case J>: Detect when RAMBAR_ALT should be used.  Add it
	to control register mapping.

	gas/testsuite/
	* gas/m68k/ctrl-1.d, gas/m68k/ctrl-1.s: New.
	* gas/m68k/ctrl-2.d, gas/m68k/ctrl-2.s: New.
	* gas/m68k/all.exp: Add them.

	opcodes/
	* m68k-dis.c (print_insn_arg): Show c04 as rambar0 and c05 as
	rambar1.
@
text
@d283 5
d318 2
a319 23
  switch (bits)
    {
    case 1:
      return val & 1;
    case 2:
      return val & 3;
    case 3:
      return val & 7;
    case 4:
      return val & 017;
    case 5:
      return val & 037;
    case 6:
      return val & 077;
    case 7:
      return val & 0177;
    case 8:
      return val & 0377;
    case 12:
      return val & 07777;
    default:
      abort ();
    }
d672 10
d1211 1
d1219 3
d1230 1
a1230 1
  for (d = best->args; *d; d += 2)
d1277 2
a1278 2
      && best->args[0] == '#'
      && best->args[1] == 'w')
a1291 2
  d = best->args;

d1298 1
a1298 1
  for (; *d; d += 2)
d1328 1
a1328 1
  d = best->args;
d1400 4
d1419 1
a1419 1
	  for (d = opc->args; *d; d += 2)
d1427 1
a1427 1
	    for (d = opc->args; *d; d += 2)
d1435 1
a1435 1
	      for (d = opc->args; *d; d += 2)
d1449 1
a1449 1
	      for (d = opc->args; *d; d += 2)
@


1.25
log
@	* m68k-dis.c (print_insn_m68k): Restore info->fprintf_func and
	info->print_address_func if longjmp is called.
@
text
@d648 3
a650 1
	     {"%flashbar", 0xc04}, {"%rambar", 0xc05}, /* mcf528x added these.  */
@


1.24
log
@gas/
	* config/m68k-parse.h (m68k_register): Add CAC and MBB.
	* config/tc-m68k.c (fido_ctrl): New.
	(m68k_archs): Use fido_ctrl for -mfidoa.
	(m68k_cpus): Use fido_ctrl on fido-*-*.
	(m68k_ip): Add support for CAC and MBB.
	(init_table): Add CAC and MBB.

opcodes/
	* m68k-dis.c (print_insn_arg): Add support for cac and mbb.
@
text
@d1478 6
d1494 20
a1513 2
    /* Error return.  */
    return -1;
@


1.23
log
@include/opcodes/
	* m68k.h (mcf_mask): Define.

opcodes/
	* m68k-opc.c (m68k_opcodes): Fix the masks of the Coldfire fmovemd
	and fmovem entries.  Put register list entries before immediate
	mask entries.  Use "l" rather than "L" in the fmovem entries.
	* m68k-dis.c (match_insn_m68k): Remove the PRIV argument and work it
	out from INFO.
	(m68k_scan_mask): New function, split out from...
	(print_insn_m68k): ...here.  If no architecture has been set,
	first try printing an m680x0 instruction, then try a Coldfire one.

gas/testsuite/
	* gas/m68k/mcf-fpu.s: Add fmovemd and fmovem instructions.
	* gas/m68k/mcf-fpu.d: Adjust accordingly.
@
text
@d653 4
a656 1
             {"%urp", 0x806}, {"%srp", 0x807}, {"%pcr", 0x808}};
@


1.22
log
@Fix buglet noticed while looking at PR 1298.
* m68k-dis.c (match_insn_m68k): Restore fprintf_func before printing
error message.
@
text
@d1207 1
a1207 2
		 const struct m68k_opcode * best,
		 struct private * priv)
d1213 1
d1346 8
a1353 5
/* Print the m68k instruction at address MEMADDR in debugged memory,
   on INFO->STREAM.  Returns length of the instruction, in bytes.  */

int
print_insn_m68k (bfd_vma memaddr, disassemble_info *info)
d1357 1
a1357 4
  unsigned int arch_mask;
  struct private priv;
  bfd_byte *buffer = priv.the_buffer;
  int major_opcode;
a1358 1
  static const struct m68k_opcode **opcodes[16];
d1360 4
a1390 17
  info->private_data = (PTR) &priv;
  /* Tell objdump to use two bytes per chunk
     and six bytes per line for displaying raw data.  */
  info->bytes_per_chunk = 2;
  info->bytes_per_line = 6;
  info->display_endian = BFD_ENDIAN_BIG;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = memaddr;

  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;

  arch_mask = bfd_m68k_mach_to_features (info->mach);
  if (!arch_mask)
    arch_mask = ~(unsigned int)0;

d1456 1
a1456 1
	    if ((val = match_insn_m68k (memaddr, info, opc, & priv)))
d1460 47
@


1.21
log
@	* bfd/archures.c (bfd_mach_mcf5200, bfd_mach_mcf5206e,
	bfd_mach_mcf5307, bfd_mach_mcf5407, bfd_mach_mcf528x,
	bfd_mach_mcfv4e, bfd_mach_mcf521x, bfd_mach_mcf5249,
	bfd_mach_mcf547x, bfd_mach_mcf548x): Remove.
	(bfd_mach_mcf_isa_a, bfd_mach_mcf_isa_a_div,
	bfd_mach_mcf_isa_a_div_mac, bfd_mach_mcf_isa_a_div_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_aplus_usp,
	bfd_mach_mcf_isa_aplus_usp_mac, bfd_mach_mcf_isa_aplus_usp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac, bfd_mach_mcf_isa_b_emac,
	bfd_mach_mcf_isa_b_usp_float, bfd_mach_mcf_isa_b_usp_float_mac,
	bfd_mach_mcf_isa_b_usp_float_emac): New.
	(bfd_default_scan): Update coldfire mapping.
	* bfd/bfd-in.h (bfd_m68k_mach_to_features,
	bfd_m68k_features_to_mach): Declare.
	* bfd/bfd-in2.h: Rebuilt.
	* bfd/cpu-m68k.c (arch_info_struct): Add new coldfire machines,
	adjust legacy names.
	(m68k_arch_features): New.
	(bfd_m68k_mach_to_features,
	bfd_m68k_features_to_mach): Define.
	* bfd/elf32-m68k.c (elf32_m68k_object_p): New.
	(elf32_m68k_merge_private_bfd_data): Merge the CF EF flags.
	(elf32_m68k_print_private_bfd_data): Print the CF EF flags.
	(elf_backend_object_p): Define.
	* bfd/ieee.c (ieee_write_processor): Update coldfire machines.
	* bfd/libbfd.h: Rebuilt.

	* gas/config/tc-m68k.c (mcf5208_control_regs, mcf5213_control_regs,
	mcf5329_control_regs): New.
	(not_current_architecture, selected_arch, selected_cpu): New.
	(m68k_archs, m68k_extensions): New.
	(archs): Renamed to ...
	(m68k_cpus): ... here.  Adjust.
	(n_arches): Remove.
	(md_pseudo_table): Add arch and cpu directives.
	(find_cf_chip, m68k_ip): Adjust table scanning.
	(no_68851, no_68881): Remove.
	(md_assemble): Lazily initialize.
	(select_control_regs): Adjust cpu names. Add 5208, 5213, 5329.
	(md_init_after_args): Move functionality to m68k_init_arch.
	(mri_chip): Adjust table scanning.
	(md_parse_option): Reimplement 'm' processing to add -march & -mcpu
	options with saner parsing.
	(m68k_lookup_cpu, m68k_set_arch, m68k_set_cpu, m68k_set_extension,
	m68k_init_arch): New.
	(s_m68k_cpu, s_m68k_arch): New.
	(md_show_usage): Adjust.
	(m68k_elf_final_processing): Set CF EF flags.
	* gas/config/tc-m68k.h (m68k_init_after_args): Remove.
	(tc_init_after_args): Remove.
	* gas/doc/c-m68k.texi (M68K-Opts): Document -march, -mcpu options.
	(M68k-Directives): Document .arch and .cpu directives.

	* gas/testsuite/gas/m68k/all.exp: Add arch-cpu-1 test.
	* gas/testsuite/gas/m68k/arch-cpu-1.[sd]: New.

	* include/elf/m68k.h (EF_CPU32, EF_M68000, EF_CFV4E): Rename to ...
	(EF_M68K_CPU32, EF_M68K_M68000, EF_M68K_CFV4E): ... here.
	(EF_M68K_ISA_MASK, EF_M68K_ISA_A, EF_M68K_M68K_ISA_A_PLUS,
	EF_M68K_ISA_B, EF_M68K_HW_DIV, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_USP, EF_M68K_FLOAT): New.

	* include/opcode/m68k.h (m68008, m68ec030, m68882): Remove.
	(m68k_mask): New.
	(cpu_m68k, cpu_cf): New.
	(mcf5200, mcf5206e, mcf521x, mcf5249, mcf528x, mcf5307, mcf5407,
	mcf5470, mcf5480): Rename to cpu_<foo>. Add m680x0 variants.

	* opcodes/m68k-dis.c (print_insn_m68k): Use
	bfd_m68k_mach_to_features.

	* binutils/readelf.c (get_machine_flags): Add logic for EF_M68K flags.
@
text
@d1311 4
a1318 2
	  info->fprintf_func = save_printer;
	  info->print_address_func = save_print_address;
@


1.21.12.1
log
@include/opcodes/
	* m68k.h (mcf_mask): Define.

opcodes/
	* m68k-opc.c (m68k_opcodes): Fix the masks of the Coldfire fmovemd
	and fmovem entries.  Put register list entries before immediate
	mask entries.  Use "l" rather than "L" in the fmovem entries.
	* m68k-dis.c (match_insn_m68k): Remove the PRIV argument and work it
	out from INFO.
	(m68k_scan_mask): New function, split out from...
	(print_insn_m68k): ...here.  If no architecture has been set,
	first try printing an m680x0 instruction, then try a Coldfire one.

gas/testsuite/
	* gas/m68k/mcf-fpu.s: Add fmovemd and fmovem instructions.
	* gas/m68k/mcf-fpu.d: Adjust accordingly.
@
text
@d1207 2
a1208 1
		 const struct m68k_opcode * best)
a1213 1
  struct private *priv = (struct private *) info->private_data;
d1344 5
a1348 8
/* Try to interpret the instruction at address MEMADDR as one that
   can execute on a processor with the features given by ARCH_MASK.
   If successful, print the instruction to INFO->STREAM and return
   its length in bytes.  Return 0 otherwise.  */

static int
m68k_scan_mask (bfd_vma memaddr, disassemble_info *info,
		unsigned int arch_mask)
d1352 5
a1357 1
  static int numopcodes[16];
a1358 4
  int major_opcode;

  struct private *priv = (struct private *) info->private_data;
  bfd_byte *buffer = priv->the_buffer;
d1386 17
d1468 1
a1468 1
	    if ((val = match_insn_m68k (memaddr, info, opc)))
a1471 47
  return 0;
}		

/* Print the m68k instruction at address MEMADDR in debugged memory,
   on INFO->STREAM.  Returns length of the instruction, in bytes.  */

int
print_insn_m68k (bfd_vma memaddr, disassemble_info *info)
{
  unsigned int arch_mask;
  struct private priv;
  int val;

  bfd_byte *buffer = priv.the_buffer;

  info->private_data = (PTR) &priv;
  /* Tell objdump to use two bytes per chunk
     and six bytes per line for displaying raw data.  */
  info->bytes_per_chunk = 2;
  info->bytes_per_line = 6;
  info->display_endian = BFD_ENDIAN_BIG;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = memaddr;

  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;

  arch_mask = bfd_m68k_mach_to_features (info->mach);
  if (!arch_mask)
    {
      /* First try printing an m680x0 instruction.  Try printing a Coldfire
	 one if that fails.  */
      val = m68k_scan_mask (memaddr, info, m68k_mask);
      if (val)
	return val;

      val = m68k_scan_mask (memaddr, info, mcf_mask);
      if (val)
	return val;
    }
  else
    {
      val = m68k_scan_mask (memaddr, info, arch_mask);
      if (val)
	return val;
    }
@


1.21.2.1
log
@include/opcodes/
	* m68k.h (mcf_mask): Define.

opcodes/
	* m68k-opc.c (m68k_opcodes): Fix the masks of the Coldfire fmovemd
	and fmovem entries.  Put register list entries before immediate
	mask entries.  Use "l" rather than "L" in the fmovem entries.
	* m68k-dis.c (match_insn_m68k): Remove the PRIV argument and work it
	out from INFO.
	(m68k_scan_mask): New function, split out from...
	(print_insn_m68k): ...here.  If no architecture has been set,
	first try printing an m680x0 instruction, then try a Coldfire one.
@
text
@d1207 2
a1208 1
		 const struct m68k_opcode * best)
a1213 1
  struct private *priv = (struct private *) info->private_data;
d1344 2
a1345 2
/* Like print_m68k_insn, but restrict the opcode search to the features
   specified by ARCH_MASK.  */
d1347 2
a1348 3
static int
m68k_scan_mask (bfd_vma memaddr, disassemble_info *info,
		unsigned int arch_mask)
d1352 5
a1357 1
  static int numopcodes[16];
a1358 4
  int major_opcode;

  struct private *priv = (struct private *) info->private_data;
  bfd_byte *buffer = priv->the_buffer;
d1386 17
d1468 1
a1468 1
	    if ((val = match_insn_m68k (memaddr, info, opc)))
a1471 46
}		

/* Print the m68k instruction at address MEMADDR in debugged memory,
   on INFO->STREAM.  Returns length of the instruction, in bytes.  */

int
print_insn_m68k (bfd_vma memaddr, disassemble_info *info)
{
  unsigned int arch_mask;
  struct private priv;
  int val;

  bfd_byte *buffer = priv.the_buffer;

  info->private_data = (PTR) &priv;
  /* Tell objdump to use two bytes per chunk
     and six bytes per line for displaying raw data.  */
  info->bytes_per_chunk = 2;
  info->bytes_per_line = 6;
  info->display_endian = BFD_ENDIAN_BIG;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = memaddr;

  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;

  arch_mask = bfd_m68k_mach_to_features (info->mach);
  if (!arch_mask)
    {
      /* First try printing an m680x0 instruction.  Try printing a Coldfire
	 one if that fails.  */
      val = m68k_scan_mask (memaddr, info, m68k_mask);
      if (val)
	return val;

      val = m68k_scan_mask (memaddr, info, mcf_mask);
      if (val)
	return val;
    }
  else
    {
      val = m68k_scan_mask (memaddr, info, arch_mask);
      if (val)
	return val;
    }
@


1.21.2.2
log
@	opcodes/
	* m68k-dis.c (m68k_scan_mask): Add missing return.
@
text
@a1455 1
  return 0;
@


1.21.6.1
log
@include/opcodes/
	* m68k.h (mcf_mask): Define.

opcodes/
	* m68k-opc.c (m68k_opcodes): Fix the masks of the Coldfire fmovemd
	and fmovem entries.  Put register list entries before immediate
	mask entries.  Use "l" rather than "L" in the fmovem entries.
	* m68k-dis.c (match_insn_m68k): Remove the PRIV argument and work it
	out from INFO.
	(m68k_scan_mask): New function, split out from...
	(print_insn_m68k): ...here.  If no architecture has been set,
	first try printing an m680x0 instruction, then try a Coldfire one.
@
text
@d1207 2
a1208 1
		 const struct m68k_opcode * best)
a1213 1
  struct private *priv = (struct private *) info->private_data;
d1344 2
a1345 2
/* Like print_m68k_insn, but restrict the opcode search to the features
   specified by ARCH_MASK.  */
d1347 2
a1348 3
static int
m68k_scan_mask (bfd_vma memaddr, disassemble_info *info,
		unsigned int arch_mask)
d1352 5
a1357 1
  static int numopcodes[16];
a1358 4
  int major_opcode;

  struct private *priv = (struct private *) info->private_data;
  bfd_byte *buffer = priv->the_buffer;
d1386 17
d1468 1
a1468 1
	    if ((val = match_insn_m68k (memaddr, info, opc)))
a1471 46
}		

/* Print the m68k instruction at address MEMADDR in debugged memory,
   on INFO->STREAM.  Returns length of the instruction, in bytes.  */

int
print_insn_m68k (bfd_vma memaddr, disassemble_info *info)
{
  unsigned int arch_mask;
  struct private priv;
  int val;

  bfd_byte *buffer = priv.the_buffer;

  info->private_data = (PTR) &priv;
  /* Tell objdump to use two bytes per chunk
     and six bytes per line for displaying raw data.  */
  info->bytes_per_chunk = 2;
  info->bytes_per_line = 6;
  info->display_endian = BFD_ENDIAN_BIG;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = memaddr;

  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;

  arch_mask = bfd_m68k_mach_to_features (info->mach);
  if (!arch_mask)
    {
      /* First try printing an m680x0 instruction.  Try printing a Coldfire
	 one if that fails.  */
      val = m68k_scan_mask (memaddr, info, m68k_mask);
      if (val)
	return val;

      val = m68k_scan_mask (memaddr, info, mcf_mask);
      if (val)
	return val;
    }
  else
    {
      val = m68k_scan_mask (memaddr, info, arch_mask);
      if (val)
	return val;
    }
@


1.21.6.2
log
@	opcodes/
	* m68k-dis.c (m68k_scan_mask): Add missing return.
@
text
@a1455 1
  return 0;
@


1.21.6.3
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d1344 2
a1345 4
/* Try to interpret the instruction at address MEMADDR as one that
   can execute on a processor with the features given by ARCH_MASK.
   If successful, print the instruction to INFO->STREAM and return
   its length in bytes.  Return 0 otherwise.  */
@


1.21.6.4
log
@	Merge fido bits:
	2006-10-25  Kazu Hirata  <kazu@@codesourcery.com>

	gprof/
	* hist.c, hist.h: Fix formatting.

	gprof/
	* Makefile.in (corefile.o): Depend on hist.h.
	* corefile.c: Include hist.h.

	2006-10-06  Vladimir Prus  <vladimir@@codesourcery.com>

	* hist.h (struct histogram)
	(histograms, num_histograms): New.
	* hist.c (find_histogram, find_histogram_for_pc)
	(read_histogram_header): New.
	(s_lowpc, s_highpc, lowpc, highpc, hist_num_bins)
	(hist_sample): Remove.
	(hist_read_rec): Use the above, and handle multiple
	histogram records with disjoint address ranges.
	(hist_write_hist): Support several histogram records.
	(scale_and_align_entries): Adjust for multiple histograms.
	(hist_assign_samples_1): New.
	(hist_assign_samples): Use the above.
	(hist_clip_symbol_address): New.
	* hist.h (hist_check_address)
	(hist_clip_symbol_address): Declare.
	* gmon_io.c (gmon_out_read, gmon_out_write): Adjust handling
	of legacy format for multiple histogram changes.
	* corefile.c (find_call): Check for core_text_space and
	clip symbol address range here.
	* vax.c	(vax_find_call): Don't check for
	core_text_space, or clip the symbol's address range here.
	Use hist_check_address to check call's target address.
	* sparc.c: Likewise.
	* tahoe.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise. Also use core_text_sect->vma as the base
	address for code accesses, just like other machine-specific
	routines do.

	2006-08-03  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (archs): Add -mfido as an alias for
	-mfido_a.

	2006-06-23  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (cpu_of_arch): Replace fido with
	fido_a.
	(archs): Likewise.
	(m68k_ip): Likewise.
	(select_control_regs): Likewise.
	(md_show_usage): Replace -mfido with -mfidoa.
	* include/opcode/m68k.h (fido): Rename to fido_a.
	* opcodes/m68k-opc.c (m68k_opcodes): Replace fido with fido_a.

	2006-06-22  Kazu Hirata  <kazu@@codesourcery.com>

	* config.sub: Replace fido with fido.
	* bfd/config.bfd: Likewise
	* gas/configure.tgt: Likewise.
	* gas/config/m68k-parse.h: Likewise.
	* gas/config/tc-m68k.c: Likewise.
	* gas/testsuite/gas/m68k/all.exp: Likewise.
	* gas/testsuite/gas/m68k/fido.d: Rename to fido.d.
	* gas/testsuite/gas/m68k/fido.s: Rename to fido.s.
	* include/opcode/m68k.h: Replace fido with fido.
	* ld/configure.tgt: Likewise.
	* opcodes/m68k-dis.c: Likewise.
	* opcodes/m68k-opc.c: Likewise.

	2005-08-01  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/m68k-parse.h (m68k_register): Add CAC and MBB.
	* gas/config/tc-m68k.c (fido_control_regs): New.
	(cpu_of_arch): Add fido.
	(archs): Add an entry for fido.
	(m68k_ip): Add warnings for uses of tbl[su]{n,}[bwl] on
	fido.  Recognize CAC and MBB.
	(init_tabl): Add CAC and MBB.
	(select_control_regs): Choose fido as the current chip
	when the current architecture is fido or when -mfido
	is given explicitly.
	* gas/testsuite/gas/m68k/all.exp: Disable operands, cas, and
	bitfield on fido-*-*.  Run fido on fido-*-*.
	* gas/testsuite/gas/m68k/fido.d: New.
	* gas/testsuite/gas/m68k/fido.s: Likewise.
	* include/opcode/m68k.h: Document new control registers CAC
	and MBB.
	* opcodes/m68k-dis.c (print_insn_arg): Add cac and mbb.
	* opcodes/m68k-opc.c (m68k_opcodes): Add sleep and trapx.

	2005-07-22  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (archs): Add fido as an OR of
	cpu32 and fido.
	(md_show_usage): Add -mfido.
	* include/opcode/m68k.h (fido): New.

	2005-07-11  Kazu Hirata  <kazu@@codesourcery.com>

	* config.sub: Recognize fido and fido-*.
	* bfd/config.bfd: Likewise.
	* gas/configure.tgt: Likewise.
	* ld/configure.tgt: Likewise.
@
text
@d653 1
a653 4
             {"%urp", 0x806}, {"%srp", 0x807}, {"%pcr", 0x808},

	     /* Fido added these.  */
             {"%cac", 0xffe}, {"%mbb", 0xfff}};
@


1.20
log
@	* m68k-dis.c (print_insn_m68k): Only match FPU insns with
	coprocessor ID 1.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d1399 3
a1401 52
  switch (info->mach)
    {
    default:
    case 0:
      arch_mask = (unsigned int) -1;
      break;
    case bfd_mach_m68000:
      arch_mask = m68000|m68881|m68851;
      break;
    case bfd_mach_m68008:
      arch_mask = m68008|m68881|m68851;
      break;
    case bfd_mach_m68010:
      arch_mask = m68010|m68881|m68851;
      break;
    case bfd_mach_m68020:
      arch_mask = m68020|m68881|m68851;
      break;
    case bfd_mach_m68030:
      arch_mask = m68030|m68881|m68851;
      break;
    case bfd_mach_m68040:
      arch_mask = m68040|m68881|m68851;
      break;
    case bfd_mach_m68060:
      arch_mask = m68060|m68881|m68851;
      break;
    case bfd_mach_mcf5200:
      arch_mask = mcfisa_a;
      break;
    case bfd_mach_mcf521x:
    case bfd_mach_mcf528x:
      arch_mask = mcfisa_a|mcfhwdiv|mcfisa_aa|mcfusp|mcfemac;
      break;
    case bfd_mach_mcf5206e:
      arch_mask = mcfisa_a|mcfhwdiv|mcfmac;
      break;
    case bfd_mach_mcf5249:
      arch_mask = mcfisa_a|mcfhwdiv|mcfemac;
      break;
    case bfd_mach_mcf5307:
      arch_mask = mcfisa_a|mcfhwdiv|mcfmac;
      break;
    case bfd_mach_mcf5407:
      arch_mask = mcfisa_a|mcfhwdiv|mcfisa_b|mcfmac;
      break;
    case bfd_mach_mcf547x:
    case bfd_mach_mcf548x:
    case bfd_mach_mcfv4e:
      arch_mask = mcfisa_a|mcfhwdiv|mcfisa_b|mcfusp|cfloat|mcfemac;
      break;
    }
@


1.19
log
@Update function declarations to ISO C90 formatting
@
text
@d1502 14
@


1.18
log
@	* m68k-dis.c: Use ISC C90.
	* m68k-opc.c: Formatting fixes.
@
text
@d18 2
a19 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d29 1
a29 10
/* Local function prototypes */

static int fetch_data (struct disassemble_info *, bfd_byte *);
static void dummy_print_address (bfd_vma, struct disassemble_info *);
static int fetch_arg (unsigned char *, int, int, disassemble_info *);
static void print_base (int, bfd_vma, disassemble_info *);
static unsigned char * print_indexed (int, unsigned char *, bfd_vma, disassemble_info *);
static int print_insn_arg (const char *, unsigned char *, unsigned char *,
			   bfd_vma, disassemble_info *);
static bfd_boolean m68k_valid_ea (char code, int val);
d33 2
a34 2
    "", "%fpiar", "%fpsr", "%fpiar/%fpsr", "%fpcr",
    "%fpiar/%fpcr", "%fpsr/%fpcr", "%fpiar/%fpsr/%fpcr"
d39 3
a41 3
    "%d0", "%d1", "%d2", "%d3", "%d4", "%d5", "%d6", "%d7",
    "%a0", "%a1", "%a2", "%a3", "%a4", "%a5", "%fp", "%sp",
    "%ps", "%pc"
d48 3
a50 3
    "%d0", "%d1", "%d2", "%d3", "%d4", "%d5", "%d6", "%d7",
    "%a0", "%a1", "%a2", "%a3", "%a4", "%a5", "%a6", "%a7",
    "%ps", "%pc"
d107 2
a108 1
struct private {
d144 1
a144 1
/* This function is used to print to the bit-bucket. */
a145 1
#ifdef __STDC__
d147 2
a148 4
	       const char *format ATTRIBUTE_UNUSED, ...)
#else
dummy_printer (FILE *file ATTRIBUTE_UNUSED)
#endif
d154 2
a155 3
dummy_print_address (vma, info)
     bfd_vma vma ATTRIBUTE_UNUSED;
     struct disassemble_info *info ATTRIBUTE_UNUSED;
d159 4
a162 2
/* Try to match the current instruction to best and if so, return the
   number of bytes consumed from the instruction stream, else zero.  */
d165 4
a168 2
match_insn_m68k (bfd_vma memaddr, disassemble_info * info,
		 const struct m68k_opcode * best, struct private * priv)
d170 1
a170 3
  unsigned char *save_p;
  unsigned char *p;
  const char *d;
d172 5
a176 4
  bfd_byte *buffer = priv->the_buffer;
  fprintf_ftype save_printer = info->fprintf_func;
  void (* save_print_address) (bfd_vma, struct disassemble_info *)
    = info->print_address_func;
d178 3
a180 3
  /* Point at first word of argument data,
     and at descriptor for first argument.  */
  p = buffer + 2;
d182 3
a184 15
  /* Figure out how long the fixed-size portion of the instruction is.
     The only place this is stored in the opcode table is
     in the arguments--look for arguments which specify fields in the 2nd
     or 3rd words of the instruction.  */
  for (d = best->args; *d; d += 2)
    {
      /* I don't think it is necessary to be checking d[0] here;
	 I suspect all this could be moved to the case statement below.  */
      if (d[0] == '#')
	{
	  if (d[1] == 'l' && p - buffer < 6)
	    p = buffer + 6;
	  else if (p - buffer < 4 && d[1] != 'C' && d[1] != '8')
	    p = buffer + 4;
	}
d186 3
a188 2
      if ((d[0] == 'L' || d[0] == 'l') && d[1] == 'w' && p - buffer < 4)
	p = buffer + 4;
d190 3
a192 22
      switch (d[1])
	{
	case '1':
	case '2':
	case '3':
	case '7':
	case '8':
	case '9':
	case 'i':
	  if (p - buffer < 4)
	    p = buffer + 4;
	  break;
	case '4':
	case '5':
	case '6':
	  if (p - buffer < 6)
	    p = buffer + 6;
	  break;
	default:
	  break;
	}
    }
d194 3
a196 4
  /* pflusha is an exceptions.  It takes no arguments but is two words
     long.  Recognize it by looking at the lower 16 bits of the mask.  */
  if (p - buffer < 4 && (best->match & 0xFFFF) != 0)
    p = buffer + 4;
d198 3
a200 16
  /* lpstop is another exception.  It takes a one word argument but is
     three words long.  */
  if (p - buffer < 6
      && (best->match & 0xffff) == 0xffff
      && best->args[0] == '#'
      && best->args[1] == 'w')
    {
      /* Copy the one word argument into the usual location for a one
	 word argument, to simplify printing it.  We can get away with
	 this because we know exactly what the second word is, and we
	 aren't going to print anything based on it.  */
      p = buffer + 6;
      FETCH_DATA (info, p);
      buffer[2] = buffer[4];
      buffer[3] = buffer[5];
    }
d202 3
a204 1
  FETCH_DATA (info, p);
d206 4
a209 1
  d = best->args;
d211 4
a214 3
  save_p = p;
  info->print_address_func = dummy_print_address;
  info->fprintf_func = (fprintf_ftype) dummy_printer;
d216 4
a219 5
  /* We scan the operands twice.  The first time we don't print anything,
     but look for errors. */
  for (; *d; d += 2)
    {
      int eaten = print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);
d221 4
a224 19
      if (eaten >= 0)
	p += eaten;
      else if (eaten == -1)
	{
	  info->fprintf_func = save_printer;
	  info->print_address_func = save_print_address;
	  return 0;
	}
      else
	{
	  info->fprintf_func (info->stream,
			      /* xgettext:c-format */
			      _("<internal error in opcode table: %s %s>\n"),
			      best->name,  best->args);
	  info->fprintf_func = save_printer;
	  info->print_address_func = save_print_address;
	  return 2;
	}
    }
d226 5
a230 3
  p = save_p;
  info->fprintf_func = save_printer;
  info->print_address_func = save_print_address;
d232 5
a236 1
  d = best->args;
d238 5
a242 1
  info->fprintf_func (info->stream, "%s", best->name);
d244 5
a248 2
  if (*d)
    info->fprintf_func (info->stream, " ");
d250 5
a254 4
  while (*d)
    {
      p += print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);
      d += 2;
d256 4
a259 3
      if (*d && *(d - 2) != 'I' && *d != 'k')
	info->fprintf_func (info->stream, ",");
    }
d261 5
a265 2
  return p - buffer;
}
d267 5
a271 2
/* Print the m68k instruction at address MEMADDR in debugged memory,
   on INFO->STREAM.  Returns length of the instruction, in bytes.  */
d273 5
a277 12
int
print_insn_m68k (bfd_vma memaddr, disassemble_info *info)
{
  int i;
  const char *d;
  unsigned int arch_mask;
  struct private priv;
  bfd_byte *buffer = priv.the_buffer;
  int major_opcode;
  static int numopcodes[16];
  static const struct m68k_opcode **opcodes[16];
  int val;
d279 3
a281 5
  if (!opcodes[0])
    {
      /* Speed up the matching by sorting the opcode
	 table on the upper four bits of the opcode.  */
      const struct m68k_opcode **opc_pointer[16];
d283 5
a287 3
      /* First count how many opcodes are in each of the sixteen buckets.  */
      for (i = 0; i < m68k_numopcodes; i++)
	numopcodes[(m68k_opcodes[i].opcode >> 28) & 15]++;
d289 3
a291 5
      /* Then create a sorted table of pointers
	 that point into the unsorted table.  */
      opc_pointer[0] = xmalloc (sizeof (struct m68k_opcode *)
				* m68k_numopcodes);
      opcodes[0] = opc_pointer[0];
d293 3
a295 5
      for (i = 1; i < 16; i++)
	{
	  opc_pointer[i] = opc_pointer[i - 1] + numopcodes[i - 1];
	  opcodes[i] = opc_pointer[i];
	}
d297 38
a334 2
      for (i = 0; i < m68k_numopcodes; i++)
	*opc_pointer[(m68k_opcodes[i].opcode >> 28) & 15]++ = &m68k_opcodes[i];
d336 1
d338 6
a343 8
  info->private_data = (PTR) &priv;
  /* Tell objdump to use two bytes per chunk
     and six bytes per line for displaying raw data.  */
  info->bytes_per_chunk = 2;
  info->bytes_per_line = 6;
  info->display_endian = BFD_ENDIAN_BIG;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = memaddr;
d345 7
a351 3
  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;
d353 1
a353 1
  switch (info->mach)
d355 29
a383 3
    default:
    case 0:
      arch_mask = (unsigned int) -1;
d385 2
a386 2
    case bfd_mach_m68000:
      arch_mask = m68000|m68881|m68851;
d388 2
a389 2
    case bfd_mach_m68008:
      arch_mask = m68008|m68881|m68851;
d391 2
a392 2
    case bfd_mach_m68010:
      arch_mask = m68010|m68881|m68851;
d394 2
a395 2
    case bfd_mach_m68020:
      arch_mask = m68020|m68881|m68851;
d397 2
a398 2
    case bfd_mach_m68030:
      arch_mask = m68030|m68881|m68851;
d400 2
a401 2
    case bfd_mach_m68040:
      arch_mask = m68040|m68881|m68851;
d403 2
a404 2
    case bfd_mach_m68060:
      arch_mask = m68060|m68881|m68851;
d406 2
a407 2
    case bfd_mach_mcf5200:
      arch_mask = mcfisa_a;
d409 2
a410 3
    case bfd_mach_mcf521x:
    case bfd_mach_mcf528x:
      arch_mask = mcfisa_a|mcfhwdiv|mcfisa_aa|mcfusp|mcfemac;
d412 2
a413 2
    case bfd_mach_mcf5206e:
      arch_mask = mcfisa_a|mcfhwdiv|mcfmac;
d415 2
a416 2
    case bfd_mach_mcf5249:
      arch_mask = mcfisa_a|mcfhwdiv|mcfemac;
d418 2
a419 2
    case bfd_mach_mcf5307:
      arch_mask = mcfisa_a|mcfhwdiv|mcfmac;
d421 2
a422 2
    case bfd_mach_mcf5407:
      arch_mask = mcfisa_a|mcfhwdiv|mcfisa_b|mcfmac;
d424 2
a425 4
    case bfd_mach_mcf547x:
    case bfd_mach_mcf548x:
    case bfd_mach_mcfv4e:
      arch_mask = mcfisa_a|mcfhwdiv|mcfisa_b|mcfusp|cfloat|mcfemac;
d427 2
d430 7
d438 2
a439 2
  FETCH_DATA (info, buffer + 2);
  major_opcode = (buffer[0] >> 4) & 15;
d441 9
a449 1
  for (i = 0; i < numopcodes[major_opcode]; i++)
d451 1
a451 3
      const struct m68k_opcode *opc = opcodes[major_opcode][i];
      unsigned long opcode = opc->opcode;
      unsigned long match = opc->match;
d453 6
a458 17
      if (((0xff & buffer[0] & (match >> 24)) == (0xff & (opcode >> 24)))
	  && ((0xff & buffer[1] & (match >> 16)) == (0xff & (opcode >> 16)))
	  /* Only fetch the next two bytes if we need to.  */
	  && (((0xffff & match) == 0)
	      ||
	      (FETCH_DATA (info, buffer + 4)
	       && ((0xff & buffer[2] & (match >> 8)) == (0xff & (opcode >> 8)))
	       && ((0xff & buffer[3] & match) == (0xff & opcode)))
	      )
	  && (opc->arch & arch_mask) != 0)
	{
	  /* Don't use for printout the variants of divul and divsl
	     that have the same register number in two places.
	     The more general variants will match instead.  */
	  for (d = opc->args; *d; d += 2)
	    if (d[1] == 'D')
	      break;
d460 2
a461 27
	  /* Don't use for printout the variants of most floating
	     point coprocessor instructions which use the same
	     register number in two places, as above.  */
	  if (*d == '\0')
	    for (d = opc->args; *d; d += 2)
	      if (d[1] == 't')
		break;

	  /* Don't match fmovel with more than one register;
	     wait for fmoveml.  */
	  if (*d == '\0')
	    {
	      for (d = opc->args; *d; d += 2)
		{
		  if (d[0] == 's' && d[1] == '8')
		    {
		      val = fetch_arg (buffer, d[1], 3, info);
		      if ((val & (val - 1)) != 0)
			break;
		    }
		}
	    }

	  if (*d == '\0')
	    if ((val = match_insn_m68k (memaddr, info, opc, & priv)))
	      return val;
	}
d463 1
d465 3
a467 4
  /* Handle undefined instructions.  */
  info->fprintf_func (info->stream, "0%o", (buffer[0] << 8) + buffer[1]);
  return 2;
}
d469 12
a480 3
/* Returns number of bytes "eaten" by the operand, or
   return -1 if an invalid operand was found, or -2 if
   an opcode tabe error was found.  */
d482 86
a567 1
/* ADDR is the pc for this arg to be relative to.  */
d570 4
a573 2
print_insn_arg (const char *d, unsigned char *buffer,
		unsigned char *p0, bfd_vma addr,
d763 1
a763 1
	  if (val > 63)		/* This is a signed constant. */
d812 1
a812 1
	  if (buffer[1] & 0x40)		/* If bit six is one, long offset */
d844 1
a844 1
      
d859 1
a859 1
      if (val != 1)				/* Unusual coprocessor ID? */
d1034 2
a1035 1
		register int newval = 0;
d1047 1
d1072 2
a1073 1
		register int newval = 0;
d1098 1
a1098 1
	    /* fmoveml for FP status registers */
d1119 1
d1138 1
d1155 1
d1173 1
d1201 2
a1202 6
/* Check if an EA is valid for a particular code.  This is required
   for the EMAC instructions since the type of source address determines
   if it is a EMAC-load instruciton if the EA is mode 2-5, otherwise it
   is a non-load EMAC instruction and the bits mean register Ry.
   A similar case exists for the movem instructions where the register
   mask is interpreted differently for different EAs.  */
d1204 5
a1208 2
static bfd_boolean
m68k_valid_ea (char code, int val)
d1210 12
a1221 4
  int mode, mask;
#define M(n0,n1,n2,n3,n4,n5,n6,n70,n71,n72,n73,n74) \
  (n0 | n1 << 1 | n2 << 2 | n3 << 3 | n4 << 4 | n5 << 5 | n6 << 6 \
   | n70 << 7 | n71 << 8 | n72 << 9 | n73 << 10 | n74 << 11)
d1223 5
a1227 1
  switch (code)
d1229 9
a1237 76
    case '*':
      mask = M (1,1,1,1,1,1,1,1,1,1,1,1);
      break;
    case '~':
      mask = M (0,0,1,1,1,1,1,1,1,0,0,0);
      break;
    case '%':
      mask = M (1,1,1,1,1,1,1,1,1,0,0,0);
      break;
    case ';':
      mask = M (1,0,1,1,1,1,1,1,1,1,1,1);
      break;
    case '@@':
      mask = M (1,0,1,1,1,1,1,1,1,1,1,0);
      break;
    case '!':
      mask = M (0,0,1,0,0,1,1,1,1,1,1,0);
      break;
    case '&':
      mask = M (0,0,1,0,0,1,1,1,1,0,0,0);
      break;
    case '$':
      mask = M (1,0,1,1,1,1,1,1,1,0,0,0);
      break;
    case '?':
      mask = M (1,0,1,0,0,1,1,1,1,0,0,0);
      break;
    case '/':
      mask = M (1,0,1,0,0,1,1,1,1,1,1,0);
      break;
    case '|':
      mask = M (0,0,1,0,0,1,1,1,1,1,1,0);
      break;
    case '>':
      mask = M (0,0,1,0,1,1,1,1,1,0,0,0);
      break;
    case '<':
      mask = M (0,0,1,1,0,1,1,1,1,1,1,0);
      break;
    case 'm':
      mask = M (1,1,1,1,1,0,0,0,0,0,0,0);
      break;
    case 'n':
      mask = M (0,0,0,0,0,1,0,0,0,1,0,0);
      break;
    case 'o':
      mask = M (0,0,0,0,0,0,1,1,1,0,1,1);
      break;
    case 'p':
      mask = M (1,1,1,1,1,1,0,0,0,0,0,0);
      break;
    case 'q':
      mask = M (1,0,1,1,1,1,0,0,0,0,0,0);
      break;
    case 'v':
      mask = M (1,0,1,1,1,1,0,1,1,0,0,0);
      break;
    case 'b':
      mask = M (1,0,1,1,1,1,0,0,0,1,0,0);
      break;
    case 'w':
      mask = M (0,0,1,1,1,1,0,0,0,1,0,0);
      break;
    case 'y':
      mask = M (0,0,1,0,0,1,0,0,0,0,0,0);
      break;
    case 'z':
      mask = M (0,0,1,0,0,1,0,0,0,1,0,0);
      break;
    case '4':
      mask = M (0,0,1,1,1,1,0,0,0,0,0,0);
      break;
    default:
      abort ();
    }
#undef M
d1239 2
a1240 5
  mode = (val >> 3) & 7;
  if (mode == 7)
    mode += val & 7;
  return (mask & (1 << mode)) != 0;
}
d1242 22
a1263 4
/* Fetch BITS bits from a position in the instruction specified by CODE.
   CODE is a "place to put an argument", or 'x' for a destination
   that is a general address (mode and register).
   BUFFER contains the instruction.  */
d1265 4
a1268 5
static int
fetch_arg (unsigned char *buffer, int code, int bits,
	   disassemble_info *info)
{
  int val = 0;
d1270 6
a1275 1
  switch (code)
d1277 51
a1327 3
    case '/': /* MAC/EMAC mask bit.  */
      val = buffer[3] >> 5;
      break;
d1329 2
a1330 3
    case 'G': /* EMAC ACC load.  */
      val = ((buffer[3] >> 3) & 0x2) | ((~buffer[1] >> 7) & 0x1);
      break;
d1332 4
a1335 3
    case 'H': /* EMAC ACC !load.  */
      val = ((buffer[3] >> 3) & 0x2) | ((buffer[1] >> 7) & 0x1);
      break;
d1337 3
a1339 3
    case ']': /* EMAC ACCEXT bit.  */
      val = buffer[0] >> 2;
      break;
d1341 2
a1342 3
    case 'I': /* MAC/EMAC scale factor.  */
      val = buffer[2] >> 1;
      break;
d1344 2
a1345 3
    case 'F': /* EMAC ACCx.  */
      val = buffer[0] >> 1;
      break;
d1347 12
a1358 3
    case 'f':
      val = buffer[1];
      break;
d1360 5
a1364 3
    case 's':
      val = buffer[1];
      break;
d1366 3
a1368 4
    case 'd':			/* Destination, for register or quick.  */
      val = (buffer[0] << 8) + buffer[1];
      val >>= 9;
      break;
d1370 5
a1374 4
    case 'x':			/* Destination, for general arg */
      val = (buffer[0] << 8) + buffer[1];
      val >>= 6;
      break;
d1376 5
a1380 4
    case 'k':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[3] >> 4);
      break;
d1382 3
a1384 4
    case 'C':
      FETCH_DATA (info, buffer + 3);
      val = buffer[3];
      break;
d1386 8
a1393 5
    case '1':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      val >>= 12;
      break;
d1395 3
a1397 5
    case '2':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      val >>= 6;
      break;
d1399 5
a1403 4
    case '3':
    case 'j':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
d1405 2
a1406 5

    case '4':
      FETCH_DATA (info, buffer + 5);
      val = (buffer[4] << 8) + buffer[5];
      val >>= 12;
d1408 2
a1409 5

    case '5':
      FETCH_DATA (info, buffer + 5);
      val = (buffer[4] << 8) + buffer[5];
      val >>= 6;
d1411 2
a1412 4

    case '6':
      FETCH_DATA (info, buffer + 5);
      val = (buffer[4] << 8) + buffer[5];
d1414 2
a1415 5

    case '7':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      val >>= 7;
d1417 2
a1418 5

    case '8':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      val >>= 10;
d1420 2
a1421 5

    case '9':
      FETCH_DATA (info, buffer + 3);
      val = (buffer[2] << 8) + buffer[3];
      val >>= 5;
d1423 2
a1424 3

    case 'e':
      val = (buffer[1] >> 6);
d1426 2
a1427 5

    case 'm':
      val = (buffer[1] & 0x40 ? 0x8 : 0)
	| ((buffer[0] >> 1) & 0x7)
	| (buffer[3] & 0x80 ? 0x10 : 0);
d1429 3
a1431 3

    case 'n':
      val = (buffer[1] & 0x40 ? 0x8 : 0) | ((buffer[0] >> 1) & 0x7);
d1433 2
a1434 3

    case 'o':
      val = (buffer[2] >> 4) | (buffer[3] & 0x80 ? 0x10 : 0);
d1436 2
a1437 3

    case 'M':
      val = (buffer[1] & 0xf) | (buffer[3] & 0x40 ? 0x10 : 0);
d1439 2
a1440 3

    case 'N':
      val = (buffer[3] & 0xf) | (buffer[3] & 0x40 ? 0x10 : 0);
d1442 2
a1443 3

    case 'h':
      val = buffer[2] >> 2;
d1445 4
a1448 85

    default:
      abort ();
    }

  switch (bits)
    {
    case 1:
      return val & 1;
    case 2:
      return val & 3;
    case 3:
      return val & 7;
    case 4:
      return val & 017;
    case 5:
      return val & 037;
    case 6:
      return val & 077;
    case 7:
      return val & 0177;
    case 8:
      return val & 0377;
    case 12:
      return val & 07777;
    default:
      abort ();
    }
}

/* Print an indexed argument.  The base register is BASEREG (-1 for pc).
   P points to extension word, in buffer.
   ADDR is the nominal core address of that extension word.  */

static unsigned char *
print_indexed (int basereg, unsigned char *p,
	       bfd_vma addr, disassemble_info *info)
{
  int word;
  static char *const scales[] = { "", ":2", ":4", ":8" };
  bfd_vma base_disp;
  bfd_vma outer_disp;
  char buf[40];
  char vmabuf[50];

  word = NEXTWORD (p);

  /* Generate the text for the index register.
     Where this will be output is not yet determined.  */
  sprintf (buf, "%s:%c%s",
	   reg_names[(word >> 12) & 0xf],
	   (word & 0x800) ? 'l' : 'w',
	   scales[(word >> 9) & 3]);

  /* Handle the 68000 style of indexing.  */

  if ((word & 0x100) == 0)
    {
      base_disp = word & 0xff;
      if ((base_disp & 0x80) != 0)
	base_disp -= 0x100;
      if (basereg == -1)
	base_disp += addr;
      print_base (basereg, base_disp, info);
      (*info->fprintf_func) (info->stream, ",%s)", buf);
      return p;
    }

  /* Handle the generalized kind.  */
  /* First, compute the displacement to add to the base register.  */

  if (word & 0200)
    {
      if (basereg == -1)
	basereg = -3;
      else
	basereg = -2;
    }
  if (word & 0100)
    buf[0] = '\0';
  base_disp = 0;
  switch ((word >> 4) & 3)
    {
    case 2:
      base_disp = NEXTWORD (p);
a1449 2
    case 3:
      base_disp = NEXTLONG (p);
a1450 2
  if (basereg == -1)
    base_disp += addr;
d1452 2
a1453 1
  /* Handle single-level case (not indirect) */
d1455 1
a1455 1
  if ((word & 7) == 0)
d1457 3
a1459 6
      print_base (basereg, base_disp, info);
      if (buf[0] != '\0')
	(*info->fprintf_func) (info->stream, ",%s", buf);
      (*info->fprintf_func) (info->stream, ")");
      return p;
    }
d1461 17
a1477 1
  /* Two level.  Compute displacement to add after indirection.  */
d1479 7
a1485 9
  outer_disp = 0;
  switch (word & 3)
    {
    case 2:
      outer_disp = NEXTWORD (p);
      break;
    case 3:
      outer_disp = NEXTLONG (p);
    }
d1487 14
a1500 11
  print_base (basereg, base_disp, info);
  if ((word & 4) == 0 && buf[0] != '\0')
    {
      (*info->fprintf_func) (info->stream, ",%s", buf);
      buf[0] = '\0';
    }
  sprintf_vma (vmabuf, outer_disp);
  (*info->fprintf_func) (info->stream, ")@@(%s", vmabuf);
  if (buf[0] != '\0')
    (*info->fprintf_func) (info->stream, ",%s", buf);
  (*info->fprintf_func) (info->stream, ")");
d1502 4
a1505 13
  return p;
}

/* Print a base register REGNO and displacement DISP, on INFO->STREAM.
   REGNO = -1 for pc, -2 for none (suppressed).  */

static void
print_base (int regno, bfd_vma disp, disassemble_info *info)
{
  if (regno == -1)
    {
      (*info->fprintf_func) (info->stream, "%%pc@@(");
      (*info->print_address_func) (disp, info);
a1506 3
  else
    {
      char buf[50];
d1508 3
a1510 10
      if (regno == -2)
	(*info->fprintf_func) (info->stream, "@@(");
      else if (regno == -3)
	(*info->fprintf_func) (info->stream, "%%zpc@@(");
      else
	(*info->fprintf_func) (info->stream, "%s@@(", reg_names[regno]);

      sprintf_vma (buf, disp);
      (*info->fprintf_func) (info->stream, "%s", buf);
    }
@


1.17
log
@Update the address and phone number of the FSF
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004
d30 7
a36 19
static int
fetch_data PARAMS ((struct disassemble_info *, bfd_byte *));

static void
dummy_print_address PARAMS ((bfd_vma, struct disassemble_info *));

static int
fetch_arg PARAMS ((unsigned char *, int, int, disassemble_info *));

static void
print_base PARAMS ((int, bfd_vma, disassemble_info *));

static unsigned char *
print_indexed PARAMS ((int, unsigned char *, bfd_vma, disassemble_info *));

static int
print_insn_arg PARAMS ((const char *, unsigned char *, unsigned char *,
			bfd_vma, disassemble_info *));

d131 1
a131 3
fetch_data (info, addr)
     struct disassemble_info *info;
     bfd_byte *addr;
d157 1
a157 2
dummy_printer (file)
     FILE *file ATTRIBUTE_UNUSED;
d315 1
a315 3
print_insn_m68k (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d484 2
d487 3
a489 6
print_insn_arg (d, buffer, p0, addr, info)
     const char *d;
     unsigned char *buffer;
     unsigned char *p0;
     bfd_vma addr;		/* PC for this arg to be relative to.  */
     disassemble_info *info;
d1215 2
a1216 5
fetch_arg (buffer, code, bits, info)
     unsigned char *buffer;
     int code;
     int bits;
     disassemble_info *info;
d1391 2
a1392 5
print_indexed (basereg, p, addr, info)
     int basereg;
     unsigned char *p;
     bfd_vma addr;
     disassemble_info *info;
d1490 1
a1490 4
print_base (regno, disp, info)
     int regno;
     bfd_vma disp;
     disassemble_info *info;
@


1.16
log
@* m68k-dis.c (m68k_valid_ea): Fix typos in last change.
@
text
@d18 1
a18 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.15
log
@binutils/testsuite/:
	* binutils-all/m68k/movem.s: New file.

	* binutils-all/m68k/objdump.exp: New file.

include/opcode/:
	* m68k.h: Fix comment.

opcodes/:
	* m68k-dis.c (m68k_valid_ea): Check validity of all codes.
@
text
@d1169 1
a1169 1
      mask = M (0,1,0,0,1,1,1,1,1,0,0,0);
d1178 1
a1178 1
      mask = M (0,0,1,0,1,1,1,1,1,1,1,0);
d1181 1
a1181 1
      mask = M (0,0,1,1,0,1,1,1,1,0,0,0);
@


1.15.2.1
log
@	* m68k-dis.c (m68k_valid_ea): Fix typos in last change.
@
text
@d1169 1
a1169 1
      mask = M (1,0,1,0,0,1,1,1,1,0,0,0);
d1178 1
a1178 1
      mask = M (0,0,1,0,1,1,1,1,1,0,0,0);
d1181 1
a1181 1
      mask = M (0,0,1,1,0,1,1,1,1,1,1,0);
@


1.14
log
@Reorganise m68k instruction decoding and improve handling of MAC/EMAC
@
text
@d829 1
a829 1
      if (m68k_valid_ea (*d, val) == FALSE)
d1130 3
a1132 1
   is a non-load EMAC instruction and the bits mean register Ry.  */
d1137 83
a1219 1
  int mode;
d1222 3
a1224 5
  if (code == '4')
    if (!(mode >= 2 && mode <= 5))
	return FALSE;

  return TRUE;
@


1.13
log
@Add support for 521x,5249,547x,548x.
@
text
@d49 4
a52 1
const char * const fpcr_names[] = {
d57 2
a58 1
static char *const reg_names[] = {
d64 10
a73 1
/* Sign-extend an (unsigned char). */
d185 141
d334 2
a335 6
  register int i;
  register unsigned char *p;
  unsigned char *save_p;
  register const char *d;
  register unsigned long bestmask;
  const struct m68k_opcode *best;
a338 3
  fprintf_ftype save_printer = info->fprintf_func;
  void (*save_print_address) PARAMS ((bfd_vma, struct disassemble_info *))
    = info->print_address_func;
d342 1
d346 2
a347 2
      /* Speed up the matching by sorting the opcode table on the upper
	 four bits of the opcode.  */
d354 4
a357 5
      /* Then create a sorted table of pointers that point into the
	 unsorted table.  */
      opc_pointer[0] = ((const struct m68k_opcode **)
			xmalloc (sizeof (struct m68k_opcode *)
				 * m68k_numopcodes));
d359 1
a367 1

d371 2
a372 2
  /* Tell objdump to use two bytes per chunk and six bytes per line for
     displaying raw data.  */
d378 1
a382 1
  best = NULL;
a435 1
  bestmask = 0;
d438 1
d465 1
a465 1
	     register number in two places, as above. */
d471 2
a472 2
	  /* Don't match fmovel with more than one register; wait for
             fmoveml.  */
a478 2
		      int val;

d486 3
a488 52
	  if (*d == '\0' && match > bestmask)
	    {
	      best = opc;
	      bestmask = match;
	    }
	}
    }

  if (best == NULL)
    goto invalid;

  /* Point at first word of argument data,
     and at descriptor for first argument.  */
  p = buffer + 2;

  /* Figure out how long the fixed-size portion of the instruction is.
     The only place this is stored in the opcode table is
     in the arguments--look for arguments which specify fields in the 2nd
     or 3rd words of the instruction.  */
  for (d = best->args; *d; d += 2)
    {
      /* I don't think it is necessary to be checking d[0] here; I suspect
	 all this could be moved to the case statement below.  */
      if (d[0] == '#')
	{
	  if (d[1] == 'l' && p - buffer < 6)
	    p = buffer + 6;
	  else if (p - buffer < 4 && d[1] != 'C' && d[1] != '8')
	    p = buffer + 4;
	}
      if ((d[0] == 'L' || d[0] == 'l') && d[1] == 'w' && p - buffer < 4)
	p = buffer + 4;
      switch (d[1])
	{
	case '1':
	case '2':
	case '3':
	case '7':
	case '8':
	case '9':
	case 'i':
	  if (p - buffer < 4)
	    p = buffer + 4;
	  break;
	case '4':
	case '5':
	case '6':
	  if (p - buffer < 6)
	    p = buffer + 6;
	  break;
	default:
	  break;
a491 71
  /* pflusha is an exceptions.  It takes no arguments but is two words
     long.  Recognize it by looking at the lower 16 bits of the mask.  */
  if (p - buffer < 4 && (best->match & 0xFFFF) != 0)
    p = buffer + 4;

  /* lpstop is another exception.  It takes a one word argument but is
     three words long.  */
  if (p - buffer < 6
      && (best->match & 0xffff) == 0xffff
      && best->args[0] == '#'
      && best->args[1] == 'w')
    {
      /* Copy the one word argument into the usual location for a one
	 word argument, to simplify printing it.  We can get away with
	 this because we know exactly what the second word is, and we
	 aren't going to print anything based on it.  */
      p = buffer + 6;
      FETCH_DATA (info, p);
      buffer[2] = buffer[4];
      buffer[3] = buffer[5];
    }

  FETCH_DATA (info, p);

  d = best->args;

  /* We scan the operands twice.  The first time we don't print anything,
     but look for errors. */

  save_p = p;
  info->print_address_func = dummy_print_address;
  info->fprintf_func = (fprintf_ftype) dummy_printer;
  for (; *d; d += 2)
    {
      int eaten = print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);
      if (eaten >= 0)
	p += eaten;
      else if (eaten == -1)
	goto invalid;
      else
	{
	  (*info->fprintf_func) (info->stream,
				 /* xgettext:c-format */
				 _("<internal error in opcode table: %s %s>\n"),
				 best->name,
				 best->args);
	  goto invalid;
	}

    }
  p = save_p;
  info->fprintf_func = save_printer;
  info->print_address_func = save_print_address;

  d = best->args;

  (*info->fprintf_func) (info->stream, "%s", best->name);

  if (*d)
    (*info->fprintf_func) (info->stream, " ");

  while (*d)
    {
      p += print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);
      d += 2;
      if (*d && *(d - 2) != 'I' && *d != 'k')
	(*info->fprintf_func) (info->stream, ",");
    }
  return p - buffer;

 invalid:
d493 1
a493 4
  info->fprintf_func = save_printer;
  info->print_address_func = save_print_address;
  (*info->fprintf_func) (info->stream, "0%o",
			 (buffer[0] << 8) + buffer[1]);
d499 1
a499 1
   an opcode tabe error was found. */
d506 1
a506 1
     bfd_vma addr;		/* PC for this arg to be relative to */
d509 3
a511 3
  register int val = 0;
  register int place = d[1];
  register unsigned char *p = p0;
d513 2
a514 2
  register const char *regname;
  register unsigned char *p1;
d522 1
a522 1
    case 'c':		/* cache identifier */
d530 1
a530 1
    case 'a':		/* address register indirect only. Cf. case '+'. */
d539 1
a539 1
    case '_':		/* 32-bit absolute address for move16. */
d774 1
a774 1
      val = fetch_arg(buffer, place, 2, info);
d784 2
d828 4
d946 1
a946 1
		(*info->fprintf_func) (info->stream, "&");
d1115 1
a1115 1
			       reg_names[reg],
d1127 18
d1157 2
a1158 1
  register int val = 0;
d1166 1
a1166 1
      val = ((buffer[3] >> 3) & 0x2) | ((~buffer[2] >> 7) & 0x1);
d1170 1
a1170 1
      val = ((buffer[3] >> 3) & 0x2) | ((buffer[2] >> 7) & 0x1);
d1178 1
a1178 1
      val = buffer[0] >> 1;
d1186 1
a1186 1
      val = buffer[0];
d1285 1
a1285 1
      val = buffer[1] | (buffer[3] & 0x40 ? 0x10 : 0);
d1289 1
a1289 1
      val = buffer[3] | (buffer[3] & 0x40 ? 0x10 : 0);
d1336 1
a1336 1
  register int word;
@


1.12
log
@Add support for ColdFire MAC instructions and tidy up support for other m68k
variants.
@
text
@d243 1
a243 1
      arch_mask = m68000;
d246 1
a246 1
      arch_mask = m68008;
d249 1
a249 1
      arch_mask = m68010;
d252 1
a252 1
      arch_mask = m68020;
d255 1
a255 1
      arch_mask = m68030;
d258 1
a258 1
      arch_mask = m68040;
d261 1
a261 1
      arch_mask = m68060;
d264 1
a264 1
      arch_mask = mcf5200;
d266 1
d268 1
a268 1
      arch_mask = mcf528x | mcfmac;
d271 4
a274 1
      arch_mask = mcf5206e | mcfmac;
d277 1
a277 1
      arch_mask = mcf5307 | mcfmac;
d280 1
a280 1
      arch_mask = mcf5407 | mcfmac;
d282 2
d285 1
a285 1
      arch_mask = mcfv4e | mcfemac;
a287 2

  arch_mask |= m68881 | m68851;
@


1.11
log
@Add ColfFire v4 support
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003
d267 1
a267 1
      arch_mask = mcf528x;
d270 1
a270 1
      arch_mask = mcf5206e;
d273 1
a273 1
      arch_mask = mcf5307;
d276 4
a279 1
      arch_mask = mcf5407;
d742 18
d768 1
d906 10
d1110 28
@


1.11.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004
d49 1
a49 4
static bfd_boolean m68k_valid_ea (char code, int val);

const char * const fpcr_names[] =
{
d54 1
a54 2
static char *const reg_names[] =
{
d60 1
a60 10
/* Name of register halves for MAC/EMAC.
   Seperate from reg_names since 'spu', 'fpl' look weird.  */
static char *const reg_half_names[] =
{
    "%d0", "%d1", "%d2", "%d3", "%d4", "%d5", "%d6", "%d7",
    "%a0", "%a1", "%a2", "%a3", "%a4", "%a5", "%a6", "%a7",
    "%ps", "%pc"
};

/* Sign-extend an (unsigned char).  */
a171 141
/* Try to match the current instruction to best and if so, return the
   number of bytes consumed from the instruction stream, else zero.  */

static int
match_insn_m68k (bfd_vma memaddr, disassemble_info * info,
		 const struct m68k_opcode * best, struct private * priv)
{
  unsigned char *save_p;
  unsigned char *p;
  const char *d;

  bfd_byte *buffer = priv->the_buffer;
  fprintf_ftype save_printer = info->fprintf_func;
  void (* save_print_address) (bfd_vma, struct disassemble_info *)
    = info->print_address_func;

  /* Point at first word of argument data,
     and at descriptor for first argument.  */
  p = buffer + 2;

  /* Figure out how long the fixed-size portion of the instruction is.
     The only place this is stored in the opcode table is
     in the arguments--look for arguments which specify fields in the 2nd
     or 3rd words of the instruction.  */
  for (d = best->args; *d; d += 2)
    {
      /* I don't think it is necessary to be checking d[0] here;
	 I suspect all this could be moved to the case statement below.  */
      if (d[0] == '#')
	{
	  if (d[1] == 'l' && p - buffer < 6)
	    p = buffer + 6;
	  else if (p - buffer < 4 && d[1] != 'C' && d[1] != '8')
	    p = buffer + 4;
	}

      if ((d[0] == 'L' || d[0] == 'l') && d[1] == 'w' && p - buffer < 4)
	p = buffer + 4;

      switch (d[1])
	{
	case '1':
	case '2':
	case '3':
	case '7':
	case '8':
	case '9':
	case 'i':
	  if (p - buffer < 4)
	    p = buffer + 4;
	  break;
	case '4':
	case '5':
	case '6':
	  if (p - buffer < 6)
	    p = buffer + 6;
	  break;
	default:
	  break;
	}
    }

  /* pflusha is an exceptions.  It takes no arguments but is two words
     long.  Recognize it by looking at the lower 16 bits of the mask.  */
  if (p - buffer < 4 && (best->match & 0xFFFF) != 0)
    p = buffer + 4;

  /* lpstop is another exception.  It takes a one word argument but is
     three words long.  */
  if (p - buffer < 6
      && (best->match & 0xffff) == 0xffff
      && best->args[0] == '#'
      && best->args[1] == 'w')
    {
      /* Copy the one word argument into the usual location for a one
	 word argument, to simplify printing it.  We can get away with
	 this because we know exactly what the second word is, and we
	 aren't going to print anything based on it.  */
      p = buffer + 6;
      FETCH_DATA (info, p);
      buffer[2] = buffer[4];
      buffer[3] = buffer[5];
    }

  FETCH_DATA (info, p);

  d = best->args;

  save_p = p;
  info->print_address_func = dummy_print_address;
  info->fprintf_func = (fprintf_ftype) dummy_printer;

  /* We scan the operands twice.  The first time we don't print anything,
     but look for errors. */
  for (; *d; d += 2)
    {
      int eaten = print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);

      if (eaten >= 0)
	p += eaten;
      else if (eaten == -1)
	{
	  info->fprintf_func = save_printer;
	  info->print_address_func = save_print_address;
	  return 0;
	}
      else
	{
	  info->fprintf_func (info->stream,
			      /* xgettext:c-format */
			      _("<internal error in opcode table: %s %s>\n"),
			      best->name,  best->args);
	  info->fprintf_func = save_printer;
	  info->print_address_func = save_print_address;
	  return 2;
	}
    }

  p = save_p;
  info->fprintf_func = save_printer;
  info->print_address_func = save_print_address;

  d = best->args;

  info->fprintf_func (info->stream, "%s", best->name);

  if (*d)
    info->fprintf_func (info->stream, " ");

  while (*d)
    {
      p += print_insn_arg (d, buffer, p, memaddr + (p - buffer), info);
      d += 2;

      if (*d && *(d - 2) != 'I' && *d != 'k')
	info->fprintf_func (info->stream, ",");
    }

  return p - buffer;
}

d180 6
a185 2
  int i;
  const char *d;
d189 3
a194 1
  int val;
d198 2
a199 2
      /* Speed up the matching by sorting the opcode
	 table on the upper four bits of the opcode.  */
d206 5
a210 4
      /* Then create a sorted table of pointers
	 that point into the unsorted table.  */
      opc_pointer[0] = xmalloc (sizeof (struct m68k_opcode *)
				* m68k_numopcodes);
a211 1

d220 1
d224 2
a225 2
  /* Tell objdump to use two bytes per chunk
     and six bytes per line for displaying raw data.  */
a230 1

d235 1
d243 1
a243 1
      arch_mask = m68000|m68881|m68851;
d246 1
a246 1
      arch_mask = m68008|m68881|m68851;
d249 1
a249 1
      arch_mask = m68010|m68881|m68851;
d252 1
a252 1
      arch_mask = m68020|m68881|m68851;
d255 1
a255 1
      arch_mask = m68030|m68881|m68851;
d258 1
a258 1
      arch_mask = m68040|m68881|m68851;
d261 1
a261 1
      arch_mask = m68060|m68881|m68851;
d264 1
a264 1
      arch_mask = mcfisa_a;
a265 1
    case bfd_mach_mcf521x:
d267 1
a267 1
      arch_mask = mcfisa_a|mcfhwdiv|mcfisa_aa|mcfusp|mcfemac;
d270 1
a270 4
      arch_mask = mcfisa_a|mcfhwdiv|mcfmac;
      break;
    case bfd_mach_mcf5249:
      arch_mask = mcfisa_a|mcfhwdiv|mcfemac;
d273 1
a273 1
      arch_mask = mcfisa_a|mcfhwdiv|mcfmac;
d276 1
a276 6
      arch_mask = mcfisa_a|mcfhwdiv|mcfisa_b|mcfmac;
      break;
    case bfd_mach_mcf547x:
    case bfd_mach_mcf548x:
    case bfd_mach_mcfv4e:
      arch_mask = mcfisa_a|mcfhwdiv|mcfisa_b|mcfusp|cfloat|mcfemac;
d280 3
a284 1

d311 1
a311 1
	     register number in two places, as above.  */
d317 2
a318 2
	  /* Don't match fmovel with more than one register;
	     wait for fmoveml.  */
d325 2
d334 102
a435 3
	  if (*d == '\0')
	    if ((val = match_insn_m68k (memaddr, info, opc, & priv)))
	      return val;
d437 1
d439 3
d443 17
d461 4
a464 1
  info->fprintf_func (info->stream, "0%o", (buffer[0] << 8) + buffer[1]);
d470 1
a470 1
   an opcode tabe error was found.  */
d477 1
a477 1
     bfd_vma addr;		/* PC for this arg to be relative to.  */
d480 3
a482 3
  int val = 0;
  int place = d[1];
  unsigned char *p = p0;
d484 2
a485 2
  const char *regname;
  unsigned char *p1;
d493 1
a493 1
    case 'c':		/* Cache identifier.  */
d501 1
a501 1
    case 'a':		/* Address register indirect only. Cf. case '+'.  */
d510 1
a510 1
    case '_':		/* 32-bit absolute address for move16.  */
a738 20
    case 'e':
      val = fetch_arg(buffer, place, 2, info);
      (*info->fprintf_func) (info->stream, "%%acc%d", val);
      break;

    case 'g':
      val = fetch_arg(buffer, place, 1, info);
      (*info->fprintf_func) (info->stream, "%%accext%s", val==0 ? "01" : "23");
      break;
      
    case 'i':
      val = fetch_arg(buffer, place, 2, info);
      if (val == 1)
	(*info->fprintf_func) (info->stream, "<<");
      else if (val == 3)
	(*info->fprintf_func) (info->stream, ">>");
      else
	return -1;
      break;

a746 1
    case '4':
a777 4
      /* If the <ea> is invalid for *d, then reject this match.  */
      if (!m68k_valid_ea (*d, val))
	return -1;

a883 10

      /* If place is '/', then this is the case of the mask bit for
	 mac/emac loads. Now that the arg has been printed, grab the
	 mask bit and if set, add a '&' to the arg.  */
      if (place == '/')
	{
	  val = fetch_arg (buffer, place, 1, info);
	  if (val)
	    info->fprintf_func (info->stream, "&");
	}
d1051 1
a1051 1
			       reg_half_names[reg],
a1062 100
/* Check if an EA is valid for a particular code.  This is required
   for the EMAC instructions since the type of source address determines
   if it is a EMAC-load instruciton if the EA is mode 2-5, otherwise it
   is a non-load EMAC instruction and the bits mean register Ry.
   A similar case exists for the movem instructions where the register
   mask is interpreted differently for different EAs.  */

static bfd_boolean
m68k_valid_ea (char code, int val)
{
  int mode, mask;
#define M(n0,n1,n2,n3,n4,n5,n6,n70,n71,n72,n73,n74) \
  (n0 | n1 << 1 | n2 << 2 | n3 << 3 | n4 << 4 | n5 << 5 | n6 << 6 \
   | n70 << 7 | n71 << 8 | n72 << 9 | n73 << 10 | n74 << 11)

  switch (code)
    {
    case '*':
      mask = M (1,1,1,1,1,1,1,1,1,1,1,1);
      break;
    case '~':
      mask = M (0,0,1,1,1,1,1,1,1,0,0,0);
      break;
    case '%':
      mask = M (1,1,1,1,1,1,1,1,1,0,0,0);
      break;
    case ';':
      mask = M (1,0,1,1,1,1,1,1,1,1,1,1);
      break;
    case '@@':
      mask = M (1,0,1,1,1,1,1,1,1,1,1,0);
      break;
    case '!':
      mask = M (0,0,1,0,0,1,1,1,1,1,1,0);
      break;
    case '&':
      mask = M (0,0,1,0,0,1,1,1,1,0,0,0);
      break;
    case '$':
      mask = M (1,0,1,1,1,1,1,1,1,0,0,0);
      break;
    case '?':
      mask = M (1,0,1,0,0,1,1,1,1,0,0,0);
      break;
    case '/':
      mask = M (1,0,1,0,0,1,1,1,1,1,1,0);
      break;
    case '|':
      mask = M (0,0,1,0,0,1,1,1,1,1,1,0);
      break;
    case '>':
      mask = M (0,0,1,0,1,1,1,1,1,0,0,0);
      break;
    case '<':
      mask = M (0,0,1,1,0,1,1,1,1,1,1,0);
      break;
    case 'm':
      mask = M (1,1,1,1,1,0,0,0,0,0,0,0);
      break;
    case 'n':
      mask = M (0,0,0,0,0,1,0,0,0,1,0,0);
      break;
    case 'o':
      mask = M (0,0,0,0,0,0,1,1,1,0,1,1);
      break;
    case 'p':
      mask = M (1,1,1,1,1,1,0,0,0,0,0,0);
      break;
    case 'q':
      mask = M (1,0,1,1,1,1,0,0,0,0,0,0);
      break;
    case 'v':
      mask = M (1,0,1,1,1,1,0,1,1,0,0,0);
      break;
    case 'b':
      mask = M (1,0,1,1,1,1,0,0,0,1,0,0);
      break;
    case 'w':
      mask = M (0,0,1,1,1,1,0,0,0,1,0,0);
      break;
    case 'y':
      mask = M (0,0,1,0,0,1,0,0,0,0,0,0);
      break;
    case 'z':
      mask = M (0,0,1,0,0,1,0,0,0,1,0,0);
      break;
    case '4':
      mask = M (0,0,1,1,1,1,0,0,0,0,0,0);
      break;
    default:
      abort ();
    }
#undef M

  mode = (val >> 3) & 7;
  if (mode == 7)
    mode += val & 7;
  return (mask & (1 << mode)) != 0;
}

d1075 1
a1075 2
  int val = 0;

a1077 28
    case '/': /* MAC/EMAC mask bit.  */
      val = buffer[3] >> 5;
      break;

    case 'G': /* EMAC ACC load.  */
      val = ((buffer[3] >> 3) & 0x2) | ((~buffer[1] >> 7) & 0x1);
      break;

    case 'H': /* EMAC ACC !load.  */
      val = ((buffer[3] >> 3) & 0x2) | ((buffer[1] >> 7) & 0x1);
      break;

    case ']': /* EMAC ACCEXT bit.  */
      val = buffer[0] >> 2;
      break;

    case 'I': /* MAC/EMAC scale factor.  */
      val = buffer[2] >> 1;
      break;

    case 'F': /* EMAC ACCx.  */
      val = buffer[0] >> 1;
      break;

    case 'f':
      val = buffer[1];
      break;

d1174 1
a1174 1
      val = (buffer[1] & 0xf) | (buffer[3] & 0x40 ? 0x10 : 0);
d1178 1
a1178 1
      val = (buffer[3] & 0xf) | (buffer[3] & 0x40 ? 0x10 : 0);
d1225 1
a1225 1
  int word;
@


1.10
log
@	* a29k-dis.c: Replace CONST with const.
	* h8300-dis.c: Likewise.
	* m68k-dis.c: Likewise.
	* or32-dis.c: Likewise.
	* sparc-dis.c: Likewise.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002
d6 13
a18 13
This file is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d266 3
d348 1
a348 1
  
d412 1
a412 1
  
d415 1
a415 1
  /* We can the operands twice.  The first time we don't print anything,
d543 3
d552 1
d579 8
d742 1
a742 1
      
d766 4
a769 1

d1044 1
a1044 1
	
d1055 1
a1055 1
	
d1142 1
a1142 1
      
d1159 1
a1159 1
    case 'm': 
d1165 1
a1165 1
    case 'n': 
@


1.10.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003
d6 13
a18 13
   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a265 3
    case bfd_mach_mcf528x:
      arch_mask = mcf528x;
      break;
d345 1
a345 1

d409 1
a409 1

d412 1
a412 1
  /* We scan the operands twice.  The first time we don't print anything,
a539 3
	/* FIXME: There's a problem here, different m68k processors call the
	   same address different names. This table can't get it right
	   because it doesn't know which processor it's disassembling for.  */
a545 1
	     {"%flashbar", 0xc04}, {"%rambar", 0xc05}, /* mcf528x added these.  */
a571 8
    case 'x':
      val = fetch_arg (buffer, place, 3, info);
      /* 0 means -1.  */
      if (val == 0)
	val = -1;
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

d727 1
a727 1

d751 1
a751 4
    case 'b':
    case 'w':
    case 'y':
    case 'z':
d1026 1
a1026 1

d1037 1
a1037 1

d1124 1
a1124 1

d1141 1
a1141 1
    case 'm':
d1147 1
a1147 1
    case 'n':
@


1.10.12.1
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003
d6 13
a18 13
   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a265 3
    case bfd_mach_mcf528x:
      arch_mask = mcf528x;
      break;
d345 1
a345 1

d409 1
a409 1

d412 1
a412 1
  /* We scan the operands twice.  The first time we don't print anything,
a539 3
	/* FIXME: There's a problem here, different m68k processors call the
	   same address different names. This table can't get it right
	   because it doesn't know which processor it's disassembling for.  */
a545 1
	     {"%flashbar", 0xc04}, {"%rambar", 0xc05}, /* mcf528x added these.  */
a571 8
    case 'x':
      val = fetch_arg (buffer, place, 3, info);
      /* 0 means -1.  */
      if (val == 0)
	val = -1;
      (*info->fprintf_func) (info->stream, "#%d", val);
      break;

d727 1
a727 1

d751 1
a751 4
    case 'b':
    case 'w':
    case 'y':
    case 'z':
d1026 1
a1026 1

d1037 1
a1037 1

d1124 1
a1124 1

d1141 1
a1141 1
    case 'm':
d1147 1
a1147 1
    case 'n':
@


1.9
log
@	* Makefile.am (sh-dis.lo): Don't put make commands in deps.
	* Makefile.in: Regenerate.
	* arc-dis.c: Use #include "" instead of <> for local header files.
	* m68k-dis.c: Likewise.
@
text
@d49 1
a49 1
CONST char * CONST fpcr_names[] = {
d481 1
a481 1
  register CONST char *regname;
@


1.9.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d49 1
a49 1
const char * const fpcr_names[] = {
d481 1
a481 1
  register const char *regname;
@


1.8
log
@	* m68k-dis.c: Fix formatting.
	* pj-dis.c: Likewise.
	* z8k-dis.c: Likewise.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001
d23 1
a23 1
#include <libiberty.h>
@


1.8.14.1
log
@merge from trunk
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002
d23 1
a23 1
#include "libiberty.h"
d49 1
a49 1
const char * const fpcr_names[] = {
d481 1
a481 1
  register const char *regname;
@


1.7
log
@correct some 68k/ColdFire problems
@
text
@d40 1
a40 1
print_base PARAMS ((int, bfd_vma, disassemble_info*));
d49 1
a49 2
CONST char * CONST fpcr_names[] =
  {
d52 1
a52 1
  };
d54 1
a54 2
static char *const reg_names[] =
  {
d58 1
a58 1
  };
d62 1
a62 1
#define COERCE_SIGNED_CHAR(ch) ((signed char)(ch))
d64 1
a64 1
#define COERCE_SIGNED_CHAR(ch) ((int)(((ch) ^ 0x80) & 0xFF) - 128)
a107 1

d114 1
a114 2
struct private
{
d126 1
a126 1
  ((addr) <= ((struct private *)(info->private_data))->max_fetched \
d155 2
a156 2
dummy_printer (FILE * file ATTRIBUTE_UNUSED,
	       const char * format ATTRIBUTE_UNUSED, ...)
d158 2
a159 1
dummy_printer (file) FILE *file ATTRIBUTE_UNUSED;
d161 3
a163 1
 { return 0; }
d190 1
a190 1
  void (*save_print_address) PARAMS((bfd_vma, struct disassemble_info*))
d358 1
a358 1
	  else if (p - buffer < 4 && d[1] != 'C' && d[1] != '8' )
d417 2
a418 2
  info->fprintf_func = (fprintf_ftype)dummy_printer;
  for ( ; *d; d += 2)
d427 5
a431 5
	  (*info->fprintf_func)(info->stream,
				/* xgettext:c-format */
				_("<internal error in opcode table: %s %s>\n"),
				best->name,
				best->args);
d503 1
a503 1
	   reg_names [fetch_arg (buffer, place, 3, info) + 8]);
d627 1
a627 1
	(*info->fprintf_func) (info->stream, "%s", reg_names [val & 7]);
d652 1
a652 1
	  if ( val > 63 )		/* This is a signed constant. */
d686 1
a686 1
	disp = COERCE_SIGNED_CHAR(buffer[1]);
d820 1
a820 1
	      switch( place )
d838 1
a838 1
		  NEXTSINGLE(flval, p);
d842 1
a842 1
		  NEXTDOUBLE(flval, p);
d846 1
a846 1
		  NEXTEXTEND(flval, p);
d850 1
a850 1
		  flval = NEXTPACKED(p);
d856 1
a856 1
	      if ( flt_p )	/* Print a float? */
d1208 1
a1208 1
  static char *const scales[] = {"", ":2", ":4", ":8"};
@


1.6
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d271 1
a271 1
      arch_mask = mcf5407;
@


1.5
log
@est of the changes for Coldfire V4
@
text
@d2 2
a3 1
   Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.4
log
@Kill compiler warnings with ATTRIBUTE_UNUSED.
@
text
@d2 1
a2 1
   Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d48 12
a59 8
CONST char * CONST fpcr_names[] = {
  "", "%fpiar", "%fpsr", "%fpiar/%fpsr", "%fpcr",
  "%fpiar/%fpcr", "%fpsr/%fpcr", "%fpiar/%fpsr/%fpcr"};

static char *const reg_names[] = {
  "%d0", "%d1", "%d2", "%d3", "%d4", "%d5", "%d6", "%d7",
  "%a0", "%a1", "%a2", "%a3", "%a4", "%a5", "%fp", "%sp",
  "%ps", "%pc"};
d185 1
a185 1
  const struct m68k_opcode *best = 0;
d235 1
d263 12
d339 1
a339 1
  if (best == 0)
@


1.4.4.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001
@


1.4.4.2
log
@Merge from mainline.
@
text
@d49 8
a56 12
CONST char * CONST fpcr_names[] =
  {
    "", "%fpiar", "%fpsr", "%fpiar/%fpsr", "%fpcr",
    "%fpiar/%fpcr", "%fpsr/%fpcr", "%fpiar/%fpsr/%fpcr"
  };

static char *const reg_names[] =
  {
    "%d0", "%d1", "%d2", "%d3", "%d4", "%d5", "%d6", "%d7",
    "%a0", "%a1", "%a2", "%a3", "%a4", "%a5", "%fp", "%sp",
    "%ps", "%pc"
  };
d182 1
a182 1
  const struct m68k_opcode *best;
a231 1
  best = NULL;
a258 12
    case bfd_mach_mcf5200:
      arch_mask = mcf5200;
      break;
    case bfd_mach_mcf5206e:
      arch_mask = mcf5206e;
      break;
    case bfd_mach_mcf5307:
      arch_mask = mcf5307;
      break;
    case bfd_mach_mcf5407:
      arch_mask = mcf5407;
      break;
d323 1
a323 1
  if (best == NULL)
@


1.3
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 1
a2 1
   Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d154 2
a155 1
dummy_printer (FILE * file, const char * format, ...)
d157 1
a157 1
dummy_printer (file) FILE *file;
d163 2
a164 2
     bfd_vma vma;
     struct disassemble_info *info;
@


1.2
log
@1999-05-28  Linus Nordberg  <linus.nordberg@@canit.se>
	* m68k-opc.c: Rename MACL/MSACL to MAC/MSAC.  Add MACM/MSACM.  Add
	MOVE MACSR,CCR.
	* m68k-dis.c (fetch_arg): Add places `n', `o'.
	* m68k-opc.c: Add MSAC, MACL, MOVE to/from ACC, MACSR, MASK.
	Add mcf5206e to appropriate instructions.
	Add alias for MAC, MSAC.
	* m68k-dis.c (print_insn_arg): Add formats `E', `G', `H' and place
	`N'.
	* m68k-opc.c (m68k_opcodes): Add divsw, divsl, divuw, divul, macl,
	macw, remsl, remul for mcf5307.  Change mcf5200 --> mcf.
	* m68k-dis.c: Add format `u' and places `h', `m', `M'.
@
text
@d19 1
@


1.2.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@a18 1
#include "sysdep.h"
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 1998
d507 12
d554 13
a566 4
      val = fetch_arg (buffer, place, 8, info);
      if (val & 0x80)
	val = val - 0x100;
      (*info->fprintf_func) (info->stream, "#%d", val);
d1003 16
d1122 26
d1154 2
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

