head	1.15;
access;
symbols
	sid-snapshot-20180601:1.15
	sid-snapshot-20180501:1.15
	sid-snapshot-20180401:1.15
	sid-snapshot-20180301:1.15
	sid-snapshot-20180201:1.15
	sid-snapshot-20180101:1.15
	sid-snapshot-20171201:1.15
	sid-snapshot-20171101:1.15
	sid-snapshot-20171001:1.15
	sid-snapshot-20170901:1.15
	sid-snapshot-20170801:1.15
	sid-snapshot-20170701:1.15
	sid-snapshot-20170601:1.15
	sid-snapshot-20170501:1.15
	sid-snapshot-20170401:1.15
	sid-snapshot-20170301:1.15
	sid-snapshot-20170201:1.15
	sid-snapshot-20170101:1.15
	sid-snapshot-20161201:1.15
	sid-snapshot-20161101:1.15
	sid-snapshot-20160901:1.15
	sid-snapshot-20160801:1.15
	sid-snapshot-20160701:1.15
	sid-snapshot-20160601:1.15
	sid-snapshot-20160501:1.15
	sid-snapshot-20160401:1.15
	sid-snapshot-20160301:1.15
	sid-snapshot-20160201:1.15
	sid-snapshot-20160101:1.15
	sid-snapshot-20151201:1.15
	sid-snapshot-20151101:1.15
	sid-snapshot-20151001:1.15
	sid-snapshot-20150901:1.15
	sid-snapshot-20150801:1.15
	sid-snapshot-20150701:1.15
	sid-snapshot-20150601:1.15
	sid-snapshot-20150501:1.15
	sid-snapshot-20150401:1.15
	sid-snapshot-20150301:1.15
	sid-snapshot-20150201:1.15
	sid-snapshot-20150101:1.15
	sid-snapshot-20141201:1.15
	sid-snapshot-20141101:1.15
	sid-snapshot-20141001:1.15
	sid-snapshot-20140901:1.15
	sid-snapshot-20140801:1.15
	sid-snapshot-20140701:1.15
	sid-snapshot-20140601:1.15
	sid-snapshot-20140501:1.15
	sid-snapshot-20140401:1.15
	sid-snapshot-20140301:1.15
	sid-snapshot-20140201:1.15
	sid-snapshot-20140101:1.15
	sid-snapshot-20131201:1.15
	sid-snapshot-20131101:1.15
	sid-snapshot-20131001:1.15
	binutils-2_24-branch:1.15.0.4
	binutils-2_24-branchpoint:1.15
	binutils-2_21_1:1.13
	sid-snapshot-20130901:1.15
	gdb_7_6_1-2013-08-30-release:1.15
	sid-snapshot-20130801:1.15
	sid-snapshot-20130701:1.15
	sid-snapshot-20130601:1.15
	sid-snapshot-20130501:1.15
	gdb_7_6-2013-04-26-release:1.15
	sid-snapshot-20130401:1.15
	binutils-2_23_2:1.14
	gdb_7_6-branch:1.15.0.2
	gdb_7_6-2013-03-12-branchpoint:1.15
	sid-snapshot-20130301:1.15
	sid-snapshot-20130201:1.15
	sid-snapshot-20130101:1.15
	sid-snapshot-20121201:1.15
	gdb_7_5_1-2012-11-29-release:1.14
	binutils-2_23_1:1.14
	sid-snapshot-20121101:1.15
	binutils-2_23:1.14
	sid-snapshot-20121001:1.14
	sid-snapshot-20120901:1.14
	gdb_7_5-2012-08-17-release:1.14
	sid-snapshot-20120801:1.14
	binutils-2_23-branch:1.14.0.4
	binutils-2_23-branchpoint:1.14
	gdb_7_5-branch:1.14.0.2
	gdb_7_5-2012-07-18-branchpoint:1.14
	sid-snapshot-20120701:1.14
	sid-snapshot-20120601:1.14
	sid-snapshot-20120501:1.13
	binutils-2_22_branch:1.13.0.18
	gdb_7_4_1-2012-04-26-release:1.13
	sid-snapshot-20120401:1.13
	sid-snapshot-20120301:1.13
	sid-snapshot-20120201:1.13
	gdb_7_4-2012-01-24-release:1.13
	sid-snapshot-20120101:1.13
	gdb_7_4-branch:1.13.0.16
	gdb_7_4-2011-12-13-branchpoint:1.13
	sid-snapshot-20111201:1.13
	binutils-2_22:1.13
	sid-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	binutils-2_22-branch:1.13.0.14
	binutils-2_22-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.13
	sid-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	gdb_7_3-2011-07-26-release:1.13
	sid-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	sid-snapshot-20110501:1.13
	gdb_7_3-branch:1.13.0.12
	gdb_7_3-2011-04-01-branchpoint:1.13
	sid-snapshot-20110401:1.13
	sid-snapshot-20110301:1.13
	sid-snapshot-20110201:1.13
	sid-snapshot-20110101:1.13
	binutils-2_21:1.13
	sid-snapshot-20101201:1.13
	binutils-2_21-branch:1.13.0.10
	binutils-2_21-branchpoint:1.13
	sid-snapshot-20101101:1.13
	sid-snapshot-20101001:1.13
	binutils-2_20_1:1.13
	gdb_7_2-2010-09-02-release:1.13
	sid-snapshot-20100901:1.13
	sid-snapshot-20100801:1.13
	gdb_7_2-branch:1.13.0.8
	gdb_7_2-2010-07-07-branchpoint:1.13
	sid-snapshot-20100701:1.13
	sid-snapshot-20100601:1.13
	sid-snapshot-20100501:1.13
	sid-snapshot-20100401:1.13
	gdb_7_1-2010-03-18-release:1.13
	sid-snapshot-20100301:1.13
	gdb_7_1-branch:1.13.0.6
	gdb_7_1-2010-02-18-branchpoint:1.13
	sid-snapshot-20100201:1.13
	sid-snapshot-20100101:1.13
	gdb_7_0_1-2009-12-22-release:1.13
	sid-snapshot-20091201:1.13
	sid-snapshot-20091101:1.13
	binutils-2_20:1.13
	gdb_7_0-2009-10-06-release:1.13
	sid-snapshot-20091001:1.13
	gdb_7_0-branch:1.13.0.4
	gdb_7_0-2009-09-16-branchpoint:1.13
	arc-sim-20090309:1.10
	binutils-arc-20081103-branch:1.10.0.26
	binutils-arc-20081103-branchpoint:1.10
	binutils-2_20-branch:1.13.0.2
	binutils-2_20-branchpoint:1.13
	sid-snapshot-20090901:1.12
	sid-snapshot-20090801:1.11
	msnyder-checkpoint-072509-branch:1.11.0.4
	msnyder-checkpoint-072509-branchpoint:1.11
	sid-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.2
	dje-cgen-play1-branchpoint:1.11
	sid-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	arc-20081103-branch:1.10.0.24
	arc-20081103-branchpoint:1.10
	arc-insight_6_8-branch:1.10.0.22
	arc-insight_6_8-branchpoint:1.10
	insight_6_8-branch:1.10.0.20
	insight_6_8-branchpoint:1.10
	sid-snapshot-20090301:1.11
	binutils-2_19_1:1.10
	sid-snapshot-20090201:1.10
	sid-snapshot-20090101:1.10
	reverse-20081226-branch:1.10.0.18
	reverse-20081226-branchpoint:1.10
	sid-snapshot-20081201:1.10
	multiprocess-20081120-branch:1.10.0.16
	multiprocess-20081120-branchpoint:1.10
	sid-snapshot-20081101:1.10
	binutils-2_19:1.10
	sid-snapshot-20081001:1.10
	reverse-20080930-branch:1.10.0.14
	reverse-20080930-branchpoint:1.10
	binutils-2_19-branch:1.10.0.12
	binutils-2_19-branchpoint:1.10
	sid-snapshot-20080901:1.10
	sid-snapshot-20080801:1.10
	reverse-20080717-branch:1.10.0.10
	reverse-20080717-branchpoint:1.10
	sid-snapshot-20080701:1.10
	msnyder-reverse-20080609-branch:1.10.0.8
	msnyder-reverse-20080609-branchpoint:1.10
	drow-reverse-20070409-branch:1.9.0.34
	drow-reverse-20070409-branchpoint:1.9
	sid-snapshot-20080601:1.10
	sid-snapshot-20080501:1.10
	sid-snapshot-20080403:1.10
	sid-snapshot-20080401:1.10
	gdb_6_8-2008-03-27-release:1.10
	sid-snapshot-20080301:1.10
	gdb_6_8-branch:1.10.0.6
	gdb_6_8-2008-02-26-branchpoint:1.10
	sid-snapshot-20080201:1.10
	sid-snapshot-20080101:1.10
	sid-snapshot-20071201:1.10
	sid-snapshot-20071101:1.10
	gdb_6_7_1-2007-10-29-release:1.10
	gdb_6_7-2007-10-10-release:1.10
	sid-snapshot-20071001:1.10
	gdb_6_7-branch:1.10.0.4
	gdb_6_7-2007-09-07-branchpoint:1.10
	binutils-2_18:1.10
	binutils-2_18-branch:1.10.0.2
	binutils-2_18-branchpoint:1.10
	insight_6_6-20070208-release:1.9
	binutils-csl-coldfire-4_1-32:1.9
	binutils-csl-sourcerygxx-4_1-32:1.9
	gdb_6_6-2006-12-18-release:1.9
	binutils-csl-innovasic-fido-3_4_4-33:1.9
	binutils-csl-sourcerygxx-3_4_4-32:1.8
	binutils-csl-coldfire-4_1-30:1.9
	binutils-csl-sourcerygxx-4_1-30:1.9
	binutils-csl-coldfire-4_1-28:1.9
	binutils-csl-sourcerygxx-4_1-29:1.9
	binutils-csl-sourcerygxx-4_1-28:1.9
	gdb_6_6-branch:1.9.0.32
	gdb_6_6-2006-11-15-branchpoint:1.9
	binutils-csl-arm-2006q3-27:1.9
	binutils-csl-sourcerygxx-4_1-27:1.9
	binutils-csl-arm-2006q3-26:1.9
	binutils-csl-sourcerygxx-4_1-26:1.9
	binutils-csl-sourcerygxx-4_1-25:1.9
	binutils-csl-sourcerygxx-4_1-24:1.9
	binutils-csl-sourcerygxx-4_1-23:1.9
	insight_6_5-20061003-release:1.9
	gdb-csl-symbian-6_4_50_20060226-12:1.9
	binutils-csl-sourcerygxx-4_1-21:1.9
	binutils-csl-arm-2006q3-21:1.9
	binutils-csl-sourcerygxx-4_1-22:1.9
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.9
	binutils-csl-sourcerygxx-4_1-20:1.9
	binutils-csl-arm-2006q3-19:1.9
	binutils-csl-sourcerygxx-4_1-19:1.9
	binutils-csl-sourcerygxx-4_1-18:1.9
	binutils-csl-renesas-4_1-9:1.9
	gdb-csl-sourcerygxx-3_4_4-25:1.9
	binutils-csl-sourcerygxx-3_4_4-25:1.8
	nickrob-async-20060828-mergepoint:1.9
	gdb-csl-symbian-6_4_50_20060226-11:1.9
	binutils-csl-renesas-4_1-8:1.9
	binutils-csl-renesas-4_1-7:1.9
	binutils-csl-renesas-4_1-6:1.9
	gdb-csl-sourcerygxx-4_1-17:1.9
	binutils-csl-sourcerygxx-4_1-17:1.9
	gdb-csl-20060226-branch-local-2:1.9
	gdb-csl-sourcerygxx-4_1-14:1.9
	binutils-csl-sourcerygxx-4_1-14:1.9
	binutils-csl-sourcerygxx-4_1-15:1.9
	gdb-csl-sourcerygxx-4_1-13:1.9
	binutils-csl-sourcerygxx-4_1-13:1.9
	binutils-2_17:1.9
	gdb-csl-sourcerygxx-4_1-12:1.9
	binutils-csl-sourcerygxx-4_1-12:1.9
	gdb-csl-sourcerygxx-3_4_4-21:1.9
	binutils-csl-sourcerygxx-3_4_4-21:1.9
	gdb_6_5-20060621-release:1.9
	binutils-csl-wrs-linux-3_4_4-24:1.8
	binutils-csl-wrs-linux-3_4_4-23:1.8
	gdb-csl-sourcerygxx-4_1-9:1.9
	binutils-csl-sourcerygxx-4_1-9:1.9
	gdb-csl-sourcerygxx-4_1-8:1.9
	binutils-csl-sourcerygxx-4_1-8:1.9
	gdb-csl-sourcerygxx-4_1-7:1.9
	binutils-csl-sourcerygxx-4_1-7:1.9
	gdb-csl-arm-2006q1-6:1.9
	binutils-csl-arm-2006q1-6:1.9
	gdb-csl-sourcerygxx-4_1-6:1.9
	binutils-csl-sourcerygxx-4_1-6:1.9
	binutils-csl-wrs-linux-3_4_4-22:1.8
	gdb-csl-symbian-6_4_50_20060226-10:1.9
	gdb-csl-symbian-6_4_50_20060226-9:1.9
	gdb-csl-symbian-6_4_50_20060226-8:1.9
	gdb-csl-coldfire-4_1-11:1.9
	binutils-csl-coldfire-4_1-11:1.9
	gdb-csl-sourcerygxx-3_4_4-19:1.9
	binutils-csl-sourcerygxx-3_4_4-19:1.9
	gdb-csl-coldfire-4_1-10:1.9
	gdb_6_5-branch:1.9.0.30
	gdb_6_5-2006-05-14-branchpoint:1.9
	binutils-csl-coldfire-4_1-10:1.9
	gdb-csl-sourcerygxx-4_1-5:1.9
	binutils-csl-sourcerygxx-4_1-5:1.9
	nickrob-async-20060513-branch:1.9.0.28
	nickrob-async-20060513-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-4:1.9
	binutils-csl-sourcerygxx-4_1-4:1.9
	msnyder-reverse-20060502-branch:1.9.0.26
	msnyder-reverse-20060502-branchpoint:1.9
	binutils-csl-wrs-linux-3_4_4-21:1.8
	gdb-csl-morpho-4_1-4:1.9
	binutils-csl-morpho-4_1-4:1.9
	gdb-csl-sourcerygxx-3_4_4-17:1.9
	binutils-csl-sourcerygxx-3_4_4-17:1.9
	binutils-csl-wrs-linux-3_4_4-20:1.8
	readline_5_1-import-branch:1.9.0.24
	readline_5_1-import-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.9
	binutils-2_17-branch:1.9.0.22
	binutils-2_17-branchpoint:1.9
	gdb-csl-symbian-20060226-branch:1.9.0.20
	gdb-csl-symbian-20060226-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.9
	msnyder-reverse-20060331-branch:1.9.0.18
	msnyder-reverse-20060331-branchpoint:1.9
	binutils-csl-2_17-branch:1.9.0.16
	binutils-csl-2_17-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.9.0.14
	gdb-csl-available-20060303-branchpoint:1.9
	gdb-csl-20060226-branch:1.9.0.12
	gdb-csl-20060226-branchpoint:1.9
	gdb_6_4-20051202-release:1.9
	msnyder-fork-checkpoint-branch:1.9.0.10
	msnyder-fork-checkpoint-branchpoint:1.9
	gdb-csl-gxxpro-6_3-branch:1.9.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.9
	gdb_6_4-branch:1.9.0.6
	gdb_6_4-2005-11-01-branchpoint:1.9
	gdb-csl-arm-20051020-branch:1.9.0.4
	gdb-csl-arm-20051020-branchpoint:1.9
	binutils-csl-gxxpro-3_4-branch:1.8.0.94
	binutils-csl-gxxpro-3_4-branchpoint:1.8
	binutils-2_16_1:1.8
	msnyder-tracepoint-checkpoint-branch:1.9.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.9
	gdb-csl-arm-20050325-2005-q1b:1.8
	binutils-csl-arm-2005q1b:1.8
	binutils-2_16:1.8
	gdb-csl-arm-20050325-2005-q1a:1.8
	binutils-csl-arm-2005q1a:1.8
	csl-arm-20050325-branch:1.8.0.92
	csl-arm-20050325-branchpoint:1.8
	binutils-csl-arm-2005q1-branch:1.8.0.90
	binutils-csl-arm-2005q1-branchpoint:1.8
	binutils-2_16-branch:1.8.0.88
	binutils-2_16-branchpoint:1.8
	csl-arm-2004-q3d:1.8
	gdb_6_3-20041109-release:1.8
	gdb_6_3-branch:1.8.0.84
	gdb_6_3-20041019-branchpoint:1.8
	csl-arm-2004-q3:1.8
	drow_intercu-merge-20040921:1.8
	drow_intercu-merge-20040915:1.8
	jimb-gdb_6_2-e500-branch:1.8.0.86
	jimb-gdb_6_2-e500-branchpoint:1.8
	gdb_6_2-20040730-release:1.8
	gdb_6_2-branch:1.8.0.82
	gdb_6_2-2004-07-10-gmt-branchpoint:1.8
	gdb_6_1_1-20040616-release:1.8
	binutils-2_15:1.8
	binutils-2_15-branchpoint:1.8
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.8
	gdb_6_1-2004-04-05-release:1.8
	drow_intercu-merge-20040402:1.8
	drow_intercu-merge-20040327:1.8
	ezannoni_pie-20040323-branch:1.8.0.80
	ezannoni_pie-20040323-branchpoint:1.8
	cagney_tramp-20040321-mergepoint:1.8
	cagney_tramp-20040309-branch:1.8.0.78
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.76
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow_intercu-20040221-branch:1.8.0.74
	drow_intercu-20040221-branchpoint:1.8
	binutils-2_15-branch:1.8.0.72
	cagney_bfdfile-20040213-branch:1.8.0.70
	cagney_bfdfile-20040213-branchpoint:1.8
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.8
	cagney_bigcore-20040122-branch:1.8.0.68
	cagney_bigcore-20040122-branchpoint:1.8
	drow-cplus-merge-20040113:1.8
	csl-arm-2003-q4:1.8
	drow-cplus-merge-20031224:1.8
	drow-cplus-merge-20031220:1.8
	carlton_dictionary-20031215-merge:1.8
	drow-cplus-merge-20031214:1.8
	carlton-dictionary-20031111-merge:1.8
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.8.0.66
	kettenis_sparc-20030918-branchpoint:1.8
	carlton_dictionary-20030917-merge:1.8
	ezannoni_pie-20030916-branchpoint:1.8
	ezannoni_pie-20030916-branch:1.8.0.64
	cagney_x86i386-20030821-branch:1.8.0.62
	cagney_x86i386-20030821-branchpoint:1.8
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.60
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.58
	jimb-ppc64-linux-20030613-branchpoint:1.8
	binutils-2_14:1.8
	cagney_convert-20030606-branch:1.8.0.56
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.54
	cagney_writestrings-20030508-branchpoint:1.8
	jimb-ppc64-linux-20030528-branch:1.8.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.50
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.8.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.8
	kettenis_i386newframe-20030504-mergepoint:1.8
	carlton_dictionary-20030430-merge:1.8
	binutils-2_14-branch:1.8.0.46
	binutils-2_14-branchpoint:1.8
	kettenis_i386newframe-20030419-branch:1.8.0.44
	kettenis_i386newframe-20030419-branchpoint:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.42
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.40
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.38
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.36
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.34
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.32
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.30
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.8
	interps-20030202-branch:1.8.0.28
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.8.0.26
	cagney-unwind-20030108-branchpoint:1.8
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	binutils-2_13_1:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.24
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.22
	carlton_dictionary-20020920-branchpoint:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.20
	gdb_5_3-branch:1.8.0.18
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.16
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.14
	readline_4_3-import-branchpoint:1.8
	binutils-2_13:1.8
	gdb_5_2_1-2002-07-23-release:1.8
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.12
	kseitz_interps-20020528-branch:1.8.0.10
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.8
	cagney_regbuf-20020515-branchpoint:1.8
	binutils-2_12_1:1.8
	jimb-macro-020506-branch:1.8.0.6
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.8
	binutils-2_12:1.8
	gdb_5_2-branch:1.8.0.4
	gdb_5_2-2002-03-03-branchpoint:1.8
	binutils-2_12-branch:1.8.0.2
	binutils-2_12-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.3
	binutils_latest_snapshot:1.15
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2;
locks; strict;
comment	@ * @;


1.15
date	2012.10.18.15.28.06;	author tromey;	state Exp;
branches;
next	1.14;

1.14
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.29.22.11.02;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.18.17.13.04;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.07.07.34.31;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.13.14.22.53;	author twall;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.20.15.28.25;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.26.11.47.39;	author aj;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.24.04.10.19;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.22.58.37;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.04.06.38.01;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.05.30.18.35.33;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.06.17.14.34;	author twall;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.18.36;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.15
log
@	* tic54x-dis.c (print_instruction): Don't use K&R style.
	(print_parallel_instruction, sprint_dual_address)
	(sprint_indirect_address, sprint_direct_address, sprint_mmr)
	(sprint_cc2, sprint_condition): Likewise.
@
text
@/* Disassembly routines for TMS320C54X architecture
   Copyright 1999, 2000, 2001, 2005, 2007, 2009, 2012
   Free Software Foundation, Inc.
   Contributed by Timothy Wall (twall@@cygnus.com)

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this file; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <errno.h>
#include <math.h>
#include <stdlib.h>
#include "dis-asm.h"
#include "opcode/tic54x.h"
#include "coff/tic54x.h"

static int has_lkaddr (unsigned short, const insn_template *);
static int get_insn_size (unsigned short, const insn_template *);
static int print_instruction (disassemble_info *, bfd_vma,
                              unsigned short, const char *,
                              const enum optype [], int, int);
static int print_parallel_instruction (disassemble_info *, bfd_vma,
                                       unsigned short,
                                       const insn_template *, int);
static int sprint_dual_address (disassemble_info *,char [],
                                unsigned short);
static int sprint_indirect_address (disassemble_info *,char [],
                                    unsigned short);
static int sprint_direct_address (disassemble_info *,char [],
                                  unsigned short);
static int sprint_mmr (disassemble_info *,char [],int);
static int sprint_condition (disassemble_info *,char *,unsigned short);
static int sprint_cc2 (disassemble_info *,char *,unsigned short);

int
print_insn_tic54x (bfd_vma memaddr, disassemble_info *info)
{
  bfd_byte opbuf[2];
  unsigned short opcode;
  int status, size;
  const insn_template* tm;

  status = (*info->read_memory_func) (memaddr, opbuf, 2, info);
  if (status != 0)
  {
    (*info->memory_error_func) (status, memaddr, info);
    return -1;
  }

  opcode = bfd_getl16 (opbuf);
  tm = tic54x_get_insn (info, memaddr, opcode, &size);

  info->bytes_per_line = 2;
  info->bytes_per_chunk = 2;
  info->octets_per_byte = 2;
  info->display_endian = BFD_ENDIAN_LITTLE;

  if (tm->flags & FL_PAR)
  {
    if (!print_parallel_instruction (info, memaddr, opcode, tm, size))
      return -1;
  }
  else
  {
    if (!print_instruction (info, memaddr, opcode,
                            (char *) tm->name,
                            tm->operand_types,
                            size, (tm->flags & FL_EXT)))
      return -1;
  }

  return size * 2;
}

static int
has_lkaddr (unsigned short memdata, const insn_template *tm)
{
  return (IS_LKADDR (memdata)
	  && (OPTYPE (tm->operand_types[0]) == OP_Smem
	      || OPTYPE (tm->operand_types[1]) == OP_Smem
	      || OPTYPE (tm->operand_types[2]) == OP_Smem
	      || OPTYPE (tm->operand_types[1]) == OP_Sind
              || OPTYPE (tm->operand_types[0]) == OP_Lmem
              || OPTYPE (tm->operand_types[1]) == OP_Lmem));
}

/* always returns 1 (whether an insn template was found) since we provide an
   "unknown instruction" template */
const insn_template*
tic54x_get_insn (disassemble_info *info, bfd_vma addr,
                 unsigned short memdata, int *size)
{
  const insn_template *tm = NULL;

  for (tm = tic54x_optab; tm->name; tm++)
  {
    if (tm->opcode == (memdata & tm->mask))
    {
      /* a few opcodes span two words */
      if (tm->flags & FL_EXT)
        {
          /* if lk addressing is used, the second half of the opcode gets
             pushed one word later */
          bfd_byte opbuf[2];
          bfd_vma addr2 = addr + 1 + has_lkaddr (memdata, tm);
          int status = (*info->read_memory_func) (addr2, opbuf, 2, info);
          // FIXME handle errors
          if (status == 0)
            {
              unsigned short data2 = bfd_getl16 (opbuf);
              if (tm->opcode2 == (data2 & tm->mask2))
                {
                  if (size) *size = get_insn_size (memdata, tm);
                  return tm;
                }
            }
        }
      else
        {
          if (size) *size = get_insn_size (memdata, tm);
          return tm;
        }
    }
  }
  for (tm = (insn_template *) tic54x_paroptab; tm->name; tm++)
  {
    if (tm->opcode == (memdata & tm->mask))
    {
      if (size) *size = get_insn_size (memdata, tm);
      return tm;
    }
  }

  if (size) *size = 1;
  return &tic54x_unknown_opcode;
}

static int
get_insn_size (unsigned short memdata, const insn_template *insn)
{
  int size;

  if (insn->flags & FL_PAR)
    {
      /* only non-parallel instructions support lk addressing */
      size = insn->words;
    }
  else
    {
      size = insn->words + has_lkaddr (memdata, insn);
    }

  return size;
}

int
print_instruction (disassemble_info *info,
		   bfd_vma memaddr,
		   unsigned short opcode,
		   const char *tm_name,
		   const enum optype tm_operands[],
		   int size,
		   int ext)
{
  static int n;
  /* string storage for multiple operands */
  char operand[4][64] = { {0},{0},{0},{0}, };
  bfd_byte buf[2];
  unsigned long opcode2 = 0;
  unsigned long lkaddr = 0;
  enum optype src = OP_None;
  enum optype dst = OP_None;
  int i, shift;
  char *comma = "";

  info->fprintf_func (info->stream, "%-7s", tm_name);

  if (size > 1)
    {
      int status = (*info->read_memory_func) (memaddr + 1, buf, 2, info);
      if (status != 0)
        return 0;
      lkaddr = opcode2 = bfd_getl16 (buf);
      if (size > 2)
        {
          status = (*info->read_memory_func) (memaddr + 2, buf, 2, info);
          if (status != 0)
            return 0;
          opcode2 = bfd_getl16 (buf);
        }
    }

  for (i = 0; i < MAX_OPERANDS && OPTYPE (tm_operands[i]) != OP_None; i++)
    {
      char *next_comma = ",";
      int optional = (tm_operands[i] & OPT) != 0;

      switch (OPTYPE (tm_operands[i]))
        {
        case OP_Xmem:
          sprint_dual_address (info, operand[i], XMEM (opcode));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_Ymem:
          sprint_dual_address (info, operand[i], YMEM (opcode));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_Smem:
        case OP_Sind:
        case OP_Lmem:
          info->fprintf_func (info->stream, "%s", comma);
          if (INDIRECT (opcode))
            {
              if (MOD (opcode) >= 12)
                {
                  bfd_vma addr = lkaddr;
                  int arf = ARF (opcode);
                  int mod = MOD (opcode);
                  if (mod == 15)
                      info->fprintf_func (info->stream, "*(");
                  else
                      info->fprintf_func (info->stream, "*%sar%d(",
                                          (mod == 13 || mod == 14 ? "+" : ""),
                                          arf);
                  (*(info->print_address_func)) ((bfd_vma) addr, info);
                  info->fprintf_func (info->stream, ")%s",
                                      mod == 14 ? "%" : "");
                }
              else
                {
                  sprint_indirect_address (info, operand[i], opcode);
                  info->fprintf_func (info->stream, "%s", operand[i]);
                }
            }
          else
          {
            /* FIXME -- use labels (print_address_func) */
            /* in order to do this, we need to guess what DP is */
            sprint_direct_address (info, operand[i], opcode);
            info->fprintf_func (info->stream, "%s", operand[i]);
          }
          break;
        case OP_dmad:
          info->fprintf_func (info->stream, "%s", comma);
          (*(info->print_address_func)) ((bfd_vma) opcode2, info);
          break;
        case OP_xpmad:
          /* upper 7 bits of address are in the opcode */
          opcode2 += ((unsigned long) opcode & 0x7F) << 16;
          /* fall through */
        case OP_pmad:
          info->fprintf_func (info->stream, "%s", comma);
          (*(info->print_address_func)) ((bfd_vma) opcode2, info);
          break;
        case OP_MMRX:
          sprint_mmr (info, operand[i], MMRX (opcode));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_MMRY:
          sprint_mmr (info, operand[i], MMRY (opcode));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_MMR:
          sprint_mmr (info, operand[i], MMR (opcode));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_PA:
          sprintf (operand[i], "pa%d", (unsigned) opcode2);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_SRC:
          src = SRC (ext ? opcode2 : opcode) ? OP_B : OP_A;
          sprintf (operand[i], (src == OP_B) ? "b" : "a");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_SRC1:
          src = SRC1 (ext ? opcode2 : opcode) ? OP_B : OP_A;
          sprintf (operand[i], (src == OP_B) ? "b" : "a");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_RND:
          dst = DST (opcode) ? OP_B : OP_A;
          sprintf (operand[i], (dst == OP_B) ? "a" : "b");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_DST:
          dst = DST (ext ? opcode2 : opcode) ? OP_B : OP_A;
          if (!optional || dst != src)
            {
              sprintf (operand[i], (dst == OP_B) ? "b" : "a");
              info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
            }
          else
            next_comma = comma;
          break;
        case OP_B:
          sprintf (operand[i], "b");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_A:
          sprintf (operand[i], "a");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_ARX:
          sprintf (operand[i], "ar%d", (int) ARX (opcode));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_SHIFT:
          shift = SHIFT (ext ? opcode2 : opcode);
          if (!optional || shift != 0)
            {
              sprintf (operand[i], "%d", shift);
              info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
            }
          else
            next_comma = comma;
          break;
        case OP_SHFT:
          shift = SHFT (opcode);
          if (!optional || shift != 0)
            {
              sprintf (operand[i], "%d", (unsigned) shift);
              info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
            }
          else
            next_comma = comma;
          break;
        case OP_lk:
          sprintf (operand[i], "#%d", (int) (short) opcode2);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_T:
          sprintf (operand[i], "t");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_TS:
          sprintf (operand[i], "ts");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_k8:
          sprintf (operand[i], "%d", (int) ((signed char) (opcode & 0xFF)));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_16:
          sprintf (operand[i], "16");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_ASM:
          sprintf (operand[i], "asm");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_BITC:
          sprintf (operand[i], "%d", (int) (opcode & 0xF));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_CC:
          /* put all CC operands in the same operand */
          sprint_condition (info, operand[i], opcode);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          i = MAX_OPERANDS;
          break;
        case OP_CC2:
          sprint_cc2 (info, operand[i], opcode);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_CC3:
        {
          const char *code[] = { "eq", "lt", "gt", "neq" };

	  /* Do not use sprintf with only two parameters as a
	     compiler warning could be generated in such conditions.  */
	  sprintf (operand[i], "%s", code[CC3 (opcode)]);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        }
        case OP_123:
          {
            int code = (opcode >> 8) & 0x3;
            sprintf (operand[i], "%d", (code == 0) ? 1 : (code == 2) ? 2 : 3);
            info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
            break;
          }
        case OP_k5:
          sprintf (operand[i], "#%d",
                   (int) (((signed char) opcode & 0x1F) << 3) >> 3);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_k8u:
          sprintf (operand[i], "#%d", (unsigned) (opcode & 0xFF));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_k3:
          sprintf (operand[i], "#%d", (int) (opcode & 0x7));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_lku:
          sprintf (operand[i], "#%d", (unsigned) opcode2);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_N:
          n = (opcode >> 9) & 0x1;
          sprintf (operand[i], "st%d", n);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_SBIT:
        {
          const char *status0[] = {
            "0", "1", "2", "3", "4", "5", "6", "7", "8",
            "ovb", "ova", "c", "tc", "13", "14", "15"
          };
          const char *status1[] = {
            "0", "1", "2", "3", "4",
            "cmpt", "frct", "c16", "sxm", "ovm", "10",
            "intm", "hm", "xf", "cpl", "braf"
          };
          sprintf (operand[i], "%s",
                   n ? status1[SBIT (opcode)] : status0[SBIT (opcode)]);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        }
        case OP_12:
          sprintf (operand[i], "%d", (int) ((opcode >> 9) & 1) + 1);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_TRN:
          sprintf (operand[i], "trn");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_DP:
          sprintf (operand[i], "dp");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_k9:
          /* FIXME-- this is DP, print the original address? */
          sprintf (operand[i], "#%d", (int) (opcode & 0x1FF));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_ARP:
          sprintf (operand[i], "arp");
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        case OP_031:
          sprintf (operand[i], "%d", (int) (opcode & 0x1F));
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        default:
          sprintf (operand[i], "??? (0x%x)", tm_operands[i]);
          info->fprintf_func (info->stream, "%s%s", comma, operand[i]);
          break;
        }
      comma = next_comma;
    }
  return 1;
}

static int
print_parallel_instruction (disassemble_info *info,
			    bfd_vma memaddr,
			    unsigned short opcode,
			    const insn_template *ptm,
			    int size)
{
  print_instruction (info, memaddr, opcode,
                     ptm->name, ptm->operand_types, size, 0);
  info->fprintf_func (info->stream, " || ");
  return print_instruction (info, memaddr, opcode,
                            ptm->parname, ptm->paroperand_types, size, 0);
}

static int
sprint_dual_address (disassemble_info *info ATTRIBUTE_UNUSED,
		     char buf[],
		     unsigned short code)
{
  const char *formats[] = {
    "*ar%d",
    "*ar%d-",
    "*ar%d+",
    "*ar%d+0%%",
  };
  return sprintf (buf, formats[XMOD (code)], XARX (code));
}

static int
sprint_indirect_address (disassemble_info *info ATTRIBUTE_UNUSED,
			 char buf[],
			 unsigned short opcode)
{
  const char *formats[] = {
    "*ar%d",
    "*ar%d-",
    "*ar%d+",
    "*+ar%d",
    "*ar%d-0B",
    "*ar%d-0",
    "*ar%d+0",
    "*ar%d+0B",
    "*ar%d-%%",
    "*ar%d-0%%",
    "*ar%d+%%",
    "*ar%d+0%%",
  };
  return sprintf (buf, formats[MOD (opcode)], ARF (opcode));
}

static int
sprint_direct_address (disassemble_info *info ATTRIBUTE_UNUSED,
		       char buf[],
		       unsigned short opcode)
{
  /* FIXME -- look up relocation if available */
  return sprintf (buf, "DP+0x%02x", (int) (opcode & 0x7F));
}

static int
sprint_mmr (disassemble_info *info ATTRIBUTE_UNUSED,
	    char buf[],
	    int mmr)
{
  symbol *reg = (symbol *) mmregs;
  while (reg->name != NULL)
    {
      if (mmr == reg->value)
        {
          sprintf (buf, "%s", (reg + 1)->name);
          return 1;
        }
      ++reg;
    }
  sprintf (buf, "MMR(%d)", mmr); /* FIXME -- different targets.  */
  return 0;
}

static int
sprint_cc2 (disassemble_info *info ATTRIBUTE_UNUSED,
	    char *buf,
	    unsigned short opcode)
{
  const char *cc2[] = {
    "??", "??", "ageq", "alt", "aneq", "aeq", "agt", "aleq",
    "??", "??", "bgeq", "blt", "bneq", "beq", "bgt", "bleq",
  };
  return sprintf (buf, "%s", cc2[opcode & 0xF]);
}

static int
sprint_condition (disassemble_info *info ATTRIBUTE_UNUSED,
		  char *buf,
		  unsigned short opcode)
{
  char *start = buf;
  const char *cmp[] = {
      "??", "??", "geq", "lt", "neq", "eq", "gt", "leq"
  };
  if (opcode & 0x40)
    {
      char acc = (opcode & 0x8) ? 'b' : 'a';
      if (opcode & 0x7)
          buf += sprintf (buf, "%c%s%s", acc, cmp[(opcode & 0x7)],
                          (opcode & 0x20) ? ", " : "");
      if (opcode & 0x20)
          buf += sprintf (buf, "%c%s", acc, (opcode & 0x10) ? "ov" : "nov");
    }
  else if (opcode & 0x3F)
    {
      if (opcode & 0x30)
        buf += sprintf (buf, "%s%s",
                        ((opcode & 0x30) == 0x30) ? "tc" : "ntc",
                        (opcode & 0x0F) ? ", " : "");
      if (opcode & 0x0C)
        buf += sprintf (buf, "%s%s",
                        ((opcode & 0x0C) == 0x0C) ? "c" : "nc",
                        (opcode & 0x03) ? ", " : "");
      if (opcode & 0x03)
        buf += sprintf (buf, "%s",
                        ((opcode & 0x03) == 0x03) ? "bio" : "nbio");
    }
  else
    buf += sprintf (buf, "unc");

  return buf - start;
}
@


1.14
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d171 7
a177 8
print_instruction (info, memaddr, opcode, tm_name, tm_operands, size, ext)
  disassemble_info *info;
  bfd_vma memaddr;
  unsigned short opcode;
  const char *tm_name;
  const enum optype tm_operands[];
  int size;
  int ext;
d471 5
a475 6
print_parallel_instruction (info, memaddr, opcode, ptm, size)
  disassemble_info *info;
  bfd_vma memaddr;
  unsigned short opcode;
  const insn_template *ptm;
  int size;
d485 3
a487 4
sprint_dual_address (info, buf, code)
  disassemble_info *info ATTRIBUTE_UNUSED;
  char buf[];
  unsigned short code;
d499 3
a501 4
sprint_indirect_address (info, buf, opcode)
  disassemble_info *info ATTRIBUTE_UNUSED;
  char buf[];
  unsigned short opcode;
d521 3
a523 4
sprint_direct_address (info, buf, opcode)
  disassemble_info *info ATTRIBUTE_UNUSED;
  char buf[];
  unsigned short opcode;
d530 3
a532 4
sprint_mmr (info, buf, mmr)
  disassemble_info *info ATTRIBUTE_UNUSED;
  char buf[];
  int mmr;
d549 3
a551 4
sprint_cc2 (info, buf, opcode)
  disassemble_info *info ATTRIBUTE_UNUSED;
  char *buf;
  unsigned short opcode;
d561 3
a563 4
sprint_condition (info, buf, opcode)
  disassemble_info *info ATTRIBUTE_UNUSED;
  char *buf;
  unsigned short opcode;
@


1.13
log
@update copyright dates
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2005, 2007, 2009 Free Software Foundation, Inc.
d23 1
a26 1
#include "sysdep.h"
@


1.12
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2007 Free Software Foundation, Inc.
@


1.11
log
@        * fr30-opc.c: Regenerate.
        * frv-opc.c: Regenerate.
        * ip2k-opc.c: Regenerate.
        * iq2000-opc.c: Regenerate.
        * lm32-opc.c: Regenerate.
        * m32c-opc.c: Regenerate.
        * m32r-opc.c: Regenerate.
        * mep-opc.c: Regenerate.
        * mt-opc.c: Regenerate.
        * xc16x-opc.c: Regenerate.
        * xstormy16-opc.c: Regenerate.
        * tic54x-dis.c (print_instruction): Avoid compiler warning on
        sprintf call.

        * opc-itab.scm (<>_cgen_init_opcode_table): Avoid compiler warning
        about calling memset with a zero length.
@
text
@d30 2
a31 2
static int has_lkaddr (unsigned short, const template *);
static int get_insn_size (unsigned short, const template *);
d36 2
a37 2
                                       unsigned short, 
                                       const template *, int);
d54 1
a54 1
  const template* tm;
d89 1
a89 1
has_lkaddr (unsigned short memdata, const template *tm)
d102 2
a103 2
const template*
tic54x_get_insn (disassemble_info *info, bfd_vma addr, 
d106 1
a106 1
  const template *tm = NULL;
d138 1
a138 1
  for (tm = (template *) tic54x_paroptab; tm->name; tm++)
d152 1
a152 1
get_insn_size (unsigned short memdata, const template *insn)
d475 1
a475 1
  const template *ptm;
@


1.10
log
@Change source files over to GPLv3.
@
text
@d383 4
a386 1
          sprintf (operand[i], code[CC3 (opcode)]);
@


1.9
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d5 3
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d18 3
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */
@


1.8
log
@Fix tic54x testsuite failures and Lmem disassembly bugs.
@
text
@d17 2
a18 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.7
log
@Fix compile time warnings
@
text
@d28 8
a35 16
typedef struct _instruction {
  int parallel;
  template *tm;
  partemplate *ptm;
} instruction;

static int has_lkaddr PARAMS ((unsigned short, template *));
static int get_insn_size PARAMS ((unsigned short, instruction *));
static int get_instruction PARAMS ((disassemble_info *, bfd_vma,
                                    unsigned short, instruction *));
static int print_instruction PARAMS ((disassemble_info *, bfd_vma,
                                      unsigned short, char *,
                                      enum optype [], int, int));
static int print_parallel_instruction PARAMS ((disassemble_info *, bfd_vma,
                                               unsigned short, partemplate *,
                                               int));
d47 1
a47 3
print_insn_tic54x (memaddr, info)
  bfd_vma memaddr;
  disassemble_info *info;
d52 1
a52 1
  instruction insn;
d62 1
a62 2
  if (!get_instruction (info, memaddr, opcode, &insn))
      return -1;
a63 1
  size = get_insn_size (opcode, &insn);
d69 1
a69 1
  if (insn.parallel)
d71 1
a71 1
    if (!print_parallel_instruction (info, memaddr, opcode, insn.ptm, size))
d77 3
a79 3
                            (char *) insn.tm->name,
                            insn.tm->operand_types,
                            size, (insn.tm->flags & FL_EXT)))
d87 1
a87 3
has_lkaddr (opcode, tm)
  unsigned short opcode;
  template *tm;
d89 1
a89 1
  return (IS_LKADDR (opcode)
d93 3
a95 1
	      || OPTYPE (tm->operand_types[1]) == OP_Sind));
d100 3
a102 6
static int
get_instruction (info, addr, opcode, insn)
  disassemble_info *info;
  bfd_vma addr;
  unsigned short opcode;
  instruction *insn;
d104 1
a104 2
  template * tm;
  partemplate * ptm;
d106 1
a106 2
  insn->parallel = 0;
  for (tm = (template *) tic54x_optab; tm->name; tm++)
d108 1
a108 1
    if (tm->opcode == (opcode & tm->mask))
d116 1
a116 1
          bfd_vma addr2 = addr + 1 + has_lkaddr (opcode, tm);
d118 1
d121 2
a122 2
              unsigned short opcode2 = bfd_getl16 (opbuf);
              if (tm->opcode2 == (opcode2 & tm->mask2))
d124 2
a125 2
                  insn->tm = tm;
                  return 1;
d131 2
a132 2
          insn->tm = tm;
          return 1;
d136 1
a136 1
  for (ptm = (partemplate *) tic54x_paroptab; ptm->name; ptm++)
d138 1
a138 1
    if (ptm->opcode == (opcode & ptm->mask))
d140 2
a141 3
      insn->parallel = 1;
      insn->ptm = ptm;
      return 1;
d145 2
a146 2
  insn->tm = (template *) &tic54x_unknown_opcode;
  return 1;
d150 1
a150 3
get_insn_size (opcode, insn)
  unsigned short opcode;
  instruction *insn;
d154 1
a154 1
  if (insn->parallel)
d157 1
a157 1
      size = insn->ptm->words;
d161 1
a161 1
      size = insn->tm->words + has_lkaddr (opcode, insn->tm);
d172 2
a173 2
  char *tm_name;
  enum optype tm_operands[];
d470 1
a470 1
  partemplate *ptm;
d525 1
a525 1
  return sprintf (buf, "0x??%02x", (int) (opcode & 0x7F));
@


1.6
log
@For include/opcode:
	* d30v.h: Fix declaration of reg_name_cnt.

	* d10v.h: Fix declaration of d10v_reg_name_cnt.

	* arc.h: Add prototypes from opcodes/arc-opc.c.

For opcodes:
	* tic54x-dis.c: Add unused attributes where needed.

	* z8k-dis.c (output_instr): Add unused attribute.

	* h8300-dis.c: Add missing prototypes.
	(bfd_h8_disassemble): Make static.

	* cris-dis.c: Add missing prototype.
	* h8500-dis.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* z8k-dis.c: Likewise.

	* d10v-dis.c: Add missing prototype.
	(dis_long): Remove unused variable.
	(dis_2_short): Likewise.

	* sh-dis.c: Add missing prototypes.
	* v850-opc.c: Likewise.
	Add unused attributes where needed.

	* ns32k-dis.c: Add missing prototypes.
	(bit_extract_simple): Remove unused variable.
@
text
@d200 2
a201 1
  unsigned long opcode2, lkaddr;
@


1.5
log
@	* alpha-dis.c: Fix formatting.
	* cris-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d34 1
d36 1
a36 1
static int get_instruction PARAMS ((disassemble_info *, bfd_vma, 
d38 2
a39 2
static int print_instruction PARAMS ((disassemble_info *, bfd_vma, 
                                      unsigned short, char *, 
d43 2
a44 2
                                               int)); 
static int sprint_dual_address (disassemble_info *,char [], 
d46 1
a46 1
static int sprint_indirect_address (disassemble_info *,char [], 
d48 1
a48 1
static int sprint_direct_address (disassemble_info *,char [], 
d59 1
a59 1
  bfd_byte opbuf[2]; 
d88 2
a89 2
    if (!print_instruction (info, memaddr, opcode, 
                            (char *) insn.tm->name, 
d112 1
a112 1
static int 
d166 1
a166 1
static int 
d252 1
a252 1
                      info->fprintf_func (info->stream, "*%sar%d(", 
d256 1
a256 1
                  info->fprintf_func (info->stream, ")%s", 
d411 1
a411 1
          sprintf (operand[i], "#%d", 
d435 1
a435 1
            "0", "1", "2", "3", "4", "5", "6", "7", "8", 
d439 1
a439 1
            "0", "1", "2", "3", "4", 
d443 1
a443 1
          sprintf (operand[i], "%s", 
d491 1
a491 1
  print_instruction (info, memaddr, opcode, 
d494 1
a494 1
  return print_instruction (info, memaddr, opcode, 
d500 1
a500 1
  disassemble_info *info;
d515 1
a515 1
  disassemble_info *info;
d538 1
a538 1
  disassemble_info *info;
d548 1
a548 1
  disassemble_info *info;
d568 1
a568 1
  disassemble_info *info;
d581 1
a581 1
  disassemble_info *info;
d601 1
a601 1
        buf += sprintf (buf, "%s%s", 
d605 1
a605 1
        buf += sprintf (buf, "%s%s", 
d609 1
a609 1
        buf += sprintf (buf, "%s", 
@


1.4
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d54 1
a54 1
print_insn_tic54x(memaddr, info)
d66 1
a66 1
    (*info->memory_error_func)(status, memaddr, info);
d70 1
a70 1
  opcode = bfd_getl16(opbuf);
d88 1
a88 1
                            (char *)insn.tm->name, 
d94 1
a94 1
  return size*2;
d98 1
a98 1
has_lkaddr(opcode, tm)
d102 5
a106 5
  return IS_LKADDR(opcode) && 
    (OPTYPE(tm->operand_types[0]) == OP_Smem ||
     OPTYPE(tm->operand_types[1]) == OP_Smem ||
     OPTYPE(tm->operand_types[2]) == OP_Smem ||
     OPTYPE(tm->operand_types[1]) == OP_Sind);
d122 1
a122 1
  for (tm = (template *)tic54x_optab; tm->name; tm++)
d132 2
a133 2
          bfd_vma addr2 = addr + 1 + has_lkaddr(opcode, tm);
          int status = (*info->read_memory_func)(addr2, opbuf, 2, info);
d136 1
a136 1
              unsigned short opcode2 = bfd_getl16(opbuf);
d151 1
a151 1
  for (ptm = (partemplate *)tic54x_paroptab; ptm->name; ptm++)
d161 1
a161 1
  insn->tm = (template *)&tic54x_unknown_opcode;
d179 1
a179 1
      size = insn->tm->words + has_lkaddr(opcode, insn->tm);
d209 1
a209 1
      int status = (*info->read_memory_func) (memaddr+1, buf, 2, info);
d212 1
a212 1
      lkaddr = opcode2 = bfd_getl16(buf);
d215 1
a215 1
          status = (*info->read_memory_func) (memaddr+2, buf, 2, info);
d218 1
a218 1
          opcode2 = bfd_getl16(buf);
d222 1
a222 1
  for (i=0;i < MAX_OPERANDS && OPTYPE(tm_operands[i]) != OP_None;i++)
d227 1
a227 1
      switch (OPTYPE(tm_operands[i]))
d230 1
a230 1
          sprint_dual_address (info, operand[i], XMEM(opcode));
d234 1
a234 1
          sprint_dual_address (info, operand[i], YMEM(opcode));
d241 1
a241 1
          if (INDIRECT(opcode))
d243 1
a243 1
              if (MOD(opcode) >= 12)
d246 2
a247 2
                  int arf = ARF(opcode);
                  int mod = MOD(opcode);
d254 1
a254 1
                  (*(info->print_address_func))((bfd_vma)addr, info);
d274 1
a274 1
          (*(info->print_address_func))((bfd_vma)opcode2, info);
d278 1
a278 1
          opcode2 += ((unsigned long)opcode & 0x7F) << 16;
d282 1
a282 1
          (*(info->print_address_func))((bfd_vma)opcode2, info);
d285 1
a285 1
          sprint_mmr (info, operand[i], MMRX(opcode));
d289 1
a289 1
          sprint_mmr (info, operand[i], MMRY(opcode));
d293 1
a293 1
          sprint_mmr (info, operand[i], MMR(opcode));
d297 1
a297 1
          sprintf (operand[i], "pa%d", (unsigned)opcode2);
d301 1
a301 1
          src = SRC(ext ? opcode2 : opcode) ? OP_B : OP_A;
d306 1
a306 1
          src = SRC1(ext ? opcode2 : opcode) ? OP_B : OP_A;
d311 1
a311 1
          dst = DST(opcode) ? OP_B : OP_A;
d316 1
a316 1
          dst = DST(ext ? opcode2 : opcode) ? OP_B : OP_A;
d334 1
a334 1
          sprintf (operand[i],"ar%d", (int)ARX(opcode));
d338 1
a338 1
          shift = SHIFT(ext ? opcode2 : opcode);
d341 1
a341 1
              sprintf (operand[i],"%d", shift);
d348 1
a348 1
          shift = SHFT(opcode);
d351 1
a351 1
              sprintf (operand[i],"%d", (unsigned)shift);
d358 1
a358 1
          sprintf (operand[i],"#%d", (int)(short)opcode2);
d370 1
a370 1
          sprintf (operand[i], "%d", (int)((signed char)(opcode & 0xFF)));
d382 1
a382 1
          sprintf (operand[i], "%d", (int)(opcode & 0xF));
d398 1
a398 1
          sprintf (operand[i], code[CC3(opcode)]);
d404 1
a404 1
            int code = (opcode>>8) & 0x3;
d411 1
a411 1
                   (int)(((signed char)opcode & 0x1F) << 3)>>3);
d415 1
a415 1
          sprintf (operand[i], "#%d", (unsigned)(opcode & 0xFF));
d419 1
a419 1
          sprintf (operand[i], "#%d", (int)(opcode & 0x7));
d423 1
a423 1
          sprintf (operand[i], "#%d", (unsigned)opcode2);
d443 1
a443 1
                   n ? status1[SBIT(opcode)] : status0[SBIT(opcode)]);
d448 1
a448 1
          sprintf (operand[i], "%d", (int)((opcode >> 9)&1) + 1);
d461 1
a461 1
          sprintf (operand[i], "#%d", (int)(opcode & 0x1FF));
d469 1
a469 1
          sprintf (operand[i], "%d", (int)(opcode & 0x1F));
d509 1
a509 1
  return sprintf (buf, formats[XMOD(code)], XARX(code));
d532 1
a532 1
  return sprintf (buf, formats[MOD(opcode)], ARF(opcode));
d542 1
a542 1
  return sprintf (buf, "0x??%02x", (int)(opcode & 0x7F));
d551 1
a551 1
  symbol *reg = (symbol *)mmregs;
d556 1
a556 1
          sprintf (buf, "%s", (reg+1)->name);
d592 2
a593 2
          buf += sprintf (buf, "%c%s%s", acc, cmp[(opcode&0x7)],
                          (opcode&0x20) ? ", " : "");
d595 1
a595 1
          buf += sprintf (buf, "%c%s", acc, (opcode&0x10) ? "ov" : "nov");
@


1.3
log
@2000-10-04  Kazu Hirata  <kazu@@hxi.com>

	* ia64-gen.c: Convert C++-style comments to C-style comments.
	* tic54x-dis.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1999,2000 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.2
log
@Replace defines with those from intl/libgettext.h to quieten gcc warnings.
@
text
@d561 1
a561 1
  sprintf (buf, "MMR(%d)", mmr); // FIXME -- different targets
@


1.1
log
@Support for tic54x target.
@
text
@d23 1
a23 1
#include <string.h>
@

