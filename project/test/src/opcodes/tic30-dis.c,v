head	1.13;
access;
symbols
	sid-snapshot-20180601:1.13
	sid-snapshot-20180501:1.13
	sid-snapshot-20180401:1.13
	sid-snapshot-20180301:1.13
	sid-snapshot-20180201:1.13
	sid-snapshot-20180101:1.13
	sid-snapshot-20171201:1.13
	sid-snapshot-20171101:1.13
	sid-snapshot-20171001:1.13
	sid-snapshot-20170901:1.13
	sid-snapshot-20170801:1.13
	sid-snapshot-20170701:1.13
	sid-snapshot-20170601:1.13
	sid-snapshot-20170501:1.13
	sid-snapshot-20170401:1.13
	sid-snapshot-20170301:1.13
	sid-snapshot-20170201:1.13
	sid-snapshot-20170101:1.13
	sid-snapshot-20161201:1.13
	sid-snapshot-20161101:1.13
	sid-snapshot-20160901:1.13
	sid-snapshot-20160801:1.13
	sid-snapshot-20160701:1.13
	sid-snapshot-20160601:1.13
	sid-snapshot-20160501:1.13
	sid-snapshot-20160401:1.13
	sid-snapshot-20160301:1.13
	sid-snapshot-20160201:1.13
	sid-snapshot-20160101:1.13
	sid-snapshot-20151201:1.13
	sid-snapshot-20151101:1.13
	sid-snapshot-20151001:1.13
	sid-snapshot-20150901:1.13
	sid-snapshot-20150801:1.13
	sid-snapshot-20150701:1.13
	sid-snapshot-20150601:1.13
	sid-snapshot-20150501:1.13
	sid-snapshot-20150401:1.13
	sid-snapshot-20150301:1.13
	sid-snapshot-20150201:1.13
	sid-snapshot-20150101:1.13
	sid-snapshot-20141201:1.13
	sid-snapshot-20141101:1.13
	sid-snapshot-20141001:1.13
	sid-snapshot-20140901:1.13
	sid-snapshot-20140801:1.13
	sid-snapshot-20140701:1.13
	sid-snapshot-20140601:1.13
	sid-snapshot-20140501:1.13
	sid-snapshot-20140401:1.13
	sid-snapshot-20140301:1.13
	sid-snapshot-20140201:1.13
	sid-snapshot-20140101:1.13
	sid-snapshot-20131201:1.13
	sid-snapshot-20131101:1.13
	sid-snapshot-20131001:1.13
	binutils-2_24-branch:1.13.0.8
	binutils-2_24-branchpoint:1.13
	binutils-2_21_1:1.12
	sid-snapshot-20130901:1.13
	gdb_7_6_1-2013-08-30-release:1.13
	sid-snapshot-20130801:1.13
	sid-snapshot-20130701:1.13
	sid-snapshot-20130601:1.13
	sid-snapshot-20130501:1.13
	gdb_7_6-2013-04-26-release:1.13
	sid-snapshot-20130401:1.13
	binutils-2_23_2:1.13
	gdb_7_6-branch:1.13.0.6
	gdb_7_6-2013-03-12-branchpoint:1.13
	sid-snapshot-20130301:1.13
	sid-snapshot-20130201:1.13
	sid-snapshot-20130101:1.13
	sid-snapshot-20121201:1.13
	gdb_7_5_1-2012-11-29-release:1.13
	binutils-2_23_1:1.13
	sid-snapshot-20121101:1.13
	binutils-2_23:1.13
	sid-snapshot-20121001:1.13
	sid-snapshot-20120901:1.13
	gdb_7_5-2012-08-17-release:1.13
	sid-snapshot-20120801:1.13
	binutils-2_23-branch:1.13.0.4
	binutils-2_23-branchpoint:1.13
	gdb_7_5-branch:1.13.0.2
	gdb_7_5-2012-07-18-branchpoint:1.13
	sid-snapshot-20120701:1.13
	sid-snapshot-20120601:1.13
	sid-snapshot-20120501:1.12
	binutils-2_22_branch:1.12.0.14
	gdb_7_4_1-2012-04-26-release:1.12
	sid-snapshot-20120401:1.12
	sid-snapshot-20120301:1.12
	sid-snapshot-20120201:1.12
	gdb_7_4-2012-01-24-release:1.12
	sid-snapshot-20120101:1.12
	gdb_7_4-branch:1.12.0.12
	gdb_7_4-2011-12-13-branchpoint:1.12
	sid-snapshot-20111201:1.12
	binutils-2_22:1.12
	sid-snapshot-20111101:1.12
	sid-snapshot-20111001:1.12
	binutils-2_22-branch:1.12.0.10
	binutils-2_22-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.12
	sid-snapshot-20110901:1.12
	sid-snapshot-20110801:1.12
	gdb_7_3-2011-07-26-release:1.12
	sid-snapshot-20110701:1.12
	sid-snapshot-20110601:1.12
	sid-snapshot-20110501:1.12
	gdb_7_3-branch:1.12.0.8
	gdb_7_3-2011-04-01-branchpoint:1.12
	sid-snapshot-20110401:1.12
	sid-snapshot-20110301:1.12
	sid-snapshot-20110201:1.12
	sid-snapshot-20110101:1.12
	binutils-2_21:1.12
	sid-snapshot-20101201:1.12
	binutils-2_21-branch:1.12.0.6
	binutils-2_21-branchpoint:1.12
	sid-snapshot-20101101:1.12
	sid-snapshot-20101001:1.12
	binutils-2_20_1:1.11
	gdb_7_2-2010-09-02-release:1.12
	sid-snapshot-20100901:1.12
	sid-snapshot-20100801:1.12
	gdb_7_2-branch:1.12.0.4
	gdb_7_2-2010-07-07-branchpoint:1.12
	sid-snapshot-20100701:1.12
	sid-snapshot-20100601:1.12
	sid-snapshot-20100501:1.12
	sid-snapshot-20100401:1.12
	gdb_7_1-2010-03-18-release:1.12
	sid-snapshot-20100301:1.12
	gdb_7_1-branch:1.12.0.2
	gdb_7_1-2010-02-18-branchpoint:1.12
	sid-snapshot-20100201:1.12
	sid-snapshot-20100101:1.12
	gdb_7_0_1-2009-12-22-release:1.11
	sid-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	binutils-2_20:1.11
	gdb_7_0-2009-10-06-release:1.11
	sid-snapshot-20091001:1.11
	gdb_7_0-branch:1.11.0.4
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.9
	binutils-arc-20081103-branch:1.9.0.30
	binutils-arc-20081103-branchpoint:1.9
	binutils-2_20-branch:1.11.0.2
	binutils-2_20-branchpoint:1.11
	sid-snapshot-20090901:1.10
	sid-snapshot-20090801:1.9
	msnyder-checkpoint-072509-branch:1.9.0.28
	msnyder-checkpoint-072509-branchpoint:1.9
	sid-snapshot-20090701:1.9
	dje-cgen-play1-branch:1.9.0.26
	dje-cgen-play1-branchpoint:1.9
	sid-snapshot-20090601:1.9
	sid-snapshot-20090501:1.9
	sid-snapshot-20090401:1.9
	arc-20081103-branch:1.9.0.24
	arc-20081103-branchpoint:1.9
	arc-insight_6_8-branch:1.9.0.22
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.20
	insight_6_8-branchpoint:1.9
	sid-snapshot-20090301:1.9
	binutils-2_19_1:1.9
	sid-snapshot-20090201:1.9
	sid-snapshot-20090101:1.9
	reverse-20081226-branch:1.9.0.18
	reverse-20081226-branchpoint:1.9
	sid-snapshot-20081201:1.9
	multiprocess-20081120-branch:1.9.0.16
	multiprocess-20081120-branchpoint:1.9
	sid-snapshot-20081101:1.9
	binutils-2_19:1.9
	sid-snapshot-20081001:1.9
	reverse-20080930-branch:1.9.0.14
	reverse-20080930-branchpoint:1.9
	binutils-2_19-branch:1.9.0.12
	binutils-2_19-branchpoint:1.9
	sid-snapshot-20080901:1.9
	sid-snapshot-20080801:1.9
	reverse-20080717-branch:1.9.0.10
	reverse-20080717-branchpoint:1.9
	sid-snapshot-20080701:1.9
	msnyder-reverse-20080609-branch:1.9.0.8
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.8.0.32
	drow-reverse-20070409-branchpoint:1.8
	sid-snapshot-20080601:1.9
	sid-snapshot-20080501:1.9
	sid-snapshot-20080403:1.9
	sid-snapshot-20080401:1.9
	gdb_6_8-2008-03-27-release:1.9
	sid-snapshot-20080301:1.9
	gdb_6_8-branch:1.9.0.6
	gdb_6_8-2008-02-26-branchpoint:1.9
	sid-snapshot-20080201:1.9
	sid-snapshot-20080101:1.9
	sid-snapshot-20071201:1.9
	sid-snapshot-20071101:1.9
	gdb_6_7_1-2007-10-29-release:1.9
	gdb_6_7-2007-10-10-release:1.9
	sid-snapshot-20071001:1.9
	gdb_6_7-branch:1.9.0.4
	gdb_6_7-2007-09-07-branchpoint:1.9
	binutils-2_18:1.9
	binutils-2_18-branch:1.9.0.2
	binutils-2_18-branchpoint:1.9
	insight_6_6-20070208-release:1.8
	binutils-csl-coldfire-4_1-32:1.8
	binutils-csl-sourcerygxx-4_1-32:1.8
	gdb_6_6-2006-12-18-release:1.8
	binutils-csl-innovasic-fido-3_4_4-33:1.8
	binutils-csl-sourcerygxx-3_4_4-32:1.5
	binutils-csl-coldfire-4_1-30:1.8
	binutils-csl-sourcerygxx-4_1-30:1.8
	binutils-csl-coldfire-4_1-28:1.8
	binutils-csl-sourcerygxx-4_1-29:1.8
	binutils-csl-sourcerygxx-4_1-28:1.8
	gdb_6_6-branch:1.8.0.30
	gdb_6_6-2006-11-15-branchpoint:1.8
	binutils-csl-arm-2006q3-27:1.8
	binutils-csl-sourcerygxx-4_1-27:1.8
	binutils-csl-arm-2006q3-26:1.8
	binutils-csl-sourcerygxx-4_1-26:1.8
	binutils-csl-sourcerygxx-4_1-25:1.8
	binutils-csl-sourcerygxx-4_1-24:1.8
	binutils-csl-sourcerygxx-4_1-23:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.8
	binutils-csl-sourcerygxx-4_1-21:1.8
	binutils-csl-arm-2006q3-21:1.8
	binutils-csl-sourcerygxx-4_1-22:1.8
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.8
	binutils-csl-sourcerygxx-4_1-20:1.8
	binutils-csl-arm-2006q3-19:1.8
	binutils-csl-sourcerygxx-4_1-19:1.8
	binutils-csl-sourcerygxx-4_1-18:1.8
	binutils-csl-renesas-4_1-9:1.8
	gdb-csl-sourcerygxx-3_4_4-25:1.8
	binutils-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.8
	binutils-csl-renesas-4_1-8:1.8
	binutils-csl-renesas-4_1-7:1.8
	binutils-csl-renesas-4_1-6:1.8
	gdb-csl-sourcerygxx-4_1-17:1.8
	binutils-csl-sourcerygxx-4_1-17:1.8
	gdb-csl-20060226-branch-local-2:1.8
	gdb-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-15:1.8
	gdb-csl-sourcerygxx-4_1-13:1.8
	binutils-csl-sourcerygxx-4_1-13:1.8
	binutils-2_17:1.8
	gdb-csl-sourcerygxx-4_1-12:1.8
	binutils-csl-sourcerygxx-4_1-12:1.8
	gdb-csl-sourcerygxx-3_4_4-21:1.8
	binutils-csl-sourcerygxx-3_4_4-21:1.8
	gdb_6_5-20060621-release:1.8
	binutils-csl-wrs-linux-3_4_4-24:1.5
	binutils-csl-wrs-linux-3_4_4-23:1.5
	gdb-csl-sourcerygxx-4_1-9:1.8
	binutils-csl-sourcerygxx-4_1-9:1.8
	gdb-csl-sourcerygxx-4_1-8:1.8
	binutils-csl-sourcerygxx-4_1-8:1.8
	gdb-csl-sourcerygxx-4_1-7:1.8
	binutils-csl-sourcerygxx-4_1-7:1.8
	gdb-csl-arm-2006q1-6:1.8
	binutils-csl-arm-2006q1-6:1.8
	gdb-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-wrs-linux-3_4_4-22:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.8
	gdb-csl-symbian-6_4_50_20060226-9:1.8
	gdb-csl-symbian-6_4_50_20060226-8:1.8
	gdb-csl-coldfire-4_1-11:1.8
	binutils-csl-coldfire-4_1-11:1.8
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	binutils-csl-sourcerygxx-3_4_4-19:1.8
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.8.0.28
	gdb_6_5-2006-05-14-branchpoint:1.8
	binutils-csl-coldfire-4_1-10:1.8
	gdb-csl-sourcerygxx-4_1-5:1.8
	binutils-csl-sourcerygxx-4_1-5:1.8
	nickrob-async-20060513-branch:1.8.0.26
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.8
	binutils-csl-sourcerygxx-4_1-4:1.8
	msnyder-reverse-20060502-branch:1.8.0.24
	msnyder-reverse-20060502-branchpoint:1.8
	binutils-csl-wrs-linux-3_4_4-21:1.5
	gdb-csl-morpho-4_1-4:1.8
	binutils-csl-morpho-4_1-4:1.8
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-wrs-linux-3_4_4-20:1.5
	readline_5_1-import-branch:1.8.0.22
	readline_5_1-import-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	binutils-2_17-branch:1.8.0.20
	binutils-2_17-branchpoint:1.8
	gdb-csl-symbian-20060226-branch:1.8.0.18
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.8.0.16
	msnyder-reverse-20060331-branchpoint:1.8
	binutils-csl-2_17-branch:1.8.0.14
	binutils-csl-2_17-branchpoint:1.8
	gdb-csl-available-20060303-branch:1.8.0.12
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.10
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.8
	msnyder-fork-checkpoint-branch:1.8.0.8
	msnyder-fork-checkpoint-branchpoint:1.8
	gdb-csl-gxxpro-6_3-branch:1.8.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.8
	gdb_6_4-branch:1.8.0.4
	gdb_6_4-2005-11-01-branchpoint:1.8
	gdb-csl-arm-20051020-branch:1.8.0.2
	gdb-csl-arm-20051020-branchpoint:1.8
	binutils-csl-gxxpro-3_4-branch:1.5.0.70
	binutils-csl-gxxpro-3_4-branchpoint:1.5
	binutils-2_16_1:1.5
	msnyder-tracepoint-checkpoint-branch:1.6.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.5
	binutils-csl-arm-2005q1b:1.5
	binutils-2_16:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	binutils-csl-arm-2005q1a:1.5
	csl-arm-20050325-branch:1.5.0.68
	csl-arm-20050325-branchpoint:1.5
	binutils-csl-arm-2005q1-branch:1.5.0.66
	binutils-csl-arm-2005q1-branchpoint:1.5
	binutils-2_16-branch:1.5.0.64
	binutils-2_16-branchpoint:1.5
	csl-arm-2004-q3d:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.60
	gdb_6_3-20041019-branchpoint:1.5
	csl-arm-2004-q3:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.62
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.58
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	binutils-2_15:1.5
	binutils-2_15-branchpoint:1.5
	csl-arm-2004-q1a:1.5
	csl-arm-2004-q1:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.56
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.54
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.52
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.50
	drow_intercu-20040221-branchpoint:1.5
	binutils-2_15-branch:1.5.0.48
	cagney_bfdfile-20040213-branch:1.5.0.46
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.44
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	csl-arm-2003-q4:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.42
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.40
	cagney_x86i386-20030821-branch:1.5.0.38
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.36
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.5
	binutils-2_14:1.5
	cagney_convert-20030606-branch:1.5.0.32
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.30
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.26
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	binutils-2_14-branch:1.5.0.22
	binutils-2_14-branchpoint:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.20
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.18
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.16
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.14
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.12
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.10
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.8
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.6
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.4
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	binutils-2_13_2_1:1.4
	binutils-2_13_2:1.4
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.4
	carlton_dictionary-20021115-merge:1.4
	binutils-2_13_1:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.30
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.28
	carlton_dictionary-20020920-branchpoint:1.4
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.26
	gdb_5_3-branch:1.4.0.24
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.22
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.20
	readline_4_3-import-branchpoint:1.4
	binutils-2_13:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	binutils-2_13-branchpoint:1.4
	binutils-2_13-branch:1.4.0.18
	kseitz_interps-20020528-branch:1.4.0.16
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.14
	cagney_regbuf-20020515-branchpoint:1.4
	binutils-2_12_1:1.4
	jimb-macro-020506-branch:1.4.0.12
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	binutils-2_12:1.4
	gdb_5_2-branch:1.4.0.10
	gdb_5_2-2002-03-03-branchpoint:1.4
	binutils-2_12-branch:1.4.0.8
	binutils-2_12-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.3
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.13
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.11.13.42.17;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.29.22.11.02;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.04.17.51.36;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.01.11.16.33;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.07.07.34.31;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.02.13.13.37;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.22.58.37;	author nickc;	state Exp;
branches
	1.4.28.1
	1.4.30.1;
next	1.3;

1.3
date	2000.08.28.16.37.55;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.06.21.10.11.52;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.4.28.1
date	2002.12.23.19.39.37;	author carlton;	state Exp;
branches;
next	;

1.4.30.1
date	2003.12.14.20.28.10;	author drow;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.18.36;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches;
next	;


desc
@@


1.13
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* Disassembly routines for TMS320C30 architecture
   Copyright 1998, 1999, 2000, 2002, 2005, 2007, 2009, 2012
   Free Software Foundation, Inc.
   Contributed by Steven Haworth (steve@@pm.cse.rmit.edu.au)

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this file; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <errno.h>
#include <math.h>
#include "dis-asm.h"
#include "opcode/tic30.h"

#define NORMAL_INSN   1
#define PARALLEL_INSN 2

/* Gets the type of instruction based on the top 2 or 3 bits of the
   instruction word.  */
#define GET_TYPE(insn) (insn & 0x80000000 ? insn & 0xC0000000 : insn & 0xE0000000)

/* Instruction types.  */
#define TWO_OPERAND_1 0x00000000
#define TWO_OPERAND_2 0x40000000
#define THREE_OPERAND 0x20000000
#define PAR_STORE     0xC0000000
#define MUL_ADDS      0x80000000
#define BRANCHES      0x60000000

/* Specific instruction id bits.  */
#define NORMAL_IDEN    0x1F800000
#define PAR_STORE_IDEN 0x3E000000
#define MUL_ADD_IDEN   0x2C000000
#define BR_IMM_IDEN    0x1F000000
#define BR_COND_IDEN   0x1C3F0000

/* Addressing modes.  */
#define AM_REGISTER 0x00000000
#define AM_DIRECT   0x00200000
#define AM_INDIRECT 0x00400000
#define AM_IMM      0x00600000

#define P_FIELD 0x03000000

#define REG_AR0 0x08
#define LDP_INSN 0x08700000

/* TMS320C30 program counter for current instruction.  */
static unsigned int _pc;

struct instruction
{
  int type;
  insn_template *tm;
  partemplate *ptm;
};

static int
get_tic30_instruction (unsigned long insn_word, struct instruction *insn)
{
  switch (GET_TYPE (insn_word))
    {
    case TWO_OPERAND_1:
    case TWO_OPERAND_2:
    case THREE_OPERAND:
      insn->type = NORMAL_INSN;
      {
	insn_template *current_optab = (insn_template *) tic30_optab;

	for (; current_optab < tic30_optab_end; current_optab++)
	  {
	    if (GET_TYPE (current_optab->base_opcode) == GET_TYPE (insn_word))
	      {
		if (current_optab->operands == 0)
		  {
		    if (current_optab->base_opcode == insn_word)
		      {
			insn->tm = current_optab;
			break;
		      }
		  }
		else if ((current_optab->base_opcode & NORMAL_IDEN) == (insn_word & NORMAL_IDEN))
		  {
		    insn->tm = current_optab;
		    break;
		  }
	      }
	  }
      }
      break;

    case PAR_STORE:
      insn->type = PARALLEL_INSN;
      {
	partemplate *current_optab = (partemplate *) tic30_paroptab;

	for (; current_optab < tic30_paroptab_end; current_optab++)
	  {
	    if (GET_TYPE (current_optab->base_opcode) == GET_TYPE (insn_word))
	      {
		if ((current_optab->base_opcode & PAR_STORE_IDEN)
		    == (insn_word & PAR_STORE_IDEN))
		  {
		    insn->ptm = current_optab;
		    break;
		  }
	      }
	  }
      }
      break;

    case MUL_ADDS:
      insn->type = PARALLEL_INSN;
      {
	partemplate *current_optab = (partemplate *) tic30_paroptab;

	for (; current_optab < tic30_paroptab_end; current_optab++)
	  {
	    if (GET_TYPE (current_optab->base_opcode) == GET_TYPE (insn_word))
	      {
		if ((current_optab->base_opcode & MUL_ADD_IDEN)
		    == (insn_word & MUL_ADD_IDEN))
		  {
		    insn->ptm = current_optab;
		    break;
		  }
	      }
	  }
      }
      break;

    case BRANCHES:
      insn->type = NORMAL_INSN;
      {
	insn_template *current_optab = (insn_template *) tic30_optab;

	for (; current_optab < tic30_optab_end; current_optab++)
	  {
	    if (GET_TYPE (current_optab->base_opcode) == GET_TYPE (insn_word))
	      {
		if (current_optab->operand_types[0] & Imm24)
		  {
		    if ((current_optab->base_opcode & BR_IMM_IDEN)
			== (insn_word & BR_IMM_IDEN))
		      {
			insn->tm = current_optab;
			break;
		      }
		  }
		else if (current_optab->operands > 0)
		  {
		    if ((current_optab->base_opcode & BR_COND_IDEN)
			== (insn_word & BR_COND_IDEN))
		      {
			insn->tm = current_optab;
			break;
		      }
		  }
		else
		  {
		    if ((current_optab->base_opcode & (BR_COND_IDEN | 0x00800000))
			== (insn_word & (BR_COND_IDEN | 0x00800000)))
		      {
			insn->tm = current_optab;
			break;
		      }
		  }
	      }
	  }
      }
      break;
    default:
      return 0;
    }
  return 1;
}

static int
get_register_operand (unsigned char fragment, char *buffer)
{
  const reg *current_reg = tic30_regtab;

  if (buffer == NULL)
    return 0;
  for (; current_reg < tic30_regtab_end; current_reg++)
    {
      if ((fragment & 0x1F) == current_reg->opcode)
	{
	  strcpy (buffer, current_reg->name);
	  return 1;
	}
    }
  return 0;
}

static int
get_indirect_operand (unsigned short fragment,
		      int size,
		      char *buffer)
{
  unsigned char mod;
  unsigned arnum;
  unsigned char disp;

  if (buffer == NULL)
    return 0;
  /* Determine which bits identify the sections of the indirect
     operand based on the size in bytes.  */
  switch (size)
    {
    case 1:
      mod = (fragment & 0x00F8) >> 3;
      arnum = (fragment & 0x0007);
      disp = 0;
      break;
    case 2:
      mod = (fragment & 0xF800) >> 11;
      arnum = (fragment & 0x0700) >> 8;
      disp = (fragment & 0x00FF);
      break;
    default:
      return 0;
    }
  {
    const ind_addr_type *current_ind = tic30_indaddr_tab;

    for (; current_ind < tic30_indaddrtab_end; current_ind++)
      {
	if (current_ind->modfield == mod)
	  {
	    if (current_ind->displacement == IMPLIED_DISP && size == 2)
	      continue;

	    else
	      {
		size_t i, len;
		int bufcnt;

		len = strlen (current_ind->syntax);
		for (i = 0, bufcnt = 0; i < len; i++, bufcnt++)
		  {
		    buffer[bufcnt] = current_ind->syntax[i];
		    if (buffer[bufcnt - 1] == 'a' && buffer[bufcnt] == 'r')
		      buffer[++bufcnt] = arnum + '0';
		    if (buffer[bufcnt] == '('
			&& current_ind->displacement == DISP_REQUIRED)
		      {
			sprintf (&buffer[bufcnt + 1], "%u", disp);
			bufcnt += strlen (&buffer[bufcnt + 1]);
		      }
		  }
		buffer[bufcnt + 1] = '\0';
		break;
	      }
	  }
      }
  }
  return 1;
}

static int
cnvt_tmsfloat_ieee (unsigned long tmsfloat, int size, float *ieeefloat)
{
  unsigned long exponent, sign, mant;
  union
  {
    unsigned long l;
    float f;
  } val;

  if (size == 2)
    {
      if ((tmsfloat & 0x0000F000) == 0x00008000)
	tmsfloat = 0x80000000;
      else
	{
	  tmsfloat <<= 16;
	  tmsfloat = (long) tmsfloat >> 4;
	}
    }
  exponent = tmsfloat & 0xFF000000;
  if (exponent == 0x80000000)
    {
      *ieeefloat = 0.0;
      return 1;
    }
  exponent += 0x7F000000;
  sign = (tmsfloat & 0x00800000) << 8;
  mant = tmsfloat & 0x007FFFFF;
  if (exponent == 0xFF000000)
    {
      if (mant == 0)
	*ieeefloat = ERANGE;
#ifdef HUGE_VALF
      if (sign == 0)
	*ieeefloat = HUGE_VALF;
      else
	*ieeefloat = -HUGE_VALF;
#else
      if (sign == 0)
	*ieeefloat = 1.0 / 0.0;
      else
	*ieeefloat = -1.0 / 0.0;
#endif
      return 1;
    }
  exponent >>= 1;
  if (sign)
    {
      mant = (~mant) & 0x007FFFFF;
      mant += 1;
      exponent += mant & 0x00800000;
      exponent &= 0x7F800000;
      mant &= 0x007FFFFF;
    }
  if (tmsfloat == 0x80000000)
    sign = mant = exponent = 0;
  tmsfloat = sign | exponent | mant;
  val.l = tmsfloat;
  *ieeefloat = val.f;
  return 1;
}

static int
print_two_operand (disassemble_info *info,
		   unsigned long insn_word,
		   struct instruction *insn)
{
  char name[12];
  char operand[2][13] =
  {
    {0},
    {0}
  };
  float f_number;

  if (insn->tm == NULL)
    return 0;
  strcpy (name, insn->tm->name);
  if (insn->tm->opcode_modifier == AddressMode)
    {
      int src_op, dest_op;
      /* Determine whether instruction is a store or a normal instruction.  */
      if ((insn->tm->operand_types[1] & (Direct | Indirect))
	  == (Direct | Indirect))
	{
	  src_op = 1;
	  dest_op = 0;
	}
      else
	{
	  src_op = 0;
	  dest_op = 1;
	}
      /* Get the destination register.  */
      if (insn->tm->operands == 2)
	get_register_operand ((insn_word & 0x001F0000) >> 16, operand[dest_op]);
      /* Get the source operand based on addressing mode.  */
      switch (insn_word & AddressMode)
	{
	case AM_REGISTER:
	  /* Check for the NOP instruction before getting the operand.  */
	  if ((insn->tm->operand_types[0] & NotReq) == 0)
	    get_register_operand ((insn_word & 0x0000001F), operand[src_op]);
	  break;
	case AM_DIRECT:
	  sprintf (operand[src_op], "@@0x%lX", (insn_word & 0x0000FFFF));
	  break;
	case AM_INDIRECT:
	  get_indirect_operand ((insn_word & 0x0000FFFF), 2, operand[src_op]);
	  break;
	case AM_IMM:
	  /* Get the value of the immediate operand based on variable type.  */
	  switch (insn->tm->imm_arg_type)
	    {
	    case Imm_Float:
	      cnvt_tmsfloat_ieee ((insn_word & 0x0000FFFF), 2, &f_number);
	      sprintf (operand[src_op], "%2.2f", f_number);
	      break;
	    case Imm_SInt:
	      sprintf (operand[src_op], "%d", (short) (insn_word & 0x0000FFFF));
	      break;
	    case Imm_UInt:
	      sprintf (operand[src_op], "%lu", (insn_word & 0x0000FFFF));
	      break;
	    default:
	      return 0;
	    }
	  /* Handle special case for LDP instruction.  */
	  if ((insn_word & 0xFFFFFF00) == LDP_INSN)
	    {
	      strcpy (name, "ldp");
	      sprintf (operand[0], "0x%06lX", (insn_word & 0x000000FF) << 16);
	      operand[1][0] = '\0';
	    }
	}
    }
  /* Handle case for stack and rotate instructions.  */
  else if (insn->tm->operands == 1)
    {
      if (insn->tm->opcode_modifier == StackOp)
	get_register_operand ((insn_word & 0x001F0000) >> 16, operand[0]);
    }
  /* Output instruction to stream.  */
  info->fprintf_func (info->stream, "   %s %s%c%s", name,
		      operand[0][0] ? operand[0] : "",
		      operand[1][0] ? ',' : ' ',
		      operand[1][0] ? operand[1] : "");
  return 1;
}

static int
print_three_operand (disassemble_info *info,
		     unsigned long insn_word,
		     struct instruction *insn)
{
  char operand[3][13] =
  {
    {0},
    {0},
    {0}
  };

  if (insn->tm == NULL)
    return 0;
  switch (insn_word & AddressMode)
    {
    case AM_REGISTER:
      get_register_operand ((insn_word & 0x000000FF), operand[0]);
      get_register_operand ((insn_word & 0x0000FF00) >> 8, operand[1]);
      break;
    case AM_DIRECT:
      get_register_operand ((insn_word & 0x000000FF), operand[0]);
      get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[1]);
      break;
    case AM_INDIRECT:
      get_indirect_operand ((insn_word & 0x000000FF), 1, operand[0]);
      get_register_operand ((insn_word & 0x0000FF00) >> 8, operand[1]);
      break;
    case AM_IMM:
      get_indirect_operand ((insn_word & 0x000000FF), 1, operand[0]);
      get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[1]);
      break;
    default:
      return 0;
    }
  if (insn->tm->operands == 3)
    get_register_operand ((insn_word & 0x001F0000) >> 16, operand[2]);
  info->fprintf_func (info->stream, "   %s %s,%s%c%s", insn->tm->name,
		      operand[0], operand[1],
		      operand[2][0] ? ',' : ' ',
		      operand[2][0] ? operand[2] : "");
  return 1;
}

static int
print_par_insn (disassemble_info *info,
		unsigned long insn_word,
		struct instruction *insn)
{
  size_t i, len;
  char *name1, *name2;
  char operand[2][3][13] =
  {
    {
      {0},
      {0},
      {0}
    },
    {
      {0},
      {0},
      {0}
    }
  };

  if (insn->ptm == NULL)
    return 0;
  /* Parse out the names of each of the parallel instructions from the
     q_insn1_insn2 format.  */
  name1 = (char *) strdup (insn->ptm->name + 2);
  name2 = "";
  len = strlen (name1);
  for (i = 0; i < len; i++)
    {
      if (name1[i] == '_')
	{
	  name2 = &name1[i + 1];
	  name1[i] = '\0';
	  break;
	}
    }
  /* Get the operands of the instruction based on the operand order.  */
  switch (insn->ptm->oporder)
    {
    case OO_4op1:
      get_indirect_operand ((insn_word & 0x000000FF), 1, operand[0][0]);
      get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[1][1]);
      get_register_operand ((insn_word >> 16) & 0x07, operand[1][0]);
      get_register_operand ((insn_word >> 22) & 0x07, operand[0][1]);
      break;
    case OO_4op2:
      get_indirect_operand ((insn_word & 0x000000FF), 1, operand[0][0]);
      get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[1][0]);
      get_register_operand ((insn_word >> 19) & 0x07, operand[1][1]);
      get_register_operand ((insn_word >> 22) & 0x07, operand[0][1]);
      break;
    case OO_4op3:
      get_indirect_operand ((insn_word & 0x000000FF), 1, operand[0][1]);
      get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[1][1]);
      get_register_operand ((insn_word >> 16) & 0x07, operand[1][0]);
      get_register_operand ((insn_word >> 22) & 0x07, operand[0][0]);
      break;
    case OO_5op1:
      get_indirect_operand ((insn_word & 0x000000FF), 1, operand[0][0]);
      get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[1][1]);
      get_register_operand ((insn_word >> 16) & 0x07, operand[1][0]);
      get_register_operand ((insn_word >> 19) & 0x07, operand[0][1]);
      get_register_operand ((insn_word >> 22) & 0x07, operand[0][2]);
      break;
    case OO_5op2:
      get_indirect_operand ((insn_word & 0x000000FF), 1, operand[0][1]);
      get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[1][1]);
      get_register_operand ((insn_word >> 16) & 0x07, operand[1][0]);
      get_register_operand ((insn_word >> 19) & 0x07, operand[0][0]);
      get_register_operand ((insn_word >> 22) & 0x07, operand[0][2]);
      break;
    case OO_PField:
      if (insn_word & 0x00800000)
	get_register_operand (0x01, operand[0][2]);
      else
	get_register_operand (0x00, operand[0][2]);
      if (insn_word & 0x00400000)
	get_register_operand (0x03, operand[1][2]);
      else
	get_register_operand (0x02, operand[1][2]);
      switch (insn_word & P_FIELD)
	{
	case 0x00000000:
	  get_indirect_operand ((insn_word & 0x000000FF), 1, operand[0][1]);
	  get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[0][0]);
	  get_register_operand ((insn_word >> 16) & 0x07, operand[1][1]);
	  get_register_operand ((insn_word >> 19) & 0x07, operand[1][0]);
	  break;
	case 0x01000000:
	  get_indirect_operand ((insn_word & 0x000000FF), 1, operand[1][0]);
	  get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[0][0]);
	  get_register_operand ((insn_word >> 16) & 0x07, operand[1][1]);
	  get_register_operand ((insn_word >> 19) & 0x07, operand[0][1]);
	  break;
	case 0x02000000:
	  get_indirect_operand ((insn_word & 0x000000FF), 1, operand[1][1]);
	  get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[1][0]);
	  get_register_operand ((insn_word >> 16) & 0x07, operand[0][1]);
	  get_register_operand ((insn_word >> 19) & 0x07, operand[0][0]);
	  break;
	case 0x03000000:
	  get_indirect_operand ((insn_word & 0x000000FF), 1, operand[1][1]);
	  get_indirect_operand ((insn_word & 0x0000FF00) >> 8, 1, operand[0][0]);
	  get_register_operand ((insn_word >> 16) & 0x07, operand[1][0]);
	  get_register_operand ((insn_word >> 19) & 0x07, operand[0][1]);
	  break;
	}
      break;
    default:
      return 0;
    }
  info->fprintf_func (info->stream, "   %s %s,%s%c%s", name1,
		      operand[0][0], operand[0][1],
		      operand[0][2][0] ? ',' : ' ',
		      operand[0][2][0] ? operand[0][2] : "");
  info->fprintf_func (info->stream, "\n\t\t\t|| %s %s,%s%c%s", name2,
		      operand[1][0], operand[1][1],
		      operand[1][2][0] ? ',' : ' ',
		      operand[1][2][0] ? operand[1][2] : "");
  free (name1);
  return 1;
}

static int
print_branch (disassemble_info *info,
	      unsigned long insn_word,
	      struct instruction *insn)
{
  char operand[2][13] =
  {
    {0},
    {0}
  };
  unsigned long address;
  int print_label = 0;

  if (insn->tm == NULL)
    return 0;
  /* Get the operands for 24-bit immediate jumps.  */
  if (insn->tm->operand_types[0] & Imm24)
    {
      address = insn_word & 0x00FFFFFF;
      sprintf (operand[0], "0x%lX", address);
      print_label = 1;
    }
  /* Get the operand for the trap instruction.  */
  else if (insn->tm->operand_types[0] & IVector)
    {
      address = insn_word & 0x0000001F;
      sprintf (operand[0], "0x%lX", address);
    }
  else
    {
      address = insn_word & 0x0000FFFF;
      /* Get the operands for the DB instructions.  */
      if (insn->tm->operands == 2)
	{
	  get_register_operand (((insn_word & 0x01C00000) >> 22) + REG_AR0, operand[0]);
	  if (insn_word & PCRel)
	    {
	      sprintf (operand[1], "%d", (short) address);
	      print_label = 1;
	    }
	  else
	    get_register_operand (insn_word & 0x0000001F, operand[1]);
	}
      /* Get the operands for the standard branches.  */
      else if (insn->tm->operands == 1)
	{
	  if (insn_word & PCRel)
	    {
	      address = (short) address;
	      sprintf (operand[0], "%ld", address);
	      print_label = 1;
	    }
	  else
	    get_register_operand (insn_word & 0x0000001F, operand[0]);
	}
    }
  info->fprintf_func (info->stream, "   %s %s%c%s", insn->tm->name,
		      operand[0][0] ? operand[0] : "",
		      operand[1][0] ? ',' : ' ',
		      operand[1][0] ? operand[1] : "");
  /* Print destination of branch in relation to current symbol.  */
  if (print_label && info->symbols)
    {
      asymbol *sym = *info->symbols;

      if ((insn->tm->opcode_modifier == PCRel) && (insn_word & PCRel))
	{
	  address = (_pc + 1 + (short) address) - ((sym->section->vma + sym->value) / 4);
	  /* Check for delayed instruction, if so adjust destination.  */
	  if (insn_word & 0x00200000)
	    address += 2;
	}
      else
	{
	  address -= ((sym->section->vma + sym->value) / 4);
	}
      if (address == 0)
	info->fprintf_func (info->stream, " <%s>", sym->name);
      else
	info->fprintf_func (info->stream, " <%s %c %d>", sym->name,
			    ((short) address < 0) ? '-' : '+',
			    abs (address));
    }
  return 1;
}

int
print_insn_tic30 (bfd_vma pc, disassemble_info *info)
{
  unsigned long insn_word;
  struct instruction insn = { 0, NULL, NULL };
  bfd_vma bufaddr = pc - info->buffer_vma;

  /* Obtain the current instruction word from the buffer.  */
  insn_word = (*(info->buffer + bufaddr) << 24) | (*(info->buffer + bufaddr + 1) << 16) |
    (*(info->buffer + bufaddr + 2) << 8) | *(info->buffer + bufaddr + 3);
  _pc = pc / 4;
  /* Get the instruction refered to by the current instruction word
     and print it out based on its type.  */
  if (!get_tic30_instruction (insn_word, &insn))
    return -1;
  switch (GET_TYPE (insn_word))
    {
    case TWO_OPERAND_1:
    case TWO_OPERAND_2:
      if (!print_two_operand (info, insn_word, &insn))
	return -1;
      break;
    case THREE_OPERAND:
      if (!print_three_operand (info, insn_word, &insn))
	return -1;
      break;
    case PAR_STORE:
    case MUL_ADDS:
      if (!print_par_insn (info, insn_word, &insn))
	return -1;
      break;
    case BRANCHES:
      if (!print_branch (info, insn_word, &insn))
	return -1;
      break;
    }
  return 4;
}
@


1.12
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2002, 2005, 2007, 2009
d23 1
a25 1
#include "sysdep.h"
@


1.11
log
@update copyright dates
@
text
@d278 1
a278 1
  unsigned long exp, sign, mant;
d295 2
a296 2
  exp = tmsfloat & 0xFF000000;
  if (exp == 0x80000000)
d301 1
a301 1
  exp += 0x7F000000;
d304 1
a304 1
  if (exp == 0xFF000000)
d321 1
a321 1
  exp >>= 1;
d326 2
a327 2
      exp += mant & 0x00800000;
      exp &= 0x7F800000;
d331 2
a332 2
    sign = mant = exp = 0;
  tmsfloat = sign | exp | mant;
@


1.10
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d2 2
a3 1
   Copyright 1998, 1999, 2000, 2002, 2005, 2007 Free Software Foundation, Inc.
@


1.9
log
@Change source files over to GPLv3.
@
text
@d67 1
a67 1
  template *tm;
d81 1
a81 1
	template *current_optab = (template *) tic30_optab;
d148 1
a148 1
	template *current_optab = (template *) tic30_optab;
@


1.8
log
@2005-07-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* tic30-dis.c (cnvt_tmsfloat_ieee): Use HUGE_VALF if defined.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2002, 2005 Free Software Foundation, Inc.
d5 3
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d18 3
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */
@


1.7
log
@Update function declarations to ISO C90 formatting
@
text
@d305 6
d315 1
@


1.6
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
d69 2
a70 57
int get_tic30_instruction PARAMS ((unsigned long, struct instruction *));
int print_two_operand
  PARAMS ((disassemble_info *, unsigned long, struct instruction *));
int print_three_operand
  PARAMS ((disassemble_info *, unsigned long, struct instruction *));
int print_par_insn
  PARAMS ((disassemble_info *, unsigned long, struct instruction *));
int print_branch
  PARAMS ((disassemble_info *, unsigned long, struct instruction *));
int get_indirect_operand PARAMS ((unsigned short, int, char *));
int get_register_operand PARAMS ((unsigned char, char *));
int cnvt_tmsfloat_ieee PARAMS ((unsigned long, int, float *));

int
print_insn_tic30 (pc, info)
     bfd_vma pc;
     disassemble_info *info;
{
  unsigned long insn_word;
  struct instruction insn = { 0, NULL, NULL };
  bfd_vma bufaddr = pc - info->buffer_vma;
  /* Obtain the current instruction word from the buffer.  */
  insn_word = (*(info->buffer + bufaddr) << 24) | (*(info->buffer + bufaddr + 1) << 16) |
    (*(info->buffer + bufaddr + 2) << 8) | *(info->buffer + bufaddr + 3);
  _pc = pc / 4;
  /* Get the instruction refered to by the current instruction word
     and print it out based on its type.  */
  if (!get_tic30_instruction (insn_word, &insn))
    return -1;
  switch (GET_TYPE (insn_word))
    {
    case TWO_OPERAND_1:
    case TWO_OPERAND_2:
      if (!print_two_operand (info, insn_word, &insn))
	return -1;
      break;
    case THREE_OPERAND:
      if (!print_three_operand (info, insn_word, &insn))
	return -1;
      break;
    case PAR_STORE:
    case MUL_ADDS:
      if (!print_par_insn (info, insn_word, &insn))
	return -1;
      break;
    case BRANCHES:
      if (!print_branch (info, insn_word, &insn))
	return -1;
      break;
    }
  return 4;
}

int
get_tic30_instruction (insn_word, insn)
     unsigned long insn_word;
     struct instruction *insn;
d80 1
d102 1
d107 1
d112 2
a113 1
		if ((current_optab->base_opcode & PAR_STORE_IDEN) == (insn_word & PAR_STORE_IDEN))
d122 1
d127 1
d132 2
a133 1
		if ((current_optab->base_opcode & MUL_ADD_IDEN) == (insn_word & MUL_ADD_IDEN))
d142 1
d147 1
d154 2
a155 1
		    if ((current_optab->base_opcode & BR_IMM_IDEN) == (insn_word & BR_IMM_IDEN))
d163 2
a164 1
		    if ((current_optab->base_opcode & BR_COND_IDEN) == (insn_word & BR_COND_IDEN))
d172 2
a173 1
		    if ((current_optab->base_opcode & (BR_COND_IDEN | 0x00800000)) == (insn_word & (BR_COND_IDEN | 0x00800000)))
d189 143
a331 5
int
print_two_operand (info, insn_word, insn)
     disassemble_info *info;
     unsigned long insn_word;
     struct instruction *insn;
d337 2
a338 1
    {0}};
d348 2
a349 1
      if ((insn->tm->operand_types[1] & (Direct | Indirect)) == (Direct | Indirect))
d406 1
a406 3
	{
	  get_register_operand ((insn_word & 0x001F0000) >> 16, operand[0]);
	}
d416 4
a419 5
int
print_three_operand (info, insn_word, insn)
     disassemble_info *info;
     unsigned long insn_word;
     struct instruction *insn;
d425 2
a426 1
    {0}};
d460 4
a463 5
int
print_par_insn (info, insn_word, insn)
     disassemble_info *info;
     unsigned long insn_word;
     struct instruction *insn;
d472 2
a473 1
      {0}},
d477 3
a479 1
      {0}}};
d584 4
a587 5
int
print_branch (info, insn_word, insn)
     disassemble_info *info;
     unsigned long insn_word;
     struct instruction *insn;
d592 2
a593 1
    {0}};
d671 1
a671 4
get_indirect_operand (fragment, size, buffer)
     unsigned short fragment;
     int size;
     char *buffer;
d673 3
a675 3
  unsigned char mod;
  unsigned arnum;
  unsigned char disp;
d677 9
a685 5
  if (buffer == NULL)
    return 0;
  /* Determine which bits identify the sections of the indirect
     operand based on the size in bytes.  */
  switch (size)
d687 13
a699 4
    case 1:
      mod = (fragment & 0x00F8) >> 3;
      arnum = (fragment & 0x0007);
      disp = 0;
d701 3
a703 4
    case 2:
      mod = (fragment & 0xF800) >> 11;
      arnum = (fragment & 0x0700) >> 8;
      disp = (fragment & 0x00FF);
a704 2
    default:
      return 0;
d706 1
a706 113
  {
    const ind_addr_type *current_ind = tic30_indaddr_tab;
    for (; current_ind < tic30_indaddrtab_end; current_ind++)
      {
	if (current_ind->modfield == mod)
	  {
	    if (current_ind->displacement == IMPLIED_DISP && size == 2)
	      {
		continue;
	      }
	    else
	      {
		size_t i, len;
		int bufcnt;

		len = strlen (current_ind->syntax);
		for (i = 0, bufcnt = 0; i < len; i++, bufcnt++)
		  {
		    buffer[bufcnt] = current_ind->syntax[i];
		    if (buffer[bufcnt - 1] == 'a' && buffer[bufcnt] == 'r')
		      buffer[++bufcnt] = arnum + '0';
		    if (buffer[bufcnt] == '('
			&& current_ind->displacement == DISP_REQUIRED)
		      {
			sprintf (&buffer[bufcnt + 1], "%u", disp);
			bufcnt += strlen (&buffer[bufcnt + 1]);
		      }
		  }
		buffer[bufcnt + 1] = '\0';
		break;
	      }
	  }
      }
  }
  return 1;
}

int
get_register_operand (fragment, buffer)
     unsigned char fragment;
     char *buffer;
{
  const reg *current_reg = tic30_regtab;

  if (buffer == NULL)
    return 0;
  for (; current_reg < tic30_regtab_end; current_reg++)
    {
      if ((fragment & 0x1F) == current_reg->opcode)
	{
	  strcpy (buffer, current_reg->name);
	  return 1;
	}
    }
  return 0;
}

int
cnvt_tmsfloat_ieee (tmsfloat, size, ieeefloat)
     unsigned long tmsfloat;
     int size;
     float *ieeefloat;
{
  unsigned long exp, sign, mant;
  union {
    unsigned long l;
    float f;
  } val;

  if (size == 2)
    {
      if ((tmsfloat & 0x0000F000) == 0x00008000)
	tmsfloat = 0x80000000;
      else
	{
	  tmsfloat <<= 16;
	  tmsfloat = (long) tmsfloat >> 4;
	}
    }
  exp = tmsfloat & 0xFF000000;
  if (exp == 0x80000000)
    {
      *ieeefloat = 0.0;
      return 1;
    }
  exp += 0x7F000000;
  sign = (tmsfloat & 0x00800000) << 8;
  mant = tmsfloat & 0x007FFFFF;
  if (exp == 0xFF000000)
    {
      if (mant == 0)
	*ieeefloat = ERANGE;
      if (sign == 0)
	*ieeefloat = 1.0 / 0.0;
      else
	*ieeefloat = -1.0 / 0.0;
      return 1;
    }
  exp >>= 1;
  if (sign)
    {
      mant = (~mant) & 0x007FFFFF;
      mant += 1;
      exp += mant & 0x00800000;
      exp &= 0x7F800000;
      mant &= 0x007FFFFF;
    }
  if (tmsfloat == 0x80000000)
    sign = mant = exp = 0;
  tmsfloat = sign | exp | mant;
  val.l = tmsfloat;
  *ieeefloat = val.f;
  return 1;
@


1.5
log
@	* arm-dis.c (print_insn_arm): Constify "insn".  Formatting.
	(print_insn_thumb): Likewise.
	* h8500-dis.c (print_insn_h8500): Constify "opcode".
	* mcore-dis.c (print_insn_mcore): Constify "op".  Formatting.
	* ns32k-dis.c (print_insn_arg <case 'F'>): Use a union to avoid
	type-punned pointer warnings.
	<case 'L'>: Likewise.  Fix error message too.
	* pdp11-dis.c (print_reg): Warning fix.
	* sh-dis.c (print_movxy): Constify "op" param.
	(print_insn_ddt): Constify sh_opcode_info vars.
	(print_insn_ppi): Likewise.
	(print_insn_sh): Likewise.
	* tic30-dis.c (cnvt_tmsfloat_ieee): Use a union to avoid
	type-punned pointer warnings.
	* w65-dis.c (print_insn_w65): Constify "op".
@
text
@d17 2
a18 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.4
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
d666 4
d712 2
a713 1
  *ieeefloat = *((float *) &tmsfloat);
@


1.4.30.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
a665 4
  union {
    unsigned long l;
    float f;
  } val;
d708 1
a708 2
  val.l = tmsfloat;
  *ieeefloat = val.f;
@


1.4.28.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
a665 4
  union {
    unsigned long l;
    float f;
  } val;
d708 1
a708 2
  val.l = tmsfloat;
  *ieeefloat = val.f;
@


1.3
log
@2000-08-28  Kazu Hirata  <kazu@@hxi.com>

	* tic30-dis.c: Fix formatting.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.2
log
@	* alpha-dis.c: Don't include <stdlib.h>.
	* arm-dis.c: Include "sysdep.h".
	* tic30-dis.c: Don't include <stdlib.h> or <string.h>.  Include
	"sysdep.h".
	* Makefile.am: Rebuild dependencies.
	* Makefile.in: Rebuild.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
d30 1
a30 1
   instruction word. */
d33 1
a33 1
/* Instruction types. */
d41 1
a41 1
/* Specific instruction id bits. */
d48 1
a48 1
/* Addressing modes. */
d59 1
a59 1
/* TMS320C30 program counter for current instruction. */
d63 5
a67 5
  {
    int type;
    template *tm;
    partemplate *ptm;
  };
d88 1
a88 2
  struct instruction insn =
  {0, NULL, NULL};
d90 1
a90 1
  /* Obtain the current instruction word from the buffer. */
d95 1
a95 1
     and print it out based on its type. */
d251 1
a251 1
      /* Determine whether instruction is a store or a normal instruction. */
d262 1
a262 1
      /* Get the destination register. */
d265 1
a265 1
      /* Get the source operand based on addressing mode. */
d269 1
a269 1
	  /* Check for the NOP instruction before getting the operand. */
d280 1
a280 1
	  /* Get the value of the immediate operand based on variable type. */
d296 1
a296 1
	  /* Handle special case for LDP instruction. */
d305 1
a305 1
  /* Handle case for stack and rotate instructions. */
d313 1
a313 1
  /* Output instruction to stream. */
d387 1
a387 1
     q_insn1_insn2 format. */
d400 1
a400 1
  /* Get the operands of the instruction based on the operand order. */
d502 1
a502 1
  /* Get the operands for 24-bit immediate jumps. */
d509 1
a509 1
  /* Get the operand for the trap instruction. */
d518 1
a518 1
      /* Get the operands for the DB instructions. */
d530 1
a530 1
      /* Get the operands for the standard branches. */
d547 1
a547 1
  /* Print destination of branch in relation to current symbol. */
d555 1
a555 1
	  /* Check for delayed instruction, if so adjust destination. */
d585 2
a586 2
  /* Determine which bits identify the sections of the indirect operand based on the
     size in bytes. */
d616 1
a616 1
		
d623 2
a624 1
		    if (buffer[bufcnt] == '(' && current_ind->displacement == DISP_REQUIRED)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1998 Free Software Foundation, Inc.
d22 1
a22 2
#include <stdlib.h>
#include <string.h>
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

