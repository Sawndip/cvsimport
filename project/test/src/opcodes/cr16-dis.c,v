head	1.12;
access;
symbols
	sid-snapshot-20180601:1.12
	sid-snapshot-20180501:1.12
	sid-snapshot-20180401:1.12
	sid-snapshot-20180301:1.12
	sid-snapshot-20180201:1.12
	sid-snapshot-20180101:1.12
	sid-snapshot-20171201:1.12
	sid-snapshot-20171101:1.12
	sid-snapshot-20171001:1.12
	sid-snapshot-20170901:1.12
	sid-snapshot-20170801:1.12
	sid-snapshot-20170701:1.12
	sid-snapshot-20170601:1.12
	sid-snapshot-20170501:1.12
	sid-snapshot-20170401:1.12
	sid-snapshot-20170301:1.12
	sid-snapshot-20170201:1.12
	sid-snapshot-20170101:1.12
	sid-snapshot-20161201:1.12
	sid-snapshot-20161101:1.12
	sid-snapshot-20160901:1.12
	sid-snapshot-20160801:1.12
	sid-snapshot-20160701:1.12
	sid-snapshot-20160601:1.12
	sid-snapshot-20160501:1.12
	sid-snapshot-20160401:1.12
	sid-snapshot-20160301:1.12
	sid-snapshot-20160201:1.12
	sid-snapshot-20160101:1.12
	sid-snapshot-20151201:1.12
	sid-snapshot-20151101:1.12
	sid-snapshot-20151001:1.12
	sid-snapshot-20150901:1.12
	sid-snapshot-20150801:1.12
	sid-snapshot-20150701:1.12
	sid-snapshot-20150601:1.12
	sid-snapshot-20150501:1.12
	sid-snapshot-20150401:1.12
	sid-snapshot-20150301:1.12
	sid-snapshot-20150201:1.12
	sid-snapshot-20150101:1.12
	sid-snapshot-20141201:1.12
	sid-snapshot-20141101:1.12
	sid-snapshot-20141001:1.12
	sid-snapshot-20140901:1.12
	sid-snapshot-20140801:1.12
	sid-snapshot-20140701:1.12
	sid-snapshot-20140601:1.12
	sid-snapshot-20140501:1.12
	sid-snapshot-20140401:1.12
	sid-snapshot-20140301:1.12
	sid-snapshot-20140201:1.12
	sid-snapshot-20140101:1.12
	sid-snapshot-20131201:1.12
	sid-snapshot-20131101:1.12
	sid-snapshot-20131001:1.12
	binutils-2_24-branch:1.12.0.4
	binutils-2_24-branchpoint:1.12
	binutils-2_21_1:1.7
	sid-snapshot-20130901:1.12
	gdb_7_6_1-2013-08-30-release:1.12
	sid-snapshot-20130801:1.12
	sid-snapshot-20130701:1.12
	sid-snapshot-20130601:1.12
	sid-snapshot-20130501:1.12
	gdb_7_6-2013-04-26-release:1.12
	sid-snapshot-20130401:1.12
	binutils-2_23_2:1.9
	gdb_7_6-branch:1.12.0.2
	gdb_7_6-2013-03-12-branchpoint:1.12
	sid-snapshot-20130301:1.12
	sid-snapshot-20130201:1.12
	sid-snapshot-20130101:1.9
	sid-snapshot-20121201:1.9
	gdb_7_5_1-2012-11-29-release:1.9
	binutils-2_23_1:1.9
	sid-snapshot-20121101:1.9
	binutils-2_23:1.9
	sid-snapshot-20121001:1.9
	sid-snapshot-20120901:1.9
	gdb_7_5-2012-08-17-release:1.9
	sid-snapshot-20120801:1.9
	binutils-2_23-branch:1.9.0.4
	binutils-2_23-branchpoint:1.9
	gdb_7_5-branch:1.9.0.2
	gdb_7_5-2012-07-18-branchpoint:1.9
	sid-snapshot-20120701:1.9
	sid-snapshot-20120601:1.9
	sid-snapshot-20120501:1.8
	binutils-2_22_branch:1.7.0.14
	gdb_7_4_1-2012-04-26-release:1.7
	sid-snapshot-20120401:1.8
	sid-snapshot-20120301:1.8
	sid-snapshot-20120201:1.8
	gdb_7_4-2012-01-24-release:1.7
	sid-snapshot-20120101:1.7
	gdb_7_4-branch:1.7.0.12
	gdb_7_4-2011-12-13-branchpoint:1.7
	sid-snapshot-20111201:1.7
	binutils-2_22:1.7
	sid-snapshot-20111101:1.7
	sid-snapshot-20111001:1.7
	binutils-2_22-branch:1.7.0.10
	binutils-2_22-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.7
	sid-snapshot-20110901:1.7
	sid-snapshot-20110801:1.7
	gdb_7_3-2011-07-26-release:1.7
	sid-snapshot-20110701:1.7
	sid-snapshot-20110601:1.7
	sid-snapshot-20110501:1.7
	gdb_7_3-branch:1.7.0.8
	gdb_7_3-2011-04-01-branchpoint:1.7
	sid-snapshot-20110401:1.7
	sid-snapshot-20110301:1.7
	sid-snapshot-20110201:1.7
	sid-snapshot-20110101:1.7
	binutils-2_21:1.7
	sid-snapshot-20101201:1.7
	binutils-2_21-branch:1.7.0.6
	binutils-2_21-branchpoint:1.7
	sid-snapshot-20101101:1.7
	sid-snapshot-20101001:1.7
	binutils-2_20_1:1.6
	gdb_7_2-2010-09-02-release:1.7
	sid-snapshot-20100901:1.7
	sid-snapshot-20100801:1.7
	gdb_7_2-branch:1.7.0.4
	gdb_7_2-2010-07-07-branchpoint:1.7
	sid-snapshot-20100701:1.7
	sid-snapshot-20100601:1.7
	sid-snapshot-20100501:1.7
	sid-snapshot-20100401:1.7
	gdb_7_1-2010-03-18-release:1.7
	sid-snapshot-20100301:1.7
	gdb_7_1-branch:1.7.0.2
	gdb_7_1-2010-02-18-branchpoint:1.7
	sid-snapshot-20100201:1.7
	sid-snapshot-20100101:1.7
	gdb_7_0_1-2009-12-22-release:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	binutils-2_20:1.6
	gdb_7_0-2009-10-06-release:1.6
	sid-snapshot-20091001:1.6
	gdb_7_0-branch:1.6.0.8
	gdb_7_0-2009-09-16-branchpoint:1.6
	arc-sim-20090309:1.3
	binutils-arc-20081103-branch:1.4.0.14
	binutils-arc-20081103-branchpoint:1.4
	binutils-2_20-branch:1.6.0.6
	binutils-2_20-branchpoint:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	msnyder-checkpoint-072509-branch:1.6.0.4
	msnyder-checkpoint-072509-branchpoint:1.6
	sid-snapshot-20090701:1.6
	dje-cgen-play1-branch:1.6.0.2
	dje-cgen-play1-branchpoint:1.6
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	sid-snapshot-20090401:1.5
	arc-20081103-branch:1.4.0.12
	arc-20081103-branchpoint:1.4
	arc-insight_6_8-branch:1.3.0.10
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.8
	insight_6_8-branchpoint:1.3
	sid-snapshot-20090301:1.5
	binutils-2_19_1:1.4
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	reverse-20081226-branch:1.5.0.2
	reverse-20081226-branchpoint:1.5
	sid-snapshot-20081201:1.5
	multiprocess-20081120-branch:1.4.0.10
	multiprocess-20081120-branchpoint:1.4
	sid-snapshot-20081101:1.4
	binutils-2_19:1.4
	sid-snapshot-20081001:1.4
	reverse-20080930-branch:1.4.0.8
	reverse-20080930-branchpoint:1.4
	binutils-2_19-branch:1.4.0.6
	binutils-2_19-branchpoint:1.4
	sid-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	reverse-20080717-branch:1.4.0.4
	reverse-20080717-branchpoint:1.4
	sid-snapshot-20080701:1.4
	msnyder-reverse-20080609-branch:1.4.0.2
	msnyder-reverse-20080609-branchpoint:1.4
	sid-snapshot-20080601:1.4
	sid-snapshot-20080501:1.3
	sid-snapshot-20080403:1.3
	sid-snapshot-20080401:1.3
	gdb_6_8-2008-03-27-release:1.3
	sid-snapshot-20080301:1.3
	gdb_6_8-branch:1.3.0.6
	gdb_6_8-2008-02-26-branchpoint:1.3
	sid-snapshot-20080201:1.3
	sid-snapshot-20080101:1.3
	sid-snapshot-20071201:1.3
	sid-snapshot-20071101:1.3
	gdb_6_7_1-2007-10-29-release:1.3
	gdb_6_7-2007-10-10-release:1.3
	sid-snapshot-20071001:1.3
	gdb_6_7-branch:1.3.0.4
	gdb_6_7-2007-09-07-branchpoint:1.3
	binutils-2_18:1.3
	binutils-2_18-branch:1.3.0.2
	binutils-2_18-branchpoint:1.3
	binutils_latest_snapshot:1.12;
locks; strict;
comment	@ * @;


1.12
date	2013.01.07.15.10.18;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2013.01.07.15.09.06;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.02.13.13.35;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2012.01.16.23.51.35;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2009.12.11.13.42.16;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.15.15.24.52;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.27.11.30.33;	author swami;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.21.07.50.55;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2007.07.04.14.29.44;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.29.14.09.34;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.12
log
@oops - typo correction.
@
text
@/* Disassembler code for CR16.
   Copyright 2007, 2008, 2009, 2012, 2013  Free Software Foundation, Inc.
   Contributed by M R Swami Reddy (MR.Swami.Reddy@@nsc.com).

   This file is part of GAS, GDB and the GNU binutils.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "opcode/cr16.h"
#include "libiberty.h"

/* String to print when opcode was not matched.  */
#define ILLEGAL  "illegal"
  /* Escape to 16-bit immediate.  */
#define ESCAPE_16_BIT  0xB

/* Extract 'n_bits' from 'a' starting from offset 'offs'.  */
#define EXTRACT(a, offs, n_bits)                    \
  (n_bits == 32 ? (((a) >> (offs)) & 0xffffffffL)   \
  : (((a) >> (offs)) & ((1 << (n_bits)) -1)))

/* Set Bit Mask - a mask to set all bits starting from offset 'offs'.  */
#define SBM(offs)  ((((1 << (32 - offs)) -1) << (offs)))

typedef struct
{
  dwordU val;
  int nbits;
} parameter;

/* Structure to map valid 'cinv' instruction options.  */

typedef struct
  {
    /* Cinv printed string.  */
    char *istr;
    /* Value corresponding to the string.  */
    char *ostr;
  }
cinv_entry;

/* CR16 'cinv' options mapping.  */
const cinv_entry cr16_cinvs[] =
{
  {"cinv[i]",     "cinv    [i]"},
  {"cinv[i,u]",   "cinv    [i,u]"},
  {"cinv[d]",     "cinv    [d]"},
  {"cinv[d,u]",   "cinv    [d,u]"},
  {"cinv[d,i]",   "cinv    [d,i]"},
  {"cinv[d,i,u]", "cinv    [d,i,u]"}
};

/* Number of valid 'cinv' instruction options.  */
static int NUMCINVS = ARRAY_SIZE (cr16_cinvs);

/* Enum to distinguish different registers argument types.  */
typedef enum REG_ARG_TYPE
  {
    /* General purpose register (r<N>).  */
    REG_ARG = 0,
    /*Processor register   */
    P_ARG,
  }
REG_ARG_TYPE;

/* Current opcode table entry we're disassembling.  */
const inst *instruction;
/* Current instruction we're disassembling.  */
ins cr16_currInsn;
/* The current instruction is read into 3 consecutive words.  */
wordU cr16_words[3];
/* Contains all words in appropriate order.  */
ULONGLONG cr16_allWords;
/* Holds the current processed argument number.  */
int processing_argument_number;
/* Nonzero means a IMM4 instruction.  */
int imm4flag;
/* Nonzero means the instruction's original size is
   incremented (escape sequence is used).  */
int size_changed;


/* Print the constant expression length.  */

static char *
print_exp_len (int size)
{
  switch (size)
    {
    case 4:
    case 5:
    case 6:
    case 8:
    case 14:
    case 16:
      return ":s";
    case 20:
    case 24:
    case 32:
      return ":m";
    case 48:
      return ":l";
    default:
      return "";
    }
}


/* Retrieve the number of operands for the current assembled instruction.  */

static int
get_number_of_operands (void)
{
  int i;

  for (i = 0; instruction->operands[i].op_type && i < MAX_OPERANDS; i++)
    ;

  return i;
}

/* Return the bit size for a given operand.  */

static int
getbits (operand_type op)
{
  if (op < MAX_OPRD)
    return cr16_optab[op].bit_size;

  return 0;
}

/* Return the argument type of a given operand.  */

static argtype
getargtype (operand_type op)
{
  if (op < MAX_OPRD)
    return cr16_optab[op].arg_type;

  return nullargs;
}

/* Given a 'CC' instruction constant operand, return its corresponding
   string. This routine is used when disassembling the 'CC' instruction.  */

static char *
getccstring (unsigned cc_insn)
{
  return (char *) cr16_b_cond_tab[cc_insn];
}


/* Given a 'cinv' instruction constant operand, return its corresponding
   string. This routine is used when disassembling the 'cinv' instruction. */

static char *
getcinvstring (const char *str)
{
  const cinv_entry *cinv;

  for (cinv = cr16_cinvs; cinv < (cr16_cinvs + NUMCINVS); cinv++)
    if (strcmp (cinv->istr, str) == 0)
      return cinv->ostr;

  return ILLEGAL;
}

/* Given the trap index in dispatch table, return its name.
   This routine is used when disassembling the 'excp' instruction.  */

static char *
gettrapstring (unsigned int trap_index)
{
  const trap_entry *trap;

  for (trap = cr16_traps; trap < cr16_traps + NUMTRAPS; trap++)
    if (trap->entry == trap_index)
      return trap->name;

  return ILLEGAL;
}

/* Given a register enum value, retrieve its name.  */

static char *
getregname (reg r)
{
  const reg_entry * regentry = cr16_regtab + r;

  if (regentry->type != CR16_R_REGTYPE)
    return ILLEGAL;

  return regentry->name;
}

/* Given a register pair enum value, retrieve its name.  */

static char *
getregpname (reg r)
{
  const reg_entry * regentry = cr16_regptab + r;

  if (regentry->type != CR16_RP_REGTYPE)
    return ILLEGAL;

  return regentry->name;
}

/* Given a index register pair enum value, retrieve its name.  */

static char *
getidxregpname (reg r)
{
  const reg_entry * regentry;

  switch (r)
   {
   case 0: r = 0; break;
   case 1: r = 2; break;
   case 2: r = 4; break;
   case 3: r = 6; break;
   case 4: r = 8; break;
   case 5: r = 10; break;
   case 6: r = 3; break;
   case 7: r = 5; break;
   default:
     break;
   }

  regentry = cr16_regptab + r;

  if (regentry->type != CR16_RP_REGTYPE)
    return ILLEGAL;

  return regentry->name;
}

/* Getting a processor register name.  */

static char *
getprocregname (int reg_index)
{
  const reg_entry *r;

  for (r = cr16_pregtab; r < cr16_pregtab + NUMPREGS; r++)
    if (r->image == reg_index)
      return r->name;

  return "ILLEGAL REGISTER";
}

/* Getting a processor register name - 32 bit size.  */

static char *
getprocpregname (int reg_index)
{
  const reg_entry *r;

  for (r = cr16_pregptab; r < cr16_pregptab + NUMPREGPS; r++)
    if (r->image == reg_index)
      return r->name;

  return "ILLEGAL REGISTER";
}

/* START and END are relating 'cr16_allWords' struct, which is 48 bits size.

                          START|--------|END
             +---------+---------+---------+---------+
             |         |   V    |     A    |   L     |
             +---------+---------+---------+---------+
                       0         16        32        48
    words                  [0]       [1]       [2]      */

static parameter
makelongparameter (ULONGLONG val, int start, int end)
{
  parameter p;

  p.val = (dwordU) EXTRACT (val, 48 - end, end - start);
  p.nbits = end - start;
  return p;
}

/* Build a mask of the instruction's 'constant' opcode,
   based on the instruction's printing flags.  */

static unsigned long
build_mask (void)
{
  unsigned long mask = SBM (instruction->match_bits);

  /* Adjust mask for bcond with 32-bit size instruction.  */
  if ((IS_INSN_MNEMONIC("b") && instruction->size == 2))
    mask = 0xff0f0000;

  return mask;
}

/* Search for a matching opcode. Return 1 for success, 0 for failure.  */

int
cr16_match_opcode (void)
{
  unsigned long mask;
  /* The instruction 'constant' opcode doesn't exceed 32 bits.  */
  unsigned long doubleWord = (cr16_words[1]
			     + (cr16_words[0] << 16)) & 0xffffffff;

  /* Start searching from end of instruction table.  */
  instruction = &cr16_instruction[NUMOPCODES - 2];

  /* Loop over instruction table until a full match is found.  */
  while (instruction >= cr16_instruction)
    {
      mask = build_mask ();
      /* Adjust mask for bcond with 32-bit size instruction */
      if ((IS_INSN_MNEMONIC("b") && instruction->size == 2))
        mask = 0xff0f0000;

      if ((doubleWord & mask) == BIN (instruction->match,
                                      instruction->match_bits))
        return 1;
      else
        instruction--;
    }
  return 0;
}

/* Set the proper parameter value for different type of arguments.  */

static void
make_argument (argument * a, int start_bits)
{
  int inst_bit_size;
  parameter p;

  if ((instruction->size == 3) && a->size >= 16)
    inst_bit_size = 48;
  else
    inst_bit_size = 32;

  switch (a->type)
    {
    case arg_r:
      p = makelongparameter (cr16_allWords, 
			     inst_bit_size - (start_bits + a->size),
			     inst_bit_size - start_bits);
      a->r = p.val;
      break;

    case arg_rp:
      p = makelongparameter (cr16_allWords,
			     inst_bit_size - (start_bits + a->size),
			     inst_bit_size - start_bits);
      a->rp = p.val;
      break;

    case arg_pr:
      p = makelongparameter (cr16_allWords,
			     inst_bit_size - (start_bits + a->size),
			     inst_bit_size - start_bits);
      a->pr = p.val;
      break;

    case arg_prp:
      p = makelongparameter (cr16_allWords,
			     inst_bit_size - (start_bits + a->size),
			     inst_bit_size - start_bits);
      a->prp = p.val;
      break;

    case arg_ic:
      p = makelongparameter (cr16_allWords, 
			     inst_bit_size - (start_bits + a->size),
			     inst_bit_size - start_bits);
      a->constant = p.val;
      break;

    case arg_cc:
      p = makelongparameter (cr16_allWords,
			     inst_bit_size - (start_bits + a->size),
			     inst_bit_size - start_bits);

      a->cc = p.val;
      break;

    case arg_idxr:
      if ((IS_INSN_MNEMONIC ("cbitb"))
	  || (IS_INSN_MNEMONIC ("sbitb"))
	  || (IS_INSN_MNEMONIC ("tbitb")))
	p = makelongparameter (cr16_allWords, 8, 9);
      else
	p = makelongparameter (cr16_allWords, 9, 10);
      a->i_r = p.val;
      p = makelongparameter (cr16_allWords,
			     inst_bit_size - a->size, inst_bit_size);
      a->constant = p.val;
      break;

    case arg_idxrp:
      p = makelongparameter (cr16_allWords, start_bits + 12, start_bits + 13);
      a->i_r = p.val;
      p = makelongparameter (cr16_allWords, start_bits + 13, start_bits + 16);
      a->rp = p.val;
      if (inst_bit_size > 32)
	{
	  p = makelongparameter (cr16_allWords, inst_bit_size - start_bits - 12,
				 inst_bit_size);
	  a->constant = ((p.val & 0xffff) | (p.val >> 8 & 0xf0000));
	}
      else if (instruction->size == 2)
	{
	  p = makelongparameter (cr16_allWords, inst_bit_size - 22,
				 inst_bit_size);
	  a->constant = (p.val & 0xf) | (((p.val >>20) & 0x3) << 4)
	    | ((p.val >>14 & 0x3) << 6) | (((p.val >>7) & 0x1f) <<7);
	}
      else if (instruction->size == 1 && a->size == 0)
	a->constant = 0;

      break;

    case arg_rbase:
      p = makelongparameter (cr16_allWords, inst_bit_size, inst_bit_size);
      a->constant = p.val;
      p = makelongparameter (cr16_allWords, inst_bit_size - (start_bits + 4),
                             inst_bit_size - start_bits);
      a->r = p.val;
      break;

    case arg_cr:
      p = makelongparameter (cr16_allWords, start_bits + 12, start_bits + 16);
      a->r = p.val;
      p = makelongparameter (cr16_allWords, inst_bit_size - 16, inst_bit_size);
      a->constant = p.val;
      break;

    case arg_crp:
      if (instruction->size == 1)
	p = makelongparameter (cr16_allWords, 12, 16);
      else
	p = makelongparameter (cr16_allWords, start_bits + 12, start_bits + 16);
      a->rp = p.val;

      if (inst_bit_size > 32)
	{
	  p = makelongparameter (cr16_allWords, inst_bit_size - start_bits - 12,
				 inst_bit_size);
	  a->constant = ((p.val & 0xffff) | (p.val >> 8 & 0xf0000));
	}
      else if (instruction->size == 2)
	{
	  p = makelongparameter (cr16_allWords, inst_bit_size - 16, 
				 inst_bit_size);
	  a->constant = p.val;
	}
      else if (instruction->size == 1 && a->size != 0)
	{
	  p = makelongparameter (cr16_allWords, 4, 8);
	  if (IS_INSN_MNEMONIC ("loadw")
	      || IS_INSN_MNEMONIC ("loadd")
	      || IS_INSN_MNEMONIC ("storw")
	      || IS_INSN_MNEMONIC ("stord"))
	    a->constant = (p.val * 2);
	  else
	    a->constant = p.val;
	}
      else /* below case for 0x0(reg pair) */
	a->constant = 0;

      break;

    case arg_c:

      if ((IS_INSN_TYPE (BRANCH_INS))
	  || (IS_INSN_MNEMONIC ("bal"))
	  || (IS_INSN_TYPE (CSTBIT_INS))
	  || (IS_INSN_TYPE (LD_STOR_INS)))
	{
	  switch (a->size)
	    {
	    case 8 :
	      p = makelongparameter (cr16_allWords, 0, start_bits);
	      a->constant = ((((p.val&0xf00)>>4)) | (p.val&0xf));
	      break;

	    case 24:
	      if (instruction->size == 3)
		{
		  p = makelongparameter (cr16_allWords, 16, inst_bit_size);
		  a->constant = ((((p.val>>16)&0xf) << 20)
				 | (((p.val>>24)&0xf) << 16)
				 | (p.val & 0xffff));
		}
	      else if (instruction->size == 2)
		{
		  p = makelongparameter (cr16_allWords, 8, inst_bit_size);
		  a->constant = p.val;
		}
	      break;

	    default:
	      p = makelongparameter (cr16_allWords,
				     inst_bit_size - (start_bits + a->size),
				     inst_bit_size - start_bits);
	      a->constant = p.val;
	      break;
	    }
	}
      else
	{
	  p = makelongparameter (cr16_allWords,
				 inst_bit_size - (start_bits + a->size),
				 inst_bit_size - start_bits);
	  a->constant = p.val;
	}
      break;

    default:
      break;
    }
}

/*  Print a single argument.  */

static void
print_arg (argument *a, bfd_vma memaddr, struct disassemble_info *info)
{
  LONGLONG longdisp, mask;
  int sign_flag = 0;
  int relative = 0;
  bfd_vma number;
  PTR stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  switch (a->type)
    {
    case arg_r:
      func (stream, "%s", getregname (a->r));
      break;

    case arg_rp:
      func (stream, "%s", getregpname (a->rp));
      break;

    case arg_pr:
      func (stream, "%s", getprocregname (a->pr));
      break;

    case arg_prp:
      func (stream, "%s", getprocpregname (a->prp));
      break;

    case arg_cc:
      func (stream, "%s", getccstring (a->cc));
      func (stream, "%s", "\t");
      break;

    case arg_ic:
      if (IS_INSN_MNEMONIC ("excp"))
	{
	  func (stream, "%s", gettrapstring (a->constant));
	  break;
	}
      else if ((IS_INSN_TYPE (ARITH_INS) || IS_INSN_TYPE (ARITH_BYTE_INS))
	       && ((instruction->size == 1) && (a->constant == 9)))
	func (stream, "$%d", -1);
      else if (INST_HAS_REG_LIST)
	func (stream, "$0x%lx", a->constant +1);
      else if (IS_INSN_TYPE (SHIFT_INS))
	{
	  longdisp = a->constant;
	  mask = ((LONGLONG)1 << a->size) - 1;
	  if (longdisp & ((LONGLONG)1 << (a->size -1)))
	    {
	      sign_flag = 1;
	      longdisp = ~(longdisp) + 1;
	    }
	  a->constant = (unsigned long int) (longdisp & mask);
	  func (stream, "$%d", ((int)(sign_flag ? -a->constant :
				      a->constant)));
	}
      else
	func (stream, "$0x%lx", a->constant);
      switch (a->size)
	{
	case 4  : case 5  : case 6  : case 8  :
	  func (stream, "%s", ":s"); break;
	case 16 : case 20 : func (stream, "%s", ":m"); break;
	case 24 : case 32 : func (stream, "%s", ":l"); break;
	default: break;
	}
      break;

    case arg_idxr:
      if (a->i_r == 0) func (stream, "[r12]");
      if (a->i_r == 1) func (stream, "[r13]");
      func (stream, "0x%lx", a->constant);
      func (stream, "%s", print_exp_len (instruction->size * 16));
      break;

    case arg_idxrp:
      if (a->i_r == 0) func (stream, "[r12]");
      if (a->i_r == 1) func (stream, "[r13]");
      func (stream, "0x%lx", a->constant);
      func (stream, "%s", print_exp_len (instruction->size * 16));
      func (stream, "%s", getidxregpname (a->rp));
      break;

    case arg_rbase:
      func (stream, "(%s)", getregname (a->r));
      break;

    case arg_cr:
      func (stream, "0x%lx", a->constant);
      func (stream, "%s", print_exp_len (instruction->size * 16));
      func (stream, "(%s)", getregname (a->r));
      break;

    case arg_crp:
      func (stream, "0x%lx", a->constant);
      func (stream, "%s", print_exp_len (instruction->size * 16));
      func (stream, "%s", getregpname (a->rp));
      break;

    case arg_c:
      /*Removed the *2 part as because implicit zeros are no more required.
	Have to fix this as this needs a bit of extension in terms of branch
	instructions. */
      if (IS_INSN_TYPE (BRANCH_INS) || IS_INSN_MNEMONIC ("bal"))
	{
	  relative = 1;
	  longdisp = a->constant;
	  /* REVISIT: To sync with WinIDEA and CR16 4.1tools, the below
	     line commented */
	  /* longdisp <<= 1; */
	  mask = ((LONGLONG)1 << a->size) - 1;
	  switch (a->size)
	    {
	    case 8  :
	      {
		longdisp <<= 1;
		if (longdisp & ((LONGLONG)1 << a->size))
		  {
		    sign_flag = 1;
		    longdisp = ~(longdisp) + 1;
		  }
		break;
	      }
	    case 16 :
	    case 24 :
	      {
		if (longdisp & 1)
		  {
		    sign_flag = 1;
		    longdisp = ~(longdisp) + 1;
		  }
		break;
	      }
	    default:
	      func (stream, "Wrong offset used in branch/bal instruction");
	      break;
	    }
	  a->constant = (unsigned long int) (longdisp & mask);
	}
      /* For branch Neq instruction it is 2*offset + 2.  */
      else if (IS_INSN_TYPE (BRANCH_NEQ_INS))
	a->constant = 2 * a->constant + 2;

      if ((!IS_INSN_TYPE (CSTBIT_INS)) && (!IS_INSN_TYPE (LD_STOR_INS)))
	(sign_flag) ? func (stream, "%s", "*-"): func (stream, "%s","*+");

      /* PR 10173: Avoid printing the 0x prefix twice.  */
      if (info->symtab_size > 0)
	func (stream, "%s", "0x");
      number = ((relative ? memaddr : 0) +
		(sign_flag ? ((- a->constant) & 0xffffffe) : a->constant));

      (*info->print_address_func) ((number & ((1 << 24) - 1)), info);

      func (stream, "%s", print_exp_len (instruction->size * 16));
      break;

    default:
      break;
    }
}

/* Print all the arguments of CURRINSN instruction.  */

static void
print_arguments (ins *currentInsn, bfd_vma memaddr, struct disassemble_info *info)
{
  int i;

  /* For "pop/push/popret RA instruction only.  */
  if ((IS_INSN_MNEMONIC ("pop")
       || (IS_INSN_MNEMONIC ("popret")
	   || (IS_INSN_MNEMONIC ("push"))))
      && currentInsn->nargs == 1)
    {
      info->fprintf_func (info->stream, "RA");
      return;
    }

  for (i = 0; i < currentInsn->nargs; i++)
    {
      processing_argument_number = i;

      /* For "bal (ra), disp17" instruction only.  */
      if ((IS_INSN_MNEMONIC ("bal")) && (i == 0) && instruction->size == 2)
        {
          info->fprintf_func (info->stream, "(ra),");
          continue;
        }

      if ((INST_HAS_REG_LIST) && (i == 2))
        info->fprintf_func (info->stream, "RA");
      else
        print_arg (&currentInsn->arg[i], memaddr, info);

      if ((i != currentInsn->nargs - 1) && (!IS_INSN_MNEMONIC ("b")))
        info->fprintf_func (info->stream, ",");
    }
}

/* Build the instruction's arguments.  */

void
cr16_make_instruction (void)
{
  int i;
  unsigned int shift;

  for (i = 0; i < cr16_currInsn.nargs; i++)
    {
      argument a;

      memset (&a, 0, sizeof (a));
      a.type = getargtype (instruction->operands[i].op_type);
      a.size = getbits (instruction->operands[i].op_type);
      shift = instruction->operands[i].shift;

      make_argument (&a, shift);
      cr16_currInsn.arg[i] = a;
    }

  /* Calculate instruction size (in bytes).  */
  cr16_currInsn.size = instruction->size + (size_changed ? 1 : 0);
  /* Now in bits.  */
  cr16_currInsn.size *= 2;
}

/* Retrieve a single word from a given memory address.  */

static wordU
get_word_at_PC (bfd_vma memaddr, struct disassemble_info *info)
{
  bfd_byte buffer[4];
  int status;
  wordU insn = 0;

  status = info->read_memory_func (memaddr, buffer, 2, info);

  if (status == 0)
    insn = (wordU) bfd_getl16 (buffer);

  return insn;
}

/* Retrieve multiple words (3) from a given memory address.  */

static void
get_words_at_PC (bfd_vma memaddr, struct disassemble_info *info)
{
  int i;
  bfd_vma mem;

  for (i = 0, mem = memaddr; i < 3; i++, mem += 2)
    cr16_words[i] = get_word_at_PC (mem, info);

  cr16_allWords =  ((ULONGLONG) cr16_words[0] << 32) 
		   + ((unsigned long) cr16_words[1] << 16) + cr16_words[2];
}

/* Prints the instruction by calling print_arguments after proper matching.  */

int
print_insn_cr16 (bfd_vma memaddr, struct disassemble_info *info)
{
  int is_decoded;     /* Nonzero means instruction has a match.  */

  /* Initialize global variables.  */
  imm4flag = 0;
  size_changed = 0;

  /* Retrieve the encoding from current memory location.  */
  get_words_at_PC (memaddr, info);
  /* Find a matching opcode in table.  */
  is_decoded = cr16_match_opcode ();
  /* If found, print the instruction's mnemonic and arguments.  */
  if (is_decoded > 0 && (cr16_words[0] << 16 || cr16_words[1]) != 0)
    {
      if (strneq (instruction->mnemonic, "cinv", 4))
        info->fprintf_func (info->stream,"%s", getcinvstring (instruction->mnemonic));
      else
        info->fprintf_func (info->stream, "%s", instruction->mnemonic);

      if (((cr16_currInsn.nargs = get_number_of_operands ()) != 0)
	  && ! (IS_INSN_MNEMONIC ("b")))
        info->fprintf_func (info->stream, "\t");
      cr16_make_instruction ();
      /* For push/pop/pushrtn with RA instructions.  */
      if ((INST_HAS_REG_LIST) && ((cr16_words[0] >> 7) & 0x1))
        cr16_currInsn.nargs +=1;
      print_arguments (&cr16_currInsn, memaddr, info);
      return cr16_currInsn.size;
    }

  /* No match found.  */
  info->fprintf_func (info->stream,"%s ",ILLEGAL);
  return 2;
}
@


1.11
log
@	(make_instruction): Rename to cr16_make_instruction.
	(match_opcode): Rename to cr16_match_opcode.
@
text
@d321 1
a321 1
  /* The instruction 'constant' opcode doewsn't exceed 32 bits.  */
@


1.10
log
@opcodes/ChangeLog
	* cr16-dis.c (match_opcode,make_instruction: Remove static declaration.
	(dwordU,wordU): Moved typedefs to opcode/cr16.h
	(cr16_words,cr16_allWords,cr16_currInsn): Added prefix 'cr16_'

bfd/Changelog
	* config.bfd (cr16*-*-uclinux*): New target support.

include/opcode/ChangeLog
	* cr16.h (dwordU,wordU): Moved typedefs from cr16-dis.c
	(make_instruction,match_opcode): Added function prototypes.
	(cr16_words,cr16_allWords,cr16_currInsn): Declare as extern.
@
text
@d318 1
a318 1
match_opcode (void)
d746 1
a746 1
make_instruction (void)
d816 1
a816 1
  is_decoded = match_opcode ();
d828 1
a828 1
      make_instruction ();
@


1.9
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d2 1
a2 1
   Copyright 2007, 2008, 2009, 2012  Free Software Foundation, Inc.
a38 3
typedef unsigned long dwordU;
typedef unsigned short wordU;

d83 1
a83 1
ins currInsn;
d85 1
a85 1
wordU words[3];
d87 1
a87 1
ULONGLONG allWords;
d281 1
a281 1
/* START and END are relating 'allWords' struct, which is 48 bits size.
d317 1
a317 1
static int
d322 2
a323 1
  unsigned long doubleWord = (words[1] + (words[0] << 16)) & 0xffffffff;
d361 3
a363 2
      p = makelongparameter (allWords, inst_bit_size - (start_bits + a->size),
                             inst_bit_size - start_bits);
d368 3
a370 2
      p = makelongparameter (allWords, inst_bit_size - (start_bits + a->size),
                             inst_bit_size - start_bits);
d375 3
a377 2
      p = makelongparameter (allWords, inst_bit_size - (start_bits + a->size),
                             inst_bit_size - start_bits);
d382 3
a384 2
      p = makelongparameter (allWords, inst_bit_size - (start_bits + a->size),
                             inst_bit_size - start_bits);
d389 3
a391 2
      p = makelongparameter (allWords, inst_bit_size - (start_bits + a->size),
                             inst_bit_size - start_bits);
d396 3
a398 2
      p = makelongparameter (allWords, inst_bit_size - (start_bits + a->size),
                             inst_bit_size - start_bits);
d407 1
a407 1
	p = makelongparameter (allWords, 8, 9);
d409 1
a409 1
	p = makelongparameter (allWords, 9, 10);
d411 2
a412 1
      p = makelongparameter (allWords, inst_bit_size - a->size, inst_bit_size);
d417 1
a417 1
      p = makelongparameter (allWords, start_bits + 12, start_bits + 13);
d419 1
a419 1
      p = makelongparameter (allWords, start_bits + 13, start_bits + 16);
d423 1
a423 1
	  p = makelongparameter (allWords, inst_bit_size - start_bits - 12,
d429 2
a430 1
	  p = makelongparameter (allWords, inst_bit_size - 22, inst_bit_size);
d440 1
a440 1
      p = makelongparameter (allWords, inst_bit_size, inst_bit_size);
d442 1
a442 1
      p = makelongparameter (allWords, inst_bit_size - (start_bits + 4),
d448 1
a448 1
      p = makelongparameter (allWords, start_bits + 12, start_bits + 16);
d450 1
a450 1
      p = makelongparameter (allWords, inst_bit_size - 16, inst_bit_size);
d456 1
a456 1
	p = makelongparameter (allWords, 12, 16);
d458 1
a458 1
	p = makelongparameter (allWords, start_bits + 12, start_bits + 16);
d463 1
a463 1
	  p = makelongparameter (allWords, inst_bit_size - start_bits - 12,
d469 2
a470 1
	  p = makelongparameter (allWords, inst_bit_size - 16, inst_bit_size);
d475 1
a475 1
	  p = makelongparameter (allWords, 4, 8);
d499 1
a499 1
	      p = makelongparameter (allWords, 0, start_bits);
d506 1
a506 1
		  p = makelongparameter (allWords, 16, inst_bit_size);
d513 1
a513 1
		  p = makelongparameter (allWords, 8, inst_bit_size);
d519 3
a521 2
	      p = makelongparameter (allWords, inst_bit_size - (start_bits +
								a->size), inst_bit_size - start_bits);
d528 2
a529 2
	  p = makelongparameter (allWords, inst_bit_size -
				 (start_bits + a->size),
d745 1
a745 1
static void
d751 1
a751 1
  for (i = 0; i < currInsn.nargs; i++)
d761 1
a761 1
      currInsn.arg[i] = a;
d765 1
a765 1
  currInsn.size = instruction->size + (size_changed ? 1 : 0);
d767 1
a767 1
  currInsn.size *= 2;
d796 1
a796 1
    words[i] = get_word_at_PC (mem, info);
d798 2
a799 2
  allWords =
    ((ULONGLONG) words[0] << 32) + ((unsigned long) words[1] << 16) + words[2];
d818 1
a818 1
  if (is_decoded > 0 && (words[0] << 16 || words[1]) != 0)
d825 1
a825 1
      if (((currInsn.nargs = get_number_of_operands ()) != 0)
d830 4
a833 4
      if ((INST_HAS_REG_LIST) && ((words[0] >> 7) & 0x1))
        currInsn.nargs +=1;
      print_arguments (&currInsn, memaddr, info);
      return currInsn.size;
@


1.8
log
@	PR binutils/10173
	* cr16-dis.c (print_arg): Test symtab_size not num_symbols.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.7
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 2007, 2008, 2009  Free Software Foundation, Inc.
d682 1
a682 1
      if (info->num_symbols > 0)
@


1.6
log
@        PR 10173
        * cr16-dis.c (print_arg): Avoid printing the 0x prefix twice.
@
text
@d165 1
a165 1
getccstring (unsigned cc)
d167 1
a167 1
  return (char *) cr16_b_cond_tab[cc];
d190 1
a190 1
gettrapstring (unsigned int index)
d195 1
a195 1
    if (trap->entry == index)
d206 1
a206 1
  const reg_entry *reg = cr16_regtab + r;
d208 1
a208 1
  if (reg->type != CR16_R_REGTYPE)
d211 1
a211 1
  return reg->name;
d219 1
a219 1
  const reg_entry *reg = cr16_regptab + r;
d221 1
a221 1
  if (reg->type != CR16_RP_REGTYPE)
d224 1
a224 1
  return reg->name;
d232 1
a232 1
  const reg_entry *reg;
d248 1
a248 1
  reg = cr16_regptab + r;
d250 1
a250 1
  if (reg->type != CR16_RP_REGTYPE)
d253 1
a253 1
  return reg->name;
d259 1
a259 1
getprocregname (int index)
d264 1
a264 1
    if (r->image == index)
d273 1
a273 1
getprocpregname (int index)
d278 1
a278 1
    if (r->image == index)
d700 1
a700 1
print_arguments (ins *currInsn, bfd_vma memaddr, struct disassemble_info *info)
d708 1
a708 1
      && currInsn->nargs == 1)
d714 1
a714 1
  for (i = 0; i < currInsn->nargs; i++)
d728 1
a728 1
        print_arg (&currInsn->arg[i], memaddr, info);
d730 1
a730 1
      if ((i != currInsn->nargs - 1) && (!IS_INSN_MNEMONIC ("b")))
@


1.5
log
@

	* cr16-dis.c (match_opcode): Truncate mcode to 32 bit and
	adjusted the mask for 32-bit branch instruction.
@
text
@d2 1
a2 1
   Copyright 2007, 2008 Free Software Foundation, Inc.
d681 3
a683 1
      func (stream, "%s", "0x");
@


1.4
log
@        * cr16-dis.c (build_mask): Adjust the mask for 32-bit bcond.
@
text
@d325 1
a325 1
  unsigned long doubleWord = words[1] + (words[0] << 16);
d334 4
@


1.3
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 2007 Free Software Foundation, Inc.
d310 5
@


1.2
log
@* cr16-dis.c (getcinvstring): Add const qualifier to char * parameter.
  (print_insn_cr16): Remove cast to char *.
@
text
@d7 3
a9 3
   This program is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2, or (at your option)
@


1.1
log
@New port: National Semiconductor's CR16
@
text
@d175 1
a175 1
getcinvstring (char *str)
d802 1
a802 1
        info->fprintf_func (info->stream,"%s", getcinvstring ((char *)instruction->mnemonic));
@

