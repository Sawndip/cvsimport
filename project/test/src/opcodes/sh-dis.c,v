head	1.30;
access;
symbols
	sid-snapshot-20180601:1.30
	sid-snapshot-20180501:1.30
	sid-snapshot-20180401:1.30
	sid-snapshot-20180301:1.30
	sid-snapshot-20180201:1.30
	sid-snapshot-20180101:1.30
	sid-snapshot-20171201:1.30
	sid-snapshot-20171101:1.30
	sid-snapshot-20171001:1.30
	sid-snapshot-20170901:1.30
	sid-snapshot-20170801:1.30
	sid-snapshot-20170701:1.30
	sid-snapshot-20170601:1.30
	sid-snapshot-20170501:1.30
	sid-snapshot-20170401:1.30
	sid-snapshot-20170301:1.30
	sid-snapshot-20170201:1.30
	sid-snapshot-20170101:1.30
	sid-snapshot-20161201:1.30
	sid-snapshot-20161101:1.30
	sid-snapshot-20160901:1.30
	sid-snapshot-20160801:1.30
	sid-snapshot-20160701:1.30
	sid-snapshot-20160601:1.30
	sid-snapshot-20160501:1.30
	sid-snapshot-20160401:1.30
	sid-snapshot-20160301:1.30
	sid-snapshot-20160201:1.30
	sid-snapshot-20160101:1.30
	sid-snapshot-20151201:1.30
	sid-snapshot-20151101:1.30
	sid-snapshot-20151001:1.30
	sid-snapshot-20150901:1.30
	sid-snapshot-20150801:1.30
	sid-snapshot-20150701:1.30
	sid-snapshot-20150601:1.30
	sid-snapshot-20150501:1.30
	sid-snapshot-20150401:1.30
	sid-snapshot-20150301:1.30
	sid-snapshot-20150201:1.30
	sid-snapshot-20150101:1.30
	sid-snapshot-20141201:1.30
	sid-snapshot-20141101:1.30
	sid-snapshot-20141001:1.30
	sid-snapshot-20140901:1.30
	sid-snapshot-20140801:1.30
	sid-snapshot-20140701:1.30
	sid-snapshot-20140601:1.30
	sid-snapshot-20140501:1.30
	sid-snapshot-20140401:1.30
	sid-snapshot-20140301:1.30
	sid-snapshot-20140201:1.30
	sid-snapshot-20140101:1.30
	sid-snapshot-20131201:1.30
	sid-snapshot-20131101:1.30
	sid-snapshot-20131001:1.30
	binutils-2_24-branch:1.30.0.4
	binutils-2_24-branchpoint:1.30
	binutils-2_21_1:1.28
	sid-snapshot-20130901:1.30
	gdb_7_6_1-2013-08-30-release:1.30
	sid-snapshot-20130801:1.30
	sid-snapshot-20130701:1.30
	sid-snapshot-20130601:1.30
	sid-snapshot-20130501:1.30
	gdb_7_6-2013-04-26-release:1.30
	sid-snapshot-20130401:1.30
	binutils-2_23_2:1.29.4.1
	gdb_7_6-branch:1.30.0.2
	gdb_7_6-2013-03-12-branchpoint:1.30
	sid-snapshot-20130301:1.30
	sid-snapshot-20130201:1.30
	sid-snapshot-20130101:1.30
	sid-snapshot-20121201:1.30
	gdb_7_5_1-2012-11-29-release:1.29
	binutils-2_23_1:1.29.4.1
	sid-snapshot-20121101:1.30
	binutils-2_23:1.29.4.1
	sid-snapshot-20121001:1.30
	sid-snapshot-20120901:1.30
	gdb_7_5-2012-08-17-release:1.29
	sid-snapshot-20120801:1.30
	binutils-2_23-branch:1.29.0.4
	binutils-2_23-branchpoint:1.29
	gdb_7_5-branch:1.29.0.2
	gdb_7_5-2012-07-18-branchpoint:1.29
	sid-snapshot-20120701:1.29
	sid-snapshot-20120601:1.29
	sid-snapshot-20120501:1.28
	binutils-2_22_branch:1.28.0.18
	gdb_7_4_1-2012-04-26-release:1.28
	sid-snapshot-20120401:1.28
	sid-snapshot-20120301:1.28
	sid-snapshot-20120201:1.28
	gdb_7_4-2012-01-24-release:1.28
	sid-snapshot-20120101:1.28
	gdb_7_4-branch:1.28.0.16
	gdb_7_4-2011-12-13-branchpoint:1.28
	sid-snapshot-20111201:1.28
	binutils-2_22:1.28
	sid-snapshot-20111101:1.28
	sid-snapshot-20111001:1.28
	binutils-2_22-branch:1.28.0.14
	binutils-2_22-branchpoint:1.28
	gdb_7_3_1-2011-09-04-release:1.28
	sid-snapshot-20110901:1.28
	sid-snapshot-20110801:1.28
	gdb_7_3-2011-07-26-release:1.28
	sid-snapshot-20110701:1.28
	sid-snapshot-20110601:1.28
	sid-snapshot-20110501:1.28
	gdb_7_3-branch:1.28.0.12
	gdb_7_3-2011-04-01-branchpoint:1.28
	sid-snapshot-20110401:1.28
	sid-snapshot-20110301:1.28
	sid-snapshot-20110201:1.28
	sid-snapshot-20110101:1.28
	binutils-2_21:1.28
	sid-snapshot-20101201:1.28
	binutils-2_21-branch:1.28.0.10
	binutils-2_21-branchpoint:1.28
	sid-snapshot-20101101:1.28
	sid-snapshot-20101001:1.28
	binutils-2_20_1:1.28
	gdb_7_2-2010-09-02-release:1.28
	sid-snapshot-20100901:1.28
	sid-snapshot-20100801:1.28
	gdb_7_2-branch:1.28.0.8
	gdb_7_2-2010-07-07-branchpoint:1.28
	sid-snapshot-20100701:1.28
	sid-snapshot-20100601:1.28
	sid-snapshot-20100501:1.28
	sid-snapshot-20100401:1.28
	gdb_7_1-2010-03-18-release:1.28
	sid-snapshot-20100301:1.28
	gdb_7_1-branch:1.28.0.6
	gdb_7_1-2010-02-18-branchpoint:1.28
	sid-snapshot-20100201:1.28
	sid-snapshot-20100101:1.28
	gdb_7_0_1-2009-12-22-release:1.28
	sid-snapshot-20091201:1.28
	sid-snapshot-20091101:1.28
	binutils-2_20:1.28
	gdb_7_0-2009-10-06-release:1.28
	sid-snapshot-20091001:1.28
	gdb_7_0-branch:1.28.0.4
	gdb_7_0-2009-09-16-branchpoint:1.28
	arc-sim-20090309:1.27
	binutils-arc-20081103-branch:1.27.0.30
	binutils-arc-20081103-branchpoint:1.27
	binutils-2_20-branch:1.28.0.2
	binutils-2_20-branchpoint:1.28
	sid-snapshot-20090901:1.27
	sid-snapshot-20090801:1.27
	msnyder-checkpoint-072509-branch:1.27.0.28
	msnyder-checkpoint-072509-branchpoint:1.27
	sid-snapshot-20090701:1.27
	dje-cgen-play1-branch:1.27.0.26
	dje-cgen-play1-branchpoint:1.27
	sid-snapshot-20090601:1.27
	sid-snapshot-20090501:1.27
	sid-snapshot-20090401:1.27
	arc-20081103-branch:1.27.0.24
	arc-20081103-branchpoint:1.27
	arc-insight_6_8-branch:1.27.0.22
	arc-insight_6_8-branchpoint:1.27
	insight_6_8-branch:1.27.0.20
	insight_6_8-branchpoint:1.27
	sid-snapshot-20090301:1.27
	binutils-2_19_1:1.27
	sid-snapshot-20090201:1.27
	sid-snapshot-20090101:1.27
	reverse-20081226-branch:1.27.0.18
	reverse-20081226-branchpoint:1.27
	sid-snapshot-20081201:1.27
	multiprocess-20081120-branch:1.27.0.16
	multiprocess-20081120-branchpoint:1.27
	sid-snapshot-20081101:1.27
	binutils-2_19:1.27
	sid-snapshot-20081001:1.27
	reverse-20080930-branch:1.27.0.14
	reverse-20080930-branchpoint:1.27
	binutils-2_19-branch:1.27.0.12
	binutils-2_19-branchpoint:1.27
	sid-snapshot-20080901:1.27
	sid-snapshot-20080801:1.27
	reverse-20080717-branch:1.27.0.10
	reverse-20080717-branchpoint:1.27
	sid-snapshot-20080701:1.27
	msnyder-reverse-20080609-branch:1.27.0.8
	msnyder-reverse-20080609-branchpoint:1.27
	drow-reverse-20070409-branch:1.26.0.4
	drow-reverse-20070409-branchpoint:1.26
	sid-snapshot-20080601:1.27
	sid-snapshot-20080501:1.27
	sid-snapshot-20080403:1.27
	sid-snapshot-20080401:1.27
	gdb_6_8-2008-03-27-release:1.27
	sid-snapshot-20080301:1.27
	gdb_6_8-branch:1.27.0.6
	gdb_6_8-2008-02-26-branchpoint:1.27
	sid-snapshot-20080201:1.27
	sid-snapshot-20080101:1.27
	sid-snapshot-20071201:1.27
	sid-snapshot-20071101:1.27
	gdb_6_7_1-2007-10-29-release:1.27
	gdb_6_7-2007-10-10-release:1.27
	sid-snapshot-20071001:1.27
	gdb_6_7-branch:1.27.0.4
	gdb_6_7-2007-09-07-branchpoint:1.27
	binutils-2_18:1.27
	binutils-2_18-branch:1.27.0.2
	binutils-2_18-branchpoint:1.27
	insight_6_6-20070208-release:1.26
	binutils-csl-coldfire-4_1-32:1.25
	binutils-csl-sourcerygxx-4_1-32:1.25
	gdb_6_6-2006-12-18-release:1.26
	binutils-csl-innovasic-fido-3_4_4-33:1.25
	binutils-csl-sourcerygxx-3_4_4-32:1.23
	binutils-csl-coldfire-4_1-30:1.25
	binutils-csl-sourcerygxx-4_1-30:1.25
	binutils-csl-coldfire-4_1-28:1.25
	binutils-csl-sourcerygxx-4_1-29:1.25
	binutils-csl-sourcerygxx-4_1-28:1.25
	gdb_6_6-branch:1.26.0.2
	gdb_6_6-2006-11-15-branchpoint:1.26
	binutils-csl-arm-2006q3-27:1.25
	binutils-csl-sourcerygxx-4_1-27:1.25
	binutils-csl-arm-2006q3-26:1.25
	binutils-csl-sourcerygxx-4_1-26:1.25
	binutils-csl-sourcerygxx-4_1-25:1.25
	binutils-csl-sourcerygxx-4_1-24:1.25
	binutils-csl-sourcerygxx-4_1-23:1.25
	insight_6_5-20061003-release:1.25
	gdb-csl-symbian-6_4_50_20060226-12:1.25
	binutils-csl-sourcerygxx-4_1-21:1.25
	binutils-csl-arm-2006q3-21:1.25
	binutils-csl-sourcerygxx-4_1-22:1.25
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.25
	binutils-csl-sourcerygxx-4_1-20:1.25
	binutils-csl-arm-2006q3-19:1.25
	binutils-csl-sourcerygxx-4_1-19:1.25
	binutils-csl-sourcerygxx-4_1-18:1.25
	binutils-csl-renesas-4_1-9:1.25
	gdb-csl-sourcerygxx-3_4_4-25:1.25
	binutils-csl-sourcerygxx-3_4_4-25:1.23
	nickrob-async-20060828-mergepoint:1.25
	gdb-csl-symbian-6_4_50_20060226-11:1.25
	binutils-csl-renesas-4_1-8:1.25
	binutils-csl-renesas-4_1-7:1.25
	binutils-csl-renesas-4_1-6:1.25
	gdb-csl-sourcerygxx-4_1-17:1.25
	binutils-csl-sourcerygxx-4_1-17:1.25
	gdb-csl-20060226-branch-local-2:1.25
	gdb-csl-sourcerygxx-4_1-14:1.25
	binutils-csl-sourcerygxx-4_1-14:1.25
	binutils-csl-sourcerygxx-4_1-15:1.25
	gdb-csl-sourcerygxx-4_1-13:1.25
	binutils-csl-sourcerygxx-4_1-13:1.25
	binutils-2_17:1.25
	gdb-csl-sourcerygxx-4_1-12:1.25
	binutils-csl-sourcerygxx-4_1-12:1.25
	gdb-csl-sourcerygxx-3_4_4-21:1.25
	binutils-csl-sourcerygxx-3_4_4-21:1.25
	gdb_6_5-20060621-release:1.25
	binutils-csl-wrs-linux-3_4_4-24:1.23
	binutils-csl-wrs-linux-3_4_4-23:1.23
	gdb-csl-sourcerygxx-4_1-9:1.25
	binutils-csl-sourcerygxx-4_1-9:1.25
	gdb-csl-sourcerygxx-4_1-8:1.25
	binutils-csl-sourcerygxx-4_1-8:1.25
	gdb-csl-sourcerygxx-4_1-7:1.25
	binutils-csl-sourcerygxx-4_1-7:1.25
	gdb-csl-arm-2006q1-6:1.25
	binutils-csl-arm-2006q1-6:1.25
	gdb-csl-sourcerygxx-4_1-6:1.25
	binutils-csl-sourcerygxx-4_1-6:1.25
	binutils-csl-wrs-linux-3_4_4-22:1.23
	gdb-csl-symbian-6_4_50_20060226-10:1.25
	gdb-csl-symbian-6_4_50_20060226-9:1.25
	gdb-csl-symbian-6_4_50_20060226-8:1.25
	gdb-csl-coldfire-4_1-11:1.25
	binutils-csl-coldfire-4_1-11:1.25
	gdb-csl-sourcerygxx-3_4_4-19:1.25
	binutils-csl-sourcerygxx-3_4_4-19:1.25
	gdb-csl-coldfire-4_1-10:1.25
	gdb_6_5-branch:1.25.0.28
	gdb_6_5-2006-05-14-branchpoint:1.25
	binutils-csl-coldfire-4_1-10:1.25
	gdb-csl-sourcerygxx-4_1-5:1.25
	binutils-csl-sourcerygxx-4_1-5:1.25
	nickrob-async-20060513-branch:1.25.0.26
	nickrob-async-20060513-branchpoint:1.25
	gdb-csl-sourcerygxx-4_1-4:1.25
	binutils-csl-sourcerygxx-4_1-4:1.25
	msnyder-reverse-20060502-branch:1.25.0.24
	msnyder-reverse-20060502-branchpoint:1.25
	binutils-csl-wrs-linux-3_4_4-21:1.23
	gdb-csl-morpho-4_1-4:1.25
	binutils-csl-morpho-4_1-4:1.25
	gdb-csl-sourcerygxx-3_4_4-17:1.25
	binutils-csl-sourcerygxx-3_4_4-17:1.25
	binutils-csl-wrs-linux-3_4_4-20:1.23
	readline_5_1-import-branch:1.25.0.22
	readline_5_1-import-branchpoint:1.25
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.25
	binutils-2_17-branch:1.25.0.20
	binutils-2_17-branchpoint:1.25
	gdb-csl-symbian-20060226-branch:1.25.0.18
	gdb-csl-symbian-20060226-branchpoint:1.25
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.25
	msnyder-reverse-20060331-branch:1.25.0.16
	msnyder-reverse-20060331-branchpoint:1.25
	binutils-csl-2_17-branch:1.25.0.14
	binutils-csl-2_17-branchpoint:1.25
	gdb-csl-available-20060303-branch:1.25.0.12
	gdb-csl-available-20060303-branchpoint:1.25
	gdb-csl-20060226-branch:1.25.0.10
	gdb-csl-20060226-branchpoint:1.25
	gdb_6_4-20051202-release:1.25
	msnyder-fork-checkpoint-branch:1.25.0.8
	msnyder-fork-checkpoint-branchpoint:1.25
	gdb-csl-gxxpro-6_3-branch:1.25.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.25
	gdb_6_4-branch:1.25.0.4
	gdb_6_4-2005-11-01-branchpoint:1.25
	gdb-csl-arm-20051020-branch:1.25.0.2
	gdb-csl-arm-20051020-branchpoint:1.25
	binutils-csl-gxxpro-3_4-branch:1.23.0.10
	binutils-csl-gxxpro-3_4-branchpoint:1.23
	binutils-2_16_1:1.23
	msnyder-tracepoint-checkpoint-branch:1.24.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.24
	gdb-csl-arm-20050325-2005-q1b:1.23
	binutils-csl-arm-2005q1b:1.23
	binutils-2_16:1.23
	gdb-csl-arm-20050325-2005-q1a:1.23
	binutils-csl-arm-2005q1a:1.23
	csl-arm-20050325-branch:1.23.0.8
	csl-arm-20050325-branchpoint:1.23
	binutils-csl-arm-2005q1-branch:1.23.0.6
	binutils-csl-arm-2005q1-branchpoint:1.23
	binutils-2_16-branch:1.23.0.4
	binutils-2_16-branchpoint:1.23
	csl-arm-2004-q3d:1.23
	gdb_6_3-20041109-release:1.23
	gdb_6_3-branch:1.23.0.2
	gdb_6_3-20041019-branchpoint:1.23
	csl-arm-2004-q3:1.23
	drow_intercu-merge-20040921:1.23
	drow_intercu-merge-20040915:1.23
	jimb-gdb_6_2-e500-branch:1.22.0.6
	jimb-gdb_6_2-e500-branchpoint:1.22
	gdb_6_2-20040730-release:1.22
	gdb_6_2-branch:1.22.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.22
	gdb_6_1_1-20040616-release:1.19
	binutils-2_15:1.18.6.1
	binutils-2_15-branchpoint:1.18
	csl-arm-2004-q1a:1.21
	csl-arm-2004-q1:1.20
	gdb_6_1-2004-04-05-release:1.19
	drow_intercu-merge-20040402:1.20
	drow_intercu-merge-20040327:1.20
	ezannoni_pie-20040323-branch:1.20.0.4
	ezannoni_pie-20040323-branchpoint:1.20
	cagney_tramp-20040321-mergepoint:1.20
	cagney_tramp-20040309-branch:1.20.0.2
	cagney_tramp-20040309-branchpoint:1.20
	gdb_6_1-branch:1.19.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.19
	drow_intercu-20040221-branch:1.18.0.8
	drow_intercu-20040221-branchpoint:1.18
	binutils-2_15-branch:1.18.0.6
	cagney_bfdfile-20040213-branch:1.18.0.4
	cagney_bfdfile-20040213-branchpoint:1.18
	drow-cplus-merge-20040208:1.18
	carlton_dictionary-20040126-merge:1.18
	cagney_bigcore-20040122-branch:1.18.0.2
	cagney_bigcore-20040122-branchpoint:1.18
	drow-cplus-merge-20040113:1.17
	csl-arm-2003-q4:1.17
	drow-cplus-merge-20031224:1.17
	drow-cplus-merge-20031220:1.17
	carlton_dictionary-20031215-merge:1.17
	drow-cplus-merge-20031214:1.17
	carlton-dictionary-20031111-merge:1.16
	gdb_6_0-2003-10-04-release:1.16
	kettenis_sparc-20030918-branch:1.16.0.40
	kettenis_sparc-20030918-branchpoint:1.16
	carlton_dictionary-20030917-merge:1.16
	ezannoni_pie-20030916-branchpoint:1.16
	ezannoni_pie-20030916-branch:1.16.0.38
	cagney_x86i386-20030821-branch:1.16.0.36
	cagney_x86i386-20030821-branchpoint:1.16
	carlton_dictionary-20030805-merge:1.16
	carlton_dictionary-20030627-merge:1.16
	gdb_6_0-branch:1.16.0.34
	gdb_6_0-2003-06-23-branchpoint:1.16
	jimb-ppc64-linux-20030613-branch:1.16.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.16
	binutils-2_14:1.16
	cagney_convert-20030606-branch:1.16.0.30
	cagney_convert-20030606-branchpoint:1.16
	cagney_writestrings-20030508-branch:1.16.0.28
	cagney_writestrings-20030508-branchpoint:1.16
	jimb-ppc64-linux-20030528-branch:1.16.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.16
	carlton_dictionary-20030523-merge:1.16
	cagney_fileio-20030521-branch:1.16.0.24
	cagney_fileio-20030521-branchpoint:1.16
	kettenis_i386newframe-20030517-mergepoint:1.16
	jimb-ppc64-linux-20030509-branch:1.16.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.16
	kettenis_i386newframe-20030504-mergepoint:1.16
	carlton_dictionary-20030430-merge:1.16
	binutils-2_14-branch:1.16.0.20
	binutils-2_14-branchpoint:1.16
	kettenis_i386newframe-20030419-branch:1.16.0.18
	kettenis_i386newframe-20030419-branchpoint:1.16
	carlton_dictionary-20030416-merge:1.16
	cagney_frameaddr-20030409-mergepoint:1.16
	kettenis_i386newframe-20030406-branch:1.16.0.16
	kettenis_i386newframe-20030406-branchpoint:1.16
	cagney_frameaddr-20030403-branchpoint:1.16
	cagney_frameaddr-20030403-branch:1.16.0.14
	cagney_framebase-20030330-mergepoint:1.16
	cagney_framebase-20030326-branch:1.16.0.12
	cagney_framebase-20030326-branchpoint:1.16
	cagney_lazyid-20030317-branch:1.16.0.10
	cagney_lazyid-20030317-branchpoint:1.16
	kettenis-i386newframe-20030316-mergepoint:1.16
	offbyone-20030313-branch:1.16.0.8
	offbyone-20030313-branchpoint:1.16
	kettenis-i386newframe-20030308-branch:1.16.0.6
	kettenis-i386newframe-20030308-branchpoint:1.16
	carlton_dictionary-20030305-merge:1.16
	cagney_offbyone-20030303-branch:1.16.0.4
	cagney_offbyone-20030303-branchpoint:1.16
	carlton_dictionary-20030207-merge:1.16
	interps-20030202-branch:1.16.0.2
	interps-20030202-branchpoint:1.16
	cagney-unwind-20030108-branch:1.15.0.2
	cagney-unwind-20030108-branchpoint:1.15
	binutils-2_13_2_1:1.13
	binutils-2_13_2:1.13
	carlton_dictionary-20021223-merge:1.15
	gdb_5_3-2002-12-12-release:1.13
	carlton_dictionary-20021115-merge:1.13
	binutils-2_13_1:1.13
	kseitz_interps-20021105-merge:1.13
	kseitz_interps-20021103-merge:1.13
	drow-cplus-merge-20021020:1.13
	drow-cplus-merge-20021025:1.13
	carlton_dictionary-20021025-merge:1.13
	carlton_dictionary-20021011-merge:1.13
	drow-cplus-branch:1.13.0.16
	drow-cplus-branchpoint:1.13
	kseitz_interps-20020930-merge:1.13
	carlton_dictionary-20020927-merge:1.13
	carlton_dictionary-branch:1.13.0.14
	carlton_dictionary-20020920-branchpoint:1.13
	sid-20020905-branchpoint:1.13
	sid-20020905-branch:1.13.0.12
	gdb_5_3-branch:1.13.0.10
	gdb_5_3-2002-09-04-branchpoint:1.13
	kseitz_interps-20020829-merge:1.13
	cagney_sysregs-20020825-branch:1.13.0.8
	cagney_sysregs-20020825-branchpoint:1.13
	readline_4_3-import-branch:1.13.0.6
	readline_4_3-import-branchpoint:1.13
	binutils-2_13:1.13
	gdb_5_2_1-2002-07-23-release:1.10
	binutils-2_13-branchpoint:1.13
	binutils-2_13-branch:1.13.0.4
	kseitz_interps-20020528-branch:1.13.0.2
	kseitz_interps-20020528-branchpoint:1.13
	cagney_regbuf-20020515-branch:1.10.0.8
	cagney_regbuf-20020515-branchpoint:1.10
	binutils-2_12_1:1.10
	jimb-macro-020506-branch:1.10.0.6
	jimb-macro-020506-branchpoint:1.10
	gdb_5_2-2002-04-29-release:1.10
	binutils-2_12:1.10
	gdb_5_2-branch:1.10.0.4
	gdb_5_2-2002-03-03-branchpoint:1.10
	binutils-2_12-branch:1.10.0.2
	binutils-2_12-branchpoint:1.10
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	binutils-2_11_2:1.6.2.1
	binutils-2_11_1:1.6.2.1
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	insight-precleanup-2001-01-01:1.6
	binutils-2_10_1:1.2.2.1
	binutils-2_10:1.2.2.1
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.30
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2012.08.01.00.41.35;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches
	1.29.4.1;
next	1.28;

1.28
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.20.14.47.05;	author ams;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.01.11.16.33;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.07.07.34.31;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.29.05.19.27;	author aoliva;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.28.12.32.09;	author amylaar;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.23.02.47.39;	author kkojima;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.03.18.01.47;	author amylaar;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.26.16.14.42;	author amylaar;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.13.19.56.46;	author msnyder;	state Exp;
branches
	1.18.6.1
	1.18.8.1;
next	1.17;

1.17
date	2003.12.05.02.02.32;	author msnyder;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.23.18.50.57;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.02.13.13.37;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.22.18.16.45;	author amylaar;	state Exp;
branches
	1.13.14.1
	1.13.16.1;
next	1.12;

1.12
date	2002.05.22.13.17.27;	author amylaar;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.17.14.36.45;	author amylaar;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.08.05.51.03;	author aoliva;	state Exp;
branches
	1.10.8.1;
next	1.9;

1.9
date	2001.10.09.12.25.22;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.26.11.47.38;	author aj;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.13.22.58.37;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.28.23.42.53;	author hp;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.08.26.18.50.14;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.05.21.22.59;	author amylaar;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.17.00.33.36;	author amylaar;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.29.4.1
date	2012.09.04.14.01.41;	author gingold;	state Exp;
branches;
next	;

1.18.6.1
date	2004.04.09.18.28.17;	author drow;	state Exp;
branches;
next	;

1.18.8.1
date	2004.03.27.17.38.13;	author drow;	state Exp;
branches;
next	1.18.8.2;

1.18.8.2
date	2004.09.16.17.02.02;	author drow;	state Exp;
branches;
next	;

1.13.14.1
date	2002.12.23.19.39.37;	author carlton;	state Exp;
branches;
next	1.13.14.2;

1.13.14.2
date	2003.02.07.19.18.04;	author carlton;	state Exp;
branches;
next	1.13.14.3;

1.13.14.3
date	2003.12.16.00.01.18;	author carlton;	state Exp;
branches;
next	1.13.14.4;

1.13.14.4
date	2004.01.26.19.11.50;	author carlton;	state Exp;
branches;
next	;

1.13.16.1
date	2003.12.14.20.28.10;	author drow;	state Exp;
branches;
next	1.13.16.2;

1.13.16.2
date	2004.02.09.19.44.01;	author drow;	state Exp;
branches;
next	;

1.10.8.1
date	2002.06.15.16.43.20;	author cagney;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.18.36;	author amodra;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.10.09.13.37.59;	author nickc;	state Exp;
branches;
next	;

1.2.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches;
next	;


desc
@@


1.30
log
@	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@/* Disassemble SH instructions.
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2012  Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this file; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdio.h>

#define STATIC_TABLE
#define DEFINE_TABLE

#include "sh-opc.h"
#include "dis-asm.h"

#ifdef ARCH_all
#define INCLUDE_SHMEDIA
#endif

static void
print_movxy (const sh_opcode_info *op,
	     int rn,
	     int rm,
	     fprintf_ftype fprintf_fn,
	     void *stream)
{
  int n;

  fprintf_fn (stream, "%s\t", op->name);
  for (n = 0; n < 2; n++)
    {
      switch (op->arg[n])
	{
	case A_IND_N:
	case AX_IND_N:
	case AXY_IND_N:
	case AY_IND_N:
	case AYX_IND_N:
	  fprintf_fn (stream, "@@r%d", rn);
	  break;
	case A_INC_N:
	case AX_INC_N:
	case AXY_INC_N:
	case AY_INC_N:
	case AYX_INC_N:
	  fprintf_fn (stream, "@@r%d+", rn);
	  break;
	case AX_PMOD_N:
	case AXY_PMOD_N:
	  fprintf_fn (stream, "@@r%d+r8", rn);
	  break;
	case AY_PMOD_N:
	case AYX_PMOD_N:
	  fprintf_fn (stream, "@@r%d+r9", rn);
	  break;
	case DSP_REG_A_M:
	  fprintf_fn (stream, "a%c", '0' + rm);
	  break;
	case DSP_REG_X:
	  fprintf_fn (stream, "x%c", '0' + rm);
	  break;
	case DSP_REG_Y:
	  fprintf_fn (stream, "y%c", '0' + rm);
	  break;
	case DSP_REG_AX:
	  fprintf_fn (stream, "%c%c",
		      (rm & 1) ? 'x' : 'a',
		      (rm & 2) ? '1' : '0');
	  break;
	case DSP_REG_XY:
	  fprintf_fn (stream, "%c%c",
		      (rm & 1) ? 'y' : 'x',
		      (rm & 2) ? '1' : '0');
	  break;
	case DSP_REG_AY:
	  fprintf_fn (stream, "%c%c",
		      (rm & 2) ? 'y' : 'a',
		      (rm & 1) ? '1' : '0');
	  break;
	case DSP_REG_YX:
	  fprintf_fn (stream, "%c%c",
		      (rm & 2) ? 'x' : 'y',
		      (rm & 1) ? '1' : '0');
	  break;
	default:
	  abort ();
	}
      if (n == 0)
	fprintf_fn (stream, ",");
    }
}

/* Print a double data transfer insn.  INSN is just the lower three
   nibbles of the insn, i.e. field a and the bit that indicates if
   a parallel processing insn follows.
   Return nonzero if a field b of a parallel processing insns follows.  */

static void
print_insn_ddt (int insn, struct disassemble_info *info)
{
  fprintf_ftype fprintf_fn = info->fprintf_func;
  void *stream = info->stream;

  /* If this is just a nop, make sure to emit something.  */
  if (insn == 0x000)
    fprintf_fn (stream, "nopx\tnopy");

  /* If a parallel processing insn was printed before,
     and we got a non-nop, emit a tab.  */
  if ((insn & 0x800) && (insn & 0x3ff))
    fprintf_fn (stream, "\t");

  /* Check if either the x or y part is invalid.  */
  if (((insn & 0xc) == 0 && (insn & 0x2a0))
      || ((insn & 3) == 0 && (insn & 0x150)))
    if (info->mach != bfd_mach_sh_dsp
        && info->mach != bfd_mach_sh3_dsp)
      {
	static const sh_opcode_info *first_movx, *first_movy;
	const sh_opcode_info *op;
	int is_movy;

	if (! first_movx)
	  {
	    for (first_movx = sh_table; first_movx->nibbles[1] != MOVX_NOPY;)
	      first_movx++;
	    for (first_movy = first_movx; first_movy->nibbles[1] != MOVY_NOPX;)
	      first_movy++;
	  }

	is_movy = ((insn & 3) != 0);

	if (is_movy)
	  op = first_movy;
	else
	  op = first_movx;

	while (op->nibbles[2] != (unsigned) ((insn >> 4) & 3)
	       || op->nibbles[3] != (unsigned) (insn & 0xf))
	  op++;
	
	print_movxy (op,
		     (4 * ((insn & (is_movy ? 0x200 : 0x100)) == 0)
		      + 2 * is_movy
		      + 1 * ((insn & (is_movy ? 0x100 : 0x200)) != 0)),
		     (insn >> 6) & 3,
		     fprintf_fn, stream);
      }
    else
      fprintf_fn (stream, ".word 0x%x", insn);
  else
    {
      static const sh_opcode_info *first_movx, *first_movy;
      const sh_opcode_info *opx, *opy;
      unsigned int insn_x, insn_y;

      if (! first_movx)
	{
	  for (first_movx = sh_table; first_movx->nibbles[1] != MOVX;)
	    first_movx++;
	  for (first_movy = first_movx; first_movy->nibbles[1] != MOVY;)
	    first_movy++;
	}
      insn_x = (insn >> 2) & 0xb;
      if (insn_x)
	{
	  for (opx = first_movx; opx->nibbles[2] != insn_x;)
	    opx++;
	  print_movxy (opx, ((insn >> 9) & 1) + 4, (insn >> 7) & 1,
		       fprintf_fn, stream);
	}
      insn_y = (insn & 3) | ((insn >> 1) & 8);
      if (insn_y)
	{
	  if (insn_x)
	    fprintf_fn (stream, "\t");
	  for (opy = first_movy; opy->nibbles[2] != insn_y;)
	    opy++;
	  print_movxy (opy, ((insn >> 8) & 1) + 6, (insn >> 6) & 1,
		       fprintf_fn, stream);
	}
    }
}

static void
print_dsp_reg (int rm, fprintf_ftype fprintf_fn, void *stream)
{
  switch (rm)
    {
    case A_A1_NUM:
      fprintf_fn (stream, "a1");
      break;
    case A_A0_NUM:
      fprintf_fn (stream, "a0");
      break;
    case A_X0_NUM:
      fprintf_fn (stream, "x0");
      break;
    case A_X1_NUM:
      fprintf_fn (stream, "x1");
      break;
    case A_Y0_NUM:
      fprintf_fn (stream, "y0");
      break;
    case A_Y1_NUM:
      fprintf_fn (stream, "y1");
      break;
    case A_M0_NUM:
      fprintf_fn (stream, "m0");
      break;
    case A_A1G_NUM:
      fprintf_fn (stream, "a1g");
      break;
    case A_M1_NUM:
      fprintf_fn (stream, "m1");
      break;
    case A_A0G_NUM:
      fprintf_fn (stream, "a0g");
      break;
    default:
      fprintf_fn (stream, "0x%x", rm);
      break;
    }
}

static void
print_insn_ppi (int field_b, struct disassemble_info *info)
{
  static char *sx_tab[] = { "x0", "x1", "a0", "a1" };
  static char *sy_tab[] = { "y0", "y1", "m0", "m1" };
  fprintf_ftype fprintf_fn = info->fprintf_func;
  void *stream = info->stream;
  unsigned int nib1, nib2, nib3;
  unsigned int altnib1, nib4;
  char *dc = NULL;
  const sh_opcode_info *op;

  if ((field_b & 0xe800) == 0)
    {
      fprintf_fn (stream, "psh%c\t#%d,",
		  field_b & 0x1000 ? 'a' : 'l',
		  (field_b >> 4) & 127);
      print_dsp_reg (field_b & 0xf, fprintf_fn, stream);
      return;
    }
  if ((field_b & 0xc000) == 0x4000 && (field_b & 0x3000) != 0x1000)
    {
      static char *du_tab[] = { "x0", "y0", "a0", "a1" };
      static char *se_tab[] = { "x0", "x1", "y0", "a1" };
      static char *sf_tab[] = { "y0", "y1", "x0", "a1" };
      static char *sg_tab[] = { "m0", "m1", "a0", "a1" };

      if (field_b & 0x2000)
	fprintf_fn (stream, "p%s %s,%s,%s\t",
		    (field_b & 0x1000) ? "add" : "sub",
		    sx_tab[(field_b >> 6) & 3],
		    sy_tab[(field_b >> 4) & 3],
		    du_tab[(field_b >> 0) & 3]);

      else if ((field_b & 0xf0) == 0x10
	       && info->mach != bfd_mach_sh_dsp
	       && info->mach != bfd_mach_sh3_dsp)
	fprintf_fn (stream, "pclr %s \t", du_tab[(field_b >> 0) & 3]);

      else if ((field_b & 0xf3) != 0)
	fprintf_fn (stream, ".word 0x%x\t", field_b);

      fprintf_fn (stream, "pmuls%c%s,%s,%s",
		  field_b & 0x2000 ? ' ' : '\t',
		  se_tab[(field_b >> 10) & 3],
		  sf_tab[(field_b >>  8) & 3],
		  sg_tab[(field_b >>  2) & 3]);
      return;
    }

  nib1 = PPIC;
  nib2 = field_b >> 12 & 0xf;
  nib3 = field_b >> 8 & 0xf;
  nib4 = field_b >> 4 & 0xf;
  switch (nib3 & 0x3)
    {
    case 0:
      dc = "";
      nib1 = PPI3;
      break;
    case 1:
      dc = "";
      break;
    case 2:
      dc = "dct ";
      nib3 -= 1;
      break;
    case 3:
      dc = "dcf ";
      nib3 -= 2;
      break;
    }
  if (nib1 == PPI3)
    altnib1 = PPI3NC;
  else
    altnib1 = nib1;
  for (op = sh_table; op->name; op++)
    {
      if ((op->nibbles[1] == nib1 || op->nibbles[1] == altnib1)
	  && op->nibbles[2] == nib2
	  && op->nibbles[3] == nib3)
	{
	  int n;

	  switch (op->nibbles[4])
	    {
	    case HEX_0:
	      break;
	    case HEX_XX00:
	      if ((nib4 & 3) != 0)
		continue;
	      break;
	    case HEX_1:
	      if ((nib4 & 3) != 1)
		continue;
	      break;
	    case HEX_00YY:
	      if ((nib4 & 0xc) != 0)
		continue;
	      break;
	    case HEX_4:
	      if ((nib4 & 0xc) != 4)
		continue;
	      break;
	    default:
	      abort ();
	    }
	  fprintf_fn (stream, "%s%s\t", dc, op->name);
	  for (n = 0; n < 3 && op->arg[n] != A_END; n++)
	    {
	      if (n && op->arg[1] != A_END)
		fprintf_fn (stream, ",");
	      switch (op->arg[n])
		{
		case DSP_REG_N:
		  print_dsp_reg (field_b & 0xf, fprintf_fn, stream);
		  break;
		case DSP_REG_X:
		  fprintf_fn (stream, "%s", sx_tab[(field_b >> 6) & 3]);
		  break;
		case DSP_REG_Y:
		  fprintf_fn (stream, "%s", sy_tab[(field_b >> 4) & 3]);
		  break;
		case A_MACH:
		  fprintf_fn (stream, "mach");
		  break;
		case A_MACL:
		  fprintf_fn (stream, "macl");
		  break;
		default:
		  abort ();
		}
	    }
	  return;
	}
    }
  /* Not found.  */
  fprintf_fn (stream, ".word 0x%x", field_b);
}

/* FIXME mvs: movx insns print as ".word 0x%03x", insn & 0xfff
   (ie. the upper nibble is missing).  */

int
print_insn_sh (bfd_vma memaddr, struct disassemble_info *info)
{
  fprintf_ftype fprintf_fn = info->fprintf_func;
  void *stream = info->stream;
  unsigned char insn[4];
  unsigned char nibs[8];
  int status;
  bfd_vma relmask = ~(bfd_vma) 0;
  const sh_opcode_info *op;
  unsigned int target_arch;
  int allow_op32;

  switch (info->mach)
    {
    case bfd_mach_sh:
      target_arch = arch_sh1;
      /* SH coff object files lack information about the machine type, so
         we end up with bfd_mach_sh unless it was set explicitly (which
	 could have happended if this is a call from gdb or the simulator.)  */
      if (info->symbols
	  && bfd_asymbol_flavour(*info->symbols) == bfd_target_coff_flavour)
	target_arch = arch_sh4;
      break;
    case bfd_mach_sh5:
#ifdef INCLUDE_SHMEDIA
      status = print_insn_sh64 (memaddr, info);
      if (status != -2)
	return status;
#endif
      /* When we get here for sh64, it's because we want to disassemble
	 SHcompact, i.e. arch_sh4.  */
      target_arch = arch_sh4;
      break;
    default:
      target_arch = sh_get_arch_from_bfd_mach (info->mach);
    }

  status = info->read_memory_func (memaddr, insn, 2, info);

  if (status != 0)
    {
      info->memory_error_func (status, memaddr, info);
      return -1;
    }

  if (info->endian == BFD_ENDIAN_LITTLE)
    {
      nibs[0] = (insn[1] >> 4) & 0xf;
      nibs[1] = insn[1] & 0xf;

      nibs[2] = (insn[0] >> 4) & 0xf;
      nibs[3] = insn[0] & 0xf;
    }
  else
    {
      nibs[0] = (insn[0] >> 4) & 0xf;
      nibs[1] = insn[0] & 0xf;

      nibs[2] = (insn[1] >> 4) & 0xf;
      nibs[3] = insn[1] & 0xf;
    }
  status = info->read_memory_func (memaddr + 2, insn + 2, 2, info);
  if (status != 0)
    allow_op32 = 0;
  else
    {
      allow_op32 = 1;

      if (info->endian == BFD_ENDIAN_LITTLE)
	{
	  nibs[4] = (insn[3] >> 4) & 0xf;
	  nibs[5] = insn[3] & 0xf;

	  nibs[6] = (insn[2] >> 4) & 0xf;
	  nibs[7] = insn[2] & 0xf;
	}
      else
	{
	  nibs[4] = (insn[2] >> 4) & 0xf;
	  nibs[5] = insn[2] & 0xf;

	  nibs[6] = (insn[3] >> 4) & 0xf;
	  nibs[7] = insn[3] & 0xf;
	}
    }

  if (nibs[0] == 0xf && (nibs[1] & 4) == 0
      && SH_MERGE_ARCH_SET_VALID (target_arch, arch_sh_dsp_up))
    {
      if (nibs[1] & 8)
	{
	  int field_b;

	  status = info->read_memory_func (memaddr + 2, insn, 2, info);

	  if (status != 0)
	    {
	      info->memory_error_func (status, memaddr + 2, info);
	      return -1;
	    }

	  if (info->endian == BFD_ENDIAN_LITTLE)
	    field_b = insn[1] << 8 | insn[0];
	  else
	    field_b = insn[0] << 8 | insn[1];

	  print_insn_ppi (field_b, info);
	  print_insn_ddt ((nibs[1] << 8) | (nibs[2] << 4) | nibs[3], info);
	  return 4;
	}
      print_insn_ddt ((nibs[1] << 8) | (nibs[2] << 4) | nibs[3], info);
      return 2;
    }
  for (op = sh_table; op->name; op++)
    {
      int n;
      int imm = 0;
      int rn = 0;
      int rm = 0;
      int rb = 0;
      int disp_pc;
      bfd_vma disp_pc_addr = 0;
      int disp = 0;
      int has_disp = 0;
      int max_n = SH_MERGE_ARCH_SET (op->arch, arch_op32) ? 8 : 4;

      if (!allow_op32
	  && SH_MERGE_ARCH_SET (op->arch, arch_op32))
	goto fail;

      if (!SH_MERGE_ARCH_SET_VALID (op->arch, target_arch))
	goto fail;
      for (n = 0; n < max_n; n++)
	{
	  int i = op->nibbles[n];

	  if (i < 16)
	    {
	      if (nibs[n] == i)
		continue;
	      goto fail;
	    }
	  switch (i)
	    {
	    case BRANCH_8:
	      imm = (nibs[2] << 4) | (nibs[3]);
	      if (imm & 0x80)
		imm |= ~0xff;
	      imm = ((char) imm) * 2 + 4;
	      goto ok;
	    case BRANCH_12:
	      imm = ((nibs[1]) << 8) | (nibs[2] << 4) | (nibs[3]);
	      if (imm & 0x800)
		imm |= ~0xfff;
	      imm = imm * 2 + 4;
	      goto ok;
	    case IMM0_3c:
	      if (nibs[3] & 0x8)
		goto fail;
	      imm = nibs[3] & 0x7;
	      break;
	    case IMM0_3s:
	      if (!(nibs[3] & 0x8))
		goto fail;
	      imm = nibs[3] & 0x7;
	      break;
	    case IMM0_3Uc:
	      if (nibs[2] & 0x8)
		goto fail;
	      imm = nibs[2] & 0x7;
	      break;
	    case IMM0_3Us:
	      if (!(nibs[2] & 0x8))
		goto fail;
	      imm = nibs[2] & 0x7;
	      break;
	    case DISP0_12:
	    case DISP1_12:
	      disp = (nibs[5] << 8) | (nibs[6] << 4) | nibs[7];
	      has_disp = 1;
	      goto ok;
	    case DISP0_12BY2:
	    case DISP1_12BY2:
	      disp = ((nibs[5] << 8) | (nibs[6] << 4) | nibs[7]) << 1;
	      relmask = ~(bfd_vma) 1;
	      has_disp = 1;
	      goto ok;
	    case DISP0_12BY4:
	    case DISP1_12BY4:
	      disp = ((nibs[5] << 8) | (nibs[6] << 4) | nibs[7]) << 2;
	      relmask = ~(bfd_vma) 3;
	      has_disp = 1;
	      goto ok;
	    case DISP0_12BY8:
	    case DISP1_12BY8:
	      disp = ((nibs[5] << 8) | (nibs[6] << 4) | nibs[7]) << 3;
	      relmask = ~(bfd_vma) 7;
	      has_disp = 1;
	      goto ok;
	    case IMM0_20_4:
	      break;
	    case IMM0_20:
	      imm = ((nibs[2] << 16) | (nibs[4] << 12) | (nibs[5] << 8)
		     | (nibs[6] << 4) | nibs[7]);
	      if (imm & 0x80000)
		imm -= 0x100000;
	      goto ok;
	    case IMM0_20BY8:
	      imm = ((nibs[2] << 16) | (nibs[4] << 12) | (nibs[5] << 8)
		     | (nibs[6] << 4) | nibs[7]);
	      imm <<= 8;
	      if (imm & 0x8000000)
		imm -= 0x10000000;
	      goto ok;
	    case IMM0_4:
	    case IMM1_4:
	      imm = nibs[3];
	      goto ok;
	    case IMM0_4BY2:
	    case IMM1_4BY2:
	      imm = nibs[3] << 1;
	      goto ok;
	    case IMM0_4BY4:
	    case IMM1_4BY4:
	      imm = nibs[3] << 2;
	      goto ok;
	    case IMM0_8:
	    case IMM1_8:
	      imm = (nibs[2] << 4) | nibs[3];
	      disp = imm;
	      has_disp = 1;
	      if (imm & 0x80)
		imm -= 0x100;
	      goto ok;
	    case PCRELIMM_8BY2:
	      imm = ((nibs[2] << 4) | nibs[3]) << 1;
	      relmask = ~(bfd_vma) 1;
	      goto ok;
	    case PCRELIMM_8BY4:
	      imm = ((nibs[2] << 4) | nibs[3]) << 2;
	      relmask = ~(bfd_vma) 3;
	      goto ok;
	    case IMM0_8BY2:
	    case IMM1_8BY2:
	      imm = ((nibs[2] << 4) | nibs[3]) << 1;
	      goto ok;
	    case IMM0_8BY4:
	    case IMM1_8BY4:
	      imm = ((nibs[2] << 4) | nibs[3]) << 2;
	      goto ok;
	    case REG_N_D:
	      if ((nibs[n] & 1) != 0)
		goto fail;
	      /* Fall through.  */
	    case REG_N:
	      rn = nibs[n];
	      break;
	    case REG_M:
	      rm = nibs[n];
	      break;
	    case REG_N_B01:
	      if ((nibs[n] & 0x3) != 1 /* binary 01 */)
		goto fail;
	      rn = (nibs[n] & 0xc) >> 2;
	      break;
	    case REG_NM:
	      rn = (nibs[n] & 0xc) >> 2;
	      rm = (nibs[n] & 0x3);
	      break;
	    case REG_B:
	      rb = nibs[n] & 0x07;
	      break;
	    case SDT_REG_N:
	      /* sh-dsp: single data transfer.  */
	      rn = nibs[n];
	      if ((rn & 0xc) != 4)
		goto fail;
	      rn = rn & 0x3;
	      rn |= (!(rn & 2)) << 2;
	      break;
	    case PPI:
	    case REPEAT:
	      goto fail;
	    default:
	      abort ();
	    }
	}

    ok:
      /* sh2a has D_REG but not X_REG.  We don't know the pattern
	 doesn't match unless we check the output args to see if they
	 make sense.  */
      if (target_arch == arch_sh2a
	  && ((op->arg[0] == DX_REG_M && (rm & 1) != 0)
	      || (op->arg[1] == DX_REG_N && (rn & 1) != 0)))
	goto fail;

      fprintf_fn (stream, "%s\t", op->name);
      disp_pc = 0;
      for (n = 0; n < 3 && op->arg[n] != A_END; n++)
	{
	  if (n && op->arg[1] != A_END)
	    fprintf_fn (stream, ",");
	  switch (op->arg[n])
	    {
	    case A_IMM:
	      fprintf_fn (stream, "#%d", imm);
	      break;
	    case A_R0:
	      fprintf_fn (stream, "r0");
	      break;
	    case A_REG_N:
	      fprintf_fn (stream, "r%d", rn);
	      break;
	    case A_INC_N:
	    case AS_INC_N:
	      fprintf_fn (stream, "@@r%d+", rn);
	      break;
	    case A_DEC_N:
	    case AS_DEC_N:
	      fprintf_fn (stream, "@@-r%d", rn);
	      break;
	    case A_IND_N:
	    case AS_IND_N:
	      fprintf_fn (stream, "@@r%d", rn);
	      break;
	    case A_DISP_REG_N:
	      fprintf_fn (stream, "@@(%d,r%d)", has_disp?disp:imm, rn);
	      break;
	    case AS_PMOD_N:
	      fprintf_fn (stream, "@@r%d+r8", rn);
	      break;
	    case A_REG_M:
	      fprintf_fn (stream, "r%d", rm);
	      break;
	    case A_INC_M:
	      fprintf_fn (stream, "@@r%d+", rm);
	      break;
	    case A_DEC_M:
	      fprintf_fn (stream, "@@-r%d", rm);
	      break;
	    case A_IND_M:
	      fprintf_fn (stream, "@@r%d", rm);
	      break;
	    case A_DISP_REG_M:
	      fprintf_fn (stream, "@@(%d,r%d)", has_disp?disp:imm, rm);
	      break;
	    case A_REG_B:
	      fprintf_fn (stream, "r%d_bank", rb);
	      break;
	    case A_DISP_PC:
	      disp_pc = 1;
	      disp_pc_addr = imm + 4 + (memaddr & relmask);
	      (*info->print_address_func) (disp_pc_addr, info);
	      break;
	    case A_IND_R0_REG_N:
	      fprintf_fn (stream, "@@(r0,r%d)", rn);
	      break;
	    case A_IND_R0_REG_M:
	      fprintf_fn (stream, "@@(r0,r%d)", rm);
	      break;
	    case A_DISP_GBR:
	      fprintf_fn (stream, "@@(%d,gbr)", has_disp?disp:imm);
	      break;
	    case A_TBR:
	      fprintf_fn (stream, "tbr");
	      break;
	    case A_DISP2_TBR:
	      fprintf_fn (stream, "@@@@(%d,tbr)", has_disp?disp:imm);
	      break;
	    case A_INC_R15:
	      fprintf_fn (stream, "@@r15+");
	      break;
	    case A_DEC_R15:
	      fprintf_fn (stream, "@@-r15");
	      break;
	    case A_R0_GBR:
	      fprintf_fn (stream, "@@(r0,gbr)");
	      break;
	    case A_BDISP12:
	    case A_BDISP8:
	      (*info->print_address_func) (imm + memaddr, info);
	      break;
	    case A_SR:
	      fprintf_fn (stream, "sr");
	      break;
	    case A_GBR:
	      fprintf_fn (stream, "gbr");
	      break;
	    case A_VBR:
	      fprintf_fn (stream, "vbr");
	      break;
	    case A_DSR:
	      fprintf_fn (stream, "dsr");
	      break;
	    case A_MOD:
	      fprintf_fn (stream, "mod");
	      break;
	    case A_RE:
	      fprintf_fn (stream, "re");
	      break;
	    case A_RS:
	      fprintf_fn (stream, "rs");
	      break;
	    case A_A0:
	      fprintf_fn (stream, "a0");
	      break;
	    case A_X0:
	      fprintf_fn (stream, "x0");
	      break;
	    case A_X1:
	      fprintf_fn (stream, "x1");
	      break;
	    case A_Y0:
	      fprintf_fn (stream, "y0");
	      break;
	    case A_Y1:
	      fprintf_fn (stream, "y1");
	      break;
	    case DSP_REG_M:
	      print_dsp_reg (rm, fprintf_fn, stream);
	      break;
	    case A_SSR:
	      fprintf_fn (stream, "ssr");
	      break;
	    case A_SPC:
	      fprintf_fn (stream, "spc");
	      break;
	    case A_MACH:
	      fprintf_fn (stream, "mach");
	      break;
	    case A_MACL:
	      fprintf_fn (stream, "macl");
	      break;
	    case A_PR:
	      fprintf_fn (stream, "pr");
	      break;
	    case A_SGR:
	      fprintf_fn (stream, "sgr");
	      break;
	    case A_DBR:
	      fprintf_fn (stream, "dbr");
	      break;
	    case F_REG_N:
	      fprintf_fn (stream, "fr%d", rn);
	      break;
	    case F_REG_M:
	      fprintf_fn (stream, "fr%d", rm);
	      break;
	    case DX_REG_N:
	      if (rn & 1)
		{
		  fprintf_fn (stream, "xd%d", rn & ~1);
		  break;
		}
	    case D_REG_N:
	      fprintf_fn (stream, "dr%d", rn);
	      break;
	    case DX_REG_M:
	      if (rm & 1)
		{
		  fprintf_fn (stream, "xd%d", rm & ~1);
		  break;
		}
	    case D_REG_M:
	      fprintf_fn (stream, "dr%d", rm);
	      break;
	    case FPSCR_M:
	    case FPSCR_N:
	      fprintf_fn (stream, "fpscr");
	      break;
	    case FPUL_M:
	    case FPUL_N:
	      fprintf_fn (stream, "fpul");
	      break;
	    case F_FR0:
	      fprintf_fn (stream, "fr0");
	      break;
	    case V_REG_N:
	      fprintf_fn (stream, "fv%d", rn * 4);
	      break;
	    case V_REG_M:
	      fprintf_fn (stream, "fv%d", rm * 4);
	      break;
	    case XMTRX_M4:
	      fprintf_fn (stream, "xmtrx");
	      break;
	    default:
	      abort ();
	    }
	}

#if 0
      /* This code prints instructions in delay slots on the same line
         as the instruction which needs the delay slots.  This can be
         confusing, since other disassembler don't work this way, and
         it means that the instructions are not all in a line.  So I
         disabled it.  Ian.  */
      if (!(info->flags & 1)
	  && (op->name[0] == 'j'
	      || (op->name[0] == 'b'
		  && (op->name[1] == 'r'
		      || op->name[1] == 's'))
	      || (op->name[0] == 'r' && op->name[1] == 't')
	      || (op->name[0] == 'b' && op->name[2] == '.')))
	{
	  info->flags |= 1;
	  fprintf_fn (stream, "\t(slot ");
	  print_insn_sh (memaddr + 2, info);
	  info->flags &= ~1;
	  fprintf_fn (stream, ")");
	  return 4;
	}
#endif

      if (disp_pc && strcmp (op->name, "mova") != 0)
	{
	  int size;
	  bfd_byte bytes[4];

	  if (relmask == ~(bfd_vma) 1)
	    size = 2;
	  else
	    size = 4;
	  status = info->read_memory_func (disp_pc_addr, bytes, size, info);
	  if (status == 0)
	    {
	      unsigned int val;

	      if (size == 2)
		{
		  if (info->endian == BFD_ENDIAN_LITTLE)
		    val = bfd_getl16 (bytes);
		  else
		    val = bfd_getb16 (bytes);
		}
	      else
		{
		  if (info->endian == BFD_ENDIAN_LITTLE)
		    val = bfd_getl32 (bytes);
		  else
		    val = bfd_getb32 (bytes);
		}
	      if ((*info->symbol_at_address_func) (val, info))
		{
		  fprintf_fn (stream, "\t! ");
		  (*info->print_address_func) (val, info);
		}
	      else
		fprintf_fn (stream, "\t! %x", val);
	    }
	}

      return SH_MERGE_ARCH_SET (op->arch, arch_op32) ? 4 : 2;
    fail:
      ;

    }
  fprintf_fn (stream, ".word 0x%x%x%x%x", nibs[0], nibs[1], nibs[2], nibs[3]);
  return 2;
}
@


1.29
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d359 1
a359 1
		  fprintf_fn (stream, sx_tab[(field_b >> 6) & 3]);
d362 1
a362 1
		  fprintf_fn (stream, sy_tab[(field_b >> 4) & 3]);
@


1.29.4.1
log
@gas/
	* config/tc-mips.c (ISA_SUPPORTS_DSP_ASE): Also set if microMIPS
	mode.
	(ISA_SUPPORTS_DSPR2_ASE): Likewise.
	(macro_build) <'2'>: Handle microMIPS.
2012-07-31  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>

gas/
	* gas/mips/micromips@@mips32-dsp.d: New test.
	* gas/mips/micromips@@mips32-dspr2.d: New test.
	* gas/mips/mips32-dsp.s: Update padding.
	* gas/mips/mips32-dspr2.s: Likewise.
	* gas/mips/mips.exp: Use run_dump_test_arches to run MIPS32 DSP
	tests.
2012-07-31  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

include/
2012-07-31  Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

opcodes/
2012-08-01  Alan Modra  <amodra@@gmail.com>

	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d359 1
a359 1
		  fprintf_fn (stream, "%s", sx_tab[(field_b >> 6) & 3]);
d362 1
a362 1
		  fprintf_fn (stream, "%s", sy_tab[(field_b >> 4) & 3]);
@


1.28
log
@update copyright dates
@
text
@d3 1
a3 1
   2006, 2007  Free Software Foundation, Inc.
d22 1
d24 1
a24 1
#include "sysdep.h"
@


1.27
log
@Change source files over to GPLv3.
@
text
@d3 1
a3 1
   2007  Free Software Foundation, Inc.
@


1.26
log
@2006-10-20  Andrew Stubbs  <andrew.stubbs@@st.com>

opcodes/

	* sh-dis.c (print_insn_sh): Remove 0x from output to prevent GDB
	duplicating it.

gas/testsuite/

	* gas/sh/pcrel-coff.d: Update patterns (remove 0x on addresses).
	* gas/sh/pcrel-hms.d: Likewise.
	* gas/sh/pcrel.d: Likewise.
	* gas/sh/pcrel2.d: Likewise.
	* gas/sh/pic.d: Likewise.
	* gas/sh/tlsd.d: Likewise.
	* gas/sh/tlsdnopic.d: Likewise.
	* gas/sh/tlsdpic.d: Likewise.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d5 3
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d18 2
a19 2
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
@


1.25
log
@Update function declarations to ISO C90 formatting
@
text
@d927 1
a927 1
		  fprintf_fn (stream, "\t! 0x");
d931 1
a931 1
		fprintf_fn (stream, "\t! 0x%x", val);
@


1.24
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2004
d17 2
a18 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a31 6
static void print_movxy
  PARAMS ((const sh_opcode_info *, int, int, fprintf_ftype, void *));
static void print_insn_ddt PARAMS ((int, struct disassemble_info *));
static void print_dsp_reg PARAMS ((int, fprintf_ftype, void *));
static void print_insn_ppi PARAMS ((int, struct disassemble_info *));

d33 5
a37 5
print_movxy (op, rn, rm, fprintf_fn, stream)
     const sh_opcode_info *op;
     int rn, rm;
     fprintf_ftype fprintf_fn;
     void *stream;
d111 1
a111 3
print_insn_ddt (insn, info)
     int insn;
     struct disassemble_info *info;
d198 1
a198 4
print_dsp_reg (rm, fprintf_fn, stream)
     int rm;
     fprintf_ftype fprintf_fn;
     void *stream;
d239 1
a239 3
print_insn_ppi (field_b, info)
     int field_b;
     struct disassemble_info *info;
d266 6
a271 7
	{
	  fprintf_fn (stream, "p%s %s,%s,%s\t",
		      (field_b & 0x1000) ? "add" : "sub",
		      sx_tab[(field_b >> 6) & 3],
		      sy_tab[(field_b >> 4) & 3],
		      du_tab[(field_b >> 0) & 3]);
	}
d275 2
a276 3
	{
	  fprintf_fn (stream, "pclr %s \t", du_tab[(field_b >> 0) & 3]);
	}
d278 2
a279 3
	{
	  fprintf_fn (stream, ".word 0x%x\t", field_b);
	}
d380 1
d382 1
a382 3
print_insn_sh (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
d635 1
a635 1
	      /* fall through */
@


1.23
log
@include/elf/ChangeLog:
Introduce SH2a support.
2004-02-18  Corinna Vinschen  <vinschen@@redhat.com>
* sh.h (EF_SH2A_NOFPU): New.
2003-12-01  Michael Snyder  <msnyder@@redhat.com>
* sh.h (EF_SH2A): New.
bfd/ChangeLog:
Introduce SH2a support.
2004-02-18  Corinna Vinschen  <vinschen@@redhat.com>
* archures.c (bfd_mach_sh2a_nofpu): New.
* bfd-in2.h: Rebuilt.
* cpu-sh.c (SH2A_NOFPU_NEXT): New.
(arch_info_struct): Add sh2a_nofpu.
* elf32-sh.c (sh_elf_set_mach_from_flags): Handle sh2a_nofpu.
2003-12-29  DJ Delorie  <dj@@redhat.com>
* reloc.c: Add relocs for sh2a.
* bfd-in2.h: Regenerate.
* libbfd.hh: Regenerate.
2003-12-01  Michael Snyder  <msnyder@@redhat.com>
* archures.c (bfd_mach_sh2a): New.
* bfd-in2.h: Rebuilt.
* cpu-sh.c (SH_NEXT, SH2_NEXT, etc.): Change defines to enums.
(SH2A_NEXT): New.
(arch_info_struct): Add sh2a.
* elf32-sh.c (sh_elf_set_mach_from_flags): Handle sh2a.
binutils/ChangeLog:
* readelf.c (get_machine_flags <EM_SH>): Handle EF_SH2A and
EF_SH2A_NOFPU.
gas/ChangeLog:
Introduce SH2a support.
2004-02-24  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (get_specific): Change arch_sh2a_up to
arch_sh2a_nofpu_up.
2004-02-24  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (md_parse_option): Add sh2a-nofpu ISA handling.
2004-02-20  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (sh_elf_final_processing): Move sh2a recognition
to end of conditional expression.
2004-02-20  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c: Add sh2a-nofpu support.
2003-12-29  DJ Delorie  <dj@@redhat.com>
* tc-sh.c: Add sh2a support.
(parse_reg): Add tbr.
(parse_at): Support @@@@(disp,tbr).
(get_specific): Support sh2a opcodes.
(insert4): New, for 4 byte relocs.
(build_Mytes): Support sh2a opcodes.
(md_apply_fix3_Mytes): Support sh2a opcodes.
2003-12-02  Michael Snyder  <msnyder@@redhat.com>
* config/tc-sh.c (md_parse_option): Handle sh2a.
(sh_elf_final_processing): Ditto.
gas/testsuite/ChangeLog:
2003-12-30  DJ Delorie  <dj@@redhat.com>
* gas/sh/sh2a.s: New.
* gas/sh/sh2a.d: New.
* gas/sh/basic.exp: Add it.
opcodes/ChangeLog:
Introduce SH2a support.
* sh-opc.h (arch_sh2a_base): Renumber.
(arch_sh2a_nofpu_base): Remove.
(arch_sh_base_mask): Adjust.
(arch_opann_mask): New.
(arch_sh2a, arch_sh2a_nofpu): Adjust.
(arch_sh2a_up, arch_sh2a_nofpu_up): Likewise.
(sh_table): Adjust whitespace.
2004-02-24  Corinna Vinschen  <vinschen@@redhat.com>
* sh-opc.h (arch_sh2a_nofpu_up): New.  Use instead of arch_sh2a_up in
instruction list throughout.
(arch_sh2a_up): Redefine to include fpu instruction set.  Use instead
of arch_sh2a in instruction list throughout.
(arch_sh2e_up): Accomodate above changes.
(arch_sh2_up): Ditto.
2004-02-20  Corinna Vinschen  <vinschen@@redhat.com>
* sh-opc.h: Add arch_sh2a_nofpu to arch_sh2_up.
2004-02-18  Corinna Vinschen  <vinschen@@redhat.com>
* sh-dis.c (print_insn_sh): Add bfd_mach_sh2a_nofpu handling.
* sh-opc.h (arch_sh2a_nofpu): New.
(arch_sh2a_up): New, defines sh2a and sh2a_nofpu.
(sh_table): Change all arch_sh2a to arch_sh2a_up unless FPU
instruction.
2004-01-20  DJ Delorie  <dj@@redhat.com>
* sh-dis.c (print_insn_sh): SH2A does not have 'X' fp regs.
2003-12-29  DJ Delorie  <dj@@redhat.com>
* sh-opc.c (sh_nibble_type, sh_arg_type, arch_2a, arch_2e_up,
sh_opcode_info, sh_table): Add sh2a support.
(arch_op32): New, to tag 32-bit opcodes.
* sh-dis.c (print_insn_sh): Support sh2a opcodes.
2003-12-02  Michael Snyder  <msnyder@@redhat.com>
* sh-opc.h (arch_sh2a): Add.
* sh-dis.c (arch_sh2a): Handle.
* sh-opc.h (arch_sh2_up): Fix up to include arch_sh2a.
@
text
@d17 1
a17 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.22
log
@2004-05-28  Andrew Stubbs <andrew.stubbs@@superh.com>

bfd:
	* Makefile.am: Regenerate dependencies.
	* Makefile.in: Regenerate.
	* archures.c: Add bfd_mach_sh3_nommu .
	* bfd-in2.h: Regenerate.
	* cpu-sh.c: Add sh3-nommu architecture.
	(bfd_to_arch_table): Create new table.
	(sh_get_arch_from_bfd_mach): Create new function.
	(sh_get_arch_up_from_bfd_mach): Create new function.
	(sh_merge_bfd_arch): Create new function.
	* elf32-sh.c (sh_ef_bfd_table): Add table.
	(sh_elf_check_relocs): Replace switch statement with
	use of sh_ef_bfd_table .
	(sh_elf_get_flags_from_mach): Add new function.
	(sh_find_elf_flags): Likewise.
	(sh_elf_copy_private_data): Replace most of non-elf contents
	with a call to sh_merge_bfd_arch() .

gas:
	* Makefile.am: Regenerate dependecies.
	* Makefile.in: Regenerate.
	* config/tc-sh.c (valid_arch): Make unsigned.
	(preset_target_arch): Likewise.
	(md_begin): Use new architecture flags system.
	(get_specific): Likewise.
	(assemble_ppi): Likewise.
	(md_assemble): Likewise. Also fix error check for bad opcodes.
	(md_parse_option): Likewise. Also generate -isa values according
	to the table in bfd/cpu-sh.c instead of just constants. Also
	allow <arch>-up ISA variants.
	(sh_elf_final_processing): Replace if-else chain with a call to
	sh_find_elf_flags().
	* testsuite/gas/sh/arch: New directory.
	* testsuite/gas/sh/arch/arch.exp: New test script.
	* testsuite/gas/sh/arch/arch_expected.txt: New file.
	* testsuite/gas/sh/arch/sh.s: New file.
	* testsuite/gas/sh/arch/sh2.s: New file.
	* testsuite/gas/sh/arch/sh-dsp.s: New file.
	* testsuite/gas/sh/arch/sh2e.s: New file.
	* testsuite/gas/sh/arch/sh3-nommu.s: New file.
	* testsuite/gas/sh/arch/sh3.s: New file.
	* testsuite/gas/sh/arch/sh3-dsp.s: New file.
	* testsuite/gas/sh/arch/sh3e.s: New file.
	* testsuite/gas/sh/arch/sh4-nommu-nofpu.s: New file.
	* testsuite/gas/sh/arch/sh4-nofpu.s: New file.
	* testsuite/gas/sh/arch/sh4.s: New file.
	* testsuite/gas/sh/arch/sh4a-nofpu.s: New file.
	* testsuite/gas/sh/arch/sh4al-dsp.s: New file.
	* testsuite/gas/sh/arch/sh4a.s: New file.

include/elf:
	* sh.h (EF_SH_HAS_DSP): Remove.
	(EF_SH_HAS_FP): Remove.
	(EF_SH_MERGE_MACH): Remove.
	(EF_SH4_NOFPU): Convert to decimal.
	(EF_SH4A_NOFPU): Likewise.
	(EF_SH4_NOMMU_NOFPU): Likewise.
	(EF_SH3_NOMMU): Add new macro.
	(EF_SH_BFD_TABLE): Likewise.
	(sh_find_elf_flags): Add prototype.
	(sh_elf_get_flags_from_mach): Likewise.

opcodes:
	* sh-dis.c (target_arch): Make unsigned.
	(print_insn_sh): Replace (most of) switch with a call to
	sh_get_arch_from_bfd_mach(). Also use new architecture flags system.
	* sh-opc.h: Redefine architecture flags values.
	Add sh3-nommu architecture.
	Reorganise <arch>_up macros so they make more visual sense.
	(SH_MERGE_ARCH_SET): Define new macro.
	(SH_VALID_BASE_ARCH_SET): Likewise.
	(SH_VALID_MMU_ARCH_SET): Likewise.
	(SH_VALID_CO_ARCH_SET): Likewise.
	(SH_VALID_ARCH_SET): Likewise.
	(SH_MERGE_ARCH_SET_VALID): Likewise.
	(SH_ARCH_SET_HAS_FPU): Likewise.
	(SH_ARCH_SET_HAS_DSP): Likewise.
	(SH_ARCH_UNKNOWN_ARCH): Likewise.
	(sh_get_arch_from_bfd_mach): Add prototype.
	(sh_get_arch_up_from_bfd_mach): Likewise.
	(sh_get_bfd_mach_from_arch_set): Likewise.
	(sh_merge_bfd_arc): Likewise.

ld:
	* testsuite/ld-sh/arch/arch.exp: New test script.
	* testsuite/ld-sh/arch/arch_expected.txt: New file.
	* testsuite/ld-sh/arch/sh.s: New file.
	* testsuite/ld-sh/arch/sh2.s: New file.
	* testsuite/ld-sh/arch/sh-dsp.s: New file.
	* testsuite/ld-sh/arch/sh2e.s: New file.
	* testsuite/ld-sh/arch/sh3-nommu.s: New file.
	* testsuite/ld-sh/arch/sh3.s: New file.
	* testsuite/ld-sh/arch/sh3-dsp.s: New file.
	* testsuite/ld-sh/arch/sh3e.s: New file.
	* testsuite/ld-sh/arch/sh4-nommu-nofpu.s: New file.
	* testsuite/ld-sh/arch/sh4-nofpu.s: New file.
	* testsuite/ld-sh/arch/sh4.s: New file.
	* testsuite/ld-sh/arch/sh4a-nofpu.s: New file.
	* testsuite/ld-sh/arch/sh4al-dsp.s: New file.
	* testsuite/ld-sh/arch/sh4a.s: New file.
@
text
@d393 2
d403 1
a403 1
  unsigned char nibs[4];
d408 1
d459 24
d520 7
d530 1
a530 1
      for (n = 0; n < 4; n++)
d554 58
d627 4
d687 8
d704 1
a704 1
	      fprintf_fn (stream, "#%d", (char) (imm));
d725 1
a725 1
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rn);
d743 1
a743 1
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rm);
d760 13
a772 1
	      fprintf_fn (stream, "@@(%d,gbr)", imm);
d951 1
a951 1
      return 2;
@


1.21
log
@bfd/
	* elf32-sh.c (sh_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.

opcodes/
	* sh-dis.c (print_insn_sh): Print the value in constant pool
	as a symbol if it looks like a symbol.

gas/testsuite/
	* gas/sh/pcrel2.d: Update.
	* gas/sh/tlsd.d: Update.
	* gas/sh/tlsnopic.d: Update.
	* gas/sh/tlspic.d: Update.

ld/testsuite/
	* ld-sh/tlsbin-1.d: Update
	* ld-sh/tlspic-1.d: Update.
@
text
@d405 1
a405 1
  int target_arch;
a417 34
    case bfd_mach_sh2:
      target_arch = arch_sh2;
      break;
    case bfd_mach_sh2e:
      target_arch = arch_sh2e;
      break;
    case bfd_mach_sh_dsp:
      target_arch = arch_sh_dsp;
      break;
    case bfd_mach_sh3:
      target_arch = arch_sh3;
      break;
    case bfd_mach_sh3_dsp:
      target_arch = arch_sh3_dsp;
      break;
    case bfd_mach_sh3e:
      target_arch = arch_sh3e;
      break;
    case bfd_mach_sh4_nofpu:
      target_arch = arch_sh4_nofpu;
      break;
    case bfd_mach_sh4:
      target_arch = arch_sh4;
      break;
    case bfd_mach_sh4a:
    case bfd_mach_sh4a_nofpu:
      target_arch = arch_sh4a;
      break;
    case bfd_mach_sh4al_dsp:
      target_arch = arch_sh4al_dsp;
      break;
    case bfd_mach_sh4_nommu_nofpu:
      target_arch = arch_sh4_nommu_nofpu;
      break;
d429 1
a429 1
      abort ();
d457 2
a458 1
  if (nibs[0] == 0xf && (nibs[1] & 4) == 0 && target_arch & arch_sh_dsp_up)
d494 1
a494 1
      if ((op->arch & target_arch) == 0)
@


1.20
log
@2003-03-03  Andrew Stubbs  <andrew.stubbs@@superh.com>

opcodes:
	* sh-dis.c (print_insn_sh): Don't disassemble fp instructions in
	nofpu mode.  Add BFD type bfd_mach_sh4_nommu_nofpu.
	* sh-opc.h: Add sh4_nommu_nofpu architecture and adjust instructions
	accordingly.
bfd:
	* archures.c: Add bfd_mach_sh4_nommu_nofpu.
	* cpu-sh.c: Ditto.
	* elf32-sh.c: Ditto.
	* bfd-in2.h: Regenerate.
include/elf:
	* sh.h: Add EF_SH4_NOMMU_NOFPU.
gas:
	* config/tc-sh.c (md_parse_option): Add -isa=sh4-nofpu and
	-isa=sh4-nommu-nofpu options. Adjust help messages accordingly.
	(sh_elf_final_processing): Output BFD type sh4_nofpu if that is
	the most general type or the user specifically requested it.
	(md_assemble): Add a new error message for when an instruction
	is understood, but is not allowed due to an -isa option.
@
text
@d858 7
a864 1
	      fprintf_fn (stream, "\t! 0x%x", val);
@


1.19
log
@2004-02-23  Andrew Stubbs <andrew.stubbs@@superh.com>

gas:
	* tc-sh.c (build_Mytes): Add REG_N_D and REG_N_B01
	nibble types to assembler.
opcodes:
	* sh-dis.c (print_insn_sh): Add REG_N_D nibble type to
	ensure that double registers have even numbers.
	Add REG_N_B01 for nn01 (binary 01) nibble to ensure
	that reserved instruction 0xfffd does not decode the same
	as 0xfdfd (ftrv).
	* sh-opc.h: Add REG_N_D nibble type and use it whereever
	REG_N refers to a double register.
	Add REG_N_B01 nibble type and use it instead of REG_NM
	in ftrv.
	Adjust the bit patterns in a few comments.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
d436 3
a439 1
    case bfd_mach_sh4_nofpu:
d448 3
@


1.18
log
@2004-01-13  Michael Snyder  <msnyder@@redhat.com>

        * sh-dis.c (print_insn_sh): Allocate 4	bytes for insn.
@
text
@d580 4
d589 5
@


1.18.6.1
log
@Merge to 2.15 branch.
@
text
@a579 4
	    case REG_N_D:
	      if ((nibs[n] & 1) != 0)
		goto fail;
	      /* fall through */
a584 5
	      break;
	    case REG_N_B01:
	      if ((nibs[n] & 0x3) != 1 /* binary 01 */)
		goto fail;
	      rn = (nibs[n] & 0xc) >> 2;
@


1.18.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2004
d436 1
a437 3
      target_arch = arch_sh4_nofpu;
      break;
    case bfd_mach_sh4:
a446 3
    case bfd_mach_sh4_nommu_nofpu:
      target_arch = arch_sh4_nommu_nofpu;
      break;
a579 4
	    case REG_N_D:
	      if ((nibs[n] & 1) != 0)
		goto fail;
	      /* fall through */
a584 5
	      break;
	    case REG_N_B01:
	      if ((nibs[n] & 0x3) != 1 /* binary 01 */)
		goto fail;
	      rn = (nibs[n] & 0xc) >> 2;
@


1.18.8.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a392 2
/* FIXME mvs: movx insns print as ".word 0x%03x", insn & 0xfff
   (ie. the upper nibble is missing).  */
d401 1
a401 1
  unsigned char nibs[8];
d405 1
a405 2
  unsigned int target_arch;
  int allow_op32;
d418 34
d463 1
a463 1
      target_arch = sh_get_arch_from_bfd_mach (info->mach);
a489 11
  status = info->read_memory_func (memaddr + 2, insn + 2, 2, info);
  if (status != 0)
    allow_op32 = 0;
  else
    {
      allow_op32 = 1;

      if (info->endian == BFD_ENDIAN_LITTLE)
	{
	  nibs[4] = (insn[3] >> 4) & 0xf;
	  nibs[5] = insn[3] & 0xf;
d491 1
a491 15
	  nibs[6] = (insn[2] >> 4) & 0xf;
	  nibs[7] = insn[2] & 0xf;
	}
      else
	{
	  nibs[4] = (insn[2] >> 4) & 0xf;
	  nibs[5] = insn[2] & 0xf;

	  nibs[6] = (insn[3] >> 4) & 0xf;
	  nibs[7] = insn[3] & 0xf;
	}
    }

  if (nibs[0] == 0xf && (nibs[1] & 4) == 0
      && SH_MERGE_ARCH_SET_VALID (target_arch, arch_sh_dsp_up))
a525 7
      int disp = 0;
      int has_disp = 0;
      int max_n = SH_MERGE_ARCH_SET (op->arch, arch_op32) ? 8 : 4;

      if (!allow_op32
	  && SH_MERGE_ARCH_SET (op->arch, arch_op32))
	goto fail;
d527 1
a527 1
      if (!SH_MERGE_ARCH_SET_VALID (op->arch, target_arch))
d529 1
a529 1
      for (n = 0; n < max_n; n++)
a552 58
	    case IMM0_3c:
	      if (nibs[3] & 0x8)
		goto fail;
	      imm = nibs[3] & 0x7;
	      break;
	    case IMM0_3s:
	      if (!(nibs[3] & 0x8))
		goto fail;
	      imm = nibs[3] & 0x7;
	      break;
	    case IMM0_3Uc:
	      if (nibs[2] & 0x8)
		goto fail;
	      imm = nibs[2] & 0x7;
	      break;
	    case IMM0_3Us:
	      if (!(nibs[2] & 0x8))
		goto fail;
	      imm = nibs[2] & 0x7;
	      break;
	    case DISP0_12:
	    case DISP1_12:
	      disp = (nibs[5] << 8) | (nibs[6] << 4) | nibs[7];
	      has_disp = 1;
	      goto ok;
	    case DISP0_12BY2:
	    case DISP1_12BY2:
	      disp = ((nibs[5] << 8) | (nibs[6] << 4) | nibs[7]) << 1;
	      relmask = ~(bfd_vma) 1;
	      has_disp = 1;
	      goto ok;
	    case DISP0_12BY4:
	    case DISP1_12BY4:
	      disp = ((nibs[5] << 8) | (nibs[6] << 4) | nibs[7]) << 2;
	      relmask = ~(bfd_vma) 3;
	      has_disp = 1;
	      goto ok;
	    case DISP0_12BY8:
	    case DISP1_12BY8:
	      disp = ((nibs[5] << 8) | (nibs[6] << 4) | nibs[7]) << 3;
	      relmask = ~(bfd_vma) 7;
	      has_disp = 1;
	      goto ok;
	    case IMM0_20_4:
	      break;
	    case IMM0_20:
	      imm = ((nibs[2] << 16) | (nibs[4] << 12) | (nibs[5] << 8)
		     | (nibs[6] << 4) | nibs[7]);
	      if (imm & 0x80000)
		imm -= 0x100000;
	      goto ok;
	    case IMM0_20BY8:
	      imm = ((nibs[2] << 16) | (nibs[4] << 12) | (nibs[5] << 8)
		     | (nibs[6] << 4) | nibs[7]);
	      imm <<= 8;
	      if (imm & 0x8000000)
		imm -= 0x10000000;
	      goto ok;
a567 4
	      disp = imm;
	      has_disp = 1;
	      if (imm & 0x80)
		imm -= 0x100;
a623 8
      /* sh2a has D_REG but not X_REG.  We don't know the pattern
	 doesn't match unless we check the output args to see if they
	 make sense.  */
      if (target_arch == arch_sh2a
	  && ((op->arg[0] == DX_REG_M && (rm & 1) != 0)
	      || (op->arg[1] == DX_REG_N && (rn & 1) != 0)))
	goto fail;

d633 1
a633 1
	      fprintf_fn (stream, "#%d", imm);
d654 1
a654 1
	      fprintf_fn (stream, "@@(%d,r%d)", has_disp?disp:imm, rn);
d672 1
a672 1
	      fprintf_fn (stream, "@@(%d,r%d)", has_disp?disp:imm, rm);
d689 1
a689 13
	      fprintf_fn (stream, "@@(%d,gbr)", has_disp?disp:imm);
	      break;
	    case A_TBR:
	      fprintf_fn (stream, "tbr");
	      break;
	    case A_DISP2_TBR:
	      fprintf_fn (stream, "@@@@(%d,tbr)", has_disp?disp:imm);
	      break;
	    case A_INC_R15:
	      fprintf_fn (stream, "@@r15+");
	      break;
	    case A_DEC_R15:
	      fprintf_fn (stream, "@@-r15");
d858 1
a858 7
	      if ((*info->symbol_at_address_func) (val, info))
		{
		  fprintf_fn (stream, "\t! 0x");
		  (*info->print_address_func) (val, info);
		}
	      else
		fprintf_fn (stream, "\t! 0x%x", val);
d862 1
a862 1
      return SH_MERGE_ARCH_SET (op->arch, arch_op32) ? 4 : 2;
@


1.17
log
@2003-12-02  Alexandre Oliva  <aoliva@@redhat.com>

	* sh-opc.h: Add support for sh4a and no-fpu variants.
	* sh-dis.c: Ditto.
@
text
@d400 1
a400 1
  unsigned char insn[2];
@


1.16
log
@Add SH2E support
@
text
@d52 4
d59 4
d65 2
a66 1
	case A_PMOD_N:
d69 2
a70 1
	case A_PMODY_N:
d73 1
a73 1
	case DSP_REG_M:
d82 20
d135 35
a169 1
    fprintf_fn (stream, ".word 0x%x", insn);
d258 1
d285 10
d306 1
d325 4
d331 1
a331 1
      if (op->nibbles[1] == nib1
d337 23
d437 1
d440 7
d628 1
d632 1
d636 1
d642 1
a642 1
	    case A_PMOD_N:
@


1.15
log
@	* arm-dis.c (print_insn_arm): Constify "insn".  Formatting.
	(print_insn_thumb): Likewise.
	* h8500-dis.c (print_insn_h8500): Constify "opcode".
	* mcore-dis.c (print_insn_mcore): Constify "op".  Formatting.
	* ns32k-dis.c (print_insn_arg <case 'F'>): Use a union to avoid
	type-punned pointer warnings.
	<case 'L'>: Likewise.  Fix error message too.
	* pdp11-dis.c (print_reg): Warning fix.
	* sh-dis.c (print_movxy): Constify "op" param.
	(print_insn_ddt): Constify sh_opcode_info vars.
	(print_insn_ppi): Likewise.
	(print_insn_sh): Likewise.
	* tic30-dis.c (cnvt_tmsfloat_ieee): Use a union to avoid
	type-punned pointer warnings.
	* w65-dis.c (print_insn_w65): Constify "op".
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002
d5 13
a17 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d317 3
@


1.14
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d32 1
a32 1
  PARAMS ((sh_opcode_info *, int, int, fprintf_ftype, void *));
d39 1
a39 1
     sh_opcode_info *op;
d108 2
a109 2
      static sh_opcode_info *first_movx, *first_movy;
      sh_opcode_info *opx, *opy;
d195 1
a195 1
  sh_opcode_info *op;
d301 1
a301 1
  sh_opcode_info *op;
@


1.13
log
@Avoid dereferencing null pointer in:
	* sh-dis.c (print_insn_sh): If coff and bfd_mach_sh, use arch_sh4
	for disassembly.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001
d26 4
@


1.13.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
d5 13
a17 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a26 4
#ifdef ARCH_all
#define INCLUDE_SHMEDIA
#endif

d28 1
a28 1
  PARAMS ((const sh_opcode_info *, int, int, fprintf_ftype, void *));
d35 1
a35 1
     const sh_opcode_info *op;
a47 4
	case AX_IND_N:
	case AXY_IND_N:
	case AY_IND_N:
	case AYX_IND_N:
a50 4
	case AX_INC_N:
	case AXY_INC_N:
	case AY_INC_N:
	case AYX_INC_N:
d53 1
a53 2
	case AX_PMOD_N:
	case AXY_PMOD_N:
d56 1
a56 2
	case AY_PMOD_N:
	case AYX_PMOD_N:
d59 1
a59 1
	case DSP_REG_A_M:
a67 20
	case DSP_REG_AX:
	  fprintf_fn (stream, "%c%c",
		      (rm & 1) ? 'x' : 'a',
		      (rm & 2) ? '1' : '0');
	  break;
	case DSP_REG_XY:
	  fprintf_fn (stream, "%c%c",
		      (rm & 1) ? 'y' : 'x',
		      (rm & 2) ? '1' : '0');
	  break;
	case DSP_REG_AY:
	  fprintf_fn (stream, "%c%c",
		      (rm & 2) ? 'y' : 'a',
		      (rm & 1) ? '1' : '0');
	  break;
	case DSP_REG_YX:
	  fprintf_fn (stream, "%c%c",
		      (rm & 2) ? 'x' : 'y',
		      (rm & 1) ? '1' : '0');
	  break;
d101 1
a101 35
    if (info->mach != bfd_mach_sh_dsp
        && info->mach != bfd_mach_sh3_dsp)
      {
	static const sh_opcode_info *first_movx, *first_movy;
	const sh_opcode_info *op;
	int is_movy;

	if (! first_movx)
	  {
	    for (first_movx = sh_table; first_movx->nibbles[1] != MOVX_NOPY;)
	      first_movx++;
	    for (first_movy = first_movx; first_movy->nibbles[1] != MOVY_NOPX;)
	      first_movy++;
	  }

	is_movy = ((insn & 3) != 0);

	if (is_movy)
	  op = first_movy;
	else
	  op = first_movx;

	while (op->nibbles[2] != (unsigned) ((insn >> 4) & 3)
	       || op->nibbles[3] != (unsigned) (insn & 0xf))
	  op++;
	
	print_movxy (op,
		     (4 * ((insn & (is_movy ? 0x200 : 0x100)) == 0)
		      + 2 * is_movy
		      + 1 * ((insn & (is_movy ? 0x100 : 0x200)) != 0)),
		     (insn >> 6) & 3,
		     fprintf_fn, stream);
      }
    else
      fprintf_fn (stream, ".word 0x%x", insn);
d104 2
a105 2
      static const sh_opcode_info *first_movx, *first_movy;
      const sh_opcode_info *opx, *opy;
a189 1
  unsigned int altnib1, nib4;
d191 1
a191 1
  const sh_opcode_info *op;
a215 10
      else if ((field_b & 0xf0) == 0x10
	       && info->mach != bfd_mach_sh_dsp
	       && info->mach != bfd_mach_sh3_dsp)
	{
	  fprintf_fn (stream, "pclr %s \t", du_tab[(field_b >> 0) & 3]);
	}
      else if ((field_b & 0xf3) != 0)
	{
	  fprintf_fn (stream, ".word 0x%x\t", field_b);
	}
a226 1
  nib4 = field_b >> 4 & 0xf;
a244 4
  if (nib1 == PPI3)
    altnib1 = PPI3NC;
  else
    altnib1 = nib1;
d247 1
a247 1
      if ((op->nibbles[1] == nib1 || op->nibbles[1] == altnib1)
a252 23
	  switch (op->nibbles[4])
	    {
	    case HEX_0:
	      break;
	    case HEX_XX00:
	      if ((nib4 & 3) != 0)
		continue;
	      break;
	    case HEX_1:
	      if ((nib4 & 3) != 1)
		continue;
	      break;
	    case HEX_00YY:
	      if ((nib4 & 0xc) != 0)
		continue;
	      break;
	    case HEX_4:
	      if ((nib4 & 0xc) != 4)
		continue;
	      break;
	    default:
	      abort ();
	    }
d297 1
a297 1
  const sh_opcode_info *op;
a313 3
    case bfd_mach_sh2e:
      target_arch = arch_sh2e;
      break;
a326 1
    case bfd_mach_sh4_nofpu:
a328 7
    case bfd_mach_sh4a:
    case bfd_mach_sh4a_nofpu:
      target_arch = arch_sh4a;
      break;
    case bfd_mach_sh4al_dsp:
      target_arch = arch_sh4al_dsp;
      break;
a509 1
	    case AS_INC_N:
a512 1
	    case AS_DEC_N:
a515 1
	    case AS_IND_N:
d521 1
a521 1
	    case AS_PMOD_N:
@


1.13.16.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d400 1
a400 1
  unsigned char insn[4];
@


1.13.14.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002
a26 4
#ifdef ARCH_all
#define INCLUDE_SHMEDIA
#endif

d28 1
a28 1
  PARAMS ((const sh_opcode_info *, int, int, fprintf_ftype, void *));
d35 1
a35 1
     const sh_opcode_info *op;
d104 2
a105 2
      static const sh_opcode_info *first_movx, *first_movy;
      const sh_opcode_info *opx, *opy;
d191 1
a191 1
  const sh_opcode_info *op;
d297 1
a297 1
  const sh_opcode_info *op;
@


1.13.14.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
d5 13
a17 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a316 3
      break;
    case bfd_mach_sh2e:
      target_arch = arch_sh2e;
@


1.13.14.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a51 4
	case AX_IND_N:
	case AXY_IND_N:
	case AY_IND_N:
	case AYX_IND_N:
a54 4
	case AX_INC_N:
	case AXY_INC_N:
	case AY_INC_N:
	case AYX_INC_N:
d57 1
a57 2
	case AX_PMOD_N:
	case AXY_PMOD_N:
d60 1
a60 2
	case AY_PMOD_N:
	case AYX_PMOD_N:
d63 1
a63 1
	case DSP_REG_A_M:
a71 20
	case DSP_REG_AX:
	  fprintf_fn (stream, "%c%c",
		      (rm & 1) ? 'x' : 'a',
		      (rm & 2) ? '1' : '0');
	  break;
	case DSP_REG_XY:
	  fprintf_fn (stream, "%c%c",
		      (rm & 1) ? 'y' : 'x',
		      (rm & 2) ? '1' : '0');
	  break;
	case DSP_REG_AY:
	  fprintf_fn (stream, "%c%c",
		      (rm & 2) ? 'y' : 'a',
		      (rm & 1) ? '1' : '0');
	  break;
	case DSP_REG_YX:
	  fprintf_fn (stream, "%c%c",
		      (rm & 2) ? 'x' : 'y',
		      (rm & 1) ? '1' : '0');
	  break;
d105 1
a105 35
    if (info->mach != bfd_mach_sh_dsp
        && info->mach != bfd_mach_sh3_dsp)
      {
	static const sh_opcode_info *first_movx, *first_movy;
	const sh_opcode_info *op;
	int is_movy;

	if (! first_movx)
	  {
	    for (first_movx = sh_table; first_movx->nibbles[1] != MOVX_NOPY;)
	      first_movx++;
	    for (first_movy = first_movx; first_movy->nibbles[1] != MOVY_NOPX;)
	      first_movy++;
	  }

	is_movy = ((insn & 3) != 0);

	if (is_movy)
	  op = first_movy;
	else
	  op = first_movx;

	while (op->nibbles[2] != (unsigned) ((insn >> 4) & 3)
	       || op->nibbles[3] != (unsigned) (insn & 0xf))
	  op++;
	
	print_movxy (op,
		     (4 * ((insn & (is_movy ? 0x200 : 0x100)) == 0)
		      + 2 * is_movy
		      + 1 * ((insn & (is_movy ? 0x100 : 0x200)) != 0)),
		     (insn >> 6) & 3,
		     fprintf_fn, stream);
      }
    else
      fprintf_fn (stream, ".word 0x%x", insn);
a193 1
  unsigned int altnib1, nib4;
a219 10
      else if ((field_b & 0xf0) == 0x10
	       && info->mach != bfd_mach_sh_dsp
	       && info->mach != bfd_mach_sh3_dsp)
	{
	  fprintf_fn (stream, "pclr %s \t", du_tab[(field_b >> 0) & 3]);
	}
      else if ((field_b & 0xf3) != 0)
	{
	  fprintf_fn (stream, ".word 0x%x\t", field_b);
	}
a230 1
  nib4 = field_b >> 4 & 0xf;
a248 4
  if (nib1 == PPI3)
    altnib1 = PPI3NC;
  else
    altnib1 = nib1;
d251 1
a251 1
      if ((op->nibbles[1] == nib1 || op->nibbles[1] == altnib1)
a256 23
	  switch (op->nibbles[4])
	    {
	    case HEX_0:
	      break;
	    case HEX_XX00:
	      if ((nib4 & 3) != 0)
		continue;
	      break;
	    case HEX_1:
	      if ((nib4 & 3) != 1)
		continue;
	      break;
	    case HEX_00YY:
	      if ((nib4 & 0xc) != 0)
		continue;
	      break;
	    case HEX_4:
	      if ((nib4 & 0xc) != 4)
		continue;
	      break;
	    default:
	      abort ();
	    }
a333 1
    case bfd_mach_sh4_nofpu:
a335 7
    case bfd_mach_sh4a:
    case bfd_mach_sh4a_nofpu:
      target_arch = arch_sh4a;
      break;
    case bfd_mach_sh4al_dsp:
      target_arch = arch_sh4al_dsp;
      break;
a516 1
	    case AS_INC_N:
a519 1
	    case AS_DEC_N:
a522 1
	    case AS_IND_N:
d528 1
a528 1
	    case AS_PMOD_N:
@


1.13.14.4
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d400 1
a400 1
  unsigned char insn[4];
@


1.12
log
@	* sh-dis.c (print_insn_sh): If coff and bfd_mach_sh, use arch_sh4
	for disassembly.
@
text
@d307 2
a308 1
      if (bfd_asymbol_flavour(*info->symbols) == bfd_target_coff_flavour)
@


1.11
log
@print_insn_sh cleanup:

include:
	* dis-asm.h (print_insn_shl, print_insn_sh64l): Remove prototype.
gdb:
	* sh-tdep.c (gdb_print_insn_sh64): Delete.
	(gdb_print_insn_sh): Just set info->endian and use print_insn_sh.
	(sh_gdbarch_init): Always use gdb_print_insn_sh.
opcodes:
	* disassemble.c (disassembler): Just use print_insn_sh for bfd_arch_sh.
	* sh-dis.c (LITTLE_BIT): Delete.
	(print_insn_sh, print_insn_shl): Deleted.
	(print_insn_shx): Renamed to
	(print_insn_sh).  No longer static.  Handle SHmedia instructions.
	Use info->endian to determine endianness.
	* sh64-dis.c (print_insn_sh64, print_insn_sh64l): Delete.
	(print_insn_sh64x): No longer static.  Renamed to
	(print_insn_sh64).  Removed pfun_compact and endian arguments.
	If we got an uneven address to indicate SHmedia, adjust it.
	Return -2 for SHcompact instructions.
sim/sh64:
	* sim-if.c (sh64_disassemble_insn): Use  print_insn_sh instead of
	print_insn_shl.
@
text
@d304 5
@


1.10
log
@Contribute sh64-elf.
2001-10-08  Nick Clifton  <nickc@@cambridge.redhat.com>
* sh64-opc.c: Regenerate.
2001-03-13  DJ Delorie  <dj@@redhat.com>
* sh64-opc.h: Rename A_RESV_Fx to A_REUSE_PREV so that its
purpose is more obvious.
* sh64-opc.c (shmedia_table): Ditto.
* sh64-dis.c (initialize_shmedia_opcode_mask_table): Ditto.
(print_insn_shmedia): Ditto.
2001-03-12  DJ Delorie  <dj@@redhat.com>
* sh64-opc.c: Adjust comments to reflect reality: replace bits
3:0 with zeros (not "reserved"), replace "rrrrrr" with
"gggggg" for two-operand floating point opcodes.  Remove
"fsina".
2001-01-08  Hans-Peter Nilsson  <hpn@@cygnus.com>
* sh64-dis.c (print_insn_shmedia) <failing read_memory_func>:
Correct printing of .byte:s.  Return number of printed bytes or
-1; never 0.
(print_insn_sh64x) <not CRT_SH5_ISA16>: Ditto.  Print as .byte:s
to next four-byte-alignment if insn or data is not aligned.
2001-01-06  Hans-Peter Nilsson  <hpn@@cygnus.com>
* sh64-dis.c: Update comments and fix comment formatting.
(initialize_shmedia_opcode_mask_table) <case A_IMMM>:
Abort instead of setting length to 0.
(crange_qsort_cmpb, crange_qsort_cmpl, crange_bsearch_cmpb,
crange_bsearch_cmpl, sh64_get_contents_type,
sh64_address_in_cranges): Move to bfd/elf32-sh64.c.
2001-01-05  Hans-Peter Nilsson  <hpn@@cygnus.com>
* sh64-opc.c: Remove #if 0:d entries for instructions not found in
SH-5/ST50-023-04: fcosa.s, fsrra.s and prefo.
2000-12-30  Hans-Peter Nilsson  <hpn@@cygnus.com>
* sh64-dis.c (print_insn_shmedia): Display MOVI/SHORI-formed
address with same prefix as SHcompact.
In the disassembler, use a .cranges section for linked executables.
* sh64-dis.c (SAVED_MOVI_R, SAVED_MOVI_IMM): Move to head of file
and update for using structure in info->private_data.
(struct sh64_disassemble_info): New.
(is_shmedia_p): Delete.
(crange_qsort_cmpb): New function.
(crange_qsort_cmpl, crange_bsearch_cmpb): New functions.
(crange_bsearch_cmpl, sh64_address_in_cranges): New functions.
(init_sh64_disasm_info, sh64_get_contents_type_disasm): New functions.
(sh64_get_contents_type, sh64_address_is_shmedia): New functions.
(print_insn_shmedia): Correct displaying of address after MOVI/SHORI
pair.  Display addresses for linked executables only.
(print_insn_sh64x_media): Initialize info->private_data by calling
init_sh64_disasm_info.
(print_insn_sh64x): Ditto.  Find out type of contents by calling
sh64_contents_type_disasm.  Display data regions using ".long" and
".byte" similar to unrecognized opcodes.
2000-12-19  Hans-Peter Nilsson  <hpn@@cygnus.com>
* sh64-dis.c (is_shmedia_p): Check info->section and look for ISA
information in section flags before considering symbols.  Don't
assume an info->mach setting of bfd_mach_sh5 means SHmedia code.
* configure.in (bfd_sh_arch): Check presence of sh64 insns by
matching $target $canon_targets instead of looking at the
now-removed -DINCLUDE_SHMEDIA in $targ_cflags.
* configure: Regenerate.
2000-11-25  Hans-Peter Nilsson  <hpn@@cygnus.com>
* sh64-opc.c (shmedia_creg_table): New.
* sh64-opc.h (shmedia_creg_info): New type.
(shmedia_creg_table): Declare.
* sh64-dis.c (creg_name): New function.
(print_insn_shmedia): Use it.
* disassemble.c (disassembler) [ARCH_sh, INCLUDE_SHMEDIA]: Map
bfd_mach_sh5 to print_insn_sh64 if big-endian and to
print_insn_sh64l if little-endian.
* sh64-dis.c (print_insn_shmedia): Make r unsigned.
(print_insn_sh64l): New.
(print_insn_sh64x): New.
(print_insn_sh64x_media): New.
(print_insn_sh64): Break out code to print_insn_sh64x and
print_insn_sh64x_media.
2000-11-24  Hans-Peter Nilsson  <hpn@@cygnus.com>
* sh64-opc.h: New file
* sh64-opc.c: New file
* sh64-dis.c: New file
* Makefile.am: Add sh64 targets.
(HFILES): Add sh64-opc.h.
(CFILES): Add sh64-opc.c and sh64-dis.c.
(ALL_MACHINES): Add sh64 files.
* Makefile.in: Regenerate.
* configure.in: Add support for sh64 to bfd_sh_arch.
* configure: Regenerate.
* disassemble.c [ARCH_all] (INCLUDE_SHMEDIA): Define.
(disassembler) [ARCH_sh, INCLUDE_SHMEDIA]: Map bfd_mach_sh5 to
print_insn_sh64.
* sh-dis.c (print_insn_shx): Handle bfd_mach_sh5 as arch_sh4.
* po/POTFILES.in: Regenerate.
* po/opcodes.pot: Regenerate.
@
text
@a26 2
#define LITTLE_BIT 2

a31 1
static int print_insn_shx PARAMS ((bfd_vma, struct disassemble_info *));
d286 2
a287 2
static int
print_insn_shx (memaddr, info)
d324 5
d345 1
a345 1
  if (info->flags & LITTLE_BIT)
d376 1
a376 1
	  if (info->flags & LITTLE_BIT)
d682 1
a682 1
	  print_insn_shx (memaddr + 2, info);
d705 1
a705 1
		  if ((info->flags & LITTLE_BIT) != 0)
d712 1
a712 1
		  if ((info->flags & LITTLE_BIT) != 0)
a727 24
}

int
print_insn_shl (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  int r;

  info->flags = LITTLE_BIT;
  r = print_insn_shx (memaddr, info);
  return r;
}

int
print_insn_sh (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  int r;

  info->flags = 0;
  r = print_insn_shx (memaddr, info);
  return r;
@


1.10.8.1
log
@merge from trunk
@
text
@d27 2
d34 1
d289 2
a290 2
int
print_insn_sh (memaddr, info)
a306 6
      /* SH coff object files lack information about the machine type, so
         we end up with bfd_mach_sh unless it was set explicitly (which
	 could have happended if this is a call from gdb or the simulator.)  */
      if (info->symbols
	  && bfd_asymbol_flavour(*info->symbols) == bfd_target_coff_flavour)
	target_arch = arch_sh4;
a326 5
#ifdef INCLUDE_SHMEDIA
      status = print_insn_sh64 (memaddr, info);
      if (status != -2)
	return status;
#endif
d343 1
a343 1
  if (info->endian == BFD_ENDIAN_LITTLE)
d374 1
a374 1
	  if (info->endian == BFD_ENDIAN_LITTLE)
d680 1
a680 1
	  print_insn_sh (memaddr + 2, info);
d703 1
a703 1
		  if (info->endian == BFD_ENDIAN_LITTLE)
d710 1
a710 1
		  if (info->endian == BFD_ENDIAN_LITTLE)
d726 24
@


1.9
log
@fix encoding & decoding of DSP single data transfer instructions
@
text
@d326 5
@


1.8
log
@For include/opcode:
	* d30v.h: Fix declaration of reg_name_cnt.

	* d10v.h: Fix declaration of d10v_reg_name_cnt.

	* arc.h: Add prototypes from opcodes/arc-opc.c.

For opcodes:
	* tic54x-dis.c: Add unused attributes where needed.

	* z8k-dis.c (output_instr): Add unused attribute.

	* h8300-dis.c: Add missing prototypes.
	(bfd_h8_disassemble): Make static.

	* cris-dis.c: Add missing prototype.
	* h8500-dis.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* z8k-dis.c: Likewise.

	* d10v-dis.c: Add missing prototype.
	(dis_long): Remove unused variable.
	(dis_2_short): Likewise.

	* sh-dis.c: Add missing prototypes.
	* v850-opc.c: Likewise.
	Add unused attributes where needed.

	* ns32k-dis.c: Add missing prototypes.
	(bit_extract_simple): Remove unused variable.
@
text
@d468 1
a468 1
	      rn |= (rn & 2) << 1;
@


1.7
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000
d28 7
@


1.6
log
@	* sh-dis.c (print_insn_ddt): Make insn_x, insn_y unsigned.
	(print_insn_ppi): Make nib1, nib2, nib3 unsigned.
	Initialize variable dc to NULL.
	(print_insn_shx): Remove unused label d_reg_n.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 1998, 2000
@


1.6.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1997, 1998, 2000
@


1.6.2.2
log
@fix encoding and decoding of dsp single data transfer instructions
@
text
@d461 1
a461 1
	      rn |= (!(rn & 2)) << 2;
@


1.5
log
@2000-08-27  Kazu Hirata  <kazu@@hxi.com>

	* sh-dis.c: Fix formatting.
@
text
@d102 1
a102 1
      int insn_x, insn_y;
d185 2
a186 2
  int nib1, nib2, nib3;
  char *dc;
a614 1
	    d_reg_n:
@


1.4
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 96, 97, 1998, 2000 Free Software Foundation, Inc.
d38 1
a38 1
  fprintf_fn (stream,"%s\t", op->name);
d44 1
a44 1
	  fprintf_fn (stream, "@@r%d", rn);	
d47 1
a47 1
	  fprintf_fn (stream, "@@r%d+", rn);	
d50 1
a50 1
	  fprintf_fn (stream, "@@r%d+r8", rn);	
d53 1
a53 1
	  fprintf_fn (stream, "@@r%d+r9", rn);	
d68 1
a68 1
	fprintf_fn (stream, ",");	
d76 1
d106 1
a106 1
	  for (first_movx = sh_table; first_movx->nibbles[1] != MOVX; )
d108 1
a108 1
	  for (first_movy = first_movx; first_movy->nibbles[1] != MOVY; )
d114 2
a115 1
	  for (opx = first_movx; opx->nibbles[2] != insn_x; ) opx++;
d124 2
a125 1
	  for (opy = first_movy; opy->nibbles[2] != insn_y; ) opy++;
d181 2
a182 2
  static char *sx_tab[] = {"x0","x1","a0","a1"};
  static char *sy_tab[] = {"y0","y1","m0","m1"};
d199 4
a202 4
      static char *du_tab[] = {"x0","y0","a0","a1"};
      static char *se_tab[] = {"x0","x1","y0","a1"};
      static char *sf_tab[] = {"y0","y1","x0","a1"};
      static char *sg_tab[] = {"m0","m1","a0","a1"};
d250 1
a250 1
	  for (n = 0; n < 3 && op->arg[n] != A_END; n++) 
d254 1
a254 1
	      switch (op->arg[n]) 
d269 1
a269 1
		  fprintf_fn (stream ,"macl");
d282 1
a282 1
static int 
d292 1
a292 1
  bfd_vma relmask = ~ (bfd_vma) 0;
d325 1
a325 1
  if (status != 0) 
d331 1
a331 1
  if (info->flags & LITTLE_BIT) 
d339 1
a339 1
  else 
d356 1
a356 1
	  if (status != 0) 
d362 1
a362 1
	  if (info->flags & LITTLE_BIT) 
d374 1
a374 1
  for (op = sh_table; op->name; op++) 
d390 1
a390 1
	  if (i < 16) 
d399 1
a399 1
	      imm = (nibs[2] << 4) | (nibs[3]);	  
d402 1
a402 1
	      imm = ((char)imm) * 2 + 4 ;
d416 1
a416 1
	      imm = nibs[3] <<1;
d420 1
a420 1
	      imm = nibs[3] <<2;
d427 2
a428 2
	      imm = ((nibs[2] << 4) | nibs[3]) <<1;
	      relmask = ~ (bfd_vma) 1;
d431 2
a432 2
	      imm = ((nibs[2] << 4) | nibs[3]) <<2;
	      relmask = ~ (bfd_vma) 3;
d436 1
a436 1
	      imm = ((nibs[2] << 4) | nibs[3]) <<1;
d440 1
a440 1
	      imm = ((nibs[2] << 4) | nibs[3]) <<2;
d454 1
a454 1
	      break;	
d467 1
a467 1
	      abort();
d472 1
a472 1
      fprintf_fn (stream,"%s\t", op->name);
d474 1
a474 1
      for (n = 0; n < 3 && op->arg[n] != A_END; n++) 
d478 1
a478 1
	  switch (op->arg[n]) 
d481 1
a481 1
	      fprintf_fn (stream, "#%d", (char)(imm));
d490 1
a490 1
	      fprintf_fn (stream, "@@r%d+", rn);	
d493 1
a493 1
	      fprintf_fn (stream, "@@-r%d", rn);	
d496 1
a496 1
	      fprintf_fn (stream, "@@r%d", rn);	
d499 1
a499 1
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rn);	
d502 1
a502 1
	      fprintf_fn (stream, "@@r%d+r8", rn);	
d508 1
a508 1
	      fprintf_fn (stream, "@@r%d+", rm);	
d511 1
a511 1
	      fprintf_fn (stream, "@@-r%d", rm);	
d514 1
a514 1
	      fprintf_fn (stream, "@@r%d", rm);	
d517 1
a517 1
	      fprintf_fn (stream, "@@(%d,r%d)", imm, rm);	
d529 1
a529 1
	      break; 
d532 1
a532 1
	      break; 
d534 1
a534 1
	      fprintf_fn (stream, "@@(%d,gbr)",imm);
d592 1
a592 1
	      fprintf_fn (stream ,"macl");
d640 1
a640 1
	      fprintf_fn (stream, "fv%d", rn*4);
d643 1
a643 1
	      fprintf_fn (stream, "fv%d", rm*4);
d649 1
a649 1
	      abort();
d662 1
a662 1
		  && (op->name[1] == 'r' 
d681 1
a681 1
	  if (relmask == ~ (bfd_vma) 1)
d717 1
a717 1
int 
d729 1
a729 1
int 
@


1.3
log
@sh-dsp REPEAT support:
opcodes:

        * sh-opc.h (sh_nibble_type): Remove DISP_8 and DISP_4.
        Split IMM_[48]{,BY[24]} into IMM[01]_[48]{,BY[24]}.  Add REPEAT.
        (sh_arg_type): Add A_PC.
        (sh_table): Update entries using immediates.  Add repeat.
        * sh-dis.c (print_insn_shx): Remove DISP_8 and DISP_4.
        Split IMM_[48]{,BY[24]} into IMM[01]_[48]{,BY[24]}.  Add REPEAT.

gas:

        * config/tc-sh.c (immediate): Delete.
        (sh_operand_info): Add immediate member.
        (parse_reg): Use A_PC for pc.
        (parse_exp): Add second argument 'op'.  All callers changed.
        (parse_at): Expect pc to be coded as A_PC.
        Use immediate field in *op.
        (insert): Add fourth argument 'op'.  All callers changed.
        (build_relax): Add second argument 'op'.  All callers changed.
        (insert_loop_bounds): New function.
        (build_Mytes): Remove DISP_4.
        Split IMM_[48]{,BY[24]} into IMM[01]_[48]{,BY[24]}.  Add REPEAT.
        (assemble_ppi): Use immediate field in *operand.
        (sh_force_relocation): Handle BFD_RELOC_SH_LOOP_{START,END}.
        (md_apply_fix): Likewise.
        (tc_gen_reloc): Likewise.  Check for a pcrel BFD_RELOC_SH_LABEL.

include/coff:

        * sh.h (R_SH_LOOP_START, R_SH_LOOP_END): Define.

include/elf:

        * sh.h (R_SH_LOOP_START, R_SH_LOOP_END): New RELOC_NUMBERs.

bfd:

        * reloc.c (_bfd_relocate_contents): Add BFD_RELOC_SH_LOOP_START and
        BFD_RELOC_SH_LOOP_END.
        * elf32-sh.c (sh_elf_howto_tab): Change special_func to
        sh_elf_ignore_reloc for all entries that sh_elf_reloc used to ignore.
        Add entries for R_SH_LOOP_START and R_SH_LOOP_END.
        (sh_elf_reloc_loop): New function.
        (sh_elf_reloc): No need to test for always-to-be-ignored relocs
        any more.
        (sh_rel): Add entries for BFD_RELOC_SH_LOOP_{START,END}.
        (sh_elf_relocate_section): Handle BFD_RELOC_SH_LOOP_{START,END}.
        * bfd-in2.h, libbfd.h: Regenerate.
@
text
@d19 1
@


1.2
log
@bfd:
Reinstate bits of sh4 support that got accidentally deleted.
Add sh-dsp support.

bfd:

	* archures.c (bfd_mach_sh2, bfd_mach_sh_dsp): New macros.
	(bfd_mach_sh3_dsp): Likewise.
	(bfd_mach_sh4): Reinstate.
	(bfd_default_scan): Recognize 7410, 7708, 7729 and 7750.
	* bfd-in2.h: Regenerate.
	* coff-sh.c (struct sh_opcode): flags is no longer short.
	(USESAS, USESAS_REG, USESR8, SETSAS, SETSAS_REG): New macros.
	(sh_opcode41, sh_opcode42): Integrate as sh_opcode41.
	(sh_opcode01, sh_opcode02, sh_opcode40): Add sh-dsp opcodes.
	(sh_opcode41, sh_opcode4, sh_opcode80): Likewise.
	(sh_opcodes): No longer const.
	(sh_dsp_opcodef0, sh_dsp_opcodef): New arrays.
	(sh_insn_uses_reg): Check for USESAS and USESR8.
	(sh_insn_sets_reg, sh_insns_conflict): Check for SETSAS.
	(_bfd_sh_align_load_span): Return early for SH4.
	Modify sh_opcodes lookup table for sh-dsp / sh3-dsp.
	Take into account that field b of a parallel processing insn
	could be mistaken for a separate insn.
	* cpu-sh.c (arch_info_struct): New array elements for
	sh2, sh-dsp and sh3-dsp.
	Reinstate element for sh4.
	(SH2_NEXT, SH_DSP_NEXT, SH3_DSP_NEXT): New macros.
	(SH4_NEXT): Reinstate.
	(SH3_NEXT, SH3E_NEXT): Adjust.
	* elf-bfd.h (_sh_elf_set_mach_from_flags): Declare.
	* elf32-sh.c (sh_elf_set_private_flags): New function.
	(sh_elf_copy_private_data, sh_elf_set_mach_from_flags): Likewise.
	(sh_elf_merge_private_data): New function.
	(elf_backend_object_p, bfd_elf32_bfd_set_private_bfd_flags): Define.
	(bfd_elf32_bfd_copy_private_bfd_data): Define.
	(bfd_elf32_bfd_merge_private_bfd_data): Change to
	sh_elf_merge_private_data.

gas:

	* config/tc-sh.c ("elf/sh.h"): Include.
	(sh_dsp, valid_arch, reg_x, reg_y, reg_efg): New static variables.
	(md.begin): Initialize target_arch.
	Only include opcodes in has table that match selected architecture.
	(parse_reg): Recognize register names for sh-dsp.
	(parse_at): Recognize post-modify addressing.
	(get_operands): The leading space is now optional.
	(get_specific): Remove FDREG_N support.  Add support for sh-dsp
	arguments.  Update valid_arch.
	(build_Mytes): Add support for SDT_REG_N.
	(find_cooked_opcode): New function, broken out of md_assemble.
	(assemble_ppi, sh_elf_final_processing): New functions.
	(md_assemble): Use find_cooked_opcode and assemble_ppi.
	(md_longopts, md_parse_option): New option: -dsp.
	* config/tc-sh.h (elf_tc_final_processing): Define.
	(sh_elf_final_processing): Declare.

include/elf:

	* sh.h: (EF_SH_MACH_MASK, EF_SH_UNKNOWN, EF_SH1, EF_SH2): New macros.
	(EF_SH3, EF_SH_HAS_DSP, EF_SH_DSP, EF_SH3_DSP): Likewise.
	(EF_SH_HAS_FP, EF_SH3E, EF_SH4, EF_SH_MERGE_MACH): Likewise.

opcodes:

	* sh-dis.c (print_movxy, print_insn_ddt, print_dsp_reg): New functions.
	(print_insn_ppi): Likewise.
	(print_insn_shx): Use info->mach to select appropriate insn set.
	Add support for sh-dsp.  Remove FD_REG_N support.
	* sh-opc.h (sh_nibble_type): Add new values for sh-dsp support.
	(sh_arg_type): Likewise.  Remove FD_REG_N.
	(sh_dsp_reg_nums): New enum.
	(arch_sh1, arch_sh2, arch_sh3, arch_sh3e, arch_sh4): New macros.
	(arch_sh_dsp, arch_sh3_dsp, arch_sh1_up, arch_sh2_up): Likewise.
	(arch_sh3_up, arch_sh3e_up, arch_sh4_up, arch_sh_dsp_up): Likewise.
	(arch_sh3_dsp_up): Likewise.
	(sh_opcode_info): New field: arch.
	(sh_table): Split up insn with FD_REG_N into ones with F_REG_N and
	D_REG_N.  Fill in arch field.  Add sh-dsp insns.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
d405 2
a406 1
	    case IMM_4:
d409 2
a410 1
	    case IMM_4BY2:
d413 2
a414 1
	    case IMM_4BY4:
d417 2
a418 1
	    case IMM_8:
d429 2
a430 1
	    case IMM_8BY2:
d433 2
a434 1
	    case IMM_8BY4:
a436 6
	    case DISP_8:
	      imm = (nibs[2] << 4) | (nibs[3]);	  
	      goto ok;
	    case DISP_4:
	      imm = nibs[3];
	      goto ok;
d459 1
@


1.2.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@a17 1
#include "sysdep.h"
@


1.1
log
@Initial revision
@
text
@d27 250
d289 28
d343 26
d379 2
d450 10
d495 3
d546 30
a596 3
	    case FD_REG_N:
	      if (0)
		goto d_reg_n;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

