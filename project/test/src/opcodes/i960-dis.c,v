head	1.11;
access;
symbols
	sid-snapshot-20180601:1.11
	sid-snapshot-20180501:1.11
	sid-snapshot-20180401:1.11
	sid-snapshot-20180301:1.11
	sid-snapshot-20180201:1.11
	sid-snapshot-20180101:1.11
	sid-snapshot-20171201:1.11
	sid-snapshot-20171101:1.11
	sid-snapshot-20171001:1.11
	sid-snapshot-20170901:1.11
	sid-snapshot-20170801:1.11
	sid-snapshot-20170701:1.11
	sid-snapshot-20170601:1.11
	sid-snapshot-20170501:1.11
	sid-snapshot-20170401:1.11
	sid-snapshot-20170301:1.11
	sid-snapshot-20170201:1.11
	sid-snapshot-20170101:1.11
	sid-snapshot-20161201:1.11
	sid-snapshot-20161101:1.11
	sid-snapshot-20160901:1.11
	sid-snapshot-20160801:1.11
	sid-snapshot-20160701:1.11
	sid-snapshot-20160601:1.11
	sid-snapshot-20160501:1.11
	sid-snapshot-20160401:1.11
	sid-snapshot-20160301:1.11
	sid-snapshot-20160201:1.11
	sid-snapshot-20160101:1.11
	sid-snapshot-20151201:1.11
	sid-snapshot-20151101:1.11
	sid-snapshot-20151001:1.11
	sid-snapshot-20150901:1.11
	sid-snapshot-20150801:1.11
	sid-snapshot-20150701:1.11
	sid-snapshot-20150601:1.11
	sid-snapshot-20150501:1.11
	sid-snapshot-20150401:1.11
	sid-snapshot-20150301:1.11
	sid-snapshot-20150201:1.11
	sid-snapshot-20150101:1.11
	sid-snapshot-20141201:1.11
	sid-snapshot-20141101:1.11
	sid-snapshot-20141001:1.11
	sid-snapshot-20140901:1.11
	sid-snapshot-20140801:1.11
	sid-snapshot-20140701:1.11
	sid-snapshot-20140601:1.11
	sid-snapshot-20140501:1.11
	sid-snapshot-20140401:1.11
	sid-snapshot-20140301:1.11
	sid-snapshot-20140201:1.11
	sid-snapshot-20140101:1.11
	sid-snapshot-20131201:1.11
	sid-snapshot-20131101:1.11
	sid-snapshot-20131001:1.11
	binutils-2_24-branch:1.11.0.4
	binutils-2_24-branchpoint:1.11
	binutils-2_21_1:1.10
	sid-snapshot-20130901:1.11
	gdb_7_6_1-2013-08-30-release:1.11
	sid-snapshot-20130801:1.11
	sid-snapshot-20130701:1.11
	sid-snapshot-20130601:1.11
	sid-snapshot-20130501:1.11
	gdb_7_6-2013-04-26-release:1.11
	sid-snapshot-20130401:1.11
	binutils-2_23_2:1.10.18.1
	gdb_7_6-branch:1.11.0.2
	gdb_7_6-2013-03-12-branchpoint:1.11
	sid-snapshot-20130301:1.11
	sid-snapshot-20130201:1.11
	sid-snapshot-20130101:1.11
	sid-snapshot-20121201:1.11
	gdb_7_5_1-2012-11-29-release:1.10
	binutils-2_23_1:1.10.18.1
	sid-snapshot-20121101:1.11
	binutils-2_23:1.10.18.1
	sid-snapshot-20121001:1.11
	sid-snapshot-20120901:1.11
	gdb_7_5-2012-08-17-release:1.10
	sid-snapshot-20120801:1.11
	binutils-2_23-branch:1.10.0.18
	binutils-2_23-branchpoint:1.10
	gdb_7_5-branch:1.10.0.16
	gdb_7_5-2012-07-18-branchpoint:1.10
	sid-snapshot-20120701:1.10
	sid-snapshot-20120601:1.10
	sid-snapshot-20120501:1.10
	binutils-2_22_branch:1.10.0.14
	gdb_7_4_1-2012-04-26-release:1.10
	sid-snapshot-20120401:1.10
	sid-snapshot-20120301:1.10
	sid-snapshot-20120201:1.10
	gdb_7_4-2012-01-24-release:1.10
	sid-snapshot-20120101:1.10
	gdb_7_4-branch:1.10.0.12
	gdb_7_4-2011-12-13-branchpoint:1.10
	sid-snapshot-20111201:1.10
	binutils-2_22:1.10
	sid-snapshot-20111101:1.10
	sid-snapshot-20111001:1.10
	binutils-2_22-branch:1.10.0.10
	binutils-2_22-branchpoint:1.10
	gdb_7_3_1-2011-09-04-release:1.10
	sid-snapshot-20110901:1.10
	sid-snapshot-20110801:1.10
	gdb_7_3-2011-07-26-release:1.10
	sid-snapshot-20110701:1.10
	sid-snapshot-20110601:1.10
	sid-snapshot-20110501:1.10
	gdb_7_3-branch:1.10.0.8
	gdb_7_3-2011-04-01-branchpoint:1.10
	sid-snapshot-20110401:1.10
	sid-snapshot-20110301:1.10
	sid-snapshot-20110201:1.10
	sid-snapshot-20110101:1.10
	binutils-2_21:1.10
	sid-snapshot-20101201:1.10
	binutils-2_21-branch:1.10.0.6
	binutils-2_21-branchpoint:1.10
	sid-snapshot-20101101:1.10
	sid-snapshot-20101001:1.10
	binutils-2_20_1:1.9
	gdb_7_2-2010-09-02-release:1.10
	sid-snapshot-20100901:1.10
	sid-snapshot-20100801:1.10
	gdb_7_2-branch:1.10.0.4
	gdb_7_2-2010-07-07-branchpoint:1.10
	sid-snapshot-20100701:1.10
	sid-snapshot-20100601:1.10
	sid-snapshot-20100501:1.10
	sid-snapshot-20100401:1.10
	gdb_7_1-2010-03-18-release:1.10
	sid-snapshot-20100301:1.10
	gdb_7_1-branch:1.10.0.2
	gdb_7_1-2010-02-18-branchpoint:1.10
	sid-snapshot-20100201:1.10
	sid-snapshot-20100101:1.10
	gdb_7_0_1-2009-12-22-release:1.9
	sid-snapshot-20091201:1.9
	sid-snapshot-20091101:1.9
	binutils-2_20:1.9
	gdb_7_0-2009-10-06-release:1.9
	sid-snapshot-20091001:1.9
	gdb_7_0-branch:1.9.0.4
	gdb_7_0-2009-09-16-branchpoint:1.9
	arc-sim-20090309:1.8
	binutils-arc-20081103-branch:1.8.0.30
	binutils-arc-20081103-branchpoint:1.8
	binutils-2_20-branch:1.9.0.2
	binutils-2_20-branchpoint:1.9
	sid-snapshot-20090901:1.8
	sid-snapshot-20090801:1.8
	msnyder-checkpoint-072509-branch:1.8.0.28
	msnyder-checkpoint-072509-branchpoint:1.8
	sid-snapshot-20090701:1.8
	dje-cgen-play1-branch:1.8.0.26
	dje-cgen-play1-branchpoint:1.8
	sid-snapshot-20090601:1.8
	sid-snapshot-20090501:1.8
	sid-snapshot-20090401:1.8
	arc-20081103-branch:1.8.0.24
	arc-20081103-branchpoint:1.8
	arc-insight_6_8-branch:1.8.0.22
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.20
	insight_6_8-branchpoint:1.8
	sid-snapshot-20090301:1.8
	binutils-2_19_1:1.8
	sid-snapshot-20090201:1.8
	sid-snapshot-20090101:1.8
	reverse-20081226-branch:1.8.0.18
	reverse-20081226-branchpoint:1.8
	sid-snapshot-20081201:1.8
	multiprocess-20081120-branch:1.8.0.16
	multiprocess-20081120-branchpoint:1.8
	sid-snapshot-20081101:1.8
	binutils-2_19:1.8
	sid-snapshot-20081001:1.8
	reverse-20080930-branch:1.8.0.14
	reverse-20080930-branchpoint:1.8
	binutils-2_19-branch:1.8.0.12
	binutils-2_19-branchpoint:1.8
	sid-snapshot-20080901:1.8
	sid-snapshot-20080801:1.8
	reverse-20080717-branch:1.8.0.10
	reverse-20080717-branchpoint:1.8
	sid-snapshot-20080701:1.8
	msnyder-reverse-20080609-branch:1.8.0.8
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.7.0.34
	drow-reverse-20070409-branchpoint:1.7
	sid-snapshot-20080601:1.8
	sid-snapshot-20080501:1.8
	sid-snapshot-20080403:1.8
	sid-snapshot-20080401:1.8
	gdb_6_8-2008-03-27-release:1.8
	sid-snapshot-20080301:1.8
	gdb_6_8-branch:1.8.0.6
	gdb_6_8-2008-02-26-branchpoint:1.8
	sid-snapshot-20080201:1.8
	sid-snapshot-20080101:1.8
	sid-snapshot-20071201:1.8
	sid-snapshot-20071101:1.8
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	sid-snapshot-20071001:1.8
	gdb_6_7-branch:1.8.0.4
	gdb_6_7-2007-09-07-branchpoint:1.8
	binutils-2_18:1.8
	binutils-2_18-branch:1.8.0.2
	binutils-2_18-branchpoint:1.8
	insight_6_6-20070208-release:1.7
	binutils-csl-coldfire-4_1-32:1.7
	binutils-csl-sourcerygxx-4_1-32:1.7
	gdb_6_6-2006-12-18-release:1.7
	binutils-csl-innovasic-fido-3_4_4-33:1.7
	binutils-csl-sourcerygxx-3_4_4-32:1.6
	binutils-csl-coldfire-4_1-30:1.7
	binutils-csl-sourcerygxx-4_1-30:1.7
	binutils-csl-coldfire-4_1-28:1.7
	binutils-csl-sourcerygxx-4_1-29:1.7
	binutils-csl-sourcerygxx-4_1-28:1.7
	gdb_6_6-branch:1.7.0.32
	gdb_6_6-2006-11-15-branchpoint:1.7
	binutils-csl-arm-2006q3-27:1.7
	binutils-csl-sourcerygxx-4_1-27:1.7
	binutils-csl-arm-2006q3-26:1.7
	binutils-csl-sourcerygxx-4_1-26:1.7
	binutils-csl-sourcerygxx-4_1-25:1.7
	binutils-csl-sourcerygxx-4_1-24:1.7
	binutils-csl-sourcerygxx-4_1-23:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	binutils-csl-sourcerygxx-4_1-21:1.7
	binutils-csl-arm-2006q3-21:1.7
	binutils-csl-sourcerygxx-4_1-22:1.7
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.7
	binutils-csl-sourcerygxx-4_1-20:1.7
	binutils-csl-arm-2006q3-19:1.7
	binutils-csl-sourcerygxx-4_1-19:1.7
	binutils-csl-sourcerygxx-4_1-18:1.7
	binutils-csl-renesas-4_1-9:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	binutils-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	binutils-csl-renesas-4_1-8:1.7
	binutils-csl-renesas-4_1-7:1.7
	binutils-csl-renesas-4_1-6:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	binutils-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	gdb-csl-sourcerygxx-4_1-14:1.7
	binutils-csl-sourcerygxx-4_1-14:1.7
	binutils-csl-sourcerygxx-4_1-15:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	binutils-csl-sourcerygxx-4_1-13:1.7
	binutils-2_17:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	binutils-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	binutils-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.7
	binutils-csl-wrs-linux-3_4_4-24:1.6
	binutils-csl-wrs-linux-3_4_4-23:1.6
	gdb-csl-sourcerygxx-4_1-9:1.7
	binutils-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	binutils-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	binutils-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	binutils-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	binutils-csl-sourcerygxx-4_1-6:1.7
	binutils-csl-wrs-linux-3_4_4-22:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	binutils-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	binutils-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.7.0.30
	gdb_6_5-2006-05-14-branchpoint:1.7
	binutils-csl-coldfire-4_1-10:1.7
	gdb-csl-sourcerygxx-4_1-5:1.7
	binutils-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.7.0.28
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.7
	binutils-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.7.0.26
	msnyder-reverse-20060502-branchpoint:1.7
	binutils-csl-wrs-linux-3_4_4-21:1.6
	gdb-csl-morpho-4_1-4:1.7
	binutils-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	binutils-csl-sourcerygxx-3_4_4-17:1.7
	binutils-csl-wrs-linux-3_4_4-20:1.6
	readline_5_1-import-branch:1.7.0.24
	readline_5_1-import-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	binutils-2_17-branch:1.7.0.22
	binutils-2_17-branchpoint:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.20
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.18
	msnyder-reverse-20060331-branchpoint:1.7
	binutils-csl-2_17-branch:1.7.0.16
	binutils-csl-2_17-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.14
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.12
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.10
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.6
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.4
	gdb-csl-arm-20051020-branchpoint:1.7
	binutils-csl-gxxpro-3_4-branch:1.6.0.32
	binutils-csl-gxxpro-3_4-branchpoint:1.6
	binutils-2_16_1:1.6
	msnyder-tracepoint-checkpoint-branch:1.7.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.6
	binutils-csl-arm-2005q1b:1.6
	binutils-2_16:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	binutils-csl-arm-2005q1a:1.6
	csl-arm-20050325-branch:1.6.0.30
	csl-arm-20050325-branchpoint:1.6
	binutils-csl-arm-2005q1-branch:1.6.0.28
	binutils-csl-arm-2005q1-branchpoint:1.6
	binutils-2_16-branch:1.6.0.26
	binutils-2_16-branchpoint:1.6
	csl-arm-2004-q3d:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.22
	gdb_6_3-20041019-branchpoint:1.6
	csl-arm-2004-q3:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.24
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	binutils-2_15:1.6
	binutils-2_15-branchpoint:1.6
	csl-arm-2004-q1a:1.6
	csl-arm-2004-q1:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.18
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.16
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.12
	drow_intercu-20040221-branchpoint:1.6
	binutils-2_15-branch:1.6.0.10
	cagney_bfdfile-20040213-branch:1.6.0.8
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.6
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	csl-arm-2003-q4:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.6.0.4
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.2
	cagney_x86i386-20030821-branch:1.5.0.62
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.60
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.58
	jimb-ppc64-linux-20030613-branchpoint:1.5
	binutils-2_14:1.5
	cagney_convert-20030606-branch:1.5.0.56
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.54
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.50
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	binutils-2_14-branch:1.5.0.46
	binutils-2_14-branchpoint:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.44
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.42
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.40
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.38
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.36
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.34
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.32
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.30
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.28
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.26
	cagney-unwind-20030108-branchpoint:1.5
	binutils-2_13_2_1:1.5
	binutils-2_13_2:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	binutils-2_13_1:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.24
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.22
	carlton_dictionary-20020920-branchpoint:1.5
	sid-20020905-branchpoint:1.5
	sid-20020905-branch:1.5.0.20
	gdb_5_3-branch:1.5.0.18
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.16
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.14
	readline_4_3-import-branchpoint:1.5
	binutils-2_13:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	binutils-2_13-branchpoint:1.5
	binutils-2_13-branch:1.5.0.12
	kseitz_interps-20020528-branch:1.5.0.10
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.8
	cagney_regbuf-20020515-branchpoint:1.5
	binutils-2_12_1:1.5
	jimb-macro-020506-branch:1.5.0.6
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	binutils-2_12:1.5
	gdb_5_2-branch:1.5.0.4
	gdb_5_2-2002-03-03-branchpoint:1.5
	binutils-2_12-branch:1.5.0.2
	binutils-2_12-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	binutils-2_11_2:1.2.4.1
	binutils-2_11_1:1.2.4.1
	binutils-2_11:1.2
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.4
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.1.1.1.2.1
	binutils-2_10:1.1.1.1.2.1
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.11
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2012.08.01.00.41.34;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2009.12.11.13.42.17;	author nickc;	state Exp;
branches
	1.10.18.1;
next	1.9;

1.9
date	2009.09.02.07.20.29;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.07.07.34.28;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.14.15.16.57;	author aj;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.20.15.28.25;	author nickc;	state Exp;
branches
	1.5.22.1
	1.5.24.1;
next	1.4;

1.4
date	2001.08.21.08.42.28;	author aj;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.13.22.58.35;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.10.18.1
date	2012.09.04.14.01.41;	author gingold;	state Exp;
branches;
next	;

1.5.22.1
date	2003.09.17.21.28.58;	author carlton;	state Exp;
branches;
next	;

1.5.24.1
date	2003.12.14.20.28.06;	author drow;	state Exp;
branches;
next	;

1.2.4.1
date	2001.06.07.03.18.34;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;


desc
@@


1.11
log
@	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@/* Disassemble i80960 instructions.
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2003,
   2005, 2007  Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "sysdep.h"
#include "dis-asm.h"

static const char *const reg_names[] = {
/*  0 */	"pfp", "sp",  "rip", "r3",  "r4",  "r5",  "r6",  "r7",
/*  8 */	"r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",
/* 16 */	"g0",  "g1",  "g2",  "g3",  "g4",  "g5",  "g6",  "g7",
/* 24 */	"g8",  "g9",  "g10", "g11", "g12", "g13", "g14", "fp",
/* 32 */	"pc",  "ac",  "ip",  "tc",  "fp0", "fp1", "fp2", "fp3"
};


static FILE *stream;		/* Output goes here */
static struct disassemble_info *info;
static void print_addr (bfd_vma);
static void ctrl (bfd_vma, unsigned long, unsigned long);
static void cobr (bfd_vma, unsigned long, unsigned long);
static void reg (unsigned long);
static int mem (bfd_vma, unsigned long, unsigned long, int);
static void ea (bfd_vma, int, const char *, const char *, int, unsigned int);
static void dstop (int, int, int);
static void regop (int, int, int, int);
static void invalid (int);
static int pinsn (bfd_vma, unsigned long, unsigned long);
static void put_abs (unsigned long, unsigned long);


/* Print the i960 instruction at address 'memaddr' in debugged memory,
   on INFO->STREAM.  Returns length of the instruction, in bytes.  */

int
print_insn_i960 (bfd_vma memaddr, struct disassemble_info *info_arg)
{
  unsigned int word1, word2 = 0xdeadbeef;
  bfd_byte buffer[8];
  int status;

  info = info_arg;
  stream = info->stream;

  /* Read word1.  Only read word2 if the instruction
     needs it, to prevent reading past the end of a section.  */

  status = (*info->read_memory_func) (memaddr, (bfd_byte *) buffer, 4, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }

  word1 = bfd_getl32 (buffer);

  /* Divide instruction set into classes based on high 4 bits of opcode.  */
  switch ( (word1 >> 28) & 0xf )
    {
    default:
      break;
    case 0x8:
    case 0x9:
    case 0xa:
    case 0xb:
    case 0xc:
      /* Read word2.  */
      status = (*info->read_memory_func)
	(memaddr + 4, (bfd_byte *) (buffer + 4), 4, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      word2 = bfd_getl32 (buffer + 4);
      break;
    }

  return pinsn( memaddr, word1, word2 );
}

#define IN_GDB

/*****************************************************************************
 *	All code below this point should be identical with that of
 *	the disassembler in gdmp960.

 A noble sentiment, but at least in cosmetic ways (info->fprintf_func), it
 just ain't so. -kingdon, 31 Mar 93
 *****************************************************************************/

struct tabent {
  char *name;
  short numops;
};

struct sparse_tabent {
  int opcode;
  char *name;
  short numops;
};

static int
pinsn (bfd_vma memaddr, unsigned long word1, unsigned long word2)
{
  int instr_len;

  instr_len = 4;
  put_abs (word1, word2);

  /* Divide instruction set into classes based on high 4 bits of opcode.  */
  switch ((word1 >> 28) & 0xf)
    {
    case 0x0:
    case 0x1:
      ctrl (memaddr, word1, word2);
      break;
    case 0x2:
    case 0x3:
      cobr (memaddr, word1, word2);
      break;
    case 0x5:
    case 0x6:
    case 0x7:
      reg (word1);
      break;
    case 0x8:
    case 0x9:
    case 0xa:
    case 0xb:
    case 0xc:
      instr_len = mem (memaddr, word1, word2, 0);
      break;
    default:
      /* Invalid instruction, print as data word.  */
      invalid (word1);
      break;
    }
  return instr_len;
}

/* CTRL format.. */

static void
ctrl (bfd_vma memaddr, unsigned long word1, unsigned long word2 ATTRIBUTE_UNUSED)
{
  int i;
  static const struct tabent ctrl_tab[] = {
    { NULL,		0, },	/* 0x00 */
    { NULL,		0, },	/* 0x01 */
    { NULL,		0, },	/* 0x02 */
    { NULL,		0, },	/* 0x03 */
    { NULL,		0, },	/* 0x04 */
    { NULL,		0, },	/* 0x05 */
    { NULL,		0, },	/* 0x06 */
    { NULL,		0, },	/* 0x07 */
    { "b",		1, },	/* 0x08 */
    { "call",		1, },	/* 0x09 */
    { "ret",		0, },	/* 0x0a */
    { "bal",		1, },	/* 0x0b */
    { NULL,		0, },	/* 0x0c */
    { NULL,		0, },	/* 0x0d */
    { NULL,		0, },	/* 0x0e */
    { NULL,		0, },	/* 0x0f */
    { "bno",		1, },	/* 0x10 */
    { "bg",		1, },	/* 0x11 */
    { "be",		1, },	/* 0x12 */
    { "bge",		1, },	/* 0x13 */
    { "bl",		1, },	/* 0x14 */
    { "bne",		1, },	/* 0x15 */
    { "ble",		1, },	/* 0x16 */
    { "bo",		1, },	/* 0x17 */
    { "faultno",	0, },	/* 0x18 */
    { "faultg",		0, },	/* 0x19 */
    { "faulte",		0, },	/* 0x1a */
    { "faultge",	0, },	/* 0x1b */
    { "faultl",		0, },	/* 0x1c */
    { "faultne",	0, },	/* 0x1d */
    { "faultle",	0, },	/* 0x1e */
    { "faulto",		0, },	/* 0x1f */
  };

  i = (word1 >> 24) & 0xff;
  if ((ctrl_tab[i].name == NULL) || ((word1 & 1) != 0))
    {
      invalid (word1);
      return;
    }

  (*info->fprintf_func) (stream, "%s", ctrl_tab[i].name);
  if (word1 & 2)
    /* Predicts branch not taken.  */
    (*info->fprintf_func) (stream, ".f");

  if (ctrl_tab[i].numops == 1)
    {
      /* Extract displacement and convert to address.  */
      word1 &= 0x00ffffff;

      if (word1 & 0x00800000)
	{
	  /* Sign bit is set.  */
	  word1 |= (-1 & ~0xffffff);	/* Sign extend.  */
	}

      (*info->fprintf_func) (stream, "\t");
      print_addr (word1 + memaddr);
    }
}

/* COBR format.  */

static void
cobr (bfd_vma memaddr, unsigned long word1, unsigned long word2 ATTRIBUTE_UNUSED)
{
  int src1;
  int src2;
  int i;

  static const struct tabent cobr_tab[] = {
    { "testno",	1, },	/* 0x20 */
    { "testg",	1, },	/* 0x21 */
    { "teste",	1, },	/* 0x22 */
    { "testge",	1, },	/* 0x23 */
    { "testl",	1, },	/* 0x24 */
    { "testne",	1, },	/* 0x25 */
    { "testle",	1, },	/* 0x26 */
    { "testo",	1, },	/* 0x27 */
    { NULL,	0, },	/* 0x28 */
    { NULL,	0, },	/* 0x29 */
    { NULL,	0, },	/* 0x2a */
    { NULL,	0, },	/* 0x2b */
    { NULL,	0, },	/* 0x2c */
    { NULL,	0, },	/* 0x2d */
    { NULL,	0, },	/* 0x2e */
    { NULL,	0, },	/* 0x2f */
    { "bbc",	3, },	/* 0x30 */
    { "cmpobg",	3, },	/* 0x31 */
    { "cmpobe",	3, },	/* 0x32 */
    { "cmpobge",3, },	/* 0x33 */
    { "cmpobl",	3, },	/* 0x34 */
    { "cmpobne",3, },	/* 0x35 */
    { "cmpoble",3, },	/* 0x36 */
    { "bbs",	3, },	/* 0x37 */
    { "cmpibno",3, },	/* 0x38 */
    { "cmpibg",	3, },	/* 0x39 */
    { "cmpibe",	3, },	/* 0x3a */
    { "cmpibge",3, },	/* 0x3b */
    { "cmpibl",	3, },	/* 0x3c */
    { "cmpibne",3, },	/* 0x3d */
    { "cmpible",3, },	/* 0x3e */
    { "cmpibo",	3, },	/* 0x3f */
  };

  i = ((word1 >> 24) & 0xff) - 0x20;
  if (cobr_tab[i].name == NULL)
    {
      invalid (word1);
      return;
    }

  (*info->fprintf_func) (stream, "%s", cobr_tab[i].name);

  /* Predicts branch not taken.  */
  if (word1 & 2)
    (*info->fprintf_func) (stream, ".f");

  (*info->fprintf_func) (stream, "\t");

  src1 = (word1 >> 19) & 0x1f;
  src2 = (word1 >> 14) & 0x1f;

  if (word1 & 0x02000)
    /* M1 is 1 */
    (*info->fprintf_func) (stream, "%d", src1);
  else
    (*info->fprintf_func) (stream, "%s", reg_names[src1]);

  if (cobr_tab[i].numops > 1)
    {
      if (word1 & 1)
	/* S2 is 1.  */
	(*info->fprintf_func) (stream, ",sf%d,", src2);
      else
	/* S1 is 0.  */
	(*info->fprintf_func) (stream, ",%s,", reg_names[src2]);

      /* Extract displacement and convert to address.  */
      word1 &= 0x00001ffc;
      if (word1 & 0x00001000)
	/* Negative displacement.  */
	word1 |= (-1 & ~0x1fff);	/* Sign extend.  */

      print_addr (memaddr + word1);
    }
}

/* MEM format.  */
/* Returns instruction length: 4 or 8.  */

static int
mem (bfd_vma memaddr, unsigned long word1, unsigned long word2, int noprint)
{
  int i, j;
  int len;
  int mode;
  int offset;
  const char *reg1, *reg2, *reg3;

  /* This lookup table is too sparse to make it worth typing in, but not
     so large as to make a sparse array necessary.  We create the table
     at runtime.  */

  /* NOTE: In this table, the meaning of 'numops' is:
      1: single operand
      2: 2 operands, load instruction
     -2: 2 operands, store instruction.  */
  static struct tabent *mem_tab;
  /* Opcodes of 0x8X, 9X, aX, bX, and cX must be in the table.  */
#define MEM_MIN	0x80
#define MEM_MAX	0xcf
#define MEM_SIZ	( * sizeof(struct tabent))

  static const struct sparse_tabent mem_init[] = {
    { 0x80,	"ldob",	 2 },
    { 0x82,	"stob",	-2 },
    { 0x84,	"bx",	 1 },
    { 0x85,	"balx",	 2 },
    { 0x86,	"callx", 1 },
    { 0x88,	"ldos",	 2 },
    { 0x8a,	"stos",	-2 },
    { 0x8c,	"lda",	 2 },
    { 0x90,	"ld",	 2 },
    { 0x92,	"st",	-2 },
    { 0x98,	"ldl",	 2 },
    { 0x9a,	"stl",	-2 },
    { 0xa0,	"ldt",	 2 },
    { 0xa2,	"stt",	-2 },
    { 0xac,	"dcinva", 1 },
    { 0xb0,	"ldq",	 2 },
    { 0xb2,	"stq",	-2 },
    { 0xc0,	"ldib",	 2 },
    { 0xc2,	"stib",	-2 },
    { 0xc8,	"ldis",	 2 },
    { 0xca,	"stis",	-2 },
    { 0,	NULL,	0 }
  };
  static struct tabent mem_tab_buf[MEM_MAX - MEM_MIN + 1];

  if (mem_tab == NULL)
    {
      mem_tab = mem_tab_buf;

      for (i = 0; mem_init[i].opcode != 0; i++)
	{
	  j = mem_init[i].opcode - MEM_MIN;
	  mem_tab[j].name = mem_init[i].name;
	  mem_tab[j].numops = mem_init[i].numops;
	}
    }

  i = ((word1 >> 24) & 0xff) - MEM_MIN;
  mode = (word1 >> 10) & 0xf;

  if ((mem_tab[i].name != NULL)		/* Valid instruction */
      && ((mode == 5) || (mode >= 12)))
    /* With 32-bit displacement.  */
    len = 8;
  else
    len = 4;

  if (noprint)
    return len;

  if ((mem_tab[i].name == NULL) || (mode == 6))
    {
      invalid (word1);
      return len;
    }

  (*info->fprintf_func) (stream, "%s\t", mem_tab[i].name);

  reg1 = reg_names[ (word1 >> 19) & 0x1f ];	/* MEMB only */
  reg2 = reg_names[ (word1 >> 14) & 0x1f ];
  reg3 = reg_names[ word1 & 0x1f ];		/* MEMB only */
  offset = word1 & 0xfff;				/* MEMA only  */

  switch (mem_tab[i].numops)
    {
    case 2: /* LOAD INSTRUCTION */
      if (mode & 4)
	{			/* MEMB FORMAT */
	  ea (memaddr, mode, reg2, reg3, word1, word2);
	  (*info->fprintf_func) (stream, ",%s", reg1);
	}
      else
	{				/* MEMA FORMAT */
	  (*info->fprintf_func) (stream, "0x%x", (unsigned) offset);

	  if (mode & 8)
	    (*info->fprintf_func) (stream, "(%s)", reg2);

	  (*info->fprintf_func)(stream, ",%s", reg1);
	}
      break;

    case -2: /* STORE INSTRUCTION */
      if (mode & 4)
	{
	  /* MEMB FORMAT */
	  (*info->fprintf_func) (stream, "%s,", reg1);
	  ea (memaddr, mode, reg2, reg3, word1, word2);
	}
      else
	{
	  /* MEMA FORMAT */
	  (*info->fprintf_func) (stream, "%s,0x%x", reg1, (unsigned) offset);

	  if (mode & 8)
	    (*info->fprintf_func) (stream, "(%s)", reg2);
	}
      break;

    case 1: /* BX/CALLX INSTRUCTION */
      if (mode & 4)
	{
	  /* MEMB FORMAT */
	  ea (memaddr, mode, reg2, reg3, word1, word2);
	}
      else
	{
	  /* MEMA FORMAT */
	  (*info->fprintf_func) (stream, "0x%x", (unsigned) offset);
	  if (mode & 8)
	    (*info->fprintf_func) (stream, "(%s)", reg2);
	}
      break;
    }

  return len;
}

/* REG format.  */

static void
reg (unsigned long word1)
{
  int i, j;
  int opcode;
  int fp;
  int m1, m2, m3;
  int s1, s2;
  int src, src2, dst;
  char *mnemp;

  /* This lookup table is too sparse to make it worth typing in, but not
     so large as to make a sparse array necessary.  We create the table
     at runtime.  */

  /* NOTE: In this table, the meaning of 'numops' is:
	 1: single operand, which is NOT a destination.
	-1: single operand, which IS a destination.
	 2: 2 operands, the 2nd of which is NOT a destination.
	-2: 2 operands, the 2nd of which IS a destination.
	 3: 3 operands

	If an opcode mnemonic begins with "F", it is a floating-point
	opcode (the "F" is not printed).  */

  static struct tabent *reg_tab;
  static const struct sparse_tabent reg_init[] =
  {
#define REG_MIN	0x580
    { 0x580,	"notbit",	3 },
    { 0x581,	"and",		3 },
    { 0x582,	"andnot",	3 },
    { 0x583,	"setbit",	3 },
    { 0x584,	"notand",	3 },
    { 0x586,	"xor",		3 },
    { 0x587,	"or",		3 },
    { 0x588,	"nor",		3 },
    { 0x589,	"xnor",		3 },
    { 0x58a,	"not",		-2 },
    { 0x58b,	"ornot",	3 },
    { 0x58c,	"clrbit",	3 },
    { 0x58d,	"notor",	3 },
    { 0x58e,	"nand",		3 },
    { 0x58f,	"alterbit",	3 },
    { 0x590,	"addo",		3 },
    { 0x591,	"addi",		3 },
    { 0x592,	"subo",		3 },
    { 0x593,	"subi",		3 },
    { 0x594,	"cmpob",	2 },
    { 0x595,	"cmpib",	2 },
    { 0x596,	"cmpos",	2 },
    { 0x597,	"cmpis",	2 },
    { 0x598,	"shro",		3 },
    { 0x59a,	"shrdi",	3 },
    { 0x59b,	"shri",		3 },
    { 0x59c,	"shlo",		3 },
    { 0x59d,	"rotate",	3 },
    { 0x59e,	"shli",		3 },
    { 0x5a0,	"cmpo",		2 },
    { 0x5a1,	"cmpi",		2 },
    { 0x5a2,	"concmpo",	2 },
    { 0x5a3,	"concmpi",	2 },
    { 0x5a4,	"cmpinco",	3 },
    { 0x5a5,	"cmpinci",	3 },
    { 0x5a6,	"cmpdeco",	3 },
    { 0x5a7,	"cmpdeci",	3 },
    { 0x5ac,	"scanbyte",	2 },
    { 0x5ad,	"bswap",	-2 },
    { 0x5ae,	"chkbit",	2 },
    { 0x5b0,	"addc",		3 },
    { 0x5b2,	"subc",		3 },
    { 0x5b4,	"intdis",	0 },
    { 0x5b5,	"inten",	0 },
    { 0x5cc,	"mov",		-2 },
    { 0x5d8,	"eshro",	3 },
    { 0x5dc,	"movl",		-2 },
    { 0x5ec,	"movt",		-2 },
    { 0x5fc,	"movq",		-2 },
    { 0x600,	"synmov",	2 },
    { 0x601,	"synmovl",	2 },
    { 0x602,	"synmovq",	2 },
    { 0x603,	"cmpstr",	3 },
    { 0x604,	"movqstr",	3 },
    { 0x605,	"movstr",	3 },
    { 0x610,	"atmod",	3 },
    { 0x612,	"atadd",	3 },
    { 0x613,	"inspacc",	-2 },
    { 0x614,	"ldphy",	-2 },
    { 0x615,	"synld",	-2 },
    { 0x617,	"fill",		3 },
    { 0x630,	"sdma",		3 },
    { 0x631,	"udma",		0 },
    { 0x640,	"spanbit",	-2 },
    { 0x641,	"scanbit",	-2 },
    { 0x642,	"daddc",	3 },
    { 0x643,	"dsubc",	3 },
    { 0x644,	"dmovt",	-2 },
    { 0x645,	"modac",	3 },
    { 0x646,	"condrec",	-2 },
    { 0x650,	"modify",	3 },
    { 0x651,	"extract",	3 },
    { 0x654,	"modtc",	3 },
    { 0x655,	"modpc",	3 },
    { 0x656,	"receive",	-2 },
    { 0x658,	"intctl",	-2 },
    { 0x659,	"sysctl",	3 },
    { 0x65b,	"icctl",	3 },
    { 0x65c,	"dcctl",	3 },
    { 0x65d,	"halt",		0 },
    { 0x660,	"calls",	1 },
    { 0x662,	"send",		3 },
    { 0x663,	"sendserv",	1 },
    { 0x664,	"resumprcs",	1 },
    { 0x665,	"schedprcs",	1 },
    { 0x666,	"saveprcs",	0 },
    { 0x668,	"condwait",	1 },
    { 0x669,	"wait",		1 },
    { 0x66a,	"signal",	1 },
    { 0x66b,	"mark",		0 },
    { 0x66c,	"fmark",	0 },
    { 0x66d,	"flushreg",	0 },
    { 0x66f,	"syncf",	0 },
    { 0x670,	"emul",		3 },
    { 0x671,	"ediv",		3 },
    { 0x673,	"ldtime",	-1 },
    { 0x674,	"Fcvtir",	-2 },
    { 0x675,	"Fcvtilr",	-2 },
    { 0x676,	"Fscalerl",	3 },
    { 0x677,	"Fscaler",	3 },
    { 0x680,	"Fatanr",	3 },
    { 0x681,	"Flogepr",	3 },
    { 0x682,	"Flogr",	3 },
    { 0x683,	"Fremr",	3 },
    { 0x684,	"Fcmpor",	2 },
    { 0x685,	"Fcmpr",	2 },
    { 0x688,	"Fsqrtr",	-2 },
    { 0x689,	"Fexpr",	-2 },
    { 0x68a,	"Flogbnr",	-2 },
    { 0x68b,	"Froundr",	-2 },
    { 0x68c,	"Fsinr",	-2 },
    { 0x68d,	"Fcosr",	-2 },
    { 0x68e,	"Ftanr",	-2 },
    { 0x68f,	"Fclassr",	1 },
    { 0x690,	"Fatanrl",	3 },
    { 0x691,	"Flogeprl",	3 },
    { 0x692,	"Flogrl",	3 },
    { 0x693,	"Fremrl",	3 },
    { 0x694,	"Fcmporl",	2 },
    { 0x695,	"Fcmprl",	2 },
    { 0x698,	"Fsqrtrl",	-2 },
    { 0x699,	"Fexprl",	-2 },
    { 0x69a,	"Flogbnrl",	-2 },
    { 0x69b,	"Froundrl",	-2 },
    { 0x69c,	"Fsinrl",	-2 },
    { 0x69d,	"Fcosrl",	-2 },
    { 0x69e,	"Ftanrl",	-2 },
    { 0x69f,	"Fclassrl",	1 },
    { 0x6c0,	"Fcvtri",	-2 },
    { 0x6c1,	"Fcvtril",	-2 },
    { 0x6c2,	"Fcvtzri",	-2 },
    { 0x6c3,	"Fcvtzril",	-2 },
    { 0x6c9,	"Fmovr",	-2 },
    { 0x6d9,	"Fmovrl",	-2 },
    { 0x6e1,	"Fmovre",	-2 },
    { 0x6e2,	"Fcpysre",	3 },
    { 0x6e3,	"Fcpyrsre",	3 },
    { 0x701,	"mulo",		3 },
    { 0x708,	"remo",		3 },
    { 0x70b,	"divo",		3 },
    { 0x741,	"muli",		3 },
    { 0x748,	"remi",		3 },
    { 0x749,	"modi",		3 },
    { 0x74b,	"divi",		3 },
    { 0x780,	"addono",	3 },
    { 0x781,	"addino",	3 },
    { 0x782,	"subono",	3 },
    { 0x783,	"subino",	3 },
    { 0x784,	"selno",	3 },
    { 0x78b,	"Fdivr",	3 },
    { 0x78c,	"Fmulr",	3 },
    { 0x78d,	"Fsubr",	3 },
    { 0x78f,	"Faddr",	3 },
    { 0x790,	"addog",	3 },
    { 0x791,	"addig",        3 },
    { 0x792,	"subog",	3 },
    { 0x793,	"subig",	3 },
    { 0x794,	"selg",		3 },
    { 0x79b,	"Fdivrl",	3 },
    { 0x79c,	"Fmulrl",	3 },
    { 0x79d,	"Fsubrl",	3 },
    { 0x79f,	"Faddrl",	3 },
    { 0x7a0,	"addoe",	3 },
    { 0x7a1,	"addie",        3 },
    { 0x7a2,	"suboe",	3 },
    { 0x7a3,	"subie",	3 },
    { 0x7a4,	"sele",		3 },
    { 0x7b0,	"addoge",	3 },
    { 0x7b1,	"addige",	3 },
    { 0x7b2,	"suboge",	3 },
    { 0x7b3,	"subige",	3 },
    { 0x7b4,	"selge",	3 },
    { 0x7c0,	"addol",	3 },
    { 0x7c1,	"addil",	3 },
    { 0x7c2,	"subol",	3 },
    { 0x7c3,	"subil",	3 },
    { 0x7c4,	"sell",		3 },
    { 0x7d0,	"addone",	3 },
    { 0x7d1,	"addine",	3 },
    { 0x7d2,	"subone",	3 },
    { 0x7d3,	"subine",	3 },
    { 0x7d4,	"selne",	3 },
    { 0x7e0,	"addole",	3 },
    { 0x7e1,	"addile",	3 },
    { 0x7e2,	"subole",	3 },
    { 0x7e3,	"subile",	3 },
    { 0x7e4,	"selle",	3 },
    { 0x7f0,	"addoo",	3 },
    { 0x7f1,	"addio",	3 },
    { 0x7f2,	"suboo",	3 },
    { 0x7f3,	"subio",	3 },
    { 0x7f4,	"selo",		3 },
#define REG_MAX 0x7f4
    { 0,	NULL,		0 }
  };
  static struct tabent reg_tab_buf[REG_MAX - REG_MIN + 1];

  if (reg_tab == NULL)
    {
      reg_tab = reg_tab_buf;

      for (i = 0; reg_init[i].opcode != 0; i++)
	{
	  j = reg_init[i].opcode - REG_MIN;
	  reg_tab[j].name = reg_init[i].name;
	  reg_tab[j].numops = reg_init[i].numops;
	}
    }

  opcode = ((word1 >> 20) & 0xff0) | ((word1 >> 7) & 0xf);
  i = opcode - REG_MIN;

  if ((opcode<REG_MIN) || (opcode>REG_MAX) || (reg_tab[i].name==NULL))
    {
      invalid (word1);
      return;
    }

  mnemp = reg_tab[i].name;
  if (*mnemp == 'F')
    {
      fp = 1;
      mnemp++;
    }
  else
    {
      fp = 0;
    }

  (*info->fprintf_func) (stream, "%s", mnemp);

  s1   = (word1 >> 5)  & 1;
  s2   = (word1 >> 6)  & 1;
  m1   = (word1 >> 11) & 1;
  m2   = (word1 >> 12) & 1;
  m3   = (word1 >> 13) & 1;
  src  =  word1        & 0x1f;
  src2 = (word1 >> 14) & 0x1f;
  dst  = (word1 >> 19) & 0x1f;

  if  (reg_tab[i].numops != 0)
    {
      (*info->fprintf_func) (stream, "\t");

    switch (reg_tab[i].numops)
      {
      case 1:
	regop (m1, s1, src, fp);
	break;
      case -1:
	dstop (m3, dst, fp);
	break;
      case 2:
	regop (m1, s1, src, fp);
	(*info->fprintf_func) (stream, ",");
	regop (m2, s2, src2, fp);
	break;
      case -2:
	regop (m1, s1, src, fp);
	(*info->fprintf_func) (stream, ",");
	dstop (m3, dst, fp);
	break;
      case 3:
	regop (m1, s1, src, fp);
	(*info->fprintf_func) (stream, ",");
	regop (m2, s2, src2, fp);
	(*info->fprintf_func) (stream, ",");
	dstop (m3, dst, fp);
	break;
      }
    }
}

/* Print out effective address for memb instructions.  */

static void
ea (bfd_vma memaddr, int mode, const char *reg2, const char *reg3, int word1,
    unsigned int word2)
{
  int scale;
  static const int scale_tab[] = { 1, 2, 4, 8, 16 };

  scale = (word1 >> 7) & 0x07;

  if ((scale > 4) || (((word1 >> 5) & 0x03) != 0))
    {
      invalid (word1);
      return;
    }
  scale = scale_tab[scale];

  switch (mode)
    {
    case 4:						/* (reg) */
      (*info->fprintf_func)( stream, "(%s)", reg2 );
      break;
    case 5:						/* displ+8(ip) */
      print_addr (word2 + 8 + memaddr);
      break;
    case 7:						/* (reg)[index*scale] */
      if (scale == 1)
	(*info->fprintf_func) (stream, "(%s)[%s]", reg2, reg3);
      else
	(*info->fprintf_func) (stream, "(%s)[%s*%d]", reg2, reg3, scale);
      break;
    case 12:					/* displacement */
      print_addr ((bfd_vma) word2);
      break;
    case 13:					/* displ(reg) */
      print_addr ((bfd_vma) word2);
      (*info->fprintf_func) (stream, "(%s)", reg2);
      break;
    case 14:					/* displ[index*scale] */
      print_addr ((bfd_vma) word2);
      if (scale == 1)
	(*info->fprintf_func) (stream, "[%s]", reg3);
      else
	(*info->fprintf_func) (stream, "[%s*%d]", reg3, scale);
      break;
    case 15:				/* displ(reg)[index*scale] */
      print_addr ((bfd_vma) word2);
      if (scale == 1)
	(*info->fprintf_func) (stream, "(%s)[%s]", reg2, reg3);
      else
	(*info->fprintf_func) (stream, "(%s)[%s*%d]", reg2, reg3, scale);
      break;
    default:
      invalid (word1);
      return;
    }
}


/* Register Instruction Operand.  */

static void
regop (int mode, int spec, int fp_reg, int fp)
{
  if (fp)
    {
      /* Floating point instruction.  */
      if (mode == 1)
	{
	  /* FP operand.  */
	  switch (fp_reg)
	    {
	    case 0:  (*info->fprintf_func) (stream, "fp0");
	      break;
	    case 1:  (*info->fprintf_func) (stream, "fp1");
	      break;
	    case 2:  (*info->fprintf_func) (stream, "fp2");
	      break;
	    case 3:  (*info->fprintf_func) (stream, "fp3");
	      break;
	    case 16: (*info->fprintf_func) (stream, "0f0.0");
	      break;
	    case 22: (*info->fprintf_func) (stream, "0f1.0");
	      break;
	    default: (*info->fprintf_func) (stream, "?");
	      break;
	    }
	}
      else
	{
	  /* Non-FP register.  */
	  (*info->fprintf_func) (stream, "%s", reg_names[fp_reg]);
	}
    }
  else
    {
      /* Not floating point.  */
      if (mode == 1)
	{
	  /* Literal.  */
	  (*info->fprintf_func) (stream, "%d", fp_reg);
	}
      else
	{
	  /* Register.  */
	  if (spec == 0)
	    (*info->fprintf_func) (stream, "%s", reg_names[fp_reg]);
	  else
	    (*info->fprintf_func) (stream, "sf%d", fp_reg);
	}
    }
}

/* Register Instruction Destination Operand.  */

static void
dstop (int mode, int dest_reg, int fp)
{
  /* 'dst' operand can't be a literal. On non-FP instructions,  register
     mode is assumed and "m3" acts as if were "s3";  on FP-instructions,
     sf registers are not allowed so m3 acts normally.  */
  if (fp)
    regop (mode, 0, dest_reg, fp);
  else
    regop (0, mode, dest_reg, fp);
}

static void
invalid (int word1)
{
  (*info->fprintf_func) (stream, ".word\t0x%08x", (unsigned) word1);
}

static void
print_addr (bfd_vma a)
{
  (*info->print_address_func) (a, info);
}

static void
put_abs (unsigned long word1 ATTRIBUTE_UNUSED,
	 unsigned long word2 ATTRIBUTE_UNUSED)
{
#ifdef IN_GDB
  return;
#else
  int len;

  switch ((word1 >> 28) & 0xf)
    {
    case 0x8:
    case 0x9:
    case 0xa:
    case 0xb:
    case 0xc:
      /* MEM format instruction.  */
      len = mem (0, word1, word2, 1);
      break;
    default:
      len = 4;
      break;
    }

  if (len == 8)
    (*info->fprintf_func) (stream, "%08x %08x\t", word1, word2);
  else
    (*info->fprintf_func) (stream, "%08x         \t", word1);
#endif
}
@


1.10
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d207 1
a207 1
  (*info->fprintf_func) (stream, ctrl_tab[i].name);
d279 1
a279 1
  (*info->fprintf_func) (stream, cobr_tab[i].name);
d294 1
a294 1
    (*info->fprintf_func) (stream, reg_names[src1]);
d720 1
a720 1
  (*info->fprintf_func) (stream, mnemp);
d856 1
a856 1
	  (*info->fprintf_func) (stream, reg_names[fp_reg]);
d871 1
a871 1
	    (*info->fprintf_func) (stream, reg_names[fp_reg]);
@


1.10.18.1
log
@gas/
	* config/tc-mips.c (ISA_SUPPORTS_DSP_ASE): Also set if microMIPS
	mode.
	(ISA_SUPPORTS_DSPR2_ASE): Likewise.
	(macro_build) <'2'>: Handle microMIPS.
2012-07-31  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>

gas/
	* gas/mips/micromips@@mips32-dsp.d: New test.
	* gas/mips/micromips@@mips32-dspr2.d: New test.
	* gas/mips/mips32-dsp.s: Update padding.
	* gas/mips/mips32-dspr2.s: Likewise.
	* gas/mips/mips.exp: Use run_dump_test_arches to run MIPS32 DSP
	tests.
2012-07-31  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

include/
2012-07-31  Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

opcodes/
2012-08-01  Alan Modra  <amodra@@gmail.com>

	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d207 1
a207 1
  (*info->fprintf_func) (stream, "%s", ctrl_tab[i].name);
d279 1
a279 1
  (*info->fprintf_func) (stream, "%s", cobr_tab[i].name);
d294 1
a294 1
    (*info->fprintf_func) (stream, "%s", reg_names[src1]);
d720 1
a720 1
  (*info->fprintf_func) (stream, "%s", mnemp);
d856 1
a856 1
	  (*info->fprintf_func) (stream, "%s", reg_names[fp_reg]);
d871 1
a871 1
	    (*info->fprintf_func) (stream, "%s", reg_names[fp_reg]);
@


1.9
log
@update copyright dates
@
text
@d827 1
a827 1
regop (int mode, int spec, int reg, int fp)
d835 1
a835 1
	  switch (reg)
d856 1
a856 1
	  (*info->fprintf_func) (stream, reg_names[reg]);
d865 1
a865 1
	  (*info->fprintf_func) (stream, "%d", reg);
d871 1
a871 1
	    (*info->fprintf_func) (stream, reg_names[reg]);
d873 1
a873 1
	    (*info->fprintf_func) (stream, "sf%d", reg);
d881 1
a881 1
dstop (int mode, int reg, int fp)
d887 1
a887 1
    regop (mode, 0, reg, fp);
d889 1
a889 1
    regop (0, mode, reg, fp);
@


1.8
log
@Change source files over to GPLv3.
@
text
@d3 1
a3 1
   2007  Free Software Foundation, Inc.
@


1.7
log
@Update the address and phone number of the FSF
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2003
   Free Software Foundation, Inc.
d5 16
a20 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the
Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
02110-1301, USA.  */
@


1.6
log
@
	* i386-dis.c: Convert to ISO C90 prototypes.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewiwse.
	* i960-dis.c: Likewise.
	* ia64-opc.c: Likewise.
@
text
@d17 2
a18 2
Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
@


1.5
log
@Fix compile time warnings
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
d34 11
a44 11
static void print_addr PARAMS ((bfd_vma));
static void ctrl PARAMS ((bfd_vma, unsigned long, unsigned long));
static void cobr PARAMS ((bfd_vma, unsigned long, unsigned long));
static void reg PARAMS ((unsigned long));
static int mem PARAMS ((bfd_vma, unsigned long, unsigned long, int));
static void ea PARAMS ((bfd_vma, int, const char *, const char *, int, unsigned int));
static void dstop PARAMS ((int, int, int));
static void regop PARAMS ((int, int, int, int));
static void invalid PARAMS ((int));
static int pinsn PARAMS ((bfd_vma, unsigned long, unsigned long));
static void put_abs PARAMS ((unsigned long, unsigned long));
d51 1
a51 3
print_insn_i960 (memaddr, info_arg)
    bfd_vma memaddr;
    struct disassemble_info *info_arg;
d119 1
a119 3
pinsn (memaddr, word1, word2)
     bfd_vma memaddr;
     unsigned long word1, word2;
d122 1
a122 1
  
d160 1
a160 4
ctrl (memaddr, word1, word2)
     bfd_vma memaddr;
     unsigned long word1;
     unsigned long word2 ATTRIBUTE_UNUSED;
d229 1
a229 4
cobr (memaddr, word1, word2)
     bfd_vma memaddr;
     unsigned long word1;
     unsigned long word2 ATTRIBUTE_UNUSED;
d234 1
a234 1
  
d317 1
a317 5
mem (memaddr, word1, word2, noprint)
     bfd_vma memaddr;
     unsigned long word1, word2;
     int noprint;		/* If TRUE, return instruction length, but
				   don't output any text.  */
d324 1
a324 1
  
d384 1
a384 1
  else 
d415 1
a415 1
	  if (mode & 8) 
d434 1
a434 1
	  if (mode & 8) 
d461 1
a461 2
reg (word1)
     unsigned long word1;
d476 8
a483 8
   	 1: single operand, which is NOT a destination.
   	-1: single operand, which IS a destination.
   	 2: 2 operands, the 2nd of which is NOT a destination.
   	-2: 2 operands, the 2nd of which IS a destination.
   	 3: 3 operands
   
   	If an opcode mnemonic begins with "F", it is a floating-point
   	opcode (the "F" is not printed).  */
d765 2
a766 7
ea (memaddr, mode, reg2, reg3, word1, word2)
     bfd_vma memaddr;
     int mode;
     const char *reg2;
     const char *reg3;
     int word1;
     unsigned int word2;
d825 1
a825 2
regop (mode, spec, reg, fp)
     int mode, spec, reg, fp;
d879 1
a879 2
dstop (mode, reg, fp)
     int mode, reg, fp;
d891 1
a891 2
invalid (word1)
     int word1;
d897 1
a897 2
print_addr (a)
     bfd_vma a;
d903 2
a904 3
put_abs (word1, word2)
     unsigned long word1 ATTRIBUTE_UNUSED;
     unsigned long word2 ATTRIBUTE_UNUSED;
@


1.5.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2003
d34 11
a44 11
static void print_addr (bfd_vma);
static void ctrl (bfd_vma, unsigned long, unsigned long);
static void cobr (bfd_vma, unsigned long, unsigned long);
static void reg (unsigned long);
static int mem (bfd_vma, unsigned long, unsigned long, int);
static void ea (bfd_vma, int, const char *, const char *, int, unsigned int);
static void dstop (int, int, int);
static void regop (int, int, int, int);
static void invalid (int);
static int pinsn (bfd_vma, unsigned long, unsigned long);
static void put_abs (unsigned long, unsigned long);
d51 3
a53 1
print_insn_i960 (bfd_vma memaddr, struct disassemble_info *info_arg)
d121 3
a123 1
pinsn (bfd_vma memaddr, unsigned long word1, unsigned long word2)
d126 1
a126 1

d164 4
a167 1
ctrl (bfd_vma memaddr, unsigned long word1, unsigned long word2 ATTRIBUTE_UNUSED)
d236 4
a239 1
cobr (bfd_vma memaddr, unsigned long word1, unsigned long word2 ATTRIBUTE_UNUSED)
d244 1
a244 1

d327 5
a331 1
mem (bfd_vma memaddr, unsigned long word1, unsigned long word2, int noprint)
d338 1
a338 1

d398 1
a398 1
  else
d429 1
a429 1
	  if (mode & 8)
d448 1
a448 1
	  if (mode & 8)
d475 2
a476 1
reg (unsigned long word1)
d491 8
a498 8
	 1: single operand, which is NOT a destination.
	-1: single operand, which IS a destination.
	 2: 2 operands, the 2nd of which is NOT a destination.
	-2: 2 operands, the 2nd of which IS a destination.
	 3: 3 operands

	If an opcode mnemonic begins with "F", it is a floating-point
	opcode (the "F" is not printed).  */
d780 7
a786 2
ea (bfd_vma memaddr, int mode, const char *reg2, const char *reg3, int word1,
    unsigned int word2)
d845 2
a846 1
regop (int mode, int spec, int reg, int fp)
d900 2
a901 1
dstop (int mode, int reg, int fp)
d913 2
a914 1
invalid (int word1)
d920 2
a921 1
print_addr (bfd_vma a)
d927 3
a929 2
put_abs (unsigned long word1 ATTRIBUTE_UNUSED,
	 unsigned long word2 ATTRIBUTE_UNUSED)
@


1.5.22.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2003
d34 11
a44 11
static void print_addr (bfd_vma);
static void ctrl (bfd_vma, unsigned long, unsigned long);
static void cobr (bfd_vma, unsigned long, unsigned long);
static void reg (unsigned long);
static int mem (bfd_vma, unsigned long, unsigned long, int);
static void ea (bfd_vma, int, const char *, const char *, int, unsigned int);
static void dstop (int, int, int);
static void regop (int, int, int, int);
static void invalid (int);
static int pinsn (bfd_vma, unsigned long, unsigned long);
static void put_abs (unsigned long, unsigned long);
d51 3
a53 1
print_insn_i960 (bfd_vma memaddr, struct disassemble_info *info_arg)
d121 3
a123 1
pinsn (bfd_vma memaddr, unsigned long word1, unsigned long word2)
d126 1
a126 1

d164 4
a167 1
ctrl (bfd_vma memaddr, unsigned long word1, unsigned long word2 ATTRIBUTE_UNUSED)
d236 4
a239 1
cobr (bfd_vma memaddr, unsigned long word1, unsigned long word2 ATTRIBUTE_UNUSED)
d244 1
a244 1

d327 5
a331 1
mem (bfd_vma memaddr, unsigned long word1, unsigned long word2, int noprint)
d338 1
a338 1

d398 1
a398 1
  else
d429 1
a429 1
	  if (mode & 8)
d448 1
a448 1
	  if (mode & 8)
d475 2
a476 1
reg (unsigned long word1)
d491 8
a498 8
	 1: single operand, which is NOT a destination.
	-1: single operand, which IS a destination.
	 2: 2 operands, the 2nd of which is NOT a destination.
	-2: 2 operands, the 2nd of which IS a destination.
	 3: 3 operands

	If an opcode mnemonic begins with "F", it is a floating-point
	opcode (the "F" is not printed).  */
d780 7
a786 2
ea (bfd_vma memaddr, int mode, const char *reg2, const char *reg3, int word1,
    unsigned int word2)
d845 2
a846 1
regop (int mode, int spec, int reg, int fp)
d900 2
a901 1
dstop (int mode, int reg, int fp)
d913 2
a914 1
invalid (int word1)
d920 2
a921 1
print_addr (bfd_vma a)
d927 3
a929 2
put_abs (unsigned long word1 ATTRIBUTE_UNUSED,
	 unsigned long word2 ATTRIBUTE_UNUSED)
@


1.4
log
@	* i960-dis.c: Add parameters for prototypes
	(ctrl): Add unused attributes.
	(cobr): Likewise.
	(put_abs): Likewise.

	* mips-dis.c: Add missing prototypes.
	* a29k-dis.c: Likewise.
	* arc-dis.c: Likewise.
	* ia64-opc.c: Likewise.

	* s390-dis.c: Add missing prototypes.
	(init_disasm): Remove unused attribute since the parameter is
	used.
@
text
@d39 1
a39 1
static void ea PARAMS ((bfd_vma, int, char *, char *, int, unsigned int));
d121 3
a123 3
pinsn( memaddr, word1, word2 )
    bfd_vma memaddr;
    unsigned long word1, word2;
d125 35
a159 1
	int instr_len;
d161 1
a161 2
	instr_len = 4;
	put_abs( word1, word2 );
a162 33
	/* Divide instruction set into classes based on high 4 bits of opcode*/
	switch ( (word1 >> 28) & 0xf ){
	case 0x0:
	case 0x1:
		ctrl( memaddr, word1, word2 );
		break;
	case 0x2:
	case 0x3:
		cobr( memaddr, word1, word2 );
		break;
	case 0x5:
	case 0x6:
	case 0x7:
		reg( word1 );
		break;
	case 0x8:
	case 0x9:
	case 0xa:
	case 0xb:
	case 0xc:
		instr_len = mem( memaddr, word1, word2, 0 );
		break;
	default:
		/* invalid instruction, print as data word */
		invalid( word1 );
		break;
	}
	return instr_len;
}

/****************************************/
/* CTRL format				*/
/****************************************/
d164 4
a167 4
ctrl( memaddr, word1, word2 )
    bfd_vma memaddr;
    unsigned long word1;
    unsigned long word2 ATTRIBUTE_UNUSED;
d169 66
a234 61
	int i;
	static const struct tabent ctrl_tab[] = {
	  { NULL,		0, },	/* 0x00 */
	  { NULL,		0, },	/* 0x01 */
	  { NULL,		0, },	/* 0x02 */
	  { NULL,		0, },	/* 0x03 */
	  { NULL,		0, },	/* 0x04 */
	  { NULL,		0, },	/* 0x05 */
	  { NULL,		0, },	/* 0x06 */
	  { NULL,		0, },	/* 0x07 */
	  { "b",		1, },	/* 0x08 */
	  { "call",		1, },	/* 0x09 */
	  { "ret",		0, },	/* 0x0a */
	  { "bal",		1, },	/* 0x0b */
	  { NULL,		0, },	/* 0x0c */
	  { NULL,		0, },	/* 0x0d */
	  { NULL,		0, },	/* 0x0e */
	  { NULL,		0, },	/* 0x0f */
	  { "bno",		1, },	/* 0x10 */
	  { "bg",		1, },	/* 0x11 */
	  { "be",		1, },	/* 0x12 */
	  { "bge",		1, },	/* 0x13 */
	  { "bl",		1, },	/* 0x14 */
	  { "bne",		1, },	/* 0x15 */
	  { "ble",		1, },	/* 0x16 */
	  { "bo",		1, },	/* 0x17 */
	  { "faultno",		0, },	/* 0x18 */
	  { "faultg",		0, },	/* 0x19 */
	  { "faulte",		0, },	/* 0x1a */
	  { "faultge",		0, },	/* 0x1b */
	  { "faultl",		0, },	/* 0x1c */
	  { "faultne",		0, },	/* 0x1d */
	  { "faultle",		0, },	/* 0x1e */
	  { "faulto",		0, },	/* 0x1f */
	};

	i = (word1 >> 24) & 0xff;
	if ( (ctrl_tab[i].name == NULL) || ((word1 & 1) != 0) ){
		invalid( word1 );
		return;
	}

	(*info->fprintf_func) ( stream, ctrl_tab[i].name );
	if ( word1 & 2 ){		/* Predicts branch not taken */
		(*info->fprintf_func) ( stream, ".f" );
	}

	if ( ctrl_tab[i].numops == 1 ){
		/* EXTRACT DISPLACEMENT AND CONVERT TO ADDRESS */
		word1 &= 0x00ffffff;
		if ( word1 & 0x00800000 ){		/* Sign bit is set */
			word1 |= (-1 & ~0xffffff);	/* Sign extend */
		}
		(*info->fprintf_func)( stream, "\t" );
		print_addr( word1 + memaddr );
	}
}

/****************************************/
/* COBR format				*/
/****************************************/
d236 4
a239 4
cobr( memaddr, word1, word2 )
    bfd_vma memaddr;
    unsigned long word1;
    unsigned long word2 ATTRIBUTE_UNUSED;
d241 108
a348 106
	int src1;
	int src2;
	int i;

	static const struct tabent cobr_tab[] = {
	  { "testno",	1, },	/* 0x20 */
	  { "testg",	1, },	/* 0x21 */
	  { "teste",	1, },	/* 0x22 */
	  { "testge",	1, },	/* 0x23 */
	  { "testl",	1, },	/* 0x24 */
	  { "testne",	1, },	/* 0x25 */
	  { "testle",	1, },	/* 0x26 */
	  { "testo",	1, },	/* 0x27 */
	  { NULL,	0, },	/* 0x28 */
	  { NULL,	0, },	/* 0x29 */
	  { NULL,	0, },	/* 0x2a */
	  { NULL,	0, },	/* 0x2b */
	  { NULL,	0, },	/* 0x2c */
	  { NULL,	0, },	/* 0x2d */
	  { NULL,	0, },	/* 0x2e */
	  { NULL,	0, },	/* 0x2f */
	  { "bbc",	3, },	/* 0x30 */
	  { "cmpobg",	3, },	/* 0x31 */
	  { "cmpobe",	3, },	/* 0x32 */
	  { "cmpobge",	3, },	/* 0x33 */
	  { "cmpobl",	3, },	/* 0x34 */
	  { "cmpobne",	3, },	/* 0x35 */
	  { "cmpoble",	3, },	/* 0x36 */
	  { "bbs",	3, },	/* 0x37 */
	  { "cmpibno",	3, },	/* 0x38 */
	  { "cmpibg",	3, },	/* 0x39 */
	  { "cmpibe",	3, },	/* 0x3a */
	  { "cmpibge",	3, },	/* 0x3b */
	  { "cmpibl",	3, },	/* 0x3c */
	  { "cmpibne",	3, },	/* 0x3d */
	  { "cmpible",	3, },	/* 0x3e */
	  { "cmpibo",	3, },	/* 0x3f */
	};

	i = ((word1 >> 24) & 0xff) - 0x20;
	if ( cobr_tab[i].name == NULL ){
		invalid( word1 );
		return;
	}

	(*info->fprintf_func) ( stream, cobr_tab[i].name );
	if ( word1 & 2 ){		/* Predicts branch not taken */
		(*info->fprintf_func) ( stream, ".f" );
	}
	(*info->fprintf_func)( stream, "\t" );

	src1 = (word1 >> 19) & 0x1f;
	src2 = (word1 >> 14) & 0x1f;

	if ( word1 & 0x02000 ){		/* M1 is 1 */
		(*info->fprintf_func)( stream, "%d", src1 );
	} else {			/* M1 is 0 */
		(*info->fprintf_func)( stream, reg_names[src1] );
	}

	if ( cobr_tab[i].numops > 1 ){
		if ( word1 & 1 ){		/* S2 is 1 */
			(*info->fprintf_func)( stream, ",sf%d,", src2 );
		} else {			/* S1 is 0 */
			(*info->fprintf_func)( stream, ",%s,", reg_names[src2] );
		}

		/* Extract displacement and convert to address
		 */
		word1 &= 0x00001ffc;
		if ( word1 & 0x00001000 ){	/* Negative displacement */
			word1 |= (-1 & ~0x1fff);	/* Sign extend */
		}
		print_addr( memaddr + word1 );
	}
}

/****************************************/
/* MEM format				*/
/****************************************/
static int				/* returns instruction length: 4 or 8 */
mem( memaddr, word1, word2, noprint )
    bfd_vma memaddr;
    unsigned long word1, word2;
    int noprint;		/* If TRUE, return instruction length, but
				 * don't output any text.
				 */
{
	int i, j;
	int len;
	int mode;
	int offset;
	const char *reg1, *reg2, *reg3;

	/* This lookup table is too sparse to make it worth typing in, but not
	   so large as to make a sparse array necessary.  We create the table
	   at runtime.  */

	/*
	 * NOTE: In this table, the meaning of 'numops' is:
	 *	 1: single operand
	 *	 2: 2 operands, load instruction
	 *	-2: 2 operands, store instruction
	 */
	static struct tabent *mem_tab;
/* Opcodes of 0x8X, 9X, aX, bX, and cX must be in the table.  */
d353 121
a473 106
	static const struct sparse_tabent mem_init[] = {
	  { 0x80,	"ldob",	 2 },
	  { 0x82,	"stob",	-2 },
	  { 0x84,	"bx",	 1 },
	  { 0x85,	"balx",	 2 },
	  { 0x86,	"callx", 1 },
	  { 0x88,	"ldos",	 2 },
	  { 0x8a,	"stos",	-2 },
	  { 0x8c,	"lda",	 2 },
	  { 0x90,	"ld",	 2 },
	  { 0x92,	"st",	-2 },
	  { 0x98,	"ldl",	 2 },
	  { 0x9a,	"stl",	-2 },
	  { 0xa0,	"ldt",	 2 },
	  { 0xa2,	"stt",	-2 },
	  { 0xac,	"dcinva", 1 },
	  { 0xb0,	"ldq",	 2 },
	  { 0xb2,	"stq",	-2 },
	  { 0xc0,	"ldib",	 2 },
	  { 0xc2,	"stib",	-2 },
	  { 0xc8,	"ldis",	 2 },
	  { 0xca,	"stis",	-2 },
	  { 0,		NULL,	0 }
	};
	static struct tabent mem_tab_buf[MEM_MAX - MEM_MIN + 1];

	if ( mem_tab == NULL ){
		mem_tab = mem_tab_buf;
		for ( i = 0; mem_init[i].opcode != 0; i++ ){
			j = mem_init[i].opcode - MEM_MIN;
			mem_tab[j].name = mem_init[i].name;
			mem_tab[j].numops = mem_init[i].numops;
		}
	}

	i = ((word1 >> 24) & 0xff) - MEM_MIN;
	mode = (word1 >> 10) & 0xf;

	if ( (mem_tab[i].name != NULL)		/* Valid instruction */
	&&   ((mode == 5) || (mode >=12)) ){	/* With 32-bit displacement */
		len = 8;
	} else {
		len = 4;
	}

	if ( noprint ){
		return len;
	}

	if ( (mem_tab[i].name == NULL) || (mode == 6) ){
		invalid( word1 );
		return len;
	}

	(*info->fprintf_func)( stream, "%s\t", mem_tab[i].name );

	reg1 = reg_names[ (word1 >> 19) & 0x1f ];	/* MEMB only */
	reg2 = reg_names[ (word1 >> 14) & 0x1f ];
	reg3 = reg_names[ word1 & 0x1f ];		/* MEMB only */
	offset = word1 & 0xfff;				/* MEMA only  */

	switch ( mem_tab[i].numops ){

	case 2: /* LOAD INSTRUCTION */
		if ( mode & 4 ){			/* MEMB FORMAT */
			ea( memaddr, mode, reg2, reg3, word1, word2 );
			(*info->fprintf_func)( stream, ",%s", reg1 );
		} else {				/* MEMA FORMAT */
			(*info->fprintf_func)( stream, "0x%x", (unsigned) offset );
			if (mode & 8) {
				(*info->fprintf_func)( stream, "(%s)", reg2 );
			}
			(*info->fprintf_func)( stream, ",%s", reg1 );
		}
		break;

	case -2: /* STORE INSTRUCTION */
		if ( mode & 4 ){			/* MEMB FORMAT */
			(*info->fprintf_func)( stream, "%s,", reg1 );
			ea( memaddr, mode, reg2, reg3, word1, word2 );
		} else {				/* MEMA FORMAT */
			(*info->fprintf_func)( stream, "%s,0x%x", reg1, (unsigned) offset );
			if (mode & 8) {
				(*info->fprintf_func)( stream, "(%s)", reg2 );
			}
		}
		break;

	case 1: /* BX/CALLX INSTRUCTION */
		if ( mode & 4 ){			/* MEMB FORMAT */
			ea( memaddr, mode, reg2, reg3, word1, word2 );
		} else {				/* MEMA FORMAT */
			(*info->fprintf_func)( stream, "0x%x", (unsigned) offset );
			if (mode & 8) {
				(*info->fprintf_func)( stream, "(%s)", reg2 );
			}
		}
		break;
	}

	return len;
}

/****************************************/
/* REG format				*/
/****************************************/
d475 2
a476 2
reg( word1 )
    unsigned long word1;
d478 25
a502 26
	int i, j;
	int opcode;
	int fp;
	int m1, m2, m3;
	int s1, s2;
	int src, src2, dst;
	char *mnemp;

	/* This lookup table is too sparse to make it worth typing in, but not
	   so large as to make a sparse array necessary.  We create the table
	   at runtime.  */

	/*
	 * NOTE: In this table, the meaning of 'numops' is:
	 *	 1: single operand, which is NOT a destination.
	 *	-1: single operand, which IS a destination.
	 *	 2: 2 operands, the 2nd of which is NOT a destination.
	 *	-2: 2 operands, the 2nd of which IS a destination.
	 *	 3: 3 operands
	 *
	 *	If an opcode mnemonic begins with "F", it is a floating-point
	 *	opcode (the "F" is not printed).
	 */

	static struct tabent *reg_tab;
	static const struct sparse_tabent reg_init[] = {
d504 192
a695 192
	  { 0x580,	"notbit",	3 },
	  { 0x581,	"and",		3 },
	  { 0x582,	"andnot",	3 },
	  { 0x583,	"setbit",	3 },
	  { 0x584,	"notand",	3 },
	  { 0x586,	"xor",		3 },
	  { 0x587,	"or",		3 },
	  { 0x588,	"nor",		3 },
	  { 0x589,	"xnor",		3 },
	  { 0x58a,	"not",		-2 },
	  { 0x58b,	"ornot",	3 },
	  { 0x58c,	"clrbit",	3 },
	  { 0x58d,	"notor",	3 },
	  { 0x58e,	"nand",		3 },
	  { 0x58f,	"alterbit",	3 },
	  { 0x590,	"addo",		3 },
	  { 0x591,	"addi",		3 },
	  { 0x592,	"subo",		3 },
	  { 0x593,	"subi",		3 },
	  { 0x594,	"cmpob",	2 },
	  { 0x595,	"cmpib",	2 },
	  { 0x596,	"cmpos",	2 },
	  { 0x597,	"cmpis",	2 },
	  { 0x598,	"shro",		3 },
	  { 0x59a,	"shrdi",	3 },
	  { 0x59b,	"shri",		3 },
	  { 0x59c,	"shlo",		3 },
	  { 0x59d,	"rotate",	3 },
	  { 0x59e,	"shli",		3 },
	  { 0x5a0,	"cmpo",		2 },
	  { 0x5a1,	"cmpi",		2 },
	  { 0x5a2,	"concmpo",	2 },
	  { 0x5a3,	"concmpi",	2 },
	  { 0x5a4,	"cmpinco",	3 },
	  { 0x5a5,	"cmpinci",	3 },
	  { 0x5a6,	"cmpdeco",	3 },
	  { 0x5a7,	"cmpdeci",	3 },
	  { 0x5ac,	"scanbyte",	2 },
	  { 0x5ad,	"bswap",	-2 },
	  { 0x5ae,	"chkbit",	2 },
	  { 0x5b0,	"addc",		3 },
	  { 0x5b2,	"subc",		3 },
	  { 0x5b4,	"intdis",	0 },
	  { 0x5b5,	"inten",	0 },
	  { 0x5cc,	"mov",		-2 },
	  { 0x5d8,	"eshro",	3 },
	  { 0x5dc,	"movl",		-2 },
	  { 0x5ec,	"movt",		-2 },
	  { 0x5fc,	"movq",		-2 },
	  { 0x600,	"synmov",	2 },
	  { 0x601,	"synmovl",	2 },
	  { 0x602,	"synmovq",	2 },
	  { 0x603,	"cmpstr",	3 },
	  { 0x604,	"movqstr",	3 },
	  { 0x605,	"movstr",	3 },
	  { 0x610,	"atmod",	3 },
	  { 0x612,	"atadd",	3 },
	  { 0x613,	"inspacc",	-2 },
	  { 0x614,	"ldphy",	-2 },
	  { 0x615,	"synld",	-2 },
	  { 0x617,	"fill",		3 },
	  { 0x630,	"sdma",		3 },
	  { 0x631,	"udma",		0 },
	  { 0x640,	"spanbit",	-2 },
	  { 0x641,	"scanbit",	-2 },
	  { 0x642,	"daddc",	3 },
	  { 0x643,	"dsubc",	3 },
	  { 0x644,	"dmovt",	-2 },
	  { 0x645,	"modac",	3 },
	  { 0x646,	"condrec",	-2 },
	  { 0x650,	"modify",	3 },
	  { 0x651,	"extract",	3 },
	  { 0x654,	"modtc",	3 },
	  { 0x655,	"modpc",	3 },
	  { 0x656,	"receive",	-2 },
	  { 0x658,	"intctl",	-2 },
	  { 0x659,	"sysctl",	3 },
	  { 0x65b,	"icctl",	3 },
	  { 0x65c,	"dcctl",	3 },
	  { 0x65d,	"halt",		0 },
	  { 0x660,	"calls",	1 },
	  { 0x662,	"send",		3 },
	  { 0x663,	"sendserv",	1 },
	  { 0x664,	"resumprcs",	1 },
	  { 0x665,	"schedprcs",	1 },
	  { 0x666,	"saveprcs",	0 },
	  { 0x668,	"condwait",	1 },
	  { 0x669,	"wait",		1 },
	  { 0x66a,	"signal",	1 },
	  { 0x66b,	"mark",		0 },
	  { 0x66c,	"fmark",	0 },
	  { 0x66d,	"flushreg",	0 },
	  { 0x66f,	"syncf",	0 },
	  { 0x670,	"emul",		3 },
	  { 0x671,	"ediv",		3 },
	  { 0x673,	"ldtime",	-1 },
	  { 0x674,	"Fcvtir",	-2 },
	  { 0x675,	"Fcvtilr",	-2 },
	  { 0x676,	"Fscalerl",	3 },
	  { 0x677,	"Fscaler",	3 },
	  { 0x680,	"Fatanr",	3 },
	  { 0x681,	"Flogepr",	3 },
	  { 0x682,	"Flogr",	3 },
	  { 0x683,	"Fremr",	3 },
	  { 0x684,	"Fcmpor",	2 },
	  { 0x685,	"Fcmpr",	2 },
	  { 0x688,	"Fsqrtr",	-2 },
	  { 0x689,	"Fexpr",	-2 },
	  { 0x68a,	"Flogbnr",	-2 },
	  { 0x68b,	"Froundr",	-2 },
	  { 0x68c,	"Fsinr",	-2 },
	  { 0x68d,	"Fcosr",	-2 },
	  { 0x68e,	"Ftanr",	-2 },
	  { 0x68f,	"Fclassr",	1 },
	  { 0x690,	"Fatanrl",	3 },
	  { 0x691,	"Flogeprl",	3 },
	  { 0x692,	"Flogrl",	3 },
	  { 0x693,	"Fremrl",	3 },
	  { 0x694,	"Fcmporl",	2 },
	  { 0x695,	"Fcmprl",	2 },
	  { 0x698,	"Fsqrtrl",	-2 },
	  { 0x699,	"Fexprl",	-2 },
	  { 0x69a,	"Flogbnrl",	-2 },
	  { 0x69b,	"Froundrl",	-2 },
	  { 0x69c,	"Fsinrl",	-2 },
	  { 0x69d,	"Fcosrl",	-2 },
	  { 0x69e,	"Ftanrl",	-2 },
	  { 0x69f,	"Fclassrl",	1 },
	  { 0x6c0,	"Fcvtri",	-2 },
	  { 0x6c1,	"Fcvtril",	-2 },
	  { 0x6c2,	"Fcvtzri",	-2 },
	  { 0x6c3,	"Fcvtzril",	-2 },
	  { 0x6c9,	"Fmovr",	-2 },
	  { 0x6d9,	"Fmovrl",	-2 },
	  { 0x6e1,	"Fmovre",	-2 },
	  { 0x6e2,	"Fcpysre",	3 },
	  { 0x6e3,	"Fcpyrsre",	3 },
	  { 0x701,	"mulo",		3 },
	  { 0x708,	"remo",		3 },
	  { 0x70b,	"divo",		3 },
	  { 0x741,	"muli",		3 },
	  { 0x748,	"remi",		3 },
	  { 0x749,	"modi",		3 },
	  { 0x74b,	"divi",		3 },
	  { 0x780,	"addono",	3 },
	  { 0x781,	"addino",	3 },
	  { 0x782,	"subono",	3 },
	  { 0x783,	"subino",	3 },
	  { 0x784,	"selno",	3 },
	  { 0x78b,	"Fdivr",	3 },
	  { 0x78c,	"Fmulr",	3 },
	  { 0x78d,	"Fsubr",	3 },
	  { 0x78f,	"Faddr",	3 },
	  { 0x790,	"addog",	3 },
	  { 0x791,	"addig",        3 },
	  { 0x792,	"subog",	3 },
	  { 0x793,	"subig",	3 },
	  { 0x794,	"selg",		3 },
	  { 0x79b,	"Fdivrl",	3 },
	  { 0x79c,	"Fmulrl",	3 },
	  { 0x79d,	"Fsubrl",	3 },
	  { 0x79f,	"Faddrl",	3 },
	  { 0x7a0,	"addoe",	3 },
	  { 0x7a1,	"addie",        3 },
	  { 0x7a2,	"suboe",	3 },
	  { 0x7a3,	"subie",	3 },
	  { 0x7a4,	"sele",		3 },
	  { 0x7b0,	"addoge",	3 },
	  { 0x7b1,	"addige",	3 },
	  { 0x7b2,	"suboge",	3 },
	  { 0x7b3,	"subige",	3 },
	  { 0x7b4,	"selge",	3 },
	  { 0x7c0,	"addol",	3 },
	  { 0x7c1,	"addil",	3 },
	  { 0x7c2,	"subol",	3 },
	  { 0x7c3,	"subil",	3 },
	  { 0x7c4,	"sell",		3 },
	  { 0x7d0,	"addone",	3 },
	  { 0x7d1,	"addine",	3 },
	  { 0x7d2,	"subone",	3 },
	  { 0x7d3,	"subine",	3 },
	  { 0x7d4,	"selne",	3 },
	  { 0x7e0,	"addole",	3 },
	  { 0x7e1,	"addile",	3 },
	  { 0x7e2,	"subole",	3 },
	  { 0x7e3,	"subile",	3 },
	  { 0x7e4,	"selle",	3 },
	  { 0x7f0,	"addoo",	3 },
	  { 0x7f1,	"addio",	3 },
	  { 0x7f2,	"suboo",	3 },
	  { 0x7f3,	"subio",	3 },
	  { 0x7f4,	"selo",		3 },
d697 82
a778 75
	  { 0,		NULL,		0 }
	};
	static struct tabent reg_tab_buf[REG_MAX - REG_MIN + 1];

	if ( reg_tab == NULL ){
		reg_tab = reg_tab_buf;
		for ( i = 0; reg_init[i].opcode != 0; i++ ){
			j = reg_init[i].opcode - REG_MIN;
			reg_tab[j].name = reg_init[i].name;
			reg_tab[j].numops = reg_init[i].numops;
		}
	}

	opcode = ((word1 >> 20) & 0xff0) | ((word1 >> 7) & 0xf);
	i = opcode - REG_MIN;

	if ( (opcode<REG_MIN) || (opcode>REG_MAX) || (reg_tab[i].name==NULL) ){
		invalid( word1 );
		return;
	}

	mnemp = reg_tab[i].name;
	if ( *mnemp == 'F' ){
		fp = 1;
		mnemp++;
	} else {
		fp = 0;
	}

	(*info->fprintf_func)( stream, mnemp );

	s1   = (word1 >> 5)  & 1;
	s2   = (word1 >> 6)  & 1;
	m1   = (word1 >> 11) & 1;
	m2   = (word1 >> 12) & 1;
	m3   = (word1 >> 13) & 1;
	src  =  word1        & 0x1f;
	src2 = (word1 >> 14) & 0x1f;
	dst  = (word1 >> 19) & 0x1f;

	if  ( reg_tab[i].numops != 0 ){
		(*info->fprintf_func)( stream, "\t" );

		switch ( reg_tab[i].numops ){
		case 1:
			regop( m1, s1, src, fp );
			break;
		case -1:
			dstop( m3, dst, fp );
			break;
		case 2:
			regop( m1, s1, src, fp );
			(*info->fprintf_func)( stream, "," );
			regop( m2, s2, src2, fp );
			break;
		case -2:
			regop( m1, s1, src, fp );
			(*info->fprintf_func)( stream, "," );
			dstop( m3, dst, fp );
			break;
		case 3:
			regop( m1, s1, src, fp );
			(*info->fprintf_func)( stream, "," );
			regop( m2, s2, src2, fp );
			(*info->fprintf_func)( stream, "," );
			dstop( m3, dst, fp );
			break;
		}
	}
}


/*
 * Print out effective address for memb instructions.
 */
d780 1
a780 1
ea( memaddr, mode, reg2, reg3, word1, word2 )
d783 2
a784 1
     char *reg2, *reg3;
d788 2
a789 2
	int scale;
	static const int scale_tab[] = { 1, 2, 4, 8, 16 };
d791 48
a838 48
	scale = (word1 >> 7) & 0x07;
	if ( (scale > 4) || (((word1 >> 5) & 0x03) != 0) ){
		invalid( word1 );
		return;
	}
	scale = scale_tab[scale];

	switch (mode) {
	case 4:						/* (reg) */
		(*info->fprintf_func)( stream, "(%s)", reg2 );
		break;
	case 5:						/* displ+8(ip) */
		print_addr( word2+8+memaddr );
		break;
	case 7:						/* (reg)[index*scale] */
		if (scale == 1) {
			(*info->fprintf_func)( stream, "(%s)[%s]", reg2, reg3 );
		} else {
			(*info->fprintf_func)( stream, "(%s)[%s*%d]",reg2,reg3,scale);
		}
		break;
	case 12:					/* displacement */
		print_addr( (bfd_vma)word2 );
		break;
	case 13:					/* displ(reg) */
		print_addr( (bfd_vma)word2 );
		(*info->fprintf_func)( stream, "(%s)", reg2 );
		break;
	case 14:					/* displ[index*scale] */
		print_addr( (bfd_vma)word2 );
		if (scale == 1) {
			(*info->fprintf_func)( stream, "[%s]", reg3 );
		} else {
			(*info->fprintf_func)( stream, "[%s*%d]", reg3, scale );
		}
		break;
	case 15:				/* displ(reg)[index*scale] */
		print_addr( (bfd_vma)word2 );
		if (scale == 1) {
			(*info->fprintf_func)( stream, "(%s)[%s]", reg2, reg3 );
		} else {
			(*info->fprintf_func)( stream, "(%s)[%s*%d]",reg2,reg3,scale );
		}
		break;
	default:
		invalid( word1 );
		return;
	}
d842 2
a843 3
/************************************************/
/* Register Instruction Operand		*/
/************************************************/
d845 2
a846 2
regop( mode, spec, reg, fp )
    int mode, spec, reg, fp;
d848 28
a875 31
	if ( fp ){				/* FLOATING POINT INSTRUCTION */
		if ( mode == 1 ){			/* FP operand */
			switch ( reg ){
			case 0:  (*info->fprintf_func)( stream, "fp0" );
			  break;
			case 1:  (*info->fprintf_func)( stream, "fp1" );
			  break;
			case 2:  (*info->fprintf_func)( stream, "fp2" );
			  break;
			case 3:  (*info->fprintf_func)( stream, "fp3" );
			  break;
			case 16: (*info->fprintf_func)( stream, "0f0.0" );
			  break;
			case 22: (*info->fprintf_func)( stream, "0f1.0" );
			  break;
			default: (*info->fprintf_func)( stream, "?" );
			  break;
			}
		} else {				/* Non-FP register */
			(*info->fprintf_func)( stream, reg_names[reg] );
		}
	} else {				/* NOT FLOATING POINT */
		if ( mode == 1 ){			/* Literal */
			(*info->fprintf_func)( stream, "%d", reg );
		} else {				/* Register */
			if ( spec == 0 ){
				(*info->fprintf_func)( stream, reg_names[reg] );
			} else {
				(*info->fprintf_func)( stream, "sf%d", reg );
			}
		}
d877 18
d897 2
a898 3
/************************************************/
/* Register Instruction Destination Operand	*/
/************************************************/
d900 2
a901 2
dstop( mode, reg, fp )
    int mode, reg, fp;
d903 7
a909 9
	/* 'dst' operand can't be a literal. On non-FP instructions,  register
	 * mode is assumed and "m3" acts as if were "s3";  on FP-instructions,
	 * sf registers are not allowed so m3 acts normally.
	 */
	 if ( fp ){
		regop( mode, 0, reg, fp );
	 } else {
		regop( 0, mode, reg, fp );
	 }
a911 1

d913 2
a914 2
invalid( word1 )
    int word1;
d916 1
a916 1
	(*info->fprintf_func)( stream, ".word\t0x%08x", (unsigned) word1 );
d920 2
a921 2
print_addr(a)
bfd_vma a;
d927 3
a929 3
put_abs( word1, word2 )
    unsigned long word1 ATTRIBUTE_UNUSED;
    unsigned long word2 ATTRIBUTE_UNUSED;
d932 1
a932 1
	return;
d934 1
a934 1
	int len;
d936 14
a949 20
	switch ( (word1 >> 28) & 0xf ){
	case 0x8:
	case 0x9:
	case 0xa:
	case 0xb:
	case 0xc:
		/* MEM format instruction */
		len = mem( 0, word1, word2, 1 );
		break;
	default:
		len = 4;
		break;
	}

	if ( len == 8 ){
		(*info->fprintf_func)( stream, "%08x %08x\t", word1, word2 );
	} else {
		(*info->fprintf_func)( stream, "%08x         \t", word1 );
	}
;
d951 4
@


1.3
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000
d24 1
a24 1
/*  0 */	"pfp", "sp",  "rip", "r3",  "r4",  "r5",  "r6",  "r7", 
d26 3
a28 3
/* 16 */	"g0",  "g1",  "g2",  "g3",  "g4",  "g5",  "g6",  "g7", 
/* 24 */	"g8",  "g9",  "g10", "g11", "g12", "g13", "g14", "fp", 
/* 32 */	"pc",  "ac",  "ip",  "tc",  "fp0", "fp1", "fp2", "fp3" 
d34 11
a44 11
static void print_addr();
static void ctrl();
static void cobr();
static void reg();
static int mem();
static void ea();
static void dstop();
static void regop();
static void invalid();
static int pinsn();
static void put_abs();
d153 1
a153 1
		/* invalid instruction, print as data word */ 
d166 2
a167 1
    unsigned long word1, word2;
d233 2
a234 1
    unsigned long word1, word2;
d498 4
a501 4
	  { 0x590, 	"addo",		3 },
	  { 0x591, 	"addi",		3 },
	  { 0x592, 	"subo",		3 },
	  { 0x593, 	"subi",		3 },
d506 15
a520 15
	  { 0x598, 	"shro",		3 },
	  { 0x59a, 	"shrdi",	3 },
	  { 0x59b, 	"shri",		3 },
	  { 0x59c, 	"shlo",		3 },
	  { 0x59d, 	"rotate",	3 },
	  { 0x59e, 	"shli",		3 },
	  { 0x5a0, 	"cmpo",		2 },
	  { 0x5a1, 	"cmpi",		2 },
	  { 0x5a2, 	"concmpo",	2 },
	  { 0x5a3, 	"concmpi",	2 },
	  { 0x5a4, 	"cmpinco",	3 },
	  { 0x5a5, 	"cmpinci",	3 },
	  { 0x5a6, 	"cmpdeco",	3 },
	  { 0x5a7, 	"cmpdeci",	3 },
	  { 0x5ac, 	"scanbyte",	2 },
d522 3
a524 3
	  { 0x5ae, 	"chkbit",	2 },
	  { 0x5b0, 	"addc",		3 },
	  { 0x5b2, 	"subc",		3 },
d578 1
a578 1
	  { 0x673, 	"ldtime",	-1 },
d617 3
a619 3
	  { 0x6e1, 	"Fmovre",	-2 },
	  { 0x6e2, 	"Fcpysre",	3 },
	  { 0x6e3, 	"Fcpyrsre",	3 },
d770 1
a770 1
	case 4:	 					/* (reg) */
d814 1
a814 1
/* Register Instruction Operand  		*/
d878 1
a878 1
}	
d889 2
a890 1
    unsigned long word1, word2;
@


1.2
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 93, 94, 95, 96, 1998 Free Software Foundation, Inc.
@


1.2.4.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000
   Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d19 1
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@a18 1
#include "sysdep.h"
@


