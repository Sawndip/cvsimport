head	1.19;
access;
symbols
	sid-snapshot-20180601:1.19
	sid-snapshot-20180501:1.19
	sid-snapshot-20180401:1.19
	sid-snapshot-20180301:1.19
	sid-snapshot-20180201:1.19
	sid-snapshot-20180101:1.19
	sid-snapshot-20171201:1.19
	sid-snapshot-20171101:1.19
	sid-snapshot-20171001:1.19
	sid-snapshot-20170901:1.19
	sid-snapshot-20170801:1.19
	sid-snapshot-20170701:1.19
	sid-snapshot-20170601:1.19
	sid-snapshot-20170501:1.19
	sid-snapshot-20170401:1.19
	sid-snapshot-20170301:1.19
	sid-snapshot-20170201:1.19
	sid-snapshot-20170101:1.19
	sid-snapshot-20161201:1.19
	sid-snapshot-20161101:1.19
	sid-snapshot-20160901:1.19
	sid-snapshot-20160801:1.19
	sid-snapshot-20160701:1.19
	sid-snapshot-20160601:1.19
	sid-snapshot-20160501:1.19
	sid-snapshot-20160401:1.19
	sid-snapshot-20160301:1.19
	sid-snapshot-20160201:1.19
	sid-snapshot-20160101:1.19
	sid-snapshot-20151201:1.19
	sid-snapshot-20151101:1.19
	sid-snapshot-20151001:1.19
	sid-snapshot-20150901:1.19
	sid-snapshot-20150801:1.19
	sid-snapshot-20150701:1.19
	sid-snapshot-20150601:1.19
	sid-snapshot-20150501:1.19
	sid-snapshot-20150401:1.19
	sid-snapshot-20150301:1.19
	sid-snapshot-20150201:1.19
	sid-snapshot-20150101:1.19
	sid-snapshot-20141201:1.19
	sid-snapshot-20141101:1.19
	sid-snapshot-20141001:1.19
	sid-snapshot-20140901:1.19
	sid-snapshot-20140801:1.19
	sid-snapshot-20140701:1.19
	sid-snapshot-20140601:1.19
	sid-snapshot-20140501:1.19
	sid-snapshot-20140401:1.19
	sid-snapshot-20140301:1.19
	sid-snapshot-20140201:1.19
	sid-snapshot-20140101:1.19
	sid-snapshot-20131201:1.19
	sid-snapshot-20131101:1.19
	sid-snapshot-20131001:1.19
	binutils-2_24-branch:1.19.0.26
	binutils-2_24-branchpoint:1.19
	binutils-2_21_1:1.19
	sid-snapshot-20130901:1.19
	gdb_7_6_1-2013-08-30-release:1.19
	sid-snapshot-20130801:1.19
	sid-snapshot-20130701:1.19
	sid-snapshot-20130601:1.19
	sid-snapshot-20130501:1.19
	gdb_7_6-2013-04-26-release:1.19
	sid-snapshot-20130401:1.19
	binutils-2_23_2:1.19
	gdb_7_6-branch:1.19.0.24
	gdb_7_6-2013-03-12-branchpoint:1.19
	sid-snapshot-20130301:1.19
	sid-snapshot-20130201:1.19
	sid-snapshot-20130101:1.19
	sid-snapshot-20121201:1.19
	gdb_7_5_1-2012-11-29-release:1.19
	binutils-2_23_1:1.19
	sid-snapshot-20121101:1.19
	binutils-2_23:1.19
	sid-snapshot-20121001:1.19
	sid-snapshot-20120901:1.19
	gdb_7_5-2012-08-17-release:1.19
	sid-snapshot-20120801:1.19
	binutils-2_23-branch:1.19.0.22
	binutils-2_23-branchpoint:1.19
	gdb_7_5-branch:1.19.0.20
	gdb_7_5-2012-07-18-branchpoint:1.19
	sid-snapshot-20120701:1.19
	sid-snapshot-20120601:1.19
	sid-snapshot-20120501:1.19
	binutils-2_22_branch:1.19.0.18
	gdb_7_4_1-2012-04-26-release:1.19
	sid-snapshot-20120401:1.19
	sid-snapshot-20120301:1.19
	sid-snapshot-20120201:1.19
	gdb_7_4-2012-01-24-release:1.19
	sid-snapshot-20120101:1.19
	gdb_7_4-branch:1.19.0.16
	gdb_7_4-2011-12-13-branchpoint:1.19
	sid-snapshot-20111201:1.19
	binutils-2_22:1.19
	sid-snapshot-20111101:1.19
	sid-snapshot-20111001:1.19
	binutils-2_22-branch:1.19.0.14
	binutils-2_22-branchpoint:1.19
	gdb_7_3_1-2011-09-04-release:1.19
	sid-snapshot-20110901:1.19
	sid-snapshot-20110801:1.19
	gdb_7_3-2011-07-26-release:1.19
	sid-snapshot-20110701:1.19
	sid-snapshot-20110601:1.19
	sid-snapshot-20110501:1.19
	gdb_7_3-branch:1.19.0.12
	gdb_7_3-2011-04-01-branchpoint:1.19
	sid-snapshot-20110401:1.19
	sid-snapshot-20110301:1.19
	sid-snapshot-20110201:1.19
	sid-snapshot-20110101:1.19
	binutils-2_21:1.19
	sid-snapshot-20101201:1.19
	binutils-2_21-branch:1.19.0.10
	binutils-2_21-branchpoint:1.19
	sid-snapshot-20101101:1.19
	sid-snapshot-20101001:1.19
	binutils-2_20_1:1.19
	gdb_7_2-2010-09-02-release:1.19
	sid-snapshot-20100901:1.19
	sid-snapshot-20100801:1.19
	gdb_7_2-branch:1.19.0.8
	gdb_7_2-2010-07-07-branchpoint:1.19
	sid-snapshot-20100701:1.19
	sid-snapshot-20100601:1.19
	sid-snapshot-20100501:1.19
	sid-snapshot-20100401:1.19
	gdb_7_1-2010-03-18-release:1.19
	sid-snapshot-20100301:1.19
	gdb_7_1-branch:1.19.0.6
	gdb_7_1-2010-02-18-branchpoint:1.19
	sid-snapshot-20100201:1.19
	sid-snapshot-20100101:1.19
	gdb_7_0_1-2009-12-22-release:1.19
	sid-snapshot-20091201:1.19
	sid-snapshot-20091101:1.19
	binutils-2_20:1.19
	gdb_7_0-2009-10-06-release:1.19
	sid-snapshot-20091001:1.19
	gdb_7_0-branch:1.19.0.4
	gdb_7_0-2009-09-16-branchpoint:1.19
	arc-sim-20090309:1.18
	binutils-arc-20081103-branch:1.18.0.30
	binutils-arc-20081103-branchpoint:1.18
	binutils-2_20-branch:1.19.0.2
	binutils-2_20-branchpoint:1.19
	sid-snapshot-20090901:1.18
	sid-snapshot-20090801:1.18
	msnyder-checkpoint-072509-branch:1.18.0.28
	msnyder-checkpoint-072509-branchpoint:1.18
	sid-snapshot-20090701:1.18
	dje-cgen-play1-branch:1.18.0.26
	dje-cgen-play1-branchpoint:1.18
	sid-snapshot-20090601:1.18
	sid-snapshot-20090501:1.18
	sid-snapshot-20090401:1.18
	arc-20081103-branch:1.18.0.24
	arc-20081103-branchpoint:1.18
	arc-insight_6_8-branch:1.18.0.22
	arc-insight_6_8-branchpoint:1.18
	insight_6_8-branch:1.18.0.20
	insight_6_8-branchpoint:1.18
	sid-snapshot-20090301:1.18
	binutils-2_19_1:1.18
	sid-snapshot-20090201:1.18
	sid-snapshot-20090101:1.18
	reverse-20081226-branch:1.18.0.18
	reverse-20081226-branchpoint:1.18
	sid-snapshot-20081201:1.18
	multiprocess-20081120-branch:1.18.0.16
	multiprocess-20081120-branchpoint:1.18
	sid-snapshot-20081101:1.18
	binutils-2_19:1.18
	sid-snapshot-20081001:1.18
	reverse-20080930-branch:1.18.0.14
	reverse-20080930-branchpoint:1.18
	binutils-2_19-branch:1.18.0.12
	binutils-2_19-branchpoint:1.18
	sid-snapshot-20080901:1.18
	sid-snapshot-20080801:1.18
	reverse-20080717-branch:1.18.0.10
	reverse-20080717-branchpoint:1.18
	sid-snapshot-20080701:1.18
	msnyder-reverse-20080609-branch:1.18.0.8
	msnyder-reverse-20080609-branchpoint:1.18
	drow-reverse-20070409-branch:1.17.0.34
	drow-reverse-20070409-branchpoint:1.17
	sid-snapshot-20080601:1.18
	sid-snapshot-20080501:1.18
	sid-snapshot-20080403:1.18
	sid-snapshot-20080401:1.18
	gdb_6_8-2008-03-27-release:1.18
	sid-snapshot-20080301:1.18
	gdb_6_8-branch:1.18.0.6
	gdb_6_8-2008-02-26-branchpoint:1.18
	sid-snapshot-20080201:1.18
	sid-snapshot-20080101:1.18
	sid-snapshot-20071201:1.18
	sid-snapshot-20071101:1.18
	gdb_6_7_1-2007-10-29-release:1.18
	gdb_6_7-2007-10-10-release:1.18
	sid-snapshot-20071001:1.18
	gdb_6_7-branch:1.18.0.4
	gdb_6_7-2007-09-07-branchpoint:1.18
	binutils-2_18:1.18
	binutils-2_18-branch:1.18.0.2
	binutils-2_18-branchpoint:1.18
	insight_6_6-20070208-release:1.17
	binutils-csl-coldfire-4_1-32:1.17
	binutils-csl-sourcerygxx-4_1-32:1.17
	gdb_6_6-2006-12-18-release:1.17
	binutils-csl-innovasic-fido-3_4_4-33:1.17
	binutils-csl-sourcerygxx-3_4_4-32:1.16
	binutils-csl-coldfire-4_1-30:1.17
	binutils-csl-sourcerygxx-4_1-30:1.17
	binutils-csl-coldfire-4_1-28:1.17
	binutils-csl-sourcerygxx-4_1-29:1.17
	binutils-csl-sourcerygxx-4_1-28:1.17
	gdb_6_6-branch:1.17.0.32
	gdb_6_6-2006-11-15-branchpoint:1.17
	binutils-csl-arm-2006q3-27:1.17
	binutils-csl-sourcerygxx-4_1-27:1.17
	binutils-csl-arm-2006q3-26:1.17
	binutils-csl-sourcerygxx-4_1-26:1.17
	binutils-csl-sourcerygxx-4_1-25:1.17
	binutils-csl-sourcerygxx-4_1-24:1.17
	binutils-csl-sourcerygxx-4_1-23:1.17
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	binutils-csl-sourcerygxx-4_1-21:1.17
	binutils-csl-arm-2006q3-21:1.17
	binutils-csl-sourcerygxx-4_1-22:1.17
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.17
	binutils-csl-sourcerygxx-4_1-20:1.17
	binutils-csl-arm-2006q3-19:1.17
	binutils-csl-sourcerygxx-4_1-19:1.17
	binutils-csl-sourcerygxx-4_1-18:1.17
	binutils-csl-renesas-4_1-9:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.17
	binutils-csl-sourcerygxx-3_4_4-25:1.16
	nickrob-async-20060828-mergepoint:1.17
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	binutils-csl-renesas-4_1-8:1.17
	binutils-csl-renesas-4_1-7:1.17
	binutils-csl-renesas-4_1-6:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17
	binutils-csl-sourcerygxx-4_1-17:1.17
	gdb-csl-20060226-branch-local-2:1.17
	gdb-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-15:1.17
	gdb-csl-sourcerygxx-4_1-13:1.17
	binutils-csl-sourcerygxx-4_1-13:1.17
	binutils-2_17:1.17
	gdb-csl-sourcerygxx-4_1-12:1.17
	binutils-csl-sourcerygxx-4_1-12:1.17
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	binutils-csl-sourcerygxx-3_4_4-21:1.17
	gdb_6_5-20060621-release:1.17
	binutils-csl-wrs-linux-3_4_4-24:1.16
	binutils-csl-wrs-linux-3_4_4-23:1.16
	gdb-csl-sourcerygxx-4_1-9:1.17
	binutils-csl-sourcerygxx-4_1-9:1.17
	gdb-csl-sourcerygxx-4_1-8:1.17
	binutils-csl-sourcerygxx-4_1-8:1.17
	gdb-csl-sourcerygxx-4_1-7:1.17
	binutils-csl-sourcerygxx-4_1-7:1.17
	gdb-csl-arm-2006q1-6:1.17
	binutils-csl-arm-2006q1-6:1.17
	gdb-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-wrs-linux-3_4_4-22:1.16
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	binutils-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	binutils-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.17.0.30
	gdb_6_5-2006-05-14-branchpoint:1.17
	binutils-csl-coldfire-4_1-10:1.17
	gdb-csl-sourcerygxx-4_1-5:1.17
	binutils-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.17.0.28
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.17
	binutils-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.17.0.26
	msnyder-reverse-20060502-branchpoint:1.17
	binutils-csl-wrs-linux-3_4_4-21:1.16
	gdb-csl-morpho-4_1-4:1.17
	binutils-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-wrs-linux-3_4_4-20:1.16
	readline_5_1-import-branch:1.17.0.24
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	binutils-2_17-branch:1.17.0.22
	binutils-2_17-branchpoint:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.20
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.18
	msnyder-reverse-20060331-branchpoint:1.17
	binutils-csl-2_17-branch:1.17.0.16
	binutils-csl-2_17-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.14
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.12
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.17
	msnyder-fork-checkpoint-branch:1.17.0.10
	msnyder-fork-checkpoint-branchpoint:1.17
	gdb-csl-gxxpro-6_3-branch:1.17.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.17
	gdb_6_4-branch:1.17.0.6
	gdb_6_4-2005-11-01-branchpoint:1.17
	gdb-csl-arm-20051020-branch:1.17.0.4
	gdb-csl-arm-20051020-branchpoint:1.17
	binutils-csl-gxxpro-3_4-branch:1.16.0.28
	binutils-csl-gxxpro-3_4-branchpoint:1.16
	binutils-2_16_1:1.16
	msnyder-tracepoint-checkpoint-branch:1.17.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.17
	gdb-csl-arm-20050325-2005-q1b:1.16
	binutils-csl-arm-2005q1b:1.16
	binutils-2_16:1.16
	gdb-csl-arm-20050325-2005-q1a:1.16
	binutils-csl-arm-2005q1a:1.16
	csl-arm-20050325-branch:1.16.0.26
	csl-arm-20050325-branchpoint:1.16
	binutils-csl-arm-2005q1-branch:1.16.0.24
	binutils-csl-arm-2005q1-branchpoint:1.16
	binutils-2_16-branch:1.16.0.22
	binutils-2_16-branchpoint:1.16
	csl-arm-2004-q3d:1.16
	gdb_6_3-20041109-release:1.16
	gdb_6_3-branch:1.16.0.18
	gdb_6_3-20041019-branchpoint:1.16
	csl-arm-2004-q3:1.16
	drow_intercu-merge-20040921:1.16
	drow_intercu-merge-20040915:1.16
	jimb-gdb_6_2-e500-branch:1.16.0.20
	jimb-gdb_6_2-e500-branchpoint:1.16
	gdb_6_2-20040730-release:1.16
	gdb_6_2-branch:1.16.0.16
	gdb_6_2-2004-07-10-gmt-branchpoint:1.16
	gdb_6_1_1-20040616-release:1.16
	binutils-2_15:1.16
	binutils-2_15-branchpoint:1.16
	csl-arm-2004-q1a:1.16
	csl-arm-2004-q1:1.16
	gdb_6_1-2004-04-05-release:1.16
	drow_intercu-merge-20040402:1.16
	drow_intercu-merge-20040327:1.16
	ezannoni_pie-20040323-branch:1.16.0.14
	ezannoni_pie-20040323-branchpoint:1.16
	cagney_tramp-20040321-mergepoint:1.16
	cagney_tramp-20040309-branch:1.16.0.12
	cagney_tramp-20040309-branchpoint:1.16
	gdb_6_1-branch:1.16.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.16
	drow_intercu-20040221-branch:1.16.0.8
	drow_intercu-20040221-branchpoint:1.16
	binutils-2_15-branch:1.16.0.6
	cagney_bfdfile-20040213-branch:1.16.0.4
	cagney_bfdfile-20040213-branchpoint:1.16
	drow-cplus-merge-20040208:1.16
	carlton_dictionary-20040126-merge:1.16
	cagney_bigcore-20040122-branch:1.16.0.2
	cagney_bigcore-20040122-branchpoint:1.16
	drow-cplus-merge-20040113:1.16
	csl-arm-2003-q4:1.16
	drow-cplus-merge-20031224:1.16
	drow-cplus-merge-20031220:1.16
	carlton_dictionary-20031215-merge:1.15
	drow-cplus-merge-20031214:1.15
	carlton-dictionary-20031111-merge:1.14
	gdb_6_0-2003-10-04-release:1.14
	kettenis_sparc-20030918-branch:1.14.0.8
	kettenis_sparc-20030918-branchpoint:1.14
	carlton_dictionary-20030917-merge:1.14
	ezannoni_pie-20030916-branchpoint:1.14
	ezannoni_pie-20030916-branch:1.14.0.6
	cagney_x86i386-20030821-branch:1.14.0.4
	cagney_x86i386-20030821-branchpoint:1.14
	carlton_dictionary-20030805-merge:1.14
	carlton_dictionary-20030627-merge:1.14
	gdb_6_0-branch:1.14.0.2
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.13.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.13
	binutils-2_14:1.12.34.1
	cagney_convert-20030606-branch:1.13.0.10
	cagney_convert-20030606-branchpoint:1.13
	cagney_writestrings-20030508-branch:1.13.0.8
	cagney_writestrings-20030508-branchpoint:1.13
	jimb-ppc64-linux-20030528-branch:1.13.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.13
	carlton_dictionary-20030523-merge:1.13
	cagney_fileio-20030521-branch:1.13.0.4
	cagney_fileio-20030521-branchpoint:1.13
	kettenis_i386newframe-20030517-mergepoint:1.13
	jimb-ppc64-linux-20030509-branch:1.13.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.13
	kettenis_i386newframe-20030504-mergepoint:1.13
	carlton_dictionary-20030430-merge:1.12
	binutils-2_14-branch:1.12.0.34
	binutils-2_14-branchpoint:1.12
	kettenis_i386newframe-20030419-branch:1.12.0.32
	kettenis_i386newframe-20030419-branchpoint:1.12
	carlton_dictionary-20030416-merge:1.12
	cagney_frameaddr-20030409-mergepoint:1.12
	kettenis_i386newframe-20030406-branch:1.12.0.30
	kettenis_i386newframe-20030406-branchpoint:1.12
	cagney_frameaddr-20030403-branchpoint:1.12
	cagney_frameaddr-20030403-branch:1.12.0.28
	cagney_framebase-20030330-mergepoint:1.12
	cagney_framebase-20030326-branch:1.12.0.26
	cagney_framebase-20030326-branchpoint:1.12
	cagney_lazyid-20030317-branch:1.12.0.24
	cagney_lazyid-20030317-branchpoint:1.12
	kettenis-i386newframe-20030316-mergepoint:1.12
	offbyone-20030313-branch:1.12.0.22
	offbyone-20030313-branchpoint:1.12
	kettenis-i386newframe-20030308-branch:1.12.0.20
	kettenis-i386newframe-20030308-branchpoint:1.12
	carlton_dictionary-20030305-merge:1.12
	cagney_offbyone-20030303-branch:1.12.0.18
	cagney_offbyone-20030303-branchpoint:1.12
	carlton_dictionary-20030207-merge:1.12
	interps-20030202-branch:1.12.0.16
	interps-20030202-branchpoint:1.12
	cagney-unwind-20030108-branch:1.12.0.14
	cagney-unwind-20030108-branchpoint:1.12
	binutils-2_13_2_1:1.11
	binutils-2_13_2:1.11
	carlton_dictionary-20021223-merge:1.12
	gdb_5_3-2002-12-12-release:1.12
	carlton_dictionary-20021115-merge:1.12
	binutils-2_13_1:1.11
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.12
	drow-cplus-branch:1.12.0.12
	drow-cplus-branchpoint:1.12
	kseitz_interps-20020930-merge:1.12
	carlton_dictionary-20020927-merge:1.12
	carlton_dictionary-branch:1.12.0.10
	carlton_dictionary-20020920-branchpoint:1.12
	sid-20020905-branchpoint:1.12
	sid-20020905-branch:1.12.0.8
	gdb_5_3-branch:1.12.0.6
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.12
	cagney_sysregs-20020825-branch:1.12.0.4
	cagney_sysregs-20020825-branchpoint:1.12
	readline_4_3-import-branch:1.12.0.2
	readline_4_3-import-branchpoint:1.12
	binutils-2_13:1.11
	gdb_5_2_1-2002-07-23-release:1.10
	binutils-2_13-branchpoint:1.11
	binutils-2_13-branch:1.11.0.8
	kseitz_interps-20020528-branch:1.11.0.6
	kseitz_interps-20020528-branchpoint:1.11
	cagney_regbuf-20020515-branch:1.11.0.4
	cagney_regbuf-20020515-branchpoint:1.11
	binutils-2_12_1:1.10
	jimb-macro-020506-branch:1.11.0.2
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.10
	binutils-2_12:1.10
	gdb_5_2-branch:1.10.0.4
	gdb_5_2-2002-03-03-branchpoint:1.10
	binutils-2_12-branch:1.10.0.2
	binutils-2_12-branchpoint:1.10
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.3
	binutils-2_10_1:1.1.1.1.2.1
	binutils-2_10:1.1.1.1.2.1
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.19
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.07.07.34.31;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.15.22.01.43;	author cpg;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.28.20.12.17;	author cpg;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.19.13.46.37;	author cpg;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.01.19.59.33;	author cpg;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.22.19.22.35;	author nickc;	state Exp;
branches
	1.12.10.1
	1.12.12.1
	1.12.32.1
	1.12.34.1;
next	1.11;

1.11
date	2002.04.25.10.59.24;	author nickc;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	2001.10.09.17.25.58;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.26.11.47.39;	author aj;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.13.08.09.58;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.24.00.48.04;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.06.17.01.35;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.24.15.22.25;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.22.58.38;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.24.17.20.18;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.12.10.1
date	2003.05.23.18.40.56;	author carlton;	state Exp;
branches;
next	1.12.10.2;

1.12.10.2
date	2003.06.27.21.50.28;	author carlton;	state Exp;
branches;
next	1.12.10.3;

1.12.10.3
date	2003.12.16.00.01.18;	author carlton;	state Exp;
branches;
next	1.12.10.4;

1.12.10.4
date	2004.01.26.19.11.50;	author carlton;	state Exp;
branches;
next	;

1.12.12.1
date	2003.12.14.20.28.10;	author drow;	state Exp;
branches;
next	1.12.12.2;

1.12.12.2
date	2003.12.20.18.16.51;	author drow;	state Exp;
branches;
next	;

1.12.32.1
date	2003.05.04.11.37.51;	author kettenis;	state Exp;
branches;
next	;

1.12.34.1
date	2003.05.01.20.23.33;	author cpg;	state Exp;
branches;
next	;

1.11.6.1
date	2002.08.30.22.52.54;	author kseitz;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.18.37;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;


desc
@@


1.19
log
@update copyright dates
@
text
@/* Disassemble z8000 code.
   Copyright 1992, 1993, 1998, 2000, 2001, 2002, 2003, 2005, 2007
   Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this file; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "dis-asm.h"

#define DEFINE_TABLE
#include "z8k-opc.h"

#include <setjmp.h>

typedef struct
{
  /* These are all indexed by nibble number (i.e only every other entry
     of bytes is used, and every 4th entry of words).  */
  unsigned char nibbles[24];
  unsigned char bytes[24];
  unsigned short words[24];

  /* Nibble number of first word not yet fetched.  */
  int max_fetched;
  bfd_vma insn_start;
  jmp_buf bailout;

  int tabl_index;
  char instr_asmsrc[80];
  unsigned long arg_reg[0x0f];
  unsigned long immediate;
  unsigned long displacement;
  unsigned long address;
  unsigned long cond_code;
  unsigned long ctrl_code;
  unsigned long flags;
  unsigned long interrupts;
}
instr_data_s;

/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)
   to ADDR (exclusive) are valid.  Returns 1 for success, longjmps
   on error.  */
#define FETCH_DATA(info, nibble) \
  ((nibble) < ((instr_data_s *) (info->private_data))->max_fetched \
   ? 1 : fetch_data ((info), (nibble)))

static int
fetch_data (struct disassemble_info *info, int nibble)
{
  unsigned char mybuf[20];
  int status;
  instr_data_s *priv = (instr_data_s *) info->private_data;

  if ((nibble % 4) != 0)
    abort ();

  status = (*info->read_memory_func) (priv->insn_start,
				      (bfd_byte *) mybuf,
				      nibble / 2,
				      info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, priv->insn_start, info);
      longjmp (priv->bailout, 1);
    }

  {
    int i;
    unsigned char *p = mybuf;

    for (i = 0; i < nibble;)
      {
	priv->words[i] = (p[0] << 8) | p[1];

	priv->bytes[i] = *p;
	priv->nibbles[i++] = *p >> 4;
	priv->nibbles[i++] = *p & 0xf;

	++p;
	priv->bytes[i] = *p;
	priv->nibbles[i++] = *p >> 4;
	priv->nibbles[i++] = *p & 0xf;

	++p;
      }
  }
  priv->max_fetched = nibble;
  return 1;
}

static char *codes[16] =
  {
    "f",
    "lt",
    "le",
    "ule",
    "ov/pe",
    "mi",
    "eq",
    "c/ult",
    "t",
    "ge",
    "gt",
    "ugt",
    "nov/po",
    "pl",
    "ne",
    "nc/uge"
  };

static char *ctrl_names[8] =
  {
    "<invld>",
    "flags",
    "fcw",
    "refresh",
    "psapseg",
    "psapoff",
    "nspseg",
    "nspoff"
  };

static int seg_length;
int z8k_lookup_instr (unsigned char *, disassemble_info *);
static void output_instr (instr_data_s *, unsigned long, disassemble_info *);
static void unpack_instr (instr_data_s *, int, disassemble_info *);
static void unparse_instr (instr_data_s *, int);

static int
print_insn_z8k (bfd_vma addr, disassemble_info *info, int is_segmented)
{
  instr_data_s instr_data;

  info->private_data = (PTR) &instr_data;
  instr_data.max_fetched = 0;
  instr_data.insn_start = addr;
  if (setjmp (instr_data.bailout) != 0)
    /* Error return.  */
    return -1;

  info->bytes_per_chunk = 2;
  info->bytes_per_line = 6;
  info->display_endian = BFD_ENDIAN_BIG;

  instr_data.tabl_index = z8k_lookup_instr (instr_data.nibbles, info);
  if (instr_data.tabl_index >= 0)
    {
      unpack_instr (&instr_data, is_segmented, info);
      unparse_instr (&instr_data, is_segmented);
      output_instr (&instr_data, addr, info);
      return z8k_table[instr_data.tabl_index].length + seg_length;
    }
  else
    {
      FETCH_DATA (info, 4);
      (*info->fprintf_func) (info->stream, ".word %02x%02x",
			     instr_data.bytes[0], instr_data.bytes[2]);
      return 2;
    }
}

int
print_insn_z8001 (bfd_vma addr, disassemble_info *info)
{
  return print_insn_z8k (addr, info, 1);
}

int
print_insn_z8002 (bfd_vma addr, disassemble_info *info)
{
  return print_insn_z8k (addr, info, 0);
}

int
z8k_lookup_instr (unsigned char *nibbles, disassemble_info *info)
{
  int nibl_index, tabl_index;
  int nibl_matched;
  int need_fetch = 0;
  unsigned short instr_nibl;
  unsigned short tabl_datum, datum_class, datum_value;

  nibl_matched = 0;
  tabl_index = 0;
  FETCH_DATA (info, 4);
  while (!nibl_matched && z8k_table[tabl_index].name)
    {
      nibl_matched = 1;
      for (nibl_index = 0;
	   nibl_index < z8k_table[tabl_index].length * 2 && nibl_matched;
	   nibl_index++)
	{
	  if ((nibl_index % 4) == 0)
            {
              /* Fetch data only if it isn't already there.  */
              if (nibl_index >= 4 || (nibl_index < 4 && need_fetch))
                FETCH_DATA (info, nibl_index + 4);   /* Fetch one word at a time.  */
              if (nibl_index < 4)
                need_fetch = 0;
              else
                need_fetch = 1;
            }
	  instr_nibl = nibbles[nibl_index];

	  tabl_datum = z8k_table[tabl_index].byte_info[nibl_index];
	  datum_class = tabl_datum & CLASS_MASK;
	  datum_value = ~CLASS_MASK & tabl_datum;

	  switch (datum_class)
	    {
	    case CLASS_BIT:
	      if (datum_value != instr_nibl)
		nibl_matched = 0;
	      break;
	    case CLASS_IGNORE:
	      break;
	    case CLASS_00II:
	      if (!((~instr_nibl) & 0x4))
		nibl_matched = 0;
	      break;
	    case CLASS_01II:
	      if (!(instr_nibl & 0x4))
		nibl_matched = 0;
	      break;
	    case CLASS_0CCC:
	      if (!((~instr_nibl) & 0x8))
		nibl_matched = 0;
	      break;
	    case CLASS_1CCC:
	      if (!(instr_nibl & 0x8))
		nibl_matched = 0;
	      break;
	    case CLASS_0DISP7:
	      if (!((~instr_nibl) & 0x8))
		nibl_matched = 0;
	      nibl_index += 1;
	      break;
	    case CLASS_1DISP7:
	      if (!(instr_nibl & 0x8))
		nibl_matched = 0;
	      nibl_index += 1;
	      break;
	    case CLASS_REGN0:
	      if (instr_nibl == 0)
		nibl_matched = 0;
	      break;
	    case CLASS_BIT_1OR2:
	      if ((instr_nibl | 0x2) != (datum_value | 0x2))
		nibl_matched = 0;
	      break;
	    default:
	      break;
	    }
	}

      if (nibl_matched)
	return tabl_index;

      tabl_index++;
    }
  return -1;
}

static void
output_instr (instr_data_s *instr_data,
              unsigned long addr ATTRIBUTE_UNUSED,
              disassemble_info *info)
{
  int num_bytes;
  char out_str[100];

  out_str[0] = 0;

  num_bytes = (z8k_table[instr_data->tabl_index].length + seg_length) * 2;
  FETCH_DATA (info, num_bytes);

  strcat (out_str, instr_data->instr_asmsrc);

  (*info->fprintf_func) (info->stream, "%s", out_str);
}

static void
unpack_instr (instr_data_s *instr_data, int is_segmented, disassemble_info *info)
{
  int nibl_count, loop;
  unsigned short instr_nibl, instr_byte, instr_word;
  long instr_long;
  unsigned int tabl_datum, datum_class;
  unsigned short datum_value;

  nibl_count = 0;
  loop = 0;
  seg_length = 0;

  while (z8k_table[instr_data->tabl_index].byte_info[loop] != 0)
    {
      FETCH_DATA (info, nibl_count + 4 - (nibl_count % 4));
      instr_nibl = instr_data->nibbles[nibl_count];
      instr_byte = instr_data->bytes[nibl_count & ~1];
      instr_word = instr_data->words[nibl_count & ~3];

      tabl_datum = z8k_table[instr_data->tabl_index].byte_info[loop];
      datum_class = tabl_datum & CLASS_MASK;
      datum_value = tabl_datum & ~CLASS_MASK;

      switch (datum_class)
	{
	case CLASS_DISP:
	  switch (datum_value)
	    {
	    case ARG_DISP16:
	      instr_data->displacement = instr_data->insn_start + 4
		+ (signed short) (instr_word & 0xffff);
	      nibl_count += 3;
	      break;
	    case ARG_DISP12:
	      if (instr_word & 0x800)
		/* Negative 12 bit displacement.  */
		instr_data->displacement = instr_data->insn_start + 2
		  - (signed short) ((instr_word & 0xfff) | 0xf000) * 2;
	      else
		instr_data->displacement = instr_data->insn_start + 2
		  - (instr_word & 0x0fff) * 2;

	      nibl_count += 2;
	      break;
	    default:
	      break;
	    }
	  break;
	case CLASS_IMM:
	  switch (datum_value)
	    {
	    case ARG_IMM4:
	      instr_data->immediate = instr_nibl;
	      break;
	    case ARG_NIM4:
	      instr_data->immediate = (- instr_nibl) & 0xf;
	      break;
	    case ARG_NIM8:
	      instr_data->immediate = (- instr_byte) & 0xff;
	      nibl_count += 1;
	      break;
	    case ARG_IMM8:
	      instr_data->immediate = instr_byte;
	      nibl_count += 1;
	      break;
	    case ARG_IMM16:
	      instr_data->immediate = instr_word;
	      nibl_count += 3;
	      break;
	    case ARG_IMM32:
	      FETCH_DATA (info, nibl_count + 8);
	      instr_long = (instr_data->words[nibl_count] << 16)
		| (instr_data->words[nibl_count + 4]);
	      instr_data->immediate = instr_long;
	      nibl_count += 7;
	      break;
	    case ARG_IMMN:
	      instr_data->immediate = instr_nibl - 1;
	      break;
	    case ARG_IMM4M1:
	      instr_data->immediate = instr_nibl + 1;
	      break;
	    case ARG_IMM_1:
	      instr_data->immediate = 1;
	      break;
	    case ARG_IMM_2:
	      instr_data->immediate = 2;
	      break;
	    case ARG_IMM2:
	      instr_data->immediate = instr_nibl & 0x3;
	      break;
	    default:
	      break;
	    }
	  break;
	case CLASS_CC:
	  instr_data->cond_code = instr_nibl;
	  break;
	case CLASS_ADDRESS:
	  if (is_segmented)
	    {
	      if (instr_nibl & 0x8)
		{
		  FETCH_DATA (info, nibl_count + 8);
		  instr_long = (instr_data->words[nibl_count] << 16)
		    | (instr_data->words[nibl_count + 4]);
		  instr_data->address = ((instr_word & 0x7f00) << 16)
		    + (instr_long & 0xffff);
		  nibl_count += 7;
		  seg_length = 2;
		}
	      else
		{
		  instr_data->address = ((instr_word & 0x7f00) << 16)
		    + (instr_word & 0x00ff);
		  nibl_count += 3;
		}
	    }
	  else
	    {
	      instr_data->address = instr_word;
	      nibl_count += 3;
	    }
	  break;
	case CLASS_0CCC:
	case CLASS_1CCC:
	  instr_data->ctrl_code = instr_nibl & 0x7;
	  break;
	case CLASS_0DISP7:
	  instr_data->displacement =
	    instr_data->insn_start + 2 - (instr_byte & 0x7f) * 2;
	  nibl_count += 1;
	  break;
	case CLASS_1DISP7:
	  instr_data->displacement =
	    instr_data->insn_start + 2 - (instr_byte & 0x7f) * 2;
	  nibl_count += 1;
	  break;
	case CLASS_01II:
	  instr_data->interrupts = instr_nibl & 0x3;
	  break;
	case CLASS_00II:
	  instr_data->interrupts = instr_nibl & 0x3;
	  break;
	case CLASS_IGNORE:
	case CLASS_BIT:
	  instr_data->ctrl_code = instr_nibl & 0x7;
	  break;
	case CLASS_FLAGS:
	  instr_data->flags = instr_nibl;
	  break;
	case CLASS_REG:
	  instr_data->arg_reg[datum_value] = instr_nibl;
	  break;
	case CLASS_REGN0:
	  instr_data->arg_reg[datum_value] = instr_nibl;
	  break;
	case CLASS_DISP8:
	  instr_data->displacement =
	    instr_data->insn_start + 2 + (signed char) instr_byte * 2;
	  nibl_count += 1;
	  break;
        case CLASS_BIT_1OR2:
          instr_data->immediate = ((instr_nibl >> 1) & 0x1) + 1;
          nibl_count += 1;
	  break;
	default:
	  abort ();
	  break;
	}

      loop += 1;
      nibl_count += 1;
    }
}

static void
print_intr(char *tmp_str, unsigned long interrupts)
{
  int comma = 0;

  *tmp_str = 0;
  if (! (interrupts & 2))
    {
      strcat (tmp_str, "vi");
      comma = 1;
    }
  if (! (interrupts & 1))
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "nvi");
    }
}

static void
print_flags(char *tmp_str, unsigned long flags)
{
  int comma = 0;

  *tmp_str = 0;
  if (flags & 8)
    {
      strcat (tmp_str, "c");
      comma = 1;
    }
  if (flags & 4)
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "z");
      comma = 1;
    }
  if (flags & 2)
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "s");
      comma = 1;
    }
  if (flags & 1)
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "p");
    }
}

static void
unparse_instr (instr_data_s *instr_data, int is_segmented)
{
  unsigned short datum_value;
  unsigned int tabl_datum, datum_class;
  int loop, loop_limit;
  char out_str[80], tmp_str[25];

  sprintf (out_str, "%s\t", z8k_table[instr_data->tabl_index].name);

  loop_limit = z8k_table[instr_data->tabl_index].noperands;
  for (loop = 0; loop < loop_limit; loop++)
    {
      if (loop)
	strcat (out_str, ",");

      tabl_datum = z8k_table[instr_data->tabl_index].arg_info[loop];
      datum_class = tabl_datum & CLASS_MASK;
      datum_value = tabl_datum & ~CLASS_MASK;

      switch (datum_class)
	{
	case CLASS_X:
          sprintf (tmp_str, "0x%0lx(r%ld)", instr_data->address,
                   instr_data->arg_reg[datum_value]);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_BA:
          if (is_segmented)
            sprintf (tmp_str, "rr%ld(#0x%lx)", instr_data->arg_reg[datum_value],
                     instr_data->immediate);
          else
            sprintf (tmp_str, "r%ld(#0x%lx)", instr_data->arg_reg[datum_value],
                     instr_data->immediate);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_BX:
          if (is_segmented)
            sprintf (tmp_str, "rr%ld(r%ld)", instr_data->arg_reg[datum_value],
                     instr_data->arg_reg[ARG_RX]);
          else
            sprintf (tmp_str, "r%ld(r%ld)", instr_data->arg_reg[datum_value],
                     instr_data->arg_reg[ARG_RX]);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_DISP:
	  sprintf (tmp_str, "0x%0lx", instr_data->displacement);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_IMM:
	  if (datum_value == ARG_IMM2)	/* True with EI/DI instructions only.  */
	    {
	      print_intr (tmp_str, instr_data->interrupts);
	      strcat (out_str, tmp_str);
	      break;
	    }
	  sprintf (tmp_str, "#0x%0lx", instr_data->immediate);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_CC:
	  sprintf (tmp_str, "%s", codes[instr_data->cond_code]);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_CTRL:
	  sprintf (tmp_str, "%s", ctrl_names[instr_data->ctrl_code]);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_DA:
	case CLASS_ADDRESS:
	  sprintf (tmp_str, "0x%0lx", instr_data->address);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_IR:
	  if (is_segmented)
	    sprintf (tmp_str, "@@rr%ld", instr_data->arg_reg[datum_value]);
	  else
	    sprintf (tmp_str, "@@r%ld", instr_data->arg_reg[datum_value]);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_IRO:
          sprintf (tmp_str, "@@r%ld", instr_data->arg_reg[datum_value]);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_FLAGS:
	  print_flags(tmp_str, instr_data->flags);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_REG_BYTE:
	  if (instr_data->arg_reg[datum_value] >= 0x8)
	    sprintf (tmp_str, "rl%ld",
		     instr_data->arg_reg[datum_value] - 0x8);
	  else
	    sprintf (tmp_str, "rh%ld", instr_data->arg_reg[datum_value]);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_REG_WORD:
	  sprintf (tmp_str, "r%ld", instr_data->arg_reg[datum_value]);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_REG_QUAD:
	  sprintf (tmp_str, "rq%ld", instr_data->arg_reg[datum_value]);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_REG_LONG:
	  sprintf (tmp_str, "rr%ld", instr_data->arg_reg[datum_value]);
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_PR:
	  if (is_segmented)
	    sprintf (tmp_str, "rr%ld", instr_data->arg_reg[datum_value]);
	  else
	    sprintf (tmp_str, "r%ld", instr_data->arg_reg[datum_value]);
	  strcat (out_str, tmp_str);
	  break;
	default:
	  abort ();
	  break;
	}
    }

  strcpy (instr_data->instr_asmsrc, out_str);
}
@


1.18
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1998, 2000, 2001, 2002, 2003, 2007
@


1.17
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1998, 2000, 2001, 2002, 2003
d5 1
a5 1
   This file is part of GNU Binutils.
d7 1
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d18 3
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,
   USA.  */
@


1.16
log
@	* z8k-dis.c (intr_names): Removed.
	(print_intr, print_flags): New functions.
	(unparse_instr): Use new functions.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
@


1.15
log
@	* z8k-dis.c: Convert to ISO C90.
	* z8kgen.c: Convert to ISO C90.
	(opt): Move long opcode for "ldb rdb,imm8" after short one, now
	the short one is created when assembling.
	* z8k-opc.h: Regenerate with new z8kgen.c.
@
text
@d29 1
a29 1

d475 47
a521 6
static char *intr_names[] = {
  "all",    /* 0 */
  "vi",     /* 1 */
  "nvi",    /* 2 */
  "none"    /* 3 */
};
d573 6
a578 6
          if (datum_value == ARG_IMM2)  /* True with EI/DI instructions only.  */
            {
              sprintf (tmp_str, "%s", intr_names[instr_data->interrupts]);
              strcat (out_str, tmp_str);
              break;
            }
d607 1
a607 1
	  sprintf (tmp_str, "0x%0lx", instr_data->flags);
@


1.14
log
@	* z8k-dis.c (instr_data_s): Change tabl_index from long to int.
	(print_insn_z8k): Correctly check return value from
	z8k_lookup_instr call.
	(unparse_instr): Handle CLASS_IRO case.
	* z8kgen.c: Fix function definitions.  Fix formatting.
	(opt): Add brk opcode alias for non-simulator breakpoint.  Add
	missing and fix existing in/out and sin/sout opcode definitions.
	(args): "@@ri", "@@ro" - add CLASS_IRO register usage for in/out
	opcodes.
	(internal): Check p->flags for non-zero before dereferencing it.
	(gas): Add CLASS_IRO line.  Insert new OPC_xxx lines for the added
	opcodes and renumber the remaining lines repectively.
	(main): Remove "-d" command line switch.
	* z8k-opc.h: Regenerate with new z8kgen.c.
@
text
@d27 1
a27 1

a55 3
static int fetch_data PARAMS ((struct disassemble_info *, int));


d64 1
a64 3
fetch_data (info, nibble)
     struct disassemble_info *info;
     int nibble;
d140 4
a143 6
static int print_insn_z8k PARAMS ((bfd_vma, disassemble_info *, int));
int z8k_lookup_instr PARAMS ((unsigned char *, disassemble_info *));
static void output_instr
  PARAMS ((instr_data_s *, unsigned long, disassemble_info *));
static void unpack_instr PARAMS ((instr_data_s *, int, disassemble_info *));
static void unparse_instr PARAMS ((instr_data_s *, int));
d146 1
a146 4
print_insn_z8k (addr, info, is_segmented)
     bfd_vma addr;
     disassemble_info *info;
     int is_segmented;
d179 1
a179 3
print_insn_z8001 (addr, info)
     bfd_vma addr;
     disassemble_info *info;
d185 1
a185 3
print_insn_z8002 (addr, info)
     bfd_vma addr;
     disassemble_info *info;
d191 1
a191 3
z8k_lookup_instr (nibbles, info)
     unsigned char *nibbles;
     disassemble_info *info;
a192 1

d281 3
a283 4
output_instr (instr_data, addr, info)
     instr_data_s *instr_data;
     unsigned long addr ATTRIBUTE_UNUSED;
     disassemble_info *info;
d299 1
a299 4
unpack_instr (instr_data, is_segmented, info)
     instr_data_s *instr_data;
     int is_segmented;
     disassemble_info *info;
d483 1
a483 3
unparse_instr (instr_data, is_segmented)
     instr_data_s *instr_data;
     int is_segmented;
@


1.13
log
@	* expr.h: Fix comments in operatorT typedef.
	* config/tc-z8k.c: Add 2003 to copyright message.
	Fold s_segm() and s_unseg() into one function s_segm(parm) which
	decides by the parameter.
	(md_begin): Don't set linkrelax.  Only set Z8002 default if no
	command line argument was given to select the intended
	architecure.
	(get_interrupt_operand): Warn if NOP type code is emitted.
	(newfix): New parameter 'size', forward it to 'fix_new_exp'.
	(apply_fix): Call newfix with additional 'size' parameter.
	(build_bytes): Remove unused variable 'nib'.  Detect overflow in
	4 bit immediate arguments.
	(md_longopts): Add 'linkrelax' option.
	(md_parse_option): Adapt to new s_segm function.  Set 'linkrelax'
	variable when 'linkrelax' command line option is specified.
	(md_show_usage): Display 'linkrelax' option.
	(md_apply_fix3): Fix cases R_IMM4L, R_JR, and R_IMM8.  Add cases
	R_CALLR and R_REL16.
	* config/tc-z8k.h: Undef WARN_SIGNED_OVERFLOW_WORD.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1998, 2000, 2001, 2002
d43 1
a43 1
  long tabl_index;
d172 1
a172 1
  if (instr_data.tabl_index > 0)
d582 4
@


1.12
log
@opcodes: Fix definition of "in rd,imm16" opcode.
gas: Adjust ptr variable also in "case 0" case.
@
text
@d212 1
d218 1
d227 9
a235 2
	    /* Fetch one word at a time.  */
	    FETCH_DATA (info, nibl_index + 4);
d426 1
a426 1
		  instr_data->address = ((instr_word & 0x7f00) << 8)
d433 1
a433 1
		  instr_data->address = ((instr_word & 0x7f00) << 8)
d496 7
d555 6
@


1.12.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1998, 2000, 2001, 2002, 2003
d27 1
a27 1

d43 1
a43 1
  int tabl_index;
d56 3
d67 3
a69 1
fetch_data (struct disassemble_info *info, int nibble)
d145 6
a150 4
int z8k_lookup_instr (unsigned char *, disassemble_info *);
static void output_instr (instr_data_s *, unsigned long, disassemble_info *);
static void unpack_instr (instr_data_s *, int, disassemble_info *);
static void unparse_instr (instr_data_s *, int);
d153 4
a156 1
print_insn_z8k (bfd_vma addr, disassemble_info *info, int is_segmented)
d172 1
a172 1
  if (instr_data.tabl_index >= 0)
d189 3
a191 1
print_insn_z8001 (bfd_vma addr, disassemble_info *info)
d197 3
a199 1
print_insn_z8002 (bfd_vma addr, disassemble_info *info)
d205 3
a207 1
z8k_lookup_instr (unsigned char *nibbles, disassemble_info *info)
d209 1
a211 1
  int need_fetch = 0;
a216 1
  FETCH_DATA (info, 4);
d225 2
a226 9
            {
              /* Fetch data only if it isn't already there.  */
              if (nibl_index >= 4 || (nibl_index < 4 && need_fetch))
                FETCH_DATA (info, nibl_index + 4);   /* Fetch one word at a time.  */
              if (nibl_index < 4)
                need_fetch = 0;
              else
                need_fetch = 1;
            }
d289 4
a292 3
output_instr (instr_data_s *instr_data,
              unsigned long addr ATTRIBUTE_UNUSED,
              disassemble_info *info)
d308 4
a311 1
unpack_instr (instr_data_s *instr_data, int is_segmented, disassemble_info *info)
d417 1
a417 1
		  instr_data->address = ((instr_word & 0x7f00) << 16)
d424 1
a424 1
		  instr_data->address = ((instr_word & 0x7f00) << 16)
a486 7
static char *intr_names[] = {
  "all",    /* 0 */
  "vi",     /* 1 */
  "nvi",    /* 2 */
  "none"    /* 3 */
};

d488 3
a490 1
unparse_instr (instr_data_s *instr_data, int is_segmented)
a538 6
          if (datum_value == ARG_IMM2)  /* True with EI/DI instructions only.  */
            {
              sprintf (tmp_str, "%s", intr_names[instr_data->interrupts]);
              strcat (out_str, tmp_str);
              break;
            }
a559 4
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_IRO:
          sprintf (tmp_str, "@@r%ld", instr_data->arg_reg[datum_value]);
@


1.12.12.2
log
@Merge from mainline.
@
text
@d29 1
a29 1

d475 6
a480 47
static void
print_intr(char *tmp_str, unsigned long interrupts)
{
  int comma = 0;

  *tmp_str = 0;
  if (! (interrupts & 2))
    {
      strcat (tmp_str, "vi");
      comma = 1;
    }
  if (! (interrupts & 1))
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "nvi");
    }
}

static void
print_flags(char *tmp_str, unsigned long flags)
{
  int comma = 0;

  *tmp_str = 0;
  if (flags & 8)
    {
      strcat (tmp_str, "c");
      comma = 1;
    }
  if (flags & 4)
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "z");
      comma = 1;
    }
  if (flags & 2)
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "s");
      comma = 1;
    }
  if (flags & 1)
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "p");
    }
}
d532 6
a537 6
	  if (datum_value == ARG_IMM2)	/* True with EI/DI instructions only.  */
	    {
	      print_intr (tmp_str, instr_data->interrupts);
	      strcat (out_str, tmp_str);
	      break;
	    }
d566 1
a566 1
	  print_flags(tmp_str, instr_data->flags);
@


1.12.10.1
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a211 1
  int need_fetch = 0;
a216 1
  FETCH_DATA (info, 4);
d225 2
a226 9
            {
              /* Fetch data only if it isn't already there.  */
              if (nibl_index >= 4 || (nibl_index < 4 && need_fetch))
                FETCH_DATA (info, nibl_index + 4);   /* Fetch one word at a time.  */
              if (nibl_index < 4)
                need_fetch = 0;
              else
                need_fetch = 1;
            }
d417 1
a417 1
		  instr_data->address = ((instr_word & 0x7f00) << 16)
d424 1
a424 1
		  instr_data->address = ((instr_word & 0x7f00) << 16)
a486 7
static char *intr_names[] = {
  "all",    /* 0 */
  "vi",     /* 1 */
  "nvi",    /* 2 */
  "none"    /* 3 */
};

a538 6
          if (datum_value == ARG_IMM2)  /* True with EI/DI instructions only.  */
            {
              sprintf (tmp_str, "%s", intr_names[instr_data->interrupts]);
              strcat (out_str, tmp_str);
              break;
            }
@


1.12.10.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1998, 2000, 2001, 2002, 2003
d43 1
a43 1
  int tabl_index;
d172 1
a172 1
  if (instr_data.tabl_index >= 0)
a581 4
	  strcat (out_str, tmp_str);
	  break;
	case CLASS_IRO:
          sprintf (tmp_str, "@@r%ld", instr_data->arg_reg[datum_value]);
@


1.12.10.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d27 1
a27 1

d56 3
d67 3
a69 1
fetch_data (struct disassemble_info *info, int nibble)
d145 6
a150 4
int z8k_lookup_instr (unsigned char *, disassemble_info *);
static void output_instr (instr_data_s *, unsigned long, disassemble_info *);
static void unpack_instr (instr_data_s *, int, disassemble_info *);
static void unparse_instr (instr_data_s *, int);
d153 4
a156 1
print_insn_z8k (bfd_vma addr, disassemble_info *info, int is_segmented)
d189 3
a191 1
print_insn_z8001 (bfd_vma addr, disassemble_info *info)
d197 3
a199 1
print_insn_z8002 (bfd_vma addr, disassemble_info *info)
d205 3
a207 1
z8k_lookup_instr (unsigned char *nibbles, disassemble_info *info)
d209 1
d298 4
a301 3
output_instr (instr_data_s *instr_data,
              unsigned long addr ATTRIBUTE_UNUSED,
              disassemble_info *info)
d317 4
a320 1
unpack_instr (instr_data_s *instr_data, int is_segmented, disassemble_info *info)
d504 3
a506 1
unparse_instr (instr_data_s *instr_data, int is_segmented)
@


1.12.10.4
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d29 1
a29 1

d475 6
a480 47
static void
print_intr(char *tmp_str, unsigned long interrupts)
{
  int comma = 0;

  *tmp_str = 0;
  if (! (interrupts & 2))
    {
      strcat (tmp_str, "vi");
      comma = 1;
    }
  if (! (interrupts & 1))
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "nvi");
    }
}

static void
print_flags(char *tmp_str, unsigned long flags)
{
  int comma = 0;

  *tmp_str = 0;
  if (flags & 8)
    {
      strcat (tmp_str, "c");
      comma = 1;
    }
  if (flags & 4)
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "z");
      comma = 1;
    }
  if (flags & 2)
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "s");
      comma = 1;
    }
  if (flags & 1)
    {
      if (comma) strcat (tmp_str, ",");
      strcat (tmp_str, "p");
    }
}
d532 6
a537 6
	  if (datum_value == ARG_IMM2)	/* True with EI/DI instructions only.  */
	    {
	      print_intr (tmp_str, instr_data->interrupts);
	      strcat (out_str, tmp_str);
	      break;
	    }
d566 1
a566 1
	  print_flags(tmp_str, instr_data->flags);
@


1.12.32.1
log
@Merge from mainline.
@
text
@a211 1
  int need_fetch = 0;
a216 1
  FETCH_DATA (info, 4);
d225 2
a226 9
            {
              /* Fetch data only if it isn't already there.  */
              if (nibl_index >= 4 || (nibl_index < 4 && need_fetch))
                FETCH_DATA (info, nibl_index + 4);   /* Fetch one word at a time.  */
              if (nibl_index < 4)
                need_fetch = 0;
              else
                need_fetch = 1;
            }
d417 1
a417 1
		  instr_data->address = ((instr_word & 0x7f00) << 16)
d424 1
a424 1
		  instr_data->address = ((instr_word & 0x7f00) << 16)
a486 7
static char *intr_names[] = {
  "all",    /* 0 */
  "vi",     /* 1 */
  "nvi",    /* 2 */
  "none"    /* 3 */
};

a538 6
          if (datum_value == ARG_IMM2)  /* True with EI/DI instructions only.  */
            {
              sprintf (tmp_str, "%s", intr_names[instr_data->interrupts]);
              strcat (out_str, tmp_str);
              break;
            }
@


1.12.34.1
log
@	* z8k-dis.c (z8k_lookup_instr): Optimize FETCH_DATA calls.
	(unpack_instr): Fix representation of segmented addresses.
	(intr_name): Added, contains names of the parameters to the EI/DI
	instructions.
	(unparse_instr): Fix display of EI/DI parameters.
@
text
@a211 1
  int need_fetch = 0;
a216 1
  FETCH_DATA (info, 4);
d225 2
a226 9
            {
              /* Fetch data only if it isn't already there.  */
              if (nibl_index >= 4 || (nibl_index < 4 && need_fetch))
                FETCH_DATA (info, nibl_index + 4);   /* Fetch one word at a time.  */
              if (nibl_index < 4)
                need_fetch = 0;
              else
                need_fetch = 1;
            }
d417 1
a417 1
		  instr_data->address = ((instr_word & 0x7f00) << 16)
d424 1
a424 1
		  instr_data->address = ((instr_word & 0x7f00) << 16)
a486 7
static char *intr_names[] = {
  "all",    /* 0 */
  "vi",     /* 1 */
  "nvi",    /* 2 */
  "none"    /* 3 */
};

a538 6
          if (datum_value == ARG_IMM2)  /* True with EI/DI instructions only.  */
            {
              sprintf (tmp_str, "%s", intr_names[instr_data->interrupts]);
              strcat (out_str, tmp_str);
              break;
            }
@


1.11
log
@The patch contains mostly fixes for the disassembler. It also fixes
a crash of the assembler with some malformed source input.
Long segmented addresses are now correctly relocated.
Finally it updates my email address in the MAINTAINERS file.
@
text
@d518 1
a518 1
            sprintf (tmp_str, "rr%ld(#%lx)", instr_data->arg_reg[datum_value],
d521 1
a521 1
            sprintf (tmp_str, "r%ld(#%lx)", instr_data->arg_reg[datum_value],
@


1.11.6.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d518 1
a518 1
            sprintf (tmp_str, "rr%ld(#0x%lx)", instr_data->arg_reg[datum_value],
d521 1
a521 1
            sprintf (tmp_str, "r%ld(#0x%lx)", instr_data->arg_reg[datum_value],
@


1.10
log
@fix z8k assembly and disassembly
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1998, 2000, 2001
d5 1
a5 1
This file is part of GNU Binutils.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d30 2
a31 1
typedef struct {
d53 2
a54 1
} instr_data_s;
d112 31
a142 29
static char *codes[16] = {
  "f",
  "lt",
  "le",
  "ule",
  "ov/pe",
  "mi",
  "eq",
  "c/ult",
  "t",
  "ge",
  "gt",
  "ugt",
  "nov/po",
  "pl",
  "ne",
  "nc/uge"
};

static char *ctrl_names[8] = {
  "<invld>",
  "flags",
  "fcw",
  "refresh",
  "psapseg",
  "psapoff",
  "nspseg",
  "nspoff"
};
d167 4
d239 2
d279 1
d281 1
a281 3
	{
	  return tabl_index;
	}
d294 1
a294 2
  int loop, loop_limit;
  char tmp_str[20];
d297 1
a297 1
  strcpy (out_str, "\t");
d299 2
a300 12
  loop_limit = (z8k_table[instr_data->tabl_index].length + seg_length) * 2;
  FETCH_DATA (info, loop_limit);
  for (loop = 0; loop < loop_limit; loop++)
    {
      sprintf (tmp_str, "%x", instr_data->nibbles[loop]);
      strcat (out_str, tmp_str);
    }

  while (loop++ < 8)
    {
      strcat (out_str, " ");
    }
d322 1
d346 3
a348 5
		{
		  /* neg. 12 bit displacement */
		  instr_data->displacement = instr_data->insn_start + 2
		    - (signed short) ((instr_word & 0xfff) | 0xf000) * 2;
		}
d350 3
a352 4
		{
		  instr_data->displacement = instr_data->insn_start + 2
		    - (instr_word & 0x0fff) * 2;
		}
d365 3
d369 1
a369 1
	      instr_data->immediate = (-instr_byte);
d455 1
d473 4
d497 1
a497 1
  sprintf (out_str, "\t%s\t", z8k_table[instr_data->tabl_index].name);
d512 2
a513 2
	  sprintf (tmp_str, "0x%0lx(R%ld)", instr_data->address,
		   instr_data->arg_reg[datum_value]);
d517 6
a522 2
	  sprintf (tmp_str, "r%ld(#%lx)", instr_data->arg_reg[datum_value],
		   instr_data->immediate);
d526 6
a531 2
	  sprintf (tmp_str, "r%ld(R%ld)", instr_data->arg_reg[datum_value],
		   instr_data->arg_reg[ARG_RX]);
@


1.9
log
@For include/opcode:
	* d30v.h: Fix declaration of reg_name_cnt.

	* d10v.h: Fix declaration of d10v_reg_name_cnt.

	* arc.h: Add prototypes from opcodes/arc-opc.c.

For opcodes:
	* tic54x-dis.c: Add unused attributes where needed.

	* z8k-dis.c (output_instr): Add unused attribute.

	* h8300-dis.c: Add missing prototypes.
	(bfd_h8_disassemble): Make static.

	* cris-dis.c: Add missing prototype.
	* h8500-dis.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* z8k-dis.c: Likewise.

	* d10v-dis.c: Add missing prototype.
	(dis_long): Remove unused variable.
	(dis_2_short): Likewise.

	* sh-dis.c: Add missing prototypes.
	* v850-opc.c: Likewise.
	Add unused attributes where needed.

	* ns32k-dis.c: Add missing prototypes.
	(bit_extract_simple): Remove unused variable.
@
text
@d543 4
a546 1
	  sprintf (tmp_str, "@@R%ld", instr_data->arg_reg[datum_value]);
d555 2
a556 4
	    {
	      sprintf (tmp_str, "rl%ld",
		       instr_data->arg_reg[datum_value] - 0x8);
	    }
d558 1
a558 3
	    {
	      sprintf (tmp_str, "rh%ld", instr_data->arg_reg[datum_value]);
	    }
@


1.8
log
@	* mcore-dis.c: Fix formatting.
	* mips-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* z8k-dis.c: Likewise.
@
text
@d53 3
d140 1
d281 1
a281 1
     unsigned long addr;
@


1.7
log
@	* m68k-dis.c: Fix formatting.
	* pj-dis.c: Likewise.
	* z8k-dis.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1998, 2000
a271 1

d336 2
a337 2
              instr_data->displacement = instr_data->insn_start + 4 +
                (signed short) (instr_word & 0xffff);
d341 1
a341 1
              if (instr_word & 0x800)
d347 1
a347 1
              else
d351 1
a351 1
              }
d413 2
a414 2
		  instr_data->address = ((instr_word & 0x7f00) << 8) +
		    (instr_long & 0xffff);
d416 1
a416 1
                  seg_length = 2;
d420 2
a421 2
		  instr_data->address = ((instr_word & 0x7f00) << 8) +
		    (instr_word & 0x00ff);
d436 2
a437 1
	  instr_data->displacement = instr_data->insn_start + 2 - (instr_byte & 0x7f) * 2;
d441 2
a442 1
	  instr_data->displacement = instr_data->insn_start + 2 - (instr_byte & 0x7f) * 2;
d463 3
a465 2
        case CLASS_DISP8:
	  instr_data->displacement = instr_data->insn_start + 2  + (signed char)instr_byte * 2;
d467 1
a467 1
          break;
d469 1
a469 1
          abort ();
d571 4
a574 4
          if (is_segmented)
            sprintf (tmp_str, "rr%ld", instr_data->arg_reg[datum_value]);
          else
            sprintf (tmp_str, "r%ld", instr_data->arg_reg[datum_value]);
d578 1
a578 1
          abort ();
@


1.6
log
@Remove warnings building z8k port.
Fix ld -r behaviour
@
text
@d29 1
a29 2
typedef struct
{
d51 1
a51 2
}
instr_data_s;
d57 1
a57 1
  ((nibble) < ((instr_data_s *)(info->private_data))->max_fetched \
d106 1
a106 2
static char *codes[16] =
{
d125 1
a125 2
static char *ctrl_names[8] =
{
d324 2
a325 2
      instr_byte = instr_data->bytes[nibl_count&~1];
      instr_word = instr_data->words[nibl_count&~3];
d338 1
a338 1
                (signed short)(instr_word & 0xffff);
d342 10
a351 6
              if (instr_word & 0x800) {  /* neg. 12 bit displacement */
                instr_data->displacement = instr_data->insn_start + 2 -
                  (signed short)((instr_word & 0xfff) | 0xf000) * 2;
              }
              else {
                instr_data->displacement = instr_data->insn_start + 2 - (instr_word & 0x0fff) * 2;
d477 1
a477 1
unparse_instr (instr_data,is_segmented)
@


1.5
log
@z8k fixes
@
text
@d145 1
a145 1
static void unparse_instr PARAMS ((instr_data_s *,int));
a336 9
	case CLASS_X:
	  instr_data->address = instr_nibl;
	  break;
	case CLASS_BA:
	  instr_data->displacement = instr_nibl;
	  break;
	case CLASS_BX:
	  instr_data->arg_reg[datum_value] = instr_nibl;
	  break;
a405 6
#if 0
	case CLASS_CTRL:
	  instr_data->ctrl_code = instr_nibl;
	  break;
#endif
	case CLASS_DA:
a452 3
	case CLASS_IR:
	  instr_data->arg_reg[datum_value] = instr_nibl;
	  break;
a458 12
	case CLASS_REG_BYTE:
	  instr_data->arg_reg[datum_value] = instr_nibl;
	  break;
	case CLASS_REG_WORD:
	  instr_data->arg_reg[datum_value] = instr_nibl;
	  break;
	case CLASS_REG_QUAD:
	  instr_data->arg_reg[datum_value] = instr_nibl;
	  break;
	case CLASS_REG_LONG:
	  instr_data->arg_reg[datum_value] = instr_nibl;
	  break;
a461 3
	case CLASS_PR:
	  instr_data->arg_reg[datum_value] = instr_nibl;
	  break;
d467 1
d576 1
@


1.4
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d128 13
d145 1
a145 1
static void unparse_instr PARAMS ((instr_data_s *));
d166 1
a166 1
      unparse_instr (&instr_data);
d168 1
a168 1
      return z8k_table[instr_data.tabl_index].length;
d291 1
a291 1
  loop_limit = z8k_table[instr_data->tabl_index].length * 2;
d318 2
a319 1
  unsigned short tabl_datum, datum_class, datum_value;
d323 1
d328 2
a329 2
      instr_byte = instr_data->bytes[nibl_count];
      instr_word = instr_data->words[nibl_count];
d350 2
a351 1
	      instr_data->displacement = instr_word;
d355 7
a361 1
	      instr_data->displacement = instr_word & 0x0fff;
d415 1
d419 1
d432 1
a447 2
	  instr_data->cond_code = instr_nibl & 0x7;
	  break;
d449 1
a449 1
	  instr_data->cond_code = instr_nibl & 0x7;
d452 1
a452 1
	  instr_data->displacement = instr_byte & 0x7f;
d456 1
a456 1
	  instr_data->displacement = instr_byte & 0x7f;
d466 1
a466 1
	  /* Do nothing.  */
d492 7
d509 1
a509 1
unparse_instr (instr_data)
d511 1
d513 2
a514 1
  unsigned short tabl_datum, datum_class, datum_value;
d548 1
a548 1
	  sprintf (tmp_str, "#0x%0lx", instr_data->displacement);
d560 1
a560 1
	  sprintf (tmp_str, "0x%0lx", instr_data->ctrl_code);
d565 1
a565 1
	  sprintf (tmp_str, "#0x%0lx", instr_data->address);
d598 7
@


1.3
log
@2000-08-24  Kazu Hirata  <kazu@@hxi.com>

	* z8k-dis.c: Fix formatting.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1995, 1998, 2000
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1998, 2000
@


1.2
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 2
a3 1
   Copyright 1992, 1993, 1995, 1998 Free Software Foundation, Inc.
a25 1

a27 1

d69 1
a69 1
  instr_data_s *priv = (instr_data_s *)info->private_data;
d86 2
a87 2
    unsigned char *p = mybuf ;
    
d91 1
a91 1
	
d94 1
a94 1
	priv->nibbles[i++] = *p &0xf;
d128 1
a128 1
int z8k_lookup_instr PARAMS ((unsigned char*, disassemble_info *));
d198 3
a200 1
      for (nibl_index = 0; nibl_index < z8k_table[tabl_index].length * 2 && nibl_matched; nibl_index++)
d443 1
a443 1
	  /* do nothing */
@


1.1
log
@Initial revision
@
text
@a19 1
#include <ansidecl.h>
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@d20 1
@


