head	1.44;
access;
symbols
	sid-snapshot-20180601:1.44
	sid-snapshot-20180501:1.44
	sid-snapshot-20180401:1.44
	sid-snapshot-20180301:1.44
	sid-snapshot-20180201:1.44
	sid-snapshot-20180101:1.44
	sid-snapshot-20171201:1.44
	sid-snapshot-20171101:1.44
	sid-snapshot-20171001:1.44
	sid-snapshot-20170901:1.44
	sid-snapshot-20170801:1.44
	sid-snapshot-20170701:1.44
	sid-snapshot-20170601:1.44
	sid-snapshot-20170501:1.44
	sid-snapshot-20170401:1.44
	sid-snapshot-20170301:1.44
	sid-snapshot-20170201:1.44
	sid-snapshot-20170101:1.44
	sid-snapshot-20161201:1.44
	sid-snapshot-20161101:1.44
	sid-snapshot-20160901:1.44
	sid-snapshot-20160801:1.44
	sid-snapshot-20160701:1.44
	sid-snapshot-20160601:1.44
	sid-snapshot-20160501:1.44
	sid-snapshot-20160401:1.44
	sid-snapshot-20160301:1.44
	sid-snapshot-20160201:1.44
	sid-snapshot-20160101:1.44
	sid-snapshot-20151201:1.44
	sid-snapshot-20151101:1.44
	sid-snapshot-20151001:1.44
	sid-snapshot-20150901:1.44
	sid-snapshot-20150801:1.44
	sid-snapshot-20150701:1.44
	sid-snapshot-20150601:1.44
	sid-snapshot-20150501:1.44
	sid-snapshot-20150401:1.44
	sid-snapshot-20150301:1.44
	sid-snapshot-20150201:1.44
	sid-snapshot-20150101:1.44
	sid-snapshot-20141201:1.44
	sid-snapshot-20141101:1.44
	sid-snapshot-20141001:1.44
	sid-snapshot-20140901:1.44
	sid-snapshot-20140801:1.44
	sid-snapshot-20140701:1.44
	sid-snapshot-20140601:1.44
	sid-snapshot-20140501:1.44
	sid-snapshot-20140401:1.44
	sid-snapshot-20140301:1.44
	sid-snapshot-20140201:1.44
	sid-snapshot-20140101:1.44
	sid-snapshot-20131201:1.44
	sid-snapshot-20131101:1.44
	sid-snapshot-20131001:1.44
	binutils-2_24-branch:1.44.0.8
	binutils-2_24-branchpoint:1.44
	binutils-2_21_1:1.29
	sid-snapshot-20130901:1.44
	gdb_7_6_1-2013-08-30-release:1.44
	sid-snapshot-20130801:1.44
	sid-snapshot-20130701:1.44
	sid-snapshot-20130601:1.44
	sid-snapshot-20130501:1.44
	gdb_7_6-2013-04-26-release:1.44
	sid-snapshot-20130401:1.44
	binutils-2_23_2:1.44
	gdb_7_6-branch:1.44.0.6
	gdb_7_6-2013-03-12-branchpoint:1.44
	sid-snapshot-20130301:1.44
	sid-snapshot-20130201:1.44
	sid-snapshot-20130101:1.44
	sid-snapshot-20121201:1.44
	gdb_7_5_1-2012-11-29-release:1.44
	binutils-2_23_1:1.44
	sid-snapshot-20121101:1.44
	binutils-2_23:1.44
	sid-snapshot-20121001:1.44
	sid-snapshot-20120901:1.44
	gdb_7_5-2012-08-17-release:1.44
	sid-snapshot-20120801:1.44
	binutils-2_23-branch:1.44.0.4
	binutils-2_23-branchpoint:1.44
	gdb_7_5-branch:1.44.0.2
	gdb_7_5-2012-07-18-branchpoint:1.44
	sid-snapshot-20120701:1.44
	sid-snapshot-20120601:1.44
	sid-snapshot-20120501:1.43
	binutils-2_22_branch:1.42.0.8
	gdb_7_4_1-2012-04-26-release:1.42
	sid-snapshot-20120401:1.43
	sid-snapshot-20120301:1.42
	sid-snapshot-20120201:1.42
	gdb_7_4-2012-01-24-release:1.42
	sid-snapshot-20120101:1.42
	gdb_7_4-branch:1.42.0.6
	gdb_7_4-2011-12-13-branchpoint:1.42
	sid-snapshot-20111201:1.42
	binutils-2_22:1.42
	sid-snapshot-20111101:1.42
	sid-snapshot-20111001:1.42
	binutils-2_22-branch:1.42.0.4
	binutils-2_22-branchpoint:1.42
	gdb_7_3_1-2011-09-04-release:1.42
	sid-snapshot-20110901:1.42
	sid-snapshot-20110801:1.42
	gdb_7_3-2011-07-26-release:1.42
	sid-snapshot-20110701:1.42
	sid-snapshot-20110601:1.42
	sid-snapshot-20110501:1.42
	gdb_7_3-branch:1.42.0.2
	gdb_7_3-2011-04-01-branchpoint:1.42
	sid-snapshot-20110401:1.42
	sid-snapshot-20110301:1.41
	sid-snapshot-20110201:1.29
	sid-snapshot-20110101:1.29
	binutils-2_21:1.29
	sid-snapshot-20101201:1.29
	binutils-2_21-branch:1.29.0.2
	binutils-2_21-branchpoint:1.29
	sid-snapshot-20101101:1.29
	sid-snapshot-20101001:1.28
	binutils-2_20_1:1.14
	gdb_7_2-2010-09-02-release:1.16
	sid-snapshot-20100901:1.16
	sid-snapshot-20100801:1.16
	gdb_7_2-branch:1.16.0.2
	gdb_7_2-2010-07-07-branchpoint:1.16
	sid-snapshot-20100701:1.16
	sid-snapshot-20100601:1.15
	sid-snapshot-20100501:1.15
	sid-snapshot-20100401:1.15
	gdb_7_1-2010-03-18-release:1.14
	sid-snapshot-20100301:1.14
	gdb_7_1-branch:1.14.0.6
	gdb_7_1-2010-02-18-branchpoint:1.14
	sid-snapshot-20100201:1.14
	sid-snapshot-20100101:1.14
	gdb_7_0_1-2009-12-22-release:1.14
	sid-snapshot-20091201:1.14
	sid-snapshot-20091101:1.14
	binutils-2_20:1.14
	gdb_7_0-2009-10-06-release:1.14
	sid-snapshot-20091001:1.14
	gdb_7_0-branch:1.14.0.4
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.5
	binutils-arc-20081103-branch:1.9.0.12
	binutils-arc-20081103-branchpoint:1.9
	binutils-2_20-branch:1.14.0.2
	binutils-2_20-branchpoint:1.14
	sid-snapshot-20090901:1.10
	sid-snapshot-20090801:1.10
	msnyder-checkpoint-072509-branch:1.10.0.4
	msnyder-checkpoint-072509-branchpoint:1.10
	sid-snapshot-20090701:1.10
	dje-cgen-play1-branch:1.10.0.2
	dje-cgen-play1-branchpoint:1.10
	sid-snapshot-20090601:1.10
	sid-snapshot-20090501:1.10
	sid-snapshot-20090401:1.10
	arc-20081103-branch:1.9.0.10
	arc-20081103-branchpoint:1.9
	arc-insight_6_8-branch:1.5.0.10
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.8
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.10
	binutils-2_19_1:1.9
	sid-snapshot-20090201:1.10
	sid-snapshot-20090101:1.9
	reverse-20081226-branch:1.9.0.8
	reverse-20081226-branchpoint:1.9
	sid-snapshot-20081201:1.9
	multiprocess-20081120-branch:1.9.0.6
	multiprocess-20081120-branchpoint:1.9
	sid-snapshot-20081101:1.9
	binutils-2_19:1.9
	sid-snapshot-20081001:1.9
	reverse-20080930-branch:1.9.0.4
	reverse-20080930-branchpoint:1.9
	binutils-2_19-branch:1.9.0.2
	binutils-2_19-branchpoint:1.9
	sid-snapshot-20080901:1.9
	sid-snapshot-20080801:1.9
	reverse-20080717-branch:1.8.0.4
	reverse-20080717-branchpoint:1.8
	sid-snapshot-20080701:1.8
	msnyder-reverse-20080609-branch:1.8.0.2
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.4.0.18
	drow-reverse-20070409-branchpoint:1.4
	sid-snapshot-20080601:1.8
	sid-snapshot-20080501:1.8
	sid-snapshot-20080403:1.8
	sid-snapshot-20080401:1.8
	gdb_6_8-2008-03-27-release:1.5
	sid-snapshot-20080301:1.5
	gdb_6_8-branch:1.5.0.6
	gdb_6_8-2008-02-26-branchpoint:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	sid-snapshot-20071001:1.5
	gdb_6_7-branch:1.5.0.4
	gdb_6_7-2007-09-07-branchpoint:1.5
	binutils-2_18:1.5
	binutils-2_18-branch:1.5.0.2
	binutils-2_18-branchpoint:1.5
	insight_6_6-20070208-release:1.4
	binutils-csl-coldfire-4_1-32:1.4
	binutils-csl-sourcerygxx-4_1-32:1.4
	gdb_6_6-2006-12-18-release:1.4
	binutils-csl-innovasic-fido-3_4_4-33:1.4
	binutils-csl-coldfire-4_1-30:1.4
	binutils-csl-sourcerygxx-4_1-30:1.4
	binutils-csl-coldfire-4_1-28:1.4
	binutils-csl-sourcerygxx-4_1-29:1.4
	binutils-csl-sourcerygxx-4_1-28:1.4
	gdb_6_6-branch:1.4.0.16
	gdb_6_6-2006-11-15-branchpoint:1.4
	binutils-csl-arm-2006q3-27:1.4
	binutils-csl-sourcerygxx-4_1-27:1.4
	binutils-csl-arm-2006q3-26:1.4
	binutils-csl-sourcerygxx-4_1-26:1.4
	binutils-csl-sourcerygxx-4_1-25:1.4
	binutils-csl-sourcerygxx-4_1-24:1.4
	binutils-csl-sourcerygxx-4_1-23:1.4
	insight_6_5-20061003-release:1.4
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	binutils-csl-sourcerygxx-4_1-21:1.4
	binutils-csl-arm-2006q3-21:1.4
	binutils-csl-sourcerygxx-4_1-22:1.4
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.4
	binutils-csl-sourcerygxx-4_1-20:1.4
	binutils-csl-arm-2006q3-19:1.4
	binutils-csl-sourcerygxx-4_1-19:1.4
	binutils-csl-sourcerygxx-4_1-18:1.4
	binutils-csl-renesas-4_1-9:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.4
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	binutils-csl-renesas-4_1-8:1.4
	binutils-csl-renesas-4_1-7:1.4
	binutils-csl-renesas-4_1-6:1.4
	gdb-csl-sourcerygxx-4_1-17:1.3
	binutils-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	binutils-csl-sourcerygxx-4_1-14:1.4
	binutils-csl-sourcerygxx-4_1-15:1.4
	gdb-csl-sourcerygxx-4_1-13:1.3
	binutils-csl-sourcerygxx-4_1-13:1.4
	binutils-2_17:1.4
	gdb-csl-sourcerygxx-4_1-12:1.3
	binutils-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	binutils-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.4
	gdb-csl-sourcerygxx-4_1-9:1.3
	binutils-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.3
	binutils-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.3
	binutils-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.3
	binutils-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.3
	binutils-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	binutils-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	binutils-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.4.0.14
	gdb_6_5-2006-05-14-branchpoint:1.4
	binutils-csl-coldfire-4_1-10:1.4
	gdb-csl-sourcerygxx-4_1-5:1.3
	binutils-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.4.0.12
	nickrob-async-20060513-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-4:1.3
	binutils-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.4.0.10
	msnyder-reverse-20060502-branchpoint:1.4
	gdb-csl-morpho-4_1-4:1.3
	binutils-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	binutils-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.4.0.8
	readline_5_1-import-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	binutils-2_17-branch:1.4.0.6
	binutils-2_17-branchpoint:1.4
	gdb-csl-symbian-20060226-branch:1.3.0.12
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.4.0.4
	msnyder-reverse-20060331-branchpoint:1.4
	binutils-csl-2_17-branch:1.4.0.2
	binutils-csl-2_17-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.3.0.10
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.8
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.6
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.2
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.2.0.2
	gdb-csl-arm-20051020-branchpoint:1.2
	binutils_latest_snapshot:1.44;
locks; strict;
comment	@ * @;


1.44
date	2012.05.18.01.59.38;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2012.04.01.04.15.43;	author vapier;	state Exp;
branches;
next	1.42;

1.42
date	2011.03.24.05.27.39;	author vapier;	state Exp;
branches;
next	1.41;

1.41
date	2011.02.22.20.52.31;	author vapier;	state Exp;
branches;
next	1.40;

1.40
date	2011.02.22.20.51.42;	author vapier;	state Exp;
branches;
next	1.39;

1.39
date	2011.02.20.01.26.14;	author vapier;	state Exp;
branches;
next	1.38;

1.38
date	2011.02.14.17.12.05;	author vapier;	state Exp;
branches;
next	1.37;

1.37
date	2011.02.14.05.21.04;	author vapier;	state Exp;
branches;
next	1.36;

1.36
date	2011.02.13.18.55.22;	author vapier;	state Exp;
branches;
next	1.35;

1.35
date	2011.02.13.18.54.49;	author vapier;	state Exp;
branches;
next	1.34;

1.34
date	2011.02.13.18.53.14;	author vapier;	state Exp;
branches;
next	1.33;

1.33
date	2011.02.12.19.38.11;	author vapier;	state Exp;
branches;
next	1.32;

1.32
date	2011.02.12.19.37.32;	author vapier;	state Exp;
branches;
next	1.31;

1.31
date	2011.02.12.19.36.31;	author vapier;	state Exp;
branches;
next	1.30;

1.30
date	2011.02.11.19.03.27;	author vapier;	state Exp;
branches;
next	1.29;

1.29
date	2010.10.15.20.44.46;	author vapier;	state Exp;
branches;
next	1.28;

1.28
date	2010.09.22.21.55.17;	author vapier;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.22.21.54.33;	author vapier;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.22.21.53.46;	author vapier;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.22.21.53.14;	author vapier;	state Exp;
branches;
next	1.24;

1.24
date	2010.09.22.21.41.39;	author vapier;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.22.21.39.08;	author vapier;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.22.21.38.20;	author vapier;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.22.21.26.13;	author vapier;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.22.21.05.03;	author vapier;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.22.20.59.00;	author vapier;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.22.20.37.23;	author vapier;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.22.20.32.40;	author vapier;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.27.04.07.55;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2010.03.24.05.16.29;	author vapier;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.04.04.29.42;	author jiez;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.03.17.42.53;	author jiez;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.03.16.17.36;	author jiez;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.02.07.20.29;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.14.19.35.12;	author vapier;	state Exp;
branches;
next	1.9;

1.9
date	2008.07.30.04.34.58;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.26.16.48.32;	author bernds;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.26.16.21.10;	author bernds;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.26.14.50.52;	author bernds;	state Exp;
branches;
next	1.5;

1.5
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.16.19.09.48;	author bernds;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.21.16.28.18;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.18.16.39.41;	author jiez;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.30.15.28.50;	author clm;	state Exp;
branches;
next	;


desc
@@


1.44
log
@	* arc-dis.c: Include sysdep.h first, remove some redundant includes.
	* bfin-dis.c: Likewise.
	* i860-dis.c: Likewise.
	* ia64-dis.c: Likewise.
	* ia64-gen.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* mmix-dis.c: Likewise.
	* msp430-dis.c: Likewise.
	* or32-dis.c: Likewise.
	* rl78-dis.c: Likewise.
	* rx-dis.c: Likewise.
	* tic4x-dis.c: Likewise.
	* tilegx-opc.c: Likewise.
	* tilepro-opc.c: Likewise.
	* rx-decode.c: Regenerate.
@
text
@/* Disassemble ADI Blackfin Instructions.
   Copyright 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of libopcodes.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdio.h>

#include "opcode/bfin.h"

#ifndef PRINTF
#define PRINTF printf
#endif

#ifndef EXIT
#define EXIT exit
#endif

typedef long TIword;

#define HOST_LONG_WORD_SIZE (sizeof (long) * 8)
#define XFIELD(w,p,s)       (((w) & ((1 << (s)) - 1) << (p)) >> (p))
#define SIGNEXTEND(v, n)    ((v << (HOST_LONG_WORD_SIZE - (n))) >> (HOST_LONG_WORD_SIZE - (n)))
#define MASKBITS(val, bits) (val & ((1 << bits) - 1))

#include "dis-asm.h"

typedef unsigned int bu32;

static char comment = 0;
static char parallel = 0;

typedef enum
{
  c_0, c_1, c_4, c_2, c_uimm2, c_uimm3, c_imm3, c_pcrel4,
  c_imm4, c_uimm4s4, c_uimm4s4d, c_uimm4, c_uimm4s2, c_negimm5s4, c_imm5, c_imm5d, c_uimm5, c_imm6,
  c_imm7, c_imm7d, c_imm8, c_uimm8, c_pcrel8, c_uimm8s4, c_pcrel8s4, c_lppcrel10, c_pcrel10,
  c_pcrel12, c_imm16s4, c_luimm16, c_imm16, c_imm16d, c_huimm16, c_rimm16, c_imm16s2, c_uimm16s4,
  c_uimm16s4d, c_uimm16, c_pcrel24, c_uimm32, c_imm32, c_huimm32, c_huimm32e,
} const_forms_t;

static const struct
{
  const char *name;
  const int nbits;
  const char reloc;
  const char issigned;
  const char pcrel;
  const char scale;
  const char offset;
  const char negative;
  const char positive;
  const char decimal;
  const char leading;
  const char exact;
} constant_formats[] =
{
  { "0",          0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "1",          0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "4",          0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "2",          0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "uimm2",      2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { "uimm3",      3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { "imm3",       3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "pcrel4",     4, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0},
  { "imm4",       4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "uimm4s4",    4, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0},
  { "uimm4s4d",   4, 0, 0, 0, 2, 0, 0, 1, 1, 0, 0},
  { "uimm4",      4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { "uimm4s2",    4, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
  { "negimm5s4",  5, 0, 1, 0, 2, 0, 1, 0, 0, 0, 0},
  { "imm5",       5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "imm5d",      5, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0},
  { "uimm5",      5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { "imm6",       6, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "imm7",       7, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "imm7d",      7, 0, 1, 0, 0, 0, 0, 0, 1, 3, 0},
  { "imm8",       8, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "uimm8",      8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { "pcrel8",     8, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0},
  { "uimm8s4",    8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0},
  { "pcrel8s4",   8, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0},
  { "lppcrel10", 10, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0},
  { "pcrel10",   10, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
  { "pcrel12",   12, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
  { "imm16s4",   16, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0},
  { "luimm16",   16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { "imm16",     16, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "imm16d",    16, 0, 1, 0, 0, 0, 0, 0, 1, 3, 0},
  { "huimm16",   16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { "rimm16",    16, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
  { "imm16s2",   16, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0},
  { "uimm16s4",  16, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0},
  { "uimm16s4d", 16, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0},
  { "uimm16",    16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { "pcrel24",   24, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
  { "uimm32",    32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { "imm32",     32, 0, 1, 0, 0, 0, 0, 0, 1, 3, 0},
  { "huimm32",   32, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { "huimm32e",  32, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
};

static const char *
fmtconst (const_forms_t cf, TIword x, bfd_vma pc, disassemble_info *outf)
{
  static char buf[60];

  if (constant_formats[cf].reloc)
    {
      bfd_vma ea = (((constant_formats[cf].pcrel ? SIGNEXTEND (x, constant_formats[cf].nbits)
		      : x) + constant_formats[cf].offset) << constant_formats[cf].scale);
      if (constant_formats[cf].pcrel)
	ea += pc;

      /* truncate to 32-bits for proper symbol lookup/matching */
      ea = (bu32)ea;

      if (outf->symbol_at_address_func (ea, outf) || !constant_formats[cf].exact)
	{
	  outf->print_address_func (ea, outf);
	  return "";
	}
      else
	{
	  sprintf (buf, "%lx", (unsigned long) x);
	  return buf;
	}
    }

  /* Negative constants have an implied sign bit.  */
  if (constant_formats[cf].negative)
    {
      int nb = constant_formats[cf].nbits + 1;

      x = x | (1 << constant_formats[cf].nbits);
      x = SIGNEXTEND (x, nb);
    }
  else
    x = constant_formats[cf].issigned ? SIGNEXTEND (x, constant_formats[cf].nbits) : x;

  if (constant_formats[cf].offset)
    x += constant_formats[cf].offset;

  if (constant_formats[cf].scale)
    x <<= constant_formats[cf].scale;

  if (constant_formats[cf].decimal)
    sprintf (buf, "%*li", constant_formats[cf].leading, x);
  else
    {
      if (constant_formats[cf].issigned && x < 0)
	sprintf (buf, "-0x%x", abs (x));
      else
	sprintf (buf, "0x%lx", (unsigned long) x);
    }

  return buf;
}

static bu32
fmtconst_val (const_forms_t cf, unsigned int x, unsigned int pc)
{
  if (0 && constant_formats[cf].reloc)
    {
      bu32 ea = (((constant_formats[cf].pcrel
		   ? SIGNEXTEND (x, constant_formats[cf].nbits)
		   : x) + constant_formats[cf].offset)
		 << constant_formats[cf].scale);
      if (constant_formats[cf].pcrel)
	ea += pc;

      return ea;
    }

  /* Negative constants have an implied sign bit.  */
  if (constant_formats[cf].negative)
    {
      int nb = constant_formats[cf].nbits + 1;
      x = x | (1 << constant_formats[cf].nbits);
      x = SIGNEXTEND (x, nb);
    }
  else if (constant_formats[cf].issigned)
    x = SIGNEXTEND (x, constant_formats[cf].nbits);

  x += constant_formats[cf].offset;
  x <<= constant_formats[cf].scale;

  return x;
}

enum machine_registers
{
  REG_RL0, REG_RL1, REG_RL2, REG_RL3, REG_RL4, REG_RL5, REG_RL6, REG_RL7,
  REG_RH0, REG_RH1, REG_RH2, REG_RH3, REG_RH4, REG_RH5, REG_RH6, REG_RH7,
  REG_R0, REG_R1, REG_R2, REG_R3, REG_R4, REG_R5, REG_R6, REG_R7,
  REG_R1_0, REG_R3_2, REG_R5_4, REG_R7_6, REG_P0, REG_P1, REG_P2, REG_P3,
  REG_P4, REG_P5, REG_SP, REG_FP, REG_A0x, REG_A1x, REG_A0w, REG_A1w,
  REG_A0, REG_A1, REG_I0, REG_I1, REG_I2, REG_I3, REG_M0, REG_M1,
  REG_M2, REG_M3, REG_B0, REG_B1, REG_B2, REG_B3, REG_L0, REG_L1,
  REG_L2, REG_L3,
  REG_AZ, REG_AN, REG_AC0, REG_AC1, REG_AV0, REG_AV1, REG_AV0S, REG_AV1S,
  REG_AQ, REG_V, REG_VS,
  REG_sftreset, REG_omode, REG_excause, REG_emucause, REG_idle_req, REG_hwerrcause, REG_CC, REG_LC0,
  REG_LC1, REG_ASTAT, REG_RETS, REG_LT0, REG_LB0, REG_LT1, REG_LB1,
  REG_CYCLES, REG_CYCLES2, REG_USP, REG_SEQSTAT, REG_SYSCFG, REG_RETI, REG_RETX, REG_RETN,
  REG_RETE, REG_EMUDAT, REG_BR0, REG_BR1, REG_BR2, REG_BR3, REG_BR4, REG_BR5, REG_BR6,
  REG_BR7, REG_PL0, REG_PL1, REG_PL2, REG_PL3, REG_PL4, REG_PL5, REG_SLP, REG_FLP,
  REG_PH0, REG_PH1, REG_PH2, REG_PH3, REG_PH4, REG_PH5, REG_SHP, REG_FHP,
  REG_IL0, REG_IL1, REG_IL2, REG_IL3, REG_ML0, REG_ML1, REG_ML2, REG_ML3,
  REG_BL0, REG_BL1, REG_BL2, REG_BL3, REG_LL0, REG_LL1, REG_LL2, REG_LL3,
  REG_IH0, REG_IH1, REG_IH2, REG_IH3, REG_MH0, REG_MH1, REG_MH2, REG_MH3,
  REG_BH0, REG_BH1, REG_BH2, REG_BH3, REG_LH0, REG_LH1, REG_LH2, REG_LH3,
  REG_AC0_COPY, REG_V_COPY, REG_RND_MOD,
  REG_LASTREG,
};

enum reg_class
{
  rc_dregs_lo, rc_dregs_hi, rc_dregs, rc_dregs_pair, rc_pregs, rc_spfp, rc_dregs_hilo, rc_accum_ext,
  rc_accum_word, rc_accum, rc_iregs, rc_mregs, rc_bregs, rc_lregs, rc_dpregs, rc_gregs,
  rc_regs, rc_statbits, rc_ignore_bits, rc_ccstat, rc_counters, rc_dregs2_sysregs1, rc_open, rc_sysregs2,
  rc_sysregs3, rc_allregs,
  LIM_REG_CLASSES
};

static const char * const reg_names[] =
{
  "R0.L", "R1.L", "R2.L", "R3.L", "R4.L", "R5.L", "R6.L", "R7.L",
  "R0.H", "R1.H", "R2.H", "R3.H", "R4.H", "R5.H", "R6.H", "R7.H",
  "R0", "R1", "R2", "R3", "R4", "R5", "R6", "R7",
  "R1:0", "R3:2", "R5:4", "R7:6", "P0", "P1", "P2", "P3",
  "P4", "P5", "SP", "FP", "A0.X", "A1.X", "A0.W", "A1.W",
  "A0", "A1", "I0", "I1", "I2", "I3", "M0", "M1",
  "M2", "M3", "B0", "B1", "B2", "B3", "L0", "L1",
  "L2", "L3",
  "AZ", "AN", "AC0", "AC1", "AV0", "AV1", "AV0S", "AV1S",
  "AQ", "V", "VS",
  "sftreset", "omode", "excause", "emucause", "idle_req", "hwerrcause", "CC", "LC0",
  "LC1", "ASTAT", "RETS", "LT0", "LB0", "LT1", "LB1",
  "CYCLES", "CYCLES2", "USP", "SEQSTAT", "SYSCFG", "RETI", "RETX", "RETN",
  "RETE", "EMUDAT",
  "R0.B", "R1.B", "R2.B", "R3.B", "R4.B", "R5.B", "R6.B", "R7.B",
  "P0.L", "P1.L", "P2.L", "P3.L", "P4.L", "P5.L", "SP.L", "FP.L",
  "P0.H", "P1.H", "P2.H", "P3.H", "P4.H", "P5.H", "SP.H", "FP.H",
  "I0.L", "I1.L", "I2.L", "I3.L", "M0.L", "M1.L", "M2.L", "M3.L",
  "B0.L", "B1.L", "B2.L", "B3.L", "L0.L", "L1.L", "L2.L", "L3.L",
  "I0.H", "I1.H", "I2.H", "I3.H", "M0.H", "M1.H", "M2.H", "M3.H",
  "B0.H", "B1.H", "B2.H", "B3.H", "L0.H", "L1.H", "L2.H", "L3.H",
  "AC0_COPY", "V_COPY", "RND_MOD",
  "LASTREG",
  0
};

#define REGNAME(x) ((x) < REG_LASTREG ? (reg_names[x]) : "...... Illegal register .......")

/* RL(0..7).  */
static const enum machine_registers decode_dregs_lo[] =
{
  REG_RL0, REG_RL1, REG_RL2, REG_RL3, REG_RL4, REG_RL5, REG_RL6, REG_RL7,
};

#define dregs_lo(x) REGNAME (decode_dregs_lo[(x) & 7])

/* RH(0..7).  */
static const enum machine_registers decode_dregs_hi[] =
{
  REG_RH0, REG_RH1, REG_RH2, REG_RH3, REG_RH4, REG_RH5, REG_RH6, REG_RH7,
};

#define dregs_hi(x) REGNAME (decode_dregs_hi[(x) & 7])

/* R(0..7).  */
static const enum machine_registers decode_dregs[] =
{
  REG_R0, REG_R1, REG_R2, REG_R3, REG_R4, REG_R5, REG_R6, REG_R7,
};

#define dregs(x) REGNAME (decode_dregs[(x) & 7])

/* R BYTE(0..7).  */
static const enum machine_registers decode_dregs_byte[] =
{
  REG_BR0, REG_BR1, REG_BR2, REG_BR3, REG_BR4, REG_BR5, REG_BR6, REG_BR7,
};

#define dregs_byte(x) REGNAME (decode_dregs_byte[(x) & 7])

/* P(0..5) SP FP.  */
static const enum machine_registers decode_pregs[] =
{
  REG_P0, REG_P1, REG_P2, REG_P3, REG_P4, REG_P5, REG_SP, REG_FP,
};

#define pregs(x)	REGNAME (decode_pregs[(x) & 7])
#define spfp(x)		REGNAME (decode_spfp[(x) & 1])
#define dregs_hilo(x, i)	REGNAME (decode_dregs_hilo[((i) << 3) | (x)])
#define accum_ext(x)	REGNAME (decode_accum_ext[(x) & 1])
#define accum_word(x)	REGNAME (decode_accum_word[(x) & 1])
#define accum(x)	REGNAME (decode_accum[(x) & 1])

/* I(0..3).  */
static const enum machine_registers decode_iregs[] =
{
  REG_I0, REG_I1, REG_I2, REG_I3,
};

#define iregs(x) REGNAME (decode_iregs[(x) & 3])

/* M(0..3).  */
static const enum machine_registers decode_mregs[] =
{
  REG_M0, REG_M1, REG_M2, REG_M3,
};

#define mregs(x) REGNAME (decode_mregs[(x) & 3])
#define bregs(x) REGNAME (decode_bregs[(x) & 3])
#define lregs(x) REGNAME (decode_lregs[(x) & 3])

/* dregs pregs.  */
static const enum machine_registers decode_dpregs[] =
{
  REG_R0, REG_R1, REG_R2, REG_R3, REG_R4, REG_R5, REG_R6, REG_R7,
  REG_P0, REG_P1, REG_P2, REG_P3, REG_P4, REG_P5, REG_SP, REG_FP,
};

#define dpregs(x) REGNAME (decode_dpregs[(x) & 15])

/* [dregs pregs].  */
static const enum machine_registers decode_gregs[] =
{
  REG_R0, REG_R1, REG_R2, REG_R3, REG_R4, REG_R5, REG_R6, REG_R7,
  REG_P0, REG_P1, REG_P2, REG_P3, REG_P4, REG_P5, REG_SP, REG_FP,
};

#define gregs(x, i) REGNAME (decode_gregs[((i) << 3) | (x)])

/* [dregs pregs (iregs mregs) (bregs lregs)].  */
static const enum machine_registers decode_regs[] =
{
  REG_R0, REG_R1, REG_R2, REG_R3, REG_R4, REG_R5, REG_R6, REG_R7,
  REG_P0, REG_P1, REG_P2, REG_P3, REG_P4, REG_P5, REG_SP, REG_FP,
  REG_I0, REG_I1, REG_I2, REG_I3, REG_M0, REG_M1, REG_M2, REG_M3,
  REG_B0, REG_B1, REG_B2, REG_B3, REG_L0, REG_L1, REG_L2, REG_L3,
};

#define regs(x, i) REGNAME (decode_regs[((i) << 3) | (x)])

/* [dregs pregs (iregs mregs) (bregs lregs) Low Half].  */
static const enum machine_registers decode_regs_lo[] =
{
  REG_RL0, REG_RL1, REG_RL2, REG_RL3, REG_RL4, REG_RL5, REG_RL6, REG_RL7,
  REG_PL0, REG_PL1, REG_PL2, REG_PL3, REG_PL4, REG_PL5, REG_SLP, REG_FLP,
  REG_IL0, REG_IL1, REG_IL2, REG_IL3, REG_ML0, REG_ML1, REG_ML2, REG_ML3,
  REG_BL0, REG_BL1, REG_BL2, REG_BL3, REG_LL0, REG_LL1, REG_LL2, REG_LL3,
};

#define regs_lo(x, i) REGNAME (decode_regs_lo[((i) << 3) | (x)])

/* [dregs pregs (iregs mregs) (bregs lregs) High Half].  */
static const enum machine_registers decode_regs_hi[] =
{
  REG_RH0, REG_RH1, REG_RH2, REG_RH3, REG_RH4, REG_RH5, REG_RH6, REG_RH7,
  REG_PH0, REG_PH1, REG_PH2, REG_PH3, REG_PH4, REG_PH5, REG_SHP, REG_FHP,
  REG_IH0, REG_IH1, REG_IH2, REG_IH3, REG_MH0, REG_MH1, REG_MH2, REG_MH3,
  REG_BH0, REG_BH1, REG_BH2, REG_BH3, REG_LH0, REG_LH1, REG_LH2, REG_LH3,
};

#define regs_hi(x, i) REGNAME (decode_regs_hi[((i) << 3) | (x)])

static const enum machine_registers decode_statbits[] =
{
  REG_AZ,        REG_AN,        REG_AC0_COPY,    REG_V_COPY,
  REG_LASTREG,   REG_LASTREG,   REG_AQ,          REG_LASTREG,
  REG_RND_MOD,   REG_LASTREG,   REG_LASTREG,     REG_LASTREG,
  REG_AC0,       REG_AC1,       REG_LASTREG,     REG_LASTREG,
  REG_AV0,       REG_AV0S,      REG_AV1,         REG_AV1S,
  REG_LASTREG,   REG_LASTREG,   REG_LASTREG,     REG_LASTREG,
  REG_V,         REG_VS,        REG_LASTREG,     REG_LASTREG,
  REG_LASTREG,   REG_LASTREG,   REG_LASTREG,     REG_LASTREG,
};

#define statbits(x) REGNAME (decode_statbits[(x) & 31])

/* LC0 LC1.  */
static const enum machine_registers decode_counters[] =
{
  REG_LC0, REG_LC1,
};

#define counters(x)        REGNAME (decode_counters[(x) & 1])
#define dregs2_sysregs1(x) REGNAME (decode_dregs2_sysregs1[(x) & 7])

/* [dregs pregs (iregs mregs) (bregs lregs)
   dregs2_sysregs1 open sysregs2 sysregs3].  */
static const enum machine_registers decode_allregs[] =
{
  REG_R0, REG_R1, REG_R2, REG_R3, REG_R4, REG_R5, REG_R6, REG_R7,
  REG_P0, REG_P1, REG_P2, REG_P3, REG_P4, REG_P5, REG_SP, REG_FP,
  REG_I0, REG_I1, REG_I2, REG_I3, REG_M0, REG_M1, REG_M2, REG_M3,
  REG_B0, REG_B1, REG_B2, REG_B3, REG_L0, REG_L1, REG_L2, REG_L3,
  REG_A0x, REG_A0w, REG_A1x, REG_A1w, REG_LASTREG, REG_LASTREG, REG_ASTAT, REG_RETS,
  REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG,
  REG_LC0, REG_LT0, REG_LB0, REG_LC1, REG_LT1, REG_LB1, REG_CYCLES, REG_CYCLES2,
  REG_USP, REG_SEQSTAT, REG_SYSCFG, REG_RETI, REG_RETX, REG_RETN, REG_RETE, REG_EMUDAT,
  REG_LASTREG,
};

#define IS_DREG(g,r)	((g) == 0 && (r) < 8)
#define IS_PREG(g,r)	((g) == 1 && (r) < 8)
#define IS_AREG(g,r)	((g) == 4 && (r) >= 0 && (r) < 4)
#define IS_GENREG(g,r)	((((g) == 0 || (g) == 1) && (r) < 8) || IS_AREG (g, r))
#define IS_DAGREG(g,r)	(((g) == 2 || (g) == 3) && (r) < 8)
#define IS_SYSREG(g,r) \
  (((g) == 4 && ((r) == 6 || (r) == 7)) || (g) == 6 || (g) == 7)
#define IS_RESERVEDREG(g,r) \
  (((r) > 7) || ((g) == 4 && ((r) == 4 || (r) == 5)) || (g) == 5)

#define allreg(r,g)	(!IS_RESERVEDREG (g, r))
#define mostreg(r,g)	(!(IS_DREG (g, r) || IS_PREG (g, r) || IS_RESERVEDREG (g, r)))

#define allregs(x, i)	REGNAME (decode_allregs[((i) << 3) | (x)])
#define uimm16s4(x)	fmtconst (c_uimm16s4, x, 0, outf)
#define uimm16s4d(x)	fmtconst (c_uimm16s4d, x, 0, outf)
#define pcrel4(x)	fmtconst (c_pcrel4, x, pc, outf)
#define pcrel8(x)	fmtconst (c_pcrel8, x, pc, outf)
#define pcrel8s4(x)	fmtconst (c_pcrel8s4, x, pc, outf)
#define pcrel10(x)	fmtconst (c_pcrel10, x, pc, outf)
#define pcrel12(x)	fmtconst (c_pcrel12, x, pc, outf)
#define negimm5s4(x)	fmtconst (c_negimm5s4, x, 0, outf)
#define rimm16(x)	fmtconst (c_rimm16, x, 0, outf)
#define huimm16(x)	fmtconst (c_huimm16, x, 0, outf)
#define imm16(x)	fmtconst (c_imm16, x, 0, outf)
#define imm16d(x)	fmtconst (c_imm16d, x, 0, outf)
#define uimm2(x)	fmtconst (c_uimm2, x, 0, outf)
#define uimm3(x)	fmtconst (c_uimm3, x, 0, outf)
#define luimm16(x)	fmtconst (c_luimm16, x, 0, outf)
#define uimm4(x)	fmtconst (c_uimm4, x, 0, outf)
#define uimm5(x)	fmtconst (c_uimm5, x, 0, outf)
#define imm16s2(x)	fmtconst (c_imm16s2, x, 0, outf)
#define uimm8(x)	fmtconst (c_uimm8, x, 0, outf)
#define imm16s4(x)	fmtconst (c_imm16s4, x, 0, outf)
#define uimm4s2(x)	fmtconst (c_uimm4s2, x, 0, outf)
#define uimm4s4(x)	fmtconst (c_uimm4s4, x, 0, outf)
#define uimm4s4d(x)	fmtconst (c_uimm4s4d, x, 0, outf)
#define lppcrel10(x)	fmtconst (c_lppcrel10, x, pc, outf)
#define imm3(x)		fmtconst (c_imm3, x, 0, outf)
#define imm4(x)		fmtconst (c_imm4, x, 0, outf)
#define uimm8s4(x)	fmtconst (c_uimm8s4, x, 0, outf)
#define imm5(x)		fmtconst (c_imm5, x, 0, outf)
#define imm5d(x)	fmtconst (c_imm5d, x, 0, outf)
#define imm6(x)		fmtconst (c_imm6, x, 0, outf)
#define imm7(x)		fmtconst (c_imm7, x, 0, outf)
#define imm7d(x)	fmtconst (c_imm7d, x, 0, outf)
#define imm8(x)		fmtconst (c_imm8, x, 0, outf)
#define pcrel24(x)	fmtconst (c_pcrel24, x, pc, outf)
#define uimm16(x)	fmtconst (c_uimm16, x, 0, outf)
#define uimm32(x)	fmtconst (c_uimm32, x, 0, outf)
#define imm32(x)	fmtconst (c_imm32, x, 0, outf)
#define huimm32(x)	fmtconst (c_huimm32, x, 0, outf)
#define huimm32e(x)	fmtconst (c_huimm32e, x, 0, outf)
#define imm7_val(x)	fmtconst_val (c_imm7, x, 0)
#define imm16_val(x)	fmtconst_val (c_uimm16, x, 0)
#define luimm16_val(x)	fmtconst_val (c_luimm16, x, 0)

/* (arch.pm)arch_disassembler_functions.  */
#ifndef OUTS
#define OUTS(p, txt) (p)->fprintf_func ((p)->stream, "%s", txt)
#endif

static void
amod0 (int s0, int x0, disassemble_info *outf)
{
  if (s0 == 1 && x0 == 0)
    OUTS (outf, " (S)");
  else if (s0 == 0 && x0 == 1)
    OUTS (outf, " (CO)");
  else if (s0 == 1 && x0 == 1)
    OUTS (outf, " (SCO)");
}

static void
amod1 (int s0, int x0, disassemble_info *outf)
{
  if (s0 == 0 && x0 == 0)
    OUTS (outf, " (NS)");
  else if (s0 == 1 && x0 == 0)
    OUTS (outf, " (S)");
}

static void
amod0amod2 (int s0, int x0, int aop0, disassemble_info *outf)
{
  if (s0 == 1 && x0 == 0 && aop0 == 0)
    OUTS (outf, " (S)");
  else if (s0 == 0 && x0 == 1 && aop0 == 0)
    OUTS (outf, " (CO)");
  else if (s0 == 1 && x0 == 1 && aop0 == 0)
    OUTS (outf, " (SCO)");
  else if (s0 == 0 && x0 == 0 && aop0 == 2)
    OUTS (outf, " (ASR)");
  else if (s0 == 1 && x0 == 0 && aop0 == 2)
    OUTS (outf, " (S, ASR)");
  else if (s0 == 0 && x0 == 1 && aop0 == 2)
    OUTS (outf, " (CO, ASR)");
  else if (s0 == 1 && x0 == 1 && aop0 == 2)
    OUTS (outf, " (SCO, ASR)");
  else if (s0 == 0 && x0 == 0 && aop0 == 3)
    OUTS (outf, " (ASL)");
  else if (s0 == 1 && x0 == 0 && aop0 == 3)
    OUTS (outf, " (S, ASL)");
  else if (s0 == 0 && x0 == 1 && aop0 == 3)
    OUTS (outf, " (CO, ASL)");
  else if (s0 == 1 && x0 == 1 && aop0 == 3)
    OUTS (outf, " (SCO, ASL)");
}

static void
searchmod (int r0, disassemble_info *outf)
{
  if (r0 == 0)
    OUTS (outf, "GT");
  else if (r0 == 1)
    OUTS (outf, "GE");
  else if (r0 == 2)
    OUTS (outf, "LT");
  else if (r0 == 3)
    OUTS (outf, "LE");
}

static void
aligndir (int r0, disassemble_info *outf)
{
  if (r0 == 1)
    OUTS (outf, " (R)");
}

static int
decode_multfunc (int h0, int h1, int src0, int src1, disassemble_info *outf)
{
  const char *s0, *s1;

  if (h0)
    s0 = dregs_hi (src0);
  else
    s0 = dregs_lo (src0);

  if (h1)
    s1 = dregs_hi (src1);
  else
    s1 = dregs_lo (src1);

  OUTS (outf, s0);
  OUTS (outf, " * ");
  OUTS (outf, s1);
  return 0;
}

static int
decode_macfunc (int which, int op, int h0, int h1, int src0, int src1, disassemble_info *outf)
{
  const char *a;
  const char *sop = "<unknown op>";

  if (which)
    a = "A1";
  else
    a = "A0";

  if (op == 3)
    {
      OUTS (outf, a);
      return 0;
    }

  switch (op)
    {
    case 0: sop = " = ";   break;
    case 1: sop = " += ";  break;
    case 2: sop = " -= ";  break;
    default: break;
    }

  OUTS (outf, a);
  OUTS (outf, sop);
  decode_multfunc (h0, h1, src0, src1, outf);

  return 0;
}

static void
decode_optmode (int mod, int MM, disassemble_info *outf)
{
  if (mod == 0 && MM == 0)
    return;

  OUTS (outf, " (");

  if (MM && !mod)
    {
      OUTS (outf, "M)");
      return;
    }

  if (MM)
    OUTS (outf, "M, ");

  if (mod == M_S2RND)
    OUTS (outf, "S2RND");
  else if (mod == M_T)
    OUTS (outf, "T");
  else if (mod == M_W32)
    OUTS (outf, "W32");
  else if (mod == M_FU)
    OUTS (outf, "FU");
  else if (mod == M_TFU)
    OUTS (outf, "TFU");
  else if (mod == M_IS)
    OUTS (outf, "IS");
  else if (mod == M_ISS2)
    OUTS (outf, "ISS2");
  else if (mod == M_IH)
    OUTS (outf, "IH");
  else if (mod == M_IU)
    OUTS (outf, "IU");
  else
    abort ();

  OUTS (outf, ")");
}

static struct saved_state
{
  bu32 dpregs[16], iregs[4], mregs[4], bregs[4], lregs[4];
  bu32 ax[2], aw[2];
  bu32 lt[2], lc[2], lb[2];
  bu32 rets;
} saved_state;

#define DREG(x)         (saved_state.dpregs[x])
#define GREG(x, i)      DPREG ((x) | ((i) << 3))
#define DPREG(x)        (saved_state.dpregs[x])
#define DREG(x)         (saved_state.dpregs[x])
#define PREG(x)         (saved_state.dpregs[(x) + 8])
#define SPREG           PREG (6)
#define FPREG           PREG (7)
#define IREG(x)         (saved_state.iregs[x])
#define MREG(x)         (saved_state.mregs[x])
#define BREG(x)         (saved_state.bregs[x])
#define LREG(x)         (saved_state.lregs[x])
#define AXREG(x)        (saved_state.ax[x])
#define AWREG(x)        (saved_state.aw[x])
#define LCREG(x)        (saved_state.lc[x])
#define LTREG(x)        (saved_state.lt[x])
#define LBREG(x)        (saved_state.lb[x])
#define RETSREG         (saved_state.rets)

static bu32 *
get_allreg (int grp, int reg)
{
  int fullreg = (grp << 3) | reg;
  /* REG_R0, REG_R1, REG_R2, REG_R3, REG_R4, REG_R5, REG_R6, REG_R7,
     REG_P0, REG_P1, REG_P2, REG_P3, REG_P4, REG_P5, REG_SP, REG_FP,
     REG_I0, REG_I1, REG_I2, REG_I3, REG_M0, REG_M1, REG_M2, REG_M3,
     REG_B0, REG_B1, REG_B2, REG_B3, REG_L0, REG_L1, REG_L2, REG_L3,
     REG_A0x, REG_A0w, REG_A1x, REG_A1w, , , REG_ASTAT, REG_RETS,
     , , , , , , , ,
     REG_LC0, REG_LT0, REG_LB0, REG_LC1, REG_LT1, REG_LB1, REG_CYCLES,
     REG_CYCLES2,
     REG_USP, REG_SEQSTAT, REG_SYSCFG, REG_RETI, REG_RETX, REG_RETN, REG_RETE,
     REG_LASTREG */
  switch (fullreg >> 2)
    {
    case 0: case 1: return &DREG (reg);
    case 2: case 3: return &PREG (reg);
    case 4: return &IREG (reg & 3);
    case 5: return &MREG (reg & 3);
    case 6: return &BREG (reg & 3);
    case 7: return &LREG (reg & 3);
    default:
      switch (fullreg)
	{
	case 32: return &AXREG (0);
	case 33: return &AWREG (0);
	case 34: return &AXREG (1);
	case 35: return &AWREG (1);
	case 39: return &RETSREG;
	case 48: return &LCREG (0);
	case 49: return &LTREG (0);
	case 50: return &LBREG (0);
	case 51: return &LCREG (1);
	case 52: return &LTREG (1);
	case 53: return &LBREG (1);
	}
    }
  abort ();
}

static int
decode_ProgCtrl_0 (TIword iw0, disassemble_info *outf)
{
  /* ProgCtrl
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |.prgfunc.......|.poprnd........|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int poprnd  = ((iw0 >> ProgCtrl_poprnd_bits) & ProgCtrl_poprnd_mask);
  int prgfunc = ((iw0 >> ProgCtrl_prgfunc_bits) & ProgCtrl_prgfunc_mask);

  if (prgfunc == 0 && poprnd == 0)
    OUTS (outf, "NOP");
  else if (parallel)
    return 0;
  else if (prgfunc == 1 && poprnd == 0)
    OUTS (outf, "RTS");
  else if (prgfunc == 1 && poprnd == 1)
    OUTS (outf, "RTI");
  else if (prgfunc == 1 && poprnd == 2)
    OUTS (outf, "RTX");
  else if (prgfunc == 1 && poprnd == 3)
    OUTS (outf, "RTN");
  else if (prgfunc == 1 && poprnd == 4)
    OUTS (outf, "RTE");
  else if (prgfunc == 2 && poprnd == 0)
    OUTS (outf, "IDLE");
  else if (prgfunc == 2 && poprnd == 3)
    OUTS (outf, "CSYNC");
  else if (prgfunc == 2 && poprnd == 4)
    OUTS (outf, "SSYNC");
  else if (prgfunc == 2 && poprnd == 5)
    OUTS (outf, "EMUEXCPT");
  else if (prgfunc == 3 && IS_DREG (0, poprnd))
    {
      OUTS (outf, "CLI ");
      OUTS (outf, dregs (poprnd));
    }
  else if (prgfunc == 4 && IS_DREG (0, poprnd))
    {
      OUTS (outf, "STI ");
      OUTS (outf, dregs (poprnd));
    }
  else if (prgfunc == 5 && IS_PREG (1, poprnd))
    {
      OUTS (outf, "JUMP (");
      OUTS (outf, pregs (poprnd));
      OUTS (outf, ")");
    }
  else if (prgfunc == 6 && IS_PREG (1, poprnd))
    {
      OUTS (outf, "CALL (");
      OUTS (outf, pregs (poprnd));
      OUTS (outf, ")");
    }
  else if (prgfunc == 7 && IS_PREG (1, poprnd))
    {
      OUTS (outf, "CALL (PC + ");
      OUTS (outf, pregs (poprnd));
      OUTS (outf, ")");
    }
  else if (prgfunc == 8 && IS_PREG (1, poprnd))
    {
      OUTS (outf, "JUMP (PC + ");
      OUTS (outf, pregs (poprnd));
      OUTS (outf, ")");
    }
  else if (prgfunc == 9)
    {
      OUTS (outf, "RAISE ");
      OUTS (outf, uimm4 (poprnd));
    }
  else if (prgfunc == 10)
    {
      OUTS (outf, "EXCPT ");
      OUTS (outf, uimm4 (poprnd));
    }
  else if (prgfunc == 11 && IS_PREG (1, poprnd) && poprnd <= 5)
    {
      OUTS (outf, "TESTSET (");
      OUTS (outf, pregs (poprnd));
      OUTS (outf, ")");
    }
  else
    return 0;
  return 2;
}

static int
decode_CaCTRL_0 (TIword iw0, disassemble_info *outf)
{
  /* CaCTRL
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |.a.|.op....|.reg.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int a   = ((iw0 >> CaCTRL_a_bits) & CaCTRL_a_mask);
  int op  = ((iw0 >> CaCTRL_op_bits) & CaCTRL_op_mask);
  int reg = ((iw0 >> CaCTRL_reg_bits) & CaCTRL_reg_mask);

  if (parallel)
    return 0;

  if (a == 0 && op == 0)
    {
      OUTS (outf, "PREFETCH[");
      OUTS (outf, pregs (reg));
      OUTS (outf, "]");
    }
  else if (a == 0 && op == 1)
    {
      OUTS (outf, "FLUSHINV[");
      OUTS (outf, pregs (reg));
      OUTS (outf, "]");
    }
  else if (a == 0 && op == 2)
    {
      OUTS (outf, "FLUSH[");
      OUTS (outf, pregs (reg));
      OUTS (outf, "]");
    }
  else if (a == 0 && op == 3)
    {
      OUTS (outf, "IFLUSH[");
      OUTS (outf, pregs (reg));
      OUTS (outf, "]");
    }
  else if (a == 1 && op == 0)
    {
      OUTS (outf, "PREFETCH[");
      OUTS (outf, pregs (reg));
      OUTS (outf, "++]");
    }
  else if (a == 1 && op == 1)
    {
      OUTS (outf, "FLUSHINV[");
      OUTS (outf, pregs (reg));
      OUTS (outf, "++]");
    }
  else if (a == 1 && op == 2)
    {
      OUTS (outf, "FLUSH[");
      OUTS (outf, pregs (reg));
      OUTS (outf, "++]");
    }
  else if (a == 1 && op == 3)
    {
      OUTS (outf, "IFLUSH[");
      OUTS (outf, pregs (reg));
      OUTS (outf, "++]");
    }
  else
    return 0;
  return 2;
}

static int
decode_PushPopReg_0 (TIword iw0, disassemble_info *outf)
{
  /* PushPopReg
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 |.W.|.grp.......|.reg.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int W   = ((iw0 >> PushPopReg_W_bits) & PushPopReg_W_mask);
  int grp = ((iw0 >> PushPopReg_grp_bits) & PushPopReg_grp_mask);
  int reg = ((iw0 >> PushPopReg_reg_bits) & PushPopReg_reg_mask);

  if (parallel)
    return 0;

  if (W == 0 && mostreg (reg, grp))
    {
      OUTS (outf, allregs (reg, grp));
      OUTS (outf, " = [SP++]");
    }
  else if (W == 1 && allreg (reg, grp) && !(grp == 1 && reg == 6))
    {
      OUTS (outf, "[--SP] = ");
      OUTS (outf, allregs (reg, grp));
    }
  else
    return 0;
  return 2;
}

static int
decode_PushPopMultiple_0 (TIword iw0, disassemble_info *outf)
{
  /* PushPopMultiple
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 0 | 0 | 0 | 1 | 0 |.d.|.p.|.W.|.dr........|.pr........|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int p  = ((iw0 >> PushPopMultiple_p_bits) & PushPopMultiple_p_mask);
  int d  = ((iw0 >> PushPopMultiple_d_bits) & PushPopMultiple_d_mask);
  int W  = ((iw0 >> PushPopMultiple_W_bits) & PushPopMultiple_W_mask);
  int dr = ((iw0 >> PushPopMultiple_dr_bits) & PushPopMultiple_dr_mask);
  int pr = ((iw0 >> PushPopMultiple_pr_bits) & PushPopMultiple_pr_mask);

  if (parallel)
    return 0;

  if (pr > 5)
    return 0;

  if (W == 1 && d == 1 && p == 1)
    {
      OUTS (outf, "[--SP] = (R7:");
      OUTS (outf, imm5d (dr));
      OUTS (outf, ", P5:");
      OUTS (outf, imm5d (pr));
      OUTS (outf, ")");
    }
  else if (W == 1 && d == 1 && p == 0 && pr == 0)
    {
      OUTS (outf, "[--SP] = (R7:");
      OUTS (outf, imm5d (dr));
      OUTS (outf, ")");
    }
  else if (W == 1 && d == 0 && p == 1 && dr == 0)
    {
      OUTS (outf, "[--SP] = (P5:");
      OUTS (outf, imm5d (pr));
      OUTS (outf, ")");
    }
  else if (W == 0 && d == 1 && p == 1)
    {
      OUTS (outf, "(R7:");
      OUTS (outf, imm5d (dr));
      OUTS (outf, ", P5:");
      OUTS (outf, imm5d (pr));
      OUTS (outf, ") = [SP++]");
    }
  else if (W == 0 && d == 1 && p == 0 && pr == 0)
    {
      OUTS (outf, "(R7:");
      OUTS (outf, imm5d (dr));
      OUTS (outf, ") = [SP++]");
    }
  else if (W == 0 && d == 0 && p == 1 && dr == 0)
    {
      OUTS (outf, "(P5:");
      OUTS (outf, imm5d (pr));
      OUTS (outf, ") = [SP++]");
    }
  else
    return 0;
  return 2;
}

static int
decode_ccMV_0 (TIword iw0, disassemble_info *outf)
{
  /* ccMV
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 0 | 0 | 0 | 1 | 1 |.T.|.d.|.s.|.dst.......|.src.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int s  = ((iw0 >> CCmv_s_bits) & CCmv_s_mask);
  int d  = ((iw0 >> CCmv_d_bits) & CCmv_d_mask);
  int T  = ((iw0 >> CCmv_T_bits) & CCmv_T_mask);
  int src = ((iw0 >> CCmv_src_bits) & CCmv_src_mask);
  int dst = ((iw0 >> CCmv_dst_bits) & CCmv_dst_mask);

  if (parallel)
    return 0;

  if (T == 1)
    {
      OUTS (outf, "IF CC ");
      OUTS (outf, gregs (dst, d));
      OUTS (outf, " = ");
      OUTS (outf, gregs (src, s));
    }
  else if (T == 0)
    {
      OUTS (outf, "IF !CC ");
      OUTS (outf, gregs (dst, d));
      OUTS (outf, " = ");
      OUTS (outf, gregs (src, s));
    }
  else
    return 0;
  return 2;
}

static int
decode_CCflag_0 (TIword iw0, disassemble_info *outf)
{
  /* CCflag
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 0 | 0 | 1 |.I.|.opc.......|.G.|.y.........|.x.........|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int x = ((iw0 >> CCflag_x_bits) & CCflag_x_mask);
  int y = ((iw0 >> CCflag_y_bits) & CCflag_y_mask);
  int I = ((iw0 >> CCflag_I_bits) & CCflag_I_mask);
  int G = ((iw0 >> CCflag_G_bits) & CCflag_G_mask);
  int opc = ((iw0 >> CCflag_opc_bits) & CCflag_opc_mask);

  if (parallel)
    return 0;

  if (opc == 0 && I == 0 && G == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (x));
      OUTS (outf, " == ");
      OUTS (outf, dregs (y));
    }
  else if (opc == 1 && I == 0 && G == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (x));
      OUTS (outf, " < ");
      OUTS (outf, dregs (y));
    }
  else if (opc == 2 && I == 0 && G == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (x));
      OUTS (outf, " <= ");
      OUTS (outf, dregs (y));
    }
  else if (opc == 3 && I == 0 && G == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (x));
      OUTS (outf, " < ");
      OUTS (outf, dregs (y));
      OUTS (outf, " (IU)");
    }
  else if (opc == 4 && I == 0 && G == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (x));
      OUTS (outf, " <= ");
      OUTS (outf, dregs (y));
      OUTS (outf, " (IU)");
    }
  else if (opc == 0 && I == 1 && G == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (x));
      OUTS (outf, " == ");
      OUTS (outf, imm3 (y));
    }
  else if (opc == 1 && I == 1 && G == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (x));
      OUTS (outf, " < ");
      OUTS (outf, imm3 (y));
    }
  else if (opc == 2 && I == 1 && G == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (x));
      OUTS (outf, " <= ");
      OUTS (outf, imm3 (y));
    }
  else if (opc == 3 && I == 1 && G == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (x));
      OUTS (outf, " < ");
      OUTS (outf, uimm3 (y));
      OUTS (outf, " (IU)");
    }
  else if (opc == 4 && I == 1 && G == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (x));
      OUTS (outf, " <= ");
      OUTS (outf, uimm3 (y));
      OUTS (outf, " (IU)");
    }
  else if (opc == 0 && I == 0 && G == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, pregs (x));
      OUTS (outf, " == ");
      OUTS (outf, pregs (y));
    }
  else if (opc == 1 && I == 0 && G == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, pregs (x));
      OUTS (outf, " < ");
      OUTS (outf, pregs (y));
    }
  else if (opc == 2 && I == 0 && G == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, pregs (x));
      OUTS (outf, " <= ");
      OUTS (outf, pregs (y));
    }
  else if (opc == 3 && I == 0 && G == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, pregs (x));
      OUTS (outf, " < ");
      OUTS (outf, pregs (y));
      OUTS (outf, " (IU)");
    }
  else if (opc == 4 && I == 0 && G == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, pregs (x));
      OUTS (outf, " <= ");
      OUTS (outf, pregs (y));
      OUTS (outf, " (IU)");
    }
  else if (opc == 0 && I == 1 && G == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, pregs (x));
      OUTS (outf, " == ");
      OUTS (outf, imm3 (y));
    }
  else if (opc == 1 && I == 1 && G == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, pregs (x));
      OUTS (outf, " < ");
      OUTS (outf, imm3 (y));
    }
  else if (opc == 2 && I == 1 && G == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, pregs (x));
      OUTS (outf, " <= ");
      OUTS (outf, imm3 (y));
    }
  else if (opc == 3 && I == 1 && G == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, pregs (x));
      OUTS (outf, " < ");
      OUTS (outf, uimm3 (y));
      OUTS (outf, " (IU)");
    }
  else if (opc == 4 && I == 1 && G == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, pregs (x));
      OUTS (outf, " <= ");
      OUTS (outf, uimm3 (y));
      OUTS (outf, " (IU)");
    }
  else if (opc == 5 && I == 0 && G == 0 && x == 0 && y == 0)
    OUTS (outf, "CC = A0 == A1");

  else if (opc == 6 && I == 0 && G == 0 && x == 0 && y == 0)
    OUTS (outf, "CC = A0 < A1");

  else if (opc == 7 && I == 0 && G == 0 && x == 0 && y == 0)
    OUTS (outf, "CC = A0 <= A1");

  else
    return 0;
  return 2;
}

static int
decode_CC2dreg_0 (TIword iw0, disassemble_info *outf)
{
  /* CC2dreg
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |.op....|.reg.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int op  = ((iw0 >> CC2dreg_op_bits) & CC2dreg_op_mask);
  int reg = ((iw0 >> CC2dreg_reg_bits) & CC2dreg_reg_mask);

  if (parallel)
    return 0;

  if (op == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = CC");
    }
  else if (op == 1)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, dregs (reg));
    }
  else if (op == 3 && reg == 0)
    OUTS (outf, "CC = !CC");
  else
    return 0;

  return 2;
}

static int
decode_CC2stat_0 (TIword iw0, disassemble_info *outf)
{
  /* CC2stat
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |.D.|.op....|.cbit..............|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int D    = ((iw0 >> CC2stat_D_bits) & CC2stat_D_mask);
  int op   = ((iw0 >> CC2stat_op_bits) & CC2stat_op_mask);
  int cbit = ((iw0 >> CC2stat_cbit_bits) & CC2stat_cbit_mask);

  const char *bitname = statbits (cbit);

  if (parallel)
    return 0;

  if (decode_statbits[cbit] == REG_LASTREG)
    {
      /* All ASTAT bits except CC may be operated on in hardware, but may
         not have a dedicated insn, so still decode "valid" insns.  */
      static char bitnames[64];
      if (cbit != 5)
	sprintf (bitnames, "ASTAT[%i /* unused bit */]", cbit);
      else
	return 0;

      bitname = bitnames;
    }

  if (op == 0 && D == 0)
    {
      OUTS (outf, "CC = ");
      OUTS (outf, bitname);
    }
  else if (op == 1 && D == 0)
    {
      OUTS (outf, "CC |= ");
      OUTS (outf, bitname);
    }
  else if (op == 2 && D == 0)
    {
      OUTS (outf, "CC &= ");
      OUTS (outf, bitname);
    }
  else if (op == 3 && D == 0)
    {
      OUTS (outf, "CC ^= ");
      OUTS (outf, bitname);
    }
  else if (op == 0 && D == 1)
    {
      OUTS (outf, bitname);
      OUTS (outf, " = CC");
    }
  else if (op == 1 && D == 1)
    {
      OUTS (outf, bitname);
      OUTS (outf, " |= CC");
    }
  else if (op == 2 && D == 1)
    {
      OUTS (outf, bitname);
      OUTS (outf, " &= CC");
    }
  else if (op == 3 && D == 1)
    {
      OUTS (outf, bitname);
      OUTS (outf, " ^= CC");
    }
  else
    return 0;

  return 2;
}

static int
decode_BRCC_0 (TIword iw0, bfd_vma pc, disassemble_info *outf)
{
  /* BRCC
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 0 | 1 |.T.|.B.|.offset................................|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int B = ((iw0 >> BRCC_B_bits) & BRCC_B_mask);
  int T = ((iw0 >> BRCC_T_bits) & BRCC_T_mask);
  int offset = ((iw0 >> BRCC_offset_bits) & BRCC_offset_mask);

  if (parallel)
    return 0;

  if (T == 1 && B == 1)
    {
      OUTS (outf, "IF CC JUMP 0x");
      OUTS (outf, pcrel10 (offset));
      OUTS (outf, " (BP)");
    }
  else if (T == 0 && B == 1)
    {
      OUTS (outf, "IF !CC JUMP 0x");
      OUTS (outf, pcrel10 (offset));
      OUTS (outf, " (BP)");
    }
  else if (T == 1)
    {
      OUTS (outf, "IF CC JUMP 0x");
      OUTS (outf, pcrel10 (offset));
    }
  else if (T == 0)
    {
      OUTS (outf, "IF !CC JUMP 0x");
      OUTS (outf, pcrel10 (offset));
    }
  else
    return 0;

  return 2;
}

static int
decode_UJUMP_0 (TIword iw0, bfd_vma pc, disassemble_info *outf)
{
  /* UJUMP
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 1 | 0 |.offset........................................|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int offset = ((iw0 >> UJump_offset_bits) & UJump_offset_mask);

  if (parallel)
    return 0;

  OUTS (outf, "JUMP.S 0x");
  OUTS (outf, pcrel12 (offset));
  return 2;
}

static int
decode_REGMV_0 (TIword iw0, disassemble_info *outf)
{
  /* REGMV
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 0 | 1 | 1 |.gd........|.gs........|.dst.......|.src.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int gs  = ((iw0 >> RegMv_gs_bits) & RegMv_gs_mask);
  int gd  = ((iw0 >> RegMv_gd_bits) & RegMv_gd_mask);
  int src = ((iw0 >> RegMv_src_bits) & RegMv_src_mask);
  int dst = ((iw0 >> RegMv_dst_bits) & RegMv_dst_mask);

  /* Reserved slots cannot be a src/dst.  */
  if (IS_RESERVEDREG (gs, src) || IS_RESERVEDREG (gd, dst))
    goto invalid_move;

  /* Standard register moves  */
  if ((gs < 2) ||                               /* Dregs/Pregs as source  */
      (gd < 2) ||                               /* Dregs/Pregs as dest    */
      (gs == 4 && src < 4) ||                   /* Accumulators as source */
      (gd == 4 && dst < 4 && (gs < 4)) ||       /* Accumulators as dest   */
      (gs == 7 && src == 7 && !(gd == 4 && dst < 4)) || /* EMUDAT as src  */
      (gd == 7 && dst == 7))                    /* EMUDAT as dest         */
    goto valid_move;

  /* dareg = dareg (IMBL) */
  if (gs < 4 && gd < 4)
    goto valid_move;

  /* USP can be src to sysregs, but not dagregs.  */
  if ((gs == 7 && src == 0) && (gd >= 4))
    goto valid_move;

  /* USP can move between genregs (only check Accumulators).  */
  if (((gs == 7 && src == 0) && (gd == 4 && dst < 4)) ||
      ((gd == 7 && dst == 0) && (gs == 4 && src < 4)))
    goto valid_move;

  /* Still here ?  Invalid reg pair.  */
 invalid_move:
  return 0;

 valid_move:
  OUTS (outf, allregs (dst, gd));
  OUTS (outf, " = ");
  OUTS (outf, allregs (src, gs));
  return 2;
}

static int
decode_ALU2op_0 (TIword iw0, disassemble_info *outf)
{
  /* ALU2op
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 1 | 0 | 0 | 0 | 0 |.opc...........|.src.......|.dst.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int src = ((iw0 >> ALU2op_src_bits) & ALU2op_src_mask);
  int opc = ((iw0 >> ALU2op_opc_bits) & ALU2op_opc_mask);
  int dst = ((iw0 >> ALU2op_dst_bits) & ALU2op_dst_mask);

  if (opc == 0)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " >>>= ");
      OUTS (outf, dregs (src));
    }
  else if (opc == 1)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " >>= ");
      OUTS (outf, dregs (src));
    }
  else if (opc == 2)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " <<= ");
      OUTS (outf, dregs (src));
    }
  else if (opc == 3)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " *= ");
      OUTS (outf, dregs (src));
    }
  else if (opc == 4)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = (");
      OUTS (outf, dregs (dst));
      OUTS (outf, " + ");
      OUTS (outf, dregs (src));
      OUTS (outf, ") << 0x1");
    }
  else if (opc == 5)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = (");
      OUTS (outf, dregs (dst));
      OUTS (outf, " + ");
      OUTS (outf, dregs (src));
      OUTS (outf, ") << 0x2");
    }
  else if (opc == 8)
    {
      OUTS (outf, "DIVQ (");
      OUTS (outf, dregs (dst));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src));
      OUTS (outf, ")");
    }
  else if (opc == 9)
    {
      OUTS (outf, "DIVS (");
      OUTS (outf, dregs (dst));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src));
      OUTS (outf, ")");
    }
  else if (opc == 10)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (src));
      OUTS (outf, " (X)");
    }
  else if (opc == 11)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (src));
      OUTS (outf, " (Z)");
    }
  else if (opc == 12)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, dregs_byte (src));
      OUTS (outf, " (X)");
    }
  else if (opc == 13)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, dregs_byte (src));
      OUTS (outf, " (Z)");
    }
  else if (opc == 14)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = -");
      OUTS (outf, dregs (src));
    }
  else if (opc == 15)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " =~ ");
      OUTS (outf, dregs (src));
    }
  else
    return 0;

  return 2;
}

static int
decode_PTR2op_0 (TIword iw0, disassemble_info *outf)
{
  /* PTR2op
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 1 | 0 | 0 | 0 | 1 | 0 |.opc.......|.src.......|.dst.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int src = ((iw0 >> PTR2op_src_bits) & PTR2op_dst_mask);
  int opc = ((iw0 >> PTR2op_opc_bits) & PTR2op_opc_mask);
  int dst = ((iw0 >> PTR2op_dst_bits) & PTR2op_dst_mask);

  if (opc == 0)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " -= ");
      OUTS (outf, pregs (src));
    }
  else if (opc == 1)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, pregs (src));
      OUTS (outf, " << 0x2");
    }
  else if (opc == 3)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, pregs (src));
      OUTS (outf, " >> 0x2");
    }
  else if (opc == 4)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, pregs (src));
      OUTS (outf, " >> 0x1");
    }
  else if (opc == 5)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " += ");
      OUTS (outf, pregs (src));
      OUTS (outf, " (BREV)");
    }
  else if (opc == 6)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " = (");
      OUTS (outf, pregs (dst));
      OUTS (outf, " + ");
      OUTS (outf, pregs (src));
      OUTS (outf, ") << 0x1");
    }
  else if (opc == 7)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " = (");
      OUTS (outf, pregs (dst));
      OUTS (outf, " + ");
      OUTS (outf, pregs (src));
      OUTS (outf, ") << 0x2");
    }
  else
    return 0;

  return 2;
}

static int
decode_LOGI2op_0 (TIword iw0, disassemble_info *outf)
{
  /* LOGI2op
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 1 | 0 | 0 | 1 |.opc.......|.src...............|.dst.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int src = ((iw0 >> LOGI2op_src_bits) & LOGI2op_src_mask);
  int opc = ((iw0 >> LOGI2op_opc_bits) & LOGI2op_opc_mask);
  int dst = ((iw0 >> LOGI2op_dst_bits) & LOGI2op_dst_mask);

  if (parallel)
    return 0;

  if (opc == 0)
    {
      OUTS (outf, "CC = !BITTST (");
      OUTS (outf, dregs (dst));
      OUTS (outf, ", ");
      OUTS (outf, uimm5 (src));
      OUTS (outf, ");\t\t/* bit");
      OUTS (outf, imm7d (src));
      OUTS (outf, " */");
      comment = 1;
    }
  else if (opc == 1)
    {
      OUTS (outf, "CC = BITTST (");
      OUTS (outf, dregs (dst));
      OUTS (outf, ", ");
      OUTS (outf, uimm5 (src));
      OUTS (outf, ");\t\t/* bit");
      OUTS (outf, imm7d (src));
      OUTS (outf, " */");
      comment = 1;
    }
  else if (opc == 2)
    {
      OUTS (outf, "BITSET (");
      OUTS (outf, dregs (dst));
      OUTS (outf, ", ");
      OUTS (outf, uimm5 (src));
      OUTS (outf, ");\t\t/* bit");
      OUTS (outf, imm7d (src));
      OUTS (outf, " */");
      comment = 1;
    }
  else if (opc == 3)
    {
      OUTS (outf, "BITTGL (");
      OUTS (outf, dregs (dst));
      OUTS (outf, ", ");
      OUTS (outf, uimm5 (src));
      OUTS (outf, ");\t\t/* bit");
      OUTS (outf, imm7d (src));
      OUTS (outf, " */");
      comment = 1;
    }
  else if (opc == 4)
    {
      OUTS (outf, "BITCLR (");
      OUTS (outf, dregs (dst));
      OUTS (outf, ", ");
      OUTS (outf, uimm5 (src));
      OUTS (outf, ");\t\t/* bit");
      OUTS (outf, imm7d (src));
      OUTS (outf, " */");
      comment = 1;
    }
  else if (opc == 5)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " >>>= ");
      OUTS (outf, uimm5 (src));
    }
  else if (opc == 6)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " >>= ");
      OUTS (outf, uimm5 (src));
    }
  else if (opc == 7)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " <<= ");
      OUTS (outf, uimm5 (src));
    }
  else
    return 0;

  return 2;
}

static int
decode_COMP3op_0 (TIword iw0, disassemble_info *outf)
{
  /* COMP3op
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 1 | 0 | 1 |.opc.......|.dst.......|.src1......|.src0......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int opc  = ((iw0 >> COMP3op_opc_bits) & COMP3op_opc_mask);
  int dst  = ((iw0 >> COMP3op_dst_bits) & COMP3op_dst_mask);
  int src0 = ((iw0 >> COMP3op_src0_bits) & COMP3op_src0_mask);
  int src1 = ((iw0 >> COMP3op_src1_bits) & COMP3op_src1_mask);

  if (opc == 5 && src1 == src0)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, pregs (src0));
      OUTS (outf, " << 0x1");
    }
  else if (opc == 1)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs (src1));
    }
  else if (opc == 2)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " & ");
      OUTS (outf, dregs (src1));
    }
  else if (opc == 3)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " | ");
      OUTS (outf, dregs (src1));
    }
  else if (opc == 4)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " ^ ");
      OUTS (outf, dregs (src1));
    }
  else if (opc == 5)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, pregs (src0));
      OUTS (outf, " + ");
      OUTS (outf, pregs (src1));
    }
  else if (opc == 6)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, pregs (src0));
      OUTS (outf, " + (");
      OUTS (outf, pregs (src1));
      OUTS (outf, " << 0x1)");
    }
  else if (opc == 7)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, pregs (src0));
      OUTS (outf, " + (");
      OUTS (outf, pregs (src1));
      OUTS (outf, " << 0x2)");
    }
  else if (opc == 0)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs (src1));
    }
  else
    return 0;

  return 2;
}

static int
decode_COMPI2opD_0 (TIword iw0, disassemble_info *outf)
{
  /* COMPI2opD
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 1 | 1 | 0 | 0 |.op|..src......................|.dst.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int op  = ((iw0 >> COMPI2opD_op_bits) & COMPI2opD_op_mask);
  int dst = ((iw0 >> COMPI2opD_dst_bits) & COMPI2opD_dst_mask);
  int src = ((iw0 >> COMPI2opD_src_bits) & COMPI2opD_src_mask);

  bu32 *pval = get_allreg (0, dst);

  if (parallel)
    return 0;

  /* Since we don't have 32-bit immediate loads, we allow the disassembler
     to combine them, so it prints out the right values.
     Here we keep track of the registers.  */
  if (op == 0)
    {
      *pval = imm7_val (src);
      if (src & 0x40)
	*pval |= 0xFFFFFF80;
      else
	*pval &= 0x7F;
    }

  if (op == 0)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, imm7 (src));
      OUTS (outf, " (X);\t\t/*\t\t");
      OUTS (outf, dregs (dst));
      OUTS (outf, "=");
      OUTS (outf, uimm32 (*pval));
      OUTS (outf, "(");
      OUTS (outf, imm32 (*pval));
      OUTS (outf, ") */");
      comment = 1;
    }
  else if (op == 1)
    {
      OUTS (outf, dregs (dst));
      OUTS (outf, " += ");
      OUTS (outf, imm7 (src));
      OUTS (outf, ";\t\t/* (");
      OUTS (outf, imm7d (src));
      OUTS (outf, ") */");
      comment = 1;
    }
  else
    return 0;

  return 2;
}

static int
decode_COMPI2opP_0 (TIword iw0, disassemble_info *outf)
{
  /* COMPI2opP
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 0 | 1 | 1 | 0 | 1 |.op|.src.......................|.dst.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int op  = ((iw0 >> COMPI2opP_op_bits) & COMPI2opP_op_mask);
  int src = ((iw0 >> COMPI2opP_src_bits) & COMPI2opP_src_mask);
  int dst = ((iw0 >> COMPI2opP_dst_bits) & COMPI2opP_dst_mask);

  bu32 *pval = get_allreg (1, dst);

  if (parallel)
    return 0;

  if (op == 0)
    {
      *pval = imm7_val (src);
      if (src & 0x40)
	*pval |= 0xFFFFFF80;
      else
	*pval &= 0x7F;
    }

  if (op == 0)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " = ");
      OUTS (outf, imm7 (src));
      OUTS (outf, " (X);\t\t/*\t\t");
      OUTS (outf, pregs (dst));
      OUTS (outf, "=");
      OUTS (outf, uimm32 (*pval));
      OUTS (outf, "(");
      OUTS (outf, imm32 (*pval));
      OUTS (outf, ") */");
      comment = 1;
    }
  else if (op == 1)
    {
      OUTS (outf, pregs (dst));
      OUTS (outf, " += ");
      OUTS (outf, imm7 (src));
      OUTS (outf, ";\t\t/* (");
      OUTS (outf, imm7d (src));
      OUTS (outf, ") */");
      comment = 1;
    }
  else
    return 0;

  return 2;
}

static int
decode_LDSTpmod_0 (TIword iw0, disassemble_info *outf)
{
  /* LDSTpmod
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 0 | 0 |.W.|.aop...|.reg.......|.idx.......|.ptr.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int W   = ((iw0 >> LDSTpmod_W_bits) & LDSTpmod_W_mask);
  int aop = ((iw0 >> LDSTpmod_aop_bits) & LDSTpmod_aop_mask);
  int idx = ((iw0 >> LDSTpmod_idx_bits) & LDSTpmod_idx_mask);
  int ptr = ((iw0 >> LDSTpmod_ptr_bits) & LDSTpmod_ptr_mask);
  int reg = ((iw0 >> LDSTpmod_reg_bits) & LDSTpmod_reg_mask);

  if (aop == 1 && W == 0 && idx == ptr)
    {
      OUTS (outf, dregs_lo (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "]");
    }
  else if (aop == 2 && W == 0 && idx == ptr)
    {
      OUTS (outf, dregs_hi (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "]");
    }
  else if (aop == 1 && W == 1 && idx == ptr)
    {
      OUTS (outf, "W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "] = ");
      OUTS (outf, dregs_lo (reg));
    }
  else if (aop == 2 && W == 1 && idx == ptr)
    {
      OUTS (outf, "W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "] = ");
      OUTS (outf, dregs_hi (reg));
    }
  else if (aop == 0 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " ++ ");
      OUTS (outf, pregs (idx));
      OUTS (outf, "]");
    }
  else if (aop == 1 && W == 0)
    {
      OUTS (outf, dregs_lo (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " ++ ");
      OUTS (outf, pregs (idx));
      OUTS (outf, "]");
    }
  else if (aop == 2 && W == 0)
    {
      OUTS (outf, dregs_hi (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " ++ ");
      OUTS (outf, pregs (idx));
      OUTS (outf, "]");
    }
  else if (aop == 3 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " ++ ");
      OUTS (outf, pregs (idx));
      OUTS (outf, "] (Z)");
    }
  else if (aop == 3 && W == 1)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " ++ ");
      OUTS (outf, pregs (idx));
      OUTS (outf, "] (X)");
    }
  else if (aop == 0 && W == 1)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " ++ ");
      OUTS (outf, pregs (idx));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 1 && W == 1)
    {
      OUTS (outf, "W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " ++ ");
      OUTS (outf, pregs (idx));
      OUTS (outf, "] = ");
      OUTS (outf, dregs_lo (reg));
    }
  else if (aop == 2 && W == 1)
    {
      OUTS (outf, "W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " ++ ");
      OUTS (outf, pregs (idx));
      OUTS (outf, "] = ");
      OUTS (outf, dregs_hi (reg));
    }
  else
    return 0;

  return 2;
}

static int
decode_dagMODim_0 (TIword iw0, disassemble_info *outf)
{
  /* dagMODim
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |.br| 1 | 1 |.op|.m.....|.i.....|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int i  = ((iw0 >> DagMODim_i_bits) & DagMODim_i_mask);
  int m  = ((iw0 >> DagMODim_m_bits) & DagMODim_m_mask);
  int br = ((iw0 >> DagMODim_br_bits) & DagMODim_br_mask);
  int op = ((iw0 >> DagMODim_op_bits) & DagMODim_op_mask);

  if (op == 0 && br == 1)
    {
      OUTS (outf, iregs (i));
      OUTS (outf, " += ");
      OUTS (outf, mregs (m));
      OUTS (outf, " (BREV)");
    }
  else if (op == 0)
    {
      OUTS (outf, iregs (i));
      OUTS (outf, " += ");
      OUTS (outf, mregs (m));
    }
  else if (op == 1 && br == 0)
    {
      OUTS (outf, iregs (i));
      OUTS (outf, " -= ");
      OUTS (outf, mregs (m));
    }
  else
    return 0;

  return 2;
}

static int
decode_dagMODik_0 (TIword iw0, disassemble_info *outf)
{
  /* dagMODik
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 0 |.op....|.i.....|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int i  = ((iw0 >> DagMODik_i_bits) & DagMODik_i_mask);
  int op = ((iw0 >> DagMODik_op_bits) & DagMODik_op_mask);

  if (op == 0)
    {
      OUTS (outf, iregs (i));
      OUTS (outf, " += 0x2");
    }
  else if (op == 1)
    {
      OUTS (outf, iregs (i));
      OUTS (outf, " -= 0x2");
    }
  else if (op == 2)
    {
      OUTS (outf, iregs (i));
      OUTS (outf, " += 0x4");
    }
  else if (op == 3)
    {
      OUTS (outf, iregs (i));
      OUTS (outf, " -= 0x4");
    }
  else
    return 0;

  if (! parallel)
    {
      OUTS (outf, ";\t\t/* (  ");
      if (op == 0 || op == 1)
	OUTS (outf, "2");
      else if (op == 2 || op == 3)
	OUTS (outf, "4");
      OUTS (outf, ") */");
      comment = 1;
    }

  return 2;
}

static int
decode_dspLDST_0 (TIword iw0, disassemble_info *outf)
{
  /* dspLDST
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 0 | 1 | 1 | 1 |.W.|.aop...|.m.....|.i.....|.reg.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int i   = ((iw0 >> DspLDST_i_bits) & DspLDST_i_mask);
  int m   = ((iw0 >> DspLDST_m_bits) & DspLDST_m_mask);
  int W   = ((iw0 >> DspLDST_W_bits) & DspLDST_W_mask);
  int aop = ((iw0 >> DspLDST_aop_bits) & DspLDST_aop_mask);
  int reg = ((iw0 >> DspLDST_reg_bits) & DspLDST_reg_mask);

  if (aop == 0 && W == 0 && m == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, iregs (i));
      OUTS (outf, "++]");
    }
  else if (aop == 0 && W == 0 && m == 1)
    {
      OUTS (outf, dregs_lo (reg));
      OUTS (outf, " = W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "++]");
    }
  else if (aop == 0 && W == 0 && m == 2)
    {
      OUTS (outf, dregs_hi (reg));
      OUTS (outf, " = W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "++]");
    }
  else if (aop == 1 && W == 0 && m == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, iregs (i));
      OUTS (outf, "--]");
    }
  else if (aop == 1 && W == 0 && m == 1)
    {
      OUTS (outf, dregs_lo (reg));
      OUTS (outf, " = W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "--]");
    }
  else if (aop == 1 && W == 0 && m == 2)
    {
      OUTS (outf, dregs_hi (reg));
      OUTS (outf, " = W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "--]");
    }
  else if (aop == 2 && W == 0 && m == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, iregs (i));
      OUTS (outf, "]");
    }
  else if (aop == 2 && W == 0 && m == 1)
    {
      OUTS (outf, dregs_lo (reg));
      OUTS (outf, " = W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "]");
    }
  else if (aop == 2 && W == 0 && m == 2)
    {
      OUTS (outf, dregs_hi (reg));
      OUTS (outf, " = W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "]");
    }
  else if (aop == 0 && W == 1 && m == 0)
    {
      OUTS (outf, "[");
      OUTS (outf, iregs (i));
      OUTS (outf, "++] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 0 && W == 1 && m == 1)
    {
      OUTS (outf, "W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "++] = ");
      OUTS (outf, dregs_lo (reg));
    }
  else if (aop == 0 && W == 1 && m == 2)
    {
      OUTS (outf, "W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "++] = ");
      OUTS (outf, dregs_hi (reg));
    }
  else if (aop == 1 && W == 1 && m == 0)
    {
      OUTS (outf, "[");
      OUTS (outf, iregs (i));
      OUTS (outf, "--] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 1 && W == 1 && m == 1)
    {
      OUTS (outf, "W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "--] = ");
      OUTS (outf, dregs_lo (reg));
    }
  else if (aop == 1 && W == 1 && m == 2)
    {
      OUTS (outf, "W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "--] = ");
      OUTS (outf, dregs_hi (reg));
    }
  else if (aop == 2 && W == 1 && m == 0)
    {
      OUTS (outf, "[");
      OUTS (outf, iregs (i));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 2 && W == 1 && m == 1)
    {
      OUTS (outf, "W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "] = ");
      OUTS (outf, dregs_lo (reg));
    }
  else if (aop == 2 && W == 1 && m == 2)
    {
      OUTS (outf, "W[");
      OUTS (outf, iregs (i));
      OUTS (outf, "] = ");
      OUTS (outf, dregs_hi (reg));
    }
  else if (aop == 3 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, iregs (i));
      OUTS (outf, " ++ ");
      OUTS (outf, mregs (m));
      OUTS (outf, "]");
    }
  else if (aop == 3 && W == 1)
    {
      OUTS (outf, "[");
      OUTS (outf, iregs (i));
      OUTS (outf, " ++ ");
      OUTS (outf, mregs (m));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else
    return 0;

  return 2;
}

static int
decode_LDST_0 (TIword iw0, disassemble_info *outf)
{
  /* LDST
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 0 | 1 |.sz....|.W.|.aop...|.Z.|.ptr.......|.reg.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int Z   = ((iw0 >> LDST_Z_bits) & LDST_Z_mask);
  int W   = ((iw0 >> LDST_W_bits) & LDST_W_mask);
  int sz  = ((iw0 >> LDST_sz_bits) & LDST_sz_mask);
  int aop = ((iw0 >> LDST_aop_bits) & LDST_aop_mask);
  int reg = ((iw0 >> LDST_reg_bits) & LDST_reg_mask);
  int ptr = ((iw0 >> LDST_ptr_bits) & LDST_ptr_mask);

  if (aop == 0 && sz == 0 && Z == 0 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "++]");
    }
  else if (aop == 0 && sz == 0 && Z == 1 && W == 0 && reg != ptr)
    {
      OUTS (outf, pregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "++]");
    }
  else if (aop == 0 && sz == 1 && Z == 0 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "++] (Z)");
    }
  else if (aop == 0 && sz == 1 && Z == 1 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "++] (X)");
    }
  else if (aop == 0 && sz == 2 && Z == 0 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "++] (Z)");
    }
  else if (aop == 0 && sz == 2 && Z == 1 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "++] (X)");
    }
  else if (aop == 1 && sz == 0 && Z == 0 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "--]");
    }
  else if (aop == 1 && sz == 0 && Z == 1 && W == 0 && reg != ptr)
    {
      OUTS (outf, pregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "--]");
    }
  else if (aop == 1 && sz == 1 && Z == 0 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "--] (Z)");
    }
  else if (aop == 1 && sz == 1 && Z == 1 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "--] (X)");
    }
  else if (aop == 1 && sz == 2 && Z == 0 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "--] (Z)");
    }
  else if (aop == 1 && sz == 2 && Z == 1 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "--] (X)");
    }
  else if (aop == 2 && sz == 0 && Z == 0 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "]");
    }
  else if (aop == 2 && sz == 0 && Z == 1 && W == 0)
    {
      OUTS (outf, pregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "]");
    }
  else if (aop == 2 && sz == 1 && Z == 0 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "] (Z)");
    }
  else if (aop == 2 && sz == 1 && Z == 1 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "] (X)");
    }
  else if (aop == 2 && sz == 2 && Z == 0 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "] (Z)");
    }
  else if (aop == 2 && sz == 2 && Z == 1 && W == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "] (X)");
    }
  else if (aop == 0 && sz == 0 && Z == 0 && W == 1)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "++] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 0 && sz == 0 && Z == 1 && W == 1)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "++] = ");
      OUTS (outf, pregs (reg));
    }
  else if (aop == 0 && sz == 1 && Z == 0 && W == 1)
    {
      OUTS (outf, "W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "++] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 0 && sz == 2 && Z == 0 && W == 1)
    {
      OUTS (outf, "B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "++] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 1 && sz == 0 && Z == 0 && W == 1)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "--] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 1 && sz == 0 && Z == 1 && W == 1)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "--] = ");
      OUTS (outf, pregs (reg));
    }
  else if (aop == 1 && sz == 1 && Z == 0 && W == 1)
    {
      OUTS (outf, "W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "--] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 1 && sz == 2 && Z == 0 && W == 1)
    {
      OUTS (outf, "B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "--] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 2 && sz == 0 && Z == 0 && W == 1)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 2 && sz == 0 && Z == 1 && W == 1)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "] = ");
      OUTS (outf, pregs (reg));
    }
  else if (aop == 2 && sz == 1 && Z == 0 && W == 1)
    {
      OUTS (outf, "W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else if (aop == 2 && sz == 2 && Z == 0 && W == 1)
    {
      OUTS (outf, "B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else
    return 0;

  return 2;
}

static int
decode_LDSTiiFP_0 (TIword iw0, disassemble_info *outf)
{
  /* LDSTiiFP
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 1 | 1 | 1 | 0 |.W.|.offset............|.reg...........|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int reg = ((iw0 >> LDSTiiFP_reg_bits) & LDSTiiFP_reg_mask);
  int offset = ((iw0 >> LDSTiiFP_offset_bits) & LDSTiiFP_offset_mask);
  int W = ((iw0 >> LDSTiiFP_W_bits) & LDSTiiFP_W_mask);

  if (W == 0)
    {
      OUTS (outf, dpregs (reg));
      OUTS (outf, " = [FP ");
      OUTS (outf, negimm5s4 (offset));
      OUTS (outf, "]");
    }
  else if (W == 1)
    {
      OUTS (outf, "[FP ");
      OUTS (outf, negimm5s4 (offset));
      OUTS (outf, "] = ");
      OUTS (outf, dpregs (reg));
    }
  else
    return 0;

  return 2;
}

static int
decode_LDSTii_0 (TIword iw0, disassemble_info *outf)
{
  /* LDSTii
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 1 |.W.|.op....|.offset........|.ptr.......|.reg.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int reg = ((iw0 >> LDSTii_reg_bit) & LDSTii_reg_mask);
  int ptr = ((iw0 >> LDSTii_ptr_bit) & LDSTii_ptr_mask);
  int offset = ((iw0 >> LDSTii_offset_bit) & LDSTii_offset_mask);
  int op = ((iw0 >> LDSTii_op_bit) & LDSTii_op_mask);
  int W = ((iw0 >> LDSTii_W_bit) & LDSTii_W_mask);

  if (W == 0 && op == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, uimm4s4 (offset));
      OUTS (outf, "]");
    }
  else if (W == 0 && op == 1)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, uimm4s2 (offset));
      OUTS (outf, "] (Z)");
    }
  else if (W == 0 && op == 2)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, uimm4s2 (offset));
      OUTS (outf, "] (X)");
    }
  else if (W == 0 && op == 3)
    {
      OUTS (outf, pregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, uimm4s4 (offset));
      OUTS (outf, "]");
    }
  else if (W == 1 && op == 0)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, uimm4s4 (offset));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else if (W == 1 && op == 1)
    {
      OUTS (outf, "W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, uimm4s2 (offset));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else if (W == 1 && op == 3)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, uimm4s4 (offset));
      OUTS (outf, "] = ");
      OUTS (outf, pregs (reg));
    }
  else
    return 0;

  return 2;
}

static int
decode_LoopSetup_0 (TIword iw0, TIword iw1, bfd_vma pc, disassemble_info *outf)
{
  /* LoopSetup
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |.rop...|.c.|.soffset.......|
     |.reg...........| - | - |.eoffset...............................|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int c   = ((iw0 >> (LoopSetup_c_bits - 16)) & LoopSetup_c_mask);
  int reg = ((iw1 >> LoopSetup_reg_bits) & LoopSetup_reg_mask);
  int rop = ((iw0 >> (LoopSetup_rop_bits - 16)) & LoopSetup_rop_mask);
  int soffset = ((iw0 >> (LoopSetup_soffset_bits - 16)) & LoopSetup_soffset_mask);
  int eoffset = ((iw1 >> LoopSetup_eoffset_bits) & LoopSetup_eoffset_mask);

  if (parallel)
    return 0;

  if (reg > 7)
    return 0;

  if (rop == 0)
    {
      OUTS (outf, "LSETUP");
      OUTS (outf, "(0x");
      OUTS (outf, pcrel4 (soffset));
      OUTS (outf, ", 0x");
      OUTS (outf, lppcrel10 (eoffset));
      OUTS (outf, ") ");
      OUTS (outf, counters (c));
    }
  else if (rop == 1)
    {
      OUTS (outf, "LSETUP");
      OUTS (outf, "(0x");
      OUTS (outf, pcrel4 (soffset));
      OUTS (outf, ", 0x");
      OUTS (outf, lppcrel10 (eoffset));
      OUTS (outf, ") ");
      OUTS (outf, counters (c));
      OUTS (outf, " = ");
      OUTS (outf, pregs (reg));
    }
  else if (rop == 3)
    {
      OUTS (outf, "LSETUP");
      OUTS (outf, "(0x");
      OUTS (outf, pcrel4 (soffset));
      OUTS (outf, ", 0x");
      OUTS (outf, lppcrel10 (eoffset));
      OUTS (outf, ") ");
      OUTS (outf, counters (c));
      OUTS (outf, " = ");
      OUTS (outf, pregs (reg));
      OUTS (outf, " >> 0x1");
    }
  else
    return 0;

  return 4;
}

static int
decode_LDIMMhalf_0 (TIword iw0, TIword iw1, disassemble_info *outf)
{
  /* LDIMMhalf
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |.Z.|.H.|.S.|.grp...|.reg.......|
     |.hword.........................................................|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int H = ((iw0 >> (LDIMMhalf_H_bits - 16)) & LDIMMhalf_H_mask);
  int Z = ((iw0 >> (LDIMMhalf_Z_bits - 16)) & LDIMMhalf_Z_mask);
  int S = ((iw0 >> (LDIMMhalf_S_bits - 16)) & LDIMMhalf_S_mask);
  int reg = ((iw0 >> (LDIMMhalf_reg_bits - 16)) & LDIMMhalf_reg_mask);
  int grp = ((iw0 >> (LDIMMhalf_grp_bits - 16)) & LDIMMhalf_grp_mask);
  int hword = ((iw1 >> LDIMMhalf_hword_bits) & LDIMMhalf_hword_mask);

  bu32 *pval = get_allreg (grp, reg);

  if (parallel)
    return 0;

  /* Since we don't have 32-bit immediate loads, we allow the disassembler
     to combine them, so it prints out the right values.
     Here we keep track of the registers.  */
  if (H == 0 && S == 1 && Z == 0)
    {
      /* regs = imm16 (x) */
      *pval = imm16_val (hword);
      if (hword & 0x8000)
	*pval |= 0xFFFF0000;
      else
	*pval &= 0xFFFF;
    }
  else if (H == 0 && S == 0 && Z == 1)
    {
      /* regs = luimm16 (Z) */
      *pval = luimm16_val (hword);
      *pval &= 0xFFFF;
    }
  else if (H == 0 && S == 0 && Z == 0)
    {
      /* regs_lo = luimm16 */
      *pval &= 0xFFFF0000;
      *pval |= luimm16_val (hword);
    }
  else if (H == 1 && S == 0 && Z == 0)
    {
      /* regs_hi = huimm16 */
      *pval &= 0xFFFF;
      *pval |= luimm16_val (hword) << 16;
    }

  /* Here we do the disassembly */
  if (grp == 0 && H == 0 && S == 0 && Z == 0)
    {
      OUTS (outf, dregs_lo (reg));
      OUTS (outf, " = ");
      OUTS (outf, uimm16 (hword));
    }
  else if (grp == 0 && H == 1 && S == 0 && Z == 0)
    {
      OUTS (outf, dregs_hi (reg));
      OUTS (outf, " = ");
      OUTS (outf, uimm16 (hword));
    }
  else if (grp == 0 && H == 0 && S == 1 && Z == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = ");
      OUTS (outf, imm16 (hword));
      OUTS (outf, " (X)");
    }
  else if (H == 0 && S == 1 && Z == 0)
    {
      OUTS (outf, regs (reg, grp));
      OUTS (outf, " = ");
      OUTS (outf, imm16 (hword));
      OUTS (outf, " (X)");
    }
  else if (H == 0 && S == 0 && Z == 1)
    {
      OUTS (outf, regs (reg, grp));
      OUTS (outf, " = ");
      OUTS (outf, uimm16 (hword));
      OUTS (outf, " (Z)");
    }
  else if (H == 0 && S == 0 && Z == 0)
    {
      OUTS (outf, regs_lo (reg, grp));
      OUTS (outf, " = ");
      OUTS (outf, uimm16 (hword));
    }
  else if (H == 1 && S == 0 && Z == 0)
    {
      OUTS (outf, regs_hi (reg, grp));
      OUTS (outf, " = ");
      OUTS (outf, uimm16 (hword));
    }
  else
    return 0;

  /* And we print out the 32-bit value if it is a pointer.  */
  if (S == 0 && Z == 0)
    {
      OUTS (outf, ";\t\t/* (");
      OUTS (outf, imm16d (hword));
      OUTS (outf, ")\t");

      /* If it is an MMR, don't print the symbol.  */
      if (*pval < 0xFFC00000 && grp == 1)
	{
	  OUTS (outf, regs (reg, grp));
	  OUTS (outf, "=0x");
	  OUTS (outf, huimm32e (*pval));
	}
      else
	{
	  OUTS (outf, regs (reg, grp));
	  OUTS (outf, "=0x");
	  OUTS (outf, huimm32e (*pval));
	  OUTS (outf, "(");
	  OUTS (outf, imm32 (*pval));
	  OUTS (outf, ")");
	}

      OUTS (outf, " */");
      comment = 1;
    }
  if (S == 1 || Z == 1)
    {
      OUTS (outf, ";\t\t/*\t\t");
      OUTS (outf, regs (reg, grp));
      OUTS (outf, "=0x");
      OUTS (outf, huimm32e (*pval));
      OUTS (outf, "(");
      OUTS (outf, imm32 (*pval));
      OUTS (outf, ") */");
      comment = 1;
    }
  return 4;
}

static int
decode_CALLa_0 (TIword iw0, TIword iw1, bfd_vma pc, disassemble_info *outf)
{
  /* CALLa
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 1 | 0 | 0 | 0 | 1 |.S.|.msw...........................|
     |.lsw...........................................................|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int S   = ((iw0 >> (CALLa_S_bits - 16)) & CALLa_S_mask);
  int lsw = ((iw1 >> 0) & 0xffff);
  int msw = ((iw0 >> 0) & 0xff);

  if (parallel)
    return 0;

  if (S == 1)
    OUTS (outf, "CALL 0x");
  else if (S == 0)
    OUTS (outf, "JUMP.L 0x");
  else
    return 0;

  OUTS (outf, pcrel24 (((msw) << 16) | (lsw)));
  return 4;
}

static int
decode_LDSTidxI_0 (TIword iw0, TIword iw1, disassemble_info *outf)
{
  /* LDSTidxI
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 1 | 0 | 0 | 1 |.W.|.Z.|.sz....|.ptr.......|.reg.......|
     |.offset........................................................|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int Z = ((iw0 >> (LDSTidxI_Z_bits - 16)) & LDSTidxI_Z_mask);
  int W = ((iw0 >> (LDSTidxI_W_bits - 16)) & LDSTidxI_W_mask);
  int sz = ((iw0 >> (LDSTidxI_sz_bits - 16)) & LDSTidxI_sz_mask);
  int reg = ((iw0 >> (LDSTidxI_reg_bits - 16)) & LDSTidxI_reg_mask);
  int ptr = ((iw0 >> (LDSTidxI_ptr_bits - 16)) & LDSTidxI_ptr_mask);
  int offset = ((iw1 >> LDSTidxI_offset_bits) & LDSTidxI_offset_mask);

  if (W == 0 && sz == 0 && Z == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, imm16s4 (offset));
      OUTS (outf, "]");
    }
  else if (W == 0 && sz == 0 && Z == 1)
    {
      OUTS (outf, pregs (reg));
      OUTS (outf, " = [");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, imm16s4 (offset));
      OUTS (outf, "]");
    }
  else if (W == 0 && sz == 1 && Z == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, imm16s2 (offset));
      OUTS (outf, "] (Z)");
    }
  else if (W == 0 && sz == 1 && Z == 1)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, imm16s2 (offset));
      OUTS (outf, "] (X)");
    }
  else if (W == 0 && sz == 2 && Z == 0)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, imm16 (offset));
      OUTS (outf, "] (Z)");
    }
  else if (W == 0 && sz == 2 && Z == 1)
    {
      OUTS (outf, dregs (reg));
      OUTS (outf, " = B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, imm16 (offset));
      OUTS (outf, "] (X)");
    }
  else if (W == 1 && sz == 0 && Z == 0)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, imm16s4 (offset));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else if (W == 1 && sz == 0 && Z == 1)
    {
      OUTS (outf, "[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, imm16s4 (offset));
      OUTS (outf, "] = ");
      OUTS (outf, pregs (reg));
    }
  else if (W == 1 && sz == 1 && Z == 0)
    {
      OUTS (outf, "W[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, imm16s2 (offset));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else if (W == 1 && sz == 2 && Z == 0)
    {
      OUTS (outf, "B[");
      OUTS (outf, pregs (ptr));
      OUTS (outf, " + ");
      OUTS (outf, imm16 (offset));
      OUTS (outf, "] = ");
      OUTS (outf, dregs (reg));
    }
  else
    return 0;

  return 4;
}

static int
decode_linkage_0 (TIword iw0, TIword iw1, disassemble_info *outf)
{
  /* linkage
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |.R.|
     |.framesize.....................................................|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int R = ((iw0 >> (Linkage_R_bits - 16)) & Linkage_R_mask);
  int framesize = ((iw1 >> Linkage_framesize_bits) & Linkage_framesize_mask);

  if (parallel)
    return 0;

  if (R == 0)
    {
      OUTS (outf, "LINK ");
      OUTS (outf, uimm16s4 (framesize));
      OUTS (outf, ";\t\t/* (");
      OUTS (outf, uimm16s4d (framesize));
      OUTS (outf, ") */");
      comment = 1;
    }
  else if (R == 1)
    OUTS (outf, "UNLINK");
  else
    return 0;

  return 4;
}

static int
decode_dsp32mac_0 (TIword iw0, TIword iw1, disassemble_info *outf)
{
  /* dsp32mac
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 0 | 0 |.M.| 0 | 0 |.mmod..........|.MM|.P.|.w1|.op1...|
     |.h01|.h11|.w0|.op0...|.h00|.h10|.dst.......|.src0......|.src1..|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int op1  = ((iw0 >> (DSP32Mac_op1_bits - 16)) & DSP32Mac_op1_mask);
  int w1   = ((iw0 >> (DSP32Mac_w1_bits - 16)) & DSP32Mac_w1_mask);
  int P    = ((iw0 >> (DSP32Mac_p_bits - 16)) & DSP32Mac_p_mask);
  int MM   = ((iw0 >> (DSP32Mac_MM_bits - 16)) & DSP32Mac_MM_mask);
  int mmod = ((iw0 >> (DSP32Mac_mmod_bits - 16)) & DSP32Mac_mmod_mask);
  int w0   = ((iw1 >> DSP32Mac_w0_bits) & DSP32Mac_w0_mask);
  int src0 = ((iw1 >> DSP32Mac_src0_bits) & DSP32Mac_src0_mask);
  int src1 = ((iw1 >> DSP32Mac_src1_bits) & DSP32Mac_src1_mask);
  int dst  = ((iw1 >> DSP32Mac_dst_bits) & DSP32Mac_dst_mask);
  int h10  = ((iw1 >> DSP32Mac_h10_bits) & DSP32Mac_h10_mask);
  int h00  = ((iw1 >> DSP32Mac_h00_bits) & DSP32Mac_h00_mask);
  int op0  = ((iw1 >> DSP32Mac_op0_bits) & DSP32Mac_op0_mask);
  int h11  = ((iw1 >> DSP32Mac_h11_bits) & DSP32Mac_h11_mask);
  int h01  = ((iw1 >> DSP32Mac_h01_bits) & DSP32Mac_h01_mask);

  if (w0 == 0 && w1 == 0 && op1 == 3 && op0 == 3)
    return 0;

  if (op1 == 3 && MM)
    return 0;

  if ((w1 || w0) && mmod == M_W32)
    return 0;

  if (((1 << mmod) & (P ? 0x131b : 0x1b5f)) == 0)
    return 0;

  if (w1 == 1 || op1 != 3)
    {
      if (w1)
	OUTS (outf, P ? dregs (dst + 1) : dregs_hi (dst));

      if (op1 == 3)
	OUTS (outf, " = A1");
      else
	{
	  if (w1)
	    OUTS (outf, " = (");
	  decode_macfunc (1, op1, h01, h11, src0, src1, outf);
	  if (w1)
	    OUTS (outf, ")");
	}

      if (w0 == 1 || op0 != 3)
	{
	  if (MM)
	    OUTS (outf, " (M)");
	  OUTS (outf, ", ");
	}
    }

  if (w0 == 1 || op0 != 3)
    {
      /* Clear MM option since it only matters for MAC1, and if we made
         it this far, we've already shown it or we want to ignore it.  */
      MM = 0;

      if (w0)
	OUTS (outf, P ? dregs (dst) : dregs_lo (dst));

      if (op0 == 3)
	OUTS (outf, " = A0");
      else
	{
	  if (w0)
	    OUTS (outf, " = (");
	  decode_macfunc (0, op0, h00, h10, src0, src1, outf);
	  if (w0)
	    OUTS (outf, ")");
	}
    }

  decode_optmode (mmod, MM, outf);

  return 4;
}

static int
decode_dsp32mult_0 (TIword iw0, TIword iw1, disassemble_info *outf)
{
  /* dsp32mult
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 0 | 0 |.M.| 0 | 1 |.mmod..........|.MM|.P.|.w1|.op1...|
     |.h01|.h11|.w0|.op0...|.h00|.h10|.dst.......|.src0......|.src1..|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int w1   = ((iw0 >> (DSP32Mac_w1_bits - 16)) & DSP32Mac_w1_mask);
  int P    = ((iw0 >> (DSP32Mac_p_bits - 16)) & DSP32Mac_p_mask);
  int MM   = ((iw0 >> (DSP32Mac_MM_bits - 16)) & DSP32Mac_MM_mask);
  int mmod = ((iw0 >> (DSP32Mac_mmod_bits - 16)) & DSP32Mac_mmod_mask);
  int w0   = ((iw1 >> DSP32Mac_w0_bits) & DSP32Mac_w0_mask);
  int src0 = ((iw1 >> DSP32Mac_src0_bits) & DSP32Mac_src0_mask);
  int src1 = ((iw1 >> DSP32Mac_src1_bits) & DSP32Mac_src1_mask);
  int dst  = ((iw1 >> DSP32Mac_dst_bits) & DSP32Mac_dst_mask);
  int h10  = ((iw1 >> DSP32Mac_h10_bits) & DSP32Mac_h10_mask);
  int h00  = ((iw1 >> DSP32Mac_h00_bits) & DSP32Mac_h00_mask);
  int h11  = ((iw1 >> DSP32Mac_h11_bits) & DSP32Mac_h11_mask);
  int h01  = ((iw1 >> DSP32Mac_h01_bits) & DSP32Mac_h01_mask);

  if (w1 == 0 && w0 == 0)
    return 0;

  if (((1 << mmod) & (P ? 0x313 : 0x1b57)) == 0)
    return 0;

  if (w1)
    {
      OUTS (outf, P ? dregs (dst + 1) : dregs_hi (dst));
      OUTS (outf, " = ");
      decode_multfunc (h01, h11, src0, src1, outf);

      if (w0)
	{
	  if (MM)
	    OUTS (outf, " (M)");
	  MM = 0;
	  OUTS (outf, ", ");
	}
    }

  if (w0)
    {
      OUTS (outf, P ? dregs (dst) : dregs_lo (dst));
      OUTS (outf, " = ");
      decode_multfunc (h00, h10, src0, src1, outf);
    }

  decode_optmode (mmod, MM, outf);
  return 4;
}

static int
decode_dsp32alu_0 (TIword iw0, TIword iw1, disassemble_info *outf)
{
  /* dsp32alu
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 0 | 0 |.M.| 1 | 0 | - | - | - |.HL|.aopcde............|
     |.aop...|.s.|.x.|.dst0......|.dst1......|.src0......|.src1......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int s    = ((iw1 >> DSP32Alu_s_bits) & DSP32Alu_s_mask);
  int x    = ((iw1 >> DSP32Alu_x_bits) & DSP32Alu_x_mask);
  int aop  = ((iw1 >> DSP32Alu_aop_bits) & DSP32Alu_aop_mask);
  int src0 = ((iw1 >> DSP32Alu_src0_bits) & DSP32Alu_src0_mask);
  int src1 = ((iw1 >> DSP32Alu_src1_bits) & DSP32Alu_src1_mask);
  int dst0 = ((iw1 >> DSP32Alu_dst0_bits) & DSP32Alu_dst0_mask);
  int dst1 = ((iw1 >> DSP32Alu_dst1_bits) & DSP32Alu_dst1_mask);
  int HL   = ((iw0 >> (DSP32Alu_HL_bits - 16)) & DSP32Alu_HL_mask);
  int aopcde = ((iw0 >> (DSP32Alu_aopcde_bits - 16)) & DSP32Alu_aopcde_mask);

  if (aop == 0 && aopcde == 9 && HL == 0 && s == 0)
    {
      OUTS (outf, "A0.L = ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (aop == 2 && aopcde == 9 && HL == 1 && s == 0)
    {
      OUTS (outf, "A1.H = ");
      OUTS (outf, dregs_hi (src0));
    }
  else if (aop == 2 && aopcde == 9 && HL == 0 && s == 0)
    {
      OUTS (outf, "A1.L = ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (aop == 0 && aopcde == 9 && HL == 1 && s == 0)
    {
      OUTS (outf, "A0.H = ");
      OUTS (outf, dregs_hi (src0));
    }
  else if (x == 1 && HL == 1 && aop == 3 && aopcde == 5)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " (RND20)");
    }
  else if (x == 1 && HL == 1 && aop == 2 && aopcde == 5)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " (RND20)");
    }
  else if (x == 0 && HL == 0 && aop == 1 && aopcde == 5)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " (RND12)");
    }
  else if (x == 0 && HL == 0 && aop == 0 && aopcde == 5)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " (RND12)");
    }
  else if (x == 1 && HL == 0 && aop == 3 && aopcde == 5)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " (RND20)");
    }
  else if (x == 0 && HL == 1 && aop == 0 && aopcde == 5)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " (RND12)");
    }
  else if (x == 1 && HL == 0 && aop == 2 && aopcde == 5)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " (RND20)");
    }
  else if (x == 0 && HL == 1 && aop == 1 && aopcde == 5)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " (RND12)");
    }
  else if (HL == 1 && aop == 0 && aopcde == 2)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs_lo (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 1 && aop == 1 && aopcde == 2)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs_hi (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 1 && aop == 2 && aopcde == 2)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs_lo (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 1 && aop == 3 && aopcde == 2)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs_hi (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 0 && aop == 0 && aopcde == 3)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs_lo (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 0 && aop == 1 && aopcde == 3)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs_hi (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 0 && aop == 3 && aopcde == 2)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs_hi (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 1 && aop == 0 && aopcde == 3)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs_lo (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 1 && aop == 1 && aopcde == 3)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs_hi (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 1 && aop == 2 && aopcde == 3)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs_lo (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 1 && aop == 3 && aopcde == 3)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs_hi (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 0 && aop == 2 && aopcde == 2)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs_lo (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 0 && aop == 1 && aopcde == 2)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs_hi (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 0 && aop == 2 && aopcde == 3)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs_lo (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 0 && aop == 3 && aopcde == 3)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs_hi (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 0 && aop == 0 && aopcde == 2)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs_lo (src1));
      amod1 (s, x, outf);
    }
  else if (aop == 0 && aopcde == 9 && s == 1)
    {
      OUTS (outf, "A0 = ");
      OUTS (outf, dregs (src0));
    }
  else if (aop == 3 && aopcde == 11 && s == 0)
    OUTS (outf, "A0 -= A1");

  else if (aop == 3 && aopcde == 11 && s == 1)
    OUTS (outf, "A0 -= A1 (W32)");

  else if (aop == 1 && aopcde == 22 && HL == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP2P (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (TH");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
  else if (aop == 1 && aopcde == 22 && HL == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP2P (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (TL");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
  else if (aop == 0 && aopcde == 22 && HL == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP2P (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (RNDH");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
  else if (aop == 0 && aopcde == 22 && HL == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP2P (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (RNDL");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
  else if (aop == 0 && s == 0 && aopcde == 8)
    OUTS (outf, "A0 = 0");

  else if (aop == 0 && s == 1 && aopcde == 8)
    OUTS (outf, "A0 = A0 (S)");

  else if (aop == 1 && s == 0 && aopcde == 8)
    OUTS (outf, "A1 = 0");

  else if (aop == 1 && s == 1 && aopcde == 8)
    OUTS (outf, "A1 = A1 (S)");

  else if (aop == 2 && s == 0 && aopcde == 8)
    OUTS (outf, "A1 = A0 = 0");

  else if (aop == 2 && s == 1 && aopcde == 8)
    OUTS (outf, "A1 = A1 (S), A0 = A0 (S)");

  else if (aop == 3 && s == 0 && aopcde == 8)
    OUTS (outf, "A0 = A1");

  else if (aop == 3 && s == 1 && aopcde == 8)
    OUTS (outf, "A1 = A0");

  else if (aop == 1 && aopcde == 9 && s == 0)
    {
      OUTS (outf, "A0.X = ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (aop == 1 && HL == 0 && aopcde == 11)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = (A0 += A1)");
    }
  else if (aop == 3 && HL == 0 && aopcde == 16)
    OUTS (outf, "A1 = ABS A1, A0 = ABS A0");

  else if (aop == 0 && aopcde == 23 && HL == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP3P (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (HI");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
  else if (aop == 3 && aopcde == 9 && s == 0)
    {
      OUTS (outf, "A1.X = ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (aop == 1 && HL == 1 && aopcde == 16)
    OUTS (outf, "A1 = ABS A1");

  else if (aop == 0 && HL == 1 && aopcde == 16)
    OUTS (outf, "A1 = ABS A0");

  else if (aop == 2 && aopcde == 9 && s == 1)
    {
      OUTS (outf, "A1 = ");
      OUTS (outf, dregs (src0));
    }
  else if (HL == 0 && aop == 3 && aopcde == 12)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " (RND)");
    }
  else if (aop == 1 && HL == 0 && aopcde == 16)
    OUTS (outf, "A0 = ABS A1");

  else if (aop == 0 && HL == 0 && aopcde == 16)
    OUTS (outf, "A0 = ABS A0");

  else if (aop == 3 && HL == 0 && aopcde == 15)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = -");
      OUTS (outf, dregs (src0));
      OUTS (outf, " (V)");
    }
  else if (aop == 3 && s == 1 && HL == 0 && aopcde == 7)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = -");
      OUTS (outf, dregs (src0));
      OUTS (outf, " (S)");
    }
  else if (aop == 3 && s == 0 && HL == 0 && aopcde == 7)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = -");
      OUTS (outf, dregs (src0));
      OUTS (outf, " (NS)");
    }
  else if (aop == 1 && HL == 1 && aopcde == 11)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = (A0 += A1)");
    }
  else if (aop == 2 && aopcde == 11 && s == 0)
    OUTS (outf, "A0 += A1");

  else if (aop == 2 && aopcde == 11 && s == 1)
    OUTS (outf, "A0 += A1 (W32)");

  else if (aop == 3 && HL == 0 && aopcde == 14)
    OUTS (outf, "A1 = -A1, A0 = -A0");

  else if (HL == 1 && aop == 3 && aopcde == 12)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " (RND)");
    }
  else if (aop == 0 && aopcde == 23 && HL == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP3P (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (LO");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
  else if (aop == 0 && HL == 0 && aopcde == 14)
    OUTS (outf, "A0 = -A0");

  else if (aop == 1 && HL == 0 && aopcde == 14)
    OUTS (outf, "A0 = -A1");

  else if (aop == 0 && HL == 1 && aopcde == 14)
    OUTS (outf, "A1 = -A0");

  else if (aop == 1 && HL == 1 && aopcde == 14)
    OUTS (outf, "A1 = -A1");

  else if (aop == 0 && aopcde == 12)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = SIGN (");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, ") * ");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, " + SIGN (");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, ") * ");
      OUTS (outf, dregs_lo (src1));
    }
  else if (aop == 2 && aopcde == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " -|+ ");
      OUTS (outf, dregs (src1));
      amod0 (s, x, outf);
    }
  else if (aop == 1 && aopcde == 12)
    {
      OUTS (outf, dregs (dst1));
      OUTS (outf, " = A1.L + A1.H, ");
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = A0.L + A0.H");
    }
  else if (aop == 2 && aopcde == 4)
    {
      OUTS (outf, dregs (dst1));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs (src1));
      amod1 (s, x, outf);
    }
  else if (HL == 0 && aopcde == 1)
    {
      OUTS (outf, dregs (dst1));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " +|+ ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " -|- ");
      OUTS (outf, dregs (src1));
      amod0amod2 (s, x, aop, outf);
    }
  else if (aop == 0 && aopcde == 11)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = (A0 += A1)");
    }
  else if (aop == 0 && aopcde == 10)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = A0.X");
    }
  else if (aop == 1 && aopcde == 10)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = A1.X");
    }
  else if (aop == 1 && aopcde == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " +|- ");
      OUTS (outf, dregs (src1));
      amod0 (s, x, outf);
    }
  else if (aop == 3 && aopcde == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " -|- ");
      OUTS (outf, dregs (src1));
      amod0 (s, x, outf);
    }
  else if (aop == 1 && aopcde == 4)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " - ");
      OUTS (outf, dregs (src1));
      amod1 (s, x, outf);
    }
  else if (aop == 0 && aopcde == 17)
    {
      OUTS (outf, dregs (dst1));
      OUTS (outf, " = A1 + A0, ");
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = A1 - A0");
      amod1 (s, x, outf);
    }
  else if (aop == 1 && aopcde == 17)
    {
      OUTS (outf, dregs (dst1));
      OUTS (outf, " = A0 + A1, ");
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = A0 - A1");
      amod1 (s, x, outf);
    }
  else if (aop == 0 && aopcde == 18)
    {
      OUTS (outf, "SAA (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ")");
      aligndir (s, outf);
    }
  else if (aop == 3 && aopcde == 18)
    OUTS (outf, "DISALGNEXCPT");

  else if (aop == 0 && aopcde == 20)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP1P (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ")");
      aligndir (s, outf);
    }
  else if (aop == 1 && aopcde == 20)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP1P (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (T");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
  else if (aop == 0 && aopcde == 21)
    {
      OUTS (outf, "(");
      OUTS (outf, dregs (dst1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (dst0));
      OUTS (outf, ") = BYTEOP16P (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ")");
      aligndir (s, outf);
    }
  else if (aop == 1 && aopcde == 21)
    {
      OUTS (outf, "(");
      OUTS (outf, dregs (dst1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (dst0));
      OUTS (outf, ") = BYTEOP16M (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ")");
      aligndir (s, outf);
    }
  else if (aop == 2 && aopcde == 7)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ABS ");
      OUTS (outf, dregs (src0));
    }
  else if (aop == 1 && aopcde == 7)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = MIN (");
      OUTS (outf, dregs (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ")");
    }
  else if (aop == 0 && aopcde == 7)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = MAX (");
      OUTS (outf, dregs (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ")");
    }
  else if (aop == 2 && aopcde == 6)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ABS ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " (V)");
    }
  else if (aop == 1 && aopcde == 6)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = MIN (");
      OUTS (outf, dregs (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ") (V)");
    }
  else if (aop == 0 && aopcde == 6)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = MAX (");
      OUTS (outf, dregs (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ") (V)");
    }
  else if (HL == 1 && aopcde == 1)
    {
      OUTS (outf, dregs (dst1));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " +|- ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " -|+ ");
      OUTS (outf, dregs (src1));
      amod0amod2 (s, x, aop, outf);
    }
  else if (aop == 0 && aopcde == 4)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " + ");
      OUTS (outf, dregs (src1));
      amod1 (s, x, outf);
    }
  else if (aop == 0 && aopcde == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " +|+ ");
      OUTS (outf, dregs (src1));
      amod0 (s, x, outf);
    }
  else if (aop == 0 && aopcde == 24)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEPACK (");
      OUTS (outf, dregs (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ")");
    }
  else if (aop == 1 && aopcde == 24)
    {
      OUTS (outf, "(");
      OUTS (outf, dregs (dst1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (dst0));
      OUTS (outf, ") = BYTEUNPACK ");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      aligndir (s, outf);
    }
  else if (aopcde == 13)
    {
      OUTS (outf, "(");
      OUTS (outf, dregs (dst1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (dst0));
      OUTS (outf, ") = SEARCH ");
      OUTS (outf, dregs (src0));
      OUTS (outf, " (");
      searchmod (aop, outf);
      OUTS (outf, ")");
    }
  else
    return 0;

  return 4;
}

static int
decode_dsp32shift_0 (TIword iw0, TIword iw1, disassemble_info *outf)
{
  /* dsp32shift
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 0 | 0 |.M.| 1 | 1 | 0 | 0 | - | - |.sopcde............|
     |.sop...|.HLs...|.dst0......| - | - | - |.src0......|.src1......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int HLs  = ((iw1 >> DSP32Shift_HLs_bits) & DSP32Shift_HLs_mask);
  int sop  = ((iw1 >> DSP32Shift_sop_bits) & DSP32Shift_sop_mask);
  int src0 = ((iw1 >> DSP32Shift_src0_bits) & DSP32Shift_src0_mask);
  int src1 = ((iw1 >> DSP32Shift_src1_bits) & DSP32Shift_src1_mask);
  int dst0 = ((iw1 >> DSP32Shift_dst0_bits) & DSP32Shift_dst0_mask);
  int sopcde = ((iw0 >> (DSP32Shift_sopcde_bits - 16)) & DSP32Shift_sopcde_mask);
  const char *acc01 = (HLs & 1) == 0 ? "A0" : "A1";

  if (HLs == 0 && sop == 0 && sopcde == 0)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (HLs == 1 && sop == 0 && sopcde == 0)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (HLs == 2 && sop == 0 && sopcde == 0)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (HLs == 3 && sop == 0 && sopcde == 0)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (HLs == 0 && sop == 1 && sopcde == 0)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " (S)");
    }
  else if (HLs == 1 && sop == 1 && sopcde == 0)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " (S)");
    }
  else if (HLs == 2 && sop == 1 && sopcde == 0)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " (S)");
    }
  else if (HLs == 3 && sop == 1 && sopcde == 0)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " (S)");
    }
  else if (sop == 2 && sopcde == 0)
    {
      OUTS (outf, (HLs & 2) == 0 ? dregs_lo (dst0) : dregs_hi (dst0));
      OUTS (outf, " = LSHIFT ");
      OUTS (outf, (HLs & 1) == 0 ? dregs_lo (src1) : dregs_hi (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (sop == 0 && sopcde == 3)
    {
      OUTS (outf, acc01);
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, acc01);
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (sop == 1 && sopcde == 3)
    {
      OUTS (outf, acc01);
      OUTS (outf, " = LSHIFT ");
      OUTS (outf, acc01);
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (sop == 2 && sopcde == 3)
    {
      OUTS (outf, acc01);
      OUTS (outf, " = ROT ");
      OUTS (outf, acc01);
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (sop == 3 && sopcde == 3)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ROT ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (sop == 1 && sopcde == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " (V, S)");
    }
  else if (sop == 0 && sopcde == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " (V)");
    }
  else if (sop == 0 && sopcde == 2)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (sop == 1 && sopcde == 2)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ASHIFT ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " (S)");
    }
  else if (sop == 2 && sopcde == 2)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = LSHIFT ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (sop == 3 && sopcde == 2)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ROT ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
    }
  else if (sop == 2 && sopcde == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = LSHIFT ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " BY ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, " (V)");
    }
  else if (sop == 0 && sopcde == 4)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = PACK (");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, ")");
    }
  else if (sop == 1 && sopcde == 4)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = PACK (");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, ")");
    }
  else if (sop == 2 && sopcde == 4)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = PACK (");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, ")");
    }
  else if (sop == 3 && sopcde == 4)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = PACK (");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs_hi (src0));
      OUTS (outf, ")");
    }
  else if (sop == 0 && sopcde == 5)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = SIGNBITS ");
      OUTS (outf, dregs (src1));
    }
  else if (sop == 1 && sopcde == 5)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = SIGNBITS ");
      OUTS (outf, dregs_lo (src1));
    }
  else if (sop == 2 && sopcde == 5)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = SIGNBITS ");
      OUTS (outf, dregs_hi (src1));
    }
  else if (sop == 0 && sopcde == 6)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = SIGNBITS A0");
    }
  else if (sop == 1 && sopcde == 6)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = SIGNBITS A1");
    }
  else if (sop == 3 && sopcde == 6)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = ONES ");
      OUTS (outf, dregs (src1));
    }
  else if (sop == 0 && sopcde == 7)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = EXPADJ (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, ")");
    }
  else if (sop == 1 && sopcde == 7)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = EXPADJ (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, ") (V)");
    }
  else if (sop == 2 && sopcde == 7)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = EXPADJ (");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, ")");
    }
  else if (sop == 3 && sopcde == 7)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = EXPADJ (");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, ")");
    }
  else if (sop == 0 && sopcde == 8)
    {
      OUTS (outf, "BITMUX (");
      OUTS (outf, dregs (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", A0) (ASR)");
    }
  else if (sop == 1 && sopcde == 8)
    {
      OUTS (outf, "BITMUX (");
      OUTS (outf, dregs (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", A0) (ASL)");
    }
  else if (sop == 0 && sopcde == 9)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = VIT_MAX (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ") (ASL)");
    }
  else if (sop == 1 && sopcde == 9)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = VIT_MAX (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ") (ASR)");
    }
  else if (sop == 2 && sopcde == 9)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = VIT_MAX (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src0));
      OUTS (outf, ") (ASL)");
    }
  else if (sop == 3 && sopcde == 9)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = VIT_MAX (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src0));
      OUTS (outf, ") (ASR)");
    }
  else if (sop == 0 && sopcde == 10)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = EXTRACT (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, ") (Z)");
    }
  else if (sop == 1 && sopcde == 10)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = EXTRACT (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs_lo (src0));
      OUTS (outf, ") (X)");
    }
  else if (sop == 2 && sopcde == 10)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = DEPOSIT (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src0));
      OUTS (outf, ")");
    }
  else if (sop == 3 && sopcde == 10)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = DEPOSIT (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src0));
      OUTS (outf, ") (X)");
    }
  else if (sop == 0 && sopcde == 11)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = CC = BXORSHIFT (A0, ");
      OUTS (outf, dregs (src0));
      OUTS (outf, ")");
    }
  else if (sop == 1 && sopcde == 11)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = CC = BXOR (A0, ");
      OUTS (outf, dregs (src0));
      OUTS (outf, ")");
    }
  else if (sop == 0 && sopcde == 12)
    OUTS (outf, "A0 = BXORSHIFT (A0, A1, CC)");

  else if (sop == 1 && sopcde == 12)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, " = CC = BXOR (A0, A1, CC)");
    }
  else if (sop == 0 && sopcde == 13)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ALIGN8 (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src0));
      OUTS (outf, ")");
    }
  else if (sop == 1 && sopcde == 13)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ALIGN16 (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src0));
      OUTS (outf, ")");
    }
  else if (sop == 2 && sopcde == 13)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ALIGN24 (");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src0));
      OUTS (outf, ")");
    }
  else
    return 0;

  return 4;
}

static int
decode_dsp32shiftimm_0 (TIword iw0, TIword iw1, disassemble_info *outf)
{
  /* dsp32shiftimm
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 0 | 0 |.M.| 1 | 1 | 0 | 1 | - | - |.sopcde............|
     |.sop...|.HLs...|.dst0......|.immag.................|.src1......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int src1     = ((iw1 >> DSP32ShiftImm_src1_bits) & DSP32ShiftImm_src1_mask);
  int sop      = ((iw1 >> DSP32ShiftImm_sop_bits) & DSP32ShiftImm_sop_mask);
  int bit8     = ((iw1 >> 8) & 0x1);
  int immag    = ((iw1 >> DSP32ShiftImm_immag_bits) & DSP32ShiftImm_immag_mask);
  int newimmag = (-(iw1 >> DSP32ShiftImm_immag_bits) & DSP32ShiftImm_immag_mask);
  int dst0     = ((iw1 >> DSP32ShiftImm_dst0_bits) & DSP32ShiftImm_dst0_mask);
  int sopcde   = ((iw0 >> (DSP32ShiftImm_sopcde_bits - 16)) & DSP32ShiftImm_sopcde_mask);
  int HLs      = ((iw1 >> DSP32ShiftImm_HLs_bits) & DSP32ShiftImm_HLs_mask);

  if (sop == 0 && sopcde == 0)
    {
      OUTS (outf, (HLs & 2) ? dregs_hi (dst0) : dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, (HLs & 1) ? dregs_hi (src1) : dregs_lo (src1));
      OUTS (outf, " >>> ");
      OUTS (outf, uimm4 (newimmag));
    }
  else if (sop == 1 && sopcde == 0 && bit8 == 0)
    {
      OUTS (outf, (HLs & 2) ? dregs_hi (dst0) : dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, (HLs & 1) ? dregs_hi (src1) : dregs_lo (src1));
      OUTS (outf, " << ");
      OUTS (outf, uimm4 (immag));
      OUTS (outf, " (S)");
    }
  else if (sop == 1 && sopcde == 0 && bit8 == 1)
    {
      OUTS (outf, (HLs & 2) ? dregs_hi (dst0) : dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, (HLs & 1) ? dregs_hi (src1) : dregs_lo (src1));
      OUTS (outf, " >>> ");
      OUTS (outf, uimm4 (newimmag));
      OUTS (outf, " (S)");
    }
  else if (sop == 2 && sopcde == 0 && bit8 == 0)
    {
      OUTS (outf, (HLs & 2) ? dregs_hi (dst0) : dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, (HLs & 1) ? dregs_hi (src1) : dregs_lo (src1));
      OUTS (outf, " << ");
      OUTS (outf, uimm4 (immag));
    }
  else if (sop == 2 && sopcde == 0 && bit8 == 1)
    {
      OUTS (outf, (HLs & 2) ? dregs_hi (dst0) : dregs_lo (dst0));
      OUTS (outf, " = ");
      OUTS (outf, (HLs & 1) ? dregs_hi (src1) : dregs_lo (src1));
      OUTS (outf, " >> ");
      OUTS (outf, uimm4 (newimmag));
    }
  else if (sop == 2 && sopcde == 3 && HLs == 1)
    {
      OUTS (outf, "A1 = ROT A1 BY ");
      OUTS (outf, imm6 (immag));
    }
  else if (sop == 0 && sopcde == 3 && HLs == 0 && bit8 == 0)
    {
      OUTS (outf, "A0 = A0 << ");
      OUTS (outf, uimm5 (immag));
    }
  else if (sop == 0 && sopcde == 3 && HLs == 0 && bit8 == 1)
    {
      OUTS (outf, "A0 = A0 >>> ");
      OUTS (outf, uimm5 (newimmag));
    }
  else if (sop == 0 && sopcde == 3 && HLs == 1 && bit8 == 0)
    {
      OUTS (outf, "A1 = A1 << ");
      OUTS (outf, uimm5 (immag));
    }
  else if (sop == 0 && sopcde == 3 && HLs == 1 && bit8 == 1)
    {
      OUTS (outf, "A1 = A1 >>> ");
      OUTS (outf, uimm5 (newimmag));
    }
  else if (sop == 1 && sopcde == 3 && HLs == 0)
    {
      OUTS (outf, "A0 = A0 >> ");
      OUTS (outf, uimm5 (newimmag));
    }
  else if (sop == 1 && sopcde == 3 && HLs == 1)
    {
      OUTS (outf, "A1 = A1 >> ");
      OUTS (outf, uimm5 (newimmag));
    }
  else if (sop == 2 && sopcde == 3 && HLs == 0)
    {
      OUTS (outf, "A0 = ROT A0 BY ");
      OUTS (outf, imm6 (immag));
    }
  else if (sop == 1 && sopcde == 1 && bit8 == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " << ");
      OUTS (outf, uimm5 (immag));
      OUTS (outf, " (V, S)");
    }
  else if (sop == 1 && sopcde == 1 && bit8 == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " >>> ");
      OUTS (outf, imm5 (-immag));
      OUTS (outf, " (V, S)");
    }
  else if (sop == 2 && sopcde == 1 && bit8 == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " >> ");
      OUTS (outf, uimm5 (newimmag));
      OUTS (outf, " (V)");
    }
  else if (sop == 2 && sopcde == 1 && bit8 == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " << ");
      OUTS (outf, imm5 (immag));
      OUTS (outf, " (V)");
    }
  else if (sop == 0 && sopcde == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " >>> ");
      OUTS (outf, uimm5 (newimmag));
      OUTS (outf, " (V)");
    }
  else if (sop == 1 && sopcde == 2)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " << ");
      OUTS (outf, uimm5 (immag));
      OUTS (outf, " (S)");
    }
  else if (sop == 2 && sopcde == 2 && bit8 == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " >> ");
      OUTS (outf, uimm5 (newimmag));
    }
  else if (sop == 2 && sopcde == 2 && bit8 == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " << ");
      OUTS (outf, uimm5 (immag));
    }
  else if (sop == 3 && sopcde == 2)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ROT ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " BY ");
      OUTS (outf, imm6 (immag));
    }
  else if (sop == 0 && sopcde == 2)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = ");
      OUTS (outf, dregs (src1));
      OUTS (outf, " >>> ");
      OUTS (outf, uimm5 (newimmag));
    }
  else
    return 0;

  return 4;
}

static int
decode_pseudoDEBUG_0 (TIword iw0, disassemble_info *outf)
{
  /* pseudoDEBUG
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |.fn....|.grp.......|.reg.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int fn  = ((iw0 >> PseudoDbg_fn_bits) & PseudoDbg_fn_mask);
  int grp = ((iw0 >> PseudoDbg_grp_bits) & PseudoDbg_grp_mask);
  int reg = ((iw0 >> PseudoDbg_reg_bits) & PseudoDbg_reg_mask);

  if (parallel)
    return 0;

  if (reg == 0 && fn == 3)
    OUTS (outf, "DBG A0");

  else if (reg == 1 && fn == 3)
    OUTS (outf, "DBG A1");

  else if (reg == 3 && fn == 3)
    OUTS (outf, "ABORT");

  else if (reg == 4 && fn == 3)
    OUTS (outf, "HLT");

  else if (reg == 5 && fn == 3)
    OUTS (outf, "DBGHALT");

  else if (reg == 6 && fn == 3)
    {
      OUTS (outf, "DBGCMPLX (");
      OUTS (outf, dregs (grp));
      OUTS (outf, ")");
    }
  else if (reg == 7 && fn == 3)
    OUTS (outf, "DBG");

  else if (grp == 0 && fn == 2)
    {
      OUTS (outf, "OUTC ");
      OUTS (outf, dregs (reg));
    }
  else if (fn == 0)
    {
      OUTS (outf, "DBG ");
      OUTS (outf, allregs (reg, grp));
    }
  else if (fn == 1)
    {
      OUTS (outf, "PRNT ");
      OUTS (outf, allregs (reg, grp));
    }
  else
    return 0;

  return 2;
}

static int
decode_pseudoOChar_0 (TIword iw0, disassemble_info *outf)
{
  /* psedoOChar
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 |.ch............................|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int ch = ((iw0 >> PseudoChr_ch_bits) & PseudoChr_ch_mask);

  if (parallel)
    return 0;

  OUTS (outf, "OUTC ");
  OUTS (outf, uimm8 (ch));

  return 2;
}

static int
decode_pseudodbg_assert_0 (TIword iw0, TIword iw1, disassemble_info *outf)
{
  /* pseudodbg_assert
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 1 | 1 | 0 | - | - | - | dbgop |.grp.......|.regtest...|
     |.expected......................................................|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int expected = ((iw1 >> PseudoDbg_Assert_expected_bits) & PseudoDbg_Assert_expected_mask);
  int dbgop    = ((iw0 >> (PseudoDbg_Assert_dbgop_bits - 16)) & PseudoDbg_Assert_dbgop_mask);
  int grp      = ((iw0 >> (PseudoDbg_Assert_grp_bits - 16)) & PseudoDbg_Assert_grp_mask);
  int regtest  = ((iw0 >> (PseudoDbg_Assert_regtest_bits - 16)) & PseudoDbg_Assert_regtest_mask);

  if (parallel)
    return 0;

  if (dbgop == 0)
    {
      OUTS (outf, "DBGA (");
      OUTS (outf, regs_lo (regtest, grp));
      OUTS (outf, ", ");
      OUTS (outf, uimm16 (expected));
      OUTS (outf, ")");
    }
  else if (dbgop == 1)
    {
      OUTS (outf, "DBGA (");
      OUTS (outf, regs_hi (regtest, grp));
      OUTS (outf, ", ");
      OUTS (outf, uimm16 (expected));
      OUTS (outf, ")");
    }
  else if (dbgop == 2)
    {
      OUTS (outf, "DBGAL (");
      OUTS (outf, allregs (regtest, grp));
      OUTS (outf, ", ");
      OUTS (outf, uimm16 (expected));
      OUTS (outf, ")");
    }
  else if (dbgop == 3)
    {
      OUTS (outf, "DBGAH (");
      OUTS (outf, allregs (regtest, grp));
      OUTS (outf, ", ");
      OUTS (outf, uimm16 (expected));
      OUTS (outf, ")");
    }
  else
    return 0;
  return 4;
}

static int
_print_insn_bfin (bfd_vma pc, disassemble_info *outf)
{
  bfd_byte buf[4];
  TIword iw0;
  TIword iw1;
  int status;
  int rv = 0;

  status = (*outf->read_memory_func) (pc & ~0x1, buf, 2, outf);
  /* FIXME */
  (void) status;
  status = (*outf->read_memory_func) ((pc + 2) & ~0x1, buf + 2, 2, outf);
  /* FIXME */
  (void) status;

  iw0 = bfd_getl16 (buf);
  iw1 = bfd_getl16 (buf + 2);

  if ((iw0 & 0xf7ff) == 0xc003 && iw1 == 0x1800)
    {
      if (parallel)
	{
	  OUTS (outf, "ILLEGAL");
	  return 0;
	}
      OUTS (outf, "MNOP");
      return 4;
    }
  else if ((iw0 & 0xff00) == 0x0000)
    rv = decode_ProgCtrl_0 (iw0, outf);
  else if ((iw0 & 0xffc0) == 0x0240)
    rv = decode_CaCTRL_0 (iw0, outf);
  else if ((iw0 & 0xff80) == 0x0100)
    rv = decode_PushPopReg_0 (iw0, outf);
  else if ((iw0 & 0xfe00) == 0x0400)
    rv = decode_PushPopMultiple_0 (iw0, outf);
  else if ((iw0 & 0xfe00) == 0x0600)
    rv = decode_ccMV_0 (iw0, outf);
  else if ((iw0 & 0xf800) == 0x0800)
    rv = decode_CCflag_0 (iw0, outf);
  else if ((iw0 & 0xffe0) == 0x0200)
    rv = decode_CC2dreg_0 (iw0, outf);
  else if ((iw0 & 0xff00) == 0x0300)
    rv = decode_CC2stat_0 (iw0, outf);
  else if ((iw0 & 0xf000) == 0x1000)
    rv = decode_BRCC_0 (iw0, pc, outf);
  else if ((iw0 & 0xf000) == 0x2000)
    rv = decode_UJUMP_0 (iw0, pc, outf);
  else if ((iw0 & 0xf000) == 0x3000)
    rv = decode_REGMV_0 (iw0, outf);
  else if ((iw0 & 0xfc00) == 0x4000)
    rv = decode_ALU2op_0 (iw0, outf);
  else if ((iw0 & 0xfe00) == 0x4400)
    rv = decode_PTR2op_0 (iw0, outf);
  else if ((iw0 & 0xf800) == 0x4800)
    rv = decode_LOGI2op_0 (iw0, outf);
  else if ((iw0 & 0xf000) == 0x5000)
    rv = decode_COMP3op_0 (iw0, outf);
  else if ((iw0 & 0xf800) == 0x6000)
    rv = decode_COMPI2opD_0 (iw0, outf);
  else if ((iw0 & 0xf800) == 0x6800)
    rv = decode_COMPI2opP_0 (iw0, outf);
  else if ((iw0 & 0xf000) == 0x8000)
    rv = decode_LDSTpmod_0 (iw0, outf);
  else if ((iw0 & 0xff60) == 0x9e60)
    rv = decode_dagMODim_0 (iw0, outf);
  else if ((iw0 & 0xfff0) == 0x9f60)
    rv = decode_dagMODik_0 (iw0, outf);
  else if ((iw0 & 0xfc00) == 0x9c00)
    rv = decode_dspLDST_0 (iw0, outf);
  else if ((iw0 & 0xf000) == 0x9000)
    rv = decode_LDST_0 (iw0, outf);
  else if ((iw0 & 0xfc00) == 0xb800)
    rv = decode_LDSTiiFP_0 (iw0, outf);
  else if ((iw0 & 0xe000) == 0xA000)
    rv = decode_LDSTii_0 (iw0, outf);
  else if ((iw0 & 0xff80) == 0xe080 && (iw1 & 0x0C00) == 0x0000)
    rv = decode_LoopSetup_0 (iw0, iw1, pc, outf);
  else if ((iw0 & 0xff00) == 0xe100 && (iw1 & 0x0000) == 0x0000)
    rv = decode_LDIMMhalf_0 (iw0, iw1, outf);
  else if ((iw0 & 0xfe00) == 0xe200 && (iw1 & 0x0000) == 0x0000)
    rv = decode_CALLa_0 (iw0, iw1, pc, outf);
  else if ((iw0 & 0xfc00) == 0xe400 && (iw1 & 0x0000) == 0x0000)
    rv = decode_LDSTidxI_0 (iw0, iw1, outf);
  else if ((iw0 & 0xfffe) == 0xe800 && (iw1 & 0x0000) == 0x0000)
    rv = decode_linkage_0 (iw0, iw1, outf);
  else if ((iw0 & 0xf600) == 0xc000 && (iw1 & 0x0000) == 0x0000)
    rv = decode_dsp32mac_0 (iw0, iw1, outf);
  else if ((iw0 & 0xf600) == 0xc200 && (iw1 & 0x0000) == 0x0000)
    rv = decode_dsp32mult_0 (iw0, iw1, outf);
  else if ((iw0 & 0xf7c0) == 0xc400 && (iw1 & 0x0000) == 0x0000)
    rv = decode_dsp32alu_0 (iw0, iw1, outf);
  else if ((iw0 & 0xf780) == 0xc600 && (iw1 & 0x01c0) == 0x0000)
    rv = decode_dsp32shift_0 (iw0, iw1, outf);
  else if ((iw0 & 0xf780) == 0xc680 && (iw1 & 0x0000) == 0x0000)
    rv = decode_dsp32shiftimm_0 (iw0, iw1, outf);
  else if ((iw0 & 0xff00) == 0xf800)
    rv = decode_pseudoDEBUG_0 (iw0, outf);
  else if ((iw0 & 0xFF00) == 0xF900)
    rv = decode_pseudoOChar_0 (iw0, outf);
  else if ((iw0 & 0xFF00) == 0xf000 && (iw1 & 0x0000) == 0x0000)
    rv = decode_pseudodbg_assert_0 (iw0, iw1, outf);

  if (rv == 0)
    OUTS (outf, "ILLEGAL");

  return rv;
}

int
print_insn_bfin (bfd_vma pc, disassemble_info *outf)
{
  bfd_byte buf[2];
  unsigned short iw0;
  int status;
  int count = 0;

  status = (*outf->read_memory_func) (pc & ~0x01, buf, 2, outf);
  /* FIXME */
  (void) status;
  iw0 = bfd_getl16 (buf);

  count += _print_insn_bfin (pc, outf);

  /* Proper display of multiple issue instructions.  */

  if (count == 4 && (iw0 & 0xc000) == 0xc000 && (iw0 & BIT_MULTI_INS)
      && ((iw0 & 0xe800) != 0xe800 /* Not Linkage.  */ ))
    {
      int legal = 1;
      int len;

      parallel = 1;
      OUTS (outf, " || ");
      len = _print_insn_bfin (pc + 4, outf);
      OUTS (outf, " || ");
      if (len != 2)
	legal = 0;
      len = _print_insn_bfin (pc + 6, outf);
      if (len != 2)
	legal = 0;

      if (legal)
	count = 8;
      else
	{
	  OUTS (outf, ";\t\t/* ILLEGAL PARALLEL INSTRUCTION */");
	  comment = 1;
	  count = 0;
	}
      parallel = 0;
    }

  if (!comment)
    OUTS (outf, ";");

  if (count == 0)
    return 2;

  comment = 0;

  return count;
}
@


1.43
log
@opcodes: bfin: simplify field width processing and fix build warnings

This fix the build time warning:
warning: format not a string literal, argument types not checked [-Wformat-nonliteral]

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008, 2009, 2010, 2011
d22 1
a23 2
#include <stdlib.h>
#include <string.h>
@


1.42
log
@opcodes: blackfin: ignore (M) on MAC0-only dsp mac funcs

If the MAC1 part of the insn is disabled, then the (M) flag is ignored.
Rather than include it in the decode, move the MM clearing to the MAC0
portion of the code.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d165 1
a165 10
    {
      if (constant_formats[cf].leading)
	{
	  char ps[10];
	  sprintf (ps, "%%%ii", constant_formats[cf].leading);
	  sprintf (buf, ps, x);
	}
      else
	sprintf (buf, "%li", x);
    }
@


1.41
log
@opcodes: blackfin: drop null/nul checks in OUTS

Parts of the disassembler rely on the disasm info never being NULL (such
as being able to read memory to disassemble in the first place).  So drop
useless null checks in the OUTS helper.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@a3012 1
	  MM = 0;
d3019 4
@


1.40
log
@opcodes: blackfin: use OUTS helper

We have an OUTS helper to handle outf fprintf_func logic, so conver the
few places not using it over.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d493 1
a493 1
#define OUTS(p, txt) ((p) ? (((txt)[0]) ? (p->fprintf_func)(p->stream, "%s", txt) :0) :0)
@


1.39
log
@opcodes: blackfin: clean up saved_state

Mark the state static, punt unused members, unify indexable register
lookups, and abort when there is a register lookup failure.  Otherwise
we return NULL and the calling code assumes a valid pointer is returned.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d4784 1
a4784 1
      outf->fprintf_func (outf->stream, " || ");
d4786 1
a4786 1
      outf->fprintf_func (outf->stream, " || ");
d4797 1
a4797 1
	  outf->fprintf_func (outf->stream, ";\t\t/* ILLEGAL PARALLEL INSTRUCTION */");
d4805 1
a4805 1
    outf->fprintf_func (outf->stream, ";");
@


1.38
log
@opcodes: blackfin: fix style

Non-functional thrashing to the GNU style.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d657 1
a657 1
struct saved_state
d660 1
a660 1
  bu32 a0x, a0w, a1x, a1w;
d662 1
a662 16
  int ac0, ac0_copy, ac1, an, aq;
  int av0, av0s, av1, av1s, az, cc, v, v_copy, vs;
  int rnd_mod;
  int v_internal;
  bu32 pc, rets;

  int ticks;
  int insts;

  int exception;

  int end_of_registers;

  int msize;
  unsigned char *memory;
  unsigned long bfd_mach;
d676 5
a680 11
#define A0XREG          (saved_state.a0x)
#define A0WREG          (saved_state.a0w)
#define A1XREG          (saved_state.a1x)
#define A1WREG          (saved_state.a1w)
#define CCREG           (saved_state.cc)
#define LC0REG          (saved_state.lc[0])
#define LT0REG          (saved_state.lt[0])
#define LB0REG          (saved_state.lb[0])
#define LC1REG          (saved_state.lc[1])
#define LT1REG          (saved_state.lt[1])
#define LB1REG          (saved_state.lb[1])
a681 1
#define PCREG           (saved_state.pc)
d699 6
a704 6
    case 0: case 1: return &DREG (reg); break;
    case 2: case 3: return &PREG (reg); break;
    case 4: return &IREG (reg & 3); break;
    case 5: return &MREG (reg & 3); break;
    case 6: return &BREG (reg & 3); break;
    case 7: return &LREG (reg & 3); break;
d708 11
a718 11
	case 32: return &saved_state.a0x;
	case 33: return &saved_state.a0w;
	case 34: return &saved_state.a1x;
	case 35: return &saved_state.a1w;
	case 39: return &saved_state.rets;
	case 48: return &LC0REG;
	case 49: return &LT0REG;
	case 50: return &LB0REG;
	case 51: return &LC1REG;
	case 52: return &LT1REG;
	case 53: return &LB1REG;
a719 1
      return 0;
d721 1
@


1.37
log
@opcodes: blackfin: catch invalid loopsetup insns

The LoopSetup insn is only valid when the reg field is 0-7, so
don't go decoding it incorrectly when reg is 8-15.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d132 2
a133 2
     /* truncate to 32-bits for proper symbol lookup/matching */
     ea = (bu32)ea;
d135 2
a136 2
     if (outf->symbol_at_address_func (ea, outf) || !constant_formats[cf].exact)
       {
d139 3
a141 3
       }
     else
       {
d144 1
a144 1
       }
d322 1
a322 1
#define dregs_hilo(x,i)	REGNAME (decode_dregs_hilo[((i) << 3)|x])
d361 1
a361 1
#define gregs(x,i) REGNAME (decode_gregs[((i) << 3)|x])
d372 1
a372 1
#define regs(x,i) REGNAME (decode_regs[((i) << 3)|x])
d383 2
a384 1
#define regs_lo(x,i) REGNAME (decode_regs_lo[((i) << 3)|x])
d394 1
a394 1
#define regs_hi(x,i) REGNAME (decode_regs_hi[((i) << 3)|x])
d447 1
a447 1
#define allregs(x,i)	REGNAME (decode_allregs[((i) << 3) | x])
d564 1
a564 1
decode_multfunc (int h0, int h1, int src0, int src1, disassemble_info * outf)
d585 1
a585 1
decode_macfunc (int which, int op, int h0, int h1, int src0, int src1, disassemble_info * outf)
d678 1
a678 1
}  saved_state;
d681 1
a681 1
#define GREG(x,i)       DPREG ((x) | (i << 3))
d684 1
a684 1
#define PREG(x)         (saved_state.dpregs[x + 8])
d1383 1
a1383 1
 /* Reserved slots cannot be a src/dst.  */
d2090 6
a2095 6
 if (! parallel )
   {
     OUTS (outf, ";\t\t/* (  ");
     if (op == 0 || op == 1)
       OUTS (outf, "2");
     else if (op == 2 || op == 3)
d2097 3
a2099 3
     OUTS (outf, ") */");
    comment = 1;
  }
d2743 1
a2743 1
   {
d2800 8
a2807 8
       OUTS (outf, ";\t\t/*\t\t");
       OUTS (outf, regs (reg, grp));
       OUTS (outf, "=0x");
       OUTS (outf, huimm32e (*pval));
       OUTS (outf, "(");
       OUTS (outf, imm32 (*pval));
       OUTS (outf, ") */");
       comment = 1;
a4367 1

d4695 2
a4696 2
	   OUTS (outf, "ILLEGAL");
	   return 0;
a4781 1

d4810 1
a4810 1
	  legal = 0;
@


1.36
log
@opcodes: blackfin: fix decoding of ABS

The single cycle dual mac ABS insn was incorrectly decoding the mac1
part of the insn.

Once we fix the decode, update the gas tests to have the correct output.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2626 3
@


1.35
log
@opcodes: blackfin: fix decoding of dsp mult insns

When assigning to a register half, the mac0 part of the mult insn
was not decoding properly.  It would always show a full dreg instead
of the dreg low half.

Once we fix the disassembler, we have to update a few of the gas
tests as their previous expected output was incorrect.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3479 1
a3479 1
    OUTS (outf, "A1 = ABS A0, A0 = ABS A0");
@


1.34
log
@gas/opcodes: blackfin: punt BYTEOP2M insn support

The BYTEOP2M insn was part of the initial Blackfin designs, but never made
it into any actual silicon.  So punt support for it.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3087 1
a3087 1
      OUTS (outf, P ? dregs (dst | 1) : dregs_hi (dst));
d3102 1
a3102 1
      OUTS (outf, dregs (dst));
@


1.33
log
@opcodes: blackfin: add missing space after PRNT insn

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@a3375 68
  else if (aop == 3 && aopcde == 22 && HL == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP2M (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (TH");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
  else if (aop == 3 && aopcde == 22 && HL == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP2M (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (TL");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
  else if (aop == 2 && aopcde == 22 && HL == 1)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP2M (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (RNDH");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
  else if (aop == 2 && aopcde == 22 && HL == 0)
    {
      OUTS (outf, dregs (dst0));
      OUTS (outf, " = BYTEOP2M (");
      OUTS (outf, dregs (src0 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1 + 1));
      OUTS (outf, ":");
      OUTS (outf, imm5d (src1));
      OUTS (outf, ") (RNDL");
      if (s == 1)
	OUTS (outf, ", R)");
      else
	OUTS (outf, ")");
    }
@


1.32
log
@opcodes: blackfin: drop "GP" register

There never was a "GP" register, so punt it from the decode map.  It's
a hold over from a very old processor definition and never made it into
actual silicon.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d4657 1
a4657 1
      OUTS (outf, "PRNT");
@


1.31
log
@gas/opcodes: blackfin: move dsp mac func defines to common header

The mmod field is decoded in a few places (gas/opcodes/sim), so move it to
a common place to avoid duplication.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d230 1
a230 1
  REG_LC1, REG_GP, REG_ASTAT, REG_RETS, REG_LT0, REG_LB0, REG_LT1, REG_LB1,
d265 1
a265 1
  "LC1", "GP", "ASTAT", "RETS", "LT0", "LB0", "LT1", "LB1",
d426 1
a426 1
  REG_A0x, REG_A0w, REG_A1x, REG_A1w, REG_GP, REG_LASTREG, REG_ASTAT, REG_RETS,
@


1.30
log
@opcodes: blackfin: constify register names

Constify the array itself since it need not be writable.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@a27 10
#define M_S2RND 1
#define M_T     2
#define M_W32   3
#define M_FU    4
#define M_TFU   6
#define M_IS    8
#define M_ISS2  9
#define M_IH    11
#define M_IU    12

@


1.29
log
@gas: blackfin: fix encoding of BYTEOP2M insn

The BYTEOP2M parser incorrectly calls BYTEOP2P to generate the opcode.
Once we've fixed that, it's easy to see that the disassembler also likes
to decode this insn incorrectly.  So fix that and then add some tests.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 2
a3 1
   Copyright 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d262 1
a262 1
static const char *reg_names[] =
d293 1
a293 1
static enum machine_registers decode_dregs_lo[] =
d301 1
a301 1
static enum machine_registers decode_dregs_hi[] =
d309 1
a309 1
static enum machine_registers decode_dregs[] =
d317 1
a317 1
static enum machine_registers decode_dregs_byte[] =
d325 1
a325 1
static enum machine_registers decode_pregs[] =
d338 1
a338 1
static enum machine_registers decode_iregs[] =
d346 1
a346 1
static enum machine_registers decode_mregs[] =
d356 1
a356 1
static enum machine_registers decode_dpregs[] =
d365 1
a365 1
static enum machine_registers decode_gregs[] =
d374 1
a374 1
static enum machine_registers decode_regs[] =
d385 1
a385 1
static enum machine_registers decode_regs_lo[] =
d395 1
a395 1
static enum machine_registers decode_regs_hi[] =
d405 1
a405 1
static enum machine_registers decode_statbits[] =
d420 1
a420 1
static enum machine_registers decode_counters[] =
d430 1
a430 1
static enum machine_registers decode_allregs[] =
@


1.28
log
@opcodes: blackfin: fix decoding of 32bit addresses on 64bit systems

The Blackfin ISA is very exact with regards to address truncation when
under/over flowing its 32bit range.  On a 32bit system, things work the
same and so addresses are decoded properly.  On a 64bit system though,
the decoded addresses may include the bits that are supposed to have
been truncated.  So force a 32bit truncation after the address has been
calculated.

Signed-off-by: Robin Getz <robin.getz@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3391 1
a3391 1
      OUTS (outf, imm5 (src0));
d3395 1
a3395 1
      OUTS (outf, imm5 (src1));
d3408 1
a3408 1
      OUTS (outf, imm5 (src0));
d3412 1
a3412 1
      OUTS (outf, imm5 (src1));
d3425 1
a3425 1
      OUTS (outf, imm5 (src0));
d3429 1
a3429 1
      OUTS (outf, imm5 (src1));
d3442 1
a3442 1
      OUTS (outf, imm5 (src0));
d3446 1
a3446 1
      OUTS (outf, imm5 (src1));
@


1.27
log
@opcodes: blackfin: fix decoding of all register move insns

Many register move insns were not being decoded properly, so rewrite
the whole function to be a bit more manageable in terms of valid
combinations.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d141 3
@


1.26
log
@opcodes: blackfin: fix decoding of many invalid insns

The Blackfin disassembler was originally based on the premise of parsing
valid opcodes all the time, so some of the opcode checking can be a bit
fuzzy.  This is exemplified in decoding of parallel insns where many
times things are decoded as invalid when in reality, they may not be
used in parallel combinations.  So add parallel checking to most insn
decoding routines so we see ILLEGAL and not just whatever insn happens
to be close to a valid mnemonic, as well as some additional sub-opcode
checks.

Signed-off-by: Robin Getz <robin.getz@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d1388 29
a1416 12
  if (!((IS_GENREG (gd, dst) && IS_GENREG (gs, src))
	|| (IS_GENREG (gd, dst) && IS_DAGREG (gs, src))
	|| (IS_DAGREG (gd, dst) && IS_GENREG (gs, src))
	|| (IS_DAGREG (gd, dst) && IS_DAGREG (gs, src))
	|| (IS_GENREG (gd, dst) && gs == 7 && src == 0)
	|| (gd == 7 && dst == 0 && IS_GENREG (gs, src))
	|| (IS_DREG (gd, dst) && IS_SYSREG (gs, src))
	|| (IS_PREG (gd, dst) && IS_SYSREG (gs, src))
	|| (IS_SYSREG (gd, dst) && IS_DREG (gs, src))
	|| (IS_SYSREG (gd, dst) && IS_PREG (gs, src))
	|| (IS_SYSREG (gd, dst) && gs == 7 && src == 0)))
    return 0;
d1418 1
@


1.25
log
@opcodes: blackfin: mark push/pop insns with a P6/P7 range as illegal

The push/pop multiple insn has a 3 bit field for the P register range,
but only values of 0...5 are valid (P0 - P5).  There is no such P6 or
P7 register, so mark these insns as illegal.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d763 2
d827 1
a827 1
  else if (prgfunc == 11 && IS_PREG (1, poprnd))
d849 3
d916 3
d924 1
a924 1
  else if (W == 1 && allreg (reg, grp))
d947 3
d961 1
a961 1
  else if (W == 1 && d == 1 && p == 0)
d967 1
a967 1
  else if (W == 1 && d == 0 && p == 1)
d981 1
a981 1
  else if (W == 0 && d == 1 && p == 0)
d987 1
a987 1
  else if (W == 0 && d == 0 && p == 1)
d1011 3
d1046 3
d1197 1
a1197 1
  else if (opc == 5 && I == 0 && G == 0)
d1200 1
a1200 1
  else if (opc == 6 && I == 0 && G == 0)
d1203 1
a1203 1
  else if (opc == 7 && I == 0 && G == 0)
d1221 3
d1254 4
d1266 2
a1267 1
	strcpy (bitnames, "CC /* ... Illegal register ... */");
d1328 3
d1368 3
d1602 3
d1788 3
d1846 3
d2032 1
a2032 1
  else if (op == 1)
d2275 1
a2275 1
  else if (aop == 0 && sz == 0 && Z == 1 && W == 0)
d2317 1
a2317 1
  else if (aop == 1 && sz == 0 && Z == 1 && W == 0)
d2611 3
d2672 3
d2808 3
d2944 3
d4606 3
d4663 3
d4685 3
d4746 5
d4829 3
d4853 1
a4853 1
  if ((iw0 & 0xc000) == 0xc000 && (iw0 & BIT_MULTI_INS)
d4856 3
d4861 1
a4861 1
      count += _print_insn_bfin (pc + 4, outf);
d4863 14
a4876 1
      count += _print_insn_bfin (pc + 6, outf);
d4879 1
a4879 5
  if (count == 0)
    {
      outf->fprintf_func (outf->stream, "ILLEGAL");
      return 2;
    }
d4883 3
@


1.24
log
@opcodes: blackfin: fix decoding of vector shift insn w/saturation

The saturation bit was missed when decoding a vector shift insn
leading to the output looking the same as the non-saturating insn.

Signed-off-by: Robin Getz <robin.getz@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d939 3
@


1.23
log
@opcodes: blackfin: decode all ASTAT bits

All ASTAT bits work in the hardware even though they aren't part of the
official Blackfin ISA.  So decode every ASTAT field to make the output
a bit nicer when working with hand generated opcodes.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d4464 1
a4464 1
      OUTS (outf, " (V)");
@


1.22
log
@opcodes: blackfin: decode insns with invalid register as illegal

Sometimes the encoding in the opcode is a 4 bit field which defines a
register number.  However, register numbers are only 0-7, so make sure
we call illegal for when the opcode register number is greater than 8.

Signed-off-by: Robin Getz <robin.getz@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d1230 13
d1246 1
a1246 1
      OUTS (outf, statbits (cbit));
d1251 1
a1251 1
      OUTS (outf, statbits (cbit));
d1256 1
a1256 1
      OUTS (outf, statbits (cbit));
d1261 1
a1261 1
      OUTS (outf, statbits (cbit));
d1265 1
a1265 1
      OUTS (outf, statbits (cbit));
d1270 1
a1270 1
      OUTS (outf, statbits (cbit));
d1275 1
a1275 1
      OUTS (outf, statbits (cbit));
d1280 1
a1280 1
      OUTS (outf, statbits (cbit));
@


1.21
log
@gas: blackfin: fix DBG/DBGCMPLX insn encoding

Some extended registers when given to the DBG/DBGCMPLX pseudo insns are
not encoded properly.  So fix them, fix the display of them when being
disassembled, and add testcases.

Signed-off-by: Robin Getz <robin.getz@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d439 2
a440 2
#define IS_DREG(g,r)	((g) == 0)
#define IS_PREG(g,r)	((g) == 1)
d442 2
a443 2
#define IS_GENREG(g,r)	((g) == 0 || (g) == 1 || IS_AREG (g, r))
#define IS_DAGREG(g,r)	((g) == 2 || (g) == 3)
d446 5
d781 1
a781 1
  else if (prgfunc == 3)
d786 1
a786 1
  else if (prgfunc == 4)
d791 1
a791 1
  else if (prgfunc == 5)
d797 1
a797 1
  else if (prgfunc == 6)
d803 1
a803 1
  else if (prgfunc == 7)
d809 1
a809 1
  else if (prgfunc == 8)
d825 1
a825 1
  else if (prgfunc == 11)
d911 1
a911 1
  if (W == 0)
d916 1
a916 1
  else if (W == 1)
d1211 1
a1211 1
  else if (op == 3)
@


1.20
log
@opcodes/gas: blackfin: handle more ASTAT flags

Support a few more ASTAT bits with the standard insns that operate on
ASTAT bits directly.

Signed-off-by: Robin Getz <robin.getz@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d4564 1
a4564 1
      OUTS (outf, "DBG");
@


1.19
log
@opcodes/gas: blackfin: support OUTC debug insn

The disassembler has partial (but incomplete/broken) support already for
the pseudo debug insn OUTC, so let's fix it up and finish it.  And now
that the disassembler can handle it, make sure our assembler can output
it too.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d245 1
d281 1
d403 8
a410 4
  REG_AZ, REG_AN, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_AQ, REG_LASTREG,
  REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_AC0, REG_AC1, REG_LASTREG, REG_LASTREG,
  REG_AV0, REG_AV0S, REG_AV1, REG_AV1S, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG,
  REG_V, REG_VS, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG, REG_LASTREG,
@


1.18
log
@opcodes: blackfin: fix decoding of LSHIFT insns

The Blackfin ISA does not have a "SHIFT" insn, it has either LSHIFT,
ASHIFT, or BXORSHIFT.  So be specific when disassembling.

As fall out of this change, we need to update some assembler tests.

Signed-off-by: Robin Getz <robin.getz@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d4553 1
a4553 1
      OUTS (outf, "OUTC");
d4573 15
a4730 1
#if 0
d4732 1
a4732 2
    rv = decode_pseudoOChar_0 (iw0, iw1, pc, outf);
#endif
@


1.17
log
@opcodes: blackfin: constify formatting related structures

No need for these local structures related to formatting of output to
be writable, so constify the whole shebang.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d4057 1
a4057 1
      OUTS (outf, " = SHIFT ");
d4073 1
a4073 1
      OUTS (outf, " = SHIFT ");
@


1.16
log
@fix set but unused variable warnings
@
text
@d56 3
d68 1
a68 1
static struct
d70 12
a81 12
  char *name;
  int nbits;
  char reloc;
  char issigned;
  char pcrel;
  char scale;
  char offset;
  char negative;
  char positive;
  char decimal;
  char leading;
  char exact;
d129 2
a130 5
static char comment = 0;
static char parallel = 0;

static char *
fmtconst (const_forms_t cf, TIword x, bfd_vma pc, disassemble_info * outf)
d257 1
a257 1
static char *reg_names[] =
d560 1
a560 1
  char *s0, *s1;
d581 2
a582 2
  char *a;
  char *sop = "<unknown op>";
@


1.15
log
@Blackfin disassmbler: fix typo where M2.H was decoded as L2.H
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d4632 2
d4635 2
d4736 2
@


1.14
log
@ 	gas/
	* config/bfin-parse.y (asm_1): Implement HLT instruction.
	Fix comments for DBGA, DBGAH and DBGAL.
	* config/tc-bfin.c (bfin_gen_pseudodbg_assert): Change according
	to the new encoding of DBGA, DBGAH, and DBGAL.

	include/
	* opcode/bfin.h (PseudoDbg_Assert): Add bits_grp and mask_grp.
	(PseudoDbg_Assert_grp_bits, PseudoDbg_Assert_grp_mask): Define.
	(PseudoDbg_Assert_dbgop_bits, PseudoDbg_Assert_dbgop_mask,
	PseudoDbg_Assert_dontcare_bits, PseudoDbg_Assert_dontcare_mask):
	Adjust accordingly.
	(init_PseudoDbg_Assert): Add PseudoDbg_Assert_grp_bits and
	PseudoDbg_Assert_grp_mask.

	opcodes/
	* bfin-dis.c (decode_pseudodbg_assert_0): Change according
	to the new encoding of DBGA, DBGAH, and DBGAL.
	(_print_insn_bfin): Likewise.
@
text
@d393 1
a393 1
  REG_IH0, REG_IH1, REG_IH2, REG_IH3, REG_MH0, REG_MH1, REG_LH2, REG_MH3,
@


1.13
log
@	gas/
	* config/bfin-parse.y: Remove trailing whitespace.
	(ccstat): Indent.
	* config/tc-bfin.c (struct bfin_reg_entry): Remove.
	(bfin_reg_info[]): Remove.

	opcodes/
	* bfin-dis.c (_print_insn_bfin): Don't declare.
	(print_insn_bfin): Don't declare.
	(dregs_pair): Remove.
	(ignore_bits): Remove.
	(ccstat): Remove.
@
text
@d4577 1
a4577 1
     | 1 | 1 | 1 | 1 | 0 | - | - | - | - | - |.dbgop.....|.regtest...|
d4582 1
d4588 1
a4588 1
      OUTS (outf, dregs_lo (regtest));
d4596 1
a4596 1
      OUTS (outf, dregs_hi (regtest));
d4604 1
a4604 1
      OUTS (outf, dregs (regtest));
d4612 1
a4612 1
      OUTS (outf, dregs (regtest));
d4716 1
a4716 1
  else if ((iw0 & 0xFFC0) == 0xf000 && (iw1 & 0x0000) == 0x0000)
@


1.12
log
@	gas/
	* config/bfin-defs.h (IS_GENREG): Define.
	(IS_DAGREG): Define.
	(IS_SYSREG): Define.
	* config/bfin-parse.y (asm_1): Check illegal register move
	instructions.

	gas/testsuite/
	* gas/bfin/expected_move_errors.s,
	gas/bfin/expected_move_errors.l: Add "LC1 = I0;".
	* gas/bfin/move.s, gas/bfin/move.d: Remove "CYCLES = A0.W".

	opcodes/
	* bfin-dis.c (IS_DREG): Define.
	(IS_PREG): Define.
	(IS_AREG): Define.
	(IS_GENREG): Define.
	(IS_DAGREG): Define.
	(IS_SYSREG): Define.
	(decode_REGMV_0): Check illegal register move instructions.
@
text
@a125 3
int _print_insn_bfin (bfd_vma pc, disassemble_info * outf);
int print_insn_bfin (bfd_vma pc, disassemble_info * outf);

a316 1
#define dregs_pair(x) REGNAME (decode_dregs_pair[(x) & 7])
d407 1
a407 3
#define statbits(x)	REGNAME (decode_statbits[(x) & 31])
#define ignore_bits(x)	REGNAME (decode_ignore_bits[(x) & 7])
#define ccstat(x)	REGNAME (decode_ccstat[(x) & 0])
d4621 1
a4621 1
int
@


1.11
log
@update copyright dates
@
text
@d435 2
a436 1
  REG_USP, REG_SEQSTAT, REG_SYSCFG, REG_RETI, REG_RETX, REG_RETN, REG_RETE, REG_EMUDAT, REG_LASTREG,
d439 8
d1336 13
@


1.10
log
@2009-01-14  Mike Frysinger  <vapier@@gentoo.org>

	* bfin-dis.c (OUTS): Use "%s" as format string.
@
text
@d2 1
a2 1
   Copyright 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.9
log
@Silence gcc printf warnings
@
text
@d484 1
a484 1
#define OUTS(p, txt) ((p) ? (((txt)[0]) ? (p->fprintf_func)(p->stream, txt) :0) :0)
@


1.8
log
@gas/testsuite/:
	From Robin Getz  <rgetz@@blackfin.uclinux.org>
	* gas/bfin/arithmetic.d: Update to reflect spaces/capitalization in
	recent changes in opcodes/bfin-dis.c.
	gas/bfin/arithmetic.s: Likewise.
	gas/bfin/bit.d: Likewise.
	gas/bfin/bit2.d: Likewise.
	gas/bfin/control_code.d: Likewise.
	gas/bfin/control_code2.d: Likewise.
	gas/bfin/event.d: Likewise.
	gas/bfin/event2.d: Likewise.
	gas/bfin/flow.d: Likewise.
	gas/bfin/flow2.d: Likewise.
	gas/bfin/load.d: Likewise.
	gas/bfin/logical.d: Likewise.
	gas/bfin/logical2.d: Likewise.
	gas/bfin/move.d: Likewise.
	gas/bfin/move2.d: Likewise.
	gas/bfin/parallel.d: Likewise.
	gas/bfin/parallel2.d: Likewise.
	gas/bfin/parallel3.d: Likewise.
	gas/bfin/parallel4.d: Likewise.
	gas/bfin/shift.d: Likewise.
	gas/bfin/shift2.d: Likewise.
	gas/bfin/stack.d: Likewise.
	gas/bfin/stack2.d: Likewise.
	gas/bfin/store.d: Likewise.
	gas/bfin/vector.d: Likewise.
	gas/bfin/vector2.d: Likewise.
	gas/bfin/video.d: Likewise.
	gas/bfin/video2.d: Likewise.

opcodes/:
	* bfin-dis.c: (c_uimm4s4d, c_imm5d, c_imm7d, c_imm16d, c_uimm16s4d,
	c_imm32, c_huimm32e): Define.
	(constant_formats): Add flags for printing decimal, leading spaces, and
	exact symbols.
	(comment, parallel): Add global flags in all disassembly.
	(fmtconst): Take advantage of new flags, and print default in hex.
	(fmtconst_val): Likewise.
	(decode_macfunc): Be consistant with spaces, tabs, comments,
	capitalization in disassembly, fix minor coding style issues.
	(reg_names, amod0, amod1, amod0amod2, aligndir, get_allreg): Likewise.
	(decode_ProgCtrl_0, decode_PushPopMultiple_0, decode_CCflag_0,
	decode_CC2dreg_0, decode_CC2stat_0, decode_BRCC_0, decode_UJUMP_0,
	decode_REGMV_0, decode_ALU2op_0, decode_PTR2op_0, decode_LOGI2op_0,
	decode_COMP3op_0, decode_COMPI2opD_0, decode_COMPI2opP_0,
	decode_LDSTpmod_0, decode_dagMODim_0, decode_dagMODik_0,
	decode_dspLDST_0, decode_LDST_0, decode_LDSTiiFP_0, decode_LDSTii_0,
	decode_LoopSetup_0, decode_LDIMMhalf_0, decode_CALLa_0,
	decode_LDSTidxI_0, decode_linkage_0, decode_dsp32alu_0,
	decode_dsp32shift_0, decode_dsp32shiftimm_0, decode_pseudodbg_assert_0,
	_print_insn_bfin, print_insn_bfin): Likewise.
@
text
@d2 1
a2 1
   Copyright 2005, 2007 Free Software Foundation, Inc.
d151 1
a151 1
	  sprintf (buf, "%lx", x);
d189 1
a189 1
	sprintf (buf, "0x%lx", x);
@


1.7
log
@gas/
	* config/bfin-parse.y (check_macfunc_option): Allow (IU)
	option for multiply and multiply-accumulate to data register
	instruction.
	(check_macfuncs): Don't check if accumulator matches the data register
	here.
	(assign_macfunc): Check if accumulator matches the
	data register in each rule that moves to the data
	register.

gas/testsuite/
	* gas/bfin/arithmetic.s, gas/bfin/arithmetic.d: Add check
	for IU option.
	* gas/bfin/expected_errors.l, gas/bfin/expected_errors.s:
	Add check for mismatch of accumulator and data register.

opcodes/
	* bfin-dis.c (decode_dsp32mac_0): Decode (IU) option for
	multiply and multiply-accumulate to data register instruction.
@
text
@d59 4
a62 4
  c_imm4, c_uimm4s4, c_uimm4, c_uimm4s2, c_negimm5s4, c_imm5, c_uimm5, c_imm6,
  c_imm7, c_imm8, c_uimm8, c_pcrel8, c_uimm8s4, c_pcrel8s4, c_lppcrel10, c_pcrel10,
  c_pcrel12, c_imm16s4, c_luimm16, c_imm16, c_huimm16, c_rimm16, c_imm16s2, c_uimm16s4,
  c_uimm16, c_pcrel24, c_uimm32, c_huimm32,
d76 3
d81 43
a123 36
  { "0", 0, 0, 1, 0, 0, 0, 0, 0},
  { "1", 0, 0, 1, 0, 0, 0, 0, 0},
  { "4", 0, 0, 1, 0, 0, 0, 0, 0},
  { "2", 0, 0, 1, 0, 0, 0, 0, 0},
  { "uimm2", 2, 0, 0, 0, 0, 0, 0, 0},
  { "uimm3", 3, 0, 0, 0, 0, 0, 0, 0},
  { "imm3", 3, 0, 1, 0, 0, 0, 0, 0},
  { "pcrel4", 4, 1, 0, 1, 1, 0, 0, 0},
  { "imm4", 4, 0, 1, 0, 0, 0, 0, 0},
  { "uimm4s4", 4, 0, 0, 0, 2, 0, 0, 1},
  { "uimm4", 4, 0, 0, 0, 0, 0, 0, 0},
  { "uimm4s2", 4, 0, 0, 0, 1, 0, 0, 1},
  { "negimm5s4", 5, 0, 1, 0, 2, 0, 1, 0},
  { "imm5", 5, 0, 1, 0, 0, 0, 0, 0},
  { "uimm5", 5, 0, 0, 0, 0, 0, 0, 0},
  { "imm6", 6, 0, 1, 0, 0, 0, 0, 0},
  { "imm7", 7, 0, 1, 0, 0, 0, 0, 0},
  { "imm8", 8, 0, 1, 0, 0, 0, 0, 0},
  { "uimm8", 8, 0, 0, 0, 0, 0, 0, 0},
  { "pcrel8", 8, 1, 0, 1, 1, 0, 0, 0},
  { "uimm8s4", 8, 0, 0, 0, 2, 0, 0, 0},
  { "pcrel8s4", 8, 1, 1, 1, 2, 0, 0, 0},
  { "lppcrel10", 10, 1, 0, 1, 1, 0, 0, 0},
  { "pcrel10", 10, 1, 1, 1, 1, 0, 0, 0},
  { "pcrel12", 12, 1, 1, 1, 1, 0, 0, 0},
  { "imm16s4", 16, 0, 1, 0, 2, 0, 0, 0},
  { "luimm16", 16, 1, 0, 0, 0, 0, 0, 0},
  { "imm16", 16, 0, 1, 0, 0, 0, 0, 0},
  { "huimm16", 16, 1, 0, 0, 0, 0, 0, 0},
  { "rimm16", 16, 1, 1, 0, 0, 0, 0, 0},
  { "imm16s2", 16, 0, 1, 0, 1, 0, 0, 0},
  { "uimm16s4", 16, 0, 0, 0, 2, 0, 0, 0},
  { "uimm16", 16, 0, 0, 0, 0, 0, 0, 0},
  { "pcrel24", 24, 1, 1, 1, 1, 0, 0, 0},
  { "uimm32", 32,  0, 0, 0, 0, 0, 0, 0},
  { "huimm16", 32, 1, 0, 0, 0, 0, 0, 0}
d129 3
d144 10
a153 2
      outf->print_address_func (ea, outf);
      return "";
d173 11
a183 2
  if (constant_formats[cf].issigned && x < 0)
    sprintf (buf, "%ld", x);
d185 6
a190 1
    sprintf (buf, "0x%lx", x);
d201 3
a203 3
                   ? SIGNEXTEND (x, constant_formats[cf].nbits)
                   : x) + constant_formats[cf].offset)
                 << constant_formats[cf].scale);
d205 1
a205 1
        ea += pc;
d266 1
a266 1
  "P4", "P5", "SP", "FP", "A0.x", "A1.x", "A0.w", "A1.w",
d440 1
d450 1
d461 1
d467 1
d470 1
d475 1
d477 2
d491 1
a491 1
    OUTS (outf, "(S)");
d493 1
a493 1
    OUTS (outf, "(CO)");
d495 1
a495 1
    OUTS (outf, "(SCO)");
d502 1
a502 1
    OUTS (outf, "(NS)");
d504 1
a504 1
    OUTS (outf, "(S)");
d511 1
a511 1
    OUTS (outf, "(S)");
d513 1
a513 1
    OUTS (outf, "(CO)");
d515 1
a515 1
    OUTS (outf, "(SCO)");
d517 1
a517 1
    OUTS (outf, "(ASR)");
d519 1
a519 1
    OUTS (outf, "(S,ASR)");
d521 1
a521 1
    OUTS (outf, "(CO,ASR)");
d523 1
a523 1
    OUTS (outf, "(SCO,ASR)");
d525 1
a525 1
    OUTS (outf, "(ASL)");
d527 1
a527 1
    OUTS (outf, "(S,ASL)");
d529 1
a529 1
    OUTS (outf, "(CO,ASL)");
d531 1
a531 1
    OUTS (outf, "(SCO,ASL)");
d551 1
a551 1
    OUTS (outf, "(R)");
d582 1
a582 1
    a = "a1";
d584 1
a584 1
    a = "a0";
d594 3
a596 3
    case 0: sop = "=";   break;
    case 1: sop = "+=";  break;
    case 2: sop = "-=";  break;
a600 1
  OUTS (outf, " ");
a601 1
  OUTS (outf, " ");
d720 13
a732 13
        {
        case 32: return &saved_state.a0x;
        case 33: return &saved_state.a0w;
        case 34: return &saved_state.a1x;
        case 35: return &saved_state.a1w;
        case 39: return &saved_state.rets;
        case 48: return &LC0REG;
        case 49: return &LT0REG;
        case 50: return &LB0REG;
        case 51: return &LC1REG;
        case 52: return &LT1REG;
        case 53: return &LB1REG;
        }
d769 1
a769 1
      OUTS (outf, "CLI  ");
d774 1
a774 1
      OUTS (outf, "STI  ");
d779 1
a779 1
      OUTS (outf, "JUMP  (");
d785 1
a785 1
      OUTS (outf, "CALL  (");
d791 1
a791 1
      OUTS (outf, "CALL  (PC+");
d797 1
a797 1
      OUTS (outf, "JUMP  (PC+");
d803 1
a803 1
      OUTS (outf, "RAISE  ");
d808 1
a808 1
      OUTS (outf, "EXCPT  ");
d813 1
a813 1
      OUTS (outf, "TESTSET  (");
a923 4
  char ps[5], ds[5];

  sprintf (ps, "%d", pr);
  sprintf (ds, "%d", dr);
d928 1
a928 1
      OUTS (outf, ds);
d930 1
a930 1
      OUTS (outf, ps);
d936 1
a936 1
      OUTS (outf, ds);
d942 1
a942 1
      OUTS (outf, ps);
d948 1
a948 1
      OUTS (outf, ds);
d950 1
a950 1
      OUTS (outf, ps);
d956 1
a956 1
      OUTS (outf, ds);
d962 1
a962 1
      OUTS (outf, ps);
d992 1
a992 1
      OUTS (outf, "IF ! CC ");
d1017 1
a1017 1
      OUTS (outf, "CC=");
d1019 1
a1019 1
      OUTS (outf, "==");
d1024 1
a1024 1
      OUTS (outf, "CC=");
d1026 1
a1026 1
      OUTS (outf, "<");
d1031 1
a1031 1
      OUTS (outf, "CC=");
d1033 1
a1033 1
      OUTS (outf, "<=");
d1038 1
a1038 1
      OUTS (outf, "CC=");
d1040 1
a1040 1
      OUTS (outf, "<");
d1042 1
a1042 1
      OUTS (outf, "(IU)");
d1046 1
a1046 1
      OUTS (outf, "CC=");
d1048 1
a1048 1
      OUTS (outf, "<=");
d1050 1
a1050 1
      OUTS (outf, "(IU)");
d1054 1
a1054 1
      OUTS (outf, "CC=");
d1056 1
a1056 1
      OUTS (outf, "==");
d1061 1
a1061 1
      OUTS (outf, "CC=");
d1063 1
a1063 1
      OUTS (outf, "<");
d1068 1
a1068 1
      OUTS (outf, "CC=");
d1070 1
a1070 1
      OUTS (outf, "<=");
d1075 1
a1075 1
      OUTS (outf, "CC=");
d1077 1
a1077 1
      OUTS (outf, "<");
d1079 1
a1079 1
      OUTS (outf, "(IU)");
d1083 1
a1083 1
      OUTS (outf, "CC=");
d1085 1
a1085 1
      OUTS (outf, "<=");
d1087 1
a1087 1
      OUTS (outf, "(IU)");
d1091 1
a1091 1
      OUTS (outf, "CC=");
d1093 1
a1093 1
      OUTS (outf, "==");
d1098 1
a1098 1
      OUTS (outf, "CC=");
d1100 1
a1100 1
      OUTS (outf, "<");
d1105 1
a1105 1
      OUTS (outf, "CC=");
d1107 1
a1107 1
      OUTS (outf, "<=");
d1112 1
a1112 1
      OUTS (outf, "CC=");
d1114 1
a1114 1
      OUTS (outf, "<");
d1116 1
a1116 1
      OUTS (outf, "(IU)");
d1120 1
a1120 1
      OUTS (outf, "CC=");
d1122 1
a1122 1
      OUTS (outf, "<=");
d1124 1
a1124 1
      OUTS (outf, "(IU)");
d1128 1
a1128 1
      OUTS (outf, "CC=");
d1130 1
a1130 1
      OUTS (outf, "==");
d1135 1
a1135 1
      OUTS (outf, "CC=");
d1137 1
a1137 1
      OUTS (outf, "<");
d1142 1
a1142 1
      OUTS (outf, "CC=");
d1144 1
a1144 1
      OUTS (outf, "<=");
d1149 1
a1149 1
      OUTS (outf, "CC=");
d1151 1
a1151 1
      OUTS (outf, "<");
d1153 1
a1153 1
      OUTS (outf, "(IU)");
d1157 1
a1157 1
      OUTS (outf, "CC=");
d1159 1
a1159 1
      OUTS (outf, "<=");
d1161 1
a1161 1
      OUTS (outf, "(IU)");
d1164 1
a1164 1
    OUTS (outf, "CC=A0==A1");
d1167 1
a1167 1
    OUTS (outf, "CC=A0<A1");
d1170 1
a1170 1
    OUTS (outf, "CC=A0<=A1");
d1190 1
a1190 1
      OUTS (outf, "=CC");
d1194 1
a1194 1
      OUTS (outf, "CC=");
d1198 1
a1198 1
    OUTS (outf, "CC=!CC");
d1223 1
a1223 1
      OUTS (outf, "CC|=");
d1228 1
a1228 1
      OUTS (outf, "CC&=");
d1233 1
a1233 1
      OUTS (outf, "CC^=");
d1239 1
a1239 1
      OUTS (outf, "=CC");
d1244 1
a1244 1
      OUTS (outf, "|=CC");
d1249 1
a1249 1
      OUTS (outf, "&=CC");
d1254 1
a1254 1
      OUTS (outf, "^=CC");
d1275 1
a1275 1
      OUTS (outf, "IF CC JUMP ");
d1277 1
a1277 1
      OUTS (outf, "(BP)");
d1281 1
a1281 1
      OUTS (outf, "IF ! CC JUMP ");
d1283 1
a1283 1
      OUTS (outf, "(BP)");
d1287 1
a1287 1
      OUTS (outf, "IF CC JUMP ");
d1292 1
a1292 1
      OUTS (outf, "IF ! CC JUMP ");
d1310 1
a1310 1
  OUTS (outf, "JUMP.S  ");
d1328 1
a1328 1
  OUTS (outf, "=");
d1347 1
a1347 1
      OUTS (outf, ">>>=");
d1353 1
a1353 1
      OUTS (outf, ">>=");
d1359 1
a1359 1
      OUTS (outf, "<<=");
d1365 1
a1365 1
      OUTS (outf, "*=");
d1371 1
a1371 1
      OUTS (outf, "=(");
d1373 1
a1373 1
      OUTS (outf, "+");
d1375 1
a1375 1
      OUTS (outf, ")<<1");
d1380 1
a1380 1
      OUTS (outf, "=(");
d1382 1
a1382 1
      OUTS (outf, "+");
d1384 1
a1384 1
      OUTS (outf, ")<<2");
d1388 1
a1388 1
      OUTS (outf, "DIVQ(");
d1390 1
a1390 1
      OUTS (outf, ",");
d1396 1
a1396 1
      OUTS (outf, "DIVS(");
d1398 1
a1398 1
      OUTS (outf, ",");
d1405 1
a1405 1
      OUTS (outf, "=");
d1407 1
a1407 1
      OUTS (outf, "(X)");
d1412 1
a1412 1
      OUTS (outf, "=");
d1414 1
a1414 1
      OUTS (outf, "(Z)");
d1419 1
a1419 1
      OUTS (outf, "=");
d1421 1
a1421 1
      OUTS (outf, "(X)");
d1426 1
a1426 1
      OUTS (outf, "=");
d1428 1
a1428 1
      OUTS (outf, "(Z)");
d1433 1
a1433 1
      OUTS (outf, "=-");
d1439 1
a1439 1
      OUTS (outf, "=~");
d1462 1
a1462 1
      OUTS (outf, "-=");
d1468 1
a1468 1
      OUTS (outf, "=");
d1470 1
a1470 1
      OUTS (outf, "<<2");
d1475 1
a1475 1
      OUTS (outf, "=");
d1477 1
a1477 1
      OUTS (outf, ">>2");
d1482 1
a1482 1
      OUTS (outf, "=");
d1484 1
a1484 1
      OUTS (outf, ">>1");
d1489 1
a1489 1
      OUTS (outf, "+=");
d1491 1
a1491 1
      OUTS (outf, "(BREV)");
d1496 1
a1496 1
      OUTS (outf, "=(");
d1498 1
a1498 1
      OUTS (outf, "+");
d1500 1
a1500 1
      OUTS (outf, ")<<1");
d1505 1
a1505 1
      OUTS (outf, "=(");
d1507 1
a1507 1
      OUTS (outf, "+");
d1509 1
a1509 1
      OUTS (outf, ")<<2");
d1530 1
a1530 1
      OUTS (outf, "CC = ! BITTST (");
d1532 1
a1532 1
      OUTS (outf, ",");
d1534 4
a1537 1
      OUTS (outf, ")");
d1543 1
a1543 1
      OUTS (outf, ",");
d1545 4
a1548 1
      OUTS (outf, ")");
d1554 1
a1554 1
      OUTS (outf, ",");
d1556 4
a1559 1
      OUTS (outf, ")");
d1565 1
a1565 1
      OUTS (outf, ",");
d1567 4
a1570 1
      OUTS (outf, ")");
d1576 1
a1576 1
      OUTS (outf, ",");
d1578 4
a1581 1
      OUTS (outf, ")");
d1586 1
a1586 1
      OUTS (outf, ">>>=");
d1592 1
a1592 1
      OUTS (outf, ">>=");
d1598 1
a1598 1
      OUTS (outf, "<<=");
d1622 1
a1622 1
      OUTS (outf, "=");
d1624 1
a1624 1
      OUTS (outf, "<<1");
d1629 1
a1629 1
      OUTS (outf, "=");
d1631 1
a1631 1
      OUTS (outf, "-");
d1637 1
a1637 1
      OUTS (outf, "=");
d1639 1
a1639 1
      OUTS (outf, "&");
d1645 1
a1645 1
      OUTS (outf, "=");
d1647 1
a1647 1
      OUTS (outf, "|");
d1653 1
a1653 1
      OUTS (outf, "=");
d1655 1
a1655 1
      OUTS (outf, "^");
d1661 1
a1661 1
      OUTS (outf, "=");
d1663 1
a1663 1
      OUTS (outf, "+");
d1669 1
a1669 1
      OUTS (outf, "=");
d1671 1
a1671 1
      OUTS (outf, "+(");
d1673 1
a1673 1
      OUTS (outf, "<<1)");
d1678 1
a1678 1
      OUTS (outf, "=");
d1680 1
a1680 1
      OUTS (outf, "+(");
d1682 1
a1682 1
      OUTS (outf, "<<2)");
d1687 1
a1687 1
      OUTS (outf, "=");
d1689 1
a1689 1
      OUTS (outf, "+");
d1709 14
d1726 4
d1731 5
a1735 2
      OUTS (outf, imm7 (src));
      OUTS (outf, "(x)");
d1740 1
a1740 1
      OUTS (outf, "+=");
d1742 4
d1764 11
d1778 4
d1783 5
a1787 1
      OUTS (outf, imm7 (src));
d1792 1
a1792 1
      OUTS (outf, "+=");
d1794 4
d1821 1
a1821 1
      OUTS (outf, "=W[");
d1828 1
a1828 1
      OUTS (outf, "=W[");
d1836 1
a1836 1
      OUTS (outf, "]=");
d1843 1
a1843 1
      OUTS (outf, "]=");
d1849 1
a1849 1
      OUTS (outf, "=[");
d1851 1
a1851 1
      OUTS (outf, "++");
d1858 1
a1858 1
      OUTS (outf, "=W[");
d1860 1
a1860 1
      OUTS (outf, "++");
d1867 1
a1867 1
      OUTS (outf, "=W[");
d1869 1
a1869 1
      OUTS (outf, "++");
d1876 1
a1876 1
      OUTS (outf, "=W[");
d1878 1
a1878 1
      OUTS (outf, "++");
d1885 1
a1885 1
      OUTS (outf, "=W[");
d1887 1
a1887 1
      OUTS (outf, "++");
d1889 1
a1889 1
      OUTS (outf, "](X)");
d1895 1
a1895 1
      OUTS (outf, "++");
d1897 1
a1897 1
      OUTS (outf, "]=");
d1904 1
a1904 1
      OUTS (outf, "++");
d1906 1
a1906 1
      OUTS (outf, "]=");
d1913 1
a1913 1
      OUTS (outf, "++");
d1915 1
a1915 1
      OUTS (outf, "]=");
d1939 1
a1939 1
      OUTS (outf, "+=");
d1941 1
a1941 1
      OUTS (outf, "(BREV)");
d1946 1
a1946 1
      OUTS (outf, "+=");
d1952 1
a1952 1
      OUTS (outf, "-=");
d1974 1
a1974 1
      OUTS (outf, "+=2");
d1979 1
a1979 1
      OUTS (outf, "-=2");
d1984 1
a1984 1
      OUTS (outf, "+=4");
d1989 1
a1989 1
      OUTS (outf, "-=4");
d1994 11
d2024 1
a2024 1
      OUTS (outf, "=[");
d2031 1
a2031 1
      OUTS (outf, "=W[");
d2038 1
a2038 1
      OUTS (outf, "=W[");
d2045 1
a2045 1
      OUTS (outf, "=[");
d2052 1
a2052 1
      OUTS (outf, "=W[");
d2059 1
a2059 1
      OUTS (outf, "=W[");
d2066 1
a2066 1
      OUTS (outf, "=[");
d2073 1
a2073 1
      OUTS (outf, "=W[");
d2080 1
a2080 1
      OUTS (outf, "=W[");
d2088 1
a2088 1
      OUTS (outf, "++]=");
d2095 1
a2095 1
      OUTS (outf, "++]=");
d2102 1
a2102 1
      OUTS (outf, "++]=");
d2109 1
a2109 1
      OUTS (outf, "--]=");
d2116 1
a2116 1
      OUTS (outf, "--]=");
d2123 1
a2123 1
      OUTS (outf, "--]=");
d2130 1
a2130 1
      OUTS (outf, "]=");
d2137 1
a2137 1
      OUTS (outf, "]=");
d2144 1
a2144 1
      OUTS (outf, "]=");
d2150 1
a2150 1
      OUTS (outf, "=[");
d2152 1
a2152 1
      OUTS (outf, "++");
d2160 1
a2160 1
      OUTS (outf, "++");
d2162 1
a2162 1
      OUTS (outf, "]=");
d2188 1
a2188 1
      OUTS (outf, "=[");
d2195 1
a2195 1
      OUTS (outf, "=[");
d2202 1
a2202 1
      OUTS (outf, "=W[");
d2209 1
a2209 1
      OUTS (outf, "=W[");
d2211 1
a2211 1
      OUTS (outf, "++](X)");
d2216 1
a2216 1
      OUTS (outf, "=B[");
d2223 1
a2223 1
      OUTS (outf, "=B[");
d2225 1
a2225 1
      OUTS (outf, "++](X)");
d2230 1
a2230 1
      OUTS (outf, "=[");
d2237 1
a2237 1
      OUTS (outf, "=[");
d2244 1
a2244 1
      OUTS (outf, "=W[");
d2251 1
a2251 1
      OUTS (outf, "=W[");
d2253 1
a2253 1
      OUTS (outf, "--](X)");
d2258 1
a2258 1
      OUTS (outf, "=B[");
d2265 1
a2265 1
      OUTS (outf, "=B[");
d2267 1
a2267 1
      OUTS (outf, "--](X)");
d2272 1
a2272 1
      OUTS (outf, "=[");
d2279 1
a2279 1
      OUTS (outf, "=[");
d2286 1
a2286 1
      OUTS (outf, "=W[");
d2293 1
a2293 1
      OUTS (outf, "=W[");
d2295 1
a2295 1
      OUTS (outf, "](X)");
d2300 1
a2300 1
      OUTS (outf, "=B[");
d2307 1
a2307 1
      OUTS (outf, "=B[");
d2309 1
a2309 1
      OUTS (outf, "](X)");
d2315 1
a2315 1
      OUTS (outf, "++]=");
d2322 1
a2322 1
      OUTS (outf, "++]=");
d2329 1
a2329 1
      OUTS (outf, "++]=");
d2336 1
a2336 1
      OUTS (outf, "++]=");
d2343 1
a2343 1
      OUTS (outf, "--]=");
d2350 1
a2350 1
      OUTS (outf, "--]=");
d2357 1
a2357 1
      OUTS (outf, "--]=");
d2364 1
a2364 1
      OUTS (outf, "--]=");
d2371 1
a2371 1
      OUTS (outf, "]=");
d2378 1
a2378 1
      OUTS (outf, "]=");
d2385 1
a2385 1
      OUTS (outf, "]=");
d2392 1
a2392 1
      OUTS (outf, "]=");
d2415 1
a2415 1
      OUTS (outf, "=[FP");
d2421 1
a2421 1
      OUTS (outf, "[FP");
d2423 1
a2423 1
      OUTS (outf, "]=");
d2448 1
a2448 1
      OUTS (outf, "=[");
d2450 1
a2450 1
      OUTS (outf, "+");
d2457 1
a2457 1
      OUTS (outf, "=W[");
d2459 1
a2459 1
      OUTS (outf, "+");
d2466 1
a2466 1
      OUTS (outf, "=W[");
d2468 1
a2468 1
      OUTS (outf, "+");
d2470 1
a2470 1
      OUTS (outf, "](X)");
d2475 1
a2475 1
      OUTS (outf, "=[");
d2477 1
a2477 1
      OUTS (outf, "+");
d2485 1
a2485 1
      OUTS (outf, "+");
d2487 1
a2487 1
      OUTS (outf, "]=");
d2492 1
a2492 2
      OUTS (outf, "W");
      OUTS (outf, "[");
d2494 1
a2494 1
      OUTS (outf, "+");
d2496 1
a2496 2
      OUTS (outf, "]");
      OUTS (outf, "=");
d2503 1
a2503 1
      OUTS (outf, "+");
d2505 1
a2505 1
      OUTS (outf, "]=");
d2531 1
a2531 1
      OUTS (outf, "(");
d2533 1
a2533 1
      OUTS (outf, ",");
d2535 1
a2535 1
      OUTS (outf, ")");
d2541 1
a2541 1
      OUTS (outf, "(");
d2543 1
a2543 1
      OUTS (outf, ",");
d2545 1
a2545 1
      OUTS (outf, ")");
d2547 1
a2547 1
      OUTS (outf, "=");
d2553 1
a2553 1
      OUTS (outf, "(");
d2555 1
a2555 1
      OUTS (outf, ",");
d2557 1
a2557 1
      OUTS (outf, ")");
d2559 1
a2559 1
      OUTS (outf, "=");
d2561 1
a2561 1
      OUTS (outf, ">>1");
d2593 4
d2602 1
d2621 2
a2622 2
      OUTS (outf, "=");
      OUTS (outf, imm16 (hword));
d2627 2
a2628 2
      OUTS (outf, "=");
      OUTS (outf, imm16 (hword));
d2633 1
a2633 1
      OUTS (outf, "=");
d2638 1
a2638 1
    {
d2640 1
a2640 1
      OUTS (outf, "=");
d2647 3
a2649 3
      OUTS (outf, "=");
      OUTS (outf, luimm16 (hword));
      OUTS (outf, "(Z)");
d2654 1
a2654 1
      OUTS (outf, "=");
d2660 1
a2660 1
      OUTS (outf, "=");
d2667 1
a2667 1
  if ( S == 0 && Z == 0 && grp != 0 )
d2669 4
a2672 1
      OUTS (outf, "\t/* ");
d2674 6
a2679 2
      if ( *pval < 0xFFC00000 )
	OUTS (outf, huimm32(*pval));
d2681 8
a2688 1
	OUTS (outf, uimm32(*pval));
d2691 12
a2703 1

d2720 1
a2720 1
    OUTS (outf, "CALL  ");
d2722 1
a2722 1
    OUTS (outf, "JUMP.L  ");
d2748 1
a2748 1
      OUTS (outf, "=[");
d2750 1
a2750 1
      OUTS (outf, "+");
d2757 1
a2757 1
      OUTS (outf, "=[");
d2759 1
a2759 1
      OUTS (outf, "+");
d2766 1
a2766 1
      OUTS (outf, "=W[");
d2768 1
a2768 1
      OUTS (outf, "+");
d2775 1
a2775 1
      OUTS (outf, "=W[");
d2777 1
a2777 1
      OUTS (outf, "+");
d2779 1
a2779 1
      OUTS (outf, "](X)");
d2784 1
a2784 1
      OUTS (outf, "=B[");
d2786 1
a2786 1
      OUTS (outf, "+");
d2793 1
a2793 1
      OUTS (outf, "=B[");
d2795 1
a2795 1
      OUTS (outf, "+");
d2797 1
a2797 1
      OUTS (outf, "](X)");
d2803 1
a2803 1
      OUTS (outf, "+");
d2805 1
a2805 1
      OUTS (outf, "]=");
d2812 1
a2812 1
      OUTS (outf, "+");
d2814 1
a2814 1
      OUTS (outf, "]=");
d2821 1
a2821 1
      OUTS (outf, "+");
d2823 1
a2823 1
      OUTS (outf, "]=");
d2830 1
a2830 1
      OUTS (outf, "+");
d2832 1
a2832 1
      OUTS (outf, "]=");
d2856 4
d3024 1
a3024 1
      OUTS (outf, "A0.L=");
d3029 1
a3029 1
      OUTS (outf, "A1.H=");
d3034 1
a3034 1
      OUTS (outf, "A1.L=");
d3039 1
a3039 1
      OUTS (outf, "A0.H=");
d3045 1
a3045 1
      OUTS (outf, "=");
d3047 1
a3047 1
      OUTS (outf, "-");
d3049 1
a3049 1
      OUTS (outf, "(RND20)");
d3054 1
a3054 1
      OUTS (outf, "=");
d3056 1
a3056 1
      OUTS (outf, "+");
d3058 1
a3058 1
      OUTS (outf, "(RND20)");
d3063 1
a3063 1
      OUTS (outf, "=");
d3065 1
a3065 1
      OUTS (outf, "-");
d3067 1
a3067 1
      OUTS (outf, "(RND12)");
d3072 1
a3072 1
      OUTS (outf, "=");
d3074 1
a3074 1
      OUTS (outf, "+");
d3076 1
a3076 1
      OUTS (outf, "(RND12)");
d3081 1
a3081 1
      OUTS (outf, "=");
d3083 1
a3083 1
      OUTS (outf, "-");
d3085 1
a3085 1
      OUTS (outf, "(RND20)");
d3090 1
a3090 1
      OUTS (outf, "=");
d3092 1
a3092 1
      OUTS (outf, "+");
d3094 1
a3094 1
      OUTS (outf, "(RND12)");
d3099 1
a3099 1
      OUTS (outf, "=");
d3101 1
a3101 1
      OUTS (outf, "+");
d3103 1
a3103 1
      OUTS (outf, "(RND20)");
d3108 1
a3108 1
      OUTS (outf, "=");
d3110 1
a3110 1
      OUTS (outf, "-");
d3112 1
a3112 1
      OUTS (outf, "(RND12)");
d3117 1
a3117 1
      OUTS (outf, "=");
d3119 1
a3119 1
      OUTS (outf, "+");
a3120 1
      OUTS (outf, " ");
d3126 1
a3126 1
      OUTS (outf, "=");
d3128 1
a3128 1
      OUTS (outf, "+");
a3129 1
      OUTS (outf, " ");
d3135 1
a3135 1
      OUTS (outf, "=");
d3137 1
a3137 1
      OUTS (outf, "+");
a3138 1
      OUTS (outf, " ");
d3144 1
a3144 1
      OUTS (outf, "=");
d3146 1
a3146 1
      OUTS (outf, "+");
a3147 1
      OUTS (outf, " ");
d3153 1
a3153 1
      OUTS (outf, "=");
d3155 1
a3155 1
      OUTS (outf, "-");
a3156 1
      OUTS (outf, " ");
d3162 1
a3162 1
      OUTS (outf, "=");
d3164 1
a3164 1
      OUTS (outf, "-");
a3165 1
      OUTS (outf, " ");
d3171 1
a3171 1
      OUTS (outf, "=");
d3173 1
a3173 1
      OUTS (outf, "+");
a3174 1
      OUTS (outf, " ");
d3180 1
a3180 1
      OUTS (outf, "=");
d3182 1
a3182 1
      OUTS (outf, "-");
a3183 1
      OUTS (outf, " ");
d3189 1
a3189 1
      OUTS (outf, "=");
d3191 1
a3191 1
      OUTS (outf, "-");
a3192 1
      OUTS (outf, " ");
d3198 1
a3198 1
      OUTS (outf, "=");
d3200 1
a3200 1
      OUTS (outf, "-");
a3201 1
      OUTS (outf, " ");
d3207 1
a3207 1
      OUTS (outf, "=");
d3209 1
a3209 1
      OUTS (outf, "-");
a3210 1
      OUTS (outf, " ");
d3216 1
a3216 1
      OUTS (outf, "=");
d3218 1
a3218 1
      OUTS (outf, "+");
a3219 1
      OUTS (outf, " ");
d3225 1
a3225 1
      OUTS (outf, "=");
d3227 1
a3227 1
      OUTS (outf, "+");
a3228 1
      OUTS (outf, " ");
d3234 1
a3234 1
      OUTS (outf, "=");
d3236 1
a3236 1
      OUTS (outf, "-");
a3237 1
      OUTS (outf, " ");
d3243 1
a3243 1
      OUTS (outf, "=");
d3245 1
a3245 1
      OUTS (outf, "-");
a3246 1
      OUTS (outf, " ");
d3252 1
a3252 1
      OUTS (outf, "=");
d3254 1
a3254 1
      OUTS (outf, "+");
a3255 1
      OUTS (outf, " ");
d3260 1
a3260 1
      OUTS (outf, "A0=");
d3264 1
a3264 1
    OUTS (outf, "A0-=A1");
d3267 1
a3267 1
    OUTS (outf, "A0-=A1(W32)");
d3272 1
a3272 1
      OUTS (outf, "=BYTEOP2M(");
d3276 1
a3276 1
      OUTS (outf, ",");
d3280 1
a3280 1
      OUTS (outf, ")(TH");
d3289 1
a3289 1
      OUTS (outf, "=BYTEOP2M(");
d3293 1
a3293 1
      OUTS (outf, ",");
d3297 1
a3297 1
      OUTS (outf, ")(TL");
d3306 1
a3306 1
      OUTS (outf, "=BYTEOP2M(");
d3310 1
a3310 1
      OUTS (outf, ",");
d3314 1
a3314 1
      OUTS (outf, ")(RNDH");
d3323 1
a3323 1
      OUTS (outf, "=BYTEOP2M(");
d3327 1
a3327 1
      OUTS (outf, ",");
d3331 1
a3331 1
      OUTS (outf, ")(RNDL");
d3340 1
a3340 1
      OUTS (outf, "=BYTEOP2P(");
d3343 2
a3344 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3347 2
a3348 2
      OUTS (outf, imm5 (src1));
      OUTS (outf, ")(TH");
d3357 1
a3357 1
      OUTS (outf, "=BYTEOP2P(");
d3360 2
a3361 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3364 2
a3365 2
      OUTS (outf, imm5 (src1));
      OUTS (outf, ")(TL");
d3374 1
a3374 1
      OUTS (outf, "=BYTEOP2P(");
d3377 2
a3378 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3381 2
a3382 2
      OUTS (outf, imm5 (src1));
      OUTS (outf, ")(RNDH");
d3391 1
a3391 1
      OUTS (outf, "=BYTEOP2P(");
d3394 2
a3395 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3398 2
a3399 2
      OUTS (outf, imm5 (src1));
      OUTS (outf, ")(RNDL");
d3406 1
a3406 1
    OUTS (outf, "A0=0");
d3409 1
a3409 1
    OUTS (outf, "A0=A0(S)");
d3412 1
a3412 1
    OUTS (outf, "A1=0");
d3415 1
a3415 1
    OUTS (outf, "A1=A1(S)");
d3418 1
a3418 1
    OUTS (outf, "A1=A0=0");
d3421 1
a3421 1
    OUTS (outf, "A1=A1(S),A0=A0(S)");
d3424 1
a3424 1
    OUTS (outf, "A0=A1");
d3427 1
a3427 1
    OUTS (outf, "A1=A0");
d3431 1
a3431 1
      OUTS (outf, "A0.x=");
d3437 1
a3437 1
      OUTS (outf, "=(A0+=A1)");
d3440 1
a3440 1
    OUTS (outf, "A1= ABS A0,A0= ABS A0");
d3445 1
a3445 1
      OUTS (outf, "=BYTEOP3P(");
d3448 2
a3449 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3452 2
a3453 2
      OUTS (outf, imm5 (src1));
      OUTS (outf, ")(HI");
d3461 1
a3461 1
      OUTS (outf, "A1.x=");
d3465 1
a3465 1
    OUTS (outf, "A1= ABS A1");
d3468 1
a3468 1
    OUTS (outf, "A1= ABS A0");
d3472 1
a3472 1
      OUTS (outf, "A1=");
d3478 1
a3478 1
      OUTS (outf, "=");
d3480 1
a3480 1
      OUTS (outf, "(RND)");
d3483 1
a3483 1
    OUTS (outf, "A0= ABS A1");
d3486 1
a3486 1
    OUTS (outf, "A0= ABS A0");
d3491 1
a3491 1
      OUTS (outf, "=-");
d3493 1
a3493 1
      OUTS (outf, "(V)");
d3498 1
a3498 1
      OUTS (outf, "=-");
d3500 1
a3500 1
      OUTS (outf, "(S)");
d3505 1
a3505 1
      OUTS (outf, "=-");
d3507 1
a3507 1
      OUTS (outf, "(NS)");
d3512 1
a3512 1
      OUTS (outf, "=(A0+=A1)");
d3515 1
a3515 1
    OUTS (outf, "A0+=A1");
d3518 1
a3518 1
    OUTS (outf, "A0+=A1(W32)");
d3521 1
a3521 1
    OUTS (outf, "A1=-A1,A0=-A0");
d3526 1
a3526 1
      OUTS (outf, "=");
d3528 1
a3528 1
      OUTS (outf, "(RND)");
d3533 1
a3533 1
      OUTS (outf, "=BYTEOP3P(");
d3536 2
a3537 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3540 2
a3541 2
      OUTS (outf, imm5 (src1));
      OUTS (outf, ")(LO");
d3548 1
a3548 1
    OUTS (outf, "A0=-A0");
d3551 1
a3551 1
    OUTS (outf, "A0=-A1");
d3554 1
a3554 1
    OUTS (outf, "A1=-A0");
d3557 1
a3557 1
    OUTS (outf, "A1=-A1");
d3562 1
a3562 1
      OUTS (outf, "=");
d3564 1
a3564 1
      OUTS (outf, "=SIGN(");
d3566 1
a3566 1
      OUTS (outf, ")*");
d3568 1
a3568 1
      OUTS (outf, "+SIGN(");
d3570 1
a3570 1
      OUTS (outf, ")*");
a3571 1
      OUTS (outf, ")");
d3576 1
a3576 1
      OUTS (outf, "=");
d3578 1
a3578 1
      OUTS (outf, "-|+");
a3579 1
      OUTS (outf, " ");
d3585 1
a3585 1
      OUTS (outf, "=A1.L+A1.H,");
d3587 1
a3587 1
      OUTS (outf, "=A0.L+A0.H");
d3592 1
a3592 1
      OUTS (outf, "=");
d3594 1
a3594 1
      OUTS (outf, "+");
d3596 1
a3596 1
      OUTS (outf, ",");
d3598 1
a3598 1
      OUTS (outf, "=");
d3600 1
a3600 1
      OUTS (outf, "-");
a3601 1
      OUTS (outf, " ");
d3607 1
a3607 1
      OUTS (outf, "=");
d3609 1
a3609 1
      OUTS (outf, "+|+");
d3611 1
a3611 1
      OUTS (outf, ",");
d3613 1
a3613 1
      OUTS (outf, "=");
d3615 1
a3615 1
      OUTS (outf, "-|-");
d3622 1
a3622 1
      OUTS (outf, "=(A0+=A1)");
d3627 1
a3627 1
      OUTS (outf, "=A0.x");
d3632 1
a3632 1
      OUTS (outf, "=A1.x");
d3637 1
a3637 1
      OUTS (outf, "=");
d3639 1
a3639 1
      OUTS (outf, "+|-");
a3640 1
      OUTS (outf, " ");
d3646 1
a3646 1
      OUTS (outf, "=");
d3648 1
a3648 1
      OUTS (outf, "-|-");
a3649 1
      OUTS (outf, " ");
d3655 1
a3655 1
      OUTS (outf, "=");
d3657 1
a3657 1
      OUTS (outf, "-");
a3658 1
      OUTS (outf, " ");
d3664 1
a3664 1
      OUTS (outf, "=A1+A0,");
d3666 1
a3666 1
      OUTS (outf, "=A1-A0 ");
d3672 1
a3672 1
      OUTS (outf, "=A0+A1,");
d3674 1
a3674 1
      OUTS (outf, "=A0-A1 ");
d3679 1
a3679 1
      OUTS (outf, "SAA(");
d3682 2
a3683 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3686 2
a3687 2
      OUTS (outf, imm5 (src1));
      OUTS (outf, ") ");
d3696 1
a3696 1
      OUTS (outf, "=BYTEOP1P(");
d3699 2
a3700 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3703 1
a3703 1
      OUTS (outf, imm5 (src1));
d3710 1
a3710 1
      OUTS (outf, "=BYTEOP1P(");
d3713 2
a3714 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3717 2
a3718 2
      OUTS (outf, imm5 (src1));
      OUTS (outf, ")(T");
d3728 1
a3728 1
      OUTS (outf, ",");
d3730 1
a3730 1
      OUTS (outf, ")=BYTEOP16P(");
d3733 2
a3734 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3737 2
a3738 2
      OUTS (outf, imm5 (src1));
      OUTS (outf, ") ");
d3745 1
a3745 1
      OUTS (outf, ",");
d3747 1
a3747 1
      OUTS (outf, ")=BYTEOP16M(");
d3750 2
a3751 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, ",");
d3754 2
a3755 2
      OUTS (outf, imm5 (src1));
      OUTS (outf, ") ");
d3761 1
a3761 1
      OUTS (outf, "= ABS ");
d3767 1
a3767 1
      OUTS (outf, "=MIN(");
d3769 1
a3769 1
      OUTS (outf, ",");
d3776 1
a3776 1
      OUTS (outf, "=MAX(");
d3778 1
a3778 1
      OUTS (outf, ",");
d3785 1
a3785 1
      OUTS (outf, "= ABS ");
d3787 1
a3787 1
      OUTS (outf, "(V)");
d3792 1
a3792 1
      OUTS (outf, "=MIN(");
d3794 1
a3794 1
      OUTS (outf, ",");
d3796 1
a3796 1
      OUTS (outf, ")(V)");
d3801 1
a3801 1
      OUTS (outf, "=MAX(");
d3803 1
a3803 1
      OUTS (outf, ",");
d3805 1
a3805 1
      OUTS (outf, ")(V)");
d3810 1
a3810 1
      OUTS (outf, "=");
d3812 1
a3812 1
      OUTS (outf, "+|-");
d3814 1
a3814 1
      OUTS (outf, ",");
d3816 1
a3816 1
      OUTS (outf, "=");
d3818 1
a3818 1
      OUTS (outf, "-|+");
d3825 1
a3825 1
      OUTS (outf, "=");
d3827 1
a3827 1
      OUTS (outf, "+");
a3828 1
      OUTS (outf, " ");
d3834 1
a3834 1
      OUTS (outf, "=");
d3836 1
a3836 1
      OUTS (outf, "+|+");
a3837 1
      OUTS (outf, " ");
d3843 1
a3843 1
      OUTS (outf, "=BYTEPACK(");
d3845 1
a3845 1
      OUTS (outf, ",");
d3853 1
a3853 1
      OUTS (outf, ",");
d3858 1
a3858 2
      OUTS (outf, imm5 (src0));
      OUTS (outf, " ");
d3865 1
a3865 1
      OUTS (outf, ",");
d3869 1
a3869 1
      OUTS (outf, "(");
d3898 1
a3898 1
      OUTS (outf, "= ASHIFT ");
d3906 1
a3906 1
      OUTS (outf, "= ASHIFT ");
d3914 1
a3914 1
      OUTS (outf, "= ASHIFT ");
d3922 1
a3922 1
      OUTS (outf, "= ASHIFT ");
d3930 1
a3930 1
      OUTS (outf, "= ASHIFT ");
d3934 1
a3934 1
      OUTS (outf, "(S)");
d3939 1
a3939 1
      OUTS (outf, "= ASHIFT ");
d3943 1
a3943 1
      OUTS (outf, "(S)");
d3948 1
a3948 1
      OUTS (outf, "= ASHIFT ");
d3952 1
a3952 1
      OUTS (outf, "(S)");
d3957 1
a3957 1
      OUTS (outf, "= ASHIFT ");
d3961 1
a3961 1
      OUTS (outf, "(S)");
d3966 1
a3966 1
      OUTS (outf, "= LSHIFT ");
d3974 1
a3974 1
      OUTS (outf, "= ASHIFT ");
d3982 1
a3982 1
      OUTS (outf, "= LSHIFT ");
d3990 1
a3990 1
      OUTS (outf, "= ROT ");
d3998 1
a3998 1
      OUTS (outf, "= ROT ");
d4006 1
a4006 1
      OUTS (outf, "= ASHIFT ");
d4010 1
a4010 1
      OUTS (outf, "(V,S)");
d4015 1
a4015 1
      OUTS (outf, "= ASHIFT ");
d4019 1
a4019 1
      OUTS (outf, "(V)");
d4024 1
a4024 1
      OUTS (outf, "= ASHIFT ");
d4032 1
a4032 1
      OUTS (outf, "= ASHIFT ");
d4036 1
a4036 1
      OUTS (outf, "(S)");
d4041 1
a4041 1
      OUTS (outf, "=SHIFT ");
d4049 1
a4049 1
      OUTS (outf, "= ROT ");
d4057 1
a4057 1
      OUTS (outf, "=SHIFT ");
d4061 1
a4061 1
      OUTS (outf, "(V)");
d4066 1
a4066 2
      OUTS (outf, "=PACK");
      OUTS (outf, "(");
d4068 1
a4068 1
      OUTS (outf, ",");
d4075 1
a4075 1
      OUTS (outf, "=PACK(");
d4077 1
a4077 1
      OUTS (outf, ",");
d4084 1
a4084 1
      OUTS (outf, "=PACK(");
d4086 1
a4086 1
      OUTS (outf, ",");
d4093 1
a4093 1
      OUTS (outf, "=PACK(");
d4095 1
a4095 1
      OUTS (outf, ",");
d4102 1
a4102 1
      OUTS (outf, "=SIGNBITS ");
d4108 1
a4108 1
      OUTS (outf, "=SIGNBITS ");
d4114 1
a4114 1
      OUTS (outf, "=SIGNBITS ");
d4120 1
a4120 1
      OUTS (outf, "=SIGNBITS A0");
d4125 1
a4125 1
      OUTS (outf, "=SIGNBITS A1");
d4130 1
a4130 1
      OUTS (outf, "=ONES ");
d4136 1
a4136 1
      OUTS (outf, "=EXPADJ (");
d4138 1
a4138 1
      OUTS (outf, ",");
d4145 1
a4145 1
      OUTS (outf, "=EXPADJ (");
d4147 1
a4147 1
      OUTS (outf, ",");
d4154 1
a4154 1
      OUTS (outf, "=EXPADJ (");
d4156 1
a4156 1
      OUTS (outf, ",");
d4163 1
a4163 1
      OUTS (outf, "=EXPADJ (");
d4165 1
a4165 1
      OUTS (outf, ",");
d4173 1
a4173 1
      OUTS (outf, ",");
d4175 1
a4175 1
      OUTS (outf, ",A0 )(ASR)");
d4181 1
a4181 1
      OUTS (outf, ",");
d4183 1
a4183 1
      OUTS (outf, ",A0 )(ASL)");
d4188 1
a4188 1
      OUTS (outf, "=VIT_MAX (");
d4195 1
a4195 1
      OUTS (outf, "=VIT_MAX (");
d4202 1
a4202 1
      OUTS (outf, "=VIT_MAX(");
d4204 1
a4204 1
      OUTS (outf, ",");
d4206 1
a4206 1
      OUTS (outf, ")(ASL)");
d4211 1
a4211 1
      OUTS (outf, "=VIT_MAX(");
d4213 1
a4213 1
      OUTS (outf, ",");
d4215 1
a4215 1
      OUTS (outf, ")(ASR)");
d4220 1
a4220 1
      OUTS (outf, "=EXTRACT(");
d4222 1
a4222 1
      OUTS (outf, ",");
d4229 1
a4229 1
      OUTS (outf, "=EXTRACT(");
d4231 1
a4231 1
      OUTS (outf, ",");
d4233 1
a4233 1
      OUTS (outf, ")(X)");
d4238 1
a4238 1
      OUTS (outf, "=DEPOSIT(");
d4240 1
a4240 1
      OUTS (outf, ",");
d4247 1
a4247 1
      OUTS (outf, "=DEPOSIT(");
d4249 1
a4249 1
      OUTS (outf, ",");
d4251 1
a4251 1
      OUTS (outf, ")(X)");
d4256 1
a4256 1
      OUTS (outf, "=CC=BXORSHIFT(A0,");
d4263 1
a4263 1
      OUTS (outf, "=CC=BXOR(A0,");
d4268 1
a4268 1
    OUTS (outf, "A0=BXORSHIFT(A0,A1 ,CC)");
d4273 1
a4273 1
      OUTS (outf, "=CC=BXOR( A0,A1 ,CC )");
d4278 1
a4278 1
      OUTS (outf, "=ALIGN8(");
d4280 1
a4280 1
      OUTS (outf, ",");
d4287 1
a4287 1
      OUTS (outf, "=ALIGN16(");
d4289 1
a4289 1
      OUTS (outf, ",");
d4296 1
a4296 1
      OUTS (outf, "=ALIGN24(");
d4298 1
a4298 1
      OUTS (outf, ",");
d4370 1
a4370 1
      OUTS (outf, "A1= ROT A1 BY ");
d4375 1
a4375 1
      OUTS (outf, "A0=A0<<");
d4380 1
a4380 1
      OUTS (outf, "A0=A0>>>");
d4385 1
a4385 1
      OUTS (outf, "A1=A1<<");
d4390 1
a4390 1
      OUTS (outf, "A1=A1>>>");
d4395 1
a4395 1
      OUTS (outf, "A0=A0>>");
d4400 1
a4400 1
      OUTS (outf, "A1=A1>>");
d4405 1
a4405 1
      OUTS (outf, "A0= ROT A0 BY ");
d4411 1
a4411 1
      OUTS (outf, "=");
d4413 1
a4413 1
      OUTS (outf, "<<");
d4420 1
a4420 1
      OUTS (outf, "=");
d4422 1
a4422 1
      OUTS (outf, ">>>");
d4429 1
a4429 1
      OUTS (outf, "=");
d4438 1
a4438 1
      OUTS (outf, "=");
d4440 1
a4440 1
      OUTS (outf, "<<");
d4447 1
a4447 1
      OUTS (outf, "=");
d4449 1
a4449 1
      OUTS (outf, ">>>");
d4456 1
a4456 1
      OUTS (outf, "=");
d4458 1
a4458 1
      OUTS (outf, "<<");
d4460 1
a4460 1
      OUTS (outf, "(S)");
d4465 1
a4465 1
      OUTS (outf, "=");
d4467 1
a4467 1
      OUTS (outf, ">>");
d4473 1
a4473 1
      OUTS (outf, "=");
d4475 1
a4475 1
      OUTS (outf, "<<");
d4481 1
a4481 1
      OUTS (outf, "= ROT ");
d4489 1
a4489 1
      OUTS (outf, "=");
d4491 1
a4491 1
      OUTS (outf, ">>>");
d4528 1
a4528 1
      OUTS (outf, "DBGCMPLX(");
d4570 1
a4570 1
      OUTS (outf, "DBGA(");
d4572 1
a4572 1
      OUTS (outf, ",");
d4578 1
a4578 1
      OUTS (outf, "DBGA(");
d4580 1
a4580 1
      OUTS (outf, ",");
d4586 1
a4586 1
      OUTS (outf, "DBGAL(");
d4588 1
a4588 1
      OUTS (outf, ",");
d4594 1
a4594 1
      OUTS (outf, "DBGAH(");
d4596 1
a4596 1
      OUTS (outf, ",");
d4622 1
a4622 1
      OUTS (outf, "mnop");
d4724 1
d4729 1
d4736 5
a4740 1
  outf->fprintf_func (outf->stream, ";");
@


1.6
log
@opcodes:
	From  Robin Getz  <robin.getz@@analog.com>
	* bfin-dis.c (bu32): Typedef.
	(enum const_forms_t): Add c_uimm32 and c_huimm32.
	(constant_formats[]): Add uimm32 and huimm16.
	(fmtconst_val): New.
	(uimm32): Define.
	(huimm32): Define.
	(imm16_val): Define.
	(luimm16_val): Define.
	(struct saved_state): Define.
	(GREG, DPREG, DREG, PREG, SPREG, FPREG, IREG, MREG, BREG, LREG,
	A0XREG, A0WREG, A1XREG, A1WREG,CCREG, LC0REG, LT0REG, LB0REG,
	LC1REG, LT1REG, LB1REG, RETSREG, PCREG): Define.
	(get_allreg): New.
	(decode_LDIMMhalf_0): Print out the whole register value.

gas/testsuite:
	From Jie Zhang  <jie.zhang@@analog.com>
	* gas/bfin/load.d: Update.
@
text
@d2758 1
a2758 1
  if (((1 << mmod) & (P ? 0x31b : 0x1b5f)) == 0)
@


1.5
log
@Change source files over to GPLv3.
@
text
@d54 2
d62 1
a62 1
  c_uimm16, c_pcrel24,
d111 3
a113 1
  { "pcrel24", 24, 1, 1, 1, 1, 0, 0, 0}
d160 31
d434 4
d607 89
d2475 29
d2541 1
a2541 1
      OUTS (outf, luimm16 (hword));
d2547 1
a2547 1
      OUTS (outf, huimm16 (hword));
d2552 13
@


1.4
log
@	* bfin-dis.c (decode_dsp32shiftimm_0): Simplify and correct the
	logic to identify halfword shifts.
@
text
@d2 1
a2 1
   Copyright 2005 Free Software Foundation, Inc.
d4 3
a6 1
   This program is free software; you can redistribute it and/or modify
d8 2
a9 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d11 4
a14 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.3
log
@bfin-dis.c: Tidy up code, removing redundant constructs.
@
text
@d4037 1
a4037 1
  if (HLs == 0 && sop == 0 && sopcde == 0)
d4039 4
a4042 28
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, ">>>");
      OUTS (outf, uimm4 (newimmag));
    }
  else if (HLs == 1 && sop == 0 && sopcde == 0)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, ">>>");
      OUTS (outf, uimm4 (newimmag));
    }
  else if (HLs == 2 && sop == 0 && sopcde == 0)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, ">>>");
      OUTS (outf, uimm4 (newimmag));
    }
  else if (HLs == 3 && sop == 0 && sopcde == 0)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, ">>>");
d4045 1
a4045 1
  else if (HLs == 0 && sop == 1 && sopcde == 0)
d4047 4
a4050 13
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, "<<");
      OUTS (outf, uimm4 (immag));
      OUTS (outf, "(S)");
    }
  else if (HLs == 1 && sop == 1 && sopcde == 0)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, "<<");
d4052 1
a4052 10
      OUTS (outf, "(S)");
    }
  else if (HLs == 2 && sop == 1 && sopcde == 0)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, "<<");
      OUTS (outf, uimm4 (immag));
      OUTS (outf, "(S)");
d4054 1
a4054 1
  else if (HLs == 3 && sop == 1 && sopcde == 0)
d4056 4
a4059 37
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, "<<");
      OUTS (outf, uimm4 (immag));
      OUTS (outf, "(S)");
    }
  else if (HLs == 0 && sop == 2 && sopcde == 0 && bit8 == 0)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, "<<");
      OUTS (outf, uimm4 (immag));
    }
  else if (HLs == 0 && sop == 2 && sopcde == 0 && bit8 == 1)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, ">>");
      OUTS (outf, uimm4 (newimmag));
    }
  else if (HLs == 1 && sop == 2 && sopcde == 0)
    {
      OUTS (outf, dregs_lo (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, ">>");
      OUTS (outf, uimm4 (newimmag));
    }
  else if (HLs == 2 && sop == 2 && sopcde == 0 && bit8 == 1)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, ">>");
d4061 1
d4063 1
a4063 1
  else if (HLs == 2 && sop == 2 && sopcde == 0 && bit8 == 0)
d4065 4
a4068 4
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_lo (src1));
      OUTS (outf, "<<");
d4071 1
a4071 1
  else if (HLs == 3 && sop == 2 && sopcde == 0 && bit8 == 1)
d4073 4
a4076 4
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, ">>");
a4078 8
  else if (HLs == 3 && sop == 2 && sopcde == 0 && bit8 == 0)
    {
      OUTS (outf, dregs_hi (dst0));
      OUTS (outf, "=");
      OUTS (outf, dregs_hi (src1));
      OUTS (outf, "<<");
      OUTS (outf, uimm4 (immag));
    }
@


1.2
log
@	* bfin-dis.c (print_insn_bfin): Do proper endian transform when
	reading instruction from memory.
@
text
@d45 4
a48 1
#define HOST_LONG_WORD_SIZE (sizeof(long)*8)
d50 1
a50 4
#define XFIELD(w,p,s) (((w)&((1<<(s))-1)<<(p))>>(p))

#define SIGNEXTEND(v, n) ((v << (HOST_LONG_WORD_SIZE - (n))) >> (HOST_LONG_WORD_SIZE - (n)))
#define MASKBITS(val, bits) (val & (( 1 << bits)-1))
a51 2

#include "dis-asm.h"
d133 1
a153 7
#undef SIGNEXTEND
#undef MASKBITS
#undef HOST_LONG_WORD_SIZE
#define HOST_LONG_WORD_SIZE (sizeof(long)*8)
#define SIGNEXTEND(v, n) (((long)(v) << (HOST_LONG_WORD_SIZE - (n))) >> (HOST_LONG_WORD_SIZE - (n)))
#define MASKBITS(val, bits) (val & (( 1 << bits)-1))

d223 1
a223 1
#define dregs_lo(x) REGNAME(decode_dregs_lo[(x) & 7])
d231 1
a231 1
#define dregs_hi(x) REGNAME(decode_dregs_hi[(x) & 7])
d239 1
a239 1
#define dregs(x) REGNAME(decode_dregs[(x) & 7])
d247 2
a248 2
#define dregs_byte(x) REGNAME(decode_dregs_byte[(x) & 7])
#define dregs_pair(x) REGNAME(decode_dregs_pair[(x) & 7])
d256 6
a261 6
#define pregs(x)	REGNAME(decode_pregs[(x) & 7])
#define spfp(x)		REGNAME(decode_spfp[(x) & 1])
#define dregs_hilo(x,i)	REGNAME(decode_dregs_hilo[((i)<<3)|x])
#define accum_ext(x)	REGNAME(decode_accum_ext[(x) & 1])
#define accum_word(x)	REGNAME(decode_accum_word[(x) & 1])
#define accum(x)	REGNAME(decode_accum[(x) & 1])
d269 1
a269 1
#define iregs(x) REGNAME(decode_iregs[(x) & 3])
d277 3
a279 3
#define mregs(x) REGNAME(decode_mregs[(x) & 3])
#define bregs(x) REGNAME(decode_bregs[(x) & 3])
#define lregs(x) REGNAME(decode_lregs[(x) & 3])
d288 1
a288 1
#define dpregs(x) REGNAME(decode_dpregs[(x) & 15])
d297 1
a297 1
#define gregs(x,i) REGNAME(decode_gregs[((i)<<3)|x])
d308 1
a308 1
#define regs(x,i) REGNAME(decode_regs[((i)<<3)|x])
d319 1
a319 1
#define regs_lo(x,i) REGNAME(decode_regs_lo[((i)<<3)|x])
d329 1
a329 1
#define regs_hi(x,i) REGNAME(decode_regs_hi[((i)<<3)|x])
d339 3
a341 3
#define statbits(x)	REGNAME(decode_statbits[(x) & 31])
#define ignore_bits(x)	REGNAME(decode_ignore_bits[(x) & 7])
#define ccstat(x)	REGNAME(decode_ccstat[(x) & 0])
d349 2
a350 2
#define counters(x) REGNAME(decode_counters[(x) & 1])
#define dregs2_sysregs1(x) REGNAME(decode_dregs2_sysregs1[(x) & 7])
d366 31
a396 31
#define allregs(x,i)	REGNAME(decode_allregs[((i) << 3) | x])
#define uimm16s4(x)	fmtconst(c_uimm16s4, x, 0, outf)
#define pcrel4(x)	fmtconst(c_pcrel4, x, pc, outf)
#define pcrel8(x)	fmtconst(c_pcrel8, x, pc, outf)
#define pcrel8s4(x)	fmtconst(c_pcrel8s4, x, pc, outf)
#define pcrel10(x)	fmtconst(c_pcrel10, x, pc, outf)
#define pcrel12(x)	fmtconst(c_pcrel12, x, pc, outf)
#define negimm5s4(x)	fmtconst(c_negimm5s4, x, 0, outf)
#define rimm16(x)	fmtconst(c_rimm16, x, 0, outf)
#define huimm16(x)	fmtconst(c_huimm16, x, 0, outf)
#define imm16(x)	fmtconst(c_imm16, x, 0, outf)
#define uimm2(x)	fmtconst(c_uimm2, x, 0, outf)
#define uimm3(x)	fmtconst(c_uimm3, x, 0, outf)
#define luimm16(x)	fmtconst(c_luimm16, x, 0, outf)
#define uimm4(x)	fmtconst(c_uimm4, x, 0, outf)
#define uimm5(x)	fmtconst(c_uimm5, x, 0, outf)
#define imm16s2(x)	fmtconst(c_imm16s2, x, 0, outf)
#define uimm8(x)	fmtconst(c_uimm8, x, 0, outf)
#define imm16s4(x)	fmtconst(c_imm16s4, x, 0, outf)
#define uimm4s2(x)	fmtconst(c_uimm4s2, x, 0, outf)
#define uimm4s4(x)	fmtconst(c_uimm4s4, x, 0, outf)
#define lppcrel10(x)	fmtconst(c_lppcrel10, x, pc, outf)
#define imm3(x)		fmtconst(c_imm3, x, 0, outf)
#define imm4(x)		fmtconst(c_imm4, x, 0, outf)
#define uimm8s4(x)	fmtconst(c_uimm8s4, x, 0, outf)
#define imm5(x)		fmtconst(c_imm5, x, 0, outf)
#define imm6(x)		fmtconst(c_imm6, x, 0, outf)
#define imm7(x)		fmtconst(c_imm7, x, 0, outf)
#define imm8(x)		fmtconst(c_imm8, x, 0, outf)
#define pcrel24(x)	fmtconst(c_pcrel24, x, pc, outf)
#define uimm16(x)	fmtconst(c_uimm16, x, 0, outf)
a398 2
#define notethat(x)

d400 1
a400 1
#define OUTS(p,txt) ((p) ? (((txt)[0]) ? (p->fprintf_func)(p->stream, txt) :0) :0)
a402 1

d406 2
a407 11
  if (s0 == 0 && x0 == 0)
    {
      notethat ("(NS)");
      return;
    }
  else if (s0 == 1 && x0 == 0)
    {
      notethat ("(S)");
      OUTS (outf, "(S)");
      return;
    }
d409 1
a409 5
    {
      notethat ("(CO)");
      OUTS (outf, "(CO)");
      return;
    }
d411 1
a411 9
    {
      notethat ("(SCO)");
      OUTS (outf, "(SCO)");
      return;
    }
  else
    goto illegal_instruction;
illegal_instruction:
  return;
d418 1
a418 5
    {
      notethat ("(NS)");
      OUTS (outf, "(NS)");
      return;
    }
d420 1
a420 9
    {
      notethat ("(S)");
      OUTS (outf, "(S)");
      return;
    }
  else
    goto illegal_instruction;
illegal_instruction:
  return;
d426 2
a427 11
  if (s0 == 0 && x0 == 0 && aop0 == 0)
    {
      notethat ("(NS)");
      return;
    }
  else if (s0 == 1 && x0 == 0 && aop0 == 0)
    {
      notethat ("(S)");
      OUTS (outf, "(S)");
      return;
    }
d429 1
a429 5
    {
      notethat ("(CO)");
      OUTS (outf, "(CO)");
      return;
    }
d431 1
a431 5
    {
      notethat ("(SCO)");
      OUTS (outf, "(SCO)");
      return;
    }
d433 1
a433 5
    {
      notethat ("(ASR)");
      OUTS (outf, "(ASR)");
      return;
    }
d435 1
a435 5
    {
      notethat ("(S,ASR)");
      OUTS (outf, "(S,ASR)");
      return;
    }
d437 1
a437 5
    {
      notethat ("(CO,ASR)");
      OUTS (outf, "(CO,ASR)");
      return;
    }
d439 1
a439 5
    {
      notethat ("(SCO,ASR)");
      OUTS (outf, "(SCO,ASR)");
      return;
    }
d441 1
a441 5
    {
      notethat ("(ASL)");
      OUTS (outf, "(ASL)");
      return;
    }
d443 1
a443 5
    {
      notethat ("(S,ASL)");
      OUTS (outf, "(S,ASL)");
      return;
    }
d445 1
a445 5
    {
      notethat ("(CO,ASL)");
      OUTS (outf, "(CO,ASL)");
      return;
    }
d447 1
a447 9
    {
      notethat ("(SCO,ASL)");
      OUTS (outf, "(SCO,ASL)");
      return;
    }
  else
    goto illegal_instruction;
illegal_instruction:
  return;
d453 8
a460 28
  if ((r0 == 0))
    {
      notethat ("GT");
      OUTS (outf, "GT");
      return;
    }
  else if ((r0 == 1))
    {
      notethat ("GE");
      OUTS (outf, "GE");
      return;
    }
  else if ((r0 == 2))
    {
      notethat ("LT");
      OUTS (outf, "LT");
      return;
    }
  else if ((r0 == 3))
    {
      notethat ("LE");
      OUTS (outf, "LE");
      return;
    }
  else
    goto illegal_instruction;
illegal_instruction:
  return;
d466 2
a467 15
  if ((r0 == 0))
    {
      notethat ("");
      return;
    }
  else if ((r0 == 1))
    {
      notethat ("(R)");
      OUTS (outf, "(R)");
      return;
    }
  else
    goto illegal_instruction;
illegal_instruction:
  return;
d510 4
a513 9
    case 0:
      sop = "=";
      break;
    case 1:
      sop = "+=";
      break;
    case 2:
      sop = "-=";
      break;
d541 1
a541 1
  
d565 1
d569 4
a572 5
/* ProgCtrl
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |.prgfunc.......|.poprnd........|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
d577 1
a577 5
    {
      notethat ("NOP");
      OUTS (outf, "NOP");
      return 1 * 2;
    }
d579 1
a579 5
    {
      notethat ("RTS");
      OUTS (outf, "RTS");
      return 1 * 2;
    }
d581 1
a581 5
    {
      notethat ("RTI");
      OUTS (outf, "RTI");
      return 1 * 2;
    }
d583 1
a583 5
    {
      notethat ("RTX");
      OUTS (outf, "RTX");
      return 1 * 2;
    }
d585 1
a585 5
    {
      notethat ("RTN");
      OUTS (outf, "RTN");
      return 1 * 2;
    }
d587 1
a587 5
    {
      notethat ("RTE");
      OUTS (outf, "RTE");
      return 1 * 2;
    }
d589 1
a589 5
    {
      notethat ("IDLE");
      OUTS (outf, "IDLE");
      return 1 * 2;
    }
d591 1
a591 5
    {
      notethat ("CSYNC");
      OUTS (outf, "CSYNC");
      return 1 * 2;
    }
d593 1
a593 5
    {
      notethat ("SSYNC");
      OUTS (outf, "SSYNC");
      return 1 * 2;
    }
d595 1
a595 5
    {
      notethat ("EMUEXCPT");
      OUTS (outf, "EMUEXCPT");
      return 1 * 2;
    }
a597 1
      notethat ("CLI dregs");
a599 1
      return 1 * 2;
a602 1
      notethat ("STI dregs");
a604 1
      return 1 * 2;
a607 1
      notethat ("JUMP ( pregs )");
a610 1
      return 1 * 2;
a613 1
      notethat ("CALL ( pregs )");
a616 1
      return 1 * 2;
a619 1
      notethat ("CALL ( PC + pregs )");
a622 1
      return 1 * 2;
a625 1
      notethat ("JUMP ( PC + pregs )");
a628 1
      return 1 * 2;
a631 1
      notethat ("RAISE uimm4");
a633 1
      return 1 * 2;
a636 1
      notethat ("EXCPT uimm4");
a638 1
      return 1 * 2;
a641 1
      notethat ("TESTSET ( pregs )");
a644 1
      return 1 * 2;
d647 2
a648 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d654 4
a657 5
/* CaCTRL
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |.a.|.op....|.reg.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a663 1
      notethat ("PREFETCH [ pregs ]");
a666 1
      return 1 * 2;
a669 1
      notethat ("FLUSHINV [ pregs ]");
a672 1
      return 1 * 2;
a675 1
      notethat ("FLUSH [ pregs ]");
a678 1
      return 1 * 2;
a681 1
      notethat ("IFLUSH [ pregs ]");
a684 1
      return 1 * 2;
a687 1
      notethat ("PREFETCH [ pregs ++ ]");
a690 1
      return 1 * 2;
a693 1
      notethat ("FLUSHINV [ pregs ++ ]");
a696 1
      return 1 * 2;
a699 1
      notethat ("FLUSH [ pregs ++ ]");
a702 1
      return 1 * 2;
a705 1
      notethat ("IFLUSH [ pregs ++ ]");
a708 1
      return 1 * 2;
d711 2
a712 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d718 4
a721 6

/* PushPopReg
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 |.W.|.grp.......|.reg.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a727 1
      notethat ("allregs = [ SP ++ ]");
a729 1
      return 1 * 2;
a732 1
      notethat ("[ -- SP ] = allregs");
a734 1
      return 1 * 2;
d737 2
a738 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d744 4
a747 5
/* PushPopMultiple
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 1 | 0 |.d.|.p.|.W.|.dr........|.pr........|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
d753 1
a754 1
  char ps[5], ds[5];
a759 1
      notethat ("[ -- SP ] = ( R7 : reglim , P5 : reglim )");
a764 1
      return 1 * 2;
a767 1
      notethat ("[ -- SP ] = ( R7 : reglim )");
a770 1
      return 1 * 2;
a773 1
      notethat ("[ -- SP ] = ( P5 : reglim )");
a776 1
      return 1 * 2;
a779 1
      notethat ("( R7 : reglim , P5 : reglim ) = [ SP ++ ]");
a784 1
      return 1 * 2;
a787 1
      notethat ("( R7 : reglim ) = [ SP ++ ]");
a790 1
      return 1 * 2;
a793 1
      notethat ("( P5 : reglim ) = [ SP ++ ]");
a796 1
      return 1 * 2;
d799 2
a800 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d806 4
a809 5
/* ccMV
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 1 | 1 |.T.|.d.|.s.|.dst.......|.src.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a817 1
      notethat ("IF CC gregs = gregs");
a821 1
      return 1 * 2;
a824 1
      notethat ("IF ! CC gregs = gregs");
a828 1
      return 1 * 2;
d831 2
a832 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d838 4
a841 5
/* CCflag
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 0 | 0 | 1 |.I.|.opc.......|.G.|.y.........|.x.........|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a849 1
      notethat ("CC = dregs == dregs");
a853 1
      return 1 * 2;
a856 1
      notethat ("CC = dregs < dregs");
a860 1
      return 1 * 2;
a863 1
      notethat ("CC = dregs <= dregs");
a867 1
      return 1 * 2;
a870 1
      notethat ("CC = dregs < dregs ( IU )");
a875 1
      return 1 * 2;
a878 1
      notethat ("CC = dregs <= dregs ( IU )");
a883 1
      return 1 * 2;
a886 1
      notethat ("CC = dregs == imm3");
a890 1
      return 1 * 2;
a893 1
      notethat ("CC = dregs < imm3");
a897 1
      return 1 * 2;
a900 1
      notethat ("CC = dregs <= imm3");
a904 1
      return 1 * 2;
a907 1
      notethat ("CC = dregs < uimm3 ( IU )");
a912 1
      return 1 * 2;
a915 1
      notethat ("CC = dregs <= uimm3 ( IU )");
a920 1
      return 1 * 2;
a923 1
      notethat ("CC = pregs == pregs");
a927 1
      return 1 * 2;
a930 1
      notethat ("CC = pregs < pregs");
a934 1
      return 1 * 2;
a937 1
      notethat ("CC = pregs <= pregs");
a941 1
      return 1 * 2;
a944 1
      notethat ("CC = pregs < pregs ( IU )");
a949 1
      return 1 * 2;
a952 1
      notethat ("CC = pregs <= pregs ( IU )");
a957 1
      return 1 * 2;
a960 1
      notethat ("CC = pregs == imm3");
a964 1
      return 1 * 2;
a967 1
      notethat ("CC = pregs < imm3");
a971 1
      return 1 * 2;
a974 1
      notethat ("CC = pregs <= imm3");
a978 1
      return 1 * 2;
a981 1
      notethat ("CC = pregs < uimm3 ( IU )");
a986 1
      return 1 * 2;
a989 1
      notethat ("CC = pregs <= uimm3 ( IU )");
a994 1
      return 1 * 2;
d997 2
a998 5
    {
      notethat ("CC = A0 == A1");
      OUTS (outf, "CC=A0==A1");
      return 1 * 2;
    }
d1000 2
a1001 5
    {
      notethat ("CC = A0 < A1");
      OUTS (outf, "CC=A0<A1");
      return 1 * 2;
    }
d1003 2
a1004 5
    {
      notethat ("CC = A0 <= A1");
      OUTS (outf, "CC=A0<=A1");
      return 1 * 2;
    }
d1006 2
a1007 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1013 4
a1016 5
/* CC2dreg
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |.op....|.reg.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1021 1
      notethat ("dregs = CC");
a1023 1
      return 1 * 2;
a1026 1
      notethat ("CC = dregs");
a1028 1
      return 1 * 2;
d1031 1
a1031 5
    {
      notethat ("CC =! CC");
      OUTS (outf, "CC=!CC");
      return 1 * 2;
    }
d1033 3
a1035 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1041 4
a1044 5
/* CC2stat
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |.D.|.op....|.cbit..............|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1050 1
      notethat ("CC = statbits");
a1052 1
      return 1 * 2;
a1055 1
      notethat ("CC |= statbits");
a1057 1
      return 1 * 2;
a1060 1
      notethat ("CC &= statbits");
a1062 1
      return 1 * 2;
a1065 1
      notethat ("CC ^= statbits");
a1067 1
      return 1 * 2;
a1070 1
      notethat ("statbits = CC");
a1072 1
      return 1 * 2;
a1075 1
      notethat ("statbits |= CC");
a1077 1
      return 1 * 2;
a1080 1
      notethat ("statbits &= CC");
a1082 1
      return 1 * 2;
a1085 1
      notethat ("statbits ^= CC");
a1087 1
      return 1 * 2;
d1090 3
a1092 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1098 4
a1101 5
/* BRCC
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 0 | 1 |.T.|.B.|.offset................................|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1107 1
      notethat ("IF CC JUMP pcrel10 ( BP )");
a1110 1
      return 1 * 2;
a1113 1
      notethat ("IF !CC JUMP pcrel10 ( BP )");
a1116 1
      return 1 * 2;
a1119 1
      notethat ("IF CC JUMP pcrel10");
a1121 1
      return 1 * 2;
a1124 1
      notethat ("IF !CC JUMP pcrel10");
a1126 1
      return 1 * 2;
d1129 3
a1131 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1137 4
a1140 5
/* UJUMP
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 1 | 0 |.offset........................................|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1142 1
  notethat ("JUMP.S pcrel12");
d1145 1
a1145 1
  return 1 * 2;
d1151 4
a1154 5
/* REGMV
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 0 | 1 | 1 |.gd........|.gs........|.dst.......|.src.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1159 1
  notethat ("allregs = allregs");
d1163 1
a1163 1
  return 1 * 2;
d1169 4
a1172 5
/* ALU2op
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 1 | 0 | 0 | 0 | 0 |.opc...........|.src.......|.dst.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1178 1
      notethat ("dregs >>>= dregs");
a1181 1
      return 1 * 2;
a1184 1
      notethat ("dregs >>= dregs");
a1187 1
      return 1 * 2;
a1190 1
      notethat ("dregs <<= dregs");
a1193 1
      return 1 * 2;
a1196 1
      notethat ("dregs *= dregs");
a1199 1
      return 1 * 2;
a1202 1
      notethat ("dregs = (dregs + dregs) << 1");
a1208 1
      return 1 * 2;
a1211 1
      notethat ("dregs = (dregs + dregs) << 2");
a1217 1
      return 1 * 2;
a1220 1
      notethat ("DIVQ (dregs , dregs)");
a1225 1
      return 1 * 2;
a1228 1
      notethat ("DIVS (dregs , dregs)");
a1233 1
      return 1 * 2;
a1236 1
      notethat ("dregs = dregs_lo (X)");
a1240 1
      return 1 * 2;
a1243 1
      notethat ("dregs = dregs_lo (Z)");
a1247 1
      return 1 * 2;
a1250 1
      notethat ("dregs = dregs_byte (X)");
a1254 1
      return 1 * 2;
a1257 1
      notethat ("dregs = dregs_byte (Z)");
a1261 1
      return 1 * 2;
a1264 1
      notethat ("dregs = - dregs");
a1267 1
      return 1 * 2;
a1270 1
      notethat ("dregs = ~ dregs");
a1273 1
      return 1 * 2;
d1276 3
a1278 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1284 4
a1287 5
/* PTR2op
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 1 | 0 | 0 | 0 | 1 | 0 |.opc.......|.src.......|.dst.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1293 1
      notethat ("pregs -= pregs");
a1296 1
      return 1 * 2;
a1299 1
      notethat ("pregs = pregs << 2");
a1303 1
      return 1 * 2;
a1306 1
      notethat ("pregs = pregs >> 2");
a1310 1
      return 1 * 2;
a1313 1
      notethat ("pregs = pregs >> 1");
a1317 1
      return 1 * 2;
a1320 1
      notethat ("pregs += pregs ( BREV )");
a1324 1
      return 1 * 2;
a1327 1
      notethat ("pregs = (pregs + pregs) << 1");
a1333 1
      return 1 * 2;
a1336 1
      notethat ("pregs = (pregs + pregs) << 2");
a1342 1
      return 1 * 2;
d1345 3
a1347 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1353 4
a1356 5
/* LOGI2op
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 1 | 0 | 0 | 1 |.opc.......|.src...............|.dst.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1362 1
      notethat ("CC = ! BITTST ( dregs , uimm5 )");
a1367 1
      return 1 * 2;
a1370 1
      notethat ("CC = BITTST ( dregs , uimm5 )");
a1375 1
      return 1 * 2;
a1378 1
      notethat ("BITSET ( dregs , uimm5 )");
a1383 1
      return 1 * 2;
a1386 1
      notethat ("BITTGL ( dregs , uimm5 )");
a1391 1
      return 1 * 2;
a1394 1
      notethat ("BITCLR ( dregs , uimm5 )");
a1399 1
      return 1 * 2;
a1402 1
      notethat ("dregs >>>= uimm5");
a1405 1
      return 1 * 2;
a1408 1
      notethat ("dregs >>= uimm5");
a1411 1
      return 1 * 2;
a1414 1
      notethat ("dregs <<= uimm5");
a1417 1
      return 1 * 2;
d1420 3
a1422 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1428 4
a1431 5
/* COMP3op
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 1 | 0 | 1 |.opc.......|.dst.......|.src1......|.src0......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1438 1
      notethat ("pregs = pregs << 1");
a1442 1
      return 1 * 2;
a1445 1
      notethat ("dregs = dregs - dregs");
a1450 1
      return 1 * 2;
a1453 1
      notethat ("dregs = dregs & dregs");
a1458 1
      return 1 * 2;
a1461 1
      notethat ("dregs = dregs | dregs");
a1466 1
      return 1 * 2;
a1469 1
      notethat ("dregs = dregs ^ dregs");
a1474 1
      return 1 * 2;
a1477 1
      notethat ("pregs = pregs + pregs");
a1482 1
      return 1 * 2;
a1485 1
      notethat ("pregs = pregs + (pregs << 1)");
a1491 1
      return 1 * 2;
a1494 1
      notethat ("pregs = pregs + (pregs << 2)");
a1500 1
      return 1 * 2;
a1503 1
      notethat ("dregs = dregs + dregs");
a1508 1
      return 1 * 2;
d1511 3
a1513 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1519 4
a1522 5
/* COMPI2opD
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 1 | 1 | 0 | 0 |.op|..src......................|.dst.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1528 1
      notethat ("dregs = imm7 (x)");
a1532 1
      return 1 * 2;
a1535 1
      notethat ("dregs += imm7");
a1538 1
      return 1 * 2;
d1541 3
a1543 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1549 4
a1552 5
/* COMPI2opP
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 0 | 1 | 1 | 0 | 1 |.op|.src.......................|.dst.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1558 1
      notethat ("pregs = imm7");
a1561 1
      return 1 * 2;
a1564 1
      notethat ("pregs += imm7");
a1567 1
      return 1 * 2;
d1570 3
a1572 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1578 4
a1581 5
/* LDSTpmod
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 0 | 0 | 0 |.W.|.aop...|.reg.......|.idx.......|.ptr.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1589 1
      notethat ("dregs_lo = W [ pregs ]");
a1593 1
      return 1 * 2;
a1596 1
      notethat ("dregs_hi = W [ pregs ]");
a1600 1
      return 1 * 2;
a1603 1
      notethat ("W [ pregs ] = dregs_lo");
a1607 1
      return 1 * 2;
a1610 1
      notethat ("W [ pregs ] = dregs_hi");
a1614 1
      return 1 * 2;
a1617 1
      notethat ("dregs = [ pregs ++ pregs ]");
a1623 1
      return 1 * 2;
a1626 1
      notethat ("dregs_lo = W [ pregs ++ pregs ]");
a1632 1
      return 1 * 2;
a1635 1
      notethat ("dregs_hi = W [ pregs ++ pregs ]");
a1641 1
      return 1 * 2;
a1644 1
      notethat ("dregs = W [ pregs ++ pregs ] (Z)");
a1650 1
      return 1 * 2;
a1653 1
      notethat ("dregs = W [ pregs ++ pregs ] (X)");
a1659 1
      return 1 * 2;
a1662 1
      notethat ("[ pregs ++ pregs ] = dregs");
a1668 1
      return 1 * 2;
a1671 1
      notethat (" W [ pregs ++ pregs ] = dregs_lo");
a1677 1
      return 1 * 2;
a1680 1
      notethat (" W[ pregs ++ pregs ] = dregs_hi");
a1686 1
      return 1 * 2;
d1689 3
a1691 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1697 4
a1700 5
/* dagMODim
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |.br| 1 | 1 |.op|.m.....|.i.....|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1707 1
      notethat ("iregs += mregs ( BREV )");
a1711 1
      return 1 * 2;
a1714 1
      notethat ("iregs += mregs");
a1717 1
      return 1 * 2;
a1720 1
      notethat ("iregs -= mregs");
a1723 1
      return 1 * 2;
d1726 3
a1728 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1734 4
a1737 5
/* dagMODik
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 0 |.op....|.i.....|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1742 1
      notethat ("iregs += 2");
a1744 1
      return 1 * 2;
a1747 1
      notethat ("iregs -= 2");
a1749 1
      return 1 * 2;
a1752 1
      notethat ("iregs += 4");
a1754 1
      return 1 * 2;
a1757 1
      notethat ("iregs -= 4");
a1759 1
      return 1 * 2;
d1762 3
a1764 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1770 4
a1773 5
/* dspLDST
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 0 | 0 | 1 | 1 | 1 |.W.|.aop...|.m.....|.i.....|.reg.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1781 1
      notethat ("dregs = [ iregs ++ ]");
a1785 1
      return 1 * 2;
a1788 1
      notethat ("dregs_lo = W [ iregs ++ ]");
a1792 1
      return 1 * 2;
a1795 1
      notethat ("dregs_hi = W [ iregs ++ ]");
a1799 1
      return 1 * 2;
a1802 1
      notethat ("dregs = [ iregs -- ]");
a1806 1
      return 1 * 2;
a1809 1
      notethat ("dregs_lo = W [ iregs -- ]");
a1813 1
      return 1 * 2;
a1816 1
      notethat ("dregs_hi = W [ iregs -- ]");
a1820 1
      return 1 * 2;
a1823 1
      notethat ("dregs = [ iregs ]");
a1827 1
      return 1 * 2;
a1830 1
      notethat ("dregs_lo = W [ iregs ]");
a1834 1
      return 1 * 2;
a1837 1
      notethat ("dregs_hi = W [ iregs ]");
a1841 1
      return 1 * 2;
a1844 1
      notethat ("[ iregs ++ ] = dregs");
a1848 1
      return 1 * 2;
a1851 1
      notethat ("W [ iregs ++ ] = dregs_lo");
a1855 1
      return 1 * 2;
a1858 1
      notethat ("W [ iregs ++ ] = dregs_hi");
a1862 1
      return 1 * 2;
a1865 1
      notethat ("[ iregs -- ] = dregs");
a1869 1
      return 1 * 2;
a1872 1
      notethat ("W [ iregs -- ] = dregs_lo");
a1876 1
      return 1 * 2;
a1879 1
      notethat ("W [ iregs -- ] = dregs_hi");
a1883 1
      return 1 * 2;
a1886 1
      notethat ("[ iregs ] = dregs");
a1890 1
      return 1 * 2;
a1893 1
      notethat (" W [ iregs ] = dregs_lo");
a1897 1
      return 1 * 2;
a1900 1
      notethat (" W [ iregs ] = dregs_hi");
a1904 1
      return 1 * 2;
a1907 1
      notethat ("dregs = [ iregs ++ mregs ]");
a1913 1
      return 1 * 2;
a1916 1
      notethat ("[ iregs ++ mregs ] = dregs");
a1922 1
      return 1 * 2;
d1925 3
a1927 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d1933 4
a1936 5
/* LDST
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 0 | 0 | 1 |.sz....|.W.|.aop...|.Z.|.ptr.......|.reg.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a1945 1
      notethat ("dregs = [ pregs ++ ]");
a1949 1
      return 1 * 2;
a1952 1
      notethat ("pregs = [ pregs ++ ]");
a1956 1
      return 1 * 2;
a1959 1
      notethat ("dregs = W [ pregs ++ ] (z)");
a1963 1
      return 1 * 2;
a1966 1
      notethat ("dregs = W [ pregs ++ ] (X)");
a1970 1
      return 1 * 2;
a1973 1
      notethat ("dregs = B [ pregs ++ ] (Z)");
a1977 1
      return 1 * 2;
a1980 1
      notethat ("dregs = B [ pregs ++ ] (X)");
a1984 1
      return 1 * 2;
a1987 1
      notethat ("dregs = [ pregs -- ]");
a1991 1
      return 1 * 2;
a1994 1
      notethat ("pregs = [ pregs -- ]");
a1998 1
      return 1 * 2;
a2001 1
      notethat ("dregs = W [ pregs -- ] (Z)");
a2005 1
      return 1 * 2;
a2008 1
      notethat ("dregs = W [ pregs -- ] (X)");
a2012 1
      return 1 * 2;
a2015 1
      notethat ("dregs = B [ pregs -- ] (Z)");
a2019 1
      return 1 * 2;
a2022 1
      notethat ("dregs = B [ pregs -- ] (X)");
a2026 1
      return 1 * 2;
a2029 1
      notethat ("dregs = [ pregs ]");
a2033 1
      return 1 * 2;
a2036 1
      notethat ("pregs = [ pregs ]");
a2040 1
      return 1 * 2;
a2043 1
      notethat ("dregs = W [ pregs ] (Z)");
a2047 1
      return 1 * 2;
a2050 1
      notethat ("dregs = W [ pregs ] (X)");
a2054 1
      return 1 * 2;
a2057 1
      notethat ("dregs = B [ pregs ] (Z)");
a2061 1
      return 1 * 2;
a2064 1
      notethat ("dregs = B [ pregs ] (X)");
a2068 1
      return 1 * 2;
a2071 1
      notethat ("[ pregs ++ ] = dregs");
a2075 1
      return 1 * 2;
a2078 1
      notethat ("[ pregs ++ ] = pregs");
a2082 1
      return 1 * 2;
a2085 1
      notethat ("W [ pregs ++ ] = dregs");
a2089 1
      return 1 * 2;
a2092 1
      notethat ("B [ pregs ++ ] = dregs");
a2096 1
      return 1 * 2;
a2099 1
      notethat ("[ pregs -- ] = dregs");
a2103 1
      return 1 * 2;
a2106 1
      notethat ("[ pregs -- ] = pregs");
a2110 1
      return 1 * 2;
a2113 1
      notethat ("W [ pregs -- ] = dregs");
a2117 1
      return 1 * 2;
a2120 1
      notethat ("B [ pregs -- ] = dregs");
a2124 1
      return 1 * 2;
a2127 1
      notethat ("[ pregs ] = dregs");
a2131 1
      return 1 * 2;
a2134 1
      notethat ("[ pregs ] = pregs");
a2138 1
      return 1 * 2;
a2141 1
      notethat ("W [ pregs ] = dregs");
a2145 1
      return 1 * 2;
a2148 1
      notethat ("B [ pregs ] = dregs");
a2152 1
      return 1 * 2;
d2155 3
a2157 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d2163 4
a2166 5
/* LDSTiiFP
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 0 | 1 | 1 | 1 | 0 |.W.|.offset............|.reg...........|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a2172 1
      notethat ("dpregs = [ FP - negimm5s4 ]");
a2176 1
      return 1 * 2;
a2179 1
      notethat ("[ FP - negimm5s4 ] = dpregs");
a2183 1
      return 1 * 2;
d2186 3
a2188 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d2194 4
a2197 5
/* LDSTii
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 0 | 1 |.W.|.op....|.offset........|.ptr.......|.reg.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a2205 1
      notethat ("dregs = [ pregs + uimm4s4 ]");
a2211 1
      return 1 * 2;
a2214 1
      notethat ("dregs = W [ pregs + uimm4s2 ] (Z)");
a2220 1
      return 1 * 2;
a2223 1
      notethat ("dregs = W [ pregs + uimm4s2 ] (X)");
a2229 1
      return 1 * 2;
a2232 1
      notethat ("pregs = [ pregs + uimm4s4 ]");
a2238 1
      return 1 * 2;
a2241 1
      notethat ("[ pregs + uimm4s4 ] = dregs");
a2247 1
      return 1 * 2;
a2250 1
      notethat ("W [ pregs + uimm4s2 ] = dregs");
a2258 1
      return 1 * 2;
a2261 1
      notethat ("[ pregs + uimm4s4 ] = pregs");
a2267 1
      return 1 * 2;
d2270 3
a2272 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d2278 5
a2282 6
/* LoopSetup
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |.rop...|.c.|.soffset.......|
|.reg...........| - | - |.eoffset...............................|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a2290 1
      notethat ("LSETUP ( pcrel4 , lppcrel10 ) counters");
a2297 1
      return 2 * 2;
a2300 1
      notethat ("LSETUP ( pcrel4 , lppcrel10 ) counters = pregs");
a2309 1
      return 2 * 2;
a2312 1
      notethat ("LSETUP ( pcrel4 , lppcrel10 ) counters = pregs >> 1");
a2322 1
      return 2 * 2;
d2325 3
a2327 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d2333 5
a2337 6
/* LDIMMhalf
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |.Z.|.H.|.S.|.grp...|.reg.......|
|.hword.........................................................|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a2346 1
      notethat ("dregs_lo = imm16");
a2349 1
      return 2 * 2;
a2352 1
      notethat ("dregs_hi = imm16");
a2355 1
      return 2 * 2;
a2358 1
      notethat ("dregs = imm16 (x)");
a2362 1
      return 2 * 2;
a2365 1
      notethat ("regs = imm16 (x)");
a2369 1
      return 2 * 2;
a2372 1
      notethat ("regs = luimm16 (Z)");
a2376 1
      return 2 * 2;
a2379 1
      notethat ("regs_lo = luimm16");
a2382 1
      return 2 * 2;
a2385 1
      notethat ("regs_hi = huimm16");
a2388 1
      return 2 * 2;
d2391 3
a2393 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d2399 5
a2403 6
/* CALLa
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 1 | 0 | 0 | 0 | 1 |.S.|.msw...........................|
|.lsw...........................................................|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
d2409 1
a2409 6
    {
      notethat ("CALL  pcrel24");
      OUTS (outf, "CALL  ");
      OUTS (outf, pcrel24 (((msw) << 16) | (lsw)));
      return 2 * 2;
    }
d2411 1
a2411 6
    {
      notethat ("JUMP.L  pcrel24");
      OUTS (outf, "JUMP.L  ");
      OUTS (outf, pcrel24 (((msw) << 16) | (lsw)));
      return 2 * 2;
    }
d2413 4
a2416 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d2422 5
a2426 6
/* LDSTidxI
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 1 | 0 | 0 | 1 |.W.|.Z.|.sz....|.ptr.......|.reg.......|
|.offset........................................................|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a2435 1
      notethat ("dregs = [ pregs + imm16s4 ]");
a2441 1
      return 2 * 2;
a2444 1
      notethat ("pregs = [ pregs + imm16s4 ]");
a2450 1
      return 2 * 2;
a2453 1
      notethat ("dregs = W [ pregs + imm16s2 ] (Z)");
a2459 1
      return 2 * 2;
a2462 1
      notethat ("dregs = W [ pregs + imm16s2 ] (X)");
a2468 1
      return 2 * 2;
a2471 1
      notethat ("dregs = B [ pregs + imm16 ] (Z)");
a2477 1
      return 2 * 2;
a2480 1
      notethat ("dregs = B [ pregs + imm16 ] (X)");
a2486 1
      return 2 * 2;
a2489 1
      notethat ("[ pregs + imm16s4 ] = dregs");
a2495 1
      return 2 * 2;
a2498 1
      notethat ("[ pregs + imm16s4 ] = pregs");
a2504 1
      return 2 * 2;
a2507 1
      notethat ("W [ pregs + imm16s2 ] = dregs");
a2513 1
      return 2 * 2;
a2516 1
      notethat ("B [ pregs + imm16 ] = dregs");
a2522 1
      return 2 * 2;
d2525 3
a2527 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d2533 5
a2537 6
/* linkage
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |.R.|
|.framesize.....................................................|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a2542 1
      notethat ("LINK uimm16s4");
a2544 1
      return 2 * 2;
d2547 1
a2547 5
    {
      notethat ("UNLINK");
      OUTS (outf, "UNLINK");
      return 2 * 2;
    }
d2549 3
a2551 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d2557 9
a2565 10
/* dsp32mac
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 0 | 0 |.M.| 0 | 0 |.mmod..........|.MM|.P.|.w1|.op1...|
|.h01|.h11|.w0|.op0...|.h00|.h10|.dst.......|.src0......|.src1......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
  int op1 = ((iw0 >> (DSP32Mac_op1_bits - 16)) & DSP32Mac_op1_mask);
  int w1 = ((iw0 >> (DSP32Mac_w1_bits - 16)) & DSP32Mac_w1_mask);
  int P = ((iw0 >> (DSP32Mac_p_bits - 16)) & DSP32Mac_p_mask);
  int MM = ((iw0 >> (DSP32Mac_MM_bits - 16)) & DSP32Mac_MM_mask);
d2567 1
a2567 1
  int w0 = ((iw1 >> DSP32Mac_w0_bits) & DSP32Mac_w0_mask);
d2570 6
a2575 6
  int dst = ((iw1 >> DSP32Mac_dst_bits) & DSP32Mac_dst_mask);
  int h10 = ((iw1 >> DSP32Mac_h10_bits) & DSP32Mac_h10_mask);
  int h00 = ((iw1 >> DSP32Mac_h00_bits) & DSP32Mac_h00_mask);
  int op0 = ((iw1 >> DSP32Mac_op0_bits) & DSP32Mac_op0_mask);
  int h11 = ((iw1 >> DSP32Mac_h11_bits) & DSP32Mac_h11_mask);
  int h01 = ((iw1 >> DSP32Mac_h01_bits) & DSP32Mac_h01_mask);
d2639 8
a2646 9
/* dsp32mult
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 0 | 0 |.M.| 0 | 1 |.mmod..........|.MM|.P.|.w1|.op1...|
|.h01|.h11|.w0|.op0...|.h00|.h10|.dst.......|.src0......|.src1......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
  int w1 = ((iw0 >> (DSP32Mac_w1_bits - 16)) & DSP32Mac_w1_mask);
  int P = ((iw0 >> (DSP32Mac_p_bits - 16)) & DSP32Mac_p_mask);
  int MM = ((iw0 >> (DSP32Mac_MM_bits - 16)) & DSP32Mac_MM_mask);
d2648 1
a2648 1
  int w0 = ((iw1 >> DSP32Mac_w0_bits) & DSP32Mac_w0_mask);
d2651 5
a2655 5
  int dst = ((iw1 >> DSP32Mac_dst_bits) & DSP32Mac_dst_mask);
  int h10 = ((iw1 >> DSP32Mac_h10_bits) & DSP32Mac_h10_mask);
  int h00 = ((iw1 >> DSP32Mac_h00_bits) & DSP32Mac_h00_mask);
  int h11 = ((iw1 >> DSP32Mac_h11_bits) & DSP32Mac_h11_mask);
  int h01 = ((iw1 >> DSP32Mac_h01_bits) & DSP32Mac_h01_mask);
d2659 1
d2662 1
a2662 1
  
d2692 5
a2696 6
/* dsp32alu
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 0 | 0 |.M.| 1 | 0 | - | - | - |.HL|.aopcde............|
|.aop...|.s.|.x.|.dst0......|.dst1......|.src0......|.src1......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a2708 1
      notethat ("A0.L = dregs_lo");
a2710 1
      return 2 * 2;
a2713 1
      notethat ("A1.H = dregs_hi");
a2715 1
      return 2 * 2;
a2718 1
      notethat ("A1.L = dregs_lo");
a2720 1
      return 2 * 2;
a2723 1
      notethat ("A0.H = dregs_hi");
a2725 1
      return 2 * 2;
a2728 1
      notethat ("dregs_hi = dregs - dregs (RND20)");
a2734 1
      return 2 * 2;
a2737 1
      notethat ("dregs_hi = dregs + dregs (RND20)");
a2743 1
      return 2 * 2;
a2746 1
      notethat ("dregs_lo = dregs - dregs (RND12)");
a2752 1
      return 2 * 2;
a2755 1
      notethat ("dregs_lo = dregs + dregs (RND12)");
a2761 1
      return 2 * 2;
a2764 1
      notethat ("dregs_lo = dregs - dregs (RND20)");
a2770 1
      return 2 * 2;
a2773 1
      notethat ("dregs_hi = dregs + dregs (RND12)");
a2779 1
      return 2 * 2;
a2782 1
      notethat ("dregs_lo = dregs + dregs (RND20)");
a2788 1
      return 2 * 2;
a2791 1
      notethat ("dregs_hi = dregs - dregs (RND12)");
a2797 1
      return 2 * 2;
a2800 1
      notethat ("dregs_hi = dregs_lo + dregs_lo amod1");
a2807 1
      return 2 * 2;
a2810 1
      notethat ("dregs_hi = dregs_lo + dregs_hi amod1");
a2817 1
      return 2 * 2;
a2820 1
      notethat ("dregs_hi = dregs_hi + dregs_lo amod1");
a2827 1
      return 2 * 2;
a2830 1
      notethat ("dregs_hi = dregs_hi + dregs_hi amod1");
a2837 1
      return 2 * 2;
a2840 1
      notethat ("dregs_lo = dregs_lo - dregs_lo amod1");
a2847 1
      return 2 * 2;
a2850 1
      notethat ("dregs_lo = dregs_lo - dregs_hi amod1");
a2857 1
      return 2 * 2;
a2860 1
      notethat ("dregs_lo = dregs_hi + dregs_hi amod1");
a2867 1
      return 2 * 2;
a2870 1
      notethat ("dregs_hi = dregs_lo - dregs_lo amod1");
a2877 1
      return 2 * 2;
a2880 1
      notethat ("dregs_hi = dregs_lo - dregs_hi amod1");
a2887 1
      return 2 * 2;
a2890 1
      notethat ("dregs_hi = dregs_hi - dregs_lo amod1");
a2897 1
      return 2 * 2;
a2900 1
      notethat ("dregs_hi = dregs_hi - dregs_hi amod1");
a2907 1
      return 2 * 2;
a2910 1
      notethat ("dregs_lo = dregs_hi + dregs_lo amod1");
a2917 1
      return 2 * 2;
a2920 1
      notethat ("dregs_lo = dregs_lo + dregs_hi amod1");
a2927 1
      return 2 * 2;
a2930 1
      notethat ("dregs_lo = dregs_hi - dregs_lo amod1");
a2937 1
      return 2 * 2;
a2940 1
      notethat ("dregs_lo = dregs_hi - dregs_hi amod1");
a2947 1
      return 2 * 2;
a2950 1
      notethat ("dregs_lo = dregs_lo + dregs_lo amod1");
a2957 1
      return 2 * 2;
a2960 1
      notethat ("A0 = dregs");
a2962 1
      return 2 * 2;
d2965 2
a2966 5
    {
      notethat ("A0 -= A1");
      OUTS (outf, "A0-=A1");
      return 2 * 2;
    }
d2968 2
a2969 5
    {
      notethat ("A0 -= A1 (W32)");
      OUTS (outf, "A0-=A1(W32)");
      return 2 * 2;
    }
a2971 1
      notethat ("dregs = BYTEOP2M ( dregs_pair , dregs_pair ) (TH , R)");
a2985 1
      return 2 * 2;
a2988 1
      notethat ("dregs = BYTEOP2M ( dregs_pair , dregs_pair ) (TL , R)");
a3002 1
      return 2 * 2;
a3005 1
      notethat ("dregs = BYTEOP2M ( dregs_pair , dregs_pair ) (RNDH , R)");
a3019 1
      return 2 * 2;
a3022 1
      notethat ("dregs = BYTEOP2M ( dregs_pair , dregs_pair ) (RNDL , R)");
a3036 1
      return 2 * 2;
a3039 1
      notethat ("dregs = BYTEOP2P ( dregs_pair , dregs_pair ) (TH , R)");
a3053 1
      return 2 * 2;
a3056 1
      notethat ("dregs = BYTEOP2P ( dregs_pair , dregs_pair ) (TL , R)");
a3070 1
      return 2 * 2;
a3073 1
      notethat ("dregs = BYTEOP2P ( dregs_pair , dregs_pair ) (RNDH , R)");
a3087 1
      return 2 * 2;
a3090 1
      notethat ("dregs = BYTEOP2P ( dregs_pair , dregs_pair ) (RNDL , aligndir)");
a3104 1
      return 2 * 2;
d3107 2
a3108 5
    {
      notethat ("A0 = 0");
      OUTS (outf, "A0=0");
      return 2 * 2;
    }
d3110 2
a3111 5
    {
      notethat ("A0 = A0 (S)");
      OUTS (outf, "A0=A0(S)");
      return 2 * 2;
    }
d3113 2
a3114 5
    {
      notethat ("A1 = 0");
      OUTS (outf, "A1=0");
      return 2 * 2;
    }
d3116 2
a3117 5
    {
      notethat ("A1 = A1 (S)");
      OUTS (outf, "A1=A1(S)");
      return 2 * 2;
    }
d3119 2
a3120 5
    {
      notethat ("A1 = A0 = 0");
      OUTS (outf, "A1=A0=0");
      return 2 * 2;
    }
d3122 2
a3123 5
    {
      notethat ("A1 = A1 (S) , A0 = A0 (S)");
      OUTS (outf, "A1=A1(S),A0=A0(S)");
      return 2 * 2;
    }
d3125 2
a3126 5
    {
      notethat ("A0 = A1");
      OUTS (outf, "A0=A1");
      return 2 * 2;
    }
d3128 2
a3129 5
    {
      notethat ("A1 = A0");
      OUTS (outf, "A1=A0");
      return 2 * 2;
    }
a3131 1
      notethat ("A0.x = dregs_lo");
a3133 1
      return 2 * 2;
a3136 1
      notethat ("dregs_lo = ( A0 += A1 )");
a3138 1
      return 2 * 2;
d3141 2
a3142 5
    {
      notethat ("A1 = ABS A1, A0 = ABS A0");
      OUTS (outf, "A1= ABS A0,A0= ABS A0");
      return 2 * 2;
    }
a3144 1
      notethat ("dregs = BYTEOP3P ( dregs_pair , dregs_pair ) (HI , R)");
a3158 1
      return 2 * 2;
a3161 1
      notethat ("A1.x = dregs_lo");
a3163 1
      return 2 * 2;
d3166 2
a3167 5
    {
      notethat ("A1 = ABS A1");
      OUTS (outf, "A1= ABS A1");
      return 2 * 2;
    }
d3169 2
a3170 5
    {
      notethat ("A1 = ABS A0");
      OUTS (outf, "A1= ABS A0");
      return 2 * 2;
    }
a3172 1
      notethat ("A1 = dregs");
a3174 1
      return 2 * 2;
a3177 1
      notethat ("dregs_lo = dregs (RND)");
a3181 1
      return 2 * 2;
d3184 2
a3185 5
    {
      notethat ("A0 = ABS A1");
      OUTS (outf, "A0= ABS A1");
      return 2 * 2;
    }
d3187 2
a3188 5
    {
      notethat ("A0 = ABS A0");
      OUTS (outf, "A0= ABS A0");
      return 2 * 2;
    }
a3190 1
      notethat ("dregs = - dregs (V)");
a3194 1
      return 2 * 2;
a3197 1
      notethat ("dregs = - dregs (S)");
a3201 1
      return 2 * 2;
a3204 1
      notethat ("dregs = - dregs (NS)");
a3208 1
      return 2 * 2;
a3211 1
      notethat ("dregs_hi = ( A0 += A1 )");
a3213 1
      return 2 * 2;
d3216 2
a3217 5
    {
      notethat ("A0 += A1");
      OUTS (outf, "A0+=A1");
      return 2 * 2;
    }
d3219 2
a3220 5
    {
      notethat ("A0 += A1 (W32)");
      OUTS (outf, "A0+=A1(W32)");
      return 2 * 2;
    }
d3222 2
a3223 5
    {
      notethat ("A1 = - A1 , A0 = - A0");
      OUTS (outf, "A1=-A1,A0=-A0");
      return 2 * 2;
    }
a3225 1
      notethat ("dregs_hi = dregs (RND)");
a3229 1
      return 2 * 2;
a3232 1
      notethat ("dregs = BYTEOP3P ( dregs_pair , dregs_pair ) (LO , R)");
a3246 1
      return 2 * 2;
d3249 2
a3250 5
    {
      notethat ("A0 = - A0");
      OUTS (outf, "A0=-A0");
      return 2 * 2;
    }
d3252 2
a3253 5
    {
      notethat ("A0 = - A1");
      OUTS (outf, "A0=-A1");
      return 2 * 2;
    }
d3255 2
a3256 5
    {
      notethat ("A1 = - A0");
      OUTS (outf, "A1=-A0");
      return 2 * 2;
    }
d3258 2
a3259 5
    {
      notethat ("A1 = - A1");
      OUTS (outf, "A1=-A1");
      return 2 * 2;
    }
a3261 1
      notethat ("dregs_hi=dregs_lo=SIGN(dregs_hi)*dregs_hi + SIGN(dregs_lo)*dregs_lo)");
a3273 1
      return 2 * 2;
a3276 1
      notethat ("dregs = dregs -|+ dregs amod0");
a3283 1
      return 2 * 2;
a3286 1
      notethat ("dregs = A1.L + A1.H , dregs = A0.L + A0.H");
a3290 1
      return 2 * 2;
a3293 1
      notethat ("dregs = dregs + dregs , dregs = dregs - dregs amod1");
a3306 1
      return 2 * 2;
a3309 1
      notethat ("dregs = dregs +|+ dregs , dregs = dregs -|- dregs (amod0, amod2)");
a3321 1
      return 2 * 2;
a3324 1
      notethat ("dregs = ( A0 += A1 )");
a3326 1
      return 2 * 2;
a3329 1
      notethat ("dregs_lo = A0.x");
a3331 1
      return 2 * 2;
a3334 1
      notethat ("dregs_lo = A1.x");
a3336 1
      return 2 * 2;
a3339 1
      notethat ("dregs = dregs +|- dregs amod0");
a3346 1
      return 2 * 2;
a3349 1
      notethat ("dregs = dregs -|- dregs amod0");
a3356 1
      return 2 * 2;
a3359 1
      notethat ("dregs = dregs - dregs amod1");
a3366 1
      return 2 * 2;
a3369 1
      notethat ("dregs = A1 + A0, dregs = A1 - A0 amod1");
a3374 1
      return 2 * 2;
a3377 1
      notethat ("dregs = A0 + A1, dregs = A0 - A1 amod1");
a3382 1
      return 2 * 2;
a3385 1
      notethat ("SAA ( dregs_pair , dregs_pair ) aligndir");
a3395 1
      return 2 * 2;
d3398 2
a3399 5
    {
      notethat ("DISALGNEXCPT");
      OUTS (outf, "DISALGNEXCPT");
      return 2 * 2;
    }
a3401 1
      notethat ("dregs = BYTEOP1P ( dregs_pair , dregs_pair ) aligndir");
a3412 1
      return 2 * 2;
a3415 1
      notethat ("dregs = BYTEOP1P ( dregs_pair , dregs_pair ) (T, R)");
a3429 1
      return 2 * 2;
a3432 1
      notethat ("( dregs , dregs ) = BYTEOP16P ( dregs_pair , dregs_pair ) aligndir");
a3446 1
      return 2 * 2;
a3449 1
      notethat ("( dregs , dregs ) = BYTEOP16M ( dregs_pair , dregs_pair ) aligndir");
a3463 1
      return 2 * 2;
a3466 1
      notethat ("dregs = ABS dregs");
a3469 1
      return 2 * 2;
a3472 1
      notethat ("dregs = MIN ( dregs , dregs )");
a3478 1
      return 2 * 2;
a3481 1
      notethat ("dregs = MAX ( dregs , dregs )");
a3487 1
      return 2 * 2;
a3490 1
      notethat ("dregs = ABS dregs (V)");
a3494 1
      return 2 * 2;
a3497 1
      notethat ("dregs = MIN ( dregs , dregs ) (V)");
a3503 1
      return 2 * 2;
a3506 1
      notethat ("dregs = MAX ( dregs , dregs ) (V)");
a3512 1
      return 2 * 2;
a3515 1
      notethat ("dregs = dregs +|- dregs, dregs = dregs -|+ dregs (amod0, amod2)");
a3527 1
      return 2 * 2;
a3530 1
      notethat ("dregs = dregs + dregs amod1");
a3537 1
      return 2 * 2;
a3540 1
      notethat ("dregs = dregs +|+ dregs amod0");
a3547 1
      return 2 * 2;
a3550 1
      notethat ("dregs = BYTEPACK ( dregs , dregs )");
a3556 1
      return 2 * 2;
a3559 1
      notethat ("( dregs , dregs ) = BYTEUNPACK dregs_pair aligndir");
a3569 1
      return 2 * 2;
a3572 1
      notethat ("( dregs , dregs ) = SEARCH dregs (searchmod)");
a3581 1
      return 2 * 2;
d3584 3
a3586 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d3592 5
a3596 6
/* dsp32shift
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 0 | 0 |.M.| 1 | 1 | 0 | 0 | - | - |.sopcde............|
|.sop...|.HLs...|.dst0......| - | - | - |.src0......|.src1......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
a3604 1

a3606 1
      notethat ("dregs_lo = ASHIFT dregs_lo BY dregs_lo");
a3611 1
      return 2 * 2;
a3614 1
      notethat ("dregs_lo = ASHIFT dregs_hi BY dregs_lo");
a3619 1
      return 2 * 2;
a3622 1
      notethat ("dregs_hi = ASHIFT dregs_lo BY dregs_lo");
a3627 1
      return 2 * 2;
a3630 1
      notethat ("dregs_hi = ASHIFT dregs_hi BY dregs_lo");
a3635 1
      return 2 * 2;
a3638 1
      notethat ("dregs_lo = ASHIFT dregs_lo BY dregs_lo (S)");
a3644 1
      return 2 * 2;
a3647 1
      notethat ("dregs_lo = ASHIFT dregs_hi BY dregs_lo (S)");
a3653 1
      return 2 * 2;
a3656 1
      notethat ("dregs_hi = ASHIFT dregs_lo BY dregs_lo (S)");
a3662 1
      return 2 * 2;
a3665 1
      notethat ("dregs_hi = ASHIFT dregs_hi BY dregs_lo (S)");
a3671 1
      return 2 * 2;
a3674 1
      notethat ("dregs_hilo = LSHIFT dregs_hilo BY dregs_lo");
a3679 1
      return 2 * 2;
a3682 1
      notethat ("An = ASHIFT An BY dregs_lo");
a3687 1
      return 2 * 2;
a3690 1
      notethat ("An = LSHIFT An BY dregs_lo");
a3695 1
      return 2 * 2;
a3698 1
      notethat ("An = ROT An BY dregs_lo");
a3703 1
      return 2 * 2;
a3706 1
      notethat ("dregs = ROT dregs BY dregs_lo");
a3711 1
      return 2 * 2;
a3714 1
      notethat ("dregs = ASHIFT dregs BY dregs_lo (V, S)");
a3720 1
      return 2 * 2;
a3723 1
      notethat ("dregs = ASHIFT dregs BY dregs_lo (V)");
a3729 1
      return 2 * 2;
a3732 1
      notethat ("dregs = ASHIFT dregs BY dregs_lo");
a3737 1
      return 2 * 2;
a3740 1
      notethat ("dregs = ASHIFT dregs BY dregs_lo (S)");
a3746 1
      return 2 * 2;
a3749 1
      notethat ("dregs = SHIFT dregs BY dregs_lo");
a3754 1
      return 2 * 2;
a3757 1
      notethat ("dregs = ROT dregs BY dregs_lo");
a3762 1
      return 2 * 2;
a3765 1
      notethat ("dregs = SHIFT dregs BY dregs_lo (V)");
a3771 1
      return 2 * 2;
a3774 1
      notethat ("dregs = PACK ( dregs_lo , dregs_lo )");
a3781 1
      return 2 * 2;
a3784 1
      notethat ("dregs = PACK ( dregs_lo , dregs_hi )");
a3790 1
      return 2 * 2;
a3793 1
      notethat ("dregs = PACK ( dregs_hi , dregs_lo )");
a3799 1
      return 2 * 2;
a3802 1
      notethat ("dregs = PACK ( dregs_hi , dregs_hi )");
a3808 1
      return 2 * 2;
a3811 1
      notethat ("dregs_lo = SIGNBITS dregs");
a3814 1
      return 2 * 2;
a3817 1
      notethat ("dregs_lo = SIGNBITS dregs_lo");
a3820 1
      return 2 * 2;
a3823 1
      notethat ("dregs_lo = SIGNBITS dregs_hi");
a3826 1
      return 2 * 2;
a3829 1
      notethat ("dregs_lo = SIGNBITS A0");
a3831 1
      return 2 * 2;
a3834 1
      notethat ("dregs_lo = SIGNBITS A1");
a3836 1
      return 2 * 2;
a3839 1
      notethat ("dregs_lo = ONES dregs");
a3842 1
      return 2 * 2;
a3845 1
      notethat ("dregs_lo = EXPADJ (dregs , dregs_lo)");
a3851 1
      return 2 * 2;
a3854 1
      notethat ("dregs_lo = EXPADJ (dregs , dregs_lo) (V)");
a3860 1
      return 2 * 2;
a3863 1
      notethat ("dregs_lo = EXPADJ (dregs_lo , dregs_lo)");
a3869 1
      return 2 * 2;
a3872 1
      notethat ("dregs_lo = EXPADJ (dregs_hi , dregs_lo)");
a3878 1
      return 2 * 2;
a3881 1
      notethat ("BITMUX (dregs , dregs , A0) (ASR)");
a3886 1
      return 2 * 2;
a3889 1
      notethat ("BITMUX (dregs , dregs , A0) (ASL)");
a3894 1
      return 2 * 2;
a3897 1
      notethat ("dregs_lo = VIT_MAX (dregs) (ASL)");
a3901 1
      return 2 * 2;
a3904 1
      notethat ("dregs_lo = VIT_MAX (dregs) (ASR)");
a3908 1
      return 2 * 2;
a3911 1
      notethat ("dregs = VIT_MAX ( dregs , dregs ) (ASL)");
a3917 1
      return 2 * 2;
a3920 1
      notethat ("dregs = VIT_MAX ( dregs , dregs ) (ASR)");
a3926 1
      return 2 * 2;
a3929 1
      notethat ("dregs = EXTRACT ( dregs , dregs_lo ) (Z)");
a3935 1
      return 2 * 2;
a3938 1
      notethat ("dregs = EXTRACT ( dregs , dregs_lo ) (X)");
a3944 1
      return 2 * 2;
a3947 1
      notethat ("dregs = DEPOSIT ( dregs , dregs )");
a3953 1
      return 2 * 2;
a3956 1
      notethat ("dregs = DEPOSIT ( dregs , dregs ) (X)");
a3962 1
      return 2 * 2;
a3965 1
      notethat ("dregs_lo = CC = BXORSHIFT ( A0 , dregs )");
a3969 1
      return 2 * 2;
a3972 1
      notethat ("dregs_lo = CC = BXOR (A0 , dregs)");
a3976 1
      return 2 * 2;
d3979 2
a3980 5
    {
      notethat ("A0 = BXORSHIFT ( A0 , A1 , CC )");
      OUTS (outf, "A0=BXORSHIFT(A0,A1 ,CC)");
      return 2 * 2;
    }
a3982 1
      notethat ("dregs_lo = CC = BXOR (A0 , A1 , CC)");
a3984 1
      return 2 * 2;
a3987 1
      notethat ("dregs = ALIGN8 ( dregs , dregs )");
a3993 1
      return 2 * 2;
a3996 1
      notethat ("dregs = ALIGN16 ( dregs , dregs )");
a4002 1
      return 2 * 2;
a4005 1
      notethat ("dregs = ALIGN24 ( dregs , dregs )");
a4011 1
      return 2 * 2;
d4014 3
a4016 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d4022 9
a4030 10
/* dsp32shiftimm
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 0 | 0 |.M.| 1 | 1 | 0 | 1 | - | - |.sopcde............|
|.sop...|.HLs...|.dst0......|.immag.................|.src1......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
  int src1 = ((iw1 >> DSP32ShiftImm_src1_bits) & DSP32ShiftImm_src1_mask);
  int sop = ((iw1 >> DSP32ShiftImm_sop_bits) & DSP32ShiftImm_sop_mask);
  int bit8 = ((iw1 >> 8) & 0x1);
  int immag = ((iw1 >> DSP32ShiftImm_immag_bits) & DSP32ShiftImm_immag_mask);
d4032 3
a4034 3
  int dst0 = ((iw1 >> DSP32ShiftImm_dst0_bits) & DSP32ShiftImm_dst0_mask);
  int sopcde = ((iw0 >> (DSP32ShiftImm_sopcde_bits - 16)) & DSP32ShiftImm_sopcde_mask);
  int HLs = ((iw1 >> DSP32ShiftImm_HLs_bits) & DSP32ShiftImm_HLs_mask);
a4038 1
      notethat ("dregs_lo = dregs_lo >>> uimm4");
a4043 1
      return 2 * 2;
a4046 1
      notethat ("dregs_lo = dregs_hi >>> uimm4");
a4051 1
      return 2 * 2;
a4054 1
      notethat ("dregs_hi = dregs_lo >>> uimm4");
a4059 1
      return 2 * 2;
a4062 1
      notethat ("dregs_hi = dregs_hi >>> uimm4");
a4067 1
      return 2 * 2;
a4070 1
      notethat ("dregs_lo = dregs_lo << uimm4 (S)");
a4076 1
      return 2 * 2;
a4079 1
      notethat ("dregs_lo = dregs_hi << uimm4 (S)");
a4085 1
      return 2 * 2;
a4088 1
      notethat ("dregs_hi = dregs_lo << uimm4 (S)");
a4094 1
      return 2 * 2;
a4097 1
      notethat ("dregs_hi = dregs_hi << uimm4 (S)");
a4103 1
      return 2 * 2;
a4106 1
      notethat ("dregs_lo = dregs_lo << uimm4");
a4111 1
      return 2 * 2;
a4114 1
      notethat ("dregs_lo = dregs_lo >> uimm4");
a4119 1
      return 2 * 2;
a4122 1
      notethat ("dregs_lo = dregs_hi >> uimm4");
a4127 1
      return 2 * 2;
a4130 1
      notethat ("dregs_hi = dregs_lo >> uimm4");
a4135 1
      return 2 * 2;
a4138 1
      notethat ("dregs_hi = dregs_lo << uimm4");
a4143 1
      return 2 * 2;
a4146 1
      notethat ("dregs_hi = dregs_hi >> uimm4");
a4151 1
      return 2 * 2;
a4154 1
      notethat ("dregs_hi = dregs_hi << uimm4");
a4159 1
      return 2 * 2;
a4162 1
      notethat ("A1 = ROT A1 BY imm6");
a4164 1
      return 2 * 2;
a4167 1
      notethat ("A0 = A0 << uimm5");
a4169 1
      return 2 * 2;
a4172 1
      notethat ("A0 = A0 >>> uimm5");
a4174 1
      return 2 * 2;
a4177 1
      notethat ("A1 = A1 << uimm5");
a4179 1
      return 2 * 2;
a4182 1
      notethat ("A1 = A1 >>> uimm5");
a4184 1
      return 2 * 2;
a4187 1
      notethat ("A0 = A0 >> uimm5");
a4189 1
      return 2 * 2;
a4192 1
      notethat ("A1 = A1 >> uimm5");
a4194 1
      return 2 * 2;
a4197 1
      notethat ("A0 = ROT A0 BY imm6");
a4199 1
      return 2 * 2;
a4202 1
      notethat ("dregs = dregs << uimm5 (V, S)");
a4208 1
      return 2 * 2;
a4211 1
      notethat ("dregs = dregs >>> uimm5 (V)");
a4217 1
      return 2 * 2;
a4220 1
      notethat ("dregs = dregs >> uimm5 (V)");
a4226 1
      return 2 * 2;
a4229 1
      notethat ("dregs = dregs << imm5 (V)");
a4235 1
      return 2 * 2;
a4238 1
      notethat ("dregs = dregs >>> uimm5 (V)");
a4244 1
      return 2 * 2;
a4247 1
      notethat ("dregs = dregs << uimm5 (S)");
a4253 1
      return 2 * 2;
a4256 1
      notethat ("dregs = dregs >> uimm5");
a4261 1
      return 2 * 2;
a4264 1
      notethat ("dregs = dregs << uimm5");
a4269 1
      return 2 * 2;
a4272 1
      notethat ("dregs = ROT dregs BY imm6");
a4277 1
      return 2 * 2;
a4280 1
      notethat ("dregs = dregs >>> uimm5");
a4285 1
      return 2 * 2;
d4288 3
a4290 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d4296 4
a4299 5
/* pseudoDEBUG
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |.fn....|.grp.......|.reg.......|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
d4305 2
a4306 5
    {
      notethat ("DBG A0");
      OUTS (outf, "DBG A0");
      return 1 * 2;
    }
d4308 2
a4309 5
    {
      notethat ("DBG A1");
      OUTS (outf, "DBG A1");
      return 1 * 2;
    }
d4311 2
a4312 5
    {
      notethat ("ABORT");
      OUTS (outf, "ABORT");
      return 1 * 2;
    }
d4314 2
a4315 5
    {
      notethat ("HLT");
      OUTS (outf, "HLT");
      return 1 * 2;
    }
d4317 2
a4318 5
    {
      notethat ("DBGHALT");
      OUTS (outf, "DBGHALT");
      return 1 * 2;
    }
a4320 1
      notethat ("DBGCMPLX ( dregs )");
a4323 1
      return 1 * 2;
d4326 2
a4327 5
    {
      notethat ("DBG");
      OUTS (outf, "DBG");
      return 1 * 2;
    }
a4329 1
      notethat ("OUTC dregs");
a4331 1
      return 1 * 2;
a4334 1
      notethat ("DBG allregs");
a4336 1
      return 1 * 2;
a4339 1
      notethat ("PRNT allregs");
a4341 1
      return 1 * 2;
d4344 3
a4346 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
d4352 5
a4356 6
/* pseudodbg_assert
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
| 1 | 1 | 1 | 1 | 0 | - | - | - | - | - |.dbgop.....|.regtest...|
|.expected......................................................|
+---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
*/
d4358 2
a4359 2
  int dbgop = ((iw0 >> (PseudoDbg_Assert_dbgop_bits - 16)) & PseudoDbg_Assert_dbgop_mask);
  int regtest = ((iw0 >> (PseudoDbg_Assert_regtest_bits - 16)) & PseudoDbg_Assert_regtest_mask);
a4362 1
      notethat ("DBGA ( dregs_lo , uimm16 )");
a4367 1
      return 2 * 2;
a4370 1
      notethat ("DBGA ( dregs_hi , uimm16 )");
a4375 1
      return 2 * 2;
a4378 1
      notethat ("DBGAL ( dregs , uimm16 )");
a4383 1
      return 2 * 2;
a4386 1
      notethat ("DBGAH ( dregs , uimm16 )");
a4391 1
      return 2 * 2;
d4394 2
a4395 3
    goto illegal_instruction;
illegal_instruction:
  return 0;
a4400 1

d4405 2
d4419 1
a4419 6
    {
      int rv = decode_ProgCtrl_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4421 1
a4421 6
    {
      int rv = decode_CaCTRL_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4423 1
a4423 6
    {
      int rv = decode_PushPopReg_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4425 1
a4425 6
    {
      int rv = decode_PushPopMultiple_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4427 1
a4427 6
    {
      int rv = decode_ccMV_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4429 1
a4429 6
    {
      int rv = decode_CCflag_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4431 1
a4431 6
    {
      int rv = decode_CC2dreg_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4433 1
a4433 6
    {
      int rv = decode_CC2stat_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4435 1
a4435 6
    {
      int rv = decode_BRCC_0 (iw0, pc, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4437 1
a4437 6
    {
      int rv = decode_UJUMP_0 (iw0, pc, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4439 1
a4439 6
    {
      int rv = decode_REGMV_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4441 1
a4441 6
    {
      int rv = decode_ALU2op_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4443 1
a4443 6
    {
      int rv = decode_PTR2op_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4445 1
a4445 6
    {
      int rv = decode_LOGI2op_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4447 1
a4447 6
    {
      int rv = decode_COMP3op_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4449 1
a4449 6
    {
      int rv = decode_COMPI2opD_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4451 1
a4451 6
    {
      int rv = decode_COMPI2opP_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4453 1
a4453 6
    {
      int rv = decode_LDSTpmod_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4455 1
a4455 6
    {
      int rv = decode_dagMODim_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4457 1
a4457 6
    {
      int rv = decode_dagMODik_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4459 1
a4459 6
    {
      int rv = decode_dspLDST_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4461 1
a4461 6
    {
      int rv = decode_LDST_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4463 1
a4463 6
    {
      int rv = decode_LDSTiiFP_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4465 1
a4465 6
    {
      int rv = decode_LDSTii_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4467 1
a4467 6
    {
      int rv = decode_LoopSetup_0 (iw0, iw1, pc, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4469 1
a4469 6
    {
      int rv = decode_LDIMMhalf_0 (iw0, iw1, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4471 1
a4471 6
    {
      int rv = decode_CALLa_0 (iw0, iw1, pc, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4473 1
a4473 6
    {
      int rv = decode_LDSTidxI_0 (iw0, iw1, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4475 1
a4475 6
    {
      int rv = decode_linkage_0 (iw0, iw1, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4477 1
a4477 6
    {
      int rv = decode_dsp32mac_0 (iw0, iw1, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4479 1
a4479 6
    {
      int rv = decode_dsp32mult_0 (iw0, iw1, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4481 1
a4481 6
    {
      int rv = decode_dsp32alu_0 (iw0, iw1, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4483 1
a4483 6
    {
      int rv = decode_dsp32shift_0 (iw0, iw1, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4485 1
a4485 6
    {
      int rv = decode_dsp32shiftimm_0 (iw0, iw1, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4487 1
a4487 5
    {
      int rv = decode_pseudoDEBUG_0 (iw0, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
a4488 1
    }
d4490 1
a4490 6
    {

      int rv = decode_pseudoOChar_0 (iw0, iw1, pc, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
a4491 1
    }
d4493 1
a4493 6
    {
      int rv = decode_pseudodbg_assert_0 (iw0, iw1, outf);
      if (rv)
	return rv;
      goto illegal_instruction;
    }
d4495 1
a4495 2
illegal_instruction:
  return 0;
d4515 1
a4515 1
      && ((iw0 & 0xe800) != 0xe800 /* not Linkage */ ))
@


1.1
log
@	* Makefile.am: Bfin support.
	* Makefile.in: Regenerated.
	* aclocal.m4: Regenerated.
	* bfin-dis.c: New file.
	* configure.in: Bfin support.
	* configure: Regenerated.
	* disassemble.c (ARCH_bfin): Define.
	(disassembler): Add case for bfd_arch_bfin.
@
text
@d5768 3
a5770 2
  short iw0 = 0;
  int status = 0;
d5772 3
a5774 1
  status = (*outf->read_memory_func) (pc & ~0x01, (bfd_byte *) & iw0, 2, outf);
d5777 1
d5779 1
@

