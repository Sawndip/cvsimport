head	1.13;
access;
symbols
	sid-snapshot-20180601:1.13
	sid-snapshot-20180501:1.13
	sid-snapshot-20180401:1.13
	sid-snapshot-20180301:1.13
	sid-snapshot-20180201:1.13
	sid-snapshot-20180101:1.13
	sid-snapshot-20171201:1.13
	sid-snapshot-20171101:1.13
	sid-snapshot-20171001:1.13
	sid-snapshot-20170901:1.13
	sid-snapshot-20170801:1.13
	sid-snapshot-20170701:1.13
	sid-snapshot-20170601:1.13
	sid-snapshot-20170501:1.13
	sid-snapshot-20170401:1.13
	sid-snapshot-20170301:1.13
	sid-snapshot-20170201:1.13
	sid-snapshot-20170101:1.13
	sid-snapshot-20161201:1.13
	sid-snapshot-20161101:1.13
	sid-snapshot-20160901:1.13
	sid-snapshot-20160801:1.13
	sid-snapshot-20160701:1.13
	sid-snapshot-20160601:1.13
	sid-snapshot-20160501:1.13
	sid-snapshot-20160401:1.13
	sid-snapshot-20160301:1.13
	sid-snapshot-20160201:1.13
	sid-snapshot-20160101:1.13
	sid-snapshot-20151201:1.13
	sid-snapshot-20151101:1.13
	sid-snapshot-20151001:1.13
	sid-snapshot-20150901:1.13
	sid-snapshot-20150801:1.13
	sid-snapshot-20150701:1.13
	sid-snapshot-20150601:1.13
	sid-snapshot-20150501:1.13
	sid-snapshot-20150401:1.13
	sid-snapshot-20150301:1.13
	sid-snapshot-20150201:1.13
	sid-snapshot-20150101:1.13
	sid-snapshot-20141201:1.13
	sid-snapshot-20141101:1.13
	sid-snapshot-20141001:1.13
	sid-snapshot-20140901:1.13
	sid-snapshot-20140801:1.13
	sid-snapshot-20140701:1.13
	sid-snapshot-20140601:1.13
	sid-snapshot-20140501:1.13
	sid-snapshot-20140401:1.13
	sid-snapshot-20140301:1.13
	sid-snapshot-20140201:1.13
	sid-snapshot-20140101:1.13
	sid-snapshot-20131201:1.13
	sid-snapshot-20131101:1.13
	sid-snapshot-20131001:1.13
	binutils-2_24-branch:1.13.0.8
	binutils-2_24-branchpoint:1.13
	binutils-2_21_1:1.12
	sid-snapshot-20130901:1.13
	gdb_7_6_1-2013-08-30-release:1.13
	sid-snapshot-20130801:1.13
	sid-snapshot-20130701:1.13
	sid-snapshot-20130601:1.13
	sid-snapshot-20130501:1.13
	gdb_7_6-2013-04-26-release:1.13
	sid-snapshot-20130401:1.13
	binutils-2_23_2:1.13
	gdb_7_6-branch:1.13.0.6
	gdb_7_6-2013-03-12-branchpoint:1.13
	sid-snapshot-20130301:1.13
	sid-snapshot-20130201:1.13
	sid-snapshot-20130101:1.13
	sid-snapshot-20121201:1.13
	gdb_7_5_1-2012-11-29-release:1.13
	binutils-2_23_1:1.13
	sid-snapshot-20121101:1.13
	binutils-2_23:1.13
	sid-snapshot-20121001:1.13
	sid-snapshot-20120901:1.13
	gdb_7_5-2012-08-17-release:1.13
	sid-snapshot-20120801:1.13
	binutils-2_23-branch:1.13.0.4
	binutils-2_23-branchpoint:1.13
	gdb_7_5-branch:1.13.0.2
	gdb_7_5-2012-07-18-branchpoint:1.13
	sid-snapshot-20120701:1.13
	sid-snapshot-20120601:1.13
	sid-snapshot-20120501:1.12
	binutils-2_22_branch:1.12.0.14
	gdb_7_4_1-2012-04-26-release:1.12
	sid-snapshot-20120401:1.12
	sid-snapshot-20120301:1.12
	sid-snapshot-20120201:1.12
	gdb_7_4-2012-01-24-release:1.12
	sid-snapshot-20120101:1.12
	gdb_7_4-branch:1.12.0.12
	gdb_7_4-2011-12-13-branchpoint:1.12
	sid-snapshot-20111201:1.12
	binutils-2_22:1.12
	sid-snapshot-20111101:1.12
	sid-snapshot-20111001:1.12
	binutils-2_22-branch:1.12.0.10
	binutils-2_22-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.12
	sid-snapshot-20110901:1.12
	sid-snapshot-20110801:1.12
	gdb_7_3-2011-07-26-release:1.12
	sid-snapshot-20110701:1.12
	sid-snapshot-20110601:1.12
	sid-snapshot-20110501:1.12
	gdb_7_3-branch:1.12.0.8
	gdb_7_3-2011-04-01-branchpoint:1.12
	sid-snapshot-20110401:1.12
	sid-snapshot-20110301:1.12
	sid-snapshot-20110201:1.12
	sid-snapshot-20110101:1.12
	binutils-2_21:1.12
	sid-snapshot-20101201:1.12
	binutils-2_21-branch:1.12.0.6
	binutils-2_21-branchpoint:1.12
	sid-snapshot-20101101:1.12
	sid-snapshot-20101001:1.12
	binutils-2_20_1:1.11
	gdb_7_2-2010-09-02-release:1.12
	sid-snapshot-20100901:1.12
	sid-snapshot-20100801:1.12
	gdb_7_2-branch:1.12.0.4
	gdb_7_2-2010-07-07-branchpoint:1.12
	sid-snapshot-20100701:1.12
	sid-snapshot-20100601:1.12
	sid-snapshot-20100501:1.12
	sid-snapshot-20100401:1.12
	gdb_7_1-2010-03-18-release:1.12
	sid-snapshot-20100301:1.12
	gdb_7_1-branch:1.12.0.2
	gdb_7_1-2010-02-18-branchpoint:1.12
	sid-snapshot-20100201:1.12
	sid-snapshot-20100101:1.12
	gdb_7_0_1-2009-12-22-release:1.11
	sid-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	binutils-2_20:1.11
	gdb_7_0-2009-10-06-release:1.11
	sid-snapshot-20091001:1.11
	gdb_7_0-branch:1.11.0.34
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.11
	binutils-arc-20081103-branch:1.11.0.32
	binutils-arc-20081103-branchpoint:1.11
	binutils-2_20-branch:1.11.0.30
	binutils-2_20-branchpoint:1.11
	sid-snapshot-20090901:1.11
	sid-snapshot-20090801:1.11
	msnyder-checkpoint-072509-branch:1.11.0.28
	msnyder-checkpoint-072509-branchpoint:1.11
	sid-snapshot-20090701:1.11
	dje-cgen-play1-branch:1.11.0.26
	dje-cgen-play1-branchpoint:1.11
	sid-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	arc-20081103-branch:1.11.0.24
	arc-20081103-branchpoint:1.11
	arc-insight_6_8-branch:1.11.0.22
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.20
	insight_6_8-branchpoint:1.11
	sid-snapshot-20090301:1.11
	binutils-2_19_1:1.11
	sid-snapshot-20090201:1.11
	sid-snapshot-20090101:1.11
	reverse-20081226-branch:1.11.0.18
	reverse-20081226-branchpoint:1.11
	sid-snapshot-20081201:1.11
	multiprocess-20081120-branch:1.11.0.16
	multiprocess-20081120-branchpoint:1.11
	sid-snapshot-20081101:1.11
	binutils-2_19:1.11
	sid-snapshot-20081001:1.11
	reverse-20080930-branch:1.11.0.14
	reverse-20080930-branchpoint:1.11
	binutils-2_19-branch:1.11.0.12
	binutils-2_19-branchpoint:1.11
	sid-snapshot-20080901:1.11
	sid-snapshot-20080801:1.11
	reverse-20080717-branch:1.11.0.10
	reverse-20080717-branchpoint:1.11
	sid-snapshot-20080701:1.11
	msnyder-reverse-20080609-branch:1.11.0.8
	msnyder-reverse-20080609-branchpoint:1.11
	drow-reverse-20070409-branch:1.10.0.34
	drow-reverse-20070409-branchpoint:1.10
	sid-snapshot-20080601:1.11
	sid-snapshot-20080501:1.11
	sid-snapshot-20080403:1.11
	sid-snapshot-20080401:1.11
	gdb_6_8-2008-03-27-release:1.11
	sid-snapshot-20080301:1.11
	gdb_6_8-branch:1.11.0.6
	gdb_6_8-2008-02-26-branchpoint:1.11
	sid-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	sid-snapshot-20071001:1.11
	gdb_6_7-branch:1.11.0.4
	gdb_6_7-2007-09-07-branchpoint:1.11
	binutils-2_18:1.11
	binutils-2_18-branch:1.11.0.2
	binutils-2_18-branchpoint:1.11
	insight_6_6-20070208-release:1.10
	binutils-csl-coldfire-4_1-32:1.10
	binutils-csl-sourcerygxx-4_1-32:1.10
	gdb_6_6-2006-12-18-release:1.10
	binutils-csl-innovasic-fido-3_4_4-33:1.10
	binutils-csl-sourcerygxx-3_4_4-32:1.8
	binutils-csl-coldfire-4_1-30:1.10
	binutils-csl-sourcerygxx-4_1-30:1.10
	binutils-csl-coldfire-4_1-28:1.10
	binutils-csl-sourcerygxx-4_1-29:1.10
	binutils-csl-sourcerygxx-4_1-28:1.10
	gdb_6_6-branch:1.10.0.32
	gdb_6_6-2006-11-15-branchpoint:1.10
	binutils-csl-arm-2006q3-27:1.10
	binutils-csl-sourcerygxx-4_1-27:1.10
	binutils-csl-arm-2006q3-26:1.10
	binutils-csl-sourcerygxx-4_1-26:1.10
	binutils-csl-sourcerygxx-4_1-25:1.10
	binutils-csl-sourcerygxx-4_1-24:1.10
	binutils-csl-sourcerygxx-4_1-23:1.10
	insight_6_5-20061003-release:1.10
	gdb-csl-symbian-6_4_50_20060226-12:1.10
	binutils-csl-sourcerygxx-4_1-21:1.10
	binutils-csl-arm-2006q3-21:1.10
	binutils-csl-sourcerygxx-4_1-22:1.10
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.10
	binutils-csl-sourcerygxx-4_1-20:1.10
	binutils-csl-arm-2006q3-19:1.10
	binutils-csl-sourcerygxx-4_1-19:1.10
	binutils-csl-sourcerygxx-4_1-18:1.10
	binutils-csl-renesas-4_1-9:1.10
	gdb-csl-sourcerygxx-3_4_4-25:1.10
	binutils-csl-sourcerygxx-3_4_4-25:1.8
	nickrob-async-20060828-mergepoint:1.10
	gdb-csl-symbian-6_4_50_20060226-11:1.10
	binutils-csl-renesas-4_1-8:1.10
	binutils-csl-renesas-4_1-7:1.10
	binutils-csl-renesas-4_1-6:1.10
	gdb-csl-sourcerygxx-4_1-17:1.10
	binutils-csl-sourcerygxx-4_1-17:1.10
	gdb-csl-20060226-branch-local-2:1.10
	gdb-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-15:1.10
	gdb-csl-sourcerygxx-4_1-13:1.10
	binutils-csl-sourcerygxx-4_1-13:1.10
	binutils-2_17:1.10
	gdb-csl-sourcerygxx-4_1-12:1.10
	binutils-csl-sourcerygxx-4_1-12:1.10
	gdb-csl-sourcerygxx-3_4_4-21:1.10
	binutils-csl-sourcerygxx-3_4_4-21:1.10
	gdb_6_5-20060621-release:1.10
	binutils-csl-wrs-linux-3_4_4-24:1.8
	binutils-csl-wrs-linux-3_4_4-23:1.8
	gdb-csl-sourcerygxx-4_1-9:1.10
	binutils-csl-sourcerygxx-4_1-9:1.10
	gdb-csl-sourcerygxx-4_1-8:1.10
	binutils-csl-sourcerygxx-4_1-8:1.10
	gdb-csl-sourcerygxx-4_1-7:1.10
	binutils-csl-sourcerygxx-4_1-7:1.10
	gdb-csl-arm-2006q1-6:1.10
	binutils-csl-arm-2006q1-6:1.10
	gdb-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-wrs-linux-3_4_4-22:1.8
	gdb-csl-symbian-6_4_50_20060226-10:1.10
	gdb-csl-symbian-6_4_50_20060226-9:1.10
	gdb-csl-symbian-6_4_50_20060226-8:1.10
	gdb-csl-coldfire-4_1-11:1.10
	binutils-csl-coldfire-4_1-11:1.10
	gdb-csl-sourcerygxx-3_4_4-19:1.10
	binutils-csl-sourcerygxx-3_4_4-19:1.10
	gdb-csl-coldfire-4_1-10:1.10
	gdb_6_5-branch:1.10.0.30
	gdb_6_5-2006-05-14-branchpoint:1.10
	binutils-csl-coldfire-4_1-10:1.10
	gdb-csl-sourcerygxx-4_1-5:1.10
	binutils-csl-sourcerygxx-4_1-5:1.10
	nickrob-async-20060513-branch:1.10.0.28
	nickrob-async-20060513-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-4:1.10
	binutils-csl-sourcerygxx-4_1-4:1.10
	msnyder-reverse-20060502-branch:1.10.0.26
	msnyder-reverse-20060502-branchpoint:1.10
	binutils-csl-wrs-linux-3_4_4-21:1.8
	gdb-csl-morpho-4_1-4:1.10
	binutils-csl-morpho-4_1-4:1.10
	gdb-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-wrs-linux-3_4_4-20:1.8
	readline_5_1-import-branch:1.10.0.24
	readline_5_1-import-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.10
	binutils-2_17-branch:1.10.0.22
	binutils-2_17-branchpoint:1.10
	gdb-csl-symbian-20060226-branch:1.10.0.20
	gdb-csl-symbian-20060226-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.10
	msnyder-reverse-20060331-branch:1.10.0.18
	msnyder-reverse-20060331-branchpoint:1.10
	binutils-csl-2_17-branch:1.10.0.16
	binutils-csl-2_17-branchpoint:1.10
	gdb-csl-available-20060303-branch:1.10.0.14
	gdb-csl-available-20060303-branchpoint:1.10
	gdb-csl-20060226-branch:1.10.0.12
	gdb-csl-20060226-branchpoint:1.10
	gdb_6_4-20051202-release:1.10
	msnyder-fork-checkpoint-branch:1.10.0.10
	msnyder-fork-checkpoint-branchpoint:1.10
	gdb-csl-gxxpro-6_3-branch:1.10.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.10
	gdb_6_4-branch:1.10.0.6
	gdb_6_4-2005-11-01-branchpoint:1.10
	gdb-csl-arm-20051020-branch:1.10.0.4
	gdb-csl-arm-20051020-branchpoint:1.10
	binutils-csl-gxxpro-3_4-branch:1.8.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.8
	binutils-2_16_1:1.8
	msnyder-tracepoint-checkpoint-branch:1.10.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb-csl-arm-20050325-2005-q1b:1.8
	binutils-csl-arm-2005q1b:1.8
	binutils-2_16:1.8
	gdb-csl-arm-20050325-2005-q1a:1.8
	binutils-csl-arm-2005q1a:1.8
	csl-arm-20050325-branch:1.8.0.6
	csl-arm-20050325-branchpoint:1.8
	binutils-csl-arm-2005q1-branch:1.8.0.4
	binutils-csl-arm-2005q1-branchpoint:1.8
	binutils-2_16-branch:1.8.0.2
	binutils-2_16-branchpoint:1.8
	csl-arm-2004-q3d:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.22
	gdb_6_3-20041019-branchpoint:1.6
	csl-arm-2004-q3:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.24
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	binutils-2_15:1.6
	binutils-2_15-branchpoint:1.6
	csl-arm-2004-q1a:1.6
	csl-arm-2004-q1:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.18
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.16
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.12
	drow_intercu-20040221-branchpoint:1.6
	binutils-2_15-branch:1.6.0.10
	cagney_bfdfile-20040213-branch:1.6.0.8
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.6
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	csl-arm-2003-q4:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.6.0.4
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.2
	cagney_x86i386-20030821-branch:1.5.0.62
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.60
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.58
	jimb-ppc64-linux-20030613-branchpoint:1.5
	binutils-2_14:1.5
	cagney_convert-20030606-branch:1.5.0.56
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.54
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.50
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	binutils-2_14-branch:1.5.0.46
	binutils-2_14-branchpoint:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.44
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.42
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.40
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.38
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.36
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.34
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.32
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.30
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.28
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.26
	cagney-unwind-20030108-branchpoint:1.5
	binutils-2_13_2_1:1.5
	binutils-2_13_2:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	binutils-2_13_1:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.24
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.22
	carlton_dictionary-20020920-branchpoint:1.5
	sid-20020905-branchpoint:1.5
	sid-20020905-branch:1.5.0.20
	gdb_5_3-branch:1.5.0.18
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.16
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.14
	readline_4_3-import-branchpoint:1.5
	binutils-2_13:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	binutils-2_13-branchpoint:1.5
	binutils-2_13-branch:1.5.0.12
	kseitz_interps-20020528-branch:1.5.0.10
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.8
	cagney_regbuf-20020515-branchpoint:1.5
	binutils-2_12_1:1.5
	jimb-macro-020506-branch:1.5.0.6
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	binutils-2_12:1.5
	gdb_5_2-branch:1.5.0.4
	gdb_5_2-2002-03-03-branchpoint:1.5
	binutils-2_12-branch:1.5.0.2
	binutils-2_12-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.3
	binutils_latest_snapshot:1.13
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2;
locks; strict;
comment	@ * @;


1.13
date	2012.05.18.05.31.15;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.11.13.42.17;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.05.09.49.01;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.07.07.34.29;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.05.21.45.58;	author wilson;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.03.11.49.49;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.23.16.04.39;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.14.15.16.57;	author aj;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.21.08.51.12;	author aj;	state Exp;
branches
	1.5.22.1
	1.5.24.1;
next	1.4;

1.4
date	2001.03.13.22.58.36;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.12.22.56.36;	author wilson;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.23.02.39.13;	author twall;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.21.20.22.24;	author wilson;	state Exp;
branches;
next	;

1.5.22.1
date	2003.09.17.21.28.59;	author carlton;	state Exp;
branches;
next	;

1.5.24.1
date	2003.12.14.20.28.07;	author drow;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.18.35;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.13
log
@	* ia64-opc.c: Remove #include "ansidecl.h".
	* z8kgen.c: Include sysdep.h first.
@
text
@/* ia64-opc.c -- Functions to access the compacted opcode table
   Copyright 1999, 2000, 2001, 2003, 2005, 2007, 2009, 2012
   Free Software Foundation, Inc.
   Written by Bob Manson of Cygnus Solutions, <manson@@cygnus.com>

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this file; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "libiberty.h"
#include "ia64-asmtab.h"
#include "ia64-asmtab.c"

static void get_opc_prefix (const char **, char *);
static short int find_string_ent (const char *);
static short int find_main_ent (short int);
static short int find_completer (short int, short int, const char *);
static ia64_insn apply_completer (ia64_insn, int);
static int extract_op_bits (int, int, int);
static int extract_op (int, int *, unsigned int *);
static int opcode_verify (ia64_insn, int, enum ia64_insn_type);
static int locate_opcode_ent (ia64_insn, enum ia64_insn_type);
static struct ia64_opcode *make_ia64_opcode
  (ia64_insn, const char *, int, int);
static struct ia64_opcode *ia64_find_matching_opcode
  (const char *, short int);

const struct ia64_templ_desc ia64_templ_desc[16] =
  {
    { 0, { IA64_UNIT_M, IA64_UNIT_I, IA64_UNIT_I }, "MII" },	/* 0 */
    { 2, { IA64_UNIT_M, IA64_UNIT_I, IA64_UNIT_I }, "MII" },
    { 0, { IA64_UNIT_M, IA64_UNIT_L, IA64_UNIT_X }, "MLX" },
    { 0, { 0, },				    "-3-" },
    { 0, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_I }, "MMI" },	/* 4 */
    { 1, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_I }, "MMI" },
    { 0, { IA64_UNIT_M, IA64_UNIT_F, IA64_UNIT_I }, "MFI" },
    { 0, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_F }, "MMF" },
    { 0, { IA64_UNIT_M, IA64_UNIT_I, IA64_UNIT_B }, "MIB" },	/* 8 */
    { 0, { IA64_UNIT_M, IA64_UNIT_B, IA64_UNIT_B }, "MBB" },
    { 0, { 0, },				    "-a-" },
    { 0, { IA64_UNIT_B, IA64_UNIT_B, IA64_UNIT_B }, "BBB" },
    { 0, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_B }, "MMB" },	/* c */
    { 0, { 0, },				    "-d-" },
    { 0, { IA64_UNIT_M, IA64_UNIT_F, IA64_UNIT_B }, "MFB" },
    { 0, { 0, },				    "-f-" },
  };


/* Copy the prefix contained in *PTR (up to a '.' or a NUL) to DEST.
   PTR will be adjusted to point to the start of the next portion
   of the opcode, or at the NUL character. */

static void
get_opc_prefix (const char **ptr, char *dest)
{
  char *c = strchr (*ptr, '.');
  if (c != NULL)
    {
      memcpy (dest, *ptr, c - *ptr);
      dest[c - *ptr] = '\0';
      *ptr = c + 1;
    }
  else
    {
      int l = strlen (*ptr);
      memcpy (dest, *ptr, l);
      dest[l] = '\0';
      *ptr += l;
    }
}

/* Find the index of the entry in the string table corresponding to
   STR; return -1 if one does not exist. */

static short
find_string_ent (const char *str)
{
  short start = 0;
  short end = sizeof (ia64_strings) / sizeof (const char *);
  short i = (start + end) / 2;

  if (strcmp (str, ia64_strings[end - 1]) > 0)
    {
      return -1;
    }
  while (start <= end)
    {
      int c = strcmp (str, ia64_strings[i]);
      if (c < 0)
	{
	  end = i - 1;
	}
      else if (c == 0)
	{
	  return i;
	}
      else
	{
	  start = i + 1;
	}
      i = (start + end) / 2;
    }
  return -1;
}

/* Find the opcode in the main opcode table whose name is STRINGINDEX, or
   return -1 if one does not exist. */

static short
find_main_ent (short nameindex)
{
  short start = 0;
  short end = sizeof (main_table) / sizeof (struct ia64_main_table);
  short i = (start + end) / 2;

  if (nameindex < main_table[0].name_index
      || nameindex > main_table[end - 1].name_index)
    {
      return -1;
    }
  while (start <= end)
    {
      if (nameindex < main_table[i].name_index)
	{
	  end = i - 1;
	}
      else if (nameindex == main_table[i].name_index)
	{
	  while (i > 0 && main_table[i - 1].name_index == nameindex)
	    {
	      i--;
	    }
	  return i;
	}
      else
	{
	  start = i + 1;
	}
      i = (start + end) / 2;
    }
  return -1;
}

/* Find the index of the entry in the completer table that is part of
   MAIN_ENT (starting from PREV_COMPLETER) that matches NAME, or
   return -1 if one does not exist. */

static short
find_completer (short main_ent, short prev_completer, const char *name)
{
  short name_index = find_string_ent (name);

  if (name_index < 0)
    {
      return -1;
    }

  if (prev_completer == -1)
    {
      prev_completer = main_table[main_ent].completers;
    }
  else
    {
      prev_completer = completer_table[prev_completer].subentries;
    }

  while (prev_completer != -1)
    {
      if (completer_table[prev_completer].name_index == name_index)
	{
	  return prev_completer;
	}
      prev_completer = completer_table[prev_completer].alternative;
    }
  return -1;
}

/* Apply the completer referred to by COMPLETER_INDEX to OPCODE, and
   return the result. */

static ia64_insn
apply_completer (ia64_insn opcode, int completer_index)
{
  ia64_insn mask = completer_table[completer_index].mask;
  ia64_insn bits = completer_table[completer_index].bits;
  int shiftamt = (completer_table[completer_index].offset & 63);

  mask = mask << shiftamt;
  bits = bits << shiftamt;
  opcode = (opcode & ~mask) | bits;
  return opcode;
}

/* Extract BITS number of bits starting from OP_POINTER + BITOFFSET in
   the dis_table array, and return its value.  (BITOFFSET is numbered
   starting from MSB to LSB, so a BITOFFSET of 0 indicates the MSB of the
   first byte in OP_POINTER.) */

static int
extract_op_bits (int op_pointer, int bitoffset, int bits)
{
  int res = 0;

  op_pointer += (bitoffset / 8);

  if (bitoffset % 8)
    {
      unsigned int op = dis_table[op_pointer++];
      int numb = 8 - (bitoffset % 8);
      int mask = (1 << numb) - 1;
      int bata = (bits < numb) ? bits : numb;
      int delta = numb - bata;

      res = (res << bata) | ((op & mask) >> delta);
      bitoffset += bata;
      bits -= bata;
    }
  while (bits >= 8)
    {
      res = (res << 8) | (dis_table[op_pointer++] & 255);
      bits -= 8;
    }
  if (bits > 0)
    {
      unsigned int op = (dis_table[op_pointer++] & 255);
      res = (res << bits) | (op >> (8 - bits));
    }
  return res;
}

/* Examine the state machine entry at OP_POINTER in the dis_table
   array, and extract its values into OPVAL and OP.  The length of the
   state entry in bits is returned. */

static int
extract_op (int op_pointer, int *opval, unsigned int *op)
{
  int oplen = 5;

  *op = dis_table[op_pointer];

  if ((*op) & 0x40)
    {
      opval[0] = extract_op_bits (op_pointer, oplen, 5);
      oplen += 5;
    }
  switch ((*op) & 0x30)
    {
    case 0x10:
      {
	opval[1] = extract_op_bits (op_pointer, oplen, 8);
	oplen += 8;
	opval[1] += op_pointer;
	break;
      }
    case 0x20:
      {
	opval[1] = extract_op_bits (op_pointer, oplen, 16);
	if (! (opval[1] & 32768))
	  {
	    opval[1] += op_pointer;
	  }
	oplen += 16;
	break;
      }
    case 0x30:
      {
	oplen--;
	opval[2] = extract_op_bits (op_pointer, oplen, 12);
	oplen += 12;
	opval[2] |= 32768;
	break;
      }
    }
  if (((*op) & 0x08) && (((*op) & 0x30) != 0x30))
    {
      opval[2] = extract_op_bits (op_pointer, oplen, 16);
      oplen += 16;
      if (! (opval[2] & 32768))
	{
	  opval[2] += op_pointer;
	}
    }
  return oplen;
}

/* Returns a non-zero value if the opcode in the main_table list at
   PLACE matches OPCODE and is of type TYPE. */

static int
opcode_verify (ia64_insn opcode, int place, enum ia64_insn_type type)
{
  if (main_table[place].opcode_type != type)
    {
      return 0;
    }
  if (main_table[place].flags
      & (IA64_OPCODE_F2_EQ_F3 | IA64_OPCODE_LEN_EQ_64MCNT))
    {
      const struct ia64_operand *o1, *o2;
      ia64_insn f2, f3;

      if (main_table[place].flags & IA64_OPCODE_F2_EQ_F3)
	{
	  o1 = elf64_ia64_operands + IA64_OPND_F2;
	  o2 = elf64_ia64_operands + IA64_OPND_F3;
	  (*o1->extract) (o1, opcode, &f2);
	  (*o2->extract) (o2, opcode, &f3);
	  if (f2 != f3)
	    return 0;
	}
      else
	{
	  ia64_insn len, count;

	  /* length must equal 64-count: */
	  o1 = elf64_ia64_operands + IA64_OPND_LEN6;
	  o2 = elf64_ia64_operands + main_table[place].operands[2];
	  (*o1->extract) (o1, opcode, &len);
	  (*o2->extract) (o2, opcode, &count);
	  if (len != 64 - count)
	    return 0;
	}
    }
  return 1;
}

/* Find an instruction entry in the ia64_dis_names array that matches
   opcode OPCODE and is of type TYPE.  Returns either a positive index
   into the array, or a negative value if an entry for OPCODE could
   not be found.  Checks all matches and returns the one with the highest
   priority. */

static int
locate_opcode_ent (ia64_insn opcode, enum ia64_insn_type type)
{
  int currtest[41];
  int bitpos[41];
  int op_ptr[41];
  int currstatenum = 0;
  short found_disent = -1;
  short found_priority = -1;

  currtest[currstatenum] = 0;
  op_ptr[currstatenum] = 0;
  bitpos[currstatenum] = 40;

  while (1)
    {
      int op_pointer = op_ptr[currstatenum];
      unsigned int op;
      int currbitnum = bitpos[currstatenum];
      int oplen;
      int opval[3] = {0};
      int next_op;
      int currbit;

      oplen = extract_op (op_pointer, opval, &op);

      bitpos[currstatenum] = currbitnum;

      /* Skip opval[0] bits in the instruction. */
      if (op & 0x40)
	{
	  currbitnum -= opval[0];
	}

      /* The value of the current bit being tested. */
      currbit = opcode & (((ia64_insn) 1) << currbitnum) ? 1 : 0;
      next_op = -1;

      /* We always perform the tests specified in the current state in
	 a particular order, falling through to the next test if the
	 previous one failed. */
      switch (currtest[currstatenum])
	{
	case 0:
	  currtest[currstatenum]++;
	  if (currbit == 0 && (op & 0x80))
	    {
	      /* Check for a zero bit.  If this test solely checks for
		 a zero bit, we can check for up to 8 consecutive zero
		 bits (the number to check is specified by the lower 3
		 bits in the state code.)

		 If the state instruction matches, we go to the very
		 next state instruction; otherwise, try the next test. */

	      if ((op & 0xf8) == 0x80)
		{
		  int count = op & 0x7;
		  int x;

		  for (x = 0; x <= count; x++)
		    {
		      int i =
			opcode & (((ia64_insn) 1) << (currbitnum - x)) ? 1 : 0;
		      if (i)
			{
			  break;
			}
		    }
		  if (x > count)
		    {
		      next_op = op_pointer + ((oplen + 7) / 8);
		      currbitnum -= count;
		      break;
		    }
		}
	      else if (! currbit)
		{
		  next_op = op_pointer + ((oplen + 7) / 8);
		  break;
		}
	    }
	  /* FALLTHROUGH */
	case 1:
	  /* If the bit in the instruction is one, go to the state
	     instruction specified by opval[1]. */
	  currtest[currstatenum]++;
	  if (currbit && (op & 0x30) != 0 && ((op & 0x30) != 0x30))
	    {
	      next_op = opval[1];
	      break;
	    }
	  /* FALLTHROUGH */
	case 2:
	  /* Don't care.  Skip the current bit and go to the state
	     instruction specified by opval[2].

	     An encoding of 0x30 is special; this means that a 12-bit
	     offset into the ia64_dis_names[] array is specified.  */
	  currtest[currstatenum]++;
	  if ((op & 0x08) || ((op & 0x30) == 0x30))
	    {
	      next_op = opval[2];
	      break;
	    }
	}

      /* If bit 15 is set in the address of the next state, an offset
	 in the ia64_dis_names array was specified instead.  We then
	 check to see if an entry in the list of opcodes matches the
	 opcode we were given; if so, we have succeeded.  */

      if ((next_op >= 0) && (next_op & 32768))
	{
	  short disent = next_op & 32767;
          short priority = -1;

	  if (next_op > 65535)
	    {
	      abort ();
	    }

	  /* Run through the list of opcodes to check, trying to find
	     one that matches.  */
	  while (disent >= 0)
	    {
	      int place = ia64_dis_names[disent].insn_index;

              priority = ia64_dis_names[disent].priority;

	      if (opcode_verify (opcode, place, type)
                  && priority > found_priority)
		{
		  break;
		}
	      if (ia64_dis_names[disent].next_flag)
		{
		  disent++;
		}
	      else
		{
		  disent = -1;
		}
	    }

	  if (disent >= 0)
	    {
              found_disent = disent;
              found_priority = priority;
	    }
          /* Try the next test in this state, regardless of whether a match
             was found. */
          next_op = -2;
	}

      /* next_op == -1 is "back up to the previous state".
	 next_op == -2 is "stay in this state and try the next test".
	 Otherwise, transition to the state indicated by next_op. */

      if (next_op == -1)
	{
	  currstatenum--;
	  if (currstatenum < 0)
	    {
              return found_disent;
	    }
	}
      else if (next_op >= 0)
	{
	  currstatenum++;
	  bitpos[currstatenum] = currbitnum - 1;
	  op_ptr[currstatenum] = next_op;
	  currtest[currstatenum] = 0;
	}
    }
}

/* Construct an ia64_opcode entry based on OPCODE, NAME and PLACE. */

static struct ia64_opcode *
make_ia64_opcode (ia64_insn opcode, const char *name, int place, int depind)
{
  struct ia64_opcode *res =
    (struct ia64_opcode *) xmalloc (sizeof (struct ia64_opcode));
  res->name = xstrdup (name);
  res->type = main_table[place].opcode_type;
  res->num_outputs = main_table[place].num_outputs;
  res->opcode = opcode;
  res->mask = main_table[place].mask;
  res->operands[0] = main_table[place].operands[0];
  res->operands[1] = main_table[place].operands[1];
  res->operands[2] = main_table[place].operands[2];
  res->operands[3] = main_table[place].operands[3];
  res->operands[4] = main_table[place].operands[4];
  res->flags = main_table[place].flags;
  res->ent_index = place;
  res->dependencies = &op_dependencies[depind];
  return res;
}

/* Determine the ia64_opcode entry for the opcode specified by INSN
   and TYPE.  If a valid entry is not found, return NULL. */
struct ia64_opcode *
ia64_dis_opcode (ia64_insn insn, enum ia64_insn_type type)
{
  int disent = locate_opcode_ent (insn, type);

  if (disent < 0)
    {
      return NULL;
    }
  else
    {
      unsigned int cb = ia64_dis_names[disent].completer_index;
      static char name[128];
      int place = ia64_dis_names[disent].insn_index;
      int ci = main_table[place].completers;
      ia64_insn tinsn = main_table[place].opcode;

      strcpy (name, ia64_strings [main_table[place].name_index]);

      while (cb)
	{
	  if (cb & 1)
	    {
	      int cname = completer_table[ci].name_index;

	      tinsn = apply_completer (tinsn, ci);

	      if (ia64_strings[cname][0] != '\0')
		{
		  strcat (name, ".");
		  strcat (name, ia64_strings[cname]);
		}
	      if (cb != 1)
		{
		  ci = completer_table[ci].subentries;
		}
	    }
	  else
	    {
	      ci = completer_table[ci].alternative;
	    }
	  if (ci < 0)
	    {
	      abort ();
	    }
	  cb = cb >> 1;
	}
      if (tinsn != (insn & main_table[place].mask))
	{
	  abort ();
	}
      return make_ia64_opcode (insn, name, place,
                               completer_table[ci].dependencies);
    }
}

/* Search the main_opcode table starting from PLACE for an opcode that
   matches NAME.  Return NULL if one is not found. */

static struct ia64_opcode *
ia64_find_matching_opcode (const char *name, short place)
{
  char op[129];
  const char *suffix;
  short name_index;

  if (strlen (name) > 128)
    {
      return NULL;
    }
  suffix = name;
  get_opc_prefix (&suffix, op);
  name_index = find_string_ent (op);
  if (name_index < 0)
    {
      return NULL;
    }

  while (main_table[place].name_index == name_index)
    {
      const char *curr_suffix = suffix;
      ia64_insn curr_insn = main_table[place].opcode;
      short completer = -1;

      do {
	if (suffix[0] == '\0')
	  {
	    completer = find_completer (place, completer, suffix);
	  }
	else
	  {
	    get_opc_prefix (&curr_suffix, op);
	    completer = find_completer (place, completer, op);
	  }
	if (completer != -1)
	  {
	    curr_insn = apply_completer (curr_insn, completer);
	  }
      } while (completer != -1 && curr_suffix[0] != '\0');

      if (completer != -1 && curr_suffix[0] == '\0'
	  && completer_table[completer].terminal_completer)
	{
          int depind = completer_table[completer].dependencies;
	  return make_ia64_opcode (curr_insn, name, place, depind);
	}
      else
	{
	  place++;
	}
    }
  return NULL;
}

/* Find the next opcode after PREV_ENT that matches PREV_ENT, or return NULL
   if one does not exist.

   It is the caller's responsibility to invoke ia64_free_opcode () to
   release any resources used by the returned entry. */

struct ia64_opcode *
ia64_find_next_opcode (struct ia64_opcode *prev_ent)
{
  return ia64_find_matching_opcode (prev_ent->name,
				    prev_ent->ent_index + 1);
}

/* Find the first opcode that matches NAME, or return NULL if it does
   not exist.

   It is the caller's responsibility to invoke ia64_free_opcode () to
   release any resources used by the returned entry. */

struct ia64_opcode *
ia64_find_opcode (const char *name)
{
  char op[129];
  const char *suffix;
  short place;
  short name_index;

  if (strlen (name) > 128)
    {
      return NULL;
    }
  suffix = name;
  get_opc_prefix (&suffix, op);
  name_index = find_string_ent (op);
  if (name_index < 0)
    {
      return NULL;
    }

  place = find_main_ent (name_index);

  if (place < 0)
    {
      return NULL;
    }
  return ia64_find_matching_opcode (name, place);
}

/* Free any resources used by ENT. */
void
ia64_free_opcode (struct ia64_opcode *ent)
{
  free ((void *)ent->name);
  free (ent);
}

const struct ia64_dependency *
ia64_find_dependency (int dep_index)
{
  dep_index = DEP(dep_index);

  if (dep_index < 0
      || dep_index >= (int) ARRAY_SIZE (dependencies))
    return NULL;

  return &dependencies[dep_index];
}
@


1.12
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2003, 2005, 2007, 2009 Free Software Foundation, Inc.
a22 1
#include "ansidecl.h"
@


1.11
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2003, 2005, 2007 Free Software Foundation, Inc.
d721 1
a721 1
ia64_find_dependency (int index)
d723 1
a723 1
  index = DEP(index);
d725 2
a726 2
  if (index < 0
      || index >= (int)(sizeof(dependencies) / sizeof(dependencies[0])))
d729 1
a729 1
  return &dependencies[index];
@


1.10
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2003, 2005 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of GDB, GAS, and the GNU binutils.
d7 9
a15 9
   GDB, GAS, and the GNU binutils are free software; you can redistribute
   them and/or modify them under the terms of the GNU General Public
   License as published by the Free Software Foundation; either version
   2, or (at your option) any later version.

   GDB, GAS, and the GNU binutils are distributed in the hope that they
   will be useful, but WITHOUT ANY WARRANTY; without even the implied
   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.
d19 2
a20 2
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */
@


1.9
log
@Fix ia64-hpux build failure.
* ia64-opc.c: Include sysdep.h before libiberty.h.
@
text
@d19 2
a20 2
   Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.8
log
@update copyright dates
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.7
log
@Fix compile time warnings generated by gcc 4.0
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2003 Free Software Foundation, Inc.
@


1.6
log
@
	* i386-dis.c: Convert to ISO C90 prototypes.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewiwse.
	* i960-dis.c: Likewise.
	* ia64-opc.c: Likewise.
@
text
@d368 1
a368 1
      int opval[3];
@


1.5
log
@	* mips-dis.c: Add missing prototypes.
	* a29k-dis.c: Likewise.
	* arc-dis.c: Likewise.
	* ia64-opc.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d28 9
a36 9
static void get_opc_prefix PARAMS ((const char **, char *));
static short int find_string_ent PARAMS ((const char *));
static short int find_main_ent PARAMS ((short int));
static short int find_completer PARAMS ((short int, short int, const char *));
static ia64_insn apply_completer PARAMS ((ia64_insn, int));
static int extract_op_bits PARAMS ((int, int, int));
static int extract_op PARAMS ((int, int *, unsigned int *));
static int opcode_verify PARAMS ((ia64_insn, int, enum ia64_insn_type));
static int locate_opcode_ent PARAMS ((ia64_insn, enum ia64_insn_type));
d38 1
a38 1
  PARAMS ((ia64_insn, const char *, int, int));
d40 1
a40 1
  PARAMS ((const char *, short int));
d68 1
a68 3
get_opc_prefix (ptr, dest)
     const char **ptr;
     char *dest;
d90 1
a90 2
find_string_ent (str)
     const char *str;
d124 1
a124 2
find_main_ent (nameindex)
     short nameindex;
d163 1
a163 4
find_completer (main_ent, prev_completer, name)
     short main_ent;
     short prev_completer;
     const char *name;
d196 1
a196 3
apply_completer (opcode, completer_index)
     ia64_insn opcode;
     int completer_index;
d214 1
a214 4
extract_op_bits (op_pointer, bitoffset, bits)
     int op_pointer;
     int bitoffset;
     int bits;
d250 1
a250 4
extract_op (op_pointer, opval, op)
     int op_pointer;
     int *opval;
     unsigned int *op;
d305 1
a305 4
opcode_verify (opcode, place, type)
     ia64_insn opcode;
     int place;
     enum ia64_insn_type type;
d349 1
a349 3
locate_opcode_ent (opcode, type)
     ia64_insn opcode;
     enum ia64_insn_type type;
d528 1
a528 5
make_ia64_opcode (opcode, name, place, depind)
     ia64_insn opcode;
     const char *name;
     int place;
     int depind;
d551 1
a551 3
ia64_dis_opcode (insn, type)
     ia64_insn insn;
     enum ia64_insn_type type;
d610 1
a610 3
ia64_find_matching_opcode (name, place)
     const char *name;
     short place;
d671 1
a671 2
ia64_find_next_opcode (prev_ent)
     struct ia64_opcode *prev_ent;
d684 1
a684 2
ia64_find_opcode (name)
     const char *name;
d714 1
a714 2
ia64_free_opcode (ent)
     struct ia64_opcode *ent;
d721 1
a721 2
ia64_find_dependency (index)
  int index;
@


1.5.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2003 Free Software Foundation, Inc.
d28 9
a36 9
static void get_opc_prefix (const char **, char *);
static short int find_string_ent (const char *);
static short int find_main_ent (short int);
static short int find_completer (short int, short int, const char *);
static ia64_insn apply_completer (ia64_insn, int);
static int extract_op_bits (int, int, int);
static int extract_op (int, int *, unsigned int *);
static int opcode_verify (ia64_insn, int, enum ia64_insn_type);
static int locate_opcode_ent (ia64_insn, enum ia64_insn_type);
d38 1
a38 1
  (ia64_insn, const char *, int, int);
d40 1
a40 1
  (const char *, short int);
d68 3
a70 1
get_opc_prefix (const char **ptr, char *dest)
d92 2
a93 1
find_string_ent (const char *str)
d127 2
a128 1
find_main_ent (short nameindex)
d167 4
a170 1
find_completer (short main_ent, short prev_completer, const char *name)
d203 3
a205 1
apply_completer (ia64_insn opcode, int completer_index)
d223 4
a226 1
extract_op_bits (int op_pointer, int bitoffset, int bits)
d262 4
a265 1
extract_op (int op_pointer, int *opval, unsigned int *op)
d320 4
a323 1
opcode_verify (ia64_insn opcode, int place, enum ia64_insn_type type)
d367 3
a369 1
locate_opcode_ent (ia64_insn opcode, enum ia64_insn_type type)
d548 5
a552 1
make_ia64_opcode (ia64_insn opcode, const char *name, int place, int depind)
d575 3
a577 1
ia64_dis_opcode (ia64_insn insn, enum ia64_insn_type type)
d636 3
a638 1
ia64_find_matching_opcode (const char *name, short place)
d699 2
a700 1
ia64_find_next_opcode (struct ia64_opcode *prev_ent)
d713 2
a714 1
ia64_find_opcode (const char *name)
d744 2
a745 1
ia64_free_opcode (struct ia64_opcode *ent)
d752 2
a753 1
ia64_find_dependency (int index)
@


1.5.22.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2003 Free Software Foundation, Inc.
d28 9
a36 9
static void get_opc_prefix (const char **, char *);
static short int find_string_ent (const char *);
static short int find_main_ent (short int);
static short int find_completer (short int, short int, const char *);
static ia64_insn apply_completer (ia64_insn, int);
static int extract_op_bits (int, int, int);
static int extract_op (int, int *, unsigned int *);
static int opcode_verify (ia64_insn, int, enum ia64_insn_type);
static int locate_opcode_ent (ia64_insn, enum ia64_insn_type);
d38 1
a38 1
  (ia64_insn, const char *, int, int);
d40 1
a40 1
  (const char *, short int);
d68 3
a70 1
get_opc_prefix (const char **ptr, char *dest)
d92 2
a93 1
find_string_ent (const char *str)
d127 2
a128 1
find_main_ent (short nameindex)
d167 4
a170 1
find_completer (short main_ent, short prev_completer, const char *name)
d203 3
a205 1
apply_completer (ia64_insn opcode, int completer_index)
d223 4
a226 1
extract_op_bits (int op_pointer, int bitoffset, int bits)
d262 4
a265 1
extract_op (int op_pointer, int *opval, unsigned int *op)
d320 4
a323 1
opcode_verify (ia64_insn opcode, int place, enum ia64_insn_type type)
d367 3
a369 1
locate_opcode_ent (ia64_insn opcode, enum ia64_insn_type type)
d548 5
a552 1
make_ia64_opcode (ia64_insn opcode, const char *name, int place, int depind)
d575 3
a577 1
ia64_dis_opcode (ia64_insn insn, enum ia64_insn_type type)
d636 3
a638 1
ia64_find_matching_opcode (const char *name, short place)
d699 2
a700 1
ia64_find_next_opcode (struct ia64_opcode *prev_ent)
d713 2
a714 1
ia64_find_opcode (const char *name)
d744 2
a745 1
ia64_free_opcode (struct ia64_opcode *ent)
d752 2
a753 1
ia64_find_dependency (int index)
@


1.4
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d28 14
d166 1
a166 1
static short 
d329 1
a329 1
  if (main_table[place].flags 
d498 1
a498 1
	      if (opcode_verify (opcode, place, type) 
d627 1
a627 1
      return make_ia64_opcode (insn, name, place, 
d663 1
a663 1
      	if (suffix[0] == '\0')
@


1.3
log
@Eliminate ia64 compiler warnings.  Fix ia64 gas testsuite again.
	*  elfxx-ia64.c (get_dyn_sym_info): Cast %p argument to void *.
	* config/tc-ia64.h (ia64_init): Add prototype.
	* gas/ia64/dv-imply.d, gas/ia64/dv-mutex.d, gas/ia64/dv-safe.d,
	gas/ia64/dv-srlz.d, gas/ia64/opc-m.d: Update.
	* ia64-dis.c (print_insn_ia64): Cast away const on ia64_free_opcode
	argument.
	* ia64_gen.c (insert_deplist): Cast sizeof result to int.
	(print_dependency_table): Print NULL if semantics field not set.
	(insert_opcode_dependencies): Mark cmp parameter as unused.
	(print_main_table): Use fprintf_vma to print long long fields.
	(main): Mark argv paramter as unused.  Convert to old style definition.
	* ia64-opc.c (ia64_find_dependency): Cast sizeof result to int.
	* ia64-asmtab.c: Regnerate.
@
text
@d2 1
a2 1
   Copyright (C) 1999 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.2
log
@Misc assembly/disassembly fixes.
@
text
@d743 2
a744 1
  if (index < 0 || index >= sizeof(dependencies) / sizeof(dependencies[0]))
@


1.1
log
@IA-64 ELF support.
@
text
@d349 2
a350 1
   not be found.  */
d361 2
d469 1
d482 4
a485 1
	      if (opcode_verify (opcode, place, type))
d501 2
a502 6
	      return disent;
	    }
	  else
	    {
	      /* Failed to match; try the next test in this state. */
	      next_op = -2;
d504 3
d518 1
a518 1
	      return -1;
@

