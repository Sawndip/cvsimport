head	1.16;
access;
symbols
	sid-snapshot-20180601:1.16
	sid-snapshot-20180501:1.16
	sid-snapshot-20180401:1.16
	sid-snapshot-20180301:1.16
	sid-snapshot-20180201:1.16
	sid-snapshot-20180101:1.16
	sid-snapshot-20171201:1.16
	sid-snapshot-20171101:1.16
	sid-snapshot-20171001:1.16
	sid-snapshot-20170901:1.16
	sid-snapshot-20170801:1.16
	sid-snapshot-20170701:1.16
	sid-snapshot-20170601:1.16
	sid-snapshot-20170501:1.16
	sid-snapshot-20170401:1.16
	sid-snapshot-20170301:1.16
	sid-snapshot-20170201:1.16
	sid-snapshot-20170101:1.16
	sid-snapshot-20161201:1.16
	sid-snapshot-20161101:1.16
	sid-snapshot-20160901:1.16
	sid-snapshot-20160801:1.16
	sid-snapshot-20160701:1.16
	sid-snapshot-20160601:1.16
	sid-snapshot-20160501:1.16
	sid-snapshot-20160401:1.16
	sid-snapshot-20160301:1.16
	sid-snapshot-20160201:1.16
	sid-snapshot-20160101:1.16
	sid-snapshot-20151201:1.16
	sid-snapshot-20151101:1.16
	sid-snapshot-20151001:1.16
	sid-snapshot-20150901:1.16
	sid-snapshot-20150801:1.16
	sid-snapshot-20150701:1.16
	sid-snapshot-20150601:1.16
	sid-snapshot-20150501:1.16
	sid-snapshot-20150401:1.16
	sid-snapshot-20150301:1.16
	sid-snapshot-20150201:1.16
	sid-snapshot-20150101:1.16
	sid-snapshot-20141201:1.16
	sid-snapshot-20141101:1.16
	sid-snapshot-20141001:1.16
	sid-snapshot-20140901:1.16
	sid-snapshot-20140801:1.16
	sid-snapshot-20140701:1.16
	sid-snapshot-20140601:1.16
	sid-snapshot-20140501:1.16
	sid-snapshot-20140401:1.16
	sid-snapshot-20140301:1.16
	sid-snapshot-20140201:1.16
	sid-snapshot-20140101:1.16
	sid-snapshot-20131201:1.16
	sid-snapshot-20131101:1.16
	sid-snapshot-20131001:1.16
	binutils-2_24-branch:1.16.0.8
	binutils-2_24-branchpoint:1.16
	binutils-2_21_1:1.15
	sid-snapshot-20130901:1.16
	gdb_7_6_1-2013-08-30-release:1.16
	sid-snapshot-20130801:1.16
	sid-snapshot-20130701:1.16
	sid-snapshot-20130601:1.16
	sid-snapshot-20130501:1.16
	gdb_7_6-2013-04-26-release:1.16
	sid-snapshot-20130401:1.16
	binutils-2_23_2:1.16
	gdb_7_6-branch:1.16.0.6
	gdb_7_6-2013-03-12-branchpoint:1.16
	sid-snapshot-20130301:1.16
	sid-snapshot-20130201:1.16
	sid-snapshot-20130101:1.16
	sid-snapshot-20121201:1.16
	gdb_7_5_1-2012-11-29-release:1.16
	binutils-2_23_1:1.16
	sid-snapshot-20121101:1.16
	binutils-2_23:1.16
	sid-snapshot-20121001:1.16
	sid-snapshot-20120901:1.16
	gdb_7_5-2012-08-17-release:1.16
	sid-snapshot-20120801:1.16
	binutils-2_23-branch:1.16.0.4
	binutils-2_23-branchpoint:1.16
	gdb_7_5-branch:1.16.0.2
	gdb_7_5-2012-07-18-branchpoint:1.16
	sid-snapshot-20120701:1.16
	sid-snapshot-20120601:1.16
	sid-snapshot-20120501:1.15
	binutils-2_22_branch:1.15.0.18
	gdb_7_4_1-2012-04-26-release:1.15
	sid-snapshot-20120401:1.15
	sid-snapshot-20120301:1.15
	sid-snapshot-20120201:1.15
	gdb_7_4-2012-01-24-release:1.15
	sid-snapshot-20120101:1.15
	gdb_7_4-branch:1.15.0.16
	gdb_7_4-2011-12-13-branchpoint:1.15
	sid-snapshot-20111201:1.15
	binutils-2_22:1.15
	sid-snapshot-20111101:1.15
	sid-snapshot-20111001:1.15
	binutils-2_22-branch:1.15.0.14
	binutils-2_22-branchpoint:1.15
	gdb_7_3_1-2011-09-04-release:1.15
	sid-snapshot-20110901:1.15
	sid-snapshot-20110801:1.15
	gdb_7_3-2011-07-26-release:1.15
	sid-snapshot-20110701:1.15
	sid-snapshot-20110601:1.15
	sid-snapshot-20110501:1.15
	gdb_7_3-branch:1.15.0.12
	gdb_7_3-2011-04-01-branchpoint:1.15
	sid-snapshot-20110401:1.15
	sid-snapshot-20110301:1.15
	sid-snapshot-20110201:1.15
	sid-snapshot-20110101:1.15
	binutils-2_21:1.15
	sid-snapshot-20101201:1.15
	binutils-2_21-branch:1.15.0.10
	binutils-2_21-branchpoint:1.15
	sid-snapshot-20101101:1.15
	sid-snapshot-20101001:1.15
	binutils-2_20_1:1.15
	gdb_7_2-2010-09-02-release:1.15
	sid-snapshot-20100901:1.15
	sid-snapshot-20100801:1.15
	gdb_7_2-branch:1.15.0.8
	gdb_7_2-2010-07-07-branchpoint:1.15
	sid-snapshot-20100701:1.15
	sid-snapshot-20100601:1.15
	sid-snapshot-20100501:1.15
	sid-snapshot-20100401:1.15
	gdb_7_1-2010-03-18-release:1.15
	sid-snapshot-20100301:1.15
	gdb_7_1-branch:1.15.0.6
	gdb_7_1-2010-02-18-branchpoint:1.15
	sid-snapshot-20100201:1.15
	sid-snapshot-20100101:1.15
	gdb_7_0_1-2009-12-22-release:1.15
	sid-snapshot-20091201:1.15
	sid-snapshot-20091101:1.15
	binutils-2_20:1.15
	gdb_7_0-2009-10-06-release:1.15
	sid-snapshot-20091001:1.15
	gdb_7_0-branch:1.15.0.4
	gdb_7_0-2009-09-16-branchpoint:1.15
	arc-sim-20090309:1.13
	binutils-arc-20081103-branch:1.13.0.26
	binutils-arc-20081103-branchpoint:1.13
	binutils-2_20-branch:1.15.0.2
	binutils-2_20-branchpoint:1.15
	sid-snapshot-20090901:1.14
	sid-snapshot-20090801:1.14
	msnyder-checkpoint-072509-branch:1.14.0.4
	msnyder-checkpoint-072509-branchpoint:1.14
	sid-snapshot-20090701:1.14
	dje-cgen-play1-branch:1.14.0.2
	dje-cgen-play1-branchpoint:1.14
	sid-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	arc-20081103-branch:1.13.0.24
	arc-20081103-branchpoint:1.13
	arc-insight_6_8-branch:1.13.0.22
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.20
	insight_6_8-branchpoint:1.13
	sid-snapshot-20090301:1.13
	binutils-2_19_1:1.13
	sid-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	reverse-20081226-branch:1.13.0.18
	reverse-20081226-branchpoint:1.13
	sid-snapshot-20081201:1.13
	multiprocess-20081120-branch:1.13.0.16
	multiprocess-20081120-branchpoint:1.13
	sid-snapshot-20081101:1.13
	binutils-2_19:1.13
	sid-snapshot-20081001:1.13
	reverse-20080930-branch:1.13.0.14
	reverse-20080930-branchpoint:1.13
	binutils-2_19-branch:1.13.0.12
	binutils-2_19-branchpoint:1.13
	sid-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	reverse-20080717-branch:1.13.0.10
	reverse-20080717-branchpoint:1.13
	sid-snapshot-20080701:1.13
	msnyder-reverse-20080609-branch:1.13.0.8
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.12.0.32
	drow-reverse-20070409-branchpoint:1.12
	sid-snapshot-20080601:1.13
	sid-snapshot-20080501:1.13
	sid-snapshot-20080403:1.13
	sid-snapshot-20080401:1.13
	gdb_6_8-2008-03-27-release:1.13
	sid-snapshot-20080301:1.13
	gdb_6_8-branch:1.13.0.6
	gdb_6_8-2008-02-26-branchpoint:1.13
	sid-snapshot-20080201:1.13
	sid-snapshot-20080101:1.13
	sid-snapshot-20071201:1.13
	sid-snapshot-20071101:1.13
	gdb_6_7_1-2007-10-29-release:1.13
	gdb_6_7-2007-10-10-release:1.13
	sid-snapshot-20071001:1.13
	gdb_6_7-branch:1.13.0.4
	gdb_6_7-2007-09-07-branchpoint:1.13
	binutils-2_18:1.13
	binutils-2_18-branch:1.13.0.2
	binutils-2_18-branchpoint:1.13
	insight_6_6-20070208-release:1.12
	binutils-csl-coldfire-4_1-32:1.12
	binutils-csl-sourcerygxx-4_1-32:1.12
	gdb_6_6-2006-12-18-release:1.12
	binutils-csl-innovasic-fido-3_4_4-33:1.12
	binutils-csl-sourcerygxx-3_4_4-32:1.7.82.1
	binutils-csl-coldfire-4_1-30:1.12
	binutils-csl-sourcerygxx-4_1-30:1.12
	binutils-csl-coldfire-4_1-28:1.12
	binutils-csl-sourcerygxx-4_1-29:1.12
	binutils-csl-sourcerygxx-4_1-28:1.12
	gdb_6_6-branch:1.12.0.30
	gdb_6_6-2006-11-15-branchpoint:1.12
	binutils-csl-arm-2006q3-27:1.12
	binutils-csl-sourcerygxx-4_1-27:1.12
	binutils-csl-arm-2006q3-26:1.12
	binutils-csl-sourcerygxx-4_1-26:1.12
	binutils-csl-sourcerygxx-4_1-25:1.12
	binutils-csl-sourcerygxx-4_1-24:1.12
	binutils-csl-sourcerygxx-4_1-23:1.12
	insight_6_5-20061003-release:1.12
	gdb-csl-symbian-6_4_50_20060226-12:1.12
	binutils-csl-sourcerygxx-4_1-21:1.12
	binutils-csl-arm-2006q3-21:1.12
	binutils-csl-sourcerygxx-4_1-22:1.12
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.12
	binutils-csl-sourcerygxx-4_1-20:1.12
	binutils-csl-arm-2006q3-19:1.12
	binutils-csl-sourcerygxx-4_1-19:1.12
	binutils-csl-sourcerygxx-4_1-18:1.12
	binutils-csl-renesas-4_1-9:1.12
	gdb-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-sourcerygxx-3_4_4-25:1.7.82.1
	nickrob-async-20060828-mergepoint:1.12
	gdb-csl-symbian-6_4_50_20060226-11:1.12
	binutils-csl-renesas-4_1-8:1.12
	binutils-csl-renesas-4_1-7:1.12
	binutils-csl-renesas-4_1-6:1.12
	gdb-csl-sourcerygxx-4_1-17:1.12
	binutils-csl-sourcerygxx-4_1-17:1.12
	gdb-csl-20060226-branch-local-2:1.12
	gdb-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-15:1.12
	gdb-csl-sourcerygxx-4_1-13:1.12
	binutils-csl-sourcerygxx-4_1-13:1.12
	binutils-2_17:1.12
	gdb-csl-sourcerygxx-4_1-12:1.12
	binutils-csl-sourcerygxx-4_1-12:1.12
	gdb-csl-sourcerygxx-3_4_4-21:1.12
	binutils-csl-sourcerygxx-3_4_4-21:1.12
	gdb_6_5-20060621-release:1.12
	binutils-csl-wrs-linux-3_4_4-24:1.7.82.1
	binutils-csl-wrs-linux-3_4_4-23:1.7.82.1
	gdb-csl-sourcerygxx-4_1-9:1.12
	binutils-csl-sourcerygxx-4_1-9:1.12
	gdb-csl-sourcerygxx-4_1-8:1.12
	binutils-csl-sourcerygxx-4_1-8:1.12
	gdb-csl-sourcerygxx-4_1-7:1.12
	binutils-csl-sourcerygxx-4_1-7:1.12
	gdb-csl-arm-2006q1-6:1.12
	binutils-csl-arm-2006q1-6:1.12
	gdb-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-wrs-linux-3_4_4-22:1.7.82.1
	gdb-csl-symbian-6_4_50_20060226-10:1.12
	gdb-csl-symbian-6_4_50_20060226-9:1.12
	gdb-csl-symbian-6_4_50_20060226-8:1.12
	gdb-csl-coldfire-4_1-11:1.12
	binutils-csl-coldfire-4_1-11:1.12
	gdb-csl-sourcerygxx-3_4_4-19:1.12
	binutils-csl-sourcerygxx-3_4_4-19:1.12
	gdb-csl-coldfire-4_1-10:1.12
	gdb_6_5-branch:1.12.0.28
	gdb_6_5-2006-05-14-branchpoint:1.12
	binutils-csl-coldfire-4_1-10:1.12
	gdb-csl-sourcerygxx-4_1-5:1.12
	binutils-csl-sourcerygxx-4_1-5:1.12
	nickrob-async-20060513-branch:1.12.0.26
	nickrob-async-20060513-branchpoint:1.12
	gdb-csl-sourcerygxx-4_1-4:1.12
	binutils-csl-sourcerygxx-4_1-4:1.12
	msnyder-reverse-20060502-branch:1.12.0.24
	msnyder-reverse-20060502-branchpoint:1.12
	binutils-csl-wrs-linux-3_4_4-21:1.7.82.1
	gdb-csl-morpho-4_1-4:1.12
	binutils-csl-morpho-4_1-4:1.12
	gdb-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-wrs-linux-3_4_4-20:1.7.82.1
	readline_5_1-import-branch:1.12.0.22
	readline_5_1-import-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.12
	binutils-2_17-branch:1.12.0.20
	binutils-2_17-branchpoint:1.12
	gdb-csl-symbian-20060226-branch:1.12.0.18
	gdb-csl-symbian-20060226-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.12
	msnyder-reverse-20060331-branch:1.12.0.16
	msnyder-reverse-20060331-branchpoint:1.12
	binutils-csl-2_17-branch:1.12.0.14
	binutils-csl-2_17-branchpoint:1.12
	gdb-csl-available-20060303-branch:1.12.0.12
	gdb-csl-available-20060303-branchpoint:1.12
	gdb-csl-20060226-branch:1.12.0.10
	gdb-csl-20060226-branchpoint:1.12
	gdb_6_4-20051202-release:1.12
	msnyder-fork-checkpoint-branch:1.12.0.8
	msnyder-fork-checkpoint-branchpoint:1.12
	gdb-csl-gxxpro-6_3-branch:1.12.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.12
	gdb_6_4-branch:1.12.0.4
	gdb_6_4-2005-11-01-branchpoint:1.12
	gdb-csl-arm-20051020-branch:1.12.0.2
	gdb-csl-arm-20051020-branchpoint:1.12
	binutils-csl-gxxpro-3_4-branch:1.7.82.1.0.4
	binutils-csl-gxxpro-3_4-branchpoint:1.7.82.1
	binutils-2_16_1:1.7.82.1
	msnyder-tracepoint-checkpoint-branch:1.11.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.11
	gdb-csl-arm-20050325-2005-q1b:1.9
	binutils-csl-arm-2005q1b:1.7.82.1
	binutils-2_16:1.7.82.1
	gdb-csl-arm-20050325-2005-q1a:1.9
	binutils-csl-arm-2005q1a:1.7.82.1
	csl-arm-20050325-branch:1.9.0.2
	csl-arm-20050325-branchpoint:1.9
	binutils-csl-arm-2005q1-branch:1.7.82.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.7.82.1
	binutils-2_16-branch:1.7.0.82
	binutils-2_16-branchpoint:1.7
	csl-arm-2004-q3d:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.78
	gdb_6_3-20041019-branchpoint:1.7
	csl-arm-2004-q3:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.80
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.76
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	binutils-2_15:1.7
	binutils-2_15-branchpoint:1.7
	csl-arm-2004-q1a:1.7
	csl-arm-2004-q1:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.74
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.72
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.70
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.68
	drow_intercu-20040221-branchpoint:1.7
	binutils-2_15-branch:1.7.0.66
	cagney_bfdfile-20040213-branch:1.7.0.64
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.62
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	csl-arm-2003-q4:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.7
	kettenis_sparc-20030918-branch:1.7.0.60
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.58
	cagney_x86i386-20030821-branch:1.7.0.56
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.54
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.52
	jimb-ppc64-linux-20030613-branchpoint:1.7
	binutils-2_14:1.7
	cagney_convert-20030606-branch:1.7.0.50
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.48
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.46
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.44
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.42
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	binutils-2_14-branch:1.7.0.40
	binutils-2_14-branchpoint:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.38
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.7.0.36
	kettenis_i386newframe-20030406-branchpoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.7
	cagney_frameaddr-20030403-branch:1.7.0.34
	cagney_framebase-20030330-mergepoint:1.7
	cagney_framebase-20030326-branch:1.7.0.32
	cagney_framebase-20030326-branchpoint:1.7
	cagney_lazyid-20030317-branch:1.7.0.30
	cagney_lazyid-20030317-branchpoint:1.7
	kettenis-i386newframe-20030316-mergepoint:1.7
	offbyone-20030313-branch:1.7.0.28
	offbyone-20030313-branchpoint:1.7
	kettenis-i386newframe-20030308-branch:1.7.0.26
	kettenis-i386newframe-20030308-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.7
	cagney_offbyone-20030303-branch:1.7.0.24
	cagney_offbyone-20030303-branchpoint:1.7
	carlton_dictionary-20030207-merge:1.7
	interps-20030202-branch:1.7.0.22
	interps-20030202-branchpoint:1.7
	cagney-unwind-20030108-branch:1.7.0.20
	cagney-unwind-20030108-branchpoint:1.7
	binutils-2_13_2_1:1.7
	binutils-2_13_2:1.7
	carlton_dictionary-20021223-merge:1.7
	gdb_5_3-2002-12-12-release:1.7
	carlton_dictionary-20021115-merge:1.7
	binutils-2_13_1:1.7
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.7.0.18
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	carlton_dictionary-branch:1.7.0.16
	carlton_dictionary-20020920-branchpoint:1.7
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.14
	gdb_5_3-branch:1.7.0.12
	gdb_5_3-2002-09-04-branchpoint:1.7
	kseitz_interps-20020829-merge:1.7
	cagney_sysregs-20020825-branch:1.7.0.10
	cagney_sysregs-20020825-branchpoint:1.7
	readline_4_3-import-branch:1.7.0.8
	readline_4_3-import-branchpoint:1.7
	binutils-2_13:1.7
	gdb_5_2_1-2002-07-23-release:1.6
	binutils-2_13-branchpoint:1.7
	binutils-2_13-branch:1.7.0.6
	kseitz_interps-20020528-branch:1.7.0.4
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.2
	cagney_regbuf-20020515-branchpoint:1.7
	binutils-2_12_1:1.6
	jimb-macro-020506-branch:1.6.0.6
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	binutils-2_12:1.6
	gdb_5_2-branch:1.6.0.4
	gdb_5_2-2002-03-03-branchpoint:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.2.4.2
	binutils-2_11_1:1.2.4.2
	binutils-2_11:1.2.4.1
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.4
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.1.1.1.2.1
	binutils-2_10:1.1.1.1.2.1
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.16
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2012.05.17.15.13.26;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.16.02.23.09;	author macro;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.01.11.16.33;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.07.07.34.31;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.29.16.13.43;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.14.09.35.26;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.09.13.08.26;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.09.23.11.30;	author thorpej;	state Exp;
branches
	1.7.82.1;
next	1.6;

1.6
date	2001.09.20.15.28.25;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.26.11.47.39;	author aj;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.19.12.20.10;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.13.22.58.37;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.7.82.1
date	2005.03.09.13.09.41;	author amodra;	state Exp;
branches;
next	;

1.2.4.1
date	2001.03.19.12.20.39;	author amodra;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.06.07.03.18.37;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.00;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;


desc
@@


1.16
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* Print VAX instructions.
   Copyright 1995, 1998, 2000, 2001, 2002, 2005, 2007, 2009, 2012
   Free Software Foundation, Inc.
   Contributed by Pauline Middelink <middelin@@polyware.iaf.nl>

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <setjmp.h>
#include <string.h>
#include "opcode/vax.h"
#include "dis-asm.h"

static char *reg_names[] =
{
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "ap", "fp", "sp", "pc"
};

/* Definitions for the function entry mask bits.  */
static char *entry_mask_bit[] =
{
  /* Registers 0 and 1 shall not be saved, since they're used to pass back
     a function's result to its caller...  */
  "~r0~", "~r1~",
  /* Registers 2 .. 11 are normal registers.  */
  "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11",
  /* Registers 12 and 13 are argument and frame pointer and must not
     be saved by using the entry mask.  */
  "~ap~", "~fp~",
  /* Bits 14 and 15 control integer and decimal overflow.  */
  "IntOvfl", "DecOvfl",
};

/* Sign-extend an (unsigned char). */
#define COERCE_SIGNED_CHAR(ch) ((signed char)(ch))

/* Get a 1 byte signed integer.  */
#define NEXTBYTE(p)  \
  (p += 1, FETCH_DATA (info, p), \
  COERCE_SIGNED_CHAR(p[-1]))

/* Get a 2 byte signed integer.  */
#define COERCE16(x) ((int) (((x) ^ 0x8000) - 0x8000))
#define NEXTWORD(p)  \
  (p += 2, FETCH_DATA (info, p), \
   COERCE16 ((p[-1] << 8) + p[-2]))

/* Get a 4 byte signed integer.  */
#define COERCE32(x) ((int) (((x) ^ 0x80000000) - 0x80000000))
#define NEXTLONG(p)  \
  (p += 4, FETCH_DATA (info, p), \
   (COERCE32 ((((((p[-1] << 8) + p[-2]) << 8) + p[-3]) << 8) + p[-4])))

/* Maximum length of an instruction.  */
#define MAXLEN 25

struct private
{
  /* Points to first byte not fetched.  */
  bfd_byte * max_fetched;
  bfd_byte   the_buffer[MAXLEN];
  bfd_vma    insn_start;
  jmp_buf    bailout;
};

/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)
   to ADDR (exclusive) are valid.  Returns 1 for success, longjmps
   on error.  */
#define FETCH_DATA(info, addr) \
  ((addr) <= ((struct private *)(info->private_data))->max_fetched \
   ? 1 : fetch_data ((info), (addr)))

static int
fetch_data (struct disassemble_info *info, bfd_byte *addr)
{
  int status;
  struct private *priv = (struct private *) info->private_data;
  bfd_vma start = priv->insn_start + (priv->max_fetched - priv->the_buffer);

  status = (*info->read_memory_func) (start,
				      priv->max_fetched,
				      addr - priv->max_fetched,
				      info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, start, info);
      longjmp (priv->bailout, 1);
    }
  else
    priv->max_fetched = addr;

  return 1;
}

/* Entry mask handling.  */
static unsigned int  entry_addr_occupied_slots = 0;
static unsigned int  entry_addr_total_slots = 0;
static bfd_vma *     entry_addr = NULL;

/* Parse the VAX specific disassembler options.  These contain function
   entry addresses, which can be useful to disassemble ROM images, since
   there's no symbol table.  Returns TRUE upon success, FALSE otherwise.  */

static bfd_boolean
parse_disassembler_options (char * options)
{
  const char * entry_switch = "entry:";

  while ((options = strstr (options, entry_switch)))
    {
      options += strlen (entry_switch);

      /* The greater-than part of the test below is paranoia.  */
      if (entry_addr_occupied_slots >= entry_addr_total_slots)
	{
	  /* A guesstimate of the number of entries we will have to create.  */
	  entry_addr_total_slots +=
	    strlen (options) / (strlen (entry_switch) + 5);
	  
	  entry_addr = realloc (entry_addr, sizeof (bfd_vma)
				* entry_addr_total_slots);
	}

      if (entry_addr == NULL)
	return FALSE;
	  
      entry_addr[entry_addr_occupied_slots] = bfd_scan_vma (options, NULL, 0);
      entry_addr_occupied_slots ++;
    }

  return TRUE;
}

#if 0 /* FIXME:  Ideally the disassembler should have target specific
	 initialisation and termination function pointers.  Then
	 parse_disassembler_options could be the init function and
	 free_entry_array (below) could be the termination routine.
	 Until then there is no way for the disassembler to tell us
	 that it has finished and that we no longer need the entry
	 array, so this routine is suppressed for now.  It does mean
	 that we leak memory, but only to the extent that we do not
	 free it just before the disassembler is about to terminate
	 anyway.  */

/* Free memory allocated to our entry array.  */

static void
free_entry_array (void)
{
  if (entry_addr)
    {
      free (entry_addr);
      entry_addr = NULL;
      entry_addr_occupied_slots = entry_addr_total_slots = 0;
    }
}
#endif
/* Check if the given address is a known function entry point.  This is
   the case if there is a symbol of the function type at this address.
   We also check for synthetic symbols as these are used for PLT entries
   (weak undefined symbols may not have the function type set).  Finally
   the address may have been forced to be treated as an entry point.  The
   latter helps in disassembling ROM images, because there's no symbol
   table at all.  Forced entry points can be given by supplying several
   -M options to objdump: -M entry:0xffbb7730.  */

static bfd_boolean
is_function_entry (struct disassemble_info *info, bfd_vma addr)
{
  unsigned int i;

  /* Check if there's a function or PLT symbol at our address.  */
  if (info->symbols
      && info->symbols[0]
      && (info->symbols[0]->flags & (BSF_FUNCTION | BSF_SYNTHETIC))
      && addr == bfd_asymbol_value (info->symbols[0]))
    return TRUE;

  /* Check for forced function entry address.  */
  for (i = entry_addr_occupied_slots; i--;)
    if (entry_addr[i] == addr)
      return TRUE;

  return FALSE;
}

/* Check if the given address is the last longword of a PLT entry.
   This longword is data and depending on the value it may interfere
   with disassembly of further PLT entries.  We make use of the fact
   PLT symbols are marked BSF_SYNTHETIC.  */
static bfd_boolean
is_plt_tail (struct disassemble_info *info, bfd_vma addr)
{
  if (info->symbols
      && info->symbols[0]
      && (info->symbols[0]->flags & BSF_SYNTHETIC)
      && addr == bfd_asymbol_value (info->symbols[0]) + 8)
    return TRUE;

  return FALSE;
}

static int
print_insn_mode (const char *d,
		 int size,
		 unsigned char *p0,
		 bfd_vma addr,	/* PC for this arg to be relative to.  */
		 disassemble_info *info)
{
  unsigned char *p = p0;
  unsigned char mode, reg;

  /* Fetch and interpret mode byte.  */
  mode = (unsigned char) NEXTBYTE (p);
  reg = mode & 0xF;
  switch (mode & 0xF0)
    {
    case 0x00:
    case 0x10:
    case 0x20:
    case 0x30: /* Literal mode			$number.  */
      if (d[1] == 'd' || d[1] == 'f' || d[1] == 'g' || d[1] == 'h')
	(*info->fprintf_func) (info->stream, "$0x%x [%c-float]", mode, d[1]);
      else
        (*info->fprintf_func) (info->stream, "$0x%x", mode);
      break;
    case 0x40: /* Index:			base-addr[Rn] */
      p += print_insn_mode (d, size, p0 + 1, addr + 1, info);
      (*info->fprintf_func) (info->stream, "[%s]", reg_names[reg]);
      break;
    case 0x50: /* Register:			Rn */
      (*info->fprintf_func) (info->stream, "%s", reg_names[reg]);
      break;
    case 0x60: /* Register deferred:		(Rn) */
      (*info->fprintf_func) (info->stream, "(%s)", reg_names[reg]);
      break;
    case 0x70: /* Autodecrement:		-(Rn) */
      (*info->fprintf_func) (info->stream, "-(%s)", reg_names[reg]);
      break;
    case 0x80: /* Autoincrement:		(Rn)+ */
      if (reg == 0xF)
	{	/* Immediate?  */
	  int i;

	  FETCH_DATA (info, p + size);
	  (*info->fprintf_func) (info->stream, "$0x");
	  if (d[1] == 'd' || d[1] == 'f' || d[1] == 'g' || d[1] == 'h')
	    {
	      int float_word;

	      float_word = p[0] | (p[1] << 8);
	      if ((d[1] == 'd' || d[1] == 'f')
		  && (float_word & 0xff80) == 0x8000)
		{
		  (*info->fprintf_func) (info->stream, "[invalid %c-float]",
					 d[1]);
		}
	      else
		{
	          for (i = 0; i < size; i++)
		    (*info->fprintf_func) (info->stream, "%02x",
		                           p[size - i - 1]);
	          (*info->fprintf_func) (info->stream, " [%c-float]", d[1]);
		}
	    }
	  else
	    {
	      for (i = 0; i < size; i++)
	        (*info->fprintf_func) (info->stream, "%02x", p[size - i - 1]);
	    }
	  p += size;
	}
      else
	(*info->fprintf_func) (info->stream, "(%s)+", reg_names[reg]);
      break;
    case 0x90: /* Autoincrement deferred:	@@(Rn)+ */
      if (reg == 0xF)
	(*info->fprintf_func) (info->stream, "*0x%x", NEXTLONG (p));
      else
	(*info->fprintf_func) (info->stream, "@@(%s)+", reg_names[reg]);
      break;
    case 0xB0: /* Displacement byte deferred:	*displ(Rn).  */
      (*info->fprintf_func) (info->stream, "*");
    case 0xA0: /* Displacement byte:		displ(Rn).  */
      if (reg == 0xF)
	(*info->print_address_func) (addr + 2 + NEXTBYTE (p), info);
      else
	(*info->fprintf_func) (info->stream, "0x%x(%s)", NEXTBYTE (p),
			       reg_names[reg]);
      break;
    case 0xD0: /* Displacement word deferred:	*displ(Rn).  */
      (*info->fprintf_func) (info->stream, "*");
    case 0xC0: /* Displacement word:		displ(Rn).  */
      if (reg == 0xF)
	(*info->print_address_func) (addr + 3 + NEXTWORD (p), info);
      else
	(*info->fprintf_func) (info->stream, "0x%x(%s)", NEXTWORD (p),
			       reg_names[reg]);
      break;
    case 0xF0: /* Displacement long deferred:	*displ(Rn).  */
      (*info->fprintf_func) (info->stream, "*");
    case 0xE0: /* Displacement long:		displ(Rn).  */
      if (reg == 0xF)
	(*info->print_address_func) (addr + 5 + NEXTLONG (p), info);
      else
	(*info->fprintf_func) (info->stream, "0x%x(%s)", NEXTLONG (p),
			       reg_names[reg]);
      break;
    }

  return p - p0;
}

/* Returns number of bytes "eaten" by the operand, or return -1 if an
   invalid operand was found, or -2 if an opcode tabel error was
   found. */

static int
print_insn_arg (const char *d,
		unsigned char *p0,
		bfd_vma addr,	/* PC for this arg to be relative to.  */
		disassemble_info *info)
{
  int arg_len;

  /* Check validity of addressing length.  */
  switch (d[1])
    {
    case 'b' : arg_len = 1;	break;
    case 'd' : arg_len = 8;	break;
    case 'f' : arg_len = 4;	break;
    case 'g' : arg_len = 8;	break;
    case 'h' : arg_len = 16;	break;
    case 'l' : arg_len = 4;	break;
    case 'o' : arg_len = 16;	break;
    case 'w' : arg_len = 2;	break;
    case 'q' : arg_len = 8;	break;
    default  : abort ();
    }

  /* Branches have no mode byte.  */
  if (d[0] == 'b')
    {
      unsigned char *p = p0;

      if (arg_len == 1)
	(*info->print_address_func) (addr + 1 + NEXTBYTE (p), info);
      else
	(*info->print_address_func) (addr + 2 + NEXTWORD (p), info);

      return p - p0;
    }

  return print_insn_mode (d, arg_len, p0, addr, info);
}

/* Print the vax instruction at address MEMADDR in debugged memory,
   on INFO->STREAM.  Returns length of the instruction, in bytes.  */

int
print_insn_vax (bfd_vma memaddr, disassemble_info *info)
{
  static bfd_boolean parsed_disassembler_options = FALSE;
  const struct vot *votp;
  const char *argp;
  unsigned char *arg;
  struct private priv;
  bfd_byte *buffer = priv.the_buffer;

  info->private_data = & priv;
  priv.max_fetched = priv.the_buffer;
  priv.insn_start = memaddr;

  if (! parsed_disassembler_options
      && info->disassembler_options != NULL)
    {
      parse_disassembler_options (info->disassembler_options);

      /* To avoid repeated parsing of these options.  */
      parsed_disassembler_options = TRUE;
    }

  if (setjmp (priv.bailout) != 0)
    /* Error return.  */
    return -1;

  argp = NULL;
  /* Check if the info buffer has more than one byte left since
     the last opcode might be a single byte with no argument data.  */
  if (info->buffer_length - (memaddr - info->buffer_vma) > 1)
    {
      FETCH_DATA (info, buffer + 2);
    }
  else
    {
      FETCH_DATA (info, buffer + 1);
      buffer[1] = 0;
    }

  /* Decode function entry mask.  */
  if (is_function_entry (info, memaddr))
    {
      int i = 0;
      int register_mask = buffer[1] << 8 | buffer[0];

      (*info->fprintf_func) (info->stream, ".word 0x%04x # Entry mask: <",
			     register_mask);

      for (i = 15; i >= 0; i--)
	if (register_mask & (1 << i))
          (*info->fprintf_func) (info->stream, " %s", entry_mask_bit[i]);

      (*info->fprintf_func) (info->stream, " >");

      return 2;
    }

  /* Decode PLT entry offset longword.  */
  if (is_plt_tail (info, memaddr))
    {
      int offset;

      FETCH_DATA (info, buffer + 4);
      offset = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
      (*info->fprintf_func) (info->stream, ".long 0x%08x", offset);

      return 4;
    }

  for (votp = &votstrs[0]; votp->name[0]; votp++)
    {
      vax_opcodeT opcode = votp->detail.code;

      /* 2 byte codes match 2 buffer pos. */
      if ((bfd_byte) opcode == buffer[0]
	  && (opcode >> 8 == 0 || opcode >> 8 == buffer[1]))
	{
	  argp = votp->detail.args;
	  break;
	}
    }
  if (argp == NULL)
    {
      /* Handle undefined instructions. */
      (*info->fprintf_func) (info->stream, ".word 0x%x",
			     (buffer[0] << 8) + buffer[1]);
      return 2;
    }

  /* Point at first byte of argument data, and at descriptor for first
     argument.  */
  arg = buffer + ((votp->detail.code >> 8) ? 2 : 1);

  /* Make sure we have it in mem */
  FETCH_DATA (info, arg);

  (*info->fprintf_func) (info->stream, "%s", votp->name);
  if (*argp)
    (*info->fprintf_func) (info->stream, " ");

  while (*argp)
    {
      arg += print_insn_arg (argp, arg, memaddr + arg - buffer, info);
      argp += 2;
      if (*argp)
	(*info->fprintf_func) (info->stream, ",");
    }

  return arg - buffer;
}

@


1.15
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000, 2001, 2002, 2005, 2007, 2009
d23 1
a25 1
#include "sysdep.h"
@


1.14
log
@bfd/
* elf32-vax.c (elf_vax_plt_sym_val): New function.
(elf_backend_plt_sym_val): Define.

opcodes/
* vax-dis.c (is_function_entry): Return success for synthetic
symbols too.
(is_plt_tail): New function.
(print_insn_vax): Decode PLT entry offset longword.
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000, 2001, 2002, 2005, 2007
@


1.13
log
@Change source files over to GPLv3.
@
text
@d174 8
a181 5
/* Check if the given address is a known function entry. Either there must
   be a symbol of function type at this address, or the address must be
   a forced entry point.  The later helps in disassembling ROM images, because
   there's no symbol table at all.  Forced entry points can be given by
   supplying several -M options to objdump: -M entry:0xffbb7730.  */
d188 1
a188 1
  /* Check if there's a BSF_FUNCTION symbol at our address.  */
d191 1
a191 1
      && (info->symbols[0]->flags & BSF_FUNCTION)
d203 16
d434 12
@


1.12
log
@Update function declarations to ISO C90 formatting
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000, 2001, 2002, 2005
d6 3
a8 1
   This program is free software; you can redistribute it and/or modify
d10 2
a11 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d13 4
a16 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.11
log
@Update the address and phone number of the FSF
@
text
@d18 2
a19 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a26 8
/* Local function prototypes */
static int fetch_data PARAMS ((struct disassemble_info *, bfd_byte *));
static int print_insn_arg
  PARAMS ((const char *, unsigned char *, bfd_vma, disassemble_info *));
static int print_insn_mode
  PARAMS ((const char *, int, unsigned char *, bfd_vma, disassemble_info *));


a48 1
#if __STDC__ == 1
a49 3
#else
#define COERCE_SIGNED_CHAR(ch) ((int)(((ch) ^ 0x80) & 0xFF) - 128)
#endif
d88 1
a88 3
fetch_data (info, addr)
     struct disassemble_info *info;
     bfd_byte *addr;
d198 154
d356 1
a356 3
print_insn_vax (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d365 1
a365 1
  info->private_data = (PTR) &priv;
d379 2
a380 4
    {
      /* Error return.  */
      return -1;
    }
d415 1
a415 1
      register vax_opcodeT opcode = votp->detail.code;
a454 155
/* Returns number of bytes "eaten" by the operand, or return -1 if an
   invalid operand was found, or -2 if an opcode tabel error was
   found. */

static int
print_insn_arg (d, p0, addr, info)
     const char *d;
     unsigned char *p0;
     bfd_vma addr;		/* PC for this arg to be relative to */
     disassemble_info *info;
{
  int arg_len;

  /* check validity of addressing length */
  switch (d[1])
    {
    case 'b' : arg_len = 1;	break;
    case 'd' : arg_len = 8;	break;
    case 'f' : arg_len = 4;	break;
    case 'g' : arg_len = 8;	break;
    case 'h' : arg_len = 16;	break;
    case 'l' : arg_len = 4;	break;
    case 'o' : arg_len = 16;	break;
    case 'w' : arg_len = 2;	break;
    case 'q' : arg_len = 8;	break;
    default  : abort();
    }

  /* branches have no mode byte */
  if (d[0] == 'b')
    {
      unsigned char *p = p0;

      if (arg_len == 1)
	(*info->print_address_func) (addr + 1 + NEXTBYTE (p), info);
      else
	(*info->print_address_func) (addr + 2 + NEXTWORD (p), info);

      return p - p0;
    }

  return print_insn_mode (d, arg_len, p0, addr, info);
}

static int
print_insn_mode (d, size, p0, addr, info)
     const char *d;
     int size;
     unsigned char *p0;
     bfd_vma addr;		/* PC for this arg to be relative to */
     disassemble_info *info;
{
  unsigned char *p = p0;
  unsigned char mode, reg;

  /* fetch and interpret mode byte */
  mode = (unsigned char) NEXTBYTE (p);
  reg = mode & 0xF;
  switch (mode & 0xF0)
    {
    case 0x00:
    case 0x10:
    case 0x20:
    case 0x30: /* literal mode			$number */
      if (d[1] == 'd' || d[1] == 'f' || d[1] == 'g' || d[1] == 'h')
	(*info->fprintf_func) (info->stream, "$0x%x [%c-float]", mode, d[1]);
      else
        (*info->fprintf_func) (info->stream, "$0x%x", mode);
      break;
    case 0x40: /* index:			base-addr[Rn] */
      p += print_insn_mode (d, size, p0 + 1, addr + 1, info);
      (*info->fprintf_func) (info->stream, "[%s]", reg_names[reg]);
      break;
    case 0x50: /* register:			Rn */
      (*info->fprintf_func) (info->stream, "%s", reg_names[reg]);
      break;
    case 0x60: /* register deferred:		(Rn) */
      (*info->fprintf_func) (info->stream, "(%s)", reg_names[reg]);
      break;
    case 0x70: /* autodecrement:		-(Rn) */
      (*info->fprintf_func) (info->stream, "-(%s)", reg_names[reg]);
      break;
    case 0x80: /* autoincrement:		(Rn)+ */
      if (reg == 0xF)
	{	/* immediate? */
	  int i;

	  FETCH_DATA (info, p + size);
	  (*info->fprintf_func) (info->stream, "$0x");
	  if (d[1] == 'd' || d[1] == 'f' || d[1] == 'g' || d[1] == 'h')
	    {
	      int float_word;

	      float_word = p[0] | (p[1] << 8);
	      if ((d[1] == 'd' || d[1] == 'f')
		  && (float_word & 0xff80) == 0x8000)
		{
		  (*info->fprintf_func) (info->stream, "[invalid %c-float]",
					 d[1]);
		}
	      else
		{
	          for (i = 0; i < size; i++)
		    (*info->fprintf_func) (info->stream, "%02x",
		                           p[size - i - 1]);
	          (*info->fprintf_func) (info->stream, " [%c-float]", d[1]);
		}
	    }
	  else
	    {
	      for (i = 0; i < size; i++)
	        (*info->fprintf_func) (info->stream, "%02x", p[size - i - 1]);
	    }
	  p += size;
	}
      else
	(*info->fprintf_func) (info->stream, "(%s)+", reg_names[reg]);
      break;
    case 0x90: /* autoincrement deferred:	@@(Rn)+ */
      if (reg == 0xF)
	(*info->fprintf_func) (info->stream, "*0x%x", NEXTLONG (p));
      else
	(*info->fprintf_func) (info->stream, "@@(%s)+", reg_names[reg]);
      break;
    case 0xB0: /* displacement byte deferred:	*displ(Rn) */
      (*info->fprintf_func) (info->stream, "*");
    case 0xA0: /* displacement byte:		displ(Rn) */
      if (reg == 0xF)
	(*info->print_address_func) (addr + 2 + NEXTBYTE (p), info);
      else
	(*info->fprintf_func) (info->stream, "0x%x(%s)", NEXTBYTE (p),
			       reg_names[reg]);
      break;
    case 0xD0: /* displacement word deferred:	*displ(Rn) */
      (*info->fprintf_func) (info->stream, "*");
    case 0xC0: /* displacement word:		displ(Rn) */
      if (reg == 0xF)
	(*info->print_address_func) (addr + 3 + NEXTWORD (p), info);
      else
	(*info->fprintf_func) (info->stream, "0x%x(%s)", NEXTWORD (p),
			       reg_names[reg]);
      break;
    case 0xF0: /* displacement long deferred:	*displ(Rn) */
      (*info->fprintf_func) (info->stream, "*");
    case 0xE0: /* displacement long:		displ(Rn) */
      if (reg == 0xF)
	(*info->print_address_func) (addr + 5 + NEXTLONG (p), info);
      else
	(*info->fprintf_func) (info->stream, "0x%x(%s)", NEXTLONG (p),
			       reg_names[reg]);
      break;
    }

  return p - p0;
}
@


1.10
log
@Add VAX specific disassembler option -Mentry: to specify a function entry
address, and add code to test this new option.
@
text
@d18 1
a18 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.9
log
@Use ".word 0x0012 # Entry mask: r1 r2 >" instead of just "Entry mask: < r1 ... >"
@
text
@d20 2
a81 2
#include <setjmp.h>

d85 4
a88 4
  bfd_byte *max_fetched;
  bfd_byte the_buffer[MAXLEN];
  bfd_vma insn_start;
  jmp_buf bailout;
d122 89
d219 1
d230 9
d259 1
a259 4
  if (info->symbols
      && info->symbols[0]
      && (info->symbols[0]->flags & BSF_FUNCTION)
      && memaddr == bfd_asymbol_value (info->symbols[0]))
@


1.8
log
@	* vax-dis.c (entry_mask_bit): New array.
	(print_insn_vax): Decode function entry mask.
@
text
@d6 13
a18 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d42 1
a42 1
     a function's result to it's caller...  */
d168 1
a168 1
      (*info->fprintf_func) (info->stream, "Entry mask 0x%04x = <",
@


1.7
log
@* vax-dis.c (print_insn_arg): Pass the insn info to print_insn_mode.
(print_insn_mode): Print some basic info about floating point values.
@
text
@d2 2
a3 1
   Copyright 1995, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
d38 15
d159 21
@


1.7.82.1
log
@	* vax-dis.c (entry_mask_bit): New array.
	(print_insn_vax): Decode function entry mask.
@
text
@d2 1
a2 2
   Copyright 1995, 1998, 2000, 2001, 2002, 2005
   Free Software Foundation, Inc.
a36 15
/* Definitions for the function entry mask bits.  */
static char *entry_mask_bit[] =
{
  /* Registers 0 and 1 shall not be saved, since they're used to pass back
     a function's result to it's caller...  */
  "~r0~", "~r1~",
  /* Registers 2 .. 11 are normal registers.  */
  "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11",
  /* Registers 12 and 13 are argument and frame pointer and must not
     be saved by using the entry mask.  */
  "~ap~", "~fp~",
  /* Bits 14 and 15 control integer and decimal overflow.  */
  "IntOvfl", "DecOvfl",
};

a142 21
  /* Decode function entry mask.  */
  if (info->symbols
      && info->symbols[0]
      && (info->symbols[0]->flags & BSF_FUNCTION)
      && memaddr == bfd_asymbol_value (info->symbols[0]))
    {
      int i = 0;
      int register_mask = buffer[1] << 8 | buffer[0];

      (*info->fprintf_func) (info->stream, "Entry mask 0x%04x = <",
			     register_mask);

      for (i = 15; i >= 0; i--)
	if (register_mask & (1 << i))
          (*info->fprintf_func) (info->stream, " %s", entry_mask_bit[i]);

      (*info->fprintf_func) (info->stream, " >");

      return 2;
    }

@


1.6
log
@Fix compile time warnings
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000, 2001 Free Software Foundation, Inc.
d28 1
a28 1
  PARAMS ((int, unsigned char *, bfd_vma, disassemble_info *));
d226 1
a226 1
  return print_insn_mode (arg_len, p0, addr, info);
d230 2
a231 1
print_insn_mode (size, p0, addr, info)
d249 4
a252 1
      (*info->fprintf_func) (info->stream, "$0x%x", mode);
d255 1
a255 1
      p += print_insn_mode (size, p0 + 1, addr + 1, info);
d274 24
a297 2
	  for (i = 0; i < size; i++)
	    (*info->fprintf_func) (info->stream, "%02x", p[size - i - 1]);
@


1.5
log
@For include/opcode:
	* d30v.h: Fix declaration of reg_name_cnt.

	* d10v.h: Fix declaration of d10v_reg_name_cnt.

	* arc.h: Add prototypes from opcodes/arc-opc.c.

For opcodes:
	* tic54x-dis.c: Add unused attributes where needed.

	* z8k-dis.c (output_instr): Add unused attribute.

	* h8300-dis.c: Add missing prototypes.
	(bfd_h8_disassemble): Make static.

	* cris-dis.c: Add missing prototype.
	* h8500-dis.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* z8k-dis.c: Likewise.

	* d10v-dis.c: Add missing prototype.
	(dis_long): Remove unused variable.
	(dis_2_short): Likewise.

	* sh-dis.c: Add missing prototypes.
	* v850-opc.c: Likewise.
	Add unused attributes where needed.

	* ns32k-dis.c: Add missing prototypes.
	(bit_extract_simple): Remove unused variable.
@
text
@d115 1
a115 1
  const char *argp = NULL;
d123 1
d130 1
@


1.4
log
@Don't try to read past end of info buffer, and correct test results.
@
text
@d24 5
a28 3
static int
print_insn_arg PARAMS ((const char *, unsigned char *, bfd_vma,
			disassemble_info *));
a29 2
static int
print_insn_mode PARAMS ((int, unsigned char *, bfd_vma, disassemble_info *));
@


1.3
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000 Free Software Foundation, Inc.
d129 12
a140 1
  FETCH_DATA (info, buffer + 2);
@


1.2
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1998 Free Software Foundation, Inc.
@


1.2.4.1
log
@Don't try to read past end of info buffer, and correct test results.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1998, 2001 Free Software Foundation, Inc.
d129 1
a129 12
  /* Check if the info buffer has more than one byte left since
     the last opcode might be a single byte with no argument data.  */
  if (info->buffer_length - (memaddr - info->buffer_vma) > 1)
    {
      FETCH_DATA (info, buffer + 2);
    }
  else
    {
      FETCH_DATA (info, buffer + 1);
      buffer[1] = 0;
    }

@


1.2.4.2
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1995, 1998, 2000, 2001 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d19 1
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@a18 1
#include "sysdep.h"
@


