head	1.15;
access;
symbols
	sid-snapshot-20180601:1.15
	sid-snapshot-20180501:1.15
	sid-snapshot-20180401:1.15
	sid-snapshot-20180301:1.15
	sid-snapshot-20180201:1.15
	sid-snapshot-20180101:1.15
	sid-snapshot-20171201:1.15
	sid-snapshot-20171101:1.15
	sid-snapshot-20171001:1.15
	sid-snapshot-20170901:1.15
	sid-snapshot-20170801:1.15
	sid-snapshot-20170701:1.15
	sid-snapshot-20170601:1.15
	sid-snapshot-20170501:1.15
	sid-snapshot-20170401:1.15
	sid-snapshot-20170301:1.15
	sid-snapshot-20170201:1.15
	sid-snapshot-20170101:1.15
	sid-snapshot-20161201:1.15
	sid-snapshot-20161101:1.15
	sid-snapshot-20160901:1.15
	sid-snapshot-20160801:1.15
	sid-snapshot-20160701:1.15
	sid-snapshot-20160601:1.15
	sid-snapshot-20160501:1.15
	sid-snapshot-20160401:1.15
	sid-snapshot-20160301:1.15
	sid-snapshot-20160201:1.15
	sid-snapshot-20160101:1.15
	sid-snapshot-20151201:1.15
	sid-snapshot-20151101:1.15
	sid-snapshot-20151001:1.15
	sid-snapshot-20150901:1.15
	sid-snapshot-20150801:1.15
	sid-snapshot-20150701:1.15
	sid-snapshot-20150601:1.15
	sid-snapshot-20150501:1.15
	sid-snapshot-20150401:1.15
	sid-snapshot-20150301:1.15
	sid-snapshot-20150201:1.15
	sid-snapshot-20150101:1.15
	sid-snapshot-20141201:1.15
	sid-snapshot-20141101:1.15
	sid-snapshot-20141001:1.15
	sid-snapshot-20140901:1.15
	sid-snapshot-20140801:1.15
	sid-snapshot-20140701:1.15
	sid-snapshot-20140601:1.15
	sid-snapshot-20140501:1.15
	sid-snapshot-20140401:1.15
	sid-snapshot-20140301:1.15
	sid-snapshot-20140201:1.15
	sid-snapshot-20140101:1.15
	sid-snapshot-20131201:1.15
	sid-snapshot-20131101:1.15
	sid-snapshot-20131001:1.15
	binutils-2_24-branch:1.15.0.8
	binutils-2_24-branchpoint:1.15
	binutils-2_21_1:1.14
	sid-snapshot-20130901:1.15
	gdb_7_6_1-2013-08-30-release:1.15
	sid-snapshot-20130801:1.15
	sid-snapshot-20130701:1.15
	sid-snapshot-20130601:1.15
	sid-snapshot-20130501:1.15
	gdb_7_6-2013-04-26-release:1.15
	sid-snapshot-20130401:1.15
	binutils-2_23_2:1.15
	gdb_7_6-branch:1.15.0.6
	gdb_7_6-2013-03-12-branchpoint:1.15
	sid-snapshot-20130301:1.15
	sid-snapshot-20130201:1.15
	sid-snapshot-20130101:1.15
	sid-snapshot-20121201:1.15
	gdb_7_5_1-2012-11-29-release:1.15
	binutils-2_23_1:1.15
	sid-snapshot-20121101:1.15
	binutils-2_23:1.15
	sid-snapshot-20121001:1.15
	sid-snapshot-20120901:1.15
	gdb_7_5-2012-08-17-release:1.15
	sid-snapshot-20120801:1.15
	binutils-2_23-branch:1.15.0.4
	binutils-2_23-branchpoint:1.15
	gdb_7_5-branch:1.15.0.2
	gdb_7_5-2012-07-18-branchpoint:1.15
	sid-snapshot-20120701:1.15
	sid-snapshot-20120601:1.15
	sid-snapshot-20120501:1.14
	binutils-2_22_branch:1.14.0.48
	gdb_7_4_1-2012-04-26-release:1.14
	sid-snapshot-20120401:1.14
	sid-snapshot-20120301:1.14
	sid-snapshot-20120201:1.14
	gdb_7_4-2012-01-24-release:1.14
	sid-snapshot-20120101:1.14
	gdb_7_4-branch:1.14.0.46
	gdb_7_4-2011-12-13-branchpoint:1.14
	sid-snapshot-20111201:1.14
	binutils-2_22:1.14
	sid-snapshot-20111101:1.14
	sid-snapshot-20111001:1.14
	binutils-2_22-branch:1.14.0.44
	binutils-2_22-branchpoint:1.14
	gdb_7_3_1-2011-09-04-release:1.14
	sid-snapshot-20110901:1.14
	sid-snapshot-20110801:1.14
	gdb_7_3-2011-07-26-release:1.14
	sid-snapshot-20110701:1.14
	sid-snapshot-20110601:1.14
	sid-snapshot-20110501:1.14
	gdb_7_3-branch:1.14.0.42
	gdb_7_3-2011-04-01-branchpoint:1.14
	sid-snapshot-20110401:1.14
	sid-snapshot-20110301:1.14
	sid-snapshot-20110201:1.14
	sid-snapshot-20110101:1.14
	binutils-2_21:1.14
	sid-snapshot-20101201:1.14
	binutils-2_21-branch:1.14.0.40
	binutils-2_21-branchpoint:1.14
	sid-snapshot-20101101:1.14
	sid-snapshot-20101001:1.14
	binutils-2_20_1:1.14
	gdb_7_2-2010-09-02-release:1.14
	sid-snapshot-20100901:1.14
	sid-snapshot-20100801:1.14
	gdb_7_2-branch:1.14.0.38
	gdb_7_2-2010-07-07-branchpoint:1.14
	sid-snapshot-20100701:1.14
	sid-snapshot-20100601:1.14
	sid-snapshot-20100501:1.14
	sid-snapshot-20100401:1.14
	gdb_7_1-2010-03-18-release:1.14
	sid-snapshot-20100301:1.14
	gdb_7_1-branch:1.14.0.36
	gdb_7_1-2010-02-18-branchpoint:1.14
	sid-snapshot-20100201:1.14
	sid-snapshot-20100101:1.14
	gdb_7_0_1-2009-12-22-release:1.14
	sid-snapshot-20091201:1.14
	sid-snapshot-20091101:1.14
	binutils-2_20:1.14
	gdb_7_0-2009-10-06-release:1.14
	sid-snapshot-20091001:1.14
	gdb_7_0-branch:1.14.0.34
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.14
	binutils-arc-20081103-branch:1.14.0.32
	binutils-arc-20081103-branchpoint:1.14
	binutils-2_20-branch:1.14.0.30
	binutils-2_20-branchpoint:1.14
	sid-snapshot-20090901:1.14
	sid-snapshot-20090801:1.14
	msnyder-checkpoint-072509-branch:1.14.0.28
	msnyder-checkpoint-072509-branchpoint:1.14
	sid-snapshot-20090701:1.14
	dje-cgen-play1-branch:1.14.0.26
	dje-cgen-play1-branchpoint:1.14
	sid-snapshot-20090601:1.14
	sid-snapshot-20090501:1.14
	sid-snapshot-20090401:1.14
	arc-20081103-branch:1.14.0.24
	arc-20081103-branchpoint:1.14
	arc-insight_6_8-branch:1.14.0.22
	arc-insight_6_8-branchpoint:1.14
	insight_6_8-branch:1.14.0.20
	insight_6_8-branchpoint:1.14
	sid-snapshot-20090301:1.14
	binutils-2_19_1:1.14
	sid-snapshot-20090201:1.14
	sid-snapshot-20090101:1.14
	reverse-20081226-branch:1.14.0.18
	reverse-20081226-branchpoint:1.14
	sid-snapshot-20081201:1.14
	multiprocess-20081120-branch:1.14.0.16
	multiprocess-20081120-branchpoint:1.14
	sid-snapshot-20081101:1.14
	binutils-2_19:1.14
	sid-snapshot-20081001:1.14
	reverse-20080930-branch:1.14.0.14
	reverse-20080930-branchpoint:1.14
	binutils-2_19-branch:1.14.0.12
	binutils-2_19-branchpoint:1.14
	sid-snapshot-20080901:1.14
	sid-snapshot-20080801:1.14
	reverse-20080717-branch:1.14.0.10
	reverse-20080717-branchpoint:1.14
	sid-snapshot-20080701:1.14
	msnyder-reverse-20080609-branch:1.14.0.8
	msnyder-reverse-20080609-branchpoint:1.14
	drow-reverse-20070409-branch:1.13.0.32
	drow-reverse-20070409-branchpoint:1.13
	sid-snapshot-20080601:1.14
	sid-snapshot-20080501:1.14
	sid-snapshot-20080403:1.14
	sid-snapshot-20080401:1.14
	gdb_6_8-2008-03-27-release:1.14
	sid-snapshot-20080301:1.14
	gdb_6_8-branch:1.14.0.6
	gdb_6_8-2008-02-26-branchpoint:1.14
	sid-snapshot-20080201:1.14
	sid-snapshot-20080101:1.14
	sid-snapshot-20071201:1.14
	sid-snapshot-20071101:1.14
	gdb_6_7_1-2007-10-29-release:1.14
	gdb_6_7-2007-10-10-release:1.14
	sid-snapshot-20071001:1.14
	gdb_6_7-branch:1.14.0.4
	gdb_6_7-2007-09-07-branchpoint:1.14
	binutils-2_18:1.14
	binutils-2_18-branch:1.14.0.2
	binutils-2_18-branchpoint:1.14
	insight_6_6-20070208-release:1.13
	binutils-csl-coldfire-4_1-32:1.13
	binutils-csl-sourcerygxx-4_1-32:1.13
	gdb_6_6-2006-12-18-release:1.13
	binutils-csl-innovasic-fido-3_4_4-33:1.13
	binutils-csl-sourcerygxx-3_4_4-32:1.10
	binutils-csl-coldfire-4_1-30:1.13
	binutils-csl-sourcerygxx-4_1-30:1.13
	binutils-csl-coldfire-4_1-28:1.13
	binutils-csl-sourcerygxx-4_1-29:1.13
	binutils-csl-sourcerygxx-4_1-28:1.13
	gdb_6_6-branch:1.13.0.30
	gdb_6_6-2006-11-15-branchpoint:1.13
	binutils-csl-arm-2006q3-27:1.13
	binutils-csl-sourcerygxx-4_1-27:1.13
	binutils-csl-arm-2006q3-26:1.13
	binutils-csl-sourcerygxx-4_1-26:1.13
	binutils-csl-sourcerygxx-4_1-25:1.13
	binutils-csl-sourcerygxx-4_1-24:1.13
	binutils-csl-sourcerygxx-4_1-23:1.13
	insight_6_5-20061003-release:1.13
	gdb-csl-symbian-6_4_50_20060226-12:1.13
	binutils-csl-sourcerygxx-4_1-21:1.13
	binutils-csl-arm-2006q3-21:1.13
	binutils-csl-sourcerygxx-4_1-22:1.13
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.13
	binutils-csl-sourcerygxx-4_1-20:1.13
	binutils-csl-arm-2006q3-19:1.13
	binutils-csl-sourcerygxx-4_1-19:1.13
	binutils-csl-sourcerygxx-4_1-18:1.13
	binutils-csl-renesas-4_1-9:1.13
	gdb-csl-sourcerygxx-3_4_4-25:1.13
	binutils-csl-sourcerygxx-3_4_4-25:1.10
	nickrob-async-20060828-mergepoint:1.13
	gdb-csl-symbian-6_4_50_20060226-11:1.13
	binutils-csl-renesas-4_1-8:1.13
	binutils-csl-renesas-4_1-7:1.13
	binutils-csl-renesas-4_1-6:1.13
	gdb-csl-sourcerygxx-4_1-17:1.13
	binutils-csl-sourcerygxx-4_1-17:1.13
	gdb-csl-20060226-branch-local-2:1.13
	gdb-csl-sourcerygxx-4_1-14:1.13
	binutils-csl-sourcerygxx-4_1-14:1.13
	binutils-csl-sourcerygxx-4_1-15:1.13
	gdb-csl-sourcerygxx-4_1-13:1.13
	binutils-csl-sourcerygxx-4_1-13:1.13
	binutils-2_17:1.13
	gdb-csl-sourcerygxx-4_1-12:1.13
	binutils-csl-sourcerygxx-4_1-12:1.13
	gdb-csl-sourcerygxx-3_4_4-21:1.13
	binutils-csl-sourcerygxx-3_4_4-21:1.13
	gdb_6_5-20060621-release:1.13
	binutils-csl-wrs-linux-3_4_4-24:1.10
	binutils-csl-wrs-linux-3_4_4-23:1.10
	gdb-csl-sourcerygxx-4_1-9:1.13
	binutils-csl-sourcerygxx-4_1-9:1.13
	gdb-csl-sourcerygxx-4_1-8:1.13
	binutils-csl-sourcerygxx-4_1-8:1.13
	gdb-csl-sourcerygxx-4_1-7:1.13
	binutils-csl-sourcerygxx-4_1-7:1.13
	gdb-csl-arm-2006q1-6:1.13
	binutils-csl-arm-2006q1-6:1.13
	gdb-csl-sourcerygxx-4_1-6:1.13
	binutils-csl-sourcerygxx-4_1-6:1.13
	binutils-csl-wrs-linux-3_4_4-22:1.10
	gdb-csl-symbian-6_4_50_20060226-10:1.13
	gdb-csl-symbian-6_4_50_20060226-9:1.13
	gdb-csl-symbian-6_4_50_20060226-8:1.13
	gdb-csl-coldfire-4_1-11:1.13
	binutils-csl-coldfire-4_1-11:1.13
	gdb-csl-sourcerygxx-3_4_4-19:1.13
	binutils-csl-sourcerygxx-3_4_4-19:1.13
	gdb-csl-coldfire-4_1-10:1.13
	gdb_6_5-branch:1.13.0.28
	gdb_6_5-2006-05-14-branchpoint:1.13
	binutils-csl-coldfire-4_1-10:1.13
	gdb-csl-sourcerygxx-4_1-5:1.13
	binutils-csl-sourcerygxx-4_1-5:1.13
	nickrob-async-20060513-branch:1.13.0.26
	nickrob-async-20060513-branchpoint:1.13
	gdb-csl-sourcerygxx-4_1-4:1.13
	binutils-csl-sourcerygxx-4_1-4:1.13
	msnyder-reverse-20060502-branch:1.13.0.24
	msnyder-reverse-20060502-branchpoint:1.13
	binutils-csl-wrs-linux-3_4_4-21:1.10
	gdb-csl-morpho-4_1-4:1.13
	binutils-csl-morpho-4_1-4:1.13
	gdb-csl-sourcerygxx-3_4_4-17:1.13
	binutils-csl-sourcerygxx-3_4_4-17:1.13
	binutils-csl-wrs-linux-3_4_4-20:1.10
	readline_5_1-import-branch:1.13.0.22
	readline_5_1-import-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.13
	binutils-2_17-branch:1.13.0.20
	binutils-2_17-branchpoint:1.13
	gdb-csl-symbian-20060226-branch:1.13.0.18
	gdb-csl-symbian-20060226-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.13
	msnyder-reverse-20060331-branch:1.13.0.16
	msnyder-reverse-20060331-branchpoint:1.13
	binutils-csl-2_17-branch:1.13.0.14
	binutils-csl-2_17-branchpoint:1.13
	gdb-csl-available-20060303-branch:1.13.0.12
	gdb-csl-available-20060303-branchpoint:1.13
	gdb-csl-20060226-branch:1.13.0.10
	gdb-csl-20060226-branchpoint:1.13
	gdb_6_4-20051202-release:1.13
	msnyder-fork-checkpoint-branch:1.13.0.8
	msnyder-fork-checkpoint-branchpoint:1.13
	gdb-csl-gxxpro-6_3-branch:1.13.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.13
	gdb_6_4-branch:1.13.0.4
	gdb_6_4-2005-11-01-branchpoint:1.13
	gdb-csl-arm-20051020-branch:1.13.0.2
	gdb-csl-arm-20051020-branchpoint:1.13
	binutils-csl-gxxpro-3_4-branch:1.10.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.10
	binutils-2_16_1:1.10
	msnyder-tracepoint-checkpoint-branch:1.11.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.11
	gdb-csl-arm-20050325-2005-q1b:1.10
	binutils-csl-arm-2005q1b:1.10
	binutils-2_16:1.10
	gdb-csl-arm-20050325-2005-q1a:1.10
	binutils-csl-arm-2005q1a:1.10
	csl-arm-20050325-branch:1.10.0.6
	csl-arm-20050325-branchpoint:1.10
	binutils-csl-arm-2005q1-branch:1.10.0.4
	binutils-csl-arm-2005q1-branchpoint:1.10
	binutils-2_16-branch:1.10.0.2
	binutils-2_16-branchpoint:1.10
	csl-arm-2004-q3d:1.9
	gdb_6_3-20041109-release:1.9
	gdb_6_3-branch:1.9.0.24
	gdb_6_3-20041019-branchpoint:1.9
	csl-arm-2004-q3:1.9
	drow_intercu-merge-20040921:1.9
	drow_intercu-merge-20040915:1.9
	jimb-gdb_6_2-e500-branch:1.9.0.26
	jimb-gdb_6_2-e500-branchpoint:1.9
	gdb_6_2-20040730-release:1.9
	gdb_6_2-branch:1.9.0.22
	gdb_6_2-2004-07-10-gmt-branchpoint:1.9
	gdb_6_1_1-20040616-release:1.9
	binutils-2_15:1.9
	binutils-2_15-branchpoint:1.9
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	gdb_6_1-2004-04-05-release:1.9
	drow_intercu-merge-20040402:1.9
	drow_intercu-merge-20040327:1.9
	ezannoni_pie-20040323-branch:1.9.0.20
	ezannoni_pie-20040323-branchpoint:1.9
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.9.0.18
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.9.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	drow_intercu-20040221-branch:1.9.0.14
	drow_intercu-20040221-branchpoint:1.9
	binutils-2_15-branch:1.9.0.12
	cagney_bfdfile-20040213-branch:1.9.0.10
	cagney_bfdfile-20040213-branchpoint:1.9
	drow-cplus-merge-20040208:1.9
	carlton_dictionary-20040126-merge:1.9
	cagney_bigcore-20040122-branch:1.9.0.8
	cagney_bigcore-20040122-branchpoint:1.9
	drow-cplus-merge-20040113:1.9
	csl-arm-2003-q4:1.9
	drow-cplus-merge-20031224:1.9
	drow-cplus-merge-20031220:1.9
	carlton_dictionary-20031215-merge:1.9
	drow-cplus-merge-20031214:1.9
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.9.0.6
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.4
	cagney_x86i386-20030821-branch:1.9.0.2
	cagney_x86i386-20030821-branchpoint:1.9
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.66
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.64
	jimb-ppc64-linux-20030613-branchpoint:1.8
	binutils-2_14:1.8
	cagney_convert-20030606-branch:1.8.0.62
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.60
	cagney_writestrings-20030508-branchpoint:1.8
	jimb-ppc64-linux-20030528-branch:1.8.0.58
	jimb-ppc64-linux-20030528-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.56
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.8.0.54
	jimb-ppc64-linux-20030509-branchpoint:1.8
	kettenis_i386newframe-20030504-mergepoint:1.8
	carlton_dictionary-20030430-merge:1.8
	binutils-2_14-branch:1.8.0.52
	binutils-2_14-branchpoint:1.8
	kettenis_i386newframe-20030419-branch:1.8.0.50
	kettenis_i386newframe-20030419-branchpoint:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.48
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.46
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.44
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.42
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.40
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.38
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.36
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.8
	interps-20030202-branch:1.8.0.34
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.8.0.32
	cagney-unwind-20030108-branchpoint:1.8
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	binutils-2_13_1:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.30
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.28
	carlton_dictionary-20020920-branchpoint:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.26
	gdb_5_3-branch:1.8.0.24
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.22
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.20
	readline_4_3-import-branchpoint:1.8
	binutils-2_13:1.8
	gdb_5_2_1-2002-07-23-release:1.8
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.18
	kseitz_interps-20020528-branch:1.8.0.16
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.14
	cagney_regbuf-20020515-branchpoint:1.8
	binutils-2_12_1:1.8
	jimb-macro-020506-branch:1.8.0.12
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.8
	binutils-2_12:1.8
	gdb_5_2-branch:1.8.0.10
	gdb_5_2-2002-03-03-branchpoint:1.8
	binutils-2_12-branch:1.8.0.8
	binutils-2_12-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.4
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.2
	gdb_5_1-2001-07-29-branchpoint:1.8
	binutils-2_11_2:1.6.4.1
	binutils-2_11_1:1.6.4.1
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.4
	insight-precleanup-2001-01-01:1.6
	binutils-2_10_1:1.2.2.2
	binutils-2_10:1.2.2.2
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.15
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.05.09.49.01;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.07.19.27.51;	author wilson;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.01.11.16.32;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.07.07.34.29;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.03.11.49.49;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.10.02.53.27;	author aoliva;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.24.04.10.19;	author kazu;	state Exp;
branches
	1.8.28.1
	1.8.30.1;
next	1.7;

1.7
date	2001.03.13.22.58.36;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.30.18.35.33;	author nickc;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2000.05.26.01.54.33;	author aoliva;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.20.22.15.32;	author aoliva;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.12.01.10.36.22;	author law;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.8.28.1
date	2003.08.05.17.13.30;	author carlton;	state Exp;
branches;
next	;

1.8.30.1
date	2003.12.14.20.28.07;	author drow;	state Exp;
branches;
next	;

1.6.4.1
date	2001.06.07.03.18.35;	author amodra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.04.20.22.16.12;	author aoliva;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches;
next	;


desc
@@


1.15
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* Disassemble MN10300 instructions.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005, 2007, 2012
   Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdio.h>
#include "opcode/mn10300.h"
#include "dis-asm.h"
#include "opintl.h"

#define HAVE_AM33_2 (info->mach == AM33_2)
#define HAVE_AM33   (info->mach == AM33 || HAVE_AM33_2)
#define HAVE_AM30   (info->mach == AM30)

static void
disassemble (bfd_vma memaddr,
	     struct disassemble_info *info,
	     unsigned long insn,
	     unsigned int size)
{
  struct mn10300_opcode *op = (struct mn10300_opcode *) mn10300_opcodes;
  const struct mn10300_operand *operand;
  bfd_byte buffer[4];
  unsigned long extension = 0;
  int status, match = 0;

  /* Find the opcode.  */
  while (op->name)
    {
      int mysize, extra_shift;

      if (op->format == FMT_S0)
	mysize = 1;
      else if (op->format == FMT_S1
	       || op->format == FMT_D0)
	mysize = 2;
      else if (op->format == FMT_S2
	       || op->format == FMT_D1)
	mysize = 3;
      else if (op->format == FMT_S4)
	mysize = 5;
      else if (op->format == FMT_D2)
	mysize = 4;
      else if (op->format == FMT_D3)
	mysize = 5;
      else if (op->format == FMT_D4)
	mysize = 6;
      else if (op->format == FMT_D6)
	mysize = 3;
      else if (op->format == FMT_D7 || op->format == FMT_D10)
	mysize = 4;
      else if (op->format == FMT_D8)
	mysize = 6;
      else if (op->format == FMT_D9)
	mysize = 7;
      else
	mysize = 7;

      if ((op->mask & insn) == op->opcode
	  && size == (unsigned int) mysize
	  && (op->machine == 0
	      || (op->machine == AM33_2 && HAVE_AM33_2)
	      || (op->machine == AM33 && HAVE_AM33)
	      || (op->machine == AM30 && HAVE_AM30)))
	{
	  const unsigned char *opindex_ptr;
	  unsigned int nocomma;
	  int paren = 0;

	  if (op->format == FMT_D1 || op->format == FMT_S1)
	    extra_shift = 8;
	  else if (op->format == FMT_D2 || op->format == FMT_D4
		   || op->format == FMT_S2 || op->format == FMT_S4
		   || op->format == FMT_S6 || op->format == FMT_D5)
	    extra_shift = 16;
	  else if (op->format == FMT_D7
		   || op->format == FMT_D8
		   || op->format == FMT_D9)
	    extra_shift = 8;
	  else
	    extra_shift = 0;

	  if (size == 1 || size == 2)
	    extension = 0;

	  else if (size == 3
		   && (op->format == FMT_D1
		       || op->opcode == 0xdf0000
		       || op->opcode == 0xde0000))
	    extension = 0;

	  else if (size == 3
		   && op->format == FMT_D6)
	    extension = 0;

	  else if (size == 3)
	    {
	      insn &= 0xff0000;
	      status = (*info->read_memory_func) (memaddr + 1, buffer, 2, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}

	      insn |= bfd_getl16 (buffer);
	      extension = 0;
	    }
	  else if (size == 4
		   && (op->opcode == 0xfaf80000
		       || op->opcode == 0xfaf00000
		       || op->opcode == 0xfaf40000))
	    extension = 0;

	  else if (size == 4
		   && (op->format == FMT_D7
		       || op->format == FMT_D10))
	    extension = 0;

	  else if (size == 4)
	    {
	      insn &= 0xffff0000;
	      status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}

	      insn |= bfd_getl16 (buffer);
	      extension = 0;
	    }
	  else if (size == 5 && op->opcode == 0xdc000000)
	    {
	      unsigned long temp = 0;

	      status = (*info->read_memory_func) (memaddr + 1, buffer, 4, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      temp |= bfd_getl32 (buffer);

	      insn &= 0xff000000;
	      insn |= (temp & 0xffffff00) >> 8;
	      extension = temp & 0xff;
	    }
	  else if (size == 5 && op->format == FMT_D3)
	    {
	      status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      insn &= 0xffff0000;
	      insn |= bfd_getl16 (buffer);

	      status = (*info->read_memory_func) (memaddr + 4, buffer, 1, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      extension = *(unsigned char *) buffer;
	    }
	  else if (size == 5)
	    {
	      unsigned long temp = 0;

	      status = (*info->read_memory_func) (memaddr + 1, buffer, 2, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      temp |= bfd_getl16 (buffer);

	      insn &= 0xff0000ff;
	      insn |= temp << 8;

	      status = (*info->read_memory_func) (memaddr + 4, buffer, 1, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      extension = *(unsigned char *) buffer;
	    }
	  else if (size == 6 && op->format == FMT_D8)
	    {
	      insn &= 0xffffff00;
	      status = (*info->read_memory_func) (memaddr + 5, buffer, 1, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      insn |= *(unsigned char *) buffer;

	      status = (*info->read_memory_func) (memaddr + 3, buffer, 2, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      extension = bfd_getl16 (buffer);
	    }
	  else if (size == 6)
	    {
	      unsigned long temp = 0;

	      status = (*info->read_memory_func) (memaddr + 2, buffer, 4, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      temp |= bfd_getl32 (buffer);

	      insn &= 0xffff0000;
	      insn |= (temp >> 16) & 0xffff;
	      extension = temp & 0xffff;
	    }
	  else if (size == 7 && op->format == FMT_D9)
	    {
	      insn &= 0xffffff00;
	      status = (*info->read_memory_func) (memaddr + 3, buffer, 4, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      extension = bfd_getl32 (buffer);
	      insn |= (extension & 0xff000000) >> 24;
	      extension &= 0xffffff;
	    }
	  else if (size == 7 && op->opcode == 0xdd000000)
	    {
	      unsigned long temp = 0;

	      status = (*info->read_memory_func) (memaddr + 1, buffer, 4, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      temp |= bfd_getl32 (buffer);

	      insn &= 0xff000000;
	      insn |= (temp >> 8) & 0xffffff;
	      extension = (temp & 0xff) << 16;

	      status = (*info->read_memory_func) (memaddr + 5, buffer, 2, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      extension |= bfd_getb16 (buffer);
	    }
	  else if (size == 7)
	    {
	      unsigned long temp = 0;

	      status = (*info->read_memory_func) (memaddr + 2, buffer, 4, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      temp |= bfd_getl32 (buffer);

	      insn &= 0xffff0000;
	      insn |= (temp >> 16) & 0xffff;
	      extension = (temp & 0xffff) << 8;

	      status = (*info->read_memory_func) (memaddr + 6, buffer, 1, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      extension |= *(unsigned char *) buffer;
	    }

	  match = 1;
	  (*info->fprintf_func) (info->stream, "%s\t", op->name);

	  /* Now print the operands.  */
	  for (opindex_ptr = op->operands, nocomma = 1;
	       *opindex_ptr != 0;
	       opindex_ptr++)
	    {
	      unsigned long value;

	      operand = &mn10300_operands[*opindex_ptr];

	      /* If this operand is a PLUS (autoincrement), then do not emit
		 a comma before emitting the plus.  */
	      if ((operand->flags & MN10300_OPERAND_PLUS) != 0)
		nocomma = 1;

	      if ((operand->flags & MN10300_OPERAND_SPLIT) != 0)
		{
		  unsigned long temp;

		  value = insn & ((1 << operand->bits) - 1);
		  value <<= (32 - operand->bits);
		  temp = extension >> operand->shift;
		  temp &= ((1 << (32 - operand->bits)) - 1);
		  value |= temp;
		  value = ((value ^ (((unsigned long) 1) << 31))
			   - (((unsigned long) 1) << 31));
		}
	      else if ((operand->flags & MN10300_OPERAND_24BIT) != 0)
		{
		  unsigned long temp;

		  value = insn & ((1 << operand->bits) - 1);
		  value <<= (24 - operand->bits);
		  temp = extension >> operand->shift;
		  temp &= ((1 << (24 - operand->bits)) - 1);
		  value |= temp;
		  if ((operand->flags & MN10300_OPERAND_SIGNED) != 0)
		    value = ((value & 0xffffff) ^ 0x800000) - 0x800000;
		}
	      else if ((operand->flags & (MN10300_OPERAND_FSREG
					  | MN10300_OPERAND_FDREG)))
		{
		  /* See m10300-opc.c just before #define FSM0 for an
		     explanation of these variables.  Note that
		     FMT-implied shifts are not taken into account for
		     FP registers.  */
		  unsigned long mask_low, mask_high;
		  int shl_low, shr_high, shl_high;

		  switch (operand->bits)
		    {
		    case 5:
		      /* Handle regular FP registers.  */
		      if (operand->shift >= 0)
			{
			  /* This is an `m' register.  */
			  shl_low = operand->shift;
			  shl_high = 8 + (8 & shl_low) + (shl_low & 4) / 4;
			}
		      else
			{
			  /* This is an `n' register.  */
			  shl_low = -operand->shift;
			  shl_high = shl_low / 4;
			}
		      mask_low = 0x0f;
		      mask_high = 0x10;
		      shr_high = 4;
		      break;

		    case 3:
		      /* Handle accumulators.  */
		      shl_low = -operand->shift;
		      shl_high = 0;
		      mask_low = 0x03;
		      mask_high = 0x04;
		      shr_high = 2;
		      break;

		    default:
		      abort ();
		    }
		  value = ((((insn >> shl_high) << shr_high) & mask_high)
			   | ((insn >> shl_low) & mask_low));
		}
	      else if ((operand->flags & MN10300_OPERAND_EXTENDED) != 0)
		value = ((extension >> (operand->shift))
			 & ((1 << operand->bits) - 1));

	      else
		value = ((insn >> (operand->shift))
			 & ((1 << operand->bits) - 1));

	      if ((operand->flags & MN10300_OPERAND_SIGNED) != 0
		  /* These are properly extended by the code above.  */
		  && ((operand->flags & MN10300_OPERAND_24BIT) == 0))
		value = ((value ^ (((unsigned long) 1) << (operand->bits - 1)))
			 - (((unsigned long) 1) << (operand->bits - 1)));

	      if (!nocomma
		  && (!paren
		      || ((operand->flags & MN10300_OPERAND_PAREN) == 0)))
		(*info->fprintf_func) (info->stream, ",");

	      nocomma = 0;

	      if ((operand->flags & MN10300_OPERAND_DREG) != 0)
		{
		  value = ((insn >> (operand->shift + extra_shift))
			   & ((1 << operand->bits) - 1));
		  (*info->fprintf_func) (info->stream, "d%d", (int) value);
		}

	      else if ((operand->flags & MN10300_OPERAND_AREG) != 0)
		{
		  value = ((insn >> (operand->shift + extra_shift))
			   & ((1 << operand->bits) - 1));
		  (*info->fprintf_func) (info->stream, "a%d", (int) value);
		}

	      else if ((operand->flags & MN10300_OPERAND_SP) != 0)
		(*info->fprintf_func) (info->stream, "sp");

	      else if ((operand->flags & MN10300_OPERAND_PSW) != 0)
		(*info->fprintf_func) (info->stream, "psw");

	      else if ((operand->flags & MN10300_OPERAND_MDR) != 0)
		(*info->fprintf_func) (info->stream, "mdr");

	      else if ((operand->flags & MN10300_OPERAND_RREG) != 0)
		{
		  value = ((insn >> (operand->shift + extra_shift))
			   & ((1 << operand->bits) - 1));
		  if (value < 8)
		    (*info->fprintf_func) (info->stream, "r%d", (int) value);
		  else if (value < 12)
		    (*info->fprintf_func) (info->stream, "a%d", (int) value - 8);
		  else
		    (*info->fprintf_func) (info->stream, "d%d", (int) value - 12);
		}

	      else if ((operand->flags & MN10300_OPERAND_XRREG) != 0)
		{
		  value = ((insn >> (operand->shift + extra_shift))
			   & ((1 << operand->bits) - 1));
		  if (value == 0)
		    (*info->fprintf_func) (info->stream, "sp");
		  else
		    (*info->fprintf_func) (info->stream, "xr%d", (int) value);
		}

	      else if ((operand->flags & MN10300_OPERAND_FSREG) != 0)
		(*info->fprintf_func) (info->stream, "fs%d", (int) value);

	      else if ((operand->flags & MN10300_OPERAND_FDREG) != 0)
		(*info->fprintf_func) (info->stream, "fd%d", (int) value);

	      else if ((operand->flags & MN10300_OPERAND_FPCR) != 0)
		(*info->fprintf_func) (info->stream, "fpcr");

	      else if ((operand->flags & MN10300_OPERAND_USP) != 0)
		(*info->fprintf_func) (info->stream, "usp");

	      else if ((operand->flags & MN10300_OPERAND_SSP) != 0)
		(*info->fprintf_func) (info->stream, "ssp");

	      else if ((operand->flags & MN10300_OPERAND_MSP) != 0)
		(*info->fprintf_func) (info->stream, "msp");

	      else if ((operand->flags & MN10300_OPERAND_PC) != 0)
		(*info->fprintf_func) (info->stream, "pc");

	      else if ((operand->flags & MN10300_OPERAND_EPSW) != 0)
		(*info->fprintf_func) (info->stream, "epsw");

	      else if ((operand->flags & MN10300_OPERAND_PLUS) != 0)
		(*info->fprintf_func) (info->stream, "+");

	      else if ((operand->flags & MN10300_OPERAND_PAREN) != 0)
		{
		  if (paren)
		    (*info->fprintf_func) (info->stream, ")");
		  else
		    {
		      (*info->fprintf_func) (info->stream, "(");
		      nocomma = 1;
		    }
		  paren = !paren;
		}

	      else if ((operand->flags & MN10300_OPERAND_PCREL) != 0)
		(*info->print_address_func) ((long) value + memaddr, info);

	      else if ((operand->flags & MN10300_OPERAND_MEMADDR) != 0)
		(*info->print_address_func) (value, info);

	      else if ((operand->flags & MN10300_OPERAND_REG_LIST) != 0)
		{
		  int comma = 0;

		  (*info->fprintf_func) (info->stream, "[");
		  if (value & 0x80)
		    {
		      (*info->fprintf_func) (info->stream, "d2");
		      comma = 1;
		    }

		  if (value & 0x40)
		    {
		      if (comma)
			(*info->fprintf_func) (info->stream, ",");
		      (*info->fprintf_func) (info->stream, "d3");
		      comma = 1;
		    }

		  if (value & 0x20)
		    {
		      if (comma)
			(*info->fprintf_func) (info->stream, ",");
		      (*info->fprintf_func) (info->stream, "a2");
		      comma = 1;
		    }

		  if (value & 0x10)
		    {
		      if (comma)
			(*info->fprintf_func) (info->stream, ",");
		      (*info->fprintf_func) (info->stream, "a3");
		      comma = 1;
		    }

		  if (value & 0x08)
		    {
		      if (comma)
			(*info->fprintf_func) (info->stream, ",");
		      (*info->fprintf_func) (info->stream, "other");
		      comma = 1;
		    }

		  if (value & 0x04)
		    {
		      if (comma)
			(*info->fprintf_func) (info->stream, ",");
		      (*info->fprintf_func) (info->stream, "exreg0");
		      comma = 1;
		    }
		  if (value & 0x02)
		    {
		      if (comma)
			(*info->fprintf_func) (info->stream, ",");
		      (*info->fprintf_func) (info->stream, "exreg1");
		      comma = 1;
		    }
		  if (value & 0x01)
		    {
		      if (comma)
			(*info->fprintf_func) (info->stream, ",");
		      (*info->fprintf_func) (info->stream, "exother");
		      comma = 1;
		    }
		  (*info->fprintf_func) (info->stream, "]");
		}

	      else
		(*info->fprintf_func) (info->stream, "%ld", (long) value);
	    }
	  /* All done. */
	  break;
	}
      op++;
    }

  if (!match)
    /* xgettext:c-format */
    (*info->fprintf_func) (info->stream, _("unknown\t0x%04lx"), insn);
}

int
print_insn_mn10300 (bfd_vma memaddr, struct disassemble_info *info)
{
  int status;
  bfd_byte buffer[4];
  unsigned long insn;
  unsigned int consume;

  /* First figure out how big the opcode is.  */
  status = (*info->read_memory_func) (memaddr, buffer, 1, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }
  insn = *(unsigned char *) buffer;

  /* These are one byte insns.  */
  if ((insn & 0xf3) == 0x00
      || (insn & 0xf0) == 0x10
      || (insn & 0xfc) == 0x3c
      || (insn & 0xf3) == 0x41
      || (insn & 0xf3) == 0x40
      || (insn & 0xfc) == 0x50
      || (insn & 0xfc) == 0x54
      || (insn & 0xf0) == 0x60
      || (insn & 0xf0) == 0x70
      || ((insn & 0xf0) == 0x80
	  && (insn & 0x0c) >> 2 != (insn & 0x03))
      || ((insn & 0xf0) == 0x90
	  && (insn & 0x0c) >> 2 != (insn & 0x03))
      || ((insn & 0xf0) == 0xa0
	  && (insn & 0x0c) >> 2 != (insn & 0x03))
      || ((insn & 0xf0) == 0xb0
	  && (insn & 0x0c) >> 2 != (insn & 0x03))
      || (insn & 0xff) == 0xcb
      || (insn & 0xfc) == 0xd0
      || (insn & 0xfc) == 0xd4
      || (insn & 0xfc) == 0xd8
      || (insn & 0xf0) == 0xe0
      || (insn & 0xff) == 0xff)
    {
      consume = 1;
    }

  /* These are two byte insns.  */
  else if ((insn & 0xf0) == 0x80
	   || (insn & 0xf0) == 0x90
	   || (insn & 0xf0) == 0xa0
	   || (insn & 0xf0) == 0xb0
	   || (insn & 0xfc) == 0x20
	   || (insn & 0xfc) == 0x28
	   || (insn & 0xf3) == 0x43
	   || (insn & 0xf3) == 0x42
	   || (insn & 0xfc) == 0x58
	   || (insn & 0xfc) == 0x5c
	   || ((insn & 0xf0) == 0xc0
	       && (insn & 0xff) != 0xcb
	       && (insn & 0xff) != 0xcc
	       && (insn & 0xff) != 0xcd)
	   || (insn & 0xff) == 0xf0
	   || (insn & 0xff) == 0xf1
	   || (insn & 0xff) == 0xf2
	   || (insn & 0xff) == 0xf3
	   || (insn & 0xff) == 0xf4
	   || (insn & 0xff) == 0xf5
	   || (insn & 0xff) == 0xf6)
    {
      status = (*info->read_memory_func) (memaddr, buffer, 2, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      insn = bfd_getb16 (buffer);
      consume = 2;
    }

  /* These are three byte insns.  */
  else if ((insn & 0xff) == 0xf8
	   || (insn & 0xff) == 0xcc
	   || (insn & 0xff) == 0xf9
	   || (insn & 0xf3) == 0x01
	   || (insn & 0xf3) == 0x02
	   || (insn & 0xf3) == 0x03
	   || (insn & 0xfc) == 0x24
	   || (insn & 0xfc) == 0x2c
	   || (insn & 0xfc) == 0x30
	   || (insn & 0xfc) == 0x34
	   || (insn & 0xfc) == 0x38
	   || (insn & 0xff) == 0xde
	   || (insn & 0xff) == 0xdf
	   || (insn & 0xff) == 0xf9
	   || (insn & 0xff) == 0xcc)
    {
      status = (*info->read_memory_func) (memaddr, buffer, 2, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      insn = bfd_getb16 (buffer);
      insn <<= 8;
      status = (*info->read_memory_func) (memaddr + 2, buffer, 1, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      insn |= *(unsigned char *) buffer;
      consume = 3;
    }

  /* These are four byte insns.  */
  else if ((insn & 0xff) == 0xfa
	   || (insn & 0xff) == 0xf7
	   || (insn & 0xff) == 0xfb)
    {
      status = (*info->read_memory_func) (memaddr, buffer, 4, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      insn = bfd_getb32 (buffer);
      consume = 4;
    }

  /* These are five byte insns.  */
  else if ((insn & 0xff) == 0xcd
	   || (insn & 0xff) == 0xdc)
    {
      status = (*info->read_memory_func) (memaddr, buffer, 4, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      insn = bfd_getb32 (buffer);
      consume = 5;
    }

  /* These are six byte insns.  */
  else if ((insn & 0xff) == 0xfd
	   || (insn & 0xff) == 0xfc)
    {
      status = (*info->read_memory_func) (memaddr, buffer, 4, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}

      insn = bfd_getb32 (buffer);
      consume = 6;
    }

  /* Else its a seven byte insns (in theory).  */
  else
    {
      status = (*info->read_memory_func) (memaddr, buffer, 4, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}

      insn = bfd_getb32 (buffer);
      consume = 7;
      /* Handle the 5-byte extended instruction codes.  */
      if ((insn & 0xfff80000) == 0xfe800000)
	consume = 5;
    }

  disassemble (memaddr, info, insn, consume);

  return consume;
}
@


1.14
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005, 2007
d22 1
a23 2

#include "sysdep.h"
@


1.13
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005
d5 3
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.12
log
@Update function declarations to ISO C90 formatting
@
text
@d452 1
a452 1
		    (*info->fprintf_func) (info->stream, "sp", value);
d580 1
a580 1
    (*info->fprintf_func) (info->stream, _("unknown\t0x%04x"), insn);
@


1.11
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2003
d5 14
a18 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

a26 3
static void disassemble PARAMS ((bfd_vma, struct disassemble_info *,
				 unsigned long insn, unsigned int));

d28 2
a29 183
#define HAVE_AM33 (info->mach == AM33 || HAVE_AM33_2)
#define HAVE_AM30 (info->mach == AM30)

int
print_insn_mn10300 (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  int status;
  bfd_byte buffer[4];
  unsigned long insn;
  unsigned int consume;

  /* First figure out how big the opcode is.  */
  status = (*info->read_memory_func) (memaddr, buffer, 1, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }
  insn = *(unsigned char *) buffer;

  /* These are one byte insns.  */
  if ((insn & 0xf3) == 0x00
      || (insn & 0xf0) == 0x10
      || (insn & 0xfc) == 0x3c
      || (insn & 0xf3) == 0x41
      || (insn & 0xf3) == 0x40
      || (insn & 0xfc) == 0x50
      || (insn & 0xfc) == 0x54
      || (insn & 0xf0) == 0x60
      || (insn & 0xf0) == 0x70
      || ((insn & 0xf0) == 0x80
	  && (insn & 0x0c) >> 2 != (insn & 0x03))
      || ((insn & 0xf0) == 0x90
	  && (insn & 0x0c) >> 2 != (insn & 0x03))
      || ((insn & 0xf0) == 0xa0
	  && (insn & 0x0c) >> 2 != (insn & 0x03))
      || ((insn & 0xf0) == 0xb0
	  && (insn & 0x0c) >> 2 != (insn & 0x03))
      || (insn & 0xff) == 0xcb
      || (insn & 0xfc) == 0xd0
      || (insn & 0xfc) == 0xd4
      || (insn & 0xfc) == 0xd8
      || (insn & 0xf0) == 0xe0
      || (insn & 0xff) == 0xff)
    {
      consume = 1;
    }

  /* These are two byte insns.  */
  else if ((insn & 0xf0) == 0x80
	   || (insn & 0xf0) == 0x90
	   || (insn & 0xf0) == 0xa0
	   || (insn & 0xf0) == 0xb0
	   || (insn & 0xfc) == 0x20
	   || (insn & 0xfc) == 0x28
	   || (insn & 0xf3) == 0x43
	   || (insn & 0xf3) == 0x42
	   || (insn & 0xfc) == 0x58
	   || (insn & 0xfc) == 0x5c
	   || ((insn & 0xf0) == 0xc0
	       && (insn & 0xff) != 0xcb
	       && (insn & 0xff) != 0xcc
	       && (insn & 0xff) != 0xcd)
	   || (insn & 0xff) == 0xf0
	   || (insn & 0xff) == 0xf1
	   || (insn & 0xff) == 0xf2
	   || (insn & 0xff) == 0xf3
	   || (insn & 0xff) == 0xf4
	   || (insn & 0xff) == 0xf5
	   || (insn & 0xff) == 0xf6)
    {
      status = (*info->read_memory_func) (memaddr, buffer, 2, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      insn = bfd_getb16 (buffer);
      consume = 2;
    }

  /* These are three byte insns.  */
  else if ((insn & 0xff) == 0xf8
	   || (insn & 0xff) == 0xcc
	   || (insn & 0xff) == 0xf9
	   || (insn & 0xf3) == 0x01
	   || (insn & 0xf3) == 0x02
	   || (insn & 0xf3) == 0x03
	   || (insn & 0xfc) == 0x24
	   || (insn & 0xfc) == 0x2c
	   || (insn & 0xfc) == 0x30
	   || (insn & 0xfc) == 0x34
	   || (insn & 0xfc) == 0x38
	   || (insn & 0xff) == 0xde
	   || (insn & 0xff) == 0xdf
	   || (insn & 0xff) == 0xf9
	   || (insn & 0xff) == 0xcc)
    {
      status = (*info->read_memory_func) (memaddr, buffer, 2, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      insn = bfd_getb16 (buffer);
      insn <<= 8;
      status = (*info->read_memory_func) (memaddr + 2, buffer, 1, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      insn |= *(unsigned char *) buffer;
      consume = 3;
    }

  /* These are four byte insns.  */
  else if ((insn & 0xff) == 0xfa
	   || (insn & 0xff) == 0xf7
	   || (insn & 0xff) == 0xfb)
    {
      status = (*info->read_memory_func) (memaddr, buffer, 4, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      insn = bfd_getb32 (buffer);
      consume = 4;
    }

  /* These are five byte insns.  */
  else if ((insn & 0xff) == 0xcd
	   || (insn & 0xff) == 0xdc)
    {
      status = (*info->read_memory_func) (memaddr, buffer, 4, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}
      insn = bfd_getb32 (buffer);
      consume = 5;
    }

  /* These are six byte insns.  */
  else if ((insn & 0xff) == 0xfd
	   || (insn & 0xff) == 0xfc)
    {
      status = (*info->read_memory_func) (memaddr, buffer, 4, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}

      insn = bfd_getb32 (buffer);
      consume = 6;
    }

  /* Else its a seven byte insns (in theory).  */
  else
    {
      status = (*info->read_memory_func) (memaddr, buffer, 4, info);
      if (status != 0)
	{
	  (*info->memory_error_func) (status, memaddr, info);
	  return -1;
	}

      insn = bfd_getb32 (buffer);
      consume = 7;
      /* Handle the 5-byte extended instruction codes.  */
      if ((insn & 0xfff80000) == 0xfe800000)
	consume = 5;
    }

  disassemble (memaddr, info, insn, consume);

  return consume;
}
d32 4
a35 5
disassemble (memaddr, info, insn, size)
     bfd_vma memaddr;
     struct disassemble_info *info;
     unsigned long insn;
     unsigned int size;
d37 1
a37 1
  struct mn10300_opcode *op = (struct mn10300_opcode *)mn10300_opcodes;
d100 2
a101 3
	    {
	      extension = 0;
	    }
d106 2
a107 3
	    {
	      extension = 0;
	    }
d110 2
a111 3
	    {
	      extension = 0;
	    }
d129 2
a130 3
	    {
	      extension = 0;
	    }
d134 2
a135 3
	    {
	      extension = 0;
	    }
d152 1
d187 1
d229 1
d258 1
d282 1
d324 1
d336 1
d392 3
a394 4
		{
		  value = ((extension >> (operand->shift))
			   & ((1 << operand->bits) - 1));
		}
d396 2
a397 4
		{
		  value = ((insn >> (operand->shift))
			   & ((1 << operand->bits) - 1));
		}
d579 45
d625 1
a625 2
      /* xgettext:c-format */
      (*info->fprintf_func) (info->stream, _("unknown\t0x%04x"), insn);
d627 133
@


1.10
log
@update copyright dates
@
text
@d17 1
a17 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.9
log
@2000-05-25  Alexandre Oliva  <aoliva@@cygnus.com>
* m10300-dis.c (disassemble): Negate negative accumulator's shift.
2000-05-24  Alexandre Oliva  <aoliva@@cygnus.com>
* m10300-dis.c (disassemble, case FSREG, FDREG): Don't assume
32-bit longs when sign-extending operands.
2000-04-20  Alexandre Oliva  <aoliva@@cygnus.com>
* m10300-opc.c: Remove MN10300_OPERAND_RELAX from all FSREGs.
* m10300-dis.c (HAVE_AM33_2): Define.
(disassemble): Use it.
(HAVE_AM33): Redefine.
(print_insn_mn10300): Fix mask for 5-byte extended insns.
2000-04-01  Alexandre Oliva  <aoliva@@cygnus.com>
* m10300-opc.c: Renamed AM332 to AM33_2.
2000-03-31  Alexandre Oliva  <aoliva@@cygnus.com>
* m10300-opc.c: Defined AM33 2.0 register operands.  Added support
for AM33 2.0 `imm8,(abs16)' addressing mode for btst, bset and
bclr.  Implemented `fbCC', `flCC', `dcpf' and all FP insns.
* m10300-dis.c (print_insn_mn10300): Recognize 5byte extended
insn code of AM33 2.0.
(disassemble): Recognize FMT_D3.  Print out FP register names.
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.8
log
@	* alpha-dis.c: Fix formatting.
	* cris-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
@
text
@d29 2
a30 1
#define HAVE_AM33 (info->mach == AM33)
d204 3
d244 2
d262 1
d353 19
d527 46
d641 9
@


1.8.30.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d29 1
a29 2
#define HAVE_AM33_2 (info->mach == AM33_2)
#define HAVE_AM33 (info->mach == AM33 || HAVE_AM33_2)
a202 3
      /* Handle the 5-byte extended instruction codes.  */
      if ((insn & 0xfff80000) == 0xfe800000)
	consume = 5;
a239 2
      else if (op->format == FMT_D3)
	mysize = 5;
a255 1
	      || (op->machine == AM33_2 && HAVE_AM33_2)
a345 19
	  else if (size == 5 && op->format == FMT_D3)
	    {
	      status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      insn &= 0xffff0000;
	      insn |= bfd_getl16 (buffer);

	      status = (*info->read_memory_func) (memaddr + 4, buffer, 1, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      extension = *(unsigned char *) buffer;
	    }
a500 46
	      else if ((operand->flags & (MN10300_OPERAND_FSREG
					  | MN10300_OPERAND_FDREG)))
		{
		  /* See m10300-opc.c just before #define FSM0 for an
		     explanation of these variables.  Note that
		     FMT-implied shifts are not taken into account for
		     FP registers.  */
		  unsigned long mask_low, mask_high;
		  int shl_low, shr_high, shl_high;

		  switch (operand->bits)
		    {
		    case 5:
		      /* Handle regular FP registers.  */
		      if (operand->shift >= 0)
			{
			  /* This is an `m' register.  */
			  shl_low = operand->shift;
			  shl_high = 8 + (8 & shl_low) + (shl_low & 4) / 4;
			}
		      else
			{
			  /* This is an `n' register.  */
			  shl_low = -operand->shift;
			  shl_high = shl_low / 4;
			}
		      mask_low = 0x0f;
		      mask_high = 0x10;
		      shr_high = 4;
		      break;

		    case 3:
		      /* Handle accumulators.  */
		      shl_low = -operand->shift;
		      shl_high = 0;
		      mask_low = 0x03;
		      mask_high = 0x04;
		      shr_high = 2;
		      break;

		    default:
		      abort ();
		    }
		  value = ((((insn >> shl_high) << shr_high) & mask_high)
			   | ((insn >> shl_low) & mask_low));
		}
a568 9

	      else if ((operand->flags & MN10300_OPERAND_FSREG) != 0)
		(*info->fprintf_func) (info->stream, "fs%d", (int) value);

	      else if ((operand->flags & MN10300_OPERAND_FDREG) != 0)
		(*info->fprintf_func) (info->stream, "fd%d", (int) value);

	      else if ((operand->flags & MN10300_OPERAND_FPCR) != 0)
		(*info->fprintf_func) (info->stream, "fpcr");
@


1.8.28.1
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d29 1
a29 2
#define HAVE_AM33_2 (info->mach == AM33_2)
#define HAVE_AM33 (info->mach == AM33 || HAVE_AM33_2)
a202 3
      /* Handle the 5-byte extended instruction codes.  */
      if ((insn & 0xfff80000) == 0xfe800000)
	consume = 5;
a239 2
      else if (op->format == FMT_D3)
	mysize = 5;
a255 1
	      || (op->machine == AM33_2 && HAVE_AM33_2)
a345 19
	  else if (size == 5 && op->format == FMT_D3)
	    {
	      status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      insn &= 0xffff0000;
	      insn |= bfd_getl16 (buffer);

	      status = (*info->read_memory_func) (memaddr + 4, buffer, 1, info);
	      if (status != 0)
		{
		  (*info->memory_error_func) (status, memaddr, info);
		  return;
		}
	      extension = *(unsigned char *) buffer;
	    }
a500 46
	      else if ((operand->flags & (MN10300_OPERAND_FSREG
					  | MN10300_OPERAND_FDREG)))
		{
		  /* See m10300-opc.c just before #define FSM0 for an
		     explanation of these variables.  Note that
		     FMT-implied shifts are not taken into account for
		     FP registers.  */
		  unsigned long mask_low, mask_high;
		  int shl_low, shr_high, shl_high;

		  switch (operand->bits)
		    {
		    case 5:
		      /* Handle regular FP registers.  */
		      if (operand->shift >= 0)
			{
			  /* This is an `m' register.  */
			  shl_low = operand->shift;
			  shl_high = 8 + (8 & shl_low) + (shl_low & 4) / 4;
			}
		      else
			{
			  /* This is an `n' register.  */
			  shl_low = -operand->shift;
			  shl_high = shl_low / 4;
			}
		      mask_low = 0x0f;
		      mask_high = 0x10;
		      shr_high = 4;
		      break;

		    case 3:
		      /* Handle accumulators.  */
		      shl_low = -operand->shift;
		      shl_high = 0;
		      mask_low = 0x03;
		      mask_high = 0x04;
		      shr_high = 2;
		      break;

		    default:
		      abort ();
		    }
		  value = ((((insn >> shl_high) << shr_high) & mask_high)
			   | ((insn >> shl_low) & mask_low));
		}
a568 9

	      else if ((operand->flags & MN10300_OPERAND_FSREG) != 0)
		(*info->fprintf_func) (info->stream, "fs%d", (int) value);

	      else if ((operand->flags & MN10300_OPERAND_FDREG) != 0)
		(*info->fprintf_func) (info->stream, "fd%d", (int) value);

	      else if ((operand->flags & MN10300_OPERAND_FPCR) != 0)
		(*info->fprintf_func) (info->stream, "fpcr");
@


1.7
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d22 1
a22 1
#include "opcode/mn10300.h" 
d32 1
a32 1
int 
d106 1
a106 1
	   return -1;
d114 1
a114 1
	   || (insn & 0xff) == 0xcc 
d143 1
a143 1
      insn |= *(unsigned char *)buffer;
d252 1
a252 1
	
d262 1
a262 1
	  
d366 1
a366 1
	      extension = *(unsigned char *)buffer;
d377 1
a377 1
	      insn |= *(unsigned char *)buffer;
d429 1
a429 1
	      
d452 1
a452 1
	      
d459 1
a459 1
	      extension |= *(unsigned char *)buffer;
d487 2
a488 2
		  value = ((value ^ (((unsigned long)1) << 31))
			   - (((unsigned long)1) << 31));
d515 2
a516 2
		value = ((value ^ (((unsigned long)1) << (operand->bits - 1)))
			 - (((unsigned long)1) << (operand->bits - 1)));
d524 1
a524 1
		
d529 1
a529 1
		  (*info->fprintf_func) (info->stream, "d%d", (int)value);
d536 1
a536 1
		  (*info->fprintf_func) (info->stream, "a%d", (int)value);
d553 1
a553 1
		    (*info->fprintf_func) (info->stream, "r%d", (int)value);
d555 1
a555 1
		    (*info->fprintf_func) (info->stream, "a%d", (int)value - 8);
d557 1
a557 1
		    (*info->fprintf_func) (info->stream, "d%d", (int)value - 12);
d567 1
a567 1
		  (*info->fprintf_func) (info->stream, "xr%d", (int)value);
d673 2
a674 2
	      else 
		(*info->fprintf_func) (info->stream, "%ld", (long)value);
@


1.6
log
@Replace defines with those from intl/libgettext.h to quieten gcc warnings.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
@


1.6.4.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.5
log
@* m10300-dis.c (disassemble): Don't assume 32-bit longs when
sign-extending operands.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
@


1.4
log
@* m10300-dis.c (HAVE_AM30, HAVE_AM33): Define.
(disassemble): Use them.
@
text
@d487 2
d499 1
a499 1
		    value = ((value & 0xffffff) ^ (~0x7fffff)) + 0x800000;
d513 4
a516 5
		   /* These are properly extended by the code above.  */
		   && ((operand->flags & MN10300_OPERAND_24BIT) == 0)
		  )
		value = ((long)(value << (32 - operand->bits))
			  >> (32 - operand->bits));
d529 1
a529 1
		  (*info->fprintf_func) (info->stream, "d%d", value);
d536 1
a536 1
		  (*info->fprintf_func) (info->stream, "a%d", value);
d553 1
a553 1
		    (*info->fprintf_func) (info->stream, "r%d", value);
d555 1
a555 1
		    (*info->fprintf_func) (info->stream, "a%d", value - 8);
d557 1
a557 1
		    (*info->fprintf_func) (info->stream, "d%d", value - 12);
d567 1
a567 1
		  (*info->fprintf_func) (info->stream, "xr%d", value);
d674 1
a674 1
		(*info->fprintf_func) (info->stream, "%d", value);
@


1.3
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d29 3
d256 2
a257 1
	      || op->machine == info->mach))
@


1.2
log
@        * m10300-opc.c, m10300-dis.c: Add am33 support.
@
text
@d21 1
a21 1
#include "ansidecl.h"
@


1.2.2.1
log
@* m10300-dis.c (HAVE_AM30, HAVE_AM33): Define.
(disassemble): Use them.
@
text
@a28 3
#define HAVE_AM33 (info->mach == AM33)
#define HAVE_AM30 (info->mach == AM30)

d253 1
a253 2
	      || (op->machine == AM33 && HAVE_AM33)
	      || (op->machine == AM30 && HAVE_AM30)))
@


1.2.2.2
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@d21 1
a21 1
#include "sysdep.h"
@


1.1
log
@Initial revision
@
text
@d123 1
d146 1
d239 8
d265 4
d283 5
d308 6
d364 19
d398 13
d470 4
d484 11
d507 2
d543 39
d644 21
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

