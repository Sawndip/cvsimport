head	1.18;
access;
symbols
	sid-snapshot-20180601:1.18
	sid-snapshot-20180501:1.18
	sid-snapshot-20180401:1.18
	sid-snapshot-20180301:1.18
	sid-snapshot-20180201:1.18
	sid-snapshot-20180101:1.18
	sid-snapshot-20171201:1.18
	sid-snapshot-20171101:1.18
	sid-snapshot-20171001:1.18
	sid-snapshot-20170901:1.18
	sid-snapshot-20170801:1.18
	sid-snapshot-20170701:1.18
	sid-snapshot-20170601:1.18
	sid-snapshot-20170501:1.18
	sid-snapshot-20170401:1.18
	sid-snapshot-20170301:1.18
	sid-snapshot-20170201:1.18
	sid-snapshot-20170101:1.18
	sid-snapshot-20161201:1.18
	sid-snapshot-20161101:1.18
	sid-snapshot-20160901:1.18
	sid-snapshot-20160801:1.18
	sid-snapshot-20160701:1.18
	sid-snapshot-20160601:1.18
	sid-snapshot-20160501:1.18
	sid-snapshot-20160401:1.18
	sid-snapshot-20160301:1.18
	sid-snapshot-20160201:1.18
	sid-snapshot-20160101:1.18
	sid-snapshot-20151201:1.18
	sid-snapshot-20151101:1.18
	sid-snapshot-20151001:1.18
	sid-snapshot-20150901:1.18
	sid-snapshot-20150801:1.18
	sid-snapshot-20150701:1.18
	sid-snapshot-20150601:1.18
	sid-snapshot-20150501:1.18
	sid-snapshot-20150401:1.18
	sid-snapshot-20150301:1.18
	sid-snapshot-20150201:1.18
	sid-snapshot-20150101:1.18
	sid-snapshot-20141201:1.18
	sid-snapshot-20141101:1.18
	sid-snapshot-20141001:1.18
	sid-snapshot-20140901:1.18
	sid-snapshot-20140801:1.18
	sid-snapshot-20140701:1.18
	sid-snapshot-20140601:1.18
	sid-snapshot-20140501:1.18
	sid-snapshot-20140401:1.18
	sid-snapshot-20140301:1.18
	sid-snapshot-20140201:1.18
	sid-snapshot-20140101:1.18
	sid-snapshot-20131201:1.18
	sid-snapshot-20131101:1.18
	sid-snapshot-20131001:1.18
	binutils-2_24-branch:1.18.0.8
	binutils-2_24-branchpoint:1.18
	binutils-2_21_1:1.16
	sid-snapshot-20130901:1.18
	gdb_7_6_1-2013-08-30-release:1.18
	sid-snapshot-20130801:1.18
	sid-snapshot-20130701:1.18
	sid-snapshot-20130601:1.18
	sid-snapshot-20130501:1.18
	gdb_7_6-2013-04-26-release:1.18
	sid-snapshot-20130401:1.18
	binutils-2_23_2:1.18
	gdb_7_6-branch:1.18.0.6
	gdb_7_6-2013-03-12-branchpoint:1.18
	sid-snapshot-20130301:1.18
	sid-snapshot-20130201:1.18
	sid-snapshot-20130101:1.18
	sid-snapshot-20121201:1.18
	gdb_7_5_1-2012-11-29-release:1.18
	binutils-2_23_1:1.18
	sid-snapshot-20121101:1.18
	binutils-2_23:1.18
	sid-snapshot-20121001:1.18
	sid-snapshot-20120901:1.18
	gdb_7_5-2012-08-17-release:1.18
	sid-snapshot-20120801:1.18
	binutils-2_23-branch:1.18.0.4
	binutils-2_23-branchpoint:1.18
	gdb_7_5-branch:1.18.0.2
	gdb_7_5-2012-07-18-branchpoint:1.18
	sid-snapshot-20120701:1.18
	sid-snapshot-20120601:1.18
	sid-snapshot-20120501:1.17
	binutils-2_22_branch:1.16.0.14
	gdb_7_4_1-2012-04-26-release:1.16
	sid-snapshot-20120401:1.17
	sid-snapshot-20120301:1.17
	sid-snapshot-20120201:1.16
	gdb_7_4-2012-01-24-release:1.16
	sid-snapshot-20120101:1.16
	gdb_7_4-branch:1.16.0.12
	gdb_7_4-2011-12-13-branchpoint:1.16
	sid-snapshot-20111201:1.16
	binutils-2_22:1.16
	sid-snapshot-20111101:1.16
	sid-snapshot-20111001:1.16
	binutils-2_22-branch:1.16.0.10
	binutils-2_22-branchpoint:1.16
	gdb_7_3_1-2011-09-04-release:1.16
	sid-snapshot-20110901:1.16
	sid-snapshot-20110801:1.16
	gdb_7_3-2011-07-26-release:1.16
	sid-snapshot-20110701:1.16
	sid-snapshot-20110601:1.16
	sid-snapshot-20110501:1.16
	gdb_7_3-branch:1.16.0.8
	gdb_7_3-2011-04-01-branchpoint:1.16
	sid-snapshot-20110401:1.16
	sid-snapshot-20110301:1.16
	sid-snapshot-20110201:1.16
	sid-snapshot-20110101:1.16
	binutils-2_21:1.16
	sid-snapshot-20101201:1.16
	binutils-2_21-branch:1.16.0.6
	binutils-2_21-branchpoint:1.16
	sid-snapshot-20101101:1.16
	sid-snapshot-20101001:1.16
	binutils-2_20_1:1.14.2.1
	gdb_7_2-2010-09-02-release:1.16
	sid-snapshot-20100901:1.16
	sid-snapshot-20100801:1.16
	gdb_7_2-branch:1.16.0.4
	gdb_7_2-2010-07-07-branchpoint:1.16
	sid-snapshot-20100701:1.16
	sid-snapshot-20100601:1.16
	sid-snapshot-20100501:1.16
	sid-snapshot-20100401:1.16
	gdb_7_1-2010-03-18-release:1.16
	sid-snapshot-20100301:1.16
	gdb_7_1-branch:1.16.0.2
	gdb_7_1-2010-02-18-branchpoint:1.16
	sid-snapshot-20100201:1.16
	sid-snapshot-20100101:1.16
	gdb_7_0_1-2009-12-22-release:1.14
	sid-snapshot-20091201:1.15
	sid-snapshot-20091101:1.15
	binutils-2_20:1.14.2.1
	gdb_7_0-2009-10-06-release:1.14
	sid-snapshot-20091001:1.15
	gdb_7_0-branch:1.14.0.4
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.13
	binutils-arc-20081103-branch:1.13.0.30
	binutils-arc-20081103-branchpoint:1.13
	binutils-2_20-branch:1.14.0.2
	binutils-2_20-branchpoint:1.14
	sid-snapshot-20090901:1.13
	sid-snapshot-20090801:1.13
	msnyder-checkpoint-072509-branch:1.13.0.28
	msnyder-checkpoint-072509-branchpoint:1.13
	sid-snapshot-20090701:1.13
	dje-cgen-play1-branch:1.13.0.26
	dje-cgen-play1-branchpoint:1.13
	sid-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	arc-20081103-branch:1.13.0.24
	arc-20081103-branchpoint:1.13
	arc-insight_6_8-branch:1.13.0.22
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.20
	insight_6_8-branchpoint:1.13
	sid-snapshot-20090301:1.13
	binutils-2_19_1:1.13
	sid-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	reverse-20081226-branch:1.13.0.18
	reverse-20081226-branchpoint:1.13
	sid-snapshot-20081201:1.13
	multiprocess-20081120-branch:1.13.0.16
	multiprocess-20081120-branchpoint:1.13
	sid-snapshot-20081101:1.13
	binutils-2_19:1.13
	sid-snapshot-20081001:1.13
	reverse-20080930-branch:1.13.0.14
	reverse-20080930-branchpoint:1.13
	binutils-2_19-branch:1.13.0.12
	binutils-2_19-branchpoint:1.13
	sid-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	reverse-20080717-branch:1.13.0.10
	reverse-20080717-branchpoint:1.13
	sid-snapshot-20080701:1.13
	msnyder-reverse-20080609-branch:1.13.0.8
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.12.0.4
	drow-reverse-20070409-branchpoint:1.12
	sid-snapshot-20080601:1.13
	sid-snapshot-20080501:1.13
	sid-snapshot-20080403:1.13
	sid-snapshot-20080401:1.13
	gdb_6_8-2008-03-27-release:1.13
	sid-snapshot-20080301:1.13
	gdb_6_8-branch:1.13.0.6
	gdb_6_8-2008-02-26-branchpoint:1.13
	sid-snapshot-20080201:1.13
	sid-snapshot-20080101:1.13
	sid-snapshot-20071201:1.13
	sid-snapshot-20071101:1.13
	gdb_6_7_1-2007-10-29-release:1.13
	gdb_6_7-2007-10-10-release:1.13
	sid-snapshot-20071001:1.13
	gdb_6_7-branch:1.13.0.4
	gdb_6_7-2007-09-07-branchpoint:1.13
	binutils-2_18:1.13
	binutils-2_18-branch:1.13.0.2
	binutils-2_18-branchpoint:1.13
	insight_6_6-20070208-release:1.12
	binutils-csl-coldfire-4_1-32:1.11.14.1
	binutils-csl-sourcerygxx-4_1-32:1.11.14.1
	gdb_6_6-2006-12-18-release:1.12
	binutils-csl-innovasic-fido-3_4_4-33:1.11.14.1
	binutils-csl-sourcerygxx-3_4_4-32:1.9
	binutils-csl-coldfire-4_1-30:1.11.14.1
	binutils-csl-sourcerygxx-4_1-30:1.11.14.1
	binutils-csl-coldfire-4_1-28:1.11.14.1
	binutils-csl-sourcerygxx-4_1-29:1.11.14.1
	binutils-csl-sourcerygxx-4_1-28:1.11.14.1
	gdb_6_6-branch:1.12.0.2
	gdb_6_6-2006-11-15-branchpoint:1.12
	binutils-csl-arm-2006q3-27:1.11.14.1
	binutils-csl-sourcerygxx-4_1-27:1.11.14.1
	binutils-csl-arm-2006q3-26:1.11.14.1
	binutils-csl-sourcerygxx-4_1-26:1.11.14.1
	binutils-csl-sourcerygxx-4_1-25:1.11.14.1
	binutils-csl-sourcerygxx-4_1-24:1.11.14.1
	binutils-csl-sourcerygxx-4_1-23:1.11.14.1
	insight_6_5-20061003-release:1.11
	gdb-csl-symbian-6_4_50_20060226-12:1.11
	binutils-csl-sourcerygxx-4_1-21:1.11.14.1
	binutils-csl-arm-2006q3-21:1.11.14.1
	binutils-csl-sourcerygxx-4_1-22:1.11.14.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.11.14.1
	binutils-csl-sourcerygxx-4_1-20:1.11.14.1
	binutils-csl-arm-2006q3-19:1.11.14.1
	binutils-csl-sourcerygxx-4_1-19:1.11.14.1
	binutils-csl-sourcerygxx-4_1-18:1.11.14.1
	binutils-csl-renesas-4_1-9:1.11.14.1
	gdb-csl-sourcerygxx-3_4_4-25:1.11
	binutils-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.12
	gdb-csl-symbian-6_4_50_20060226-11:1.11
	binutils-csl-renesas-4_1-8:1.11
	binutils-csl-renesas-4_1-7:1.11
	binutils-csl-renesas-4_1-6:1.11
	gdb-csl-sourcerygxx-4_1-17:1.11
	binutils-csl-sourcerygxx-4_1-17:1.11
	gdb-csl-20060226-branch-local-2:1.11
	gdb-csl-sourcerygxx-4_1-14:1.11
	binutils-csl-sourcerygxx-4_1-14:1.11
	binutils-csl-sourcerygxx-4_1-15:1.11
	gdb-csl-sourcerygxx-4_1-13:1.11
	binutils-csl-sourcerygxx-4_1-13:1.11
	binutils-2_17:1.11.20.1
	gdb-csl-sourcerygxx-4_1-12:1.11
	binutils-csl-sourcerygxx-4_1-12:1.11
	gdb-csl-sourcerygxx-3_4_4-21:1.11
	binutils-csl-sourcerygxx-3_4_4-21:1.11
	gdb_6_5-20060621-release:1.11
	binutils-csl-wrs-linux-3_4_4-24:1.9
	binutils-csl-wrs-linux-3_4_4-23:1.9
	gdb-csl-sourcerygxx-4_1-9:1.11
	binutils-csl-sourcerygxx-4_1-9:1.11
	gdb-csl-sourcerygxx-4_1-8:1.11
	binutils-csl-sourcerygxx-4_1-8:1.11
	gdb-csl-sourcerygxx-4_1-7:1.11
	binutils-csl-sourcerygxx-4_1-7:1.11
	gdb-csl-arm-2006q1-6:1.11
	binutils-csl-arm-2006q1-6:1.11
	gdb-csl-sourcerygxx-4_1-6:1.11
	binutils-csl-sourcerygxx-4_1-6:1.11
	binutils-csl-wrs-linux-3_4_4-22:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.11
	gdb-csl-symbian-6_4_50_20060226-9:1.11
	gdb-csl-symbian-6_4_50_20060226-8:1.11
	gdb-csl-coldfire-4_1-11:1.11
	binutils-csl-coldfire-4_1-11:1.11
	gdb-csl-sourcerygxx-3_4_4-19:1.11
	binutils-csl-sourcerygxx-3_4_4-19:1.11
	gdb-csl-coldfire-4_1-10:1.11
	gdb_6_5-branch:1.11.0.28
	gdb_6_5-2006-05-14-branchpoint:1.11
	binutils-csl-coldfire-4_1-10:1.11
	gdb-csl-sourcerygxx-4_1-5:1.11
	binutils-csl-sourcerygxx-4_1-5:1.11
	nickrob-async-20060513-branch:1.11.0.26
	nickrob-async-20060513-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-4:1.11
	binutils-csl-sourcerygxx-4_1-4:1.11
	msnyder-reverse-20060502-branch:1.11.0.24
	msnyder-reverse-20060502-branchpoint:1.11
	binutils-csl-wrs-linux-3_4_4-21:1.9
	gdb-csl-morpho-4_1-4:1.11
	binutils-csl-morpho-4_1-4:1.11
	gdb-csl-sourcerygxx-3_4_4-17:1.11
	binutils-csl-sourcerygxx-3_4_4-17:1.11
	binutils-csl-wrs-linux-3_4_4-20:1.9
	readline_5_1-import-branch:1.11.0.22
	readline_5_1-import-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.11
	binutils-2_17-branch:1.11.0.20
	binutils-2_17-branchpoint:1.11
	gdb-csl-symbian-20060226-branch:1.11.0.18
	gdb-csl-symbian-20060226-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.11
	msnyder-reverse-20060331-branch:1.11.0.16
	msnyder-reverse-20060331-branchpoint:1.11
	binutils-csl-2_17-branch:1.11.0.14
	binutils-csl-2_17-branchpoint:1.11
	gdb-csl-available-20060303-branch:1.11.0.12
	gdb-csl-available-20060303-branchpoint:1.11
	gdb-csl-20060226-branch:1.11.0.10
	gdb-csl-20060226-branchpoint:1.11
	gdb_6_4-20051202-release:1.11
	msnyder-fork-checkpoint-branch:1.11.0.8
	msnyder-fork-checkpoint-branchpoint:1.11
	gdb-csl-gxxpro-6_3-branch:1.11.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.11
	gdb_6_4-branch:1.11.0.4
	gdb_6_4-2005-11-01-branchpoint:1.11
	gdb-csl-arm-20051020-branch:1.11.0.2
	gdb-csl-arm-20051020-branchpoint:1.11
	binutils-csl-gxxpro-3_4-branch:1.9.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.9
	binutils-2_16_1:1.9
	msnyder-tracepoint-checkpoint-branch:1.10.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb-csl-arm-20050325-2005-q1b:1.9
	binutils-csl-arm-2005q1b:1.9
	binutils-2_16:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	binutils-csl-arm-2005q1a:1.9
	csl-arm-20050325-branch:1.9.0.6
	csl-arm-20050325-branchpoint:1.9
	binutils-csl-arm-2005q1-branch:1.9.0.4
	binutils-csl-arm-2005q1-branchpoint:1.9
	binutils-2_16-branch:1.9.0.2
	binutils-2_16-branchpoint:1.9
	csl-arm-2004-q3d:1.3
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.2
	gdb_6_3-20041019-branchpoint:1.2
	csl-arm-2004-q3:1.1
	drow_intercu-merge-20040921:1.1
	drow_intercu-20040221-branch:1.1.0.4
	drow_intercu-merge-20040915:1.1
	jimb-gdb_6_2-e500-branch:1.1.0.6
	jimb-gdb_6_2-e500-branchpoint:1.1
	gdb_6_2-20040730-release:1.1
	gdb_6_2-branch:1.1.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1
	binutils_latest_snapshot:1.18;
locks; strict;
comment	@ * @;


1.18
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2012.02.27.06.37.39;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.11.13.42.16;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.01.08.19.55;	author swami;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.02.07.20.29;	author amodra;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.22.08.40.09;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.07.19.27.48;	author wilson;	state Exp;
branches
	1.11.14.1
	1.11.20.1;
next	1.10;

1.10
date	2005.05.07.07.34.27;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.03.11.49.48;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.24.13.38.01;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.23.11.53.31;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.05.12.26.49;	author tomerl;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.29.16.34.35;	author tomerl;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.05.10.59.57;	author tomerl;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.27.10.24.01;	author tomerl;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.07.14.18.16;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.07.17.28.53;	author nickc;	state Exp;
branches
	1.1.4.1;
next	;

1.14.2.1
date	2009.10.02.12.19.05;	author gingold;	state Exp;
branches;
next	;

1.11.14.1
date	2006.08.22.15.08.46;	author jsm28;	state Exp;
branches;
next	;

1.11.20.1
date	2006.05.22.14.53.41;	author drow;	state Exp;
branches;
next	;

1.1.4.1
date	2004.09.16.17.01.58;	author drow;	state Exp;
branches;
next	;


desc
@@


1.18
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* Disassembler code for CRX.
   Copyright 2004, 2005, 2006, 2007, 2012 Free Software Foundation, Inc.
   Contributed by Tomer Levi, NSC, Israel.
   Written by Tomer Levi.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "opcode/crx.h"

/* String to print when opcode was not matched.  */
#define ILLEGAL	"illegal"
  /* Escape to 16-bit immediate.  */
#define ESCAPE_16_BIT  0xE

/* Extract 'n_bits' from 'a' starting from offset 'offs'.  */
#define EXTRACT(a, offs, n_bits)	    \
  (n_bits == 32 ? (((a) >> (offs)) & 0xffffffffL)   \
  : (((a) >> (offs)) & ((1 << (n_bits)) -1)))

/* Set Bit Mask - a mask to set all bits starting from offset 'offs'.  */
#define SBM(offs)  ((((1 << (32 - offs)) -1) << (offs)))

typedef unsigned long dwordU;
typedef unsigned short wordU;

typedef struct
{
  dwordU val;
  int nbits;
} parameter;

/* Structure to hold valid 'cinv' instruction options.  */

typedef struct
  {
    /* Cinv printed string.  */
    char *str;
    /* Value corresponding to the string.  */
    unsigned int value;
  }
cinv_entry;

/* CRX 'cinv' options.  */
const cinv_entry crx_cinvs[] =
{
  {"[i]", 2}, {"[i,u]", 3}, {"[d]", 4}, {"[d,u]", 5}, 
  {"[d,i]", 6}, {"[d,i,u]", 7}, {"[b]", 8}, 
  {"[b,i]", 10}, {"[b,i,u]", 11}, {"[b,d]", 12}, 
  {"[b,d,u]", 13}, {"[b,d,i]", 14}, {"[b,d,i,u]", 15}
};

/* Enum to distinguish different registers argument types.  */
typedef enum REG_ARG_TYPE
  {
    /* General purpose register (r<N>).  */
    REG_ARG = 0,
    /* User register (u<N>).  */
    USER_REG_ARG,
    /* CO-Processor register (c<N>).  */
    COP_ARG,
    /* CO-Processor special register (cs<N>).  */
    COPS_ARG 
  }
REG_ARG_TYPE;

/* Number of valid 'cinv' instruction options.  */
int NUMCINVS = ((sizeof crx_cinvs)/(sizeof crx_cinvs[0]));
/* Current opcode table entry we're disassembling.  */
const inst *instruction;
/* Current instruction we're disassembling.  */
ins currInsn;
/* The current instruction is read into 3 consecutive words.  */
wordU words[3];
/* Contains all words in appropriate order.  */
ULONGLONG allWords;
/* Holds the current processed argument number.  */
int processing_argument_number;
/* Nonzero means a CST4 instruction.  */
int cst4flag;
/* Nonzero means the instruction's original size is
   incremented (escape sequence is used).  */
int size_changed;

static int get_number_of_operands (void);
static argtype getargtype     (operand_type);
static int getbits	      (operand_type);
static char *getregname	      (reg);
static char *getcopregname    (copreg, reg_type);
static char * getprocregname  (int);
static char *gettrapstring    (unsigned);
static char *getcinvstring    (unsigned);
static void getregliststring  (int, char *, enum REG_ARG_TYPE);
static wordU get_word_at_PC   (bfd_vma, struct disassemble_info *);
static void get_words_at_PC   (bfd_vma, struct disassemble_info *);
static unsigned long build_mask (void);
static int powerof2	      (int);
static int match_opcode	      (void);
static void make_instruction  (void);
static void print_arguments   (ins *, bfd_vma, struct disassemble_info *);
static void print_arg	      (argument *, bfd_vma, struct disassemble_info *);

/* Retrieve the number of operands for the current assembled instruction.  */

static int
get_number_of_operands (void)
{
  int i;

  for (i = 0; instruction->operands[i].op_type && i < MAX_OPERANDS; i++)
    ;

  return i;
}

/* Return the bit size for a given operand.  */

static int
getbits (operand_type op)
{
  if (op < MAX_OPRD)
    return crx_optab[op].bit_size;
  else
    return 0;
}

/* Return the argument type of a given operand.  */

static argtype
getargtype (operand_type op)
{
  if (op < MAX_OPRD)
    return crx_optab[op].arg_type;
  else
    return nullargs;
}

/* Given the trap index in dispatch table, return its name.
   This routine is used when disassembling the 'excp' instruction.  */

static char *
gettrapstring (unsigned int trap_index)
{
  const trap_entry *trap;

  for (trap = crx_traps; trap < crx_traps + NUMTRAPS; trap++)
    if (trap->entry == trap_index)
      return trap->name;

  return ILLEGAL;
}

/* Given a 'cinv' instruction constant operand, return its corresponding string.
   This routine is used when disassembling the 'cinv' instruction.  */

static char *
getcinvstring (unsigned int num)
{
  const cinv_entry *cinv;

  for (cinv = crx_cinvs; cinv < (crx_cinvs + NUMCINVS); cinv++)
    if (cinv->value == num)
      return cinv->str;

  return ILLEGAL;
}

/* Given a register enum value, retrieve its name.  */

char *
getregname (reg r)
{
  const reg_entry * regentry = &crx_regtab[r];

  if (regentry->type != CRX_R_REGTYPE)
    return ILLEGAL;
  else
    return regentry->name;
}

/* Given a coprocessor register enum value, retrieve its name.  */

char *
getcopregname (copreg r, reg_type type)
{
  const reg_entry * regentry;

  if (type == CRX_C_REGTYPE)
    regentry = &crx_copregtab[r];
  else if (type == CRX_CS_REGTYPE)
    regentry = &crx_copregtab[r+(cs0-c0)];
  else
    return ILLEGAL;

  return regentry->name;
}


/* Getting a processor register name.  */

static char *
getprocregname (int reg_index)
{
  const reg_entry *r;

  for (r = crx_regtab; r < crx_regtab + NUMREGS; r++)
    if (r->image == reg_index)
      return r->name;

  return "ILLEGAL REGISTER";
}

/* Get the power of two for a given integer.  */

static int
powerof2 (int x)
{
  int product, i;

  for (i = 0, product = 1; i < x; i++)
    product *= 2;

  return product;
}

/* Transform a register bit mask to a register list.  */

void
getregliststring (int mask, char *string, enum REG_ARG_TYPE core_cop)
{
  char temp_string[5];
  int i;

  string[0] = '{';
  string[1] = '\0';


  /* A zero mask means HI/LO registers.  */
  if (mask == 0)
    {
      if (core_cop == USER_REG_ARG)
	strcat (string, "ulo,uhi");
      else
	strcat (string, "lo,hi");
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (mask & 0x1)
	    {
	      switch (core_cop)
	      {
	      case REG_ARG:
		sprintf (temp_string, "r%d", i);
		break;
	      case USER_REG_ARG:
		sprintf (temp_string, "u%d", i);
		break;
	      case COP_ARG:
		sprintf (temp_string, "c%d", i);
		break;
	      case COPS_ARG:
		sprintf (temp_string, "cs%d", i);
		break;
	      default:
		break;
	      }
	      strcat (string, temp_string);
	      if (mask & 0xfffe)
		strcat (string, ",");
	    }
	  mask >>= 1;
	}
    }

  strcat (string, "}");
}

/* START and END are relating 'allWords' struct, which is 48 bits size.

			  START|--------|END
	    +---------+---------+---------+---------+
	    |	      |	   V    |     A	  |   L	    |
	    +---------+---------+---------+---------+
	    	      0		16	  32	    48
    words		  [0]	    [1]	      [2]	*/

static parameter
makelongparameter (ULONGLONG val, int start, int end)
{
  parameter p;

  p.val = (dwordU) EXTRACT(val, 48 - end, end - start);
  p.nbits = end - start;
  return p;
}

/* Build a mask of the instruction's 'constant' opcode,
   based on the instruction's printing flags.  */

static unsigned long
build_mask (void)
{
  unsigned int print_flags;
  unsigned long mask;

  print_flags = instruction->flags & FMT_CRX;
  switch (print_flags)
    {
      case FMT_1:
	mask = 0xF0F00000;
	break;
      case FMT_2:
	mask = 0xFFF0FF00;
	break;
      case FMT_3:
	mask = 0xFFF00F00;
	break;
      case FMT_4:
	mask = 0xFFF0F000;
	break;
      case FMT_5:
	mask = 0xFFF0FFF0;
	break;
      default:
	mask = SBM(instruction->match_bits);
	break;
    }

  return mask;
}

/* Search for a matching opcode. Return 1 for success, 0 for failure.  */

static int
match_opcode (void)
{
  unsigned long mask;

  /* The instruction 'constant' opcode doewsn't exceed 32 bits.  */
  unsigned long doubleWord = (words[1] + (words[0] << 16)) & 0xffffffff;

  /* Start searching from end of instruction table.  */
  instruction = &crx_instruction[NUMOPCODES - 2];

  /* Loop over instruction table until a full match is found.  */
  while (instruction >= crx_instruction)
    {
      mask = build_mask ();
      if ((doubleWord & mask) == BIN(instruction->match, instruction->match_bits))
	return 1;
      else
	instruction--;
    }
  return 0;
}

/* Set the proper parameter value for different type of arguments.  */

static void
make_argument (argument * a, int start_bits)
{
  int inst_bit_size, total_size;
  parameter p;

  if ((instruction->size == 3) && a->size >= 16)
    inst_bit_size = 48;
  else
    inst_bit_size = 32;

  switch (a->type)
    {
    case arg_copr:
    case arg_copsr:
      p = makelongparameter (allWords, inst_bit_size - (start_bits + a->size),
			     inst_bit_size - start_bits);
      a->cr = p.val;
      break;

    case arg_r:
      p = makelongparameter (allWords, inst_bit_size - (start_bits + a->size),
			     inst_bit_size - start_bits);
      a->r = p.val;
      break;

    case arg_ic:
      p = makelongparameter (allWords, inst_bit_size - (start_bits + a->size),
			     inst_bit_size - start_bits);

      if ((p.nbits == 4) && cst4flag)
        {
	  if (IS_INSN_TYPE (CMPBR_INS) && (p.val == ESCAPE_16_BIT))
	    {
	      /* A special case, where the value is actually stored
		 in the last 4 bits.  */
	      p = makelongparameter (allWords, 44, 48);
	      /* The size of the instruction should be incremented.  */
	      size_changed = 1;
	    }

          if (p.val == 6)
            p.val = -1;
          else if (p.val == 13)
            p.val = 48;
          else if (p.val == 5)
            p.val = -4;
          else if (p.val == 10)
            p.val = 32;
          else if (p.val == 11)
            p.val = 20;
          else if (p.val == 9)
            p.val = 16;
        }

      a->constant = p.val;
      break;

    case arg_idxr:
      a->scale = 0;
      total_size = a->size + 10;  /* sizeof(rbase + ridx + scl2) = 10.  */
      p = makelongparameter (allWords, inst_bit_size - total_size,
			     inst_bit_size - (total_size - 4));
      a->r = p.val;
      p = makelongparameter (allWords, inst_bit_size - (total_size - 4),
			     inst_bit_size - (total_size - 8));
      a->i_r = p.val;
      p = makelongparameter (allWords, inst_bit_size - (total_size - 8),
			     inst_bit_size - (total_size - 10));
      a->scale = p.val;
      p = makelongparameter (allWords, inst_bit_size - (total_size - 10),
			     inst_bit_size);
      a->constant = p.val;
      break;

    case arg_rbase:
      p = makelongparameter (allWords, inst_bit_size - (start_bits + 4),
			     inst_bit_size - start_bits);
      a->r = p.val;
      break;

    case arg_cr:
      if (a->size <= 8)
        {
          p = makelongparameter (allWords, inst_bit_size - (start_bits + 4),
				 inst_bit_size - start_bits);
          a->r = p.val;
          /* Case for opc4 r dispu rbase.  */
          p = makelongparameter (allWords, inst_bit_size - (start_bits + 8),
				 inst_bit_size - (start_bits + 4));
        }
      else
        {
	  /* The 'rbase' start_bits is always relative to a 32-bit data type.  */
          p = makelongparameter (allWords, 32 - (start_bits + 4),
				 32 - start_bits);
          a->r = p.val;
          p = makelongparameter (allWords, 32 - start_bits,
				 inst_bit_size);
        }
      if ((p.nbits == 4) && cst4flag)
        {
          if (instruction->flags & DISPUW4)
	    p.val *= 2;
          else if (instruction->flags & DISPUD4)
	    p.val *= 4;
        }
      a->constant = p.val;
      break;

    case arg_c:
      p = makelongparameter (allWords, inst_bit_size - (start_bits + a->size),
			     inst_bit_size - start_bits);
      a->constant = p.val;
      break;
    default:
      break;
    }
}

/*  Print a single argument.  */

static void
print_arg (argument *a, bfd_vma memaddr, struct disassemble_info *info)
{
  LONGLONG longdisp, mask;
  int sign_flag = 0;
  int relative = 0;
  bfd_vma number;
  int op_index = 0;
  char string[200];
  PTR stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  switch (a->type)
    {
    case arg_copr:
      func (stream, "%s", getcopregname (a->cr, CRX_C_REGTYPE));
      break;

    case arg_copsr:
      func (stream, "%s", getcopregname (a->cr, CRX_CS_REGTYPE));
      break;

    case arg_r:
      if (IS_INSN_MNEMONIC ("mtpr") || IS_INSN_MNEMONIC ("mfpr"))
	func (stream, "%s", getprocregname (a->r));
      else
	func (stream, "%s", getregname (a->r));
      break;

    case arg_ic:
      if (IS_INSN_MNEMONIC ("excp"))
	func (stream, "%s", gettrapstring (a->constant));

      else if (IS_INSN_MNEMONIC ("cinv"))
	func (stream, "%s", getcinvstring (a->constant));

      else if (INST_HAS_REG_LIST)
        {
	  REG_ARG_TYPE reg_arg_type = IS_INSN_TYPE (COP_REG_INS) ? 
				 COP_ARG : IS_INSN_TYPE (COPS_REG_INS) ? 
				 COPS_ARG : (instruction->flags & USER_REG) ?
				 USER_REG_ARG : REG_ARG;

          if ((reg_arg_type == COP_ARG) || (reg_arg_type == COPS_ARG))
	    {
		/*  Check for proper argument number.  */
		if (processing_argument_number == 2)
		  {
		    getregliststring (a->constant, string, reg_arg_type);
		    func (stream, "%s", string);
		  }
		else
		  func (stream, "$0x%lx", a->constant & 0xffffffff);
	    }
	  else
            {
              getregliststring (a->constant, string, reg_arg_type);
              func (stream, "%s", string);
            }
        }
      else
	func (stream, "$0x%lx", a->constant & 0xffffffff);
      break;

    case arg_idxr:
      func (stream, "0x%lx(%s,%s,%d)", a->constant & 0xffffffff,
	    getregname (a->r), getregname (a->i_r), powerof2 (a->scale));
      break;

    case arg_rbase:
      func (stream, "(%s)", getregname (a->r));
      break;

    case arg_cr:
      func (stream, "0x%lx(%s)", a->constant & 0xffffffff, getregname (a->r));

      if (IS_INSN_TYPE (LD_STOR_INS_INC))
	func (stream, "+");
      break;

    case arg_c:
      /* Removed the *2 part as because implicit zeros are no more required.
	 Have to fix this as this needs a bit of extension in terms of branchins.
	 Have to add support for cmp and branch instructions.  */
      if (IS_INSN_TYPE (BRANCH_INS) || IS_INSN_MNEMONIC ("bal")
	  || IS_INSN_TYPE (CMPBR_INS) || IS_INSN_TYPE (DCR_BRANCH_INS)
	  || IS_INSN_TYPE (COP_BRANCH_INS))
        {
	  relative = 1;
          longdisp = a->constant;
          longdisp <<= 1;

          switch (a->size)
            {
            case 8:
	    case 16:
	    case 24:
	    case 32:
	      mask = ((LONGLONG)1 << a->size) - 1;
              if (longdisp & ((LONGLONG)1 << a->size))
                {
                  sign_flag = 1;
                  longdisp = ~(longdisp) + 1;
                }
              a->constant = (unsigned long int) (longdisp & mask);
              break;
            default:
	      func (stream,
		    "Wrong offset used in branch/bal instruction");
              break;
            }

        }
      /* For branch Neq instruction it is 2*offset + 2.  */
      else if (IS_INSN_TYPE (BRANCH_NEQ_INS))
	a->constant = 2 * a->constant + 2;
      else if (IS_INSN_TYPE (LD_STOR_INS_INC)
	  || IS_INSN_TYPE (LD_STOR_INS)
	  || IS_INSN_TYPE (STOR_IMM_INS)
	  || IS_INSN_TYPE (CSTBIT_INS))
        {
          op_index = instruction->flags & REVERSE_MATCH ? 0 : 1;
          if (instruction->operands[op_index].op_type == abs16)
	    a->constant |= 0xFFFF0000;
        }
      func (stream, "%s", "0x");
      number = (relative ? memaddr : 0)
	       + (sign_flag ? -a->constant : a->constant);
      (*info->print_address_func) (number, info);
      break;
    default:
      break;
    }
}

/* Print all the arguments of CURRINSN instruction.  */

static void
print_arguments (ins *currentInsn, bfd_vma memaddr, struct disassemble_info *info)
{
  int i;

  for (i = 0; i < currentInsn->nargs; i++)
    {
      processing_argument_number = i;

      print_arg (&currentInsn->arg[i], memaddr, info);

      if (i != currentInsn->nargs - 1)
	info->fprintf_func (info->stream, ", ");
    }
}

/* Build the instruction's arguments.  */

static void
make_instruction (void)
{
  int i;
  unsigned int shift;

  for (i = 0; i < currInsn.nargs; i++)
    {
      argument a;

      memset (&a, 0, sizeof (a));
      a.type = getargtype (instruction->operands[i].op_type);
      if (instruction->operands[i].op_type == cst4
	  || instruction->operands[i].op_type == rbase_dispu4)
	cst4flag = 1;
      a.size = getbits (instruction->operands[i].op_type);
      shift = instruction->operands[i].shift;

      make_argument (&a, shift);
      currInsn.arg[i] = a;
    }

  /* Calculate instruction size (in bytes).  */
  currInsn.size = instruction->size + (size_changed ? 1 : 0);
  /* Now in bits.  */
  currInsn.size *= 2;
}

/* Retrieve a single word from a given memory address.  */

static wordU
get_word_at_PC (bfd_vma memaddr, struct disassemble_info *info)
{
  bfd_byte buffer[4];
  int status;
  wordU insn = 0;

  status = info->read_memory_func (memaddr, buffer, 2, info);

  if (status == 0)
    insn = (wordU) bfd_getl16 (buffer);

  return insn;
}

/* Retrieve multiple words (3) from a given memory address.  */

static void
get_words_at_PC (bfd_vma memaddr, struct disassemble_info *info)
{
  int i;
  bfd_vma mem;

  for (i = 0, mem = memaddr; i < 3; i++, mem += 2)
    words[i] = get_word_at_PC (mem, info);

  allWords =
    ((ULONGLONG) words[0] << 32) + ((unsigned long) words[1] << 16) + words[2];
}

/* Prints the instruction by calling print_arguments after proper matching.  */

int
print_insn_crx (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info *info;
{
  int is_decoded;     /* Nonzero means instruction has a match.  */

  /* Initialize global variables.  */
  cst4flag = 0;
  size_changed = 0;

  /* Retrieve the encoding from current memory location.  */
  get_words_at_PC (memaddr, info);
  /* Find a matching opcode in table.  */
  is_decoded = match_opcode ();
  /* If found, print the instruction's mnemonic and arguments.  */
  if (is_decoded > 0 && (words[0] << 16 || words[1]) != 0)
    {
      info->fprintf_func (info->stream, "%s", instruction->mnemonic);
      if ((currInsn.nargs = get_number_of_operands ()) != 0)
	info->fprintf_func (info->stream, "\t");
      make_instruction ();
      print_arguments (&currInsn, memaddr, info);
      return currInsn.size;
    }

  /* No match found.  */
  info->fprintf_func (info->stream,"%s ",ILLEGAL);
  return 2;
}
@


1.17
log
@gas/
	* config/tc-crx.c: Include bfd_stdint.h.
	(getconstant): Remove irrelevant comment.  Don't fail due to
	sign-extension of int mask.
	(check_range): Rewrite using unsigned arithmetic throughout.
opcodes/
	* crx-dis.c (print_arg): Mask constant to 32 bits.
	* crx-opc.c (cst4_map): Use int array.
include/opcode/
	* crx.h (cst4_map): Update declaration.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.16
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d551 1
a551 1
		  func (stream, "$0x%lx", a->constant);
d560 1
a560 1
	func (stream, "$0x%lx", a->constant);
d564 2
a565 2
      func (stream, "0x%lx(%s,%s,%d)", a->constant, getregname (a->r),
	    getregname (a->i_r), powerof2 (a->scale));
d573 1
a573 1
      func (stream, "0x%lx(%s)", a->constant, getregname (a->r));
@


1.15
log
@

2009-10-01  M R Swami Reddy <MR.Swami.Reddy@@nsc.com>

       * crx-dis.c (match_opcode): Truncate mcode to 32-bit.
@
text
@d158 1
a158 1
gettrapstring (unsigned int index)
d163 1
a163 1
    if (trap->entry == index)
d189 1
a189 1
  const reg_entry *reg = &crx_regtab[r];
d191 1
a191 1
  if (reg->type != CRX_R_REGTYPE)
d194 1
a194 1
    return reg->name;
d202 1
a202 1
  const reg_entry *reg;
d205 1
a205 1
    reg = &crx_copregtab[r];
d207 1
a207 1
    reg = &crx_copregtab[r+(cs0-c0)];
d211 1
a211 1
  return reg->name;
d218 1
a218 1
getprocregname (int index)
d223 1
a223 1
    if (r->image == index)
d637 1
a637 1
print_arguments (ins *currInsn, bfd_vma memaddr, struct disassemble_info *info)
d641 1
a641 1
  for (i = 0; i < currInsn->nargs; i++)
d645 1
a645 1
      print_arg (&currInsn->arg[i], memaddr, info);
d647 1
a647 1
      if (i != currInsn->nargs - 1)
@


1.14
log
@update copyright dates
@
text
@d358 1
a358 1
  unsigned long doubleWord = words[1] + (words[0] << 16);
@


1.14.2.1
log
@2009-10-01  M R Swami Reddy <MR.Swami.Reddy@@nsc.com>

	* crx-dis.c (match_opcode): Truncate mcode to 32-bit.
@
text
@d358 1
a358 1
  unsigned long doubleWord = (words[1] + (words[0] << 16)) & 0xffffffff;
@


1.13
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.12
log
@* crx-dis.c (EXTRACT): Make macro work on 64-bit hosts.
@
text
@d2 1
a2 1
   Copyright 2004, 2005 Free Software Foundation, Inc.
d6 1
a6 1
   This file is part of the GNU binutils and GDB, the GNU debugger.
d8 3
a10 3
   This program is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2, or (at your option)
d13 4
a16 4
   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.11
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d33 1
a33 1
  (n_bits == 32 ? (((a) >> (offs)) & ~0L)   \
@


1.11.14.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d33 1
a33 1
  (n_bits == 32 ? (((a) >> (offs)) & 0xffffffffL)   \
@


1.11.20.1
log
@Backport fixes to branch.
@
text
@d33 1
a33 1
  (n_bits == 32 ? (((a) >> (offs)) & 0xffffffffL)   \
@


1.10
log
@Update the address and phone number of the FSF
@
text
@d550 1
a550 1
		  func (stream, "$0x%x", a->constant);
d559 1
a559 1
	func (stream, "$0x%x", a->constant);
d563 1
a563 1
      func (stream, "0x%x(%s,%s,%d)", a->constant, getregname (a->r),
d572 1
a572 1
      func (stream, "0x%x(%s)", a->constant, getregname (a->r));
@


1.9
log
@update copyright dates
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.8
log
@	* cris-dis.c (format_hex): Remove ineffective warning fix.
	* crx-dis.c (make_instruction): Warning fix.
	* frv-asm.c: Regenerate.
@
text
@d2 1
a2 1
   Copyright 2004 Free Software Foundation, Inc.
@


1.7
log
@(make_instruction): Move argument structure into inner scope and ensure that
all of its fields are initialised before they are used.
@
text
@d661 1
a661 1
      argument a = { 0 };
d663 1
@


1.6
log
@2004-12-05  Tomer Levi  <Tomer.Levi@@nsc.com>

* crx-dis.c: Use 'info->print_address_func' for address printing.
@
text
@a657 1
  argument a;
d661 2
@


1.5
log
@2004-11-29  Tomer Levi  <Tomer.Levi@@nsc.com>

	* crx-opc.c (crx_optab): Mark all rbase_disps* operands as signed.
	(no_op_insn): Initialize array with instructions that have no
	operands.
	* crx-dis.c (make_instruction): Get rid of COP_BRANCH_INS operand swapping.
@
text
@d115 2
a116 2
static void print_arguments   (ins *, struct disassemble_info *);
static void print_arg	      (argument *, struct disassemble_info *);
d499 1
a499 1
print_arg (argument *a, struct disassemble_info *info)
d502 3
a504 1
  char sign_flag;
d586 1
a586 1
          func (stream, "%c", '*');
a588 1
          sign_flag = '+';
d599 1
a599 1
                  sign_flag = '-';
a609 1
	  func (stream, "%c", sign_flag);
d612 1
a612 1
      if (IS_INSN_TYPE (BRANCH_NEQ_INS))
d614 1
a614 1
      if (IS_INSN_TYPE (LD_STOR_INS_INC)
d623 4
a626 1
      func (stream, "0x%x", a->constant);
d636 1
a636 1
print_arguments (ins *currInsn, struct disassemble_info *info)
d644 1
a644 1
      print_arg (&currInsn->arg[i], info);
d735 1
a735 1
      print_arguments (&currInsn, info);
@


1.4
log
@2004-11-05  Tomer Levi  <Tomer.Levi@@nsc.com>

* crx-opc.c (crx_optab): Rename 'arg_icr' to 'arg_idxr' for Index register mode.
* crx-dis.c: Likewise.
@
text
@d654 1
a654 1
  unsigned int temp_value, shift;
d661 1
a661 1
	  || instruction->operands[i].op_type == rbase_cst4)
d672 1
a673 8

  /* Swapping first and second arguments.  */
  if (IS_INSN_TYPE (COP_BRANCH_INS))
    {
      temp_value = currInsn.arg[0].constant;
      currInsn.arg[0].constant = currInsn.arg[1].constant;
      currInsn.arg[1].constant = temp_value;
    }
@


1.3
log
@* crx-dis.c (enum REG_ARG_TYPE): New, replacing COP_ARG_TYPE.
(getregliststring): Support HI/LO and user registers.
@
text
@d434 1
a434 1
    case arg_icr:
d560 1
a560 1
    case arg_icr:
@


1.2
log
@Add support for CRX co-processor opcodes
@
text
@d68 2
a69 3
/* Enum to distinguish CO-Processor [special] registers arguments 
   from general purpose regidters.  */
typedef enum COP_ARG_TYPE
d71 5
a75 3
    /* Not a CO-Processor argument (probably a general purpose reg.).  */
    NO_COP_ARG = 0,
    /* A CO-Processor argument (c<N>).  */
d77 1
a77 1
    /* A CO-Processor special argument (cs<N>).  */
d80 1
a80 1
COP_ARG_TYPE;
d108 1
a108 1
static void getregliststring  (int, char *, enum COP_ARG_TYPE);
d244 1
a244 1
getregliststring (int trap, char *string, enum COP_ARG_TYPE core_cop)
d252 10
a261 1
  for (i = 0; i < 16; i++)
d263 1
a263 1
      if (trap & 0x1)
d265 1
a265 1
	  switch (core_cop)
d267 20
a286 11
	    case NO_COP_ARG:
	      sprintf (temp_string, "r%d", i);
	      break;
	    case COP_ARG:
	      sprintf (temp_string, "c%d", i);
	      break;
	    case COPS_ARG:
	      sprintf (temp_string, "cs%d", i);
	      break;
	    default:
	      break;
d288 2
a289 5
          strcat (string, temp_string);
          if (trap & 0xfffe)
	    strcat (string, ",");
        }
      trap = trap >> 1;
d534 1
a534 1
	  COP_ARG_TYPE cop_ins = IS_INSN_TYPE (COP_REG_INS) ? 
d536 2
a537 1
				 COPS_ARG : NO_COP_ARG;
d539 1
a539 1
          if (cop_ins != NO_COP_ARG)
d541 8
a548 8
	      /*  Check for proper argument number.  */
	      if (processing_argument_number == 2)
		{
		  getregliststring (a->constant, string, cop_ins);
		  func (stream, "%s", string);
		}
	      else
		func (stream, "$0x%x", a->constant);
d552 1
a552 1
              getregliststring (a->constant, string, cop_ins);
@


1.1
log
@Add new port: crx-elf
@
text
@d62 4
a65 2
  {"[i]", 2}, {"[i,u]", 3}, {"[d]", 4},
  {"[d,u]", 5}, {"[d,i]", 6}, {"[d,i,u]", 7}
d68 13
d107 1
a107 1
static void getregliststring  (int, char *, int);
d243 1
a243 1
getregliststring (int trap, char *string, int core_cop)
d254 15
a268 5
        {
          if (core_cop)
	    sprintf (temp_string, "r%d", i);
          else
	    sprintf (temp_string, "c%d", i);
d518 16
a533 1
          if (!IS_INSN_TYPE (COP_REG_INS))
d535 1
a535 1
              getregliststring (a->constant, string, 1);
a537 11
          else
            {
              /*  Check for proper argument number.  */
              if (processing_argument_number == 2)
                {
                  getregliststring (a->constant, string, 0);
                  func (stream, "%s", string);
                }
              else
		func (stream, "$0x%x", a->constant);
            }
@


1.1.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@@

