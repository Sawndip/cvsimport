head	1.25;
access;
symbols
	sid-snapshot-20180601:1.25
	sid-snapshot-20180501:1.25
	sid-snapshot-20180401:1.25
	sid-snapshot-20180301:1.25
	sid-snapshot-20180201:1.25
	sid-snapshot-20180101:1.25
	sid-snapshot-20171201:1.25
	sid-snapshot-20171101:1.25
	sid-snapshot-20171001:1.25
	sid-snapshot-20170901:1.25
	sid-snapshot-20170801:1.25
	sid-snapshot-20170701:1.25
	sid-snapshot-20170601:1.25
	sid-snapshot-20170501:1.25
	sid-snapshot-20170401:1.25
	sid-snapshot-20170301:1.25
	sid-snapshot-20170201:1.25
	sid-snapshot-20170101:1.25
	sid-snapshot-20161201:1.25
	sid-snapshot-20161101:1.25
	sid-snapshot-20160901:1.25
	sid-snapshot-20160801:1.25
	sid-snapshot-20160701:1.25
	sid-snapshot-20160601:1.25
	sid-snapshot-20160501:1.25
	sid-snapshot-20160401:1.25
	sid-snapshot-20160301:1.25
	sid-snapshot-20160201:1.25
	sid-snapshot-20160101:1.25
	sid-snapshot-20151201:1.25
	sid-snapshot-20151101:1.25
	sid-snapshot-20151001:1.25
	sid-snapshot-20150901:1.25
	sid-snapshot-20150801:1.25
	sid-snapshot-20150701:1.25
	sid-snapshot-20150601:1.25
	sid-snapshot-20150501:1.25
	sid-snapshot-20150401:1.25
	sid-snapshot-20150301:1.25
	sid-snapshot-20150201:1.25
	sid-snapshot-20150101:1.25
	sid-snapshot-20141201:1.25
	sid-snapshot-20141101:1.25
	sid-snapshot-20141001:1.25
	sid-snapshot-20140901:1.25
	sid-snapshot-20140801:1.25
	sid-snapshot-20140701:1.25
	sid-snapshot-20140601:1.25
	sid-snapshot-20140501:1.25
	sid-snapshot-20140401:1.25
	sid-snapshot-20140301:1.25
	sid-snapshot-20140201:1.25
	sid-snapshot-20140101:1.25
	sid-snapshot-20131201:1.25
	sid-snapshot-20131101:1.25
	sid-snapshot-20131001:1.25
	binutils-2_24-branch:1.25.0.4
	binutils-2_24-branchpoint:1.25
	binutils-2_21_1:1.24
	sid-snapshot-20130901:1.25
	gdb_7_6_1-2013-08-30-release:1.25
	sid-snapshot-20130801:1.25
	sid-snapshot-20130701:1.25
	sid-snapshot-20130601:1.25
	sid-snapshot-20130501:1.25
	gdb_7_6-2013-04-26-release:1.25
	sid-snapshot-20130401:1.25
	binutils-2_23_2:1.24.16.1
	gdb_7_6-branch:1.25.0.2
	gdb_7_6-2013-03-12-branchpoint:1.25
	sid-snapshot-20130301:1.25
	sid-snapshot-20130201:1.25
	sid-snapshot-20130101:1.25
	sid-snapshot-20121201:1.25
	gdb_7_5_1-2012-11-29-release:1.24
	binutils-2_23_1:1.24.16.1
	sid-snapshot-20121101:1.25
	binutils-2_23:1.24.16.1
	sid-snapshot-20121001:1.25
	sid-snapshot-20120901:1.25
	gdb_7_5-2012-08-17-release:1.24
	sid-snapshot-20120801:1.25
	binutils-2_23-branch:1.24.0.16
	binutils-2_23-branchpoint:1.24
	gdb_7_5-branch:1.24.0.14
	gdb_7_5-2012-07-18-branchpoint:1.24
	sid-snapshot-20120701:1.24
	sid-snapshot-20120601:1.24
	sid-snapshot-20120501:1.24
	binutils-2_22_branch:1.24.0.12
	gdb_7_4_1-2012-04-26-release:1.24
	sid-snapshot-20120401:1.24
	sid-snapshot-20120301:1.24
	sid-snapshot-20120201:1.24
	gdb_7_4-2012-01-24-release:1.24
	sid-snapshot-20120101:1.24
	gdb_7_4-branch:1.24.0.10
	gdb_7_4-2011-12-13-branchpoint:1.24
	sid-snapshot-20111201:1.24
	binutils-2_22:1.24
	sid-snapshot-20111101:1.24
	sid-snapshot-20111001:1.24
	binutils-2_22-branch:1.24.0.8
	binutils-2_22-branchpoint:1.24
	gdb_7_3_1-2011-09-04-release:1.24
	sid-snapshot-20110901:1.24
	sid-snapshot-20110801:1.24
	gdb_7_3-2011-07-26-release:1.24
	sid-snapshot-20110701:1.24
	sid-snapshot-20110601:1.24
	sid-snapshot-20110501:1.24
	gdb_7_3-branch:1.24.0.6
	gdb_7_3-2011-04-01-branchpoint:1.24
	sid-snapshot-20110401:1.24
	sid-snapshot-20110301:1.24
	sid-snapshot-20110201:1.24
	sid-snapshot-20110101:1.24
	binutils-2_21:1.24
	sid-snapshot-20101201:1.24
	binutils-2_21-branch:1.24.0.4
	binutils-2_21-branchpoint:1.24
	sid-snapshot-20101101:1.24
	sid-snapshot-20101001:1.24
	binutils-2_20_1:1.23
	gdb_7_2-2010-09-02-release:1.24
	sid-snapshot-20100901:1.24
	sid-snapshot-20100801:1.24
	gdb_7_2-branch:1.24.0.2
	gdb_7_2-2010-07-07-branchpoint:1.24
	sid-snapshot-20100701:1.24
	sid-snapshot-20100601:1.23
	sid-snapshot-20100501:1.23
	sid-snapshot-20100401:1.23
	gdb_7_1-2010-03-18-release:1.23
	sid-snapshot-20100301:1.23
	gdb_7_1-branch:1.23.0.36
	gdb_7_1-2010-02-18-branchpoint:1.23
	sid-snapshot-20100201:1.23
	sid-snapshot-20100101:1.23
	gdb_7_0_1-2009-12-22-release:1.23
	sid-snapshot-20091201:1.23
	sid-snapshot-20091101:1.23
	binutils-2_20:1.23
	gdb_7_0-2009-10-06-release:1.23
	sid-snapshot-20091001:1.23
	gdb_7_0-branch:1.23.0.34
	gdb_7_0-2009-09-16-branchpoint:1.23
	arc-sim-20090309:1.23
	binutils-arc-20081103-branch:1.23.0.32
	binutils-arc-20081103-branchpoint:1.23
	binutils-2_20-branch:1.23.0.30
	binutils-2_20-branchpoint:1.23
	sid-snapshot-20090901:1.23
	sid-snapshot-20090801:1.23
	msnyder-checkpoint-072509-branch:1.23.0.28
	msnyder-checkpoint-072509-branchpoint:1.23
	sid-snapshot-20090701:1.23
	dje-cgen-play1-branch:1.23.0.26
	dje-cgen-play1-branchpoint:1.23
	sid-snapshot-20090601:1.23
	sid-snapshot-20090501:1.23
	sid-snapshot-20090401:1.23
	arc-20081103-branch:1.23.0.24
	arc-20081103-branchpoint:1.23
	arc-insight_6_8-branch:1.23.0.22
	arc-insight_6_8-branchpoint:1.23
	insight_6_8-branch:1.23.0.20
	insight_6_8-branchpoint:1.23
	sid-snapshot-20090301:1.23
	binutils-2_19_1:1.23
	sid-snapshot-20090201:1.23
	sid-snapshot-20090101:1.23
	reverse-20081226-branch:1.23.0.18
	reverse-20081226-branchpoint:1.23
	sid-snapshot-20081201:1.23
	multiprocess-20081120-branch:1.23.0.16
	multiprocess-20081120-branchpoint:1.23
	sid-snapshot-20081101:1.23
	binutils-2_19:1.23
	sid-snapshot-20081001:1.23
	reverse-20080930-branch:1.23.0.14
	reverse-20080930-branchpoint:1.23
	binutils-2_19-branch:1.23.0.12
	binutils-2_19-branchpoint:1.23
	sid-snapshot-20080901:1.23
	sid-snapshot-20080801:1.23
	reverse-20080717-branch:1.23.0.10
	reverse-20080717-branchpoint:1.23
	sid-snapshot-20080701:1.23
	msnyder-reverse-20080609-branch:1.23.0.8
	msnyder-reverse-20080609-branchpoint:1.23
	drow-reverse-20070409-branch:1.22.0.4
	drow-reverse-20070409-branchpoint:1.22
	sid-snapshot-20080601:1.23
	sid-snapshot-20080501:1.23
	sid-snapshot-20080403:1.23
	sid-snapshot-20080401:1.23
	gdb_6_8-2008-03-27-release:1.23
	sid-snapshot-20080301:1.23
	gdb_6_8-branch:1.23.0.6
	gdb_6_8-2008-02-26-branchpoint:1.23
	sid-snapshot-20080201:1.23
	sid-snapshot-20080101:1.23
	sid-snapshot-20071201:1.23
	sid-snapshot-20071101:1.23
	gdb_6_7_1-2007-10-29-release:1.23
	gdb_6_7-2007-10-10-release:1.23
	sid-snapshot-20071001:1.23
	gdb_6_7-branch:1.23.0.4
	gdb_6_7-2007-09-07-branchpoint:1.23
	binutils-2_18:1.23
	binutils-2_18-branch:1.23.0.2
	binutils-2_18-branchpoint:1.23
	insight_6_6-20070208-release:1.22
	binutils-csl-coldfire-4_1-32:1.20
	binutils-csl-sourcerygxx-4_1-32:1.20
	gdb_6_6-2006-12-18-release:1.22
	binutils-csl-innovasic-fido-3_4_4-33:1.20
	binutils-csl-sourcerygxx-3_4_4-32:1.17
	binutils-csl-coldfire-4_1-30:1.20
	binutils-csl-sourcerygxx-4_1-30:1.20
	binutils-csl-coldfire-4_1-28:1.20
	binutils-csl-sourcerygxx-4_1-29:1.20
	binutils-csl-sourcerygxx-4_1-28:1.20
	gdb_6_6-branch:1.22.0.2
	gdb_6_6-2006-11-15-branchpoint:1.22
	binutils-csl-arm-2006q3-27:1.20
	binutils-csl-sourcerygxx-4_1-27:1.20
	binutils-csl-arm-2006q3-26:1.20
	binutils-csl-sourcerygxx-4_1-26:1.20
	binutils-csl-sourcerygxx-4_1-25:1.20
	binutils-csl-sourcerygxx-4_1-24:1.20
	binutils-csl-sourcerygxx-4_1-23:1.20
	insight_6_5-20061003-release:1.20
	gdb-csl-symbian-6_4_50_20060226-12:1.20
	binutils-csl-sourcerygxx-4_1-21:1.20
	binutils-csl-arm-2006q3-21:1.20
	binutils-csl-sourcerygxx-4_1-22:1.20
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.20
	binutils-csl-sourcerygxx-4_1-20:1.20
	binutils-csl-arm-2006q3-19:1.20
	binutils-csl-sourcerygxx-4_1-19:1.20
	binutils-csl-sourcerygxx-4_1-18:1.20
	binutils-csl-renesas-4_1-9:1.20
	gdb-csl-sourcerygxx-3_4_4-25:1.20
	binutils-csl-sourcerygxx-3_4_4-25:1.17
	nickrob-async-20060828-mergepoint:1.20
	gdb-csl-symbian-6_4_50_20060226-11:1.20
	binutils-csl-renesas-4_1-8:1.20
	binutils-csl-renesas-4_1-7:1.20
	binutils-csl-renesas-4_1-6:1.20
	gdb-csl-sourcerygxx-4_1-17:1.20
	binutils-csl-sourcerygxx-4_1-17:1.20
	gdb-csl-20060226-branch-local-2:1.20
	gdb-csl-sourcerygxx-4_1-14:1.20
	binutils-csl-sourcerygxx-4_1-14:1.20
	binutils-csl-sourcerygxx-4_1-15:1.20
	gdb-csl-sourcerygxx-4_1-13:1.20
	binutils-csl-sourcerygxx-4_1-13:1.20
	binutils-2_17:1.20
	gdb-csl-sourcerygxx-4_1-12:1.20
	binutils-csl-sourcerygxx-4_1-12:1.20
	gdb-csl-sourcerygxx-3_4_4-21:1.20
	binutils-csl-sourcerygxx-3_4_4-21:1.20
	gdb_6_5-20060621-release:1.20
	binutils-csl-wrs-linux-3_4_4-24:1.17
	binutils-csl-wrs-linux-3_4_4-23:1.17
	gdb-csl-sourcerygxx-4_1-9:1.20
	binutils-csl-sourcerygxx-4_1-9:1.20
	gdb-csl-sourcerygxx-4_1-8:1.20
	binutils-csl-sourcerygxx-4_1-8:1.20
	gdb-csl-sourcerygxx-4_1-7:1.20
	binutils-csl-sourcerygxx-4_1-7:1.20
	gdb-csl-arm-2006q1-6:1.20
	binutils-csl-arm-2006q1-6:1.20
	gdb-csl-sourcerygxx-4_1-6:1.20
	binutils-csl-sourcerygxx-4_1-6:1.20
	binutils-csl-wrs-linux-3_4_4-22:1.17
	gdb-csl-symbian-6_4_50_20060226-10:1.20
	gdb-csl-symbian-6_4_50_20060226-9:1.20
	gdb-csl-symbian-6_4_50_20060226-8:1.20
	gdb-csl-coldfire-4_1-11:1.20
	binutils-csl-coldfire-4_1-11:1.20
	gdb-csl-sourcerygxx-3_4_4-19:1.20
	binutils-csl-sourcerygxx-3_4_4-19:1.20
	gdb-csl-coldfire-4_1-10:1.20
	gdb_6_5-branch:1.20.0.28
	gdb_6_5-2006-05-14-branchpoint:1.20
	binutils-csl-coldfire-4_1-10:1.20
	gdb-csl-sourcerygxx-4_1-5:1.20
	binutils-csl-sourcerygxx-4_1-5:1.20
	nickrob-async-20060513-branch:1.20.0.26
	nickrob-async-20060513-branchpoint:1.20
	gdb-csl-sourcerygxx-4_1-4:1.20
	binutils-csl-sourcerygxx-4_1-4:1.20
	msnyder-reverse-20060502-branch:1.20.0.24
	msnyder-reverse-20060502-branchpoint:1.20
	binutils-csl-wrs-linux-3_4_4-21:1.17
	gdb-csl-morpho-4_1-4:1.20
	binutils-csl-morpho-4_1-4:1.20
	gdb-csl-sourcerygxx-3_4_4-17:1.20
	binutils-csl-sourcerygxx-3_4_4-17:1.20
	binutils-csl-wrs-linux-3_4_4-20:1.17
	readline_5_1-import-branch:1.20.0.22
	readline_5_1-import-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.20
	binutils-2_17-branch:1.20.0.20
	binutils-2_17-branchpoint:1.20
	gdb-csl-symbian-20060226-branch:1.20.0.18
	gdb-csl-symbian-20060226-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.20
	msnyder-reverse-20060331-branch:1.20.0.16
	msnyder-reverse-20060331-branchpoint:1.20
	binutils-csl-2_17-branch:1.20.0.14
	binutils-csl-2_17-branchpoint:1.20
	gdb-csl-available-20060303-branch:1.20.0.12
	gdb-csl-available-20060303-branchpoint:1.20
	gdb-csl-20060226-branch:1.20.0.10
	gdb-csl-20060226-branchpoint:1.20
	gdb_6_4-20051202-release:1.20
	msnyder-fork-checkpoint-branch:1.20.0.8
	msnyder-fork-checkpoint-branchpoint:1.20
	gdb-csl-gxxpro-6_3-branch:1.20.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.20
	gdb_6_4-branch:1.20.0.4
	gdb_6_4-2005-11-01-branchpoint:1.20
	gdb-csl-arm-20051020-branch:1.20.0.2
	gdb-csl-arm-20051020-branchpoint:1.20
	binutils-csl-gxxpro-3_4-branch:1.17.0.10
	binutils-csl-gxxpro-3_4-branchpoint:1.17
	binutils-2_16_1:1.17
	msnyder-tracepoint-checkpoint-branch:1.18.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.18
	gdb-csl-arm-20050325-2005-q1b:1.17
	binutils-csl-arm-2005q1b:1.17
	binutils-2_16:1.17
	gdb-csl-arm-20050325-2005-q1a:1.17
	binutils-csl-arm-2005q1a:1.17
	csl-arm-20050325-branch:1.17.0.8
	csl-arm-20050325-branchpoint:1.17
	binutils-csl-arm-2005q1-branch:1.17.0.6
	binutils-csl-arm-2005q1-branchpoint:1.17
	binutils-2_16-branch:1.17.0.4
	binutils-2_16-branchpoint:1.17
	csl-arm-2004-q3d:1.17
	gdb_6_3-20041109-release:1.17
	gdb_6_3-branch:1.17.0.2
	gdb_6_3-20041019-branchpoint:1.17
	csl-arm-2004-q3:1.17
	drow_intercu-merge-20040921:1.17
	drow_intercu-merge-20040915:1.17
	jimb-gdb_6_2-e500-branch:1.16.0.6
	jimb-gdb_6_2-e500-branchpoint:1.16
	gdb_6_2-20040730-release:1.16
	gdb_6_2-branch:1.16.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.16
	gdb_6_1_1-20040616-release:1.15
	binutils-2_15:1.15
	binutils-2_15-branchpoint:1.15
	csl-arm-2004-q1a:1.16
	csl-arm-2004-q1:1.15
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.15
	drow_intercu-merge-20040327:1.15
	ezannoni_pie-20040323-branch:1.15.0.14
	ezannoni_pie-20040323-branchpoint:1.15
	cagney_tramp-20040321-mergepoint:1.15
	cagney_tramp-20040309-branch:1.15.0.12
	cagney_tramp-20040309-branchpoint:1.15
	gdb_6_1-branch:1.15.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.15.0.8
	drow_intercu-20040221-branchpoint:1.15
	binutils-2_15-branch:1.15.0.6
	cagney_bfdfile-20040213-branch:1.15.0.4
	cagney_bfdfile-20040213-branchpoint:1.15
	drow-cplus-merge-20040208:1.15
	carlton_dictionary-20040126-merge:1.15
	cagney_bigcore-20040122-branch:1.15.0.2
	cagney_bigcore-20040122-branchpoint:1.15
	drow-cplus-merge-20040113:1.15
	csl-arm-2003-q4:1.15
	drow-cplus-merge-20031224:1.15
	drow-cplus-merge-20031220:1.15
	carlton_dictionary-20031215-merge:1.15
	drow-cplus-merge-20031214:1.15
	carlton-dictionary-20031111-merge:1.14
	gdb_6_0-2003-10-04-release:1.14
	kettenis_sparc-20030918-branch:1.14.0.10
	kettenis_sparc-20030918-branchpoint:1.14
	carlton_dictionary-20030917-merge:1.14
	ezannoni_pie-20030916-branchpoint:1.14
	ezannoni_pie-20030916-branch:1.14.0.8
	cagney_x86i386-20030821-branch:1.14.0.6
	cagney_x86i386-20030821-branchpoint:1.14
	carlton_dictionary-20030805-merge:1.14
	carlton_dictionary-20030627-merge:1.14
	gdb_6_0-branch:1.14.0.4
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.14.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.14
	binutils-2_14:1.12
	cagney_convert-20030606-branch:1.13.0.2
	cagney_convert-20030606-branchpoint:1.13
	cagney_writestrings-20030508-branch:1.12.0.30
	cagney_writestrings-20030508-branchpoint:1.12
	jimb-ppc64-linux-20030528-branch:1.12.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.12
	carlton_dictionary-20030523-merge:1.12
	cagney_fileio-20030521-branch:1.12.0.26
	cagney_fileio-20030521-branchpoint:1.12
	kettenis_i386newframe-20030517-mergepoint:1.12
	jimb-ppc64-linux-20030509-branch:1.12.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.12
	kettenis_i386newframe-20030504-mergepoint:1.12
	carlton_dictionary-20030430-merge:1.12
	binutils-2_14-branch:1.12.0.22
	binutils-2_14-branchpoint:1.12
	kettenis_i386newframe-20030419-branch:1.12.0.20
	kettenis_i386newframe-20030419-branchpoint:1.12
	carlton_dictionary-20030416-merge:1.12
	cagney_frameaddr-20030409-mergepoint:1.12
	kettenis_i386newframe-20030406-branch:1.12.0.18
	kettenis_i386newframe-20030406-branchpoint:1.12
	cagney_frameaddr-20030403-branchpoint:1.12
	cagney_frameaddr-20030403-branch:1.12.0.16
	cagney_framebase-20030330-mergepoint:1.12
	cagney_framebase-20030326-branch:1.12.0.14
	cagney_framebase-20030326-branchpoint:1.12
	cagney_lazyid-20030317-branch:1.12.0.12
	cagney_lazyid-20030317-branchpoint:1.12
	kettenis-i386newframe-20030316-mergepoint:1.12
	offbyone-20030313-branch:1.12.0.10
	offbyone-20030313-branchpoint:1.12
	kettenis-i386newframe-20030308-branch:1.12.0.8
	kettenis-i386newframe-20030308-branchpoint:1.12
	carlton_dictionary-20030305-merge:1.12
	cagney_offbyone-20030303-branch:1.12.0.6
	cagney_offbyone-20030303-branchpoint:1.12
	carlton_dictionary-20030207-merge:1.12
	interps-20030202-branch:1.12.0.4
	interps-20030202-branchpoint:1.12
	cagney-unwind-20030108-branch:1.12.0.2
	cagney-unwind-20030108-branchpoint:1.12
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	carlton_dictionary-20021223-merge:1.12
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	binutils-2_13_1:1.10
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.14
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.12
	carlton_dictionary-20020920-branchpoint:1.10
	sid-20020905-branchpoint:1.10
	sid-20020905-branch:1.10.0.10
	gdb_5_3-branch:1.10.0.8
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.6
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.4
	readline_4_3-import-branchpoint:1.10
	binutils-2_13:1.10
	gdb_5_2_1-2002-07-23-release:1.9
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	kseitz_interps-20020528-branch:1.9.0.10
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.8
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.9
	jimb-macro-020506-branch:1.9.0.6
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	binutils-2_12:1.9
	gdb_5_2-branch:1.9.0.4
	gdb_5_2-2002-03-03-branchpoint:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.4
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.2
	gdb_5_1-2001-07-29-branchpoint:1.8
	binutils-2_11_2:1.7.2.1
	binutils-2_11_1:1.7.2.1
	binutils-2_11:1.7
	x86_64versiong3:1.7
	binutils-2_11-branch:1.7.0.2
	insight-precleanup-2001-01-01:1.7
	binutils-2_10_1:1.1.1.1.2.1
	binutils-2_10:1.1.1.1.2.1
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.25
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2012.08.01.00.41.34;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.27.04.07.55;	author amodra;	state Exp;
branches
	1.24.16.1;
next	1.23;

1.23
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.26.15.37.21;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.07.19.27.50;	author wilson;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.01.11.16.32;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.07.07.34.28;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.22.16.52.43;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.15.08.55.27;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.19.19.44.58;	author kazu;	state Exp;
branches
	1.15.8.1;
next	1.14;

1.14
date	2003.06.10.07.27.55;	author rsandifo;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.21.32.52;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches
	1.12.22.1;
next	1.11;

1.11
date	2002.11.18.16.52.46;	author kdienes;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.08.07.29.26;	author amodra;	state Exp;
branches
	1.10.12.1
	1.10.14.1;
next	1.9;

1.9
date	2001.08.26.11.47.39;	author aj;	state Exp;
branches
	1.9.8.1
	1.9.10.1;
next	1.8;

1.8
date	2001.03.13.22.58.35;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.03.21.52.37;	author nickc;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.06.12.22.23.25;	author law;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.02.18.09.28;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.01.18.19.59;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.30.18.35.32;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.14.04.16.58;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.24.16.1
date	2012.09.04.14.01.41;	author gingold;	state Exp;
branches;
next	;

1.15.8.1
date	2004.09.16.17.01.58;	author drow;	state Exp;
branches;
next	;

1.12.22.1
date	2003.07.12.07.35.40;	author rsandifo;	state Exp;
branches;
next	;

1.10.12.1
date	2002.12.23.19.39.31;	author carlton;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2003.06.27.21.50.26;	author carlton;	state Exp;
branches;
next	1.10.12.3;

1.10.12.3
date	2003.12.16.00.01.14;	author carlton;	state Exp;
branches;
next	;

1.10.14.1
date	2003.12.14.20.28.05;	author drow;	state Exp;
branches;
next	;

1.9.8.1
date	2002.06.15.16.43.20;	author cagney;	state Exp;
branches;
next	;

1.9.10.1
date	2002.06.20.01.38.29;	author kseitz;	state Exp;
branches;
next	;

1.7.2.1
date	2001.06.07.03.18.34;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.05.06.14.49.26;	author pb;	state Exp;
branches;
next	;


desc
@@


1.25
log
@	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@/* Disassemble h8300 instructions.
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2010  Free Software Foundation, Inc.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define DEFINE_TABLE

#include "sysdep.h"
#define h8_opcodes h8ops
#include "opcode/h8300.h"
#include "dis-asm.h"
#include "opintl.h"
#include "libiberty.h"

struct h8_instruction
{
  int length;
  const struct h8_opcode *opcode;
};

struct h8_instruction *h8_instructions;

/* Run through the opcodes and sort them into order to make them easy
   to disassemble.  */

static void
bfd_h8_disassemble_init (void)
{
  unsigned int i;
  unsigned int nopcodes;
  const struct h8_opcode *p;
  struct h8_instruction *pi;

  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);

  h8_instructions = xmalloc (nopcodes * sizeof (struct h8_instruction));

  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
    {
      /* Just make sure there are an even number of nibbles in it, and
	 that the count is the same as the length.  */
      for (i = 0; p->data.nib[i] != (op_type) E; i++)
	;

      if (i & 1)
	{
	  fprintf (stderr, "Internal error, h8_disassemble_init.\n");
	  abort ();
	}

      pi->length = i / 2;
      pi->opcode = p;
    }

  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->opcode = p;
}

static void
extract_immediate (FILE *stream,
		   op_type looking_for,
		   int thisnib,
		   unsigned char *data,
		   int *cst,
		   int *len,
		   const struct h8_opcode *q)
{
  switch (looking_for & SIZE)
    {
    case L_2:
      *len = 2;
      *cst = thisnib & 3;

      /* DISP2 special treatment.  */
      if ((looking_for & MODE) == DISP)
	{
	  if (OP_KIND (q->how) == O_MOVAB
	      || OP_KIND (q->how) == O_MOVAW
	      || OP_KIND (q->how) == O_MOVAL)
	    {
	      /* Handling for mova insn.  */
	      switch (q->args.nib[0] & MODE)
		{
		case INDEXB:
		default:
		  break;
		case INDEXW:
		  *cst *= 2;
		  break;
		case INDEXL:
		  *cst *= 4;
		  break;
		}
	    }
	  else
	    {
	      /* Handling for non-mova insn.  */
	      switch (OP_SIZE (q->how))
		{
		default: break;
		case SW:
		  *cst *= 2;
		  break;
		case SL:
		  *cst *= 4;
		  break;
		}
	    }
	}
      break;
    case L_8:
      *len = 8;
      *cst = data[0];
      break;
    case L_16:
    case L_16U:
      *len = 16;
      *cst = (data[0] << 8) + data [1];
#if 0
      if ((looking_for & SIZE) == L_16)
	*cst = (short) *cst;	/* Sign extend.  */
#endif
      break;
    case L_32:
      *len = 32;
      *cst = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
      break;
    default:
      *len = 0;
      *cst = 0;
      fprintf (stream, "DISP bad size\n");
      break;
    }
}

static const char *regnames[] =
{
  "r0h", "r1h", "r2h", "r3h", "r4h", "r5h", "r6h", "r7h",
  "r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l"
};
static const char *wregnames[] =
{
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7"
};
static const char *lregnames[] =
{
  "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7",
  "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7"
};
static const char *cregnames[] =
{
  "ccr", "exr", "mach", "macl", "", "", "vbr", "sbr"
};

static void
print_one_arg (disassemble_info *info,
	       bfd_vma addr,
	       op_type x,
	       int cst,
	       int cstlen,
	       int rdisp_n,
	       int rn,
	       const char **pregnames,
	       int len)
{
  void * stream = info->stream;
  fprintf_ftype outfn = info->fprintf_func;

  if ((x & SIZE) == L_3 || (x & SIZE) == L_3NZ)
    outfn (stream, "#0x%x", (unsigned) cst);
  else if ((x & MODE) == IMM)
    outfn (stream, "#0x%x", (unsigned) cst);
  else if ((x & MODE) == DBIT || (x & MODE) == KBIT)
    outfn (stream, "#%d", (unsigned) cst);
  else if ((x & MODE) == CONST_2)
    outfn (stream, "#2");
  else if ((x & MODE) == CONST_4)
    outfn (stream, "#4");
  else if ((x & MODE) == CONST_8)
    outfn (stream, "#8");
  else if ((x & MODE) == CONST_16)
    outfn (stream, "#16");
  else if ((x & MODE) == REG)
    {
      switch (x & SIZE)
	{
	case L_8:
	  outfn (stream, "%s", regnames[rn]);
	  break;
	case L_16:
	case L_16U:
	  outfn (stream, "%s", wregnames[rn]);
	  break;
	case L_P:
	case L_32:
	  outfn (stream, "%s", lregnames[rn]);
	  break;
	}
    }
  else if ((x & MODE) == LOWREG)
    {
      switch (x & SIZE)
	{
	case L_8:
	  /* Always take low half of reg.  */
	  outfn (stream, "%s.b", regnames[rn < 8 ? rn + 8 : rn]);
	  break;
	case L_16:
	case L_16U:
	  /* Always take low half of reg.  */
	  outfn (stream, "%s.w", wregnames[rn < 8 ? rn : rn - 8]);
	  break;
	case L_P:
	case L_32:
	  outfn (stream, "%s.l", lregnames[rn]);
	  break;
	}
    }
  else if ((x & MODE) == POSTINC)
    outfn (stream, "@@%s+", pregnames[rn]);

  else if ((x & MODE) == POSTDEC)
    outfn (stream, "@@%s-", pregnames[rn]);

  else if ((x & MODE) == PREINC)
    outfn (stream, "@@+%s", pregnames[rn]);

  else if ((x & MODE) == PREDEC)
    outfn (stream, "@@-%s", pregnames[rn]);

  else if ((x & MODE) == IND)
    outfn (stream, "@@%s", pregnames[rn]);

  else if ((x & MODE) == ABS || (x & ABSJMP))
    outfn (stream, "@@0x%x:%d", (unsigned) cst, cstlen);

  else if ((x & MODE) == MEMIND)
    outfn (stream, "@@@@%d (0x%x)", cst, cst);

  else if ((x & MODE) == VECIND)
    {
      /* FIXME Multiplier should be 2 or 4, depending on processor mode,
	 by which is meant "normal" vs. "middle", "advanced", "maximum".  */

      int offset = (cst + 0x80) * 4;
      outfn (stream, "@@@@%d (0x%x)", offset, offset);
    }
  else if ((x & MODE) == PCREL)
    {
      if ((x & SIZE) == L_16 ||
	  (x & SIZE) == L_16U)
	{
	  outfn (stream, ".%s%d (0x%lx)",
		   (short) cst > 0 ? "+" : "",
		   (short) cst, 
		   (long)(addr + (short) cst + len));
	}
      else
	{
	  outfn (stream, ".%s%d (0x%lx)",
		   (char) cst > 0 ? "+" : "",
		   (char) cst, 
		   (long)(addr + (char) cst + len));
	}
    }
  else if ((x & MODE) == DISP)
    outfn (stream, "@@(0x%x:%d,%s)", cst, cstlen, pregnames[rdisp_n]);

  else if ((x & MODE) == INDEXB)
    /* Always take low half of reg.  */
    outfn (stream, "@@(0x%x:%d,%s.b)", cst, cstlen, 
	   regnames[rdisp_n < 8 ? rdisp_n + 8 : rdisp_n]);

  else if ((x & MODE) == INDEXW)
    /* Always take low half of reg.  */
    outfn (stream, "@@(0x%x:%d,%s.w)", cst, cstlen, 
	   wregnames[rdisp_n < 8 ? rdisp_n : rdisp_n - 8]);

  else if ((x & MODE) == INDEXL)
    outfn (stream, "@@(0x%x:%d,%s.l)", cst, cstlen, lregnames[rdisp_n]);

  else if (x & CTRL)
    outfn (stream, "%s", cregnames[rn]);

  else if ((x & MODE) == CCR)
    outfn (stream, "ccr");

  else if ((x & MODE) == EXR)
    outfn (stream, "exr");

  else if ((x & MODE) == MACREG)
    outfn (stream, "mac%c", cst ? 'l' : 'h');

  else
    /* xgettext:c-format */
    outfn (stream, _("Hmmmm 0x%x"), x);
}

static unsigned int
bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)
{
  /* Find the first entry in the table for this opcode.  */
  int regno[3] = { 0, 0, 0 };
  int dispregno[3] = { 0, 0, 0 };
  int cst[3] = { 0, 0, 0 };
  int cstlen[3] = { 0, 0, 0 };
  static bfd_boolean init = 0;
  const struct h8_instruction *qi;
  char const **pregnames = mach != 0 ? lregnames : wregnames;
  int status;
  unsigned int l;
  unsigned char data[MAX_CODE_NIBBLES];
  void *stream = info->stream;
  fprintf_ftype outfn = info->fprintf_func;

  if (!init)
    {
      bfd_h8_disassemble_init ();
      init = 1;
    }

  status = info->read_memory_func (addr, data, 2, info);
  if (status != 0)
    {
      info->memory_error_func (status, addr, info);
      return -1;
    }

  for (l = 2; status == 0 && l < sizeof (data) / 2; l += 2)
    status = info->read_memory_func (addr + l, data + l, 2, info);

  /* Find the exact opcode/arg combo.  */
  for (qi = h8_instructions; qi->opcode->name; qi++)
    {
      const struct h8_opcode *q = qi->opcode;
      const op_type *nib = q->data.nib;
      unsigned int len = 0;

      while (1)
	{
	  op_type looking_for = *nib;
	  int thisnib = data[len / 2];
	  int opnr;

	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib / 16) & 0xf);
	  opnr = ((looking_for & OP3) == OP3 ? 2
		  : (looking_for & DST) == DST ? 1 : 0);

	  if (looking_for < 16 && looking_for >= 0)
	    {
	      if (looking_for != thisnib)
		goto fail;
	    }
	  else
	    {
	      if ((int) looking_for & (int) B31)
		{
		  if (!((thisnib & 0x8) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B31);
		  thisnib &= 0x7;
		}
	      else if ((int) looking_for & (int) B30)
		{
		  if (!((thisnib & 0x8) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B30);
		}

	      if ((int) looking_for & (int) B21)
		{
		  if (!((thisnib & 0x4) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B21);
		  thisnib &= 0xb;
		}
	      else if ((int) looking_for & (int) B20)
		{
		  if (!((thisnib & 0x4) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B20);
		}
	      if ((int) looking_for & (int) B11)
		{
		  if (!((thisnib & 0x2) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B11);
		  thisnib &= 0xd;
		}
	      else if ((int) looking_for & (int) B10)
		{
		  if (!((thisnib & 0x2) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B10);
		}

	      if ((int) looking_for & (int) B01)
		{
		  if (!((thisnib & 0x1) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B01);
		  thisnib &= 0xe;
		}
	      else if ((int) looking_for & (int) B00)
		{
		  if (!((thisnib & 0x1) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B00);
		}

	      if (looking_for & IGNORE)
		{
		  /* Hitachi has declared that IGNORE must be zero.  */
		  if (thisnib != 0)
		    goto fail;
		}
	      else if ((looking_for & MODE) == DATA)
		{
		  ;			/* Skip embedded data.  */
		}
	      else if ((looking_for & MODE) == DBIT)
		{
		  /* Exclude adds/subs by looking at bit 0 and 2, and
                     make sure the operand size, either w or l,
                     matches by looking at bit 1.  */
		  if ((looking_for & 7) != (thisnib & 7))
		    goto fail;

		  cst[opnr] = (thisnib & 0x8) ? 2 : 1;
		}
	      else if ((looking_for & MODE) == DISP
		       || (looking_for & MODE) == ABS
		       || (looking_for & MODE) == PCREL
		       || (looking_for & MODE) == INDEXB
		       || (looking_for & MODE) == INDEXW
		       || (looking_for & MODE) == INDEXL)
		{
		  extract_immediate (stream, looking_for, thisnib, 
				     data + len / 2, cst + opnr, 
				     cstlen + opnr, q);
		  /* Even address == bra, odd == bra/s.  */
		  if (q->how == O (O_BRAS, SB))
		    cst[opnr] -= 1;
		}
	      else if ((looking_for & MODE) == REG
		       || (looking_for & MODE) == LOWREG
		       || (looking_for & MODE) == IND
		       || (looking_for & MODE) == PREINC
		       || (looking_for & MODE) == POSTINC
		       || (looking_for & MODE) == PREDEC
		       || (looking_for & MODE) == POSTDEC)
		{
		  regno[opnr] = thisnib;
		}
	      else if (looking_for & CTRL)	/* Control Register.  */
		{
		  thisnib &= 7;
		  if (((looking_for & MODE) == CCR  && (thisnib != C_CCR))
		      || ((looking_for & MODE) == EXR  && (thisnib != C_EXR))
		      || ((looking_for & MODE) == MACH && (thisnib != C_MACH))
		      || ((looking_for & MODE) == MACL && (thisnib != C_MACL))
		      || ((looking_for & MODE) == VBR  && (thisnib != C_VBR))
		      || ((looking_for & MODE) == SBR  && (thisnib != C_SBR)))
		    goto fail;
		  if (((looking_for & MODE) == CCR_EXR
		       && (thisnib != C_CCR && thisnib != C_EXR))
		      || ((looking_for & MODE) == VBR_SBR
			  && (thisnib != C_VBR && thisnib != C_SBR))
		      || ((looking_for & MODE) == MACREG
			  && (thisnib != C_MACH && thisnib != C_MACL)))
		    goto fail;
		  if (((looking_for & MODE) == CC_EX_VB_SB
		       && (thisnib != C_CCR && thisnib != C_EXR
			   && thisnib != C_VBR && thisnib != C_SBR)))
		    goto fail;

		  regno[opnr] = thisnib;
		}
	      else if ((looking_for & SIZE) == L_5)
		{
		  cst[opnr] = data[len / 2] & 31;
		  cstlen[opnr] = 5;
		}
	      else if ((looking_for & SIZE) == L_4)
		{
		  cst[opnr] = thisnib;
		  cstlen[opnr] = 4;
		}
	      else if ((looking_for & SIZE) == L_16
		       || (looking_for & SIZE) == L_16U)
		{
		  cst[opnr] = (data[len / 2]) * 256 + data[(len + 2) / 2];
		  cstlen[opnr] = 16;
		}
	      else if ((looking_for & MODE) == MEMIND)
		{
		  cst[opnr] = data[1];
		}
	      else if ((looking_for & MODE) == VECIND)
		{
		  cst[opnr] = data[1] & 0x7f;
		}
	      else if ((looking_for & SIZE) == L_32)
		{
		  int i = len / 2;

		  cst[opnr] = ((data[i] << 24) 
			       | (data[i + 1] << 16) 
			       | (data[i + 2] << 8)
			       | (data[i + 3]));

		  cstlen[opnr] = 32;
		}
	      else if ((looking_for & SIZE) == L_24)
		{
		  int i = len / 2;

		  cst[opnr] = 
		    (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
		  cstlen[opnr] = 24;
		}
	      else if (looking_for & IGNORE)
		{
		  ;
		}
	      else if (looking_for & DISPREG)
		{
		  dispregno[opnr] = thisnib & 7;
		}
	      else if ((looking_for & MODE) == KBIT)
		{
		  switch (thisnib)
		    {
		    case 9:
		      cst[opnr] = 4;
		      break;
		    case 8:
		      cst[opnr] = 2;
		      break;
		    case 0:
		      cst[opnr] = 1;
		      break;
		    default:
		      goto fail;
		    }
		}
	      else if ((looking_for & SIZE) == L_8)
		{
		  cstlen[opnr] = 8;
		  cst[opnr] = data[len / 2];
		}
	      else if ((looking_for & SIZE) == L_3
		       || (looking_for & SIZE) == L_3NZ)
		{
		  cst[opnr] = thisnib & 0x7;
		  if (cst[opnr] == 0 && (looking_for & SIZE) == L_3NZ)
		    goto fail;
		}
	      else if ((looking_for & SIZE) == L_2)
		{
		  cstlen[opnr] = 2;
		  cst[opnr] = thisnib & 0x3;
		}
	      else if ((looking_for & MODE) == MACREG)
		{
		  cst[opnr] = (thisnib == 3);
		}
	      else if (looking_for == (op_type) E)
		{
		  outfn (stream, "%s\t", q->name);

		  /* Gross.  Disgusting.  */
		  if (strcmp (q->name, "ldm.l") == 0)
		    {
		      int count, high;

		      count = (data[1] / 16) & 0x3;
		      high = regno[1];

		      outfn (stream, "@@sp+,er%d-er%d", high - count, high);
		      return qi->length;
		    }

		  if (strcmp (q->name, "stm.l") == 0)
		    {
		      int count, low;

		      count = (data[1] / 16) & 0x3;
		      low = regno[0];

		      outfn (stream, "er%d-er%d,@@-sp", low, low + count);
		      return qi->length;
		    }
		  if (strcmp (q->name, "rte/l") == 0
		      || strcmp (q->name, "rts/l") == 0)
		    {
		      if (regno[0] == 0)
			outfn (stream, "er%d", regno[1]);
		      else
			outfn (stream, "er%d-er%d", regno[1] - regno[0],
			       regno[1]);
		      return qi->length;
		    }
		  if (CONST_STRNEQ (q->name, "mova"))
		    {
		      const op_type *args = q->args.nib;

		      if (args[1] == (op_type) E)
			{
			  /* Short form.  */
			  print_one_arg (info, addr, args[0], cst[0], 
					 cstlen[0], dispregno[0], regno[0], 
					 pregnames, qi->length);
			  outfn (stream, ",er%d", dispregno[0]);
			}
		      else
			{
			  outfn (stream, "@@(0x%x:%d,", cst[0], cstlen[0]);
			  print_one_arg (info, addr, args[1], cst[1], 
					 cstlen[1], dispregno[1], regno[1], 
					 pregnames, qi->length);
			  outfn (stream, ".%c),",
				 (args[0] & MODE) == INDEXB ? 'b' : 'w');
			  print_one_arg (info, addr, args[2], cst[2], 
					 cstlen[2], dispregno[2], regno[2], 
					 pregnames, qi->length);
			}
		      return qi->length;
		    }
		  /* Fill in the args.  */
		  {
		    const op_type *args = q->args.nib;
		    int hadone = 0;
		    int nargs;

		    /* Special case handling for the adds and subs instructions
		       since in H8 mode thay can only take the r0-r7 registers
		       but in other (higher) modes they can take the er0-er7
		       registers as well.  */
		    if (strcmp (qi->opcode->name, "adds") == 0
			|| strcmp (qi->opcode->name, "subs") == 0)
		      {
			outfn (stream, "#%d,%s", cst[0], pregnames[regno[1] & 0x7]);
			return qi->length;
		      }

		    for (nargs = 0; 
			 nargs < 3 && args[nargs] != (op_type) E;
			 nargs++)
		      {
			int x = args[nargs];

			if (hadone)
			  outfn (stream, ",");

			print_one_arg (info, addr, x,
				       cst[nargs], cstlen[nargs],
				       dispregno[nargs], regno[nargs],
				       pregnames, qi->length);

			hadone = 1;
		      }
		  }

		  return qi->length;
		}
	      else
		/* xgettext:c-format */
		outfn (stream, _("Don't understand 0x%x \n"), looking_for);
	    }

	  len++;
	  nib++;
	}

    fail:
      ;
    }

  /* Fell off the end.  */
  outfn (stream, ".word\tH'%x,H'%x", data[0], data[1]);
  return 2;
}

int
print_insn_h8300 (bfd_vma addr, disassemble_info *info)
{
  return bfd_h8_disassemble (addr, info, 0);
}

int
print_insn_h8300h (bfd_vma addr, disassemble_info *info)
{
  return bfd_h8_disassemble (addr, info, 1);
}

int
print_insn_h8300s (bfd_vma addr, disassemble_info *info)
{
  return bfd_h8_disassemble (addr, info, 2);
}
@


1.24
log
@fix set but unused variable warnings
@
text
@d301 1
a301 1
    outfn (stream, cregnames[rn]);
@


1.24.16.1
log
@gas/
	* config/tc-mips.c (ISA_SUPPORTS_DSP_ASE): Also set if microMIPS
	mode.
	(ISA_SUPPORTS_DSPR2_ASE): Likewise.
	(macro_build) <'2'>: Handle microMIPS.
2012-07-31  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>

gas/
	* gas/mips/micromips@@mips32-dsp.d: New test.
	* gas/mips/micromips@@mips32-dspr2.d: New test.
	* gas/mips/mips32-dsp.s: Update padding.
	* gas/mips/mips32-dspr2.s: Likewise.
	* gas/mips/mips.exp: Use run_dump_test_arches to run MIPS32 DSP
	tests.
2012-07-31  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

include/
2012-07-31  Chao-Ying Fu  <fu@@mips.com>
            Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

opcodes/
2012-08-01  Alan Modra  <amodra@@gmail.com>

	* h8300-dis.c: Fix printf arg warnings.
	* i960-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* pdp11-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* configure.in: Formatting.
	* configure: Regenerate.
	* rl78-decode.c: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d301 1
a301 1
    outfn (stream, "%s", cregnames[rn]);
@


1.23
log
@Change source files over to GPLv3.
@
text
@d3 1
a3 1
   2007  Free Software Foundation, Inc.
a55 13
      int n1 = 0;
      int n2 = 0;

      if ((int) p->data.nib[0] < 16)
	n1 = (int) p->data.nib[0];
      else
	n1 = 0;

      if ((int) p->data.nib[1] < 16)
	n2 = (int) p->data.nib[1];
      else
	n2 = 0;

@


1.22
log
@	* h8300-dis.c (bfd_h8_disassemble): Add missing consts.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2006
   Free Software Foundation, Inc.
d5 3
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.21
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d365 1
a365 1
      op_type *nib = q->data.nib;
d643 1
a643 1
		      op_type *args = q->args.nib;
d669 1
a669 1
		    op_type *args = q->args.nib;
@


1.20
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005
d641 1
a641 1
		  if (strncmp (q->name, "mova", 4) == 0)
@


1.19
log
@Update function declarations to ISO C90 formatting
@
text
@d282 1
a282 1
	  outfn (stream, ".%s%d (0x%x)",
d285 1
a285 1
		   addr + (short) cst + len);
d289 1
a289 1
	  outfn (stream, ".%s%d (0x%x)",
d292 1
a292 1
		   addr + (char) cst + len);
@


1.18
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002, 2003, 2004
d17 2
a18 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a36 12
static void bfd_h8_disassemble_init PARAMS ((void));
static void print_one_arg PARAMS ((disassemble_info *, bfd_vma, op_type,
				   int, int, int, int, const char **, int));
static unsigned int bfd_h8_disassemble PARAMS ((bfd_vma, 
						disassemble_info *, 
						int));
static void extract_immediate PARAMS ((FILE *, 
				       op_type, int, 
				       unsigned char *,
				       int *, int *,
				       const struct h8_opcode *));

d41 1
a41 1
bfd_h8_disassemble_init ()
d50 1
a50 2
  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));
d88 7
a94 7
extract_immediate (stream, looking_for, thisnib, data, cst, len, q)
     FILE *stream;
     op_type looking_for;
     int thisnib;
     unsigned char *data;
     int *cst, *len;
     const struct h8_opcode *q;
d105 3
a107 3
	  if (OP_KIND (q->how) == O_MOVAB ||
	      OP_KIND (q->how) == O_MOVAW ||
	      OP_KIND (q->how) == O_MOVAL)
d110 12
a121 11
	      switch (q->args.nib[0] & MODE) {
	      case INDEXB:
	      default:
		break;
	      case INDEXW:
		*cst *= 2;
		break;
	      case INDEXL:
		*cst *= 4;
		break;
	      }
d126 10
a135 9
	      switch (OP_SIZE (q->how)) {
	      default: break;
	      case SW:
		*cst *= 2;
		break;
	      case SL:
		*cst *= 4;
		break;
	      }
d149 1
a149 1
	*cst = (short) *cst;	/* sign extend */
d185 9
a193 7
print_one_arg (info, addr, x, cst, cstlen, rdisp_n, rn, pregnames, len)
     disassemble_info *info;
     bfd_vma addr;
     op_type x;
     int cst, cstlen, rdisp_n, rn;
     const char **pregnames;
     int len;
d195 1
a195 1
  void *stream = info->stream;
d198 2
a199 5
  if ((x & SIZE) == L_3 ||
      (x & SIZE) == L_3NZ)
    {
      outfn (stream, "#0x%x", (unsigned) cst);
    }
d201 3
a203 8
    {
      outfn (stream, "#0x%x", (unsigned) cst);
    }
  else if ((x & MODE) == DBIT  ||
	   (x & MODE) == KBIT)
    {
      outfn (stream, "#%d", (unsigned) cst);
    }
d249 2
a250 3
    {
      outfn (stream, "@@%s+", pregnames[rn]);
    }
d252 2
a253 3
    {
      outfn (stream, "@@%s-", pregnames[rn]);
    }
d255 2
a256 3
    {
      outfn (stream, "@@+%s", pregnames[rn]);
    }
d258 2
a259 3
    {
      outfn (stream, "@@-%s", pregnames[rn]);
    }
d261 2
a262 3
    {
      outfn (stream, "@@%s", pregnames[rn]);
    }
d264 2
a265 3
    {
      outfn (stream, "@@0x%x:%d", (unsigned) cst, cstlen);
    }
d267 2
a268 3
    {
      outfn (stream, "@@@@%d (0x%x)", cst, cst);
    }
d296 2
a297 4
    {
      outfn (stream, "@@(0x%x:%d,%s)", cst, cstlen, 
	       pregnames[rdisp_n]);
    }
d299 4
a302 5
    {
      /* Always take low half of reg.  */
      outfn (stream, "@@(0x%x:%d,%s.b)", cst, cstlen, 
	     regnames[rdisp_n < 8 ? rdisp_n + 8 : rdisp_n]);
    }
d304 4
a307 5
    {
      /* Always take low half of reg.  */
      outfn (stream, "@@(0x%x:%d,%s.w)", cst, cstlen, 
	       wregnames[rdisp_n < 8 ? rdisp_n : rdisp_n - 8]);
    }
d309 2
a310 4
    {
      outfn (stream, "@@(0x%x:%d,%s.l)", cst, cstlen, 
	       lregnames[rdisp_n]);
    }
d312 2
a313 3
    {
      outfn (stream, cregnames[rn]);
    }
d315 2
a316 3
    {
      outfn (stream, "ccr");
    }
d318 2
a319 3
    {
      outfn (stream, "exr");
    }
d321 2
a322 3
    {
      outfn (stream, "mac%c", cst ? 'l' : 'h');
    }
d329 1
a329 4
bfd_h8_disassemble (addr, info, mach)
     bfd_vma addr;
     disassemble_info *info;
     int mach;
d468 6
a473 6
	      else if ((looking_for & MODE) == DISP  ||
		       (looking_for & MODE) == ABS   ||
		       (looking_for & MODE) == PCREL ||
		       (looking_for & MODE) == INDEXB ||
		       (looking_for & MODE) == INDEXW ||
		       (looking_for & MODE) == INDEXL)
d482 7
a488 7
	      else if ((looking_for & MODE) == REG     ||
		       (looking_for & MODE) == LOWREG  ||
		       (looking_for & MODE) == IND     ||
		       (looking_for & MODE) == PREINC  ||
		       (looking_for & MODE) == POSTINC ||
		       (looking_for & MODE) == PREDEC  ||
		       (looking_for & MODE) == POSTDEC)
d492 1
a492 1
	      else if (looking_for & CTRL)	/* Control Register */
d495 17
a511 17
		  if (((looking_for & MODE) == CCR  && (thisnib != C_CCR))  ||
		      ((looking_for & MODE) == EXR  && (thisnib != C_EXR))  ||
		      ((looking_for & MODE) == MACH && (thisnib != C_MACH)) ||
		      ((looking_for & MODE) == MACL && (thisnib != C_MACL)) ||
		      ((looking_for & MODE) == VBR  && (thisnib != C_VBR))  ||
		      ((looking_for & MODE) == SBR  && (thisnib != C_SBR)))
		    goto fail;
		  if (((looking_for & MODE) == CCR_EXR && 
		       (thisnib != C_CCR && thisnib != C_EXR)) ||
		      ((looking_for & MODE) == VBR_SBR && 
		       (thisnib != C_VBR && thisnib != C_SBR)) ||
		      ((looking_for & MODE) == MACREG && 
		       (thisnib != C_MACH && thisnib != C_MACL)))
		    goto fail;
		  if (((looking_for & MODE) == CC_EX_VB_SB && 
		       (thisnib != C_CCR && thisnib != C_EXR &&
			thisnib != C_VBR && thisnib != C_SBR)))
d526 2
a527 2
	      else if ((looking_for & SIZE) == L_16 ||
		       (looking_for & SIZE) == L_16U)
d589 2
a590 2
	      else if ((looking_for & SIZE) == L_3 ||
		       (looking_for & SIZE) == L_3NZ)
d637 2
a638 4
			{
			  outfn (stream, "er%d-er%d", regno[1] - regno[0],
				 regno[1]);
			}
d674 3
a676 3
		       since in H8 mode thay can only take the r0-r7 registers but
		       in other (higher) modes they can take the er0-er7 registers
		       as well.  */
d685 1
a685 1
			 nargs < 3 && args[nargs] != (op_type) E; 
d723 1
a723 3
print_insn_h8300 (addr, info)
     bfd_vma addr;
     disassemble_info *info;
d729 1
a729 3
print_insn_h8300h (addr, info)
     bfd_vma addr;
     disassemble_info *info;
d735 1
a735 3
print_insn_h8300s (addr, info)
     bfd_vma addr;
     disassemble_info *info;
@


1.17
log
@Fix for PR 280 - remove duplicated raw insn output fron h8300/h8500 disassemblers
@
text
@d17 1
a17 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.16
log
@Treat adds and subs as a special case
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002, 2003
d5 13
a17 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a642 8
		  int i;

		  for (i = 0; i < qi->length; i++)
		    outfn (stream, "%02x ", data[i]);

		  for (; i < 6; i++)
		    outfn (stream, "   ");

d756 1
a756 3
  outfn (stream, "%02x %02x        .word\tH'%x,H'%x",
	   data[0], data[1],
	   data[0], data[1]);
@


1.15
log
@	* h8300-dis.c (print_colon_thingie): Remove.
@
text
@d719 11
@


1.15.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002, 2003, 2004
d5 13
a17 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d643 8
a718 11
		    /* Special case handling for the adds and subs instructions
		       since in H8 mode thay can only take the r0-r7 registers but
		       in other (higher) modes they can take the er0-er7 registers
		       as well.  */
		    if (strcmp (qi->opcode->name, "adds") == 0
			|| strcmp (qi->opcode->name, "subs") == 0)
		      {
			outfn (stream, "#%d,%s", cst[0], pregnames[regno[1] & 0x7]);
			return qi->length;
		      }

d753 3
a755 1
  outfn (stream, ".word\tH'%x,H'%x", data[0], data[1]);
@


1.14
log
@opcodes/
	* h8300-dis.c (bfd_h8_disassemble): Don't print brackets round
	rts/l and rte/l register lists.

gas/
	* config/tc-h8300.c (get_rtsl_operands): Accept unbracketed register
	lists.  Allow single-register ranges.

testsuite/
	* gas/h8300/h8sx_rtsl.[sd]: New test.
	* gas/h8300/h8300.exp: Run it.
@
text
@a47 19
static void print_colon_thingie PARAMS ((op_type *));

static void
print_colon_thingie (op_type *nib)
{
  switch (*nib & SIZE) {
  case L_2:	fprintf (stdout, "2");	break;
  case L_3:
  case L_3NZ:	fprintf (stdout, "3");	break;
  case L_4:	fprintf (stdout, "4");	break;
  case L_5:	fprintf (stdout, "5");	break;
  case L_8:	fprintf (stdout, "8");	break;
  case L_16:
  case L_16U:	fprintf (stdout, "16");	break;
  case L_24:	fprintf (stdout, "24");	break;
  case L_32:	fprintf (stdout, "32");	break;
  }
}

@


1.13
log
@2003-06-03  Michael Snyder  <msnyder@@redhat.com>
	and Bernd Schmidt   <bernds@@redhat.com>
	and Alexandre Oliva <aoliva@@redhat.com>
	* disassemble.c (disassembler): Add support for h8300sx.
	* h8300-dis.c: Ditto.
@
text
@d701 1
a701 1
			  outfn (stream, "(er%d-er%d)", regno[1] - regno[0],
@


1.12
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002
d37 29
a65 2
static unsigned int bfd_h8_disassemble
  PARAMS ((bfd_vma, disassemble_info *, int));
d69 1
d100 1
a100 1
      for (i = 0; p->data.nib[i] != E; i++)
d104 4
a107 1
	abort ();
d118 262
d381 1
a381 1
bfd_h8_disassemble (addr, info, mode)
d384 1
a384 1
     int mode;
d387 4
a390 21
  static const char *regnames[] =
    {
      "r0h", "r1h", "r2h", "r3h", "r4h", "r5h", "r6h", "r7h",
      "r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l"
    };
  static const char *wregnames[] =
    {
      "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
      "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7"
    };
  static const char *lregnames[] =
    {
      "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7",
      "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7"
    };
  int rs = 0;
  int rd = 0;
  int rdisp = 0;
  int abs = 0;
  int bit = 0;
  int plen = 0;
d393 1
a393 1
  char const **pregnames = mode != 0 ? lregnames : wregnames;
d395 2
a396 2
  int l;
  unsigned char data[20];
d398 1
a398 1
  fprintf_ftype fprintf = info->fprintf_func;
d413 1
a413 1
  for (l = 2; status == 0 && l < 10; l += 2)
d426 2
a427 1
	  int thisnib = data[len >> 1];
d429 3
a431 1
	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib >> 4) & 0xf);
d442 1
a442 1
		  if (!(((int) thisnib & 0x8) != 0))
d446 39
d487 1
a487 1
	      if ((int) looking_for & (int) B30)
d489 1
a489 1
		  if (!(((int) thisnib & 0x8) == 0))
d492 9
a500 1
		  looking_for = (op_type) ((int) looking_for & ~(int) B30);
d503 11
a513 1
	      if (looking_for & DBIT)
d521 1
a521 1
		  abs = (thisnib & 0x8) ? 2 : 1;
d523 49
a571 1
	      else if (looking_for & (REG | IND | INC | DEC))
d573 2
a574 4
		  if (looking_for & SRC)
		    rs = thisnib;
		  else
		    rd = thisnib;
d576 1
a576 1
	      else if (looking_for & L_16)
d578 2
a579 2
		  abs = (data[len >> 1]) * 256 + data[(len + 2) >> 1];
		  plen = 16;
d581 2
a582 1
	      else if (looking_for & ABSJMP)
d584 2
a585 1
		  abs = (data[1] << 16) | (data[2] << 8) | (data[3]);
d587 1
a587 1
	      else if (looking_for & MEMIND)
d589 1
a589 1
		  abs = data[1];
d591 1
a591 1
	      else if (looking_for & L_32)
d593 5
a597 1
		  int i = len >> 1;
d599 4
a602 4
		  abs = (data[i] << 24)
		    | (data[i + 1] << 16)
		    | (data[i + 2] << 8)
		    | (data[i + 3]);
d604 1
a604 1
		  plen = 32;
d606 1
a606 1
	      else if (looking_for & L_24)
d608 1
a608 1
		  int i = len >> 1;
d610 3
a612 2
		  abs = (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
		  plen = 24;
d620 1
a620 1
		  rdisp = thisnib;
d622 1
a622 1
	      else if (looking_for & KBIT)
d627 1
a627 1
		      abs = 4;
d630 1
a630 1
		      abs = 2;
d633 1
a633 1
		      abs = 1;
d639 1
a639 1
	      else if (looking_for & L_8)
d641 2
a642 2
		  plen = 8;
		  abs = data[len >> 1];
d644 2
a645 1
	      else if (looking_for & L_3)
d647 3
a649 1
		  bit = thisnib & 0x7;
d651 1
a651 1
	      else if (looking_for & L_2)
d653 2
a654 2
		  plen = 2;
		  abs = thisnib & 0x3;
d656 1
a656 1
	      else if (looking_for & MACREG)
d658 1
a658 1
		  abs = (thisnib == 3);
d660 1
a660 1
	      else if (looking_for == E)
d665 1
a665 1
		    fprintf (stream, "%02x ", data[i]);
d668 1
a668 1
		    fprintf (stream, "   ");
d670 1
a670 1
		  fprintf (stream, "%s\t", q->name);
d677 2
a678 2
		      count = (data[1] >> 4) & 0x3;
		      high = data[3] & 0x7;
d680 1
a680 1
		      fprintf (stream, "@@sp+,er%d-er%d", high - count, high);
d688 2
a689 2
		      count = (data[1] >> 4) & 0x3;
		      low = data[3] & 0x7;
d691 13
a703 1
		      fprintf (stream, "er%d-er%d,@@-sp", low, low + count);
d706 3
d710 22
d736 1
d738 3
a740 1
		    while (*args != E)
d742 1
a742 1
			int x = *args;
d745 1
a745 1
			  fprintf (stream, ",");
d747 4
a750 93
			if (x & L_3)
			  {
			    fprintf (stream, "#0x%x", (unsigned) bit);
			  }
			else if (x & (IMM | KBIT | DBIT))
			  {
			    /* Bletch.  For shal #2,er0 and friends.  */
			    if (*(args + 1) & SRC_IN_DST)
			      abs = 2;

			    fprintf (stream, "#0x%x", (unsigned) abs);
			  }
			else if (x & REG)
			  {
			    int rn = (x & DST) ? rd : rs;

			    switch (x & SIZE)
			      {
			      case L_8:
				fprintf (stream, "%s", regnames[rn]);
				break;
			      case L_16:
				fprintf (stream, "%s", wregnames[rn]);
				break;
			      case L_P:
			      case L_32:
				fprintf (stream, "%s", lregnames[rn]);
				break;
			      }
			  }
			else if (x & MACREG)
			  {
			    fprintf (stream, "mac%c", abs ? 'l' : 'h');
			  }
			else if (x & INC)
			  {
			    fprintf (stream, "@@%s+", pregnames[rs]);
			  }
			else if (x & DEC)
			  {
			    fprintf (stream, "@@-%s", pregnames[rd]);
			  }
			else if (x & IND)
			  {
			    int rn = (x & DST) ? rd : rs;
			    fprintf (stream, "@@%s", pregnames[rn]);
			  }
			else if (x & ABS8MEM)
			  {
			    fprintf (stream, "@@0x%x:8", (unsigned) abs);
			  }
			else if (x & (ABS | ABSJMP))
			  {
			    fprintf (stream, "@@0x%x:%d", (unsigned) abs, plen);
			  }
			else if (x & MEMIND)
			  {
			    fprintf (stream, "@@@@%d (%x)", abs, abs);
			  }
			else if (x & PCREL)
			  {
			    if (x & L_16)
			      {
				abs += 2;
				fprintf (stream,
					 ".%s%d (%x)",
					 (short) abs > 0 ? "+" : "",
					 (short) abs, addr + (short) abs + 2);
			      }
			    else
			      {
				fprintf (stream,
					 ".%s%d (%x)",
					 (char) abs > 0 ? "+" : "",
					 (char) abs, addr + (char) abs + 2);
			      }
			  }
			else if (x & DISP)
			  {
			    fprintf (stream, "@@(0x%x:%d,%s)",
				     abs, plen, pregnames[rdisp]);
			  }
			else if (x & CCR)
			  {
			    fprintf (stream, "ccr");
			  }
			else if (x & EXR)
			  {
			    fprintf (stream, "exr");
			  }
			else
			  /* xgettext:c-format */
			  fprintf (stream, _("Hmmmm %x"), x);
a752 1
			args++;
d760 1
a760 1
		fprintf (stream, _("Don't understand %x \n"), looking_for);
d772 1
a772 1
  fprintf (stream, "%02x %02x        .word\tH'%x,H'%x",
@


1.12.22.1
log
@	* h8300-dis.c (bfd_h8_disassemble): Mask off the high bit of rs and rd
	for INC and DEC operands.
@
text
@d351 1
a351 1
			    fprintf (stream, "@@%s+", pregnames[rs & 7]);
d355 1
a355 1
			    fprintf (stream, "@@-%s", pregnames[rd & 7]);
@


1.11
log
@2002-11-11  Klee Dienes  <kdienes@@apple.com>

	* h8300.h (h8_opcode): Remove 'length' field.
	(h8_opcodes): Mark as 'const' (both the declaration and
	definition).  Modify initializer and initializer macros to no
	longer initialize the length field.

2002-11-11  Klee Dienes  <kdienes@@apple.com>

	* h8300-dis.c: Include libiberty.h (for xmalloc).
	(struct h8_instruction): New type, used to wrap h8_opcodes with a
	length field (computed at run-time).
	(h8_instructions): New variable.
	(bfd_h8_disassemble_init): Allocate the storage for
	h8_instructions.  Fill h8_instructions with pointers to the
	appropriate opcode and the correct value for the length field.
	(bfd_h8_disassemble): Iterate through h8_instructions instead of
	h8_opcodes.
@
text
@d51 1
a51 1
  
d115 1
a115 1
  static boolean init = 0;
@


1.10
log
@	* a29k-dis.c: Replace CONST with const.
	* h8300-dis.c: Likewise.
	* m68k-dis.c: Likewise.
	* or32-dis.c: Likewise.
	* sparc-dis.c: Likewise.
@
text
@d26 9
d46 8
a53 1
  struct h8_opcode *p;
d55 1
a55 1
  for (p = h8_opcodes; p->name; p++)
d78 2
a79 1
      p->length = i / 2;
d81 4
d116 1
a116 1
  struct h8_opcode *q;
d141 1
a141 1
  for (q = h8_opcodes; q->name; q++)
d143 1
d272 1
a272 1
		  for (i = 0; i < q->length; i++)
d289 1
a289 1
		      return q->length;
d300 1
a300 1
		      return q->length;
d414 1
a414 1
		  return q->length;
@


1.10.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002, 2003
a25 9
#include "libiberty.h"

struct h8_instruction
{
  int length;
  const struct h8_opcode *opcode;
};

struct h8_instruction *h8_instructions;
d28 2
a29 10
static void print_one_arg PARAMS ((disassemble_info *, bfd_vma, op_type,
				   int, int, int, int, const char **, int));
static unsigned int bfd_h8_disassemble PARAMS ((bfd_vma, 
						disassemble_info *, 
						int));
static void extract_immediate PARAMS ((FILE *, 
				       op_type, int, 
				       unsigned char *,
				       int *, int *,
				       const struct h8_opcode *));
a32 1

d37 1
a37 5
  unsigned int nopcodes;
  const struct h8_opcode *p;
  struct h8_instruction *pi;

  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);
d39 1
a39 4
  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));

  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
d56 1
a56 1
      for (i = 0; p->data.nib[i] != (op_type) E; i++)
d60 1
a60 4
	{
	  fprintf (stderr, "Internal error, h8_disassemble_init.\n");
	  abort ();
	}
d62 1
a62 81
      pi->length = i / 2;
      pi->opcode = p;
    }

  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->opcode = p;
}

static void
extract_immediate (stream, looking_for, thisnib, data, cst, len, q)
     FILE *stream;
     op_type looking_for;
     int thisnib;
     unsigned char *data;
     int *cst, *len;
     const struct h8_opcode *q;
{
  switch (looking_for & SIZE)
    {
    case L_2:
      *len = 2;
      *cst = thisnib & 3;

      /* DISP2 special treatment.  */
      if ((looking_for & MODE) == DISP)
	{
	  if (OP_KIND (q->how) == O_MOVAB ||
	      OP_KIND (q->how) == O_MOVAW ||
	      OP_KIND (q->how) == O_MOVAL)
	    {
	      /* Handling for mova insn.  */
	      switch (q->args.nib[0] & MODE) {
	      case INDEXB:
	      default:
		break;
	      case INDEXW:
		*cst *= 2;
		break;
	      case INDEXL:
		*cst *= 4;
		break;
	      }
	    }
	  else
	    {
	      /* Handling for non-mova insn.  */
	      switch (OP_SIZE (q->how)) {
	      default: break;
	      case SW:
		*cst *= 2;
		break;
	      case SL:
		*cst *= 4;
		break;
	      }
	    }
	}
      break;
    case L_8:
      *len = 8;
      *cst = data[0];
      break;
    case L_16:
    case L_16U:
      *len = 16;
      *cst = (data[0] << 8) + data [1];
#if 0
      if ((looking_for & SIZE) == L_16)
	*cst = (short) *cst;	/* sign extend */
#endif
      break;
    case L_32:
      *len = 32;
      *cst = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
      break;
    default:
      *len = 0;
      *cst = 0;
      fprintf (stream, "DISP bad size\n");
      break;
a65 187
static const char *regnames[] =
{
  "r0h", "r1h", "r2h", "r3h", "r4h", "r5h", "r6h", "r7h",
  "r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l"
};
static const char *wregnames[] =
{
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7"
};
static const char *lregnames[] =
{
  "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7",
  "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7"
};
static const char *cregnames[] =
{
  "ccr", "exr", "mach", "macl", "", "", "vbr", "sbr"
};

static void
print_one_arg (info, addr, x, cst, cstlen, rdisp_n, rn, pregnames, len)
     disassemble_info *info;
     bfd_vma addr;
     op_type x;
     int cst, cstlen, rdisp_n, rn;
     const char **pregnames;
     int len;
{
  void *stream = info->stream;
  fprintf_ftype outfn = info->fprintf_func;

  if ((x & SIZE) == L_3 ||
      (x & SIZE) == L_3NZ)
    {
      outfn (stream, "#0x%x", (unsigned) cst);
    }
  else if ((x & MODE) == IMM)
    {
      outfn (stream, "#0x%x", (unsigned) cst);
    }
  else if ((x & MODE) == DBIT  ||
	   (x & MODE) == KBIT)
    {
      outfn (stream, "#%d", (unsigned) cst);
    }
  else if ((x & MODE) == CONST_2)
    outfn (stream, "#2");
  else if ((x & MODE) == CONST_4)
    outfn (stream, "#4");
  else if ((x & MODE) == CONST_8)
    outfn (stream, "#8");
  else if ((x & MODE) == CONST_16)
    outfn (stream, "#16");
  else if ((x & MODE) == REG)
    {
      switch (x & SIZE)
	{
	case L_8:
	  outfn (stream, "%s", regnames[rn]);
	  break;
	case L_16:
	case L_16U:
	  outfn (stream, "%s", wregnames[rn]);
	  break;
	case L_P:
	case L_32:
	  outfn (stream, "%s", lregnames[rn]);
	  break;
	}
    }
  else if ((x & MODE) == LOWREG)
    {
      switch (x & SIZE)
	{
	case L_8:
	  /* Always take low half of reg.  */
	  outfn (stream, "%s.b", regnames[rn < 8 ? rn + 8 : rn]);
	  break;
	case L_16:
	case L_16U:
	  /* Always take low half of reg.  */
	  outfn (stream, "%s.w", wregnames[rn < 8 ? rn : rn - 8]);
	  break;
	case L_P:
	case L_32:
	  outfn (stream, "%s.l", lregnames[rn]);
	  break;
	}
    }
  else if ((x & MODE) == POSTINC)
    {
      outfn (stream, "@@%s+", pregnames[rn]);
    }
  else if ((x & MODE) == POSTDEC)
    {
      outfn (stream, "@@%s-", pregnames[rn]);
    }
  else if ((x & MODE) == PREINC)
    {
      outfn (stream, "@@+%s", pregnames[rn]);
    }
  else if ((x & MODE) == PREDEC)
    {
      outfn (stream, "@@-%s", pregnames[rn]);
    }
  else if ((x & MODE) == IND)
    {
      outfn (stream, "@@%s", pregnames[rn]);
    }
  else if ((x & MODE) == ABS || (x & ABSJMP))
    {
      outfn (stream, "@@0x%x:%d", (unsigned) cst, cstlen);
    }
  else if ((x & MODE) == MEMIND)
    {
      outfn (stream, "@@@@%d (0x%x)", cst, cst);
    }
  else if ((x & MODE) == VECIND)
    {
      /* FIXME Multiplier should be 2 or 4, depending on processor mode,
	 by which is meant "normal" vs. "middle", "advanced", "maximum".  */

      int offset = (cst + 0x80) * 4;
      outfn (stream, "@@@@%d (0x%x)", offset, offset);
    }
  else if ((x & MODE) == PCREL)
    {
      if ((x & SIZE) == L_16 ||
	  (x & SIZE) == L_16U)
	{
	  outfn (stream, ".%s%d (0x%x)",
		   (short) cst > 0 ? "+" : "",
		   (short) cst, 
		   addr + (short) cst + len);
	}
      else
	{
	  outfn (stream, ".%s%d (0x%x)",
		   (char) cst > 0 ? "+" : "",
		   (char) cst, 
		   addr + (char) cst + len);
	}
    }
  else if ((x & MODE) == DISP)
    {
      outfn (stream, "@@(0x%x:%d,%s)", cst, cstlen, 
	       pregnames[rdisp_n]);
    }
  else if ((x & MODE) == INDEXB)
    {
      /* Always take low half of reg.  */
      outfn (stream, "@@(0x%x:%d,%s.b)", cst, cstlen, 
	     regnames[rdisp_n < 8 ? rdisp_n + 8 : rdisp_n]);
    }
  else if ((x & MODE) == INDEXW)
    {
      /* Always take low half of reg.  */
      outfn (stream, "@@(0x%x:%d,%s.w)", cst, cstlen, 
	       wregnames[rdisp_n < 8 ? rdisp_n : rdisp_n - 8]);
    }
  else if ((x & MODE) == INDEXL)
    {
      outfn (stream, "@@(0x%x:%d,%s.l)", cst, cstlen, 
	       lregnames[rdisp_n]);
    }
  else if (x & CTRL)
    {
      outfn (stream, cregnames[rn]);
    }
  else if ((x & MODE) == CCR)
    {
      outfn (stream, "ccr");
    }
  else if ((x & MODE) == EXR)
    {
      outfn (stream, "exr");
    }
  else if ((x & MODE) == MACREG)
    {
      outfn (stream, "mac%c", cst ? 'l' : 'h');
    }
  else
    /* xgettext:c-format */
    outfn (stream, _("Hmmmm 0x%x"), x);
}

d67 1
a67 1
bfd_h8_disassemble (addr, info, mach)
d70 1
a70 1
     int mach;
d73 24
a96 7
  int regno[3] = { 0, 0, 0 };
  int dispregno[3] = { 0, 0, 0 };
  int cst[3] = { 0, 0, 0 };
  int cstlen[3] = { 0, 0, 0 };
  static bfd_boolean init = 0;
  const struct h8_instruction *qi;
  char const **pregnames = mach != 0 ? lregnames : wregnames;
d98 2
a99 2
  unsigned int l;
  unsigned char data[MAX_CODE_NIBBLES];
d101 1
a101 1
  fprintf_ftype outfn = info->fprintf_func;
d116 1
a116 1
  for (l = 2; status == 0 && l < sizeof (data) / 2; l += 2)
d120 1
a120 1
  for (qi = h8_instructions; qi->opcode->name; qi++)
a121 1
      const struct h8_opcode *q = qi->opcode;
d128 1
a128 2
	  int thisnib = data[len / 2];
	  int opnr;
d130 1
a130 3
	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib / 16) & 0xf);
	  opnr = ((looking_for & OP3) == OP3 ? 2
		  : (looking_for & DST) == DST ? 1 : 0);
d141 1
a141 1
		  if (!((thisnib & 0x8) != 0))
a144 1
		  thisnib &= 0x7;
d146 2
a147 1
	      else if ((int) looking_for & (int) B30)
d149 1
a149 1
		  if (!((thisnib & 0x8) == 0))
d155 1
a155 58
	      if ((int) looking_for & (int) B21)
		{
		  if (!((thisnib & 0x4) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B21);
		  thisnib &= 0xb;
		}
	      else if ((int) looking_for & (int) B20)
		{
		  if (!((thisnib & 0x4) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B20);
		}
	      if ((int) looking_for & (int) B11)
		{
		  if (!((thisnib & 0x2) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B11);
		  thisnib &= 0xd;
		}
	      else if ((int) looking_for & (int) B10)
		{
		  if (!((thisnib & 0x2) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B10);
		}

	      if ((int) looking_for & (int) B01)
		{
		  if (!((thisnib & 0x1) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B01);
		  thisnib &= 0xe;
		}
	      else if ((int) looking_for & (int) B00)
		{
		  if (!((thisnib & 0x1) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B00);
		}

	      if (looking_for & IGNORE)
		{
		  /* Hitachi has declared that IGNORE must be zero.  */
		  if (thisnib != 0)
		    goto fail;
		}
	      else if ((looking_for & MODE) == DATA)
		{
		  ;			/* Skip embedded data.  */
		}
	      else if ((looking_for & MODE) == DBIT)
d163 1
a163 54
		  cst[opnr] = (thisnib & 0x8) ? 2 : 1;
		}
	      else if ((looking_for & MODE) == DISP  ||
		       (looking_for & MODE) == ABS   ||
		       (looking_for & MODE) == PCREL ||
		       (looking_for & MODE) == INDEXB ||
		       (looking_for & MODE) == INDEXW ||
		       (looking_for & MODE) == INDEXL)
		{
		  extract_immediate (stream, looking_for, thisnib, 
				     data + len / 2, cst + opnr, 
				     cstlen + opnr, q);
		  /* Even address == bra, odd == bra/s.  */
		  if (q->how == O (O_BRAS, SB))
		    cst[opnr] -= 1;
		}
	      else if ((looking_for & MODE) == REG     ||
		       (looking_for & MODE) == LOWREG  ||
		       (looking_for & MODE) == IND     ||
		       (looking_for & MODE) == PREINC  ||
		       (looking_for & MODE) == POSTINC ||
		       (looking_for & MODE) == PREDEC  ||
		       (looking_for & MODE) == POSTDEC)
		{
		  regno[opnr] = thisnib;
		}
	      else if (looking_for & CTRL)	/* Control Register */
		{
		  thisnib &= 7;
		  if (((looking_for & MODE) == CCR  && (thisnib != C_CCR))  ||
		      ((looking_for & MODE) == EXR  && (thisnib != C_EXR))  ||
		      ((looking_for & MODE) == MACH && (thisnib != C_MACH)) ||
		      ((looking_for & MODE) == MACL && (thisnib != C_MACL)) ||
		      ((looking_for & MODE) == VBR  && (thisnib != C_VBR))  ||
		      ((looking_for & MODE) == SBR  && (thisnib != C_SBR)))
		    goto fail;
		  if (((looking_for & MODE) == CCR_EXR && 
		       (thisnib != C_CCR && thisnib != C_EXR)) ||
		      ((looking_for & MODE) == VBR_SBR && 
		       (thisnib != C_VBR && thisnib != C_SBR)) ||
		      ((looking_for & MODE) == MACREG && 
		       (thisnib != C_MACH && thisnib != C_MACL)))
		    goto fail;
		  if (((looking_for & MODE) == CC_EX_VB_SB && 
		       (thisnib != C_CCR && thisnib != C_EXR &&
			thisnib != C_VBR && thisnib != C_SBR)))
		    goto fail;

		  regno[opnr] = thisnib;
		}
	      else if ((looking_for & SIZE) == L_5)
		{
		  cst[opnr] = data[len / 2] & 31;
		  cstlen[opnr] = 5;
d165 1
a165 1
	      else if ((looking_for & SIZE) == L_4)
d167 4
a170 2
		  cst[opnr] = thisnib;
		  cstlen[opnr] = 4;
d172 1
a172 2
	      else if ((looking_for & SIZE) == L_16 ||
		       (looking_for & SIZE) == L_16U)
d174 2
a175 2
		  cst[opnr] = (data[len / 2]) * 256 + data[(len + 2) / 2];
		  cstlen[opnr] = 16;
d177 1
a177 1
	      else if ((looking_for & MODE) == MEMIND)
d179 1
a179 1
		  cst[opnr] = data[1];
d181 1
a181 1
	      else if ((looking_for & MODE) == VECIND)
d183 1
a183 1
		  cst[opnr] = data[1] & 0x7f;
d185 1
a185 1
	      else if ((looking_for & SIZE) == L_32)
d187 1
a187 1
		  int i = len / 2;
d189 4
a192 4
		  cst[opnr] = ((data[i] << 24) 
			       | (data[i + 1] << 16) 
			       | (data[i + 2] << 8)
			       | (data[i + 3]));
d194 1
a194 1
		  cstlen[opnr] = 32;
d196 1
a196 1
	      else if ((looking_for & SIZE) == L_24)
d198 1
a198 1
		  int i = len / 2;
d200 2
a201 3
		  cst[opnr] = 
		    (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
		  cstlen[opnr] = 24;
d209 1
a209 1
		  dispregno[opnr] = thisnib & 7;
d211 1
a211 1
	      else if ((looking_for & MODE) == KBIT)
d216 1
a216 1
		      cst[opnr] = 4;
d219 1
a219 1
		      cst[opnr] = 2;
d222 1
a222 1
		      cst[opnr] = 1;
d228 1
a228 1
	      else if ((looking_for & SIZE) == L_8)
d230 2
a231 2
		  cstlen[opnr] = 8;
		  cst[opnr] = data[len / 2];
d233 1
a233 2
	      else if ((looking_for & SIZE) == L_3 ||
		       (looking_for & SIZE) == L_3NZ)
d235 1
a235 3
		  cst[opnr] = thisnib & 0x7;
		  if (cst[opnr] == 0 && (looking_for & SIZE) == L_3NZ)
		    goto fail;
d237 1
a237 1
	      else if ((looking_for & SIZE) == L_2)
d239 2
a240 2
		  cstlen[opnr] = 2;
		  cst[opnr] = thisnib & 0x3;
d242 1
a242 1
	      else if ((looking_for & MODE) == MACREG)
d244 1
a244 1
		  cst[opnr] = (thisnib == 3);
d246 1
a246 1
	      else if (looking_for == (op_type) E)
d250 2
a251 2
		  for (i = 0; i < qi->length; i++)
		    outfn (stream, "%02x ", data[i]);
d254 1
a254 1
		    outfn (stream, "   ");
d256 1
a256 1
		  outfn (stream, "%s\t", q->name);
d263 2
a264 2
		      count = (data[1] / 16) & 0x3;
		      high = regno[1];
d266 2
a267 2
		      outfn (stream, "@@sp+,er%d-er%d", high - count, high);
		      return qi->length;
d274 2
a275 2
		      count = (data[1] / 16) & 0x3;
		      low = regno[0];
d277 2
a278 2
		      outfn (stream, "er%d-er%d,@@-sp", low, low + count);
		      return qi->length;
a279 15
		  if (strcmp (q->name, "rte/l") == 0
		      || strcmp (q->name, "rts/l") == 0)
		    {
		      if (regno[0] == 0)
			outfn (stream, "er%d", regno[1]);
		      else
			{
			  outfn (stream, "er%d-er%d", regno[1] - regno[0],
				 regno[1]);
			}
		      return qi->length;
		    }
		  if (strncmp (q->name, "mova", 4) == 0)
		    {
		      op_type *args = q->args.nib;
a280 22
		      if (args[1] == (op_type) E)
			{
			  /* Short form.  */
			  print_one_arg (info, addr, args[0], cst[0], 
					 cstlen[0], dispregno[0], regno[0], 
					 pregnames, qi->length);
			  outfn (stream, ",er%d", dispregno[0]);
			}
		      else
			{
			  outfn (stream, "@@(0x%x:%d,", cst[0], cstlen[0]);
			  print_one_arg (info, addr, args[1], cst[1], 
					 cstlen[1], dispregno[1], regno[1], 
					 pregnames, qi->length);
			  outfn (stream, ".%c),",
				 (args[0] & MODE) == INDEXB ? 'b' : 'w');
			  print_one_arg (info, addr, args[2], cst[2], 
					 cstlen[2], dispregno[2], regno[2], 
					 pregnames, qi->length);
			}
		      return qi->length;
		    }
a284 1
		    int nargs;
d286 1
a286 3
		    for (nargs = 0; 
			 nargs < 3 && args[nargs] != (op_type) E; 
			 nargs++)
d288 1
a288 1
			int x = args[nargs];
d291 1
a291 1
			  outfn (stream, ",");
d293 93
a385 4
			print_one_arg (info, addr, x,
				       cst[nargs], cstlen[nargs],
				       dispregno[nargs], regno[nargs],
				       pregnames, qi->length);
d388 1
d392 1
a392 1
		  return qi->length;
d396 1
a396 1
		outfn (stream, _("Don't understand 0x%x \n"), looking_for);
d408 1
a408 1
  outfn (stream, "%02x %02x        .word\tH'%x,H'%x",
@


1.10.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a25 9
#include "libiberty.h"

struct h8_instruction
{
  int length;
  const struct h8_opcode *opcode;
};

struct h8_instruction *h8_instructions;
d37 1
a37 3
  unsigned int nopcodes;
  const struct h8_opcode *p;
  struct h8_instruction *pi;
d39 1
a39 6
  nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);

  h8_instructions = (struct h8_instruction *)
    xmalloc (nopcodes * sizeof (struct h8_instruction));

  for (p = h8_opcodes, pi = h8_instructions; p->name; p++, pi++)
d62 1
a62 2
      pi->length = i / 2;
      pi->opcode = p;
a63 4

  /* Add entry for the NULL vector terminator.  */
  pi->length = 0;
  pi->opcode = p;
d94 2
a95 2
  static bfd_boolean init = 0;
  const struct h8_instruction *qi;
d120 1
a120 1
  for (qi = h8_instructions; qi->opcode->name; qi++)
a121 1
      const struct h8_opcode *q = qi->opcode;
d250 1
a250 1
		  for (i = 0; i < qi->length; i++)
d267 1
a267 1
		      return qi->length;
d278 1
a278 1
		      return qi->length;
d392 1
a392 1
		  return qi->length;
@


1.10.12.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002, 2003
d37 2
a38 29
static void print_one_arg PARAMS ((disassemble_info *, bfd_vma, op_type,
				   int, int, int, int, const char **, int));
static unsigned int bfd_h8_disassemble PARAMS ((bfd_vma, 
						disassemble_info *, 
						int));
static void extract_immediate PARAMS ((FILE *, 
				       op_type, int, 
				       unsigned char *,
				       int *, int *,
				       const struct h8_opcode *));

static void print_colon_thingie PARAMS ((op_type *));

static void
print_colon_thingie (op_type *nib)
{
  switch (*nib & SIZE) {
  case L_2:	fprintf (stdout, "2");	break;
  case L_3:
  case L_3NZ:	fprintf (stdout, "3");	break;
  case L_4:	fprintf (stdout, "4");	break;
  case L_5:	fprintf (stdout, "5");	break;
  case L_8:	fprintf (stdout, "8");	break;
  case L_16:
  case L_16U:	fprintf (stdout, "16");	break;
  case L_24:	fprintf (stdout, "24");	break;
  case L_32:	fprintf (stdout, "32");	break;
  }
}
a41 1

d72 1
a72 1
      for (i = 0; p->data.nib[i] != (op_type) E; i++)
d76 1
a76 4
	{
	  fprintf (stderr, "Internal error, h8_disassemble_init.\n");
	  abort ();
	}
a86 262
static void
extract_immediate (stream, looking_for, thisnib, data, cst, len, q)
     FILE *stream;
     op_type looking_for;
     int thisnib;
     unsigned char *data;
     int *cst, *len;
     const struct h8_opcode *q;
{
  switch (looking_for & SIZE)
    {
    case L_2:
      *len = 2;
      *cst = thisnib & 3;

      /* DISP2 special treatment.  */
      if ((looking_for & MODE) == DISP)
	{
	  if (OP_KIND (q->how) == O_MOVAB ||
	      OP_KIND (q->how) == O_MOVAW ||
	      OP_KIND (q->how) == O_MOVAL)
	    {
	      /* Handling for mova insn.  */
	      switch (q->args.nib[0] & MODE) {
	      case INDEXB:
	      default:
		break;
	      case INDEXW:
		*cst *= 2;
		break;
	      case INDEXL:
		*cst *= 4;
		break;
	      }
	    }
	  else
	    {
	      /* Handling for non-mova insn.  */
	      switch (OP_SIZE (q->how)) {
	      default: break;
	      case SW:
		*cst *= 2;
		break;
	      case SL:
		*cst *= 4;
		break;
	      }
	    }
	}
      break;
    case L_8:
      *len = 8;
      *cst = data[0];
      break;
    case L_16:
    case L_16U:
      *len = 16;
      *cst = (data[0] << 8) + data [1];
#if 0
      if ((looking_for & SIZE) == L_16)
	*cst = (short) *cst;	/* sign extend */
#endif
      break;
    case L_32:
      *len = 32;
      *cst = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
      break;
    default:
      *len = 0;
      *cst = 0;
      fprintf (stream, "DISP bad size\n");
      break;
    }
}

static const char *regnames[] =
{
  "r0h", "r1h", "r2h", "r3h", "r4h", "r5h", "r6h", "r7h",
  "r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l"
};
static const char *wregnames[] =
{
  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7"
};
static const char *lregnames[] =
{
  "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7",
  "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7"
};
static const char *cregnames[] =
{
  "ccr", "exr", "mach", "macl", "", "", "vbr", "sbr"
};

static void
print_one_arg (info, addr, x, cst, cstlen, rdisp_n, rn, pregnames, len)
     disassemble_info *info;
     bfd_vma addr;
     op_type x;
     int cst, cstlen, rdisp_n, rn;
     const char **pregnames;
     int len;
{
  void *stream = info->stream;
  fprintf_ftype outfn = info->fprintf_func;

  if ((x & SIZE) == L_3 ||
      (x & SIZE) == L_3NZ)
    {
      outfn (stream, "#0x%x", (unsigned) cst);
    }
  else if ((x & MODE) == IMM)
    {
      outfn (stream, "#0x%x", (unsigned) cst);
    }
  else if ((x & MODE) == DBIT  ||
	   (x & MODE) == KBIT)
    {
      outfn (stream, "#%d", (unsigned) cst);
    }
  else if ((x & MODE) == CONST_2)
    outfn (stream, "#2");
  else if ((x & MODE) == CONST_4)
    outfn (stream, "#4");
  else if ((x & MODE) == CONST_8)
    outfn (stream, "#8");
  else if ((x & MODE) == CONST_16)
    outfn (stream, "#16");
  else if ((x & MODE) == REG)
    {
      switch (x & SIZE)
	{
	case L_8:
	  outfn (stream, "%s", regnames[rn]);
	  break;
	case L_16:
	case L_16U:
	  outfn (stream, "%s", wregnames[rn]);
	  break;
	case L_P:
	case L_32:
	  outfn (stream, "%s", lregnames[rn]);
	  break;
	}
    }
  else if ((x & MODE) == LOWREG)
    {
      switch (x & SIZE)
	{
	case L_8:
	  /* Always take low half of reg.  */
	  outfn (stream, "%s.b", regnames[rn < 8 ? rn + 8 : rn]);
	  break;
	case L_16:
	case L_16U:
	  /* Always take low half of reg.  */
	  outfn (stream, "%s.w", wregnames[rn < 8 ? rn : rn - 8]);
	  break;
	case L_P:
	case L_32:
	  outfn (stream, "%s.l", lregnames[rn]);
	  break;
	}
    }
  else if ((x & MODE) == POSTINC)
    {
      outfn (stream, "@@%s+", pregnames[rn]);
    }
  else if ((x & MODE) == POSTDEC)
    {
      outfn (stream, "@@%s-", pregnames[rn]);
    }
  else if ((x & MODE) == PREINC)
    {
      outfn (stream, "@@+%s", pregnames[rn]);
    }
  else if ((x & MODE) == PREDEC)
    {
      outfn (stream, "@@-%s", pregnames[rn]);
    }
  else if ((x & MODE) == IND)
    {
      outfn (stream, "@@%s", pregnames[rn]);
    }
  else if ((x & MODE) == ABS || (x & ABSJMP))
    {
      outfn (stream, "@@0x%x:%d", (unsigned) cst, cstlen);
    }
  else if ((x & MODE) == MEMIND)
    {
      outfn (stream, "@@@@%d (0x%x)", cst, cst);
    }
  else if ((x & MODE) == VECIND)
    {
      /* FIXME Multiplier should be 2 or 4, depending on processor mode,
	 by which is meant "normal" vs. "middle", "advanced", "maximum".  */

      int offset = (cst + 0x80) * 4;
      outfn (stream, "@@@@%d (0x%x)", offset, offset);
    }
  else if ((x & MODE) == PCREL)
    {
      if ((x & SIZE) == L_16 ||
	  (x & SIZE) == L_16U)
	{
	  outfn (stream, ".%s%d (0x%x)",
		   (short) cst > 0 ? "+" : "",
		   (short) cst, 
		   addr + (short) cst + len);
	}
      else
	{
	  outfn (stream, ".%s%d (0x%x)",
		   (char) cst > 0 ? "+" : "",
		   (char) cst, 
		   addr + (char) cst + len);
	}
    }
  else if ((x & MODE) == DISP)
    {
      outfn (stream, "@@(0x%x:%d,%s)", cst, cstlen, 
	       pregnames[rdisp_n]);
    }
  else if ((x & MODE) == INDEXB)
    {
      /* Always take low half of reg.  */
      outfn (stream, "@@(0x%x:%d,%s.b)", cst, cstlen, 
	     regnames[rdisp_n < 8 ? rdisp_n + 8 : rdisp_n]);
    }
  else if ((x & MODE) == INDEXW)
    {
      /* Always take low half of reg.  */
      outfn (stream, "@@(0x%x:%d,%s.w)", cst, cstlen, 
	       wregnames[rdisp_n < 8 ? rdisp_n : rdisp_n - 8]);
    }
  else if ((x & MODE) == INDEXL)
    {
      outfn (stream, "@@(0x%x:%d,%s.l)", cst, cstlen, 
	       lregnames[rdisp_n]);
    }
  else if (x & CTRL)
    {
      outfn (stream, cregnames[rn]);
    }
  else if ((x & MODE) == CCR)
    {
      outfn (stream, "ccr");
    }
  else if ((x & MODE) == EXR)
    {
      outfn (stream, "exr");
    }
  else if ((x & MODE) == MACREG)
    {
      outfn (stream, "mac%c", cst ? 'l' : 'h');
    }
  else
    /* xgettext:c-format */
    outfn (stream, _("Hmmmm 0x%x"), x);
}

d88 1
a88 1
bfd_h8_disassemble (addr, info, mach)
d91 1
a91 1
     int mach;
d94 21
a114 4
  int regno[3] = { 0, 0, 0 };
  int dispregno[3] = { 0, 0, 0 };
  int cst[3] = { 0, 0, 0 };
  int cstlen[3] = { 0, 0, 0 };
d117 1
a117 1
  char const **pregnames = mach != 0 ? lregnames : wregnames;
d119 2
a120 2
  unsigned int l;
  unsigned char data[MAX_CODE_NIBBLES];
d122 1
a122 1
  fprintf_ftype outfn = info->fprintf_func;
d137 1
a137 1
  for (l = 2; status == 0 && l < sizeof (data) / 2; l += 2)
d150 1
a150 2
	  int thisnib = data[len / 2];
	  int opnr;
d152 1
a152 3
	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib / 16) & 0xf);
	  opnr = ((looking_for & OP3) == OP3 ? 2
		  : (looking_for & DST) == DST ? 1 : 0);
d163 1
a163 1
		  if (!((thisnib & 0x8) != 0))
a166 1
		  thisnib &= 0x7;
d168 2
a169 1
	      else if ((int) looking_for & (int) B30)
d171 1
a171 1
		  if (!((thisnib & 0x8) == 0))
d177 1
a177 58
	      if ((int) looking_for & (int) B21)
		{
		  if (!((thisnib & 0x4) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B21);
		  thisnib &= 0xb;
		}
	      else if ((int) looking_for & (int) B20)
		{
		  if (!((thisnib & 0x4) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B20);
		}
	      if ((int) looking_for & (int) B11)
		{
		  if (!((thisnib & 0x2) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B11);
		  thisnib &= 0xd;
		}
	      else if ((int) looking_for & (int) B10)
		{
		  if (!((thisnib & 0x2) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B10);
		}

	      if ((int) looking_for & (int) B01)
		{
		  if (!((thisnib & 0x1) != 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B01);
		  thisnib &= 0xe;
		}
	      else if ((int) looking_for & (int) B00)
		{
		  if (!((thisnib & 0x1) == 0))
		    goto fail;

		  looking_for = (op_type) ((int) looking_for & ~(int) B00);
		}

	      if (looking_for & IGNORE)
		{
		  /* Hitachi has declared that IGNORE must be zero.  */
		  if (thisnib != 0)
		    goto fail;
		}
	      else if ((looking_for & MODE) == DATA)
		{
		  ;			/* Skip embedded data.  */
		}
	      else if ((looking_for & MODE) == DBIT)
d185 1
a185 1
		  cst[opnr] = (thisnib & 0x8) ? 2 : 1;
d187 1
a187 49
	      else if ((looking_for & MODE) == DISP  ||
		       (looking_for & MODE) == ABS   ||
		       (looking_for & MODE) == PCREL ||
		       (looking_for & MODE) == INDEXB ||
		       (looking_for & MODE) == INDEXW ||
		       (looking_for & MODE) == INDEXL)
		{
		  extract_immediate (stream, looking_for, thisnib, 
				     data + len / 2, cst + opnr, 
				     cstlen + opnr, q);
		  /* Even address == bra, odd == bra/s.  */
		  if (q->how == O (O_BRAS, SB))
		    cst[opnr] -= 1;
		}
	      else if ((looking_for & MODE) == REG     ||
		       (looking_for & MODE) == LOWREG  ||
		       (looking_for & MODE) == IND     ||
		       (looking_for & MODE) == PREINC  ||
		       (looking_for & MODE) == POSTINC ||
		       (looking_for & MODE) == PREDEC  ||
		       (looking_for & MODE) == POSTDEC)
		{
		  regno[opnr] = thisnib;
		}
	      else if (looking_for & CTRL)	/* Control Register */
		{
		  thisnib &= 7;
		  if (((looking_for & MODE) == CCR  && (thisnib != C_CCR))  ||
		      ((looking_for & MODE) == EXR  && (thisnib != C_EXR))  ||
		      ((looking_for & MODE) == MACH && (thisnib != C_MACH)) ||
		      ((looking_for & MODE) == MACL && (thisnib != C_MACL)) ||
		      ((looking_for & MODE) == VBR  && (thisnib != C_VBR))  ||
		      ((looking_for & MODE) == SBR  && (thisnib != C_SBR)))
		    goto fail;
		  if (((looking_for & MODE) == CCR_EXR && 
		       (thisnib != C_CCR && thisnib != C_EXR)) ||
		      ((looking_for & MODE) == VBR_SBR && 
		       (thisnib != C_VBR && thisnib != C_SBR)) ||
		      ((looking_for & MODE) == MACREG && 
		       (thisnib != C_MACH && thisnib != C_MACL)))
		    goto fail;
		  if (((looking_for & MODE) == CC_EX_VB_SB && 
		       (thisnib != C_CCR && thisnib != C_EXR &&
			thisnib != C_VBR && thisnib != C_SBR)))
		    goto fail;

		  regno[opnr] = thisnib;
		}
	      else if ((looking_for & SIZE) == L_5)
d189 4
a192 2
		  cst[opnr] = data[len / 2] & 31;
		  cstlen[opnr] = 5;
d194 1
a194 1
	      else if ((looking_for & SIZE) == L_4)
d196 2
a197 2
		  cst[opnr] = thisnib;
		  cstlen[opnr] = 4;
d199 1
a199 2
	      else if ((looking_for & SIZE) == L_16 ||
		       (looking_for & SIZE) == L_16U)
d201 1
a201 2
		  cst[opnr] = (data[len / 2]) * 256 + data[(len + 2) / 2];
		  cstlen[opnr] = 16;
d203 1
a203 1
	      else if ((looking_for & MODE) == MEMIND)
d205 1
a205 1
		  cst[opnr] = data[1];
d207 1
a207 1
	      else if ((looking_for & MODE) == VECIND)
d209 1
a209 5
		  cst[opnr] = data[1] & 0x7f;
		}
	      else if ((looking_for & SIZE) == L_32)
		{
		  int i = len / 2;
d211 4
a214 4
		  cst[opnr] = ((data[i] << 24) 
			       | (data[i + 1] << 16) 
			       | (data[i + 2] << 8)
			       | (data[i + 3]));
d216 1
a216 1
		  cstlen[opnr] = 32;
d218 1
a218 1
	      else if ((looking_for & SIZE) == L_24)
d220 1
a220 1
		  int i = len / 2;
d222 2
a223 3
		  cst[opnr] = 
		    (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
		  cstlen[opnr] = 24;
d231 1
a231 1
		  dispregno[opnr] = thisnib & 7;
d233 1
a233 1
	      else if ((looking_for & MODE) == KBIT)
d238 1
a238 1
		      cst[opnr] = 4;
d241 1
a241 1
		      cst[opnr] = 2;
d244 1
a244 1
		      cst[opnr] = 1;
d250 1
a250 1
	      else if ((looking_for & SIZE) == L_8)
d252 2
a253 2
		  cstlen[opnr] = 8;
		  cst[opnr] = data[len / 2];
d255 1
a255 2
	      else if ((looking_for & SIZE) == L_3 ||
		       (looking_for & SIZE) == L_3NZ)
d257 1
a257 3
		  cst[opnr] = thisnib & 0x7;
		  if (cst[opnr] == 0 && (looking_for & SIZE) == L_3NZ)
		    goto fail;
d259 1
a259 1
	      else if ((looking_for & SIZE) == L_2)
d261 2
a262 2
		  cstlen[opnr] = 2;
		  cst[opnr] = thisnib & 0x3;
d264 1
a264 1
	      else if ((looking_for & MODE) == MACREG)
d266 1
a266 1
		  cst[opnr] = (thisnib == 3);
d268 1
a268 1
	      else if (looking_for == (op_type) E)
d273 1
a273 1
		    outfn (stream, "%02x ", data[i]);
d276 1
a276 1
		    outfn (stream, "   ");
d278 1
a278 1
		  outfn (stream, "%s\t", q->name);
d285 2
a286 2
		      count = (data[1] / 16) & 0x3;
		      high = regno[1];
d288 1
a288 1
		      outfn (stream, "@@sp+,er%d-er%d", high - count, high);
d296 2
a297 2
		      count = (data[1] / 16) & 0x3;
		      low = regno[0];
d299 1
a299 13
		      outfn (stream, "er%d-er%d,@@-sp", low, low + count);
		      return qi->length;
		    }
		  if (strcmp (q->name, "rte/l") == 0
		      || strcmp (q->name, "rts/l") == 0)
		    {
		      if (regno[0] == 0)
			outfn (stream, "er%d", regno[1]);
		      else
			{
			  outfn (stream, "er%d-er%d", regno[1] - regno[0],
				 regno[1]);
			}
a301 3
		  if (strncmp (q->name, "mova", 4) == 0)
		    {
		      op_type *args = q->args.nib;
a302 22
		      if (args[1] == (op_type) E)
			{
			  /* Short form.  */
			  print_one_arg (info, addr, args[0], cst[0], 
					 cstlen[0], dispregno[0], regno[0], 
					 pregnames, qi->length);
			  outfn (stream, ",er%d", dispregno[0]);
			}
		      else
			{
			  outfn (stream, "@@(0x%x:%d,", cst[0], cstlen[0]);
			  print_one_arg (info, addr, args[1], cst[1], 
					 cstlen[1], dispregno[1], regno[1], 
					 pregnames, qi->length);
			  outfn (stream, ".%c),",
				 (args[0] & MODE) == INDEXB ? 'b' : 'w');
			  print_one_arg (info, addr, args[2], cst[2], 
					 cstlen[2], dispregno[2], regno[2], 
					 pregnames, qi->length);
			}
		      return qi->length;
		    }
a306 1
		    int nargs;
d308 1
a308 3
		    for (nargs = 0; 
			 nargs < 3 && args[nargs] != (op_type) E; 
			 nargs++)
d310 1
a310 1
			int x = args[nargs];
d313 1
a313 1
			  outfn (stream, ",");
d315 93
a407 4
			print_one_arg (info, addr, x,
				       cst[nargs], cstlen[nargs],
				       dispregno[nargs], regno[nargs],
				       pregnames, qi->length);
d410 1
d418 1
a418 1
		outfn (stream, _("Don't understand 0x%x \n"), looking_for);
d430 1
a430 1
  outfn (stream, "%02x %02x        .word\tH'%x,H'%x",
@


1.10.12.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d48 19
@


1.9
log
@For include/opcode:
	* d30v.h: Fix declaration of reg_name_cnt.

	* d10v.h: Fix declaration of d10v_reg_name_cnt.

	* arc.h: Add prototypes from opcodes/arc-opc.c.

For opcodes:
	* tic54x-dis.c: Add unused attributes where needed.

	* z8k-dis.c (output_instr): Add unused attribute.

	* h8300-dis.c: Add missing prototypes.
	(bfd_h8_disassemble): Make static.

	* cris-dis.c: Add missing prototype.
	* h8500-dis.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* z8k-dis.c: Likewise.

	* d10v-dis.c: Add missing prototype.
	(dis_long): Remove unused variable.
	(dis_2_short): Likewise.

	* sh-dis.c: Add missing prototypes.
	* v850-opc.c: Likewise.
	Add unused attributes where needed.

	* ns32k-dis.c: Add missing prototypes.
	(bit_extract_simple): Remove unused variable.
@
text
@d2 2
a3 1
   Copyright 1993, 1994, 1996, 1998, 2000, 2001 Free Software Foundation, Inc.
d73 1
a73 1
  static CONST char *regnames[] =
d78 1
a78 1
  static CONST char *wregnames[] =
d83 1
a83 1
  static CONST char *lregnames[] =
d96 1
a96 1
  char CONST **pregnames = mode != 0 ? lregnames : wregnames;
@


1.9.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002
   Free Software Foundation, Inc.
d72 1
a72 1
  static const char *regnames[] =
d77 1
a77 1
  static const char *wregnames[] =
d82 1
a82 1
  static const char *lregnames[] =
d95 1
a95 1
  char const **pregnames = mode != 0 ? lregnames : wregnames;
@


1.9.8.1
log
@merge from trunk
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1996, 1998, 2000, 2001, 2002
   Free Software Foundation, Inc.
d72 1
a72 1
  static const char *regnames[] =
d77 1
a77 1
  static const char *wregnames[] =
d82 1
a82 1
  static const char *lregnames[] =
d95 1
a95 1
  char const **pregnames = mode != 0 ? lregnames : wregnames;
@


1.8
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000 Free Software Foundation, Inc.
d26 4
d65 1
a65 1
unsigned int
@


1.7
log
@Fix formatting.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1998, 2000 Free Software Foundation, Inc.
@


1.7.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1996, 1998, 2000 Free Software Foundation, Inc.
@


1.6
log
@        * h8300-dis.c: Fix formatting.
        (bfd_h8_disassemble): Distinguish adds/subs, inc/dec.[wl]
        correctly.
@
text
@d90 1
a90 1
  struct h8_opcode *q = h8_opcodes;
d115 1
a115 1
  while (q->name)
d117 1
a117 1
      op_type *nib;
a119 2
      nib = q->data.nib;

d399 1
a399 1
      q++;
@


1.5
log
@Fix formatting
@
text
@a25 1

d43 1
a43 1
      
d52 2
a53 2
	/*EMPTY*/;
      
d56 1
a56 1
      
a60 1

d110 1
a110 1
  
d112 1
a112 1
    status = info->read_memory_func (addr + l, data+l, 2, info);
d121 1
a121 1
      
d126 1
a126 1
	  
d128 1
a128 1
	  
d138 1
a138 1
		  if (! (((int) thisnib & 0x8) != 0))
d140 1
a140 1
		  
d143 1
a143 1
	      
d148 1
a148 1
		  
d154 4
a157 1
		  if ((looking_for & 2) != (thisnib & 2))
d159 1
a159 1
		  
d185 1
a185 1
		  
d189 1
a189 1
		    | (data[i+ 3]);
d196 1
a196 1
		  
d249 1
a249 1
		  
d252 1
a252 1
		  
d286 1
a286 1
			
d305 1
a305 1
			    
d355 2
a356 1
					 ".%s%d (%x)", (short) abs > 0 ? "+" : "",
d362 2
a363 1
					 ".%s%d (%x)", (char) abs > 0 ? "+" : "",
d370 1
a370 1
				     abs,plen, pregnames[rdisp]);
d383 1
a383 1
			
d388 1
a388 1
		  
d395 1
a395 1
	  
d399 1
a399 1
      
a407 1
  
@


1.4
log
@Applied patch from  Kazu Hirata  <kazu@@hxi.com> to fix disassembly of inc.l
and dec.l instructions
@
text
@d41 1
a41 3
	{
	  n1 = (int) p->data.nib[0];
	}
d46 1
a46 3
	{
	  n2 = (int) p->data.nib[1];
	}
d53 1
a53 1
	/*EMPTY*/ ;
a79 1
  
a84 1

d96 1
a96 1
  unsigned char data[20];  
d107 1
a107 1
  if (status != 0) 
d114 1
a114 1
    status = info->read_memory_func(addr+l, data+l, 2, info);
d131 1
a131 1
	  if (looking_for < 16 && looking_for >=0) 
d133 1
a133 1
	      if (looking_for != thisnib) 
d136 1
a136 1
	  else 
d140 1
a140 1
		  if (! (((int) thisnib & 0x8) != 0)) 
d142 1
d148 1
a148 1
		  if (!(((int) thisnib & 0x8) == 0)) 
d150 1
d158 1
d160 2
a161 2
		}		  
	      else if (looking_for & (REG | IND|INC|DEC))
d175 1
a175 4
		  abs =
		    (data[1] << 16)
		      | (data[2] << 8)
			| (data[3]);
d187 2
a188 2
		      | (data[i + 2] << 8)
			| (data[i+ 3]);
d195 3
a197 2
		  abs = (data[i] << 16) | (data[i + 1] << 8)|  (data[i+2]);
		  plen =24;
d209 1
a209 1
		  switch (thisnib) 
d226 1
a226 1
		  plen = 8;		  
d293 1
a293 1
			else if (x & (IMM|KBIT|DBIT))
d296 1
a296 1
			    if (*(args+1) & SRC_IN_DST)
d340 1
a340 1
			else if (x & (ABS|ABSJMP))
d350 1
a350 1
			    if (x & L_16) 
d353 3
a355 2
				fprintf (stream, ".%s%d (%x)", (short) abs > 0 ? "+" : "", (short) abs,
					 addr + (short) abs + 2);
d359 3
a361 2
				fprintf (stream, ".%s%d (%x)", (char) abs > 0 ? "+" : "", (char) abs,
					 addr + (char) abs + 2);
d366 2
a367 1
			    fprintf (stream, "@@(0x%x:%d,%s)", abs,plen, pregnames[rdisp]);
d385 1
d389 2
a390 4
		{
		  /* xgettext:c-format */
		  fprintf (stream, _("Don't understand %x \n"), looking_for);
		}
d401 1
a401 1
  /* Fell of the end.  */
d405 1
d409 1
a409 1
int 
d411 1
a411 1
     bfd_vma addr; 
d414 1
a414 1
  return bfd_h8_disassemble (addr, info , 0);
d417 1
a417 1
int 
d422 1
a422 1
  return bfd_h8_disassemble (addr, info , 1);
d425 1
a425 1
int 
d430 1
a430 1
  return bfd_h8_disassemble (addr, info , 2);
@


1.3
log
@Replace defines with those from intl/libgettext.h to quieten gcc warnings.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1998 Free Software Foundation, Inc.
d28 1
a28 2
   to disassemble
 */
a32 2


d46 1
d55 1
a55 1
	 that the count is the same s the length */
d58 1
d61 1
a63 1

d73 1
a73 1
  /* Find the first entry in the table for this opcode */
d77 2
a78 2
      "r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l"};
  
d83 1
a83 1
      };
d89 1
a89 2
      }
  ;
a101 1
  
d112 1
a112 1
  status = info->read_memory_func(addr, data, 2, info);
d115 1
a115 1
      info->memory_error_func(status, addr, info);
a117 5
  for (l = 2; status == 0 && l < 10; l+=2)
    {
      status = info->read_memory_func(addr+l, data+l, 2, info);
    }
  
d119 2
d122 1
a122 1
  /* Find the exact opcode/arg combo */
a138 1
	      
a141 1
	  
a143 1
	      
d150 1
d160 2
a161 1
		  if ((looking_for & 5) != (thisnib & 5)) goto fail;
a163 1
	      
d167 1
a167 3
		    {
		      rs = thisnib;
		    }
d169 1
a169 3
		    {
		      rd = thisnib;
		    }
a174 1
	      
d176 1
a176 1
	      else if(looking_for & ABSJMP)
d183 1
a183 1
	      else if(looking_for & MEMIND)
d190 1
d196 1
a196 2
		  plen =32;
	      
d206 1
a206 1
		  
d249 1
d251 6
a256 12
		  {
		    int i;

		    for (i = 0; i < q->length; i++)
		      {
			fprintf (stream, "%02x ", data[i]);
		      }
		    for (; i < 6; i++)
		      {
			fprintf (stream, "   ");
		      }
		  }
d282 1
a282 1
		  /* Fill in the args */
a286 1

d290 1
a293 1

d309 1
a321 1
		    
a335 1

a340 1

a344 1

a348 1

a352 1

d357 1
a357 1
				abs  +=2;
d361 5
a365 4
			    else {
			      fprintf (stream, ".%s%d (%x)", (char) abs > 0 ? "+" : "", (char) abs,
				       addr + (char) abs + 2);
			    }
a370 1

d382 1
a388 2

      
d404 1
a404 1
  /* Fell of the end */
d413 2
a414 2
bfd_vma addr; 
disassemble_info *info;
d421 2
a422 2
bfd_vma addr;
disassemble_info *info;
d429 2
a430 2
bfd_vma addr;
disassemble_info *info;
@


1.2
log
@More portability patches.  Include sysdep.h everywhere.
@
text
@d168 1
a168 1
		  if ((looking_for & 5) != (thisnib &5)) goto fail;
d172 1
a172 1
	      else  if (looking_for & (REG | IND|INC|DEC))
@


1.1
log
@Initial revision
@
text
@d20 1
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@2000-04-13  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* a29k-dis.c, alpha-dis.c, alpha-opc.c, arc-dis.c, arc-opc.c,
	avr-dis.c, d10v-dis.c, d10v-opc.c, d30v-dis.c, d30v-opc.c,
	disassemble.c, h8300-dis.c, h8500-dis.c, hppa-dis.c, i370-dis.c,
	i370-opc.c, i960-dis.c, m10200-dis.c, m10200-opc.c, m10300-dis.c,
	m10300-opc.c, m68k-dis.c, m68k-opc.c, m88k-dis.c, mcore-dis.c,
	mips-dis.c, mips-opc.c, mips16-opc.c, pj-dis.c, pj-opc.c, ppc-dis.c,
	ppc-opc.c, sh-dis.c, sparc-dis.c, sparc-opc.c, tic80-dis.c,
	tic80-opc.c, v850-dis.c, v850-opc.c, vax-dis.c, w65-dis.c, z8k-dis.c,
	z8kgen.c: Everyone includes sysdep.h. Remove ansidecl.h as sysdep.h
	includes it.
@
text
@a19 1
#include "sysdep.h"
@


