head	1.173;
access;
symbols
	sid-snapshot-20180601:1.173
	sid-snapshot-20180501:1.173
	sid-snapshot-20180401:1.173
	sid-snapshot-20180301:1.173
	sid-snapshot-20180201:1.173
	sid-snapshot-20180101:1.173
	sid-snapshot-20171201:1.173
	sid-snapshot-20171101:1.173
	sid-snapshot-20171001:1.173
	sid-snapshot-20170901:1.173
	sid-snapshot-20170801:1.173
	sid-snapshot-20170701:1.173
	sid-snapshot-20170601:1.173
	sid-snapshot-20170501:1.173
	sid-snapshot-20170401:1.173
	sid-snapshot-20170301:1.173
	sid-snapshot-20170201:1.173
	sid-snapshot-20170101:1.173
	sid-snapshot-20161201:1.173
	sid-snapshot-20161101:1.173
	sid-snapshot-20160901:1.173
	sid-snapshot-20160801:1.173
	sid-snapshot-20160701:1.173
	sid-snapshot-20160601:1.173
	sid-snapshot-20160501:1.173
	sid-snapshot-20160401:1.173
	sid-snapshot-20160301:1.173
	sid-snapshot-20160201:1.173
	sid-snapshot-20160101:1.173
	sid-snapshot-20151201:1.173
	sid-snapshot-20151101:1.173
	sid-snapshot-20151001:1.173
	sid-snapshot-20150901:1.173
	sid-snapshot-20150801:1.173
	sid-snapshot-20150701:1.173
	sid-snapshot-20150601:1.173
	sid-snapshot-20150501:1.173
	sid-snapshot-20150401:1.173
	sid-snapshot-20150301:1.173
	sid-snapshot-20150201:1.173
	sid-snapshot-20150101:1.173
	sid-snapshot-20141201:1.173
	sid-snapshot-20141101:1.173
	sid-snapshot-20141001:1.173
	sid-snapshot-20140901:1.173
	sid-snapshot-20140801:1.173
	sid-snapshot-20140701:1.173
	sid-snapshot-20140601:1.173
	sid-snapshot-20140501:1.173
	sid-snapshot-20140401:1.173
	sid-snapshot-20140301:1.173
	sid-snapshot-20140201:1.173
	sid-snapshot-20140101:1.173
	sid-snapshot-20131201:1.173
	sid-snapshot-20131101:1.173
	sid-snapshot-20131001:1.172
	binutils-2_24-branch:1.172.0.2
	binutils-2_24-branchpoint:1.172
	binutils-2_21_1:1.135
	sid-snapshot-20130901:1.171
	gdb_7_6_1-2013-08-30-release:1.171
	sid-snapshot-20130801:1.171
	sid-snapshot-20130701:1.171
	sid-snapshot-20130601:1.171
	sid-snapshot-20130501:1.171
	gdb_7_6-2013-04-26-release:1.171
	sid-snapshot-20130401:1.171
	binutils-2_23_2:1.152.2.2
	gdb_7_6-branch:1.171.0.2
	gdb_7_6-2013-03-12-branchpoint:1.171
	sid-snapshot-20130301:1.170
	sid-snapshot-20130201:1.169
	sid-snapshot-20130101:1.169
	sid-snapshot-20121201:1.169
	gdb_7_5_1-2012-11-29-release:1.151
	binutils-2_23_1:1.152.2.2
	sid-snapshot-20121101:1.169
	binutils-2_23:1.152.2.2
	sid-snapshot-20121001:1.168
	sid-snapshot-20120901:1.167
	gdb_7_5-2012-08-17-release:1.151
	sid-snapshot-20120801:1.152
	binutils-2_23-branch:1.152.0.2
	binutils-2_23-branchpoint:1.152
	gdb_7_5-branch:1.151.0.2
	gdb_7_5-2012-07-18-branchpoint:1.151
	sid-snapshot-20120701:1.151
	sid-snapshot-20120601:1.151
	sid-snapshot-20120501:1.149
	binutils-2_22_branch:1.148.0.4
	gdb_7_4_1-2012-04-26-release:1.149
	sid-snapshot-20120401:1.149
	sid-snapshot-20120301:1.149
	sid-snapshot-20120201:1.149
	gdb_7_4-2012-01-24-release:1.149
	sid-snapshot-20120101:1.149
	gdb_7_4-branch:1.149.0.2
	gdb_7_4-2011-12-13-branchpoint:1.149
	sid-snapshot-20111201:1.149
	binutils-2_22:1.148
	sid-snapshot-20111101:1.149
	sid-snapshot-20111001:1.148
	binutils-2_22-branch:1.148.0.2
	binutils-2_22-branchpoint:1.148
	gdb_7_3_1-2011-09-04-release:1.138
	sid-snapshot-20110901:1.148
	sid-snapshot-20110801:1.148
	gdb_7_3-2011-07-26-release:1.138
	sid-snapshot-20110701:1.146
	sid-snapshot-20110601:1.143
	sid-snapshot-20110501:1.143
	gdb_7_3-branch:1.138.0.2
	gdb_7_3-2011-04-01-branchpoint:1.138
	sid-snapshot-20110401:1.138
	sid-snapshot-20110301:1.136
	sid-snapshot-20110201:1.136
	sid-snapshot-20110101:1.135
	binutils-2_21:1.135
	sid-snapshot-20101201:1.135
	binutils-2_21-branch:1.135.0.2
	binutils-2_21-branchpoint:1.135
	sid-snapshot-20101101:1.135
	sid-snapshot-20101001:1.135
	binutils-2_20_1:1.106.2.4
	gdb_7_2-2010-09-02-release:1.128
	sid-snapshot-20100901:1.129
	sid-snapshot-20100801:1.129
	gdb_7_2-branch:1.128.0.2
	gdb_7_2-2010-07-07-branchpoint:1.128
	sid-snapshot-20100701:1.128
	sid-snapshot-20100601:1.126
	sid-snapshot-20100501:1.124
	sid-snapshot-20100401:1.124
	gdb_7_1-2010-03-18-release:1.123
	sid-snapshot-20100301:1.124
	gdb_7_1-branch:1.123.0.2
	gdb_7_1-2010-02-18-branchpoint:1.123
	sid-snapshot-20100201:1.123
	sid-snapshot-20100101:1.119
	gdb_7_0_1-2009-12-22-release:1.106
	sid-snapshot-20091201:1.114
	sid-snapshot-20091101:1.108
	binutils-2_20:1.106.2.1
	gdb_7_0-2009-10-06-release:1.106
	sid-snapshot-20091001:1.107
	gdb_7_0-branch:1.106.0.4
	gdb_7_0-2009-09-16-branchpoint:1.106
	arc-sim-20090309:1.88
	binutils-arc-20081103-branch:1.89.0.10
	binutils-arc-20081103-branchpoint:1.89
	binutils-2_20-branch:1.106.0.2
	binutils-2_20-branchpoint:1.106
	sid-snapshot-20090901:1.105
	sid-snapshot-20090801:1.105
	msnyder-checkpoint-072509-branch:1.105.0.2
	msnyder-checkpoint-072509-branchpoint:1.105
	sid-snapshot-20090701:1.100
	dje-cgen-play1-branch:1.98.0.2
	dje-cgen-play1-branchpoint:1.98
	sid-snapshot-20090601:1.95
	sid-snapshot-20090501:1.95
	sid-snapshot-20090401:1.94
	arc-20081103-branch:1.89.0.8
	arc-20081103-branchpoint:1.89
	arc-insight_6_8-branch:1.88.0.8
	arc-insight_6_8-branchpoint:1.88
	insight_6_8-branch:1.88.0.6
	insight_6_8-branchpoint:1.88
	sid-snapshot-20090301:1.93
	binutils-2_19_1:1.89
	sid-snapshot-20090201:1.92
	sid-snapshot-20090101:1.91
	reverse-20081226-branch:1.91.0.2
	reverse-20081226-branchpoint:1.91
	sid-snapshot-20081201:1.90
	multiprocess-20081120-branch:1.90.0.2
	multiprocess-20081120-branchpoint:1.90
	sid-snapshot-20081101:1.89
	binutils-2_19:1.89
	sid-snapshot-20081001:1.89
	reverse-20080930-branch:1.89.0.6
	reverse-20080930-branchpoint:1.89
	binutils-2_19-branch:1.89.0.4
	binutils-2_19-branchpoint:1.89
	sid-snapshot-20080901:1.89
	sid-snapshot-20080801:1.89
	reverse-20080717-branch:1.89.0.2
	reverse-20080717-branchpoint:1.89
	sid-snapshot-20080701:1.88
	msnyder-reverse-20080609-branch:1.88.0.4
	msnyder-reverse-20080609-branchpoint:1.88
	drow-reverse-20070409-branch:1.80.0.2
	drow-reverse-20070409-branchpoint:1.80
	sid-snapshot-20080601:1.88
	sid-snapshot-20080501:1.88
	sid-snapshot-20080403:1.88
	sid-snapshot-20080401:1.88
	gdb_6_8-2008-03-27-release:1.88
	sid-snapshot-20080301:1.88
	gdb_6_8-branch:1.88.0.2
	gdb_6_8-2008-02-26-branchpoint:1.88
	sid-snapshot-20080201:1.88
	sid-snapshot-20080101:1.88
	sid-snapshot-20071201:1.88
	sid-snapshot-20071101:1.87
	gdb_6_7_1-2007-10-29-release:1.86
	gdb_6_7-2007-10-10-release:1.86
	sid-snapshot-20071001:1.86
	gdb_6_7-branch:1.86.0.4
	gdb_6_7-2007-09-07-branchpoint:1.86
	binutils-2_18:1.86
	binutils-2_18-branch:1.86.0.2
	binutils-2_18-branchpoint:1.86
	insight_6_6-20070208-release:1.73
	binutils-csl-coldfire-4_1-32:1.62.2.11
	binutils-csl-sourcerygxx-4_1-32:1.62.2.11
	gdb_6_6-2006-12-18-release:1.73
	binutils-csl-innovasic-fido-3_4_4-33:1.62.2.11
	binutils-csl-sourcerygxx-3_4_4-32:1.41
	binutils-csl-coldfire-4_1-30:1.62.2.11
	binutils-csl-sourcerygxx-4_1-30:1.62.2.11
	binutils-csl-coldfire-4_1-28:1.62.2.11
	binutils-csl-sourcerygxx-4_1-29:1.62.2.11
	binutils-csl-sourcerygxx-4_1-28:1.62.2.11
	gdb_6_6-branch:1.73.0.2
	gdb_6_6-2006-11-15-branchpoint:1.73
	binutils-csl-arm-2006q3-27:1.62.2.11
	binutils-csl-sourcerygxx-4_1-27:1.62.2.11
	binutils-csl-arm-2006q3-26:1.62.2.11
	binutils-csl-sourcerygxx-4_1-26:1.62.2.11
	binutils-csl-sourcerygxx-4_1-25:1.62.2.11
	binutils-csl-sourcerygxx-4_1-24:1.62.2.9
	binutils-csl-sourcerygxx-4_1-23:1.62.2.9
	insight_6_5-20061003-release:1.65
	gdb-csl-symbian-6_4_50_20060226-12:1.61
	binutils-csl-sourcerygxx-4_1-21:1.62.2.9
	binutils-csl-arm-2006q3-21:1.62.2.9
	binutils-csl-sourcerygxx-4_1-22:1.62.2.9
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.62.2.9
	binutils-csl-sourcerygxx-4_1-20:1.62.2.8
	binutils-csl-arm-2006q3-19:1.62.2.8
	binutils-csl-sourcerygxx-4_1-19:1.62.2.8
	binutils-csl-sourcerygxx-4_1-18:1.62.2.8
	binutils-csl-renesas-4_1-9:1.62.2.7
	gdb-csl-sourcerygxx-3_4_4-25:1.60
	binutils-csl-sourcerygxx-3_4_4-25:1.41
	nickrob-async-20060828-mergepoint:1.69
	gdb-csl-symbian-6_4_50_20060226-11:1.61
	binutils-csl-renesas-4_1-8:1.62.2.7
	binutils-csl-renesas-4_1-7:1.62.2.6
	binutils-csl-renesas-4_1-6:1.62.2.6
	gdb-csl-sourcerygxx-4_1-17:1.61
	binutils-csl-sourcerygxx-4_1-17:1.62.2.6
	gdb-csl-20060226-branch-local-2:1.61
	gdb-csl-sourcerygxx-4_1-14:1.61
	binutils-csl-sourcerygxx-4_1-14:1.62.2.4
	binutils-csl-sourcerygxx-4_1-15:1.62.2.4
	gdb-csl-sourcerygxx-4_1-13:1.61
	binutils-csl-sourcerygxx-4_1-13:1.62.2.4
	binutils-2_17:1.62
	gdb-csl-sourcerygxx-4_1-12:1.61
	binutils-csl-sourcerygxx-4_1-12:1.62.2.4
	gdb-csl-sourcerygxx-3_4_4-21:1.61
	binutils-csl-sourcerygxx-3_4_4-21:1.62.2.4
	gdb_6_5-20060621-release:1.65
	binutils-csl-wrs-linux-3_4_4-24:1.41.4.4
	binutils-csl-wrs-linux-3_4_4-23:1.41.4.4
	gdb-csl-sourcerygxx-4_1-9:1.61
	binutils-csl-sourcerygxx-4_1-9:1.62.2.4
	gdb-csl-sourcerygxx-4_1-8:1.61
	binutils-csl-sourcerygxx-4_1-8:1.62.2.4
	gdb-csl-sourcerygxx-4_1-7:1.61
	binutils-csl-sourcerygxx-4_1-7:1.62.2.4
	gdb-csl-arm-2006q1-6:1.61
	binutils-csl-arm-2006q1-6:1.62.2.4
	gdb-csl-sourcerygxx-4_1-6:1.61
	binutils-csl-sourcerygxx-4_1-6:1.62.2.4
	binutils-csl-wrs-linux-3_4_4-22:1.41.4.4
	gdb-csl-symbian-6_4_50_20060226-10:1.61
	gdb-csl-symbian-6_4_50_20060226-9:1.61
	gdb-csl-symbian-6_4_50_20060226-8:1.61
	gdb-csl-coldfire-4_1-11:1.61
	binutils-csl-coldfire-4_1-11:1.62.2.4
	gdb-csl-sourcerygxx-3_4_4-19:1.61
	binutils-csl-sourcerygxx-3_4_4-19:1.62.2.4
	gdb-csl-coldfire-4_1-10:1.61
	gdb_6_5-branch:1.65.0.4
	gdb_6_5-2006-05-14-branchpoint:1.65
	binutils-csl-coldfire-4_1-10:1.62.2.4
	gdb-csl-sourcerygxx-4_1-5:1.61
	binutils-csl-sourcerygxx-4_1-5:1.62.2.4
	nickrob-async-20060513-branch:1.65.0.2
	nickrob-async-20060513-branchpoint:1.65
	gdb-csl-sourcerygxx-4_1-4:1.61
	binutils-csl-sourcerygxx-4_1-4:1.62.2.4
	msnyder-reverse-20060502-branch:1.64.0.2
	msnyder-reverse-20060502-branchpoint:1.64
	binutils-csl-wrs-linux-3_4_4-21:1.41.4.4
	gdb-csl-morpho-4_1-4:1.61
	binutils-csl-morpho-4_1-4:1.62.2.3
	gdb-csl-sourcerygxx-3_4_4-17:1.61
	binutils-csl-sourcerygxx-3_4_4-17:1.62.2.1
	binutils-csl-wrs-linux-3_4_4-20:1.41.4.4
	readline_5_1-import-branch:1.62.0.8
	readline_5_1-import-branchpoint:1.62
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.61
	binutils-2_17-branch:1.62.0.6
	binutils-2_17-branchpoint:1.62
	gdb-csl-symbian-20060226-branch:1.61.0.6
	gdb-csl-symbian-20060226-branchpoint:1.61
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.61
	msnyder-reverse-20060331-branch:1.62.0.4
	msnyder-reverse-20060331-branchpoint:1.62
	binutils-csl-2_17-branch:1.62.0.2
	binutils-csl-2_17-branchpoint:1.62
	gdb-csl-available-20060303-branch:1.61.0.4
	gdb-csl-available-20060303-branchpoint:1.61
	gdb-csl-20060226-branch:1.61.0.2
	gdb-csl-20060226-branchpoint:1.61
	gdb_6_4-20051202-release:1.59
	msnyder-fork-checkpoint-branch:1.60.0.4
	msnyder-fork-checkpoint-branchpoint:1.60
	gdb-csl-gxxpro-6_3-branch:1.60.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.60
	gdb_6_4-branch:1.59.0.2
	gdb_6_4-2005-11-01-branchpoint:1.59
	gdb-csl-arm-20051020-branch:1.57.0.2
	gdb-csl-arm-20051020-branchpoint:1.57
	binutils-csl-gxxpro-3_4-branch:1.41.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.41
	binutils-2_16_1:1.41
	msnyder-tracepoint-checkpoint-branch:1.46.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.46
	gdb-csl-arm-20050325-2005-q1b:1.44
	binutils-csl-arm-2005q1b:1.41.4.4
	binutils-2_16:1.41
	gdb-csl-arm-20050325-2005-q1a:1.44
	binutils-csl-arm-2005q1a:1.41.4.1
	csl-arm-20050325-branch:1.44.0.2
	csl-arm-20050325-branchpoint:1.44
	binutils-csl-arm-2005q1-branch:1.41.0.4
	binutils-csl-arm-2005q1-branchpoint:1.41
	binutils-2_16-branch:1.41.0.2
	binutils-2_16-branchpoint:1.41
	csl-arm-2004-q3d:1.38
	gdb_6_3-20041109-release:1.38
	gdb_6_3-branch:1.38.0.2
	gdb_6_3-20041019-branchpoint:1.38
	csl-arm-2004-q3:1.38
	drow_intercu-merge-20040921:1.37
	drow_intercu-merge-20040915:1.37
	jimb-gdb_6_2-e500-branch:1.37.0.20
	jimb-gdb_6_2-e500-branchpoint:1.37
	gdb_6_2-20040730-release:1.37
	gdb_6_2-branch:1.37.0.16
	gdb_6_2-2004-07-10-gmt-branchpoint:1.37
	gdb_6_1_1-20040616-release:1.37
	binutils-2_15:1.37
	binutils-2_15-branchpoint:1.37
	csl-arm-2004-q1a:1.37
	csl-arm-2004-q1:1.37
	gdb_6_1-2004-04-05-release:1.37
	drow_intercu-merge-20040402:1.37
	drow_intercu-merge-20040327:1.37
	ezannoni_pie-20040323-branch:1.37.0.14
	ezannoni_pie-20040323-branchpoint:1.37
	cagney_tramp-20040321-mergepoint:1.37
	cagney_tramp-20040309-branch:1.37.0.12
	cagney_tramp-20040309-branchpoint:1.37
	gdb_6_1-branch:1.37.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.37
	drow_intercu-20040221-branch:1.37.0.8
	drow_intercu-20040221-branchpoint:1.37
	binutils-2_15-branch:1.37.0.6
	cagney_bfdfile-20040213-branch:1.37.0.4
	cagney_bfdfile-20040213-branchpoint:1.37
	drow-cplus-merge-20040208:1.37
	carlton_dictionary-20040126-merge:1.37
	cagney_bigcore-20040122-branch:1.37.0.2
	cagney_bigcore-20040122-branchpoint:1.37
	drow-cplus-merge-20040113:1.37
	csl-arm-2003-q4:1.37
	drow-cplus-merge-20031224:1.37
	drow-cplus-merge-20031220:1.37
	carlton_dictionary-20031215-merge:1.37
	drow-cplus-merge-20031214:1.37
	carlton-dictionary-20031111-merge:1.35
	gdb_6_0-2003-10-04-release:1.32
	kettenis_sparc-20030918-branch:1.34.0.6
	kettenis_sparc-20030918-branchpoint:1.34
	carlton_dictionary-20030917-merge:1.34
	ezannoni_pie-20030916-branchpoint:1.34
	ezannoni_pie-20030916-branch:1.34.0.4
	cagney_x86i386-20030821-branch:1.34.0.2
	cagney_x86i386-20030821-branchpoint:1.34
	carlton_dictionary-20030805-merge:1.33
	carlton_dictionary-20030627-merge:1.32
	gdb_6_0-branch:1.32.0.22
	gdb_6_0-2003-06-23-branchpoint:1.32
	jimb-ppc64-linux-20030613-branch:1.32.0.20
	jimb-ppc64-linux-20030613-branchpoint:1.32
	binutils-2_14:1.32
	cagney_convert-20030606-branch:1.32.0.18
	cagney_convert-20030606-branchpoint:1.32
	cagney_writestrings-20030508-branch:1.32.0.16
	cagney_writestrings-20030508-branchpoint:1.32
	jimb-ppc64-linux-20030528-branch:1.32.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.32
	carlton_dictionary-20030523-merge:1.32
	cagney_fileio-20030521-branch:1.32.0.12
	cagney_fileio-20030521-branchpoint:1.32
	kettenis_i386newframe-20030517-mergepoint:1.32
	jimb-ppc64-linux-20030509-branch:1.32.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.32
	kettenis_i386newframe-20030504-mergepoint:1.32
	carlton_dictionary-20030430-merge:1.32
	binutils-2_14-branch:1.32.0.8
	binutils-2_14-branchpoint:1.32
	kettenis_i386newframe-20030419-branch:1.32.0.6
	kettenis_i386newframe-20030419-branchpoint:1.32
	carlton_dictionary-20030416-merge:1.32
	cagney_frameaddr-20030409-mergepoint:1.32
	kettenis_i386newframe-20030406-branch:1.32.0.4
	kettenis_i386newframe-20030406-branchpoint:1.32
	cagney_frameaddr-20030403-branchpoint:1.32
	cagney_frameaddr-20030403-branch:1.32.0.2
	cagney_framebase-20030330-mergepoint:1.31
	cagney_framebase-20030326-branch:1.31.0.2
	cagney_framebase-20030326-branchpoint:1.31
	cagney_lazyid-20030317-branch:1.30.0.12
	cagney_lazyid-20030317-branchpoint:1.30
	kettenis-i386newframe-20030316-mergepoint:1.30
	offbyone-20030313-branch:1.30.0.10
	offbyone-20030313-branchpoint:1.30
	kettenis-i386newframe-20030308-branch:1.30.0.8
	kettenis-i386newframe-20030308-branchpoint:1.30
	carlton_dictionary-20030305-merge:1.30
	cagney_offbyone-20030303-branch:1.30.0.6
	cagney_offbyone-20030303-branchpoint:1.30
	carlton_dictionary-20030207-merge:1.30
	interps-20030202-branch:1.30.0.4
	interps-20030202-branchpoint:1.30
	cagney-unwind-20030108-branch:1.30.0.2
	cagney-unwind-20030108-branchpoint:1.30
	binutils-2_13_2_1:1.28
	binutils-2_13_2:1.28
	carlton_dictionary-20021223-merge:1.30
	gdb_5_3-2002-12-12-release:1.28
	carlton_dictionary-20021115-merge:1.28
	binutils-2_13_1:1.28
	kseitz_interps-20021105-merge:1.28
	kseitz_interps-20021103-merge:1.28
	drow-cplus-merge-20021020:1.28
	drow-cplus-merge-20021025:1.28
	carlton_dictionary-20021025-merge:1.28
	carlton_dictionary-20021011-merge:1.28
	drow-cplus-branch:1.28.0.16
	drow-cplus-branchpoint:1.28
	kseitz_interps-20020930-merge:1.28
	carlton_dictionary-20020927-merge:1.28
	carlton_dictionary-branch:1.28.0.14
	carlton_dictionary-20020920-branchpoint:1.28
	sid-20020905-branchpoint:1.28
	sid-20020905-branch:1.28.0.12
	gdb_5_3-branch:1.28.0.10
	gdb_5_3-2002-09-04-branchpoint:1.28
	kseitz_interps-20020829-merge:1.28
	cagney_sysregs-20020825-branch:1.28.0.8
	cagney_sysregs-20020825-branchpoint:1.28
	readline_4_3-import-branch:1.28.0.6
	readline_4_3-import-branchpoint:1.28
	binutils-2_13:1.28
	gdb_5_2_1-2002-07-23-release:1.27
	binutils-2_13-branchpoint:1.28
	binutils-2_13-branch:1.28.0.4
	kseitz_interps-20020528-branch:1.28.0.2
	kseitz_interps-20020528-branchpoint:1.28
	cagney_regbuf-20020515-branch:1.27.0.8
	cagney_regbuf-20020515-branchpoint:1.27
	binutils-2_12_1:1.27
	jimb-macro-020506-branch:1.27.0.6
	jimb-macro-020506-branchpoint:1.27
	gdb_5_2-2002-04-29-release:1.27
	binutils-2_12:1.27
	gdb_5_2-branch:1.27.0.4
	gdb_5_2-2002-03-03-branchpoint:1.27
	binutils-2_12-branch:1.27.0.2
	binutils-2_12-branchpoint:1.27
	gdb_5_1_1-2002-01-24-release:1.23
	gdb_5_1_0_1-2002-01-03-release:1.23
	cygnus_cvs_20020108_pre:1.25
	gdb_5_1_0_1-2002-01-03-branch:1.23.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.23
	gdb_5_1-2001-11-21-release:1.23
	gdb_s390-2001-09-26-branch:1.23.0.4
	gdb_s390-2001-09-26-branchpoint:1.23
	gdb_5_1-2001-07-29-branch:1.23.0.2
	gdb_5_1-2001-07-29-branchpoint:1.23
	binutils-2_11_2:1.20.2.1
	binutils-2_11_1:1.20.2.1
	binutils-2_11:1.20
	x86_64versiong3:1.20
	binutils-2_11-branch:1.20.0.2
	insight-precleanup-2001-01-01:1.19
	binutils-2_10_1:1.15.2.1
	binutils-2_10:1.15.2.1
	gdb-premipsmulti-2000-06-06-branch:1.16.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.16
	gdb_5_0-2000-05-19-release:1.15
	gdb_4_18_2-2000-05-18-release:1.15
	gdb_4_95_1-2000-05-11-snapshot:1.15
	gdb_4_95_0-2000-04-27-snapshot:1.15
	gdb_5_0-2000-04-10-branch:1.15.0.4
	gdb_5_0-2000-04-10-branchpoint:1.15
	binutils-2_10-branch:1.15.0.2
	binutils-2_10-branchpoint:1.15
	binutils_latest_snapshot:1.173
	repo-unification-2000-02-06:1.13
	binu_ss_19990721:1.6
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.173
date	2013.10.15.13.30.40;	author ramana;	state Exp;
branches;
next	1.172;

1.172
date	2013.09.04.07.59.33;	author nickc;	state Exp;
branches;
next	1.171;

1.171
date	2013.03.11.11.09.33;	author ktkachov;	state Exp;
branches;
next	1.170;

1.170
date	2013.02.11.10.15.51;	author rearnsha;	state Exp;
branches;
next	1.169;

1.169
date	2012.10.11.15.33.07;	author rearnsha;	state Exp;
branches;
next	1.168;

1.168
date	2012.09.18.14.52.43;	author rearnsha;	state Exp;
branches;
next	1.167;

1.167
date	2012.08.24.08.14.40;	author mgretton;	state Exp;
branches;
next	1.166;

1.166
date	2012.08.24.08.14.04;	author mgretton;	state Exp;
branches;
next	1.165;

1.165
date	2012.08.24.08.13.24;	author mgretton;	state Exp;
branches;
next	1.164;

1.164
date	2012.08.24.08.12.45;	author mgretton;	state Exp;
branches;
next	1.163;

1.163
date	2012.08.24.08.11.44;	author mgretton;	state Exp;
branches;
next	1.162;

1.162
date	2012.08.24.08.11.13;	author mgretton;	state Exp;
branches;
next	1.161;

1.161
date	2012.08.24.08.09.50;	author mgretton;	state Exp;
branches;
next	1.160;

1.160
date	2012.08.24.08.07.36;	author mgretton;	state Exp;
branches;
next	1.159;

1.159
date	2012.08.24.08.06.36;	author mgretton;	state Exp;
branches;
next	1.158;

1.158
date	2012.08.24.08.03.39;	author mgretton;	state Exp;
branches;
next	1.157;

1.157
date	2012.08.24.08.02.51;	author mgretton;	state Exp;
branches;
next	1.156;

1.156
date	2012.08.24.08.02.09;	author mgretton;	state Exp;
branches;
next	1.155;

1.155
date	2012.08.24.08.01.18;	author mgretton;	state Exp;
branches;
next	1.154;

1.154
date	2012.08.24.08.00.20;	author mgretton;	state Exp;
branches;
next	1.153;

1.153
date	2012.08.24.07.59.05;	author mgretton;	state Exp;
branches;
next	1.152;

1.152
date	2012.07.24.12.56.47;	author nickc;	state Exp;
branches
	1.152.2.1;
next	1.151;

1.151
date	2012.05.16.10.53.49;	author nickc;	state Exp;
branches;
next	1.150;

1.150
date	2012.05.11.09.41.21;	author nickc;	state Exp;
branches;
next	1.149;

1.149
date	2011.10.18.14.41.55;	author jules;	state Exp;
branches;
next	1.148;

1.148
date	2011.07.12.08.45.45;	author nickc;	state Exp;
branches;
next	1.147;

1.147
date	2011.07.01.16.11.27;	author nickc;	state Exp;
branches;
next	1.146;

1.146
date	2011.06.03.10.04.03;	author nickc;	state Exp;
branches;
next	1.145;

1.145
date	2011.06.02.15.32.10;	author nathan;	state Exp;
branches;
next	1.144;

1.144
date	2011.06.02.13.43.24;	author nickc;	state Exp;
branches;
next	1.143;

1.143
date	2011.04.19.07.44.12;	author nickc;	state Exp;
branches;
next	1.142;

1.142
date	2011.04.19.07.27.32;	author nickc;	state Exp;
branches;
next	1.141;

1.141
date	2011.04.12.16.01.47;	author nickc;	state Exp;
branches;
next	1.140;

1.140
date	2011.04.11.18.49.06;	author jules;	state Exp;
branches;
next	1.139;

1.139
date	2011.04.08.11.42.19;	author pbrook;	state Exp;
branches;
next	1.138;

1.138
date	2011.03.14.16.04.08;	author rsandifo;	state Exp;
branches;
next	1.137;

1.137
date	2011.03.14.15.55.03;	author rsandifo;	state Exp;
branches;
next	1.136;

1.136
date	2011.01.06.14.30.43;	author nathan;	state Exp;
branches;
next	1.135;

1.135
date	2010.09.27.09.47.04;	author mgretton;	state Exp;
branches;
next	1.134;

1.134
date	2010.09.23.15.52.19;	author mgretton;	state Exp;
branches;
next	1.133;

1.133
date	2010.09.23.15.37.45;	author mgretton;	state Exp;
branches;
next	1.132;

1.132
date	2010.09.23.15.26.23;	author mgretton;	state Exp;
branches;
next	1.131;

1.131
date	2010.09.23.15.18.19;	author mgretton;	state Exp;
branches;
next	1.130;

1.130
date	2010.09.17.10.13.41;	author mgretton;	state Exp;
branches;
next	1.129;

1.129
date	2010.07.08.22.40.28;	author rearnsha;	state Exp;
branches;
next	1.128;

1.128
date	2010.06.28.09.10.25;	author mgretton;	state Exp;
branches;
next	1.127;

1.127
date	2010.06.07.10.43.52;	author mgretton;	state Exp;
branches;
next	1.126;

1.126
date	2010.05.28.16.04.21;	author mgretton;	state Exp;
branches;
next	1.125;

1.125
date	2010.05.11.17.36.29;	author nickc;	state Exp;
branches;
next	1.124;

1.124
date	2010.02.24.15.11.42;	author nickc;	state Exp;
branches;
next	1.123;

1.123
date	2010.01.29.16.47.55;	author drow;	state Exp;
branches;
next	1.122;

1.122
date	2010.01.20.10.54.03;	author nickc;	state Exp;
branches;
next	1.121;

1.121
date	2010.01.06.15.02.44;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	2010.01.04.10.18.32;	author nickc;	state Exp;
branches;
next	1.119;

1.119
date	2009.12.17.09.52.15;	author nickc;	state Exp;
branches;
next	1.118;

1.118
date	2009.12.14.16.38.22;	author nickc;	state Exp;
branches;
next	1.117;

1.117
date	2009.12.11.13.42.16;	author nickc;	state Exp;
branches;
next	1.116;

1.116
date	2009.12.09.08.38.04;	author nickc;	state Exp;
branches;
next	1.115;

1.115
date	2009.12.02.20.26.30;	author nickc;	state Exp;
branches;
next	1.114;

1.114
date	2009.11.19.14.07.10;	author nickc;	state Exp;
branches;
next	1.113;

1.113
date	2009.11.17.17.20.26;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	2009.11.17.10.43.09;	author ramana;	state Exp;
branches;
next	1.111;

1.111
date	2009.11.12.14.49.45;	author drow;	state Exp;
branches;
next	1.110;

1.110
date	2009.11.11.09.44.45;	author nickc;	state Exp;
branches;
next	1.109;

1.109
date	2009.11.02.13.44.05;	author pbrook;	state Exp;
branches;
next	1.108;

1.108
date	2009.10.03.00.39.53;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2009.09.25.19.13.27;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2009.09.02.07.20.29;	author amodra;	state Exp;
branches
	1.106.2.1;
next	1.105;

1.105
date	2009.07.20.12.11.18;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2009.07.14.14.16.34;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2009.07.10.16.58.54;	author dougkwan;	state Exp;
branches;
next	1.102;

1.102
date	2009.07.07.16.15.27;	author nickc;	state Exp;
branches;
next	1.101;

1.101
date	2009.07.07.14.46.14;	author nickc;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.30.11.57.04;	author nickc;	state Exp;
branches;
next	1.99;

1.99
date	2009.06.29.08.08.14;	author nickc;	state Exp;
branches;
next	1.98;

1.98
date	2009.06.18.10.31.21;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2009.06.15.15.42.34;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2009.06.15.11.37.26;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2009.04.01.15.45.13;	author clyon;	state Exp;
branches;
next	1.94;

1.94
date	2009.03.30.14.41.31;	author jsm28;	state Exp;
branches;
next	1.93;

1.93
date	2009.02.23.14.58.34;	author rearnsha;	state Exp;
branches;
next	1.92;

1.92
date	2009.01.29.11.48.34;	author jsm28;	state Exp;
branches;
next	1.91;

1.91
date	2008.12.15.17.24.13;	author rearnsha;	state Exp;
branches;
next	1.90;

1.90
date	2008.11.18.15.45.05;	author clm;	state Exp;
branches;
next	1.89;

1.89
date	2008.07.07.18.35.24;	author shebs;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.07.14.40.40;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2007.10.26.11.27.12;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2007.06.26.21.36.37;	author pbrook;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.05.22.02.47;	author pbrook;	state Exp;
branches;
next	1.83;

1.83
date	2007.04.24.13.21.32;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2007.04.21.19.44.09;	author rearnsha;	state Exp;
branches;
next	1.81;

1.81
date	2007.04.20.00.00.21;	author rearnsha;	state Exp;
branches;
next	1.80;

1.80
date	2007.03.27.21.09.53;	author pbrook;	state Exp;
branches;
next	1.79;

1.79
date	2007.03.24.02.51.28;	author pbrook;	state Exp;
branches;
next	1.78;

1.78
date	2007.03.24.01.29.00;	author pbrook;	state Exp;
branches;
next	1.77;

1.77
date	2007.01.04.20.08.36;	author pbrook;	state Exp;
branches;
next	1.76;

1.76
date	2007.01.04.15.33.12;	author jules;	state Exp;
branches;
next	1.75;

1.75
date	2006.11.29.16.26.56;	author pbrook;	state Exp;
branches;
next	1.74;

1.74
date	2006.11.22.17.45.57;	author drow;	state Exp;
branches;
next	1.73;

1.73
date	2006.10.31.20.21.57;	author pbrook;	state Exp;
branches;
next	1.72;

1.72
date	2006.09.26.12.04.45;	author jsm28;	state Exp;
branches;
next	1.71;

1.71
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2006.09.05.14.07.22;	author pbrook;	state Exp;
branches;
next	1.69;

1.69
date	2006.07.19.12.53.33;	author pbrook;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.05.17.08.47;	author jules;	state Exp;
branches;
next	1.67;

1.67
date	2006.06.12.15.31.28;	author jules;	state Exp;
branches;
next	1.66;

1.66
date	2006.06.07.14.08.19;	author pbrook;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.05.18.56.01;	author jules;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.26.16.02.07;	author jules;	state Exp;
branches;
next	1.63;

1.63
date	2006.04.26.15.40.55;	author jules;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.16.15.08.48;	author pbrook;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2006.02.24.15.36.36;	author pbrook;	state Exp;
branches;
next	1.60;

1.60
date	2005.11.02.16.53.11;	author pbrook;	state Exp;
branches;
next	1.59;

1.59
date	2005.10.31.06.10.33;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.26.14.09.29;	author pbrook;	state Exp;
branches;
next	1.57;

1.57
date	2005.10.08.14.52.07;	author rearnsha;	state Exp;
branches;
next	1.56;

1.56
date	2005.09.08.12.49.27;	author pbrook;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.02.14.54.27;	author pbrook;	state Exp;
branches;
next	1.54;

1.54
date	2005.09.02.13.12.45;	author pbrook;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.30.11.21.59;	author pbrook;	state Exp;
branches;
next	1.52;

1.52
date	2005.07.29.17.39.39;	author pbrook;	state Exp;
branches;
next	1.51;

1.51
date	2005.07.29.17.28.33;	author pbrook;	state Exp;
branches;
next	1.50;

1.50
date	2005.07.07.19.27.48;	author wilson;	state Exp;
branches;
next	1.49;

1.49
date	2005.07.07.11.37.08;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2005.06.08.17.27.40;	author zack;	state Exp;
branches;
next	1.47;

1.47
date	2005.06.07.22.16.52;	author zack;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.18.05.40.12;	author zack;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.07.07.34.26;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.12.18.25.47;	author zack;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.12.18.17.42;	author zack;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.12.18.14.05;	author zack;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.29.10.12.57;	author rearnsha;	state Exp;
branches
	1.41.4.1;
next	1.40;

1.40
date	2004.11.27.11.09.21;	author rearnsha;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.17.17.50.28;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2004.09.30.16.21.43;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.06.01.25.29;	author mmitchel;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.14.15.12.44;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.03.14.47.22;	author drow;	state Exp;
branches;
next	1.34;

1.34
date	2003.08.19.13.05.41;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.18.11.34.41;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.01.13.08.06;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.25.20.56.01;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2002.12.02.13.13.37;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.23.12.48.23;	author nickc;	state Exp;
branches
	1.28.14.1
	1.28.16.1;
next	1.27;

1.27
date	2002.01.19.12.27.24;	author rearnsha;	state Exp;
branches
	1.27.8.1;
next	1.26;

1.26
date	2002.01.15.15.41.23;	author rearnsha;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.08.18.50.37;	author aldyh;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.19.17.40.28;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.16.19.04.31;	author pb;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.13.22.58.34;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.06.22.33.47;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.09.20.29.48;	author nickc;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.11.25.00.21.40;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.04.05.47.22;	author aoliva;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.26.16.50.29;	author scottb;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.15.19.25.21;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.14.19.02.47;	author fnasser;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.02.07.18.27.19;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.28.01.55.09;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.27.22.17.12;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.27.20.05.28;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.25.22.10.13;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.03.20.50.57;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	99.11.16.03.37.02;	author dlindsay;	state Exp;
branches;
next	1.7;

1.7
date	99.10.27.18.14.17;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	99.07.05.07.44.09;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.06.21.10.11.50;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.16.02.58.52;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.06.16.02.24.29;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.06.04.07.14.10;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.152.2.1
date	2012.08.28.10.50.38;	author mgretton;	state Exp;
branches;
next	1.152.2.2;

1.152.2.2
date	2012.09.18.15.47.02;	author gingold;	state Exp;
branches;
next	;

1.106.2.1
date	2009.10.03.00.40.25;	author amodra;	state Exp;
branches;
next	1.106.2.2;

1.106.2.2
date	2010.01.14.11.29.41;	author gingold;	state Exp;
branches;
next	1.106.2.3;

1.106.2.3
date	2010.01.21.12.03.13;	author nickc;	state Exp;
branches;
next	1.106.2.4;

1.106.2.4
date	2010.02.19.09.36.43;	author mgretton;	state Exp;
branches;
next	;

1.62.2.1
date	2006.04.03.00.03.34;	author jules;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2006.04.26.16.24.26;	author jules;	state Exp;
branches;
next	1.62.2.3;

1.62.2.3
date	2006.04.26.16.30.48;	author jules;	state Exp;
branches;
next	1.62.2.4;

1.62.2.4
date	2006.04.29.17.54.32;	author pbrook;	state Exp;
branches;
next	1.62.2.5;

1.62.2.5
date	2006.07.19.13.08.21;	author pbrook;	state Exp;
branches;
next	1.62.2.6;

1.62.2.6
date	2006.07.20.14.16.42;	author jules;	state Exp;
branches;
next	1.62.2.7;

1.62.2.7
date	2006.08.18.10.30.35;	author jules;	state Exp;
branches;
next	1.62.2.8;

1.62.2.8
date	2006.09.04.15.55.36;	author pbrook;	state Exp;
branches;
next	1.62.2.9;

1.62.2.9
date	2006.09.19.18.44.37;	author jsm28;	state Exp;
branches;
next	1.62.2.10;

1.62.2.10
date	2006.10.25.23.28.52;	author pbrook;	state Exp;
branches;
next	1.62.2.11;

1.62.2.11
date	2006.10.26.19.41.54;	author pbrook;	state Exp;
branches;
next	;

1.41.4.1
date	2005.03.28.15.30.09;	author drow;	state Exp;
branches;
next	1.41.4.2;

1.41.4.2
date	2005.04.26.05.31.43;	author zack;	state Exp;
branches;
next	1.41.4.3;

1.41.4.3
date	2005.04.30.23.36.15;	author pbrook;	state Exp;
branches;
next	1.41.4.4;

1.41.4.4
date	2005.04.30.23.50.32;	author pbrook;	state Exp;
branches;
next	;

1.28.14.1
date	2002.12.23.19.39.29;	author carlton;	state Exp;
branches;
next	1.28.14.2;

1.28.14.2
date	2003.04.16.19.57.05;	author carlton;	state Exp;
branches;
next	1.28.14.3;

1.28.14.3
date	2003.08.05.17.13.29;	author carlton;	state Exp;
branches;
next	1.28.14.4;

1.28.14.4
date	2003.09.17.21.28.57;	author carlton;	state Exp;
branches;
next	1.28.14.5;

1.28.14.5
date	2003.11.11.23.51.16;	author carlton;	state Exp;
branches;
next	1.28.14.6;

1.28.14.6
date	2003.12.16.00.01.13;	author carlton;	state Exp;
branches;
next	;

1.28.16.1
date	2003.12.14.20.28.04;	author drow;	state Exp;
branches;
next	;

1.27.8.1
date	2002.06.15.16.43.20;	author cagney;	state Exp;
branches;
next	;

1.20.2.1
date	2001.06.07.03.18.33;	author amodra;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.07.16.21.42.48;	author pb;	state Exp;
branches;
next	;

1.15.2.1
date	2000.05.30.13.42.11;	author scottb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches;
next	;


desc
@@


1.173
log
@Fix neon vshll disassembly.

opcodes/
2013-10-15  Ramana Radhakrishnan  <ramana.radhakrishnan@@arm.com>

	* arm-dis.c (neon_opcodes): Adjust print string for vshll.

gas/testsuite/
2013-10-15  Ramana Radhakrishnan  <ramana.radhakrishnan@@arm.com>

	* gas/arm/neon-cov.d: Adjust output.
@
text
@/* Instruction printing code for the ARM
   Copyright 1994-2013 Free Software Foundation, Inc.
   Contributed by Richard Earnshaw (rwe@@pegasus.esprit.ec.org)
   Modification by James G. Smith (jsmith@@cygnus.co.uk)

   This file is part of libopcodes.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"

#include "dis-asm.h"
#include "opcode/arm.h"
#include "opintl.h"
#include "safe-ctype.h"
#include "floatformat.h"

/* FIXME: This shouldn't be done here.  */
#include "coff/internal.h"
#include "libcoff.h"
#include "elf-bfd.h"
#include "elf/internal.h"
#include "elf/arm.h"

/* FIXME: Belongs in global header.  */
#ifndef strneq
#define strneq(a,b,n)	(strncmp ((a), (b), (n)) == 0)
#endif

#ifndef NUM_ELEM
#define NUM_ELEM(a)     (sizeof (a) / sizeof (a)[0])
#endif

/* Cached mapping symbol state.  */
enum map_type
{
  MAP_ARM,
  MAP_THUMB,
  MAP_DATA
};

struct arm_private_data
{
  /* The features to use when disassembling optional instructions.  */
  arm_feature_set features;

  /* Whether any mapping symbols are present in the provided symbol
     table.  -1 if we do not know yet, otherwise 0 or 1.  */
  int has_mapping_symbols;

  /* Track the last type (although this doesn't seem to be useful) */
  enum map_type last_type;

  /* Tracking symbol table information */
  int last_mapping_sym;
  bfd_vma last_mapping_addr;
};

struct opcode32
{
  unsigned long arch;		/* Architecture defining this insn.  */
  unsigned long value;		/* If arch == 0 then value is a sentinel.  */
  unsigned long mask;		/* Recognise insn if (op & mask) == value.  */
  const char *  assembler;	/* How to disassemble this insn.  */
};

struct opcode16
{
  unsigned long arch;		/* Architecture defining this insn.  */
  unsigned short value, mask;	/* Recognise insn if (op & mask) == value.  */
  const char *assembler;	/* How to disassemble this insn.  */
};

/* print_insn_coprocessor recognizes the following format control codes:

   %%			%

   %c			print condition code (always bits 28-31 in ARM mode)
   %q			print shifter argument
   %u			print condition code (unconditional in ARM mode,
                          UNPREDICTABLE if not AL in Thumb)
   %A			print address for ldc/stc/ldf/stf instruction
   %B			print vstm/vldm register list
   %I                   print cirrus signed shift immediate: bits 0..3|4..6
   %F			print the COUNT field of a LFM/SFM instruction.
   %P			print floating point precision in arithmetic insn
   %Q			print floating point precision in ldf/stf insn
   %R			print floating point rounding mode

   %<bitfield>c		print as a condition code (for vsel)
   %<bitfield>r		print as an ARM register
   %<bitfield>R		as %<>r but r15 is UNPREDICTABLE
   %<bitfield>ru        as %<>r but each u register must be unique.
   %<bitfield>d		print the bitfield in decimal
   %<bitfield>k		print immediate for VFPv3 conversion instruction
   %<bitfield>x		print the bitfield in hex
   %<bitfield>X		print the bitfield as 1 hex digit without leading "0x"
   %<bitfield>f		print a floating point constant if >7 else a
			floating point register
   %<bitfield>w         print as an iWMMXt width field - [bhwd]ss/us
   %<bitfield>g         print as an iWMMXt 64-bit register
   %<bitfield>G         print as an iWMMXt general purpose or control register
   %<bitfield>D		print as a NEON D register
   %<bitfield>Q		print as a NEON Q register

   %y<code>		print a single precision VFP reg.
			  Codes: 0=>Sm, 1=>Sd, 2=>Sn, 3=>multi-list, 4=>Sm pair
   %z<code>		print a double precision VFP reg
			  Codes: 0=>Dm, 1=>Dd, 2=>Dn, 3=>multi-list

   %<bitfield>'c	print specified char iff bitfield is all ones
   %<bitfield>`c	print specified char iff bitfield is all zeroes
   %<bitfield>?ab...    select from array of values in big endian order
   
   %L			print as an iWMMXt N/M width field.
   %Z			print the Immediate of a WSHUFH instruction.
   %l			like 'A' except use byte offsets for 'B' & 'H'
			versions.
   %i			print 5-bit immediate in bits 8,3..0
			(print "32" when 0)
   %r			print register offset address for wldt/wstr instruction.  */

enum opcode_sentinel_enum
{
  SENTINEL_IWMMXT_START = 1,
  SENTINEL_IWMMXT_END,
  SENTINEL_GENERIC_START
} opcode_sentinels;

#define UNDEFINED_INSTRUCTION      "\t\t; <UNDEFINED> instruction: %0-31x"
#define UNPREDICTABLE_INSTRUCTION  "\t; <UNPREDICTABLE>"

/* Common coprocessor opcodes shared between Arm and Thumb-2.  */

static const struct opcode32 coprocessor_opcodes[] =
{
  /* XScale instructions.  */
  {ARM_CEXT_XSCALE, 0x0e200010, 0x0fff0ff0, "mia%c\tacc0, %0-3r, %12-15r"},
  {ARM_CEXT_XSCALE, 0x0e280010, 0x0fff0ff0, "miaph%c\tacc0, %0-3r, %12-15r"},
  {ARM_CEXT_XSCALE, 0x0e2c0010, 0x0ffc0ff0, "mia%17'T%17`B%16'T%16`B%c\tacc0, %0-3r, %12-15r"},
  {ARM_CEXT_XSCALE, 0x0c400000, 0x0ff00fff, "mar%c\tacc0, %12-15r, %16-19r"},
  {ARM_CEXT_XSCALE, 0x0c500000, 0x0ff00fff, "mra%c\t%12-15r, %16-19r, acc0"},

  /* Intel Wireless MMX technology instructions.  */
  { 0, SENTINEL_IWMMXT_START, 0, "" },
  {ARM_CEXT_IWMMXT, 0x0e130130, 0x0f3f0fff, "tandc%22-23w%c\t%12-15r"},
  {ARM_CEXT_XSCALE, 0x0e400010, 0x0ff00f3f, "tbcst%6-7w%c\t%16-19g, %12-15r"},
  {ARM_CEXT_XSCALE, 0x0e130170, 0x0f3f0ff8, "textrc%22-23w%c\t%12-15r, #%0-2d"},
  {ARM_CEXT_XSCALE, 0x0e100070, 0x0f300ff0, "textrm%3?su%22-23w%c\t%12-15r, %16-19g, #%0-2d"},
  {ARM_CEXT_XSCALE, 0x0e600010, 0x0ff00f38, "tinsr%6-7w%c\t%16-19g, %12-15r, #%0-2d"},
  {ARM_CEXT_XSCALE, 0x0e000110, 0x0ff00fff, "tmcr%c\t%16-19G, %12-15r"},
  {ARM_CEXT_XSCALE, 0x0c400000, 0x0ff00ff0, "tmcrr%c\t%0-3g, %12-15r, %16-19r"},
  {ARM_CEXT_XSCALE, 0x0e2c0010, 0x0ffc0e10, "tmia%17?tb%16?tb%c\t%5-8g, %0-3r, %12-15r"},
  {ARM_CEXT_XSCALE, 0x0e200010, 0x0fff0e10, "tmia%c\t%5-8g, %0-3r, %12-15r"},
  {ARM_CEXT_XSCALE, 0x0e280010, 0x0fff0e10, "tmiaph%c\t%5-8g, %0-3r, %12-15r"},
  {ARM_CEXT_XSCALE, 0x0e100030, 0x0f300fff, "tmovmsk%22-23w%c\t%12-15r, %16-19g"},
  {ARM_CEXT_XSCALE, 0x0e100110, 0x0ff00ff0, "tmrc%c\t%12-15r, %16-19G"},
  {ARM_CEXT_XSCALE, 0x0c500000, 0x0ff00ff0, "tmrrc%c\t%12-15r, %16-19r, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e130150, 0x0f3f0fff, "torc%22-23w%c\t%12-15r"},
  {ARM_CEXT_XSCALE, 0x0e120190, 0x0f3f0fff, "torvsc%22-23w%c\t%12-15r"},
  {ARM_CEXT_XSCALE, 0x0e2001c0, 0x0f300fff, "wabs%22-23w%c\t%12-15g, %16-19g"},
  {ARM_CEXT_XSCALE, 0x0e0001c0, 0x0f300fff, "wacc%22-23w%c\t%12-15g, %16-19g"},
  {ARM_CEXT_XSCALE, 0x0e000180, 0x0f000ff0, "wadd%20-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e2001a0, 0x0fb00ff0, "waddbhus%22?ml%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ea001a0, 0x0ff00ff0, "waddsubhx%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e000020, 0x0f800ff0, "waligni%c\t%12-15g, %16-19g, %0-3g, #%20-22d"},
  {ARM_CEXT_XSCALE, 0x0e800020, 0x0fc00ff0, "walignr%20-21d%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e200000, 0x0fe00ff0, "wand%20'n%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e800000, 0x0fa00ff0, "wavg2%22?hb%20'r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e400000, 0x0fe00ff0, "wavg4%20'r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e000060, 0x0f300ff0, "wcmpeq%22-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e100060, 0x0f100ff0, "wcmpgt%21?su%22-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0xfc500100, 0xfe500f00, "wldrd\t%12-15g, %r"},
  {ARM_CEXT_XSCALE, 0xfc100100, 0xfe500f00, "wldrw\t%12-15G, %A"},
  {ARM_CEXT_XSCALE, 0x0c100000, 0x0e100e00, "wldr%L%c\t%12-15g, %l"},
  {ARM_CEXT_XSCALE, 0x0e400100, 0x0fc00ff0, "wmac%21?su%20'z%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e800100, 0x0fc00ff0, "wmadd%21?su%20'x%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ec00100, 0x0fd00ff0, "wmadd%21?sun%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e000160, 0x0f100ff0, "wmax%21?su%22-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e000080, 0x0f100fe0, "wmerge%c\t%12-15g, %16-19g, %0-3g, #%21-23d"},
  {ARM_CEXT_XSCALE, 0x0e0000a0, 0x0f800ff0, "wmia%21?tb%20?tb%22'n%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e800120, 0x0f800ff0, "wmiaw%21?tb%20?tb%22'n%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e100160, 0x0f100ff0, "wmin%21?su%22-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e000100, 0x0fc00ff0, "wmul%21?su%20?ml%23'r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ed00100, 0x0fd00ff0, "wmul%21?sumr%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ee000c0, 0x0fe00ff0, "wmulwsm%20`r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ec000c0, 0x0fe00ff0, "wmulwum%20`r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0eb000c0, 0x0ff00ff0, "wmulwl%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e8000a0, 0x0f800ff0, "wqmia%21?tb%20?tb%22'n%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e100080, 0x0fd00ff0, "wqmulm%21'r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ec000e0, 0x0fd00ff0, "wqmulwm%21'r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e000000, 0x0ff00ff0, "wor%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e000080, 0x0f000ff0, "wpack%20-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0xfe300040, 0xff300ef0, "wror%22-23w\t%12-15g, %16-19g, #%i"},
  {ARM_CEXT_XSCALE, 0x0e300040, 0x0f300ff0, "wror%22-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e300140, 0x0f300ff0, "wror%22-23wg%c\t%12-15g, %16-19g, %0-3G"},
  {ARM_CEXT_XSCALE, 0x0e000120, 0x0fa00ff0, "wsad%22?hb%20'z%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e0001e0, 0x0f000ff0, "wshufh%c\t%12-15g, %16-19g, #%Z"},
  {ARM_CEXT_XSCALE, 0xfe100040, 0xff300ef0, "wsll%22-23w\t%12-15g, %16-19g, #%i"},
  {ARM_CEXT_XSCALE, 0x0e100040, 0x0f300ff0, "wsll%22-23w%8'g%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e100148, 0x0f300ffc, "wsll%22-23w%8'g%c\t%12-15g, %16-19g, %0-3G"},
  {ARM_CEXT_XSCALE, 0xfe000040, 0xff300ef0, "wsra%22-23w\t%12-15g, %16-19g, #%i"},
  {ARM_CEXT_XSCALE, 0x0e000040, 0x0f300ff0, "wsra%22-23w%8'g%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e000148, 0x0f300ffc, "wsra%22-23w%8'g%c\t%12-15g, %16-19g, %0-3G"},
  {ARM_CEXT_XSCALE, 0xfe200040, 0xff300ef0, "wsrl%22-23w\t%12-15g, %16-19g, #%i"},
  {ARM_CEXT_XSCALE, 0x0e200040, 0x0f300ff0, "wsrl%22-23w%8'g%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e200148, 0x0f300ffc, "wsrl%22-23w%8'g%c\t%12-15g, %16-19g, %0-3G"},
  {ARM_CEXT_XSCALE, 0xfc400100, 0xfe500f00, "wstrd\t%12-15g, %r"},
  {ARM_CEXT_XSCALE, 0xfc000100, 0xfe500f00, "wstrw\t%12-15G, %A"},
  {ARM_CEXT_XSCALE, 0x0c000000, 0x0e100e00, "wstr%L%c\t%12-15g, %l"},
  {ARM_CEXT_XSCALE, 0x0e0001a0, 0x0f000ff0, "wsub%20-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ed001c0, 0x0ff00ff0, "wsubaddhx%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e1001c0, 0x0f300ff0, "wabsdiff%22-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e0000c0, 0x0fd00fff, "wunpckeh%21?sub%c\t%12-15g, %16-19g"},
  {ARM_CEXT_XSCALE, 0x0e4000c0, 0x0fd00fff, "wunpckeh%21?suh%c\t%12-15g, %16-19g"},
  {ARM_CEXT_XSCALE, 0x0e8000c0, 0x0fd00fff, "wunpckeh%21?suw%c\t%12-15g, %16-19g"},
  {ARM_CEXT_XSCALE, 0x0e0000e0, 0x0f100fff, "wunpckel%21?su%22-23w%c\t%12-15g, %16-19g"},
  {ARM_CEXT_XSCALE, 0x0e1000c0, 0x0f300ff0, "wunpckih%22-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e1000e0, 0x0f300ff0, "wunpckil%22-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e100000, 0x0ff00ff0, "wxor%c\t%12-15g, %16-19g, %0-3g"},
  { 0, SENTINEL_IWMMXT_END, 0, "" },

  /* Floating point coprocessor (FPA) instructions.  */
  {FPU_FPA_EXT_V1, 0x0e000100, 0x0ff08f10, "adf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e100100, 0x0ff08f10, "muf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e200100, 0x0ff08f10, "suf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e300100, 0x0ff08f10, "rsf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e400100, 0x0ff08f10, "dvf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e500100, 0x0ff08f10, "rdf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e600100, 0x0ff08f10, "pow%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e700100, 0x0ff08f10, "rpw%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e800100, 0x0ff08f10, "rmf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e900100, 0x0ff08f10, "fml%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ea00100, 0x0ff08f10, "fdv%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0eb00100, 0x0ff08f10, "frd%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ec00100, 0x0ff08f10, "pol%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e008100, 0x0ff08f10, "mvf%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e108100, 0x0ff08f10, "mnf%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e208100, 0x0ff08f10, "abs%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e308100, 0x0ff08f10, "rnd%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e408100, 0x0ff08f10, "sqt%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e508100, 0x0ff08f10, "log%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e608100, 0x0ff08f10, "lgn%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e708100, 0x0ff08f10, "exp%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e808100, 0x0ff08f10, "sin%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e908100, 0x0ff08f10, "cos%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ea08100, 0x0ff08f10, "tan%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0eb08100, 0x0ff08f10, "asn%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ec08100, 0x0ff08f10, "acs%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ed08100, 0x0ff08f10, "atn%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ee08100, 0x0ff08f10, "urd%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ef08100, 0x0ff08f10, "nrm%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e000110, 0x0ff00f1f, "flt%c%P%R\t%16-18f, %12-15r"},
  {FPU_FPA_EXT_V1, 0x0e100110, 0x0fff0f98, "fix%c%R\t%12-15r, %0-2f"},
  {FPU_FPA_EXT_V1, 0x0e200110, 0x0fff0fff, "wfs%c\t%12-15r"},
  {FPU_FPA_EXT_V1, 0x0e300110, 0x0fff0fff, "rfs%c\t%12-15r"},
  {FPU_FPA_EXT_V1, 0x0e400110, 0x0fff0fff, "wfc%c\t%12-15r"},
  {FPU_FPA_EXT_V1, 0x0e500110, 0x0fff0fff, "rfc%c\t%12-15r"},
  {FPU_FPA_EXT_V1, 0x0e90f110, 0x0ff8fff0, "cmf%c\t%16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0eb0f110, 0x0ff8fff0, "cnf%c\t%16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ed0f110, 0x0ff8fff0, "cmfe%c\t%16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ef0f110, 0x0ff8fff0, "cnfe%c\t%16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0c000100, 0x0e100f00, "stf%c%Q\t%12-14f, %A"},
  {FPU_FPA_EXT_V1, 0x0c100100, 0x0e100f00, "ldf%c%Q\t%12-14f, %A"},
  {FPU_FPA_EXT_V2, 0x0c000200, 0x0e100f00, "sfm%c\t%12-14f, %F, %A"},
  {FPU_FPA_EXT_V2, 0x0c100200, 0x0e100f00, "lfm%c\t%12-14f, %F, %A"},

  /* Register load/store.  */
  {FPU_VFP_EXT_V1xD | FPU_NEON_EXT_V1, 0x0d2d0b00, 0x0fbf0f01, "vpush%c\t%B"},
  {FPU_VFP_EXT_V1xD | FPU_NEON_EXT_V1, 0x0d200b00, 0x0fb00f01, "vstmdb%c\t%16-19r!, %B"},
  {FPU_VFP_EXT_V1xD | FPU_NEON_EXT_V1, 0x0d300b00, 0x0fb00f01, "vldmdb%c\t%16-19r!, %B"},
  {FPU_VFP_EXT_V1xD | FPU_NEON_EXT_V1, 0x0c800b00, 0x0f900f01, "vstmia%c\t%16-19r%21'!, %B"},
  {FPU_VFP_EXT_V1xD | FPU_NEON_EXT_V1, 0x0cbd0b00, 0x0fbf0f01, "vpop%c\t%B"},
  {FPU_VFP_EXT_V1xD | FPU_NEON_EXT_V1, 0x0c900b00, 0x0f900f01, "vldmia%c\t%16-19r%21'!, %B"},
  {FPU_VFP_EXT_V1xD | FPU_NEON_EXT_V1, 0x0d000b00, 0x0f300f00, "vstr%c\t%12-15,22D, %A"},
  {FPU_VFP_EXT_V1xD | FPU_NEON_EXT_V1, 0x0d100b00, 0x0f300f00, "vldr%c\t%12-15,22D, %A"},
  {FPU_VFP_EXT_V1xD, 0x0d2d0a00, 0x0fbf0f00, "vpush%c\t%y3"},
  {FPU_VFP_EXT_V1xD, 0x0d200a00, 0x0fb00f00, "vstmdb%c\t%16-19r!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0d300a00, 0x0fb00f00, "vldmdb%c\t%16-19r!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0c800a00, 0x0f900f00, "vstmia%c\t%16-19r%21'!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0cbd0a00, 0x0fbf0f00, "vpop%c\t%y3"},
  {FPU_VFP_EXT_V1xD, 0x0c900a00, 0x0f900f00, "vldmia%c\t%16-19r%21'!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0d000a00, 0x0f300f00, "vstr%c\t%y1, %A"},
  {FPU_VFP_EXT_V1xD, 0x0d100a00, 0x0f300f00, "vldr%c\t%y1, %A"},

  {FPU_VFP_EXT_V1xD, 0x0d200b01, 0x0fb00f01, "fstmdbx%c\t%16-19r!, %z3\t;@@ Deprecated"},
  {FPU_VFP_EXT_V1xD, 0x0d300b01, 0x0fb00f01, "fldmdbx%c\t%16-19r!, %z3\t;@@ Deprecated"},
  {FPU_VFP_EXT_V1xD, 0x0c800b01, 0x0f900f01, "fstmiax%c\t%16-19r%21'!, %z3\t;@@ Deprecated"},
  {FPU_VFP_EXT_V1xD, 0x0c900b01, 0x0f900f01, "fldmiax%c\t%16-19r%21'!, %z3\t;@@ Deprecated"},

  /* Data transfer between ARM and NEON registers.  */
  {FPU_NEON_EXT_V1, 0x0e800b10, 0x0ff00f70, "vdup%c.32\t%16-19,7D, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0e800b30, 0x0ff00f70, "vdup%c.16\t%16-19,7D, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0ea00b10, 0x0ff00f70, "vdup%c.32\t%16-19,7Q, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0ea00b30, 0x0ff00f70, "vdup%c.16\t%16-19,7Q, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0ec00b10, 0x0ff00f70, "vdup%c.8\t%16-19,7D, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0ee00b10, 0x0ff00f70, "vdup%c.8\t%16-19,7Q, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0c400b10, 0x0ff00fd0, "vmov%c\t%0-3,5D, %12-15r, %16-19r"},
  {FPU_NEON_EXT_V1, 0x0c500b10, 0x0ff00fd0, "vmov%c\t%12-15r, %16-19r, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0x0e000b10, 0x0fd00f70, "vmov%c.32\t%16-19,7D[%21d], %12-15r"},
  {FPU_NEON_EXT_V1, 0x0e100b10, 0x0f500f70, "vmov%c.32\t%12-15r, %16-19,7D[%21d]"},
  {FPU_NEON_EXT_V1, 0x0e000b30, 0x0fd00f30, "vmov%c.16\t%16-19,7D[%6,21d], %12-15r"},
  {FPU_NEON_EXT_V1, 0x0e100b30, 0x0f500f30, "vmov%c.%23?us16\t%12-15r, %16-19,7D[%6,21d]"},
  {FPU_NEON_EXT_V1, 0x0e400b10, 0x0fd00f10, "vmov%c.8\t%16-19,7D[%5,6,21d], %12-15r"},
  {FPU_NEON_EXT_V1, 0x0e500b10, 0x0f500f10, "vmov%c.%23?us8\t%12-15r, %16-19,7D[%5,6,21d]"},
  /* Half-precision conversion instructions.  */
  {FPU_VFP_EXT_ARMV8, 0x0eb20b40, 0x0fbf0f50, "vcvt%7?tb%c.f64.f16\t%z1, %y0"},
  {FPU_VFP_EXT_ARMV8, 0x0eb30b40, 0x0fbf0f50, "vcvt%7?tb%c.f16.f64\t%y1, %z0"},
  {FPU_VFP_EXT_FP16, 0x0eb20a40, 0x0fbf0f50, "vcvt%7?tb%c.f32.f16\t%y1, %y0"},
  {FPU_VFP_EXT_FP16, 0x0eb30a40, 0x0fbf0f50, "vcvt%7?tb%c.f16.f32\t%y1, %y0"},

  /* Floating point coprocessor (VFP) instructions.  */
  {FPU_VFP_EXT_V1xD, 0x0ee00a10, 0x0fff0fff, "vmsr%c\tfpsid, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee10a10, 0x0fff0fff, "vmsr%c\tfpscr, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee60a10, 0x0fff0fff, "vmsr%c\tmvfr1, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee70a10, 0x0fff0fff, "vmsr%c\tmvfr0, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee80a10, 0x0fff0fff, "vmsr%c\tfpexc, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee90a10, 0x0fff0fff, "vmsr%c\tfpinst, %12-15r\t@@ Impl def"},
  {FPU_VFP_EXT_V1xD, 0x0eea0a10, 0x0fff0fff, "vmsr%c\tfpinst2, %12-15r\t@@ Impl def"},
  {FPU_VFP_EXT_V1xD, 0x0ef00a10, 0x0fff0fff, "vmrs%c\t%12-15r, fpsid"},
  {FPU_VFP_EXT_V1xD, 0x0ef1fa10, 0x0fffffff, "vmrs%c\tAPSR_nzcv, fpscr"},
  {FPU_VFP_EXT_V1xD, 0x0ef10a10, 0x0fff0fff, "vmrs%c\t%12-15r, fpscr"},
  {FPU_VFP_EXT_V1xD, 0x0ef60a10, 0x0fff0fff, "vmrs%c\t%12-15r, mvfr1"},
  {FPU_VFP_EXT_V1xD, 0x0ef70a10, 0x0fff0fff, "vmrs%c\t%12-15r, mvfr0"},
  {FPU_VFP_EXT_V1xD, 0x0ef80a10, 0x0fff0fff, "vmrs%c\t%12-15r, fpexc"},
  {FPU_VFP_EXT_V1xD, 0x0ef90a10, 0x0fff0fff, "vmrs%c\t%12-15r, fpinst\t@@ Impl def"},
  {FPU_VFP_EXT_V1xD, 0x0efa0a10, 0x0fff0fff, "vmrs%c\t%12-15r, fpinst2\t@@ Impl def"},
  {FPU_VFP_EXT_V1, 0x0e000b10, 0x0fd00fff, "vmov%c.32\t%z2[%21d], %12-15r"},
  {FPU_VFP_EXT_V1, 0x0e100b10, 0x0fd00fff, "vmov%c.32\t%12-15r, %z2[%21d]"},
  {FPU_VFP_EXT_V1xD, 0x0ee00a10, 0x0ff00fff, "vmsr%c\t<impl def %16-19x>, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ef00a10, 0x0ff00fff, "vmrs%c\t%12-15r, <impl def %16-19x>"},
  {FPU_VFP_EXT_V1xD, 0x0e000a10, 0x0ff00f7f, "vmov%c\t%y2, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0e100a10, 0x0ff00f7f, "vmov%c\t%12-15r, %y2"},
  {FPU_VFP_EXT_V1xD, 0x0eb50a40, 0x0fbf0f70, "vcmp%7'e%c.f32\t%y1, #0.0"},
  {FPU_VFP_EXT_V1, 0x0eb50b40, 0x0fbf0f70, "vcmp%7'e%c.f64\t%z1, #0.0"},
  {FPU_VFP_EXT_V1xD, 0x0eb00a40, 0x0fbf0fd0, "vmov%c.f32\t%y1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb00ac0, 0x0fbf0fd0, "vabs%c.f32\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb00b40, 0x0fbf0fd0, "vmov%c.f64\t%z1, %z0"},
  {FPU_VFP_EXT_V1, 0x0eb00bc0, 0x0fbf0fd0, "vabs%c.f64\t%z1, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0eb10a40, 0x0fbf0fd0, "vneg%c.f32\t%y1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb10ac0, 0x0fbf0fd0, "vsqrt%c.f32\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb10b40, 0x0fbf0fd0, "vneg%c.f64\t%z1, %z0"},
  {FPU_VFP_EXT_V1, 0x0eb10bc0, 0x0fbf0fd0, "vsqrt%c.f64\t%z1, %z0"},
  {FPU_VFP_EXT_V1, 0x0eb70ac0, 0x0fbf0fd0, "vcvt%c.f64.f32\t%z1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb70bc0, 0x0fbf0fd0, "vcvt%c.f32.f64\t%y1, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0eb80a40, 0x0fbf0f50, "vcvt%c.f32.%7?su32\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb80b40, 0x0fbf0f50, "vcvt%c.f64.%7?su32\t%z1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb40a40, 0x0fbf0f50, "vcmp%7'e%c.f32\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb40b40, 0x0fbf0f50, "vcmp%7'e%c.f64\t%z1, %z0"},
  {FPU_VFP_EXT_V3xD, 0x0eba0a40, 0x0fbe0f50, "vcvt%c.f32.%16?us%7?31%7?26\t%y1, %y1, #%5,0-3k"},
  {FPU_VFP_EXT_V3, 0x0eba0b40, 0x0fbe0f50, "vcvt%c.f64.%16?us%7?31%7?26\t%z1, %z1, #%5,0-3k"},
  {FPU_VFP_EXT_V1xD, 0x0ebc0a40, 0x0fbe0f50, "vcvt%7`r%c.%16?su32.f32\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0ebc0b40, 0x0fbe0f50, "vcvt%7`r%c.%16?su32.f64\t%y1, %z0"},
  {FPU_VFP_EXT_V3xD, 0x0ebe0a40, 0x0fbe0f50, "vcvt%c.%16?us%7?31%7?26.f32\t%y1, %y1, #%5,0-3k"},
  {FPU_VFP_EXT_V3, 0x0ebe0b40, 0x0fbe0f50, "vcvt%c.%16?us%7?31%7?26.f64\t%z1, %z1, #%5,0-3k"},
  {FPU_VFP_EXT_V1, 0x0c500b10, 0x0fb00ff0, "vmov%c\t%12-15r, %16-19r, %z0"},
  {FPU_VFP_EXT_V3xD, 0x0eb00a00, 0x0fb00ff0, "vmov%c.f32\t%y1, #%0-3,16-19d"},
  {FPU_VFP_EXT_V3, 0x0eb00b00, 0x0fb00ff0, "vmov%c.f64\t%z1, #%0-3,16-19d"},
  {FPU_VFP_EXT_V2, 0x0c400a10, 0x0ff00fd0, "vmov%c\t%y4, %12-15r, %16-19r"},
  {FPU_VFP_EXT_V2, 0x0c400b10, 0x0ff00fd0, "vmov%c\t%z0, %12-15r, %16-19r"},
  {FPU_VFP_EXT_V2, 0x0c500a10, 0x0ff00fd0, "vmov%c\t%12-15r, %16-19r, %y4"},
  {FPU_VFP_EXT_V1xD, 0x0e000a00, 0x0fb00f50, "vmla%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e000a40, 0x0fb00f50, "vmls%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e000b00, 0x0fb00f50, "vmla%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e000b40, 0x0fb00f50, "vmls%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e100a00, 0x0fb00f50, "vnmls%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e100a40, 0x0fb00f50, "vnmla%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e100b00, 0x0fb00f50, "vnmls%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e100b40, 0x0fb00f50, "vnmla%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e200a00, 0x0fb00f50, "vmul%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e200a40, 0x0fb00f50, "vnmul%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e200b00, 0x0fb00f50, "vmul%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e200b40, 0x0fb00f50, "vnmul%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e300a00, 0x0fb00f50, "vadd%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e300a40, 0x0fb00f50, "vsub%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e300b00, 0x0fb00f50, "vadd%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e300b40, 0x0fb00f50, "vsub%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e800a00, 0x0fb00f50, "vdiv%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e800b00, 0x0fb00f50, "vdiv%c.f64\t%z1, %z2, %z0"},

  /* Cirrus coprocessor instructions.  */
  {ARM_CEXT_MAVERICK, 0x0d100400, 0x0f500f00, "cfldrs%c\tmvf%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0c100400, 0x0f500f00, "cfldrs%c\tmvf%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0d500400, 0x0f500f00, "cfldrd%c\tmvd%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0c500400, 0x0f500f00, "cfldrd%c\tmvd%12-15d, %A"}, 
  {ARM_CEXT_MAVERICK, 0x0d100500, 0x0f500f00, "cfldr32%c\tmvfx%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0c100500, 0x0f500f00, "cfldr32%c\tmvfx%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0d500500, 0x0f500f00, "cfldr64%c\tmvdx%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0c500500, 0x0f500f00, "cfldr64%c\tmvdx%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0d000400, 0x0f500f00, "cfstrs%c\tmvf%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0c000400, 0x0f500f00, "cfstrs%c\tmvf%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0d400400, 0x0f500f00, "cfstrd%c\tmvd%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0c400400, 0x0f500f00, "cfstrd%c\tmvd%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0d000500, 0x0f500f00, "cfstr32%c\tmvfx%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0c000500, 0x0f500f00, "cfstr32%c\tmvfx%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0d400500, 0x0f500f00, "cfstr64%c\tmvdx%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0c400500, 0x0f500f00, "cfstr64%c\tmvdx%12-15d, %A"},
  {ARM_CEXT_MAVERICK, 0x0e000450, 0x0ff00ff0, "cfmvsr%c\tmvf%16-19d, %12-15r"},
  {ARM_CEXT_MAVERICK, 0x0e100450, 0x0ff00ff0, "cfmvrs%c\t%12-15r, mvf%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e000410, 0x0ff00ff0, "cfmvdlr%c\tmvd%16-19d, %12-15r"},
  {ARM_CEXT_MAVERICK, 0x0e100410, 0x0ff00ff0, "cfmvrdl%c\t%12-15r, mvd%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e000430, 0x0ff00ff0, "cfmvdhr%c\tmvd%16-19d, %12-15r"},
  {ARM_CEXT_MAVERICK, 0x0e100430, 0x0ff00fff, "cfmvrdh%c\t%12-15r, mvd%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e000510, 0x0ff00fff, "cfmv64lr%c\tmvdx%16-19d, %12-15r"},
  {ARM_CEXT_MAVERICK, 0x0e100510, 0x0ff00fff, "cfmvr64l%c\t%12-15r, mvdx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e000530, 0x0ff00fff, "cfmv64hr%c\tmvdx%16-19d, %12-15r"},
  {ARM_CEXT_MAVERICK, 0x0e100530, 0x0ff00fff, "cfmvr64h%c\t%12-15r, mvdx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e200440, 0x0ff00fff, "cfmval32%c\tmvax%12-15d, mvfx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e100440, 0x0ff00fff, "cfmv32al%c\tmvfx%12-15d, mvax%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e200460, 0x0ff00fff, "cfmvam32%c\tmvax%12-15d, mvfx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e100460, 0x0ff00fff, "cfmv32am%c\tmvfx%12-15d, mvax%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e200480, 0x0ff00fff, "cfmvah32%c\tmvax%12-15d, mvfx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e100480, 0x0ff00fff, "cfmv32ah%c\tmvfx%12-15d, mvax%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e2004a0, 0x0ff00fff, "cfmva32%c\tmvax%12-15d, mvfx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e1004a0, 0x0ff00fff, "cfmv32a%c\tmvfx%12-15d, mvax%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e2004c0, 0x0ff00fff, "cfmva64%c\tmvax%12-15d, mvdx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e1004c0, 0x0ff00fff, "cfmv64a%c\tmvdx%12-15d, mvax%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e2004e0, 0x0fff0fff, "cfmvsc32%c\tdspsc, mvdx%12-15d"},
  {ARM_CEXT_MAVERICK, 0x0e1004e0, 0x0fff0fff, "cfmv32sc%c\tmvdx%12-15d, dspsc"},
  {ARM_CEXT_MAVERICK, 0x0e000400, 0x0ff00fff, "cfcpys%c\tmvf%12-15d, mvf%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e000420, 0x0ff00fff, "cfcpyd%c\tmvd%12-15d, mvd%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e000460, 0x0ff00fff, "cfcvtsd%c\tmvd%12-15d, mvf%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e000440, 0x0ff00fff, "cfcvtds%c\tmvf%12-15d, mvd%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e000480, 0x0ff00fff, "cfcvt32s%c\tmvf%12-15d, mvfx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e0004a0, 0x0ff00fff, "cfcvt32d%c\tmvd%12-15d, mvfx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e0004c0, 0x0ff00fff, "cfcvt64s%c\tmvf%12-15d, mvdx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e0004e0, 0x0ff00fff, "cfcvt64d%c\tmvd%12-15d, mvdx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e100580, 0x0ff00fff, "cfcvts32%c\tmvfx%12-15d, mvf%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e1005a0, 0x0ff00fff, "cfcvtd32%c\tmvfx%12-15d, mvd%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e1005c0, 0x0ff00fff, "cftruncs32%c\tmvfx%12-15d, mvf%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e1005e0, 0x0ff00fff, "cftruncd32%c\tmvfx%12-15d, mvd%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e000550, 0x0ff00ff0, "cfrshl32%c\tmvfx%16-19d, mvfx%0-3d, %12-15r"},
  {ARM_CEXT_MAVERICK, 0x0e000570, 0x0ff00ff0, "cfrshl64%c\tmvdx%16-19d, mvdx%0-3d, %12-15r"},
  {ARM_CEXT_MAVERICK, 0x0e000500, 0x0ff00f10, "cfsh32%c\tmvfx%12-15d, mvfx%16-19d, #%I"},
  {ARM_CEXT_MAVERICK, 0x0e200500, 0x0ff00f10, "cfsh64%c\tmvdx%12-15d, mvdx%16-19d, #%I"},
  {ARM_CEXT_MAVERICK, 0x0e100490, 0x0ff00ff0, "cfcmps%c\t%12-15r, mvf%16-19d, mvf%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e1004b0, 0x0ff00ff0, "cfcmpd%c\t%12-15r, mvd%16-19d, mvd%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e100590, 0x0ff00ff0, "cfcmp32%c\t%12-15r, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e1005b0, 0x0ff00ff0, "cfcmp64%c\t%12-15r, mvdx%16-19d, mvdx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e300400, 0x0ff00fff, "cfabss%c\tmvf%12-15d, mvf%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e300420, 0x0ff00fff, "cfabsd%c\tmvd%12-15d, mvd%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e300440, 0x0ff00fff, "cfnegs%c\tmvf%12-15d, mvf%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e300460, 0x0ff00fff, "cfnegd%c\tmvd%12-15d, mvd%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e300480, 0x0ff00ff0, "cfadds%c\tmvf%12-15d, mvf%16-19d, mvf%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e3004a0, 0x0ff00ff0, "cfaddd%c\tmvd%12-15d, mvd%16-19d, mvd%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e3004c0, 0x0ff00ff0, "cfsubs%c\tmvf%12-15d, mvf%16-19d, mvf%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e3004e0, 0x0ff00ff0, "cfsubd%c\tmvd%12-15d, mvd%16-19d, mvd%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e100400, 0x0ff00ff0, "cfmuls%c\tmvf%12-15d, mvf%16-19d, mvf%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e100420, 0x0ff00ff0, "cfmuld%c\tmvd%12-15d, mvd%16-19d, mvd%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e300500, 0x0ff00fff, "cfabs32%c\tmvfx%12-15d, mvfx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e300520, 0x0ff00fff, "cfabs64%c\tmvdx%12-15d, mvdx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e300540, 0x0ff00fff, "cfneg32%c\tmvfx%12-15d, mvfx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e300560, 0x0ff00fff, "cfneg64%c\tmvdx%12-15d, mvdx%16-19d"},
  {ARM_CEXT_MAVERICK, 0x0e300580, 0x0ff00ff0, "cfadd32%c\tmvfx%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e3005a0, 0x0ff00ff0, "cfadd64%c\tmvdx%12-15d, mvdx%16-19d, mvdx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e3005c0, 0x0ff00ff0, "cfsub32%c\tmvfx%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e3005e0, 0x0ff00ff0, "cfsub64%c\tmvdx%12-15d, mvdx%16-19d, mvdx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e100500, 0x0ff00ff0, "cfmul32%c\tmvfx%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e100520, 0x0ff00ff0, "cfmul64%c\tmvdx%12-15d, mvdx%16-19d, mvdx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e100540, 0x0ff00ff0, "cfmac32%c\tmvfx%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e100560, 0x0ff00ff0, "cfmsc32%c\tmvfx%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e000600, 0x0ff00f10, "cfmadd32%c\tmvax%5-7d, mvfx%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e100600, 0x0ff00f10, "cfmsub32%c\tmvax%5-7d, mvfx%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e200600, 0x0ff00f10, "cfmadda32%c\tmvax%5-7d, mvax%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e300600, 0x0ff00f10, "cfmsuba32%c\tmvax%5-7d, mvax%12-15d, mvfx%16-19d, mvfx%0-3d"},

  /* VFP Fused multiply add instructions.  */
  {FPU_VFP_EXT_FMA, 0x0ea00a00, 0x0fb00f50, "vfma%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_FMA, 0x0ea00b00, 0x0fb00f50, "vfma%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_FMA, 0x0ea00a40, 0x0fb00f50, "vfms%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_FMA, 0x0ea00b40, 0x0fb00f50, "vfms%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_FMA, 0x0e900a40, 0x0fb00f50, "vfnma%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_FMA, 0x0e900b40, 0x0fb00f50, "vfnma%c.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_FMA, 0x0e900a00, 0x0fb00f50, "vfnms%c.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_FMA, 0x0e900b00, 0x0fb00f50, "vfnms%c.f64\t%z1, %z2, %z0"},

  /* FP v5.  */
  {FPU_VFP_EXT_ARMV8, 0xfe000a00, 0xff800f00, "vsel%20-21c%u.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfe000b00, 0xff800f00, "vsel%20-21c%u.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_ARMV8, 0xfe800a00, 0xffb00f40, "vmaxnm%u.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfe800b00, 0xffb00f40, "vmaxnm%u.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_ARMV8, 0xfe800a40, 0xffb00f40, "vminnm%u.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfe800b40, 0xffb00f40, "vminnm%u.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_ARMV8, 0xfebc0a40, 0xffbc0f50, "vcvt%16-17?mpna%u.%7?su32.f32\t%y1, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfebc0b40, 0xffbc0f50, "vcvt%16-17?mpna%u.%7?su32.f64\t%y1, %z0"},
  {FPU_VFP_EXT_ARMV8, 0x0eb60a40, 0x0fbe0f50, "vrint%7,16??xzr%c.f32\t%y1, %y0"},
  {FPU_VFP_EXT_ARMV8, 0x0eb60b40, 0x0fbe0f50, "vrint%7,16??xzr%c.f64\t%z1, %z0"},
  {FPU_VFP_EXT_ARMV8, 0xfeb80a40, 0xffbc0f50, "vrint%16-17?mpna%u.f32\t%y1, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfeb80b40, 0xffbc0f50, "vrint%16-17?mpna%u.f64\t%z1, %z0"},

  /* Generic coprocessor instructions.  */
  { 0, SENTINEL_GENERIC_START, 0, "" },
  {ARM_EXT_V5E, 0x0c400000, 0x0ff00000, "mcrr%c\t%8-11d, %4-7d, %12-15R, %16-19r, cr%0-3d"},
  {ARM_EXT_V5E, 0x0c500000, 0x0ff00000, "mrrc%c\t%8-11d, %4-7d, %12-15Ru, %16-19Ru, cr%0-3d"},
  {ARM_EXT_V2, 0x0e000000, 0x0f000010, "cdp%c\t%8-11d, %20-23d, cr%12-15d, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V2, 0x0e10f010, 0x0f10f010, "mrc%c\t%8-11d, %21-23d, APSR_nzcv, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V2, 0x0e100010, 0x0f100010, "mrc%c\t%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V2, 0x0e000010, 0x0f100010, "mcr%c\t%8-11d, %21-23d, %12-15R, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V2, 0x0c000000, 0x0e100000, "stc%22'l%c\t%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V2, 0x0c100000, 0x0e100000, "ldc%22'l%c\t%8-11d, cr%12-15d, %A"},

  /* V6 coprocessor instructions.  */
  {ARM_EXT_V6, 0xfc500000, 0xfff00000, "mrrc2%c\t%8-11d, %4-7d, %12-15Ru, %16-19Ru, cr%0-3d"},
  {ARM_EXT_V6, 0xfc400000, 0xfff00000, "mcrr2%c\t%8-11d, %4-7d, %12-15R, %16-19R, cr%0-3d"},

  /* V5 coprocessor instructions.  */
  {ARM_EXT_V5, 0xfc100000, 0xfe100000, "ldc2%22'l%c\t%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V5, 0xfc000000, 0xfe100000, "stc2%22'l%c\t%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V5, 0xfe000000, 0xff000010, "cdp2%c\t%8-11d, %20-23d, cr%12-15d, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V5, 0xfe000010, 0xff100010, "mcr2%c\t%8-11d, %21-23d, %12-15R, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V5, 0xfe100010, 0xff100010, "mrc2%c\t%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, {%5-7d}"},

  {0, 0, 0, 0}
};

/* Neon opcode table:  This does not encode the top byte -- that is
   checked by the print_insn_neon routine, as it depends on whether we are
   doing thumb32 or arm32 disassembly.  */

/* print_insn_neon recognizes the following format control codes:

   %%			%

   %c			print condition code
   %u			print condition code (unconditional in ARM mode,
                          UNPREDICTABLE if not AL in Thumb)
   %A			print v{st,ld}[1234] operands
   %B			print v{st,ld}[1234] any one operands
   %C			print v{st,ld}[1234] single->all operands
   %D			print scalar
   %E			print vmov, vmvn, vorr, vbic encoded constant
   %F			print vtbl,vtbx register list

   %<bitfield>r		print as an ARM register
   %<bitfield>d		print the bitfield in decimal
   %<bitfield>e         print the 2^N - bitfield in decimal
   %<bitfield>D		print as a NEON D register
   %<bitfield>Q		print as a NEON Q register
   %<bitfield>R		print as a NEON D or Q register
   %<bitfield>Sn	print byte scaled width limited by n
   %<bitfield>Tn	print short scaled width limited by n
   %<bitfield>Un	print long scaled width limited by n
   
   %<bitfield>'c	print specified char iff bitfield is all ones
   %<bitfield>`c	print specified char iff bitfield is all zeroes
   %<bitfield>?ab...    select from array of values in big endian order.  */

static const struct opcode32 neon_opcodes[] =
{
  /* Extract.  */
  {FPU_NEON_EXT_V1, 0xf2b00840, 0xffb00850, "vext%c.8\t%12-15,22R, %16-19,7R, %0-3,5R, #%8-11d"},
  {FPU_NEON_EXT_V1, 0xf2b00000, 0xffb00810, "vext%c.8\t%12-15,22R, %16-19,7R, %0-3,5R, #%8-11d"},

  /* Move data element to all lanes.  */
  {FPU_NEON_EXT_V1, 0xf3b40c00, 0xffb70f90, "vdup%c.32\t%12-15,22R, %0-3,5D[%19d]"},
  {FPU_NEON_EXT_V1, 0xf3b20c00, 0xffb30f90, "vdup%c.16\t%12-15,22R, %0-3,5D[%18-19d]"},
  {FPU_NEON_EXT_V1, 0xf3b10c00, 0xffb10f90, "vdup%c.8\t%12-15,22R, %0-3,5D[%17-19d]"},

  /* Table lookup.  */
  {FPU_NEON_EXT_V1, 0xf3b00800, 0xffb00c50, "vtbl%c.8\t%12-15,22D, %F, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3b00840, 0xffb00c50, "vtbx%c.8\t%12-15,22D, %F, %0-3,5D"},
  
  /* Half-precision conversions.  */
  {FPU_VFP_EXT_FP16, 0xf3b60600, 0xffbf0fd0, "vcvt%c.f16.f32\t%12-15,22D, %0-3,5Q"},
  {FPU_VFP_EXT_FP16, 0xf3b60700, 0xffbf0fd0, "vcvt%c.f32.f16\t%12-15,22Q, %0-3,5D"},

  /* NEON fused multiply add instructions.  */
  {FPU_NEON_EXT_FMA, 0xf2000c10, 0xffa00f10, "vfma%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_FMA, 0xf2200c10, 0xffa00f10, "vfms%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},

  /* Two registers, miscellaneous.  */
  {FPU_NEON_EXT_ARMV8, 0xf3ba0400, 0xffbf0c10, "vrint%7-9?p?m?zaxn%u.f32\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_ARMV8, 0xf3bb0000, 0xffbf0c10, "vcvt%8-9?mpna%u.%7?us32.f32\t%12-15,22R, %0-3,5R"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3b00300, 0xffbf0fd0, "aese%u.8\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3b00340, 0xffbf0fd0, "aesd%u.8\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3b00380, 0xffbf0fd0, "aesmc%u.8\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3b003c0, 0xffbf0fd0, "aesimc%u.8\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3b902c0, 0xffbf0fd0, "sha1h%u.32\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3ba0380, 0xffbf0fd0, "sha1su1%u.32\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3ba03c0, 0xffbf0fd0, "sha256su0%u.32\t%12-15,22Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2880a10, 0xfebf0fd0, "vmovl%c.%24?us8\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2900a10, 0xfebf0fd0, "vmovl%c.%24?us16\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2a00a10, 0xfebf0fd0, "vmovl%c.%24?us32\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3b00500, 0xffbf0f90, "vcnt%c.8\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00580, 0xffbf0f90, "vmvn%c\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20000, 0xffbf0f90, "vswp%c\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20200, 0xffb30fd0, "vmovn%c.i%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20240, 0xffb30fd0, "vqmovun%c.s%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20280, 0xffb30fd0, "vqmovn%c.s%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b202c0, 0xffb30fd0, "vqmovn%c.u%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20300, 0xffb30fd0, "vshll%c.i%18-19S2\t%12-15,22Q, %0-3,5D, #%18-19S2"},
  {FPU_NEON_EXT_V1, 0xf3bb0400, 0xffbf0e90, "vrecpe%c.%8?fu%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3bb0480, 0xffbf0e90, "vrsqrte%c.%8?fu%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00000, 0xffb30f90, "vrev64%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00080, 0xffb30f90, "vrev32%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00100, 0xffb30f90, "vrev16%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00400, 0xffb30f90, "vcls%c.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00480, 0xffb30f90, "vclz%c.i%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00700, 0xffb30f90, "vqabs%c.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00780, 0xffb30f90, "vqneg%c.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20080, 0xffb30f90, "vtrn%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20100, 0xffb30f90, "vuzp%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20180, 0xffb30f90, "vzip%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b10000, 0xffb30b90, "vcgt%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10080, 0xffb30b90, "vcge%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10100, 0xffb30b90, "vceq%c.%10?fi%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10180, 0xffb30b90, "vcle%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10200, 0xffb30b90, "vclt%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10300, 0xffb30b90, "vabs%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b10380, 0xffb30b90, "vneg%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00200, 0xffb30f10, "vpaddl%c.%7?us%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00600, 0xffb30f10, "vpadal%c.%7?us%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b30600, 0xffb30e10, "vcvt%c.%7-8?usff%18-19Sa.%7-8?ffus%18-19Sa\t%12-15,22R, %0-3,5R"},

  /* Three registers of the same length.  */
  {FPU_CRYPTO_EXT_ARMV8, 0xf2000c40, 0xffb00f50, "sha1c%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf2100c40, 0xffb00f50, "sha1p%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf2200c40, 0xffb00f50, "sha1m%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf2300c40, 0xffb00f50, "sha1su0%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3000c40, 0xffb00f50, "sha256h%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3100c40, 0xffb00f50, "sha256h2%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3200c40, 0xffb00f50, "sha256su1%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_ARMV8, 0xf3000f10, 0xffa00f10, "vmaxnm%u.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_ARMV8, 0xf3200f10, 0xffa00f10, "vminnm%u.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000110, 0xffb00f10, "vand%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2100110, 0xffb00f10, "vbic%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200110, 0xffb00f10, "vorr%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2300110, 0xffb00f10, "vorn%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000110, 0xffb00f10, "veor%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3100110, 0xffb00f10, "vbsl%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200110, 0xffb00f10, "vbit%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3300110, 0xffb00f10, "vbif%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000d00, 0xffa00f10, "vadd%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000d10, 0xffa00f10, "vmla%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000e00, 0xffa00f10, "vceq%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000f00, 0xffa00f10, "vmax%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000f10, 0xffa00f10, "vrecps%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200d00, 0xffa00f10, "vsub%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200d10, 0xffa00f10, "vmls%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200f00, 0xffa00f10, "vmin%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200f10, 0xffa00f10, "vrsqrts%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000d00, 0xffa00f10, "vpadd%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000d10, 0xffa00f10, "vmul%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000e00, 0xffa00f10, "vcge%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000e10, 0xffa00f10, "vacge%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000f00, 0xffa00f10, "vpmax%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200d00, 0xffa00f10, "vabd%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200e00, 0xffa00f10, "vcgt%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200e10, 0xffa00f10, "vacgt%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200f00, 0xffa00f10, "vpmin%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000800, 0xff800f10, "vadd%c.i%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000810, 0xff800f10, "vtst%c.%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000900, 0xff800f10, "vmla%c.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000b00, 0xff800f10, "vqdmulh%c.s%20-21S6\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000b10, 0xff800f10, "vpadd%c.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000800, 0xff800f10, "vsub%c.i%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000810, 0xff800f10, "vceq%c.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000900, 0xff800f10, "vmls%c.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000b00, 0xff800f10, "vqrdmulh%c.s%20-21S6\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000000, 0xfe800f10, "vhadd%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000010, 0xfe800f10, "vqadd%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000100, 0xfe800f10, "vrhadd%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000200, 0xfe800f10, "vhsub%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000210, 0xfe800f10, "vqsub%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000300, 0xfe800f10, "vcgt%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000310, 0xfe800f10, "vcge%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000400, 0xfe800f10, "vshl%c.%24?us%20-21S3\t%12-15,22R, %0-3,5R, %16-19,7R"},
  {FPU_NEON_EXT_V1, 0xf2000410, 0xfe800f10, "vqshl%c.%24?us%20-21S3\t%12-15,22R, %0-3,5R, %16-19,7R"},
  {FPU_NEON_EXT_V1, 0xf2000500, 0xfe800f10, "vrshl%c.%24?us%20-21S3\t%12-15,22R, %0-3,5R, %16-19,7R"},
  {FPU_NEON_EXT_V1, 0xf2000510, 0xfe800f10, "vqrshl%c.%24?us%20-21S3\t%12-15,22R, %0-3,5R, %16-19,7R"},
  {FPU_NEON_EXT_V1, 0xf2000600, 0xfe800f10, "vmax%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000610, 0xfe800f10, "vmin%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000700, 0xfe800f10, "vabd%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000710, 0xfe800f10, "vaba%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000910, 0xfe800f10, "vmul%c.%24?pi%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000a00, 0xfe800f10, "vpmax%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000a10, 0xfe800f10, "vpmin%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},

  /* One register and an immediate value.  */
  {FPU_NEON_EXT_V1, 0xf2800e10, 0xfeb80fb0, "vmov%c.i8\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800e30, 0xfeb80fb0, "vmov%c.i64\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800f10, 0xfeb80fb0, "vmov%c.f32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800810, 0xfeb80db0, "vmov%c.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800830, 0xfeb80db0, "vmvn%c.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800910, 0xfeb80db0, "vorr%c.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800930, 0xfeb80db0, "vbic%c.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800c10, 0xfeb80eb0, "vmov%c.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800c30, 0xfeb80eb0, "vmvn%c.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800110, 0xfeb809b0, "vorr%c.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800130, 0xfeb809b0, "vbic%c.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800010, 0xfeb808b0, "vmov%c.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800030, 0xfeb808b0, "vmvn%c.i32\t%12-15,22R, %E"},

  /* Two registers and a shift amount.  */
  {FPU_NEON_EXT_V1, 0xf2880810, 0xffb80fd0, "vshrn%c.i16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880850, 0xffb80fd0, "vrshrn%c.i16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880810, 0xfeb80fd0, "vqshrun%c.s16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880850, 0xfeb80fd0, "vqrshrun%c.s16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880910, 0xfeb80fd0, "vqshrn%c.%24?us16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880950, 0xfeb80fd0, "vqrshrn%c.%24?us16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880a10, 0xfeb80fd0, "vshll%c.%24?us8\t%12-15,22Q, %0-3,5D, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2900810, 0xffb00fd0, "vshrn%c.i32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900850, 0xffb00fd0, "vrshrn%c.i32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2880510, 0xffb80f90, "vshl%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf3880410, 0xffb80f90, "vsri%c.8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf3880510, 0xffb80f90, "vsli%c.8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf3880610, 0xffb80f90, "vqshlu%c.s8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2900810, 0xfeb00fd0, "vqshrun%c.s32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900850, 0xfeb00fd0, "vqrshrun%c.s32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900910, 0xfeb00fd0, "vqshrn%c.%24?us32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900950, 0xfeb00fd0, "vqrshrn%c.%24?us32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900a10, 0xfeb00fd0, "vshll%c.%24?us16\t%12-15,22Q, %0-3,5D, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2880010, 0xfeb80f90, "vshr%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880110, 0xfeb80f90, "vsra%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880210, 0xfeb80f90, "vrshr%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880310, 0xfeb80f90, "vrsra%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880710, 0xfeb80f90, "vqshl%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2a00810, 0xffa00fd0, "vshrn%c.i64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00850, 0xffa00fd0, "vrshrn%c.i64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2900510, 0xffb00f90, "vshl%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf3900410, 0xffb00f90, "vsri%c.16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf3900510, 0xffb00f90, "vsli%c.16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf3900610, 0xffb00f90, "vqshlu%c.s16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2a00a10, 0xfea00fd0, "vshll%c.%24?us32\t%12-15,22Q, %0-3,5D, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2900010, 0xfeb00f90, "vshr%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900110, 0xfeb00f90, "vsra%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900210, 0xfeb00f90, "vrshr%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900310, 0xfeb00f90, "vrsra%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900710, 0xfeb00f90, "vqshl%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2a00810, 0xfea00fd0, "vqshrun%c.s64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00850, 0xfea00fd0, "vqrshrun%c.s64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00910, 0xfea00fd0, "vqshrn%c.%24?us64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00950, 0xfea00fd0, "vqrshrn%c.%24?us64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00510, 0xffa00f90, "vshl%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf3a00410, 0xffa00f90, "vsri%c.32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf3a00510, 0xffa00f90, "vsli%c.32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf3a00610, 0xffa00f90, "vqshlu%c.s32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2a00010, 0xfea00f90, "vshr%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00110, 0xfea00f90, "vsra%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00210, 0xfea00f90, "vrshr%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00310, 0xfea00f90, "vrsra%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00710, 0xfea00f90, "vqshl%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2800590, 0xff800f90, "vshl%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf3800490, 0xff800f90, "vsri%c.64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf3800590, 0xff800f90, "vsli%c.64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf3800690, 0xff800f90, "vqshlu%c.s64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf2800090, 0xfe800f90, "vshr%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800190, 0xfe800f90, "vsra%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800290, 0xfe800f90, "vrshr%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800390, 0xfe800f90, "vrsra%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800790, 0xfe800f90, "vqshl%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf2a00e10, 0xfea00e90, "vcvt%c.%24,8?usff32.%24,8?ffus32\t%12-15,22R, %0-3,5R, #%16-20e"},

  /* Three registers of different lengths.  */
  {FPU_CRYPTO_EXT_ARMV8, 0xf2a00e00, 0xfeb00f50, "vmull%c.p64\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800e00, 0xfea00f50, "vmull%c.p%20S0\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800400, 0xff800f50, "vaddhn%c.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800600, 0xff800f50, "vsubhn%c.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800900, 0xff800f50, "vqdmlal%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800b00, 0xff800f50, "vqdmlsl%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800d00, 0xff800f50, "vqdmull%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3800400, 0xff800f50, "vraddhn%c.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3800600, 0xff800f50, "vrsubhn%c.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800000, 0xfe800f50, "vaddl%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800100, 0xfe800f50, "vaddw%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800200, 0xfe800f50, "vsubl%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800300, 0xfe800f50, "vsubw%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800500, 0xfe800f50, "vabal%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800700, 0xfe800f50, "vabdl%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800800, 0xfe800f50, "vmlal%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800a00, 0xfe800f50, "vmlsl%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800c00, 0xfe800f50, "vmull%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},

  /* Two registers and a scalar.  */
  {FPU_NEON_EXT_V1, 0xf2800040, 0xff800f50, "vmla%c.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800140, 0xff800f50, "vmla%c.f%20-21Sa\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800340, 0xff800f50, "vqdmlal%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800440, 0xff800f50, "vmls%c.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800540, 0xff800f50, "vmls%c.f%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800740, 0xff800f50, "vqdmlsl%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800840, 0xff800f50, "vmul%c.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800940, 0xff800f50, "vmul%c.f%20-21Sa\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800b40, 0xff800f50, "vqdmull%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800c40, 0xff800f50, "vqdmulh%c.s%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800d40, 0xff800f50, "vqrdmulh%c.s%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf3800040, 0xff800f50, "vmla%c.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800140, 0xff800f50, "vmla%c.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800440, 0xff800f50, "vmls%c.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800540, 0xff800f50, "vmls%c.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800840, 0xff800f50, "vmul%c.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800940, 0xff800f50, "vmul%c.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800c40, 0xff800f50, "vqdmulh%c.s%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800d40, 0xff800f50, "vqrdmulh%c.s%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf2800240, 0xfe800f50, "vmlal%c.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800640, 0xfe800f50, "vmlsl%c.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800a40, 0xfe800f50, "vmull%c.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},

  /* Element and structure load/store.  */
  {FPU_NEON_EXT_V1, 0xf4a00fc0, 0xffb00fc0, "vld4%c.32\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00c00, 0xffb00f00, "vld1%c.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00d00, 0xffb00f00, "vld2%c.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00e00, 0xffb00f00, "vld3%c.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00f00, 0xffb00f00, "vld4%c.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4000200, 0xff900f00, "v%21?ls%21?dt1%c.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000300, 0xff900f00, "v%21?ls%21?dt2%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000400, 0xff900f00, "v%21?ls%21?dt3%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000500, 0xff900f00, "v%21?ls%21?dt3%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000600, 0xff900f00, "v%21?ls%21?dt1%c.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000700, 0xff900f00, "v%21?ls%21?dt1%c.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000800, 0xff900f00, "v%21?ls%21?dt2%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000900, 0xff900f00, "v%21?ls%21?dt2%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000a00, 0xff900f00, "v%21?ls%21?dt1%c.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000000, 0xff900e00, "v%21?ls%21?dt4%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4800000, 0xff900300, "v%21?ls%21?dt1%c.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800100, 0xff900300, "v%21?ls%21?dt2%c.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800200, 0xff900300, "v%21?ls%21?dt3%c.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800300, 0xff900300, "v%21?ls%21?dt4%c.%10-11S2\t%B"},

  {0,0 ,0, 0}
};

/* Opcode tables: ARM, 16-bit Thumb, 32-bit Thumb.  All three are partially
   ordered: they must be searched linearly from the top to obtain a correct
   match.  */

/* print_insn_arm recognizes the following format control codes:

   %%			%

   %a			print address for ldr/str instruction
   %s                   print address for ldr/str halfword/signextend instruction
   %S                   like %s but allow UNPREDICTABLE addressing
   %b			print branch destination
   %c			print condition code (always bits 28-31)
   %m			print register mask for ldm/stm instruction
   %o			print operand2 (immediate or register + shift)
   %p			print 'p' iff bits 12-15 are 15
   %t			print 't' iff bit 21 set and bit 24 clear
   %B			print arm BLX(1) destination
   %C			print the PSR sub type.
   %U			print barrier type.
   %P			print address for pli instruction.

   %<bitfield>r		print as an ARM register
   %<bitfield>T		print as an ARM register + 1
   %<bitfield>R		as %r but r15 is UNPREDICTABLE
   %<bitfield>{r|R}u    as %{r|R} but if matches the other %u field then is UNPREDICTABLE
   %<bitfield>{r|R}U    as %{r|R} but if matches the other %U field then is UNPREDICTABLE
   %<bitfield>d		print the bitfield in decimal
   %<bitfield>W         print the bitfield plus one in decimal 
   %<bitfield>x		print the bitfield in hex
   %<bitfield>X		print the bitfield as 1 hex digit without leading "0x"
   
   %<bitfield>'c	print specified char iff bitfield is all ones
   %<bitfield>`c	print specified char iff bitfield is all zeroes
   %<bitfield>?ab...    select from array of values in big endian order

   %e                   print arm SMI operand (bits 0..7,8..19).
   %E			print the LSB and WIDTH fields of a BFI or BFC instruction.
   %V                   print the 16-bit immediate field of a MOVT or MOVW instruction.
   %R			print the SPSR/CPSR or banked register of an MRS.  */

static const struct opcode32 arm_opcodes[] =
{
  /* ARM instructions.  */
  {ARM_EXT_V1, 0xe1a00000, 0xffffffff, "nop\t\t\t; (mov r0, r0)"},
  {ARM_EXT_V1, 0xe7f000f0, 0xfff000f0, "udf\t#%e"},

  {ARM_EXT_V4T | ARM_EXT_V5, 0x012FFF10, 0x0ffffff0, "bx%c\t%0-3r"},
  {ARM_EXT_V2, 0x00000090, 0x0fe000f0, "mul%20's%c\t%16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V2, 0x00200090, 0x0fe000f0, "mla%20's%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V2S, 0x01000090, 0x0fb00ff0, "swp%22'b%c\t%12-15RU, %0-3Ru, [%16-19RuU]"},
  {ARM_EXT_V3M, 0x00800090, 0x0fa000f0, "%22?sumull%20's%c\t%12-15Ru, %16-19Ru, %0-3R, %8-11R"},
  {ARM_EXT_V3M, 0x00a00090, 0x0fa000f0, "%22?sumlal%20's%c\t%12-15Ru, %16-19Ru, %0-3R, %8-11R"},

  /* V8 instructions.  */
  {ARM_EXT_V8,   0x0320f005, 0x0fffffff, "sevl"},
  {ARM_EXT_V8,   0xe1000070, 0xfff000f0, "hlt\t0x%16-19X%12-15X%8-11X%0-3X"},
  {ARM_EXT_V8,	 0x01800e90, 0x0ff00ff0, "stlex%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01900e9f, 0x0ff00fff, "ldaex%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01a00e90, 0x0ff00ff0, "stlexd%c\t%12-15r, %0-3r, %0-3T, [%16-19R]"},
  {ARM_EXT_V8,	 0x01b00e9f, 0x0ff00fff, "ldaexd%c\t%12-15r, %12-15T, [%16-19R]"},
  {ARM_EXT_V8,	 0x01c00e90, 0x0ff00ff0, "stlexb%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01d00e9f, 0x0ff00fff, "ldaexb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01e00e90, 0x0ff00ff0, "stlexh%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01f00e9f, 0x0ff00fff, "ldaexh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x0180fc90, 0x0ff0fff0, "stl%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01900c9f, 0x0ff00fff, "lda%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01c0fc90, 0x0ff0fff0, "stlb%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01d00c9f, 0x0ff00fff, "ldab%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01e0fc90, 0x0ff0fff0, "stlh%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01f00c9f, 0x0ff00fff, "ldaexh%c\t%12-15r, [%16-19R]"},
  /* CRC32 instructions.  */
  {CRC_EXT_ARMV8, 0xe1000040, 0xfff00ff0, "crc32b\t%12-15R, %16-19R, %0-3R"},
  {CRC_EXT_ARMV8, 0xe1200040, 0xfff00ff0, "crc32h\t%12-15R, %16-19R, %0-3R"},
  {CRC_EXT_ARMV8, 0xe1400040, 0xfff00ff0, "crc32w\t%12-15R, %16-19R, %0-3R"},
  {CRC_EXT_ARMV8, 0xe1000240, 0xfff00ff0, "crc32cb\t%12-15R, %16-19R, %0-3R"},
  {CRC_EXT_ARMV8, 0xe1200240, 0xfff00ff0, "crc32ch\t%12-15R, %16-19R, %0-3R"},
  {CRC_EXT_ARMV8, 0xe1400240, 0xfff00ff0, "crc32cw\t%12-15R, %16-19R, %0-3R"},

  /* Virtualization Extension instructions.  */
  {ARM_EXT_VIRT, 0x0160006e, 0x0fffffff, "eret%c"},
  {ARM_EXT_VIRT, 0x01400070, 0x0ff000f0, "hvc%c\t%e"},

  /* Integer Divide Extension instructions.  */
  {ARM_EXT_ADIV, 0x0710f010, 0x0ff0f0f0, "sdiv%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_ADIV, 0x0730f010, 0x0ff0f0f0, "udiv%c\t%16-19r, %0-3r, %8-11r"},

  /* MP Extension instructions.  */
  {ARM_EXT_MP, 0xf410f000, 0xfc70f000, "pldw\t%a"},

  /* V7 instructions.  */
  {ARM_EXT_V7, 0xf450f000, 0xfd70f000, "pli\t%P"},
  {ARM_EXT_V7, 0x0320f0f0, 0x0ffffff0, "dbg%c\t#%0-3d"},
  {ARM_EXT_V8, 0xf57ff051, 0xfffffff3, "dmb\t%U"},
  {ARM_EXT_V8, 0xf57ff041, 0xfffffff3, "dsb\t%U"},
  {ARM_EXT_V7, 0xf57ff050, 0xfffffff0, "dmb\t%U"},
  {ARM_EXT_V7, 0xf57ff040, 0xfffffff0, "dsb\t%U"},
  {ARM_EXT_V7, 0xf57ff060, 0xfffffff0, "isb\t%U"},

  /* ARM V6T2 instructions.  */
  {ARM_EXT_V6T2, 0x07c0001f, 0x0fe0007f, "bfc%c\t%12-15R, %E"},
  {ARM_EXT_V6T2, 0x07c00010, 0x0fe00070, "bfi%c\t%12-15R, %0-3r, %E"},
  {ARM_EXT_V6T2, 0x00600090, 0x0ff000f0, "mls%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V6T2, 0x002000b0, 0x0f3000f0, "strht%c\t%12-15R, %S"},

  {ARM_EXT_V6T2, 0x00300090, 0x0f3000f0, UNDEFINED_INSTRUCTION },
  {ARM_EXT_V6T2, 0x00300090, 0x0f300090, "ldr%6's%5?hbt%c\t%12-15R, %S"},
  
  {ARM_EXT_V6T2, 0x03000000, 0x0ff00000, "movw%c\t%12-15R, %V"},
  {ARM_EXT_V6T2, 0x03400000, 0x0ff00000, "movt%c\t%12-15R, %V"},
  {ARM_EXT_V6T2, 0x06ff0f30, 0x0fff0ff0, "rbit%c\t%12-15R, %0-3R"},
  {ARM_EXT_V6T2, 0x07a00050, 0x0fa00070, "%22?usbfx%c\t%12-15r, %0-3r, #%7-11d, #%16-20W"},

  /* ARM Security extension instructions.  */
  {ARM_EXT_SEC, 0x01600070, 0x0ff000f0, "smc%c\t%e"},

  /* ARM V6K instructions.  */
  {ARM_EXT_V6K, 0xf57ff01f, 0xffffffff, "clrex"},
  {ARM_EXT_V6K, 0x01d00f9f, 0x0ff00fff, "ldrexb%c\t%12-15R, [%16-19R]"},
  {ARM_EXT_V6K, 0x01b00f9f, 0x0ff00fff, "ldrexd%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V6K, 0x01f00f9f, 0x0ff00fff, "ldrexh%c\t%12-15R, [%16-19R]"},
  {ARM_EXT_V6K, 0x01c00f90, 0x0ff00ff0, "strexb%c\t%12-15R, %0-3R, [%16-19R]"},
  {ARM_EXT_V6K, 0x01a00f90, 0x0ff00ff0, "strexd%c\t%12-15R, %0-3r, [%16-19R]"},
  {ARM_EXT_V6K, 0x01e00f90, 0x0ff00ff0, "strexh%c\t%12-15R, %0-3R, [%16-19R]"},

  /* ARM V6K NOP hints.  */
  {ARM_EXT_V6K, 0x0320f001, 0x0fffffff, "yield%c"},
  {ARM_EXT_V6K, 0x0320f002, 0x0fffffff, "wfe%c"},
  {ARM_EXT_V6K, 0x0320f003, 0x0fffffff, "wfi%c"},
  {ARM_EXT_V6K, 0x0320f004, 0x0fffffff, "sev%c"},
  {ARM_EXT_V6K, 0x0320f000, 0x0fffff00, "nop%c\t{%0-7d}"},

  /* ARM V6 instructions.  */
  {ARM_EXT_V6, 0xf1080000, 0xfffffe3f, "cpsie\t%8'a%7'i%6'f"},
  {ARM_EXT_V6, 0xf10a0000, 0xfffffe20, "cpsie\t%8'a%7'i%6'f,#%0-4d"},
  {ARM_EXT_V6, 0xf10C0000, 0xfffffe3f, "cpsid\t%8'a%7'i%6'f"},
  {ARM_EXT_V6, 0xf10e0000, 0xfffffe20, "cpsid\t%8'a%7'i%6'f,#%0-4d"},
  {ARM_EXT_V6, 0xf1000000, 0xfff1fe20, "cps\t#%0-4d"},
  {ARM_EXT_V6, 0x06800010, 0x0ff00ff0, "pkhbt%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06800010, 0x0ff00070, "pkhbt%c\t%12-15R, %16-19R, %0-3R, lsl #%7-11d"},
  {ARM_EXT_V6, 0x06800050, 0x0ff00ff0, "pkhtb%c\t%12-15R, %16-19R, %0-3R, asr #32"},
  {ARM_EXT_V6, 0x06800050, 0x0ff00070, "pkhtb%c\t%12-15R, %16-19R, %0-3R, asr #%7-11d"},
  {ARM_EXT_V6, 0x01900f9f, 0x0ff00fff, "ldrex%c\tr%12-15d, [%16-19R]"},
  {ARM_EXT_V6, 0x06200f10, 0x0ff00ff0, "qadd16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06200f90, 0x0ff00ff0, "qadd8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06200f30, 0x0ff00ff0, "qasx%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06200f70, 0x0ff00ff0, "qsub16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06200ff0, 0x0ff00ff0, "qsub8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06200f50, 0x0ff00ff0, "qsax%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06100f10, 0x0ff00ff0, "sadd16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06100f90, 0x0ff00ff0, "sadd8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06100f30, 0x0ff00ff0, "sasx%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06300f10, 0x0ff00ff0, "shadd16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06300f90, 0x0ff00ff0, "shadd8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06300f30, 0x0ff00ff0, "shasx%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06300f70, 0x0ff00ff0, "shsub16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06300ff0, 0x0ff00ff0, "shsub8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06300f50, 0x0ff00ff0, "shsax%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06100f70, 0x0ff00ff0, "ssub16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06100ff0, 0x0ff00ff0, "ssub8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06100f50, 0x0ff00ff0, "ssax%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06500f10, 0x0ff00ff0, "uadd16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06500f90, 0x0ff00ff0, "uadd8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06500f30, 0x0ff00ff0, "uasx%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06700f10, 0x0ff00ff0, "uhadd16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06700f90, 0x0ff00ff0, "uhadd8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06700f30, 0x0ff00ff0, "uhasx%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06700f70, 0x0ff00ff0, "uhsub16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06700ff0, 0x0ff00ff0, "uhsub8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06700f50, 0x0ff00ff0, "uhsax%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06600f10, 0x0ff00ff0, "uqadd16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06600f90, 0x0ff00ff0, "uqadd8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06600f30, 0x0ff00ff0, "uqasx%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06600f70, 0x0ff00ff0, "uqsub16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06600ff0, 0x0ff00ff0, "uqsub8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06600f50, 0x0ff00ff0, "uqsax%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06500f70, 0x0ff00ff0, "usub16%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06500ff0, 0x0ff00ff0, "usub8%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06500f50, 0x0ff00ff0, "usax%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0x06bf0f30, 0x0fff0ff0, "rev%c\t%12-15R, %0-3R"},
  {ARM_EXT_V6, 0x06bf0fb0, 0x0fff0ff0, "rev16%c\t%12-15R, %0-3R"},
  {ARM_EXT_V6, 0x06ff0fb0, 0x0fff0ff0, "revsh%c\t%12-15R, %0-3R"},
  {ARM_EXT_V6, 0xf8100a00, 0xfe50ffff, "rfe%23?id%24?ba\t%16-19r%21'!"},
  {ARM_EXT_V6, 0x06bf0070, 0x0fff0ff0, "sxth%c\t%12-15R, %0-3R"},
  {ARM_EXT_V6, 0x06bf0470, 0x0fff0ff0, "sxth%c\t%12-15R, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06bf0870, 0x0fff0ff0, "sxth%c\t%12-15R, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06bf0c70, 0x0fff0ff0, "sxth%c\t%12-15R, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x068f0070, 0x0fff0ff0, "sxtb16%c\t%12-15R, %0-3R"},
  {ARM_EXT_V6, 0x068f0470, 0x0fff0ff0, "sxtb16%c\t%12-15R, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x068f0870, 0x0fff0ff0, "sxtb16%c\t%12-15R, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x068f0c70, 0x0fff0ff0, "sxtb16%c\t%12-15R, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x06af0070, 0x0fff0ff0, "sxtb%c\t%12-15R, %0-3R"},
  {ARM_EXT_V6, 0x06af0470, 0x0fff0ff0, "sxtb%c\t%12-15R, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06af0870, 0x0fff0ff0, "sxtb%c\t%12-15R, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06af0c70, 0x0fff0ff0, "sxtb%c\t%12-15R, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x06ff0070, 0x0fff0ff0, "uxth%c\t%12-15R, %0-3R"},
  {ARM_EXT_V6, 0x06ff0470, 0x0fff0ff0, "uxth%c\t%12-15R, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06ff0870, 0x0fff0ff0, "uxth%c\t%12-15R, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06ff0c70, 0x0fff0ff0, "uxth%c\t%12-15R, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x06cf0070, 0x0fff0ff0, "uxtb16%c\t%12-15R, %0-3R"},
  {ARM_EXT_V6, 0x06cf0470, 0x0fff0ff0, "uxtb16%c\t%12-15R, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06cf0870, 0x0fff0ff0, "uxtb16%c\t%12-15R, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06cf0c70, 0x0fff0ff0, "uxtb16%c\t%12-15R, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x06ef0070, 0x0fff0ff0, "uxtb%c\t%12-15R, %0-3R"},
  {ARM_EXT_V6, 0x06ef0470, 0x0fff0ff0, "uxtb%c\t%12-15R, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06ef0870, 0x0fff0ff0, "uxtb%c\t%12-15R, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06ef0c70, 0x0fff0ff0, "uxtb%c\t%12-15R, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x06b00070, 0x0ff00ff0, "sxtah%c\t%12-15R, %16-19r, %0-3R"},
  {ARM_EXT_V6, 0x06b00470, 0x0ff00ff0, "sxtah%c\t%12-15R, %16-19r, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06b00870, 0x0ff00ff0, "sxtah%c\t%12-15R, %16-19r, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06b00c70, 0x0ff00ff0, "sxtah%c\t%12-15R, %16-19r, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x06800070, 0x0ff00ff0, "sxtab16%c\t%12-15R, %16-19r, %0-3R"},
  {ARM_EXT_V6, 0x06800470, 0x0ff00ff0, "sxtab16%c\t%12-15R, %16-19r, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06800870, 0x0ff00ff0, "sxtab16%c\t%12-15R, %16-19r, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06800c70, 0x0ff00ff0, "sxtab16%c\t%12-15R, %16-19r, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x06a00070, 0x0ff00ff0, "sxtab%c\t%12-15R, %16-19r, %0-3R"},
  {ARM_EXT_V6, 0x06a00470, 0x0ff00ff0, "sxtab%c\t%12-15R, %16-19r, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06a00870, 0x0ff00ff0, "sxtab%c\t%12-15R, %16-19r, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06a00c70, 0x0ff00ff0, "sxtab%c\t%12-15R, %16-19r, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x06f00070, 0x0ff00ff0, "uxtah%c\t%12-15R, %16-19r, %0-3R"},
  {ARM_EXT_V6, 0x06f00470, 0x0ff00ff0, "uxtah%c\t%12-15R, %16-19r, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06f00870, 0x0ff00ff0, "uxtah%c\t%12-15R, %16-19r, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06f00c70, 0x0ff00ff0, "uxtah%c\t%12-15R, %16-19r, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x06c00070, 0x0ff00ff0, "uxtab16%c\t%12-15R, %16-19r, %0-3R"},
  {ARM_EXT_V6, 0x06c00470, 0x0ff00ff0, "uxtab16%c\t%12-15R, %16-19r, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06c00870, 0x0ff00ff0, "uxtab16%c\t%12-15R, %16-19r, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06c00c70, 0x0ff00ff0, "uxtab16%c\t%12-15R, %16-19r, %0-3R, ROR #24"},
  {ARM_EXT_V6, 0x06e00070, 0x0ff00ff0, "uxtab%c\t%12-15R, %16-19r, %0-3R"},
  {ARM_EXT_V6, 0x06e00470, 0x0ff00ff0, "uxtab%c\t%12-15R, %16-19r, %0-3R, ror #8"},
  {ARM_EXT_V6, 0x06e00870, 0x0ff00ff0, "uxtab%c\t%12-15R, %16-19r, %0-3R, ror #16"},
  {ARM_EXT_V6, 0x06e00c70, 0x0ff00ff0, "uxtab%c\t%12-15R, %16-19r, %0-3R, ror #24"},
  {ARM_EXT_V6, 0x06800fb0, 0x0ff00ff0, "sel%c\t%12-15R, %16-19R, %0-3R"},
  {ARM_EXT_V6, 0xf1010000, 0xfffffc00, "setend\t%9?ble"},
  {ARM_EXT_V6, 0x0700f010, 0x0ff0f0d0, "smuad%5'x%c\t%16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V6, 0x0700f050, 0x0ff0f0d0, "smusd%5'x%c\t%16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V6, 0x07000010, 0x0ff000d0, "smlad%5'x%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V6, 0x07400010, 0x0ff000d0, "smlald%5'x%c\t%12-15Ru, %16-19Ru, %0-3R, %8-11R"},
  {ARM_EXT_V6, 0x07000050, 0x0ff000d0, "smlsd%5'x%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V6, 0x07400050, 0x0ff000d0, "smlsld%5'x%c\t%12-15Ru, %16-19Ru, %0-3R, %8-11R"},
  {ARM_EXT_V6, 0x0750f010, 0x0ff0f0d0, "smmul%5'r%c\t%16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V6, 0x07500010, 0x0ff000d0, "smmla%5'r%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V6, 0x075000d0, 0x0ff000d0, "smmls%5'r%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V6, 0xf84d0500, 0xfe5fffe0, "srs%23?id%24?ba\t%16-19r%21'!, #%0-4d"},
  {ARM_EXT_V6, 0x06a00010, 0x0fe00ff0, "ssat%c\t%12-15R, #%16-20W, %0-3R"},
  {ARM_EXT_V6, 0x06a00010, 0x0fe00070, "ssat%c\t%12-15R, #%16-20W, %0-3R, lsl #%7-11d"},
  {ARM_EXT_V6, 0x06a00050, 0x0fe00070, "ssat%c\t%12-15R, #%16-20W, %0-3R, asr #%7-11d"},
  {ARM_EXT_V6, 0x06a00f30, 0x0ff00ff0, "ssat16%c\t%12-15r, #%16-19W, %0-3r"},
  {ARM_EXT_V6, 0x01800f90, 0x0ff00ff0, "strex%c\t%12-15R, %0-3R, [%16-19R]"},
  {ARM_EXT_V6, 0x00400090, 0x0ff000f0, "umaal%c\t%12-15R, %16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V6, 0x0780f010, 0x0ff0f0f0, "usad8%c\t%16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V6, 0x07800010, 0x0ff000f0, "usada8%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V6, 0x06e00010, 0x0fe00ff0, "usat%c\t%12-15R, #%16-20d, %0-3R"},
  {ARM_EXT_V6, 0x06e00010, 0x0fe00070, "usat%c\t%12-15R, #%16-20d, %0-3R, lsl #%7-11d"},
  {ARM_EXT_V6, 0x06e00050, 0x0fe00070, "usat%c\t%12-15R, #%16-20d, %0-3R, asr #%7-11d"},
  {ARM_EXT_V6, 0x06e00f30, 0x0ff00ff0, "usat16%c\t%12-15R, #%16-19d, %0-3R"},

  /* V5J instruction.  */
  {ARM_EXT_V5J, 0x012fff20, 0x0ffffff0, "bxj%c\t%0-3R"},

  /* V5 Instructions.  */
  {ARM_EXT_V5, 0xe1200070, 0xfff000f0, "bkpt\t0x%16-19X%12-15X%8-11X%0-3X"},
  {ARM_EXT_V5, 0xfa000000, 0xfe000000, "blx\t%B"},
  {ARM_EXT_V5, 0x012fff30, 0x0ffffff0, "blx%c\t%0-3R"},
  {ARM_EXT_V5, 0x016f0f10, 0x0fff0ff0, "clz%c\t%12-15R, %0-3R"},

  /* V5E "El Segundo" Instructions.  */    
  {ARM_EXT_V5E, 0x000000d0, 0x0e1000f0, "ldrd%c\t%12-15r, %s"},
  {ARM_EXT_V5E, 0x000000f0, 0x0e1000f0, "strd%c\t%12-15r, %s"},
  {ARM_EXT_V5E, 0xf450f000, 0xfc70f000, "pld\t%a"},
  {ARM_EXT_V5ExP, 0x01000080, 0x0ff000f0, "smlabb%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V5ExP, 0x010000a0, 0x0ff000f0, "smlatb%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V5ExP, 0x010000c0, 0x0ff000f0, "smlabt%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V5ExP, 0x010000e0, 0x0ff000f0, "smlatt%c\t%16-19r, %0-3r, %8-11R, %12-15R"},

  {ARM_EXT_V5ExP, 0x01200080, 0x0ff000f0, "smlawb%c\t%16-19R, %0-3R, %8-11R, %12-15R"},
  {ARM_EXT_V5ExP, 0x012000c0, 0x0ff000f0, "smlawt%c\t%16-19R, %0-3r, %8-11R, %12-15R"},

  {ARM_EXT_V5ExP, 0x01400080, 0x0ff000f0, "smlalbb%c\t%12-15Ru, %16-19Ru, %0-3R, %8-11R"},
  {ARM_EXT_V5ExP, 0x014000a0, 0x0ff000f0, "smlaltb%c\t%12-15Ru, %16-19Ru, %0-3R, %8-11R"},
  {ARM_EXT_V5ExP, 0x014000c0, 0x0ff000f0, "smlalbt%c\t%12-15Ru, %16-19Ru, %0-3R, %8-11R"},
  {ARM_EXT_V5ExP, 0x014000e0, 0x0ff000f0, "smlaltt%c\t%12-15Ru, %16-19Ru, %0-3R, %8-11R"},

  {ARM_EXT_V5ExP, 0x01600080, 0x0ff0f0f0, "smulbb%c\t%16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V5ExP, 0x016000a0, 0x0ff0f0f0, "smultb%c\t%16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V5ExP, 0x016000c0, 0x0ff0f0f0, "smulbt%c\t%16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V5ExP, 0x016000e0, 0x0ff0f0f0, "smultt%c\t%16-19R, %0-3R, %8-11R"},

  {ARM_EXT_V5ExP, 0x012000a0, 0x0ff0f0f0, "smulwb%c\t%16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V5ExP, 0x012000e0, 0x0ff0f0f0, "smulwt%c\t%16-19R, %0-3R, %8-11R"},

  {ARM_EXT_V5ExP, 0x01000050, 0x0ff00ff0,  "qadd%c\t%12-15R, %0-3R, %16-19R"},
  {ARM_EXT_V5ExP, 0x01400050, 0x0ff00ff0, "qdadd%c\t%12-15R, %0-3R, %16-19R"},
  {ARM_EXT_V5ExP, 0x01200050, 0x0ff00ff0,  "qsub%c\t%12-15R, %0-3R, %16-19R"},
  {ARM_EXT_V5ExP, 0x01600050, 0x0ff00ff0, "qdsub%c\t%12-15R, %0-3R, %16-19R"},

  /* ARM Instructions.  */
  {ARM_EXT_V1, 0x052d0004, 0x0fff0fff, "push%c\t{%12-15r}\t\t; (str%c %12-15r, %a)"},
  
  {ARM_EXT_V1, 0x04400000, 0x0e500000, "strb%t%c\t%12-15R, %a"},
  {ARM_EXT_V1, 0x04000000, 0x0e500000, "str%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x06400000, 0x0e500ff0, "strb%t%c\t%12-15R, %a"},
  {ARM_EXT_V1, 0x06000000, 0x0e500ff0, "str%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x04400000, 0x0c500010, "strb%t%c\t%12-15R, %a"},
  {ARM_EXT_V1, 0x04000000, 0x0c500010, "str%t%c\t%12-15r, %a"},
  
  {ARM_EXT_V1, 0x04400000, 0x0e500000, "strb%c\t%12-15R, %a"},
  {ARM_EXT_V1, 0x06400000, 0x0e500010, "strb%c\t%12-15R, %a"},
  {ARM_EXT_V1, 0x004000b0, 0x0e5000f0, "strh%c\t%12-15R, %s"},
  {ARM_EXT_V1, 0x000000b0, 0x0e500ff0, "strh%c\t%12-15R, %s"},

  {ARM_EXT_V1, 0x00500090, 0x0e5000f0, UNDEFINED_INSTRUCTION},
  {ARM_EXT_V1, 0x00500090, 0x0e500090, "ldr%6's%5?hb%c\t%12-15R, %s"},
  {ARM_EXT_V1, 0x00100090, 0x0e500ff0, UNDEFINED_INSTRUCTION},
  {ARM_EXT_V1, 0x00100090, 0x0e500f90, "ldr%6's%5?hb%c\t%12-15R, %s"},

  {ARM_EXT_V1, 0x02000000, 0x0fe00000, "and%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00000000, 0x0fe00010, "and%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00000010, 0x0fe00090, "and%20's%c\t%12-15R, %16-19R, %o"},

  {ARM_EXT_V1, 0x02200000, 0x0fe00000, "eor%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00200000, 0x0fe00010, "eor%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00200010, 0x0fe00090, "eor%20's%c\t%12-15R, %16-19R, %o"},

  {ARM_EXT_V1, 0x02400000, 0x0fe00000, "sub%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00400000, 0x0fe00010, "sub%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00400010, 0x0fe00090, "sub%20's%c\t%12-15R, %16-19R, %o"},

  {ARM_EXT_V1, 0x02600000, 0x0fe00000, "rsb%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00600000, 0x0fe00010, "rsb%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00600010, 0x0fe00090, "rsb%20's%c\t%12-15R, %16-19R, %o"},

  {ARM_EXT_V1, 0x02800000, 0x0fe00000, "add%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00800000, 0x0fe00010, "add%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00800010, 0x0fe00090, "add%20's%c\t%12-15R, %16-19R, %o"},

  {ARM_EXT_V1, 0x02a00000, 0x0fe00000, "adc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00a00000, 0x0fe00010, "adc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00a00010, 0x0fe00090, "adc%20's%c\t%12-15R, %16-19R, %o"},

  {ARM_EXT_V1, 0x02c00000, 0x0fe00000, "sbc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00c00000, 0x0fe00010, "sbc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00c00010, 0x0fe00090, "sbc%20's%c\t%12-15R, %16-19R, %o"},

  {ARM_EXT_V1, 0x02e00000, 0x0fe00000, "rsc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00e00000, 0x0fe00010, "rsc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00e00010, 0x0fe00090, "rsc%20's%c\t%12-15R, %16-19R, %o"},

  {ARM_EXT_VIRT, 0x0120f200, 0x0fb0f200, "msr%c\t%C, %0-3r"},
  {ARM_EXT_V3, 0x0120f000, 0x0db0f000, "msr%c\t%C, %o"},
  {ARM_EXT_V3, 0x01000000, 0x0fb00cff, "mrs%c\t%12-15R, %R"},

  {ARM_EXT_V1, 0x03000000, 0x0fe00000, "tst%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01000000, 0x0fe00010, "tst%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01000010, 0x0fe00090, "tst%p%c\t%16-19R, %o"},

  {ARM_EXT_V1, 0x03200000, 0x0fe00000, "teq%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01200000, 0x0fe00010, "teq%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01200010, 0x0fe00090, "teq%p%c\t%16-19R, %o"},

  {ARM_EXT_V1, 0x03400000, 0x0fe00000, "cmp%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01400000, 0x0fe00010, "cmp%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01400010, 0x0fe00090, "cmp%p%c\t%16-19R, %o"},

  {ARM_EXT_V1, 0x03600000, 0x0fe00000, "cmn%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01600000, 0x0fe00010, "cmn%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01600010, 0x0fe00090, "cmn%p%c\t%16-19R, %o"},

  {ARM_EXT_V1, 0x03800000, 0x0fe00000, "orr%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x01800000, 0x0fe00010, "orr%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x01800010, 0x0fe00090, "orr%20's%c\t%12-15R, %16-19R, %o"},

  {ARM_EXT_V1, 0x03a00000, 0x0fef0000, "mov%20's%c\t%12-15r, %o"},
  {ARM_EXT_V1, 0x01a00000, 0x0def0ff0, "mov%20's%c\t%12-15r, %0-3r"},
  {ARM_EXT_V1, 0x01a00000, 0x0def0060, "lsl%20's%c\t%12-15R, %q"},
  {ARM_EXT_V1, 0x01a00020, 0x0def0060, "lsr%20's%c\t%12-15R, %q"},
  {ARM_EXT_V1, 0x01a00040, 0x0def0060, "asr%20's%c\t%12-15R, %q"},
  {ARM_EXT_V1, 0x01a00060, 0x0def0ff0, "rrx%20's%c\t%12-15r, %0-3r"},
  {ARM_EXT_V1, 0x01a00060, 0x0def0060, "ror%20's%c\t%12-15R, %q"},

  {ARM_EXT_V1, 0x03c00000, 0x0fe00000, "bic%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x01c00000, 0x0fe00010, "bic%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x01c00010, 0x0fe00090, "bic%20's%c\t%12-15R, %16-19R, %o"},

  {ARM_EXT_V1, 0x03e00000, 0x0fe00000, "mvn%20's%c\t%12-15r, %o"},
  {ARM_EXT_V1, 0x01e00000, 0x0fe00010, "mvn%20's%c\t%12-15r, %o"},
  {ARM_EXT_V1, 0x01e00010, 0x0fe00090, "mvn%20's%c\t%12-15R, %o"},

  {ARM_EXT_V1, 0x06000010, 0x0e000010, UNDEFINED_INSTRUCTION},
  {ARM_EXT_V1, 0x049d0004, 0x0fff0fff, "pop%c\t{%12-15r}\t\t; (ldr%c %12-15r, %a)"},
  
  {ARM_EXT_V1, 0x04500000, 0x0c500000, "ldrb%t%c\t%12-15R, %a"},

  {ARM_EXT_V1, 0x04300000, 0x0d700000, "ldrt%c\t%12-15R, %a"},
  {ARM_EXT_V1, 0x04100000, 0x0c500000, "ldr%c\t%12-15r, %a"},
  
  {ARM_EXT_V1, 0x092d0001, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0002, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0004, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0008, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0010, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0020, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0040, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0080, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0100, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0200, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0400, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0800, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d1000, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d2000, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d4000, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d8000, 0x0fffffff, "stmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x092d0000, 0x0fff0000, "push%c\t%m"},
  {ARM_EXT_V1, 0x08800000, 0x0ff00000, "stm%c\t%16-19R%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x08000000, 0x0e100000, "stm%23?id%24?ba%c\t%16-19R%21'!, %m%22'^"},

  {ARM_EXT_V1, 0x08bd0001, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0002, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0004, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0008, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0010, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0020, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0040, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0080, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0100, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0200, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0400, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0800, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd1000, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd2000, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd4000, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd8000, 0x0fffffff, "ldmfd%c\t%16-19R!, %m"},
  {ARM_EXT_V1, 0x08bd0000, 0x0fff0000, "pop%c\t%m"},
  {ARM_EXT_V1, 0x08900000, 0x0f900000, "ldm%c\t%16-19R%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x08100000, 0x0e100000, "ldm%23?id%24?ba%c\t%16-19R%21'!, %m%22'^"},

  {ARM_EXT_V1, 0x0a000000, 0x0e000000, "b%24'l%c\t%b"},
  {ARM_EXT_V1, 0x0f000000, 0x0f000000, "svc%c\t%0-23x"},

  /* The rest.  */
  {ARM_EXT_V1, 0x00000000, 0x00000000, UNDEFINED_INSTRUCTION},
  {0, 0x00000000, 0x00000000, 0}
};

/* print_insn_thumb16 recognizes the following format control codes:

   %S                   print Thumb register (bits 3..5 as high number if bit 6 set)
   %D                   print Thumb register (bits 0..2 as high number if bit 7 set)
   %<bitfield>I         print bitfield as a signed decimal
   				(top bit of range being the sign bit)
   %N                   print Thumb register mask (with LR)
   %O                   print Thumb register mask (with PC)
   %M                   print Thumb register mask
   %b			print CZB's 6-bit unsigned branch destination
   %s			print Thumb right-shift immediate (6..10; 0 == 32).
   %c			print the condition code
   %C			print the condition code, or "s" if not conditional
   %x			print warning if conditional an not at end of IT block"
   %X			print "\t; unpredictable <IT:code>" if conditional
   %I			print IT instruction suffix and operands
   %W			print Thumb Writeback indicator for LDMIA
   %<bitfield>r		print bitfield as an ARM register
   %<bitfield>d		print bitfield as a decimal
   %<bitfield>H         print (bitfield * 2) as a decimal
   %<bitfield>W         print (bitfield * 4) as a decimal
   %<bitfield>a         print (bitfield * 4) as a pc-rel offset + decoded symbol
   %<bitfield>B         print Thumb branch destination (signed displacement)
   %<bitfield>c         print bitfield as a condition code
   %<bitnum>'c		print specified char iff bit is one
   %<bitnum>?ab		print a if bit is one else print b.  */

static const struct opcode16 thumb_opcodes[] =
{
  /* Thumb instructions.  */

  /* ARM V8 instructions.  */
  {ARM_EXT_V8,  0xbf50, 0xffff, "sevl%c"},
  {ARM_EXT_V8,  0xba80, 0xffc0, "hlt\t%0-5x"},

  /* ARM V6K no-argument instructions.  */
  {ARM_EXT_V6K, 0xbf00, 0xffff, "nop%c"},
  {ARM_EXT_V6K, 0xbf10, 0xffff, "yield%c"},
  {ARM_EXT_V6K, 0xbf20, 0xffff, "wfe%c"},
  {ARM_EXT_V6K, 0xbf30, 0xffff, "wfi%c"},
  {ARM_EXT_V6K, 0xbf40, 0xffff, "sev%c"},
  {ARM_EXT_V6K, 0xbf00, 0xff0f, "nop%c\t{%4-7d}"},

  /* ARM V6T2 instructions.  */
  {ARM_EXT_V6T2, 0xb900, 0xfd00, "cbnz\t%0-2r, %b%X"},
  {ARM_EXT_V6T2, 0xb100, 0xfd00, "cbz\t%0-2r, %b%X"},
  {ARM_EXT_V6T2, 0xbf00, 0xff00, "it%I%X"},

  /* ARM V6.  */
  {ARM_EXT_V6, 0xb660, 0xfff8, "cpsie\t%2'a%1'i%0'f%X"},
  {ARM_EXT_V6, 0xb670, 0xfff8, "cpsid\t%2'a%1'i%0'f%X"},
  {ARM_EXT_V6, 0x4600, 0xffc0, "mov%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xba00, 0xffc0, "rev%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xba40, 0xffc0, "rev16%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xbac0, 0xffc0, "revsh%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb650, 0xfff7, "setend\t%3?ble%X"},
  {ARM_EXT_V6, 0xb200, 0xffc0, "sxth%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb240, 0xffc0, "sxtb%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb280, 0xffc0, "uxth%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb2c0, 0xffc0, "uxtb%c\t%0-2r, %3-5r"},

  /* ARM V5 ISA extends Thumb.  */
  {ARM_EXT_V5T, 0xbe00, 0xff00, "bkpt\t%0-7x"}, /* Is always unconditional.  */
  /* This is BLX(2).  BLX(1) is a 32-bit instruction.  */
  {ARM_EXT_V5T, 0x4780, 0xff87, "blx%c\t%3-6r%x"},	/* note: 4 bit register number.  */
  /* ARM V4T ISA (Thumb v1).  */
  {ARM_EXT_V4T, 0x46C0, 0xFFFF, "nop%c\t\t\t; (mov r8, r8)"},
  /* Format 4.  */
  {ARM_EXT_V4T, 0x4000, 0xFFC0, "and%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4040, 0xFFC0, "eor%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4080, 0xFFC0, "lsl%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x40C0, 0xFFC0, "lsr%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4100, 0xFFC0, "asr%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4140, 0xFFC0, "adc%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4180, 0xFFC0, "sbc%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x41C0, 0xFFC0, "ror%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4200, 0xFFC0, "tst%c\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4240, 0xFFC0, "neg%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4280, 0xFFC0, "cmp%c\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x42C0, 0xFFC0, "cmn%c\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4300, 0xFFC0, "orr%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4340, 0xFFC0, "mul%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4380, 0xFFC0, "bic%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x43C0, 0xFFC0, "mvn%C\t%0-2r, %3-5r"},
  /* format 13 */
  {ARM_EXT_V4T, 0xB000, 0xFF80, "add%c\tsp, #%0-6W"},
  {ARM_EXT_V4T, 0xB080, 0xFF80, "sub%c\tsp, #%0-6W"},
  /* format 5 */
  {ARM_EXT_V4T, 0x4700, 0xFF80, "bx%c\t%S%x"},
  {ARM_EXT_V4T, 0x4400, 0xFF00, "add%c\t%D, %S"},
  {ARM_EXT_V4T, 0x4500, 0xFF00, "cmp%c\t%D, %S"},
  {ARM_EXT_V4T, 0x4600, 0xFF00, "mov%c\t%D, %S"},
  /* format 14 */
  {ARM_EXT_V4T, 0xB400, 0xFE00, "push%c\t%N"},
  {ARM_EXT_V4T, 0xBC00, 0xFE00, "pop%c\t%O"},
  /* format 2 */
  {ARM_EXT_V4T, 0x1800, 0xFE00, "add%C\t%0-2r, %3-5r, %6-8r"},
  {ARM_EXT_V4T, 0x1A00, 0xFE00, "sub%C\t%0-2r, %3-5r, %6-8r"},
  {ARM_EXT_V4T, 0x1C00, 0xFE00, "add%C\t%0-2r, %3-5r, #%6-8d"},
  {ARM_EXT_V4T, 0x1E00, 0xFE00, "sub%C\t%0-2r, %3-5r, #%6-8d"},
  /* format 8 */
  {ARM_EXT_V4T, 0x5200, 0xFE00, "strh%c\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5A00, 0xFE00, "ldrh%c\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5600, 0xF600, "ldrs%11?hb%c\t%0-2r, [%3-5r, %6-8r]"},
  /* format 7 */
  {ARM_EXT_V4T, 0x5000, 0xFA00, "str%10'b%c\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5800, 0xFA00, "ldr%10'b%c\t%0-2r, [%3-5r, %6-8r]"},
  /* format 1 */
  {ARM_EXT_V4T, 0x0000, 0xFFC0, "mov%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x0000, 0xF800, "lsl%C\t%0-2r, %3-5r, #%6-10d"},
  {ARM_EXT_V4T, 0x0800, 0xF800, "lsr%C\t%0-2r, %3-5r, %s"},
  {ARM_EXT_V4T, 0x1000, 0xF800, "asr%C\t%0-2r, %3-5r, %s"},
  /* format 3 */
  {ARM_EXT_V4T, 0x2000, 0xF800, "mov%C\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x2800, 0xF800, "cmp%c\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x3000, 0xF800, "add%C\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x3800, 0xF800, "sub%C\t%8-10r, #%0-7d"},
  /* format 6 */
  {ARM_EXT_V4T, 0x4800, 0xF800, "ldr%c\t%8-10r, [pc, #%0-7W]\t; (%0-7a)"},  /* TODO: Disassemble PC relative "LDR rD,=<symbolic>" */
  /* format 9 */
  {ARM_EXT_V4T, 0x6000, 0xF800, "str%c\t%0-2r, [%3-5r, #%6-10W]"},
  {ARM_EXT_V4T, 0x6800, 0xF800, "ldr%c\t%0-2r, [%3-5r, #%6-10W]"},
  {ARM_EXT_V4T, 0x7000, 0xF800, "strb%c\t%0-2r, [%3-5r, #%6-10d]"},
  {ARM_EXT_V4T, 0x7800, 0xF800, "ldrb%c\t%0-2r, [%3-5r, #%6-10d]"},
  /* format 10 */
  {ARM_EXT_V4T, 0x8000, 0xF800, "strh%c\t%0-2r, [%3-5r, #%6-10H]"},
  {ARM_EXT_V4T, 0x8800, 0xF800, "ldrh%c\t%0-2r, [%3-5r, #%6-10H]"},
  /* format 11 */
  {ARM_EXT_V4T, 0x9000, 0xF800, "str%c\t%8-10r, [sp, #%0-7W]"},
  {ARM_EXT_V4T, 0x9800, 0xF800, "ldr%c\t%8-10r, [sp, #%0-7W]"},
  /* format 12 */
  {ARM_EXT_V4T, 0xA000, 0xF800, "add%c\t%8-10r, pc, #%0-7W\t; (adr %8-10r, %0-7a)"},
  {ARM_EXT_V4T, 0xA800, 0xF800, "add%c\t%8-10r, sp, #%0-7W"},
  /* format 15 */
  {ARM_EXT_V4T, 0xC000, 0xF800, "stmia%c\t%8-10r!, %M"},
  {ARM_EXT_V4T, 0xC800, 0xF800, "ldmia%c\t%8-10r%W, %M"},
  /* format 17 */
  {ARM_EXT_V4T, 0xDF00, 0xFF00, "svc%c\t%0-7d"},
  /* format 16 */
  {ARM_EXT_V4T, 0xDE00, 0xFF00, "udf%c\t#%0-7d"},
  {ARM_EXT_V4T, 0xDE00, 0xFE00, UNDEFINED_INSTRUCTION},
  {ARM_EXT_V4T, 0xD000, 0xF000, "b%8-11c.n\t%0-7B%X"},
  /* format 18 */
  {ARM_EXT_V4T, 0xE000, 0xF800, "b%c.n\t%0-10B%x"},

  /* The E800 .. FFFF range is unconditionally redirected to the
     32-bit table, because even in pre-V6T2 ISAs, BL and BLX(1) pairs
     are processed via that table.  Thus, we can never encounter a
     bare "second half of BL/BLX(1)" instruction here.  */
  {ARM_EXT_V1,  0x0000, 0x0000, UNDEFINED_INSTRUCTION},
  {0, 0, 0, 0}
};

/* Thumb32 opcodes use the same table structure as the ARM opcodes.
   We adopt the convention that hw1 is the high 16 bits of .value and
   .mask, hw2 the low 16 bits.

   print_insn_thumb32 recognizes the following format control codes:

       %%		%

       %I		print a 12-bit immediate from hw1[10],hw2[14:12,7:0]
       %M		print a modified 12-bit immediate (same location)
       %J		print a 16-bit immediate from hw1[3:0,10],hw2[14:12,7:0]
       %K		print a 16-bit immediate from hw2[3:0],hw1[3:0],hw2[11:4]
       %H		print a 16-bit immediate from hw2[3:0],hw1[11:0]
       %S		print a possibly-shifted Rm

       %L		print address for a ldrd/strd instruction
       %a		print the address of a plain load/store
       %w		print the width and signedness of a core load/store
       %m		print register mask for ldm/stm

       %E		print the lsb and width fields of a bfc/bfi instruction
       %F		print the lsb and width fields of a sbfx/ubfx instruction
       %b		print a conditional branch offset
       %B		print an unconditional branch offset
       %s		print the shift field of an SSAT instruction
       %R		print the rotation field of an SXT instruction
       %U		print barrier type.
       %P		print address for pli instruction.
       %c		print the condition code
       %x		print warning if conditional an not at end of IT block"
       %X		print "\t; unpredictable <IT:code>" if conditional

       %<bitfield>d	print bitfield in decimal
       %<bitfield>W	print bitfield*4 in decimal
       %<bitfield>r	print bitfield as an ARM register
       %<bitfield>R	as %<>r but r15 is UNPREDICTABLE
       %<bitfield>S	as %<>R but r13 is UNPREDICTABLE
       %<bitfield>c	print bitfield as a condition code

       %<bitfield>'c	print specified char iff bitfield is all ones
       %<bitfield>`c	print specified char iff bitfield is all zeroes
       %<bitfield>?ab... select from array of values in big endian order

   With one exception at the bottom (done because BL and BLX(1) need
   to come dead last), this table was machine-sorted first in
   decreasing order of number of bits set in the mask, then in
   increasing numeric order of mask, then in increasing numeric order
   of opcode.  This order is not the clearest for a human reader, but
   is guaranteed never to catch a special-case bit pattern with a more
   general mask, which is important, because this instruction encoding
   makes heavy use of special-case bit patterns.  */
static const struct opcode32 thumb32_opcodes[] =
{
  /* V8 instructions.  */
  {ARM_EXT_V8, 0xf3af8005, 0xffffffff, "sevl%c.w"},
  {ARM_EXT_V8, 0xf78f8000, 0xfffffffc, "dcps%0-1d"},
  {ARM_EXT_V8, 0xe8c00f8f, 0xfff00fff, "stlb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00f9f, 0xfff00fff, "stlh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00faf, 0xfff00fff, "stl%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fc0, 0xfff00ff0, "stlexb%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fd0, 0xfff00ff0, "stlexh%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fe0, 0xfff00ff0, "stlex%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c000f0, 0xfff000f0, "stlexd%c\t%0-3r, %12-15r, %8-11r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00f8f, 0xfff00fff, "ldab%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00f9f, 0xfff00fff, "ldah%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00faf, 0xfff00fff, "lda%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fcf, 0xfff00fff, "ldaexb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fdf, 0xfff00fff, "ldaexh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fef, 0xfff00fff, "ldaex%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d000ff, 0xfff000ff, "ldaexd%c\t%12-15r, %8-11r, [%16-19R]"},

  /* CRC32 instructions.  */
  {CRC_EXT_ARMV8, 0xfac0f080, 0xfff0f0f0, "crc32b\t%8-11S, %16-19S, %0-3S"},
  {CRC_EXT_ARMV8, 0xfac0f090, 0xfff0f0f0, "crc32h\t%9-11S, %16-19S, %0-3S"},
  {CRC_EXT_ARMV8, 0xfac0f0a0, 0xfff0f0f0, "crc32w\t%8-11S, %16-19S, %0-3S"},
  {CRC_EXT_ARMV8, 0xfad0f080, 0xfff0f0f0, "crc32cb\t%8-11S, %16-19S, %0-3S"},
  {CRC_EXT_ARMV8, 0xfad0f090, 0xfff0f0f0, "crc32ch\t%8-11S, %16-19S, %0-3S"},
  {CRC_EXT_ARMV8, 0xfad0f0a0, 0xfff0f0f0, "crc32cw\t%8-11S, %16-19S, %0-3S"},

  /* V7 instructions.  */
  {ARM_EXT_V7, 0xf910f000, 0xff70f000, "pli%c\t%a"},
  {ARM_EXT_V7, 0xf3af80f0, 0xfffffff0, "dbg%c\t#%0-3d"},
  {ARM_EXT_V8, 0xf3bf8f51, 0xfffffff3, "dmb%c\t%U"},
  {ARM_EXT_V8, 0xf3bf8f41, 0xfffffff3, "dsb%c\t%U"},
  {ARM_EXT_V7, 0xf3bf8f50, 0xfffffff0, "dmb%c\t%U"},
  {ARM_EXT_V7, 0xf3bf8f40, 0xfffffff0, "dsb%c\t%U"},
  {ARM_EXT_V7, 0xf3bf8f60, 0xfffffff0, "isb%c\t%U"},
  {ARM_EXT_DIV, 0xfb90f0f0, 0xfff0f0f0, "sdiv%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_DIV, 0xfbb0f0f0, 0xfff0f0f0, "udiv%c\t%8-11r, %16-19r, %0-3r"},

  /* Virtualization Extension instructions.  */
  {ARM_EXT_VIRT, 0xf7e08000, 0xfff0f000, "hvc%c\t%V"},
  /* We skip ERET as that is SUBS pc, lr, #0.  */

  /* MP Extension instructions.  */
  {ARM_EXT_MP,   0xf830f000, 0xff70f000, "pldw%c\t%a"},

  /* Security extension instructions.  */
  {ARM_EXT_SEC,  0xf7f08000, 0xfff0f000, "smc%c\t%K"},

  /* Instructions defined in the basic V6T2 set.  */
  {ARM_EXT_V6T2, 0xf3af8000, 0xffffffff, "nop%c.w"},
  {ARM_EXT_V6T2, 0xf3af8001, 0xffffffff, "yield%c.w"},
  {ARM_EXT_V6T2, 0xf3af8002, 0xffffffff, "wfe%c.w"},
  {ARM_EXT_V6T2, 0xf3af8003, 0xffffffff, "wfi%c.w"},
  {ARM_EXT_V6T2, 0xf3af8004, 0xffffffff, "sev%c.w"},
  {ARM_EXT_V6T2, 0xf3af8000, 0xffffff00, "nop%c.w\t{%0-7d}"},
  {ARM_EXT_V6T2, 0xf7f0a000, 0xfff0f000, "udf%c.w\t%H"},

  {ARM_EXT_V6T2, 0xf3bf8f2f, 0xffffffff, "clrex%c"},
  {ARM_EXT_V6T2, 0xf3af8400, 0xffffff1f, "cpsie.w\t%7'a%6'i%5'f%X"},
  {ARM_EXT_V6T2, 0xf3af8600, 0xffffff1f, "cpsid.w\t%7'a%6'i%5'f%X"},
  {ARM_EXT_V6T2, 0xf3c08f00, 0xfff0ffff, "bxj%c\t%16-19r%x"},
  {ARM_EXT_V6T2, 0xe810c000, 0xffd0ffff, "rfedb%c\t%16-19r%21'!"},
  {ARM_EXT_V6T2, 0xe990c000, 0xffd0ffff, "rfeia%c\t%16-19r%21'!"},
  {ARM_EXT_V6T2, 0xf3e08000, 0xffe0f000, "mrs%c\t%8-11r, %D"},
  {ARM_EXT_V6T2, 0xf3af8100, 0xffffffe0, "cps\t#%0-4d%X"},
  {ARM_EXT_V6T2, 0xe8d0f000, 0xfff0fff0, "tbb%c\t[%16-19r, %0-3r]%x"},
  {ARM_EXT_V6T2, 0xe8d0f010, 0xfff0fff0, "tbh%c\t[%16-19r, %0-3r, lsl #1]%x"},
  {ARM_EXT_V6T2, 0xf3af8500, 0xffffff00, "cpsie\t%7'a%6'i%5'f, #%0-4d%X"},
  {ARM_EXT_V6T2, 0xf3af8700, 0xffffff00, "cpsid\t%7'a%6'i%5'f, #%0-4d%X"},
  {ARM_EXT_V6T2, 0xf3de8f00, 0xffffff00, "subs%c\tpc, lr, #%0-7d"},
  {ARM_EXT_V6T2, 0xf3808000, 0xffe0f000, "msr%c\t%C, %16-19r"},
  {ARM_EXT_V6T2, 0xe8500f00, 0xfff00fff, "ldrex%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe8d00f4f, 0xfff00fef, "ldrex%4?hb%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe800c000, 0xffd0ffe0, "srsdb%c\t%16-19r%21'!, #%0-4d"},
  {ARM_EXT_V6T2, 0xe980c000, 0xffd0ffe0, "srsia%c\t%16-19r%21'!, #%0-4d"},
  {ARM_EXT_V6T2, 0xfa0ff080, 0xfffff0c0, "sxth%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa1ff080, 0xfffff0c0, "uxth%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa2ff080, 0xfffff0c0, "sxtb16%c\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa3ff080, 0xfffff0c0, "uxtb16%c\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa4ff080, 0xfffff0c0, "sxtb%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa5ff080, 0xfffff0c0, "uxtb%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xe8400000, 0xfff000ff, "strex%c\t%8-11r, %12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe8d0007f, 0xfff000ff, "ldrexd%c\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xfa80f000, 0xfff0f0f0, "sadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f010, 0xfff0f0f0, "qadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f020, 0xfff0f0f0, "shadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f040, 0xfff0f0f0, "uadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f050, 0xfff0f0f0, "uqadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f060, 0xfff0f0f0, "uhadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f080, 0xfff0f0f0, "qadd%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f090, 0xfff0f0f0, "qdadd%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0a0, 0xfff0f0f0, "qsub%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0b0, 0xfff0f0f0, "qdsub%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f000, 0xfff0f0f0, "sadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f010, 0xfff0f0f0, "qadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f020, 0xfff0f0f0, "shadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f040, 0xfff0f0f0, "uadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f050, 0xfff0f0f0, "uqadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f060, 0xfff0f0f0, "uhadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f080, 0xfff0f0f0, "rev%c.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f090, 0xfff0f0f0, "rev16%c.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f0a0, 0xfff0f0f0, "rbit%c\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f0b0, 0xfff0f0f0, "revsh%c.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfaa0f000, 0xfff0f0f0, "sasx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f010, 0xfff0f0f0, "qasx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f020, 0xfff0f0f0, "shasx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f040, 0xfff0f0f0, "uasx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f050, 0xfff0f0f0, "uqasx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f060, 0xfff0f0f0, "uhasx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f080, 0xfff0f0f0, "sel%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfab0f080, 0xfff0f0f0, "clz%c\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfac0f000, 0xfff0f0f0, "ssub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f010, 0xfff0f0f0, "qsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f020, 0xfff0f0f0, "shsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f040, 0xfff0f0f0, "usub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f050, 0xfff0f0f0, "uqsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f060, 0xfff0f0f0, "uhsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f000, 0xfff0f0f0, "ssub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f010, 0xfff0f0f0, "qsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f020, 0xfff0f0f0, "shsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f040, 0xfff0f0f0, "usub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f050, 0xfff0f0f0, "uqsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f060, 0xfff0f0f0, "uhsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f000, 0xfff0f0f0, "ssax%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f010, 0xfff0f0f0, "qsax%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f020, 0xfff0f0f0, "shsax%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f040, 0xfff0f0f0, "usax%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f050, 0xfff0f0f0, "uqsax%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f060, 0xfff0f0f0, "uhsax%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb00f000, 0xfff0f0f0, "mul%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb70f000, 0xfff0f0f0, "usad8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa00f000, 0xffe0f0f0, "lsl%20's%c.w\t%8-11R, %16-19R, %0-3R"},
  {ARM_EXT_V6T2, 0xfa20f000, 0xffe0f0f0, "lsr%20's%c.w\t%8-11R, %16-19R, %0-3R"},
  {ARM_EXT_V6T2, 0xfa40f000, 0xffe0f0f0, "asr%20's%c.w\t%8-11R, %16-19R, %0-3R"},
  {ARM_EXT_V6T2, 0xfa60f000, 0xffe0f0f0, "ror%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xe8c00f40, 0xfff00fe0, "strex%4?hb%c\t%0-3r, %12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xf3200000, 0xfff0f0e0, "ssat16%c\t%8-11r, #%0-4d, %16-19r"},
  {ARM_EXT_V6T2, 0xf3a00000, 0xfff0f0e0, "usat16%c\t%8-11r, #%0-4d, %16-19r"},
  {ARM_EXT_V6T2, 0xfb20f000, 0xfff0f0e0, "smuad%4'x%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb30f000, 0xfff0f0e0, "smulw%4?tb%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb40f000, 0xfff0f0e0, "smusd%4'x%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb50f000, 0xfff0f0e0, "smmul%4'r%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa00f080, 0xfff0f0c0, "sxtah%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa10f080, 0xfff0f0c0, "uxtah%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa20f080, 0xfff0f0c0, "sxtab16%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa30f080, 0xfff0f0c0, "uxtab16%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa40f080, 0xfff0f0c0, "sxtab%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa50f080, 0xfff0f0c0, "uxtab%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfb10f000, 0xfff0f0c0, "smul%5?tb%4?tb%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xf36f0000, 0xffff8020, "bfc%c\t%8-11r, %E"},
  {ARM_EXT_V6T2, 0xea100f00, 0xfff08f00, "tst%c.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xea900f00, 0xfff08f00, "teq%c\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb100f00, 0xfff08f00, "cmn%c.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xebb00f00, 0xfff08f00, "cmp%c.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xf0100f00, 0xfbf08f00, "tst%c.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0900f00, 0xfbf08f00, "teq%c\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1100f00, 0xfbf08f00, "cmn%c.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1b00f00, 0xfbf08f00, "cmp%c.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xea4f0000, 0xffef8000, "mov%20's%c.w\t%8-11r, %S"},
  {ARM_EXT_V6T2, 0xea6f0000, 0xffef8000, "mvn%20's%c.w\t%8-11r, %S"},
  {ARM_EXT_V6T2, 0xe8c00070, 0xfff000f0, "strexd%c\t%0-3r, %12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xfb000000, 0xfff000f0, "mla%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb000010, 0xfff000f0, "mls%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb700000, 0xfff000f0, "usada8%c\t%8-11R, %16-19R, %0-3R, %12-15R"},
  {ARM_EXT_V6T2, 0xfb800000, 0xfff000f0, "smull%c\t%12-15R, %8-11R, %16-19R, %0-3R"},
  {ARM_EXT_V6T2, 0xfba00000, 0xfff000f0, "umull%c\t%12-15R, %8-11R, %16-19R, %0-3R"},
  {ARM_EXT_V6T2, 0xfbc00000, 0xfff000f0, "smlal%c\t%12-15R, %8-11R, %16-19R, %0-3R"},
  {ARM_EXT_V6T2, 0xfbe00000, 0xfff000f0, "umlal%c\t%12-15R, %8-11R, %16-19R, %0-3R"},
  {ARM_EXT_V6T2, 0xfbe00060, 0xfff000f0, "umaal%c\t%12-15R, %8-11R, %16-19R, %0-3R"},
  {ARM_EXT_V6T2, 0xe8500f00, 0xfff00f00, "ldrex%c\t%12-15r, [%16-19r, #%0-7W]"},
  {ARM_EXT_V6T2, 0xf04f0000, 0xfbef8000, "mov%20's%c.w\t%8-11r, %M"},
  {ARM_EXT_V6T2, 0xf06f0000, 0xfbef8000, "mvn%20's%c.w\t%8-11r, %M"},
  {ARM_EXT_V6T2, 0xf810f000, 0xff70f000, "pld%c\t%a"},
  {ARM_EXT_V6T2, 0xfb200000, 0xfff000e0, "smlad%4'x%c\t%8-11R, %16-19R, %0-3R, %12-15R"},
  {ARM_EXT_V6T2, 0xfb300000, 0xfff000e0, "smlaw%4?tb%c\t%8-11R, %16-19R, %0-3R, %12-15R"},
  {ARM_EXT_V6T2, 0xfb400000, 0xfff000e0, "smlsd%4'x%c\t%8-11R, %16-19R, %0-3R, %12-15R"},
  {ARM_EXT_V6T2, 0xfb500000, 0xfff000e0, "smmla%4'r%c\t%8-11R, %16-19R, %0-3R, %12-15R"},
  {ARM_EXT_V6T2, 0xfb600000, 0xfff000e0, "smmls%4'r%c\t%8-11R, %16-19R, %0-3R, %12-15R"},
  {ARM_EXT_V6T2, 0xfbc000c0, 0xfff000e0, "smlald%4'x%c\t%12-15R, %8-11R, %16-19R, %0-3R"},
  {ARM_EXT_V6T2, 0xfbd000c0, 0xfff000e0, "smlsld%4'x%c\t%12-15R, %8-11R, %16-19R, %0-3R"},
  {ARM_EXT_V6T2, 0xeac00000, 0xfff08030, "pkhbt%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeac00020, 0xfff08030, "pkhtb%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xf3400000, 0xfff08020, "sbfx%c\t%8-11r, %16-19r, %F"},
  {ARM_EXT_V6T2, 0xf3c00000, 0xfff08020, "ubfx%c\t%8-11r, %16-19r, %F"},
  {ARM_EXT_V6T2, 0xf8000e00, 0xff900f00, "str%wt%c\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xfb100000, 0xfff000c0, "smla%5?tb%4?tb%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfbc00080, 0xfff000c0, "smlal%5?tb%4?tb%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xf3600000, 0xfff08020, "bfi%c\t%8-11r, %16-19r, %E"},
  {ARM_EXT_V6T2, 0xf8100e00, 0xfe900f00, "ldr%wt%c\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf3000000, 0xffd08020, "ssat%c\t%8-11r, #%0-4d, %16-19r%s"},
  {ARM_EXT_V6T2, 0xf3800000, 0xffd08020, "usat%c\t%8-11r, #%0-4d, %16-19r%s"},
  {ARM_EXT_V6T2, 0xf2000000, 0xfbf08000, "addw%c\t%8-11r, %16-19r, %I"},
  {ARM_EXT_V6T2, 0xf2400000, 0xfbf08000, "movw%c\t%8-11r, %J"},
  {ARM_EXT_V6T2, 0xf2a00000, 0xfbf08000, "subw%c\t%8-11r, %16-19r, %I"},
  {ARM_EXT_V6T2, 0xf2c00000, 0xfbf08000, "movt%c\t%8-11r, %J"},
  {ARM_EXT_V6T2, 0xea000000, 0xffe08000, "and%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea200000, 0xffe08000, "bic%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea400000, 0xffe08000, "orr%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea600000, 0xffe08000, "orn%20's%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea800000, 0xffe08000, "eor%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb000000, 0xffe08000, "add%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb400000, 0xffe08000, "adc%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb600000, 0xffe08000, "sbc%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeba00000, 0xffe08000, "sub%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xebc00000, 0xffe08000, "rsb%20's%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xe8400000, 0xfff00000, "strex%c\t%8-11r, %12-15r, [%16-19r, #%0-7W]"},
  {ARM_EXT_V6T2, 0xf0000000, 0xfbe08000, "and%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0200000, 0xfbe08000, "bic%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0400000, 0xfbe08000, "orr%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0600000, 0xfbe08000, "orn%20's%c\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0800000, 0xfbe08000, "eor%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1000000, 0xfbe08000, "add%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1400000, 0xfbe08000, "adc%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1600000, 0xfbe08000, "sbc%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1a00000, 0xfbe08000, "sub%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1c00000, 0xfbe08000, "rsb%20's%c\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xe8800000, 0xffd00000, "stmia%c.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe8900000, 0xffd00000, "ldmia%c.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9000000, 0xffd00000, "stmdb%c\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9100000, 0xffd00000, "ldmdb%c\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9c00000, 0xffd000ff, "strd%c\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9d00000, 0xffd000ff, "ldrd%c\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9400000, 0xff500000, "strd%c\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]%21'!%L"},
  {ARM_EXT_V6T2, 0xe9500000, 0xff500000, "ldrd%c\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]%21'!%L"},
  {ARM_EXT_V6T2, 0xe8600000, 0xff700000, "strd%c\t%12-15r, %8-11r, [%16-19r], #%23`-%0-7W%L"},
  {ARM_EXT_V6T2, 0xe8700000, 0xff700000, "ldrd%c\t%12-15r, %8-11r, [%16-19r], #%23`-%0-7W%L"},
  {ARM_EXT_V6T2, 0xf8000000, 0xff100000, "str%w%c.w\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf8100000, 0xfe100000, "ldr%w%c.w\t%12-15r, %a"},

  /* Filter out Bcc with cond=E or F, which are used for other instructions.  */
  {ARM_EXT_V6T2, 0xf3c08000, 0xfbc0d000, "undefined (bcc, cond=0xF)"},
  {ARM_EXT_V6T2, 0xf3808000, 0xfbc0d000, "undefined (bcc, cond=0xE)"},
  {ARM_EXT_V6T2, 0xf0008000, 0xf800d000, "b%22-25c.w\t%b%X"},
  {ARM_EXT_V6T2, 0xf0009000, 0xf800d000, "b%c.w\t%B%x"},

  /* These have been 32-bit since the invention of Thumb.  */
  {ARM_EXT_V4T,  0xf000c000, 0xf800d001, "blx%c\t%B%x"},
  {ARM_EXT_V4T,  0xf000d000, 0xf800d000, "bl%c\t%B%x"},

  /* Fallback.  */
  {ARM_EXT_V1,   0x00000000, 0x00000000, UNDEFINED_INSTRUCTION},
  {0, 0, 0, 0}
};

static const char *const arm_conditional[] =
{"eq", "ne", "cs", "cc", "mi", "pl", "vs", "vc",
 "hi", "ls", "ge", "lt", "gt", "le", "al", "<und>", ""};

static const char *const arm_fp_const[] =
{"0.0", "1.0", "2.0", "3.0", "4.0", "5.0", "0.5", "10.0"};

static const char *const arm_shift[] =
{"lsl", "lsr", "asr", "ror"};

typedef struct
{
  const char *name;
  const char *description;
  const char *reg_names[16];
}
arm_regname;

static const arm_regname regnames[] =
{
  { "raw" , "Select raw register names",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}},
  { "gcc",  "Select register names used by GCC",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "std",  "Select register names used in ARM's ISA documentation",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "sp",  "lr",  "pc" }},
  { "apcs", "Select register names used in the APCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "atpcs", "Select register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "v7",  "v8",  "IP",  "SP",  "LR",  "PC" }},
  { "special-atpcs", "Select special register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},
};

static const char *const iwmmxt_wwnames[] =
{"b", "h", "w", "d"};

static const char *const iwmmxt_wwssnames[] =
{"b", "bus", "bc", "bss",
 "h", "hus", "hc", "hss",
 "w", "wus", "wc", "wss",
 "d", "dus", "dc", "dss"
};

static const char *const iwmmxt_regnames[] =
{ "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7",
  "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"
};

static const char *const iwmmxt_cregnames[] =
{ "wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved",
  "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"
};

/* Default to GCC register name set.  */
static unsigned int regname_selected = 1;

#define NUM_ARM_REGNAMES  NUM_ELEM (regnames)
#define arm_regnames      regnames[regname_selected].reg_names

static bfd_boolean force_thumb = FALSE;

/* Current IT instruction state.  This contains the same state as the IT
   bits in the CPSR.  */
static unsigned int ifthen_state;
/* IT state for the next instruction.  */
static unsigned int ifthen_next_state;
/* The address of the insn for which the IT state is valid.  */
static bfd_vma ifthen_address;
#define IFTHEN_COND ((ifthen_state >> 4) & 0xf)
/* Indicates that the current Conditional state is unconditional or outside
   an IT block.  */
#define COND_UNCOND 16


/* Functions.  */
int
get_arm_regname_num_options (void)
{
  return NUM_ARM_REGNAMES;
}

int
set_arm_regname_option (int option)
{
  int old = regname_selected;
  regname_selected = option;
  return old;
}

int
get_arm_regnames (int option,
		  const char **setname,
		  const char **setdescription,
		  const char *const **register_names)
{
  *setname = regnames[option].name;
  *setdescription = regnames[option].description;
  *register_names = regnames[option].reg_names;
  return 16;
}

/* Decode a bitfield of the form matching regexp (N(-N)?,)*N(-N)?.
   Returns pointer to following character of the format string and
   fills in *VALUEP and *WIDTHP with the extracted value and number of
   bits extracted.  WIDTHP can be NULL.  */

static const char *
arm_decode_bitfield (const char *ptr,
		     unsigned long insn,
		     unsigned long *valuep,
		     int *widthp)
{
  unsigned long value = 0;
  int width = 0;
  
  do 
    {
      int start, end;
      int bits;

      for (start = 0; *ptr >= '0' && *ptr <= '9'; ptr++)
	start = start * 10 + *ptr - '0';
      if (*ptr == '-')
	for (end = 0, ptr++; *ptr >= '0' && *ptr <= '9'; ptr++)
	  end = end * 10 + *ptr - '0';
      else
	end = start;
      bits = end - start;
      if (bits < 0)
	abort ();
      value |= ((insn >> start) & ((2ul << bits) - 1)) << width;
      width += bits + 1;
    }
  while (*ptr++ == ',');
  *valuep = value;
  if (widthp)
    *widthp = width;
  return ptr - 1;
}

static void
arm_decode_shift (long given, fprintf_ftype func, void *stream,
		  bfd_boolean print_shift)
{
  func (stream, "%s", arm_regnames[given & 0xf]);

  if ((given & 0xff0) != 0)
    {
      if ((given & 0x10) == 0)
	{
	  int amount = (given & 0xf80) >> 7;
	  int shift = (given & 0x60) >> 5;

	  if (amount == 0)
	    {
	      if (shift == 3)
		{
		  func (stream, ", rrx");
		  return;
		}

	      amount = 32;
	    }

	  if (print_shift)
	    func (stream, ", %s #%d", arm_shift[shift], amount);
	  else
	    func (stream, ", #%d", amount);
	}
      else if ((given & 0x80) == 0x80)
	func (stream, "\t; <illegal shifter operand>");
      else if (print_shift)
	func (stream, ", %s %s", arm_shift[(given & 0x60) >> 5],
	      arm_regnames[(given & 0xf00) >> 8]);
      else
	func (stream, ", %s", arm_regnames[(given & 0xf00) >> 8]);
    }
}

#define W_BIT 21
#define I_BIT 22
#define U_BIT 23
#define P_BIT 24

#define WRITEBACK_BIT_SET   (given & (1 << W_BIT))
#define IMMEDIATE_BIT_SET   (given & (1 << I_BIT))
#define NEGATIVE_BIT_SET   ((given & (1 << U_BIT)) == 0)
#define PRE_BIT_SET         (given & (1 << P_BIT))

/* Print one coprocessor instruction on INFO->STREAM.
   Return TRUE if the instuction matched, FALSE if this is not a
   recognised coprocessor instruction.  */

static bfd_boolean
print_insn_coprocessor (bfd_vma pc,
			struct disassemble_info *info,
			long given,
			bfd_boolean thumb)
{
  const struct opcode32 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
  unsigned long mask;
  unsigned long value = 0;
  struct arm_private_data *private_data = info->private_data;
  unsigned long allowed_arches = private_data->features.coproc;
  int cond;

  for (insn = coprocessor_opcodes; insn->assembler; insn++)
    {
      unsigned long u_reg = 16;
      bfd_boolean is_unpredictable = FALSE;
      signed long value_in_comment = 0;
      const char *c;

      if (insn->arch == 0)
	switch (insn->value)
	  {
	  case SENTINEL_IWMMXT_START:
	    if (info->mach != bfd_mach_arm_XScale
		&& info->mach != bfd_mach_arm_iWMMXt
		&& info->mach != bfd_mach_arm_iWMMXt2)
	      do
		insn++;
	      while (insn->arch != 0 && insn->value != SENTINEL_IWMMXT_END);
	    continue;

	  case SENTINEL_IWMMXT_END:
	    continue;

	  case SENTINEL_GENERIC_START:
	    allowed_arches = private_data->features.core;
	    continue;

	  default:
	    abort ();
	  }

      mask = insn->mask;
      value = insn->value;
      if (thumb)
	{
	  /* The high 4 bits are 0xe for Arm conditional instructions, and
	     0xe for arm unconditional instructions.  The rest of the
	     encoding is the same.  */
	  mask |= 0xf0000000;
	  value |= 0xe0000000;
	  if (ifthen_state)
	    cond = IFTHEN_COND;
	  else
	    cond = COND_UNCOND;
	}
      else
	{
	  /* Only match unconditional instuctions against unconditional
	     patterns.  */
	  if ((given & 0xf0000000) == 0xf0000000)
	    {
	      mask |= 0xf0000000;
	      cond = COND_UNCOND;
	    }
	  else
	    {
	      cond = (given >> 28) & 0xf;
	      if (cond == 0xe)
		cond = COND_UNCOND;
	    }
	}
      
      if ((given & mask) != value)
	continue;

      if ((insn->arch & allowed_arches) == 0)
	continue;

      for (c = insn->assembler; *c; c++)
	{
	  if (*c == '%')
	    {
	      switch (*++c)
		{
		case '%':
		  func (stream, "%%");
		  break;

		case 'A':
		  {
		    int rn = (given >> 16) & 0xf;
  		    bfd_vma offset = given & 0xff;

		    func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

		    if (PRE_BIT_SET || WRITEBACK_BIT_SET)
		      {
			/* Not unindexed.  The offset is scaled.  */
			offset = offset * 4;
			if (NEGATIVE_BIT_SET)
			  offset = - offset;
			if (rn != 15)
			  value_in_comment = offset;
		      }

		    if (PRE_BIT_SET)
		      {
			if (offset)
			  func (stream, ", #%d]%s",
				(int) offset,
				WRITEBACK_BIT_SET ? "!" : "");
			else if (NEGATIVE_BIT_SET)
			  func (stream, ", #-0]");
			else
			  func (stream, "]");
		      }
		    else
		      {
			func (stream, "]");

			if (WRITEBACK_BIT_SET)
			  {
			    if (offset)
			      func (stream, ", #%d", (int) offset);
			    else if (NEGATIVE_BIT_SET)
			      func (stream, ", #-0");
			  }
			else
			  {
			    func (stream, ", {%s%d}",
				  (NEGATIVE_BIT_SET && !offset) ? "-" : "",
				  (int) offset);
			    value_in_comment = offset;
			  }
		      }
		    if (rn == 15 && (PRE_BIT_SET || WRITEBACK_BIT_SET))
		      {
			func (stream, "\t; ");
			/* For unaligned PCs, apply off-by-alignment
			   correction.  */
			info->print_address_func (offset + pc 
						  + info->bytes_per_chunk * 2
						  - (pc & 3),
				 		  info);
		      }
		  }
		  break;

		case 'B':
		  {
		    int regno = ((given >> 12) & 0xf) | ((given >> (22 - 4)) & 0x10);
		    int offset = (given >> 1) & 0x3f;

		    if (offset == 1)
		      func (stream, "{d%d}", regno);
		    else if (regno + offset > 32)
		      func (stream, "{d%d-<overflow reg d%d>}", regno, regno + offset - 1);
		    else
		      func (stream, "{d%d-d%d}", regno, regno + offset - 1);
		  }
		  break;

		case 'u':
		  if (cond != COND_UNCOND)
		    is_unpredictable = TRUE;

		  /* Fall through.  */
		case 'c':
		  func (stream, "%s", arm_conditional[cond]);
		  break;

		case 'I':
		  /* Print a Cirrus/DSP shift immediate.  */
		  /* Immediates are 7bit signed ints with bits 0..3 in
		     bits 0..3 of opcode and bits 4..6 in bits 5..7
		     of opcode.  */
		  {
		    int imm;

		    imm = (given & 0xf) | ((given & 0xe0) >> 1);

		    /* Is ``imm'' a negative number?  */
		    if (imm & 0x40)
		      imm |= (-1 << 7);

		    func (stream, "%d", imm);
		  }

		  break;

		case 'F':
		  switch (given & 0x00408000)
		    {
		    case 0:
		      func (stream, "4");
		      break;
		    case 0x8000:
		      func (stream, "1");
		      break;
		    case 0x00400000:
		      func (stream, "2");
		      break;
		    default:
		      func (stream, "3");
		    }
		  break;

		case 'P':
		  switch (given & 0x00080080)
		    {
		    case 0:
		      func (stream, "s");
		      break;
		    case 0x80:
		      func (stream, "d");
		      break;
		    case 0x00080000:
		      func (stream, "e");
		      break;
		    default:
		      func (stream, _("<illegal precision>"));
		      break;
		    }
		  break;

		case 'Q':
		  switch (given & 0x00408000)
		    {
		    case 0:
		      func (stream, "s");
		      break;
		    case 0x8000:
		      func (stream, "d");
		      break;
		    case 0x00400000:
		      func (stream, "e");
		      break;
		    default:
		      func (stream, "p");
		      break;
		    }
		  break;

		case 'R':
		  switch (given & 0x60)
		    {
		    case 0:
		      break;
		    case 0x20:
		      func (stream, "p");
		      break;
		    case 0x40:
		      func (stream, "m");
		      break;
		    default:
		      func (stream, "z");
		      break;
		    }
		  break;

		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
		  {
		    int width;

		    c = arm_decode_bitfield (c, given, &value, &width);

		    switch (*c)
		      {
		      case 'R':
			if (value == 15)
			  is_unpredictable = TRUE;
			/* Fall through.  */
		      case 'r':
			if (c[1] == 'u')
			  {
			    /* Eat the 'u' character.  */
			    ++ c;

			    if (u_reg == value)
			      is_unpredictable = TRUE;
			    u_reg = value;
			  }
			func (stream, "%s", arm_regnames[value]);
			break;
		      case 'D':
			func (stream, "d%ld", value);
			break;
		      case 'Q':
			if (value & 1)
			  func (stream, "<illegal reg q%ld.5>", value >> 1);
			else
			  func (stream, "q%ld", value >> 1);
			break;
		      case 'd':
			func (stream, "%ld", value);
			value_in_comment = value;
			break;
		      case 'k':
			{
			  int from = (given & (1 << 7)) ? 32 : 16;
			  func (stream, "%ld", from - value);
			}
			break;

		      case 'f':
			if (value > 7)
			  func (stream, "#%s", arm_fp_const[value & 7]);
			else
			  func (stream, "f%ld", value);
			break;

		      case 'w':
			if (width == 2)
			  func (stream, "%s", iwmmxt_wwnames[value]);
			else
			  func (stream, "%s", iwmmxt_wwssnames[value]);
			break;

		      case 'g':
			func (stream, "%s", iwmmxt_regnames[value]);
			break;
		      case 'G':
			func (stream, "%s", iwmmxt_cregnames[value]);
			break;

		      case 'x':
			func (stream, "0x%lx", (value & 0xffffffffUL));
			break;

		      case 'c':
			switch (value)
			  {
			  case 0:
			    func (stream, "eq");
			    break;

			  case 1:
			    func (stream, "vs");
			    break;

			  case 2:
			    func (stream, "ge");
			    break;

			  case 3:
			    func (stream, "gt");
			    break;

			  default:
			    func (stream, "??");
			    break;
			  }
			break;

		      case '`':
			c++;
			if (value == 0)
			  func (stream, "%c", *c);
			break;
		      case '\'':
			c++;
			if (value == ((1ul << width) - 1))
			  func (stream, "%c", *c);
			break;
		      case '?':
			func (stream, "%c", c[(1 << width) - (int) value]);
			c += 1 << width;
			break;
		      default:
			abort ();
		      }
		    break;

		  case 'y':
		  case 'z':
		    {
		      int single = *c++ == 'y';
		      int regno;

		      switch (*c)
			{
			case '4': /* Sm pair */
			case '0': /* Sm, Dm */
			  regno = given & 0x0000000f;
			  if (single)
			    {
			      regno <<= 1;
			      regno += (given >> 5) & 1;
			    }
			  else
			    regno += ((given >> 5) & 1) << 4;
			  break;

			case '1': /* Sd, Dd */
			  regno = (given >> 12) & 0x0000000f;
			  if (single)
			    {
			      regno <<= 1;
			      regno += (given >> 22) & 1;
			    }
			  else
			    regno += ((given >> 22) & 1) << 4;
			  break;

			case '2': /* Sn, Dn */
			  regno = (given >> 16) & 0x0000000f;
			  if (single)
			    {
			      regno <<= 1;
			      regno += (given >> 7) & 1;
			    }
			  else
			    regno += ((given >> 7) & 1) << 4;
			  break;

			case '3': /* List */
			  func (stream, "{");
			  regno = (given >> 12) & 0x0000000f;
			  if (single)
			    {
			      regno <<= 1;
			      regno += (given >> 22) & 1;
			    }
			  else
			    regno += ((given >> 22) & 1) << 4;
			  break;

			default:
			  abort ();
			}

		      func (stream, "%c%d", single ? 's' : 'd', regno);

		      if (*c == '3')
			{
			  int count = given & 0xff;

			  if (single == 0)
			    count >>= 1;

			  if (--count)
			    {
			      func (stream, "-%c%d",
				    single ? 's' : 'd',
				    regno + count);
			    }

			  func (stream, "}");
			}
		      else if (*c == '4')
			func (stream, ", %c%d", single ? 's' : 'd',
			      regno + 1);
		    }
		    break;

		  case 'L':
		    switch (given & 0x00400100)
		      {
		      case 0x00000000: func (stream, "b"); break;
		      case 0x00400000: func (stream, "h"); break;
		      case 0x00000100: func (stream, "w"); break;
		      case 0x00400100: func (stream, "d"); break;
		      default:
			break;
		      }
		    break;

		  case 'Z':
		    {
		      /* given (20, 23) | given (0, 3) */
		      value = ((given >> 16) & 0xf0) | (given & 0xf);
		      func (stream, "%d", (int) value);
		    }
		    break;

		  case 'l':
		    /* This is like the 'A' operator, except that if
		       the width field "M" is zero, then the offset is
		       *not* multiplied by four.  */
		    {
		      int offset = given & 0xff;
		      int multiplier = (given & 0x00000100) ? 4 : 1;

		      func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

		      if (multiplier > 1)
			{
			  value_in_comment = offset * multiplier;
			  if (NEGATIVE_BIT_SET)
			    value_in_comment = - value_in_comment;
			}

		      if (offset)
			{
			  if (PRE_BIT_SET)
			    func (stream, ", #%s%d]%s",
				  NEGATIVE_BIT_SET ? "-" : "",
				  offset * multiplier,
				  WRITEBACK_BIT_SET ? "!" : "");
			  else
			    func (stream, "], #%s%d",
				  NEGATIVE_BIT_SET ? "-" : "",
				  offset * multiplier);
			}
		      else
			func (stream, "]");
		    }
		    break;

		  case 'r':
		    {
		      int imm4 = (given >> 4) & 0xf;
		      int puw_bits = ((given >> 22) & 6) | ((given >> W_BIT) & 1);
		      int ubit = ! NEGATIVE_BIT_SET;
		      const char *rm = arm_regnames [given & 0xf];
		      const char *rn = arm_regnames [(given >> 16) & 0xf];

		      switch (puw_bits)
			{
			case 1:
			case 3:
			  func (stream, "[%s], %c%s", rn, ubit ? '+' : '-', rm);
			  if (imm4)
			    func (stream, ", lsl #%d", imm4);
			  break;

			case 4:
			case 5:
			case 6:
			case 7:
			  func (stream, "[%s, %c%s", rn, ubit ? '+' : '-', rm);
			  if (imm4 > 0)
			    func (stream, ", lsl #%d", imm4);
			  func (stream, "]");
			  if (puw_bits == 5 || puw_bits == 7)
			    func (stream, "!");
			  break;

			default:
			  func (stream, "INVALID");
			}
		    }
		    break;

		  case 'i':
		    {
		      long imm5;
		      imm5 = ((given & 0x100) >> 4) | (given & 0xf);
		      func (stream, "%ld", (imm5 == 0) ? 32 : imm5);
		    }
		    break;

		  default:
		    abort ();
		  }
		}
	    }
	  else
	    func (stream, "%c", *c);
	}

      if (value_in_comment > 32 || value_in_comment < -16)
	func (stream, "\t; 0x%lx", (value_in_comment & 0xffffffffUL));

      if (is_unpredictable)
	func (stream, UNPREDICTABLE_INSTRUCTION);

      return TRUE;
    }
  return FALSE;
}

/* Decodes and prints ARM addressing modes.  Returns the offset
   used in the address, if any, if it is worthwhile printing the
   offset as a hexadecimal value in a comment at the end of the
   line of disassembly.  */

static signed long
print_arm_address (bfd_vma pc, struct disassemble_info *info, long given)
{
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
  bfd_vma offset = 0;

  if (((given & 0x000f0000) == 0x000f0000)
      && ((given & 0x02000000) == 0))
    {
      offset = given & 0xfff;

      func (stream, "[pc");

      if (PRE_BIT_SET)
	{
	  /* Pre-indexed.  Elide offset of positive zero when
	     non-writeback.  */
	  if (WRITEBACK_BIT_SET || NEGATIVE_BIT_SET || offset)
	    func (stream, ", #%s%d", NEGATIVE_BIT_SET ? "-" : "", (int) offset);

	  if (NEGATIVE_BIT_SET)
	    offset = -offset;

	  offset += pc + 8;

	  /* Cope with the possibility of write-back
	     being used.  Probably a very dangerous thing
	     for the programmer to do, but who are we to
	     argue ?  */
	  func (stream, "]%s", WRITEBACK_BIT_SET ? "!" : "");
	}
      else  /* Post indexed.  */
	{
	  func (stream, "], #%s%d", NEGATIVE_BIT_SET ? "-" : "", (int) offset);

	  /* Ie ignore the offset.  */
	  offset = pc + 8;
	}

      func (stream, "\t; ");
      info->print_address_func (offset, info);
      offset = 0;
    }
  else
    {
      func (stream, "[%s",
	    arm_regnames[(given >> 16) & 0xf]);

      if (PRE_BIT_SET)
	{
	  if ((given & 0x02000000) == 0)
	    {
	      /* Elide offset of positive zero when non-writeback.  */
	      offset = given & 0xfff;
	      if (WRITEBACK_BIT_SET || NEGATIVE_BIT_SET || offset)
		func (stream, ", #%s%d", NEGATIVE_BIT_SET ? "-" : "", (int) offset);
	    }
	  else
	    {
	      func (stream, ", %s", NEGATIVE_BIT_SET ? "-" : "");
	      arm_decode_shift (given, func, stream, TRUE);
	    }

	  func (stream, "]%s",
		WRITEBACK_BIT_SET ? "!" : "");
	}
      else
	{
	  if ((given & 0x02000000) == 0)
	    {
	      /* Always show offset.  */
	      offset = given & 0xfff;
	      func (stream, "], #%s%d",
		    NEGATIVE_BIT_SET ? "-" : "", (int) offset);
	    }
	  else
	    {
	      func (stream, "], %s",
		    NEGATIVE_BIT_SET ? "-" : "");
	      arm_decode_shift (given, func, stream, TRUE);
	    }
	}
    }

  return (signed long) offset;
}

/* Print one neon instruction on INFO->STREAM.
   Return TRUE if the instuction matched, FALSE if this is not a
   recognised neon instruction.  */

static bfd_boolean
print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
{
  const struct opcode32 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  if (thumb)
    {
      if ((given & 0xef000000) == 0xef000000)
	{
	  /* Move bit 28 to bit 24 to translate Thumb2 to ARM encoding.  */
	  unsigned long bit28 = given & (1 << 28);

	  given &= 0x00ffffff;
	  if (bit28)
            given |= 0xf3000000;
          else
	    given |= 0xf2000000;
	}
      else if ((given & 0xff000000) == 0xf9000000)
	given ^= 0xf9000000 ^ 0xf4000000;
      else
	return FALSE;
    }
  
  for (insn = neon_opcodes; insn->assembler; insn++)
    {
      if ((given & insn->mask) == insn->value)
	{
	  signed long value_in_comment = 0;
	  bfd_boolean is_unpredictable = FALSE;
	  const char *c;

	  for (c = insn->assembler; *c; c++)
	    {
	      if (*c == '%')
		{
		  switch (*++c)
		    {
		    case '%':
		      func (stream, "%%");
		      break;

		    case 'u':
		      if (thumb && ifthen_state)
			is_unpredictable = TRUE;

		      /* Fall through.  */
		    case 'c':
		      if (thumb && ifthen_state)
			func (stream, "%s", arm_conditional[IFTHEN_COND]);
		      break;

		    case 'A':
		      {
			static const unsigned char enc[16] = 
			{
			  0x4, 0x14, /* st4 0,1 */
			  0x4, /* st1 2 */
			  0x4, /* st2 3 */
			  0x3, /* st3 4 */
			  0x13, /* st3 5 */
			  0x3, /* st1 6 */
			  0x1, /* st1 7 */
			  0x2, /* st2 8 */
			  0x12, /* st2 9 */
			  0x2, /* st1 10 */
			  0, 0, 0, 0, 0
			};
			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
			int rn = ((given >> 16) & 0xf);
			int rm = ((given >> 0) & 0xf);
			int align = ((given >> 4) & 0x3);
			int type = ((given >> 8) & 0xf);
			int n = enc[type] & 0xf;
			int stride = (enc[type] >> 4) + 1;
			int ix;
			
			func (stream, "{");
			if (stride > 1)
			  for (ix = 0; ix != n; ix++)
			    func (stream, "%sd%d", ix ? "," : "", rd + ix * stride);
			else if (n == 1)
			  func (stream, "d%d", rd);
			else
			  func (stream, "d%d-d%d", rd, rd + n - 1);
			func (stream, "}, [%s", arm_regnames[rn]);
			if (align)
			  func (stream, " :%d", 32 << align);
			func (stream, "]");
			if (rm == 0xd)
			  func (stream, "!");
			else if (rm != 0xf)
			  func (stream, ", %s", arm_regnames[rm]);
		      }
		      break;
		      
		    case 'B':
		      {
			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
			int rn = ((given >> 16) & 0xf);
			int rm = ((given >> 0) & 0xf);
			int idx_align = ((given >> 4) & 0xf);
                        int align = 0;
			int size = ((given >> 10) & 0x3);
			int idx = idx_align >> (size + 1);
                        int length = ((given >> 8) & 3) + 1;
                        int stride = 1;
                        int i;

                        if (length > 1 && size > 0)
                          stride = (idx_align & (1 << size)) ? 2 : 1;
			
                        switch (length)
                          {
                          case 1:
                            {
                              int amask = (1 << size) - 1;
                              if ((idx_align & (1 << size)) != 0)
                                return FALSE;
                              if (size > 0)
                                {
                                  if ((idx_align & amask) == amask)
                                    align = 8 << size;
                                  else if ((idx_align & amask) != 0)
                                    return FALSE;
                                }
                              }
                            break;
                          
                          case 2:
                            if (size == 2 && (idx_align & 2) != 0)
                              return FALSE;
                            align = (idx_align & 1) ? 16 << size : 0;
                            break;
                          
                          case 3:
                            if ((size == 2 && (idx_align & 3) != 0)
                                || (idx_align & 1) != 0)
                              return FALSE;
                            break;
                          
                          case 4:
                            if (size == 2)
                              {
                                if ((idx_align & 3) == 3)
                                  return FALSE;
                                align = (idx_align & 3) * 64;
                              }
                            else
                              align = (idx_align & 1) ? 32 << size : 0;
                            break;
                          
                          default:
                            abort ();
                          }
                                
			func (stream, "{");
                        for (i = 0; i < length; i++)
                          func (stream, "%sd%d[%d]", (i == 0) ? "" : ",",
                            rd + i * stride, idx);
                        func (stream, "}, [%s", arm_regnames[rn]);
			if (align)
			  func (stream, " :%d", align);
			func (stream, "]");
			if (rm == 0xd)
			  func (stream, "!");
			else if (rm != 0xf)
			  func (stream, ", %s", arm_regnames[rm]);
		      }
		      break;
		      
		    case 'C':
		      {
			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
			int rn = ((given >> 16) & 0xf);
			int rm = ((given >> 0) & 0xf);
			int align = ((given >> 4) & 0x1);
			int size = ((given >> 6) & 0x3);
			int type = ((given >> 8) & 0x3);
			int n = type + 1;
			int stride = ((given >> 5) & 0x1);
			int ix;
			
			if (stride && (n == 1))
			  n++;
			else
			  stride++;
			
			func (stream, "{");
			if (stride > 1)
			  for (ix = 0; ix != n; ix++)
			    func (stream, "%sd%d[]", ix ? "," : "", rd + ix * stride);
			else if (n == 1)
			  func (stream, "d%d[]", rd);
			else
			  func (stream, "d%d[]-d%d[]", rd, rd + n - 1);
			func (stream, "}, [%s", arm_regnames[rn]);
			if (align)
			  {
                            align = (8 * (type + 1)) << size;
                            if (type == 3)
                              align = (size > 1) ? align >> 1 : align;
			    if (type == 2 || (type == 0 && !size))
			      func (stream, " :<bad align %d>", align);
			    else
			      func (stream, " :%d", align);
			  }
			func (stream, "]");
			if (rm == 0xd)
			  func (stream, "!");
			else if (rm != 0xf)
			  func (stream, ", %s", arm_regnames[rm]);
		      }
		      break;
		      
		    case 'D':
		      {
			int raw_reg = (given & 0xf) | ((given >> 1) & 0x10);
			int size = (given >> 20) & 3;
			int reg = raw_reg & ((4 << size) - 1);
			int ix = raw_reg >> size >> 2;
			
			func (stream, "d%d[%d]", reg, ix);
		      }
		      break;
		      
		    case 'E':
		      /* Neon encoded constant for mov, mvn, vorr, vbic.  */
		      {
			int bits = 0;
			int cmode = (given >> 8) & 0xf;
			int op = (given >> 5) & 0x1;
			unsigned long value = 0, hival = 0;
			unsigned shift;
                        int size = 0;
                        int isfloat = 0;
			
			bits |= ((given >> 24) & 1) << 7;
			bits |= ((given >> 16) & 7) << 4;
			bits |= ((given >> 0) & 15) << 0;
			
			if (cmode < 8)
			  {
			    shift = (cmode >> 1) & 3;
			    value = (unsigned long) bits << (8 * shift);
                            size = 32;
			  }
			else if (cmode < 12)
			  {
			    shift = (cmode >> 1) & 1;
			    value = (unsigned long) bits << (8 * shift);
                            size = 16;
			  }
			else if (cmode < 14)
			  {
			    shift = (cmode & 1) + 1;
			    value = (unsigned long) bits << (8 * shift);
			    value |= (1ul << (8 * shift)) - 1;
                            size = 32;
			  }
			else if (cmode == 14)
			  {
			    if (op)
			      {
				/* Bit replication into bytes.  */
				int ix;
				unsigned long mask;
				
				value = 0;
                                hival = 0;
				for (ix = 7; ix >= 0; ix--)
				  {
				    mask = ((bits >> ix) & 1) ? 0xff : 0;
                                    if (ix <= 3)
				      value = (value << 8) | mask;
                                    else
                                      hival = (hival << 8) | mask;
				  }
                                size = 64;
			      }
                            else
                              {
                                /* Byte replication.  */
                                value = (unsigned long) bits;
                                size = 8;
                              }
			  }
			else if (!op)
			  {
			    /* Floating point encoding.  */
			    int tmp;
			    
			    value = (unsigned long)  (bits & 0x7f) << 19;
			    value |= (unsigned long) (bits & 0x80) << 24;
			    tmp = bits & 0x40 ? 0x3c : 0x40;
			    value |= (unsigned long) tmp << 24;
                            size = 32;
                            isfloat = 1;
			  }
			else
			  {
			    func (stream, "<illegal constant %.8x:%x:%x>",
                                  bits, cmode, op);
                            size = 32;
			    break;
			  }
                        switch (size)
                          {
                          case 8:
			    func (stream, "#%ld\t; 0x%.2lx", value, value);
                            break;
                          
                          case 16:
                            func (stream, "#%ld\t; 0x%.4lx", value, value);
                            break;

                          case 32:
                            if (isfloat)
                              {
                                unsigned char valbytes[4];
                                double fvalue;
                                
                                /* Do this a byte at a time so we don't have to
                                   worry about the host's endianness.  */
                                valbytes[0] = value & 0xff;
                                valbytes[1] = (value >> 8) & 0xff;
                                valbytes[2] = (value >> 16) & 0xff;
                                valbytes[3] = (value >> 24) & 0xff;
                                
                                floatformat_to_double 
                                  (& floatformat_ieee_single_little, valbytes,
                                  & fvalue);
                                                                
                                func (stream, "#%.7g\t; 0x%.8lx", fvalue,
                                      value);
                              }
                            else
                              func (stream, "#%ld\t; 0x%.8lx",
				    (long) (((value & 0x80000000L) != 0) 
					    ? value | ~0xffffffffL : value),
				    value);
                            break;

                          case 64:
                            func (stream, "#0x%.8lx%.8lx", hival, value);
                            break;
                          
                          default:
                            abort ();
                          }
		      }
		      break;
		      
		    case 'F':
		      {
			int regno = ((given >> 16) & 0xf) | ((given >> (7 - 4)) & 0x10);
			int num = (given >> 8) & 0x3;
			
			if (!num)
			  func (stream, "{d%d}", regno);
			else if (num + regno >= 32)
			  func (stream, "{d%d-<overflow reg d%d}", regno, regno + num);
			else
			  func (stream, "{d%d-d%d}", regno, regno + num);
		      }
		      break;


		    case '0': case '1': case '2': case '3': case '4':
		    case '5': case '6': case '7': case '8': case '9':
		      {
			int width;
			unsigned long value;

			c = arm_decode_bitfield (c, given, &value, &width);
			
			switch (*c)
			  {
			  case 'r':
			    func (stream, "%s", arm_regnames[value]);
			    break;
			  case 'd':
			    func (stream, "%ld", value);
			    value_in_comment = value;
			    break;
			  case 'e':
			    func (stream, "%ld", (1ul << width) - value);
			    break;
			    
			  case 'S':
			  case 'T':
			  case 'U':
			    /* Various width encodings.  */
			    {
			      int base = 8 << (*c - 'S'); /* 8,16 or 32 */
			      int limit;
			      unsigned low, high;

			      c++;
			      if (*c >= '0' && *c <= '9')
				limit = *c - '0';
			      else if (*c >= 'a' && *c <= 'f')
				limit = *c - 'a' + 10;
			      else
				abort ();
			      low = limit >> 2;
			      high = limit & 3;

			      if (value < low || value > high)
				func (stream, "<illegal width %d>", base << value);
			      else
				func (stream, "%d", base << value);
			    }
			    break;
			  case 'R':
			    if (given & (1 << 6))
			      goto Q;
			    /* FALLTHROUGH */
			  case 'D':
			    func (stream, "d%ld", value);
			    break;
			  case 'Q':
			  Q:
			    if (value & 1)
			      func (stream, "<illegal reg q%ld.5>", value >> 1);
			    else
			      func (stream, "q%ld", value >> 1);
			    break;
			    
			  case '`':
			    c++;
			    if (value == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if (value == ((1ul << width) - 1))
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    func (stream, "%c", c[(1 << width) - (int) value]);
			    c += 1 << width;
			    break;
			  default:
			    abort ();
			  }
			break;

		      default:
			abort ();
		      }
		    }
		}
	      else
		func (stream, "%c", *c);
	    }

	  if (value_in_comment > 32 || value_in_comment < -16)
	    func (stream, "\t; 0x%lx", value_in_comment);

	  if (is_unpredictable)
	    func (stream, UNPREDICTABLE_INSTRUCTION);

	  return TRUE;
	}
    }
  return FALSE;
}

/* Return the name of a v7A special register.  */

static const char * 
banked_regname (unsigned reg)
{
  switch (reg)
    {
      case 15: return "CPSR";
      case 32: return "R8_usr"; 
      case 33: return "R9_usr";
      case 34: return "R10_usr";
      case 35: return "R11_usr";
      case 36: return "R12_usr";
      case 37: return "SP_usr";
      case 38: return "LR_usr";
      case 40: return "R8_fiq"; 
      case 41: return "R9_fiq";
      case 42: return "R10_fiq";
      case 43: return "R11_fiq";
      case 44: return "R12_fiq";
      case 45: return "SP_fiq";
      case 46: return "LR_fiq";
      case 48: return "LR_irq";
      case 49: return "SP_irq";
      case 50: return "LR_svc";
      case 51: return "SP_svc";
      case 52: return "LR_abt";
      case 53: return "SP_abt";
      case 54: return "LR_und";
      case 55: return "SP_und";
      case 60: return "LR_mon";
      case 61: return "SP_mon";
      case 62: return "ELR_hyp";
      case 63: return "SP_hyp";
      case 79: return "SPSR";
      case 110: return "SPSR_fiq";
      case 112: return "SPSR_irq";
      case 114: return "SPSR_svc";
      case 116: return "SPSR_abt";
      case 118: return "SPSR_und";
      case 124: return "SPSR_mon";
      case 126: return "SPSR_hyp";
      default: return NULL;
    }
}

/* Return the name of the DMB/DSB option.  */
static const char *
data_barrier_option (unsigned option)
{
  switch (option & 0xf)
    {
    case 0xf: return "sy";
    case 0xe: return "st";
    case 0xd: return "ld";
    case 0xb: return "ish";
    case 0xa: return "ishst";
    case 0x9: return "ishld";
    case 0x7: return "un";
    case 0x6: return "unst";
    case 0x5: return "nshld";
    case 0x3: return "osh";
    case 0x2: return "oshst";
    case 0x1: return "oshld";
    default:  return NULL;
    }
}

/* Print one ARM instruction from PC on INFO->STREAM.  */

static void
print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)
{
  const struct opcode32 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
  struct arm_private_data *private_data = info->private_data;

  if (print_insn_coprocessor (pc, info, given, FALSE))
    return;

  if (print_insn_neon (info, given, FALSE))
    return;

  for (insn = arm_opcodes; insn->assembler; insn++)
    {
      if ((given & insn->mask) != insn->value)
	continue;
    
      if ((insn->arch & private_data->features.core) == 0)
	continue;

      /* Special case: an instruction with all bits set in the condition field
	 (0xFnnn_nnnn) is only matched if all those bits are set in insn->mask,
	 or by the catchall at the end of the table.  */
      if ((given & 0xF0000000) != 0xF0000000
	  || (insn->mask & 0xF0000000) == 0xF0000000
	  || (insn->mask == 0 && insn->value == 0))
	{
	  unsigned long u_reg = 16;
	  unsigned long U_reg = 16;
	  bfd_boolean is_unpredictable = FALSE;
	  signed long value_in_comment = 0;
	  const char *c;

	  for (c = insn->assembler; *c; c++)
	    {
	      if (*c == '%')
		{
		  bfd_boolean allow_unpredictable = FALSE;

		  switch (*++c)
		    {
		    case '%':
		      func (stream, "%%");
		      break;

		    case 'a':
		      value_in_comment = print_arm_address (pc, info, given);
		      break;

		    case 'P':
		      /* Set P address bit and use normal address
			 printing routine.  */
		      value_in_comment = print_arm_address (pc, info, given | (1 << P_BIT));
		      break;

		    case 'S':
		      allow_unpredictable = TRUE;
		    case 's':
                      if ((given & 0x004f0000) == 0x004f0000)
			{
                          /* PC relative with immediate offset.  */
			  bfd_vma offset = ((given & 0xf00) >> 4) | (given & 0xf);

			  if (PRE_BIT_SET)
			    {
			      /* Elide positive zero offset.  */
			      if (offset || NEGATIVE_BIT_SET)
				func (stream, "[pc, #%s%d]\t; ",
				      NEGATIVE_BIT_SET ? "-" : "", (int) offset);
			      else
				func (stream, "[pc]\t; ");
			      if (NEGATIVE_BIT_SET)
				offset = -offset;
			      info->print_address_func (offset + pc + 8, info);
			    }
			  else
			    {
			      /* Always show the offset.  */
			      func (stream, "[pc], #%s%d",
				    NEGATIVE_BIT_SET ? "-" : "", (int) offset);
			      if (! allow_unpredictable)
				is_unpredictable = TRUE;
			    }
			}
		      else
			{
			  int offset = ((given & 0xf00) >> 4) | (given & 0xf);

			  func (stream, "[%s",
				arm_regnames[(given >> 16) & 0xf]);

			  if (PRE_BIT_SET)
			    {
			      if (IMMEDIATE_BIT_SET)
				{
				  /* Elide offset for non-writeback
				     positive zero.  */
				  if (WRITEBACK_BIT_SET || NEGATIVE_BIT_SET
				      || offset)
				    func (stream, ", #%s%d",
					  NEGATIVE_BIT_SET ? "-" : "", offset);

				  if (NEGATIVE_BIT_SET)
				    offset = -offset;

				  value_in_comment = offset;
				}
			      else
				{
				  /* Register Offset or Register Pre-Indexed.  */
				  func (stream, ", %s%s",
					NEGATIVE_BIT_SET ? "-" : "",
					arm_regnames[given & 0xf]);

				  /* Writing back to the register that is the source/
				     destination of the load/store is unpredictable.  */
				  if (! allow_unpredictable
				      && WRITEBACK_BIT_SET
				      && ((given & 0xf) == ((given >> 12) & 0xf)))
				    is_unpredictable = TRUE;
				}

			      func (stream, "]%s",
				    WRITEBACK_BIT_SET ? "!" : "");
			    }
			  else
			    {
			      if (IMMEDIATE_BIT_SET)
				{
				  /* Immediate Post-indexed.  */
				  /* PR 10924: Offset must be printed, even if it is zero.  */
				  func (stream, "], #%s%d",
					NEGATIVE_BIT_SET ? "-" : "", offset);
				  if (NEGATIVE_BIT_SET)
				    offset = -offset;
				  value_in_comment = offset;
				}
			      else
				{
				  /* Register Post-indexed.  */
				  func (stream, "], %s%s",
					NEGATIVE_BIT_SET ? "-" : "",
					arm_regnames[given & 0xf]);

				  /* Writing back to the register that is the source/
				     destination of the load/store is unpredictable.  */
				  if (! allow_unpredictable
				      && (given & 0xf) == ((given >> 12) & 0xf))
				    is_unpredictable = TRUE;
				}

			      if (! allow_unpredictable)
				{
				  /* Writeback is automatically implied by post- addressing.
				     Setting the W bit is unnecessary and ARM specify it as
				     being unpredictable.  */
				  if (WRITEBACK_BIT_SET
				      /* Specifying the PC register as the post-indexed
					 registers is also unpredictable.  */
				      || (! IMMEDIATE_BIT_SET && ((given & 0xf) == 0xf)))
				    is_unpredictable = TRUE;
				}
			    }
			}
		      break;

		    case 'b':
		      {
			bfd_vma disp = (((given & 0xffffff) ^ 0x800000) - 0x800000);
			info->print_address_func (disp * 4 + pc + 8, info);
		      }
		      break;

		    case 'c':
		      if (((given >> 28) & 0xf) != 0xe)
			func (stream, "%s",
			      arm_conditional [(given >> 28) & 0xf]);
		      break;

		    case 'm':
		      {
			int started = 0;
			int reg;

			func (stream, "{");
			for (reg = 0; reg < 16; reg++)
			  if ((given & (1 << reg)) != 0)
			    {
			      if (started)
				func (stream, ", ");
			      started = 1;
			      func (stream, "%s", arm_regnames[reg]);
			    }
			func (stream, "}");
			if (! started)
			  is_unpredictable = TRUE;
		      }
		      break;

		    case 'q':
		      arm_decode_shift (given, func, stream, FALSE);
		      break;

		    case 'o':
		      if ((given & 0x02000000) != 0)
			{
			  unsigned int rotate = (given & 0xf00) >> 7;
			  unsigned int immed = (given & 0xff);
			  unsigned int a, i;

			  a = (((immed << (32 - rotate))
				| (immed >> rotate)) & 0xffffffff);
			  /* If there is another encoding with smaller rotate,
			     the rotate should be specified directly.  */
			  for (i = 0; i < 32; i += 2)
			    if ((a << i | a >> (32 - i)) <= 0xff)
			      break;

			  if (i != rotate)
			    func (stream, "#%d, %d", immed, rotate);
			  else
			    func (stream, "#%d", a);
			  value_in_comment = a;
			}
		      else
			arm_decode_shift (given, func, stream, TRUE);
		      break;

		    case 'p':
		      if ((given & 0x0000f000) == 0x0000f000)
			{
			  /* The p-variants of tst/cmp/cmn/teq are the pre-V6
			     mechanism for setting PSR flag bits.  They are
			     obsolete in V6 onwards.  */
			  if ((private_data->features.core & ARM_EXT_V6) == 0)
			    func (stream, "p");
			}
		      break;

		    case 't':
		      if ((given & 0x01200000) == 0x00200000)
			func (stream, "t");
		      break;

		    case 'A':
		      {
			int offset = given & 0xff;

			value_in_comment = offset * 4;
			if (NEGATIVE_BIT_SET)
			  value_in_comment = - value_in_comment;

			func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

			if (PRE_BIT_SET)
			  {
			    if (offset)
			      func (stream, ", #%d]%s",
				    (int) value_in_comment,
				    WRITEBACK_BIT_SET ? "!" : "");
			    else
			      func (stream, "]");
			  }
			else
			  {
			    func (stream, "]");

			    if (WRITEBACK_BIT_SET)
			      {
				if (offset)
				  func (stream, ", #%d", (int) value_in_comment);
			      }
			    else
			      {
				func (stream, ", {%d}", (int) offset);
				value_in_comment = offset;
			      }
			  }
		      }
		      break;

		    case 'B':
		      /* Print ARM V5 BLX(1) address: pc+25 bits.  */
		      {
			bfd_vma address;
			bfd_vma offset = 0;

			if (! NEGATIVE_BIT_SET)
			  /* Is signed, hi bits should be ones.  */
			  offset = (-1) ^ 0x00ffffff;

			/* Offset is (SignExtend(offset field)<<2).  */
			offset += given & 0x00ffffff;
			offset <<= 2;
			address = offset + pc + 8;

			if (given & 0x01000000)
			  /* H bit allows addressing to 2-byte boundaries.  */
			  address += 2;

		        info->print_address_func (address, info);
		      }
		      break;

		    case 'C':
		      if ((given & 0x02000200) == 0x200)
			{
			  const char * name;
			  unsigned sysm = (given & 0x004f0000) >> 16;

			  sysm |= (given & 0x300) >> 4;
			  name = banked_regname (sysm);

			  if (name != NULL)
			    func (stream, "%s", name);
			  else
			    func (stream, "(UNDEF: %lu)", (unsigned long) sysm);
			}
		      else
			{
			  func (stream, "%cPSR_", 
				(given & 0x00400000) ? 'S' : 'C');
			  if (given & 0x80000)
			    func (stream, "f");
			  if (given & 0x40000)
			    func (stream, "s");
			  if (given & 0x20000)
			    func (stream, "x");
			  if (given & 0x10000)
			    func (stream, "c");
			}
		      break;

		    case 'U':
		      if ((given & 0xf0) == 0x60) 
			{
			  switch (given & 0xf)
			    {
			    case 0xf: func (stream, "sy"); break;
			    default:
			      func (stream, "#%d", (int) given & 0xf);
			      break;
			    }
			} 
		      else 
			{
			  const char * opt = data_barrier_option (given & 0xf);
			  if (opt != NULL)
			    func (stream, "%s", opt);
			  else
			      func (stream, "#%d", (int) given & 0xf);
			}
		      break;

		    case '0': case '1': case '2': case '3': case '4':
		    case '5': case '6': case '7': case '8': case '9':
		      {
			int width;
			unsigned long value;

			c = arm_decode_bitfield (c, given, &value, &width);
			
			switch (*c)
			  {
			  case 'R':
			    if (value == 15)
			      is_unpredictable = TRUE;
			    /* Fall through.  */
			  case 'r':
			  case 'T':
			    /* We want register + 1 when decoding T.  */
			    if (*c == 'T')
			      ++value;

			    if (c[1] == 'u')
			      {
				/* Eat the 'u' character.  */
				++ c;

				if (u_reg == value)
				  is_unpredictable = TRUE;
				u_reg = value;
			      }
			    if (c[1] == 'U')
			      {
				/* Eat the 'U' character.  */
				++ c;

				if (U_reg == value)
				  is_unpredictable = TRUE;
				U_reg = value;
			      }
			    func (stream, "%s", arm_regnames[value]);
			    break;
			  case 'd':
			    func (stream, "%ld", value);
			    value_in_comment = value;
			    break;
			  case 'b':
			    func (stream, "%ld", value * 8);
			    value_in_comment = value * 8;
			    break;
			  case 'W':
			    func (stream, "%ld", value + 1);
			    value_in_comment = value + 1;
			    break;
			  case 'x':
			    func (stream, "0x%08lx", value);

			    /* Some SWI instructions have special
			       meanings.  */
			    if ((given & 0x0fffffff) == 0x0FF00000)
			      func (stream, "\t; IMB");
			    else if ((given & 0x0fffffff) == 0x0FF00001)
			      func (stream, "\t; IMBRange");
			    break;
			  case 'X':
			    func (stream, "%01lx", value & 0xf);
			    value_in_comment = value;
			    break;
			  case '`':
			    c++;
			    if (value == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if (value == ((1ul << width) - 1))
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    func (stream, "%c", c[(1 << width) - (int) value]);
			    c += 1 << width;
			    break;
			  default:
			    abort ();
			  }
			break;

		      case 'e':
			{
			  int imm;

			  imm = (given & 0xf) | ((given & 0xfff00) >> 4);
			  func (stream, "%d", imm);
			  value_in_comment = imm;
			}
			break;

		      case 'E':
			/* LSB and WIDTH fields of BFI or BFC.  The machine-
			   language instruction encodes LSB and MSB.  */
			{
			  long msb = (given & 0x001f0000) >> 16;
			  long lsb = (given & 0x00000f80) >> 7;
			  long w = msb - lsb + 1;

			  if (w > 0)
			    func (stream, "#%lu, #%lu", lsb, w);
			  else
			    func (stream, "(invalid: %lu:%lu)", lsb, msb);
			}
			break;

		      case 'R':
			/* Get the PSR/banked register name.  */
			{
			  const char * name;
			  unsigned sysm = (given & 0x004f0000) >> 16;

			  sysm |= (given & 0x300) >> 4;
			  name = banked_regname (sysm);

			  if (name != NULL)
			    func (stream, "%s", name);
			  else
			    func (stream, "(UNDEF: %lu)", (unsigned long) sysm);
			}
			break;

		      case 'V':
			/* 16-bit unsigned immediate from a MOVT or MOVW
			   instruction, encoded in bits 0:11 and 15:19.  */
			{
			  long hi = (given & 0x000f0000) >> 4;
			  long lo = (given & 0x00000fff);
			  long imm16 = hi | lo;

			  func (stream, "#%lu", imm16);
			  value_in_comment = imm16;
			}
			break;

		      default:
			abort ();
		      }
		    }
		}
	      else
		func (stream, "%c", *c);
	    }

	  if (value_in_comment > 32 || value_in_comment < -16)
	    func (stream, "\t; 0x%lx", (value_in_comment & 0xffffffffUL));

	  if (is_unpredictable)
	    func (stream, UNPREDICTABLE_INSTRUCTION);

	  return;
	}
    }
  abort ();
}

/* Print one 16-bit Thumb instruction from PC on INFO->STREAM.  */

static void
print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long given)
{
  const struct opcode16 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  for (insn = thumb_opcodes; insn->assembler; insn++)
    if ((given & insn->mask) == insn->value)
      {
	signed long value_in_comment = 0;
	const char *c = insn->assembler;

	for (; *c; c++)
	  {
	    int domaskpc = 0;
	    int domasklr = 0;

	    if (*c != '%')
	      {
		func (stream, "%c", *c);
		continue;
	      }

	    switch (*++c)
	      {
	      case '%':
		func (stream, "%%");
		break;

	      case 'c':
		if (ifthen_state)
		  func (stream, "%s", arm_conditional[IFTHEN_COND]);
		break;

	      case 'C':
		if (ifthen_state)
		  func (stream, "%s", arm_conditional[IFTHEN_COND]);
		else
		  func (stream, "s");
		break;

	      case 'I':
		{
		  unsigned int tmp;

		  ifthen_next_state = given & 0xff;
		  for (tmp = given << 1; tmp & 0xf; tmp <<= 1)
		    func (stream, ((given ^ tmp) & 0x10) ? "e" : "t");
		  func (stream, "\t%s", arm_conditional[(given >> 4) & 0xf]);
		}
		break;

	      case 'x':
		if (ifthen_next_state)
		  func (stream, "\t; unpredictable branch in IT block\n");
		break;

	      case 'X':
		if (ifthen_state)
		  func (stream, "\t; unpredictable <IT:%s>",
			arm_conditional[IFTHEN_COND]);
		break;

	      case 'S':
		{
		  long reg;

		  reg = (given >> 3) & 0x7;
		  if (given & (1 << 6))
		    reg += 8;

		  func (stream, "%s", arm_regnames[reg]);
		}
		break;

	      case 'D':
		{
		  long reg;

		  reg = given & 0x7;
		  if (given & (1 << 7))
		    reg += 8;

		  func (stream, "%s", arm_regnames[reg]);
		}
		break;

	      case 'N':
		if (given & (1 << 8))
		  domasklr = 1;
		/* Fall through.  */
	      case 'O':
		if (*c == 'O' && (given & (1 << 8)))
		  domaskpc = 1;
		/* Fall through.  */
	      case 'M':
		{
		  int started = 0;
		  int reg;

		  func (stream, "{");

		  /* It would be nice if we could spot
		     ranges, and generate the rS-rE format: */
		  for (reg = 0; (reg < 8); reg++)
		    if ((given & (1 << reg)) != 0)
		      {
			if (started)
			  func (stream, ", ");
			started = 1;
			func (stream, "%s", arm_regnames[reg]);
		      }

		  if (domasklr)
		    {
		      if (started)
			func (stream, ", ");
		      started = 1;
		      func (stream, "%s", arm_regnames[14] /* "lr" */);
		    }

		  if (domaskpc)
		    {
		      if (started)
			func (stream, ", ");
		      func (stream, "%s", arm_regnames[15] /* "pc" */);
		    }

		  func (stream, "}");
		}
		break;

	      case 'W':
		/* Print writeback indicator for a LDMIA.  We are doing a
		   writeback if the base register is not in the register
		   mask.  */
		if ((given & (1 << ((given & 0x0700) >> 8))) == 0)
		  func (stream, "!");
	      	break;

	      case 'b':
		/* Print ARM V6T2 CZB address: pc+4+6 bits.  */
		{
		  bfd_vma address = (pc + 4
				     + ((given & 0x00f8) >> 2)
				     + ((given & 0x0200) >> 3));
		  info->print_address_func (address, info);
		}
		break;

	      case 's':
		/* Right shift immediate -- bits 6..10; 1-31 print
		   as themselves, 0 prints as 32.  */
		{
		  long imm = (given & 0x07c0) >> 6;
		  if (imm == 0)
		    imm = 32;
		  func (stream, "#%ld", imm);
		}
		break;

	      case '0': case '1': case '2': case '3': case '4':
	      case '5': case '6': case '7': case '8': case '9':
		{
		  int bitstart = *c++ - '0';
		  int bitend = 0;

		  while (*c >= '0' && *c <= '9')
		    bitstart = (bitstart * 10) + *c++ - '0';

		  switch (*c)
		    {
		    case '-':
		      {
			bfd_vma reg;

			c++;
			while (*c >= '0' && *c <= '9')
			  bitend = (bitend * 10) + *c++ - '0';
			if (!bitend)
			  abort ();
			reg = given >> bitstart;
			reg &= (2 << (bitend - bitstart)) - 1;

			switch (*c)
			  {
			  case 'r':
			    func (stream, "%s", arm_regnames[reg]);
			    break;

			  case 'd':
			    func (stream, "%ld", (long) reg);
			    value_in_comment = reg;
			    break;

			  case 'H':
			    func (stream, "%ld", (long) (reg << 1));
			    value_in_comment = reg << 1;
			    break;

			  case 'W':
			    func (stream, "%ld", (long) (reg << 2));
			    value_in_comment = reg << 2;
			    break;

			  case 'a':
			    /* PC-relative address -- the bottom two
			       bits of the address are dropped
			       before the calculation.  */
			    info->print_address_func
			      (((pc + 4) & ~3) + (reg << 2), info);
			    value_in_comment = 0;
			    break;

			  case 'x':
			    func (stream, "0x%04lx", (long) reg);
			    break;

			  case 'B':
			    reg = ((reg ^ (1 << bitend)) - (1 << bitend));
			    info->print_address_func (reg * 2 + pc + 4, info);
			    value_in_comment = 0;
			    break;

			  case 'c':
			    func (stream, "%s", arm_conditional [reg]);
			    break;

			  default:
			    abort ();
			  }
		      }
		      break;

		    case '\'':
		      c++;
		      if ((given & (1 << bitstart)) != 0)
			func (stream, "%c", *c);
		      break;

		    case '?':
		      ++c;
		      if ((given & (1 << bitstart)) != 0)
			func (stream, "%c", *c++);
		      else
			func (stream, "%c", *++c);
		      break;

		    default:
		      abort ();
		    }
		}
		break;

	      default:
		abort ();
	      }
	  }

	if (value_in_comment > 32 || value_in_comment < -16)
	  func (stream, "\t; 0x%lx", value_in_comment);
	return;
      }

  /* No match.  */
  abort ();
}

/* Return the name of an V7M special register.  */

static const char *
psr_name (int regno)
{
  switch (regno)
    {
    case 0: return "APSR";
    case 1: return "IAPSR";
    case 2: return "EAPSR";
    case 3: return "PSR";
    case 5: return "IPSR";
    case 6: return "EPSR";
    case 7: return "IEPSR";
    case 8: return "MSP";
    case 9: return "PSP";
    case 16: return "PRIMASK";
    case 17: return "BASEPRI";
    case 18: return "BASEPRI_MAX";
    case 19: return "FAULTMASK";
    case 20: return "CONTROL";
    default: return "<unknown>";
    }
}

/* Print one 32-bit Thumb instruction from PC on INFO->STREAM.  */

static void
print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)
{
  const struct opcode32 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  if (print_insn_coprocessor (pc, info, given, TRUE))
    return;

  if (print_insn_neon (info, given, TRUE))
    return;

  for (insn = thumb32_opcodes; insn->assembler; insn++)
    if ((given & insn->mask) == insn->value)
      {
	bfd_boolean is_unpredictable = FALSE;
	signed long value_in_comment = 0;
	const char *c = insn->assembler;

	for (; *c; c++)
	  {
	    if (*c != '%')
	      {
		func (stream, "%c", *c);
		continue;
	      }

	    switch (*++c)
	      {
	      case '%':
		func (stream, "%%");
		break;

	      case 'c':
		if (ifthen_state)
		  func (stream, "%s", arm_conditional[IFTHEN_COND]);
		break;

	      case 'x':
		if (ifthen_next_state)
		  func (stream, "\t; unpredictable branch in IT block\n");
		break;

	      case 'X':
		if (ifthen_state)
		  func (stream, "\t; unpredictable <IT:%s>",
			arm_conditional[IFTHEN_COND]);
		break;

	      case 'I':
		{
		  unsigned int imm12 = 0;

		  imm12 |= (given & 0x000000ffu);
		  imm12 |= (given & 0x00007000u) >> 4;
		  imm12 |= (given & 0x04000000u) >> 15;
		  func (stream, "#%u", imm12);
		  value_in_comment = imm12;
		}
		break;

	      case 'M':
		{
		  unsigned int bits = 0, imm, imm8, mod;

		  bits |= (given & 0x000000ffu);
		  bits |= (given & 0x00007000u) >> 4;
		  bits |= (given & 0x04000000u) >> 15;
		  imm8 = (bits & 0x0ff);
		  mod = (bits & 0xf00) >> 8;
		  switch (mod)
		    {
		    case 0: imm = imm8; break;
		    case 1: imm = ((imm8 << 16) | imm8); break;
		    case 2: imm = ((imm8 << 24) | (imm8 << 8)); break;
		    case 3: imm = ((imm8 << 24) | (imm8 << 16) | (imm8 << 8) | imm8); break;
		    default:
		      mod  = (bits & 0xf80) >> 7;
		      imm8 = (bits & 0x07f) | 0x80;
		      imm  = (((imm8 << (32 - mod)) | (imm8 >> mod)) & 0xffffffff);
		    }
		  func (stream, "#%u", imm);
		  value_in_comment = imm;
		}
		break;
		  
	      case 'J':
		{
		  unsigned int imm = 0;

		  imm |= (given & 0x000000ffu);
		  imm |= (given & 0x00007000u) >> 4;
		  imm |= (given & 0x04000000u) >> 15;
		  imm |= (given & 0x000f0000u) >> 4;
		  func (stream, "#%u", imm);
		  value_in_comment = imm;
		}
		break;

	      case 'K':
		{
		  unsigned int imm = 0;

		  imm |= (given & 0x000f0000u) >> 16;
		  imm |= (given & 0x00000ff0u) >> 0;
		  imm |= (given & 0x0000000fu) << 12;
		  func (stream, "#%u", imm);
		  value_in_comment = imm;
		}
		break;

	      case 'H':
		{
		  unsigned int imm = 0;

		  imm |= (given & 0x000f0000u) >> 4;
		  imm |= (given & 0x00000fffu) >> 0;
		  func (stream, "#%u", imm);
		  value_in_comment = imm;
		}
		break;

	      case 'V':
		{
		  unsigned int imm = 0;

		  imm |= (given & 0x00000fffu);
		  imm |= (given & 0x000f0000u) >> 4;
		  func (stream, "#%u", imm);
		  value_in_comment = imm;
		}
		break;

	      case 'S':
		{
		  unsigned int reg = (given & 0x0000000fu);
		  unsigned int stp = (given & 0x00000030u) >> 4;
		  unsigned int imm = 0;
		  imm |= (given & 0x000000c0u) >> 6;
		  imm |= (given & 0x00007000u) >> 10;

		  func (stream, "%s", arm_regnames[reg]);
		  switch (stp)
		    {
		    case 0:
		      if (imm > 0)
			func (stream, ", lsl #%u", imm);
		      break;

		    case 1:
		      if (imm == 0)
			imm = 32;
		      func (stream, ", lsr #%u", imm);
		      break;

		    case 2:
		      if (imm == 0)
			imm = 32;
		      func (stream, ", asr #%u", imm);
		      break;

		    case 3:
		      if (imm == 0)
			func (stream, ", rrx");
		      else
			func (stream, ", ror #%u", imm);
		    }
		}
		break;

	      case 'a':
		{
		  unsigned int Rn  = (given & 0x000f0000) >> 16;
		  unsigned int U   = ! NEGATIVE_BIT_SET;
		  unsigned int op  = (given & 0x00000f00) >> 8;
		  unsigned int i12 = (given & 0x00000fff);
		  unsigned int i8  = (given & 0x000000ff);
		  bfd_boolean writeback = FALSE, postind = FALSE;
		  bfd_vma offset = 0;

		  func (stream, "[%s", arm_regnames[Rn]);
		  if (U) /* 12-bit positive immediate offset.  */
		    {
		      offset = i12;
		      if (Rn != 15)
			value_in_comment = offset;
		    }
		  else if (Rn == 15) /* 12-bit negative immediate offset.  */
		    offset = - (int) i12;
		  else if (op == 0x0) /* Shifted register offset.  */
		    {
		      unsigned int Rm = (i8 & 0x0f);
		      unsigned int sh = (i8 & 0x30) >> 4;

		      func (stream, ", %s", arm_regnames[Rm]);
		      if (sh)
			func (stream, ", lsl #%u", sh);
		      func (stream, "]");
		      break;
		    }
		  else switch (op)
		    {
		    case 0xE:  /* 8-bit positive immediate offset.  */
		      offset = i8;
		      break;

		    case 0xC:  /* 8-bit negative immediate offset.  */
		      offset = -i8;
		      break;

		    case 0xF:  /* 8-bit + preindex with wb.  */
		      offset = i8;
		      writeback = TRUE;
		      break;

		    case 0xD:  /* 8-bit - preindex with wb.  */
		      offset = -i8;
		      writeback = TRUE;
		      break;

		    case 0xB:  /* 8-bit + postindex.  */
		      offset = i8;
		      postind = TRUE;
		      break;

		    case 0x9:  /* 8-bit - postindex.  */
		      offset = -i8;
		      postind = TRUE;
		      break;

		    default:
		      func (stream, ", <undefined>]");
		      goto skip;
		    }

		  if (postind)
		    func (stream, "], #%d", (int) offset);
		  else
		    {
		      if (offset)
			func (stream, ", #%d", (int) offset);
		      func (stream, writeback ? "]!" : "]");
		    }

		  if (Rn == 15)
		    {
		      func (stream, "\t; ");
		      info->print_address_func (((pc + 4) & ~3) + offset, info);
		    }
		}
	      skip:
		break;

	      case 'A':
		{
		  unsigned int U   = ! NEGATIVE_BIT_SET;
		  unsigned int W   = WRITEBACK_BIT_SET;
		  unsigned int Rn  = (given & 0x000f0000) >> 16;
		  unsigned int off = (given & 0x000000ff);

		  func (stream, "[%s", arm_regnames[Rn]);

		  if (PRE_BIT_SET)
		    {
		      if (off || !U)
			{
			  func (stream, ", #%c%u", U ? '+' : '-', off * 4);
			  value_in_comment = off * 4 * U ? 1 : -1;
			}
		      func (stream, "]");
		      if (W)
			func (stream, "!");
		    }
		  else
		    {
		      func (stream, "], ");
		      if (W)
			{
			  func (stream, "#%c%u", U ? '+' : '-', off * 4);
			  value_in_comment = off * 4 * U ? 1 : -1;
			}
		      else
			{
			  func (stream, "{%u}", off);
			  value_in_comment = off;
			}
		    }
		}
		break;

	      case 'w':
		{
		  unsigned int Sbit = (given & 0x01000000) >> 24;
		  unsigned int type = (given & 0x00600000) >> 21;

		  switch (type)
		    {
		    case 0: func (stream, Sbit ? "sb" : "b"); break;
		    case 1: func (stream, Sbit ? "sh" : "h"); break;
		    case 2:
		      if (Sbit)
			func (stream, "??");
		      break;
		    case 3:
		      func (stream, "??");
		      break;
		    }
		}
		break;

	      case 'm':
		{
		  int started = 0;
		  int reg;

		  func (stream, "{");
		  for (reg = 0; reg < 16; reg++)
		    if ((given & (1 << reg)) != 0)
		      {
			if (started)
			  func (stream, ", ");
			started = 1;
			func (stream, "%s", arm_regnames[reg]);
		      }
		  func (stream, "}");
		}
		break;

	      case 'E':
		{
		  unsigned int msb = (given & 0x0000001f);
		  unsigned int lsb = 0;

		  lsb |= (given & 0x000000c0u) >> 6;
		  lsb |= (given & 0x00007000u) >> 10;
		  func (stream, "#%u, #%u", lsb, msb - lsb + 1);
		}
		break;

	      case 'F':
		{
		  unsigned int width = (given & 0x0000001f) + 1;
		  unsigned int lsb = 0;

		  lsb |= (given & 0x000000c0u) >> 6;
		  lsb |= (given & 0x00007000u) >> 10;
		  func (stream, "#%u, #%u", lsb, width);
		}
		break;

	      case 'b':
		{
		  unsigned int S = (given & 0x04000000u) >> 26;
		  unsigned int J1 = (given & 0x00002000u) >> 13;
		  unsigned int J2 = (given & 0x00000800u) >> 11;
		  bfd_vma offset = 0;

		  offset |= !S << 20;
		  offset |= J2 << 19;
		  offset |= J1 << 18;
		  offset |= (given & 0x003f0000) >> 4;
		  offset |= (given & 0x000007ff) << 1;
		  offset -= (1 << 20);

		  info->print_address_func (pc + 4 + offset, info);
		}
		break;

	      case 'B':
		{
		  unsigned int S = (given & 0x04000000u) >> 26;
		  unsigned int I1 = (given & 0x00002000u) >> 13;
		  unsigned int I2 = (given & 0x00000800u) >> 11;
		  bfd_vma offset = 0;

		  offset |= !S << 24;
		  offset |= !(I1 ^ S) << 23;
		  offset |= !(I2 ^ S) << 22;
		  offset |= (given & 0x03ff0000u) >> 4;
		  offset |= (given & 0x000007ffu) << 1;
		  offset -= (1 << 24);
		  offset += pc + 4;

		  /* BLX target addresses are always word aligned.  */
		  if ((given & 0x00001000u) == 0)
		      offset &= ~2u;

		  info->print_address_func (offset, info);
		}
		break;

	      case 's':
		{
		  unsigned int shift = 0;

		  shift |= (given & 0x000000c0u) >> 6;
		  shift |= (given & 0x00007000u) >> 10;
		  if (WRITEBACK_BIT_SET)
		    func (stream, ", asr #%u", shift);
		  else if (shift)
		    func (stream, ", lsl #%u", shift);
		  /* else print nothing - lsl #0 */
		}
		break;

	      case 'R':
		{
		  unsigned int rot = (given & 0x00000030) >> 4;

		  if (rot)
		    func (stream, ", ror #%u", rot * 8);
		}
		break;

	      case 'U':
		if ((given & 0xf0) == 0x60) 
		  {
		    switch (given & 0xf)
		      {
			case 0xf: func (stream, "sy"); break;
			default:
			  func (stream, "#%d", (int) given & 0xf);
			      break;
		      }
		  }
		else 
		  {
		    const char * opt = data_barrier_option (given & 0xf);
		    if (opt != NULL)
		      func (stream, "%s", opt);
		    else
		      func (stream, "#%d", (int) given & 0xf);
		   }
		break;

	      case 'C':
		if ((given & 0xff) == 0)
		  {
		    func (stream, "%cPSR_", (given & 0x100000) ? 'S' : 'C');
		    if (given & 0x800)
		      func (stream, "f");
		    if (given & 0x400)
		      func (stream, "s");
		    if (given & 0x200)
		      func (stream, "x");
		    if (given & 0x100)
		      func (stream, "c");
		  }
		else if ((given & 0x20) == 0x20)
		  {
		    char const* name;
		    unsigned sysm = (given & 0xf00) >> 8;

		    sysm |= (given & 0x30);
		    sysm |= (given & 0x00100000) >> 14;
		    name = banked_regname (sysm);
		    
		    if (name != NULL)
		      func (stream, "%s", name);
		    else
		      func (stream, "(UNDEF: %lu)", (unsigned long) sysm);
		  }
		else
		  {
		    func (stream, "%s", psr_name (given & 0xff));
		  }
		break;

	      case 'D':
		if (((given & 0xff) == 0)
		    || ((given & 0x20) == 0x20))
		  {
		    char const* name;
		    unsigned sm = (given & 0xf0000) >> 16;

		    sm |= (given & 0x30);
		    sm |= (given & 0x00100000) >> 14;
		    name = banked_regname (sm);

		    if (name != NULL)
		      func (stream, "%s", name);
		    else
		      func (stream, "(UNDEF: %lu)", (unsigned long) sm);
		  }
		else
		  func (stream, "%s", psr_name (given & 0xff));
		break;

	      case '0': case '1': case '2': case '3': case '4':
	      case '5': case '6': case '7': case '8': case '9':
		{
		  int width;
		  unsigned long val;

		  c = arm_decode_bitfield (c, given, &val, &width);
			
		  switch (*c)
		    {
		    case 'd':
		      func (stream, "%lu", val);
		      value_in_comment = val;
		      break;

		    case 'W':
		      func (stream, "%lu", val * 4);
		      value_in_comment = val * 4;
		      break;

		    case 'S':
		      if (val == 13)
			is_unpredictable = TRUE;
		      /* Fall through.  */
		    case 'R':
		      if (val == 15)
			is_unpredictable = TRUE;
		      /* Fall through.  */
		    case 'r':
		      func (stream, "%s", arm_regnames[val]);
		      break;

		    case 'c':
		      func (stream, "%s", arm_conditional[val]);
		      break;

		    case '\'':
		      c++;
		      if (val == ((1ul << width) - 1))
			func (stream, "%c", *c);
		      break;
		      
		    case '`':
		      c++;
		      if (val == 0)
			func (stream, "%c", *c);
		      break;

		    case '?':
		      func (stream, "%c", c[(1 << width) - (int) val]);
		      c += 1 << width;
		      break;
		      
		    case 'x':
		      func (stream, "0x%lx", val & 0xffffffffUL);
		      break;

		    default:
		      abort ();
		    }
		}
		break;

	      case 'L':
		/* PR binutils/12534
		   If we have a PC relative offset in an LDRD or STRD
		   instructions then display the decoded address.  */
		if (((given >> 16) & 0xf) == 0xf)
		  {
		    bfd_vma offset = (given & 0xff) * 4;

		    if ((given & (1 << 23)) == 0)
		      offset = - offset;
		    func (stream, "\t; ");
		    info->print_address_func ((pc & ~3) + 4 + offset, info);
		  }
		break;

	      default:
		abort ();
	      }
	  }

	if (value_in_comment > 32 || value_in_comment < -16)
	  func (stream, "\t; 0x%lx", value_in_comment);

	if (is_unpredictable)
	  func (stream, UNPREDICTABLE_INSTRUCTION);

	return;
      }

  /* No match.  */
  abort ();
}

/* Print data bytes on INFO->STREAM.  */

static void
print_insn_data (bfd_vma pc ATTRIBUTE_UNUSED,
		 struct disassemble_info *info,
		 long given)
{
  switch (info->bytes_per_chunk)
    {
    case 1:
      info->fprintf_func (info->stream, ".byte\t0x%02lx", given);
      break;
    case 2:
      info->fprintf_func (info->stream, ".short\t0x%04lx", given);
      break;
    case 4:
      info->fprintf_func (info->stream, ".word\t0x%08lx", given);
      break;
    default:
      abort ();
    }
}

/* Disallow mapping symbols ($a, $b, $d, $t etc) from
   being displayed in symbol relative addresses.  */

bfd_boolean
arm_symbol_is_valid (asymbol * sym,
		     struct disassemble_info * info ATTRIBUTE_UNUSED)
{
  const char * name;
  
  if (sym == NULL)
    return FALSE;

  name = bfd_asymbol_name (sym);

  return (name && *name != '$');
}

/* Parse an individual disassembler option.  */

void
parse_arm_disassembler_option (char *option)
{
  if (option == NULL)
    return;

  if (CONST_STRNEQ (option, "reg-names-"))
    {
      int i;

      option += 10;

      for (i = NUM_ARM_REGNAMES; i--;)
	if (strneq (option, regnames[i].name, strlen (regnames[i].name)))
	  {
	    regname_selected = i;
	    break;
	  }

      if (i < 0)
	/* XXX - should break 'option' at following delimiter.  */
	fprintf (stderr, _("Unrecognised register name set: %s\n"), option);
    }
  else if (CONST_STRNEQ (option, "force-thumb"))
    force_thumb = 1;
  else if (CONST_STRNEQ (option, "no-force-thumb"))
    force_thumb = 0;
  else
    /* XXX - should break 'option' at following delimiter.  */
    fprintf (stderr, _("Unrecognised disassembler option: %s\n"), option);

  return;
}

/* Parse the string of disassembler options, spliting it at whitespaces
   or commas.  (Whitespace separators supported for backwards compatibility).  */

static void
parse_disassembler_options (char *options)
{
  if (options == NULL)
    return;

  while (*options)
    {
      parse_arm_disassembler_option (options);

      /* Skip forward to next seperator.  */
      while ((*options) && (! ISSPACE (*options)) && (*options != ','))
	++ options;
      /* Skip forward past seperators.  */
      while (ISSPACE (*options) || (*options == ','))
	++ options;      
    }
}

/* Search back through the insn stream to determine if this instruction is
   conditionally executed.  */

static void
find_ifthen_state (bfd_vma pc,
		   struct disassemble_info *info,
		   bfd_boolean little)
{
  unsigned char b[2];
  unsigned int insn;
  int status;
  /* COUNT is twice the number of instructions seen.  It will be odd if we
     just crossed an instruction boundary.  */
  int count;
  int it_count;
  unsigned int seen_it;
  bfd_vma addr;

  ifthen_address = pc;
  ifthen_state = 0;

  addr = pc;
  count = 1;
  it_count = 0;
  seen_it = 0;
  /* Scan backwards looking for IT instructions, keeping track of where
     instruction boundaries are.  We don't know if something is actually an
     IT instruction until we find a definite instruction boundary.  */
  for (;;)
    {
      if (addr == 0 || info->symbol_at_address_func (addr, info))
	{
	  /* A symbol must be on an instruction boundary, and will not
	     be within an IT block.  */
	  if (seen_it && (count & 1))
	    break;

	  return;
	}
      addr -= 2;
      status = info->read_memory_func (addr, (bfd_byte *) b, 2, info);
      if (status)
	return;

      if (little)
	insn = (b[0]) | (b[1] << 8);
      else
	insn = (b[1]) | (b[0] << 8);
      if (seen_it)
	{
	  if ((insn & 0xf800) < 0xe800)
	    {
	      /* Addr + 2 is an instruction boundary.  See if this matches
	         the expected boundary based on the position of the last
		 IT candidate.  */
	      if (count & 1)
		break;
	      seen_it = 0;
	    }
	}
      if ((insn & 0xff00) == 0xbf00 && (insn & 0xf) != 0)
	{
	  /* This could be an IT instruction.  */
	  seen_it = insn;
	  it_count = count >> 1;
	}
      if ((insn & 0xf800) >= 0xe800)
	count++;
      else
	count = (count + 2) | 1;
      /* IT blocks contain at most 4 instructions.  */
      if (count >= 8 && !seen_it)
	return;
    }
  /* We found an IT instruction.  */
  ifthen_state = (seen_it & 0xe0) | ((seen_it << it_count) & 0x1f);
  if ((ifthen_state & 0xf) == 0)
    ifthen_state = 0;
}

/* Returns nonzero and sets *MAP_TYPE if the N'th symbol is a
   mapping symbol.  */

static int
is_mapping_symbol (struct disassemble_info *info, int n,
		   enum map_type *map_type)
{
  const char *name;

  name = bfd_asymbol_name (info->symtab[n]);
  if (name[0] == '$' && (name[1] == 'a' || name[1] == 't' || name[1] == 'd')
      && (name[2] == 0 || name[2] == '.'))
    {
      *map_type = ((name[1] == 'a') ? MAP_ARM
		   : (name[1] == 't') ? MAP_THUMB
		   : MAP_DATA);
      return TRUE;
    }

  return FALSE;
}

/* Try to infer the code type (ARM or Thumb) from a mapping symbol.
   Returns nonzero if *MAP_TYPE was set.  */

static int
get_map_sym_type (struct disassemble_info *info,
		  int n,
		  enum map_type *map_type)
{
  /* If the symbol is in a different section, ignore it.  */
  if (info->section != NULL && info->section != info->symtab[n]->section)
    return FALSE;

  return is_mapping_symbol (info, n, map_type);
}

/* Try to infer the code type (ARM or Thumb) from a non-mapping symbol.
   Returns nonzero if *MAP_TYPE was set.  */

static int
get_sym_code_type (struct disassemble_info *info,
		   int n,
		   enum map_type *map_type)
{
  elf_symbol_type *es;
  unsigned int type;

  /* If the symbol is in a different section, ignore it.  */
  if (info->section != NULL && info->section != info->symtab[n]->section)
    return FALSE;

  es = *(elf_symbol_type **)(info->symtab + n);
  type = ELF_ST_TYPE (es->internal_elf_sym.st_info);

  /* If the symbol has function type then use that.  */
  if (type == STT_FUNC || type == STT_GNU_IFUNC)
    {
      if (ARM_SYM_BRANCH_TYPE (&es->internal_elf_sym) == ST_BRANCH_TO_THUMB)
	*map_type = MAP_THUMB;
      else
	*map_type = MAP_ARM;
      return TRUE;
    }

  return FALSE;
}

/* Given a bfd_mach_arm_XXX value, this function fills in the fields
   of the supplied arm_feature_set structure with bitmasks indicating
   the support base architectures and coprocessor extensions.

   FIXME: This could more efficiently implemented as a constant array,
   although it would also be less robust.  */

static void
select_arm_features (unsigned long mach,
		     arm_feature_set * features)
{
#undef  ARM_FEATURE
#define ARM_FEATURE(ARCH,CEXT) \
  features->core = (ARCH); \
  features->coproc = (CEXT) | FPU_FPA; \
  return

  switch (mach)
    {
    case bfd_mach_arm_2:       ARM_ARCH_V2;
    case bfd_mach_arm_2a:      ARM_ARCH_V2S;
    case bfd_mach_arm_3:       ARM_ARCH_V3;
    case bfd_mach_arm_3M:      ARM_ARCH_V3M;
    case bfd_mach_arm_4:       ARM_ARCH_V4;
    case bfd_mach_arm_4T:      ARM_ARCH_V4T;
    case bfd_mach_arm_5:       ARM_ARCH_V5;
    case bfd_mach_arm_5T:      ARM_ARCH_V5T;
    case bfd_mach_arm_5TE:     ARM_ARCH_V5TE;
    case bfd_mach_arm_XScale:  ARM_ARCH_XSCALE;
    case bfd_mach_arm_ep9312:  ARM_FEATURE (ARM_AEXT_V4T, ARM_CEXT_MAVERICK | FPU_MAVERICK);
    case bfd_mach_arm_iWMMXt:  ARM_ARCH_IWMMXT;
    case bfd_mach_arm_iWMMXt2: ARM_ARCH_IWMMXT2;
      /* If the machine type is unknown allow all
	 architecture types and all extensions.  */
    case bfd_mach_arm_unknown: ARM_FEATURE (-1UL, -1UL);
    default:
      abort ();
    }
}


/* NOTE: There are no checks in these routines that
   the relevant number of data bytes exist.  */

static int
print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)
{
  unsigned char b[4];
  long		given;
  int           status;
  int           is_thumb = FALSE;
  int           is_data = FALSE;
  int           little_code;
  unsigned int	size = 4;
  void	 	(*printer) (bfd_vma, struct disassemble_info *, long);
  bfd_boolean   found = FALSE;
  struct arm_private_data *private_data;

  if (info->disassembler_options)
    {
      parse_disassembler_options (info->disassembler_options);

      /* To avoid repeated parsing of these options, we remove them here.  */
      info->disassembler_options = NULL;
    }

  /* PR 10288: Control which instructions will be disassembled.  */
  if (info->private_data == NULL)
    {
      static struct arm_private_data private;

      if ((info->flags & USER_SPECIFIED_MACHINE_TYPE) == 0)
	/* If the user did not use the -m command line switch then default to
	   disassembling all types of ARM instruction.
	   
	   The info->mach value has to be ignored as this will be based on
	   the default archictecture for the target and/or hints in the notes
	   section, but it will never be greater than the current largest arm
	   machine value (iWMMXt2), which is only equivalent to the V5TE
	   architecture.  ARM architectures have advanced beyond the machine
	   value encoding, and these newer architectures would be ignored if
	   the machine value was used.

	   Ie the -m switch is used to restrict which instructions will be
	   disassembled.  If it is necessary to use the -m switch to tell
	   objdump that an ARM binary is being disassembled, eg because the
	   input is a raw binary file, but it is also desired to disassemble
	   all ARM instructions then use "-marm".  This will select the
	   "unknown" arm architecture which is compatible with any ARM
	   instruction.  */
	  info->mach = bfd_mach_arm_unknown;

      /* Compute the architecture bitmask from the machine number.
	 Note: This assumes that the machine number will not change
	 during disassembly....  */
      select_arm_features (info->mach, & private.features);

      private.has_mapping_symbols = -1;
      private.last_mapping_sym = -1;
      private.last_mapping_addr = 0;

      info->private_data = & private;
    }

  private_data = info->private_data;

  /* Decide if our code is going to be little-endian, despite what the
     function argument might say.  */
  little_code = ((info->endian_code == BFD_ENDIAN_LITTLE) || little);

  /* For ELF, consult the symbol table to determine what kind of code
     or data we have.  */
  if (info->symtab_size != 0
      && bfd_asymbol_flavour (*info->symtab) == bfd_target_elf_flavour)
    {
      bfd_vma addr;
      int n, start;
      int last_sym = -1;
      enum map_type type = MAP_ARM;

      /* Start scanning at the start of the function, or wherever
	 we finished last time.  */
      /* PR 14006.  When the address is 0 we are either at the start of the
	 very first function, or else the first function in a new, unlinked
	 executable section (eg because uf -ffunction-sections).  Either way
	 start scanning from the beginning of the symbol table, not where we
	 left off last time.  */
      if (pc == 0)
	start = 0;
      else
	{
	  start = info->symtab_pos + 1;
	  if (start < private_data->last_mapping_sym)
	    start = private_data->last_mapping_sym;
	}
      found = FALSE;

      /* First, look for mapping symbols.  */
      if (private_data->has_mapping_symbols != 0)
	{
	  /* Scan up to the location being disassembled.  */
	  for (n = start; n < info->symtab_size; n++)
	    {
	      addr = bfd_asymbol_value (info->symtab[n]);
	      if (addr > pc)
		break;
	      if (get_map_sym_type (info, n, &type))
		{
		  last_sym = n;
		  found = TRUE;
		}
	    }

	  if (!found)
	    {
	      /* No mapping symbol found at this address.  Look backwards
		 for a preceding one.  */
	      for (n = start - 1; n >= 0; n--)
		{
		  if (get_map_sym_type (info, n, &type))
		    {
		      last_sym = n;
		      found = TRUE;
		      break;
		    }
		}
	    }

	  if (found)
	    private_data->has_mapping_symbols = 1;

	  /* No mapping symbols were found.  A leading $d may be
	     omitted for sections which start with data; but for
	     compatibility with legacy and stripped binaries, only
	     assume the leading $d if there is at least one mapping
	     symbol in the file.  */
	  if (!found && private_data->has_mapping_symbols == -1)
	    {
	      /* Look for mapping symbols, in any section.  */
	      for (n = 0; n < info->symtab_size; n++)
		if (is_mapping_symbol (info, n, &type))
		  {
		    private_data->has_mapping_symbols = 1;
		    break;
		  }
	      if (private_data->has_mapping_symbols == -1)
		private_data->has_mapping_symbols = 0;
	    }

	  if (!found && private_data->has_mapping_symbols == 1)
	    {
	      type = MAP_DATA;
	      found = TRUE;
	    }
	}

      /* Next search for function symbols to separate ARM from Thumb
	 in binaries without mapping symbols.  */
      if (!found)
	{
	  /* Scan up to the location being disassembled.  */
	  for (n = start; n < info->symtab_size; n++)
	    {
	      addr = bfd_asymbol_value (info->symtab[n]);
	      if (addr > pc)
		break;
	      if (get_sym_code_type (info, n, &type))
		{
		  last_sym = n;
		  found = TRUE;
		}
	    }

	  if (!found)
	    {
	      /* No mapping symbol found at this address.  Look backwards
		 for a preceding one.  */
	      for (n = start - 1; n >= 0; n--)
		{
		  if (get_sym_code_type (info, n, &type))
		    {
		      last_sym = n;
		      found = TRUE;
		      break;
		    }
		}
	    }
	}

      private_data->last_mapping_sym = last_sym;
      private_data->last_type = type;
      is_thumb = (private_data->last_type == MAP_THUMB);
      is_data = (private_data->last_type == MAP_DATA);

      /* Look a little bit ahead to see if we should print out
	 two or four bytes of data.  If there's a symbol,
	 mapping or otherwise, after two bytes then don't
	 print more.  */
      if (is_data)
	{
	  size = 4 - (pc & 3);
	  for (n = last_sym + 1; n < info->symtab_size; n++)
	    {
	      addr = bfd_asymbol_value (info->symtab[n]);
	      if (addr > pc
		  && (info->section == NULL
		      || info->section == info->symtab[n]->section))
		{
		  if (addr - pc < size)
		    size = addr - pc;
		  break;
		}
	    }
	  /* If the next symbol is after three bytes, we need to
	     print only part of the data, so that we can use either
	     .byte or .short.  */
	  if (size == 3)
	    size = (pc & 1) ? 1 : 2;
	}
    }

  if (info->symbols != NULL)
    {
      if (bfd_asymbol_flavour (*info->symbols) == bfd_target_coff_flavour)
	{
	  coff_symbol_type * cs;

	  cs = coffsymbol (*info->symbols);
	  is_thumb = (   cs->native->u.syment.n_sclass == C_THUMBEXT
		      || cs->native->u.syment.n_sclass == C_THUMBSTAT
		      || cs->native->u.syment.n_sclass == C_THUMBLABEL
		      || cs->native->u.syment.n_sclass == C_THUMBEXTFUNC
		      || cs->native->u.syment.n_sclass == C_THUMBSTATFUNC);
	}
      else if (bfd_asymbol_flavour (*info->symbols) == bfd_target_elf_flavour
	       && !found)
	{
	  /* If no mapping symbol has been found then fall back to the type
	     of the function symbol.  */
	  elf_symbol_type *  es;
	  unsigned int       type;

	  es = *(elf_symbol_type **)(info->symbols);
	  type = ELF_ST_TYPE (es->internal_elf_sym.st_info);

	  is_thumb = ((ARM_SYM_BRANCH_TYPE (&es->internal_elf_sym)
		       == ST_BRANCH_TO_THUMB)
		      || type == STT_ARM_16BIT);
	}
    }

  if (force_thumb)
    is_thumb = TRUE;

  if (is_data)
    info->display_endian = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;
  else
    info->display_endian = little_code ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;

  info->bytes_per_line = 4;

  /* PR 10263: Disassemble data if requested to do so by the user.  */
  if (is_data && ((info->flags & DISASSEMBLE_DATA) == 0))
    {
      int i;

      /* Size was already set above.  */
      info->bytes_per_chunk = size;
      printer = print_insn_data;

      status = info->read_memory_func (pc, (bfd_byte *) b, size, info);
      given = 0;
      if (little)
	for (i = size - 1; i >= 0; i--)
	  given = b[i] | (given << 8);
      else
	for (i = 0; i < (int) size; i++)
	  given = b[i] | (given << 8);
    }
  else if (!is_thumb)
    {
      /* In ARM mode endianness is a straightforward issue: the instruction
	 is four bytes long and is either ordered 0123 or 3210.  */
      printer = print_insn_arm;
      info->bytes_per_chunk = 4;
      size = 4;

      status = info->read_memory_func (pc, (bfd_byte *) b, 4, info);
      if (little_code)
	given = (b[0]) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
      else
	given = (b[3]) | (b[2] << 8) | (b[1] << 16) | (b[0] << 24);
    }
  else
    {
      /* In Thumb mode we have the additional wrinkle of two
	 instruction lengths.  Fortunately, the bits that determine
	 the length of the current instruction are always to be found
	 in the first two bytes.  */
      printer = print_insn_thumb16;
      info->bytes_per_chunk = 2;
      size = 2;

      status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);
      if (little_code)
	given = (b[0]) | (b[1] << 8);
      else
	given = (b[1]) | (b[0] << 8);

      if (!status)
	{
	  /* These bit patterns signal a four-byte Thumb
	     instruction.  */
	  if ((given & 0xF800) == 0xF800
	      || (given & 0xF800) == 0xF000
	      || (given & 0xF800) == 0xE800)
	    {
	      status = info->read_memory_func (pc + 2, (bfd_byte *) b, 2, info);
	      if (little_code)
		given = (b[0]) | (b[1] << 8) | (given << 16);
	      else
		given = (b[1]) | (b[0] << 8) | (given << 16);

	      printer = print_insn_thumb32;
	      size = 4;
	    }
	}

      if (ifthen_address != pc)
	find_ifthen_state (pc, info, little_code);

      if (ifthen_state)
	{
	  if ((ifthen_state & 0xf) == 0x8)
	    ifthen_next_state = 0;
	  else
	    ifthen_next_state = (ifthen_state & 0xe0)
				| ((ifthen_state & 0xf) << 1);
	}
    }

  if (status)
    {
      info->memory_error_func (status, pc, info);
      return -1;
    }
  if (info->flags & INSN_HAS_RELOC)
    /* If the instruction has a reloc associated with it, then
       the offset field in the instruction will actually be the
       addend for the reloc.  (We are using REL type relocs).
       In such cases, we can ignore the pc when computing
       addresses, since the addend is not currently pc-relative.  */
    pc = 0;

  printer (pc, info, given);

  if (is_thumb)
    {
      ifthen_state = ifthen_next_state;
      ifthen_address += size;
    }
  return size;
}

int
print_insn_big_arm (bfd_vma pc, struct disassemble_info *info)
{
  /* Detect BE8-ness and record it in the disassembler info.  */
  if (info->flavour == bfd_target_elf_flavour
      && info->section != NULL
      && (elf_elfheader (info->section->owner)->e_flags & EF_ARM_BE8))
    info->endian_code = BFD_ENDIAN_LITTLE;

  return print_insn (pc, info, FALSE);
}

int
print_insn_little_arm (bfd_vma pc, struct disassemble_info *info)
{
  return print_insn (pc, info, TRUE);
}

void
print_arm_disassembler_options (FILE *stream)
{
  int i;

  fprintf (stream, _("\n\
The following ARM specific disassembler options are supported for use with\n\
the -M switch:\n"));

  for (i = NUM_ARM_REGNAMES; i--;)
    fprintf (stream, "  reg-names-%s %*c%s\n",
	     regnames[i].name,
	     (int)(14 - strlen (regnames[i].name)), ' ',
	     regnames[i].description);

  fprintf (stream, "  force-thumb              Assume all insns are Thumb insns\n");
  fprintf (stream, "  no-force-thumb           Examine preceding label to determine an insn's type\n\n");
}
@


1.172
log
@	PR gas/15914

	* config/tc-arm.c (T16_32_TAB): Add _udf.
	(do_t_udf): New function.
	(insns): Add "udf".

	* gas/arm/udf-bad.s: New file.
	* gas/arm/udf-bad.d: New file.
	* gas/arm/udf-bad.l: New file.
	* gas/arm/udf.s: New file.
	* gas/arm/udf.d: New file.
	* gas/arm/udf.l: New file.

	* arm-dis.c (arm_opcodes): Add udf.
	(thumb_opcodes): Use "udf" mnemonic rather than UNDEFINED_INSTRUCTION.
	(thumb32_opcodes): Add udf.w.
	(print_insn_thumb32): Handle %H as the thumb32_opcodes comment says.
@
text
@d714 1
a714 1
  {FPU_NEON_EXT_V1, 0xf2880a10, 0xfeb80fd0, "vshll%c.%24?us8\t%12-15,22D, %0-3,5Q, #%16-18d"},
d725 1
a725 1
  {FPU_NEON_EXT_V1, 0xf2900a10, 0xfeb00fd0, "vshll%c.%24?us16\t%12-15,22D, %0-3,5Q, #%16-19d"},
d737 1
a737 1
  {FPU_NEON_EXT_V1, 0xf2a00a10, 0xfea00fd0, "vshll%c.%24?us32\t%12-15,22D, %0-3,5Q, #%16-20d"},
@


1.171
log
@Add support for AArch32 CRC instruction in ARMv8.

gas/ChangeLog
2013-03-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* config/tc-arm.c (crc_ext_armv8): New feature set.
	(UNPRED_REG): New macro.
	(do_crc32_1): New function.
	(do_crc32b, do_crc32h, do_crc32w, do_crc32cb,
	do_crc32ch, do_crc32cw): Likewise.
	(TUEc): New macro.
	(insns): Add entries for crc32 mnemonics.
	(arm_extensions): Add entry for crc.

include/opcode/ChangeLog
2013-03-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* arm.h (CRC_EXT_ARMV8): New constant.
	(ARCH_CRC_ARMV8): New macro.

opcodes/ChangeLog
2013-03-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* arm-dis.c (arm_opcodes): Add entries for CRC instructions.
	(thumb32_opcodes): Likewise.
	(print_insn_thumb32): Handle 'S' control char.

gas/testsuite/ChangeLog
2013-03-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* gas/arm/crc32-bad.d: New file.
	* gas/arm/crc32-bad.l: Likewise.
	* gas/arm/crc32-bad.s: Likewise.
	* gas/arm/crc32.d: Likewise.
	* gas/arm/crc32.s: Likewise.
@
text
@d2 1
a2 3
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012
   Free Software Foundation, Inc.
d880 2
d1417 1
d1538 1
d4062 11
@


1.170
log
@2013-02-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* arm-dis.c: Update strht pattern.

	* gas/arm/archv6t2.s: Add strht and ldrht tests.
	* gas/arm/archv6t2.d: Add disassembly patterns for the above.
@
text
@d906 7
d1465 2
a1466 1
       %<bitfield>R	as %<>r bit r15 is UNPREDICTABLE
d1501 8
d4446 4
@


1.169
log
@2012-10-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* arm-dis.c: Use preferred form of vrint instruction variants
	for disassembly.

2012-10-11  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* gas/arm/armv8-a+fp.d: Use preferred form of vrint instruction
	variants for disassembly.
	* gas/arm/armv8-a+fp.s: Likewise.
	* gas/arm/armv8-a+simd.d: Likewise.
	* gas/arm/armv8-a+simd.s: Likewise.
@
text
@d931 2
a932 2
  {ARM_EXT_V6T2, 0x006000b0, 0x0f7000f0, "strht%c\t%12-15R, %S"},
  
@


1.168
log
@2012-09-18  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>
opcodes:
	* arm-dis.c: Changed ldra and strl-form mnemonics
	to lda and stl-form.
gas:
	* config/tc-arm.c: Changed ldra and strl-form mnemonics
	to lda and stl-form for armv8.
gas/testsuite:
	* gas/arm/armv8-a-bad.l: Updated for changed mnemonics.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.
	* gas/arm/inst.s: Added test for ldrt encoding compatibly with ldralt.
	* gas/arm/inst.d: Updated.
@
text
@d501 4
a504 4
  {FPU_VFP_EXT_ARMV8, 0x0eb60a40, 0x0fbe0f50, "vrint%7,16??xzr%c.f32.f32\t%y1, %y0"},
  {FPU_VFP_EXT_ARMV8, 0x0eb60b40, 0x0fbe0f50, "vrint%7,16??xzr%c.f64.f64\t%z1, %z0"},
  {FPU_VFP_EXT_ARMV8, 0xfeb80a40, 0xffbc0f50, "vrint%16-17?mpna%u.f32.f32\t%y1, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfeb80b40, 0xffbc0f50, "vrint%16-17?mpna%u.f64.f64\t%z1, %z0"},
d587 1
a587 1
  {FPU_NEON_EXT_ARMV8, 0xf3ba0400, 0xffbf0c10, "vrint%7-9?p?m?zaxn%u.f32.f32\t%12-15,22R, %0-3,5R"},
@


1.167
log
@	* gas/config/tc-arm.c (ARM_ENC_TAB): Add sha1h and sha2op entries.
	(do_sha1h): New function.
	(do_sha1su1): Likewise.
	(do_sha256su0): Likewise.
	(insns): Add 2 operand SHA instructions.
	* gas/testsuite/gas/arm/armv8-a+crypto.s: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+crypto.d: Likewise.
	* opcodes/arm-dis.c (neon_opcodes): Add 2 operand sha instructions.
@
text
@d892 14
a905 14
  {ARM_EXT_V8,	 0x01800e90, 0x0ff00ff0, "strlex%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01900e9f, 0x0ff00fff, "ldraex%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01a00e90, 0x0ff00ff0, "strlexd%c\t%12-15r, %0-3r, %0-3T, [%16-19R]"},
  {ARM_EXT_V8,	 0x01b00e9f, 0x0ff00fff, "ldraexd%c\t%12-15r, %12-15T, [%16-19R]"},
  {ARM_EXT_V8,	 0x01c00e90, 0x0ff00ff0, "strlexb%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01d00e9f, 0x0ff00fff, "ldraexb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01e00e90, 0x0ff00ff0, "strlexh%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01f00e9f, 0x0ff00fff, "ldraexh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x0180fc90, 0x0ff0fff0, "strl%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01900c9f, 0x0ff00fff, "ldra%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01c0fc90, 0x0ff0fff0, "strlb%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01d00c9f, 0x0ff00fff, "ldrab%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01e0fc90, 0x0ff0fff0, "strlh%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01f00c9f, 0x0ff00fff, "ldraexh%c\t%12-15r, [%16-19R]"},
d1478 14
a1491 14
  {ARM_EXT_V8, 0xe8c00f8f, 0xfff00fff, "strlb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00f9f, 0xfff00fff, "strlh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00faf, 0xfff00fff, "strl%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fc0, 0xfff00ff0, "strlexb%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fd0, 0xfff00ff0, "strlexh%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fe0, 0xfff00ff0, "strlex%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c000f0, 0xfff000f0, "strlexd%c\t%0-3r, %12-15r, %8-11r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00f8f, 0xfff00fff, "ldrab%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00f9f, 0xfff00fff, "ldrah%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00faf, 0xfff00fff, "ldra%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fcf, 0xfff00fff, "ldraexb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fdf, 0xfff00fff, "ldraexh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fef, 0xfff00fff, "ldraex%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d000ff, 0xfff000ff, "ldraexd%c\t%12-15r, %8-11r, [%16-19R]"},
@


1.166
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add sha3op entry.
	(do_crypto_3op_1): New function.
	(do_sha1c): Likewise.
	(do_sha1p): Likewise.
	(do_sha1m): Likewise.
	(do_sha1su0): Likewise.
	(do_sha256h): Likewise.
	(do_sha256h2): Likewise.
	(do_sha256su1): Likewise.
	(insns): Add SHA 3 operand instructions.
	* gas/testsuite/gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+crypto.s: Likewise.
	* opcodes/arm-dis.c (neon_opcodes): Add SHA 3-operand instructions.
@
text
@d593 3
@


1.165
log
@	* gas/config/tc-arm.c (neon_type_mask): Add P64 type.
	(type_chk_of_el_type): Handle P64 type.
	(el_type_of_type_chk): Likewise.
	(do_neon_vmull): Handle VMULL.P64.
	* gas/testsuite/gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+crypto.s: Likewise.
	* opcodes/arm-dis.c (neon_opcodes): Handle VMULL.P64.
@
text
@d628 7
@


1.164
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add aes entry.
	(neon_type_mask): Add N_UNT.
	(neon_check_type): Don't always decay typed to untyped sizes.
	(do_crypto_2op_1): New function.
	(do_aese): Likewise.
	(do_aesd): Likewise.
	(do_aesmc.8): Likewise.
	(do_aesimc.8): Likewise.
	(insns): Add AES instructions.
	* gas/testsuite/gas/arm/armv8-a+crypto.d: New testcase.
	* gas/testsuite/gas/arm/armv8-a+crypto.s: Likewise.
	* opcodes/arm-dis.c (neon_opcodes): Add support for AES instructions.
@
text
@d760 1
@


1.163
log
@	* gas/config/tc-arm.c (el_type_type_check): Add handling for 16-bit
	floating point types.
	(do_neon_cvttb_2): New function.
	(do_neon_cvttb_1): Likewise.
	(do_neon_cvtb): Refactor to use do_neon_cvttb_1.
	(do_neon_cvtt): Likewise.
	* gas/testsuite/gas/arm/armv8-a+fp.d: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+fp.s: Likewise.
	* gas/testsuite/gas/arm/half-prec-vfpv3.s: Likewise.
	* opcodes/arm-dis.c (coprocessor_opcodes): Add support for HP/DP
	conversions.
@
text
@d589 4
@


1.162
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add vrint entries.
	(neon_cvt_mode): Add neon_cvt_mode_r.
	(do_vrint_1): New function.
	(do_vrint_x): Likewise.
	(do_vrint_z): Likewise.
	(do_vrint_r): Likewise.
	(do_vrint_a): Likewise.
	(do_vrint_n): Likewise.
	(do_vrint_p): Likewise.
	(do_vrint_m): Likewise.
	(insns): Add VRINT instructions.
	* gas/testsuite/gas/arm/armv8-a+fpv5.d: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+fpv5.s: Likewise.
	* gas/testsuite/gas/arm/armv8-a+simdv3.d: Likewise.
	* gas/testsuite/gas/arm/armv8-a+simdv3.s: Likewise.
	* opcodes/arm-dis.c (coprocessor_opcodes): Add VRINT.
	(neon_opcodes): Likewise.
@
text
@d322 2
@


1.161
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add vcvta entry.
	(neon_cvt_mode): New enumeration.
	(do_vfp_nsyn_cvt_fpv8): New function.
	(do_neon_cvt_1): Add support for new conversions.
	(do_neon_cvtr): Use neon_cvt_mode enumerator.
	(do_neon_cvt): Likewise.
	(do_neon_cvta): New function.
	(do_neon_cvtn): Likewise.
	(do_neon_cvtp): Likewise.
	(do_neon_cvtm): Likewise.
	(insns): Add new VCVT instructions.
	* gas/testsuite/gas/arm/armv8-a+fp.d: Update testcase.
	* gas/testsuite/gas/arm/armv8-a+fp.s: Likewise.
	* gas/testsuite/gas/arm/armv8-a+simd.d: Likewise.
	* gas/testsuite/gas/arm/armv8-a+simd.s: Likewise.
	* opcodes/arm-dis.c (coprocessor_opcodes): Add support for new VCVT
	variants.
	(neon_opcodes): Likewise.
@
text
@d499 4
d585 1
@


1.160
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add vmaxnm, vminnm entries.
	(vfp_or_neon_is_neon_bits): Add NEON_CHECK_ARCH8 enumerator.
	(vfp_or_neon_is_neon): Add check for SIMD for ARMv8.
	(do_maxnm): New function.
	(insns): Add vmaxnm, vminnm entries.
	* gas/testsuite/gas/testsuite/gas/armv8-a+fp.d: Update testcase.
	* gas/testsuite/gas/testsuite/gas/armv8-a+fp.s: Likewise.
	* gas/testsuite/gas/testsuite/gas/armv8-a+simd.d: New testcase.
	* gas/testsuite/gas/testsuite/gas/armv8-a+simd.s: Likewise.
	* opcodes/arm-dis.c (coprocessor_opcodes): Add VMAXNM/VMINNM.
	(neon_opcodes): Likewise.
@
text
@d497 2
d581 1
d2923 1
a2923 1
      
@


1.159
log
@	* gas/config/tc-arm.c (NEON_ENC_TAB): Add entries for VSEL.
	(NEON_ENC_FPV8_): New define.
	(do_vfp_nsyn_fpv8): New function.
	(do_vsel): Likewise.
	(insns): Add VSEL instructions.
	* gas/testsuite/gas/arm/armv8-a+fp.d: New testcase.
	* gas/testsuite/gas/arm/armv8-a+fp.s: Likewise.
	* opcodes/arm-dis.c (coprocessor_opcodes): Add VSEL.
	(print_insn_coprocessor): Add new %<>c bitfield format
	specifier.
@
text
@d493 4
d614 2
@


1.158
log
@	* gas/config/tc-arm.c (do_rm_rn): New function.
	(do_strlex): Likewise.
	(do_t_strlex): Likewise.
	(insns): Add support for LDRA/STRL instructions.
	* gas/testsuite/gas/arm/armv8-a-bad.l: Update testcase.
	* gas/testsuite/gas/arm/armv8-a-bad.s: Likewise.
	* gas/testsuite/gas/arm/armv8-a.d: Likewise.
	* gas/testsuite/gas/arm/armv8-a.s: Likewise.
	* opcodes/arm-dis.c (arm_opcodes): Add LDRA/STRL instructions.
	(thumb32_opcodes): Likewise.
	(print_arm_insn): Add support for %<>T formatter.
@
text
@d105 1
d490 4
d2206 25
@


1.157
log
@	* gas/config/tc-arm.c (do_t_bkpt_hlt1): New function.
	(do_t_hlt): New function.
	(do_t_bkpt): Use do_t_bkpt_hlt1.
	(insns): Add HLT.
	* gas/testsuite/gas/arm/armv8-a-bad.l: Update for HLT.
	* gas/testsuite/gas/arm/armv8-a-bad.s: Likewise.
	* gas/testsuite/gas/arm/armv8-a.d: Likewise.
	* gas/testsuite/gas/arm/armv8-a.s: Likewise.
	* opcodes/arm-dis.c (arm_opcodes): Add HLT.
	(thumb_opcodes): Likewise.
@
text
@d824 1
d856 14
a869 1

d1442 14
d3428 5
@


1.156
log
@	* gas/config/tc-arm.c (insns): Add DCPS instruction.
	* gas/testsuite/gas/arm/armv8-a.d: Update.
	* gas/testsuite/gas/arm/armv8-a.s: Likewise.
	* opcodes/arm-dis.c (thumb32_opcodes): Add DCPS instruction.
@
text
@d854 2
d1254 1
@


1.155
log
@	* gas/config/tc-arm.c (T16_32_TAB): Add _sevl.
	(insns): Add SEVL.
	* gas/testsuite/gas/arm/armv8-a.s: New testcase.
	* gas/testsuite/gas/arm/armv8-a.d: Likewise.
	* opcodes/arm-dis.c (arm_opcodes): Add SEVL.
	(thumb_opcodes): Likewise.
	(thumb32_opcodes): Likewise.
@
text
@d1424 1
@


1.154
log
@	* gas/config/tc-arm.c (asm_barrier_opt): Add arch field.
	(mark_feature_used): New function.
	(parse_barrier): Check specified option is valid for the
	specified architecture.
	(UL_BARRIER): New macro.
	(barrier_opt_names): Update for new barrier options.
	* gas/testsuite/gas/arm/armv8-a-barrier.s: New testcase.
	* gas/testsuite/gas/arm/armv8-a-barrier-arm.d: Likewise.
	* gas/testsuite/gas/arm/armv8-a-barrier-thumb.d: Likewise.
	* opcodes/arm-dis.c (data_barrier_option): New function.
	(print_insn_arm): Use data_barrier_option.
	(print_insn_thumb32): Use data_barrier_option.
@
text
@d852 3
d1250 3
d1422 3
@


1.153
log
@	* opcodes/arm-dis.c (COND_UNCOND): New constant.
	(print_insn_coprocessor): Add support for %u format specifier.
	(print_insn_neon): Likewise.
@
text
@d866 2
d1419 2
d2992 22
d3364 4
a3367 11
			  switch (given & 0xf)
			    {
			    case 0xf: func (stream, "sy"); break;
			    case 0x7: func (stream, "un"); break;
			    case 0xe: func (stream, "st"); break;
			    case 0x6: func (stream, "unst"); break;
			    case 0xb: func (stream, "ish"); break;
			    case 0xa: func (stream, "ishst"); break;
			    case 0x3: func (stream, "osh"); break;
			    case 0x2: func (stream, "oshst"); break;
			    default:
a3368 2
			      break;
			    }
d4242 5
a4246 14
		    switch (given & 0xf)
		      {
			case 0xf: func (stream, "sy"); break;
			case 0x7: func (stream, "un"); break;
			case 0xe: func (stream, "st"); break;
			case 0x6: func (stream, "unst"); break;
			case 0xb: func (stream, "ish"); break;
			case 0xa: func (stream, "ishst"); break;
			case 0x3: func (stream, "osh"); break;
			case 0x2: func (stream, "oshst"); break;
			default:
			  func (stream, "#%d", (int) given & 0xf);
			  break;
		      }
@


1.152
log
@	PR binutils/13135
	* arm-dis.c: Add necessary casts for printing integer values.
	Use %s when printing string values.
	* hppa-dis.c: Likewise.
	* m68k-dis.c: Likewise.
	* microblaze-dis.c: Likewise.
	* mips-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* sparc-dis.c: Likewise.

	* dis-asm.h (fprintf_ftype): Add ATTRIBUTE_FPTR_PRINTF_2.
@
text
@d95 2
a96 1
   %u			print condition code (unconditional in ARM mode)
d523 2
d1698 3
d1879 1
a1879 1
	    cond = 16;
d1888 1
a1888 1
	      cond = 16;
d1894 1
a1894 1
		cond = 16;
d1988 5
d2502 1
d2515 5
d2933 3
@


1.152.2.1
log
@	Apply mainline patches

bfd/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* elf32-arm.c (v8): New array.
	(tag_cpu_arch_combine): Add support for ARMv8 attributes.
	(elf32_arm_merge_eabi_attributes): Likewise.
	(VFP_VERSION_COUNT): New define.

gas/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (ARM_ENC_TAB): Add sha1h and sha2op entries.
	(do_sha1h): New function.
	(do_sha1su1): Likewise.
	(do_sha256su0): Likewise.
	(insns): Add 2 operand SHA instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add sha3op entry.
	(do_crypto_3op_1): New function.
	(do_sha1c): Likewise.
	(do_sha1p): Likewise.
	(do_sha1m): Likewise.
	(do_sha1su0): Likewise.
	(do_sha256h): Likewise.
	(do_sha256h2): Likewise.
	(do_sha256su1): Likewise.
	(insns): Add SHA 3 operand instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (neon_type_mask): Add P64 type.
	(type_chk_of_el_type): Handle P64 type.
	(el_type_of_type_chk): Likewise.
	(do_neon_vmull): Handle VMULL.P64.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add aes entry.
	(neon_type_mask): Add N_UNT.
	(neon_check_type): Don't always decay typed to untyped sizes.
	(do_crypto_2op_1): New function.
	(do_aese): Likewise.
	(do_aesd): Likewise.
	(do_aesmc.8): Likewise.
	(do_aesimc.8): Likewise.
	(insns): Add AES instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (el_type_type_check): Add handling for 16-bit
	floating point types.
	(do_neon_cvttb_2): New function.
	(do_neon_cvttb_1): Likewise.
	(do_neon_cvtb): Refactor to use do_neon_cvttb_1.
	(do_neon_cvtt): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vrint entries.
	(neon_cvt_mode): Add neon_cvt_mode_r.
	(do_vrint_1): New function.
	(do_vrint_x): Likewise.
	(do_vrint_z): Likewise.
	(do_vrint_r): Likewise.
	(do_vrint_a): Likewise.
	(do_vrint_n): Likewise.
	(do_vrint_p): Likewise.
	(do_vrint_m): Likewise.
	(insns): Add VRINT instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vcvta entry.
	(neon_cvt_mode): New enumeration.
	(do_vfp_nsyn_cvt_fpv8): New function.
	(do_neon_cvt_1): Add support for new conversions.
	(do_neon_cvtr): Use neon_cvt_mode enumerator.
	(do_neon_cvt): Likewise.
	(do_neon_cvta): New function.
	(do_neon_cvtn): Likewise.
	(do_neon_cvtp): Likewise.
	(do_neon_cvtm): Likewise.
	(insns): Add new VCVT instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm>
	* config/tc-arm.c (CVT_FLAVOUR_VAR): New define.
	(CVT_VAR): New helper define.
	(neon_cvt_flavour): New enumeration, function renamed...
	(get_neon_cvt_flavour): ...to this.
	(do_vfp_nsyn_cvt): Update to use new neon_cvt_flavour.
	(do_vfp_nsyn_cvtz): Likewise.
	(do_neon_cvt_1): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vmaxnm, vminnm entries.
	(vfp_or_neon_is_neon_bits): Add NEON_CHECK_ARCH8 enumerator.
	(vfp_or_neon_is_neon): Add check for SIMD for ARMv8.
	(do_maxnm): New function.
	(insns): Add vmaxnm, vminnm entries.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add entries for VSEL.
	(NEON_ENC_FPV8_): New define.
	(do_vfp_nsyn_fpv8): New function.
	(do_vsel): Likewise.
	(insns): Add VSEL instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_rm_rn): New function.
	(do_strlex): Likewise.
	(do_t_strlex): Likewise.
	(insns): Add support for LDRA/STRL instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_t_bkpt_hlt1): New function.
	(do_t_hlt): New function.
	(do_t_bkpt): Use do_t_bkpt_hlt1.
	(insns): Add HLT.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (insns): Add DCPS instruction.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (T16_32_TAB): Add _sevl.
	(insns): Add SEVL.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (asm_barrier_opt): Add arch field.
	(mark_feature_used): New function.
	(parse_barrier): Check specified option is valid for the
	specified architecture.
	(UL_BARRIER): New macro.
	(barrier_opt_names): Update for new barrier options.

	2012-08-24  Matthew Gretton-Dann <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_setend): Warn on deprecated SETEND.
	(do_t_setend): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_t_it): Fully initialise now_it.
	(new_automatic_it_block): Likewise.
	(handle_it_block): Record whether current instruction is
	conditionally executed.
	* config/tc-arm.c (depr_insn_mask): New structure.
	(depr_it_insns): New variable.
	(it_fsm_post_encode): Warn on deprecated uses.
	* config/tc-arm.h (current_it): Add new fields.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (deprecated_coproc_regs_s): New structure.
	(deprecated_coproc_regs): New variable.
	(deprecated_coproc_reg_count): Likewise.
	(do_co_reg): Error on obsolete & warn on deprecated registers.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (check_obsolete): New function.
	(do_rd_rm_rn): Check swp{b} for obsoletion.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.h (arm_ext_v8): New variable.
	(fpu_vfp_ext_armv8): Likewise.
	(fpu_neon_ext_armv8): Likewise.
	(fpu_crypto_ext_armv8): Likewise.
	(arm_archs): Add armv8-a.
	(arm_extensions): Add crypto, fp, and simd.
	(arm_fpus): Add fp-armv8, neon-fp-armv8, crypto-neon-fp-armv8.
	(cpu_arch_ver): Add support for ARMv8.
	(aeabi_set_public_sttributes): Likewise.
	* doc/c-arm.texi (ARM Options): Document new architecture and
	extension options for ARMv8.

gas/testsuite/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.s: Update testcase.
	* gas/arm/armv8-a+crypto.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: New testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: Update testcase.
	* gas/arm/armv8-a+fp.s: Likewise.
	* gas/arm/half-prec-vfpv3.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fpv5.d: Update testcase.
	* gas/arm/armv8-a+fpv5.s: Likewise.
	* gas/arm/armv8-a+simdv3.d: Likewise.
	* gas/arm/armv8-a+simdv3.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: Update testcase.
	* gas/arm/armv8-a+fp.s: Likewise.
	* gas/arm/armv8-a+simd.d: Likewise.
	* gas/arm/armv8-a+simd.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/testsuite/gas/armv8-a+fp.d: Update testcase.
	* gas/testsuite/gas/armv8-a+fp.s: Likewise.
	* gas/testsuite/gas/armv8-a+simd.d: New testcase.
	* gas/testsuite/gas/armv8-a+simd.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: New testcase.
	* gas/arm/armv8-a+fp.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update testcase.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update for HLT.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a.d: Update.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a.s: New testcase.
	* gas/arm/armv8-a.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-barrier.s: New testcase.
	* gas/arm/armv8-a-barrier-arm.d: Likewise.
	* gas/arm/armv8-a-barrier-thumb.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update
	* gas/arm/armv8-a-bad.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-it-bad.d: New testcase.
	* gas/arm/armv8-a-it-bad.l: Likewise.
	* gas/arm/armv8-a-it-bad.s: Likewise.
	* gas/arm/ldr-t-bad.s: Update testcase.
	* gas/arm/ldr-t.d: Likewise.
	* gas/arm/ldr-t.s: Likewise.
	* gas/arm/neon-cond-bad-inc.s: Likewise.
	* gas/arm/sp-pc-validations-bad-t: Likewise.
	* gas/arm/vfp-fma-inc.s: Likewise.
	* gas/arm/vfp-neon-syntax-inc.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update testcase.
	* gas/arm/armv8-a-bad.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.d: New testcase.
	* gas/arm/armv8-a-bad.l: Likewise.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/depr-swp.l: Update for change in expected output.
	* gas/arm/depr-swp.s: Add additional test.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/attr-march-all.d: Update for change in expected
	output.
	* gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/arm/attr-march-armv8-a+crypto.d: New testcase.
	* gas/arm/attr-march-armv8-a+fp.d: Likewise.
	* gas/arm/attr-march-armv8-a+simd.d: Likewise.
	* gas/arm/attr-march-armv8-a.d: Likewise.

include/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* opcode/arm.h (ARM_CPU_IS_ANY): New define.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* elf/arm.h (TAG_CPU_ARCH_V8): New define.
	(MAX_TAG_CPU_ARCH): Update.
	* opcode/arm.h (ARM_EXT_V8): New define.
	(FPU_VFP_EXT_ARMV8): Likewise.
	(FPU_NEON_EXT_ARMV8): Likewise.
	(FPU_CRYPTO_EXT_ARMV8): Likewise.
	(ARM_AEXT_V8A): Likewise.
	(FPU_VFP_ARMV8): Likwise.
	(FPU_NEON_ARMV8): Likewise.
	(FPU_CRYPTO_ARMV8): Likewise.
	(FPU_ARCH_VFP_ARMV8): Likewise.
	(FPU_ARCH_NEON_VFP_ARMV8): Likewise.
	(FPU_ARCH_CRYPTO_NEON_VFP_ARMV8): Likewise.
	(ARM_ARCH_V8A): Likwise.
	(ARM_ARCH_V8A_FP): Likewise.
	(ARM_ARCH_V8A_SIMD): Likewise.
	(ARM_ARCH_V8A_CRYPTO): Likewise.

ld/testsuite/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* ld-arm/arm-elf.exp: Add new testcases.
	* ld-arm/attr-merge-vfp-3.d: Update for change in expected
	output.
	* ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld-arm/attr-merge-vfp-4.d: Likewise.
	* ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld-arm/attr-merge-vfp-7.d: New testcase.
	* ld-arm/attr-merge-vfp-7r.d: Likewise.
	* ld-arm/attr-merge-vfp-armv8-hard.s: Likewise.
	* ld-arm/attr-merge-vfp-armv8.s: Likewise.

opcodes/
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add 2 operand sha instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add SHA 3-operand instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Handle VMULL.P64.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add support for AES instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add support for HP/DP
	conversions.

	2012-08-24  Matthew  Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VRINT.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add support for new VCVT
	variants.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VMAXNM/VMINNM.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VSEL.
	(print_insn_coprocessor): Add new %<>c bitfield format
	specifier.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add LDRA/STRL instructions.
	(thumb32_opcodes): Likewise.
	(print_arm_insn): Add support for %<>T formatter.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add HLT.
	(thumb_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (thumb32_opcodes): Add DCPS instruction.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add SEVL.
	(thumb_opcodes): Likewise.
	(thumb32_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (data_barrier_option): New function.
	(print_insn_arm): Use data_barrier_option.
	(print_insn_thumb32): Use data_barrier_option.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com
	* arm-dis.c (COND_UNCOND): New constant.
	(print_insn_coprocessor): Add support for %u format specifier.
	(print_insn_neon): Likewise.
@
text
@d95 1
a95 2
   %u			print condition code (unconditional in ARM mode,
                          UNPREDICTABLE if not AL in Thumb)
a103 1
   %<bitfield>c		print as a condition code (for vsel)
a319 2
  {FPU_VFP_EXT_ARMV8, 0x0eb20b40, 0x0fbf0f50, "vcvt%7?tb%c.f64.f16\t%z1, %y0"},
  {FPU_VFP_EXT_ARMV8, 0x0eb30b40, 0x0fbf0f50, "vcvt%7?tb%c.f16.f64\t%y1, %z0"},
a487 14
  /* FP v5.  */
  {FPU_VFP_EXT_ARMV8, 0xfe000a00, 0xff800f00, "vsel%20-21c%u.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfe000b00, 0xff800f00, "vsel%20-21c%u.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_ARMV8, 0xfe800a00, 0xffb00f40, "vmaxnm%u.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfe800b00, 0xffb00f40, "vmaxnm%u.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_ARMV8, 0xfe800a40, 0xffb00f40, "vminnm%u.f32\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfe800b40, 0xffb00f40, "vminnm%u.f64\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_ARMV8, 0xfebc0a40, 0xffbc0f50, "vcvt%16-17?mpna%u.%7?su32.f32\t%y1, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfebc0b40, 0xffbc0f50, "vcvt%16-17?mpna%u.%7?su32.f64\t%y1, %z0"},
  {FPU_VFP_EXT_ARMV8, 0x0eb60a40, 0x0fbe0f50, "vrint%7,16??xzr%c.f32.f32\t%y1, %y0"},
  {FPU_VFP_EXT_ARMV8, 0x0eb60b40, 0x0fbe0f50, "vrint%7,16??xzr%c.f64.f64\t%z1, %z0"},
  {FPU_VFP_EXT_ARMV8, 0xfeb80a40, 0xffbc0f50, "vrint%16-17?mpna%u.f32.f32\t%y1, %y0"},
  {FPU_VFP_EXT_ARMV8, 0xfeb80b40, 0xffbc0f50, "vrint%16-17?mpna%u.f64.f64\t%z1, %z0"},

a521 2
   %u			print condition code (unconditional in ARM mode,
                          UNPREDICTABLE if not AL in Thumb)
a566 9
  {FPU_NEON_EXT_ARMV8, 0xf3ba0400, 0xffbf0c10, "vrint%7-9?p?m?zaxn%u.f32.f32\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_ARMV8, 0xf3bb0000, 0xffbf0c10, "vcvt%8-9?mpna%u.%7?us32.f32\t%12-15,22R, %0-3,5R"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3b00300, 0xffbf0fd0, "aese%u.8\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3b00340, 0xffbf0fd0, "aesd%u.8\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3b00380, 0xffbf0fd0, "aesmc%u.8\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3b003c0, 0xffbf0fd0, "aesimc%u.8\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3b902c0, 0xffbf0fd0, "sha1h%u.32\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3ba0380, 0xffbf0fd0, "sha1su1%u.32\t%12-15,22Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3ba03c0, 0xffbf0fd0, "sha256su0%u.32\t%12-15,22Q, %0-3,5Q"},
a601 9
  {FPU_CRYPTO_EXT_ARMV8, 0xf2000c40, 0xffb00f50, "sha1c%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf2100c40, 0xffb00f50, "sha1p%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf2200c40, 0xffb00f50, "sha1m%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf2300c40, 0xffb00f50, "sha1su0%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3000c40, 0xffb00f50, "sha256h%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3100c40, 0xffb00f50, "sha256h2%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_CRYPTO_EXT_ARMV8, 0xf3200c40, 0xffb00f50, "sha256su1%u.32\t%12-15,22Q, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_ARMV8, 0xf3000f10, 0xffa00f10, "vmaxnm%u.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_ARMV8, 0xf3200f10, 0xffa00f10, "vminnm%u.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
a731 1
  {FPU_CRYPTO_EXT_ARMV8, 0xf2a00e00, 0xfeb00f50, "vmull%c.p64\t%12-15,22Q, %16-19,7D, %0-3,5D"},
a820 1
   %<bitfield>T		print as an ARM register + 1
a848 18
  /* V8 instructions.  */
  {ARM_EXT_V8,   0x0320f005, 0x0fffffff, "sevl"},
  {ARM_EXT_V8,   0xe1000070, 0xfff000f0, "hlt\t0x%16-19X%12-15X%8-11X%0-3X"},
  {ARM_EXT_V8,	 0x01800e90, 0x0ff00ff0, "strlex%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01900e9f, 0x0ff00fff, "ldraex%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01a00e90, 0x0ff00ff0, "strlexd%c\t%12-15r, %0-3r, %0-3T, [%16-19R]"},
  {ARM_EXT_V8,	 0x01b00e9f, 0x0ff00fff, "ldraexd%c\t%12-15r, %12-15T, [%16-19R]"},
  {ARM_EXT_V8,	 0x01c00e90, 0x0ff00ff0, "strlexb%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01d00e9f, 0x0ff00fff, "ldraexb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01e00e90, 0x0ff00ff0, "strlexh%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01f00e9f, 0x0ff00fff, "ldraexh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x0180fc90, 0x0ff0fff0, "strl%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01900c9f, 0x0ff00fff, "ldra%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01c0fc90, 0x0ff0fff0, "strlb%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01d00c9f, 0x0ff00fff, "ldrab%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01e0fc90, 0x0ff0fff0, "strlh%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01f00c9f, 0x0ff00fff, "ldraexh%c\t%12-15r, [%16-19R]"},

a862 2
  {ARM_EXT_V8, 0xf57ff051, 0xfffffff3, "dmb\t%U"},
  {ARM_EXT_V8, 0xf57ff041, 0xfffffff3, "dsb\t%U"},
a1241 4
  /* ARM V8 instructions.  */
  {ARM_EXT_V8,  0xbf50, 0xffff, "sevl%c"},
  {ARM_EXT_V8,  0xba80, 0xffc0, "hlt\t%0-5x"},

a1410 18
  /* V8 instructions.  */
  {ARM_EXT_V8, 0xf3af8005, 0xffffffff, "sevl%c.w"},
  {ARM_EXT_V8, 0xf78f8000, 0xfffffffc, "dcps%0-1d"},
  {ARM_EXT_V8, 0xe8c00f8f, 0xfff00fff, "strlb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00f9f, 0xfff00fff, "strlh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00faf, 0xfff00fff, "strl%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fc0, 0xfff00ff0, "strlexb%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fd0, 0xfff00ff0, "strlexh%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fe0, 0xfff00ff0, "strlex%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c000f0, 0xfff000f0, "strlexd%c\t%0-3r, %12-15r, %8-11r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00f8f, 0xfff00fff, "ldrab%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00f9f, 0xfff00fff, "ldrah%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00faf, 0xfff00fff, "ldra%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fcf, 0xfff00fff, "ldraexb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fdf, 0xfff00fff, "ldraexh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fef, 0xfff00fff, "ldraex%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d000ff, 0xfff000ff, "ldraexd%c\t%12-15r, %8-11r, [%16-19R]"},

a1413 2
  {ARM_EXT_V8, 0xf3bf8f51, 0xfffffff3, "dmb%c\t%U"},
  {ARM_EXT_V8, 0xf3bf8f41, 0xfffffff3, "dsb%c\t%U"},
a1694 3
/* Indicates that the current Conditional state is unconditional or outside
   an IT block.  */
#define COND_UNCOND 16
d1873 1
a1873 1
	    cond = COND_UNCOND;
d1882 1
a1882 1
	      cond = COND_UNCOND;
d1888 1
a1888 1
		cond = COND_UNCOND;
a1981 5
		case 'u':
		  if (cond != COND_UNCOND)
		    is_unpredictable = TRUE;

		  /* Fall through.  */
a2144 25
		      case 'c':
			switch (value)
			  {
			  case 0:
			    func (stream, "eq");
			    break;

			  case 1:
			    func (stream, "vs");
			    break;

			  case 2:
			    func (stream, "ge");
			    break;

			  case 3:
			    func (stream, "gt");
			    break;

			  default:
			    func (stream, "??");
			    break;
			  }
			break;

a2490 1
	  bfd_boolean is_unpredictable = FALSE;
a2502 5
		    case 'u':
		      if (thumb && ifthen_state)
			is_unpredictable = TRUE;

		      /* Fall through.  */
d2822 1
a2822 1

a2915 3
	  if (is_unpredictable)
	    func (stream, UNPREDICTABLE_INSTRUCTION);

a2967 22
/* Return the name of the DMB/DSB option.  */
static const char *
data_barrier_option (unsigned option)
{
  switch (option & 0xf)
    {
    case 0xf: return "sy";
    case 0xe: return "st";
    case 0xd: return "ld";
    case 0xb: return "ish";
    case 0xa: return "ishst";
    case 0x9: return "ishld";
    case 0x7: return "un";
    case 0x6: return "unst";
    case 0x5: return "nshld";
    case 0x3: return "osh";
    case 0x2: return "oshst";
    case 0x1: return "oshld";
    default:  return NULL;
    }
}

d3318 11
a3328 4
			  const char * opt = data_barrier_option (given & 0xf);
			  if (opt != NULL)
			    func (stream, "%s", opt);
			  else
d3330 2
a3349 5
			  case 'T':
			    /* We want register + 1 when decoding T.  */
			    if (*c == 'T')
			      ++value;

d4205 14
a4218 5
		    const char * opt = data_barrier_option (given & 0xf);
		    if (opt != NULL)
		      func (stream, "%s", opt);
		    else
		      func (stream, "#%d", (int) given & 0xf);
@


1.152.2.2
log
@gas/
2012-09-18  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* config/tc-arm.c: Changed ldra and strl-form mnemonics
	to lda and stl-form for armv8.

gas/testsuite/
2012-09-18  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

	* gas/arm/armv8-a-bad.l: Updated for changed mnemonics.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.
	* gas/arm/inst.s: Added test for ldrt encoding compatibly with ldralt.
	* gas/arm/inst.d: Updated.

opcodes/
2012-09-18  Kyrylo Tkachov  <kyrylo.tkachov@@arm.com>

        * arm-dis.c: Changed ldra and strl-form mnemonics
	to lda and stl-form.
@
text
@d892 14
a905 14
  {ARM_EXT_V8,	 0x01800e90, 0x0ff00ff0, "stlex%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01900e9f, 0x0ff00fff, "ldaex%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01a00e90, 0x0ff00ff0, "stlexd%c\t%12-15r, %0-3r, %0-3T, [%16-19R]"},
  {ARM_EXT_V8,	 0x01b00e9f, 0x0ff00fff, "ldaexd%c\t%12-15r, %12-15T, [%16-19R]"},
  {ARM_EXT_V8,	 0x01c00e90, 0x0ff00ff0, "stlexb%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01d00e9f, 0x0ff00fff, "ldaexb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01e00e90, 0x0ff00ff0, "stlexh%c\t%12-15r, %0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01f00e9f, 0x0ff00fff, "ldaexh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x0180fc90, 0x0ff0fff0, "stl%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01900c9f, 0x0ff00fff, "lda%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01c0fc90, 0x0ff0fff0, "stlb%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01d00c9f, 0x0ff00fff, "ldab%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01e0fc90, 0x0ff0fff0, "stlh%c\t%0-3r, [%16-19R]"},
  {ARM_EXT_V8,	 0x01f00c9f, 0x0ff00fff, "ldaexh%c\t%12-15r, [%16-19R]"},
d1478 14
a1491 14
  {ARM_EXT_V8, 0xe8c00f8f, 0xfff00fff, "stlb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00f9f, 0xfff00fff, "stlh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00faf, 0xfff00fff, "stl%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fc0, 0xfff00ff0, "stlexb%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fd0, 0xfff00ff0, "stlexh%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c00fe0, 0xfff00ff0, "stlex%c\t%0-3r, %12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8c000f0, 0xfff000f0, "stlexd%c\t%0-3r, %12-15r, %8-11r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00f8f, 0xfff00fff, "ldab%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00f9f, 0xfff00fff, "ldah%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00faf, 0xfff00fff, "lda%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fcf, 0xfff00fff, "ldaexb%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fdf, 0xfff00fff, "ldaexh%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d00fef, 0xfff00fff, "ldaex%c\t%12-15r, [%16-19R]"},
  {ARM_EXT_V8, 0xe8d000ff, 0xfff000ff, "ldaexd%c\t%12-15r, %8-11r, [%16-19R]"},
@


1.151
log
@	* arm-dis.c (arm_opcodes): Don't disassemble STMFD/LDMIA sp!, {reg}
	to PUSH/POP {reg}.

	* binutils-all/arm/objdump.exp:
	STMFD/LDMIA sp!, {reg} don't disassemble to PUSH/POP {reg} any longer.

	* gas/arm/stm-ldm.d: STMFD/LDMIA sp!, {reg} don't disassemble to
	PUSH/POP {reg} any longer.  Some new test cases have been added as well.
	* gas/arm/stm-ldm.s: Likewise.
@
text
@d3 2
a4 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010  Free Software Foundation, Inc.
d1929 1
a1929 1
				offset,
d1943 1
a1943 1
			      func (stream, ", #%d", offset);
d1951 1
a1951 1
				  offset);
d2262 1
a2262 1
		      func (stream, "%d", value);
d2387 1
a2387 1
	    func (stream, ", #%s%d", NEGATIVE_BIT_SET ? "-" : "", offset);
d2402 1
a2402 1
	  func (stream, "], #%s%d", NEGATIVE_BIT_SET ? "-" : "", offset);
d2424 1
a2424 1
		func (stream, ", #%s%d", NEGATIVE_BIT_SET ? "-" : "", offset);
d2442 1
a2442 1
		    NEGATIVE_BIT_SET ? "-" : "", offset);
d3040 1
a3040 1
				      NEGATIVE_BIT_SET ? "-" : "", offset);
d3051 1
a3051 1
				    NEGATIVE_BIT_SET ? "-" : "", offset);
d3230 1
a3230 1
				    value_in_comment,
d3242 1
a3242 1
				  func (stream, ", #%d", value_in_comment);
d3246 1
a3246 1
				func (stream, ", {%d}", offset);
d3288 1
a3288 1
			    func (stream, "(UNDEF: %lu)", sysm);
d3452 1
a3452 1
			    func (stream, "(UNDEF: %lu)", sysm);
d3611 1
a3611 1
		      func (stream, arm_regnames[14] /* "lr" */);
d3618 1
a3618 1
		      func (stream, arm_regnames[15] /* "pc" */);
d3684 1
a3684 1
			    func (stream, "%ld", reg);
d3689 1
a3689 1
			    func (stream, "%ld", reg << 1);
d3694 1
a3694 1
			    func (stream, "%ld", reg << 2);
d3708 1
a3708 1
			    func (stream, "0x%04lx", reg);
d4014 1
a4014 1
		    func (stream, "], #%d", offset);
d4018 1
a4018 1
			func (stream, ", #%d", offset);
d4247 1
a4247 1
		      func (stream, "(UNDEF: %lu)", sysm);
d4251 1
a4251 1
		    func (stream, psr_name (given & 0xff));
d4269 1
a4269 1
		      func (stream, "(UNDEF: %lu)", sm);
d4272 1
a4272 1
		  func (stream, psr_name (given & 0xff));
@


1.150
log
@	PR binutils/14006
	* arm-dis.c (print_insn): Fix detection of instruction mode in
	files containing multiple executable sections.
@
text
@d1162 16
d1181 17
d1201 1
@


1.149
log
@    Jie Zhang  <jie@@codesourcery.com>
    Julian Brown  <julian@@codesourcery.com>

    gas/
    * config/tc-arm.c (parse_shifter_operand): Fix handling
    of explicit rotation.
    (encode_arm_shifter_operand): Likewise.

    gas/testsuite/
    * gas/arm/adrl.d: Adjust.
    * gas/arm/immed2.d: New test.
    * gas/arm/immed2.s: New test.

    ld/testsuite/
    * ld-arm/cortex-a8-fix-b-plt.d: Adjust.
    * ld-arm/cortex-a8-fix-bcc-plt.d: Adjust.
    * ld-arm/cortex-a8-fix-bl-plt.d: Adjust.
    * ld-arm/cortex-a8-fix-bl-rel-plt.d: Adjust.
    * ld-arm/cortex-a8-fix-blx-plt.d: Adjust.
    * ld-arm/ifunc-1.dd: Adjust.
    * ld-arm/ifunc-2.dd: Adjust.
    * ld-arm/ifunc-3.dd: Adjust.
    * ld-arm/ifunc-4.dd: Adjust.
    * ld-arm/ifunc-5.dd: Adjust.
    * ld-arm/ifunc-6.dd: Adjust.
    * ld-arm/ifunc-7.dd: Adjust.
    * ld-arm/ifunc-8.dd: Adjust.
    * ld-arm/ifunc-9.dd: Adjust.
    * ld-arm/ifunc-10.dd: Adjust.
    * ld-arm/ifunc-14.dd: Adjust.
    * ld-arm/ifunc-15.dd: Adjust.
    * ld-arm/ifunc-16.dd: Adjust.

    opcodes/
    * arm-dis.c (print_insn_arm): Explicitly specify rotation
    if needed.
@
text
@d4700 13
a4712 3
      start = info->symtab_pos + 1;
      if (start < private_data->last_mapping_sym)
	start = private_data->last_mapping_sym;
@


1.148
log
@	* arm-dis.c (print_insn_arm): Revert previous, undocumented,
	accidental change.
@
text
@d3143 11
a3153 2
			  int rotate = (given & 0xf00) >> 7;
			  int immed = (given & 0xff);
d3155 5
a3159 4
			  immed = (((immed << (32 - rotate))
				    | (immed >> rotate)) & 0xffffffff);
			  func (stream, "#%d", immed);
			  value_in_comment = immed;
@


1.147
log
@	PR binutils/12329
	* avr-dis.c (avr_operand): Fix disassembly of ELPM, LPM and SPM
	insns using post-increment addressing.

	* avr.h (AVR_ISA_AVR6): Fix typo, adding AVR_ISA_SPMX.
@
text
@a2999 3
			  if (NEGATIVE_BIT_SET)
			    offset = - offset;

@


1.146
log
@	PR binutils/12752
	* arm-dis.c (print_insn_coprocessor): Use bfd_vma type for
	computing address offsets.
	(print_arm_address): Likewise.
	(print_insn_arm): Likewise.
	(print_insn_thumb16): Likewise.
	(print_insn_thumb32): Likewise.
@
text
@d3000 3
@


1.145
log
@	gas/
	* config/tc-arm.c (parse_address_main): Handle -0 offsets.
	(encode_arm_addr_mode_2): Set default sign of zero here ...
	(encode_arm_addr_mode_3): ... and here.
	(encode_arm_cp_address): ... and here.
	(md_apply_fix): Use default sign of zero here.

	gas/testsuite/
	* gas/arm/inst.d: Adjust for signed zero offsets.
	* gas/arm/ldst-offset0.d: New test.
	* gas/arm/ldst-offset0.s: New test.
	* gas/arm/offset-1.d: New test.
	* gas/arm/offset-1.s: New test.

	ld/testsuite/
	Adjust tests for zero offset formatting.
	* ld-arm/cortex-a8-fix-bcc-plt.d: Adjust.
	* ld-arm/farcall-arm-arm-pic-veneer.d: Adjust.
	* ld-arm/farcall-arm-thumb.d: Adjust.
	* ld-arm/farcall-group-size2.d: Adjust.
	* ld-arm/farcall-group.d: Adjust.
	* ld-arm/farcall-mix.d: Adjust.
	* ld-arm/farcall-mix2.d: Adjust.
	* ld-arm/farcall-mixed-lib-v4t.d: Adjust.
	* ld-arm/farcall-mixed-lib.d: Adjust.
	* ld-arm/farcall-thumb-arm-blx-pic-veneer.d: Adjust.
	* ld-arm/farcall-thumb-arm-pic-veneer.d: Adjust.
	* ld-arm/farcall-thumb-thumb.d: Adjust.
	* ld-arm/ifunc-10.dd: Adjust.
	* ld-arm/ifunc-3.dd: Adjust.
	* ld-arm/ifunc-4.dd: Adjust.
	* ld-arm/ifunc-5.dd: Adjust.
	* ld-arm/ifunc-6.dd: Adjust.
	* ld-arm/ifunc-7.dd: Adjust.
	* ld-arm/ifunc-8.dd: Adjust.
	* ld-arm/jump-reloc-veneers-long.d: Adjust.
	* ld-arm/tls-longplt-lib.d: Adjust.
	* ld-arm/tls-thumb1.d: Adjust.

	opcodes/
	* arm-dis.c (print_insn_coprocessor): Explicitly print #-0
	as address offset.
	(print_arm_address): Likewise. Elide positive #0 appropriately.
	(print_insn_arm): Likewise.
@
text
@d1876 1
a1876 1
  		    int offset = given & 0xff;
d2338 1
a2338 1
  int offset = 0;
d2998 1
a2998 1
			  int offset = ((given & 0xf00) >> 4) | (given & 0xf);
d3105 1
a3105 1
			int disp = (((given & 0xffffff) ^ 0x800000) - 0x800000);
d3622 1
a3622 1
			long reg;
d3911 1
a3911 1
		  int offset = 0;
d4088 1
a4088 1
		  int offset = 0;
d4106 1
a4106 1
		  int offset = 0;
@


1.144
log
@Fix spelling mistakes.
@
text
@d1896 2
d1909 2
d1914 3
a1916 1
			    func (stream, ", {%d}", offset);
a2346 3
      if (NEGATIVE_BIT_SET)
	offset = - offset;

d2349 7
a2355 2
	  /* Pre-indexed.  */
	  func (stream, ", #%d]", offset);
d2363 1
a2363 2
	  if (WRITEBACK_BIT_SET)
	    func (stream, "!");
d2367 1
a2367 1
	  func (stream, "], #%d", offset);
d2386 1
d2388 2
a2389 3
	      if (offset)
		func (stream, ", #%s%d",
		      NEGATIVE_BIT_SET ? "-" : "", offset);
d2393 1
a2393 2
	      func (stream, ", %s",
		    NEGATIVE_BIT_SET ? "-" : "");
d2404 1
d2406 2
a2407 5
	      if (offset)
		func (stream, "], #%s%d",
		      NEGATIVE_BIT_SET ? "-" : "", offset);
	      else
		func (stream, "]");
a2999 3
			  if (NEGATIVE_BIT_SET)
			    offset = - offset;

d3002 4
a3005 2
			      if (offset)
				func (stream, "[pc, #%d]\t; ", offset);
d3007 3
a3009 1
				func (stream, "[pc]\t; ");				
d3014 3
a3016 1
			      func (stream, "[pc], #%d", offset);
a3024 3
			  if (NEGATIVE_BIT_SET)
			    offset = - offset;

d3032 9
a3040 7
				  if (WRITEBACK_BIT_SET)
				    /* Immediate Pre-indexed.  */
				    /* PR 10924: Offset must be printed, even if it is zero.  */
				    func (stream, ", #%d", offset);
				  else if (offset)
				    /* Immediate Offset: printing zero offset is optional.  */
				    func (stream, ", #%d", offset);
d3068 4
a3071 1
				  func (stream, "], #%d", offset);
@


1.143
log
@	* config/tc-arm.c (v7m_psrs): Revert previous delta.

	* gas/arm/mrs-msr-thumb-v7e-m.s: Restore name of basepri_max
	register.
	* gas/arm/mrs-msr-thumb-v7e-m.d: Likewise.
	* gas/arm/arch7.d: Likewise.
	* gas/arm/arch7.s: Likewise.

	* arm-dis.c: Revert previous reversion.
@
text
@d4705 1
a4705 1
		 for a preceeding one.  */
d4765 1
a4765 1
		 for a preceeding one.  */
d4987 1
a4987 1
  fprintf (stream, "  no-force-thumb           Examine preceeding label to determine an insn's type\n\n");
@


1.142
log
@	* gas/arm/arch7.s: Fix typo basepri_max should be basepri_mask.
	* gas/arm/mrs-msr-thumb-v7e-m.s: Likewise.
	* gas/arm/arch7.d: Update expected disassembly.
	* gas/arm/attr-march-armv7.d: Remove Microcontroller tag.
	* gas/arm/blx-bad.d: Only run for ELF based targets.
	* gas/arm/mrs-msr-thumb-v6t2.d: Likewise.
	* gas/arm/vldm-arm.d: Likewise.
	* gas/arm/mrs-msr-thumb-v7-m.d: Likewise.
	Remove qualifiers from PSR and IAPSR regsiter names.
	* gas/arm/mrs-msr-thumb-v7e-m.d: Likewise.
	* gas/arm/thumb2_bcond.d: Update expected disassembly to allow for
	relaxing of branch insns.
	* gas/arm/thumb32.d: Fix whitespace problems in disassembly.

	* config/tc-arm.c (parse_psr): Use selected_cpu not cpu_variant to
	detect M-profile targets.
	(do_t_swi): Exclude v7 and higher variants from arm_ext_os test.
	(v7m_psrs): Fix typo: basepri_max should be basepri_mask.

	* arm-dis.c (psr_name): Revert previous delta.

	* arm.h (ARM_AEXT_V7_ARM): Remove ARM_EXT_OS from bitmask.
@
text
@d3725 1
a3725 1
    case 18: return "BASEPRI_MASK";
@


1.141
log
@	PR binutils/12534
	* arm-dis.c (thumb32_opcodes): Add %L suffix to LDRD and STRD insn
	patterns.
	(print_insn_thumb32): Handle %L.

	* gas/arm/thumb32.s: Add PC relative LDRD and STRD insns.
	* gas/arm/thumb32.l: Update expected output.
	* gas/arm/thumb32.d: Update expected disassembly.
@
text
@d3725 1
a3725 1
    case 18: return "BASEPRI_MAX";
a4194 9
		else if ((given & 0xff) <= 3)
		  {
		    func (stream, "%s_", psr_name (given & 0xff));
		    
		    if (given & 0x800)
		      func (stream, "nzcvq");
		    if (given & 0x400)
		      func (stream, "g");
		  }
@


1.140
log
@    gas/
    * config/tc-arm.c (parse_psr): Add LHS argument. Improve support
    for *APSR bitmasks.
    (operand_parse_code): Replace OP_PSR with OP_wPSR and OP_rPSR.
    Remove OP_RVC_PSR.
    (parse_operands): Likewise.
    (do_mrs): Tweak error message for constraint.
    (do_t_mrs): Update constraints for changes to APSR support.
    (do_t_msr): Likewise. Don't set PSR_f flag here.
    (psrs): Remove "g", "nzcvq", "nzcvqg".
    (insns): Tweak entries for msr and mrs instructions.

    opcodes/
    * arm-dis.c (psr_name): Fix typo for BASEPRI_MAX.
    (print_insn_thumb32): Add APSR bitmask support.

    gas/testsuite/
    * gas/arm/mrs-msr-thumb-v7-m.s: New.
    * gas/arm/mrs-msr-thumb-v7-m.d: New.
    * gas/arm/mrs-msr-thumb-v7-m-bad.d: New.
    * gas/arm/mrs-msr-thumb-v7-m-bad.l: New.
    * gas/arm/mrs-msr-thumb-v7-m-bad.s: New.
    * gas/arm/mrs-msr-thumb-v7e-m.d: New.
    * gas/arm/mrs-msr-thumb-v7e-m.s: New.
    * gas/arm/mrs-msr-arm-v7-a-bad.d: New.
    * gas/arm/mrs-msr-arm-v7-a-bad.l: New.
    * gas/arm/mrs-msr-arm-v7-a-bad.s: New.
    * gas/arm/mrs-msr-arm-v7-a.d: New.
    * gas/arm/mrs-msr-arm-v7-a.s: New.
    * gas/arm/mrs-msr-arm-v6.d: New.
    * gas/arm/mrs-msr-arm-v6.s: New.
    * gas/arm/mrs-msr-thumb-v6t2.d: New.
    * gas/arm/mrs-msr-thumb-v6t2.s: New.
    * gas/arm/arch7.d: Fix typo in disassembly for BASEPRI_MAX,
    bitmasks for IAPSR etc.
    * gas/arm/arch7.s: Specify bitmask for APSR writes.
    * gas/arm/archv6m.s: Likewise.
    * msr-imm-bad.l: Tweak expected disassembly in error message.
    * msr-reg-bad.l: Likewise.
    * msr-imm.d: Tweak expected disassembly.
    * msr-reg.d: Likewise.
    * msr-reg-thumb.d: Likewise.
    * msr-imm.s: Specify bitmask on APSR writes.
    * msr-reg.s: Add comment about deprecated usage.
@
text
@d1339 1
d1568 4
a1571 4
  {ARM_EXT_V6T2, 0xe9400000, 0xff500000, "strd%c\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]%21'!"},
  {ARM_EXT_V6T2, 0xe9500000, 0xff500000, "ldrd%c\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]%21'!"},
  {ARM_EXT_V6T2, 0xe8600000, 0xff700000, "strd%c\t%12-15r, %8-11r, [%16-19r], #%23`-%0-7W"},
  {ARM_EXT_V6T2, 0xe8700000, 0xff700000, "ldrd%c\t%12-15r, %8-11r, [%16-19r], #%23`-%0-7W"},
d4289 15
@


1.139
log
@2011-04-07  Paul Carroll<pcarroll@@codesourcery.com>

	opcodes/
	* arm-dis.c (print_insn): init vars moved into private_data structure.

	binutils/testsuite/
	* binutils-all/arm/simple.s: Demo issue with objdump with
	multiple input files
	* binutils-all/arm/objdump.exp: added new ARM test case code
@
text
@d3724 1
a3724 1
    case 18: return "BASEPRI_MASK";
d4194 9
@


1.138
log
@include/elf/
	* arm.h (R_ARM_IRELATIVE): New relocation.

bfd/
	* reloc.c (BFD_RELOC_ARM_IRELATIVE): New relocation.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (elf32_arm_howto_table_2): Rename existing definition
	to elf32_arm_howto_table_3 and replace with a single R_ARM_IRELATIVE
	entry.
	(elf32_arm_howto_from_type): Update accordingly.
	(elf32_arm_reloc_map): Map BFD_RELOC_ARM_IRELATIVE to R_ARM_IRELATIVE.
	(elf32_arm_reloc_name_lookup): Handle elf32_arm_howto_table_3.
	(arm_plt_info): New structure, split out from elf32_arm_link_hash_entry
	with an extra noncall_refcount field.
	(arm_local_iplt_info): New structure.
	(elf_arm_obj_tdata): Add local_iplt.
	(elf32_arm_local_iplt): New accessor macro.
	(elf32_arm_link_hash_entry): Replace plt_thumb_refcount,
	plt_maybe_thumb_refcount and plt_got_offset with an arm_plt_info.
	Change tls_type to a bitfield and add is_iplt.
	(elf32_arm_link_hash_newfunc): Update accordingly.
	(elf32_arm_allocate_local_sym_info): New function.
	(elf32_arm_create_local_iplt): Likewise.
	(elf32_arm_get_plt_info): Likewise.
	(elf32_arm_plt_needs_thumb_stub_p): Likewise.
	(elf32_arm_get_local_dynreloc_list): Likewise.
	(create_ifunc_sections): Likewise.
	(elf32_arm_copy_indirect_symbol): Update after the changes to
	elf32_arm_link_hash_entry.  Assert the is_iplt has not yet been set.
	(arm_type_of_stub): Add an st_type argument.  Use elf32_arm_get_plt_info
	to get PLT information.  Assert that all STT_GNU_IFUNC references
	are turned into PLT references.
	(arm_build_one_stub): Pass the symbol type to
	elf32_arm_final_link_relocate.
	(elf32_arm_size_stubs): Pass the symbol type to arm_type_of_stub.
	(elf32_arm_allocate_irelocs): New function.
	(elf32_arm_add_dynreloc): In static objects, use .rel.iplt for
	all R_ARM_IRELATIVE.
	(elf32_arm_allocate_plt_entry): New function.
	(elf32_arm_populate_plt_entry): Likewise.
	(elf32_arm_final_link_relocate): Add an st_type parameter.
	Set srelgot to null for static objects.  Use separate variables
	to record which st_value and st_type should be used when generating
	a dynamic relocation.  Use elf32_arm_get_plt_info to find the
	symbol's PLT information, setting has_iplt_entry, splt,
	plt_offset and gotplt_offset accordingly.  Check whether
	STT_GNU_IFUNC symbols should resolve to an .iplt entry, and change
	the relocation target accordingly.  Broaden assert to include
	.iplts.  Don't set sreloc for static relocations.  Assert that
	we only generate dynamic R_ARM_RELATIVE relocations for R_ARM_ABS32
	and R_ARM_ABS32_NOI.  Generate R_ARM_IRELATIVE relocations instead
	of R_ARM_RELATIVE relocations if the target is an STT_GNU_IFUNC
	symbol.  Pass the symbol type to arm_type_of_stub.  Conditionally
	resolve GOT references to the .igot.plt entry.
	(elf32_arm_relocate_section): Update the call to
	elf32_arm_final_link_relocate.
	(elf32_arm_gc_sweep_hook): Use elf32_arm_get_plt_info to get PLT
	information.  Treat R_ARM_REL32 and R_ARM_REL32_NOI as call
	relocations in shared libraries and relocatable executables.
	Count non-call PLT references.  Use elf32_arm_get_local_dynreloc_list
	to get the list of dynamic relocations for a local symbol.
	(elf32_arm_check_relocs): Always create ifunc sections.  Set isym
	at the same time as setting h.  Use elf32_arm_allocate_local_sym_info
	to allocate local symbol information.  Treat R_ARM_REL32 and
	R_ARM_REL32_NOI as call relocations in shared libraries and
	relocatable executables.  Record PLT information for local
	STT_GNU_IFUNC functions as well as global functions.   Count
	non-call PLT references.  Use elf32_arm_get_local_dynreloc_list
	to get the list of dynamic relocations for a local symbol.
	(elf32_arm_adjust_dynamic_symbol): Handle STT_GNU_IFUNC symbols.
	Don't remove STT_GNU_IFUNC PLTs unless all references have been
	removed.  Update after the changes to elf32_arm_link_hash_entry.
	(allocate_dynrelocs_for_symbol): Decide whether STT_GNU_IFUNC PLT
	entries should live in .plt or .iplt.  Check whether the .igot.plt
	and .got entries can be combined.  Use elf32_arm_allocate_plt_entry
	to allocate .plt and .(i)got.plt entries.  Detect which .got
	entries will need R_ARM_IRELATIVE relocations and use
	elf32_arm_allocate_irelocs to allocate them.  Likewise other
	non-.got dynamic relocations.
	(elf32_arm_size_dynamic_sections): Allocate .iplt, .igot.plt
	and dynamic relocations for local STT_GNU_IFUNC symbols.
	Check whether the .igot.plt and .got entries can be combined.
	Detect which .got entries will need R_ARM_IRELATIVE relocations
	and use elf32_arm_allocate_irelocs to allocate them.  Use stashed
	section pointers intead of strcmp checks.  Handle iplt and igotplt.
	(elf32_arm_finish_dynamic_symbol): Use elf32_arm_populate_plt_entry
	to fill in .plt, .got.plt and .rel(a).plt entries.  Point
	STT_GNU_IFUNC symbols at an .iplt entry if non-call relocations
	resolve to it.
	(elf32_arm_output_plt_map_1): New function, split out from
	elf32_arm_output_plt_map.  Handle .iplt entries.  Use
	elf32_arm_plt_needs_thumb_stub_p.
	(elf32_arm_output_plt_map): Call it.
	(elf32_arm_output_arch_local_syms): Add mapping symbols for
	local .iplt entries.
	(elf32_arm_swap_symbol_in): Handle Thumb STT_GNU_IFUNC symbols.
	(elf32_arm_swap_symbol_out): Likewise.
	(elf32_arm_add_symbol_hook): New function.
	(elf_backend_add_symbol_hook): Define for all targets.

opcodes/
	* arm-dis.c (get_sym_code_type): Treat STT_GNU_IFUNCs as code.

gas/
	* config/tc-arm.c (md_pcrel_from_section): Use S_FORCE_RELOC to
	determine whether a relocation is needed.
	(md_apply_fix, arm_apply_sym_value): Likewise.

ld/testsuite/
	* ld-arm/ifunc-1.s, ld-arm/ifunc-1.dd, ld-arm/ifunc-1.gd,
	ld-arm/ifunc-1.rd, ld-arm/ifunc-2.s, ld-arm/ifunc-2.dd,
	ld-arm/ifunc-2.gd, ld-arm/ifunc-2.rd, ld-arm/ifunc-3.s,
	ld-arm/ifunc-3.dd, ld-arm/ifunc-3.gd, ld-arm/ifunc-3.rd,
	ld-arm/ifunc-4.s, ld-arm/ifunc-4.dd, ld-arm/ifunc-4.gd,
	ld-arm/ifunc-4.rd, ld-arm/ifunc-5.s, ld-arm/ifunc-5.dd,
	ld-arm/ifunc-5.gd, ld-arm/ifunc-5.rd, ld-arm/ifunc-6.s,
	ld-arm/ifunc-6.dd, ld-arm/ifunc-6.gd, ld-arm/ifunc-6.rd,
	ld-arm/ifunc-7.s, ld-arm/ifunc-7.dd, ld-arm/ifunc-7.gd,
	ld-arm/ifunc-7.rd, ld-arm/ifunc-8.s, ld-arm/ifunc-8.dd,
	ld-arm/ifunc-8.gd, ld-arm/ifunc-8.rd, ld-arm/ifunc-9.s,
	ld-arm/ifunc-9.dd, ld-arm/ifunc-9.gd, ld-arm/ifunc-9.rd,
	ld-arm/ifunc-10.s, ld-arm/ifunc-10.dd, ld-arm/ifunc-10.gd,
	ld-arm/ifunc-10.rd, ld-arm/ifunc-11.s, ld-arm/ifunc-11.dd,
	ld-arm/ifunc-11.gd, ld-arm/ifunc-11.rd, ld-arm/ifunc-12.s,
	ld-arm/ifunc-12.dd, ld-arm/ifunc-12.gd, ld-arm/ifunc-12.rd,
	ld-arm/ifunc-13.s, ld-arm/ifunc-13.dd, ld-arm/ifunc-13.gd,
	ld-arm/ifunc-13.rd, ld-arm/ifunc-14.s, ld-arm/ifunc-14.dd,
	ld-arm/ifunc-14.gd, ld-arm/ifunc-14.rd, ld-arm/ifunc-15.s,
	ld-arm/ifunc-15.dd, ld-arm/ifunc-15.gd, ld-arm/ifunc-15.rd,
	ld-arm/ifunc-16.s, ld-arm/ifunc-16.dd, ld-arm/ifunc-16.gd,
	ld-arm/ifunc-16.rd, ld-arm/ifunc-dynamic.ld,
	ld-arm/ifunc-static.ld: New tests.
	* ld-arm/farcall-group.d, ld-arm/farcall-group-size2.d,
	ld-arm/farcall-mixed-lib-v4t.d, ld-arm/farcall-mixed-lib.d: Update
	for new stub hashes.
	* ld-arm/arm-elf.exp: Run them.
@
text
@d48 8
d64 7
a1659 12
/* Cached mapping symbol state.  */
enum map_type
{
  MAP_ARM,
  MAP_THUMB,
  MAP_DATA
};

enum map_type last_type;
int last_mapping_sym = -1;
bfd_vma last_mapping_addr = 0;

d4641 2
d4666 2
a4667 2
      if (start < last_mapping_sym)
	start = last_mapping_sym;
d4762 4
a4765 4
      last_mapping_sym = last_sym;
      last_type = type;
      is_thumb = (last_type == MAP_THUMB);
      is_data = (last_type == MAP_DATA);
@


1.137
log
@include/elf/
	* internal.h (elf_internal_sym): Add st_target_internal.
	* arm.h (arm_st_branch_type): New enum.
	(ARM_SYM_BRANCH_TYPE): New macro.

bfd/
	* elf-bfd.h (elf_link_hash_entry): Add target_internal.
	* elf.c (swap_out_syms): Set st_target_internal for each
	Elf_Internal_Sym.
	* elfcode.h (elf_swap_symbol_in): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Likewise.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* elflink.c (elf_link_output_extsym): Likewise.
	(bfd_elf_final_link): Likewise.
	(elf_link_add_object_symbols): Copy st_target_internal
	to the hash table if we see a definition.
	(_bfd_elf_copy_link_hash_symbol_type): Copy target_internal.
	* elf32-arm.c (elf32_arm_stub_hash_entry): Replace st_type with
	a branch_type field.
	(a8_erratum_fix, a8_erratum_reloc): Likewise.
	(arm_type_of_stub): Replace actual_st_type with an
	actual_branch_type parameter.
	(arm_build_one_stub): Use branch types rather than st_types to
	determine the type of branch.
	(cortex_a8_erratum_scan): Likewise.
	(elf32_arm_size_stubs): Likewise.
	(bfd_elf32_arm_process_before_allocation): Likewise.
	(allocate_dynrelocs_for_symbol): Likewise.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_final_link_relocate): Replace sym_flags parameter with
	a branch_type parameter.
	(elf32_arm_relocate_section): Update call accordingly.
	(elf32_arm_adjust_dynamic_symbol): Don't check STT_ARM_TFUNC.
	(elf32_arm_output_map_sym): Initialize st_target_internal.
	(elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_symbol_processing): Delete.
	(elf32_arm_swap_symbol_in): Convert STT_ARM_TFUNCs into STT_FUNCs.
	Use st_target_internal to record the branch type.
	(elf32_arm_swap_symbol_out): Use st_target_internal to test for
	Thumb functions.
	(elf32_arm_is_function_type): Delete.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_is_function_type): Likewise.

gas/
	* config/tc-arm.c (arm_adjust_symtab): Set the branch type
	for Thumb symbols.

ld/
	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Check
	eh->target_internal.

opcodes/
	* arm-dis.c (get_sym_code_type): Don't check for STT_ARM_TFUNC.
	Use branch types instead.
	(print_insn): Likewise.
@
text
@d4528 1
a4528 1
  if (type == STT_FUNC)
@


1.136
log
@	gas/testsuite/
	* gas/arm/blx-bad.s: New.
	* gas/arm/blx-bad.d: New.

	opcodes/
	* arm-dis.c (thumb32_opcodes): BLX must have bit zero clear.
@
text
@d4528 1
a4528 1
  if (type == STT_FUNC || type == STT_ARM_TFUNC)
d4530 4
a4533 1
      *map_type = (type == STT_ARM_TFUNC) ? MAP_THUMB : MAP_ARM;
d4813 3
a4815 1
	  is_thumb = (type == STT_ARM_TFUNC) || (type == STT_ARM_16BIT);
@


1.135
log
@2010-09-27  Tejas Belagod  <tejas.belagod@@arm.com>

	* gas/config/tc-arm.c (do_neon_ldr_str): Deprecate ARM-mode PC-relative
	VSTR, issue an error in THUMB mode.
	* opcodes/arm_dis.c (print_insn_coprocessor): Apply off-by-alignment
	correction to unaligned PCs while printing comment.
	* gas/testsuite/gas/arm/vldr.s: New test for pc-relative VLDR disassembly comment.
	* gas/testsuite/gas/arm/vldr.d: Likewise.
	* gas/testsuite/gas/arm/vstr-bad.s: New test for PC-relative VSTR.
	* gas/testsuite/gas/arm/vstr-thumb-bad.l: Likewise.
	* gas/testsuite/gas/arm/vstr-thumb-bad.d: Likewise.
	* gas/testsuite/gas/arm/vstr-arm-bad.l: Likewise.
	* gas/testsuite/gas/arm/vstr-arm-bad.d: Likewise.
@
text
@d1566 1
a1566 1
  {ARM_EXT_V4T,  0xf000c000, 0xf800d000, "blx%c\t%B%x"},
@


1.134
log
@	* bfd/bfd-in2.h (BFD_RELOC_ARM_HVC): New enum value.
	* gas/config/tc-arm.c (arm_ext_virt): New variable.
	(arm_reg_type): Add REG_TYPE_RNB for banked registers.
	(reg_entry): Allow registers to be larger than a byte.
	(reg_alias): Fix type warning.
	(parse_operands): Parse banked registers when appropriate.
	(do_mrs): Add support for Virtualization Extensions.
	(do_hvc): New function.
	(do_t_mrs): Add support for Virtualization Extensions.
	(do_t_msr): Likewise.
	(do_t_hvc): New function.
	(SPLRBANK): New define.
	(reg_names): Add banked registers.
	(insns): Add support for Virtualization Extensions.
	(md_apply_fixup): Likewise.
	(arm_cpus): -mcpu=cortex-a15 implies the Virtualization Extensions.
	(arm_extensions): Add 'virt' extension.
	(aeabi_set_public_attributes): Add support for Virtualization
	Extensions.
	* gas/doc/c-arm.texi: Document 'virt' extension.
	* gas/testsuite/gas/arm/armv7-a+virt.d: New test.
	* gas/testsuite/gas/arm/armv7-a+virt.s: Likewise.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for Virtualization Extensions.
	* gas/testsuite/gas/arm/attr-march-armv7-a+sec+virt.d: New test.
	* gas/testsuite/gas/arm/attr-march-armv7-a+virt.d: Likewise.
	* include/opcode/arm.h (ARM_EXT_VIRT): New define.
	(ARM_ARCH_V7A_IDIV_MP_SEC): Rename...
	(ARM_ARCH_V7A_IDIV_MP_SEC_VIRT): ...to this and include Virtualization
	Extensions.
	* opcodes/arm-dis.c (arm_opcodes): Add Virtualiztion Extensions support.
	(thumb32_opcodes): Likewise.
	(banked_regname): New function.
	(print_insn_arm): Add Virtualization Extensions support.
	(print_insn_thumb32): Likewise.
@
text
@d1913 6
a1918 2
			info->print_address_func (offset + pc
						  + info->bytes_per_chunk * 2, info);
@


1.133
log
@	* gas/config/tc-arm.c (arm_ext_adiv): New variable.
	(do_div): New function.
	(insns): Accept UDIV and SDIV in ARM state.
	(arm_cpus): The cortex-a15 option has all current v7-A extensions.
	(arm_extensions): Add 'idiv' extension.
	(aeabi_set_public_attributes): Update Tag_DIV_use values for the
	Integer Divide extension.
	* gas/doc/c-arm.texi: Document the idiv extension.
	* gas/testsuite/gas/arm/armv7-a+idiv.d: New test.
	* gas/testsuite/gas/arm/armv7-a+idiv.s: Likewise.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for Integer divide extension.
	* gas/testsuite/gas/arm/attr-march-armv7-a+idiv.d: New test.
	* include/opcode/arm.h (ARM_AEXT_ADIV): New define.
	(ARM_ARCH_V7A_IDIV_MP_SEC): Likewise.
	* opcodes/arm-dis.c (arm_opcodes): Support disassembly of UDIV and SDIV in
	ARM state.
@
text
@d819 2
a820 1
   %V                   print the 16-bit immediate field of a MOVT or MOVW instruction.  */
d833 4
d1099 3
a1101 2
  {ARM_EXT_V3, 0x0120f000, 0x0db0f000, "msr%c\t%22?SCPSR%C, %o"},
  {ARM_EXT_V3, 0x010f0000, 0x0fbf0fff, "mrs%c\t%12-15R, %22?SCPSR"},
a1111 1
  {ARM_EXT_V3, 0x01400000, 0x0ff00010, "mrs%c\t%12-15R, %22?SCPSR"},
d1321 1
d1369 4
d1393 1
a1393 1
  {ARM_EXT_V6T2, 0xf3ef8000, 0xffeff000, "mrs%c\t%8-11r, %D"},
d2875 46
d3215 26
a3240 9
		      func (stream, "_");
		      if (given & 0x80000)
			func (stream, "f");
		      if (given & 0x40000)
			func (stream, "s");
		      if (given & 0x20000)
			func (stream, "x");
		      if (given & 0x10000)
			func (stream, "c");
d3378 16
d3838 11
d4173 14
d4194 15
a4208 2
		if ((given & 0xff) == 0)
		  func (stream, "%cPSR", (given & 0x100000) ? 'S' : 'C');
@


1.132
log
@	* gas/config/tc-arm.c (arm_ext_v6z): Remove.
	(arm_ext_sec): New variable.
	(do_t_smc): In Thumb state SMC requires v7-A.
	(insns): Make SMC depend on Security Extensions.
	(arm_cpus): All -mcpu=cortex-a* options have the Security Extensions.
	(arm_extensions): Add 'sec' extension.
	(cpu_arch_ver): Reorder.
	(aeabi_set_public_attributes): Emit Tag_Virtualization_use as
	appropriate.
	* gas/doc/c-arm.texi: Document Security Extensions.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for Security Extensions..
	* gas/testsuite/gas/arm/attr-march-armv6k+sec.d: New test.
	* gas/testsuite/gas/arm/attr-march-armv6z.d: Update for Security Extensions.
	* gas/testsuite/gas/arm/attr-march-armv6zk.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6zkt2.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv6zt2.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv7-a+sec.d: New test.
	* gas/testsuite/gas/arm/attr-mcpu.d: Update for Security Extensions.
	* gas/testsuite/gas/arm/thumb32.d: Likewise.
	* gas/testsuite/gas/arm/thumb32.s: Likewise.
	* include/opcode/arm.h (ARM_EXT_V6Z): Remove.
	(ARM_EXT_SEC): New define.
	(ARM_AEXT_V6Z): Use Security Extensions.
	(ARM_AEXT_V6ZK): Likeiwse.
	(ARM_AEXT_V6ZT2): Likewise.
	(ARM_AEXT_V6ZKT2): Likewise.
	(ARM_AEXT_V7_ARM): Base v7 does not have Security Extensions.
	(ARM_ARCH_V7A_SEC): New define.
	(ARM_ARCH_V7A_MP): Rename...
	(ARM_ARCH_V7A_MP_SEC): ...to this and add Security Extensions.
	* ld/testsuite/ld-arm/attr-merge-6.attr: Update for Security Extensions.
	* ld/testsuite/ld-arm/attr-merge-7.attr: Likewise.
	* opcodes/arm-dis.c (arm_opcodes): SMC implies Security Extensions.
	(thumb32_opcodes): Likewise.
@
text
@d832 4
@


1.131
log
@	* gas/config/tc-arm.c (arm_ext_mp): Add.
	(do_pld): Update comment.
	(insns): Add support for pldw.
	(arm_cpus): Update cortex-a5, cortex-a9, and cortex-a15 to support
	MP extension.
	(arm_extensions): Add 'mp' extension.
	(aeabi_set_public_attributes): Emit correct build attribute when
	MP extension is enabled.
	* gas/doc/c-arm.texi: Update for MP extensions.
	* gas/testsuite/gas/arm/arch7a-mp.d: Add.
	* gas/testsuite/gas/arm/arch7ar-mp.s: Likewise.
	* gas/testsuite/gas/arm/arch7r-mp.d: Likewise.
	* gas/testsuite/gas/arm/armv2-mp-bad.d: Likewise.
	* gas/testsuite/gas/arm/armv2-mp-bad.l: Likewise.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for MP extension.
	* gas/testsuite/gas/arm/attr-march-armv7-a+mp.d: Add.
	* gas/testsuite/gas/arm/attr-march-armv7-r+mp.d: Likewise.
	* include/opcode/arm.h (ARM_EXT_MP): Add.
	(ARM_ARCH_V7A_MP): Likewise.
	* opcodes/arm-dis.c (arm_opcodes): Add support for pldw.
	(thumb32_opcodes): Likewise.
@
text
@d856 2
a857 2
  /* ARM V6Z instructions.  */
  {ARM_EXT_V6Z, 0x01600070, 0x0ff000f0, "smc%c\t%e"},
d1362 3
a1485 1
  {ARM_EXT_V6T2, 0xf7f08000, 0xfff0f000, "smc%c\t%K"},
@


1.130
log
@2010-09-17  Tejas Belagod  <tejas.belagod@@arm.com>

	* config/tc-arm.c (insns): Change MRC entry to accept APSR_RR instead
	of just RR.

2010-09-17  Tejas Belagod  <tejas.belagod@@arm.com>

	* gas/arm/copro.s: Add test for APSR_nzcv as a MRC operand.
	* gas/arm/copro.d: Change pc in MRC to disassemble as APSR_nzcv.  Also
	add disassembly for test added in copro.s

2010-09-17  Tejas Belagod  <tejas.belagod@@arm.com>

	* arm_dis.c (coprocessor_opcodes): Add MRC entry for APSR_nzcv.
@
text
@d832 3
d1359 3
@


1.129
log
@2010-07-08 Tejas Belagod <tejas.belagod@@arm.com>

	gas/testsuite
	* gas/arm/barrier.s: New file.
	* gas/arm/barrier.d: New file.
	* gas/arm/barrier-thumb.s: New file.
	* gas/arm/barrier-thumb.d: New file.
	* gas/arm/barrier-bad.s: New file.
	* gas/arm/barrier-bad.d: New file.
	* gas/arm/barrier-bad.l: New file.
	* gas/arm/barrier-bad-thumb.s: New file.
	* gas/arm/barrier-bad-thumb.d: New file.
	* gas/arm/barrier-bad-thumb.l: New file.

	gas/config
	* tc-arm.c (OP_oBARRIER): Remove.
	(OP_oBARRIER_I15): Add.
	(po_barrier_or_imm): Add macro.
	(parse_operands): Improve OP_oBARRIER_I15 operand parsing.
	(do_barrier): Check correct immediate range.
	(do_t_barrier): Likewise.
	(barrier_opt_names): Add entries for more symbolic operands.
	(insns): Replace OP_oBARRIER with OP_oBARRIER_I15 for barriers.

	opcodes/
	* arm-dis.c (print_insn_arm): Add cases for printing more
	symbolic operands.
	(print_insn_thumb32): Likewise.
@
text
@d477 1
@


1.128
log
@	* gas/config/tc-arm.c (parse_neon_alignment): New function.
	(parse_address_main): Fix Neon load/store alignment parsing.
	* gas/testsuite/gas/arm/neon-ldst-align-bad.l: Update for Neon alignment syntax fix.
	* gas/testsuite/gas/arm/neon-ldst-align-bad.s: Likewise.
	* gas/testsuite/gas/arm/neon-ldst-es.d: Likewise.
	* gas/testsuite/gas/arm/neon-ldst-es.s: Likewise.
	* opcodes/arm-disc.c (parse_insn_neon):  Fix Neon alignment syntax.
@
text
@d3158 1
a3158 1
		      switch (given & 0xf)
d3160 24
a3183 7
			case 0xf: func (stream, "sy"); break;
			case 0x7: func (stream, "un"); break;
			case 0xe: func (stream, "st"); break;
			case 0x6: func (stream, "unst"); break;
			default:
			  func (stream, "#%d", (int) given & 0xf);
			  break;
d4018 1
a4018 1
		switch (given & 0xf)
d4020 7
a4026 7
		  case 0xf: func (stream, "sy"); break;
		  case 0x7: func (stream, "un"); break;
		  case 0xe: func (stream, "st"); break;
		  case 0x6: func (stream, "unst"); break;
		  default:
		    func (stream, "#%d", (int) given & 0xf);
		    break;
d4028 17
@


1.127
log
@	* gas/testsuite/gas/arm/thumb-eabi.d: Add case for divided syntax encoding of movs.
	* gas/testsuite/gas/arm/thumb.d: Likewise.
	* gas/testsuite/gas/arm/thumb.s: Likewise.
	* gas/testsuite/gas/arm/thumb2_it.d: Update for change in lsls/movs disassembly.
	* gas/testsuite/gas/arm/thumb2_it_auto.d: Liekwise.
	* gas/testsuite/gas/arm/thumb32.d: Likewise.
	* ld/testsuite/ld-arm/arm-call.d: Handle change in lsls/movs disassembly.
	* ld/testsuite/ld-arm/farcall-thumb-arm-short.d: Likewise.
	* ld/testsuite/ld-arm/farcall-thumb-thumb-blx-pic-veneer.d: Likewise.
	* ld/testsuite/ld-arm/farcall-thumb-thumb-blx.d: Likewise.
	* ld/testsuite/ld-arm/farcall-thumb-thumb-m-pic-veneer.d: Likewise.
	* ld/testsuite/ld-arm/farcall-thumb-thumb-m.d: Likewise.
	* ld/testsuite/ld-arm/farcall-thumb-thumb-pic-veneer.d: Likewise.
	* ld/testsuite/ld-arm/farcall-thumb-thumb.d: Likewise.
	* ld/testsuite/ld-arm/thumb2-bl-as-thumb1-bad-noeabi.d: Likewise.
	* ld/testsuite/ld-arm/thumb2-bl-as-thumb1-bad.d: Likewise.
	* ld/testsuite/ld-arm/thumb2-bl-bad-noeabi.d: Likewise.
	* ld/testsuite/ld-arm/thumb2-bl-bad.d: Likewise.
	* opcodes/arm-dis.c (thumb-opcodes): Add disassembly for movs.
@
text
@d2473 1
a2473 1
			  func (stream, ", :%d", 32 << align);
d2548 1
a2548 1
			  func (stream, ", :%d", align);
d2589 1
a2589 1
			      func (stream, ", :<bad align %d>", align);
d2591 1
a2591 1
			      func (stream, ", :%d", align);
@


1.126
log
@	* opcodes/arm-dis.c (print_insn_neon):  Ensure disassembly of Neon
	constants is the same on 32-bit and 64-bit hosts.
@
text
@d1252 1
@


1.125
log
@2010-05-10  Andrew Stubbs  <ams@@codesourcery.com>

        gas/
        * config/tc-arm.c (aeabi_set_public_attributes): Set Tag_DIV_use.

        gas/testsuite/
        * gas/arm/attr-cpu-directive.d: Add Tag_DIV_use.
        * gas/arm/attr-default.d: Likewise.
        * gas/arm/attr-march-armv1.d: Likewise.
        * gas/arm/attr-march-armv2.d: Likewise.
        * gas/arm/attr-march-armv2a.d: Likewise.
        * gas/arm/attr-march-armv2s.d: Likewise.
        * gas/arm/attr-march-armv3.d: Likewise.
        * gas/arm/attr-march-armv3m.d: Likewise.
        * gas/arm/attr-march-armv4.d: Likewise.
        * gas/arm/attr-march-armv4t.d: Likewise.
        * gas/arm/attr-march-armv4txm.d: Likewise.
        * gas/arm/attr-march-armv4xm.d: Likewise.
        * gas/arm/attr-march-armv5.d: Likewise.
        * gas/arm/attr-march-armv5t.d: Likewise.
        * gas/arm/attr-march-armv5te.d: Likewise.
        * gas/arm/attr-march-armv5tej.d: Likewise.
        * gas/arm/attr-march-armv5texp.d: Likewise.
        * gas/arm/attr-march-armv5txm.d: Likewise.
        * gas/arm/attr-march-armv6-m.d: Likewise.
        * gas/arm/attr-march-armv6.d: Likewise.
        * gas/arm/attr-march-armv6j.d: Likewise.
        * gas/arm/attr-march-armv6k.d: Likewise.
        * gas/arm/attr-march-armv6kt2.d: Likewise.
        * gas/arm/attr-march-armv6t2.d: Likewise.
        * gas/arm/attr-march-armv6z.d: Likewise.
        * gas/arm/attr-march-armv6zk.d: Likewise.
        * gas/arm/attr-march-armv6zkt2.d: Likewise.
        * gas/arm/attr-march-armv6zt2.d: Likewise.
        * gas/arm/attr-march-armv7-a.d: Likewise.
        * gas/arm/attr-march-armv7.d: Likewise.
        * gas/arm/attr-march-armv7a.d: Likewise.
        * gas/arm/attr-march-iwmmxt.d: Likewise.
        * gas/arm/attr-march-iwmmxt2.d: Likewise.
        * gas/arm/attr-march-marvell-f.d: Likewise.
        * gas/arm/attr-march-xscale.d: Likewise.
        * gas/arm/attr-mcpu.d: Likewise.
        * gas/arm/attr-mfpu-arm1020e.d: Likewise.
        * gas/arm/attr-mfpu-arm1020t.d: Likewise.
        * gas/arm/attr-mfpu-arm1136jf-s.d: Likewise.
        * gas/arm/attr-mfpu-arm1136jfs.d: Likewise.
        * gas/arm/attr-mfpu-arm7500fe.d: Likewise.
        * gas/arm/attr-mfpu-fpa.d: Likewise.
        * gas/arm/attr-mfpu-fpa10.d: Likewise.
        * gas/arm/attr-mfpu-fpa11.d: Likewise.
        * gas/arm/attr-mfpu-fpe.d: Likewise.
        * gas/arm/attr-mfpu-fpe2.d: Likewise.
        * gas/arm/attr-mfpu-fpe3.d: Likewise.
        * gas/arm/attr-mfpu-maverick.d: Likewise.
        * gas/arm/attr-mfpu-neon-fp16.d: Likewise.
        * gas/arm/attr-mfpu-neon.d: Likewise.
        * gas/arm/attr-mfpu-softfpa.d: Likewise.
        * gas/arm/attr-mfpu-softvfp+vfp.d: Likewise.
        * gas/arm/attr-mfpu-softvfp.d: Likewise.
        * gas/arm/attr-mfpu-vfp.d: Likewise.
        * gas/arm/attr-mfpu-vfp10-r0.d: Likewise.
        * gas/arm/attr-mfpu-vfp10.d: Likewise.
        * gas/arm/attr-mfpu-vfp3.d: Likewise.
        * gas/arm/attr-mfpu-vfp9.d: Likewise.
        * gas/arm/attr-mfpu-vfpv2.d: Likewise.
        * gas/arm/attr-mfpu-vfpv3-d16.d: Likewise.
        * gas/arm/attr-mfpu-vfpv3.d: Likewise.
        * gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
        * gas/arm/attr-mfpu-vfpv4.d: Likewise.
        * gas/arm/attr-mfpu-vfpxd.d: Likewise.
        * gas/arm/attr-order.d: Likewise.
        * gas/arm/attr-override-cpu-directive.d: Likewise.
        * gas/arm/attr-override-mcpu.d: Likewise.
        * gas/arm/eabi_attr_1.d: Likewise.

        ld/testsuite/
        * ld-arm/attr-merge-2.attr: Add Tag_DIV_use.
        * ld-arm/attr-merge-2a.s: Likewise.
        * ld-arm/attr-merge-2b.s: Likewise.
        * ld-arm/attr-merge-3a.s: Likewise.
        * ld-arm/attr-merge-3b.s: Likewise.
        * ld-arm/attr-merge-4.attr: Likewise.
        * ld-arm/attr-merge-5.attr: Likewise.
        * ld-arm/attr-merge-6.attr: Likewise.
        * ld-arm/attr-merge-7.attr: Likewise.
        * ld-arm/attr-merge-arch-1.attr: Likewise.
        * ld-arm/attr-merge-arch-2.attr: Likewise.
        * ld-arm/attr-merge-unknown-2.d: Likewise.
        * ld-arm/attr-merge-unknown-2r.d: Likewise.
        * ld-arm/attr-merge-unknown-3.d: Likewise.
        * ld-arm/attr-merge-vfp-1.d: Likewise.
        * ld-arm/attr-merge-vfp-1r.d: Likewise.
        * ld-arm/attr-merge-vfp-2.d: Likewise.
        * ld-arm/attr-merge-vfp-2r.d: Likewise.
        * ld-arm/attr-merge-vfp-3.d: Likewise.
        * ld-arm/attr-merge-vfp-3r.d: Likewise.
        * ld-arm/attr-merge-vfp-4.d: Likewise.
        * ld-arm/attr-merge-vfp-4r.d: Likewise.
        * ld-arm/attr-merge-vfp-5.d: Likewise.
        * ld-arm/attr-merge-vfp-5r.d: Likewise.
        * ld-arm/attr-merge-wchar-00-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-00.d: Likewise.
        * ld-arm/attr-merge-wchar-02-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-02.d: Likewise.
        * ld-arm/attr-merge-wchar-04-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-04.d: Likewise.
        * ld-arm/attr-merge-wchar-20-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-20.d: Likewise.
        * ld-arm/attr-merge-wchar-22-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-22.d: Likewise.
        * ld-arm/attr-merge-wchar-24-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-40-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-40.d: Likewise.
        * ld-arm/attr-merge-wchar-42-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-44-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-44.d: Likewise.
        * ld-arm/attr-merge.attr: Likewise.

2010-04-07  Jie Zhang  <jie@@codesourcery.com>

        gas/
        * config/tc-arm.c (aeabi_set_public_attributes): Set
        Tag_ABI_HardFP_use to 1 if a single precision FPU is selected.

        gas/testsuite/
        * gas/arm/attr-mfpu-vfpxd.d: New test.

        bfd/
        * elf32-arm.c (elf32_arm_merge_eabi_attributes): Merge
        Tag_ABI_HardFP_use correctly.

        ld/testsuite/
        * ld-arm/attr-merge-vfp-6.d: New test.
        * ld-arm/attr-merge-vfp-6r.d: New test.
        * ld-arm/attr-merge-vfpv3xd.s: New test.
        * ld-arm/arm-elf.exp: Add attr-merge-vfp-6 and attr-merge-vfp-6r.

2010-05-11  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>

        * arm-dis.c (thumb_opcodes): Update ldmia entry to use new %W
        format.
        (print_insn_thumb16): Add support for new %W format.

        * gas/arm/thumb32.d: Fix expected disassembly of ldmia
          instruction.
@
text
@d2723 2
a2724 1
				    (long) (NEGATIVE_BIT_SET ? value | ~0xffffffffL : value),
@


1.124
log
@        PR binutils/6773
        * arm-dis.c (arm_opcodes): Replace <prefix>addsubx with
        <prefix>asx.  Replace <prefix>subaddx with <prefix>sax.
        (thumb32_opcodes): Likewise.

        * gas/arm/arch7em.d: Replace expected disassembly of
        <prefix>addsubx with <prefix>asx.  Also replace <prefix>subaddx
        with <prefix>sax.
        * gas/arm/archv6.d: Likewise.
        * gas/arm/thumb32.d: Likewise.
@
text
@d1164 1
d1278 1
a1278 1
  {ARM_EXT_V4T, 0xC800, 0xF800, "ldmia%c\t%8-10r!, %M"},
d3442 8
@


1.123
log
@	gas/testsuite/
	* gas/arm/dis-data.d: Update test name.  Do not expect
	.word output.
	* gas/arm/dis-data2.d, gas/arm/dis-data2.s,
	gas/arm/dis-data3.d, gas/arm/dis-data3.s: New tests.

	opcodes/
	* opcodes/arm-dis.c (struct arm_private_data): New.
	(print_insn_coprocessor, print_insn_arm): Update to use struct
	arm_private_data.
	(is_mapping_symbol, get_map_sym_type): New functions.
	(get_sym_code_type): Check the symbol's section.  Do not check
	mapping symbols.
	(print_insn): Default to disassembling ARM mode code.  Check
	for mapping symbols separately from other symbols.  Use
	struct arm_private_data.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
d884 1
a884 1
  {ARM_EXT_V6, 0x06200f30, 0x0ff00ff0, "qaddsubx%c\t%12-15R, %16-19R, %0-3R"},
d887 1
a887 1
  {ARM_EXT_V6, 0x06200f50, 0x0ff00ff0, "qsubaddx%c\t%12-15R, %16-19R, %0-3R"},
d890 1
a890 1
  {ARM_EXT_V6, 0x06100f30, 0x0ff00ff0, "saddaddx%c\t%12-15R, %16-19R, %0-3R"},
d893 1
a893 1
  {ARM_EXT_V6, 0x06300f30, 0x0ff00ff0, "shaddsubx%c\t%12-15R, %16-19R, %0-3R"},
d896 1
a896 1
  {ARM_EXT_V6, 0x06300f50, 0x0ff00ff0, "shsubaddx%c\t%12-15R, %16-19R, %0-3R"},
d899 1
a899 1
  {ARM_EXT_V6, 0x06100f50, 0x0ff00ff0, "ssubaddx%c\t%12-15R, %16-19R, %0-3R"},
d902 1
a902 1
  {ARM_EXT_V6, 0x06500f30, 0x0ff00ff0, "uaddsubx%c\t%12-15R, %16-19R, %0-3R"},
d905 1
a905 1
  {ARM_EXT_V6, 0x06700f30, 0x0ff00ff0, "uhaddsubx%c\t%12-15R, %16-19R, %0-3R"},
d908 1
a908 1
  {ARM_EXT_V6, 0x06700f50, 0x0ff00ff0, "uhsubaddx%c\t%12-15R, %16-19R, %0-3R"},
d911 1
a911 1
  {ARM_EXT_V6, 0x06600f30, 0x0ff00ff0, "uqaddsubx%c\t%12-15R, %16-19R, %0-3R"},
d914 1
a914 1
  {ARM_EXT_V6, 0x06600f50, 0x0ff00ff0, "uqsubaddx%c\t%12-15R, %16-19R, %0-3R"},
d917 1
a917 1
  {ARM_EXT_V6, 0x06500f50, 0x0ff00ff0, "usubaddx%c\t%12-15R, %16-19R, %0-3R"},
d1407 6
a1412 6
  {ARM_EXT_V6T2, 0xfaa0f000, 0xfff0f0f0, "saddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f010, 0xfff0f0f0, "qaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f020, 0xfff0f0f0, "shaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f040, 0xfff0f0f0, "uaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f050, 0xfff0f0f0, "uqaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f060, 0xfff0f0f0, "uhaddsubx%c\t%8-11r, %16-19r, %0-3r"},
d1427 6
a1432 6
  {ARM_EXT_V6T2, 0xfae0f000, 0xfff0f0f0, "ssubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f010, 0xfff0f0f0, "qsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f020, 0xfff0f0f0, "shsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f040, 0xfff0f0f0, "usubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f050, 0xfff0f0f0, "uqsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f060, 0xfff0f0f0, "uhsubaddx%c\t%8-11r, %16-19r, %0-3r"},
@


1.122
log
@        PR 11170
        * arm-dis.c (print_arm_address): Do not ignore negative bit in PC
        based post-indexed addressing.
@
text
@d48 10
d1763 2
a1764 1
  unsigned long allowed_arches = ((arm_feature_set *) info->private_data)->coproc;
d1790 1
a1790 1
	    allowed_arches = ((arm_feature_set *) info->private_data)->core;
d2857 1
d2870 1
a2870 1
      if ((insn->arch & ((arm_feature_set *) info->private_data)->core) == 0)
d3072 1
a3072 1
			  if (((((arm_feature_set *) info->private_data)->core) & ARM_EXT_V6) == 0)
d4283 38
a4320 1
/* Try to infer the code type (Arm or Thumb) from a symbol.
d4330 4
a4333 1
  const char *name;
a4344 11
  /* Check for mapping symbols.  */
  name = bfd_asymbol_name (info->symtab[n]);
  if (name[0] == '$' && (name[1] == 'a' || name[1] == 't' || name[1] == 'd')
      && (name[2] == 0 || name[2] == '.'))
    {
      *map_type = ((name[1] == 'a') ? MAP_ARM
		   : (name[1] == 't') ? MAP_THUMB
		   : MAP_DATA);
      return TRUE;
    }

d4399 1
a4399 2
  int           is_data = (bfd_asymbol_flavour (*info->symtab)
			   == bfd_target_elf_flavour) ? TRUE : FALSE;
d4404 1
d4417 1
a4417 1
      static arm_feature_set features;
d4443 1
a4443 1
      select_arm_features (info->mach, & features);
d4445 3
a4447 1
      info->private_data = & features;
d4449 3
a4451 1
  
d4456 2
a4457 2
  /* First check the full symtab for a mapping symbol, even if there
     are no usable non-mapping symbols for this address.  */
d4462 1
a4462 1
      int n;
d4464 1
a4464 1
      enum map_type type = MAP_DATA;
a4465 4
      if (pc <= last_mapping_addr)
	last_mapping_sym = -1;
      is_thumb = (last_type == MAP_THUMB);
      found = FALSE;
d4468 4
a4471 3
      n = info->symtab_pos + 1;
      if (n < last_mapping_sym)
	n = last_mapping_sym;
d4473 2
a4474 2
      /* Scan up to the location being disassembled.  */
      for (; n < info->symtab_size; n++)
d4476 50
a4525 6
	  addr = bfd_asymbol_value (info->symtab[n]);
	  if (addr > pc)
	    break;
	  if ((info->section == NULL
	       || info->section == info->symtab[n]->section)
	      && get_sym_code_type (info, n, &type))
d4527 1
a4527 1
	      last_sym = n;
d4532 2
d4536 2
a4537 7
	  n = info->symtab_pos;
	  if (n < last_mapping_sym - 1)
	    n = last_mapping_sym - 1;

	  /* No mapping symbol found at this address.  Look backwards
	     for a preceeding one.  */
	  for (; n >= 0; n--)
d4539 4
a4542 3
	      if ((info->section == NULL
		   || info->section == info->symtab[n]->section)
		  && get_sym_code_type (info, n, &type))
d4546 15
a4560 1
		  break;
@


1.121
log
@    * arm-dis.c (print_insn): Fixed search for next
    symbol and data dumping condition, and the
    initial mapping symbol state.

    * gas/arm/dis-data.d: New test case.
    * gas/arm/dis-data.s: New file.
@
text
@d2297 3
a2301 3
	  if (NEGATIVE_BIT_SET)
	    offset = - offset;

@


1.120
log
@        PR 11123
        * arm-dis.c (print_insn_coprocessor): Initialise value.
@
text
@d4358 2
a4359 1
  int           is_data = FALSE;
d4419 1
a4419 1
      enum map_type type = MAP_ARM;
d4482 3
a4484 1
	      if (addr > pc)
@


1.119
log
@        PR binutils/10924
        * config/tc-arm.c (do_ldstv4): Do not allow r15 as the destination
        register.
        (do_mrs): Likewise.
        (do_mul): Likewise.

        * arm-dis.c: Add support for %<>ru and %<>rU formats to enforce
        unique register numbers.  Extend support for %<>R format to
        thumb32 and coprocessor instructions.

        * gas/arm/unpredictable.s: Add more unpredictable instructions.
        * gas/arm/unpredictable.d: Add expected disassemblies.
@
text
@d1752 1
a1752 1
  unsigned long value;
@


1.118
log
@        PR binutils/10924
        * arm-dis.c (arm_opcodes): Specify %R in cases where using r15
        results in unpredictable behaviour.
        (print_insn_arm): Handle %R.

        * gas/arm/unpredictable.s: New test case - checks the disassembly
        of instructions with unpredictable behaviour.
        * gas/arm/unpredictable.d: New file - expected disassembly.
@
text
@d79 2
d464 2
a465 2
  {ARM_EXT_V5E, 0x0c400000, 0x0ff00000, "mcrr%c\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
  {ARM_EXT_V5E, 0x0c500000, 0x0ff00000, "mrrc%c\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
d468 1
a468 1
  {ARM_EXT_V2, 0x0e000010, 0x0f100010, "mcr%c\t%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, {%5-7d}"},
d473 2
a474 2
  {ARM_EXT_V6, 0xfc500000, 0xfff00000, "mrrc2%c\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
  {ARM_EXT_V6, 0xfc400000, 0xfff00000, "mcrr2%c\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
d480 1
a480 1
  {ARM_EXT_V5, 0xfe000010, 0xff100010, "mcr2%c\t%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, {%5-7d}"},
d794 3
a796 1
   %<bitfield>R		as %<bitfield>r but r15 is UNPREDICTABLE
d817 3
a819 3
  {ARM_EXT_V2S, 0x01000090, 0x0fb00ff0, "swp%22'b%c\t%12-15R, %0-3R, [%16-19R]"},
  {ARM_EXT_V3M, 0x00800090, 0x0fa000f0, "%22?sumull%20's%c\t%12-15R, %16-19R, %0-3R, %8-11R"},
  {ARM_EXT_V3M, 0x00a00090, 0x0fa000f0, "%22?sumlal%20's%c\t%12-15R, %16-19R, %0-3R, %8-11R"},
d829 4
a832 4
  {ARM_EXT_V6T2, 0x07c0001f, 0x0fe0007f, "bfc%c\t%12-15r, %E"},
  {ARM_EXT_V6T2, 0x07c00010, 0x0fe00070, "bfi%c\t%12-15r, %0-3r, %E"},
  {ARM_EXT_V6T2, 0x00600090, 0x0ff000f0, "mls%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6T2, 0x006000b0, 0x0f7000f0, "strht%c\t%12-15r, %S"},
d835 1
a835 1
  {ARM_EXT_V6T2, 0x00300090, 0x0f300090, "ldr%6's%5?hbt%c\t%12-15r, %S"},
d837 3
a839 3
  {ARM_EXT_V6T2, 0x03000000, 0x0ff00000, "movw%c\t%12-15r, %V"},
  {ARM_EXT_V6T2, 0x03400000, 0x0ff00000, "movt%c\t%12-15r, %V"},
  {ARM_EXT_V6T2, 0x06ff0f30, 0x0fff0ff0, "rbit%c\t%12-15r, %0-3r"},
d847 6
a852 6
  {ARM_EXT_V6K, 0x01d00f9f, 0x0ff00fff, "ldrexb%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6K, 0x01b00f9f, 0x0ff00fff, "ldrexd%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6K, 0x01f00f9f, 0x0ff00fff, "ldrexh%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6K, 0x01c00f90, 0x0ff00ff0, "strexb%c\t%12-15r, %0-3r, [%16-19r]"},
  {ARM_EXT_V6K, 0x01a00f90, 0x0ff00ff0, "strexd%c\t%12-15r, %0-3r, [%16-19r]"},
  {ARM_EXT_V6K, 0x01e00f90, 0x0ff00ff0, "strexh%c\t%12-15r, %0-3r, [%16-19r]"},
d867 44
a910 44
  {ARM_EXT_V6, 0x06800010, 0x0ff00ff0, "pkhbt%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06800010, 0x0ff00070, "pkhbt%c\t%12-15r, %16-19r, %0-3r, lsl #%7-11d"},
  {ARM_EXT_V6, 0x06800050, 0x0ff00ff0, "pkhtb%c\t%12-15r, %16-19r, %0-3r, asr #32"},
  {ARM_EXT_V6, 0x06800050, 0x0ff00070, "pkhtb%c\t%12-15r, %16-19r, %0-3r, asr #%7-11d"},
  {ARM_EXT_V6, 0x01900f9f, 0x0ff00fff, "ldrex%c\tr%12-15d, [%16-19r]"},
  {ARM_EXT_V6, 0x06200f10, 0x0ff00ff0, "qadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06200f90, 0x0ff00ff0, "qadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06200f30, 0x0ff00ff0, "qaddsubx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06200f70, 0x0ff00ff0, "qsub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06200ff0, 0x0ff00ff0, "qsub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06200f50, 0x0ff00ff0, "qsubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100f10, 0x0ff00ff0, "sadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100f90, 0x0ff00ff0, "sadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100f30, 0x0ff00ff0, "saddaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300f10, 0x0ff00ff0, "shadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300f90, 0x0ff00ff0, "shadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300f30, 0x0ff00ff0, "shaddsubx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300f70, 0x0ff00ff0, "shsub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300ff0, 0x0ff00ff0, "shsub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300f50, 0x0ff00ff0, "shsubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100f70, 0x0ff00ff0, "ssub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100ff0, 0x0ff00ff0, "ssub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100f50, 0x0ff00ff0, "ssubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500f10, 0x0ff00ff0, "uadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500f90, 0x0ff00ff0, "uadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500f30, 0x0ff00ff0, "uaddsubx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700f10, 0x0ff00ff0, "uhadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700f90, 0x0ff00ff0, "uhadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700f30, 0x0ff00ff0, "uhaddsubx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700f70, 0x0ff00ff0, "uhsub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700ff0, 0x0ff00ff0, "uhsub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700f50, 0x0ff00ff0, "uhsubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600f10, 0x0ff00ff0, "uqadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600f90, 0x0ff00ff0, "uqadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600f30, 0x0ff00ff0, "uqaddsubx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600f70, 0x0ff00ff0, "uqsub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600ff0, 0x0ff00ff0, "uqsub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600f50, 0x0ff00ff0, "uqsubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500f70, 0x0ff00ff0, "usub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500ff0, 0x0ff00ff0, "usub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500f50, 0x0ff00ff0, "usubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06bf0f30, 0x0fff0ff0, "rev%c\t%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06bf0fb0, 0x0fff0ff0, "rev16%c\t%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06ff0fb0, 0x0fff0ff0, "revsh%c\t%12-15r, %0-3r"},
d912 49
a960 49
  {ARM_EXT_V6, 0x06bf0070, 0x0fff0ff0, "sxth%c\t%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06bf0470, 0x0fff0ff0, "sxth%c\t%12-15r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06bf0870, 0x0fff0ff0, "sxth%c\t%12-15r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06bf0c70, 0x0fff0ff0, "sxth%c\t%12-15r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x068f0070, 0x0fff0ff0, "sxtb16%c\t%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x068f0470, 0x0fff0ff0, "sxtb16%c\t%12-15r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x068f0870, 0x0fff0ff0, "sxtb16%c\t%12-15r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x068f0c70, 0x0fff0ff0, "sxtb16%c\t%12-15r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x06af0070, 0x0fff0ff0, "sxtb%c\t%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06af0470, 0x0fff0ff0, "sxtb%c\t%12-15r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06af0870, 0x0fff0ff0, "sxtb%c\t%12-15r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06af0c70, 0x0fff0ff0, "sxtb%c\t%12-15r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x06ff0070, 0x0fff0ff0, "uxth%c\t%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06ff0470, 0x0fff0ff0, "uxth%c\t%12-15r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06ff0870, 0x0fff0ff0, "uxth%c\t%12-15r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06ff0c70, 0x0fff0ff0, "uxth%c\t%12-15r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x06cf0070, 0x0fff0ff0, "uxtb16%c\t%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06cf0470, 0x0fff0ff0, "uxtb16%c\t%12-15r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06cf0870, 0x0fff0ff0, "uxtb16%c\t%12-15r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06cf0c70, 0x0fff0ff0, "uxtb16%c\t%12-15r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x06ef0070, 0x0fff0ff0, "uxtb%c\t%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06ef0470, 0x0fff0ff0, "uxtb%c\t%12-15r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06ef0870, 0x0fff0ff0, "uxtb%c\t%12-15r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06ef0c70, 0x0fff0ff0, "uxtb%c\t%12-15r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x06b00070, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06b00470, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06b00870, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06b00c70, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x06800070, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06800470, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06800870, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06800c70, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x06a00070, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06a00470, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06a00870, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06a00c70, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x06f00070, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06f00470, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06f00870, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06f00c70, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x06c00070, 0x0ff00ff0, "uxtab16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06c00470, 0x0ff00ff0, "uxtab16%c\t%12-15r, %16-19r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06c00870, 0x0ff00ff0, "uxtab16%c\t%12-15r, %16-19r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06c00c70, 0x0ff00ff0, "uxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06e00070, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06e00470, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r, ror #8"},
  {ARM_EXT_V6, 0x06e00870, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r, ror #16"},
  {ARM_EXT_V6, 0x06e00c70, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r, ror #24"},
  {ARM_EXT_V6, 0x06800fb0, 0x0ff00ff0, "sel%c\t%12-15r, %16-19r, %0-3r"},
d962 9
a970 9
  {ARM_EXT_V6, 0x0700f010, 0x0ff0f0d0, "smuad%5'x%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x0700f050, 0x0ff0f0d0, "smusd%5'x%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07000010, 0x0ff000d0, "smlad%5'x%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x07400010, 0x0ff000d0, "smlald%5'x%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07000050, 0x0ff000d0, "smlsd%5'x%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x07400050, 0x0ff000d0, "smlsld%5'x%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x0750f010, 0x0ff0f0d0, "smmul%5'r%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07500010, 0x0ff000d0, "smmla%5'r%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x075000d0, 0x0ff000d0, "smmls%5'r%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
d972 3
a974 3
  {ARM_EXT_V6, 0x06a00010, 0x0fe00ff0, "ssat%c\t%12-15r, #%16-20W, %0-3r"},
  {ARM_EXT_V6, 0x06a00010, 0x0fe00070, "ssat%c\t%12-15r, #%16-20W, %0-3r, lsl #%7-11d"},
  {ARM_EXT_V6, 0x06a00050, 0x0fe00070, "ssat%c\t%12-15r, #%16-20W, %0-3r, asr #%7-11d"},
d976 8
a983 8
  {ARM_EXT_V6, 0x01800f90, 0x0ff00ff0, "strex%c\t%12-15r, %0-3r, [%16-19r]"},
  {ARM_EXT_V6, 0x00400090, 0x0ff000f0, "umaal%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x0780f010, 0x0ff0f0f0, "usad8%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07800010, 0x0ff000f0, "usada8%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x06e00010, 0x0fe00ff0, "usat%c\t%12-15r, #%16-20d, %0-3r"},
  {ARM_EXT_V6, 0x06e00010, 0x0fe00070, "usat%c\t%12-15r, #%16-20d, %0-3r, lsl #%7-11d"},
  {ARM_EXT_V6, 0x06e00050, 0x0fe00070, "usat%c\t%12-15r, #%16-20d, %0-3r, asr #%7-11d"},
  {ARM_EXT_V6, 0x06e00f30, 0x0ff00ff0, "usat16%c\t%12-15r, #%16-19d, %0-3r"},
d986 1
a986 1
  {ARM_EXT_V5J, 0x012fff20, 0x0ffffff0, "bxj%c\t%0-3r"},
d991 1
a991 1
  {ARM_EXT_V5, 0x012fff30, 0x0ffffff0, "blx%c\t%0-3r"},
d998 25
a1022 25
  {ARM_EXT_V5ExP, 0x01000080, 0x0ff000f0, "smlabb%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x010000a0, 0x0ff000f0, "smlatb%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x010000c0, 0x0ff000f0, "smlabt%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x010000e0, 0x0ff000f0, "smlatt%c\t%16-19r, %0-3r, %8-11r, %12-15r"},

  {ARM_EXT_V5ExP, 0x01200080, 0x0ff000f0, "smlawb%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x012000c0, 0x0ff000f0, "smlawt%c\t%16-19r, %0-3r, %8-11r, %12-15r"},

  {ARM_EXT_V5ExP, 0x01400080, 0x0ff000f0, "smlalbb%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x014000a0, 0x0ff000f0, "smlaltb%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x014000c0, 0x0ff000f0, "smlalbt%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x014000e0, 0x0ff000f0, "smlaltt%c\t%12-15r, %16-19r, %0-3r, %8-11r"},

  {ARM_EXT_V5ExP, 0x01600080, 0x0ff0f0f0, "smulbb%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x016000a0, 0x0ff0f0f0, "smultb%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x016000c0, 0x0ff0f0f0, "smulbt%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x016000e0, 0x0ff0f0f0, "smultt%c\t%16-19r, %0-3r, %8-11r"},

  {ARM_EXT_V5ExP, 0x012000a0, 0x0ff0f0f0, "smulwb%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x012000e0, 0x0ff0f0f0, "smulwt%c\t%16-19r, %0-3r, %8-11r"},

  {ARM_EXT_V5ExP, 0x01000050, 0x0ff00ff0,  "qadd%c\t%12-15r, %0-3r, %16-19r"},
  {ARM_EXT_V5ExP, 0x01400050, 0x0ff00ff0, "qdadd%c\t%12-15r, %0-3r, %16-19r"},
  {ARM_EXT_V5ExP, 0x01200050, 0x0ff00ff0,  "qsub%c\t%12-15r, %0-3r, %16-19r"},
  {ARM_EXT_V5ExP, 0x01600050, 0x0ff00ff0, "qdsub%c\t%12-15r, %0-3r, %16-19r"},
d1046 1
a1046 1
  {ARM_EXT_V1, 0x00000010, 0x0fe00090, "and%20's%c\t%12-15r, %16-19r, %o"},
d1050 1
a1050 1
  {ARM_EXT_V1, 0x00200010, 0x0fe00090, "eor%20's%c\t%12-15r, %16-19r, %o"},
d1054 1
a1054 1
  {ARM_EXT_V1, 0x00400010, 0x0fe00090, "sub%20's%c\t%12-15r, %16-19r, %o"},
d1058 1
a1058 1
  {ARM_EXT_V1, 0x00600010, 0x0fe00090, "rsb%20's%c\t%12-15r, %16-19r, %o"},
d1062 1
a1062 1
  {ARM_EXT_V1, 0x00800010, 0x0fe00090, "add%20's%c\t%12-15r, %16-19r, %o"},
d1066 1
a1066 1
  {ARM_EXT_V1, 0x00a00010, 0x0fe00090, "adc%20's%c\t%12-15r, %16-19r, %o"},
d1070 1
a1070 1
  {ARM_EXT_V1, 0x00c00010, 0x0fe00090, "sbc%20's%c\t%12-15r, %16-19r, %o"},
d1074 1
a1074 1
  {ARM_EXT_V1, 0x00e00010, 0x0fe00090, "rsc%20's%c\t%12-15r, %16-19r, %o"},
d1081 1
a1081 1
  {ARM_EXT_V1, 0x01000010, 0x0fe00090, "tst%p%c\t%16-19r, %o"},
d1085 1
a1085 1
  {ARM_EXT_V1, 0x01200010, 0x0fe00090, "teq%p%c\t%16-19r, %o"},
d1088 1
a1088 1
  {ARM_EXT_V3, 0x01400000, 0x0ff00010, "mrs%c\t%12-15r, %22?SCPSR"},
d1090 1
a1090 1
  {ARM_EXT_V1, 0x01400010, 0x0fe00090, "cmp%p%c\t%16-19r, %o"},
d1094 1
a1094 1
  {ARM_EXT_V1, 0x01600010, 0x0fe00090, "cmn%p%c\t%16-19r, %o"},
d1098 1
a1098 1
  {ARM_EXT_V1, 0x01800010, 0x0fe00090, "orr%20's%c\t%12-15r, %16-19r, %o"},
d1102 3
a1104 3
  {ARM_EXT_V1, 0x01a00000, 0x0def0060, "lsl%20's%c\t%12-15r, %q"},
  {ARM_EXT_V1, 0x01a00020, 0x0def0060, "lsr%20's%c\t%12-15r, %q"},
  {ARM_EXT_V1, 0x01a00040, 0x0def0060, "asr%20's%c\t%12-15r, %q"},
d1106 1
a1106 1
  {ARM_EXT_V1, 0x01a00060, 0x0def0060, "ror%20's%c\t%12-15r, %q"},
d1110 1
a1110 1
  {ARM_EXT_V1, 0x01c00010, 0x0fe00090, "bic%20's%c\t%12-15r, %16-19r, %o"},
d1114 1
a1114 1
  {ARM_EXT_V1, 0x01e00010, 0x0fe00090, "mvn%20's%c\t%12-15r, %o"},
d1317 1
d1425 3
a1427 3
  {ARM_EXT_V6T2, 0xfa00f000, 0xffe0f0f0, "lsl%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa20f000, 0xffe0f0f0, "lsr%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa40f000, 0xffe0f0f0, "asr%20's%c.w\t%8-11r, %16-19r, %0-3r"},
d1457 6
a1462 6
  {ARM_EXT_V6T2, 0xfb700000, 0xfff000f0, "usada8%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb800000, 0xfff000f0, "smull%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfba00000, 0xfff000f0, "umull%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbc00000, 0xfff000f0, "smlal%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbe00000, 0xfff000f0, "umlal%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbe00060, 0xfff000f0, "umaal%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
d1468 7
a1474 7
  {ARM_EXT_V6T2, 0xfb200000, 0xfff000e0, "smlad%4'x%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb300000, 0xfff000e0, "smlaw%4?tb%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb400000, 0xfff000e0, "smlsd%4'x%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb500000, 0xfff000e0, "smmla%4'r%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb600000, 0xfff000e0, "smmls%4'r%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfbc000c0, 0xfff000e0, "smlald%4'x%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbd000c0, 0xfff000e0, "smlsld%4'x%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
d1538 1
a1538 1
   
d1758 2
d1999 4
d2004 9
d2270 3
d2868 2
d2918 2
a2919 1
			      is_unpredictable = TRUE;
d2947 13
a2959 4
				/* Register Offset or Register Pre-Indexed.  */
				func (stream, ", %s%s",
				      NEGATIVE_BIT_SET ? "-" : "",
				      arm_regnames[given & 0xf]);
d2974 12
a2985 4
				/* Register Post-indexed.  */
				func (stream, "], %s%s",
				      NEGATIVE_BIT_SET ? "-" : "",
				      arm_regnames[given & 0xf]);
d3170 18
d3287 1
d3472 1
d3600 1
d4030 1
d4035 8
a4042 1
		    case 'r': func (stream, "%s", arm_regnames[val]); break;
d4082 4
@


1.117
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d792 1
d811 5
a815 5
  {ARM_EXT_V2, 0x00000090, 0x0fe000f0, "mul%20's%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V2, 0x00200090, 0x0fe000f0, "mla%20's%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V2S, 0x01000090, 0x0fb00ff0, "swp%22'b%c\t%12-15r, %0-3r, [%16-19r]"},
  {ARM_EXT_V3M, 0x00800090, 0x0fa000f0, "%22?sumull%20's%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V3M, 0x00a00090, 0x0fa000f0, "%22?sumlal%20's%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
d988 1
a988 1
  {ARM_EXT_V5, 0x016f0f10, 0x0fff0ff0, "clz%c\t%12-15r, %0-3r"},
d1022 12
a1033 7
  {ARM_EXT_V1, 0x04000000, 0x0e100000, "str%22'b%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x06000000, 0x0e100ff0, "str%22'b%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x04000000, 0x0c100010, "str%22'b%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x04400000, 0x0e500000, "strb%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x06400000, 0x0e500010, "strb%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x004000b0, 0x0e5000f0, "strh%c\t%12-15r, %s"},
  {ARM_EXT_V1, 0x000000b0, 0x0e500ff0, "strh%c\t%12-15r, %s"},
d1036 1
a1036 1
  {ARM_EXT_V1, 0x00500090, 0x0e500090, "ldr%6's%5?hb%c\t%12-15r, %s"},
d1038 1
a1038 1
  {ARM_EXT_V1, 0x00100090, 0x0e500f90, "ldr%6's%5?hb%c\t%12-15r, %s"},
d1073 1
a1073 1
  {ARM_EXT_V3, 0x010f0000, 0x0fbf0fff, "mrs%c\t%12-15r, %22?SCPSR"},
d1114 6
a1119 1
  {ARM_EXT_V1, 0x04100000, 0x0c100000, "ldr%22'b%t%c\t%12-15r, %a"},
d1121 2
a1122 2
  {ARM_EXT_V1, 0x08800000, 0x0ff00000, "stm%c\t%16-19r%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x08000000, 0x0e100000, "stm%23?id%24?ba%c\t%16-19r%21'!, %m%22'^"},
d1124 2
a1125 2
  {ARM_EXT_V1, 0x08900000, 0x0f900000, "ldm%c\t%16-19r%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x08100000, 0x0e100000, "ldm%23?id%24?ba%c\t%16-19r%21'!, %m%22'^"},
d2845 1
d2893 1
a2893 1
			      func (stream, UNPREDICTABLE_INSTRUCTION);
d2952 2
a2953 2
				      || ((given & 0xf) == 0xf))
				    func (stream, UNPREDICTABLE_INSTRUCTION);
d2987 2
d3122 4
d3223 3
@


1.116
log
@        PR 10924
        * arm-dis.c (print_insn_arm): Mark insns that use the PC in
        post-indexed addressing as unpredictable.
@
text
@a1975 1
		    unsigned long value;
a2143 1
		      int value;
d2538 1
a2538 1
                            int align = (8 * (type + 1)) << size;
d3172 1
a3172 1
			  long width = msb - lsb + 1;
d3174 2
a3175 2
			  if (width > 0)
			    func (stream, "#%lu, #%lu", lsb, width);
@


1.115
log
@        PR gas/11013
        * arm-dis.c (thumb32_opc): Adjust disassembly of QADD, QDADD, QSUB
        and QDSUB.

        * gas/arm/arch7em.d: Update expected disassembly.
        * gas/arm/thumb32.d: Likewise.

        * config/tc-arm.c (do_t_simd2): New function.
        (insns): Use do_t_simd2 for QADD, QDADD, QSUB and QDSUB.
@
text
@d2934 11
a2944 5
			      /* Writeback is automatically implied by post- addressing.
				 Setting the W bit is unnecessary and ARM specify it as
				 being unpredictable.  */
			      if (WRITEBACK_BIT_SET && ! allow_unpredictable)
				func (stream, UNPREDICTABLE_INSTRUCTION);
@


1.114
log
@        PR binutils/10924
        * gas/arm/arch4t-eabi.d: Restore previous expected dissambly of
        instructions using Immediate Offset addressing with an offset of
        zero.
        * gas/arm/arch4t.d: Likewise.
        * gas/arm/arm7t.d: Likewise.
        * gas/arm/xscale.d: Likewise.
        * gas/arm/wince-inst.d: Remove 'p' suffix from cmp, cmn, teq and
        tst instructions.

        PR binutils/10924
        * arm-dis.c (print_insn_arm): Do not print an offset of zero when
        decoding Immediaate Offset addressing.
@
text
@d1367 4
a1370 4
  {ARM_EXT_V6T2, 0xfa80f080, 0xfff0f0f0, "qadd%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f090, 0xfff0f0f0, "qdadd%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f0a0, 0xfff0f0f0, "qsub%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f0b0, 0xfff0f0f0, "qdsub%c\t%8-11r, %16-19r, %0-3r"},
@


1.113
log
@        * gas/arm/vfma1.d: Only run on ELF based targets.

        PR binutils/10924
        * gas/arm/arch4t-eabi.d: Update expected disassembly.
        * gas/arm/arch4t.d: Likewise.
        * gas/arm/archv6t2.d: Likewise.
        * gas/arm/arm7t.d: Likewise.
        * gas/arm/inst.d: Likewise.
        * gas/arm/xscale.d: Likewise.

        PR binutils/10924
        * arm-dis.c (arm_opcodes): Add patterns to match undefined LDRB
        instruction variants.  Add pattern for MRS variant that was being
        confused with CMP.
        (arm_decode_shift): Place error message in a comment.
        (print_insn_arm): Note that writing back to the PC is
        unpredictable.
        Only print 'p' variants of cmp/cmn/teq/tst instructions if
        decoding for pre-V6 architectures.
@
text
@d2874 4
a2877 1
			      func (stream, "[pc, #%d]\t; ", offset);
a2897 1
                              /* Pre-indexed.  */
d2900 8
a2907 2
				  /* PR 10924: Offset must be printed, even if it is zero.  */
				  func (stream, ", #%d", offset);
d2910 2
a2911 1
			      else /* Register.  */
d2919 1
a2919 1
			  else /* Post-indexed.  */
d2923 1
d2928 2
a2929 1
			      else /* Register.  */
d2934 3
@


1.112
log
@2009-11-17  Edward Nevill <edward.nevill@@arm.com>

	* arm-dis.c (print_insn_thumb32): Handle undefined instruction.
@
text
@d59 1
a59 1
  unsigned short value, mask;	/* Recognise insn if (op&mask)==value.  */
d115 1
a115 1
#define UNDEFINED_INSTRUCTION      "undefined instruction %0-31x"
d828 2
d831 1
d1028 2
d1031 1
d1078 1
d1703 1
a1703 1
	func (stream, ", <illegal shifter operand>");
d2872 10
a2881 2
			  func (stream, "[pc, #%d]\t; ", offset);
			  info->print_address_func (offset + pc + 8, info);
d2898 2
a2899 2
				  if (offset)
				    func (stream, ", #%d", offset);
d2914 2
a2915 5
				  if (offset)
				    func (stream, "], #%d", offset);
				  else
				    func (stream, "]");

d2981 7
a2987 1
			func (stream, "p");
@


1.111
log
@	gas/testsuite/
	* gas/arm/copro.d, gas/arm/fp-save.d, gas/arm/float.d,
	gas/arm/fpa-mem.d: Update for removed generic coprocessor instructions
	and expanded PC-relative offsets.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Use %A instead of %C.  Remove
	generic coprocessor instructions for FPA loads and stores.
	(print_insn_coprocessor): Remove %C support.  Display address for
	PC-relative offsets in %A.
@
text
@d3935 4
@


1.110
log
@        PR binutils/10924
        * arm-dis.c (UNPREDICTABLE_INSTRUCTION): New macro.
        (print_insn_arm): Extend %s format control code to check for
        unpredictable addressing modes.  Add support for %S format control
        code which suppresses this check.
        (W_BIT, I_BIT, U_BIT, P_BIT): New macros.
        (WRITEBACK_BIT_SET, IMMEDIATE_BIT_SET, NEGATIVE_BIT_SET,
        PRE_BIT_SET): New macros.
        (print_insn_coprocessor): Use the new macros instead of magic
        constants.
        (print_arm_address): Likewise.
        (pirnt_insn_arm): Likewise.
        (print_insn_thumb32): Likewise.
@
text
@a71 1
   %C			print vstr/vldr address operand
d250 2
a251 2
  {FPU_FPA_EXT_V2, 0x0c000200, 0x0e100f00, "sfm%c\t%12-14f, %F, %A\t; (stc%22'l%c %8-11d, cr%12-15d, %A)"},
  {FPU_FPA_EXT_V2, 0x0c100200, 0x0e100f00, "lfm%c\t%12-14f, %F, %A\t; (ldc%22'l%c %8-11d, cr%12-15d, %A)"},
d260 2
a261 2
  {FPU_VFP_EXT_V1xD | FPU_NEON_EXT_V1, 0x0d000b00, 0x0f300f00, "vstr%c\t%12-15,22D, %C"},
  {FPU_VFP_EXT_V1xD | FPU_NEON_EXT_V1, 0x0d100b00, 0x0f300f00, "vldr%c\t%12-15,22D, %C"},
d1810 2
a1811 1
		    int offset = given & 0xff;
d1815 10
a1824 4
		    value_in_comment = offset * 4;
		    if (NEGATIVE_BIT_SET)
		      value_in_comment = - value_in_comment;
		    
d1829 1
a1829 1
				value_in_comment,
d1841 1
a1841 1
			      func (stream, ", #%d", value_in_comment);
d1849 6
a1871 27
		case 'C':
		  {
		    int rn = (given >> 16) & 0xf;
		    int offset = (given & 0xff) * 4;

		    func (stream, "[%s", arm_regnames[rn]);

		    if (offset)
		      {
			if (NEGATIVE_BIT_SET)
			  offset = - offset;
			func (stream, ", #%d", offset);
			if (rn != 15)
			  value_in_comment = offset;
		      }
		    func (stream, "]");
		    if (rn == 15)
		      {
			func (stream, "\t; ");
			/* FIXME: Unsure if info->bytes_per_chunk is the
			   right thing to use here.  */
			info->print_address_func (offset + pc
						  + info->bytes_per_chunk * 2, info);
		      }
		  }
		  break;

@


1.109
log
@2009-11-02  Paul Brook  <paul@@codesourcery.com>

	ld/testsuite/
	* ld-arm/arm-elf.exp: Add new attr-merge-vfp tests.
	* ld-arm/attr-merge-vfp-1.d: New test.
	* ld-arm/attr-merge-vfp-1r.d: New test.
	* ld-arm/attr-merge-vfp-2.d: New test.
	* ld-arm/attr-merge-vfp-2r.d: New test.
	* ld-arm/attr-merge-vfp-3.d: New test.
	* ld-arm/attr-merge-vfp-3r.d: New test.
	* ld-arm/attr-merge-vfp-4.d: New test.
	* ld-arm/attr-merge-vfp-4r.d: New test.
	* ld-arm/attr-merge-vfp-5.d: New test.
	* ld-arm/attr-merge-vfp-5r.d: New test.
	* ld-arm/attr-merge-vfp-2.s: New test.
	* ld-arm/attr-merge-vfp-3.s: New test.
	* ld-arm/attr-merge-vfp-3-d16.s: New test.
	* ld-arm/attr-merge-vfp-4.s: New test.
	* ld-arm/attr-merge-vfp-4-d16.s: New test.

	gas/
	* doc/c-arm.texi: Document new -mfpu options.
	* config/tc-arm.c (fpu_vfp_ext_v3xd, fpu_vfp_fp16, fpu_neon_ext_fma,
	fpu_vfp_ext_fma): New.
	(NEON_ENC_TAB): Add vfma, vfms, vfnma and vfnms.
	(do_vfp_nsyn_fma_fms, do_neon_fmac): New functions.
	(insns): Move double precision load/store.  Split out double
	precision VFPv3 instrucitons.  Add VFPv4 instructions.
	(arm_fpus): Add VFPv3-FP16, VFPv3xD and VFPv4 variants.
	(aeabi_set_public_attributes): Set VFPv4 variants

	gas/testsuite/
	* gas/arm/attr-mfpu-vfpv4.d: New test.
	* gas/arm/attr-mfpu-vfpv4-d16.d: New test.
	* gas/arm/neon-fma-cov.d: New test.
	* gas/arm/neon-fma-cov.s: New test.
	* gas/arm/vfp-fma-inc.s: New test.
	* gas/arm/vfp-fma-arm.d: New test.
	* gas/arm/vfp-fma-arm.s: New test.
	* gas/arm/vfp-fma-thumb.d: New test.
	* gas/arm/vfp-fma-thumb.s: New test.
	* gas/arm/vfma1.d: New test.
	* gas/arm/vfma1.s: New test.
	* gas/arm/vfpv3xd.d: New test.
	* gas/arm/vfpv3xd.s: New test.

	include/opcode/
	* arm.h (FPU_VFP_EXT_V3xD, FPU_VFP_EXT_FP16, FPU_NEON_EXT_FMA,
	FPU_VFP_EXT_FMA, FPU_VFP_V3xD, FPU_VFP_V4D16, FPU_VFP_V4): Define.
	(FPU_ARCH_VFP_V3D16_FP16, FPU_ARCH_VFP_V3_FP16, FPU_ARCH_VFP_V3xD,
	FPU_ARCH_VFP_V3xD_FP16, FPU_ARCH_VFP_V4, FPU_ARCH_VFP_V4D16,
	FPU_ARCH_NEON_VFP_V4): Define.

	binutils/
	* readelf.c (arm_attr_tag_VFP_arch): Add VFPv4 and VFPv4-D16.

	bfd/
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Handle VFPv4
	attributes.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Update to use new feature flags.
	Add VFPv4 instructions.
@
text
@d116 2
a117 1
#define UNDEFINED_INSTRUCTION "undefined instruction %0-31x"
d780 1
d828 2
a829 2
  {ARM_EXT_V6T2, 0x006000b0, 0x0f7000f0, "strht%c\t%12-15r, %s"},
  {ARM_EXT_V6T2, 0x00300090, 0x0f300090, "ldr%6's%5?hbt%c\t%12-15r, %s"},
d1706 10
d1816 1
a1816 1
		    if ((given & 0x00800000) == 0)
d1819 1
a1819 1
		    if ((given & (1 << 24)) != 0)
d1824 1
a1824 1
				((given & 0x00200000) != 0 ? "!" : ""));
d1832 1
a1832 1
			if (given & (1 << 21))
a1863 1
		    int add = (given >> 23) & 1;
d1869 2
a1870 2
			if (!add)
			  offset = -offset;
d2173 1
a2173 1
			  if ((given & 0x00800000) == 0)
d2179 1
a2179 1
			  if ((given & 0x01000000) != 0)
d2181 1
a2181 1
				  ((given & 0x00800000) == 0 ? "-" : ""),
d2183 1
a2183 1
				  ((given & 0x00200000) != 0 ? "!" : ""));
d2186 1
a2186 1
				  ((given & 0x00800000) == 0 ? "-" : ""),
d2197 2
a2198 2
		      int puw_bits = ((given >> 22) & 6) | ((given >> 21) & 1);
		      int ubit = (given >> 23) & 1;
d2273 1
a2273 1
      if (given & 0x01000000)
d2275 1
a2275 1
	  if ((given & 0x00800000) == 0)
d2287 1
a2287 1
	  if (given & 0x00200000)
d2290 1
a2290 1
      else
a2291 1
	  /* Post indexed.  */
d2294 1
a2294 1
	  /* ie ignore the offset.  */
d2306 2
a2307 1
      if ((given & 0x01000000) != 0)
d2314 1
a2314 2
		      (((given & 0x00800000) == 0)
		       ? "-" : ""), offset);
d2319 1
a2319 2
		    (((given & 0x00800000) == 0)
		     ? "-" : ""));
d2324 1
a2324 1
		((given & 0x00200000) != 0) ? "!" : "");
d2333 1
a2333 2
		      (((given & 0x00800000) == 0)
		       ? "-" : ""), offset);
d2340 1
a2340 2
		    (((given & 0x00800000) == 0)
		     ? "-" : ""));
d2679 2
a2680 2
                                  (&floatformat_ieee_single_little, valbytes,
                                  &fvalue);
d2687 2
a2688 2
				(long) ((value & 0x80000000)
					? value | ~0xffffffffl : value), value);
d2851 2
d2866 1
a2866 1
		      value_in_comment = print_arm_address (pc, info, given | (1 << 24));
d2869 2
d2877 2
a2878 2
			  if ((given & 0x00800000) == 0)
			    offset = -offset;
a2884 1
			  bfd_boolean negative = (given & 0x00800000) == 0;
d2887 2
a2888 2
			  if (negative)
			    offset = -offset;
d2893 1
a2893 1
			  if ((given & 0x01000000) != 0)
d2896 1
a2896 1
			      if ((given & 0x00400000) == 0x00400000)
a2897 1
                                  /* Immediate.  */
d2902 4
a2905 6
			      else
				{
                                  /* Register.  */
				  func (stream, ", %s%s", negative ? "-" : "",
                                        arm_regnames[given & 0xf]);
				}
d2908 1
a2908 1
				    ((given & 0x00200000) != 0) ? "!" : "");
d2910 1
a2910 1
			  else
d2912 1
a2912 2
                              /* Post-indexed.  */
			      if ((given & 0x00400000) == 0x00400000)
a2913 1
                                  /* Immediate.  */
d2921 7
a2927 6
			      else
				{
                                  /* Register.  */
				  func (stream, "], %s%s", negative ? "-" : "",
                                        arm_regnames[given & 0xf]);
				}
d2997 1
a2997 1
			if ((given & 0x00800000) == 0)
d3002 1
a3002 1
			if ((given & (1 << 24)) != 0)
d3007 1
a3007 1
				    ((given & 0x00200000) != 0 ? "!" : ""));
d3015 1
a3015 1
			    if (given & (1 << 21))
d3035 1
a3035 1
			if (given & 0x00800000)
d3552 3
a3554 3
		    case 1: imm = ((imm8<<16) | imm8); break;
		    case 2: imm = ((imm8<<24) | (imm8 << 8)); break;
		    case 3: imm = ((imm8<<24) | (imm8 << 16) | (imm8 << 8) | imm8); break;
d3630 1
a3630 1
		  unsigned int U   = (given & 0x00800000) >> 23;
d3712 2
a3713 3
		  unsigned int P   = (given & 0x01000000) >> 24;
		  unsigned int U   = (given & 0x00800000) >> 23;
		  unsigned int W   = (given & 0x00400000) >> 21;
d3718 2
a3719 1
		  if (P)
d3854 1
a3854 1
		  if (given & 0x00200000u)
@


1.108
log
@	* arm-dis.c (print_insn): Check symtab_size not *symtab.
@
text
@d292 2
a293 2
  {FPU_NEON_FP16,   0x0eb20a40, 0x0fbf0f50, "vcvt%7?tb%c.f32.f16\t%y1, %y0"},
  {FPU_NEON_FP16,   0x0eb30a40, 0x0fbf0f50, "vcvt%7?tb%c.f16.f32\t%y1, %y0"},
d333 1
a333 1
  {FPU_VFP_EXT_V3, 0x0eba0a40, 0x0fbe0f50, "vcvt%c.f32.%16?us%7?31%7?26\t%y1, %y1, #%5,0-3k"},
d337 1
a337 1
  {FPU_VFP_EXT_V3, 0x0ebe0a40, 0x0fbe0f50, "vcvt%c.%16?us%7?31%7?26.f32\t%y1, %y1, #%5,0-3k"},
d340 1
a340 1
  {FPU_VFP_EXT_V3, 0x0eb00a00, 0x0fb00ff0, "vmov%c.f32\t%y1, #%0-3,16-19d"},
d450 10
d530 6
a535 2
  {FPU_NEON_FP16,   0xf3b60600, 0xffbf0fd0, "vcvt%c.f16.f32\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_FP16,   0xf3b60700, 0xffbf0fd0, "vcvt%c.f32.f16\t%12-15,22Q, %0-3,5D"},
@


1.107
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@d4270 1
a4270 2
  if (info->symtab != NULL
      && * info->symtab
@


1.106
log
@update copyright dates
@
text
@d109 1
a109 1
enum
@


1.106.2.1
log
@	* arm-dis.c (print_insn): Check symtab_size not *symtab.
@
text
@d4270 2
a4271 1
  if (info->symtab_size != 0
@


1.106.2.2
log
@opcodes/

2009-11-17  Edward Nevill <edward.nevill@@arm.com>

       * arm-dis.c (print_insn_thumb32): Handle undefined instruction.
@
text
@a3934 4
		      
		    case 'x':
		      func (stream, "0x%lx", val & 0xffffffffUL);
		      break;
@


1.106.2.3
log
@        * arm-dis.c: Fix mis-applied patch.
@
text
@a3930 4
		    case 'x':
		      func (stream, "0x%lx", val & 0xffffffffUL);
		      break;

d3936 5
@


1.106.2.4
log
@	* opcodes/arm-dis.c: Fix mis-applied patch.
@
text
@a3937 1
		  break;
@


1.105
log
@        PR 10288
        * arm-dis.c (arm_opcodes): Catch non-zero bits 8-11 in register
        offset or indexed based addressing mode 3.
@
text
@d3 1
a3 1
   2004, 2007, 2009  Free Software Foundation, Inc.
@


1.104
log
@        PR 10288
        * arm-dis.c (arm_opcodes): Catch illegal Addressing Mode 1
        patterns.
        (arm_decode_shift): Catch illegal register based shifts.
        (print_insn_arm): Properly handle negative register r0
        post-indexed addressing.
@
text
@d1008 4
a1011 2
  {ARM_EXT_V1, 0x000000b0, 0x0e1000f0, "strh%c\t%12-15r, %s"},
  {ARM_EXT_V1, 0x00100090, 0x0e100090, "ldr%6's%5?hb%c\t%12-15r, %s"},
@


1.103
log
@2009-07-10  Doug Kwan  <dougkwan@@google.com>

	* arm-disc.c (print_insn_coprocessor, print_insn_arm):  Print only
	lower 32 bits of long types to make hexadecimal output consistent
	on both 32-bit and 64-bit hosts.
@
text
@d1010 33
a1042 8
  {ARM_EXT_V1, 0x00000000, 0x0de00000, "and%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00200000, 0x0de00000, "eor%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00400000, 0x0de00000, "sub%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00600000, 0x0de00000, "rsb%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00800000, 0x0de00000, "add%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00a00000, 0x0de00000, "adc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00c00000, 0x0de00000, "sbc%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00e00000, 0x0de00000, "rsc%20's%c\t%12-15r, %16-19r, %o"},
d1045 21
a1065 5
  {ARM_EXT_V1, 0x01000000, 0x0de00000, "tst%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01200000, 0x0de00000, "teq%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01400000, 0x0de00000, "cmp%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01600000, 0x0de00000, "cmn%p%c\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01800000, 0x0de00000, "orr%20's%c\t%12-15r, %16-19r, %o"},
d1073 9
a1081 2
  {ARM_EXT_V1, 0x01c00000, 0x0de00000, "bic%20's%c\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x01e00000, 0x0de00000, "mvn%20's%c\t%12-15r, %o"},
d1678 2
d2858 1
d2861 1
a2861 1
			  if ((given & 0x00800000) == 0)
d2880 1
a2880 1
				  func (stream, ", %s%s", offset < 0 ? "-" : "",
d2903 1
a2903 1
				  func (stream, "], %s%s", offset < 0 ? "-" : "",
@


1.102
log
@gas/
    * config/tc-arm.c (insns): Fix encoding for torvsc.

gas/testsuite/
    * gas/arm/iwmmxt2.d: Fix insn pattern for torvsc,
    add patterns for waddsubhx.
    * gas/arm/iwmmxt2.s: Add tests for waddsubhx.

opcodes/
    * arm-dis.c (coprocessor_opcodes): Fix mask for waddbhus.
@
text
@d1958 1
a1958 1
			func (stream, "0x%lx", value);
d2170 1
a2170 1
	func (stream, "\t; 0x%lx", value_in_comment);
d3110 1
a3110 1
	    func (stream, "\t; 0x%lx", value_in_comment);
@


1.101
log
@        PR 10288
        * arm-dis.c (arm_opcodes): Be more strict about decoding scaled
        addressing modes.
@
text
@d145 1
a145 1
  {ARM_CEXT_XSCALE, 0x0e130190, 0x0f3f0fff, "torvsc%22-23w%c\t%12-15r"},
d149 1
a149 1
  {ARM_CEXT_XSCALE, 0x0e2001a0, 0x0f300ff0, "waddbhus%22?ml%c\t%12-15g, %16-19g, %0-3g"},
@


1.100
log
@        PR 10288
        * arm-dis.c (coprocessor): Print the LDC and STC versions of the
        LFM and SFM instructions as comments,.
        Improve consistency of formatting for instructions displayed as
        comments and decimal values displayed with their hexadecimal
        equivalents.
        Formatting tidy ups.

        Updated expected disassembler regexps.
@
text
@d1006 2
a1007 1
  {ARM_EXT_V1, 0x04400000, 0x0c500000, "strb%c\t%12-15r, %a"},
d1603 1
a1603 1
		  int print_shift)
d2245 1
a2245 1
	      arm_decode_shift (given, func, stream, 1);
d2268 1
a2268 1
	      arm_decode_shift (given, func, stream, 1);
d2891 1
a2891 1
		      arm_decode_shift (given, func, stream, 0);
d2906 1
a2906 1
			arm_decode_shift (given, func, stream, 1);
@


1.99
log
@        PR 10288
        * arm-dis.c (enum opcode_sentinels): New:  Used to mark the
        boundary between variaant and generic coprocessor instuctions.
        (coprocessor): Use it.
        Fix architecture version of MCRR and MRRC instructions.
        (arm_opcdes): Fix patterns for STRB and STRH instructions.
        (print_insn_coprocessor): Check architecture and extension masks.
        Print a hexadecimal version of any decimal constant that is
        outside of the range of -16 to +32.
        (print_arm_address): Add a return value of the offset used in the
        adress, if it is worth printing a hexadecimal version of it.
        (print_insn_neon): Print a hexadecimal version of any decimal
        constant that is outside of the range of -16 to +32.
        (print_insn_arm): Likewise.
        (print_insn_thumb16): Likewise.
        (print_insn_thumb32): Likewise.

        PR 10297
        * arm-dis.c (UNDEFINED_INSTRUCTION): New macro for a description
        of an undefined instruction.
        (arm_opcodes): Use it.
        (thumb_opcod): Use it.
        (thumb32_opc): Use it.

        Update expected disassembly regrexps in GAS and LD testsuites.
@
text
@d51 2
a52 2
  unsigned long value;		/* Recognise insn if (op & mask) == value.  */
  unsigned long mask;		/* If arch == 0 then value is a sentinel.  */
d107 1
a107 2
   %r			print register offset address for wldt/wstr instruction
*/
d208 1
a208 1
  /* Floating point coprocessor (FPA) instructions */
d250 2
a251 2
  {FPU_FPA_EXT_V2, 0x0c000200, 0x0e100f00, "sfm%c\t%12-14f, %F, %A"},
  {FPU_FPA_EXT_V2, 0x0c100200, 0x0e100f00, "lfm%c\t%12-14f, %F, %A"},
d253 1
a253 1
  /* Register load/store */
d276 1
a276 1
  /* Data transfer between ARM and NEON registers */
d295 1
a295 1
  /* Floating point coprocessor (VFP) instructions */
d502 1
a502 1
   %<bitfield>?ab...    select from array of values in big endian order  */
d506 1
a506 1
  /* Extract */
d510 1
a510 1
  /* Move data element to all lanes */
d515 1
a515 1
  /* Table lookup */
d523 1
a523 1
  /* Two registers, miscellaneous */
d558 1
a558 1
  /* Three registers of the same length */
d613 1
a613 1
  /* One register and an immediate value */
d628 1
a628 1
  /* Two registers and a shift amount */
d688 1
a688 1
  /* Three registers of different lengths */
d707 1
a707 1
  /* Two registers and a scalar */
d731 1
a731 1
  /* Element and structure load/store */
d793 1
a793 1
  {ARM_EXT_V1, 0xe1a00000, 0xffffffff, "nop\t\t\t(mov r0,r0)"},
d838 1
a838 1
  /* ARM V6 instructions. */
d1111 1
a1111 1
  {ARM_EXT_V4T, 0x46C0, 0xFFFF, "nop%c\t\t\t(mov r8, r8)"},
d1162 1
a1162 1
  {ARM_EXT_V4T, 0x4800, 0xF800, "ldr%c\t%8-10r, [pc, #%0-7W]\t(%0-7a)"},  /* TODO: Disassemble PC relative "LDR rD,=<symbolic>" */
d1175 1
a1175 1
  {ARM_EXT_V4T, 0xA000, 0xF800, "add%c\t%8-10r, pc, #%0-7W\t(adr %8-10r, %0-7a)"},
d1522 2
a1523 1
enum map_type {
d1550 3
a1552 1
get_arm_regnames (int option, const char **setname, const char **setdescription,
d1564 1
a1564 1
   bits extracted.  WIDTHP can be NULL. */
d1567 4
a1570 2
arm_decode_bitfield (const char *ptr, unsigned long insn,
		     unsigned long *valuep, int *widthp)
d1642 3
a1644 1
print_insn_coprocessor (bfd_vma pc, struct disassemble_info *info, long given,
d1743 2
a1744 3
			  func (stream, ", #%s%d]%s",
				((given & 0x00800000) == 0 ? "-" : ""),
				offset * 4,
d1756 1
a1756 3
			      func (stream, ", #%s%d",
				    ((given & 0x00800000) == 0 ? "-" : ""),
				    offset * 4);
d1759 4
a1762 1
			  func (stream, ", {%d}", offset);
d1794 2
d1971 1
a1971 1
			func (stream, "%c", c[(1 << width) - (int)value]);
d2502 1
a2502 1
		      /* Neon encoded constant for mov, mvn, vorr, vbic */
d2519 1
a2519 1
			    value = (unsigned long)bits << (8 * shift);
d2525 1
a2525 1
			    value = (unsigned long)bits << (8 * shift);
d2531 1
a2531 1
			    value = (unsigned long)bits << (8 * shift);
d2539 1
a2539 1
				/* bit replication into bytes */
d2557 2
a2558 2
                                /* byte replication */
                                value = (unsigned long)bits;
d2564 1
a2564 1
			    /* floating point encoding */
d2567 2
a2568 2
			    value = (unsigned long)(bits & 0x7f) << 19;
			    value |= (unsigned long)(bits & 0x80) << 24;
d2570 1
a2570 1
			    value |= (unsigned long)tmp << 24;
d2714 1
a2714 1
			    func (stream, "%c", c[(1 << width) - (int)value]);
d2807 5
d2814 1
a2820 2
                                  int offset = ((given & 0xf00) >> 4) | (given & 0xf);

d2822 2
a2823 3
				    func (stream, ", #%s%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
d2828 1
a2828 3
				  func (stream, ", %s%s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""),
a2840 2
                                  int offset = ((given & 0xf00) >> 4) | (given & 0xf);

d2842 1
a2842 3
				    func (stream, "], #%s%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
d2845 2
d2851 1
a2851 3
				  func (stream, "], %s%s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""),
d2898 1
d2901 2
a2902 1
			  func (stream, "#%d\t; 0x%x", immed, immed);
d2931 2
a2932 3
			      func (stream, ", #%s%d]%s",
				    ((given & 0x00800000) == 0 ? "-" : ""),
				    offset * 4,
d2944 1
a2944 3
				  func (stream, ", #%s%d",
					((given & 0x00800000) == 0 ? "-" : ""),
					offset * 4);
d2947 4
a2950 1
			      func (stream, ", {%d}", offset);
d2993 4
a2996 4
			case 0xf: func(stream, "sy"); break;
			case 0x7: func(stream, "un"); break;
			case 0xe: func(stream, "st"); break;
			case 0x6: func(stream, "unst"); break;
d2998 1
a2998 1
			  func(stream, "#%d", (int)given & 0xf);
d3053 1
a3053 1
			    func (stream, "%c", c[(1 << width) - (int)value]);
d3067 1
d3077 1
a3078 1
			  long width = msb - lsb + 1;
d3093 3
a3095 1
			  func (stream, "#%lu\t; 0x%lx", imm16, imm16);
d3379 1
d3457 1
d3461 2
a3462 1
		  func (stream, "#%u\t; 0x%x", imm12, imm12);
d3469 1
d3486 2
a3487 1
		  func (stream, "#%u\t; 0x%x", imm, imm);
d3494 1
d3499 2
a3500 1
		  func (stream, "#%u\t; 0x%x", imm, imm);
d3507 1
d3511 2
a3512 1
		  func (stream, "#%u\t; 0x%x", imm, imm);
d3665 4
a3668 1
			func (stream, "{%u}", off);
d3715 1
d3726 1
d3777 1
d3791 1
d3800 4
a3803 4
		  case 0xf: func(stream, "sy"); break;
		  case 0x7: func(stream, "un"); break;
		  case 0xe: func(stream, "st"); break;
		  case 0x6: func(stream, "unst"); break;
d3805 1
a3805 1
		    func(stream, "#%d", (int)given & 0xf);
d3873 1
a3873 1
		      func (stream, "%c", c[(1 << width) - (int)val]);
d3900 2
a3901 1
print_insn_data (bfd_vma pc ATTRIBUTE_UNUSED, struct disassemble_info *info,
d3997 1
d3999 2
a4000 1
find_ifthen_state (bfd_vma pc, struct disassemble_info *info,
d4025 1
a4025 1
      if (addr == 0 || info->symbol_at_address_func(addr, info))
d4035 1
a4035 1
      status = info->read_memory_func (addr, (bfd_byte *)b, 2, info);
d4079 2
a4080 1
get_sym_code_type (struct disassemble_info *info, int n,
d4098 1
a4098 1
  name = bfd_asymbol_name(info->symtab[n]);
d4348 1
a4348 1
      status = info->read_memory_func (pc, (bfd_byte *)b, size, info);
d4381 1
a4381 1
      status = info->read_memory_func (pc, (bfd_byte *)b, 2, info);
@


1.98
log
@        PR 10288
        * arm-dis.c (print_insn_coprocessor): Check that a user specified
        ARM architecture supports the matched instruction.
        (print_insn_arm): Likewise.
        (select_arm_features): New function.  Fills in the fields of an
        arm_feature_set structure based on a given arm machine number.
        (print_insn): Initialise an arm_feature_set structure.

        * objdump.c (disassemble_bytes): Set the
        USER_SPECIFIED_MACHINE_TYPE flag in the disassemble_info structure
        if the user has invoked the -m switch.
        * doc/binutils.texi: Document the additional behaviour of
        objdump's -m switch for ARM targets.

        * dis-asm.h (USER_SPECIFIED_MACHINE_TYPE): New value for the flags
        field of struct disassemble_info.

        * gas/arm/align.s: Add labels so that COFF based targets can
        correctly locate THUMB code.
        * gas/arm/copro.d: Do not pass --architecture switch to objdump.
@
text
@d51 3
a53 2
  unsigned long value, mask;	/* Recognise insn if (op&mask)==value.  */
  const char *assembler;	/* How to disassemble this insn.  */
d110 9
d129 1
a129 1
    
d131 1
a131 2
#define FIRST_IWMMXT_INSN 0x0e130130
#define IWMMXT_INSN_COUNT 73
d207 1
d451 4
a454 3
  /* Generic coprocessor instructions */
  {ARM_EXT_V2, 0x0c400000, 0x0ff00000, "mcrr%c\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
  {ARM_EXT_V2, 0x0c500000, 0x0ff00000, "mrrc%c\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
d461 1
a461 1
  /* V6 coprocessor instructions */
d465 1
a465 1
  /* V5 coprocessor instructions */
d1003 6
a1008 1
  {ARM_EXT_V1, 0x00000090, 0x0e100090, "str%6's%5?hb%c\t%12-15r, %s"},
d1034 1
a1034 5
  {ARM_EXT_V1, 0x052d0004, 0x0fff0fff, "push%c\t{%12-15r}\t\t; (str%c %12-15r, %a)"},
  {ARM_EXT_V1, 0x04000000, 0x0e100000, "str%22'b%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x06000000, 0x0e100ff0, "str%22'b%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x04000000, 0x0c100010, "str%22'b%t%c\t%12-15r, %a"},
  {ARM_EXT_V1, 0x06000010, 0x0e000010, "undefined"},
d1047 1
a1047 1
  {ARM_EXT_V1, 0x00000000, 0x00000000, "undefined instruction %0-31x"},
d1184 1
a1184 1
  {ARM_EXT_V4T, 0xDE00, 0xFE00, "undefined"},
d1193 1
a1193 1
  {ARM_EXT_V1,  0x0000, 0x0000, "undefined"},
d1447 1
a1447 1
  {ARM_EXT_V1,   0x00000000, 0x00000000, "undefined"},
d1646 1
d1651 1
d1654 22
a1675 5
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt
	  && info->mach != bfd_mach_arm_iWMMXt2)
	insn = insn + IWMMXT_INSN_COUNT;
d1711 1
a1711 1
      if ((insn->arch & ((arm_feature_set *) info->private_data)->coproc) == 0)
d1725 2
a1726 1
		  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);
d1728 1
a1728 3
		  if ((given & (1 << 24)) != 0)
		    {
		      int offset = given & 0xff;
d1730 16
a1745 6
		      if (offset)
			func (stream, ", #%s%d]%s",
			      ((given & 0x00800000) == 0 ? "-" : ""),
			      offset * 4,
			      ((given & 0x00200000) != 0 ? "!" : ""));
		      else
a1746 4
		    }
		  else
		    {
		      int offset = given & 0xff;
d1748 11
a1758 12
		      func (stream, "]");

		      if (given & (1 << 21))
			{
			  if (offset)
			    func (stream, ", #%s%d",
				  ((given & 0x00800000) == 0 ? "-" : ""),
				  offset * 4);
			}
		      else
			func (stream, ", {%d}", offset);
		    }
d1918 1
d2084 7
d2159 4
d2168 6
a2173 1
static void
d2178 1
d2183 1
a2183 1
      int offset = given & 0xfff;
d2215 1
d2225 1
a2225 1
	      int offset = given & 0xfff;
d2246 1
a2246 1
	      int offset = given & 0xfff;
d2263 2
d2301 1
d2649 1
d2658 1
a2658 1
			    /* various width encodings */
d2722 4
a2748 5
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt)
	insn = insn + IWMMXT_INSN_COUNT;

d2762 1
d2776 1
a2776 1
		      print_arm_address (pc, info, given);
d2782 1
a2782 1
		      print_arm_address (pc, info, given | (1 << 24));
d2808 1
d2833 1
d2856 1
a2856 1
			info->print_address_func (disp*4 + pc + 8, info);
d2912 6
a2917 1
		      func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);
d2919 1
a2919 3
		      if ((given & (1 << 24)) != 0)
			{
			  int offset = given & 0xff;
d2921 12
a2932 6
			  if (offset)
			    func (stream, ", #%s%d]%s",
				  ((given & 0x00800000) == 0 ? "-" : ""),
				  offset * 4,
				  ((given & 0x00200000) != 0 ? "!" : ""));
			  else
a2933 4
			}
		      else
			{
			  int offset = given & 0xff;
d2935 11
a2945 12
			  func (stream, "]");

			  if (given & (1 << 21))
			    {
			      if (offset)
				func (stream, ", #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * 4);
			    }
			  else
			    func (stream, ", {%d}", offset);
			}
d3011 1
d3015 1
d3019 1
d3033 1
d3097 3
d3118 1
d3120 1
d3292 1
d3297 1
d3302 1
d3311 1
d3321 1
d3358 3
d3410 1
d3412 1
d3545 9
a3553 5
		  if (U) /* 12-bit positive immediate offset */
		    offset = i12;
		  else if (Rn == 15) /* 12-bit negative immediate offset */
		    offset = -(int)i12;
		  else if (op == 0x0) /* shifted register offset */
d3557 1
d3566 1
a3566 1
		    case 0xE:  /* 8-bit positive immediate offset */
d3570 1
a3570 1
		    case 0xC:  /* 8-bit negative immediate offset */
d3574 1
a3574 1
		    case 0xF:  /* 8-bit + preindex with wb */
d3579 1
a3579 1
		    case 0xD:  /* 8-bit - preindex with wb */
d3584 1
a3584 1
		    case 0xB:  /* 8-bit + postindex */
d3589 1
a3589 1
		    case 0x9:  /* 8-bit - postindex */
d3629 4
a3632 1
			func (stream, ", #%c%u", U ? '+' : '-', off * 4);
d3641 4
a3644 1
			func (stream, "#%c%u", U ? '+' : '-', off * 4);
d3655 1
d3820 8
a3827 2
		    case 'd': func (stream, "%lu", val); break;
		    case 'W': func (stream, "%lu", val * 4); break;
d3861 3
@


1.97
log
@        PR 10186
        * arm-dis.c (thumb32_opcodes): Fix binary value of SEV.W
        instruction.

        * gas/arm/thumb32.d: Fix expected binary value of SEV.W instruction.

        * config/tc-arm.c (T16_32_TAB): Fix binary value of SEV.W
        instruction.
@
text
@d1638 2
d1676 8
a1683 1
      if ((given & mask) == value)
d1685 1
a1685 3
	  const char *c;

	  for (c = insn->assembler; *c; c++)
d1687 1
a1687 1
	      if (*c == '%')
d1689 20
a1708 1
		  switch (*++c)
d1710 1
a1710 3
		    case '%':
		      func (stream, "%%");
		      break;
d1712 1
a1712 2
		    case 'A':
		      func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);
d1714 1
a1714 1
		      if ((given & (1 << 24)) != 0)
a1715 2
			  int offset = given & 0xff;

d1717 1
a1717 1
			    func (stream, ", #%s%d]%s",
d1719 1
a1719 4
				  offset * 4,
				  ((given & 0x00200000) != 0 ? "!" : ""));
			  else
			    func (stream, "]");
d1722 17
a1738 2
			{
			  int offset = given & 0xff;
d1740 5
a1744 1
			  func (stream, "]");
d1746 1
a1746 11
			  if (given & (1 << 21))
			    {
			      if (offset)
				func (stream, ", #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * 4);
			    }
			  else
			    func (stream, ", {%d}", offset);
			}
		      break;
d1748 1
a1748 1
		    case 'B':
d1750 3
a1752 9
			int regno = ((given >> 12) & 0xf) | ((given >> (22 - 4)) & 0x10);
			int offset = (given >> 1) & 0x3f;
			
			if (offset == 1)
			  func (stream, "{d%d}", regno);
			else if (regno + offset > 32)
			  func (stream, "{d%d-<overflow reg d%d>}", regno, regno + offset - 1);
			else
			  func (stream, "{d%d-d%d}", regno, regno + offset - 1);
d1754 2
a1755 3
		      break;
		      
		    case 'C':
d1757 5
a1761 21
			int rn = (given >> 16) & 0xf;
			int offset = (given & 0xff) * 4;
			int add = (given >> 23) & 1;
			
			func (stream, "[%s", arm_regnames[rn]);
			
			if (offset)
			  {
			    if (!add)
			      offset = -offset;
			    func (stream, ", #%d", offset);
			  }
			func (stream, "]");
			if (rn == 15)
			  {
			    func (stream, "\t; ");
                            /* FIXME: Unsure if info->bytes_per_chunk is the
                               right thing to use here.  */
			    info->print_address_func (offset + pc
                              + info->bytes_per_chunk * 2, info);
			  }
d1763 14
a1776 1
		      break;
d1778 1
a1778 3
		    case 'c':
		      func (stream, "%s", arm_conditional[cond]);
		      break;
d1780 3
a1782 7
		    case 'I':
		      /* Print a Cirrus/DSP shift immediate.  */
		      /* Immediates are 7bit signed ints with bits 0..3 in
			 bits 0..3 of opcode and bits 4..6 in bits 5..7
			 of opcode.  */
		      {
			int imm;
d1784 2
a1785 1
			imm = (given & 0xf) | ((given & 0xe0) >> 1);
d1787 1
a1787 3
			/* Is ``imm'' a negative number?  */
			if (imm & 0x40)
			  imm |= (-1 << 7);
d1789 16
a1804 2
			func (stream, "%d", imm);
		      }
d1806 8
d1815 8
d1824 14
a1837 15
		    case 'F':
		      switch (given & 0x00408000)
			{
			case 0:
			  func (stream, "4");
			  break;
			case 0x8000:
			  func (stream, "1");
			  break;
			case 0x00400000:
			  func (stream, "2");
			  break;
			default:
			  func (stream, "3");
			}
d1839 2
d1842 7
a1848 16
		    case 'P':
		      switch (given & 0x00080080)
			{
			case 0:
			  func (stream, "s");
			  break;
			case 0x80:
			  func (stream, "d");
			  break;
			case 0x00080000:
			  func (stream, "e");
			  break;
			default:
			  func (stream, _("<illegal precision>"));
			  break;
			}
d1850 2
a1851 16
		    case 'Q':
		      switch (given & 0x00408000)
			{
			case 0:
			  func (stream, "s");
			  break;
			case 0x8000:
			  func (stream, "d");
			  break;
			case 0x00400000:
			  func (stream, "e");
			  break;
			default:
			  func (stream, "p");
			  break;
			}
d1853 2
a1854 15
		    case 'R':
		      switch (given & 0x60)
			{
			case 0:
			  break;
			case 0x20:
			  func (stream, "p");
			  break;
			case 0x40:
			  func (stream, "m");
			  break;
			default:
			  func (stream, "z");
			  break;
			}
d1856 10
d1867 1
a1867 2
		    case '0': case '1': case '2': case '3': case '4':
		    case '5': case '6': case '7': case '8': case '9':
d1869 21
a1889 2
			int width;
			unsigned long value;
d1891 6
a1896 1
			c = arm_decode_bitfield (c, given, &value, &width);
d1898 6
a1903 30
			switch (*c)
			  {
			  case 'r':
			    func (stream, "%s", arm_regnames[value]);
			    break;
			  case 'D':
			    func (stream, "d%ld", value);
			    break;
			  case 'Q':
			    if (value & 1)
			      func (stream, "<illegal reg q%ld.5>", value >> 1);
			    else
			      func (stream, "q%ld", value >> 1);
			    break;
			  case 'd':
			    func (stream, "%ld", value);
			    break;
                          case 'k':
                            {
                              int from = (given & (1 << 7)) ? 32 : 16;
                              func (stream, "%ld", from - value);
                            }
                            break;
                            
			  case 'f':
			    if (value > 7)
			      func (stream, "#%s", arm_fp_const[value & 7]);
			    else
			      func (stream, "f%ld", value);
			    break;
d1905 6
a1910 6
			  case 'w':
			    if (width == 2)
			      func (stream, "%s", iwmmxt_wwnames[value]);
			    else
			      func (stream, "%s", iwmmxt_wwssnames[value]);
			    break;
d1912 3
a1914 6
			  case 'g':
			    func (stream, "%s", iwmmxt_regnames[value]);
			    break;
			  case 'G':
			    func (stream, "%s", iwmmxt_cregnames[value]);
			    break;
d1916 18
a1933 3
			  case 'x':
			    func (stream, "0x%lx", value);
			    break;
d1935 5
a1939 18
			  case '`':
			    c++;
			    if (value == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if (value == ((1ul << width) - 1))
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    func (stream, "%c", c[(1 << width) - (int)value]);
			    c += 1 << width;
			    break;
			  default:
			    abort ();
			  }
			break;
d1941 1
a1941 2
		      case 'y':
		      case 'z':
d1943 4
a1946 4
			  int single = *c++ == 'y';
			  int regno;
			  
			  switch (*c)
d1948 2
a1949 48
			    case '4': /* Sm pair */
			    case '0': /* Sm, Dm */
			      regno = given & 0x0000000f;
			      if (single)
				{
				  regno <<= 1;
				  regno += (given >> 5) & 1;
				}
                              else
                                regno += ((given >> 5) & 1) << 4;
			      break;

			    case '1': /* Sd, Dd */
			      regno = (given >> 12) & 0x0000000f;
			      if (single)
				{
				  regno <<= 1;
				  regno += (given >> 22) & 1;
				}
                              else
                                regno += ((given >> 22) & 1) << 4;
			      break;

			    case '2': /* Sn, Dn */
			      regno = (given >> 16) & 0x0000000f;
			      if (single)
				{
				  regno <<= 1;
				  regno += (given >> 7) & 1;
				}
                              else
                                regno += ((given >> 7) & 1) << 4;
			      break;
			      
			    case '3': /* List */
			      func (stream, "{");
			      regno = (given >> 12) & 0x0000000f;
			      if (single)
				{
				  regno <<= 1;
				  regno += (given >> 22) & 1;
				}
                              else
                                regno += ((given >> 22) & 1) << 4;
			      break;
			      
			    default:
			      abort ();
d1951 3
d1955 10
a1964 1
			  func (stream, "%c%d", single ? 's' : 'd', regno);
d1966 3
a1968 1
			  if (*c == '3')
d1970 2
a1971 13
			      int count = given & 0xff;
			      
			      if (single == 0)
				count >>= 1;
			      
			      if (--count)
				{
				  func (stream, "-%c%d",
					single ? 's' : 'd',
					regno + count);
				}
			      
			      func (stream, "}");
d1973 3
a1975 5
			  else if (*c == '4')
			    func (stream, ", %c%d", single ? 's' : 'd',
				  regno + 1);
			}
			break;
d1977 11
a1987 11
		      case 'L':
			switch (given & 0x00400100)
			  {
			  case 0x00000000: func (stream, "b"); break;
			  case 0x00400000: func (stream, "h"); break;
			  case 0x00000100: func (stream, "w"); break;
			  case 0x00400100: func (stream, "d"); break;
			  default:
			    break;
			  }
			break;
d1989 2
a1990 6
		      case 'Z':
			{
			  int value;
			  /* given (20, 23) | given (0, 3) */
			  value = ((given >> 16) & 0xf0) | (given & 0xf);
			  func (stream, "%d", value);
a1991 1
			break;
d1993 3
a1995 4
		      case 'l':
			/* This is like the 'A' operator, except that if
			   the width field "M" is zero, then the offset is
			   *not* multiplied by four.  */
d1997 1
a1997 2
			  int offset = given & 0xff;
			  int multiplier = (given & 0x00000100) ? 4 : 1;
d1999 2
a2000 1
			  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);
d2002 1
a2002 1
			  if (offset)
d2004 3
a2006 9
			      if ((given & 0x01000000) != 0)
				func (stream, ", #%s%d]%s",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier,
				      ((given & 0x00200000) != 0 ? "!" : ""));
			      else
				func (stream, "], #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier);
d2008 2
a2009 2
			  else
			    func (stream, "]");
d2011 14
d2026 11
d2038 11
a2048 1
		      case 'r':
d2050 14
a2063 5
			  int imm4 = (given >> 4) & 0xf;
			  int puw_bits = ((given >> 22) & 6) | ((given >> 21) & 1);
			  int ubit = (given >> 23) & 1;
			  const char *rm = arm_regnames [given & 0xf];
			  const char *rn = arm_regnames [(given >> 16) & 0xf];
d2065 16
a2080 24
			  switch (puw_bits)
			    {
			    case 1:
			      /* fall through */
			    case 3:
			      func (stream, "[%s], %c%s", rn, ubit ? '+' : '-', rm);
			      if (imm4)
				func (stream, ", lsl #%d", imm4);
			      break;

			    case 4:
			      /* fall through */
			    case 5:
			      /* fall through */
			    case 6:
			      /* fall through */
			    case 7:
			      func (stream, "[%s, %c%s", rn, ubit ? '+' : '-', rm);
			      if (imm4 > 0)
				func (stream, ", lsl #%d", imm4);
			      func (stream, "]");
			      if (puw_bits == 5 || puw_bits == 7)
				func (stream, "!");
			      break;
d2082 11
a2092 5
			    default:
			      func (stream, "INVALID");
			    }
			}
			break;
d2094 2
a2095 5
		      case 'i':
			{
			  long imm5;
			  imm5 = ((given & 0x100) >> 4) | (given & 0xf);
			  func (stream, "%ld", (imm5 == 0) ? 32 : imm5);
d2097 2
a2098 1
			break;
d2100 5
a2104 3
		      default:
			abort ();
		      }
d2106 5
a2111 2
	      else
		func (stream, "%c", *c);
d2113 2
a2114 1
	  return TRUE;
d2116 1
d2226 1
a2226 1
	  /* move bit 28 to bit 24 to translate Thumb2 to ARM encoding.  */
d2692 12
a2703 7
      if ((given & insn->mask) == insn->value
	  /* Special case: an instruction with all bits set in the condition field
	     (0xFnnn_nnnn) is only matched if all those bits are set in insn->mask,
	     or by the catchall at the end of the table.  */
	  && ((given & 0xF0000000) != 0xF0000000
	      || (insn->mask & 0xF0000000) == 0xF0000000
	      || (insn->mask == 0 && insn->value == 0)))
d3977 41
d4042 34
d4231 1
a4231 1
      status = info->read_memory_func (pc, (bfd_byte *)b, 4, info);
d4261 1
a4261 1
	      status = info->read_memory_func (pc + 2, (bfd_byte *)b, 2, info);
d4273 1
a4273 1
	find_ifthen_state(pc, info, little_code);
@


1.96
log
@        PR 10263
        * arm-dis.c (print_insn): Ignore is_data if the user has requested
        the disassembly of data as well as instructions.

        * objdump.c (disassemble_bytes): Set the DISASSEMBLE_DATA bit in
        the flags field of the disassemble_info structure if the -D switch
        is in operation.

        * dis-asm.h (struct disassemble_info): New value for the flags
        field.
@
text
@d1248 1
a1248 1
  {ARM_EXT_V6T2, 0xf3af9004, 0xffffffff, "sev%c.w"},
@


1.95
log
@2009-04-01  Christophe Lyon  <christophe.lyon@@st.com>

	opcodes/
	* arm-dis.c (print_insn): Print BE8 opcodes in little endianness.

	ld/testsuite/
	* ld-arm/arm-elf.exp: BE8 tests expect the same output as the
	default ones.
	* ld-arm/arm-be8.d: Print opcodes in little endian.
	* ld-arm/farcall-thumb-arm-be8.d: Removed useless expected result.
	* ld-arm/farcall-arm-arm-be8.d: Likewise.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   2007, Free Software Foundation, Inc.
d4123 2
a4124 1
  if (is_data)
d4128 1
a4128 1
      /* size was already set above.  */
@


1.94
log
@gas/testsuite:
	* gas/arm/mapsecs.d, gas/arm/mapsecs.s: New.

opcodes:
	* arm-dis.c (print_insn): Also check section matches in backwards
	search for mapping symbol.
@
text
@d4116 5
a4120 1
  info->display_endian = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;
@


1.93
log
@	* arm-dis.c (neon_opcodes): Correct bit-mask and patterns for
	vq{r}shr{u}n.s64 insnstructions.
@
text
@d4044 3
a4046 1
	      if (get_sym_code_type (info, n, &type))
@


1.92
log
@gas:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* config/tc-arm.c (insns): Correct encoding of qadd, qdadd, qsub,
	qdsub in Thumb-2 mode.

gas/testsuite:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* gas/arm/thumb32.s (qadd): Add qadd, qdadd, qsub, and qdsub.
	* gas/arm/thumb32.d: Likewise.

opcodes:
2009-01-29  Mark Mitchell  <mark@@codesourcery.com>

	* arm-dis.c (thumb32_opcodes): Correct decoding for qadd, qdadd,
	qsub, and qdsub.
@
text
@d654 4
a657 4
  {FPU_NEON_EXT_V1, 0xf2800810, 0xfec00fd0, "vqshrun%c.s64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800850, 0xfec00fd0, "vqrshrun%c.s64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800910, 0xfec00fd0, "vqshrn%c.%24?us64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800950, 0xfec00fd0, "vqrshrn%c.%24?us64\t%12-15,22D, %0-3,5Q, #%16-20e"},
@


1.91
log
@opcodes:
	* arm-dis.c (coprocessor_opcodes): Disassemble VFP instructions using
	unified syntax.
gas/testsuite:
	* gas/arm/group-reloc-ldc.d: Disassembly of VFP instructions now uses
	unified syntax.
	* gas/arm/vfp-non-overlap.d: Likewise.
	* gas/arm/vfp-neon-syntax.d: Likewise.
	* gas/arm/vfp-neon-syntax_t2.d: Likewise.
	* gas/arm/vfp1.d: Likewise.
	* gas/arm/vfp1_t2.d: Likewise.
	* gas/arm/vfp1xD.d: Likewise.
	* gas/arm/vfp1xD_t2.d: Likewise.
	* gas/arm/vfp2.d: Likewise.
	* gas/arm/vfp2_t2.d: Likewise.
	* gas/arm/vfpv3-32drs.d: Likewise.
	* gas/arm/vfpv3-const-conv.d: Likewise.
ld/testsuite:
	* ld-arm/vfp11-fix-scalar.d: Disassembly of VFP instructions now uses
	unified syntax.
	* ld-arm/vfp11-fix-vector.d: Likewise.
@
text
@d1283 4
a1286 4
  {ARM_EXT_V6T2, 0xfa80f080, 0xfff0f0f0, "qadd%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f090, 0xfff0f0f0, "qdadd%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0a0, 0xfff0f0f0, "qsub%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0b0, 0xfff0f0f0, "qdsub%c\t%8-11r, %0-3r, %16-19r"},
@


1.90
log
@Add support for ARM half-precision conversion instructions.
@
text
@d245 21
a265 6
  {FPU_NEON_EXT_V1, 0x0d200b00, 0x0fb00f01, "vstmdb%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0d300b00, 0x0fb00f01, "vldmdb%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0c800b00, 0x0f900f01, "vstmia%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0c900b00, 0x0f900f01, "vldmia%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0d000b00, 0x0f300f00, "vstr%c\t%12-15,22D, %C"},
  {FPU_NEON_EXT_V1, 0x0d100b00, 0x0f300f00, "vldr%c\t%12-15,22D, %C"},
d287 67
a353 83
  {FPU_VFP_EXT_V1xD, 0x0ef1fa10, 0x0fffffff, "fmstat%c"},
  {FPU_VFP_EXT_V1xD, 0x0ee00a10, 0x0fff0fff, "fmxr%c\tfpsid, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee10a10, 0x0fff0fff, "fmxr%c\tfpscr, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee60a10, 0x0fff0fff, "fmxr%c\tmvfr1, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee70a10, 0x0fff0fff, "fmxr%c\tmvfr0, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee80a10, 0x0fff0fff, "fmxr%c\tfpexc, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee90a10, 0x0fff0fff, "fmxr%c\tfpinst, %12-15r\t@@ Impl def"},
  {FPU_VFP_EXT_V1xD, 0x0eea0a10, 0x0fff0fff, "fmxr%c\tfpinst2, %12-15r\t@@ Impl def"},
  {FPU_VFP_EXT_V1xD, 0x0ef00a10, 0x0fff0fff, "fmrx%c\t%12-15r, fpsid"},
  {FPU_VFP_EXT_V1xD, 0x0ef10a10, 0x0fff0fff, "fmrx%c\t%12-15r, fpscr"},
  {FPU_VFP_EXT_V1xD, 0x0ef60a10, 0x0fff0fff, "fmrx%c\t%12-15r, mvfr1"},
  {FPU_VFP_EXT_V1xD, 0x0ef70a10, 0x0fff0fff, "fmrx%c\t%12-15r, mvfr0"},
  {FPU_VFP_EXT_V1xD, 0x0ef80a10, 0x0fff0fff, "fmrx%c\t%12-15r, fpexc"},
  {FPU_VFP_EXT_V1xD, 0x0ef90a10, 0x0fff0fff, "fmrx%c\t%12-15r, fpinst\t@@ Impl def"},
  {FPU_VFP_EXT_V1xD, 0x0efa0a10, 0x0fff0fff, "fmrx%c\t%12-15r, fpinst2\t@@ Impl def"},
  {FPU_VFP_EXT_V1, 0x0e000b10, 0x0ff00fff, "fmdlr%c\t%z2, %12-15r"},
  {FPU_VFP_EXT_V1, 0x0e100b10, 0x0ff00fff, "fmrdl%c\t%12-15r, %z2"},
  {FPU_VFP_EXT_V1, 0x0e200b10, 0x0ff00fff, "fmdhr%c\t%z2, %12-15r"},
  {FPU_VFP_EXT_V1, 0x0e300b10, 0x0ff00fff, "fmrdh%c\t%12-15r, %z2"},
  {FPU_VFP_EXT_V1xD, 0x0ee00a10, 0x0ff00fff, "fmxr%c\t<impl def %16-19x>, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ef00a10, 0x0ff00fff, "fmrx%c\t%12-15r, <impl def %16-19x>"},
  {FPU_VFP_EXT_V1xD, 0x0e000a10, 0x0ff00f7f, "fmsr%c\t%y2, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0e100a10, 0x0ff00f7f, "fmrs%c\t%12-15r, %y2"},
  {FPU_VFP_EXT_V1xD, 0x0eb50a40, 0x0fbf0f70, "fcmp%7'ezs%c\t%y1"},
  {FPU_VFP_EXT_V1, 0x0eb50b40, 0x0fbf0f70, "fcmp%7'ezd%c\t%z1"},
  {FPU_VFP_EXT_V1xD, 0x0eb00a40, 0x0fbf0fd0, "fcpys%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb00ac0, 0x0fbf0fd0, "fabss%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb00b40, 0x0fbf0fd0, "fcpyd%c\t%z1, %z0"},
  {FPU_VFP_EXT_V1, 0x0eb00bc0, 0x0fbf0fd0, "fabsd%c\t%z1, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0eb10a40, 0x0fbf0fd0, "fnegs%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb10ac0, 0x0fbf0fd0, "fsqrts%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb10b40, 0x0fbf0fd0, "fnegd%c\t%z1, %z0"},
  {FPU_VFP_EXT_V1, 0x0eb10bc0, 0x0fbf0fd0, "fsqrtd%c\t%z1, %z0"},
  {FPU_VFP_EXT_V1, 0x0eb70ac0, 0x0fbf0fd0, "fcvtds%c\t%z1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb70bc0, 0x0fbf0fd0, "fcvtsd%c\t%y1, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0eb80a40, 0x0fbf0fd0, "fuitos%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb80ac0, 0x0fbf0fd0, "fsitos%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb80b40, 0x0fbf0fd0, "fuitod%c\t%z1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb80bc0, 0x0fbf0fd0, "fsitod%c\t%z1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb40a40, 0x0fbf0f50, "fcmp%7'es%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb40b40, 0x0fbf0f50, "fcmp%7'ed%c\t%z1, %z0"},
  {FPU_VFP_EXT_V3, 0x0eba0a40, 0x0fbe0f50, "f%16?us%7?lhtos%c\t%y1, #%5,0-3k"},
  {FPU_VFP_EXT_V3, 0x0eba0b40, 0x0fbe0f50, "f%16?us%7?lhtod%c\t%z1, #%5,0-3k"},
  {FPU_VFP_EXT_V1xD, 0x0ebc0a40, 0x0fbe0f50, "fto%16?sui%7'zs%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0ebc0b40, 0x0fbe0f50, "fto%16?sui%7'zd%c\t%y1, %z0"},
  {FPU_VFP_EXT_V3, 0x0ebe0a40, 0x0fbe0f50, "fto%16?us%7?lhs%c\t%y1, #%5,0-3k"},
  {FPU_VFP_EXT_V3, 0x0ebe0b40, 0x0fbe0f50, "fto%16?us%7?lhd%c\t%z1, #%5,0-3k"},
  {FPU_VFP_EXT_V1, 0x0c500b10, 0x0fb00ff0, "fmrrd%c\t%12-15r, %16-19r, %z0"},
  {FPU_VFP_EXT_V3, 0x0eb00a00, 0x0fb00ff0, "fconsts%c\t%y1, #%0-3,16-19d"},
  {FPU_VFP_EXT_V3, 0x0eb00b00, 0x0fb00ff0, "fconstd%c\t%z1, #%0-3,16-19d"},
  {FPU_VFP_EXT_V2, 0x0c400a10, 0x0ff00fd0, "fmsrr%c\t%y4, %12-15r, %16-19r"},
  {FPU_VFP_EXT_V2, 0x0c400b10, 0x0ff00fd0, "fmdrr%c\t%z0, %12-15r, %16-19r"},
  {FPU_VFP_EXT_V2, 0x0c500a10, 0x0ff00fd0, "fmrrs%c\t%12-15r, %16-19r, %y4"},
  {FPU_VFP_EXT_V1xD, 0x0e000a00, 0x0fb00f50, "fmacs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e000a40, 0x0fb00f50, "fnmacs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e000b00, 0x0fb00f50, "fmacd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e000b40, 0x0fb00f50, "fnmacd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e100a00, 0x0fb00f50, "fmscs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e100a40, 0x0fb00f50, "fnmscs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e100b00, 0x0fb00f50, "fmscd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e100b40, 0x0fb00f50, "fnmscd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e200a00, 0x0fb00f50, "fmuls%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e200a40, 0x0fb00f50, "fnmuls%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e200b00, 0x0fb00f50, "fmuld%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e200b40, 0x0fb00f50, "fnmuld%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e300a00, 0x0fb00f50, "fadds%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e300a40, 0x0fb00f50, "fsubs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e300b00, 0x0fb00f50, "faddd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e300b40, 0x0fb00f50, "fsubd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e800a00, 0x0fb00f50, "fdivs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e800b00, 0x0fb00f50, "fdivd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0d200a00, 0x0fb00f00, "fstmdbs%c\t%16-19r!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0d200b00, 0x0fb00f00, "fstmdb%0?xd%c\t%16-19r!, %z3"},
  {FPU_VFP_EXT_V1xD, 0x0d300a00, 0x0fb00f00, "fldmdbs%c\t%16-19r!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0d300b00, 0x0fb00f00, "fldmdb%0?xd%c\t%16-19r!, %z3"},
  {FPU_VFP_EXT_V1xD, 0x0d000a00, 0x0f300f00, "fsts%c\t%y1, %A"},
  {FPU_VFP_EXT_V1, 0x0d000b00, 0x0f300f00, "fstd%c\t%z1, %A"},
  {FPU_VFP_EXT_V1xD, 0x0d100a00, 0x0f300f00, "flds%c\t%y1, %A"},
  {FPU_VFP_EXT_V1, 0x0d100b00, 0x0f300f00, "fldd%c\t%z1, %A"},
  {FPU_VFP_EXT_V1xD, 0x0c800a00, 0x0f900f00, "fstmias%c\t%16-19r%21'!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0c800b00, 0x0f900f00, "fstmia%0?xd%c\t%16-19r%21'!, %z3"},
  {FPU_VFP_EXT_V1xD, 0x0c900a00, 0x0f900f00, "fldmias%c\t%16-19r%21'!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0c900b00, 0x0f900f00, "fldmia%0?xd%c\t%16-19r%21'!, %z3"},
a1936 2
			      func (stream, "{");
			      /* Fall through.  */
d2005 1
a2005 1
			    func (stream, ", %c%d}", single ? 's' : 'd',
d2009 1
a2009 1
			    
@


1.89
log
@2008-07-07  Stan Shebs  <stan@@codesourcery.com>

	    * dis-init.c (init_disassemble_info): Init endian_code field.
	    * arm-dis.c (print_insn): Disassemble code according to
	    setting of endian_code.
	    (print_insn_big_arm): Detect when BE8 extension flag has been set.
@
text
@d267 3
d510 4
@


1.88
log
@* arm-dis.c (arm_opcodes): Remove superflous escapes of percent operators.
@
text
@d3977 1
d3990 4
d4139 1
a4139 1
      if (little)
d4155 1
a4155 1
      if (little)
d4169 1
a4169 1
	      if (little)
d4180 1
a4180 1
	find_ifthen_state(pc, info, little);
d4218 6
@


1.87
log
@* arm-dis.c (print_insn): Check for a symtab that exists but is empty.
@
text
@d869 4
a872 4
  {ARM_EXT_V6, 0x06bf0f30, 0x0fff0ff0, "rev%c\t\%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06bf0fb0, 0x0fff0ff0, "rev16%c\t\%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06ff0fb0, 0x0fff0ff0, "revsh%c\t\%12-15r, %0-3r"},
  {ARM_EXT_V6, 0xf8100a00, 0xfe50ffff, "rfe%23?id%24?ba\t\%16-19r%21'!"},
@


1.86
log
@Change source files over to GPLv3.
@
text
@d3992 1
@


1.85
log
@2007-06-26  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (parse_operands): Accept generic coprocessor regs
	for OP_RVC.
	(reg_names): Add fpinst, pfinst2, mvfr0 and mvfr1.

	gas/testsuite/
	* gas/arm/vfp1xD.d: Add new fmrx/fmxr tests.
	* gas/arm/vfp1xD.s: Ditto.
	* gas/arm/vfp1xD_t2.d: Ditto.
	* gas/arm/vfp1xD_t2.s: Ditto.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Add fmxr/fmrx mvfr0/mvfr1.
@
text
@d9 9
a17 9
   This program is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.84
log
@2007-06-05  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (insns): Correct Thumb-2 ldrd/strd opcodes.

	gas/testsuite/
	* gas/arm/thumb32.d: Add writeback addressing mode tests.
	* gas/arm/thumb32.s: Update expected output.

	opcodes/
	* arm-dis.c (thumb32_opcodes): Display writeback ldrd/strd addresses.
@
text
@d271 2
d278 2
@


1.83
log
@Fix compile time warning (at -O3 with gcc 4.1.2)
@
text
@d1406 4
a1409 2
  {ARM_EXT_V6T2, 0xe9400000, 0xff500000, "strd%c\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]"},
  {ARM_EXT_V6T2, 0xe9500000, 0xff500000, "ldrd%c\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]"},
@


1.82
log
@	* arm-dis.c (arm_opcodes): Disassemble to unified syntax.
	(thumb_opcodes): Add missing white space in adr.
	(arm_decode_shift): New parameter, print_shift.  Only decode the
	shift parameter if set.  Adjust callers.
	(print_insn_arm): Support for operand type q with no shift decode.
@
text
@d3990 1
a3990 1
      enum map_type type;
@


1.81
log
@	* arm-dis.c (print_insn): Only look for a mapping symbol in the section
	being disassembled.
@
text
@d66 1
d440 2
a441 2
  {ARM_EXT_V2, 0x0c000000, 0x0e100000, "stc%c%22'l\t%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V2, 0x0c100000, 0x0e100000, "ldc%c%22'l\t%8-11d, cr%12-15d, %A"},
d774 5
a778 5
  {ARM_EXT_V2, 0x00000090, 0x0fe000f0, "mul%c%20's\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V2, 0x00200090, 0x0fe000f0, "mla%c%20's\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V2S, 0x01000090, 0x0fb00ff0, "swp%c%22'b\t%12-15r, %0-3r, [%16-19r]"},
  {ARM_EXT_V3M, 0x00800090, 0x0fa000f0, "%22?sumull%c%20's\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V3M, 0x00a00090, 0x0fa000f0, "%22?sumlal%c%20's\t%12-15r, %16-19r, %0-3r, %8-11r"},
d791 2
a792 2
  {ARM_EXT_V6T2, 0x006000b0, 0x0f7000f0, "str%cht\t%12-15r, %s"},
  {ARM_EXT_V6T2, 0x00300090, 0x0f300090, "ldr%c%6's%5?hbt\t%12-15r, %s"},
d824 3
a826 3
  {ARM_EXT_V6, 0x06800010, 0x0ff00070, "pkhbt%c\t%12-15r, %16-19r, %0-3r, LSL #%7-11d"},
  {ARM_EXT_V6, 0x06800050, 0x0ff00ff0, "pkhtb%c\t%12-15r, %16-19r, %0-3r, ASR #32"},
  {ARM_EXT_V6, 0x06800050, 0x0ff00070, "pkhtb%c\t%12-15r, %16-19r, %0-3r, ASR #%7-11d"},
d868 24
a891 24
  {ARM_EXT_V6, 0x06bf0070, 0x0fff0ff0, "sxth%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x06bf0470, 0x0fff0ff0, "sxth%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06bf0870, 0x0fff0ff0, "sxth%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06bf0c70, 0x0fff0ff0, "sxth%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x068f0070, 0x0fff0ff0, "sxtb16%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x068f0470, 0x0fff0ff0, "sxtb16%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x068f0870, 0x0fff0ff0, "sxtb16%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x068f0c70, 0x0fff0ff0, "sxtb16%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06af0070, 0x0fff0ff0, "sxtb%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x06af0470, 0x0fff0ff0, "sxtb%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06af0870, 0x0fff0ff0, "sxtb%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06af0c70, 0x0fff0ff0, "sxtb%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06ff0070, 0x0fff0ff0, "uxth%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x06ff0470, 0x0fff0ff0, "uxth%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06ff0870, 0x0fff0ff0, "uxth%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06ff0c70, 0x0fff0ff0, "uxth%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06cf0070, 0x0fff0ff0, "uxtb16%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x06cf0470, 0x0fff0ff0, "uxtb16%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06cf0870, 0x0fff0ff0, "uxtb16%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06cf0c70, 0x0fff0ff0, "uxtb16%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06ef0070, 0x0fff0ff0, "uxtb%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x06ef0470, 0x0fff0ff0, "uxtb%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06ef0870, 0x0fff0ff0, "uxtb%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06ef0c70, 0x0fff0ff0, "uxtb%c %12-15r,%0-3r, ROR #24"},
d893 3
a895 3
  {ARM_EXT_V6, 0x06b00470, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06b00870, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06b00c70, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
d897 3
a899 3
  {ARM_EXT_V6, 0x06800470, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06800870, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06800c70, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
d901 3
a903 3
  {ARM_EXT_V6, 0x06a00470, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06a00870, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06a00c70, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
d905 3
a907 3
  {ARM_EXT_V6, 0x06f00470, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06f00870, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06f00c70, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
d909 2
a910 2
  {ARM_EXT_V6, 0x06c00470, 0x0ff00ff0, "uxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06c00870, 0x0ff00ff0, "uxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
d913 3
a915 3
  {ARM_EXT_V6, 0x06e00470, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06e00870, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06e00c70, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
d929 2
a930 2
  {ARM_EXT_V6, 0x06a00010, 0x0fe00070, "ssat%c\t%12-15r, #%16-20W, %0-3r, LSL #%7-11d"},
  {ARM_EXT_V6, 0x06a00050, 0x0fe00070, "ssat%c\t%12-15r, #%16-20W, %0-3r, ASR #%7-11d"},
d937 2
a938 2
  {ARM_EXT_V6, 0x06e00010, 0x0fe00070, "usat%c\t%12-15r, #%16-20d, %0-3r, LSL #%7-11d"},
  {ARM_EXT_V6, 0x06e00050, 0x0fe00070, "usat%c\t%12-15r, #%16-20d, %0-3r, ASR #%7-11d"},
d951 2
a952 2
  {ARM_EXT_V5E, 0x000000d0, 0x0e1000f0, "ldr%cd\t%12-15r, %s"},
  {ARM_EXT_V5E, 0x000000f0, 0x0e1000f0, "str%cd\t%12-15r, %s"},
d981 10
a990 10
  {ARM_EXT_V1, 0x00000090, 0x0e100090, "str%c%6's%5?hb\t%12-15r, %s"},
  {ARM_EXT_V1, 0x00100090, 0x0e100090, "ldr%c%6's%5?hb\t%12-15r, %s"},
  {ARM_EXT_V1, 0x00000000, 0x0de00000, "and%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00200000, 0x0de00000, "eor%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00400000, 0x0de00000, "sub%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00600000, 0x0de00000, "rsb%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00800000, 0x0de00000, "add%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00a00000, 0x0de00000, "adc%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00c00000, 0x0de00000, "sbc%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00e00000, 0x0de00000, "rsc%c%20's\t%12-15r, %16-19r, %o"},
d993 18
a1010 11
  {ARM_EXT_V1, 0x01000000, 0x0de00000, "tst%c%p\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01200000, 0x0de00000, "teq%c%p\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01400000, 0x0de00000, "cmp%c%p\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01600000, 0x0de00000, "cmn%c%p\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01800000, 0x0de00000, "orr%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x01a00000, 0x0de00000, "mov%c%20's\t%12-15r, %o"},
  {ARM_EXT_V1, 0x01c00000, 0x0de00000, "bic%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x01e00000, 0x0de00000, "mvn%c%20's\t%12-15r, %o"},
  {ARM_EXT_V1, 0x04000000, 0x0e100000, "str%c%22'b%t\t%12-15r, %a"},
  {ARM_EXT_V1, 0x06000000, 0x0e100ff0, "str%c%22'b%t\t%12-15r, %a"},
  {ARM_EXT_V1, 0x04000000, 0x0c100010, "str%c%22'b%t\t%12-15r, %a"},
d1012 8
a1019 3
  {ARM_EXT_V1, 0x04100000, 0x0c100000, "ldr%c%22'b%t\t%12-15r, %a"},
  {ARM_EXT_V1, 0x08000000, 0x0e100000, "stm%c%23?id%24?ba\t%16-19r%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x08100000, 0x0e100000, "ldm%c%23?id%24?ba\t%16-19r%21'!, %m%22'^"},
d1153 1
a1153 1
  {ARM_EXT_V4T, 0xA000, 0xF800, "add%c\t%8-10r, pc, #%0-7W\t(adr %8-10r,%0-7a)"},
d1572 2
a1573 1
arm_decode_shift (long given, fprintf_ftype func, void *stream)
d1595 4
a1598 1
	  func (stream, ", %s #%d", arm_shift[shift], amount);
d1600 1
a1600 1
      else
d1603 2
d2169 1
a2169 1
	      arm_decode_shift (given, func, stream);
d2192 1
a2192 1
	      arm_decode_shift (given, func, stream);
d2806 4
d2820 1
a2820 1
			arm_decode_shift (given, func, stream);
@


1.80
log
@2006-03-27  Paul Brook  <paul@@codesourcery.com>

	opcodes/
	* arm-dis.c (thumb_opcodes): Add entry for undefined insns (0xbe??).
@
text
@d3 1
a3 1
   Free Software Foundation, Inc.
d3985 3
a3987 1
	  if (get_sym_code_type (info, n, &type))
@


1.79
log
@2007-03-24  Paul Brook  <paul@@codesourcery.com>

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Remove superfluous 0x.
	(print_insn_coprocessor): Handle %<bitfield>x.
@
text
@d1148 1
@


1.78
log
@2007-03-24  Paul Brook  <paul@@codesourcery.com>
	Mark Shinwell  <shinwell@@codesourcery.com>

	gas/
	* config/tc-arm.c (operand_parse_code): Add OP_oRRw.
	(parse_operands): Don't expect comma if first operand missing.
	Handle OP_oRRw.
	(do_srs): Encode register number, checking it is r13.  Update comment.
	(insns): Update SRS entries to take a register.

	gas/testsuite/
	* gas/arm/archv6.s: Add new SRS tests.
	* gas/arm/archv6.d: Update expected output.
	* gas/arm/thumb32.s: Add new SRS tests.
	* gas/arm/thumb32.d: Update expected output.
	* gas/arm/srs-t2.d: New.
	* gas/arm/srs-t2.l: New.
	* gas/arm/srs-t2.s: New.
	* gas/arm/srs-arm.d: New.
	* gas/arm/srs-arm.l: New.
	* gas/arm/srs-arm.s: New.

	opcodes/
	* arm-dis.c (arm_opcodes): Print SRS base register.
@
text
@d282 2
a283 2
  {FPU_VFP_EXT_V1xD, 0x0ee00a10, 0x0ff00fff, "fmxr%c\t<impl def 0x%16-19x>, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ef00a10, 0x0ff00fff, "fmrx%c\t%12-15r, <impl def 0x%16-19x>"},
d1871 5
@


1.77
log
@2007-01-04  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_cpsi): Set mmod bit for 2 argument form.
	gas/testsuite/
	* gas/arm/archv6.s: Add more cpsie tests.
	* gas/arm/archv6.d: Ditto.
	opcodes/
	* arm-dis.c (arm_opcodes): Fix cpsie and cpsid entries.
@
text
@d926 1
a926 1
  {ARM_EXT_V6, 0xf84d0500, 0xfe5fffe0, "srs%23?id%24?ba\t#%0-4d%21'!"},
d1242 2
a1243 2
  {ARM_EXT_V6T2, 0xe800c000, 0xffd0ffe0, "srsdb%c\t#%0-4d%21'!"},
  {ARM_EXT_V6T2, 0xe980c000, 0xffd0ffe0, "srsia%c\t#%0-4d%21'!"},
@


1.76
log
@	* arm-dis.c (neon_opcode): Fix disassembly for vshl, vqshl, vrshl,
	vqrshl instructions.
@
text
@d817 4
a820 4
  {ARM_EXT_V6, 0xf1080000, 0xfffdfe3f, "cpsie\t%8'a%7'i%6'f"},
  {ARM_EXT_V6, 0xf1080000, 0xfffdfe20, "cpsie\t%8'a%7'i%6'f,#%0-4d"},
  {ARM_EXT_V6, 0xf10C0000, 0xfffdfe3f, "cpsid\t%8'a%7'i%6'f"},
  {ARM_EXT_V6, 0xf10C0000, 0xfffdfe20, "cpsid\t%8'a%7'i%6'f,#%0-4d"},
@


1.75
log
@2006-11-29  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_vfp_sp_const, do_vfp_dp_const): Fix operans
	encoding.

	gas/testsuite/
	* gas/arm/vfpv3-const-conv.s: Improve test coverage.
	* gas/arm/vfpv3-const-conv.d: Adjust expected output.
	* gas/arm/vfp-neon-syntax_t2.d: Ditto.
	* gas/arm/vfp-neon-syntax.d: Ditto.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Fix bitfields for fconstd/fconstd.
@
text
@d579 4
a582 4
  {FPU_NEON_EXT_V1, 0xf2000400, 0xfe800f10, "vshl%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000410, 0xfe800f10, "vqshl%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000500, 0xfe800f10, "vrshl%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000510, 0xfe800f10, "vqrshl%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
@


1.74
log
@opcodes/
	* arm-dis.c (last_is_thumb): Delete.
	(enum map_type, last_type): New.
	(print_insn_data): New.
	(get_sym_code_type): Take MAP_TYPE argument.  Check the type of
	the right symbol.  Handle $d.
	(print_insn): Check for mapping symbols even without a normal
	symbol.  Adjust searching.  If $d is found see how much data
	to print.  Handle data.
gas/
	* config/tc-arm.h (md_cons_align): Define.
	(mapping_state): New prototype.
	* config/tc-arm.c (mapping_state): Make global.
gas/testsuite/
	* gas/arm/arm7t.d, gas/arm/neon-ldst-rm.d, gas/arm/thumb2_pool.d,
	gas/arm/tls.d: Update for $d support.
	* gas/arm/mapshort.d, gas/arm/mapshort.s: New test.
	* gas/elf/section2.e-armeabi: Update.
	* gas/elf/section2.e-armelf: New file.
	* gas/elf/elf.exp: Use it.
ld/testsuite/
	* ld-arm/mixed-app.d, ld-arm/tls-app.d, ld-arm/tls-lib.d: Update
	for $d support.
@
text
@d311 2
a312 2
  {FPU_VFP_EXT_V3, 0x0eb00a00, 0x0fb00ff0, "fconsts%c\t%y1, #%16-19,0-3d"},
  {FPU_VFP_EXT_V3, 0x0eb00b00, 0x0fb00ff0, "fconstd%c\t%z1, #%16-19,0-3d"},
@


1.73
log
@2006-10-30  Paul Brook  <paul@@codesourcery.com>

	binutils/
	* objdump.c (disassemble_section): Set info->symtab_pos.
	(disassemble_data): Set info->symtab and info->symtab_size.

	include/
	* dis-asm.h (disassemble_info): Add symtab, symtab_pos and
	symtab_size.

	opcodes/
	* arm-dis.c (last_is_thumb, last_mapping_sym, last_mapping_addr): New.
	(get_sym_code_type): New function.
	(print_insn): Search for mapping symbols.
@
text
@d1483 8
a1490 2
/* Cached Thumb state.  */
int last_is_thumb;
d3720 22
d3896 1
a3896 1
   Returns nonzero if is_thumb was set.  */
d3899 2
a3900 1
get_sym_code_type (struct disassemble_info *info, int n, int *is_thumb)
d3906 1
a3906 1
  es = *(elf_symbol_type **)(info->symbols);
d3912 1
a3912 1
      *is_thumb = (type == STT_ARM_TFUNC);
d3918 1
a3918 1
  if (name[0] == '$' && (name[1] == 'a' || name[1] == 't')
d3921 3
a3923 1
      *is_thumb = (name[1] == 't');
d3939 3
a3941 2
  int           is_thumb;
  int		size;
d3943 1
d3953 81
a4033 1
  is_thumb = force_thumb;
d4035 1
a4035 1
  if (!is_thumb && info->symbols != NULL)
d4048 2
a4049 1
      else if (bfd_asymbol_flavour (*info->symbols) == bfd_target_elf_flavour)
a4050 53
	  bfd_vma addr;
	  int n;
	  int last_sym;
	  bfd_boolean found;

	  if (info->symtab)
	    {
	      if (pc <= last_mapping_addr)
		last_mapping_sym = -1;
	      is_thumb = last_is_thumb;
	      found = FALSE;
	      /* Start scanning at the start of the function, or wherever
		 we finished last time.  */
	      n = info->symtab_pos + 1;
	      if (n < last_mapping_sym)
		n = last_mapping_sym;

	      /* Scan up to the location being disassembled.  */
	      for (; n < info->symtab_size; n++)
		{
		  addr = bfd_asymbol_value (info->symtab[n]);
		  if (addr > pc)
		    break;
		  if (get_sym_code_type (info, n, &is_thumb))
		    found = TRUE;
		}

	      last_sym = n;
	      if (!found)
		{
		  if (last_mapping_sym == -1)
		    last_mapping_sym = 0;
		  else
		    found = TRUE;

		  /* No mapping symbol found at this address.  Look backwards
		     for a preceeding one.  */
		  for (n = info->symtab_pos; n >= last_mapping_sym; n--)
		    {
		      if (get_sym_code_type (info, n, &is_thumb))
			{
			  found = TRUE;
			  break;
			}
		    }
		}

	      last_mapping_sym = last_sym;
	      last_is_thumb = is_thumb;
	    }
	  else
	    found = FALSE;

d4053 2
a4054 4
	  if (!found)
	    {
	      elf_symbol_type *  es;
	      unsigned int       type;
d4056 2
a4057 2
	      es = *(elf_symbol_type **)(info->symbols);
	      type = ELF_ST_TYPE (es->internal_elf_sym.st_info);
d4059 1
a4059 2
	      is_thumb = (type == STT_ARM_TFUNC) || (type == STT_ARM_16BIT);
	    }
d4063 4
a4066 1
  info->display_endian  = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;
d4069 18
a4086 1
  if (!is_thumb)
@


1.72
log
@bfd/
2006-09-26  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	* archures.c: Add definition for bfd_mach_arm_iWMMXt2.
	* cpu-arm.c (processors): Add bfd_mach_arm_iWMMXt2.
	(arch_info_struct, bfd_arm_update_notes): Likewise.
	(architectures): Likewise.
	(bfd_arm_merge_machines): Check for iWMMXt2.
	* bfd-in2.h: Rebuild.

gas/
2006-09-26  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	* config/tc-arm.c (arm_cext_iwmmxt2): New.
	(enum operand_parse_code): New code OP_RIWR_I32z.
	(parse_operands): Handle OP_RIWR_I32z.
	(do_iwmmxt_wmerge): New function.
	(do_iwmmxt_wldstd): Handle iwmmxt2 case where second operand is
	a register.
	(do_iwmmxt_wrwrwr_or_imm5): New function.
	(insns): Mark instructions as RIWR_I32z as appropriate.
	Also add torvsc<b,h,w>, wabs<b,h,w>, wabsdiff<b,h,w>,
	waddbhus<l,m>, waddhc, waddwc, waddsubhx, wavg4{r}, wmaddu{x,n},
	wmadds{x,n}, wmerge, wmiaxy{n}, wmiawxy{n}, wmul<sm,um>{r},
	wmulw<um,sm,l>{r}, wqmiaxy{n}, wqmulm{r}, wqmulwm{r}, wsubaddhx.
	(md_begin): Handle IWMMXT2.
	(arm_cpus): Add iwmmxt2.
	(arm_extensions): Likewise.
	(arm_archs): Likewise.

gas/testsuite/
2006-09-26  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	* gas/arm/iwmmxt2.s: New file.
	* gas/arm/iwmmxt2.d: New file.

include/opcode/
2006-09-26  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	* arm.h (ARM_CEXT_IWMMXT2, ARM_ARCH_IWMMXT2): Define.

opcodes/
2006-09-26  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	* arm-dis.c (coprocessor_opcodes): The X-qualifier to WMADD may
	only be used with the default multiply-add operation, so if N is
	set, don't bother printing X.  Add new iwmmxt instructions.
	(IWMMXT_INSN_COUNT): Update.
	(iwmmxt_wwssnames): Qualify "wwss" names at index 2, 6, 10 and 14
	with a 'c' suffix.
	(print_insn_coprocessor): Check for iWMMXt2.  Handle format
	specifiers 'r', 'i'.
@
text
@d1483 5
d3867 32
d3937 4
a3940 2
	  elf_symbol_type *  es;
	  unsigned int       type;
d3942 11
a3952 2
	  es = *(elf_symbol_type **)(info->symbols);
	  type = ELF_ST_TYPE (es->internal_elf_sym.st_info);
d3954 48
a4001 1
	  is_thumb = (type == STT_ARM_TFUNC) || (type == STT_ARM_16BIT);
@


1.71
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d101 5
a105 1
			versions.  */
d120 1
a120 1
#define IWMMXT_INSN_COUNT 47
d135 2
d139 2
d145 1
d148 1
d152 2
a153 1
  {ARM_CEXT_XSCALE, 0x0e800100, 0x0fd00ff0, "wmadd%21?su%c\t%12-15g, %16-19g, %0-3g"},
d155 3
d159 8
a166 1
  {ARM_CEXT_XSCALE, 0x0e000100, 0x0fc00ff0, "wmul%21?su%20?ml%c\t%12-15g, %16-19g, %0-3g"},
d169 3
a171 2
  {ARM_CEXT_XSCALE, 0x0e300040, 0x0f300ff0, "wror%22-23w%8'g%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e300148, 0x0f300ffc, "wror%22-23w%8'g%c\t%12-15g, %16-19g, %0-3G"},
d174 1
d177 1
d180 1
d183 1
d187 5
a191 1
  {ARM_CEXT_XSCALE, 0x0e0000c0, 0x0f100fff, "wunpckeh%21?su%22-23w%c\t%12-15g, %16-19g"},
d1450 4
a1453 4
{"b", "bus", "b", "bss",
 "h", "hus", "h", "hss",
 "w", "wus", "w", "wss",
 "d", "dus", "d", "dss"
d1596 2
a1597 1
	  && info->mach != bfd_mach_arm_iWMMXt)
d2011 47
@


1.70
log
@2006-09-04  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_neon_dyadic_if_i): Remove.
	(do_neon_dyadic_if_i_d): Avoid setting U bit.
	(do_neon_mac_maybe_scalar): Ditto.
	(do_neon_dyadic_narrow): Force operand type to NT_integer.
	(insns): Remove out of date comments.

	gas/testsuite/
	* gas/arm/neon-cov.s: Test .u and .s aliases for .i suffixes.
	* gas/arm/neon-cov.d: Adjust expected output.

	opcodes/
	* arm-dis.c (neon_opcode): Fix suffix on VMOVN.
@
text
@d3656 1
a3656 1
  if (strneq (option, "reg-names-", 10))
d3673 1
a3673 1
  else if (strneq (option, "force-thumb", 11))
d3675 1
a3675 1
  else if (strneq (option, "no-force-thumb", 14))
@


1.69
log
@2006-07-19  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (insns): Fix rbit Arm opcode.
	gas/testsuite/
	* gas/arm/archv6t2.d: Adjust expected output for rbit.
	opcodes/
	* armd-dis.c (arm_opcodes): Fix rbit opcode.
@
text
@d478 1
a478 1
  {FPU_NEON_EXT_V1, 0xf3b20200, 0xffb30fd0, "vmovn%c.i%18-19S2\t%12-15,22D, %0-3,5Q"},
@


1.68
log
@	* arm-dis.c (coprocessor): Alter fmsrr disassembly syntax.
@
text
@d764 1
a764 1
  {ARM_EXT_V6T2, 0x03ff0f30, 0x0fff0ff0, "rbit%c\t%12-15r, %0-3r"},
@


1.67
log
@	* arm-dis.c (print_insn_neon): Disassemble 32-bit immediates as signed
	on 64-bit hosts.
@
text
@d283 1
a283 1
  {FPU_VFP_EXT_V2, 0x0c400a10, 0x0ff00fd0, "fmsrr%c\t%12-15r, %16-19r, %y4"},
@


1.66
log
@2006-06-06  Paul Brook  <paul@@codesourcery.com>

opcodes/
	* arm-dis.c (coprocessor_opcodes): Add %c to unconditional arm
	instructions.
	(neon_opcodes): Add conditional execution specifiers.
	(thumb_opcodes): Ditto.
	(thumb32_opcodes): Ditto.
	(arm_conditional): Change 0xe to "al" and add "" to end.
	(ifthen_state, ifthen_next_state, ifthen_address): New.
	(IFTHEN_COND): Define.
	(print_insn_coprocessor, print_insn_neon): Print thumb conditions.
	(print_insn_arm): Change %c to use new values of arm_conditional.
	(print_insn_thumb16): Print thumb conditions.  Add %I.
	(print_insn_thumb32): Print thumb conditions.
	(find_ifthen_state): New function.
	(print_insn): Track IT block state.
gas/testsuite/
	* gas/arm/thumb2_bcond.d: Update expected output.
	* gas/arm/thumb32.d: Ditto.
	* gas/arm/vfp1_t2.d: Ditto.
	* gas/arm/vfp1xD_t2.d: Ditto.
binutils/testsuite/
	* binutils-all/arm/objdump.exp: New file.
	* binutils-all/arm/thumb2-cond.s: New test.
@
text
@d2420 3
a2422 1
                              func (stream, "#%ld\t; 0x%.8lx", value, value);
@


1.65
log
@	* arm-dis.c (coprocessor_opcodes): Don't interpret fldmx/fstmx as
	vldm/vstm.
@
text
@d65 2
a66 1
   %c			print condition code (always bits 28-31)
d413 2
a414 2
  {ARM_EXT_V6, 0xfc500000, 0xfff00000, "mrrc2\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
  {ARM_EXT_V6, 0xfc400000, 0xfff00000, "mcrr2\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
d417 5
a421 5
  {ARM_EXT_V5, 0xfc100000, 0xfe100000, "ldc2%22'l\t%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V5, 0xfc000000, 0xfe100000, "stc2%22'l\t%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V5, 0xfe000000, 0xff000010, "cdp2\t%8-11d, %20-23d, cr%12-15d, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V5, 0xfe000010, 0xff100010, "mcr2\t%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V5, 0xfe100010, 0xff100010, "mrc2\t%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, {%5-7d}"},
d434 1
d459 2
a460 2
  {FPU_NEON_EXT_V1, 0xf2b00840, 0xffb00850, "vext.8\t%12-15,22R, %16-19,7R, %0-3,5R, #%8-11d"},
  {FPU_NEON_EXT_V1, 0xf2b00000, 0xffb00810, "vext.8\t%12-15,22R, %16-19,7R, %0-3,5R, #%8-11d"},
d463 3
a465 3
  {FPU_NEON_EXT_V1, 0xf3b40c00, 0xffb70f90, "vdup.32\t%12-15,22R, %0-3,5D[%19d]"},
  {FPU_NEON_EXT_V1, 0xf3b20c00, 0xffb30f90, "vdup.16\t%12-15,22R, %0-3,5D[%18-19d]"},
  {FPU_NEON_EXT_V1, 0xf3b10c00, 0xffb10f90, "vdup.8\t%12-15,22R, %0-3,5D[%17-19d]"},
d468 2
a469 2
  {FPU_NEON_EXT_V1, 0xf3b00800, 0xffb00c50, "vtbl.8\t%12-15,22D, %F, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3b00840, 0xffb00c50, "vtbx.8\t%12-15,22D, %F, %0-3,5D"},
d472 33
a504 33
  {FPU_NEON_EXT_V1, 0xf2880a10, 0xfebf0fd0, "vmovl.%24?us8\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2900a10, 0xfebf0fd0, "vmovl.%24?us16\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2a00a10, 0xfebf0fd0, "vmovl.%24?us32\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3b00500, 0xffbf0f90, "vcnt.8\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00580, 0xffbf0f90, "vmvn\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20000, 0xffbf0f90, "vswp\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20200, 0xffb30fd0, "vmovn.i%18-19S2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20240, 0xffb30fd0, "vqmovun.s%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20280, 0xffb30fd0, "vqmovn.s%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b202c0, 0xffb30fd0, "vqmovn.u%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20300, 0xffb30fd0, "vshll.i%18-19S2\t%12-15,22Q, %0-3,5D, #%18-19S2"},
  {FPU_NEON_EXT_V1, 0xf3bb0400, 0xffbf0e90, "vrecpe.%8?fu%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3bb0480, 0xffbf0e90, "vrsqrte.%8?fu%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00000, 0xffb30f90, "vrev64.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00080, 0xffb30f90, "vrev32.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00100, 0xffb30f90, "vrev16.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00400, 0xffb30f90, "vcls.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00480, 0xffb30f90, "vclz.i%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00700, 0xffb30f90, "vqabs.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00780, 0xffb30f90, "vqneg.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20080, 0xffb30f90, "vtrn.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20100, 0xffb30f90, "vuzp.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20180, 0xffb30f90, "vzip.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b10000, 0xffb30b90, "vcgt.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10080, 0xffb30b90, "vcge.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10100, 0xffb30b90, "vceq.%10?fi%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10180, 0xffb30b90, "vcle.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10200, 0xffb30b90, "vclt.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10300, 0xffb30b90, "vabs.%10?fs%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b10380, 0xffb30b90, "vneg.%10?fs%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00200, 0xffb30f10, "vpaddl.%7?us%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00600, 0xffb30f10, "vpadal.%7?us%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b30600, 0xffb30e10, "vcvt.%7-8?usff%18-19Sa.%7-8?ffus%18-19Sa\t%12-15,22R, %0-3,5R"},
d507 53
a559 53
  {FPU_NEON_EXT_V1, 0xf2000110, 0xffb00f10, "vand\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2100110, 0xffb00f10, "vbic\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200110, 0xffb00f10, "vorr\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2300110, 0xffb00f10, "vorn\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000110, 0xffb00f10, "veor\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3100110, 0xffb00f10, "vbsl\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200110, 0xffb00f10, "vbit\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3300110, 0xffb00f10, "vbif\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000d00, 0xffa00f10, "vadd.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000d10, 0xffa00f10, "vmla.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000e00, 0xffa00f10, "vceq.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000f00, 0xffa00f10, "vmax.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000f10, 0xffa00f10, "vrecps.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200d00, 0xffa00f10, "vsub.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200d10, 0xffa00f10, "vmls.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200f00, 0xffa00f10, "vmin.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200f10, 0xffa00f10, "vrsqrts.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000d00, 0xffa00f10, "vpadd.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000d10, 0xffa00f10, "vmul.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000e00, 0xffa00f10, "vcge.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000e10, 0xffa00f10, "vacge.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000f00, 0xffa00f10, "vpmax.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200d00, 0xffa00f10, "vabd.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200e00, 0xffa00f10, "vcgt.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200e10, 0xffa00f10, "vacgt.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200f00, 0xffa00f10, "vpmin.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000800, 0xff800f10, "vadd.i%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000810, 0xff800f10, "vtst.%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000900, 0xff800f10, "vmla.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000b00, 0xff800f10, "vqdmulh.s%20-21S6\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000b10, 0xff800f10, "vpadd.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000800, 0xff800f10, "vsub.i%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000810, 0xff800f10, "vceq.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000900, 0xff800f10, "vmls.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000b00, 0xff800f10, "vqrdmulh.s%20-21S6\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000000, 0xfe800f10, "vhadd.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000010, 0xfe800f10, "vqadd.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000100, 0xfe800f10, "vrhadd.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000200, 0xfe800f10, "vhsub.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000210, 0xfe800f10, "vqsub.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000300, 0xfe800f10, "vcgt.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000310, 0xfe800f10, "vcge.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000400, 0xfe800f10, "vshl.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000410, 0xfe800f10, "vqshl.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000500, 0xfe800f10, "vrshl.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000510, 0xfe800f10, "vqrshl.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000600, 0xfe800f10, "vmax.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000610, 0xfe800f10, "vmin.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000700, 0xfe800f10, "vabd.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000710, 0xfe800f10, "vaba.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000910, 0xfe800f10, "vmul.%24?pi%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000a00, 0xfe800f10, "vpmax.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000a10, 0xfe800f10, "vpmin.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
d562 13
a574 13
  {FPU_NEON_EXT_V1, 0xf2800e10, 0xfeb80fb0, "vmov.i8\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800e30, 0xfeb80fb0, "vmov.i64\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800f10, 0xfeb80fb0, "vmov.f32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800810, 0xfeb80db0, "vmov.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800830, 0xfeb80db0, "vmvn.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800910, 0xfeb80db0, "vorr.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800930, 0xfeb80db0, "vbic.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800c10, 0xfeb80eb0, "vmov.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800c30, 0xfeb80eb0, "vmvn.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800110, 0xfeb809b0, "vorr.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800130, 0xfeb809b0, "vbic.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800010, 0xfeb808b0, "vmov.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800030, 0xfeb808b0, "vmvn.i32\t%12-15,22R, %E"},
d577 58
a634 58
  {FPU_NEON_EXT_V1, 0xf2880810, 0xffb80fd0, "vshrn.i16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880850, 0xffb80fd0, "vrshrn.i16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880810, 0xfeb80fd0, "vqshrun.s16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880850, 0xfeb80fd0, "vqrshrun.s16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880910, 0xfeb80fd0, "vqshrn.%24?us16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880950, 0xfeb80fd0, "vqrshrn.%24?us16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880a10, 0xfeb80fd0, "vshll.%24?us8\t%12-15,22D, %0-3,5Q, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2900810, 0xffb00fd0, "vshrn.i32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900850, 0xffb00fd0, "vrshrn.i32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2880510, 0xffb80f90, "vshl.%24?us8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf3880410, 0xffb80f90, "vsri.8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf3880510, 0xffb80f90, "vsli.8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf3880610, 0xffb80f90, "vqshlu.s8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2900810, 0xfeb00fd0, "vqshrun.s32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900850, 0xfeb00fd0, "vqrshrun.s32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900910, 0xfeb00fd0, "vqshrn.%24?us32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900950, 0xfeb00fd0, "vqrshrn.%24?us32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900a10, 0xfeb00fd0, "vshll.%24?us16\t%12-15,22D, %0-3,5Q, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2880010, 0xfeb80f90, "vshr.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880110, 0xfeb80f90, "vsra.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880210, 0xfeb80f90, "vrshr.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880310, 0xfeb80f90, "vrsra.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880710, 0xfeb80f90, "vqshl.%24?us8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2a00810, 0xffa00fd0, "vshrn.i64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00850, 0xffa00fd0, "vrshrn.i64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2900510, 0xffb00f90, "vshl.%24?us16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf3900410, 0xffb00f90, "vsri.16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf3900510, 0xffb00f90, "vsli.16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf3900610, 0xffb00f90, "vqshlu.s16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2a00a10, 0xfea00fd0, "vshll.%24?us32\t%12-15,22D, %0-3,5Q, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2900010, 0xfeb00f90, "vshr.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900110, 0xfeb00f90, "vsra.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900210, 0xfeb00f90, "vrshr.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900310, 0xfeb00f90, "vrsra.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900710, 0xfeb00f90, "vqshl.%24?us16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2800810, 0xfec00fd0, "vqshrun.s64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800850, 0xfec00fd0, "vqrshrun.s64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800910, 0xfec00fd0, "vqshrn.%24?us64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800950, 0xfec00fd0, "vqrshrn.%24?us64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00510, 0xffa00f90, "vshl.%24?us32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf3a00410, 0xffa00f90, "vsri.32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf3a00510, 0xffa00f90, "vsli.32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf3a00610, 0xffa00f90, "vqshlu.s32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2a00010, 0xfea00f90, "vshr.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00110, 0xfea00f90, "vsra.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00210, 0xfea00f90, "vrshr.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00310, 0xfea00f90, "vrsra.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00710, 0xfea00f90, "vqshl.%24?us32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2800590, 0xff800f90, "vshl.%24?us64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf3800490, 0xff800f90, "vsri.64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf3800590, 0xff800f90, "vsli.64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf3800690, 0xff800f90, "vqshlu.s64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf2800090, 0xfe800f90, "vshr.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800190, 0xfe800f90, "vsra.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800290, 0xfe800f90, "vrshr.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800390, 0xfe800f90, "vrsra.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800790, 0xfe800f90, "vqshl.%24?us64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf2a00e10, 0xfea00e90, "vcvt.%24,8?usff32.%24,8?ffus32\t%12-15,22R, %0-3,5R, #%16-20e"},
d637 17
a653 17
  {FPU_NEON_EXT_V1, 0xf2800e00, 0xfea00f50, "vmull.p%20S0\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800400, 0xff800f50, "vaddhn.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800600, 0xff800f50, "vsubhn.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800900, 0xff800f50, "vqdmlal.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800b00, 0xff800f50, "vqdmlsl.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800d00, 0xff800f50, "vqdmull.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3800400, 0xff800f50, "vraddhn.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3800600, 0xff800f50, "vrsubhn.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800000, 0xfe800f50, "vaddl.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800100, 0xfe800f50, "vaddw.%24?us%20-21S2\t%12-15,22Q, %16-19,7Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800200, 0xfe800f50, "vsubl.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800300, 0xfe800f50, "vsubw.%24?us%20-21S2\t%12-15,22Q, %16-19,7Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800500, 0xfe800f50, "vabal.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800700, 0xfe800f50, "vabdl.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800800, 0xfe800f50, "vmlal.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800a00, 0xfe800f50, "vmlsl.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800c00, 0xfe800f50, "vmull.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
d656 22
a677 22
  {FPU_NEON_EXT_V1, 0xf2800040, 0xff800f50, "vmla.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800140, 0xff800f50, "vmla.f%20-21Sa\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800340, 0xff800f50, "vqdmlal.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800440, 0xff800f50, "vmls.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800540, 0xff800f50, "vmls.f%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800740, 0xff800f50, "vqdmlsl.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800840, 0xff800f50, "vmul.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800940, 0xff800f50, "vmul.f%20-21Sa\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800b40, 0xff800f50, "vqdmull.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800c40, 0xff800f50, "vqdmulh.s%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800d40, 0xff800f50, "vqrdmulh.s%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf3800040, 0xff800f50, "vmla.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800140, 0xff800f50, "vmla.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800440, 0xff800f50, "vmls.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800540, 0xff800f50, "vmls.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800840, 0xff800f50, "vmul.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800940, 0xff800f50, "vmul.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800c40, 0xff800f50, "vqdmulh.s%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800d40, 0xff800f50, "vqrdmulh.s%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf2800240, 0xfe800f50, "vmlal.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800640, 0xfe800f50, "vmlsl.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800a40, 0xfe800f50, "vmull.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
d680 19
a698 19
  {FPU_NEON_EXT_V1, 0xf4a00fc0, 0xffb00fc0, "vld4.32\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00c00, 0xffb00f00, "vld1.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00d00, 0xffb00f00, "vld2.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00e00, 0xffb00f00, "vld3.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00f00, 0xffb00f00, "vld4.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4000200, 0xff900f00, "v%21?ls%21?dt1.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000300, 0xff900f00, "v%21?ls%21?dt2.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000400, 0xff900f00, "v%21?ls%21?dt3.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000500, 0xff900f00, "v%21?ls%21?dt3.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000600, 0xff900f00, "v%21?ls%21?dt1.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000700, 0xff900f00, "v%21?ls%21?dt1.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000800, 0xff900f00, "v%21?ls%21?dt2.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000900, 0xff900f00, "v%21?ls%21?dt2.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000a00, 0xff900f00, "v%21?ls%21?dt1.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000000, 0xff900e00, "v%21?ls%21?dt4.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4800000, 0xff900300, "v%21?ls%21?dt1.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800100, 0xff900300, "v%21?ls%21?dt2.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800200, 0xff900300, "v%21?ls%21?dt3.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800300, 0xff900300, "v%21?ls%21?dt4.%10-11S2\t%B"},
d996 5
d1016 6
a1021 6
  {ARM_EXT_V6K, 0xbf00, 0xffff, "nop"},
  {ARM_EXT_V6K, 0xbf10, 0xffff, "yield"},
  {ARM_EXT_V6K, 0xbf20, 0xffff, "wfe"},
  {ARM_EXT_V6K, 0xbf30, 0xffff, "wfi"},
  {ARM_EXT_V6K, 0xbf40, 0xffff, "sev"},
  {ARM_EXT_V6K, 0xbf00, 0xff0f, "nop\t{%4-7d}"},
d1024 3
a1026 9
  {ARM_EXT_V6T2, 0xb900, 0xfd00, "cbnz\t%0-2r, %b"},
  {ARM_EXT_V6T2, 0xb100, 0xfd00, "cbz\t%0-2r, %b"},
  {ARM_EXT_V6T2, 0xbf08, 0xff0f, "it\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf14, 0xff17, "it%3?te\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf04, 0xff17, "it%3?et\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf12, 0xff13, "it%3?te%2?te\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf02, 0xff13, "it%3?et%2?et\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf11, 0xff11, "it%3?te%2?te%1?te\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf01, 0xff11, "it%3?et%2?et%1?et\t%4-7c"},
d1029 11
a1039 11
  {ARM_EXT_V6, 0xb660, 0xfff8, "cpsie\t%2'a%1'i%0'f"},
  {ARM_EXT_V6, 0xb670, 0xfff8, "cpsid\t%2'a%1'i%0'f"},
  {ARM_EXT_V6, 0x4600, 0xffc0, "mov\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xba00, 0xffc0, "rev\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xba40, 0xffc0, "rev16\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xbac0, 0xffc0, "revsh\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb650, 0xfff7, "setend\t%3?ble"},
  {ARM_EXT_V6, 0xb200, 0xffc0, "sxth\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb240, 0xffc0, "sxtb\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb280, 0xffc0, "uxth\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb2c0, 0xffc0, "uxtb\t%0-2r, %3-5r"},
d1042 1
a1042 1
  {ARM_EXT_V5T, 0xbe00, 0xff00, "bkpt\t%0-7x"},
d1044 1
a1044 1
  {ARM_EXT_V5T, 0x4780, 0xff87, "blx\t%3-6r"},	/* note: 4 bit register number.  */
d1046 1
a1046 1
  {ARM_EXT_V4T, 0x46C0, 0xFFFF, "nop\t\t\t(mov r8, r8)"},
d1048 16
a1063 16
  {ARM_EXT_V4T, 0x4000, 0xFFC0, "ands\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4040, 0xFFC0, "eors\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4080, 0xFFC0, "lsls\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x40C0, 0xFFC0, "lsrs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4100, 0xFFC0, "asrs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4140, 0xFFC0, "adcs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4180, 0xFFC0, "sbcs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x41C0, 0xFFC0, "rors\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4200, 0xFFC0, "tst\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4240, 0xFFC0, "negs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4280, 0xFFC0, "cmp\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x42C0, 0xFFC0, "cmn\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4300, 0xFFC0, "orrs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4340, 0xFFC0, "muls\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4380, 0xFFC0, "bics\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x43C0, 0xFFC0, "mvns\t%0-2r, %3-5r"},
d1065 2
a1066 2
  {ARM_EXT_V4T, 0xB000, 0xFF80, "add\tsp, #%0-6W"},
  {ARM_EXT_V4T, 0xB080, 0xFF80, "sub\tsp, #%0-6W"},
d1068 4
a1071 4
  {ARM_EXT_V4T, 0x4700, 0xFF80, "bx\t%S"},
  {ARM_EXT_V4T, 0x4400, 0xFF00, "add\t%D, %S"},
  {ARM_EXT_V4T, 0x4500, 0xFF00, "cmp\t%D, %S"},
  {ARM_EXT_V4T, 0x4600, 0xFF00, "mov\t%D, %S"},
d1073 2
a1074 2
  {ARM_EXT_V4T, 0xB400, 0xFE00, "push\t%N"},
  {ARM_EXT_V4T, 0xBC00, 0xFE00, "pop\t%O"},
d1076 4
a1079 4
  {ARM_EXT_V4T, 0x1800, 0xFE00, "adds\t%0-2r, %3-5r, %6-8r"},
  {ARM_EXT_V4T, 0x1A00, 0xFE00, "subs\t%0-2r, %3-5r, %6-8r"},
  {ARM_EXT_V4T, 0x1C00, 0xFE00, "adds\t%0-2r, %3-5r, #%6-8d"},
  {ARM_EXT_V4T, 0x1E00, 0xFE00, "subs\t%0-2r, %3-5r, #%6-8d"},
d1081 3
a1083 3
  {ARM_EXT_V4T, 0x5200, 0xFE00, "strh\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5A00, 0xFE00, "ldrh\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5600, 0xF600, "ldrs%11?hb\t%0-2r, [%3-5r, %6-8r]"},
d1085 2
a1086 2
  {ARM_EXT_V4T, 0x5000, 0xFA00, "str%10'b\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5800, 0xFA00, "ldr%10'b\t%0-2r, [%3-5r, %6-8r]"},
d1088 3
a1090 3
  {ARM_EXT_V4T, 0x0000, 0xF800, "lsls\t%0-2r, %3-5r, #%6-10d"},
  {ARM_EXT_V4T, 0x0800, 0xF800, "lsrs\t%0-2r, %3-5r, %s"},
  {ARM_EXT_V4T, 0x1000, 0xF800, "asrs\t%0-2r, %3-5r, %s"},
d1092 4
a1095 4
  {ARM_EXT_V4T, 0x2000, 0xF800, "movs\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x2800, 0xF800, "cmp\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x3000, 0xF800, "adds\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x3800, 0xF800, "subs\t%8-10r, #%0-7d"},
d1097 1
a1097 1
  {ARM_EXT_V4T, 0x4800, 0xF800, "ldr\t%8-10r, [pc, #%0-7W]\t(%0-7a)"},  /* TODO: Disassemble PC relative "LDR rD,=<symbolic>" */
d1099 4
a1102 4
  {ARM_EXT_V4T, 0x6000, 0xF800, "str\t%0-2r, [%3-5r, #%6-10W]"},
  {ARM_EXT_V4T, 0x6800, 0xF800, "ldr\t%0-2r, [%3-5r, #%6-10W]"},
  {ARM_EXT_V4T, 0x7000, 0xF800, "strb\t%0-2r, [%3-5r, #%6-10d]"},
  {ARM_EXT_V4T, 0x7800, 0xF800, "ldrb\t%0-2r, [%3-5r, #%6-10d]"},
d1104 2
a1105 2
  {ARM_EXT_V4T, 0x8000, 0xF800, "strh\t%0-2r, [%3-5r, #%6-10H]"},
  {ARM_EXT_V4T, 0x8800, 0xF800, "ldrh\t%0-2r, [%3-5r, #%6-10H]"},
d1107 2
a1108 2
  {ARM_EXT_V4T, 0x9000, 0xF800, "str\t%8-10r, [sp, #%0-7W]"},
  {ARM_EXT_V4T, 0x9800, 0xF800, "ldr\t%8-10r, [sp, #%0-7W]"},
d1110 2
a1111 2
  {ARM_EXT_V4T, 0xA000, 0xF800, "add\t%8-10r, pc, #%0-7W\t(adr %8-10r,%0-7a)"},
  {ARM_EXT_V4T, 0xA800, 0xF800, "add\t%8-10r, sp, #%0-7W"},
d1113 2
a1114 2
  {ARM_EXT_V4T, 0xC000, 0xF800, "stmia\t%8-10r!, %M"},
  {ARM_EXT_V4T, 0xC800, 0xF800, "ldmia\t%8-10r!, %M"},
d1116 1
a1116 1
  {ARM_EXT_V4T, 0xDF00, 0xFF00, "svc\t%0-7d"},
d1118 1
a1118 1
  {ARM_EXT_V4T, 0xD000, 0xF000, "b%8-11c.n\t%0-7B"},
d1120 1
a1120 1
  {ARM_EXT_V4T, 0xE000, 0xF800, "b.n\t%0-10B"},
d1156 3
d1180 7
a1186 7
  {ARM_EXT_V7, 0xf910f000, 0xff70f000, "pli\t%a"},
  {ARM_EXT_V7, 0xf3af80f0, 0xfffffff0, "dbg\t#%0-3d"},
  {ARM_EXT_V7, 0xf3bf8f50, 0xfffffff0, "dmb\t%U"},
  {ARM_EXT_V7, 0xf3bf8f40, 0xfffffff0, "dsb\t%U"},
  {ARM_EXT_V7, 0xf3bf8f60, 0xfffffff0, "isb\t%U"},
  {ARM_EXT_DIV, 0xfb90f0f0, 0xfff0f0f0, "sdiv\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_DIV, 0xfbb0f0f0, 0xfff0f0f0, "udiv\t%8-11r, %16-19r, %0-3r"},
d1189 177
a1365 177
  {ARM_EXT_V6T2, 0xf3af8000, 0xffffffff, "nop.w"},
  {ARM_EXT_V6T2, 0xf3af8001, 0xffffffff, "yield.w"},
  {ARM_EXT_V6T2, 0xf3af8002, 0xffffffff, "wfe.w"},
  {ARM_EXT_V6T2, 0xf3af8003, 0xffffffff, "wfi.w"},
  {ARM_EXT_V6T2, 0xf3af9004, 0xffffffff, "sev.w"},
  {ARM_EXT_V6T2, 0xf3af8000, 0xffffff00, "nop.w\t{%0-7d}"},

  {ARM_EXT_V6T2, 0xf3bf8f2f, 0xffffffff, "clrex"},
  {ARM_EXT_V6T2, 0xf3af8400, 0xffffff1f, "cpsie.w\t%7'a%6'i%5'f"},
  {ARM_EXT_V6T2, 0xf3af8600, 0xffffff1f, "cpsid.w\t%7'a%6'i%5'f"},
  {ARM_EXT_V6T2, 0xf3c08f00, 0xfff0ffff, "bxj\t%16-19r"},
  {ARM_EXT_V6T2, 0xe810c000, 0xffd0ffff, "rfedb\t%16-19r%21'!"},
  {ARM_EXT_V6T2, 0xe990c000, 0xffd0ffff, "rfeia\t%16-19r%21'!"},
  {ARM_EXT_V6T2, 0xf3ef8000, 0xffeff000, "mrs\t%8-11r, %D"},
  {ARM_EXT_V6T2, 0xf3af8100, 0xffffffe0, "cps\t#%0-4d"},
  {ARM_EXT_V6T2, 0xe8d0f000, 0xfff0fff0, "tbb\t[%16-19r, %0-3r]"},
  {ARM_EXT_V6T2, 0xe8d0f010, 0xfff0fff0, "tbh\t[%16-19r, %0-3r, lsl #1]"},
  {ARM_EXT_V6T2, 0xf3af8500, 0xffffff00, "cpsie\t%7'a%6'i%5'f, #%0-4d"},
  {ARM_EXT_V6T2, 0xf3af8700, 0xffffff00, "cpsid\t%7'a%6'i%5'f, #%0-4d"},
  {ARM_EXT_V6T2, 0xf3de8f00, 0xffffff00, "subs\tpc, lr, #%0-7d"},
  {ARM_EXT_V6T2, 0xf3808000, 0xffe0f000, "msr\t%C, %16-19r"},
  {ARM_EXT_V6T2, 0xe8500f00, 0xfff00fff, "ldrex\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe8d00f4f, 0xfff00fef, "ldrex%4?hb\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe800c000, 0xffd0ffe0, "srsdb\t#%0-4d%21'!"},
  {ARM_EXT_V6T2, 0xe980c000, 0xffd0ffe0, "srsia\t#%0-4d%21'!"},
  {ARM_EXT_V6T2, 0xfa0ff080, 0xfffff0c0, "sxth.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa1ff080, 0xfffff0c0, "uxth.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa2ff080, 0xfffff0c0, "sxtb16\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa3ff080, 0xfffff0c0, "uxtb16\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa4ff080, 0xfffff0c0, "sxtb.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa5ff080, 0xfffff0c0, "uxtb.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xe8400000, 0xfff000ff, "strex\t%8-11r, %12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe8d0007f, 0xfff000ff, "ldrexd\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xfa80f000, 0xfff0f0f0, "sadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f010, 0xfff0f0f0, "qadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f020, 0xfff0f0f0, "shadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f040, 0xfff0f0f0, "uadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f050, 0xfff0f0f0, "uqadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f060, 0xfff0f0f0, "uhadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f080, 0xfff0f0f0, "qadd\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f090, 0xfff0f0f0, "qdadd\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0a0, 0xfff0f0f0, "qsub\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0b0, 0xfff0f0f0, "qdsub\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f000, 0xfff0f0f0, "sadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f010, 0xfff0f0f0, "qadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f020, 0xfff0f0f0, "shadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f040, 0xfff0f0f0, "uadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f050, 0xfff0f0f0, "uqadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f060, 0xfff0f0f0, "uhadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f080, 0xfff0f0f0, "rev.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f090, 0xfff0f0f0, "rev16.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f0a0, 0xfff0f0f0, "rbit\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f0b0, 0xfff0f0f0, "revsh.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfaa0f000, 0xfff0f0f0, "saddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f010, 0xfff0f0f0, "qaddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f020, 0xfff0f0f0, "shaddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f040, 0xfff0f0f0, "uaddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f050, 0xfff0f0f0, "uqaddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f060, 0xfff0f0f0, "uhaddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f080, 0xfff0f0f0, "sel\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfab0f080, 0xfff0f0f0, "clz\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfac0f000, 0xfff0f0f0, "ssub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f010, 0xfff0f0f0, "qsub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f020, 0xfff0f0f0, "shsub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f040, 0xfff0f0f0, "usub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f050, 0xfff0f0f0, "uqsub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f060, 0xfff0f0f0, "uhsub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f000, 0xfff0f0f0, "ssub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f010, 0xfff0f0f0, "qsub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f020, 0xfff0f0f0, "shsub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f040, 0xfff0f0f0, "usub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f050, 0xfff0f0f0, "uqsub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f060, 0xfff0f0f0, "uhsub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f000, 0xfff0f0f0, "ssubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f010, 0xfff0f0f0, "qsubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f020, 0xfff0f0f0, "shsubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f040, 0xfff0f0f0, "usubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f050, 0xfff0f0f0, "uqsubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f060, 0xfff0f0f0, "uhsubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb00f000, 0xfff0f0f0, "mul.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb70f000, 0xfff0f0f0, "usad8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa00f000, 0xffe0f0f0, "lsl%20's.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa20f000, 0xffe0f0f0, "lsr%20's.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa40f000, 0xffe0f0f0, "asr%20's.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa60f000, 0xffe0f0f0, "ror%20's.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xe8c00f40, 0xfff00fe0, "strex%4?hb\t%0-3r, %12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xf3200000, 0xfff0f0e0, "ssat16\t%8-11r, #%0-4d, %16-19r"},
  {ARM_EXT_V6T2, 0xf3a00000, 0xfff0f0e0, "usat16\t%8-11r, #%0-4d, %16-19r"},
  {ARM_EXT_V6T2, 0xfb20f000, 0xfff0f0e0, "smuad%4'x\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb30f000, 0xfff0f0e0, "smulw%4?tb\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb40f000, 0xfff0f0e0, "smusd%4'x\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb50f000, 0xfff0f0e0, "smmul%4'r\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa00f080, 0xfff0f0c0, "sxtah\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa10f080, 0xfff0f0c0, "uxtah\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa20f080, 0xfff0f0c0, "sxtab16\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa30f080, 0xfff0f0c0, "uxtab16\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa40f080, 0xfff0f0c0, "sxtab\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa50f080, 0xfff0f0c0, "uxtab\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfb10f000, 0xfff0f0c0, "smul%5?tb%4?tb\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xf36f0000, 0xffff8020, "bfc\t%8-11r, %E"},
  {ARM_EXT_V6T2, 0xea100f00, 0xfff08f00, "tst.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xea900f00, 0xfff08f00, "teq\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb100f00, 0xfff08f00, "cmn.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xebb00f00, 0xfff08f00, "cmp.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xf0100f00, 0xfbf08f00, "tst.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0900f00, 0xfbf08f00, "teq\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1100f00, 0xfbf08f00, "cmn.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1b00f00, 0xfbf08f00, "cmp.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xea4f0000, 0xffef8000, "mov%20's.w\t%8-11r, %S"},
  {ARM_EXT_V6T2, 0xea6f0000, 0xffef8000, "mvn%20's.w\t%8-11r, %S"},
  {ARM_EXT_V6T2, 0xe8c00070, 0xfff000f0, "strexd\t%0-3r, %12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xfb000000, 0xfff000f0, "mla\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb000010, 0xfff000f0, "mls\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb700000, 0xfff000f0, "usada8\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb800000, 0xfff000f0, "smull\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfba00000, 0xfff000f0, "umull\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbc00000, 0xfff000f0, "smlal\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbe00000, 0xfff000f0, "umlal\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbe00060, 0xfff000f0, "umaal\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xe8500f00, 0xfff00f00, "ldrex\t%12-15r, [%16-19r, #%0-7W]"},
  {ARM_EXT_V6T2, 0xf7f08000, 0xfff0f000, "smc\t%K"},
  {ARM_EXT_V6T2, 0xf04f0000, 0xfbef8000, "mov%20's.w\t%8-11r, %M"},
  {ARM_EXT_V6T2, 0xf06f0000, 0xfbef8000, "mvn%20's.w\t%8-11r, %M"},
  {ARM_EXT_V6T2, 0xf810f000, 0xff70f000, "pld\t%a"},
  {ARM_EXT_V6T2, 0xfb200000, 0xfff000e0, "smlad%4'x\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb300000, 0xfff000e0, "smlaw%4?tb\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb400000, 0xfff000e0, "smlsd%4'x\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb500000, 0xfff000e0, "smmla%4'r\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb600000, 0xfff000e0, "smmls%4'r\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfbc000c0, 0xfff000e0, "smlald%4'x\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbd000c0, 0xfff000e0, "smlsld%4'x\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xeac00000, 0xfff08030, "pkhbt\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeac00020, 0xfff08030, "pkhtb\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xf3400000, 0xfff08020, "sbfx\t%8-11r, %16-19r, %F"},
  {ARM_EXT_V6T2, 0xf3c00000, 0xfff08020, "ubfx\t%8-11r, %16-19r, %F"},
  {ARM_EXT_V6T2, 0xf8000e00, 0xff900f00, "str%wt\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xfb100000, 0xfff000c0, "smla%5?tb%4?tb\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfbc00080, 0xfff000c0, "smlal%5?tb%4?tb\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xf3600000, 0xfff08020, "bfi\t%8-11r, %16-19r, %E"},
  {ARM_EXT_V6T2, 0xf8100e00, 0xfe900f00, "ldr%wt\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf3000000, 0xffd08020, "ssat\t%8-11r, #%0-4d, %16-19r%s"},
  {ARM_EXT_V6T2, 0xf3800000, 0xffd08020, "usat\t%8-11r, #%0-4d, %16-19r%s"},
  {ARM_EXT_V6T2, 0xf2000000, 0xfbf08000, "addw\t%8-11r, %16-19r, %I"},
  {ARM_EXT_V6T2, 0xf2400000, 0xfbf08000, "movw\t%8-11r, %J"},
  {ARM_EXT_V6T2, 0xf2a00000, 0xfbf08000, "subw\t%8-11r, %16-19r, %I"},
  {ARM_EXT_V6T2, 0xf2c00000, 0xfbf08000, "movt\t%8-11r, %J"},
  {ARM_EXT_V6T2, 0xea000000, 0xffe08000, "and%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea200000, 0xffe08000, "bic%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea400000, 0xffe08000, "orr%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea600000, 0xffe08000, "orn%20's\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea800000, 0xffe08000, "eor%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb000000, 0xffe08000, "add%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb400000, 0xffe08000, "adc%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb600000, 0xffe08000, "sbc%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeba00000, 0xffe08000, "sub%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xebc00000, 0xffe08000, "rsb%20's\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xe8400000, 0xfff00000, "strex\t%8-11r, %12-15r, [%16-19r, #%0-7W]"},
  {ARM_EXT_V6T2, 0xf0000000, 0xfbe08000, "and%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0200000, 0xfbe08000, "bic%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0400000, 0xfbe08000, "orr%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0600000, 0xfbe08000, "orn%20's\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0800000, 0xfbe08000, "eor%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1000000, 0xfbe08000, "add%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1400000, 0xfbe08000, "adc%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1600000, 0xfbe08000, "sbc%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1a00000, 0xfbe08000, "sub%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1c00000, 0xfbe08000, "rsb%20's\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xe8800000, 0xffd00000, "stmia.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe8900000, 0xffd00000, "ldmia.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9000000, 0xffd00000, "stmdb\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9100000, 0xffd00000, "ldmdb\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9c00000, 0xffd000ff, "strd\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9d00000, 0xffd000ff, "ldrd\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9400000, 0xff500000, "strd\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]"},
  {ARM_EXT_V6T2, 0xe9500000, 0xff500000, "ldrd\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]"},
  {ARM_EXT_V6T2, 0xf8000000, 0xff100000, "str%w.w\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf8100000, 0xfe100000, "ldr%w.w\t%12-15r, %a"},
d1370 2
a1371 2
  {ARM_EXT_V6T2, 0xf0008000, 0xf800d000, "b%22-25c.w\t%b"},
  {ARM_EXT_V6T2, 0xf0009000, 0xf800d000, "b.w\t%B"},
d1374 2
a1375 2
  {ARM_EXT_V4T,  0xf000c000, 0xf800d000, "blx\t%B"},
  {ARM_EXT_V4T,  0xf000d000, 0xf800d000, "bl\t%B"},
d1384 1
a1384 1
 "hi", "ls", "ge", "lt", "gt", "le", "", "<und>"};
d1444 9
d1560 1
d1578 4
d1588 10
a1597 1
	    mask |= 0xf0000000;
d1685 1
a1685 1
      
d1687 1
a1687 2
		      func (stream, "%s",
			    arm_conditional [(given >> 28) & 0xf]);
d2130 5
d2667 3
a2669 2
		      func (stream, "%s",
			    arm_conditional [(given >> 28) & 0xf]);
d2927 34
d3109 1
a3109 8
			    {
			      /* Must print 0xE as 'al' to distinguish
				 unconditional B from conditional BAL.  */
			      if (reg == 0xE)
				func (stream, "al");
			      else
				func (stream, "%s", arm_conditional [reg]);
			    }
d3206 16
d3592 1
a3592 4
		      if (val == 0xE)
			func (stream, "al");
		      else
			func (stream, "%s", arm_conditional[val]);
d3704 78
d3881 12
d3909 6
@


1.64
log
@	* arm-dis.c (print_insn_neon): Disassemble floating-point constant
	VMOV.
@
text
@d212 4
a217 4
  {FPU_NEON_EXT_V1, 0x0c800b00, 0x0f900f00, "vstmia%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0c900b00, 0x0f900f00, "vldmia%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0d000b00, 0x0f900f00, "vstmdb%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0d100b00, 0x0f900f00, "vldmdb%c\t%16-19r%21'!, %B"},
@


1.63
log
@	* opcodes/arm-dis.c (coprocessor_opcodes): Add %A, %B, %k, convert
	%<code>[zy] into %[zy]<code>.  Expand meaning of %<bitfield>['`?].
	Add unified load/store instruction names.
	(neon_opcode_table): New.
	(arm_opcodes): Expand meaning of %<bitfield>['`?].
	(arm_decode_bitfield): New.
	(print_insn_coprocessor): Add pc argument. Add %A & %B specifiers.
	Use arm_decode_bitfield and adjust numeric specifiers. Adjust %z & %y.
	(print_insn_neon): New.
	(print_insn_arm): Adjust print_insn_coprocessor call. Call
	print_insn_neon. Use arm_decode_bitfield and adjust numeric specifiers.
	(print_insn_thumb32): Likewise.
@
text
@d29 1
d2287 1
d2344 1
a2344 1
			    value = (unsigned long)(bits & 0x7f) << (24 - 6);
d2349 1
d2369 21
a2389 1
                            func (stream, "#%ld\t; 0x%.8lx", value, value);
@


1.62
log
@2006-03-16  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (insns): Add "svc".
gas/testsuite/
	* gas/arm/svc.d: New test.
	* gas/arm/svc.s: New test.
	* gas/arm/inst.d: Accept svc mnemonic.
	* gas/arm/thumb.d: Ditto.
	* gas/arm/wince_inst.d: Ditto.
opcodes/
	* arm-dis.c (arm_opcodes): Rename swi to svc.
	(thumb_opcodes): Ditto.
@
text
@d66 2
d76 1
d84 2
d87 1
a87 1
   %<code>y		print a single precision VFP reg.
d89 1
a89 1
   %<code>z		print a double precision VFP reg
a90 3
   %<bitnum>'c		print specified char iff bit is one
   %<bitnum>`c		print specified char iff bit is zero
   %<bitnum>?ab		print a if bit is one else print b
d92 4
d210 24
a234 30
  {FPU_VFP_EXT_V1, 0x0eb00bc0, 0x0fff0ff0, "fabsd%c\t%1z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0eb00ac0, 0x0fbf0fd0, "fabss%c\t%1y, %0y"},
  {FPU_VFP_EXT_V1, 0x0e300b00, 0x0ff00ff0, "faddd%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e300a00, 0x0fb00f50, "fadds%c\t%1y, %2y, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb40b40, 0x0fff0f70, "fcmp%7'ed%c\t%1z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0eb40a40, 0x0fbf0f50, "fcmp%7'es%c\t%1y, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb50b40, 0x0fff0f70, "fcmp%7'ezd%c\t%1z"},
  {FPU_VFP_EXT_V1xD, 0x0eb50a40, 0x0fbf0f70, "fcmp%7'ezs%c\t%1y"},
  {FPU_VFP_EXT_V1, 0x0eb00b40, 0x0fff0ff0, "fcpyd%c\t%1z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0eb00a40, 0x0fbf0fd0, "fcpys%c\t%1y, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb70ac0, 0x0fff0fd0, "fcvtds%c\t%1z, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb70bc0, 0x0fbf0ff0, "fcvtsd%c\t%1y, %0z"},
  {FPU_VFP_EXT_V1, 0x0e800b00, 0x0ff00ff0, "fdivd%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e800a00, 0x0fb00f50, "fdivs%c\t%1y, %2y, %0y"},
  {FPU_VFP_EXT_V1, 0x0d100b00, 0x0f700f00, "fldd%c\t%1z, %A"},
  {FPU_VFP_EXT_V1xD, 0x0c900b00, 0x0fd00f00, "fldmia%0?xd%c\t%16-19r%21'!, %3z"},
  {FPU_VFP_EXT_V1xD, 0x0d300b00, 0x0ff00f00, "fldmdb%0?xd%c\t%16-19r!, %3z"},
  {FPU_VFP_EXT_V1xD, 0x0d100a00, 0x0f300f00, "flds%c\t%1y, %A"},
  {FPU_VFP_EXT_V1xD, 0x0c900a00, 0x0f900f00, "fldmias%c\t%16-19r%21'!, %3y"},
  {FPU_VFP_EXT_V1xD, 0x0d300a00, 0x0fb00f00, "fldmdbs%c\t%16-19r!, %3y"},
  {FPU_VFP_EXT_V1, 0x0e000b00, 0x0ff00ff0, "fmacd%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e000a00, 0x0fb00f50, "fmacs%c\t%1y, %2y, %0y"},
  {FPU_VFP_EXT_V1, 0x0e200b10, 0x0ff00fff, "fmdhr%c\t%2z, %12-15r"},
  {FPU_VFP_EXT_V1, 0x0e000b10, 0x0ff00fff, "fmdlr%c\t%2z, %12-15r"},
  {FPU_VFP_EXT_V2, 0x0c400b10, 0x0ff00ff0, "fmdrr%c\t%0z, %12-15r, %16-19r"},
  {FPU_VFP_EXT_V1, 0x0e300b10, 0x0ff00fff, "fmrdh%c\t%12-15r, %2z"},
  {FPU_VFP_EXT_V1, 0x0e100b10, 0x0ff00fff, "fmrdl%c\t%12-15r, %2z"},
  {FPU_VFP_EXT_V1, 0x0c500b10, 0x0ff00ff0, "fmrrd%c\t%12-15r, %16-19r, %0z"},
  {FPU_VFP_EXT_V2, 0x0c500a10, 0x0ff00fd0, "fmrrs%c\t%12-15r, %16-19r, %4y"},
  {FPU_VFP_EXT_V1xD, 0x0e100a10, 0x0ff00f7f, "fmrs%c\t%12-15r, %2y"},
d236 5
d246 5
d252 62
a313 36
  {FPU_VFP_EXT_V1, 0x0e100b00, 0x0ff00ff0, "fmscd%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e100a00, 0x0fb00f50, "fmscs%c\t%1y, %2y, %0y"},
  {FPU_VFP_EXT_V1xD, 0x0e000a10, 0x0ff00f7f, "fmsr%c\t%2y, %12-15r"},
  {FPU_VFP_EXT_V2, 0x0c400a10, 0x0ff00fd0, "fmsrr%c\t%12-15r, %16-19r, %4y"},
  {FPU_VFP_EXT_V1, 0x0e200b00, 0x0ff00ff0, "fmuld%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e200a00, 0x0fb00f50, "fmuls%c\t%1y, %2y, %0y"},
  {FPU_VFP_EXT_V1xD, 0x0ee00a10, 0x0fff0fff, "fmxr%c\tfpsid, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee10a10, 0x0fff0fff, "fmxr%c\tfpscr, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee80a10, 0x0fff0fff, "fmxr%c\tfpexc, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0ee90a10, 0x0fff0fff, "fmxr%c\tfpinst, %12-15r\t@@ Impl def"},
  {FPU_VFP_EXT_V1xD, 0x0eea0a10, 0x0fff0fff, "fmxr%c\tfpinst2, %12-15r\t@@ Impl def"},
  {FPU_VFP_EXT_V1xD, 0x0ee00a10, 0x0ff00fff, "fmxr%c\t<impl def 0x%16-19x>, %12-15r"},
  {FPU_VFP_EXT_V1, 0x0eb10b40, 0x0fff0ff0, "fnegd%c\t%1z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0eb10a40, 0x0fbf0fd0, "fnegs%c\t%1y, %0y"},
  {FPU_VFP_EXT_V1, 0x0e000b40, 0x0ff00ff0, "fnmacd%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e000a40, 0x0fb00f50, "fnmacs%c\t%1y, %2y, %0y"},
  {FPU_VFP_EXT_V1, 0x0e100b40, 0x0ff00ff0, "fnmscd%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e100a40, 0x0fb00f50, "fnmscs%c\t%1y, %2y, %0y"},
  {FPU_VFP_EXT_V1, 0x0e200b40, 0x0ff00ff0, "fnmuld%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e200a40, 0x0fb00f50, "fnmuls%c\t%1y, %2y, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb80bc0, 0x0fff0fd0, "fsitod%c\t%1z, %0y"},
  {FPU_VFP_EXT_V1xD, 0x0eb80ac0, 0x0fbf0fd0, "fsitos%c\t%1y, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb10bc0, 0x0fff0ff0, "fsqrtd%c\t%1z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0eb10ac0, 0x0fbf0fd0, "fsqrts%c\t%1y, %0y"},
  {FPU_VFP_EXT_V1, 0x0d000b00, 0x0f700f00, "fstd%c\t%1z, %A"},
  {FPU_VFP_EXT_V1xD, 0x0c800b00, 0x0fd00f00, "fstmia%0?xd%c\t%16-19r%21'!, %3z"},
  {FPU_VFP_EXT_V1xD, 0x0d200b00, 0x0ff00f00, "fstmdb%0?xd%c\t%16-19r!, %3z"},
  {FPU_VFP_EXT_V1xD, 0x0d000a00, 0x0f300f00, "fsts%c\t%1y, %A"},
  {FPU_VFP_EXT_V1xD, 0x0c800a00, 0x0f900f00, "fstmias%c\t%16-19r%21'!, %3y"},
  {FPU_VFP_EXT_V1xD, 0x0d200a00, 0x0fb00f00, "fstmdbs%c\t%16-19r!, %3y"},
  {FPU_VFP_EXT_V1, 0x0e300b40, 0x0ff00ff0, "fsubd%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e300a40, 0x0fb00f50, "fsubs%c\t%1y, %2y, %0y"},
  {FPU_VFP_EXT_V1, 0x0ebc0b40, 0x0fbe0f70, "fto%16?sui%7'zd%c\t%1y, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0ebc0a40, 0x0fbe0f50, "fto%16?sui%7'zs%c\t%1y, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb80b40, 0x0fff0fd0, "fuitod%c\t%1z, %0y"},
  {FPU_VFP_EXT_V1xD, 0x0eb80a40, 0x0fbf0fd0, "fuitos%c\t%1y, %0y"},
d420 1
d424 276
d726 4
a729 4

   %<bitnum>'c		print specified char iff bit is one
   %<bitnum>`c		print specified char iff bit is zero
   %<bitnum>?ab		print a if bit is one else print b
d1160 3
a1162 3
       %<bitnum>'c	print "c" iff bit is one
       %<bitnum>`c	print "c" iff bit is zero
       %<bitnum>?ab	print "a" if bit is one, else "b"
d1465 37
d1538 1
a1538 1
print_insn_coprocessor (struct disassemble_info *info, long given,
d1618 40
d1753 4
a1756 4
			int bitstart = *c++ - '0';
			int bitend = 0;
			while (*c >= '0' && *c <= '9')
			  bitstart = (bitstart * 10) + *c++ - '0';
d1760 28
a1787 2
			  case '-':
			    c++;
d1789 6
a1794 2
			    while (*c >= '0' && *c <= '9')
			      bitend = (bitend * 10) + *c++ - '0';
d1796 24
a1819 2
			    if (!bitend)
			      abort ();
d1821 14
a1834 3
			    switch (*c)
			      {
			      case 'r':
d1836 2
a1837 6
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "%s", arm_regnames[reg]);
d1839 3
a1841 7
				break;
			      case 'd':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
d1843 3
a1845 4
				  func (stream, "%ld", reg);
				}
				break;
			      case 'f':
d1847 2
a1848 10
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  if (reg > 7)
				    func (stream, "#%s",
					  arm_fp_const[reg & 7]);
				  else
				    func (stream, "f%ld", reg);
d1850 3
a1852 1
				break;
d1854 3
a1856 1
			      case 'w':
d1858 2
a1859 17
				  long reg;

				  if (bitstart != bitend)
				    {
				      reg = given >> bitstart;
				      reg &= (2 << (bitend - bitstart)) - 1;
				      if (bitend - bitstart == 1)
					func (stream, "%s", iwmmxt_wwnames[reg]);
				      else
					func (stream, "%s", iwmmxt_wwssnames[reg]);
				    }
				  else
				    {
				      reg = (((given >> 8)  & 0x1) |
					     ((given >> 22) & 0x1));
				      func (stream, "%s", iwmmxt_wwnames[reg]);
				    }
d1861 8
a1868 3
				break;

			      case 'g':
d1870 2
a1871 4
				  long reg;
				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", iwmmxt_regnames[reg]);
d1873 7
a1879 10
				break;

			      case 'G':
				{
				  long reg;
				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", iwmmxt_cregnames[reg]);
				}
				break;
d1881 1
a1881 4
			      default:
				abort ();
			      }
			    break;
d1883 1
a1883 2
			  case 'y':
			  case 'z':
d1885 6
a1890 53
			      int single = *c == 'y';
			      int regno;

			      switch (bitstart)
				{
				case 4: /* Sm pair */
				  func (stream, "{");
				  /* Fall through.  */
				case 0: /* Sm, Dm */
				  regno = given & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 5) & 1;
				    }
				  break;

				case 1: /* Sd, Dd */
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;

				case 2: /* Sn, Dn */
				  regno = (given >> 16) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 7) & 1;
				    }
				  break;

				case 3: /* List */
				  func (stream, "{");
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;


				default:
				  abort ();
				}

			      func (stream, "%c%d", single ? 's' : 'd', regno);

			      if (bitstart == 3)
d1892 3
a1894 13
				  int count = given & 0xff;

				  if (single == 0)
				    count >>= 1;

				  if (--count)
				    {
				      func (stream, "-%c%d",
					    single ? 's' : 'd',
					    regno + count);
				    }

				  func (stream, "}");
d1896 2
a1897 5
			      else if (bitstart == 4)
				func (stream, ", %c%d}", single ? 's' : 'd',
				      regno + 1);

			      break;
d1899 4
a1902 23

			    break;

			  case '`':
			    c++;
			    if ((given & (1 << bitstart)) == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if ((given & (1 << bitstart)) != 0)
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    ++c;
			    if ((given & (1 << bitstart)) != 0)
			      func (stream, "%c", *c++);
			    else
			      func (stream, "%c", *++c);
			    break;
			  default:
			    abort ();
			  }
d1904 1
a1904 1

d2057 430
d2496 4
a2499 1
  if (print_insn_coprocessor (info, given, FALSE))
d2742 2
a2743 4
			int bitstart = *c++ - '0';
			int bitend = 0;
			while (*c >= '0' && *c <= '9')
			  bitstart = (bitstart * 10) + *c++ - '0';
d2745 2
d2749 14
a2762 2
			  case '-':
			    c++;
d2764 9
a2772 68
			    while (*c >= '0' && *c <= '9')
			      bitend = (bitend * 10) + *c++ - '0';

			    if (!bitend)
			      abort ();

			    switch (*c)
			      {
			      case 'r':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "%s", arm_regnames[reg]);
				}
				break;
			      case 'd':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "%ld", reg);
				}
				break;
			      case 'W':
				{
				  long reg;
				  
				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  
				  func (stream, "%ld", reg + 1);
				}
				break;
			      case 'x':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "0x%08lx", reg);

				  /* Some SWI instructions have special
				     meanings.  */
				  if ((given & 0x0fffffff) == 0x0FF00000)
				    func (stream, "\t; IMB");
				  else if ((given & 0x0fffffff) == 0x0FF00001)
				    func (stream, "\t; IMBRange");
				}
				break;
			      case 'X':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  func (stream, "%01lx", reg & 0xf);
				}
				break;
			      default:
				abort ();
			      }
a2773 1

d2776 1
a2776 1
			    if ((given & (1 << bitstart)) == 0)
d2781 1
a2781 1
			    if ((given & (1 << bitstart)) != 0)
d2785 2
a2786 5
			    ++c;
			    if ((given & (1 << bitstart)) != 0)
			      func (stream, "%c", *c++);
			    else
			      func (stream, "%c", *++c);
d3100 4
a3103 1
  if (print_insn_coprocessor (info, given, TRUE))
d3482 2
a3483 19
		  int bitstart = *c++ - '0';
		  int bitend = 0;
		  unsigned int val;
		  while (*c >= '0' && *c <= '9')
		    bitstart = (bitstart * 10) + *c++ - '0';

		  if (*c == '-')
		    {
		      c++;
		      while (*c >= '0' && *c <= '9')
			bitend = (bitend * 10) + *c++ - '0';
		      if (!bitend)
			abort ();

		      val = given >> bitstart;
		      val &= (2 << (bitend - bitstart)) - 1;
		    }
		  else
		    val = (given >> bitstart) & 1;
d3485 2
d3489 2
a3490 2
		    case 'd': func (stream, "%u", val); break;
		    case 'W': func (stream, "%u", val * 4); break;
a3500 2
		      if (val)
			func (stream, "%c", c[1]);
d3502 2
a3506 2
		      if (!val)
			func (stream, "%c", c[1]);
d3508 2
d3513 2
a3514 2
		      func (stream, "%c", val ? c[1] : c[2]);
		      c += 2;
@


1.62.2.1
log
@	* binutils/readelf.c (arm_attr_tag_VFP_arch): Add VFPv3.

	* gas/config/tc-arm.c (limits.h): Include.
	(fpu_arch_vfp_v3, fpu_vfp_ext_v3, fpu_neon_ext_v1)
	(fpu_vfp_v3_or_neon_ext): Declare constants.
	(neon_el_type): New enumeration of types for Neon vector elements.
	(neon_type_el): New struct. Define type and size of a vector element.
   	(NEON_MAX_TYPE_ELS): Define constant. The maximum number of types per
	instruction.
	(neon_type): Define struct. The type of an instruction.
	(arm_it): Add 'vectype' for the current instruction.
	(isscalar, immisalign, regisimm, isquad): New predicates for operands.
	(vfp_sp_reg_pos): Rename to...
	(vfp_reg_pos): ...this, and add VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
	tags.
	(arm_reg_type): Add REG_TYPE_NQ (Neon Q register) and REG_TYPE_NDQ
	(Neon D or Q register).
	(reg_expected_msgs): Sync with above. Allow VFD to mean VFP or Neon
	D register.
	(GE_OPT_PREFIX_BIG): Define constant, for use in...
	(my_get_expression): Allow above constant as argument to accept
	64-bit constants with optional prefix.
	(arm_reg_parse): Add extra argument to return the specific type of
	register in when either a D or Q register (REG_TYPE_NDQ) is requested.
	Can be NULL.
	(parse_scalar): New function. Parse Neon scalar (vector reg and index).
	(parse_reg_list): Update for new arm_reg_parse args.
	(parse_vfp_reg_list): Allow parsing of Neon D/Q register lists.
	(parse_neon_el_struct_list): New function. Parse element/structure
	register lists for VLD<n>/VST<n> instructions.
	(s_arm_unwind_save_vfp): Update for new parse_vfp_reg_list args.
	(s_arm_unwind_save_mmxwr): Likewise.
	(s_arm_unwind_save_mmxwcg): Likewise.
	(s_arm_unwind_movsp): Likewise.
	(s_arm_unwind_setfp): Likewise.
	(parse_big_immediate): New function. Parse an immediate, which may
	be 64 bits wide. Put results in inst.operands[i].
	(parse_shift): Update for new arm_reg_parse args.
	(parse_address): Likewise. Add parsing of alignment specifiers.
	(parse_neon_mov): Parse the operands of a VMOV instruction.
	(operand_parse_code): Add OP_RND, OP_RNQ, OP_RNDQ, OP_RNSC,
	OP_NRDLST, OP_NSTRLST, OP_NILO, OP_RNDQ_I0, OP_RR_RNSC,
	OP_RNDQ_RNSC, OP_RND_RNSC, OP_VMOV, OP_RNDQ_IMVNb, OP_RNDQ_I63b,
	OP_I0, OP_I16z, OP_I32z, OP_I64, OP_I64z, OP_oI32b, OP_oRND,
	OP_oRNQ, OP_oRNDQ.
	(parse_operands): Handle new codes above.
	(encode_arm_vfp_sp_reg): Rename to...
	(encode_arm_vfp_reg): ...this. Handle D regs (0-31) too. Complain if
	selected VFP version only supports D0-D15.
	(do_vfp_sp_monadic, do_vfp_sp_dyadic, do_vfp_sp_compare_z)
	(do_vfp_dp_sp_cvt, do_vfp_reg_from_sp, do_vfp_reg2_from_sp2)
	(do_vfp_sp_from_reg, do_vfp_sp2_from_reg2, do_vfp_sp_ldst)
	(do_vfp_dp_ldst, vfp_sp_ldstm, vfp_dp_ldstm): Update for new
	encode_arm_vfp_reg name, and allow 32 D regs.
	(do_vfp_dp_rd_rm, do_vfp_dp_rn_rd, do_vfp_dp_rd_rn)
	(do_vfp_dp_rd_rn_rm, do_vfp_rm_rd_rn): New functions to encode VFP
	insns allowing 32 D regs.
	(do_vfp_sp_const, do_vfp_dp_const, vfp_conv, do_vfp_sp_conv_16)
	(do_vfp_dp_conv_16, do_vfp_sp_conv_32, do_vfp_dp_conv_32): Handle
	constant-load and conversion insns introduced with VFPv3.
	(neon_tab_entry): New struct.
	(NEON_ENC_TAB): Bit patterns for overloaded Neon instructions, and
	those which are the targets of pseudo-instructions.
	(neon_opc): Enumerate opcodes, use as indices into...
	(neon_enc_tab): ...this. Hold data from NEON_ENC_TAB.
	(NEON_ENC_INTEGER, NEON_ENC_ARMREG, NEON_ENC_POLY, NEON_ENC_FLOAT)
	(NEON_ENC_SCALAR, NEON_ENC_IMMED, NEON_ENC_INTERLV, NEON_ENC_LANE)
	(NEON_ENC_DUP): Define meaningful helper macros to look up values in
	neon_enc_tab.
	(neon_shape): Enumerate shapes (permitted register widths, etc.) for
	Neon instructions.
	(neon_type_mask): New. Compact type representation for type
	checking.
	(N_SU_ALL, N_SU_32, N_SU_16_64, N_SUF_32, N_I_ALL, N_IF_32): Common
	permitted type combinations.
	(N_IGNORE_TYPE): New macro.
	(neon_check_shape): New function. Check an instruction shape for
	multiple alternatives. Return the specific shape for the current
	instruction.
	(neon_modify_type_size): New function. Modify a vector type and
	size, depending on the bit mask in argument 1.
	(neon_type_promote): New function. Convert a given "key" type (of an
	operand) into the correct type for a different operand, based on a bit
	mask.
	(type_chk_of_el_type): New function. Convert a type and size into the
	compact representation used for type checking.
	(el_type_of_type_ckh): New function. Reverse of above (only when a
	single bit is set in the bit mask).
	(modify_types_allowed): New function. Alter a mask of allowed types
	based on a bit mask of modifications.
	(neon_check_type): New function. Check the type of the current
	instruction against the variable argument list. The "key" type of the
	instruction is returned.
	(neon_dp_fixup): New function. Fill in and modify instruction bits for
	a Neon data-processing instruction depending on whether we're in ARM
	mode or Thumb-2 mode.
	(neon_logbits): New function.
	(neon_three_same, neon_two_same, do_neon_dyadic_i_su)
	(do_neon_dyadic_i64_su, neon_imm_shift, do_neon_shl_imm)
	(do_neon_qshl_imm, neon_cmode_for_logic_imm)
	(neon_bits_same_in_bytes, neon_squash_bits, neon_is_quarter_float)
	(neon_qfloat_bits, neon_cmode_for_move_imm, neon_write_immbits)
	(neon_invert_size, do_neon_logic, do_neon_bitfield, neon_dyadic)
	(do_neon_dyadic_if_su, do_neon_dyadic_if_su_d, do_neon_dyadic_if_i)
	(do_neon_dyadic_if_i_d, do_neon_addsub_if_i, neon_exchange_operands)
	(neon_compare, do_neon_cmp, do_neon_cmp_inv, do_neon_ceq)
	(neon_scalar_for_mul, neon_mul_mac, do_neon_mac_maybe_scalar)
	(do_neon_tst, do_neon_mul, do_neon_qdmulh, do_neon_fcmp_absolute)
	(do_neon_fcmp_absolute_inv, do_neon_step, do_neon_abs_neg)
	(do_neon_sli, do_neon_sri, do_neon_qshlu_imm, do_neon_qmovn)
	(do_neon_qmovun, do_neon_rshift_sat_narrow)
	(do_neon_rshift_sat_narrow_u, do_neon_movn, do_neon_rshift_narrow)
	(do_neon_shll, neon_cvt_flavour, do_neon_cvt, neon_move_immediate)
	(do_neon_mvn, neon_mixed_length, do_neon_dyadic_long, do_neon_abal)
	(neon_mac_reg_scalar_long, do_neon_mac_maybe_scalar_long)
	(do_neon_dyadic_wide, do_neon_vmull, do_neon_ext, do_neon_rev)
	(do_neon_dup, do_neon_mov, do_neon_rshift_round_imm, do_neon_movl)
	(do_neon_trn, do_neon_zip_uzp, do_neon_sat_abs_neg)
	(do_neon_pair_long, do_neon_recip_est, do_neon_cls, do_neon_clz)
	(do_neon_cnt, do_neon_swp, do_neon_tbl_tbx, do_neon_ldm_stm)
	(do_neon_ldr_str, do_neon_ld_st_interleave, neon_alignment_bit)
	(do_neon_ld_st_lane, do_neon_ld_dup, do_neon_ldx_stx): New
	functions. Neon bit encoding and encoding helpers.
	(parse_neon_type): New function. Parse Neon type specifier.
	(opcode_lookup): Allow parsing of Neon type specifiers.
	(REGNUM2, REGSETH, REGSET2): New macros.
	(reg_names): Add new VFPv3 and Neon registers.
	(NUF, nUF, NCE, nCE): New macros for opcode table.
	(insns): More VFP registers allowed in fcpyd, fmdhr, fmdlr, fmrdh,
	fmrdl, fabsd, fnegd, fsqrtd, faddd, fsubd, fmuld, fdivd, fmacd,
	fmscd, fnmuld, fnmacd, fnmscd, fcmpd, fcmpzd, fcmped, fcmpezd,
	fmdrr, fmrrd. Add Neon instructions vaba, vhadd, vrhadd, vhsub,
	vqadd, vqsub, vrshl, vqrshl, vshl, vqshl{u}, vand, vbic, vorr, vorn,
	veor, vbsl, vbit, vbif, vabd, vmax, vmin, vcge, vcgt, vclt, vcle,
	vceq, vpmax, vpmin, vmla, vmls, vpadd, vadd, vsub, vtst, vmul,
	vqdmulh, vqrdmulh, vacge, vacgt, vaclt, vacle, vrecps, vrsqrts,
	vabs, vneg, v{r}shr,  v{r}sra, vsli, vsri, vqshrn, vq{r}shr{u}n,
	v{r}shrn, vshll, vcvt, vmov, vmvn, vabal, vabdl, vaddl, vsubl,
	vmlal, vmlsl, vaddw, vsubw, v{r}addhn, v{r}subhn, vqdmlal, vqdmlsl,
	vqdmull, vmull, vext, vrev64, vrev32, vrev16, vdup, vmovl, v{q}movn,
	vzip, vuzp, vqabs, vqneg, vpadal, vpaddl, vrecpe, vrsqrte, vcls,
	vclz, vcnt, vswp, vtrn, vtbl, vtbx, vldm, vstm, vldr, vstr,
	vld[1234], vst[1234], fconst[sd], f[us][lh]to[sd], fto[us][lh][sd].
	(tc_arm_regname_to_dw2regnum): Update for arm_reg_parse args.
	(arm_cpu_option_table): Add Neon and VFPv3 to Cortex-A8.
	(arm_option_cpu_value): Add vfp3 and neon.
	(aeabi_set_public_attributes): Support VFPv3 and NEON attributes.
	Fix VFPv1 attribute.

	* gas/testsuite/gas/arm/copro.s: Avoid ldcl which encodes as a bad Neon
	instruction.
	* gas/testsuite/gas/arm/copro.d: Update accordingly.
	* gas/testsuite/gas/arm/neon-cond.s: New test. Conditional Neon opcodes
	in ARM mode.
	* gas/testsuite/gas/arm/neon-cond.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-cov.s: New test. Coverage of Neon
	instructions.
	* gas/testsuite/gas/arm/neon-cov.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-ldst-es.s: New test. Element and structure
	loads and stores.
	* gas/testsuite/gas/arm/neon-ldst-es.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-ldst-rm.s: New test. Single and multiple
	register loads and stores.
	* gas/testsuite/gas/arm/neon-ldst-rm.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-omit.s: New test. Omission of optional
	operands.
	* gas/testsuite/gas/arm/neon-omit.d: Expected results of above.
	* gas/testsuite/gas/arm/vfp1.d: Expect Neon syntax for some VFP
	instructions.
	* gas/testsuite/gas/arm/vfp1_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfp1xD.d: Likewise.
	* gas/testsuite/gas/arm/vfp1xD_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfp2.d: Likewise.
	* gas/testsuite/gas/arm/vfp2_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfp3-32drs.s: New test. Extended D register
	range for VFP instructions.
	* gas/testsuite/gas/arm/vfp3-32drs.d: Expected results of above.
	* gas/testsuite/gas/arm/vfp3-const-conv.s: New test. VFPv3
	constant-load and conversion instructions.
	* gas/testsuite/gas/arm/vfp3-const-conv.d: Expected results of above.

	* include/opcode/arm.h (FPU_VFP_EXT_V3): Define constant.
	(FPU_NEON_EXT_V1): Likewise.
	(FPU_VFP_HARD): Update.
	(FPU_VFP_V3): Define macro.
	(FPU_ARCH_VFP_V3, FPU_ARCH_VFP_V3_PLUS_NEON_V1): Define macros.

	* opcodes/arm-dis.c (coprocessor_opcodes): Add %A, %B, %k,
	convert %<code>[zy] into %[zy]<code>.  Expand meaning of
	%<bitfield>['`?].
	Add unified load/store instruction names.
	(neon_opcode_table): New.
	(arm_opcodes): Expand meaning of %<bitfield>['`?].
	(arm_decode_bitfield): New.
	(print_insn_coprocessor): Add pc argument. Add %A & %B specifiers.
	Use arm_decode_bitfield and adjust numeric specifiers.
	Adjust %z & %y.
	(print_insn_neon): New.
	(print_insn_arm): Adjust print_insn_coprocessor call. Call
	print_insn_neon. Use arm_decode_bitfield and adjust numeric specifiers.
	(print_insn_thumb32): Likewise.
@
text
@a65 2
   %B			print vstm/vldm register list
   %C			print vstr/vldr address operand
a73 1
   %<bitfield>k		print immediate for VFPv3 conversion instruction
a80 2
   %<bitfield>D		print as a NEON D register
   %<bitfield>Q		print as a NEON Q register
d82 1
a82 1
   %y<code>		print a single precision VFP reg.
d84 1
a84 1
   %z<code>		print a double precision VFP reg
d86 3
a89 4
   %<bitfield>'c	print specified char iff bitfield is all ones
   %<bitfield>`c	print specified char iff bitfield is all zeroes
   %<bitfield>?ab...    select from array of values in big endian order
   
a203 24
  /* Register load/store */
  {FPU_NEON_EXT_V1, 0x0d000b00, 0x0f300f00, "vstr%c\t%12-15,22D, %C"},
  {FPU_NEON_EXT_V1, 0x0d100b00, 0x0f300f00, "vldr%c\t%12-15,22D, %C"},
  {FPU_NEON_EXT_V1, 0x0c800b00, 0x0f900f00, "vstmia%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0c900b00, 0x0f900f00, "vldmia%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0d000b00, 0x0f900f00, "vstmdb%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0d100b00, 0x0f900f00, "vldmdb%c\t%16-19r%21'!, %B"},

  /* Data transfer between ARM and NEON registers */
  {FPU_NEON_EXT_V1, 0x0e800b10, 0x0ff00f70, "vdup%c.32\t%16-19,7D, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0e800b30, 0x0ff00f70, "vdup%c.16\t%16-19,7D, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0ea00b10, 0x0ff00f70, "vdup%c.32\t%16-19,7Q, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0ea00b30, 0x0ff00f70, "vdup%c.16\t%16-19,7Q, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0ec00b10, 0x0ff00f70, "vdup%c.8\t%16-19,7D, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0ee00b10, 0x0ff00f70, "vdup%c.8\t%16-19,7Q, %12-15r"},
  {FPU_NEON_EXT_V1, 0x0c400b10, 0x0ff00fd0, "vmov%c\t%0-3,5D, %12-15r, %16-19r"},
  {FPU_NEON_EXT_V1, 0x0c500b10, 0x0ff00fd0, "vmov%c\t%12-15r, %16-19r, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0x0e000b10, 0x0fd00f70, "vmov%c.32\t%16-19,7D[%21d], %12-15r"},
  {FPU_NEON_EXT_V1, 0x0e100b10, 0x0f500f70, "vmov%c.32\t%12-15r, %16-19,7D[%21d]"},
  {FPU_NEON_EXT_V1, 0x0e000b30, 0x0fd00f30, "vmov%c.16\t%16-19,7D[%6,21d], %12-15r"},
  {FPU_NEON_EXT_V1, 0x0e100b30, 0x0f500f30, "vmov%c.%23?us16\t%12-15r, %16-19,7D[%6,21d]"},
  {FPU_NEON_EXT_V1, 0x0e400b10, 0x0fd00f10, "vmov%c.8\t%16-19,7D[%5,6,21d], %12-15r"},
  {FPU_NEON_EXT_V1, 0x0e500b10, 0x0f500f10, "vmov%c.%23?us8\t%12-15r, %16-19,7D[%5,6,21d]"},

d205 30
d236 12
a252 9
  {FPU_VFP_EXT_V1xD, 0x0ef00a10, 0x0fff0fff, "fmrx%c\t%12-15r, fpsid"},
  {FPU_VFP_EXT_V1xD, 0x0ef10a10, 0x0fff0fff, "fmrx%c\t%12-15r, fpscr"},
  {FPU_VFP_EXT_V1xD, 0x0ef80a10, 0x0fff0fff, "fmrx%c\t%12-15r, fpexc"},
  {FPU_VFP_EXT_V1xD, 0x0ef90a10, 0x0fff0fff, "fmrx%c\t%12-15r, fpinst\t@@ Impl def"},
  {FPU_VFP_EXT_V1xD, 0x0efa0a10, 0x0fff0fff, "fmrx%c\t%12-15r, fpinst2\t@@ Impl def"},
  {FPU_VFP_EXT_V1, 0x0e000b10, 0x0ff00fff, "fmdlr%c\t%z2, %12-15r"},
  {FPU_VFP_EXT_V1, 0x0e100b10, 0x0ff00fff, "fmrdl%c\t%12-15r, %z2"},
  {FPU_VFP_EXT_V1, 0x0e200b10, 0x0ff00fff, "fmdhr%c\t%z2, %12-15r"},
  {FPU_VFP_EXT_V1, 0x0e300b10, 0x0ff00fff, "fmrdh%c\t%12-15r, %z2"},
d254 24
a277 63
  {FPU_VFP_EXT_V1xD, 0x0ef00a10, 0x0ff00fff, "fmrx%c\t%12-15r, <impl def 0x%16-19x>"},
  {FPU_VFP_EXT_V1xD, 0x0e000a10, 0x0ff00f7f, "fmsr%c\t%y2, %12-15r"},
  {FPU_VFP_EXT_V1xD, 0x0e100a10, 0x0ff00f7f, "fmrs%c\t%12-15r, %y2"},
  {FPU_VFP_EXT_V1xD, 0x0eb50a40, 0x0fbf0f70, "fcmp%7'ezs%c\t%y1"},
  {FPU_VFP_EXT_V1, 0x0eb50b40, 0x0fbf0f70, "fcmp%7'ezd%c\t%z1"},
  {FPU_VFP_EXT_V1xD, 0x0eb00a40, 0x0fbf0fd0, "fcpys%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb00ac0, 0x0fbf0fd0, "fabss%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb00b40, 0x0fbf0fd0, "fcpyd%c\t%z1, %z0"},
  {FPU_VFP_EXT_V1, 0x0eb00bc0, 0x0fbf0fd0, "fabsd%c\t%z1, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0eb10a40, 0x0fbf0fd0, "fnegs%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb10ac0, 0x0fbf0fd0, "fsqrts%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb10b40, 0x0fbf0fd0, "fnegd%c\t%z1, %z0"},
  {FPU_VFP_EXT_V1, 0x0eb10bc0, 0x0fbf0fd0, "fsqrtd%c\t%z1, %z0"},
  {FPU_VFP_EXT_V1, 0x0eb70ac0, 0x0fbf0fd0, "fcvtds%c\t%z1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb70bc0, 0x0fbf0fd0, "fcvtsd%c\t%y1, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0eb80a40, 0x0fbf0fd0, "fuitos%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb80ac0, 0x0fbf0fd0, "fsitos%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb80b40, 0x0fbf0fd0, "fuitod%c\t%z1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb80bc0, 0x0fbf0fd0, "fsitod%c\t%z1, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0eb40a40, 0x0fbf0f50, "fcmp%7'es%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0eb40b40, 0x0fbf0f50, "fcmp%7'ed%c\t%z1, %z0"},
  {FPU_VFP_EXT_V3, 0x0eba0a40, 0x0fbe0f50, "f%16?us%7?lhtos%c\t%y1, #%5,0-3k"},
  {FPU_VFP_EXT_V3, 0x0eba0b40, 0x0fbe0f50, "f%16?us%7?lhtod%c\t%z1, #%5,0-3k"},
  {FPU_VFP_EXT_V1xD, 0x0ebc0a40, 0x0fbe0f50, "fto%16?sui%7'zs%c\t%y1, %y0"},
  {FPU_VFP_EXT_V1, 0x0ebc0b40, 0x0fbe0f50, "fto%16?sui%7'zd%c\t%y1, %z0"},
  {FPU_VFP_EXT_V3, 0x0ebe0a40, 0x0fbe0f50, "fto%16?us%7?lhs%c\t%y1, #%5,0-3k"},
  {FPU_VFP_EXT_V3, 0x0ebe0b40, 0x0fbe0f50, "fto%16?us%7?lhd%c\t%z1, #%5,0-3k"},
  {FPU_VFP_EXT_V1, 0x0c500b10, 0x0fb00ff0, "fmrrd%c\t%12-15r, %16-19r, %z0"},
  {FPU_VFP_EXT_V3, 0x0eb00a00, 0x0fb00ff0, "fconsts%c\t%y1, #%16-19,0-3d"},
  {FPU_VFP_EXT_V3, 0x0eb00b00, 0x0fb00ff0, "fconstd%c\t%z1, #%16-19,0-3d"},
  {FPU_VFP_EXT_V2, 0x0c400a10, 0x0ff00fd0, "fmsrr%c\t%12-15r, %16-19r, %y4"},
  {FPU_VFP_EXT_V2, 0x0c400b10, 0x0ff00fd0, "fmdrr%c\t%z0, %12-15r, %16-19r"},
  {FPU_VFP_EXT_V2, 0x0c500a10, 0x0ff00fd0, "fmrrs%c\t%12-15r, %16-19r, %y4"},
  {FPU_VFP_EXT_V1xD, 0x0e000a00, 0x0fb00f50, "fmacs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e000a40, 0x0fb00f50, "fnmacs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e000b00, 0x0fb00f50, "fmacd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e000b40, 0x0fb00f50, "fnmacd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e100a00, 0x0fb00f50, "fmscs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e100a40, 0x0fb00f50, "fnmscs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e100b00, 0x0fb00f50, "fmscd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e100b40, 0x0fb00f50, "fnmscd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e200a00, 0x0fb00f50, "fmuls%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e200a40, 0x0fb00f50, "fnmuls%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e200b00, 0x0fb00f50, "fmuld%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e200b40, 0x0fb00f50, "fnmuld%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e300a00, 0x0fb00f50, "fadds%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1xD, 0x0e300a40, 0x0fb00f50, "fsubs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e300b00, 0x0fb00f50, "faddd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1, 0x0e300b40, 0x0fb00f50, "fsubd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0e800a00, 0x0fb00f50, "fdivs%c\t%y1, %y2, %y0"},
  {FPU_VFP_EXT_V1, 0x0e800b00, 0x0fb00f50, "fdivd%c\t%z1, %z2, %z0"},
  {FPU_VFP_EXT_V1xD, 0x0d200a00, 0x0fb00f00, "fstmdbs%c\t%16-19r!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0d200b00, 0x0fb00f00, "fstmdb%0?xd%c\t%16-19r!, %z3"},
  {FPU_VFP_EXT_V1xD, 0x0d300a00, 0x0fb00f00, "fldmdbs%c\t%16-19r!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0d300b00, 0x0fb00f00, "fldmdb%0?xd%c\t%16-19r!, %z3"},
  {FPU_VFP_EXT_V1xD, 0x0d000a00, 0x0f300f00, "fsts%c\t%y1, %A"},
  {FPU_VFP_EXT_V1, 0x0d000b00, 0x0f300f00, "fstd%c\t%z1, %A"},
  {FPU_VFP_EXT_V1xD, 0x0d100a00, 0x0f300f00, "flds%c\t%y1, %A"},
  {FPU_VFP_EXT_V1, 0x0d100b00, 0x0f300f00, "fldd%c\t%z1, %A"},
  {FPU_VFP_EXT_V1xD, 0x0c800a00, 0x0f900f00, "fstmias%c\t%16-19r%21'!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0c800b00, 0x0f900f00, "fstmia%0?xd%c\t%16-19r%21'!, %z3"},
  {FPU_VFP_EXT_V1xD, 0x0c900a00, 0x0f900f00, "fldmias%c\t%16-19r%21'!, %y3"},
  {FPU_VFP_EXT_V1xD, 0x0c900b00, 0x0f900f00, "fldmia%0?xd%c\t%16-19r%21'!, %z3"},
a383 1

a386 276
/* Neon opcode table:  This does not encode the top byte -- that is
   checked by the print_insn_neon routine, as it depends on whether we are
   doing thumb32 or arm32 disassembly.  */

/* print_insn_neon recognizes the following format control codes:

   %%			%

   %A			print v{st,ld}[1234] operands
   %B			print v{st,ld}[1234] any one operands
   %C			print v{st,ld}[1234] single->all operands
   %D			print scalar
   %E			print vmov, vmvn, vorr, vbic encoded constant
   %F			print vtbl,vtbx register list

   %<bitfield>r		print as an ARM register
   %<bitfield>d		print the bitfield in decimal
   %<bitfield>e         print the 2^N - bitfield in decimal
   %<bitfield>D		print as a NEON D register
   %<bitfield>Q		print as a NEON Q register
   %<bitfield>R		print as a NEON D or Q register
   %<bitfield>Sn	print byte scaled width limited by n
   %<bitfield>Tn	print short scaled width limited by n
   %<bitfield>Un	print long scaled width limited by n
   
   %<bitfield>'c	print specified char iff bitfield is all ones
   %<bitfield>`c	print specified char iff bitfield is all zeroes
   %<bitfield>?ab...    select from array of values in big endian order  */

static const struct opcode32 neon_opcodes[] =
{
  /* Extract */
  {FPU_NEON_EXT_V1, 0xf2b00840, 0xffb00850, "vext.8\t%12-15,22R, %16-19,7R, %0-3,5R, #%8-11d"},
  {FPU_NEON_EXT_V1, 0xf2b00000, 0xffb00810, "vext.8\t%12-15,22R, %16-19,7R, %0-3,5R, #%8-11d"},

  /* Move data element to all lanes */
  {FPU_NEON_EXT_V1, 0xf3b40c00, 0xffb70f90, "vdup.32\t%12-15,22R, %0-3,5D[%19d]"},
  {FPU_NEON_EXT_V1, 0xf3b20c00, 0xffb30f90, "vdup.16\t%12-15,22R, %0-3,5D[%18-19d]"},
  {FPU_NEON_EXT_V1, 0xf3b10c00, 0xffb10f90, "vdup.8\t%12-15,22R, %0-3,5D[%17-19d]"},

  /* Table lookup */
  {FPU_NEON_EXT_V1, 0xf3b00800, 0xffb00c50, "vtbl.8\t%12-15,22D, %F, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3b00840, 0xffb00c50, "vtbx.8\t%12-15,22D, %F, %0-3,5D"},
  
  /* Two registers, miscellaneous */
  {FPU_NEON_EXT_V1, 0xf2880a10, 0xfebf0fd0, "vmovl.%24?us8\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2900a10, 0xfebf0fd0, "vmovl.%24?us16\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2a00a10, 0xfebf0fd0, "vmovl.%24?us32\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3b00500, 0xffbf0f90, "vcnt.8\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00580, 0xffbf0f90, "vmvn\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20000, 0xffbf0f90, "vswp\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20200, 0xffb30fd0, "vmovn.i%18-19S2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20240, 0xffb30fd0, "vqmovun.s%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20280, 0xffb30fd0, "vqmovn.s%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b202c0, 0xffb30fd0, "vqmovn.u%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20300, 0xffb30fd0, "vshll.i%18-19S2\t%12-15,22Q, %0-3,5D, #%18-19S2"},
  {FPU_NEON_EXT_V1, 0xf3bb0400, 0xffbf0e90, "vrecpe.%8?fu%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3bb0480, 0xffbf0e90, "vrsqrte.%8?fu%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00000, 0xffb30f90, "vrev64.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00080, 0xffb30f90, "vrev32.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00100, 0xffb30f90, "vrev16.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00400, 0xffb30f90, "vcls.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00480, 0xffb30f90, "vclz.i%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00700, 0xffb30f90, "vqabs.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00780, 0xffb30f90, "vqneg.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20080, 0xffb30f90, "vtrn.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20100, 0xffb30f90, "vuzp.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20180, 0xffb30f90, "vzip.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b10000, 0xffb30b90, "vcgt.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10080, 0xffb30b90, "vcge.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10100, 0xffb30b90, "vceq.%10?fi%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10180, 0xffb30b90, "vcle.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10200, 0xffb30b90, "vclt.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10300, 0xffb30b90, "vabs.%10?fs%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b10380, 0xffb30b90, "vneg.%10?fs%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00200, 0xffb30f10, "vpaddl.%7?us%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00600, 0xffb30f10, "vpadal.%7?us%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b30600, 0xffb30e10, "vcvt.%7-8?usff%18-19Sa.%7-8?ffus%18-19Sa\t%12-15,22R, %0-3,5R"},

  /* Three registers of the same length */
  {FPU_NEON_EXT_V1, 0xf2000110, 0xffb00f10, "vand\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2100110, 0xffb00f10, "vbic\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200110, 0xffb00f10, "vorr\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2300110, 0xffb00f10, "vorn\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000110, 0xffb00f10, "veor\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3100110, 0xffb00f10, "vbsl\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200110, 0xffb00f10, "vbit\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3300110, 0xffb00f10, "vbif\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000d00, 0xffa00f10, "vadd.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000d10, 0xffa00f10, "vmla.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000e00, 0xffa00f10, "vceq.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000f00, 0xffa00f10, "vmax.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000f10, 0xffa00f10, "vrecps.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200d00, 0xffa00f10, "vsub.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200d10, 0xffa00f10, "vmls.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200f00, 0xffa00f10, "vmin.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200f10, 0xffa00f10, "vrsqrts.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000d00, 0xffa00f10, "vpadd.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000d10, 0xffa00f10, "vmul.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000e00, 0xffa00f10, "vcge.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000e10, 0xffa00f10, "vacge.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000f00, 0xffa00f10, "vpmax.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200d00, 0xffa00f10, "vabd.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200e00, 0xffa00f10, "vcgt.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200e10, 0xffa00f10, "vacgt.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200f00, 0xffa00f10, "vpmin.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000800, 0xff800f10, "vadd.i%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000810, 0xff800f10, "vtst.%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000900, 0xff800f10, "vmla.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000b00, 0xff800f10, "vqdmulh.s%20-21S6\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000b10, 0xff800f10, "vpadd.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000800, 0xff800f10, "vsub.i%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000810, 0xff800f10, "vceq.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000900, 0xff800f10, "vmls.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000b00, 0xff800f10, "vqrdmulh.s%20-21S6\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000000, 0xfe800f10, "vhadd.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000010, 0xfe800f10, "vqadd.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000100, 0xfe800f10, "vrhadd.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000200, 0xfe800f10, "vhsub.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000210, 0xfe800f10, "vqsub.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000300, 0xfe800f10, "vcgt.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000310, 0xfe800f10, "vcge.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000400, 0xfe800f10, "vshl.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000410, 0xfe800f10, "vqshl.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000500, 0xfe800f10, "vrshl.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000510, 0xfe800f10, "vqrshl.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000600, 0xfe800f10, "vmax.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000610, 0xfe800f10, "vmin.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000700, 0xfe800f10, "vabd.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000710, 0xfe800f10, "vaba.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000910, 0xfe800f10, "vmul.%24?pi%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000a00, 0xfe800f10, "vpmax.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000a10, 0xfe800f10, "vpmin.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},

  /* One register and an immediate value */
  {FPU_NEON_EXT_V1, 0xf2800e10, 0xfeb80fb0, "vmov.i8\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800e30, 0xfeb80fb0, "vmov.i64\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800f10, 0xfeb80fb0, "vmov.f32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800810, 0xfeb80db0, "vmov.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800830, 0xfeb80db0, "vmvn.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800910, 0xfeb80db0, "vorr.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800930, 0xfeb80db0, "vbic.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800c10, 0xfeb80eb0, "vmov.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800c30, 0xfeb80eb0, "vmvn.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800110, 0xfeb809b0, "vorr.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800130, 0xfeb809b0, "vbic.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800010, 0xfeb808b0, "vmov.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800030, 0xfeb808b0, "vmvn.i32\t%12-15,22R, %E"},

  /* Two registers and a shift amount */
  {FPU_NEON_EXT_V1, 0xf2880810, 0xffb80fd0, "vshrn.i16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880850, 0xffb80fd0, "vrshrn.i16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880810, 0xfeb80fd0, "vqshrun.s16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880850, 0xfeb80fd0, "vqrshrun.s16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880910, 0xfeb80fd0, "vqshrn.%24?us16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880950, 0xfeb80fd0, "vqrshrn.%24?us16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880a10, 0xfeb80fd0, "vshll.%24?us8\t%12-15,22D, %0-3,5Q, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2900810, 0xffb00fd0, "vshrn.i32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900850, 0xffb00fd0, "vrshrn.i32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2880510, 0xffb80f90, "vshl.%24?us8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf3880410, 0xffb80f90, "vsri.8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf3880510, 0xffb80f90, "vsli.8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf3880610, 0xffb80f90, "vqshlu.s8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2900810, 0xfeb00fd0, "vqshrun.s32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900850, 0xfeb00fd0, "vqrshrun.s32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900910, 0xfeb00fd0, "vqshrn.%24?us32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900950, 0xfeb00fd0, "vqrshrn.%24?us32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900a10, 0xfeb00fd0, "vshll.%24?us16\t%12-15,22D, %0-3,5Q, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2880010, 0xfeb80f90, "vshr.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880110, 0xfeb80f90, "vsra.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880210, 0xfeb80f90, "vrshr.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880310, 0xfeb80f90, "vrsra.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880710, 0xfeb80f90, "vqshl.%24?us8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2a00810, 0xffa00fd0, "vshrn.i64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00850, 0xffa00fd0, "vrshrn.i64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2900510, 0xffb00f90, "vshl.%24?us16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf3900410, 0xffb00f90, "vsri.16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf3900510, 0xffb00f90, "vsli.16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf3900610, 0xffb00f90, "vqshlu.s16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2a00a10, 0xfea00fd0, "vshll.%24?us32\t%12-15,22D, %0-3,5Q, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2900010, 0xfeb00f90, "vshr.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900110, 0xfeb00f90, "vsra.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900210, 0xfeb00f90, "vrshr.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900310, 0xfeb00f90, "vrsra.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900710, 0xfeb00f90, "vqshl.%24?us16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2800810, 0xfec00fd0, "vqshrun.s64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800850, 0xfec00fd0, "vqrshrun.s64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800910, 0xfec00fd0, "vqshrn.%24?us64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800950, 0xfec00fd0, "vqrshrn.%24?us64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00510, 0xffa00f90, "vshl.%24?us32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf3a00410, 0xffa00f90, "vsri.32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf3a00510, 0xffa00f90, "vsli.32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf3a00610, 0xffa00f90, "vqshlu.s32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2a00010, 0xfea00f90, "vshr.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00110, 0xfea00f90, "vsra.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00210, 0xfea00f90, "vrshr.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00310, 0xfea00f90, "vrsra.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00710, 0xfea00f90, "vqshl.%24?us32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2800590, 0xff800f90, "vshl.%24?us64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf3800490, 0xff800f90, "vsri.64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf3800590, 0xff800f90, "vsli.64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf3800690, 0xff800f90, "vqshlu.s64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf2800090, 0xfe800f90, "vshr.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800190, 0xfe800f90, "vsra.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800290, 0xfe800f90, "vrshr.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800390, 0xfe800f90, "vrsra.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800790, 0xfe800f90, "vqshl.%24?us64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf2a00e10, 0xfea00e90, "vcvt.%24,8?usff32.%24,8?ffus32\t%12-15,22R, %0-3,5R, #%16-20e"},

  /* Three registers of different lengths */
  {FPU_NEON_EXT_V1, 0xf2800e00, 0xfea00f50, "vmull.p%20S0\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800400, 0xff800f50, "vaddhn.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800600, 0xff800f50, "vsubhn.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800900, 0xff800f50, "vqdmlal.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800b00, 0xff800f50, "vqdmlsl.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800d00, 0xff800f50, "vqdmull.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3800400, 0xff800f50, "vraddhn.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3800600, 0xff800f50, "vrsubhn.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800000, 0xfe800f50, "vaddl.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800100, 0xfe800f50, "vaddw.%24?us%20-21S2\t%12-15,22Q, %16-19,7Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800200, 0xfe800f50, "vsubl.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800300, 0xfe800f50, "vsubw.%24?us%20-21S2\t%12-15,22Q, %16-19,7Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800500, 0xfe800f50, "vabal.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800700, 0xfe800f50, "vabdl.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800800, 0xfe800f50, "vmlal.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800a00, 0xfe800f50, "vmlsl.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800c00, 0xfe800f50, "vmull.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},

  /* Two registers and a scalar */
  {FPU_NEON_EXT_V1, 0xf2800040, 0xff800f50, "vmla.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800140, 0xff800f50, "vmla.f%20-21Sa\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800340, 0xff800f50, "vqdmlal.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800440, 0xff800f50, "vmls.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800540, 0xff800f50, "vmls.f%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800740, 0xff800f50, "vqdmlsl.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800840, 0xff800f50, "vmul.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800940, 0xff800f50, "vmul.f%20-21Sa\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800b40, 0xff800f50, "vqdmull.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800c40, 0xff800f50, "vqdmulh.s%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800d40, 0xff800f50, "vqrdmulh.s%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf3800040, 0xff800f50, "vmla.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800140, 0xff800f50, "vmla.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800440, 0xff800f50, "vmls.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800540, 0xff800f50, "vmls.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800840, 0xff800f50, "vmul.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800940, 0xff800f50, "vmul.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800c40, 0xff800f50, "vqdmulh.s%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800d40, 0xff800f50, "vqrdmulh.s%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf2800240, 0xfe800f50, "vmlal.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800640, 0xfe800f50, "vmlsl.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800a40, 0xfe800f50, "vmull.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},

  /* Element and structure load/store */
  {FPU_NEON_EXT_V1, 0xf4a00fc0, 0xffb00fc0, "vld4.32\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00c00, 0xffb00f00, "vld1.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00d00, 0xffb00f00, "vld2.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00e00, 0xffb00f00, "vld3.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00f00, 0xffb00f00, "vld4.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4000200, 0xff900f00, "v%21?ls%21?dt1.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000300, 0xff900f00, "v%21?ls%21?dt2.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000400, 0xff900f00, "v%21?ls%21?dt3.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000500, 0xff900f00, "v%21?ls%21?dt3.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000600, 0xff900f00, "v%21?ls%21?dt1.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000700, 0xff900f00, "v%21?ls%21?dt1.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000800, 0xff900f00, "v%21?ls%21?dt2.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000900, 0xff900f00, "v%21?ls%21?dt2.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000a00, 0xff900f00, "v%21?ls%21?dt1.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000000, 0xff900e00, "v%21?ls%21?dt4.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4800000, 0xff900300, "v%21?ls%21?dt1.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800100, 0xff900300, "v%21?ls%21?dt2.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800200, 0xff900300, "v%21?ls%21?dt3.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800300, 0xff900300, "v%21?ls%21?dt4.%10-11S2\t%B"},

  {0,0 ,0, 0}
};

d413 4
a416 4
   
   %<bitfield>'c	print specified char iff bitfield is all ones
   %<bitfield>`c	print specified char iff bitfield is all zeroes
   %<bitfield>?ab...    select from array of values in big endian order
d847 3
a849 3
       %<bitfield>'c	print specified char iff bitfield is all ones
       %<bitfield>`c	print specified char iff bitfield is all zeroes
       %<bitfield>?ab... select from array of values in big endian order
a1151 37
/* Decode a bitfield of the form matching regexp (N(-N)?,)*N(-N)?.
   Returns pointer to following character of the format string and
   fills in *VALUEP and *WIDTHP with the extracted value and number of
   bits extracted.  WIDTHP can be NULL. */

static const char *
arm_decode_bitfield (const char *ptr, unsigned long insn,
		     unsigned long *valuep, int *widthp)
{
  unsigned long value = 0;
  int width = 0;
  
  do 
    {
      int start, end;
      int bits;

      for (start = 0; *ptr >= '0' && *ptr <= '9'; ptr++)
	start = start * 10 + *ptr - '0';
      if (*ptr == '-')
	for (end = 0, ptr++; *ptr >= '0' && *ptr <= '9'; ptr++)
	  end = end * 10 + *ptr - '0';
      else
	end = start;
      bits = end - start;
      if (bits < 0)
	abort ();
      value |= ((insn >> start) & ((2ul << bits) - 1)) << width;
      width += bits + 1;
    }
  while (*ptr++ == ',');
  *valuep = value;
  if (widthp)
    *widthp = width;
  return ptr - 1;
}

d1188 1
a1188 1
print_insn_coprocessor (bfd_vma pc, struct disassemble_info *info, long given,
a1267 40
		    case 'B':
		      {
			int regno = ((given >> 12) & 0xf) | ((given >> (22 - 4)) & 0x10);
			int offset = (given >> 1) & 0x3f;
			
			if (offset == 1)
			  func (stream, "{d%d}", regno);
			else if (regno + offset > 32)
			  func (stream, "{d%d-<overflow reg d%d>}", regno, regno + offset - 1);
			else
			  func (stream, "{d%d-d%d}", regno, regno + offset - 1);
		      }
		      break;
		      
		    case 'C':
		      {
			int rn = (given >> 16) & 0xf;
			int offset = (given & 0xff) * 4;
			int add = (given >> 23) & 1;
			
			func (stream, "[%s", arm_regnames[rn]);
			
			if (offset)
			  {
			    if (!add)
			      offset = -offset;
			    func (stream, ", #%d", offset);
			  }
			func (stream, "]");
			if (rn == 15)
			  {
			    func (stream, "\t; ");
                            /* FIXME: Unsure if info->bytes_per_chunk is the
                               right thing to use here.  */
			    info->print_address_func (offset + pc
                              + info->bytes_per_chunk * 2, info);
			  }
		      }
		      break;
      
d1363 4
a1366 4
			int width;
			unsigned long value;

			c = arm_decode_bitfield (c, given, &value, &width);
d1370 17
a1386 28
			  case 'r':
			    func (stream, "%s", arm_regnames[value]);
			    break;
			  case 'D':
			    func (stream, "d%ld", value);
			    break;
			  case 'Q':
			    if (value & 1)
			      func (stream, "<illegal reg q%ld.5>", value >> 1);
			    else
			      func (stream, "q%ld", value >> 1);
			    break;
			  case 'd':
			    func (stream, "%ld", value);
			    break;
                          case 'k':
                            {
                              int from = (given & (1 << 7)) ? 32 : 16;
                              func (stream, "%ld", from - value);
                            }
                            break;
                            
			  case 'f':
			    if (value > 7)
			      func (stream, "#%s", arm_fp_const[value & 7]);
			    else
			      func (stream, "f%ld", value);
			    break;
d1388 6
a1393 6
			  case 'w':
			    if (width == 2)
			      func (stream, "%s", iwmmxt_wwnames[value]);
			    else
			      func (stream, "%s", iwmmxt_wwssnames[value]);
			    break;
d1395 2
a1396 24
			  case 'g':
			    func (stream, "%s", iwmmxt_regnames[value]);
			    break;
			  case 'G':
			    func (stream, "%s", iwmmxt_cregnames[value]);
			    break;
			  case '`':
			    c++;
			    if (value == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if (value == ((1ul << width) - 1))
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    func (stream, "%c", c[(1 << width) - (int)value]);
			    c += 1 << width;
			    break;
			  default:
			    abort ();
			  }
			break;
d1398 4
a1401 14
		      case 'y':
		      case 'z':
			{
			  int single = *c++ == 'y';
			  int regno;
			  
			  switch (*c)
			    {
			    case '4': /* Sm pair */
			      func (stream, "{");
			      /* Fall through.  */
			    case '0': /* Sm, Dm */
			      regno = given & 0x0000000f;
			      if (single)
d1403 10
a1412 2
				  regno <<= 1;
				  regno += (given >> 5) & 1;
d1414 1
a1414 3
                              else
                                regno += ((given >> 5) & 1) << 4;
			      break;
d1416 1
a1416 3
			    case '1': /* Sd, Dd */
			      regno = (given >> 12) & 0x0000000f;
			      if (single)
d1418 17
a1434 2
				  regno <<= 1;
				  regno += (given >> 22) & 1;
d1436 1
a1436 3
                              else
                                regno += ((given >> 22) & 1) << 4;
			      break;
d1438 1
a1438 3
			    case '2': /* Sn, Dn */
			      regno = (given >> 16) & 0x0000000f;
			      if (single)
d1440 4
a1443 2
				  regno <<= 1;
				  regno += (given >> 7) & 1;
d1445 3
a1447 8
                              else
                                regno += ((given >> 7) & 1) << 4;
			      break;
			      
			    case '3': /* List */
			      func (stream, "{");
			      regno = (given >> 12) & 0x0000000f;
			      if (single)
d1449 4
a1452 2
				  regno <<= 1;
				  regno += (given >> 22) & 1;
d1454 1
a1454 7
                              else
                                regno += ((given >> 22) & 1) << 4;
			      break;
			      
			    default:
			      abort ();
			    }
d1456 4
a1459 1
			  func (stream, "%c%d", single ? 's' : 'd', regno);
d1461 2
a1462 1
			  if (*c == '3')
d1464 53
a1516 6
			      int count = given & 0xff;
			      
			      if (single == 0)
				count >>= 1;
			      
			      if (--count)
d1518 13
a1530 3
				  func (stream, "-%c%d",
					single ? 's' : 'd',
					regno + count);
d1532 5
a1536 2
			      
			      func (stream, "}");
d1538 23
a1560 4
			  else if (*c == '4')
			    func (stream, ", %c%d}", single ? 's' : 'd',
				  regno + 1);
			}
d1562 1
a1562 1
			    
a1714 430
/* Print one neon instruction on INFO->STREAM.
   Return TRUE if the instuction matched, FALSE if this is not a
   recognised neon instruction.  */

static bfd_boolean
print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)
{
  const struct opcode32 *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  if (thumb)
    {
      if ((given & 0xef000000) == 0xef000000)
	{
	  /* move bit 28 to bit 24 to translate Thumb2 to ARM encoding.  */
	  unsigned long bit28 = given & (1 << 28);

	  given &= 0x00ffffff;
	  if (bit28)
            given |= 0xf3000000;
          else
	    given |= 0xf2000000;
	}
      else if ((given & 0xff000000) == 0xf9000000)
	given ^= 0xf9000000 ^ 0xf4000000;
      else
	return FALSE;
    }
  
  for (insn = neon_opcodes; insn->assembler; insn++)
    {
      if ((given & insn->mask) == insn->value)
	{
	  const char *c;

	  for (c = insn->assembler; *c; c++)
	    {
	      if (*c == '%')
		{
		  switch (*++c)
		    {
		    case '%':
		      func (stream, "%%");
		      break;

		    case 'A':
		      {
			static const unsigned char enc[16] = 
			{
			  0x4, 0x14, /* st4 0,1 */
			  0x4, /* st1 2 */
			  0x4, /* st2 3 */
			  0x3, /* st3 4 */
			  0x13, /* st3 5 */
			  0x3, /* st1 6 */
			  0x1, /* st1 7 */
			  0x2, /* st2 8 */
			  0x12, /* st2 9 */
			  0x2, /* st1 10 */
			  0, 0, 0, 0, 0
			};
			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
			int rn = ((given >> 16) & 0xf);
			int rm = ((given >> 0) & 0xf);
			int align = ((given >> 4) & 0x3);
			int type = ((given >> 8) & 0xf);
			int n = enc[type] & 0xf;
			int stride = (enc[type] >> 4) + 1;
			int ix;
			
			func (stream, "{");
			if (stride > 1)
			  for (ix = 0; ix != n; ix++)
			    func (stream, "%sd%d", ix ? "," : "", rd + ix * stride);
			else if (n == 1)
			  func (stream, "d%d", rd);
			else
			  func (stream, "d%d-d%d", rd, rd + n - 1);
			func (stream, "}, [%s", arm_regnames[rn]);
			if (align)
			  func (stream, ", :%d", 32 << align);
			func (stream, "]");
			if (rm == 0xd)
			  func (stream, "!");
			else if (rm != 0xf)
			  func (stream, ", %s", arm_regnames[rm]);
		      }
		      break;
		      
		    case 'B':
		      {
			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
			int rn = ((given >> 16) & 0xf);
			int rm = ((given >> 0) & 0xf);
			int idx_align = ((given >> 4) & 0xf);
                        int align = 0;
			int size = ((given >> 10) & 0x3);
			int idx = idx_align >> (size + 1);
                        int length = ((given >> 8) & 3) + 1;
                        int stride = 1;
                        int i;

                        if (length > 1 && size > 0)
                          stride = (idx_align & (1 << size)) ? 2 : 1;
			
                        switch (length)
                          {
                          case 1:
                            {
                              int amask = (1 << size) - 1;
                              if ((idx_align & (1 << size)) != 0)
                                return FALSE;
                              if (size > 0)
                                {
                                  if ((idx_align & amask) == amask)
                                    align = 8 << size;
                                  else if ((idx_align & amask) != 0)
                                    return FALSE;
                                }
                              }
                            break;
                          
                          case 2:
                            if (size == 2 && (idx_align & 2) != 0)
                              return FALSE;
                            align = (idx_align & 1) ? 16 << size : 0;
                            break;
                          
                          case 3:
                            if ((size == 2 && (idx_align & 3) != 0)
                                || (idx_align & 1) != 0)
                              return FALSE;
                            break;
                          
                          case 4:
                            if (size == 2)
                              {
                                if ((idx_align & 3) == 3)
                                  return FALSE;
                                align = (idx_align & 3) * 64;
                              }
                            else
                              align = (idx_align & 1) ? 32 << size : 0;
                            break;
                          
                          default:
                            abort ();
                          }
                                
			func (stream, "{");
                        for (i = 0; i < length; i++)
                          func (stream, "%sd%d[%d]", (i == 0) ? "" : ",",
                            rd + i * stride, idx);
                        func (stream, "}, [%s", arm_regnames[rn]);
			if (align)
			  func (stream, ", :%d", align);
			func (stream, "]");
			if (rm == 0xd)
			  func (stream, "!");
			else if (rm != 0xf)
			  func (stream, ", %s", arm_regnames[rm]);
		      }
		      break;
		      
		    case 'C':
		      {
			int rd = ((given >> 12) & 0xf) | (((given >> 22) & 1) << 4);
			int rn = ((given >> 16) & 0xf);
			int rm = ((given >> 0) & 0xf);
			int align = ((given >> 4) & 0x1);
			int size = ((given >> 6) & 0x3);
			int type = ((given >> 8) & 0x3);
			int n = type + 1;
			int stride = ((given >> 5) & 0x1);
			int ix;
			
			if (stride && (n == 1))
			  n++;
			else
			  stride++;
			
			func (stream, "{");
			if (stride > 1)
			  for (ix = 0; ix != n; ix++)
			    func (stream, "%sd%d[]", ix ? "," : "", rd + ix * stride);
			else if (n == 1)
			  func (stream, "d%d[]", rd);
			else
			  func (stream, "d%d[]-d%d[]", rd, rd + n - 1);
			func (stream, "}, [%s", arm_regnames[rn]);
			if (align)
			  {
                            int align = (8 * (type + 1)) << size;
                            if (type == 3)
                              align = (size > 1) ? align >> 1 : align;
			    if (type == 2 || (type == 0 && !size))
			      func (stream, ", :<bad align %d>", align);
			    else
			      func (stream, ", :%d", align);
			  }
			func (stream, "]");
			if (rm == 0xd)
			  func (stream, "!");
			else if (rm != 0xf)
			  func (stream, ", %s", arm_regnames[rm]);
		      }
		      break;
		      
		    case 'D':
		      {
			int raw_reg = (given & 0xf) | ((given >> 1) & 0x10);
			int size = (given >> 20) & 3;
			int reg = raw_reg & ((4 << size) - 1);
			int ix = raw_reg >> size >> 2;
			
			func (stream, "d%d[%d]", reg, ix);
		      }
		      break;
		      
		    case 'E':
		      /* Neon encoded constant for mov, mvn, vorr, vbic */
		      {
			int bits = 0;
			int cmode = (given >> 8) & 0xf;
			int op = (given >> 5) & 0x1;
			unsigned long value = 0, hival = 0;
			unsigned shift;
                        int size = 0;
			
			bits |= ((given >> 24) & 1) << 7;
			bits |= ((given >> 16) & 7) << 4;
			bits |= ((given >> 0) & 15) << 0;
			
			if (cmode < 8)
			  {
			    shift = (cmode >> 1) & 3;
			    value = (unsigned long)bits << (8 * shift);
                            size = 32;
			  }
			else if (cmode < 12)
			  {
			    shift = (cmode >> 1) & 1;
			    value = (unsigned long)bits << (8 * shift);
                            size = 16;
			  }
			else if (cmode < 14)
			  {
			    shift = (cmode & 1) + 1;
			    value = (unsigned long)bits << (8 * shift);
			    value |= (1ul << (8 * shift)) - 1;
                            size = 32;
			  }
			else if (cmode == 14)
			  {
			    if (op)
			      {
				/* bit replication into bytes */
				int ix;
				unsigned long mask;
				
				value = 0;
                                hival = 0;
				for (ix = 7; ix >= 0; ix--)
				  {
				    mask = ((bits >> ix) & 1) ? 0xff : 0;
                                    if (ix <= 3)
				      value = (value << 8) | mask;
                                    else
                                      hival = (hival << 8) | mask;
				  }
                                size = 64;
			      }
                            else
                              {
                                /* byte replication */
                                value = (unsigned long)bits;
                                size = 8;
                              }
			  }
			else if (!op)
			  {
			    /* floating point encoding */
			    int tmp;
			    
			    value = (unsigned long)(bits & 0x7f) << (24 - 6);
			    value |= (unsigned long)(bits & 0x80) << 24;
			    tmp = bits & 0x40 ? 0x3c : 0x40;
			    value |= (unsigned long)tmp << 24;
                            size = 32;
			  }
			else
			  {
			    func (stream, "<illegal constant %.8x:%x:%x>",
                                  bits, cmode, op);
                            size = 32;
			    break;
			  }
                        switch (size)
                          {
                          case 8:
			    func (stream, "#%ld\t; 0x%.2lx", value, value);
                            break;
                          
                          case 16:
                            func (stream, "#%ld\t; 0x%.4lx", value, value);
                            break;

                          case 32:
                            func (stream, "#%ld\t; 0x%.8lx", value, value);
                            break;

                          case 64:
                            func (stream, "#0x%.8lx%.8lx", hival, value);
                            break;
                          
                          default:
                            abort ();
                          }
		      }
		      break;
		      
		    case 'F':
		      {
			int regno = ((given >> 16) & 0xf) | ((given >> (7 - 4)) & 0x10);
			int num = (given >> 8) & 0x3;
			
			if (!num)
			  func (stream, "{d%d}", regno);
			else if (num + regno >= 32)
			  func (stream, "{d%d-<overflow reg d%d}", regno, regno + num);
			else
			  func (stream, "{d%d-d%d}", regno, regno + num);
		      }
		      break;
      

		    case '0': case '1': case '2': case '3': case '4':
		    case '5': case '6': case '7': case '8': case '9':
		      {
			int width;
			unsigned long value;

			c = arm_decode_bitfield (c, given, &value, &width);
			
			switch (*c)
			  {
			  case 'r':
			    func (stream, "%s", arm_regnames[value]);
			    break;
			  case 'd':
			    func (stream, "%ld", value);
			    break;
			  case 'e':
			    func (stream, "%ld", (1ul << width) - value);
			    break;
			    
			  case 'S':
			  case 'T':
			  case 'U':
			    /* various width encodings */
			    {
			      int base = 8 << (*c - 'S'); /* 8,16 or 32 */
			      int limit;
			      unsigned low, high;

			      c++;
			      if (*c >= '0' && *c <= '9')
				limit = *c - '0';
			      else if (*c >= 'a' && *c <= 'f')
				limit = *c - 'a' + 10;
			      else
				abort ();
			      low = limit >> 2;
			      high = limit & 3;

			      if (value < low || value > high)
				func (stream, "<illegal width %d>", base << value);
			      else
				func (stream, "%d", base << value);
			    }
			    break;
			  case 'R':
			    if (given & (1 << 6))
			      goto Q;
			    /* FALLTHROUGH */
			  case 'D':
			    func (stream, "d%ld", value);
			    break;
			  case 'Q':
			  Q:
			    if (value & 1)
			      func (stream, "<illegal reg q%ld.5>", value >> 1);
			    else
			      func (stream, "q%ld", value >> 1);
			    break;
			    
			  case '`':
			    c++;
			    if (value == 0)
			      func (stream, "%c", *c);
			    break;
			  case '\'':
			    c++;
			    if (value == ((1ul << width) - 1))
			      func (stream, "%c", *c);
			    break;
			  case '?':
			    func (stream, "%c", c[(1 << width) - (int)value]);
			    c += 1 << width;
			    break;
			  default:
			    abort ();
			  }
			break;

		      default:
			abort ();
		      }
		    }
		}
	      else
		func (stream, "%c", *c);
	    }
	  return TRUE;
	}
    }
  return FALSE;
}

d1724 1
a1724 4
  if (print_insn_coprocessor (pc, info, given, FALSE))
    return;

  if (print_insn_neon (info, given, FALSE))
d1967 4
a1970 2
			int width;
			unsigned long value;
a1971 2
			c = arm_decode_bitfield (c, given, &value, &width);
			
d1974 71
a2044 11
			  case 'r':
			    func (stream, "%s", arm_regnames[value]);
			    break;
			  case 'd':
			    func (stream, "%ld", value);
			    break;
			  case 'b':
			    func (stream, "%ld", value * 8);
			    break;
			  case 'W':
			    func (stream, "%ld", value + 1);
a2045 2
			  case 'x':
			    func (stream, "0x%08lx", value);
a2046 10
			    /* Some SWI instructions have special
			       meanings.  */
			    if ((given & 0x0fffffff) == 0x0FF00000)
			      func (stream, "\t; IMB");
			    else if ((given & 0x0fffffff) == 0x0FF00001)
			      func (stream, "\t; IMBRange");
			    break;
			  case 'X':
			    func (stream, "%01lx", value & 0xf);
			    break;
d2049 1
a2049 1
			    if (value == 0)
d2054 1
a2054 1
			    if (value == ((1ul << width) - 1))
d2058 5
a2062 2
			    func (stream, "%c", c[(1 << width) - (int)value]);
			    c += 1 << width;
d2376 1
a2376 4
  if (print_insn_coprocessor (pc, info, given, TRUE))
    return;

  if (print_insn_neon (info, given, TRUE))
d2755 19
a2773 2
		  int width;
		  unsigned long val;
a2774 2
		  c = arm_decode_bitfield (c, given, &val, &width);
			
d2777 2
a2778 2
		    case 'd': func (stream, "%lu", val); break;
		    case 'W': func (stream, "%lu", val * 4); break;
d2789 2
a2791 2
		      if (val == ((1ul << width) - 1))
			func (stream, "%c", *c);
d2795 2
a2797 2
		      if (val == 0)
			func (stream, "%c", *c);
d2801 2
a2802 2
		      func (stream, "%c", c[(1 << width) - (int)val]);
		      c += 1 << width;
@


1.62.2.2
log
@	* gas/config/tc-arm.c (neon_is_quarter_float): Move, and rename to...
	(is_quarter_float): Rename from above. Simplify slightly.
	(parse_qfloat_immediate): Parse a "quarter precision" floating-point
	number.
	(parse_neon_mov): Parse floating-point constants.
	(neon_qfloat_bits): Fix encoding.
	(neon_cmode_for_move_imm): Tweak to use floating-point encoding in
	preference to integer encoding when using the F32 type.

   	* gas/testsuite/gas/arm/neon-const.s: New testcase. Neon floating-point
	constants.
	* gas/testsuite/gas/arm/neon-const.d: Expected output of above.
	* gas/testsuite/gas/arm/neon-cov.d: Expect floating-point disassembly
	for VMOV.F32.

   	* opcodes/arm-dis.c (print_insn_neon): Disassemble floating-point
	constant VMOV.
@
text
@a28 1
#include "floatformat.h"
a2285 1
                        int isfloat = 0;
d2342 1
a2342 1
			    value = (unsigned long)(bits & 0x7f) << 19;
a2346 1
                            isfloat = 1;
d2366 1
a2366 21
                            if (isfloat)
                              {
                                unsigned char valbytes[4];
                                double fvalue;
                                
                                /* Do this a byte at a time so we don't have to
                                   worry about the host's endianness.  */
                                valbytes[0] = value & 0xff;
                                valbytes[1] = (value >> 8) & 0xff;
                                valbytes[2] = (value >> 16) & 0xff;
                                valbytes[3] = (value >> 24) & 0xff;
                                
                                floatformat_to_double 
                                  (&floatformat_ieee_single_little, valbytes,
                                  &fvalue);
                                                                
                                func (stream, "#%.7g\t; 0x%.8lx", fvalue,
                                      value);
                              }
                            else
                              func (stream, "#%ld\t; 0x%.8lx", value, value);
@


1.62.2.3
log
@	* gas/config/tc-arm.c (parse_vfp_reg_list): Improve register bounds
	checking.
	(do_neon_mov): Enable several VMOV variants for VFP. Add suitable
	architecture version checks.
	(insns): Allow overlapping instructions to be used in VFP mode.

   	* gas/testsuite/gas/arm/vfp-neon-overlap.s: New test. Overlapping
	VFP/Neon instructions.
	* gas/testsuite/gas/arm/vfp-neon-overlap.d: Expected output of above.
	* gas/testsuite/gas/arm/vfp1xD.d: Test for fldmx/fstmx.
	* gas/testsuite/gas/arm/vfp1xD_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfpv3-32drs.d: Likewise.

   	* opcodes/arm-dis.c (coprocessor_opcodes): Don't interpret fldmx/fstmx
	as vldm/vstm.
@
text
@a211 4
  {FPU_NEON_EXT_V1, 0x0d200b00, 0x0fb00f01, "vstmdb%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0d300b00, 0x0fb00f01, "vldmdb%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0c800b00, 0x0f900f01, "vstmia%c\t%16-19r%21'!, %B"},
  {FPU_NEON_EXT_V1, 0x0c900b00, 0x0f900f01, "vldmia%c\t%16-19r%21'!, %B"},
d214 4
@


1.62.2.4
log
@2006-04-29  Paul Brook  <paul@@codesourcery.com>

	* opcodes/arm-dis.c (coprocessor_opcodes): Add %c to unconditional
	arm instructions.
	(neon_opcodes): Add conditional execution specifiers.
	(thumb_opcodes): Ditto.
	(thumb32_opcodes): Ditto.
	(arm_conditional): Change 0xe to "al" and add "" to end.
	(ifthen_state, ifthen_next_state, ifthen_address): New.
	(IFTHEN_COND): Define.
	(print_insn_coprocessor, print_insn_neon): Print thumb conditions.
	(print_insn_arm): Change %c to use new values of arm_conditional.
	(print_insn_thumb16): Print thumb conditions.  Add %I.
	(print_insn_thumb32): Print thumb conditions.
	(find_ifthen_state): New function.
	(print_insn): Track IT block state.
	* gas/testsuite/gas/arm/thumb2_bcond.d: Update expected output.
	* gas/testsuite/gas/arm/thumb32.d: Ditto.
	* gas/testsuite/gas/arm/vfp1_t2.d: Ditto.
	* gas/testsuite/gas/arm/vfp1xD_t2.d: Ditto.
	* binutils/testsuite/binutils-all/arm/objdump.exp: New file.
	* binutils/testsuite/binutils-all/arm/thumb2-cond.s: New test.
@
text
@d65 1
a65 2
   %c			print condition code (always bits 28-31 in ARM mode)
   %u			print condition code (unconditional in ARM mode)
d412 2
a413 2
  {ARM_EXT_V6, 0xfc500000, 0xfff00000, "mrrc2%c\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
  {ARM_EXT_V6, 0xfc400000, 0xfff00000, "mcrr2%c\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
d416 5
a420 5
  {ARM_EXT_V5, 0xfc100000, 0xfe100000, "ldc2%22'l%c\t%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V5, 0xfc000000, 0xfe100000, "stc2%22'l%c\t%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V5, 0xfe000000, 0xff000010, "cdp2%c\t%8-11d, %20-23d, cr%12-15d, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V5, 0xfe000010, 0xff100010, "mcr2%c\t%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V5, 0xfe100010, 0xff100010, "mrc2%c\t%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, {%5-7d}"},
a432 1
   %c			print condition code
d457 2
a458 2
  {FPU_NEON_EXT_V1, 0xf2b00840, 0xffb00850, "vext%c.8\t%12-15,22R, %16-19,7R, %0-3,5R, #%8-11d"},
  {FPU_NEON_EXT_V1, 0xf2b00000, 0xffb00810, "vext%c.8\t%12-15,22R, %16-19,7R, %0-3,5R, #%8-11d"},
d461 3
a463 3
  {FPU_NEON_EXT_V1, 0xf3b40c00, 0xffb70f90, "vdup%c.32\t%12-15,22R, %0-3,5D[%19d]"},
  {FPU_NEON_EXT_V1, 0xf3b20c00, 0xffb30f90, "vdup%c.16\t%12-15,22R, %0-3,5D[%18-19d]"},
  {FPU_NEON_EXT_V1, 0xf3b10c00, 0xffb10f90, "vdup%c.8\t%12-15,22R, %0-3,5D[%17-19d]"},
d466 2
a467 2
  {FPU_NEON_EXT_V1, 0xf3b00800, 0xffb00c50, "vtbl%c.8\t%12-15,22D, %F, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3b00840, 0xffb00c50, "vtbx%c.8\t%12-15,22D, %F, %0-3,5D"},
d470 33
a502 33
  {FPU_NEON_EXT_V1, 0xf2880a10, 0xfebf0fd0, "vmovl%c.%24?us8\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2900a10, 0xfebf0fd0, "vmovl%c.%24?us16\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2a00a10, 0xfebf0fd0, "vmovl%c.%24?us32\t%12-15,22Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3b00500, 0xffbf0f90, "vcnt%c.8\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00580, 0xffbf0f90, "vmvn%c\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20000, 0xffbf0f90, "vswp%c\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20200, 0xffb30fd0, "vmovn%c.i%18-19S2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20240, 0xffb30fd0, "vqmovun%c.s%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20280, 0xffb30fd0, "vqmovn%c.s%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b202c0, 0xffb30fd0, "vqmovn%c.u%18-19T2\t%12-15,22D, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3b20300, 0xffb30fd0, "vshll%c.i%18-19S2\t%12-15,22Q, %0-3,5D, #%18-19S2"},
  {FPU_NEON_EXT_V1, 0xf3bb0400, 0xffbf0e90, "vrecpe%c.%8?fu%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3bb0480, 0xffbf0e90, "vrsqrte%c.%8?fu%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00000, 0xffb30f90, "vrev64%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00080, 0xffb30f90, "vrev32%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00100, 0xffb30f90, "vrev16%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00400, 0xffb30f90, "vcls%c.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00480, 0xffb30f90, "vclz%c.i%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00700, 0xffb30f90, "vqabs%c.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00780, 0xffb30f90, "vqneg%c.s%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20080, 0xffb30f90, "vtrn%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20100, 0xffb30f90, "vuzp%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b20180, 0xffb30f90, "vzip%c.%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b10000, 0xffb30b90, "vcgt%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10080, 0xffb30b90, "vcge%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10100, 0xffb30b90, "vceq%c.%10?fi%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10180, 0xffb30b90, "vcle%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10200, 0xffb30b90, "vclt%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R, #0"},
  {FPU_NEON_EXT_V1, 0xf3b10300, 0xffb30b90, "vabs%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b10380, 0xffb30b90, "vneg%c.%10?fs%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00200, 0xffb30f10, "vpaddl%c.%7?us%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b00600, 0xffb30f10, "vpadal%c.%7?us%18-19S2\t%12-15,22R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3b30600, 0xffb30e10, "vcvt%c.%7-8?usff%18-19Sa.%7-8?ffus%18-19Sa\t%12-15,22R, %0-3,5R"},
d505 53
a557 53
  {FPU_NEON_EXT_V1, 0xf2000110, 0xffb00f10, "vand%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2100110, 0xffb00f10, "vbic%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200110, 0xffb00f10, "vorr%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2300110, 0xffb00f10, "vorn%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000110, 0xffb00f10, "veor%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3100110, 0xffb00f10, "vbsl%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200110, 0xffb00f10, "vbit%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3300110, 0xffb00f10, "vbif%c\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000d00, 0xffa00f10, "vadd%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000d10, 0xffa00f10, "vmla%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000e00, 0xffa00f10, "vceq%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000f00, 0xffa00f10, "vmax%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000f10, 0xffa00f10, "vrecps%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200d00, 0xffa00f10, "vsub%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200d10, 0xffa00f10, "vmls%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200f00, 0xffa00f10, "vmin%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2200f10, 0xffa00f10, "vrsqrts%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000d00, 0xffa00f10, "vpadd%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000d10, 0xffa00f10, "vmul%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000e00, 0xffa00f10, "vcge%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000e10, 0xffa00f10, "vacge%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000f00, 0xffa00f10, "vpmax%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200d00, 0xffa00f10, "vabd%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200e00, 0xffa00f10, "vcgt%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200e10, 0xffa00f10, "vacgt%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3200f00, 0xffa00f10, "vpmin%c.f%20U0\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000800, 0xff800f10, "vadd%c.i%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000810, 0xff800f10, "vtst%c.%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000900, 0xff800f10, "vmla%c.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000b00, 0xff800f10, "vqdmulh%c.s%20-21S6\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000b10, 0xff800f10, "vpadd%c.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000800, 0xff800f10, "vsub%c.i%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000810, 0xff800f10, "vceq%c.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000900, 0xff800f10, "vmls%c.i%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf3000b00, 0xff800f10, "vqrdmulh%c.s%20-21S6\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000000, 0xfe800f10, "vhadd%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000010, 0xfe800f10, "vqadd%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000100, 0xfe800f10, "vrhadd%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000200, 0xfe800f10, "vhsub%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000210, 0xfe800f10, "vqsub%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000300, 0xfe800f10, "vcgt%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000310, 0xfe800f10, "vcge%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000400, 0xfe800f10, "vshl%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000410, 0xfe800f10, "vqshl%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000500, 0xfe800f10, "vrshl%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000510, 0xfe800f10, "vqrshl%c.%24?us%20-21S3\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000600, 0xfe800f10, "vmax%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000610, 0xfe800f10, "vmin%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000700, 0xfe800f10, "vabd%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000710, 0xfe800f10, "vaba%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000910, 0xfe800f10, "vmul%c.%24?pi%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000a00, 0xfe800f10, "vpmax%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
  {FPU_NEON_EXT_V1, 0xf2000a10, 0xfe800f10, "vpmin%c.%24?us%20-21S2\t%12-15,22R, %16-19,7R, %0-3,5R"},
d560 13
a572 13
  {FPU_NEON_EXT_V1, 0xf2800e10, 0xfeb80fb0, "vmov%c.i8\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800e30, 0xfeb80fb0, "vmov%c.i64\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800f10, 0xfeb80fb0, "vmov%c.f32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800810, 0xfeb80db0, "vmov%c.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800830, 0xfeb80db0, "vmvn%c.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800910, 0xfeb80db0, "vorr%c.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800930, 0xfeb80db0, "vbic%c.i16\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800c10, 0xfeb80eb0, "vmov%c.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800c30, 0xfeb80eb0, "vmvn%c.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800110, 0xfeb809b0, "vorr%c.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800130, 0xfeb809b0, "vbic%c.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800010, 0xfeb808b0, "vmov%c.i32\t%12-15,22R, %E"},
  {FPU_NEON_EXT_V1, 0xf2800030, 0xfeb808b0, "vmvn%c.i32\t%12-15,22R, %E"},
d575 58
a632 58
  {FPU_NEON_EXT_V1, 0xf2880810, 0xffb80fd0, "vshrn%c.i16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880850, 0xffb80fd0, "vrshrn%c.i16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880810, 0xfeb80fd0, "vqshrun%c.s16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880850, 0xfeb80fd0, "vqrshrun%c.s16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880910, 0xfeb80fd0, "vqshrn%c.%24?us16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880950, 0xfeb80fd0, "vqrshrn%c.%24?us16\t%12-15,22D, %0-3,5Q, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880a10, 0xfeb80fd0, "vshll%c.%24?us8\t%12-15,22D, %0-3,5Q, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2900810, 0xffb00fd0, "vshrn%c.i32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900850, 0xffb00fd0, "vrshrn%c.i32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2880510, 0xffb80f90, "vshl%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf3880410, 0xffb80f90, "vsri%c.8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf3880510, 0xffb80f90, "vsli%c.8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf3880610, 0xffb80f90, "vqshlu%c.s8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2900810, 0xfeb00fd0, "vqshrun%c.s32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900850, 0xfeb00fd0, "vqrshrun%c.s32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900910, 0xfeb00fd0, "vqshrn%c.%24?us32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900950, 0xfeb00fd0, "vqrshrn%c.%24?us32\t%12-15,22D, %0-3,5Q, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900a10, 0xfeb00fd0, "vshll%c.%24?us16\t%12-15,22D, %0-3,5Q, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2880010, 0xfeb80f90, "vshr%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880110, 0xfeb80f90, "vsra%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880210, 0xfeb80f90, "vrshr%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880310, 0xfeb80f90, "vrsra%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18e"},
  {FPU_NEON_EXT_V1, 0xf2880710, 0xfeb80f90, "vqshl%c.%24?us8\t%12-15,22R, %0-3,5R, #%16-18d"},
  {FPU_NEON_EXT_V1, 0xf2a00810, 0xffa00fd0, "vshrn%c.i64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00850, 0xffa00fd0, "vrshrn%c.i64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2900510, 0xffb00f90, "vshl%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf3900410, 0xffb00f90, "vsri%c.16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf3900510, 0xffb00f90, "vsli%c.16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf3900610, 0xffb00f90, "vqshlu%c.s16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2a00a10, 0xfea00fd0, "vshll%c.%24?us32\t%12-15,22D, %0-3,5Q, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2900010, 0xfeb00f90, "vshr%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900110, 0xfeb00f90, "vsra%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900210, 0xfeb00f90, "vrshr%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900310, 0xfeb00f90, "vrsra%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19e"},
  {FPU_NEON_EXT_V1, 0xf2900710, 0xfeb00f90, "vqshl%c.%24?us16\t%12-15,22R, %0-3,5R, #%16-19d"},
  {FPU_NEON_EXT_V1, 0xf2800810, 0xfec00fd0, "vqshrun%c.s64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800850, 0xfec00fd0, "vqrshrun%c.s64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800910, 0xfec00fd0, "vqshrn%c.%24?us64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2800950, 0xfec00fd0, "vqrshrn%c.%24?us64\t%12-15,22D, %0-3,5Q, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00510, 0xffa00f90, "vshl%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf3a00410, 0xffa00f90, "vsri%c.32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf3a00510, 0xffa00f90, "vsli%c.32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf3a00610, 0xffa00f90, "vqshlu%c.s32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2a00010, 0xfea00f90, "vshr%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00110, 0xfea00f90, "vsra%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00210, 0xfea00f90, "vrshr%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00310, 0xfea00f90, "vrsra%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20e"},
  {FPU_NEON_EXT_V1, 0xf2a00710, 0xfea00f90, "vqshl%c.%24?us32\t%12-15,22R, %0-3,5R, #%16-20d"},
  {FPU_NEON_EXT_V1, 0xf2800590, 0xff800f90, "vshl%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf3800490, 0xff800f90, "vsri%c.64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf3800590, 0xff800f90, "vsli%c.64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf3800690, 0xff800f90, "vqshlu%c.s64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf2800090, 0xfe800f90, "vshr%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800190, 0xfe800f90, "vsra%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800290, 0xfe800f90, "vrshr%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800390, 0xfe800f90, "vrsra%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21e"},
  {FPU_NEON_EXT_V1, 0xf2800790, 0xfe800f90, "vqshl%c.%24?us64\t%12-15,22R, %0-3,5R, #%16-21d"},
  {FPU_NEON_EXT_V1, 0xf2a00e10, 0xfea00e90, "vcvt%c.%24,8?usff32.%24,8?ffus32\t%12-15,22R, %0-3,5R, #%16-20e"},
d635 17
a651 17
  {FPU_NEON_EXT_V1, 0xf2800e00, 0xfea00f50, "vmull%c.p%20S0\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800400, 0xff800f50, "vaddhn%c.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800600, 0xff800f50, "vsubhn%c.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800900, 0xff800f50, "vqdmlal%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800b00, 0xff800f50, "vqdmlsl%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800d00, 0xff800f50, "vqdmull%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf3800400, 0xff800f50, "vraddhn%c.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf3800600, 0xff800f50, "vrsubhn%c.i%20-21T2\t%12-15,22D, %16-19,7Q, %0-3,5Q"},
  {FPU_NEON_EXT_V1, 0xf2800000, 0xfe800f50, "vaddl%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800100, 0xfe800f50, "vaddw%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800200, 0xfe800f50, "vsubl%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800300, 0xfe800f50, "vsubw%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7Q, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800500, 0xfe800f50, "vabal%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800700, 0xfe800f50, "vabdl%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800800, 0xfe800f50, "vmlal%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800a00, 0xfe800f50, "vmlsl%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
  {FPU_NEON_EXT_V1, 0xf2800c00, 0xfe800f50, "vmull%c.%24?us%20-21S2\t%12-15,22Q, %16-19,7D, %0-3,5D"},
d654 22
a675 22
  {FPU_NEON_EXT_V1, 0xf2800040, 0xff800f50, "vmla%c.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800140, 0xff800f50, "vmla%c.f%20-21Sa\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800340, 0xff800f50, "vqdmlal%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800440, 0xff800f50, "vmls%c.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800540, 0xff800f50, "vmls%c.f%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800740, 0xff800f50, "vqdmlsl%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800840, 0xff800f50, "vmul%c.i%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800940, 0xff800f50, "vmul%c.f%20-21Sa\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800b40, 0xff800f50, "vqdmull%c.s%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800c40, 0xff800f50, "vqdmulh%c.s%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800d40, 0xff800f50, "vqrdmulh%c.s%20-21S6\t%12-15,22D, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf3800040, 0xff800f50, "vmla%c.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800140, 0xff800f50, "vmla%c.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800440, 0xff800f50, "vmls%c.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800540, 0xff800f50, "vmls%c.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800840, 0xff800f50, "vmul%c.i%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800940, 0xff800f50, "vmul%c.f%20-21Sa\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800c40, 0xff800f50, "vqdmulh%c.s%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf3800d40, 0xff800f50, "vqrdmulh%c.s%20-21S6\t%12-15,22Q, %16-19,7Q, %D"},
  {FPU_NEON_EXT_V1, 0xf2800240, 0xfe800f50, "vmlal%c.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800640, 0xfe800f50, "vmlsl%c.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
  {FPU_NEON_EXT_V1, 0xf2800a40, 0xfe800f50, "vmull%c.%24?us%20-21S6\t%12-15,22Q, %16-19,7D, %D"},
d678 19
a696 19
  {FPU_NEON_EXT_V1, 0xf4a00fc0, 0xffb00fc0, "vld4%c.32\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00c00, 0xffb00f00, "vld1%c.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00d00, 0xffb00f00, "vld2%c.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00e00, 0xffb00f00, "vld3%c.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4a00f00, 0xffb00f00, "vld4%c.%6-7S2\t%C"},
  {FPU_NEON_EXT_V1, 0xf4000200, 0xff900f00, "v%21?ls%21?dt1%c.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000300, 0xff900f00, "v%21?ls%21?dt2%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000400, 0xff900f00, "v%21?ls%21?dt3%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000500, 0xff900f00, "v%21?ls%21?dt3%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000600, 0xff900f00, "v%21?ls%21?dt1%c.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000700, 0xff900f00, "v%21?ls%21?dt1%c.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000800, 0xff900f00, "v%21?ls%21?dt2%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000900, 0xff900f00, "v%21?ls%21?dt2%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000a00, 0xff900f00, "v%21?ls%21?dt1%c.%6-7S3\t%A"},
  {FPU_NEON_EXT_V1, 0xf4000000, 0xff900e00, "v%21?ls%21?dt4%c.%6-7S2\t%A"},
  {FPU_NEON_EXT_V1, 0xf4800000, 0xff900300, "v%21?ls%21?dt1%c.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800100, 0xff900300, "v%21?ls%21?dt2%c.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800200, 0xff900300, "v%21?ls%21?dt3%c.%10-11S2\t%B"},
  {FPU_NEON_EXT_V1, 0xf4800300, 0xff900300, "v%21?ls%21?dt4%c.%10-11S2\t%B"},
a993 5
   %c			print the condition code
   %C			print the condition code, or "s" if not conditional
   %x			print warning if conditional an not at end of IT block"
   %X			print "\t; unpredictable <IT:code>" if conditional
   %I			print IT instruction suffix and operands
d1009 6
a1014 6
  {ARM_EXT_V6K, 0xbf00, 0xffff, "nop%c"},
  {ARM_EXT_V6K, 0xbf10, 0xffff, "yield%c"},
  {ARM_EXT_V6K, 0xbf20, 0xffff, "wfe%c"},
  {ARM_EXT_V6K, 0xbf30, 0xffff, "wfi%c"},
  {ARM_EXT_V6K, 0xbf40, 0xffff, "sev%c"},
  {ARM_EXT_V6K, 0xbf00, 0xff0f, "nop%c\t{%4-7d}"},
d1017 9
a1025 3
  {ARM_EXT_V6T2, 0xb900, 0xfd00, "cbnz\t%0-2r, %b%X"},
  {ARM_EXT_V6T2, 0xb100, 0xfd00, "cbz\t%0-2r, %b%X"},
  {ARM_EXT_V6T2, 0xbf00, 0xff00, "it%I%X"},
d1028 11
a1038 11
  {ARM_EXT_V6, 0xb660, 0xfff8, "cpsie\t%2'a%1'i%0'f%X"},
  {ARM_EXT_V6, 0xb670, 0xfff8, "cpsid\t%2'a%1'i%0'f%X"},
  {ARM_EXT_V6, 0x4600, 0xffc0, "mov%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xba00, 0xffc0, "rev%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xba40, 0xffc0, "rev16%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xbac0, 0xffc0, "revsh%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb650, 0xfff7, "setend\t%3?ble%X"},
  {ARM_EXT_V6, 0xb200, 0xffc0, "sxth%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb240, 0xffc0, "sxtb%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb280, 0xffc0, "uxth%c\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb2c0, 0xffc0, "uxtb%c\t%0-2r, %3-5r"},
d1041 1
a1041 1
  {ARM_EXT_V5T, 0xbe00, 0xff00, "bkpt\t%0-7x"}, /* Is always unconditional.  */
d1043 1
a1043 1
  {ARM_EXT_V5T, 0x4780, 0xff87, "blx%c\t%3-6r%x"},	/* note: 4 bit register number.  */
d1045 1
a1045 1
  {ARM_EXT_V4T, 0x46C0, 0xFFFF, "nop%c\t\t\t(mov r8, r8)"},
d1047 16
a1062 16
  {ARM_EXT_V4T, 0x4000, 0xFFC0, "and%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4040, 0xFFC0, "eor%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4080, 0xFFC0, "lsl%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x40C0, 0xFFC0, "lsr%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4100, 0xFFC0, "asr%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4140, 0xFFC0, "adc%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4180, 0xFFC0, "sbc%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x41C0, 0xFFC0, "ror%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4200, 0xFFC0, "tst%c\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4240, 0xFFC0, "neg%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4280, 0xFFC0, "cmp%c\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x42C0, 0xFFC0, "cmn%c\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4300, 0xFFC0, "orr%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4340, 0xFFC0, "mul%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4380, 0xFFC0, "bic%C\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x43C0, 0xFFC0, "mvn%C\t%0-2r, %3-5r"},
d1064 2
a1065 2
  {ARM_EXT_V4T, 0xB000, 0xFF80, "add%c\tsp, #%0-6W"},
  {ARM_EXT_V4T, 0xB080, 0xFF80, "sub%c\tsp, #%0-6W"},
d1067 4
a1070 4
  {ARM_EXT_V4T, 0x4700, 0xFF80, "bx%c\t%S%x"},
  {ARM_EXT_V4T, 0x4400, 0xFF00, "add%c\t%D, %S"},
  {ARM_EXT_V4T, 0x4500, 0xFF00, "cmp%c\t%D, %S"},
  {ARM_EXT_V4T, 0x4600, 0xFF00, "mov%c\t%D, %S"},
d1072 2
a1073 2
  {ARM_EXT_V4T, 0xB400, 0xFE00, "push%c\t%N"},
  {ARM_EXT_V4T, 0xBC00, 0xFE00, "pop%c\t%O"},
d1075 4
a1078 4
  {ARM_EXT_V4T, 0x1800, 0xFE00, "add%C\t%0-2r, %3-5r, %6-8r"},
  {ARM_EXT_V4T, 0x1A00, 0xFE00, "sub%C\t%0-2r, %3-5r, %6-8r"},
  {ARM_EXT_V4T, 0x1C00, 0xFE00, "add%C\t%0-2r, %3-5r, #%6-8d"},
  {ARM_EXT_V4T, 0x1E00, 0xFE00, "sub%C\t%0-2r, %3-5r, #%6-8d"},
d1080 3
a1082 3
  {ARM_EXT_V4T, 0x5200, 0xFE00, "strh%c\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5A00, 0xFE00, "ldrh%c\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5600, 0xF600, "ldrs%11?hb%c\t%0-2r, [%3-5r, %6-8r]"},
d1084 2
a1085 2
  {ARM_EXT_V4T, 0x5000, 0xFA00, "str%10'b%c\t%0-2r, [%3-5r, %6-8r]"},
  {ARM_EXT_V4T, 0x5800, 0xFA00, "ldr%10'b%c\t%0-2r, [%3-5r, %6-8r]"},
d1087 3
a1089 3
  {ARM_EXT_V4T, 0x0000, 0xF800, "lsl%C\t%0-2r, %3-5r, #%6-10d"},
  {ARM_EXT_V4T, 0x0800, 0xF800, "lsr%C\t%0-2r, %3-5r, %s"},
  {ARM_EXT_V4T, 0x1000, 0xF800, "asr%C\t%0-2r, %3-5r, %s"},
d1091 4
a1094 4
  {ARM_EXT_V4T, 0x2000, 0xF800, "mov%C\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x2800, 0xF800, "cmp%c\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x3000, 0xF800, "add%C\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x3800, 0xF800, "sub%C\t%8-10r, #%0-7d"},
d1096 1
a1096 1
  {ARM_EXT_V4T, 0x4800, 0xF800, "ldr%c\t%8-10r, [pc, #%0-7W]\t(%0-7a)"},  /* TODO: Disassemble PC relative "LDR rD,=<symbolic>" */
d1098 4
a1101 4
  {ARM_EXT_V4T, 0x6000, 0xF800, "str%c\t%0-2r, [%3-5r, #%6-10W]"},
  {ARM_EXT_V4T, 0x6800, 0xF800, "ldr%c\t%0-2r, [%3-5r, #%6-10W]"},
  {ARM_EXT_V4T, 0x7000, 0xF800, "strb%c\t%0-2r, [%3-5r, #%6-10d]"},
  {ARM_EXT_V4T, 0x7800, 0xF800, "ldrb%c\t%0-2r, [%3-5r, #%6-10d]"},
d1103 2
a1104 2
  {ARM_EXT_V4T, 0x8000, 0xF800, "strh%c\t%0-2r, [%3-5r, #%6-10H]"},
  {ARM_EXT_V4T, 0x8800, 0xF800, "ldrh%c\t%0-2r, [%3-5r, #%6-10H]"},
d1106 2
a1107 2
  {ARM_EXT_V4T, 0x9000, 0xF800, "str%c\t%8-10r, [sp, #%0-7W]"},
  {ARM_EXT_V4T, 0x9800, 0xF800, "ldr%c\t%8-10r, [sp, #%0-7W]"},
d1109 2
a1110 2
  {ARM_EXT_V4T, 0xA000, 0xF800, "add%c\t%8-10r, pc, #%0-7W\t(adr %8-10r,%0-7a)"},
  {ARM_EXT_V4T, 0xA800, 0xF800, "add%c\t%8-10r, sp, #%0-7W"},
d1112 2
a1113 2
  {ARM_EXT_V4T, 0xC000, 0xF800, "stmia%c\t%8-10r!, %M"},
  {ARM_EXT_V4T, 0xC800, 0xF800, "ldmia%c\t%8-10r!, %M"},
d1115 1
a1115 1
  {ARM_EXT_V4T, 0xDF00, 0xFF00, "svc%c\t%0-7d"},
d1117 1
a1117 1
  {ARM_EXT_V4T, 0xD000, 0xF000, "b%8-11c.n\t%0-7B%X"},
d1119 1
a1119 1
  {ARM_EXT_V4T, 0xE000, 0xF800, "b%c.n\t%0-10B%x"},
a1154 3
       %c		print the condition code
       %x		print warning if conditional an not at end of IT block"
       %X		print "\t; unpredictable <IT:code>" if conditional
d1176 7
a1182 7
  {ARM_EXT_V7, 0xf910f000, 0xff70f000, "pli%c\t%a"},
  {ARM_EXT_V7, 0xf3af80f0, 0xfffffff0, "dbg%c\t#%0-3d"},
  {ARM_EXT_V7, 0xf3bf8f50, 0xfffffff0, "dmb%c\t%U"},
  {ARM_EXT_V7, 0xf3bf8f40, 0xfffffff0, "dsb%c\t%U"},
  {ARM_EXT_V7, 0xf3bf8f60, 0xfffffff0, "isb%c\t%U"},
  {ARM_EXT_DIV, 0xfb90f0f0, 0xfff0f0f0, "sdiv%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_DIV, 0xfbb0f0f0, 0xfff0f0f0, "udiv%c\t%8-11r, %16-19r, %0-3r"},
d1185 177
a1361 177
  {ARM_EXT_V6T2, 0xf3af8000, 0xffffffff, "nop%c.w"},
  {ARM_EXT_V6T2, 0xf3af8001, 0xffffffff, "yield%c.w"},
  {ARM_EXT_V6T2, 0xf3af8002, 0xffffffff, "wfe%c.w"},
  {ARM_EXT_V6T2, 0xf3af8003, 0xffffffff, "wfi%c.w"},
  {ARM_EXT_V6T2, 0xf3af9004, 0xffffffff, "sev%c.w"},
  {ARM_EXT_V6T2, 0xf3af8000, 0xffffff00, "nop%c.w\t{%0-7d}"},

  {ARM_EXT_V6T2, 0xf3bf8f2f, 0xffffffff, "clrex%c"},
  {ARM_EXT_V6T2, 0xf3af8400, 0xffffff1f, "cpsie.w\t%7'a%6'i%5'f%X"},
  {ARM_EXT_V6T2, 0xf3af8600, 0xffffff1f, "cpsid.w\t%7'a%6'i%5'f%X"},
  {ARM_EXT_V6T2, 0xf3c08f00, 0xfff0ffff, "bxj%c\t%16-19r%x"},
  {ARM_EXT_V6T2, 0xe810c000, 0xffd0ffff, "rfedb%c\t%16-19r%21'!"},
  {ARM_EXT_V6T2, 0xe990c000, 0xffd0ffff, "rfeia%c\t%16-19r%21'!"},
  {ARM_EXT_V6T2, 0xf3ef8000, 0xffeff000, "mrs%c\t%8-11r, %D"},
  {ARM_EXT_V6T2, 0xf3af8100, 0xffffffe0, "cps\t#%0-4d%X"},
  {ARM_EXT_V6T2, 0xe8d0f000, 0xfff0fff0, "tbb%c\t[%16-19r, %0-3r]%x"},
  {ARM_EXT_V6T2, 0xe8d0f010, 0xfff0fff0, "tbh%c\t[%16-19r, %0-3r, lsl #1]%x"},
  {ARM_EXT_V6T2, 0xf3af8500, 0xffffff00, "cpsie\t%7'a%6'i%5'f, #%0-4d%X"},
  {ARM_EXT_V6T2, 0xf3af8700, 0xffffff00, "cpsid\t%7'a%6'i%5'f, #%0-4d%X"},
  {ARM_EXT_V6T2, 0xf3de8f00, 0xffffff00, "subs%c\tpc, lr, #%0-7d"},
  {ARM_EXT_V6T2, 0xf3808000, 0xffe0f000, "msr%c\t%C, %16-19r"},
  {ARM_EXT_V6T2, 0xe8500f00, 0xfff00fff, "ldrex%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe8d00f4f, 0xfff00fef, "ldrex%4?hb%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe800c000, 0xffd0ffe0, "srsdb%c\t#%0-4d%21'!"},
  {ARM_EXT_V6T2, 0xe980c000, 0xffd0ffe0, "srsia%c\t#%0-4d%21'!"},
  {ARM_EXT_V6T2, 0xfa0ff080, 0xfffff0c0, "sxth%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa1ff080, 0xfffff0c0, "uxth%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa2ff080, 0xfffff0c0, "sxtb16%c\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa3ff080, 0xfffff0c0, "uxtb16%c\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa4ff080, 0xfffff0c0, "sxtb%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa5ff080, 0xfffff0c0, "uxtb%c.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xe8400000, 0xfff000ff, "strex%c\t%8-11r, %12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe8d0007f, 0xfff000ff, "ldrexd%c\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xfa80f000, 0xfff0f0f0, "sadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f010, 0xfff0f0f0, "qadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f020, 0xfff0f0f0, "shadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f040, 0xfff0f0f0, "uadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f050, 0xfff0f0f0, "uqadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f060, 0xfff0f0f0, "uhadd8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f080, 0xfff0f0f0, "qadd%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f090, 0xfff0f0f0, "qdadd%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0a0, 0xfff0f0f0, "qsub%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0b0, 0xfff0f0f0, "qdsub%c\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f000, 0xfff0f0f0, "sadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f010, 0xfff0f0f0, "qadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f020, 0xfff0f0f0, "shadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f040, 0xfff0f0f0, "uadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f050, 0xfff0f0f0, "uqadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f060, 0xfff0f0f0, "uhadd16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f080, 0xfff0f0f0, "rev%c.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f090, 0xfff0f0f0, "rev16%c.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f0a0, 0xfff0f0f0, "rbit%c\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f0b0, 0xfff0f0f0, "revsh%c.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfaa0f000, 0xfff0f0f0, "saddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f010, 0xfff0f0f0, "qaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f020, 0xfff0f0f0, "shaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f040, 0xfff0f0f0, "uaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f050, 0xfff0f0f0, "uqaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f060, 0xfff0f0f0, "uhaddsubx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f080, 0xfff0f0f0, "sel%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfab0f080, 0xfff0f0f0, "clz%c\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfac0f000, 0xfff0f0f0, "ssub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f010, 0xfff0f0f0, "qsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f020, 0xfff0f0f0, "shsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f040, 0xfff0f0f0, "usub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f050, 0xfff0f0f0, "uqsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f060, 0xfff0f0f0, "uhsub8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f000, 0xfff0f0f0, "ssub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f010, 0xfff0f0f0, "qsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f020, 0xfff0f0f0, "shsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f040, 0xfff0f0f0, "usub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f050, 0xfff0f0f0, "uqsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f060, 0xfff0f0f0, "uhsub16%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f000, 0xfff0f0f0, "ssubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f010, 0xfff0f0f0, "qsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f020, 0xfff0f0f0, "shsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f040, 0xfff0f0f0, "usubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f050, 0xfff0f0f0, "uqsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f060, 0xfff0f0f0, "uhsubaddx%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb00f000, 0xfff0f0f0, "mul%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb70f000, 0xfff0f0f0, "usad8%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa00f000, 0xffe0f0f0, "lsl%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa20f000, 0xffe0f0f0, "lsr%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa40f000, 0xffe0f0f0, "asr%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa60f000, 0xffe0f0f0, "ror%20's%c.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xe8c00f40, 0xfff00fe0, "strex%4?hb%c\t%0-3r, %12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xf3200000, 0xfff0f0e0, "ssat16%c\t%8-11r, #%0-4d, %16-19r"},
  {ARM_EXT_V6T2, 0xf3a00000, 0xfff0f0e0, "usat16%c\t%8-11r, #%0-4d, %16-19r"},
  {ARM_EXT_V6T2, 0xfb20f000, 0xfff0f0e0, "smuad%4'x%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb30f000, 0xfff0f0e0, "smulw%4?tb%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb40f000, 0xfff0f0e0, "smusd%4'x%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb50f000, 0xfff0f0e0, "smmul%4'r%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa00f080, 0xfff0f0c0, "sxtah%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa10f080, 0xfff0f0c0, "uxtah%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa20f080, 0xfff0f0c0, "sxtab16%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa30f080, 0xfff0f0c0, "uxtab16%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa40f080, 0xfff0f0c0, "sxtab%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa50f080, 0xfff0f0c0, "uxtab%c\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfb10f000, 0xfff0f0c0, "smul%5?tb%4?tb%c\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xf36f0000, 0xffff8020, "bfc%c\t%8-11r, %E"},
  {ARM_EXT_V6T2, 0xea100f00, 0xfff08f00, "tst%c.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xea900f00, 0xfff08f00, "teq%c\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb100f00, 0xfff08f00, "cmn%c.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xebb00f00, 0xfff08f00, "cmp%c.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xf0100f00, 0xfbf08f00, "tst%c.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0900f00, 0xfbf08f00, "teq%c\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1100f00, 0xfbf08f00, "cmn%c.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1b00f00, 0xfbf08f00, "cmp%c.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xea4f0000, 0xffef8000, "mov%20's%c.w\t%8-11r, %S"},
  {ARM_EXT_V6T2, 0xea6f0000, 0xffef8000, "mvn%20's%c.w\t%8-11r, %S"},
  {ARM_EXT_V6T2, 0xe8c00070, 0xfff000f0, "strexd%c\t%0-3r, %12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xfb000000, 0xfff000f0, "mla%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb000010, 0xfff000f0, "mls%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb700000, 0xfff000f0, "usada8%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb800000, 0xfff000f0, "smull%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfba00000, 0xfff000f0, "umull%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbc00000, 0xfff000f0, "smlal%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbe00000, 0xfff000f0, "umlal%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbe00060, 0xfff000f0, "umaal%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xe8500f00, 0xfff00f00, "ldrex%c\t%12-15r, [%16-19r, #%0-7W]"},
  {ARM_EXT_V6T2, 0xf7f08000, 0xfff0f000, "smc%c\t%K"},
  {ARM_EXT_V6T2, 0xf04f0000, 0xfbef8000, "mov%20's%c.w\t%8-11r, %M"},
  {ARM_EXT_V6T2, 0xf06f0000, 0xfbef8000, "mvn%20's%c.w\t%8-11r, %M"},
  {ARM_EXT_V6T2, 0xf810f000, 0xff70f000, "pld%c\t%a"},
  {ARM_EXT_V6T2, 0xfb200000, 0xfff000e0, "smlad%4'x%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb300000, 0xfff000e0, "smlaw%4?tb%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb400000, 0xfff000e0, "smlsd%4'x%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb500000, 0xfff000e0, "smmla%4'r%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb600000, 0xfff000e0, "smmls%4'r%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfbc000c0, 0xfff000e0, "smlald%4'x%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbd000c0, 0xfff000e0, "smlsld%4'x%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xeac00000, 0xfff08030, "pkhbt%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeac00020, 0xfff08030, "pkhtb%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xf3400000, 0xfff08020, "sbfx%c\t%8-11r, %16-19r, %F"},
  {ARM_EXT_V6T2, 0xf3c00000, 0xfff08020, "ubfx%c\t%8-11r, %16-19r, %F"},
  {ARM_EXT_V6T2, 0xf8000e00, 0xff900f00, "str%wt%c\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xfb100000, 0xfff000c0, "smla%5?tb%4?tb%c\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfbc00080, 0xfff000c0, "smlal%5?tb%4?tb%c\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xf3600000, 0xfff08020, "bfi%c\t%8-11r, %16-19r, %E"},
  {ARM_EXT_V6T2, 0xf8100e00, 0xfe900f00, "ldr%wt%c\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf3000000, 0xffd08020, "ssat%c\t%8-11r, #%0-4d, %16-19r%s"},
  {ARM_EXT_V6T2, 0xf3800000, 0xffd08020, "usat%c\t%8-11r, #%0-4d, %16-19r%s"},
  {ARM_EXT_V6T2, 0xf2000000, 0xfbf08000, "addw%c\t%8-11r, %16-19r, %I"},
  {ARM_EXT_V6T2, 0xf2400000, 0xfbf08000, "movw%c\t%8-11r, %J"},
  {ARM_EXT_V6T2, 0xf2a00000, 0xfbf08000, "subw%c\t%8-11r, %16-19r, %I"},
  {ARM_EXT_V6T2, 0xf2c00000, 0xfbf08000, "movt%c\t%8-11r, %J"},
  {ARM_EXT_V6T2, 0xea000000, 0xffe08000, "and%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea200000, 0xffe08000, "bic%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea400000, 0xffe08000, "orr%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea600000, 0xffe08000, "orn%20's%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea800000, 0xffe08000, "eor%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb000000, 0xffe08000, "add%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb400000, 0xffe08000, "adc%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb600000, 0xffe08000, "sbc%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeba00000, 0xffe08000, "sub%20's%c.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xebc00000, 0xffe08000, "rsb%20's%c\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xe8400000, 0xfff00000, "strex%c\t%8-11r, %12-15r, [%16-19r, #%0-7W]"},
  {ARM_EXT_V6T2, 0xf0000000, 0xfbe08000, "and%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0200000, 0xfbe08000, "bic%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0400000, 0xfbe08000, "orr%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0600000, 0xfbe08000, "orn%20's%c\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0800000, 0xfbe08000, "eor%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1000000, 0xfbe08000, "add%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1400000, 0xfbe08000, "adc%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1600000, 0xfbe08000, "sbc%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1a00000, 0xfbe08000, "sub%20's%c.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1c00000, 0xfbe08000, "rsb%20's%c\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xe8800000, 0xffd00000, "stmia%c.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe8900000, 0xffd00000, "ldmia%c.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9000000, 0xffd00000, "stmdb%c\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9100000, 0xffd00000, "ldmdb%c\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9c00000, 0xffd000ff, "strd%c\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9d00000, 0xffd000ff, "ldrd%c\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9400000, 0xff500000, "strd%c\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]"},
  {ARM_EXT_V6T2, 0xe9500000, 0xff500000, "ldrd%c\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]"},
  {ARM_EXT_V6T2, 0xf8000000, 0xff100000, "str%w%c.w\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf8100000, 0xfe100000, "ldr%w%c.w\t%12-15r, %a"},
d1366 2
a1367 2
  {ARM_EXT_V6T2, 0xf0008000, 0xf800d000, "b%22-25c.w\t%b%X"},
  {ARM_EXT_V6T2, 0xf0009000, 0xf800d000, "b%c.w\t%B%x"},
d1370 2
a1371 2
  {ARM_EXT_V4T,  0xf000c000, 0xf800d000, "blx%c\t%B%x"},
  {ARM_EXT_V4T,  0xf000d000, 0xf800d000, "bl%c\t%B%x"},
d1380 1
a1380 1
 "hi", "ls", "ge", "lt", "gt", "le", "al", "<und>", ""};
a1439 9
/* Current IT instruction state.  This conatins the same state as the IT
   bits in the CPSR.  */
static unsigned int ifthen_state;
/* IT state for the next instruction.  */
static unsigned int ifthen_next_state;
/* The address of the insn for which the IT state is valid.  */
static bfd_vma ifthen_address;
#define IFTHEN_COND ((ifthen_state >> 4) & 0xf)

a1546 1
  int cond;
a1563 4
	  if (ifthen_state)
	    cond = IFTHEN_COND;
	  else
	    cond = 16;
d1570 1
a1570 10
	    {
	      mask |= 0xf0000000;
	      cond = 16;
	    }
	  else
	    {
	      cond = (given >> 28) & 0xf;
	      if (cond == 0xe)
		cond = 16;
	    }
d1658 1
a1658 1

d1660 2
a1661 1
		      func (stream, "%s", arm_conditional[cond]);
a2103 5
		    case 'c':
		      if (thumb && ifthen_state)
			func (stream, "%s", arm_conditional[IFTHEN_COND]);
		      break;

d2636 2
a2637 3
		      if (((given >> 28) & 0xf) != 0xe)
			func (stream, "%s",
			      arm_conditional [(given >> 28) & 0xf]);
a2894 34
	      case 'c':
		if (ifthen_state)
		  func (stream, "%s", arm_conditional[IFTHEN_COND]);
		break;

	      case 'C':
		if (ifthen_state)
		  func (stream, "%s", arm_conditional[IFTHEN_COND]);
		else
		  func (stream, "s");
		break;

	      case 'I':
		{
		  unsigned int tmp;

		  ifthen_next_state = given & 0xff;
		  for (tmp = given << 1; tmp & 0xf; tmp <<= 1)
		    func (stream, ((given ^ tmp) & 0x10) ? "e" : "t");
		  func (stream, "\t%s", arm_conditional[(given >> 4) & 0xf]);
		}
		break;

	      case 'x':
		if (ifthen_next_state)
		  func (stream, "\t; unpredictable branch in IT block\n");
		break;

	      case 'X':
		if (ifthen_state)
		  func (stream, "\t; unpredictable <IT:%s>",
			arm_conditional[IFTHEN_COND]);
		break;

d3043 8
a3050 1
			    func (stream, "%s", arm_conditional [reg]);
a3146 16
	      case 'c':
		if (ifthen_state)
		  func (stream, "%s", arm_conditional[IFTHEN_COND]);
		break;

	      case 'x':
		if (ifthen_next_state)
		  func (stream, "\t; unpredictable branch in IT block\n");
		break;

	      case 'X':
		if (ifthen_state)
		  func (stream, "\t; unpredictable <IT:%s>",
			arm_conditional[IFTHEN_COND]);
		break;

d3517 4
a3520 1
		      func (stream, "%s", arm_conditional[val]);
a3631 78
/* Search back through the insn stream to determine if this instruction is
   conditionally executed.  */
static void
find_ifthen_state (bfd_vma pc, struct disassemble_info *info,
		   bfd_boolean little)
{
  unsigned char b[2];
  unsigned int insn;
  int status;
  /* COUNT is twice the number of instructions seen.  It will be odd if we
     just crossed an instruction boundary.  */
  int count;
  int it_count;
  unsigned int seen_it;
  bfd_vma addr;

  ifthen_address = pc;
  ifthen_state = 0;

  addr = pc;
  count = 1;
  it_count = 0;
  seen_it = 0;
  /* Scan backwards looking for IT instructions, keeping track of where
     instruction boundaries are.  We don't know if something is actually an
     IT instruction until we find a definite instruction boundary.  */
  for (;;)
    {
      if (addr == 0 || info->symbol_at_address_func(addr, info))
	{
	  /* A symbol must be on an instruction boundary, and will not
	     be within an IT block.  */
	  if (seen_it && (count & 1))
	    break;

	  return;
	}
      addr -= 2;
      status = info->read_memory_func (addr, (bfd_byte *)b, 2, info);
      if (status)
	return;

      if (little)
	insn = (b[0]) | (b[1] << 8);
      else
	insn = (b[1]) | (b[0] << 8);
      if (seen_it)
	{
	  if ((insn & 0xf800) < 0xe800)
	    {
	      /* Addr + 2 is an instruction boundary.  See if this matches
	         the expected boundary based on the position of the last
		 IT candidate.  */
	      if (count & 1)
		break;
	      seen_it = 0;
	    }
	}
      if ((insn & 0xff00) == 0xbf00 && (insn & 0xf) != 0)
	{
	  /* This could be an IT instruction.  */
	  seen_it = insn;
	  it_count = count >> 1;
	}
      if ((insn & 0xf800) >= 0xe800)
	count++;
      else
	count = (count + 2) | 1;
      /* IT blocks contain at most 4 instructions.  */
      if (count >= 8 && !seen_it)
	return;
    }
  /* We found an IT instruction.  */
  ifthen_state = (seen_it & 0xe0) | ((seen_it << it_count) & 0x1f);
  if ((ifthen_state & 0xf) == 0)
    ifthen_state = 0;
}

a3730 12

      if (ifthen_address != pc)
	find_ifthen_state(pc, info, little);

      if (ifthen_state)
	{
	  if ((ifthen_state & 0xf) == 0x8)
	    ifthen_next_state = 0;
	  else
	    ifthen_next_state = (ifthen_state & 0xe0)
				| ((ifthen_state & 0xf) << 1);
	}
a3746 6

  if (is_thumb)
    {
      ifthen_state = ifthen_next_state;
      ifthen_address += size;
    }
@


1.62.2.5
log
@2006-07-19  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	gas/
	* config/tc-arm.c (insns): Fix rbit Arm opcode.
	gas/testsuite/
	* gas/arm/archv6t2.d: Adjust expected output for rbit.
	opcodes/
	* armd-dis.c (arm_opcodes): Fix rbit opcode.
@
text
@d764 1
a764 1
  {ARM_EXT_V6T2, 0x06ff0f30, 0x0fff0ff0, "rbit%c\t%12-15r, %0-3r"},
@


1.62.2.6
log
@	Backport from mainline.

	opcodes/
	* arm-dis.c (coprocessor): Alter fmsrr disassembly syntax.

	gas/testsuite/
	* gas/arm/vfp-neon-syntax.d: Tweak expected fmsrr syntax.
	* gas/arm/vfp-neon-syntax_t2.d: Likewise.
	* gas/arm/vfp2.d: Likewise.
	* gas/arm/vfp2_t2.d: Likewise.
@
text
@d283 1
a283 1
  {FPU_VFP_EXT_V2, 0x0c400a10, 0x0ff00fd0, "fmsrr%c\t%y4, %12-15r, %16-19r"},
@


1.62.2.7
log
@	* arm-dis.c (print_insn_neon): Disassemble 32-bit immediates as
	signed on 64-bit hosts.
@
text
@d2420 1
a2420 3
                              func (stream, "#%ld\t; 0x%.8lx",
				(long) ((value & 0x80000000)
					? value | ~0xffffffffl : value), value);
@


1.62.2.8
log
@2006-09-04  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_neon_dyadic_if_i): Remove.
	(do_neon_dyadic_if_i_d): Avoid setting U bit.
	(do_neon_mac_maybe_scalar): Ditto.
	(do_neon_dyadic_narrow): Force operand type to NT_integer.
	(insns): Remove out of date comments.

	gas/testsuite/
	* gas/arm/neon-cov.s: Test .u and .s aliases for .i suffixes.
	* gas/arm/neon-cov.d: Adjust expected output.

	opcodes/
	* arm-dis.c (neon_opcode): Fix suffix on VMOVN.
@
text
@d478 1
a478 1
  {FPU_NEON_EXT_V1, 0xf3b20200, 0xffb30fd0, "vmovn%c.i%18-19T2\t%12-15,22D, %0-3,5Q"},
@


1.62.2.9
log
@2006-09-19  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Ian Lance Taylor  <ian@@wasabisystems.com>
            Ben Elliston  <bje@@wasabisystems.com>

	bfd/
	* archures.c: Add definition for bfd_mach_arm_iWMMXt2.
	* cpu-arm.c (processors): Add bfd_mach_arm_iWMMXt2.
	(arch_info_struct, bfd_arm_update_notes): Likewise.
	(architectures): Likewise.
	(bfd_arm_merge_machines): Check for iWMMXt2.
	* bfd-in2.h: Rebuild.

	gas/
	* config/tc-arm.c (enum operand_parse_code): New code OP_RIWR_I32z.
	(parse_operands): Handle OP_RIWR_I32z.
	(do_iwmmxt_wmerge): New function.
	(do_iwmmxt_wldstd): Handle iwmmxt2 case where second operand is
	a register.
	(do_iwmmxt_wrwrwr_or_imm5): New function.
	(insns): Mark instructions as RIWR_I32z as appropriate.
	Also add torvsc<b,h,w>, wabs<b,h,w>, wabsdiff<b,h,w>,
	waddbhus<l,m>, waddhc, waddwc, waddsubhx, wavg4{r}, wmaddu{x,n},
	wmadds{x,n}, wmerge, wmiaxy{n}, wmiawxy{n}, wmul<sm,um>{r},
	wmulw<um,sm,l>{r}, wqmiaxy{n}, wqmulm{r}, wqmulwm{r}, wsubaddhx.
	(md_begin): Handle IWMMXT2.
	(arm_cpus): Add iwmmxt2.
	(arm_extensions): Likewise.
	(arm_archs): Likewise.

	gas/testsuite/
	* gas/arm/iwmmxt2.s: New file.
	* gas/arm/iwmmxt2.d: New file.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): The X-qualifier to WMADD may
	only be used with the default multiply-add operation, so if N is
	set, don't bother printing X.  Add new iwmmxt instructions.
	(IWMMXT_INSN_COUNT): Update.
	(iwmmxt_wwssnames): Qualify "wwss" names at index 2, 6, 10 and 14
	with a 'c' suffix.
	(print_insn_coprocessor): Check for iWMMXt2.  Handle format
	specifiers 'r', 'i'.
@
text
@d101 1
a101 5
			versions.
   %i			print 5-bit immediate in bits 8,3..0
			(print "32" when 0)
   %r			print register offset address for wldt/wstr instruction
*/
d116 1
a116 1
#define IWMMXT_INSN_COUNT 73
a130 2
  {ARM_CEXT_XSCALE, 0x0e130190, 0x0f3f0fff, "torvsc%22-23w%c\t%12-15r"},
  {ARM_CEXT_XSCALE, 0x0e2001c0, 0x0f300fff, "wabs%22-23w%c\t%12-15g, %16-19g"},
a132 2
  {ARM_CEXT_XSCALE, 0x0e2001a0, 0x0f300ff0, "waddbhus%22?ml%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ea001a0, 0x0ff00ff0, "waddsubhx%c\t%12-15g, %16-19g, %0-3g"},
a136 1
  {ARM_CEXT_XSCALE, 0x0e400000, 0x0fe00ff0, "wavg4%20'r%c\t%12-15g, %16-19g, %0-3g"},
a138 1
  {ARM_CEXT_XSCALE, 0xfc500100, 0xfe500f00, "wldrd\t%12-15g, %r"},
d142 1
a142 2
  {ARM_CEXT_XSCALE, 0x0e800100, 0x0fc00ff0, "wmadd%21?su%20'x%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ec00100, 0x0fd00ff0, "wmadd%21?sun%c\t%12-15g, %16-19g, %0-3g"},
a143 3
  {ARM_CEXT_XSCALE, 0x0e000080, 0x0f100fe0, "wmerge%c\t%12-15g, %16-19g, %0-3g, #%21-23d"},
  {ARM_CEXT_XSCALE, 0x0e0000a0, 0x0f800ff0, "wmia%21?tb%20?tb%22'n%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e800120, 0x0f800ff0, "wmiaw%21?tb%20?tb%22'n%c\t%12-15g, %16-19g, %0-3g"},
d145 1
a145 8
  {ARM_CEXT_XSCALE, 0x0e000100, 0x0fc00ff0, "wmul%21?su%20?ml%23'r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ed00100, 0x0fd00ff0, "wmul%21?sumr%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ee000c0, 0x0fe00ff0, "wmulwsm%20`r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ec000c0, 0x0fe00ff0, "wmulwum%20`r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0eb000c0, 0x0ff00ff0, "wmulwl%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e8000a0, 0x0f800ff0, "wqmia%21?tb%20?tb%22'n%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e100080, 0x0fd00ff0, "wqmulm%21'r%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0ec000e0, 0x0fd00ff0, "wqmulwm%21'r%c\t%12-15g, %16-19g, %0-3g"},
d148 2
a149 3
  {ARM_CEXT_XSCALE, 0xfe300040, 0xff300ef0, "wror%22-23w\t%12-15g, %16-19g, #%i"},
  {ARM_CEXT_XSCALE, 0x0e300040, 0x0f300ff0, "wror%22-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e300140, 0x0f300ff0, "wror%22-23wg%c\t%12-15g, %16-19g, %0-3G"},
a151 1
  {ARM_CEXT_XSCALE, 0xfe100040, 0xff300ef0, "wsll%22-23w\t%12-15g, %16-19g, #%i"},
a153 1
  {ARM_CEXT_XSCALE, 0xfe000040, 0xff300ef0, "wsra%22-23w\t%12-15g, %16-19g, #%i"},
a155 1
  {ARM_CEXT_XSCALE, 0xfe200040, 0xff300ef0, "wsrl%22-23w\t%12-15g, %16-19g, #%i"},
a157 1
  {ARM_CEXT_XSCALE, 0xfc400100, 0xfe500f00, "wstrd\t%12-15g, %r"},
d161 1
a161 5
  {ARM_CEXT_XSCALE, 0x0ed001c0, 0x0ff00ff0, "wsubaddhx%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e1001c0, 0x0f300ff0, "wabsdiff%22-23w%c\t%12-15g, %16-19g, %0-3g"},
  {ARM_CEXT_XSCALE, 0x0e0000c0, 0x0fd00fff, "wunpckeh%21?sub%c\t%12-15g, %16-19g"},
  {ARM_CEXT_XSCALE, 0x0e4000c0, 0x0fd00fff, "wunpckeh%21?suh%c\t%12-15g, %16-19g"},
  {ARM_CEXT_XSCALE, 0x0e8000c0, 0x0fd00fff, "wunpckeh%21?suw%c\t%12-15g, %16-19g"},
d1420 4
a1423 4
{"b", "bus", "bc", "bss",
 "h", "hus", "hc", "hss",
 "w", "wus", "wc", "wss",
 "d", "dus", "dc", "dss"
d1566 1
a1566 2
	  && info->mach != bfd_mach_arm_iWMMXt
	  && info->mach != bfd_mach_arm_iWMMXt2)
a1979 47
		      case 'r':
			{
			  int imm4 = (given >> 4) & 0xf;
			  int puw_bits = ((given >> 22) & 6) | ((given >> 21) & 1);
			  int ubit = (given >> 23) & 1;
			  const char *rm = arm_regnames [given & 0xf];
			  const char *rn = arm_regnames [(given >> 16) & 0xf];

			  switch (puw_bits)
			    {
			    case 1:
			      /* fall through */
			    case 3:
			      func (stream, "[%s], %c%s", rn, ubit ? '+' : '-', rm);
			      if (imm4)
				func (stream, ", lsl #%d", imm4);
			      break;

			    case 4:
			      /* fall through */
			    case 5:
			      /* fall through */
			    case 6:
			      /* fall through */
			    case 7:
			      func (stream, "[%s, %c%s", rn, ubit ? '+' : '-', rm);
			      if (imm4 > 0)
				func (stream, ", lsl #%d", imm4);
			      func (stream, "]");
			      if (puw_bits == 5 || puw_bits == 7)
				func (stream, "!");
			      break;

			    default:
			      func (stream, "INVALID");
			    }
			}
			break;

		      case 'i':
			{
			  long imm5;
			  imm5 = ((given & 0x100) >> 4) | (given & 0xf);
			  func (stream, "%ld", (imm5 == 0) ? 32 : imm5);
			}
			break;

@


1.62.2.10
log
@2006-10-25  Paul Brook  <paul@@codesourcery.com>

	gas/
	* config/tc-arm.c (do_vfp_sp_const, do_vfp_dp_const): Fix operans
	encoding.

	gas/testsuite/
	* gas/arm/vfpv3-const-conv.s: Improve test coverage.
	* gas/arm/vfpv3-const-conv.d: Adjust expected output.
	* gas/arm/vfp-neon-syntax_t2.d: Ditto.
	* gas/arm/vfp-neon-syntax.d: Ditto.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Fix bitfields for fconstd/fconstd.
@
text
@d311 2
a312 2
  {FPU_VFP_EXT_V3, 0x0eb00a00, 0x0fb00ff0, "fconsts%c\t%y1, #%0-3,16-19d"},
  {FPU_VFP_EXT_V3, 0x0eb00b00, 0x0fb00ff0, "fconstd%c\t%z1, #%0-3,16-19d"},
@


1.62.2.11
log
@2006-10-26  Paul Brook  <paul@@codesourcery.com>

	binutils/
	* objdump.c (disassemble_section): Set info->symtab_pos.
	(disassemble_data): Set info->symtab and info->symtab_size.

	include/
	* dis-asm.h (disassemble_info): Add symtab, symtab_pos and
	symtab_size.

	opcodes/
	* arm-dis.c (last_is_thumb, last_mapping_sym, last_mapping_addr): New.
	(get_sym_code_type): New function.
	(print_insn): Search for mapping symbols.
@
text
@a1482 5
/* Cached Thumb state.  */
int last_is_thumb;
int last_mapping_sym = -1;
bfd_vma last_mapping_addr = 0;

a3861 33
/* Try to infer the code type (Arm or Thumb) from a symbol.
   Returns nonzero if is_thumb was set.  */

static int
get_sym_code_type (struct disassemble_info *info, int n, int *is_thumb)
{
  elf_symbol_type *es;
  unsigned int type;
  const char *name;

  es = *(elf_symbol_type **)(info->symbols);
  type = ELF_ST_TYPE (es->internal_elf_sym.st_info);

//printf("Scan %d %s\n", n, bfd_asymbol_name(info->symtab[n]));
  /* If the symbol has function type then use that.  */
  if (type == STT_FUNC || type == STT_ARM_TFUNC)
    {
      *is_thumb = (type == STT_ARM_TFUNC);
      return TRUE;
    }

  /* Check for mapping symbols.  */
  name = bfd_asymbol_name(info->symtab[n]);
  if (name[0] == '$' && (name[1] == 'a' || name[1] == 't')
      && (name[2] == 0 || name[2] == '.'))
    {
      *is_thumb = (name[1] == 't');
      return TRUE;
    }

  return FALSE;
}

d3900 2
a3901 4
	  bfd_vma addr;
	  int n;
	  int last_sym;
	  bfd_boolean found;
d3903 2
a3904 22
	  if (info->symtab)
	    {
	      if (pc <= last_mapping_addr)
		last_mapping_sym = -1;
//printf("Mapping %d %d %d\n", last_mapping_sym, info->symtab_pos, info->symtab_size);
	      is_thumb = last_is_thumb;
	      found = FALSE;
	      /* Start scanning at the start of the function, or wherever
		 we finished last time.  */
	      n = info->symtab_pos + 1;
	      if (n < last_mapping_sym)
		n = last_mapping_sym;

	      /* Scan up to the location being disassembled.  */
	      for (; n < info->symtab_size; n++)
		{
		  addr = bfd_asymbol_value (info->symtab[n]);
		  if (addr > pc)
		    break;
		  if (get_sym_code_type (info, n, &is_thumb))
		    found = TRUE;
		}
d3906 1
a3906 38
	      last_sym = n;
	      if (!found)
		{
		  if (last_mapping_sym == -1)
		    last_mapping_sym = 0;
		  else
		    found = TRUE;

		  /* No mapping symbol found at this address.  Look backwards
		     for a preceeding one.  */
		  for (n = info->symtab_pos; n >= last_mapping_sym; n--)
		    {
		      if (get_sym_code_type (info, n, &is_thumb))
			{
			  found = TRUE;
			  break;
			}
		    }
		}

	      last_mapping_sym = last_sym;
	      last_is_thumb = is_thumb;
	    }
	  else
	    found = FALSE;

	  /* If no mapping symbol has been found then fall back to the type
	     of the function symbol.  */
	  if (!found)
	    {
	      elf_symbol_type *  es;
	      unsigned int       type;

	      es = *(elf_symbol_type **)(info->symbols);
	      type = ELF_ST_TYPE (es->internal_elf_sym.st_info);

	      is_thumb = (type == STT_ARM_TFUNC) || (type == STT_ARM_16BIT);
	    }
@


1.61
log
@2006-02-24  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/arm/tc-arm.c (arm_ext_v6_notm, arm_ext_div, arm_ext_v7,
	arm_ext_v7a, arm_ext_v7r, arm_ext_v7m): New variables.
	(struct asm_barrier_opt): Define.
	(arm_v7m_psr_hsh, arm_barrier_opt_hsh): New variables.
	(parse_psr): Accept V7M psr names.
	(parse_barrier): New function.
	(enum operand_parse_code): Add OP_oBARRIER.
	(parse_operands): Implement OP_oBARRIER.
	(do_barrier): New function.
	(do_dbg, do_pli, do_t_barrier, do_t_dbg, do_t_div): New functions.
	(do_t_cpsi): Add V7M restrictions.
	(do_t_mrs, do_t_msr): Validate V7M variants.
	(md_assemble): Check for NULL variants.
	(v7m_psrs, barrier_opt_names): New tables.
	(insns): Add V7 instructions.  Mark V6 instructions absent from V7M.
	(md_begin): Initialize arm_v7m_psr_hsh and arm_barrier_opt_hsh.
	(arm_cpu_option_table): Add Cortex-M3, R4 and A8.
	(arm_arch_option_table): Add armv7, armv7a, armv7r and armv7m.
	(struct cpu_arch_ver_table): Define.
	(cpu_arch_ver): New.
	(aeabi_set_public_attributes): Use cpu_arch_ver.  Set
	Tag_CPU_arch_profile.
	* doc/c-arm.texi: Document new cpu and arch options.
gas/testsuite/
	* gas/arm/thumb32.d: Fix expected msr and mrs output.
	* gas/arm/arch7.d: New test.
	* gas/arm/arch7.s: New test.
	* gas/arm/arch7m-bad.l: New test.
	* gas/arm/arch7m-bad.d: New test.
	* gas/arm/arch7m-bad.s: New test.
include/opcode/
	* arm.h: Add V7 feature bits.
opcodes/
	* arm-dis.c (arm_opcodes): Add V7 instructions.
	(thumb32_opcodes): Ditto.  Handle V7M MSR/MRS variants.
	(print_arm_address): New function.
	(print_insn_arm): Use it.  Add 'P' and 'U' cases.
	(psr_name): New function.
	(print_insn_thumb32): Add 'U', 'C' and 'D' cases.
@
text
@d662 1
a662 1
  {ARM_EXT_V1, 0x0f000000, 0x0f000000, "swi%c\t%0-23x"},
d801 1
a801 1
  {ARM_EXT_V4T, 0xDF00, 0xFF00, "swi\t%0-7d"},
@


1.60
log
@2005-11-02  Paul Brook  <paul@@codesourcery.com>

	* arm-dis.c (print_insn_thumb32): Word align blx target address.
@
text
@d405 2
d433 7
d839 2
d861 9
d884 1
a884 1
  {ARM_EXT_V6T2, 0xf3ef8000, 0xffeff0ff, "mrs\t%8-11r, %20?CSPSR"},
d891 1
a891 1
  {ARM_EXT_V6T2, 0xf3808000, 0xffe0f0ff, "msr\t%20?CSPSR_%8'c%9'x%10's%11'f, %16-19r"},
d1625 90
d1755 2
a1756 4
		      if (((given & 0x000f0000) == 0x000f0000)
			  && ((given & 0x02000000) == 0))
			{
			  int offset = given & 0xfff;
d1758 4
a1761 77
			  func (stream, "[pc");

			  if (given & 0x01000000)
			    {
			      if ((given & 0x00800000) == 0)
				offset = - offset;

			      /* Pre-indexed.  */
			      func (stream, ", #%d]", offset);

			      offset += pc + 8;

			      /* Cope with the possibility of write-back
				 being used.  Probably a very dangerous thing
				 for the programmer to do, but who are we to
				 argue ?  */
			      if (given & 0x00200000)
				func (stream, "!");
			    }
			  else
			    {
			      /* Post indexed.  */
			      func (stream, "], #%d", offset);

			      /* ie ignore the offset.  */
			      offset = pc + 8;
			    }

			  func (stream, "\t; ");
			  info->print_address_func (offset, info);
			}
		      else
			{
			  func (stream, "[%s",
				arm_regnames[(given >> 16) & 0xf]);
			  if ((given & 0x01000000) != 0)
			    {
			      if ((given & 0x02000000) == 0)
				{
				  int offset = given & 0xfff;
				  if (offset)
				    func (stream, ", #%s%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				}
			      else
				{
				  func (stream, ", %s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""));
				  arm_decode_shift (given, func, stream);
				}

			      func (stream, "]%s",
				    ((given & 0x00200000) != 0) ? "!" : "");
			    }
			  else
			    {
			      if ((given & 0x02000000) == 0)
				{
				  int offset = given & 0xfff;
				  if (offset)
				    func (stream, "], #%s%d",
					  (((given & 0x00800000) == 0)
					   ? "-" : ""), offset);
				  else
				    func (stream, "]");
				}
			      else
				{
				  func (stream, "], %s",
					(((given & 0x00800000) == 0)
					 ? "-" : ""));
				  arm_decode_shift (given, func, stream);
				}
			    }
			}
d1951 13
d2343 24
d2713 39
@


1.59
log
@	* arm-dis.c (print_insn): Warning fix.
@
text
@d2610 1
d2612 5
a2616 1
		  info->print_address_func (pc + 4 + offset, info);
@


1.58
log
@2005-10-26  Paul Brook  <paul@@codesourcery.com>

gas/
	* config/tc-arm.c (insns): Correct "sel" entry.
gas/testsuite/
	* gas/arm/archv6.d: Adjust expected output.
opcodes/
	* arm-dis.c (arm_opcodes): Correct "sel" entry.
@
text
@d2857 5
a2863 5
	  if (little)
	    given = (b[0]) | (b[1] << 8);
	  else
	    given = (b[1]) | (b[0] << 8);

@


1.57
log
@2005-10-08  James Lemke  <jim@@wasabisystems.com>

	* arm-dis.c (coprocessor_opcodes): Fix mask for various Maverick CDP
	operations.
@
text
@d560 1
a560 1
  {ARM_EXT_V6, 0x068000b0, 0x0ff00ff0, "sel%c\t%12-15r, %16-19r, %0-3r"},
@


1.56
log
@2005-09-08  Paul Brook  <paul@@codesourcery.com>

bfd/
	* reloc.c: Rename BFD_RELOC_ARM_SMI to BFD_RELOC_ARM_SMC.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
opcodes/
	* arm-dis.c (arm_opcodes, thumb32_opcodes): Rename smi to smc.
gas/
	* config/tc-arm.c (do_smi, do_t_smi): Rename ...
	(do_smc, do_t_smc): ... to this.
	(insns): Remane smi to smc.
	(md_apply_fix, tc_gen_reloc): Rename BFD_RELOC_ARM_SMI to
	BFD_RELOC_ARM_SMC.
gas/testsuite/
	* gas/arm/arch6zk.d: Rename smi to smc.
	* gas/arm/arch6zk.s: Ditto.
	* gas/arm/thumb32.d: Ditto.
	* gas/arm/thumb32.s: Ditto.
@
text
@d332 2
a333 2
  {ARM_CEXT_MAVERICK, 0x0e000500, 0x0ff00f00, "cfsh32%c\tmvfx%12-15d, mvfx%16-19d, #%I"},
  {ARM_CEXT_MAVERICK, 0x0e200500, 0x0ff00f00, "cfsh64%c\tmvdx%12-15d, mvdx%16-19d, #%I"},
d360 4
a363 4
  {ARM_CEXT_MAVERICK, 0x0e000600, 0x0ff00f00, "cfmadd32%c\tmvax%5-7d, mvfx%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e100600, 0x0ff00f00, "cfmsub32%c\tmvax%5-7d, mvfx%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e200600, 0x0ff00f00, "cfmadda32%c\tmvax%5-7d, mvax%12-15d, mvfx%16-19d, mvfx%0-3d"},
  {ARM_CEXT_MAVERICK, 0x0e300600, 0x0ff00f00, "cfmsuba32%c\tmvax%5-7d, mvax%12-15d, mvfx%16-19d, mvfx%0-3d"},
@


1.55
log
@2005-09-02  Paul Brook  <paul@@codesourcery.com>

	* arm-dis.c (coprocessor_opcodes): Add null terminator.
@
text
@d443 1
a443 1
  {ARM_EXT_V6Z, 0x01600070, 0x0ff000f0, "smi%c\t%e"},
d971 1
a971 1
  {ARM_EXT_V6T2, 0xf7f08000, 0xfff0f000, "smi\t%K"},
@


1.54
log
@2005-09-02  Paul Brook  <paul@@codesourcery.com>

bfd/
	* libbdf.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* reloc.c: Add BFD_RELOC_ARM_T32_CP_OFF_IMM and
	BFD_RELOC_ARM_T32_CP_OFF_IMM_S2.
gas/
	* config/tc-arm.c (encode_arm_cp_address): Use
	BFD_RELOC_ARM_T32_CP_OFF_IMM in thumb mode.
	(do_iwmmxt_wldstbh): Use BFD_RELOC_ARM_T32_CP_OFF_IMM_S2 in thumb
	mode.
	(md_assemble): Only allow coprocessor instructions when Thumb-2 is
	available.
	(cCE, cC3): Define.
	(insns): Use them for coprocessor instructions.
	(md_pcrel_from_section): Handle BFD_RELOC_ARM_T32_CP_OFF_IMM.
	(get_thumb32_insn): New function.
	(put_thumb32_insn): New function.
	(md_apply_fix): Handle BFD_RELOC_ARM_T32_CP_OFF_IMM and
	BFD_RELOC_ARM_T32_CP_OFF_IMM_S2.
gas/testsuite/
	* gas/arm/vfp-bad_t2.d, gas/arm/vfp-bad_t2.l, arm/vfp-bad_t2.s,
	gas/arm/vfp1_t2.d, gas/arm/vfp1_t2.s, gas/arm/vfp1xD_t2.d,
	gas/arm/vfp1xD_t2.s, gas/arm/vfp2_t2.d, gas/arm/vfp2_t2.s): New files.
opcodes/
	* arm-dis.c (coprocessor_opcodes): New.
	(arm_opcodes, thumb32_opcodes): Remove coprocessor insns.
	(print_insn_coprocessor): New function.
	(print_insn_arm): Use print_insn_coprocessor.  Remove coprocessor
	format characters.
	(print_insn_thumb32): Use print_insn_coprocessor.
@
text
@d384 1
a384 1

@


1.53
log
@2005-08-30  Paul Brook  <paul@@codesourcery.com>

opcodes/
	* arm-dis.c (thumb_opcodes): Disassemble sub(3) as subs.
gas/testsuite/
	* gas/arm/thumb.d: Change "sub rn, rn, rn" to "subs rn, rn, rn".
	* gas/arm/thumb32.d: Ditto.
@
text
@d60 1
a60 5
/* Opcode tables: ARM, 16-bit Thumb, 32-bit Thumb.  All three are partially
   ordered: they must be searched linearly from the top to obtain a correct
   match.  */

/* print_insn_arm recognizes the following format control codes:
a63 3
   %a			print address for ldr/str instruction
   %s                   print address for ldr/str halfword/signextend instruction
   %b			print branch destination
a64 4
   %m			print register mask for ldm/stm instruction
   %o			print operand2 (immediate or register + shift)
   %p			print 'p' iff bits 12-15 are 15
   %t			print 't' iff bit 21 set and bit 24 clear
a65 1
   %B			print arm BLX(1) destination
a66 1
   %C			print the PSR sub type.
a73 1
   %<bitfield>W         print the bitfield plus one in decimal 
d92 2
a93 1
   %l			like 'A' except use byte offsets for 'B' & 'H' versions.
d95 1
a95 3
   %e                   print arm SMI operand (bits 0..7,8..19).
   %E			print the LSB and WIDTH fields of a BFI or BFC instruction.
   %V                   print the 16-bit immediate field of a MOVT or MOVW instruction.  */
d97 1
a97 1
static const struct opcode32 arm_opcodes[] =
a98 168
  /* ARM instructions.  */
  {ARM_EXT_V1, 0xe1a00000, 0xffffffff, "nop\t\t\t(mov r0,r0)"},
  {ARM_EXT_V4T | ARM_EXT_V5, 0x012FFF10, 0x0ffffff0, "bx%c\t%0-3r"},
  {ARM_EXT_V2, 0x00000090, 0x0fe000f0, "mul%c%20's\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V2, 0x00200090, 0x0fe000f0, "mla%c%20's\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V2S, 0x01000090, 0x0fb00ff0, "swp%c%22'b\t%12-15r, %0-3r, [%16-19r]"},
  {ARM_EXT_V3M, 0x00800090, 0x0fa000f0, "%22?sumull%c%20's\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V3M, 0x00a00090, 0x0fa000f0, "%22?sumlal%c%20's\t%12-15r, %16-19r, %0-3r, %8-11r"},

  /* ARM V6T2 instructions.  */
  {ARM_EXT_V6T2, 0x07c0001f, 0x0fe0007f, "bfc%c\t%12-15r, %E"},
  {ARM_EXT_V6T2, 0x07c00010, 0x0fe00070, "bfi%c\t%12-15r, %0-3r, %E"},
  {ARM_EXT_V6T2, 0x00600090, 0x0ff000f0, "mls%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6T2, 0x006000b0, 0x0f7000f0, "str%cht\t%12-15r, %s"},
  {ARM_EXT_V6T2, 0x00300090, 0x0f300090, "ldr%c%6's%5?hbt\t%12-15r, %s"},
  {ARM_EXT_V6T2, 0x03000000, 0x0ff00000, "movw%c\t%12-15r, %V"},
  {ARM_EXT_V6T2, 0x03400000, 0x0ff00000, "movt%c\t%12-15r, %V"},
  {ARM_EXT_V6T2, 0x03ff0f30, 0x0fff0ff0, "rbit%c\t%12-15r, %0-3r"},
  {ARM_EXT_V6T2, 0x07a00050, 0x0fa00070, "%22?usbfx%c\t%12-15r, %0-3r, #%7-11d, #%16-20W"},

  /* ARM V6Z instructions.  */
  {ARM_EXT_V6Z, 0x01600070, 0x0ff000f0, "smi%c\t%e"},

  /* ARM V6K instructions.  */
  {ARM_EXT_V6K, 0xf57ff01f, 0xffffffff, "clrex"},
  {ARM_EXT_V6K, 0x01d00f9f, 0x0ff00fff, "ldrexb%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6K, 0x01b00f9f, 0x0ff00fff, "ldrexd%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6K, 0x01f00f9f, 0x0ff00fff, "ldrexh%c\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6K, 0x01c00f90, 0x0ff00ff0, "strexb%c\t%12-15r, %0-3r, [%16-19r]"},
  {ARM_EXT_V6K, 0x01a00f90, 0x0ff00ff0, "strexd%c\t%12-15r, %0-3r, [%16-19r]"},
  {ARM_EXT_V6K, 0x01e00f90, 0x0ff00ff0, "strexh%c\t%12-15r, %0-3r, [%16-19r]"},

  /* ARM V6K NOP hints.  */
  {ARM_EXT_V6K, 0x0320f001, 0x0fffffff, "yield%c"},
  {ARM_EXT_V6K, 0x0320f002, 0x0fffffff, "wfe%c"},
  {ARM_EXT_V6K, 0x0320f003, 0x0fffffff, "wfi%c"},
  {ARM_EXT_V6K, 0x0320f004, 0x0fffffff, "sev%c"},
  {ARM_EXT_V6K, 0x0320f000, 0x0fffff00, "nop%c\t{%0-7d}"},

  /* ARM V6 instructions. */
  {ARM_EXT_V6, 0xfc500000, 0xfff00000, "mrrc2\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
  {ARM_EXT_V6, 0xfc400000, 0xfff00000, "mcrr2\t%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
  {ARM_EXT_V6, 0xf1080000, 0xfffdfe3f, "cpsie\t%8'a%7'i%6'f"},
  {ARM_EXT_V6, 0xf1080000, 0xfffdfe20, "cpsie\t%8'a%7'i%6'f,#%0-4d"},
  {ARM_EXT_V6, 0xf10C0000, 0xfffdfe3f, "cpsid\t%8'a%7'i%6'f"},
  {ARM_EXT_V6, 0xf10C0000, 0xfffdfe20, "cpsid\t%8'a%7'i%6'f,#%0-4d"},
  {ARM_EXT_V6, 0xf1000000, 0xfff1fe20, "cps\t#%0-4d"},
  {ARM_EXT_V6, 0x06800010, 0x0ff00ff0, "pkhbt%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06800010, 0x0ff00070, "pkhbt%c\t%12-15r, %16-19r, %0-3r, LSL #%7-11d"},
  {ARM_EXT_V6, 0x06800050, 0x0ff00ff0, "pkhtb%c\t%12-15r, %16-19r, %0-3r, ASR #32"},
  {ARM_EXT_V6, 0x06800050, 0x0ff00070, "pkhtb%c\t%12-15r, %16-19r, %0-3r, ASR #%7-11d"},
  {ARM_EXT_V6, 0x01900f9f, 0x0ff00fff, "ldrex%c\tr%12-15d, [%16-19r]"},
  {ARM_EXT_V6, 0x06200f10, 0x0ff00ff0, "qadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06200f90, 0x0ff00ff0, "qadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06200f30, 0x0ff00ff0, "qaddsubx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06200f70, 0x0ff00ff0, "qsub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06200ff0, 0x0ff00ff0, "qsub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06200f50, 0x0ff00ff0, "qsubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100f10, 0x0ff00ff0, "sadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100f90, 0x0ff00ff0, "sadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100f30, 0x0ff00ff0, "saddaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300f10, 0x0ff00ff0, "shadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300f90, 0x0ff00ff0, "shadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300f30, 0x0ff00ff0, "shaddsubx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300f70, 0x0ff00ff0, "shsub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300ff0, 0x0ff00ff0, "shsub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06300f50, 0x0ff00ff0, "shsubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100f70, 0x0ff00ff0, "ssub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100ff0, 0x0ff00ff0, "ssub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06100f50, 0x0ff00ff0, "ssubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500f10, 0x0ff00ff0, "uadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500f90, 0x0ff00ff0, "uadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500f30, 0x0ff00ff0, "uaddsubx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700f10, 0x0ff00ff0, "uhadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700f90, 0x0ff00ff0, "uhadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700f30, 0x0ff00ff0, "uhaddsubx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700f70, 0x0ff00ff0, "uhsub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700ff0, 0x0ff00ff0, "uhsub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06700f50, 0x0ff00ff0, "uhsubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600f10, 0x0ff00ff0, "uqadd16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600f90, 0x0ff00ff0, "uqadd8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600f30, 0x0ff00ff0, "uqaddsubx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600f70, 0x0ff00ff0, "uqsub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600ff0, 0x0ff00ff0, "uqsub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06600f50, 0x0ff00ff0, "uqsubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500f70, 0x0ff00ff0, "usub16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500ff0, 0x0ff00ff0, "usub8%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06500f50, 0x0ff00ff0, "usubaddx%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06bf0f30, 0x0fff0ff0, "rev%c\t\%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06bf0fb0, 0x0fff0ff0, "rev16%c\t\%12-15r, %0-3r"},
  {ARM_EXT_V6, 0x06ff0fb0, 0x0fff0ff0, "revsh%c\t\%12-15r, %0-3r"},
  {ARM_EXT_V6, 0xf8100a00, 0xfe50ffff, "rfe%23?id%24?ba\t\%16-19r%21'!"},
  {ARM_EXT_V6, 0x06bf0070, 0x0fff0ff0, "sxth%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x06bf0470, 0x0fff0ff0, "sxth%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06bf0870, 0x0fff0ff0, "sxth%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06bf0c70, 0x0fff0ff0, "sxth%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x068f0070, 0x0fff0ff0, "sxtb16%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x068f0470, 0x0fff0ff0, "sxtb16%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x068f0870, 0x0fff0ff0, "sxtb16%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x068f0c70, 0x0fff0ff0, "sxtb16%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06af0070, 0x0fff0ff0, "sxtb%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x06af0470, 0x0fff0ff0, "sxtb%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06af0870, 0x0fff0ff0, "sxtb%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06af0c70, 0x0fff0ff0, "sxtb%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06ff0070, 0x0fff0ff0, "uxth%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x06ff0470, 0x0fff0ff0, "uxth%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06ff0870, 0x0fff0ff0, "uxth%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06ff0c70, 0x0fff0ff0, "uxth%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06cf0070, 0x0fff0ff0, "uxtb16%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x06cf0470, 0x0fff0ff0, "uxtb16%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06cf0870, 0x0fff0ff0, "uxtb16%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06cf0c70, 0x0fff0ff0, "uxtb16%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06ef0070, 0x0fff0ff0, "uxtb%c %12-15r,%0-3r"},
  {ARM_EXT_V6, 0x06ef0470, 0x0fff0ff0, "uxtb%c %12-15r,%0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06ef0870, 0x0fff0ff0, "uxtb%c %12-15r,%0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06ef0c70, 0x0fff0ff0, "uxtb%c %12-15r,%0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06b00070, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06b00470, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06b00870, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06b00c70, 0x0ff00ff0, "sxtah%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06800070, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06800470, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06800870, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06800c70, 0x0ff00ff0, "sxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06a00070, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06a00470, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06a00870, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06a00c70, 0x0ff00ff0, "sxtab%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06f00070, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06f00470, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06f00870, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06f00c70, 0x0ff00ff0, "uxtah%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06c00070, 0x0ff00ff0, "uxtab16%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06c00470, 0x0ff00ff0, "uxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06c00870, 0x0ff00ff0, "uxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06c00c70, 0x0ff00ff0, "uxtab16%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
  {ARM_EXT_V6, 0x06e00070, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0x06e00470, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r, ROR #8"},
  {ARM_EXT_V6, 0x06e00870, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r, ROR #16"},
  {ARM_EXT_V6, 0x06e00c70, 0x0ff00ff0, "uxtab%c\t%12-15r, %16-19r, %0-3r, ROR #24"},
  {ARM_EXT_V6, 0x068000b0, 0x0ff00ff0, "sel%c\t%12-15r, %16-19r, %0-3r"},
  {ARM_EXT_V6, 0xf1010000, 0xfffffc00, "setend\t%9?ble"},
  {ARM_EXT_V6, 0x0700f010, 0x0ff0f0d0, "smuad%5'x%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x0700f050, 0x0ff0f0d0, "smusd%5'x%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07000010, 0x0ff000d0, "smlad%5'x%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x07400010, 0x0ff000d0, "smlald%5'x%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07000050, 0x0ff000d0, "smlsd%5'x%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x07400050, 0x0ff000d0, "smlsld%5'x%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x0750f010, 0x0ff0f0d0, "smmul%5'r%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07500010, 0x0ff000d0, "smmla%5'r%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x075000d0, 0x0ff000d0, "smmls%5'r%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0xf84d0500, 0xfe5fffe0, "srs%23?id%24?ba\t#%0-4d%21'!"},
  {ARM_EXT_V6, 0x06a00010, 0x0fe00ff0, "ssat%c\t%12-15r, #%16-20W, %0-3r"},
  {ARM_EXT_V6, 0x06a00010, 0x0fe00070, "ssat%c\t%12-15r, #%16-20W, %0-3r, LSL #%7-11d"},
  {ARM_EXT_V6, 0x06a00050, 0x0fe00070, "ssat%c\t%12-15r, #%16-20W, %0-3r, ASR #%7-11d"},
  {ARM_EXT_V6, 0x06a00f30, 0x0ff00ff0, "ssat16%c\t%12-15r, #%16-19W, %0-3r"},
  {ARM_EXT_V6, 0x01800f90, 0x0ff00ff0, "strex%c\t%12-15r, %0-3r, [%16-19r]"},
  {ARM_EXT_V6, 0x00400090, 0x0ff000f0, "umaal%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x0780f010, 0x0ff0f0f0, "usad8%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V6, 0x07800010, 0x0ff000f0, "usada8%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6, 0x06e00010, 0x0fe00ff0, "usat%c\t%12-15r, #%16-20d, %0-3r"},
  {ARM_EXT_V6, 0x06e00010, 0x0fe00070, "usat%c\t%12-15r, #%16-20d, %0-3r, LSL #%7-11d"},
  {ARM_EXT_V6, 0x06e00050, 0x0fe00070, "usat%c\t%12-15r, #%16-20d, %0-3r, ASR #%7-11d"},
  {ARM_EXT_V6, 0x06e00f30, 0x0ff00ff0, "usat16%c\t%12-15r, #%16-19d, %0-3r"},

  /* V5J instruction.  */
  {ARM_EXT_V5J, 0x012fff20, 0x0ffffff0, "bxj%c\t%0-3r"},

d159 44
a202 10
  /* V5 Instructions.  */
  {ARM_EXT_V5, 0xe1200070, 0xfff000f0, "bkpt\t0x%16-19X%12-15X%8-11X%0-3X"},
  {ARM_EXT_V5, 0xfa000000, 0xfe000000, "blx\t%B"},
  {ARM_EXT_V5, 0x012fff30, 0x0ffffff0, "blx%c\t%0-3r"},
  {ARM_EXT_V5, 0x016f0f10, 0x0fff0ff0, "clz%c\t%12-15r, %0-3r"},
  {ARM_EXT_V5, 0xfc100000, 0xfe100000, "ldc2%22'l\t%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V5, 0xfc000000, 0xfe100000, "stc2%22'l\t%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V5, 0xfe000000, 0xff000010, "cdp2\t%8-11d, %20-23d, cr%12-15d, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V5, 0xfe000010, 0xff100010, "mcr2\t%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, {%5-7d}"},
  {ARM_EXT_V5, 0xfe100010, 0xff100010, "mrc2\t%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, {%5-7d}"},
d204 15
a218 121
  /* V5E "El Segundo" Instructions.  */    
  {ARM_EXT_V5E, 0x000000d0, 0x0e1000f0, "ldr%cd\t%12-15r, %s"},
  {ARM_EXT_V5E, 0x000000f0, 0x0e1000f0, "str%cd\t%12-15r, %s"},
  {ARM_EXT_V5E, 0xf450f000, 0xfc70f000, "pld\t%a"},
  {ARM_EXT_V5ExP, 0x01000080, 0x0ff000f0, "smlabb%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x010000a0, 0x0ff000f0, "smlatb%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x010000c0, 0x0ff000f0, "smlabt%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x010000e0, 0x0ff000f0, "smlatt%c\t%16-19r, %0-3r, %8-11r, %12-15r"},

  {ARM_EXT_V5ExP, 0x01200080, 0x0ff000f0, "smlawb%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V5ExP, 0x012000c0, 0x0ff000f0, "smlawt%c\t%16-19r, %0-3r, %8-11r, %12-15r"},

  {ARM_EXT_V5ExP, 0x01400080, 0x0ff000f0, "smlalbb%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x014000a0, 0x0ff000f0, "smlaltb%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x014000c0, 0x0ff000f0, "smlalbt%c\t%12-15r, %16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x014000e0, 0x0ff000f0, "smlaltt%c\t%12-15r, %16-19r, %0-3r, %8-11r"},

  {ARM_EXT_V5ExP, 0x01600080, 0x0ff0f0f0, "smulbb%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x016000a0, 0x0ff0f0f0, "smultb%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x016000c0, 0x0ff0f0f0, "smulbt%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x016000e0, 0x0ff0f0f0, "smultt%c\t%16-19r, %0-3r, %8-11r"},

  {ARM_EXT_V5ExP, 0x012000a0, 0x0ff0f0f0, "smulwb%c\t%16-19r, %0-3r, %8-11r"},
  {ARM_EXT_V5ExP, 0x012000e0, 0x0ff0f0f0, "smulwt%c\t%16-19r, %0-3r, %8-11r"},

  {ARM_EXT_V5ExP, 0x01000050, 0x0ff00ff0,  "qadd%c\t%12-15r, %0-3r, %16-19r"},
  {ARM_EXT_V5ExP, 0x01400050, 0x0ff00ff0, "qdadd%c\t%12-15r, %0-3r, %16-19r"},
  {ARM_EXT_V5ExP, 0x01200050, 0x0ff00ff0,  "qsub%c\t%12-15r, %0-3r, %16-19r"},
  {ARM_EXT_V5ExP, 0x01600050, 0x0ff00ff0, "qdsub%c\t%12-15r, %0-3r, %16-19r"},

  /* ARM Instructions.  */
  {ARM_EXT_V1, 0x00000090, 0x0e100090, "str%c%6's%5?hb\t%12-15r, %s"},
  {ARM_EXT_V1, 0x00100090, 0x0e100090, "ldr%c%6's%5?hb\t%12-15r, %s"},
  {ARM_EXT_V1, 0x00000000, 0x0de00000, "and%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00200000, 0x0de00000, "eor%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00400000, 0x0de00000, "sub%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00600000, 0x0de00000, "rsb%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00800000, 0x0de00000, "add%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00a00000, 0x0de00000, "adc%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00c00000, 0x0de00000, "sbc%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x00e00000, 0x0de00000, "rsc%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V3, 0x0120f000, 0x0db0f000, "msr%c\t%22?SCPSR%C, %o"},
  {ARM_EXT_V3, 0x010f0000, 0x0fbf0fff, "mrs%c\t%12-15r, %22?SCPSR"},
  {ARM_EXT_V1, 0x01000000, 0x0de00000, "tst%c%p\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01200000, 0x0de00000, "teq%c%p\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01400000, 0x0de00000, "cmp%c%p\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01600000, 0x0de00000, "cmn%c%p\t%16-19r, %o"},
  {ARM_EXT_V1, 0x01800000, 0x0de00000, "orr%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x01a00000, 0x0de00000, "mov%c%20's\t%12-15r, %o"},
  {ARM_EXT_V1, 0x01c00000, 0x0de00000, "bic%c%20's\t%12-15r, %16-19r, %o"},
  {ARM_EXT_V1, 0x01e00000, 0x0de00000, "mvn%c%20's\t%12-15r, %o"},
  {ARM_EXT_V1, 0x04000000, 0x0e100000, "str%c%22'b%t\t%12-15r, %a"},
  {ARM_EXT_V1, 0x06000000, 0x0e100ff0, "str%c%22'b%t\t%12-15r, %a"},
  {ARM_EXT_V1, 0x04000000, 0x0c100010, "str%c%22'b%t\t%12-15r, %a"},
  {ARM_EXT_V1, 0x06000010, 0x0e000010, "undefined"},
  {ARM_EXT_V1, 0x04100000, 0x0c100000, "ldr%c%22'b%t\t%12-15r, %a"},
  {ARM_EXT_V1, 0x08000000, 0x0e100000, "stm%c%23?id%24?ba\t%16-19r%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x08100000, 0x0e100000, "ldm%c%23?id%24?ba\t%16-19r%21'!, %m%22'^"},
  {ARM_EXT_V1, 0x0a000000, 0x0e000000, "b%24'l%c\t%b"},
  {ARM_EXT_V1, 0x0f000000, 0x0f000000, "swi%c\t%0-23x"},

  /* Floating point coprocessor (FPA) instructions */
  {FPU_FPA_EXT_V1, 0x0e000100, 0x0ff08f10, "adf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e100100, 0x0ff08f10, "muf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e200100, 0x0ff08f10, "suf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e300100, 0x0ff08f10, "rsf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e400100, 0x0ff08f10, "dvf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e500100, 0x0ff08f10, "rdf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e600100, 0x0ff08f10, "pow%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e700100, 0x0ff08f10, "rpw%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e800100, 0x0ff08f10, "rmf%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e900100, 0x0ff08f10, "fml%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ea00100, 0x0ff08f10, "fdv%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0eb00100, 0x0ff08f10, "frd%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ec00100, 0x0ff08f10, "pol%c%P%R\t%12-14f, %16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e008100, 0x0ff08f10, "mvf%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e108100, 0x0ff08f10, "mnf%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e208100, 0x0ff08f10, "abs%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e308100, 0x0ff08f10, "rnd%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e408100, 0x0ff08f10, "sqt%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e508100, 0x0ff08f10, "log%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e608100, 0x0ff08f10, "lgn%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e708100, 0x0ff08f10, "exp%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e808100, 0x0ff08f10, "sin%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e908100, 0x0ff08f10, "cos%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ea08100, 0x0ff08f10, "tan%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0eb08100, 0x0ff08f10, "asn%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ec08100, 0x0ff08f10, "acs%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ed08100, 0x0ff08f10, "atn%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ee08100, 0x0ff08f10, "urd%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ef08100, 0x0ff08f10, "nrm%c%P%R\t%12-14f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0e000110, 0x0ff00f1f, "flt%c%P%R\t%16-18f, %12-15r"},
  {FPU_FPA_EXT_V1, 0x0e100110, 0x0fff0f98, "fix%c%R\t%12-15r, %0-2f"},
  {FPU_FPA_EXT_V1, 0x0e200110, 0x0fff0fff, "wfs%c\t%12-15r"},
  {FPU_FPA_EXT_V1, 0x0e300110, 0x0fff0fff, "rfs%c\t%12-15r"},
  {FPU_FPA_EXT_V1, 0x0e400110, 0x0fff0fff, "wfc%c\t%12-15r"},
  {FPU_FPA_EXT_V1, 0x0e500110, 0x0fff0fff, "rfc%c\t%12-15r"},
  {FPU_FPA_EXT_V1, 0x0e90f110, 0x0ff8fff0, "cmf%c\t%16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0eb0f110, 0x0ff8fff0, "cnf%c\t%16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ed0f110, 0x0ff8fff0, "cmfe%c\t%16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0ef0f110, 0x0ff8fff0, "cnfe%c\t%16-18f, %0-3f"},
  {FPU_FPA_EXT_V1, 0x0c000100, 0x0e100f00, "stf%c%Q\t%12-14f, %A"},
  {FPU_FPA_EXT_V1, 0x0c100100, 0x0e100f00, "ldf%c%Q\t%12-14f, %A"},
  {FPU_FPA_EXT_V2, 0x0c000200, 0x0e100f00, "sfm%c\t%12-14f, %F, %A"},
  {FPU_FPA_EXT_V2, 0x0c100200, 0x0e100f00, "lfm%c\t%12-14f, %F, %A"},

  /* Floating point coprocessor (VFP) instructions */
  {FPU_VFP_EXT_V1, 0x0eb00bc0, 0x0fff0ff0, "fabsd%c\t%1z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0eb00ac0, 0x0fbf0fd0, "fabss%c\t%1y, %0y"},
  {FPU_VFP_EXT_V1, 0x0e300b00, 0x0ff00ff0, "faddd%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e300a00, 0x0fb00f50, "fadds%c\t%1y, %2y, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb40b40, 0x0fff0f70, "fcmp%7'ed%c\t%1z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0eb40a40, 0x0fbf0f50, "fcmp%7'es%c\t%1y, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb50b40, 0x0fff0f70, "fcmp%7'ezd%c\t%1z"},
  {FPU_VFP_EXT_V1xD, 0x0eb50a40, 0x0fbf0f70, "fcmp%7'ezs%c\t%1y"},
  {FPU_VFP_EXT_V1, 0x0eb00b40, 0x0fff0ff0, "fcpyd%c\t%1z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0eb00a40, 0x0fbf0fd0, "fcpys%c\t%1y, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb70ac0, 0x0fff0fd0, "fcvtds%c\t%1z, %0y"},
  {FPU_VFP_EXT_V1, 0x0eb70bc0, 0x0fbf0ff0, "fcvtsd%c\t%1y, %0z"},
  {FPU_VFP_EXT_V1, 0x0e800b00, 0x0ff00ff0, "fdivd%c\t%1z, %2z, %0z"},
  {FPU_VFP_EXT_V1xD, 0x0e800a00, 0x0fb00f50, "fdivs%c\t%1y, %2y, %0y"},
d374 11
a384 3
  /* The rest.  */
  {ARM_EXT_V1, 0x00000000, 0x00000000, "undefined instruction %0-31x"},
  {0, 0x00000000, 0x00000000, 0}
d387 24
a410 1
/* print_insn_thumb16 recognizes the following format control codes:
a411 16
   %S                   print Thumb register (bits 3..5 as high number if bit 6 set)
   %D                   print Thumb register (bits 0..2 as high number if bit 7 set)
   %<bitfield>I         print bitfield as a signed decimal
   				(top bit of range being the sign bit)
   %N                   print Thumb register mask (with LR)
   %O                   print Thumb register mask (with PC)
   %M                   print Thumb register mask
   %b			print CZB's 6-bit unsigned branch destination
   %s			print Thumb right-shift immediate (6..10; 0 == 32).
   %<bitfield>r		print bitfield as an ARM register
   %<bitfield>d		print bitfield as a decimal
   %<bitfield>H         print (bitfield * 2) as a decimal
   %<bitfield>W         print (bitfield * 4) as a decimal
   %<bitfield>a         print (bitfield * 4) as a pc-rel offset + decoded symbol
   %<bitfield>B         print Thumb branch destination (signed displacement)
   %<bitfield>c         print bitfield as a condition code
d413 6
a418 1
   %<bitnum>?ab		print a if bit is one else print b.  */
d420 1
a420 1
static const struct opcode16 thumb_opcodes[] =
d422 19
a440 1
  /* Thumb instructions.  */
d442 2
a443 7
  /* ARM V6K no-argument instructions.  */
  {ARM_EXT_V6K, 0xbf00, 0xffff, "nop"},
  {ARM_EXT_V6K, 0xbf10, 0xffff, "yield"},
  {ARM_EXT_V6K, 0xbf20, 0xffff, "wfe"},
  {ARM_EXT_V6K, 0xbf30, 0xffff, "wfi"},
  {ARM_EXT_V6K, 0xbf40, 0xffff, "sev"},
  {ARM_EXT_V6K, 0xbf00, 0xff0f, "nop\t{%4-7d}"},
d445 8
a452 10
  /* ARM V6T2 instructions.  */
  {ARM_EXT_V6T2, 0xb900, 0xfd00, "cbnz\t%0-2r, %b"},
  {ARM_EXT_V6T2, 0xb100, 0xfd00, "cbz\t%0-2r, %b"},
  {ARM_EXT_V6T2, 0xbf08, 0xff0f, "it\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf14, 0xff17, "it%3?te\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf04, 0xff17, "it%3?et\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf12, 0xff13, "it%3?te%2?te\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf02, 0xff13, "it%3?et%2?et\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf11, 0xff11, "it%3?te%2?te%1?te\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf01, 0xff11, "it%3?et%2?et%1?et\t%4-7c"},
d454 262
a715 12
  /* ARM V6.  */
  {ARM_EXT_V6, 0xb660, 0xfff8, "cpsie\t%2'a%1'i%0'f"},
  {ARM_EXT_V6, 0xb670, 0xfff8, "cpsid\t%2'a%1'i%0'f"},
  {ARM_EXT_V6, 0x4600, 0xffc0, "mov\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xba00, 0xffc0, "rev\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xba40, 0xffc0, "rev16\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xbac0, 0xffc0, "revsh\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb650, 0xfff7, "setend\t%3?ble"},
  {ARM_EXT_V6, 0xb200, 0xffc0, "sxth\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb240, 0xffc0, "sxtb\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb280, 0xffc0, "uxth\t%0-2r, %3-5r"},
  {ARM_EXT_V6, 0xb2c0, 0xffc0, "uxtb\t%0-2r, %3-5r"},
a820 1
       %A		print the address of a coprocessor load/store
a992 2
  {ARM_EXT_V6T2, 0xee000010, 0xef1000f0, "mcr%28'2\tp%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d"},
  {ARM_EXT_V6T2, 0xee100010, 0xef1000f0, "mrc%28'2\tp%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d"},
a1007 3
  {ARM_EXT_V6T2, 0xee000000, 0xef0000f0, "cdp%28'2\tp%8-11d, %20-23d, cr%12-15d, cr%16-19d, cr%0-3d"},
  {ARM_EXT_V6T2, 0xec400000, 0xeff00000, "mcrr%28'2\tp%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
  {ARM_EXT_V6T2, 0xec500000, 0xeff00000, "mrrc%28'2\tp%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
d1018 442
a1459 15
  {ARM_EXT_V6T2, 0xe8800000, 0xffd00000, "stmia.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe8900000, 0xffd00000, "ldmia.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9000000, 0xffd00000, "stmdb\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9100000, 0xffd00000, "ldmdb\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9c00000, 0xffd000ff, "strd\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9d00000, 0xffd000ff, "ldrd\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9400000, 0xff500000, "strd\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]"},
  {ARM_EXT_V6T2, 0xe9500000, 0xff500000, "ldrd\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]"},
  {ARM_EXT_V6T2, 0xee000010, 0xef100010, "mcr%28'2\tp%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, %5-7d"},
  {ARM_EXT_V6T2, 0xee100010, 0xef100010, "mrc%28'2\tp%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, %5-7d"},
  {ARM_EXT_V6T2, 0xf8000000, 0xff100000, "str%w.w\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf8100000, 0xfe100000, "ldr%w.w\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xec000000, 0xee100000, "stc%28'2%22'l\tp%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V6T2, 0xec100000, 0xee100000, "ldc%28'2%22'l\tp%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V6T2, 0xee000000, 0xef000010, "cdp%28'2\tp%8-11d, %20-23d, cr%12-15d, cr%16-19d, cr%0-3d, %5-7d"},
d1461 8
a1468 5
  /* Filter out Bcc with cond=E or F, which are used for other instructions.  */
  {ARM_EXT_V6T2, 0xf3c08000, 0xfbc0d000, "undefined (bcc, cond=0xF)"},
  {ARM_EXT_V6T2, 0xf3808000, 0xfbc0d000, "undefined (bcc, cond=0xE)"},
  {ARM_EXT_V6T2, 0xf0008000, 0xf800d000, "b%22-25c.w\t%b"},
  {ARM_EXT_V6T2, 0xf0009000, 0xf800d000, "b.w\t%B"},
d1470 8
a1477 3
  /* These have been 32-bit since the invention of Thumb.  */
  {ARM_EXT_V4T,  0xf000c000, 0xf800d000, "blx\t%B"},
  {ARM_EXT_V4T,  0xf000d000, 0xf800d000, "bl\t%B"},
d1479 9
a1487 8
  /* Fallback.  */
  {ARM_EXT_V1,   0x00000000, 0x00000000, "undefined"},
  {0, 0, 0, 0}
};
   
static const char *const arm_conditional[] =
{"eq", "ne", "cs", "cc", "mi", "pl", "vs", "vc",
 "hi", "ls", "ge", "lt", "gt", "le", "", "<und>"};
a1488 2
static const char *const arm_fp_const[] =
{"0.0", "1.0", "2.0", "3.0", "4.0", "5.0", "0.5", "10.0"};
d1490 3
a1492 2
static const char *const arm_shift[] =
{"lsl", "lsr", "asr", "ror"};
d1494 1
a1494 7
typedef struct
{
  const char *name;
  const char *description;
  const char *reg_names[16];
}
arm_regname;
d1496 3
a1498 15
static const arm_regname regnames[] =
{
  { "raw" , "Select raw register names",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}},
  { "gcc",  "Select register names used by GCC",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "std",  "Select register names used in ARM's ISA documentation",
    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "sp",  "lr",  "pc" }},
  { "apcs", "Select register names used in the APCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},
  { "atpcs", "Select register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "v7",  "v8",  "IP",  "SP",  "LR",  "PC" }},
  { "special-atpcs", "Select special register names used in the ATPCS",
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},
};
d1500 2
a1501 2
static const char *const iwmmxt_wwnames[] =
{"b", "h", "w", "d"};
d1503 6
a1508 6
static const char *const iwmmxt_wwssnames[] =
{"b", "bus", "b", "bss",
 "h", "hus", "h", "hss",
 "w", "wus", "w", "wss",
 "d", "dus", "d", "dss"
};
d1510 5
a1514 4
static const char *const iwmmxt_regnames[] =
{ "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7",
  "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"
};
d1516 2
a1517 4
static const char *const iwmmxt_cregnames[] =
{ "wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved",
  "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"
};
d1519 1
a1519 2
/* Default to GCC register name set.  */
static unsigned int regname_selected = 1;
d1521 21
a1541 2
#define NUM_ARM_REGNAMES  NUM_ELEM (regnames)
#define arm_regnames      regnames[regname_selected].reg_names
d1543 11
a1553 1
static bfd_boolean force_thumb = FALSE;
d1555 8
a1562 7

/* Functions.  */
int
get_arm_regname_num_options (void)
{
  return NUM_ARM_REGNAMES;
}
d1564 7
a1570 7
int
set_arm_regname_option (int option)
{
  int old = regname_selected;
  regname_selected = option;
  return old;
}
d1572 1
a1572 9
int
get_arm_regnames (int option, const char **setname, const char **setdescription,
		  const char *const **register_names)
{
  *setname = regnames[option].name;
  *setdescription = regnames[option].description;
  *register_names = regnames[option].reg_names;
  return 16;
}
d1574 16
a1589 4
static void
arm_decode_shift (long given, fprintf_ftype func, void *stream)
{
  func (stream, "%s", arm_regnames[given & 0xf]);
d1591 4
a1594 13
  if ((given & 0xff0) != 0)
    {
      if ((given & 0x10) == 0)
	{
	  int amount = (given & 0xf80) >> 7;
	  int shift = (given & 0x60) >> 5;

	  if (amount == 0)
	    {
	      if (shift == 3)
		{
		  func (stream, ", rrx");
		  return;
d1596 2
a1597 2

	      amount = 32;
d1599 1
a1599 2

	  func (stream, ", %s #%d", arm_shift[shift], amount);
a1600 3
      else
	func (stream, ", %s %s", arm_shift[(given & 0x60) >> 5],
	      arm_regnames[(given & 0xf00) >> 8]);
d1602 1
d1614 3
d1900 1
a1900 19
		        info->print_address_func (address, info);
		      }
		      break;

		    case 'I':
		      /* Print a Cirrus/DSP shift immediate.  */
		      /* Immediates are 7bit signed ints with bits 0..3 in
			 bits 0..3 of opcode and bits 4..6 in bits 5..7
			 of opcode.  */
		      {
			int imm;

			imm = (given & 0xf) | ((given & 0xe0) >> 1);

			/* Is ``imm'' a negative number?  */
			if (imm & 0x40)
			  imm |= (-1 << 7);

			func (stream, "%d", imm);
a1901 1

a1915 68
		    case 'F':
		      switch (given & 0x00408000)
			{
			case 0:
			  func (stream, "4");
			  break;
			case 0x8000:
			  func (stream, "1");
			  break;
			case 0x00400000:
			  func (stream, "2");
			  break;
			default:
			  func (stream, "3");
			}
		      break;

		    case 'P':
		      switch (given & 0x00080080)
			{
			case 0:
			  func (stream, "s");
			  break;
			case 0x80:
			  func (stream, "d");
			  break;
			case 0x00080000:
			  func (stream, "e");
			  break;
			default:
			  func (stream, _("<illegal precision>"));
			  break;
			}
		      break;
		    case 'Q':
		      switch (given & 0x00408000)
			{
			case 0:
			  func (stream, "s");
			  break;
			case 0x8000:
			  func (stream, "d");
			  break;
			case 0x00400000:
			  func (stream, "e");
			  break;
			default:
			  func (stream, "p");
			  break;
			}
		      break;
		    case 'R':
		      switch (given & 0x60)
			{
			case 0:
			  break;
			case 0x20:
			  func (stream, "p");
			  break;
			case 0x40:
			  func (stream, "m");
			  break;
			default:
			  func (stream, "z");
			  break;
			}
		      break;

a1993 55
			      case 'f':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

				  if (reg > 7)
				    func (stream, "#%s",
					  arm_fp_const[reg & 7]);
				  else
				    func (stream, "f%ld", reg);
				}
				break;

			      case 'w':
				{
				  long reg;

				  if (bitstart != bitend)
				    {
				      reg = given >> bitstart;
				      reg &= (2 << (bitend - bitstart)) - 1;
				      if (bitend - bitstart == 1)
					func (stream, "%s", iwmmxt_wwnames[reg]);
				      else
					func (stream, "%s", iwmmxt_wwssnames[reg]);
				    }
				  else
				    {
				      reg = (((given >> 8)  & 0x1) |
					     ((given >> 22) & 0x1));
				      func (stream, "%s", iwmmxt_wwnames[reg]);
				    }
				}
				break;

			      case 'g':
				{
				  long reg;
				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", iwmmxt_regnames[reg]);
				}
				break;

			      case 'G':
				{
				  long reg;
				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", iwmmxt_cregnames[reg]);
				}
				break;

a1998 78
			  case 'y':
			  case 'z':
			    {
			      int single = *c == 'y';
			      int regno;

			      switch (bitstart)
				{
				case 4: /* Sm pair */
				  func (stream, "{");
				  /* Fall through.  */
				case 0: /* Sm, Dm */
				  regno = given & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 5) & 1;
				    }
				  break;

				case 1: /* Sd, Dd */
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;

				case 2: /* Sn, Dn */
				  regno = (given >> 16) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 7) & 1;
				    }
				  break;

				case 3: /* List */
				  func (stream, "{");
				  regno = (given >> 12) & 0x0000000f;
				  if (single)
				    {
				      regno <<= 1;
				      regno += (given >> 22) & 1;
				    }
				  break;


				default:
				  abort ();
				}

			      func (stream, "%c%d", single ? 's' : 'd', regno);

			      if (bitstart == 3)
				{
				  int count = given & 0xff;

				  if (single == 0)
				    count >>= 1;

				  if (--count)
				    {
				      func (stream, "-%c%d",
					    single ? 's' : 'd',
					    regno + count);
				    }

				  func (stream, "}");
				}
			      else if (bitstart == 4)
				func (stream, ", %c%d}", single ? 's' : 'd',
				      regno + 1);

			      break;
			    }

a2020 48
		      case 'L':
			switch (given & 0x00400100)
			  {
			  case 0x00000000: func (stream, "b"); break;
			  case 0x00400000: func (stream, "h"); break;
			  case 0x00000100: func (stream, "w"); break;
			  case 0x00400100: func (stream, "d"); break;
			  default:
			    break;
			  }
			break;

		      case 'Z':
			{
			  int value;
			  /* given (20, 23) | given (0, 3) */
			  value = ((given >> 16) & 0xf0) | (given & 0xf);
			  func (stream, "%d", value);
			}
			break;

		      case 'l':
			/* This is like the 'A' operator, except that if
			   the width field "M" is zero, then the offset is
			   *not* multiplied by four.  */
			{
			  int offset = given & 0xff;
			  int multiplier = (given & 0x00000100) ? 4 : 1;

			  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

			  if (offset)
			    {
			      if ((given & 0x01000000) != 0)
				func (stream, ", #%s%d]%s",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier,
				      ((given & 0x00200000) != 0 ? "!" : ""));
			      else
				func (stream, "], #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier);
			    }
			  else
			    func (stream, "]");
			}
			break;

d2304 3
@


1.52
log
@2005-07-29  Paul Brook  <paul@@codesourcery.com>

bfd/
	* reloc.c: Add BFD_RELOC_ARM_T32_ADD_PC12.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* config/tc-arm.c (T16_32_TAB): Add "addr". Fix encoding of push and
	pop.
	(do_t_addr): Implement 32-bit variant.
	(do_t_push_pop): Make some errors warnings.  Handle single register
	32-bit case.
	(insns): Use tCE for adr.
	(md_pcrel_from_section): Handle BFD_RELOC_ARM_T32_ADD_PC12.
	(md_apply_fix): Ditto.
gas/testsuite/
	* gas/arm/thumb32.d: Fix expected output for writeback addressing
	modes.  Add single high reg push/pop test.
	* gas/asm/thumb32.s: Add single high reg push/pop test.
opcodes/
	* arm-dis.c: Fix disassebly of thumb2 writeback addressing modes.
@
text
@d727 1
a727 1
  {ARM_EXT_V4T, 0x1A00, 0xFE00, "sub\t%0-2r, %3-5r, %6-8r"},
d729 1
a729 1
  {ARM_EXT_V4T, 0x1E00, 0xFE00, "sub\t%0-2r, %3-5r, #%6-8d"},
@


1.51
log
@2005-07-29  Paul Brook  <paul@@codesourcery.com>

bfd/
	* reloc.c (BFD_RELOC_ARM_T32_IMM12): Add.
	* bfd-in2.h: Regeenrate.
	* libbfd.h: Regenerate.
gas/
	* config/tc-arm.c (parse_tb): New function.
	(enum operand_parse_code): Add OP_TB.
	(parse_operands): Handle OP_TB.
	(do_t_add_sub_w, do_t_tb): New functions.
	(insns): Add entries for addw, subw, tbb and tbh.
	(md_apply_fix): Handle BFD_RELOC_ARM_T32_IMM12.
gas/testsuite/
	* gas/arm/thumb32.s: Add tests for addw, subw, tbb and tbh.
	* gas/arm/thumb32.d: Ditto.
opcodes/
	* arm-dis.c (thumb32_opc): Fix addressing mode for tbh.
	(print_insn_thumb32): Fix decoding of thumb2 'I' operands.
@
text
@d2256 1
a2256 1
		    case 0xB:  /* 8-bit + preindex with wb */
d2261 1
a2261 1
		    case 0x9:  /* 8-bit - preindex with wb */
d2266 1
a2266 1
		    case 0xF:  /* 8-bit + postindex */
d2271 1
a2271 1
		    case 0xD:  /* 8-bit - postindex */
@


1.50
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d842 1
a842 1
  {ARM_EXT_V6T2, 0xe8d0f010, 0xfff0fff0, "tbh\t[%16-19r, %0-3r]"},
d2135 1
a2135 1
		  imm12 |= (given & 0x04000000u) >> 12;
@


1.49
log
@arm-dis.c (opcode32 arm_opcodes): Fix ARM VFP fadds instruction disassembly
  pattern.
vfp1xD.d: Adjust expected fadds disassemblies now that the dissassembler has
  been fixed.
@
text
@d1581 1
a1581 1
				  func (stream, "%d", reg);
d1591 1
a1591 1
				  func (stream, "%d", reg + 1);
d1601 1
a1601 1
				  func (stream, "0x%08x", reg);
d1618 1
a1618 1
				  func (stream, "%01x", reg & 0xf);
d1632 1
a1632 1
				    func (stream, "f%d", reg);
d1994 1
a1994 1
		  func (stream, "#%d", imm);
d2027 1
a2027 1
			    func (stream, "%d", reg);
d2031 1
a2031 1
			    func (stream, "%d", reg << 1);
d2035 1
a2035 1
			    func (stream, "%d", reg << 2);
d2047 1
a2047 1
			    func (stream, "0x%04x", reg);
@


1.48
log
@opcodes:
	* arm-opc.h: Delete; fold contents into ...
	* arm-dis.c: ... here.  Move includes of internal COFF headers
	next to includes of internal ELF headers.
	(streq, WORD_ADDRESS, BDISP, BDISP23): Delete, unused.
	(struct arm_opcode): Rename struct opcode32.  Make 'assembler' const.
	(struct thumb_opcode): Rename struct opcode16.  Make 'assembler' const.
	(arm_conditional, arm_fp_const, arm_shift, arm_regname, regnames)
	(iwmmxt_wwnames, iwmmxt_wwssnames):
	Make const.
	(regnames): Remove iWMMXt coprocessor register sets.
	(iwmmxt_regnames, iwmmxt_cregnames): New statics.
	(get_arm_regnames): Adjust fourth argument to match above changes.
	(set_iwmmxt_regnames): Delete.
	(print_insn_arm): Constify 'c'.  Use ISO syntax for function
	pointer calls.  Expand sole use of BDISP.  Use iwmmxt_regnames
	and iwmmxt_cregnames, not set_iwmmxt_regnames.
	(print_insn_thumb16, print_insn_thumb32): Constify 'c'.  Use
	ISO syntax for function pointer calls.
include:
	* dis-asm.h (get_arm_regnames): Update prototype.
@
text
@d463 1
a463 1
  {FPU_VFP_EXT_V1xD, 0x0e300a00, 0x0fb00f50, "fadds%c\t%1y, %2y, %1y"},
@


1.47
log
@	* arm-dis.c: Split up the comments describing the format codes, so
	that the ARM and 16-bit Thumb opcode tables each have comments
	preceding them that describe all the codes, and only the codes,
	valid in those tables.  (32-bit Thumb table is already like this.)
	Reorder the lists in all three comments to match the order in
	which the codes are implemented.
	Remove all forward declarations of static functions.  Convert all
	function definitions to ISO C format.
	(print_insn_arm, print_insn_thumb16, print_insn_thumb32):
	Return nothing.
	(print_insn_thumb16): Remove unused case 'I'.
	(print_insn): Update for changed calling convention of subroutines.
@
text
@a26 3
#include "arm-opc.h"
#include "coff/internal.h"
#include "libcoff.h"
d31 2
d37 1
a37 4
#ifndef streq
#define streq(a,b)	(strcmp ((a), (b)) == 0)
#endif

d46 13
a58 1
#define WORD_ADDRESS(pc) ((pc) & ~0x3)
d112 1
a112 1
static const struct arm_opcode arm_opcodes[] =
d655 1
a655 1
static const struct thumb_opcode thumb_opcodes[] =
d823 1
a823 1
static const struct arm_opcode thumb32_opcodes[] =
d1029 1
a1029 2

static char * arm_conditional[] =
d1033 6
d1041 3
a1043 3
  const char * name;
  const char * description;
  const char * reg_names[16];
d1047 1
a1047 1
static arm_regname regnames[] =
a1060 4
  { "iwmmxt_regnames", "Select register names used on the Intel Wireless MMX technology coprocessor",
    { "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7", "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"}},
  { "iwmmxt_Cregnames", "Select control register names used on the Intel Wireless MMX technology coprocessor",
    {"wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved", "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"}}
d1063 1
a1063 1
static char * iwmmxt_wwnames[] =
d1066 1
a1066 1
static char * iwmmxt_wwssnames[] =
d1073 10
a1090 5
static char * arm_fp_const[] =
{"0.0", "1.0", "2.0", "3.0", "4.0", "5.0", "0.5", "10.0"};

static char * arm_shift[] =
{"lsl", "lsr", "asr", "ror"};
d1109 1
a1109 1
		  const char ***register_names)
a1147 18
static int
set_iwmmxt_regnames (void)
{
  const char * setname;
  const char * setdesc;
  const char ** regnames;
  int iwmmxt_regnames = 0;
  int num_regnames = get_arm_regname_num_options ();

  get_arm_regnames (iwmmxt_regnames, &setname,
		    &setdesc, &regnames);
  while ((strcmp ("iwmmxt_regnames", setname))
	 && (iwmmxt_regnames < num_regnames))
    get_arm_regnames (++iwmmxt_regnames, &setname, &setdesc, &regnames);

  return iwmmxt_regnames;
}

d1153 1
a1153 1
  const struct arm_opcode *insn;
d1155 1
a1155 2
  fprintf_ftype func   = info->fprintf_func;
  static int iwmmxt_regnames = 0;
d1172 1
a1172 1
	  char * c;
d1279 1
a1279 3

			  (*info->print_address_func)
			    (offset + pc + 8, info);
d1336 4
a1339 2
		      (*info->print_address_func)
			(BDISP (given) * 4 + pc + 8, info);
a1660 7
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames);

d1663 1
a1663 2
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
a1669 7
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames + 1);

d1672 1
a1672 2
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
d1883 1
a1883 1
  const struct thumb_opcode *insn;
d1890 1
a1890 1
	char * c = insn->assembler;
d2052 1
a2052 2
			    (*info->print_address_func)
			      (reg * 2 + pc + 4, info);
d2108 1
a2108 1
  const struct arm_opcode *insn;
d2115 1
a2115 1
	char * c = insn->assembler;
@


1.46
log
@include/elf:
	* arm.h: Import complete list of official relocation names
	and numbers from AAELF.  Define FAKE_RELOCs for old names.
	Remove a few old names no longer used anywhere.

bfd:
	* elf32-arm.c: Wherever possible, use official reloc names
	from AAELF.
	(elf32_arm_howto_table, elf32_arm_tls_gd32_howto)
	(elf32_arm_tls_ldo32_howto, elf32_arm_tls_ldm32_howto)
	(elf32_arm_tls_le32_howto, elf32_arm_tls_ie32_howto)
	(elf32_arm_vtinherit_howto, elf32_arm_vtentry_howto)
	(elf32_arm_pc11_howto, elf32_arm_thm_pc9_howto, elf32_arm_got_prel)
	(elf32_arm_r_howto): Replace with elf32_arm_howto_table_1,
	elf32_arm_howto_table_2, and elf32_arm_howto_table_3.
	Add many new relocations from AAELF.
	(elf32_arm_howto_from_type): Update to match.
	(elf32_arm_reloc_map): Add entries for R_ARM_THM_JUMP24,
	R_ARM_THM_JUMP11, R_ARM_THM_JUMP19, R_ARM_THM_JUMP8,
	R_ARM_THM_JUMP6, R_ARM_GNU_VTINHERIT, and R_ARM_GNU_VTENTRY.
	(elf32_arm_reloc_type_lookup): Use elf32_arm_howto_from_type.
	(elf32_arm_final_link_relocate): Add support for
	R_ARM_THM_JUMP24, R_ARM_THM_JUMP19, R_ARM_THM_JUMP6.  Remove
	case entries redundant with default.

	* reloc.c: Reorganize ARM relocations.  Add Thumb
	assembler-internal relocations BFD_RELOC_ARM_T32_OFFSET_U8,
	BFD_RELOC_ARM_T32_OFFSET_IMM, BFD_RELOC_ARM_T32_IMMEDIATE.
	Add visible relocations BFD_RELOC_THUMB_PCREL_BRANCH7,
	BFD_RELOC_THUMB_BRANCH20, BFD_RELOC_THUMB_BRANCH25.
	Delete unused relocations BFD_RELOC_ARM_GOT12, BFD_RELOC_ARM_COPY.
	* bfd-in2.h, libbfd.h: Regenerate.

opcodes:
	* arm-dis.c (thumb_opcodes): Add disassembly for V6T2 16-bit
	instructions.  Adjust disassembly of some opcodes to match
	unified syntax.
	(thumb32_opcodes): New table.
	(print_insn_thumb): Rename print_insn_thumb16; don't handle
	two-halfword branches here.
	(print_insn_thumb32): New function.
	(print_insn): Choose among print_insn_arm, print_insn_thumb16,
	and print_insn_thumb32.  Be consistent about order of
	halfwords when printing 32-bit instructions.

gas:
	* hash.c (hash_lookup): Add len parameter.  All callers changed.
	(hash_find_n): New interface.
	* hash.h: Prototype hash_find_n.
	* sb.c: Include as.h.
	(scrub_from_sb, sb_to_scrub, scrub_position): New statics.
	(sb_scrub_and_add_sb): New interface.
	* sb.h: Prototype sb_scrub_and_add_sb.
	* input-scrub.c (input_scrub_include_sb): Use sb_scrub_and_add_sb.

	* config/tc-arm.h (TC_FORCE_RELOCATION_LOCAL): Remove
	reference to BFD_RELOC_ARM_GOT12 which is never generated.
	* config/tc-arm.c: Rewrite, adding Thumb-2 support.

gas/testsuite:
	* gas/arm/arm.exp: Convert all existing "gas_test" tests to
	"run_dump_test" tests.  Run more tests unconditionally.  Run new tests.
	* gas/arm/arch4t.s, gas/arm/arch6zk.s, gas/arm/arm3.s, gas/arm/arm6.s
	* gas/arm/arm7dm.s, gas/arm/bignum1.s, gas/arm/float.s
	* gas/arm/immed.s, gas/arm/iwmmxt.s, gas/arm/offset.s, gas/arm/thumb.s:
	Adjust to work as a dump test.
	* gas/arm/arch4t.d, gas/arm/arch6zk.d, gas/arm/arm3.d, gas/arm/arm6.d
	* gas/arm/arm7dm.d, gas/arm/bignum1.d, gas/arm/float.d
	* gas/arm/immed.d, gas/arm/iwmmxt.d, gas/arm/offset.d, gas/arm/thumb.d:
	New files.

	* gas/arm/armv1-bad.l, gas/arm/armv1-bad.s: Remove tests for
	diagnostics that don't happen in the first pass anymore.

	* gas/arm/iwmmxt-bad.l, gas/arm/r15-bad.l, gas/arm/req.l
	* gas/arm/vfp-bad.l:
	Update expected diagnostics.
	* gas/arm/pic.d: Update expected reloc name.
	* gas/arm/thumbv6.d: CPY no longer appears in disassembly.
	* gas/arm/r15-bad.s: Avoid two-argument mul.
	* gas/arm/req.s: Adjust comments.
	* gas/arm/maverick.d, gas/arm/maverick.s: Avoid inappropriate
	use of PC.

	* gas/arm/macro-1.d, gas/arm/macro1.s
	* gas/arm/t16-bad.l, gas/arm/t16-bad.s
	* gas/arm/tcompat.d, gas/arm/tcompat.s
	* gas/arm/tcompat2.d, gas/arm/tcompat2.s
	* gas/arm/thumb32.d, gas/arm/thumb32.s
	New test pair.

ld/testsuite:
	* ld-arm/mixed-app.d: Adjust expected disassembly a little.
@
text
@d52 6
a57 2
/* Format of the disassembler control string :
   
d59 19
d79 1
a81 2
   %<bitfield>W         print the bitfield plus one in decimal 
   %<bitfield>r		print as an ARM register
d84 4
a91 4
   %c			print condition code (always bits 28-31)
   %P			print floating point precision in arithmetic insn
   %Q			print floating point precision in ldf/stf insn
   %R			print floating point rounding mode
d95 2
a96 17
   %p			print 'p' iff bits 12-15 are 15
   %t			print 't' iff bit 21 set and bit 24 clear
   %o			print operand2 (immediate or register + shift)
   %a			print address for ldr/str instruction
   %s                   print address for ldr/str halfword/signextend instruction
   %b			print branch destination
   %B			print arm BLX(1) destination
   %A			print address for ldc/stc/ldf/stf instruction
   %m			print register mask for ldm/stm instruction
   %C			print the PSR sub type.
   %F			print the COUNT field of a LFM/SFM instruction.
   %E			print the LSB and WIDTH fields of a BFI or BFC instruction.
   %V                   print the 16-bit immediate field of a MOVT or MOVW instruction.
IWMMXT specific format options:
   %<bitfield>g         print as an iWMMXt 64-bit register
   %<bitfield>G         print as an iWMMXt general purpose or control register
   %<bitfield>w         print as an iWMMXt width field - [bhwd]ss/us
d98 2
a99 16
   %L			print as an iWMMXt N/M width field.
   %l			like 'A' except use byte offsets for 'B' & 'H' versions
Thumb specific format options:
   %D                   print Thumb register (bits 0..2 as high number if bit 7 set)
   %S                   print Thumb register (bits 3..5 as high number if bit 6 set)
   %<bitfield>I         print bitfield as a signed decimal
   				(top bit of range being the sign bit)
   %M                   print Thumb register mask
   %N                   print Thumb register mask (with LR)
   %O                   print Thumb register mask (with PC)
   %I                   print cirrus signed shift immediate: bits 0..3|4..6
   %<bitfield>B         print Thumb branch destination (signed displacement)
   %<bitfield>W         print (bitfield * 4) as a decimal
   %<bitfield>H         print (bitfield * 2) as a decimal
   %<bitfield>a         print (bitfield * 4) as a pc-rel offset + decoded symbol
   %<bitfield>c         print bitfield as a condition code
d101 2
a102 4
   %s			print Thumb right-shift immediate (6..10; 0 == 32). */

/* Note: There is a partial ordering in this table - it must be searched from
   the top to obtain a correct match.  */
d626 21
d776 1
a776 1
   %-escapes defined for these instructions:
a778 8
       %<bitfield>d	print bitfield in decimal
       %<bitfield>W	print bitfield*4 in decimal
       %<bitfield>r	print bitfield as an ARM register
       %<bitfield>c	print bitfield as a condition code

       %<bitnum>'c	print "c" iff bit is one
       %<bitnum>`c	print "c" iff bit is zero
       %<bitnum>?ab	print "a" if bit is one, else "b"
d793 1
a794 1
       %b		print a conditional branch offset
d798 9
a1077 23
/* Forward declarations.  */
static void arm_decode_shift
  PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb16
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb32
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options
  PARAMS ((char *));
static int  print_insn
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static int set_iwmmxt_regnames
  PARAMS ((void));

int get_arm_regname_num_options
  PARAMS ((void));
int set_arm_regname_option
  PARAMS ((int));
int get_arm_regnames
  PARAMS ((int, const char **, const char **, const char ***));

d1080 1
a1080 1
get_arm_regname_num_options ()
d1086 1
a1086 2
set_arm_regname_option (option)
     int option;
d1094 2
a1095 5
get_arm_regnames (option, setname, setdescription, register_names)
     int option;
     const char **setname;
     const char **setdescription;
     const char ***register_names;
d1104 1
a1104 4
arm_decode_shift (given, func, stream)
     long given;
     fprintf_ftype func;
     void * stream;
d1135 1
a1135 1
set_iwmmxt_regnames ()
a1150 3
			  
/* Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction (always 4 on ARM). */
d1152 4
a1155 5
static int
print_insn_arm (pc, info, given)
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d1893 1
a1893 1
	  return 4;
d1899 1
a1899 2
/* Print one instruction from PC on INFO->STREAM.
   Return the size of the instruction. */
d1901 2
a1902 5
static int
print_insn_thumb16 (pc, info, given)
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
a2070 5
			  case 'I':
			    reg = ((reg ^ (1 << bitend)) - (1 << bitend));
			    func (stream, "%d", reg);
			    break;

d2118 1
a2118 1
	return 2;
d2125 4
a2128 5
static int
print_insn_thumb32 (pc, info, given)
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d2526 1
a2526 1
	return 4;
d2553 1
a2553 2
parse_arm_disassembler_option (option)
     char * option;
d2590 1
a2590 2
parse_disassembler_options (options)
     char * options;
d2612 1
a2612 4
print_insn (pc, info, little)
     bfd_vma pc;
     struct disassemble_info * info;
     bfd_boolean little;
d2618 2
a2619 1
  int	 	(*printer) (bfd_vma, struct disassemble_info *, long);
d2665 1
d2679 3
a2682 1
      info->bytes_per_chunk = 2;
d2704 1
a2705 2
	  else
	    printer = print_insn_thumb16;
d2722 2
a2723 1
  return printer (pc, info, given);
d2727 1
a2727 3
print_insn_big_arm (pc, info)
     bfd_vma pc;
     struct disassemble_info * info;
d2733 1
a2733 3
print_insn_little_arm (pc, info)
     bfd_vma pc;
     struct disassemble_info * info;
d2739 1
a2739 1
print_arm_disassembler_options (FILE * stream)
@


1.45
log
@Update the address and phone number of the FSF
@
text
@a100 1
   %T                   print Thumb condition code (always bits 8-11)
d106 3
a108 1
   %e                   print arm SMI operand (bits 0..7,8..19).  */
d645 12
d661 1
a661 1
  {ARM_EXT_V6, 0x4600, 0xffc0, "cpy\t%0-2r, %3-5r"},
d673 1
a673 6
  /* Note: this is BLX(2).  BLX(1) is done in arm-dis.c/print_insn_thumb()
     as an extension of the special processing there for Thumb BL.
     BL and BLX(1) involve 2 successive 16-bit instructions, which must
     always appear together in the correct order.  So, the empty
     string is put in this table, and the string interpreter takes <empty>
     to mean it has a pair of BL-ish instructions.  */
a676 2
  /* Format 5 instructions do not update the PSR.  */
  {ARM_EXT_V4T, 0x1C00, 0xFFC0, "mov\t%0-2r, %3-5r\t\t(add %0-2r, %3-5r, #%6-8d)"},
d678 8
a685 8
  {ARM_EXT_V4T, 0x4000, 0xFFC0, "and\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4040, 0xFFC0, "eor\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4080, 0xFFC0, "lsl\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x40C0, 0xFFC0, "lsr\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4100, 0xFFC0, "asr\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4140, 0xFFC0, "adc\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4180, 0xFFC0, "sbc\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x41C0, 0xFFC0, "ror\t%0-2r, %3-5r"},
d687 1
a687 1
  {ARM_EXT_V4T, 0x4240, 0xFFC0, "neg\t%0-2r, %3-5r"},
d690 4
a693 4
  {ARM_EXT_V4T, 0x4300, 0xFFC0, "orr\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4340, 0xFFC0, "mul\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4380, 0xFFC0, "bic\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x43C0, 0xFFC0, "mvn\t%0-2r, %3-5r"},
d706 1
a706 1
  {ARM_EXT_V4T, 0x1800, 0xFE00, "add\t%0-2r, %3-5r, %6-8r"},
d708 1
a708 1
  {ARM_EXT_V4T, 0x1C00, 0xFE00, "add\t%0-2r, %3-5r, #%6-8d"},
d718 3
a720 3
  {ARM_EXT_V4T, 0x0000, 0xF800, "lsl\t%0-2r, %3-5r, #%6-10d"},
  {ARM_EXT_V4T, 0x0800, 0xF800, "lsr\t%0-2r, %3-5r, #%6-10d"},
  {ARM_EXT_V4T, 0x1000, 0xF800, "asr\t%0-2r, %3-5r, #%6-10d"},
d722 1
a722 1
  {ARM_EXT_V4T, 0x2000, 0xF800, "mov\t%8-10r, #%0-7d"},
d724 2
a725 2
  {ARM_EXT_V4T, 0x3000, 0xF800, "add\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x3800, 0xF800, "sub\t%8-10r, #%0-7d"},
d743 2
a744 23
  {ARM_EXT_V4T, 0xC000, 0xF800, "stmia\t%8-10r!,%M"},
  {ARM_EXT_V4T, 0xC800, 0xF800, "ldmia\t%8-10r!,%M"},
  /* format 18 */
  {ARM_EXT_V4T, 0xE000, 0xF800, "b\t%0-10B"},
  {ARM_EXT_V4T, 0xE800, 0xF800, "undefined"},
  /* format 19 */
  {ARM_EXT_V4T, 0xF000, 0xF800, ""}, /* special processing required in disassembler */
  {ARM_EXT_V4T, 0xF800, 0xF800, "second half of BL instruction %0-15x"},
  /* format 16 */
  {ARM_EXT_V4T, 0xD000, 0xFF00, "beq\t%0-7B"},
  {ARM_EXT_V4T, 0xD100, 0xFF00, "bne\t%0-7B"},
  {ARM_EXT_V4T, 0xD200, 0xFF00, "bcs\t%0-7B"},
  {ARM_EXT_V4T, 0xD300, 0xFF00, "bcc\t%0-7B"},
  {ARM_EXT_V4T, 0xD400, 0xFF00, "bmi\t%0-7B"},
  {ARM_EXT_V4T, 0xD500, 0xFF00, "bpl\t%0-7B"},
  {ARM_EXT_V4T, 0xD600, 0xFF00, "bvs\t%0-7B"},
  {ARM_EXT_V4T, 0xD700, 0xFF00, "bvc\t%0-7B"},
  {ARM_EXT_V4T, 0xD800, 0xFF00, "bhi\t%0-7B"},
  {ARM_EXT_V4T, 0xD900, 0xFF00, "bls\t%0-7B"},
  {ARM_EXT_V4T, 0xDA00, 0xFF00, "bge\t%0-7B"},
  {ARM_EXT_V4T, 0xDB00, 0xFF00, "blt\t%0-7B"},
  {ARM_EXT_V4T, 0xDC00, 0xFF00, "bgt\t%0-7B"},
  {ARM_EXT_V4T, 0xDD00, 0xFF00, "ble\t%0-7B"},
a745 1
  {ARM_EXT_V4T, 0xDE00, 0xFF00, "bal\t%0-7B"},
d747 259
a1005 8
  /* format 9 */
  {ARM_EXT_V4T, 0x6000, 0xF800, "str\t%0-2r, [%3-5r, #%6-10W]"},
  {ARM_EXT_V4T, 0x6800, 0xF800, "ldr\t%0-2r, [%3-5r, #%6-10W]"},
  {ARM_EXT_V4T, 0x7000, 0xF800, "strb\t%0-2r, [%3-5r, #%6-10d]"},
  {ARM_EXT_V4T, 0x7800, 0xF800, "ldrb\t%0-2r, [%3-5r, #%6-10d]"},
  /* the rest */
  {ARM_EXT_V1, 0x0000, 0x0000, "undefined instruction %0-15x"},
  {0, 0x0000, 0x0000, 0}
d1007 1
d1011 1
a1011 1
 "hi", "ls", "ge", "lt", "gt", "le", "", "nv"};
d1070 3
a1072 1
static int  print_insn_thumb
d1924 1
a1924 1
print_insn_thumb (pc, info, given)
d1934 520
a2453 4
    {
      if ((given & insn->mask) == insn->value)
        {
          char * c = insn->assembler;
d2455 13
a2467 4
          /* Special processing for Thumb 2 instruction BL sequence:  */
          if (!*c) /* Check for empty (not NULL) assembler string.  */
            {
	      long offset;
d2469 3
a2471 2
	      info->bytes_per_chunk = 4;
	      info->bytes_per_line  = 4;
d2473 12
a2484 2
	      offset = BDISP23 (given);
	      offset = offset * 2 + pc + 4;
d2486 1
a2486 1
	      if ((given & 0x10000000) == 0)
d2488 62
a2549 2
		  func (stream, "blx\t");
		  offset &= 0xfffffffc;
d2551 1
a2551 2
	      else
		func (stream, "bl\t");
d2553 6
a2558 198
	      info->print_address_func (offset, info);
              return 4;
            }
          else
            {
	      info->bytes_per_chunk = 2;
	      info->bytes_per_line  = 4;

              given &= 0xffff;

              for (; *c; c++)
                {
                  if (*c == '%')
                    {
                      int domaskpc = 0;
                      int domasklr = 0;

                      switch (*++c)
                        {
                        case '%':
                          func (stream, "%%");
                          break;

                        case 'S':
                          {
                            long reg;

                            reg = (given >> 3) & 0x7;
                            if (given & (1 << 6))
                              reg += 8;

                            func (stream, "%s", arm_regnames[reg]);
                          }
                          break;

                        case 'D':
                          {
                            long reg;

                            reg = given & 0x7;
                            if (given & (1 << 7))
                             reg += 8;

                            func (stream, "%s", arm_regnames[reg]);
                          }
                          break;

                        case 'T':
                          func (stream, "%s",
                                arm_conditional [(given >> 8) & 0xf]);
                          break;

                        case 'N':
                          if (given & (1 << 8))
                            domasklr = 1;
                          /* Fall through.  */
                        case 'O':
                          if (*c == 'O' && (given & (1 << 8)))
                            domaskpc = 1;
                          /* Fall through.  */
                        case 'M':
                          {
                            int started = 0;
                            int reg;

                            func (stream, "{");

                            /* It would be nice if we could spot
                               ranges, and generate the rS-rE format: */
                            for (reg = 0; (reg < 8); reg++)
                              if ((given & (1 << reg)) != 0)
                                {
                                  if (started)
                                    func (stream, ", ");
                                  started = 1;
                                  func (stream, "%s", arm_regnames[reg]);
                                }

                            if (domasklr)
                              {
                                if (started)
                                  func (stream, ", ");
                                started = 1;
                                func (stream, arm_regnames[14] /* "lr" */);
                              }

                            if (domaskpc)
                              {
                                if (started)
                                  func (stream, ", ");
                                func (stream, arm_regnames[15] /* "pc" */);
                              }

                            func (stream, "}");
                          }
                          break;


                        case '0': case '1': case '2': case '3': case '4':
                        case '5': case '6': case '7': case '8': case '9':
                          {
                            int bitstart = *c++ - '0';
                            int bitend = 0;

                            while (*c >= '0' && *c <= '9')
                              bitstart = (bitstart * 10) + *c++ - '0';

                            switch (*c)
                              {
                              case '-':
                                {
                                  long reg;

                                  c++;
                                  while (*c >= '0' && *c <= '9')
                                    bitend = (bitend * 10) + *c++ - '0';
                                  if (!bitend)
                                    abort ();
                                  reg = given >> bitstart;
                                  reg &= (2 << (bitend - bitstart)) - 1;
                                  switch (*c)
                                    {
                                    case 'r':
                                      func (stream, "%s", arm_regnames[reg]);
                                      break;

                                    case 'd':
                                      func (stream, "%d", reg);
                                      break;

                                    case 'H':
                                      func (stream, "%d", reg << 1);
                                      break;

                                    case 'W':
                                      func (stream, "%d", reg << 2);
                                      break;

                                    case 'a':
				      /* PC-relative address -- the bottom two
					 bits of the address are dropped
					 before the calculation.  */
                                      info->print_address_func
					(((pc + 4) & ~3) + (reg << 2), info);
                                      break;

                                    case 'x':
                                      func (stream, "0x%04x", reg);
                                      break;

                                    case 'I':
                                      reg = ((reg ^ (1 << bitend)) - (1 << bitend));
                                      func (stream, "%d", reg);
                                      break;

                                    case 'B':
                                      reg = ((reg ^ (1 << bitend)) - (1 << bitend));
                                      (*info->print_address_func)
                                        (reg * 2 + pc + 4, info);
                                      break;

                                    default:
                                      abort ();
                                    }
                                }
                                break;

                              case '\'':
                                c++;
                                if ((given & (1 << bitstart)) != 0)
                                  func (stream, "%c", *c);
                                break;

                              case '?':
                                ++c;
                                if ((given & (1 << bitstart)) != 0)
                                  func (stream, "%c", *c++);
                                else
                                  func (stream, "%c", *++c);
                                break;

                              default:
                                 abort ();
                              }
                          }
                          break;

                        default:
                          abort ();
                        }
                    }
                  else
                    func (stream, "%c", *c);
                }
             }
          return 2;
       }
    }
d2650 5
a2654 4
  unsigned char      b[4];
  long               given;
  int                status;
  int                is_thumb, second_half_valid = 1;
a2690 1
  info->bytes_per_chunk = 4;
d2692 1
d2694 1
a2694 1
  if (little)
d2696 10
a2705 17
      status = info->read_memory_func (pc, (bfd_byte *) &b[0], 4, info);
      if (status != 0 && is_thumb)
	{
	  info->bytes_per_chunk = 2;
	  second_half_valid = 0;

	  status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);
	  b[3] = b[2] = 0;
	}

      if (status != 0)
	{
	  info->memory_error_func (status, pc, info);
	  return -1;
	}

      given = (b[0]) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
d2709 8
a2716 3
      status = info->read_memory_func
	(WORD_ADDRESS (pc), (bfd_byte *) &b[0], 4, info);
      if (status != 0)
d2718 4
a2721 3
	  info->memory_error_func (status, WORD_ADDRESS (pc), info);
	  return -1;
	}
d2723 5
a2727 3
      if (is_thumb)
	{
	  if (pc & 0x2)
d2729 5
a2733 1
	      given = (b[2] << 8) | b[3];
d2735 1
a2735 6
	      status = info->read_memory_func
		(WORD_ADDRESS (pc + 4), (bfd_byte *) b, 4, info);
	      if (status != 0)
		second_half_valid = 0;
	      else
		given |= (b[0] << 24) | (b[1] << 16);
d2738 1
a2738 1
	    given = (b[0] << 8) | b[1] | (b[2] << 24) | (b[3] << 16);
a2739 2
      else
	given = (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | (b[3]);
d2742 5
d2755 1
a2755 12
  if (is_thumb)
    status = print_insn_thumb (pc, info, given);
  else
    status = print_insn_arm (pc, info, given);

  if (is_thumb && status == 4 && second_half_valid == 0)
    {
      info->memory_error_func (status, WORD_ADDRESS (pc + 4), info);
      return -1;
    }

  return status;
@


1.44
log
@gas:
	* config/tc-arm.c (tinsns): Add ARMv6K instructions sev, wfe,
	wfi, yield.
opcodes:
	* arm-dis.c (thumb_opcodes): Add ARMv6K instructions nop, sev,
	wfe, wfi, yield.
gas/testsuite:
	* gas/arm/thumbv6k.d, gas/arm/thumbv6k.s: New dump test.
	* gas/arm/arm.exp: Run it.
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.43
log
@Revert accidental commit of V6K ops
@
text
@d638 7
@


1.42
log
@include:
	* opcode/arm.h: Adjust comments for ARM_EXT_V4T and ARM_EXT_V5T.
	Add ARM_EXT_V6T2, ARM_ARCH_V6T2, ARM_ARCH_V6KT2, ARM_ARCH_V6ZT2,
	and ARM_ARCH_V6ZKT2.
opcodes:
	* arm-dis.c (arm_opcodes): Document %E and %V.
	Add entries for v6T2 ARM instructions:
	bfc bfi mls strht ldrht ldrsht ldrsbt movw movt rbit ubfx sbfx.
	(print_insn_arm): Add support for %E and %V.
@
text
@a637 7
  /* ARM V6K no-argument instructions.  */
  {ARM_EXT_V6K, 0xbf00, 0xffff, "nop"},
  {ARM_EXT_V6K, 0xbf10, 0xffff, "yield"},
  {ARM_EXT_V6K, 0xbf20, 0xffff, "wfe"},
  {ARM_EXT_V6K, 0xbf30, 0xffff, "wfi"},
  {ARM_EXT_V6K, 0xbf40, 0xffff, "sev"},

@


1.41
log
@* arm-dis.c: Correct top-level comment.
@
text
@d84 2
d123 11
d638 7
d952 7
a958 1
      if ((given & insn->mask) == insn->value)
d1642 26
@


1.41.4.1
log
@Backport ARM patches from HEAD to binutils-csl-arm-2005q1-branch.
@
text
@a83 2
   %E			print the LSB and WIDTH fields of a BFI or BFC instruction.
   %V                   print the 16-bit immediate field of a MOVT or MOVW instruction.
a120 11
  /* ARM V6T2 instructions.  */
  {ARM_EXT_V6T2, 0x07c0001f, 0x0fe0007f, "bfc%c\t%12-15r, %E"},
  {ARM_EXT_V6T2, 0x07c00010, 0x0fe00070, "bfi%c\t%12-15r, %0-3r, %E"},
  {ARM_EXT_V6T2, 0x00600090, 0x0ff000f0, "mls%c\t%16-19r, %0-3r, %8-11r, %12-15r"},
  {ARM_EXT_V6T2, 0x006000b0, 0x0f7000f0, "str%cht\t%12-15r, %s"},
  {ARM_EXT_V6T2, 0x00300090, 0x0f300090, "ldr%c%6's%5?hbt\t%12-15r, %s"},
  {ARM_EXT_V6T2, 0x03000000, 0x0ff00000, "movw%c\t%12-15r, %V"},
  {ARM_EXT_V6T2, 0x03400000, 0x0ff00000, "movt%c\t%12-15r, %V"},
  {ARM_EXT_V6T2, 0x03ff0f30, 0x0fff0ff0, "rbit%c\t%12-15r, %0-3r"},
  {ARM_EXT_V6T2, 0x07a00050, 0x0fa00070, "%22?usbfx%c\t%12-15r, %0-3r, #%7-11d, #%16-20W"},

a624 7
  /* ARM V6K no-argument instructions.  */
  {ARM_EXT_V6K, 0xbf00, 0xffff, "nop"},
  {ARM_EXT_V6K, 0xbf10, 0xffff, "yield"},
  {ARM_EXT_V6K, 0xbf20, 0xffff, "wfe"},
  {ARM_EXT_V6K, 0xbf30, 0xffff, "wfi"},
  {ARM_EXT_V6K, 0xbf40, 0xffff, "sev"},

d932 1
a932 7
      if ((given & insn->mask) == insn->value
	  /* Special case: an instruction with all bits set in the condition field
	     (0xFnnn_nnnn) is only matched if all those bits are set in insn->mask,
	     or by the catchall at the end of the table.  */
	  && ((given & 0xF0000000) != 0xF0000000
	      || (insn->mask & 0xF0000000) == 0xF0000000
	      || (insn->mask == 0 && insn->value == 0)))
a1615 26
		      case 'E':
			/* LSB and WIDTH fields of BFI or BFC.  The machine-
			   language instruction encodes LSB and MSB.  */
			{
			  long msb = (given & 0x001f0000) >> 16;
			  long lsb = (given & 0x00000f80) >> 7;

			  long width = msb - lsb + 1;
			  if (width > 0)
			    func (stream, "#%lu, #%lu", lsb, width);
			  else
			    func (stream, "(invalid: %lu:%lu)", lsb, msb);
			}
			break;

		      case 'V':
			/* 16-bit unsigned immediate from a MOVT or MOVW
			   instruction, encoded in bits 0:11 and 15:19.  */
			{
			  long hi = (given & 0x000f0000) >> 4;
			  long lo = (given & 0x00000fff);
			  long imm16 = hi | lo;
			  func (stream, "#%lu\t; 0x%lx", imm16, imm16);
			}
			break;

@


1.41.4.2
log
@	Thumb32 assembler.

	* include/elf/arm.h: Import full set of relocation names from
	latest AAELF.  Make the primary name of all relocations be the one
	AAELF specifies.  Provide aliases under the traditional names.
	Kill FIRST_INVALID_RELOC_* and LAST_INVALID_RELOC_*.
	* bfd/reloc.c: Reorganize ARM relocations.  Remove ARM relocations
	that are never generated.  Document more of the relocations.  Add
	relocations for Thumb32.
	* bfd/libbfd.h, bfd/bfd-in2.h: Regenerate.
	* bfd/elf32-arm.c: Reorganize howto tables.  Implement Thumb32
	relocations.
	* ld/testsuite/ld-arm/mixed-app.d: Adjust expectations for
	renamed relocations.

	* gas/hash.c (hash_find_n): New interface.
	* gas/hash.h: Prototype it.

	* gas/config/tc-arm.c: Rewrite and reorganize.  Implement 32-bit
	Thumb instructions.
	* gas/testsuite/gas/arm: Convert all "gas_test" style tests to
	"run_dump_test" style tests, for more thorough testing.  Make
	adjustments to expectations where necessary.
	* gas/testsuite/gas/arm/t16-bad.s, gas/testsuite/gas/arm/tcompat.s
	* gas/testsuite/gas/arm/tcompat2.s, gas/testsuite/gas/arm/thumb32.s:
	New test cases.

	* opcodes/arm-dis.c: Add support for Thumb32 instructions and
	16-bit V6T2 instructions.
@
text
@d101 1
d107 1
a107 3
   %<bitfield>c         print bitfield as a condition code
   %e                   print arm SMI operand (bits 0..7,8..19).
   %s			print Thumb right-shift immediate (6..10; 0 == 32). */
a643 12
  {ARM_EXT_V6K, 0xbf00, 0xff0f, "nop\t{%4-7d}"},

  /* ARM V6T2 instructions.  */
  {ARM_EXT_V6T2, 0xb900, 0xfd00, "czbne\t%0-2r, %b"},
  {ARM_EXT_V6T2, 0xb100, 0xfd00, "czbeq\t%0-2r, %b"},
  {ARM_EXT_V6T2, 0xbf08, 0xff0f, "it\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf14, 0xff17, "it%3?te\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf04, 0xff17, "it%3?et\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf12, 0xff13, "it%3?te%2?te\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf02, 0xff13, "it%3?et%2?et\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf11, 0xff11, "it%3?te%2?te%1?te\t%4-7c"},
  {ARM_EXT_V6T2, 0xbf01, 0xff11, "it%3?et%2?et%1?et\t%4-7c"},
d648 1
a648 1
  {ARM_EXT_V6, 0x4600, 0xffc0, "mov\t%0-2r, %3-5r"},
d660 6
a665 1
  /* This is BLX(2).  BLX(1) is a 32-bit instruction.  */
d669 2
d672 8
a679 8
  {ARM_EXT_V4T, 0x4000, 0xFFC0, "ands\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4040, 0xFFC0, "eors\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4080, 0xFFC0, "lsls\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x40C0, 0xFFC0, "lsrs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4100, 0xFFC0, "asrs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4140, 0xFFC0, "adcs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4180, 0xFFC0, "sbcs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x41C0, 0xFFC0, "rors\t%0-2r, %3-5r"},
d681 1
a681 1
  {ARM_EXT_V4T, 0x4240, 0xFFC0, "negs\t%0-2r, %3-5r"},
d684 4
a687 4
  {ARM_EXT_V4T, 0x4300, 0xFFC0, "orrs\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4340, 0xFFC0, "muls\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x4380, 0xFFC0, "bics\t%0-2r, %3-5r"},
  {ARM_EXT_V4T, 0x43C0, 0xFFC0, "mvns\t%0-2r, %3-5r"},
d700 1
a700 1
  {ARM_EXT_V4T, 0x1800, 0xFE00, "adds\t%0-2r, %3-5r, %6-8r"},
d702 1
a702 1
  {ARM_EXT_V4T, 0x1C00, 0xFE00, "adds\t%0-2r, %3-5r, #%6-8d"},
d712 3
a714 3
  {ARM_EXT_V4T, 0x0000, 0xF800, "lsls\t%0-2r, %3-5r, #%6-10d"},
  {ARM_EXT_V4T, 0x0800, 0xF800, "lsrs\t%0-2r, %3-5r, %s"},
  {ARM_EXT_V4T, 0x1000, 0xF800, "asrs\t%0-2r, %3-5r, %s"},
d716 1
a716 1
  {ARM_EXT_V4T, 0x2000, 0xF800, "movs\t%8-10r, #%0-7d"},
d718 2
a719 2
  {ARM_EXT_V4T, 0x3000, 0xF800, "adds\t%8-10r, #%0-7d"},
  {ARM_EXT_V4T, 0x3800, 0xF800, "subs\t%8-10r, #%0-7d"},
d737 23
a759 2
  {ARM_EXT_V4T, 0xC000, 0xF800, "stmia\t%8-10r!, %M"},
  {ARM_EXT_V4T, 0xC800, 0xF800, "ldmia\t%8-10r!, %M"},
d761 1
d763 8
a770 11
  /* format 16 */
  {ARM_EXT_V4T, 0xD000, 0xF000, "b%8-11c.n\t%0-7B"},
  /* format 18 */
  {ARM_EXT_V4T, 0xE000, 0xF800, "b.n\t%0-10B"},

  /* The E800 .. FFFF range is unconditionally redirected to the
     32-bit table, because even in pre-V6T2 ISAs, BL and BLX(1) pairs
     are processed via that table.  Thus, we can never encounter a
     bare "second half of BL/BLX(1)" instruction here.  */
  {ARM_EXT_V1,  0x0000, 0x0000, "undefined"},
  {0, 0, 0, 0}
a772 249
/* Thumb32 opcodes use the same table structure as the ARM opcodes.
   We adopt the convention that hw1 is the high 16 bits of .value and
   .mask, hw2 the low 16 bits.

   %-escapes defined for these instructions:

       %%		%
       %<bitfield>d	print bitfield in decimal
       %<bitfield>W	print bitfield*4 in decimal
       %<bitfield>r	print bitfield as an ARM register
       %<bitfield>c	print bitfield as a condition code

       %<bitnum>'c	print "c" iff bit is one
       %<bitnum>`c	print "c" iff bit is zero
       %<bitnum>?ab	print "a" if bit is one, else "b"

       %I		print a 12-bit immediate from hw1[10],hw2[14:12,7:0]
       %M		print a modified 12-bit immediate (same location)
       %J		print a 16-bit immediate from hw1[3:0,10],hw2[14:12,7:0]
       %K		print a 16-bit immediate from hw2[3:0],hw1[3:0],hw2[11:4]
       %S		print a possibly-shifted Rm

       %a		print the address of a plain load/store
       %A		print the address of a coprocessor load/store
       %w		print the width and signedness of a core load/store
       %m		print register mask for ldm/stm

       %E		print the lsb and width fields of a bfc/bfi instruction
       %F		print the lsb and width fields of a sbfx/ubfx instruction
       %B		print an unconditional branch offset
       %b		print a conditional branch offset
       %s		print the shift field of an SSAT instruction
       %R		print the rotation field of an SXT instruction

   With one exception at the bottom (done because BL and BLX(1) need
   to come dead last), this table was machine-sorted first in
   decreasing order of number of bits set in the mask, then in
   increasing numeric order of mask, then in increasing numeric order
   of opcode.  This order is not the clearest for a human reader, but
   is guaranteed never to catch a special-case bit pattern with a more
   general mask, which is important, because this instruction encoding
   makes heavy use of special-case bit patterns.  */
static const struct arm_opcode thumb32_opcodes[] =
{
  /* Instructions defined in the basic V6T2 set.  */
  {ARM_EXT_V6T2, 0xf3af8000, 0xffffffff, "nop.w"},
  {ARM_EXT_V6T2, 0xf3af8001, 0xffffffff, "yield.w"},
  {ARM_EXT_V6T2, 0xf3af8002, 0xffffffff, "wfe.w"},
  {ARM_EXT_V6T2, 0xf3af8003, 0xffffffff, "wfi.w"},
  {ARM_EXT_V6T2, 0xf3af9004, 0xffffffff, "sev.w"},
  {ARM_EXT_V6T2, 0xf3af8000, 0xffffff00, "nop.w\t{%0-7d}"},

  {ARM_EXT_V6T2, 0xf3bf8f2f, 0xffffffff, "clrex"},
  {ARM_EXT_V6T2, 0xf3af8400, 0xffffff1f, "cpsie.w\t%7'a%6'i%5'f"},
  {ARM_EXT_V6T2, 0xf3af8600, 0xffffff1f, "cpsid.w\t%7'a%6'i%5'f"},
  {ARM_EXT_V6T2, 0xf3c08f00, 0xfff0ffff, "bxj\t%16-19r"},
  {ARM_EXT_V6T2, 0xe810c000, 0xffd0ffff, "rfedb\t%16-19r%21'!"},
  {ARM_EXT_V6T2, 0xe990c000, 0xffd0ffff, "rfeia\t%16-19r%21'!"},
  {ARM_EXT_V6T2, 0xf3ef8000, 0xffeff0ff, "mrs\t%8-11r, %20?CSPSR"},
  {ARM_EXT_V6T2, 0xf3af8100, 0xffffffe0, "cps\t#%0-4d"},
  {ARM_EXT_V6T2, 0xe8d0f000, 0xfff0fff0, "tbb\t[%16-19r, %0-3r]"},
  {ARM_EXT_V6T2, 0xe8d0f010, 0xfff0fff0, "tbh\t[%16-19r, %0-3r]"},
  {ARM_EXT_V6T2, 0xf3af8500, 0xffffff00, "cpsie\t%7'a%6'i%5'f, #%0-4d"},
  {ARM_EXT_V6T2, 0xf3af8700, 0xffffff00, "cpsid\t%7'a%6'i%5'f, #%0-4d"},
  {ARM_EXT_V6T2, 0xf3de8f00, 0xffffff00, "subs\tpc, lr, #%0-7d"},
  {ARM_EXT_V6T2, 0xf3808000, 0xffe0f0ff, "msr\t%20?CSPSR_%8'c%9'x%10's%11'f, %16-19r"},
  {ARM_EXT_V6T2, 0xe8500f00, 0xfff00fff, "ldrex\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe8d00f4f, 0xfff00fef, "ldrex%4?hb\t%12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe800c000, 0xffd0ffe0, "srsdb\t#%0-4d%21'!"},
  {ARM_EXT_V6T2, 0xe980c000, 0xffd0ffe0, "srsia\t#%0-4d%21'!"},
  {ARM_EXT_V6T2, 0xfa0ff080, 0xfffff0c0, "sxth.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa1ff080, 0xfffff0c0, "uxth.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa2ff080, 0xfffff0c0, "sxtb16\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa3ff080, 0xfffff0c0, "uxtb16\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa4ff080, 0xfffff0c0, "sxtb.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa5ff080, 0xfffff0c0, "uxtb.w\t%8-11r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xe8400000, 0xfff000ff, "strex\t%8-11r, %12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe8d0007f, 0xfff000ff, "ldrexd\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xfa80f000, 0xfff0f0f0, "sadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f010, 0xfff0f0f0, "qadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f020, 0xfff0f0f0, "shadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f040, 0xfff0f0f0, "uadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f050, 0xfff0f0f0, "uqadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f060, 0xfff0f0f0, "uhadd8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa80f080, 0xfff0f0f0, "qadd\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f090, 0xfff0f0f0, "qdadd\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0a0, 0xfff0f0f0, "qsub\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa80f0b0, 0xfff0f0f0, "qdsub\t%8-11r, %0-3r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f000, 0xfff0f0f0, "sadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f010, 0xfff0f0f0, "qadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f020, 0xfff0f0f0, "shadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f040, 0xfff0f0f0, "uadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f050, 0xfff0f0f0, "uqadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f060, 0xfff0f0f0, "uhadd16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa90f080, 0xfff0f0f0, "rev.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f090, 0xfff0f0f0, "rev16.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f0a0, 0xfff0f0f0, "rbit\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfa90f0b0, 0xfff0f0f0, "revsh.w\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfaa0f000, 0xfff0f0f0, "saddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f010, 0xfff0f0f0, "qaddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f020, 0xfff0f0f0, "shaddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f040, 0xfff0f0f0, "uaddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f050, 0xfff0f0f0, "uqaddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f060, 0xfff0f0f0, "uhaddsubx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfaa0f080, 0xfff0f0f0, "sel\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfab0f080, 0xfff0f0f0, "clz\t%8-11r, %16-19r"},
  {ARM_EXT_V6T2, 0xfac0f000, 0xfff0f0f0, "ssub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f010, 0xfff0f0f0, "qsub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f020, 0xfff0f0f0, "shsub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f040, 0xfff0f0f0, "usub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f050, 0xfff0f0f0, "uqsub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfac0f060, 0xfff0f0f0, "uhsub8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f000, 0xfff0f0f0, "ssub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f010, 0xfff0f0f0, "qsub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f020, 0xfff0f0f0, "shsub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f040, 0xfff0f0f0, "usub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f050, 0xfff0f0f0, "uqsub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfad0f060, 0xfff0f0f0, "uhsub16\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f000, 0xfff0f0f0, "ssubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f010, 0xfff0f0f0, "qsubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f020, 0xfff0f0f0, "shsubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f040, 0xfff0f0f0, "usubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f050, 0xfff0f0f0, "uqsubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfae0f060, 0xfff0f0f0, "uhsubaddx\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb00f000, 0xfff0f0f0, "mul.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb70f000, 0xfff0f0f0, "usad8\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa00f000, 0xffe0f0f0, "lsl%20's.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa20f000, 0xffe0f0f0, "lsr%20's.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa40f000, 0xffe0f0f0, "asr%20's.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa60f000, 0xffe0f0f0, "ror%20's.w\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xe8c00f40, 0xfff00fe0, "strex%4?hb\t%0-3r, %12-15r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xf3200000, 0xfff0f0e0, "ssat16\t%8-11r, #%0-4d, %16-19r"},
  {ARM_EXT_V6T2, 0xf3a00000, 0xfff0f0e0, "usat16\t%8-11r, #%0-4d, %16-19r"},
  {ARM_EXT_V6T2, 0xfb20f000, 0xfff0f0e0, "smuad%4'x\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb30f000, 0xfff0f0e0, "smulw%4?tb\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb40f000, 0xfff0f0e0, "smusd%4'x\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfb50f000, 0xfff0f0e0, "smmul%4'r\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfa00f080, 0xfff0f0c0, "sxtah\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa10f080, 0xfff0f0c0, "uxtah\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa20f080, 0xfff0f0c0, "sxtab16\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa30f080, 0xfff0f0c0, "uxtab16\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa40f080, 0xfff0f0c0, "sxtab\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfa50f080, 0xfff0f0c0, "uxtab\t%8-11r, %16-19r, %0-3r%R"},
  {ARM_EXT_V6T2, 0xfb10f000, 0xfff0f0c0, "smul%5?tb%4?tb\t%8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xf36f0000, 0xffff8020, "bfc\t%8-11r, %E"},
  {ARM_EXT_V6T2, 0xea100f00, 0xfff08f00, "tst.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xea900f00, 0xfff08f00, "teq\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb100f00, 0xfff08f00, "cmn.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xebb00f00, 0xfff08f00, "cmp.w\t%16-19r, %S"},
  {ARM_EXT_V6T2, 0xf0100f00, 0xfbf08f00, "tst.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0900f00, 0xfbf08f00, "teq\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1100f00, 0xfbf08f00, "cmn.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1b00f00, 0xfbf08f00, "cmp.w\t%16-19r, %M"},
  {ARM_EXT_V6T2, 0xea4f0000, 0xffef8000, "mov%20's.w\t%8-11r, %S"},
  {ARM_EXT_V6T2, 0xea6f0000, 0xffef8000, "mvn%20's.w\t%8-11r, %S"},
  {ARM_EXT_V6T2, 0xe8c00070, 0xfff000f0, "strexd\t%0-3r, %12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xfb000000, 0xfff000f0, "mla\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb000010, 0xfff000f0, "mls\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb700000, 0xfff000f0, "usada8\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb800000, 0xfff000f0, "smull\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfba00000, 0xfff000f0, "umull\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbc00000, 0xfff000f0, "smlal\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbe00000, 0xfff000f0, "umlal\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbe00060, 0xfff000f0, "umaal\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xe8500f00, 0xfff00f00, "ldrex\t%12-15r, [%16-19r, #%0-7W]"},
  {ARM_EXT_V6T2, 0xf7f08000, 0xfff0f000, "smi\t%K"},
  {ARM_EXT_V6T2, 0xf04f0000, 0xfbef8000, "mov%20's.w\t%8-11r, %M"},
  {ARM_EXT_V6T2, 0xf06f0000, 0xfbef8000, "mvn%20's.w\t%8-11r, %M"},
  {ARM_EXT_V6T2, 0xf810f000, 0xff70f000, "pld\t%a"},
  {ARM_EXT_V6T2, 0xfb200000, 0xfff000e0, "smlad%4'x\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb300000, 0xfff000e0, "smlaw%4?tb\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb400000, 0xfff000e0, "smlsd%4'x\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb500000, 0xfff000e0, "smmla%4'r\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfb600000, 0xfff000e0, "smmls%4'r\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfbc000c0, 0xfff000e0, "smlald%4'x\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xfbd000c0, 0xfff000e0, "smlsld%4'x\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xeac00000, 0xfff08030, "pkhbt\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeac00020, 0xfff08030, "pkhtb\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xf3400000, 0xfff08020, "sbfx\t%8-11r, %16-19r, %F"},
  {ARM_EXT_V6T2, 0xf3c00000, 0xfff08020, "ubfx\t%8-11r, %16-19r, %F"},
  {ARM_EXT_V6T2, 0xf8000e00, 0xff900f00, "str%wt\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xfb100000, 0xfff000c0, "smla%5?tb%4?tb\t%8-11r, %16-19r, %0-3r, %12-15r"},
  {ARM_EXT_V6T2, 0xfbc00080, 0xfff000c0, "smlal%5?tb%4?tb\t%12-15r, %8-11r, %16-19r, %0-3r"},
  {ARM_EXT_V6T2, 0xf3600000, 0xfff08020, "bfi\t%8-11r, %16-19r, %E"},
  {ARM_EXT_V6T2, 0xf8100e00, 0xfe900f00, "ldr%wt\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf3000000, 0xffd08020, "ssat\t%8-11r, #%0-4d, %16-19r%s"},
  {ARM_EXT_V6T2, 0xf3800000, 0xffd08020, "usat\t%8-11r, #%0-4d, %16-19r%s"},
  {ARM_EXT_V6T2, 0xee000010, 0xef1000f0, "mcr%28'2\tp%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d"},
  {ARM_EXT_V6T2, 0xee100010, 0xef1000f0, "mrc%28'2\tp%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d"},
  {ARM_EXT_V6T2, 0xf2000000, 0xfbf08000, "addw\t%8-11r, %16-19r, %I"},
  {ARM_EXT_V6T2, 0xf2400000, 0xfbf08000, "movw\t%8-11r, %J"},
  {ARM_EXT_V6T2, 0xf2a00000, 0xfbf08000, "subw\t%8-11r, %16-19r, %I"},
  {ARM_EXT_V6T2, 0xf2c00000, 0xfbf08000, "movt\t%8-11r, %J"},
  {ARM_EXT_V6T2, 0xea000000, 0xffe08000, "and%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea200000, 0xffe08000, "bic%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea400000, 0xffe08000, "orr%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea600000, 0xffe08000, "orn%20's\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xea800000, 0xffe08000, "eor%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb000000, 0xffe08000, "add%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb400000, 0xffe08000, "adc%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeb600000, 0xffe08000, "sbc%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xeba00000, 0xffe08000, "sub%20's.w\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xebc00000, 0xffe08000, "rsb%20's\t%8-11r, %16-19r, %S"},
  {ARM_EXT_V6T2, 0xe8400000, 0xfff00000, "strex\t%8-11r, %12-15r, [%16-19r, #%0-7W]"},
  {ARM_EXT_V6T2, 0xee000000, 0xef0000f0, "cdp%28'2\tp%8-11d, %20-23d, cr%12-15d, cr%16-19d, cr%0-3d"},
  {ARM_EXT_V6T2, 0xec400000, 0xeff00000, "mcrr%28'2\tp%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
  {ARM_EXT_V6T2, 0xec500000, 0xeff00000, "mrrc%28'2\tp%8-11d, %4-7d, %12-15r, %16-19r, cr%0-3d"},
  {ARM_EXT_V6T2, 0xf0000000, 0xfbe08000, "and%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0200000, 0xfbe08000, "bic%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0400000, 0xfbe08000, "orr%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0600000, 0xfbe08000, "orn%20's\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf0800000, 0xfbe08000, "eor%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1000000, 0xfbe08000, "add%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1400000, 0xfbe08000, "adc%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1600000, 0xfbe08000, "sbc%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1a00000, 0xfbe08000, "sub%20's.w\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xf1c00000, 0xfbe08000, "rsb%20's\t%8-11r, %16-19r, %M"},
  {ARM_EXT_V6T2, 0xe8800000, 0xffd00000, "stmia.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe8900000, 0xffd00000, "ldmia.w\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9000000, 0xffd00000, "stmdb\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9100000, 0xffd00000, "ldmdb\t%16-19r%21'!, %m"},
  {ARM_EXT_V6T2, 0xe9c00000, 0xffd000ff, "strd\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9d00000, 0xffd000ff, "ldrd\t%12-15r, %8-11r, [%16-19r]"},
  {ARM_EXT_V6T2, 0xe9400000, 0xff500000, "strd\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]"},
  {ARM_EXT_V6T2, 0xe9500000, 0xff500000, "ldrd\t%12-15r, %8-11r, [%16-19r, #%23`-%0-7W]"},
  {ARM_EXT_V6T2, 0xee000010, 0xef100010, "mcr%28'2\tp%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, %5-7d"},
  {ARM_EXT_V6T2, 0xee100010, 0xef100010, "mrc%28'2\tp%8-11d, %21-23d, %12-15r, cr%16-19d, cr%0-3d, %5-7d"},
  {ARM_EXT_V6T2, 0xf8000000, 0xff100000, "str%w.w\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xf8100000, 0xfe100000, "ldr%w.w\t%12-15r, %a"},
  {ARM_EXT_V6T2, 0xec000000, 0xee100000, "stc%28'2%22'l\tp%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V6T2, 0xec100000, 0xee100000, "ldc%28'2%22'l\tp%8-11d, cr%12-15d, %A"},
  {ARM_EXT_V6T2, 0xee000000, 0xef000010, "cdp%28'2\tp%8-11d, %20-23d, cr%12-15d, cr%16-19d, cr%0-3d, %5-7d"},

  /* Filter out Bcc with cond=E or F, which are used for other instructions.  */
  {ARM_EXT_V6T2, 0xf3c08000, 0xfbc0d000, "undefined (bcc, cond=0xF)"},
  {ARM_EXT_V6T2, 0xf3808000, 0xfbc0d000, "undefined (bcc, cond=0xE)"},
  {ARM_EXT_V6T2, 0xf0008000, 0xf800d000, "b%22-25c.w\t%b"},
  {ARM_EXT_V6T2, 0xf0009000, 0xf800d000, "b.w\t%B"},

  /* These have been 32-bit since the invention of Thumb.  */
  {ARM_EXT_V4T,  0xf000c000, 0xf800d000, "blx\t%B"},
  {ARM_EXT_V4T,  0xf000d000, 0xf800d000, "bl\t%B"},

  /* Fallback.  */
  {ARM_EXT_V1,   0x00000000, 0x00000000, "undefined"},
  {0, 0, 0, 0}
};
   

d775 1
a775 1
 "hi", "ls", "ge", "lt", "gt", "le", "", "<und>"};
d834 1
a834 3
static int  print_insn_thumb16
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb32
d1686 1
a1686 1
print_insn_thumb16 (pc, info, given)
d1696 4
a1699 13
    if ((given & insn->mask) == insn->value)
      {
	char * c = insn->assembler;
	for (; *c; c++)
	  {
	    int domaskpc = 0;
	    int domasklr = 0;

	    if (*c != '%')
	      {
		func (stream, "%c", *c);
		continue;
	      }
d1701 4
a1704 5
	    switch (*++c)
	      {
	      case '%':
		func (stream, "%%");
		break;
d1706 2
a1707 7
	      case 'S':
		{
		  long reg;

		  reg = (given >> 3) & 0x7;
		  if (given & (1 << 6))
		    reg += 8;
d1709 2
a1710 3
		  func (stream, "%s", arm_regnames[reg]);
		}
		break;
d1712 1
a1712 1
	      case 'D':
d1714 2
a1715 7
		  long reg;

		  reg = given & 0x7;
		  if (given & (1 << 7))
		    reg += 8;

		  func (stream, "%s", arm_regnames[reg]);
d1717 2
a1718 1
		break;
d1720 198
a1917 567
	      case 'N':
		if (given & (1 << 8))
		  domasklr = 1;
		/* Fall through.  */
	      case 'O':
		if (*c == 'O' && (given & (1 << 8)))
		  domaskpc = 1;
		/* Fall through.  */
	      case 'M':
		{
		  int started = 0;
		  int reg;

		  func (stream, "{");

		  /* It would be nice if we could spot
		     ranges, and generate the rS-rE format: */
		  for (reg = 0; (reg < 8); reg++)
		    if ((given & (1 << reg)) != 0)
		      {
			if (started)
			  func (stream, ", ");
			started = 1;
			func (stream, "%s", arm_regnames[reg]);
		      }

		  if (domasklr)
		    {
		      if (started)
			func (stream, ", ");
		      started = 1;
		      func (stream, arm_regnames[14] /* "lr" */);
		    }

		  if (domaskpc)
		    {
		      if (started)
			func (stream, ", ");
		      func (stream, arm_regnames[15] /* "pc" */);
		    }

		  func (stream, "}");
		}
		break;

	      case 'b':
		/* Print ARM V6T2 CZB address: pc+4+6 bits.  */
		{
		  bfd_vma address = (pc + 4
				     + ((given & 0x00f8) >> 2)
				     + ((given & 0x0200) >> 3));
		  info->print_address_func (address, info);
		}
		break;

	      case 's':
		/* Right shift immediate -- bits 6..10; 1-31 print
		   as themselves, 0 prints as 32.  */
		{
		  long imm = (given & 0x07c0) >> 6;
		  if (imm == 0)
		    imm = 32;
		  func (stream, "#%d", imm);
		}
		break;

	      case '0': case '1': case '2': case '3': case '4':
	      case '5': case '6': case '7': case '8': case '9':
		{
		  int bitstart = *c++ - '0';
		  int bitend = 0;

		  while (*c >= '0' && *c <= '9')
		    bitstart = (bitstart * 10) + *c++ - '0';

		  switch (*c)
		    {
		    case '-':
		      {
			long reg;

			c++;
			while (*c >= '0' && *c <= '9')
			  bitend = (bitend * 10) + *c++ - '0';
			if (!bitend)
			  abort ();
			reg = given >> bitstart;
			reg &= (2 << (bitend - bitstart)) - 1;
			switch (*c)
			  {
			  case 'r':
			    func (stream, "%s", arm_regnames[reg]);
			    break;

			  case 'd':
			    func (stream, "%d", reg);
			    break;

			  case 'H':
			    func (stream, "%d", reg << 1);
			    break;

			  case 'W':
			    func (stream, "%d", reg << 2);
			    break;

			  case 'a':
			    /* PC-relative address -- the bottom two
			       bits of the address are dropped
			       before the calculation.  */
			    info->print_address_func
			      (((pc + 4) & ~3) + (reg << 2), info);
			    break;

			  case 'x':
			    func (stream, "0x%04x", reg);
			    break;

			  case 'I':
			    reg = ((reg ^ (1 << bitend)) - (1 << bitend));
			    func (stream, "%d", reg);
			    break;

			  case 'B':
			    reg = ((reg ^ (1 << bitend)) - (1 << bitend));
			    (*info->print_address_func)
			      (reg * 2 + pc + 4, info);
			    break;

			  case 'c':
			    {
			      /* Must print 0xE as 'al' to distinguish
				 unconditional B from conditional BAL.  */
			      if (reg == 0xE)
				func (stream, "al");
			      else
				func (stream, "%s", arm_conditional [reg]);
			    }
			    break;

			  default:
			    abort ();
			  }
		      }
		      break;

		    case '\'':
		      c++;
		      if ((given & (1 << bitstart)) != 0)
			func (stream, "%c", *c);
		      break;

		    case '?':
		      ++c;
		      if ((given & (1 << bitstart)) != 0)
			func (stream, "%c", *c++);
		      else
			func (stream, "%c", *++c);
		      break;

		    default:
		      abort ();
		    }
		}
		break;

	      default:
		abort ();
	      }
	  }
	return 2;
      }

  /* No match.  */
  abort ();
}

static int
print_insn_thumb32 (pc, info, given)
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
{
  const struct arm_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;

  for (insn = thumb32_opcodes; insn->assembler; insn++)
    if ((given & insn->mask) == insn->value)
      {
	char * c = insn->assembler;
	for (; *c; c++)
	  {
	    if (*c != '%')
	      {
		func (stream, "%c", *c);
		continue;
	      }

	    switch (*++c)
	      {
	      case '%':
		func (stream, "%%");
		break;

	      case 'I':
		{
		  unsigned int imm12 = 0;
		  imm12 |= (given & 0x000000ffu);
		  imm12 |= (given & 0x00007000u) >> 4;
		  imm12 |= (given & 0x04000000u) >> 12;
		  func (stream, "#%u\t; 0x%x", imm12, imm12);
		}
		break;

	      case 'M':
		{
		  unsigned int bits = 0, imm, imm8, mod;
		  bits |= (given & 0x000000ffu);
		  bits |= (given & 0x00007000u) >> 4;
		  bits |= (given & 0x04000000u) >> 15;
		  imm8 = (bits & 0x0ff);
		  mod = (bits & 0xf00) >> 8;
		  switch (mod)
		    {
		    case 0: imm = imm8; break;
		    case 1: imm = ((imm8<<16) | imm8); break;
		    case 2: imm = ((imm8<<24) | (imm8 << 8)); break;
		    case 3: imm = ((imm8<<24) | (imm8 << 16) | (imm8 << 8) | imm8); break;
		    default:
		      mod  = (bits & 0xf80) >> 7;
		      imm8 = (bits & 0x07f) | 0x80;
		      imm  = (((imm8 << (32 - mod)) | (imm8 >> mod)) & 0xffffffff);
		    }
		  func (stream, "#%u\t; 0x%x", imm, imm);
		}
		break;
		  
	      case 'J':
		{
		  unsigned int imm = 0;
		  imm |= (given & 0x000000ffu);
		  imm |= (given & 0x00007000u) >> 4;
		  imm |= (given & 0x04000000u) >> 15;
		  imm |= (given & 0x000f0000u) >> 4;
		  func (stream, "#%u\t; 0x%x", imm, imm);
		}
		break;

	      case 'K':
		{
		  unsigned int imm = 0;
		  imm |= (given & 0x000f0000u) >> 16;
		  imm |= (given & 0x00000ff0u) >> 0;
		  imm |= (given & 0x0000000fu) << 12;
		  func (stream, "#%u\t; 0x%x", imm, imm);
		}
		break;

	      case 'S':
		{
		  unsigned int reg = (given & 0x0000000fu);
		  unsigned int stp = (given & 0x00000030u) >> 4;
		  unsigned int imm = 0;
		  imm |= (given & 0x000000c0u) >> 6;
		  imm |= (given & 0x00007000u) >> 10;

		  func (stream, "%s", arm_regnames[reg]);
		  switch (stp)
		    {
		    case 0:
		      if (imm > 0)
			func (stream, ", lsl #%u", imm);
		      break;

		    case 1:
		      if (imm == 0)
			imm = 32;
		      func (stream, ", lsr #%u", imm);
		      break;

		    case 2:
		      if (imm == 0)
			imm = 32;
		      func (stream, ", asr #%u", imm);
		      break;

		    case 3:
		      if (imm == 0)
			func (stream, ", rrx");
		      else
			func (stream, ", ror #%u", imm);
		    }
		}
		break;

	      case 'a':
		{
		  unsigned int Rn  = (given & 0x000f0000) >> 16;
		  unsigned int U   = (given & 0x00800000) >> 23;
		  unsigned int op  = (given & 0x00000f00) >> 8;
		  unsigned int i12 = (given & 0x00000fff);
		  unsigned int i8  = (given & 0x000000ff);

		  func (stream, "[%s", arm_regnames[Rn]);
		  if (U) /* 12-bit positive immediate offset */
		    {
		      if (i12)
			func (stream, ", #%u", i12);
		      func (stream, "]");
		    }
		  else if (Rn == 15) /* 12-bit negative immediate offset */
		    func (stream, ", #-%u]", i12);
		  else switch (op)
		    {
		    case 0x0:  /* shifted register offset */
		      {
			unsigned int Rm = (i8 & 0x0f);
			unsigned int sh = (i8 & 0x30) >> 4;
			func (stream, ", %s", arm_regnames[Rm]);
			if (sh)
			  func (stream, ", lsl #%u", sh);
			func (stream, "]");
		      }
		      break;

		    case 0xE:  /* 8-bit positive immediate offset */
		      if (i8)
			func (stream, ", #%u", i8);
		      func (stream, "]");
		      break;

		    case 0xC:  /* 8-bit negative immediate offset */
		      func (stream, ", #-%u]", i8);
		      break;

		    case 0xB:  /* 8-bit + preindex with wb */
		      if (i8)
			func (stream, ", #%u", i8);
		      func (stream, "]!");
		      break;

		    case 0x9:  /* 8-bit - preindex with wb */
		      func (stream, ", #-%u]!", i8);
		      break;

		    case 0xF:  /* 8-bit + postindex */
		      func (stream, "], #%u", i8);
		      break;

		    case 0xD:  /* 8-bit - postindex */
		      func (stream, "], #-%u", i8);
		      break;

		    default:
		      func (stream, ", <undefined>]");
		    }
		}
		break;

	      case 'A':
		{
		  unsigned int P   = (given & 0x01000000) >> 24;
		  unsigned int U   = (given & 0x00800000) >> 23;
		  unsigned int W   = (given & 0x00400000) >> 21;
		  unsigned int Rn  = (given & 0x000f0000) >> 16;
		  unsigned int off = (given & 0x000000ff);

		  func (stream, "[%s", arm_regnames[Rn]);
		  if (P)
		    {
		      if (off || !U)
			func (stream, ", #%c%u", U ? '+' : '-', off * 4);
		      func (stream, "]");
		      if (W)
			func (stream, "!");
		    }
		  else
		    {
		      func (stream, "], ");
		      if (W)
			func (stream, "#%c%u", U ? '+' : '-', off * 4);
		      else
			func (stream, "{%u}", off);
		    }
		}
		break;

	      case 'w':
		{
		  unsigned int Sbit = (given & 0x01000000) >> 24;
		  unsigned int type = (given & 0x00600000) >> 21;
		  switch (type)
		    {
		    case 0: func (stream, Sbit ? "sb" : "b"); break;
		    case 1: func (stream, Sbit ? "sh" : "h"); break;
		    case 2:
		      if (Sbit)
			func (stream, "??");
		      break;
		    case 3:
		      func (stream, "??");
		      break;
		    }
		}
		break;

	      case 'm':
		{
		  int started = 0;
		  int reg;

		  func (stream, "{");
		  for (reg = 0; reg < 16; reg++)
		    if ((given & (1 << reg)) != 0)
		      {
			if (started)
			  func (stream, ", ");
			started = 1;
			func (stream, "%s", arm_regnames[reg]);
		      }
		  func (stream, "}");
		}
		break;

	      case 'E':
		{
		  unsigned int msb = (given & 0x0000001f);
		  unsigned int lsb = 0;
		  lsb |= (given & 0x000000c0u) >> 6;
		  lsb |= (given & 0x00007000u) >> 10;
		  func (stream, "#%u, #%u", lsb, msb - lsb + 1);
		}
		break;

	      case 'F':
		{
		  unsigned int width = (given & 0x0000001f) + 1;
		  unsigned int lsb = 0;
		  lsb |= (given & 0x000000c0u) >> 6;
		  lsb |= (given & 0x00007000u) >> 10;
		  func (stream, "#%u, #%u", lsb, width);
		}
		break;

	      case 'b':
		{
		  unsigned int S = (given & 0x04000000u) >> 26;
		  unsigned int J1 = (given & 0x00002000u) >> 13;
		  unsigned int J2 = (given & 0x00000800u) >> 11;
		  unsigned int offset = 0;

		  offset |= !S << 20;
		  offset |= J2 << 19;
		  offset |= J1 << 18;
		  offset |= (given & 0x003f0000) >> 4;
		  offset |= (given & 0x000007ff) << 1;
		  offset -= (1 << 20);

		  info->print_address_func ((bfd_vma)offset + pc + 4, info);
		}
		break;

	      case 'B':
		{
		  unsigned int S = (given & 0x04000000u) >> 26;
		  unsigned int I1 = (given & 0x00002000u) >> 13;
		  unsigned int I2 = (given & 0x00000800u) >> 11;
		  unsigned int offset = 0;

		  offset |= !S << 24;
		  offset |= !(I1 ^ S) << 23;
		  offset |= !(I2 ^ S) << 22;
		  offset |= (given & 0x03ff0000u) >> 4;
		  offset |= (given & 0x000007ffu) << 1;
		  offset -= (1 << 24);

		  info->print_address_func ((bfd_vma)offset + pc + 4, info);
		}
		break;

	      case 's':
		{
		  unsigned int shift = 0;
		  shift |= (given & 0x000000c0u) >> 6;
		  shift |= (given & 0x00007000u) >> 10;
		  if (given & 0x00200000u)
		    func (stream, ", asr #%u", shift);
		  else if (shift)
		    func (stream, ", lsl #%u", shift);
		  /* else print nothing - lsl #0 */
		}
		break;

	      case 'R':
		{
		  unsigned int rot = (given & 0x00000030) >> 4;
		  if (rot)
		    func (stream, ", ror #%u", rot * 8);
		}
		break;

	      case '0': case '1': case '2': case '3': case '4':
	      case '5': case '6': case '7': case '8': case '9':
		{
		  int bitstart = *c++ - '0';
		  int bitend = 0;
		  unsigned int val;
		  while (*c >= '0' && *c <= '9')
		    bitstart = (bitstart * 10) + *c++ - '0';

		  if (*c == '-')
		    {
		      c++;
		      while (*c >= '0' && *c <= '9')
			bitend = (bitend * 10) + *c++ - '0';
		      if (!bitend)
			abort ();

		      val = given >> bitstart;
		      val &= (2 << (bitend - bitstart)) - 1;
		    }
		  else
		    val = (given >> bitstart) & 1;

		  switch (*c)
		    {
		    case 'd': func (stream, "%u", val); break;
		    case 'W': func (stream, "%u", val * 4); break;
		    case 'r': func (stream, "%s", arm_regnames[val]); break;

		    case 'c':
		      if (val == 0xE)
			func (stream, "al");
		      else
			func (stream, "%s", arm_conditional[val]);
		      break;

		    case '\'':
		      if (val)
			func (stream, "%c", c[1]);
		      c++;
		      break;
		      
		    case '`':
		      if (!val)
			func (stream, "%c", c[1]);
		      c++;
		      break;

		    case '?':
		      func (stream, "%c", val ? c[1] : c[2]);
		      c += 2;
		      break;

		    default:
		      abort ();
		    }
		}
		break;

	      default:
		abort ();
	      }
	  }
	return 4;
      }
d2009 4
a2012 5
  unsigned char b[4];
  long		given;
  int           status;
  int           is_thumb;
  int	 	(*printer) (bfd_vma, struct disassemble_info *, long);
d2049 1
a2050 1
  info->bytes_per_line = 4;
d2052 1
a2052 1
  if (!is_thumb)
d2054 17
a2070 10
      /* In ARM mode endianness is a straightforward issue: the instruction
	 is four bytes long and is either ordered 0123 or 3210.  */
      printer = print_insn_arm;
      info->bytes_per_chunk = 4;

      status = info->read_memory_func (pc, (bfd_byte *)b, 4, info);
      if (little)
	given = (b[0]) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
      else
	given = (b[3]) | (b[2] << 8) | (b[1] << 16) | (b[0] << 24);
d2074 3
a2076 8
      /* In Thumb mode we have the additional wrinkle of two
	 instruction lengths.  Fortunately, the bits that determine
	 the length of the current instruction are always to be found
	 in the first two bytes.  */

      info->bytes_per_chunk = 2;
      status = info->read_memory_func (pc, (bfd_byte *)b, 2, info);
      if (!status)
d2078 3
a2080 4
	  if (little)
	    given = (b[0]) | (b[1] << 8);
	  else
	    given = (b[1]) | (b[0] << 8);
d2082 3
a2084 5
	  /* These bit patterns signal a four-byte Thumb
	     instruction.  */
	  if ((given & 0xF800) == 0xF800
	      || (given & 0xF800) == 0xF000
	      || (given & 0xF800) == 0xE800)
d2086 6
a2091 3
	      status = info->read_memory_func (pc + 2, (bfd_byte *)b, 2, info);
	      if (little)
		given = (b[0]) | (b[1] << 8) | (given << 16);
d2093 1
a2093 3
		given = (b[1]) | (b[0] << 8) | (given << 16);

	      printer = print_insn_thumb32;
d2096 1
a2096 1
	    printer = print_insn_thumb16;
d2098 2
a2101 5
  if (status)
    {
      info->memory_error_func (status, pc, info);
      return -1;
    }
d2110 12
a2121 1
  return printer (pc, info, given);
@


1.41.4.3
log
@2005-05-01  Zack Weinberg  <zack@@codesourcery.com>

	* gas/config/tc-arm.c (encode_thumb32_addr_mode): Set inst.reloc.pc_rel
	if is_pc.
	(T16_32_TAB): Delete unused entry for BLX.
	(do_t_ldst): Don't offset inst.reloc.exp.X_add_number for PC-relative
	addressing.
	(md_pcrel_from): Report the adjusted PC for
	BFD_RELOC_ARM_THUMB_OFFSET and BFD_RELOC_ARM_T32_OFFSET_IMM.
	(md_apply_fix3): Correct bitmasks for BFD_RELOC_ARM_T32_OFFSET_IMM.
	Do not round up value for PC-relative BFD_RELOC_ARM_THUMB_OFFSET.

	* gas/testsuite/gas/arm/thumb.s: Test PC-relative ldr more thoroughly.
	* gas/testsuite/gas/arm/thumb.d: Update to match.

	* gas/testsuite/gas/arm/thumb32.s: Properly align labels that
	will be targeted by blx instructions.
	* gas/testsuite/gas/arm/thumb32.d: Update to match.  Correct
	expected dissassembly of PC-relative ldr.

	* gas/testsuite/gas/arm/macro1.s: Add leading label and
	trailing padding for a.out compatibility.
	* gas/testsuite/gas/arm/macro1.d: Update to match.
	* gas/testsuite/gas/arm/tcompat2.s: Add trailing padding for a.out
	compatibility.
	* gas/testsuite/gas/arm/tcompat2.d: Update to match.

	* opcodes/arm-dis.c (print_insn_thumb32): Reorganize %a and %A
	handling.  Call info->print_address_func when %a/%A are applied
	to a PC-relative instruction.
@
text
@a2280 2
		  bfd_boolean writeback = FALSE, postind = FALSE;
		  int offset = 0;
a2283 4
		    offset = i12;
		  else if (Rn == 15) /* 12-bit negative immediate offset */
		    offset = -(int)i12;
		  else if (op == 0x0) /* shifted register offset */
d2285 2
a2286 5
		      unsigned int Rm = (i8 & 0x0f);
		      unsigned int sh = (i8 & 0x30) >> 4;
		      func (stream, ", %s", arm_regnames[Rm]);
		      if (sh)
			func (stream, ", lsl #%u", sh);
a2287 1
		      break;
d2289 2
d2293 11
d2305 3
a2307 1
		      offset = i8;
d2311 1
a2311 1
		      offset = -i8;
d2315 3
a2317 2
		      offset = i8;
		      writeback = TRUE;
d2321 1
a2321 2
		      offset = -i8;
		      writeback = TRUE;
d2325 1
a2325 2
		      offset = i8;
		      postind = TRUE;
d2329 1
a2329 2
		      offset = -i8;
		      postind = TRUE;
a2333 16
		      goto skip;
		    }

		  if (postind)
		    func (stream, "], #%d", offset);
		  else
		    {
		      if (offset)
			func (stream, ", #%d", offset);
		      func (stream, writeback ? "]!" : "]");
		    }

		  if (Rn == 15)
		    {
		      func (stream, "\t; ");
		      info->print_address_func (((pc + 4) & ~3) + offset, info);
a2335 1
	      skip:
d2428 1
a2428 1
		  int offset = 0;
d2437 1
a2437 1
		  info->print_address_func (pc + 4 + offset, info);
d2446 1
a2446 1
		  int offset = 0;
d2455 1
a2455 1
		  info->print_address_func (pc + 4 + offset, info);
@


1.41.4.4
log
@2005-05-01  Zack Weinberg  <zack@@codesourcery.com>

	* gas/config/tc-arm.c (thumb32_mode): Rename unified_syntax.
	All uses changed to match.
	(COND_ALWAYS): Don't offset.
	(COND_MASK): Delete.
	(struct arm_it): Add cond field.
	(struct asm_opcode): Add tag field.  Change some fields to
	unsigned int and/or to bitfields.
	(my_get_expression): If unified_syntax, always treat the
	prefix as optional.
	(s_thumb32, s_thumb32_func): Delete.
	(opcode_select, s_force_thumb): Don't set thumb32_mode.
	(s_syntax): New function.
	(md_pseudo_table): Update to match.
	(do_blx, do_iwmmxt_wldstw): Look at inst.cond, not
	inst.instruction, for the condition.
	(do_it): New function.
	(do_t_branch): Get the condition from inst.cond and patch it
	into the appropriate place.
	(output_inst): If inst.size == 0, output nothing, but do issue
	a diagnostic if any.
	(enum opcode_tag): New set of constants.
	(opcode_lookup): New function.
	(md_assemble): Use opcode_lookup.  Restructure a little.
	(conds, OPS0): Adjust comment.
	(TxCE, TxCM, TUE, TUF): Rewrite.
	(TCC): Delete.
	(TxC3, TC3, tC3, TxCM_, C3, C3E): New notational macros.

	(insns): Use TC3, tC3, or C3, as appropriate, for all
	instructions where the conditional infix appears after the
	third letter of the mnemonic.  Use TCE for 'b'.  Use C3E for
	'cmfe' and 'cnfe'.  Change 'czbne' to 'cbnz', 'czbeq' to 'cbz'.
	Use TUE, with a dummy ARM opcode, for all variants of 'it'.

	* opcodes/arm-dis.c: Change 'czbne' to 'cbnz', 'czbeq' to 'cbz'.

	* gas/testsuite/gas/arm/thumb.d: bal.n is no longer
	distinguishable from b.n.
	* gas/testsuite/gas/arm/thumb32.d: Likewise.  Change 'czbne'
	to 'cbnz', 'czbeq' to 'cbz'.
	* gas/testsuite/gas/arm/thumb32.s: Use .syntax unified.
	Change 'czbne' to 'cbnz', 'czbeq' to 'cbz'.
@
text
@d648 2
a649 2
  {ARM_EXT_V6T2, 0xb900, 0xfd00, "cbnz\t%0-2r, %b"},
  {ARM_EXT_V6T2, 0xb100, 0xfd00, "cbz\t%0-2r, %b"},
@


1.40
log
@* arm-opc.h (arm_opcode, thumb_opcode): Add extra field for the
architecuture defining the insn.
(arm_opcodes, thumb_opcodes): Delete.  Move to ...
* arm-dis.c (arm_opcodes, thumb_opcodes): Here.
Also include opcode/arm.h.
* Makefile.am (arm-dis.lo): Update dependency list.
* Makefile.in: Regenerate.
@
text
@d52 1
a52 1
/* Format of the assembler string :
@


1.39
log
@bfd/
	* elf32-arm.c (PLT_THUMB_STUB_SIZE): Define.
	(elf32_arm_plt_thumb_stub): New.
	(struct elf32_arm_link_hash_entry): Add plt_thumb_refcount
	and plt_got_offset.
	(elf32_arm_link_hash_traverse): Fix typo.
	(elf32_arm_link_hash_table): Add obfd.
	(elf32_arm_link_hash_newfunc): Initialize new fields.
	(elf32_arm_copy_indirect_symbol): Copy plt_thumb_refcount.
	(elf32_arm_link_hash_table_create): Initialize obfd.
	(record_arm_to_thumb_glue): Mark the glue as a local ARM function.
	(record_thumb_to_arm_glue): Mark the glue as a local Thumb function.
	(bfd_elf32_arm_get_bfd_for_interworking): Verify that the
	interworking BFD is not dynamic.
	(bfd_elf32_arm_process_before_allocation): Handle R_ARM_PLT32.  Do
	not emit glue for PLT references.
	(elf32_arm_final_link_relocate): Handle Thumb functions.  Do not
	emit glue for PLT references.  Support the Thumb PLT prefix.
	(elf32_arm_gc_sweep_hook): Handle R_ARM_THM_PC22 and
	plt_thumb_refcount.
	(elf32_arm_check_relocs): Likewise.
	(elf32_arm_adjust_dynamic_symbol): Handle Thumb functions and
	plt_thumb_refcount.
	(allocate_dynrelocs): Handle Thumb PLT references.
	(elf32_arm_finish_dynamic_symbol): Likewise.
	(elf32_arm_symbol_processing): New function.
	(elf_backend_symbol_processing): Define.
opcodes/
	* arm-dis.c (WORD_ADDRESS): Define.
	(print_insn): Use it.  Correct big-endian end-of-section handling.
gas/testsuite/
	* gas/arm/mapping.d: Expect F markers for Thumb code.
	* gas/arm/unwind.d: Update big-endian pattern.
ld/
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Don't use
	a dynamic object for stubs.
ld/testsuite/
	* ld-arm/mixed-app.d, ld-arm/mixed-app.r, ld-arm/mixed-app.s,
	ld-arm/mixed-app.sym, ld-arm/mixed-lib.d, ld-arm/mixed-lib.r,
	ld-arm/mixed-lib.s, ld-arm/mixed-lib.sym, ld-arm/arm-dyn.ld,
	ld-arm/arm-lib.ld: New files.
	* ld-arm/arm-app-abs32.d, ld-arm/arm-app-abs32.r, ld-arm/arm-app.d,
	ld-arm/arm-app.r, ld-arm/arm-lib-plt32.d, ld-arm/arm-lib-plt32.r,
	ld-arm/arm-lib.d, ld-arm/arm-lib.r, ld-arm/arm-static-app.d,
	ld-arm/arm-static-app.r: Update for big-endian.
	* ld-arm/arm-elf.exp: Run the new tests.
@
text
@d24 1
d26 1
a26 1
#define DEFINE_TABLE
d52 701
@


1.38
log
@Apply Paul Brook's patch to implement armv6k instructions
@
text
@d49 2
d1258 1
a1258 1
  int                is_thumb;
d1304 1
d1321 1
a1321 1
	(pc & ~ 0x3, (bfd_byte *) &b[0], 4, info);
d1324 1
a1324 1
	  info->memory_error_func (status, pc, info);
d1335 1
a1335 1
		((pc + 4) & ~ 0x3, (bfd_byte *) b, 4, info);
d1337 3
a1339 6
		{
		  info->memory_error_func (status, pc + 4, info);
		  return -1;
		}

	      given |= (b[0] << 24) | (b[1] << 16);
d1361 6
@


1.37
log
@	* gas/arm/arm.exp: Add archv6 and thumbv6.
	* gas/arm/archv6.d: New file.
	* gas/arm/archv6.s: Likewise.
	* gas/arm/thumbv6.d: Likewise.
	* gas/arm/thumbv6.s: Likewise.

	Add V6 support.
	* config/tc-arm.c (ARM_EXT_V6): New macro.
	(ARM_ARCH_V6): Likewise.
	(SHIFT_IMMEDIATE): Likewise.
	(SHIFT_LSL_OR_ASR_IMMEDIATE): Likewise.
	(SHIFT_ASR_IMMEDIATE): Likewise.
	(SHIFT_LSL_IMMMEDIATE): Likewise.
	(do_cps): New function.
	(do_cpsi): Likewise.
	(do_ldrex): Likewise.
	(do_pkhbt): Likewise.
	(do_pkhtb): Likewise.
	(do_qadd16): Likewise.
	(do_rev): Likewise.
	(do_rfe): Likewise.
	(do_sxtah): Likewise.
	(do_sxth): Likewise.
	(do_setend): Likewise.
	(do_smlad): Likewise.
	(do_smlald): Likewise.
	(do_smmul): Likewise.
	(do_ssat): Likewise.
	(do_usat): Likewise.
	(do_srs): Likewise.
	(do_ssat16): Likewise.
	(do_usat16): Likewise.
	(do_strex): Likewise.
	(do_umaal): Likewise.
	(do_cps_mode): Likewise.
	(do_cps_flags): Likewise.
	(do_endian_specifier): Likewise.
	(do_pkh_core): Likewise.
	(do_sat): Likewise.
	(do_sat16): Likewise.
	(insns): Add V6 instructions.
	(do_t_cps): New function.
	(do_t_cpy): Likewise.
	(do_t_setend): Likewise.
	(THUMB_CPY): New macro.
	(tinsns): Add V6 instructions.
	(decode_shift): Handle V6 restricted-shift options.
	(thumb_mov_compare): Support CPY.
	(arm_cores): Add arm1136js and arm1136jfs.
	(arm_archs): Add armv6.
	(arm_fpus): Add arm1136jfs.
	* doc/c-arm.texi (ARM Options): Mention arm1136js, arm1136jfs, and
	armv6 options.

	* gas/arm/arm.exp: Add archv6 and thumbv6.
	* gas/arm/archv6.d: New file.
	* gas/arm/archv6.s: Likewise.
	* gas/arm/thumbv6.d: Likewise.
	* gas/arm/thumbv6.s: Likewise.

	* arm-dis.c (print_arm_insn): Add 'W' macro.
	* arm-opc.h (arm_opcodes): Add V6 instructions.
	(thumb_opcodes): Likewise.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d903 9
@


1.36
log
@Add new field to disassemble_info structure: symbol_is_valid() and use it to
skip displaying arm elf mapping symbols in disassembly output.
@
text
@d642 10
@


1.35
log
@	* arm-dis.c (print_arm_insn): Print "-" after "#".
@
text
@d1148 17
@


1.34
log
@Add support for unindexed form of Addressing Mode 5
@
text
@d289 1
a289 1
				    func (stream, ", %s#%d",
d310 1
a310 1
				    func (stream, "], %s#%d",
d353 1
a353 1
				    func (stream, ", %s#%d",
d377 1
a377 1
				    func (stream, "], %s#%d",
d454 1
a454 1
			    func (stream, ", %s#%d]%s",
d470 1
a470 1
				func (stream, ", %s#%d",
d879 1
a879 1
				func (stream, ", %s#%d]%s",
d884 1
a884 1
				func (stream, "], %s#%d",
@


1.33
log
@* objdump.c (main) :Accept multiple -M switch.
* doc/binutils.texi: Document that multiple -M switches are accepted and that
  a single -M switch can contain comma separated options.
* arm-dis.c (parse_arm_disassembler_option): Do not expect option string to be
  NUL terminated.
  (parse_disassembler_options): Allow options to be space or comma separated.
@
text
@d448 2
a449 1
		      if ((given & 0x01000000) != 0)
d452 1
d464 10
a473 4
			  if (offset)
			    func (stream, "], %s#%d",
				  ((given & 0x00800000) == 0 ? "-" : ""),
				  offset * 4);
d475 1
a475 1
			    func (stream, "]");
@


1.32
log
@Fixes for iWMMXt contribution.
@
text
@d30 1
d1156 1
a1156 1
	if (streq (option, regnames[i].name))
d1163 1
d1166 1
a1166 1
  else if (streq (option, "force-thumb"))
d1168 1
a1168 1
  else if (streq (option, "no-force-thumb"))
d1171 1
d1177 2
a1178 1
/* Parse the string of disassembler options, spliting it at whitespaces.  */
a1183 2
  char * space;

d1187 1
a1187 1
  do
d1189 1
a1189 1
      space = strchr (options, ' ');
d1191 6
a1196 9
      if (space)
	{
	  * space = '\0';
	  parse_arm_disassembler_option (options);
	  * space = ' ';
	  options = space + 1;
	}
      else
	parse_arm_disassembler_option (options);
a1197 1
  while (space);
@


1.31
log
@Add iWMMXt support
@
text
@d74 1
a74 1
  { "iwmmxt_regnames", "Select register names used on the Intel(r) Wireless MMX(tm) technology coprocessor",
d76 1
a76 1
  { "iwmmxt_Cregnames", "Select control register names used on the Intel(r) Wireless MMX(tm) technology coprocessor",
@


1.30
log
@	* arm-dis.c (print_insn_arm): Constify "insn".  Formatting.
	(print_insn_thumb): Likewise.
	* h8500-dis.c (print_insn_h8500): Constify "opcode".
	* mcore-dis.c (print_insn_mcore): Constify "op".  Formatting.
	* ns32k-dis.c (print_insn_arg <case 'F'>): Use a union to avoid
	type-punned pointer warnings.
	<case 'L'>: Likewise.  Fix error message too.
	* pdp11-dis.c (print_reg): Warning fix.
	* sh-dis.c (print_movxy): Constify "op" param.
	(print_insn_ddt): Constify sh_opcode_info vars.
	(print_insn_ppi): Likewise.
	(print_insn_sh): Likewise.
	* tic30-dis.c (cnvt_tmsfloat_ieee): Use a union to avoid
	type-punned pointer warnings.
	* w65-dis.c (print_insn_w65): Constify "op".
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d7 1
a7 1
This file is part of libopcodes.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d73 15
a87 1
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }}
d115 9
a123 5
int get_arm_regname_num_options (void);
int set_arm_regname_option (int option);
int get_arm_regnames (int option, const char **setname,
		      const char **setdescription,
		      const char ***register_names);
d188 18
d218 1
d222 5
d674 57
d834 48
@


1.29
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d175 3
a177 3
     bfd_vma                   pc;
     struct disassemble_info * info;
     long                      given;
d179 3
a181 3
  struct arm_opcode *  insn;
  void *               stream = info->stream;
  fprintf_ftype        func   = info->fprintf_func;
d756 3
a758 3
     bfd_vma                   pc;
     struct disassemble_info * info;
     long                      given;
d760 3
a762 3
  struct thumb_opcode * insn;
  void *                stream = info->stream;
  fprintf_ftype         func = info->fprintf_func;
@


1.28
log
@Fix handling of BLX instruction to conform to Operations definition in the
ARM ARM.
@
text
@d7 1
a7 1
This file is part of libopcodes. 
d12 1
a12 1
any later version. 
d17 1
a17 1
more details. 
d82 1
a82 1
static boolean force_thumb = false;
d87 1
a87 1
static char * arm_shift[] = 
d91 10
a100 5
static void arm_decode_shift PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm   PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options PARAMS ((char *));
static int  print_insn       PARAMS ((bfd_vma, struct disassemble_info *, boolean));
d143 1
a143 1
  
d150 1
a150 1
	  
d158 1
a158 1
	      
d161 1
a161 1
	  
d188 1
a188 1
	  
d204 1
a204 1
			  
d206 1
a206 1
 
d211 1
a211 1
			  
d232 1
a232 1
			  
d238 1
a238 1
			  func (stream, "[%s", 
d258 1
a258 1
			      func (stream, "]%s", 
d270 1
a270 1
				  else 
d276 1
a276 1
					(((given & 0x00800000) == 0) 
d289 1
a289 1
			  
d292 1
a292 1
			  
d294 1
a294 1
			  
d300 1
a300 1
			  func (stream, "[%s", 
d323 1
a323 1
			      func (stream, "]%s", 
d337 1
a337 1
				  else 
d351 1
a351 1
			  
d433 1
a433 1
			
d442 1
a442 1
			
d498 1
a498 1
			
d550 1
a550 1
		    case '0': case '1': case '2': case '3': case '4': 
d562 1
a562 1
			    
d565 1
a565 1
			    
d568 1
a568 1
			    
d574 1
a574 1
				  
d577 1
a577 1
				  
d584 1
a584 1
				  
d587 1
a587 1
				  
d594 1
a594 1
				  
d597 1
a597 1
				  
d599 1
a599 1
				  
d611 1
a611 1
				  
d614 1
a614 1
				  
d621 1
a621 1
				  
d624 1
a624 1
				  
d685 1
a685 1
				  
d774 1
a774 1
	      
d796 1
a796 1
	  	      
d798 1
a798 1
	      
d805 1
a805 1
		      
d815 1
a815 1
			    
d819 1
a819 1
			    
d827 1
a827 1
			    
d831 1
a831 1
			    
d853 1
a853 1
			    
d855 1
a855 1
			    
d887 1
a887 1
                        case '0': case '1': case '2': case '3': case '4': 
d892 1
a892 1
			    
d901 1
a901 1
				  
d1000 1
a1000 1
      
d1004 1
a1004 1
	
d1013 1
a1013 1
      
d1023 1
a1023 1
  
d1034 1
a1034 1
  
d1062 1
a1062 1
     boolean little;
d1072 1
a1072 1
      
d1076 1
a1076 1
  
d1078 1
a1078 1
  
d1084 1
a1084 1
	  
d1096 1
a1096 1
	  
d1099 1
a1099 1
	  
d1103 1
a1103 1
  
d1113 1
a1113 1
	  
d1117 1
a1117 1
      
d1123 1
a1123 1
      
d1135 1
a1135 1
      
d1141 1
a1141 1
	      
d1149 1
a1149 1
	      
d1158 1
a1158 1
  
d1166 1
a1166 1
  
d1180 1
a1180 1
  return print_insn (pc, info, false);
d1188 1
a1188 1
  return print_insn (pc, info, true);
d1199 1
a1199 1
  
@


1.28.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of libopcodes.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a29 1
#include "safe-ctype.h"
d73 1
a73 15
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},
  { "iwmmxt_regnames", "Select register names used on the Intel Wireless MMX technology coprocessor",
    { "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7", "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"}},
  { "iwmmxt_Cregnames", "Select control register names used on the Intel Wireless MMX technology coprocessor",
    {"wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved", "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"}}
};

static char * iwmmxt_wwnames[] =
{"b", "h", "w", "d"};

static char * iwmmxt_wwssnames[] =
{"b", "bus", "b", "bss",
 "h", "hus", "h", "hss",
 "w", "wus", "w", "wss",
 "d", "dus", "d", "dss"
d82 1
a82 1
static bfd_boolean force_thumb = FALSE;
d87 1
a87 1
static char * arm_shift[] =
d91 10
a100 19
static void arm_decode_shift
  PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options
  PARAMS ((char *));
static int  print_insn
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
static int set_iwmmxt_regnames
  PARAMS ((void));

int get_arm_regname_num_options
  PARAMS ((void));
int set_arm_regname_option
  PARAMS ((int));
int get_arm_regnames
  PARAMS ((int, const char **, const char **, const char ***));
d138 1
a138 1

d145 1
a145 1

d153 1
a153 1

d156 1
a156 1

a164 18
static int
set_iwmmxt_regnames ()
{
  const char * setname;
  const char * setdesc;
  const char ** regnames;
  int iwmmxt_regnames = 0;
  int num_regnames = get_arm_regname_num_options ();

  get_arm_regnames (iwmmxt_regnames, &setname,
		    &setdesc, &regnames);
  while ((strcmp ("iwmmxt_regnames", setname))
	 && (iwmmxt_regnames < num_regnames))
    get_arm_regnames (++iwmmxt_regnames, &setname, &setdesc, &regnames);

  return iwmmxt_regnames;
}
			  
d170 3
a172 3
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d174 3
a176 4
  const struct arm_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func   = info->fprintf_func;
  static int iwmmxt_regnames = 0;
a179 5
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt)
	insn = insn + IWMMXT_INSN_COUNT;

d183 1
a183 1

d199 1
a199 1

d201 1
a201 1

d206 1
a206 1

d227 1
a227 1

d233 1
a233 1
			  func (stream, "[%s",
d241 1
a241 1
				    func (stream, ", #%s%d",
d253 1
a253 1
			      func (stream, "]%s",
d262 1
a262 1
				    func (stream, "], #%s%d",
d265 1
a265 1
				  else
d271 1
a271 1
					(((given & 0x00800000) == 0)
d284 1
a284 1

d287 1
a287 1

d289 1
a289 1

d295 1
a295 1
			  func (stream, "[%s",
d305 1
a305 1
				    func (stream, ", #%s%d",
d318 1
a318 1
			      func (stream, "]%s",
d329 1
a329 1
				    func (stream, "], #%s%d",
d332 1
a332 1
				  else
d346 1
a346 1

d400 1
a400 2

		      if ((given & (1 << 24)) != 0)
a402 1

d404 1
a404 1
			    func (stream, ", #%s%d]%s",
d414 4
a417 10

			  func (stream, "]");

			  if (given & (1 << 21))
			    {
			      if (offset)
				func (stream, ", #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * 4);
			    }
d419 1
a419 1
			    func (stream, ", {%d}", offset);
d428 1
a428 1

d437 1
a437 1

d493 1
a493 1

d545 1
a545 1
		    case '0': case '1': case '2': case '3': case '4':
d557 1
a557 1

d560 1
a560 1

d563 1
a563 1

d569 1
a569 1

d572 1
a572 1

d579 1
a579 1

d582 1
a582 1

d586 1
a586 1
			      case 'W':
a592 10
				  func (stream, "%d", reg + 1);
				}
				break;
			      case 'x':
				{
				  long reg;

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;

d594 1
a594 1

d606 1
a606 1

d609 1
a609 1

d616 1
a616 1

d619 1
a619 1

a626 57

			      case 'w':
				{
				  long reg;

				  if (bitstart != bitend)
				    {
				      reg = given >> bitstart;
				      reg &= (2 << (bitend - bitstart)) - 1;
				      if (bitend - bitstart == 1)
					func (stream, "%s", iwmmxt_wwnames[reg]);
				      else
					func (stream, "%s", iwmmxt_wwssnames[reg]);
				    }
				  else
				    {
				      reg = (((given >> 8)  & 0x1) |
					     ((given >> 22) & 0x1));
				      func (stream, "%s", iwmmxt_wwnames[reg]);
				    }
				}
				break;

			      case 'g':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

			      case 'G':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames + 1);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

d680 1
a680 1

a731 48
		      case 'L':
			switch (given & 0x00400100)
			  {
			  case 0x00000000: func (stream, "b"); break;
			  case 0x00400000: func (stream, "h"); break;
			  case 0x00000100: func (stream, "w"); break;
			  case 0x00400100: func (stream, "d"); break;
			  default:
			    break;
			  }
			break;

		      case 'Z':
			{
			  int value;
			  /* given (20, 23) | given (0, 3) */
			  value = ((given >> 16) & 0xf0) | (given & 0xf);
			  func (stream, "%d", value);
			}
			break;

		      case 'l':
			/* This is like the 'A' operator, except that if
			   the width field "M" is zero, then the offset is
			   *not* multiplied by four.  */
			{
			  int offset = given & 0xff;
			  int multiplier = (given & 0x00000100) ? 4 : 1;

			  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

			  if (offset)
			    {
			      if ((given & 0x01000000) != 0)
				func (stream, ", #%s%d]%s",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier,
				      ((given & 0x00200000) != 0 ? "!" : ""));
			      else
				func (stream, "], #%s%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier);
			    }
			  else
			    func (stream, "]");
			}
			break;

d751 3
a753 3
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d755 3
a757 3
  const struct thumb_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
d769 1
a769 1

d791 1
a791 1

d793 1
a793 1

d800 1
a800 1

d810 1
a810 1

d814 1
a814 1

d822 1
a822 1

d826 1
a826 1

d848 1
a848 1

d850 1
a850 1

d882 1
a882 1
                        case '0': case '1': case '2': case '3': case '4':
d887 1
a887 1

d896 1
a896 1

a986 17
/* Disallow mapping symbols ($a, $b, $d, $t etc) from
   being displayed in symbol relative addresses.  */

bfd_boolean
arm_symbol_is_valid (asymbol * sym,
		     struct disassemble_info * info ATTRIBUTE_UNUSED)
{
  const char * name;
  
  if (sym == NULL)
    return FALSE;

  name = bfd_asymbol_name (sym);

  return (name && *name != '$');
}

d995 1
a995 1

d999 1
a999 1

d1003 1
a1003 1
	if (strneq (option, regnames[i].name, strlen (regnames[i].name)))
d1008 1
a1008 1

a1009 1
	/* XXX - should break 'option' at following delimiter.  */
d1012 1
a1012 1
  else if (strneq (option, "force-thumb", 11))
d1014 1
a1014 1
  else if (strneq (option, "no-force-thumb", 14))
a1016 1
    /* XXX - should break 'option' at following delimiter.  */
d1018 1
a1018 1

d1022 1
a1022 2
/* Parse the string of disassembler options, spliting it at whitespaces
   or commas.  (Whitespace separators supported for backwards compatibility).  */
d1028 2
d1033 1
a1033 1
  while (*options)
d1035 1
a1035 1
      parse_arm_disassembler_option (options);
d1037 9
a1045 6
      /* Skip forward to next seperator.  */
      while ((*options) && (! ISSPACE (*options)) && (*options != ','))
	++ options;
      /* Skip forward past seperators.  */
      while (ISSPACE (*options) || (*options == ','))
	++ options;      
d1047 1
d1057 1
a1057 1
     bfd_boolean little;
d1067 1
a1067 1

d1071 1
a1071 1

d1073 1
a1073 1

d1079 1
a1079 1

d1091 1
a1091 1

d1094 1
a1094 1

d1098 1
a1098 1

d1108 1
a1108 1

d1112 1
a1112 1

d1118 1
a1118 1

d1130 1
a1130 1

d1136 1
a1136 1

d1144 1
a1144 1

d1153 1
a1153 1

d1161 1
a1161 1

d1175 1
a1175 1
  return print_insn (pc, info, FALSE);
d1183 1
a1183 1
  return print_insn (pc, info, TRUE);
d1194 1
a1194 1

@


1.28.14.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d7 1
a7 1
This file is part of libopcodes.
d12 1
a12 1
any later version.
d17 1
a17 1
more details.
d82 1
a82 1
static bfd_boolean force_thumb = FALSE;
d87 1
a87 1
static char * arm_shift[] =
d91 5
a95 10
static void arm_decode_shift
  PARAMS ((long, fprintf_ftype, void *));
static int  print_insn_arm
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static int  print_insn_thumb
  PARAMS ((bfd_vma, struct disassemble_info *, long));
static void parse_disassembler_options
  PARAMS ((char *));
static int  print_insn
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
d138 1
a138 1

d145 1
a145 1

d153 1
a153 1

d156 1
a156 1

d170 3
a172 3
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d174 3
a176 3
  const struct arm_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func   = info->fprintf_func;
d183 1
a183 1

d199 1
a199 1

d201 1
a201 1

d206 1
a206 1

d227 1
a227 1

d233 1
a233 1
			  func (stream, "[%s",
d253 1
a253 1
			      func (stream, "]%s",
d265 1
a265 1
				  else
d271 1
a271 1
					(((given & 0x00800000) == 0)
d284 1
a284 1

d287 1
a287 1

d289 1
a289 1

d295 1
a295 1
			  func (stream, "[%s",
d318 1
a318 1
			      func (stream, "]%s",
d332 1
a332 1
				  else
d346 1
a346 1

d428 1
a428 1

d437 1
a437 1

d493 1
a493 1

d545 1
a545 1
		    case '0': case '1': case '2': case '3': case '4':
d557 1
a557 1

d560 1
a560 1

d563 1
a563 1

d569 1
a569 1

d572 1
a572 1

d579 1
a579 1

d582 1
a582 1

d589 1
a589 1

d592 1
a592 1

d594 1
a594 1

d606 1
a606 1

d609 1
a609 1

d616 1
a616 1

d619 1
a619 1

d680 1
a680 1

d751 3
a753 3
     bfd_vma pc;
     struct disassemble_info *info;
     long given;
d755 3
a757 3
  const struct thumb_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
d769 1
a769 1

d791 1
a791 1

d793 1
a793 1

d800 1
a800 1

d810 1
a810 1

d814 1
a814 1

d822 1
a822 1

d826 1
a826 1

d848 1
a848 1

d850 1
a850 1

d882 1
a882 1
                        case '0': case '1': case '2': case '3': case '4':
d887 1
a887 1

d896 1
a896 1

d995 1
a995 1

d999 1
a999 1

d1008 1
a1008 1

d1018 1
a1018 1

d1029 1
a1029 1

d1057 1
a1057 1
     bfd_boolean little;
d1067 1
a1067 1

d1071 1
a1071 1

d1073 1
a1073 1

d1079 1
a1079 1

d1091 1
a1091 1

d1094 1
a1094 1

d1098 1
a1098 1

d1108 1
a1108 1

d1112 1
a1112 1

d1118 1
a1118 1

d1130 1
a1130 1

d1136 1
a1136 1

d1144 1
a1144 1

d1153 1
a1153 1

d1161 1
a1161 1

d1175 1
a1175 1
  return print_insn (pc, info, FALSE);
d1183 1
a1183 1
  return print_insn (pc, info, TRUE);
d1194 1
a1194 1

@


1.28.14.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of libopcodes.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d73 1
a73 15
    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},
  { "iwmmxt_regnames", "Select register names used on the Intel Wireless MMX technology coprocessor",
    { "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7", "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15"}},
  { "iwmmxt_Cregnames", "Select control register names used on the Intel Wireless MMX technology coprocessor",
    {"wcid", "wcon", "wcssf", "wcasf", "reserved", "reserved", "reserved", "reserved", "wcgr0", "wcgr1", "wcgr2", "wcgr3", "reserved", "reserved", "reserved", "reserved"}}
};

static char * iwmmxt_wwnames[] =
{"b", "h", "w", "d"};

static char * iwmmxt_wwssnames[] =
{"b", "bus", "b", "bss",
 "h", "hus", "h", "hss",
 "w", "wus", "w", "wss",
 "d", "dus", "d", "dss"
d101 5
a105 9
static int set_iwmmxt_regnames
  PARAMS ((void));

int get_arm_regname_num_options
  PARAMS ((void));
int set_arm_regname_option
  PARAMS ((int));
int get_arm_regnames
  PARAMS ((int, const char **, const char **, const char ***));
a169 18
static int
set_iwmmxt_regnames ()
{
  const char * setname;
  const char * setdesc;
  const char ** regnames;
  int iwmmxt_regnames = 0;
  int num_regnames = get_arm_regname_num_options ();

  get_arm_regnames (iwmmxt_regnames, &setname,
		    &setdesc, &regnames);
  while ((strcmp ("iwmmxt_regnames", setname))
	 && (iwmmxt_regnames < num_regnames))
    get_arm_regnames (++iwmmxt_regnames, &setname, &setdesc, &regnames);

  return iwmmxt_regnames;
}
			  
a181 1
  static int iwmmxt_regnames = 0;
a184 5
      if (insn->value == FIRST_IWMMXT_INSN
	  && info->mach != bfd_mach_arm_XScale
	  && info->mach != bfd_mach_arm_iWMMXt)
	insn = insn + IWMMXT_INSN_COUNT;

a631 57

			      case 'w':
				{
				  long reg;

				  if (bitstart != bitend)
				    {
				      reg = given >> bitstart;
				      reg &= (2 << (bitend - bitstart)) - 1;
				      if (bitend - bitstart == 1)
					func (stream, "%s", iwmmxt_wwnames[reg]);
				      else
					func (stream, "%s", iwmmxt_wwssnames[reg]);
				    }
				  else
				    {
				      reg = (((given >> 8)  & 0x1) |
					     ((given >> 22) & 0x1));
				      func (stream, "%s", iwmmxt_wwnames[reg]);
				    }
				}
				break;

			      case 'g':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

			      case 'G':
				{
				  long reg;
				  int current_regnames;

				  if (! iwmmxt_regnames)
				    iwmmxt_regnames = set_iwmmxt_regnames ();
				  current_regnames = set_arm_regname_option
				    (iwmmxt_regnames + 1);

				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  func (stream, "%s", arm_regnames[reg]);
				  set_arm_regname_option (current_regnames);
				}
				break;

a734 48
			break;

		      case 'L':
			switch (given & 0x00400100)
			  {
			  case 0x00000000: func (stream, "b"); break;
			  case 0x00400000: func (stream, "h"); break;
			  case 0x00000100: func (stream, "w"); break;
			  case 0x00400100: func (stream, "d"); break;
			  default:
			    break;
			  }
			break;

		      case 'Z':
			{
			  int value;
			  /* given (20, 23) | given (0, 3) */
			  value = ((given >> 16) & 0xf0) | (given & 0xf);
			  func (stream, "%d", value);
			}
			break;

		      case 'l':
			/* This is like the 'A' operator, except that if
			   the width field "M" is zero, then the offset is
			   *not* multiplied by four.  */
			{
			  int offset = given & 0xff;
			  int multiplier = (given & 0x00000100) ? 4 : 1;

			  func (stream, "[%s", arm_regnames [(given >> 16) & 0xf]);

			  if (offset)
			    {
			      if ((given & 0x01000000) != 0)
				func (stream, ", %s#%d]%s",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier,
				      ((given & 0x00200000) != 0 ? "!" : ""));
			      else
				func (stream, "], %s#%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * multiplier);
			    }
			  else
			    func (stream, "]");
			}
@


1.28.14.3
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a29 1
#include "safe-ctype.h"
d1155 1
a1155 1
	if (strneq (option, regnames[i].name, strlen (regnames[i].name)))
a1161 1
	/* XXX - should break 'option' at following delimiter.  */
d1164 1
a1164 1
  else if (strneq (option, "force-thumb", 11))
d1166 1
a1166 1
  else if (strneq (option, "no-force-thumb", 14))
a1168 1
    /* XXX - should break 'option' at following delimiter.  */
d1174 1
a1174 2
/* Parse the string of disassembler options, spliting it at whitespaces
   or commas.  (Whitespace separators supported for backwards compatibility).  */
d1180 2
d1185 1
a1185 1
  while (*options)
d1187 1
a1187 1
      parse_arm_disassembler_option (options);
d1189 9
a1197 6
      /* Skip forward to next seperator.  */
      while ((*options) && (! ISSPACE (*options)) && (*options != ','))
	++ options;
      /* Skip forward past seperators.  */
      while (ISSPACE (*options) || (*options == ','))
	++ options;      
d1199 1
@


1.28.14.4
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d448 1
a448 2

		      if ((given & (1 << 24)) != 0)
a450 1

d462 4
a465 10

			  func (stream, "]");

			  if (given & (1 << 21))
			    {
			      if (offset)
				func (stream, ", %s#%d",
				      ((given & 0x00800000) == 0 ? "-" : ""),
				      offset * 4);
			    }
d467 1
a467 1
			    func (stream, ", {%d}", offset);
@


1.28.14.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d289 1
a289 1
				    func (stream, ", #%s%d",
d310 1
a310 1
				    func (stream, "], #%s%d",
d353 1
a353 1
				    func (stream, ", #%s%d",
d377 1
a377 1
				    func (stream, "], #%s%d",
d454 1
a454 1
			    func (stream, ", #%s%d]%s",
d470 1
a470 1
				func (stream, ", #%s%d",
d879 1
a879 1
				func (stream, ", #%s%d]%s",
d884 1
a884 1
				func (stream, "], #%s%d",
@


1.28.14.6
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a641 10
			      case 'W':
				{
				  long reg;
				  
				  reg = given >> bitstart;
				  reg &= (2 << (bitend - bitstart)) - 1;
				  
				  func (stream, "%d", reg + 1);
				}
				break;
a1145 17
}

/* Disallow mapping symbols ($a, $b, $d, $t etc) from
   being displayed in symbol relative addresses.  */

bfd_boolean
arm_symbol_is_valid (asymbol * sym,
		     struct disassemble_info * info ATTRIBUTE_UNUSED)
{
  const char * name;
  
  if (sym == NULL)
    return FALSE;

  name = bfd_asymbol_name (sym);

  return (name && *name != '$');
@


1.27
log
@* arm-opc.h (arm_opcodes): Use generic rule %5?hb instead of %h.
* arm-dis.c (print_insn_arm): Don't handle 'h' case.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d31 1
a31 1
/* FIXME: This shouldn't be done here */
d102 1
a102 1
/* Functions. */
d104 1
a104 1
get_arm_regname_num_options (void)
d110 2
a111 1
set_arm_regname_option (int option)
d119 5
a123 3
get_arm_regnames (int option, const char **setname,
		  const char **setdescription,
                  const char ***register_names)
d167 1
d207 1
a207 1
			      /* pre-indexed */
d224 2
a225 1
			      offset = pc + 8;  /* ie ignore the offset.  */
d748 1
d774 2
a775 1
	      
d779 1
a779 11

		  /* The spec says that bit 1 of the branch's destination
		     address comes from bit 1 of the instruction's
		     address and not from the offset in the instruction.  */
		  if (offset & 0x1)
		    {
		      /* func (stream, "*malformed!* "); */
		      offset &= ~ 0x1;
		    }

		  offset |= ((pc & 0x2) >> 1);
d784 1
a784 1
	      info->print_address_func (offset * 2 + pc + 4, info);
d988 1
d1023 1
d1052 1
@


1.27.8.1
log
@merge from trunk
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d31 1
a31 1
/* FIXME: This shouldn't be done here.  */
d102 1
a102 1
/* Functions.  */
d104 1
a104 1
get_arm_regname_num_options ()
d110 1
a110 2
set_arm_regname_option (option)
     int option;
d118 3
a120 5
get_arm_regnames (option, setname, setdescription, register_names)
     int option;
     const char **setname;
     const char **setdescription;
     const char ***register_names;
a163 1

d203 1
a203 1
			      /* Pre-indexed.  */
d220 1
a220 2
			      /* ie ignore the offset.  */
			      offset = pc + 8;
a742 1

d768 1
a768 2
	      offset = offset * 2 + pc + 4;

d772 11
a782 1
		  offset &= 0xfffffffc;
d787 1
a787 1
	      info->print_address_func (offset, info);
a990 1

a1024 1

a1052 1

@


1.26
log
@* arm-opc.h (arm_opcodes): Add patterns for VFP instructions.
* arm-dis.c (print_insn_arm): Support new disassembly qualifiers for
VFP bitfields.
@
text
@a392 7
		    case 'h':
		      if ((given & 0x00000020) == 0x00000020)
			func (stream, "h");
                      else
                        func (stream, "b");
		      break;

@


1.25
log
@        * opcodess/arm-opc.h (arm_opcodes): Add cirrus insns.

	* opcodes/arm-dis.c (print_insn_arm): Add 'I' case.
@
text
@d633 79
a711 1
			    
@


1.24
log
@Fix compile time warning messages
@
text
@d448 19
@


1.23
log
@2001-07-13  Philip Blundell  <philb@@gnu.org>

	* arm-dis.c (print_insn_arm): Use decimal for offsets in LDR/STR.
@
text
@d1108 1
a1108 1
	     14 - strlen (regnames[i].name), ' ',
@


1.22
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d204 1
a204 1
			      func (stream, ", #%x]", offset);
d218 1
a218 1
			      func (stream, "], #%x", offset);
d283 1
a283 1
			  func (stream, "[pc, #%x]\t; ", offset);
@


1.21
log
@Fix BLX(1) for Thumb
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc. 
@


1.20
log
@Fix disassembly of arm-elf instructions with relocs associated with them.
@
text
@d671 2
d675 2
d679 14
a692 1
                 func (stream, "blx\t");
d694 3
a696 3
                func (stream, "bl\t");
		
              info->print_address_func (BDISP23 (given) * 2 + pc + 4, info);
@


1.20.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.20.2.2
log
@2001-07-16  Philip Blundell  <philb@@gnu.org>

	* arm-dis.c (print_insn_arm): Use decimal for offsets in LDR/STR.
@
text
@d204 1
a204 1
			      func (stream, ", #%d]", offset);
d218 1
a218 1
			      func (stream, "], #%d", offset);
d283 1
a283 1
			  func (stream, "[pc, #%d]\t; ", offset);
@


1.19
log
@Add ARM v5t, v5te and XScale support
@
text
@d1046 8
@


1.18
log
@* arm-dis.c (print_insn_arm): Output combinations of PSR flags.
@
text
@d424 23
d674 3
@


1.17
log
@2000-06-26  Scott Bambrough  <scottb@@netwinder.org>

	* arm-dis.c (regnames): Add an additional register set to match
	the set used by GCC.  Make it the default.
@
text
@d425 9
a433 21
		      switch (given & 0x000f0000)
			{
			default:
			  func (stream, "_???");
			  break;
			case 0x90000:
			  func (stream, "_all");
			  break;
			case 0x10000:
			  func (stream, "_c");
			  break;
			case 0x20000:
			  func (stream, "_x");
			  break;
			case 0x40000:
			  func (stream, "_s");
			  break;
			case 0x80000:
			  func (stream, "_f");
			  break;
			}
@


1.16
log
@Add support for _x and _s flags to MSR instruction
@
text
@d63 2
d75 1
a75 1
/* Default to standard register name set.  */
@


1.15
log
@2000-02-14  Fernando Nasser  <fnasser@@totem.to.cygnus.com>

	* arm-dis.c: Change flavor name from atpcs-special to
	special-atpcs to prevent name conflict in gdb.
	(get_arm_regname_num_options, set_arm_regname_option,
	get_arm_regnames): New functions.  API to access the several
	flavor of register names.  Note: Used by gdb.
	(print_insn_thumb): Use the register name entry from the currently
	selected flavor for LR and PC.
@
text
@d423 1
a423 1
		      switch (given & 0x00090000)
d432 7
a438 1
			  func (stream, "_ctl");
d441 1
a441 1
			  func (stream, "_flg");
@


1.15.2.1
log
@2000-05-26  Scott Bambrough  <scottb@@netwinder.org>

	Port of patch to mainline by Nick Clifton <nickc@@cygnus.com>:
	* arm-opc.h: Use upper case for flags in MSR and MRS
	instructions.  Allow any bit to be set in the field_mask of
	the MSR instruction.

	Port of patch to mainline by Nick Clifton <nickc@@cygnus.com>:
	* arm-dis.c (print_insn_arm): Decode _x and _s bits of
	the field_mask of an MSR instruction.

2000-05-26  Scott Bambrough  <scottb@@netwinder.org>

	Port of patch to mainline by Thomas de Lellis <tdel@@windriver.com>:
        * arm-opc.h: Disassembly of thumb ldsb/ldsh
        instructions changed to ldrsb/ldrsh.
@
text
@d423 1
a423 1
		      switch (given & 0x000f0000)
d432 1
a432 7
			  func (stream, "_c");
			  break;
			case 0x20000:
			  func (stream, "_x");
			  break;
			case 0x40000:
			  func (stream, "_s");
d435 1
a435 1
			  func (stream, "_f");
@


1.14
log
@Rename parse_disassembler_option (again)
@
text
@d69 1
a69 1
  { "atpcs-special", "Select special register names used in the ATPCS",
d93 5
d100 25
d740 1
a740 1
                                func (stream, "lr");
d747 1
a747 1
                                func (stream, "pc");
@


1.13
log
@Rename parse_disassembler_option to parse_arm_disassembler_option and allow it
to be exported.
@
text
@d625 2
a626 1
              func (stream, "bl\t");
d831 2
a832 2
static void
parse_disassembler_option (option)
d881 1
a881 1
	  parse_disassembler_option (options);
d886 1
a886 1
	parse_disassembler_option (options);
@


1.12
log
@Add ATPCS support to ARM disassembler.
Document ARM disassembler options.
@
text
@a90 1
static void parse_disassembler_option PARAMS ((char *));
@


1.11
log
@Apply Thoams de Lellis's patch to fic disassembly of Thumb instructions when
bounded by non-function labels.
@
text
@d36 1
a36 1
#define streq(a,b) (strcmp ((a), (b)) == 0)
d38 1
d40 5
a44 1
#define strneq(a,b,n) (strncmp ((a), (b), (n)) == 0)
d51 24
a74 11
static char * arm_regnames_raw[] =
{"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
 "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"};

static char * arm_regnames_standard[] =
{"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
 "r8", "r9", "r10", "r11", "r12", "sp", "lr", "pc"};

static char * arm_regnames_apcs[] =
{"a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4",
 "v5", "v6", "sl", "fp", "ip", "sp", "lr", "pc"};
d76 2
a77 2
/* Choose which register name set to use.  */
static char ** arm_regnames = arm_regnames_standard;
d93 1
a131 1

d176 4
a179 3
			      /* Cope with the possibility of write-back being used.
				 Probably a very dangerous thing for the programmer
				 to do, but who are we to argue ?  */
d185 1
a185 1
			      /* post indexed */
d188 1
a188 1
			      offset = pc + 8;  /* ie ignore the offset */
d245 1
a245 1
                          /* PC relative with immediate offset */
d262 1
a262 1
                              /* pre-indexed */
d265 1
a265 1
                                  /* immediate */
d274 1
a274 1
                                  /* register */
d286 1
a286 1
                              /* post-indexed */
d289 1
a289 1
                                  /* immediate */
d300 1
a300 1
                                  /* register */
d491 1
d494 1
d497 1
d503 1
d506 1
d513 1
d516 1
d523 1
d526 1
d529 2
a530 1
				  /* Some SWI instructions have special meanings.  */
d540 1
d543 1
d550 1
d553 1
d565 1
a603 1

d620 2
a621 2
          /* Special processing for Thumb 2 instruction BL sequence: */
          if (!*c) /* check for empty (not NULL) assembler string */
d627 1
a627 2
              (*info->print_address_func)
                (BDISP23 (given) * 2 + pc + 4, info);
d636 1
a636 1

d653 1
d657 1
d669 1
d682 1
a682 1
                          /* fall through */
d686 1
a686 1
                          /* fall through */
d693 1
d767 2
a768 2
					 bits of the address are dropped before
					 the calculation.  */
d826 1
a826 1
  /* no match */
d830 1
a830 13
/* Select a different register name set.
   Returns true if the name set selected is the APCS name set.  */
int
arm_toggle_regnames ()
{
  if (arm_regnames == arm_regnames_standard)
    arm_regnames = arm_regnames_apcs;
  else
    arm_regnames = arm_regnames_standard;

  return arm_regnames == arm_regnames_apcs;
}

d840 2
d843 7
d851 2
a852 8
      if (streq (option, "std"))
	arm_regnames = arm_regnames_standard;
      else if (streq (option, "apcs"))
	arm_regnames = arm_regnames_apcs;
      else if (streq (option, "raw"))
	arm_regnames = arm_regnames_raw;
      else
	fprintf (stderr, "Unrecognised register name set: %s\n", option);
d859 1
a859 1
    fprintf (stderr, "Unrecognised disassembler option: %s\n", option);
d864 1
d891 4
a894 5
/* NOTE: There are no checks in these routines that the relevant number of
   data bytes exist.  */

int
print_insn_big_arm (pc, info)
d897 1
d903 1
a903 1
  
d908 1
a908 1
      /* To avoid repeated parsing of the options, we remove it here.  */
d930 1
d933 3
a935 2
	  is_thumb = (ELF_ST_TYPE (es->internal_elf_sym.st_info) == STT_ARM_TFUNC)
	          || (ELF_ST_TYPE (es->internal_elf_sym.st_info) == STT_ARM_16BIT);
d938 1
a938 1

d940 1
a940 1
  info->display_endian = BFD_ENDIAN_BIG;
d942 1
a942 4
  /* Always fetch word aligned values.  */
  
  status = (*info->read_memory_func) (pc & ~ 0x3, (bfd_byte *) &b[0], 4, info);
  if (status != 0)
d944 16
a959 2
      (*info->memory_error_func) (status, pc, info);
      return -1;
d961 1
a961 2

  if (is_thumb)
d963 3
a965 1
      if (pc & 0x2)
d967 7
a973 4
	  given = (b[2] << 8) | b[3];

	  status = info->read_memory_func ((pc + 4) & ~ 0x3, (bfd_byte *) b, 4, info);
	  if (status != 0)
d975 11
a985 2
	      info->memory_error_func (status, pc + 4, info);
	      return -1;
d987 2
a988 2
	  
	  given |= (b[0] << 24) | (b[1] << 16);
d991 1
a991 1
	given = (b[0] << 8) | b[1] | (b[2] << 24) | (b[3] << 16);
d993 1
a993 3
  else
    given = (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | (b[3]);

d1003 8
d1015 2
a1016 4
  unsigned char      b[4];
  long               given;
  int                status;
  int                is_thumb;
d1018 4
a1021 7
  if (info->disassembler_options)
    {
      parse_disassembler_options (info->disassembler_options);
      
      /* To avoid repeated parsing of the options, we remove it here.  */
      info->disassembler_options = NULL;
    }
d1023 3
a1025 1
  is_thumb = force_thumb;
d1027 5
a1031 40
  if (!is_thumb && info->symbols != NULL)
    {
      if (bfd_asymbol_flavour (*info->symbols) == bfd_target_coff_flavour)
	{
	  coff_symbol_type * cs;
	  
	  cs = coffsymbol (*info->symbols);
	  is_thumb = (   cs->native->u.syment.n_sclass == C_THUMBEXT
		      || cs->native->u.syment.n_sclass == C_THUMBSTAT
		      || cs->native->u.syment.n_sclass == C_THUMBLABEL
		      || cs->native->u.syment.n_sclass == C_THUMBEXTFUNC
		      || cs->native->u.syment.n_sclass == C_THUMBSTATFUNC);
	}
      else if (bfd_asymbol_flavour (*info->symbols) == bfd_target_elf_flavour)
	{
	  elf_symbol_type *  es;
	  
	  es = *(elf_symbol_type **)(info->symbols);
	  is_thumb = (ELF_ST_TYPE (es->internal_elf_sym.st_info) == STT_ARM_TFUNC)
	          || (ELF_ST_TYPE (es->internal_elf_sym.st_info) == STT_ARM_16BIT);
	}
    }
  
  info->bytes_per_chunk = 4;
  info->display_endian = BFD_ENDIAN_LITTLE;

  status = (*info->read_memory_func) (pc, (bfd_byte *) &b[0], 4, info);
  if (status != 0 && is_thumb)
    {
      info->bytes_per_chunk = 2;

      status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);
      b[3] = b[2] = 0;
    }
  
  if (status != 0)
    {
      info->memory_error_func (status, pc, info);
      return -1;
    }
d1033 2
a1034 8
  given = (b[0]) | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);

  if (is_thumb)
    status = print_insn_thumb (pc, info, given);
  else
    status = print_insn_arm (pc, info, given);

  return status;
@


1.10
log
@Prevent double dumping of raw thumb instructions.
@
text
@a873 2
  coff_symbol_type * cs;
  elf_symbol_type *  es;
d880 1
a880 1
      /* To avoid repeated parsing of this option, we remove it here.  */
d890 2
d901 2
d904 2
a905 2
	  is_thumb = ELF_ST_TYPE (es->internal_elf_sym.st_info) ==
	    STT_ARM_TFUNC;
a957 2
  coff_symbol_type * cs;
  elf_symbol_type *  es;
d964 1
a964 1
      /* To avoid repeated parsing of this option, we remove it here.  */
d974 2
d985 2
d988 2
a989 2
	  is_thumb = ELF_ST_TYPE (es->internal_elf_sym.st_info) ==
	    STT_ARM_TFUNC;
@


1.9
log
@Add support for --disassembler-options=force-thumb
@
text
@d593 1
a593 1
              func (stream, "%04x\tbl\t", given & 0xffff);
d604 1
a604 2
              func (stream, "%04x\t", given);
	      
@


1.8
log
@Added 'X' format to ARM code.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc. 
d35 7
d61 2
d68 9
a76 4

static int print_insn_arm
  PARAMS ((bfd_vma, struct disassemble_info *, long));

d809 2
a810 2
parse_disassembler_options (options)
     char * options;
d812 1
a812 1
  if (options == NULL)
d815 1
a815 1
  if (strncmp (options, "reg-names-", 10) == 0)
d817 1
a817 1
      options += 10;
d819 1
a819 1
      if (strcmp (options, "std") == 0)
d821 1
a821 1
      else if (strcmp (options, "apcs") == 0)
d823 1
a823 1
      else if (strcmp (options, "raw") == 0)
d826 1
a826 1
	fprintf (stderr, "Unrecognised register name set: %s\n", options);
d828 4
d833 1
a833 1
    fprintf (stderr, "Unrecognised disassembler option: %s\n", options);
d838 28
a865 1
/* NOTE: There are no checks in these routines that the relevant number of data bytes exist */
d887 3
a889 2
  is_thumb = false;
  if (info->symbols != NULL)
d968 2
d971 1
a971 3
  is_thumb = false;
  
  if (info->symbols != NULL)
d1001 1
d1004 1
a1004 1
      (*info->memory_error_func) (status, pc, info);
@


1.7
log
@fix compile time warnings.
@
text
@d494 8
@


1.6
log
@Display hex equivalent of rotated ARM constants.
@
text
@d22 1
@


1.5
log
@	* alpha-dis.c: Don't include <stdlib.h>.
	* arm-dis.c: Include "sysdep.h".
	* tic30-dis.c: Don't include <stdlib.h> or <string.h>.  Include
	"sysdep.h".
	* Makefile.am: Rebuild dependencies.
	* Makefile.in: Rebuild.
@
text
@a21 1
#include "sysdep.h"
d309 3
a311 3
			  func (stream, "#%d",
				((immed << (32 - rotate))
				 | (immed >> rotate)) & 0xffffffff);
@


1.4
log
@Add detection of IMB and IMBRange SWIs.
@
text
@d22 1
@


1.3
log
@Add -M command line switch to objdump - text of switch is passed on to disassembler
Add support for register name set selection ot ARM disassembler.
@
text
@d34 1
a34 1
static char *arm_conditional[] =
d38 1
a38 1
static char *arm_regnames_raw[] =
d42 1
a42 1
static char *arm_regnames_standard[] =
d46 1
a46 1
static char *arm_regnames_apcs[] =
d51 1
a51 1
static char **arm_regnames = arm_regnames_standard;
d53 1
a53 1
static char *arm_fp_const[] =
d56 1
a56 1
static char *arm_shift[] = 
d59 2
a60 2
static int print_insn_arm PARAMS ((bfd_vma, struct disassemble_info *,
				   long));
d66 1
a66 1
     void *stream;
d69 1
d76 1
d84 1
d87 1
d101 3
a103 3
     bfd_vma         pc;
     struct disassemble_info *info;
     long given;
d485 6
d550 3
a552 3
     bfd_vma         pc;
     struct disassemble_info *info;
     long given;
d554 3
a556 3
  struct thumb_opcode *insn;
  void *stream = info->stream;
  fprintf_ftype func = info->fprintf_func;
d562 1
a562 1
          char *c = insn->assembler;
d582 1
d589 1
d609 1
d634 1
d672 1
d681 1
d731 1
a731 1
                                      abort();
d751 1
a751 1
                                 abort();
d816 1
a816 1
     struct disassemble_info *info;
d821 2
a822 2
  coff_symbol_type   *cs;
  elf_symbol_type    *es;
d836 16
a851 17
    if (bfd_asymbol_flavour (*info->symbols) == bfd_target_coff_flavour)
     {
       cs = coffsymbol (*info->symbols);
       is_thumb = (cs->native->u.syment.n_sclass == C_THUMBEXT
                   || cs->native->u.syment.n_sclass == C_THUMBSTAT
                   || cs->native->u.syment.n_sclass == C_THUMBLABEL
                   || cs->native->u.syment.n_sclass == C_THUMBEXTFUNC
                   || cs->native->u.syment.n_sclass == C_THUMBSTATFUNC);
  
     }
    else if (bfd_asymbol_flavour (*info->symbols) == bfd_target_elf_flavour)
     {
       es = *(elf_symbol_type **)(info->symbols);
       is_thumb = ELF_ST_TYPE (es->internal_elf_sym.st_info) ==
	 STT_ARM_TFUNC;
      }
   }
d881 1
a881 3
	{
	  given = (b[0] << 8) | b[1] | (b[2] << 24) | (b[3] << 16);
	}
d884 1
a884 3
    {
      given = (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | (b[3]);
    }
d887 1
a887 3
    {
      status = print_insn_thumb (pc, info, given);
    }
d889 1
a889 3
    {
      status = print_insn_arm (pc, info, given);
    }
d902 2
a903 2
  coff_symbol_type   *cs;
  elf_symbol_type    *es;
d915 1
d918 16
a933 8
    if (bfd_asymbol_flavour (*info->symbols) == bfd_target_coff_flavour)
     {
       cs = coffsymbol (*info->symbols);
       is_thumb = (cs->native->u.syment.n_sclass == C_THUMBEXT
                   || cs->native->u.syment.n_sclass == C_THUMBSTAT
                   || cs->native->u.syment.n_sclass == C_THUMBLABEL
                   || cs->native->u.syment.n_sclass == C_THUMBEXTFUNC
                   || cs->native->u.syment.n_sclass == C_THUMBSTATFUNC);
a934 9
     }
    else if (bfd_asymbol_flavour (*info->symbols) == bfd_target_elf_flavour)
     {
       es = *(elf_symbol_type **)(info->symbols);
       is_thumb = ELF_ST_TYPE (es->internal_elf_sym.st_info) ==
	 STT_ARM_TFUNC;
      }
   }

d955 1
a955 3
    {
      status = print_insn_thumb (pc, info, given);
    }
d957 1
a957 3
    {
      status = print_insn_arm (pc, info, given);
    }
@


1.2
log
@Make LDRH/LDRB consistent with LDR when target is PC-relative
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 1998 Free Software Foundation, Inc. 
d38 1
a38 1
static char *arm_regnames[] =
d40 12
a51 1
 "r8", "r9", "sl", "fp", "ip", "sp", "lr", "pc"};
d756 39
d809 8
d899 8
@


1.1
log
@Initial revision
@
text
@d198 1
d201 3
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

