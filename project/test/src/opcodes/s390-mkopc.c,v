head	1.21;
access;
symbols
	sid-snapshot-20180601:1.21
	sid-snapshot-20180501:1.21
	sid-snapshot-20180401:1.21
	sid-snapshot-20180301:1.21
	sid-snapshot-20180201:1.21
	sid-snapshot-20180101:1.21
	sid-snapshot-20171201:1.21
	sid-snapshot-20171101:1.21
	sid-snapshot-20171001:1.21
	sid-snapshot-20170901:1.21
	sid-snapshot-20170801:1.21
	sid-snapshot-20170701:1.21
	sid-snapshot-20170601:1.21
	sid-snapshot-20170501:1.21
	sid-snapshot-20170401:1.21
	sid-snapshot-20170301:1.21
	sid-snapshot-20170201:1.21
	sid-snapshot-20170101:1.21
	sid-snapshot-20161201:1.21
	sid-snapshot-20161101:1.21
	sid-snapshot-20160901:1.21
	sid-snapshot-20160801:1.21
	sid-snapshot-20160701:1.21
	sid-snapshot-20160601:1.21
	sid-snapshot-20160501:1.21
	sid-snapshot-20160401:1.21
	sid-snapshot-20160301:1.21
	sid-snapshot-20160201:1.21
	sid-snapshot-20160101:1.21
	sid-snapshot-20151201:1.21
	sid-snapshot-20151101:1.21
	sid-snapshot-20151001:1.21
	sid-snapshot-20150901:1.21
	sid-snapshot-20150801:1.21
	sid-snapshot-20150701:1.21
	sid-snapshot-20150601:1.21
	sid-snapshot-20150501:1.21
	sid-snapshot-20150401:1.21
	sid-snapshot-20150301:1.21
	sid-snapshot-20150201:1.21
	sid-snapshot-20150101:1.21
	sid-snapshot-20141201:1.21
	sid-snapshot-20141101:1.21
	sid-snapshot-20141001:1.21
	sid-snapshot-20140901:1.21
	sid-snapshot-20140801:1.21
	sid-snapshot-20140701:1.21
	sid-snapshot-20140601:1.21
	sid-snapshot-20140501:1.21
	sid-snapshot-20140401:1.21
	sid-snapshot-20140301:1.21
	sid-snapshot-20140201:1.21
	sid-snapshot-20140101:1.21
	sid-snapshot-20131201:1.21
	sid-snapshot-20131101:1.21
	sid-snapshot-20131001:1.21
	binutils-2_24-branch:1.21.0.4
	binutils-2_24-branchpoint:1.21
	binutils-2_21_1:1.18
	sid-snapshot-20130901:1.21
	gdb_7_6_1-2013-08-30-release:1.21
	sid-snapshot-20130801:1.21
	sid-snapshot-20130701:1.21
	sid-snapshot-20130601:1.21
	sid-snapshot-20130501:1.21
	gdb_7_6-2013-04-26-release:1.21
	sid-snapshot-20130401:1.21
	binutils-2_23_2:1.18
	gdb_7_6-branch:1.21.0.2
	gdb_7_6-2013-03-12-branchpoint:1.21
	sid-snapshot-20130301:1.21
	sid-snapshot-20130201:1.21
	sid-snapshot-20130101:1.21
	sid-snapshot-20121201:1.21
	gdb_7_5_1-2012-11-29-release:1.18
	binutils-2_23_1:1.18
	sid-snapshot-20121101:1.20
	binutils-2_23:1.18
	sid-snapshot-20121001:1.18
	sid-snapshot-20120901:1.18
	gdb_7_5-2012-08-17-release:1.18
	sid-snapshot-20120801:1.18
	binutils-2_23-branch:1.18.0.14
	binutils-2_23-branchpoint:1.18
	gdb_7_5-branch:1.18.0.12
	gdb_7_5-2012-07-18-branchpoint:1.18
	sid-snapshot-20120701:1.18
	sid-snapshot-20120601:1.18
	sid-snapshot-20120501:1.18
	binutils-2_22_branch:1.18.0.10
	gdb_7_4_1-2012-04-26-release:1.18
	sid-snapshot-20120401:1.18
	sid-snapshot-20120301:1.18
	sid-snapshot-20120201:1.18
	gdb_7_4-2012-01-24-release:1.18
	sid-snapshot-20120101:1.18
	gdb_7_4-branch:1.18.0.8
	gdb_7_4-2011-12-13-branchpoint:1.18
	sid-snapshot-20111201:1.18
	binutils-2_22:1.18
	sid-snapshot-20111101:1.18
	sid-snapshot-20111001:1.18
	binutils-2_22-branch:1.18.0.6
	binutils-2_22-branchpoint:1.18
	gdb_7_3_1-2011-09-04-release:1.18
	sid-snapshot-20110901:1.18
	sid-snapshot-20110801:1.18
	gdb_7_3-2011-07-26-release:1.18
	sid-snapshot-20110701:1.18
	sid-snapshot-20110601:1.18
	sid-snapshot-20110501:1.18
	gdb_7_3-branch:1.18.0.4
	gdb_7_3-2011-04-01-branchpoint:1.18
	sid-snapshot-20110401:1.18
	sid-snapshot-20110301:1.18
	sid-snapshot-20110201:1.18
	sid-snapshot-20110101:1.18
	binutils-2_21:1.18
	sid-snapshot-20101201:1.18
	binutils-2_21-branch:1.18.0.2
	binutils-2_21-branchpoint:1.18
	sid-snapshot-20101101:1.18
	sid-snapshot-20101001:1.18
	binutils-2_20_1:1.15
	gdb_7_2-2010-09-02-release:1.15
	sid-snapshot-20100901:1.15
	sid-snapshot-20100801:1.15
	gdb_7_2-branch:1.15.0.8
	gdb_7_2-2010-07-07-branchpoint:1.15
	sid-snapshot-20100701:1.15
	sid-snapshot-20100601:1.15
	sid-snapshot-20100501:1.15
	sid-snapshot-20100401:1.15
	gdb_7_1-2010-03-18-release:1.15
	sid-snapshot-20100301:1.15
	gdb_7_1-branch:1.15.0.6
	gdb_7_1-2010-02-18-branchpoint:1.15
	sid-snapshot-20100201:1.15
	sid-snapshot-20100101:1.15
	gdb_7_0_1-2009-12-22-release:1.15
	sid-snapshot-20091201:1.15
	sid-snapshot-20091101:1.15
	binutils-2_20:1.15
	gdb_7_0-2009-10-06-release:1.15
	sid-snapshot-20091001:1.15
	gdb_7_0-branch:1.15.0.4
	gdb_7_0-2009-09-16-branchpoint:1.15
	arc-sim-20090309:1.11
	binutils-arc-20081103-branch:1.14.0.20
	binutils-arc-20081103-branchpoint:1.14
	binutils-2_20-branch:1.15.0.2
	binutils-2_20-branchpoint:1.15
	sid-snapshot-20090901:1.14
	sid-snapshot-20090801:1.14
	msnyder-checkpoint-072509-branch:1.14.0.18
	msnyder-checkpoint-072509-branchpoint:1.14
	sid-snapshot-20090701:1.14
	dje-cgen-play1-branch:1.14.0.16
	dje-cgen-play1-branchpoint:1.14
	sid-snapshot-20090601:1.14
	sid-snapshot-20090501:1.14
	sid-snapshot-20090401:1.14
	arc-20081103-branch:1.14.0.14
	arc-20081103-branchpoint:1.14
	arc-insight_6_8-branch:1.11.0.8
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.6
	insight_6_8-branchpoint:1.11
	sid-snapshot-20090301:1.14
	binutils-2_19_1:1.14
	sid-snapshot-20090201:1.14
	sid-snapshot-20090101:1.14
	reverse-20081226-branch:1.14.0.12
	reverse-20081226-branchpoint:1.14
	sid-snapshot-20081201:1.14
	multiprocess-20081120-branch:1.14.0.10
	multiprocess-20081120-branchpoint:1.14
	sid-snapshot-20081101:1.14
	binutils-2_19:1.14
	sid-snapshot-20081001:1.14
	reverse-20080930-branch:1.14.0.8
	reverse-20080930-branchpoint:1.14
	binutils-2_19-branch:1.14.0.6
	binutils-2_19-branchpoint:1.14
	sid-snapshot-20080901:1.14
	sid-snapshot-20080801:1.14
	reverse-20080717-branch:1.14.0.4
	reverse-20080717-branchpoint:1.14
	sid-snapshot-20080701:1.14
	msnyder-reverse-20080609-branch:1.14.0.2
	msnyder-reverse-20080609-branchpoint:1.14
	drow-reverse-20070409-branch:1.9.0.2
	drow-reverse-20070409-branchpoint:1.9
	sid-snapshot-20080601:1.14
	sid-snapshot-20080501:1.14
	sid-snapshot-20080403:1.12
	sid-snapshot-20080401:1.12
	gdb_6_8-2008-03-27-release:1.11
	sid-snapshot-20080301:1.11
	gdb_6_8-branch:1.11.0.4
	gdb_6_8-2008-02-26-branchpoint:1.11
	sid-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	sid-snapshot-20071001:1.11
	gdb_6_7-branch:1.11.0.2
	gdb_6_7-2007-09-07-branchpoint:1.11
	binutils-2_18:1.10
	binutils-2_18-branch:1.10.0.2
	binutils-2_18-branchpoint:1.10
	insight_6_6-20070208-release:1.8
	binutils-csl-coldfire-4_1-32:1.8
	binutils-csl-sourcerygxx-4_1-32:1.8
	gdb_6_6-2006-12-18-release:1.8
	binutils-csl-innovasic-fido-3_4_4-33:1.8
	binutils-csl-sourcerygxx-3_4_4-32:1.6
	binutils-csl-coldfire-4_1-30:1.8
	binutils-csl-sourcerygxx-4_1-30:1.8
	binutils-csl-coldfire-4_1-28:1.8
	binutils-csl-sourcerygxx-4_1-29:1.8
	binutils-csl-sourcerygxx-4_1-28:1.8
	gdb_6_6-branch:1.8.0.30
	gdb_6_6-2006-11-15-branchpoint:1.8
	binutils-csl-arm-2006q3-27:1.8
	binutils-csl-sourcerygxx-4_1-27:1.8
	binutils-csl-arm-2006q3-26:1.8
	binutils-csl-sourcerygxx-4_1-26:1.8
	binutils-csl-sourcerygxx-4_1-25:1.8
	binutils-csl-sourcerygxx-4_1-24:1.8
	binutils-csl-sourcerygxx-4_1-23:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.8
	binutils-csl-sourcerygxx-4_1-21:1.8
	binutils-csl-arm-2006q3-21:1.8
	binutils-csl-sourcerygxx-4_1-22:1.8
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.8
	binutils-csl-sourcerygxx-4_1-20:1.8
	binutils-csl-arm-2006q3-19:1.8
	binutils-csl-sourcerygxx-4_1-19:1.8
	binutils-csl-sourcerygxx-4_1-18:1.8
	binutils-csl-renesas-4_1-9:1.8
	gdb-csl-sourcerygxx-3_4_4-25:1.8
	binutils-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.8
	binutils-csl-renesas-4_1-8:1.8
	binutils-csl-renesas-4_1-7:1.8
	binutils-csl-renesas-4_1-6:1.8
	gdb-csl-sourcerygxx-4_1-17:1.8
	binutils-csl-sourcerygxx-4_1-17:1.8
	gdb-csl-20060226-branch-local-2:1.8
	gdb-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-15:1.8
	gdb-csl-sourcerygxx-4_1-13:1.8
	binutils-csl-sourcerygxx-4_1-13:1.8
	binutils-2_17:1.8
	gdb-csl-sourcerygxx-4_1-12:1.8
	binutils-csl-sourcerygxx-4_1-12:1.8
	gdb-csl-sourcerygxx-3_4_4-21:1.8
	binutils-csl-sourcerygxx-3_4_4-21:1.8
	gdb_6_5-20060621-release:1.8
	binutils-csl-wrs-linux-3_4_4-24:1.6
	binutils-csl-wrs-linux-3_4_4-23:1.6
	gdb-csl-sourcerygxx-4_1-9:1.8
	binutils-csl-sourcerygxx-4_1-9:1.8
	gdb-csl-sourcerygxx-4_1-8:1.8
	binutils-csl-sourcerygxx-4_1-8:1.8
	gdb-csl-sourcerygxx-4_1-7:1.8
	binutils-csl-sourcerygxx-4_1-7:1.8
	gdb-csl-arm-2006q1-6:1.8
	binutils-csl-arm-2006q1-6:1.8
	gdb-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-wrs-linux-3_4_4-22:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.8
	gdb-csl-symbian-6_4_50_20060226-9:1.8
	gdb-csl-symbian-6_4_50_20060226-8:1.8
	gdb-csl-coldfire-4_1-11:1.8
	binutils-csl-coldfire-4_1-11:1.8
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	binutils-csl-sourcerygxx-3_4_4-19:1.8
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.8.0.28
	gdb_6_5-2006-05-14-branchpoint:1.8
	binutils-csl-coldfire-4_1-10:1.8
	gdb-csl-sourcerygxx-4_1-5:1.8
	binutils-csl-sourcerygxx-4_1-5:1.8
	nickrob-async-20060513-branch:1.8.0.26
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.8
	binutils-csl-sourcerygxx-4_1-4:1.8
	msnyder-reverse-20060502-branch:1.8.0.24
	msnyder-reverse-20060502-branchpoint:1.8
	binutils-csl-wrs-linux-3_4_4-21:1.6
	gdb-csl-morpho-4_1-4:1.8
	binutils-csl-morpho-4_1-4:1.8
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-wrs-linux-3_4_4-20:1.6
	readline_5_1-import-branch:1.8.0.22
	readline_5_1-import-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	binutils-2_17-branch:1.8.0.20
	binutils-2_17-branchpoint:1.8
	gdb-csl-symbian-20060226-branch:1.8.0.18
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.8.0.16
	msnyder-reverse-20060331-branchpoint:1.8
	binutils-csl-2_17-branch:1.8.0.14
	binutils-csl-2_17-branchpoint:1.8
	gdb-csl-available-20060303-branch:1.8.0.12
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.10
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.8
	msnyder-fork-checkpoint-branch:1.8.0.8
	msnyder-fork-checkpoint-branchpoint:1.8
	gdb-csl-gxxpro-6_3-branch:1.8.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.8
	gdb_6_4-branch:1.8.0.4
	gdb_6_4-2005-11-01-branchpoint:1.8
	gdb-csl-arm-20051020-branch:1.8.0.2
	gdb-csl-arm-20051020-branchpoint:1.8
	binutils-csl-gxxpro-3_4-branch:1.6.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.6
	binutils-2_16_1:1.6
	msnyder-tracepoint-checkpoint-branch:1.7.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.6
	binutils-csl-arm-2005q1b:1.6
	binutils-2_16:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	binutils-csl-arm-2005q1a:1.6
	csl-arm-20050325-branch:1.6.0.6
	csl-arm-20050325-branchpoint:1.6
	binutils-csl-arm-2005q1-branch:1.6.0.4
	binutils-csl-arm-2005q1-branchpoint:1.6
	binutils-2_16-branch:1.6.0.2
	binutils-2_16-branchpoint:1.6
	csl-arm-2004-q3d:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.24
	gdb_6_3-20041019-branchpoint:1.5
	csl-arm-2004-q3:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.26
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.22
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	binutils-2_15:1.5
	binutils-2_15-branchpoint:1.5
	csl-arm-2004-q1a:1.5
	csl-arm-2004-q1:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.20
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.18
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.14
	drow_intercu-20040221-branchpoint:1.5
	binutils-2_15-branch:1.5.0.12
	cagney_bfdfile-20040213-branch:1.5.0.10
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.8
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	csl-arm-2003-q4:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.5.0.6
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.4
	cagney_x86i386-20030821-branch:1.5.0.2
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.24
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.22
	jimb-ppc64-linux-20030613-branchpoint:1.4
	binutils-2_14:1.4
	cagney_convert-20030606-branch:1.4.0.20
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.18
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.16
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.14
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.12
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	binutils-2_14-branch:1.4.0.10
	binutils-2_14-branchpoint:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.8
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.6
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.4
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.2
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.3.0.36
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.34
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.32
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.30
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.28
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.26
	cagney-unwind-20030108-branchpoint:1.3
	binutils-2_13_2_1:1.3
	binutils-2_13_2:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	binutils-2_13_1:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.20
	gdb_5_3-branch:1.3.0.18
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.16
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.14
	readline_4_3-import-branchpoint:1.3
	binutils-2_13:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	binutils-2_13-branchpoint:1.3
	binutils-2_13-branch:1.3.0.12
	kseitz_interps-20020528-branch:1.3.0.10
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.8
	cagney_regbuf-20020515-branchpoint:1.3
	binutils-2_12_1:1.3
	jimb-macro-020506-branch:1.3.0.6
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	binutils-2_12:1.3
	gdb_5_2-branch:1.3.0.4
	gdb_5_2-2002-03-03-branchpoint:1.3
	binutils-2_12-branch:1.3.0.2
	binutils-2_12-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	x86_64versiong3:1.1
	binutils_latest_snapshot:1.21;
locks; strict;
comment	@ * @;


1.21
date	2012.11.29.23.42.03;	author roland;	state Exp;
branches;
next	1.20;

1.20
date	2012.10.26.09.41.55;	author krebbel;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.04.08.47.36;	author krebbel;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.30.16.02.35;	author muller;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.30.11.32.15;	author muller;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.27.13.36.48;	author krebbel;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.10.13.05.07;	author krebbel;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.10.08.59.46;	author krebbel;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.19.10.29.17;	author krebbel;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.21.15.54.30;	author krebbel;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.06.13.19.07;	author sky;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.12.18.03.03;	author sky;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.07.07.34.31;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.03.11.49.50;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.01.14.47.58;	author sky;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.21.13.28.09;	author sky;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.18.15.41.33;	author nickc;	state Exp;
branches
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2001.03.13.22.58.37;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.10.00.55.48;	author nickc;	state Exp;
branches;
next	;

1.3.22.1
date	2003.04.16.19.57.06;	author carlton;	state Exp;
branches;
next	1.3.22.2;

1.3.22.2
date	2003.08.05.17.13.31;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.10;	author drow;	state Exp;
branches;
next	;


desc
@@


1.21
log
@opcodes/
	* s390-mkopc.c (file_header): Add const.
@
text
@/* s390-mkopc.c -- Generates opcode table out of s390-opc.txt
   Copyright 2000, 2001, 2003, 2005, 2007, 2008 Free Software Foundation, Inc.
   Contributed by Martin Schwidefsky (schwidefsky@@de.ibm.com).

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this file; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Taken from opcodes/s390.h */
enum s390_opcode_mode_val
  {
    S390_OPCODE_ESA = 0,
    S390_OPCODE_ZARCH
  };

enum s390_opcode_cpu_val
  {
    S390_OPCODE_G5 = 0,
    S390_OPCODE_G6,
    S390_OPCODE_Z900,
    S390_OPCODE_Z990,
    S390_OPCODE_Z9_109,
    S390_OPCODE_Z9_EC,
    S390_OPCODE_Z10,
    S390_OPCODE_Z196,
    S390_OPCODE_ZEC12
  };

struct op_struct
  {
    char  opcode[16];
    char  mnemonic[16];
    char  format[16];
    int   mode_bits;
    int   min_cpu;

    unsigned long long sort_value;
    int   no_nibbles;
  };

struct op_struct *op_array;
int max_ops;
int no_ops;

static void
createTable (void)
{
  max_ops = 256;
  op_array = malloc (max_ops * sizeof (struct op_struct));
  no_ops = 0;
}

/* `insertOpcode': insert an op_struct into sorted opcode array.  */

static void
insertOpcode (char *opcode, char *mnemonic, char *format,
	      int min_cpu, int mode_bits)
{
  char *str;
  unsigned long long sort_value;
  int no_nibbles;
  int ix, k;

  while (no_ops >= max_ops)
    {
      max_ops = max_ops * 2;
      op_array = realloc (op_array, max_ops * sizeof (struct op_struct));
    }

  sort_value = 0;
  str = opcode;
  for (ix = 0; ix < 16; ix++)
    {
      if (*str >= '0' && *str <= '9')
	sort_value = (sort_value << 4) + (*str - '0');
      else if (*str >= 'a' && *str <= 'f')
	sort_value = (sort_value << 4) + (*str - 'a' + 10);
      else if (*str >= 'A' && *str <= 'F')
	sort_value = (sort_value << 4) + (*str - 'A' + 10);
      else if (*str == '?')
	sort_value <<= 4;
      else
	break;
      str ++;
    }
  sort_value <<= 4*(16 - ix);
  sort_value += (min_cpu << 8) + mode_bits;
  no_nibbles = ix;
  for (ix = 0; ix < no_ops; ix++)
    if (sort_value > op_array[ix].sort_value)
      break;
  for (k = no_ops; k > ix; k--)
    op_array[k] = op_array[k-1];
  strcpy(op_array[ix].opcode, opcode);
  strcpy(op_array[ix].mnemonic, mnemonic);
  strcpy(op_array[ix].format, format);
  op_array[ix].sort_value = sort_value;
  op_array[ix].no_nibbles = no_nibbles;
  op_array[ix].min_cpu = min_cpu;
  op_array[ix].mode_bits = mode_bits;
  no_ops++;
}

struct s390_cond_ext_format
{
  char nibble;
  char extension[4];
};

/* The mnemonic extensions for conditional jumps used to replace
   the '*' tag.  */
#define NUM_COND_EXTENSIONS 20
const struct s390_cond_ext_format s390_cond_extensions[NUM_COND_EXTENSIONS] =
{ { '1', "o" },    /* jump on overflow / if ones */
  { '2', "h" },    /* jump on A high */
  { '2', "p" },    /* jump on plus */
  { '3', "nle" },  /* jump on not low or equal */
  { '4', "l" },    /* jump on A low */
  { '4', "m" },    /* jump on minus / if mixed */
  { '5', "nhe" },  /* jump on not high or equal */
  { '6', "lh" },   /* jump on low or high */
  { '7', "ne" },   /* jump on A not equal B */
  { '7', "nz" },   /* jump on not zero / if not zeros */
  { '8', "e" },    /* jump on A equal B */
  { '8', "z" },    /* jump on zero / if zeros */
  { '9', "nlh" },  /* jump on not low or high */
  { 'a', "he" },   /* jump on high or equal */
  { 'b', "nl" },   /* jump on A not low */
  { 'b', "nm" },   /* jump on not minus / if not mixed */
  { 'c', "le" },   /* jump on low or equal */
  { 'd', "nh" },   /* jump on A not high */
  { 'd', "np" },   /* jump on not plus */
  { 'e', "no" },   /* jump on not overflow / if not ones */
};

/* The mnemonic extensions for conditional branches used to replace
   the '$' tag.  */
#define NUM_CRB_EXTENSIONS 12
const struct s390_cond_ext_format s390_crb_extensions[NUM_CRB_EXTENSIONS] =
{ { '2', "h" },    /* jump on A high */
  { '2', "nle" },  /* jump on not low or equal */
  { '4', "l" },    /* jump on A low */
  { '4', "nhe" },  /* jump on not high or equal */
  { '6', "ne" },   /* jump on A not equal B */
  { '6', "lh" },   /* jump on low or high */
  { '8', "e" },    /* jump on A equal B */
  { '8', "nlh" },  /* jump on not low or high */
  { 'a', "nl" },   /* jump on A not low */
  { 'a', "he" },   /* jump on high or equal */
  { 'c', "nh" },   /* jump on A not high */
  { 'c', "le" },   /* jump on low or equal */
};

/* As with insertOpcode instructions are added to the sorted opcode
   array.  Additionally mnemonics containing the '*<number>' tag are
   expanded to the set of conditional instructions described by
   s390_cond_extensions with the tag replaced by the respective
   mnemonic extensions.  */

static void
insertExpandedMnemonic (char *opcode, char *mnemonic, char *format,
			int min_cpu, int mode_bits)
{
  char *tag;
  char prefix[15];
  char suffix[15];
  char number[15];
  int mask_start, i = 0, tag_found = 0, reading_number = 0;
  int number_p = 0, suffix_p = 0, prefix_p = 0;
  const struct s390_cond_ext_format *ext_table;
  int ext_table_length;

  if (!(tag = strpbrk (mnemonic, "*$")))
    {
      insertOpcode (opcode, mnemonic, format, min_cpu, mode_bits);
      return;
    }

  while (mnemonic[i] != '\0')
    {
      if (mnemonic[i] == *tag)
	{
	  if (tag_found)
	    goto malformed_mnemonic;

	  tag_found = 1;
	  reading_number = 1;
	}
      else
	switch (mnemonic[i])
	  {
	  case '0': case '1': case '2': case '3': case '4':
	  case '5': case '6': case '7': case '8': case '9':
	    if (!tag_found || !reading_number)
	      goto malformed_mnemonic;

	    number[number_p++] = mnemonic[i];
	    break;

	  default:
	    if (reading_number)
	      {
		if (!number_p)
		  goto malformed_mnemonic;
		else
		  reading_number = 0;
	      }

	    if (tag_found)
	      suffix[suffix_p++] = mnemonic[i];
	    else
	      prefix[prefix_p++] = mnemonic[i];
	  }
      i++;
    }

  prefix[prefix_p] = '\0';
  suffix[suffix_p] = '\0';
  number[number_p] = '\0';

  if (sscanf (number, "%d", &mask_start) != 1)
    goto malformed_mnemonic;

  if (mask_start & 3)
    {
      fprintf (stderr, "Conditional mask not at nibble boundary in: %s\n",
	       mnemonic);
      return;
    }

  mask_start >>= 2;

  switch (*tag)
    {
    case '*':
      ext_table = s390_cond_extensions;
      ext_table_length = NUM_COND_EXTENSIONS;
      break;
    case '$':
      ext_table = s390_crb_extensions;
      ext_table_length = NUM_CRB_EXTENSIONS;
      break;
    default: fprintf (stderr, "Unknown tag char: %c\n", *tag);
    }

  for (i = 0; i < ext_table_length; i++)
    {
      char new_mnemonic[15];

      strcpy (new_mnemonic, prefix);
      opcode[mask_start] = ext_table[i].nibble;
      strcat (new_mnemonic, ext_table[i].extension);
      strcat (new_mnemonic, suffix);
      insertOpcode (opcode, new_mnemonic, format, min_cpu, mode_bits);
    }
  return;

 malformed_mnemonic:
  fprintf (stderr, "Malformed mnemonic: %s\n", mnemonic);
}

static const char file_header[] =
  "/* The opcode table. This file was generated by s390-mkopc.\n\n"
  "   The format of the opcode table is:\n\n"
  "   NAME	     OPCODE	MASK	OPERANDS\n\n"
  "   Name is the name of the instruction.\n"
  "   OPCODE is the instruction opcode.\n"
  "   MASK is the opcode mask; this is used to tell the disassembler\n"
  "     which bits in the actual opcode must match OPCODE.\n"
  "   OPERANDS is the list of operands.\n\n"
  "   The disassembler reads the table in order and prints the first\n"
  "   instruction which matches.  */\n\n"
  "const struct s390_opcode s390_opcodes[] =\n  {\n";

/* `dumpTable': write opcode table.  */

static void
dumpTable (void)
{
  char *str;
  int  ix;

  /*  Write hash table entries (slots).  */
  printf (file_header);

  for (ix = 0; ix < no_ops; ix++)
    {
      printf ("  { \"%s\", ", op_array[ix].mnemonic);
      for (str = op_array[ix].opcode; *str != 0; str++)
	if (*str == '?')
	  *str = '0';
      printf ("OP%i(0x%sLL), ",
	      op_array[ix].no_nibbles*4, op_array[ix].opcode);
      printf ("MASK_%s, INSTR_%s, ",
	      op_array[ix].format, op_array[ix].format);
      printf ("%i, ", op_array[ix].mode_bits);
      printf ("%i}", op_array[ix].min_cpu);
      if (ix < no_ops-1)
	printf (",\n");
      else
	printf ("\n");
    }
  printf ("};\n\n");
  printf ("const int s390_num_opcodes =\n");
  printf ("  sizeof (s390_opcodes) / sizeof (s390_opcodes[0]);\n\n");
}

int
main (void)
{
  char currentLine[256];

  createTable ();

  /*  Read opcode descriptions from `stdin'.  For each mnemonic,
      make an entry into the opcode table.  */
  while (fgets (currentLine, sizeof (currentLine), stdin) != NULL)
    {
      char  opcode[16];
      char  mnemonic[16];
      char  format[16];
      char  description[80];
      char  cpu_string[16];
      char  modes_string[16];
      int   min_cpu;
      int   mode_bits;
      char  *str;

      if (currentLine[0] == '#' || currentLine[0] == '\n')
        continue;
      memset (opcode, 0, 8);
      if (sscanf (currentLine, "%15s %15s %15s \"%79[^\"]\" %15s %15s",
		  opcode, mnemonic, format, description,
		  cpu_string, modes_string) == 6)
	{
	  if (strcmp (cpu_string, "g5") == 0)
	    min_cpu = S390_OPCODE_G5;
	  else if (strcmp (cpu_string, "g6") == 0)
	    min_cpu = S390_OPCODE_G6;
	  else if (strcmp (cpu_string, "z900") == 0)
	    min_cpu = S390_OPCODE_Z900;
	  else if (strcmp (cpu_string, "z990") == 0)
	    min_cpu = S390_OPCODE_Z990;
	  else if (strcmp (cpu_string, "z9-109") == 0)
	    min_cpu = S390_OPCODE_Z9_109;
	  else if (strcmp (cpu_string, "z9-ec") == 0)
	    min_cpu = S390_OPCODE_Z9_EC;
	  else if (strcmp (cpu_string, "z10") == 0)
	    min_cpu = S390_OPCODE_Z10;
	  else if (strcmp (cpu_string, "z196") == 0)
	    min_cpu = S390_OPCODE_Z196;
	  else if (strcmp (cpu_string, "zEC12") == 0)
	    min_cpu = S390_OPCODE_ZEC12;
	  else {
	    fprintf (stderr, "Couldn't parse cpu string %s\n", cpu_string);
	    exit (1);
	  }

	  str = modes_string;
	  mode_bits = 0;
	  do {
	    if (strncmp (str, "esa", 3) == 0
		&& (str[3] == 0 || str[3] == ',')) {
	      mode_bits |= 1 << S390_OPCODE_ESA;
	      str += 3;
	    } else if (strncmp (str, "zarch", 5) == 0
		       && (str[5] == 0 || str[5] == ',')) {
	      mode_bits |= 1 << S390_OPCODE_ZARCH;
	      str += 5;
	    } else {
	      fprintf (stderr, "Couldn't parse modes string %s\n",
		       modes_string);
	      exit (1);
	    }
	    if (*str == ',')
	      str++;
	  } while (*str != 0);

	  insertExpandedMnemonic (opcode, mnemonic, format, min_cpu, mode_bits);
	}
      else
	{
	  fprintf (stderr, "Couldn't scan line %s\n", currentLine);
	  exit (1);
	}
    }

  dumpTable ();
  return 0;
}
@


1.20
log
@2012-10-26  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390-mkopc.c: Accept empty lines in s390-opc.txt.
	* s390-opc.c: Add M_20OPT field. New instruction formats RRF_RURR2 and RRF_RMRR.
	* s390-opc.txt: Add new instructions.  New instruction type for lptea.

2012-10-26  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* gas/testsuite/gas/s390/zarch-z10.d: Refreshed.
	* gas/testsuite/gas/s390/zarch-z10.s: Refreshed.
	* gas/testsuite/gas/s390/zarch-z196.d: Refreshed.
	* gas/testsuite/gas/s390/zarch-z196.s: Refreshed.
	* gas/testsuite/gas/s390/zarch-z9-109.d: Refreshed.
	* gas/testsuite/gas/s390/zarch-z990.d: Refreshed.
	* gas/testsuite/gas/s390/zarch-z990.s: Refreshed.
	* gas/testsuite/gas/s390/zarch-zEC12.d: Refreshed.
	* gas/testsuite/gas/s390/zarch-zEC12.s: Refreshed.
@
text
@d53 1
a53 1
    
d279 1
a279 1
static char file_header[] =
d309 1
a309 1
      printf ("OP%i(0x%sLL), ", 
d329 1
a329 1
  
@


1.19
log
@2012-10-04  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (s390_parse_cpu): Add new option zEC12.
	* doc/as.texinfo: Document new option zEC12.
	* doc/c-s390.texi: Likewise.

2012-10-04  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* gas/s390/s390.exp: Run zEC12 tests.
	* gas/s390/zarch-zEC12.d: New file.
	* gas/s390/zarch-zEC12.s: New file.

2012-10-04  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390-mkopc.c: Support new option zEC12.
	* s390-opc.c: Add new instruction formats.
	* s390-opc.txt: Add new instructions for zEC12.

2012-10-04  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390.h (s390_opcode_cpu_val): Add S390_OPCODE_ZEC12.
@
text
@d346 1
a346 1
      if (currentLine[0] == '#')
@


1.18
log
@	* s390-mkopc.c (main): Exit with error 1 if sscanf fails
	to parse all 6 parameters.
@
text
@d42 2
a43 1
    S390_OPCODE_Z196
d369 2
@


1.17
log
@	* s390-mkopc.c (main): Change description array size to 80.
	Add maximum length of 79 to description parsing.
@
text
@d396 4
a399 1
        fprintf (stderr, "Couldn't scan line %s\n", currentLine);
@


1.16
log
@2010-09-27  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390-mkopc.c (enum s390_opcde_cpu_val): Add S390_OPCODE_Z196.
	(main): Recognize the new CPU string.
	* s390-opc.c: Add new instruction formats and masks.
	* s390-opc.txt: Add new z196 instructions.

2010-09-27  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* opcode/s390.h: Add S390_OPCODE_Z196 to enum s390_opcode_cpu_val.

2010-09-27  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c: (md_parse_option): New option -march=z196.
	* doc/c-s390.texi: Document new option.

2010-09-27  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* gas/s390/s390.exp: Run the zarch-z196 test.
	* gas/s390/zarch-z196.d: Add new instructions.
	* gas/s390/zarch-z196.s: Likewise.
	* gas/s390/zarch-z9-109.d: Likewise.
	* gas/s390/zarch-z9-109.s: Likewise.
@
text
@d338 1
a338 1
      char  description[64];
d348 1
a348 1
      if (sscanf (currentLine, "%15s %15s %15s \"%[^\"]\" %15s %15s",
@


1.15
log
@update copyright dates
@
text
@d41 2
a42 1
    S390_OPCODE_Z10
d366 2
@


1.14
log
@2008-04-10  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* s390-mkopc.c (insertExpandedMnemonic): Expand string sizes
	of local variables used for mnemonic parsing: prefix, suffix and
	number.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2003, 2007, 2008 Free Software Foundation, Inc.
@


1.13
log
@2008-04-10  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* s390-mkopc.c (s390_cond_ext_format): Add back the mnemonic
	extensions for conditional jumps (o, p, m, nz, z, nm, np, no).
	(s390_crb_extensions): New extensions table.
	(insertExpandedMnemonic): Handle '$' tag.
	* s390-opc.txt: Remove conditional jump variants which can now
	be expanded automatically.
	Replace '*' tag with '$' in the compare and branch instructions.

2008-04-10  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* gas/s390/zarch-z10.d: Map the compare and branch variants
	with odd condition code mask to version with an even mask.
@
text
@d180 3
a182 3
  char prefix[5];
  char suffix[5];
  char number[5];
@


1.12
log
@2008-03-19  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* opcodes/s390-mkopc.c (s390_opcode_cpu_val): S390_OPCODE_Z10 added.
	(s390_cond_extensions): Reduced extensions to the compare related.
	(main): z10 cpu type option added.
	(expandConditionalJump): Renamed to ...
	(insertExpandedMnemonic): ... this.

	* opcodes/s390-opc.c: Re-group the operand format makros.
	(INSTR_RIE_RRPU, INSTR_RIE_RRP0, INSTR_RIE_RUPI,
	INSTR_RIE_R0PI, INSTR_RIE_RUPU, INSTR_RIE_R0PU, INSTR_RIE_R0IU,
	INSTR_RIE_R0I0, INSTR_RIE_R0UU, INSTR_RIE_R0U0,
	INSTR_RIE_RRUUU, INSTR_RIS_RURDI, INSTR_RIS_R0RDI, INSTR_RIS_RURDU,
	INSTR_RIS_R0RDU, INSTR_RRF_U0RR, INSTR_RRF_00RR, INSTR_RRS_RRRDU,
	INSTR_RRS_RRRD0, INSTR_RXY_URRD, INSTR_SIY_IRD, INSTR_SIL_RDI,
	INSTR_SIL_RDU): New instruction formats added.
	(MASK_RIE_RRPU, MASK_RIE_RRP0, MASK_RIE_RUPI, MASK_RIE_R0PI,
	MASK_RIE_RUPU, MASK_RIE_R0PU, MASK_RIE_R0IU, MASK_RIE_R0I0,
	MASK_RIE_R0UU, MASK_RIE_R0U0, MASK_RIE_RRUUU, MASK_RIS_RURDI,
	MASK_RIS_R0RDI, MASK_RIS_RURDU, MASK_RIS_R0RDU, MASK_RRF_U0RR,
	MASK_RRF_00RR, MASK_RRS_RRRDU, MASK_RRS_RRRD0, MASK_RXY_URRD,
	MASK_SIY_IRD, MASK_SIL_RDI, MASK_SIL_RDU): New instruction format
	masks added.
	(s390_opformats): New formats added "ris", "rrs", "sil".
	* opcodes/s390-opc.txt: Add the conditional jumps with the
	extensions removed from automatic expansion in s390-mkopc.c manually.
	(asi - trtre): Add new System z10 EC instructions.
	* include/opcode/s390.h (s390_opcode_cpu_val): S390_OPCODE_Z10 added.

2008-03-19  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* config/tc-s390.c (md_parse_option): z10 option added.

2008-03-19  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* gas/s390/zarch-z10.d: New file.
	* gas/s390/zarch-z10.s: New file.
	* gas/s390/s390.exp: Run the z10 testcases.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2003, 2007 Free Software Foundation, Inc.
d125 1
a125 1
/* The mnemonic extensions for conditional branches used to replace
d127 1
a127 1
#define NUM_COND_EXTENSIONS 12
d129 3
a131 1
{ { '2', "h" },    /* jump on A high */
d134 1
d138 1
d140 1
d144 1
d147 20
d185 2
d188 1
a188 1
  if (!(tag = strchr (mnemonic, '*')))
d248 14
a261 1
  for (i = 0; i < NUM_COND_EXTENSIONS; i++)
d266 2
a267 2
      opcode[mask_start] = s390_cond_extensions[i].nibble;
      strcat (new_mnemonic, s390_cond_extensions[i].extension);
@


1.11
log
@2007-08-21  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* s390-mkopc.c (struct s390_cond_ext_format): New global struct.
	(s390_cond_ext_format): New global variable.
	(expandConditionalJump): New function.
	(main): Invoke expandConditionalJump for mnemonics containing '*'.
	* s390-opc.txt: Replace mnemonics with conditional
	mask extensions with instructions using the newly introduced '*' tag.
@
text
@d40 2
a41 1
    S390_OPCODE_Z9_EC
d125 3
a127 2
#define NUM_COND_EXTENSIONS 20

d129 13
a141 22
  {
    { '1', "o" },    /* jump on overflow / if ones */
    { '2', "h" },    /* jump on A high */
    { '2', "p" },    /* jump on plus */
    { '3', "nle" },  /* jump on not low or equal */
    { '4', "l" },    /* jump on A low */
    { '4', "m" },    /* jump on minus / if mixed */
    { '5', "nhe" },  /* jump on not high or equal */
    { '6', "lh" },   /* jump on low or high */
    { '7', "ne" },   /* jump on A not equal B */
    { '7', "nz" },   /* jump on not zero / if not zeros */
    { '8', "e" },    /* jump on A equal B */
    { '8', "z" },    /* jump on zero / if zeros */
    { '9', "nlh" },  /* jump on not low or high */
    { 'a', "he" },   /* jump on high or equal */
    { 'b', "nl" },   /* jump on A not low */
    { 'b', "nm" },   /* jump on not minus / if not mixed */
    { 'c', "le" },   /* jump on low or equal */
    { 'd', "nh" },   /* jump on A not high */
    { 'd', "np" },   /* jump on not plus */
    { 'e', "no" },   /* jump on not overflow / if not ones */
  };
d146 2
a147 2
   s390_cond_extensions with the '*<number>' tag replaced by the
   respective mnemonic extensions.  */
d150 2
a151 2
expandConditionalJump (char *opcode, char *mnemonic, char *format,
		       int min_cpu, int mode_bits)
d153 1
d157 1
a157 1
  int mask_start, i = 0, star_found = 0, reading_number = 0;
d160 6
d168 1
a168 1
      switch (mnemonic[i])
d170 1
a170 2
	case '*':
	  if (star_found)
d173 1
a173 1
	  star_found = 1;
a174 23
	  break;

	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	  if (!star_found || !reading_number)
	    goto malformed_mnemonic;

	  number[number_p++] = mnemonic[i];
	  break;

	default:
	  if (reading_number)
	    {
	      if (!number_p)
		goto malformed_mnemonic;
	      else
		reading_number = 0;
	    }

	  if (star_found)
	    suffix[suffix_p++] = mnemonic[i];
	  else
	    prefix[prefix_p++] = mnemonic[i];
d176 25
d225 1
a227 1
      opcode[mask_start] = s390_cond_extensions[i].nibble;
d322 2
d349 1
a349 5
	  if (!strchr (mnemonic, '*'))
	    insertOpcode (opcode, mnemonic, format, min_cpu, mode_bits);
	  else
	    expandConditionalJump (opcode, mnemonic, format,
				   min_cpu, mode_bits);
@


1.10
log
@Change source files over to GPLv3.
@
text
@d118 117
d345 6
a350 1
	  insertOpcode (opcode, mnemonic, format, min_cpu, mode_bits);
@


1.9
log
@2007-03-06  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* opcodes/s390-opc.c (INSTR_RRE_FR, INSTR_RRF_F0FF2, INSTR_RRF_F0FR,
	INSTR_RRF_UUFF, INSTR_RRF_0UFF, INSTR_RRF_FFFU,	INSTR_RRR_F0FF): New
	instruction formats added.
	(MASK_RRE_FR, MASK_RRF_F0FF2, MASK_RRF_F0FR, MASK_RRF_UUFF,
	MASK_RRF_0UFF, MASK_RRF_FFFU, MASK_RRR_F0FF): New instruction format
	masks added.
	* opcodes/s390-opc.txt (lpdfr - tgxt): Decimal floating point
	instructions added.
	* opcodes/s390-mkopc.c (s390_opcode_cpu_val): S390_OPCODE_Z9_EC added.
	(main): z9-ec cpu type option added.
	* include/opcode/s390.h (s390_opcode_cpu_val): S390_OPCODE_Z9_EC added.

2007-03-06  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* config/tc-s390.c (md_parse_option): z9-ec option added.

2007-03-06  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* gas/s390/zarch-z9-ec.d: New file.
	* gas/s390/zarch-z9-ec.s: New file.
	* gas/s390/s390.exp: Run the z9-ec testcases.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2003 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of GDB, GAS, and the GNU binutils.
d7 1
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d18 3
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */
@


1.8
log
@	* s390-dis.c (print_insn_s390): Print unsigned operands with %u.
	* s390-mkopc.c (s390_opcode_cpu_val): Add support for cpu type z9-109.
	(main): Likewise.
	* s390-opc.c (I32_16, U32_16, M_16): Add defines 32 bit immediates
	and 4 bit optional masks.
	(INSTR_RIL_RI, INSTR_RIL_RU, INSTR_RRF_M0RR, INSTR_RSE_CCRD,
	INSTR_RSY_CCRD, INSTR_SSF_RRDRD): Add new instruction formats.
	(MASK_RIL_RI, MASK_RIL_RU, MASK_RRF_M0RR, MASK_RSE_CCRD,
	MASK_RSY_CCRD, MASK_SSF_RRDRD): Likewise.
	(s390_opformats): Likewise.
	* s390-opc.txt: Add new instructions for cpu type z9-109.
@
text
@d39 2
a40 1
    S390_OPCODE_Z9_109
d202 2
@


1.7
log
@Update the address and phone number of the FSF
@
text
@d38 2
a39 1
    S390_OPCODE_Z990
d199 2
@


1.6
log
@update copyright dates
@
text
@d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.5
log
@        * s390-dis.c (s390_extract_operand): Add support for long displacements.
        * s390-mkopc.c (s390_opcode_cpu_val): Add support for cpu type z990.
        * s390-opc.c (D20_20): Add define for 20 bit displacements.
        (INSTR_RRF_R0RR, INSTR_RSL_R0RD, INSTR_RSY_RRRD, INSTR_RSY_RURD,
        INSTR_RSY_AARD, INSTR_RXY_RRRD, INSTR_RXY_FRRD, INSTR_SIY_URD): Add
        new instruction formats.
        (MASK_RRF_R0RR, MASK_RSL_R0RD, MASK_RSY_RRRD, MASK_RSY_RURD,
        MASK_RSY_AARD, MASK_RXY_RRRD, MASK_RXY_FRRD, MASK_SIY_URD): Likewise.
        (s390_opformats): Likewise.
        * s390-opc.txt: Add new instructions for cpu type z990. Add missing
        hfp instructions. Add missing instructions pgin, pgout and xsch.
@
text
@d2 1
a2 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
@


1.4
log
@	* s390-dis.c (init_disasm): Rename S390_OPCODE_ESAME to
	S390_OPCODE_ZARCH.
	(print_insn_s390): Use new modes field of s390_opcodes.
	* s390-mkopc.c (ARCHBITS_ESAONLY, ARCHBITS_ESA, ARCHBITS_ESAME): Remove.
	(s390_opcode_mode_val, s390_opcode_cpu_val): New enums.
	(struct op_struct): Remove archbits. Add mode_bits and min_cpu.
	(insertOpcode): Replace archbits by min_cpu and mode_bits.
	(dumpTable): Write mode_bits and min_cpu instead of archbits.
	(main): Adapt to new format in s390-opcode.txt.
	* s390-opc.c (s390_opformats): Replace archbits by min_cpu and
	mode_bits.
	* s390-opc.txt: Replace archbits by min_cpu and mode_bits.
@
text
@d37 2
a38 1
    S390_OPCODE_Z900
d196 2
@


1.3
log
@s390 assembler improvements and testsuite
@
text
@d26 13
a38 8
/* ARCHBITS_ESA and ARCH_ESAME correspond to the bit numbers defined
   by s390_opcode_arch_val in include/opcode/s390.h:
     ARCHBITS_ESAONLY = (1<<S390_OPCODE_ESA)
     ARCHBITS_ESA     = (1<<S390_OPCODE_ESA) + (1<<S390_OPCODE_ESAME)
     ARCHBITS_ESA     = (1<<S390_OPCODE_ESAME).  */
#define ARCHBITS_ESAONLY 1
#define ARCHBITS_ESA     3
#define ARCHBITS_ESAME   2
d45 3
a47 1
    int   archbits;
d67 2
a68 1
insertOpcode (char *opcode, char *mnemonic, char *format, int archbits)
d98 1
d110 2
a111 1
  op_array[ix].archbits = archbits;
d149 2
a150 1
      printf ("%i}", op_array[ix].archbits);
d176 5
a180 2
      char  archtag[16];
      int   archbits;
d185 3
a187 2
      if (sscanf (currentLine, "%15s %15s %15s \"%[^\"]\" %15s",
		  opcode, mnemonic, format, description, archtag) == 5)
d189 31
a219 9
	  if (strcmp (archtag, "esaonly") == 0)
	    archbits = ARCHBITS_ESAONLY;
	  else if (strcmp (archtag, "esa") == 0)
	    archbits = ARCHBITS_ESA;
	  else if (strcmp (archtag, "esame") == 0)
	    archbits = ARCHBITS_ESAME;
	  else
	    archbits = 0;
	  insertOpcode (opcode, mnemonic, format, archbits);
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d26 8
a33 14
/* Taken from opcodes/s390.h */
enum s390_opcode_mode_val
  {
    S390_OPCODE_ESA = 0,
    S390_OPCODE_ZARCH
  };

enum s390_opcode_cpu_val
  {
    S390_OPCODE_G5 = 0,
    S390_OPCODE_G6,
    S390_OPCODE_Z900,
    S390_OPCODE_Z990
  };
d40 1
a40 3
    int   mode_bits;
    int   min_cpu;
    
d60 1
a60 2
insertOpcode (char *opcode, char *mnemonic, char *format,
	      int min_cpu, int mode_bits)
a89 1
  sort_value += (min_cpu << 8) + mode_bits;
d101 1
a101 2
  op_array[ix].min_cpu = min_cpu;
  op_array[ix].mode_bits = mode_bits;
d139 1
a139 2
      printf ("%i, ", op_array[ix].mode_bits);
      printf ("%i}", op_array[ix].min_cpu);
d165 2
a166 5
      char  cpu_string[16];
      char  modes_string[16];
      int   min_cpu;
      int   mode_bits;
      char  *str;
d171 2
a172 3
      if (sscanf (currentLine, "%15s %15s %15s \"%[^\"]\" %15s %15s",
		  opcode, mnemonic, format, description,
		  cpu_string, modes_string) == 6)
d174 9
a182 33
	  if (strcmp (cpu_string, "g5") == 0)
	    min_cpu = S390_OPCODE_G5;
	  else if (strcmp (cpu_string, "g6") == 0)
	    min_cpu = S390_OPCODE_G6;
	  else if (strcmp (cpu_string, "z900") == 0)
	    min_cpu = S390_OPCODE_Z900;
	  else if (strcmp (cpu_string, "z990") == 0)
	    min_cpu = S390_OPCODE_Z990;
	  else {
	    fprintf (stderr, "Couldn't parse cpu string %s\n", cpu_string);
	    exit (1);
	  }

	  str = modes_string;
	  mode_bits = 0;
	  do {
	    if (strncmp (str, "esa", 3) == 0
		&& (str[3] == 0 || str[3] == ',')) {
	      mode_bits |= 1 << S390_OPCODE_ESA;
	      str += 3;
	    } else if (strncmp (str, "zarch", 5) == 0
		       && (str[5] == 0 || str[5] == ',')) {
	      mode_bits |= 1 << S390_OPCODE_ZARCH;
	      str += 5;
	    } else {
	      fprintf (stderr, "Couldn't parse modes string %s\n",
		       modes_string);
	      exit (1);
	    }
	    if (*str == ',')
	      str++;
	  } while (*str != 0);
	  insertOpcode (opcode, mnemonic, format, min_cpu, mode_bits);
@


1.3.22.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d26 8
a33 13
/* Taken from opcodes/s390.h */
enum s390_opcode_mode_val
  {
    S390_OPCODE_ESA = 0,
    S390_OPCODE_ZARCH
  };

enum s390_opcode_cpu_val
  {
    S390_OPCODE_G5 = 0,
    S390_OPCODE_G6,
    S390_OPCODE_Z900
  };
d40 1
a40 3
    int   mode_bits;
    int   min_cpu;
    
d60 1
a60 2
insertOpcode (char *opcode, char *mnemonic, char *format,
	      int min_cpu, int mode_bits)
a89 1
  sort_value += (min_cpu << 8) + mode_bits;
d101 1
a101 2
  op_array[ix].min_cpu = min_cpu;
  op_array[ix].mode_bits = mode_bits;
d139 1
a139 2
      printf ("%i, ", op_array[ix].mode_bits);
      printf ("%i}", op_array[ix].min_cpu);
d165 2
a166 5
      char  cpu_string[16];
      char  modes_string[16];
      int   min_cpu;
      int   mode_bits;
      char  *str;
d171 2
a172 3
      if (sscanf (currentLine, "%15s %15s %15s \"%[^\"]\" %15s %15s",
		  opcode, mnemonic, format, description,
		  cpu_string, modes_string) == 6)
d174 9
a182 31
	  if (strcmp (cpu_string, "g5") == 0)
	    min_cpu = S390_OPCODE_G5;
	  else if (strcmp (cpu_string, "g6") == 0)
	    min_cpu = S390_OPCODE_G6;
	  else if (strcmp (cpu_string, "z900") == 0)
	    min_cpu = S390_OPCODE_Z900;
	  else {
	    fprintf (stderr, "Couldn't parse cpu string %s\n", cpu_string);
	    exit (1);
	  }

	  str = modes_string;
	  mode_bits = 0;
	  do {
	    if (strncmp (str, "esa", 3) == 0
		&& (str[3] == 0 || str[3] == ',')) {
	      mode_bits |= 1 << S390_OPCODE_ESA;
	      str += 3;
	    } else if (strncmp (str, "zarch", 5) == 0
		       && (str[5] == 0 || str[5] == ',')) {
	      mode_bits |= 1 << S390_OPCODE_ZARCH;
	      str += 5;
	    } else {
	      fprintf (stderr, "Couldn't parse modes string %s\n",
		       modes_string);
	      exit (1);
	    }
	    if (*str == ',')
	      str++;
	  } while (*str != 0);
	  insertOpcode (opcode, mnemonic, format, min_cpu, mode_bits);
@


1.3.22.2
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d37 1
a37 2
    S390_OPCODE_Z900,
    S390_OPCODE_Z990
a194 2
	  else if (strcmp (cpu_string, "z990") == 0)
	    min_cpu = S390_OPCODE_Z990;
@


1.2
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d35 9
a43 8
struct op_struct {
	char  opcode[16];
	char  mnemonic[16];
	char  format[16];
        int   archbits;
        unsigned long long sort_value;
        int   no_nibbles;
};
d50 1
a50 1
createTable(void)
d52 3
a54 3
    max_ops = 256;
    op_array = malloc(max_ops*sizeof(struct op_struct));
    no_ops = 0;
d57 2
a58 3
/*
 *  `insertOpcode': insert an op_struct into sorted opcode array 
 */
d60 1
a60 1
insertOpcode(char *opcode, char *mnemonic, char *format, int archbits)
d62 10
a71 4
    char *str;
    unsigned long long sort_value;
    int no_nibbles;
    int ix, k;
d73 4
a76 7
    while (no_ops >= max_ops) {
      max_ops = max_ops*2;
      op_array = realloc(op_array, max_ops*sizeof(struct op_struct));
    }
    sort_value = 0;
    str = opcode;
    for (ix = 0; ix < 16; ix++) {
d87 1
a87 1
      str++;
d89 14
a102 14
    sort_value <<= 4*(16 - ix);
    no_nibbles = ix;
    for (ix = 0; ix < no_ops; ix++)
      if (sort_value > op_array[ix].sort_value)
        break;
    for (k = no_ops; k > ix; k--)
      op_array[k] = op_array[k-1];
    strcpy(op_array[ix].opcode, opcode);
    strcpy(op_array[ix].mnemonic, mnemonic);
    strcpy(op_array[ix].format, format);
    op_array[ix].sort_value = sort_value;
    op_array[ix].no_nibbles = no_nibbles;
    op_array[ix].archbits = archbits;
    no_ops++;
d105 14
a119 3
/*
 *  `dumpTable': write opcode table
 */
d121 1
a121 1
dumpTable(void)
d123 5
a127 2
    char *str;
    int  ix;
d129 3
a131 4
    /*  Write hash table entries (slots). */
    printf("const struct s390_opcode s390_opcodes[] = {\n");
    for (ix = 0; ix < no_ops; ix++) {
      printf("  { \"%s\", ", op_array[ix].mnemonic);
d135 5
a139 5
      printf("OP%i(0x%sLL), ", 
	     op_array[ix].no_nibbles*4, op_array[ix].opcode);
      printf("MASK_%s, INSTR_%s, ",
             op_array[ix].format, op_array[ix].format);
      printf("%i}", op_array[ix].archbits);
d141 1
a141 1
	printf(",\n");
d143 1
a143 1
	printf("\n");
d145 3
a147 3
    printf("};\n\n");
    printf("const int s390_num_opcodes =\n");
    printf("  sizeof (s390_opcodes) / sizeof (s390_opcodes[0]);\n\n");
a149 1

d151 1
a151 1
main(void)
d153 8
a160 7
    char currentLine[256];

    createTable();
    /*  Read opcode descriptions from `stdin'.  For each mnemonic,
     *  make an entry into the opcode table.
     */
    while (fgets(currentLine, sizeof(currentLine), stdin) != NULL) {
d170 16
a185 14
      memset(opcode, 0, 8);
      if (sscanf(currentLine, "%15s %15s %15s \"%[^\"]\" %15s",
                 opcode, mnemonic, format, description, archtag) == 5) {
        if (strcmp(archtag, "esaonly") == 0)
          archbits = ARCHBITS_ESAONLY;
        else if (strcmp(archtag, "esa") == 0)
          archbits = ARCHBITS_ESA;
        else if (strcmp(archtag, "esame") == 0)
          archbits = ARCHBITS_ESAME;
        else
          archbits = 0;
        insertOpcode(opcode, mnemonic, format, archbits);
      } else
        fprintf(stderr, "Couldn't scan line %s\n", currentLine);
d188 2
a189 2
    dumpTable();
    return 0;
@


1.1
log
@Add s390 support
@
text
@d2 1
a2 1
   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
@

