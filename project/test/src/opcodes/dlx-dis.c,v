head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	binutils-2_24-branch:1.6.0.18
	binutils-2_24-branchpoint:1.6
	binutils-2_21_1:1.6
	sid-snapshot-20130901:1.6
	gdb_7_6_1-2013-08-30-release:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	sid-snapshot-20130501:1.6
	gdb_7_6-2013-04-26-release:1.6
	sid-snapshot-20130401:1.6
	binutils-2_23_2:1.6
	gdb_7_6-branch:1.6.0.16
	gdb_7_6-2013-03-12-branchpoint:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	gdb_7_5_1-2012-11-29-release:1.6
	binutils-2_23_1:1.6
	sid-snapshot-20121101:1.6
	binutils-2_23:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	gdb_7_5-2012-08-17-release:1.6
	sid-snapshot-20120801:1.6
	binutils-2_23-branch:1.6.0.14
	binutils-2_23-branchpoint:1.6
	gdb_7_5-branch:1.6.0.12
	gdb_7_5-2012-07-18-branchpoint:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	binutils-2_22_branch:1.6.0.10
	gdb_7_4_1-2012-04-26-release:1.6
	sid-snapshot-20120401:1.6
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	gdb_7_4-2012-01-24-release:1.6
	sid-snapshot-20120101:1.6
	gdb_7_4-branch:1.6.0.8
	gdb_7_4-2011-12-13-branchpoint:1.6
	sid-snapshot-20111201:1.6
	binutils-2_22:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	binutils-2_22-branch:1.6.0.6
	binutils-2_22-branchpoint:1.6
	gdb_7_3_1-2011-09-04-release:1.6
	sid-snapshot-20110901:1.6
	sid-snapshot-20110801:1.6
	gdb_7_3-2011-07-26-release:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	gdb_7_3-branch:1.6.0.4
	gdb_7_3-2011-04-01-branchpoint:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	binutils-2_21:1.6
	sid-snapshot-20101201:1.6
	binutils-2_21-branch:1.6.0.2
	binutils-2_21-branchpoint:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	binutils-2_20_1:1.4
	gdb_7_2-2010-09-02-release:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	gdb_7_2-branch:1.5.0.2
	gdb_7_2-2010-07-07-branchpoint:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.4
	sid-snapshot-20100501:1.4
	sid-snapshot-20100401:1.4
	gdb_7_1-2010-03-18-release:1.4
	sid-snapshot-20100301:1.4
	gdb_7_1-branch:1.4.0.36
	gdb_7_1-2010-02-18-branchpoint:1.4
	sid-snapshot-20100201:1.4
	sid-snapshot-20100101:1.4
	gdb_7_0_1-2009-12-22-release:1.4
	sid-snapshot-20091201:1.4
	sid-snapshot-20091101:1.4
	binutils-2_20:1.4
	gdb_7_0-2009-10-06-release:1.4
	sid-snapshot-20091001:1.4
	gdb_7_0-branch:1.4.0.34
	gdb_7_0-2009-09-16-branchpoint:1.4
	arc-sim-20090309:1.4
	binutils-arc-20081103-branch:1.4.0.32
	binutils-arc-20081103-branchpoint:1.4
	binutils-2_20-branch:1.4.0.30
	binutils-2_20-branchpoint:1.4
	sid-snapshot-20090901:1.4
	sid-snapshot-20090801:1.4
	msnyder-checkpoint-072509-branch:1.4.0.28
	msnyder-checkpoint-072509-branchpoint:1.4
	sid-snapshot-20090701:1.4
	dje-cgen-play1-branch:1.4.0.26
	dje-cgen-play1-branchpoint:1.4
	sid-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	arc-20081103-branch:1.4.0.24
	arc-20081103-branchpoint:1.4
	arc-insight_6_8-branch:1.4.0.22
	arc-insight_6_8-branchpoint:1.4
	insight_6_8-branch:1.4.0.20
	insight_6_8-branchpoint:1.4
	sid-snapshot-20090301:1.4
	binutils-2_19_1:1.4
	sid-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	reverse-20081226-branch:1.4.0.18
	reverse-20081226-branchpoint:1.4
	sid-snapshot-20081201:1.4
	multiprocess-20081120-branch:1.4.0.16
	multiprocess-20081120-branchpoint:1.4
	sid-snapshot-20081101:1.4
	binutils-2_19:1.4
	sid-snapshot-20081001:1.4
	reverse-20080930-branch:1.4.0.14
	reverse-20080930-branchpoint:1.4
	binutils-2_19-branch:1.4.0.12
	binutils-2_19-branchpoint:1.4
	sid-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	reverse-20080717-branch:1.4.0.10
	reverse-20080717-branchpoint:1.4
	sid-snapshot-20080701:1.4
	msnyder-reverse-20080609-branch:1.4.0.8
	msnyder-reverse-20080609-branchpoint:1.4
	drow-reverse-20070409-branch:1.3.0.32
	drow-reverse-20070409-branchpoint:1.3
	sid-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	gdb_6_8-2008-03-27-release:1.4
	sid-snapshot-20080301:1.4
	gdb_6_8-branch:1.4.0.6
	gdb_6_8-2008-02-26-branchpoint:1.4
	sid-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	gdb_6_7_1-2007-10-29-release:1.4
	gdb_6_7-2007-10-10-release:1.4
	sid-snapshot-20071001:1.4
	gdb_6_7-branch:1.4.0.4
	gdb_6_7-2007-09-07-branchpoint:1.4
	binutils-2_18:1.4
	binutils-2_18-branch:1.4.0.2
	binutils-2_18-branchpoint:1.4
	insight_6_6-20070208-release:1.3
	binutils-csl-coldfire-4_1-32:1.3
	binutils-csl-sourcerygxx-4_1-32:1.3
	gdb_6_6-2006-12-18-release:1.3
	binutils-csl-innovasic-fido-3_4_4-33:1.3
	binutils-csl-sourcerygxx-3_4_4-32:1.1
	binutils-csl-coldfire-4_1-30:1.3
	binutils-csl-sourcerygxx-4_1-30:1.3
	binutils-csl-coldfire-4_1-28:1.3
	binutils-csl-sourcerygxx-4_1-29:1.3
	binutils-csl-sourcerygxx-4_1-28:1.3
	gdb_6_6-branch:1.3.0.30
	gdb_6_6-2006-11-15-branchpoint:1.3
	binutils-csl-arm-2006q3-27:1.3
	binutils-csl-sourcerygxx-4_1-27:1.3
	binutils-csl-arm-2006q3-26:1.3
	binutils-csl-sourcerygxx-4_1-26:1.3
	binutils-csl-sourcerygxx-4_1-25:1.3
	binutils-csl-sourcerygxx-4_1-24:1.3
	binutils-csl-sourcerygxx-4_1-23:1.3
	insight_6_5-20061003-release:1.3
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	binutils-csl-sourcerygxx-4_1-21:1.3
	binutils-csl-arm-2006q3-21:1.3
	binutils-csl-sourcerygxx-4_1-22:1.3
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.3
	binutils-csl-sourcerygxx-4_1-20:1.3
	binutils-csl-arm-2006q3-19:1.3
	binutils-csl-sourcerygxx-4_1-19:1.3
	binutils-csl-sourcerygxx-4_1-18:1.3
	binutils-csl-renesas-4_1-9:1.3
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	binutils-csl-sourcerygxx-3_4_4-25:1.1
	nickrob-async-20060828-mergepoint:1.3
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	binutils-csl-renesas-4_1-8:1.3
	binutils-csl-renesas-4_1-7:1.3
	binutils-csl-renesas-4_1-6:1.3
	gdb-csl-sourcerygxx-4_1-17:1.3
	binutils-csl-sourcerygxx-4_1-17:1.3
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	binutils-csl-sourcerygxx-4_1-14:1.3
	binutils-csl-sourcerygxx-4_1-15:1.3
	gdb-csl-sourcerygxx-4_1-13:1.3
	binutils-csl-sourcerygxx-4_1-13:1.3
	binutils-2_17:1.3
	gdb-csl-sourcerygxx-4_1-12:1.3
	binutils-csl-sourcerygxx-4_1-12:1.3
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	binutils-csl-sourcerygxx-3_4_4-21:1.3
	gdb_6_5-20060621-release:1.3
	binutils-csl-wrs-linux-3_4_4-24:1.1
	binutils-csl-wrs-linux-3_4_4-23:1.1
	gdb-csl-sourcerygxx-4_1-9:1.3
	binutils-csl-sourcerygxx-4_1-9:1.3
	gdb-csl-sourcerygxx-4_1-8:1.3
	binutils-csl-sourcerygxx-4_1-8:1.3
	gdb-csl-sourcerygxx-4_1-7:1.3
	binutils-csl-sourcerygxx-4_1-7:1.3
	gdb-csl-arm-2006q1-6:1.3
	binutils-csl-arm-2006q1-6:1.3
	gdb-csl-sourcerygxx-4_1-6:1.3
	binutils-csl-sourcerygxx-4_1-6:1.3
	binutils-csl-wrs-linux-3_4_4-22:1.1
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	binutils-csl-coldfire-4_1-11:1.3
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	binutils-csl-sourcerygxx-3_4_4-19:1.3
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.3.0.28
	gdb_6_5-2006-05-14-branchpoint:1.3
	binutils-csl-coldfire-4_1-10:1.3
	gdb-csl-sourcerygxx-4_1-5:1.3
	binutils-csl-sourcerygxx-4_1-5:1.3
	nickrob-async-20060513-branch:1.3.0.26
	nickrob-async-20060513-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-4:1.3
	binutils-csl-sourcerygxx-4_1-4:1.3
	msnyder-reverse-20060502-branch:1.3.0.24
	msnyder-reverse-20060502-branchpoint:1.3
	binutils-csl-wrs-linux-3_4_4-21:1.1
	gdb-csl-morpho-4_1-4:1.3
	binutils-csl-morpho-4_1-4:1.3
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	binutils-csl-sourcerygxx-3_4_4-17:1.3
	binutils-csl-wrs-linux-3_4_4-20:1.1
	readline_5_1-import-branch:1.3.0.22
	readline_5_1-import-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	binutils-2_17-branch:1.3.0.20
	binutils-2_17-branchpoint:1.3
	gdb-csl-symbian-20060226-branch:1.3.0.18
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.3.0.16
	msnyder-reverse-20060331-branchpoint:1.3
	binutils-csl-2_17-branch:1.3.0.14
	binutils-csl-2_17-branchpoint:1.3
	gdb-csl-available-20060303-branch:1.3.0.12
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.10
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.8
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.4
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.2
	gdb-csl-arm-20051020-branchpoint:1.3
	binutils-csl-gxxpro-3_4-branch:1.1.0.88
	binutils-csl-gxxpro-3_4-branchpoint:1.1
	binutils-2_16_1:1.1
	msnyder-tracepoint-checkpoint-branch:1.2.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.2
	gdb-csl-arm-20050325-2005-q1b:1.1
	binutils-csl-arm-2005q1b:1.1
	binutils-2_16:1.1
	gdb-csl-arm-20050325-2005-q1a:1.1
	binutils-csl-arm-2005q1a:1.1
	csl-arm-20050325-branch:1.1.0.86
	csl-arm-20050325-branchpoint:1.1
	binutils-csl-arm-2005q1-branch:1.1.0.84
	binutils-csl-arm-2005q1-branchpoint:1.1
	binutils-2_16-branch:1.1.0.82
	binutils-2_16-branchpoint:1.1
	csl-arm-2004-q3d:1.1
	gdb_6_3-20041109-release:1.1
	gdb_6_3-branch:1.1.0.78
	gdb_6_3-20041019-branchpoint:1.1
	csl-arm-2004-q3:1.1
	drow_intercu-merge-20040921:1.1
	drow_intercu-merge-20040915:1.1
	jimb-gdb_6_2-e500-branch:1.1.0.80
	jimb-gdb_6_2-e500-branchpoint:1.1
	gdb_6_2-20040730-release:1.1
	gdb_6_2-branch:1.1.0.76
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1
	gdb_6_1_1-20040616-release:1.1
	binutils-2_15:1.1
	binutils-2_15-branchpoint:1.1
	csl-arm-2004-q1a:1.1
	csl-arm-2004-q1:1.1
	gdb_6_1-2004-04-05-release:1.1
	drow_intercu-merge-20040402:1.1
	drow_intercu-merge-20040327:1.1
	ezannoni_pie-20040323-branch:1.1.0.74
	ezannoni_pie-20040323-branchpoint:1.1
	cagney_tramp-20040321-mergepoint:1.1
	cagney_tramp-20040309-branch:1.1.0.72
	cagney_tramp-20040309-branchpoint:1.1
	gdb_6_1-branch:1.1.0.70
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1
	drow_intercu-20040221-branch:1.1.0.68
	drow_intercu-20040221-branchpoint:1.1
	binutils-2_15-branch:1.1.0.66
	cagney_bfdfile-20040213-branch:1.1.0.64
	cagney_bfdfile-20040213-branchpoint:1.1
	drow-cplus-merge-20040208:1.1
	carlton_dictionary-20040126-merge:1.1
	cagney_bigcore-20040122-branch:1.1.0.62
	cagney_bigcore-20040122-branchpoint:1.1
	drow-cplus-merge-20040113:1.1
	csl-arm-2003-q4:1.1
	drow-cplus-merge-20031224:1.1
	drow-cplus-merge-20031220:1.1
	carlton_dictionary-20031215-merge:1.1
	drow-cplus-merge-20031214:1.1
	carlton-dictionary-20031111-merge:1.1
	gdb_6_0-2003-10-04-release:1.1
	kettenis_sparc-20030918-branch:1.1.0.60
	kettenis_sparc-20030918-branchpoint:1.1
	carlton_dictionary-20030917-merge:1.1
	ezannoni_pie-20030916-branchpoint:1.1
	ezannoni_pie-20030916-branch:1.1.0.58
	cagney_x86i386-20030821-branch:1.1.0.56
	cagney_x86i386-20030821-branchpoint:1.1
	carlton_dictionary-20030805-merge:1.1
	carlton_dictionary-20030627-merge:1.1
	gdb_6_0-branch:1.1.0.54
	gdb_6_0-2003-06-23-branchpoint:1.1
	jimb-ppc64-linux-20030613-branch:1.1.0.52
	jimb-ppc64-linux-20030613-branchpoint:1.1
	binutils-2_14:1.1
	cagney_convert-20030606-branch:1.1.0.50
	cagney_convert-20030606-branchpoint:1.1
	cagney_writestrings-20030508-branch:1.1.0.48
	cagney_writestrings-20030508-branchpoint:1.1
	jimb-ppc64-linux-20030528-branch:1.1.0.46
	jimb-ppc64-linux-20030528-branchpoint:1.1
	carlton_dictionary-20030523-merge:1.1
	cagney_fileio-20030521-branch:1.1.0.44
	cagney_fileio-20030521-branchpoint:1.1
	kettenis_i386newframe-20030517-mergepoint:1.1
	jimb-ppc64-linux-20030509-branch:1.1.0.42
	jimb-ppc64-linux-20030509-branchpoint:1.1
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	binutils-2_14-branch:1.1.0.40
	binutils-2_14-branchpoint:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.38
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-20030416-merge:1.1
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.36
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.34
	cagney_framebase-20030330-mergepoint:1.1
	cagney_framebase-20030326-branch:1.1.0.32
	cagney_framebase-20030326-branchpoint:1.1
	cagney_lazyid-20030317-branch:1.1.0.30
	cagney_lazyid-20030317-branchpoint:1.1
	kettenis-i386newframe-20030316-mergepoint:1.1
	offbyone-20030313-branch:1.1.0.28
	offbyone-20030313-branchpoint:1.1
	kettenis-i386newframe-20030308-branch:1.1.0.26
	kettenis-i386newframe-20030308-branchpoint:1.1
	carlton_dictionary-20030305-merge:1.1
	cagney_offbyone-20030303-branch:1.1.0.24
	cagney_offbyone-20030303-branchpoint:1.1
	carlton_dictionary-20030207-merge:1.1
	interps-20030202-branch:1.1.0.22
	interps-20030202-branchpoint:1.1
	cagney-unwind-20030108-branch:1.1.0.20
	cagney-unwind-20030108-branchpoint:1.1
	binutils-2_13_2_1:1.1
	binutils-2_13_2:1.1
	carlton_dictionary-20021223-merge:1.1
	gdb_5_3-2002-12-12-release:1.1
	carlton_dictionary-20021115-merge:1.1
	binutils-2_13_1:1.1
	kseitz_interps-20021105-merge:1.1
	kseitz_interps-20021103-merge:1.1
	drow-cplus-merge-20021020:1.1
	drow-cplus-merge-20021025:1.1
	carlton_dictionary-20021025-merge:1.1
	carlton_dictionary-20021011-merge:1.1
	drow-cplus-branch:1.1.0.18
	drow-cplus-branchpoint:1.1
	kseitz_interps-20020930-merge:1.1
	carlton_dictionary-20020927-merge:1.1
	carlton_dictionary-branch:1.1.0.16
	carlton_dictionary-20020920-branchpoint:1.1
	sid-20020905-branchpoint:1.1
	sid-20020905-branch:1.1.0.14
	gdb_5_3-branch:1.1.0.12
	gdb_5_3-2002-09-04-branchpoint:1.1
	kseitz_interps-20020829-merge:1.1
	cagney_sysregs-20020825-branch:1.1.0.10
	cagney_sysregs-20020825-branchpoint:1.1
	readline_4_3-import-branch:1.1.0.8
	readline_4_3-import-branchpoint:1.1
	binutils-2_13:1.1
	binutils-2_13-branchpoint:1.1
	binutils-2_13-branch:1.1.0.6
	cagney_regbuf-20020515-branch:1.1.0.4
	binutils_latest_snapshot:1.6
	kseitz_interps-20020528-branch:1.1.0.2
	kseitz_interps-20020528-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.6
date	2010.09.10.13.00.54;	author muller;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.27.04.07.55;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.01.11.16.31;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.07.07.34.27;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.28.14.08.47;	author nickc;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2002.06.15.16.43.20;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.6
log
@	* src/opcodes/dlx-dis.c (print_insn_dlx): Use dlx_insn type for
	dlx_insn_type array.
@
text
@/* Instruction printing code for the DLX Microprocessor
   Copyright 2002, 2005, 2007, 2010 Free Software Foundation, Inc.
   Contributed by Kuang Hwa Lin.  Written by Kuang Hwa Lin, 03/2002.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "opcode/dlx.h"

#define R_ERROR     0x1
#define R_TYPE      0x2
#define ILD_TYPE    0x3
#define IST_TYPE    0x4
#define IAL_TYPE    0x5
#define IBR_TYPE    0x6
#define IJ_TYPE     0x7
#define IJR_TYPE    0x8
#define NIL         0x9

#define OPC(x)      ((x >> 26) & 0x3F)
#define FUNC(x)     (x & 0x7FF)

unsigned char opc, rs1, rs2, rd;
unsigned long imm26, imm16, func, current_insn_addr;

/* Print one instruction from MEMADDR on INFO->STREAM.
   Return the size of the instruction (always 4 on dlx).  */

static unsigned char
dlx_get_opcode (unsigned long opcode)
{
  return (unsigned char) ((opcode >> 26) & 0x3F);
}

static unsigned char
dlx_get_rs1 (unsigned long opcode)
{
  return (unsigned char) ((opcode >> 21) & 0x1F);
}

static unsigned char
dlx_get_rs2 (unsigned long opcode)
{
  return (unsigned char) ((opcode >> 16) & 0x1F);
}

static unsigned char
dlx_get_rdR (unsigned long opcode)
{
  return (unsigned char) ((opcode >> 11) & 0x1F);
}

static unsigned long
dlx_get_func (unsigned long opcode)
{
  return (unsigned char) (opcode & 0x7FF);
}

static unsigned long
dlx_get_imm16 (unsigned long opcode)
{
  return (unsigned long) (opcode & 0xFFFF);
}

static unsigned long
dlx_get_imm26 (unsigned long opcode)
{
  return (unsigned long) (opcode & 0x03FFFFFF);
}

/* Fill the opcode to the max length.  */

static void
operand_deliminator (struct disassemble_info *info, char *ptr)
{
  int difft = 8 - (int) strlen (ptr);

  while (difft > 0)
    {
      (*info->fprintf_func) (info->stream, "%c", ' ');
      difft -= 1;
    }
}

/* Process the R-type opcode.  */

static unsigned char
dlx_r_type (struct disassemble_info *info)
{
  unsigned char r_opc[] = { OPC(ALUOP) }; /* Fix ME */
  int r_opc_num = (sizeof r_opc) / (sizeof (char));
  struct _r_opcode
  {
    unsigned long func;
    char *name;
  }
  dlx_r_opcode[] =
  {
    { NOPF,     "nop"    },  /* NOP                          */
    { ADDF,     "add"    },  /* Add                          */
    { ADDUF,    "addu"   },  /* Add Unsigned                 */
    { SUBF,     "sub"    },  /* SUB                          */
    { SUBUF,    "subu"   },  /* Sub Unsigned                 */
    { MULTF,    "mult"   },  /* MULTIPLY                     */
    { MULTUF,   "multu"  },  /* MULTIPLY Unsigned            */
    { DIVF,     "div"    },  /* DIVIDE                       */
    { DIVUF,    "divu"   },  /* DIVIDE Unsigned              */
    { ANDF,     "and"    },  /* AND                          */
    { ORF,      "or"     },  /* OR                           */
    { XORF,     "xor"    },  /* Exclusive OR                 */
    { SLLF,     "sll"    },  /* SHIFT LEFT LOGICAL           */
    { SRAF,     "sra"    },  /* SHIFT RIGHT ARITHMETIC       */
    { SRLF,     "srl"    },  /* SHIFT RIGHT LOGICAL          */
    { SEQF,     "seq"    },  /* Set if equal                 */
    { SNEF,     "sne"    },  /* Set if not equal             */
    { SLTF,     "slt"    },  /* Set if less                  */
    { SGTF,     "sgt"    },  /* Set if greater               */
    { SLEF,     "sle"    },  /* Set if less or equal         */
    { SGEF,     "sge"    },  /* Set if greater or equal      */
    { SEQUF,    "sequ"   },  /* Set if equal                 */
    { SNEUF,    "sneu"   },  /* Set if not equal             */
    { SLTUF,    "sltu"   },  /* Set if less                  */
    { SGTUF,    "sgtu"   },  /* Set if greater               */
    { SLEUF,    "sleu"   },  /* Set if less or equal         */
    { SGEUF,    "sgeu"   },  /* Set if greater or equal      */
    { MVTSF,    "mvts"   },  /* Move to special register     */
    { MVFSF,    "mvfs"   },  /* Move from special register   */
    { BSWAPF,   "bswap"  },  /* Byte swap ??                 */
    { LUTF,     "lut"    }   /* ????????? ??                 */
  };
  int dlx_r_opcode_num = (sizeof dlx_r_opcode) / (sizeof dlx_r_opcode[0]);
  int idx;

  for (idx = 0; idx < r_opc_num; idx++)
    {
      if (r_opc[idx] != opc)
	continue;
      else
	break;
    }

  if (idx == r_opc_num)
    return NIL;

  for (idx = 0 ; idx < dlx_r_opcode_num; idx++)
    if (dlx_r_opcode[idx].func == func)
      {
	(*info->fprintf_func) (info->stream, "%s", dlx_r_opcode[idx].name);

	if (func != NOPF)
	  {
	    /* This is not a nop.  */
	    operand_deliminator (info, dlx_r_opcode[idx].name);
	    (*info->fprintf_func) (info->stream, "r%d,", (int)rd);
	    (*info->fprintf_func) (info->stream, "r%d", (int)rs1);
	    if (func != MVTSF && func != MVFSF)
	      (*info->fprintf_func) (info->stream, ",r%d", (int)rs2);
	  }
	return (unsigned char) R_TYPE;
      }

  return (unsigned char) R_ERROR;
}

/* Process the memory read opcode.  */

static unsigned char
dlx_load_type (struct disassemble_info* info)
{
  struct _load_opcode
  {
    unsigned long opcode;
    char *name;
  }
  dlx_load_opcode[] =
  {
    { OPC(LHIOP),   "lhi" },  /* Load HI to register.           */
    { OPC(LBOP),     "lb" },  /* load byte sign extended.       */
    { OPC(LBUOP),   "lbu" },  /* load byte unsigned.            */
    { OPC(LSBUOP),"ldstbu"},  /* load store byte unsigned.      */
    { OPC(LHOP),     "lh" },  /* load halfword sign extended.   */
    { OPC(LHUOP),   "lhu" },  /* load halfword unsigned.        */
    { OPC(LSHUOP),"ldsthu"},  /* load store halfword unsigned.  */
    { OPC(LWOP),     "lw" },  /* load word.                     */
    { OPC(LSWOP), "ldstw" }   /* load store word.               */
  };
  int dlx_load_opcode_num =
    (sizeof dlx_load_opcode) / (sizeof dlx_load_opcode[0]);
  int idx;

  for (idx = 0 ; idx < dlx_load_opcode_num; idx++)
    if (dlx_load_opcode[idx].opcode == opc)
      {
	if (opc == OPC (LHIOP))
	  {
	    (*info->fprintf_func) (info->stream, "%s", dlx_load_opcode[idx].name);
	    operand_deliminator (info, dlx_load_opcode[idx].name);
	    (*info->fprintf_func) (info->stream, "r%d,", (int)rs2);
	    (*info->fprintf_func) (info->stream, "0x%04x", (int)imm16);
	  }
	else
	  {
	    (*info->fprintf_func) (info->stream, "%s", dlx_load_opcode[idx].name);
	    operand_deliminator (info, dlx_load_opcode[idx].name);
	    (*info->fprintf_func) (info->stream, "r%d,", (int)rs2);
	    (*info->fprintf_func) (info->stream, "0x%04x[r%d]", (int)imm16, (int)rs1);
	  }

	return (unsigned char) ILD_TYPE;
    }

  return (unsigned char) NIL;
}

/* Process the memory store opcode.  */

static unsigned char
dlx_store_type (struct disassemble_info* info)
{
  struct _store_opcode
  {
    unsigned long opcode;
    char *name;
  }
  dlx_store_opcode[] =
  {
    { OPC(SBOP),     "sb" },  /* Store byte.      */
    { OPC(SHOP),     "sh" },  /* Store halfword.  */
    { OPC(SWOP),     "sw" },  /* Store word.      */
  };
  int dlx_store_opcode_num =
    (sizeof dlx_store_opcode) / (sizeof dlx_store_opcode[0]);
  int idx;

  for (idx = 0 ; idx < dlx_store_opcode_num; idx++)
    if (dlx_store_opcode[idx].opcode == opc)
      {
	(*info->fprintf_func) (info->stream, "%s", dlx_store_opcode[idx].name);
	operand_deliminator (info, dlx_store_opcode[idx].name);
	(*info->fprintf_func) (info->stream, "0x%04x[r%d],", (int)imm16, (int)rs1);
	(*info->fprintf_func) (info->stream, "r%d", (int)rs2);
	return (unsigned char) IST_TYPE;
      }

  return (unsigned char) NIL;
}

/* Process the Arithmetic and Logical I-TYPE opcode.  */

static unsigned char
dlx_aluI_type (struct disassemble_info* info)
{
  struct _aluI_opcode
  {
    unsigned long opcode;
    char *name;
  }
  dlx_aluI_opcode[] =
  {
    { OPC(ADDIOP),   "addi"  },  /* Store byte.      */
    { OPC(ADDUIOP),  "addui" },  /* Store halfword.  */
    { OPC(SUBIOP),   "subi"  },  /* Store word.      */
    { OPC(SUBUIOP),  "subui" },  /* Store word.      */
    { OPC(ANDIOP),   "andi"  },  /* Store word.      */
    { OPC(ORIOP),    "ori"   },  /* Store word.      */
    { OPC(XORIOP),   "xori"  },  /* Store word.      */
    { OPC(SLLIOP),   "slli"  },  /* Store word.      */
    { OPC(SRAIOP),   "srai"  },  /* Store word.      */
    { OPC(SRLIOP),   "srli"  },  /* Store word.      */
    { OPC(SEQIOP),   "seqi"  },  /* Store word.      */
    { OPC(SNEIOP),   "snei"  },  /* Store word.      */
    { OPC(SLTIOP),   "slti"  },  /* Store word.      */
    { OPC(SGTIOP),   "sgti"  },  /* Store word.      */
    { OPC(SLEIOP),   "slei"  },  /* Store word.      */
    { OPC(SGEIOP),   "sgei"  },  /* Store word.      */
    { OPC(SEQUIOP),  "sequi" },  /* Store word.      */
    { OPC(SNEUIOP),  "sneui" },  /* Store word.      */
    { OPC(SLTUIOP),  "sltui" },  /* Store word.      */
    { OPC(SGTUIOP),  "sgtui" },  /* Store word.      */
    { OPC(SLEUIOP),  "sleui" },  /* Store word.      */
    { OPC(SGEUIOP),  "sgeui" },  /* Store word.      */
#if 0						       
    { OPC(MVTSOP),   "mvts"  },  /* Store word.      */
    { OPC(MVFSOP),   "mvfs"  },  /* Store word.      */
#endif
  };
  int dlx_aluI_opcode_num =
    (sizeof dlx_aluI_opcode) / (sizeof dlx_aluI_opcode[0]);
  int idx;

  for (idx = 0 ; idx < dlx_aluI_opcode_num; idx++)
    if (dlx_aluI_opcode[idx].opcode == opc)
      {
	(*info->fprintf_func) (info->stream, "%s", dlx_aluI_opcode[idx].name);
	operand_deliminator (info, dlx_aluI_opcode[idx].name);
	(*info->fprintf_func) (info->stream, "r%d,", (int)rs2);
	(*info->fprintf_func) (info->stream, "r%d,", (int)rs1);
	(*info->fprintf_func) (info->stream, "0x%04x", (int)imm16);

	return (unsigned char) IAL_TYPE;
      }

  return (unsigned char) NIL;
}

/* Process the branch instruction.  */

static unsigned char
dlx_br_type (struct disassemble_info* info)
{
  struct _br_opcode
  {
    unsigned long opcode;
    char *name;
  }
  dlx_br_opcode[] =
  {
    { OPC(BEQOP), "beqz" }, /* Store byte.  */
    { OPC(BNEOP), "bnez" }  /* Store halfword.  */
  };
  int dlx_br_opcode_num =
    (sizeof dlx_br_opcode) / (sizeof dlx_br_opcode[0]);
  int idx;

  for (idx = 0 ; idx < dlx_br_opcode_num; idx++)
    if (dlx_br_opcode[idx].opcode == opc)
      {
	if (imm16 & 0x00008000)
	  imm16 |= 0xFFFF0000;

	imm16 += (current_insn_addr + 4);
	(*info->fprintf_func) (info->stream, "%s", dlx_br_opcode[idx].name);
	operand_deliminator (info, dlx_br_opcode[idx].name);
	(*info->fprintf_func) (info->stream, "r%d,", (int) rs1);
	(*info->fprintf_func) (info->stream, "0x%08x", (int) imm16);

	return (unsigned char) IBR_TYPE;
      }

  return (unsigned char) NIL;
}

/* Process the jump instruction.  */

static unsigned char
dlx_jmp_type (struct disassemble_info* info)
{
  struct _jmp_opcode
  {
    unsigned long opcode;
    char *name;
  }
  dlx_jmp_opcode[] =
  {
    { OPC(JOP),         "j" },  /* Store byte.      */
    { OPC(JALOP),     "jal" },  /* Store halfword.  */
    { OPC(BREAKOP), "break" },  /* Store halfword.  */
    { OPC(TRAPOP),   "trap" },  /* Store halfword.  */
    { OPC(RFEOP),     "rfe" }   /* Store halfword.  */
  };
  int dlx_jmp_opcode_num =
    (sizeof dlx_jmp_opcode) / (sizeof dlx_jmp_opcode[0]);
  int idx;

  for (idx = 0 ; idx < dlx_jmp_opcode_num; idx++)
    if (dlx_jmp_opcode[idx].opcode == opc)
      {
	if (imm26 & 0x02000000)
	  imm26 |= 0xFC000000;

	imm26 += (current_insn_addr + 4);

	(*info->fprintf_func) (info->stream, "%s", dlx_jmp_opcode[idx].name);
	operand_deliminator (info, dlx_jmp_opcode[idx].name);
	(*info->fprintf_func) (info->stream, "0x%08x", (int)imm26);

	return (unsigned char) IJ_TYPE;
      }

  return (unsigned char) NIL;
}

/* Process the jump register instruction.  */

static unsigned char
dlx_jr_type (struct disassemble_info* info)
{
  struct _jr_opcode
  {
    unsigned long opcode;
    char *name;
  }
  dlx_jr_opcode[] =
  {
    { OPC(JROP),   "jr"    },  /* Store byte.  */
    { OPC(JALROP), "jalr"  }   /* Store halfword.  */
  };
  int dlx_jr_opcode_num =
    (sizeof dlx_jr_opcode) / (sizeof dlx_jr_opcode[0]);
  int idx;

  for (idx = 0 ; idx < dlx_jr_opcode_num; idx++)
    if (dlx_jr_opcode[idx].opcode == opc)
      {
	(*info->fprintf_func) (info->stream, "%s", dlx_jr_opcode[idx].name);
	operand_deliminator (info, dlx_jr_opcode[idx].name);
	(*info->fprintf_func) (info->stream, "r%d", (int)rs1);
	return (unsigned char) IJR_TYPE;
      }

  return (unsigned char) NIL;
}

typedef unsigned char (* dlx_insn) (struct disassemble_info *);

/* This is the main DLX insn handling routine.  */

int
print_insn_dlx (bfd_vma memaddr, struct disassemble_info* info)
{
  bfd_byte buffer[4];
  int insn_idx;
  unsigned long insn_word;
  dlx_insn dlx_insn_type[] =
  {
    dlx_r_type,
    dlx_load_type,
    dlx_store_type,
    dlx_aluI_type,
    dlx_br_type,
    dlx_jmp_type,
    dlx_jr_type,
    (dlx_insn) NULL
  };
  int dlx_insn_type_num = ((sizeof dlx_insn_type) / (sizeof (dlx_insn))) - 1;
  int status =
    (*info->read_memory_func) (memaddr, (bfd_byte *) &buffer[0], 4, info);

  if (status != 0)
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }

  /* Now decode the insn    */
  insn_word = bfd_getb32 (buffer);
  opc  = dlx_get_opcode (insn_word);
  rs1  = dlx_get_rs1 (insn_word);
  rs2  = dlx_get_rs2 (insn_word);
  rd   = dlx_get_rdR (insn_word);
  func = dlx_get_func (insn_word);
  imm16= dlx_get_imm16 (insn_word);
  imm26= dlx_get_imm26 (insn_word);

#if 0
  printf ("print_insn_big_dlx: opc = 0x%02x\n"
	  "                    rs1 = 0x%02x\n"
	  "                    rs2 = 0x%02x\n"
	  "                    rd  = 0x%02x\n"
	  "                  func  = 0x%08x\n"
	  "                 imm16  = 0x%08x\n"
	  "                 imm26  = 0x%08x\n",
	  opc, rs1, rs2, rd, func, imm16, imm26);
#endif

  /* Scan through all the insn type and print the insn out.  */
  current_insn_addr = (unsigned long) memaddr;

  for (insn_idx = 0; dlx_insn_type[insn_idx] != 0x0; insn_idx++)
    switch ((dlx_insn_type[insn_idx]) (info))
      {
	/* Found the correct opcode   */
      case R_TYPE:
      case ILD_TYPE:
      case IST_TYPE:
      case IAL_TYPE:
      case IBR_TYPE:
      case IJ_TYPE:
      case IJR_TYPE:
	return 4;

	/* Wrong insn type check next one. */
      default:
      case NIL:
	continue;

	/* All rest of the return code are not recongnized, treat it as error */
	/* we should never get here,  I hope! */
      case R_ERROR:
	return -1;
      }

  if (insn_idx ==  dlx_insn_type_num)
    /* Well, does not recoganize this opcode.  */
    (*info->fprintf_func) (info->stream, "<%s>", "Unrecognized Opcode");

  return 4;
}
@


1.5
log
@fix set but unused variable warnings
@
text
@d440 1
a440 1
  unsigned long dlx_insn_type[] =
d442 8
a449 8
    (unsigned long) dlx_r_type,
    (unsigned long) dlx_load_type,
    (unsigned long) dlx_store_type,
    (unsigned long) dlx_aluI_type,
    (unsigned long) dlx_br_type,
    (unsigned long) dlx_jmp_type,
    (unsigned long) dlx_jr_type,
    (unsigned long) NULL
d451 1
a451 1
  int dlx_insn_type_num = ((sizeof dlx_insn_type) / (sizeof (unsigned long))) - 1;
d486 1
a486 1
    switch (((dlx_insn) (dlx_insn_type[insn_idx])) (info))
@


1.4
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 2002, 2005, 2007 Free Software Foundation, Inc.
a439 1
  unsigned char rtn_code;
a482 1
  rtn_code = 0;
@


1.3
log
@Update function declarations to ISO C90 formatting
@
text
@d2 1
a2 1
   Copyright 2002, 2005 Free Software Foundation, Inc.
d5 3
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.2
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 2002 Free Software Foundation, Inc.
d17 2
a18 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a39 16
static unsigned char dlx_get_opcode PARAMS ((unsigned long));
static unsigned char dlx_get_rs1    PARAMS ((unsigned long));
static unsigned char dlx_get_rs2    PARAMS ((unsigned long));
static unsigned char dlx_get_rdR    PARAMS ((unsigned long));
static unsigned long dlx_get_func   PARAMS ((unsigned long)); 
static unsigned long dlx_get_imm16  PARAMS ((unsigned long));
static unsigned long dlx_get_imm26  PARAMS ((unsigned long));
static void     operand_deliminator PARAMS ((struct disassemble_info *, char *));
static unsigned char dlx_r_type     PARAMS ((struct disassemble_info *));
static unsigned char dlx_load_type  PARAMS ((struct disassemble_info *));
static unsigned char dlx_store_type PARAMS ((struct disassemble_info *));
static unsigned char dlx_aluI_type  PARAMS ((struct disassemble_info *));
static unsigned char dlx_br_type    PARAMS ((struct disassemble_info *));
static unsigned char dlx_jmp_type   PARAMS ((struct disassemble_info *));
static unsigned char dlx_jr_type    PARAMS ((struct disassemble_info *));

d44 1
a44 2
dlx_get_opcode (opcode)
     unsigned long opcode;
d50 1
a50 2
dlx_get_rs1 (opcode)
     unsigned long opcode;
d56 1
a56 2
dlx_get_rs2 (opcode)
     unsigned long opcode;
d62 1
a62 2
dlx_get_rdR (opcode)
     unsigned long opcode;
d68 1
a68 2
dlx_get_func (opcode)
     unsigned long opcode;
d74 1
a74 2
dlx_get_imm16 (opcode)
     unsigned long opcode;
d80 1
a80 2
dlx_get_imm26 (opcode)
     unsigned long opcode;
d86 1
d88 1
a88 3
operand_deliminator (info, ptr)
     struct disassemble_info *info;
     char *ptr;
d100 1
d102 1
a102 2
dlx_r_type (info)
     struct disassemble_info *info;
d112 1
a112 1
    {
d154 1
a154 1
  }
d182 1
a182 2
dlx_load_type (info)
     struct disassemble_info* info;
d190 11
a200 11
    {
      { OPC(LHIOP),   "lhi" },  /* Load HI to register.           */
      { OPC(LBOP),     "lb" },  /* load byte sign extended.       */
      { OPC(LBUOP),   "lbu" },  /* load byte unsigned.            */
      { OPC(LSBUOP),"ldstbu"},  /* load store byte unsigned.      */
      { OPC(LHOP),     "lh" },  /* load halfword sign extended.   */
      { OPC(LHUOP),   "lhu" },  /* load halfword unsigned.        */
      { OPC(LSHUOP),"ldsthu"},  /* load store halfword unsigned.  */
      { OPC(LWOP),     "lw" },  /* load word.                     */
      { OPC(LSWOP), "ldstw" }   /* load store word.               */
    };
d232 1
a232 2
dlx_store_type (info)
     struct disassemble_info* info;
d240 5
a244 5
    {
      { OPC(SBOP),     "sb" },  /* Store byte.      */
      { OPC(SHOP),     "sh" },  /* Store halfword.  */
      { OPC(SWOP),     "sw" },  /* Store word.      */
    };
d265 1
a265 2
dlx_aluI_type (info)
     struct disassemble_info* info;
d273 23
a295 23
    {
      { OPC(ADDIOP),   "addi"  },  /* Store byte.      */
      { OPC(ADDUIOP),  "addui" },  /* Store halfword.  */
      { OPC(SUBIOP),   "subi"  },  /* Store word.      */
      { OPC(SUBUIOP),  "subui" },  /* Store word.      */
      { OPC(ANDIOP),   "andi"  },  /* Store word.      */
      { OPC(ORIOP),    "ori"   },  /* Store word.      */
      { OPC(XORIOP),   "xori"  },  /* Store word.      */
      { OPC(SLLIOP),   "slli"  },  /* Store word.      */
      { OPC(SRAIOP),   "srai"  },  /* Store word.      */
      { OPC(SRLIOP),   "srli"  },  /* Store word.      */
      { OPC(SEQIOP),   "seqi"  },  /* Store word.      */
      { OPC(SNEIOP),   "snei"  },  /* Store word.      */
      { OPC(SLTIOP),   "slti"  },  /* Store word.      */
      { OPC(SGTIOP),   "sgti"  },  /* Store word.      */
      { OPC(SLEIOP),   "slei"  },  /* Store word.      */
      { OPC(SGEIOP),   "sgei"  },  /* Store word.      */
      { OPC(SEQUIOP),  "sequi" },  /* Store word.      */
      { OPC(SNEUIOP),  "sneui" },  /* Store word.      */
      { OPC(SLTUIOP),  "sltui" },  /* Store word.      */
      { OPC(SGTUIOP),  "sgtui" },  /* Store word.      */
      { OPC(SLEUIOP),  "sleui" },  /* Store word.      */
      { OPC(SGEUIOP),  "sgeui" },  /* Store word.      */
d297 2
a298 2
      { OPC(MVTSOP),   "mvts"  },  /* Store word.      */
      { OPC(MVFSOP),   "mvfs"  },  /* Store word.      */
d300 1
a300 1
    };
d323 1
a323 2
dlx_br_type (info)
     struct disassemble_info* info;
d331 4
a334 4
    {
      { OPC(BEQOP), "beqz" }, /* Store byte.  */
      { OPC(BNEOP), "bnez" }  /* Store halfword.  */
    };
d348 2
a349 2
	(*info->fprintf_func) (info->stream, "r%d,", (int)rs1);
	(*info->fprintf_func) (info->stream, "0x%08x", (int)imm16);
d360 1
a360 2
dlx_jmp_type (info)
     struct disassemble_info* info;
d368 7
a374 7
    {
      { OPC(JOP),         "j" },  /* Store byte.      */
      { OPC(JALOP),     "jal" },  /* Store halfword.  */
      { OPC(BREAKOP), "break" },  /* Store halfword.  */
      { OPC(TRAPOP),   "trap" },  /* Store halfword.  */
      { OPC(RFEOP),     "rfe" }   /* Store halfword.  */
    };
d400 1
a400 2
dlx_jr_type (info)
     struct disassemble_info* info;
d407 2
a408 1
  dlx_jr_opcode[] = {
d428 1
a428 1
typedef unsigned char (* dlx_insn) PARAMS ((struct disassemble_info *));
d433 1
a433 3
print_insn_dlx (memaddr, info)
     bfd_vma memaddr;
     struct disassemble_info* info;
d440 9
a448 9
    {
      (unsigned long) dlx_r_type,
      (unsigned long) dlx_load_type,
      (unsigned long) dlx_store_type,
      (unsigned long) dlx_aluI_type,
      (unsigned long) dlx_br_type,
      (unsigned long) dlx_jmp_type,
      (unsigned long) dlx_jr_type,
      (unsigned long) NULL
@


1.1
log
@Add DLX target
@
text
@d17 1
a17 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.1.4.1
log
@merge from trunk
@
text
@@

