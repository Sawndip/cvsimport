head	1.22;
access;
symbols
	sid-snapshot-20180601:1.22
	sid-snapshot-20180501:1.22
	sid-snapshot-20180401:1.22
	sid-snapshot-20180301:1.22
	sid-snapshot-20180201:1.22
	sid-snapshot-20180101:1.22
	sid-snapshot-20171201:1.22
	sid-snapshot-20171101:1.22
	sid-snapshot-20171001:1.22
	sid-snapshot-20170901:1.22
	sid-snapshot-20170801:1.22
	sid-snapshot-20170701:1.22
	sid-snapshot-20170601:1.22
	sid-snapshot-20170501:1.22
	sid-snapshot-20170401:1.22
	sid-snapshot-20170301:1.22
	sid-snapshot-20170201:1.22
	sid-snapshot-20170101:1.22
	sid-snapshot-20161201:1.22
	sid-snapshot-20161101:1.22
	sid-snapshot-20160901:1.22
	sid-snapshot-20160801:1.22
	sid-snapshot-20160701:1.22
	sid-snapshot-20160601:1.22
	sid-snapshot-20160501:1.22
	sid-snapshot-20160401:1.22
	sid-snapshot-20160301:1.22
	sid-snapshot-20160201:1.22
	sid-snapshot-20160101:1.22
	sid-snapshot-20151201:1.22
	sid-snapshot-20151101:1.22
	sid-snapshot-20151001:1.22
	sid-snapshot-20150901:1.22
	sid-snapshot-20150801:1.22
	sid-snapshot-20150701:1.22
	sid-snapshot-20150601:1.22
	sid-snapshot-20150501:1.22
	sid-snapshot-20150401:1.22
	sid-snapshot-20150301:1.22
	sid-snapshot-20150201:1.22
	sid-snapshot-20150101:1.22
	sid-snapshot-20141201:1.22
	sid-snapshot-20141101:1.22
	sid-snapshot-20141001:1.22
	sid-snapshot-20140901:1.22
	sid-snapshot-20140801:1.22
	sid-snapshot-20140701:1.22
	sid-snapshot-20140601:1.22
	sid-snapshot-20140501:1.22
	sid-snapshot-20140401:1.22
	sid-snapshot-20140301:1.22
	sid-snapshot-20140201:1.22
	sid-snapshot-20140101:1.22
	sid-snapshot-20131201:1.22
	sid-snapshot-20131101:1.22
	sid-snapshot-20131001:1.22
	binutils-2_24-branch:1.22.0.8
	binutils-2_24-branchpoint:1.22
	binutils-2_21_1:1.21
	sid-snapshot-20130901:1.22
	gdb_7_6_1-2013-08-30-release:1.22
	sid-snapshot-20130801:1.22
	sid-snapshot-20130701:1.22
	sid-snapshot-20130601:1.22
	sid-snapshot-20130501:1.22
	gdb_7_6-2013-04-26-release:1.22
	sid-snapshot-20130401:1.22
	binutils-2_23_2:1.22
	gdb_7_6-branch:1.22.0.6
	gdb_7_6-2013-03-12-branchpoint:1.22
	sid-snapshot-20130301:1.22
	sid-snapshot-20130201:1.22
	sid-snapshot-20130101:1.22
	sid-snapshot-20121201:1.22
	gdb_7_5_1-2012-11-29-release:1.22
	binutils-2_23_1:1.22
	sid-snapshot-20121101:1.22
	binutils-2_23:1.22
	sid-snapshot-20121001:1.22
	sid-snapshot-20120901:1.22
	gdb_7_5-2012-08-17-release:1.22
	sid-snapshot-20120801:1.22
	binutils-2_23-branch:1.22.0.4
	binutils-2_23-branchpoint:1.22
	gdb_7_5-branch:1.22.0.2
	gdb_7_5-2012-07-18-branchpoint:1.22
	sid-snapshot-20120701:1.22
	sid-snapshot-20120601:1.22
	sid-snapshot-20120501:1.21
	binutils-2_22_branch:1.21.0.18
	gdb_7_4_1-2012-04-26-release:1.21
	sid-snapshot-20120401:1.21
	sid-snapshot-20120301:1.21
	sid-snapshot-20120201:1.21
	gdb_7_4-2012-01-24-release:1.21
	sid-snapshot-20120101:1.21
	gdb_7_4-branch:1.21.0.16
	gdb_7_4-2011-12-13-branchpoint:1.21
	sid-snapshot-20111201:1.21
	binutils-2_22:1.21
	sid-snapshot-20111101:1.21
	sid-snapshot-20111001:1.21
	binutils-2_22-branch:1.21.0.14
	binutils-2_22-branchpoint:1.21
	gdb_7_3_1-2011-09-04-release:1.21
	sid-snapshot-20110901:1.21
	sid-snapshot-20110801:1.21
	gdb_7_3-2011-07-26-release:1.21
	sid-snapshot-20110701:1.21
	sid-snapshot-20110601:1.21
	sid-snapshot-20110501:1.21
	gdb_7_3-branch:1.21.0.12
	gdb_7_3-2011-04-01-branchpoint:1.21
	sid-snapshot-20110401:1.21
	sid-snapshot-20110301:1.21
	sid-snapshot-20110201:1.21
	sid-snapshot-20110101:1.21
	binutils-2_21:1.21
	sid-snapshot-20101201:1.21
	binutils-2_21-branch:1.21.0.10
	binutils-2_21-branchpoint:1.21
	sid-snapshot-20101101:1.21
	sid-snapshot-20101001:1.21
	binutils-2_20_1:1.21
	gdb_7_2-2010-09-02-release:1.21
	sid-snapshot-20100901:1.21
	sid-snapshot-20100801:1.21
	gdb_7_2-branch:1.21.0.8
	gdb_7_2-2010-07-07-branchpoint:1.21
	sid-snapshot-20100701:1.21
	sid-snapshot-20100601:1.21
	sid-snapshot-20100501:1.21
	sid-snapshot-20100401:1.21
	gdb_7_1-2010-03-18-release:1.21
	sid-snapshot-20100301:1.21
	gdb_7_1-branch:1.21.0.6
	gdb_7_1-2010-02-18-branchpoint:1.21
	sid-snapshot-20100201:1.21
	sid-snapshot-20100101:1.21
	gdb_7_0_1-2009-12-22-release:1.21
	sid-snapshot-20091201:1.21
	sid-snapshot-20091101:1.21
	binutils-2_20:1.21
	gdb_7_0-2009-10-06-release:1.21
	sid-snapshot-20091001:1.21
	gdb_7_0-branch:1.21.0.4
	gdb_7_0-2009-09-16-branchpoint:1.21
	arc-sim-20090309:1.18
	binutils-arc-20081103-branch:1.19.0.16
	binutils-arc-20081103-branchpoint:1.19
	binutils-2_20-branch:1.21.0.2
	binutils-2_20-branchpoint:1.21
	sid-snapshot-20090901:1.20
	sid-snapshot-20090801:1.19
	msnyder-checkpoint-072509-branch:1.19.0.14
	msnyder-checkpoint-072509-branchpoint:1.19
	sid-snapshot-20090701:1.19
	dje-cgen-play1-branch:1.19.0.12
	dje-cgen-play1-branchpoint:1.19
	sid-snapshot-20090601:1.19
	sid-snapshot-20090501:1.19
	sid-snapshot-20090401:1.19
	arc-20081103-branch:1.19.0.10
	arc-20081103-branchpoint:1.19
	arc-insight_6_8-branch:1.18.0.14
	arc-insight_6_8-branchpoint:1.18
	insight_6_8-branch:1.18.0.12
	insight_6_8-branchpoint:1.18
	sid-snapshot-20090301:1.19
	binutils-2_19_1:1.19
	sid-snapshot-20090201:1.19
	sid-snapshot-20090101:1.19
	reverse-20081226-branch:1.19.0.8
	reverse-20081226-branchpoint:1.19
	sid-snapshot-20081201:1.19
	multiprocess-20081120-branch:1.19.0.6
	multiprocess-20081120-branchpoint:1.19
	sid-snapshot-20081101:1.19
	binutils-2_19:1.19
	sid-snapshot-20081001:1.19
	reverse-20080930-branch:1.19.0.4
	reverse-20080930-branchpoint:1.19
	binutils-2_19-branch:1.19.0.2
	binutils-2_19-branchpoint:1.19
	sid-snapshot-20080901:1.19
	sid-snapshot-20080801:1.19
	reverse-20080717-branch:1.18.0.10
	reverse-20080717-branchpoint:1.18
	sid-snapshot-20080701:1.18
	msnyder-reverse-20080609-branch:1.18.0.8
	msnyder-reverse-20080609-branchpoint:1.18
	drow-reverse-20070409-branch:1.17.0.4
	drow-reverse-20070409-branchpoint:1.17
	sid-snapshot-20080601:1.18
	sid-snapshot-20080501:1.18
	sid-snapshot-20080403:1.18
	sid-snapshot-20080401:1.18
	gdb_6_8-2008-03-27-release:1.18
	sid-snapshot-20080301:1.18
	gdb_6_8-branch:1.18.0.6
	gdb_6_8-2008-02-26-branchpoint:1.18
	sid-snapshot-20080201:1.18
	sid-snapshot-20080101:1.18
	sid-snapshot-20071201:1.18
	sid-snapshot-20071101:1.18
	gdb_6_7_1-2007-10-29-release:1.18
	gdb_6_7-2007-10-10-release:1.18
	sid-snapshot-20071001:1.18
	gdb_6_7-branch:1.18.0.4
	gdb_6_7-2007-09-07-branchpoint:1.18
	binutils-2_18:1.18
	binutils-2_18-branch:1.18.0.2
	binutils-2_18-branchpoint:1.18
	insight_6_6-20070208-release:1.17
	binutils-csl-coldfire-4_1-32:1.16
	binutils-csl-sourcerygxx-4_1-32:1.16
	gdb_6_6-2006-12-18-release:1.17
	binutils-csl-innovasic-fido-3_4_4-33:1.16
	binutils-csl-sourcerygxx-3_4_4-32:1.11
	binutils-csl-coldfire-4_1-30:1.16
	binutils-csl-sourcerygxx-4_1-30:1.16
	binutils-csl-coldfire-4_1-28:1.16
	binutils-csl-sourcerygxx-4_1-29:1.16
	binutils-csl-sourcerygxx-4_1-28:1.16
	gdb_6_6-branch:1.17.0.2
	gdb_6_6-2006-11-15-branchpoint:1.17
	binutils-csl-arm-2006q3-27:1.16
	binutils-csl-sourcerygxx-4_1-27:1.16
	binutils-csl-arm-2006q3-26:1.16
	binutils-csl-sourcerygxx-4_1-26:1.16
	binutils-csl-sourcerygxx-4_1-25:1.16
	binutils-csl-sourcerygxx-4_1-24:1.16
	binutils-csl-sourcerygxx-4_1-23:1.16
	insight_6_5-20061003-release:1.16
	gdb-csl-symbian-6_4_50_20060226-12:1.16
	binutils-csl-sourcerygxx-4_1-21:1.16
	binutils-csl-arm-2006q3-21:1.16
	binutils-csl-sourcerygxx-4_1-22:1.16
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.16
	binutils-csl-sourcerygxx-4_1-20:1.16
	binutils-csl-arm-2006q3-19:1.16
	binutils-csl-sourcerygxx-4_1-19:1.16
	binutils-csl-sourcerygxx-4_1-18:1.16
	binutils-csl-renesas-4_1-9:1.16
	gdb-csl-sourcerygxx-3_4_4-25:1.15
	binutils-csl-sourcerygxx-3_4_4-25:1.11
	nickrob-async-20060828-mergepoint:1.16
	gdb-csl-symbian-6_4_50_20060226-11:1.16
	binutils-csl-renesas-4_1-8:1.16
	binutils-csl-renesas-4_1-7:1.16
	binutils-csl-renesas-4_1-6:1.16
	gdb-csl-sourcerygxx-4_1-17:1.16
	binutils-csl-sourcerygxx-4_1-17:1.16
	gdb-csl-20060226-branch-local-2:1.16
	gdb-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-15:1.16
	gdb-csl-sourcerygxx-4_1-13:1.16
	binutils-csl-sourcerygxx-4_1-13:1.16
	binutils-2_17:1.16
	gdb-csl-sourcerygxx-4_1-12:1.16
	binutils-csl-sourcerygxx-4_1-12:1.16
	gdb-csl-sourcerygxx-3_4_4-21:1.16
	binutils-csl-sourcerygxx-3_4_4-21:1.16
	gdb_6_5-20060621-release:1.16
	binutils-csl-wrs-linux-3_4_4-24:1.11
	binutils-csl-wrs-linux-3_4_4-23:1.11
	gdb-csl-sourcerygxx-4_1-9:1.16
	binutils-csl-sourcerygxx-4_1-9:1.16
	gdb-csl-sourcerygxx-4_1-8:1.16
	binutils-csl-sourcerygxx-4_1-8:1.16
	gdb-csl-sourcerygxx-4_1-7:1.16
	binutils-csl-sourcerygxx-4_1-7:1.16
	gdb-csl-arm-2006q1-6:1.16
	binutils-csl-arm-2006q1-6:1.16
	gdb-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-wrs-linux-3_4_4-22:1.11
	gdb-csl-symbian-6_4_50_20060226-10:1.16
	gdb-csl-symbian-6_4_50_20060226-9:1.16
	gdb-csl-symbian-6_4_50_20060226-8:1.16
	gdb-csl-coldfire-4_1-11:1.16
	binutils-csl-coldfire-4_1-11:1.16
	gdb-csl-sourcerygxx-3_4_4-19:1.16
	binutils-csl-sourcerygxx-3_4_4-19:1.16
	gdb-csl-coldfire-4_1-10:1.16
	gdb_6_5-branch:1.16.0.20
	gdb_6_5-2006-05-14-branchpoint:1.16
	binutils-csl-coldfire-4_1-10:1.16
	gdb-csl-sourcerygxx-4_1-5:1.16
	binutils-csl-sourcerygxx-4_1-5:1.16
	nickrob-async-20060513-branch:1.16.0.18
	nickrob-async-20060513-branchpoint:1.16
	gdb-csl-sourcerygxx-4_1-4:1.16
	binutils-csl-sourcerygxx-4_1-4:1.16
	msnyder-reverse-20060502-branch:1.16.0.16
	msnyder-reverse-20060502-branchpoint:1.16
	binutils-csl-wrs-linux-3_4_4-21:1.11
	gdb-csl-morpho-4_1-4:1.16
	binutils-csl-morpho-4_1-4:1.16
	gdb-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-wrs-linux-3_4_4-20:1.11
	readline_5_1-import-branch:1.16.0.14
	readline_5_1-import-branchpoint:1.16
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.16
	binutils-2_17-branch:1.16.0.12
	binutils-2_17-branchpoint:1.16
	gdb-csl-symbian-20060226-branch:1.16.0.10
	gdb-csl-symbian-20060226-branchpoint:1.16
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.16
	msnyder-reverse-20060331-branch:1.16.0.8
	msnyder-reverse-20060331-branchpoint:1.16
	binutils-csl-2_17-branch:1.16.0.6
	binutils-csl-2_17-branchpoint:1.16
	gdb-csl-available-20060303-branch:1.16.0.4
	gdb-csl-available-20060303-branchpoint:1.16
	gdb-csl-20060226-branch:1.16.0.2
	gdb-csl-20060226-branchpoint:1.16
	gdb_6_4-20051202-release:1.15
	msnyder-fork-checkpoint-branch:1.15.0.8
	msnyder-fork-checkpoint-branchpoint:1.15
	gdb-csl-gxxpro-6_3-branch:1.15.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.15
	gdb_6_4-branch:1.15.0.4
	gdb_6_4-2005-11-01-branchpoint:1.15
	gdb-csl-arm-20051020-branch:1.15.0.2
	gdb-csl-arm-20051020-branchpoint:1.15
	binutils-csl-gxxpro-3_4-branch:1.11.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.11
	binutils-2_16_1:1.11
	msnyder-tracepoint-checkpoint-branch:1.13.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.13
	gdb-csl-arm-20050325-2005-q1b:1.12
	binutils-csl-arm-2005q1b:1.11
	binutils-2_16:1.11
	gdb-csl-arm-20050325-2005-q1a:1.12
	binutils-csl-arm-2005q1a:1.11
	csl-arm-20050325-branch:1.12.0.2
	csl-arm-20050325-branchpoint:1.12
	binutils-csl-arm-2005q1-branch:1.11.0.4
	binutils-csl-arm-2005q1-branchpoint:1.11
	binutils-2_16-branch:1.11.0.2
	binutils-2_16-branchpoint:1.11
	csl-arm-2004-q3d:1.9
	gdb_6_3-20041109-release:1.8
	gdb_6_3-branch:1.8.0.60
	gdb_6_3-20041019-branchpoint:1.8
	csl-arm-2004-q3:1.8
	drow_intercu-merge-20040921:1.8
	drow_intercu-merge-20040915:1.8
	jimb-gdb_6_2-e500-branch:1.8.0.62
	jimb-gdb_6_2-e500-branchpoint:1.8
	gdb_6_2-20040730-release:1.8
	gdb_6_2-branch:1.8.0.58
	gdb_6_2-2004-07-10-gmt-branchpoint:1.8
	gdb_6_1_1-20040616-release:1.8
	binutils-2_15:1.8
	binutils-2_15-branchpoint:1.8
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.8
	gdb_6_1-2004-04-05-release:1.8
	drow_intercu-merge-20040402:1.8
	drow_intercu-merge-20040327:1.8
	ezannoni_pie-20040323-branch:1.8.0.56
	ezannoni_pie-20040323-branchpoint:1.8
	cagney_tramp-20040321-mergepoint:1.8
	cagney_tramp-20040309-branch:1.8.0.54
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.52
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow_intercu-20040221-branch:1.8.0.50
	drow_intercu-20040221-branchpoint:1.8
	binutils-2_15-branch:1.8.0.48
	cagney_bfdfile-20040213-branch:1.8.0.46
	cagney_bfdfile-20040213-branchpoint:1.8
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.8
	cagney_bigcore-20040122-branch:1.8.0.44
	cagney_bigcore-20040122-branchpoint:1.8
	drow-cplus-merge-20040113:1.8
	csl-arm-2003-q4:1.8
	drow-cplus-merge-20031224:1.8
	drow-cplus-merge-20031220:1.8
	carlton_dictionary-20031215-merge:1.8
	drow-cplus-merge-20031214:1.8
	carlton-dictionary-20031111-merge:1.8
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.8.0.42
	kettenis_sparc-20030918-branchpoint:1.8
	carlton_dictionary-20030917-merge:1.8
	ezannoni_pie-20030916-branchpoint:1.8
	ezannoni_pie-20030916-branch:1.8.0.40
	cagney_x86i386-20030821-branch:1.8.0.38
	cagney_x86i386-20030821-branchpoint:1.8
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.36
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.8
	binutils-2_14:1.8
	cagney_convert-20030606-branch:1.8.0.32
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.30
	cagney_writestrings-20030508-branchpoint:1.8
	jimb-ppc64-linux-20030528-branch:1.8.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.26
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.8.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.8
	kettenis_i386newframe-20030504-mergepoint:1.8
	carlton_dictionary-20030430-merge:1.8
	binutils-2_14-branch:1.8.0.22
	binutils-2_14-branchpoint:1.8
	kettenis_i386newframe-20030419-branch:1.8.0.20
	kettenis_i386newframe-20030419-branchpoint:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.18
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.16
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.14
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.12
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.10
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.8
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.6
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.8
	interps-20030202-branch:1.8.0.4
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.8.0.2
	cagney-unwind-20030108-branchpoint:1.8
	binutils-2_13_2_1:1.7
	binutils-2_13_2:1.7
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.7
	carlton_dictionary-20021115-merge:1.7
	binutils-2_13_1:1.7
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.7.0.24
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	carlton_dictionary-branch:1.7.0.22
	carlton_dictionary-20020920-branchpoint:1.7
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.20
	gdb_5_3-branch:1.7.0.18
	gdb_5_3-2002-09-04-branchpoint:1.7
	kseitz_interps-20020829-merge:1.7
	cagney_sysregs-20020825-branch:1.7.0.16
	cagney_sysregs-20020825-branchpoint:1.7
	readline_4_3-import-branch:1.7.0.14
	readline_4_3-import-branchpoint:1.7
	binutils-2_13:1.7
	gdb_5_2_1-2002-07-23-release:1.7
	binutils-2_13-branchpoint:1.7
	binutils-2_13-branch:1.7.0.12
	kseitz_interps-20020528-branch:1.7.0.10
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.8
	cagney_regbuf-20020515-branchpoint:1.7
	binutils-2_12_1:1.7
	jimb-macro-020506-branch:1.7.0.6
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	binutils-2_12:1.7
	gdb_5_2-branch:1.7.0.4
	gdb_5_2-2002-03-03-branchpoint:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.3
	binutils_latest_snapshot:1.22;
locks; strict;
comment	@ * @;


1.22
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.02.07.20.29;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.29.22.11.01;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.30.04.34.58;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.05.23.27.01;	author hp;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.07.19.27.48;	author wilson;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.01.11.16.31;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.07.07.34.27;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.23.19.21.16;	author hjl;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.03.11.49.48;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.24.13.38.01;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.04.14.54.38;	author hp;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.19.17.40.28;	author nickc;	state Exp;
branches
	1.7.22.1
	1.7.24.1;
next	1.6;

1.6
date	2001.08.26.11.47.39;	author aj;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.24.04.10.19;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.22.58.34;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.14.20.08.55;	author hp;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.09.29.18.17.25;	author hp;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.20.16.46.28;	author hp;	state Exp;
branches;
next	;

1.7.22.1
date	2002.12.23.19.39.30;	author carlton;	state Exp;
branches;
next	;

1.7.24.1
date	2003.12.14.20.28.05;	author drow;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.18.34;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.22
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* Disassembler code for CRIS.
   Copyright 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2012
   Free Software Foundation, Inc.
   Contributed by Axis Communications AB, Lund, Sweden.
   Written by Hans-Peter Nilsson.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "dis-asm.h"
#include "opcode/cris.h"
#include "libiberty.h"

/* No instruction will be disassembled longer than this.  In theory, and
   in silicon, address prefixes can be cascaded.  In practice, cascading
   is not used by GCC, and not supported by the assembler.  */
#ifndef MAX_BYTES_PER_CRIS_INSN
#define MAX_BYTES_PER_CRIS_INSN 8
#endif

/* Whether or not to decode prefixes, folding it into the following
   instruction.  FIXME: Make this optional later.  */
#ifndef PARSE_PREFIX
#define PARSE_PREFIX 1
#endif

/* Sometimes we prefix all registers with this character.  */
#define REGISTER_PREFIX_CHAR '$'

/* Whether or not to trace the following sequence:
   sub* X,r%d
   bound* Y,r%d
   adds.w [pc+r%d.w],pc

   This is the assembly form of a switch-statement in C.
   The "sub is optional.  If there is none, then X will be zero.
   X is the value of the first case,
   Y is the number of cases (including default).

   This results in case offsets printed on the form:
    case N: -> case_address
   where N is an estimation on the corresponding 'case' operand in C,
   and case_address is where execution of that case continues after the
   sequence presented above.

   The old style of output was to print the offsets as instructions,
   which made it hard to follow "case"-constructs in the disassembly,
   and caused a lot of annoying warnings about undefined instructions.

   FIXME: Make this optional later.  */
#ifndef TRACE_CASE
#define TRACE_CASE (disdata->trace_case)
#endif

enum cris_disass_family
 { cris_dis_v0_v10, cris_dis_common_v10_v32, cris_dis_v32 };

/* Stored in the disasm_info->private_data member.  */
struct cris_disasm_data
{
  /* Whether to print something less confusing if we find something
     matching a switch-construct.  */
  bfd_boolean trace_case;

  /* Whether this code is flagged as crisv32.  FIXME: Should be an enum
     that includes "compatible".  */
  enum cris_disass_family distype;
};

/* Value of first element in switch.  */
static long case_offset = 0;

/* How many more case-offsets to print.  */
static long case_offset_counter = 0;

/* Number of case offsets.  */
static long no_of_case_offsets = 0;

/* Candidate for next case_offset.  */
static long last_immediate = 0;

static int cris_constraint
  (const char *, unsigned, unsigned, struct cris_disasm_data *);

/* Parse disassembler options and store state in info.  FIXME: For the
   time being, we abuse static variables.  */

static bfd_boolean
cris_parse_disassembler_options (disassemble_info *info,
				 enum cris_disass_family distype)
{
  struct cris_disasm_data *disdata;

  info->private_data = calloc (1, sizeof (struct cris_disasm_data));
  disdata = (struct cris_disasm_data *) info->private_data;
  if (disdata == NULL)
    return FALSE;

  /* Default true.  */
  disdata->trace_case
    = (info->disassembler_options == NULL
       || (strcmp (info->disassembler_options, "nocase") != 0));

  disdata->distype = distype;
  return TRUE;
}

static const struct cris_spec_reg *
spec_reg_info (unsigned int sreg, enum cris_disass_family distype)
{
  int i;

  for (i = 0; cris_spec_regs[i].name != NULL; i++)
    {
      if (cris_spec_regs[i].number == sreg)
	{
	  if (distype == cris_dis_v32)
	    switch (cris_spec_regs[i].applicable_version)
	      {
	      case cris_ver_warning:
	      case cris_ver_version_all:
	      case cris_ver_v3p:
	      case cris_ver_v8p:
	      case cris_ver_v10p:
	      case cris_ver_v32p:
		/* No ambiguous sizes or register names with CRISv32.  */
		if (cris_spec_regs[i].warning == NULL)
		  return &cris_spec_regs[i];
	      default:
		;
	      }
	  else if (cris_spec_regs[i].applicable_version != cris_ver_v32p)
	    return &cris_spec_regs[i];
	}
    }

  return NULL;
}

/* Return the number of bits in the argument.  */

static int
number_of_bits (unsigned int val)
{
  int bits;

  for (bits = 0; val != 0; val &= val - 1)
    bits++;

  return bits;
}

/* Get an entry in the opcode-table.  */

static const struct cris_opcode *
get_opcode_entry (unsigned int insn,
		  unsigned int prefix_insn,
		  struct cris_disasm_data *disdata)
{
  /* For non-prefixed insns, we keep a table of pointers, indexed by the
     insn code.  Each entry is initialized when found to be NULL.  */
  static const struct cris_opcode **opc_table = NULL;

  const struct cris_opcode *max_matchedp = NULL;
  const struct cris_opcode **prefix_opc_table = NULL;

  /* We hold a table for each prefix that need to be handled differently.  */
  static const struct cris_opcode **dip_prefixes = NULL;
  static const struct cris_opcode **bdapq_m1_prefixes = NULL;
  static const struct cris_opcode **bdapq_m2_prefixes = NULL;
  static const struct cris_opcode **bdapq_m4_prefixes = NULL;
  static const struct cris_opcode **rest_prefixes = NULL;

  /* Allocate and clear the opcode-table.  */
  if (opc_table == NULL)
    {
      opc_table = malloc (65536 * sizeof (opc_table[0]));
      if (opc_table == NULL)
	return NULL;

      memset (opc_table, 0, 65536 * sizeof (const struct cris_opcode *));

      dip_prefixes
	= malloc (65536 * sizeof (const struct cris_opcode **));
      if (dip_prefixes == NULL)
	return NULL;

      memset (dip_prefixes, 0, 65536 * sizeof (dip_prefixes[0]));

      bdapq_m1_prefixes
	= malloc (65536 * sizeof (const struct cris_opcode **));
      if (bdapq_m1_prefixes == NULL)
	return NULL;

      memset (bdapq_m1_prefixes, 0, 65536 * sizeof (bdapq_m1_prefixes[0]));

      bdapq_m2_prefixes
	= malloc (65536 * sizeof (const struct cris_opcode **));
      if (bdapq_m2_prefixes == NULL)
	return NULL;

      memset (bdapq_m2_prefixes, 0, 65536 * sizeof (bdapq_m2_prefixes[0]));

      bdapq_m4_prefixes
	= malloc (65536 * sizeof (const struct cris_opcode **));
      if (bdapq_m4_prefixes == NULL)
	return NULL;

      memset (bdapq_m4_prefixes, 0, 65536 * sizeof (bdapq_m4_prefixes[0]));

      rest_prefixes
	= malloc (65536 * sizeof (const struct cris_opcode **));
      if (rest_prefixes == NULL)
	return NULL;

      memset (rest_prefixes, 0, 65536 * sizeof (rest_prefixes[0]));
    }

  /* Get the right table if this is a prefix.
     This code is connected to cris_constraints in that it knows what
     prefixes play a role in recognition of patterns; the necessary
     state is reflected by which table is used.  If constraints
     involving match or non-match of prefix insns are changed, then this
     probably needs changing too.  */
  if (prefix_insn != NO_CRIS_PREFIX)
    {
      const struct cris_opcode *popcodep
	= (opc_table[prefix_insn] != NULL
	   ? opc_table[prefix_insn]
	   : get_opcode_entry (prefix_insn, NO_CRIS_PREFIX, disdata));

      if (popcodep == NULL)
	return NULL;

      if (popcodep->match == BDAP_QUICK_OPCODE)
	{
	  /* Since some offsets are recognized with "push" macros, we
	     have to have different tables for them.  */
	  int offset = (prefix_insn & 255);

	  if (offset > 127)
	    offset -= 256;

	  switch (offset)
	    {
	    case -4:
	      prefix_opc_table = bdapq_m4_prefixes;
	      break;

	    case -2:
	      prefix_opc_table = bdapq_m2_prefixes;
	      break;

	    case -1:
	      prefix_opc_table = bdapq_m1_prefixes;
	      break;

	    default:
	      prefix_opc_table = rest_prefixes;
	      break;
	    }
	}
      else if (popcodep->match == DIP_OPCODE)
	/* We don't allow postincrement when the prefix is DIP, so use a
	   different table for DIP.  */
	prefix_opc_table = dip_prefixes;
      else
	prefix_opc_table = rest_prefixes;
    }

  if (prefix_insn != NO_CRIS_PREFIX
      && prefix_opc_table[insn] != NULL)
    max_matchedp = prefix_opc_table[insn];
  else if (prefix_insn == NO_CRIS_PREFIX && opc_table[insn] != NULL)
    max_matchedp = opc_table[insn];
  else
    {
      const struct cris_opcode *opcodep;
      int max_level_of_match = -1;

      for (opcodep = cris_opcodes;
	   opcodep->name != NULL;
	   opcodep++)
	{
	  int level_of_match;

	  if (disdata->distype == cris_dis_v32)
	    {
	      switch (opcodep->applicable_version)
		{
		case cris_ver_version_all:
		  break;

		case cris_ver_v0_3:
		case cris_ver_v0_10:
		case cris_ver_v3_10:
		case cris_ver_sim_v0_10:
		case cris_ver_v8_10:
		case cris_ver_v10:
		case cris_ver_warning:
		  continue;

		case cris_ver_v3p:
		case cris_ver_v8p:
		case cris_ver_v10p:
		case cris_ver_v32p:
		  break;

		case cris_ver_v8:
		  abort ();
		default:
		  abort ();
		}
	    }
	  else
	    {
	      switch (opcodep->applicable_version)
		{
		case cris_ver_version_all:
		case cris_ver_v0_3:
		case cris_ver_v3p:
		case cris_ver_v0_10:
		case cris_ver_v8p:
		case cris_ver_v8_10:
		case cris_ver_v10:
		case cris_ver_sim_v0_10:
		case cris_ver_v10p:
		case cris_ver_warning:
		  break;

		case cris_ver_v32p:
		  continue;

		case cris_ver_v8:
		  abort ();
		default:
		  abort ();
		}
	    }

	  /* We give a double lead for bits matching the template in
	     cris_opcodes.  Not even, because then "move p8,r10" would
	     be given 2 bits lead over "clear.d r10".  When there's a
	     tie, the first entry in the table wins.  This is
	     deliberate, to avoid a more complicated recognition
	     formula.  */
	  if ((opcodep->match & insn) == opcodep->match
	      && (opcodep->lose & insn) == 0
	      && ((level_of_match
		   = cris_constraint (opcodep->args,
				      insn,
				      prefix_insn,
				      disdata))
		  >= 0)
	      && ((level_of_match
		   += 2 * number_of_bits (opcodep->match
					  | opcodep->lose))
			  > max_level_of_match))
		    {
		      max_matchedp = opcodep;
		      max_level_of_match = level_of_match;

		      /* If there was a full match, never mind looking
			 further.  */
		      if (level_of_match >= 2 * 16)
			break;
		    }
		}
      /* Fill in the new entry.

	 If there are changes to the opcode-table involving prefixes, and
	 disassembly then does not work correctly, try removing the
	 else-clause below that fills in the prefix-table.  If that
	 helps, you need to change the prefix_opc_table setting above, or
	 something related.  */
      if (prefix_insn == NO_CRIS_PREFIX)
	opc_table[insn] = max_matchedp;
      else
	prefix_opc_table[insn] = max_matchedp;
    }

  return max_matchedp;
}

/* Return -1 if the constraints of a bitwise-matched instruction say
   that there is no match.  Otherwise return a nonnegative number
   indicating the confidence in the match (higher is better).  */

static int
cris_constraint (const char *cs,
		 unsigned int insn,
		 unsigned int prefix_insn,
		 struct cris_disasm_data *disdata)
{
  int retval = 0;
  int tmp;
  int prefix_ok = 0;
  const char *s;

  for (s = cs; *s; s++)
    switch (*s)
      {
      case '!':
	/* Do not recognize "pop" if there's a prefix and then only for
           v0..v10.  */
	if (prefix_insn != NO_CRIS_PREFIX
	    || disdata->distype != cris_dis_v0_v10)
	  return -1;
	break;

      case 'U':
	/* Not recognized at disassembly.  */
	return -1;

      case 'M':
	/* Size modifier for "clear", i.e. special register 0, 4 or 8.
	   Check that it is one of them.  Only special register 12 could
	   be mismatched, but checking for matches is more logical than
	   checking for mismatches when there are only a few cases.  */
	tmp = ((insn >> 12) & 0xf);
	if (tmp != 0 && tmp != 4 && tmp != 8)
	  return -1;
	break;

      case 'm':
	if ((insn & 0x30) == 0x30)
	  return -1;
	break;

      case 'S':
	/* A prefix operand without side-effect.  */
	if (prefix_insn != NO_CRIS_PREFIX && (insn & 0x400) == 0)
	  {
	    prefix_ok = 1;
	    break;
	  }
	else
	  return -1;

      case 's':
      case 'y':
      case 'Y':
	/* If this is a prefixed insn with postincrement (side-effect),
	   the prefix must not be DIP.  */
	if (prefix_insn != NO_CRIS_PREFIX)
	  {
	    if (insn & 0x400)
	      {
		const struct cris_opcode *prefix_opcodep
		  = get_opcode_entry (prefix_insn, NO_CRIS_PREFIX, disdata);

		if (prefix_opcodep->match == DIP_OPCODE)
		  return -1;
	      }

	    prefix_ok = 1;
	  }
	break;

      case 'B':
	/* If we don't fall through, then the prefix is ok.  */
	prefix_ok = 1;

	/* A "push" prefix.  Check for valid "push" size.
	   In case of special register, it may be != 4.  */
	if (prefix_insn != NO_CRIS_PREFIX)
	  {
	    /* Match the prefix insn to BDAPQ.  */
	    const struct cris_opcode *prefix_opcodep
	      = get_opcode_entry (prefix_insn, NO_CRIS_PREFIX, disdata);

	    if (prefix_opcodep->match == BDAP_QUICK_OPCODE)
	      {
		int pushsize = (prefix_insn & 255);

		if (pushsize > 127)
		  pushsize -= 256;

		if (s[1] == 'P')
		  {
		    unsigned int spec_reg = (insn >> 12) & 15;
		    const struct cris_spec_reg *sregp
		      = spec_reg_info (spec_reg, disdata->distype);

		    /* For a special-register, the "prefix size" must
		       match the size of the register.  */
		    if (sregp && sregp->reg_size == (unsigned int) -pushsize)
		      break;
		  }
		else if (s[1] == 'R')
		  {
		    if ((insn & 0x30) == 0x20 && pushsize == -4)
		      break;
		  }
		/* FIXME:  Should abort here; next constraint letter
		   *must* be 'P' or 'R'.  */
	      }
	  }
	return -1;

      case 'D':
	retval = (((insn >> 12) & 15) == (insn & 15));
	if (!retval)
	  return -1;
	else
	  retval += 4;
	break;

      case 'P':
	{
	  const struct cris_spec_reg *sregp
	    = spec_reg_info ((insn >> 12) & 15, disdata->distype);

	  /* Since we match four bits, we will give a value of 4-1 = 3
	     in a match.  If there is a corresponding exact match of a
	     special register in another pattern, it will get a value of
	     4, which will be higher.  This should be correct in that an
	     exact pattern would match better than a general pattern.

	     Note that there is a reason for not returning zero; the
	     pattern for "clear" is partly  matched in the bit-pattern
	     (the two lower bits must be zero), while the bit-pattern
	     for a move from a special register is matched in the
	     register constraint.  */

	  if (sregp != NULL)
	    {
	      retval += 3;
	      break;
	    }
	  else
	    return -1;
	}
      }

  if (prefix_insn != NO_CRIS_PREFIX && ! prefix_ok)
    return -1;

  return retval;
}

/* Format number as hex with a leading "0x" into outbuffer.  */

static char *
format_hex (unsigned long number,
	    char *outbuffer,
	    struct cris_disasm_data *disdata)
{
  /* Truncate negative numbers on >32-bit hosts.  */
  number &= 0xffffffff;

  sprintf (outbuffer, "0x%lx", number);

  /* Save this value for the "case" support.  */
  if (TRACE_CASE)
    last_immediate = number;

  return outbuffer + strlen (outbuffer);
}

/* Format number as decimal into outbuffer.  Parameter signedp says
   whether the number should be formatted as signed (!= 0) or
   unsigned (== 0).  */

static char *
format_dec (long number, char *outbuffer, int signedp)
{
  last_immediate = number;
  if (signedp)
    sprintf (outbuffer, "%ld", number);
  else
    sprintf (outbuffer, "%lu", (unsigned long) number);

  return outbuffer + strlen (outbuffer);
}

/* Format the name of the general register regno into outbuffer.  */

static char *
format_reg (struct cris_disasm_data *disdata,
	    int regno,
	    char *outbuffer_start,
	    bfd_boolean with_reg_prefix)
{
  char *outbuffer = outbuffer_start;

  if (with_reg_prefix)
    *outbuffer++ = REGISTER_PREFIX_CHAR;

  switch (regno)
    {
    case 15:
      /* For v32, there is no context in which we output PC.  */
      if (disdata->distype == cris_dis_v32)
	strcpy (outbuffer, "acr");
      else
	strcpy (outbuffer, "pc");
      break;

    case 14:
      strcpy (outbuffer, "sp");
      break;

    default:
      sprintf (outbuffer, "r%d", regno);
      break;
    }

  return outbuffer_start + strlen (outbuffer_start);
}

/* Format the name of a support register into outbuffer.  */

static char *
format_sup_reg (unsigned int regno,
		char *outbuffer_start,
		bfd_boolean with_reg_prefix)
{
  char *outbuffer = outbuffer_start;
  int i;

  if (with_reg_prefix)
    *outbuffer++ = REGISTER_PREFIX_CHAR;

  for (i = 0; cris_support_regs[i].name != NULL; i++)
    if (cris_support_regs[i].number == regno)
      {
	sprintf (outbuffer, "%s", cris_support_regs[i].name);
	return outbuffer_start + strlen (outbuffer_start);
      }

  /* There's supposed to be register names covering all numbers, though
     some may be generic names.  */
  sprintf (outbuffer, "format_sup_reg-BUG");
  return outbuffer_start + strlen (outbuffer_start);
}

/* Return the length of an instruction.  */

static unsigned
bytes_to_skip (unsigned int insn,
	       const struct cris_opcode *matchedp,
	       enum cris_disass_family distype,
	       const struct cris_opcode *prefix_matchedp)
{
  /* Each insn is a word plus "immediate" operands.  */
  unsigned to_skip = 2;
  const char *template_name = (const char *) matchedp->args;
  const char *s;

  for (s = template_name; *s; s++)
    if ((*s == 's' || *s == 'N' || *s == 'Y')
	&& (insn & 0x400) && (insn & 15) == 15
	&& prefix_matchedp == NULL)
      {
	/* Immediate via [pc+], so we have to check the size of the
	   operand.  */
	int mode_size = 1 << ((insn >> 4) & (*template_name == 'z' ? 1 : 3));

	if (matchedp->imm_oprnd_size == SIZE_FIX_32)
	  to_skip += 4;
	else if (matchedp->imm_oprnd_size == SIZE_SPEC_REG)
	  {
	    const struct cris_spec_reg *sregp
	      = spec_reg_info ((insn >> 12) & 15, distype);

	    /* FIXME: Improve error handling; should have been caught
	       earlier.  */
	    if (sregp == NULL)
	      return 2;

	    /* PC is incremented by two, not one, for a byte.  Except on
	       CRISv32, where constants are always DWORD-size for
	       special registers.  */
	    to_skip +=
	      distype == cris_dis_v32 ? 4 : (sregp->reg_size + 1) & ~1;
	  }
	else
	  to_skip += (mode_size + 1) & ~1;
      }
    else if (*s == 'n')
      to_skip += 4;
    else if (*s == 'b')
      to_skip += 2;

  return to_skip;
}

/* Print condition code flags.  */

static char *
print_flags (struct cris_disasm_data *disdata, unsigned int insn, char *cp)
{
  /* Use the v8 (Etrax 100) flag definitions for disassembly.
     The differences with v0 (Etrax 1..4) vs. Svinto are:
      v0 'd' <=> v8 'm'
      v0 'e' <=> v8 'b'.
     FIXME: Emit v0..v3 flag names somehow.  */
  static const char v8_fnames[] = "cvznxibm";
  static const char v32_fnames[] = "cvznxiup";
  const char *fnames
    = disdata->distype == cris_dis_v32 ? v32_fnames : v8_fnames;

  unsigned char flagbits = (((insn >> 8) & 0xf0) | (insn & 15));
  int i;

  for (i = 0; i < 8; i++)
    if (flagbits & (1 << i))
      *cp++ = fnames[i];

  return cp;
}

/* Print out an insn with its operands, and update the info->insn_type
   fields.  The prefix_opcodep and the rest hold a prefix insn that is
   supposed to be output as an address mode.  */

static void
print_with_operands (const struct cris_opcode *opcodep,
		     unsigned int insn,
		     unsigned char *buffer,
		     bfd_vma addr,
		     disassemble_info *info,
		     /* If a prefix insn was before this insn (and is supposed
			to be output as an address), here is a description of
			it.  */
		     const struct cris_opcode *prefix_opcodep,
		     unsigned int prefix_insn,
		     unsigned char *prefix_buffer,
		     bfd_boolean with_reg_prefix)
{
  /* Get a buffer of somewhat reasonable size where we store
     intermediate parts of the insn.  */
  char temp[sizeof (".d [$r13=$r12-2147483648],$r10") * 2];
  char *tp = temp;
  static const char mode_char[] = "bwd?";
  const char *s;
  const char *cs;
  struct cris_disasm_data *disdata
    = (struct cris_disasm_data *) info->private_data;

  /* Print out the name first thing we do.  */
  (*info->fprintf_func) (info->stream, "%s", opcodep->name);

  cs = opcodep->args;
  s = cs;

  /* Ignore any prefix indicator.  */
  if (*s == 'p')
    s++;

  if (*s == 'm' || *s == 'M' || *s == 'z')
    {
      *tp++ = '.';

      /* Get the size-letter.  */
      *tp++ = *s == 'M'
	? (insn & 0x8000 ? 'd'
	   : insn & 0x4000 ? 'w' : 'b')
	: mode_char[(insn >> 4) & (*s == 'z' ? 1 : 3)];

      /* Ignore the size and the space character that follows.  */
      s += 2;
    }

  /* Add a space if this isn't a long-branch, because for those will add
     the condition part of the name later.  */
  if (opcodep->match != (BRANCH_PC_LOW + BRANCH_INCR_HIGH * 256))
    *tp++ = ' ';

  /* Fill in the insn-type if deducible from the name (and there's no
     better way).  */
  if (opcodep->name[0] == 'j')
    {
      if (CONST_STRNEQ (opcodep->name, "jsr"))
	/* It's "jsr" or "jsrc".  */
	info->insn_type = dis_jsr;
      else
	/* Any other jump-type insn is considered a branch.  */
	info->insn_type = dis_branch;
    }

  /* We might know some more fields right now.  */
  info->branch_delay_insns = opcodep->delayed;

  /* Handle operands.  */
  for (; *s; s++)
    {
    switch (*s)
      {
      case 'T':
	tp = format_sup_reg ((insn >> 12) & 15, tp, with_reg_prefix);
	break;

      case 'A':
	if (with_reg_prefix)
	  *tp++ = REGISTER_PREFIX_CHAR;
	*tp++ = 'a';
	*tp++ = 'c';
	*tp++ = 'r';
	break;
	
      case '[':
      case ']':
      case ',':
	*tp++ = *s;
	break;

      case '!':
	/* Ignore at this point; used at earlier stages to avoid
	   recognition if there's a prefix at something that in other
	   ways looks like a "pop".  */
	break;

      case 'd':
	/* Ignore.  This is an optional ".d " on the large one of
	   relaxable insns.  */
	break;

      case 'B':
	/* This was the prefix that made this a "push".  We've already
	   handled it by recognizing it, so signal that the prefix is
	   handled by setting it to NULL.  */
	prefix_opcodep = NULL;
	break;

      case 'D':
      case 'r':
	tp = format_reg (disdata, insn & 15, tp, with_reg_prefix);
	break;

      case 'R':
	tp = format_reg (disdata, (insn >> 12) & 15, tp, with_reg_prefix);
	break;

      case 'n':
	{
	  /* Like N but pc-relative to the start of the insn.  */
	  unsigned long number
	    = (buffer[2] + buffer[3] * 256 + buffer[4] * 65536
	       + buffer[5] * 0x1000000 + addr);

	  /* Finish off and output previous formatted bytes.  */
	  *tp = 0;
	  if (temp[0])
	    (*info->fprintf_func) (info->stream, "%s", temp);
	  tp = temp;

	  (*info->print_address_func) ((bfd_vma) number, info);
	}
	break;

      case 'u':
	{
	  /* Like n but the offset is bits <3:0> in the instruction.  */
	  unsigned long number = (buffer[0] & 0xf) * 2 + addr;

	  /* Finish off and output previous formatted bytes.  */
	  *tp = 0;
	  if (temp[0])
	    (*info->fprintf_func) (info->stream, "%s", temp);
	  tp = temp;

	  (*info->print_address_func) ((bfd_vma) number, info);
	}
	break;

      case 'N':
      case 'y':
      case 'Y':
      case 'S':
      case 's':
	/* Any "normal" memory operand.  */
	if ((insn & 0x400) && (insn & 15) == 15 && prefix_opcodep == NULL)
	  {
	    /* We're looking at [pc+], i.e. we need to output an immediate
	       number, where the size can depend on different things.  */
	    long number;
	    int signedp
	      = ((*cs == 'z' && (insn & 0x20))
		 || opcodep->match == BDAP_QUICK_OPCODE);
	    int nbytes;

	    if (opcodep->imm_oprnd_size == SIZE_FIX_32)
	      nbytes = 4;
	    else if (opcodep->imm_oprnd_size == SIZE_SPEC_REG)
	      {
		const struct cris_spec_reg *sregp
		  = spec_reg_info ((insn >> 12) & 15, disdata->distype);

		/* A NULL return should have been as a non-match earlier,
		   so catch it as an internal error in the error-case
		   below.  */
		if (sregp == NULL)
		  /* Whatever non-valid size.  */
		  nbytes = 42;
		else
		  /* PC is always incremented by a multiple of two.
		     For CRISv32, immediates are always 4 bytes for
		     special registers.  */
		  nbytes = disdata->distype == cris_dis_v32
		    ? 4 : (sregp->reg_size + 1) & ~1;
	      }
	    else
	      {
		int mode_size = 1 << ((insn >> 4) & (*cs == 'z' ? 1 : 3));

		if (mode_size == 1)
		  nbytes = 2;
		else
		  nbytes = mode_size;
	      }

	    switch (nbytes)
	      {
	      case 1:
		number = buffer[2];
		if (signedp && number > 127)
		  number -= 256;
		break;

	      case 2:
		number = buffer[2] + buffer[3] * 256;
		if (signedp && number > 32767)
		  number -= 65536;
		break;

	      case 4:
		number
		  = buffer[2] + buffer[3] * 256 + buffer[4] * 65536
		  + buffer[5] * 0x1000000;
		break;

	      default:
		strcpy (tp, "bug");
		tp += 3;
		number = 42;
	      }

	    if ((*cs == 'z' && (insn & 0x20))
		|| (opcodep->match == BDAP_QUICK_OPCODE
		    && (nbytes <= 2 || buffer[1 + nbytes] == 0)))
	      tp = format_dec (number, tp, signedp);
	    else
	      {
		unsigned int highbyte = (number >> 24) & 0xff;

		/* Either output this as an address or as a number.  If it's
		   a dword with the same high-byte as the address of the
		   insn, assume it's an address, and also if it's a non-zero
		   non-0xff high-byte.  If this is a jsr or a jump, then
		   it's definitely an address.  */
		if (nbytes == 4
		    && (highbyte == ((addr >> 24) & 0xff)
			|| (highbyte != 0 && highbyte != 0xff)
			|| info->insn_type == dis_branch
			|| info->insn_type == dis_jsr))
		  {
		    /* Finish off and output previous formatted bytes.  */
		    *tp = 0;
		    tp = temp;
		    if (temp[0])
		      (*info->fprintf_func) (info->stream, "%s", temp);

		    (*info->print_address_func) ((bfd_vma) number, info);

		    info->target = number;
		  }
		else
		  tp = format_hex (number, tp, disdata);
	      }
	  }
	else
	  {
	    /* Not an immediate number.  Then this is a (possibly
	       prefixed) memory operand.  */
	    if (info->insn_type != dis_nonbranch)
	      {
		int mode_size
		  = 1 << ((insn >> 4)
			  & (opcodep->args[0] == 'z' ? 1 : 3));
		int size;
		info->insn_type = dis_dref;
		info->flags |= CRIS_DIS_FLAG_MEMREF;

		if (opcodep->imm_oprnd_size == SIZE_FIX_32)
		  size = 4;
		else if (opcodep->imm_oprnd_size == SIZE_SPEC_REG)
		  {
		    const struct cris_spec_reg *sregp
		      = spec_reg_info ((insn >> 12) & 15, disdata->distype);

		    /* FIXME: Improve error handling; should have been caught
		       earlier.  */
		    if (sregp == NULL)
		      size = 4;
		    else
		      size = sregp->reg_size;
		  }
		else
		  size = mode_size;

		info->data_size = size;
	      }

	    *tp++ = '[';

	    if (prefix_opcodep
		/* We don't match dip with a postincremented field
		   as a side-effect address mode.  */
		&& ((insn & 0x400) == 0
		    || prefix_opcodep->match != DIP_OPCODE))
	      {
		if (insn & 0x400)
		  {
		    tp = format_reg (disdata, insn & 15, tp, with_reg_prefix);
		    *tp++ = '=';
		  }


		/* We mainly ignore the prefix format string when the
		   address-mode syntax is output.  */
		switch (prefix_opcodep->match)
		  {
		  case DIP_OPCODE:
		    /* It's [r], [r+] or [pc+].  */
		    if ((prefix_insn & 0x400) && (prefix_insn & 15) == 15)
		      {
			/* It's [pc+].  This cannot possibly be anything
			   but an address.  */
			unsigned long number
			  = prefix_buffer[2] + prefix_buffer[3] * 256
			  + prefix_buffer[4] * 65536
			  + prefix_buffer[5] * 0x1000000;

			info->target = (bfd_vma) number;

			/* Finish off and output previous formatted
			   data.  */
			*tp = 0;
			tp = temp;
			if (temp[0])
			  (*info->fprintf_func) (info->stream, "%s", temp);

			(*info->print_address_func) ((bfd_vma) number, info);
		      }
		    else
		      {
			/* For a memref in an address, we use target2.
			   In this case, target is zero.  */
			info->flags
			  |= (CRIS_DIS_FLAG_MEM_TARGET2_IS_REG
			      | CRIS_DIS_FLAG_MEM_TARGET2_MEM);

			info->target2 = prefix_insn & 15;

			*tp++ = '[';
			tp = format_reg (disdata, prefix_insn & 15, tp,
					 with_reg_prefix);
			if (prefix_insn & 0x400)
			  *tp++ = '+';
			*tp++ = ']';
		      }
		    break;

		  case BDAP_QUICK_OPCODE:
		    {
		      int number;

		      number = prefix_buffer[0];
		      if (number > 127)
			number -= 256;

		      /* Output "reg+num" or, if num < 0, "reg-num".  */
		      tp = format_reg (disdata, (prefix_insn >> 12) & 15, tp,
				       with_reg_prefix);
		      if (number >= 0)
			*tp++ = '+';
		      tp = format_dec (number, tp, 1);

		      info->flags |= CRIS_DIS_FLAG_MEM_TARGET_IS_REG;
		      info->target = (prefix_insn >> 12) & 15;
		      info->target2 = (bfd_vma) number;
		      break;
		    }

		  case BIAP_OPCODE:
		    /* Output "r+R.m".  */
		    tp = format_reg (disdata, prefix_insn & 15, tp,
				     with_reg_prefix);
		    *tp++ = '+';
		    tp = format_reg (disdata, (prefix_insn >> 12) & 15, tp,
				     with_reg_prefix);
		    *tp++ = '.';
		    *tp++ = mode_char[(prefix_insn >> 4) & 3];

		    info->flags
		      |= (CRIS_DIS_FLAG_MEM_TARGET2_IS_REG
			  | CRIS_DIS_FLAG_MEM_TARGET_IS_REG

			  | ((prefix_insn & 0x8000)
			     ? CRIS_DIS_FLAG_MEM_TARGET2_MULT4
			     : ((prefix_insn & 0x8000)
				? CRIS_DIS_FLAG_MEM_TARGET2_MULT2 : 0)));

		    /* Is it the casejump?  It's a "adds.w [pc+r%d.w],pc".  */
		    if (insn == 0xf83f && (prefix_insn & ~0xf000) == 0x55f)
		      /* Then start interpreting data as offsets.  */
		      case_offset_counter = no_of_case_offsets;
		    break;

		  case BDAP_INDIR_OPCODE:
		    /* Output "r+s.m", or, if "s" is [pc+], "r+s" or
		       "r-s".  */
		    tp = format_reg (disdata, (prefix_insn >> 12) & 15, tp,
				     with_reg_prefix);

		    if ((prefix_insn & 0x400) && (prefix_insn & 15) == 15)
		      {
			long number;
			unsigned int nbytes;

			/* It's a value.  Get its size.  */
			int mode_size = 1 << ((prefix_insn >> 4) & 3);

			if (mode_size == 1)
			  nbytes = 2;
			else
			  nbytes = mode_size;

			switch (nbytes)
			  {
			  case 1:
			    number = prefix_buffer[2];
			    if (number > 127)
			      number -= 256;
			    break;

			  case 2:
			    number = prefix_buffer[2] + prefix_buffer[3] * 256;
			    if (number > 32767)
			      number -= 65536;
			    break;

			  case 4:
			    number
			      = prefix_buffer[2] + prefix_buffer[3] * 256
			      + prefix_buffer[4] * 65536
			      + prefix_buffer[5] * 0x1000000;
			    break;

			  default:
			    strcpy (tp, "bug");
			    tp += 3;
			    number = 42;
			  }

			info->flags |= CRIS_DIS_FLAG_MEM_TARGET_IS_REG;
			info->target2 = (bfd_vma) number;

			/* If the size is dword, then assume it's an
			   address.  */
			if (nbytes == 4)
			  {
			    /* Finish off and output previous formatted
			       bytes.  */
			    *tp++ = '+';
			    *tp = 0;
			    tp = temp;
			    (*info->fprintf_func) (info->stream, "%s", temp);

			    (*info->print_address_func) ((bfd_vma) number, info);
			  }
			else
			  {
			    if (number >= 0)
			      *tp++ = '+';
			    tp = format_dec (number, tp, 1);
			  }
		      }
		    else
		      {
			/* Output "r+[R].m" or "r+[R+].m".  */
			*tp++ = '+';
			*tp++ = '[';
			tp = format_reg (disdata, prefix_insn & 15, tp,
					 with_reg_prefix);
			if (prefix_insn & 0x400)
			  *tp++ = '+';
			*tp++ = ']';
			*tp++ = '.';
			*tp++ = mode_char[(prefix_insn >> 4) & 3];

			info->flags
			  |= (CRIS_DIS_FLAG_MEM_TARGET2_IS_REG
			      | CRIS_DIS_FLAG_MEM_TARGET2_MEM
			      | CRIS_DIS_FLAG_MEM_TARGET_IS_REG

			      | (((prefix_insn >> 4) == 2)
				 ? 0
				 : (((prefix_insn >> 4) & 3) == 1
				    ? CRIS_DIS_FLAG_MEM_TARGET2_MEM_WORD
				    : CRIS_DIS_FLAG_MEM_TARGET2_MEM_BYTE)));
		      }
		    break;

		  default:
		    (*info->fprintf_func) (info->stream, "?prefix-bug");
		  }

		/* To mark that the prefix is used, reset it.  */
		prefix_opcodep = NULL;
	      }
	    else
	      {
		tp = format_reg (disdata, insn & 15, tp, with_reg_prefix);

		info->flags |= CRIS_DIS_FLAG_MEM_TARGET_IS_REG;
		info->target = insn & 15;

		if (insn & 0x400)
		  *tp++ = '+';
	      }
	    *tp++ = ']';
	  }
	break;

      case 'x':
	tp = format_reg (disdata, (insn >> 12) & 15, tp, with_reg_prefix);
	*tp++ = '.';
	*tp++ = mode_char[(insn >> 4) & 3];
	break;

      case 'I':
	tp = format_dec (insn & 63, tp, 0);
	break;

      case 'b':
	{
	  int where = buffer[2] + buffer[3] * 256;

	  if (where > 32767)
	    where -= 65536;

	  where += addr + ((disdata->distype == cris_dis_v32) ? 0 : 4);

	  if (insn == BA_PC_INCR_OPCODE)
	    info->insn_type = dis_branch;
	  else
	    info->insn_type = dis_condbranch;

	  info->target = (bfd_vma) where;

	  *tp = 0;
	  tp = temp;
	  (*info->fprintf_func) (info->stream, "%s%s ",
				 temp, cris_cc_strings[insn >> 12]);

	  (*info->print_address_func) ((bfd_vma) where, info);
	}
      break;

    case 'c':
      tp = format_dec (insn & 31, tp, 0);
      break;

    case 'C':
      tp = format_dec (insn & 15, tp, 0);
      break;

    case 'o':
      {
	long offset = insn & 0xfe;
	bfd_vma target;

	if (insn & 1)
	  offset |= ~0xff;

	if (opcodep->match == BA_QUICK_OPCODE)
	  info->insn_type = dis_branch;
	else
	  info->insn_type = dis_condbranch;

	target = addr + ((disdata->distype == cris_dis_v32) ? 0 : 2) + offset;
	info->target = target;
	*tp = 0;
	tp = temp;
	(*info->fprintf_func) (info->stream, "%s", temp);
	(*info->print_address_func) (target, info);
      }
      break;

    case 'Q':
    case 'O':
      {
	long number = buffer[0];

	if (number > 127)
	  number = number - 256;

	tp = format_dec (number, tp, 1);
	*tp++ = ',';
	tp = format_reg (disdata, (insn >> 12) & 15, tp, with_reg_prefix);
      }
      break;

    case 'f':
      tp = print_flags (disdata, insn, tp);
      break;

    case 'i':
      tp = format_dec ((insn & 32) ? (insn & 31) | ~31L : insn & 31, tp, 1);
      break;

    case 'P':
      {
	const struct cris_spec_reg *sregp
	  = spec_reg_info ((insn >> 12) & 15, disdata->distype);

	if (sregp->name == NULL)
	  /* Should have been caught as a non-match eariler.  */
	  *tp++ = '?';
	else
	  {
	    if (with_reg_prefix)
	      *tp++ = REGISTER_PREFIX_CHAR;
	    strcpy (tp, sregp->name);
	    tp += strlen (tp);
	  }
      }
      break;

    default:
      strcpy (tp, "???");
      tp += 3;
    }
  }

  *tp = 0;

  if (prefix_opcodep)
    (*info->fprintf_func) (info->stream, " (OOPS unused prefix \"%s: %s\")",
			   prefix_opcodep->name, prefix_opcodep->args);

  (*info->fprintf_func) (info->stream, "%s", temp);

  /* Get info for matching case-tables, if we don't have any active.
     We assume that the last constant seen is used; either in the insn
     itself or in a "move.d const,rN, sub.d rN,rM"-like sequence.  */
  if (TRACE_CASE && case_offset_counter == 0)
    {
      if (CONST_STRNEQ (opcodep->name, "sub"))
	case_offset = last_immediate;

      /* It could also be an "add", if there are negative case-values.  */
      else if (CONST_STRNEQ (opcodep->name, "add"))
	/* The first case is the negated operand to the add.  */
	case_offset = -last_immediate;

      /* A bound insn will tell us the number of cases.  */
      else if (CONST_STRNEQ (opcodep->name, "bound"))
	no_of_case_offsets = last_immediate + 1;

      /* A jump or jsr or branch breaks the chain of insns for a
	 case-table, so assume default first-case again.  */
      else if (info->insn_type == dis_jsr
	       || info->insn_type == dis_branch
	       || info->insn_type == dis_condbranch)
	case_offset = 0;
    }
}


/* Print the CRIS instruction at address memaddr on stream.  Returns
   length of the instruction, in bytes.  Prefix register names with `$' if
   WITH_REG_PREFIX.  */

static int
print_insn_cris_generic (bfd_vma memaddr,
			 disassemble_info *info,
			 bfd_boolean with_reg_prefix)
{
  int nbytes;
  unsigned int insn;
  const struct cris_opcode *matchedp;
  int advance = 0;
  struct cris_disasm_data *disdata
    = (struct cris_disasm_data *) info->private_data;

  /* No instruction will be disassembled as longer than this number of
     bytes; stacked prefixes will not be expanded.  */
  unsigned char buffer[MAX_BYTES_PER_CRIS_INSN];
  unsigned char *bufp;
  int status = 0;
  bfd_vma addr;

  /* There will be an "out of range" error after the last instruction.
     Reading pairs of bytes in decreasing number, we hope that we will get
     at least the amount that we will consume.

     If we can't get any data, or we do not get enough data, we print
     the error message.  */

  for (nbytes = MAX_BYTES_PER_CRIS_INSN; nbytes > 0; nbytes -= 2)
    {
      status = (*info->read_memory_func) (memaddr, buffer, nbytes, info);
      if (status == 0)
	break;
    }

  /* If we did not get all we asked for, then clear the rest.
     Hopefully this makes a reproducible result in case of errors.  */
  if (nbytes != MAX_BYTES_PER_CRIS_INSN)
    memset (buffer + nbytes, 0, MAX_BYTES_PER_CRIS_INSN - nbytes);

  addr = memaddr;
  bufp = buffer;

  /* Set some defaults for the insn info.  */
  info->insn_info_valid = 1;
  info->branch_delay_insns = 0;
  info->data_size = 0;
  info->insn_type = dis_nonbranch;
  info->flags = 0;
  info->target = 0;
  info->target2 = 0;

  /* If we got any data, disassemble it.  */
  if (nbytes != 0)
    {
      matchedp = NULL;

      insn = bufp[0] + bufp[1] * 256;

      /* If we're in a case-table, don't disassemble the offsets.  */
      if (TRACE_CASE && case_offset_counter != 0)
	{
	  info->insn_type = dis_noninsn;
	  advance += 2;

	  /* If to print data as offsets, then shortcut here.  */
	  (*info->fprintf_func) (info->stream, "case %ld%s: -> ",
				 case_offset + no_of_case_offsets
				 - case_offset_counter,
				 case_offset_counter == 1 ? "/default" :
				 "");

	  (*info->print_address_func) ((bfd_vma)
				       ((short) (insn)
					+ (long) (addr
						  - (no_of_case_offsets
						     - case_offset_counter)
						  * 2)), info);
	  case_offset_counter--;

	  /* The default case start (without a "sub" or "add") must be
	     zero.  */
	  if (case_offset_counter == 0)
	    case_offset = 0;
	}
      else if (insn == 0)
	{
	  /* We're often called to disassemble zeroes.  While this is a
	     valid "bcc .+2" insn, it is also useless enough and enough
	     of a nuiscance that we will just output "bcc .+2" for it
	     and signal it as a noninsn.  */
	  (*info->fprintf_func) (info->stream,
				 disdata->distype == cris_dis_v32
				 ? "bcc ." : "bcc .+2");
	  info->insn_type = dis_noninsn;
	  advance += 2;
	}
      else
	{
	  const struct cris_opcode *prefix_opcodep = NULL;
	  unsigned char *prefix_buffer = bufp;
	  unsigned int prefix_insn = insn;
	  int prefix_size = 0;

	  matchedp = get_opcode_entry (insn, NO_CRIS_PREFIX, disdata);

	  /* Check if we're supposed to write out prefixes as address
	     modes and if this was a prefix.  */
	  if (matchedp != NULL && PARSE_PREFIX && matchedp->args[0] == 'p')
	    {
	      /* If it's a prefix, put it into the prefix vars and get the
		 main insn.  */
	      prefix_size = bytes_to_skip (prefix_insn, matchedp,
					   disdata->distype, NULL);
	      prefix_opcodep = matchedp;

	      insn = bufp[prefix_size] + bufp[prefix_size + 1] * 256;
	      matchedp = get_opcode_entry (insn, prefix_insn, disdata);

	      if (matchedp != NULL)
		{
		  addr += prefix_size;
		  bufp += prefix_size;
		  advance += prefix_size;
		}
	      else
		{
		  /* The "main" insn wasn't valid, at least not when
		     prefixed.  Put back things enough to output the
		     prefix insn only, as a normal insn.  */
		  matchedp = prefix_opcodep;
		  insn = prefix_insn;
		  prefix_opcodep = NULL;
		}
	    }

	  if (matchedp == NULL)
	    {
	      (*info->fprintf_func) (info->stream, "??0x%x", insn);
	      advance += 2;

	      info->insn_type = dis_noninsn;
	    }
	  else
	    {
	      advance
		+= bytes_to_skip (insn, matchedp, disdata->distype,
				  prefix_opcodep);

	      /* The info_type and assorted fields will be set according
		 to the operands.   */
	      print_with_operands (matchedp, insn, bufp, addr, info,
				   prefix_opcodep, prefix_insn,
				   prefix_buffer, with_reg_prefix);
	    }
	}
    }
  else
    info->insn_type = dis_noninsn;

  /* If we read less than MAX_BYTES_PER_CRIS_INSN, i.e. we got an error
     status when reading that much, and the insn decoding indicated a
     length exceeding what we read, there is an error.  */
  if (status != 0 && (nbytes == 0 || advance > nbytes))
    {
      (*info->memory_error_func) (status, memaddr, info);
      return -1;
    }

  /* Max supported insn size with one folded prefix insn.  */
  info->bytes_per_line = MAX_BYTES_PER_CRIS_INSN;

  /* I would like to set this to a fixed value larger than the actual
     number of bytes to print in order to avoid spaces between bytes,
     but objdump.c (2.9.1) does not like that, so we print 16-bit
     chunks, which is the next choice.  */
  info->bytes_per_chunk = 2;

  /* Printing bytes in order of increasing addresses makes sense,
     especially on a little-endian target.
     This is completely the opposite of what you think; setting this to
     BFD_ENDIAN_LITTLE will print bytes in order N..0 rather than the 0..N
     we want.  */
  info->display_endian = BFD_ENDIAN_BIG;

  return advance;
}

/* Disassemble, prefixing register names with `$'.  CRIS v0..v10.  */

static int
print_insn_cris_with_register_prefix (bfd_vma vma,
				      disassemble_info *info)
{
  if (info->private_data == NULL
      && !cris_parse_disassembler_options (info, cris_dis_v0_v10))
    return -1;
  return print_insn_cris_generic (vma, info, TRUE);
}

/* Disassemble, prefixing register names with `$'.  CRIS v32.  */

static int
print_insn_crisv32_with_register_prefix (bfd_vma vma,
					 disassemble_info *info)
{
  if (info->private_data == NULL
      && !cris_parse_disassembler_options (info, cris_dis_v32))
    return -1;
  return print_insn_cris_generic (vma, info, TRUE);
}

/* Disassemble, prefixing register names with `$'.
   Common v10 and v32 subset.  */

static int
print_insn_crisv10_v32_with_register_prefix (bfd_vma vma,
					     disassemble_info *info)
{
  if (info->private_data == NULL
      && !cris_parse_disassembler_options (info, cris_dis_common_v10_v32))
    return -1;
  return print_insn_cris_generic (vma, info, TRUE);
}

/* Disassemble, no prefixes on register names.  CRIS v0..v10.  */

static int
print_insn_cris_without_register_prefix (bfd_vma vma,
					 disassemble_info *info)
{
  if (info->private_data == NULL
      && !cris_parse_disassembler_options (info, cris_dis_v0_v10))
    return -1;
  return print_insn_cris_generic (vma, info, FALSE);
}

/* Disassemble, no prefixes on register names.  CRIS v32.  */

static int
print_insn_crisv32_without_register_prefix (bfd_vma vma,
					    disassemble_info *info)
{
  if (info->private_data == NULL
      && !cris_parse_disassembler_options (info, cris_dis_v32))
    return -1;
  return print_insn_cris_generic (vma, info, FALSE);
}

/* Disassemble, no prefixes on register names.
   Common v10 and v32 subset.  */

static int
print_insn_crisv10_v32_without_register_prefix (bfd_vma vma,
						disassemble_info *info)
{
  if (info->private_data == NULL
      && !cris_parse_disassembler_options (info, cris_dis_common_v10_v32))
    return -1;
  return print_insn_cris_generic (vma, info, FALSE);
}

/* Return a disassembler-function that prints registers with a `$' prefix,
   or one that prints registers without a prefix.
   FIXME: We should improve the solution to avoid the multitude of
   functions seen above.  */

disassembler_ftype
cris_get_disassembler (bfd *abfd)
{
  /* If there's no bfd in sight, we return what is valid as input in all
     contexts if fed back to the assembler: disassembly *with* register
     prefix.  Unfortunately this will be totally wrong for v32.  */
  if (abfd == NULL)
    return print_insn_cris_with_register_prefix;

  if (bfd_get_symbol_leading_char (abfd) == 0)
    {
      if (bfd_get_mach (abfd) == bfd_mach_cris_v32)
	return print_insn_crisv32_with_register_prefix;
      if (bfd_get_mach (abfd) == bfd_mach_cris_v10_v32)
	return print_insn_crisv10_v32_with_register_prefix;

      /* We default to v10.  This may be specifically specified in the
	 bfd mach, but is also the default setting.  */
      return print_insn_cris_with_register_prefix;
    }

  if (bfd_get_mach (abfd) == bfd_mach_cris_v32)
    return print_insn_crisv32_without_register_prefix;
  if (bfd_get_mach (abfd) == bfd_mach_cris_v10_v32)
    return print_insn_crisv10_v32_without_register_prefix;
  return print_insn_cris_without_register_prefix;
}

/* Local variables:
   eval: (c-set-style "gnu")
   indent-tabs-mode: t
   End:  */
@


1.21
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009
d24 1
a25 1
#include "sysdep.h"
@


1.20
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008
@


1.19
log
@Silence gcc printf warnings
@
text
@d663 1
a663 1
  const char *template = matchedp->args;
d666 1
a666 1
  for (s = template; *s; s++)
d673 1
a673 1
	int mode_size = 1 << ((insn >> 4) & (*template == 'z' ? 1 : 3));
@


1.18
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2004, 2005, 2006, 2007
d584 4
a587 1
  sprintf (outbuffer, signedp ? "%ld" : "%lu", number);
@


1.17
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2 2
a3 1
   Copyright 2000, 2001, 2002, 2004, 2005, 2006 Free Software Foundation, Inc.
d7 1
a7 1
   This file is part of the GNU binutils and GDB, the GNU debugger.
d9 9
a17 9
   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any later
   version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
   more details.
@


1.16
log
@	* cris-dis.c (bytes_to_skip): Handle new parameter prefix_matchedp.
	(print_with_operands): Check for prefix when [PC+] is seen.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
d786 1
a786 1
      if (strncmp (opcodep->name, "jsr", 3) == 0)
d1363 1
a1363 1
      if (strncmp (opcodep->name, "sub", 3) == 0)
d1367 1
a1367 1
      else if (strncmp (opcodep->name, "add", 3) == 0)
d1372 1
a1372 1
      else if (strncmp (opcodep->name, "bound", 5) == 0)
@


1.15
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d654 2
a655 1
	       enum cris_disass_family distype)
d664 2
a665 1
	&& (insn & 0x400) && (insn & 15) == 15)
d885 1
a885 1
	if ((insn & 0x400) && (insn & 15) == 15)
d1500 1
a1500 1
					   disdata->distype);
d1532 3
a1534 1
	      advance += bytes_to_skip (insn, matchedp, disdata->distype);
@


1.14
log
@Update function declarations to ISO C90 formatting
@
text
@d1451 1
a1451 1
	  (*info->fprintf_func) (info->stream, "case %d%s: -> ",
d1523 1
a1523 1
	      (*info->fprintf_func) (info->stream, "??0x%lx", insn);
@


1.13
log
@Update the address and phone number of the FSF
@
text
@d6 1
a6 1
This file is part of the GNU binutils and GDB, the GNU debugger.
d8 14
a21 13
This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a95 10
static int number_of_bits
  PARAMS ((unsigned int));
static char *format_hex
  PARAMS ((unsigned long, char *, struct cris_disasm_data *));
static char *format_dec
  PARAMS ((long, char *, int));
static char *format_reg
  PARAMS ((struct cris_disasm_data *, int, char *, bfd_boolean));
static char *format_sup_reg
  PARAMS ((unsigned int, char *, bfd_boolean));
d97 1
a97 31
  PARAMS ((const char *, unsigned int, unsigned int,
	   struct cris_disasm_data *));
static unsigned bytes_to_skip
  PARAMS ((unsigned int, const struct cris_opcode *,
	   enum cris_disass_family));
static char *print_flags
  PARAMS ((struct cris_disasm_data *, unsigned int, char *));
static void print_with_operands
  PARAMS ((const struct cris_opcode *, unsigned int, unsigned char *,
	   bfd_vma, disassemble_info *, const struct cris_opcode *,
	   unsigned int, unsigned char *, bfd_boolean));
static const struct cris_spec_reg *spec_reg_info
  PARAMS ((unsigned int, enum cris_disass_family));
static int print_insn_cris_generic
  PARAMS ((bfd_vma, disassemble_info *, bfd_boolean));
static int print_insn_cris_with_register_prefix
  PARAMS ((bfd_vma, disassemble_info *));
static int print_insn_cris_without_register_prefix
  PARAMS ((bfd_vma, disassemble_info *));
static int print_insn_crisv32_with_register_prefix
  PARAMS ((bfd_vma, disassemble_info *));
static int print_insn_crisv32_without_register_prefix
  PARAMS ((bfd_vma, disassemble_info *));
static int print_insn_crisv10_v32_with_register_prefix
  PARAMS ((bfd_vma, disassemble_info *));
static int print_insn_crisv10_v32_without_register_prefix
  PARAMS ((bfd_vma, disassemble_info *));
static bfd_boolean cris_parse_disassembler_options
  PARAMS ((disassemble_info *, enum cris_disass_family));
static const struct cris_opcode *get_opcode_entry
  PARAMS ((unsigned int, unsigned int, struct cris_disasm_data *));
d103 2
a104 3
cris_parse_disassembler_options (info, distype)
     disassemble_info *info;
     enum cris_disass_family distype;
a121 1

d123 1
a123 3
spec_reg_info (sreg, distype)
     unsigned int sreg;
     enum cris_disass_family distype;
d126 1
d157 1
a157 2
number_of_bits (val)
     unsigned int val;
d170 3
a172 4
get_opcode_entry (insn, prefix_insn, disdata)
     unsigned int insn;
     unsigned int prefix_insn;
     struct cris_disasm_data *disdata;
a398 99
/* Format number as hex with a leading "0x" into outbuffer.  */

static char *
format_hex (number, outbuffer, disdata)
     unsigned long number;
     char *outbuffer;
     struct cris_disasm_data *disdata;
{
  /* Truncate negative numbers on >32-bit hosts.  */
  number &= 0xffffffff;

  sprintf (outbuffer, "0x%lx", number);

  /* Save this value for the "case" support.  */
  if (TRACE_CASE)
    last_immediate = number;

  return outbuffer + strlen (outbuffer);
}

/* Format number as decimal into outbuffer.  Parameter signedp says
   whether the number should be formatted as signed (!= 0) or
   unsigned (== 0).  */

static char *
format_dec (number, outbuffer, signedp)
     long number;
     char *outbuffer;
     int signedp;
{
  last_immediate = number;
  sprintf (outbuffer, signedp ? "%ld" : "%lu", number);

  return outbuffer + strlen (outbuffer);
}

/* Format the name of the general register regno into outbuffer.  */

static char *
format_reg (disdata, regno, outbuffer_start, with_reg_prefix)
     struct cris_disasm_data *disdata;
     int regno;
     char *outbuffer_start;
     bfd_boolean with_reg_prefix;
{
  char *outbuffer = outbuffer_start;

  if (with_reg_prefix)
    *outbuffer++ = REGISTER_PREFIX_CHAR;

  switch (regno)
    {
    case 15:
      /* For v32, there is no context in which we output PC.  */
      if (disdata->distype == cris_dis_v32)
	strcpy (outbuffer, "acr");
      else
	strcpy (outbuffer, "pc");
      break;

    case 14:
      strcpy (outbuffer, "sp");
      break;

    default:
      sprintf (outbuffer, "r%d", regno);
      break;
    }

  return outbuffer_start + strlen (outbuffer_start);
}

/* Format the name of a support register into outbuffer.  */

static char *
format_sup_reg (regno, outbuffer_start, with_reg_prefix)
     unsigned int regno;
     char *outbuffer_start;
     bfd_boolean with_reg_prefix;
{
  char *outbuffer = outbuffer_start;
  int i;

  if (with_reg_prefix)
    *outbuffer++ = REGISTER_PREFIX_CHAR;

  for (i = 0; cris_support_regs[i].name != NULL; i++)
    if (cris_support_regs[i].number == regno)
      {
	sprintf (outbuffer, "%s", cris_support_regs[i].name);
	return outbuffer_start + strlen (outbuffer_start);
      }

  /* There's supposed to be register names covering all numbers, though
     some may be generic names.  */
  sprintf (outbuffer, "format_sup_reg-BUG");
  return outbuffer_start + strlen (outbuffer_start);
}

d404 4
a407 5
cris_constraint (cs, insn, prefix_insn, disdata)
     const char *cs;
     unsigned int insn;
     unsigned int prefix_insn;
     struct cris_disasm_data *disdata;
d412 1
a413 1
  const char *s;
d556 93
d652 3
a654 4
bytes_to_skip (insn, matchedp, distype)
     unsigned int insn;
     const struct cris_opcode *matchedp;
     enum cris_disass_family distype;
d701 1
a701 4
print_flags (disdata, insn, cp)
     struct cris_disasm_data *disdata;
     unsigned int insn;
     char *cp;
d728 12
a739 14
print_with_operands (opcodep, insn, buffer, addr, info, prefix_opcodep,
		     prefix_insn, prefix_buffer, with_reg_prefix)
     const struct cris_opcode *opcodep;
     unsigned int insn;
     unsigned char *buffer;
     bfd_vma addr;
     disassemble_info *info;

     /* If a prefix insn was before this insn (and is supposed to be
	output as an address), here is a description of it.  */
     const struct cris_opcode *prefix_opcodep;
     unsigned int prefix_insn;
     unsigned char *prefix_buffer;
     bfd_boolean with_reg_prefix;
d1366 3
a1368 4
	{
	  /* The first case is the negated operand to the add.  */
	  case_offset = -last_immediate;
	}
d1371 2
a1372 3
	{
	  no_of_case_offsets = last_immediate + 1;
	}
d1388 3
a1390 4
print_insn_cris_generic (memaddr, info, with_reg_prefix)
     bfd_vma memaddr;
     disassemble_info *info;
     bfd_boolean with_reg_prefix;
d1574 2
a1575 3
print_insn_cris_with_register_prefix (vma, info)
     bfd_vma vma;
     disassemble_info *info;
d1586 2
a1587 3
print_insn_crisv32_with_register_prefix (vma, info)
     bfd_vma vma;
     disassemble_info *info;
d1599 2
a1600 3
print_insn_crisv10_v32_with_register_prefix (vma, info)
     bfd_vma vma;
     disassemble_info *info;
d1611 2
a1612 3
print_insn_cris_without_register_prefix (vma, info)
     bfd_vma vma;
     disassemble_info *info;
d1623 2
a1624 3
print_insn_crisv32_without_register_prefix (vma, info)
     bfd_vma vma;
     disassemble_info *info;
d1636 2
a1637 3
print_insn_crisv10_v32_without_register_prefix (vma, info)
     bfd_vma vma;
     disassemble_info *info;
d1651 1
a1651 2
cris_get_disassembler (abfd)
     bfd *abfd;
d1678 4
a1681 6
/*
 * Local variables:
 * eval: (c-set-style "gnu")
 * indent-tabs-mode: t
 * End:
 */
@


1.12
log
@2005-03-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* cris-dis.c (print_with_operands): Use ~31L for long instead
	of ~31.
@
text
@d20 1
a20 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.11
log
@update copyright dates
@
text
@d1378 1
a1378 1
      tp = format_dec ((insn & 32) ? (insn & 31) | ~31 : insn & 31, tp, 1);
@


1.10
log
@	* cris-dis.c (format_hex): Remove ineffective warning fix.
	* crx-dis.c (make_instruction): Warning fix.
	* frv-asm.c: Regenerate.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
@


1.9
log
@	Generally, handle CRISv32.
	* cris-dis.c (TRACE_CASE): Define as (disdata->trace_case).
	(struct cris_disasm_data): New type.
	(format_reg, format_hex, cris_constraint, print_flags)
	(get_opcode_entry): Add struct cris_disasm_data * parameter.  All
	callers changed.
	(format_sup_reg, print_insn_crisv32_with_register_prefix)
	(print_insn_crisv32_without_register_prefix)
	(print_insn_crisv10_v32_with_register_prefix)
	(print_insn_crisv10_v32_without_register_prefix)
	(cris_parse_disassembler_options): New functions.
	(bytes_to_skip, cris_spec_reg): Add enum cris_disass_family
	parameter.  All callers changed.
	(get_opcode_entry): Call malloc, not xmalloc.  Return NULL on
	failure.
	(cris_constraint) <case 'Y', 'U'>: New cases.
	(bytes_to_skip): Handle 'Y' and 'N' as 's'.  Skip size is 4 bytes
	for constraint 'n'.
	(print_with_operands) <case 'Y'>: New case.
	(print_with_operands) <case 'T', 'A', '[', ']', 'd', 'n', 'u'>
	<case 'N', 'Y', 'Q'>: New cases.
	(print_insn_cris_generic): Emit "bcc ." for zero and CRISv32.
	(print_insn_cris_with_register_prefix)
	(print_insn_cris_without_register_prefix): Call
	cris_parse_disassembler_options.
	* cris-opc.c (cris_spec_regs): Mention that this table isn't used
	for CRISv32 and the size of immediate operands.  New v32-only
	entries for bz, pid, srs, wz, exs, eda, dz, ebp, erp, nrp, ccs and
	spc.  Add v32-only 4-byte entries for p2, p3, p5 and p6.  Change
	ccr, ibr, irp to be v0..v10.  Change bar, dccr to be v8..v10.
	Change brp to be v3..v10.
	(cris_support_regs): New vector.
	(cris_opcodes): Update head comment.  New format characters '[',
	']', space, 'A', 'd', 'N', 'n', 'Q', 'T', 'u', 'U', 'Y'.
	Add new opcodes for v32 and adjust existing opcodes to accommodate
	differences to earlier variants.
	(cris_cond15s): New vector.
@
text
@d451 2
a452 4
  /* Obfuscate to avoid warning on 32-bit host, but properly truncate
     negative numbers on >32-bit hosts.  */
  if (sizeof (number) > 4)
    number &= (1 << (sizeof (number) > 4 ? 32 : 1)) - 1;
@


1.8
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d65 1
a65 1
#define TRACE_CASE 1
d68 15
d98 1
a98 1
  PARAMS ((unsigned long, char *));
d102 3
a104 1
  PARAMS ((int, char *, bfd_boolean));
d106 2
a107 1
  PARAMS ((const char *, unsigned int, unsigned int));
d109 2
a110 1
  PARAMS ((unsigned int, const struct cris_opcode *));
d112 1
a112 1
  PARAMS ((unsigned int, char *));
d118 1
a118 1
  PARAMS ((unsigned int));
d125 10
d136 25
a160 1
  PARAMS ((unsigned int, unsigned int));
a161 3
/* Return the descriptor of a special register.
   FIXME: Depend on a CPU-version specific argument when all machinery
   is in place.  */
d164 1
a164 1
spec_reg_info (sreg)
d166 1
d172 19
a190 1
	return &cris_spec_regs[i];
d213 1
a213 1
get_opcode_entry (insn, prefix_insn)
d216 1
d235 4
a238 1
      opc_table = xmalloc (65536 * sizeof (opc_table[0]));
d242 4
a245 1
	= xmalloc (65536 * sizeof (const struct cris_opcode **));
d249 4
a252 1
	= xmalloc (65536 * sizeof (const struct cris_opcode **));
d256 4
a259 1
	= xmalloc (65536 * sizeof (const struct cris_opcode **));
d263 4
a266 1
	= xmalloc (65536 * sizeof (const struct cris_opcode **));
d270 4
a273 1
	= xmalloc (65536 * sizeof (const struct cris_opcode **));
d288 1
a288 1
	   : get_opcode_entry (prefix_insn, NO_CRIS_PREFIX));
d345 54
d410 2
a411 1
				      prefix_insn))
d446 1
a446 1
format_hex (number, outbuffer)
d449 1
d484 2
a485 1
format_reg (regno, outbuffer_start, with_reg_prefix)
d498 5
a502 1
      strcpy (outbuffer, "pc");
d517 27
d549 1
a549 1
cris_constraint (cs, insn, prefix_insn)
d553 1
d564 4
a567 2
	/* Do not recognize "pop" if there's a prefix.  */
	if (prefix_insn != NO_CRIS_PREFIX)
d571 4
d602 1
d610 1
a610 1
		  = get_opcode_entry (prefix_insn, NO_CRIS_PREFIX);
d630 1
a630 1
	      = get_opcode_entry (prefix_insn, NO_CRIS_PREFIX);
d643 1
a643 1
		      = spec_reg_info (spec_reg);
d672 1
a672 1
	    = spec_reg_info ((insn >> 12) & 15);
d705 1
a705 1
bytes_to_skip (insn, matchedp)
d708 1
d716 2
a717 1
    if (*s == 's' && (insn & 0x400) && (insn & 15) == 15)
d728 1
a728 1
	      = spec_reg_info ((insn >> 12) & 15);
d735 5
a739 2
	    /* PC is incremented by two, not one, for a byte.  */
	    to_skip += (sregp->reg_size + 1) & ~1;
d744 2
d755 2
a756 1
print_flags (insn, cp)
d762 7
a768 3
     v0 'd' <=> v8 'm'
     v0 'e' <=> v8 'b'.  */
  static const char fnames[] = "cvznxibm";
d807 2
d859 14
d878 8
a885 3
	/* Ignore at this point; used at earlier stages to avoid recognition
	   if there's a prefixes at something that in other ways looks like
	   a "pop".  */
d897 1
a897 1
	tp = format_reg (insn & 15, tp, with_reg_prefix);
d901 33
a933 1
	tp = format_reg ((insn >> 12) & 15, tp, with_reg_prefix);
d936 1
d938 1
d957 1
a957 1
		  = spec_reg_info ((insn >> 12) & 15);
d966 5
a970 2
		  /* PC is always incremented by a multiple of two.  */
		  nbytes = (sregp->reg_size + 1) & ~1;
d1038 1
a1038 1
		  tp = format_hex (number, tp);
d1059 1
a1059 1
		      = spec_reg_info ((insn >> 12) & 15);
d1084 1
a1084 1
		    tp = format_reg (insn & 15, tp, with_reg_prefix);
d1126 1
a1126 1
			tp = format_reg (prefix_insn & 15, tp,
d1143 1
a1143 1
		      tp = format_reg ((prefix_insn >> 12) & 15, tp,
d1157 2
a1158 1
		    tp = format_reg (prefix_insn & 15, tp, with_reg_prefix);
d1160 1
a1160 1
		    tp = format_reg ((prefix_insn >> 12) & 15, tp,
d1183 1
a1183 1
		    tp = format_reg ((prefix_insn >> 12) & 15, tp,
d1254 1
a1254 1
			tp = format_reg (prefix_insn & 15, tp,
d1284 1
a1284 1
		tp = format_reg (insn & 15, tp, with_reg_prefix);
d1297 1
a1297 1
	tp = format_reg ((insn >> 12) & 15, tp, with_reg_prefix);
d1313 1
a1313 1
	  where += addr + 4;
d1342 1
d1352 2
a1353 1
	info->target = (bfd_vma) (addr + 2 + offset);
d1357 1
a1357 2

	(*info->print_address_func) ((bfd_vma) (addr + 2 + offset), info);
d1361 1
d1371 1
a1371 1
	tp = format_reg ((insn >> 12) & 15, tp, with_reg_prefix);
d1376 1
a1376 1
      tp = print_flags (insn, tp);
d1386 1
a1386 1
	  = spec_reg_info ((insn >> 12) & 15);
d1458 2
d1538 3
a1540 1
	  (*info->fprintf_func) (info->stream, "bcc .+2");
d1551 1
a1551 1
	  matchedp = get_opcode_entry (insn, NO_CRIS_PREFIX);
d1559 2
a1560 1
	      prefix_size = bytes_to_skip (prefix_insn, matchedp);
d1564 1
a1564 1
	      matchedp = get_opcode_entry (insn, prefix_insn);
d1592 1
a1592 1
	      advance += bytes_to_skip (insn, matchedp);
d1633 1
a1633 1
/* Disassemble, prefixing register names with `$'.  */
d1640 30
d1673 1
a1673 1
/* Disassemble, no prefixes on register names.  */
d1680 30
d1714 3
a1716 1
   or one that prints registers without a prefix.  */
d1724 2
a1725 2
     prefix.  */
  if (abfd == NULL || bfd_get_symbol_leading_char (abfd) == 0)
d1728 16
@


1.7
log
@Fix compile time warning messages
@
text
@d2 1
a2 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d80 14
a93 9
static int number_of_bits PARAMS ((unsigned int));
static char *format_hex PARAMS ((unsigned long, char *));
static char *format_dec PARAMS ((long, char *, int));
static char *format_reg PARAMS ((int, char *, boolean));
static int cris_constraint PARAMS ((const char *, unsigned int,
				    unsigned int));
static unsigned bytes_to_skip PARAMS ((unsigned int,
				       const struct cris_opcode *));
static char *print_flags PARAMS ((unsigned int, char *));
d97 3
a99 2
	   unsigned int, unsigned char *, boolean));
static const struct cris_spec_reg *spec_reg_info PARAMS ((unsigned int));
d101 1
a101 1
  PARAMS ((bfd_vma, disassemble_info *, boolean));
d343 1
a343 1
     boolean with_reg_prefix;
d602 1
a602 1
     boolean with_reg_prefix;
d1195 1
a1195 1
     boolean with_reg_prefix;
d1378 1
a1378 1
  return print_insn_cris_generic (vma, info, true);
d1388 1
a1388 1
  return print_insn_cris_generic (vma, info, false);
@


1.7.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d80 9
a88 14
static int number_of_bits
  PARAMS ((unsigned int));
static char *format_hex
  PARAMS ((unsigned long, char *));
static char *format_dec
  PARAMS ((long, char *, int));
static char *format_reg
  PARAMS ((int, char *, bfd_boolean));
static int cris_constraint
  PARAMS ((const char *, unsigned int, unsigned int));
static unsigned bytes_to_skip
  PARAMS ((unsigned int, const struct cris_opcode *));
static char *print_flags
  PARAMS ((unsigned int, char *));
d92 2
a93 3
	   unsigned int, unsigned char *, bfd_boolean));
static const struct cris_spec_reg *spec_reg_info
  PARAMS ((unsigned int));
d95 1
a95 1
  PARAMS ((bfd_vma, disassemble_info *, bfd_boolean));
d337 1
a337 1
     bfd_boolean with_reg_prefix;
d596 1
a596 1
     bfd_boolean with_reg_prefix;
d1189 1
a1189 1
     bfd_boolean with_reg_prefix;
d1372 1
a1372 1
  return print_insn_cris_generic (vma, info, TRUE);
d1382 1
a1382 1
  return print_insn_cris_generic (vma, info, FALSE);
@


1.7.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d80 9
a88 14
static int number_of_bits
  PARAMS ((unsigned int));
static char *format_hex
  PARAMS ((unsigned long, char *));
static char *format_dec
  PARAMS ((long, char *, int));
static char *format_reg
  PARAMS ((int, char *, bfd_boolean));
static int cris_constraint
  PARAMS ((const char *, unsigned int, unsigned int));
static unsigned bytes_to_skip
  PARAMS ((unsigned int, const struct cris_opcode *));
static char *print_flags
  PARAMS ((unsigned int, char *));
d92 2
a93 3
	   unsigned int, unsigned char *, bfd_boolean));
static const struct cris_spec_reg *spec_reg_info
  PARAMS ((unsigned int));
d95 1
a95 1
  PARAMS ((bfd_vma, disassemble_info *, bfd_boolean));
d337 1
a337 1
     bfd_boolean with_reg_prefix;
d596 1
a596 1
     bfd_boolean with_reg_prefix;
d1189 1
a1189 1
     bfd_boolean with_reg_prefix;
d1372 1
a1372 1
  return print_insn_cris_generic (vma, info, TRUE);
d1382 1
a1382 1
  return print_insn_cris_generic (vma, info, FALSE);
@


1.6
log
@For include/opcode:
	* d30v.h: Fix declaration of reg_name_cnt.

	* d10v.h: Fix declaration of d10v_reg_name_cnt.

	* arc.h: Add prototypes from opcodes/arc-opc.c.

For opcodes:
	* tic54x-dis.c: Add unused attributes where needed.

	* z8k-dis.c (output_instr): Add unused attribute.

	* h8300-dis.c: Add missing prototypes.
	(bfd_h8_disassemble): Make static.

	* cris-dis.c: Add missing prototype.
	* h8500-dis.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* pj-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* z8k-dis.c: Likewise.

	* d10v-dis.c: Add missing prototype.
	(dis_long): Remove unused variable.
	(dis_2_short): Likewise.

	* sh-dis.c: Add missing prototypes.
	* v850-opc.c: Likewise.
	Add unused attributes where needed.

	* ns32k-dis.c: Add missing prototypes.
	(bit_extract_simple): Remove unused variable.
@
text
@d1200 1
a1200 1
  int status;
@


1.5
log
@	* alpha-dis.c: Fix formatting.
	* cris-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
@
text
@d10 1
a10 1
Software Foundation; either version 2 of the License, or (at your option)
d100 2
@


1.4
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d2 1
a2 1
   Copyright 2000 Free Software Foundation, Inc.
d127 1
a127 1
  for (bits = 0; val != 0; val &= val-1)
d375 1
a375 1
  for (s  = cs; *s; s++)
@


1.3
log
@	* cris-dis.c (cris_get_disassembler): If abfd is NULL, return
	print_insn_cris_with_register_prefix.
@
text
@d2 1
a2 1
   Copyright (C) 2000 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 2000 Free Software Foundation, Inc.
@


1.2
log
@	Changes to add dollar prefix to registers for files where user symbols
	don't have a leading underscore.  Fix formatting.
	* cris-dis.c (REGISTER_PREFIX_CHAR): New.
	(format_reg): Add parameter with_reg_prefix.  All callers changed.
	(print_with_operands): Ditto.
	(print_insn_cris_generic): Renamed from print_insn_cris, add
	parameter with_reg_prefix.
	(print_insn_cris_with_register_prefix,
	print_insn_cris_without_register_prefix, cris_get_disassembler):
	New.
	* disassemble.c (disassembler) [ARCH_cris]: Call cris_get_disassembler.
@
text
@d1390 4
a1393 1
  if (bfd_get_symbol_leading_char (abfd) == 0)
@


1.1
log
@	* Makefile.am (CFILES): Add cris-dis.c and cris-opc.c.
	(ALL_MACHINES): Add cris-dis.lo and cris-opc.lo.
	(cris-dis.lo, cris-opc.lo): New rules.
	* Makefile.in: Rebuild.
	* configure.in (bfd_cris_arch): New target.
	* configure: Rebuild.
	* disassemble.c (ARCH_cris): Define.
	(disassembler): Support ARCH_cris.
	* cris-dis.c, cris-opc.c: New files.
	* po/POTFILES.in, po/opcodes.pot: Regenerate.
@
text
@a26 1

d40 3
d83 1
a83 1
static char *format_reg PARAMS ((int, char *));
d89 4
a92 5
static void print_with_operands PARAMS ((const struct cris_opcode *,
					 unsigned int, unsigned char *,
					 bfd_vma, disassemble_info *,
					 const struct cris_opcode *,
					 unsigned int, unsigned char *));
d94 6
d104 1
d119 1
a120 1
/* Return the number of bits in the argument.  */
d133 1
a134 1
/* Get an entry in the opcode-table.  */
d292 1
a293 1
/* Format number as hex with a leading "0x" into outbuffer.  */
a312 1

d316 1
d329 1
a330 1
/* Format the name of the general register regno into outbuffer.  */
d332 1
a332 1
format_reg (regno, outbuffer)
d334 2
a335 1
     char *outbuffer;
d337 5
d357 1
a357 1
  return outbuffer + strlen (outbuffer);
a359 1

d363 1
d510 1
a511 1
/* Return the length of an instruction.  */
d553 1
a554 1
/* Print condition code flags.  */
a575 1

d579 1
d582 1
a582 1
		     prefix_insn, prefix_buffer)
d594 1
d598 1
a598 1
  char temp[sizeof (".d [r13=r12-2147483648],r10") * 2];
d672 1
a672 1
	tp = format_reg (insn & 15, tp);
d676 1
a676 1
	tp = format_reg ((insn >> 12) & 15, tp);
d822 1
a822 1
		    tp = format_reg (insn & 15, tp);
d864 2
a865 1
			tp = format_reg (prefix_insn & 15, tp);
d881 2
a882 1
		      tp = format_reg ((prefix_insn >> 12) & 15, tp);
d895 1
a895 1
		    tp = format_reg (prefix_insn & 15, tp);
d897 2
a898 1
		    tp = format_reg ((prefix_insn >> 12) & 15, tp);
d920 2
a921 1
		    tp = format_reg ((prefix_insn >> 12) & 15, tp);
d991 2
a992 1
			tp = format_reg (prefix_insn & 15, tp);
d1021 1
a1021 1
		tp = format_reg (insn & 15, tp);
d1034 1
a1034 1
	tp = format_reg ((insn >> 12) & 15, tp);
d1106 1
a1106 1
	tp = format_reg ((insn >> 12) & 15, tp);
d1128 2
d1180 5
a1184 3
   length of the instruction, in bytes.  */
int
print_insn_cris (memaddr, info)
d1187 1
d1328 1
a1328 1
				   prefix_buffer);
d1361 33
@

