head	1.7;
access;
symbols
	sid-snapshot-20180601:1.7
	sid-snapshot-20180501:1.7
	sid-snapshot-20180401:1.7
	sid-snapshot-20180301:1.7
	sid-snapshot-20180201:1.7
	sid-snapshot-20180101:1.7
	sid-snapshot-20171201:1.7
	sid-snapshot-20171101:1.7
	sid-snapshot-20171001:1.7
	sid-snapshot-20170901:1.7
	sid-snapshot-20170801:1.7
	sid-snapshot-20170701:1.7
	sid-snapshot-20170601:1.7
	sid-snapshot-20170501:1.7
	sid-snapshot-20170401:1.7
	sid-snapshot-20170301:1.7
	sid-snapshot-20170201:1.7
	sid-snapshot-20170101:1.7
	sid-snapshot-20161201:1.7
	sid-snapshot-20161101:1.7
	sid-snapshot-20160901:1.7
	sid-snapshot-20160801:1.7
	sid-snapshot-20160701:1.7
	sid-snapshot-20160601:1.7
	sid-snapshot-20160501:1.7
	sid-snapshot-20160401:1.7
	sid-snapshot-20160301:1.7
	sid-snapshot-20160201:1.7
	sid-snapshot-20160101:1.7
	sid-snapshot-20151201:1.7
	sid-snapshot-20151101:1.7
	sid-snapshot-20151001:1.7
	sid-snapshot-20150901:1.7
	sid-snapshot-20150801:1.7
	sid-snapshot-20150701:1.7
	sid-snapshot-20150601:1.7
	sid-snapshot-20150501:1.7
	sid-snapshot-20150401:1.7
	sid-snapshot-20150301:1.7
	sid-snapshot-20150201:1.7
	sid-snapshot-20150101:1.7
	sid-snapshot-20141201:1.7
	sid-snapshot-20141101:1.7
	sid-snapshot-20141001:1.7
	sid-snapshot-20140901:1.7
	sid-snapshot-20140801:1.7
	sid-snapshot-20140701:1.7
	sid-snapshot-20140601:1.7
	sid-snapshot-20140501:1.7
	sid-snapshot-20140401:1.7
	sid-snapshot-20140301:1.7
	sid-snapshot-20140201:1.7
	sid-snapshot-20140101:1.7
	sid-snapshot-20131201:1.7
	sid-snapshot-20131101:1.7
	sid-snapshot-20131001:1.7
	binutils-2_24-branch:1.7.0.4
	binutils-2_24-branchpoint:1.7
	sid-snapshot-20130901:1.7
	gdb_7_6_1-2013-08-30-release:1.7
	sid-snapshot-20130801:1.7
	sid-snapshot-20130701:1.7
	sid-snapshot-20130601:1.7
	sid-snapshot-20130501:1.7
	gdb_7_6-2013-04-26-release:1.7
	sid-snapshot-20130401:1.7
	binutils-2_23_2:1.3
	gdb_7_6-branch:1.7.0.2
	gdb_7_6-2013-03-12-branchpoint:1.7
	sid-snapshot-20130301:1.7
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.4
	gdb_7_5_1-2012-11-29-release:1.3
	binutils-2_23_1:1.3
	sid-snapshot-20121101:1.4
	binutils-2_23:1.3
	sid-snapshot-20121001:1.4
	sid-snapshot-20120901:1.4
	gdb_7_5-2012-08-17-release:1.3
	sid-snapshot-20120801:1.3
	binutils-2_23-branch:1.3.0.4
	binutils-2_23-branchpoint:1.3
	gdb_7_5-branch:1.3.0.2
	gdb_7_5-2012-07-18-branchpoint:1.3
	sid-snapshot-20120701:1.3
	sid-snapshot-20120601:1.3
	sid-snapshot-20120501:1.2
	gdb_7_4_1-2012-04-26-release:1.1
	sid-snapshot-20120401:1.2
	sid-snapshot-20120301:1.2
	sid-snapshot-20120201:1.2
	gdb_7_4-2012-01-24-release:1.1
	sid-snapshot-20120101:1.1
	gdb_7_4-branch:1.1.0.2
	gdb_7_4-2011-12-13-branchpoint:1.1
	sid-snapshot-20111201:1.1
	binutils_latest_snapshot:1.7;
locks; strict;
comment	@# @;


1.7
date	2013.02.27.03.00.44;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2013.02.25.18.41.06;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2012.12.17.16.56.11;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.15.22.37.56;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2012.01.25.01.40.09;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.02.03.09.11;	author dj;	state Exp;
branches;
next	;


desc
@@


1.7
log
@	* rl78-decode.opc (rl78_decode_opcode): Fix typo.
	* rl78-decode.c: Regenerate.
@
text
@/* -*- c -*- */
/* Copyright 2012-2013 Free Software Foundation, Inc.
   Contributed by Red Hat.
   Written by DJ Delorie.

   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ansidecl.h"
#include "opcode/rl78.h"

static int trace = 0;

typedef struct
{
  RL78_Opcode_Decoded * rl78;
  int (* getbyte)(void *);
  void * ptr;
  unsigned char * op;
} LocalData;

#define ID(x) rl78->id = RLO_##x, rl78->lineno = __LINE__
#define OP(n,t,r,a) (rl78->op[n].type = t, \
		     rl78->op[n].reg = r,	     \
		     rl78->op[n].addend = a )
#define OPX(n,t,r1,r2,a) \
	(rl78->op[n].type = t, \
	rl78->op[n].reg = r1, \
	rl78->op[n].reg2 = r2, \
	rl78->op[n].addend = a )

#define W() rl78->size = RL78_Word

#define AU ATTRIBUTE_UNUSED
#define GETBYTE() (ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr))
#define B ((unsigned long) GETBYTE())

#define SYNTAX(x) rl78->syntax = x

#define UNSUPPORTED() \
  rl78->syntax = "*unknown*"

#define RB(x) ((x)+RL78_Reg_X)
#define RW(x) ((x)+RL78_Reg_AX)

#define Fz	rl78->flags = RL78_PSW_Z
#define Fza	rl78->flags = RL78_PSW_Z | RL78_PSW_AC
#define Fzc	rl78->flags = RL78_PSW_Z | RL78_PSW_CY
#define Fzac	rl78->flags = RL78_PSW_Z | RL78_PSW_AC | RL78_PSW_CY
#define Fa	rl78->flags = RL78_PSW_AC
#define Fc	rl78->flags = RL78_PSW_CY
#define Fac	rl78->flags = RL78_PSW_AC | RL78_PSW_CY

#define IMMU(bytes)   immediate (bytes, 0, ld)
#define IMMS(bytes)   immediate (bytes, 1, ld)

static int
immediate (int bytes, int sign_extend, LocalData * ld)
{
  unsigned long i = 0;

  switch (bytes)
    {
    case 1:
      i |= B;
      if (sign_extend && (i & 0x80))
	i -= 0x100;
      break;
    case 2:
      i |= B;
      i |= B << 8;
      if (sign_extend && (i & 0x8000))
	i -= 0x10000;
      break;
    case 3:
      i |= B;
      i |= B << 8;
      i |= B << 16;
      if (sign_extend && (i & 0x800000))
	i -= 0x1000000;
      break;
    default:
      fprintf (stderr, "Programmer error: immediate() called with invalid byte count %d\n", bytes);
      abort();
    }
  return i;
}

#define DC(c)		OP (0, RL78_Operand_Immediate, 0, c)
#define DR(r)		OP (0, RL78_Operand_Register, RL78_Reg_##r, 0)
#define DRB(r)		OP (0, RL78_Operand_Register, RB(r), 0)
#define DRW(r)		OP (0, RL78_Operand_Register, RW(r), 0)
#define DM(r,a)		OP (0, RL78_Operand_Indirect, RL78_Reg_##r, a)
#define DM2(r1,r2,a)	OPX (0, RL78_Operand_Indirect, RL78_Reg_##r1, RL78_Reg_##r2, a)
#define DE()		rl78->op[0].use_es = 1
#define DB(b)		set_bit (rl78->op, b)
#define DCY()		DR(PSW); DB(0)
#define DPUSH()		OP (0, RL78_Operand_PreDec, RL78_Reg_SP, 0);

#define SC(c)		OP (1, RL78_Operand_Immediate, 0, c)
#define SR(r)		OP (1, RL78_Operand_Register, RL78_Reg_##r, 0)
#define SRB(r)		OP (1, RL78_Operand_Register, RB(r), 0)
#define SRW(r)		OP (1, RL78_Operand_Register, RW(r), 0)
#define SM(r,a)		OP (1, RL78_Operand_Indirect, RL78_Reg_##r, a)
#define SM2(r1,r2,a)	OPX (1, RL78_Operand_Indirect, RL78_Reg_##r1, RL78_Reg_##r2, a)
#define SE()		rl78->op[1].use_es = 1
#define SB(b)		set_bit (rl78->op+1, b)
#define SCY()		SR(PSW); SB(0)
#define COND(c)		rl78->op[1].condition = RL78_Condition_##c
#define SPOP()		OP (1, RL78_Operand_PostInc, RL78_Reg_SP, 0);

static void
set_bit (RL78_Opcode_Operand *op, int bit)
{
  op->bit_number = bit;
  switch (op->type) {
  case RL78_Operand_Register:
    op->type = RL78_Operand_Bit;
    break;
  case RL78_Operand_Indirect:
    op->type = RL78_Operand_BitIndirect;
    break;
  default:
    break;
  }
}

static int
saddr (int x)
{
  if (x < 0x20)
    return 0xfff00 + x;
  return 0xffe00 + x;
}

static int
sfr (int x)
{
  return 0xfff00 + x;
}

#define SADDR saddr (IMMU (1))
#define SFR sfr (IMMU (1))

int
rl78_decode_opcode (unsigned long pc AU,
		  RL78_Opcode_Decoded * rl78,
		  int (* getbyte)(void *),
		  void * ptr)
{
  LocalData lds, * ld = &lds;
  unsigned char op_buf[20] = {0};
  unsigned char *op = op_buf;
  int op0, op1;

  lds.rl78 = rl78;
  lds.getbyte = getbyte;
  lds.ptr = ptr;
  lds.op = op;

  memset (rl78, 0, sizeof (*rl78));

 start_again:

/* Byte registers, not including A.  */
/** VARY rba 000 010 011 100 101 110 111 */
/* Word registers, not including AX.  */
/** VARY ra 01 10 11 */

/*----------------------------------------------------------------------*/
/* ES: prefix								*/

/** 0001 0001			es:					*/
  DE(); SE();
  op ++;
  pc ++;
  goto start_again;

/*----------------------------------------------------------------------*/

/** 0000 1111			add	%0, %e!1			*/
  ID(add); DR(A); SM(None, IMMU(2)); Fzac;

/** 0000 1101			add	%0, %e1				*/
  ID(add); DR(A); SM(HL, 0); Fzac;

/** 0110 0001 1000 000		add	%0, %e1				*/
  ID(add); DR(A); SM2(HL, B, 0); Fzac;

/** 0000 1110			add	%0, %e1				*/
  ID(add); DR(A); SM(HL, IMMU(1)); Fzac;
  
/** 0110 0001 1000 0010		add	%0, %e1				*/
  ID(add); DR(A); SM2(HL, C, 0); Fzac;

/** 0000 1100			add	%0, #%1				*/
  ID(add); DR(A); SC(IMMU(1)); Fzac;

/** 0110 0001 0000 1rba		add	%0, %1				*/
  ID(add); DR(A); SRB(rba); Fzac;

/** 0000 1011			add	%0, %1				*/
  ID(add); DR(A); SM(None, SADDR); Fzac;

/** 0110 0001 0000 0reg		add	%0, %1				*/
  ID(add); DRB(reg); SR(A); Fzac;

/** 0000 1010			add	%0, #%1				*/
  ID(add); DM(None, SADDR); SC(IMMU(1)); Fzac;

/*----------------------------------------------------------------------*/

/** 0001 1111			addc	%0, %e!1			*/
  ID(addc); DR(A); SM(None, IMMU(2)); Fzac;

/** 0001 1101			addc	%0, %e1				*/
  ID(addc); DR(A); SM(HL, 0); Fzac;

/** 0110 0001 1001 0000		addc	%0, %e1				*/
  ID(addc); DR(A); SM2(HL, B, 0); Fzac;

/** 0110 0001 1001 0010		addc	%0, %e1				*/
  ID(addc); DR(A); SM2(HL, C, 0); Fzac;

/** 0001 1110			addc	%0, %e1				*/
  ID(addc); DR(A); SM(HL, IMMU(1)); Fzac;

/** 0001 1100			addc	%0, #%1				*/
  ID(addc); DR(A); SC(IMMU(1)); Fzac;

/** 0110 0001 0001 1rba		addc	%0, %1				*/
  ID(addc); DR(A); SRB(rba); Fzac;

/** 0110 0001 0001 0reg		addc	%0, %1				*/
  ID(addc); DRB(reg); SR(A); Fzac;

/** 0001 1011			addc	%0, %1				*/
  ID(addc); DR(A); SM(None, SADDR); Fzac;

/** 0001 1010			addc	%0, #%1				*/
  ID(addc); DM(None, SADDR); SC(IMMU(1)); Fzac;

/*----------------------------------------------------------------------*/

/** 0000 0010			addw	%0, %e!1			*/
  ID(add); W(); DR(AX); SM(None, IMMU(2)); Fzac;

/** 0110 0001 0000 1001		addw	%0, %e1			*/
  ID(add); W(); DR(AX); SM(HL, IMMU(1)); Fzac;

/** 0000 0100			addw	%0, #%1				*/
  ID(add); W(); DR(AX); SC(IMMU(2)); Fzac;

/** 0000 0rw1			addw	%0, %1				*/
  ID(add); W(); DR(AX); SRW(rw); Fzac;

/** 0000 0110			addw	%0, %1				*/
  ID(add); W(); DR(AX); SM(None, SADDR); Fzac;

/** 0001 0000			addw	%0, #%1				*/
  ID(add); W(); DR(SP); SC(IMMU(1)); Fzac;

/*----------------------------------------------------------------------*/

/** 0101 1111			and	%0, %e!1			*/
  ID(and); DR(A); SM(None, IMMU(2)); Fz;

/** 0101 1101			and	%0, %e1			*/
  ID(and); DR(A); SM(HL, 0); Fz;

/** 0110 0001 1101 0000		and	%0, %e1			*/
  ID(and); DR(A); SM2(HL, B, 0); Fz;

/** 0101 1110			and	%0, %e1			*/
  ID(and); DR(A); SM(HL, IMMU(1)); Fz;

/** 0110 0001 1101 0010		and	%0, %e1			*/
  ID(and); DR(A); SM2(HL, C, 0); Fz;

/** 0101 1100	       		and	%0, #%1				*/
  ID(and); DR(A); SC(IMMU(1)); Fz;

/** 0110 0001 0101 1rba		and	%0, %1				*/
  ID(and); DR(A); SRB(rba); Fz;

/** 0110 0001 0101 0reg		and	%0, %1				*/
  ID(and); DRB(reg); SR(A); Fz;

/** 0101 1011	       		and	%0, %1				*/
  ID(and); DR(A); SM(None, SADDR); Fz;

/** 0101 1010	       		and	%0, #%1				*/
  ID(and); DM(None, SADDR); SC(IMMU(1)); Fz;

/*----------------------------------------------------------------------*/

/** 0111 0001 1bit 0101		and1	cy, %e1			*/
  ID(and); DCY(); SM(HL, 0); SB(bit);

/** 0111 0001 1bit 1101		and1	cy, %1				*/
  ID(and); DCY(); SR(A); SB(bit);

/** 0111 0001 0bit 1101		and1	cy, %s1				*/
  ID(and); DCY(); SM(None, SFR); SB(bit);

/** 0111 0001 0bit 0101		and1	cy, %s1				*/
  ID(and); DCY(); SM(None, SADDR); SB(bit);

/*----------------------------------------------------------------------*/

/* Note that the branch insns need to be listed before the shift
   ones, as "shift count of zero" means "branch insn" */

/** 1101 1100			bc	$%a0				*/
  ID(branch_cond); DC(pc+IMMS(1)+2); SR(None); COND(C);

/** 1101 1110			bnc	$%a0				*/
  ID(branch_cond); DC(pc+IMMS(1)+2); SR(None); COND(NC);

/** 0110 0001 1100 0011		bh	$%a0				*/
  ID(branch_cond); DC(pc+IMMS(1)+3); SR(None); COND(H);

/** 0110 0001 1101 0011		bnh	$%a0				*/
  ID(branch_cond); DC(pc+IMMS(1)+3); SR(None); COND(NH);

/** 1101 1101			bz	$%a0				*/
  ID(branch_cond); DC(pc+IMMS(1)+2); SR(None); COND(Z);

/** 1101 1111			bnz	$%a0				*/
  ID(branch_cond); DC(pc+IMMS(1)+2); SR(None); COND(NZ);

/*----------------------------------------------------------------------*/

/** 0011 0001 1bit 0101		bf	%e1, $%a0			*/
  ID(branch_cond); DC(pc+IMMS(1)+3); SM(HL,0); SB(bit); COND(F);

/** 0011 0001 0bit 0101		bf	%1, $%a0			*/
  ID(branch_cond); DC(pc+IMMS(1)+3); SR(A); SB(bit); COND(F);

/** 0011 0001 1bit 0100		bf	%s1, $%a0			*/
  ID(branch_cond); SM(None, SFR); SB(bit); DC(pc+IMMS(1)+4); COND(F);

/** 0011 0001 0bit 0100		bf	%s1, $%a0			*/
  ID(branch_cond); SM(None, SADDR); SB(bit); DC(pc+IMMS(1)+4); COND(F);

/*----------------------------------------------------------------------*/

/** 1110 1100			br	!%!a0				*/
  ID(branch); DC(IMMU(3));

/** 1110 1101			br	%!a0				*/
  ID(branch); DC(IMMU(2));

/** 1110 1110			br	$%!a0				*/
  ID(branch); DC(pc+IMMS(2)+3);

/** 1110 1111			br	$%a0				*/
  ID(branch); DC(pc+IMMS(1)+2);

/** 0110 0001 1100 1011		br	ax				*/
  ID(branch); DR(AX);

/*----------------------------------------------------------------------*/

/** 1111 1111			brk1					*/
  ID(break);

/** 0110 0001 1100 1100		brk					*/
  ID(break);

/*----------------------------------------------------------------------*/

/** 0011 0001 1bit 0011		bt	%e1, $%a0			*/
  ID(branch_cond); DC(pc+IMMS(1)+3); SM(HL,0); SB(bit); COND(T);

/** 0011 0001 0bit 0011		bt	%1, $%a0			*/
  ID(branch_cond); DC(pc+IMMS(1)+3); SR(A); SB(bit); COND(T);

/** 0011 0001 1bit 0010		bt	%s1, $%a0			*/
  ID(branch_cond); SM(None, SFR); SB(bit); DC(pc+IMMS(1)+4); COND(T);

/** 0011 0001 0bit 0010		bt	%s1, $%a0			*/
  ID(branch_cond); SM(None, SADDR); SB(bit); DC(pc+IMMS(1)+4); COND(T);

/*----------------------------------------------------------------------*/

/** 0011 0001 1bit 0001		btclr	%e1, $%a0			*/
  ID(branch_cond_clear); DC(pc+IMMS(1)+3); SM(HL,0); SB(bit); COND(T);

/** 0011 0001 0bit 0001		btclr	%1, $%a0			*/
  ID(branch_cond_clear); DC(pc+IMMS(1)+3); SR(A); SB(bit); COND(T);

/** 0011 0001 1bit 0000		btclr	%s1, $%a0			*/
  ID(branch_cond_clear); SM(None, SFR); SB(bit); DC(pc+IMMS(1)+4); COND(T);

/** 0011 0001 0bit 0000		btclr	%s1, $%a0			*/
  ID(branch_cond_clear); SM(None, SADDR); SB(bit); DC(pc+IMMS(1)+4); COND(T);

/*----------------------------------------------------------------------*/

/** 1111 1100			call	!%!a0				*/
  ID(call); DC(IMMU(3));

/** 1111 1101			call	%!a0				*/
  ID(call); DC(IMMU(2));

/** 1111 1110			call	$%!a0				*/
  ID(call); DC(pc+IMMS(2)+3);

/** 0110 0001 11rg 1010		call	%0				*/
  ID(call); DRW(rg);

/** 0110 0001 1nnn 01mm		callt	[%x0]				*/
  ID(call); DM(None, 0x80 + mm*16 + nnn*2);

/*----------------------------------------------------------------------*/

/** 0111 0001 0bit 1000		clr1	%e!0				*/
  ID(mov); DM(None, IMMU(2)); DB(bit); SC(0);

/** 0111 0001 1bit 0011		clr1	%e0				*/
  ID(mov); DM(HL, 0); DB(bit); SC(0);

/** 0111 0001 1bit 1011		clr1	%0				*/
  ID(mov); DR(A); DB(bit); SC(0);

/** 0111 0001 1000 1000		clr1	cy				*/
  ID(mov); DCY(); SC(0);

/** 0111 0001 0bit 1011		clr1	%s0				*/
  op0 = SFR;
  ID(mov); DM(None, op0); DB(bit); SC(0);
  if (op0 == RL78_SFR_PSW && bit == 7)
    rl78->syntax = "di";

/** 0111 0001 0bit 0011		clr1	%0				*/
  ID(mov); DM(None, SADDR); DB(bit); SC(0);

/*----------------------------------------------------------------------*/

/** 1111 0101			clrb	%e!0				*/
  ID(mov); DM(None, IMMU(2)); SC(0);

/** 1111 00rg			clrb	%0				*/
  ID(mov); DRB(rg); SC(0);

/** 1111 0100			clrb	%0				*/
  ID(mov); DM(None, SADDR); SC(0);

/*----------------------------------------------------------------------*/

/** 1111 0110			clrw	%0				*/
  ID(mov); DR(AX); SC(0);

/** 1111 0111			clrw	%0				*/
  ID(mov); DR(BC); SC(0);

/*----------------------------------------------------------------------*/

/** 0100 0000			cmp	%e!0, #%1			*/
  ID(cmp); DM(None, IMMU(2)); SC(IMMU(1)); Fzac;

/** 0100 1010			cmp	%0, #%1				*/
  ID(cmp); DM(None, SADDR); SC(IMMU(1)); Fzac;

/** 0100 1111			cmp	%0, %e!1			*/
  ID(cmp); DR(A); SM(None, IMMU(2)); Fzac;

/** 0100 1101			cmp	%0, %e1				*/
  ID(cmp); DR(A); SM(HL, 0); Fzac;

/** 0110 0001 1100 0000		cmp	%0, %e1				*/
  ID(cmp); DR(A); SM2(HL, B, 0); Fzac;

/** 0110 0001 1100 0010		cmp	%0, %e1				*/
  ID(cmp); DR(A); SM2(HL, C, 0); Fzac;

/** 0100 1110			cmp	%0, %e1				*/
  ID(cmp); DR(A); SM(HL, IMMU(1)); Fzac;

/** 0100 1100			cmp	%0, #%1				*/
  ID(cmp); DR(A); SC(IMMU(1)); Fzac;

/** 0110 0001 0100 1rba		cmp	%0, %1				*/
  ID(cmp); DR(A); SRB(rba); Fzac;

/** 0110 0001 0100 0reg		cmp	%0, %1				*/
  ID(cmp); DRB(reg); SR(A); Fzac;

/** 0100 1011			cmp	%0, %1				*/
  ID(cmp); DR(A); SM(None, SADDR); Fzac;

/*----------------------------------------------------------------------*/

/** 1101 0101			cmp0	%e!0				*/
  ID(cmp); DM(None, IMMU(2)); SC(0); Fzac;

/** 1101 00rg			cmp0	%0				*/
  ID(cmp); DRB(rg); SC(0); Fzac;

/** 1101 0100			cmp0	%0				*/
  ID(cmp); DM(None, SADDR); SC(0); Fzac;

/*----------------------------------------------------------------------*/

/** 0110 0001 1101 1110		cmps	%0, %e1				*/
  ID(cmp); DR(X); SM(HL, IMMU(1)); Fzac;

/*----------------------------------------------------------------------*/

/** 0100 0010			cmpw	%0, %e!1			*/
  ID(cmp); W(); DR(AX); SM(None, IMMU(2)); Fzac;

/** 0110 0001 0100 1001		cmpw	%0, %e1				*/
  ID(cmp); W(); DR(AX); SM(HL, IMMU(1)); Fzac;

/** 0100 0100			cmpw	%0, #%1				*/
  ID(cmp); W(); DR(AX); SC(IMMU(2)); Fzac;

/** 0100 0ra1			cmpw	%0, %1				*/
  ID(cmp); W(); DR(AX); SRW(ra); Fzac;

/** 0100 0110			cmpw	%0, %1				*/
  ID(cmp); W(); DR(AX); SM(None, SADDR); Fzac;

/*----------------------------------------------------------------------*/

/** 1011 0000			dec	%e!0				*/
  ID(sub); DM(None, IMMU(2)); SC(1); Fza;

/** 0110 0001 0110 1001		dec	%e0				*/
  ID(sub); DM(HL, IMMU(1)); SC(1); Fza;

/** 1001 0reg			dec	%0				*/
  ID(sub); DRB(reg); SC(1); Fza;

/** 1011 0100			dec	%0				*/
  ID(sub); DM(None, SADDR); SC(1); Fza;

/*----------------------------------------------------------------------*/

/** 1011 0010			decw	%e!0				*/
  ID(sub); W(); DM(None, IMMU(2)); SC(1);

/** 0110 0001 1000 1001		decw	%e0				*/
  ID(sub); W(); DM(HL, IMMU(1)); SC(1);

/** 1011 0rg1 			decw	%0				*/
  ID(sub); W(); DRW(rg); SC(1);

/** 1011 0110			decw	%0				*/
  ID(sub); W(); DM(None, SADDR); SC(1);

/*----------------------------------------------------------------------*/

/** 0110 0001 1110 1101		halt					*/
  ID(halt);

/*----------------------------------------------------------------------*/

/** 1010 0000			inc	%e!0				*/
  ID(add); DM(None, IMMU(2)); SC(1); Fza;

/** 0110 0001 0101 1001		inc	%e0				*/
  ID(add); DM(HL, IMMU(1)); SC(1); Fza;

/** 1000 0reg			inc	%0				*/
  ID(add); DRB(reg); SC(1); Fza;

/** 1010 0100			inc	%0				*/
  ID(add); DM(None, SADDR); SC(1); Fza;

/*----------------------------------------------------------------------*/

/** 1010 0010			incw	%e!0				*/
  ID(add); W(); DM(None, IMMU(2)); SC(1);

/** 0110 0001 0111 1001		incw	%e0				*/
  ID(add); W(); DM(HL, IMMU(1)); SC(1);

/** 1010 0rg1			incw	%0				*/
  ID(add); W(); DRW(rg); SC(1);

/** 1010 0110			incw	%0				*/
  ID(add); W(); DM(None, SADDR); SC(1);

/*----------------------------------------------------------------------*/

/** 1100 1111			mov	%e!0, #%1			*/
  ID(mov); DM(None, IMMU(2)); SC(IMMU(1));

/** 1001 1111			mov	%e!0, %1			*/
  ID(mov); DM(None, IMMU(2)); SR(A);

/** 1001 1001			mov	%e0,%1				*/
  ID(mov); DM(DE, 0); SR(A);

/** 1100 1010			mov	%e0, #%1			*/
  ID(mov); DM(DE, IMMU(1)); SC(IMMU(1));

/** 1001 1010			mov	%e0, %1				*/
  ID(mov); DM(DE, IMMU(1)); SR(A);

/** 1001 1011			mov	%e0,%1				*/
  ID(mov); DM(HL, 0); SR(A);

/** 0110 0001 1101 1001		mov	%e0, %1				*/
  ID(mov); DM2(HL, B, 0); SR(A);

/** 1100 1100			mov	%e0, #%1			*/
  ID(mov); DM(HL, IMMU(1)); SC(IMMU(1));

/** 1001 1100			mov	%e0, %1				*/
  ID(mov); DM(HL, IMMU(1)); SR(A);

/** 0110 0001 1111 1001		mov	%e0, %1				*/
  ID(mov); DM2(HL, C, 0); SR(A);

/** 1100 1000			mov	%0, #%1				*/
  ID(mov); DM(SP, IMMU(1)); SC(IMMU(1));

/** 1001 1000			mov	%0, %1				*/
  ID(mov); DM(SP, IMMU(1)); SR(A);

/** 1000 1111			mov	%0, %e!1			*/
  ID(mov); DR(A); SM(None, IMMU(2));

/** 1000 1001			mov	%0, %e1				*/
  ID(mov); DR(A); SM(DE, 0);

/** 1000 1010			mov	%0, %e1				*/
  ID(mov); DR(A); SM(DE, IMMU(1));

/** 1000 1011			mov	%0, %e1				*/
  ID(mov); DR(A); SM(HL, 0);

/** 1000 1100			mov	%0, %e1				*/
  ID(mov); DR(A); SM(HL, IMMU(1));

/** 0110 0001 1100 1001		mov	%0, %e1				*/
  ID(mov); DR(A); SM2(HL, B, 0);

/** 0110 0001 1110 1001		mov	%0, %e1				*/
  ID(mov); DR(A); SM2(HL, C, 0);

/** 1000 1000			mov	%0, %e1				*/
  ID(mov); DR(A); SM(SP, IMMU(1));

/** 0101 0reg			mov	%0, #%1				*/
  ID(mov); DRB(reg); SC(IMMU(1));

/** 0110 0rba			mov	%0, %1				*/
  ID(mov); DR(A); SRB(rba);

/** 1000 1110 1111 1101		mov	%0, %1				*/
  ID(mov); DR(A); SR(ES);

/** 0000 1001			mov	%0, %e1				*/
  ID(mov); DR(A); SM(B, IMMU(2));

/** 0100 1001			mov	%0, %e1				*/
  ID(mov); DR(A); SM(BC, IMMU(2));

/** 0010 1001			mov	%0, %e1				*/
  ID(mov); DR(A); SM(C, IMMU(2));

/** 1000 1110			mov	%0, %s1				*/
  ID(mov); DR(A); SM(None, SFR);

/** 1000 1101			mov	%0, %1				*/
  ID(mov); DR(A); SM(None, SADDR);

/** 1110 1001			mov	%0, %e!1			*/
  ID(mov); DR(B); SM(None, IMMU(2));

/** 0111 0rba			mov	%0, %1				*/
  ID(mov); DRB(rba); SR(A);

/** 1110 1000			mov	%0, %1				*/
  ID(mov); DR(B); SM(None, SADDR);

/** 1111 1001			mov	%0, %e!1			*/
  ID(mov); DR(C); SM(None, IMMU(2));

/** 1111 1000			mov	%0, %1				*/
  ID(mov); DR(C); SM(None, SADDR);

/** 1101 1001			mov	%0, %e!1			*/
  ID(mov); DR(X); SM(None, IMMU(2));

/** 1101 1000			mov	%0, %1				*/
  ID(mov); DR(X); SM(None, SADDR);

/** 1001 1110 1111 1100		mov	%0, %1				*/
  ID(mov); DR(CS); SR(A);

/** 0100 0001			mov	%0, #%1				*/
  ID(mov); DR(ES); SC(IMMU(1));	

/** 1001 1110 1111 1101		mov	%0, %1				*/
  ID(mov); DR(ES); SR(A);	

/** 0110 0001 1011 1000		mov	%0, %1				*/
  ID(mov); DR(ES); SM(None, SADDR);	

/** 0001 1001			mov	%e0, #%1			*/
  ID(mov); DM(B, IMMU(2)); SC(IMMU(1));	

/** 0001 1000			mov	%e0, %1				*/
  ID(mov); DM(B, IMMU(2)); SR(A);	

/** 0011 1001			mov	%e0, #%1			*/
  ID(mov); DM(BC, IMMU(2)); SC(IMMU(1));	

/** 0100 1000			mov	%e0, %1				*/
  ID(mov); DM(BC, IMMU(2)); SR(A);	

/** 0011 1000			mov	%e0, #%1			*/
  ID(mov); DM(C, IMMU(2)); SC(IMMU(1));	

/** 0010 1000			mov	%e0, %1				*/
  ID(mov); DM(C, IMMU(2)); SR(A);

/** 1100 1101			mov	%0, #%1				*/
  ID(mov); DM(None, SADDR); SC(IMMU(1));

/** 1001 1101			mov	%0, %1				*/
  ID(mov); DM(None, SADDR); SR(A);

/** 1100 1110			mov	%s0, #%1			*/
  op0 = SFR;
  op1 = IMMU(1);
  ID(mov); DM(None, op0); SC(op1);
  if (op0 == 0xffffb)
    switch (op1)
      {
      case 0x01:
	rl78->syntax = "mulhu"; ID(mulhu);
	break;
      case 0x02:
	rl78->syntax = "mulh"; ID(mulh);
	break;
      case 0x03:
	rl78->syntax = "divhu"; ID(divhu);
	break;
      case 0x04:
	rl78->syntax = "divwu <old-encoding>"; ID(divwu);
	break;
      case 0x05:
	rl78->syntax = "machu"; ID(machu);
	break;
      case 0x06:
	rl78->syntax = "mach"; ID(mach);
	break;
      case 0x0b:
	rl78->syntax = "divwu"; ID(divwu);
	break;
      }

/** 1001 1110			mov	%0, %1				*/
  ID(mov); DM(None, SFR); SR(A);

/*----------------------------------------------------------------------*/

/** 0111 0001 1bit 0001		mov1	%e0, cy				*/
  ID(mov); DM(HL, 0); DB(bit); SCY();

/** 0111 0001 1bit 1001		mov1	%e0, cy				*/
  ID(mov); DR(A); DB(bit); SCY();

/** 0111 0001 1bit 0100		mov1	cy, %e1				*/
  ID(mov); DCY(); SM(HL, 0); SB(bit);

/** 0111 0001 1bit 1100		mov1	cy, %e1				*/
  ID(mov); DCY(); SR(A); SB(bit);

/** 0111 0001 0bit 0100		mov1	cy, %1				*/
  ID(mov); DCY(); SM(None, SADDR); SB(bit);

/** 0111 0001 0bit 1100		mov1	cy, %s1				*/
  ID(mov); DCY(); SM(None, SFR); SB(bit);

/** 0111 0001 0bit 0001		mov1	%0, cy				*/
  ID(mov); DM(None, SADDR); DB(bit); SCY();

/** 0111 0001 0bit 1001		mov1	%s0, cy				*/
  ID(mov); DM(None, SFR); DB(bit); SCY();

/*----------------------------------------------------------------------*/

/** 0110 0001 1100 1110		movs	%e0, %1				*/
  ID(mov); DM(HL, IMMU(1)); SR(X); Fzc;

/*----------------------------------------------------------------------*/

/** 1011 1111			movw	%e!0, %1			*/
  ID(mov); W(); DM(None, IMMU(2)); SR(AX);

/** 1011 1001			movw	%e0, %1				*/
  ID(mov); W(); DM(DE, 0); SR(AX);

/** 1011 1010			movw	%e0, %1				*/
  ID(mov); W(); DM(DE, IMMU(1)); SR(AX);

/** 1011 1011			movw	%e0, %1				*/
  ID(mov); W(); DM(HL, 0); SR(AX);

/** 1011 1100			movw	%e0, %1				*/
  ID(mov); W(); DM(HL, IMMU(1)); SR(AX);

/** 1011 1000			movw	%0, %1				*/
  ID(mov); W(); DM(SP, IMMU(1)); SR(AX);

/** 1010 1111			movw	%0, %e!1			*/
  ID(mov); W(); DR(AX); SM(None, IMMU(2));


/** 1010 1001			movw	%0, %e1				*/
  ID(mov); W(); DR(AX); SM(DE, 0);

/** 1010 1010			movw	%0, %e1				*/
  ID(mov); W(); DR(AX); SM(DE, IMMU(1));

/** 1010 1011			movw	%0, %e1				*/
  ID(mov); W(); DR(AX); SM(HL, 0);

/** 1010 1100			movw	%0, %e1				*/
  ID(mov); W(); DR(AX); SM(HL, IMMU(1));

/** 1010 1000			movw	%0, %1				*/
  ID(mov); W(); DR(AX); SM(SP, IMMU(1));

/** 0011 0rg0			movw	%0, #%1				*/
  ID(mov); W(); DRW(rg); SC(IMMU(2));

/** 0001 0ra1			movw	%0, %1				*/
  ID(mov); W(); DR(AX); SRW(ra);

/** 0001 0ra0			movw	%0, %1				*/
  ID(mov); W(); DRW(ra); SR(AX);

/** 0101 1001			movw	%0, %e1				*/
  ID(mov); W(); DR(AX); SM(B, IMMU(2));

/** 0110 1001			movw	%0, %e1				*/
  ID(mov); W(); DR(AX); SM(C, IMMU(2));

/** 0111 1001			movw	%0, %e1				*/
  ID(mov); W(); DR(AX); SM(BC, IMMU(2));

/** 0101 1000			movw	%e0, %1				*/
  ID(mov); W(); DM(B, IMMU(2)); SR(AX);

/** 0110 1000			movw	%e0, %1				*/
  ID(mov); W(); DM(C, IMMU(2)); SR(AX);

/** 0111 1000			movw	%e0, %1				*/
  ID(mov); W(); DM(BC, IMMU(2)); SR(AX);

/** 1010 1101			movw	%0, %1				*/
  ID(mov); W(); DR(AX); SM(None, SADDR);

/** 1010 1110			movw	%0, %s1				*/
  ID(mov); W(); DR(AX); SM(None, SFR);

/** 11ra 1011			movw	%0, %e!1			*/
  ID(mov); W(); DRW(ra); SM(None, IMMU(2));

/** 11ra 1010			movw	%0, %1				*/
  ID(mov); W(); DRW(ra); SM(None, SADDR);

/** 1100 1001			movw	%0, #%1				*/
  ID(mov); W(); DM(None, SADDR); SC(IMMU(2));

/** 1011 1101			movw	%0, %1				*/
  ID(mov); W(); DM(None, SADDR); SR(AX);

/** 1100 1011			movw	%0, #%1				*/
  ID(mov); W(); DM(None, SFR); SC(IMMU(2));

/** 1011 1110			movw	%0, %1				*/
  ID(mov); W(); DM(None, SFR); SR(AX);

/*----------------------------------------------------------------------*/

/** 1101 0110			mulu	x				*/
  ID(mulu);

/*----------------------------------------------------------------------*/

/** 0000 0000			nop					*/
  ID(nop);

/*----------------------------------------------------------------------*/

/** 0111 0001 1100 0000		not1	cy				*/
  ID(xor); DCY(); SC(1);

/*----------------------------------------------------------------------*/

/** 1110 0101			oneb	%e!0				*/
  ID(mov); DM(None, IMMU(2)); SC(1);

/** 1110 00rg			oneb	%0				*/
  ID(mov); DRB(rg); SC(1);

/** 1110 0100			oneb	%0				*/
  ID(mov); DM(None, SADDR); SC(1);

/*----------------------------------------------------------------------*/

/** 1110 0110			onew	%0				*/
  ID(mov); DR(AX); SC(1);

/** 1110 0111			onew	%0				*/
  ID(mov); DR(BC); SC(1);

/*----------------------------------------------------------------------*/

/** 0110 1111			or	%0, %e!1			*/
  ID(or); DR(A); SM(None, IMMU(2)); Fz;

/** 0110 1101			or	%0, %e1				*/
  ID(or); DR(A); SM(HL, 0); Fz;

/** 0110 0001 1110 0000		or	%0, %e1				*/
  ID(or); DR(A); SM2(HL, B, 0); Fz;

/** 0110 1110			or	%0, %e1				*/
  ID(or); DR(A); SM(HL, IMMU(1)); Fz;

/** 0110 0001 1110 0010		or	%0, %e1				*/
  ID(or); DR(A); SM2(HL, C, 0); Fz;

/** 0110 1100	       		or	%0, #%1				*/
  ID(or); DR(A); SC(IMMU(1)); Fz;

/** 0110 0001 0110 1rba		or	%0, %1				*/
  ID(or); DR(A); SRB(rba); Fz;

/** 0110 0001 0110 0reg		or	%0, %1				*/
  ID(or); DRB(reg); SR(A); Fz;

/** 0110 1011	       		or	%0, %1				*/
  ID(or); DR(A); SM(None, SADDR); Fz;

/** 0110 1010	       		or	%0, #%1				*/
  ID(or); DM(None, SADDR); SC(IMMU(1)); Fz;

/*----------------------------------------------------------------------*/

/** 0111 0001 1bit 0110		or1	cy, %e1				*/
  ID(or); DCY(); SM(HL, 0); SB(bit);

/** 0111 0001 1bit 1110		or1	cy, %1				*/
  ID(or); DCY(); SR(A); SB(bit);

/** 0111 0001 0bit 1110		or1	cy, %s1				*/
  ID(or); DCY(); SM(None, SFR); SB(bit);

/** 0111 0001 0bit 0110		or1	cy, %s1				*/
  ID(or); DCY(); SM(None, SADDR); SB(bit);

/*----------------------------------------------------------------------*/

/** 1100 0rg0			pop	%0				*/
  ID(mov); W(); DRW(rg); SPOP();

/** 0110 0001 1100 1101		pop	%s0				*/
  ID(mov); W(); DR(PSW); SPOP();

/*----------------------------------------------------------------------*/

/** 1100 0rg1			push	%1				*/
  ID(mov); W(); DPUSH(); SRW(rg);

/** 0110 0001 1101 1101		push	%s1				*/
  ID(mov); W(); DPUSH(); SR(PSW);

/*----------------------------------------------------------------------*/

/** 1101 0111			ret					*/
  ID(ret);

/** 0110 0001 1111 1100		reti					*/
  ID(reti);

/** 0110 0001 1110 1100		retb					*/
  ID(reti);

/*----------------------------------------------------------------------*/

/** 0110 0001 1110 1011		rol	%0, %1				*/
  ID(rol); DR(A); SC(1);

/** 0110 0001 1101 1100		rolc	%0, %1				*/
  ID(rolc); DR(A); SC(1);

/** 0110 0001 111r 1110		rolwc	%0, %1				*/
  ID(rolc); W(); DRW(r); SC(1);

/** 0110 0001 1101 1011		ror	%0, %1				*/
  ID(ror); DR(A); SC(1);

/** 0110 0001 1111 1011		rorc	%0, %1				*/
  ID(rorc); DR(A); SC(1);

/*----------------------------------------------------------------------*/

/* Note that the branch insns need to be listed before the shift
   ones, as "shift count of zero" means "branch insn" */

/** 0011 0001 0cnt 1011		sar	%0, %1				*/
  ID(sar); DR(A); SC(cnt);

/** 0011 0001 wcnt 1111		sarw	%0, %1				*/
  ID(sar); W(); DR(AX); SC(wcnt);

/*----------------------------------------------------------------------*/

/** 0110 0001 11rb 1111		sel	rb%1				*/
  ID(sel); SC(rb);

/*----------------------------------------------------------------------*/

/** 0111 0001 0bit 0000		set1	%e!0				*/
  ID(mov); DM(None, IMMU(2)); DB(bit); SC(1);

/** 0111 0001 1bit 0010		set1	%e0				*/
  ID(mov); DM(HL, 0); DB(bit); SC(1);

/** 0111 0001 1bit 1010		set1	%0				*/
  ID(mov); DR(A); DB(bit); SC(1);

/** 0111 0001 1000 0000		set1	cy				*/
  ID(mov); DCY(); SC(1);

/** 0111 0001 0bit 1010		set1	%s0				*/
  op0 = SFR;
  ID(mov); DM(None, op0); DB(bit); SC(1);
  if (op0 == RL78_SFR_PSW && bit == 7)
    rl78->syntax = "ei";

/** 0111 0001 0bit 0010		set1	%0				*/
  ID(mov); DM(None, SADDR); DB(bit); SC(1);

/*----------------------------------------------------------------------*/

/** 0011 0001 0cnt 1001		shl	%0, %1				*/
  ID(shl); DR(A); SC(cnt);

/** 0011 0001 0cnt 1000		shl	%0, %1				*/
  ID(shl); DR(B); SC(cnt);

/** 0011 0001 0cnt 0111		shl	%0, %1				*/
  ID(shl); DR(C); SC(cnt);

/** 0011 0001 wcnt 1101		shlw	%0, %1				*/
  ID(shl); W(); DR(AX); SC(wcnt);

/** 0011 0001 wcnt 1100		shlw	%0, %1				*/
  ID(shl); W(); DR(BC); SC(wcnt);

/*----------------------------------------------------------------------*/

/** 0011 0001 0cnt 1010		shr	%0, %1				*/
  ID(shr); DR(A); SC(cnt);

/** 0011 0001 wcnt 1110		shrw	%0, %1				*/
  ID(shr); W(); DR(AX); SC(wcnt);

/*----------------------------------------------------------------------*/

/** 0110 0001 1100 1000		sk%c1					*/
  ID(skip); COND(C);

/** 0110 0001 1110 0011		sk%c1					*/
  ID(skip); COND(H);

/** 0110 0001 1101 1000		sk%c1					*/
  ID(skip); COND(NC);

/** 0110 0001 1111 0011		sk%c1					*/
  ID(skip); COND(NH);

/** 0110 0001 1111 1000		sk%c1					*/
  ID(skip); COND(NZ);

/** 0110 0001 1110 1000		sk%c1					*/
  ID(skip); COND(Z);

/*----------------------------------------------------------------------*/

/** 0110 0001 1111 1101	stop						*/
  ID(stop);

/*----------------------------------------------------------------------*/

/** 0010 1111			sub	%0, %e!1			*/
  ID(sub); DR(A); SM(None, IMMU(2)); Fzac;

/** 0010 1101			sub	%0, %e1				*/
  ID(sub); DR(A); SM(HL, 0); Fzac;

/** 0110 0001 1010 000		sub	%0, %e1				*/
  ID(sub); DR(A); SM2(HL, B, 0); Fzac;

/** 0010 1110			sub	%0, %e1				*/
  ID(sub); DR(A); SM(HL, IMMU(1)); Fzac;

/** 0110 0001 1010 0010		sub	%0, %e1				*/
  ID(sub); DR(A); SM2(HL, C, 0); Fzac;

/** 0010 1100			sub	%0, #%1				*/
  ID(sub); DR(A); SC(IMMU(1)); Fzac;

/** 0110 0001 0010 1rba		sub	%0, %1				*/
  ID(sub); DR(A); SRB(rba); Fzac;

/** 0010 1011			sub	%0, %1				*/
  ID(sub); DR(A); SM(None, SADDR); Fzac;

/** 0110 0001 0010 0reg		sub	%0, %1				*/
  ID(sub); DRB(reg); SR(A); Fzac;

/** 0010 1010			sub	%0, #%1				*/
  ID(sub); DM(None, SADDR); SC(IMMU(1)); Fzac;

/*----------------------------------------------------------------------*/

/** 0011 1111			subc	%0, %e!1			*/
  ID(subc); DR(A); SM(None, IMMU(2)); Fzac;

/** 0011 1101			subc	%0, %e1				*/
  ID(subc); DR(A); SM(HL, 0); Fzac;

/** 0110 0001 1011 0000		subc	%0, %e1				*/
  ID(subc); DR(A); SM2(HL, B, 0); Fzac;

/** 0110 0001 1011 0010		subc	%0, %e1				*/
  ID(subc); DR(A); SM2(HL, C, 0); Fzac;

/** 0011 1110			subc	%0, %e1				*/
  ID(subc); DR(A); SM(HL, IMMU(1)); Fzac;

/** 0011 1100			subc	%0, #%1				*/
  ID(subc); DR(A); SC(IMMU(1)); Fzac;

/** 0110 0001 0011 1rba		subc	%0, %1				*/
  ID(subc); DR(A); SRB(rba); Fzac;

/** 0110 0001 0011 0reg		subc	%0, %1				*/
  ID(subc); DRB(reg); SR(A); Fzac;

/** 0011 1011			subc	%0, %1				*/
  ID(subc); DR(A); SM(None, SADDR); Fzac;

/** 0011 1010			subc	%0, #%1				*/
  ID(subc); DM(None, SADDR); SC(IMMU(1)); Fzac;

/*----------------------------------------------------------------------*/

/** 0010 0010			subw	%0, %e!1			*/
  ID(sub); W(); DR(AX); SM(None, IMMU(2)); Fzac;

/** 0110 0001 0010 1001		subw	%0, %e1				*/
  ID(sub); W(); DR(AX); SM(HL, IMMU(1)); Fzac;

/** 0010 0100			subw	%0, #%1				*/
  ID(sub); W(); DR(AX); SC(IMMU(2)); Fzac;

/** 0010 0rw1			subw	%0, %1				*/
  ID(sub); W(); DR(AX); SRW(rw); Fzac;

/** 0010 0110			subw	%0, %1				*/
  ID(sub); W(); DR(AX); SM(None, SADDR); Fzac;

/** 0010 0000			subw	%0, #%1				*/
  ID(sub); W(); DR(SP); SC(IMMU(1)); Fzac;

/*----------------------------------------------------------------------*/

/** 0110 0001 1010 1010		xch	%0, %e!1			*/
  ID(xch); DR(A); SM(None, IMMU(2));

/** 0110 0001 1010 1110		xch	%0, %e1				*/
  ID(xch); DR(A); SM(DE, 0);

/** 0110 0001 1010 1111		xch	%0, %e1				*/
  ID(xch); DR(A); SM(DE, IMMU(1));

/** 0110 0001 1010 1100		xch	%0, %e1				*/
  ID(xch); DR(A); SM(HL, 0);

/** 0110 0001 1011 1001		xch	%0, %e1				*/
  ID(xch); DR(A); SM2(HL, B, 0);

/** 0110 0001 1010 1101		xch	%0, %e1				*/
  ID(xch); DR(A); SM(HL, IMMU(1));

/** 0110 0001 1010 1001		xch	%0, %e1				*/
  ID(xch); DR(A); SM2(HL, C, 0);

/** 0110 0001 1000 1reg		xch	%0, %1				*/
  /* Note: DECW uses reg == X, so this must follow DECW */
  ID(xch); DR(A); SRB(reg);

/** 0110 0001 1010 1000	       	xch	%0, %1				*/
  ID(xch); DR(A); SM(None, SADDR);

/** 0110 0001 1010 1011	       	xch	%0, %1				*/
  ID(xch); DR(A); SM(None, SFR);

/** 0000 1000			xch	a, x				*/
  ID(xch); DR(A); SR(X);

/*----------------------------------------------------------------------*/

/** 0011 0ra1			xchw	%0, %1				*/
  ID(xch); W(); DR(AX); SRW(ra);

/*----------------------------------------------------------------------*/

/** 0111 1111			xor	%0, %e!1			*/
  ID(xor); DR(A); SM(None, IMMU(2)); Fz;

/** 0111 1101			xor	%0, %e1				*/
  ID(xor); DR(A); SM(HL, 0); Fz;

/** 0110 0001 1111 0000		xor	%0, %e1				*/
  ID(xor); DR(A); SM2(HL, B, 0); Fz;

/** 0111 1110			xor	%0, %e1				*/
  ID(xor); DR(A); SM(HL, IMMU(1)); Fz;

/** 0110 0001 1111 0010		xor	%0, %e1				*/
  ID(xor); DR(A); SM2(HL, C, 0); Fz;

/** 0111 1100	       		xor	%0, #%1				*/
  ID(xor); DR(A); SC(IMMU(1)); Fz;

/** 0110 0001 0111 1rba		xor	%0, %1				*/
  ID(xor); DR(A); SRB(rba); Fz;

/** 0110 0001 0111 0reg		xor	%0, %1				*/
  ID(xor); DRB(reg); SR(A); Fz;

/** 0111 1011	       		xor	%0, %1				*/
  ID(xor); DR(A); SM(None, SADDR); Fz;

/** 0111 1010	       		xor	%0, #%1				*/
  ID(xor); DM(None, SADDR); SC(IMMU(1)); Fz;

/*----------------------------------------------------------------------*/

/** 0111 0001 1bit 0111		xor1	cy, %e1				*/
  ID(xor); DCY(); SM(HL, 0); SB(bit);

/** 0111 0001 1bit 1111		xor1	cy, %1				*/
  ID(xor); DCY(); SR(A); SB(bit);

/** 0111 0001 0bit 1111		xor1	cy, %s1				*/
  ID(xor); DCY(); SM(None, SFR); SB(bit);

/** 0111 0001 0bit 0111		xor1	cy, %s1				*/
  ID(xor); DCY(); SM(None, SADDR); SB(bit);

/*----------------------------------------------------------------------*/

/** */

  return rl78->n_bytes;
}
@


1.6
log
@	* rl78-decode.opc: Fix encoding of DIVWU insn.
	* rl78-decode.c: Regenerate.

	* config/rl78-parse.y: Fix encoding of DIVWU insn.
@
text
@d765 1
a765 1
	rl78->syntax = "divwu <old-encoding>" ID(divwu);
@


1.5
log
@Add copyright notices
@
text
@d2 1
a2 1
/* Copyright 2012 Free Software Foundation, Inc.
d765 1
a765 1
	rl78->syntax = "divwu"; ID(divwu);
d773 3
@


1.4
log
@* rl78-decode.opc (rl78_decode_opcode): Merge %e and %[01]
operands, so that data addresses can be corrected when not
ES-overridden.
* rl78-decode.c: Regenerate.
* rl78-dis.c (print_insn_rl78): Make order of modifiers
irrelevent.  When the 'e' specifier is used on an operand and no
ES prefix is provided, adjust address to make it absolute.
@
text
@d2 21
@


1.3
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d178 1
a178 1
/** 0000 1111			add	%0, %e1%!1			*/
d181 1
a181 1
/** 0000 1101			add	%0, %e1%1			*/
d184 1
a184 1
/** 0110 0001 1000 000		add	%0, %e1%1			*/
d187 1
a187 1
/** 0000 1110			add	%0, %e1%1			*/
d189 2
a190 2

/** 0110 0001 1000 0010		add	%0, %e1%1			*/
d210 1
a210 1
/** 0001 1111			addc	%0, %e1%!1			*/
d213 1
a213 1
/** 0001 1101			addc	%0, %e1%1			*/
d216 1
a216 1
/** 0110 0001 1001 0000		addc	%0, %e1%1			*/
d219 1
a219 1
/** 0110 0001 1001 0010		addc	%0, %e1%1			*/
d222 1
a222 1
/** 0001 1110			addc	%0, %e1%1			*/
d242 1
a242 1
/** 0000 0010			addw	%0, %e1%!1			*/
d245 1
a245 1
/** 0110 0001 0000 1001		addw	%0, %e1%1			*/
d262 1
a262 1
/** 0101 1111			and	%0, %e1%!1			*/
d265 1
a265 1
/** 0101 1101			and	%0, %e1%1			*/
d268 1
a268 1
/** 0110 0001 1101 0000		and	%0, %e1%1			*/
d271 1
a271 1
/** 0101 1110			and	%0, %e1%1			*/
d274 1
a274 1
/** 0110 0001 1101 0010		and	%0, %e1%1			*/
d294 1
a294 1
/** 0111 0001 1bit 0101		and1	cy, %e1%1			*/
d331 1
a331 1
/** 0011 0001 1bit 0101		bf	%e1%1, $%a0			*/
d370 1
a370 1
/** 0011 0001 1bit 0011		bt	%e1%1, $%a0			*/
d384 1
a384 1
/** 0011 0001 1bit 0001		btclr	%e1%1, $%a0			*/
d415 1
a415 1
/** 0111 0001 0bit 1000		clr1	%e0%!0				*/
d418 1
a418 1
/** 0111 0001 1bit 0011		clr1	%e0%0				*/
d438 1
a438 1
/** 1111 0101			clrb	%e0%!0				*/
d457 1
a457 1
/** 0100 0000			cmp	%e0%!0, #%1			*/
d463 1
a463 1
/** 0100 1111			cmp	%0, %e1%!1			*/
d466 1
a466 1
/** 0100 1101			cmp	%0, %e1%1			*/
d469 1
a469 1
/** 0110 0001 1100 0000		cmp	%0, %e1%1			*/
d472 1
a472 1
/** 0110 0001 1100 0010		cmp	%0, %e1%1			*/
d475 1
a475 1
/** 0100 1110			cmp	%0, %e1%1			*/
d492 1
a492 1
/** 1101 0101			cmp0	%e0%!0				*/
d503 1
a503 1
/** 0110 0001 1101 1110		cmps	%0, %e1%1			*/
d508 1
a508 1
/** 0100 0010			cmpw	%0, %e1%!1			*/
d511 1
a511 1
/** 0110 0001 0100 1001		cmpw	%0, %e1%1			*/
d525 1
a525 1
/** 1011 0000			dec	%e0%!0				*/
d528 1
a528 1
/** 0110 0001 0110 1001		dec	%e0%0				*/
d539 1
a539 1
/** 1011 0010			decw	%e0%!0				*/
d542 1
a542 1
/** 0110 0001 1000 1001		decw	%e0%0				*/
d558 1
a558 1
/** 1010 0000			inc	%e0%!0				*/
d561 1
a561 1
/** 0110 0001 0101 1001		inc	%e0%0				*/
d572 1
a572 1
/** 1010 0010			incw	%e0%!0				*/
d575 1
a575 1
/** 0110 0001 0111 1001		incw	%e0%0				*/
d586 1
a586 1
/** 1100 1111			mov	%e0%!0, #%1			*/
d589 1
a589 1
/** 1001 1111			mov	%e0%!0, %1			*/
d592 1
a592 1
/** 1001 1001			mov	%e0%0,%1			*/
d595 1
a595 1
/** 1100 1010			mov	%e0%0, #%1			*/
d598 1
a598 1
/** 1001 1010			mov	%e0%0, %1			*/
d601 1
a601 1
/** 1001 1011			mov	%e0%0,%1			*/
d604 1
a604 1
/** 0110 0001 1101 1001		mov	%e0%0, %1			*/
d607 1
a607 1
/** 1100 1100			mov	%e0%0, #%1			*/
d610 1
a610 1
/** 1001 1100			mov	%e0%0, %1			*/
d613 1
a613 1
/** 0110 0001 1111 1001		mov	%e0%0, %1			*/
d622 1
a622 1
/** 1000 1111			mov	%0, %e1%!1			*/
d625 1
a625 1
/** 1000 1001			mov	%0, %e1%1			*/
d628 1
a628 1
/** 1000 1010			mov	%0, %e1%1			*/
d631 1
a631 1
/** 1000 1011			mov	%0, %e1%1			*/
d634 1
a634 1
/** 1000 1100			mov	%0, %e1%1			*/
d637 1
a637 1
/** 0110 0001 1100 1001		mov	%0, %e1%1			*/
d640 1
a640 1
/** 0110 0001 1110 1001		mov	%0, %e1%1			*/
d643 1
a643 1
/** 1000 1000			mov	%0, %e1%1			*/
d655 1
a655 1
/** 0000 1001			mov	%0, %e1%1			*/
d658 1
a658 1
/** 0100 1001			mov	%0, %e1%1			*/
d661 1
a661 1
/** 0010 1001			mov	%0, %e1%1			*/
d670 1
a670 1
/** 1110 1001			mov	%0, %e1%!1			*/
d679 1
a679 1
/** 1111 1001			mov	%0, %e1%!1			*/
d685 1
a685 1
/** 1101 1001			mov	%0, %e1%!1			*/
d703 1
a703 1
/** 0001 1001			mov	%e0%0, #%1			*/
d706 1
a706 1
/** 0001 1000			mov	%e0%0, %1			*/
d709 1
a709 1
/** 0011 1001			mov	%e0%0, #%1			*/
d712 1
a712 1
/** 0100 1000			mov	%e0%0, %1			*/
d715 1
a715 1
/** 0011 1000			mov	%e0%0, #%1			*/
d718 1
a718 1
/** 0010 1000			mov	%e0%0, %1			*/
d759 1
a759 1
/** 0111 0001 1bit 0001		mov1	%e0%0, cy			*/
d762 1
a762 1
/** 0111 0001 1bit 1001		mov1	%e0%0, cy			*/
d765 1
a765 1
/** 0111 0001 1bit 0100		mov1	cy, %e1%1			*/
d768 1
a768 1
/** 0111 0001 1bit 1100		mov1	cy, %e1%1			*/
d785 1
a785 1
/** 0110 0001 1100 1110		movs	%e0%0, %1			*/
d790 1
a790 1
/** 1011 1111			movw	%e0%!0, %1			*/
d793 1
a793 1
/** 1011 1001			movw	%e0%0, %1			*/
d796 1
a796 1
/** 1011 1010			movw	%e0%0, %1			*/
d799 1
a799 1
/** 1011 1011			movw	%e0%0, %1			*/
d802 1
a802 1
/** 1011 1100			movw	%e0%0, %1			*/
d808 1
a808 1
/** 1010 1111			movw	%0, %e1%!1			*/
d812 1
a812 1
/** 1010 1001			movw	%0, %e1%1			*/
d815 1
a815 1
/** 1010 1010			movw	%0, %e1%1			*/
d818 1
a818 1
/** 1010 1011			movw	%0, %e1%1			*/
d821 1
a821 1
/** 1010 1100			movw	%0, %e1%1			*/
d836 1
a836 1
/** 0101 1001			movw	%0, %e1%1			*/
d839 1
a839 1
/** 0110 1001			movw	%0, %e1%1			*/
d842 1
a842 1
/** 0111 1001			movw	%0, %e1%1			*/
d845 1
a845 1
/** 0101 1000			movw	%e0%0, %1			*/
d848 1
a848 1
/** 0110 1000			movw	%e0%0, %1			*/
d851 1
a851 1
/** 0111 1000			movw	%e0%0, %1			*/
d860 1
a860 1
/** 11ra 1011			movw	%0, %e1%!1			*/
d895 1
a895 1
/** 1110 0101			oneb	%e0%!0				*/
d914 1
a914 1
/** 0110 1111			or	%0, %e1%!1			*/
d917 1
a917 1
/** 0110 1101			or	%0, %e1%1			*/
d920 1
a920 1
/** 0110 0001 1110 0000		or	%0, %e1%1			*/
d923 1
a923 1
/** 0110 1110			or	%0, %e1%1			*/
d926 1
a926 1
/** 0110 0001 1110 0010		or	%0, %e1%1			*/
d946 1
a946 1
/** 0111 0001 1bit 0110		or1	cy, %e1%1			*/
d1020 1
a1020 1
/** 0111 0001 0bit 0000		set1	%e0%!0				*/
d1023 1
a1023 1
/** 0111 0001 1bit 0010		set1	%e0%0				*/
d1088 1
a1088 1
/** 0110 0001 1111 1101	stop					*/
d1093 1
a1093 1
/** 0010 1111			sub	%0, %e1%!1			*/
d1096 1
a1096 1
/** 0010 1101			sub	%0, %e1%1			*/
d1099 1
a1099 1
/** 0110 0001 1010 000		sub	%0, %e1%1			*/
d1102 1
a1102 1
/** 0010 1110			sub	%0, %e1%1			*/
d1105 1
a1105 1
/** 0110 0001 1010 0010		sub	%0, %e1%1			*/
d1125 1
a1125 1
/** 0011 1111			subc	%0, %e1%!1			*/
d1128 1
a1128 1
/** 0011 1101			subc	%0, %e1%1			*/
d1131 1
a1131 1
/** 0110 0001 1011 0000		subc	%0, %e1%1			*/
d1134 1
a1134 1
/** 0110 0001 1011 0010		subc	%0, %e1%1			*/
d1137 1
a1137 1
/** 0011 1110			subc	%0, %e1%1			*/
d1157 1
a1157 1
/** 0010 0010			subw	%0, %e1%!1			*/
d1160 1
a1160 1
/** 0110 0001 0010 1001		subw	%0, %e1%1			*/
d1177 1
a1177 1
/** 0110 0001 1010 1010		xch	%0, %e1%!1			*/
d1180 1
a1180 1
/** 0110 0001 1010 1110		xch	%0, %e1%1			*/
d1183 1
a1183 1
/** 0110 0001 1010 1111		xch	%0, %e1%1			*/
d1186 1
a1186 1
/** 0110 0001 1010 1100		xch	%0, %e1%1			*/
d1189 1
a1189 1
/** 0110 0001 1011 1001		xch	%0, %e1%1			*/
d1192 1
a1192 1
/** 0110 0001 1010 1101		xch	%0, %e1%1			*/
d1195 1
a1195 1
/** 0110 0001 1010 1001		xch	%0, %e1%1			*/
d1218 1
a1218 1
/** 0111 1111			xor	%0, %e1%!1			*/
d1221 1
a1221 1
/** 0111 1101			xor	%0, %e1%1			*/
d1224 1
a1224 1
/** 0110 0001 1111 0000		xor	%0, %e1%1			*/
d1227 1
a1227 1
/** 0111 1110			xor	%0, %e1%1			*/
d1230 1
a1230 1
/** 0110 0001 1111 0010		xor	%0, %e1%1			*/
d1250 1
a1250 1
/** 0111 0001 1bit 0111		xor1	cy, %e1%1			*/
@


1.2
log
@* rl78-decode.opc (rl78_decode_opcode): Add NOT1.
* rl78-decode.c: Regenerate.

* config/rl78-parse.y (NOT1): Add.
@
text
@d2 1
a5 2

#include "config.h"
@


1.1
log
@[.]
	* configure.ac (rl78-*-*) New case.
	* configure: Regenerate.

[bfd]
	* Makefile.am (ALL_MACHINES): Add cpu-rl78.lo.
	(ALL_MACHINES_CFILES): Add cpu-rl78.c.
	(BFD32_BACKENDS): Add elf32-rl78.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-rl78.c.
	(Makefile.in): Regenerate.
	* archures.c (bfd_architecture): Define bfd_arch_rl78.
	(bfd_archures_list): Add bfd_rl78_arch.
	* config.bfd: Add rl78-*-elf.
	* configure.in: Add bfd_elf32_rl78_vec.
	* reloc.c (bfd_reloc_code_type): Add BFD_RELOC_RL78_* relocations.
	* targets.c (bfd_target_vector): Add bfd_elf32_rl78_vec.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.
	* libbfd.h: Regenerate.
	* cpu-rl78.c: New file.
	* elf32-rl78.c: New file.

[binutils]
	* readelf.c: Include elf/rl78.h
	(guess_is_rela): Handle EM_RL78.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.
	(is_32bit_abs_reloc): Likewise.
	* NEWS: Mention addition of RL78 support.
	* MAINTAINERS: Add myself as RL78 port maintainer.

[gas]
	* Makefile.am (TARGET_CPU_CFILES): Add tc-rl78.c.
	(TARGET_CPU_HFILES): Add rc-rl78.h.
	(EXTRA_DIST): Add rl78-parse.c and rl78-parse.y.
	(rl78-parse.c, rl78-parse.h, rl78-parse.o, rl78-defs.h): New rules.
	* Makefile.in: Regenerate.
	* configure.in: Add rl78 case.
	* configure: Regenerate.
	* configure.tgt: Add rl78 case.
	* config/rl78-defs.h: New file.
	* config/rl78-parse.y: New file.
	* config/tc-rl78.c: New file.
	* config/tc-rl78.h: New file.
	* NEWS: Add Renesas RL78.

	* doc/Makefile.am (c-rl78.texi): New.
	* doc/Makefile.in: Likewise.
	* doc/all.texi: Enable it.
	* doc/as.texi: Add it.

[include]
	* dis-asm.h (print_insn_rl78): Declare.

[include/elf]
	* common.h (EM_RL78, EM_78K0R): New.
	* rl78.h: New.

[include/opcode]
	* rl78.h: New file.

[ld]
	* Makefile.am (ALL_EMULATION_SOURCES): Add eelf32rl78.c.
	(+eelf32rl78.c): New rule.
	* Makefile.in: Regenerate.
	* configure.tgt: Add rl78-*-* case.
	* emulparams/elf32rl78.sh: New file.
	* NEWS: Mention addition of Renesas RL78 support.

[opcodes]
	* Makefile.am (TARGET_LIBOPCODES_CFILES): Add rl78-decode.c and
	rl78-dis.c.
	(MAINTAINERCLEANFILES): Add rl78-decode.c.
	(rl78-decode.c): New rule, built from rl78-decode.opc and opc2c.
	* Makefile.in: Regenerate.
	* configure.in: Add bfd_rl78_arch case.
	* configure: Regenerate.
	* disassemble.c: Define ARCH_rl78.
	(disassembler): Add ARCH_rl78 case.
	* rl78-decode.c: New file.
	* rl78-decode.opc: New file.
	* rl78-dis.c: New file.
@
text
@d891 5
@

