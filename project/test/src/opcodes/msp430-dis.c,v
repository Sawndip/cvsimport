head	1.10;
access;
symbols
	sid-snapshot-20180601:1.10
	sid-snapshot-20180501:1.10
	sid-snapshot-20180401:1.10
	sid-snapshot-20180301:1.10
	sid-snapshot-20180201:1.10
	sid-snapshot-20180101:1.10
	sid-snapshot-20171201:1.10
	sid-snapshot-20171101:1.10
	sid-snapshot-20171001:1.10
	sid-snapshot-20170901:1.10
	sid-snapshot-20170801:1.10
	sid-snapshot-20170701:1.10
	sid-snapshot-20170601:1.10
	sid-snapshot-20170501:1.10
	sid-snapshot-20170401:1.10
	sid-snapshot-20170301:1.10
	sid-snapshot-20170201:1.10
	sid-snapshot-20170101:1.10
	sid-snapshot-20161201:1.10
	sid-snapshot-20161101:1.10
	sid-snapshot-20160901:1.10
	sid-snapshot-20160801:1.10
	sid-snapshot-20160701:1.10
	sid-snapshot-20160601:1.10
	sid-snapshot-20160501:1.10
	sid-snapshot-20160401:1.10
	sid-snapshot-20160301:1.10
	sid-snapshot-20160201:1.10
	sid-snapshot-20160101:1.10
	sid-snapshot-20151201:1.10
	sid-snapshot-20151101:1.10
	sid-snapshot-20151001:1.10
	sid-snapshot-20150901:1.10
	sid-snapshot-20150801:1.10
	sid-snapshot-20150701:1.10
	sid-snapshot-20150601:1.10
	sid-snapshot-20150501:1.10
	sid-snapshot-20150401:1.10
	sid-snapshot-20150301:1.10
	sid-snapshot-20150201:1.10
	sid-snapshot-20150101:1.10
	sid-snapshot-20141201:1.10
	sid-snapshot-20141101:1.10
	sid-snapshot-20141001:1.10
	sid-snapshot-20140901:1.10
	sid-snapshot-20140801:1.10
	sid-snapshot-20140701:1.10
	sid-snapshot-20140601:1.10
	sid-snapshot-20140501:1.10
	sid-snapshot-20140401:1.10
	sid-snapshot-20140301:1.10
	sid-snapshot-20140201:1.10
	sid-snapshot-20140101:1.10
	sid-snapshot-20131201:1.10
	sid-snapshot-20131101:1.10
	sid-snapshot-20131001:1.10
	binutils-2_24-branch:1.10.0.2
	binutils-2_24-branchpoint:1.10
	binutils-2_21_1:1.7
	sid-snapshot-20130901:1.10
	gdb_7_6_1-2013-08-30-release:1.8
	sid-snapshot-20130801:1.9
	sid-snapshot-20130701:1.9
	sid-snapshot-20130601:1.9
	sid-snapshot-20130501:1.8
	gdb_7_6-2013-04-26-release:1.8
	sid-snapshot-20130401:1.8
	binutils-2_23_2:1.8
	gdb_7_6-branch:1.8.0.6
	gdb_7_6-2013-03-12-branchpoint:1.8
	sid-snapshot-20130301:1.8
	sid-snapshot-20130201:1.8
	sid-snapshot-20130101:1.8
	sid-snapshot-20121201:1.8
	gdb_7_5_1-2012-11-29-release:1.8
	binutils-2_23_1:1.8
	sid-snapshot-20121101:1.8
	binutils-2_23:1.8
	sid-snapshot-20121001:1.8
	sid-snapshot-20120901:1.8
	gdb_7_5-2012-08-17-release:1.8
	sid-snapshot-20120801:1.8
	binutils-2_23-branch:1.8.0.4
	binutils-2_23-branchpoint:1.8
	gdb_7_5-branch:1.8.0.2
	gdb_7_5-2012-07-18-branchpoint:1.8
	sid-snapshot-20120701:1.8
	sid-snapshot-20120601:1.8
	sid-snapshot-20120501:1.7
	binutils-2_22_branch:1.7.0.12
	gdb_7_4_1-2012-04-26-release:1.7
	sid-snapshot-20120401:1.7
	sid-snapshot-20120301:1.7
	sid-snapshot-20120201:1.7
	gdb_7_4-2012-01-24-release:1.7
	sid-snapshot-20120101:1.7
	gdb_7_4-branch:1.7.0.10
	gdb_7_4-2011-12-13-branchpoint:1.7
	sid-snapshot-20111201:1.7
	binutils-2_22:1.7
	sid-snapshot-20111101:1.7
	sid-snapshot-20111001:1.7
	binutils-2_22-branch:1.7.0.8
	binutils-2_22-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.7
	sid-snapshot-20110901:1.7
	sid-snapshot-20110801:1.7
	gdb_7_3-2011-07-26-release:1.7
	sid-snapshot-20110701:1.7
	sid-snapshot-20110601:1.7
	sid-snapshot-20110501:1.7
	gdb_7_3-branch:1.7.0.6
	gdb_7_3-2011-04-01-branchpoint:1.7
	sid-snapshot-20110401:1.7
	sid-snapshot-20110301:1.7
	sid-snapshot-20110201:1.7
	sid-snapshot-20110101:1.7
	binutils-2_21:1.7
	sid-snapshot-20101201:1.7
	binutils-2_21-branch:1.7.0.4
	binutils-2_21-branchpoint:1.7
	sid-snapshot-20101101:1.7
	sid-snapshot-20101001:1.7
	binutils-2_20_1:1.6
	gdb_7_2-2010-09-02-release:1.7
	sid-snapshot-20100901:1.7
	sid-snapshot-20100801:1.7
	gdb_7_2-branch:1.7.0.2
	gdb_7_2-2010-07-07-branchpoint:1.7
	sid-snapshot-20100701:1.7
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	gdb_7_1-2010-03-18-release:1.6
	sid-snapshot-20100301:1.6
	gdb_7_1-branch:1.6.0.6
	gdb_7_1-2010-02-18-branchpoint:1.6
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.6
	gdb_7_0_1-2009-12-22-release:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	binutils-2_20:1.6
	gdb_7_0-2009-10-06-release:1.6
	sid-snapshot-20091001:1.6
	gdb_7_0-branch:1.6.0.4
	gdb_7_0-2009-09-16-branchpoint:1.6
	arc-sim-20090309:1.5
	binutils-arc-20081103-branch:1.5.0.30
	binutils-arc-20081103-branchpoint:1.5
	binutils-2_20-branch:1.6.0.2
	binutils-2_20-branchpoint:1.6
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	msnyder-checkpoint-072509-branch:1.5.0.28
	msnyder-checkpoint-072509-branchpoint:1.5
	sid-snapshot-20090701:1.5
	dje-cgen-play1-branch:1.5.0.26
	dje-cgen-play1-branchpoint:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	sid-snapshot-20090401:1.5
	arc-20081103-branch:1.5.0.24
	arc-20081103-branchpoint:1.5
	arc-insight_6_8-branch:1.5.0.22
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.20
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	binutils-2_19_1:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	reverse-20081226-branch:1.5.0.18
	reverse-20081226-branchpoint:1.5
	sid-snapshot-20081201:1.5
	multiprocess-20081120-branch:1.5.0.16
	multiprocess-20081120-branchpoint:1.5
	sid-snapshot-20081101:1.5
	binutils-2_19:1.5
	sid-snapshot-20081001:1.5
	reverse-20080930-branch:1.5.0.14
	reverse-20080930-branchpoint:1.5
	binutils-2_19-branch:1.5.0.12
	binutils-2_19-branchpoint:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	reverse-20080717-branch:1.5.0.10
	reverse-20080717-branchpoint:1.5
	sid-snapshot-20080701:1.5
	msnyder-reverse-20080609-branch:1.5.0.8
	msnyder-reverse-20080609-branchpoint:1.5
	drow-reverse-20070409-branch:1.4.0.32
	drow-reverse-20070409-branchpoint:1.4
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-2008-03-27-release:1.5
	sid-snapshot-20080301:1.5
	gdb_6_8-branch:1.5.0.6
	gdb_6_8-2008-02-26-branchpoint:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	sid-snapshot-20071001:1.5
	gdb_6_7-branch:1.5.0.4
	gdb_6_7-2007-09-07-branchpoint:1.5
	binutils-2_18:1.5
	binutils-2_18-branch:1.5.0.2
	binutils-2_18-branchpoint:1.5
	insight_6_6-20070208-release:1.4
	binutils-csl-coldfire-4_1-32:1.4
	binutils-csl-sourcerygxx-4_1-32:1.4
	gdb_6_6-2006-12-18-release:1.4
	binutils-csl-innovasic-fido-3_4_4-33:1.4
	binutils-csl-sourcerygxx-3_4_4-32:1.2
	binutils-csl-coldfire-4_1-30:1.4
	binutils-csl-sourcerygxx-4_1-30:1.4
	binutils-csl-coldfire-4_1-28:1.4
	binutils-csl-sourcerygxx-4_1-29:1.4
	binutils-csl-sourcerygxx-4_1-28:1.4
	gdb_6_6-branch:1.4.0.30
	gdb_6_6-2006-11-15-branchpoint:1.4
	binutils-csl-arm-2006q3-27:1.4
	binutils-csl-sourcerygxx-4_1-27:1.4
	binutils-csl-arm-2006q3-26:1.4
	binutils-csl-sourcerygxx-4_1-26:1.4
	binutils-csl-sourcerygxx-4_1-25:1.4
	binutils-csl-sourcerygxx-4_1-24:1.4
	binutils-csl-sourcerygxx-4_1-23:1.4
	insight_6_5-20061003-release:1.4
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	binutils-csl-sourcerygxx-4_1-21:1.4
	binutils-csl-arm-2006q3-21:1.4
	binutils-csl-sourcerygxx-4_1-22:1.4
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.4
	binutils-csl-sourcerygxx-4_1-20:1.4
	binutils-csl-arm-2006q3-19:1.4
	binutils-csl-sourcerygxx-4_1-19:1.4
	binutils-csl-sourcerygxx-4_1-18:1.4
	binutils-csl-renesas-4_1-9:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	binutils-csl-sourcerygxx-3_4_4-25:1.2
	nickrob-async-20060828-mergepoint:1.4
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	binutils-csl-renesas-4_1-8:1.4
	binutils-csl-renesas-4_1-7:1.4
	binutils-csl-renesas-4_1-6:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	binutils-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	binutils-csl-sourcerygxx-4_1-14:1.4
	binutils-csl-sourcerygxx-4_1-15:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	binutils-csl-sourcerygxx-4_1-13:1.4
	binutils-2_17:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	binutils-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	binutils-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.4
	binutils-csl-wrs-linux-3_4_4-24:1.2
	binutils-csl-wrs-linux-3_4_4-23:1.2
	gdb-csl-sourcerygxx-4_1-9:1.4
	binutils-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	binutils-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	binutils-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	binutils-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	binutils-csl-sourcerygxx-4_1-6:1.4
	binutils-csl-wrs-linux-3_4_4-22:1.2
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	binutils-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	binutils-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.4.0.28
	gdb_6_5-2006-05-14-branchpoint:1.4
	binutils-csl-coldfire-4_1-10:1.4
	gdb-csl-sourcerygxx-4_1-5:1.4
	binutils-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.4.0.26
	nickrob-async-20060513-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-4:1.4
	binutils-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.4.0.24
	msnyder-reverse-20060502-branchpoint:1.4
	binutils-csl-wrs-linux-3_4_4-21:1.2
	gdb-csl-morpho-4_1-4:1.4
	binutils-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	binutils-csl-sourcerygxx-3_4_4-17:1.4
	binutils-csl-wrs-linux-3_4_4-20:1.2
	readline_5_1-import-branch:1.4.0.22
	readline_5_1-import-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	binutils-2_17-branch:1.4.0.20
	binutils-2_17-branchpoint:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.18
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.16
	msnyder-reverse-20060331-branchpoint:1.4
	binutils-csl-2_17-branch:1.4.0.14
	binutils-csl-2_17-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.12
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.10
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.8
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.4
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.2
	gdb-csl-arm-20051020-branchpoint:1.4
	binutils-csl-gxxpro-3_4-branch:1.2.0.28
	binutils-csl-gxxpro-3_4-branchpoint:1.2
	binutils-2_16_1:1.2
	msnyder-tracepoint-checkpoint-branch:1.3.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb-csl-arm-20050325-2005-q1b:1.2
	binutils-csl-arm-2005q1b:1.2
	binutils-2_16:1.2
	gdb-csl-arm-20050325-2005-q1a:1.2
	binutils-csl-arm-2005q1a:1.2
	csl-arm-20050325-branch:1.2.0.26
	csl-arm-20050325-branchpoint:1.2
	binutils-csl-arm-2005q1-branch:1.2.0.24
	binutils-csl-arm-2005q1-branchpoint:1.2
	binutils-2_16-branch:1.2.0.22
	binutils-2_16-branchpoint:1.2
	csl-arm-2004-q3d:1.2
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.18
	gdb_6_3-20041019-branchpoint:1.2
	csl-arm-2004-q3:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.20
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.16
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	binutils-2_15:1.2
	binutils-2_15-branchpoint:1.2
	csl-arm-2004-q1a:1.2
	csl-arm-2004-q1:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.14
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.12
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.8
	drow_intercu-20040221-branchpoint:1.2
	binutils-2_15-branch:1.2.0.6
	cagney_bfdfile-20040213-branch:1.2.0.4
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.2
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	csl-arm-2003-q4:1.1
	drow-cplus-merge-20031224:1.1
	drow-cplus-merge-20031220:1.1
	carlton_dictionary-20031215-merge:1.1
	drow-cplus-branch:1.1.0.46
	drow-cplus-merge-20031214:1.1
	carlton-dictionary-20031111-merge:1.1
	gdb_6_0-2003-10-04-release:1.1
	kettenis_sparc-20030918-branch:1.1.0.44
	kettenis_sparc-20030918-branchpoint:1.1
	carlton_dictionary-20030917-merge:1.1
	ezannoni_pie-20030916-branchpoint:1.1
	ezannoni_pie-20030916-branch:1.1.0.42
	cagney_x86i386-20030821-branch:1.1.0.40
	cagney_x86i386-20030821-branchpoint:1.1
	carlton_dictionary-20030805-merge:1.1
	carlton_dictionary-20030627-merge:1.1
	gdb_6_0-branch:1.1.0.38
	gdb_6_0-2003-06-23-branchpoint:1.1
	jimb-ppc64-linux-20030613-branch:1.1.0.36
	jimb-ppc64-linux-20030613-branchpoint:1.1
	binutils-2_14:1.1
	cagney_convert-20030606-branch:1.1.0.34
	cagney_convert-20030606-branchpoint:1.1
	cagney_writestrings-20030508-branch:1.1.0.32
	cagney_writestrings-20030508-branchpoint:1.1
	jimb-ppc64-linux-20030528-branch:1.1.0.30
	jimb-ppc64-linux-20030528-branchpoint:1.1
	carlton_dictionary-20030523-merge:1.1
	cagney_fileio-20030521-branch:1.1.0.28
	cagney_fileio-20030521-branchpoint:1.1
	kettenis_i386newframe-20030517-mergepoint:1.1
	jimb-ppc64-linux-20030509-branch:1.1.0.26
	jimb-ppc64-linux-20030509-branchpoint:1.1
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	binutils-2_14-branch:1.1.0.24
	binutils-2_14-branchpoint:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.22
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-20030416-merge:1.1
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.20
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.18
	cagney_framebase-20030330-mergepoint:1.1
	cagney_framebase-20030326-branch:1.1.0.16
	cagney_framebase-20030326-branchpoint:1.1
	cagney_lazyid-20030317-branch:1.1.0.14
	cagney_lazyid-20030317-branchpoint:1.1
	kettenis-i386newframe-20030316-mergepoint:1.1
	offbyone-20030313-branch:1.1.0.12
	offbyone-20030313-branchpoint:1.1
	kettenis-i386newframe-20030308-branch:1.1.0.10
	kettenis-i386newframe-20030308-branchpoint:1.1
	carlton_dictionary-20030305-merge:1.1
	cagney_offbyone-20030303-branch:1.1.0.8
	cagney_offbyone-20030303-branchpoint:1.1
	carlton_dictionary-branch:1.1.0.6
	carlton_dictionary-20030207-merge:1.1
	interps-20030202-branch:1.1.0.4
	interps-20030202-branchpoint:1.1
	cagney-unwind-20030108-branch:1.1.0.2
	cagney-unwind-20030108-branchpoint:1.1
	binutils_latest_snapshot:1.10;
locks; strict;
comment	@ * @;


1.10
date	2013.08.23.07.54.19;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2013.05.02.21.06.15;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.18.01.59.38;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.27.04.07.55;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.02.07.20.30;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.01.11.16.32;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.07.07.34.30;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.02.17.26.10;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.30.19.25.13;	author nickc;	state Exp;
branches
	1.1.6.1
	1.1.46.1;
next	;

1.1.6.1
date	2003.02.07.19.18.04;	author carlton;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2004.01.26.19.11.50;	author carlton;	state Exp;
branches;
next	;

1.1.46.1
date	2003.12.14.20.28.09;	author drow;	state Exp;
branches;
next	1.1.46.2;

1.1.46.2
date	2004.01.13.16.12.22;	author drow;	state Exp;
branches;
next	;


desc
@@


1.10
log
@	PR binutils/15834
	Fix typos:
---
 bfd/bfdio.c                                  |  2 +-
 bfd/elf32-spu.c                              |  2 +-
 bfd/elfnn-aarch64.c                          |  2 +-
 binutils/od-xcoff.c                          |  2 +-
 config/tcl.m4                                |  2 +-
 gas/config/tc-ia64.c                         |  2 +-
 gas/config/tc-sparc.c                        |  2 +-
 gas/config/tc-z80.c                          | 12 ++++++------
 gas/doc/c-i386.texi                          |  6 +++---
 gas/doc/c-m32r.texi                          |  2 +-
 gas/testsuite/gas/d10v/instruction_packing.d |  2 +-
 gas/testsuite/gas/z80/atend.d                |  2 +-
 gold/object.h                                |  2 +-
 include/gdb/remote-sim.h                     |  2 +-
 include/opcode/ChangeLog                     |  2 +-
 include/opcode/i960.h                        |  2 +-
 ld/testsuite/ld-mips-elf/mips16-pic-1.inc    |  2 +-
 opcodes/aarch64-asm.c                        |  2 +-
 opcodes/aarch64-dis.c                        |  2 +-
 opcodes/msp430-dis.c                         |  2 +-
@
text
@/* Disassemble MSP430 instructions.
   Copyright (C) 2002-2013 Free Software Foundation, Inc.

   Contributed by Dmitry Diky <diwil@@mail.ru>
        
   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdio.h>
#include <ctype.h>
#include <sys/types.h>

#include "dis-asm.h"
#include "opintl.h"
#include "libiberty.h"

#define DASM_SECTION
#include "opcode/msp430.h"
#undef DASM_SECTION


#define PS(x)   (0xffff & (x))

static unsigned short
msp430dis_opcode (bfd_vma addr, disassemble_info *info)
{
  bfd_byte buffer[2];
  int status;

  status = info->read_memory_func (addr, buffer, 2, info);
  if (status != 0)
    {
      info->memory_error_func (status, addr, info);
      return -1;
    }
  return bfd_getl16 (buffer);
}

static int
msp430_nooperands (struct msp430_opcode_s *opcode,
		   bfd_vma addr ATTRIBUTE_UNUSED,
		   unsigned short insn ATTRIBUTE_UNUSED,
		   char *comm,
		   int *cycles)
{
  /* Pop with constant.  */
  if (insn == 0x43b2)
    return 0;
  if (insn == opcode->bin_opcode)
    return 2;

  if (opcode->fmt == 0)
    {
      if ((insn & 0x0f00) != 3 || (insn & 0x0f00) != 2)
	return 0;

      strcpy (comm, "emulated...");
      *cycles = 1;
    }
  else
    {
      strcpy (comm, "return from interupt");
      *cycles = 5;
    }

  return 2;
}

static int
print_as2_reg_name (int regno, char * op1, char * comm1,
		    int c2, int c3, int cd)
{
  switch (regno)
    {
    case 2:
      sprintf (op1, "#4");
      sprintf (comm1, "r2 As==10");
      return c2;

    case 3:
      sprintf (op1, "#2");
      sprintf (comm1, "r3 As==10");
      return c3;

    default:
      /* Indexed register mode @@Rn.  */
      sprintf (op1, "@@r%d", regno);
      return cd;
    }
}

static int
print_as3_reg_name (int regno, char * op1, char * comm1,
		    int c2, int c3, int cd)
{
  switch (regno)
    {
    case 2:
      sprintf (op1, "#8");
      sprintf (comm1, "r2 As==11");
      return c2;

    case 3:
      sprintf (op1, "#-1");
      sprintf (comm1, "r3 As==11");
      return c3;

    default:
      /* Post incremented @@Rn+.  */
      sprintf (op1, "@@r%d+", regno);
      return cd;
    }
}

static int
msp430_singleoperand (disassemble_info *info,
		      struct msp430_opcode_s *opcode,
		      bfd_vma addr,
		      unsigned short insn,
		      char *op,
		      char *comm,
		      unsigned short extension_word,
		      int *cycles)
{
  int regs = 0, regd = 0;
  int ad = 0, as = 0;
  int where = 0;
  int cmd_len = 2;
  int dst = 0;
  int fmt;
  int extended_dst = extension_word & 0xf;

  regd = insn & 0x0f;
  regs = (insn & 0x0f00) >> 8;
  as = (insn & 0x0030) >> 4;
  ad = (insn & 0x0080) >> 7;

  if (opcode->fmt < 0)
    fmt = (- opcode->fmt) - 1;
  else
    fmt = opcode->fmt;

  switch (fmt)
    {
    case 0:			/* Emulated work with dst register.  */
      if (regs != 2 && regs != 3 && regs != 1)
	return 0;

      /* Check if not clr insn.  */
      if (opcode->bin_opcode == 0x4300 && (ad || as))
	return 0;

      /* Check if really inc, incd insns.  */
      if ((opcode->bin_opcode & 0xff00) == 0x5300 && as == 3)
	return 0;

      if (ad == 0)
	{
	  *cycles = 1;

	  /* Register.  */
	  if (regd == 0)
	    {
	      *cycles += 1;
	      sprintf (op, "r0");
	    }
	  else if (regd == 1)
	    sprintf (op, "r1");

	  else if (regd == 2)
	    sprintf (op, "r2");

	  else
	    sprintf (op, "r%d", regd);
	}
      else	/* ad == 1 msp430dis_opcode.  */
	{
	  if (regd == 0)
	    {
	      /* PC relative.  */
	      dst = msp430dis_opcode (addr + 2, info);
	      cmd_len += 2;
	      *cycles = 4;
	      sprintf (op, "0x%04x", dst);
	      sprintf (comm, "PC rel. abs addr 0x%04x",
		       PS ((short) (addr + 2) + dst));
	      if (extended_dst)
		{
		  dst |= extended_dst << 16;
		  sprintf (op, "0x%05x", dst);
		  sprintf (comm, "PC rel. abs addr 0x%05lx",
			   (long)((addr + 2 + dst) & 0xfffff));
		}
	    }
	  else if (regd == 2)
	    {
	      /* Absolute.  */
	      dst = msp430dis_opcode (addr + 2, info);
	      cmd_len += 2;
	      *cycles = 4;
	      sprintf (op, "&0x%04x", PS (dst));
	      if (extended_dst)
		{
		  dst |= extended_dst << 16;
		  sprintf (op, "&0x%05x", dst & 0xfffff);
		}
	    }
	  else
	    {
	      dst = msp430dis_opcode (addr + 2, info);
	      cmd_len += 2;
	      *cycles = 4;
	      if (extended_dst)
		{
		  dst |= extended_dst << 16;
		  if (dst & 0x80000)
		    dst |= -1 << 20;
		}
	      else if (dst & 0x8000)
		dst |= -1 << 16;
	      sprintf (op, "%d(r%d)", dst, regd);
	    }
	}
      break;

    case 2:	/* rrc, push, call, swpb, rra, sxt, push, call, reti etc...  */
      if (as == 0)
	{
	  if (regd == 3)
	    {
	      /* Constsnts.  */
	      sprintf (op, "#0");
	      sprintf (comm, "r3 As==00");
	    }
	  else
	    {
	      /* Register.  */
	      sprintf (op, "r%d", regd);
	    }
	  *cycles = 1;
	}
      else if (as == 2)
	{
	  * cycles = print_as2_reg_name (regd, op, comm, 1, 1, 3);
	}
      else if (as == 3)
	{
	  if (regd == 0)
	    {
	      *cycles = 3;
	      /* absolute. @@pc+ */
	      dst = msp430dis_opcode (addr + 2, info);
	      cmd_len += 2;
	      sprintf (op, "#%d", dst);
	      if (dst > 9 || dst < 0)
		sprintf (comm, "#0x%04x", PS (dst));
	      if (extended_dst)
		{
		  dst |= extended_dst << 16;
		  if (dst & 0x80000)
		    dst |= -1 << 20;
		  sprintf (op, "#%d", dst);
		  if (dst > 9 || dst < 0)
		    sprintf (comm, "#0x%05x", dst);
		}
	    }
	  else
	    * cycles = print_as3_reg_name (regd, op, comm, 1, 1, 3);
	}
      else if (as == 1)
	{
	  *cycles = 4;
	  if (regd == 0)
	    {
	      /* PC relative.  */
	      dst = msp430dis_opcode (addr + 2, info);
	      cmd_len += 2;
	      sprintf (op, "0x%04x", PS (dst));
	      sprintf (comm, "PC rel. 0x%04x",
		       PS ((short) addr + 2 + dst));
	      if (extended_dst)
		{
		  dst |= extended_dst << 16;
		  sprintf (op, "0x%05x", dst & 0xffff);
		  sprintf (comm, "PC rel. 0x%05lx",
			   (long)((addr + 2 + dst) & 0xfffff));
		}
	    }
	  else if (regd == 2)
	    {
	      /* Absolute.  */
	      dst = msp430dis_opcode (addr + 2, info);
	      cmd_len += 2;
	      sprintf (op, "&0x%04x", PS (dst));
	      if (extended_dst)
		{
		  dst |= extended_dst << 16;
		  sprintf (op, "&0x%05x", dst & 0xfffff);
		}
	    }
	  else if (regd == 3)
	    {
	      *cycles = 1;
	      sprintf (op, "#1");
	      sprintf (comm, "r3 As==01");
	    }
	  else
	    {
	      /* Indexed.  */
	      dst = msp430dis_opcode (addr + 2, info);
	      cmd_len += 2;
	      if (extended_dst)
		{
		  dst |= extended_dst << 16;
		  if (dst & 0x80000)
		    dst |= -1 << 20;
		}
	      else if (dst & 0x8000)
		dst |= -1 << 16;
	      sprintf (op, "%d(r%d)", dst, regd);
	      if (dst > 9 || dst < 0)
		sprintf (comm, "%05x", dst);
	    }
	}
      break;

    case 3:			/* Jumps.  */
      where = insn & 0x03ff;
      if (where & 0x200)
	where |= ~0x03ff;
      if (where > 512 || where < -511)
	return 0;

      where *= 2;
      sprintf (op, "$%+-8d", where + 2);
      sprintf (comm, "abs 0x%lx", (long) (addr + 2 + where));
      *cycles = 2;
      return 2;
      break;
    default:
      cmd_len = 0;
    }

  return cmd_len;
}

static int
msp430_doubleoperand (disassemble_info *info,
		      struct msp430_opcode_s *opcode,
		      bfd_vma addr,
		      unsigned short insn,
		      char *op1,
		      char *op2,
		      char *comm1,
		      char *comm2,
		      unsigned short extension_word,
		      int *cycles)
{
  int regs = 0, regd = 0;
  int ad = 0, as = 0;
  int cmd_len = 2;
  int dst = 0;
  int fmt;
  int extended_dst = extension_word & 0xf;
  int extended_src = (extension_word >> 7) & 0xf;

  regd = insn & 0x0f;
  regs = (insn & 0x0f00) >> 8;
  as = (insn & 0x0030) >> 4;
  ad = (insn & 0x0080) >> 7;

  if (opcode->fmt < 0)
    fmt = (- opcode->fmt) - 1;
  else
    fmt = opcode->fmt;

  if (fmt == 0)
    {
      /* Special case: rla and rlc are the only 2 emulated instructions that
	 fall into two operand instructions.  */
      /* With dst, there are only:
	 Rm       	Register,
         x(Rm)     	Indexed,
         0xXXXX    	Relative,
         &0xXXXX    	Absolute 
         emulated_ins   dst
         basic_ins      dst, dst.  */

      if (regd != regs || as != ad)
	return 0;		/* May be 'data' section.  */

      if (ad == 0)
	{
	  /* Register mode.  */
	  if (regd == 3)
	    {
	      strcpy (comm1, _("Illegal as emulation instr"));
	      return -1;
	    }

	  sprintf (op1, "r%d", regd);
	  *cycles = 1;
	}
      else			/* ad == 1 */
	{
	  if (regd == 0)
	    {
	      /* PC relative, Symbolic.  */
	      dst = msp430dis_opcode (addr + 2, info);
	      cmd_len += 4;
	      *cycles = 6;
	      sprintf (op1, "0x%04x", PS (dst));
	      sprintf (comm1, "PC rel. 0x%04x",
		       PS ((short) addr + 2 + dst));
	      if (extended_dst)
		{
		  dst |= extended_dst << 16;
		  if (dst & 0x80000)
		    dst |= -1 << 20;
		  sprintf (op1, "0x%05x", dst & 0xfffff);
		  sprintf (comm1, "PC rel. 0x%05lx",
			   (long)((addr + 2 + dst) & 0xfffff));
		}
	    }
	  else if (regd == 2)
	    {
	      /* Absolute.  */
	      dst = msp430dis_opcode (addr + 2, info);
	      /* If the 'src' field is not the same as the dst
		 then this is not an rla instruction.  */
	      if (dst != msp430dis_opcode (addr + 4, info))
		return 0;
	      cmd_len += 4;
	      *cycles = 6;
	      sprintf (op1, "&0x%04x", PS (dst));
	      if (extended_dst)
		{
		  dst |= extended_dst << 16;
		  sprintf (op1, "&0x%05x", dst & 0xfffff);
		}
	    }
	  else
	    {
	      /* Indexed.  */
	      dst = msp430dis_opcode (addr + 2, info);
	      if (extended_dst)
		{
		  dst |= extended_dst << 16;
		  if (dst & 0x80000)
		    dst |= -1 << 20;
		}
	      else if (dst & 0x8000)
		dst |= -1 << 16;
	      cmd_len += 4;
	      *cycles = 6;
	      sprintf (op1, "%d(r%d)", dst, regd);
	      if (dst > 9 || dst < -9)
		sprintf (comm1, "#0x%05x", dst);
	    }
	}

      *op2 = 0;
      *comm2 = 0;

      return cmd_len;
    }

  /* Two operands exactly.  */
  if (ad == 0 && regd == 3)
    {
      /* R2/R3 are illegal as dest: may be data section.  */
      strcpy (comm1, _("Illegal as 2-op instr"));
      return -1;
    }

  /* Source.  */
  if (as == 0)
    {
      *cycles = 1;
      if (regs == 3)
	{
	  /* Constants.  */
	  sprintf (op1, "#0");
	  sprintf (comm1, "r3 As==00");
	}
      else
	{
	  /* Register.  */
	  sprintf (op1, "r%d", regs);
	}
    }
  else if (as == 2)
    {
      * cycles = print_as2_reg_name (regs, op1, comm1, 1, 1, regs == 0 ? 3 : 2);
    }
  else if (as == 3)
    {
      if (regs == 0)
	{
	  *cycles = 3;
	  /* Absolute. @@pc+.  */
	  dst = msp430dis_opcode (addr + 2, info);
	  cmd_len += 2;
	  sprintf (op1, "#%d", dst);
	  if (dst > 9 || dst < 0)
	    sprintf (comm1, "#0x%04x", PS (dst));
	  if (extended_src)
	    {
	      dst |= extended_src << 16;
	      if (dst & 0x80000)
		dst |= -1 << 20;
	      sprintf (op1, "#%d", dst);
	      if (dst > 9 || dst < 0)
		sprintf (comm1, "0x%05x", dst & 0xfffff);
	    }
	}
      else
	* cycles = print_as3_reg_name (regs, op1, comm1, 1, 1, 2);
    }
  else if (as == 1)
    {
      if (regs == 0)
	{
	  *cycles = 4;
	  /* PC relative.  */
	  dst = msp430dis_opcode (addr + 2, info);
	  cmd_len += 2;
	  sprintf (op1, "0x%04x", PS (dst));
	  sprintf (comm1, "PC rel. 0x%04x",
		   PS ((short) addr + 2 + dst));
	  if (extended_src)
	    {
	      dst |= extended_src << 16;
	      if (dst & 0x80000)
		dst |= -1 << 20;
	      sprintf (op1, "0x%05x", dst & 0xfffff);
	      sprintf (comm1, "PC rel. 0x%05lx",
		       (long) ((addr + 2 + dst) & 0xfffff));
	    }
	}
      else if (regs == 2)
	{
	  *cycles = 2;
	  /* Absolute.  */
	  dst = msp430dis_opcode (addr + 2, info);
	  cmd_len += 2;
	  sprintf (op1, "&0x%04x", PS (dst));
	  sprintf (comm1, "0x%04x", PS (dst));
	  if (extended_src)
	    {
	      dst |= extended_src << 16;
	      sprintf (op1, "&0x%05x", dst & 0xfffff);
	      * comm1 = 0;
	    }
	}
      else if (regs == 3)
	{
	  *cycles = 1;
	  sprintf (op1, "#1");
	  sprintf (comm1, "r3 As==01");
	}
      else
	{
	  *cycles = 3;
	  /* Indexed.  */
	  dst = msp430dis_opcode (addr + 2, info);
	  cmd_len += 2;
	  if (extended_src)
	    {
	      dst |= extended_src << 16;
	      if (dst & 0x80000)
		dst |= -1 << 20;
	    }
	  else if (dst & 0x8000)
	    dst |= -1 << 16;
	  sprintf (op1, "%d(r%d)", dst, regs);
	  if (dst > 9 || dst < -9)
	    sprintf (comm1, "0x%05x", dst);
	}
    }

  /* Destination. Special care needed on addr + XXXX.  */

  if (ad == 0)
    {
      /* Register.  */
      if (regd == 0)
	{
	  *cycles += 1;
	  sprintf (op2, "r0");
	}
      else if (regd == 1)
	sprintf (op2, "r1");

      else if (regd == 2)
	sprintf (op2, "r2");

      else
	sprintf (op2, "r%d", regd);
    }
  else	/* ad == 1.  */
    {
      * cycles += 3;

      if (regd == 0)
	{
	  /* PC relative.  */
	  *cycles += 1;
	  dst = msp430dis_opcode (addr + cmd_len, info);
	  sprintf (op2, "0x%04x", PS (dst));
	  sprintf (comm2, "PC rel. 0x%04x",
		   PS ((short) addr + cmd_len + dst));
	  if (extended_dst)
	    {
	      dst |= extended_dst << 16;
	      if (dst & 0x80000)
		dst |= -1 << 20;
	      sprintf (op2, "0x%05x", dst & 0xfffff);
	      sprintf (comm2, "PC rel. 0x%05lx",
		       (long)((addr + cmd_len + dst) & 0xfffff));
	    }
	  cmd_len += 2;
	}
      else if (regd == 2)
	{
	  /* Absolute.  */
	  dst = msp430dis_opcode (addr + cmd_len, info);
	  cmd_len += 2;
	  sprintf (op2, "&0x%04x", PS (dst));
	  if (extended_dst)
	    {
	      dst |= extended_dst << 16;
	      sprintf (op2, "&0x%05x", dst & 0xfffff);
	    }
	}
      else
	{
	  dst = msp430dis_opcode (addr + cmd_len, info);
	  cmd_len += 2;
	  if (dst & 0x8000)
	    dst |= -1 << 16;
	  if (dst > 9 || dst < 0)
	    sprintf (comm2, "0x%04x", PS (dst));
	  if (extended_dst)
	    {
	      dst |= extended_dst << 16;
	      if (dst & 0x80000)
		dst |= -1 << 20;
	      if (dst > 9 || dst < 0)
		sprintf (comm2, "0x%05x", dst & 0xfffff);
	    }
	  sprintf (op2, "%d(r%d)", dst, regd);
	}
    }

  return cmd_len;
}

static int
msp430_branchinstr (disassemble_info *info,
		    struct msp430_opcode_s *opcode ATTRIBUTE_UNUSED,
		    bfd_vma addr ATTRIBUTE_UNUSED,
		    unsigned short insn,
		    char *op1,
		    char *comm1,
		    int *cycles)
{
  int regs = 0, regd = 0;
  int as = 0;
  int cmd_len = 2;
  short dst = 0;

  regd = insn & 0x0f;
  regs = (insn & 0x0f00) >> 8;
  as = (insn & 0x0030) >> 4;

  if (regd != 0)	/* Destination register is not a PC.  */
    return 0;

  /* dst is a source register.  */
  if (as == 0)
    {
      /* Constants.  */
      if (regs == 3)
	{
	  *cycles = 1;
	  sprintf (op1, "#0");
	  sprintf (comm1, "r3 As==00");
	}
      else
	{
	  /* Register.  */
	  *cycles = 1;
	  sprintf (op1, "r%d", regs);
	}
    }
  else if (as == 2)
    {
      * cycles = print_as2_reg_name (regs, op1, comm1, 2, 1, 2);
    }
  else if (as == 3)
    {
      if (regs == 0)
	{
	  /* Absolute. @@pc+  */
	  *cycles = 3;
	  dst = msp430dis_opcode (addr + 2, info);
	  cmd_len += 2;
	  sprintf (op1, "#0x%04x", PS (dst));
	}
      else
	* cycles = print_as3_reg_name (regs, op1, comm1, 1, 1, 2);
    }
  else if (as == 1)
    {
      * cycles = 3;

      if (regs == 0)
	{
	  /* PC relative.  */
	  dst = msp430dis_opcode (addr + 2, info);
	  cmd_len += 2;
	  (*cycles)++;
	  sprintf (op1, "0x%04x", PS (dst));
	  sprintf (comm1, "PC rel. 0x%04x",
		   PS ((short) addr + 2 + dst));
	}
      else if (regs == 2)
	{
	  /* Absolute.  */
	  dst = msp430dis_opcode (addr + 2, info);
	  cmd_len += 2;
	  sprintf (op1, "&0x%04x", PS (dst));
	}
      else if (regs == 3)
	{
	  (*cycles)--;
	  sprintf (op1, "#1");
	  sprintf (comm1, "r3 As==01");
	}
      else
	{
	  /* Indexed.  */
	  dst = msp430dis_opcode (addr + 2, info);
	  cmd_len += 2;
	  if (dst & 0x8000)
	    dst |= -1 << 16;
	  sprintf (op1, "%d(r%d)", dst, regs);
	}
    }

  return cmd_len;
}

static int
msp430x_calla_instr (disassemble_info * info,
		     bfd_vma            addr,
		     unsigned short     insn,
		     char *             op1,
		     char *             comm1,
		     int *              cycles)
{
  unsigned int   ureg = insn & 0xf;
  int            reg = insn & 0xf;
  int            am = (insn & 0xf0) >> 4;
  int            cmd_len = 2;
  unsigned short udst = 0;
  short          dst = 0;

  switch (am)
    {
    case 4: /* CALLA Rdst */
      *cycles = 1;
      sprintf (op1, "r%d", reg);
      break;

    case 5: /* CALLA x(Rdst) */
      *cycles = 3;
      dst = msp430dis_opcode (addr + 2, info);
      cmd_len += 2;
      sprintf (op1, "%d(r%d)", dst, reg);
      if (reg == 0)
	sprintf (comm1, "PC rel. 0x%05lx", (long) (addr + 2 + dst));
      else
	sprintf (comm1, "0x%05x", dst);
      break;

    case 6: /* CALLA @@Rdst */
      *cycles = 2;
      sprintf (op1, "@@r%d", reg);
      break;

    case 7: /* CALLA @@Rdst+ */
      *cycles = 2;
      sprintf (op1, "@@r%d+", reg);
      break;

    case 8: /* CALLA &abs20 */
      udst = msp430dis_opcode (addr + 2, info);
      cmd_len += 2;
      *cycles = 4;
      sprintf (op1, "&%d", (ureg << 16) + udst);
      sprintf (comm1, "0x%05x", (ureg << 16) + udst);
      break;

    case 9: /* CALLA pcrel-sym */
      dst = msp430dis_opcode (addr + 2, info);
      cmd_len += 2;
      *cycles = 4;
      sprintf (op1, "%d(PC)", (reg << 16) + dst);
      sprintf (comm1, "PC rel. 0x%05lx",
	       (long) (addr + 2 + dst + (reg << 16)));
      break;

    case 11: /* CALLA #imm20 */
      udst = msp430dis_opcode (addr + 2, info);
      cmd_len += 2;
      *cycles = 4;
      sprintf (op1, "#%d", (ureg << 16) + udst);
      sprintf (comm1, "0x%05x", (ureg << 16) + udst);
      break;

    default:
      strcpy (comm1, _("unrecognised CALLA addressing mode"));
      return -1;
    }

  return cmd_len;
}

int
print_insn_msp430 (bfd_vma addr, disassemble_info *info)
{
  void *stream = info->stream;
  fprintf_ftype prin = info->fprintf_func;
  struct msp430_opcode_s *opcode;
  char op1[32], op2[32], comm1[64], comm2[64];
  int cmd_len = 0;
  unsigned short insn;
  int cycles = 0;
  char *bc = "";
  unsigned short extension_word = 0;

  insn = msp430dis_opcode (addr, info);
  if (insn == (unsigned short) -1)
    {
      prin (stream, ".word	0xffff;	????");
      return 2;
    }

  if (((int) addr & 0xffff) > 0xffdf)
    {
      (*prin) (stream, "interrupt service routine at 0x%04x", 0xffff & insn);
      return 2;
    }

  *comm1 = 0;
  *comm2 = 0;

  /* Check for an extension word.  */
  if ((insn & 0xf800) == 0x1800)
    {
      extension_word = insn;
      addr += 2;
      insn = msp430dis_opcode (addr, info);
      if (insn == (unsigned short) -1)
	{
	  prin (stream, ".word	0x%04x, 0xffff;	????",
		extension_word);
	  return 4;
	}
   }

  for (opcode = msp430_opcodes; opcode->name; opcode++)
    {
      if ((insn & opcode->bin_mask) == opcode->bin_opcode
	  && opcode->bin_opcode != 0x9300)
	{
	  *op1 = 0;
	  *op2 = 0;
	  *comm1 = 0;
	  *comm2 = 0;

	  /* r0 as destination. Ad should be zero.  */
	  if (opcode->insn_opnumb == 3
	      && (insn & 0x000f) == 0
	      && (insn & 0x0080) == 0)
	    {
	      cmd_len +=
		msp430_branchinstr (info, opcode, addr, insn, op1, comm1,
				    &cycles);
	      if (cmd_len)
		break;
	    }

	  switch (opcode->insn_opnumb)
	    {
	      int n;
	      int reg;

	    case 4:
	      cmd_len += msp430x_calla_instr (info, addr, insn,
					      op1, comm1, & cycles);
	      break;

	    case 5: /* PUSHM/POPM */
	      n = (insn & 0xf0) >> 4;
	      reg = (insn & 0xf);

	      sprintf (op1, "#%d", n + 1);
	      if (opcode->bin_opcode == 0x1400)
		/* PUSHM */
		sprintf (op2, "r%d", reg);
	      else
		/* POPM */
		sprintf (op2, "r%d", reg + n);
	      if (insn & 0x100)
		sprintf (comm1, "16-bit words");
	      else
		{
		  sprintf (comm1, "20-bit words");
		  bc =".a";
		}
	      
	      cycles = 2; /*FIXME*/
	      cmd_len = 2;
	      break;

	    case 6: /* RRAM, RRCM, RRUM, RLAM.  */
	      n = ((insn >> 10) & 0x3) + 1;
	      reg = (insn & 0xf);
	      if ((insn & 0x10) == 0)
		bc =".a";
	      sprintf (op1, "#%d", n);
	      sprintf (op2, "r%d", reg);
	      cycles = 2; /*FIXME*/
	      cmd_len = 2;
	      break;

	    case 8: /* ADDA, CMPA, SUBA.  */
	      reg = (insn & 0xf);
	      n = (insn >> 8) & 0xf;
	      if (insn & 0x40)
		{
		  sprintf (op1, "r%d", n);
		  cmd_len = 2;
		}
	      else
		{
		  n <<= 16;
		  n |= msp430dis_opcode (addr + 2, info);
		  sprintf (op1, "#%d", n);
		  if (n > 9 || n < 0)
		    sprintf (comm1, "0x%05x", n);
		  cmd_len = 4;
		}
	      sprintf (op2, "r%d", reg);
	      cycles = 2; /*FIXME*/
	      break;

	    case 9: /* MOVA */
	      reg = (insn & 0xf);
	      n = (insn >> 8) & 0xf;
	      switch ((insn >> 4) & 0xf)
		{
		case 0: /* MOVA @@Rsrc, Rdst */
		  cmd_len = 2;
		  sprintf (op1, "@@r%d", n);
		  if (strcmp (opcode->name, "bra") != 0)
		    sprintf (op2, "r%d", reg);
		  break;
		  
		case 1: /* MOVA @@Rsrc+, Rdst */
		  cmd_len = 2;
		  if (strcmp (opcode->name, "reta") != 0)
		    {
		      sprintf (op1, "@@r%d+", n);
		      if (strcmp (opcode->name, "bra") != 0)
			sprintf (op2, "r%d", reg);
		    }
		  break;
		  
		case 2: /* MOVA &abs20, Rdst */
		  cmd_len = 4;
		  n <<= 16;
		  n |= msp430dis_opcode (addr + 2, info);
		  sprintf (op1, "&%d", n);
		  if (n > 9 || n < 0)
		    sprintf (comm1, "0x%05x", n);
		  if (strcmp (opcode->name, "bra") != 0)
		    sprintf (op2, "r%d", reg);
		  break;
		  
		case 3: /* MOVA x(Rsrc), Rdst */
		  cmd_len = 4;
		  if (strcmp (opcode->name, "bra") != 0)
		    sprintf (op2, "r%d", reg);
		  reg = n;
		  n = msp430dis_opcode (addr + 2, info);
		  if (n & 0x8000)
		    n |= -1 << 16;
		  sprintf (op1, "%d(r%d)", n, reg);
		  if (n > 9 || n < 0)
		    {
		      if (reg == 0)
			sprintf (comm1, "PC rel. 0x%05lx",
				 (long) (addr + 2 + n));
		      else
			sprintf (comm1, "0x%05x", n);
		    }
		  break;

		case 6: /* MOVA Rsrc, &abs20 */
		  cmd_len = 4;
		  reg <<= 16;
		  reg |= msp430dis_opcode (addr + 2, info);
		  sprintf (op1, "r%d", n);
		  sprintf (op2, "&%d", reg);
		  if (reg > 9 || reg < 0)
		    sprintf (comm2, "0x%05x", reg);
		  break;

		case 7: /* MOVA Rsrc, x(Rdst) */
		  cmd_len = 4;
		  sprintf (op1, "r%d", n);
		  n = msp430dis_opcode (addr + 2, info);
		  if (n & 0x8000)
		    n |= -1 << 16;
		  sprintf (op2, "%d(r%d)", n, reg);
		  if (n > 9 || n < 0)
		    {
		      if (reg == 0)
			sprintf (comm2, "PC rel. 0x%05lx",
				 (long) (addr + 2 + n));
		      else
			sprintf (comm2, "0x%05x", n);
		    }
		  break;
		  
		case 8: /* MOVA #imm20, Rdst */
		  cmd_len = 4;
		  n <<= 16;
		  n |= msp430dis_opcode (addr + 2, info);
		  if (n & 0x80000)
		    n |= -1 << 20;
		  sprintf (op1, "#%d", n);
		  if (n > 9 || n < 0)
		    sprintf (comm1, "0x%05x", n);
		  if (strcmp (opcode->name, "bra") != 0)
		    sprintf (op2, "r%d", reg);
		  break;
		  
		case 12: /* MOVA Rsrc, Rdst */
		  cmd_len = 2;
		  sprintf (op1, "r%d", n);
		  if (strcmp (opcode->name, "bra") != 0)
		    sprintf (op2, "r%d", reg);
		  break;

		default:
		  break;
		}
	      cycles = 2; /* FIXME */
	      break;
	    }

	  if (cmd_len)
	    break;

	  switch (opcode->insn_opnumb)
	    {
	    case 0:
	      cmd_len += msp430_nooperands (opcode, addr, insn, comm1, &cycles);
	      break;
	    case 2:
	      cmd_len +=
		msp430_doubleoperand (info, opcode, addr, insn, op1, op2,
				      comm1, comm2,
				      extension_word,
				      &cycles);
	      if (insn & BYTE_OPERATION)
		{
		  if (extension_word != 0 && ((extension_word & BYTE_OPERATION) == 0))
		    bc = ".a";
		  else
		    bc = ".b";
		}
	      else if (extension_word)
		{
		  if (extension_word & (1 << 6))
		    bc = ".w";
		  else
		    {
		      bc = ".?";
		      sprintf (comm2, _("Reserved use of A/L and B/W bits detected"));
		    }
		}
	      
	      break;
	    case 1:
	      cmd_len +=
		msp430_singleoperand (info, opcode, addr, insn, op1, comm1,
				      extension_word,
				      &cycles);
	      if (extension_word
		  && (strcmp (opcode->name, "swpb") == 0
		      || strcmp (opcode->name, "sxt") == 0))
		{
		  if (insn & BYTE_OPERATION)
		    {
		      bc = ".?";
		      sprintf (comm2, _("Reserved use of A/L and B/W bits detected"));
		    }
		  else if (extension_word & BYTE_OPERATION)
		    bc = ".w";
		  else
		    bc = ".a";
		}
	      else if (insn & BYTE_OPERATION && opcode->fmt != 3)
		{
		  if (extension_word != 0 && ((extension_word & BYTE_OPERATION) == 0))
		    bc = ".a";
		  else
		    bc = ".b";
		}
	      else if (extension_word)
		{
		  if (extension_word & (1 << 6))
		    bc = ".w";
		  else
		    {
		      bc = ".?";
		      sprintf (comm2, _("Reserved use of A/L and B/W bits detected"));
		    }
		}
	      break;
	    default:
	      break;
	    }
	}

      if (cmd_len)
	break;
    }

  if (cmd_len < 1)
    {
      /* Unknown opcode, or invalid combination of operands.  */
      if (extension_word)
	{
	  prin (stream, ".word	0x%04x, 0x%04x;	????", extension_word, PS (insn));
	  if (*comm1)
	    prin (stream, "\t %s", comm1);
	  return 4;
	}
      (*prin) (stream, ".word	0x%04x;	????", PS (insn));
      return 2;
    }

  /* Display the repeat count (if set) for extended register mode.  */
  if (cmd_len == 2 && ((extension_word & 0xf) != 0))
    {
      if (extension_word & (1 << 7))
	prin (stream, "rpt r%d { ", extension_word & 0xf);
      else
	prin (stream, "rpt #%d { ", (extension_word & 0xf) + 1);
    }

  if (extension_word && opcode->name[strlen (opcode->name) - 1] != 'x')
    (*prin) (stream, "%sx%s", opcode->name, bc);
  else
    (*prin) (stream, "%s%s", opcode->name, bc);

  if (*op1)
    (*prin) (stream, "\t%s", op1);
  if (*op2)
    (*prin) (stream, ",");

  if (strlen (op1) < 7)
    (*prin) (stream, "\t");
  if (!strlen (op1))
    (*prin) (stream, "\t");

  if (*op2)
    (*prin) (stream, "%s", op2);
  if (strlen (op2) < 8)
    (*prin) (stream, "\t");

  if (*comm1 || *comm2)
    (*prin) (stream, ";");
  else if (cycles)
    {
      if (*op2)
	(*prin) (stream, ";");
      else
	{
	  if (strlen (op1) < 7)
	    (*prin) (stream, ";");
	  else
	    (*prin) (stream, "\t;");
	}
    }
  if (*comm1)
    (*prin) (stream, "%s", comm1);
  if (*comm1 && *comm2)
    (*prin) (stream, ",");
  if (*comm2)
    (*prin) (stream, " %s", comm2);

  if (extension_word)
    cmd_len += 2;

  return cmd_len;
}
@


1.9
log
@	* archures.c: Add some more MSP430 machine numbers.
	* config.bfd (msp430): Define targ_selvecs.
	* configure.in: Add bfd_elf32_msp430_ti_vec.
	* cpu-msp430.c: Add some more MSP430 machine numbers.
	* elf32-msp430.c Add support for MSP430X relocations.
	Add support for TI compiler generated relocations.
	Add support for sym_diff relocations.
	Add support for relaxing out of range short branches into long
	branches.
	Add support for MSP430 attribute section.
	* reloc.c: Add MSP430X relocations.
	* targets.c: Add bfd_elf32_msp430_ti_vec.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.
	* libbfd.h: Regenerate.

	* readelf.c: Add support for MSP430X architecture.

	* readelf.exp: Expect -wi test to fail for the MSP430.

	* config/tc-msp430.c: Add support for the MSP430X architecture.
	Add code to insert a NOP instruction after any instruction that
	might change the interrupt state.
	Add support for the LARGE memory model.
	Add code to initialise the .MSP430.attributes section.
	* config/tc-msp430.h: Add support for the MSP430X architecture.
	* doc/c-msp430.texi: Document the new -mL and -mN command line
	options.
	* NEWS: Mention support for the MSP430X architecture.

	* gas/all/gas.exp: Skip the DIFF1 test for the MSP430.
	Expect the FORWARD test to pass for the MSP430.
	Skip the REDEF tests for the MSP430.
	Expect the 930509A test to fail for the MSP430.
	* gas/all/sleb128-4.d: Skip for the MSP430.
	* gas/elf/elf.exp: Set target_machine to msp430 for the MSP430.
	Skip the EHOPT0 test for the MSP430.
	Skip the REDEF and EQU-RELOC tests for the MSP430.
	* gas/elf/section2.e-msp430: New file.
	* gas/lns/lns-big-delta.d: Remove expectation of 20-bit
	addresses.
	* gas/lns/lns.exp: Use alternate LNS COMMON test for the MSP430.
	* gas/msp430/msp430x.s: New test.
	* gas/msp430/msp430x.d: Expected disassembly.
	* gas/msp430/msp430.exp: Run new test.
	* gas/msp430/opcode.d: Update expected disassembly.

	* msp430.h: Add MSP430X relocs.
	Add some more MSP430 machine numbers.
	Add values used by .MSP430.attributes section.

	* msp430.h: Add patterns for MSP430X instructions.

	* Makefile.am: Add emsp430X.c
	* Makefine.in: Regenerate.
	* configure.tgt (msp430): Add msp430X emulation.
	* ldmain.c (multiple_definition): Only disable relaxation if it
	was enabled by the user.
	* ldmain.h (RELAXATION_ENABLED_BY_USER): New macro.
	* emulparams/msp430all.sh: Add support for MSP430X.
	* emultempl/generic.em: (before_parse): Enable relaxation for the
	MSP430.
	* scripttempl/msp430.sc: Reorganize sections.  Add .rodata
	section.
	* scripttempl/msp430_3.sc: Likewise.
	* NEWS: Mention support for MSP430X.

	* ld-elf/flags1.d: Expect this test to pass on the MSP430.
	* ld-elf/init-fini-arrays.d: Expect this test to fail on the
	MSP430.
	* ld-elf/merge.d: Expect this test to pass on the MSP430.
	* ld-elf/sec64k.exp: Skip these tests for the MSP430.
	* ld-gc/pr13683.d: Expect this test to fail on the MSP430.
	* ld-srec/srec.exp: Expect these tests to fail on the MSP430.
	* ld-undefined/undefined.exp: Expect the UNDEFINED LINE test to
	fail on the MSP430.

	* msp430-dis.c: Add support for MSP430X instructions.
@
text
@d839 1
a839 1
      strcpy (comm1, _("unercognised CALLA addressing mode"));
@


1.8
log
@	* arc-dis.c: Include sysdep.h first, remove some redundant includes.
	* bfin-dis.c: Likewise.
	* i860-dis.c: Likewise.
	* ia64-dis.c: Likewise.
	* ia64-gen.c: Likewise.
	* m68hc11-dis.c: Likewise.
	* mmix-dis.c: Likewise.
	* msp430-dis.c: Likewise.
	* or32-dis.c: Likewise.
	* rl78-dis.c: Likewise.
	* rx-dis.c: Likewise.
	* tic4x-dis.c: Likewise.
	* tilegx-opc.c: Likewise.
	* tilepro-opc.c: Likewise.
	* rx-decode.c: Regenerate.
@
text
@d2 2
a3 3
   Copyright (C) 2002, 2004, 2005, 2007, 2009, 2010, 2012
   Free Software Foundation, Inc.
   
d85 46
d137 1
d144 3
a146 1
  short dst = 0;
d153 6
a158 1
  switch (opcode->fmt)
d202 7
d217 5
d228 8
d259 1
a259 17
	  *cycles = 1;
	  if (regd == 2)
	    {
	      sprintf (op, "#4");
	      sprintf (comm, "r2 As==10");
	    }
	  else if (regd == 3)
	    {
	      sprintf (op, "#2");
	      sprintf (comm, "r3 As==10");
	    }
	  else
	    {
	      *cycles = 3;
	      /* Indexed register mode @@Rn.  */
	      sprintf (op, "@@r%d", regd);
	    }
d263 1
a263 12
	  *cycles = 1;
	  if (regd == 2)
	    {
	      sprintf (op, "#8");
	      sprintf (comm, "r2 As==11");
	    }
	  else if (regd == 3)
	    {
	      sprintf (op, "#-1");
	      sprintf (comm, "r3 As==11");
	    }
	  else if (regd == 0)
d270 11
a280 1
	      sprintf (comm, "#0x%04x", PS (dst));
d283 1
a283 4
	    {
	      *cycles = 3;
	      sprintf (op, "@@r%d+", regd);
	    }
d296 7
d310 5
d324 1
a324 1
	      /* Indexd.  */
d327 8
d336 2
d351 1
a351 1
      sprintf (comm, "abs 0x%x", PS ((short) (addr) + 2 + where));
d371 1
d377 4
a380 1
  short dst = 0;
d387 6
a392 1
  if (opcode->fmt == 0)
d430 9
a438 1

d451 5
d461 8
d472 2
d479 1
d497 1
a497 1
	  /* Constsnts.  */
d509 1
a509 21
      *cycles = 1;

      if (regs == 2)
	{
	  sprintf (op1, "#4");
	  sprintf (comm1, "r2 As==10");
	}
      else if (regs == 3)
	{
	  sprintf (op1, "#2");
	  sprintf (comm1, "r3 As==10");
	}
      else
	{
	  *cycles = 2;

	  /* Indexed register mode @@Rn.  */
	  sprintf (op1, "@@r%d", regs);
	}
      if (!regs)
	*cycles = 3;
d513 1
a513 13
      if (regs == 2)
	{
	  sprintf (op1, "#8");
	  sprintf (comm1, "r2 As==11");
	  *cycles = 1;
	}
      else if (regs == 3)
	{
	  sprintf (op1, "#-1");
	  sprintf (comm1, "r3 As==11");
	  *cycles = 1;
	}
      else if (regs == 0)
d520 11
a530 1
	  sprintf (comm1, "#0x%04x", PS (dst));
d533 1
a533 4
	{
	  *cycles = 2;
	  sprintf (op1, "@@r%d+", regs);
	}
d546 9
d564 6
d583 8
d592 2
d628 9
d645 5
d655 12
d714 1
a714 18
      if (regs == 2)
	{
	  *cycles = 2;
	  sprintf (op1, "#4");
	  sprintf (comm1, "r2 As==10");
	}
      else if (regs == 3)
	{
	  *cycles = 1;
	  sprintf (op1, "#2");
	  sprintf (comm1, "r3 As==10");
	}
      else
	{
	  /* Indexed register mode @@Rn.  */
	  *cycles = 2;
	  sprintf (op1, "@@r%d", regs);
	}
d718 1
a718 13
      if (regs == 2)
	{
	  *cycles = 1;
	  sprintf (op1, "#8");
	  sprintf (comm1, "r2 As==11");
	}
      else if (regs == 3)
	{
	  *cycles = 1;
	  sprintf (op1, "#-1");
	  sprintf (comm1, "r3 As==11");
	}
      else if (regs == 0)
d727 1
a727 4
	{
	  *cycles = 2;
	  sprintf (op1, "@@r%d+", regs);
	}
d758 1
a758 1
	  /* Indexd.  */
d761 2
d770 76
d857 1
a857 1
  char dinfo[32];		/* Debug purposes.  */
d860 5
a864 1
  sprintf (dinfo, "0x%04x", insn);
d875 14
d900 3
a902 2
	  if (opcode->insn_opnumb == 3 && (insn & 0x000f) == 0
	      && (0x0080 & insn) == 0)
d904 1
a904 1
	      cmd_len =
d913 174
d1088 1
a1088 1
	      cmd_len = msp430_nooperands (opcode, addr, insn, comm1, &cycles);
d1091 1
a1091 1
	      cmd_len =
d1093 3
a1095 1
				      comm1, comm2, &cycles);
d1097 17
a1113 1
		bc = ".b";
d1116 1
a1116 1
	      cmd_len =
d1118 1
d1120 31
a1150 2
	      if (insn & BYTE_OPERATION && opcode->fmt != 3)
		bc = ".b";
a1160 2
  dinfo[5] = 0;

d1164 7
d1175 13
a1187 1
  (*prin) (stream, "%s%s", opcode->name, bc);
d1224 4
@


1.7
log
@fix set but unused variable warnings
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004, 2005, 2007, 2009, 2010
d24 1
a26 1
#include <string.h>
@


1.6
log
@update copyright dates
@
text
@d2 2
a3 1
   Copyright (C) 2002, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.
d550 1
a550 1
  int ad = 0, as = 0;
a556 1
  ad = (insn & 0x0080) >> 7;
@


1.5
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.4
log
@Update function declarations to ISO C90 formatting
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004, 2005 Free Software Foundation, Inc.
d6 3
a8 1
   This program is free software; you can redistribute it and/or modify
d10 8
a17 8
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
@


1.3
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
d18 2
a19 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a34 16
static unsigned short msp430dis_opcode
  PARAMS ((bfd_vma, disassemble_info *));
int print_insn_msp430
  PARAMS ((bfd_vma, disassemble_info *));
int msp430_nooperands
  PARAMS ((struct msp430_opcode_s *, bfd_vma, unsigned short, char *, int *));
int msp430_singleoperand
  PARAMS ((disassemble_info *, struct msp430_opcode_s *, bfd_vma, unsigned short,
	   char *, char *, int *));
int msp430_doubleoperand
  PARAMS ((disassemble_info *, struct msp430_opcode_s *, bfd_vma, unsigned short,
	   char *, char *, char *, char *, int *));
int msp430_branchinstr
  PARAMS ((disassemble_info *, struct msp430_opcode_s *, bfd_vma, unsigned short,
	   char *, char *, int *));

d38 1
a38 3
msp430dis_opcode (addr, info)
     bfd_vma addr;
     disassemble_info *info;
d52 6
a57 132
int
print_insn_msp430 (addr, info)
     bfd_vma addr;
     disassemble_info *info;
{
  void *stream = info->stream;
  fprintf_ftype prin = info->fprintf_func;
  struct msp430_opcode_s *opcode;
  char op1[32], op2[32], comm1[64], comm2[64];
  int cmd_len = 0;
  unsigned short insn;
  int cycles = 0;
  char *bc = "";
  char dinfo[32];		/* Debug purposes.  */

  insn = msp430dis_opcode (addr, info);
  sprintf (dinfo, "0x%04x", insn);

  if (((int) addr & 0xffff) > 0xffdf)
    {
      (*prin) (stream, "interrupt service routine at 0x%04x", 0xffff & insn);
      return 2;
    }

  *comm1 = 0;
  *comm2 = 0;

  for (opcode = msp430_opcodes; opcode->name; opcode++)
    {
      if ((insn & opcode->bin_mask) == opcode->bin_opcode
	  && opcode->bin_opcode != 0x9300)
	{
	  *op1 = 0;
	  *op2 = 0;
	  *comm1 = 0;
	  *comm2 = 0;

	  /* r0 as destination. Ad should be zero.  */
	  if (opcode->insn_opnumb == 3 && (insn & 0x000f) == 0
	      && (0x0080 & insn) == 0)
	    {
	      cmd_len =
		msp430_branchinstr (info, opcode, addr, insn, op1, comm1,
				    &cycles);
	      if (cmd_len)
		break;
	    }

	  switch (opcode->insn_opnumb)
	    {
	    case 0:
	      cmd_len = msp430_nooperands (opcode, addr, insn, comm1, &cycles);
	      break;
	    case 2:
	      cmd_len =
		msp430_doubleoperand (info, opcode, addr, insn, op1, op2,
				      comm1, comm2, &cycles);
	      if (insn & BYTE_OPERATION)
		bc = ".b";
	      break;
	    case 1:
	      cmd_len =
		msp430_singleoperand (info, opcode, addr, insn, op1, comm1,
				      &cycles);
	      if (insn & BYTE_OPERATION && opcode->fmt != 3)
		bc = ".b";
	      break;
	    default:
	      break;
	    }
	}

      if (cmd_len)
	break;
    }

  dinfo[5] = 0;

  if (cmd_len < 1)
    {
      /* Unknown opcode, or invalid combination of operands.  */
      (*prin) (stream, ".word	0x%04x;	????", PS (insn));
      return 2;
    }

  (*prin) (stream, "%s%s", opcode->name, bc);

  if (*op1)
    (*prin) (stream, "\t%s", op1);
  if (*op2)
    (*prin) (stream, ",");

  if (strlen (op1) < 7)
    (*prin) (stream, "\t");
  if (!strlen (op1))
    (*prin) (stream, "\t");

  if (*op2)
    (*prin) (stream, "%s", op2);
  if (strlen (op2) < 8)
    (*prin) (stream, "\t");

  if (*comm1 || *comm2)
    (*prin) (stream, ";");
  else if (cycles)
    {
      if (*op2)
	(*prin) (stream, ";");
      else
	{
	  if (strlen (op1) < 7)
	    (*prin) (stream, ";");
	  else
	    (*prin) (stream, "\t;");
	}
    }
  if (*comm1)
    (*prin) (stream, "%s", comm1);
  if (*comm1 && *comm2)
    (*prin) (stream, ",");
  if (*comm2)
    (*prin) (stream, " %s", comm2);
  return cmd_len;
}

int
msp430_nooperands (opcode, addr, insn, comm, cycles)
     struct msp430_opcode_s *opcode;
     bfd_vma addr ATTRIBUTE_UNUSED;
     unsigned short insn ATTRIBUTE_UNUSED;
     char *comm;
     int *cycles;
d82 8
a89 10

int
msp430_singleoperand (info, opcode, addr, insn, op, comm, cycles)
     disassemble_info *info;
     struct msp430_opcode_s *opcode;
     bfd_vma addr;
     unsigned short insn;
     char *op;
     char *comm;
     int *cycles;
d135 1
a135 1
      else			/* ad == 1 msp430dis_opcode.  */
a165 1

d284 10
a293 9
int
msp430_doubleoperand (info, opcode, addr, insn, op1, op2, comm1, comm2, cycles)
     disassemble_info *info;
     struct msp430_opcode_s *opcode;
     bfd_vma addr;
     unsigned short insn;
     char *op1, *op2;
     char *comm1, *comm2;
     int *cycles;
d325 1
a325 1
	      strcpy (comm1, "Illegal as emulation instr");
d376 1
a376 1
      strcpy (comm1, "Illegal as 2-op instr");
d437 1
a437 1
	  /* Absolute. @@pc+  */
d505 1
a505 1
  else				/* ad == 1.  */
d537 8
a544 10

int
msp430_branchinstr (info, opcode, addr, insn, op1, comm1, cycles)
     disassemble_info *info;
     struct msp430_opcode_s *opcode ATTRIBUTE_UNUSED;
     bfd_vma addr ATTRIBUTE_UNUSED;
     unsigned short insn;
     char *op1;
     char *comm1;
     int *cycles;
d663 123
@


1.2
log
@Catch a bug in the msp430 disassembler where an add instruction was confused
with an rla instruction.  Add a test for this to the testsuite.
@
text
@d18 1
a18 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.1
log
@Add support for msp430.
@
text
@d2 1
a2 1
   Copyright (C) 2002 Free Software Foundation, Inc.
d494 4
@


1.1.46.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.1.46.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
a493 4
	      /* If the 'src' field is not the same as the dst
		 then this is not an rla instruction.  */
	      if (dst != msp430dis_opcode (addr + 4, info))
		return 0;
@


1.1.6.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@@


1.1.6.2
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
a493 4
	      /* If the 'src' field is not the same as the dst
		 then this is not an rla instruction.  */
	      if (dst != msp430dis_opcode (addr + 4, info))
		return 0;
@


