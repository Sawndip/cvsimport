head	1.12;
access;
symbols
	sid-snapshot-20180601:1.12
	sid-snapshot-20180501:1.12
	sid-snapshot-20180401:1.12
	sid-snapshot-20180301:1.12
	sid-snapshot-20180201:1.12
	sid-snapshot-20180101:1.12
	sid-snapshot-20171201:1.12
	sid-snapshot-20171101:1.12
	sid-snapshot-20171001:1.12
	sid-snapshot-20170901:1.12
	sid-snapshot-20170801:1.12
	sid-snapshot-20170701:1.12
	sid-snapshot-20170601:1.12
	sid-snapshot-20170501:1.12
	sid-snapshot-20170401:1.12
	sid-snapshot-20170301:1.12
	sid-snapshot-20170201:1.12
	sid-snapshot-20170101:1.12
	sid-snapshot-20161201:1.12
	sid-snapshot-20161101:1.12
	sid-snapshot-20160901:1.12
	sid-snapshot-20160801:1.12
	sid-snapshot-20160701:1.12
	sid-snapshot-20160601:1.12
	sid-snapshot-20160501:1.12
	sid-snapshot-20160401:1.12
	sid-snapshot-20160301:1.12
	sid-snapshot-20160201:1.12
	sid-snapshot-20160101:1.12
	sid-snapshot-20151201:1.12
	sid-snapshot-20151101:1.12
	sid-snapshot-20151001:1.12
	sid-snapshot-20150901:1.12
	sid-snapshot-20150801:1.12
	sid-snapshot-20150701:1.12
	sid-snapshot-20150601:1.12
	sid-snapshot-20150501:1.12
	sid-snapshot-20150401:1.12
	sid-snapshot-20150301:1.12
	sid-snapshot-20150201:1.12
	sid-snapshot-20150101:1.12
	sid-snapshot-20141201:1.12
	sid-snapshot-20141101:1.12
	sid-snapshot-20141001:1.12
	sid-snapshot-20140901:1.12
	sid-snapshot-20140801:1.12
	sid-snapshot-20140701:1.12
	sid-snapshot-20140601:1.12
	sid-snapshot-20140501:1.12
	sid-snapshot-20140401:1.12
	sid-snapshot-20140301:1.12
	sid-snapshot-20140201:1.12
	sid-snapshot-20140101:1.12
	sid-snapshot-20131201:1.12
	sid-snapshot-20131101:1.12
	sid-snapshot-20131001:1.12
	binutils-2_24-branch:1.12.0.8
	binutils-2_24-branchpoint:1.12
	binutils-2_21_1:1.11
	sid-snapshot-20130901:1.12
	gdb_7_6_1-2013-08-30-release:1.12
	sid-snapshot-20130801:1.12
	sid-snapshot-20130701:1.12
	sid-snapshot-20130601:1.12
	sid-snapshot-20130501:1.12
	gdb_7_6-2013-04-26-release:1.12
	sid-snapshot-20130401:1.12
	binutils-2_23_2:1.12
	gdb_7_6-branch:1.12.0.6
	gdb_7_6-2013-03-12-branchpoint:1.12
	sid-snapshot-20130301:1.12
	sid-snapshot-20130201:1.12
	sid-snapshot-20130101:1.12
	sid-snapshot-20121201:1.12
	gdb_7_5_1-2012-11-29-release:1.12
	binutils-2_23_1:1.12
	sid-snapshot-20121101:1.12
	binutils-2_23:1.12
	sid-snapshot-20121001:1.12
	sid-snapshot-20120901:1.12
	gdb_7_5-2012-08-17-release:1.12
	sid-snapshot-20120801:1.12
	binutils-2_23-branch:1.12.0.4
	binutils-2_23-branchpoint:1.12
	gdb_7_5-branch:1.12.0.2
	gdb_7_5-2012-07-18-branchpoint:1.12
	sid-snapshot-20120701:1.12
	sid-snapshot-20120601:1.12
	sid-snapshot-20120501:1.11
	binutils-2_22_branch:1.11.0.10
	gdb_7_4_1-2012-04-26-release:1.11
	sid-snapshot-20120401:1.11
	sid-snapshot-20120301:1.11
	sid-snapshot-20120201:1.11
	gdb_7_4-2012-01-24-release:1.11
	sid-snapshot-20120101:1.11
	gdb_7_4-branch:1.11.0.8
	gdb_7_4-2011-12-13-branchpoint:1.11
	sid-snapshot-20111201:1.11
	binutils-2_22:1.11
	sid-snapshot-20111101:1.11
	sid-snapshot-20111001:1.11
	binutils-2_22-branch:1.11.0.6
	binutils-2_22-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.11
	sid-snapshot-20110901:1.11
	sid-snapshot-20110801:1.11
	gdb_7_3-2011-07-26-release:1.11
	sid-snapshot-20110701:1.11
	sid-snapshot-20110601:1.11
	sid-snapshot-20110501:1.11
	gdb_7_3-branch:1.11.0.4
	gdb_7_3-2011-04-01-branchpoint:1.11
	sid-snapshot-20110401:1.11
	sid-snapshot-20110301:1.11
	sid-snapshot-20110201:1.11
	sid-snapshot-20110101:1.11
	binutils-2_21:1.11
	sid-snapshot-20101201:1.11
	binutils-2_21-branch:1.11.0.2
	binutils-2_21-branchpoint:1.11
	sid-snapshot-20101101:1.11
	sid-snapshot-20101001:1.10
	binutils-2_20_1:1.9
	gdb_7_2-2010-09-02-release:1.10
	sid-snapshot-20100901:1.10
	sid-snapshot-20100801:1.10
	gdb_7_2-branch:1.10.0.4
	gdb_7_2-2010-07-07-branchpoint:1.10
	sid-snapshot-20100701:1.10
	sid-snapshot-20100601:1.10
	sid-snapshot-20100501:1.10
	sid-snapshot-20100401:1.10
	gdb_7_1-2010-03-18-release:1.10
	sid-snapshot-20100301:1.10
	gdb_7_1-branch:1.10.0.2
	gdb_7_1-2010-02-18-branchpoint:1.10
	sid-snapshot-20100201:1.10
	sid-snapshot-20100101:1.10
	gdb_7_0_1-2009-12-22-release:1.9
	sid-snapshot-20091201:1.9
	sid-snapshot-20091101:1.9
	binutils-2_20:1.9
	gdb_7_0-2009-10-06-release:1.9
	sid-snapshot-20091001:1.9
	gdb_7_0-branch:1.9.0.8
	gdb_7_0-2009-09-16-branchpoint:1.9
	arc-sim-20090309:1.7
	binutils-arc-20081103-branch:1.8.0.12
	binutils-arc-20081103-branchpoint:1.8
	binutils-2_20-branch:1.9.0.6
	binutils-2_20-branchpoint:1.9
	sid-snapshot-20090901:1.9
	sid-snapshot-20090801:1.9
	msnyder-checkpoint-072509-branch:1.9.0.4
	msnyder-checkpoint-072509-branchpoint:1.9
	sid-snapshot-20090701:1.9
	dje-cgen-play1-branch:1.9.0.2
	dje-cgen-play1-branchpoint:1.9
	sid-snapshot-20090601:1.9
	sid-snapshot-20090501:1.9
	sid-snapshot-20090401:1.9
	arc-20081103-branch:1.8.0.10
	arc-20081103-branchpoint:1.8
	arc-insight_6_8-branch:1.7.0.14
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.12
	insight_6_8-branchpoint:1.7
	sid-snapshot-20090301:1.9
	binutils-2_19_1:1.8
	sid-snapshot-20090201:1.9
	sid-snapshot-20090101:1.8
	reverse-20081226-branch:1.8.0.8
	reverse-20081226-branchpoint:1.8
	sid-snapshot-20081201:1.8
	multiprocess-20081120-branch:1.8.0.6
	multiprocess-20081120-branchpoint:1.8
	sid-snapshot-20081101:1.8
	binutils-2_19:1.8
	sid-snapshot-20081001:1.8
	reverse-20080930-branch:1.8.0.4
	reverse-20080930-branchpoint:1.8
	binutils-2_19-branch:1.8.0.2
	binutils-2_19-branchpoint:1.8
	sid-snapshot-20080901:1.8
	sid-snapshot-20080801:1.8
	reverse-20080717-branch:1.7.0.10
	reverse-20080717-branchpoint:1.7
	sid-snapshot-20080701:1.7
	msnyder-reverse-20080609-branch:1.7.0.8
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.6.0.32
	drow-reverse-20070409-branchpoint:1.6
	sid-snapshot-20080601:1.7
	sid-snapshot-20080501:1.7
	sid-snapshot-20080403:1.7
	sid-snapshot-20080401:1.7
	gdb_6_8-2008-03-27-release:1.7
	sid-snapshot-20080301:1.7
	gdb_6_8-branch:1.7.0.6
	gdb_6_8-2008-02-26-branchpoint:1.7
	sid-snapshot-20080201:1.7
	sid-snapshot-20080101:1.7
	sid-snapshot-20071201:1.7
	sid-snapshot-20071101:1.7
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	sid-snapshot-20071001:1.7
	gdb_6_7-branch:1.7.0.4
	gdb_6_7-2007-09-07-branchpoint:1.7
	binutils-2_18:1.7
	binutils-2_18-branch:1.7.0.2
	binutils-2_18-branchpoint:1.7
	insight_6_6-20070208-release:1.6
	binutils-csl-coldfire-4_1-32:1.6
	binutils-csl-sourcerygxx-4_1-32:1.6
	gdb_6_6-2006-12-18-release:1.6
	binutils-csl-innovasic-fido-3_4_4-33:1.6
	binutils-csl-sourcerygxx-3_4_4-32:1.3
	binutils-csl-coldfire-4_1-30:1.6
	binutils-csl-sourcerygxx-4_1-30:1.6
	binutils-csl-coldfire-4_1-28:1.6
	binutils-csl-sourcerygxx-4_1-29:1.6
	binutils-csl-sourcerygxx-4_1-28:1.6
	gdb_6_6-branch:1.6.0.30
	gdb_6_6-2006-11-15-branchpoint:1.6
	binutils-csl-arm-2006q3-27:1.6
	binutils-csl-sourcerygxx-4_1-27:1.6
	binutils-csl-arm-2006q3-26:1.6
	binutils-csl-sourcerygxx-4_1-26:1.6
	binutils-csl-sourcerygxx-4_1-25:1.6
	binutils-csl-sourcerygxx-4_1-24:1.6
	binutils-csl-sourcerygxx-4_1-23:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	binutils-csl-sourcerygxx-4_1-21:1.6
	binutils-csl-arm-2006q3-21:1.6
	binutils-csl-sourcerygxx-4_1-22:1.6
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.6
	binutils-csl-sourcerygxx-4_1-20:1.6
	binutils-csl-arm-2006q3-19:1.6
	binutils-csl-sourcerygxx-4_1-19:1.6
	binutils-csl-sourcerygxx-4_1-18:1.6
	binutils-csl-renesas-4_1-9:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	binutils-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	binutils-csl-renesas-4_1-8:1.6
	binutils-csl-renesas-4_1-7:1.6
	binutils-csl-renesas-4_1-6:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	binutils-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	binutils-csl-sourcerygxx-4_1-14:1.6
	binutils-csl-sourcerygxx-4_1-15:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	binutils-csl-sourcerygxx-4_1-13:1.6
	binutils-2_17:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	binutils-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	binutils-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.6
	binutils-csl-wrs-linux-3_4_4-24:1.3
	binutils-csl-wrs-linux-3_4_4-23:1.3
	gdb-csl-sourcerygxx-4_1-9:1.6
	binutils-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	binutils-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	binutils-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	binutils-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	binutils-csl-sourcerygxx-4_1-6:1.6
	binutils-csl-wrs-linux-3_4_4-22:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	binutils-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	binutils-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.6.0.28
	gdb_6_5-2006-05-14-branchpoint:1.6
	binutils-csl-coldfire-4_1-10:1.6
	gdb-csl-sourcerygxx-4_1-5:1.6
	binutils-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.6.0.26
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.6
	binutils-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.6.0.24
	msnyder-reverse-20060502-branchpoint:1.6
	binutils-csl-wrs-linux-3_4_4-21:1.3
	gdb-csl-morpho-4_1-4:1.6
	binutils-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	binutils-csl-sourcerygxx-3_4_4-17:1.6
	binutils-csl-wrs-linux-3_4_4-20:1.3
	readline_5_1-import-branch:1.6.0.22
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	binutils-2_17-branch:1.6.0.20
	binutils-2_17-branchpoint:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.18
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.16
	msnyder-reverse-20060331-branchpoint:1.6
	binutils-csl-2_17-branch:1.6.0.14
	binutils-csl-2_17-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.12
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.10
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.8
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.4
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.2
	gdb-csl-arm-20051020-branchpoint:1.6
	binutils-csl-gxxpro-3_4-branch:1.3.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.3
	binutils-2_16_1:1.3
	msnyder-tracepoint-checkpoint-branch:1.4.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.3
	binutils-csl-arm-2005q1b:1.3
	binutils-2_16:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	binutils-csl-arm-2005q1a:1.3
	csl-arm-20050325-branch:1.3.0.6
	csl-arm-20050325-branchpoint:1.3
	binutils-csl-arm-2005q1-branch:1.3.0.4
	binutils-csl-arm-2005q1-branchpoint:1.3
	binutils-2_16-branch:1.3.0.2
	binutils-2_16-branchpoint:1.3
	csl-arm-2004-q3d:1.2
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.84
	gdb_6_3-20041019-branchpoint:1.2
	csl-arm-2004-q3:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.86
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.82
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	binutils-2_15:1.2
	binutils-2_15-branchpoint:1.2
	csl-arm-2004-q1a:1.2
	csl-arm-2004-q1:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.80
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.78
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.76
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.74
	drow_intercu-20040221-branchpoint:1.2
	binutils-2_15-branch:1.2.0.72
	cagney_bfdfile-20040213-branch:1.2.0.70
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.68
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	csl-arm-2003-q4:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.66
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.64
	cagney_x86i386-20030821-branch:1.2.0.62
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.60
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.58
	jimb-ppc64-linux-20030613-branchpoint:1.2
	binutils-2_14:1.2
	cagney_convert-20030606-branch:1.2.0.56
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.54
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.50
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	binutils-2_14-branch:1.2.0.46
	binutils-2_14-branchpoint:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.44
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.42
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.40
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.38
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.36
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.34
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.32
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.30
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.28
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.26
	cagney-unwind-20030108-branchpoint:1.2
	binutils-2_13_2_1:1.2
	binutils-2_13_2:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	binutils-2_13_1:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.24
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.22
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.20
	gdb_5_3-branch:1.2.0.18
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.16
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.14
	readline_4_3-import-branchpoint:1.2
	binutils-2_13:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	binutils-2_13-branchpoint:1.2
	binutils-2_13-branch:1.2.0.12
	kseitz_interps-20020528-branch:1.2.0.10
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.8
	cagney_regbuf-20020515-branchpoint:1.2
	binutils-2_12_1:1.2
	jimb-macro-020506-branch:1.2.0.6
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	binutils-2_12:1.2
	gdb_5_2-branch:1.2.0.4
	gdb_5_2-2002-03-03-branchpoint:1.2
	binutils-2_12-branch:1.2.0.2
	binutils-2_12-branchpoint:1.2
	binutils_latest_snapshot:1.12;
locks; strict;
comment	@ * @;


1.12
date	2012.05.17.15.13.25;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.08.14.00.50;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2009.12.11.13.42.17;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.02.14.21.54;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2008.07.30.04.34.58;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.05.09.49.02;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.07.19.27.51;	author wilson;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.01.11.16.33;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.07.07.34.30;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.19.12.38.55;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.08.12.12.15;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.31.17.33.08;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.12
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* Table of opcodes for the OpenRISC 1000 ISA.
   Copyright 2002, 2004, 2005, 2007, 2008, 2009, 2012
   Free Software Foundation, Inc.
   Contributed by Damjan Lampret (lampret@@opencores.org).
   
   This file is part of the GNU opcodes library.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "safe-ctype.h"
#include "ansidecl.h"
#include "opcode/or32.h"

/* We treat all letters the same in encode/decode routines so
   we need to assign some characteristics to them like signess etc.  */

const struct or32_letter or32_letters[] =
{
  { 'A', NUM_UNSIGNED },
  { 'B', NUM_UNSIGNED },
  { 'D', NUM_UNSIGNED },
  { 'I', NUM_SIGNED },
  { 'K', NUM_UNSIGNED },
  { 'L', NUM_UNSIGNED },
  { 'N', NUM_SIGNED },
  { '0', NUM_UNSIGNED },
  { '\0', 0 }     /* Dummy entry.  */
};

/* Opcode encoding:
   machine[31:30]: first two bits of opcode
   		   00 - neither of source operands is GPR
   		   01 - second source operand is GPR (rB)
   		   10 - first source operand is GPR (rA)
   		   11 - both source operands are GPRs (rA and rB)
   machine[29:26]: next four bits of opcode
   machine[25:00]: instruction operands (specific to individual instruction)

  Recommendation: irrelevant instruction bits should be set with a value of
  bits in same positions of instruction preceding current instruction in the
  code (when assembling).  */

#define EFN &l_none

#ifdef HAS_EXECUTION
#define EF(func) &(func)
#define EFI &l_invalid
#else  /* HAS_EXECUTION */
#define EF(func) EFN
#define EFI EFN
#endif /* HAS_EXECUTION */

const struct or32_opcode or32_opcodes[] =
{
  { "l.j",       "N",            "00 0x0  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_j), OR32_IF_DELAY },
  { "l.jal",     "N",            "00 0x1  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_jal), OR32_IF_DELAY },
  { "l.bnf",     "N",            "00 0x3  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_bnf), OR32_IF_DELAY | OR32_R_FLAG},
  { "l.bf",      "N",            "00 0x4  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_bf), OR32_IF_DELAY | OR32_R_FLAG },
  { "l.nop",     "K",            "00 0x5  01--- ----- KKKK KKKK KKKK KKKK", EF(l_nop), 0 },
  { "l.movhi",   "rD,K",         "00 0x6  DDDDD ----0 KKKK KKKK KKKK KKKK", EF(l_movhi), 0 }, /*MM*/
  { "l.macrc",   "rD",           "00 0x6  DDDDD ----1 0000 0000 0000 0000", EF(l_macrc), 0 }, /*MM*/

  { "l.sys",     "K",            "00 0x8  00000 00000 KKKK KKKK KKKK KKKK", EF(l_sys), 0 },
  { "l.trap",    "K",            "00 0x8  01000 00000 KKKK KKKK KKKK KKKK", EF(l_trap), 0 }, /* CZ 21/06/01 */
  { "l.msync",   "",             "00 0x8  10000 00000 0000 0000 0000 0000", EFN, 0 },
  { "l.psync",   "",             "00 0x8  10100 00000 0000 0000 0000 0000", EFN, 0 },
  { "l.csync",   "",             "00 0x8  11000 00000 0000 0000 0000 0000", EFN, 0 },
  { "l.rfe",     "",             "00 0x9  ----- ----- ---- ---- ---- ----", EF(l_rfe), OR32_IF_DELAY },

  { "lv.all_eq.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
  { "lv.all_eq.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x1", EFI, 0 },
  { "lv.all_ge.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x2", EFI, 0 },
  { "lv.all_ge.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x3", EFI, 0 },
  { "lv.all_gt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x4", EFI, 0 },
  { "lv.all_gt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x5", EFI, 0 },
  { "lv.all_le.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x6", EFI, 0 },
  { "lv.all_le.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x7", EFI, 0 },
  { "lv.all_lt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x8", EFI, 0 },
  { "lv.all_lt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x9", EFI, 0 },
  { "lv.all_ne.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0xA", EFI, 0 },
  { "lv.all_ne.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0xB", EFI, 0 },
  { "lv.any_eq.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x0", EFI, 0 },
  { "lv.any_eq.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x1", EFI, 0 },
  { "lv.any_ge.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x2", EFI, 0 },
  { "lv.any_ge.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x3", EFI, 0 },
  { "lv.any_gt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x4", EFI, 0 },
  { "lv.any_gt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x5", EFI, 0 },
  { "lv.any_le.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x6", EFI, 0 },
  { "lv.any_le.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x7", EFI, 0 },
  { "lv.any_lt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x8", EFI, 0 },
  { "lv.any_lt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x9", EFI, 0 },
  { "lv.any_ne.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0xA", EFI, 0 },
  { "lv.any_ne.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0xB", EFI, 0 },
  { "lv.add.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x0", EFI, 0 },
  { "lv.add.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x1", EFI, 0 },
  { "lv.adds.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x2", EFI, 0 },
  { "lv.adds.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x3", EFI, 0 },
  { "lv.addu.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x4", EFI, 0 },
  { "lv.addu.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x5", EFI, 0 },
  { "lv.addus.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x6", EFI, 0 },
  { "lv.addus.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x7", EFI, 0 },
  { "lv.and",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x8", EFI, 0 },
  { "lv.avg.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x9", EFI, 0 },
  { "lv.avg.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0xA", EFI, 0 },
  { "lv.cmp_eq.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x0", EFI, 0 },
  { "lv.cmp_eq.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x1", EFI, 0 },
  { "lv.cmp_ge.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x2", EFI, 0 },
  { "lv.cmp_ge.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x3", EFI, 0 },
  { "lv.cmp_gt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x4", EFI, 0 },
  { "lv.cmp_gt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x5", EFI, 0 },
  { "lv.cmp_le.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x6", EFI, 0 },
  { "lv.cmp_le.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x7", EFI, 0 },
  { "lv.cmp_lt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x8", EFI, 0 },
  { "lv.cmp_lt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x9", EFI, 0 },
  { "lv.cmp_ne.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0xA", EFI, 0 },
  { "lv.cmp_ne.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0xB", EFI, 0 },
  { "lv.madds.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x4", EFI, 0 },
  { "lv.max.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x5", EFI, 0 },
  { "lv.max.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x6", EFI, 0 },
  { "lv.merge.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x7", EFI, 0 },
  { "lv.merge.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x8", EFI, 0 },
  { "lv.min.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x9", EFI, 0 },
  { "lv.min.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xA", EFI, 0 },
  { "lv.msubs.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xB", EFI, 0 },
  { "lv.muls.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xC", EFI, 0 },
  { "lv.nand",   "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xD", EFI, 0 },
  { "lv.nor",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xE", EFI, 0 },
  { "lv.or",     "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xF", EFI, 0 },
  { "lv.pack.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x0", EFI, 0 },
  { "lv.pack.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x1", EFI, 0 },
  { "lv.packs.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x2", EFI, 0 },
  { "lv.packs.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x3", EFI, 0 },
  { "lv.packus.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x4", EFI, 0 },
  { "lv.packus.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x5", EFI, 0 },
  { "lv.perm.n", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x6", EFI, 0 },
  { "lv.rl.b",   "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x7", EFI, 0 },
  { "lv.rl.h",   "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x8", EFI, 0 },
  { "lv.sll.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x9", EFI, 0 },
  { "lv.sll.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xA", EFI, 0 },
  { "lv.sll",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xB", EFI, 0 },
  { "lv.srl.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xC", EFI, 0 },
  { "lv.srl.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xD", EFI, 0 },
  { "lv.sra.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xE", EFI, 0 },
  { "lv.sra.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xF", EFI, 0 },
  { "lv.srl",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x0", EFI, 0 },
  { "lv.sub.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x1", EFI, 0 },
  { "lv.sub.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x2", EFI, 0 },
  { "lv.subs.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x3", EFI, 0 },
  { "lv.subs.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x4", EFI, 0 },
  { "lv.subu.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x5", EFI, 0 },
  { "lv.subu.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x6", EFI, 0 },
  { "lv.subus.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x7", EFI, 0 },
  { "lv.subus.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x8", EFI, 0 },
  { "lv.unpack.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x9", EFI, 0 },
  { "lv.unpack.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0xA", EFI, 0 },
  { "lv.xor",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0xB", EFI, 0 },
  { "lv.cust1",  "",	       "00 0xA  ----- ----- ---- ---- 0xC ----", EFI, 0 },
  { "lv.cust2",  "",	       "00 0xA  ----- ----- ---- ---- 0xD ----", EFI, 0 },
  { "lv.cust3",  "",	       "00 0xA  ----- ----- ---- ---- 0xE ----", EFI, 0 },
  { "lv.cust4",  "",	       "00 0xA  ----- ----- ---- ---- 0xF ----", EFI, 0 },
  
  { "lf.add.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
  { "lf.sub.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x1", EFI, 0 },
  { "lf.mul.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x2", EFI, 0 },
  { "lf.div.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x3", EFI, 0 },
  { "lf.itof.s",  "rD,rA",       "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x4", EFI, 0 },
  { "lf.ftoi.s",  "rD,rA",       "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x5", EFI, 0 },
  { "lf.rem.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x6", EFI, 0 },
  { "lf.madd.s",  "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x7", EFI, 0 },
  { "lf.sfeq.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0x8", EFI, 0 },
  { "lf.sfne.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0x9", EFI, 0 },
  { "lf.sfgt.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xA", EFI, 0 },
  { "lf.sfge.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xB", EFI, 0 },
  { "lf.sflt.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xC", EFI, 0 },
  { "lf.sfle.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xD", EFI, 0 },
  { "lf.cust1.s", "",	       "00 0xB  ----- ----- ---- ---- 0xE ----", EFI, 0 },

  { "lf.add.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
  { "lf.sub.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x1", EFI, 0 },
  { "lf.mul.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x2", EFI, 0 },
  { "lf.div.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x3", EFI, 0 },
  { "lf.itof.d",  "rD,rA",       "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x4", EFI, 0 },
  { "lf.ftoi.d",  "rD,rA",       "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x5", EFI, 0 },
  { "lf.rem.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x6", EFI, 0 },
  { "lf.madd.d",  "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x7", EFI, 0 },
  { "lf.sfeq.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0x8", EFI, 0 },
  { "lf.sfne.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0x9", EFI, 0 },
  { "lf.sfgt.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xA", EFI, 0 },
  { "lf.sfge.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xB", EFI, 0 },
  { "lf.sflt.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xC", EFI, 0 },
  { "lf.sfle.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xD", EFI, 0 },
  { "lf.cust1.d", "",	       "00 0xC  ----- ----- ---- ---- 0xE ----", EFI, 0 },

  { "lvf.ld",     "rD,0(rA)",    "00 0xD  DDDDD AAAAA ---- ---- 0x0 0x0", EFI, 0 },
  { "lvf.lw",     "rD,0(rA)",    "00 0xD  DDDDD AAAAA ---- ---- 0x0 0x1", EFI, 0 },
  { "lvf.sd",     "0(rA),rB",    "00 0xD  ----- AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
  { "lvf.sw",     "0(rA),rB",    "00 0xD  ----- AAAAA BBBB B--- 0x1 0x1", EFI, 0 },

  { "l.jr",      "rB",           "01 0x1  ----- ----- BBBB B--- ---- ----", EF(l_jr), OR32_IF_DELAY },
  { "l.jalr",    "rB",           "01 0x2  ----- ----- BBBB B--- ---- ----", EF(l_jalr), OR32_IF_DELAY },
  { "l.maci",    "rB,I",         "01 0x3  IIIII ----- BBBB BIII IIII IIII", EF(l_mac), 0 },
  { "l.cust1",   "",	       "01 0xC  ----- ----- ---- ---- ---- ----", EF(l_cust1), 0 },
  { "l.cust2",   "",	       "01 0xD  ----- ----- ---- ---- ---- ----", EF(l_cust2), 0 },
  { "l.cust3",   "",	       "01 0xE  ----- ----- ---- ---- ---- ----", EF(l_cust3), 0 },
  { "l.cust4",   "",	       "01 0xF  ----- ----- ---- ---- ---- ----", EF(l_cust4), 0 },

  { "l.ld",      "rD,I(rA)",     "10 0x0  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
  { "l.lwz",     "rD,I(rA)",     "10 0x1  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lwz), 0 },
  { "l.lws",     "rD,I(rA)",     "10 0x2  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
  { "l.lbz",     "rD,I(rA)",     "10 0x3  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lbz), 0 },
  { "l.lbs",     "rD,I(rA)",     "10 0x4  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lbs), 0 },
  { "l.lhz",     "rD,I(rA)",     "10 0x5  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lhz), 0 },
  { "l.lhs",     "rD,I(rA)",     "10 0x6  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lhs), 0 },

  { "l.addi",    "rD,rA,I",      "10 0x7  DDDDD AAAAA IIII IIII IIII IIII", EF(l_add), 0 },
  { "l.addic",   "rD,rA,I",      "10 0x8  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
  { "l.andi",    "rD,rA,K",      "10 0x9  DDDDD AAAAA KKKK KKKK KKKK KKKK", EF(l_and), 0 },
  { "l.ori",     "rD,rA,K",      "10 0xA  DDDDD AAAAA KKKK KKKK KKKK KKKK", EF(l_or), 0  },
  { "l.xori",    "rD,rA,I",      "10 0xB  DDDDD AAAAA IIII IIII IIII IIII", EF(l_xor), 0 },
  { "l.muli",    "rD,rA,I",      "10 0xC  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
  { "l.mfspr",   "rD,rA,K",      "10 0xD  DDDDD AAAAA KKKK KKKK KKKK KKKK", EF(l_mfspr), 0 },
  { "l.slli",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 00LL LLLL", EF(l_sll), 0 },
  { "l.srli",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 01LL LLLL", EF(l_srl), 0 },
  { "l.srai",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 10LL LLLL", EF(l_sra), 0 },
  { "l.rori",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 11LL LLLL", EFI, 0 },

  { "l.sfeqi",   "rA,I",         "10 0xF  00000 AAAAA IIII IIII IIII IIII", EF(l_sfeq), OR32_W_FLAG },
  { "l.sfnei",   "rA,I",         "10 0xF  00001 AAAAA IIII IIII IIII IIII", EF(l_sfne), OR32_W_FLAG },
  { "l.sfgtui",  "rA,I",         "10 0xF  00010 AAAAA IIII IIII IIII IIII", EF(l_sfgtu), OR32_W_FLAG },
  { "l.sfgeui",  "rA,I",         "10 0xF  00011 AAAAA IIII IIII IIII IIII", EF(l_sfgeu), OR32_W_FLAG },
  { "l.sfltui",  "rA,I",         "10 0xF  00100 AAAAA IIII IIII IIII IIII", EF(l_sfltu), OR32_W_FLAG },
  { "l.sfleui",  "rA,I",         "10 0xF  00101 AAAAA IIII IIII IIII IIII", EF(l_sfleu), OR32_W_FLAG },
  { "l.sfgtsi",  "rA,I",         "10 0xF  01010 AAAAA IIII IIII IIII IIII", EF(l_sfgts), OR32_W_FLAG },
  { "l.sfgesi",  "rA,I",         "10 0xF  01011 AAAAA IIII IIII IIII IIII", EF(l_sfges), OR32_W_FLAG },
  { "l.sfltsi",  "rA,I",         "10 0xF  01100 AAAAA IIII IIII IIII IIII", EF(l_sflts), OR32_W_FLAG },
  { "l.sflesi",  "rA,I",         "10 0xF  01101 AAAAA IIII IIII IIII IIII", EF(l_sfles), OR32_W_FLAG },

  { "l.mtspr",   "rA,rB,K",      "11 0x0  KKKKK AAAAA BBBB BKKK KKKK KKKK", EF(l_mtspr), 0 },
  { "l.mac",     "rA,rB",        "11 0x1  ----- AAAAA BBBB B--- ---- 0x1", EF(l_mac), 0 }, /*MM*/
  { "l.msb",     "rA,rB",        "11 0x1  ----- AAAAA BBBB B--- ---- 0x2", EF(l_msb), 0 }, /*MM*/

  { "l.sd",      "I(rA),rB",     "11 0x4  IIIII AAAAA BBBB BIII IIII IIII", EFI, 0 },
  { "l.sw",      "I(rA),rB",     "11 0x5  IIIII AAAAA BBBB BIII IIII IIII", EF(l_sw), 0 },
  { "l.sb",      "I(rA),rB",     "11 0x6  IIIII AAAAA BBBB BIII IIII IIII", EF(l_sb), 0 },
  { "l.sh",      "I(rA),rB",     "11 0x7  IIIII AAAAA BBBB BIII IIII IIII", EF(l_sh), 0 },
    
  { "l.add",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x0", EF(l_add), 0 },
  { "l.addc",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x1", EFI, 0 },
  { "l.sub",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x2", EF(l_sub), 0 },
  { "l.and",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x3", EF(l_and), 0 },
  { "l.or",      "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x4", EF(l_or), 0 },
  { "l.xor",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x5", EF(l_xor), 0 },
  { "l.mul",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-11 ---- 0x6", EF(l_mul), 0 },

  { "l.sll",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 00-- 0x8", EF(l_sll), 0 },
  { "l.srl",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 01-- 0x8", EF(l_srl), 0 },
  { "l.sra",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 10-- 0x8", EF(l_sra), 0 },
  { "l.ror",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 11-- 0x8", EFI, 0 },
  { "l.div",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x9", EF(l_div), 0 },
  { "l.divu",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0xA", EF(l_divu), 0 },
  { "l.mulu",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-11 ---- 0xB", EFI, 0 },
  { "l.exths",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 00-- 0xC", EFI, 0 },
  { "l.extbs",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 01-- 0xC", EFI, 0 },
  { "l.exthz",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 10-- 0xC", EFI, 0 },
  { "l.extbz",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 11-- 0xC", EFI, 0 },
  { "l.extws",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 00-- 0xD", EFI, 0 },
  { "l.extwz",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 01-- 0xD", EFI, 0 },
  { "l.cmov",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0xE", EFI, 0 },
  { "l.ff1",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0xF", EFI, 0 },

  { "l.sfeq",    "rA,rB",        "11 0x9  00000 AAAAA BBBB B--- ---- ----", EF(l_sfeq), OR32_W_FLAG },
  { "l.sfne",    "rA,rB",        "11 0x9  00001 AAAAA BBBB B--- ---- ----", EF(l_sfne), OR32_W_FLAG },
  { "l.sfgtu",   "rA,rB",        "11 0x9  00010 AAAAA BBBB B--- ---- ----", EF(l_sfgtu), OR32_W_FLAG },
  { "l.sfgeu",   "rA,rB",        "11 0x9  00011 AAAAA BBBB B--- ---- ----", EF(l_sfgeu), OR32_W_FLAG },
  { "l.sfltu",   "rA,rB",        "11 0x9  00100 AAAAA BBBB B--- ---- ----", EF(l_sfltu), OR32_W_FLAG },
  { "l.sfleu",   "rA,rB",        "11 0x9  00101 AAAAA BBBB B--- ---- ----", EF(l_sfleu), OR32_W_FLAG },
  { "l.sfgts",   "rA,rB",        "11 0x9  01010 AAAAA BBBB B--- ---- ----", EF(l_sfgts), OR32_W_FLAG },
  { "l.sfges",   "rA,rB",        "11 0x9  01011 AAAAA BBBB B--- ---- ----", EF(l_sfges), OR32_W_FLAG },
  { "l.sflts",   "rA,rB",        "11 0x9  01100 AAAAA BBBB B--- ---- ----", EF(l_sflts), OR32_W_FLAG },
  { "l.sfles",   "rA,rB",        "11 0x9  01101 AAAAA BBBB B--- ---- ----", EF(l_sfles), OR32_W_FLAG },

  { "l.cust5",   "",	       "11 0xC  ----- ----- ---- ---- ---- ----", EFI, 0 },
  { "l.cust6",   "",	       "11 0xD  ----- ----- ---- ---- ---- ----", EFI, 0 },
  { "l.cust7",   "",	       "11 0xE  ----- ----- ---- ---- ---- ----", EFI, 0 },
  { "l.cust8",   "",	       "11 0xF  ----- ----- ---- ---- ---- ----", EFI, 0 },

  /* This section should not be defined in or1ksim, since it contains duplicates,
     which would cause machine builder to complain.  */
#ifdef HAS_CUST
  { "l.cust5_1",   "rD",	       "11 0xC  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
  { "l.cust5_2",   "rD,rA"   ,   "11 0xC  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
  { "l.cust5_3",   "rD,rA,rB",   "11 0xC  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },

  { "l.cust6_1",   "rD",	       "11 0xD  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
  { "l.cust6_2",   "rD,rA"   ,   "11 0xD  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
  { "l.cust6_3",   "rD,rA,rB",   "11 0xD  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },

  { "l.cust7_1",   "rD",	       "11 0xE  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
  { "l.cust7_2",   "rD,rA"   ,   "11 0xE  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
  { "l.cust7_3",   "rD,rA,rB",   "11 0xE  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },

  { "l.cust8_1",   "rD",	       "11 0xF  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
  { "l.cust8_2",   "rD,rA"   ,   "11 0xF  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
  { "l.cust8_3",   "rD,rA,rB",   "11 0xF  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },
#endif

  /* Dummy entry, not included in num_opcodes.  This
     lets code examine entry i+1 without checking
     if we've run off the end of the table.  */
  { "", "", "", EFI, 0 }
};

#undef EFI
#undef EFN
#undef EF 

/* Define dummy, if debug is not defined.  */

#if !defined HAS_DEBUG
static void ATTRIBUTE_PRINTF_2
debug (int level ATTRIBUTE_UNUSED, const char *format ATTRIBUTE_UNUSED, ...)
{
}
#endif

const unsigned int or32_num_opcodes = ((sizeof(or32_opcodes)) / (sizeof(struct or32_opcode))) - 1;

/* Calculates instruction length in bytes. Always 4 for OR32.  */

int
insn_len (int i_index ATTRIBUTE_UNUSED)
{
  return 4;
}

/* Is individual insn's operand signed or unsigned?  */

int
letter_signed (char l)
{
  const struct or32_letter *pletter;
  
  for (pletter = or32_letters; pletter->letter != '\0'; pletter++)
    if (pletter->letter == l)
      return pletter->sign;
  
  printf ("letter_signed(%c): Unknown letter.\n", l);
  return 0;
}

/* Number of letters in the individual lettered operand.  */

int
letter_range (char l)
{
  const struct or32_opcode *pinsn;
  char *enc;
  int range = 0;
  
  for (pinsn = or32_opcodes; strlen (pinsn->name); pinsn ++)
    {
      if (strchr (pinsn->encoding,l))
	{
	  for (enc = pinsn->encoding; *enc != '\0'; enc ++)
	    if ((*enc == '0') && (*(enc + 1) == 'x'))
	      enc += 2;
	    else if (*enc == l)
	      range++;
	  return range;
	}
    }

  printf ("\nABORT: letter_range(%c): Never used letter.\n", l);
  exit (1);
}

/* MM: Returns index of given instruction name.  */

int
insn_index (char *insn)
{
  unsigned int i;
  int found = -1;

  for (i = 0; i < or32_num_opcodes; i++)
    if (!strcmp (or32_opcodes[i].name, insn))
      {
	found = i;
	break;
      }
  return found;
}

const char *
insn_name (int op_index)
{
  if (op_index >= 0 && op_index < (int) or32_num_opcodes)
    return or32_opcodes[op_index].name;
  else
    return "???";
}

void
l_none (void)
{
}

/* Finite automata for instruction decoding building code.  */

/* Find simbols in encoding.  */

static unsigned long
insn_extract (char param_ch, char *enc_initial)
{
  char *enc;
  unsigned long ret = 0;
  unsigned opc_pos = 32;

  for (enc = enc_initial; *enc != '\0'; )
    if ((*enc == '0') && (*(enc + 1) == 'x')) 
      {
	unsigned long tmp = strtol (enc+2, NULL, 16);

        opc_pos -= 4;
	if (param_ch == '0' || param_ch == '1')
	  {
	    if (param_ch == '0')
	      tmp = 15 - tmp;
	    ret |= tmp << opc_pos;
	  }
        enc += 3;
      }
    else
      {
	if (*enc == '0' || *enc == '1' || *enc == '-' || ISALPHA (*enc))
	  {
	    opc_pos--;
	    if (param_ch == *enc)
	      ret |= 1 << opc_pos;
	  }
	enc++;
      }
  return ret;
}

#define MAX_AUTOMATA_SIZE  1200
#define MAX_OP_TABLE_SIZE  1200
#define LEAF_FLAG          0x80000000
#define MAX_LEN            8

#ifndef MIN
#define MIN(x, y)          ((x) < (y) ? (x) : (y))
#endif

unsigned long *automata;
int nuncovered;
int curpass = 0;

/* MM: Struct that hold runtime build information about instructions.  */
struct temp_insn_struct
{
  unsigned long insn;
  unsigned long insn_mask;
  int in_pass;
} *ti;

struct insn_op_struct *op_data, **op_start;

/* Recursive utility function used to find best match and to build automata.  */

static unsigned long *
cover_insn (unsigned long * cur, int pass, unsigned int mask)
{
  int best_first = 0, last_match = -1, ninstr = 0;
  unsigned int best_len = 0;
  unsigned int i;
  unsigned long cur_mask = mask;
  unsigned long *next;

  for (i = 0; i < or32_num_opcodes; i++)
    if (ti[i].in_pass == pass)
      {
	cur_mask &= ti[i].insn_mask;
	ninstr++;
	last_match = i;
      }
  
  debug (8, "%08X %08lX\n", mask, cur_mask);

  if (ninstr == 0)
    return 0;

  if (ninstr == 1)
    {
      /* Leaf holds instruction index.  */
      debug (8, "%li>I%i %s\n",
	     (long)(cur - automata), last_match, or32_opcodes[last_match].name);

      *cur = LEAF_FLAG | last_match;
      cur++;
      nuncovered--;
    }
  else
    {
      /* Find longest match.  */
      for (i = 0; i < 32; i++)
	{
	  unsigned int len;

	  for (len = best_len + 1; len < MIN (MAX_LEN, 33 - i); len++)
	    {
	      unsigned long m = (1UL << ((unsigned long) len)) - 1;

	      debug (9, " (%i(%08lX & %08lX>>%i = %08lX, %08lX)",
		     len,m, cur_mask, i, (cur_mask >> (unsigned)i),
		     (cur_mask >> (unsigned) i) & m);

	      if ((m & (cur_mask >> (unsigned) i)) == m)
		{
		  best_len = len;
		  best_first = i;
		  debug (9, "!");
		}
	      else
		break;
	    }
	}

      debug (9, "\n");

      if (!best_len)
	{
	  fprintf (stderr, "%i instructions match mask 0x%08X:\n", ninstr, mask);

	  for (i = 0; i < or32_num_opcodes; i++)
	    if (ti[i].in_pass == pass)
	      fprintf (stderr, "%s ", or32_opcodes[i].name);
	  
	  fprintf (stderr, "\n");
	  exit (1);
	}

      debug (8, "%li> #### %i << %i (%i) ####\n",
	     (long)(cur - automata), best_len, best_first, ninstr);

      *cur = best_first;
      cur++;
      *cur = (1 << best_len) - 1;
      cur++;
      next = cur;    

      /* Allocate space for pointers.  */
      cur += 1 << best_len;
      cur_mask = (1 << (unsigned long) best_len) - 1;
      
      for (i = 0; i < ((unsigned) 1 << best_len); i++)
	{
	  unsigned int j;
	  unsigned long *c;

	  curpass++;
	  for (j = 0; j < or32_num_opcodes; j++)
	    if (ti[j].in_pass == pass
		&& ((ti[j].insn >> best_first) & cur_mask) == (unsigned long) i
		&& ((ti[j].insn_mask >> best_first) & cur_mask) == cur_mask)
	      ti[j].in_pass = curpass;

	  debug (9, "%08X %08lX %i\n", mask, cur_mask, best_first);
	  c = cover_insn (cur, curpass, mask & (~(cur_mask << best_first)));
	  if (c)
	    {
	      debug (8, "%li> #%X -> %lu\n", (long)(next - automata), i,
		     (unsigned long)(cur - automata));
	      *next = cur - automata;
	      cur = c;	 
	    }
	  else 
	    {
	      debug (8, "%li> N/A\n", (long)(next - automata));
	      *next = 0;
	    }
	  next++;
	}
    }
  return cur;
}

/* Returns number of nonzero bits.  */

static int
num_ones (unsigned long value)
{
  int c = 0;

  while (value)
    {
      if (value & 1)
	c++;
      value >>= 1;
    }
  return c;
}

/* Utility function, which converts parameters from or32_opcode
   format to more binary form.  Parameters are stored in ti struct.  */

static struct insn_op_struct *
parse_params (const struct or32_opcode * opcode,
	      struct insn_op_struct * cur)
{
  char *args = opcode->args;
  int i, type;
  
  i = 0;
  type = 0;
  /* In case we don't have any parameters, we add dummy read from r0.  */

  if (!(*args))
    {
      cur->type = OPTYPE_REG | OPTYPE_OP | OPTYPE_LAST;
      cur->data = 0;
      debug (9, "#%08lX %08lX\n", cur->type, cur->data);
      cur++;
      return cur;
  }
  
  while (*args != '\0')
    {     
      if (*args == 'r')
	{
	  args++;
	  type |= OPTYPE_REG;
	}
      else if (ISALPHA (*args))
	{
	  unsigned long arg;

	  arg = insn_extract (*args, opcode->encoding);
	  debug (9, "%s : %08lX ------\n", opcode->name, arg);
	  if (letter_signed (*args))
	    {
	      type |= OPTYPE_SIG;
	      type |= ((num_ones (arg) - 1) << OPTYPE_SBIT_SHR) & OPTYPE_SBIT;
	    }

	  /* Split argument to sequences of consecutive ones.  */
	  while (arg)
	    {
	      int shr = 0;
	      unsigned long tmp = arg, mask = 0;

	      while ((tmp & 1) == 0)
		{
		  shr++;
		  tmp >>= 1;
		}
	      while (tmp & 1)
		{
		  mask++;
		  tmp >>= 1;
		}
	      cur->type = type | shr;
	      cur->data = mask;
	      arg &= ~(((1 << mask) - 1) << shr);
	      debug (6, "|%08lX %08lX\n", cur->type, cur->data);
	      cur++;
	    }
	  args++;
	}
      else if (*args == '(')
	{
	  /* Next param is displacement.
	     Later we will treat them as one operand.  */
	  cur--;
	  cur->type = type | cur->type | OPTYPE_DIS | OPTYPE_OP;
	  debug (9, ">%08lX %08lX\n", cur->type, cur->data);
	  cur++;
	  type = 0;
	  i++;
	  args++;
	}
      else if (*args == OPERAND_DELIM)
	{
	  cur--;
	  cur->type = type | cur->type | OPTYPE_OP;
	  debug (9, ">%08lX %08lX\n", cur->type, cur->data);
	  cur++;
	  type = 0;
	  i++;
	  args++;
	}
      else if (*args == '0')
	{
	  cur->type = type;
	  cur->data = 0;
	  debug (9, ">%08lX %08lX\n", cur->type, cur->data);
	  cur++;
	  type = 0;
	  i++;
	  args++;
	}
      else if (*args == ')')
	args++;
      else
	{
	  fprintf (stderr, "%s : parse error in args.\n", opcode->name);
	  exit (1);
	}
    }

  cur--;
  cur->type = type | cur->type | OPTYPE_OP | OPTYPE_LAST;
  debug (9, "#%08lX %08lX\n", cur->type, cur->data);
  cur++;

  return cur;
}

/* Constructs new automata based on or32_opcodes array.  */

void
build_automata (void)
{
  unsigned int i;
  unsigned long *end;
  struct insn_op_struct *cur;
  
  automata = malloc (MAX_AUTOMATA_SIZE * sizeof (unsigned long));
  ti = malloc (sizeof (struct temp_insn_struct) * or32_num_opcodes);

  nuncovered = or32_num_opcodes;
  printf ("Building automata... ");
  /* Build temporary information about instructions.  */
  for (i = 0; i < or32_num_opcodes; i++)
    {
      unsigned long ones, zeros;
      char *encoding = or32_opcodes[i].encoding;

      ones  = insn_extract('1', encoding);
      zeros = insn_extract('0', encoding);

      ti[i].insn_mask = ones | zeros;
      ti[i].insn = ones;
      ti[i].in_pass = curpass = 0;

      /*debug(9, "%s: %s %08X %08X\n", or32_opcodes[i].name,
	or32_opcodes[i].encoding, ti[i].insn_mask, ti[i].insn);*/
    }
  
  /* Until all are covered search for best criteria to separate them.  */
  end = cover_insn (automata, curpass, 0xFFFFFFFF);

  if (end - automata > MAX_AUTOMATA_SIZE)
    {
      fprintf (stderr, "Automata too large. Increase MAX_AUTOMATA_SIZE.");
      exit (1);
    }

  printf ("done, num uncovered: %i/%i.\n", nuncovered, or32_num_opcodes);
  printf ("Parsing operands data... ");

  op_data = malloc (MAX_OP_TABLE_SIZE * sizeof (struct insn_op_struct));
  op_start = malloc (or32_num_opcodes * sizeof (struct insn_op_struct *));
  cur = op_data;

  for (i = 0; i < or32_num_opcodes; i++)
    {
      op_start[i] = cur;
      cur = parse_params (&or32_opcodes[i], cur);

      if (cur - op_data > MAX_OP_TABLE_SIZE)
	{
	  fprintf (stderr, "Operands table too small, increase MAX_OP_TABLE_SIZE.\n");
	  exit (1);
	}
    }
  printf ("done.\n");
}

void
destruct_automata (void)
{
  free (ti);
  free (automata);
  free (op_data);
  free (op_start);
}

/* Decodes instruction and returns instruction index.  */

int
insn_decode (unsigned int insn)
{
  unsigned long *a = automata;
  int i;

  while (!(*a & LEAF_FLAG))
    {
      unsigned int first = *a;

      debug (9, "%li ", (long)(a - automata));

      a++;
      i = (insn >> first) & *a;
      a++;
      if (!*(a + i))
	{
	  /* Invalid instruction found?  */
	  debug (9, "XXX\n");
	  return -1;
	}
      a = automata + *(a + i);
    }

  i = *a & ~LEAF_FLAG;

  debug (9, "%i\n", i);

  /* Final check - do we have direct match?
     (based on or32_opcodes this should be the only possibility,
     but in case of invalid/missing instruction we must perform a check)  */
  if ((ti[i].insn_mask & insn) == ti[i].insn) 
    return i;
  else
    return -1;
}

static char disassembled_str[50];
char *disassembled = &disassembled_str[0];

/* Automagically does zero- or sign- extension and also finds correct
   sign bit position if sign extension is correct extension. Which extension
   is proper is figured out from letter description.  */
   
static unsigned long
extend_imm (unsigned long imm, char l)
{
  unsigned long mask;
  int letter_bits;
  
  /* First truncate all bits above valid range for this letter
     in case it is zero extend.  */
  letter_bits = letter_range (l);
  mask = (1 << letter_bits) - 1;
  imm &= mask;
  
  /* Do sign extend if this is the right one.  */
  if (letter_signed(l) && (imm >> (letter_bits - 1)))
    imm |= (~mask);

  return imm;
}

static unsigned long
or32_extract (char param_ch, char *enc_initial, unsigned long insn)
{
  char *enc;
  unsigned long ret = 0;
  int opc_pos = 0;
  int param_pos = 0;

  for (enc = enc_initial; *enc != '\0'; enc++)
    if (*enc == param_ch)
      {
        if (enc - 2 >= enc_initial && (*(enc - 2) == '0') && (*(enc - 1) == 'x'))
      	  continue;
        else
          param_pos++;
      }

#if DEBUG
  printf ("or32_extract: %x ", param_pos);
#endif
  opc_pos = 32;

  for (enc = enc_initial; *enc != '\0'; )
    if ((*enc == '0') && (*(enc + 1) == 'x')) 
      {
        opc_pos -= 4;
        if ((param_ch == '0') || (param_ch == '1')) 
          {
            unsigned long tmp = strtol (enc, NULL, 16);
#if DEBUG
            printf (" enc=%s, tmp=%lx ", enc, tmp);
#endif
            if (param_ch == '0')
              tmp = 15 - tmp;
            ret |= tmp << opc_pos;
          }
        enc += 3;
      }
    else if ((*enc == '0') || (*enc == '1')) 
      {
        opc_pos--;
        if (param_ch == *enc)
          ret |= 1 << opc_pos;
        enc++;
      }
    else if (*enc == param_ch) 
      {
        opc_pos--;
        param_pos--;
#if DEBUG
        printf ("\n  ret=%lx opc_pos=%x, param_pos=%x\n", ret, opc_pos, param_pos);
#endif  
        if (ISLOWER (param_ch))
          ret -= ((insn >> opc_pos) & 0x1) << param_pos;
        else
          ret += ((insn >> opc_pos) & 0x1) << param_pos;
        enc++;
      }
    else if (ISALPHA (*enc)) 
      {
        opc_pos--;
        enc++;
      }
    else if (*enc == '-') 
      {
        opc_pos--;
        enc++;
      }
    else
      enc++;

#if DEBUG
  printf ("ret=%lx\n", ret);
#endif
  return ret;
}

/* Print register. Used only by print_insn.  */

static void
or32_print_register (char param_ch, char *encoding, unsigned long insn)
{
  int regnum = or32_extract(param_ch, encoding, insn);
  char s_regnum[20];

  sprintf (s_regnum, "r%d", regnum);
  strcat (disassembled, s_regnum);
}

/* Print immediate. Used only by print_insn.  */

static void
or32_print_immediate (char param_ch, char *encoding, unsigned long insn)
{
  int imm = or32_extract (param_ch, encoding, insn);
  char s_imm[20];

  imm = extend_imm (imm, param_ch);

  if (letter_signed (param_ch))
    {
      if (imm < 0)
	sprintf (s_imm, "%d", imm);
      else
	sprintf (s_imm, "0x%x", imm);
    }
  else
    sprintf (s_imm, "%#x", imm);
  strcat (disassembled, s_imm);
}

/* Disassemble one instruction from insn to disassemble.
   Return the size of the instruction.  */

int
disassemble_insn (unsigned long insn)
{
  int op_index;
  op_index = insn_decode (insn);

  if (op_index >= 0)
    {
      struct or32_opcode const *opcode = &or32_opcodes[op_index];
      char *s;

      sprintf (disassembled, "%s ", opcode->name);
      for (s = opcode->args; *s != '\0'; ++s)
        {
          switch (*s)
            {
            case '\0':
              return 4;
  
            case 'r':
              or32_print_register (*++s, opcode->encoding, insn);
              break;
  
            default:
              if (strchr (opcode->encoding, *s))
                or32_print_immediate (*s, opcode->encoding, insn);
              else
		{
		  char s_encoding[2] = { *s, '\0' };

		  strcat (disassembled, s_encoding);
		}

            }
        }
    }
  else
    {
      char s_insn[20];

      /* This used to be %8x for binutils.  */
      sprintf (s_insn, ".word 0x%08lx", insn);
      strcat (disassembled, s_insn);
    }

  return insn_len (insn);
}
@


1.11
log
@Fix build with -DDEBUG=7
@
text
@d2 2
a3 1
   Copyright 2002, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
d23 1
a23 2
/* We treat all letters the same in encode/decode routines so
   we need to assign some characteristics to them like signess etc.  */
a28 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
d31 3
@


1.10
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d901 1
a901 1
            printf (" enc=%s, tmp=%x ", enc, tmp);
d921 1
a921 1
        printf ("\n  ret=%x opc_pos=%x, param_pos=%x\n", ret, opc_pos, param_pos);
d943 1
a943 1
  printf ("ret=%x\n", ret);
@


1.9
log
@        * or32-opc.c (or32_print_register, or32_print_immediate,
        disassemble_insn): Don't rely on undefined sprintf behaviour.

        * itbl-ops.c (itbl_disassemble): Don't rely on undefined sprintf
        behaviour.
@
text
@d348 1
a348 1
insn_len (int insn_index ATTRIBUTE_UNUSED)
d412 1
a412 1
insn_name (int index)
d414 2
a415 2
  if (index >= 0 && index < (int) or32_num_opcodes)
    return or32_opcodes[index].name;
d988 2
a989 2
  int index;
  index = insn_decode (insn);
d991 1
a991 1
  if (index >= 0)
d993 1
a993 1
      struct or32_opcode const *opcode = &or32_opcodes[index];
@


1.8
log
@Silence gcc printf warnings
@
text
@d2 1
a2 1
   Copyright 2002, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
d954 4
a957 2
  
  sprintf (disassembled, "%sr%d", disassembled, regnum);
d966 1
d969 1
a969 1
  
d973 1
a973 1
        sprintf (disassembled, "%s%d", disassembled, imm);
d975 1
a975 1
        sprintf (disassembled, "%s0x%x", disassembled, imm);
d978 2
a979 1
    sprintf (disassembled, "%s%#x", disassembled, imm);
d1012 6
a1017 1
                sprintf (disassembled, "%s%c", disassembled, *s);
d1023 2
d1026 2
a1027 1
      sprintf (disassembled, "%s.word 0x%08lx", disassembled, insn);
@


1.7
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 2002, 2004, 2005, 2007 Free Software Foundation, Inc.
d589 2
a590 1
	      debug (8, "%li> #%X -> %lu\n", (long)(next - automata), i, (long)(cur - automata));
@


1.6
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d2 1
a2 1
   Copyright 2002, 2004, 2005 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of gen_or1k_isa, or1k, GDB and GAS.
d7 1
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.5
log
@Update function declarations to ISO C90 formatting
@
text
@d337 1
a337 1
static void
d505 1
a505 1
  debug (8, "%08X %08X\n", mask, cur_mask);
d513 2
a514 2
      debug (8, "%i>I%i %s\n",
	     cur - automata, last_match, or32_opcodes[last_match].name);
d531 1
a531 1
	      debug (9, " (%i(%08X & %08X>>%i = %08X, %08X)",
d560 2
a561 2
      debug (8, "%i> #### %i << %i (%i) ####\n",
	     cur - automata, best_len, best_first, ninstr);
d585 1
a585 1
	  debug (9, "%08X %08X %i\n", mask, cur_mask, best_first);
d589 1
a589 1
	      debug (8, "%i> #%X -> %u\n", next - automata, i, cur - automata);
d595 1
a595 1
	      debug (8, "%i> N/A\n", next - automata);
d638 1
a638 1
      debug (9, "#%08X %08X\n", cur->type, cur->data);
d655 1
a655 1
	  debug (9, "%s : %08X ------\n", opcode->name, arg);
d681 1
a681 1
	      debug (6, "|%08X %08X\n", cur->type, cur->data);
d692 1
a692 1
	  debug (9, ">%08X %08X\n", cur->type, cur->data);
d702 1
a702 1
	  debug (9, ">%08X %08X\n", cur->type, cur->data);
d712 1
a712 1
	  debug (9, ">%08X %08X\n", cur->type, cur->data);
d729 1
a729 1
  debug (9, "#%08X %08X\n", cur->type, cur->data);
d817 1
a817 1
      debug (9, "%i ", a - automata);
d825 1
a825 1
	  debug (9, "XXX\n", i);
@


1.4
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 2002, 2004 Free Software Foundation, Inc.
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a33 9
static unsigned long           insn_extract         PARAMS ((char, char *));
static unsigned long *         cover_insn           PARAMS ((unsigned long *, int, unsigned int));
static int                     num_ones             PARAMS ((unsigned long));
static struct insn_op_struct * parse_params         PARAMS ((const struct or32_opcode *, struct insn_op_struct *));
static unsigned long           or32_extract         PARAMS ((char, char *, unsigned long));
static void                    or32_print_register  PARAMS ((char, char *, unsigned long));
static void                    or32_print_immediate PARAMS ((char, char *, unsigned long));
static unsigned long           extend_imm           PARAMS ((unsigned long, char));

d35 11
a45 11
  {
    { 'A', NUM_UNSIGNED },
    { 'B', NUM_UNSIGNED },
    { 'D', NUM_UNSIGNED },
    { 'I', NUM_SIGNED },
    { 'K', NUM_UNSIGNED },
    { 'L', NUM_UNSIGNED },
    { 'N', NUM_SIGNED },
    { '0', NUM_UNSIGNED },
    { '\0', 0 }     /* Dummy entry.  */
  };
d71 192
a262 192
  {
    { "l.j",       "N",            "00 0x0  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_j), OR32_IF_DELAY },
    { "l.jal",     "N",            "00 0x1  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_jal), OR32_IF_DELAY },
    { "l.bnf",     "N",            "00 0x3  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_bnf), OR32_IF_DELAY | OR32_R_FLAG},
    { "l.bf",      "N",            "00 0x4  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_bf), OR32_IF_DELAY | OR32_R_FLAG },
    { "l.nop",     "K",            "00 0x5  01--- ----- KKKK KKKK KKKK KKKK", EF(l_nop), 0 },
    { "l.movhi",   "rD,K",         "00 0x6  DDDDD ----0 KKKK KKKK KKKK KKKK", EF(l_movhi), 0 }, /*MM*/
    { "l.macrc",   "rD",           "00 0x6  DDDDD ----1 0000 0000 0000 0000", EF(l_macrc), 0 }, /*MM*/

    { "l.sys",     "K",            "00 0x8  00000 00000 KKKK KKKK KKKK KKKK", EF(l_sys), 0 },
    { "l.trap",    "K",            "00 0x8  01000 00000 KKKK KKKK KKKK KKKK", EF(l_trap), 0 }, /* CZ 21/06/01 */
    { "l.msync",   "",             "00 0x8  10000 00000 0000 0000 0000 0000", EFN, 0 },
    { "l.psync",   "",             "00 0x8  10100 00000 0000 0000 0000 0000", EFN, 0 },
    { "l.csync",   "",             "00 0x8  11000 00000 0000 0000 0000 0000", EFN, 0 },
    { "l.rfe",     "",             "00 0x9  ----- ----- ---- ---- ---- ----", EF(l_rfe), OR32_IF_DELAY },

    { "lv.all_eq.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
    { "lv.all_eq.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x1", EFI, 0 },
    { "lv.all_ge.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x2", EFI, 0 },
    { "lv.all_ge.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x3", EFI, 0 },
    { "lv.all_gt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x4", EFI, 0 },
    { "lv.all_gt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x5", EFI, 0 },
    { "lv.all_le.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x6", EFI, 0 },
    { "lv.all_le.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x7", EFI, 0 },
    { "lv.all_lt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x8", EFI, 0 },
    { "lv.all_lt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x9", EFI, 0 },
    { "lv.all_ne.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0xA", EFI, 0 },
    { "lv.all_ne.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0xB", EFI, 0 },
    { "lv.any_eq.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x0", EFI, 0 },
    { "lv.any_eq.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x1", EFI, 0 },
    { "lv.any_ge.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x2", EFI, 0 },
    { "lv.any_ge.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x3", EFI, 0 },
    { "lv.any_gt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x4", EFI, 0 },
    { "lv.any_gt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x5", EFI, 0 },
    { "lv.any_le.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x6", EFI, 0 },
    { "lv.any_le.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x7", EFI, 0 },
    { "lv.any_lt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x8", EFI, 0 },
    { "lv.any_lt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x9", EFI, 0 },
    { "lv.any_ne.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0xA", EFI, 0 },
    { "lv.any_ne.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0xB", EFI, 0 },
    { "lv.add.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x0", EFI, 0 },
    { "lv.add.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x1", EFI, 0 },
    { "lv.adds.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x2", EFI, 0 },
    { "lv.adds.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x3", EFI, 0 },
    { "lv.addu.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x4", EFI, 0 },
    { "lv.addu.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x5", EFI, 0 },
    { "lv.addus.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x6", EFI, 0 },
    { "lv.addus.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x7", EFI, 0 },
    { "lv.and",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x8", EFI, 0 },
    { "lv.avg.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x9", EFI, 0 },
    { "lv.avg.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0xA", EFI, 0 },
    { "lv.cmp_eq.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x0", EFI, 0 },
    { "lv.cmp_eq.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x1", EFI, 0 },
    { "lv.cmp_ge.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x2", EFI, 0 },
    { "lv.cmp_ge.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x3", EFI, 0 },
    { "lv.cmp_gt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x4", EFI, 0 },
    { "lv.cmp_gt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x5", EFI, 0 },
    { "lv.cmp_le.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x6", EFI, 0 },
    { "lv.cmp_le.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x7", EFI, 0 },
    { "lv.cmp_lt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x8", EFI, 0 },
    { "lv.cmp_lt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x9", EFI, 0 },
    { "lv.cmp_ne.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0xA", EFI, 0 },
    { "lv.cmp_ne.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0xB", EFI, 0 },
    { "lv.madds.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x4", EFI, 0 },
    { "lv.max.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x5", EFI, 0 },
    { "lv.max.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x6", EFI, 0 },
    { "lv.merge.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x7", EFI, 0 },
    { "lv.merge.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x8", EFI, 0 },
    { "lv.min.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x9", EFI, 0 },
    { "lv.min.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xA", EFI, 0 },
    { "lv.msubs.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xB", EFI, 0 },
    { "lv.muls.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xC", EFI, 0 },
    { "lv.nand",   "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xD", EFI, 0 },
    { "lv.nor",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xE", EFI, 0 },
    { "lv.or",     "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xF", EFI, 0 },
    { "lv.pack.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x0", EFI, 0 },
    { "lv.pack.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x1", EFI, 0 },
    { "lv.packs.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x2", EFI, 0 },
    { "lv.packs.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x3", EFI, 0 },
    { "lv.packus.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x4", EFI, 0 },
    { "lv.packus.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x5", EFI, 0 },
    { "lv.perm.n", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x6", EFI, 0 },
    { "lv.rl.b",   "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x7", EFI, 0 },
    { "lv.rl.h",   "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x8", EFI, 0 },
    { "lv.sll.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x9", EFI, 0 },
    { "lv.sll.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xA", EFI, 0 },
    { "lv.sll",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xB", EFI, 0 },
    { "lv.srl.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xC", EFI, 0 },
    { "lv.srl.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xD", EFI, 0 },
    { "lv.sra.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xE", EFI, 0 },
    { "lv.sra.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xF", EFI, 0 },
    { "lv.srl",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x0", EFI, 0 },
    { "lv.sub.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x1", EFI, 0 },
    { "lv.sub.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x2", EFI, 0 },
    { "lv.subs.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x3", EFI, 0 },
    { "lv.subs.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x4", EFI, 0 },
    { "lv.subu.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x5", EFI, 0 },
    { "lv.subu.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x6", EFI, 0 },
    { "lv.subus.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x7", EFI, 0 },
    { "lv.subus.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x8", EFI, 0 },
    { "lv.unpack.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x9", EFI, 0 },
    { "lv.unpack.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0xA", EFI, 0 },
    { "lv.xor",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0xB", EFI, 0 },
    { "lv.cust1",  "",	       "00 0xA  ----- ----- ---- ---- 0xC ----", EFI, 0 },
    { "lv.cust2",  "",	       "00 0xA  ----- ----- ---- ---- 0xD ----", EFI, 0 },
    { "lv.cust3",  "",	       "00 0xA  ----- ----- ---- ---- 0xE ----", EFI, 0 },
    { "lv.cust4",  "",	       "00 0xA  ----- ----- ---- ---- 0xF ----", EFI, 0 },

    { "lf.add.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
    { "lf.sub.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x1", EFI, 0 },
    { "lf.mul.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x2", EFI, 0 },
    { "lf.div.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x3", EFI, 0 },
    { "lf.itof.s",  "rD,rA",       "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x4", EFI, 0 },
    { "lf.ftoi.s",  "rD,rA",       "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x5", EFI, 0 },
    { "lf.rem.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x6", EFI, 0 },
    { "lf.madd.s",  "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x7", EFI, 0 },
    { "lf.sfeq.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0x8", EFI, 0 },
    { "lf.sfne.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0x9", EFI, 0 },
    { "lf.sfgt.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xA", EFI, 0 },
    { "lf.sfge.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xB", EFI, 0 },
    { "lf.sflt.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xC", EFI, 0 },
    { "lf.sfle.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xD", EFI, 0 },
    { "lf.cust1.s", "",	       "00 0xB  ----- ----- ---- ---- 0xE ----", EFI, 0 },

    { "lf.add.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
    { "lf.sub.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x1", EFI, 0 },
    { "lf.mul.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x2", EFI, 0 },
    { "lf.div.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x3", EFI, 0 },
    { "lf.itof.d",  "rD,rA",       "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x4", EFI, 0 },
    { "lf.ftoi.d",  "rD,rA",       "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x5", EFI, 0 },
    { "lf.rem.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x6", EFI, 0 },
    { "lf.madd.d",  "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x7", EFI, 0 },
    { "lf.sfeq.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0x8", EFI, 0 },
    { "lf.sfne.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0x9", EFI, 0 },
    { "lf.sfgt.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xA", EFI, 0 },
    { "lf.sfge.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xB", EFI, 0 },
    { "lf.sflt.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xC", EFI, 0 },
    { "lf.sfle.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xD", EFI, 0 },
    { "lf.cust1.d", "",	       "00 0xC  ----- ----- ---- ---- 0xE ----", EFI, 0 },

    { "lvf.ld",     "rD,0(rA)",    "00 0xD  DDDDD AAAAA ---- ---- 0x0 0x0", EFI, 0 },
    { "lvf.lw",     "rD,0(rA)",    "00 0xD  DDDDD AAAAA ---- ---- 0x0 0x1", EFI, 0 },
    { "lvf.sd",     "0(rA),rB",    "00 0xD  ----- AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
    { "lvf.sw",     "0(rA),rB",    "00 0xD  ----- AAAAA BBBB B--- 0x1 0x1", EFI, 0 },

    { "l.jr",      "rB",           "01 0x1  ----- ----- BBBB B--- ---- ----", EF(l_jr), OR32_IF_DELAY },
    { "l.jalr",    "rB",           "01 0x2  ----- ----- BBBB B--- ---- ----", EF(l_jalr), OR32_IF_DELAY },
    { "l.maci",    "rB,I",         "01 0x3  IIIII ----- BBBB BIII IIII IIII", EF(l_mac), 0 },
    { "l.cust1",   "",	       "01 0xC  ----- ----- ---- ---- ---- ----", EF(l_cust1), 0 },
    { "l.cust2",   "",	       "01 0xD  ----- ----- ---- ---- ---- ----", EF(l_cust2), 0 },
    { "l.cust3",   "",	       "01 0xE  ----- ----- ---- ---- ---- ----", EF(l_cust3), 0 },
    { "l.cust4",   "",	       "01 0xF  ----- ----- ---- ---- ---- ----", EF(l_cust4), 0 },

    { "l.ld",      "rD,I(rA)",     "10 0x0  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
    { "l.lwz",     "rD,I(rA)",     "10 0x1  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lwz), 0 },
    { "l.lws",     "rD,I(rA)",     "10 0x2  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
    { "l.lbz",     "rD,I(rA)",     "10 0x3  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lbz), 0 },
    { "l.lbs",     "rD,I(rA)",     "10 0x4  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lbs), 0 },
    { "l.lhz",     "rD,I(rA)",     "10 0x5  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lhz), 0 },
    { "l.lhs",     "rD,I(rA)",     "10 0x6  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lhs), 0 },

    { "l.addi",    "rD,rA,I",      "10 0x7  DDDDD AAAAA IIII IIII IIII IIII", EF(l_add), 0 },
    { "l.addic",   "rD,rA,I",      "10 0x8  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
    { "l.andi",    "rD,rA,K",      "10 0x9  DDDDD AAAAA KKKK KKKK KKKK KKKK", EF(l_and), 0 },
    { "l.ori",     "rD,rA,K",      "10 0xA  DDDDD AAAAA KKKK KKKK KKKK KKKK", EF(l_or), 0  },
    { "l.xori",    "rD,rA,I",      "10 0xB  DDDDD AAAAA IIII IIII IIII IIII", EF(l_xor), 0 },
    { "l.muli",    "rD,rA,I",      "10 0xC  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
    { "l.mfspr",   "rD,rA,K",      "10 0xD  DDDDD AAAAA KKKK KKKK KKKK KKKK", EF(l_mfspr), 0 },
    { "l.slli",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 00LL LLLL", EF(l_sll), 0 },
    { "l.srli",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 01LL LLLL", EF(l_srl), 0 },
    { "l.srai",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 10LL LLLL", EF(l_sra), 0 },
    { "l.rori",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 11LL LLLL", EFI, 0 },

    { "l.sfeqi",   "rA,I",         "10 0xF  00000 AAAAA IIII IIII IIII IIII", EF(l_sfeq), OR32_W_FLAG },
    { "l.sfnei",   "rA,I",         "10 0xF  00001 AAAAA IIII IIII IIII IIII", EF(l_sfne), OR32_W_FLAG },
    { "l.sfgtui",  "rA,I",         "10 0xF  00010 AAAAA IIII IIII IIII IIII", EF(l_sfgtu), OR32_W_FLAG },
    { "l.sfgeui",  "rA,I",         "10 0xF  00011 AAAAA IIII IIII IIII IIII", EF(l_sfgeu), OR32_W_FLAG },
    { "l.sfltui",  "rA,I",         "10 0xF  00100 AAAAA IIII IIII IIII IIII", EF(l_sfltu), OR32_W_FLAG },
    { "l.sfleui",  "rA,I",         "10 0xF  00101 AAAAA IIII IIII IIII IIII", EF(l_sfleu), OR32_W_FLAG },
    { "l.sfgtsi",  "rA,I",         "10 0xF  01010 AAAAA IIII IIII IIII IIII", EF(l_sfgts), OR32_W_FLAG },
    { "l.sfgesi",  "rA,I",         "10 0xF  01011 AAAAA IIII IIII IIII IIII", EF(l_sfges), OR32_W_FLAG },
    { "l.sfltsi",  "rA,I",         "10 0xF  01100 AAAAA IIII IIII IIII IIII", EF(l_sflts), OR32_W_FLAG },
    { "l.sflesi",  "rA,I",         "10 0xF  01101 AAAAA IIII IIII IIII IIII", EF(l_sfles), OR32_W_FLAG },

    { "l.mtspr",   "rA,rB,K",      "11 0x0  KKKKK AAAAA BBBB BKKK KKKK KKKK", EF(l_mtspr), 0 },
    { "l.mac",     "rA,rB",        "11 0x1  ----- AAAAA BBBB B--- ---- 0x1", EF(l_mac), 0 }, /*MM*/
    { "l.msb",     "rA,rB",        "11 0x1  ----- AAAAA BBBB B--- ---- 0x2", EF(l_msb), 0 }, /*MM*/

    { "l.sd",      "I(rA),rB",     "11 0x4  IIIII AAAAA BBBB BIII IIII IIII", EFI, 0 },
    { "l.sw",      "I(rA),rB",     "11 0x5  IIIII AAAAA BBBB BIII IIII IIII", EF(l_sw), 0 },
    { "l.sb",      "I(rA),rB",     "11 0x6  IIIII AAAAA BBBB BIII IIII IIII", EF(l_sb), 0 },
    { "l.sh",      "I(rA),rB",     "11 0x7  IIIII AAAAA BBBB BIII IIII IIII", EF(l_sh), 0 },
d264 39
a302 39
    { "l.add",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x0", EF(l_add), 0 },
    { "l.addc",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x1", EFI, 0 },
    { "l.sub",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x2", EF(l_sub), 0 },
    { "l.and",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x3", EF(l_and), 0 },
    { "l.or",      "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x4", EF(l_or), 0 },
    { "l.xor",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x5", EF(l_xor), 0 },
    { "l.mul",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-11 ---- 0x6", EF(l_mul), 0 },

    { "l.sll",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 00-- 0x8", EF(l_sll), 0 },
    { "l.srl",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 01-- 0x8", EF(l_srl), 0 },
    { "l.sra",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 10-- 0x8", EF(l_sra), 0 },
    { "l.ror",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 11-- 0x8", EFI, 0 },
    { "l.div",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x9", EF(l_div), 0 },
    { "l.divu",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0xA", EF(l_divu), 0 },
    { "l.mulu",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-11 ---- 0xB", EFI, 0 },
    { "l.exths",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 00-- 0xC", EFI, 0 },
    { "l.extbs",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 01-- 0xC", EFI, 0 },
    { "l.exthz",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 10-- 0xC", EFI, 0 },
    { "l.extbz",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 11-- 0xC", EFI, 0 },
    { "l.extws",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 00-- 0xD", EFI, 0 },
    { "l.extwz",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 01-- 0xD", EFI, 0 },
    { "l.cmov",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0xE", EFI, 0 },
    { "l.ff1",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0xF", EFI, 0 },

    { "l.sfeq",    "rA,rB",        "11 0x9  00000 AAAAA BBBB B--- ---- ----", EF(l_sfeq), OR32_W_FLAG },
    { "l.sfne",    "rA,rB",        "11 0x9  00001 AAAAA BBBB B--- ---- ----", EF(l_sfne), OR32_W_FLAG },
    { "l.sfgtu",   "rA,rB",        "11 0x9  00010 AAAAA BBBB B--- ---- ----", EF(l_sfgtu), OR32_W_FLAG },
    { "l.sfgeu",   "rA,rB",        "11 0x9  00011 AAAAA BBBB B--- ---- ----", EF(l_sfgeu), OR32_W_FLAG },
    { "l.sfltu",   "rA,rB",        "11 0x9  00100 AAAAA BBBB B--- ---- ----", EF(l_sfltu), OR32_W_FLAG },
    { "l.sfleu",   "rA,rB",        "11 0x9  00101 AAAAA BBBB B--- ---- ----", EF(l_sfleu), OR32_W_FLAG },
    { "l.sfgts",   "rA,rB",        "11 0x9  01010 AAAAA BBBB B--- ---- ----", EF(l_sfgts), OR32_W_FLAG },
    { "l.sfges",   "rA,rB",        "11 0x9  01011 AAAAA BBBB B--- ---- ----", EF(l_sfges), OR32_W_FLAG },
    { "l.sflts",   "rA,rB",        "11 0x9  01100 AAAAA BBBB B--- ---- ----", EF(l_sflts), OR32_W_FLAG },
    { "l.sfles",   "rA,rB",        "11 0x9  01101 AAAAA BBBB B--- ---- ----", EF(l_sfles), OR32_W_FLAG },

    { "l.cust5",   "",	       "11 0xC  ----- ----- ---- ---- ---- ----", EFI, 0 },
    { "l.cust6",   "",	       "11 0xD  ----- ----- ---- ---- ---- ----", EFI, 0 },
    { "l.cust7",   "",	       "11 0xE  ----- ----- ---- ---- ---- ----", EFI, 0 },
    { "l.cust8",   "",	       "11 0xF  ----- ----- ---- ---- ---- ----", EFI, 0 },
d304 2
a305 2
    /* This section should not be defined in or1ksim, since it contains duplicates,
       which would cause machine builder to complain.  */
d307 15
a321 15
    { "l.cust5_1",   "rD",	       "11 0xC  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
    { "l.cust5_2",   "rD,rA"   ,   "11 0xC  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
    { "l.cust5_3",   "rD,rA,rB",   "11 0xC  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },

    { "l.cust6_1",   "rD",	       "11 0xD  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
    { "l.cust6_2",   "rD,rA"   ,   "11 0xD  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
    { "l.cust6_3",   "rD,rA,rB",   "11 0xD  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },

    { "l.cust7_1",   "rD",	       "11 0xE  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
    { "l.cust7_2",   "rD,rA"   ,   "11 0xE  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
    { "l.cust7_3",   "rD,rA,rB",   "11 0xE  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },

    { "l.cust8_1",   "rD",	       "11 0xF  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
    { "l.cust8_2",   "rD,rA"   ,   "11 0xF  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
    { "l.cust8_3",   "rD,rA,rB",   "11 0xF  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },
d324 4
a327 4
    /* Dummy entry, not included in num_opcodes.  This
       lets code examine entry i+1 without checking
       if we've run off the end of the table.  */
    { "", "", "", EFI, 0 }
a336 2
static void debug PARAMS ((int, const char *, ...));

d348 1
a348 2
insn_len (insn_index)
     int insn_index ATTRIBUTE_UNUSED;
d356 1
a356 2
letter_signed (l)
     char l;
d371 1
a371 2
letter_range (l)
     char l;
d377 1
a377 1
  for (pinsn = or32_opcodes; strlen(pinsn->name); pinsn++)
d381 2
a382 2
	  for (enc = pinsn->encoding; *enc != '\0'; enc++)
	    if ((*enc == '0') && (*(enc+1) == 'x'))
d412 1
a412 2
insn_name (index)
     int index;
d421 1
a421 1
l_none ()
d428 1
d430 1
a430 3
insn_extract (param_ch, enc_initial)
     char param_ch;
     char *enc_initial;
d463 4
a466 4
#define MAX_AUTOMATA_SIZE (1200)
#define MAX_OP_TABLE_SIZE (1200)
#define LEAF_FLAG         (0x80000000)
#define MAX_LEN           (8)
d469 1
a469 1
# define MIN(x,y)          ((x) < (y) ? (x) : (y))
d489 1
a489 4
cover_insn (cur, pass, mask)
     unsigned long * cur;
     int pass;
     unsigned int mask;
d529 1
a529 1
	      unsigned long m = (1UL << ((unsigned long)len)) - 1;
d533 1
a533 1
		     (cur_mask >> (unsigned)i) & m);
d535 1
a535 1
	      if ((m & (cur_mask >> (unsigned)i)) == m)
d571 1
a571 1
      cur_mask = (1 << (unsigned long)best_len) - 1;
d607 1
a607 2
num_ones (value)
     unsigned long value;
d620 2
a621 2
/* Utility function, which converts parameters from or32_opcode format to more binary form.  
   Parameters are stored in ti struct.  */
d624 2
a625 3
parse_params (opcode, cur)
     const struct or32_opcode * opcode;
     struct insn_op_struct * cur;
d688 2
a689 1
	  /* Next param is displacement.  Later we will treat them as one operand.  */
d738 1
a738 1
build_automata ()
d744 2
a745 2
  automata = (unsigned long *) malloc (MAX_AUTOMATA_SIZE * sizeof (unsigned long));
  ti = (struct temp_insn_struct *) malloc (sizeof (struct temp_insn_struct) * or32_num_opcodes);
d778 2
a779 2
  op_data = (struct insn_op_struct *) malloc (MAX_OP_TABLE_SIZE * sizeof (struct insn_op_struct));
  op_start = (struct insn_op_struct **) malloc (or32_num_opcodes * sizeof (struct insn_op_struct *));
d797 1
a797 1
destruct_automata ()
d808 1
a808 2
insn_decode (insn)
     unsigned int insn;
d852 1
a852 3
extend_imm (imm, l)
     unsigned long imm;
     char l;
d871 1
a871 4
or32_extract (param_ch, enc_initial, insn)
     char param_ch;
     char *enc_initial;
     unsigned long insn;
d950 1
a950 4
or32_print_register (param_ch, encoding, insn)
     char param_ch;
     char *encoding;
     unsigned long insn;
d960 1
a960 4
or32_print_immediate (param_ch, encoding, insn)
     char param_ch;
     char *encoding;
     unsigned long insn;
d981 1
a981 2
disassemble_insn (insn)
     unsigned long insn;
@


1.3
log
@	* or32-opc.c (debug): Warning fix.
	* po/POTFILES.in: Regenerate.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.2
log
@Fix compile time warning messages
@
text
@d2 1
a2 1
   Copyright 2002 Free Software Foundation, Inc.
d348 1
a348 1
debug (int level, const char *format, ...)
a349 2
  /* Just to get rid of warnings.  */
  format = (char *) level = 0;
@


1.1
log
@Add support for OpenRISC 32-bit embedded processor
@
text
@d351 1
a351 1
  format = level = 0;
d414 2
a415 1
  int i, found = -1;
d430 1
a430 1
  if (index >= 0 && index < or32_num_opcodes)
d511 3
a513 1
  int best_first = 0, best_len = 0, i, last_match = -1, ninstr = 0;
d545 1
a545 1
	  int len;
d593 1
a593 1
      for (i = 0; i < (1 << (unsigned long)best_len); i++)
d595 1
a595 1
	  int j;
d761 1
a761 1
  int i;
@

