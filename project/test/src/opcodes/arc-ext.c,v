head	1.8;
access;
symbols
	sid-snapshot-20180601:1.8
	sid-snapshot-20180501:1.8
	sid-snapshot-20180401:1.8
	sid-snapshot-20180301:1.8
	sid-snapshot-20180201:1.8
	sid-snapshot-20180101:1.8
	sid-snapshot-20171201:1.8
	sid-snapshot-20171101:1.8
	sid-snapshot-20171001:1.8
	sid-snapshot-20170901:1.8
	sid-snapshot-20170801:1.8
	sid-snapshot-20170701:1.8
	sid-snapshot-20170601:1.8
	sid-snapshot-20170501:1.8
	sid-snapshot-20170401:1.8
	sid-snapshot-20170301:1.8
	sid-snapshot-20170201:1.8
	sid-snapshot-20170101:1.8
	sid-snapshot-20161201:1.8
	sid-snapshot-20161101:1.8
	sid-snapshot-20160901:1.8
	sid-snapshot-20160801:1.8
	sid-snapshot-20160701:1.8
	sid-snapshot-20160601:1.8
	sid-snapshot-20160501:1.8
	sid-snapshot-20160401:1.8
	sid-snapshot-20160301:1.8
	sid-snapshot-20160201:1.8
	sid-snapshot-20160101:1.8
	sid-snapshot-20151201:1.8
	sid-snapshot-20151101:1.8
	sid-snapshot-20151001:1.8
	sid-snapshot-20150901:1.8
	sid-snapshot-20150801:1.8
	sid-snapshot-20150701:1.8
	sid-snapshot-20150601:1.8
	sid-snapshot-20150501:1.8
	sid-snapshot-20150401:1.8
	sid-snapshot-20150301:1.8
	sid-snapshot-20150201:1.8
	sid-snapshot-20150101:1.8
	sid-snapshot-20141201:1.8
	sid-snapshot-20141101:1.8
	sid-snapshot-20141001:1.8
	sid-snapshot-20140901:1.8
	sid-snapshot-20140801:1.8
	sid-snapshot-20140701:1.8
	sid-snapshot-20140601:1.8
	sid-snapshot-20140501:1.8
	sid-snapshot-20140401:1.8
	sid-snapshot-20140301:1.8
	sid-snapshot-20140201:1.8
	sid-snapshot-20140101:1.8
	sid-snapshot-20131201:1.8
	sid-snapshot-20131101:1.8
	sid-snapshot-20131001:1.8
	binutils-2_24-branch:1.8.0.22
	binutils-2_24-branchpoint:1.8
	binutils-2_21_1:1.8
	sid-snapshot-20130901:1.8
	gdb_7_6_1-2013-08-30-release:1.8
	sid-snapshot-20130801:1.8
	sid-snapshot-20130701:1.8
	sid-snapshot-20130601:1.8
	sid-snapshot-20130501:1.8
	gdb_7_6-2013-04-26-release:1.8
	sid-snapshot-20130401:1.8
	binutils-2_23_2:1.8
	gdb_7_6-branch:1.8.0.20
	gdb_7_6-2013-03-12-branchpoint:1.8
	sid-snapshot-20130301:1.8
	sid-snapshot-20130201:1.8
	sid-snapshot-20130101:1.8
	sid-snapshot-20121201:1.8
	gdb_7_5_1-2012-11-29-release:1.8
	binutils-2_23_1:1.8
	sid-snapshot-20121101:1.8
	binutils-2_23:1.8
	sid-snapshot-20121001:1.8
	sid-snapshot-20120901:1.8
	gdb_7_5-2012-08-17-release:1.8
	sid-snapshot-20120801:1.8
	binutils-2_23-branch:1.8.0.18
	binutils-2_23-branchpoint:1.8
	gdb_7_5-branch:1.8.0.16
	gdb_7_5-2012-07-18-branchpoint:1.8
	sid-snapshot-20120701:1.8
	sid-snapshot-20120601:1.8
	sid-snapshot-20120501:1.8
	binutils-2_22_branch:1.8.0.14
	gdb_7_4_1-2012-04-26-release:1.8
	sid-snapshot-20120401:1.8
	sid-snapshot-20120301:1.8
	sid-snapshot-20120201:1.8
	gdb_7_4-2012-01-24-release:1.8
	sid-snapshot-20120101:1.8
	gdb_7_4-branch:1.8.0.12
	gdb_7_4-2011-12-13-branchpoint:1.8
	sid-snapshot-20111201:1.8
	binutils-2_22:1.8
	sid-snapshot-20111101:1.8
	sid-snapshot-20111001:1.8
	binutils-2_22-branch:1.8.0.10
	binutils-2_22-branchpoint:1.8
	gdb_7_3_1-2011-09-04-release:1.8
	sid-snapshot-20110901:1.8
	sid-snapshot-20110801:1.8
	gdb_7_3-2011-07-26-release:1.8
	sid-snapshot-20110701:1.8
	sid-snapshot-20110601:1.8
	sid-snapshot-20110501:1.8
	gdb_7_3-branch:1.8.0.8
	gdb_7_3-2011-04-01-branchpoint:1.8
	sid-snapshot-20110401:1.8
	sid-snapshot-20110301:1.8
	sid-snapshot-20110201:1.8
	sid-snapshot-20110101:1.8
	binutils-2_21:1.8
	sid-snapshot-20101201:1.8
	binutils-2_21-branch:1.8.0.6
	binutils-2_21-branchpoint:1.8
	sid-snapshot-20101101:1.8
	sid-snapshot-20101001:1.8
	binutils-2_20_1:1.7
	gdb_7_2-2010-09-02-release:1.8
	sid-snapshot-20100901:1.8
	sid-snapshot-20100801:1.8
	gdb_7_2-branch:1.8.0.4
	gdb_7_2-2010-07-07-branchpoint:1.8
	sid-snapshot-20100701:1.8
	sid-snapshot-20100601:1.8
	sid-snapshot-20100501:1.8
	sid-snapshot-20100401:1.8
	gdb_7_1-2010-03-18-release:1.8
	sid-snapshot-20100301:1.8
	gdb_7_1-branch:1.8.0.2
	gdb_7_1-2010-02-18-branchpoint:1.8
	sid-snapshot-20100201:1.8
	sid-snapshot-20100101:1.8
	gdb_7_0_1-2009-12-22-release:1.7
	sid-snapshot-20091201:1.8
	sid-snapshot-20091101:1.8
	binutils-2_20:1.7
	gdb_7_0-2009-10-06-release:1.7
	sid-snapshot-20091001:1.8
	gdb_7_0-branch:1.7.0.34
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.7.22.1
	binutils-arc-20081103-branch:1.7.0.32
	binutils-arc-20081103-branchpoint:1.7
	binutils-2_20-branch:1.7.0.30
	binutils-2_20-branchpoint:1.7
	sid-snapshot-20090901:1.7
	sid-snapshot-20090801:1.7
	msnyder-checkpoint-072509-branch:1.7.0.28
	msnyder-checkpoint-072509-branchpoint:1.7
	sid-snapshot-20090701:1.7
	dje-cgen-play1-branch:1.7.0.26
	dje-cgen-play1-branchpoint:1.7
	sid-snapshot-20090601:1.7
	sid-snapshot-20090501:1.7
	sid-snapshot-20090401:1.7
	arc-20081103-branch:1.7.0.24
	arc-20081103-branchpoint:1.7
	arc-insight_6_8-branch:1.7.0.22
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.20
	insight_6_8-branchpoint:1.7
	sid-snapshot-20090301:1.7
	binutils-2_19_1:1.7
	sid-snapshot-20090201:1.7
	sid-snapshot-20090101:1.7
	reverse-20081226-branch:1.7.0.18
	reverse-20081226-branchpoint:1.7
	sid-snapshot-20081201:1.7
	multiprocess-20081120-branch:1.7.0.16
	multiprocess-20081120-branchpoint:1.7
	sid-snapshot-20081101:1.7
	binutils-2_19:1.7
	sid-snapshot-20081001:1.7
	reverse-20080930-branch:1.7.0.14
	reverse-20080930-branchpoint:1.7
	binutils-2_19-branch:1.7.0.12
	binutils-2_19-branchpoint:1.7
	sid-snapshot-20080901:1.7
	sid-snapshot-20080801:1.7
	reverse-20080717-branch:1.7.0.10
	reverse-20080717-branchpoint:1.7
	sid-snapshot-20080701:1.7
	msnyder-reverse-20080609-branch:1.7.0.8
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.6.0.34
	drow-reverse-20070409-branchpoint:1.6
	sid-snapshot-20080601:1.7
	sid-snapshot-20080501:1.7
	sid-snapshot-20080403:1.7
	sid-snapshot-20080401:1.7
	gdb_6_8-2008-03-27-release:1.7
	sid-snapshot-20080301:1.7
	gdb_6_8-branch:1.7.0.6
	gdb_6_8-2008-02-26-branchpoint:1.7
	sid-snapshot-20080201:1.7
	sid-snapshot-20080101:1.7
	sid-snapshot-20071201:1.7
	sid-snapshot-20071101:1.7
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	sid-snapshot-20071001:1.7
	gdb_6_7-branch:1.7.0.4
	gdb_6_7-2007-09-07-branchpoint:1.7
	binutils-2_18:1.7
	binutils-2_18-branch:1.7.0.2
	binutils-2_18-branchpoint:1.7
	insight_6_6-20070208-release:1.6
	binutils-csl-coldfire-4_1-32:1.6
	binutils-csl-sourcerygxx-4_1-32:1.6
	gdb_6_6-2006-12-18-release:1.6
	binutils-csl-innovasic-fido-3_4_4-33:1.6
	binutils-csl-sourcerygxx-3_4_4-32:1.5
	binutils-csl-coldfire-4_1-30:1.6
	binutils-csl-sourcerygxx-4_1-30:1.6
	binutils-csl-coldfire-4_1-28:1.6
	binutils-csl-sourcerygxx-4_1-29:1.6
	binutils-csl-sourcerygxx-4_1-28:1.6
	gdb_6_6-branch:1.6.0.32
	gdb_6_6-2006-11-15-branchpoint:1.6
	binutils-csl-arm-2006q3-27:1.6
	binutils-csl-sourcerygxx-4_1-27:1.6
	binutils-csl-arm-2006q3-26:1.6
	binutils-csl-sourcerygxx-4_1-26:1.6
	binutils-csl-sourcerygxx-4_1-25:1.6
	binutils-csl-sourcerygxx-4_1-24:1.6
	binutils-csl-sourcerygxx-4_1-23:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	binutils-csl-sourcerygxx-4_1-21:1.6
	binutils-csl-arm-2006q3-21:1.6
	binutils-csl-sourcerygxx-4_1-22:1.6
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.6
	binutils-csl-sourcerygxx-4_1-20:1.6
	binutils-csl-arm-2006q3-19:1.6
	binutils-csl-sourcerygxx-4_1-19:1.6
	binutils-csl-sourcerygxx-4_1-18:1.6
	binutils-csl-renesas-4_1-9:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	binutils-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	binutils-csl-renesas-4_1-8:1.6
	binutils-csl-renesas-4_1-7:1.6
	binutils-csl-renesas-4_1-6:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	binutils-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	binutils-csl-sourcerygxx-4_1-14:1.6
	binutils-csl-sourcerygxx-4_1-15:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	binutils-csl-sourcerygxx-4_1-13:1.6
	binutils-2_17:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	binutils-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	binutils-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.6
	binutils-csl-wrs-linux-3_4_4-24:1.5
	binutils-csl-wrs-linux-3_4_4-23:1.5
	gdb-csl-sourcerygxx-4_1-9:1.6
	binutils-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	binutils-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	binutils-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	binutils-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	binutils-csl-sourcerygxx-4_1-6:1.6
	binutils-csl-wrs-linux-3_4_4-22:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	binutils-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	binutils-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.6.0.30
	gdb_6_5-2006-05-14-branchpoint:1.6
	binutils-csl-coldfire-4_1-10:1.6
	gdb-csl-sourcerygxx-4_1-5:1.6
	binutils-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.6.0.28
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.6
	binutils-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.6.0.26
	msnyder-reverse-20060502-branchpoint:1.6
	binutils-csl-wrs-linux-3_4_4-21:1.5
	gdb-csl-morpho-4_1-4:1.6
	binutils-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	binutils-csl-sourcerygxx-3_4_4-17:1.6
	binutils-csl-wrs-linux-3_4_4-20:1.5
	readline_5_1-import-branch:1.6.0.24
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	binutils-2_17-branch:1.6.0.22
	binutils-2_17-branchpoint:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.20
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.18
	msnyder-reverse-20060331-branchpoint:1.6
	binutils-csl-2_17-branch:1.6.0.16
	binutils-csl-2_17-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.14
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.12
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.10
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.6
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.4
	gdb-csl-arm-20051020-branchpoint:1.6
	binutils-csl-gxxpro-3_4-branch:1.5.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.5
	binutils-2_16_1:1.5
	msnyder-tracepoint-checkpoint-branch:1.6.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.5
	binutils-csl-arm-2005q1b:1.5
	binutils-2_16:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	binutils-csl-arm-2005q1a:1.5
	csl-arm-20050325-branch:1.5.0.6
	csl-arm-20050325-branchpoint:1.5
	binutils-csl-arm-2005q1-branch:1.5.0.4
	binutils-csl-arm-2005q1-branchpoint:1.5
	binutils-2_16-branch:1.5.0.2
	binutils-2_16-branchpoint:1.5
	csl-arm-2004-q3d:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.4
	gdb_6_3-20041019-branchpoint:1.4
	csl-arm-2004-q3:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.6
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.3
	binutils-2_15:1.3
	binutils-2_15-branchpoint:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.80
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.78
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.76
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.74
	drow_intercu-20040221-branchpoint:1.3
	binutils-2_15-branch:1.3.0.72
	cagney_bfdfile-20040213-branch:1.3.0.70
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.68
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	csl-arm-2003-q4:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.66
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.64
	cagney_x86i386-20030821-branch:1.3.0.62
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.60
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.58
	jimb-ppc64-linux-20030613-branchpoint:1.3
	binutils-2_14:1.3
	cagney_convert-20030606-branch:1.3.0.56
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.54
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.50
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	binutils-2_14-branch:1.3.0.46
	binutils-2_14-branchpoint:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.44
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.42
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.40
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.38
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.36
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.34
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.32
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.30
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.28
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.26
	cagney-unwind-20030108-branchpoint:1.3
	binutils-2_13_2_1:1.3
	binutils-2_13_2:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	binutils-2_13_1:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.20
	gdb_5_3-branch:1.3.0.18
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.16
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.14
	readline_4_3-import-branchpoint:1.3
	binutils-2_13:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	binutils-2_13-branchpoint:1.3
	binutils-2_13-branch:1.3.0.12
	kseitz_interps-20020528-branch:1.3.0.10
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.8
	cagney_regbuf-20020515-branchpoint:1.3
	binutils-2_12_1:1.3
	jimb-macro-020506-branch:1.3.0.6
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	binutils-2_12:1.3
	gdb_5_2-branch:1.3.0.4
	gdb_5_2-2002-03-03-branchpoint:1.3
	binutils-2_12-branch:1.3.0.2
	binutils-2_12-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	binutils-2_11_2:1.1.2.1
	binutils-2_11_1:1.1.2.1
	binutils-2_11:1.1
	x86_64versiong3:1.1
	binutils-2_11-branch:1.1.0.2
	binutils_latest_snapshot:1.8;
locks; strict;
comment	@ * @;


1.8
date	2009.09.25.19.13.27;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches
	1.7.22.1
	1.7.32.1;
next	1.6;

1.6
date	2005.05.07.07.34.26;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.22.13.01.52;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.15.01.14.22;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.31.20.05.24;	author aj;	state Exp;
branches
	1.3.74.1;
next	1.2;

1.2
date	2001.03.13.22.58.34;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.11.21.20.19;	author nickc;	state Exp;
branches
	1.1.2.1;
next	;

1.7.22.1
date	2009.03.09.20.36.11;	author amylaar;	state Exp;
branches;
next	1.7.22.2;

1.7.22.2
date	2009.09.11.04.45.54;	author amylaar;	state Exp;
branches;
next	;

1.7.32.1
date	2009.09.10.15.09.45;	author amylaar;	state Exp;
branches;
next	;

1.3.74.1
date	2004.09.16.17.01.57;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2001.06.07.03.18.33;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.8
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@/* ARC target-dependent stuff. Extension structure access functions
   Copyright 1995, 1997, 2000, 2001, 2004, 2005, 2007, 2009
   Free Software Foundation, Inc.

   This file is part of libopcodes.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <stdlib.h>
#include <stdio.h>
#include "bfd.h"
#include "arc-ext.h"
#include "libiberty.h"

/* Extension structure  */
static struct arcExtMap arc_extension_map;

/* Get the name of an extension instruction.  */

const char *
arcExtMap_instName(int opcode, int minor, int *flags)
{
    if (opcode == 3)
      {
	/* FIXME: ??? need to also check 0/1/2 in bit0 for (3f) brk/sleep/swi  */
	if (minor < 0x09 || minor == 0x3f)
	  return 0;
	else
	  opcode = 0x1f - 0x10 + minor - 0x09 + 1;
      }
    else
      if (opcode < 0x10)
	return 0;
    else
      opcode -= 0x10;
    if (!arc_extension_map.instructions[opcode])
      return 0;
    *flags = arc_extension_map.instructions[opcode]->flags;
    return arc_extension_map.instructions[opcode]->name;
}

/* Get the name of an extension core register.  */

const char *
arcExtMap_coreRegName(int value)
{
  if (value < 32)
    return 0;
  return arc_extension_map.coreRegisters[value-32];
}

/* Get the name of an extension condition code.  */

const char *
arcExtMap_condCodeName(int value)
{
  if (value < 16)
    return 0;
  return arc_extension_map.condCodes[value-16];
}

/* Get the name of an extension aux register.  */

const char *
arcExtMap_auxRegName(long address)
{
  /* walk the list of aux reg names and find the name  */
  struct ExtAuxRegister *r;

  for (r = arc_extension_map.auxRegisters; r; r = r->next) {
    if (r->address == address)
      return (const char *) r->name;
  }
  return 0;
}

/* Recursively free auxilliary register strcture pointers until
   the list is empty.  */

static void
clean_aux_registers(struct ExtAuxRegister *r)
{
  if (r -> next)
    {
      clean_aux_registers( r->next);
      free(r -> name);
      free(r -> next);
      r ->next = NULL;
    }
  else
    free(r -> name);
}

/* Free memory that has been allocated for the extensions.  */

static void
cleanup_ext_map(void)
{
  struct ExtAuxRegister *r;
  struct ExtInstruction *insn;
  int i;

  /* clean aux reg structure  */
  r = arc_extension_map.auxRegisters;
  if (r)
    {
      (clean_aux_registers(r));
      free(r);
    }

  /* clean instructions  */
  for (i = 0; i < NUM_EXT_INST; i++)
    {
      insn = arc_extension_map.instructions[i];
      if (insn)
	free(insn->name);
    }

  /* clean core reg struct  */
  for (i = 0; i < NUM_EXT_CORE; i++)
    {
      if (arc_extension_map.coreRegisters[i])
	free(arc_extension_map.coreRegisters[i]);
    }

  for (i = 0; i < NUM_EXT_COND; i++) {
    if (arc_extension_map.condCodes[i])
      free(arc_extension_map.condCodes[i]);
  }

  memset(&arc_extension_map, 0, sizeof(struct arcExtMap));
}

int
arcExtMap_add(void *base, unsigned long length)
{
  unsigned char *block = (unsigned char *) base;
  unsigned char *p = (unsigned char *) block;

  /* Clean up and reset everything if needed.  */
  cleanup_ext_map();

  while (p && p < (block + length))
    {
      /* p[0] == length of record
	 p[1] == type of record
	 For instructions:
	   p[2]  = opcode
	   p[3]  = minor opcode (if opcode == 3)
	   p[4]  = flags
	   p[5]+ = name
	 For core regs and condition codes:
	   p[2]  = value
	   p[3]+ = name
	 For aux regs:
	   p[2..5] = value
	   p[6]+   = name
	 (value is p[2]<<24|p[3]<<16|p[4]<<8|p[5])  */

      if (p[0] == 0)
	return -1;

      switch (p[1])
	{
	case EXT_INSTRUCTION:
	  {
	    char opcode = p[2];
	    char minor  = p[3];
	    char * insn_name = (char *) xmalloc(( (int)*p-5) * sizeof(char));
	    struct ExtInstruction * insn =
	      (struct ExtInstruction *) xmalloc(sizeof(struct ExtInstruction));

	    if (opcode==3)
	      opcode = 0x1f - 0x10 + minor - 0x09 + 1;
	    else
	      opcode -= 0x10;
	    insn -> flags = (char) *(p+4);
	    strcpy (insn_name, (char *) (p+5));
	    insn -> name = insn_name;
	    arc_extension_map.instructions[(int) opcode] = insn;
	  }
	  break;

	case EXT_CORE_REGISTER:
	  {
	    char * core_name = (char *) xmalloc(((int)*p-3) * sizeof(char));

	    strcpy(core_name, (char *) (p+3));
	    arc_extension_map.coreRegisters[p[2]-32] = core_name;
	  }
	  break;

	case EXT_COND_CODE:
	  {
	    char * cc_name = (char *) xmalloc( ((int)*p-3) * sizeof(char));
	    strcpy(cc_name, (char *) (p+3));
	    arc_extension_map.condCodes[p[2]-16] = cc_name;
	  }
	  break;

	case EXT_AUX_REGISTER:
	  {
	    /* trickier -- need to store linked list to these  */
	    struct ExtAuxRegister *newAuxRegister =
	      (struct ExtAuxRegister *)malloc(sizeof(struct ExtAuxRegister));
	    char * aux_name = (char *) xmalloc ( ((int)*p-6) * sizeof(char));

	    strcpy (aux_name, (char *) (p+6));
	    newAuxRegister->name = aux_name;
	    newAuxRegister->address = p[2]<<24 | p[3]<<16 | p[4]<<8  | p[5];
	    newAuxRegister->next = arc_extension_map.auxRegisters;
	    arc_extension_map.auxRegisters = newAuxRegister;
	  }
	  break;

	default:
	  return -1;

	}
      p += p[0]; /* move to next record  */
    }

  return 0;
}

/* Load hw extension descibed in .extArcMap ELF section.  */

void
build_ARC_extmap (text_bfd)
  bfd *text_bfd;
{
  char *arcExtMap;
  bfd_size_type count;
  asection *p;

  for (p = text_bfd->sections; p != NULL; p = p->next)
    if (!strcmp (p->name, ".arcextmap"))
      {
        count = bfd_get_section_size (p);
        arcExtMap = (char *) xmalloc (count);
        if (bfd_get_section_contents (text_bfd, p, (PTR) arcExtMap, 0, count))
          {
            arcExtMap_add ((PTR) arcExtMap, count);
            break;
          }
        free ((PTR) arcExtMap);
      }
}
@


1.7
log
@Change source files over to GPLv3.
@
text
@d2 1
a2 1
   Copyright 1995, 1997, 2000, 2001, 2004, 2005, 2007
d151 2
a152 2
  unsigned char *block = base;
  unsigned char *p = block;
@


1.7.32.1
log
@Commit patches for ARCompact support to binutils-arc-20081103-branch .
@
text
@d2 1
a2 1
   Copyright 1995, 1997, 2000, 2001, 2004, 2005, 2009
d22 1
a22 1

a24 1

a26 1
#include "elf/arc.h"
a27 1
#include "sysdep.h"
d29 4
d34 21
a54 28
/******************************************************************************/
/*                                                                            */
/* Outline:                                                                   */
/*     This module provides support for extensions to the ARC processor       */
/*     architecture.                                                          */
/*                                                                            */
/******************************************************************************/


/* -------------------------------------------------------------------------- */
/*                               local constants                              */
/* -------------------------------------------------------------------------- */

#define FIRST_EXTENSION_CORE_REGISTER   32
#define LAST_EXTENSION_CORE_REGISTER    59
#define FIRST_EXTENSION_CONDITION_CODE  0x10
#define LAST_EXTENSION_CONDITION_CODE   0x1f

#define NUM_EXT_CORE      (LAST_EXTENSION_CORE_REGISTER  - FIRST_EXTENSION_CORE_REGISTER  + 1)
#define NUM_EXT_COND      (LAST_EXTENSION_CONDITION_CODE - FIRST_EXTENSION_CONDITION_CODE + 1)
#define INST_HASH_BITS    6
#define INST_HASH_SIZE    (1 << INST_HASH_BITS)
#define INST_HASH_MASK    (INST_HASH_SIZE - 1)


/* -------------------------------------------------------------------------- */
/*                               local types                                  */
/* -------------------------------------------------------------------------- */
d56 1
a56 1
/* these types define the information stored in the table */
d58 2
a59 1
struct ExtInstruction
d61 4
a64 6
  char                   major;
  char                   minor;
  char                   flags;
  char*                  name;
  struct ExtInstruction* next;
};
d66 4
a69 1
struct ExtAuxRegister
d71 6
a76 4
  long                   address;
  char*                  name;
  struct ExtAuxRegister* next;
};
d78 2
a79 1
struct ExtCoreRegister
d81 12
a92 4
  short             number;
  enum ExtReadWrite rw;
  char*             name;
};
d94 2
a95 1
struct arcExtMap
d97 10
a106 5
  struct ExtAuxRegister* auxRegisters;
  struct ExtInstruction* instructions[INST_HASH_SIZE];
  struct ExtCoreRegister coreRegisters[NUM_EXT_CORE];
  char*                  condCodes[NUM_EXT_COND];
};
d108 1
d110 6
a115 3
/* -------------------------------------------------------------------------- */
/*                               local data                                   */
/* -------------------------------------------------------------------------- */
d117 7
a123 2
/* extension table */
static struct arcExtMap arc_extension_map;
d125 7
d133 6
a138 3
/* -------------------------------------------------------------------------- */
/*                               local macros                                 */
/* -------------------------------------------------------------------------- */
d140 4
a143 2
/* a hash function used to map instructions into the table */
#define INST_HASH(MAJOR, MINOR)    ((((MAJOR) << 3) ^ (MINOR)) & INST_HASH_MASK)
d145 2
d148 2
a149 5
/* -------------------------------------------------------------------------- */
/*                               local functions                              */
/* -------------------------------------------------------------------------- */

static void create_map(unsigned char *block, unsigned long length)
d151 1
d154 2
a155 1
//printf("building ext map...\n");
d169 1
a169 1
	 For auxiliary regs:
d172 1
a172 1
	     (value is p[2]<<24|p[3]<<16|p[4]<<8|p[5]) */
a173 1
      /* the sequence of records is temrinated by an "empty" record */
d175 1
a175 3
	break;

//    printf("%d byte type %d record\n", p[0], p[1]);
d178 1
a178 1
	{ /* type */
d181 14
a194 13
	    struct ExtInstruction  *insn = XNEW (struct ExtInstruction);
	    int                     major = p[2];
	    int                     minor = p[3];
	    struct ExtInstruction **bucket =
                   &arc_extension_map.instructions[INST_HASH (major, minor)];

	    insn->name  = xstrdup ((char *) (p+5));
	    insn->major = major;
	    insn->minor = minor;
	    insn->flags = p[4];
	    insn->next  = *bucket;
	    *bucket = insn;
	    break;
d196 1
d200 1
a200 2
	    unsigned char number = p[2];
	    char*         name   = (char *) p+3;
d202 2
a203 15
	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].number = number;
	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].rw     = REG_READWRITE;
	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].name   = xstrdup (name);
	    break;
	  }

	case EXT_LONG_CORE_REGISTER:
	  {
	    unsigned char     number = p[2];
	    char*             name   = (char *) p+7;
	    enum ExtReadWrite rw     = p[6];

	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].number = number;
	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].rw     = rw;
	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].name   = xstrdup (name);
d205 1
d209 3
a211 4
	    char *cc_name = xstrdup ((char *) (p+3));

	    arc_extension_map.condCodes[p[2] - FIRST_EXTENSION_CONDITION_CODE] = cc_name;
	    break;
d213 1
d217 9
a225 7
	    /* trickier -- need to store linked list of these */
	    struct ExtAuxRegister *newAuxRegister = XNEW (struct ExtAuxRegister);
	    char *aux_name = xstrdup ((char *) (p+6));

	    newAuxRegister->name           = aux_name;
	    newAuxRegister->address        = p[2]<<24 | p[3]<<16 | p[4]<<8 | p[5];
	    newAuxRegister->next           = arc_extension_map.auxRegisters;
a226 1
	    break;
d228 1
d231 1
a231 51
//        printf("type %d extension record skipped\n", p[1]);
	  break;
	}

      p += p[0]; /* move on to next record */
    }

//printf("ext map built\n");
}


/* Free memory that has been allocated for the extensions. */
static void destroy_map(void)
{
  struct ExtAuxRegister *r;
  unsigned int           i;

  /* free auxiliary registers */
  r = arc_extension_map.auxRegisters;
  while (r)
    {
      /* N.B. after r has been freed, r->next is invalid! */
      struct ExtAuxRegister* next = r->next;

      free (r->name);
      free (r);
      r = next;
    }

  /*  free instructions */
  for (i = 0; i < INST_HASH_SIZE; i++)
    {
      struct ExtInstruction *insn = arc_extension_map.instructions[i];

      while (insn)
        {
          /* N.B. after insn has been freed, insn->next is invalid! */
          struct ExtInstruction *next = insn->next;

          free (insn->name);
          free (insn);
          insn = next;
        }
    }

  /* free core registers */
  for (i = 0; i < NUM_EXT_CORE; i++)
    {
      if (arc_extension_map.coreRegisters[i].name)
        free (arc_extension_map.coreRegisters[i].name);
    }
a232 119
  /* free condition codes */
  for (i = 0; i < NUM_EXT_COND; i++)
    {
      if (arc_extension_map.condCodes[i])
        free (arc_extension_map.condCodes[i]);
    }

  memset (&arc_extension_map, 0, sizeof (arc_extension_map));
}


static const char* ExtReadWrite_image(enum ExtReadWrite val)
{
    switch (val)
    {
        case REG_INVALID  : return "INVALID";
        case REG_READ     : return "RO";
        case REG_WRITE    : return "WO";
        case REG_READWRITE: return "R/W";
        default           : return "???";
    }
}


/* -------------------------------------------------------------------------- */
/*                               externally visible functions                 */
/* -------------------------------------------------------------------------- */

/* Get the name of an extension instruction.  */

const char *
arcExtMap_instName (int opcode, int insn, int *flags)
{
  /* Here the following tasks need to be done.  First of all, the opcode
     stored in the Extension Map is the real opcode.  However, the subopcode
     stored in the instruction to be disassembled is mangled.  We pass (in
     minor opcode), the instruction word.  Here we will un-mangle it and get
     the real subopcode which we can look for in the Extension Map.  This
     function is used both for the ARCTangent and the ARCompact, so we would
     also need some sort of a way to distinguish between the two
     architectures.  This is because the ARCTangent does not do any of this
     mangling so we have no issues there.  */

  /* If P[22:23] is 0 or 2 then un-mangle using iiiiiI.  If it is 1 then use
     iiiiIi.  Now, if P is 3 then check M[5:5] and if it is 0 then un-mangle
     using iiiiiI else iiiiii.  */

  unsigned char minor;
  struct ExtInstruction *temp;

  if (*flags != E_ARC_MACH_A4) /* ARCompact extension instructions.  */
    {
      /* 16-bit instructions.  */
      if (0x08 <= opcode && opcode <= 0x0b)
	{
	  unsigned char I, b, c, i;

	  I = (insn & 0xf800) >> 11;
	  b = (insn & 0x0700) >> 8;
	  c = (insn & 0x00e0) >> 5;
	  i = (insn & 0x001f);

	  if (i)
	    minor = i;
	  else
	    minor = (c == 0x07) ? b : c;
	}
      /* 32-bit instructions.  */
      else
	{
	  unsigned char P, M, I, A, B;

	  P = (insn & 0x00c00000) >> 22;
	  M = (insn & 0x00000020);
	  I = (insn & 0x003f0000) >> 16;
	  A = (insn & 0x0000003f);
	  B = ((insn & 0x07000000) >> 24) | ((insn & 0x00007000) >> 9);

	  if (I != 0x2f)
	    {
#ifndef UNMANGLED
	      switch (P)
		{
		case 3:
		  if (M)
		    {
		      minor = I;
		      break;
		    }
		case 0:
		case 2:
		  minor = (I >> 1) | ((I & 0x1) << 5);
		  break;
		case 1:
		  minor = (I >> 1) | (I & 0x1) | ((I & 0x2) << 4);
		}
#else
	      minor = I;
#endif
	    }
	  else
	    {
	      if (A != 0x3f)
		minor = A;
	      else
		minor = B;
	    }
	}
    }
  else /* ARCTangent extension instructions.  */
    minor = insn;

  temp = arc_extension_map.instructions[INST_HASH (opcode, minor)];
  while (temp)
    {
      if ((temp->major == opcode) && (temp->minor == minor))
	{
	  *flags = temp->flags;
	  return temp->name;
d234 1
a234 1
      temp = temp->next;
d237 1
a237 1
  return NULL;
d240 1
d242 3
a244 13
/* get the name of an extension core register */
const char *
arcExtMap_coreRegName (int regnum)
{
  if (regnum < FIRST_EXTENSION_CORE_REGISTER || regnum > LAST_EXTENSION_CONDITION_CODE)
    return NULL;
  return arc_extension_map.coreRegisters[regnum - FIRST_EXTENSION_CORE_REGISTER].name;
}


/* get the access mode of an extension core register */
enum ExtReadWrite
arcExtMap_coreReadWrite (int regnum)
d246 3
a248 22
  if (regnum < FIRST_EXTENSION_CORE_REGISTER || regnum > LAST_EXTENSION_CONDITION_CODE)
    return REG_INVALID;
  return arc_extension_map.coreRegisters[regnum - FIRST_EXTENSION_CORE_REGISTER].rw;
}


/* get the name of an extension condition code */
const char *
arcExtMap_condCodeName (int code)
{
  if (code < FIRST_EXTENSION_CONDITION_CODE || code > LAST_EXTENSION_CONDITION_CODE)
    return NULL;
  return arc_extension_map.condCodes[code - FIRST_EXTENSION_CONDITION_CODE];
}


/* Get the name of an extension auxiliary register.  */
const char *
arcExtMap_auxRegName (long address)
{
  /* Walk the list of auxiliary register names and find the name.  */
  struct ExtAuxRegister *r;
d250 2
a251 26
  for (r = arc_extension_map.auxRegisters; r; r = r->next)
    {
      if (r->address == address)
        return (const char *)r->name;
    }
  return NULL;
}


/* Load extensions described in .arcextmap and .gnu.linkonce.arcextmap.* ELF
   section.  */
void
build_ARC_extmap (bfd *text_bfd)
{
  asection *sect;
    
  /* the map is built each time gdb loads an executable file - so free any
   * existing map, as the map defined by the new file may differ from the old
   */
  destroy_map();

  for (sect = text_bfd->sections; sect != NULL; sect = sect->next)
    if (!strncmp (sect->name,
                  ".gnu.linkonce.arcextmap.",
          sizeof (".gnu.linkonce.arcextmap.") - 1)
        || !strcmp (sect->name,".arcextmap"))
d253 3
a255 4
        bfd_size_type  count  = bfd_get_section_size (sect);
        unsigned char* buffer = xmalloc (count);

        if (buffer)
d257 2
a258 3
            if (bfd_get_section_contents (text_bfd, sect, buffer, 0, count))
              create_map(buffer, count);
            free (buffer);
d260 1
a262 37


void dump_ARC_extmap (void)
{
    struct ExtAuxRegister* r;
    int                    i;

    r = arc_extension_map.auxRegisters;

    while (r)
    {
        printf("AUX : %s %ld\n", r->name, r->address);
        r = r->next;
    }
  
    for (i = 0; i < INST_HASH_SIZE; i++)
    {
        struct ExtInstruction *insn;

        for (insn = arc_extension_map.instructions[i]; insn != NULL; insn = insn->next)
            printf("INST: %d %d %x %s\n", insn->major, insn->minor, insn->flags, insn->name);
    }

    for (i = 0; i < NUM_EXT_CORE; i++)
    {
        struct ExtCoreRegister reg = arc_extension_map.coreRegisters[i];

        if (reg.name)
            printf("CORE: %s %d %s\n", reg.name, reg.number, ExtReadWrite_image(reg.rw));
    }

    for (i = 0; i < NUM_EXT_COND; i++)
        if (arc_extension_map.condCodes[i])
            printf("COND: %s\n", arc_extension_map.condCodes[i]);
}

/******************************************************************************/
@


1.7.22.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@d22 1
a26 2
#include "elf/arc.h"

a27 1
#include "sysdep.h"
d29 1
a29 1
/* extension structure */
d35 1
a35 1
arcExtMap_instName (int opcode, int insn, int *flags)
d37 18
a54 13
  /* Here the following tasks need to be done.  First of all, the opcode
     stored in the Extension Map is the real opcode.  However, the subopcode
     stored in the instruction to be disassembled is mangled.  We pass (in
     minor opcode), the instruction word.  Here we will un-mangle it and get
     the real subopcode which we can look for in the Extension Map.  This
     function is used both for the ARCTangent and the ARCompact, so we would
     also need some sort of a way to distinguish between the two
     architectures.  This is because the ARCTangent does not do any of this
     mangling so we have no issues there.  */

  /* If P[22:23] is 0 or 2 then un-mangle using iiiiiI.  If it is 1 then use
     iiiiIi.  Now, if P is 3 then check M[5:5] and if it is 0 then un-mangle
     using iiiiiI else iiiiii.  */
d56 1
a56 2
  unsigned char minor;
  struct ExtInstruction *temp;
a57 77
  if (*flags != E_ARC_MACH_A4) /* ARCompact extension instructions.  */
    {
      /* 16-bit instructions.  */
      if (0x08 <= opcode && opcode <= 0x0b)
	{
	  unsigned char I, b, c, i;

	  I = (insn & 0xf800) >> 11;
	  b = (insn & 0x0700) >> 8;
	  c = (insn & 0x00e0) >> 5;
	  i = (insn & 0x001f);

	  if (i)
	    minor = i;
	  else
	    minor = (c == 0x07) ? b : c;
	}
      /* 32-bit instructions.  */
      else
	{
	  unsigned char P, M, I, A, B;

	  P = (insn & 0x00c00000) >> 22;
	  M = (insn & 0x00000020);
	  I = (insn & 0x003f0000) >> 16;
	  A = (insn & 0x0000003f);
	  B = ((insn & 0x07000000) >> 24) | ((insn & 0x00007000) >> 9);

	  if (I != 0x2f)
	    {
#ifndef UNMANGLED
	      switch (P)
		{
		case 3:
		  if (M)
		    {
		      minor = I;
		      break;
		    }
		case 0:
		case 2:
		  minor = (I >> 1) | ((I & 0x1) << 5);
		  break;
		case 1:
		  minor = (I >> 1) | (I & 0x1) | ((I & 0x2) << 4);
		}
#else
	      minor = I;
#endif
	    }
	  else
	    {
	      if (A != 0x3f)
		minor = A;
	      else
		minor = B;
	    }
	}
    }
  else /* ARCTangent extension instructions.  */
    minor = insn;

  temp = arc_extension_map.instructions[INST_HASH (opcode, minor)];
  while (temp)
    {
      if ((temp->major == opcode) && (temp->minor == minor))
	{
	  *flags = temp->flags;
	  return temp->name;
	}
      temp = temp->next;
    }

  return NULL;
}

/* get the name of an extension core register */
d59 1
a59 1
arcExtMap_coreRegName (int value)
d63 1
a63 1
  return arc_extension_map.coreRegisters[value-32].name;
d66 1
a66 15
enum ExtReadWrite
arcExtMap_coreReadWrite (int value)
{
  if (value < 32)
    return REG_INVALID;
  return arc_extension_map.coreRegisters[value-32].rw;
}

#if 0
struct ExtAuxRegister *
arc_ExtMap_auxRegs ()
{
  return arc_extension_map.auxRegisters;
}
#endif
a67 1
/* Get the name of an extension condition code.  */
d69 1
a69 1
arcExtMap_condCodeName (int value)
d79 1
a79 1
arcExtMap_auxRegName (long address)
d81 1
a81 1
  /* Walk the list of aux reg names and find the name.  */
d84 4
a87 5
  for (r = arc_extension_map.auxRegisters; r; r = r->next)
    {
      if (r->address == address)
	return (const char *)r->name;
    }
a90 1
#if 0
d93 1
d95 1
a95 1
clean_aux_registers (struct ExtAuxRegister *r)
d99 4
a102 4
      clean_aux_registers (r->next);
      free (r->name);
      free (r->next);
      r->next = NULL;
d105 1
a105 1
    free (r->name);
d108 1
a108 1
/* Free memory that has been allocated for the extensions. */
d111 1
a111 1
cleanup_ext_map (void)
d117 1
a117 1
  /* Clean aux reg structure.  */
d121 2
a122 2
      (clean_aux_registers (r));
      free (r);
d125 2
a126 2
  /* Clean instructions.  */
  for (i = INST_HASH_SIZE - 1; i >= 0; i--)
d128 3
a130 5
      for (insn = arc_extension_map.instructions[i]; insn ; insn = insn->next)
	{
	  free (insn->name);
	  free (insn);
	}
d133 1
a133 1
  /* Clean core reg struct.  */
d136 2
a137 2
      if (arc_extension_map.coreRegisters[i].name)
	free (arc_extension_map.coreRegisters[i].name);
d142 1
a142 1
      free (arc_extension_map.condCodes[i]);
d145 1
a145 1
  memset (&arc_extension_map, 0, sizeof (struct arcExtMap));
a146 1
#endif
d149 1
a149 1
arcExtMap_add (void *base, unsigned long length)
d154 3
d172 2
a173 1
	     (value is p[2]<<24|p[3]<<16|p[4]<<8|p[5]) */
d178 1
a178 1
	{ /* type */
d181 14
a194 14
	    char *insn_name = xstrdup ((char *) (p+5));
	    struct ExtInstruction *insn = XNEW (struct ExtInstruction);
	    int major = p[2];
	    int minor = p[3];
	    struct ExtInstruction **bucket
	      = &arc_extension_map.instructions[INST_HASH (major, minor)];

	    insn->name  = insn_name;
	    insn->major = major;
	    insn->minor = minor;
	    insn->flags = p[4];
	    insn->next  = *bucket;
	    *bucket = insn;
	    break;
d196 2
d200 1
a200 2
	    unsigned char number = p[2];
	    char *name = (char *) p+3;
d202 2
a203 14
	    arc_extension_map.coreRegisters[number-32].number = number;
	    arc_extension_map.coreRegisters[number-32].rw = REG_READWRITE;
	    arc_extension_map.coreRegisters[number-32].name = xstrdup (name);
	    break;
	  }
	case EXT_LONG_CORE_REGISTER:
	  {
	    unsigned char number = p[2];
	    char *name = (char *) p+7;
	    enum ExtReadWrite rw = p[6];

	    arc_extension_map.coreRegisters[number-32].number = number;
	    arc_extension_map.coreRegisters[number-32].rw = rw;
	    arc_extension_map.coreRegisters[number-32].name = xstrdup (name);
d205 2
d209 2
a210 2
	    char *cc_name = xstrdup ((char *) (p+3));

a211 1
	    break;
d213 2
d217 4
a220 4
	    /* trickier -- need to store linked list to these */
	    struct ExtAuxRegister *newAuxRegister
	      = XNEW (struct ExtAuxRegister);
	    char *aux_name = xstrdup ((char *) (p+6));
d222 1
a226 1
	    break;
d228 2
d232 1
d234 1
a234 1
      p += p[0]; /* move to next record */
d236 1
d240 2
a241 2
/* Load extensions described in .arcextmap and .gnu.linkonce.arcextmap.* ELF
   section.  */
d243 2
a244 1
build_ARC_extmap (bfd *text_bfd)
d251 1
a251 4
    if (!strncmp (p->name,
		  ".gnu.linkonce.arcextmap.",
		  sizeof (".gnu.linkonce.arcextmap.")-1)
	|| !strcmp (p->name,".arcextmap"))
d256 4
a259 1
	  arcExtMap_add ((PTR) arcExtMap, count);
@


1.7.22.2
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@a23 1

d27 1
d31 1
a31 69

/******************************************************************************/
/*                                                                            */
/* Outline:                                                                   */
/*     This module provides support for extensions to the ARC processor       */
/*     architecture.                                                          */
/*                                                                            */
/******************************************************************************/


/* -------------------------------------------------------------------------- */
/*                               local constants                              */
/* -------------------------------------------------------------------------- */

#define FIRST_EXTENSION_CORE_REGISTER   32
#define LAST_EXTENSION_CORE_REGISTER    59
#define FIRST_EXTENSION_CONDITION_CODE  0x10
#define LAST_EXTENSION_CONDITION_CODE   0x1f

#define NUM_EXT_CORE      (LAST_EXTENSION_CORE_REGISTER  - FIRST_EXTENSION_CORE_REGISTER  + 1)
#define NUM_EXT_COND      (LAST_EXTENSION_CONDITION_CODE - FIRST_EXTENSION_CONDITION_CODE + 1)
#define INST_HASH_BITS    6
#define INST_HASH_SIZE    (1 << INST_HASH_BITS)
#define INST_HASH_MASK    (INST_HASH_SIZE - 1)


/* -------------------------------------------------------------------------- */
/*                               local types                                  */
/* -------------------------------------------------------------------------- */

/* these types define the information stored in the table */

struct ExtInstruction
{
  char                   major;
  char                   minor;
  char                   flags;
  char*                  name;
  struct ExtInstruction* next;
};

struct ExtAuxRegister
{
  long                   address;
  char*                  name;
  struct ExtAuxRegister* next;
};

struct ExtCoreRegister
{
  short             number;
  enum ExtReadWrite rw;
  char*             name;
};

struct arcExtMap
{
  struct ExtAuxRegister* auxRegisters;
  struct ExtInstruction* instructions[INST_HASH_SIZE];
  struct ExtCoreRegister coreRegisters[NUM_EXT_CORE];
  char*                  condCodes[NUM_EXT_COND];
};


/* -------------------------------------------------------------------------- */
/*                               local data                                   */
/* -------------------------------------------------------------------------- */

/* extension table */
a33 185

/* -------------------------------------------------------------------------- */
/*                               local macros                                 */
/* -------------------------------------------------------------------------- */

/* a hash function used to map instructions into the table */
#define INST_HASH(MAJOR, MINOR)    ((((MAJOR) << 3) ^ (MINOR)) & INST_HASH_MASK)


/* -------------------------------------------------------------------------- */
/*                               local functions                              */
/* -------------------------------------------------------------------------- */

static void create_map(unsigned char *block, unsigned long length)
{
  unsigned char *p = block;

//printf("building ext map...\n");

  while (p && p < (block + length))
    {
      /* p[0] == length of record
	 p[1] == type of record
	 For instructions:
	   p[2]  = opcode
	   p[3]  = minor opcode (if opcode == 3)
	   p[4]  = flags
	   p[5]+ = name
	 For core regs and condition codes:
	   p[2]  = value
	   p[3]+ = name
	 For auxiliary regs:
	   p[2..5] = value
	   p[6]+   = name
	     (value is p[2]<<24|p[3]<<16|p[4]<<8|p[5]) */

      /* the sequence of records is temrinated by an "empty" record */
      if (p[0] == 0)
	break;

//    printf("%d byte type %d record\n", p[0], p[1]);

      switch (p[1])
	{ /* type */
	case EXT_INSTRUCTION:
	  {
	    struct ExtInstruction  *insn = XNEW (struct ExtInstruction);
	    int                     major = p[2];
	    int                     minor = p[3];
	    struct ExtInstruction **bucket =
                   &arc_extension_map.instructions[INST_HASH (major, minor)];

	    insn->name  = xstrdup ((char *) (p+5));
	    insn->major = major;
	    insn->minor = minor;
	    insn->flags = p[4];
	    insn->next  = *bucket;
	    *bucket = insn;
	    break;
	  }

	case EXT_CORE_REGISTER:
	  {
	    unsigned char number = p[2];
	    char*         name   = (char *) p+3;

	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].number = number;
	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].rw     = REG_READWRITE;
	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].name   = xstrdup (name);
	    break;
	  }

	case EXT_LONG_CORE_REGISTER:
	  {
	    unsigned char     number = p[2];
	    char*             name   = (char *) p+7;
	    enum ExtReadWrite rw     = p[6];

	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].number = number;
	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].rw     = rw;
	    arc_extension_map.coreRegisters[number - FIRST_EXTENSION_CORE_REGISTER].name   = xstrdup (name);
	  }

	case EXT_COND_CODE:
	  {
	    char *cc_name = xstrdup ((char *) (p+3));

	    arc_extension_map.condCodes[p[2] - FIRST_EXTENSION_CONDITION_CODE] = cc_name;
	    break;
	  }

	case EXT_AUX_REGISTER:
	  {
	    /* trickier -- need to store linked list of these */
	    struct ExtAuxRegister *newAuxRegister = XNEW (struct ExtAuxRegister);
	    char *aux_name = xstrdup ((char *) (p+6));

	    newAuxRegister->name           = aux_name;
	    newAuxRegister->address        = p[2]<<24 | p[3]<<16 | p[4]<<8 | p[5];
	    newAuxRegister->next           = arc_extension_map.auxRegisters;
	    arc_extension_map.auxRegisters = newAuxRegister;
	    break;
	  }

	default:
//        printf("type %d extension record skipped\n", p[1]);
	  break;
	}

      p += p[0]; /* move on to next record */
    }

//printf("ext map built\n");
}


/* Free memory that has been allocated for the extensions. */
static void destroy_map(void)
{
  struct ExtAuxRegister *r;
  unsigned int           i;

  /* free auxiliary registers */
  r = arc_extension_map.auxRegisters;
  while (r)
    {
      /* N.B. after r has been freed, r->next is invalid! */
      struct ExtAuxRegister* next = r->next;

      free (r->name);
      free (r);
      r = next;
    }

  /*  free instructions */
  for (i = 0; i < INST_HASH_SIZE; i++)
    {
      struct ExtInstruction *insn = arc_extension_map.instructions[i];

      while (insn)
        {
          /* N.B. after insn has been freed, insn->next is invalid! */
          struct ExtInstruction *next = insn->next;

          free (insn->name);
          free (insn);
          insn = next;
        }
    }

  /* free core registers */
  for (i = 0; i < NUM_EXT_CORE; i++)
    {
      if (arc_extension_map.coreRegisters[i].name)
        free (arc_extension_map.coreRegisters[i].name);
    }

  /* free condition codes */
  for (i = 0; i < NUM_EXT_COND; i++)
    {
      if (arc_extension_map.condCodes[i])
        free (arc_extension_map.condCodes[i]);
    }

  memset (&arc_extension_map, 0, sizeof (arc_extension_map));
}


static const char* ExtReadWrite_image(enum ExtReadWrite val)
{
    switch (val)
    {
        case REG_INVALID  : return "INVALID";
        case REG_READ     : return "RO";
        case REG_WRITE    : return "WO";
        case REG_READWRITE: return "R/W";
        default           : return "???";
    }
}


/* -------------------------------------------------------------------------- */
/*                               externally visible functions                 */
/* -------------------------------------------------------------------------- */

d122 4
a125 4
        {
          *flags = temp->flags;
          return temp->name;
        }
a131 1

d134 1
a134 1
arcExtMap_coreRegName (int regnum)
d136 3
a138 3
  if (regnum < FIRST_EXTENSION_CORE_REGISTER || regnum > LAST_EXTENSION_CONDITION_CODE)
    return NULL;
  return arc_extension_map.coreRegisters[regnum - FIRST_EXTENSION_CORE_REGISTER].name;
a140 2

/* get the access mode of an extension core register */
d142 1
a142 1
arcExtMap_coreReadWrite (int regnum)
d144 1
a144 1
  if (regnum < FIRST_EXTENSION_CORE_REGISTER || regnum > LAST_EXTENSION_CONDITION_CODE)
d146 1
a146 1
  return arc_extension_map.coreRegisters[regnum - FIRST_EXTENSION_CORE_REGISTER].rw;
d149 7
d157 1
a157 1
/* get the name of an extension condition code */
d159 1
a159 1
arcExtMap_condCodeName (int code)
d161 3
a163 3
  if (code < FIRST_EXTENSION_CONDITION_CODE || code > LAST_EXTENSION_CONDITION_CODE)
    return NULL;
  return arc_extension_map.condCodes[code - FIRST_EXTENSION_CONDITION_CODE];
d166 1
a167 1
/* Get the name of an extension auxiliary register.  */
d171 1
a171 1
  /* Walk the list of auxiliary register names and find the name.  */
d177 1
a177 1
        return (const char *)r->name;
d179 1
a179 1
  return NULL;
d182 5
a186 5

/* Load extensions described in .arcextmap and .gnu.linkonce.arcextmap.* ELF
   section.  */
void
build_ARC_extmap (bfd *text_bfd)
d188 9
a196 23
  asection *sect;

  /* the map is built each time gdb loads an executable file - so free any
   * existing map, as the map defined by the new file may differ from the old
   */
  destroy_map();

  for (sect = text_bfd->sections; sect != NULL; sect = sect->next)
    if (!strncmp (sect->name,
                  ".gnu.linkonce.arcextmap.",
          sizeof (".gnu.linkonce.arcextmap.") - 1)
        || !strcmp (sect->name,".arcextmap"))
      {
        bfd_size_type  count  = bfd_get_section_size (sect);
        unsigned char* buffer = xmalloc (count);

        if (buffer)
          {
            if (bfd_get_section_contents (text_bfd, sect, buffer, 0, count))
              create_map(buffer, count);
            free (buffer);
          }
      }
d199 1
d201 2
a202 1
void dump_ARC_extmap (void)
d204 3
a206 2
    struct ExtAuxRegister* r;
    int                    i;
d208 7
a214 1
    r = arc_extension_map.auxRegisters;
d216 2
a217 1
    while (r)
d219 5
a223 2
        printf("AUX : %s %ld\n", r->name, r->address);
        r = r->next;
d226 2
a227 1
    for (i = 0; i < INST_HASH_SIZE; i++)
d229 3
a231 1
        struct ExtInstruction *insn;
d233 14
a246 3
        for (insn = arc_extension_map.instructions[i]; insn != NULL; insn = insn->next)
            printf("INST: %d %d %x %s\n", insn->major, insn->minor, insn->flags, insn->name);
    }
d248 1
a248 1
    for (i = 0; i < NUM_EXT_CORE; i++)
d250 40
a289 1
        struct ExtCoreRegister reg = arc_extension_map.coreRegisters[i];
d291 39
a329 2
        if (reg.name)
            printf("CORE: %s %d %s\n", reg.name, reg.number, ExtReadWrite_image(reg.rw));
d331 2
d334 21
a354 3
    for (i = 0; i < NUM_EXT_COND; i++)
        if (arc_extension_map.condCodes[i])
            printf("COND: %s\n", arc_extension_map.condCodes[i]);
a355 2

/******************************************************************************/
@


1.6
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1995, 1997, 2000, 2001, 2004, 2005
d5 1
a5 1
   This file is part of GDB.
d7 1
a7 1
   This program is free software; you can redistribute it and/or modify
d9 2
a10 2
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d12 4
a15 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.5
log
@	* arc-ext.c: Warning fixes.
	* arc-ext.h: Likewise.
	* cgen-opc.c: Likewise.
	* ia64-gen.c: Likewise.
	* maxq-dis.c: Likewise.
	* ns32k-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* ia64-asmtab.c: Regenerate.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.4
log
@	* arc-ext.c (build_ARC_extmap): Use bfd_get_section_size
	instead of _raw_size.
@
text
@d2 2
a3 1
   Copyright 1995, 1997, 2000, 2001, 2004 Free Software Foundation, Inc.
d62 1
a62 1
  return (const char *) arc_extension_map.coreRegisters[value-32];
d72 1
a72 1
  return (const char *) arc_extension_map.condCodes[value-16];
d191 1
a191 1
	    strcpy(insn_name, (p+5));
d201 1
a201 1
	    strcpy(core_name, (p+3));
d209 1
a209 1
	    strcpy(cc_name, (p+3));
d221 1
a221 1
	    strcpy (aux_name, (p+6));
@


1.3
log
@
	* tic54x-opc.c: Add default initializers to avoid warnings.

	* arc-opc.c: Include "sysdep.h" to get stdio.h as include file.
	* arc-ext.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1995, 1997, 2000, 2001 Free Software Foundation, Inc.
d251 1
a251 1
        count = p->_raw_size;
@


1.3.74.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1995, 1997, 2000, 2001, 2004 Free Software Foundation, Inc.
d251 1
a251 1
        count = bfd_get_section_size (p);
@


1.2
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d1 1
a1 1
/* ARC target-dependent stuff. Extension structure access functions 
d20 1
d33 1
a33 1
arcExtMap_instName(int opcode, int minor, int *flags) 
d35 1
a35 1
    if (opcode == 3) 
d57 1
a57 1
arcExtMap_coreRegName(int value) 
d67 1
a67 1
arcExtMap_condCodeName(int value) 
d92 1
a92 1
static void 
d102 1
a102 1
  else 
d105 1
a105 1
	      
d108 2
a109 2
static void 
cleanup_ext_map(void) 
d117 1
a117 1
  if (r) 
d122 1
a122 1
  
d124 1
a124 1
  for (i = 0; i < NUM_EXT_INST; i++) 
d130 1
a130 1
  
d132 1
a132 1
  for (i = 0; i < NUM_EXT_CORE; i++) 
d137 1
a137 1
  
d142 2
a143 2
  
  memset(&arc_extension_map, 0, sizeof(struct arcExtMap));  
d146 2
a147 2
int 
arcExtMap_add(void *base, unsigned long length) 
d151 1
a151 1
  
d155 1
a155 1
  while (p && p < (block + length)) 
d174 1
a174 1
      
d182 1
a182 1
	    struct ExtInstruction * insn = 
d184 1
a184 1
	    
d195 2
a196 2
	
	case EXT_CORE_REGISTER: 
d204 2
a205 2
	  
	case EXT_COND_CODE: 
d210 1
a210 1
	  }	
d212 2
a213 2
	  
	case EXT_AUX_REGISTER: 
d216 1
a216 1
	    struct ExtAuxRegister *newAuxRegister = 
d227 1
a227 1
	  
d230 1
a230 1
	  
d234 1
a234 1
  
@


1.1
log
@Updated ARC assembler from arccores.com
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1997, 2000 Free Software Foundation, Inc.
@


1.1.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1995, 1997, 2000, 2001 Free Software Foundation, Inc.
@


