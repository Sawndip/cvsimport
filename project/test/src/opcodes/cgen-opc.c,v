head	1.21;
access;
symbols
	sid-snapshot-20180601:1.21
	sid-snapshot-20180501:1.21
	sid-snapshot-20180401:1.21
	sid-snapshot-20180301:1.21
	sid-snapshot-20180201:1.21
	sid-snapshot-20180101:1.21
	sid-snapshot-20171201:1.21
	sid-snapshot-20171101:1.21
	sid-snapshot-20171001:1.21
	sid-snapshot-20170901:1.21
	sid-snapshot-20170801:1.21
	sid-snapshot-20170701:1.21
	sid-snapshot-20170601:1.21
	sid-snapshot-20170501:1.21
	sid-snapshot-20170401:1.21
	sid-snapshot-20170301:1.21
	sid-snapshot-20170201:1.21
	sid-snapshot-20170101:1.21
	sid-snapshot-20161201:1.21
	sid-snapshot-20161101:1.21
	sid-snapshot-20160901:1.21
	sid-snapshot-20160801:1.21
	sid-snapshot-20160701:1.21
	sid-snapshot-20160601:1.21
	sid-snapshot-20160501:1.21
	sid-snapshot-20160401:1.21
	sid-snapshot-20160301:1.21
	sid-snapshot-20160201:1.21
	sid-snapshot-20160101:1.21
	sid-snapshot-20151201:1.21
	sid-snapshot-20151101:1.21
	sid-snapshot-20151001:1.21
	sid-snapshot-20150901:1.21
	sid-snapshot-20150801:1.21
	sid-snapshot-20150701:1.21
	sid-snapshot-20150601:1.21
	sid-snapshot-20150501:1.21
	sid-snapshot-20150401:1.21
	sid-snapshot-20150301:1.21
	sid-snapshot-20150201:1.21
	sid-snapshot-20150101:1.21
	sid-snapshot-20141201:1.21
	sid-snapshot-20141101:1.21
	sid-snapshot-20141001:1.21
	sid-snapshot-20140901:1.21
	sid-snapshot-20140801:1.21
	sid-snapshot-20140701:1.21
	sid-snapshot-20140601:1.21
	sid-snapshot-20140501:1.21
	sid-snapshot-20140401:1.21
	sid-snapshot-20140301:1.21
	sid-snapshot-20140201:1.21
	sid-snapshot-20140101:1.21
	sid-snapshot-20131201:1.21
	sid-snapshot-20131101:1.21
	sid-snapshot-20131001:1.21
	binutils-2_24-branch:1.21.0.8
	binutils-2_24-branchpoint:1.21
	binutils-2_21_1:1.20
	sid-snapshot-20130901:1.21
	gdb_7_6_1-2013-08-30-release:1.21
	sid-snapshot-20130801:1.21
	sid-snapshot-20130701:1.21
	sid-snapshot-20130601:1.21
	sid-snapshot-20130501:1.21
	gdb_7_6-2013-04-26-release:1.21
	sid-snapshot-20130401:1.21
	binutils-2_23_2:1.21
	gdb_7_6-branch:1.21.0.6
	gdb_7_6-2013-03-12-branchpoint:1.21
	sid-snapshot-20130301:1.21
	sid-snapshot-20130201:1.21
	sid-snapshot-20130101:1.21
	sid-snapshot-20121201:1.21
	gdb_7_5_1-2012-11-29-release:1.21
	binutils-2_23_1:1.21
	sid-snapshot-20121101:1.21
	binutils-2_23:1.21
	sid-snapshot-20121001:1.21
	sid-snapshot-20120901:1.21
	gdb_7_5-2012-08-17-release:1.21
	sid-snapshot-20120801:1.21
	binutils-2_23-branch:1.21.0.4
	binutils-2_23-branchpoint:1.21
	gdb_7_5-branch:1.21.0.2
	gdb_7_5-2012-07-18-branchpoint:1.21
	sid-snapshot-20120701:1.21
	sid-snapshot-20120601:1.21
	sid-snapshot-20120501:1.20
	binutils-2_22_branch:1.20.0.14
	gdb_7_4_1-2012-04-26-release:1.20
	sid-snapshot-20120401:1.20
	sid-snapshot-20120301:1.20
	sid-snapshot-20120201:1.20
	gdb_7_4-2012-01-24-release:1.20
	sid-snapshot-20120101:1.20
	gdb_7_4-branch:1.20.0.12
	gdb_7_4-2011-12-13-branchpoint:1.20
	sid-snapshot-20111201:1.20
	binutils-2_22:1.20
	sid-snapshot-20111101:1.20
	sid-snapshot-20111001:1.20
	binutils-2_22-branch:1.20.0.10
	binutils-2_22-branchpoint:1.20
	gdb_7_3_1-2011-09-04-release:1.20
	sid-snapshot-20110901:1.20
	sid-snapshot-20110801:1.20
	gdb_7_3-2011-07-26-release:1.20
	sid-snapshot-20110701:1.20
	sid-snapshot-20110601:1.20
	sid-snapshot-20110501:1.20
	gdb_7_3-branch:1.20.0.8
	gdb_7_3-2011-04-01-branchpoint:1.20
	sid-snapshot-20110401:1.20
	sid-snapshot-20110301:1.20
	sid-snapshot-20110201:1.20
	sid-snapshot-20110101:1.20
	binutils-2_21:1.20
	sid-snapshot-20101201:1.20
	binutils-2_21-branch:1.20.0.6
	binutils-2_21-branchpoint:1.20
	sid-snapshot-20101101:1.20
	sid-snapshot-20101001:1.20
	binutils-2_20_1:1.19
	gdb_7_2-2010-09-02-release:1.20
	sid-snapshot-20100901:1.20
	sid-snapshot-20100801:1.20
	gdb_7_2-branch:1.20.0.4
	gdb_7_2-2010-07-07-branchpoint:1.20
	sid-snapshot-20100701:1.20
	sid-snapshot-20100601:1.20
	sid-snapshot-20100501:1.20
	sid-snapshot-20100401:1.20
	gdb_7_1-2010-03-18-release:1.20
	sid-snapshot-20100301:1.20
	gdb_7_1-branch:1.20.0.2
	gdb_7_1-2010-02-18-branchpoint:1.20
	sid-snapshot-20100201:1.20
	sid-snapshot-20100101:1.20
	gdb_7_0_1-2009-12-22-release:1.19
	sid-snapshot-20091201:1.19
	sid-snapshot-20091101:1.19
	binutils-2_20:1.19
	gdb_7_0-2009-10-06-release:1.19
	sid-snapshot-20091001:1.19
	gdb_7_0-branch:1.19.0.8
	gdb_7_0-2009-09-16-branchpoint:1.19
	arc-sim-20090309:1.18
	binutils-arc-20081103-branch:1.18.0.26
	binutils-arc-20081103-branchpoint:1.18
	binutils-2_20-branch:1.19.0.6
	binutils-2_20-branchpoint:1.19
	sid-snapshot-20090901:1.19
	sid-snapshot-20090801:1.19
	msnyder-checkpoint-072509-branch:1.19.0.4
	msnyder-checkpoint-072509-branchpoint:1.19
	sid-snapshot-20090701:1.19
	dje-cgen-play1-branch:1.19.0.2
	dje-cgen-play1-branchpoint:1.19
	sid-snapshot-20090601:1.19
	sid-snapshot-20090501:1.19
	sid-snapshot-20090401:1.19
	arc-20081103-branch:1.18.0.24
	arc-20081103-branchpoint:1.18
	arc-insight_6_8-branch:1.18.0.22
	arc-insight_6_8-branchpoint:1.18
	insight_6_8-branch:1.18.0.20
	insight_6_8-branchpoint:1.18
	sid-snapshot-20090301:1.18
	binutils-2_19_1:1.18
	sid-snapshot-20090201:1.18
	sid-snapshot-20090101:1.18
	reverse-20081226-branch:1.18.0.18
	reverse-20081226-branchpoint:1.18
	sid-snapshot-20081201:1.18
	multiprocess-20081120-branch:1.18.0.16
	multiprocess-20081120-branchpoint:1.18
	sid-snapshot-20081101:1.18
	binutils-2_19:1.18
	sid-snapshot-20081001:1.18
	reverse-20080930-branch:1.18.0.14
	reverse-20080930-branchpoint:1.18
	binutils-2_19-branch:1.18.0.12
	binutils-2_19-branchpoint:1.18
	sid-snapshot-20080901:1.18
	sid-snapshot-20080801:1.18
	reverse-20080717-branch:1.18.0.10
	reverse-20080717-branchpoint:1.18
	sid-snapshot-20080701:1.18
	msnyder-reverse-20080609-branch:1.18.0.8
	msnyder-reverse-20080609-branchpoint:1.18
	drow-reverse-20070409-branch:1.17.0.24
	drow-reverse-20070409-branchpoint:1.17
	sid-snapshot-20080601:1.18
	sid-snapshot-20080501:1.18
	sid-snapshot-20080403:1.18
	sid-snapshot-20080401:1.18
	gdb_6_8-2008-03-27-release:1.18
	sid-snapshot-20080301:1.18
	gdb_6_8-branch:1.18.0.6
	gdb_6_8-2008-02-26-branchpoint:1.18
	sid-snapshot-20080201:1.18
	sid-snapshot-20080101:1.18
	sid-snapshot-20071201:1.18
	sid-snapshot-20071101:1.18
	gdb_6_7_1-2007-10-29-release:1.18
	gdb_6_7-2007-10-10-release:1.18
	sid-snapshot-20071001:1.18
	gdb_6_7-branch:1.18.0.4
	gdb_6_7-2007-09-07-branchpoint:1.18
	binutils-2_18:1.18
	binutils-2_18-branch:1.18.0.2
	binutils-2_18-branchpoint:1.18
	insight_6_6-20070208-release:1.17
	binutils-csl-coldfire-4_1-32:1.17
	binutils-csl-sourcerygxx-4_1-32:1.17
	gdb_6_6-2006-12-18-release:1.17
	binutils-csl-innovasic-fido-3_4_4-33:1.17
	binutils-csl-sourcerygxx-3_4_4-32:1.13
	binutils-csl-coldfire-4_1-30:1.17
	binutils-csl-sourcerygxx-4_1-30:1.17
	binutils-csl-coldfire-4_1-28:1.17
	binutils-csl-sourcerygxx-4_1-29:1.17
	binutils-csl-sourcerygxx-4_1-28:1.17
	gdb_6_6-branch:1.17.0.22
	gdb_6_6-2006-11-15-branchpoint:1.17
	binutils-csl-arm-2006q3-27:1.17
	binutils-csl-sourcerygxx-4_1-27:1.17
	binutils-csl-arm-2006q3-26:1.17
	binutils-csl-sourcerygxx-4_1-26:1.17
	binutils-csl-sourcerygxx-4_1-25:1.17
	binutils-csl-sourcerygxx-4_1-24:1.17
	binutils-csl-sourcerygxx-4_1-23:1.17
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	binutils-csl-sourcerygxx-4_1-21:1.17
	binutils-csl-arm-2006q3-21:1.17
	binutils-csl-sourcerygxx-4_1-22:1.17
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.17
	binutils-csl-sourcerygxx-4_1-20:1.17
	binutils-csl-arm-2006q3-19:1.17
	binutils-csl-sourcerygxx-4_1-19:1.17
	binutils-csl-sourcerygxx-4_1-18:1.17
	binutils-csl-renesas-4_1-9:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.16
	binutils-csl-sourcerygxx-3_4_4-25:1.13
	nickrob-async-20060828-mergepoint:1.17
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	binutils-csl-renesas-4_1-8:1.17
	binutils-csl-renesas-4_1-7:1.17
	binutils-csl-renesas-4_1-6:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17
	binutils-csl-sourcerygxx-4_1-17:1.17
	gdb-csl-20060226-branch-local-2:1.17
	gdb-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-15:1.17
	gdb-csl-sourcerygxx-4_1-13:1.17
	binutils-csl-sourcerygxx-4_1-13:1.17
	binutils-2_17:1.17
	gdb-csl-sourcerygxx-4_1-12:1.17
	binutils-csl-sourcerygxx-4_1-12:1.17
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	binutils-csl-sourcerygxx-3_4_4-21:1.17
	gdb_6_5-20060621-release:1.17
	binutils-csl-wrs-linux-3_4_4-24:1.13
	binutils-csl-wrs-linux-3_4_4-23:1.13
	gdb-csl-sourcerygxx-4_1-9:1.17
	binutils-csl-sourcerygxx-4_1-9:1.17
	gdb-csl-sourcerygxx-4_1-8:1.17
	binutils-csl-sourcerygxx-4_1-8:1.17
	gdb-csl-sourcerygxx-4_1-7:1.17
	binutils-csl-sourcerygxx-4_1-7:1.17
	gdb-csl-arm-2006q1-6:1.17
	binutils-csl-arm-2006q1-6:1.17
	gdb-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-wrs-linux-3_4_4-22:1.13
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	binutils-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	binutils-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.17.0.20
	gdb_6_5-2006-05-14-branchpoint:1.17
	binutils-csl-coldfire-4_1-10:1.17
	gdb-csl-sourcerygxx-4_1-5:1.17
	binutils-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.17.0.18
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.17
	binutils-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.17.0.16
	msnyder-reverse-20060502-branchpoint:1.17
	binutils-csl-wrs-linux-3_4_4-21:1.13
	gdb-csl-morpho-4_1-4:1.17
	binutils-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-wrs-linux-3_4_4-20:1.13
	readline_5_1-import-branch:1.17.0.14
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	binutils-2_17-branch:1.17.0.12
	binutils-2_17-branchpoint:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.10
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.8
	msnyder-reverse-20060331-branchpoint:1.17
	binutils-csl-2_17-branch:1.17.0.6
	binutils-csl-2_17-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.4
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.2
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.16
	msnyder-fork-checkpoint-branch:1.16.0.6
	msnyder-fork-checkpoint-branchpoint:1.16
	gdb-csl-gxxpro-6_3-branch:1.16.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.16
	gdb_6_4-branch:1.16.0.2
	gdb_6_4-2005-11-01-branchpoint:1.16
	gdb-csl-arm-20051020-branch:1.15.0.2
	gdb-csl-arm-20051020-branchpoint:1.15
	binutils-csl-gxxpro-3_4-branch:1.13.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.13
	binutils-2_16_1:1.13
	msnyder-tracepoint-checkpoint-branch:1.14.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.14
	gdb-csl-arm-20050325-2005-q1b:1.13
	binutils-csl-arm-2005q1b:1.13
	binutils-2_16:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	binutils-csl-arm-2005q1a:1.13
	csl-arm-20050325-branch:1.13.0.6
	csl-arm-20050325-branchpoint:1.13
	binutils-csl-arm-2005q1-branch:1.13.0.4
	binutils-csl-arm-2005q1-branchpoint:1.13
	binutils-2_16-branch:1.13.0.2
	binutils-2_16-branchpoint:1.13
	csl-arm-2004-q3d:1.12
	gdb_6_3-20041109-release:1.12
	gdb_6_3-branch:1.12.0.24
	gdb_6_3-20041019-branchpoint:1.12
	csl-arm-2004-q3:1.12
	drow_intercu-merge-20040921:1.12
	drow_intercu-merge-20040915:1.12
	jimb-gdb_6_2-e500-branch:1.12.0.26
	jimb-gdb_6_2-e500-branchpoint:1.12
	gdb_6_2-20040730-release:1.12
	gdb_6_2-branch:1.12.0.22
	gdb_6_2-2004-07-10-gmt-branchpoint:1.12
	gdb_6_1_1-20040616-release:1.12
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	gdb_6_1-2004-04-05-release:1.12
	drow_intercu-merge-20040402:1.12
	drow_intercu-merge-20040327:1.12
	ezannoni_pie-20040323-branch:1.12.0.20
	ezannoni_pie-20040323-branchpoint:1.12
	cagney_tramp-20040321-mergepoint:1.12
	cagney_tramp-20040309-branch:1.12.0.18
	cagney_tramp-20040309-branchpoint:1.12
	gdb_6_1-branch:1.12.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.12
	drow_intercu-20040221-branch:1.12.0.14
	drow_intercu-20040221-branchpoint:1.12
	binutils-2_15-branch:1.12.0.12
	cagney_bfdfile-20040213-branch:1.12.0.10
	cagney_bfdfile-20040213-branchpoint:1.12
	drow-cplus-merge-20040208:1.12
	carlton_dictionary-20040126-merge:1.12
	cagney_bigcore-20040122-branch:1.12.0.8
	cagney_bigcore-20040122-branchpoint:1.12
	drow-cplus-merge-20040113:1.12
	csl-arm-2003-q4:1.12
	drow-cplus-merge-20031224:1.12
	drow-cplus-merge-20031220:1.12
	carlton_dictionary-20031215-merge:1.12
	drow-cplus-merge-20031214:1.12
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.11
	kettenis_sparc-20030918-branch:1.12.0.6
	kettenis_sparc-20030918-branchpoint:1.12
	carlton_dictionary-20030917-merge:1.12
	ezannoni_pie-20030916-branchpoint:1.12
	ezannoni_pie-20030916-branch:1.12.0.4
	cagney_x86i386-20030821-branch:1.12.0.2
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.11
	carlton_dictionary-20030627-merge:1.11
	gdb_6_0-branch:1.11.0.60
	gdb_6_0-2003-06-23-branchpoint:1.11
	jimb-ppc64-linux-20030613-branch:1.11.0.58
	jimb-ppc64-linux-20030613-branchpoint:1.11
	binutils-2_14:1.11
	cagney_convert-20030606-branch:1.11.0.56
	cagney_convert-20030606-branchpoint:1.11
	cagney_writestrings-20030508-branch:1.11.0.54
	cagney_writestrings-20030508-branchpoint:1.11
	jimb-ppc64-linux-20030528-branch:1.11.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.11
	carlton_dictionary-20030523-merge:1.11
	cagney_fileio-20030521-branch:1.11.0.50
	cagney_fileio-20030521-branchpoint:1.11
	kettenis_i386newframe-20030517-mergepoint:1.11
	jimb-ppc64-linux-20030509-branch:1.11.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.11
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	binutils-2_14-branch:1.11.0.46
	binutils-2_14-branchpoint:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.44
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.42
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.40
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.11.0.38
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.11.0.36
	cagney_lazyid-20030317-branchpoint:1.11
	kettenis-i386newframe-20030316-mergepoint:1.11
	offbyone-20030313-branch:1.11.0.34
	offbyone-20030313-branchpoint:1.11
	kettenis-i386newframe-20030308-branch:1.11.0.32
	kettenis-i386newframe-20030308-branchpoint:1.11
	carlton_dictionary-20030305-merge:1.11
	cagney_offbyone-20030303-branch:1.11.0.30
	cagney_offbyone-20030303-branchpoint:1.11
	carlton_dictionary-20030207-merge:1.11
	interps-20030202-branch:1.11.0.28
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.11.0.26
	cagney-unwind-20030108-branchpoint:1.11
	binutils-2_13_2_1:1.11
	binutils-2_13_2:1.11
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.11
	carlton_dictionary-20021115-merge:1.11
	binutils-2_13_1:1.11
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.24
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.22
	carlton_dictionary-20020920-branchpoint:1.11
	sid-20020905-branchpoint:1.11
	sid-20020905-branch:1.11.0.20
	gdb_5_3-branch:1.11.0.18
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.11.0.16
	cagney_sysregs-20020825-branchpoint:1.11
	readline_4_3-import-branch:1.11.0.14
	readline_4_3-import-branchpoint:1.11
	binutils-2_13:1.11
	gdb_5_2_1-2002-07-23-release:1.11
	binutils-2_13-branchpoint:1.11
	binutils-2_13-branch:1.11.0.12
	kseitz_interps-20020528-branch:1.11.0.10
	kseitz_interps-20020528-branchpoint:1.11
	cagney_regbuf-20020515-branch:1.11.0.8
	cagney_regbuf-20020515-branchpoint:1.11
	binutils-2_12_1:1.11
	jimb-macro-020506-branch:1.11.0.6
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.11
	binutils-2_12:1.11
	gdb_5_2-branch:1.11.0.4
	gdb_5_2-2002-03-03-branchpoint:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.11
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	binutils-2_11_2:1.5.2.1
	binutils-2_11_1:1.5.2.1
	binutils-2_11:1.5
	x86_64versiong3:1.6
	binutils-2_11-branch:1.5.0.2
	insight-precleanup-2001-01-01:1.4
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.21
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2012.05.17.15.13.24;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.11.13.42.16;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.18.11.47.18;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.05.09.49.00;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.02.20.09.42;	author brolley;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.28.19.49.21;	author brolley;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.01.11.16.31;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.07.07.34.27;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.22.13.01.52;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.08.21.21.24;	author meissner;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.19.05.33.36;	author hjl;	state Exp;
branches
	1.11.22.1
	1.11.24.1;
next	1.10;

1.10
date	2001.07.12.02.32.25;	author fche;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.29.00.09.16;	author geoffk;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.14.20.38.41;	author geoffk;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.13.22.58.34;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.21.21.54.31;	author gkm;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.02.16.34.07;	author fche;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.12.21.18.43.33;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.26.22.45.49;	author brolley;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.24.23.58.52;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.11.22.1
date	2003.09.17.21.28.57;	author carlton;	state Exp;
branches;
next	;

1.11.24.1
date	2003.12.14.20.28.04;	author drow;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.18.34;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.59;	author rth;	state Exp;
branches;
next	;


desc
@@


1.21
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* CGEN generic opcode support.

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005, 2007, 2009,
   2012  Free Software Foundation, Inc.

   This file is part of libopcodes.

   This library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

#include "sysdep.h"
#include "alloca-conf.h"
#include <stdio.h>
#include "ansidecl.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "bfd.h"
#include "symcat.h"
#include "opcode/cgen.h"

static unsigned int hash_keyword_name
  (const CGEN_KEYWORD *, const char *, int);
static unsigned int hash_keyword_value
  (const CGEN_KEYWORD *, unsigned int);
static void build_keyword_hash_tables
  (CGEN_KEYWORD *);

/* Return number of hash table entries to use for N elements.  */
#define KEYWORD_HASH_SIZE(n) ((n) <= 31 ? 17 : 31)

/* Look up *NAMEP in the keyword table KT.
   The result is the keyword entry or NULL if not found.  */

const CGEN_KEYWORD_ENTRY *
cgen_keyword_lookup_name (CGEN_KEYWORD *kt, const char *name)
{
  const CGEN_KEYWORD_ENTRY *ke;
  const char *p,*n;

  if (kt->name_hash_table == NULL)
    build_keyword_hash_tables (kt);

  ke = kt->name_hash_table[hash_keyword_name (kt, name, 0)];

  /* We do case insensitive comparisons.
     If that ever becomes a problem, add an attribute that denotes
     "do case sensitive comparisons".  */

  while (ke != NULL)
    {
      n = name;
      p = ke->name;

      while (*p
	     && (*p == *n
		 || (ISALPHA (*p) && (TOLOWER (*p) == TOLOWER (*n)))))
	++n, ++p;

      if (!*p && !*n)
	return ke;

      ke = ke->next_name;
    }

  if (kt->null_entry)
    return kt->null_entry;
  return NULL;
}

/* Look up VALUE in the keyword table KT.
   The result is the keyword entry or NULL if not found.  */

const CGEN_KEYWORD_ENTRY *
cgen_keyword_lookup_value (CGEN_KEYWORD *kt, int value)
{
  const CGEN_KEYWORD_ENTRY *ke;

  if (kt->name_hash_table == NULL)
    build_keyword_hash_tables (kt);

  ke = kt->value_hash_table[hash_keyword_value (kt, value)];

  while (ke != NULL)
    {
      if (value == ke->value)
	return ke;
      ke = ke->next_value;
    }

  return NULL;
}

/* Add an entry to a keyword table.  */

void
cgen_keyword_add (CGEN_KEYWORD *kt, CGEN_KEYWORD_ENTRY *ke)
{
  unsigned int hash;
  size_t i;

  if (kt->name_hash_table == NULL)
    build_keyword_hash_tables (kt);

  hash = hash_keyword_name (kt, ke->name, 0);
  ke->next_name = kt->name_hash_table[hash];
  kt->name_hash_table[hash] = ke;

  hash = hash_keyword_value (kt, ke->value);
  ke->next_value = kt->value_hash_table[hash];
  kt->value_hash_table[hash] = ke;

  if (ke->name[0] == 0)
    kt->null_entry = ke;

  for (i = 1; i < strlen (ke->name); i++)
    if (! ISALNUM (ke->name[i])
	&& ! strchr (kt->nonalpha_chars, ke->name[i]))
      {
	size_t idx = strlen (kt->nonalpha_chars);
	
	/* If you hit this limit, please don't just
	   increase the size of the field, instead
	   look for a better algorithm.  */
	if (idx >= sizeof (kt->nonalpha_chars) - 1)
	  abort ();
	kt->nonalpha_chars[idx] = ke->name[i];
	kt->nonalpha_chars[idx+1] = 0;
      }
}

/* FIXME: Need function to return count of keywords.  */

/* Initialize a keyword table search.
   SPEC is a specification of what to search for.
   A value of NULL means to find every keyword.
   Currently NULL is the only acceptable value [further specification
   deferred].
   The result is an opaque data item used to record the search status.
   It is passed to each call to cgen_keyword_search_next.  */

CGEN_KEYWORD_SEARCH
cgen_keyword_search_init (CGEN_KEYWORD *kt, const char *spec)
{
  CGEN_KEYWORD_SEARCH search;

  /* FIXME: Need to specify format of params.  */
  if (spec != NULL)
    abort ();

  if (kt->name_hash_table == NULL)
    build_keyword_hash_tables (kt);

  search.table = kt;
  search.spec = spec;
  search.current_hash = 0;
  search.current_entry = NULL;
  return search;
}

/* Return the next keyword specified by SEARCH.
   The result is the next entry or NULL if there are no more.  */

const CGEN_KEYWORD_ENTRY *
cgen_keyword_search_next (CGEN_KEYWORD_SEARCH *search)
{
  /* Has search finished?  */
  if (search->current_hash == search->table->hash_table_size)
    return NULL;

  /* Search in progress?  */
  if (search->current_entry != NULL
      /* Anything left on this hash chain?  */
      && search->current_entry->next_name != NULL)
    {
      search->current_entry = search->current_entry->next_name;
      return search->current_entry;
    }

  /* Move to next hash chain [unless we haven't started yet].  */
  if (search->current_entry != NULL)
    ++search->current_hash;

  while (search->current_hash < search->table->hash_table_size)
    {
      search->current_entry = search->table->name_hash_table[search->current_hash];
      if (search->current_entry != NULL)
	return search->current_entry;
      ++search->current_hash;
    }

  return NULL;
}

/* Return first entry in hash chain for NAME.
   If CASE_SENSITIVE_P is non-zero, return a case sensitive hash.  */

static unsigned int
hash_keyword_name (const CGEN_KEYWORD *kt,
		   const char *name,
		   int case_sensitive_p)
{
  unsigned int hash;

  if (case_sensitive_p)
    for (hash = 0; *name; ++name)
      hash = (hash * 97) + (unsigned char) *name;
  else
    for (hash = 0; *name; ++name)
      hash = (hash * 97) + (unsigned char) TOLOWER (*name);
  return hash % kt->hash_table_size;
}

/* Return first entry in hash chain for VALUE.  */

static unsigned int
hash_keyword_value (const CGEN_KEYWORD *kt, unsigned int value)
{
  return value % kt->hash_table_size;
}

/* Build a keyword table's hash tables.
   We probably needn't build the value hash table for the assembler when
   we're using the disassembler, but we keep things simple.  */

static void
build_keyword_hash_tables (CGEN_KEYWORD *kt)
{
  int i;
  /* Use the number of compiled in entries as an estimate for the
     typical sized table [not too many added at runtime].  */
  unsigned int size = KEYWORD_HASH_SIZE (kt->num_init_entries);

  kt->hash_table_size = size;
  kt->name_hash_table = (CGEN_KEYWORD_ENTRY **)
    xmalloc (size * sizeof (CGEN_KEYWORD_ENTRY *));
  memset (kt->name_hash_table, 0, size * sizeof (CGEN_KEYWORD_ENTRY *));
  kt->value_hash_table = (CGEN_KEYWORD_ENTRY **)
    xmalloc (size * sizeof (CGEN_KEYWORD_ENTRY *));
  memset (kt->value_hash_table, 0, size * sizeof (CGEN_KEYWORD_ENTRY *));

  /* The table is scanned backwards as we want keywords appearing earlier to
     be prefered over later ones.  */
  for (i = kt->num_init_entries - 1; i >= 0; --i)
    cgen_keyword_add (kt, &kt->init_entries[i]);
}

/* Hardware support.  */

/* Lookup a hardware element by its name.
   Returns NULL if NAME is not supported by the currently selected
   mach/isa.  */

const CGEN_HW_ENTRY *
cgen_hw_lookup_by_name (CGEN_CPU_DESC cd, const char *name)
{
  unsigned int i;
  const CGEN_HW_ENTRY **hw = cd->hw_table.entries;

  for (i = 0; i < cd->hw_table.num_entries; ++i)
    if (hw[i] && strcmp (name, hw[i]->name) == 0)
      return hw[i];

  return NULL;
}

/* Lookup a hardware element by its number.
   Hardware elements are enumerated, however it may be possible to add some
   at runtime, thus HWNUM is not an enum type but rather an int.
   Returns NULL if HWNUM is not supported by the currently selected mach.  */

const CGEN_HW_ENTRY *
cgen_hw_lookup_by_num (CGEN_CPU_DESC cd, unsigned int hwnum)
{
  unsigned int i;
  const CGEN_HW_ENTRY **hw = cd->hw_table.entries;

  /* ??? This can be speeded up.  */
  for (i = 0; i < cd->hw_table.num_entries; ++i)
    if (hw[i] && hwnum == hw[i]->type)
      return hw[i];

  return NULL;
}

/* Operand support.  */

/* Lookup an operand by its name.
   Returns NULL if NAME is not supported by the currently selected
   mach/isa.  */

const CGEN_OPERAND *
cgen_operand_lookup_by_name (CGEN_CPU_DESC cd, const char *name)
{
  unsigned int i;
  const CGEN_OPERAND **op = cd->operand_table.entries;

  for (i = 0; i < cd->operand_table.num_entries; ++i)
    if (op[i] && strcmp (name, op[i]->name) == 0)
      return op[i];

  return NULL;
}

/* Lookup an operand by its number.
   Operands are enumerated, however it may be possible to add some
   at runtime, thus OPNUM is not an enum type but rather an int.
   Returns NULL if OPNUM is not supported by the currently selected
   mach/isa.  */

const CGEN_OPERAND *
cgen_operand_lookup_by_num (CGEN_CPU_DESC cd, int opnum)
{
  return cd->operand_table.entries[opnum];
}

/* Instruction support.  */

/* Return number of instructions.  This includes any added at runtime.  */

int
cgen_insn_count (CGEN_CPU_DESC cd)
{
  int count = cd->insn_table.num_init_entries;
  CGEN_INSN_LIST *rt_insns = cd->insn_table.new_entries;

  for ( ; rt_insns != NULL; rt_insns = rt_insns->next)
    ++count;

  return count;
}

/* Return number of macro-instructions.
   This includes any added at runtime.  */

int
cgen_macro_insn_count (CGEN_CPU_DESC cd)
{
  int count = cd->macro_insn_table.num_init_entries;
  CGEN_INSN_LIST *rt_insns = cd->macro_insn_table.new_entries;

  for ( ; rt_insns != NULL; rt_insns = rt_insns->next)
    ++count;

  return count;
}

/* Cover function to read and properly byteswap an insn value.  */

CGEN_INSN_INT
cgen_get_insn_value (CGEN_CPU_DESC cd, unsigned char *buf, int length)
{
  int big_p = (cd->insn_endian == CGEN_ENDIAN_BIG);
  int insn_chunk_bitsize = cd->insn_chunk_bitsize;
  CGEN_INSN_INT value = 0;

  if (insn_chunk_bitsize != 0 && insn_chunk_bitsize < length)
    {
      /* We need to divide up the incoming value into insn_chunk_bitsize-length
	 segments, and endian-convert them, one at a time. */
      int i;

      /* Enforce divisibility. */ 
      if ((length % insn_chunk_bitsize) != 0)
	abort ();

      for (i = 0; i < length; i += insn_chunk_bitsize) /* NB: i == bits */
	{
	  int bit_index;
	  bfd_vma this_value;

	  bit_index = i; /* NB: not dependent on endianness; opposite of cgen_put_insn_value! */
	  this_value = bfd_get_bits (& buf[bit_index / 8], insn_chunk_bitsize, big_p);
	  value = (value << insn_chunk_bitsize) | this_value;
	}
    }
  else
    {
      value = bfd_get_bits (buf, length, cd->insn_endian == CGEN_ENDIAN_BIG);
    }

  return value;
}

/* Cover function to store an insn value properly byteswapped.  */

void
cgen_put_insn_value (CGEN_CPU_DESC cd,
		     unsigned char *buf,
		     int length,
		     CGEN_INSN_INT value)
{
  int big_p = (cd->insn_endian == CGEN_ENDIAN_BIG);
  int insn_chunk_bitsize = cd->insn_chunk_bitsize;

  if (insn_chunk_bitsize != 0 && insn_chunk_bitsize < length)
    {
      /* We need to divide up the incoming value into insn_chunk_bitsize-length
	 segments, and endian-convert them, one at a time. */
      int i;

      /* Enforce divisibility. */ 
      if ((length % insn_chunk_bitsize) != 0)
	abort ();

      for (i = 0; i < length; i += insn_chunk_bitsize) /* NB: i == bits */
	{
	  int bit_index;

	  bit_index = (length - insn_chunk_bitsize - i); /* NB: not dependent on endianness! */
	  bfd_put_bits ((bfd_vma) value, & buf[bit_index / 8], insn_chunk_bitsize, big_p);
	  value >>= insn_chunk_bitsize;
	}
    }
  else
    {
      bfd_put_bits ((bfd_vma) value, buf, length, big_p);
    }
}

/* Look up instruction INSN_*_VALUE and extract its fields.
   INSN_INT_VALUE is used if CGEN_INT_INSN_P.
   Otherwise INSN_BYTES_VALUE is used.
   INSN, if non-null, is the insn table entry.
   Otherwise INSN_*_VALUE is examined to compute it.
   LENGTH is the bit length of INSN_*_VALUE if known, otherwise 0.
   0 is only valid if `insn == NULL && ! CGEN_INT_INSN_P'.
   If INSN != NULL, LENGTH must be valid.
   ALIAS_P is non-zero if alias insns are to be included in the search.

   The result is a pointer to the insn table entry, or NULL if the instruction
   wasn't recognized.  */

/* ??? Will need to be revisited for VLIW architectures.  */

const CGEN_INSN *
cgen_lookup_insn (CGEN_CPU_DESC cd,
		  const CGEN_INSN *insn,
		  CGEN_INSN_INT insn_int_value,
		  /* ??? CGEN_INSN_BYTES would be a nice type name to use here.  */
		  unsigned char *insn_bytes_value,
		  int length,
		  CGEN_FIELDS *fields,
		  int alias_p)
{
  unsigned char *buf;
  CGEN_INSN_INT base_insn;
  CGEN_EXTRACT_INFO ex_info;
  CGEN_EXTRACT_INFO *info;

  if (cd->int_insn_p)
    {
      info = NULL;
      buf = (unsigned char *) alloca (cd->max_insn_bitsize / 8);
      cgen_put_insn_value (cd, buf, length, insn_int_value);
      base_insn = insn_int_value;
    }
  else
    {
      info = &ex_info;
      ex_info.dis_info = NULL;
      ex_info.insn_bytes = insn_bytes_value;
      ex_info.valid = -1;
      buf = insn_bytes_value;
      base_insn = cgen_get_insn_value (cd, buf, length);
    }

  if (!insn)
    {
      const CGEN_INSN_LIST *insn_list;

      /* The instructions are stored in hash lists.
	 Pick the first one and keep trying until we find the right one.  */

      insn_list = cgen_dis_lookup_insn (cd, (char *) buf, base_insn);
      while (insn_list != NULL)
	{
	  insn = insn_list->insn;

	  if (alias_p
	      /* FIXME: Ensure ALIAS attribute always has same index.  */
	      || ! CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_ALIAS))
	    {
	      /* Basic bit mask must be correct.  */
	      /* ??? May wish to allow target to defer this check until the
		 extract handler.  */
	      if ((base_insn & CGEN_INSN_BASE_MASK (insn))
		  == CGEN_INSN_BASE_VALUE (insn))
		{
		  /* ??? 0 is passed for `pc' */
		  int elength = CGEN_EXTRACT_FN (cd, insn)
		    (cd, insn, info, base_insn, fields, (bfd_vma) 0);
		  if (elength > 0)
		    {
		      /* sanity check */
		      if (length != 0 && length != elength)
			abort ();
		      return insn;
		    }
		}
	    }

	  insn_list = insn_list->next;
	}
    }
  else
    {
      /* Sanity check: can't pass an alias insn if ! alias_p.  */
      if (! alias_p
	  && CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_ALIAS))
	abort ();
      /* Sanity check: length must be correct.  */
      if (length != CGEN_INSN_BITSIZE (insn))
	abort ();

      /* ??? 0 is passed for `pc' */
      length = CGEN_EXTRACT_FN (cd, insn)
	(cd, insn, info, base_insn, fields, (bfd_vma) 0);
      /* Sanity check: must succeed.
	 Could relax this later if it ever proves useful.  */
      if (length == 0)
	abort ();
      return insn;
    }

  return NULL;
}

/* Fill in the operand instances used by INSN whose operands are FIELDS.
   INDICES is a pointer to a buffer of MAX_OPERAND_INSTANCES ints to be filled
   in.  */

void
cgen_get_insn_operands (CGEN_CPU_DESC cd,
			const CGEN_INSN *insn,
			const CGEN_FIELDS *fields,
			int *indices)
{
  const CGEN_OPINST *opinst;
  int i;

  if (insn->opinst == NULL)
    abort ();
  for (i = 0, opinst = insn->opinst; opinst->type != CGEN_OPINST_END; ++i, ++opinst)
    {
      enum cgen_operand_type op_type = opinst->op_type;
      if (op_type == CGEN_OPERAND_NIL)
	indices[i] = opinst->index;
      else
	indices[i] = (*cd->get_int_operand) (cd, op_type, fields);
    }
}

/* Cover function to cgen_get_insn_operands when either INSN or FIELDS
   isn't known.
   The INSN, INSN_*_VALUE, and LENGTH arguments are passed to
   cgen_lookup_insn unchanged.
   INSN_INT_VALUE is used if CGEN_INT_INSN_P.
   Otherwise INSN_BYTES_VALUE is used.

   The result is the insn table entry or NULL if the instruction wasn't
   recognized.  */

const CGEN_INSN *
cgen_lookup_get_insn_operands (CGEN_CPU_DESC cd,
			       const CGEN_INSN *insn,
			       CGEN_INSN_INT insn_int_value,
			       /* ??? CGEN_INSN_BYTES would be a nice type name to use here.  */
			       unsigned char *insn_bytes_value,
			       int length,
			       int *indices,
			       CGEN_FIELDS *fields)
{
  /* Pass non-zero for ALIAS_P only if INSN != NULL.
     If INSN == NULL, we want a real insn.  */
  insn = cgen_lookup_insn (cd, insn, insn_int_value, insn_bytes_value,
			   length, fields, insn != NULL);
  if (! insn)
    return NULL;

  cgen_get_insn_operands (cd, insn, fields, indices);
  return insn;
}

/* Allow signed overflow of instruction fields.  */
void
cgen_set_signed_overflow_ok (CGEN_CPU_DESC cd)
{
  cd->signed_overflow_ok_p = 1;
}

/* Generate an error message if a signed field in an instruction overflows.  */
void
cgen_clear_signed_overflow_ok (CGEN_CPU_DESC cd)
{
  cd->signed_overflow_ok_p = 0;
}

/* Will an error message be generated if a signed field in an instruction overflows ? */
unsigned int
cgen_signed_overflow_ok_p (CGEN_CPU_DESC cd)
{
  return cd->signed_overflow_ok_p;
}
@


1.20
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005, 2007, 2009
   Free Software Foundation, Inc.
d22 1
a23 1
#include "sysdep.h"
@


1.19
log
@bfd/
	* vms-hdr.c: Don't include alloca.h.
opcodes/
	* cgen-opc.c: Include alloca-conf.h rather than alloca.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
@
text
@d379 1
a379 1
	  int index;
d381 3
a383 2
	  index = i; /* NB: not dependent on endianness; opposite of cgen_put_insn_value! */
	  this_value = bfd_get_bits (& buf[index / 8], insn_chunk_bitsize, big_p);
d418 4
a421 3
	  int index;
	  index = (length - insn_chunk_bitsize - i); /* NB: not dependent on endianness! */
	  bfd_put_bits ((bfd_vma) value, & buf[index / 8], insn_chunk_bitsize, big_p);
@


1.18
log
@Change source files over to GPLv3.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005, 2007
d22 1
a31 4
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#endif

@


1.17
log
@2005-12-02  Dave Brolley  <brolley@@redhat.com>

        * configure.in (cgen_files): Add cgen-bitset.lo.
        (ta): Add cgen-bitset.lo when arch==bfd_cris_arch.
        * Makefile.am (CFILES): Add cgen-bitset.c.
        (ALL_MACHINES): Add cgen-bitset.lo.
        (cgen-bitset.lo): New target.
        * cgen-opc.c (cgen_bitset_create, cgen_bitset_init, cgen_bitset_clear)
        (cgen_bitset_add, cgen_bitset_set, cgen_bitset_contains)
        (cgen_bitset_compare, cgen_bitset_intersect_p, cgen_bitset_copy)
        (cgen_bitset_union): Moved from here ...
        * cgen-bitset.c: ... to here. New file.
        * Makefile.in: Regenerated.
        * configure: Regenerated.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005
d6 1
a6 1
   This file is part of the GNU Binutils and GDB, the GNU debugger.
d8 1
a8 1
   This program is free software; you can redistribute it and/or modify
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
d13 4
a16 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.16
log
@2005-10-28  Dave Brolley  <brolley@@redhat.com>

        * All CGEN-generated sources: Regenerate.

        Contribute the following changes:
        2005-09-19  Dave Brolley  <brolley@@redhat.com>

        * disassemble.c (disassemble_init_for_target): Add 'break' to case for
        bfd_arch_tic4x. Use cgen_bitset_create and cgen_bitset_set for
        bfd_arch_m32c case.

        2005-02-16  Dave Brolley  <brolley@@redhat.com>

        * cgen-dis.in: Rename CGEN_ISA_MASK to CGEN_BITSET. Rename
        cgen_isa_mask_* to cgen_bitset_*.
        * cgen-opc.c: Likewise.

        2003-11-28  Richard Sandiford  <rsandifo@@redhat.com>

        * cgen-dis.in (print_insn_@@arch@@): Fix comparison with cached isas.
        * *-dis.c: Regenerate.

        2003-06-05  DJ Delorie  <dj@@redhat.com>

        * cgen-dis.in (print_insn_@@arch@@): Copy prev_isas, don't assign
        it, as it may point to a reused buffer. Set prev_isas when we
        change cpus.

        2002-12-13  Dave Brolley  <brolley@@redhat.com>

        * cgen-opc.c (cgen_isa_mask_create): New support function for
        CGEN_ISA_MASK.
        (cgen_isa_mask_init): Ditto.
        (cgen_isa_mask_clear): Ditto.
        (cgen_isa_mask_add): Ditto.
        (cgen_isa_mask_set): Ditto.
        (cgen_isa_supported): Ditto.
        (cgen_isa_mask_compare): Ditto.
        (cgen_isa_mask_intersection): Ditto.
        (cgen_isa_mask_copy): Ditto.
        (cgen_isa_mask_combine): Ditto.
        * cgen-dis.in (libiberty.h): #include it.
        (isas): Renamed from 'isa' and now (CGEN_ISA_MASK *).
        (print_insn_@@arch@@): Use CGEN_ISA_MASK and support functions.
        * Makefile.am (CGENDEPS): Add utils-cgen.scm and attrs.scm.
        * Makefile.in: Regenerated.
@
text
@a615 148
/* Functions for manipulating CGEN_BITSET.  */

/* Create a bit mask.  */
CGEN_BITSET *
cgen_bitset_create (unsigned bit_count)
{
  CGEN_BITSET * mask = xmalloc (sizeof (* mask));
  cgen_bitset_init (mask, bit_count);
  return mask;
}

/* Initialize an existing bit mask.  */

void
cgen_bitset_init (CGEN_BITSET * mask, unsigned bit_count)
{
  if (! mask)
    return;
  mask->length = (bit_count / 8) + 1;
  mask->bits = xmalloc (mask->length);
  cgen_bitset_clear (mask);
}

/* Clear the bits of a bit mask.  */

void
cgen_bitset_clear (CGEN_BITSET * mask)
{
  unsigned i;

  if (! mask)
    return;

  for (i = 0; i < mask->length; ++i)
    mask->bits[i] = 0;
}

/* Add a bit to a bit mask.  */

void
cgen_bitset_add (CGEN_BITSET * mask, unsigned bit_num)
{
  int byte_ix, bit_ix;
  int bit_mask;

  if (! mask)
    return;
  byte_ix = bit_num / 8;
  bit_ix = bit_num % 8;
  bit_mask = 1 << (7 - bit_ix);
  mask->bits[byte_ix] |= bit_mask;
}

/* Set a bit mask.  */

void
cgen_bitset_set (CGEN_BITSET * mask, unsigned bit_num)
{
  if (! mask)
    return;
  cgen_bitset_clear (mask);
  cgen_bitset_add (mask, bit_num);
}

/* Test for a bit in a bit mask.
   Returns 1 if the bit is found  */

int
cgen_bitset_contains (CGEN_BITSET * mask, unsigned bit_num)
{
  int byte_ix, bit_ix;
  int bit_mask;

  if (! mask)
    return 1; /* No bit restrictions.  */

  byte_ix = bit_num / 8;
  bit_ix = 7 - (bit_num % 8);
  bit_mask = 1 << bit_ix;
  return (mask->bits[byte_ix] & bit_mask) >> bit_ix;
}

/* Compare two bit masks for equality.
   Returns 0 if they are equal.  */

int
cgen_bitset_compare (CGEN_BITSET * mask1, CGEN_BITSET * mask2)
{
  if (mask1 == mask2)
    return 0;
  if (! mask1 || ! mask2)
    return 1;
  if (mask1->length != mask2->length)
    return 1;
  return memcmp (mask1->bits, mask2->bits, mask1->length);
}

/* Test two bit masks for common bits.
   Returns 1 if a common bit is found.  */

int
cgen_bitset_intersect_p (CGEN_BITSET * mask1, CGEN_BITSET * mask2)
{
  unsigned i, limit;

  if (mask1 == mask2)
    return 1;
  if (! mask1 || ! mask2)
    return 0;
  limit = mask1->length < mask2->length ? mask1->length : mask2->length;

  for (i = 0; i < limit; ++i)
    if ((mask1->bits[i] & mask2->bits[i]))
      return 1;

  return 0;
}

/* Make a copy of a bit mask.  */

CGEN_BITSET *
cgen_bitset_copy (CGEN_BITSET * mask)
{
  CGEN_BITSET* newmask;

  if (! mask)
    return NULL;
  newmask = cgen_bitset_create ((mask->length * 8) - 1);
  memcpy (newmask->bits, mask->bits, mask->length);
  return newmask;
}

/* Combine two bit masks.  */

void
cgen_bitset_union (CGEN_BITSET * mask1, CGEN_BITSET * mask2,
		   CGEN_BITSET * result)
{
  unsigned i;

  if (! mask1 || ! mask2 || ! result
      || mask1->length != mask2->length
      || mask1->length != result->length)
    return;

  for (i = 0; i < result->length; ++i)
    result->bits[i] = mask1->bits[i] | mask2->bits[i];
}
@


1.15
log
@Update function declarations to ISO C90 formatting
@
text
@d616 148
@


1.14
log
@Update the address and phone number of the FSF
@
text
@d160 1
a160 1
  /* FIXME: Need to specify format of PARAMS.  */
@


1.13
log
@	* arc-ext.c: Warning fixes.
	* arc-ext.h: Likewise.
	* cgen-opc.c: Likewise.
	* ia64-gen.c: Likewise.
	* maxq-dis.c: Likewise.
	* ns32k-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* ia64-asmtab.c: Regenerate.
@
text
@d20 1
a20 1
   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.12
log
@Convert cgen to C-90
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d486 1
a486 1
      insn_list = cgen_dis_lookup_insn (cd, buf, base_insn);
@


1.11
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d36 1
a36 1
  PARAMS ((const CGEN_KEYWORD *, const char *, int));
d38 1
a38 1
  PARAMS ((const CGEN_KEYWORD *, unsigned int));
d40 1
a40 1
  PARAMS ((CGEN_KEYWORD *));
d49 1
a49 3
cgen_keyword_lookup_name (kt, name)
     CGEN_KEYWORD *kt;
     const char *name;
d88 1
a88 3
cgen_keyword_lookup_value (kt, value)
     CGEN_KEYWORD *kt;
     int value;
d110 1
a110 3
cgen_keyword_add (kt, ke)
     CGEN_KEYWORD *kt;
     CGEN_KEYWORD_ENTRY *ke;
d156 1
a156 3
cgen_keyword_search_init (kt, spec)
     CGEN_KEYWORD *kt;
     const char *spec;
d178 1
a178 2
cgen_keyword_search_next (search)
     CGEN_KEYWORD_SEARCH *search;
d212 3
a214 4
hash_keyword_name (kt, name, case_sensitive_p)
     const CGEN_KEYWORD *kt;
     const char *name;
     int case_sensitive_p;
d230 1
a230 3
hash_keyword_value (kt, value)
     const CGEN_KEYWORD *kt;
     unsigned int value;
d240 1
a240 2
build_keyword_hash_tables (kt)
     CGEN_KEYWORD *kt;
d268 1
a268 3
cgen_hw_lookup_by_name (cd, name)
     CGEN_CPU_DESC cd;
     const char *name;
d286 1
a286 3
cgen_hw_lookup_by_num (cd, hwnum)
     CGEN_CPU_DESC cd;
     unsigned int hwnum;
d306 1
a306 3
cgen_operand_lookup_by_name (cd, name)
     CGEN_CPU_DESC cd;
     const char *name;
d325 1
a325 3
cgen_operand_lookup_by_num (cd, opnum)
     CGEN_CPU_DESC cd;
     int opnum;
d335 1
a335 2
cgen_insn_count (cd)
     CGEN_CPU_DESC cd;
d350 1
a350 2
cgen_macro_insn_count (cd)
     CGEN_CPU_DESC cd;
d364 1
a364 4
cgen_get_insn_value (cd, buf, length)
     CGEN_CPU_DESC cd;
     unsigned char *buf;
     int length;
d400 4
a403 5
cgen_put_insn_value (cd, buf, length, value)
     CGEN_CPU_DESC cd;
     unsigned char *buf;
     int length;
     CGEN_INSN_INT value;
d448 8
a455 10
cgen_lookup_insn (cd, insn, insn_int_value, insn_bytes_value, length, fields,
		  alias_p)
     CGEN_CPU_DESC cd;
     const CGEN_INSN *insn;
     CGEN_INSN_INT insn_int_value;
     /* ??? CGEN_INSN_BYTES would be a nice type name to use here.  */
     unsigned char *insn_bytes_value;
     int length;
     CGEN_FIELDS *fields;
     int alias_p;
d545 4
a548 5
cgen_get_insn_operands (cd, insn, fields, indices)
     CGEN_CPU_DESC cd;
     const CGEN_INSN *insn;
     const CGEN_FIELDS *fields;
     int *indices;
d576 8
a583 10
cgen_lookup_get_insn_operands (cd, insn, insn_int_value, insn_bytes_value,
			       length, indices, fields)
     CGEN_CPU_DESC cd;
     const CGEN_INSN *insn;
     CGEN_INSN_INT insn_int_value;
     /* ??? CGEN_INSN_BYTES would be a nice type name to use here.  */
     unsigned char *insn_bytes_value;
     int length;
     int *indices;
     CGEN_FIELDS *fields;
d598 1
a598 2
cgen_set_signed_overflow_ok (cd)
     CGEN_CPU_DESC cd;
d605 1
a605 2
cgen_clear_signed_overflow_ok (cd)
     CGEN_CPU_DESC cd;
d612 1
a612 2
cgen_signed_overflow_ok_p (cd)
     CGEN_CPU_DESC cd;
@


1.11.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d36 1
a36 1
  (const CGEN_KEYWORD *, const char *, int);
d38 1
a38 1
  (const CGEN_KEYWORD *, unsigned int);
d40 1
a40 1
  (CGEN_KEYWORD *);
d49 3
a51 1
cgen_keyword_lookup_name (CGEN_KEYWORD *kt, const char *name)
d90 3
a92 1
cgen_keyword_lookup_value (CGEN_KEYWORD *kt, int value)
d114 3
a116 1
cgen_keyword_add (CGEN_KEYWORD *kt, CGEN_KEYWORD_ENTRY *ke)
d162 3
a164 1
cgen_keyword_search_init (CGEN_KEYWORD *kt, const char *spec)
d186 2
a187 1
cgen_keyword_search_next (CGEN_KEYWORD_SEARCH *search)
d221 4
a224 3
hash_keyword_name (const CGEN_KEYWORD *kt,
		   const char *name,
		   int case_sensitive_p)
d240 3
a242 1
hash_keyword_value (const CGEN_KEYWORD *kt, unsigned int value)
d252 2
a253 1
build_keyword_hash_tables (CGEN_KEYWORD *kt)
d281 3
a283 1
cgen_hw_lookup_by_name (CGEN_CPU_DESC cd, const char *name)
d301 3
a303 1
cgen_hw_lookup_by_num (CGEN_CPU_DESC cd, unsigned int hwnum)
d323 3
a325 1
cgen_operand_lookup_by_name (CGEN_CPU_DESC cd, const char *name)
d344 3
a346 1
cgen_operand_lookup_by_num (CGEN_CPU_DESC cd, int opnum)
d356 2
a357 1
cgen_insn_count (CGEN_CPU_DESC cd)
d372 2
a373 1
cgen_macro_insn_count (CGEN_CPU_DESC cd)
d387 4
a390 1
cgen_get_insn_value (CGEN_CPU_DESC cd, unsigned char *buf, int length)
d426 5
a430 4
cgen_put_insn_value (CGEN_CPU_DESC cd,
		     unsigned char *buf,
		     int length,
		     CGEN_INSN_INT value)
d475 10
a484 8
cgen_lookup_insn (CGEN_CPU_DESC cd,
		  const CGEN_INSN *insn,
		  CGEN_INSN_INT insn_int_value,
		  /* ??? CGEN_INSN_BYTES would be a nice type name to use here.  */
		  unsigned char *insn_bytes_value,
		  int length,
		  CGEN_FIELDS *fields,
		  int alias_p)
d574 5
a578 4
cgen_get_insn_operands (CGEN_CPU_DESC cd,
			const CGEN_INSN *insn,
			const CGEN_FIELDS *fields,
			int *indices)
d606 10
a615 8
cgen_lookup_get_insn_operands (CGEN_CPU_DESC cd,
			       const CGEN_INSN *insn,
			       CGEN_INSN_INT insn_int_value,
			       /* ??? CGEN_INSN_BYTES would be a nice type name to use here.  */
			       unsigned char *insn_bytes_value,
			       int length,
			       int *indices,
			       CGEN_FIELDS *fields)
d630 2
a631 1
cgen_set_signed_overflow_ok (CGEN_CPU_DESC cd)
d638 2
a639 1
cgen_clear_signed_overflow_ok (CGEN_CPU_DESC cd)
d646 2
a647 1
cgen_signed_overflow_ok_p (CGEN_CPU_DESC cd)
@


1.11.22.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d36 1
a36 1
  (const CGEN_KEYWORD *, const char *, int);
d38 1
a38 1
  (const CGEN_KEYWORD *, unsigned int);
d40 1
a40 1
  (CGEN_KEYWORD *);
d49 3
a51 1
cgen_keyword_lookup_name (CGEN_KEYWORD *kt, const char *name)
d90 3
a92 1
cgen_keyword_lookup_value (CGEN_KEYWORD *kt, int value)
d114 3
a116 1
cgen_keyword_add (CGEN_KEYWORD *kt, CGEN_KEYWORD_ENTRY *ke)
d162 3
a164 1
cgen_keyword_search_init (CGEN_KEYWORD *kt, const char *spec)
d186 2
a187 1
cgen_keyword_search_next (CGEN_KEYWORD_SEARCH *search)
d221 4
a224 3
hash_keyword_name (const CGEN_KEYWORD *kt,
		   const char *name,
		   int case_sensitive_p)
d240 3
a242 1
hash_keyword_value (const CGEN_KEYWORD *kt, unsigned int value)
d252 2
a253 1
build_keyword_hash_tables (CGEN_KEYWORD *kt)
d281 3
a283 1
cgen_hw_lookup_by_name (CGEN_CPU_DESC cd, const char *name)
d301 3
a303 1
cgen_hw_lookup_by_num (CGEN_CPU_DESC cd, unsigned int hwnum)
d323 3
a325 1
cgen_operand_lookup_by_name (CGEN_CPU_DESC cd, const char *name)
d344 3
a346 1
cgen_operand_lookup_by_num (CGEN_CPU_DESC cd, int opnum)
d356 2
a357 1
cgen_insn_count (CGEN_CPU_DESC cd)
d372 2
a373 1
cgen_macro_insn_count (CGEN_CPU_DESC cd)
d387 4
a390 1
cgen_get_insn_value (CGEN_CPU_DESC cd, unsigned char *buf, int length)
d426 5
a430 4
cgen_put_insn_value (CGEN_CPU_DESC cd,
		     unsigned char *buf,
		     int length,
		     CGEN_INSN_INT value)
d475 10
a484 8
cgen_lookup_insn (CGEN_CPU_DESC cd,
		  const CGEN_INSN *insn,
		  CGEN_INSN_INT insn_int_value,
		  /* ??? CGEN_INSN_BYTES would be a nice type name to use here.  */
		  unsigned char *insn_bytes_value,
		  int length,
		  CGEN_FIELDS *fields,
		  int alias_p)
d574 5
a578 4
cgen_get_insn_operands (CGEN_CPU_DESC cd,
			const CGEN_INSN *insn,
			const CGEN_FIELDS *fields,
			int *indices)
d606 10
a615 8
cgen_lookup_get_insn_operands (CGEN_CPU_DESC cd,
			       const CGEN_INSN *insn,
			       CGEN_INSN_INT insn_int_value,
			       /* ??? CGEN_INSN_BYTES would be a nice type name to use here.  */
			       unsigned char *insn_bytes_value,
			       int length,
			       int *indices,
			       CGEN_FIELDS *fields)
d630 2
a631 1
cgen_set_signed_overflow_ok (CGEN_CPU_DESC cd)
d638 2
a639 1
cgen_clear_signed_overflow_ok (CGEN_CPU_DESC cd)
d646 2
a647 1
cgen_signed_overflow_ok_p (CGEN_CPU_DESC cd)
@


1.10
log
@* some support for funny-endian 16/32-bit insn sets

[cgen/ChangeLog]
2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

        * desc-cpu.scm (-gen-mach-table-defns): Emit fourth field: the
        mach->cpu insn-chunk-bitsize.
        (-gen-cpu-open): In @@arch@@_cgen_rebuild_tables, process above new
        field toward CGEN_CPU_TABLE->insn_chunk_bitsize.
        * mach.scm (<cpu>): New field insn-chunk-bitsize.
        (-cpu-parse, -cpu-read): Parse/initialize it.
        * doc/rtl.texi (define-cpu): Document it.

[opcodes/ChangeLog]
2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

        * cgen-dis.in (print_insn): Use cgen_get_insn_value instead of
        bfd_get_bits.
        * cgen-opc.c (cgen_get_insn_value, cgen_put_insn_value): Respect
        non-zero CGEN_CPU_DESC->insn_chunk_bitsize.

[include/opcode/ChangeLog]
2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

        * cgen.h (CGEN_MACH): Add insn_chunk_bitsize field.
        (cgen_cpu_desc): Ditto.
@
text
@a22 1
#include <ctype.h>
d26 1
d72 1
a72 3
		 || (isalpha ((unsigned char) *p)
		     && (tolower ((unsigned char) *p)
			 == tolower ((unsigned char) *n)))))
d136 1
a136 1
    if (! isalnum ((unsigned char) ke->name[i])
d233 1
a233 1
      hash = (hash * 97) + (unsigned char) tolower (*name);
@


1.9
log
@	* cgen-asm.c (cgen_parse_keyword): Allow any first character.
	* cgen-opc.c (cgen_keyword_add): Ignore special first
	character when building nonalpha_chars field.
@
text
@d394 29
a422 1
  return bfd_get_bits (buf, length, cd->insn_endian == CGEN_ENDIAN_BIG);
d434 25
a458 2
  bfd_put_bits ((bfd_vma) value, buf, length,
		cd->insn_endian == CGEN_ENDIAN_BIG);
@


1.8
log
@Index: opcodes/ChangeLog
2001-06-13  Geoffrey Keating  <geoffk@@redhat.com>

	* cgen-asm.c (cgen_parse_keyword): When looking for the
	boundaries of a keyword, allow any special characters
	that are actually in one of the allowed keyword.
	* cgen-opc.c (cgen_keyword_add): Add any special characters
	to the nonalpha_chars field.

Index: cgen/ChangeLog
2001-06-13  Geoffrey Keating  <geoffk@@redhat.com>

	* desc.scm (<keyword> 'gen-defn): Add extra zero into
	CGEN_KEYWORD_ENTRY initializers.

Index: include/opcode/ChangeLog
2001-06-13  Geoffrey Keating  <geoffk@@redhat.com>

	* cgen.h (cgen_keyword): Add nonalpha_chars field.
@
text
@d137 1
a137 1
  for (i = 0; i < strlen (ke->name); i++)
@


1.7
log
@Fix typos in ChangeLogs; fix dates in copyright notices
@
text
@d121 1
d136 15
@


1.6
log
@	* cgen-opc.c (cgen_get_insn_value): Add missing `return'.
@
text
@d3 2
a4 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.5
log
@* generalization

2001-01-02  Richard Sandiford  <rsandifo@@redhat.com>

	* cgen-dis.c (hash_insn_array): Use bfd_put_bits().
	(hash_insn_list): Likewise
	* cgen-ibld.in (insert_1): Use bfd_put_bits() and bfd_get_bits().
	(extract_1): Use bfd_get_bits().
	(extract_normal): Apply sign extension to both extraction
	methods.
	* cgen-opc.c (cgen_get_insn_value): Use bfd_get_bits()
	(cgen_put_insn_value): Use bfd_put_bits()
@
text
@d3 1
a3 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d377 1
a377 1
  bfd_get_bits (buf, length, cd->insn_endian == CGEN_ENDIAN_BIG);
@


1.5.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.4
log
@Fix for compiling under Solaris 2.8
@
text
@d377 1
a377 24
  CGEN_INSN_INT value;

  switch (length)
    {
    case 8:
      value = *buf;
      break;
    case 16:
      if (cd->insn_endian == CGEN_ENDIAN_BIG)
	value = bfd_getb16 (buf);
      else
	value = bfd_getl16 (buf);
      break;
    case 32:
      if (cd->insn_endian == CGEN_ENDIAN_BIG)
	value = bfd_getb32 (buf);
      else
	value = bfd_getl32 (buf);
      break;
    default:
      abort ();
    }

  return value;
d389 2
a390 20
  switch (length)
    {
    case 8:
      buf[0] = value;
      break;
    case 16:
      if (cd->insn_endian == CGEN_ENDIAN_BIG)
	bfd_putb16 (value, buf);
      else
	bfd_putl16 (value, buf);
      break;
    case 32:
      if (cd->insn_endian == CGEN_ENDIAN_BIG)
	bfd_putb32 (value, buf);
      else
	bfd_putl32 (value, buf);
      break;
    default:
      abort ();
    }
@


1.3
log
@2000-07-26  Dave Brolley  <brolley@@redhat.com>

	* cgen-opc.c (cgen_hw_lookup_by_name): 'i' is now unsigned.
	(cgen_hw_lookup_by_num): Ditto.
	(cgen_operand_lookup_by_name): Ditto.
	(print_address): Ditto.
	(print_keyword): Ditto.
	* cgen-dis.c (hash_insn_array): Mark unused parameters with
	ATTRIBUTE_UNUSED.
	* cgen-asm.c (hash_insn_array): Mark unused parameters with
	ATTRIBUTE_UNUSED.
	(cgen_parse_keyword): Ditto.
@
text
@d30 4
@


1.2
log
@Add functions to modify/examine the signed_overflow_ok_p field in cpu_desc.
@
text
@d266 1
a266 1
  int i;
d284 1
a284 1
     int hwnum;
d286 1
a286 1
  int i;
d308 1
a308 1
  int i;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d597 24
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

