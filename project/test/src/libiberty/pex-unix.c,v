head	1.21;
access;
symbols
	sid-snapshot-20180601:1.21
	sid-snapshot-20180501:1.21
	sid-snapshot-20180401:1.21
	sid-snapshot-20180301:1.21
	sid-snapshot-20180201:1.21
	sid-snapshot-20180101:1.21
	sid-snapshot-20171201:1.21
	sid-snapshot-20171101:1.21
	sid-snapshot-20171001:1.21
	sid-snapshot-20170901:1.21
	sid-snapshot-20170801:1.21
	sid-snapshot-20170701:1.21
	sid-snapshot-20170601:1.21
	sid-snapshot-20170501:1.21
	sid-snapshot-20170401:1.21
	sid-snapshot-20170301:1.21
	sid-snapshot-20170201:1.21
	sid-snapshot-20170101:1.21
	sid-snapshot-20161201:1.21
	sid-snapshot-20161101:1.21
	sid-snapshot-20160901:1.21
	sid-snapshot-20160801:1.21
	sid-snapshot-20160701:1.21
	sid-snapshot-20160601:1.21
	sid-snapshot-20160501:1.21
	sid-snapshot-20160401:1.21
	sid-snapshot-20160301:1.21
	sid-snapshot-20160201:1.21
	sid-snapshot-20160101:1.21
	sid-snapshot-20151201:1.21
	sid-snapshot-20151101:1.21
	sid-snapshot-20151001:1.21
	sid-snapshot-20150901:1.21
	sid-snapshot-20150801:1.21
	sid-snapshot-20150701:1.21
	sid-snapshot-20150601:1.21
	sid-snapshot-20150501:1.21
	sid-snapshot-20150401:1.21
	sid-snapshot-20150301:1.21
	sid-snapshot-20150201:1.21
	sid-snapshot-20150101:1.21
	sid-snapshot-20141201:1.21
	sid-snapshot-20141101:1.21
	sid-snapshot-20141001:1.21
	sid-snapshot-20140901:1.20
	sid-snapshot-20140801:1.20
	sid-snapshot-20140701:1.20
	sid-snapshot-20140601:1.20
	sid-snapshot-20140501:1.20
	sid-snapshot-20140401:1.20
	sid-snapshot-20140301:1.20
	sid-snapshot-20140201:1.20
	sid-snapshot-20140101:1.20
	sid-snapshot-20131201:1.20
	sid-snapshot-20131101:1.20
	sid-snapshot-20131001:1.20
	binutils-2_24-branch:1.20.0.8
	binutils-2_24-branchpoint:1.20
	binutils-2_21_1:1.18
	sid-snapshot-20130901:1.20
	gdb_7_6_1-2013-08-30-release:1.20
	sid-snapshot-20130801:1.20
	sid-snapshot-20130701:1.20
	sid-snapshot-20130601:1.20
	sid-snapshot-20130501:1.20
	gdb_7_6-2013-04-26-release:1.20
	sid-snapshot-20130401:1.20
	binutils-2_23_2:1.20
	gdb_7_6-branch:1.20.0.6
	gdb_7_6-2013-03-12-branchpoint:1.20
	sid-snapshot-20130301:1.20
	sid-snapshot-20130201:1.20
	sid-snapshot-20130101:1.20
	sid-snapshot-20121201:1.20
	gdb_7_5_1-2012-11-29-release:1.20
	binutils-2_23_1:1.20
	sid-snapshot-20121101:1.20
	binutils-2_23:1.20
	sid-snapshot-20121001:1.20
	sid-snapshot-20120901:1.20
	gdb_7_5-2012-08-17-release:1.20
	sid-snapshot-20120801:1.20
	binutils-2_23-branch:1.20.0.4
	binutils-2_23-branchpoint:1.20
	gdb_7_5-branch:1.20.0.2
	gdb_7_5-2012-07-18-branchpoint:1.20
	sid-snapshot-20120701:1.20
	sid-snapshot-20120601:1.20
	sid-snapshot-20120501:1.20
	binutils-2_22_branch:1.19.0.8
	gdb_7_4_1-2012-04-26-release:1.19
	sid-snapshot-20120401:1.19
	sid-snapshot-20120301:1.19
	sid-snapshot-20120201:1.19
	gdb_7_4-2012-01-24-release:1.19
	sid-snapshot-20120101:1.19
	gdb_7_4-branch:1.19.0.6
	gdb_7_4-2011-12-13-branchpoint:1.19
	sid-snapshot-20111201:1.19
	binutils-2_22:1.19
	sid-snapshot-20111101:1.19
	sid-snapshot-20111001:1.19
	binutils-2_22-branch:1.19.0.4
	binutils-2_22-branchpoint:1.19
	gdb_7_3_1-2011-09-04-release:1.19
	sid-snapshot-20110901:1.19
	sid-snapshot-20110801:1.19
	gdb_7_3-2011-07-26-release:1.19
	sid-snapshot-20110701:1.19
	sid-snapshot-20110601:1.19
	sid-snapshot-20110501:1.19
	gdb_7_3-branch:1.19.0.2
	gdb_7_3-2011-04-01-branchpoint:1.19
	sid-snapshot-20110401:1.19
	sid-snapshot-20110301:1.19
	cygwin-1_7_8-release:1.19
	sid-snapshot-20110201:1.19
	sid-snapshot-20110101:1.18
	binutils-2_21:1.18
	sid-snapshot-20101201:1.18
	binutils-2_21-branch:1.18.0.2
	binutils-2_21-branchpoint:1.18
	sid-snapshot-20101101:1.17
	sid-snapshot-20101001:1.17
	binutils-2_20_1:1.14
	gdb_7_2-2010-09-02-release:1.17
	sid-snapshot-20100901:1.17
	cygwin-1_7_7-release:1.17
	sid-snapshot-20100801:1.17
	gdb_7_2-branch:1.17.0.4
	gdb_7_2-2010-07-07-branchpoint:1.17
	sid-snapshot-20100701:1.17
	sid-snapshot-20100601:1.17
	sid-snapshot-20100501:1.17
	sid-snapshot-20100401:1.17
	gdb_7_1-2010-03-18-release:1.17
	sid-snapshot-20100301:1.17
	gdb_7_1-branch:1.17.0.2
	gdb_7_1-2010-02-18-branchpoint:1.17
	sid-snapshot-20100201:1.17
	sid-snapshot-20100101:1.17
	gdb_7_0_1-2009-12-22-release:1.14
	sid-snapshot-20091201:1.16
	sid-snapshot-20091101:1.14
	binutils-2_20:1.14
	gdb_7_0-2009-10-06-release:1.14
	sid-snapshot-20091001:1.14
	gdb_7_0-branch:1.14.0.4
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.13
	binutils-arc-20081103-branch:1.13.0.28
	binutils-arc-20081103-branchpoint:1.13
	binutils-2_20-branch:1.14.0.2
	binutils-2_20-branchpoint:1.14
	sid-snapshot-20090901:1.14
	sid-snapshot-20090801:1.14
	msnyder-checkpoint-072509-branch:1.13.0.26
	msnyder-checkpoint-072509-branchpoint:1.13
	sid-snapshot-20090701:1.13
	dje-cgen-play1-branch:1.13.0.24
	dje-cgen-play1-branchpoint:1.13
	sid-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	arc-20081103-branch:1.13.0.22
	arc-20081103-branchpoint:1.13
	arc-insight_6_8-branch:1.13.0.20
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.18
	insight_6_8-branchpoint:1.13
	sid-snapshot-20090301:1.13
	binutils-2_19_1:1.13
	sid-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	reverse-20081226-branch:1.13.0.16
	reverse-20081226-branchpoint:1.13
	sid-snapshot-20081201:1.13
	multiprocess-20081120-branch:1.13.0.14
	multiprocess-20081120-branchpoint:1.13
	sid-snapshot-20081101:1.13
	binutils-2_19:1.13
	sid-snapshot-20081001:1.13
	reverse-20080930-branch:1.13.0.12
	reverse-20080930-branchpoint:1.13
	binutils-2_19-branch:1.13.0.10
	binutils-2_19-branchpoint:1.13
	sid-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	reverse-20080717-branch:1.13.0.8
	reverse-20080717-branchpoint:1.13
	sid-snapshot-20080701:1.13
	msnyder-reverse-20080609-branch:1.13.0.6
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.12.0.4
	drow-reverse-20070409-branchpoint:1.12
	sid-snapshot-20080601:1.13
	sid-snapshot-20080501:1.13
	sid-snapshot-20080403:1.13
	sid-snapshot-20080401:1.13
	gdb_6_8-2008-03-27-release:1.13
	sid-snapshot-20080301:1.13
	gdb_6_8-branch:1.13.0.4
	gdb_6_8-2008-02-26-branchpoint:1.13
	sid-snapshot-20080201:1.13
	sid-snapshot-20080101:1.13
	sid-snapshot-20071201:1.13
	sid-snapshot-20071101:1.13
	gdb_6_7_1-2007-10-29-release:1.13
	gdb_6_7-2007-10-10-release:1.13
	sid-snapshot-20071001:1.13
	gdb_6_7-branch:1.13.0.2
	gdb_6_7-2007-09-07-branchpoint:1.13
	binutils-2_18:1.12
	binutils-2_18-branch:1.12.0.2
	binutils-2_18-branchpoint:1.12
	insight_6_6-20070208-release:1.11
	binutils-csl-coldfire-4_1-32:1.7.16.2
	binutils-csl-sourcerygxx-4_1-32:1.7.16.2
	gdb_6_6-2006-12-18-release:1.11
	binutils-csl-innovasic-fido-3_4_4-33:1.7.16.2
	binutils-csl-sourcerygxx-3_4_4-32:1.3
	binutils-csl-coldfire-4_1-30:1.7.16.2
	binutils-csl-sourcerygxx-4_1-30:1.7.16.2
	binutils-csl-coldfire-4_1-28:1.7.16.2
	binutils-csl-sourcerygxx-4_1-29:1.7.16.2
	binutils-csl-sourcerygxx-4_1-28:1.7.16.2
	gdb_6_6-branch:1.11.0.2
	gdb_6_6-2006-11-15-branchpoint:1.11
	binutils-csl-arm-2006q3-27:1.7.16.2
	binutils-csl-sourcerygxx-4_1-27:1.7.16.2
	binutils-csl-arm-2006q3-26:1.7.16.2
	binutils-csl-sourcerygxx-4_1-26:1.7.16.2
	binutils-csl-sourcerygxx-4_1-25:1.7.16.2
	binutils-csl-sourcerygxx-4_1-24:1.7.16.2
	binutils-csl-sourcerygxx-4_1-23:1.7.16.2
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.7.12.1
	binutils-csl-sourcerygxx-4_1-21:1.7.16.2
	binutils-csl-arm-2006q3-21:1.7.16.2
	binutils-csl-sourcerygxx-4_1-22:1.7.16.2
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.7.16.2
	binutils-csl-sourcerygxx-4_1-20:1.7.16.1
	binutils-csl-arm-2006q3-19:1.7.16.1
	binutils-csl-sourcerygxx-4_1-19:1.7.16.1
	binutils-csl-sourcerygxx-4_1-18:1.7.16.1
	binutils-csl-renesas-4_1-9:1.7.16.1
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	binutils-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.11
	gdb-csl-symbian-6_4_50_20060226-11:1.7.12.1
	binutils-csl-renesas-4_1-8:1.7.16.1
	binutils-csl-renesas-4_1-7:1.7.16.1
	binutils-csl-renesas-4_1-6:1.7.16.1
	gdb-csl-sourcerygxx-4_1-17:1.7.12.1
	binutils-csl-sourcerygxx-4_1-17:1.7.16.1
	gdb-csl-20060226-branch-local-2:1.7.12.1
	cr-0x5f1:1.10.0.2
	gdb-csl-sourcerygxx-4_1-14:1.7.12.1
	binutils-csl-sourcerygxx-4_1-14:1.7.16.1
	binutils-csl-sourcerygxx-4_1-15:1.7.16.1
	gdb-csl-sourcerygxx-4_1-13:1.7.12.1
	binutils-csl-sourcerygxx-4_1-13:1.7.16.1
	binutils-2_17:1.8
	gdb-csl-sourcerygxx-4_1-12:1.7.12.1
	binutils-csl-sourcerygxx-4_1-12:1.7.16.1
	gdb-csl-sourcerygxx-3_4_4-21:1.7.12.1
	binutils-csl-sourcerygxx-3_4_4-21:1.7.16.1
	gdb_6_5-20060621-release:1.8
	binutils-csl-wrs-linux-3_4_4-24:1.3
	binutils-csl-wrs-linux-3_4_4-23:1.3
	gdb-csl-sourcerygxx-4_1-9:1.7.12.1
	binutils-csl-sourcerygxx-4_1-9:1.7.16.1
	gdb-csl-sourcerygxx-4_1-8:1.7.12.1
	binutils-csl-sourcerygxx-4_1-8:1.7.16.1
	gdb-csl-sourcerygxx-4_1-7:1.7.12.1
	binutils-csl-sourcerygxx-4_1-7:1.7.16.1
	gdb-csl-arm-2006q1-6:1.7.12.1
	binutils-csl-arm-2006q1-6:1.7.16.1
	gdb-csl-sourcerygxx-4_1-6:1.7.12.1
	binutils-csl-sourcerygxx-4_1-6:1.7.16.1
	binutils-csl-wrs-linux-3_4_4-22:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.7.12.1
	gdb-csl-symbian-6_4_50_20060226-9:1.7.12.1
	gdb-csl-symbian-6_4_50_20060226-8:1.7.12.1
	gdb-csl-coldfire-4_1-11:1.7.12.1
	binutils-csl-coldfire-4_1-11:1.7.16.1
	gdb-csl-sourcerygxx-3_4_4-19:1.7.12.1
	binutils-csl-sourcerygxx-3_4_4-19:1.7.16.1
	gdb-csl-coldfire-4_1-10:1.7.12.1
	gdb_6_5-branch:1.8.0.10
	gdb_6_5-2006-05-14-branchpoint:1.8
	binutils-csl-coldfire-4_1-10:1.7.16.1
	gdb-csl-sourcerygxx-4_1-5:1.7.12.1
	binutils-csl-sourcerygxx-4_1-5:1.7.16.1
	nickrob-async-20060513-branch:1.8.0.8
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.7.12.1
	binutils-csl-sourcerygxx-4_1-4:1.7.16.1
	msnyder-reverse-20060502-branch:1.8.0.6
	msnyder-reverse-20060502-branchpoint:1.8
	binutils-csl-wrs-linux-3_4_4-21:1.3
	gdb-csl-morpho-4_1-4:1.7.12.1
	binutils-csl-morpho-4_1-4:1.7.16.1
	gdb-csl-sourcerygxx-3_4_4-17:1.7.12.1
	binutils-csl-sourcerygxx-3_4_4-17:1.7.16.1
	binutils-csl-wrs-linux-3_4_4-20:1.3
	readline_5_1-import-branch:1.8.0.4
	readline_5_1-import-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7.12.1
	binutils-2_17-branch:1.8.0.2
	binutils-2_17-branchpoint:1.8
	gdb-csl-symbian-20060226-branch:1.7.12.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.7.12.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7.12.1
	msnyder-reverse-20060331-branch:1.7.0.18
	msnyder-reverse-20060331-branchpoint:1.7
	binutils-csl-2_17-branch:1.7.0.16
	binutils-csl-2_17-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.14
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.12
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.10
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.6
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.4
	gdb-csl-arm-20051020-branchpoint:1.7
	binutils-csl-gxxpro-3_4-branch:1.3.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.3
	binutils-2_16_1:1.3
	msnyder-tracepoint-checkpoint-branch:1.7.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.3
	binutils-csl-arm-2005q1b:1.3
	binutils-2_16:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	binutils-csl-arm-2005q1a:1.3
	csl-arm-20050325-branch:1.3.0.6
	csl-arm-20050325-branchpoint:1.3
	binutils-csl-arm-2005q1-branch:1.3.0.4
	binutils-csl-arm-2005q1-branchpoint:1.3
	binutils-2_16-branch:1.3.0.2
	binutils-2_16-branchpoint:1.3
	csl-arm-2004-q3d:1.2
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.6
	gdb_6_3-20041019-branchpoint:1.2
	csl-arm-2004-q3:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.8
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.4
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.1
	binutils-2_15:1.1
	binutils-2_15-branchpoint:1.1
	csl-arm-2004-q1a:1.2
	csl-arm-2004-q1:1.2
	gdb_6_1-2004-04-05-release:1.1
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.2
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.1.0.56
	cagney_tramp-20040309-branchpoint:1.1
	gdb_6_1-branch:1.1.0.54
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1
	drow_intercu-20040221-branch:1.1.0.52
	drow_intercu-20040221-branchpoint:1.1
	binutils-2_15-branch:1.1.0.50
	cagney_bfdfile-20040213-branch:1.1.0.48
	cagney_bfdfile-20040213-branchpoint:1.1
	drow-cplus-merge-20040208:1.1
	carlton_dictionary-20040126-merge:1.1
	cagney_bigcore-20040122-branch:1.1.0.46
	cagney_bigcore-20040122-branchpoint:1.1
	drow-cplus-merge-20040113:1.1
	csl-arm-2003-q4:1.1
	drow-cplus-merge-20031224:1.1
	drow-cplus-merge-20031220:1.1
	carlton_dictionary-20031215-merge:1.1
	drow-cplus-branch:1.1.0.44
	drow-cplus-merge-20031214:1.1
	carlton-dictionary-20031111-merge:1.1
	gdb_6_0-2003-10-04-release:1.1
	kettenis_sparc-20030918-branch:1.1.0.42
	kettenis_sparc-20030918-branchpoint:1.1
	carlton_dictionary-20030917-merge:1.1
	ezannoni_pie-20030916-branchpoint:1.1
	ezannoni_pie-20030916-branch:1.1.0.40
	cagney_x86i386-20030821-branch:1.1.0.38
	cagney_x86i386-20030821-branchpoint:1.1
	carlton_dictionary-20030805-merge:1.1
	carlton_dictionary-20030627-merge:1.1
	gdb_6_0-branch:1.1.0.36
	gdb_6_0-2003-06-23-branchpoint:1.1
	jimb-ppc64-linux-20030613-branch:1.1.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.1
	binutils-2_14:1.1
	cagney_convert-20030606-branch:1.1.0.32
	cagney_convert-20030606-branchpoint:1.1
	cagney_writestrings-20030508-branch:1.1.0.30
	cagney_writestrings-20030508-branchpoint:1.1
	jimb-ppc64-linux-20030528-branch:1.1.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.1
	carlton_dictionary-20030523-merge:1.1
	cagney_fileio-20030521-branch:1.1.0.26
	cagney_fileio-20030521-branchpoint:1.1
	kettenis_i386newframe-20030517-mergepoint:1.1
	jimb-ppc64-linux-20030509-branch:1.1.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.1
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	binutils-2_14-branch:1.1.0.22
	binutils-2_14-branchpoint:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.20
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-20030416-merge:1.1
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.18
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.16
	cagney_framebase-20030330-mergepoint:1.1
	cagney_framebase-20030326-branch:1.1.0.14
	cagney_framebase-20030326-branchpoint:1.1
	cagney_lazyid-20030317-branch:1.1.0.12
	cagney_lazyid-20030317-branchpoint:1.1
	kettenis-i386newframe-20030316-mergepoint:1.1
	offbyone-20030313-branch:1.1.0.10
	offbyone-20030313-branchpoint:1.1
	kettenis-i386newframe-20030308-branch:1.1.0.8
	kettenis-i386newframe-20030308-branchpoint:1.1
	carlton_dictionary-20030305-merge:1.1
	cagney_offbyone-20030303-branch:1.1.0.6
	cagney_offbyone-20030303-branchpoint:1.1
	w32api-2_2:1.1
	mingw-runtime-2_4:1.1
	carlton_dictionary-branch:1.1.0.4
	carlton_dictionary-20030207-merge:1.1
	binutils_latest_snapshot:1.20
	interps-20030202-branch:1.1.0.2
	interps-20030202-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.09.28.17.46.12;	author dj;	state Exp;
branches;
next	1.20;

1.20
date	2012.04.10.17.07.35;	author dj;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.03.21.05.58;	author dj;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.04.23.41.21;	author rth;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.08.07.15.36;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.23.04.42.14;	author bje;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.19.21.17.04;	author bje;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.27.19.01.17;	author dj;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.24.16.08.40;	author dj;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.12.02.21.52;	author bje;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.28.00.56.12;	author dj;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.02.15.37.03;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.01.14.57.50;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.12.18.42.01;	author dj;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.24.21.01.32;	author dj;	state Exp;
branches
	1.7.12.1
	1.7.16.1;
next	1.6;

1.6
date	2005.05.10.15.33.33;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.29.02.15.22;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.28.05.07.08;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.30.03.01.37;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.18.04.07.41;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.24.21.31.35;	author dj;	state Exp;
branches
	1.1.4.1
	1.1.44.1
	1.1.52.1
	1.1.56.1;
next	;

1.7.12.1
date	2006.03.17.20.36.14;	author jimb;	state Exp;
branches;
next	;

1.7.16.1
date	2006.03.31.01.17.06;	author mmitchel;	state Exp;
branches;
next	1.7.16.2;

1.7.16.2
date	2006.09.28.20.41.10;	author shinwell;	state Exp;
branches;
next	;

1.1.4.1
date	2003.02.07.19.18.02;	author carlton;	state Exp;
branches;
next	;

1.1.44.1
date	2003.12.14.20.28.03;	author drow;	state Exp;
branches;
next	;

1.1.52.1
date	2004.03.27.17.38.09;	author drow;	state Exp;
branches;
next	;

1.1.56.1
date	2004.03.21.23.57.43;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.21
log
@merge from gcc
@
text
@/* Utilities to execute a program in a subprocess (possibly linked by pipes
   with other subprocesses), and wait for it.  Generic Unix version
   (also used for UWIN and VMS).
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2009,
   2010 Free Software Foundation, Inc.

This file is part of the libiberty library.
Libiberty is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

Libiberty is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libiberty; see the file COPYING.LIB.  If not,
write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */

#include "config.h"
#include "libiberty.h"
#include "pex-common.h"

#include <stdio.h>
#include <signal.h>
#include <errno.h>
#ifdef NEED_DECLARATION_ERRNO
extern int errno;
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <sys/types.h>

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#ifdef HAVE_GETRUSAGE
#include <sys/time.h>
#include <sys/resource.h>
#endif
#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif
#ifdef HAVE_PROCESS_H
#include <process.h>
#endif

#ifdef vfork /* Autoconf may define this to fork for us. */
# define VFORK_STRING "fork"
#else
# define VFORK_STRING "vfork"
#endif
#ifdef HAVE_VFORK_H
#include <vfork.h>
#endif
#if defined(VMS) && defined (__LONG_POINTERS)
#ifndef __CHAR_PTR32
typedef char * __char_ptr32
__attribute__ ((mode (SI)));
#endif

typedef __char_ptr32 *__char_ptr_char_ptr32
__attribute__ ((mode (SI)));

/* Return a 32 bit pointer to an array of 32 bit pointers 
   given a 64 bit pointer to an array of 64 bit pointers.  */

static __char_ptr_char_ptr32
to_ptr32 (char **ptr64)
{
  int argc;
  __char_ptr_char_ptr32 short_argv;

  /* Count number of arguments.  */
  for (argc = 0; ptr64[argc] != NULL; argc++)
    ;

  /* Reallocate argv with 32 bit pointers.  */
  short_argv = (__char_ptr_char_ptr32) decc$malloc
    (sizeof (__char_ptr32) * (argc + 1));

  for (argc = 0; ptr64[argc] != NULL; argc++)
    short_argv[argc] = (__char_ptr32) decc$strdup (ptr64[argc]);

  short_argv[argc] = (__char_ptr32) 0;
  return short_argv;

}
#else
#define to_ptr32(argv) argv
#endif

/* File mode to use for private and world-readable files.  */

#if defined (S_IRUSR) && defined (S_IWUSR) && defined (S_IRGRP) && defined (S_IWGRP) && defined (S_IROTH) && defined (S_IWOTH)
#define PUBLIC_MODE  \
    (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)
#else
#define PUBLIC_MODE 0666
#endif

/* Get the exit status of a particular process, and optionally get the
   time that it took.  This is simple if we have wait4, slightly
   harder if we have waitpid, and is a pain if we only have wait.  */

static pid_t pex_wait (struct pex_obj *, pid_t, int *, struct pex_time *);

#ifdef HAVE_WAIT4

static pid_t
pex_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, pid_t pid, int *status,
	  struct pex_time *time)
{
  pid_t ret;
  struct rusage r;

#ifdef HAVE_WAITPID
  if (time == NULL)
    return waitpid (pid, status, 0);
#endif

  ret = wait4 (pid, status, 0, &r);

  if (time != NULL)
    {
      time->user_seconds = r.ru_utime.tv_sec;
      time->user_microseconds= r.ru_utime.tv_usec;
      time->system_seconds = r.ru_stime.tv_sec;
      time->system_microseconds= r.ru_stime.tv_usec;
    }

  return ret;
}

#else /* ! defined (HAVE_WAIT4) */

#ifdef HAVE_WAITPID

#ifndef HAVE_GETRUSAGE

static pid_t
pex_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, pid_t pid, int *status,
	  struct pex_time *time)
{
  if (time != NULL)
    memset (time, 0, sizeof (struct pex_time));
  return waitpid (pid, status, 0);
}

#else /* defined (HAVE_GETRUSAGE) */

static pid_t
pex_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, pid_t pid, int *status,
	  struct pex_time *time)
{
  struct rusage r1, r2;
  pid_t ret;

  if (time == NULL)
    return waitpid (pid, status, 0);

  getrusage (RUSAGE_CHILDREN, &r1);

  ret = waitpid (pid, status, 0);
  if (ret < 0)
    return ret;

  getrusage (RUSAGE_CHILDREN, &r2);

  time->user_seconds = r2.ru_utime.tv_sec - r1.ru_utime.tv_sec;
  time->user_microseconds = r2.ru_utime.tv_usec - r1.ru_utime.tv_usec;
  if (r2.ru_utime.tv_usec < r1.ru_utime.tv_usec)
    {
      --time->user_seconds;
      time->user_microseconds += 1000000;
    }

  time->system_seconds = r2.ru_stime.tv_sec - r1.ru_stime.tv_sec;
  time->system_microseconds = r2.ru_stime.tv_usec - r1.ru_stime.tv_usec;
  if (r2.ru_stime.tv_usec < r1.ru_stime.tv_usec)
    {
      --time->system_seconds;
      time->system_microseconds += 1000000;
    }

  return ret;
}

#endif /* defined (HAVE_GETRUSAGE) */

#else /* ! defined (HAVE_WAITPID) */

struct status_list
{
  struct status_list *next;
  pid_t pid;
  int status;
  struct pex_time time;
};

static pid_t
pex_wait (struct pex_obj *obj, pid_t pid, int *status, struct pex_time *time)
{
  struct status_list **pp;

  for (pp = (struct status_list **) &obj->sysdep;
       *pp != NULL;
       pp = &(*pp)->next)
    {
      if ((*pp)->pid == pid)
	{
	  struct status_list *p;

	  p = *pp;
	  *status = p->status;
	  if (time != NULL)
	    *time = p->time;
	  *pp = p->next;
	  free (p);
	  return pid;
	}
    }

  while (1)
    {
      pid_t cpid;
      struct status_list *psl;
      struct pex_time pt;
#ifdef HAVE_GETRUSAGE
      struct rusage r1, r2;
#endif

      if (time != NULL)
	{
#ifdef HAVE_GETRUSAGE
	  getrusage (RUSAGE_CHILDREN, &r1);
#else
	  memset (&pt, 0, sizeof (struct pex_time));
#endif
	}

      cpid = wait (status);

#ifdef HAVE_GETRUSAGE
      if (time != NULL && cpid >= 0)
	{
	  getrusage (RUSAGE_CHILDREN, &r2);

	  pt.user_seconds = r2.ru_utime.tv_sec - r1.ru_utime.tv_sec;
	  pt.user_microseconds = r2.ru_utime.tv_usec - r1.ru_utime.tv_usec;
	  if (pt.user_microseconds < 0)
	    {
	      --pt.user_seconds;
	      pt.user_microseconds += 1000000;
	    }

	  pt.system_seconds = r2.ru_stime.tv_sec - r1.ru_stime.tv_sec;
	  pt.system_microseconds = r2.ru_stime.tv_usec - r1.ru_stime.tv_usec;
	  if (pt.system_microseconds < 0)
	    {
	      --pt.system_seconds;
	      pt.system_microseconds += 1000000;
	    }
	}
#endif

      if (cpid < 0 || cpid == pid)
	{
	  if (time != NULL)
	    *time = pt;
	  return cpid;
	}

      psl = XNEW (struct status_list);
      psl->pid = cpid;
      psl->status = *status;
      if (time != NULL)
	psl->time = pt;
      psl->next = (struct status_list *) obj->sysdep;
      obj->sysdep = (void *) psl;
    }
}

#endif /* ! defined (HAVE_WAITPID) */
#endif /* ! defined (HAVE_WAIT4) */

static void pex_child_error (struct pex_obj *, const char *, const char *, int)
     ATTRIBUTE_NORETURN;
static int pex_unix_open_read (struct pex_obj *, const char *, int);
static int pex_unix_open_write (struct pex_obj *, const char *, int, int);
static pid_t pex_unix_exec_child (struct pex_obj *, int, const char *,
				 char * const *, char * const *,
				 int, int, int, int,
				 const char **, int *);
static int pex_unix_close (struct pex_obj *, int);
static int pex_unix_wait (struct pex_obj *, pid_t, int *, struct pex_time *,
			  int, const char **, int *);
static int pex_unix_pipe (struct pex_obj *, int *, int);
static FILE *pex_unix_fdopenr (struct pex_obj *, int, int);
static FILE *pex_unix_fdopenw (struct pex_obj *, int, int);
static void pex_unix_cleanup (struct pex_obj *);

/* The list of functions we pass to the common routines.  */

const struct pex_funcs funcs =
{
  pex_unix_open_read,
  pex_unix_open_write,
  pex_unix_exec_child,
  pex_unix_close,
  pex_unix_wait,
  pex_unix_pipe,
  pex_unix_fdopenr,
  pex_unix_fdopenw,
  pex_unix_cleanup
};

/* Return a newly initialized pex_obj structure.  */

struct pex_obj *
pex_init (int flags, const char *pname, const char *tempbase)
{
  return pex_init_common (flags, pname, tempbase, &funcs);
}

/* Open a file for reading.  */

static int
pex_unix_open_read (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
		    int binary ATTRIBUTE_UNUSED)
{
  return open (name, O_RDONLY);
}

/* Open a file for writing.  */

static int
pex_unix_open_write (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
		     int binary ATTRIBUTE_UNUSED, int append)
{
  /* Note that we can't use O_EXCL here because gcc may have already
     created the temporary file via make_temp_file.  */
  return open (name, O_WRONLY | O_CREAT
		     | (append ? O_APPEND : O_TRUNC), PUBLIC_MODE);
}

/* Close a file.  */

static int
pex_unix_close (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd)
{
  return close (fd);
}

/* Report an error from a child process.  We don't use stdio routines,
   because we might be here due to a vfork call.  */

static void
pex_child_error (struct pex_obj *obj, const char *executable,
		 const char *errmsg, int err)
{
  int retval = 0;
#define writeerr(s) retval |= (write (STDERR_FILE_NO, s, strlen (s)) < 0)
  writeerr (obj->pname);
  writeerr (": error trying to exec '");
  writeerr (executable);
  writeerr ("': ");
  writeerr (errmsg);
  writeerr (": ");
  writeerr (xstrerror (err));
  writeerr ("\n");
#undef writeerr
  /* Exit with -2 if the error output failed, too.  */
  _exit (retval == 0 ? -1 : -2);
}

/* Execute a child.  */

extern char **environ;

#if defined(HAVE_SPAWNVE) && defined(HAVE_SPAWNVPE)
/* Implementation of pex->exec_child using the Cygwin spawn operation.  */

/* Subroutine of pex_unix_exec_child.  Move OLD_FD to a new file descriptor
   to be stored in *PNEW_FD, save the flags in *PFLAGS, and arrange for the
   saved copy to be close-on-exec.  Move CHILD_FD into OLD_FD.  If CHILD_FD
   is -1, OLD_FD is to be closed.  Return -1 on error.  */

static int
save_and_install_fd(int *pnew_fd, int *pflags, int old_fd, int child_fd)
{
  int new_fd, flags;

  flags = fcntl (old_fd, F_GETFD);

  /* If we could not retrieve the flags, then OLD_FD was not open.  */
  if (flags < 0)
    {
      new_fd = -1, flags = 0;
      if (child_fd >= 0 && dup2 (child_fd, old_fd) < 0)
	return -1;
    }
  /* If we wish to close OLD_FD, just mark it CLOEXEC.  */
  else if (child_fd == -1)
    {
      new_fd = old_fd;
      if ((flags & FD_CLOEXEC) == 0 && fcntl (old_fd, F_SETFD, FD_CLOEXEC) < 0)
	return -1;
    }
  /* Otherwise we need to save a copy of OLD_FD before installing CHILD_FD.  */
  else
    {
#ifdef F_DUPFD_CLOEXEC
      new_fd = fcntl (old_fd, F_DUPFD_CLOEXEC, 3);
      if (new_fd < 0)
	return -1;
#else
      /* Prefer F_DUPFD over dup in order to avoid getting a new fd
	 in the range 0-2, right where a new stderr fd might get put.  */
      new_fd = fcntl (old_fd, F_DUPFD, 3);
      if (new_fd < 0)
	return -1;
      if (fcntl (new_fd, F_SETFD, FD_CLOEXEC) < 0)
	return -1;
#endif
      if (dup2 (child_fd, old_fd) < 0)
	return -1;
    }

  *pflags = flags;
  if (pnew_fd)
    *pnew_fd = new_fd;
  else if (new_fd != old_fd)
    abort ();

  return 0;
}

/* Subroutine of pex_unix_exec_child.  Move SAVE_FD back to OLD_FD
   restoring FLAGS.  If SAVE_FD < 0, OLD_FD is to be closed.  */

static int
restore_fd(int old_fd, int save_fd, int flags)
{
  /* For SAVE_FD < 0, all we have to do is restore the
     "closed-ness" of the original.  */
  if (save_fd < 0)
    return close (old_fd);

  /* For SAVE_FD == OLD_FD, all we have to do is restore the
     original setting of the CLOEXEC flag.  */
  if (save_fd == old_fd)
    {
      if (flags & FD_CLOEXEC)
	return 0;
      return fcntl (old_fd, F_SETFD, flags);
    }

  /* Otherwise we have to move the descriptor back, restore the flags,
     and close the saved copy.  */
#ifdef HAVE_DUP3
  if (flags == FD_CLOEXEC)
    {
      if (dup3 (save_fd, old_fd, O_CLOEXEC) < 0)
	return -1;
    }
  else
#endif
    {
      if (dup2 (save_fd, old_fd) < 0)
	return -1;
      if (flags != 0 && fcntl (old_fd, F_SETFD, flags) < 0)
	return -1;
    }
  return close (save_fd);
}

static pid_t
pex_unix_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED,
		     int flags, const char *executable,
		     char * const * argv, char * const * env,
                     int in, int out, int errdes, int toclose,
		     const char **errmsg, int *err)
{
  int fl_in = 0, fl_out = 0, fl_err = 0, fl_tc = 0;
  int save_in = -1, save_out = -1, save_err = -1;
  int max, retries;
  pid_t pid;

  if (flags & PEX_STDERR_TO_STDOUT)
    errdes = out;

  /* We need the three standard file descriptors to be set up as for
     the child before we perform the spawn.  The file descriptors for
     the parent need to be moved and marked for close-on-exec.  */
  if (in != STDIN_FILE_NO
      && save_and_install_fd (&save_in, &fl_in, STDIN_FILE_NO, in) < 0)
    goto error_dup2;
  if (out != STDOUT_FILE_NO
      && save_and_install_fd (&save_out, &fl_out, STDOUT_FILE_NO, out) < 0)
    goto error_dup2;
  if (errdes != STDERR_FILE_NO
      && save_and_install_fd (&save_err, &fl_err, STDERR_FILE_NO, errdes) < 0)
    goto error_dup2;
  if (toclose >= 0
      && save_and_install_fd (NULL, &fl_tc, toclose, -1) < 0)
    goto error_dup2;

  /* Now that we've moved the file descriptors for the child into place,
     close the originals.  Be careful not to close any of the standard
     file descriptors that we just set up.  */
  max = -1;
  if (errdes >= 0)
    max = STDERR_FILE_NO;
  else if (out >= 0)
    max = STDOUT_FILE_NO;
  else if (in >= 0)
    max = STDIN_FILE_NO;
  if (in > max)
    close (in);
  if (out > max)
    close (out);
  if (errdes > max && errdes != out)
    close (errdes);

  /* If we were not given an environment, use the global environment.  */
  if (env == NULL)
    env = environ;

  /* Launch the program.  If we get EAGAIN (normally out of pid's), try
     again a few times with increasing backoff times.  */
  retries = 0;
  while (1)
    {
      typedef const char * const *cc_cp;

      if (flags & PEX_SEARCH)
	pid = spawnvpe (_P_NOWAITO, executable, (cc_cp)argv, (cc_cp)env);
      else
	pid = spawnve (_P_NOWAITO, executable, (cc_cp)argv, (cc_cp)env);

      if (pid > 0)
	break;

      *err = errno;
      *errmsg = "spawn";
      if (errno != EAGAIN || ++retries == 4)
	return (pid_t) -1;
      sleep (1 << retries);
    }

  /* Success.  Restore the parent's file descriptors that we saved above.  */
  if (toclose >= 0
      && restore_fd (toclose, toclose, fl_tc) < 0)
    goto error_dup2;
  if (in != STDIN_FILE_NO
      && restore_fd (STDIN_FILE_NO, save_in, fl_in) < 0)
    goto error_dup2;
  if (out != STDOUT_FILE_NO
      && restore_fd (STDOUT_FILE_NO, save_out, fl_out) < 0)
    goto error_dup2;
  if (errdes != STDERR_FILE_NO
      && restore_fd (STDERR_FILE_NO, save_err, fl_err) < 0)
    goto error_dup2;

  return pid;

 error_dup2:
  *err = errno;
  *errmsg = "dup2";
  return (pid_t) -1;
}

#else
/* Implementation of pex->exec_child using standard vfork + exec.  */

static pid_t
pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,
		     char * const * argv, char * const * env,
                     int in, int out, int errdes,
		     int toclose, const char **errmsg, int *err)
{
  pid_t pid;

  /* We declare these to be volatile to avoid warnings from gcc about
     them being clobbered by vfork.  */
  volatile int sleep_interval;
  volatile int retries;

  /* We vfork and then set environ in the child before calling execvp.
     This clobbers the parent's environ so we need to restore it.
     It would be nice to use one of the exec* functions that takes an
     environment as a parameter, but that may have portability issues.  */
  char **save_environ = environ;

  sleep_interval = 1;
  pid = -1;
  for (retries = 0; retries < 4; ++retries)
    {
      pid = vfork ();
      if (pid >= 0)
	break;
      sleep (sleep_interval);
      sleep_interval *= 2;
    }

  switch (pid)
    {
    case -1:
      *err = errno;
      *errmsg = VFORK_STRING;
      return (pid_t) -1;

    case 0:
      /* Child process.  */
      if (in != STDIN_FILE_NO)
	{
	  if (dup2 (in, STDIN_FILE_NO) < 0)
	    pex_child_error (obj, executable, "dup2", errno);
	  if (close (in) < 0)
	    pex_child_error (obj, executable, "close", errno);
	}
      if (out != STDOUT_FILE_NO)
	{
	  if (dup2 (out, STDOUT_FILE_NO) < 0)
	    pex_child_error (obj, executable, "dup2", errno);
	  if (close (out) < 0)
	    pex_child_error (obj, executable, "close", errno);
	}
      if (errdes != STDERR_FILE_NO)
	{
	  if (dup2 (errdes, STDERR_FILE_NO) < 0)
	    pex_child_error (obj, executable, "dup2", errno);
	  if (close (errdes) < 0)
	    pex_child_error (obj, executable, "close", errno);
	}
      if (toclose >= 0)
	{
	  if (close (toclose) < 0)
	    pex_child_error (obj, executable, "close", errno);
	}
      if ((flags & PEX_STDERR_TO_STDOUT) != 0)
	{
	  if (dup2 (STDOUT_FILE_NO, STDERR_FILE_NO) < 0)
	    pex_child_error (obj, executable, "dup2", errno);
	}

      if (env)
	{
	  /* NOTE: In a standard vfork implementation this clobbers the
	     parent's copy of environ "too" (in reality there's only one copy).
	     This is ok as we restore it below.  */
	  environ = (char**) env;
	}

      if ((flags & PEX_SEARCH) != 0)
	{
	  execvp (executable, to_ptr32 (argv));
	  pex_child_error (obj, executable, "execvp", errno);
	}
      else
	{
	  execv (executable, to_ptr32 (argv));
	  pex_child_error (obj, executable, "execv", errno);
	}

      /* NOTREACHED */
      return (pid_t) -1;

    default:
      /* Parent process.  */

      /* Restore environ.
	 Note that the parent either doesn't run until the child execs/exits
	 (standard vfork behaviour), or if it does run then vfork is behaving
	 more like fork.  In either case we needn't worry about clobbering
	 the child's copy of environ.  */
      environ = save_environ;

      if (in != STDIN_FILE_NO)
	{
	  if (close (in) < 0)
	    {
	      *err = errno;
	      *errmsg = "close";
	      return (pid_t) -1;
	    }
	}
      if (out != STDOUT_FILE_NO)
	{
	  if (close (out) < 0)
	    {
	      *err = errno;
	      *errmsg = "close";
	      return (pid_t) -1;
	    }
	}
      if (errdes != STDERR_FILE_NO)
	{
	  if (close (errdes) < 0)
	    {
	      *err = errno;
	      *errmsg = "close";
	      return (pid_t) -1;
	    }
	}

      return pid;
    }
}
#endif /* SPAWN */

/* Wait for a child process to complete.  */

static int
pex_unix_wait (struct pex_obj *obj, pid_t pid, int *status,
	       struct pex_time *time, int done, const char **errmsg,
	       int *err)
{
  /* If we are cleaning up when the caller didn't retrieve process
     status for some reason, encourage the process to go away.  */
  if (done)
    kill (pid, SIGTERM);

  if (pex_wait (obj, pid, status, time) < 0)
    {
      *err = errno;
      *errmsg = "wait";
      return -1;
    }

  return 0;
}

/* Create a pipe.  */

static int
pex_unix_pipe (struct pex_obj *obj ATTRIBUTE_UNUSED, int *p,
	       int binary ATTRIBUTE_UNUSED)
{
  return pipe (p);
}

/* Get a FILE pointer to read from a file descriptor.  */

static FILE *
pex_unix_fdopenr (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,
		  int binary ATTRIBUTE_UNUSED)
{
  return fdopen (fd, "r");
}

static FILE *
pex_unix_fdopenw (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,
		  int binary ATTRIBUTE_UNUSED)
{
  if (fcntl (fd, F_SETFD, FD_CLOEXEC) < 0)
    return NULL;
  return fdopen (fd, "w");
}

static void
pex_unix_cleanup (struct pex_obj *obj ATTRIBUTE_UNUSED)
{
#if !defined (HAVE_WAIT4) && !defined (HAVE_WAITPID)
  while (obj->sysdep != NULL)
    {
      struct status_list *this;
      struct status_list *next;

      this = (struct status_list *) obj->sysdep;
      next = this->next;
      free (this);
      obj->sysdep = (void *) next;
    }
#endif
}
@


1.20
log
@merge from gcc
@
text
@d304 1
a304 1
static int pex_unix_open_write (struct pex_obj *, const char *, int);
d353 1
a353 1
		     int binary ATTRIBUTE_UNUSED)
d357 2
a358 1
  return open (name, O_WRONLY | O_CREAT | O_TRUNC, PUBLIC_MODE);
@


1.19
log
@merge from gcc
@
text
@d88 3
a90 1
  for (argc=0; ptr64[argc]; argc++);
d96 1
a96 1
  for (argc=0; ptr64[argc]; argc++)
@


1.18
log
@Use spawnve on cygwin.

	* configure.ac (AC_CHECK_HEADERS): Add process.h.
	(checkfuncs): Add dup3, spawnve, spawnvpe; sort the list.
	(AC_CHECK_FUNCS): Add dup3, spawnve, spawnvpe.
	* configure, config.in: Rebuild.
	* pex-unix.c [HAVE_SPAWNVE] (pex_unix_exec_child): New function.
	[HAVE_SPAWNVE] (save_and_install_fd, restore_fd): New functions.
@
text
@d4 2
a5 2
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2009
   Free Software Foundation, Inc.
@


1.17
log
@	* pex-unix.c (pex_unix_exec_child): Save/restore environ.
@
text
@d58 3
a60 1

d392 196
d722 1
@


1.16
log
@	* pex-unix.c (pex_child_error): Improve warning avoidance by
	checking the results of write(3) and exiting with -2 if any write
	returns a negative value.
@
text
@d403 6
d462 6
a467 1
        environ = (char**) env;
d485 8
@


1.15
log
@	* pex-unix.c (pex_child_error): Define writeerr macro to avoid
	unused result warnings from write(3) calls.  Undefine writeerr
	after all uses.
@
text
@d371 2
a372 1
#define writeerr(s) if (write (STDERR_FILE_NO, s, strlen (s))) {}
d382 2
a383 1
  _exit (-1);
@


1.14
log
@merge from gcc
@
text
@d371 1
a371 1
#define writeerr(s) (void) write (STDERR_FILE_NO, s, strlen (s))
d380 1
@


1.13
log
@merge from gcc
@
text
@d4 1
a4 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005
d68 19
a86 4
#ifdef VMS
#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \
               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
#endif /* VMS */
d88 14
d457 1
a457 1
	  execvp (executable, argv);
d462 1
a462 1
	  execv (executable, argv);
@


1.12
log
@	* pex-unix.c (writeerr): Cast write result to void.
@
text
@d272 1
a272 1
static long pex_unix_exec_child (struct pex_obj *, int, const char *,
d277 1
a277 1
static int pex_unix_wait (struct pex_obj *, long, int *, struct pex_time *,
d358 1
a358 1
static long
d387 1
a387 1
      return -1;
d438 1
a438 1
      return -1;
d448 1
a448 1
	      return -1;
d457 1
a457 1
	      return -1;
d466 1
a466 1
	      return -1;
d470 1
a470 1
      return (long) pid;
d477 1
a477 1
pex_unix_wait (struct pex_obj *obj, long pid, int *status,
@


1.11
log
@merge from gcc
@
text
@d342 1
a342 1
#define writeerr(s) write (STDERR_FILE_NO, s, strlen (s))
@


1.10
log
@merge from gcc
@
text
@d274 2
a275 1
                                 int, int, int, const char **, int *);
d362 1
a362 1
		     const char **errmsg, int *err)
d412 5
@


1.9
log
@merge from gcc
@
text
@d418 1
a418 1
        environ = env;
@


1.8
log
@merge from gcc
@
text
@d273 2
a274 2
				 char * const *, int, int, int,
				 const char **, int *);
d355 2
d359 2
a360 1
		     char * const * argv, int in, int out, int errdes,
d364 1
d416 4
@


1.7
log
@merge from gcc
@
text
@d280 1
d294 1
d500 9
@


1.7.16.1
log
@	* libiberty/configure.ac: Add cygpath for mingw hosts.
	* libiberty.configure: Rebuilt.
	* libiberty/Makefile.in: Add cygpath.
	* libiberty/cygpath.c: New.

	* include/libiberty.h (pex_write_input): New declaration.

	* libiberty/pex-common.c (pex_write_input): New function.
	* libiberty/pexecute.txh (pex_write_input): Document it.
	* libiberty/pex-common.h (struct pex_funcs): New function ptr fdopenw.
	* libiberty/pex-unix.c (pex_unix_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* libiberty/pex-win32.c (pex_win32_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* libiberty/pex-djgpp.c (funcs): Leave fdopenw null.
	* libiberty/pex-msdos (funcs): Same.
	* libiberty/functions.texi: Regenerated.

	* libiberty/pex-common.h (struct pex_obj): Doc fixes.

	* libiberty/functions.texi: Regenerate.
@
text
@a279 1
static FILE *pex_unix_fdopenw (struct pex_obj *, int, int);
a292 1
  pex_unix_fdopenw,
a497 9
static FILE *
pex_unix_fdopenw (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,
		  int binary ATTRIBUTE_UNUSED)
{
  if (fcntl (fd, F_SETFD, FD_CLOEXEC) < 0)
    return NULL;
  return fdopen (fd, "w");
}

@


1.7.16.2
log
@	include/
	* libiberty.h: Declare pex_run_in_environment.

	libiberty/
	* pex-common.c: New function pex_run_in_environment.
	* pex-common.h: Add environment parameter to exec_child.
	* pex-msdos.c: Add environment parameter to pex_msdos_exec_child.
	* pex-djgpp.c: Add environment parameter to pex_djgpp_exec_child.
	(pex_djgpp_exec_child): Pass environment to child process.
	* pex-unix.c: Add environment parameter to pex_unix_exec_child.
	(pex_unix_exec_child): Pass environment to child process.
	* pex-win32.c: Add environment parameter to pex_win32_exec_child.
	New function env_compare for comparing VAR=VALUE pairs.
	(win32_spawn): Assemble environment block and pass to CreateProcess.
	(spawn_script): Pass environment through to win32_spawn.
	(pex_win32_exec_child): Pass environment through to spawn_script and
	win32_spawn.
	* functions.texi: Regenerate.
	* pexecute.txh: Document pex_run_in_environment.
@
text
@d273 2
a274 2
				 char * const *, char * const *,
                                 int, int, int, const char **, int *);
a354 2
extern char **environ;

d357 1
a357 2
		     char * const * argv, char * const * env,
                     int in, int out, int errdes,
a360 1

a411 4

      if (env)
        environ = env;

@


1.7.12.1
log
@gdb/ChangeLog:
2006-03-17  Jim Blandy  <jimb@@codesourcery.com>

	Add support for 'target remote |' on MinGW.
	* ser-mingw.c (struct pipe_state): New structure.
	(make_pipe_state, free_pipe_state, cleanup_pipe_state)
	(pipe_windows_open, pipe_windows_close, pipe_windows_read)
	(pipe_windows_write, pipe_wait_handle): New functions.
	(_initialize_ser_windows): Register a "pipe" interface based on
	them.

include/ChangeLog:
2006-03-15  Jim Blandy  <jimb@@codesourcery.com>

	* libiberty.h (pex_write_input): New declaration.

libiberty/ChangeLog:
2006-03-15  Jim Blandy  <jimb@@codesourcery.com>

	* pex-common.c (pex_write_input): New function.
	* pexecute.txh (pex_write_input): Document it.
	* pex-common.h (struct pex_funcs): New function ptr fdopenw.
	* pex-unix.c (pex_unix_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* pex-win32.c (pex_win32_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* pex-djgpp.c (funcs): Leave fdopenw null.
	* pex-msdos (funcs): Same.
	* functions.texi: Regenerated.

2006-03-12  Jim Blandy  <jimb@@red-bean.com>

	* pex-common.h (struct pex_obj): Doc fixes.

2006-03-11  Jim Blandy  <jimb@@red-bean.com>

	* functions.texi: Regenerate.
@
text
@a279 1
static FILE *pex_unix_fdopenw (struct pex_obj *, int, int);
a292 1
  pex_unix_fdopenw,
a497 9
static FILE *
pex_unix_fdopenw (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,
		  int binary ATTRIBUTE_UNUSED)
{
  if (fcntl (fd, F_SETFD, FD_CLOEXEC) < 0)
    return NULL;
  return fdopen (fd, "w");
}

@


1.6
log
@Update the address and phone number of the FSF organization.
@
text
@d255 1
a255 1
      psl = xmalloc (sizeof (struct status_list));
@


1.5
log
@libiberty:
	* pex-common.c: New file.
	* pex-one.c: New file.
	* pexecute.c: New file.
	* pex-common.h: Include <stdio.h>.
	(struct pex_obj): Define.
	(struct pex_funcs): Define.
	(pex_init_common): Declare.
	* pex-unix.c: Rewrite.
	* pex-win32.c: Rewrite.
	* pex-djgpp.c: Rewrite.
	* pex-msdos.c: Rewrite.
	* testsuite/text-pexecute.c: New file.
	* pexecute.txh: Rewrite.
	* configure.ac: Check for wait3 and wait4.  Set CHECK to
	really-check rather than check-cplus-dem.
	* functions.texi: Rebuild.
	* Makefile.in: Rebuild dependencies.
	(CFILES): Add pexecute.c, pex-common.c, pex-one.c.
	(REQUIRED_OFILES): Add pexecute.o, pex-common.o, pex-one.o.
	* testsuite/Makefile.in (really-check): New target.
	(check-pexecute, test-pexecute): New targets.
	* configure: Rebuild.
include:
	* libiberty.h: Include <stdio.h>.
	(PEX_RECORD_TIMES, PEX_USE_PIPES, PEX_SAVE_TEMPS): Define.
	(PEX_LAST, PEX_SEARCH, PEX_SUFFIX, PEX_STDERR_TO_STDOUT): Define.
	(PEX_BINARY_INPUT, PEX_BINARY_OUTPUT): Define.
	(pex_init, pex_run, pex_read_output): Declare.
	(pex_get_status, pex_get_times, pex_free, pex_one): Declare.
	(struct pex_time): Define.
@
text
@d20 2
a21 2
write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
@


1.4
log
@merge from gcc
@
text
@d23 2
d28 1
d33 3
d42 5
a46 2
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
d51 7
a58 3
#ifndef HAVE_WAITPID
#define waitpid(pid, status, flags) wait(status)
#endif
a72 2
/* Execute a program, possibly setting up pipes to programs executed
   via other calls to this function.
d74 97
a170 36
   This version of the function uses vfork.  In general vfork is
   similar to setjmp/longjmp, in that any variable which is modified by
   the child process has an indeterminate value in the parent process.
   We follow a safe approach here by not modifying any variables at
   all in the child process (with the possible exception of variables
   modified by xstrerror if exec fails, but this is unlikely to be
   detectable).

   We work a little bit harder to avoid gcc warnings.  gcc will warn
   about any automatic variable which is live at the time of the
   vfork, which is non-volatile, and which is either set more than
   once or is an argument to the function.  This warning isn't quite
   right, since what we really care about is whether the variable is
   live at the time of the vfork and set afterward by the child
   process, but gcc only checks whether the variable is set more than
   once.  To avoid this warning, we ensure that any variable which is
   live at the time of the vfork (i.e., used after the vfork) is set
   exactly once and is not an argument, or is marked volatile.  */

int
pexecute (const char *program, char * const *argv, const char *this_pname,
          const char *temp_base ATTRIBUTE_UNUSED,
          char **errmsg_fmt, char **errmsg_arg, int flagsarg)
{
  int pid;
  int pdes[2];
  int out;
  int input_desc, output_desc;
  int flags;
  /* We declare these to be volatile to avoid warnings from gcc about
     them being clobbered by vfork.  */
  volatile int retries, sleep_interval;
  /* Pipe waiting from last process, to be used as input for the next one.
     Value is STDIN_FILE_NO if no pipe is waiting
     (i.e. the next command is the first of a group).  */
  static int last_pipe_input;
d172 1
a172 1
  flags = flagsarg;
d174 7
a180 3
  /* If this is the first process, initialize.  */
  if (flags & PEXECUTE_FIRST)
    last_pipe_input = STDIN_FILE_NO;
d182 4
a185 1
  input_desc = last_pipe_input;
d187 3
a189 3
  /* If this isn't the last process, make a pipe for its output,
     and record it as waiting to be the input to the next process.  */
  if (! (flags & PEXECUTE_LAST))
d191 1
a191 1
      if (pipe (pdes) < 0)
d193 9
a201 3
	  *errmsg_fmt = "pipe";
	  *errmsg_arg = NULL;
	  return -1;
a202 2
      out = pdes[WRITE_PORT];
      last_pipe_input = pdes[READ_PORT];
d204 2
a205 1
  else
d207 55
a261 3
      /* Last process.  */
      out = STDOUT_FILE_NO;
      last_pipe_input = STDIN_FILE_NO;
d263 60
d324 39
a362 1
  output_desc = out;
a363 1
  /* Fork a subprocess; wait and retry if it fails.  */
d366 1
a366 1
  for (retries = 0; retries < 4; retries++)
d378 2
a379 2
      *errmsg_fmt = "fork";
      *errmsg_arg = NULL;
d382 17
a398 3
    case 0: /* child */
      /* Move the input and output pipes into place, if necessary.  */
      if (input_desc != STDIN_FILE_NO)
d400 4
a403 3
	  close (STDIN_FILE_NO);
	  dup (input_desc);
	  close (input_desc);
d405 1
a405 1
      if (output_desc != STDOUT_FILE_NO)
d407 7
a413 3
	  close (STDOUT_FILE_NO);
	  dup (output_desc);
	  close (output_desc);
a414 8

      /* Close the parent's descs that aren't wanted here.  */
      if (last_pipe_input != STDIN_FILE_NO)
	close (last_pipe_input);

      /* Exec the program.  */
      if (flags & PEXECUTE_SEARCH)
	execvp (program, argv);
d416 4
a419 1
	execv (program, argv);
a420 10
      /* We don't want to call fprintf after vfork.  */
#define writeerr(s) write (STDERR_FILE_NO, s, strlen (s))
      writeerr (this_pname);
      writeerr (": ");
      writeerr ("installation problem, cannot exec '");
      writeerr (program);
      writeerr ("': ");
      writeerr (xstrerror (errno));
      writeerr ("\n");
      _exit (-1);
d422 1
a422 1
      return 0;
d425 28
a452 6
      /* In the parent, after forking.
	 Close the descriptors that we made for this child.  */
      if (input_desc != STDIN_FILE_NO)
	close (input_desc);
      if (output_desc != STDOUT_FILE_NO)
	close (output_desc);
d454 1
a454 2
      /* Return child's process number.  */
      return pid;
d458 6
a463 2
int
pwait (int pid, int *status, int flags ATTRIBUTE_UNUSED)
d465 48
a512 4
  /* ??? Here's an opportunity to canonicalize the values in STATUS.
     Needed?  */
  pid = waitpid (pid, status, 0);
  return pid;
@


1.3
log
@merge from gcc
@
text
@d4 1
a4 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004
d83 3
a85 8
pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg,
	  flagsarg)
     const char *program;
     char * const *argv;
     const char *this_pname;
     const char *temp_base ATTRIBUTE_UNUSED;
     char **errmsg_fmt, **errmsg_arg;
     int flagsarg;
d201 1
a201 4
pwait (pid, status, flags)
     int pid;
     int *status;
     int flags ATTRIBUTE_UNUSED;
@


1.2
log
@merge from gcc
@
text
@d64 1
a64 1
   similar to setjmp/longmp, in that any variable which is modified by
@


1.1
log
@merge from gcc
@
text
@d4 1
a4 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003
d47 34
a80 2
extern int execv ();
extern int execvp ();
d83 2
a84 1
pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
d90 1
a90 1
     int flags;
a91 1
  int (*func)() = (flags & PEXECUTE_SEARCH ? execvp : execv);
d94 1
d96 4
a99 1
  int retries, sleep_interval;
d105 2
d123 1
a123 1
      output_desc = pdes[WRITE_PORT];
d129 1
a129 1
      output_desc = STDOUT_FILE_NO;
d133 2
d140 1
a140 1
      pid = fork ();
d174 15
a188 6
      (*func) (program, argv);

      fprintf (stderr, "%s: ", this_pname);
      fprintf (stderr, install_error_msg, program);
      fprintf (stderr, ": %s\n", xstrerror (errno));
      exit (-1);
@


1.1.52.1
log
@Merge mainline to intercu branch.
@
text
@d4 1
a4 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004
d47 2
a48 34
#ifdef vfork /* Autoconf may define this to fork for us. */
# define VFORK_STRING "fork"
#else
# define VFORK_STRING "vfork"
#endif
#ifdef HAVE_VFORK_H
#include <vfork.h>
#endif
#ifdef VMS
#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \
               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
#endif /* VMS */

/* Execute a program, possibly setting up pipes to programs executed
   via other calls to this function.

   This version of the function uses vfork.  In general vfork is
   similar to setjmp/longmp, in that any variable which is modified by
   the child process has an indeterminate value in the parent process.
   We follow a safe approach here by not modifying any variables at
   all in the child process (with the possible exception of variables
   modified by xstrerror if exec fails, but this is unlikely to be
   detectable).

   We work a little bit harder to avoid gcc warnings.  gcc will warn
   about any automatic variable which is live at the time of the
   vfork, which is non-volatile, and which is either set more than
   once or is an argument to the function.  This warning isn't quite
   right, since what we really care about is whether the variable is
   live at the time of the vfork and set afterward by the child
   process, but gcc only checks whether the variable is set more than
   once.  To avoid this warning, we ensure that any variable which is
   live at the time of the vfork (i.e., used after the vfork) is set
   exactly once and is not an argument, or is marked volatile.  */
d51 1
a51 2
pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg,
	  flagsarg)
d57 1
a57 1
     int flagsarg;
d59 1
a61 1
  int out;
d63 1
a63 4
  int flags;
  /* We declare these to be volatile to avoid warnings from gcc about
     them being clobbered by vfork.  */
  volatile int retries, sleep_interval;
a68 2
  flags = flagsarg;

d85 1
a85 1
      out = pdes[WRITE_PORT];
d91 1
a91 1
      out = STDOUT_FILE_NO;
a94 2
  output_desc = out;

d100 1
a100 1
      pid = vfork ();
d134 6
a139 15
      if (flags & PEXECUTE_SEARCH)
	execvp (program, argv);
      else
	execv (program, argv);

      /* We don't want to call fprintf after vfork.  */
#define writeerr(s) write (STDERR_FILE_NO, s, strlen (s))
      writeerr (this_pname);
      writeerr (": ");
      writeerr ("installation problem, cannot exec '");
      writeerr (program);
      writeerr ("': ");
      writeerr (xstrerror (errno));
      writeerr ("\n");
      _exit (-1);
@


1.1.56.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d4 1
a4 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004
d47 2
a48 34
#ifdef vfork /* Autoconf may define this to fork for us. */
# define VFORK_STRING "fork"
#else
# define VFORK_STRING "vfork"
#endif
#ifdef HAVE_VFORK_H
#include <vfork.h>
#endif
#ifdef VMS
#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \
               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
#endif /* VMS */

/* Execute a program, possibly setting up pipes to programs executed
   via other calls to this function.

   This version of the function uses vfork.  In general vfork is
   similar to setjmp/longmp, in that any variable which is modified by
   the child process has an indeterminate value in the parent process.
   We follow a safe approach here by not modifying any variables at
   all in the child process (with the possible exception of variables
   modified by xstrerror if exec fails, but this is unlikely to be
   detectable).

   We work a little bit harder to avoid gcc warnings.  gcc will warn
   about any automatic variable which is live at the time of the
   vfork, which is non-volatile, and which is either set more than
   once or is an argument to the function.  This warning isn't quite
   right, since what we really care about is whether the variable is
   live at the time of the vfork and set afterward by the child
   process, but gcc only checks whether the variable is set more than
   once.  To avoid this warning, we ensure that any variable which is
   live at the time of the vfork (i.e., used after the vfork) is set
   exactly once and is not an argument, or is marked volatile.  */
d51 1
a51 2
pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg,
	  flagsarg)
d57 1
a57 1
     int flagsarg;
d59 1
a61 1
  int out;
d63 1
a63 4
  int flags;
  /* We declare these to be volatile to avoid warnings from gcc about
     them being clobbered by vfork.  */
  volatile int retries, sleep_interval;
a68 2
  flags = flagsarg;

d85 1
a85 1
      out = pdes[WRITE_PORT];
d91 1
a91 1
      out = STDOUT_FILE_NO;
a94 2
  output_desc = out;

d100 1
a100 1
      pid = vfork ();
d134 6
a139 15
      if (flags & PEXECUTE_SEARCH)
	execvp (program, argv);
      else
	execv (program, argv);

      /* We don't want to call fprintf after vfork.  */
#define writeerr(s) write (STDERR_FILE_NO, s, strlen (s))
      writeerr (this_pname);
      writeerr (": ");
      writeerr ("installation problem, cannot exec '");
      writeerr (program);
      writeerr ("': ");
      writeerr (xstrerror (errno));
      writeerr ("\n");
      _exit (-1);
@


1.1.44.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.1.4.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@@

