head	1.20;
access;
symbols
	sid-snapshot-20180601:1.20
	sid-snapshot-20180501:1.20
	sid-snapshot-20180401:1.20
	sid-snapshot-20180301:1.20
	sid-snapshot-20180201:1.20
	sid-snapshot-20180101:1.20
	sid-snapshot-20171201:1.20
	sid-snapshot-20171101:1.20
	sid-snapshot-20171001:1.20
	sid-snapshot-20170901:1.20
	sid-snapshot-20170801:1.20
	sid-snapshot-20170701:1.20
	sid-snapshot-20170601:1.20
	sid-snapshot-20170501:1.20
	sid-snapshot-20170401:1.20
	sid-snapshot-20170301:1.20
	sid-snapshot-20170201:1.20
	sid-snapshot-20170101:1.20
	sid-snapshot-20161201:1.20
	sid-snapshot-20161101:1.20
	sid-snapshot-20160901:1.20
	sid-snapshot-20160801:1.20
	sid-snapshot-20160701:1.20
	sid-snapshot-20160601:1.20
	sid-snapshot-20160501:1.20
	sid-snapshot-20160401:1.20
	sid-snapshot-20160301:1.20
	sid-snapshot-20160201:1.20
	sid-snapshot-20160101:1.20
	sid-snapshot-20151201:1.20
	sid-snapshot-20151101:1.20
	sid-snapshot-20151001:1.20
	sid-snapshot-20150901:1.20
	sid-snapshot-20150801:1.20
	sid-snapshot-20150701:1.20
	sid-snapshot-20150601:1.20
	sid-snapshot-20150501:1.20
	sid-snapshot-20150401:1.20
	sid-snapshot-20150301:1.20
	sid-snapshot-20150201:1.20
	sid-snapshot-20150101:1.20
	sid-snapshot-20141201:1.20
	sid-snapshot-20141101:1.20
	sid-snapshot-20141001:1.20
	sid-snapshot-20140901:1.20
	sid-snapshot-20140801:1.20
	sid-snapshot-20140701:1.20
	sid-snapshot-20140601:1.20
	sid-snapshot-20140501:1.20
	sid-snapshot-20140401:1.20
	sid-snapshot-20140301:1.20
	sid-snapshot-20140201:1.20
	sid-snapshot-20140101:1.20
	sid-snapshot-20131201:1.20
	sid-snapshot-20131101:1.20
	sid-snapshot-20131001:1.20
	binutils-2_24-branch:1.20.0.16
	binutils-2_24-branchpoint:1.20
	binutils-2_21_1:1.18
	sid-snapshot-20130901:1.20
	gdb_7_6_1-2013-08-30-release:1.20
	sid-snapshot-20130801:1.20
	sid-snapshot-20130701:1.20
	sid-snapshot-20130601:1.20
	sid-snapshot-20130501:1.20
	gdb_7_6-2013-04-26-release:1.20
	sid-snapshot-20130401:1.20
	binutils-2_23_2:1.20
	gdb_7_6-branch:1.20.0.14
	gdb_7_6-2013-03-12-branchpoint:1.20
	sid-snapshot-20130301:1.20
	sid-snapshot-20130201:1.20
	sid-snapshot-20130101:1.20
	sid-snapshot-20121201:1.20
	gdb_7_5_1-2012-11-29-release:1.20
	binutils-2_23_1:1.20
	sid-snapshot-20121101:1.20
	binutils-2_23:1.20
	sid-snapshot-20121001:1.20
	sid-snapshot-20120901:1.20
	gdb_7_5-2012-08-17-release:1.20
	sid-snapshot-20120801:1.20
	binutils-2_23-branch:1.20.0.12
	binutils-2_23-branchpoint:1.20
	gdb_7_5-branch:1.20.0.10
	gdb_7_5-2012-07-18-branchpoint:1.20
	sid-snapshot-20120701:1.20
	sid-snapshot-20120601:1.20
	sid-snapshot-20120501:1.20
	binutils-2_22_branch:1.20.0.8
	gdb_7_4_1-2012-04-26-release:1.20
	sid-snapshot-20120401:1.20
	sid-snapshot-20120301:1.20
	sid-snapshot-20120201:1.20
	gdb_7_4-2012-01-24-release:1.20
	sid-snapshot-20120101:1.20
	gdb_7_4-branch:1.20.0.6
	gdb_7_4-2011-12-13-branchpoint:1.20
	sid-snapshot-20111201:1.20
	binutils-2_22:1.20
	sid-snapshot-20111101:1.20
	sid-snapshot-20111001:1.20
	binutils-2_22-branch:1.20.0.4
	binutils-2_22-branchpoint:1.20
	gdb_7_3_1-2011-09-04-release:1.20
	sid-snapshot-20110901:1.20
	sid-snapshot-20110801:1.20
	gdb_7_3-2011-07-26-release:1.20
	sid-snapshot-20110701:1.20
	sid-snapshot-20110601:1.20
	sid-snapshot-20110501:1.20
	gdb_7_3-branch:1.20.0.2
	gdb_7_3-2011-04-01-branchpoint:1.20
	sid-snapshot-20110401:1.20
	sid-snapshot-20110301:1.20
	cygwin-1_7_8-release:1.20
	sid-snapshot-20110201:1.19
	sid-snapshot-20110101:1.19
	binutils-2_21:1.18
	sid-snapshot-20101201:1.18
	binutils-2_21-branch:1.18.0.4
	binutils-2_21-branchpoint:1.18
	sid-snapshot-20101101:1.18
	sid-snapshot-20101001:1.18
	binutils-2_20_1:1.17
	gdb_7_2-2010-09-02-release:1.18
	sid-snapshot-20100901:1.18
	cygwin-1_7_7-release:1.18
	sid-snapshot-20100801:1.18
	gdb_7_2-branch:1.18.0.2
	gdb_7_2-2010-07-07-branchpoint:1.18
	sid-snapshot-20100701:1.18
	sid-snapshot-20100601:1.17
	sid-snapshot-20100501:1.17
	sid-snapshot-20100401:1.17
	gdb_7_1-2010-03-18-release:1.17
	sid-snapshot-20100301:1.17
	gdb_7_1-branch:1.17.0.32
	gdb_7_1-2010-02-18-branchpoint:1.17
	sid-snapshot-20100201:1.17
	sid-snapshot-20100101:1.17
	gdb_7_0_1-2009-12-22-release:1.17
	sid-snapshot-20091201:1.17
	sid-snapshot-20091101:1.17
	binutils-2_20:1.17
	gdb_7_0-2009-10-06-release:1.17
	sid-snapshot-20091001:1.17
	gdb_7_0-branch:1.17.0.30
	gdb_7_0-2009-09-16-branchpoint:1.17
	arc-sim-20090309:1.17
	binutils-arc-20081103-branch:1.17.0.28
	binutils-arc-20081103-branchpoint:1.17
	binutils-2_20-branch:1.17.0.26
	binutils-2_20-branchpoint:1.17
	sid-snapshot-20090901:1.17
	sid-snapshot-20090801:1.17
	msnyder-checkpoint-072509-branch:1.17.0.24
	msnyder-checkpoint-072509-branchpoint:1.17
	sid-snapshot-20090701:1.17
	dje-cgen-play1-branch:1.17.0.22
	dje-cgen-play1-branchpoint:1.17
	sid-snapshot-20090601:1.17
	sid-snapshot-20090501:1.17
	sid-snapshot-20090401:1.17
	arc-20081103-branch:1.17.0.20
	arc-20081103-branchpoint:1.17
	arc-insight_6_8-branch:1.17.0.18
	arc-insight_6_8-branchpoint:1.17
	insight_6_8-branch:1.17.0.16
	insight_6_8-branchpoint:1.17
	sid-snapshot-20090301:1.17
	binutils-2_19_1:1.17
	sid-snapshot-20090201:1.17
	sid-snapshot-20090101:1.17
	reverse-20081226-branch:1.17.0.14
	reverse-20081226-branchpoint:1.17
	sid-snapshot-20081201:1.17
	multiprocess-20081120-branch:1.17.0.12
	multiprocess-20081120-branchpoint:1.17
	sid-snapshot-20081101:1.17
	binutils-2_19:1.17
	sid-snapshot-20081001:1.17
	reverse-20080930-branch:1.17.0.10
	reverse-20080930-branchpoint:1.17
	binutils-2_19-branch:1.17.0.8
	binutils-2_19-branchpoint:1.17
	sid-snapshot-20080901:1.17
	sid-snapshot-20080801:1.17
	reverse-20080717-branch:1.17.0.6
	reverse-20080717-branchpoint:1.17
	sid-snapshot-20080701:1.17
	msnyder-reverse-20080609-branch:1.17.0.4
	msnyder-reverse-20080609-branchpoint:1.17
	drow-reverse-20070409-branch:1.16.0.34
	drow-reverse-20070409-branchpoint:1.16
	sid-snapshot-20080601:1.17
	sid-snapshot-20080501:1.17
	sid-snapshot-20080403:1.17
	sid-snapshot-20080401:1.17
	gdb_6_8-2008-03-27-release:1.17
	sid-snapshot-20080301:1.17
	gdb_6_8-branch:1.17.0.2
	gdb_6_8-2008-02-26-branchpoint:1.17
	sid-snapshot-20080201:1.17
	sid-snapshot-20080101:1.16
	sid-snapshot-20071201:1.16
	sid-snapshot-20071101:1.16
	gdb_6_7_1-2007-10-29-release:1.16
	gdb_6_7-2007-10-10-release:1.16
	sid-snapshot-20071001:1.16
	gdb_6_7-branch:1.16.0.32
	gdb_6_7-2007-09-07-branchpoint:1.16
	binutils-2_18:1.16
	binutils-2_18-branch:1.16.0.30
	binutils-2_18-branchpoint:1.16
	insight_6_6-20070208-release:1.16
	binutils-csl-coldfire-4_1-32:1.16
	binutils-csl-sourcerygxx-4_1-32:1.16
	gdb_6_6-2006-12-18-release:1.16
	binutils-csl-innovasic-fido-3_4_4-33:1.16
	binutils-csl-sourcerygxx-3_4_4-32:1.13
	binutils-csl-coldfire-4_1-30:1.16
	binutils-csl-sourcerygxx-4_1-30:1.16
	binutils-csl-coldfire-4_1-28:1.16
	binutils-csl-sourcerygxx-4_1-29:1.16
	binutils-csl-sourcerygxx-4_1-28:1.16
	gdb_6_6-branch:1.16.0.28
	gdb_6_6-2006-11-15-branchpoint:1.16
	binutils-csl-arm-2006q3-27:1.16
	binutils-csl-sourcerygxx-4_1-27:1.16
	binutils-csl-arm-2006q3-26:1.16
	binutils-csl-sourcerygxx-4_1-26:1.16
	binutils-csl-sourcerygxx-4_1-25:1.16
	binutils-csl-sourcerygxx-4_1-24:1.16
	binutils-csl-sourcerygxx-4_1-23:1.16
	insight_6_5-20061003-release:1.16
	gdb-csl-symbian-6_4_50_20060226-12:1.16
	binutils-csl-sourcerygxx-4_1-21:1.16
	binutils-csl-arm-2006q3-21:1.16
	binutils-csl-sourcerygxx-4_1-22:1.16
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.16
	binutils-csl-sourcerygxx-4_1-20:1.16
	binutils-csl-arm-2006q3-19:1.16
	binutils-csl-sourcerygxx-4_1-19:1.16
	binutils-csl-sourcerygxx-4_1-18:1.16
	binutils-csl-renesas-4_1-9:1.16
	gdb-csl-sourcerygxx-3_4_4-25:1.16
	binutils-csl-sourcerygxx-3_4_4-25:1.13
	nickrob-async-20060828-mergepoint:1.16
	gdb-csl-symbian-6_4_50_20060226-11:1.16
	binutils-csl-renesas-4_1-8:1.16
	binutils-csl-renesas-4_1-7:1.16
	binutils-csl-renesas-4_1-6:1.16
	gdb-csl-sourcerygxx-4_1-17:1.16
	binutils-csl-sourcerygxx-4_1-17:1.16
	gdb-csl-20060226-branch-local-2:1.16
	cr-0x5f1:1.16.0.26
	gdb-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-15:1.16
	gdb-csl-sourcerygxx-4_1-13:1.16
	binutils-csl-sourcerygxx-4_1-13:1.16
	binutils-2_17:1.16
	gdb-csl-sourcerygxx-4_1-12:1.16
	binutils-csl-sourcerygxx-4_1-12:1.16
	gdb-csl-sourcerygxx-3_4_4-21:1.16
	binutils-csl-sourcerygxx-3_4_4-21:1.16
	gdb_6_5-20060621-release:1.16
	binutils-csl-wrs-linux-3_4_4-24:1.13
	binutils-csl-wrs-linux-3_4_4-23:1.13
	gdb-csl-sourcerygxx-4_1-9:1.16
	binutils-csl-sourcerygxx-4_1-9:1.16
	gdb-csl-sourcerygxx-4_1-8:1.16
	binutils-csl-sourcerygxx-4_1-8:1.16
	gdb-csl-sourcerygxx-4_1-7:1.16
	binutils-csl-sourcerygxx-4_1-7:1.16
	gdb-csl-arm-2006q1-6:1.16
	binutils-csl-arm-2006q1-6:1.16
	gdb-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-wrs-linux-3_4_4-22:1.13
	gdb-csl-symbian-6_4_50_20060226-10:1.16
	gdb-csl-symbian-6_4_50_20060226-9:1.16
	gdb-csl-symbian-6_4_50_20060226-8:1.16
	gdb-csl-coldfire-4_1-11:1.16
	binutils-csl-coldfire-4_1-11:1.16
	gdb-csl-sourcerygxx-3_4_4-19:1.16
	binutils-csl-sourcerygxx-3_4_4-19:1.16
	gdb-csl-coldfire-4_1-10:1.16
	gdb_6_5-branch:1.16.0.24
	gdb_6_5-2006-05-14-branchpoint:1.16
	binutils-csl-coldfire-4_1-10:1.16
	gdb-csl-sourcerygxx-4_1-5:1.16
	binutils-csl-sourcerygxx-4_1-5:1.16
	nickrob-async-20060513-branch:1.16.0.22
	nickrob-async-20060513-branchpoint:1.16
	gdb-csl-sourcerygxx-4_1-4:1.16
	binutils-csl-sourcerygxx-4_1-4:1.16
	msnyder-reverse-20060502-branch:1.16.0.20
	msnyder-reverse-20060502-branchpoint:1.16
	binutils-csl-wrs-linux-3_4_4-21:1.13
	gdb-csl-morpho-4_1-4:1.16
	binutils-csl-morpho-4_1-4:1.16
	gdb-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-wrs-linux-3_4_4-20:1.13
	readline_5_1-import-branch:1.16.0.18
	readline_5_1-import-branchpoint:1.16
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.16
	binutils-2_17-branch:1.16.0.16
	binutils-2_17-branchpoint:1.16
	gdb-csl-symbian-20060226-branch:1.16.0.14
	gdb-csl-symbian-20060226-branchpoint:1.16
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.16
	msnyder-reverse-20060331-branch:1.16.0.12
	msnyder-reverse-20060331-branchpoint:1.16
	binutils-csl-2_17-branch:1.16.0.10
	binutils-csl-2_17-branchpoint:1.16
	gdb-csl-available-20060303-branch:1.16.0.8
	gdb-csl-available-20060303-branchpoint:1.16
	gdb-csl-20060226-branch:1.16.0.6
	gdb-csl-20060226-branchpoint:1.16
	gdb_6_4-20051202-release:1.15
	msnyder-fork-checkpoint-branch:1.16.0.4
	msnyder-fork-checkpoint-branchpoint:1.16
	gdb-csl-gxxpro-6_3-branch:1.16.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.16
	gdb_6_4-branch:1.15.0.6
	gdb_6_4-2005-11-01-branchpoint:1.15
	gdb-csl-arm-20051020-branch:1.15.0.4
	gdb-csl-arm-20051020-branchpoint:1.15
	binutils-csl-gxxpro-3_4-branch:1.13.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.13
	binutils-2_16_1:1.13
	msnyder-tracepoint-checkpoint-branch:1.15.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.15
	gdb-csl-arm-20050325-2005-q1b:1.13
	binutils-csl-arm-2005q1b:1.13
	binutils-2_16:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	binutils-csl-arm-2005q1a:1.13
	csl-arm-20050325-branch:1.13.0.6
	csl-arm-20050325-branchpoint:1.13
	binutils-csl-arm-2005q1-branch:1.13.0.4
	binutils-csl-arm-2005q1-branchpoint:1.13
	binutils-2_16-branch:1.13.0.2
	binutils-2_16-branchpoint:1.13
	csl-arm-2004-q3d:1.12
	gdb_6_3-20041109-release:1.12
	gdb_6_3-branch:1.12.0.38
	gdb_6_3-20041019-branchpoint:1.12
	csl-arm-2004-q3:1.12
	drow_intercu-merge-20040921:1.12
	drow_intercu-merge-20040915:1.12
	jimb-gdb_6_2-e500-branch:1.12.0.40
	jimb-gdb_6_2-e500-branchpoint:1.12
	gdb_6_2-20040730-release:1.12
	gdb_6_2-branch:1.12.0.36
	gdb_6_2-2004-07-10-gmt-branchpoint:1.12
	gdb_6_1_1-20040616-release:1.12
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	gdb_6_1-2004-04-05-release:1.12
	drow_intercu-merge-20040402:1.12
	drow_intercu-merge-20040327:1.12
	ezannoni_pie-20040323-branch:1.12.0.34
	ezannoni_pie-20040323-branchpoint:1.12
	cagney_tramp-20040321-mergepoint:1.12
	cagney_tramp-20040309-branch:1.12.0.32
	cagney_tramp-20040309-branchpoint:1.12
	gdb_6_1-branch:1.12.0.30
	gdb_6_1-2004-03-01-gmt-branchpoint:1.12
	drow_intercu-20040221-branch:1.12.0.28
	drow_intercu-20040221-branchpoint:1.12
	binutils-2_15-branch:1.12.0.26
	cagney_bfdfile-20040213-branch:1.12.0.24
	cagney_bfdfile-20040213-branchpoint:1.12
	drow-cplus-merge-20040208:1.12
	carlton_dictionary-20040126-merge:1.12
	cagney_bigcore-20040122-branch:1.12.0.22
	cagney_bigcore-20040122-branchpoint:1.12
	drow-cplus-merge-20040113:1.12
	csl-arm-2003-q4:1.12
	drow-cplus-merge-20031224:1.12
	drow-cplus-merge-20031220:1.12
	carlton_dictionary-20031215-merge:1.12
	drow-cplus-merge-20031214:1.12
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.12
	kettenis_sparc-20030918-branch:1.12.0.20
	kettenis_sparc-20030918-branchpoint:1.12
	carlton_dictionary-20030917-merge:1.12
	ezannoni_pie-20030916-branchpoint:1.12
	ezannoni_pie-20030916-branch:1.12.0.18
	cagney_x86i386-20030821-branch:1.12.0.16
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.12
	carlton_dictionary-20030627-merge:1.12
	gdb_6_0-branch:1.12.0.14
	gdb_6_0-2003-06-23-branchpoint:1.12
	jimb-ppc64-linux-20030613-branch:1.12.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.12
	binutils-2_14:1.11
	cagney_convert-20030606-branch:1.12.0.10
	cagney_convert-20030606-branchpoint:1.12
	cagney_writestrings-20030508-branch:1.12.0.8
	cagney_writestrings-20030508-branchpoint:1.12
	jimb-ppc64-linux-20030528-branch:1.12.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.12
	carlton_dictionary-20030523-merge:1.12
	cagney_fileio-20030521-branch:1.12.0.4
	cagney_fileio-20030521-branchpoint:1.12
	kettenis_i386newframe-20030517-mergepoint:1.12
	jimb-ppc64-linux-20030509-branch:1.12.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.12
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	binutils-2_14-branch:1.11.0.26
	binutils-2_14-branchpoint:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.24
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.22
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.20
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.11.0.18
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.11.0.16
	cagney_lazyid-20030317-branchpoint:1.11
	kettenis-i386newframe-20030316-mergepoint:1.11
	offbyone-20030313-branch:1.11.0.14
	offbyone-20030313-branchpoint:1.11
	kettenis-i386newframe-20030308-branch:1.11.0.12
	kettenis-i386newframe-20030308-branchpoint:1.11
	carlton_dictionary-20030305-merge:1.11
	cagney_offbyone-20030303-branch:1.11.0.10
	cagney_offbyone-20030303-branchpoint:1.11
	w32api-2_2:1.11
	mingw-runtime-2_4:1.11
	carlton_dictionary-20030207-merge:1.11
	interps-20030202-branch:1.11.0.8
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.11.0.6
	cagney-unwind-20030108-branchpoint:1.11
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.11
	binutils-2_13_1:1.9
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.4
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.2
	carlton_dictionary-20020920-branchpoint:1.11
	sid-20020905-branchpoint:1.9
	sid-20020905-branch:1.9.0.16
	gdb_5_3-branch:1.9.0.14
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.12
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.10
	readline_4_3-import-branchpoint:1.9
	binutils-2_13:1.9
	gdb_5_2_1-2002-07-23-release:1.8.2.1
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.8
	kseitz_interps-20020528-branch:1.9.0.6
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.4
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.7
	jimb-macro-020506-branch:1.9.0.2
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.8.2.1
	binutils-2_12:1.7
	gdb_5_2-branch:1.8.0.2
	gdb_5_2-2002-03-03-branchpoint:1.8
	binutils-2_12-branch:1.7.0.8
	binutils-2_12-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	binutils-2_11_2:1.6
	binutils-2_11_1:1.6
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	insight-precleanup-2001-01-01:1.6
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	gdb-premipsmulti-2000-06-06-branch:1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	cygwin-1_1_1:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	egcs_20000222:1.1.1.2
	binutils_latest_snapshot:1.20
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2011.02.03.07.23.59;	author rwild;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.08.16.24.43;	author dj;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.10.18.30.24;	author dj;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.19.01.18.42;	author dj;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.07.16.36.16;	author dj;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.10.15.33.34;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.28.05.07.08;	author dj;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.07.20.02.09;	author dj;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.07.19.15.59;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.20.13.45.20;	author dj;	state Exp;
branches
	1.11.2.1
	1.11.4.1
	1.11.24.1;
next	1.10;

1.10
date	2002.09.12.01.11.20;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.07.00.16.50;	author jimb;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2002.02.21.22.19.11;	author jimb;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.05.07.16.21.15;	author dj;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.12.02.16.48;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.15.15.16.11;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.00.16.01;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.22.16.14.35;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.11.19.13.51;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.54;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.11.2.1
date	2003.05.23.18.40.55;	author carlton;	state Exp;
branches;
next	;

1.11.4.1
date	2003.12.14.20.28.03;	author drow;	state Exp;
branches;
next	;

1.11.24.1
date	2003.05.18.09.44.40;	author kettenis;	state Exp;
branches;
next	;

1.9.6.1
date	2002.10.01.00.46.42;	author kseitz;	state Exp;
branches;
next	;

1.8.2.1
date	2002.04.15.04.15.16;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.54;	author rth;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.22.15.59.20;	author ian;	state Exp;
branches;
next	;


desc
@@


1.20
log
@libiberty: documentation markup and order fixes.

libiberty/:
	* splay-tree.c: Escape wrapping newlines in texinfo markup
	with '@@', to fix function declaration output rendering.
	* gather-docs: Relax and improve macro name matching to actually
	match all current names and to allow input line wrapping.
	* bsearch.c, concat.c, crc32.c, fnmatch.txh, fopen_unlocked.c,
	hashtab.c, insque.c, make-relative-prefix.c, memchr.c, memcmp.c,
	memcpy.c, memmem.c, memmove.c, mempcpy.c, memset.c,
	pexecute.txh, random.c, setenv.c, setproctitle.c,
	simple-object.txh, snprintf.c, stpncpy.c, strncmp.c, strtod.c,
	strtol.c, vasprintf.c, vprintf.c, vsnprintf.c, xmemdup.c:
	Wrap long texinfo input lines.
	* functions.texi: Regenerate.
@
text
@/* A splay-tree datatype.  
   Copyright (C) 1998, 1999, 2000, 2001, 2009,
   2010, 2011 Free Software Foundation, Inc.
   Contributed by Mark Mitchell (mark@@markmitchell.com).

This file is part of GNU CC.
   
GNU CC is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU CC is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */

/* For an easily readable description of splay-trees, see:

     Lewis, Harry R. and Denenberg, Larry.  Data Structures and Their
     Algorithms.  Harper-Collins, Inc.  1991.  */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include <stdio.h>

#include "libiberty.h"
#include "splay-tree.h"

static void splay_tree_delete_helper (splay_tree, splay_tree_node);
static inline void rotate_left (splay_tree_node *,
				splay_tree_node, splay_tree_node);
static inline void rotate_right (splay_tree_node *,
				splay_tree_node, splay_tree_node);
static void splay_tree_splay (splay_tree, splay_tree_key);
static int splay_tree_foreach_helper (splay_tree_node,
                                      splay_tree_foreach_fn, void*);

/* Deallocate NODE (a member of SP), and all its sub-trees.  */

static void 
splay_tree_delete_helper (splay_tree sp, splay_tree_node node)
{
  splay_tree_node pending = 0;
  splay_tree_node active = 0;

  if (!node)
    return;

#define KDEL(x)  if (sp->delete_key) (*sp->delete_key)(x);
#define VDEL(x)  if (sp->delete_value) (*sp->delete_value)(x);

  KDEL (node->key);
  VDEL (node->value);

  /* We use the "key" field to hold the "next" pointer.  */
  node->key = (splay_tree_key)pending;
  pending = (splay_tree_node)node;

  /* Now, keep processing the pending list until there aren't any
     more.  This is a little more complicated than just recursing, but
     it doesn't toast the stack for large trees.  */

  while (pending)
    {
      active = pending;
      pending = 0;
      while (active)
	{
	  splay_tree_node temp;

	  /* active points to a node which has its key and value
	     deallocated, we just need to process left and right.  */

	  if (active->left)
	    {
	      KDEL (active->left->key);
	      VDEL (active->left->value);
	      active->left->key = (splay_tree_key)pending;
	      pending = (splay_tree_node)(active->left);
	    }
	  if (active->right)
	    {
	      KDEL (active->right->key);
	      VDEL (active->right->value);
	      active->right->key = (splay_tree_key)pending;
	      pending = (splay_tree_node)(active->right);
	    }

	  temp = active;
	  active = (splay_tree_node)(temp->key);
	  (*sp->deallocate) ((char*) temp, sp->allocate_data);
	}
    }
#undef KDEL
#undef VDEL
}

/* Rotate the edge joining the left child N with its parent P.  PP is the
   grandparents' pointer to P.  */

static inline void
rotate_left (splay_tree_node *pp, splay_tree_node p, splay_tree_node n)
{
  splay_tree_node tmp;
  tmp = n->right;
  n->right = p;
  p->left = tmp;
  *pp = n;
}

/* Rotate the edge joining the right child N with its parent P.  PP is the
   grandparents' pointer to P.  */

static inline void
rotate_right (splay_tree_node *pp, splay_tree_node p, splay_tree_node n)
{
  splay_tree_node tmp;
  tmp = n->left;
  n->left = p;
  p->right = tmp;
  *pp = n;
}

/* Bottom up splay of key.  */

static void
splay_tree_splay (splay_tree sp, splay_tree_key key)
{
  if (sp->root == 0)
    return;

  do {
    int cmp1, cmp2;
    splay_tree_node n, c;

    n = sp->root;
    cmp1 = (*sp->comp) (key, n->key);

    /* Found.  */
    if (cmp1 == 0)
      return;

    /* Left or right?  If no child, then we're done.  */
    if (cmp1 < 0)
      c = n->left;
    else
      c = n->right;
    if (!c)
      return;

    /* Next one left or right?  If found or no child, we're done
       after one rotation.  */
    cmp2 = (*sp->comp) (key, c->key);
    if (cmp2 == 0
        || (cmp2 < 0 && !c->left)
        || (cmp2 > 0 && !c->right))
      {
	if (cmp1 < 0)
	  rotate_left (&sp->root, n, c);
	else
	  rotate_right (&sp->root, n, c);
        return;
      }

    /* Now we have the four cases of double-rotation.  */
    if (cmp1 < 0 && cmp2 < 0)
      {
	rotate_left (&n->left, c, c->left);
	rotate_left (&sp->root, n, n->left);
      }
    else if (cmp1 > 0 && cmp2 > 0)
      {
	rotate_right (&n->right, c, c->right);
	rotate_right (&sp->root, n, n->right);
      }
    else if (cmp1 < 0 && cmp2 > 0)
      {
	rotate_right (&n->left, c, c->right);
	rotate_left (&sp->root, n, n->left);
      }
    else if (cmp1 > 0 && cmp2 < 0)
      {
	rotate_left (&n->right, c, c->left);
	rotate_right (&sp->root, n, n->right);
      }
  } while (1);
}

/* Call FN, passing it the DATA, for every node below NODE, all of
   which are from SP, following an in-order traversal.  If FN every
   returns a non-zero value, the iteration ceases immediately, and the
   value is returned.  Otherwise, this function returns 0.  */

static int
splay_tree_foreach_helper (splay_tree_node node,
                           splay_tree_foreach_fn fn, void *data)
{
  int val;
  splay_tree_node *stack;
  int stack_ptr, stack_size;

  /* A non-recursive implementation is used to avoid filling the stack
     for large trees.  Splay trees are worst case O(n) in the depth of
     the tree.  */

#define INITIAL_STACK_SIZE 100
  stack_size = INITIAL_STACK_SIZE;
  stack_ptr = 0;
  stack = XNEWVEC (splay_tree_node, stack_size);
  val = 0;

  for (;;)
    {
      while (node != NULL)
	{
	  if (stack_ptr == stack_size)
	    {
	      stack_size *= 2;
	      stack = XRESIZEVEC (splay_tree_node, stack, stack_size);
	    }
	  stack[stack_ptr++] = node;
	  node = node->left;
	}

      if (stack_ptr == 0)
	break;

      node = stack[--stack_ptr];

      val = (*fn) (node, data);
      if (val)
	break;

      node = node->right;
    }

  XDELETEVEC (stack);
  return val;
}

/* An allocator and deallocator based on xmalloc.  */
static void *
splay_tree_xmalloc_allocate (int size, void *data ATTRIBUTE_UNUSED)
{
  return (void *) xmalloc (size);
}

static void
splay_tree_xmalloc_deallocate (void *object, void *data ATTRIBUTE_UNUSED)
{
  free (object);
}


/* Allocate a new splay tree, using COMPARE_FN to compare nodes,
   DELETE_KEY_FN to deallocate keys, and DELETE_VALUE_FN to deallocate
   values.  Use xmalloc to allocate the splay tree structure, and any
   nodes added.  */

splay_tree 
splay_tree_new (splay_tree_compare_fn compare_fn,
                splay_tree_delete_key_fn delete_key_fn,
                splay_tree_delete_value_fn delete_value_fn)
{
  return (splay_tree_new_with_allocator
          (compare_fn, delete_key_fn, delete_value_fn,
           splay_tree_xmalloc_allocate, splay_tree_xmalloc_deallocate, 0));
}


/* Allocate a new splay tree, using COMPARE_FN to compare nodes,
   DELETE_KEY_FN to deallocate keys, and DELETE_VALUE_FN to deallocate
   values.  */

splay_tree 
splay_tree_new_with_allocator (splay_tree_compare_fn compare_fn,
                               splay_tree_delete_key_fn delete_key_fn,
                               splay_tree_delete_value_fn delete_value_fn,
                               splay_tree_allocate_fn allocate_fn,
                               splay_tree_deallocate_fn deallocate_fn,
                               void *allocate_data)
{
  return
    splay_tree_new_typed_alloc (compare_fn, delete_key_fn, delete_value_fn,
				allocate_fn, allocate_fn, deallocate_fn,
				allocate_data);
}

/*

@@deftypefn Supplemental splay_tree splay_tree_new_with_typed_alloc @@
(splay_tree_compare_fn @@var{compare_fn}, @@
splay_tree_delete_key_fn @@var{delete_key_fn}, @@
splay_tree_delete_value_fn @@var{delete_value_fn}, @@
splay_tree_allocate_fn @@var{tree_allocate_fn}, @@
splay_tree_allocate_fn @@var{node_allocate_fn}, @@
splay_tree_deallocate_fn @@var{deallocate_fn}, @@
void * @@var{allocate_data})

This function creates a splay tree that uses two different allocators
@@var{tree_allocate_fn} and @@var{node_allocate_fn} to use for allocating the
tree itself and its nodes respectively.  This is useful when variables of
different types need to be allocated with different allocators.

The splay tree will use @@var{compare_fn} to compare nodes,
@@var{delete_key_fn} to deallocate keys, and @@var{delete_value_fn} to
deallocate values.

@@end deftypefn

*/

splay_tree
splay_tree_new_typed_alloc (splay_tree_compare_fn compare_fn,
			    splay_tree_delete_key_fn delete_key_fn,
			    splay_tree_delete_value_fn delete_value_fn,
			    splay_tree_allocate_fn tree_allocate_fn,
			    splay_tree_allocate_fn node_allocate_fn,
			    splay_tree_deallocate_fn deallocate_fn,
			    void * allocate_data)
{
  splay_tree sp = (splay_tree) (*tree_allocate_fn)
    (sizeof (struct splay_tree_s), allocate_data);

  sp->root = 0;
  sp->comp = compare_fn;
  sp->delete_key = delete_key_fn;
  sp->delete_value = delete_value_fn;
  sp->allocate = node_allocate_fn;
  sp->deallocate = deallocate_fn;
  sp->allocate_data = allocate_data;

  return sp;
}

/* Deallocate SP.  */

void 
splay_tree_delete (splay_tree sp)
{
  splay_tree_delete_helper (sp, sp->root);
  (*sp->deallocate) ((char*) sp, sp->allocate_data);
}

/* Insert a new node (associating KEY with DATA) into SP.  If a
   previous node with the indicated KEY exists, its data is replaced
   with the new value.  Returns the new node.  */

splay_tree_node
splay_tree_insert (splay_tree sp, splay_tree_key key, splay_tree_value value)
{
  int comparison = 0;

  splay_tree_splay (sp, key);

  if (sp->root)
    comparison = (*sp->comp)(sp->root->key, key);

  if (sp->root && comparison == 0)
    {
      /* If the root of the tree already has the indicated KEY, just
	 replace the value with VALUE.  */
      if (sp->delete_value)
	(*sp->delete_value)(sp->root->value);
      sp->root->value = value;
    } 
  else 
    {
      /* Create a new node, and insert it at the root.  */
      splay_tree_node node;

      node = ((splay_tree_node)
	      (*sp->allocate) (sizeof (struct splay_tree_node_s),
			       sp->allocate_data));
      node->key = key;
      node->value = value;
      
      if (!sp->root)
	node->left = node->right = 0;
      else if (comparison < 0)
	{
	  node->left = sp->root;
	  node->right = node->left->right;
	  node->left->right = 0;
	}
      else
	{
	  node->right = sp->root;
	  node->left = node->right->left;
	  node->right->left = 0;
	}

      sp->root = node;
    }

  return sp->root;
}

/* Remove KEY from SP.  It is not an error if it did not exist.  */

void
splay_tree_remove (splay_tree sp, splay_tree_key key)
{
  splay_tree_splay (sp, key);

  if (sp->root && (*sp->comp) (sp->root->key, key) == 0)
    {
      splay_tree_node left, right;

      left = sp->root->left;
      right = sp->root->right;

      /* Delete the root node itself.  */
      if (sp->delete_value)
	(*sp->delete_value) (sp->root->value);
      (*sp->deallocate) (sp->root, sp->allocate_data);

      /* One of the children is now the root.  Doesn't matter much
	 which, so long as we preserve the properties of the tree.  */
      if (left)
	{
	  sp->root = left;

	  /* If there was a right child as well, hang it off the 
	     right-most leaf of the left child.  */
	  if (right)
	    {
	      while (left->right)
		left = left->right;
	      left->right = right;
	    }
	}
      else
	sp->root = right;
    }
}

/* Lookup KEY in SP, returning VALUE if present, and NULL 
   otherwise.  */

splay_tree_node
splay_tree_lookup (splay_tree sp, splay_tree_key key)
{
  splay_tree_splay (sp, key);

  if (sp->root && (*sp->comp)(sp->root->key, key) == 0)
    return sp->root;
  else
    return 0;
}

/* Return the node in SP with the greatest key.  */

splay_tree_node
splay_tree_max (splay_tree sp)
{
  splay_tree_node n = sp->root;

  if (!n)
    return NULL;

  while (n->right)
    n = n->right;

  return n;
}

/* Return the node in SP with the smallest key.  */

splay_tree_node
splay_tree_min (splay_tree sp)
{
  splay_tree_node n = sp->root;

  if (!n)
    return NULL;

  while (n->left)
    n = n->left;

  return n;
}

/* Return the immediate predecessor KEY, or NULL if there is no
   predecessor.  KEY need not be present in the tree.  */

splay_tree_node
splay_tree_predecessor (splay_tree sp, splay_tree_key key)
{
  int comparison;
  splay_tree_node node;

  /* If the tree is empty, there is certainly no predecessor.  */
  if (!sp->root)
    return NULL;

  /* Splay the tree around KEY.  That will leave either the KEY
     itself, its predecessor, or its successor at the root.  */
  splay_tree_splay (sp, key);
  comparison = (*sp->comp)(sp->root->key, key);

  /* If the predecessor is at the root, just return it.  */
  if (comparison < 0)
    return sp->root;

  /* Otherwise, find the rightmost element of the left subtree.  */
  node = sp->root->left;
  if (node)
    while (node->right)
      node = node->right;

  return node;
}

/* Return the immediate successor KEY, or NULL if there is no
   successor.  KEY need not be present in the tree.  */

splay_tree_node
splay_tree_successor (splay_tree sp, splay_tree_key key)
{
  int comparison;
  splay_tree_node node;

  /* If the tree is empty, there is certainly no successor.  */
  if (!sp->root)
    return NULL;

  /* Splay the tree around KEY.  That will leave either the KEY
     itself, its predecessor, or its successor at the root.  */
  splay_tree_splay (sp, key);
  comparison = (*sp->comp)(sp->root->key, key);

  /* If the successor is at the root, just return it.  */
  if (comparison > 0)
    return sp->root;

  /* Otherwise, find the leftmost element of the right subtree.  */
  node = sp->root->right;
  if (node)
    while (node->left)
      node = node->left;

  return node;
}

/* Call FN, passing it the DATA, for every node in SP, following an
   in-order traversal.  If FN every returns a non-zero value, the
   iteration ceases immediately, and the value is returned.
   Otherwise, this function returns 0.  */

int
splay_tree_foreach (splay_tree sp, splay_tree_foreach_fn fn, void *data)
{
  return splay_tree_foreach_helper (sp->root, fn, data);
}

/* Splay-tree comparison function, treating the keys as ints.  */

int
splay_tree_compare_ints (splay_tree_key k1, splay_tree_key k2)
{
  if ((int) k1 < (int) k2)
    return -1;
  else if ((int) k1 > (int) k2)
    return 1;
  else 
    return 0;
}

/* Splay-tree comparison function, treating the keys as pointers.  */

int
splay_tree_compare_pointers (splay_tree_key k1, splay_tree_key k2)
{
  if ((char*) k1 < (char*) k2)
    return -1;
  else if ((char*) k1 > (char*) k2)
    return 1;
  else 
    return 0;
}
@


1.19
log
@merge from gcc
@
text
@d3 1
a3 1
   2010 Free Software Foundation, Inc.
d303 7
a309 7
@@deftypefn Supplemental splay_tree splay_tree_new_with_typed_alloc
(splay_tree_compare_fn @@var{compare_fn},
splay_tree_delete_key_fn @@var{delete_key_fn},
splay_tree_delete_value_fn @@var{delete_value_fn},
splay_tree_allocate_fn @@var{tree_allocate_fn},
splay_tree_allocate_fn @@var{node_allocate_fn},
splay_tree_deallocate_fn @@var{deallocate_fn},
@


1.18
log
@merge from gcc
@
text
@d47 1
a47 1
static int splay_tree_foreach_helper (splay_tree, splay_tree_node,
d207 1
a207 1
splay_tree_foreach_helper (splay_tree sp, splay_tree_node node,
d211 2
d214 27
a240 2
  if (!node)
    return 0;
d242 3
a244 7
  val = splay_tree_foreach_helper (sp, node->left, fn, data);
  if (val)
    return val;

  val = (*fn)(node, data);
  if (val)
    return val;
d246 5
a250 1
  return splay_tree_foreach_helper (sp, node->right, fn, data);
a252 1

d566 1
a566 1
  return splay_tree_foreach_helper (sp, sp->root, fn, data);
@


1.17
log
@merge from gcc
@
text
@d2 2
a3 1
   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d269 42
a310 2
  splay_tree sp = (splay_tree) (*allocate_fn) (sizeof (struct splay_tree_s),
                                               allocate_data);
d315 1
a315 1
  sp->allocate = allocate_fn;
d357 1
a357 1
      
d359 2
a360 2
              (*sp->allocate) (sizeof (struct splay_tree_node_s),
                               sp->allocate_data));
@


1.16
log
@merge from gcc
@
text
@d110 1
a110 1
   grandparents pointer to P.  */
d123 1
a123 1
   grandparents pointer to P.  */
@


1.15
log
@Update the address and phone number of the FSF organization.
@
text
@d41 4
a45 5
static splay_tree_node splay_tree_splay_helper (splay_tree,
						splay_tree_key,
						splay_tree_node*,
						splay_tree_node*,
						splay_tree_node*);
d109 2
a110 2
/* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent
   and grandparent, respectively, of NODE.  */
d112 2
a113 4
static splay_tree_node
splay_tree_splay_helper (splay_tree sp, splay_tree_key key,
                         splay_tree_node *node, splay_tree_node *parent,
                         splay_tree_node *grandparent)
d115 6
a120 5
  splay_tree_node *next;
  splay_tree_node n;
  int comparison;
  
  n = *node;
d122 2
a123 2
  if (!n)
    return *parent;
d125 8
a132 90
  comparison = (*sp->comp) (key, n->key);

  if (comparison == 0)
    /* We've found the target.  */
    next = 0;
  else if (comparison < 0)
    /* The target is to the left.  */
    next = &n->left;
  else 
    /* The target is to the right.  */
    next = &n->right;

  if (next)
    {
      /* Continue down the tree.  */
      n = splay_tree_splay_helper (sp, key, next, node, parent);

      /* The recursive call will change the place to which NODE
	 points.  */
      if (*node != n)
	return n;
    }

  if (!parent)
    /* NODE is the root.  We are done.  */
    return n;

  /* First, handle the case where there is no grandparent (i.e.,
     *PARENT is the root of the tree.)  */
  if (!grandparent) 
    {
      if (n == (*parent)->left)
	{
	  *node = n->right;
	  n->right = *parent;
	}
      else
	{
	  *node = n->left;
	  n->left = *parent;
	}
      *parent = n;
      return n;
    }

  /* Next handle the cases where both N and *PARENT are left children,
     or where both are right children.  */
  if (n == (*parent)->left && *parent == (*grandparent)->left)
    {
      splay_tree_node p = *parent;

      (*grandparent)->left = p->right;
      p->right = *grandparent;
      p->left = n->right;
      n->right = p;
      *grandparent = n;
      return n; 
    }
  else if  (n == (*parent)->right && *parent == (*grandparent)->right)
    {
      splay_tree_node p = *parent;

      (*grandparent)->right = p->left;
      p->left = *grandparent;
      p->right = n->left;
      n->left = p;
      *grandparent = n;
      return n;
    }

  /* Finally, deal with the case where N is a left child, but *PARENT
     is a right child, or vice versa.  */
  if (n == (*parent)->left) 
    {
      (*parent)->left = n->right;
      n->right = *parent;
      (*grandparent)->right = n->left;
      n->left = *grandparent;
      *grandparent = n;
      return n;
    } 
  else
    {
      (*parent)->right = n->left;
      n->left = *parent;
      (*grandparent)->left = n->right;
      n->right = *grandparent;
      *grandparent = n;
      return n;
    }
d135 1
a135 1
/* Splay SP around KEY.  */
d143 55
a197 2
  splay_tree_splay_helper (sp, key, &sp->root, 
			   /*grandparent=*/0, /*parent=*/0); 
@


1.14
log
@merge from gcc
@
text
@d19 2
a20 2
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
@


1.13
log
@merge from gcc
@
text
@d40 3
a42 6
static void splay_tree_delete_helper    PARAMS((splay_tree, 
						splay_tree_node));
static void splay_tree_splay            PARAMS((splay_tree,
						splay_tree_key));
static splay_tree_node splay_tree_splay_helper     
                                        PARAMS((splay_tree,
d46 3
a48 5
						splay_tree_node*));
static int splay_tree_foreach_helper    PARAMS((splay_tree,
					        splay_tree_node,
						splay_tree_foreach_fn,
						void*));
d53 1
a53 3
splay_tree_delete_helper (sp, node)
     splay_tree sp;
     splay_tree_node node;
d114 3
a116 6
splay_tree_splay_helper (sp, key, node, parent, grandparent)
     splay_tree sp;
     splay_tree_key key;
     splay_tree_node *node;
     splay_tree_node *parent;
     splay_tree_node *grandparent;
d222 1
a222 3
splay_tree_splay (sp, key)
     splay_tree sp;
     splay_tree_key key;
d237 2
a238 5
splay_tree_foreach_helper (sp, node, fn, data)
     splay_tree sp;
     splay_tree_node node;
     splay_tree_foreach_fn fn;
     void* data;
d259 1
a259 3
splay_tree_xmalloc_allocate (size, data)
     int size;
     void *data ATTRIBUTE_UNUSED;
d265 1
a265 3
splay_tree_xmalloc_deallocate (object, data)
     void *object;
     void *data ATTRIBUTE_UNUSED;
d277 3
a279 4
splay_tree_new (compare_fn, delete_key_fn, delete_value_fn)
     splay_tree_compare_fn compare_fn;
     splay_tree_delete_key_fn delete_key_fn;
     splay_tree_delete_value_fn delete_value_fn;
d292 6
a297 8
splay_tree_new_with_allocator (compare_fn, delete_key_fn, delete_value_fn,
                               allocate_fn, deallocate_fn, allocate_data)
     splay_tree_compare_fn compare_fn;
     splay_tree_delete_key_fn delete_key_fn;
     splay_tree_delete_value_fn delete_value_fn;
     splay_tree_allocate_fn allocate_fn;
     splay_tree_deallocate_fn deallocate_fn;
     void *allocate_data;
d315 1
a315 2
splay_tree_delete (sp)
     splay_tree sp;
d326 1
a326 4
splay_tree_insert (sp, key, value)
     splay_tree sp;
     splay_tree_key key;
     splay_tree_value value;
d378 1
a378 3
splay_tree_remove (sp, key)
     splay_tree sp;
     splay_tree_key key;
d418 1
a418 3
splay_tree_lookup (sp, key)
     splay_tree sp;
     splay_tree_key key;
d431 1
a431 2
splay_tree_max (sp)
     splay_tree sp;
d447 1
a447 2
splay_tree_min (sp)
     splay_tree sp;
d464 1
a464 3
splay_tree_predecessor (sp, key)
     splay_tree sp;
     splay_tree_key key;
d495 1
a495 3
splay_tree_successor (sp, key)
     splay_tree sp;
     splay_tree_key key;
d528 1
a528 4
splay_tree_foreach (sp, fn, data)
     splay_tree sp;
     splay_tree_foreach_fn fn;
     void *data;
d536 1
a536 3
splay_tree_compare_ints (k1, k2)
     splay_tree_key k1;
     splay_tree_key k2;
d549 1
a549 3
splay_tree_compare_pointers (k1, k2)
     splay_tree_key k1;
     splay_tree_key k2;
@


1.12
log
@merge from gcc
@
text
@d62 3
d68 24
a91 2
  splay_tree_delete_helper (sp, node->left);
  splay_tree_delete_helper (sp, node->right);
d93 14
a106 4
  if (sp->delete_key)
    (*sp->delete_key)(node->key);
  if (sp->delete_value)
    (*sp->delete_value)(node->value);
d108 7
a114 1
  (*sp->deallocate) ((char*) node, sp->allocate_data);
@


1.11
log
@merge from gcc
@
text
@d475 1
a475 1
  /* Otherwise, find the leftmost element of the right subtree.  */
d508 1
a508 1
  /* Otherwise, find the rightmost element of the left subtree.  */
@


1.11.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d475 1
a475 1
  /* Otherwise, find the rightmost element of the left subtree.  */
d508 1
a508 1
  /* Otherwise, find the leftmost element of the right subtree.  */
@


1.11.2.1
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d475 1
a475 1
  /* Otherwise, find the rightmost element of the left subtree.  */
d508 1
a508 1
  /* Otherwise, find the leftmost element of the right subtree.  */
@


1.11.24.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d475 1
a475 1
  /* Otherwise, find the rightmost element of the left subtree.  */
d508 1
a508 1
  /* Otherwise, find the leftmost element of the right subtree.  */
@


1.10
log
@merge from gcc
@
text
@d237 1
a237 1
  return xmalloc (size);
@


1.9
log
@* splay-tree.c (splay_tree_xmalloc_allocate,
splay_tree_xmalloc_deallocate): Use K&R-style definitions, not
prototyped definitions.  Mark `data' arguments as unused.
@
text
@d485 1
a485 1
   predecessor.  KEY need not be present in the tree.  */
d495 1
a495 1
  /* If the tree is empty, there is certainly no predecessor.  */
@


1.9.6.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d237 1
a237 1
  return (void *) xmalloc (size);
d485 1
a485 1
   successor.  KEY need not be present in the tree.  */
d495 1
a495 1
  /* If the tree is empty, there is certainly no successor.  */
@


1.8
log
@include:

Allow the user to specify functions for allocating memory for
splay tree roots and nodes.
* splay-tree.h (splay_tree_allocate_fn, splay_tree_deallocate_fn):
New types.
(splay_tree): New fields: `allocate', `deallocate', and
`allocate_data'.
(splay_tree_new_with_allocator): New function declaration.

libiberty:

* splay-tree.c (splay_tree_xmalloc_allocate,
splay_tree_xmalloc_deallocate): New functions.
(splay_tree_new): Call splay_tree_new_with_allocator, passing the
above functions and a dummy data pointer.
(splay_tree_new_with_allocator): New function.
(splay_tree_delete_helper, splay_tree_delete, splay_tree_insert,
splay_tree_remove): Use the splay tree's allocation and
deallocation functions.
@
text
@d233 3
a235 1
splay_tree_xmalloc_allocate (int size, void *data)
d241 3
a243 1
splay_tree_xmalloc_deallocate (void *object, void *data)
@


1.8.2.1
log
@From mainline: 2002-03-06  Jim Blandy  <jimb@@redhat.com>
* splay-tree.c (splay_tree_xmalloc_allocate,
splay_tree_xmalloc_deallocate): Use K&R-style definitions, not
prototyped definitions.  Mark `data' arguments as unused.
@
text
@d233 1
a233 3
splay_tree_xmalloc_allocate (size, data)
     int size;
     void *data ATTRIBUTE_UNUSED;
d239 1
a239 3
splay_tree_xmalloc_deallocate (object, data)
     void *object;
     void *data ATTRIBUTE_UNUSED;
@


1.7
log
@merge from gcc
@
text
@d73 1
a73 1
  free ((char*) node);
d230 32
d267 2
a268 1
splay_tree_new (compare_fn, delete_key_fn, delete_value_fn)
d272 3
d276 2
a277 1
  splay_tree sp = (splay_tree) xmalloc (sizeof (struct splay_tree_s));
d282 3
d296 1
a296 1
  free ((char*) sp);
d329 3
a331 1
      node = (splay_tree_node) xmalloc (sizeof (struct splay_tree_node_s));
d375 1
a375 1
      free (sp->root);
@


1.6
log
@merge from gcc repository
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
d369 34
@


1.5
log
@* splay-tree.c: #include <stdio.h>.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
d308 2
a309 2
    sp->root = node;
  }
d369 66
@


1.4
log
@        * splay-tree.c (splay_tree_remove): New.
@
text
@d35 2
@


1.3
log
@merge with libiberty from egcs 2000-02-22
@
text
@d312 41
@


1.2
log
@	* splay-tree.c (splay_tree_insert): Add initialization to avoid
	warning.
@
text
@d238 1
a238 1
  splay_tree sp = (splay_tree) xmalloc (sizeof (struct splay_tree));
d259 1
a259 1
   with the new value.  */
d261 1
a261 1
void 
d287 1
a287 1
      node = (splay_tree_node) xmalloc (sizeof (struct splay_tree_node));
d308 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1998 Free Software Foundation, Inc.
d267 1
a267 1
  int comparison;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.2
log
@import libiberty from egcs
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
d238 1
a238 1
  splay_tree sp = (splay_tree) xmalloc (sizeof (struct splay_tree_s));
d259 1
a259 1
   with the new value.  Returns the new node.  */
d261 1
a261 1
splay_tree_node
d267 1
a267 1
  int comparison = 0;
d287 1
a287 1
      node = (splay_tree_node) xmalloc (sizeof (struct splay_tree_node_s));
a307 2

  return sp->root;
@


