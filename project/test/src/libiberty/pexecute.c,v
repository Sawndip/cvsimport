head	1.17;
access;
symbols
	sid-snapshot-20180601:1.17
	sid-snapshot-20180501:1.17
	sid-snapshot-20180401:1.17
	sid-snapshot-20180301:1.17
	sid-snapshot-20180201:1.17
	sid-snapshot-20180101:1.17
	sid-snapshot-20171201:1.17
	sid-snapshot-20171101:1.17
	sid-snapshot-20171001:1.17
	sid-snapshot-20170901:1.17
	sid-snapshot-20170801:1.17
	sid-snapshot-20170701:1.17
	sid-snapshot-20170601:1.17
	sid-snapshot-20170501:1.17
	sid-snapshot-20170401:1.17
	sid-snapshot-20170301:1.17
	sid-snapshot-20170201:1.17
	sid-snapshot-20170101:1.17
	sid-snapshot-20161201:1.17
	sid-snapshot-20161101:1.17
	sid-snapshot-20160901:1.17
	sid-snapshot-20160801:1.17
	sid-snapshot-20160701:1.17
	sid-snapshot-20160601:1.17
	sid-snapshot-20160501:1.17
	sid-snapshot-20160401:1.17
	sid-snapshot-20160301:1.17
	sid-snapshot-20160201:1.17
	sid-snapshot-20160101:1.17
	sid-snapshot-20151201:1.17
	sid-snapshot-20151101:1.17
	sid-snapshot-20151001:1.17
	sid-snapshot-20150901:1.17
	sid-snapshot-20150801:1.17
	sid-snapshot-20150701:1.17
	sid-snapshot-20150601:1.17
	sid-snapshot-20150501:1.17
	sid-snapshot-20150401:1.17
	sid-snapshot-20150301:1.17
	sid-snapshot-20150201:1.17
	sid-snapshot-20150101:1.17
	sid-snapshot-20141201:1.17
	sid-snapshot-20141101:1.17
	sid-snapshot-20141001:1.17
	sid-snapshot-20140901:1.17
	sid-snapshot-20140801:1.17
	sid-snapshot-20140701:1.17
	sid-snapshot-20140601:1.17
	sid-snapshot-20140501:1.17
	sid-snapshot-20140401:1.17
	sid-snapshot-20140301:1.17
	sid-snapshot-20140201:1.17
	sid-snapshot-20140101:1.17
	sid-snapshot-20131201:1.17
	sid-snapshot-20131101:1.17
	sid-snapshot-20131001:1.17
	binutils-2_24-branch:1.17.0.82
	binutils-2_24-branchpoint:1.17
	binutils-2_21_1:1.17
	sid-snapshot-20130901:1.17
	gdb_7_6_1-2013-08-30-release:1.17
	sid-snapshot-20130801:1.17
	sid-snapshot-20130701:1.17
	sid-snapshot-20130601:1.17
	sid-snapshot-20130501:1.17
	gdb_7_6-2013-04-26-release:1.17
	sid-snapshot-20130401:1.17
	binutils-2_23_2:1.17
	gdb_7_6-branch:1.17.0.80
	gdb_7_6-2013-03-12-branchpoint:1.17
	sid-snapshot-20130301:1.17
	sid-snapshot-20130201:1.17
	sid-snapshot-20130101:1.17
	sid-snapshot-20121201:1.17
	gdb_7_5_1-2012-11-29-release:1.17
	binutils-2_23_1:1.17
	sid-snapshot-20121101:1.17
	binutils-2_23:1.17
	sid-snapshot-20121001:1.17
	sid-snapshot-20120901:1.17
	gdb_7_5-2012-08-17-release:1.17
	sid-snapshot-20120801:1.17
	binutils-2_23-branch:1.17.0.78
	binutils-2_23-branchpoint:1.17
	gdb_7_5-branch:1.17.0.76
	gdb_7_5-2012-07-18-branchpoint:1.17
	sid-snapshot-20120701:1.17
	sid-snapshot-20120601:1.17
	sid-snapshot-20120501:1.17
	binutils-2_22_branch:1.17.0.74
	gdb_7_4_1-2012-04-26-release:1.17
	sid-snapshot-20120401:1.17
	sid-snapshot-20120301:1.17
	sid-snapshot-20120201:1.17
	gdb_7_4-2012-01-24-release:1.17
	sid-snapshot-20120101:1.17
	gdb_7_4-branch:1.17.0.72
	gdb_7_4-2011-12-13-branchpoint:1.17
	sid-snapshot-20111201:1.17
	binutils-2_22:1.17
	sid-snapshot-20111101:1.17
	sid-snapshot-20111001:1.17
	binutils-2_22-branch:1.17.0.70
	binutils-2_22-branchpoint:1.17
	gdb_7_3_1-2011-09-04-release:1.17
	sid-snapshot-20110901:1.17
	sid-snapshot-20110801:1.17
	gdb_7_3-2011-07-26-release:1.17
	sid-snapshot-20110701:1.17
	sid-snapshot-20110601:1.17
	sid-snapshot-20110501:1.17
	gdb_7_3-branch:1.17.0.68
	gdb_7_3-2011-04-01-branchpoint:1.17
	sid-snapshot-20110401:1.17
	sid-snapshot-20110301:1.17
	cygwin-1_7_8-release:1.17
	sid-snapshot-20110201:1.17
	sid-snapshot-20110101:1.17
	binutils-2_21:1.17
	sid-snapshot-20101201:1.17
	binutils-2_21-branch:1.17.0.66
	binutils-2_21-branchpoint:1.17
	sid-snapshot-20101101:1.17
	sid-snapshot-20101001:1.17
	binutils-2_20_1:1.17
	gdb_7_2-2010-09-02-release:1.17
	sid-snapshot-20100901:1.17
	cygwin-1_7_7-release:1.17
	sid-snapshot-20100801:1.17
	gdb_7_2-branch:1.17.0.64
	gdb_7_2-2010-07-07-branchpoint:1.17
	sid-snapshot-20100701:1.17
	sid-snapshot-20100601:1.17
	sid-snapshot-20100501:1.17
	sid-snapshot-20100401:1.17
	gdb_7_1-2010-03-18-release:1.17
	sid-snapshot-20100301:1.17
	gdb_7_1-branch:1.17.0.62
	gdb_7_1-2010-02-18-branchpoint:1.17
	sid-snapshot-20100201:1.17
	sid-snapshot-20100101:1.17
	gdb_7_0_1-2009-12-22-release:1.17
	sid-snapshot-20091201:1.17
	sid-snapshot-20091101:1.17
	binutils-2_20:1.17
	gdb_7_0-2009-10-06-release:1.17
	sid-snapshot-20091001:1.17
	gdb_7_0-branch:1.17.0.60
	gdb_7_0-2009-09-16-branchpoint:1.17
	arc-sim-20090309:1.17
	binutils-arc-20081103-branch:1.17.0.58
	binutils-arc-20081103-branchpoint:1.17
	binutils-2_20-branch:1.17.0.56
	binutils-2_20-branchpoint:1.17
	sid-snapshot-20090901:1.17
	sid-snapshot-20090801:1.17
	msnyder-checkpoint-072509-branch:1.17.0.54
	msnyder-checkpoint-072509-branchpoint:1.17
	sid-snapshot-20090701:1.17
	dje-cgen-play1-branch:1.17.0.52
	dje-cgen-play1-branchpoint:1.17
	sid-snapshot-20090601:1.17
	sid-snapshot-20090501:1.17
	sid-snapshot-20090401:1.17
	arc-20081103-branch:1.17.0.50
	arc-20081103-branchpoint:1.17
	arc-insight_6_8-branch:1.17.0.48
	arc-insight_6_8-branchpoint:1.17
	insight_6_8-branch:1.17.0.46
	insight_6_8-branchpoint:1.17
	sid-snapshot-20090301:1.17
	binutils-2_19_1:1.17
	sid-snapshot-20090201:1.17
	sid-snapshot-20090101:1.17
	reverse-20081226-branch:1.17.0.44
	reverse-20081226-branchpoint:1.17
	sid-snapshot-20081201:1.17
	multiprocess-20081120-branch:1.17.0.42
	multiprocess-20081120-branchpoint:1.17
	sid-snapshot-20081101:1.17
	binutils-2_19:1.17
	sid-snapshot-20081001:1.17
	reverse-20080930-branch:1.17.0.40
	reverse-20080930-branchpoint:1.17
	binutils-2_19-branch:1.17.0.38
	binutils-2_19-branchpoint:1.17
	sid-snapshot-20080901:1.17
	sid-snapshot-20080801:1.17
	reverse-20080717-branch:1.17.0.36
	reverse-20080717-branchpoint:1.17
	sid-snapshot-20080701:1.17
	msnyder-reverse-20080609-branch:1.17.0.34
	msnyder-reverse-20080609-branchpoint:1.17
	drow-reverse-20070409-branch:1.17.0.32
	drow-reverse-20070409-branchpoint:1.17
	sid-snapshot-20080601:1.17
	sid-snapshot-20080501:1.17
	sid-snapshot-20080403:1.17
	sid-snapshot-20080401:1.17
	gdb_6_8-2008-03-27-release:1.17
	sid-snapshot-20080301:1.17
	gdb_6_8-branch:1.17.0.30
	gdb_6_8-2008-02-26-branchpoint:1.17
	sid-snapshot-20080201:1.17
	sid-snapshot-20080101:1.17
	sid-snapshot-20071201:1.17
	sid-snapshot-20071101:1.17
	gdb_6_7_1-2007-10-29-release:1.17
	gdb_6_7-2007-10-10-release:1.17
	sid-snapshot-20071001:1.17
	gdb_6_7-branch:1.17.0.28
	gdb_6_7-2007-09-07-branchpoint:1.17
	binutils-2_18:1.17
	binutils-2_18-branch:1.17.0.26
	binutils-2_18-branchpoint:1.17
	insight_6_6-20070208-release:1.17
	binutils-csl-coldfire-4_1-32:1.17
	binutils-csl-sourcerygxx-4_1-32:1.17
	gdb_6_6-2006-12-18-release:1.17
	binutils-csl-innovasic-fido-3_4_4-33:1.17
	binutils-csl-coldfire-4_1-30:1.17
	binutils-csl-sourcerygxx-4_1-30:1.17
	binutils-csl-coldfire-4_1-28:1.17
	binutils-csl-sourcerygxx-4_1-29:1.17
	binutils-csl-sourcerygxx-4_1-28:1.17
	gdb_6_6-branch:1.17.0.24
	gdb_6_6-2006-11-15-branchpoint:1.17
	binutils-csl-arm-2006q3-27:1.17
	binutils-csl-sourcerygxx-4_1-27:1.17
	binutils-csl-arm-2006q3-26:1.17
	binutils-csl-sourcerygxx-4_1-26:1.17
	binutils-csl-sourcerygxx-4_1-25:1.17
	binutils-csl-sourcerygxx-4_1-24:1.17
	binutils-csl-sourcerygxx-4_1-23:1.17
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	binutils-csl-sourcerygxx-4_1-21:1.17
	binutils-csl-arm-2006q3-21:1.17
	binutils-csl-sourcerygxx-4_1-22:1.17
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.17
	binutils-csl-sourcerygxx-4_1-20:1.17
	binutils-csl-arm-2006q3-19:1.17
	binutils-csl-sourcerygxx-4_1-19:1.17
	binutils-csl-sourcerygxx-4_1-18:1.17
	binutils-csl-renesas-4_1-9:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.15
	nickrob-async-20060828-mergepoint:1.17
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	binutils-csl-renesas-4_1-8:1.17
	binutils-csl-renesas-4_1-7:1.17
	binutils-csl-renesas-4_1-6:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17
	binutils-csl-sourcerygxx-4_1-17:1.17
	gdb-csl-20060226-branch-local-2:1.17
	cr-0x5f1:1.17.0.22
	gdb-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-15:1.17
	gdb-csl-sourcerygxx-4_1-13:1.17
	binutils-csl-sourcerygxx-4_1-13:1.17
	binutils-2_17:1.17
	gdb-csl-sourcerygxx-4_1-12:1.17
	binutils-csl-sourcerygxx-4_1-12:1.17
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	binutils-csl-sourcerygxx-3_4_4-21:1.17
	gdb_6_5-20060621-release:1.17
	gdb-csl-sourcerygxx-4_1-9:1.17
	binutils-csl-sourcerygxx-4_1-9:1.17
	gdb-csl-sourcerygxx-4_1-8:1.17
	binutils-csl-sourcerygxx-4_1-8:1.17
	gdb-csl-sourcerygxx-4_1-7:1.17
	binutils-csl-sourcerygxx-4_1-7:1.17
	gdb-csl-arm-2006q1-6:1.17
	binutils-csl-arm-2006q1-6:1.17
	gdb-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-sourcerygxx-4_1-6:1.17
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	binutils-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	binutils-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.17.0.20
	gdb_6_5-2006-05-14-branchpoint:1.17
	binutils-csl-coldfire-4_1-10:1.17
	gdb-csl-sourcerygxx-4_1-5:1.17
	binutils-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.17.0.18
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.17
	binutils-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.17.0.16
	msnyder-reverse-20060502-branchpoint:1.17
	gdb-csl-morpho-4_1-4:1.17
	binutils-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-sourcerygxx-3_4_4-17:1.17
	readline_5_1-import-branch:1.17.0.14
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	binutils-2_17-branch:1.17.0.12
	binutils-2_17-branchpoint:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.10
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.8
	msnyder-reverse-20060331-branchpoint:1.17
	binutils-csl-2_17-branch:1.17.0.6
	binutils-csl-2_17-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.4
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.2
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.15
	msnyder-fork-checkpoint-branch:1.15.0.8
	msnyder-fork-checkpoint-branchpoint:1.15
	gdb-csl-gxxpro-6_3-branch:1.15.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.15
	gdb_6_4-branch:1.15.0.4
	gdb_6_4-2005-11-01-branchpoint:1.15
	gdb-csl-arm-20051020-branch:1.15.0.2
	gdb-csl-arm-20051020-branchpoint:1.15
	msnyder-tracepoint-checkpoint-branch:1.14.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.14
	cagney-unwind-20030108-branch:1.10.0.26
	cagney-unwind-20030108-branchpoint:1.10
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	binutils-2_13_1:1.10
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.24
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.22
	carlton_dictionary-20020920-branchpoint:1.10
	sid-20020905-branchpoint:1.10
	sid-20020905-branch:1.10.0.20
	gdb_5_3-branch:1.10.0.18
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.16
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.14
	readline_4_3-import-branchpoint:1.10
	binutils-2_13:1.10
	gdb_5_2_1-2002-07-23-release:1.10
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.12
	kseitz_interps-20020528-branch:1.10.0.10
	kseitz_interps-20020528-branchpoint:1.10
	cagney_regbuf-20020515-branch:1.10.0.8
	cagney_regbuf-20020515-branchpoint:1.10
	binutils-2_12_1:1.10
	jimb-macro-020506-branch:1.10.0.6
	jimb-macro-020506-branchpoint:1.10
	gdb_5_2-2002-04-29-release:1.10
	binutils-2_12:1.10
	gdb_5_2-branch:1.10.0.4
	gdb_5_2-2002-03-03-branchpoint:1.10
	binutils-2_12-branch:1.10.0.2
	binutils-2_12-branchpoint:1.10
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.6
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.4
	gdb_5_1-2001-07-29-branchpoint:1.8
	binutils-2_11_2:1.8
	binutils-2_11_1:1.8
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	insight-precleanup-2001-01-01:1.8
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	cygwin-1_1_1:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.4
	gdb_5_0-2000-04-10-branchpoint:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	egcs_20000222:1.1.1.2
	binutils_latest_snapshot:1.17
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2006.02.21.02.38.06;	author dj;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.21.02.01.56;	author dj;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.12.10.35.00;	author dj;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.24.21.01.33;	author dj;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.10.15.33.33;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.29.02.15.22;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.24.21.31.35;	author dj;	state dead;
branches;
next	1.10;

1.10
date	2001.10.17.22.35.28;	author dj;	state Exp;
branches
	1.10.22.1
	1.10.24.1;
next	1.9;

1.9
date	2001.10.16.02.55.31;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.08.16.37.01;	author dj;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.12.02.16.48;	author dj;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.27.01.49.21;	author law;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.23.16.05.33;	author law;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.29.20.45.32;	author zack;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.22.16.14.35;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.08.03.16.00.39;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.54;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.10.22.1
date	2003.02.07.19.18.02;	author carlton;	state dead;
branches;
next	;

1.10.24.1
date	2003.12.14.20.28.03;	author drow;	state dead;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.54;	author rth;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.22.15.59.20;	author ian;	state Exp;
branches;
next	;


desc
@@


1.17
log
@merge from gcc
@
text
@/* Utilities to execute a program in a subprocess (possibly linked by pipes
   with other subprocesses), and wait for it.
   Copyright (C) 2004 Free Software Foundation, Inc.

This file is part of the libiberty library.
Libiberty is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

Libiberty is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libiberty; see the file COPYING.LIB.  If not,
write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */

/* pexecute is an old routine.  This implementation uses the newer
   pex_init/pex_run/pex_get_status/pex_free routines.  Don't use
   pexecute in new code.  Use the newer routines instead.  */

#include "config.h"
#include "libiberty.h"

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

/* We only permit a single pexecute chain to execute at a time.  This
   was always true anyhow, though it wasn't documented.  */

static struct pex_obj *pex;
static int idx;

int
pexecute (const char *program, char * const *argv, const char *pname,
	  const char *temp_base, char **errmsg_fmt, char **errmsg_arg,
	  int flags)
{
  const char *errmsg;
  int err;

  if ((flags & PEXECUTE_FIRST) != 0)
    {
      if (pex != NULL)
	{
	  *errmsg_fmt = (char *) "pexecute already in progress";
	  *errmsg_arg = NULL;
	  return -1;
	}
      pex = pex_init (PEX_USE_PIPES, pname, temp_base);
      idx = 0;
    }
  else
    {
      if (pex == NULL)
	{
	  *errmsg_fmt = (char *) "pexecute not in progress";
	  *errmsg_arg = NULL;
	  return -1;
	}
    }

  errmsg = pex_run (pex,
		    (((flags & PEXECUTE_LAST) != 0 ? PEX_LAST : 0)
		     | ((flags & PEXECUTE_SEARCH) != 0 ? PEX_SEARCH : 0)),
		    program, argv, NULL, NULL, &err);
  if (errmsg != NULL)
    {
      *errmsg_fmt = (char *) errmsg;
      *errmsg_arg = NULL;
      return -1;
    }

  /* Instead of a PID, we just return a one-based index into the
     status values.  We avoid zero just because the old pexecute would
     never return it.  */
  return ++idx;
}

int
pwait (int pid, int *status, int flags ATTRIBUTE_UNUSED)
{
  /* The PID returned by pexecute is one-based.  */
  --pid;

  if (pex == NULL || pid < 0 || pid >= idx)
    return -1;

  if (pid == 0 && idx == 1)
    {
      if (!pex_get_status (pex, 1, status))
	return -1;
    }
  else
    {
      int *vector;

      vector = XNEWVEC (int, idx);
      if (!pex_get_status (pex, idx, vector))
	{
	  free (vector);
	  return -1;
	}
      *status = vector[pid];
      free (vector);
    }

  /* Assume that we are done after the caller has retrieved the last
     exit status.  The original implementation did not require that
     the exit statuses be retrieved in order, but this implementation
     does.  */
  if (pid + 1 == idx)
    {
      pex_free (pex);
      pex = NULL;
      idx = 0;
    }

  return pid + 1;
}
@


1.16
log
@merge from gcc
@
text
@d105 1
a105 1
	  free (vector)
@


1.15
log
@merge from gcc
@
text
@d104 4
a107 1
	return -1;
@


1.14
log
@merge from gcc
@
text
@d50 1
a50 1
	  *errmsg_fmt = "pexecute already in progress";
d61 1
a61 1
	  *errmsg_fmt = "pexecute not in progress";
@


1.13
log
@Update the address and phone number of the FSF organization.
@
text
@d102 1
a102 1
      vector = xmalloc (idx * sizeof (int));
@


1.12
log
@libiberty:
	* pex-common.c: New file.
	* pex-one.c: New file.
	* pexecute.c: New file.
	* pex-common.h: Include <stdio.h>.
	(struct pex_obj): Define.
	(struct pex_funcs): Define.
	(pex_init_common): Declare.
	* pex-unix.c: Rewrite.
	* pex-win32.c: Rewrite.
	* pex-djgpp.c: Rewrite.
	* pex-msdos.c: Rewrite.
	* testsuite/text-pexecute.c: New file.
	* pexecute.txh: Rewrite.
	* configure.ac: Check for wait3 and wait4.  Set CHECK to
	really-check rather than check-cplus-dem.
	* functions.texi: Rebuild.
	* Makefile.in: Rebuild dependencies.
	(CFILES): Add pexecute.c, pex-common.c, pex-one.c.
	(REQUIRED_OFILES): Add pexecute.o, pex-common.o, pex-one.o.
	* testsuite/Makefile.in (really-check): New target.
	(check-pexecute, test-pexecute): New targets.
	* configure: Rebuild.
include:
	* libiberty.h: Include <stdio.h>.
	(PEX_RECORD_TIMES, PEX_USE_PIPES, PEX_SAVE_TEMPS): Define.
	(PEX_LAST, PEX_SEARCH, PEX_SUFFIX, PEX_STDERR_TO_STDOUT): Define.
	(PEX_BINARY_INPUT, PEX_BINARY_OUTPUT): Define.
	(pex_init, pex_run, pex_read_output): Declare.
	(pex_get_status, pex_get_times, pex_free, pex_one): Declare.
	(struct pex_time): Define.
@
text
@d18 2
a19 2
write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
@


1.11
log
@merge from gcc
@
text
@d3 1
a3 1
   Copyright (C) 1996-2000 Free Software Foundation, Inc.
d21 3
a23 1
/* This file exports two functions: pexecute and pwait.  */
a24 4
/* This file lives in at least two places: libiberty and gcc.
   Don't change one without the other.  */

#ifdef HAVE_CONFIG_H
d26 1
a26 1
#endif
a27 11
#include <stdio.h>
#include <errno.h>
#ifdef NEED_DECLARATION_ERRNO
extern int errno;
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
a30 57
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#include "libiberty.h"
#include "safe-ctype.h"

/* stdin file number.  */
#define STDIN_FILE_NO 0

/* stdout file number.  */
#define STDOUT_FILE_NO 1

/* value of `pipe': port index for reading.  */
#define READ_PORT 0

/* value of `pipe': port index for writing.  */
#define WRITE_PORT 1

static char *install_error_msg = "installation problem, cannot exec `%s'";

/* pexecute: execute a program.

@@deftypefn Extension int pexecute (const char *@@var{program}, char * const *@@var{argv}, const char *@@var{this_pname}, const char *@@var{temp_base}, char **@@var{errmsg_fmt}, char **@@var{errmsg_arg}, int flags)

Executes a program.

@@var{program} and @@var{argv} are the arguments to
@@code{execv}/@@code{execvp}.

@@var{this_pname} is name of the calling program (i.e., @@code{argv[0]}).

@@var{temp_base} is the path name, sans suffix, of a temporary file to
use if needed.  This is currently only needed for MS-DOS ports that
don't use @@code{go32} (do any still exist?).  Ports that don't need it
can pass @@code{NULL}.

(@@code{@@var{flags} & PEXECUTE_SEARCH}) is non-zero if @@env{PATH} should be searched
(??? It's not clear that GCC passes this flag correctly).  (@@code{@@var{flags} &
PEXECUTE_FIRST}) is nonzero for the first process in chain.
(@@code{@@var{flags} & PEXECUTE_FIRST}) is nonzero for the last process
in chain.  The first/last flags could be simplified to only mark the
last of a chain of processes but that requires the caller to always
mark the last one (and not give up early if some error occurs).
It's more robust to require the caller to mark both ends of the chain.

The result is the pid on systems like Unix where we
@@code{fork}/@@code{exec} and on systems like WIN32 and OS/2 where we
use @@code{spawn}.  It is up to the caller to wait for the child.

The result is the @@code{WEXITSTATUS} on systems like MS-DOS where we
@@code{spawn} and wait for the child here.

Upon failure, @@var{errmsg_fmt} and @@var{errmsg_arg} are set to the
text of the error message with an optional argument (if not needed,
@@var{errmsg_arg} is set to @@code{NULL}), and @@minus{}1 is returned.
@@code{errno} is available to the caller to use.
d32 2
a33 1
@@end deftypefn
d35 2
a36 37
@@deftypefn Extension int pwait (int @@var{pid}, int *@@var{status}, int @@var{flags})

Waits for a program started by @@code{pexecute} to finish.

@@var{pid} is the process id of the task to wait for. @@var{status} is
the `status' argument to wait. @@var{flags} is currently unused (allows
future enhancement without breaking upward compatibility).  Pass 0 for now.

The result is the pid of the child reaped, or -1 for failure
(@@code{errno} says why).

On systems that don't support waiting for a particular child, @@var{pid} is
ignored.  On systems like MS-DOS that don't really multitask @@code{pwait}
is just a mechanism to provide a consistent interface for the caller.

@@end deftypefn

@@undocumented pfinish

   pfinish: finish generation of script

   pfinish is necessary for systems like MPW where a script is generated that
   runs the requested programs.  */

#ifdef __MSDOS__

/* MSDOS doesn't multitask, but for the sake of a consistent interface
   the code behaves like it does.  pexecute runs the program, tucks the
   exit code away, and returns a "pid".  pwait must be called to fetch the
   exit code.  */

#include <process.h>

/* For communicating information from pexecute to pwait.  */
static int last_pid = 0;
static int last_status = 0;
static int last_reaped = 0;
d39 3
a41 7
pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
     const char *program;
     char * const *argv;
     const char *this_pname;
     const char *temp_base;
     char **errmsg_fmt, **errmsg_arg;
     int flags;
d43 2
a44 1
  int rc;
d46 1
a46 23
  last_pid++;
  if (last_pid < 0)
    last_pid = 1;

  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)
    abort ();

#ifdef __DJGPP__
  /* ??? What are the possible return values from spawnv?  */
  rc = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (P_WAIT, program, argv);
#else
  char *scmd, *rf;
  FILE *argfile;
  int i, el = flags & PEXECUTE_SEARCH ? 4 : 0;

  if (temp_base == 0)
    temp_base = choose_temp_base ();
  scmd = (char *) xmalloc (strlen (program) + strlen (temp_base) + 6 + el);
  rf = scmd + strlen(program) + 2 + el;
  sprintf (scmd, "%s%s @@%s.gp", program,
	   (flags & PEXECUTE_SEARCH ? ".exe" : ""), temp_base);
  argfile = fopen (rf, "w");
  if (argfile == 0)
d48 1
a48 12
      int errno_save = errno;
      free (scmd);
      errno = errno_save;
      *errmsg_fmt = "cannot open `%s.gp'";
      *errmsg_arg = temp_base;
      return -1;
    }

  for (i=1; argv[i]; i++)
    {
      char *cp;
      for (cp = argv[i]; *cp; cp++)
d50 3
a52 3
	  if (*cp == '"' || *cp == '\'' || *cp == '\\' || ISSPACE (*cp))
	    fputc ('\\', argfile);
	  fputc (*cp, argfile);
d54 2
a55 1
      fputc ('\n', argfile);
d57 1
a57 13
  fclose (argfile);

  rc = system (scmd);

  {
    int errno_save = errno;
    remove (rf);
    free (scmd);
    errno = errno_save;
  }
#endif

  if (rc == -1)
d59 1
a59 182
      *errmsg_fmt = install_error_msg;
      *errmsg_arg = (char *)program;
      return -1;
    }

  /* Tuck the status away for pwait, and return a "pid".  */
  last_status = rc << 8;
  return last_pid;
}

/* Use ECHILD if available, otherwise use EINVAL.  */
#ifdef ECHILD
#define PWAIT_ERROR ECHILD
#else
#define PWAIT_ERROR EINVAL
#endif

int
pwait (pid, status, flags)
     int pid;
     int *status;
     int flags;
{
  /* On MSDOS each pexecute must be followed by it's associated pwait.  */
  if (pid != last_pid
      /* Called twice for the same child?  */
      || pid == last_reaped)
    {
      errno = PWAIT_ERROR;
      return -1;
    }
  /* ??? Here's an opportunity to canonicalize the values in STATUS.
     Needed?  */
#ifdef __DJGPP__
  *status = (last_status >> 8);
#else
  *status = last_status;
#endif
  last_reaped = last_pid;
  return last_pid;
}

#endif /* MSDOS */

#if defined (_WIN32) && ! defined (_UWIN)

#include <process.h>

#ifdef __CYGWIN__

#define fix_argv(argvec) (argvec)

extern int _spawnv ();
extern int _spawnvp ();

#else /* ! __CYGWIN__ */

/* This is a kludge to get around the Microsoft C spawn functions' propensity
   to remove the outermost set of double quotes from all arguments.  */

static const char * const *
fix_argv (argvec)
     char **argvec;
{
  int i;

  for (i = 1; argvec[i] != 0; i++)
    {
      int len, j;
      char *temp, *newtemp;

      temp = argvec[i];
      len = strlen (temp);
      for (j = 0; j < len; j++)
        {
          if (temp[j] == '"')
            {
              newtemp = xmalloc (len + 2);
              strncpy (newtemp, temp, j);
              newtemp [j] = '\\';
              strncpy (&newtemp [j+1], &temp [j], len-j);
              newtemp [len+1] = 0;
              temp = newtemp;
              len++;
              j++;
            }
        }

        argvec[i] = temp;
      }

  for (i = 0; argvec[i] != 0; i++)
    {
      if (strpbrk (argvec[i], " \t"))
        {
	  int len, trailing_backslash;
	  char *temp;

	  len = strlen (argvec[i]);
	  trailing_backslash = 0;

	  /* There is an added complication when an arg with embedded white
	     space ends in a backslash (such as in the case of -iprefix arg
	     passed to cpp). The resulting quoted strings gets misinterpreted
	     by the command interpreter -- it thinks that the ending quote
	     is escaped by the trailing backslash and things get confused. 
	     We handle this case by escaping the trailing backslash, provided
	     it was not escaped in the first place.  */
	  if (len > 1 
	      && argvec[i][len-1] == '\\' 
	      && argvec[i][len-2] != '\\')
	    {
	      trailing_backslash = 1;
	      ++len;			/* to escape the final backslash. */
	    }

	  len += 2;			/* and for the enclosing quotes. */

	  temp = xmalloc (len + 1);
	  temp[0] = '"';
	  strcpy (temp + 1, argvec[i]);
	  if (trailing_backslash)
	    temp[len-2] = '\\';
	  temp[len-1] = '"';
	  temp[len] = '\0';

	  argvec[i] = temp;
	}
    }

  return (const char * const *) argvec;
}
#endif /* __CYGWIN__ */

#include <io.h>
#include <fcntl.h>
#include <signal.h>

/* mingw32 headers may not define the following.  */

#ifndef _P_WAIT
#  define _P_WAIT	0
#  define _P_NOWAIT	1
#  define _P_OVERLAY	2
#  define _P_NOWAITO	3
#  define _P_DETACH	4

#  define WAIT_CHILD	0
#  define WAIT_GRANDCHILD	1
#endif

/* Win32 supports pipes */
int
pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
     const char *program;
     char * const *argv;
     const char *this_pname;
     const char *temp_base;
     char **errmsg_fmt, **errmsg_arg;
     int flags;
{
  int pid;
  int pdes[2], org_stdin, org_stdout;
  int input_desc, output_desc;
  int retries, sleep_interval;

  /* Pipe waiting from last process, to be used as input for the next one.
     Value is STDIN_FILE_NO if no pipe is waiting
     (i.e. the next command is the first of a group).  */
  static int last_pipe_input;

  /* If this is the first process, initialize.  */
  if (flags & PEXECUTE_FIRST)
    last_pipe_input = STDIN_FILE_NO;

  input_desc = last_pipe_input;

  /* If this isn't the last process, make a pipe for its output,
     and record it as waiting to be the input to the next process.  */
  if (! (flags & PEXECUTE_LAST))
    {
      if (_pipe (pdes, 256, O_BINARY) < 0)
d61 1
a61 1
	  *errmsg_fmt = "pipe";
a64 8
      output_desc = pdes[WRITE_PORT];
      last_pipe_input = pdes[READ_PORT];
    }
  else
    {
      /* Last process.  */
      output_desc = STDOUT_FILE_NO;
      last_pipe_input = STDIN_FILE_NO;
d67 5
a71 1
  if (input_desc != STDIN_FILE_NO)
d73 2
a74 31
      org_stdin = dup (STDIN_FILE_NO);
      dup2 (input_desc, STDIN_FILE_NO);
      close (input_desc); 
    }

  if (output_desc != STDOUT_FILE_NO)
    {
      org_stdout = dup (STDOUT_FILE_NO);
      dup2 (output_desc, STDOUT_FILE_NO);
      close (output_desc);
    }

  pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)
    (_P_NOWAIT, program, fix_argv(argv));

  if (input_desc != STDIN_FILE_NO)
    {
      dup2 (org_stdin, STDIN_FILE_NO);
      close (org_stdin);
    }

  if (output_desc != STDOUT_FILE_NO)
    {
      dup2 (org_stdout, STDOUT_FILE_NO);
      close (org_stdout);
    }

  if (pid == -1)
    {
      *errmsg_fmt = install_error_msg;
      *errmsg_arg = program;
d78 4
a81 1
  return pid;
a83 7
/* MS CRTDLL doesn't return enough information in status to decide if the
   child exited due to a signal or not, rather it simply returns an
   integer with the exit code of the child; eg., if the child exited with 
   an abort() call and didn't have a handler for SIGABRT, it simply returns
   with status = 3. We fix the status code to conform to the usual WIF*
   macros. Note that WIFSIGNALED will never be true under CRTDLL. */

d85 1
a85 4
pwait (pid, status, flags)
     int pid;
     int *status;
     int flags;
d87 2
a88 24
#ifdef __CYGWIN__
  return wait (status);
#else
  int termstat;

  pid = _cwait (&termstat, pid, WAIT_CHILD);

  /* ??? Here's an opportunity to canonicalize the values in STATUS.
     Needed?  */

  /* cwait returns the child process exit code in termstat.
     A value of 3 indicates that the child caught a signal, but not
     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we
     report SIGABRT.  */
  if (termstat == 3)
    *status = SIGABRT;
  else
    *status = (((termstat) & 0xff) << 8);

  return pid;
#endif /* __CYGWIN__ */
}

#endif /* _WIN32 && ! _UWIN */
d90 2
a91 1
#ifdef OS2
d93 1
a93 20
/* ??? Does OS2 have process.h?  */
extern int spawnv ();
extern int spawnvp ();

int
pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
     const char *program;
     char * const *argv;
     const char *this_pname;
     const char *temp_base;
     char **errmsg_fmt, **errmsg_arg;
     int flags;
{
  int pid;

  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)
    abort ();
  /* ??? Presumably 1 == _P_NOWAIT.  */
  pid = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (1, program, argv);
  if (pid == -1)
d95 2
a96 200
      *errmsg_fmt = install_error_msg;
      *errmsg_arg = program;
      return -1;
    }
  return pid;
}

int
pwait (pid, status, flags)
     int pid;
     int *status;
     int flags;
{
  /* ??? Here's an opportunity to canonicalize the values in STATUS.
     Needed?  */
  int pid = wait (status);
  return pid;
}

#endif /* OS2 */

#ifdef MPW

/* MPW pexecute doesn't actually run anything; instead, it writes out
   script commands that, when run, will do the actual executing.

   For example, in GCC's case, GCC will write out several script commands:

   cpp ...
   cc1 ...
   as ...
   ld ...

   and then exit.  None of the above programs will have run yet.  The task
   that called GCC will then execute the script and cause cpp,etc. to run.
   The caller must invoke pfinish before calling exit.  This adds
   the finishing touches to the generated script.  */

static int first_time = 1;

int
pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
     const char *program;
     char * const *argv;
     const char *this_pname;
     const char *temp_base;
     char **errmsg_fmt, **errmsg_arg;
     int flags;
{
  char tmpprogram[255];
  char *cp, *tmpname;
  int i;

  mpwify_filename (program, tmpprogram);
  if (first_time)
    {
      printf ("Set Failed 0\n");
      first_time = 0;
    }

  fputs ("If {Failed} == 0\n", stdout);
  /* If being verbose, output a copy of the command.  It should be
     accurate enough and escaped enough to be "clickable".  */
  if (flags & PEXECUTE_VERBOSE)
    {
      fputs ("\tEcho ", stdout);
      fputc ('\'', stdout);
      fputs (tmpprogram, stdout);
      fputc ('\'', stdout);
      fputc (' ', stdout);
      for (i=1; argv[i]; i++)
	{
	  fputc ('\'', stdout);
	  /* See if we have an argument that needs fixing.  */
	  if (strchr(argv[i], '/'))
	    {
	      tmpname = (char *) xmalloc (256);
	      mpwify_filename (argv[i], tmpname);
	      argv[i] = tmpname;
	    }
	  for (cp = argv[i]; *cp; cp++)
	    {
	      /* Write an Option-d escape char in front of special chars.  */
	      if (strchr("'+", *cp))
		fputc ('\266', stdout);
	      fputc (*cp, stdout);
	    }
	  fputc ('\'', stdout);
	  fputc (' ', stdout);
	}
      fputs ("\n", stdout);
    }
  fputs ("\t", stdout);
  fputs (tmpprogram, stdout);
  fputc (' ', stdout);

  for (i=1; argv[i]; i++)
    {
      /* See if we have an argument that needs fixing.  */
      if (strchr(argv[i], '/'))
	{
	  tmpname = (char *) xmalloc (256);
	  mpwify_filename (argv[i], tmpname);
	  argv[i] = tmpname;
	}
      if (strchr (argv[i], ' '))
	fputc ('\'', stdout);
      for (cp = argv[i]; *cp; cp++)
	{
	  /* Write an Option-d escape char in front of special chars.  */
	  if (strchr("'+", *cp))
	    fputc ('\266', stdout);
	  fputc (*cp, stdout);
	}
      if (strchr (argv[i], ' '))
	fputc ('\'', stdout);
      fputc (' ', stdout);
    }

  fputs ("\n", stdout);

  /* Output commands that arrange to clean up and exit if a failure occurs.
     We have to be careful to collect the status from the program that was
     run, rather than some other script command.  Also, we don't exit
     immediately, since necessary cleanups are at the end of the script.  */
  fputs ("\tSet TmpStatus {Status}\n", stdout);
  fputs ("\tIf {TmpStatus} != 0\n", stdout);
  fputs ("\t\tSet Failed {TmpStatus}\n", stdout);
  fputs ("\tEnd\n", stdout);
  fputs ("End\n", stdout);

  /* We're just composing a script, can't fail here.  */
  return 0;
}

int
pwait (pid, status, flags)
     int pid;
     int *status;
     int flags;
{
  *status = 0;
  return 0;
}

/* Write out commands that will exit with the correct error code
   if something in the script failed.  */

void
pfinish ()
{
  printf ("\tExit \"{Failed}\"\n");
}

#endif /* MPW */

/* include for Unix-like environments but not for Dos-like environments */
#if ! defined (__MSDOS__) && ! defined (OS2) && ! defined (MPW) \
    && ! (defined (_WIN32) && ! defined (_UWIN))

extern int execv ();
extern int execvp ();

int
pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
     const char *program;
     char * const *argv;
     const char *this_pname;
     const char *temp_base ATTRIBUTE_UNUSED;
     char **errmsg_fmt, **errmsg_arg;
     int flags;
{
  int (*func)() = (flags & PEXECUTE_SEARCH ? execvp : execv);
  int pid;
  int pdes[2];
  int input_desc, output_desc;
  int retries, sleep_interval;
  /* Pipe waiting from last process, to be used as input for the next one.
     Value is STDIN_FILE_NO if no pipe is waiting
     (i.e. the next command is the first of a group).  */
  static int last_pipe_input;

  /* If this is the first process, initialize.  */
  if (flags & PEXECUTE_FIRST)
    last_pipe_input = STDIN_FILE_NO;

  input_desc = last_pipe_input;

  /* If this isn't the last process, make a pipe for its output,
     and record it as waiting to be the input to the next process.  */
  if (! (flags & PEXECUTE_LAST))
    {
      if (pipe (pdes) < 0)
	{
	  *errmsg_fmt = "pipe";
	  *errmsg_arg = NULL;
	  return -1;
	}
      output_desc = pdes[WRITE_PORT];
      last_pipe_input = pdes[READ_PORT];
d100 1
a100 4
      /* Last process.  */
      output_desc = STDOUT_FILE_NO;
      last_pipe_input = STDIN_FILE_NO;
    }
d102 5
a106 10
  /* Fork a subprocess; wait and retry if it fails.  */
  sleep_interval = 1;
  pid = -1;
  for (retries = 0; retries < 4; retries++)
    {
      pid = fork ();
      if (pid >= 0)
	break;
      sleep (sleep_interval);
      sleep_interval *= 2;
d109 5
a113 1
  switch (pid)
d115 3
a117 44
    case -1:
      *errmsg_fmt = "fork";
      *errmsg_arg = NULL;
      return -1;

    case 0: /* child */
      /* Move the input and output pipes into place, if necessary.  */
      if (input_desc != STDIN_FILE_NO)
	{
	  close (STDIN_FILE_NO);
	  dup (input_desc);
	  close (input_desc);
	}
      if (output_desc != STDOUT_FILE_NO)
	{
	  close (STDOUT_FILE_NO);
	  dup (output_desc);
	  close (output_desc);
	}

      /* Close the parent's descs that aren't wanted here.  */
      if (last_pipe_input != STDIN_FILE_NO)
	close (last_pipe_input);

      /* Exec the program.  */
      (*func) (program, argv);

      fprintf (stderr, "%s: ", this_pname);
      fprintf (stderr, install_error_msg, program);
      fprintf (stderr, ": %s\n", xstrerror (errno));
      exit (-1);
      /* NOTREACHED */
      return 0;

    default:
      /* In the parent, after forking.
	 Close the descriptors that we made for this child.  */
      if (input_desc != STDIN_FILE_NO)
	close (input_desc);
      if (output_desc != STDOUT_FILE_NO)
	close (output_desc);

      /* Return child's process number.  */
      return pid;
a118 1
}
d120 1
a120 14
int
pwait (pid, status, flags)
     int pid;
     int *status;
     int flags ATTRIBUTE_UNUSED;
{
  /* ??? Here's an opportunity to canonicalize the values in STATUS.
     Needed?  */
#ifdef VMS
  pid = waitpid (-1, status, 0);
#else
  pid = wait (status);
#endif
  return pid;
a121 2

#endif /* ! __MSDOS__ && ! OS2 && ! MPW && ! (_WIN32 && ! _UWIN) */
@


1.10
log
@merge from gcc
@
text
@@


1.10.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.10.22.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@@


1.9
log
@merge from gcc
@
text
@d74 1
a74 1
@@var{this_pname} is name of the calling program (i.e. @@code{argv[0]}).
d81 4
a84 4
(@@var{flags} & @@code{PEXECUTE_SEARCH}) is non-zero if @@code{$PATH} should be searched
(??? It's not clear that GCC passes this flag correctly). (@@var{flags} &
@@code{PEXECUTE_FIRST}) is nonzero for the first process in chain.
(@@var{flags} & @@code{PEXECUTE_FIRST}) is nonzero for the last process
d94 1
a94 1
The result is the WEXITSTATUS on systems like MS-DOS where we
d99 1
a99 1
@@var{errmsg_arg} is set to @@code{NULL}), and -1 is returned.
@


1.8
log
@* safe-ctype.c: New file.
* Makefile.in (CFILES): Add safe-ctype.c.
(REQUIRED_OFILES): Add safe-ctype.o.

* argv.c: Define ISBLANK and use it, not isspace.
* basename.c, cplus-dem.c, fnmatch.c, pexecute.c, strtod.c,
strtol.c, strtoul.c: Include safe-ctype.h, not ctype.h.  Use
uppercase ctype macros.  Don't test ISUPPER(c)/ISLOWER(c)
before calling TOLOWER(c)/TOUPPER(c).
@
text
@d67 1
a67 1
   PROGRAM and ARGV are the arguments to execv/execvp.
d69 1
a69 1
   THIS_PNAME is name of the calling program (i.e. argv[0]).
d71 51
a121 37
   TEMP_BASE is the path name, sans suffix, of a temporary file to use
   if needed.  This is currently only needed for MSDOS ports that don't use
   GO32 (do any still exist?).  Ports that don't need it can pass NULL.

   (FLAGS & PEXECUTE_SEARCH) is non-zero if $PATH should be searched
   (??? It's not clear that GCC passes this flag correctly).
   (FLAGS & PEXECUTE_FIRST) is nonzero for the first process in chain.
   (FLAGS & PEXECUTE_FIRST) is nonzero for the last process in chain.
   FIRST_LAST could be simplified to only mark the last of a chain of processes
   but that requires the caller to always mark the last one (and not give up
   early if some error occurs).  It's more robust to require the caller to
   mark both ends of the chain.

   The result is the pid on systems like Unix where we fork/exec and on systems
   like WIN32 and OS2 where we use spawn.  It is up to the caller to wait for
   the child.

   The result is the WEXITSTATUS on systems like MSDOS where we spawn and wait
   for the child here.

   Upon failure, ERRMSG_FMT and ERRMSG_ARG are set to the text of the error
   message with an optional argument (if not needed, ERRMSG_ARG is set to
   NULL), and -1 is returned.  `errno' is available to the caller to use.

   pwait: cover function for wait.

   PID is the process id of the task to wait for.
   STATUS is the `status' argument to wait.
   FLAGS is currently unused (allows future enhancement without breaking
   upward compatibility).  Pass 0 for now.

   The result is the pid of the child reaped,
   or -1 for failure (errno says why).

   On systems that don't support waiting for a particular child, PID is
   ignored.  On systems like MSDOS that don't really multitask pwait
   is just a mechanism to provide a consistent interface for the caller.
d126 1
a126 2
   runs the requested programs.
*/
d270 1
a270 1
const char * const *
@


1.7
log
@merge from gcc repository
@
text
@a43 1
#define ISSPACE (x) isspace(x)
d49 1
@


1.6
log
@        * pexecute.c (pexecute) [__MSDOS__]: Change __GO32__ to
        __DJGPP__. Use P_WAIT instead of constant in the spawnv* call.
        Cast program to 'char *' in errmsg_arg assignment.
        (PWAIT_ERROR): Define.
	(pwait): Use PWAIT_ERROR.  Adjust DJGPP's status code to conform
        to DJGPP's WIF* macros.
@
text
@a48 13
#ifdef vfork /* Autoconf may define this to fork for us. */
# define VFORK_STRING "fork"
#else
# define VFORK_STRING "vfork"
#endif
#ifdef HAVE_VFORK_H
#include <vfork.h>
#endif
#ifdef VMS
#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \
               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
#endif /* VMS */

d704 1
d707 1
a707 1
      pid = vfork ();
d717 3
a719 5
      {
	*errmsg_fmt = VFORK_STRING;
	*errmsg_arg = NULL;
	return -1;
      }
a742 1
      /* Note: Calling fprintf and exit here doesn't seem right for vfork.  */
@


1.5
log
@	* aclocal.m4 (libiberty_AC_DECLARE_ERRNO): New macro.
	* configure.in (libiberty_AC_DECLARE_ERRNO): Add check.
	* configure, config.in: Regenerate.
	* pexecute.c, strtol.c, strtoul.c: Declare errno if necessary.
@
text
@d160 1
a160 1
#ifdef __GO32__
d162 1
a162 1
  rc = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (1, program, argv);
d211 1
a211 1
      *errmsg_arg = program;
d220 7
d238 1
a238 2
      /* ??? ECHILD would be a better choice.  Can we use it here?  */
      errno = EINVAL;
d243 3
d247 1
@


1.4
log
@	* hashtab.c, partition.c, xmemdup.c: Include string.h
	if HAVE_STRING_H.
	* pexecute.c, xexit.c: Include stdlib.h if HAVE_STDLIB_H.
	* objalloc.c: Include config.h.  Include stdlib.h and don't
	declare malloc or free if HAVE_STDLIB_H.
	* strerror.c, strsignal.c: Include stdlib.h if HAVE_STDLIB_H,
	else declare malloc without prototype.  Include string.h if
	HAVE_STRING_H, else declare memset without prototype.  Don't
	include stddef.h.

	* sort.c: Bring over from GCC.
@
text
@d32 3
@


1.3
log
@merge with libiberty from egcs 2000-02-22
@
text
@d38 3
@


1.2
log
@	* floatformat.c: Add casts to avoid signed/unsigned warnings.
	* pexecute.c: Add ATTRIBUTE_UNUSED as needed on Unix.
@
text
@d3 1
a3 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
d32 3
a57 4
#if !defined (__CYGWIN__) && defined (__CYGWIN32__)
#define __CYGWIN__ 1
#endif

d162 2
d238 1
a238 1
#if defined (_WIN32) && ! defined (__UWIN__)
d285 39
d466 1
a466 1
#endif /* _WIN32 && ! __UWIN__ */
d649 1
a649 1
    && ! (defined (_WIN32) && ! defined (__UWIN__))
d778 1
a778 1
#endif /* ! __MSDOS__ && ! OS2 && ! MPW && ! (_WIN32 && ! __UWIN__) */
@


1.1
log
@Initial revision
@
text
@d619 1
a619 1
     const char *temp_base;
d726 1
a726 1
     int flags;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.2
log
@import libiberty from egcs
@
text
@d3 1
a3 1
   Copyright (C) 1996-2000 Free Software Foundation, Inc.
a31 3
#ifdef HAVE_STRING_H
#include <string.h>
#endif
d55 4
a162 2
  if (temp_base == 0)
    temp_base = choose_temp_base ();
d237 1
a237 1
#if defined (_WIN32) && ! defined (_UWIN)
a283 39
  for (i = 0; argvec[i] != 0; i++)
    {
      if (strpbrk (argvec[i], " \t"))
        {
	  int len, trailing_backslash;
	  char *temp;

	  len = strlen (argvec[i]);
	  trailing_backslash = 0;

	  /* There is an added complication when an arg with embedded white
	     space ends in a backslash (such as in the case of -iprefix arg
	     passed to cpp). The resulting quoted strings gets misinterpreted
	     by the command interpreter -- it thinks that the ending quote
	     is escaped by the trailing backslash and things get confused. 
	     We handle this case by escaping the trailing backslash, provided
	     it was not escaped in the first place.  */
	  if (len > 1 
	      && argvec[i][len-1] == '\\' 
	      && argvec[i][len-2] != '\\')
	    {
	      trailing_backslash = 1;
	      ++len;			/* to escape the final backslash. */
	    }

	  len += 2;			/* and for the enclosing quotes. */

	  temp = xmalloc (len + 1);
	  temp[0] = '"';
	  strcpy (temp + 1, argvec[i]);
	  if (trailing_backslash)
	    temp[len-2] = '\\';
	  temp[len-1] = '"';
	  temp[len] = '\0';

	  argvec[i] = temp;
	}
    }

d426 1
a426 1
#endif /* _WIN32 && ! _UWIN */
d609 1
a609 1
    && ! (defined (_WIN32) && ! defined (_UWIN))
d738 1
a738 1
#endif /* ! __MSDOS__ && ! OS2 && ! MPW && ! (_WIN32 && ! _UWIN) */
@


