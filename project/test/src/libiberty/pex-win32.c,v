head	1.25;
access;
symbols
	sid-snapshot-20180601:1.25
	sid-snapshot-20180501:1.25
	sid-snapshot-20180401:1.25
	sid-snapshot-20180301:1.25
	sid-snapshot-20180201:1.25
	sid-snapshot-20180101:1.25
	sid-snapshot-20171201:1.25
	sid-snapshot-20171101:1.25
	sid-snapshot-20171001:1.25
	sid-snapshot-20170901:1.25
	sid-snapshot-20170801:1.25
	sid-snapshot-20170701:1.25
	sid-snapshot-20170601:1.25
	sid-snapshot-20170501:1.25
	sid-snapshot-20170401:1.25
	sid-snapshot-20170301:1.25
	sid-snapshot-20170201:1.25
	sid-snapshot-20170101:1.25
	sid-snapshot-20161201:1.25
	sid-snapshot-20161101:1.25
	sid-snapshot-20160901:1.25
	sid-snapshot-20160801:1.25
	sid-snapshot-20160701:1.25
	sid-snapshot-20160601:1.25
	sid-snapshot-20160501:1.25
	sid-snapshot-20160401:1.25
	sid-snapshot-20160301:1.25
	sid-snapshot-20160201:1.25
	sid-snapshot-20160101:1.25
	sid-snapshot-20151201:1.25
	sid-snapshot-20151101:1.25
	sid-snapshot-20151001:1.25
	sid-snapshot-20150901:1.25
	sid-snapshot-20150801:1.25
	sid-snapshot-20150701:1.25
	sid-snapshot-20150601:1.25
	sid-snapshot-20150501:1.25
	sid-snapshot-20150401:1.25
	sid-snapshot-20150301:1.25
	sid-snapshot-20150201:1.25
	sid-snapshot-20150101:1.25
	sid-snapshot-20141201:1.25
	sid-snapshot-20141101:1.25
	sid-snapshot-20141001:1.25
	sid-snapshot-20140901:1.24
	sid-snapshot-20140801:1.24
	sid-snapshot-20140701:1.24
	sid-snapshot-20140601:1.23
	sid-snapshot-20140501:1.23
	sid-snapshot-20140401:1.23
	sid-snapshot-20140301:1.23
	sid-snapshot-20140201:1.23
	sid-snapshot-20140101:1.23
	sid-snapshot-20131201:1.23
	sid-snapshot-20131101:1.23
	sid-snapshot-20131001:1.23
	binutils-2_24-branch:1.23.0.6
	binutils-2_24-branchpoint:1.23
	binutils-2_21_1:1.21
	sid-snapshot-20130901:1.23
	gdb_7_6_1-2013-08-30-release:1.23
	sid-snapshot-20130801:1.23
	sid-snapshot-20130701:1.23
	sid-snapshot-20130601:1.23
	sid-snapshot-20130501:1.23
	gdb_7_6-2013-04-26-release:1.23
	sid-snapshot-20130401:1.23
	binutils-2_23_2:1.23
	gdb_7_6-branch:1.23.0.4
	gdb_7_6-2013-03-12-branchpoint:1.23
	sid-snapshot-20130301:1.23
	sid-snapshot-20130201:1.23
	sid-snapshot-20130101:1.23
	sid-snapshot-20121201:1.23
	gdb_7_5_1-2012-11-29-release:1.22
	binutils-2_23_1:1.23
	sid-snapshot-20121101:1.23
	binutils-2_23:1.23
	sid-snapshot-20121001:1.23
	sid-snapshot-20120901:1.23
	gdb_7_5-2012-08-17-release:1.22
	sid-snapshot-20120801:1.23
	binutils-2_23-branch:1.23.0.2
	binutils-2_23-branchpoint:1.23
	gdb_7_5-branch:1.22.0.8
	gdb_7_5-2012-07-18-branchpoint:1.22
	sid-snapshot-20120701:1.22
	sid-snapshot-20120601:1.22
	sid-snapshot-20120501:1.22
	binutils-2_22_branch:1.22.0.6
	gdb_7_4_1-2012-04-26-release:1.22
	sid-snapshot-20120401:1.22
	sid-snapshot-20120301:1.22
	sid-snapshot-20120201:1.22
	gdb_7_4-2012-01-24-release:1.22
	sid-snapshot-20120101:1.22
	gdb_7_4-branch:1.22.0.4
	gdb_7_4-2011-12-13-branchpoint:1.22
	sid-snapshot-20111201:1.22
	binutils-2_22:1.22
	sid-snapshot-20111101:1.22
	sid-snapshot-20111001:1.22
	binutils-2_22-branch:1.22.0.2
	binutils-2_22-branchpoint:1.22
	gdb_7_3_1-2011-09-04-release:1.21
	sid-snapshot-20110901:1.22
	sid-snapshot-20110801:1.22
	gdb_7_3-2011-07-26-release:1.21
	sid-snapshot-20110701:1.22
	sid-snapshot-20110601:1.22
	sid-snapshot-20110501:1.22
	gdb_7_3-branch:1.21.0.16
	gdb_7_3-2011-04-01-branchpoint:1.21
	sid-snapshot-20110401:1.21
	sid-snapshot-20110301:1.21
	cygwin-1_7_8-release:1.21
	sid-snapshot-20110201:1.21
	sid-snapshot-20110101:1.21
	binutils-2_21:1.21
	sid-snapshot-20101201:1.21
	binutils-2_21-branch:1.21.0.14
	binutils-2_21-branchpoint:1.21
	sid-snapshot-20101101:1.21
	sid-snapshot-20101001:1.21
	binutils-2_20_1:1.21
	gdb_7_2-2010-09-02-release:1.21
	sid-snapshot-20100901:1.21
	cygwin-1_7_7-release:1.21
	sid-snapshot-20100801:1.21
	gdb_7_2-branch:1.21.0.12
	gdb_7_2-2010-07-07-branchpoint:1.21
	sid-snapshot-20100701:1.21
	sid-snapshot-20100601:1.21
	sid-snapshot-20100501:1.21
	sid-snapshot-20100401:1.21
	gdb_7_1-2010-03-18-release:1.21
	sid-snapshot-20100301:1.21
	gdb_7_1-branch:1.21.0.10
	gdb_7_1-2010-02-18-branchpoint:1.21
	sid-snapshot-20100201:1.21
	sid-snapshot-20100101:1.21
	gdb_7_0_1-2009-12-22-release:1.21
	sid-snapshot-20091201:1.21
	sid-snapshot-20091101:1.21
	binutils-2_20:1.21
	gdb_7_0-2009-10-06-release:1.21
	sid-snapshot-20091001:1.21
	gdb_7_0-branch:1.21.0.8
	gdb_7_0-2009-09-16-branchpoint:1.21
	arc-sim-20090309:1.16
	binutils-arc-20081103-branch:1.17.0.12
	binutils-arc-20081103-branchpoint:1.17
	binutils-2_20-branch:1.21.0.6
	binutils-2_20-branchpoint:1.21
	sid-snapshot-20090901:1.21
	sid-snapshot-20090801:1.21
	msnyder-checkpoint-072509-branch:1.21.0.4
	msnyder-checkpoint-072509-branchpoint:1.21
	sid-snapshot-20090701:1.21
	dje-cgen-play1-branch:1.21.0.2
	dje-cgen-play1-branchpoint:1.21
	sid-snapshot-20090601:1.21
	sid-snapshot-20090501:1.19
	sid-snapshot-20090401:1.17
	arc-20081103-branch:1.17.0.10
	arc-20081103-branchpoint:1.17
	arc-insight_6_8-branch:1.16.0.12
	arc-insight_6_8-branchpoint:1.16
	insight_6_8-branch:1.16.0.10
	insight_6_8-branchpoint:1.16
	sid-snapshot-20090301:1.17
	binutils-2_19_1:1.17
	sid-snapshot-20090201:1.17
	sid-snapshot-20090101:1.17
	reverse-20081226-branch:1.17.0.8
	reverse-20081226-branchpoint:1.17
	sid-snapshot-20081201:1.17
	multiprocess-20081120-branch:1.17.0.6
	multiprocess-20081120-branchpoint:1.17
	sid-snapshot-20081101:1.17
	binutils-2_19:1.17
	sid-snapshot-20081001:1.17
	reverse-20080930-branch:1.17.0.4
	reverse-20080930-branchpoint:1.17
	binutils-2_19-branch:1.17.0.2
	binutils-2_19-branchpoint:1.17
	sid-snapshot-20080901:1.17
	sid-snapshot-20080801:1.16
	reverse-20080717-branch:1.16.0.8
	reverse-20080717-branchpoint:1.16
	sid-snapshot-20080701:1.16
	msnyder-reverse-20080609-branch:1.16.0.6
	msnyder-reverse-20080609-branchpoint:1.16
	drow-reverse-20070409-branch:1.15.0.6
	drow-reverse-20070409-branchpoint:1.15
	sid-snapshot-20080601:1.16
	sid-snapshot-20080501:1.16
	sid-snapshot-20080403:1.16
	sid-snapshot-20080401:1.16
	gdb_6_8-2008-03-27-release:1.16
	sid-snapshot-20080301:1.16
	gdb_6_8-branch:1.16.0.4
	gdb_6_8-2008-02-26-branchpoint:1.16
	sid-snapshot-20080201:1.16
	sid-snapshot-20080101:1.16
	sid-snapshot-20071201:1.16
	sid-snapshot-20071101:1.16
	gdb_6_7_1-2007-10-29-release:1.16
	gdb_6_7-2007-10-10-release:1.16
	sid-snapshot-20071001:1.16
	gdb_6_7-branch:1.16.0.2
	gdb_6_7-2007-09-07-branchpoint:1.16
	binutils-2_18:1.15
	binutils-2_18-branch:1.15.0.4
	binutils-2_18-branchpoint:1.15
	insight_6_6-20070208-release:1.15
	binutils-csl-coldfire-4_1-32:1.9.14.5
	binutils-csl-sourcerygxx-4_1-32:1.9.14.5
	gdb_6_6-2006-12-18-release:1.15
	binutils-csl-innovasic-fido-3_4_4-33:1.9.14.5
	binutils-csl-sourcerygxx-3_4_4-32:1.4
	binutils-csl-coldfire-4_1-30:1.9.14.5
	binutils-csl-sourcerygxx-4_1-30:1.9.14.5
	binutils-csl-coldfire-4_1-28:1.9.14.5
	binutils-csl-sourcerygxx-4_1-29:1.9.14.5
	binutils-csl-sourcerygxx-4_1-28:1.9.14.5
	gdb_6_6-branch:1.15.0.2
	gdb_6_6-2006-11-15-branchpoint:1.15
	binutils-csl-arm-2006q3-27:1.9.14.5
	binutils-csl-sourcerygxx-4_1-27:1.9.14.5
	binutils-csl-arm-2006q3-26:1.9.14.4
	binutils-csl-sourcerygxx-4_1-26:1.9.14.4
	binutils-csl-sourcerygxx-4_1-25:1.9.14.4
	binutils-csl-sourcerygxx-4_1-24:1.9.14.4
	binutils-csl-sourcerygxx-4_1-23:1.9.14.4
	insight_6_5-20061003-release:1.11
	gdb-csl-symbian-6_4_50_20060226-12:1.9.10.3
	binutils-csl-sourcerygxx-4_1-21:1.9.14.4
	binutils-csl-arm-2006q3-21:1.9.14.4
	binutils-csl-sourcerygxx-4_1-22:1.9.14.4
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.9.14.4
	binutils-csl-sourcerygxx-4_1-20:1.9.14.3
	binutils-csl-arm-2006q3-19:1.9.14.3
	binutils-csl-sourcerygxx-4_1-19:1.9.14.3
	binutils-csl-sourcerygxx-4_1-18:1.9.14.3
	binutils-csl-renesas-4_1-9:1.9.14.3
	gdb-csl-sourcerygxx-3_4_4-25:1.9
	binutils-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.13
	gdb-csl-symbian-6_4_50_20060226-11:1.9.10.3
	binutils-csl-renesas-4_1-8:1.9.14.3
	binutils-csl-renesas-4_1-7:1.9.14.3
	binutils-csl-renesas-4_1-6:1.9.14.3
	gdb-csl-sourcerygxx-4_1-17:1.9.10.3
	binutils-csl-sourcerygxx-4_1-17:1.9.14.3
	gdb-csl-20060226-branch-local-2:1.9.10.3
	cr-0x5f1:1.12.0.2
	gdb-csl-sourcerygxx-4_1-14:1.9.10.3
	binutils-csl-sourcerygxx-4_1-14:1.9.14.3
	binutils-csl-sourcerygxx-4_1-15:1.9.14.3
	gdb-csl-sourcerygxx-4_1-13:1.9.10.3
	binutils-csl-sourcerygxx-4_1-13:1.9.14.3
	binutils-2_17:1.11
	gdb-csl-sourcerygxx-4_1-12:1.9.10.3
	binutils-csl-sourcerygxx-4_1-12:1.9.14.3
	gdb-csl-sourcerygxx-3_4_4-21:1.9.10.3
	binutils-csl-sourcerygxx-3_4_4-21:1.9.14.3
	gdb_6_5-20060621-release:1.11
	binutils-csl-wrs-linux-3_4_4-24:1.4
	binutils-csl-wrs-linux-3_4_4-23:1.4
	gdb-csl-sourcerygxx-4_1-9:1.9.10.3
	binutils-csl-sourcerygxx-4_1-9:1.9.14.3
	gdb-csl-sourcerygxx-4_1-8:1.9.10.3
	binutils-csl-sourcerygxx-4_1-8:1.9.14.3
	gdb-csl-sourcerygxx-4_1-7:1.9.10.3
	binutils-csl-sourcerygxx-4_1-7:1.9.14.3
	gdb-csl-arm-2006q1-6:1.9.10.3
	binutils-csl-arm-2006q1-6:1.9.14.3
	gdb-csl-sourcerygxx-4_1-6:1.9.10.3
	binutils-csl-sourcerygxx-4_1-6:1.9.14.3
	binutils-csl-wrs-linux-3_4_4-22:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.9.10.3
	gdb-csl-symbian-6_4_50_20060226-9:1.9.10.3
	gdb-csl-symbian-6_4_50_20060226-8:1.9.10.3
	gdb-csl-coldfire-4_1-11:1.9.10.3
	binutils-csl-coldfire-4_1-11:1.9.14.3
	gdb-csl-sourcerygxx-3_4_4-19:1.9.10.3
	binutils-csl-sourcerygxx-3_4_4-19:1.9.14.3
	gdb-csl-coldfire-4_1-10:1.9.10.3
	gdb_6_5-branch:1.11.0.10
	gdb_6_5-2006-05-14-branchpoint:1.11
	binutils-csl-coldfire-4_1-10:1.9.14.3
	gdb-csl-sourcerygxx-4_1-5:1.9.10.3
	binutils-csl-sourcerygxx-4_1-5:1.9.14.3
	nickrob-async-20060513-branch:1.11.0.8
	nickrob-async-20060513-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-4:1.9.10.3
	binutils-csl-sourcerygxx-4_1-4:1.9.14.3
	msnyder-reverse-20060502-branch:1.11.0.6
	msnyder-reverse-20060502-branchpoint:1.11
	binutils-csl-wrs-linux-3_4_4-21:1.4
	gdb-csl-morpho-4_1-4:1.9.10.3
	binutils-csl-morpho-4_1-4:1.9.14.3
	gdb-csl-sourcerygxx-3_4_4-17:1.9.10.3
	binutils-csl-sourcerygxx-3_4_4-17:1.9.14.3
	binutils-csl-wrs-linux-3_4_4-20:1.4
	readline_5_1-import-branch:1.11.0.4
	readline_5_1-import-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.9.10.3
	binutils-2_17-branch:1.11.0.2
	binutils-2_17-branchpoint:1.11
	gdb-csl-symbian-20060226-branch:1.9.10.3.0.2
	gdb-csl-symbian-20060226-branchpoint:1.9.10.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.9.10.3
	msnyder-reverse-20060331-branch:1.9.0.16
	msnyder-reverse-20060331-branchpoint:1.9
	binutils-csl-2_17-branch:1.9.0.14
	binutils-csl-2_17-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.9.0.12
	gdb-csl-available-20060303-branchpoint:1.9
	gdb-csl-20060226-branch:1.9.0.10
	gdb-csl-20060226-branchpoint:1.9
	gdb_6_4-20051202-release:1.9
	msnyder-fork-checkpoint-branch:1.9.0.8
	msnyder-fork-checkpoint-branchpoint:1.9
	gdb-csl-gxxpro-6_3-branch:1.9.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.9
	gdb_6_4-branch:1.9.0.4
	gdb_6_4-2005-11-01-branchpoint:1.9
	gdb-csl-arm-20051020-branch:1.9.0.2
	gdb-csl-arm-20051020-branchpoint:1.9
	binutils-csl-gxxpro-3_4-branch:1.4.0.14
	binutils-csl-gxxpro-3_4-branchpoint:1.4
	binutils-2_16_1:1.4
	msnyder-tracepoint-checkpoint-branch:1.8.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.8
	gdb-csl-arm-20050325-2005-q1b:1.4
	binutils-csl-arm-2005q1b:1.4
	binutils-2_16:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	binutils-csl-arm-2005q1a:1.4
	csl-arm-20050325-branch:1.4.0.12
	csl-arm-20050325-branchpoint:1.4
	binutils-csl-arm-2005q1-branch:1.4.0.10
	binutils-csl-arm-2005q1-branchpoint:1.4
	binutils-2_16-branch:1.4.0.8
	binutils-2_16-branchpoint:1.4
	csl-arm-2004-q3d:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.4
	gdb_6_3-20041019-branchpoint:1.4
	csl-arm-2004-q3:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.6
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.3
	binutils-2_15:1.3
	binutils-2_15-branchpoint:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.22
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.20
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.18
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.16
	drow_intercu-20040221-branchpoint:1.3
	binutils-2_15-branch:1.3.0.14
	cagney_bfdfile-20040213-branch:1.3.0.12
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.10
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	csl-arm-2003-q4:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-branch:1.3.0.8
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.1
	kettenis_sparc-20030918-branch:1.3.0.6
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.4
	cagney_x86i386-20030821-branch:1.3.0.2
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.1
	gdb_6_0-branch:1.1.0.36
	gdb_6_0-2003-06-23-branchpoint:1.1
	jimb-ppc64-linux-20030613-branch:1.1.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.1
	binutils-2_14:1.1
	cagney_convert-20030606-branch:1.1.0.32
	cagney_convert-20030606-branchpoint:1.1
	cagney_writestrings-20030508-branch:1.1.0.30
	cagney_writestrings-20030508-branchpoint:1.1
	jimb-ppc64-linux-20030528-branch:1.1.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.1
	carlton_dictionary-20030523-merge:1.1
	cagney_fileio-20030521-branch:1.1.0.26
	cagney_fileio-20030521-branchpoint:1.1
	kettenis_i386newframe-20030517-mergepoint:1.1
	jimb-ppc64-linux-20030509-branch:1.1.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.1
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	binutils-2_14-branch:1.1.0.22
	binutils-2_14-branchpoint:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.20
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-20030416-merge:1.1
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.18
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.16
	cagney_framebase-20030330-mergepoint:1.1
	cagney_framebase-20030326-branch:1.1.0.14
	cagney_framebase-20030326-branchpoint:1.1
	cagney_lazyid-20030317-branch:1.1.0.12
	cagney_lazyid-20030317-branchpoint:1.1
	kettenis-i386newframe-20030316-mergepoint:1.1
	offbyone-20030313-branch:1.1.0.10
	offbyone-20030313-branchpoint:1.1
	kettenis-i386newframe-20030308-branch:1.1.0.8
	kettenis-i386newframe-20030308-branchpoint:1.1
	carlton_dictionary-20030305-merge:1.1
	cagney_offbyone-20030303-branch:1.1.0.6
	cagney_offbyone-20030303-branchpoint:1.1
	w32api-2_2:1.1
	mingw-runtime-2_4:1.1
	carlton_dictionary-branch:1.1.0.4
	carlton_dictionary-20030207-merge:1.1
	binutils_latest_snapshot:1.24
	interps-20030202-branch:1.1.0.2
	interps-20030202-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.25
date	2014.09.28.17.46.12;	author dj;	state Exp;
branches;
next	1.24;

1.24
date	2014.06.11.17.56.20;	author dj;	state Exp;
branches;
next	1.23;

1.23
date	2012.07.27.00.02.21;	author dj;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.20.19.06.46;	author dj;	state Exp;
branches;
next	1.21;

1.21
date	2009.05.29.20.19.14;	author ktietz;	state Exp;
branches;
next	1.20;

1.20
date	2009.05.17.13.12.28;	author jules;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.29.11.52.41;	author jules;	state Exp;
branches;
next	1.18;

1.18
date	2009.04.13.10.48.27;	author ktietz;	state Exp;
branches;
next	1.17;

1.17
date	2008.08.07.20.00.53;	author dj;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.24.16.08.40;	author dj;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.08.16.18.58;	author vprus;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.26.04.18.42;	author dj;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.28.00.56.12;	author dj;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.01.14.57.50;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.12.18.42.01;	author dj;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.31.23.01.16;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.15.01.04.05;	author dj;	state Exp;
branches
	1.9.10.1
	1.9.14.1;
next	1.8;

1.8
date	2005.05.24.21.01.33;	author dj;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.10.15.33.33;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.29.02.15.22;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.28.05.07.08;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.31.13.27.45;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.05.01.59.15;	author dj;	state Exp;
branches
	1.3.8.1
	1.3.16.1;
next	1.2;

1.2
date	2003.07.03.14.00.54;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.24.21.31.35;	author dj;	state Exp;
branches
	1.1.4.1;
next	;

1.9.10.1
date	2006.03.17.20.36.14;	author jimb;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2006.03.20.20.00.45;	author mmitchel;	state Exp;
branches;
next	1.9.10.3;

1.9.10.3
date	2006.03.27.09.48.38;	author mmitchel;	state Exp;
branches;
next	;

1.9.14.1
date	2006.03.20.21.00.32;	author mmitchel;	state Exp;
branches;
next	1.9.14.2;

1.9.14.2
date	2006.03.27.09.44.11;	author mmitchel;	state Exp;
branches;
next	1.9.14.3;

1.9.14.3
date	2006.03.31.01.17.06;	author mmitchel;	state Exp;
branches;
next	1.9.14.4;

1.9.14.4
date	2006.09.28.20.41.10;	author shinwell;	state Exp;
branches;
next	1.9.14.5;

1.9.14.5
date	2006.11.08.17.45.23;	author vprus;	state Exp;
branches;
next	;

1.3.8.1
date	2003.12.14.20.28.03;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2004.09.16.17.01.56;	author drow;	state Exp;
branches;
next	;

1.1.4.1
date	2003.02.07.19.18.02;	author carlton;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.08.05.17.13.29;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.25
log
@merge from gcc
@
text
@/* Utilities to execute a program in a subprocess (possibly linked by pipes
   with other subprocesses), and wait for it.  Generic Win32 specialization.
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006
   Free Software Foundation, Inc.

This file is part of the libiberty library.
Libiberty is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

Libiberty is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libiberty; see the file COPYING.LIB.  If not,
write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */

#include "pex-common.h"

#include <windows.h>

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#include <assert.h>
#include <process.h>
#include <io.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/stat.h>
#include <errno.h>
#include <ctype.h>

/* mingw32 headers may not define the following.  */

#ifndef _P_WAIT
#  define _P_WAIT	0
#  define _P_NOWAIT	1
#  define _P_OVERLAY	2
#  define _P_NOWAITO	3
#  define _P_DETACH	4

#  define WAIT_CHILD		0
#  define WAIT_GRANDCHILD	1
#endif

#define MINGW_NAME "Minimalist GNU for Windows"
#define MINGW_NAME_LEN (sizeof(MINGW_NAME) - 1)

extern char *stpcpy (char *dst, const char *src);

/* Ensure that the executable pathname uses Win32 backslashes. This
   is not necessary on NT, but on W9x, forward slashes causes
   failure of spawn* and exec* functions (and probably any function
   that calls CreateProcess) *iff* the executable pathname (argv[0])
   is a quoted string.  And quoting is necessary in case a pathname
   contains embedded white space.  You can't win.  */
static void
backslashify (char *s)
{
  while ((s = strchr (s, '/')) != NULL)
    *s = '\\';
  return;
}

static int pex_win32_open_read (struct pex_obj *, const char *, int);
static int pex_win32_open_write (struct pex_obj *, const char *, int, int);
static pid_t pex_win32_exec_child (struct pex_obj *, int, const char *,
				  char * const *, char * const *,
                                  int, int, int, int,
				  const char **, int *);
static int pex_win32_close (struct pex_obj *, int);
static pid_t pex_win32_wait (struct pex_obj *, pid_t, int *,
			   struct pex_time *, int, const char **, int *);
static int pex_win32_pipe (struct pex_obj *, int *, int);
static FILE *pex_win32_fdopenr (struct pex_obj *, int, int);
static FILE *pex_win32_fdopenw (struct pex_obj *, int, int);

/* The list of functions we pass to the common routines.  */

const struct pex_funcs funcs =
{
  pex_win32_open_read,
  pex_win32_open_write,
  pex_win32_exec_child,
  pex_win32_close,
  pex_win32_wait,
  pex_win32_pipe,
  pex_win32_fdopenr,
  pex_win32_fdopenw,
  NULL /* cleanup */
};

/* Return a newly initialized pex_obj structure.  */

struct pex_obj *
pex_init (int flags, const char *pname, const char *tempbase)
{
  return pex_init_common (flags, pname, tempbase, &funcs);
}

/* Open a file for reading.  */

static int
pex_win32_open_read (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
		     int binary)
{
  return _open (name, _O_RDONLY | (binary ? _O_BINARY : _O_TEXT));
}

/* Open a file for writing.  */

static int
pex_win32_open_write (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
		      int binary, int append)
{
  /* Note that we can't use O_EXCL here because gcc may have already
     created the temporary file via make_temp_file.  */
  if (append)
    return -1;
  return _open (name,
		(_O_WRONLY | _O_CREAT | _O_TRUNC
		 | (binary ? _O_BINARY : _O_TEXT)),
		_S_IREAD | _S_IWRITE);
}

/* Close a file.  */

static int
pex_win32_close (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd)
{
  return _close (fd);
}

#ifdef USE_MINGW_MSYS
static const char *mingw_keys[] = {"SOFTWARE", "Microsoft", "Windows", "CurrentVersion", "Uninstall", NULL};

/* Tack the executable on the end of a (possibly slash terminated) buffer
   and convert everything to \. */
static const char *
tack_on_executable (char *buf, const char *executable)
{
  char *p = strchr (buf, '\0');
  if (p > buf && (p[-1] == '\\' || p[-1] == '/'))
    p[-1] = '\0';
  backslashify (strcat (buf, executable));
  return buf;
}

/* Walk down a registry hierarchy until the end.  Return the key. */
static HKEY
openkey (HKEY hStart, const char *keys[])
{
  HKEY hKey, hTmp;
  for (hKey = hStart; *keys; keys++)
    {
      LONG res;
      hTmp = hKey;
      res = RegOpenKey (hTmp, *keys, &hKey);

      if (hTmp != HKEY_LOCAL_MACHINE)
	RegCloseKey (hTmp);

      if (res != ERROR_SUCCESS)
	return NULL;
    }
  return hKey;
}

/* Return the "mingw root" as derived from the mingw uninstall information. */
static const char *
mingw_rootify (const char *executable)
{
  HKEY hKey, hTmp;
  DWORD maxlen;
  char *namebuf, *foundbuf;
  DWORD i;
  LONG res;

  /* Open the uninstall "directory". */
  hKey = openkey (HKEY_LOCAL_MACHINE, mingw_keys);

  /* Not found. */
  if (!hKey)
    return executable;

  /* Need to enumerate all of the keys here looking for one the most recent
     one for MinGW. */
  if (RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, &maxlen, NULL, NULL,
		       NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
    {
      RegCloseKey (hKey);
      return executable;
    }
  namebuf = XNEWVEC (char, ++maxlen);
  foundbuf = XNEWVEC (char, maxlen);
  foundbuf[0] = '\0';
  if (!namebuf || !foundbuf)
    {
      RegCloseKey (hKey);
      free (namebuf);
      free (foundbuf);
      return executable;
    }

  /* Look through all of the keys for one that begins with Minimal GNU...
     Try to get the latest version by doing a string compare although that
     string never really works with version number sorting. */
  for (i = 0; RegEnumKey (hKey, i, namebuf, maxlen) == ERROR_SUCCESS; i++)
    {
      int match = strcasecmp (namebuf, MINGW_NAME);
      if (match < 0)
	continue;
      if (match > 0 && strncasecmp (namebuf, MINGW_NAME, MINGW_NAME_LEN) > 0)
	continue;
      if (strcasecmp (namebuf, foundbuf) > 0)
	strcpy (foundbuf, namebuf);
    }
  free (namebuf);

  /* If foundbuf is empty, we didn't find anything.  Punt. */
  if (!foundbuf[0])
    {
      free (foundbuf);
      RegCloseKey (hKey);
      return executable;
    }

  /* Open the key that we wanted */
  res = RegOpenKey (hKey, foundbuf, &hTmp);
  RegCloseKey (hKey);
  free (foundbuf);

  /* Don't know why this would fail, but you gotta check */
  if (res != ERROR_SUCCESS)
    return executable;

  maxlen = 0;
  /* Get the length of the value pointed to by InstallLocation */
  if (RegQueryValueEx (hTmp, "InstallLocation", 0, NULL, NULL,
		       &maxlen) != ERROR_SUCCESS || maxlen == 0)
    {
      RegCloseKey (hTmp);
      return executable;
    }

  /* Allocate space for the install location */
  foundbuf = XNEWVEC (char, maxlen + strlen (executable));
  if (!foundbuf)
    {
      free (foundbuf);
      RegCloseKey (hTmp);
    }

  /* Read the install location into the buffer */
  res = RegQueryValueEx (hTmp, "InstallLocation", 0, NULL, (LPBYTE) foundbuf,
			 &maxlen);
  RegCloseKey (hTmp);
  if (res != ERROR_SUCCESS)
    {
      free (foundbuf);
      return executable;
    }

  /* Concatenate the install location and the executable, turn all slashes
     to backslashes, and return that. */
  return tack_on_executable (foundbuf, executable);
}

/* Read the install location of msys from it's installation file and
   rootify the executable based on that. */
static const char *
msys_rootify (const char *executable)
{
  size_t bufsize = 64;
  size_t execlen = strlen (executable) + 1;
  char *buf;
  DWORD res = 0;
  for (;;)
    {
      buf = XNEWVEC (char, bufsize + execlen);
      if (!buf)
	break;
      res = GetPrivateProfileString ("InstallSettings", "InstallPath", NULL,
				     buf, bufsize, "msys.ini");
      if (!res)
	break;
      if (strlen (buf) < bufsize)
	break;
      res = 0;
      free (buf);
      bufsize *= 2;
      if (bufsize > 65536)
	{
	  buf = NULL;
	  break;
	}
    }

  if (res)
    return tack_on_executable (buf, executable);

  /* failed */
  free (buf);
  return executable;
}
#endif

/* Return the number of arguments in an argv array, not including the null
   terminating argument. */

static int
argv_to_argc (char *const *argv)
{
  char *const *i = argv;
  while (*i)
    i++;
  return i - argv;
}

/* Return a Windows command-line from ARGV.  It is the caller's
   responsibility to free the string returned.  */

static char *
argv_to_cmdline (char *const *argv)
{
  char *cmdline;
  char *p;
  size_t cmdline_len;
  int i, j, k;
  int needs_quotes;

  cmdline_len = 0;
  for (i = 0; argv[i]; i++)
    {
      /* We only quote arguments that contain spaces, \t or " characters to
	 prevent wasting 2 chars per argument of the CreateProcess 32k char
	 limit.  We need only escape embedded double-quotes and immediately
	 preceeding backslash characters.  A sequence of backslach characters
	 that is not follwed by a double quote character will not be
	 escaped.  */
      needs_quotes = 0;
      for (j = 0; argv[i][j]; j++)
	{
	  if (argv[i][j] == ' ' || argv[i][j] == '\t' || argv[i][j] == '"')
	    {
	      needs_quotes = 1;
	    }

	  if (argv[i][j] == '"')
	    {
	      /* Escape preceeding backslashes.  */
	      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
		cmdline_len++;
	      /* Escape the qote character.  */
	      cmdline_len++;
	    }
	}
      /* Trailing backslashes also need to be escaped because they will be
         followed by the terminating quote.  */
      if (needs_quotes)
        {
          for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
            cmdline_len++;
        }
      cmdline_len += j;
      /* for leading and trailing quotes and space */
      cmdline_len += needs_quotes * 2 + 1;
    }
  cmdline = XNEWVEC (char, cmdline_len);
  p = cmdline;
  for (i = 0; argv[i]; i++)
    {
      needs_quotes = 0;
      for (j = 0; argv[i][j]; j++)
        {
          if (argv[i][j] == ' ' || argv[i][j] == '\t' || argv[i][j] == '"')
            {
              needs_quotes = 1;
              break;
            }
        }

      if (needs_quotes)
        {
          *p++ = '"';
        }
      for (j = 0; argv[i][j]; j++)
	{
	  if (argv[i][j] == '"')
	    {
	      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
		*p++ = '\\';
	      *p++ = '\\';
	    }
	  *p++ = argv[i][j];
	}
      if (needs_quotes)
        {
          for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
            *p++ = '\\';
          *p++ = '"';
        }
      *p++ = ' ';
    }
  p[-1] = '\0';
  return cmdline;
}

/* We'll try the passed filename with all the known standard
   extensions, and then without extension.  We try no extension
   last so that we don't try to run some random extension-less
   file that might be hanging around.  We try both extension
   and no extension so that we don't need any fancy logic
   to determine if a file has extension.  */
static const char *const
std_suffixes[] = {
  ".com",
  ".exe",
  ".bat",
  ".cmd",
  "",
  0
};

/* Returns the full path to PROGRAM.  If SEARCH is true, look for
   PROGRAM in each directory in PATH.  */

static char *
find_executable (const char *program, BOOL search)
{
  char *full_executable;
  char *e;
  size_t fe_len;
  const char *path = 0;
  const char *const *ext;
  const char *p, *q;
  size_t proglen = strlen (program);
  int has_slash = (strchr (program, '/') || strchr (program, '\\'));
  HANDLE h;

  if (has_slash)
    search = FALSE;

  if (search)
    path = getenv ("PATH");
  if (!path)
    path = "";

  fe_len = 0;
  for (p = path; *p; p = q)
    {
      q = p;
      while (*q != ';' && *q != '\0')
	q++;
      if ((size_t)(q - p) > fe_len)
	fe_len = q - p;
      if (*q == ';')
	q++;
    }
  fe_len = fe_len + 1 + proglen + 5 /* space for extension */;
  full_executable = XNEWVEC (char, fe_len);

  p = path;
  do
    {
      q = p;
      while (*q != ';' && *q != '\0')
	q++;

      e = full_executable;
      memcpy (e, p, q - p);
      e += (q - p);
      if (q - p)
	*e++ = '\\';
      strcpy (e, program);

      if (*q == ';')
	q++;

      for (e = full_executable; *e; e++)
	if (*e == '/')
	  *e = '\\';

      /* At this point, e points to the terminating NUL character for
         full_executable.  */
      for (ext = std_suffixes; *ext; ext++)
	{
	  /* Remove any current extension.  */
	  *e = '\0';
	  /* Add the new one.  */
	  strcat (full_executable, *ext);

	  /* Attempt to open this file.  */
	  h = CreateFile (full_executable, GENERIC_READ,
			  FILE_SHARE_READ | FILE_SHARE_WRITE,
			  0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	  if (h != INVALID_HANDLE_VALUE)
	    goto found;
	}
      p = q;
    }
  while (*p);
  free (full_executable);
  return 0;

 found:
  CloseHandle (h);
  return full_executable;
}

/* Low-level process creation function and helper.  */

static int
env_compare (const void *a_ptr, const void *b_ptr)
{
  const char *a;
  const char *b;
  unsigned char c1;
  unsigned char c2;

  a = *(const char **) a_ptr;
  b = *(const char **) b_ptr;

  /* a and b will be of the form: VAR=VALUE
     We compare only the variable name part here using a case-insensitive
     comparison algorithm.  It might appear that in fact strcasecmp () can
     take the place of this whole function, and indeed it could, save for
     the fact that it would fail in cases such as comparing A1=foo and
     A=bar (because 1 is less than = in the ASCII character set).
     (Environment variables containing no numbers would work in such a
     scenario.)  */

  do
    {
      c1 = (unsigned char) tolower (*a++);
      c2 = (unsigned char) tolower (*b++);

      if (c1 == '=')
        c1 = '\0';

      if (c2 == '=')
        c2 = '\0';
    }
  while (c1 == c2 && c1 != '\0');

  return c1 - c2;
}

/* Execute a Windows executable as a child process.  This will fail if the
 * target is not actually an executable, such as if it is a shell script. */

static pid_t
win32_spawn (const char *executable,
	     BOOL search,
	     char *const *argv,
             char *const *env, /* array of strings of the form: VAR=VALUE */
	     DWORD dwCreationFlags,
	     LPSTARTUPINFO si,
	     LPPROCESS_INFORMATION pi)
{
  char *full_executable;
  char *cmdline;
  char **env_copy;
  char *env_block = NULL;

  full_executable = NULL;
  cmdline = NULL;

  if (env)
    {
      int env_size;

      /* Count the number of environment bindings supplied.  */
      for (env_size = 0; env[env_size]; env_size++)
        continue;
    
      /* Assemble an environment block, if required.  This consists of
         VAR=VALUE strings juxtaposed (with one null character between each
         pair) and an additional null at the end.  */
      if (env_size > 0)
        {
          int var;
          int total_size = 1; /* 1 is for the final null.  */
          char *bufptr;
    
          /* Windows needs the members of the block to be sorted by variable
             name.  */
          env_copy = (char **) alloca (sizeof (char *) * env_size);
          memcpy (env_copy, env, sizeof (char *) * env_size);
          qsort (env_copy, env_size, sizeof (char *), env_compare);
    
          for (var = 0; var < env_size; var++)
            total_size += strlen (env[var]) + 1;
    
          env_block = XNEWVEC (char, total_size);
          bufptr = env_block;
          for (var = 0; var < env_size; var++)
            bufptr = stpcpy (bufptr, env_copy[var]) + 1;
    
          *bufptr = '\0';
        }
    }

  full_executable = find_executable (executable, search);
  if (!full_executable)
    goto error;
  cmdline = argv_to_cmdline (argv);
  if (!cmdline)
    goto error;
    
  /* Create the child process.  */  
  if (!CreateProcess (full_executable, cmdline, 
		      /*lpProcessAttributes=*/NULL,
		      /*lpThreadAttributes=*/NULL,
		      /*bInheritHandles=*/TRUE,
		      dwCreationFlags,
		      (LPVOID) env_block,
		      /*lpCurrentDirectory=*/NULL,
		      si,
		      pi))
    {
      free (env_block);

      free (full_executable);

      return (pid_t) -1;
    }

  /* Clean up.  */
  CloseHandle (pi->hThread);
  free (full_executable);
  free (env_block);

  return (pid_t) pi->hProcess;

 error:
  free (env_block);
  free (cmdline);
  free (full_executable);

  return (pid_t) -1;
}

/* Spawn a script.  This simulates the Unix script execution mechanism.
   This function is called as a fallback if win32_spawn fails. */

static pid_t
spawn_script (const char *executable, char *const *argv,
              char* const *env,
	      DWORD dwCreationFlags,
	      LPSTARTUPINFO si,
	      LPPROCESS_INFORMATION pi)
{
  pid_t pid = (pid_t) -1;
  int save_errno = errno;
  int fd = _open (executable, _O_RDONLY);

  /* Try to open script, check header format, extract interpreter path,
     and spawn script using that interpretter. */
  if (fd >= 0)
    {
      char buf[MAX_PATH + 5];
      int len = _read (fd, buf, sizeof (buf) - 1);
      _close (fd);
      if (len > 3)
	{
	  char *eol;
	  buf[len] = '\0';
	  eol = strchr (buf, '\n');
	  if (eol && strncmp (buf, "#!", 2) == 0)
	    {
            
	      /* Header format is OK. */
	      char *executable1;
              int new_argc;
              const char **avhere;

	      /* Extract interpreter path. */
	      do
		*eol = '\0';
	      while (*--eol == '\r' || *eol == ' ' || *eol == '\t');
	      for (executable1 = buf + 2; *executable1 == ' ' || *executable1 == '\t'; executable1++)
		continue;
	      backslashify (executable1);

	      /* Duplicate argv, prepending the interpreter path. */
	      new_argc = argv_to_argc (argv) + 1;
	      avhere = XNEWVEC (const char *, new_argc + 1);
	      *avhere = executable1;
	      memcpy (avhere + 1, argv, new_argc * sizeof(*argv));
	      argv = (char *const *)avhere;

	      /* Spawn the child. */
#ifndef USE_MINGW_MSYS
	      executable = strrchr (executable1, '\\') + 1;
	      if (!executable)
		executable = executable1;
	      pid = win32_spawn (executable, TRUE, argv, env,
				 dwCreationFlags, si, pi);
#else
	      if (strchr (executable1, '\\') == NULL)
		pid = win32_spawn (executable1, TRUE, argv, env,
				   dwCreationFlags, si, pi);
	      else if (executable1[0] != '\\')
		pid = win32_spawn (executable1, FALSE, argv, env,
				   dwCreationFlags, si, pi);
	      else
		{
		  const char *newex = mingw_rootify (executable1);
		  *avhere = newex;
		  pid = win32_spawn (newex, FALSE, argv, env,
				     dwCreationFlags, si, pi);
		  if (executable1 != newex)
		    free ((char *) newex);
		  if (pid == (pid_t) -1)
		    {
		      newex = msys_rootify (executable1);
		      if (newex != executable1)
			{
			  *avhere = newex;
			  pid = win32_spawn (newex, FALSE, argv, env,
					     dwCreationFlags, si, pi);
			  free ((char *) newex);
			}
		    }
		}
#endif
	      free (avhere);
	    }
	}
    }
  if (pid == (pid_t) -1)
    errno = save_errno;
  return pid;
}

/* Execute a child.  */

static pid_t
pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,
		      const char *executable, char * const * argv,
                      char* const* env,
		      int in, int out, int errdes,
		      int toclose ATTRIBUTE_UNUSED,
		      const char **errmsg,
		      int *err)
{
  pid_t pid;
  HANDLE stdin_handle;
  HANDLE stdout_handle;
  HANDLE stderr_handle;
  DWORD dwCreationFlags;
  OSVERSIONINFO version_info;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  int orig_out, orig_in, orig_err;
  BOOL separate_stderr = !(flags & PEX_STDERR_TO_STDOUT);

  /* Ensure we have inheritable descriptors to pass to the child.  */
  orig_in = in;
  in = _dup (orig_in);
  
  orig_out = out;
  out = _dup (orig_out);
  
  if (separate_stderr)
    {
      orig_err = errdes;
      errdes = _dup (orig_err);
    }

  stdin_handle = INVALID_HANDLE_VALUE;
  stdout_handle = INVALID_HANDLE_VALUE;
  stderr_handle = INVALID_HANDLE_VALUE;

  stdin_handle = (HANDLE) _get_osfhandle (in);
  stdout_handle = (HANDLE) _get_osfhandle (out);
  if (separate_stderr)
    stderr_handle = (HANDLE) _get_osfhandle (errdes);
  else
    stderr_handle = stdout_handle;

  /* Determine the version of Windows we are running on.  */
  version_info.dwOSVersionInfoSize = sizeof (version_info); 
  GetVersionEx (&version_info);
  if (version_info.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    /* On Windows 95/98/ME the CREATE_NO_WINDOW flag is not
       supported, so we cannot avoid creating a console window.  */
    dwCreationFlags = 0;
  else
    {
      HANDLE conout_handle;

      /* Determine whether or not we have an associated console.  */
      conout_handle = CreateFile("CONOUT$", 
				 GENERIC_WRITE,
				 FILE_SHARE_WRITE,
				 /*lpSecurityAttributes=*/NULL,
				 OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL,
				 /*hTemplateFile=*/NULL);
      if (conout_handle == INVALID_HANDLE_VALUE)
	/* There is no console associated with this process.  Since
	   the child is a console process, the OS would normally
	   create a new console Window for the child.  Since we'll be
	   redirecting the child's standard streams, we do not need
	   the console window.  */ 
	dwCreationFlags = CREATE_NO_WINDOW;
      else 
	{
	  /* There is a console associated with the process, so the OS
	     will not create a new console.  And, if we use
	     CREATE_NO_WINDOW in this situation, the child will have
	     no associated console.  Therefore, if the child's
	     standard streams are connected to the console, the output
	     will be discarded.  */
	  CloseHandle(conout_handle);
	  dwCreationFlags = 0;
	}
    }

  /* Since the child will be a console process, it will, by default,
     connect standard input/output to its console.  However, we want
     the child to use the handles specifically designated above.  In
     addition, if there is no console (such as when we are running in
     a Cygwin X window), then we must redirect the child's
     input/output, as there is no console for the child to use.  */
  memset (&si, 0, sizeof (si));
  si.cb = sizeof (si);
  si.dwFlags = STARTF_USESTDHANDLES;
  si.hStdInput = stdin_handle;
  si.hStdOutput = stdout_handle;
  si.hStdError = stderr_handle;

  /* Create the child process.  */  
  pid = win32_spawn (executable, (flags & PEX_SEARCH) != 0,
		     argv, env, dwCreationFlags, &si, &pi);
  if (pid == (pid_t) -1)
    pid = spawn_script (executable, argv, env, dwCreationFlags,
                        &si, &pi);
  if (pid == (pid_t) -1)
    {
      *err = ENOENT;
      *errmsg = "CreateProcess";
    }

  /* If the child was created successfully, close the original file
     descriptors.  If the process creation fails, these are closed by
     pex_run_in_environment instead.  We must not close them twice as
     that seems to cause a Windows exception.  */
     
  if (pid != (pid_t) -1)
    {
      if (orig_in != STDIN_FILENO)
	_close (orig_in);
      if (orig_out != STDOUT_FILENO)
	_close (orig_out);
      if (separate_stderr
	  && orig_err != STDERR_FILENO)
	_close (orig_err);
    }

  /* Close the standard input, standard output and standard error handles
     in the parent.  */ 

  _close (in);
  _close (out);
  if (separate_stderr)
    _close (errdes);

  return pid;
}

/* Wait for a child process to complete.  MS CRTDLL doesn't return
   enough information in status to decide if the child exited due to a
   signal or not, rather it simply returns an integer with the exit
   code of the child; eg., if the child exited with an abort() call
   and didn't have a handler for SIGABRT, it simply returns with
   status == 3.  We fix the status code to conform to the usual WIF*
   macros.  Note that WIFSIGNALED will never be true under CRTDLL. */

static pid_t
pex_win32_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, pid_t pid,
		int *status, struct pex_time *time, int done ATTRIBUTE_UNUSED,
		const char **errmsg, int *err)
{
  DWORD termstat;
  HANDLE h;

  if (time != NULL)
    memset (time, 0, sizeof *time);

  h = (HANDLE) pid;

  /* FIXME: If done is non-zero, we should probably try to kill the
     process.  */
  if (WaitForSingleObject (h, INFINITE) != WAIT_OBJECT_0)
    {
      CloseHandle (h);
      *err = ECHILD;
      *errmsg = "WaitForSingleObject";
      return -1;
    }

  GetExitCodeProcess (h, &termstat);
  CloseHandle (h);
 
  /* A value of 3 indicates that the child caught a signal, but not
     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we
     report SIGABRT.  */
  if (termstat == 3)
    *status = SIGABRT;
  else
    *status = (termstat & 0xff) << 8;

  return 0;
}

/* Create a pipe.  */

static int
pex_win32_pipe (struct pex_obj *obj ATTRIBUTE_UNUSED, int *p,
		int binary)
{
  return _pipe (p, 256, (binary ? _O_BINARY : _O_TEXT) | _O_NOINHERIT);
}

/* Get a FILE pointer to read from a file descriptor.  */

static FILE *
pex_win32_fdopenr (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,
		   int binary)
{
  HANDLE h = (HANDLE) _get_osfhandle (fd);
  if (h == INVALID_HANDLE_VALUE)
    return NULL;
  if (! SetHandleInformation (h, HANDLE_FLAG_INHERIT, 0))
    return NULL;
  return fdopen (fd, binary ? "rb" : "r");
}

static FILE *
pex_win32_fdopenw (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,
		   int binary)
{
  HANDLE h = (HANDLE) _get_osfhandle (fd);
  if (h == INVALID_HANDLE_VALUE)
    return NULL;
  if (! SetHandleInformation (h, HANDLE_FLAG_INHERIT, 0))
    return NULL;
  return fdopen (fd, binary ? "wb" : "w");
}

#ifdef MAIN
#include <stdio.h>

int
main (int argc ATTRIBUTE_UNUSED, char **argv)
{
  char const *errmsg;
  int err;
  argv++;
  printf ("%ld\n", (long) pex_win32_exec_child (NULL, PEX_SEARCH, argv[0], argv, NULL, 0, 0, 1, 2, &errmsg, &err));
  exit (0);
}
#endif
@


1.24
log
@merge from gcc
@
text
@d81 1
a81 1
static int pex_win32_open_write (struct pex_obj *, const char *, int);
d129 1
a129 1
		      int binary)
d133 2
@


1.23
log
@merge from gcc
@
text
@d343 1
d348 3
a350 2
      /* We quote every last argument.  This simplifies the problem;
	 we need only escape embedded double-quotes and immediately
d354 1
d357 5
d373 5
a377 2
      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
	cmdline_len++;
d379 2
a380 1
      cmdline_len += 3;  /* for leading and trailing quotes and space */
d386 14
a399 1
      *p++ = '"';
d410 6
a415 3
      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
	*p++ = '\\';
      *p++ = '"';
@


1.22
log
@merge from gcc
@
text
@d744 1
a744 2
  /* Ensure we have inheritable descriptors to pass to the child, and close the
     original descriptors.  */
a746 2
  if (orig_in != STDIN_FILENO)
    _close (orig_in);
a749 2
  if (orig_out != STDOUT_FILENO)
    _close (orig_out);
a754 2
      if (orig_err != STDERR_FILENO)
	_close (orig_err);
d832 16
@


1.21
log
@2009-05-29  Kai Tietz  <kai.tietz@@onevision.com>

        * pex-win32.c (pex_win32_fdopenr): Set INHERIT to false.
@
text
@d213 2
a214 4
      if (namebuf)
	free (namebuf);
      if (foundbuf)
	free (foundbuf);
d316 1
a316 2
  if (buf)
    free (buf);
d607 1
a607 2
      if (env_block)
        free (env_block);
d617 1
a617 2
  if (env_block)
    free (env_block);
d622 3
a624 6
  if (env_block)
    free (env_block);
  if (cmdline)
    free (cmdline);
  if (full_executable)
    free (full_executable);
@


1.20
log
@	libiberty/
	* pex-win32.c (pex_win32_exec_child): Fix logic to avoid closing
	standard handles (stdin, stdout, stderr) in parent.
@
text
@d918 5
@


1.19
log
@	libiberty/
	* pex-win32.c (pex_win32_pipe): Add _O_NOINHERIT.
	(pex_win32_exec_child): Ensure each process has only one handle open
	on pipe endpoints. Close standard input after creating child
	for symmetry with standard output/standard error.
@
text
@d756 2
a757 1
  _close (orig_in);
d761 2
a762 1
  _close (orig_out);
d768 2
a769 1
      _close (orig_err);
d850 3
a852 5
  if (in != STDIN_FILENO)
    _close (in);
  if (out != STDOUT_FILENO)
    _close (out);
  if (errdes != STDERR_FILENO)
@


1.18
log
@Merged from gcc head revision 146001.
2009-04-13  Ozkan Sezer  <sezeroz@@gmail.com>

        PR target/39397
        * pex-common.h (struct pex_obj): Store pid values as pid_t,
        not as long (members *children and (*wait))
        * pex-common.c (pex_run_in_environment): Likewise.
        * pex-win32.c (pex_win32_wait): Return pid_t and properly check
        returned pid value.
        * pex-djgpp.c (pex_djgpp_wait): Return pid_t.
        * pex-msdos.c (pex_msdos_wait): Likewise.
@
text
@d749 19
d775 1
a775 1
  if (!(flags & PEX_STDERR_TO_STDOUT))
d844 5
a848 2
  /* Close the standard output and standard error handles in the
     parent.  */ 
d850 1
a850 1
    obj->funcs->close (obj, out);
d852 1
a852 1
    obj->funcs->close (obj, errdes);
d908 1
a908 1
  return _pipe (p, 256, binary ? _O_BINARY : _O_TEXT);
@


1.17
log
@merge from gcc
@
text
@d87 1
a87 1
static int pex_win32_wait (struct pex_obj *, pid_t, int *,
d708 1
a708 1
		  if ((long) pid < 0)
d725 1
a725 1
  if ((long) pid < 0)
d843 1
a843 1
static int
@


1.16
log
@merge from gcc
@
text
@d324 12
d537 3
d637 3
d651 2
d665 2
d668 4
a671 1
	      const char ** avhere = (const char **) --argv;
d677 1
d679 3
a681 1
	      backslashify (executable1);
d683 4
d721 1
@


1.15
log
@2006-11-08  Vladimir Prus  <vladimir@@codesourcery.com>

        * pex-win32.c (no_suffixes): Remove.
        (std_suffixes): Add "" as first element.
        (find_executable): Remove detection of already-present
        extension. Try all suffixes in std_suffixes.
@
text
@d82 1
a82 1
static long pex_win32_exec_child (struct pex_obj *, int, const char *,
d87 1
a87 1
static int pex_win32_wait (struct pex_obj *, long, int *,
d525 1
a525 1
static long
d600 1
a600 1
      return -1;
d609 1
a609 1
  return (long) pi->hProcess;
d619 1
a619 1
  return -1;
d622 1
a622 1
static long
d629 1
a629 1
  int pid = -1;
d676 1
a676 1
		  if (pid < 0)
d692 1
a692 1
  if (pid < 0)
d699 1
a699 1
static long
d708 1
a708 1
  long pid;
d783 1
a783 1
  if (pid == -1)
d786 1
a786 1
  if (pid == -1)
d811 1
a811 1
pex_win32_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, long pid,
d886 1
a886 1
  printf ("%ld\n", pex_win32_exec_child (NULL, PEX_SEARCH, argv[0], argv, NULL, 0, 0, 1, 2, &errmsg, &err));
@


1.14
log
@merge from gcc
@
text
@d385 6
a396 4
  0
};
static const char *const
no_suffixes[] = {
a413 1
  int has_extension = !!strchr (program, '.');
d436 1
a436 1
  fe_len = fe_len + 1 + proglen + (has_extension ? 1 : 5);
d462 1
a462 1
      for (ext = has_extension ? no_suffixes : std_suffixes; *ext; ext++)
@


1.13
log
@merge from gcc
@
text
@d3 1
a3 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005
d361 1
a361 1
  cmdline = xmalloc (cmdline_len);
d436 1
a436 1
  full_executable = xmalloc (fe_len);
d560 1
a560 1
          env_copy = alloca (sizeof (char *) * env_size);
d567 1
a567 1
          env_block = malloc (total_size);
@


1.12
log
@merge from gcc
@
text
@d84 1
a84 1
                                  int, int, int,
d702 3
a704 1
		      int in, int out, int errdes, const char **errmsg,
@


1.11
log
@merge from gcc
@
text
@d39 1
d46 1
d64 2
d83 2
a84 1
				  char * const *, int, int, int,
d486 37
a522 1
/* Low-level process creation function.  */
d528 1
d535 2
d541 35
d589 1
a589 1
		      /*lpEnvironment=*/NULL,
d594 3
d598 1
d605 2
d611 2
d617 1
d623 1
d658 1
a658 1
	      pid = win32_spawn (executable, TRUE, argv, 
d662 1
a662 1
		pid = win32_spawn (executable1, TRUE, argv, 
d665 1
a665 1
		pid = win32_spawn (executable1, FALSE, argv, 
d671 1
a671 1
		  pid = win32_spawn (newex, FALSE, argv, 
d681 1
a681 1
			  pid = win32_spawn (newex, FALSE, argv, 
d701 1
d779 1
a779 1
		     argv, dwCreationFlags, &si, &pi);
d781 2
a782 1
    pid = spawn_script (executable, argv, dwCreationFlags, &si, &pi);
d883 1
a883 1
  printf ("%ld\n", pex_win32_exec_child (NULL, PEX_SEARCH, argv[0], argv, 0, 1, 2, &errmsg, &err));
@


1.10
log
@merge from gcc
@
text
@d86 1
d99 1
d771 12
@


1.9
log
@merge from gcc
@
text
@d44 1
a75 109
/* This is a kludge to get around the Microsoft C spawn functions' propensity
   to remove the outermost set of double quotes from all arguments.  */

static const char * const *
fix_argv (char * const *argvec)
{
  char **argv;
  int i;
  char *command0;

  /* See whether we need to change anything.  */
  for (command0 = argvec[0]; *command0 != '\0'; command0++)
    if (*command0 == '/')
      break;
  if (*command0 == '\0')
    {
      for (i = 1; argvec[i] != NULL; i++)
	if (strpbrk (argvec[i], "\" \t") != NULL)
	  break;

      if (argvec[i] == NULL)
	return (const char * const *) argvec;
    }

  for (i = 0; argvec[i] != NULL; i++)
    ;
  argv = XNEWVEC (char *, i + 2);

  argv++;	/* Leave space at the beginning of argv
		   for potential #! handling */

  for (i = 0; argvec[i] != NULL; i++)
    argv[i] = xstrdup (argvec[i]);
  argv[i] = NULL;

  backslashify (argv[0]);

  for (i = 1; argv[i] != 0; i++)
    {
      int len, j;
      char *temp, *newtemp;

      temp = argv[i];
      len = strlen (temp);
      for (j = 0; j < len; j++)
        {
          if (temp[j] == '"')
            {
              newtemp = XNEWVEC (char, len + 2);
              strncpy (newtemp, temp, j);
              newtemp [j] = '\\';
              strncpy (&newtemp [j+1], &temp [j], len-j);
              newtemp [len+1] = 0;
              temp = newtemp;
              len++;
              j++;
            }
        }

      if (argv[i] != temp)
	{
	  free (argv[i]);
	  argv[i] = temp;
	}
    }

  for (i = 0; argv[i] != 0; i++)
    {
      if (strpbrk (argv[i], " \t"))
        {
	  int len, trailing_backslash;
	  char *temp;

	  len = strlen (argv[i]);
	  trailing_backslash = 0;

	  /* There is an added complication when an arg with embedded white
	     space ends in a backslash (such as in the case of -iprefix arg
	     passed to cpp). The resulting quoted strings gets misinterpreted
	     by the command interpreter -- it thinks that the ending quote
	     is escaped by the trailing backslash and things get confused.
	     We handle this case by escaping the trailing backslash, provided
	     it was not escaped in the first place.  */
	  if (len > 1
	      && argv[i][len-1] == '\\'
	      && argv[i][len-2] != '\\')
	    {
	      trailing_backslash = 1;
	      ++len;			/* to escape the final backslash. */
	    }

	  len += 2;			/* and for the enclosing quotes. */

	  temp = XNEWVEC (char, len + 1);
	  temp[0] = '"';
	  strcpy (temp + 1, argv[i]);
	  if (trailing_backslash)
	    temp[len - 2] = '\\';
	  temp[len - 1] = '"';
	  temp[len] = '\0';

	  free (argv[i]);
	  argv[i] = temp;
	}
    }

  return (const char * const *) argv;
}

d317 214
d532 4
a535 1
spawn_script (const char *executable, const char * const * argv)
d567 2
a568 1
	      pid = _spawnvp (_P_NOWAIT, executable, argv);
d571 2
a572 1
		pid = _spawnvp (_P_NOWAIT, executable1, argv);
d574 2
a575 1
		pid = _spawnv (_P_NOWAIT, executable1, argv);
d580 2
a581 1
		  pid = _spawnv (_P_NOWAIT, newex, argv);
d590 2
a591 1
			  pid = _spawnv (_P_NOWAIT, newex, argv);
a612 1
  int org_in, org_out, org_errdes;
d614 18
a631 1
  const char * const * newargv;
d633 8
a640 5
  org_in = -1;
  org_out = -1;
  org_errdes = -1;

  if (in != STDIN_FILE_NO)
d642 1
a642 43
      org_in = _dup (STDIN_FILE_NO);
      if (org_in < 0)
	{
	  *err = errno;
	  *errmsg = "_dup";
	  return -1;
	}
      if (_dup2 (in, STDIN_FILE_NO) < 0)
	{
	  *err = errno;
	  *errmsg = "_dup2";
	  return -1;
	}
      if (_close (in) < 0)
	{
	  *err = errno;
	  *errmsg = "_close";
	  return -1;
	}
    }

  if (out != STDOUT_FILE_NO)
    {
      org_out = _dup (STDOUT_FILE_NO);
      if (org_out < 0)
	{
	  *err = errno;
	  *errmsg = "_dup";
	  return -1;
	}
      if (_dup2 (out, STDOUT_FILE_NO) < 0)
	{
	  *err = errno;
	  *errmsg = "_dup2";
	  return -1;
	}
      if (_close (out) < 0)
	{
	  *err = errno;
	  *errmsg = "_close";
	  return -1;
	}
    }
d644 25
a668 25
  if (errdes != STDERR_FILE_NO
      || (flags & PEX_STDERR_TO_STDOUT) != 0)
    {
      org_errdes = _dup (STDERR_FILE_NO);
      if (org_errdes < 0)
	{
	  *err = errno;
	  *errmsg = "_dup";
	  return -1;
	}
      if (_dup2 ((flags & PEX_STDERR_TO_STDOUT) != 0 ? STDOUT_FILE_NO : errdes,
		 STDERR_FILE_NO) < 0)
	{
	  *err = errno;
	  *errmsg = "_dup2";
	  return -1;
	}
      if (errdes != STDERR_FILE_NO)
	{
	  if (_close (errdes) < 0)
	    {
	      *err = errno;
	      *errmsg = "_close";
	      return -1;
	    }
d672 16
a687 4
  newargv = fix_argv (argv);
  pid = (((flags & PEX_SEARCH) != 0 ? _spawnvp : _spawnv)
	 (_P_NOWAIT, executable, newargv));

d689 1
a689 2
    pid = spawn_script (executable, newargv);

d692 2
a693 34
      *err = errno;
      *errmsg = ((flags & PEX_SEARCH) != 0) ? "_spawnvp" : "_spawnv";
    }

  if (in != STDIN_FILE_NO)
    {
      if (_dup2 (org_in, STDIN_FILE_NO) < 0)
	{
	  *err = errno;
	  *errmsg = "_dup2";
	  return -1;
	}
      if (_close (org_in) < 0)
	{
	  *err = errno;
	  *errmsg = "_close";
	  return -1;
	}
    }

  if (out != STDOUT_FILE_NO)
    {
      if (_dup2 (org_out, STDOUT_FILE_NO) < 0)
	{
	  *err = errno;
	  *errmsg = "_dup2";
	  return -1;
	}
      if (_close (org_out) < 0)
	{
	  *err = errno;
	  *errmsg = "_close";
	  return -1;
	}
d696 6
a701 16
  if (errdes != STDERR_FILE_NO
      || (flags & PEX_STDERR_TO_STDOUT) != 0)
    {
      if (_dup2 (org_errdes, STDERR_FILE_NO) < 0)
	{
	  *err = errno;
	  *errmsg = "_dup2";
	  return -1;
	}
      if (_close (org_errdes) < 0)
	{
	  *err = errno;
	  *errmsg = "_close";
	  return -1;
	}
    }
d719 2
a720 1
  int termstat;
d725 2
d729 1
a729 2

  if (_cwait (&termstat, pid, WAIT_CHILD) < 0)
d731 3
a733 2
      *err = errno;
      *errmsg = "_cwait";
d737 6
a742 5
  /* cwait returns the child process exit code in termstat.  A value
     of 3 indicates that the child caught a signal, but not which one.
     Since only SIGABRT, SIGFPE and SIGINT do anything, we report
     SIGABRT.  */

d746 1
a746 1
    *status = ((termstat & 0xff) << 8);
@


1.9.14.1
log
@	* libiberty/pex-win32.c (<errno.h>): Include.
	(fix_argv): Remove.
	(argv_to_cmdline): New function.
	(std_suffixes): New variable.
	(no_suffixes): Likewise.
	(find_executable): New function.
	(win32_spawn): Likewise.
	(spawn_script): Use win32_spawn instead of _spawnv[p].
	(pex_win32_exec_child): Replace MSVCRT calls with Win32 API calls.
	(pex_win32_wait): Likewise.
@
text
@a43 1
#include <errno.h>
d75 109
a424 214
/* Return a Windows command-line from ARGV.  It is the caller's
   responsibility to free the string returned.  */

static char *
argv_to_cmdline (char *const *argv)
{
  char *cmdline;
  char *p;
  size_t cmdline_len;
  int i, j, k;

  cmdline_len = 0;
  for (i = 0; argv[i]; i++)
    {
      /* We quote every last argument.  This simplifies the problem;
	 we need only escape embedded double-quotes and immediately
	 preceeding backslash characters.  A sequence of backslach characters
	 that is not follwed by a double quote character will not be
	 escaped.  */
      for (j = 0; argv[i][j]; j++)
	{
	  if (argv[i][j] == '"')
	    {
	      /* Escape preceeding backslashes.  */
	      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
		cmdline_len++;
	      /* Escape the qote character.  */
	      cmdline_len++;
	    }
	}
      /* Trailing backslashes also need to be escaped because they will be
         followed by the terminating quote.  */
      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
	cmdline_len++;
      cmdline_len += j;
      cmdline_len += 3;  /* for leading and trailing quotes and space */
    }
  cmdline = xmalloc (cmdline_len);
  p = cmdline;
  for (i = 0; argv[i]; i++)
    {
      *p++ = '"';
      for (j = 0; argv[i][j]; j++)
	{
	  if (argv[i][j] == '"')
	    {
	      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
		*p++ = '\\';
	      *p++ = '\\';
	    }
	  *p++ = argv[i][j];
	}
      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
	*p++ = '\\';
      *p++ = '"';
      *p++ = ' ';
    }
  p[-1] = '\0';
  return cmdline;
}

static const char *const
std_suffixes[] = {
  ".com",
  ".exe",
  ".bat",
  ".cmd",
  0
};
static const char *const
no_suffixes[] = {
  "",
  0
};

/* Returns the full path to PROGRAM.  If SEARCH is true, look for
   PROGRAM in each directory in PATH.  */

static char *
find_executable (const char *program, BOOL search)
{
  char *full_executable;
  char *e;
  size_t fe_len;
  const char *path = 0;
  const char *const *ext;
  const char *p, *q;
  size_t proglen = strlen (program);
  int has_extension = !!strchr (program, '.');
  int has_slash = (strchr (program, '/') || strchr (program, '\\'));
  HANDLE h;

  if (has_slash)
    search = FALSE;

  if (search)
    path = getenv ("PATH");
  if (!path)
    path = "";

  fe_len = 0;
  for (p = path; *p; p = q)
    {
      q = p;
      while (*q != ';' && *q != '\0')
	q++;
      if ((size_t)(q - p) > fe_len)
	fe_len = q - p;
      if (*q == ';')
	q++;
    }
  fe_len = fe_len + 1 + proglen + (has_extension ? 1 : 5);
  full_executable = xmalloc (fe_len);

  p = path;
  do
    {
      q = p;
      while (*q != ';' && *q != '\0')
	q++;

      e = full_executable;
      memcpy (e, p, q - p);
      e += (q - p);
      if (q - p)
	*e++ = '\\';
      strcpy (e, program);

      if (*q == ';')
	q++;

      for (e = full_executable; *e; e++)
	if (*e == '/')
	  *e = '\\';

      /* At this point, e points to the terminating NUL character for
         full_executable.  */
      for (ext = has_extension ? no_suffixes : std_suffixes; *ext; ext++)
	{
	  /* Remove any current extension.  */
	  *e = '\0';
	  /* Add the new one.  */
	  strcat (full_executable, *ext);

	  /* Attempt to open this file.  */
	  h = CreateFile (full_executable, GENERIC_READ,
			  FILE_SHARE_READ | FILE_SHARE_WRITE,
			  0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	  if (h != INVALID_HANDLE_VALUE)
	    goto found;
	}
      p = q;
    }
  while (*p);
  free (full_executable);
  return 0;

 found:
  CloseHandle (h);
  return full_executable;
}

/* Low-level process creation function.  */

static long
win32_spawn (const char *executable,
	     BOOL search,
	     char *const *argv,
	     DWORD dwCreationFlags,
	     LPSTARTUPINFO si,
	     LPPROCESS_INFORMATION pi)
{
  char *full_executable;
  char *cmdline;

  full_executable = NULL;
  cmdline = NULL;

  full_executable = find_executable (executable, search);
  if (!full_executable)
    goto error;
  cmdline = argv_to_cmdline (argv);
  if (!cmdline)
    goto error;
    
  /* Create the child process.  */  
  if (!CreateProcess (full_executable, cmdline, 
		      /*lpProcessAttributes=*/NULL,
		      /*lpThreadAttributes=*/NULL,
		      /*bInheritHandles=*/TRUE,
		      dwCreationFlags,
		      /*lpEnvironment=*/NULL,
		      /*lpCurrentDirectory=*/NULL,
		      si,
		      pi))
    {
      free (full_executable);
      return -1;
    }

  /* Clean up.  */
  CloseHandle (pi->hThread);
  free (full_executable);

  return (long) pi->hProcess;

 error:
  if (cmdline)
    free (cmdline);
  if (full_executable)
    free (full_executable);
  return -1;
}

d426 1
a426 4
spawn_script (const char *executable, char *const *argv,
	      DWORD dwCreationFlags,
	      LPSTARTUPINFO si,
	      LPPROCESS_INFORMATION pi)
d458 1
a458 2
	      pid = win32_spawn (executable, TRUE, argv, 
				 dwCreationFlags, si, pi);
d461 1
a461 2
		pid = win32_spawn (executable1, TRUE, argv, 
				   dwCreationFlags, si, pi);
d463 1
a463 2
		pid = win32_spawn (executable1, FALSE, argv, 
				   dwCreationFlags, si, pi);
d468 1
a468 2
		  pid = win32_spawn (newex, FALSE, argv, 
				     dwCreationFlags, si, pi);
d477 1
a477 2
			  pid = win32_spawn (newex, FALSE, argv, 
					     dwCreationFlags, si, pi);
d499 1
d501 5
a505 18
  HANDLE stdin_handle;
  HANDLE stdout_handle;
  HANDLE stderr_handle;
  DWORD dwCreationFlags;
  OSVERSIONINFO version_info;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  stdin_handle = INVALID_HANDLE_VALUE;
  stdout_handle = INVALID_HANDLE_VALUE;
  stderr_handle = INVALID_HANDLE_VALUE;

  stdin_handle = (HANDLE) _get_osfhandle (in);
  stdout_handle = (HANDLE) _get_osfhandle (out);
  if (!(flags & PEX_STDERR_TO_STDOUT))
    stderr_handle = (HANDLE) _get_osfhandle (errdes);
  else
    stderr_handle = stdout_handle;
d507 1
a507 8
  /* Determine the version of Windows we are running on.  */
  version_info.dwOSVersionInfoSize = sizeof (version_info); 
  GetVersionEx (&version_info);
  if (version_info.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    /* On Windows 95/98/ME the CREATE_NO_WINDOW flag is not
       supported, so we cannot avoid creating a console window.  */
    dwCreationFlags = 0;
  else
d509 20
a528 1
      HANDLE conout_handle;
d530 48
a577 25
      /* Determine whether or not we have an associated console.  */
      conout_handle = CreateFile("CONOUT$", 
				 GENERIC_WRITE,
				 FILE_SHARE_WRITE,
				 /*lpSecurityAttributes=*/NULL,
				 OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL,
				 /*hTemplateFile=*/NULL);
      if (conout_handle == INVALID_HANDLE_VALUE)
	/* There is no console associated with this process.  Since
	   the child is a console process, the OS would normally
	   create a new console Window for the child.  Since we'll be
	   redirecting the child's standard streams, we do not need
	   the console window.  */ 
	dwCreationFlags = CREATE_NO_WINDOW;
      else 
	{
	  /* There is a console associated with the process, so the OS
	     will not create a new console.  And, if we use
	     CREATE_NO_WINDOW in this situation, the child will have
	     no associated console.  Therefore, if the child's
	     standard streams are connected to the console, the output
	     will be discarded.  */
	  CloseHandle(conout_handle);
	  dwCreationFlags = 0;
d581 4
a584 16
  /* Since the child will be a console process, it will, by default,
     connect standard input/output to its console.  However, we want
     the child to use the handles specifically designated above.  In
     addition, if there is no console (such as when we are running in
     a Cygwin X window), then we must redirect the child's
     input/output, as there is no console for the child to use.  */
  memset (&si, 0, sizeof (si));
  si.cb = sizeof (si);
  si.dwFlags = STARTF_USESTDHANDLES;
  si.hStdInput = stdin_handle;
  si.hStdOutput = stdout_handle;
  si.hStdError = stderr_handle;

  /* Create the child process.  */  
  pid = win32_spawn (executable, (flags & PEX_SEARCH) != 0,
		     argv, dwCreationFlags, &si, &pi);
d586 2
a587 1
    pid = spawn_script (executable, argv, dwCreationFlags, &si, &pi);
d590 51
a640 2
      *err = ENOENT;
      *errmsg = "CreateProcess";
d659 1
a659 2
  DWORD termstat;
  HANDLE h;
a663 2
  h = (HANDLE) pid;

d666 2
a667 1
  if (WaitForSingleObject (h, INFINITE) != WAIT_OBJECT_0)
d669 2
a670 3
      CloseHandle (h);
      *err = ECHILD;
      *errmsg = "WaitForSingleObject";
d674 5
a678 6
  GetExitCodeProcess (h, &termstat);
  CloseHandle (h);
 
  /* A value of 3 indicates that the child caught a signal, but not
     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we
     report SIGABRT.  */
d682 1
a682 1
    *status = (termstat & 0xff) << 8;
@


1.9.14.2
log
@	* libiberty/pex-win32.c (pex_win32_exec_child): Close stdout/stderr
	in parent.
@
text
@a695 7
  /* Close the standard output and standard error handles in the
     parent.  */ 
  if (out != STDOUT_FILENO)
    obj->funcs->close (obj, out);
  if (errdes != STDERR_FILENO)
    obj->funcs->close (obj, errdes);

@


1.9.14.3
log
@	* libiberty/configure.ac: Add cygpath for mingw hosts.
	* libiberty.configure: Rebuilt.
	* libiberty/Makefile.in: Add cygpath.
	* libiberty/cygpath.c: New.

	* include/libiberty.h (pex_write_input): New declaration.

	* libiberty/pex-common.c (pex_write_input): New function.
	* libiberty/pexecute.txh (pex_write_input): Document it.
	* libiberty/pex-common.h (struct pex_funcs): New function ptr fdopenw.
	* libiberty/pex-unix.c (pex_unix_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* libiberty/pex-win32.c (pex_win32_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* libiberty/pex-djgpp.c (funcs): Leave fdopenw null.
	* libiberty/pex-msdos (funcs): Same.
	* libiberty/functions.texi: Regenerated.

	* libiberty/pex-common.h (struct pex_obj): Doc fixes.

	* libiberty/functions.texi: Regenerate.
@
text
@a85 1
static FILE *pex_win32_fdopenw (struct pex_obj *, int, int);
a97 1
  pex_win32_fdopenw,
a768 12
static FILE *
pex_win32_fdopenw (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,
		   int binary)
{
  HANDLE h = (HANDLE) _get_osfhandle (fd);
  if (h == INVALID_HANDLE_VALUE)
    return NULL;
  if (! SetHandleInformation (h, HANDLE_FLAG_INHERIT, 0))
    return NULL;
  return fdopen (fd, binary ? "wb" : "w");
}

@


1.9.14.4
log
@	include/
	* libiberty.h: Declare pex_run_in_environment.

	libiberty/
	* pex-common.c: New function pex_run_in_environment.
	* pex-common.h: Add environment parameter to exec_child.
	* pex-msdos.c: Add environment parameter to pex_msdos_exec_child.
	* pex-djgpp.c: Add environment parameter to pex_djgpp_exec_child.
	(pex_djgpp_exec_child): Pass environment to child process.
	* pex-unix.c: Add environment parameter to pex_unix_exec_child.
	(pex_unix_exec_child): Pass environment to child process.
	* pex-win32.c: Add environment parameter to pex_win32_exec_child.
	New function env_compare for comparing VAR=VALUE pairs.
	(win32_spawn): Assemble environment block and pass to CreateProcess.
	(spawn_script): Pass environment through to win32_spawn.
	(pex_win32_exec_child): Pass environment through to spawn_script and
	win32_spawn.
	* functions.texi: Regenerate.
	* pexecute.txh: Document pex_run_in_environment.
@
text
@a38 1
#include <assert.h>
a44 1
#include <ctype.h>
a61 2
extern char *stpcpy (char *dst, const char *src);

d79 1
a79 2
				  char * const *, char * const *,
                                  int, int, int,
d481 1
a481 37
/* Low-level process creation function and helper.  */

static int
env_compare (const void *a_ptr, const void *b_ptr)
{
  const char *a;
  const char *b;
  unsigned char c1;
  unsigned char c2;

  a = *(const char **) a_ptr;
  b = *(const char **) b_ptr;

  /* a and b will be of the form: VAR=VALUE
     We compare only the variable name part here using a case-insensitive
     comparison algorithm.  It might appear that in fact strcasecmp () can
     take the place of this whole function, and indeed it could, save for
     the fact that it would fail in cases such as comparing A1=foo and
     A=bar (because 1 is less than = in the ASCII character set).
     (Environment variables containing no numbers would work in such a
     scenario.)  */

  do
    {
      c1 = (unsigned char) tolower (*a++);
      c2 = (unsigned char) tolower (*b++);

      if (c1 == '=')
        c1 = '\0';

      if (c2 == '=')
        c2 = '\0';
    }
  while (c1 == c2 && c1 != '\0');

  return c1 - c2;
}
a486 1
             char *const *env, /* array of strings of the form: VAR=VALUE */
a492 2
  char **env_copy;
  char *env_block = NULL;
a496 35
  if (env)
    {
      int env_size;

      /* Count the number of environment bindings supplied.  */
      for (env_size = 0; env[env_size]; env_size++)
        continue;
    
      /* Assemble an environment block, if required.  This consists of
         VAR=VALUE strings juxtaposed (with one null character between each
         pair) and an additional null at the end.  */
      if (env_size > 0)
        {
          int var;
          int total_size = 1; /* 1 is for the final null.  */
          char *bufptr;
    
          /* Windows needs the members of the block to be sorted by variable
             name.  */
          env_copy = alloca (sizeof (char *) * env_size);
          memcpy (env_copy, env, sizeof (char *) * env_size);
          qsort (env_copy, env_size, sizeof (char *), env_compare);
    
          for (var = 0; var < env_size; var++)
            total_size += strlen (env[var]) + 1;
    
          env_block = malloc (total_size);
          bufptr = env_block;
          for (var = 0; var < env_size; var++)
            bufptr = stpcpy (bufptr, env_copy[var]) + 1;
    
          *bufptr = '\0';
        }
    }

d510 1
a510 1
		      (LPVOID) env_block,
a514 3
      if (env_block)
        free (env_block);

a515 1

a521 2
  if (env_block)
    free (env_block);
a525 2
  if (env_block)
    free (env_block);
a529 1

a534 1
              char* const *env,
d569 1
a569 1
	      pid = win32_spawn (executable, TRUE, argv, env,
d573 1
a573 1
		pid = win32_spawn (executable1, TRUE, argv, env,
d576 1
a576 1
		pid = win32_spawn (executable1, FALSE, argv, env,
d582 1
a582 1
		  pid = win32_spawn (newex, FALSE, argv, env,
d592 1
a592 1
			  pid = win32_spawn (newex, FALSE, argv, env,
a611 1
                      char* const* env,
d689 1
a689 1
		     argv, env, dwCreationFlags, &si, &pi);
d691 1
a691 2
    pid = spawn_script (executable, argv, env, dwCreationFlags,
                        &si, &pi);
d792 1
a792 1
  printf ("%ld\n", pex_win32_exec_child (NULL, PEX_SEARCH, argv[0], argv, NULL, 0, 0, 1, 2, &errmsg, &err));
@


1.9.14.5
log
@2006-11-08  Vladimir Prus  <vladimir@@codesourcery.com>

        * pex-win32.c (no_suffixes): Remove.
        (std_suffixes): Add "" as first element.
        (find_executable): Remove detection of already-present
        extension. Try all suffixes in std_suffixes.
@
text
@a384 6
/* We'll try the passed filename with all the known standard
   extensions, and then without extension.  We try no extension
   last so that we don't try to run some random extension-less
   file that might be hanging around.  We try both extension
   and no extension so that we don't need any fancy logic
   to determine if a file has extension.  */
d391 4
d412 1
d435 1
a435 1
  fe_len = fe_len + 1 + proglen + 5 /* space for extension */;
d461 1
a461 1
      for (ext = std_suffixes; *ext; ext++)
@


1.9.10.1
log
@gdb/ChangeLog:
2006-03-17  Jim Blandy  <jimb@@codesourcery.com>

	Add support for 'target remote |' on MinGW.
	* ser-mingw.c (struct pipe_state): New structure.
	(make_pipe_state, free_pipe_state, cleanup_pipe_state)
	(pipe_windows_open, pipe_windows_close, pipe_windows_read)
	(pipe_windows_write, pipe_wait_handle): New functions.
	(_initialize_ser_windows): Register a "pipe" interface based on
	them.

include/ChangeLog:
2006-03-15  Jim Blandy  <jimb@@codesourcery.com>

	* libiberty.h (pex_write_input): New declaration.

libiberty/ChangeLog:
2006-03-15  Jim Blandy  <jimb@@codesourcery.com>

	* pex-common.c (pex_write_input): New function.
	* pexecute.txh (pex_write_input): Document it.
	* pex-common.h (struct pex_funcs): New function ptr fdopenw.
	* pex-unix.c (pex_unix_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* pex-win32.c (pex_win32_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* pex-djgpp.c (funcs): Leave fdopenw null.
	* pex-msdos (funcs): Same.
	* functions.texi: Regenerated.

2006-03-12  Jim Blandy  <jimb@@red-bean.com>

	* pex-common.h (struct pex_obj): Doc fixes.

2006-03-11  Jim Blandy  <jimb@@red-bean.com>

	* functions.texi: Regenerate.
@
text
@a193 1
static FILE *pex_win32_fdopenw (struct pex_obj *, int, int);
a205 1
  pex_win32_fdopenw,
a704 12
static FILE *
pex_win32_fdopenw (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,
		   int binary)
{
  HANDLE h = (HANDLE) _get_osfhandle (fd);
  if (h == INVALID_HANDLE_VALUE)
    return NULL;
  if (! SetHandleInformation (h, HANDLE_FLAG_INHERIT, 0))
    return NULL;
  return fdopen (fd, binary ? "wb" : "w");
}

@


1.9.10.2
log
@	* libiberty/pex-win32.c (<errno.h>): Include.
	(fix_argv): Remove.
	(argv_to_cmdline): New function.
	(std_suffixes): New variable.
	(no_suffixes): Likewise.
	(find_executable): New function.
	(win32_spawn): Likewise.
	(spawn_script): Use win32_spawn instead of _spawnv[p].
	(pex_win32_exec_child): Replace MSVCRT calls with Win32 API calls.
	(pex_win32_wait): Likewise.
@
text
@a43 1
#include <errno.h>
d75 109
a426 214
/* Return a Windows command-line from ARGV.  It is the caller's
   responsibility to free the string returned.  */

static char *
argv_to_cmdline (char *const *argv)
{
  char *cmdline;
  char *p;
  size_t cmdline_len;
  int i, j, k;

  cmdline_len = 0;
  for (i = 0; argv[i]; i++)
    {
      /* We quote every last argument.  This simplifies the problem;
	 we need only escape embedded double-quotes and immediately
	 preceeding backslash characters.  A sequence of backslach characters
	 that is not follwed by a double quote character will not be
	 escaped.  */
      for (j = 0; argv[i][j]; j++)
	{
	  if (argv[i][j] == '"')
	    {
	      /* Escape preceeding backslashes.  */
	      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
		cmdline_len++;
	      /* Escape the qote character.  */
	      cmdline_len++;
	    }
	}
      /* Trailing backslashes also need to be escaped because they will be
         followed by the terminating quote.  */
      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
	cmdline_len++;
      cmdline_len += j;
      cmdline_len += 3;  /* for leading and trailing quotes and space */
    }
  cmdline = xmalloc (cmdline_len);
  p = cmdline;
  for (i = 0; argv[i]; i++)
    {
      *p++ = '"';
      for (j = 0; argv[i][j]; j++)
	{
	  if (argv[i][j] == '"')
	    {
	      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
		*p++ = '\\';
	      *p++ = '\\';
	    }
	  *p++ = argv[i][j];
	}
      for (k = j - 1; k >= 0 && argv[i][k] == '\\'; k--)
	*p++ = '\\';
      *p++ = '"';
      *p++ = ' ';
    }
  p[-1] = '\0';
  return cmdline;
}

static const char *const
std_suffixes[] = {
  ".com",
  ".exe",
  ".bat",
  ".cmd",
  0
};
static const char *const
no_suffixes[] = {
  "",
  0
};

/* Returns the full path to PROGRAM.  If SEARCH is true, look for
   PROGRAM in each directory in PATH.  */

static char *
find_executable (const char *program, BOOL search)
{
  char *full_executable;
  char *e;
  size_t fe_len;
  const char *path = 0;
  const char *const *ext;
  const char *p, *q;
  size_t proglen = strlen (program);
  int has_extension = !!strchr (program, '.');
  int has_slash = (strchr (program, '/') || strchr (program, '\\'));
  HANDLE h;

  if (has_slash)
    search = FALSE;

  if (search)
    path = getenv ("PATH");
  if (!path)
    path = "";

  fe_len = 0;
  for (p = path; *p; p = q)
    {
      q = p;
      while (*q != ';' && *q != '\0')
	q++;
      if ((size_t)(q - p) > fe_len)
	fe_len = q - p;
      if (*q == ';')
	q++;
    }
  fe_len = fe_len + 1 + proglen + (has_extension ? 1 : 5);
  full_executable = xmalloc (fe_len);

  p = path;
  do
    {
      q = p;
      while (*q != ';' && *q != '\0')
	q++;

      e = full_executable;
      memcpy (e, p, q - p);
      e += (q - p);
      if (q - p)
	*e++ = '\\';
      strcpy (e, program);

      if (*q == ';')
	q++;

      for (e = full_executable; *e; e++)
	if (*e == '/')
	  *e = '\\';

      /* At this point, e points to the terminating NUL character for
         full_executable.  */
      for (ext = has_extension ? no_suffixes : std_suffixes; *ext; ext++)
	{
	  /* Remove any current extension.  */
	  *e = '\0';
	  /* Add the new one.  */
	  strcat (full_executable, *ext);

	  /* Attempt to open this file.  */
	  h = CreateFile (full_executable, GENERIC_READ,
			  FILE_SHARE_READ | FILE_SHARE_WRITE,
			  0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	  if (h != INVALID_HANDLE_VALUE)
	    goto found;
	}
      p = q;
    }
  while (*p);
  free (full_executable);
  return 0;

 found:
  CloseHandle (h);
  return full_executable;
}

/* Low-level process creation function.  */

static long
win32_spawn (const char *executable,
	     BOOL search,
	     char *const *argv,
	     DWORD dwCreationFlags,
	     LPSTARTUPINFO si,
	     LPPROCESS_INFORMATION pi)
{
  char *full_executable;
  char *cmdline;

  full_executable = NULL;
  cmdline = NULL;

  full_executable = find_executable (executable, search);
  if (!full_executable)
    goto error;
  cmdline = argv_to_cmdline (argv);
  if (!cmdline)
    goto error;
    
  /* Create the child process.  */  
  if (!CreateProcess (full_executable, cmdline, 
		      /*lpProcessAttributes=*/NULL,
		      /*lpThreadAttributes=*/NULL,
		      /*bInheritHandles=*/TRUE,
		      dwCreationFlags,
		      /*lpEnvironment=*/NULL,
		      /*lpCurrentDirectory=*/NULL,
		      si,
		      pi))
    {
      free (full_executable);
      return -1;
    }

  /* Clean up.  */
  CloseHandle (pi->hThread);
  free (full_executable);

  return (long) pi->hProcess;

 error:
  if (cmdline)
    free (cmdline);
  if (full_executable)
    free (full_executable);
  return -1;
}

d428 1
a428 4
spawn_script (const char *executable, char *const *argv,
	      DWORD dwCreationFlags,
	      LPSTARTUPINFO si,
	      LPPROCESS_INFORMATION pi)
d460 1
a460 2
	      pid = win32_spawn (executable, TRUE, argv, 
				 dwCreationFlags, si, pi);
d463 1
a463 2
		pid = win32_spawn (executable1, TRUE, argv, 
				   dwCreationFlags, si, pi);
d465 1
a465 2
		pid = win32_spawn (executable1, FALSE, argv, 
				   dwCreationFlags, si, pi);
d470 1
a470 2
		  pid = win32_spawn (newex, FALSE, argv, 
				     dwCreationFlags, si, pi);
d479 1
a479 2
			  pid = win32_spawn (newex, FALSE, argv, 
					     dwCreationFlags, si, pi);
d501 1
d503 5
a507 18
  HANDLE stdin_handle;
  HANDLE stdout_handle;
  HANDLE stderr_handle;
  DWORD dwCreationFlags;
  OSVERSIONINFO version_info;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  stdin_handle = INVALID_HANDLE_VALUE;
  stdout_handle = INVALID_HANDLE_VALUE;
  stderr_handle = INVALID_HANDLE_VALUE;

  stdin_handle = (HANDLE) _get_osfhandle (in);
  stdout_handle = (HANDLE) _get_osfhandle (out);
  if (!(flags & PEX_STDERR_TO_STDOUT))
    stderr_handle = (HANDLE) _get_osfhandle (errdes);
  else
    stderr_handle = stdout_handle;
d509 1
a509 8
  /* Determine the version of Windows we are running on.  */
  version_info.dwOSVersionInfoSize = sizeof (version_info); 
  GetVersionEx (&version_info);
  if (version_info.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    /* On Windows 95/98/ME the CREATE_NO_WINDOW flag is not
       supported, so we cannot avoid creating a console window.  */
    dwCreationFlags = 0;
  else
d511 20
a530 1
      HANDLE conout_handle;
d532 48
a579 25
      /* Determine whether or not we have an associated console.  */
      conout_handle = CreateFile("CONOUT$", 
				 GENERIC_WRITE,
				 FILE_SHARE_WRITE,
				 /*lpSecurityAttributes=*/NULL,
				 OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL,
				 /*hTemplateFile=*/NULL);
      if (conout_handle == INVALID_HANDLE_VALUE)
	/* There is no console associated with this process.  Since
	   the child is a console process, the OS would normally
	   create a new console Window for the child.  Since we'll be
	   redirecting the child's standard streams, we do not need
	   the console window.  */ 
	dwCreationFlags = CREATE_NO_WINDOW;
      else 
	{
	  /* There is a console associated with the process, so the OS
	     will not create a new console.  And, if we use
	     CREATE_NO_WINDOW in this situation, the child will have
	     no associated console.  Therefore, if the child's
	     standard streams are connected to the console, the output
	     will be discarded.  */
	  CloseHandle(conout_handle);
	  dwCreationFlags = 0;
d583 4
a586 16
  /* Since the child will be a console process, it will, by default,
     connect standard input/output to its console.  However, we want
     the child to use the handles specifically designated above.  In
     addition, if there is no console (such as when we are running in
     a Cygwin X window), then we must redirect the child's
     input/output, as there is no console for the child to use.  */
  memset (&si, 0, sizeof (si));
  si.cb = sizeof (si);
  si.dwFlags = STARTF_USESTDHANDLES;
  si.hStdInput = stdin_handle;
  si.hStdOutput = stdout_handle;
  si.hStdError = stderr_handle;

  /* Create the child process.  */  
  pid = win32_spawn (executable, (flags & PEX_SEARCH) != 0,
		     argv, dwCreationFlags, &si, &pi);
d588 2
a589 1
    pid = spawn_script (executable, argv, dwCreationFlags, &si, &pi);
d592 51
a642 2
      *err = ENOENT;
      *errmsg = "CreateProcess";
d661 1
a661 2
  DWORD termstat;
  HANDLE h;
a665 2
  h = (HANDLE) pid;

d668 2
a669 1
  if (WaitForSingleObject (h, INFINITE) != WAIT_OBJECT_0)
d671 2
a672 3
      CloseHandle (h);
      *err = ECHILD;
      *errmsg = "WaitForSingleObject";
d676 5
a680 6
  GetExitCodeProcess (h, &termstat);
  CloseHandle (h);
 
  /* A value of 3 indicates that the child caught a signal, but not
     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we
     report SIGABRT.  */
d684 1
a684 1
    *status = (termstat & 0xff) << 8;
@


1.9.10.3
log
@	* libiberty/pex-win32.c (pex_win32_exec_child): Close stdout/stderr
	in parent.
@
text
@a697 7
  /* Close the standard output and standard error handles in the
     parent.  */ 
  if (out != STDOUT_FILENO)
    obj->funcs->close (obj, out);
  if (errdes != STDERR_FILENO)
    obj->funcs->close (obj, errdes);

@


1.8
log
@merge from gcc
@
text
@d24 2
d58 17
d101 5
a105 1
  argv = XNEWVEC (char *, i + 1);
d110 1
a110 9
  /* Ensure that the executable pathname uses Win32 backslashes. This
     is not necessary on NT, but on W9x, forward slashes causes
     failure of spawn* and exec* functions (and probably any function
     that calls CreateProcess) *iff* the executable pathname (argv[0])
     is a quoted string.  And quoting is necessary in case a pathname
     contains embedded white space.  You can't win.  */
  for (command0 = argv[0]; *command0 != '\0'; command0++)
    if (*command0 == '/')
      *command0 = '\\';
d155 1
a155 1
	     is escaped by the trailing backslash and things get confused. 
d158 2
a159 2
	  if (len > 1 
	      && argv[i][len-1] == '\\' 
d248 243
d501 1
d581 1
d583 4
a586 1
	 (_P_NOWAIT, executable, fix_argv (argv)));
d704 14
@


1.7
log
@Update the address and phone number of the FSF organization.
@
text
@d82 1
a82 1
  argv = xmalloc ((i + 1) * sizeof (char *));
d108 1
a108 1
              newtemp = xmalloc (len + 2);
d153 1
a153 1
	  temp = xmalloc (len + 1);
@


1.6
log
@libiberty:
	* pex-common.c: New file.
	* pex-one.c: New file.
	* pexecute.c: New file.
	* pex-common.h: Include <stdio.h>.
	(struct pex_obj): Define.
	(struct pex_funcs): Define.
	(pex_init_common): Declare.
	* pex-unix.c: Rewrite.
	* pex-win32.c: Rewrite.
	* pex-djgpp.c: Rewrite.
	* pex-msdos.c: Rewrite.
	* testsuite/text-pexecute.c: New file.
	* pexecute.txh: Rewrite.
	* configure.ac: Check for wait3 and wait4.  Set CHECK to
	really-check rather than check-cplus-dem.
	* functions.texi: Rebuild.
	* Makefile.in: Rebuild dependencies.
	(CFILES): Add pexecute.c, pex-common.c, pex-one.c.
	(REQUIRED_OFILES): Add pexecute.o, pex-common.o, pex-one.o.
	* testsuite/Makefile.in (really-check): New target.
	(check-pexecute, test-pexecute): New targets.
	* configure: Rebuild.
include:
	* libiberty.h: Include <stdio.h>.
	(PEX_RECORD_TIMES, PEX_USE_PIPES, PEX_SAVE_TEMPS): Define.
	(PEX_LAST, PEX_SEARCH, PEX_SUFFIX, PEX_STDERR_TO_STDOUT): Define.
	(PEX_BINARY_INPUT, PEX_BINARY_OUTPUT): Define.
	(pex_init, pex_run, pex_read_output): Declare.
	(pex_get_status, pex_get_times, pex_free, pex_one): Declare.
	(struct pex_time): Define.
@
text
@d19 2
a20 2
write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
@


1.5
log
@merge from gcc
@
text
@d24 3
d41 1
d60 1
a60 1
fix_argv (char **argvec)
d62 1
d64 22
a85 1
  char * command0 = argvec[0];
d88 6
a93 6
     is not necessary on NT, but on W9x, forward slashes causes failure
     of spawn* and exec* functions (and probably any function that
     calls CreateProcess) *iff* the executable pathname (argvec[0]) is
     a quoted string.  And quoting is necessary in case a pathname
     contains  embedded white space. You can't win.  */
  for (; *command0 != '\0'; command0++)
d96 2
a97 2
 
  for (i = 1; argvec[i] != 0; i++)
d102 1
a102 1
      temp = argvec[i];
d119 6
a124 2
        argvec[i] = temp;
      }
d126 1
a126 1
  for (i = 0; argvec[i] != 0; i++)
d128 1
a128 1
      if (strpbrk (argvec[i], " \t"))
d133 1
a133 1
	  len = strlen (argvec[i]);
d144 2
a145 2
	      && argvec[i][len-1] == '\\' 
	      && argvec[i][len-2] != '\\')
d155 1
a155 1
	  strcpy (temp + 1, argvec[i]);
d157 2
a158 2
	    temp[len-2] = '\\';
	  temp[len-1] = '"';
d161 2
a162 1
	  argvec[i] = temp;
d166 57
a222 1
  return (const char * const *) argvec;
d225 4
a228 6
/* Win32 supports pipes */
int
pexecute (const char *program, char * const *argv,
          const char *this_pname ATTRIBUTE_UNUSED,
          const char *temp_base ATTRIBUTE_UNUSED,
          char **errmsg_fmt, char **errmsg_arg, int flags)
d230 2
a231 5
  int pid;
  int pdes[2];
  int org_stdin = -1;
  int org_stdout = -1;
  int input_desc, output_desc;
d233 1
a233 4
  /* Pipe waiting from last process, to be used as input for the next one.
     Value is STDIN_FILE_NO if no pipe is waiting
     (i.e. the next command is the first of a group).  */
  static int last_pipe_input;
d235 8
a242 3
  /* If this is the first process, initialize.  */
  if (flags & PEXECUTE_FIRST)
    last_pipe_input = STDIN_FILE_NO;
d244 3
a246 1
  input_desc = last_pipe_input;
d248 1
a248 3
  /* If this isn't the last process, make a pipe for its output,
     and record it as waiting to be the input to the next process.  */
  if (! (flags & PEXECUTE_LAST))
d250 14
a263 1
      if (_pipe (pdes, 256, O_BINARY) < 0)
d265 2
a266 2
	  *errmsg_fmt = "pipe";
	  *errmsg_arg = NULL;
a268 2
      output_desc = pdes[WRITE_PORT];
      last_pipe_input = pdes[READ_PORT];
d270 2
a271 1
  else
d273 19
a291 3
      /* Last process.  */
      output_desc = STDOUT_FILE_NO;
      last_pipe_input = STDIN_FILE_NO;
d294 2
a295 1
  if (input_desc != STDIN_FILE_NO)
d297 23
a319 3
      org_stdin = dup (STDIN_FILE_NO);
      dup2 (input_desc, STDIN_FILE_NO);
      close (input_desc); 
d322 4
a325 1
  if (output_desc != STDOUT_FILE_NO)
d327 2
a328 3
      org_stdout = dup (STDOUT_FILE_NO);
      dup2 (output_desc, STDOUT_FILE_NO);
      close (output_desc);
d331 1
a331 4
  pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)
    (_P_NOWAIT, program, fix_argv(argv));

  if (input_desc != STDIN_FILE_NO)
d333 12
a344 2
      dup2 (org_stdin, STDIN_FILE_NO);
      close (org_stdin);
d347 1
a347 1
  if (output_desc != STDOUT_FILE_NO)
d349 12
a360 2
      dup2 (org_stdout, STDOUT_FILE_NO);
      close (org_stdout);
d363 2
a364 1
  if (pid == -1)
d366 12
a377 3
      *errmsg_fmt = install_error_msg;
      *errmsg_arg = (char*) program;
      return -1;
d383 12
a394 9
/* MS CRTDLL doesn't return enough information in status to decide if the
   child exited due to a signal or not, rather it simply returns an
   integer with the exit code of the child; eg., if the child exited with 
   an abort() call and didn't have a handler for SIGABRT, it simply returns
   with status = 3. We fix the status code to conform to the usual WIF*
   macros. Note that WIFSIGNALED will never be true under CRTDLL. */

int
pwait (int pid, int *status, int flags ATTRIBUTE_UNUSED)
d398 2
a399 1
  pid = _cwait (&termstat, pid, WAIT_CHILD);
d401 14
a414 2
  /* ??? Here's an opportunity to canonicalize the values in STATUS.
     Needed?  */
a415 4
  /* cwait returns the child process exit code in termstat.
     A value of 3 indicates that the child caught a signal, but not
     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we
     report SIGABRT.  */
d419 6
a424 1
    *status = (((termstat) & 0xff) << 8);
d426 14
a439 1
  return pid;
@


1.4
log
@merge from gcc
@
text
@d3 1
a3 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003
d56 1
a56 2
fix_argv (argvec)
     char **argvec;
d140 4
a143 7
pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)
     const char *program;
     char * const *argv;
     const char *this_pname ATTRIBUTE_UNUSED;
     const char *temp_base ATTRIBUTE_UNUSED;
     char **errmsg_fmt, **errmsg_arg;
     int flags;
d229 1
a229 4
pwait (pid, status, flags)
     int pid;
     int *status;
     int flags ATTRIBUTE_UNUSED;
@


1.3
log
@merge from gcc
@
text
@d62 6
a67 1
  /* Ensure that the executable pathname uses Win32 backslashes.  */
@


1.3.16.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d62 1
a62 6
  /* Ensure that the executable pathname uses Win32 backslashes. This
     is not necessary on NT, but on W9x, forward slashes causes failure
     of spawn* and exec* functions (and probably any function that
     calls CreateProcess) *iff* the executable pathname (argvec[0]) is
     a quoted string.  And quoting is necessary in case a pathname
     contains  embedded white space. You can't win.  */
@


1.3.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.2
log
@merge from gcc
@
text
@d139 2
a140 2
     const char *this_pname;
     const char *temp_base;
d145 3
a147 1
  int pdes[2], org_stdin, org_stdout;
a148 1
  int retries, sleep_interval;
d231 1
a231 1
     int flags;
@


1.1
log
@merge from gcc
@
text
@d60 1
d62 5
d212 1
a212 1
      *errmsg_arg = program;
@


1.1.4.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@@


1.1.4.2
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a59 1
  char * command0 = argvec[0];
a60 5
  /* Ensure that the executable pathname uses Win32 backslashes.  */
  for (; *command0 != '\0'; command0++)
    if (*command0 == '/')
      *command0 = '\\';
 
d133 2
a134 2
     const char *this_pname ATTRIBUTE_UNUSED;
     const char *temp_base ATTRIBUTE_UNUSED;
d139 1
a139 3
  int pdes[2];
  int org_stdin = -1;
  int org_stdout = -1;
d141 1
d206 1
a206 1
      *errmsg_arg = (char*) program;
d224 1
a224 1
     int flags ATTRIBUTE_UNUSED;
@


