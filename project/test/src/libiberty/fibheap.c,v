head	1.8;
access;
symbols
	sid-snapshot-20180601:1.8
	sid-snapshot-20180501:1.8
	sid-snapshot-20180401:1.8
	sid-snapshot-20180301:1.8
	sid-snapshot-20180201:1.8
	sid-snapshot-20180101:1.8
	sid-snapshot-20171201:1.8
	sid-snapshot-20171101:1.8
	sid-snapshot-20171001:1.8
	sid-snapshot-20170901:1.8
	sid-snapshot-20170801:1.8
	sid-snapshot-20170701:1.8
	sid-snapshot-20170601:1.8
	sid-snapshot-20170501:1.8
	sid-snapshot-20170401:1.8
	sid-snapshot-20170301:1.8
	sid-snapshot-20170201:1.8
	sid-snapshot-20170101:1.8
	sid-snapshot-20161201:1.8
	sid-snapshot-20161101:1.8
	sid-snapshot-20160901:1.8
	sid-snapshot-20160801:1.8
	sid-snapshot-20160701:1.8
	sid-snapshot-20160601:1.8
	sid-snapshot-20160501:1.8
	sid-snapshot-20160401:1.8
	sid-snapshot-20160301:1.8
	sid-snapshot-20160201:1.8
	sid-snapshot-20160101:1.8
	sid-snapshot-20151201:1.8
	sid-snapshot-20151101:1.8
	sid-snapshot-20151001:1.8
	sid-snapshot-20150901:1.8
	sid-snapshot-20150801:1.8
	sid-snapshot-20150701:1.8
	sid-snapshot-20150601:1.8
	sid-snapshot-20150501:1.8
	sid-snapshot-20150401:1.8
	sid-snapshot-20150301:1.8
	sid-snapshot-20150201:1.8
	sid-snapshot-20150101:1.8
	sid-snapshot-20141201:1.8
	sid-snapshot-20141101:1.8
	sid-snapshot-20141001:1.8
	sid-snapshot-20140901:1.8
	sid-snapshot-20140801:1.8
	sid-snapshot-20140701:1.8
	sid-snapshot-20140601:1.8
	sid-snapshot-20140501:1.8
	sid-snapshot-20140401:1.8
	sid-snapshot-20140301:1.8
	sid-snapshot-20140201:1.8
	sid-snapshot-20140101:1.8
	sid-snapshot-20131201:1.8
	sid-snapshot-20131101:1.8
	sid-snapshot-20131001:1.8
	binutils-2_24-branch:1.8.0.30
	binutils-2_24-branchpoint:1.8
	binutils-2_21_1:1.8
	sid-snapshot-20130901:1.8
	gdb_7_6_1-2013-08-30-release:1.8
	sid-snapshot-20130801:1.8
	sid-snapshot-20130701:1.8
	sid-snapshot-20130601:1.8
	sid-snapshot-20130501:1.8
	gdb_7_6-2013-04-26-release:1.8
	sid-snapshot-20130401:1.8
	binutils-2_23_2:1.8
	gdb_7_6-branch:1.8.0.28
	gdb_7_6-2013-03-12-branchpoint:1.8
	sid-snapshot-20130301:1.8
	sid-snapshot-20130201:1.8
	sid-snapshot-20130101:1.8
	sid-snapshot-20121201:1.8
	gdb_7_5_1-2012-11-29-release:1.8
	binutils-2_23_1:1.8
	sid-snapshot-20121101:1.8
	binutils-2_23:1.8
	sid-snapshot-20121001:1.8
	sid-snapshot-20120901:1.8
	gdb_7_5-2012-08-17-release:1.8
	sid-snapshot-20120801:1.8
	binutils-2_23-branch:1.8.0.26
	binutils-2_23-branchpoint:1.8
	gdb_7_5-branch:1.8.0.24
	gdb_7_5-2012-07-18-branchpoint:1.8
	sid-snapshot-20120701:1.8
	sid-snapshot-20120601:1.8
	sid-snapshot-20120501:1.8
	binutils-2_22_branch:1.8.0.22
	gdb_7_4_1-2012-04-26-release:1.8
	sid-snapshot-20120401:1.8
	sid-snapshot-20120301:1.8
	sid-snapshot-20120201:1.8
	gdb_7_4-2012-01-24-release:1.8
	sid-snapshot-20120101:1.8
	gdb_7_4-branch:1.8.0.20
	gdb_7_4-2011-12-13-branchpoint:1.8
	sid-snapshot-20111201:1.8
	binutils-2_22:1.8
	sid-snapshot-20111101:1.8
	sid-snapshot-20111001:1.8
	binutils-2_22-branch:1.8.0.18
	binutils-2_22-branchpoint:1.8
	gdb_7_3_1-2011-09-04-release:1.8
	sid-snapshot-20110901:1.8
	sid-snapshot-20110801:1.8
	gdb_7_3-2011-07-26-release:1.8
	sid-snapshot-20110701:1.8
	sid-snapshot-20110601:1.8
	sid-snapshot-20110501:1.8
	gdb_7_3-branch:1.8.0.16
	gdb_7_3-2011-04-01-branchpoint:1.8
	sid-snapshot-20110401:1.8
	sid-snapshot-20110301:1.8
	cygwin-1_7_8-release:1.8
	sid-snapshot-20110201:1.8
	sid-snapshot-20110101:1.8
	binutils-2_21:1.8
	sid-snapshot-20101201:1.8
	binutils-2_21-branch:1.8.0.14
	binutils-2_21-branchpoint:1.8
	sid-snapshot-20101101:1.8
	sid-snapshot-20101001:1.8
	binutils-2_20_1:1.8
	gdb_7_2-2010-09-02-release:1.8
	sid-snapshot-20100901:1.8
	cygwin-1_7_7-release:1.8
	sid-snapshot-20100801:1.8
	gdb_7_2-branch:1.8.0.12
	gdb_7_2-2010-07-07-branchpoint:1.8
	sid-snapshot-20100701:1.8
	sid-snapshot-20100601:1.8
	sid-snapshot-20100501:1.8
	sid-snapshot-20100401:1.8
	gdb_7_1-2010-03-18-release:1.8
	sid-snapshot-20100301:1.8
	gdb_7_1-branch:1.8.0.10
	gdb_7_1-2010-02-18-branchpoint:1.8
	sid-snapshot-20100201:1.8
	sid-snapshot-20100101:1.8
	gdb_7_0_1-2009-12-22-release:1.8
	sid-snapshot-20091201:1.8
	sid-snapshot-20091101:1.8
	binutils-2_20:1.8
	gdb_7_0-2009-10-06-release:1.8
	sid-snapshot-20091001:1.8
	gdb_7_0-branch:1.8.0.8
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.7
	binutils-arc-20081103-branch:1.7.0.62
	binutils-arc-20081103-branchpoint:1.7
	binutils-2_20-branch:1.8.0.6
	binutils-2_20-branchpoint:1.8
	sid-snapshot-20090901:1.8
	sid-snapshot-20090801:1.8
	msnyder-checkpoint-072509-branch:1.8.0.4
	msnyder-checkpoint-072509-branchpoint:1.8
	sid-snapshot-20090701:1.8
	dje-cgen-play1-branch:1.8.0.2
	dje-cgen-play1-branchpoint:1.8
	sid-snapshot-20090601:1.8
	sid-snapshot-20090501:1.7
	sid-snapshot-20090401:1.7
	arc-20081103-branch:1.7.0.60
	arc-20081103-branchpoint:1.7
	arc-insight_6_8-branch:1.7.0.58
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.56
	insight_6_8-branchpoint:1.7
	sid-snapshot-20090301:1.7
	binutils-2_19_1:1.7
	sid-snapshot-20090201:1.7
	sid-snapshot-20090101:1.7
	reverse-20081226-branch:1.7.0.54
	reverse-20081226-branchpoint:1.7
	sid-snapshot-20081201:1.7
	multiprocess-20081120-branch:1.7.0.52
	multiprocess-20081120-branchpoint:1.7
	sid-snapshot-20081101:1.7
	binutils-2_19:1.7
	sid-snapshot-20081001:1.7
	reverse-20080930-branch:1.7.0.50
	reverse-20080930-branchpoint:1.7
	binutils-2_19-branch:1.7.0.48
	binutils-2_19-branchpoint:1.7
	sid-snapshot-20080901:1.7
	sid-snapshot-20080801:1.7
	reverse-20080717-branch:1.7.0.46
	reverse-20080717-branchpoint:1.7
	sid-snapshot-20080701:1.7
	msnyder-reverse-20080609-branch:1.7.0.44
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.7.0.42
	drow-reverse-20070409-branchpoint:1.7
	sid-snapshot-20080601:1.7
	sid-snapshot-20080501:1.7
	sid-snapshot-20080403:1.7
	sid-snapshot-20080401:1.7
	gdb_6_8-2008-03-27-release:1.7
	sid-snapshot-20080301:1.7
	gdb_6_8-branch:1.7.0.40
	gdb_6_8-2008-02-26-branchpoint:1.7
	sid-snapshot-20080201:1.7
	sid-snapshot-20080101:1.7
	sid-snapshot-20071201:1.7
	sid-snapshot-20071101:1.7
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	sid-snapshot-20071001:1.7
	gdb_6_7-branch:1.7.0.38
	gdb_6_7-2007-09-07-branchpoint:1.7
	binutils-2_18:1.7
	binutils-2_18-branch:1.7.0.36
	binutils-2_18-branchpoint:1.7
	insight_6_6-20070208-release:1.7
	binutils-csl-coldfire-4_1-32:1.7
	binutils-csl-sourcerygxx-4_1-32:1.7
	gdb_6_6-2006-12-18-release:1.7
	binutils-csl-innovasic-fido-3_4_4-33:1.7
	binutils-csl-sourcerygxx-3_4_4-32:1.5
	binutils-csl-coldfire-4_1-30:1.7
	binutils-csl-sourcerygxx-4_1-30:1.7
	binutils-csl-coldfire-4_1-28:1.7
	binutils-csl-sourcerygxx-4_1-29:1.7
	binutils-csl-sourcerygxx-4_1-28:1.7
	gdb_6_6-branch:1.7.0.34
	gdb_6_6-2006-11-15-branchpoint:1.7
	binutils-csl-arm-2006q3-27:1.7
	binutils-csl-sourcerygxx-4_1-27:1.7
	binutils-csl-arm-2006q3-26:1.7
	binutils-csl-sourcerygxx-4_1-26:1.7
	binutils-csl-sourcerygxx-4_1-25:1.7
	binutils-csl-sourcerygxx-4_1-24:1.7
	binutils-csl-sourcerygxx-4_1-23:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	binutils-csl-sourcerygxx-4_1-21:1.7
	binutils-csl-arm-2006q3-21:1.7
	binutils-csl-sourcerygxx-4_1-22:1.7
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.7
	binutils-csl-sourcerygxx-4_1-20:1.7
	binutils-csl-arm-2006q3-19:1.7
	binutils-csl-sourcerygxx-4_1-19:1.7
	binutils-csl-sourcerygxx-4_1-18:1.7
	binutils-csl-renesas-4_1-9:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	binutils-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	binutils-csl-renesas-4_1-8:1.7
	binutils-csl-renesas-4_1-7:1.7
	binutils-csl-renesas-4_1-6:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	binutils-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	cr-0x5f1:1.7.0.32
	gdb-csl-sourcerygxx-4_1-14:1.7
	binutils-csl-sourcerygxx-4_1-14:1.7
	binutils-csl-sourcerygxx-4_1-15:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	binutils-csl-sourcerygxx-4_1-13:1.7
	binutils-2_17:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	binutils-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	binutils-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.7
	binutils-csl-wrs-linux-3_4_4-24:1.5
	binutils-csl-wrs-linux-3_4_4-23:1.5
	gdb-csl-sourcerygxx-4_1-9:1.7
	binutils-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	binutils-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	binutils-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	binutils-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	binutils-csl-sourcerygxx-4_1-6:1.7
	binutils-csl-wrs-linux-3_4_4-22:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	binutils-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	binutils-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.7.0.30
	gdb_6_5-2006-05-14-branchpoint:1.7
	binutils-csl-coldfire-4_1-10:1.7
	gdb-csl-sourcerygxx-4_1-5:1.7
	binutils-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.7.0.28
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.7
	binutils-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.7.0.26
	msnyder-reverse-20060502-branchpoint:1.7
	binutils-csl-wrs-linux-3_4_4-21:1.5
	gdb-csl-morpho-4_1-4:1.7
	binutils-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	binutils-csl-sourcerygxx-3_4_4-17:1.7
	binutils-csl-wrs-linux-3_4_4-20:1.5
	readline_5_1-import-branch:1.7.0.24
	readline_5_1-import-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	binutils-2_17-branch:1.7.0.22
	binutils-2_17-branchpoint:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.20
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.18
	msnyder-reverse-20060331-branchpoint:1.7
	binutils-csl-2_17-branch:1.7.0.16
	binutils-csl-2_17-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.14
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.12
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.10
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.6
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.4
	gdb-csl-arm-20051020-branchpoint:1.7
	binutils-csl-gxxpro-3_4-branch:1.5.0.32
	binutils-csl-gxxpro-3_4-branchpoint:1.5
	binutils-2_16_1:1.5
	msnyder-tracepoint-checkpoint-branch:1.7.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.5
	binutils-csl-arm-2005q1b:1.5
	binutils-2_16:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	binutils-csl-arm-2005q1a:1.5
	csl-arm-20050325-branch:1.5.0.30
	csl-arm-20050325-branchpoint:1.5
	binutils-csl-arm-2005q1-branch:1.5.0.28
	binutils-csl-arm-2005q1-branchpoint:1.5
	binutils-2_16-branch:1.5.0.26
	binutils-2_16-branchpoint:1.5
	csl-arm-2004-q3d:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.22
	gdb_6_3-20041019-branchpoint:1.5
	csl-arm-2004-q3:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.24
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	binutils-2_15:1.5
	binutils-2_15-branchpoint:1.5
	csl-arm-2004-q1a:1.5
	csl-arm-2004-q1:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.18
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.16
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.12
	drow_intercu-20040221-branchpoint:1.5
	binutils-2_15-branch:1.5.0.10
	cagney_bfdfile-20040213-branch:1.5.0.8
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.6
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	csl-arm-2003-q4:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.5.0.4
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.2
	cagney_x86i386-20030821-branch:1.4.0.42
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.40
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.38
	jimb-ppc64-linux-20030613-branchpoint:1.4
	binutils-2_14:1.4
	cagney_convert-20030606-branch:1.4.0.36
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.34
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.32
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.30
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.28
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	binutils-2_14-branch:1.4.0.26
	binutils-2_14-branchpoint:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.24
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.22
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.20
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.18
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.16
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.14
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.12
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.10
	cagney_offbyone-20030303-branchpoint:1.4
	w32api-2_2:1.4
	mingw-runtime-2_4:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.8
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.6
	cagney-unwind-20030108-branchpoint:1.4
	binutils-2_13_2_1:1.3
	binutils-2_13_2:1.3
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.4
	binutils-2_13_1:1.3
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.4
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.2
	carlton_dictionary-20020920-branchpoint:1.4
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.20
	gdb_5_3-branch:1.3.0.18
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.16
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.14
	readline_4_3-import-branchpoint:1.3
	binutils-2_13:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	binutils-2_13-branchpoint:1.3
	binutils-2_13-branch:1.3.0.12
	kseitz_interps-20020528-branch:1.3.0.10
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.8
	cagney_regbuf-20020515-branchpoint:1.3
	binutils-2_12_1:1.3
	jimb-macro-020506-branch:1.3.0.6
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	binutils-2_12:1.3
	gdb_5_2-branch:1.3.0.4
	gdb_5_2-2002-03-03-branchpoint:1.3
	binutils-2_12-branch:1.3.0.2
	binutils-2_12-branchpoint:1.3
	cygnus_cvs_20020108_pre:1.3
	binutils_latest_snapshot:1.8;
locks; strict;
comment	@ * @;


1.8
date	2009.05.29.03.01.15;	author dj;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.10.15.33.33;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.28.02.09.01;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.06.23.51.12;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.20.13.45.20;	author dj;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	2001.08.22.22.55.38;	author dj;	state Exp;
branches
	1.3.10.1;
next	1.2;

1.2
date	2001.08.22.02.12.15;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.21.15.19.19;	author dj;	state Exp;
branches;
next	;

1.4.2.1
date	2003.09.17.21.28.56;	author carlton;	state Exp;
branches;
next	;

1.4.4.1
date	2003.12.14.20.28.03;	author drow;	state Exp;
branches;
next	;

1.3.10.1
date	2002.10.01.00.46.42;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.8
log
@merge from gcc
@
text
@/* A Fibonacci heap datatype.
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
   Contributed by Daniel Berlin (dan@@cgsoftware.com).
   
This file is part of GNU CC.
   
GNU CC is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU CC is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#include "libiberty.h"
#include "fibheap.h"


#define FIBHEAPKEY_MIN	LONG_MIN

static void fibheap_ins_root (fibheap_t, fibnode_t);
static void fibheap_rem_root (fibheap_t, fibnode_t);
static void fibheap_consolidate (fibheap_t);
static void fibheap_link (fibheap_t, fibnode_t, fibnode_t);
static void fibheap_cut (fibheap_t, fibnode_t, fibnode_t);
static void fibheap_cascading_cut (fibheap_t, fibnode_t);
static fibnode_t fibheap_extr_min_node (fibheap_t);
static int fibheap_compare (fibheap_t, fibnode_t, fibnode_t);
static int fibheap_comp_data (fibheap_t, fibheapkey_t, void *, fibnode_t);
static fibnode_t fibnode_new (void);
static void fibnode_insert_after (fibnode_t, fibnode_t);
#define fibnode_insert_before(a, b) fibnode_insert_after (a->left, b)
static fibnode_t fibnode_remove (fibnode_t);


/* Create a new fibonacci heap.  */
fibheap_t
fibheap_new (void)
{
  return (fibheap_t) xcalloc (1, sizeof (struct fibheap));
}

/* Create a new fibonacci heap node.  */
static fibnode_t
fibnode_new (void)
{
  fibnode_t node;

  node = (fibnode_t) xcalloc (1, sizeof *node);
  node->left = node;
  node->right = node;

  return node;
}

static inline int
fibheap_compare (fibheap_t heap ATTRIBUTE_UNUSED, fibnode_t a, fibnode_t b)
{
  if (a->key < b->key)
    return -1;
  if (a->key > b->key)
    return 1;
  return 0;
}

static inline int
fibheap_comp_data (fibheap_t heap, fibheapkey_t key, void *data, fibnode_t b)
{
  struct fibnode a;

  a.key = key;
  a.data = data;

  return fibheap_compare (heap, &a, b);
}

/* Insert DATA, with priority KEY, into HEAP.  */
fibnode_t
fibheap_insert (fibheap_t heap, fibheapkey_t key, void *data)
{
  fibnode_t node;

  /* Create the new node.  */
  node = fibnode_new ();

  /* Set the node's data.  */
  node->data = data;
  node->key = key;

  /* Insert it into the root list.  */
  fibheap_ins_root (heap, node);

  /* If their was no minimum, or this key is less than the min,
     it's the new min.  */
  if (heap->min == NULL || node->key < heap->min->key)
    heap->min = node;

  heap->nodes++;

  return node;
}

/* Return the data of the minimum node (if we know it).  */
void *
fibheap_min (fibheap_t heap)
{
  /* If there is no min, we can't easily return it.  */
  if (heap->min == NULL)
    return NULL;
  return heap->min->data;
}

/* Return the key of the minimum node (if we know it).  */
fibheapkey_t
fibheap_min_key (fibheap_t heap)
{
  /* If there is no min, we can't easily return it.  */
  if (heap->min == NULL)
    return 0;
  return heap->min->key;
}

/* Union HEAPA and HEAPB into a new heap.  */
fibheap_t
fibheap_union (fibheap_t heapa, fibheap_t heapb)
{
  fibnode_t a_root, b_root, temp;

  /* If one of the heaps is empty, the union is just the other heap.  */
  if ((a_root = heapa->root) == NULL)
    {
      free (heapa);
      return heapb;
    }
  if ((b_root = heapb->root) == NULL)
    {
      free (heapb);
      return heapa;
    }

  /* Merge them to the next nodes on the opposite chain.  */
  a_root->left->right = b_root;
  b_root->left->right = a_root;
  temp = a_root->left;
  a_root->left = b_root->left;
  b_root->left = temp;
  heapa->nodes += heapb->nodes;

  /* And set the new minimum, if it's changed.  */
  if (fibheap_compare (heapa, heapb->min, heapa->min) < 0)
    heapa->min = heapb->min;

  free (heapb);
  return heapa;
}

/* Extract the data of the minimum node from HEAP.  */
void *
fibheap_extract_min (fibheap_t heap)
{
  fibnode_t z;
  void *ret = NULL;

  /* If we don't have a min set, it means we have no nodes.  */
  if (heap->min != NULL)
    {
      /* Otherwise, extract the min node, free the node, and return the
         node's data.  */
      z = fibheap_extr_min_node (heap);
      ret = z->data;
      free (z);
    }

  return ret;
}

/* Replace both the KEY and the DATA associated with NODE.  */
void *
fibheap_replace_key_data (fibheap_t heap, fibnode_t node,
                          fibheapkey_t key, void *data)
{
  void *odata;
  fibheapkey_t okey;
  fibnode_t y;

  /* If we wanted to, we could actually do a real increase by redeleting and
     inserting. However, this would require O (log n) time. So just bail out
     for now.  */
  if (fibheap_comp_data (heap, key, data, node) > 0)
    return NULL;

  odata = node->data;
  okey = node->key;
  node->data = data;
  node->key = key;
  y = node->parent;

  /* Short-circuit if the key is the same, as we then don't have to
     do anything.  Except if we're trying to force the new node to
     be the new minimum for delete.  */
  if (okey == key && okey != FIBHEAPKEY_MIN)
    return odata;

  /* These two compares are specifically <= 0 to make sure that in the case
     of equality, a node we replaced the data on, becomes the new min.  This
     is needed so that delete's call to extractmin gets the right node.  */
  if (y != NULL && fibheap_compare (heap, node, y) <= 0)
    {
      fibheap_cut (heap, node, y);
      fibheap_cascading_cut (heap, y);
    }

  if (fibheap_compare (heap, node, heap->min) <= 0)
    heap->min = node;

  return odata;
}

/* Replace the DATA associated with NODE.  */
void *
fibheap_replace_data (fibheap_t heap, fibnode_t node, void *data)
{
  return fibheap_replace_key_data (heap, node, node->key, data);
}

/* Replace the KEY associated with NODE.  */
fibheapkey_t
fibheap_replace_key (fibheap_t heap, fibnode_t node, fibheapkey_t key)
{
  int okey = node->key;
  fibheap_replace_key_data (heap, node, key, node->data);
  return okey;
}

/* Delete NODE from HEAP.  */
void *
fibheap_delete_node (fibheap_t heap, fibnode_t node)
{
  void *ret = node->data;

  /* To perform delete, we just make it the min key, and extract.  */
  fibheap_replace_key (heap, node, FIBHEAPKEY_MIN);
  if (node != heap->min)
    {
      fprintf (stderr, "Can't force minimum on fibheap.\n");
      abort ();
    }
  fibheap_extract_min (heap);

  return ret;
}

/* Delete HEAP.  */
void
fibheap_delete (fibheap_t heap)
{
  while (heap->min != NULL)
    free (fibheap_extr_min_node (heap));

  free (heap);
}

/* Determine if HEAP is empty.  */
int
fibheap_empty (fibheap_t heap)
{
  return heap->nodes == 0;
}

/* Extract the minimum node of the heap.  */
static fibnode_t
fibheap_extr_min_node (fibheap_t heap)
{
  fibnode_t ret = heap->min;
  fibnode_t x, y, orig;

  /* Attach the child list of the minimum node to the root list of the heap.
     If there is no child list, we don't do squat.  */
  for (x = ret->child, orig = NULL; x != orig && x != NULL; x = y)
    {
      if (orig == NULL)
	orig = x;
      y = x->right;
      x->parent = NULL;
      fibheap_ins_root (heap, x);
    }

  /* Remove the old root.  */
  fibheap_rem_root (heap, ret);
  heap->nodes--;

  /* If we are left with no nodes, then the min is NULL.  */
  if (heap->nodes == 0)
    heap->min = NULL;
  else
    {
      /* Otherwise, consolidate to find new minimum, as well as do the reorg
         work that needs to be done.  */
      heap->min = ret->right;
      fibheap_consolidate (heap);
    }

  return ret;
}

/* Insert NODE into the root list of HEAP.  */
static void
fibheap_ins_root (fibheap_t heap, fibnode_t node)
{
  /* If the heap is currently empty, the new node becomes the singleton
     circular root list.  */
  if (heap->root == NULL)
    {
      heap->root = node;
      node->left = node;
      node->right = node;
      return;
    }

  /* Otherwise, insert it in the circular root list between the root
     and it's right node.  */
  fibnode_insert_after (heap->root, node);
}

/* Remove NODE from the rootlist of HEAP.  */
static void
fibheap_rem_root (fibheap_t heap, fibnode_t node)
{
  if (node->left == node)
    heap->root = NULL;
  else
    heap->root = fibnode_remove (node);
}

/* Consolidate the heap.  */
static void
fibheap_consolidate (fibheap_t heap)
{
  fibnode_t a[1 + 8 * sizeof (long)];
  fibnode_t w;
  fibnode_t y;
  fibnode_t x;
  int i;
  int d;
  int D;

  D = 1 + 8 * sizeof (long);

  memset (a, 0, sizeof (fibnode_t) * D);

  while ((w = heap->root) != NULL)
    {
      x = w;
      fibheap_rem_root (heap, w);
      d = x->degree;
      while (a[d] != NULL)
	{
	  y = a[d];
	  if (fibheap_compare (heap, x, y) > 0)
	    {
	      fibnode_t temp;
	      temp = x;
	      x = y;
	      y = temp;
	    }
	  fibheap_link (heap, y, x);
	  a[d] = NULL;
	  d++;
	}
      a[d] = x;
    }
  heap->min = NULL;
  for (i = 0; i < D; i++)
    if (a[i] != NULL)
      {
	fibheap_ins_root (heap, a[i]);
	if (heap->min == NULL || fibheap_compare (heap, a[i], heap->min) < 0)
	  heap->min = a[i];
      }
}

/* Make NODE a child of PARENT.  */
static void
fibheap_link (fibheap_t heap ATTRIBUTE_UNUSED,
              fibnode_t node, fibnode_t parent)
{
  if (parent->child == NULL)
    parent->child = node;
  else
    fibnode_insert_before (parent->child, node);
  node->parent = parent;
  parent->degree++;
  node->mark = 0;
}

/* Remove NODE from PARENT's child list.  */
static void
fibheap_cut (fibheap_t heap, fibnode_t node, fibnode_t parent)
{
  fibnode_remove (node);
  parent->degree--;
  fibheap_ins_root (heap, node);
  node->parent = NULL;
  node->mark = 0;
}

static void
fibheap_cascading_cut (fibheap_t heap, fibnode_t y)
{
  fibnode_t z;

  while ((z = y->parent) != NULL)
    {
      if (y->mark == 0)
	{
	  y->mark = 1;
	  return;
	}
      else
	{
	  fibheap_cut (heap, y, z);
	  y = z;
	}
    }
}

static void
fibnode_insert_after (fibnode_t a, fibnode_t b)
{
  if (a == a->right)
    {
      a->right = b;
      a->left = b;
      b->right = a;
      b->left = a;
    }
  else
    {
      b->right = a->right;
      a->right->left = b;
      a->right = b;
      b->left = a;
    }
}

static fibnode_t
fibnode_remove (fibnode_t node)
{
  fibnode_t ret;

  if (node == node->left)
    ret = NULL;
  else
    ret = node->left;

  if (node->parent != NULL && node->parent->child == node)
    node->parent->child = ret;

  node->right->left = node->left;
  node->left->right = node->right;

  node->parent = NULL;
  node->left = node;
  node->right = node;

  return ret;
}
@


1.7
log
@Update the address and phone number of the FSF organization.
@
text
@d217 4
a220 1
  if (okey == key)
d262 5
@


1.6
log
@merge from gcc
@
text
@d19 2
a20 2
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
@


1.5
log
@merge from gcc
@
text
@d40 11
a50 12
static void fibheap_ins_root PARAMS ((fibheap_t, fibnode_t));
static void fibheap_rem_root PARAMS ((fibheap_t, fibnode_t));
static void fibheap_consolidate PARAMS ((fibheap_t));
static void fibheap_link PARAMS ((fibheap_t, fibnode_t, fibnode_t));
static void fibheap_cut PARAMS ((fibheap_t, fibnode_t, fibnode_t));
static void fibheap_cascading_cut PARAMS ((fibheap_t, fibnode_t));
static fibnode_t fibheap_extr_min_node PARAMS ((fibheap_t));
static int fibheap_compare PARAMS ((fibheap_t, fibnode_t, fibnode_t));
static int fibheap_comp_data PARAMS ((fibheap_t, fibheapkey_t, void *,
				      fibnode_t));
static fibnode_t fibnode_new PARAMS ((void));
static void fibnode_insert_after PARAMS ((fibnode_t, fibnode_t));
d52 1
a52 1
static fibnode_t fibnode_remove PARAMS ((fibnode_t));
d57 1
a57 1
fibheap_new ()
d64 1
a64 1
fibnode_new ()
d76 1
a76 4
fibheap_compare (heap, a, b)
     fibheap_t heap ATTRIBUTE_UNUSED;
     fibnode_t a;
     fibnode_t b;
d86 1
a86 5
fibheap_comp_data (heap, key, data, b)
     fibheap_t heap;
     fibheapkey_t key;
     void *data;
     fibnode_t b;
d98 1
a98 4
fibheap_insert (heap, key, data)
     fibheap_t heap;
     fibheapkey_t key;
     void *data;
d124 1
a124 2
fibheap_min (heap)
     fibheap_t heap;
d134 1
a134 2
fibheap_min_key (heap)
     fibheap_t heap;
d144 1
a144 3
fibheap_union (heapa, heapb)
     fibheap_t heapa;
     fibheap_t heapb;
d178 1
a178 2
fibheap_extract_min (heap)
     fibheap_t heap;
d198 2
a199 5
fibheap_replace_key_data (heap, node, key, data)
     fibheap_t heap;
     fibnode_t node;
     fibheapkey_t key;
     void *data;
d237 1
a237 4
fibheap_replace_data (heap, node, data)
     fibheap_t heap;
     fibnode_t node;
     void *data;
d244 1
a244 4
fibheap_replace_key (heap, node, key)
     fibheap_t heap;
     fibnode_t node;
     fibheapkey_t key;
d253 1
a253 3
fibheap_delete_node (heap, node)
     fibheap_t heap;
     fibnode_t node;
d266 1
a266 2
fibheap_delete (heap)
     fibheap_t heap;
d276 1
a276 2
fibheap_empty (heap)
     fibheap_t heap;
d283 1
a283 2
fibheap_extr_min_node (heap)
     fibheap_t heap;
d319 1
a319 3
fibheap_ins_root (heap, node)
     fibheap_t heap;
     fibnode_t node;
d338 1
a338 3
fibheap_rem_root (heap, node)
     fibheap_t heap;
     fibnode_t node;
d348 1
a348 2
fibheap_consolidate (heap)
     fibheap_t heap;
d395 2
a396 4
fibheap_link (heap, node, parent)
     fibheap_t heap ATTRIBUTE_UNUSED;
     fibnode_t node;
     fibnode_t parent;
d409 1
a409 4
fibheap_cut (heap, node, parent)
     fibheap_t heap;
     fibnode_t node;
     fibnode_t parent;
d419 1
a419 3
fibheap_cascading_cut (heap, y)
     fibheap_t heap;
     fibnode_t y;
d439 1
a439 3
fibnode_insert_after (a, b)
     fibnode_t a;
     fibnode_t b;
d458 1
a458 2
fibnode_remove (node)
     fibnode_t node;
@


1.4
log
@merge from gcc
@
text
@d221 1
a221 1
  int okey;
@


1.4.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d221 1
a221 1
  fibheapkey_t okey;
@


1.4.2.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d221 1
a221 1
  fibheapkey_t okey;
@


1.3
log
@merge from gcc
@
text
@d69 1
a69 1
  node = xcalloc (1, sizeof *node);
@


1.3.10.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d69 1
a69 1
  node = (fibnode_t) xcalloc (1, sizeof *node);
@


1.2
log
@merge from gcc
@
text
@a39 1
static void fibheap_init PARAMS ((fibheap_t));
a50 1
static void fibnode_init PARAMS ((fibnode_t));
a55 10
/* Initialize the passed in fibonacci heap.  */
static inline void
fibheap_init (heap)
     fibheap_t heap;
{
  heap->nodes = 0;
  heap->min = NULL;
  heap->root = NULL;
}

d60 1
a60 22
  fibheap_t result;

  if ((result = xmalloc (sizeof (*result))) == NULL)
    return NULL;

  fibheap_init (result);

  return result;
}

/* Initialize the passed in fibonacci heap node.  */
static inline void
fibnode_init (node)
     fibnode_t node;
{
  node->degree = 0;
  node->mark = 0;
  node->parent = NULL;
  node->child = NULL;
  node->left = node;
  node->right = node;
  node->data = NULL;
d64 1
a64 1
static inline fibnode_t
d67 1
a67 1
  fibnode_t e;
d69 3
a71 4
  if ((e = xmalloc (sizeof *e)) == NULL)
    return NULL;

  fibnode_init (e);
d73 1
a73 1
  return e;
d113 2
a114 3
  /* Create the new node, if we fail, return NULL.  */
  if ((node = fibnode_new ()) == NULL)
    return NULL;
@


1.1
log
@merge from gcc
@
text
@a0 1

d22 4
a25 1
/* Fibonacci heaps */
d27 2
d30 4
d38 2
d49 2
a50 1
static int fibheap_comp_data PARAMS ((fibheap_t, fibheapkey_t, void *, fibnode_t));
d57 11
d82 43
a124 3
/* Initialize the passed in fibonacci heap.  */
static void
fibheap_init (heap)
d126 3
d130 6
a135 3
  heap->nodes = 0;
  heap->min = NULL;
  heap->root = NULL;
d146 1
d150 1
d158 2
a159 2
  /* If their was no minimum, or this key is less than the min, it's the new
     min.  */
d196 1
a196 1
  fibnode_t temp;
d199 6
a204 1
  if (heapa->root == NULL || heapb->root == NULL)
d206 2
a207 10
      if (heapa->root == NULL)
	{
	  free (heapa);
	  return heapb;
	}
      else
	{
	  free (heapb);
	  return heapa;
	}
d209 1
d211 5
a215 5
  heapa->root->left->right = heapb->root;
  heapb->root->left->right = heapa->root;
  temp = heapa->root->left;
  heapa->root->left = heapb->root->left;
  heapb->root->left = temp;
d232 1
a232 1
  void *ret;
a233 1
  ret = NULL;
a246 25
/* Replace the DATA associated with NODE.  */
void *
fibheap_replace_data (heap, node, data)
     fibheap_t heap;
     fibnode_t node;
     void *data;
{
  return fibheap_replace_key_data (heap, node, node->key, data);
}

/* Replace the KEY associated with NODE.  */
fibheapkey_t
fibheap_replace_key (heap, node, key)
     fibheap_t heap;
     fibnode_t node;
     fibheapkey_t key;
{
  int ret;

  ret = node->key;
  (void) fibheap_replace_key_data (heap, node, key, node->data);

  return ret;
}

d289 22
d317 2
a318 1
  void *k;
d320 1
a320 2
  k = node->data;
  fibheap_replace_key (heap, node, LONG_MIN);
d323 1
a323 1
  return k;
a344 1

d350 1
a350 1
  fibnode_t ret;
a352 3
  ret = heap->min;

  orig = NULL;
d355 1
a355 1
  for (x = ret->child; x != orig && x != NULL;)
a361 1
      x = y;
d363 1
d367 1
d397 3
a399 2
  /* Otherwise, insert it in the circular root list between the root and it's 
     right node.  */
a514 27

static fibnode_t
fibnode_new ()
{
  fibnode_t e;

  if ((e = xmalloc (sizeof *e)) == NULL)
    return NULL;

  fibnode_init (e);

  return e;
}

static void
fibnode_init (node)
     fibnode_t node;
{
  node->degree = 0;
  node->mark = 0;
  node->parent = NULL;
  node->child = NULL;
  node->left = node;
  node->right = node;
  node->data = NULL;
}

a535 1

a557 28
}

static int
fibheap_compare (heap, a, b)
     fibheap_t heap ATTRIBUTE_UNUSED;
     fibnode_t a;
     fibnode_t b;
{
  if (a->key < b->key)
    return -1;
  if (a->key > b->key)
    return 1;
  return 0;
}

static int
fibheap_comp_data (heap, key, data, b)
     fibheap_t heap;
     fibheapkey_t key;
     void *data;
     fibnode_t b;
{
  struct fibnode a;

  a.key = key;
  a.data = data;

  return fibheap_compare (heap, &a, b);
@

