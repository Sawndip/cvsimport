head	1.25;
access;
symbols
	sid-snapshot-20180601:1.25
	sid-snapshot-20180501:1.25
	sid-snapshot-20180401:1.25
	sid-snapshot-20180301:1.25
	sid-snapshot-20180201:1.25
	sid-snapshot-20180101:1.25
	sid-snapshot-20171201:1.25
	sid-snapshot-20171101:1.25
	sid-snapshot-20171001:1.25
	sid-snapshot-20170901:1.25
	sid-snapshot-20170801:1.25
	sid-snapshot-20170701:1.25
	sid-snapshot-20170601:1.25
	sid-snapshot-20170501:1.25
	sid-snapshot-20170401:1.25
	sid-snapshot-20170301:1.25
	sid-snapshot-20170201:1.25
	sid-snapshot-20170101:1.25
	sid-snapshot-20161201:1.25
	sid-snapshot-20161101:1.25
	sid-snapshot-20160901:1.25
	sid-snapshot-20160801:1.25
	sid-snapshot-20160701:1.25
	sid-snapshot-20160601:1.25
	sid-snapshot-20160501:1.25
	sid-snapshot-20160401:1.25
	sid-snapshot-20160301:1.25
	sid-snapshot-20160201:1.25
	sid-snapshot-20160101:1.25
	sid-snapshot-20151201:1.25
	sid-snapshot-20151101:1.25
	sid-snapshot-20151001:1.25
	sid-snapshot-20150901:1.25
	sid-snapshot-20150801:1.25
	sid-snapshot-20150701:1.25
	sid-snapshot-20150601:1.25
	sid-snapshot-20150501:1.25
	sid-snapshot-20150401:1.25
	sid-snapshot-20150301:1.25
	sid-snapshot-20150201:1.25
	sid-snapshot-20150101:1.25
	sid-snapshot-20141201:1.25
	sid-snapshot-20141101:1.25
	sid-snapshot-20141001:1.25
	sid-snapshot-20140901:1.25
	sid-snapshot-20140801:1.25
	sid-snapshot-20140701:1.25
	sid-snapshot-20140601:1.25
	sid-snapshot-20140501:1.25
	sid-snapshot-20140401:1.25
	sid-snapshot-20140301:1.25
	sid-snapshot-20140201:1.25
	sid-snapshot-20140101:1.25
	sid-snapshot-20131201:1.25
	sid-snapshot-20131101:1.25
	sid-snapshot-20131001:1.25
	binutils-2_24-branch:1.25.0.4
	binutils-2_24-branchpoint:1.25
	binutils-2_21_1:1.22
	sid-snapshot-20130901:1.25
	gdb_7_6_1-2013-08-30-release:1.25
	sid-snapshot-20130801:1.25
	sid-snapshot-20130701:1.25
	sid-snapshot-20130601:1.25
	sid-snapshot-20130501:1.25
	gdb_7_6-2013-04-26-release:1.25
	sid-snapshot-20130401:1.25
	binutils-2_23_2:1.23
	gdb_7_6-branch:1.25.0.2
	gdb_7_6-2013-03-12-branchpoint:1.25
	sid-snapshot-20130301:1.25
	sid-snapshot-20130201:1.25
	sid-snapshot-20130101:1.25
	sid-snapshot-20121201:1.25
	gdb_7_5_1-2012-11-29-release:1.23
	binutils-2_23_1:1.23
	sid-snapshot-20121101:1.25
	binutils-2_23:1.23
	sid-snapshot-20121001:1.25
	sid-snapshot-20120901:1.25
	gdb_7_5-2012-08-17-release:1.23
	sid-snapshot-20120801:1.23
	binutils-2_23-branch:1.23.0.6
	binutils-2_23-branchpoint:1.23
	gdb_7_5-branch:1.23.0.4
	gdb_7_5-2012-07-18-branchpoint:1.23
	sid-snapshot-20120701:1.23
	sid-snapshot-20120601:1.23
	sid-snapshot-20120501:1.23
	binutils-2_22_branch:1.22.0.8
	gdb_7_4_1-2012-04-26-release:1.23
	sid-snapshot-20120401:1.23
	sid-snapshot-20120301:1.23
	sid-snapshot-20120201:1.23
	gdb_7_4-2012-01-24-release:1.23
	sid-snapshot-20120101:1.23
	gdb_7_4-branch:1.23.0.2
	gdb_7_4-2011-12-13-branchpoint:1.23
	sid-snapshot-20111201:1.23
	binutils-2_22:1.22
	sid-snapshot-20111101:1.23
	sid-snapshot-20111001:1.23
	binutils-2_22-branch:1.22.0.6
	binutils-2_22-branchpoint:1.22
	gdb_7_3_1-2011-09-04-release:1.22
	sid-snapshot-20110901:1.22
	sid-snapshot-20110801:1.22
	gdb_7_3-2011-07-26-release:1.22
	sid-snapshot-20110701:1.22
	sid-snapshot-20110601:1.22
	sid-snapshot-20110501:1.22
	gdb_7_3-branch:1.22.0.4
	gdb_7_3-2011-04-01-branchpoint:1.22
	sid-snapshot-20110401:1.22
	sid-snapshot-20110301:1.22
	cygwin-1_7_8-release:1.22
	sid-snapshot-20110201:1.22
	sid-snapshot-20110101:1.22
	binutils-2_21:1.22
	sid-snapshot-20101201:1.22
	binutils-2_21-branch:1.22.0.2
	binutils-2_21-branchpoint:1.22
	sid-snapshot-20101101:1.22
	sid-snapshot-20101001:1.22
	binutils-2_20_1:1.20
	gdb_7_2-2010-09-02-release:1.21
	sid-snapshot-20100901:1.22
	cygwin-1_7_7-release:1.22
	sid-snapshot-20100801:1.21
	gdb_7_2-branch:1.21.0.4
	gdb_7_2-2010-07-07-branchpoint:1.21
	sid-snapshot-20100701:1.21
	sid-snapshot-20100601:1.21
	sid-snapshot-20100501:1.21
	sid-snapshot-20100401:1.21
	gdb_7_1-2010-03-18-release:1.21
	sid-snapshot-20100301:1.21
	gdb_7_1-branch:1.21.0.2
	gdb_7_1-2010-02-18-branchpoint:1.21
	sid-snapshot-20100201:1.21
	sid-snapshot-20100101:1.21
	gdb_7_0_1-2009-12-22-release:1.20
	sid-snapshot-20091201:1.21
	sid-snapshot-20091101:1.21
	binutils-2_20:1.20
	gdb_7_0-2009-10-06-release:1.20
	sid-snapshot-20091001:1.20
	gdb_7_0-branch:1.20.0.34
	gdb_7_0-2009-09-16-branchpoint:1.20
	arc-sim-20090309:1.20
	binutils-arc-20081103-branch:1.20.0.32
	binutils-arc-20081103-branchpoint:1.20
	binutils-2_20-branch:1.20.0.30
	binutils-2_20-branchpoint:1.20
	sid-snapshot-20090901:1.20
	sid-snapshot-20090801:1.20
	msnyder-checkpoint-072509-branch:1.20.0.28
	msnyder-checkpoint-072509-branchpoint:1.20
	sid-snapshot-20090701:1.20
	dje-cgen-play1-branch:1.20.0.26
	dje-cgen-play1-branchpoint:1.20
	sid-snapshot-20090601:1.20
	sid-snapshot-20090501:1.20
	sid-snapshot-20090401:1.20
	arc-20081103-branch:1.20.0.24
	arc-20081103-branchpoint:1.20
	arc-insight_6_8-branch:1.20.0.22
	arc-insight_6_8-branchpoint:1.20
	insight_6_8-branch:1.20.0.20
	insight_6_8-branchpoint:1.20
	sid-snapshot-20090301:1.20
	binutils-2_19_1:1.20
	sid-snapshot-20090201:1.20
	sid-snapshot-20090101:1.20
	reverse-20081226-branch:1.20.0.18
	reverse-20081226-branchpoint:1.20
	sid-snapshot-20081201:1.20
	multiprocess-20081120-branch:1.20.0.16
	multiprocess-20081120-branchpoint:1.20
	sid-snapshot-20081101:1.20
	binutils-2_19:1.20
	sid-snapshot-20081001:1.20
	reverse-20080930-branch:1.20.0.14
	reverse-20080930-branchpoint:1.20
	binutils-2_19-branch:1.20.0.12
	binutils-2_19-branchpoint:1.20
	sid-snapshot-20080901:1.20
	sid-snapshot-20080801:1.20
	reverse-20080717-branch:1.20.0.10
	reverse-20080717-branchpoint:1.20
	sid-snapshot-20080701:1.20
	msnyder-reverse-20080609-branch:1.20.0.8
	msnyder-reverse-20080609-branchpoint:1.20
	drow-reverse-20070409-branch:1.16.0.26
	drow-reverse-20070409-branchpoint:1.16
	sid-snapshot-20080601:1.20
	sid-snapshot-20080501:1.20
	sid-snapshot-20080403:1.20
	sid-snapshot-20080401:1.20
	gdb_6_8-2008-03-27-release:1.20
	sid-snapshot-20080301:1.20
	gdb_6_8-branch:1.20.0.6
	gdb_6_8-2008-02-26-branchpoint:1.20
	sid-snapshot-20080201:1.20
	sid-snapshot-20080101:1.20
	sid-snapshot-20071201:1.20
	sid-snapshot-20071101:1.20
	gdb_6_7_1-2007-10-29-release:1.20
	gdb_6_7-2007-10-10-release:1.20
	sid-snapshot-20071001:1.20
	gdb_6_7-branch:1.20.0.4
	gdb_6_7-2007-09-07-branchpoint:1.20
	binutils-2_18:1.20
	binutils-2_18-branch:1.20.0.2
	binutils-2_18-branchpoint:1.20
	insight_6_6-20070208-release:1.16
	binutils-csl-coldfire-4_1-32:1.16
	binutils-csl-sourcerygxx-4_1-32:1.16
	gdb_6_6-2006-12-18-release:1.16
	binutils-csl-innovasic-fido-3_4_4-33:1.16
	binutils-csl-sourcerygxx-3_4_4-32:1.9.52.2
	binutils-csl-coldfire-4_1-30:1.16
	binutils-csl-sourcerygxx-4_1-30:1.16
	binutils-csl-coldfire-4_1-28:1.16
	binutils-csl-sourcerygxx-4_1-29:1.16
	binutils-csl-sourcerygxx-4_1-28:1.16
	gdb_6_6-branch:1.16.0.24
	gdb_6_6-2006-11-15-branchpoint:1.16
	binutils-csl-arm-2006q3-27:1.16
	binutils-csl-sourcerygxx-4_1-27:1.16
	binutils-csl-arm-2006q3-26:1.16
	binutils-csl-sourcerygxx-4_1-26:1.16
	binutils-csl-sourcerygxx-4_1-25:1.16
	binutils-csl-sourcerygxx-4_1-24:1.16
	binutils-csl-sourcerygxx-4_1-23:1.16
	insight_6_5-20061003-release:1.16
	gdb-csl-symbian-6_4_50_20060226-12:1.16
	binutils-csl-sourcerygxx-4_1-21:1.16
	binutils-csl-arm-2006q3-21:1.16
	binutils-csl-sourcerygxx-4_1-22:1.16
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.16
	binutils-csl-sourcerygxx-4_1-20:1.16
	binutils-csl-arm-2006q3-19:1.16
	binutils-csl-sourcerygxx-4_1-19:1.16
	binutils-csl-sourcerygxx-4_1-18:1.16
	binutils-csl-renesas-4_1-9:1.16
	gdb-csl-sourcerygxx-3_4_4-25:1.15
	binutils-csl-sourcerygxx-3_4_4-25:1.9.52.2
	nickrob-async-20060828-mergepoint:1.16
	gdb-csl-symbian-6_4_50_20060226-11:1.16
	binutils-csl-renesas-4_1-8:1.16
	binutils-csl-renesas-4_1-7:1.16
	binutils-csl-renesas-4_1-6:1.16
	gdb-csl-sourcerygxx-4_1-17:1.16
	binutils-csl-sourcerygxx-4_1-17:1.16
	gdb-csl-20060226-branch-local-2:1.16
	cr-0x5f1:1.16.0.22
	gdb-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-15:1.16
	gdb-csl-sourcerygxx-4_1-13:1.16
	binutils-csl-sourcerygxx-4_1-13:1.16
	binutils-2_17:1.16
	gdb-csl-sourcerygxx-4_1-12:1.16
	binutils-csl-sourcerygxx-4_1-12:1.16
	gdb-csl-sourcerygxx-3_4_4-21:1.16
	binutils-csl-sourcerygxx-3_4_4-21:1.16
	gdb_6_5-20060621-release:1.16
	binutils-csl-wrs-linux-3_4_4-24:1.9
	binutils-csl-wrs-linux-3_4_4-23:1.9
	gdb-csl-sourcerygxx-4_1-9:1.16
	binutils-csl-sourcerygxx-4_1-9:1.16
	gdb-csl-sourcerygxx-4_1-8:1.16
	binutils-csl-sourcerygxx-4_1-8:1.16
	gdb-csl-sourcerygxx-4_1-7:1.16
	binutils-csl-sourcerygxx-4_1-7:1.16
	gdb-csl-arm-2006q1-6:1.16
	binutils-csl-arm-2006q1-6:1.16
	gdb-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-wrs-linux-3_4_4-22:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.16
	gdb-csl-symbian-6_4_50_20060226-9:1.16
	gdb-csl-symbian-6_4_50_20060226-8:1.16
	gdb-csl-coldfire-4_1-11:1.16
	binutils-csl-coldfire-4_1-11:1.16
	gdb-csl-sourcerygxx-3_4_4-19:1.16
	binutils-csl-sourcerygxx-3_4_4-19:1.16
	gdb-csl-coldfire-4_1-10:1.16
	gdb_6_5-branch:1.16.0.20
	gdb_6_5-2006-05-14-branchpoint:1.16
	binutils-csl-coldfire-4_1-10:1.16
	gdb-csl-sourcerygxx-4_1-5:1.16
	binutils-csl-sourcerygxx-4_1-5:1.16
	nickrob-async-20060513-branch:1.16.0.18
	nickrob-async-20060513-branchpoint:1.16
	gdb-csl-sourcerygxx-4_1-4:1.16
	binutils-csl-sourcerygxx-4_1-4:1.16
	msnyder-reverse-20060502-branch:1.16.0.16
	msnyder-reverse-20060502-branchpoint:1.16
	binutils-csl-wrs-linux-3_4_4-21:1.9
	gdb-csl-morpho-4_1-4:1.16
	binutils-csl-morpho-4_1-4:1.16
	gdb-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-wrs-linux-3_4_4-20:1.9
	readline_5_1-import-branch:1.16.0.14
	readline_5_1-import-branchpoint:1.16
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.16
	binutils-2_17-branch:1.16.0.12
	binutils-2_17-branchpoint:1.16
	gdb-csl-symbian-20060226-branch:1.16.0.10
	gdb-csl-symbian-20060226-branchpoint:1.16
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.16
	msnyder-reverse-20060331-branch:1.16.0.8
	msnyder-reverse-20060331-branchpoint:1.16
	binutils-csl-2_17-branch:1.16.0.6
	binutils-csl-2_17-branchpoint:1.16
	gdb-csl-available-20060303-branch:1.16.0.4
	gdb-csl-available-20060303-branchpoint:1.16
	gdb-csl-20060226-branch:1.16.0.2
	gdb-csl-20060226-branchpoint:1.16
	gdb_6_4-20051202-release:1.15
	msnyder-fork-checkpoint-branch:1.15.0.8
	msnyder-fork-checkpoint-branchpoint:1.15
	gdb-csl-gxxpro-6_3-branch:1.15.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.15
	gdb_6_4-branch:1.15.0.4
	gdb_6_4-2005-11-01-branchpoint:1.15
	gdb-csl-arm-20051020-branch:1.15.0.2
	gdb-csl-arm-20051020-branchpoint:1.15
	binutils-csl-gxxpro-3_4-branch:1.9.0.52
	binutils-csl-gxxpro-3_4-branchpoint:1.9
	binutils-2_16_1:1.9
	msnyder-tracepoint-checkpoint-branch:1.13.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.13
	gdb-csl-arm-20050325-2005-q1b:1.9
	binutils-csl-arm-2005q1b:1.9
	binutils-2_16:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	binutils-csl-arm-2005q1a:1.9
	csl-arm-20050325-branch:1.9.0.50
	csl-arm-20050325-branchpoint:1.9
	binutils-csl-arm-2005q1-branch:1.9.0.48
	binutils-csl-arm-2005q1-branchpoint:1.9
	binutils-2_16-branch:1.9.0.46
	binutils-2_16-branchpoint:1.9
	csl-arm-2004-q3d:1.9
	gdb_6_3-20041109-release:1.9
	gdb_6_3-branch:1.9.0.42
	gdb_6_3-20041019-branchpoint:1.9
	csl-arm-2004-q3:1.9
	drow_intercu-merge-20040921:1.9
	drow_intercu-merge-20040915:1.9
	jimb-gdb_6_2-e500-branch:1.9.0.44
	jimb-gdb_6_2-e500-branchpoint:1.9
	gdb_6_2-20040730-release:1.9
	gdb_6_2-branch:1.9.0.40
	gdb_6_2-2004-07-10-gmt-branchpoint:1.9
	gdb_6_1_1-20040616-release:1.9
	binutils-2_15:1.9
	binutils-2_15-branchpoint:1.9
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	gdb_6_1-2004-04-05-release:1.9
	drow_intercu-merge-20040402:1.9
	drow_intercu-merge-20040327:1.9
	ezannoni_pie-20040323-branch:1.9.0.38
	ezannoni_pie-20040323-branchpoint:1.9
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.9.0.36
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.9.0.34
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	drow_intercu-20040221-branch:1.9.0.32
	drow_intercu-20040221-branchpoint:1.9
	binutils-2_15-branch:1.9.0.30
	cagney_bfdfile-20040213-branch:1.9.0.28
	cagney_bfdfile-20040213-branchpoint:1.9
	drow-cplus-merge-20040208:1.9
	carlton_dictionary-20040126-merge:1.9
	cagney_bigcore-20040122-branch:1.9.0.26
	cagney_bigcore-20040122-branchpoint:1.9
	drow-cplus-merge-20040113:1.9
	csl-arm-2003-q4:1.9
	drow-cplus-merge-20031224:1.9
	drow-cplus-merge-20031220:1.9
	carlton_dictionary-20031215-merge:1.9
	drow-cplus-merge-20031214:1.9
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.9
	kettenis_sparc-20030918-branch:1.9.0.24
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.22
	cagney_x86i386-20030821-branch:1.9.0.20
	cagney_x86i386-20030821-branchpoint:1.9
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.18
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.9.0.16
	jimb-ppc64-linux-20030613-branchpoint:1.9
	binutils-2_14:1.9
	cagney_convert-20030606-branch:1.9.0.14
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.9.0.12
	cagney_writestrings-20030508-branchpoint:1.9
	jimb-ppc64-linux-20030528-branch:1.9.0.10
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.9.0.8
	cagney_fileio-20030521-branchpoint:1.9
	kettenis_i386newframe-20030517-mergepoint:1.9
	jimb-ppc64-linux-20030509-branch:1.9.0.6
	jimb-ppc64-linux-20030509-branchpoint:1.9
	kettenis_i386newframe-20030504-mergepoint:1.9
	carlton_dictionary-20030430-merge:1.9
	binutils-2_14-branch:1.9.0.4
	binutils-2_14-branchpoint:1.9
	kettenis_i386newframe-20030419-branch:1.9.0.2
	kettenis_i386newframe-20030419-branchpoint:1.9
	carlton_dictionary-20030416-merge:1.9
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.7.0.42
	kettenis_i386newframe-20030406-branchpoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.7
	cagney_frameaddr-20030403-branch:1.7.0.40
	cagney_framebase-20030330-mergepoint:1.7
	cagney_framebase-20030326-branch:1.7.0.38
	cagney_framebase-20030326-branchpoint:1.7
	cagney_lazyid-20030317-branch:1.7.0.36
	cagney_lazyid-20030317-branchpoint:1.7
	kettenis-i386newframe-20030316-mergepoint:1.7
	offbyone-20030313-branch:1.7.0.34
	offbyone-20030313-branchpoint:1.7
	kettenis-i386newframe-20030308-branch:1.7.0.32
	kettenis-i386newframe-20030308-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.7
	cagney_offbyone-20030303-branch:1.7.0.30
	cagney_offbyone-20030303-branchpoint:1.7
	w32api-2_2:1.7
	mingw-runtime-2_4:1.7
	carlton_dictionary-20030207-merge:1.7
	interps-20030202-branch:1.7.0.28
	interps-20030202-branchpoint:1.7
	cagney-unwind-20030108-branch:1.7.0.26
	cagney-unwind-20030108-branchpoint:1.7
	binutils-2_13_2_1:1.7
	binutils-2_13_2:1.7
	carlton_dictionary-20021223-merge:1.7
	gdb_5_3-2002-12-12-release:1.7
	carlton_dictionary-20021115-merge:1.7
	binutils-2_13_1:1.7
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.7.0.24
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	carlton_dictionary-branch:1.7.0.22
	carlton_dictionary-20020920-branchpoint:1.7
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.20
	gdb_5_3-branch:1.7.0.18
	gdb_5_3-2002-09-04-branchpoint:1.7
	kseitz_interps-20020829-merge:1.7
	cagney_sysregs-20020825-branch:1.7.0.16
	cagney_sysregs-20020825-branchpoint:1.7
	readline_4_3-import-branch:1.7.0.14
	readline_4_3-import-branchpoint:1.7
	binutils-2_13:1.7
	gdb_5_2_1-2002-07-23-release:1.7
	binutils-2_13-branchpoint:1.7
	binutils-2_13-branch:1.7.0.12
	kseitz_interps-20020528-branch:1.7.0.10
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.8
	cagney_regbuf-20020515-branchpoint:1.7
	binutils-2_12_1:1.7
	jimb-macro-020506-branch:1.7.0.6
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	binutils-2_12:1.7
	gdb_5_2-branch:1.7.0.4
	gdb_5_2-2002-03-03-branchpoint:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.3
	binutils-2_11_1:1.3
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.3
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	cygwin-1_1_1:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	egcs_20000222:1.1.1.2
	binutils_latest_snapshot:1.25
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2012.08.29.01.02.41;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2012.08.29.00.45.49;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2011.09.28.20.01.45;	author dj;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.13.11.36.10;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.09.04.49.48;	author dj;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.23.18.01.25;	author dj;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.12.03.10.12;	author dj;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.08.01.29.33;	author dj;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.11.20.01.26;	author dj;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.21.04.28.45;	author dj;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.27.15.21.13;	author mmitchel;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.26.21.02.59;	author mmitchel;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.10.15.33.31;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.16.01.05.04;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.14.02.22.18;	author dj;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.27.05.28.42;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.15.21.29.34;	author dj;	state Exp;
branches
	1.9.52.1;
next	1.8;

1.8
date	2003.04.15.03.53.52;	author dj;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.17.22.35.28;	author dj;	state Exp;
branches
	1.7.22.1
	1.7.24.1;
next	1.6;

1.6
date	2001.10.16.02.55.31;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.07.17.24.36;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.06.18.27.14;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.08.16.37.01;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	99.07.14.17.32.01;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.53;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.9.52.1
date	2005.08.30.19.57.35;	author mmitchel;	state Exp;
branches;
next	1.9.52.2;

1.9.52.2
date	2005.11.18.06.00.25;	author mmitchel;	state Exp;
branches;
next	;

1.7.22.1
date	2003.04.16.19.57.04;	author carlton;	state Exp;
branches;
next	;

1.7.24.1
date	2003.12.14.20.28.02;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.53;	author rth;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.22.15.59.20;	author ian;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Replace malloc with xmalloc

	* argv.c (dupargv): Replace malloc with xmalloc.  Don't check
	xmalloc return.
	(buildargv): Likewise.  Also replace strdup with xstrdup.
	(expandargv): Don't check dupargv return.
@
text
@/* Create and destroy argument vectors (argv's)
   Copyright (C) 1992, 2001, 2010, 2012 Free Software Foundation, Inc.
   Written by Fred Fish @@ Cygnus Support

This file is part of the libiberty library.
Libiberty is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

Libiberty is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libiberty; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */


/*  Create and destroy argument vectors.  An argument vector is simply an
    array of string pointers, terminated by a NULL pointer. */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include "ansidecl.h"
#include "libiberty.h"
#include "safe-ctype.h"

/*  Routines imported from standard C runtime libraries. */

#include <stddef.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#ifndef NULL
#define NULL 0
#endif

#ifndef EOS
#define EOS '\0'
#endif

#define INITIAL_MAXARGC 8	/* Number of args + NULL in initial argv */


/*

@@deftypefn Extension char** dupargv (char **@@var{vector})

Duplicate an argument vector.  Simply scans through @@var{vector},
duplicating each argument until the terminating @@code{NULL} is found.
Returns a pointer to the argument vector if successful.  Returns
@@code{NULL} if there is insufficient memory to complete building the
argument vector.

@@end deftypefn

*/

char **
dupargv (char **argv)
{
  int argc;
  char **copy;
  
  if (argv == NULL)
    return NULL;
  
  /* the vector */
  for (argc = 0; argv[argc] != NULL; argc++);
  copy = (char **) xmalloc ((argc + 1) * sizeof (char *));

  /* the strings */
  for (argc = 0; argv[argc] != NULL; argc++)
    {
      int len = strlen (argv[argc]);
      copy[argc] = (char *) xmalloc (len + 1);
      strcpy (copy[argc], argv[argc]);
    }
  copy[argc] = NULL;
  return copy;
}

/*

@@deftypefn Extension void freeargv (char **@@var{vector})

Free an argument vector that was built using @@code{buildargv}.  Simply
scans through @@var{vector}, freeing the memory for each argument until
the terminating @@code{NULL} is found, and then frees @@var{vector}
itself.

@@end deftypefn

*/

void freeargv (char **vector)
{
  register char **scan;

  if (vector != NULL)
    {
      for (scan = vector; *scan != NULL; scan++)
	{
	  free (*scan);
	}
      free (vector);
    }
}

static void
consume_whitespace (const char **input)
{
  while (ISSPACE (**input))
    {
      (*input)++;
    }
}

static int
only_whitespace (const char* input)
{
  while (*input != EOS && ISSPACE (*input))
    input++;

  return (*input == EOS);
}

/*

@@deftypefn Extension char** buildargv (char *@@var{sp})

Given a pointer to a string, parse the string extracting fields
separated by whitespace and optionally enclosed within either single
or double quotes (which are stripped off), and build a vector of
pointers to copies of the string for each field.  The input string
remains unchanged.  The last element of the vector is followed by a
@@code{NULL} element.

All of the memory for the pointer array and copies of the string
is obtained from @@code{xmalloc}.  All of the memory can be returned to the
system with the single function call @@code{freeargv}, which takes the
returned result of @@code{buildargv}, as it's argument.

Returns a pointer to the argument vector if successful.  Returns
@@code{NULL} if @@var{sp} is @@code{NULL} or if there is insufficient
memory to complete building the argument vector.

If the input is a null string (as opposed to a @@code{NULL} pointer),
then buildarg returns an argument vector that has one arg, a null
string.

@@end deftypefn

The memory for the argv array is dynamically expanded as necessary.

In order to provide a working buffer for extracting arguments into,
with appropriate stripping of quotes and translation of backslash
sequences, we allocate a working buffer at least as long as the input
string.  This ensures that we always have enough space in which to
work, since the extracted arg is never larger than the input string.

The argument vector is always kept terminated with a @@code{NULL} arg
pointer, so it can be passed to @@code{freeargv} at any time, or
returned, as appropriate.

*/

char **buildargv (const char *input)
{
  char *arg;
  char *copybuf;
  int squote = 0;
  int dquote = 0;
  int bsquote = 0;
  int argc = 0;
  int maxargc = 0;
  char **argv = NULL;
  char **nargv;

  if (input != NULL)
    {
      copybuf = (char *) xmalloc (strlen (input) + 1);
      /* Is a do{}while to always execute the loop once.  Always return an
	 argv, even for null strings.  See NOTES above, test case below. */
      do
	{
	  /* Pick off argv[argc] */
	  consume_whitespace (&input);

	  if ((maxargc == 0) || (argc >= (maxargc - 1)))
	    {
	      /* argv needs initialization, or expansion */
	      if (argv == NULL)
		{
		  maxargc = INITIAL_MAXARGC;
		  nargv = (char **) xmalloc (maxargc * sizeof (char *));
		}
	      else
		{
		  maxargc *= 2;
		  nargv = (char **) xrealloc (argv, maxargc * sizeof (char *));
		}
	      argv = nargv;
	      argv[argc] = NULL;
	    }
	  /* Begin scanning arg */
	  arg = copybuf;
	  while (*input != EOS)
	    {
	      if (ISSPACE (*input) && !squote && !dquote && !bsquote)
		{
		  break;
		}
	      else
		{
		  if (bsquote)
		    {
		      bsquote = 0;
		      *arg++ = *input;
		    }
		  else if (*input == '\\')
		    {
		      bsquote = 1;
		    }
		  else if (squote)
		    {
		      if (*input == '\'')
			{
			  squote = 0;
			}
		      else
			{
			  *arg++ = *input;
			}
		    }
		  else if (dquote)
		    {
		      if (*input == '"')
			{
			  dquote = 0;
			}
		      else
			{
			  *arg++ = *input;
			}
		    }
		  else
		    {
		      if (*input == '\'')
			{
			  squote = 1;
			}
		      else if (*input == '"')
			{
			  dquote = 1;
			}
		      else
			{
			  *arg++ = *input;
			}
		    }
		  input++;
		}
	    }
	  *arg = EOS;
	  argv[argc] = xstrdup (copybuf);
	  argc++;
	  argv[argc] = NULL;

	  consume_whitespace (&input);
	}
      while (*input != EOS);

      free (copybuf);
    }
  return (argv);
}

/*

@@deftypefn Extension int writeargv (const char **@@var{argv}, FILE *@@var{file})

Write each member of ARGV, handling all necessary quoting, to the file
named by FILE, separated by whitespace.  Return 0 on success, non-zero
if an error occurred while writing to FILE.

@@end deftypefn

*/

int
writeargv (char **argv, FILE *f)
{
  int status = 0;

  if (f == NULL)
    return 1;

  while (*argv != NULL)
    {
      const char *arg = *argv;

      while (*arg != EOS)
        {
          char c = *arg;

          if (ISSPACE(c) || c == '\\' || c == '\'' || c == '"')
            if (EOF == fputc ('\\', f))
              {
                status = 1;
                goto done;
              }

          if (EOF == fputc (c, f))
            {
              status = 1;
              goto done;
            }
          arg++;
        }

      if (EOF == fputc ('\n', f))
        {
          status = 1;
          goto done;
        }
      argv++;
    }

 done:
  return status;
}

/*

@@deftypefn Extension void expandargv (int *@@var{argcp}, char ***@@var{argvp})

The @@var{argcp} and @@code{argvp} arguments are pointers to the usual
@@code{argc} and @@code{argv} arguments to @@code{main}.  This function
looks for arguments that begin with the character @@samp{@@@@}.  Any such
arguments are interpreted as ``response files''.  The contents of the
response file are interpreted as additional command line options.  In
particular, the file is separated into whitespace-separated strings;
each such string is taken as a command-line option.  The new options
are inserted in place of the option naming the response file, and
@@code{*argcp} and @@code{*argvp} will be updated.  If the value of
@@code{*argvp} is modified by this function, then the new value has
been dynamically allocated and can be deallocated by the caller with
@@code{freeargv}.  However, most callers will simply call
@@code{expandargv} near the beginning of @@code{main} and allow the
operating system to free the memory when the program exits.

@@end deftypefn

*/

void
expandargv (int *argcp, char ***argvp)
{
  /* The argument we are currently processing.  */
  int i = 0;
  /* Non-zero if ***argvp has been dynamically allocated.  */
  int argv_dynamic = 0;
  /* Limit the number of response files that we parse in order
     to prevent infinite recursion.  */
  unsigned int iteration_limit = 2000;
  /* Loop over the arguments, handling response files.  We always skip
     ARGVP[0], as that is the name of the program being run.  */
  while (++i < *argcp)
    {
      /* The name of the response file.  */
      const char *filename;
      /* The response file.  */
      FILE *f;
      /* An upper bound on the number of characters in the response
	 file.  */
      long pos;
      /* The number of characters in the response file, when actually
	 read.  */
      size_t len;
      /* A dynamically allocated buffer used to hold options read from a
	 response file.  */
      char *buffer;
      /* Dynamically allocated storage for the options read from the
	 response file.  */
      char **file_argv;
      /* The number of options read from the response file, if any.  */
      size_t file_argc;
      /* We are only interested in options of the form "@@file".  */
      filename = (*argvp)[i];
      if (filename[0] != '@@')
	continue;
      /* If we have iterated too many times then stop.  */
      if (-- iteration_limit == 0)
	{
	  fprintf (stderr, "%s: error: too many @@-files encountered\n", (*argvp)[0]);
	  xexit (1);
	}
      /* Read the contents of the file.  */
      f = fopen (++filename, "r");
      if (!f)
	continue;
      if (fseek (f, 0L, SEEK_END) == -1)
	goto error;
      pos = ftell (f);
      if (pos == -1)
	goto error;
      if (fseek (f, 0L, SEEK_SET) == -1)
	goto error;
      buffer = (char *) xmalloc (pos * sizeof (char) + 1);
      len = fread (buffer, sizeof (char), pos, f);
      if (len != (size_t) pos
	  /* On Windows, fread may return a value smaller than POS,
	     due to CR/LF->CR translation when reading text files.
	     That does not in-and-of itself indicate failure.  */
	  && ferror (f))
	goto error;
      /* Add a NUL terminator.  */
      buffer[len] = '\0';
      /* If the file is empty or contains only whitespace, buildargv would
	 return a single empty argument.  In this context we want no arguments,
	 instead.  */
      if (only_whitespace (buffer))
	{
	  file_argv = (char **) xmalloc (sizeof (char *));
	  file_argv[0] = NULL;
	}
      else
	/* Parse the string.  */
	file_argv = buildargv (buffer);
      /* If *ARGVP is not already dynamically allocated, copy it.  */
      if (!argv_dynamic)
	*argvp = dupargv (*argvp);
      /* Count the number of arguments.  */
      file_argc = 0;
      while (file_argv[file_argc])
	++file_argc;
      /* Now, insert FILE_ARGV into ARGV.  The "+1" below handles the
	 NULL terminator at the end of ARGV.  */ 
      *argvp = ((char **) 
		xrealloc (*argvp, 
			  (*argcp + file_argc + 1) * sizeof (char *)));
      memmove (*argvp + i + file_argc, *argvp + i + 1, 
	       (*argcp - i) * sizeof (char *));
      memcpy (*argvp + i, file_argv, file_argc * sizeof (char *));
      /* The original option has been replaced by all the new
	 options.  */
      *argcp += file_argc - 1;
      /* Free up memory allocated to process the response file.  We do
	 not use freeargv because the individual options in FILE_ARGV
	 are now in the main ARGV.  */
      free (file_argv);
      free (buffer);
      /* Rescan all of the arguments just read to support response
	 files that include other response files.  */
      --i;
    error:
      /* We're all done with the file now.  */
      fclose (f);
    }
}

/*

@@deftypefn Extension int countargv (char **@@var{argv})

Return the number of elements in @@var{argv}.
Returns zero if @@var{argv} is NULL.

@@end deftypefn

*/

int
countargv (char **argv)
{
  int argc;

  if (argv == NULL)
    return 0;
  for (argc = 0; argv[argc] != NULL; argc++)
    continue;
  return argc;
}

#ifdef MAIN

/* Simple little test driver. */

static const char *const tests[] =
{
  "a simple command line",
  "arg 'foo' is single quoted",
  "arg \"bar\" is double quoted",
  "arg \"foo bar\" has embedded whitespace",
  "arg 'Jack said \\'hi\\'' has single quotes",
  "arg 'Jack said \\\"hi\\\"' has double quotes",
  "a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9",
  
  /* This should be expanded into only one argument.  */
  "trailing-whitespace ",

  "",
  NULL
};

int
main (void)
{
  char **argv;
  const char *const *test;
  char **targs;

  for (test = tests; *test != NULL; test++)
    {
      printf ("buildargv(\"%s\")\n", *test);
      if ((argv = buildargv (*test)) == NULL)
	{
	  printf ("failed!\n\n");
	}
      else
	{
	  for (targs = argv; *targs != NULL; targs++)
	    {
	      printf ("\t\"%s\"\n", *targs);
	    }
	  printf ("\n");
	}
      freeargv (argv);
    }

  return 0;
}

#endif	/* MAIN */
@


1.24
log
@Replace alloca with xmalloc/free

	PR binutils/14526
	* argv.c (buildargv): Replace alloca with xmalloc/free.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 2001, 2010 Free Software Foundation, Inc.
d75 2
a76 4
  copy = (char **) malloc ((argc + 1) * sizeof (char *));
  if (copy == NULL)
    return NULL;
  
d81 1
a81 6
      copy[argc] = (char *) malloc (len + 1);
      if (copy[argc] == NULL)
	{
	  freeargv (copy);
	  return NULL;
	}
d145 1
a145 1
is obtained from @@code{malloc}.  All of the memory can be returned to the
d201 1
a201 1
		  nargv = (char **) malloc (maxargc * sizeof (char *));
d206 1
a206 10
		  nargv = (char **) realloc (argv, maxargc * sizeof (char *));
		}
	      if (nargv == NULL)
		{
		  if (argv != NULL)
		    {
		      freeargv (argv);
		      argv = NULL;
		    }
		  break;
d271 1
a271 7
	  argv[argc] = strdup (copybuf);
	  if (argv[argc] == NULL)
	    {
	      freeargv (argv);
	      argv = NULL;
	      break;
	    }
d438 1
a438 8
	{
	  *argvp = dupargv (*argvp);
	  if (!*argvp)
	    {
	      fputs ("\nout of memory\n", stderr);
	      xexit (1);
	    }
	}
@


1.23
log
@merge from gcc
@
text
@d194 1
a194 1
      copybuf = (char *) alloca (strlen (input) + 1);
d300 2
@


1.22
log
@        * argv.c (expandargv): Limit the number of times that response
        files are opened in order to prevent infinite recursion.
@
text
@d495 23
@


1.21
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright (C) 1992, 2001 Free Software Foundation, Inc.
d389 3
d418 6
@


1.20
log
@merge from gcc
@
text
@d122 18
d200 2
a201 4
	  while (ISBLANK (*input))
	    {
	      input++;
	    }
d297 1
a297 4
	  while (ISSPACE (*input))
	    {
	      input++;
	    }
d436 11
a446 2
      /* Parse the string.  */
      file_argv = buildargv (buffer);
d459 1
a459 1
      while (file_argv[file_argc] && *file_argv[file_argc])
@


1.19
log
@merge from gcc
@
text
@d293 1
a293 1
@@deftypefn Extension int writeargv (const char **@@var{argv}, FILE *@@{file})
@


1.18
log
@merge from gcc
@
text
@a312 1
      int ret;
@


1.17
log
@merge from gcc
@
text
@d293 56
@


1.16
log
@merge from gcc
@
text
@d315 1
a315 3
expandargv (argcp, argvp)
     int *argcp;
     char ***argvp;
@


1.15
log
@	* argv.c (expandargv): Do not use xmalloc_failed.
@
text
@d331 2
a332 1
      /* The number of characters in the response file.  */
d334 3
d344 1
a344 1
     size_t file_argc;
d361 6
a366 1
      if (fread (buffer, sizeof (char), pos, f) != (size_t) pos)
d369 1
a369 1
      buffer[pos] = '\0';
@


1.14
log
@	* libiberty.h (expandargv): New function.

	* argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(buildargv): Use ISSPACE instead of ISBLANK.
	(expandargv): New function.
	* Makefile.in: Regenerated.
@
text
@d368 4
a371 3
	    /* We do not know exactly many bytes dupargv tried to
	       allocate, so make a guess.  */
	    xmalloc_failed (*argcp * 32);
@


1.13
log
@Update the address and phone number of the FSF organization.
@
text
@d30 1
a30 2

#define ISBLANK(ch) ((ch) == ' ' || (ch) == '\t')
d37 1
d215 1
a215 1
	      if (ISBLANK (*input) && !squote && !dquote && !bsquote)
d281 1
a281 1
	  while (ISBLANK (*input))
d291 110
@


1.12
log
@merge from gcc
@
text
@d18 2
a19 2
not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
@


1.11
log
@merge from gcc
@
text
@d25 3
@


1.10
log
@merge from gcc
@
text
@d80 1
a80 1
      copy[argc] = malloc (sizeof (char *) * (len + 1));
@


1.9
log
@merge from gcc
@
text
@a31 2
#ifdef ANSI_PROTOTYPES

a35 14
#else	/* !ANSI_PROTOTYPES */

#if !defined _WIN32 || defined __GNUC__
extern char *memcpy ();		/* Copy memory region */
extern int strlen ();		/* Count length of string */
extern char *malloc ();		/* Standard memory allocater */
extern char *realloc ();	/* Standard memory reallocator */
extern void free ();		/* Free malloc'd memory */
extern char *strdup ();		/* Duplicate a string */
#endif

#endif	/* ANSI_PROTOTYPES */


d62 1
a62 2
dupargv (argv)
     char **argv;
d105 1
a105 2
void freeargv (vector)
char **vector;
d159 1
a159 2
char **buildargv (input)
     const char *input;
d309 2
a310 1
int main ()
@


1.9.52.1
log
@	* ld/ldmain.c (main): Use expandargv.
	* binutils/addr2line.c (main): Likewise.
	* binutils/ar.c (main): Likewise.
	* binutils/coffdump.c (main): Likewise.
	* binutils/cxxfilt.c (main): Likewise.
	* binutils/dlltool.c (main): Likewise.
	* binutils/dllwrap.c (main): Likewise.
	* binutils/nlmconv.c (main): Likewise.
	* binutils/nm.c (main): Likewise.
	* binutils/objcopy.c (main): Likewise.
	* binutils/objdump.c (main): Likewise.
	* binutils/readelf.c (main): Likewise.
	* binutils/size.c (main): Likeiwse.
	* binutils/srcconv.c (main): Likewise.
	* binutils/strings.c (main): Likewise.
	* binutils/sysdump.c (main): Likewise.
	* binutils/sysinfo.c (main): Likewise.
	* binutils/windres.c (main): Likewise.

	* include/libiberty.h (expandargv): New function.
	* libiberty/argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(expandargv): New function.
	* libiberty/Makefile.in: Regenerated.
@
text
@a26 1
#include "safe-ctype.h"
d28 1
a28 1
#include <stdio.h>
a306 138
/*

@@deftypefn Extension void expandargv (int *@@var{argcp}, char ***@@var{argvp})

The @@var{argcp} and @@code{argvp} arguments are pointers to the usual
@@code{argc} and @@code{argv} arguments to @@code{main}.  This function
looks for arguments that begin with the character @@samp{@@@@}.  Any such
arguments are interpreted as ``response files''.  The contents of the
response file are interpreted as additional command line options.  In
particular, the file is separated into whitespace-separated strings;
each such string is taken as a command-line option.  The new options
are inserted in place of the option naming the response file, and
@@code{*argcp} and @@code{*argvp} will be updated.  If the value of
@@code{*argvp} is modified by this function, then the new value has
been dynamically allocated and should be deallocated by the caller
with @@code{freeargv}.

@@end deftypefn

*/

void
expandargv (argcp, argvp)
     int *argcp;
     char ***argvp;
{
  /* A dynamically allocated buffer used to hold options read from a
     response file.  NULL until needed.  */
  char *buffer = NULL;
  /* The number of bytes in BUFFER.  */
  size_t buffer_len = 0;
  /* Dynamically allocated storage for the options read from the
     response file.  NULL until needed.  */
  char **file_options = NULL;
  /* The number of slots in the FILE_OPTIONS array.  */
  size_t file_options_len = 0;
  /* If non-NULL, the name of the response file that caused a
     failure.  */
  const char *error_file = NULL;
  /* The argument we are currently processing.  */
  int i = 0;
  /* Non-zero if ***argvp has been dynamically allocated.  */
  int argv_dynamic = 0;

  /* Loop over the arguments, handling response files.  We always skip
     ARGVP[0], as that is the name of the program being run.  */
  while (++i != *argcp)
    {
      /* The name of the response file.  */
      const char *filename;
      /* The response file.  */
      FILE *f;
      /* The number of options read from the response file, if any.  */
      size_t num_options;

      /* We are only interested in options of the form "@@file".  */
      filename = (*argvp)[i];
      if (filename[0] != '@@')
	continue;

      /* Open the file.  */
      f = fopen (++filename, "r");
      if (!f)
	continue;

      /* Read all the options.  */
      num_options = 0;
      while (1)
	{
	  /* The insertion point in BUFFER.  */
	  size_t buffer_pos = 0;
	  /* The character immediately following the option in
	     BUFFER.  */
	  int c;
	  /* Read the next option from the file.  */
	  while (1)
	    {
	      if (buffer_pos + 32 > buffer_len)
		{
		  buffer_len = buffer_len ? 2 * buffer_len : 32;
		  buffer = (char *) xrealloc (buffer, buffer_len);
		}
	      c = fscanf (f, "%31s", buffer + buffer_pos);
	      if (c == EOF)
		break;
	      /* If the next character in the file is not whitespace,
		 then we didn't yet read the entire argument.  */
	      c = getc (f);
	      if (c == EOF || ISSPACE (c))
		break;
	      /* Put back the character at which we peeked.  */
	      ungetc (c, f);
	      buffer_pos += 31;
	    }
	  if (c == EOF)
	    break;
	  /* Insert the option into FILE_OPTIONS.  */
	  if (num_options == file_options_len)
	    {
	      file_options_len = file_options_len ? 2 * file_options_len : 32;
	      file_options
		= (char **) xrealloc (file_options,
				      file_options_len * sizeof (char *));
	    }
	  file_options[num_options++] = xstrdup(buffer);
	}

      /* We're done with the file now.  */
      fclose (f);
      /* Insert all the options into ARGV.  */
      if (!argv_dynamic)
	{
	  *argvp = dupargv (*argvp);
	  if (!*argvp)
	    /* We do not know exactly many bytes dupargv tried to
	       allocate, so make a guess.  */
	    xmalloc_failed (*argcp * 32);
	}
      /* The "+1" below handles the NULL terminator at the end of ARGV.  */
      *argvp = ((char **) 
		xrealloc (*argvp, 
			  (*argcp + num_options + 1) * sizeof (char *)));
      memmove (*argvp + i + num_options, *argvp + i + 1, 
	       (*argcp - i) * sizeof (char *));
      memcpy (*argvp + i, file_options, num_options * sizeof (char *));
      /* The original option has been replaced by all the new
	 options.  */
      *argcp += num_options - 1;
    }

  if (buffer)
    free (buffer);
  if (file_options)
    free (file_options);

  return error_file;
}

@


1.9.52.2
log
@	Issue #488
	* libiberty/argv.c (expandargv): Check for errors with ferror,
	rather than by looking at return value from fread.
@
text
@d232 1
a232 1
	      if (ISSPACE (*input) && !squote && !dquote && !bsquote)
d298 1
a298 1
	  while (ISSPACE (*input))
d334 13
d351 1
d354 1
a354 1
  while (++i < *argcp)
a359 12
      /* An upper bound on the number of characters in the response
	 file.  */
      long pos;
      /* The number of characters in the response file, when actually
	 read.  */
      size_t len;
      /* A dynamically allocated buffer used to hold options read from a
	 response file.  */
      char *buffer;
      /* Dynamically allocated storage for the options read from the
	 response file.  */
      char **file_argv;
d361 2
a362 1
      size_t file_argc;
d367 2
a368 1
      /* Read the contents of the file.  */
d372 46
a417 20
      if (fseek (f, 0L, SEEK_END) == -1)
	goto error;
      pos = ftell (f);
      if (pos == -1)
	goto error;
      if (fseek (f, 0L, SEEK_SET) == -1)
	goto error;
      buffer = (char *) xmalloc (pos * sizeof (char) + 1);
      len = fread (buffer, sizeof (char), pos, f);
      if (len != (size_t) pos
	  /* On Windows, fread may return a value smaller than POS,
	     due to CR/LF->CR translation when reading text files.
	     That does not in-and-of itself indicate failure.  */
	  && ferror (f))
	goto error;
      /* Add a NUL terminator.  */
      buffer[len] = '\0';
      /* Parse the string.  */
      file_argv = buildargv (buffer);
      /* If *ARGVP is not already dynamically allocated, copy it.  */
d426 1
a426 6
      /* Count the number of arguments.  */
      file_argc = 0;
      while (file_argv[file_argc] && *file_argv[file_argc])
	++file_argc;
      /* Now, insert FILE_ARGV into ARGV.  The "+1" below handles the
	 NULL terminator at the end of ARGV.  */ 
d429 2
a430 2
			  (*argcp + file_argc + 1) * sizeof (char *)));
      memmove (*argvp + i + file_argc, *argvp + i + 1, 
d432 1
a432 1
      memcpy (*argvp + i, file_argv, file_argc * sizeof (char *));
d435 1
a435 12
      *argcp += file_argc - 1;
      /* Free up memory allocated to process the response file.  We do
	 not use freeargv because the individual options in FILE_ARGV
	 are now in the main ARGV.  */
      free (file_argv);
      free (buffer);
      /* Rescan all of the arguments just read to support response
	 files that include other response files.  */
      --i;
    error:
      /* We're all done with the file now.  */
      fclose (f);
d437 7
@


1.8
log
@merge from gcc
@
text
@d38 1
a38 1
#else	/* !__STDC__ */
d49 1
a49 1
#endif	/* __STDC__ */
@


1.7
log
@merge from gcc
@
text
@d32 1
a32 1
#ifdef __STDC__
@


1.7.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d32 1
a32 1
#ifdef ANSI_PROTOTYPES
d38 1
a38 1
#else	/* !ANSI_PROTOTYPES */
d49 1
a49 1
#endif	/* ANSI_PROTOTYPES */
@


1.7.22.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d32 1
a32 1
#ifdef ANSI_PROTOTYPES
d38 1
a38 1
#else	/* !ANSI_PROTOTYPES */
d49 1
a49 1
#endif	/* ANSI_PROTOTYPES */
@


1.6
log
@merge from gcc
@
text
@d69 1
a69 1
Returns a pointer to the argument vector if successful. Returns
d153 1
a153 1
Returns a pointer to the argument vector if successful. Returns
@


1.5
log
@merge from gcc
@
text
@d65 1
a65 1
NAME
d67 5
a71 1
	dupargv -- duplicate an argument vector
d73 1
a73 16
SYNOPSIS

	char **dupargv (vector)
	char **vector;

DESCRIPTION

	Duplicate an argument vector.  Simply scans through the
	vector, duplicating each argument until the
	terminating NULL is found.

RETURNS

	Returns a pointer to the argument vector if
	successful. Returns NULL if there is insufficient memory to
	complete building the argument vector.
d111 1
a111 3
NAME

	freeargv -- free an argument vector
d113 4
a116 1
SYNOPSIS
d118 1
a118 12
	void freeargv (vector)
	char **vector;

DESCRIPTION

	Free an argument vector that was built using buildargv.  Simply scans
	through the vector, freeing the memory for each argument until the
	terminating NULL is found, and then frees the vector itself.

RETURNS

	No value.
d139 1
a139 37
NAME

	buildargv -- build an argument vector from a string

SYNOPSIS

	char **buildargv (sp)
	char *sp;

DESCRIPTION

	Given a pointer to a string, parse the string extracting fields
	separated by whitespace and optionally enclosed within either single
	or double quotes (which are stripped off), and build a vector of
	pointers to copies of the string for each field.  The input string
	remains unchanged.

	All of the memory for the pointer array and copies of the string
	is obtained from malloc.  All of the memory can be returned to the
	system with the single function call freeargv, which takes the
	returned result of buildargv, as it's argument.

	The memory for the argv array is dynamically expanded as necessary.

RETURNS

	Returns a pointer to the argument vector if successful. Returns NULL
	if the input string pointer is NULL or if there is insufficient
	memory to complete building the argument vector.

NOTES

	In order to provide a working buffer for extracting arguments into,
	with appropriate stripping of quotes and translation of backslash
	sequences, we allocate a working buffer at least as long as the input
	string.  This ensures that we always have enough space in which to
	work, since the extracted arg is never larger than the input string.
d141 33
a173 2
	If the input is a null string (as opposed to a NULL pointer), then
	buildarg returns an argv that has one arg, a null string.
a174 2
	Argv is always kept terminated with a NULL arg pointer, so it can
	be passed to freeargv at any time, or returned, as appropriate.
@


1.4
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright (C) 1992 Free Software Foundation, Inc.
d206 1
a206 1
char *input;
d339 1
a339 1
static char *tests[] =
d356 1
a356 1
main ()
d359 1
a359 1
  char **test;
d380 1
@


1.3
log
@* safe-ctype.c: New file.
* Makefile.in (CFILES): Add safe-ctype.c.
(REQUIRED_OFILES): Add safe-ctype.o.

* argv.c: Define ISBLANK and use it, not isspace.
* basename.c, cplus-dem.c, fnmatch.c, pexecute.c, strtod.c,
strtol.c, strtoul.c: Include safe-ctype.h, not ctype.h.  Use
uppercase ctype macros.  Don't test ISUPPER(c)/ISLOWER(c)
before calling TOLOWER(c)/TOUPPER(c).
@
text
@a50 1
#include "alloca-conf.h"
@


1.2
log
@        * argv.c: Include stdlib.h and string.h instead of
        prototyping directly.
        * choose-temp.c: Conditionally include string.h.
@
text
@d28 1
a28 4
#ifdef isspace
#undef isspace
#endif
#define isspace(ch) ((ch) == ' ' || (ch) == '\t')
d227 1
a227 1
	  while (isspace (*input))
d260 1
a260 1
	      if (isspace (*input) && !squote && !dquote && !bsquote)
d326 1
a326 1
	  while (isspace (*input))
@


1.1
log
@Initial revision
@
text
@d38 2
a39 6
extern void *memcpy (void *s1, const void *s2, size_t n);	/* 4.11.2.1 */
extern size_t strlen (const char *s);				/* 4.11.6.3 */
extern void *malloc (size_t size);				/* 4.10.3.3 */
extern void *realloc (void *ptr, size_t size);			/* 4.10.3.4 */
extern void free (void *ptr);					/* 4.10.3.2 */
extern char *strdup (const char *s);				/* Non-ANSI */
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.2
log
@import libiberty from egcs
@
text
@d38 6
a43 2
#include <string.h>
#include <stdlib.h>
@


