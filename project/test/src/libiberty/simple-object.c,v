head	1.4;
access;
symbols
	sid-snapshot-20180601:1.4
	sid-snapshot-20180501:1.4
	sid-snapshot-20180401:1.4
	sid-snapshot-20180301:1.4
	sid-snapshot-20180201:1.4
	sid-snapshot-20180101:1.4
	sid-snapshot-20171201:1.4
	sid-snapshot-20171101:1.4
	sid-snapshot-20171001:1.4
	sid-snapshot-20170901:1.4
	sid-snapshot-20170801:1.4
	sid-snapshot-20170701:1.4
	sid-snapshot-20170601:1.4
	sid-snapshot-20170501:1.4
	sid-snapshot-20170401:1.4
	sid-snapshot-20170301:1.4
	sid-snapshot-20170201:1.4
	sid-snapshot-20170101:1.4
	sid-snapshot-20161201:1.4
	sid-snapshot-20161101:1.4
	sid-snapshot-20160901:1.4
	sid-snapshot-20160801:1.4
	sid-snapshot-20160701:1.4
	sid-snapshot-20160601:1.4
	sid-snapshot-20160501:1.4
	sid-snapshot-20160401:1.4
	sid-snapshot-20160301:1.4
	sid-snapshot-20160201:1.4
	sid-snapshot-20160101:1.4
	sid-snapshot-20151201:1.4
	sid-snapshot-20151101:1.4
	sid-snapshot-20151001:1.4
	sid-snapshot-20150901:1.4
	sid-snapshot-20150801:1.4
	sid-snapshot-20150701:1.4
	sid-snapshot-20150601:1.4
	sid-snapshot-20150501:1.4
	sid-snapshot-20150401:1.4
	sid-snapshot-20150301:1.4
	sid-snapshot-20150201:1.4
	sid-snapshot-20150101:1.4
	sid-snapshot-20141201:1.4
	sid-snapshot-20141101:1.4
	sid-snapshot-20141001:1.4
	sid-snapshot-20140901:1.4
	sid-snapshot-20140801:1.4
	sid-snapshot-20140701:1.4
	sid-snapshot-20140601:1.4
	sid-snapshot-20140501:1.3
	sid-snapshot-20140401:1.3
	sid-snapshot-20140301:1.3
	sid-snapshot-20140201:1.3
	sid-snapshot-20140101:1.3
	sid-snapshot-20131201:1.3
	sid-snapshot-20131101:1.3
	sid-snapshot-20131001:1.3
	binutils-2_24-branch:1.3.0.4
	binutils-2_24-branchpoint:1.3
	binutils-2_21_1:1.1
	sid-snapshot-20130901:1.3
	gdb_7_6_1-2013-08-30-release:1.3
	sid-snapshot-20130801:1.3
	sid-snapshot-20130701:1.3
	sid-snapshot-20130601:1.3
	sid-snapshot-20130501:1.3
	gdb_7_6-2013-04-26-release:1.3
	sid-snapshot-20130401:1.3
	binutils-2_23_2:1.2
	gdb_7_6-branch:1.3.0.2
	gdb_7_6-2013-03-12-branchpoint:1.3
	sid-snapshot-20130301:1.3
	sid-snapshot-20130201:1.3
	sid-snapshot-20130101:1.2
	sid-snapshot-20121201:1.2
	gdb_7_5_1-2012-11-29-release:1.2
	binutils-2_23_1:1.2
	sid-snapshot-20121101:1.2
	binutils-2_23:1.2
	sid-snapshot-20121001:1.2
	sid-snapshot-20120901:1.2
	gdb_7_5-2012-08-17-release:1.2
	sid-snapshot-20120801:1.2
	binutils-2_23-branch:1.2.0.12
	binutils-2_23-branchpoint:1.2
	gdb_7_5-branch:1.2.0.10
	gdb_7_5-2012-07-18-branchpoint:1.2
	sid-snapshot-20120701:1.2
	sid-snapshot-20120601:1.2
	sid-snapshot-20120501:1.2
	binutils-2_22_branch:1.2.0.8
	gdb_7_4_1-2012-04-26-release:1.2
	sid-snapshot-20120401:1.2
	sid-snapshot-20120301:1.2
	sid-snapshot-20120201:1.2
	gdb_7_4-2012-01-24-release:1.2
	sid-snapshot-20120101:1.2
	gdb_7_4-branch:1.2.0.6
	gdb_7_4-2011-12-13-branchpoint:1.2
	sid-snapshot-20111201:1.2
	binutils-2_22:1.2
	sid-snapshot-20111101:1.2
	sid-snapshot-20111001:1.2
	binutils-2_22-branch:1.2.0.4
	binutils-2_22-branchpoint:1.2
	gdb_7_3_1-2011-09-04-release:1.2
	sid-snapshot-20110901:1.2
	sid-snapshot-20110801:1.2
	gdb_7_3-2011-07-26-release:1.2
	sid-snapshot-20110701:1.2
	sid-snapshot-20110601:1.2
	sid-snapshot-20110501:1.2
	gdb_7_3-branch:1.2.0.2
	gdb_7_3-2011-04-01-branchpoint:1.2
	sid-snapshot-20110401:1.2
	sid-snapshot-20110301:1.2
	cygwin-1_7_8-release:1.2
	sid-snapshot-20110201:1.2
	sid-snapshot-20110101:1.2
	binutils-2_21:1.1
	sid-snapshot-20101201:1.2
	binutils-2_21-branch:1.1.0.2
	binutils-2_21-branchpoint:1.1
	binutils_latest_snapshot:1.4;
locks; strict;
comment	@ * @;


1.4
date	2014.05.14.17.23.26;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2013.01.07.20.28.44;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.17.02.03.43;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2010.11.02.15.20.47;	author dj;	state Exp;
branches;
next	;


desc
@@


1.4
log
@merge from gcc
@
text
@/* simple-object.c -- simple routines to read and write object files.
   Copyright 2010 Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Google.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */

#include "config.h"
#include "libiberty.h"
#include "simple-object.h"

#include <errno.h>

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef HAVE_STDINT_H
#include <stdint.h>
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#endif

#ifdef HAVE_INTTYPES_H
#include <inttypes.h>
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#endif

#include "simple-object-common.h"

/* The known object file formats.  */

static const struct simple_object_functions * const format_functions[] =
{
  &simple_object_elf_functions,
  &simple_object_mach_o_functions,
  &simple_object_coff_functions,
  &simple_object_xcoff_functions
};

/* Read data from a file using the simple_object error reporting
   conventions.  */

int
simple_object_internal_read (int descriptor, off_t offset,
			     unsigned char *buffer, size_t size,
			     const char **errmsg, int *err)
{
  if (lseek (descriptor, offset, SEEK_SET) < 0)
    {
      *errmsg = "lseek";
      *err = errno;
      return 0;
    }

  do
    {
      ssize_t got = read (descriptor, buffer, size);
      if (got == 0)
	break;
      else if (got > 0)
	{
	  buffer += got;
	  size -= got;
	}
      else if (errno != EINTR)
	{
	  *errmsg = "read";
	  *err = errno;
	  return 0;
	}
    }
  while (size > 0);

  if (size > 0)
    {
      *errmsg = "file too short";
      *err = 0;
      return 0;
    }

  return 1;
}

/* Write data to a file using the simple_object error reporting
   conventions.  */

int
simple_object_internal_write (int descriptor, off_t offset,
			      const unsigned char *buffer, size_t size,
			      const char **errmsg, int *err)
{
  if (lseek (descriptor, offset, SEEK_SET) < 0)
    {
      *errmsg = "lseek";
      *err = errno;
      return 0;
    }

  do
    {
      ssize_t wrote = write (descriptor, buffer, size);
      if (wrote == 0)
	break;
      else if (wrote > 0)
	{
	  buffer += wrote;
	  size -= wrote;
	}
      else if (errno != EINTR)
	{
	  *errmsg = "write";
	  *err = errno;
	  return 0;
	}
    }
  while (size > 0);

  if (size > 0)
    {
      *errmsg = "short write";
      *err = 0;
      return 0;
    }

  return 1;
}

/* Open for read.  */

simple_object_read *
simple_object_start_read (int descriptor, off_t offset,
			  const char *segment_name, const char **errmsg,
			  int *err)
{
  unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN];
  size_t len, i;

  if (!simple_object_internal_read (descriptor, offset, header,
				    SIMPLE_OBJECT_MATCH_HEADER_LEN,
				    errmsg, err))
    return NULL;

  len = sizeof (format_functions) / sizeof (format_functions[0]);
  for (i = 0; i < len; ++i)
    {
      void *data;

      data = format_functions[i]->match (header, descriptor, offset,
					 segment_name, errmsg, err);
      if (data != NULL)
	{
	  simple_object_read *ret;

	  ret = XNEW (simple_object_read);
	  ret->descriptor = descriptor;
	  ret->offset = offset;
	  ret->functions = format_functions[i];
	  ret->data = data;
	  return ret;
	}
    }

  *errmsg = "file not recognized";
  *err = 0;
  return NULL;
}

/* Find all sections.  */

const char *
simple_object_find_sections (simple_object_read *sobj,
			     int (*pfn) (void *, const char *, off_t, off_t),
			     void *data,
			     int *err)
{
  return sobj->functions->find_sections (sobj, pfn, data, err);
}

/* Internal data passed to find_one_section.  */

struct find_one_section_data
{
  /* The section we are looking for.  */
  const char *name;
  /* Where to store the section offset.  */
  off_t *offset;
  /* Where to store the section length.  */
  off_t *length;
  /* Set if the name is found.  */
  int found;
};

/* Internal function passed to find_sections.  */

static int
find_one_section (void *data, const char *name, off_t offset, off_t length)
{
  struct find_one_section_data *fosd = (struct find_one_section_data *) data;

  if (strcmp (name, fosd->name) != 0)
    return 1;

  *fosd->offset = offset;
  *fosd->length = length;
  fosd->found = 1;

  /* Stop iteration.  */
  return 0;
}

/* Find a section.  */

int
simple_object_find_section (simple_object_read *sobj, const char *name,
			    off_t *offset, off_t *length,
			    const char **errmsg, int *err)
{
  struct find_one_section_data fosd;

  fosd.name = name;
  fosd.offset = offset;
  fosd.length = length;
  fosd.found = 0;

  *errmsg = simple_object_find_sections (sobj, find_one_section,
					 (void *) &fosd, err);
  if (*errmsg != NULL)
    return 0;
  if (!fosd.found)
    return 0;
  return 1;
}

/* Fetch attributes.  */

simple_object_attributes *
simple_object_fetch_attributes (simple_object_read *sobj, const char **errmsg,
				int *err)
{
  void *data;
  simple_object_attributes *ret;

  data = sobj->functions->fetch_attributes (sobj, errmsg, err);
  if (data == NULL)
    return NULL;
  ret = XNEW (simple_object_attributes);
  ret->functions = sobj->functions;
  ret->data = data;
  return ret;
}

/* Release an simple_object_read.  */

void
simple_object_release_read (simple_object_read *sobj)
{
  sobj->functions->release_read (sobj->data);
  XDELETE (sobj);
}

/* Merge attributes.  */

const char *
simple_object_attributes_merge (simple_object_attributes *to,
				simple_object_attributes *from,
				int *err)
{
  if (to->functions != from->functions)
    {
      *err = 0;
      return "different object file format";
    }
  return to->functions->attributes_merge (to->data, from->data, err);
}

/* Release an attributes structure.  */

void
simple_object_release_attributes (simple_object_attributes *attrs)
{
  attrs->functions->release_attributes (attrs->data);
  XDELETE (attrs);
}

/* Start creating an object file.  */

simple_object_write *
simple_object_start_write (simple_object_attributes *attrs,
			   const char *segment_name, const char **errmsg,
			   int *err)
{
  void *data;
  simple_object_write *ret;

  data = attrs->functions->start_write (attrs->data, errmsg, err);
  if (data == NULL)
    return NULL;
  ret = XNEW (simple_object_write);
  ret->functions = attrs->functions;
  ret->segment_name = xstrdup (segment_name);
  ret->sections = NULL;
  ret->last_section = NULL;
  ret->data = data;
  return ret;
}

/* Start creating a section.  */

simple_object_write_section *
simple_object_write_create_section (simple_object_write *sobj, const char *name,
				    unsigned int align,
				    const char **errmsg ATTRIBUTE_UNUSED,
				    int *err ATTRIBUTE_UNUSED)
{
  simple_object_write_section *ret;

  ret = XNEW (simple_object_write_section);
  ret->next = NULL;
  ret->name = xstrdup (name);
  ret->align = align;
  ret->buffers = NULL;
  ret->last_buffer = NULL;

  if (sobj->last_section == NULL)
    {
      sobj->sections = ret;
      sobj->last_section = ret;
    }
  else
    {
      sobj->last_section->next = ret;
      sobj->last_section = ret;
    }

  return ret;
}

/* Add data to a section.  */

const char *
simple_object_write_add_data (simple_object_write *sobj ATTRIBUTE_UNUSED,
			      simple_object_write_section *section,
			      const void *buffer,
			      size_t size, int copy,
			      int *err ATTRIBUTE_UNUSED)
{
  struct simple_object_write_section_buffer *wsb;

  wsb = XNEW (struct simple_object_write_section_buffer);
  wsb->next = NULL;
  wsb->size = size;

  if (!copy)
    {
      wsb->buffer = buffer;
      wsb->free_buffer = NULL;
    }
  else
    {
      wsb->free_buffer = (void *) XNEWVEC (char, size);
      memcpy (wsb->free_buffer, buffer, size);
      wsb->buffer = wsb->free_buffer;
    }

  if (section->last_buffer == NULL)
    {
      section->buffers = wsb;
      section->last_buffer = wsb;
    }
  else
    {
      section->last_buffer->next = wsb;
      section->last_buffer = wsb;
    }

  return NULL;
}

/* Write the complete object file.  */

const char *
simple_object_write_to_file (simple_object_write *sobj, int descriptor,
			     int *err)
{
  return sobj->functions->write_to_file (sobj, descriptor, err);
}

/* Release an simple_object_write.  */

void
simple_object_release_write (simple_object_write *sobj)
{
  simple_object_write_section *section;

  free (sobj->segment_name);

  section = sobj->sections;
  while (section != NULL)
    {
      struct simple_object_write_section_buffer *buffer;
      simple_object_write_section *next_section;

      buffer = section->buffers;
      while (buffer != NULL)
	{
	  struct simple_object_write_section_buffer *next_buffer;

	  if (buffer->free_buffer != NULL)
	    XDELETEVEC (buffer->free_buffer);
	  next_buffer = buffer->next;
	  XDELETE (buffer);
	  buffer = next_buffer;
	}

      next_section = section->next;
      free (section->name);
      XDELETE (section);
      section = next_section;
    }

  sobj->functions->release_write (sobj->data);
  XDELETE (sobj);
}
@


1.3
log
@merge from gcc
@
text
@a65 2
  ssize_t got;

d73 1
a73 2
  got = read (descriptor, buffer, size);
  if (got < 0)
d75 14
a88 3
      *errmsg = "read";
      *err = errno;
      return 0;
d90 1
d92 1
a92 1
  if ((size_t) got < size)
a109 2
  ssize_t wrote;

d117 1
a117 2
  wrote = write (descriptor, buffer, size);
  if (wrote < 0)
d119 14
a132 3
      *errmsg = "write";
      *err = errno;
      return 0;
d134 1
d136 1
a136 1
  if ((size_t) wrote < size)
@


1.2
log
@merge from gcc
@
text
@d54 2
a55 1
  &simple_object_coff_functions
@


1.1
log
@merge from gcc
@
text
@d260 1
a260 1
/* Compare attributes.  */
d263 3
a265 3
simple_object_attributes_compare (simple_object_attributes *attrs1,
				  simple_object_attributes *attrs2,
				  int *err)
d267 1
a267 1
  if (attrs1->functions != attrs2->functions)
d272 1
a272 2
  return attrs1->functions->attributes_compare (attrs1->data, attrs2->data,
						err);
@

