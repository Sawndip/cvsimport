head	1.125;
access;
symbols
	sid-snapshot-20180601:1.125
	sid-snapshot-20180501:1.125
	sid-snapshot-20180401:1.125
	sid-snapshot-20180301:1.125
	sid-snapshot-20180201:1.125
	sid-snapshot-20180101:1.125
	sid-snapshot-20171201:1.125
	sid-snapshot-20171101:1.125
	sid-snapshot-20171001:1.125
	sid-snapshot-20170901:1.125
	sid-snapshot-20170801:1.125
	sid-snapshot-20170701:1.125
	sid-snapshot-20170601:1.125
	sid-snapshot-20170501:1.125
	sid-snapshot-20170401:1.125
	sid-snapshot-20170301:1.125
	sid-snapshot-20170201:1.125
	sid-snapshot-20170101:1.125
	sid-snapshot-20161201:1.125
	sid-snapshot-20161101:1.125
	sid-snapshot-20160901:1.125
	sid-snapshot-20160801:1.125
	sid-snapshot-20160701:1.125
	sid-snapshot-20160601:1.125
	sid-snapshot-20160501:1.125
	sid-snapshot-20160401:1.125
	sid-snapshot-20160301:1.125
	sid-snapshot-20160201:1.125
	sid-snapshot-20160101:1.125
	sid-snapshot-20151201:1.125
	sid-snapshot-20151101:1.125
	sid-snapshot-20151001:1.125
	sid-snapshot-20150901:1.125
	sid-snapshot-20150801:1.125
	sid-snapshot-20150701:1.125
	sid-snapshot-20150601:1.124
	sid-snapshot-20150501:1.124
	sid-snapshot-20150401:1.124
	sid-snapshot-20150301:1.124
	sid-snapshot-20150201:1.124
	sid-snapshot-20150101:1.124
	sid-snapshot-20141201:1.124
	sid-snapshot-20141101:1.124
	sid-snapshot-20141001:1.124
	sid-snapshot-20140901:1.123
	sid-snapshot-20140801:1.122
	sid-snapshot-20140701:1.122
	sid-snapshot-20140601:1.121
	sid-snapshot-20140501:1.120
	sid-snapshot-20140401:1.120
	sid-snapshot-20140301:1.120
	sid-snapshot-20140201:1.120
	sid-snapshot-20140101:1.118
	sid-snapshot-20131201:1.117
	sid-snapshot-20131101:1.115
	sid-snapshot-20131001:1.113
	binutils-2_24-branch:1.113.0.2
	binutils-2_24-branchpoint:1.113
	binutils-2_21_1:1.88.2.1
	sid-snapshot-20130901:1.111
	gdb_7_6_1-2013-08-30-release:1.109
	sid-snapshot-20130801:1.111
	sid-snapshot-20130701:1.111
	sid-snapshot-20130601:1.111
	sid-snapshot-20130501:1.111
	gdb_7_6-2013-04-26-release:1.109
	sid-snapshot-20130401:1.109
	binutils-2_23_2:1.106
	gdb_7_6-branch:1.109.0.2
	gdb_7_6-2013-03-12-branchpoint:1.109
	sid-snapshot-20130301:1.109
	sid-snapshot-20130201:1.108
	sid-snapshot-20130101:1.108
	sid-snapshot-20121201:1.108
	gdb_7_5_1-2012-11-29-release:1.105
	binutils-2_23_1:1.106
	sid-snapshot-20121101:1.107
	binutils-2_23:1.106
	sid-snapshot-20121001:1.106
	sid-snapshot-20120901:1.106
	gdb_7_5-2012-08-17-release:1.105
	sid-snapshot-20120801:1.106
	binutils-2_23-branch:1.106.0.2
	binutils-2_23-branchpoint:1.106
	gdb_7_5-branch:1.105.0.2
	gdb_7_5-2012-07-18-branchpoint:1.105
	sid-snapshot-20120701:1.105
	sid-snapshot-20120601:1.105
	sid-snapshot-20120501:1.104
	binutils-2_22_branch:1.96.0.4
	gdb_7_4_1-2012-04-26-release:1.100
	sid-snapshot-20120401:1.103
	sid-snapshot-20120301:1.102
	sid-snapshot-20120201:1.102
	gdb_7_4-2012-01-24-release:1.100
	sid-snapshot-20120101:1.100
	gdb_7_4-branch:1.100.0.2
	gdb_7_4-2011-12-13-branchpoint:1.100
	sid-snapshot-20111201:1.100
	binutils-2_22:1.96
	sid-snapshot-20111101:1.98
	sid-snapshot-20111001:1.97
	binutils-2_22-branch:1.96.0.2
	binutils-2_22-branchpoint:1.96
	gdb_7_3_1-2011-09-04-release:1.90.2.2
	sid-snapshot-20110901:1.96
	sid-snapshot-20110801:1.95
	gdb_7_3-2011-07-26-release:1.90.2.2
	sid-snapshot-20110701:1.92
	sid-snapshot-20110601:1.90
	sid-snapshot-20110501:1.90
	gdb_7_3-branch:1.90.0.2
	gdb_7_3-2011-04-01-branchpoint:1.90
	sid-snapshot-20110401:1.90
	sid-snapshot-20110301:1.90
	cygwin-1_7_8-release:1.90
	sid-snapshot-20110201:1.90
	sid-snapshot-20110101:1.90
	binutils-2_21:1.88.2.1
	sid-snapshot-20101201:1.90
	binutils-2_21-branch:1.88.0.2
	binutils-2_21-branchpoint:1.88
	sid-snapshot-20101101:1.88
	sid-snapshot-20101001:1.88
	binutils-2_20_1:1.80
	gdb_7_2-2010-09-02-release:1.87
	sid-snapshot-20100901:1.87
	cygwin-1_7_7-release:1.87
	sid-snapshot-20100801:1.87
	gdb_7_2-branch:1.87.0.2
	gdb_7_2-2010-07-07-branchpoint:1.87
	sid-snapshot-20100701:1.87
	sid-snapshot-20100601:1.86
	sid-snapshot-20100501:1.85
	sid-snapshot-20100401:1.85
	gdb_7_1-2010-03-18-release:1.84
	sid-snapshot-20100301:1.84
	gdb_7_1-branch:1.84.0.2
	gdb_7_1-2010-02-18-branchpoint:1.84
	sid-snapshot-20100201:1.83
	sid-snapshot-20100101:1.81
	gdb_7_0_1-2009-12-22-release:1.80
	sid-snapshot-20091201:1.81
	sid-snapshot-20091101:1.81
	binutils-2_20:1.80
	gdb_7_0-2009-10-06-release:1.80
	sid-snapshot-20091001:1.80
	gdb_7_0-branch:1.80.0.6
	gdb_7_0-2009-09-16-branchpoint:1.80
	arc-sim-20090309:1.70
	binutils-arc-20081103-branch:1.73.0.6
	binutils-arc-20081103-branchpoint:1.73
	binutils-2_20-branch:1.80.0.4
	binutils-2_20-branchpoint:1.80
	sid-snapshot-20090901:1.80
	sid-snapshot-20090801:1.80
	msnyder-checkpoint-072509-branch:1.80.0.2
	msnyder-checkpoint-072509-branchpoint:1.80
	sid-snapshot-20090701:1.79
	dje-cgen-play1-branch:1.79.0.2
	dje-cgen-play1-branchpoint:1.79
	sid-snapshot-20090601:1.79
	sid-snapshot-20090501:1.78
	sid-snapshot-20090401:1.78
	arc-20081103-branch:1.73.0.4
	arc-20081103-branchpoint:1.73
	arc-insight_6_8-branch:1.70.0.6
	arc-insight_6_8-branchpoint:1.70
	insight_6_8-branch:1.70.0.4
	insight_6_8-branchpoint:1.70
	sid-snapshot-20090301:1.76
	binutils-2_19_1:1.71
	sid-snapshot-20090201:1.76
	sid-snapshot-20090101:1.75
	reverse-20081226-branch:1.75.0.2
	reverse-20081226-branchpoint:1.75
	sid-snapshot-20081201:1.73
	multiprocess-20081120-branch:1.73.0.2
	multiprocess-20081120-branchpoint:1.73
	sid-snapshot-20081101:1.73
	binutils-2_19:1.71
	sid-snapshot-20081001:1.72
	reverse-20080930-branch:1.72.0.2
	reverse-20080930-branchpoint:1.72
	binutils-2_19-branch:1.71.0.6
	binutils-2_19-branchpoint:1.71
	sid-snapshot-20080901:1.71
	sid-snapshot-20080801:1.71
	reverse-20080717-branch:1.71.0.4
	reverse-20080717-branchpoint:1.71
	sid-snapshot-20080701:1.71
	msnyder-reverse-20080609-branch:1.71.0.2
	msnyder-reverse-20080609-branchpoint:1.71
	drow-reverse-20070409-branch:1.66.0.2
	drow-reverse-20070409-branchpoint:1.66
	sid-snapshot-20080601:1.71
	sid-snapshot-20080501:1.71
	sid-snapshot-20080403:1.71
	sid-snapshot-20080401:1.71
	gdb_6_8-2008-03-27-release:1.70
	sid-snapshot-20080301:1.70
	gdb_6_8-branch:1.70.0.2
	gdb_6_8-2008-02-26-branchpoint:1.70
	sid-snapshot-20080201:1.70
	sid-snapshot-20080101:1.69
	sid-snapshot-20071201:1.69
	sid-snapshot-20071101:1.69
	gdb_6_7_1-2007-10-29-release:1.69
	gdb_6_7-2007-10-10-release:1.69
	sid-snapshot-20071001:1.69
	gdb_6_7-branch:1.69.0.2
	gdb_6_7-2007-09-07-branchpoint:1.69
	binutils-2_18:1.68
	binutils-2_18-branch:1.68.0.2
	binutils-2_18-branchpoint:1.68
	insight_6_6-20070208-release:1.63
	binutils-csl-coldfire-4_1-32:1.61
	binutils-csl-sourcerygxx-4_1-32:1.61
	gdb_6_6-2006-12-18-release:1.63
	binutils-csl-innovasic-fido-3_4_4-33:1.61
	binutils-csl-sourcerygxx-3_4_4-32:1.53
	binutils-csl-coldfire-4_1-30:1.61
	binutils-csl-sourcerygxx-4_1-30:1.61
	binutils-csl-coldfire-4_1-28:1.61
	binutils-csl-sourcerygxx-4_1-29:1.61
	binutils-csl-sourcerygxx-4_1-28:1.61
	gdb_6_6-branch:1.63.0.2
	gdb_6_6-2006-11-15-branchpoint:1.63
	binutils-csl-arm-2006q3-27:1.61
	binutils-csl-sourcerygxx-4_1-27:1.61
	binutils-csl-arm-2006q3-26:1.61
	binutils-csl-sourcerygxx-4_1-26:1.61
	binutils-csl-sourcerygxx-4_1-25:1.61
	binutils-csl-sourcerygxx-4_1-24:1.61
	binutils-csl-sourcerygxx-4_1-23:1.61
	insight_6_5-20061003-release:1.61
	gdb-csl-symbian-6_4_50_20060226-12:1.61
	binutils-csl-sourcerygxx-4_1-21:1.61
	binutils-csl-arm-2006q3-21:1.61
	binutils-csl-sourcerygxx-4_1-22:1.61
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.61
	binutils-csl-sourcerygxx-4_1-20:1.61
	binutils-csl-arm-2006q3-19:1.61
	binutils-csl-sourcerygxx-4_1-19:1.61
	binutils-csl-sourcerygxx-4_1-18:1.61
	binutils-csl-renesas-4_1-9:1.61
	gdb-csl-sourcerygxx-3_4_4-25:1.60
	binutils-csl-sourcerygxx-3_4_4-25:1.53
	nickrob-async-20060828-mergepoint:1.62
	gdb-csl-symbian-6_4_50_20060226-11:1.61
	binutils-csl-renesas-4_1-8:1.61
	binutils-csl-renesas-4_1-7:1.61
	binutils-csl-renesas-4_1-6:1.61
	gdb-csl-sourcerygxx-4_1-17:1.61
	binutils-csl-sourcerygxx-4_1-17:1.61
	gdb-csl-20060226-branch-local-2:1.61
	cr-0x5f1:1.61.0.22
	gdb-csl-sourcerygxx-4_1-14:1.61
	binutils-csl-sourcerygxx-4_1-14:1.61
	binutils-csl-sourcerygxx-4_1-15:1.61
	gdb-csl-sourcerygxx-4_1-13:1.61
	binutils-csl-sourcerygxx-4_1-13:1.61
	binutils-2_17:1.61
	gdb-csl-sourcerygxx-4_1-12:1.61
	binutils-csl-sourcerygxx-4_1-12:1.61
	gdb-csl-sourcerygxx-3_4_4-21:1.61
	binutils-csl-sourcerygxx-3_4_4-21:1.61
	gdb_6_5-20060621-release:1.61
	binutils-csl-wrs-linux-3_4_4-24:1.53
	binutils-csl-wrs-linux-3_4_4-23:1.53
	gdb-csl-sourcerygxx-4_1-9:1.61
	binutils-csl-sourcerygxx-4_1-9:1.61
	gdb-csl-sourcerygxx-4_1-8:1.61
	binutils-csl-sourcerygxx-4_1-8:1.61
	gdb-csl-sourcerygxx-4_1-7:1.61
	binutils-csl-sourcerygxx-4_1-7:1.61
	gdb-csl-arm-2006q1-6:1.61
	binutils-csl-arm-2006q1-6:1.61
	gdb-csl-sourcerygxx-4_1-6:1.61
	binutils-csl-sourcerygxx-4_1-6:1.61
	binutils-csl-wrs-linux-3_4_4-22:1.53
	gdb-csl-symbian-6_4_50_20060226-10:1.61
	gdb-csl-symbian-6_4_50_20060226-9:1.61
	gdb-csl-symbian-6_4_50_20060226-8:1.61
	gdb-csl-coldfire-4_1-11:1.61
	binutils-csl-coldfire-4_1-11:1.61
	gdb-csl-sourcerygxx-3_4_4-19:1.61
	binutils-csl-sourcerygxx-3_4_4-19:1.61
	gdb-csl-coldfire-4_1-10:1.61
	gdb_6_5-branch:1.61.0.20
	gdb_6_5-2006-05-14-branchpoint:1.61
	binutils-csl-coldfire-4_1-10:1.61
	gdb-csl-sourcerygxx-4_1-5:1.61
	binutils-csl-sourcerygxx-4_1-5:1.61
	nickrob-async-20060513-branch:1.61.0.18
	nickrob-async-20060513-branchpoint:1.61
	gdb-csl-sourcerygxx-4_1-4:1.61
	binutils-csl-sourcerygxx-4_1-4:1.61
	msnyder-reverse-20060502-branch:1.61.0.16
	msnyder-reverse-20060502-branchpoint:1.61
	binutils-csl-wrs-linux-3_4_4-21:1.53
	gdb-csl-morpho-4_1-4:1.61
	binutils-csl-morpho-4_1-4:1.61
	gdb-csl-sourcerygxx-3_4_4-17:1.61
	binutils-csl-sourcerygxx-3_4_4-17:1.61
	binutils-csl-wrs-linux-3_4_4-20:1.53
	readline_5_1-import-branch:1.61.0.14
	readline_5_1-import-branchpoint:1.61
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.61
	binutils-2_17-branch:1.61.0.12
	binutils-2_17-branchpoint:1.61
	gdb-csl-symbian-20060226-branch:1.61.0.10
	gdb-csl-symbian-20060226-branchpoint:1.61
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.61
	msnyder-reverse-20060331-branch:1.61.0.8
	msnyder-reverse-20060331-branchpoint:1.61
	binutils-csl-2_17-branch:1.61.0.6
	binutils-csl-2_17-branchpoint:1.61
	gdb-csl-available-20060303-branch:1.61.0.4
	gdb-csl-available-20060303-branchpoint:1.61
	gdb-csl-20060226-branch:1.61.0.2
	gdb-csl-20060226-branchpoint:1.61
	gdb_6_4-20051202-release:1.60
	msnyder-fork-checkpoint-branch:1.60.0.8
	msnyder-fork-checkpoint-branchpoint:1.60
	gdb-csl-gxxpro-6_3-branch:1.60.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.60
	gdb_6_4-branch:1.60.0.4
	gdb_6_4-2005-11-01-branchpoint:1.60
	gdb-csl-arm-20051020-branch:1.60.0.2
	gdb-csl-arm-20051020-branchpoint:1.60
	binutils-csl-gxxpro-3_4-branch:1.53.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.53
	binutils-2_16_1:1.53
	msnyder-tracepoint-checkpoint-branch:1.59.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.59
	gdb-csl-arm-20050325-2005-q1b:1.53
	binutils-csl-arm-2005q1b:1.53
	binutils-2_16:1.53
	gdb-csl-arm-20050325-2005-q1a:1.53
	binutils-csl-arm-2005q1a:1.53
	csl-arm-20050325-branch:1.53.0.6
	csl-arm-20050325-branchpoint:1.53
	binutils-csl-arm-2005q1-branch:1.53.0.4
	binutils-csl-arm-2005q1-branchpoint:1.53
	binutils-2_16-branch:1.53.0.2
	binutils-2_16-branchpoint:1.53
	csl-arm-2004-q3d:1.51
	gdb_6_3-20041109-release:1.51
	gdb_6_3-branch:1.51.0.4
	gdb_6_3-20041019-branchpoint:1.51
	csl-arm-2004-q3:1.51
	drow_intercu-merge-20040921:1.51
	drow_intercu-merge-20040915:1.51
	jimb-gdb_6_2-e500-branch:1.51.0.6
	jimb-gdb_6_2-e500-branchpoint:1.51
	gdb_6_2-20040730-release:1.51
	gdb_6_2-branch:1.51.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.51
	gdb_6_1_1-20040616-release:1.50
	binutils-2_15:1.47
	binutils-2_15-branchpoint:1.47
	csl-arm-2004-q1a:1.50
	csl-arm-2004-q1:1.50
	gdb_6_1-2004-04-05-release:1.50
	drow_intercu-merge-20040402:1.50
	drow_intercu-merge-20040327:1.50
	ezannoni_pie-20040323-branch:1.50.0.6
	ezannoni_pie-20040323-branchpoint:1.50
	cagney_tramp-20040321-mergepoint:1.50
	cagney_tramp-20040309-branch:1.50.0.4
	cagney_tramp-20040309-branchpoint:1.50
	gdb_6_1-branch:1.50.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.50
	drow_intercu-20040221-branch:1.47.0.8
	drow_intercu-20040221-branchpoint:1.47
	binutils-2_15-branch:1.47.0.6
	cagney_bfdfile-20040213-branch:1.47.0.4
	cagney_bfdfile-20040213-branchpoint:1.47
	drow-cplus-merge-20040208:1.47
	carlton_dictionary-20040126-merge:1.47
	cagney_bigcore-20040122-branch:1.47.0.2
	cagney_bigcore-20040122-branchpoint:1.47
	drow-cplus-merge-20040113:1.46
	csl-arm-2003-q4:1.44
	drow-cplus-merge-20031224:1.43
	drow-cplus-merge-20031220:1.41
	carlton_dictionary-20031215-merge:1.39
	drow-cplus-merge-20031214:1.38
	carlton-dictionary-20031111-merge:1.29
	gdb_6_0-2003-10-04-release:1.28
	kettenis_sparc-20030918-branch:1.29.0.6
	kettenis_sparc-20030918-branchpoint:1.29
	carlton_dictionary-20030917-merge:1.29
	ezannoni_pie-20030916-branchpoint:1.29
	ezannoni_pie-20030916-branch:1.29.0.4
	cagney_x86i386-20030821-branch:1.29.0.2
	cagney_x86i386-20030821-branchpoint:1.29
	carlton_dictionary-20030805-merge:1.28
	carlton_dictionary-20030627-merge:1.28
	gdb_6_0-branch:1.28.0.14
	gdb_6_0-2003-06-23-branchpoint:1.28
	jimb-ppc64-linux-20030613-branch:1.28.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.28
	binutils-2_14:1.27
	cagney_convert-20030606-branch:1.28.0.10
	cagney_convert-20030606-branchpoint:1.28
	cagney_writestrings-20030508-branch:1.28.0.8
	cagney_writestrings-20030508-branchpoint:1.28
	jimb-ppc64-linux-20030528-branch:1.28.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.28
	carlton_dictionary-20030523-merge:1.28
	cagney_fileio-20030521-branch:1.28.0.4
	cagney_fileio-20030521-branchpoint:1.28
	kettenis_i386newframe-20030517-mergepoint:1.28
	jimb-ppc64-linux-20030509-branch:1.28.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.28
	kettenis_i386newframe-20030504-mergepoint:1.28
	carlton_dictionary-20030430-merge:1.27
	binutils-2_14-branch:1.27.0.26
	binutils-2_14-branchpoint:1.27
	kettenis_i386newframe-20030419-branch:1.27.0.24
	kettenis_i386newframe-20030419-branchpoint:1.27
	carlton_dictionary-20030416-merge:1.27
	cagney_frameaddr-20030409-mergepoint:1.27
	kettenis_i386newframe-20030406-branch:1.27.0.22
	kettenis_i386newframe-20030406-branchpoint:1.27
	cagney_frameaddr-20030403-branchpoint:1.27
	cagney_frameaddr-20030403-branch:1.27.0.20
	cagney_framebase-20030330-mergepoint:1.27
	cagney_framebase-20030326-branch:1.27.0.18
	cagney_framebase-20030326-branchpoint:1.27
	cagney_lazyid-20030317-branch:1.27.0.16
	cagney_lazyid-20030317-branchpoint:1.27
	kettenis-i386newframe-20030316-mergepoint:1.27
	offbyone-20030313-branch:1.27.0.14
	offbyone-20030313-branchpoint:1.27
	kettenis-i386newframe-20030308-branch:1.27.0.12
	kettenis-i386newframe-20030308-branchpoint:1.27
	carlton_dictionary-20030305-merge:1.27
	cagney_offbyone-20030303-branch:1.27.0.10
	cagney_offbyone-20030303-branchpoint:1.27
	w32api-2_2:1.27
	mingw-runtime-2_4:1.27
	carlton_dictionary-20030207-merge:1.27
	interps-20030202-branch:1.27.0.8
	interps-20030202-branchpoint:1.27
	cagney-unwind-20030108-branch:1.27.0.6
	cagney-unwind-20030108-branchpoint:1.27
	binutils-2_13_2_1:1.26
	binutils-2_13_2:1.26
	carlton_dictionary-20021223-merge:1.27
	gdb_5_3-2002-12-12-release:1.26
	carlton_dictionary-20021115-merge:1.27
	binutils-2_13_1:1.26
	kseitz_interps-20021105-merge:1.27
	kseitz_interps-20021103-merge:1.27
	drow-cplus-merge-20021020:1.27
	drow-cplus-merge-20021025:1.27
	carlton_dictionary-20021025-merge:1.27
	carlton_dictionary-20021011-merge:1.27
	drow-cplus-branch:1.27.0.4
	drow-cplus-branchpoint:1.27
	kseitz_interps-20020930-merge:1.27
	carlton_dictionary-20020927-merge:1.27
	carlton_dictionary-branch:1.27.0.2
	carlton_dictionary-20020920-branchpoint:1.27
	sid-20020905-branchpoint:1.26
	sid-20020905-branch:1.26.0.10
	gdb_5_3-branch:1.26.0.8
	gdb_5_3-2002-09-04-branchpoint:1.26
	kseitz_interps-20020829-merge:1.26
	cagney_sysregs-20020825-branch:1.26.0.6
	cagney_sysregs-20020825-branchpoint:1.26
	readline_4_3-import-branch:1.26.0.4
	readline_4_3-import-branchpoint:1.26
	binutils-2_13:1.26
	gdb_5_2_1-2002-07-23-release:1.20
	binutils-2_13-branchpoint:1.26
	binutils-2_13-branch:1.26.0.2
	kseitz_interps-20020528-branch:1.23.0.6
	kseitz_interps-20020528-branchpoint:1.23
	cagney_regbuf-20020515-branch:1.23.0.4
	cagney_regbuf-20020515-branchpoint:1.23
	binutils-2_12_1:1.20
	jimb-macro-020506-branch:1.23.0.2
	jimb-macro-020506-branchpoint:1.23
	gdb_5_2-2002-04-29-release:1.20
	binutils-2_12:1.20
	gdb_5_2-branch:1.20.0.4
	gdb_5_2-2002-03-03-branchpoint:1.20
	binutils-2_12-branch:1.20.0.2
	binutils-2_12-branchpoint:1.20
	gdb_5_1_1-2002-01-24-release:1.12
	gdb_5_1_0_1-2002-01-03-release:1.12
	cygnus_cvs_20020108_pre:1.15
	gdb_5_1_0_1-2002-01-03-branch:1.12.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.12
	gdb_5_1-2001-11-21-release:1.12
	gdb_s390-2001-09-26-branch:1.12.0.4
	gdb_s390-2001-09-26-branchpoint:1.12
	gdb_5_1-2001-07-29-branch:1.12.0.2
	gdb_5_1-2001-07-29-branchpoint:1.12
	binutils-2_11_2:1.7
	binutils-2_11_1:1.7
	binutils-2_11:1.7
	x86_64versiong3:1.8
	binutils-2_11-branch:1.7.0.2
	insight-precleanup-2001-01-01:1.7
	binutils-2_10_1:1.4.2.1
	binutils-2_10-branch:1.4.0.2
	binutils_latest_snapshot:1.122;
locks; strict;
comment	@ * @;


1.125
date	2015.06.02.03.05.46;	author dj;	state Exp;
branches;
next	1.124;

1.124
date	2014.09.28.17.46.12;	author dj;	state Exp;
branches;
next	1.123;

1.123
date	2014.08.29.20.03.03;	author dj;	state Exp;
branches;
next	1.122;

1.122
date	2014.06.11.17.56.20;	author dj;	state Exp;
branches;
next	1.121;

1.121
date	2014.05.14.17.23.25;	author dj;	state Exp;
branches;
next	1.120;

1.120
date	2014.01.28.20.01.58;	author dj;	state Exp;
branches;
next	1.119;

1.119
date	2014.01.06.16.20.29;	author dj;	state Exp;
branches;
next	1.118;

1.118
date	2013.12.23.18.30.26;	author dj;	state Exp;
branches;
next	1.117;

1.117
date	2013.11.22.23.06.38;	author dj;	state Exp;
branches;
next	1.116;

1.116
date	2013.11.12.21.16.42;	author dj;	state Exp;
branches;
next	1.115;

1.115
date	2013.10.25.18.21.11;	author dj;	state Exp;
branches;
next	1.114;

1.114
date	2013.10.16.00.29.45;	author dj;	state Exp;
branches;
next	1.113;

1.113
date	2013.09.10.19.01.20;	author dj;	state Exp;
branches;
next	1.112;

1.112
date	2013.09.10.16.05.00;	author dj;	state Exp;
branches;
next	1.111;

1.111
date	2013.04.04.01.02.59;	author dj;	state Exp;
branches;
next	1.110;

1.110
date	2013.04.03.18.21.45;	author dj;	state Exp;
branches;
next	1.109;

1.109
date	2013.02.15.02.48.29;	author dj;	state Exp;
branches;
next	1.108;

1.108
date	2012.11.11.22.37.25;	author dj;	state Exp;
branches;
next	1.107;

1.107
date	2012.10.10.03.11.33;	author dj;	state Exp;
branches;
next	1.106;

1.106
date	2012.07.18.20.08.53;	author dj;	state Exp;
branches;
next	1.105;

1.105
date	2012.05.22.18.05.36;	author dj;	state Exp;
branches;
next	1.104;

1.104
date	2012.04.02.18.50.26;	author dj;	state Exp;
branches;
next	1.103;

1.103
date	2012.03.08.00.01.27;	author dj;	state Exp;
branches;
next	1.102;

1.102
date	2012.01.10.18.15.31;	author dj;	state Exp;
branches;
next	1.101;

1.101
date	2012.01.06.22.04.40;	author dj;	state Exp;
branches;
next	1.100;

1.100
date	2011.11.08.16.01.58;	author dj;	state Exp;
branches;
next	1.99;

1.99
date	2011.11.04.14.32.13;	author dj;	state Exp;
branches;
next	1.98;

1.98
date	2011.10.10.21.02.44;	author dj;	state Exp;
branches;
next	1.97;

1.97
date	2011.09.23.22.21.33;	author dj;	state Exp;
branches;
next	1.96;

1.96
date	2011.08.06.18.40.24;	author dj;	state Exp;
branches;
next	1.95;

1.95
date	2011.07.26.16.04.33;	author dj;	state Exp;
branches;
next	1.94;

1.94
date	2011.07.05.15.40.14;	author dj;	state Exp;
branches;
next	1.93;

1.93
date	2011.07.01.17.30.47;	author jkratoch;	state Exp;
branches;
next	1.92;

1.92
date	2011.06.22.19.13.38;	author dj;	state Exp;
branches;
next	1.91;

1.91
date	2011.06.13.23.01.45;	author dj;	state Exp;
branches;
next	1.90;

1.90
date	2010.11.16.17.58.26;	author hjl;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2010.11.13.02.20.29;	author dj;	state Exp;
branches;
next	1.88;

1.88
date	2010.09.10.22.42.04;	author tromey;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2010.06.10.15.42.01;	author jakub;	state Exp;
branches;
next	1.86;

1.86
date	2010.05.06.21.40.01;	author dj;	state Exp;
branches;
next	1.85;

1.85
date	2010.03.22.21.39.42;	author dj;	state Exp;
branches;
next	1.84;

1.84
date	2010.02.03.23.27.57;	author dj;	state Exp;
branches;
next	1.83;

1.83
date	2010.01.21.02.05.11;	author dj;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.10.01.19.02;	author hjl;	state Exp;
branches;
next	1.81;

1.81
date	2009.10.02.18.22.57;	author dj;	state Exp;
branches;
next	1.80;

1.80
date	2009.07.17.20.20.45;	author dj;	state Exp;
branches;
next	1.79;

1.79
date	2009.05.19.03.02.30;	author dj;	state Exp;
branches;
next	1.78;

1.78
date	2009.03.23.22.05.08;	author dj;	state Exp;
branches;
next	1.77;

1.77
date	2009.03.18.00.07.44;	author dj;	state Exp;
branches;
next	1.76;

1.76
date	2009.01.07.18.52.57;	author dj;	state Exp;
branches;
next	1.75;

1.75
date	2008.12.18.15.56.12;	author dj;	state Exp;
branches;
next	1.74;

1.74
date	2008.12.10.23.28.19;	author dj;	state Exp;
branches;
next	1.73;

1.73
date	2008.10.07.01.27.58;	author dj;	state Exp;
branches;
next	1.72;

1.72
date	2008.09.09.18.21.46;	author dj;	state Exp;
branches;
next	1.71;

1.71
date	2008.03.31.18.11.50;	author dj;	state Exp;
branches;
next	1.70;

1.70
date	2008.01.27.06.25.44;	author daney;	state Exp;
branches;
next	1.69;

1.69
date	2007.08.31.20.20.49;	author dj;	state Exp;
branches;
next	1.68;

1.68
date	2007.08.01.19.43.08;	author msnyder;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.06.00.25.11;	author geoffk;	state Exp;
branches;
next	1.66;

1.66
date	2007.03.16.01.09.26;	author geoffk;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.30.23.16.58;	author dj;	state Exp;
branches;
next	1.64;

1.64
date	2006.12.21.01.32.48;	author geoffk;	state Exp;
branches;
next	1.63;

1.63
date	2006.09.22.19.19.26;	author dj;	state Exp;
branches;
next	1.62;

1.62
date	2006.08.28.00.56.12;	author dj;	state Exp;
branches;
next	1.61;

1.61
date	2005.12.11.02.16.07;	author dj;	state Exp;
branches;
next	1.60;

1.60
date	2005.07.03.19.16.18;	author dj;	state Exp;
branches;
next	1.59;

1.59
date	2005.05.25.23.32.35;	author rth;	state Exp;
branches;
next	1.58;

1.58
date	2005.05.24.21.01.30;	author dj;	state Exp;
branches;
next	1.57;

1.57
date	2005.05.10.15.33.31;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2005.04.02.17.18.43;	author ian;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.28.17.14.33;	author dj;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.27.05.28.42;	author dj;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.13.06.58.28;	author jason;	state Exp;
branches;
next	1.52;

1.52
date	2004.11.24.03.00.34;	author dj;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.28.18.01.41;	author dj;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.25.05.40.01;	author dj;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.25.02.04.35;	author dj;	state Exp;
branches;
next	1.48;

1.48
date	2004.02.24.16.30.39;	author dj;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.13.21.34.31;	author drow;	state Exp;
branches
	1.47.8.1;
next	1.46;

1.46
date	2004.01.12.21.24.38;	author dj;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.02.21.11.32;	author dj;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.26.16.27.37;	author dj;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.22.16.03.32;	author dj;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.20.16.06.09;	author dj;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.19.22.03.37;	author dj;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.16.00.58.42;	author dj;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.15.17.45.34;	author dj;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.04.20.03.27;	author dj;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.01.23.54.35;	author dj;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.27.01.17.22;	author dj;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.25.22.35.33;	author dj;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.24.19.33.33;	author dj;	state Exp;
branches;
next	1.33;

1.33
date	2003.11.21.22.01.25;	author dj;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.21.17.42.45;	author dj;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.20.02.01.32;	author dj;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.19.16.19.14;	author dj;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.12.12.23.42;	author dj;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.03.17.14.52;	author dj;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.20.13.45.20;	author dj;	state Exp;
branches
	1.27.2.1
	1.27.4.1
	1.27.24.1;
next	1.26;

1.26
date	2002.07.10.00.01.54;	author dj;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.09.01.01.18;	author dj;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.02.04.09.35;	author dj;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.01.22.01.20;	author dj;	state Exp;
branches
	1.23.6.1;
next	1.22;

1.22
date	2002.03.30.06.17.57;	author dj;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.12.21.11.11;	author dj;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.05.17.53.16;	author dj;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.03.13.12.40;	author dj;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.01.21.20.30;	author dj;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.01.01.34.09;	author dj;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.31.02.21.24;	author dj;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.03.00.25.57;	author dj;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.07.17.24.36;	author dj;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.09.00.05.37;	author dj;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.08.14.35.18;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.23.23.57.50;	author dj;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.22.15.16.04;	author jimb;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.20.18.22.37;	author jimb;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.02.18.58.39;	author dj;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.05.19.08.13;	author dj;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.05.16.51.28;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.23.15.30.54;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.12.02.16.48;	author dj;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.07.23.15.58.10;	author law;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.20.18.56.16;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.15.20.56.25;	author hjl;	state Exp;
branches;
next	;

1.90.2.1
date	2011.07.02.19.45.28;	author jkratoch;	state Exp;
branches;
next	1.90.2.2;

1.90.2.2
date	2011.07.02.19.47.08;	author jkratoch;	state Exp;
branches;
next	;

1.88.2.1
date	2010.11.16.14.49.57;	author ian;	state Exp;
branches;
next	;

1.47.8.1
date	2004.03.27.17.38.09;	author drow;	state Exp;
branches;
next	1.47.8.2;

1.47.8.2
date	2004.09.16.17.01.54;	author drow;	state Exp;
branches;
next	;

1.27.2.1
date	2003.05.23.18.40.55;	author carlton;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2003.09.17.21.28.56;	author carlton;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2003.12.16.00.01.10;	author carlton;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2004.01.26.19.11.48;	author carlton;	state Exp;
branches;
next	;

1.27.4.1
date	2003.12.14.20.28.02;	author drow;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2003.12.20.18.16.51;	author drow;	state Exp;
branches;
next	1.27.4.3;

1.27.4.3
date	2003.12.24.22.08.39;	author drow;	state Exp;
branches;
next	1.27.4.4;

1.27.4.4
date	2004.01.04.19.05.57;	author drow;	state Exp;
branches;
next	1.27.4.5;

1.27.4.5
date	2004.01.13.16.12.17;	author drow;	state Exp;
branches;
next	1.27.4.6;

1.27.4.6
date	2004.02.09.19.43.59;	author drow;	state Exp;
branches;
next	;

1.27.24.1
date	2003.05.04.11.37.50;	author kettenis;	state Exp;
branches;
next	;

1.23.6.1
date	2002.07.22.21.47.15;	author kseitz;	state Exp;
branches;
next	1.23.6.2;

1.23.6.2
date	2002.10.01.00.46.41;	author kseitz;	state Exp;
branches;
next	;

1.4.2.1
date	2000.10.23.09.43.14;	author pb;	state Exp;
branches;
next	;


desc
@@


1.125
log
@merge from gcc
@
text
@/* Demangler for g++ V3 ABI.
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2014
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@wasabisystems.com>.

   This file is part of the libiberty library, which is part of GCC.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   In addition to the permissions in the GNU General Public License, the
   Free Software Foundation gives you unlimited permission to link the
   compiled version of this file into combinations with other programs,
   and to distribute those combinations without any restriction coming
   from the use of this file.  (The General Public License restrictions
   do apply in other respects; for example, they cover modification of
   the file, and distribution when not linked into a combined
   executable.)

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. 
*/

/* This code implements a demangler for the g++ V3 ABI.  The ABI is
   described on this web page:
       http://www.codesourcery.com/cxx-abi/abi.html#mangling

   This code was written while looking at the demangler written by
   Alex Samuel <samuel@@codesourcery.com>.

   This code first pulls the mangled name apart into a list of
   components, and then walks the list generating the demangled
   name.

   This file will normally define the following functions, q.v.:
      char *cplus_demangle_v3(const char *mangled, int options)
      char *java_demangle_v3(const char *mangled)
      int cplus_demangle_v3_callback(const char *mangled, int options,
                                     demangle_callbackref callback)
      int java_demangle_v3_callback(const char *mangled,
                                    demangle_callbackref callback)
      enum gnu_v3_ctor_kinds is_gnu_v3_mangled_ctor (const char *name)
      enum gnu_v3_dtor_kinds is_gnu_v3_mangled_dtor (const char *name)

   Also, the interface to the component list is public, and defined in
   demangle.h.  The interface consists of these types, which are
   defined in demangle.h:
      enum demangle_component_type
      struct demangle_component
      demangle_callbackref
   and these functions defined in this file:
      cplus_demangle_fill_name
      cplus_demangle_fill_extended_operator
      cplus_demangle_fill_ctor
      cplus_demangle_fill_dtor
      cplus_demangle_print
      cplus_demangle_print_callback
   and other functions defined in the file cp-demint.c.

   This file also defines some other functions and variables which are
   only to be used by the file cp-demint.c.

   Preprocessor macros you can define while compiling this file:

   IN_LIBGCC2
      If defined, this file defines the following functions, q.v.:
         char *__cxa_demangle (const char *mangled, char *buf, size_t *len,
                               int *status)
         int __gcclibcxx_demangle_callback (const char *,
                                            void (*)
                                              (const char *, size_t, void *),
                                            void *)
      instead of cplus_demangle_v3[_callback]() and
      java_demangle_v3[_callback]().

   IN_GLIBCPP_V3
      If defined, this file defines only __cxa_demangle() and
      __gcclibcxx_demangle_callback(), and no other publically visible
      functions or variables.

   STANDALONE_DEMANGLER
      If defined, this file defines a main() function which demangles
      any arguments, or, if none, demangles stdin.

   CP_DEMANGLE_DEBUG
      If defined, turns on debugging mode, which prints information on
      stdout about the mangled string.  This is not generally useful.
*/

#if defined (_AIX) && !defined (__GNUC__)
 #pragma alloca
#endif

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#ifdef HAVE_ALLOCA_H
# include <alloca.h>
#else
# ifndef alloca
#  ifdef __GNUC__
#   define alloca __builtin_alloca
#  else
extern char *alloca ();
#  endif /* __GNUC__ */
# endif /* alloca */
#endif /* HAVE_ALLOCA_H */

#include "ansidecl.h"
#include "libiberty.h"
#include "demangle.h"
#include "cp-demangle.h"

/* If IN_GLIBCPP_V3 is defined, some functions are made static.  We
   also rename them via #define to avoid compiler errors when the
   static definition conflicts with the extern declaration in a header
   file.  */
#ifdef IN_GLIBCPP_V3

#define CP_STATIC_IF_GLIBCPP_V3 static

#define cplus_demangle_fill_name d_fill_name
static int d_fill_name (struct demangle_component *, const char *, int);

#define cplus_demangle_fill_extended_operator d_fill_extended_operator
static int
d_fill_extended_operator (struct demangle_component *, int,
                          struct demangle_component *);

#define cplus_demangle_fill_ctor d_fill_ctor
static int
d_fill_ctor (struct demangle_component *, enum gnu_v3_ctor_kinds,
             struct demangle_component *);

#define cplus_demangle_fill_dtor d_fill_dtor
static int
d_fill_dtor (struct demangle_component *, enum gnu_v3_dtor_kinds,
             struct demangle_component *);

#define cplus_demangle_mangled_name d_mangled_name
static struct demangle_component *d_mangled_name (struct d_info *, int);

#define cplus_demangle_type d_type
static struct demangle_component *d_type (struct d_info *);

#define cplus_demangle_print d_print
static char *d_print (int, const struct demangle_component *, int, size_t *);

#define cplus_demangle_print_callback d_print_callback
static int d_print_callback (int, const struct demangle_component *,
                             demangle_callbackref, void *);

#define cplus_demangle_init_info d_init_info
static void d_init_info (const char *, int, size_t, struct d_info *);

#else /* ! defined(IN_GLIBCPP_V3) */
#define CP_STATIC_IF_GLIBCPP_V3
#endif /* ! defined(IN_GLIBCPP_V3) */

/* See if the compiler supports dynamic arrays.  */

#ifdef __GNUC__
#define CP_DYNAMIC_ARRAYS
#else
#ifdef __STDC__
#ifdef __STDC_VERSION__
#if __STDC_VERSION__ >= 199901L
#define CP_DYNAMIC_ARRAYS
#endif /* __STDC__VERSION >= 199901L */
#endif /* defined (__STDC_VERSION__) */
#endif /* defined (__STDC__) */
#endif /* ! defined (__GNUC__) */

/* We avoid pulling in the ctype tables, to prevent pulling in
   additional unresolved symbols when this code is used in a library.
   FIXME: Is this really a valid reason?  This comes from the original
   V3 demangler code.

   As of this writing this file has the following undefined references
   when compiled with -DIN_GLIBCPP_V3: realloc, free, memcpy, strcpy,
   strcat, strlen.  */

#define IS_DIGIT(c) ((c) >= '0' && (c) <= '9')
#define IS_UPPER(c) ((c) >= 'A' && (c) <= 'Z')
#define IS_LOWER(c) ((c) >= 'a' && (c) <= 'z')

/* The prefix prepended by GCC to an identifier represnting the
   anonymous namespace.  */
#define ANONYMOUS_NAMESPACE_PREFIX "_GLOBAL_"
#define ANONYMOUS_NAMESPACE_PREFIX_LEN \
  (sizeof (ANONYMOUS_NAMESPACE_PREFIX) - 1)

/* Information we keep for the standard substitutions.  */

struct d_standard_sub_info
{
  /* The code for this substitution.  */
  char code;
  /* The simple string it expands to.  */
  const char *simple_expansion;
  /* The length of the simple expansion.  */
  int simple_len;
  /* The results of a full, verbose, expansion.  This is used when
     qualifying a constructor/destructor, or when in verbose mode.  */
  const char *full_expansion;
  /* The length of the full expansion.  */
  int full_len;
  /* What to set the last_name field of d_info to; NULL if we should
     not set it.  This is only relevant when qualifying a
     constructor/destructor.  */
  const char *set_last_name;
  /* The length of set_last_name.  */
  int set_last_name_len;
};

/* Accessors for subtrees of struct demangle_component.  */

#define d_left(dc) ((dc)->u.s_binary.left)
#define d_right(dc) ((dc)->u.s_binary.right)

/* A list of templates.  This is used while printing.  */

struct d_print_template
{
  /* Next template on the list.  */
  struct d_print_template *next;
  /* This template.  */
  const struct demangle_component *template_decl;
};

/* A list of type modifiers.  This is used while printing.  */

struct d_print_mod
{
  /* Next modifier on the list.  These are in the reverse of the order
     in which they appeared in the mangled string.  */
  struct d_print_mod *next;
  /* The modifier.  */
  const struct demangle_component *mod;
  /* Whether this modifier was printed.  */
  int printed;
  /* The list of templates which applies to this modifier.  */
  struct d_print_template *templates;
};

/* We use these structures to hold information during printing.  */

struct d_growable_string
{
  /* Buffer holding the result.  */
  char *buf;
  /* Current length of data in buffer.  */
  size_t len;
  /* Allocated size of buffer.  */
  size_t alc;
  /* Set to 1 if we had a memory allocation failure.  */
  int allocation_failure;
};

/* Stack of components, innermost first, used to avoid loops.  */

struct d_component_stack
{
  /* This component.  */
  const struct demangle_component *dc;
  /* This component's parent.  */
  const struct d_component_stack *parent;
};

/* A demangle component and some scope captured when it was first
   traversed.  */

struct d_saved_scope
{
  /* The component whose scope this is.  */
  const struct demangle_component *container;
  /* The list of templates, if any, that was current when this
     scope was captured.  */
  struct d_print_template *templates;
};

/* Checkpoint structure to allow backtracking.  This holds copies
   of the fields of struct d_info that need to be restored
   if a trial parse needs to be backtracked over.  */

struct d_info_checkpoint
{
  const char *n;
  int next_comp;
  int next_sub;
  int did_subs;
  int expansion;
};

enum { D_PRINT_BUFFER_LENGTH = 256 };
struct d_print_info
{
  /* Fixed-length allocated buffer for demangled data, flushed to the
     callback with a NUL termination once full.  */
  char buf[D_PRINT_BUFFER_LENGTH];
  /* Current length of data in buffer.  */
  size_t len;
  /* The last character printed, saved individually so that it survives
     any buffer flush.  */
  char last_char;
  /* Callback function to handle demangled buffer flush.  */
  demangle_callbackref callback;
  /* Opaque callback argument.  */
  void *opaque;
  /* The current list of templates, if any.  */
  struct d_print_template *templates;
  /* The current list of modifiers (e.g., pointer, reference, etc.),
     if any.  */
  struct d_print_mod *modifiers;
  /* Set to 1 if we saw a demangling error.  */
  int demangle_failure;
  /* The current index into any template argument packs we are using
     for printing.  */
  int pack_index;
  /* Number of d_print_flush calls so far.  */
  unsigned long int flush_count;
  /* Stack of components, innermost first, used to avoid loops.  */
  const struct d_component_stack *component_stack;
  /* Array of saved scopes for evaluating substitutions.  */
  struct d_saved_scope *saved_scopes;
  /* Index of the next unused saved scope in the above array.  */
  int next_saved_scope;
  /* Number of saved scopes in the above array.  */
  int num_saved_scopes;
  /* Array of templates for saving into scopes.  */
  struct d_print_template *copy_templates;
  /* Index of the next unused copy template in the above array.  */
  int next_copy_template;
  /* Number of copy templates in the above array.  */
  int num_copy_templates;
  /* The nearest enclosing template, if any.  */
  const struct demangle_component *current_template;
};

#ifdef CP_DEMANGLE_DEBUG
static void d_dump (struct demangle_component *, int);
#endif

static struct demangle_component *
d_make_empty (struct d_info *);

static struct demangle_component *
d_make_comp (struct d_info *, enum demangle_component_type,
             struct demangle_component *,
             struct demangle_component *);

static struct demangle_component *
d_make_name (struct d_info *, const char *, int);

static struct demangle_component *
d_make_demangle_mangled_name (struct d_info *, const char *);

static struct demangle_component *
d_make_builtin_type (struct d_info *,
                     const struct demangle_builtin_type_info *);

static struct demangle_component *
d_make_operator (struct d_info *,
                 const struct demangle_operator_info *);

static struct demangle_component *
d_make_extended_operator (struct d_info *, int,
                          struct demangle_component *);

static struct demangle_component *
d_make_ctor (struct d_info *, enum gnu_v3_ctor_kinds,
             struct demangle_component *);

static struct demangle_component *
d_make_dtor (struct d_info *, enum gnu_v3_dtor_kinds,
             struct demangle_component *);

static struct demangle_component *
d_make_template_param (struct d_info *, long);

static struct demangle_component *
d_make_sub (struct d_info *, const char *, int);

static int
has_return_type (struct demangle_component *);

static int
is_ctor_dtor_or_conversion (struct demangle_component *);

static struct demangle_component *d_encoding (struct d_info *, int);

static struct demangle_component *d_name (struct d_info *);

static struct demangle_component *d_nested_name (struct d_info *);

static struct demangle_component *d_prefix (struct d_info *);

static struct demangle_component *d_unqualified_name (struct d_info *);

static struct demangle_component *d_source_name (struct d_info *);

static long d_number (struct d_info *);

static struct demangle_component *d_identifier (struct d_info *, int);

static struct demangle_component *d_operator_name (struct d_info *);

static struct demangle_component *d_special_name (struct d_info *);

static int d_call_offset (struct d_info *, int);

static struct demangle_component *d_ctor_dtor_name (struct d_info *);

static struct demangle_component **
d_cv_qualifiers (struct d_info *, struct demangle_component **, int);

static struct demangle_component *
d_ref_qualifier (struct d_info *, struct demangle_component *);

static struct demangle_component *
d_function_type (struct d_info *);

static struct demangle_component *
d_bare_function_type (struct d_info *, int);

static struct demangle_component *
d_class_enum_type (struct d_info *);

static struct demangle_component *d_array_type (struct d_info *);

static struct demangle_component *d_vector_type (struct d_info *);

static struct demangle_component *
d_pointer_to_member_type (struct d_info *);

static struct demangle_component *
d_template_param (struct d_info *);

static struct demangle_component *d_template_args (struct d_info *);

static struct demangle_component *
d_template_arg (struct d_info *);

static struct demangle_component *d_expression (struct d_info *);

static struct demangle_component *d_expr_primary (struct d_info *);

static struct demangle_component *d_local_name (struct d_info *);

static int d_discriminator (struct d_info *);

static struct demangle_component *d_lambda (struct d_info *);

static struct demangle_component *d_unnamed_type (struct d_info *);

static struct demangle_component *
d_clone_suffix (struct d_info *, struct demangle_component *);

static int
d_add_substitution (struct d_info *, struct demangle_component *);

static struct demangle_component *d_substitution (struct d_info *, int);

static void d_checkpoint (struct d_info *, struct d_info_checkpoint *);

static void d_backtrack (struct d_info *, struct d_info_checkpoint *);

static void d_growable_string_init (struct d_growable_string *, size_t);

static inline void
d_growable_string_resize (struct d_growable_string *, size_t);

static inline void
d_growable_string_append_buffer (struct d_growable_string *,
                                 const char *, size_t);
static void
d_growable_string_callback_adapter (const char *, size_t, void *);

static void
d_print_init (struct d_print_info *, demangle_callbackref, void *,
	      const struct demangle_component *);

static inline void d_print_error (struct d_print_info *);

static inline int d_print_saw_error (struct d_print_info *);

static inline void d_print_flush (struct d_print_info *);

static inline void d_append_char (struct d_print_info *, char);

static inline void d_append_buffer (struct d_print_info *,
                                    const char *, size_t);

static inline void d_append_string (struct d_print_info *, const char *);

static inline char d_last_char (struct d_print_info *);

static void
d_print_comp (struct d_print_info *, int, const struct demangle_component *);

static void
d_print_java_identifier (struct d_print_info *, const char *, int);

static void
d_print_mod_list (struct d_print_info *, int, struct d_print_mod *, int);

static void
d_print_mod (struct d_print_info *, int, const struct demangle_component *);

static void
d_print_function_type (struct d_print_info *, int,
                       const struct demangle_component *,
                       struct d_print_mod *);

static void
d_print_array_type (struct d_print_info *, int,
                    const struct demangle_component *,
                    struct d_print_mod *);

static void
d_print_expr_op (struct d_print_info *, int, const struct demangle_component *);

static void
d_print_cast (struct d_print_info *, int, const struct demangle_component *);

static int d_demangle_callback (const char *, int,
                                demangle_callbackref, void *);
static char *d_demangle (const char *, int, size_t *);

#ifdef CP_DEMANGLE_DEBUG

static void
d_dump (struct demangle_component *dc, int indent)
{
  int i;

  if (dc == NULL)
    {
      if (indent == 0)
        printf ("failed demangling\n");
      return;
    }

  for (i = 0; i < indent; ++i)
    putchar (' ');

  switch (dc->type)
    {
    case DEMANGLE_COMPONENT_NAME:
      printf ("name '%.*s'\n", dc->u.s_name.len, dc->u.s_name.s);
      return;
    case DEMANGLE_COMPONENT_TAGGED_NAME:
      printf ("tagged name\n");
      d_dump (dc->u.s_binary.left, indent + 2);
      d_dump (dc->u.s_binary.right, indent + 2);
      return;
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
      printf ("template parameter %ld\n", dc->u.s_number.number);
      return;
    case DEMANGLE_COMPONENT_FUNCTION_PARAM:
      printf ("function parameter %ld\n", dc->u.s_number.number);
      return;
    case DEMANGLE_COMPONENT_CTOR:
      printf ("constructor %d\n", (int) dc->u.s_ctor.kind);
      d_dump (dc->u.s_ctor.name, indent + 2);
      return;
    case DEMANGLE_COMPONENT_DTOR:
      printf ("destructor %d\n", (int) dc->u.s_dtor.kind);
      d_dump (dc->u.s_dtor.name, indent + 2);
      return;
    case DEMANGLE_COMPONENT_SUB_STD:
      printf ("standard substitution %s\n", dc->u.s_string.string);
      return;
    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
      printf ("builtin type %s\n", dc->u.s_builtin.type->name);
      return;
    case DEMANGLE_COMPONENT_OPERATOR:
      printf ("operator %s\n", dc->u.s_operator.op->name);
      return;
    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
      printf ("extended operator with %d args\n",
	      dc->u.s_extended_operator.args);
      d_dump (dc->u.s_extended_operator.name, indent + 2);
      return;

    case DEMANGLE_COMPONENT_QUAL_NAME:
      printf ("qualified name\n");
      break;
    case DEMANGLE_COMPONENT_LOCAL_NAME:
      printf ("local name\n");
      break;
    case DEMANGLE_COMPONENT_TYPED_NAME:
      printf ("typed name\n");
      break;
    case DEMANGLE_COMPONENT_TEMPLATE:
      printf ("template\n");
      break;
    case DEMANGLE_COMPONENT_VTABLE:
      printf ("vtable\n");
      break;
    case DEMANGLE_COMPONENT_VTT:
      printf ("VTT\n");
      break;
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
      printf ("construction vtable\n");
      break;
    case DEMANGLE_COMPONENT_TYPEINFO:
      printf ("typeinfo\n");
      break;
    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
      printf ("typeinfo name\n");
      break;
    case DEMANGLE_COMPONENT_TYPEINFO_FN:
      printf ("typeinfo function\n");
      break;
    case DEMANGLE_COMPONENT_THUNK:
      printf ("thunk\n");
      break;
    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
      printf ("virtual thunk\n");
      break;
    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
      printf ("covariant thunk\n");
      break;
    case DEMANGLE_COMPONENT_JAVA_CLASS:
      printf ("java class\n");
      break;
    case DEMANGLE_COMPONENT_GUARD:
      printf ("guard\n");
      break;
    case DEMANGLE_COMPONENT_REFTEMP:
      printf ("reference temporary\n");
      break;
    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:
      printf ("hidden alias\n");
      break;
    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:
      printf ("transaction clone\n");
      break;
    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:
      printf ("non-transaction clone\n");
      break;
    case DEMANGLE_COMPONENT_RESTRICT:
      printf ("restrict\n");
      break;
    case DEMANGLE_COMPONENT_VOLATILE:
      printf ("volatile\n");
      break;
    case DEMANGLE_COMPONENT_CONST:
      printf ("const\n");
      break;
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
      printf ("restrict this\n");
      break;
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
      printf ("volatile this\n");
      break;
    case DEMANGLE_COMPONENT_CONST_THIS:
      printf ("const this\n");
      break;
    case DEMANGLE_COMPONENT_REFERENCE_THIS:
      printf ("reference this\n");
      break;
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
      printf ("rvalue reference this\n");
      break;
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
      printf ("vendor type qualifier\n");
      break;
    case DEMANGLE_COMPONENT_POINTER:
      printf ("pointer\n");
      break;
    case DEMANGLE_COMPONENT_REFERENCE:
      printf ("reference\n");
      break;
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:
      printf ("rvalue reference\n");
      break;
    case DEMANGLE_COMPONENT_COMPLEX:
      printf ("complex\n");
      break;
    case DEMANGLE_COMPONENT_IMAGINARY:
      printf ("imaginary\n");
      break;
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
      printf ("vendor type\n");
      break;
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
      printf ("function type\n");
      break;
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
      printf ("array type\n");
      break;
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
      printf ("pointer to member type\n");
      break;
    case DEMANGLE_COMPONENT_FIXED_TYPE:
      printf ("fixed-point type, accum? %d, sat? %d\n",
              dc->u.s_fixed.accum, dc->u.s_fixed.sat);
      d_dump (dc->u.s_fixed.length, indent + 2)
      break;
    case DEMANGLE_COMPONENT_ARGLIST:
      printf ("argument list\n");
      break;
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
      printf ("template argument list\n");
      break;
    case DEMANGLE_COMPONENT_INITIALIZER_LIST:
      printf ("initializer list\n");
      break;
    case DEMANGLE_COMPONENT_CAST:
      printf ("cast\n");
      break;
    case DEMANGLE_COMPONENT_NULLARY:
      printf ("nullary operator\n");
      break;
    case DEMANGLE_COMPONENT_UNARY:
      printf ("unary operator\n");
      break;
    case DEMANGLE_COMPONENT_BINARY:
      printf ("binary operator\n");
      break;
    case DEMANGLE_COMPONENT_BINARY_ARGS:
      printf ("binary operator arguments\n");
      break;
    case DEMANGLE_COMPONENT_TRINARY:
      printf ("trinary operator\n");
      break;
    case DEMANGLE_COMPONENT_TRINARY_ARG1:
      printf ("trinary operator arguments 1\n");
      break;
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
      printf ("trinary operator arguments 1\n");
      break;
    case DEMANGLE_COMPONENT_LITERAL:
      printf ("literal\n");
      break;
    case DEMANGLE_COMPONENT_LITERAL_NEG:
      printf ("negative literal\n");
      break;
    case DEMANGLE_COMPONENT_JAVA_RESOURCE:
      printf ("java resource\n");
      break;
    case DEMANGLE_COMPONENT_COMPOUND_NAME:
      printf ("compound name\n");
      break;
    case DEMANGLE_COMPONENT_CHARACTER:
      printf ("character '%c'\n",  dc->u.s_character.character);
      return;
    case DEMANGLE_COMPONENT_NUMBER:
      printf ("number %ld\n", dc->u.s_number.number);
      return;
    case DEMANGLE_COMPONENT_DECLTYPE:
      printf ("decltype\n");
      break;
    case DEMANGLE_COMPONENT_PACK_EXPANSION:
      printf ("pack expansion\n");
      break;
    case DEMANGLE_COMPONENT_TLS_INIT:
      printf ("tls init function\n");
      break;
    case DEMANGLE_COMPONENT_TLS_WRAPPER:
      printf ("tls wrapper function\n");
      break;
    case DEMANGLE_COMPONENT_DEFAULT_ARG:
      printf ("default argument %d\n", dc->u.s_unary_num.num);
      d_dump (dc->u.s_unary_num.sub, indent+2);
      return;
    case DEMANGLE_COMPONENT_LAMBDA:
      printf ("lambda %d\n", dc->u.s_unary_num.num);
      d_dump (dc->u.s_unary_num.sub, indent+2);
      return;
    }

  d_dump (d_left (dc), indent + 2);
  d_dump (d_right (dc), indent + 2);
}

#endif /* CP_DEMANGLE_DEBUG */

/* Fill in a DEMANGLE_COMPONENT_NAME.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_name (struct demangle_component *p, const char *s, int len)
{
  if (p == NULL || s == NULL || len == 0)
    return 0;
  p->type = DEMANGLE_COMPONENT_NAME;
  p->u.s_name.s = s;
  p->u.s_name.len = len;
  return 1;
}

/* Fill in a DEMANGLE_COMPONENT_EXTENDED_OPERATOR.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_extended_operator (struct demangle_component *p, int args,
                                       struct demangle_component *name)
{
  if (p == NULL || args < 0 || name == NULL)
    return 0;
  p->type = DEMANGLE_COMPONENT_EXTENDED_OPERATOR;
  p->u.s_extended_operator.args = args;
  p->u.s_extended_operator.name = name;
  return 1;
}

/* Fill in a DEMANGLE_COMPONENT_CTOR.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_ctor (struct demangle_component *p,
                          enum gnu_v3_ctor_kinds kind,
                          struct demangle_component *name)
{
  if (p == NULL
      || name == NULL
      || (int) kind < gnu_v3_complete_object_ctor
      || (int) kind > gnu_v3_object_ctor_group)
    return 0;
  p->type = DEMANGLE_COMPONENT_CTOR;
  p->u.s_ctor.kind = kind;
  p->u.s_ctor.name = name;
  return 1;
}

/* Fill in a DEMANGLE_COMPONENT_DTOR.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_dtor (struct demangle_component *p,
                          enum gnu_v3_dtor_kinds kind,
                          struct demangle_component *name)
{
  if (p == NULL
      || name == NULL
      || (int) kind < gnu_v3_deleting_dtor
      || (int) kind > gnu_v3_object_dtor_group)
    return 0;
  p->type = DEMANGLE_COMPONENT_DTOR;
  p->u.s_dtor.kind = kind;
  p->u.s_dtor.name = name;
  return 1;
}

/* Add a new component.  */

static struct demangle_component *
d_make_empty (struct d_info *di)
{
  struct demangle_component *p;

  if (di->next_comp >= di->num_comps)
    return NULL;
  p = &di->comps[di->next_comp];
  ++di->next_comp;
  return p;
}

/* Add a new generic component.  */

static struct demangle_component *
d_make_comp (struct d_info *di, enum demangle_component_type type,
             struct demangle_component *left,
             struct demangle_component *right)
{
  struct demangle_component *p;

  /* We check for errors here.  A typical error would be a NULL return
     from a subroutine.  We catch those here, and return NULL
     upward.  */
  switch (type)
    {
      /* These types require two parameters.  */
    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
    case DEMANGLE_COMPONENT_TYPED_NAME:
    case DEMANGLE_COMPONENT_TAGGED_NAME:
    case DEMANGLE_COMPONENT_TEMPLATE:
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
    case DEMANGLE_COMPONENT_UNARY:
    case DEMANGLE_COMPONENT_BINARY:
    case DEMANGLE_COMPONENT_BINARY_ARGS:
    case DEMANGLE_COMPONENT_TRINARY:
    case DEMANGLE_COMPONENT_TRINARY_ARG1:
    case DEMANGLE_COMPONENT_LITERAL:
    case DEMANGLE_COMPONENT_LITERAL_NEG:
    case DEMANGLE_COMPONENT_COMPOUND_NAME:
    case DEMANGLE_COMPONENT_VECTOR_TYPE:
    case DEMANGLE_COMPONENT_CLONE:
      if (left == NULL || right == NULL)
	return NULL;
      break;

      /* These types only require one parameter.  */
    case DEMANGLE_COMPONENT_VTABLE:
    case DEMANGLE_COMPONENT_VTT:
    case DEMANGLE_COMPONENT_TYPEINFO:
    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
    case DEMANGLE_COMPONENT_TYPEINFO_FN:
    case DEMANGLE_COMPONENT_THUNK:
    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
    case DEMANGLE_COMPONENT_JAVA_CLASS:
    case DEMANGLE_COMPONENT_GUARD:
    case DEMANGLE_COMPONENT_TLS_INIT:
    case DEMANGLE_COMPONENT_TLS_WRAPPER:
    case DEMANGLE_COMPONENT_REFTEMP:
    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:
    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:
    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_REFERENCE:
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
    case DEMANGLE_COMPONENT_CAST:
    case DEMANGLE_COMPONENT_JAVA_RESOURCE:
    case DEMANGLE_COMPONENT_DECLTYPE:
    case DEMANGLE_COMPONENT_PACK_EXPANSION:
    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:
    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:
    case DEMANGLE_COMPONENT_NULLARY:
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
      if (left == NULL)
	return NULL;
      break;

      /* This needs a right parameter, but the left parameter can be
	 empty.  */
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
    case DEMANGLE_COMPONENT_INITIALIZER_LIST:
      if (right == NULL)
	return NULL;
      break;

      /* These are allowed to have no parameters--in some cases they
	 will be filled in later.  */
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
    case DEMANGLE_COMPONENT_REFERENCE_THIS:
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
    case DEMANGLE_COMPONENT_ARGLIST:
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
      break;

      /* Other types should not be seen here.  */
    default:
      return NULL;
    }

  p = d_make_empty (di);
  if (p != NULL)
    {
      p->type = type;
      p->u.s_binary.left = left;
      p->u.s_binary.right = right;
    }
  return p;
}

/* Add a new demangle mangled name component.  */

static struct demangle_component *
d_make_demangle_mangled_name (struct d_info *di, const char *s)
{
  if (d_peek_char (di) != '_' || d_peek_next_char (di) != 'Z')
    return d_make_name (di, s, strlen (s));
  d_advance (di, 2);
  return d_encoding (di, 0);
}

/* Add a new name component.  */

static struct demangle_component *
d_make_name (struct d_info *di, const char *s, int len)
{
  struct demangle_component *p;

  p = d_make_empty (di);
  if (! cplus_demangle_fill_name (p, s, len))
    return NULL;
  return p;
}

/* Add a new builtin type component.  */

static struct demangle_component *
d_make_builtin_type (struct d_info *di,
                     const struct demangle_builtin_type_info *type)
{
  struct demangle_component *p;

  if (type == NULL)
    return NULL;
  p = d_make_empty (di);
  if (p != NULL)
    {
      p->type = DEMANGLE_COMPONENT_BUILTIN_TYPE;
      p->u.s_builtin.type = type;
    }
  return p;
}

/* Add a new operator component.  */

static struct demangle_component *
d_make_operator (struct d_info *di, const struct demangle_operator_info *op)
{
  struct demangle_component *p;

  p = d_make_empty (di);
  if (p != NULL)
    {
      p->type = DEMANGLE_COMPONENT_OPERATOR;
      p->u.s_operator.op = op;
    }
  return p;
}

/* Add a new extended operator component.  */

static struct demangle_component *
d_make_extended_operator (struct d_info *di, int args,
                          struct demangle_component *name)
{
  struct demangle_component *p;

  p = d_make_empty (di);
  if (! cplus_demangle_fill_extended_operator (p, args, name))
    return NULL;
  return p;
}

static struct demangle_component *
d_make_default_arg (struct d_info *di, int num,
		    struct demangle_component *sub)
{
  struct demangle_component *p = d_make_empty (di);
  if (p)
    {
      p->type = DEMANGLE_COMPONENT_DEFAULT_ARG;
      p->u.s_unary_num.num = num;
      p->u.s_unary_num.sub = sub;
    }
  return p;
}

/* Add a new constructor component.  */

static struct demangle_component *
d_make_ctor (struct d_info *di, enum gnu_v3_ctor_kinds kind,
             struct demangle_component *name)
{
  struct demangle_component *p;

  p = d_make_empty (di);
  if (! cplus_demangle_fill_ctor (p, kind, name))
    return NULL;
  return p;
}

/* Add a new destructor component.  */

static struct demangle_component *
d_make_dtor (struct d_info *di, enum gnu_v3_dtor_kinds kind,
             struct demangle_component *name)
{
  struct demangle_component *p;

  p = d_make_empty (di);
  if (! cplus_demangle_fill_dtor (p, kind, name))
    return NULL;
  return p;
}

/* Add a new template parameter.  */

static struct demangle_component *
d_make_template_param (struct d_info *di, long i)
{
  struct demangle_component *p;

  p = d_make_empty (di);
  if (p != NULL)
    {
      p->type = DEMANGLE_COMPONENT_TEMPLATE_PARAM;
      p->u.s_number.number = i;
    }
  return p;
}

/* Add a new function parameter.  */

static struct demangle_component *
d_make_function_param (struct d_info *di, long i)
{
  struct demangle_component *p;

  p = d_make_empty (di);
  if (p != NULL)
    {
      p->type = DEMANGLE_COMPONENT_FUNCTION_PARAM;
      p->u.s_number.number = i;
    }
  return p;
}

/* Add a new standard substitution component.  */

static struct demangle_component *
d_make_sub (struct d_info *di, const char *name, int len)
{
  struct demangle_component *p;

  p = d_make_empty (di);
  if (p != NULL)
    {
      p->type = DEMANGLE_COMPONENT_SUB_STD;
      p->u.s_string.string = name;
      p->u.s_string.len = len;
    }
  return p;
}

/* <mangled-name> ::= _Z <encoding> [<clone-suffix>]*

   TOP_LEVEL is non-zero when called at the top level.  */

CP_STATIC_IF_GLIBCPP_V3
struct demangle_component *
cplus_demangle_mangled_name (struct d_info *di, int top_level)
{
  struct demangle_component *p;

  if (! d_check_char (di, '_')
      /* Allow missing _ if not at toplevel to work around a
	 bug in G++ abi-version=2 mangling; see the comment in
	 write_template_arg.  */
      && top_level)
    return NULL;
  if (! d_check_char (di, 'Z'))
    return NULL;
  p = d_encoding (di, top_level);

  /* If at top level and parsing parameters, check for a clone
     suffix.  */
  if (top_level && (di->options & DMGL_PARAMS) != 0)
    while (d_peek_char (di) == '.'
	   && (IS_LOWER (d_peek_next_char (di))
	       || d_peek_next_char (di) == '_'
	       || IS_DIGIT (d_peek_next_char (di))))
      p = d_clone_suffix (di, p);

  return p;
}

/* Return whether a function should have a return type.  The argument
   is the function name, which may be qualified in various ways.  The
   rules are that template functions have return types with some
   exceptions, function types which are not part of a function name
   mangling have return types with some exceptions, and non-template
   function names do not have return types.  The exceptions are that
   constructors, destructors, and conversion operators do not have
   return types.  */

static int
has_return_type (struct demangle_component *dc)
{
  if (dc == NULL)
    return 0;
  switch (dc->type)
    {
    default:
      return 0;
    case DEMANGLE_COMPONENT_TEMPLATE:
      return ! is_ctor_dtor_or_conversion (d_left (dc));
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
    case DEMANGLE_COMPONENT_REFERENCE_THIS:
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
      return has_return_type (d_left (dc));
    }
}

/* Return whether a name is a constructor, a destructor, or a
   conversion operator.  */

static int
is_ctor_dtor_or_conversion (struct demangle_component *dc)
{
  if (dc == NULL)
    return 0;
  switch (dc->type)
    {
    default:
      return 0;
    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
      return is_ctor_dtor_or_conversion (d_right (dc));
    case DEMANGLE_COMPONENT_CTOR:
    case DEMANGLE_COMPONENT_DTOR:
    case DEMANGLE_COMPONENT_CAST:
      return 1;
    }
}

/* <encoding> ::= <(function) name> <bare-function-type>
              ::= <(data) name>
              ::= <special-name>

   TOP_LEVEL is non-zero when called at the top level, in which case
   if DMGL_PARAMS is not set we do not demangle the function
   parameters.  We only set this at the top level, because otherwise
   we would not correctly demangle names in local scopes.  */

static struct demangle_component *
d_encoding (struct d_info *di, int top_level)
{
  char peek = d_peek_char (di);

  if (peek == 'G' || peek == 'T')
    return d_special_name (di);
  else
    {
      struct demangle_component *dc;

      dc = d_name (di);

      if (dc != NULL && top_level && (di->options & DMGL_PARAMS) == 0)
	{
	  /* Strip off any initial CV-qualifiers, as they really apply
	     to the `this' parameter, and they were not output by the
	     v2 demangler without DMGL_PARAMS.  */
	  while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS
		 || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS
		 || dc->type == DEMANGLE_COMPONENT_CONST_THIS
		 || dc->type == DEMANGLE_COMPONENT_REFERENCE_THIS
		 || dc->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)
	    dc = d_left (dc);

	  /* If the top level is a DEMANGLE_COMPONENT_LOCAL_NAME, then
	     there may be CV-qualifiers on its right argument which
	     really apply here; this happens when parsing a class
	     which is local to a function.  */
	  if (dc->type == DEMANGLE_COMPONENT_LOCAL_NAME)
	    {
	      struct demangle_component *dcr;

	      dcr = d_right (dc);
	      while (dcr->type == DEMANGLE_COMPONENT_RESTRICT_THIS
		     || dcr->type == DEMANGLE_COMPONENT_VOLATILE_THIS
		     || dcr->type == DEMANGLE_COMPONENT_CONST_THIS
		     || dcr->type == DEMANGLE_COMPONENT_REFERENCE_THIS
		     || dcr->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)
		dcr = d_left (dcr);
	      dc->u.s_binary.right = dcr;
	    }

	  return dc;
	}

      peek = d_peek_char (di);
      if (dc == NULL || peek == '\0' || peek == 'E')
	return dc;
      return d_make_comp (di, DEMANGLE_COMPONENT_TYPED_NAME, dc,
			  d_bare_function_type (di, has_return_type (dc)));
    }
}

/* <tagged-name> ::= <name> B <source-name> */

static struct demangle_component *
d_abi_tags (struct d_info *di, struct demangle_component *dc)
{
  char peek;
  while (peek = d_peek_char (di),
	 peek == 'B')
    {
      struct demangle_component *tag;
      d_advance (di, 1);
      tag = d_source_name (di);
      dc = d_make_comp (di, DEMANGLE_COMPONENT_TAGGED_NAME, dc, tag);
    }
  return dc;
}

/* <name> ::= <nested-name>
          ::= <unscoped-name>
          ::= <unscoped-template-name> <template-args>
          ::= <local-name>

   <unscoped-name> ::= <unqualified-name>
                   ::= St <unqualified-name>

   <unscoped-template-name> ::= <unscoped-name>
                            ::= <substitution>
*/

static struct demangle_component *
d_name (struct d_info *di)
{
  char peek = d_peek_char (di);
  struct demangle_component *dc;

  switch (peek)
    {
    case 'N':
      return d_nested_name (di);

    case 'Z':
      return d_local_name (di);

    case 'U':
      return d_unqualified_name (di);

    case 'S':
      {
	int subst;

	if (d_peek_next_char (di) != 't')
	  {
	    dc = d_substitution (di, 0);
	    subst = 1;
	  }
	else
	  {
	    d_advance (di, 2);
	    dc = d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME,
			      d_make_name (di, "std", 3),
			      d_unqualified_name (di));
	    di->expansion += 3;
	    subst = 0;
	  }

	if (d_peek_char (di) != 'I')
	  {
	    /* The grammar does not permit this case to occur if we
	       called d_substitution() above (i.e., subst == 1).  We
	       don't bother to check.  */
	  }
	else
	  {
	    /* This is <template-args>, which means that we just saw
	       <unscoped-template-name>, which is a substitution
	       candidate if we didn't just get it from a
	       substitution.  */
	    if (! subst)
	      {
		if (! d_add_substitution (di, dc))
		  return NULL;
	      }
	    dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,
			      d_template_args (di));
	  }

	return dc;
      }

    case 'L':
    default:
      dc = d_unqualified_name (di);
      if (d_peek_char (di) == 'I')
	{
	  /* This is <template-args>, which means that we just saw
	     <unscoped-template-name>, which is a substitution
	     candidate.  */
	  if (! d_add_substitution (di, dc))
	    return NULL;
	  dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,
			    d_template_args (di));
	}
      return dc;
    }
}

/* <nested-name> ::= N [<CV-qualifiers>] [<ref-qualifier>] <prefix> <unqualified-name> E
                 ::= N [<CV-qualifiers>] [<ref-qualifier>] <template-prefix> <template-args> E
*/

static struct demangle_component *
d_nested_name (struct d_info *di)
{
  struct demangle_component *ret;
  struct demangle_component **pret;
  struct demangle_component *rqual;

  if (! d_check_char (di, 'N'))
    return NULL;

  pret = d_cv_qualifiers (di, &ret, 1);
  if (pret == NULL)
    return NULL;

  /* Parse the ref-qualifier now and then attach it
     once we have something to attach it to.  */
  rqual = d_ref_qualifier (di, NULL);

  *pret = d_prefix (di);
  if (*pret == NULL)
    return NULL;

  if (rqual)
    {
      d_left (rqual) = ret;
      ret = rqual;
    }

  if (! d_check_char (di, 'E'))
    return NULL;

  return ret;
}

/* <prefix> ::= <prefix> <unqualified-name>
            ::= <template-prefix> <template-args>
            ::= <template-param>
            ::= <decltype>
            ::=
            ::= <substitution>

   <template-prefix> ::= <prefix> <(template) unqualified-name>
                     ::= <template-param>
                     ::= <substitution>
*/

static struct demangle_component *
d_prefix (struct d_info *di)
{
  struct demangle_component *ret = NULL;

  while (1)
    {
      char peek;
      enum demangle_component_type comb_type;
      struct demangle_component *dc;

      peek = d_peek_char (di);
      if (peek == '\0')
	return NULL;

      /* The older code accepts a <local-name> here, but I don't see
	 that in the grammar.  The older code does not accept a
	 <template-param> here.  */

      comb_type = DEMANGLE_COMPONENT_QUAL_NAME;
      if (peek == 'D')
	{
	  char peek2 = d_peek_next_char (di);
	  if (peek2 == 'T' || peek2 == 't')
	    /* Decltype.  */
	    dc = cplus_demangle_type (di);
	  else
	    /* Destructor name.  */
	    dc = d_unqualified_name (di);
	}
      else if (IS_DIGIT (peek)
	  || IS_LOWER (peek)
	  || peek == 'C'
	  || peek == 'U'
	  || peek == 'L')
	dc = d_unqualified_name (di);
      else if (peek == 'S')
	dc = d_substitution (di, 1);
      else if (peek == 'I')
	{
	  if (ret == NULL)
	    return NULL;
	  comb_type = DEMANGLE_COMPONENT_TEMPLATE;
	  dc = d_template_args (di);
	}
      else if (peek == 'T')
	dc = d_template_param (di);
      else if (peek == 'E')
	return ret;
      else if (peek == 'M')
	{
	  /* Initializer scope for a lambda.  We don't need to represent
	     this; the normal code will just treat the variable as a type
	     scope, which gives appropriate output.  */
	  if (ret == NULL)
	    return NULL;
	  d_advance (di, 1);
	  continue;
	}
      else
	return NULL;

      if (ret == NULL)
	ret = dc;
      else
	ret = d_make_comp (di, comb_type, ret, dc);

      if (peek != 'S' && d_peek_char (di) != 'E')
	{
	  if (! d_add_substitution (di, ret))
	    return NULL;
	}
    }
}

/* <unqualified-name> ::= <operator-name>
                      ::= <ctor-dtor-name>
                      ::= <source-name>
		      ::= <local-source-name> 

    <local-source-name>	::= L <source-name> <discriminator>
*/

static struct demangle_component *
d_unqualified_name (struct d_info *di)
{
  struct demangle_component *ret;
  char peek;

  peek = d_peek_char (di);
  if (IS_DIGIT (peek))
    ret = d_source_name (di);
  else if (IS_LOWER (peek))
    {
      ret = d_operator_name (di);
      if (ret != NULL && ret->type == DEMANGLE_COMPONENT_OPERATOR)
	{
	  di->expansion += sizeof "operator" + ret->u.s_operator.op->len - 2;
	  if (!strcmp (ret->u.s_operator.op->code, "li"))
	    ret = d_make_comp (di, DEMANGLE_COMPONENT_UNARY, ret,
			       d_source_name (di));
	}
    }
  else if (peek == 'C' || peek == 'D')
    ret = d_ctor_dtor_name (di);
  else if (peek == 'L')
    {
      d_advance (di, 1);

      ret = d_source_name (di);
      if (ret == NULL)
	return NULL;
      if (! d_discriminator (di))
	return NULL;
    }
  else if (peek == 'U')
    {
      switch (d_peek_next_char (di))
	{
	case 'l':
	  ret = d_lambda (di);
	  break;
	case 't':
	  ret = d_unnamed_type (di);
	  break;
	default:
	  return NULL;
	}
    }
  else
    return NULL;

  if (d_peek_char (di) == 'B')
    ret = d_abi_tags (di, ret);
  return ret;
}

/* <source-name> ::= <(positive length) number> <identifier>  */

static struct demangle_component *
d_source_name (struct d_info *di)
{
  long len;
  struct demangle_component *ret;

  len = d_number (di);
  if (len <= 0)
    return NULL;
  ret = d_identifier (di, len);
  di->last_name = ret;
  return ret;
}

/* number ::= [n] <(non-negative decimal integer)>  */

static long
d_number (struct d_info *di)
{
  int negative;
  char peek;
  long ret;

  negative = 0;
  peek = d_peek_char (di);
  if (peek == 'n')
    {
      negative = 1;
      d_advance (di, 1);
      peek = d_peek_char (di);
    }

  ret = 0;
  while (1)
    {
      if (! IS_DIGIT (peek))
	{
	  if (negative)
	    ret = - ret;
	  return ret;
	}
      ret = ret * 10 + peek - '0';
      d_advance (di, 1);
      peek = d_peek_char (di);
    }
}

/* Like d_number, but returns a demangle_component.  */

static struct demangle_component *
d_number_component (struct d_info *di)
{
  struct demangle_component *ret = d_make_empty (di);
  if (ret)
    {
      ret->type = DEMANGLE_COMPONENT_NUMBER;
      ret->u.s_number.number = d_number (di);
    }
  return ret;
}

/* identifier ::= <(unqualified source code identifier)>  */

static struct demangle_component *
d_identifier (struct d_info *di, int len)
{
  const char *name;

  name = d_str (di);

  if (di->send - name < len)
    return NULL;

  d_advance (di, len);

  /* A Java mangled name may have a trailing '$' if it is a C++
     keyword.  This '$' is not included in the length count.  We just
     ignore the '$'.  */
  if ((di->options & DMGL_JAVA) != 0
      && d_peek_char (di) == '$')
    d_advance (di, 1);

  /* Look for something which looks like a gcc encoding of an
     anonymous namespace, and replace it with a more user friendly
     name.  */
  if (len >= (int) ANONYMOUS_NAMESPACE_PREFIX_LEN + 2
      && memcmp (name, ANONYMOUS_NAMESPACE_PREFIX,
		 ANONYMOUS_NAMESPACE_PREFIX_LEN) == 0)
    {
      const char *s;

      s = name + ANONYMOUS_NAMESPACE_PREFIX_LEN;
      if ((*s == '.' || *s == '_' || *s == '$')
	  && s[1] == 'N')
	{
	  di->expansion -= len - sizeof "(anonymous namespace)";
	  return d_make_name (di, "(anonymous namespace)",
			      sizeof "(anonymous namespace)" - 1);
	}
    }

  return d_make_name (di, name, len);
}

/* operator_name ::= many different two character encodings.
                 ::= cv <type>
                 ::= v <digit> <source-name>

   This list is sorted for binary search.  */

#define NL(s) s, (sizeof s) - 1

CP_STATIC_IF_GLIBCPP_V3
const struct demangle_operator_info cplus_demangle_operators[] =
{
  { "aN", NL ("&="),        2 },
  { "aS", NL ("="),         2 },
  { "aa", NL ("&&"),        2 },
  { "ad", NL ("&"),         1 },
  { "an", NL ("&"),         2 },
  { "at", NL ("alignof "),   1 },
  { "az", NL ("alignof "),   1 },
  { "cc", NL ("const_cast"), 2 },
  { "cl", NL ("()"),        2 },
  { "cm", NL (","),         2 },
  { "co", NL ("~"),         1 },
  { "dV", NL ("/="),        2 },
  { "da", NL ("delete[] "), 1 },
  { "dc", NL ("dynamic_cast"), 2 },
  { "de", NL ("*"),         1 },
  { "dl", NL ("delete "),   1 },
  { "ds", NL (".*"),        2 },
  { "dt", NL ("."),         2 },
  { "dv", NL ("/"),         2 },
  { "eO", NL ("^="),        2 },
  { "eo", NL ("^"),         2 },
  { "eq", NL ("=="),        2 },
  { "ge", NL (">="),        2 },
  { "gs", NL ("::"),	    1 },
  { "gt", NL (">"),         2 },
  { "ix", NL ("[]"),        2 },
  { "lS", NL ("<<="),       2 },
  { "le", NL ("<="),        2 },
  { "li", NL ("operator\"\" "), 1 },
  { "ls", NL ("<<"),        2 },
  { "lt", NL ("<"),         2 },
  { "mI", NL ("-="),        2 },
  { "mL", NL ("*="),        2 },
  { "mi", NL ("-"),         2 },
  { "ml", NL ("*"),         2 },
  { "mm", NL ("--"),        1 },
  { "na", NL ("new[]"),     3 },
  { "ne", NL ("!="),        2 },
  { "ng", NL ("-"),         1 },
  { "nt", NL ("!"),         1 },
  { "nw", NL ("new"),       3 },
  { "oR", NL ("|="),        2 },
  { "oo", NL ("||"),        2 },
  { "or", NL ("|"),         2 },
  { "pL", NL ("+="),        2 },
  { "pl", NL ("+"),         2 },
  { "pm", NL ("->*"),       2 },
  { "pp", NL ("++"),        1 },
  { "ps", NL ("+"),         1 },
  { "pt", NL ("->"),        2 },
  { "qu", NL ("?"),         3 },
  { "rM", NL ("%="),        2 },
  { "rS", NL (">>="),       2 },
  { "rc", NL ("reinterpret_cast"), 2 },
  { "rm", NL ("%"),         2 },
  { "rs", NL (">>"),        2 },
  { "sc", NL ("static_cast"), 2 },
  { "st", NL ("sizeof "),   1 },
  { "sz", NL ("sizeof "),   1 },
  { "tr", NL ("throw"),     0 },
  { "tw", NL ("throw "),    1 },
  { NULL, NULL, 0,          0 }
};

static struct demangle_component *
d_operator_name (struct d_info *di)
{
  char c1;
  char c2;

  c1 = d_next_char (di);
  c2 = d_next_char (di);
  if (c1 == 'v' && IS_DIGIT (c2))
    return d_make_extended_operator (di, c2 - '0', d_source_name (di));
  else if (c1 == 'c' && c2 == 'v')
    {
      struct demangle_component *type;
      int was_conversion = di->is_conversion;

      di->is_conversion = ! di->is_expression;
      type = cplus_demangle_type (di);
      di->is_conversion = was_conversion;
      return d_make_comp (di, DEMANGLE_COMPONENT_CAST, type, NULL);
    }
  else
    {
      /* LOW is the inclusive lower bound.  */
      int low = 0;
      /* HIGH is the exclusive upper bound.  We subtract one to ignore
	 the sentinel at the end of the array.  */
      int high = ((sizeof (cplus_demangle_operators)
		   / sizeof (cplus_demangle_operators[0]))
		  - 1);

      while (1)
	{
	  int i;
	  const struct demangle_operator_info *p;

	  i = low + (high - low) / 2;
	  p = cplus_demangle_operators + i;

	  if (c1 == p->code[0] && c2 == p->code[1])
	    return d_make_operator (di, p);

	  if (c1 < p->code[0] || (c1 == p->code[0] && c2 < p->code[1]))
	    high = i;
	  else
	    low = i + 1;
	  if (low == high)
	    return NULL;
	}
    }
}

static struct demangle_component *
d_make_character (struct d_info *di, int c)
{
  struct demangle_component *p;
  p = d_make_empty (di);
  if (p != NULL)
    {
      p->type = DEMANGLE_COMPONENT_CHARACTER;
      p->u.s_character.character = c;
    }
  return p;
}

static struct demangle_component *
d_java_resource (struct d_info *di)
{
  struct demangle_component *p = NULL;
  struct demangle_component *next = NULL;
  long len, i;
  char c;
  const char *str;

  len = d_number (di);
  if (len <= 1)
    return NULL;

  /* Eat the leading '_'.  */
  if (d_next_char (di) != '_')
    return NULL;
  len--;

  str = d_str (di);
  i = 0;

  while (len > 0)
    {
      c = str[i];
      if (!c)
	return NULL;

      /* Each chunk is either a '$' escape...  */
      if (c == '$')
	{
	  i++;
	  switch (str[i++])
	    {
	    case 'S':
	      c = '/';
	      break;
	    case '_':
	      c = '.';
	      break;
	    case '$':
	      c = '$';
	      break;
	    default:
	      return NULL;
	    }
	  next = d_make_character (di, c);
	  d_advance (di, i);
	  str = d_str (di);
	  len -= i;
	  i = 0;
	  if (next == NULL)
	    return NULL;
	}
      /* ... or a sequence of characters.  */
      else
	{
	  while (i < len && str[i] && str[i] != '$')
	    i++;

	  next = d_make_name (di, str, i);
	  d_advance (di, i);
	  str = d_str (di);
	  len -= i;
	  i = 0;
	  if (next == NULL)
	    return NULL;
	}

      if (p == NULL)
	p = next;
      else
	{
	  p = d_make_comp (di, DEMANGLE_COMPONENT_COMPOUND_NAME, p, next);
	  if (p == NULL)
	    return NULL;
	}
    }

  p = d_make_comp (di, DEMANGLE_COMPONENT_JAVA_RESOURCE, p, NULL);

  return p;
}

/* <special-name> ::= TV <type>
                  ::= TT <type>
                  ::= TI <type>
                  ::= TS <type>
                  ::= GV <(object) name>
                  ::= T <call-offset> <(base) encoding>
                  ::= Tc <call-offset> <call-offset> <(base) encoding>
   Also g++ extensions:
                  ::= TC <type> <(offset) number> _ <(base) type>
                  ::= TF <type>
                  ::= TJ <type>
                  ::= GR <name>
		  ::= GA <encoding>
		  ::= Gr <resource name>
		  ::= GTt <encoding>
		  ::= GTn <encoding>
*/

static struct demangle_component *
d_special_name (struct d_info *di)
{
  di->expansion += 20;
  if (d_check_char (di, 'T'))
    {
      switch (d_next_char (di))
	{
	case 'V':
	  di->expansion -= 5;
	  return d_make_comp (di, DEMANGLE_COMPONENT_VTABLE,
			      cplus_demangle_type (di), NULL);
	case 'T':
	  di->expansion -= 10;
	  return d_make_comp (di, DEMANGLE_COMPONENT_VTT,
			      cplus_demangle_type (di), NULL);
	case 'I':
	  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO,
			      cplus_demangle_type (di), NULL);
	case 'S':
	  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO_NAME,
			      cplus_demangle_type (di), NULL);

	case 'h':
	  if (! d_call_offset (di, 'h'))
	    return NULL;
	  return d_make_comp (di, DEMANGLE_COMPONENT_THUNK,
			      d_encoding (di, 0), NULL);

	case 'v':
	  if (! d_call_offset (di, 'v'))
	    return NULL;
	  return d_make_comp (di, DEMANGLE_COMPONENT_VIRTUAL_THUNK,
			      d_encoding (di, 0), NULL);

	case 'c':
	  if (! d_call_offset (di, '\0'))
	    return NULL;
	  if (! d_call_offset (di, '\0'))
	    return NULL;
	  return d_make_comp (di, DEMANGLE_COMPONENT_COVARIANT_THUNK,
			      d_encoding (di, 0), NULL);

	case 'C':
	  {
	    struct demangle_component *derived_type;
	    long offset;
	    struct demangle_component *base_type;

	    derived_type = cplus_demangle_type (di);
	    offset = d_number (di);
	    if (offset < 0)
	      return NULL;
	    if (! d_check_char (di, '_'))
	      return NULL;
	    base_type = cplus_demangle_type (di);
	    /* We don't display the offset.  FIXME: We should display
	       it in verbose mode.  */
	    di->expansion += 5;
	    return d_make_comp (di, DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE,
				base_type, derived_type);
	  }

	case 'F':
	  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO_FN,
			      cplus_demangle_type (di), NULL);
	case 'J':
	  return d_make_comp (di, DEMANGLE_COMPONENT_JAVA_CLASS,
			      cplus_demangle_type (di), NULL);

	case 'H':
	  return d_make_comp (di, DEMANGLE_COMPONENT_TLS_INIT,
			      d_name (di), NULL);

	case 'W':
	  return d_make_comp (di, DEMANGLE_COMPONENT_TLS_WRAPPER,
			      d_name (di), NULL);

	default:
	  return NULL;
	}
    }
  else if (d_check_char (di, 'G'))
    {
      switch (d_next_char (di))
	{
	case 'V':
	  return d_make_comp (di, DEMANGLE_COMPONENT_GUARD, d_name (di), NULL);

	case 'R':
	  {
	    struct demangle_component *name = d_name (di);
	    return d_make_comp (di, DEMANGLE_COMPONENT_REFTEMP, name,
				d_number_component (di));
	  }

	case 'A':
	  return d_make_comp (di, DEMANGLE_COMPONENT_HIDDEN_ALIAS,
			      d_encoding (di, 0), NULL);

	case 'T':
	  switch (d_next_char (di))
	    {
	    case 'n':
	      return d_make_comp (di, DEMANGLE_COMPONENT_NONTRANSACTION_CLONE,
				  d_encoding (di, 0), NULL);
	    default:
	      /* ??? The proposal is that other letters (such as 'h') stand
		 for different variants of transaction cloning, such as
		 compiling directly for hardware transaction support.  But
		 they still should all be transactional clones of some sort
		 so go ahead and call them that.  */
	    case 't':
	      return d_make_comp (di, DEMANGLE_COMPONENT_TRANSACTION_CLONE,
				  d_encoding (di, 0), NULL);
	    }

	case 'r':
	  return d_java_resource (di);

	default:
	  return NULL;
	}
    }
  else
    return NULL;
}

/* <call-offset> ::= h <nv-offset> _
                 ::= v <v-offset> _

   <nv-offset> ::= <(offset) number>

   <v-offset> ::= <(offset) number> _ <(virtual offset) number>

   The C parameter, if not '\0', is a character we just read which is
   the start of the <call-offset>.

   We don't display the offset information anywhere.  FIXME: We should
   display it in verbose mode.  */

static int
d_call_offset (struct d_info *di, int c)
{
  if (c == '\0')
    c = d_next_char (di);

  if (c == 'h')
    d_number (di);
  else if (c == 'v')
    {
      d_number (di);
      if (! d_check_char (di, '_'))
	return 0;
      d_number (di);
    }
  else
    return 0;

  if (! d_check_char (di, '_'))
    return 0;

  return 1;
}

/* <ctor-dtor-name> ::= C1
                    ::= C2
                    ::= C3
                    ::= D0
                    ::= D1
                    ::= D2
*/

static struct demangle_component *
d_ctor_dtor_name (struct d_info *di)
{
  if (di->last_name != NULL)
    {
      if (di->last_name->type == DEMANGLE_COMPONENT_NAME)
	di->expansion += di->last_name->u.s_name.len;
      else if (di->last_name->type == DEMANGLE_COMPONENT_SUB_STD)
	di->expansion += di->last_name->u.s_string.len;
    }
  switch (d_peek_char (di))
    {
    case 'C':
      {
	enum gnu_v3_ctor_kinds kind;

	switch (d_peek_next_char (di))
	  {
	  case '1':
	    kind = gnu_v3_complete_object_ctor;
	    break;
	  case '2':
	    kind = gnu_v3_base_object_ctor;
	    break;
	  case '3':
	    kind = gnu_v3_complete_object_allocating_ctor;
	    break;
          case '4':
	    kind = gnu_v3_unified_ctor;
	    break;
	  case '5':
	    kind = gnu_v3_object_ctor_group;
	    break;
	  default:
	    return NULL;
	  }
	d_advance (di, 2);
	return d_make_ctor (di, kind, di->last_name);
      }

    case 'D':
      {
	enum gnu_v3_dtor_kinds kind;

	switch (d_peek_next_char (di))
	  {
	  case '0':
	    kind = gnu_v3_deleting_dtor;
	    break;
	  case '1':
	    kind = gnu_v3_complete_object_dtor;
	    break;
	  case '2':
	    kind = gnu_v3_base_object_dtor;
	    break;
          /*  digit '3' is not used */
	  case '4':
	    kind = gnu_v3_unified_dtor;
	    break;
	  case '5':
	    kind = gnu_v3_object_dtor_group;
	    break;
	  default:
	    return NULL;
	  }
	d_advance (di, 2);
	return d_make_dtor (di, kind, di->last_name);
      }

    default:
      return NULL;
    }
}

/* <type> ::= <builtin-type>
          ::= <function-type>
          ::= <class-enum-type>
          ::= <array-type>
          ::= <pointer-to-member-type>
          ::= <template-param>
          ::= <template-template-param> <template-args>
          ::= <substitution>
          ::= <CV-qualifiers> <type>
          ::= P <type>
          ::= R <type>
          ::= O <type> (C++0x)
          ::= C <type>
          ::= G <type>
          ::= U <source-name> <type>

   <builtin-type> ::= various one letter codes
                  ::= u <source-name>
*/

CP_STATIC_IF_GLIBCPP_V3
const struct demangle_builtin_type_info
cplus_demangle_builtin_types[D_BUILTIN_TYPE_COUNT] =
{
  /* a */ { NL ("signed char"),	NL ("signed char"),	D_PRINT_DEFAULT },
  /* b */ { NL ("bool"),	NL ("boolean"),		D_PRINT_BOOL },
  /* c */ { NL ("char"),	NL ("byte"),		D_PRINT_DEFAULT },
  /* d */ { NL ("double"),	NL ("double"),		D_PRINT_FLOAT },
  /* e */ { NL ("long double"),	NL ("long double"),	D_PRINT_FLOAT },
  /* f */ { NL ("float"),	NL ("float"),		D_PRINT_FLOAT },
  /* g */ { NL ("__float128"),	NL ("__float128"),	D_PRINT_FLOAT },
  /* h */ { NL ("unsigned char"), NL ("unsigned char"),	D_PRINT_DEFAULT },
  /* i */ { NL ("int"),		NL ("int"),		D_PRINT_INT },
  /* j */ { NL ("unsigned int"), NL ("unsigned"),	D_PRINT_UNSIGNED },
  /* k */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* l */ { NL ("long"),	NL ("long"),		D_PRINT_LONG },
  /* m */ { NL ("unsigned long"), NL ("unsigned long"),	D_PRINT_UNSIGNED_LONG },
  /* n */ { NL ("__int128"),	NL ("__int128"),	D_PRINT_DEFAULT },
  /* o */ { NL ("unsigned __int128"), NL ("unsigned __int128"),
	    D_PRINT_DEFAULT },
  /* p */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* q */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* r */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* s */ { NL ("short"),	NL ("short"),		D_PRINT_DEFAULT },
  /* t */ { NL ("unsigned short"), NL ("unsigned short"), D_PRINT_DEFAULT },
  /* u */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* v */ { NL ("void"),	NL ("void"),		D_PRINT_VOID },
  /* w */ { NL ("wchar_t"),	NL ("char"),		D_PRINT_DEFAULT },
  /* x */ { NL ("long long"),	NL ("long"),		D_PRINT_LONG_LONG },
  /* y */ { NL ("unsigned long long"), NL ("unsigned long long"),
	    D_PRINT_UNSIGNED_LONG_LONG },
  /* z */ { NL ("..."),		NL ("..."),		D_PRINT_DEFAULT },
  /* 26 */ { NL ("decimal32"),	NL ("decimal32"),	D_PRINT_DEFAULT },
  /* 27 */ { NL ("decimal64"),	NL ("decimal64"),	D_PRINT_DEFAULT },
  /* 28 */ { NL ("decimal128"),	NL ("decimal128"),	D_PRINT_DEFAULT },
  /* 29 */ { NL ("half"),	NL ("half"),		D_PRINT_FLOAT },
  /* 30 */ { NL ("char16_t"),	NL ("char16_t"),	D_PRINT_DEFAULT },
  /* 31 */ { NL ("char32_t"),	NL ("char32_t"),	D_PRINT_DEFAULT },
  /* 32 */ { NL ("decltype(nullptr)"),	NL ("decltype(nullptr)"),
	     D_PRINT_DEFAULT },
};

CP_STATIC_IF_GLIBCPP_V3
struct demangle_component *
cplus_demangle_type (struct d_info *di)
{
  char peek;
  struct demangle_component *ret;
  int can_subst;

  /* The ABI specifies that when CV-qualifiers are used, the base type
     is substitutable, and the fully qualified type is substitutable,
     but the base type with a strict subset of the CV-qualifiers is
     not substitutable.  The natural recursive implementation of the
     CV-qualifiers would cause subsets to be substitutable, so instead
     we pull them all off now.

     FIXME: The ABI says that order-insensitive vendor qualifiers
     should be handled in the same way, but we have no way to tell
     which vendor qualifiers are order-insensitive and which are
     order-sensitive.  So we just assume that they are all
     order-sensitive.  g++ 3.4 supports only one vendor qualifier,
     __vector, and it treats it as order-sensitive when mangling
     names.  */

  peek = d_peek_char (di);
  if (peek == 'r' || peek == 'V' || peek == 'K')
    {
      struct demangle_component **pret;

      pret = d_cv_qualifiers (di, &ret, 0);
      if (pret == NULL)
	return NULL;
      if (d_peek_char (di) == 'F')
	{
	  /* cv-qualifiers before a function type apply to 'this',
	     so avoid adding the unqualified function type to
	     the substitution list.  */
	  *pret = d_function_type (di);
	}
      else
	*pret = cplus_demangle_type (di);
      if (!*pret)
	return NULL;
      if ((*pret)->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS
	  || (*pret)->type == DEMANGLE_COMPONENT_REFERENCE_THIS)
	{
	  /* Move the ref-qualifier outside the cv-qualifiers so that
	     they are printed in the right order.  */
	  struct demangle_component *fn = d_left (*pret);
	  d_left (*pret) = ret;
	  ret = *pret;
	  *pret = fn;
	}
      if (! d_add_substitution (di, ret))
	return NULL;
      return ret;
    }

  can_subst = 1;

  switch (peek)
    {
    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':
    case 'h': case 'i': case 'j':           case 'l': case 'm': case 'n':
    case 'o':                               case 's': case 't':
    case 'v': case 'w': case 'x': case 'y': case 'z':
      ret = d_make_builtin_type (di,
				 &cplus_demangle_builtin_types[peek - 'a']);
      di->expansion += ret->u.s_builtin.type->len;
      can_subst = 0;
      d_advance (di, 1);
      break;

    case 'u':
      d_advance (di, 1);
      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE,
			 d_source_name (di), NULL);
      break;

    case 'F':
      ret = d_function_type (di);
      break;

    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    case 'N':
    case 'Z':
      ret = d_class_enum_type (di);
      break;

    case 'A':
      ret = d_array_type (di);
      break;

    case 'M':
      ret = d_pointer_to_member_type (di);
      break;

    case 'T':
      ret = d_template_param (di);
      if (d_peek_char (di) == 'I')
	{
	  /* This may be <template-template-param> <template-args>.
	     If this is the type for a conversion operator, we can
	     have a <template-template-param> here only by following
	     a derivation like this:

	     <nested-name>
	     -> <template-prefix> <template-args>
	     -> <prefix> <template-unqualified-name> <template-args>
	     -> <unqualified-name> <template-unqualified-name> <template-args>
	     -> <source-name> <template-unqualified-name> <template-args>
	     -> <source-name> <operator-name> <template-args>
	     -> <source-name> cv <type> <template-args>
	     -> <source-name> cv <template-template-param> <template-args> <template-args>

	     where the <template-args> is followed by another.
	     Otherwise, we must have a derivation like this:

	     <nested-name>
	     -> <template-prefix> <template-args>
	     -> <prefix> <template-unqualified-name> <template-args>
	     -> <unqualified-name> <template-unqualified-name> <template-args>
	     -> <source-name> <template-unqualified-name> <template-args>
	     -> <source-name> <operator-name> <template-args>
	     -> <source-name> cv <type> <template-args>
	     -> <source-name> cv <template-param> <template-args>

	     where we need to leave the <template-args> to be processed
	     by d_prefix (following the <template-prefix>).

	     The <template-template-param> part is a substitution
	     candidate.  */
	  if (! di->is_conversion)
	    {
	      if (! d_add_substitution (di, ret))
		return NULL;
	      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,
				 d_template_args (di));
	    }
	  else
	    {
	      struct demangle_component *args;
	      struct d_info_checkpoint checkpoint;

	      d_checkpoint (di, &checkpoint);
	      args = d_template_args (di);
	      if (d_peek_char (di) == 'I')
		{
		  if (! d_add_substitution (di, ret))
		    return NULL;
		  ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,
				     args);
		}
	      else
		d_backtrack (di, &checkpoint);
	    }
	}
      break;

    case 'S':
      /* If this is a special substitution, then it is the start of
	 <class-enum-type>.  */
      {
	char peek_next;

	peek_next = d_peek_next_char (di);
	if (IS_DIGIT (peek_next)
	    || peek_next == '_'
	    || IS_UPPER (peek_next))
	  {
	    ret = d_substitution (di, 0);
	    /* The substituted name may have been a template name and
	       may be followed by tepmlate args.  */
	    if (d_peek_char (di) == 'I')
	      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,
				 d_template_args (di));
	    else
	      can_subst = 0;
	  }
	else
	  {
	    ret = d_class_enum_type (di);
	    /* If the substitution was a complete type, then it is not
	       a new substitution candidate.  However, if the
	       substitution was followed by template arguments, then
	       the whole thing is a substitution candidate.  */
	    if (ret != NULL && ret->type == DEMANGLE_COMPONENT_SUB_STD)
	      can_subst = 0;
	  }
      }
      break;

    case 'O':
      d_advance (di, 1);
      ret = d_make_comp (di, DEMANGLE_COMPONENT_RVALUE_REFERENCE,
                         cplus_demangle_type (di), NULL);
      break;

    case 'P':
      d_advance (di, 1);
      ret = d_make_comp (di, DEMANGLE_COMPONENT_POINTER,
			 cplus_demangle_type (di), NULL);
      break;

    case 'R':
      d_advance (di, 1);
      ret = d_make_comp (di, DEMANGLE_COMPONENT_REFERENCE,
                         cplus_demangle_type (di), NULL);
      break;

    case 'C':
      d_advance (di, 1);
      ret = d_make_comp (di, DEMANGLE_COMPONENT_COMPLEX,
			 cplus_demangle_type (di), NULL);
      break;

    case 'G':
      d_advance (di, 1);
      ret = d_make_comp (di, DEMANGLE_COMPONENT_IMAGINARY,
			 cplus_demangle_type (di), NULL);
      break;

    case 'U':
      d_advance (di, 1);
      ret = d_source_name (di);
      if (d_peek_char (di) == 'I')
	ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,
			   d_template_args (di));
      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL,
			 cplus_demangle_type (di), ret);
      break;

    case 'D':
      can_subst = 0;
      d_advance (di, 1);
      peek = d_next_char (di);
      switch (peek)
	{
	case 'T':
	case 't':
	  /* decltype (expression) */
	  ret = d_make_comp (di, DEMANGLE_COMPONENT_DECLTYPE,
			     d_expression (di), NULL);
	  if (ret && d_next_char (di) != 'E')
	    ret = NULL;
	  can_subst = 1;
	  break;
	  
	case 'p':
	  /* Pack expansion.  */
	  ret = d_make_comp (di, DEMANGLE_COMPONENT_PACK_EXPANSION,
			     cplus_demangle_type (di), NULL);
	  can_subst = 1;
	  break;

	case 'a':
	  /* auto */
	  ret = d_make_name (di, "auto", 4);
	  break;
	  
	case 'f':
	  /* 32-bit decimal floating point */
	  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[26]);
	  di->expansion += ret->u.s_builtin.type->len;
	  break;
	case 'd':
	  /* 64-bit DFP */
	  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[27]);
	  di->expansion += ret->u.s_builtin.type->len;
	  break;
	case 'e':
	  /* 128-bit DFP */
	  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[28]);
	  di->expansion += ret->u.s_builtin.type->len;
	  break;
	case 'h':
	  /* 16-bit half-precision FP */
	  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[29]);
	  di->expansion += ret->u.s_builtin.type->len;
	  break;
	case 's':
	  /* char16_t */
	  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[30]);
	  di->expansion += ret->u.s_builtin.type->len;
	  break;
	case 'i':
	  /* char32_t */
	  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[31]);
	  di->expansion += ret->u.s_builtin.type->len;
	  break;

	case 'F':
	  /* Fixed point types. DF<int bits><length><fract bits><sat>  */
	  ret = d_make_empty (di);
	  ret->type = DEMANGLE_COMPONENT_FIXED_TYPE;
	  if ((ret->u.s_fixed.accum = IS_DIGIT (d_peek_char (di))))
	    /* For demangling we don't care about the bits.  */
	    d_number (di);
	  ret->u.s_fixed.length = cplus_demangle_type (di);
	  if (ret->u.s_fixed.length == NULL)
	    return NULL;
	  d_number (di);
	  peek = d_next_char (di);
	  ret->u.s_fixed.sat = (peek == 's');
	  break;

	case 'v':
	  ret = d_vector_type (di);
	  can_subst = 1;
	  break;

        case 'n':
          /* decltype(nullptr) */
	  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[32]);
	  di->expansion += ret->u.s_builtin.type->len;
	  break;

	default:
	  return NULL;
	}
      break;

    default:
      return NULL;
    }

  if (can_subst)
    {
      if (! d_add_substitution (di, ret))
	return NULL;
    }

  return ret;
}

/* <CV-qualifiers> ::= [r] [V] [K]  */

static struct demangle_component **
d_cv_qualifiers (struct d_info *di,
                 struct demangle_component **pret, int member_fn)
{
  struct demangle_component **pstart;
  char peek;

  pstart = pret;
  peek = d_peek_char (di);
  while (peek == 'r' || peek == 'V' || peek == 'K')
    {
      enum demangle_component_type t;

      d_advance (di, 1);
      if (peek == 'r')
	{
	  t = (member_fn
	       ? DEMANGLE_COMPONENT_RESTRICT_THIS
	       : DEMANGLE_COMPONENT_RESTRICT);
	  di->expansion += sizeof "restrict";
	}
      else if (peek == 'V')
	{
	  t = (member_fn
	       ? DEMANGLE_COMPONENT_VOLATILE_THIS
	       : DEMANGLE_COMPONENT_VOLATILE);
	  di->expansion += sizeof "volatile";
	}
      else
	{
	  t = (member_fn
	       ? DEMANGLE_COMPONENT_CONST_THIS
	       : DEMANGLE_COMPONENT_CONST);
	  di->expansion += sizeof "const";
	}

      *pret = d_make_comp (di, t, NULL, NULL);
      if (*pret == NULL)
	return NULL;
      pret = &d_left (*pret);

      peek = d_peek_char (di);
    }

  if (!member_fn && peek == 'F')
    {
      while (pstart != pret)
	{
	  switch ((*pstart)->type)
	    {
	    case DEMANGLE_COMPONENT_RESTRICT:
	      (*pstart)->type = DEMANGLE_COMPONENT_RESTRICT_THIS;
	      break;
	    case DEMANGLE_COMPONENT_VOLATILE:
	      (*pstart)->type = DEMANGLE_COMPONENT_VOLATILE_THIS;
	      break;
	    case DEMANGLE_COMPONENT_CONST:
	      (*pstart)->type = DEMANGLE_COMPONENT_CONST_THIS;
	      break;
	    default:
	      break;
	    }
	  pstart = &d_left (*pstart);
	}
    }

  return pret;
}

/* <ref-qualifier> ::= R
                   ::= O */

static struct demangle_component *
d_ref_qualifier (struct d_info *di, struct demangle_component *sub)
{
  struct demangle_component *ret = sub;
  char peek;

  peek = d_peek_char (di);
  if (peek == 'R' || peek == 'O')
    {
      enum demangle_component_type t;
      if (peek == 'R')
	{
	  t = DEMANGLE_COMPONENT_REFERENCE_THIS;
	  di->expansion += sizeof "&";
	}
      else
	{
	  t = DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS;
	  di->expansion += sizeof "&&";
	}
      d_advance (di, 1);

      ret = d_make_comp (di, t, ret, NULL);
    }

  return ret;
}

/* <function-type> ::= F [Y] <bare-function-type> [<ref-qualifier>] E  */

static struct demangle_component *
d_function_type (struct d_info *di)
{
  struct demangle_component *ret;

  if (! d_check_char (di, 'F'))
    return NULL;
  if (d_peek_char (di) == 'Y')
    {
      /* Function has C linkage.  We don't print this information.
	 FIXME: We should print it in verbose mode.  */
      d_advance (di, 1);
    }
  ret = d_bare_function_type (di, 1);
  ret = d_ref_qualifier (di, ret);

  if (! d_check_char (di, 'E'))
    return NULL;
  return ret;
}

/* <type>+ */

static struct demangle_component *
d_parmlist (struct d_info *di)
{
  struct demangle_component *tl;
  struct demangle_component **ptl;

  tl = NULL;
  ptl = &tl;
  while (1)
    {
      struct demangle_component *type;

      char peek = d_peek_char (di);
      if (peek == '\0' || peek == 'E' || peek == '.')
	break;
      if ((peek == 'R' || peek == 'O')
	  && d_peek_next_char (di) == 'E')
	/* Function ref-qualifier, not a ref prefix for a parameter type.  */
	break;
      type = cplus_demangle_type (di);
      if (type == NULL)
	return NULL;
      *ptl = d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, type, NULL);
      if (*ptl == NULL)
	return NULL;
      ptl = &d_right (*ptl);
    }

  /* There should be at least one parameter type besides the optional
     return type.  A function which takes no arguments will have a
     single parameter type void.  */
  if (tl == NULL)
    return NULL;

  /* If we have a single parameter type void, omit it.  */
  if (d_right (tl) == NULL
      && d_left (tl)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE
      && d_left (tl)->u.s_builtin.type->print == D_PRINT_VOID)
    {
      di->expansion -= d_left (tl)->u.s_builtin.type->len;
      d_left (tl) = NULL;
    }

  return tl;
}

/* <bare-function-type> ::= [J]<type>+  */

static struct demangle_component *
d_bare_function_type (struct d_info *di, int has_return_type)
{
  struct demangle_component *return_type;
  struct demangle_component *tl;
  char peek;

  /* Detect special qualifier indicating that the first argument
     is the return type.  */
  peek = d_peek_char (di);
  if (peek == 'J')
    {
      d_advance (di, 1);
      has_return_type = 1;
    }

  if (has_return_type)
    {
      return_type = cplus_demangle_type (di);
      if (return_type == NULL)
	return NULL;
    }
  else
    return_type = NULL;

  tl = d_parmlist (di);
  if (tl == NULL)
    return NULL;

  return d_make_comp (di, DEMANGLE_COMPONENT_FUNCTION_TYPE,
		      return_type, tl);
}

/* <class-enum-type> ::= <name>  */

static struct demangle_component *
d_class_enum_type (struct d_info *di)
{
  return d_name (di);
}

/* <array-type> ::= A <(positive dimension) number> _ <(element) type>
                ::= A [<(dimension) expression>] _ <(element) type>
*/

static struct demangle_component *
d_array_type (struct d_info *di)
{
  char peek;
  struct demangle_component *dim;

  if (! d_check_char (di, 'A'))
    return NULL;

  peek = d_peek_char (di);
  if (peek == '_')
    dim = NULL;
  else if (IS_DIGIT (peek))
    {
      const char *s;

      s = d_str (di);
      do
	{
	  d_advance (di, 1);
	  peek = d_peek_char (di);
	}
      while (IS_DIGIT (peek));
      dim = d_make_name (di, s, d_str (di) - s);
      if (dim == NULL)
	return NULL;
    }
  else
    {
      dim = d_expression (di);
      if (dim == NULL)
	return NULL;
    }

  if (! d_check_char (di, '_'))
    return NULL;

  return d_make_comp (di, DEMANGLE_COMPONENT_ARRAY_TYPE, dim,
		      cplus_demangle_type (di));
}

/* <vector-type> ::= Dv <number> _ <type>
                 ::= Dv _ <expression> _ <type> */

static struct demangle_component *
d_vector_type (struct d_info *di)
{
  char peek;
  struct demangle_component *dim;

  peek = d_peek_char (di);
  if (peek == '_')
    {
      d_advance (di, 1);
      dim = d_expression (di);
    }
  else
    dim = d_number_component (di);

  if (dim == NULL)
    return NULL;

  if (! d_check_char (di, '_'))
    return NULL;

  return d_make_comp (di, DEMANGLE_COMPONENT_VECTOR_TYPE, dim,
		      cplus_demangle_type (di));
}

/* <pointer-to-member-type> ::= M <(class) type> <(member) type>  */

static struct demangle_component *
d_pointer_to_member_type (struct d_info *di)
{
  struct demangle_component *cl;
  struct demangle_component *mem;

  if (! d_check_char (di, 'M'))
    return NULL;

  cl = cplus_demangle_type (di);
  if (cl == NULL)
    return NULL;

  /* The ABI says, "The type of a non-static member function is considered
     to be different, for the purposes of substitution, from the type of a
     namespace-scope or static member function whose type appears
     similar. The types of two non-static member functions are considered
     to be different, for the purposes of substitution, if the functions
     are members of different classes. In other words, for the purposes of
     substitution, the class of which the function is a member is
     considered part of the type of function."

     For a pointer to member function, this call to cplus_demangle_type
     will end up adding a (possibly qualified) non-member function type to
     the substitution table, which is not correct; however, the member
     function type will never be used in a substitution, so putting the
     wrong type in the substitution table is harmless.  */

  mem = cplus_demangle_type (di);
  if (mem == NULL)
    return NULL;

  return d_make_comp (di, DEMANGLE_COMPONENT_PTRMEM_TYPE, cl, mem);
}

/* <non-negative number> _ */

static long
d_compact_number (struct d_info *di)
{
  long num;
  if (d_peek_char (di) == '_')
    num = 0;
  else if (d_peek_char (di) == 'n')
    return -1;
  else
    num = d_number (di) + 1;

  if (! d_check_char (di, '_'))
    return -1;
  return num;
}

/* <template-param> ::= T_
                    ::= T <(parameter-2 non-negative) number> _
*/

static struct demangle_component *
d_template_param (struct d_info *di)
{
  long param;

  if (! d_check_char (di, 'T'))
    return NULL;

  param = d_compact_number (di);
  if (param < 0)
    return NULL;

  ++di->did_subs;

  return d_make_template_param (di, param);
}

/* <template-args> ::= I <template-arg>+ E  */

static struct demangle_component *
d_template_args (struct d_info *di)
{
  struct demangle_component *hold_last_name;
  struct demangle_component *al;
  struct demangle_component **pal;

  /* Preserve the last name we saw--don't let the template arguments
     clobber it, as that would give us the wrong name for a subsequent
     constructor or destructor.  */
  hold_last_name = di->last_name;

  if (d_peek_char (di) != 'I'
      && d_peek_char (di) != 'J')
    return NULL;
  d_advance (di, 1);

  if (d_peek_char (di) == 'E')
    {
      /* An argument pack can be empty.  */
      d_advance (di, 1);
      return d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, NULL, NULL);
    }

  al = NULL;
  pal = &al;
  while (1)
    {
      struct demangle_component *a;

      a = d_template_arg (di);
      if (a == NULL)
	return NULL;

      *pal = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, a, NULL);
      if (*pal == NULL)
	return NULL;
      pal = &d_right (*pal);

      if (d_peek_char (di) == 'E')
	{
	  d_advance (di, 1);
	  break;
	}
    }

  di->last_name = hold_last_name;

  return al;
}

/* <template-arg> ::= <type>
                  ::= X <expression> E
                  ::= <expr-primary>
*/

static struct demangle_component *
d_template_arg (struct d_info *di)
{
  struct demangle_component *ret;

  switch (d_peek_char (di))
    {
    case 'X':
      d_advance (di, 1);
      ret = d_expression (di);
      if (! d_check_char (di, 'E'))
	return NULL;
      return ret;

    case 'L':
      return d_expr_primary (di);

    case 'I':
    case 'J':
      /* An argument pack.  */
      return d_template_args (di);

    default:
      return cplus_demangle_type (di);
    }
}

/* Parse a sequence of expressions until we hit the terminator
   character.  */

static struct demangle_component *
d_exprlist (struct d_info *di, char terminator)
{
  struct demangle_component *list = NULL;
  struct demangle_component **p = &list;

  if (d_peek_char (di) == terminator)
    {
      d_advance (di, 1);
      return d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, NULL, NULL);
    }

  while (1)
    {
      struct demangle_component *arg = d_expression (di);
      if (arg == NULL)
	return NULL;

      *p = d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, arg, NULL);
      if (*p == NULL)
	return NULL;
      p = &d_right (*p);

      if (d_peek_char (di) == terminator)
	{
	  d_advance (di, 1);
	  break;
	}
    }

  return list;
}

/* Returns nonzero iff OP is an operator for a C++ cast: const_cast,
   dynamic_cast, static_cast or reinterpret_cast.  */

static int
op_is_new_cast (struct demangle_component *op)
{
  const char *code = op->u.s_operator.op->code;
  return (code[1] == 'c'
	  && (code[0] == 's' || code[0] == 'd'
	      || code[0] == 'c' || code[0] == 'r'));
}

/* <expression> ::= <(unary) operator-name> <expression>
                ::= <(binary) operator-name> <expression> <expression>
                ::= <(trinary) operator-name> <expression> <expression> <expression>
		::= cl <expression>+ E
                ::= st <type>
                ::= <template-param>
                ::= sr <type> <unqualified-name>
                ::= sr <type> <unqualified-name> <template-args>
                ::= <expr-primary>
*/

static inline struct demangle_component *
d_expression_1 (struct d_info *di)
{
  char peek;

  peek = d_peek_char (di);
  if (peek == 'L')
    return d_expr_primary (di);
  else if (peek == 'T')
    return d_template_param (di);
  else if (peek == 's' && d_peek_next_char (di) == 'r')
    {
      struct demangle_component *type;
      struct demangle_component *name;

      d_advance (di, 2);
      type = cplus_demangle_type (di);
      name = d_unqualified_name (di);
      if (d_peek_char (di) != 'I')
	return d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);
      else
	return d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type,
			    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,
					 d_template_args (di)));
    }
  else if (peek == 's' && d_peek_next_char (di) == 'p')
    {
      d_advance (di, 2);
      return d_make_comp (di, DEMANGLE_COMPONENT_PACK_EXPANSION,
			  d_expression_1 (di), NULL);
    }
  else if (peek == 'f' && d_peek_next_char (di) == 'p')
    {
      /* Function parameter used in a late-specified return type.  */
      int index;
      d_advance (di, 2);
      if (d_peek_char (di) == 'T')
	{
	  /* 'this' parameter.  */
	  d_advance (di, 1);
	  index = 0;
	}
      else
	{
	  index = d_compact_number (di) + 1;
	  if (index == 0)
	    return NULL;
	}
      return d_make_function_param (di, index);
    }
  else if (IS_DIGIT (peek)
	   || (peek == 'o' && d_peek_next_char (di) == 'n'))
    {
      /* We can get an unqualified name as an expression in the case of
         a dependent function call, i.e. decltype(f(t)).  */
      struct demangle_component *name;

      if (peek == 'o')
	/* operator-function-id, i.e. operator+(t).  */
	d_advance (di, 2);

      name = d_unqualified_name (di);
      if (name == NULL)
	return NULL;
      if (d_peek_char (di) == 'I')
	return d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,
			    d_template_args (di));
      else
	return name;
    }
  else if ((peek == 'i' || peek == 't')
	   && d_peek_next_char (di) == 'l')
    {
      /* Brace-enclosed initializer list, untyped or typed.  */
      struct demangle_component *type = NULL;
      if (peek == 't')
	type = cplus_demangle_type (di);
      d_advance (di, 2);
      return d_make_comp (di, DEMANGLE_COMPONENT_INITIALIZER_LIST,
			  type, d_exprlist (di, 'E'));
    }
  else
    {
      struct demangle_component *op;
      const char *code = NULL;
      int args;

      op = d_operator_name (di);
      if (op == NULL)
	return NULL;

      if (op->type == DEMANGLE_COMPONENT_OPERATOR)
	{
	  code = op->u.s_operator.op->code;
	  di->expansion += op->u.s_operator.op->len - 2;
	  if (strcmp (code, "st") == 0)
	    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
				cplus_demangle_type (di));
	}

      switch (op->type)
	{
	default:
	  return NULL;
	case DEMANGLE_COMPONENT_OPERATOR:
	  args = op->u.s_operator.op->args;
	  break;
	case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
	  args = op->u.s_extended_operator.args;
	  break;
	case DEMANGLE_COMPONENT_CAST:
	  args = 1;
	  break;
	}

      switch (args)
	{
	case 0:
	  return d_make_comp (di, DEMANGLE_COMPONENT_NULLARY, op, NULL);

	case 1:
	  {
	    struct demangle_component *operand;
	    int suffix = 0;

	    if (code && (code[0] == 'p' || code[0] == 'm')
		&& code[1] == code[0])
	      /* pp_ and mm_ are the prefix variants.  */
	      suffix = !d_check_char (di, '_');

	    if (op->type == DEMANGLE_COMPONENT_CAST
		&& d_check_char (di, '_'))
	      operand = d_exprlist (di, 'E');
	    else
	      operand = d_expression_1 (di);

	    if (suffix)
	      /* Indicate the suffix variant for d_print_comp.  */
	      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
				  d_make_comp (di,
					       DEMANGLE_COMPONENT_BINARY_ARGS,
					       operand, operand));
	    else
	      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
				  operand);
	  }
	case 2:
	  {
	    struct demangle_component *left;
	    struct demangle_component *right;

	    if (op_is_new_cast (op))
	      left = cplus_demangle_type (di);
	    else
	      left = d_expression_1 (di);
	    if (!strcmp (code, "cl"))
	      right = d_exprlist (di, 'E');
	    else if (!strcmp (code, "dt") || !strcmp (code, "pt"))
	      {
		right = d_unqualified_name (di);
		if (d_peek_char (di) == 'I')
		  right = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE,
				       right, d_template_args (di));
	      }
	    else
	      right = d_expression_1 (di);

	    return d_make_comp (di, DEMANGLE_COMPONENT_BINARY, op,
				d_make_comp (di,
					     DEMANGLE_COMPONENT_BINARY_ARGS,
					     left, right));
	  }
	case 3:
	  {
	    struct demangle_component *first;
	    struct demangle_component *second;
	    struct demangle_component *third;

	    if (!strcmp (code, "qu"))
	      {
		/* ?: expression.  */
		first = d_expression_1 (di);
		second = d_expression_1 (di);
		third = d_expression_1 (di);
	      }
	    else if (code[0] == 'n')
	      {
		/* new-expression.  */
		if (code[1] != 'w' && code[1] != 'a')
		  return NULL;
		first = d_exprlist (di, '_');
		second = cplus_demangle_type (di);
		if (d_peek_char (di) == 'E')
		  {
		    d_advance (di, 1);
		    third = NULL;
		  }
		else if (d_peek_char (di) == 'p'
			 && d_peek_next_char (di) == 'i')
		  {
		    /* Parenthesized initializer.  */
		    d_advance (di, 2);
		    third = d_exprlist (di, 'E');
		  }
		else if (d_peek_char (di) == 'i'
			 && d_peek_next_char (di) == 'l')
		  /* initializer-list.  */
		  third = d_expression_1 (di);
		else
		  return NULL;
	      }
	    else
	      return NULL;
	    return d_make_comp (di, DEMANGLE_COMPONENT_TRINARY, op,
				d_make_comp (di,
					     DEMANGLE_COMPONENT_TRINARY_ARG1,
					     first,
					     d_make_comp (di,
							  DEMANGLE_COMPONENT_TRINARY_ARG2,
							  second, third)));
	  }
	default:
	  return NULL;
	}
    }
}

static struct demangle_component *
d_expression (struct d_info *di)
{
  struct demangle_component *ret;
  int was_expression = di->is_expression;

  di->is_expression = 1;
  ret = d_expression_1 (di);
  di->is_expression = was_expression;
  return ret;
}

/* <expr-primary> ::= L <type> <(value) number> E
                  ::= L <type> <(value) float> E
                  ::= L <mangled-name> E
*/

static struct demangle_component *
d_expr_primary (struct d_info *di)
{
  struct demangle_component *ret;

  if (! d_check_char (di, 'L'))
    return NULL;
  if (d_peek_char (di) == '_'
      /* Workaround for G++ bug; see comment in write_template_arg.  */
      || d_peek_char (di) == 'Z')
    ret = cplus_demangle_mangled_name (di, 0);
  else
    {
      struct demangle_component *type;
      enum demangle_component_type t;
      const char *s;

      type = cplus_demangle_type (di);
      if (type == NULL)
	return NULL;

      /* If we have a type we know how to print, we aren't going to
	 print the type name itself.  */
      if (type->type == DEMANGLE_COMPONENT_BUILTIN_TYPE
	  && type->u.s_builtin.type->print != D_PRINT_DEFAULT)
	di->expansion -= type->u.s_builtin.type->len;

      /* Rather than try to interpret the literal value, we just
	 collect it as a string.  Note that it's possible to have a
	 floating point literal here.  The ABI specifies that the
	 format of such literals is machine independent.  That's fine,
	 but what's not fine is that versions of g++ up to 3.2 with
	 -fabi-version=1 used upper case letters in the hex constant,
	 and dumped out gcc's internal representation.  That makes it
	 hard to tell where the constant ends, and hard to dump the
	 constant in any readable form anyhow.  We don't attempt to
	 handle these cases.  */

      t = DEMANGLE_COMPONENT_LITERAL;
      if (d_peek_char (di) == 'n')
	{
	  t = DEMANGLE_COMPONENT_LITERAL_NEG;
	  d_advance (di, 1);
	}
      s = d_str (di);
      while (d_peek_char (di) != 'E')
	{
	  if (d_peek_char (di) == '\0')
	    return NULL;
	  d_advance (di, 1);
	}
      ret = d_make_comp (di, t, type, d_make_name (di, s, d_str (di) - s));
    }
  if (! d_check_char (di, 'E'))
    return NULL;
  return ret;
}

/* <local-name> ::= Z <(function) encoding> E <(entity) name> [<discriminator>]
                ::= Z <(function) encoding> E s [<discriminator>]
                ::= Z <(function) encoding> E d [<parameter> number>] _ <entity name>
*/

static struct demangle_component *
d_local_name (struct d_info *di)
{
  struct demangle_component *function;

  if (! d_check_char (di, 'Z'))
    return NULL;

  function = d_encoding (di, 0);

  if (! d_check_char (di, 'E'))
    return NULL;

  if (d_peek_char (di) == 's')
    {
      d_advance (di, 1);
      if (! d_discriminator (di))
	return NULL;
      return d_make_comp (di, DEMANGLE_COMPONENT_LOCAL_NAME, function,
			  d_make_name (di, "string literal",
				       sizeof "string literal" - 1));
    }
  else
    {
      struct demangle_component *name;
      int num = -1;

      if (d_peek_char (di) == 'd')
	{
	  /* Default argument scope: d <number> _.  */
	  d_advance (di, 1);
	  num = d_compact_number (di);
	  if (num < 0)
	    return NULL;
	}

      name = d_name (di);
      if (name)
	switch (name->type)
	  {
	    /* Lambdas and unnamed types have internal discriminators.  */
	  case DEMANGLE_COMPONENT_LAMBDA:
	  case DEMANGLE_COMPONENT_UNNAMED_TYPE:
	    break;
	  default:
	    if (! d_discriminator (di))
	      return NULL;
	  }
      if (num >= 0)
	name = d_make_default_arg (di, num, name);
      return d_make_comp (di, DEMANGLE_COMPONENT_LOCAL_NAME, function, name);
    }
}

/* <discriminator> ::= _ <(non-negative) number>

   We demangle the discriminator, but we don't print it out.  FIXME:
   We should print it out in verbose mode.  */

static int
d_discriminator (struct d_info *di)
{
  long discrim;

  if (d_peek_char (di) != '_')
    return 1;
  d_advance (di, 1);
  discrim = d_number (di);
  if (discrim < 0)
    return 0;
  return 1;
}

/* <closure-type-name> ::= Ul <lambda-sig> E [ <nonnegative number> ] _ */

static struct demangle_component *
d_lambda (struct d_info *di)
{
  struct demangle_component *tl;
  struct demangle_component *ret;
  int num;

  if (! d_check_char (di, 'U'))
    return NULL;
  if (! d_check_char (di, 'l'))
    return NULL;

  tl = d_parmlist (di);
  if (tl == NULL)
    return NULL;

  if (! d_check_char (di, 'E'))
    return NULL;

  num = d_compact_number (di);
  if (num < 0)
    return NULL;

  ret = d_make_empty (di);
  if (ret)
    {
      ret->type = DEMANGLE_COMPONENT_LAMBDA;
      ret->u.s_unary_num.sub = tl;
      ret->u.s_unary_num.num = num;
    }

  if (! d_add_substitution (di, ret))
    return NULL;

  return ret;
}

/* <unnamed-type-name> ::= Ut [ <nonnegative number> ] _ */

static struct demangle_component *
d_unnamed_type (struct d_info *di)
{
  struct demangle_component *ret;
  long num;

  if (! d_check_char (di, 'U'))
    return NULL;
  if (! d_check_char (di, 't'))
    return NULL;

  num = d_compact_number (di);
  if (num < 0)
    return NULL;

  ret = d_make_empty (di);
  if (ret)
    {
      ret->type = DEMANGLE_COMPONENT_UNNAMED_TYPE;
      ret->u.s_number.number = num;
    }

  if (! d_add_substitution (di, ret))
    return NULL;

  return ret;
}

/* <clone-suffix> ::= [ . <clone-type-identifier> ] [ . <nonnegative number> ]*
*/

static struct demangle_component *
d_clone_suffix (struct d_info *di, struct demangle_component *encoding)
{
  const char *suffix = d_str (di);
  const char *pend = suffix;
  struct demangle_component *n;

  if (*pend == '.' && (IS_LOWER (pend[1]) || pend[1] == '_'))
    {
      pend += 2;
      while (IS_LOWER (*pend) || *pend == '_')
	++pend;
    }
  while (*pend == '.' && IS_DIGIT (pend[1]))
    {
      pend += 2;
      while (IS_DIGIT (*pend))
	++pend;
    }
  d_advance (di, pend - suffix);
  n = d_make_name (di, suffix, pend - suffix);
  return d_make_comp (di, DEMANGLE_COMPONENT_CLONE, encoding, n);
}

/* Add a new substitution.  */

static int
d_add_substitution (struct d_info *di, struct demangle_component *dc)
{
  if (dc == NULL)
    return 0;
  if (di->next_sub >= di->num_subs)
    return 0;
  di->subs[di->next_sub] = dc;
  ++di->next_sub;
  return 1;
}

/* <substitution> ::= S <seq-id> _
                  ::= S_
                  ::= St
                  ::= Sa
                  ::= Sb
                  ::= Ss
                  ::= Si
                  ::= So
                  ::= Sd

   If PREFIX is non-zero, then this type is being used as a prefix in
   a qualified name.  In this case, for the standard substitutions, we
   need to check whether we are being used as a prefix for a
   constructor or destructor, and return a full template name.
   Otherwise we will get something like std::iostream::~iostream()
   which does not correspond particularly well to any function which
   actually appears in the source.
*/

static const struct d_standard_sub_info standard_subs[] =
{
  { 't', NL ("std"),
    NL ("std"),
    NULL, 0 },
  { 'a', NL ("std::allocator"),
    NL ("std::allocator"),
    NL ("allocator") },
  { 'b', NL ("std::basic_string"),
    NL ("std::basic_string"),
    NL ("basic_string") },
  { 's', NL ("std::string"),
    NL ("std::basic_string<char, std::char_traits<char>, std::allocator<char> >"),
    NL ("basic_string") },
  { 'i', NL ("std::istream"),
    NL ("std::basic_istream<char, std::char_traits<char> >"),
    NL ("basic_istream") },
  { 'o', NL ("std::ostream"),
    NL ("std::basic_ostream<char, std::char_traits<char> >"),
    NL ("basic_ostream") },
  { 'd', NL ("std::iostream"),
    NL ("std::basic_iostream<char, std::char_traits<char> >"),
    NL ("basic_iostream") }
};

static struct demangle_component *
d_substitution (struct d_info *di, int prefix)
{
  char c;

  if (! d_check_char (di, 'S'))
    return NULL;

  c = d_next_char (di);
  if (c == '_' || IS_DIGIT (c) || IS_UPPER (c))
    {
      unsigned int id;

      id = 0;
      if (c != '_')
	{
	  do
	    {
	      unsigned int new_id;

	      if (IS_DIGIT (c))
		new_id = id * 36 + c - '0';
	      else if (IS_UPPER (c))
		new_id = id * 36 + c - 'A' + 10;
	      else
		return NULL;
	      if (new_id < id)
		return NULL;
	      id = new_id;
	      c = d_next_char (di);
	    }
	  while (c != '_');

	  ++id;
	}

      if (id >= (unsigned int) di->next_sub)
	return NULL;

      ++di->did_subs;

      return di->subs[id];
    }
  else
    {
      int verbose;
      const struct d_standard_sub_info *p;
      const struct d_standard_sub_info *pend;

      verbose = (di->options & DMGL_VERBOSE) != 0;
      if (! verbose && prefix)
	{
	  char peek;

	  peek = d_peek_char (di);
	  if (peek == 'C' || peek == 'D')
	    verbose = 1;
	}

      pend = (&standard_subs[0]
	      + sizeof standard_subs / sizeof standard_subs[0]);
      for (p = &standard_subs[0]; p < pend; ++p)
	{
	  if (c == p->code)
	    {
	      const char *s;
	      int len;
	      struct demangle_component *c;

	      if (p->set_last_name != NULL)
		di->last_name = d_make_sub (di, p->set_last_name,
					    p->set_last_name_len);
	      if (verbose)
		{
		  s = p->full_expansion;
		  len = p->full_len;
		}
	      else
		{
		  s = p->simple_expansion;
		  len = p->simple_len;
		}
	      di->expansion += len;
	      c = d_make_sub (di, s, len);
	      if (d_peek_char (di) == 'B')
		{
		  /* If there are ABI tags on the abbreviation, it becomes
		     a substitution candidate.  */
		  c = d_abi_tags (di, c);
		  d_add_substitution (di, c);
		}
	      return c;
	    }
	}

      return NULL;
    }
}

static void
d_checkpoint (struct d_info *di, struct d_info_checkpoint *checkpoint)
{
  checkpoint->n = di->n;
  checkpoint->next_comp = di->next_comp;
  checkpoint->next_sub = di->next_sub;
  checkpoint->did_subs = di->did_subs;
  checkpoint->expansion = di->expansion;
}

static void
d_backtrack (struct d_info *di, struct d_info_checkpoint *checkpoint)
{
  di->n = checkpoint->n;
  di->next_comp = checkpoint->next_comp;
  di->next_sub = checkpoint->next_sub;
  di->did_subs = checkpoint->did_subs;
  di->expansion = checkpoint->expansion;
}

/* Initialize a growable string.  */

static void
d_growable_string_init (struct d_growable_string *dgs, size_t estimate)
{
  dgs->buf = NULL;
  dgs->len = 0;
  dgs->alc = 0;
  dgs->allocation_failure = 0;

  if (estimate > 0)
    d_growable_string_resize (dgs, estimate);
}

/* Grow a growable string to a given size.  */

static inline void
d_growable_string_resize (struct d_growable_string *dgs, size_t need)
{
  size_t newalc;
  char *newbuf;

  if (dgs->allocation_failure)
    return;

  /* Start allocation at two bytes to avoid any possibility of confusion
     with the special value of 1 used as a return in *palc to indicate
     allocation failures.  */
  newalc = dgs->alc > 0 ? dgs->alc : 2;
  while (newalc < need)
    newalc <<= 1;

  newbuf = (char *) realloc (dgs->buf, newalc);
  if (newbuf == NULL)
    {
      free (dgs->buf);
      dgs->buf = NULL;
      dgs->len = 0;
      dgs->alc = 0;
      dgs->allocation_failure = 1;
      return;
    }
  dgs->buf = newbuf;
  dgs->alc = newalc;
}

/* Append a buffer to a growable string.  */

static inline void
d_growable_string_append_buffer (struct d_growable_string *dgs,
                                 const char *s, size_t l)
{
  size_t need;

  need = dgs->len + l + 1;
  if (need > dgs->alc)
    d_growable_string_resize (dgs, need);

  if (dgs->allocation_failure)
    return;

  memcpy (dgs->buf + dgs->len, s, l);
  dgs->buf[dgs->len + l] = '\0';
  dgs->len += l;
}

/* Bridge growable strings to the callback mechanism.  */

static void
d_growable_string_callback_adapter (const char *s, size_t l, void *opaque)
{
  struct d_growable_string *dgs = (struct d_growable_string*) opaque;

  d_growable_string_append_buffer (dgs, s, l);
}

/* Walk the tree, counting the number of templates encountered, and
   the number of times a scope might be saved.  These counts will be
   used to allocate data structures for d_print_comp, so the logic
   here must mirror the logic d_print_comp will use.  It is not
   important that the resulting numbers are exact, so long as they
   are larger than the actual numbers encountered.  */

static void
d_count_templates_scopes (int *num_templates, int *num_scopes,
			  const struct demangle_component *dc)
{
  if (dc == NULL)
    return;

  switch (dc->type)
    {
    case DEMANGLE_COMPONENT_NAME:
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
    case DEMANGLE_COMPONENT_FUNCTION_PARAM:
    case DEMANGLE_COMPONENT_SUB_STD:
    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
    case DEMANGLE_COMPONENT_OPERATOR:
    case DEMANGLE_COMPONENT_CHARACTER:
    case DEMANGLE_COMPONENT_NUMBER:
    case DEMANGLE_COMPONENT_UNNAMED_TYPE:
      break;

    case DEMANGLE_COMPONENT_TEMPLATE:
      (*num_templates)++;
      goto recurse_left_right;

    case DEMANGLE_COMPONENT_REFERENCE:
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:
      if (d_left (dc)->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)
	(*num_scopes)++;
      goto recurse_left_right;

    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
    case DEMANGLE_COMPONENT_TYPED_NAME:
    case DEMANGLE_COMPONENT_VTABLE:
    case DEMANGLE_COMPONENT_VTT:
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
    case DEMANGLE_COMPONENT_TYPEINFO:
    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
    case DEMANGLE_COMPONENT_TYPEINFO_FN:
    case DEMANGLE_COMPONENT_THUNK:
    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
    case DEMANGLE_COMPONENT_JAVA_CLASS:
    case DEMANGLE_COMPONENT_GUARD:
    case DEMANGLE_COMPONENT_TLS_INIT:
    case DEMANGLE_COMPONENT_TLS_WRAPPER:
    case DEMANGLE_COMPONENT_REFTEMP:
    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
    case DEMANGLE_COMPONENT_REFERENCE_THIS:
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
    case DEMANGLE_COMPONENT_VECTOR_TYPE:
    case DEMANGLE_COMPONENT_ARGLIST:
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
    case DEMANGLE_COMPONENT_INITIALIZER_LIST:
    case DEMANGLE_COMPONENT_CAST:
    case DEMANGLE_COMPONENT_NULLARY:
    case DEMANGLE_COMPONENT_UNARY:
    case DEMANGLE_COMPONENT_BINARY:
    case DEMANGLE_COMPONENT_BINARY_ARGS:
    case DEMANGLE_COMPONENT_TRINARY:
    case DEMANGLE_COMPONENT_TRINARY_ARG1:
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
    case DEMANGLE_COMPONENT_LITERAL:
    case DEMANGLE_COMPONENT_LITERAL_NEG:
    case DEMANGLE_COMPONENT_JAVA_RESOURCE:
    case DEMANGLE_COMPONENT_COMPOUND_NAME:
    case DEMANGLE_COMPONENT_DECLTYPE:
    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:
    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:
    case DEMANGLE_COMPONENT_PACK_EXPANSION:
    case DEMANGLE_COMPONENT_TAGGED_NAME:
    case DEMANGLE_COMPONENT_CLONE:
    recurse_left_right:
      d_count_templates_scopes (num_templates, num_scopes,
				d_left (dc));
      d_count_templates_scopes (num_templates, num_scopes,
				d_right (dc));
      break;

    case DEMANGLE_COMPONENT_CTOR:
      d_count_templates_scopes (num_templates, num_scopes,
				dc->u.s_ctor.name);
      break;

    case DEMANGLE_COMPONENT_DTOR:
      d_count_templates_scopes (num_templates, num_scopes,
				dc->u.s_dtor.name);
      break;

    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
      d_count_templates_scopes (num_templates, num_scopes,
				dc->u.s_extended_operator.name);
      break;

    case DEMANGLE_COMPONENT_FIXED_TYPE:
      d_count_templates_scopes (num_templates, num_scopes,
                                dc->u.s_fixed.length);
      break;

    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:
    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:
      d_count_templates_scopes (num_templates, num_scopes,
				d_left (dc));
      break;

    case DEMANGLE_COMPONENT_LAMBDA:
    case DEMANGLE_COMPONENT_DEFAULT_ARG:
      d_count_templates_scopes (num_templates, num_scopes,
				dc->u.s_unary_num.sub);
      break;
    }
}

/* Initialize a print information structure.  */

static void
d_print_init (struct d_print_info *dpi, demangle_callbackref callback,
	      void *opaque, const struct demangle_component *dc)
{
  dpi->len = 0;
  dpi->last_char = '\0';
  dpi->templates = NULL;
  dpi->modifiers = NULL;
  dpi->pack_index = 0;
  dpi->flush_count = 0;

  dpi->callback = callback;
  dpi->opaque = opaque;

  dpi->demangle_failure = 0;

  dpi->component_stack = NULL;

  dpi->saved_scopes = NULL;
  dpi->next_saved_scope = 0;
  dpi->num_saved_scopes = 0;

  dpi->copy_templates = NULL;
  dpi->next_copy_template = 0;
  dpi->num_copy_templates = 0;

  d_count_templates_scopes (&dpi->num_copy_templates,
			    &dpi->num_saved_scopes, dc);
  dpi->num_copy_templates *= dpi->num_saved_scopes;

  dpi->current_template = NULL;
}

/* Indicate that an error occurred during printing, and test for error.  */

static inline void
d_print_error (struct d_print_info *dpi)
{
  dpi->demangle_failure = 1;
}

static inline int
d_print_saw_error (struct d_print_info *dpi)
{
  return dpi->demangle_failure != 0;
}

/* Flush buffered characters to the callback.  */

static inline void
d_print_flush (struct d_print_info *dpi)
{
  dpi->buf[dpi->len] = '\0';
  dpi->callback (dpi->buf, dpi->len, dpi->opaque);
  dpi->len = 0;
  dpi->flush_count++;
}

/* Append characters and buffers for printing.  */

static inline void
d_append_char (struct d_print_info *dpi, char c)
{
  if (dpi->len == sizeof (dpi->buf) - 1)
    d_print_flush (dpi);

  dpi->buf[dpi->len++] = c;
  dpi->last_char = c;
}

static inline void
d_append_buffer (struct d_print_info *dpi, const char *s, size_t l)
{
  size_t i;

  for (i = 0; i < l; i++)
    d_append_char (dpi, s[i]);
}

static inline void
d_append_string (struct d_print_info *dpi, const char *s)
{
  d_append_buffer (dpi, s, strlen (s));
}

static inline void
d_append_num (struct d_print_info *dpi, long l)
{
  char buf[25];
  sprintf (buf,"%ld", l);
  d_append_string (dpi, buf);
}

static inline char
d_last_char (struct d_print_info *dpi)
{
  return dpi->last_char;
}

/* Turn components into a human readable string.  OPTIONS is the
   options bits passed to the demangler.  DC is the tree to print.
   CALLBACK is a function to call to flush demangled string segments
   as they fill the intermediate buffer, and OPAQUE is a generalized
   callback argument.  On success, this returns 1.  On failure,
   it returns 0, indicating a bad parse.  It does not use heap
   memory to build an output string, so cannot encounter memory
   allocation failure.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_print_callback (int options,
                               const struct demangle_component *dc,
                               demangle_callbackref callback, void *opaque)
{
  struct d_print_info dpi;

  d_print_init (&dpi, callback, opaque, dc);

  {
#ifdef CP_DYNAMIC_ARRAYS
    __extension__ struct d_saved_scope scopes[dpi.num_saved_scopes];
    __extension__ struct d_print_template temps[dpi.num_copy_templates];

    dpi.saved_scopes = scopes;
    dpi.copy_templates = temps;
#else
    dpi.saved_scopes = alloca (dpi.num_saved_scopes
			       * sizeof (*dpi.saved_scopes));
    dpi.copy_templates = alloca (dpi.num_copy_templates
				 * sizeof (*dpi.copy_templates));
#endif

    d_print_comp (&dpi, options, dc);
  }

  d_print_flush (&dpi);

  return ! d_print_saw_error (&dpi);
}

/* Turn components into a human readable string.  OPTIONS is the
   options bits passed to the demangler.  DC is the tree to print.
   ESTIMATE is a guess at the length of the result.  This returns a
   string allocated by malloc, or NULL on error.  On success, this
   sets *PALC to the size of the allocated buffer.  On failure, this
   sets *PALC to 0 for a bad parse, or to 1 for a memory allocation
   failure.  */

CP_STATIC_IF_GLIBCPP_V3
char *
cplus_demangle_print (int options, const struct demangle_component *dc,
                      int estimate, size_t *palc)
{
  struct d_growable_string dgs;

  d_growable_string_init (&dgs, estimate);

  if (! cplus_demangle_print_callback (options, dc,
                                       d_growable_string_callback_adapter,
                                       &dgs))
    {
      free (dgs.buf);
      *palc = 0;
      return NULL;
    }

  *palc = dgs.allocation_failure ? 1 : dgs.alc;
  return dgs.buf;
}

/* Returns the I'th element of the template arglist ARGS, or NULL on
   failure.  */

static struct demangle_component *
d_index_template_argument (struct demangle_component *args, int i)
{
  struct demangle_component *a;

  for (a = args;
       a != NULL;
       a = d_right (a))
    {
      if (a->type != DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)
	return NULL;
      if (i <= 0)
	break;
      --i;
    }
  if (i != 0 || a == NULL)
    return NULL;

  return d_left (a);
}

/* Returns the template argument from the current context indicated by DC,
   which is a DEMANGLE_COMPONENT_TEMPLATE_PARAM, or NULL.  */

static struct demangle_component *
d_lookup_template_argument (struct d_print_info *dpi,
			    const struct demangle_component *dc)
{
  if (dpi->templates == NULL)
    {
      d_print_error (dpi);
      return NULL;
    }
	
  return d_index_template_argument
    (d_right (dpi->templates->template_decl),
     dc->u.s_number.number);
}

/* Returns a template argument pack used in DC (any will do), or NULL.  */

static struct demangle_component *
d_find_pack (struct d_print_info *dpi,
	     const struct demangle_component *dc)
{
  struct demangle_component *a;
  if (dc == NULL)
    return NULL;

  switch (dc->type)
    {
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
      a = d_lookup_template_argument (dpi, dc);
      if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)
	return a;
      return NULL;

    case DEMANGLE_COMPONENT_PACK_EXPANSION:
      return NULL;
      
    case DEMANGLE_COMPONENT_LAMBDA:
    case DEMANGLE_COMPONENT_NAME:
    case DEMANGLE_COMPONENT_TAGGED_NAME:
    case DEMANGLE_COMPONENT_OPERATOR:
    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
    case DEMANGLE_COMPONENT_SUB_STD:
    case DEMANGLE_COMPONENT_CHARACTER:
    case DEMANGLE_COMPONENT_FUNCTION_PARAM:
    case DEMANGLE_COMPONENT_UNNAMED_TYPE:
      return NULL;

    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
      return d_find_pack (dpi, dc->u.s_extended_operator.name);
    case DEMANGLE_COMPONENT_CTOR:
      return d_find_pack (dpi, dc->u.s_ctor.name);
    case DEMANGLE_COMPONENT_DTOR:
      return d_find_pack (dpi, dc->u.s_dtor.name);

    default:
      a = d_find_pack (dpi, d_left (dc));
      if (a)
	return a;
      return d_find_pack (dpi, d_right (dc));
    }
}

/* Returns the length of the template argument pack DC.  */

static int
d_pack_length (const struct demangle_component *dc)
{
  int count = 0;
  while (dc && dc->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST
	 && d_left (dc) != NULL)
    {
      ++count;
      dc = d_right (dc);
    }
  return count;
}

/* DC is a component of a mangled expression.  Print it, wrapped in parens
   if needed.  */

static void
d_print_subexpr (struct d_print_info *dpi, int options,
		 const struct demangle_component *dc)
{
  int simple = 0;
  if (dc->type == DEMANGLE_COMPONENT_NAME
      || dc->type == DEMANGLE_COMPONENT_QUAL_NAME
      || dc->type == DEMANGLE_COMPONENT_INITIALIZER_LIST
      || dc->type == DEMANGLE_COMPONENT_FUNCTION_PARAM)
    simple = 1;
  if (!simple)
    d_append_char (dpi, '(');
  d_print_comp (dpi, options, dc);
  if (!simple)
    d_append_char (dpi, ')');
}

/* Save the current scope.  */

static void
d_save_scope (struct d_print_info *dpi,
	      const struct demangle_component *container)
{
  struct d_saved_scope *scope;
  struct d_print_template *src, **link;

  if (dpi->next_saved_scope >= dpi->num_saved_scopes)
    {
      d_print_error (dpi);
      return;
    }
  scope = &dpi->saved_scopes[dpi->next_saved_scope];
  dpi->next_saved_scope++;

  scope->container = container;
  link = &scope->templates;

  for (src = dpi->templates; src != NULL; src = src->next)
    {
      struct d_print_template *dst;

      if (dpi->next_copy_template >= dpi->num_copy_templates)
	{
	  d_print_error (dpi);
	  return;
	}
      dst = &dpi->copy_templates[dpi->next_copy_template];
      dpi->next_copy_template++;

      dst->template_decl = src->template_decl;
      *link = dst;
      link = &dst->next;
    }

  *link = NULL;
}

/* Attempt to locate a previously saved scope.  Returns NULL if no
   corresponding saved scope was found.  */

static struct d_saved_scope *
d_get_saved_scope (struct d_print_info *dpi,
		   const struct demangle_component *container)
{
  int i;

  for (i = 0; i < dpi->next_saved_scope; i++)
    if (dpi->saved_scopes[i].container == container)
      return &dpi->saved_scopes[i];

  return NULL;
}

/* Subroutine to handle components.  */

static void
d_print_comp_inner (struct d_print_info *dpi, int options,
		  const struct demangle_component *dc)
{
  /* Magic variable to let reference smashing skip over the next modifier
     without needing to modify *dc.  */
  const struct demangle_component *mod_inner = NULL;

  /* Variable used to store the current templates while a previously
     captured scope is used.  */
  struct d_print_template *saved_templates;

  /* Nonzero if templates have been stored in the above variable.  */
  int need_template_restore = 0;

  if (dc == NULL)
    {
      d_print_error (dpi);
      return;
    }
  if (d_print_saw_error (dpi))
    return;

  switch (dc->type)
    {
    case DEMANGLE_COMPONENT_NAME:
      if ((options & DMGL_JAVA) == 0)
	d_append_buffer (dpi, dc->u.s_name.s, dc->u.s_name.len);
      else
	d_print_java_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);
      return;

    case DEMANGLE_COMPONENT_TAGGED_NAME:
      d_print_comp (dpi, options, d_left (dc));
      d_append_string (dpi, "[abi:");
      d_print_comp (dpi, options, d_right (dc));
      d_append_char (dpi, ']');
      return;

    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
      d_print_comp (dpi, options, d_left (dc));
      if ((options & DMGL_JAVA) == 0)
	d_append_string (dpi, "::");
      else
	d_append_char (dpi, '.');
      {
	struct demangle_component *local_name = d_right (dc);
	if (local_name->type == DEMANGLE_COMPONENT_DEFAULT_ARG)
	  {
	    d_append_string (dpi, "{default arg#");
	    d_append_num (dpi, local_name->u.s_unary_num.num + 1);
	    d_append_string (dpi, "}::");
	    local_name = local_name->u.s_unary_num.sub;
	  }
	d_print_comp (dpi, options, local_name);
      }
      return;

    case DEMANGLE_COMPONENT_TYPED_NAME:
      {
	struct d_print_mod *hold_modifiers;
	struct demangle_component *typed_name;
	struct d_print_mod adpm[4];
	unsigned int i;
	struct d_print_template dpt;

	/* Pass the name down to the type so that it can be printed in
	   the right place for the type.  We also have to pass down
	   any CV-qualifiers, which apply to the this parameter.  */
	hold_modifiers = dpi->modifiers;
	dpi->modifiers = 0;
	i = 0;
	typed_name = d_left (dc);
	while (typed_name != NULL)
	  {
	    if (i >= sizeof adpm / sizeof adpm[0])
	      {
		d_print_error (dpi);
		return;
	      }

	    adpm[i].next = dpi->modifiers;
	    dpi->modifiers = &adpm[i];
	    adpm[i].mod = typed_name;
	    adpm[i].printed = 0;
	    adpm[i].templates = dpi->templates;
	    ++i;

	    if (typed_name->type != DEMANGLE_COMPONENT_RESTRICT_THIS
		&& typed_name->type != DEMANGLE_COMPONENT_VOLATILE_THIS
		&& typed_name->type != DEMANGLE_COMPONENT_CONST_THIS
		&& typed_name->type != DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS
		&& typed_name->type != DEMANGLE_COMPONENT_REFERENCE_THIS)
	      break;

	    typed_name = d_left (typed_name);
	  }

	if (typed_name == NULL)
	  {
	    d_print_error (dpi);
	    return;
	  }

	/* If typed_name is a template, then it applies to the
	   function type as well.  */
	if (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)
	  {
	    dpt.next = dpi->templates;
	    dpi->templates = &dpt;
	    dpt.template_decl = typed_name;
	  }

	/* If typed_name is a DEMANGLE_COMPONENT_LOCAL_NAME, then
	   there may be CV-qualifiers on its right argument which
	   really apply here; this happens when parsing a class which
	   is local to a function.  */
	if (typed_name->type == DEMANGLE_COMPONENT_LOCAL_NAME)
	  {
	    struct demangle_component *local_name;

	    local_name = d_right (typed_name);
	    if (local_name->type == DEMANGLE_COMPONENT_DEFAULT_ARG)
	      local_name = local_name->u.s_unary_num.sub;
	    while (local_name->type == DEMANGLE_COMPONENT_RESTRICT_THIS
		   || local_name->type == DEMANGLE_COMPONENT_VOLATILE_THIS
		   || local_name->type == DEMANGLE_COMPONENT_CONST_THIS
		   || local_name->type == DEMANGLE_COMPONENT_REFERENCE_THIS
		   || (local_name->type
		       == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))
	      {
		if (i >= sizeof adpm / sizeof adpm[0])
		  {
		    d_print_error (dpi);
		    return;
		  }

		adpm[i] = adpm[i - 1];
		adpm[i].next = &adpm[i - 1];
		dpi->modifiers = &adpm[i];

		adpm[i - 1].mod = local_name;
		adpm[i - 1].printed = 0;
		adpm[i - 1].templates = dpi->templates;
		++i;

		local_name = d_left (local_name);
	      }
	  }

	d_print_comp (dpi, options, d_right (dc));

	if (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)
	  dpi->templates = dpt.next;

	/* If the modifiers didn't get printed by the type, print them
	   now.  */
	while (i > 0)
	  {
	    --i;
	    if (! adpm[i].printed)
	      {
		d_append_char (dpi, ' ');
		d_print_mod (dpi, options, adpm[i].mod);
	      }
	  }

	dpi->modifiers = hold_modifiers;

	return;
      }

    case DEMANGLE_COMPONENT_TEMPLATE:
      {
	struct d_print_mod *hold_dpm;
	struct demangle_component *dcl;
	const struct demangle_component *hold_current;

	/* This template may need to be referenced by a cast operator
	   contained in its subtree.  */
	hold_current = dpi->current_template;
	dpi->current_template = dc;

	/* Don't push modifiers into a template definition.  Doing so
	   could give the wrong definition for a template argument.
	   Instead, treat the template essentially as a name.  */

	hold_dpm = dpi->modifiers;
	dpi->modifiers = NULL;

        dcl = d_left (dc);

        if ((options & DMGL_JAVA) != 0
            && dcl->type == DEMANGLE_COMPONENT_NAME
            && dcl->u.s_name.len == 6
            && strncmp (dcl->u.s_name.s, "JArray", 6) == 0)
          {
            /* Special-case Java arrays, so that JArray<TYPE> appears
               instead as TYPE[].  */

            d_print_comp (dpi, options, d_right (dc));
            d_append_string (dpi, "[]");
          }
        else
          {
	    d_print_comp (dpi, options, dcl);
	    if (d_last_char (dpi) == '<')
	      d_append_char (dpi, ' ');
	    d_append_char (dpi, '<');
	    d_print_comp (dpi, options, d_right (dc));
	    /* Avoid generating two consecutive '>' characters, to avoid
	       the C++ syntactic ambiguity.  */
	    if (d_last_char (dpi) == '>')
	      d_append_char (dpi, ' ');
	    d_append_char (dpi, '>');
          }

	dpi->modifiers = hold_dpm;
	dpi->current_template = hold_current;

	return;
      }

    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
      {
	struct d_print_template *hold_dpt;
	struct demangle_component *a = d_lookup_template_argument (dpi, dc);

	if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)
	  a = d_index_template_argument (a, dpi->pack_index);

	if (a == NULL)
	  {
	    d_print_error (dpi);
	    return;
	  }

	/* While processing this parameter, we need to pop the list of
	   templates.  This is because the template parameter may
	   itself be a reference to a parameter of an outer
	   template.  */

	hold_dpt = dpi->templates;
	dpi->templates = hold_dpt->next;

	d_print_comp (dpi, options, a);

	dpi->templates = hold_dpt;

	return;
      }

    case DEMANGLE_COMPONENT_CTOR:
      d_print_comp (dpi, options, dc->u.s_ctor.name);
      return;

    case DEMANGLE_COMPONENT_DTOR:
      d_append_char (dpi, '~');
      d_print_comp (dpi, options, dc->u.s_dtor.name);
      return;

    case DEMANGLE_COMPONENT_VTABLE:
      d_append_string (dpi, "vtable for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_VTT:
      d_append_string (dpi, "VTT for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
      d_append_string (dpi, "construction vtable for ");
      d_print_comp (dpi, options, d_left (dc));
      d_append_string (dpi, "-in-");
      d_print_comp (dpi, options, d_right (dc));
      return;

    case DEMANGLE_COMPONENT_TYPEINFO:
      d_append_string (dpi, "typeinfo for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
      d_append_string (dpi, "typeinfo name for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_TYPEINFO_FN:
      d_append_string (dpi, "typeinfo fn for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_THUNK:
      d_append_string (dpi, "non-virtual thunk to ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
      d_append_string (dpi, "virtual thunk to ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
      d_append_string (dpi, "covariant return thunk to ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_JAVA_CLASS:
      d_append_string (dpi, "java Class for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_GUARD:
      d_append_string (dpi, "guard variable for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_TLS_INIT:
      d_append_string (dpi, "TLS init function for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_TLS_WRAPPER:
      d_append_string (dpi, "TLS wrapper function for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_REFTEMP:
      d_append_string (dpi, "reference temporary #");
      d_print_comp (dpi, options, d_right (dc));
      d_append_string (dpi, " for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:
      d_append_string (dpi, "hidden alias for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:
      d_append_string (dpi, "transaction clone for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:
      d_append_string (dpi, "non-transaction clone for ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_SUB_STD:
      d_append_buffer (dpi, dc->u.s_string.string, dc->u.s_string.len);
      return;

    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
      {
	struct d_print_mod *pdpm;

	/* When printing arrays, it's possible to have cases where the
	   same CV-qualifier gets pushed on the stack multiple times.
	   We only need to print it once.  */

	for (pdpm = dpi->modifiers; pdpm != NULL; pdpm = pdpm->next)
	  {
	    if (! pdpm->printed)
	      {
		if (pdpm->mod->type != DEMANGLE_COMPONENT_RESTRICT
		    && pdpm->mod->type != DEMANGLE_COMPONENT_VOLATILE
		    && pdpm->mod->type != DEMANGLE_COMPONENT_CONST)
		  break;
		if (pdpm->mod->type == dc->type)
		  {
		    d_print_comp (dpi, options, d_left (dc));
		    return;
		  }
	      }
	  }
      }
      goto modifier;

    case DEMANGLE_COMPONENT_REFERENCE:
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:
      {
	/* Handle reference smashing: & + && = &.  */
	const struct demangle_component *sub = d_left (dc);
	if (sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)
	  {
	    struct d_saved_scope *scope = d_get_saved_scope (dpi, sub);
	    struct demangle_component *a;

	    if (scope == NULL)
	      {
		/* This is the first time SUB has been traversed.
		   We need to capture the current templates so
		   they can be restored if SUB is reentered as a
		   substitution.  */
		d_save_scope (dpi, sub);
		if (d_print_saw_error (dpi))
		  return;
	      }
	    else
	      {
		const struct d_component_stack *dcse;
		int found_self_or_parent = 0;

		/* This traversal is reentering SUB as a substition.
		   If we are not beneath SUB or DC in the tree then we
		   need to restore SUB's template stack temporarily.  */
		for (dcse = dpi->component_stack; dcse != NULL;
		     dcse = dcse->parent)
		  {
		    if (dcse->dc == sub
			|| (dcse->dc == dc
			    && dcse != dpi->component_stack))
		      {
			found_self_or_parent = 1;
			break;
		      }
		  }

		if (!found_self_or_parent)
		  {
		    saved_templates = dpi->templates;
		    dpi->templates = scope->templates;
		    need_template_restore = 1;
		  }
	      }

	    a = d_lookup_template_argument (dpi, sub);
	    if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)
	      a = d_index_template_argument (a, dpi->pack_index);

	    if (a == NULL)
	      {
		if (need_template_restore)
		  dpi->templates = saved_templates;

		d_print_error (dpi);
		return;
	      }

	    sub = a;
	  }

	if (sub->type == DEMANGLE_COMPONENT_REFERENCE
	    || sub->type == dc->type)
	  dc = sub;
	else if (sub->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE)
	  mod_inner = d_left (sub);
      }
      /* Fall through.  */

    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
    case DEMANGLE_COMPONENT_REFERENCE_THIS:
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
    modifier:
      {
	/* We keep a list of modifiers on the stack.  */
	struct d_print_mod dpm;

	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;

	if (!mod_inner)
	  mod_inner = d_left (dc);

	d_print_comp (dpi, options, mod_inner);

	/* If the modifier didn't get printed by the type, print it
	   now.  */
	if (! dpm.printed)
	  d_print_mod (dpi, options, dc);

	dpi->modifiers = dpm.next;

	if (need_template_restore)
	  dpi->templates = saved_templates;

	return;
      }

    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
      if ((options & DMGL_JAVA) == 0)
	d_append_buffer (dpi, dc->u.s_builtin.type->name,
			 dc->u.s_builtin.type->len);
      else
	d_append_buffer (dpi, dc->u.s_builtin.type->java_name,
			 dc->u.s_builtin.type->java_len);
      return;

    case DEMANGLE_COMPONENT_VENDOR_TYPE:
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
      {
	if ((options & DMGL_RET_POSTFIX) != 0)
	  d_print_function_type (dpi,
				 options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
				 dc, dpi->modifiers);

	/* Print return type if present */
	if (d_left (dc) != NULL && (options & DMGL_RET_POSTFIX) != 0)
	  d_print_comp (dpi, options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
			d_left (dc));
	else if (d_left (dc) != NULL && (options & DMGL_RET_DROP) == 0)
	  {
	    struct d_print_mod dpm;

	    /* We must pass this type down as a modifier in order to
	       print it in the right location.  */
	    dpm.next = dpi->modifiers;
	    dpi->modifiers = &dpm;
	    dpm.mod = dc;
	    dpm.printed = 0;
	    dpm.templates = dpi->templates;

	    d_print_comp (dpi, options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
			  d_left (dc));

	    dpi->modifiers = dpm.next;

	    if (dpm.printed)
	      return;

	    /* In standard prefix notation, there is a space between the
	       return type and the function signature.  */
	    if ((options & DMGL_RET_POSTFIX) == 0)
	      d_append_char (dpi, ' ');
	  }

	if ((options & DMGL_RET_POSTFIX) == 0)
	  d_print_function_type (dpi,
				 options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
				 dc, dpi->modifiers);

	return;
      }

    case DEMANGLE_COMPONENT_ARRAY_TYPE:
      {
	struct d_print_mod *hold_modifiers;
	struct d_print_mod adpm[4];
	unsigned int i;
	struct d_print_mod *pdpm;

	/* We must pass this type down as a modifier in order to print
	   multi-dimensional arrays correctly.  If the array itself is
	   CV-qualified, we act as though the element type were
	   CV-qualified.  We do this by copying the modifiers down
	   rather than fiddling pointers, so that we don't wind up
	   with a d_print_mod higher on the stack pointing into our
	   stack frame after we return.  */

	hold_modifiers = dpi->modifiers;

	adpm[0].next = hold_modifiers;
	dpi->modifiers = &adpm[0];
	adpm[0].mod = dc;
	adpm[0].printed = 0;
	adpm[0].templates = dpi->templates;

	i = 1;
	pdpm = hold_modifiers;
	while (pdpm != NULL
	       && (pdpm->mod->type == DEMANGLE_COMPONENT_RESTRICT
		   || pdpm->mod->type == DEMANGLE_COMPONENT_VOLATILE
		   || pdpm->mod->type == DEMANGLE_COMPONENT_CONST))
	  {
	    if (! pdpm->printed)
	      {
		if (i >= sizeof adpm / sizeof adpm[0])
		  {
		    d_print_error (dpi);
		    return;
		  }

		adpm[i] = *pdpm;
		adpm[i].next = dpi->modifiers;
		dpi->modifiers = &adpm[i];
		pdpm->printed = 1;
		++i;
	      }

	    pdpm = pdpm->next;
	  }

	d_print_comp (dpi, options, d_right (dc));

	dpi->modifiers = hold_modifiers;

	if (adpm[0].printed)
	  return;

	while (i > 1)
	  {
	    --i;
	    d_print_mod (dpi, options, adpm[i].mod);
	  }

	d_print_array_type (dpi, options, dc, dpi->modifiers);

	return;
      }

    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
    case DEMANGLE_COMPONENT_VECTOR_TYPE:
      {
	struct d_print_mod dpm;

	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;

	d_print_comp (dpi, options, d_right (dc));

	/* If the modifier didn't get printed by the type, print it
	   now.  */
	if (! dpm.printed)
	  d_print_mod (dpi, options, dc);

	dpi->modifiers = dpm.next;

	return;
      }

    case DEMANGLE_COMPONENT_FIXED_TYPE:
      if (dc->u.s_fixed.sat)
	d_append_string (dpi, "_Sat ");
      /* Don't print "int _Accum".  */
      if (dc->u.s_fixed.length->u.s_builtin.type
	  != &cplus_demangle_builtin_types['i'-'a'])
	{
	  d_print_comp (dpi, options, dc->u.s_fixed.length);
	  d_append_char (dpi, ' ');
	}
      if (dc->u.s_fixed.accum)
	d_append_string (dpi, "_Accum");
      else
	d_append_string (dpi, "_Fract");
      return;

    case DEMANGLE_COMPONENT_ARGLIST:
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
      if (d_left (dc) != NULL)
	d_print_comp (dpi, options, d_left (dc));
      if (d_right (dc) != NULL)
	{
	  size_t len;
	  unsigned long int flush_count;
	  /* Make sure ", " isn't flushed by d_append_string, otherwise
	     dpi->len -= 2 wouldn't work.  */
	  if (dpi->len >= sizeof (dpi->buf) - 2)
	    d_print_flush (dpi);
	  d_append_string (dpi, ", ");
	  len = dpi->len;
	  flush_count = dpi->flush_count;
	  d_print_comp (dpi, options, d_right (dc));
	  /* If that didn't print anything (which can happen with empty
	     template argument packs), remove the comma and space.  */
	  if (dpi->flush_count == flush_count && dpi->len == len)
	    dpi->len -= 2;
	}
      return;

    case DEMANGLE_COMPONENT_INITIALIZER_LIST:
      {
	struct demangle_component *type = d_left (dc);
	struct demangle_component *list = d_right (dc);

	if (type)
	  d_print_comp (dpi, options, type);
	d_append_char (dpi, '{');
	d_print_comp (dpi, options, list);
	d_append_char (dpi, '}');
      }
      return;

    case DEMANGLE_COMPONENT_OPERATOR:
      {
	const struct demangle_operator_info *op = dc->u.s_operator.op;
	int len = op->len;

	d_append_string (dpi, "operator");
	/* Add a space before new/delete.  */
	if (IS_LOWER (op->name[0]))
	  d_append_char (dpi, ' ');
	/* Omit a trailing space.  */
	if (op->name[len-1] == ' ')
	  --len;
	d_append_buffer (dpi, op->name, len);
	return;
      }

    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
      d_append_string (dpi, "operator ");
      d_print_comp (dpi, options, dc->u.s_extended_operator.name);
      return;

    case DEMANGLE_COMPONENT_CAST:
      d_append_string (dpi, "operator ");
      d_print_cast (dpi, options, dc);
      return;

    case DEMANGLE_COMPONENT_NULLARY:
      d_print_expr_op (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_UNARY:
      {
	struct demangle_component *op = d_left (dc);
	struct demangle_component *operand = d_right (dc);
	const char *code = NULL;

	if (op->type == DEMANGLE_COMPONENT_OPERATOR)
	  {
	    code = op->u.s_operator.op->code;
	    if (!strcmp (code, "ad"))
	      {
		/* Don't print the argument list for the address of a
		   function.  */
		if (operand->type == DEMANGLE_COMPONENT_TYPED_NAME
		    && d_left (operand)->type == DEMANGLE_COMPONENT_QUAL_NAME
		    && d_right (operand)->type == DEMANGLE_COMPONENT_FUNCTION_TYPE)
		  operand = d_left (operand);
	      }
	    if (operand->type == DEMANGLE_COMPONENT_BINARY_ARGS)
	      {
		/* This indicates a suffix operator.  */
		operand = d_left (operand);
		d_print_subexpr (dpi, options, operand);
		d_print_expr_op (dpi, options, op);
		return;
	      }
	  }

	if (op->type != DEMANGLE_COMPONENT_CAST)
	  d_print_expr_op (dpi, options, op);
	else
	  {
	    d_append_char (dpi, '(');
	    d_print_cast (dpi, options, op);
	    d_append_char (dpi, ')');
	  }
	if (code && !strcmp (code, "gs"))
	  /* Avoid parens after '::'.  */
	  d_print_comp (dpi, options, operand);
	else if (code && !strcmp (code, "st"))
	  /* Always print parens for sizeof (type).  */
	  {
	    d_append_char (dpi, '(');
	    d_print_comp (dpi, options, operand);
	    d_append_char (dpi, ')');
	  }
	else
	  d_print_subexpr (dpi, options, operand);
      }
      return;

    case DEMANGLE_COMPONENT_BINARY:
      if (d_right (dc)->type != DEMANGLE_COMPONENT_BINARY_ARGS)
	{
	  d_print_error (dpi);
	  return;
	}

      if (op_is_new_cast (d_left (dc)))
	{
	  d_print_expr_op (dpi, options, d_left (dc));
	  d_append_char (dpi, '<');
	  d_print_comp (dpi, options, d_left (d_right (dc)));
	  d_append_string (dpi, ">(");
	  d_print_comp (dpi, options, d_right (d_right (dc)));
	  d_append_char (dpi, ')');
	  return;
	}

      /* We wrap an expression which uses the greater-than operator in
	 an extra layer of parens so that it does not get confused
	 with the '>' which ends the template parameters.  */
      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
	  && d_left (dc)->u.s_operator.op->len == 1
	  && d_left (dc)->u.s_operator.op->name[0] == '>')
	d_append_char (dpi, '(');

      if (strcmp (d_left (dc)->u.s_operator.op->code, "cl") == 0
          && d_left (d_right (dc))->type == DEMANGLE_COMPONENT_TYPED_NAME)
	{
	  /* Function call used in an expression should not have printed types
	     of the function arguments.  Values of the function arguments still
	     get printed below.  */

	  const struct demangle_component *func = d_left (d_right (dc));

	  if (d_right (func)->type != DEMANGLE_COMPONENT_FUNCTION_TYPE)
	    d_print_error (dpi);
	  d_print_subexpr (dpi, options, d_left (func));
	}
      else
	d_print_subexpr (dpi, options, d_left (d_right (dc)));
      if (strcmp (d_left (dc)->u.s_operator.op->code, "ix") == 0)
	{
	  d_append_char (dpi, '[');
	  d_print_comp (dpi, options, d_right (d_right (dc)));
	  d_append_char (dpi, ']');
	}
      else
	{
	  if (strcmp (d_left (dc)->u.s_operator.op->code, "cl") != 0)
	    d_print_expr_op (dpi, options, d_left (dc));
	  d_print_subexpr (dpi, options, d_right (d_right (dc)));
	}

      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
	  && d_left (dc)->u.s_operator.op->len == 1
	  && d_left (dc)->u.s_operator.op->name[0] == '>')
	d_append_char (dpi, ')');

      return;

    case DEMANGLE_COMPONENT_BINARY_ARGS:
      /* We should only see this as part of DEMANGLE_COMPONENT_BINARY.  */
      d_print_error (dpi);
      return;

    case DEMANGLE_COMPONENT_TRINARY:
      if (d_right (dc)->type != DEMANGLE_COMPONENT_TRINARY_ARG1
	  || d_right (d_right (dc))->type != DEMANGLE_COMPONENT_TRINARY_ARG2)
	{
	  d_print_error (dpi);
	  return;
	}
      {
	struct demangle_component *op = d_left (dc);
	struct demangle_component *first = d_left (d_right (dc));
	struct demangle_component *second = d_left (d_right (d_right (dc)));
	struct demangle_component *third = d_right (d_right (d_right (dc)));

	if (!strcmp (op->u.s_operator.op->code, "qu"))
	  {
	    d_print_subexpr (dpi, options, first);
	    d_print_expr_op (dpi, options, op);
	    d_print_subexpr (dpi, options, second);
	    d_append_string (dpi, " : ");
	    d_print_subexpr (dpi, options, third);
	  }
	else
	  {
	    d_append_string (dpi, "new ");
	    if (d_left (first) != NULL)
	      {
		d_print_subexpr (dpi, options, first);
		d_append_char (dpi, ' ');
	      }
	    d_print_comp (dpi, options, second);
	    if (third)
	      d_print_subexpr (dpi, options, third);
	  }
      }
      return;

    case DEMANGLE_COMPONENT_TRINARY_ARG1:
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
      /* We should only see these are part of DEMANGLE_COMPONENT_TRINARY.  */
      d_print_error (dpi);
      return;

    case DEMANGLE_COMPONENT_LITERAL:
    case DEMANGLE_COMPONENT_LITERAL_NEG:
      {
	enum d_builtin_type_print tp;

	/* For some builtin types, produce simpler output.  */
	tp = D_PRINT_DEFAULT;
	if (d_left (dc)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE)
	  {
	    tp = d_left (dc)->u.s_builtin.type->print;
	    switch (tp)
	      {
	      case D_PRINT_INT:
	      case D_PRINT_UNSIGNED:
	      case D_PRINT_LONG:
	      case D_PRINT_UNSIGNED_LONG:
	      case D_PRINT_LONG_LONG:
	      case D_PRINT_UNSIGNED_LONG_LONG:
		if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME)
		  {
		    if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
		      d_append_char (dpi, '-');
		    d_print_comp (dpi, options, d_right (dc));
		    switch (tp)
		      {
		      default:
			break;
		      case D_PRINT_UNSIGNED:
			d_append_char (dpi, 'u');
			break;
		      case D_PRINT_LONG:
			d_append_char (dpi, 'l');
			break;
		      case D_PRINT_UNSIGNED_LONG:
			d_append_string (dpi, "ul");
			break;
		      case D_PRINT_LONG_LONG:
			d_append_string (dpi, "ll");
			break;
		      case D_PRINT_UNSIGNED_LONG_LONG:
			d_append_string (dpi, "ull");
			break;
		      }
		    return;
		  }
		break;

	      case D_PRINT_BOOL:
		if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME
		    && d_right (dc)->u.s_name.len == 1
		    && dc->type == DEMANGLE_COMPONENT_LITERAL)
		  {
		    switch (d_right (dc)->u.s_name.s[0])
		      {
		      case '0':
			d_append_string (dpi, "false");
			return;
		      case '1':
			d_append_string (dpi, "true");
			return;
		      default:
			break;
		      }
		  }
		break;

	      default:
		break;
	      }
	  }

	d_append_char (dpi, '(');
	d_print_comp (dpi, options, d_left (dc));
	d_append_char (dpi, ')');
	if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
	  d_append_char (dpi, '-');
	if (tp == D_PRINT_FLOAT)
	  d_append_char (dpi, '[');
	d_print_comp (dpi, options, d_right (dc));
	if (tp == D_PRINT_FLOAT)
	  d_append_char (dpi, ']');
      }
      return;

    case DEMANGLE_COMPONENT_NUMBER:
      d_append_num (dpi, dc->u.s_number.number);
      return;

    case DEMANGLE_COMPONENT_JAVA_RESOURCE:
      d_append_string (dpi, "java resource ");
      d_print_comp (dpi, options, d_left (dc));
      return;

    case DEMANGLE_COMPONENT_COMPOUND_NAME:
      d_print_comp (dpi, options, d_left (dc));
      d_print_comp (dpi, options, d_right (dc));
      return;

    case DEMANGLE_COMPONENT_CHARACTER:
      d_append_char (dpi, dc->u.s_character.character);
      return;

    case DEMANGLE_COMPONENT_DECLTYPE:
      d_append_string (dpi, "decltype (");
      d_print_comp (dpi, options, d_left (dc));
      d_append_char (dpi, ')');
      return;

    case DEMANGLE_COMPONENT_PACK_EXPANSION:
      {
	int len;
	int i;
	struct demangle_component *a = d_find_pack (dpi, d_left (dc));
	if (a == NULL)
	  {
	    /* d_find_pack won't find anything if the only packs involved
	       in this expansion are function parameter packs; in that
	       case, just print the pattern and "...".  */
	    d_print_subexpr (dpi, options, d_left (dc));
	    d_append_string (dpi, "...");
	    return;
	  }

	len = d_pack_length (a);
	dc = d_left (dc);
	for (i = 0; i < len; ++i)
	  {
	    dpi->pack_index = i;
	    d_print_comp (dpi, options, dc);
	    if (i < len-1)
	      d_append_string (dpi, ", ");
	  }
      }
      return;

    case DEMANGLE_COMPONENT_FUNCTION_PARAM:
      {
	long num = dc->u.s_number.number;
	if (num == 0)
	  d_append_string (dpi, "this");
	else
	  {
	    d_append_string (dpi, "{parm#");
	    d_append_num (dpi, num);
	    d_append_char (dpi, '}');
	  }
      }
      return;

    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:
      d_append_string (dpi, "global constructors keyed to ");
      d_print_comp (dpi, options, dc->u.s_binary.left);
      return;

    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:
      d_append_string (dpi, "global destructors keyed to ");
      d_print_comp (dpi, options, dc->u.s_binary.left);
      return;

    case DEMANGLE_COMPONENT_LAMBDA:
      d_append_string (dpi, "{lambda(");
      d_print_comp (dpi, options, dc->u.s_unary_num.sub);
      d_append_string (dpi, ")#");
      d_append_num (dpi, dc->u.s_unary_num.num + 1);
      d_append_char (dpi, '}');
      return;

    case DEMANGLE_COMPONENT_UNNAMED_TYPE:
      d_append_string (dpi, "{unnamed type#");
      d_append_num (dpi, dc->u.s_number.number + 1);
      d_append_char (dpi, '}');
      return;

    case DEMANGLE_COMPONENT_CLONE:
      d_print_comp (dpi, options, d_left (dc));
      d_append_string (dpi, " [clone ");
      d_print_comp (dpi, options, d_right (dc));
      d_append_char (dpi, ']');
      return;

    default:
      d_print_error (dpi);
      return;
    }
}

static void
d_print_comp (struct d_print_info *dpi, int options,
	      const struct demangle_component *dc)
{
  struct d_component_stack self;

  self.dc = dc;
  self.parent = dpi->component_stack;
  dpi->component_stack = &self;

  d_print_comp_inner (dpi, options, dc);

  dpi->component_stack = self.parent;
}

/* Print a Java dentifier.  For Java we try to handle encoded extended
   Unicode characters.  The C++ ABI doesn't mention Unicode encoding,
   so we don't it for C++.  Characters are encoded as
   __U<hex-char>+_.  */

static void
d_print_java_identifier (struct d_print_info *dpi, const char *name, int len)
{
  const char *p;
  const char *end;

  end = name + len;
  for (p = name; p < end; ++p)
    {
      if (end - p > 3
	  && p[0] == '_'
	  && p[1] == '_'
	  && p[2] == 'U')
	{
	  unsigned long c;
	  const char *q;

	  c = 0;
	  for (q = p + 3; q < end; ++q)
	    {
	      int dig;

	      if (IS_DIGIT (*q))
		dig = *q - '0';
	      else if (*q >= 'A' && *q <= 'F')
		dig = *q - 'A' + 10;
	      else if (*q >= 'a' && *q <= 'f')
		dig = *q - 'a' + 10;
	      else
		break;

	      c = c * 16 + dig;
	    }
	  /* If the Unicode character is larger than 256, we don't try
	     to deal with it here.  FIXME.  */
	  if (q < end && *q == '_' && c < 256)
	    {
	      d_append_char (dpi, c);
	      p = q;
	      continue;
	    }
	}

      d_append_char (dpi, *p);
    }
}

/* Print a list of modifiers.  SUFFIX is 1 if we are printing
   qualifiers on this after printing a function.  */

static void
d_print_mod_list (struct d_print_info *dpi, int options,
                  struct d_print_mod *mods, int suffix)
{
  struct d_print_template *hold_dpt;

  if (mods == NULL || d_print_saw_error (dpi))
    return;

  if (mods->printed
      || (! suffix
	  && (mods->mod->type == DEMANGLE_COMPONENT_RESTRICT_THIS
	      || mods->mod->type == DEMANGLE_COMPONENT_VOLATILE_THIS
	      || mods->mod->type == DEMANGLE_COMPONENT_CONST_THIS
	      || mods->mod->type == DEMANGLE_COMPONENT_REFERENCE_THIS
	      || (mods->mod->type
		  == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))))
    {
      d_print_mod_list (dpi, options, mods->next, suffix);
      return;
    }

  mods->printed = 1;

  hold_dpt = dpi->templates;
  dpi->templates = mods->templates;

  if (mods->mod->type == DEMANGLE_COMPONENT_FUNCTION_TYPE)
    {
      d_print_function_type (dpi, options, mods->mod, mods->next);
      dpi->templates = hold_dpt;
      return;
    }
  else if (mods->mod->type == DEMANGLE_COMPONENT_ARRAY_TYPE)
    {
      d_print_array_type (dpi, options, mods->mod, mods->next);
      dpi->templates = hold_dpt;
      return;
    }
  else if (mods->mod->type == DEMANGLE_COMPONENT_LOCAL_NAME)
    {
      struct d_print_mod *hold_modifiers;
      struct demangle_component *dc;

      /* When this is on the modifier stack, we have pulled any
	 qualifiers off the right argument already.  Otherwise, we
	 print it as usual, but don't let the left argument see any
	 modifiers.  */

      hold_modifiers = dpi->modifiers;
      dpi->modifiers = NULL;
      d_print_comp (dpi, options, d_left (mods->mod));
      dpi->modifiers = hold_modifiers;

      if ((options & DMGL_JAVA) == 0)
	d_append_string (dpi, "::");
      else
	d_append_char (dpi, '.');

      dc = d_right (mods->mod);

      if (dc->type == DEMANGLE_COMPONENT_DEFAULT_ARG)
	{
	  d_append_string (dpi, "{default arg#");
	  d_append_num (dpi, dc->u.s_unary_num.num + 1);
	  d_append_string (dpi, "}::");
	  dc = dc->u.s_unary_num.sub;
	}

      while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS
	     || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS
	     || dc->type == DEMANGLE_COMPONENT_CONST_THIS
	     || dc->type == DEMANGLE_COMPONENT_REFERENCE_THIS
	     || dc->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)
	dc = d_left (dc);

      d_print_comp (dpi, options, dc);

      dpi->templates = hold_dpt;
      return;
    }

  d_print_mod (dpi, options, mods->mod);

  dpi->templates = hold_dpt;

  d_print_mod_list (dpi, options, mods->next, suffix);
}

/* Print a modifier.  */

static void
d_print_mod (struct d_print_info *dpi, int options,
             const struct demangle_component *mod)
{
  switch (mod->type)
    {
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
      d_append_string (dpi, " restrict");
      return;
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
      d_append_string (dpi, " volatile");
      return;
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_CONST_THIS:
      d_append_string (dpi, " const");
      return;
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
      d_append_char (dpi, ' ');
      d_print_comp (dpi, options, d_right (mod));
      return;
    case DEMANGLE_COMPONENT_POINTER:
      /* There is no pointer symbol in Java.  */
      if ((options & DMGL_JAVA) == 0)
	d_append_char (dpi, '*');
      return;
    case DEMANGLE_COMPONENT_REFERENCE_THIS:
      /* For the ref-qualifier, put a space before the &.  */
      d_append_char (dpi, ' ');
    case DEMANGLE_COMPONENT_REFERENCE:
      d_append_char (dpi, '&');
      return;
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
      d_append_char (dpi, ' ');
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:
      d_append_string (dpi, "&&");
      return;
    case DEMANGLE_COMPONENT_COMPLEX:
      d_append_string (dpi, "complex ");
      return;
    case DEMANGLE_COMPONENT_IMAGINARY:
      d_append_string (dpi, "imaginary ");
      return;
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
      if (d_last_char (dpi) != '(')
	d_append_char (dpi, ' ');
      d_print_comp (dpi, options, d_left (mod));
      d_append_string (dpi, "::*");
      return;
    case DEMANGLE_COMPONENT_TYPED_NAME:
      d_print_comp (dpi, options, d_left (mod));
      return;
    case DEMANGLE_COMPONENT_VECTOR_TYPE:
      d_append_string (dpi, " __vector(");
      d_print_comp (dpi, options, d_left (mod));
      d_append_char (dpi, ')');
      return;

    default:
      /* Otherwise, we have something that won't go back on the
	 modifier stack, so we can just print it.  */
      d_print_comp (dpi, options, mod);
      return;
    }
}

/* Print a function type, except for the return type.  */

static void
d_print_function_type (struct d_print_info *dpi, int options,
                       const struct demangle_component *dc,
                       struct d_print_mod *mods)
{
  int need_paren;
  int need_space;
  struct d_print_mod *p;
  struct d_print_mod *hold_modifiers;

  need_paren = 0;
  need_space = 0;
  for (p = mods; p != NULL; p = p->next)
    {
      if (p->printed)
	break;

      switch (p->mod->type)
	{
	case DEMANGLE_COMPONENT_POINTER:
	case DEMANGLE_COMPONENT_REFERENCE:
	case DEMANGLE_COMPONENT_RVALUE_REFERENCE:
	  need_paren = 1;
	  break;
	case DEMANGLE_COMPONENT_RESTRICT:
	case DEMANGLE_COMPONENT_VOLATILE:
	case DEMANGLE_COMPONENT_CONST:
	case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
	case DEMANGLE_COMPONENT_COMPLEX:
	case DEMANGLE_COMPONENT_IMAGINARY:
	case DEMANGLE_COMPONENT_PTRMEM_TYPE:
	  need_space = 1;
	  need_paren = 1;
	  break;
	case DEMANGLE_COMPONENT_RESTRICT_THIS:
	case DEMANGLE_COMPONENT_VOLATILE_THIS:
	case DEMANGLE_COMPONENT_CONST_THIS:
	case DEMANGLE_COMPONENT_REFERENCE_THIS:
	case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
	  break;
	default:
	  break;
	}
      if (need_paren)
	break;
    }

  if (need_paren)
    {
      if (! need_space)
	{
	  if (d_last_char (dpi) != '('
	      && d_last_char (dpi) != '*')
	    need_space = 1;
	}
      if (need_space && d_last_char (dpi) != ' ')
	d_append_char (dpi, ' ');
      d_append_char (dpi, '(');
    }

  hold_modifiers = dpi->modifiers;
  dpi->modifiers = NULL;

  d_print_mod_list (dpi, options, mods, 0);

  if (need_paren)
    d_append_char (dpi, ')');

  d_append_char (dpi, '(');

  if (d_right (dc) != NULL)
    d_print_comp (dpi, options, d_right (dc));

  d_append_char (dpi, ')');

  d_print_mod_list (dpi, options, mods, 1);

  dpi->modifiers = hold_modifiers;
}

/* Print an array type, except for the element type.  */

static void
d_print_array_type (struct d_print_info *dpi, int options,
                    const struct demangle_component *dc,
                    struct d_print_mod *mods)
{
  int need_space;

  need_space = 1;
  if (mods != NULL)
    {
      int need_paren;
      struct d_print_mod *p;

      need_paren = 0;
      for (p = mods; p != NULL; p = p->next)
	{
	  if (! p->printed)
	    {
	      if (p->mod->type == DEMANGLE_COMPONENT_ARRAY_TYPE)
		{
		  need_space = 0;
		  break;
		}
	      else
		{
		  need_paren = 1;
		  need_space = 1;
		  break;
		}
	    }
	}

      if (need_paren)
	d_append_string (dpi, " (");

      d_print_mod_list (dpi, options, mods, 0);

      if (need_paren)
	d_append_char (dpi, ')');
    }

  if (need_space)
    d_append_char (dpi, ' ');

  d_append_char (dpi, '[');

  if (d_left (dc) != NULL)
    d_print_comp (dpi, options, d_left (dc));

  d_append_char (dpi, ']');
}

/* Print an operator in an expression.  */

static void
d_print_expr_op (struct d_print_info *dpi, int options,
                 const struct demangle_component *dc)
{
  if (dc->type == DEMANGLE_COMPONENT_OPERATOR)
    d_append_buffer (dpi, dc->u.s_operator.op->name,
		     dc->u.s_operator.op->len);
  else
    d_print_comp (dpi, options, dc);
}

/* Print a cast.  */

static void
d_print_cast (struct d_print_info *dpi, int options,
              const struct demangle_component *dc)
{
  struct d_print_template dpt;

  /* For a cast operator, we need the template parameters from
     the enclosing template in scope for processing the type.  */
  if (dpi->current_template != NULL)
    {
      dpt.next = dpi->templates;
      dpi->templates = &dpt;
      dpt.template_decl = dpi->current_template;
    }

  if (d_left (dc)->type != DEMANGLE_COMPONENT_TEMPLATE)
    {
      d_print_comp (dpi, options, d_left (dc));
      if (dpi->current_template != NULL)
	dpi->templates = dpt.next;
    }
  else
    {
      d_print_comp (dpi, options, d_left (d_left (dc)));

      /* For a templated cast operator, we need to remove the template
	 parameters from scope after printing the operator name,
	 so we need to handle the template printing here.  */
      if (dpi->current_template != NULL)
	dpi->templates = dpt.next;

      if (d_last_char (dpi) == '<')
	d_append_char (dpi, ' ');
      d_append_char (dpi, '<');
      d_print_comp (dpi, options, d_right (d_left (dc)));
      /* Avoid generating two consecutive '>' characters, to avoid
	 the C++ syntactic ambiguity.  */
      if (d_last_char (dpi) == '>')
	d_append_char (dpi, ' ');
      d_append_char (dpi, '>');
    }
}

/* Initialize the information structure we use to pass around
   information.  */

CP_STATIC_IF_GLIBCPP_V3
void
cplus_demangle_init_info (const char *mangled, int options, size_t len,
                          struct d_info *di)
{
  di->s = mangled;
  di->send = mangled + len;
  di->options = options;

  di->n = mangled;

  /* We can not need more components than twice the number of chars in
     the mangled string.  Most components correspond directly to
     chars, but the ARGLIST types are exceptions.  */
  di->num_comps = 2 * len;
  di->next_comp = 0;

  /* Similarly, we can not need more substitutions than there are
     chars in the mangled string.  */
  di->num_subs = len;
  di->next_sub = 0;
  di->did_subs = 0;

  di->last_name = NULL;

  di->expansion = 0;
  di->is_expression = 0;
  di->is_conversion = 0;
}

/* Internal implementation for the demangler.  If MANGLED is a g++ v3 ABI
   mangled name, return strings in repeated callback giving the demangled
   name.  OPTIONS is the usual libiberty demangler options.  On success,
   this returns 1.  On failure, returns 0.  */

static int
d_demangle_callback (const char *mangled, int options,
                     demangle_callbackref callback, void *opaque)
{
  enum
    {
      DCT_TYPE,
      DCT_MANGLED,
      DCT_GLOBAL_CTORS,
      DCT_GLOBAL_DTORS
    }
  type;
  struct d_info di;
  struct demangle_component *dc;
  int status;

  if (mangled[0] == '_' && mangled[1] == 'Z')
    type = DCT_MANGLED;
  else if (strncmp (mangled, "_GLOBAL_", 8) == 0
	   && (mangled[8] == '.' || mangled[8] == '_' || mangled[8] == '$')
	   && (mangled[9] == 'D' || mangled[9] == 'I')
	   && mangled[10] == '_')
    type = mangled[9] == 'I' ? DCT_GLOBAL_CTORS : DCT_GLOBAL_DTORS;
  else
    {
      if ((options & DMGL_TYPES) == 0)
	return 0;
      type = DCT_TYPE;
    }

  cplus_demangle_init_info (mangled, options, strlen (mangled), &di);

  {
#ifdef CP_DYNAMIC_ARRAYS
    __extension__ struct demangle_component comps[di.num_comps];
    __extension__ struct demangle_component *subs[di.num_subs];

    di.comps = comps;
    di.subs = subs;
#else
    di.comps = alloca (di.num_comps * sizeof (*di.comps));
    di.subs = alloca (di.num_subs * sizeof (*di.subs));
#endif

    switch (type)
      {
      case DCT_TYPE:
	dc = cplus_demangle_type (&di);
	break;
      case DCT_MANGLED:
	dc = cplus_demangle_mangled_name (&di, 1);
	break;
      case DCT_GLOBAL_CTORS:
      case DCT_GLOBAL_DTORS:
	d_advance (&di, 11);
	dc = d_make_comp (&di,
			  (type == DCT_GLOBAL_CTORS
			   ? DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS
			   : DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS),
			  d_make_demangle_mangled_name (&di, d_str (&di)),
			  NULL);
	d_advance (&di, strlen (d_str (&di)));
	break;
      default:
	abort (); /* We have listed all the cases.  */
      }

    /* If DMGL_PARAMS is set, then if we didn't consume the entire
       mangled string, then we didn't successfully demangle it.  If
       DMGL_PARAMS is not set, we didn't look at the trailing
       parameters.  */
    if (((options & DMGL_PARAMS) != 0) && d_peek_char (&di) != '\0')
      dc = NULL;

#ifdef CP_DEMANGLE_DEBUG
    d_dump (dc, 0);
#endif

    status = (dc != NULL)
             ? cplus_demangle_print_callback (options, dc, callback, opaque)
             : 0;
  }

  return status;
}

/* Entry point for the demangler.  If MANGLED is a g++ v3 ABI mangled
   name, return a buffer allocated with malloc holding the demangled
   name.  OPTIONS is the usual libiberty demangler options.  On
   success, this sets *PALC to the allocated size of the returned
   buffer.  On failure, this sets *PALC to 0 for a bad name, or 1 for
   a memory allocation failure, and returns NULL.  */

static char *
d_demangle (const char *mangled, int options, size_t *palc)
{
  struct d_growable_string dgs;
  int status;

  d_growable_string_init (&dgs, 0);

  status = d_demangle_callback (mangled, options,
                                d_growable_string_callback_adapter, &dgs);
  if (status == 0)
    {
      free (dgs.buf);
      *palc = 0;
      return NULL;
    }

  *palc = dgs.allocation_failure ? 1 : dgs.alc;
  return dgs.buf;
}

#if defined(IN_LIBGCC2) || defined(IN_GLIBCPP_V3)

extern char *__cxa_demangle (const char *, char *, size_t *, int *);

/* ia64 ABI-mandated entry point in the C++ runtime library for
   performing demangling.  MANGLED_NAME is a NUL-terminated character
   string containing the name to be demangled.

   OUTPUT_BUFFER is a region of memory, allocated with malloc, of
   *LENGTH bytes, into which the demangled name is stored.  If
   OUTPUT_BUFFER is not long enough, it is expanded using realloc.
   OUTPUT_BUFFER may instead be NULL; in that case, the demangled name
   is placed in a region of memory allocated with malloc.

   If LENGTH is non-NULL, the length of the buffer containing the
   demangled name, is placed in *LENGTH.

   The return value is a pointer to the start of the NUL-terminated
   demangled name, or NULL if the demangling fails.  The caller is
   responsible for deallocating this memory using free.

   *STATUS is set to one of the following values:
      0: The demangling operation succeeded.
     -1: A memory allocation failure occurred.
     -2: MANGLED_NAME is not a valid name under the C++ ABI mangling rules.
     -3: One of the arguments is invalid.

   The demangling is performed using the C++ ABI mangling rules, with
   GNU extensions.  */

char *
__cxa_demangle (const char *mangled_name, char *output_buffer,
                size_t *length, int *status)
{
  char *demangled;
  size_t alc;

  if (mangled_name == NULL)
    {
      if (status != NULL)
	*status = -3;
      return NULL;
    }

  if (output_buffer != NULL && length == NULL)
    {
      if (status != NULL)
	*status = -3;
      return NULL;
    }

  demangled = d_demangle (mangled_name, DMGL_PARAMS | DMGL_TYPES, &alc);

  if (demangled == NULL)
    {
      if (status != NULL)
	{
	  if (alc == 1)
	    *status = -1;
	  else
	    *status = -2;
	}
      return NULL;
    }

  if (output_buffer == NULL)
    {
      if (length != NULL)
	*length = alc;
    }
  else
    {
      if (strlen (demangled) < *length)
	{
	  strcpy (output_buffer, demangled);
	  free (demangled);
	  demangled = output_buffer;
	}
      else
	{
	  free (output_buffer);
	  *length = alc;
	}
    }

  if (status != NULL)
    *status = 0;

  return demangled;
}

extern int __gcclibcxx_demangle_callback (const char *,
                                          void (*)
                                            (const char *, size_t, void *),
                                          void *);

/* Alternative, allocationless entry point in the C++ runtime library
   for performing demangling.  MANGLED_NAME is a NUL-terminated character
   string containing the name to be demangled.

   CALLBACK is a callback function, called with demangled string
   segments as demangling progresses; it is called at least once,
   but may be called more than once.  OPAQUE is a generalized pointer
   used as a callback argument.

   The return code is one of the following values, equivalent to
   the STATUS values of __cxa_demangle() (excluding -1, since this
   function performs no memory allocations):
      0: The demangling operation succeeded.
     -2: MANGLED_NAME is not a valid name under the C++ ABI mangling rules.
     -3: One of the arguments is invalid.

   The demangling is performed using the C++ ABI mangling rules, with
   GNU extensions.  */

int
__gcclibcxx_demangle_callback (const char *mangled_name,
                               void (*callback) (const char *, size_t, void *),
                               void *opaque)
{
  int status;

  if (mangled_name == NULL || callback == NULL)
    return -3;

  status = d_demangle_callback (mangled_name, DMGL_PARAMS | DMGL_TYPES,
                                callback, opaque);
  if (status == 0)
    return -2;

  return 0;
}

#else /* ! (IN_LIBGCC2 || IN_GLIBCPP_V3) */

/* Entry point for libiberty demangler.  If MANGLED is a g++ v3 ABI
   mangled name, return a buffer allocated with malloc holding the
   demangled name.  Otherwise, return NULL.  */

char *
cplus_demangle_v3 (const char *mangled, int options)
{
  size_t alc;

  return d_demangle (mangled, options, &alc);
}

int
cplus_demangle_v3_callback (const char *mangled, int options,
                            demangle_callbackref callback, void *opaque)
{
  return d_demangle_callback (mangled, options, callback, opaque);
}

/* Demangle a Java symbol.  Java uses a subset of the V3 ABI C++ mangling 
   conventions, but the output formatting is a little different.
   This instructs the C++ demangler not to emit pointer characters ("*"), to
   use Java's namespace separator symbol ("." instead of "::"), and to output
   JArray<TYPE> as TYPE[].  */

char *
java_demangle_v3 (const char *mangled)
{
  size_t alc;

  return d_demangle (mangled, DMGL_JAVA | DMGL_PARAMS | DMGL_RET_POSTFIX, &alc);
}

int
java_demangle_v3_callback (const char *mangled,
                           demangle_callbackref callback, void *opaque)
{
  return d_demangle_callback (mangled,
                              DMGL_JAVA | DMGL_PARAMS | DMGL_RET_POSTFIX,
                              callback, opaque);
}

#endif /* IN_LIBGCC2 || IN_GLIBCPP_V3 */

#ifndef IN_GLIBCPP_V3

/* Demangle a string in order to find out whether it is a constructor
   or destructor.  Return non-zero on success.  Set *CTOR_KIND and
   *DTOR_KIND appropriately.  */

static int
is_ctor_or_dtor (const char *mangled,
                 enum gnu_v3_ctor_kinds *ctor_kind,
                 enum gnu_v3_dtor_kinds *dtor_kind)
{
  struct d_info di;
  struct demangle_component *dc;
  int ret;

  *ctor_kind = (enum gnu_v3_ctor_kinds) 0;
  *dtor_kind = (enum gnu_v3_dtor_kinds) 0;

  cplus_demangle_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di);

  {
#ifdef CP_DYNAMIC_ARRAYS
    __extension__ struct demangle_component comps[di.num_comps];
    __extension__ struct demangle_component *subs[di.num_subs];

    di.comps = comps;
    di.subs = subs;
#else
    di.comps = alloca (di.num_comps * sizeof (*di.comps));
    di.subs = alloca (di.num_subs * sizeof (*di.subs));
#endif

    dc = cplus_demangle_mangled_name (&di, 1);

    /* Note that because we did not pass DMGL_PARAMS, we don't expect
       to demangle the entire string.  */

    ret = 0;
    while (dc != NULL)
      {
	switch (dc->type)
	  {
	    /* These cannot appear on a constructor or destructor.  */
	  case DEMANGLE_COMPONENT_RESTRICT_THIS:
	  case DEMANGLE_COMPONENT_VOLATILE_THIS:
	  case DEMANGLE_COMPONENT_CONST_THIS:
	  case DEMANGLE_COMPONENT_REFERENCE_THIS:
	  case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
	  default:
	    dc = NULL;
	    break;
	  case DEMANGLE_COMPONENT_TYPED_NAME:
	  case DEMANGLE_COMPONENT_TEMPLATE:
	    dc = d_left (dc);
	    break;
	  case DEMANGLE_COMPONENT_QUAL_NAME:
	  case DEMANGLE_COMPONENT_LOCAL_NAME:
	    dc = d_right (dc);
	    break;
	  case DEMANGLE_COMPONENT_CTOR:
	    *ctor_kind = dc->u.s_ctor.kind;
	    ret = 1;
	    dc = NULL;
	    break;
	  case DEMANGLE_COMPONENT_DTOR:
	    *dtor_kind = dc->u.s_dtor.kind;
	    ret = 1;
	    dc = NULL;
	    break;
	  }
      }
  }

  return ret;
}

/* Return whether NAME is the mangled form of a g++ V3 ABI constructor
   name.  A non-zero return indicates the type of constructor.  */

enum gnu_v3_ctor_kinds
is_gnu_v3_mangled_ctor (const char *name)
{
  enum gnu_v3_ctor_kinds ctor_kind;
  enum gnu_v3_dtor_kinds dtor_kind;

  if (! is_ctor_or_dtor (name, &ctor_kind, &dtor_kind))
    return (enum gnu_v3_ctor_kinds) 0;
  return ctor_kind;
}


/* Return whether NAME is the mangled form of a g++ V3 ABI destructor
   name.  A non-zero return indicates the type of destructor.  */

enum gnu_v3_dtor_kinds
is_gnu_v3_mangled_dtor (const char *name)
{
  enum gnu_v3_ctor_kinds ctor_kind;
  enum gnu_v3_dtor_kinds dtor_kind;

  if (! is_ctor_or_dtor (name, &ctor_kind, &dtor_kind))
    return (enum gnu_v3_dtor_kinds) 0;
  return dtor_kind;
}

#endif /* IN_GLIBCPP_V3 */

#ifdef STANDALONE_DEMANGLER

#include "getopt.h"
#include "dyn-string.h"

static void print_usage (FILE* fp, int exit_value);

#define IS_ALPHA(CHAR)                                                  \
  (((CHAR) >= 'a' && (CHAR) <= 'z')                                     \
   || ((CHAR) >= 'A' && (CHAR) <= 'Z'))

/* Non-zero if CHAR is a character than can occur in a mangled name.  */
#define is_mangled_char(CHAR)                                           \
  (IS_ALPHA (CHAR) || IS_DIGIT (CHAR)                                   \
   || (CHAR) == '_' || (CHAR) == '.' || (CHAR) == '$')

/* The name of this program, as invoked.  */
const char* program_name;

/* Prints usage summary to FP and then exits with EXIT_VALUE.  */

static void
print_usage (FILE* fp, int exit_value)
{
  fprintf (fp, "Usage: %s [options] [names ...]\n", program_name);
  fprintf (fp, "Options:\n");
  fprintf (fp, "  -h,--help       Display this message.\n");
  fprintf (fp, "  -p,--no-params  Don't display function parameters\n");
  fprintf (fp, "  -v,--verbose    Produce verbose demanglings.\n");
  fprintf (fp, "If names are provided, they are demangled.  Otherwise filters standard input.\n");

  exit (exit_value);
}

/* Option specification for getopt_long.  */
static const struct option long_options[] = 
{
  { "help",	 no_argument, NULL, 'h' },
  { "no-params", no_argument, NULL, 'p' },
  { "verbose",   no_argument, NULL, 'v' },
  { NULL,        no_argument, NULL, 0   },
};

/* Main entry for a demangling filter executable.  It will demangle
   its command line arguments, if any.  If none are provided, it will
   filter stdin to stdout, replacing any recognized mangled C++ names
   with their demangled equivalents.  */

int
main (int argc, char *argv[])
{
  int i;
  int opt_char;
  int options = DMGL_PARAMS | DMGL_ANSI | DMGL_TYPES;

  /* Use the program name of this program, as invoked.  */
  program_name = argv[0];

  /* Parse options.  */
  do 
    {
      opt_char = getopt_long (argc, argv, "hpv", long_options, NULL);
      switch (opt_char)
	{
	case '?':  /* Unrecognized option.  */
	  print_usage (stderr, 1);
	  break;

	case 'h':
	  print_usage (stdout, 0);
	  break;

	case 'p':
	  options &= ~ DMGL_PARAMS;
	  break;

	case 'v':
	  options |= DMGL_VERBOSE;
	  break;
	}
    }
  while (opt_char != -1);

  if (optind == argc) 
    /* No command line arguments were provided.  Filter stdin.  */
    {
      dyn_string_t mangled = dyn_string_new (3);
      char *s;

      /* Read all of input.  */
      while (!feof (stdin))
	{
	  char c;

	  /* Pile characters into mangled until we hit one that can't
	     occur in a mangled name.  */
	  c = getchar ();
	  while (!feof (stdin) && is_mangled_char (c))
	    {
	      dyn_string_append_char (mangled, c);
	      if (feof (stdin))
		break;
	      c = getchar ();
	    }

	  if (dyn_string_length (mangled) > 0)
	    {
#ifdef IN_GLIBCPP_V3
	      s = __cxa_demangle (dyn_string_buf (mangled), NULL, NULL, NULL);
#else
	      s = cplus_demangle_v3 (dyn_string_buf (mangled), options);
#endif

	      if (s != NULL)
		{
		  fputs (s, stdout);
		  free (s);
		}
	      else
		{
		  /* It might not have been a mangled name.  Print the
		     original text.  */
		  fputs (dyn_string_buf (mangled), stdout);
		}

	      dyn_string_clear (mangled);
	    }

	  /* If we haven't hit EOF yet, we've read one character that
	     can't occur in a mangled name, so print it out.  */
	  if (!feof (stdin))
	    putchar (c);
	}

      dyn_string_delete (mangled);
    }
  else
    /* Demangle command line arguments.  */
    {
      /* Loop over command line arguments.  */
      for (i = optind; i < argc; ++i)
	{
	  char *s;
#ifdef IN_GLIBCPP_V3
	  int status;
#endif

	  /* Attempt to demangle.  */
#ifdef IN_GLIBCPP_V3
	  s = __cxa_demangle (argv[i], NULL, NULL, &status);
#else
	  s = cplus_demangle_v3 (argv[i], options);
#endif

	  /* If it worked, print the demangled name.  */
	  if (s != NULL)
	    {
	      printf ("%s\n", s);
	      free (s);
	    }
	  else
	    {
#ifdef IN_GLIBCPP_V3
	      fprintf (stderr, "Failed: %s (status %d)\n", argv[i], status);
#else
	      fprintf (stderr, "Failed: %s\n", argv[i]);
#endif
	    }
	}
    }

  return 0;
}

#endif /* STANDALONE_DEMANGLER */
@


1.124
log
@merge from gcc
@
text
@d2473 3
@


1.123
log
@merge from gcc
@
text
@d3690 1
d3706 9
a3714 1
	      return d_make_sub (di, s, len);
@


1.122
log
@merge from gcc
@
text
@d716 3
a718 1
      printf ("fixed-point type\n");
a3879 1
    case DEMANGLE_COMPONENT_FIXED_TYPE:
d3924 5
@


1.121
log
@merge from gcc
@
text
@d578 3
d766 3
@


1.120
log
@merge from gcc
@
text
@d278 10
d340 2
d3949 2
d4286 2
a4287 2
d_print_comp (struct d_print_info *dpi, int options,
              const struct demangle_component *dc)
d4690 3
d4694 20
a4713 4
		   Restore the original templates temporarily.  */
		saved_templates = dpi->templates;
		dpi->templates = scope->templates;
		need_template_restore = 1;
d5352 15
@


1.119
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d5827 2
@


1.118
log
@merge from gcc
@
text
@d332 2
d336 6
d486 2
a487 1
d_print_init (struct d_print_info *, demangle_callbackref, void *);
d3789 130
d3923 1
a3923 1
	      void *opaque)
d3938 1
a3939 2
  dpi->current_template = NULL;
}
d3941 7
a3947 1
/* Free a print information structure.  */
d3949 1
a3949 17
static void
d_print_free (struct d_print_info *dpi)
{
  int i;

  for (i = 0; i < dpi->num_saved_scopes; i++)
    {
      struct d_print_template *ts, *tn;

      for (ts = dpi->saved_scopes[i].templates; ts != NULL; ts = tn)
	{
	  tn = ts->next;
	  free (ts);
	}
    }

  free (dpi->saved_scopes);
a4033 1
  int success;
d4035 15
a4049 1
  d_print_init (&dpi, callback, opaque);
d4051 2
a4052 1
  d_print_comp (&dpi, options, dc);
d4056 1
a4056 3
  success = ! d_print_saw_error (&dpi);
  d_print_free (&dpi);
  return success;
d4213 1
a4213 3
/* Return a shallow copy of the current list of templates.
   On error d_print_error is called and a partial list may
   be returned.  Whatever is returned must be freed.  */
d4215 3
a4217 2
static struct d_print_template *
d_copy_templates (struct d_print_info *dpi)
d4219 13
a4231 1
  struct d_print_template *src, *result, **link = &result;
d4235 1
a4235 2
      struct d_print_template *dst =
	(struct d_print_template *) malloc (sizeof (struct d_print_template));
d4237 1
a4237 1
      if (dst == NULL)
d4240 1
a4240 1
	  break;
d4242 2
d4251 10
d4262 5
a4266 1
  return result;
d4661 1
a4662 6
	    struct d_saved_scope *scope = NULL, *scopes;
	    int i;

	    for (i = 0; i < dpi->num_saved_scopes; i++)
	      if (dpi->saved_scopes[i].container == sub)
		scope = &dpi->saved_scopes[i];
a4665 2
		size_t size;

d4670 1
a4670 15
		++dpi->num_saved_scopes;
		size = sizeof (struct d_saved_scope) * dpi->num_saved_scopes;
		scopes = (struct d_saved_scope *) realloc (dpi->saved_scopes,
							   size);
		if (scopes == NULL)
		  {
		    d_print_error (dpi);
		    return;
		  }

		dpi->saved_scopes = scopes;
		scope = dpi->saved_scopes + (dpi->num_saved_scopes - 1);

		scope->container = sub;
		scope->templates = d_copy_templates (dpi);
@


1.117
log
@merge from gcc
@
text
@d2110 3
d2138 4
@


1.116
log
@merge from gcc
@
text
@d290 13
d334 2
d462 4
d1756 9
a1764 2
    return d_make_comp (di, DEMANGLE_COMPONENT_CAST,
			cplus_demangle_type (di), NULL);
d2313 30
a2342 2
	  /* This is <template-template-param> <template-args>.  The
	     <template-template-param> part is a substitution
d2344 24
a2367 4
	  if (! d_add_substitution (di, ret))
	    return NULL;
	  ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,
			     d_template_args (di));
d3053 2
a3054 2
static struct demangle_component *
d_expression (struct d_info *di)
d3082 1
a3082 1
			  d_expression (di), NULL);
d3187 1
a3187 1
	      operand = d_expression (di);
d3207 1
a3207 1
	      left = d_expression (di);
d3218 1
a3218 1
	      right = d_expression (di);
d3234 3
a3236 3
		first = d_expression (di);
		second = d_expression (di);
		third = d_expression (di);
d3260 1
a3260 1
		  third = d_expression (di);
d3280 12
d3677 20
d3793 1
d4275 6
d4317 1
d5535 5
a5539 3
  if (d_left (dc)->type != DEMANGLE_COMPONENT_TEMPLATE)
    d_print_comp (dpi, options, d_left (dc));
  else
a5540 11
      struct d_print_mod *hold_dpm;
      struct d_print_template dpt;

      /* It appears that for a templated cast operator, we need to put
	 the template parameters in scope for the operator name, but
	 not for the parameters.  The effect is that we need to handle
	 the template printing here.  */

      hold_dpm = dpi->modifiers;
      dpi->modifiers = NULL;

d5543 2
a5544 1
      dpt.template_decl = d_left (dc);
d5546 8
d5556 5
a5560 1
      dpi->templates = dpt.next;
a5570 2

      dpi->modifiers = hold_dpm;
d5603 2
@


1.115
log
@merge from gcc
@
text
@d3971 1
a3971 1
	malloc (sizeof (struct d_print_template));
d4384 2
d4391 3
a4393 3
		scopes = realloc (dpi->saved_scopes,
				  sizeof (struct d_saved_scope)
				  * dpi->num_saved_scopes);
@


1.114
log
@merge from gcc
@
text
@d278 12
d317 4
d3684 24
d3792 1
d3800 3
a3802 1
  return ! d_print_saw_error (&dpi);
d3959 30
d3999 7
d4374 42
a4415 1
	    struct demangle_component *a = d_lookup_template_argument (dpi, sub);
d4421 3
d4471 3
@


1.113
log
@merge from gcc
@
text
@a1278 1
    case 'L':
d1325 1
@


1.112
log
@merge from gcc
@
text
@a130 1
#include "hashtab.h"
a304 4
  /* Table mapping demangle components to scopes saved when first
     traversing those components.  These are used while evaluating
     substitutions.  */
  htab_t saved_scopes;
a3667 11

  dpi->saved_scopes = NULL;
}

/* Free a print information structure.  */

static void
d_print_free (struct d_print_info *dpi)
{
  if (dpi->saved_scopes != NULL)
    htab_delete (dpi->saved_scopes);
a3751 1
  int success;
d3759 1
a3759 3
  success = ! d_print_saw_error (&dpi);
  d_print_free (&dpi);
  return success;
a3915 108
/* A demangle component and some scope captured when it was first
   traversed.  */

struct d_saved_scope
{
  /* The component whose scope this is.  Used as the key for the
     saved_scopes hashtable in d_print_info.  May be NULL if this
     scope will not be inserted into that table.  */
  const struct demangle_component *container;
  /* Nonzero if the below items are copies and require freeing
     when this scope is freed.  */
  int is_copy;
  /* The list of templates, if any, that was current when this
     scope was captured.  */
  struct d_print_template *templates;
};

/* Allocate a scope and populate it with the current values from DPI.
   CONTAINER is the demangle component to which the scope refers, and
   is used as the key for the saved_scopes hashtable in d_print_info.
   CONTAINER may be NULL if this scope will not be inserted into that
   table.  If COPY is nonzero then items that may have been allocated
   on the stack will be copied before storing.  */

static struct d_saved_scope *
d_store_scope (const struct d_print_info *dpi,
	       const struct demangle_component *container, int copy)
{
  struct d_saved_scope *scope = XNEW (struct d_saved_scope);

  scope->container = container;
  scope->is_copy = copy;

  if (copy)
    {
      struct d_print_template *ts, **tl = &scope->templates;

      for (ts = dpi->templates; ts != NULL; ts = ts->next)
	{
	  struct d_print_template *td = XNEW (struct d_print_template);

	  *tl = td;
	  tl = &td->next;
	  td->template_decl = ts->template_decl;
	}
      *tl = NULL;
    }
  else
    scope->templates = dpi->templates;

  return scope;
}

/* Free a scope allocated by d_store_scope.  */

static void
d_free_scope (void *p)
{
  struct d_saved_scope *scope = (struct d_saved_scope *) p;

  if (scope->is_copy)
    {
      struct d_print_template *ts, *tn;

      for (ts = scope->templates; ts != NULL; ts = tn)
	{
	  tn = ts->next;
	  free (ts);
	}
    }

  free (scope);
}

/* Restore a stored scope to DPI, optionally freeing it afterwards.  */

static void
d_restore_scope (struct d_print_info *dpi, struct d_saved_scope *scope,
		 int free_after)
{
  dpi->templates = scope->templates;

  if (free_after)
    d_free_scope (scope);
}

/* Returns a hash code for the saved scope referenced by p.  */

static hashval_t
d_hash_saved_scope (const void *p)
{
  const struct d_saved_scope *s = (const struct d_saved_scope *) p;

  return htab_hash_pointer (s->container);
}

/* Returns non-zero if the saved scopes referenced by p1 and p2
   are equal.  */

static int
d_equal_saved_scope (const void *p1, const void *p2)
{
  const struct d_saved_scope *s1 = (const struct d_saved_scope *) p1;
  const struct d_saved_scope *s2 = (const struct d_saved_scope *) p2;

  return s1->container == s2->container;
}

a3925 4
  /* Variable used to store the current scope while a previously
     captured scope is used.  */
  struct d_saved_scope *saved_scope = NULL;

d4294 1
a4294 29
	    struct demangle_component *a;
	    struct d_saved_scope lookup;
	    void **slot;

	    if (dpi->saved_scopes == NULL)
	      dpi->saved_scopes = htab_create_alloc (1,
						     d_hash_saved_scope,
						     d_equal_saved_scope,
						     d_free_scope,
						     xcalloc, free);

	    lookup.container = sub;
	    slot = htab_find_slot (dpi->saved_scopes, &lookup, INSERT);
	    if (*slot == HTAB_EMPTY_ENTRY)
	      {
		/* This is the first time SUB has been traversed.
		   We need to capture some scope so it can be
		   restored if SUB is reentered as a substitution.  */
		*slot = d_store_scope (dpi, sub, 1);
	      }
	    else
	      {
		/* This traversal is reentering SUB as a substition.
		   Restore the original scope temporarily.  */
		saved_scope = d_store_scope (dpi, NULL, 0);
		d_restore_scope (dpi, (struct d_saved_scope *) *slot, 0);
	      }

	    a = d_lookup_template_argument (dpi, sub);
a4299 3
		if (saved_scope != NULL)
		  d_restore_scope (dpi, saved_scope, 1);

a4346 3
	if (saved_scope != NULL)
	  d_restore_scope (dpi, saved_scope, 1);

@


1.111
log
@merge from gcc
@
text
@d131 1
d306 4
d3673 11
d3768 1
d3776 3
a3778 1
  return ! d_print_saw_error (&dpi);
d3935 108
d4053 4
d4425 29
a4453 1
	    struct demangle_component *a = d_lookup_template_argument (dpi, sub);
d4459 3
d4509 3
@


1.110
log
@merge from gcc
@
text
@d2201 10
a2210 2
      *pret = cplus_demangle_type (di);
      if (! *pret)
a2749 1
  struct demangle_component **pmem;
d2755 2
d2758 14
a2771 34
  /* The ABI specifies that any type can be a substitution source, and
     that M is followed by two types, and that when a CV-qualified
     type is seen both the base type and the CV-qualified types are
     substitution sources.  The ABI also specifies that for a pointer
     to a CV-qualified member function, the qualifiers are attached to
     the second type.  Given the grammar, a plain reading of the ABI
     suggests that both the CV-qualified member function and the
     non-qualified member function are substitution sources.  However,
     g++ does not work that way.  g++ treats only the CV-qualified
     member function as a substitution source.  FIXME.  So to work
     with g++, we need to pull off the CV-qualifiers here, in order to
     avoid calling add_substitution() in cplus_demangle_type().  But
     for a CV-qualified member which is not a function, g++ does
     follow the ABI, so we need to handle that case here by calling
     d_add_substitution ourselves.  */

  pmem = d_cv_qualifiers (di, &mem, 1);
  if (pmem == NULL)
    return NULL;
  *pmem = cplus_demangle_type (di);
  if (*pmem == NULL)
    return NULL;

  if (pmem != &mem
      && ((*pmem)->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS
	  || (*pmem)->type == DEMANGLE_COMPONENT_REFERENCE_THIS))
    {
      /* Move the ref-qualifier outside the cv-qualifiers so that
	 they are printed in the right order.  */
      struct demangle_component *fn = d_left (*pmem);
      d_left (*pmem) = mem;
      mem = *pmem;
      *pmem = fn;
    }
d2773 3
a2775 5
  if (pmem != &mem && (*pmem)->type != DEMANGLE_COMPONENT_FUNCTION_TYPE)
    {
      if (! d_add_substitution (di, mem))
	return NULL;
    }
@


1.109
log
@merge from gcc
@
text
@d385 3
d620 6
d905 2
d1145 2
d1202 3
a1204 1
		 || dc->type == DEMANGLE_COMPONENT_CONST_THIS)
d1218 3
a1220 1
		     || dcr->type == DEMANGLE_COMPONENT_CONST_THIS)
d1342 2
a1343 2
/* <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E
                 ::= N [<CV-qualifiers>] <template-prefix> <template-args> E
d1351 1
d1360 4
d1368 6
d2202 13
a2214 1
      if (! *pret || ! d_add_substitution (di, ret))
d2517 32
a2548 1
/* <function-type> ::= F [Y] <bare-function-type> E  */
d2564 2
d2588 4
d2772 12
d4015 3
a4017 1
		&& typed_name->type != DEMANGLE_COMPONENT_CONST_THIS)
d4051 4
a4054 1
		   || local_name->type == DEMANGLE_COMPONENT_CONST_THIS)
d4331 2
d5005 4
a5008 1
	      || mods->mod->type == DEMANGLE_COMPONENT_CONST_THIS)))
d5063 3
a5065 1
	     || dc->type == DEMANGLE_COMPONENT_CONST_THIS)
d5110 3
d5116 2
d5189 2
d5711 6
a5721 3
	  case DEMANGLE_COMPONENT_RESTRICT_THIS:
	  case DEMANGLE_COMPONENT_VOLATILE_THIS:
	  case DEMANGLE_COMPONENT_CONST_THIS:
@


1.108
log
@merge from gcc
@
text
@d710 8
d3179 1
d3881 11
a3891 1
      d_print_comp (dpi, options, d_right (dc));
@


1.107
log
@merge from gcc
@
text
@d511 5
d817 1
d1211 17
d1442 1
d1447 1
a1447 1
    return d_source_name (di);
a1449 2
      struct demangle_component *ret;

a1457 1
      return ret;
d1460 1
a1460 1
    return d_ctor_dtor_name (di);
a1462 2
      struct demangle_component * ret;

a1469 1
      return ret;
d1476 2
a1477 1
	  return d_lambda (di);
d1479 2
a1480 1
	  return d_unnamed_type (di);
d1487 4
d3772 1
d3858 7
@


1.106
log
@merge from gcc
@
text
@d699 6
d841 2
d1878 8
d4091 10
@


1.105
log
@merge from gcc
@
text
@d1585 1
d1591 1
d1631 1
d1634 1
d2816 12
d2990 4
a2993 1
	    left = d_expression (di);
d4477 11
@


1.104
log
@merge from gcc
@
text
@d3718 1
@


1.103
log
@merge from gcc
@
text
@d2273 5
@


1.102
log
@merge from gcc
@
text
@d1422 6
a1427 1
	di->expansion += sizeof "operator" + ret->u.s_operator.op->len - 2;
d1604 1
@


1.101
log
@merge from gcc
@
text
@d4360 2
a4361 1
	char c;
d4364 2
a4365 2
	c = dc->u.s_operator.op->name[0];
	if (IS_LOWER (c))
d4367 4
a4370 2
	d_append_buffer (dpi, dc->u.s_operator.op->name,
			 dc->u.s_operator.op->len);
@


1.100
log
@merge from gcc
@
text
@d651 3
d657 3
a814 1
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
d851 2
d860 1
d1565 2
a1566 1
*/
d1578 2
d1584 1
a1584 1
  { "da", NL ("delete[]"),  1 },
d1586 2
a1587 1
  { "dl", NL ("delete"),    1 },
d1594 1
d1606 1
a1606 1
  { "na", NL ("new[]"),     1 },
d1610 1
a1610 1
  { "nw", NL ("new"),       1 },
d1627 2
a1628 2
  { "at", NL ("alignof "),   1 },
  { "az", NL ("alignof "),   1 },
d2258 1
d2265 1
d2316 1
d2694 2
a2695 1
  if (! d_check_char (di, 'I'))
d2697 1
d2756 1
d2765 2
a2766 1
/* Subroutine of <expression> ::= cl <expression>+ E */
d2769 1
a2769 1
d_exprlist (struct d_info *di)
d2774 1
a2774 1
  if (d_peek_char (di) == 'E')
d2791 1
a2791 1
      if (d_peek_char (di) == 'E')
d2882 11
d2896 1
d2904 7
a2910 6
	di->expansion += op->u.s_operator.op->len - 2;

      if (op->type == DEMANGLE_COMPONENT_OPERATOR
	  && strcmp (op->u.s_operator.op->code, "st") == 0)
	return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
			    cplus_demangle_type (di));
d2929 3
d2935 7
d2944 1
a2944 1
	      operand = d_exprlist (di);
d2947 10
a2956 2
	    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
				operand);
a2961 1
	    const char *code = op->u.s_operator.op->code;
d2965 1
a2965 1
	      right = d_exprlist (di);
d2985 1
d2987 35
a3021 2
	    first = d_expression (di);
	    second = d_expression (di);
d3028 1
a3028 2
							  second,
							  d_expression (di))));
d3748 2
d4345 13
d4381 4
d4386 4
a4389 18
      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
	  && d_left (dc)->u.s_operator.op->len == 1
	  && d_left (dc)->u.s_operator.op->name[0] == '&'
	  && d_right (dc)->type == DEMANGLE_COMPONENT_TYPED_NAME
	  && d_left (d_right (dc))->type == DEMANGLE_COMPONENT_QUAL_NAME
	  && d_right (d_right (dc))->type == DEMANGLE_COMPONENT_FUNCTION_TYPE)
	{
	  /* Address of a function (therefore in an expression context) must
	     have its argument list suppressed.

	     unary operator ... dc
	       operator & ... d_left (dc)
	       typed name ... d_right (dc)
		 qualified name ... d_left (d_right (dc))
		   <names>
		 function type ... d_right (d_right (dc))
		   argument list
		     <arguments>  */
d4391 21
a4411 15
	  d_print_expr_op (dpi, options, d_left (dc));
	  d_print_comp (dpi, options, d_left (d_right (dc)));
	  return;
	}
      else if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
	       && d_left (dc)->u.s_operator.op->len == 1
	       && d_left (dc)->u.s_operator.op->name[0] == '&'
	       && d_right (dc)->type == DEMANGLE_COMPONENT_QUAL_NAME)
	{
	  /* Keep also already processed variant without the argument list.

	     unary operator ... dc
	       operator & ... d_left (dc)
	       qualified name ... d_right (dc)
		 <names>  */
d4413 21
a4433 13
	  d_print_expr_op (dpi, options, d_left (dc));
	  d_print_comp (dpi, options, d_right (dc));
	  return;
	}
      else if (d_left (dc)->type != DEMANGLE_COMPONENT_CAST)
	d_print_expr_op (dpi, options, d_left (dc));
      else
	{
	  d_append_char (dpi, '(');
	  d_print_cast (dpi, options, d_left (dc));
	  d_append_char (dpi, ')');
	}
      d_print_subexpr (dpi, options, d_right (dc));
d4498 27
a4524 5
      d_print_subexpr (dpi, options, d_left (d_right (dc)));
      d_print_expr_op (dpi, options, d_left (dc));
      d_print_subexpr (dpi, options, d_left (d_right (d_right (dc))));
      d_append_string (dpi, " : ");
      d_print_subexpr (dpi, options, d_right (d_right (d_right (dc))));
@


1.99
log
@merge from gcc
@
text
@d588 6
d741 1
a741 1
      || (int) kind > gnu_v3_complete_object_allocating_ctor)
d760 1
a760 1
      || (int) kind > gnu_v3_base_object_dtor)
d832 2
d1773 2
d1869 17
d1969 3
d1994 3
d3971 10
@


1.98
log
@merge from gcc
@
text
@d1849 5
a1853 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_REFTEMP, d_name (di),
			      NULL);
d3927 3
a3929 1
      d_append_string (dpi, "reference temporary for ");
@


1.97
log
@merge from gcc
@
text
@d2297 1
d2300 1
d2337 22
@


1.96
log
@merge from gcc
@
text
@d420 3
d808 1
d1041 1
a1041 1
/* <mangled-name> ::= _Z <encoding>
d1049 2
d1059 12
a1070 1
  return d_encoding (di, top_level);
d2374 1
a2374 1
      if (peek == '\0' || peek == 'E')
d3102 27
d4510 7
@


1.95
log
@merge from gcc
@
text
@d1283 1
d1312 11
a1322 1
      if (IS_DIGIT (peek)
a1324 1
	  || peek == 'D'
@


1.94
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d3309 1
d3897 7
@


1.93
log
@merge from gcc

libiberty/
	PR debug/49408
	* cp-demangle.c (d_print_comp): Suppress argument list for function
	references by the '&' unary operator.  Keep also already processed
	variant without the argument list.  Suppress argument list types for
	function call used in an expression.
	* testsuite/demangle-expected: Fix excessive argument list types in
	`test for typed function in decltype'.  New testcase for no argument
	list types printed.  3 new testcases for function references by the
	'&' unary operator..
@
text
@d2741 12
a2752 4
      index = d_compact_number (di);
      if (index < 0)
	return NULL;

d4411 11
a4421 3
      d_append_string (dpi, "{parm#");
      d_append_num (dpi, dc->u.s_number.number + 1);
      d_append_char (dpi, '}');
@


1.92
log
@merge from gcc
@
text
@d4142 40
a4181 1
      if (d_left (dc)->type != DEMANGLE_COMPONENT_CAST)
d4207 15
a4221 1
      d_print_subexpr (dpi, options, d_left (d_right (dc)));
@


1.91
log
@merge from gcc
@
text
@d3557 4
d3876 21
d3898 1
a3903 2
    case DEMANGLE_COMPONENT_REFERENCE:
    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:
d3906 1
d3917 4
a3920 1
	d_print_comp (dpi, options, d_left (dc));
@


1.90
log
@Properly demangle a global constructor symbol.

2010-11-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR other/42670
	PR binutils/11137
	* cp-demangle.c (d_make_demangle_mangled_name): New.
	(d_demangle_callback): Use it on DCT_GLOBAL_XTORS.

	* testsuite/demangle-expected: Updated.
@
text
@a280 2
  /* The options passed to the demangler.  */
  int options;
d437 1
a437 1
d_print_init (struct d_print_info *, int, demangle_callbackref, void *);
d455 1
a455 1
d_print_comp (struct d_print_info *, const struct demangle_component *);
d461 1
a461 1
d_print_mod_list (struct d_print_info *, struct d_print_mod *, int);
d464 1
a464 1
d_print_mod (struct d_print_info *, const struct demangle_component *);
d467 1
a467 1
d_print_function_type (struct d_print_info *,
d472 1
a472 1
d_print_array_type (struct d_print_info *,
d477 1
a477 1
d_print_expr_op (struct d_print_info *, const struct demangle_component *);
d480 1
a480 1
d_print_cast (struct d_print_info *, const struct demangle_component *);
d3294 2
a3295 2
d_print_init (struct d_print_info *dpi, int options,
              demangle_callbackref callback, void *opaque)
a3296 1
  dpi->options = options;
d3392 1
a3392 1
  d_print_init (&dpi, options, callback, opaque);
d3394 1
a3394 1
  d_print_comp (&dpi, dc);
d3537 1
a3537 1
d_print_subexpr (struct d_print_info *dpi,
d3546 1
a3546 1
  d_print_comp (dpi, dc);
d3554 1
a3554 1
d_print_comp (struct d_print_info *dpi,
d3568 1
a3568 1
      if ((dpi->options & DMGL_JAVA) == 0)
d3576 2
a3577 2
      d_print_comp (dpi, d_left (dc));
      if ((dpi->options & DMGL_JAVA) == 0)
d3581 1
a3581 1
      d_print_comp (dpi, d_right (dc));
d3671 1
a3671 1
	d_print_comp (dpi, d_right (dc));
d3684 1
a3684 1
		d_print_mod (dpi, adpm[i].mod);
d3707 1
a3707 1
        if ((dpi->options & DMGL_JAVA) != 0
d3715 1
a3715 1
            d_print_comp (dpi, d_right (dc));
d3720 1
a3720 1
	    d_print_comp (dpi, dcl);
d3724 1
a3724 1
	    d_print_comp (dpi, d_right (dc));
d3759 1
a3759 1
	d_print_comp (dpi, a);
d3767 1
a3767 1
      d_print_comp (dpi, dc->u.s_ctor.name);
d3772 1
a3772 1
      d_print_comp (dpi, dc->u.s_dtor.name);
d3777 1
a3777 1
      d_print_comp (dpi, d_left (dc));
d3782 1
a3782 1
      d_print_comp (dpi, d_left (dc));
d3787 1
a3787 1
      d_print_comp (dpi, d_left (dc));
d3789 1
a3789 1
      d_print_comp (dpi, d_right (dc));
d3794 1
a3794 1
      d_print_comp (dpi, d_left (dc));
d3799 1
a3799 1
      d_print_comp (dpi, d_left (dc));
d3804 1
a3804 1
      d_print_comp (dpi, d_left (dc));
d3809 1
a3809 1
      d_print_comp (dpi, d_left (dc));
d3814 1
a3814 1
      d_print_comp (dpi, d_left (dc));
d3819 1
a3819 1
      d_print_comp (dpi, d_left (dc));
d3824 1
a3824 1
      d_print_comp (dpi, d_left (dc));
d3829 1
a3829 1
      d_print_comp (dpi, d_left (dc));
d3834 1
a3834 1
      d_print_comp (dpi, d_left (dc));
d3839 1
a3839 1
      d_print_comp (dpi, d_left (dc));
d3866 1
a3866 1
		    d_print_comp (dpi, d_left (dc));
d3892 1
a3892 1
	d_print_comp (dpi, d_left (dc));
d3897 1
a3897 1
	  d_print_mod (dpi, dc);
d3905 1
a3905 1
      if ((dpi->options & DMGL_JAVA) == 0)
d3914 1
a3914 1
      d_print_comp (dpi, d_left (dc));
d3919 4
a3922 2
	if ((dpi->options & DMGL_RET_POSTFIX) != 0)
	  d_print_function_type (dpi, dc, dpi->modifiers);
d3925 4
a3928 1
	if (d_left (dc) != NULL)
d3940 2
a3941 1
	    d_print_comp (dpi, d_left (dc));
d3950 1
a3950 1
	    if ((dpi->options & DMGL_RET_POSTFIX) == 0)
d3954 4
a3957 2
	if ((dpi->options & DMGL_RET_POSTFIX) == 0) 
	  d_print_function_type (dpi, dc, dpi->modifiers);
d4010 1
a4010 1
	d_print_comp (dpi, d_right (dc));
d4020 1
a4020 1
	    d_print_mod (dpi, adpm[i].mod);
d4023 1
a4023 1
	d_print_array_type (dpi, dc, dpi->modifiers);
d4039 1
a4039 1
	d_print_comp (dpi, d_right (dc));
d4044 1
a4044 1
	  d_print_mod (dpi, dc);
d4058 1
a4058 1
	  d_print_comp (dpi, dc->u.s_fixed.length);
d4070 1
a4070 1
	d_print_comp (dpi, d_left (dc));
d4082 1
a4082 1
	  d_print_comp (dpi, d_right (dc));
d4105 1
a4105 1
      d_print_comp (dpi, dc->u.s_extended_operator.name);
d4110 1
a4110 1
      d_print_cast (dpi, dc);
d4115 1
a4115 1
	d_print_expr_op (dpi, d_left (dc));
d4119 1
a4119 1
	  d_print_cast (dpi, d_left (dc));
d4122 1
a4122 1
      d_print_subexpr (dpi, d_right (dc));
d4140 1
a4140 1
      d_print_subexpr (dpi, d_left (d_right (dc)));
d4144 1
a4144 1
	  d_print_comp (dpi, d_right (d_right (dc)));
d4150 2
a4151 2
	    d_print_expr_op (dpi, d_left (dc));
	  d_print_subexpr (dpi, d_right (d_right (dc)));
d4173 3
a4175 3
      d_print_subexpr (dpi, d_left (d_right (dc)));
      d_print_expr_op (dpi, d_left (dc));
      d_print_subexpr (dpi, d_left (d_right (d_right (dc))));
d4177 1
a4177 1
      d_print_subexpr (dpi, d_right (d_right (d_right (dc))));
d4208 1
a4208 1
		    d_print_comp (dpi, d_right (dc));
d4258 1
a4258 1
	d_print_comp (dpi, d_left (dc));
d4264 1
a4264 1
	d_print_comp (dpi, d_right (dc));
d4276 1
a4276 1
      d_print_comp (dpi, d_left (dc));
d4280 2
a4281 2
      d_print_comp (dpi, d_left (dc));
      d_print_comp (dpi, d_right (dc));
d4290 1
a4290 1
      d_print_comp (dpi, d_left (dc));
d4304 1
a4304 1
	    d_print_subexpr (dpi, d_left (dc));
d4314 1
a4314 1
	    d_print_comp (dpi, dc);
d4329 1
a4329 1
      d_print_comp (dpi, dc->u.s_binary.left);
d4334 1
a4334 1
      d_print_comp (dpi, dc->u.s_binary.left);
d4339 1
a4339 1
      d_print_comp (dpi, dc->u.s_unary_num.sub);
d4413 1
a4413 1
d_print_mod_list (struct d_print_info *dpi,
d4427 1
a4427 1
      d_print_mod_list (dpi, mods->next, suffix);
d4438 1
a4438 1
      d_print_function_type (dpi, mods->mod, mods->next);
d4444 1
a4444 1
      d_print_array_type (dpi, mods->mod, mods->next);
d4460 1
a4460 1
      d_print_comp (dpi, d_left (mods->mod));
d4463 1
a4463 1
      if ((dpi->options & DMGL_JAVA) == 0)
d4483 1
a4483 1
      d_print_comp (dpi, dc);
d4489 1
a4489 1
  d_print_mod (dpi, mods->mod);
d4493 1
a4493 1
  d_print_mod_list (dpi, mods->next, suffix);
d4499 1
a4499 1
d_print_mod (struct d_print_info *dpi,
d4518 1
a4518 1
      d_print_comp (dpi, d_right (mod));
d4522 1
a4522 1
      if ((dpi->options & DMGL_JAVA) == 0)
d4540 1
a4540 1
      d_print_comp (dpi, d_left (mod));
d4544 1
a4544 1
      d_print_comp (dpi, d_left (mod));
d4548 1
a4548 1
      d_print_comp (dpi, d_left (mod));
d4555 1
a4555 1
      d_print_comp (dpi, mod);
d4563 1
a4563 1
d_print_function_type (struct d_print_info *dpi,
d4623 1
a4623 1
  d_print_mod_list (dpi, mods, 0);
d4631 1
a4631 1
    d_print_comp (dpi, d_right (dc));
d4635 1
a4635 1
  d_print_mod_list (dpi, mods, 1);
d4643 1
a4643 1
d_print_array_type (struct d_print_info *dpi,
d4677 1
a4677 1
      d_print_mod_list (dpi, mods, 0);
d4689 1
a4689 1
    d_print_comp (dpi, d_left (dc));
d4697 1
a4697 1
d_print_expr_op (struct d_print_info *dpi,
d4704 1
a4704 1
    d_print_comp (dpi, dc);
d4710 1
a4710 1
d_print_cast (struct d_print_info *dpi,
d4714 1
a4714 1
    d_print_comp (dpi, d_left (dc));
d4732 1
a4732 1
      d_print_comp (dpi, d_left (d_left (dc)));
d4739 1
a4739 1
      d_print_comp (dpi, d_right (d_left (dc)));
@


1.90.2.1
log
@commit d5b397191d6242fa1b0941cdb328c421bf2b09a0
Author: DJ Delorie <dj@@delorie.com>
Date:   Mon Jun 13 23:01:42 2011 +0000

    merge from gcc

include/
	* demangle.h (DMGL_RET_POSTFIX): Extend the comment.
	(DMGL_RET_DROP): New.

libiberty/
	* cp-demangle.c (d_print_comp) <DEMANGLE_COMPONENT_FUNCTION_TYPE>:
	Suppress d_print_mod for DMGL_RET_POSTFIX.
	* testsuite/demangle-expected: New testcases for --ret-postfix.

	* cp-demangle.c (d_print_comp) <DEMANGLE_COMPONENT_FUNCTION_TYPE>: Do
	not pass DMGL_RET_POSTFIX or DMGL_RET_DROP.  Support DMGL_RET_DROP.
	* testsuite/demangle-expected: New testcases for --ret-drop.
	* testsuite/test-demangle.c: Document --ret-drop in a comment.
	(main): New variable ret_drop, fill it, call cplus_demangle with it.

	* cp-demangle.c (struct d_print_info): Remove field options.
	(d_print_init): Remove parameter options.
	(cplus_demangle_print_callback): Update all the callers.
	(d_print_comp, d_print_mod_list, d_print_mod, d_print_function_type)
	(d_print_array_type, d_print_expr_op, d_print_cast, d_print_subexpr):
	Add parameter options, update all the callers.
@
text
@d281 2
d439 1
a439 1
d_print_init (struct d_print_info *, demangle_callbackref, void *);
d457 1
a457 1
d_print_comp (struct d_print_info *, int, const struct demangle_component *);
d463 1
a463 1
d_print_mod_list (struct d_print_info *, int, struct d_print_mod *, int);
d466 1
a466 1
d_print_mod (struct d_print_info *, int, const struct demangle_component *);
d469 1
a469 1
d_print_function_type (struct d_print_info *, int,
d474 1
a474 1
d_print_array_type (struct d_print_info *, int,
d479 1
a479 1
d_print_expr_op (struct d_print_info *, int, const struct demangle_component *);
d482 1
a482 1
d_print_cast (struct d_print_info *, int, const struct demangle_component *);
d3296 2
a3297 2
d_print_init (struct d_print_info *dpi, demangle_callbackref callback,
	      void *opaque)
d3299 1
d3395 1
a3395 1
  d_print_init (&dpi, callback, opaque);
d3397 1
a3397 1
  d_print_comp (&dpi, options, dc);
d3540 1
a3540 1
d_print_subexpr (struct d_print_info *dpi, int options,
d3549 1
a3549 1
  d_print_comp (dpi, options, dc);
d3557 1
a3557 1
d_print_comp (struct d_print_info *dpi, int options,
d3571 1
a3571 1
      if ((options & DMGL_JAVA) == 0)
d3579 2
a3580 2
      d_print_comp (dpi, options, d_left (dc));
      if ((options & DMGL_JAVA) == 0)
d3584 1
a3584 1
      d_print_comp (dpi, options, d_right (dc));
d3674 1
a3674 1
	d_print_comp (dpi, options, d_right (dc));
d3687 1
a3687 1
		d_print_mod (dpi, options, adpm[i].mod);
d3710 1
a3710 1
        if ((options & DMGL_JAVA) != 0
d3718 1
a3718 1
            d_print_comp (dpi, options, d_right (dc));
d3723 1
a3723 1
	    d_print_comp (dpi, options, dcl);
d3727 1
a3727 1
	    d_print_comp (dpi, options, d_right (dc));
d3762 1
a3762 1
	d_print_comp (dpi, options, a);
d3770 1
a3770 1
      d_print_comp (dpi, options, dc->u.s_ctor.name);
d3775 1
a3775 1
      d_print_comp (dpi, options, dc->u.s_dtor.name);
d3780 1
a3780 1
      d_print_comp (dpi, options, d_left (dc));
d3785 1
a3785 1
      d_print_comp (dpi, options, d_left (dc));
d3790 1
a3790 1
      d_print_comp (dpi, options, d_left (dc));
d3792 1
a3792 1
      d_print_comp (dpi, options, d_right (dc));
d3797 1
a3797 1
      d_print_comp (dpi, options, d_left (dc));
d3802 1
a3802 1
      d_print_comp (dpi, options, d_left (dc));
d3807 1
a3807 1
      d_print_comp (dpi, options, d_left (dc));
d3812 1
a3812 1
      d_print_comp (dpi, options, d_left (dc));
d3817 1
a3817 1
      d_print_comp (dpi, options, d_left (dc));
d3822 1
a3822 1
      d_print_comp (dpi, options, d_left (dc));
d3827 1
a3827 1
      d_print_comp (dpi, options, d_left (dc));
d3832 1
a3832 1
      d_print_comp (dpi, options, d_left (dc));
d3837 1
a3837 1
      d_print_comp (dpi, options, d_left (dc));
d3842 1
a3842 1
      d_print_comp (dpi, options, d_left (dc));
d3869 1
a3869 1
		    d_print_comp (dpi, options, d_left (dc));
d3895 1
a3895 1
	d_print_comp (dpi, options, d_left (dc));
d3900 1
a3900 1
	  d_print_mod (dpi, options, dc);
d3908 1
a3908 1
      if ((options & DMGL_JAVA) == 0)
d3917 1
a3917 1
      d_print_comp (dpi, options, d_left (dc));
d3922 2
a3923 4
	if ((options & DMGL_RET_POSTFIX) != 0)
	  d_print_function_type (dpi,
				 options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
				 dc, dpi->modifiers);
d3926 1
a3926 4
	if (d_left (dc) != NULL && (options & DMGL_RET_POSTFIX) != 0)
	  d_print_comp (dpi, options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
			d_left (dc));
	else if (d_left (dc) != NULL && (options & DMGL_RET_DROP) == 0)
d3938 1
a3938 2
	    d_print_comp (dpi, options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
			  d_left (dc));
d3947 1
a3947 1
	    if ((options & DMGL_RET_POSTFIX) == 0)
d3951 2
a3952 4
	if ((options & DMGL_RET_POSTFIX) == 0)
	  d_print_function_type (dpi,
				 options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),
				 dc, dpi->modifiers);
d4005 1
a4005 1
	d_print_comp (dpi, options, d_right (dc));
d4015 1
a4015 1
	    d_print_mod (dpi, options, adpm[i].mod);
d4018 1
a4018 1
	d_print_array_type (dpi, options, dc, dpi->modifiers);
d4034 1
a4034 1
	d_print_comp (dpi, options, d_right (dc));
d4039 1
a4039 1
	  d_print_mod (dpi, options, dc);
d4053 1
a4053 1
	  d_print_comp (dpi, options, dc->u.s_fixed.length);
d4065 1
a4065 1
	d_print_comp (dpi, options, d_left (dc));
d4077 1
a4077 1
	  d_print_comp (dpi, options, d_right (dc));
d4100 1
a4100 1
      d_print_comp (dpi, options, dc->u.s_extended_operator.name);
d4105 1
a4105 1
      d_print_cast (dpi, options, dc);
d4110 1
a4110 1
	d_print_expr_op (dpi, options, d_left (dc));
d4114 1
a4114 1
	  d_print_cast (dpi, options, d_left (dc));
d4117 1
a4117 1
      d_print_subexpr (dpi, options, d_right (dc));
d4135 1
a4135 1
      d_print_subexpr (dpi, options, d_left (d_right (dc)));
d4139 1
a4139 1
	  d_print_comp (dpi, options, d_right (d_right (dc)));
d4145 2
a4146 2
	    d_print_expr_op (dpi, options, d_left (dc));
	  d_print_subexpr (dpi, options, d_right (d_right (dc)));
d4168 3
a4170 3
      d_print_subexpr (dpi, options, d_left (d_right (dc)));
      d_print_expr_op (dpi, options, d_left (dc));
      d_print_subexpr (dpi, options, d_left (d_right (d_right (dc))));
d4172 1
a4172 1
      d_print_subexpr (dpi, options, d_right (d_right (d_right (dc))));
d4203 1
a4203 1
		    d_print_comp (dpi, options, d_right (dc));
d4253 1
a4253 1
	d_print_comp (dpi, options, d_left (dc));
d4259 1
a4259 1
	d_print_comp (dpi, options, d_right (dc));
d4271 1
a4271 1
      d_print_comp (dpi, options, d_left (dc));
d4275 2
a4276 2
      d_print_comp (dpi, options, d_left (dc));
      d_print_comp (dpi, options, d_right (dc));
d4285 1
a4285 1
      d_print_comp (dpi, options, d_left (dc));
d4299 1
a4299 1
	    d_print_subexpr (dpi, options, d_left (dc));
d4309 1
a4309 1
	    d_print_comp (dpi, options, dc);
d4324 1
a4324 1
      d_print_comp (dpi, options, dc->u.s_binary.left);
d4329 1
a4329 1
      d_print_comp (dpi, options, dc->u.s_binary.left);
d4334 1
a4334 1
      d_print_comp (dpi, options, dc->u.s_unary_num.sub);
d4408 1
a4408 1
d_print_mod_list (struct d_print_info *dpi, int options,
d4422 1
a4422 1
      d_print_mod_list (dpi, options, mods->next, suffix);
d4433 1
a4433 1
      d_print_function_type (dpi, options, mods->mod, mods->next);
d4439 1
a4439 1
      d_print_array_type (dpi, options, mods->mod, mods->next);
d4455 1
a4455 1
      d_print_comp (dpi, options, d_left (mods->mod));
d4458 1
a4458 1
      if ((options & DMGL_JAVA) == 0)
d4478 1
a4478 1
      d_print_comp (dpi, options, dc);
d4484 1
a4484 1
  d_print_mod (dpi, options, mods->mod);
d4488 1
a4488 1
  d_print_mod_list (dpi, options, mods->next, suffix);
d4494 1
a4494 1
d_print_mod (struct d_print_info *dpi, int options,
d4513 1
a4513 1
      d_print_comp (dpi, options, d_right (mod));
d4517 1
a4517 1
      if ((options & DMGL_JAVA) == 0)
d4535 1
a4535 1
      d_print_comp (dpi, options, d_left (mod));
d4539 1
a4539 1
      d_print_comp (dpi, options, d_left (mod));
d4543 1
a4543 1
      d_print_comp (dpi, options, d_left (mod));
d4550 1
a4550 1
      d_print_comp (dpi, options, mod);
d4558 1
a4558 1
d_print_function_type (struct d_print_info *dpi, int options,
d4618 1
a4618 1
  d_print_mod_list (dpi, options, mods, 0);
d4626 1
a4626 1
    d_print_comp (dpi, options, d_right (dc));
d4630 1
a4630 1
  d_print_mod_list (dpi, options, mods, 1);
d4638 1
a4638 1
d_print_array_type (struct d_print_info *dpi, int options,
d4672 1
a4672 1
      d_print_mod_list (dpi, options, mods, 0);
d4684 1
a4684 1
    d_print_comp (dpi, options, d_left (dc));
d4692 1
a4692 1
d_print_expr_op (struct d_print_info *dpi, int options,
d4699 1
a4699 1
    d_print_comp (dpi, options, dc);
d4705 1
a4705 1
d_print_cast (struct d_print_info *dpi, int options,
d4709 1
a4709 1
    d_print_comp (dpi, options, d_left (dc));
d4727 1
a4727 1
      d_print_comp (dpi, options, d_left (d_left (dc)));
d4734 1
a4734 1
      d_print_comp (dpi, options, d_right (d_left (dc)));
@


1.90.2.2
log
@commit f0c376c93cceeffce3e7b879c20a1ab9787e102d
Author: Jan Kratochvil <jan.kratochvil@@redhat.com>
Date:   Fri Jul 1 17:30:47 2011 +0000

libiberty/
	PR debug/49408
	* cp-demangle.c (d_print_comp): Suppress argument list for function
	references by the '&' unary operator.  Keep also already processed
	variant without the argument list.  Suppress argument list types for
	function call used in an expression.
	* testsuite/demangle-expected: Fix excessive argument list types in
	`test for typed function in decltype'.  New testcase for no argument
	list types printed.  3 new testcases for function references by the
	'&' unary operator..
@
text
@d4114 1
a4114 40
      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
	  && d_left (dc)->u.s_operator.op->len == 1
	  && d_left (dc)->u.s_operator.op->name[0] == '&'
	  && d_right (dc)->type == DEMANGLE_COMPONENT_TYPED_NAME
	  && d_left (d_right (dc))->type == DEMANGLE_COMPONENT_QUAL_NAME
	  && d_right (d_right (dc))->type == DEMANGLE_COMPONENT_FUNCTION_TYPE)
	{
	  /* Address of a function (therefore in an expression context) must
	     have its argument list suppressed.

	     unary operator ... dc
	       operator & ... d_left (dc)
	       typed name ... d_right (dc)
		 qualified name ... d_left (d_right (dc))
		   <names>
		 function type ... d_right (d_right (dc))
		   argument list
		     <arguments>  */

	  d_print_expr_op (dpi, options, d_left (dc));
	  d_print_comp (dpi, options, d_left (d_right (dc)));
	  return;
	}
      else if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
	       && d_left (dc)->u.s_operator.op->len == 1
	       && d_left (dc)->u.s_operator.op->name[0] == '&'
	       && d_right (dc)->type == DEMANGLE_COMPONENT_QUAL_NAME)
	{
	  /* Keep also already processed variant without the argument list.

	     unary operator ... dc
	       operator & ... d_left (dc)
	       qualified name ... d_right (dc)
		 <names>  */

	  d_print_expr_op (dpi, options, d_left (dc));
	  d_print_comp (dpi, options, d_right (dc));
	  return;
	}
      else if (d_left (dc)->type != DEMANGLE_COMPONENT_CAST)
d4140 1
a4140 15
      if (strcmp (d_left (dc)->u.s_operator.op->code, "cl") == 0
          && d_left (d_right (dc))->type == DEMANGLE_COMPONENT_TYPED_NAME)
	{
	  /* Function call used in an expression should not have printed types
	     of the function arguments.  Values of the function arguments still
	     get printed below.  */

	  const struct demangle_component *func = d_left (d_right (dc));

	  if (d_right (func)->type != DEMANGLE_COMPONENT_FUNCTION_TYPE)
	    d_print_error (dpi);
	  d_print_subexpr (dpi, options, d_left (func));
	}
      else
	d_print_subexpr (dpi, options, d_left (d_right (dc)));
@


1.89
log
@merge from gcc
@
text
@d325 3
d875 11
d4840 1
a4840 1
			  d_make_name (&di, d_str (&di), strlen (d_str (&di))),
@


1.88
log
@2010-09-10  James Lyon  <jameslyon0@@googlemail.com>

	http://sourceware.org/bugzilla/show_bug.cgi?id=11572
	* cp-demangle.c (d_find_pack): Add case for
	DEMANGLE_COMPONENT_LAMBDA.
	* testsuite/demangle-expected: Add regression test.
@
text
@a4548 1
  int saw_mod;
a4553 1
  saw_mod = 0;
a4559 1
      saw_mod = 1;
a4587 3
  if (d_left (dc) != NULL && ! saw_mod)
    need_paren = 1;

@


1.88.2.1
log
@	PR other/46332
	* cp-demangle.c (d_print_function_type): Don't print parentheses
	if there are no modifiers to print.
	* testsuite/demangle-expected: Tweak one test case, add another.
@
text
@d4549 1
d4555 1
d4562 1
d4591 3
@


1.87
log
@	PR other/43838
	* cp-demangle.c (struct d_print_info): Add flush_count field.
	(d_print_init): Initialize it to 0.
	(d_print_flush): Increment it.
	(d_print_comp): If needed flush before appending ", ".  Only
	decrement dpi->len if no flushes happened during the recursive
	call.
	* testsuite/demangle-expected: Add a test for this.
@
text
@d3483 1
@


1.86
log
@merge from gcc
@
text
@d305 2
d3290 1
d3320 1
d4054 5
d4061 1
d4065 1
a4065 1
	  if (dpi->len == len)
@


1.85
log
@merge from gcc
@
text
@d1990 2
d2226 6
@


1.84
log
@merge from gcc
@
text
@d4509 1
a4509 1
      d_append_string (dpi, " vector[");
d4511 1
a4511 1
      d_append_char (dpi, ']');
@


1.83
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008
d392 2
d801 1
d1448 14
d2213 2
d2220 4
d2442 28
d2725 2
a2726 1
  else if (IS_DIGIT (peek))
d2729 8
a2736 2
         a dependent member access, i.e. decltype(T().i).  */
      struct demangle_component *name = d_unqualified_name (di);
d2794 1
d2797 1
a2797 1
	    if (!strcmp (op->u.s_operator.op->code, "cl"))
d2799 7
d3997 1
d4012 1
a4012 5
	  {
	    d_append_char (dpi, ' ');
	    d_print_comp (dpi, d_left (dc));
	    d_append_string (dpi, "::*");
	  }
d4232 4
d4508 6
@


1.82
log
@Return dgs.alc on success

2010-01-09  Ian Lance Taylor  <iant@@google.com>

	PR other/42230
	* cp-demangle.c (d_demangle): Return dgs.alc on success.
@
text
@d4040 12
a4051 3
      if (strcmp (d_left (dc)->u.s_operator.op->code, "cl") != 0)
	d_print_expr_op (dpi, d_left (dc));
      d_print_subexpr (dpi, d_right (d_right (dc)));
@


1.81
log
@merge from gcc
@
text
@d4780 1
a4780 1
  *palc = dgs.allocation_failure ? 1 : 0;
@


1.80
log
@merge from gcc
@
text
@d411 4
d929 14
d1174 1
d1176 1
a1176 1
	
d1298 1
d1314 10
d1380 12
d2287 1
a2287 1
/* <bare-function-type> ::= [J]<type>+  */
d2290 1
a2290 1
d_bare_function_type (struct d_info *di, int has_return_type)
a2291 1
  struct demangle_component *return_type;
a2293 1
  char peek;
a2294 10
  /* Detect special qualifier indicating that the first argument
     is the return type.  */
  peek = d_peek_char (di);
  if (peek == 'J')
    {
      d_advance (di, 1);
      has_return_type = 1;
    }

  return_type = NULL;
d2301 1
a2301 1
      peek = d_peek_char (di);
d2307 4
a2310 12
      if (has_return_type)
	{
	  return_type = type;
	  has_return_type = 0;
	}
      else
	{
	  *ptl = d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, type, NULL);
	  if (*ptl == NULL)
	    return NULL;
	  ptl = &d_right (*ptl);
	}
d2325 1
a2325 1
      tl = NULL;
d2328 36
a2363 1
  return d_make_comp (di, DEMANGLE_COMPONENT_FUNCTION_TYPE, return_type, tl);
d2465 18
d2495 2
a2496 11
  if (d_peek_char (di) == '_')
    param = 0;
  else
    {
      param = d_number (di);
      if (param < 0)
	return NULL;
      param += 1;
    }

  if (! d_check_char (di, '_'))
d2668 2
a2669 11
      if (d_peek_char (di) == '_')
	index = 1;
      else
	{
	  index = d_number (di);
	  if (index < 0)
	    return NULL;
	  index += 2;
	}

      if (! d_check_char (di, '_'))
d2862 10
d2874 13
a2886 2
      if (! d_discriminator (di))
	return NULL;
d2910 69
d3272 8
d3556 2
d4208 4
a4211 7
      {
	char buf[25];
	d_append_string (dpi, "parm#");
	sprintf(buf,"%ld", dc->u.s_number.number);
	d_append_string (dpi, buf);
	return;
      }
d4223 14
d4355 9
@


1.79
log
@merge from gcc
@
text
@d822 2
d4059 10
d4499 8
a4506 1
  int type;
d4512 1
a4512 1
    type = 0;
d4517 1
a4517 11
    {
      const char *intro;

      intro = (mangled[9] == 'I')
              ? "global constructors keyed to "
              : "global destructors keyed to ";

      callback (intro, strlen (intro), opaque);
      callback (mangled + 11, strlen (mangled + 11), opaque);
      return 1;
    }
d4522 1
a4522 1
      type = 1;
d4539 20
a4558 4
    if (type)
      dc = cplus_demangle_type (&di);
    else
      dc = cplus_demangle_mangled_name (&di, 1);
@


1.78
log
@merge from gcc
@
text
@d722 2
a723 2
      || (kind < gnu_v3_complete_object_ctor
	  && kind > gnu_v3_complete_object_allocating_ctor))
d741 2
a742 2
      || (kind < gnu_v3_deleting_dtor
	  && kind > gnu_v3_base_object_dtor))
@


1.77
log
@merge from gcc
@
text
@d2589 6
d3253 1
d3294 2
a3295 1
  if (dc->type == DEMANGLE_COMPONENT_NAME)
d4023 2
d4026 9
a4034 2
	int len = d_pack_length (a);
	int i;
d4036 1
@


1.76
log
@merge from gcc
@
text
@d967 16
d1008 5
a1012 1
  if (! d_check_char (di, '_'))
d1504 2
d2589 1
a2589 2
  else if (peek == 's'
	   && (d_peek_next_char (di) == 'T' || d_peek_next_char (di) == 'R'))
d2591 2
a2592 1
      /* Just demangle a parameter placeholder as its type.  */
d2594 14
a2607 1
      return cplus_demangle_type (di);
d2657 10
a2666 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
			      d_expression (di));
d2717 3
a2719 1
  if (d_peek_char (di) == '_')
d3341 1
d4030 9
@


1.75
log
@merge from gcc
@
text
@d2134 3
d2615 1
a2615 6
	  if (d_peek_char (di) == 'v')
	    /* T() encoded as an operand of void.  */
	    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
				cplus_demangle_type (di));
	  else
	    args = 1;
d3808 1
a3808 6
      if (d_left (dc)->type == DEMANGLE_COMPONENT_CAST
	  && d_right (dc)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE)
	/* type() -- FIXME what about type(multiple,args) */
	d_append_string (dpi, "()");
      else
	d_print_subexpr (dpi, d_right (dc));
@


1.74
log
@merge from gcc
@
text
@d2564 2
a2565 1
  else if (peek == 's' && d_peek_next_char (di) == 'T')
d3767 1
d3769 1
d3771 4
@


1.73
log
@merge from gcc
@
text
@d624 3
d2121 13
d3744 16
@


1.72
log
@merge from gcc
@
text
@d302 3
d669 3
a814 2
    case DEMANGLE_COMPONENT_ARGLIST:
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
d818 1
d839 2
d1443 1
d1886 3
a1888 6
  /* The decimal floating point and half-precision floating point types
     don't use the normal builtin type encoding, they're just stuck into
     holes in the table for convenience.  */
  /* p */ { NL ("decimal32"),	NL ("decimal32"),	D_PRINT_DEFAULT },
  /* q */ { NL ("decimal64"),	NL ("decimal64"),	D_PRINT_DEFAULT },
  /* r */ { NL ("decimal128"),	NL ("decimal128"),	D_PRINT_DEFAULT },
d1891 1
a1891 1
  /* u */ { NL ("half"),	NL ("half"),		D_PRINT_FLOAT },
d1898 6
d2084 3
a2086 1
	  return NULL;
d2089 2
a2090 3
	  /* 32-bit DFP */
	  ret = d_make_builtin_type (di,
				     &cplus_demangle_builtin_types['p' - 'a']);
d2094 2
a2095 3
	  /* 64-bit decimal floating point */
	  ret = d_make_builtin_type (di,
				     &cplus_demangle_builtin_types['q' - 'a']);
d2100 1
a2100 2
	  ret = d_make_builtin_type (di,
				     &cplus_demangle_builtin_types['r' - 'a']);
d2105 11
a2115 2
	  ret = d_make_builtin_type (di,
				     &cplus_demangle_builtin_types['u' - 'a']);
d2412 7
d2468 4
d2485 6
d2554 13
d3119 117
a3420 2
	long i;
	struct demangle_component *a;
d3422 1
d3424 4
a3427 20
	if (dpi->templates == NULL)
	  {
	    d_print_error (dpi);
	    return;
	  }
	i = dc->u.s_number.number;
	for (a = d_right (dpi->templates->template_decl);
	     a != NULL;
	     a = d_right (a))
	  {
	    if (a->type != DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)
	      {
		d_print_error (dpi);
		return;
	      }
	    if (i <= 0)
	      break;
	    --i;
	  }
	if (i != 0 || a == NULL)
d3441 1
a3441 1
	d_print_comp (dpi, d_left (a));
d3730 2
a3731 1
      d_print_comp (dpi, d_left (dc));
d3771 6
a3776 5
      d_append_char (dpi, '(');
      if (d_left (dc)->type != DEMANGLE_COMPONENT_CAST
	  || d_right (dc)->type != DEMANGLE_COMPONENT_BUILTIN_TYPE)
	d_print_comp (dpi, d_right (dc));
      d_append_char (dpi, ')');
a3785 9
      if (!strcmp (d_left (dc)->u.s_operator.op->code, "cl"))
	{
	  d_print_comp (dpi, d_left (d_right (dc)));
	  d_append_string (dpi, " (");
	  d_print_comp (dpi, d_right (d_right (dc)));
	  d_append_char (dpi, ')');
	  return;
	}

d3794 4
a3797 7
      d_append_char (dpi, '(');
      d_print_comp (dpi, d_left (d_right (dc)));
      d_append_string (dpi, ") ");
      d_print_expr_op (dpi, d_left (dc));
      d_append_string (dpi, " (");
      d_print_comp (dpi, d_right (d_right (dc)));
      d_append_char (dpi, ')');
d3818 1
a3818 3
      d_append_char (dpi, '(');
      d_print_comp (dpi, d_left (d_right (dc)));
      d_append_string (dpi, ") ");
d3820 3
a3822 5
      d_append_string (dpi, " (");
      d_print_comp (dpi, d_left (d_right (d_right (dc))));
      d_append_string (dpi, ") : (");
      d_print_comp (dpi, d_right (d_right (d_right (dc))));
      d_append_char (dpi, ')');
d3935 17
@


1.71
log
@merge from gcc
@
text
@d663 3
d813 1
d1429 1
a1429 1
  { "cl", NL ("()"),        0 },
d1878 6
a1883 3
  /* p */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* q */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* r */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
d1886 1
a1886 1
  /* u */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
d2056 46
d2447 29
d2479 1
d2512 6
d2546 6
a2551 1
	  args = 1;
d2563 1
d2566 5
d2574 1
a2574 2
					     left,
					     d_expression (di)));
d3622 3
a3624 1
      d_print_comp (dpi, d_right (dc));
d3635 9
d3794 6
@


1.70
log
@include/
2008-01-26  David Daney  <ddaney@@avtrex.com>

	* demangle.h (demangle_component_type):  Add
	DEMANGLE_COMPONENT_JAVA_RESOURCE,
	DEMANGLE_COMPONENT_COMPOUND_NAME, and
	DEMANGLE_COMPONENT_CHARACTER as new enum values.
	(demangle_component): Add struct s_character to union u.

libiberty/
2008-01-26  David Daney  <ddaney@@avtrex.com>

	* cp-demangle.c (d_dump): Handle DEMANGLE_COMPONENT_JAVA_RESOURCE,
	DEMANGLE_COMPONENT_COMPOUND_NAME, and
	DEMANGLE_COMPONENT_CHARACTER cases.
	(d_make_comp): Handle DEMANGLE_COMPONENT_COMPOUND_NAME and
	DEMANGLE_COMPONENT_JAVA_RESOURCE cases.
	(d_make_character): New function.
	(d_java_resource): Same.
	(d_special_name): Handle "Gr" case.
	(d_print_comp): Handle DEMANGLE_COMPONENT_JAVA_RESOURCE,
	DEMANGLE_COMPONENT_COMPOUND_NAME, and
	DEMANGLE_COMPONENT_CHARACTER cases.
	* testsuite/demangle-expected: Add test for java resource name
	mangling.
@
text
@d2 2
a3 1
   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d2685 1
a2685 1
      int id;
d2692 2
d2695 1
a2695 1
		id = id * 36 + c - '0';
d2697 1
a2697 1
		id = id * 36 + c - 'A' + 10;
d2700 1
a2700 1
	      if (id < 0)
d2702 1
d2710 1
a2710 1
      if (id >= di->next_sub)
@


1.69
log
@merge from gcc
@
text
@d653 9
d781 1
d808 1
d1515 96
d1624 1
d1716 3
d3666 14
@


1.68
log
@2007-07-31  Michael Snyder  <msnyder@@access-company.com>

	* cp-demangle.c (d_print_comp): Guard against null.
@
text
@d599 3
d791 1
d1733 1
d1900 6
d1915 1
a1915 1
			 cplus_demangle_type (di), NULL);
d3198 1
d3723 3
d3775 1
@


1.67
log
@	* cp-demangle.c (d_name): Detect local-source-name.
	(d_prefix): Likewise.
	(d_unqualified_name): Implement local-source-name.
@
text
@d2915 6
@


1.66
log
@	* cp-demangle.c (d_encoding): Exit early on error.
	(d_pointer_to_member_type): Exit early if cplus_demangle_type
	returns NULL.
	(cplus_demangle_type): Likewise.
	* testsuite/demangle-expected: New testcase.
@
text
@d1103 3
d1226 2
a1227 1
	  || peek == 'D')
d1261 3
d1285 13
@


1.65
log
@merge from gcc
@
text
@d1070 1
a1070 1
      if (peek == '\0' || peek == 'E')
d1783 1
a1783 1
      if (! d_add_substitution (di, ret))
d2138 2
@


1.64
log
@	* cp-demangle.h: Add comment explaining what to do to avoid
	overrunning string.
	(d_check_char): New.
	(d_next_char): Don't advance past trailing '\0'.
	* cp-demangle.c (cplus_demangle_mangled_name): Use d_check_char.
	(d_nested_name): Likewise.
	(d_special_name): Likewise.
	(d_call_offset): Likewise.
	(d_function_type): Likewise.
	(d_array_type): Likewise.
	(d_pointer_to_member_type): Likewise.
	(d_template_param): Likewise.
	(d_template_args): Likewise.
	(d_template_arg): Likewise.
	(d_expr_primary): Likewise.
	(d_local_name): Likewise.
	(d_substitution): Likewise.
	(d_ctor_dtor_name): Use d_advance rather than d_next_char.
	* testsuite/test-demangle.c: Include sys/mman.h.
	(MAP_ANONYMOUS): Define.
	(protect_end): New.
	(main): Use protect_end.
	* testsuite/demangle-expected: Add testcases for overrunning
	the end of the string.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
d45 4
d57 1
d64 1
d73 1
a73 1
      If defined, this file defines the following function, q.v.:
d76 6
a81 1
      instead of cplus_demangle_v3() and java_demangle_v3().
d84 3
a86 2
      If defined, this file defines only __cxa_demangle(), and no other
      publically visible functions or variables.
d97 4
d114 12
d166 4
d197 2
a198 2
   when compiled with -DIN_GLIBCPP_V3: malloc, realloc, free, memcpy,
   strcpy, strcat, strlen.  */
d263 1
a263 1
/* We use this structure to hold information during printing.  */
d265 1
a265 1
struct d_print_info
a266 2
  /* The options passed to the demangler.  */
  int options;
d273 21
d299 2
a300 2
  /* Set to 1 if we had a memory allocation failure.  */
  int allocation_failure;
a302 31
#define d_print_saw_error(dpi) ((dpi)->buf == NULL)

#define d_append_char(dpi, c) \
  do \
    { \
      if ((dpi)->buf != NULL && (dpi)->len < (dpi)->alc) \
        (dpi)->buf[(dpi)->len++] = (c); \
      else \
        d_print_append_char ((dpi), (c)); \
    } \
  while (0)

#define d_append_buffer(dpi, s, l) \
  do \
    { \
      if ((dpi)->buf != NULL && (dpi)->len + (l) <= (dpi)->alc) \
        { \
          memcpy ((dpi)->buf + (dpi)->len, (s), (l)); \
          (dpi)->len += l; \
        } \
      else \
        d_print_append_buffer ((dpi), (s), (l)); \
    } \
  while (0)

#define d_append_string_constant(dpi, s) \
  d_append_buffer (dpi, (s), sizeof (s) - 1)

#define d_last_char(dpi) \
  ((dpi)->buf == NULL || (dpi)->len == 0 ? '\0' : (dpi)->buf[(dpi)->len - 1])

d412 1
a412 1
static void d_print_resize (struct d_print_info *, size_t);
d414 2
a415 1
static void d_print_append_char (struct d_print_info *, int);
d417 3
d421 6
a426 1
d_print_append_buffer (struct d_print_info *, const char *, size_t);
d428 12
a439 1
static void d_print_error (struct d_print_info *);
d469 2
d481 5
a485 1
    return;
d2616 1
a2616 1
/* Resize the print buffer.  */
d2619 48
a2666 1
d_print_resize (struct d_print_info *dpi, size_t add)
d2670 5
a2674 1
  if (dpi->buf == NULL)
a2675 5
  need = dpi->len + add;
  while (need > dpi->alc)
    {
      size_t newalc;
      char *newbuf;
d2677 3
a2679 12
      newalc = dpi->alc * 2;
      newbuf = (char *) realloc (dpi->buf, newalc);
      if (newbuf == NULL)
	{
	  free (dpi->buf);
	  dpi->buf = NULL;
	  dpi->allocation_failure = 1;
	  return;
	}
      dpi->buf = newbuf;
      dpi->alc = newalc;
    }
d2682 1
a2682 1
/* Append a character to the print buffer.  */
d2685 1
a2685 1
d_print_append_char (struct d_print_info *dpi, int c)
d2687 1
a2687 8
  if (dpi->buf != NULL)
    {
      if (dpi->len >= dpi->alc)
	{
	  d_print_resize (dpi, 1);
	  if (dpi->buf == NULL)
	    return;
	}
d2689 1
a2689 3
      dpi->buf[dpi->len] = c;
      ++dpi->len;
    }
d2692 1
a2692 1
/* Append a buffer to the print buffer.  */
d2695 2
a2696 1
d_print_append_buffer (struct d_print_info *dpi, const char *s, size_t l)
d2698 8
a2705 8
  if (dpi->buf != NULL)
    {
      if (dpi->len + l > dpi->alc)
	{
	  d_print_resize (dpi, l);
	  if (dpi->buf == NULL)
	    return;
	}
d2707 1
a2707 3
      memcpy (dpi->buf + dpi->len, s, l);
      dpi->len += l;
    }
d2710 1
a2710 1
/* Indicate that an error occurred during printing.  */
d2712 1
a2712 1
static void
d2715 76
a2790 2
  free (dpi->buf);
  dpi->buf = NULL;
d2806 1
a2806 1
  struct d_print_info dpi;
d2808 1
a2808 1
  dpi.options = options;
d2810 3
a2812 3
  dpi.alc = estimate + 1;
  dpi.buf = (char *) malloc (dpi.alc);
  if (dpi.buf == NULL)
d2814 2
a2815 1
      *palc = 1;
d2819 2
a2820 16
  dpi.len = 0;
  dpi.templates = NULL;
  dpi.modifiers = NULL;

  dpi.allocation_failure = 0;

  d_print_comp (&dpi, dc);

  d_append_char (&dpi, '\0');

  if (dpi.buf != NULL)
    *palc = dpi.alc;
  else
    *palc = dpi.allocation_failure;

  return dpi.buf;
d2850 1
a2850 1
	d_append_string_constant (dpi, "::");
d2959 1
d2968 26
a2993 10
	d_print_comp (dpi, d_left (dc));
	if (d_last_char (dpi) == '<')
	  d_append_char (dpi, ' ');
	d_append_char (dpi, '<');
	d_print_comp (dpi, d_right (dc));
	/* Avoid generating two consecutive '>' characters, to avoid
	   the C++ syntactic ambiguity.  */
	if (d_last_char (dpi) == '>')
	  d_append_char (dpi, ' ');
	d_append_char (dpi, '>');
d3056 1
a3056 1
      d_append_string_constant (dpi, "vtable for ");
d3061 1
a3061 1
      d_append_string_constant (dpi, "VTT for ");
d3066 1
a3066 1
      d_append_string_constant (dpi, "construction vtable for ");
d3068 1
a3068 1
      d_append_string_constant (dpi, "-in-");
d3073 1
a3073 1
      d_append_string_constant (dpi, "typeinfo for ");
d3078 1
a3078 1
      d_append_string_constant (dpi, "typeinfo name for ");
d3083 1
a3083 1
      d_append_string_constant (dpi, "typeinfo fn for ");
d3088 1
a3088 1
      d_append_string_constant (dpi, "non-virtual thunk to ");
d3093 1
a3093 1
      d_append_string_constant (dpi, "virtual thunk to ");
d3098 1
a3098 1
      d_append_string_constant (dpi, "covariant return thunk to ");
d3103 1
a3103 1
      d_append_string_constant (dpi, "java Class for ");
d3108 1
a3108 1
      d_append_string_constant (dpi, "guard variable for ");
d3113 1
a3113 1
      d_append_string_constant (dpi, "reference temporary for ");
d3118 1
a3118 1
      d_append_string_constant (dpi, "hidden alias for ");
d3317 1
a3317 1
	    d_append_string_constant (dpi, "::*");
d3330 1
a3330 1
	  d_append_string_constant (dpi, ", ");
d3339 1
a3339 1
	d_append_string_constant (dpi, "operator");
d3349 1
a3349 1
      d_append_string_constant (dpi, "operator ");
d3354 1
a3354 1
      d_append_string_constant (dpi, "operator ");
d3389 1
a3389 1
      d_append_string_constant (dpi, ") ");
d3391 1
a3391 1
      d_append_string_constant (dpi, " (");
d3416 1
a3416 1
      d_append_string_constant (dpi, ") ");
d3418 1
a3418 1
      d_append_string_constant (dpi, " (");
d3420 1
a3420 1
      d_append_string_constant (dpi, ") : (");
d3465 1
a3465 1
			d_append_string_constant (dpi, "ul");
d3468 1
a3468 1
			d_append_string_constant (dpi, "ll");
d3471 1
a3471 1
			d_append_string_constant (dpi, "ull");
d3486 1
a3486 1
			d_append_string_constant (dpi, "false");
d3489 1
a3489 1
			d_append_string_constant (dpi, "true");
d3628 1
a3628 1
	d_append_string_constant (dpi, "::");
d3661 1
a3661 1
      d_append_string_constant (dpi, " restrict");
d3665 1
a3665 1
      d_append_string_constant (dpi, " volatile");
d3669 1
a3669 1
      d_append_string_constant (dpi, " const");
d3684 1
a3684 1
      d_append_string_constant (dpi, "complex ");
d3687 1
a3687 1
      d_append_string_constant (dpi, "imaginary ");
d3693 1
a3693 1
      d_append_string_constant (dpi, "::*");
d3826 1
a3826 1
	d_append_string_constant (dpi, " (");
d3932 4
a3935 6
/* Entry point for the demangler.  If MANGLED is a g++ v3 ABI mangled
   name, return a buffer allocated with malloc holding the demangled
   name.  OPTIONS is the usual libiberty demangler options.  On
   success, this sets *PALC to the allocated size of the returned
   buffer.  On failure, this sets *PALC to 0 for a bad name, or 1 for
   a memory allocation failure.  On failure, this returns NULL.  */
d3937 3
a3939 2
static char *
d_demangle (const char* mangled, int options, size_t *palc)
a3940 1
  size_t len;
d3944 1
a3944 6
  int estimate;
  char *ret;

  *palc = 0;

  len = strlen (mangled);
d3953 5
a3957 1
      char *r;
d3959 3
a3961 12
      r = (char *) malloc (40 + len - 11);
      if (r == NULL)
	*palc = 1;
      else
	{
	  if (mangled[9] == 'I')
	    strcpy (r, "global constructors keyed to ");
	  else
	    strcpy (r, "global destructors keyed to ");
	  strcat (r, mangled + 11);
	}
      return r;
d3966 1
a3966 1
	return NULL;
d3970 1
a3970 1
  cplus_demangle_init_info (mangled, options, len, &di);
d3977 2
a3978 2
    di.comps = &comps[0];
    di.subs = &subs[0];
d3980 2
a3981 13
    di.comps = ((struct demangle_component *)
		malloc (di.num_comps * sizeof (struct demangle_component)));
    di.subs = ((struct demangle_component **)
	       malloc (di.num_subs * sizeof (struct demangle_component *)));
    if (di.comps == NULL || di.subs == NULL)
      {
	if (di.comps != NULL)
	  free (di.comps);
	if (di.subs != NULL)
	  free (di.subs);
	*palc = 1;
	return NULL;
      }
d3984 3
a3986 1
    if (! type)
a3987 2
    else
      dc = cplus_demangle_type (&di);
d3997 1
a3997 4
    if (dc == NULL)
      printf ("failed demangling\n");
    else
      d_dump (dc, 0);
d4000 20
a4019 13
    /* We try to guess the length of the demangled string, to minimize
       calls to realloc during demangling.  */
    estimate = len + di.expansion + 10 * di.did_subs;
    estimate += estimate / 8;

    ret = NULL;
    if (dc != NULL)
      ret = cplus_demangle_print (options, dc, estimate, palc);

#ifndef CP_DYNAMIC_ARRAYS
    free (di.comps);
    free (di.subs);
#endif
d4021 1
a4021 4
#ifdef CP_DEMANGLE_DEBUG
    if (ret != NULL)
      {
	int rlen;
d4023 8
a4030 13
	rlen = strlen (ret);
	if (rlen > 2 * estimate)
	  printf ("*** Length %d much greater than estimate %d\n",
		  rlen, estimate);
	else if (rlen > estimate)
	  printf ("*** Length %d greater than estimate %d\n",
		  rlen, estimate);
	else if (rlen < estimate / 2)
	  printf ("*** Length %d much less than estimate %d\n",
		  rlen, estimate);
      }
#endif
  }
d4032 2
a4033 1
  return ret;
d4050 1
a4050 1
   If LENGTH is non-NULL, the length of the buffer conaining the
d4127 42
d4176 1
a4176 1
cplus_demangle_v3 (const char* mangled, int options)
d4183 7
d4192 3
a4194 4
   This instructs the C++ demangler not to emit pointer characters ("*"), and 
   to use Java's namespace separator symbol ("." instead of "::").  It then 
   does an additional pass over the demangled output to replace instances 
   of JArray<TYPE> with TYPE[].  */
d4197 1
a4197 1
java_demangle_v3 (const char* mangled)
a4199 4
  char *demangled;
  int nesting;
  char *from;
  char *to;
d4201 2
a4202 2
  demangled = d_demangle (mangled, DMGL_JAVA | DMGL_PARAMS | DMGL_RET_POSTFIX, 
			  &alc);
d4204 7
a4210 29
  if (demangled == NULL)
    return NULL;

  nesting = 0;
  from = demangled;
  to = from;
  while (*from != '\0')
    {
      if (strncmp (from, "JArray<", 7) == 0)
	{
	  from += 7;
	  ++nesting;
	}
      else if (nesting > 0 && *from == '>')
	{
	  while (to > demangled && to[-1] == ' ')
	    --to;
	  *to++ = '[';
	  *to++ = ']';
	  --nesting;
	  ++from;
	}
      else
	*to++ = *from++;
    }

  *to = '\0';

  return demangled;
d4240 2
a4241 2
    di.comps = &comps[0];
    di.subs = &subs[0];
d4243 2
a4244 12
    di.comps = ((struct demangle_component *)
		malloc (di.num_comps * sizeof (struct demangle_component)));
    di.subs = ((struct demangle_component **)
	       malloc (di.num_subs * sizeof (struct demangle_component *)));
    if (di.comps == NULL || di.subs == NULL)
      {
	if (di.comps != NULL)
	  free (di.comps);
	if (di.subs != NULL)
	  free (di.subs);
	return 0;
      }
a4282 5

#ifndef CP_DYNAMIC_ARRAYS
    free (di.subs);
    free (di.comps);
#endif
@


1.63
log
@merge from gcc
@
text
@d916 1
a916 1
  if (d_next_char (di) != '_')
d918 1
a918 1
  if (d_next_char (di) != 'Z')
d1126 1
a1126 1
  if (d_next_char (di) != 'N')
d1137 1
a1137 1
  if (d_next_char (di) != 'E')
a1451 2
  char c;

d1453 1
a1453 2
  c = d_next_char (di);
  if (c == 'T')
d1502 1
a1502 1
	    if (d_next_char (di) != '_')
d1523 1
a1523 1
  else if (c == 'G')
d1570 1
a1570 1
      if (d_next_char (di) != '_')
d1577 1
a1577 1
  if (d_next_char (di) != '_')
d1601 1
a1601 1
  switch (d_next_char (di))
d1607 1
a1607 1
	switch (d_next_char (di))
d1621 1
d1629 1
a1629 1
	switch (d_next_char (di))
d1643 1
d1927 1
a1927 1
  if (d_next_char (di) != 'F')
d1936 1
a1936 1
  if (d_next_char (di) != 'E')
d2023 1
a2023 1
  if (d_next_char (di) != 'A')
d2051 1
a2051 1
  if (d_next_char (di) != '_')
d2067 1
a2067 1
  if (d_next_char (di) != 'M')
d2111 1
a2111 1
  if (d_next_char (di) != 'T')
d2124 1
a2124 1
  if (d_next_char (di) != '_')
d2146 1
a2146 1
  if (d_next_char (di) != 'I')
d2191 1
a2191 1
      if (d_next_char (di) != 'E')
d2318 1
a2318 1
  if (d_next_char (di) != 'L')
d2364 1
a2364 1
  if (d_next_char (di) != 'E')
d2378 1
a2378 1
  if (d_next_char (di) != 'Z')
d2383 1
a2383 1
  if (d_next_char (di) != 'E')
d2488 1
a2488 1
  if (d_next_char (di) != 'S')
@


1.62
log
@merge from gcc
@
text
@d2508 2
@


1.61
log
@merge from gcc
@
text
@d2084 4
a2087 1
     avoid calling add_substitution() in cplus_demangle_type().  */
d2094 6
@


1.60
log
@merge from gcc
@
text
@d1942 1
a1942 1
/* <bare-function-type> ::= <type>+  */
d1950 10
a1965 1
      char peek;
d3037 4
a3046 1

d3060 4
a3063 1
	    d_append_char (dpi, ' ');
d3066 2
a3067 1
	d_print_function_type (dpi, dc, dpi->modifiers);
d4022 2
a4023 1
  demangled = d_demangle (mangled, DMGL_JAVA | DMGL_PARAMS, &alc);
@


1.59
log
@include/
	* demangle.h (DEMANGLE_COMPONENT_HIDDEN_ALIAS): New.
libiberty/
	* cp-demangle.c (d_dump): Handle DEMANGLE_COMPONENT_HIDDEN_ALIAS.
	(d_make_comp, d_print_comp): Likewise.
	(d_special_name): Generate one.
	* testsuite/demangle-expected: Add a hidden alias test.
@
text
@d2340 5
a2344 1
	d_advance (di, 1);
@


1.58
log
@merge from gcc
@
text
@d523 3
d739 1
d1446 1
d1537 4
d2943 5
@


1.57
log
@Update the address and phone number of the FSF organization.
@
text
@d213 1
a213 1
  const struct demangle_component *template;
d2554 1
a2554 1
      newbuf = realloc (dpi->buf, newalc);
d2632 1
a2632 1
  dpi.buf = malloc (dpi.alc);
d2733 1
a2733 1
	    dpt.template = typed_name;
d2829 1
a2829 1
	for (a = d_right (dpi->templates->template);
d3686 1
a3686 1
      dpt.template = d_left (dc);
d3767 1
a3767 1
      r = malloc (40 + len - 11);
@


1.56
log
@	* cp-demangle.c: Update copyright.
@
text
@d28 1
a28 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
@


1.55
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
@


1.54
log
@merge from gcc
@
text
@d4147 1
a4147 1
static void print_usage PARAMS ((FILE* fp, int exit_value));
@


1.53
log
@        * cp-demangle.c (__cxa_demangle): Change resolution of ambiguous
        arguments.
@
text
@d112 1
a112 2
static int
d_fill_name PARAMS ((struct demangle_component *, const char *, int));
d116 2
a117 2
d_fill_extended_operator PARAMS ((struct demangle_component *, int,
				  struct demangle_component *));
d121 2
a122 2
d_fill_ctor PARAMS ((struct demangle_component *, enum gnu_v3_ctor_kinds,
		     struct demangle_component *));
d126 2
a127 2
d_fill_dtor PARAMS ((struct demangle_component *, enum gnu_v3_dtor_kinds,
		     struct demangle_component *));
d130 1
a130 2
static struct demangle_component *
d_mangled_name PARAMS ((struct d_info *, int));
d133 1
a133 2
static struct demangle_component *
d_type PARAMS ((struct d_info *));
d136 1
a136 2
static char *
d_print PARAMS ((int, const struct demangle_component *, int, size_t *));
d139 1
a139 2
static void
d_init_info PARAMS ((const char *, int, size_t, struct d_info *));
d284 1
a284 2
static void 
d_dump PARAMS ((struct demangle_component *, int));
d288 1
a288 1
d_make_empty PARAMS ((struct d_info *));
d291 3
a293 3
d_make_comp PARAMS ((struct d_info *, enum demangle_component_type,
		     struct demangle_component *,
		     struct demangle_component *));
d296 1
a296 1
d_make_name PARAMS ((struct d_info *, const char *, int));
d299 2
a300 2
d_make_builtin_type PARAMS ((struct d_info *,
			     const struct demangle_builtin_type_info *));
d303 2
a304 2
d_make_operator PARAMS ((struct d_info *,
			 const struct demangle_operator_info *));
d307 2
a308 2
d_make_extended_operator PARAMS ((struct d_info *, int,
				  struct demangle_component *));
d311 2
a312 2
d_make_ctor PARAMS ((struct d_info *, enum gnu_v3_ctor_kinds,
		     struct demangle_component *));
d315 2
a316 2
d_make_dtor PARAMS ((struct d_info *, enum gnu_v3_dtor_kinds,
		     struct demangle_component *));
d319 1
a319 1
d_make_template_param PARAMS ((struct d_info *, long));
d322 1
a322 1
d_make_sub PARAMS ((struct d_info *, const char *, int));
d325 1
a325 1
has_return_type PARAMS ((struct demangle_component *));
d328 1
a328 1
is_ctor_dtor_or_conversion PARAMS ((struct demangle_component *));
d330 1
a330 2
static struct demangle_component *
d_encoding PARAMS ((struct d_info *, int));
d332 1
a332 2
static struct demangle_component *
d_name PARAMS ((struct d_info *));
d334 1
a334 2
static struct demangle_component *
d_nested_name PARAMS ((struct d_info *));
d336 1
a336 2
static struct demangle_component *
d_prefix PARAMS ((struct d_info *));
d338 1
a338 2
static struct demangle_component *
d_unqualified_name PARAMS ((struct d_info *));
d340 1
a340 2
static struct demangle_component *
d_source_name PARAMS ((struct d_info *));
d342 1
a342 2
static long
d_number PARAMS ((struct d_info *));
d344 1
a344 2
static struct demangle_component *
d_identifier PARAMS ((struct d_info *, int));
d346 1
a346 2
static struct demangle_component *
d_operator_name PARAMS ((struct d_info *));
d348 1
a348 2
static struct demangle_component *
d_special_name PARAMS ((struct d_info *));
d350 1
a350 2
static int
d_call_offset PARAMS ((struct d_info *, int));
d352 1
a352 2
static struct demangle_component *
d_ctor_dtor_name PARAMS ((struct d_info *));
d355 1
a355 1
d_cv_qualifiers PARAMS ((struct d_info *, struct demangle_component **, int));
d358 1
a358 1
d_function_type PARAMS ((struct d_info *));
d361 1
a361 1
d_bare_function_type PARAMS ((struct d_info *, int));
d364 1
a364 1
d_class_enum_type PARAMS ((struct d_info *));
d366 1
a366 2
static struct demangle_component *
d_array_type PARAMS ((struct d_info *));
d369 1
a369 1
d_pointer_to_member_type PARAMS ((struct d_info *));
d372 1
a372 1
d_template_param PARAMS ((struct d_info *));
d374 1
a374 2
static struct demangle_component *
d_template_args PARAMS ((struct d_info *));
d377 1
a377 1
d_template_arg PARAMS ((struct d_info *));
d379 1
a379 2
static struct demangle_component *
d_expression PARAMS ((struct d_info *));
d381 1
a381 2
static struct demangle_component *
d_expr_primary PARAMS ((struct d_info *));
d383 1
a383 2
static struct demangle_component *
d_local_name PARAMS ((struct d_info *));
d385 1
a385 2
static int
d_discriminator PARAMS ((struct d_info *));
d388 1
a388 1
d_add_substitution PARAMS ((struct d_info *, struct demangle_component *));
d390 1
a390 2
static struct demangle_component *
d_substitution PARAMS ((struct d_info *, int));
d392 1
a392 2
static void
d_print_resize PARAMS ((struct d_print_info *, size_t));
d394 1
a394 2
static void
d_print_append_char PARAMS ((struct d_print_info *, int));
d397 1
a397 1
d_print_append_buffer PARAMS ((struct d_print_info *, const char *, size_t));
d399 1
a399 2
static void
d_print_error PARAMS ((struct d_print_info *));
d402 1
a402 2
d_print_comp PARAMS ((struct d_print_info *,
		      const struct demangle_component *));
d405 1
a405 1
d_print_java_identifier PARAMS ((struct d_print_info *, const char *, int));
d408 1
a408 1
d_print_mod_list PARAMS ((struct d_print_info *, struct d_print_mod *, int));
d411 1
a411 2
d_print_mod PARAMS ((struct d_print_info *,
		     const struct demangle_component *));
d414 3
a416 3
d_print_function_type PARAMS ((struct d_print_info *,
			       const struct demangle_component *,
			       struct d_print_mod *));
d419 3
a421 3
d_print_array_type PARAMS ((struct d_print_info *,
			    const struct demangle_component *,
			    struct d_print_mod *));
d424 1
a424 2
d_print_expr_op PARAMS ((struct d_print_info *,
			 const struct demangle_component *));
d427 1
a427 2
d_print_cast PARAMS ((struct d_print_info *,
		      const struct demangle_component *));
d429 1
a429 2
static char *
d_demangle PARAMS ((const char *, int, size_t *));
d434 1
a434 3
d_dump (dc, indent)
     struct demangle_component *dc;
     int indent;
d613 1
a613 4
cplus_demangle_fill_name (p, s, len)
     struct demangle_component *p;
     const char *s;
     int len;
d627 2
a628 4
cplus_demangle_fill_extended_operator (p, args, name)
     struct demangle_component *p;
     int args;
     struct demangle_component *name;
d642 3
a644 4
cplus_demangle_fill_ctor (p, kind, name)
     struct demangle_component *p;
     enum gnu_v3_ctor_kinds kind;
     struct demangle_component *name;
d661 3
a663 4
cplus_demangle_fill_dtor (p, kind, name)
     struct demangle_component *p;
     enum gnu_v3_dtor_kinds kind;
     struct demangle_component *name;
d679 1
a679 2
d_make_empty (di)
     struct d_info *di;
d693 3
a695 5
d_make_comp (di, type, left, right)
     struct d_info *di;
     enum demangle_component_type type;
     struct demangle_component *left;
     struct demangle_component *right;
d784 1
a784 4
d_make_name (di, s, len)
     struct d_info *di;
     const char *s;
     int len;
d797 2
a798 3
d_make_builtin_type (di, type)
     struct d_info *di;
     const struct demangle_builtin_type_info *type;
d816 1
a816 3
d_make_operator (di, op)
     struct d_info *di;
     const struct demangle_operator_info *op;
d832 2
a833 4
d_make_extended_operator (di, args, name)
     struct d_info *di;
     int args;
     struct demangle_component *name;
d846 2
a847 4
d_make_ctor (di, kind,  name)
     struct d_info *di;
     enum gnu_v3_ctor_kinds kind;
     struct demangle_component *name;
d860 2
a861 4
d_make_dtor (di, kind, name)
     struct d_info *di;
     enum gnu_v3_dtor_kinds kind;
     struct demangle_component *name;
d874 1
a874 3
d_make_template_param (di, i)
     struct d_info *di;
     long i;
d890 1
a890 4
d_make_sub (di, name, len)
     struct d_info *di;
     const char *name;
     int len;
d910 1
a910 3
cplus_demangle_mangled_name (di, top_level)
     struct d_info *di;
     int top_level;
d929 1
a929 2
has_return_type (dc)
     struct demangle_component *dc;
d950 1
a950 2
is_ctor_dtor_or_conversion (dc)
     struct demangle_component *dc;
d978 1
a978 3
d_encoding (di, top_level)
     struct d_info *di;
     int top_level;
d1040 1
a1040 2
d_name (di)
     struct d_info *di;
d1117 1
a1117 2
d_nested_name (di)
     struct d_info *di;
d1151 1
a1151 2
d_prefix (di)
     struct d_info *di;
d1210 1
a1210 2
d_unqualified_name (di)
     struct d_info *di;
d1235 1
a1235 2
d_source_name (di)
     struct d_info *di;
d1251 1
a1251 2
d_number (di)
     struct d_info *di;
d1284 1
a1284 3
d_identifier (di, len)
     struct d_info *di;
     int len;
d1387 1
a1387 2
d_operator_name (di)
     struct d_info *di;
d1445 1
a1445 2
d_special_name (di)
     struct d_info *di;
d1554 1
a1554 3
d_call_offset (di, c)
     struct d_info *di;
     int c;
d1586 1
a1586 2
d_ctor_dtor_name (di)
     struct d_info *di;
d1699 1
a1699 2
cplus_demangle_type (di)
     struct d_info *di;
d1868 2
a1869 4
d_cv_qualifiers (di, pret, member_fn)
     struct d_info *di;
     struct demangle_component **pret;
     int member_fn;
d1915 1
a1915 2
d_function_type (di)
     struct d_info *di;
d1936 1
a1936 3
d_bare_function_type (di, has_return_type)
     struct d_info *di;
     int has_return_type;
d1991 1
a1991 2
d_class_enum_type (di)
     struct d_info *di;
d2001 1
a2001 2
d_array_type (di)
     struct d_info *di;
d2044 1
a2044 2
d_pointer_to_member_type (di)
     struct d_info *di;
d2081 1
a2081 2
d_template_param (di)
     struct d_info *di;
d2109 1
a2109 2
d_template_args (di)
     struct d_info *di;
d2156 1
a2156 2
d_template_arg (di)
     struct d_info *di;
d2188 1
a2188 2
d_expression (di)
     struct d_info *di;
d2288 1
a2288 2
d_expr_primary (di)
     struct d_info *di;
d2344 1
a2344 2
d_local_name (di)
     struct d_info *di;
d2382 1
a2382 2
d_discriminator (di)
     struct d_info *di;
d2398 1
a2398 3
d_add_substitution (di, dc)
     struct d_info *di;
     struct demangle_component *dc;
d2454 1
a2454 3
d_substitution (di, prefix)
     struct d_info *di;
     int prefix;
d2541 1
a2541 3
d_print_resize (dpi, add)
     struct d_print_info *dpi;
     size_t add;
d2570 1
a2570 3
d_print_append_char (dpi, c)
     struct d_print_info *dpi;
     int c;
d2589 1
a2589 4
d_print_append_buffer (dpi, s, l)
     struct d_print_info *dpi;
     const char *s;
     size_t l;
d2608 1
a2608 2
d_print_error (dpi)
     struct d_print_info *dpi;
d2624 2
a2625 5
cplus_demangle_print (options, dc, estimate, palc)
     int options;
     const struct demangle_component *dc;
     int estimate;
     size_t *palc;
d2660 2
a2661 3
d_print_comp (dpi, dc)
     struct d_print_info *dpi;
     const struct demangle_component *dc;
d3332 1
a3332 4
d_print_java_identifier (dpi, name, len)
     struct d_print_info *dpi;
     const char *name;
     int len;
d3382 2
a3383 4
d_print_mod_list (dpi, mods, suffix)
     struct d_print_info *dpi;
     struct d_print_mod *mods;
     int suffix;
d3459 2
a3460 3
d_print_mod (dpi, mod)
     struct d_print_info *dpi;
     const struct demangle_component *mod;
d3514 3
a3516 4
d_print_function_type (dpi, dc, mods)
     struct d_print_info *dpi;
     const struct demangle_component *dc;
     struct d_print_mod *mods;
d3599 3
a3601 4
d_print_array_type (dpi, dc, mods)
     struct d_print_info *dpi;
     const struct demangle_component *dc;
     struct d_print_mod *mods;
d3653 2
a3654 3
d_print_expr_op (dpi, dc)
     struct d_print_info *dpi;
     const struct demangle_component *dc;
d3666 2
a3667 3
d_print_cast (dpi, dc)
     struct d_print_info *dpi;
     const struct demangle_component *dc;
d3711 2
a3712 5
cplus_demangle_init_info (mangled, options, len, di)
     const char *mangled;
     int options;
     size_t len;
     struct d_info *di;
d3745 1
a3745 4
d_demangle (mangled, options, palc)
     const char* mangled;
     int options;
     size_t *palc;
d3869 1
a3869 1
extern char *__cxa_demangle PARAMS ((const char *, char *, size_t *, int *));
d3898 2
a3899 5
__cxa_demangle (mangled_name, output_buffer, length, status)
     const char *mangled_name;
     char *output_buffer;
     size_t *length;
     int *status;
d3965 1
a3965 3
cplus_demangle_v3 (mangled, options)
     const char* mangled;
     int options;
d3980 1
a3980 2
java_demangle_v3 (mangled)
     const char* mangled;
d4030 3
a4032 4
is_ctor_or_dtor (mangled, ctor_kind, dtor_kind)
     const char *mangled;
     enum gnu_v3_ctor_kinds *ctor_kind;
     enum gnu_v3_dtor_kinds *dtor_kind;
d4115 1
a4115 2
is_gnu_v3_mangled_ctor (name)
     const char *name;
d4130 1
a4130 2
is_gnu_v3_mangled_dtor (name)
     const char *name;
d4164 1
a4164 3
print_usage (fp, exit_value)
     FILE* fp;
     int exit_value;
d4191 1
a4191 3
main (argc, argv)
     int argc;
     char *argv[];
@


1.52
log
@merge from gcc
@
text
@a4049 15
  /* The specification for __cxa_demangle() is that if the mangled
     name could be either an extern "C" identifier, or an internal
     built-in type name, then we resolve it as the identifier.  All
     internal built-in type names are a single lower case character.
     Frankly, this simplistic disambiguation doesn't make sense to me,
     but it is documented, so we implement it here.  */
  if (IS_LOWER (mangled_name[0])
      && mangled_name[1] == '\0'
      && cplus_demangle_builtin_types[mangled_name[0] - 'a'].name != NULL)
    {
      if (status != NULL)
	*status = -2;
      return NULL;
    }

@


1.51
log
@merge from gcc
@
text
@a1635 3
  long offset;
  long virtual_offset;

d1640 1
a1640 1
    offset = d_number (di);
d1643 1
a1643 1
      offset = d_number (di);
d1646 1
a1646 1
      virtual_offset = d_number (di);
@


1.50
log
@merge from gcc
@
text
@d2401 2
@


1.49
log
@merge from gcc
@
text
@d1751 1
a1751 1
  /* a */ { NL ("signed char"),	NL ("signed char"),	D_PRINT_INT },
d1753 6
a1758 6
  /* c */ { NL ("char"),	NL ("byte"),		D_PRINT_INT },
  /* d */ { NL ("double"),	NL ("double"),		D_PRINT_DEFAULT },
  /* e */ { NL ("long double"),	NL ("long double"),	D_PRINT_DEFAULT },
  /* f */ { NL ("float"),	NL ("float"),		D_PRINT_DEFAULT },
  /* g */ { NL ("__float128"),	NL ("__float128"),	D_PRINT_DEFAULT },
  /* h */ { NL ("unsigned char"), NL ("unsigned char"),	D_PRINT_INT },
d1760 1
a1760 1
  /* j */ { NL ("unsigned int"), NL ("unsigned"),	D_PRINT_INT },
d1763 1
a1763 1
  /* m */ { NL ("unsigned long"), NL ("unsigned long"),	D_PRINT_LONG },
d1765 2
a1766 1
  /* o */ { NL ("unsigned __int128"), NL ("unsigned __int128"),	D_PRINT_DEFAULT },
d1770 2
a1771 2
  /* s */ { NL ("short"),	NL ("short"),		D_PRINT_INT },
  /* t */ { NL ("unsigned short"), NL ("unsigned short"), D_PRINT_INT },
d1774 4
a1777 3
  /* w */ { NL ("wchar_t"),	NL ("char"),		D_PRINT_INT },
  /* x */ { NL ("long long"),	NL ("long"),		D_PRINT_DEFAULT },
  /* y */ { NL ("unsigned long long"), NL ("unsigned long long"), D_PRINT_DEFAULT },
d3352 2
a3353 14
      /* For some builtin types, produce simpler output.  */
      if (d_left (dc)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE)
	{
	  switch (d_left (dc)->u.s_builtin.type->print)
	    {
	    case D_PRINT_INT:
	      if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME)
		{
		  if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
		    d_append_char (dpi, '-');
		  d_print_comp (dpi, d_right (dc));
		  return;
		}
	      break;
d3355 41
a3395 10
	    case D_PRINT_LONG:
	      if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME)
		{
		  if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
		    d_append_char (dpi, '-');
		  d_print_comp (dpi, d_right (dc));
		  d_append_char (dpi, 'l');
		  return;
		}
	      break;
d3397 18
a3414 18
	    case D_PRINT_BOOL:
	      if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME
		  && d_right (dc)->u.s_name.len == 1
		  && dc->type == DEMANGLE_COMPONENT_LITERAL)
		{
		  switch (d_right (dc)->u.s_name.s[0])
		    {
		    case '0':
		      d_append_string_constant (dpi, "false");
		      return;
		    case '1':
		      d_append_string_constant (dpi, "true");
		      return;
		    default:
		      break;
		    }
		}
	      break;
d3416 4
a3419 4
	    default:
	      break;
	    }
	}
d3421 11
a3431 6
      d_append_char (dpi, '(');
      d_print_comp (dpi, d_left (dc));
      d_append_char (dpi, ')');
      if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
	d_append_char (dpi, '-');
      d_print_comp (dpi, d_right (dc));
d3641 1
d3647 1
d3656 4
a3663 2
	case DEMANGLE_COMPONENT_POINTER:
	case DEMANGLE_COMPONENT_REFERENCE:
d3667 1
d3686 1
a3686 1
      switch (d_last_char (dpi))
d3688 3
a3690 8
	case ' ':
	case '(':
	case '*':
	  break;

	default:
	  d_append_char (dpi, ' ');
	  break;
d3692 2
a3693 1

@


1.48
log
@merge from gcc
@
text
@d3280 1
a3280 1
	  d_append_string_constant (dpi, "((");
a3286 2
      if (d_left (dc)->type == DEMANGLE_COMPONENT_CAST)
	d_append_char (dpi, ')');
@


1.47
log
@	* cp-demangle.c (d_make_comp): DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE
	takes two parameters.
	* cp-demint.c (cplus_demangle_fill_component): Likewise.
@
text
@d3053 24
d3152 4
a3155 1
	struct d_print_mod dpm;
d3158 36
a3193 1
	   multi-dimensional arrays correctly.  */
d3195 2
a3196 5
	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;
d3200 1
a3200 1
	dpi->modifiers = dpm.next;
d3202 1
a3202 1
	if (dpm.printed)
d3205 6
d3711 1
a3711 4
	  if (p->printed)
	    break;

	  if (p->mod->type == DEMANGLE_COMPONENT_ARRAY_TYPE)
d3713 11
a3723 8
	      need_space = 0;
	      break;
	    }
	  else
	    {
	      need_paren = 1;
	      need_space = 1;
	      break;
a4011 3
  if (status == NULL)
    return NULL;

d4014 2
a4015 1
      *status = -3;
d4021 2
a4022 1
      *status = -3;
d4026 16
a4041 1
  demangled = d_demangle (mangled_name, DMGL_TYPES, &alc);
d4045 7
a4051 4
      if (alc == 1)
	*status = -1;
      else
	*status = -2;
d4075 2
a4076 1
  *status = 0;
d4382 3
d4386 1
d4418 3
d4423 3
d4427 1
d4436 7
a4442 1
	    fprintf (stderr, "Failed: %s\n", argv[i]);
@


1.47.8.1
log
@Merge mainline to intercu branch.
@
text
@d1751 1
a1751 1
  /* a */ { NL ("signed char"),	NL ("signed char"),	D_PRINT_DEFAULT },
d1753 6
a1758 6
  /* c */ { NL ("char"),	NL ("byte"),		D_PRINT_DEFAULT },
  /* d */ { NL ("double"),	NL ("double"),		D_PRINT_FLOAT },
  /* e */ { NL ("long double"),	NL ("long double"),	D_PRINT_FLOAT },
  /* f */ { NL ("float"),	NL ("float"),		D_PRINT_FLOAT },
  /* g */ { NL ("__float128"),	NL ("__float128"),	D_PRINT_FLOAT },
  /* h */ { NL ("unsigned char"), NL ("unsigned char"),	D_PRINT_DEFAULT },
d1760 1
a1760 1
  /* j */ { NL ("unsigned int"), NL ("unsigned"),	D_PRINT_UNSIGNED },
d1763 1
a1763 1
  /* m */ { NL ("unsigned long"), NL ("unsigned long"),	D_PRINT_UNSIGNED_LONG },
d1765 1
a1765 2
  /* o */ { NL ("unsigned __int128"), NL ("unsigned __int128"),
	    D_PRINT_DEFAULT },
d1769 2
a1770 2
  /* s */ { NL ("short"),	NL ("short"),		D_PRINT_DEFAULT },
  /* t */ { NL ("unsigned short"), NL ("unsigned short"), D_PRINT_DEFAULT },
d1773 3
a1775 4
  /* w */ { NL ("wchar_t"),	NL ("char"),		D_PRINT_DEFAULT },
  /* x */ { NL ("long long"),	NL ("long"),		D_PRINT_LONG_LONG },
  /* y */ { NL ("unsigned long long"), NL ("unsigned long long"),
	    D_PRINT_UNSIGNED_LONG_LONG },
a3052 24
      {
	struct d_print_mod *pdpm;

	/* When printing arrays, it's possible to have cases where the
	   same CV-qualifier gets pushed on the stack multiple times.
	   We only need to print it once.  */

	for (pdpm = dpi->modifiers; pdpm != NULL; pdpm = pdpm->next)
	  {
	    if (! pdpm->printed)
	      {
		if (pdpm->mod->type != DEMANGLE_COMPONENT_RESTRICT
		    && pdpm->mod->type != DEMANGLE_COMPONENT_VOLATILE
		    && pdpm->mod->type != DEMANGLE_COMPONENT_CONST)
		  break;
		if (pdpm->mod->type == dc->type)
		  {
		    d_print_comp (dpi, d_left (dc));
		    return;
		  }
	      }
	  }
      }
      /* Fall through.  */
d3128 1
a3128 4
	struct d_print_mod *hold_modifiers;
	struct d_print_mod adpm[4];
	unsigned int i;
	struct d_print_mod *pdpm;
d3131 1
a3131 6
	   multi-dimensional arrays correctly.  If the array itself is
	   CV-qualified, we act as though the element type were
	   CV-qualified.  We do this by copying the modifiers down
	   rather than fiddling pointers, so that we don't wind up
	   with a d_print_mod higher on the stack pointing into our
	   stack frame after we return.  */
d3133 5
a3137 32
	hold_modifiers = dpi->modifiers;

	adpm[0].next = hold_modifiers;
	dpi->modifiers = &adpm[0];
	adpm[0].mod = dc;
	adpm[0].printed = 0;
	adpm[0].templates = dpi->templates;

	i = 1;
	pdpm = hold_modifiers;
	while (pdpm != NULL
	       && (pdpm->mod->type == DEMANGLE_COMPONENT_RESTRICT
		   || pdpm->mod->type == DEMANGLE_COMPONENT_VOLATILE
		   || pdpm->mod->type == DEMANGLE_COMPONENT_CONST))
	  {
	    if (! pdpm->printed)
	      {
		if (i >= sizeof adpm / sizeof adpm[0])
		  {
		    d_print_error (dpi);
		    return;
		  }

		adpm[i] = *pdpm;
		adpm[i].next = dpi->modifiers;
		dpi->modifiers = &adpm[i];
		pdpm->printed = 1;
		++i;
	      }

	    pdpm = pdpm->next;
	  }
d3141 1
a3141 1
	dpi->modifiers = hold_modifiers;
d3143 1
a3143 1
	if (adpm[0].printed)
a3145 6
	while (i > 1)
	  {
	    --i;
	    d_print_mod (dpi, adpm[i].mod);
	  }

d3215 1
a3215 1
	  d_append_char (dpi, '(');
d3222 2
d3287 14
a3300 2
      {
	enum d_builtin_type_print tp;
d3302 10
a3311 41
	/* For some builtin types, produce simpler output.  */
	tp = D_PRINT_DEFAULT;
	if (d_left (dc)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE)
	  {
	    tp = d_left (dc)->u.s_builtin.type->print;
	    switch (tp)
	      {
	      case D_PRINT_INT:
	      case D_PRINT_UNSIGNED:
	      case D_PRINT_LONG:
	      case D_PRINT_UNSIGNED_LONG:
	      case D_PRINT_LONG_LONG:
	      case D_PRINT_UNSIGNED_LONG_LONG:
		if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME)
		  {
		    if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
		      d_append_char (dpi, '-');
		    d_print_comp (dpi, d_right (dc));
		    switch (tp)
		      {
		      default:
			break;
		      case D_PRINT_UNSIGNED:
			d_append_char (dpi, 'u');
			break;
		      case D_PRINT_LONG:
			d_append_char (dpi, 'l');
			break;
		      case D_PRINT_UNSIGNED_LONG:
			d_append_string_constant (dpi, "ul");
			break;
		      case D_PRINT_LONG_LONG:
			d_append_string_constant (dpi, "ll");
			break;
		      case D_PRINT_UNSIGNED_LONG_LONG:
			d_append_string_constant (dpi, "ull");
			break;
		      }
		    return;
		  }
		break;
d3313 18
a3330 18
	      case D_PRINT_BOOL:
		if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME
		    && d_right (dc)->u.s_name.len == 1
		    && dc->type == DEMANGLE_COMPONENT_LITERAL)
		  {
		    switch (d_right (dc)->u.s_name.s[0])
		      {
		      case '0':
			d_append_string_constant (dpi, "false");
			return;
		      case '1':
			d_append_string_constant (dpi, "true");
			return;
		      default:
			break;
		      }
		  }
		break;
d3332 4
a3335 4
	      default:
		break;
	      }
	  }
d3337 6
a3342 11
	d_append_char (dpi, '(');
	d_print_comp (dpi, d_left (dc));
	d_append_char (dpi, ')');
	if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
	  d_append_char (dpi, '-');
	if (tp == D_PRINT_FLOAT)
	  d_append_char (dpi, '[');
	d_print_comp (dpi, d_right (dc));
	if (tp == D_PRINT_FLOAT)
	  d_append_char (dpi, ']');
      }
a3551 1
  int need_space;
a3556 1
  need_space = 0;
a3564 4
	case DEMANGLE_COMPONENT_POINTER:
	case DEMANGLE_COMPONENT_REFERENCE:
	  need_paren = 1;
	  break;
d3569 2
a3573 1
	  need_space = 1;
d3592 1
a3592 1
      if (! need_space)
d3594 8
a3601 3
	  if (d_last_char (dpi) != '('
	      && d_last_char (dpi) != '*')
	    need_space = 1;
d3603 1
a3603 2
      if (need_space && d_last_char (dpi) != ' ')
	d_append_char (dpi, ' ');
d3646 4
a3649 1
	  if (! p->printed)
d3651 8
a3658 11
	      if (p->mod->type == DEMANGLE_COMPONENT_ARRAY_TYPE)
		{
		  need_space = 0;
		  break;
		}
	      else
		{
		  need_paren = 1;
		  need_space = 1;
		  break;
		}
d3947 3
d3952 1
a3952 2
      if (status != NULL)
	*status = -3;
d3958 1
a3958 2
      if (status != NULL)
	*status = -3;
d3962 1
a3962 16
  /* The specification for __cxa_demangle() is that if the mangled
     name could be either an extern "C" identifier, or an internal
     built-in type name, then we resolve it as the identifier.  All
     internal built-in type names are a single lower case character.
     Frankly, this simplistic disambiguation doesn't make sense to me,
     but it is documented, so we implement it here.  */
  if (IS_LOWER (mangled_name[0])
      && mangled_name[1] == '\0'
      && cplus_demangle_builtin_types[mangled_name[0] - 'a'].name != NULL)
    {
      if (status != NULL)
	*status = -2;
      return NULL;
    }

  demangled = d_demangle (mangled_name, DMGL_PARAMS | DMGL_TYPES, &alc);
d3966 4
a3969 7
      if (status != NULL)
	{
	  if (alc == 1)
	    *status = -1;
	  else
	    *status = -2;
	}
d3993 1
a3993 2
  if (status != NULL)
    *status = 0;
a4298 3
#ifdef IN_GLIBCPP_V3
	      s = __cxa_demangle (dyn_string_buf (mangled), NULL, NULL, NULL);
#else
a4299 1
#endif
a4330 3
#ifdef IN_GLIBCPP_V3
	  int status;
#endif
a4332 3
#ifdef IN_GLIBCPP_V3
	  s = __cxa_demangle (argv[i], NULL, NULL, &status);
#else
a4333 1
#endif
d4342 1
a4342 7
	    {
#ifdef IN_GLIBCPP_V3
	      fprintf (stderr, "Failed: %s (status %d)\n", argv[i], status);
#else
	      fprintf (stderr, "Failed: %s\n", argv[i]);
#endif
	    }
@


1.47.8.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a2400 2
      if (type == NULL)
	return NULL;
@


1.46
log
@merge from gcc
@
text
@d754 1
a771 1
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
@


1.45
log
@merge from gcc
@
text
@d48 16
d73 2
a74 1
      If defined, this file defines only __cxa_demangle().
d101 48
a182 46
/* Information we keep for operators.  */

struct d_operator_info
{
  /* Mangled name.  */
  const char *code;
  /* Real name.  */
  const char *name;
  /* Length of real name.  */
  int len;
  /* Number of arguments.  */
  int args;
};

/* How to print the value of a builtin type.  */

enum d_builtin_type_print
{
  /* Print as (type)val.  */
  D_PRINT_DEFAULT,
  /* Print as integer.  */
  D_PRINT_INT,
  /* Print as long, with trailing `l'.  */
  D_PRINT_LONG,
  /* Print as bool.  */
  D_PRINT_BOOL,
  /* Print in usual way, but here to detect void.  */
  D_PRINT_VOID
};

/* Information we keep for a builtin type.  */

struct d_builtin_type_info
{
  /* Type name.  */
  const char *name;
  /* Length of type name.  */
  int len;
  /* Type name when using Java.  */
  const char *java_name;
  /* Length of java name.  */
  int java_len;
  /* How to print a value of this type.  */
  enum d_builtin_type_print print;
};

d206 1
a206 180
/* Component types found in mangled names.  */

enum d_comp_type
{
  /* A name.  */
  D_COMP_NAME,
  /* A qualified name.  */
  D_COMP_QUAL_NAME,
  /* A local name.  */
  D_COMP_LOCAL_NAME,
  /* A typed name.  */
  D_COMP_TYPED_NAME,
  /* A template.  */
  D_COMP_TEMPLATE,
  /* A template parameter.  */
  D_COMP_TEMPLATE_PARAM,
  /* A constructor.  */
  D_COMP_CTOR,
  /* A destructor.  */
  D_COMP_DTOR,
  /* A vtable.  */
  D_COMP_VTABLE,
  /* A VTT structure.  */
  D_COMP_VTT,
  /* A construction vtable.  */
  D_COMP_CONSTRUCTION_VTABLE,
  /* A typeinfo structure.  */
  D_COMP_TYPEINFO,
  /* A typeinfo name.  */
  D_COMP_TYPEINFO_NAME,
  /* A typeinfo function.  */
  D_COMP_TYPEINFO_FN,
  /* A thunk.  */
  D_COMP_THUNK,
  /* A virtual thunk.  */
  D_COMP_VIRTUAL_THUNK,
  /* A covariant thunk.  */
  D_COMP_COVARIANT_THUNK,
  /* A Java class.  */
  D_COMP_JAVA_CLASS,
  /* A guard variable.  */
  D_COMP_GUARD,
  /* A reference temporary.  */
  D_COMP_REFTEMP,
  /* A standard substitution.  */
  D_COMP_SUB_STD,
  /* The restrict qualifier.  */
  D_COMP_RESTRICT,
  /* The volatile qualifier.  */
  D_COMP_VOLATILE,
  /* The const qualifier.  */
  D_COMP_CONST,
  /* The restrict qualifier modifying a member function.  */
  D_COMP_RESTRICT_THIS,
  /* The volatile qualifier modifying a member function.  */
  D_COMP_VOLATILE_THIS,
  /* The const qualifier modifying a member function.  */
  D_COMP_CONST_THIS,
  /* A vendor qualifier.  */
  D_COMP_VENDOR_TYPE_QUAL,
  /* A pointer.  */
  D_COMP_POINTER,
  /* A reference.  */
  D_COMP_REFERENCE,
  /* A complex type.  */
  D_COMP_COMPLEX,
  /* An imaginary type.  */
  D_COMP_IMAGINARY,
  /* A builtin type.  */
  D_COMP_BUILTIN_TYPE,
  /* A vendor's builtin type.  */
  D_COMP_VENDOR_TYPE,
  /* A function type.  */
  D_COMP_FUNCTION_TYPE,
  /* An array type.  */
  D_COMP_ARRAY_TYPE,
  /* A pointer to member type.  */
  D_COMP_PTRMEM_TYPE,
  /* An argument list.  */
  D_COMP_ARGLIST,
  /* A template argument list.  */
  D_COMP_TEMPLATE_ARGLIST,
  /* An operator.  */
  D_COMP_OPERATOR,
  /* An extended operator.  */
  D_COMP_EXTENDED_OPERATOR,
  /* A typecast.  */
  D_COMP_CAST,
  /* A unary expression.  */
  D_COMP_UNARY,
  /* A binary expression.  */
  D_COMP_BINARY,
  /* Arguments to a binary expression.  */
  D_COMP_BINARY_ARGS,
  /* A trinary expression.  */
  D_COMP_TRINARY,
  /* Arguments to a trinary expression.  */
  D_COMP_TRINARY_ARG1,
  D_COMP_TRINARY_ARG2,
  /* A literal.  */
  D_COMP_LITERAL,
  /* A negative literal.  */
  D_COMP_LITERAL_NEG
};

/* A component of the mangled name.  */

struct d_comp
{
  /* The type of this component.  */
  enum d_comp_type type;
  union
  {
    /* For D_COMP_NAME.  */
    struct
    {
      /* A pointer to the name (not NULL terminated) and it's
	 length.  */
      const char *s;
      int len;
    } s_name;

    /* For D_COMP_OPERATOR.  */
    struct
    {
      /* Operator.  */
      const struct d_operator_info *op;
    } s_operator;

    /* For D_COMP_EXTENDED_OPERATOR.  */
    struct
    {
      /* Number of arguments.  */
      int args;
      /* Name.  */
      struct d_comp *name;
    } s_extended_operator;

    /* For D_COMP_CTOR.  */
    struct
    {
      enum gnu_v3_ctor_kinds kind;
      struct d_comp *name;
    } s_ctor;

    /* For D_COMP_DTOR.  */
    struct
    {
      enum gnu_v3_dtor_kinds kind;
      struct d_comp *name;
    } s_dtor;

    /* For D_COMP_BUILTIN_TYPE.  */
    struct
    {
      const struct d_builtin_type_info *type;
    } s_builtin;

    /* For D_COMP_SUB_STD.  */
    struct
    {
      const char* string;
      int len;
    } s_string;

    /* For D_COMP_TEMPLATE_PARAM.  */
    struct
    {
      long number;
    } s_number;

    /* For other types.  */
    struct
    {
      struct d_comp *left;
      struct d_comp *right;
    } s_binary;

  } u;
};
a210 42
/* The information structure we pass around.  */

struct d_info
{
  /* The string we are demangling.  */
  const char *s;
  /* The end of the string we are demangling.  */
  const char *send;
  /* The options passed to the demangler.  */
  int options;
  /* The next character in the string to consider.  */
  const char *n;
  /* The array of components.  */
  struct d_comp *comps;
  /* The index of the next available component.  */
  int next_comp;
  /* The number of available component structures.  */
  int num_comps;
  /* The array of substitutions.  */
  struct d_comp **subs;
  /* The index of the next substitution.  */
  int next_sub;
  /* The number of available entries in the subs array.  */
  int num_subs;
  /* The number of substitutions which we actually made from the subs
     array, plus the number of template parameter references we
     saw.  */
  int did_subs;
  /* The last name we saw, for constructors and destructors.  */
  struct d_comp *last_name;
  /* A running total of the length of large expansions from the
     mangled name to the demangled name, such as standard
     substitutions and builtin types.  */
  int expansion;
};

#define d_peek_char(di) (*((di)->n))
#define d_peek_next_char(di) ((di)->n[1])
#define d_advance(di, i) ((di)->n += (i))
#define d_next_char(di) (*((di)->n++))
#define d_str(di) ((di)->n)

d218 1
a218 1
  const struct d_comp *template;
d229 1
a229 1
  const struct d_comp *mod;
d289 2
a290 1
static void d_dump PARAMS ((struct d_comp *, int));
d292 171
a462 79
static struct d_comp *d_make_empty PARAMS ((struct d_info *,
					    enum d_comp_type));
static struct d_comp *d_make_comp PARAMS ((struct d_info *, enum d_comp_type,
					   struct d_comp *, struct d_comp *));
static struct d_comp *d_make_name PARAMS ((struct d_info *, const char *,
					   int));
static struct d_comp *d_make_builtin_type PARAMS ((struct d_info *,
						   const struct d_builtin_type_info *));
static struct d_comp *d_make_operator PARAMS ((struct d_info *,
					       const struct d_operator_info *));
static struct d_comp *d_make_extended_operator PARAMS ((struct d_info *,
							int,
							struct d_comp *));
static struct d_comp *d_make_ctor PARAMS ((struct d_info *,
					   enum gnu_v3_ctor_kinds,
					   struct d_comp *));
static struct d_comp *d_make_dtor PARAMS ((struct d_info *,
					   enum gnu_v3_dtor_kinds,
					   struct d_comp *));
static struct d_comp *d_make_template_param PARAMS ((struct d_info *, long));
static struct d_comp *d_make_sub PARAMS ((struct d_info *, const char *, int));
static struct d_comp *d_mangled_name PARAMS ((struct d_info *, int));
static int has_return_type PARAMS ((struct d_comp *));
static int is_ctor_dtor_or_conversion PARAMS ((struct d_comp *));
static struct d_comp *d_encoding PARAMS ((struct d_info *, int));
static struct d_comp *d_name PARAMS ((struct d_info *));
static struct d_comp *d_nested_name PARAMS ((struct d_info *));
static struct d_comp *d_prefix PARAMS ((struct d_info *));
static struct d_comp *d_unqualified_name PARAMS ((struct d_info *));
static struct d_comp *d_source_name PARAMS ((struct d_info *));
static long d_number PARAMS ((struct d_info *));
static struct d_comp *d_identifier PARAMS ((struct d_info *, int));
static struct d_comp *d_operator_name PARAMS ((struct d_info *));
static struct d_comp *d_special_name PARAMS ((struct d_info *));
static int d_call_offset PARAMS ((struct d_info *, int));
static struct d_comp *d_ctor_dtor_name PARAMS ((struct d_info *));
static struct d_comp *d_type PARAMS ((struct d_info *));
static struct d_comp **d_cv_qualifiers PARAMS ((struct d_info *,
						struct d_comp **, int));
static struct d_comp *d_function_type PARAMS ((struct d_info *));
static struct d_comp *d_bare_function_type PARAMS ((struct d_info *, int));
static struct d_comp *d_class_enum_type PARAMS ((struct d_info *));
static struct d_comp *d_array_type PARAMS ((struct d_info *));
static struct d_comp *d_pointer_to_member_type PARAMS ((struct d_info *));
static struct d_comp *d_template_param PARAMS ((struct d_info *));
static struct d_comp *d_template_args PARAMS ((struct d_info *));
static struct d_comp *d_template_arg PARAMS ((struct d_info *));
static struct d_comp *d_expression PARAMS ((struct d_info *));
static struct d_comp *d_expr_primary PARAMS ((struct d_info *));
static struct d_comp *d_local_name PARAMS ((struct d_info *));
static int d_discriminator PARAMS ((struct d_info *));
static int d_add_substitution PARAMS ((struct d_info *, struct d_comp *));
static struct d_comp *d_substitution PARAMS ((struct d_info *, int));
static void d_print_resize PARAMS ((struct d_print_info *, size_t));
static void d_print_append_char PARAMS ((struct d_print_info *, int));
static void d_print_append_buffer PARAMS ((struct d_print_info *, const char *,
					   size_t));
static void d_print_error PARAMS ((struct d_print_info *));
static char *d_print PARAMS ((int, const struct d_comp *, int, size_t *));
static void d_print_comp PARAMS ((struct d_print_info *,
				  const struct d_comp *));
static void d_print_java_identifier PARAMS ((struct d_print_info *,
					     const char *, int));
static void d_print_mod_list PARAMS ((struct d_print_info *,
				      struct d_print_mod *, int));
static void d_print_mod PARAMS ((struct d_print_info *,
				 const struct d_comp *));
static void d_print_function_type PARAMS ((struct d_print_info *,
					   const struct d_comp *,
					   struct d_print_mod *));
static void d_print_array_type PARAMS ((struct d_print_info *,
					const struct d_comp *,
					struct d_print_mod *));
static void d_print_expr_op PARAMS ((struct d_print_info *,
				     const struct d_comp *));
static void d_print_cast PARAMS ((struct d_print_info *,
				  const struct d_comp *));
static void d_init_info PARAMS ((const char *, int, size_t, struct d_info *));
static char *d_demangle PARAMS ((const char *, int, size_t *));
d468 1
a468 1
     struct d_comp *dc;
d481 1
a481 1
    case D_COMP_NAME:
d484 1
a484 1
    case D_COMP_TEMPLATE_PARAM:
d487 1
a487 1
    case D_COMP_CTOR:
d491 1
a491 1
    case D_COMP_DTOR:
d495 1
a495 1
    case D_COMP_SUB_STD:
d498 1
a498 1
    case D_COMP_BUILTIN_TYPE:
d501 1
a501 1
    case D_COMP_OPERATOR:
d504 1
a504 1
    case D_COMP_EXTENDED_OPERATOR:
d510 1
a510 1
    case D_COMP_QUAL_NAME:
d513 1
a513 1
    case D_COMP_LOCAL_NAME:
d516 1
a516 1
    case D_COMP_TYPED_NAME:
d519 1
a519 1
    case D_COMP_TEMPLATE:
d522 1
a522 1
    case D_COMP_VTABLE:
d525 1
a525 1
    case D_COMP_VTT:
d528 1
a528 1
    case D_COMP_CONSTRUCTION_VTABLE:
d531 1
a531 1
    case D_COMP_TYPEINFO:
d534 1
a534 1
    case D_COMP_TYPEINFO_NAME:
d537 1
a537 1
    case D_COMP_TYPEINFO_FN:
d540 1
a540 1
    case D_COMP_THUNK:
d543 1
a543 1
    case D_COMP_VIRTUAL_THUNK:
d546 1
a546 1
    case D_COMP_COVARIANT_THUNK:
d549 1
a549 1
    case D_COMP_JAVA_CLASS:
d552 1
a552 1
    case D_COMP_GUARD:
d555 1
a555 1
    case D_COMP_REFTEMP:
d558 1
a558 1
    case D_COMP_RESTRICT:
d561 1
a561 1
    case D_COMP_VOLATILE:
d564 1
a564 1
    case D_COMP_CONST:
d567 1
a567 1
    case D_COMP_RESTRICT_THIS:
d570 1
a570 1
    case D_COMP_VOLATILE_THIS:
d573 1
a573 1
    case D_COMP_CONST_THIS:
d576 1
a576 1
    case D_COMP_VENDOR_TYPE_QUAL:
d579 1
a579 1
    case D_COMP_POINTER:
d582 1
a582 1
    case D_COMP_REFERENCE:
d585 1
a585 1
    case D_COMP_COMPLEX:
d588 1
a588 1
    case D_COMP_IMAGINARY:
d591 1
a591 1
    case D_COMP_VENDOR_TYPE:
d594 1
a594 1
    case D_COMP_FUNCTION_TYPE:
d597 1
a597 1
    case D_COMP_ARRAY_TYPE:
d600 1
a600 1
    case D_COMP_PTRMEM_TYPE:
d603 1
a603 1
    case D_COMP_ARGLIST:
d606 1
a606 1
    case D_COMP_TEMPLATE_ARGLIST:
d609 1
a609 1
    case D_COMP_CAST:
d612 1
a612 1
    case D_COMP_UNARY:
d615 1
a615 1
    case D_COMP_BINARY:
d618 1
a618 1
    case D_COMP_BINARY_ARGS:
d621 1
a621 1
    case D_COMP_TRINARY:
d624 1
a624 1
    case D_COMP_TRINARY_ARG1:
d627 1
a627 1
    case D_COMP_TRINARY_ARG2:
d630 1
a630 1
    case D_COMP_LITERAL:
d633 1
a633 1
    case D_COMP_LITERAL_NEG:
d644 74
d720 2
a721 2
static struct d_comp *
d_make_empty (di, type)
a722 1
     enum d_comp_type type;
d724 1
a724 1
  struct d_comp *p;
a728 1
  p->type = type;
d735 1
a735 1
static struct d_comp *
d738 3
a740 3
     enum d_comp_type type;
     struct d_comp *left;
     struct d_comp *right;
d742 1
a742 1
  struct d_comp *p;
d750 14
a763 14
    case D_COMP_QUAL_NAME:
    case D_COMP_LOCAL_NAME:
    case D_COMP_TYPED_NAME:
    case D_COMP_TEMPLATE:
    case D_COMP_VENDOR_TYPE_QUAL:
    case D_COMP_PTRMEM_TYPE:
    case D_COMP_UNARY:
    case D_COMP_BINARY:
    case D_COMP_BINARY_ARGS:
    case D_COMP_TRINARY:
    case D_COMP_TRINARY_ARG1:
    case D_COMP_TRINARY_ARG2:
    case D_COMP_LITERAL:
    case D_COMP_LITERAL_NEG:
d769 20
a788 20
    case D_COMP_VTABLE:
    case D_COMP_VTT:
    case D_COMP_CONSTRUCTION_VTABLE:
    case D_COMP_TYPEINFO:
    case D_COMP_TYPEINFO_NAME:
    case D_COMP_TYPEINFO_FN:
    case D_COMP_THUNK:
    case D_COMP_VIRTUAL_THUNK:
    case D_COMP_COVARIANT_THUNK:
    case D_COMP_JAVA_CLASS:
    case D_COMP_GUARD:
    case D_COMP_REFTEMP:
    case D_COMP_POINTER:
    case D_COMP_REFERENCE:
    case D_COMP_COMPLEX:
    case D_COMP_IMAGINARY:
    case D_COMP_VENDOR_TYPE:
    case D_COMP_ARGLIST:
    case D_COMP_TEMPLATE_ARGLIST:
    case D_COMP_CAST:
d795 1
a795 1
    case D_COMP_ARRAY_TYPE:
d802 7
a808 7
    case D_COMP_FUNCTION_TYPE:
    case D_COMP_RESTRICT:
    case D_COMP_VOLATILE:
    case D_COMP_CONST:
    case D_COMP_RESTRICT_THIS:
    case D_COMP_VOLATILE_THIS:
    case D_COMP_CONST_THIS:
d816 1
a816 1
  p = d_make_empty (di, type);
d819 1
d828 1
a828 1
static struct d_comp *
d834 1
a834 1
  struct d_comp *p;
d836 2
a837 1
  if (s == NULL || len == 0)
a838 6
  p = d_make_empty (di, D_COMP_NAME);
  if (p != NULL)
    {
      p->u.s_name.s = s;
      p->u.s_name.len = len;
    }
d844 1
a844 1
static struct d_comp *
d847 1
a847 1
     const struct d_builtin_type_info *type;
d849 1
a849 1
  struct d_comp *p;
d853 1
a853 1
  p = d_make_empty (di, D_COMP_BUILTIN_TYPE);
d855 4
a858 1
    p->u.s_builtin.type = type;
d864 1
a864 1
static struct d_comp *
d867 1
a867 1
     const struct d_operator_info *op;
d869 1
a869 1
  struct d_comp *p;
d871 1
a871 1
  p = d_make_empty (di, D_COMP_OPERATOR);
d873 4
a876 1
    p->u.s_operator.op = op;
d882 1
a882 1
static struct d_comp *
d886 1
a886 1
     struct d_comp *name;
d888 1
a888 1
  struct d_comp *p;
d890 2
a891 1
  if (name == NULL)
a892 6
  p = d_make_empty (di, D_COMP_EXTENDED_OPERATOR);
  if (p != NULL)
    {
      p->u.s_extended_operator.args = args;
      p->u.s_extended_operator.name = name;
    }
d898 1
a898 1
static struct d_comp *
d902 1
a902 1
     struct d_comp *name;
d904 1
a904 1
  struct d_comp *p;
d906 2
a907 1
  if (name == NULL)
a908 6
  p = d_make_empty (di, D_COMP_CTOR);
  if (p != NULL)
    {
      p->u.s_ctor.kind = kind;
      p->u.s_ctor.name = name;
    }
d914 1
a914 1
static struct d_comp *
d918 1
a918 1
     struct d_comp *name;
d920 1
a920 1
  struct d_comp *p;
d922 2
a923 1
  if (name == NULL)
a924 6
  p = d_make_empty (di, D_COMP_DTOR);
  if (p != NULL)
    {
      p->u.s_dtor.kind = kind;
      p->u.s_dtor.name = name;
    }
d930 1
a930 1
static struct d_comp *
d935 1
a935 1
  struct d_comp *p;
d937 1
a937 1
  p = d_make_empty (di, D_COMP_TEMPLATE_PARAM);
d939 4
a942 1
    p->u.s_number.number = i;
d948 1
a948 1
static struct d_comp *
d954 1
a954 1
  struct d_comp *p;
d956 1
a956 1
  p = d_make_empty (di, D_COMP_SUB_STD);
d959 1
d970 3
a972 2
static struct d_comp *
d_mangled_name (di, top_level)
d994 1
a994 1
     struct d_comp *dc;
d1002 1
a1002 1
    case D_COMP_TEMPLATE:
d1004 3
a1006 3
    case D_COMP_RESTRICT_THIS:
    case D_COMP_VOLATILE_THIS:
    case D_COMP_CONST_THIS:
d1016 1
a1016 1
     struct d_comp *dc;
d1024 2
a1025 2
    case D_COMP_QUAL_NAME:
    case D_COMP_LOCAL_NAME:
d1027 3
a1029 3
    case D_COMP_CTOR:
    case D_COMP_DTOR:
    case D_COMP_CAST:
d1043 1
a1043 1
static struct d_comp *
d1054 1
a1054 1
      struct d_comp *dc;
d1063 3
a1065 3
	  while (dc->type == D_COMP_RESTRICT_THIS
		 || dc->type == D_COMP_VOLATILE_THIS
		 || dc->type == D_COMP_CONST_THIS)
d1068 5
a1072 5
	  /* If the top level is a D_COMP_LOCAL_NAME, then there may
	     be CV-qualifiers on its right argument which really apply
	     here; this happens when parsing a class which is local to
	     a function.  */
	  if (dc->type == D_COMP_LOCAL_NAME)
d1074 1
a1074 1
	      struct d_comp *dcr;
d1077 3
a1079 3
	      while (dcr->type == D_COMP_RESTRICT_THIS
		     || dcr->type == D_COMP_VOLATILE_THIS
		     || dcr->type == D_COMP_CONST_THIS)
d1090 1
a1090 1
      return d_make_comp (di, D_COMP_TYPED_NAME, dc,
d1107 1
a1107 1
static struct d_comp *
d1112 1
a1112 1
  struct d_comp *dc;
d1134 2
a1135 1
	    dc = d_make_comp (di, D_COMP_QUAL_NAME, d_make_name (di, "std", 3),
d1158 2
a1159 1
	    dc = d_make_comp (di, D_COMP_TEMPLATE, dc, d_template_args (di));
d1174 2
a1175 1
	  dc = d_make_comp (di, D_COMP_TEMPLATE, dc, d_template_args (di));
d1185 1
a1185 1
static struct d_comp *
d1189 2
a1190 2
  struct d_comp *ret;
  struct d_comp **pret;
d1220 1
a1220 1
static struct d_comp *
d1224 1
a1224 1
  struct d_comp *ret = NULL;
d1229 2
a1230 2
      enum d_comp_type comb_type;
      struct d_comp *dc;
d1240 1
a1240 1
      comb_type = D_COMP_QUAL_NAME;
d1252 1
a1252 1
	  comb_type = D_COMP_TEMPLATE;
d1280 1
a1280 1
static struct d_comp *
d1291 1
a1291 1
      struct d_comp *ret;
d1294 1
a1294 1
      if (ret != NULL && ret->type == D_COMP_OPERATOR)
d1306 1
a1306 1
static struct d_comp *
d1311 1
a1311 1
  struct d_comp *ret;
d1357 1
a1357 1
static struct d_comp *
d1407 2
a1408 1
static const struct d_operator_info d_operators[] =
d1458 2
a1459 1
  { "sz", NL ("sizeof "),   1 }
d1462 1
a1462 1
static struct d_comp *
d1474 2
a1475 1
    return d_make_comp (di, D_COMP_CAST, d_type (di), NULL);
d1478 1
d1480 5
a1484 1
      int high = sizeof (d_operators) / sizeof (d_operators[0]);
d1489 1
a1489 1
	  const struct d_operator_info *p;
d1492 1
a1492 1
	  p = d_operators + i;
d1521 1
a1521 1
static struct d_comp *
d1535 2
a1536 1
	  return d_make_comp (di, D_COMP_VTABLE, d_type (di), NULL);
d1539 2
a1540 1
	  return d_make_comp (di, D_COMP_VTT, d_type (di), NULL);
d1542 2
a1543 1
	  return d_make_comp (di, D_COMP_TYPEINFO, d_type (di), NULL);
d1545 2
a1546 1
	  return d_make_comp (di, D_COMP_TYPEINFO_NAME, d_type (di), NULL);
d1551 2
a1552 1
	  return d_make_comp (di, D_COMP_THUNK, d_encoding (di, 0), NULL);
d1557 2
a1558 2
	  return d_make_comp (di, D_COMP_VIRTUAL_THUNK, d_encoding (di, 0),
			      NULL);
d1565 2
a1566 2
	  return d_make_comp (di, D_COMP_COVARIANT_THUNK, d_encoding (di, 0),
			      NULL);
d1570 1
a1570 1
	    struct d_comp *derived_type;
d1572 1
a1572 1
	    struct d_comp *base_type;
d1574 1
a1574 1
	    derived_type = d_type (di);
d1580 1
a1580 1
	    base_type = d_type (di);
d1584 2
a1585 2
	    return d_make_comp (di, D_COMP_CONSTRUCTION_VTABLE, base_type,
				derived_type);
d1589 2
a1590 1
	  return d_make_comp (di, D_COMP_TYPEINFO_FN, d_type (di), NULL);
d1592 2
a1593 1
	  return d_make_comp (di, D_COMP_JAVA_CLASS, d_type (di), NULL);
d1604 1
a1604 1
	  return d_make_comp (di, D_COMP_GUARD, d_name (di), NULL);
d1607 2
a1608 1
	  return d_make_comp (di, D_COMP_REFTEMP, d_name (di), NULL);
d1668 1
a1668 1
static struct d_comp *
d1674 1
a1674 1
      if (di->last_name->type == D_COMP_NAME)
d1676 1
a1676 1
      else if (di->last_name->type == D_COMP_SUB_STD)
d1747 3
a1749 1
static const struct d_builtin_type_info d_builtin_types[26] =
d1779 3
a1781 2
static struct d_comp *
d_type (di)
d1785 1
a1785 1
  struct d_comp *ret;
d1806 1
a1806 1
      struct d_comp **pret;
d1811 1
a1811 1
      *pret = d_type (di);
d1825 2
a1826 1
      ret = d_make_builtin_type (di, &d_builtin_types[peek - 'a']);
d1834 2
a1835 1
      ret = d_make_comp (di, D_COMP_VENDOR_TYPE, d_source_name (di), NULL);
d1866 2
a1867 1
	  ret = d_make_comp (di, D_COMP_TEMPLATE, ret, d_template_args (di));
d1886 1
a1886 1
	      ret = d_make_comp (di, D_COMP_TEMPLATE, ret,
d1898 1
a1898 1
	    if (ret != NULL && ret->type == D_COMP_SUB_STD)
d1906 2
a1907 1
      ret = d_make_comp (di, D_COMP_POINTER, d_type (di), NULL);
d1912 2
a1913 1
      ret = d_make_comp (di, D_COMP_REFERENCE, d_type (di), NULL);
d1918 2
a1919 1
      ret = d_make_comp (di, D_COMP_COMPLEX, d_type (di), NULL);
d1924 2
a1925 1
      ret = d_make_comp (di, D_COMP_IMAGINARY, d_type (di), NULL);
d1931 2
a1932 1
      ret = d_make_comp (di, D_COMP_VENDOR_TYPE_QUAL, d_type (di), ret);
d1950 1
a1950 1
static struct d_comp **
d1953 1
a1953 1
     struct d_comp **pret;
d1961 1
a1961 1
      enum d_comp_type t;
d1966 3
a1968 1
	  t = member_fn ? D_COMP_RESTRICT_THIS : D_COMP_RESTRICT;
d1973 3
a1975 1
	  t = member_fn ? D_COMP_VOLATILE_THIS : D_COMP_VOLATILE;
d1980 3
a1982 1
	  t = member_fn ? D_COMP_CONST_THIS : D_COMP_CONST;
d1999 1
a1999 1
static struct d_comp *
d2003 1
a2003 1
  struct d_comp *ret;
d2021 1
a2021 1
static struct d_comp *
d2026 3
a2028 3
  struct d_comp *return_type;
  struct d_comp *tl;
  struct d_comp **ptl;
d2036 1
a2036 1
      struct d_comp *type;
d2041 1
a2041 1
      type = d_type (di);
d2051 1
a2051 1
	  *ptl = d_make_comp (di, D_COMP_ARGLIST, type, NULL);
d2066 1
a2066 1
      && d_left (tl)->type == D_COMP_BUILTIN_TYPE
d2073 1
a2073 1
  return d_make_comp (di, D_COMP_FUNCTION_TYPE, return_type, tl);
d2078 1
a2078 1
static struct d_comp *
d2089 1
a2089 1
static struct d_comp *
d2094 1
a2094 1
  struct d_comp *dim;
d2127 2
a2128 1
  return d_make_comp (di, D_COMP_ARRAY_TYPE, dim, d_type (di));
d2133 1
a2133 1
static struct d_comp *
d2137 3
a2139 3
  struct d_comp *cl;
  struct d_comp *mem;
  struct d_comp **pmem;
d2144 1
a2144 1
  cl = d_type (di);
d2157 1
a2157 1
     avoid calling add_substitution() in d_type().  */
d2162 1
a2162 1
  *pmem = d_type (di);
d2164 1
a2164 1
  return d_make_comp (di, D_COMP_PTRMEM_TYPE, cl, mem);
d2171 1
a2171 1
static struct d_comp *
d2200 1
a2200 1
static struct d_comp *
d2204 3
a2206 3
  struct d_comp *hold_last_name;
  struct d_comp *al;
  struct d_comp **pal;
d2220 1
a2220 1
      struct d_comp *a;
d2226 1
a2226 1
      *pal = d_make_comp (di, D_COMP_TEMPLATE_ARGLIST, a, NULL);
d2248 1
a2248 1
static struct d_comp *
d2252 1
a2252 1
  struct d_comp *ret;
d2267 1
a2267 1
      return d_type (di);
d2281 1
a2281 1
static struct d_comp *
d2294 2
a2295 2
      struct d_comp *type;
      struct d_comp *name;
d2298 1
a2298 1
      type = d_type (di);
d2301 1
a2301 1
	return d_make_comp (di, D_COMP_QUAL_NAME, type, name);
d2303 2
a2304 2
	return d_make_comp (di, D_COMP_QUAL_NAME, type,
			    d_make_comp (di, D_COMP_TEMPLATE, name,
d2309 1
a2309 1
      struct d_comp *op;
d2316 1
a2316 1
      if (op->type == D_COMP_OPERATOR)
d2319 1
a2319 1
      if (op->type == D_COMP_OPERATOR
d2321 2
a2322 1
	return d_make_comp (di, D_COMP_UNARY, op, d_type (di));
d2328 1
a2328 1
	case D_COMP_OPERATOR:
d2331 1
a2331 1
	case D_COMP_EXTENDED_OPERATOR:
d2334 1
a2334 1
	case D_COMP_CAST:
d2342 2
a2343 1
	  return d_make_comp (di, D_COMP_UNARY, op, d_expression (di));
d2346 1
a2346 1
	    struct d_comp *left;
d2349 4
a2352 2
	    return d_make_comp (di, D_COMP_BINARY, op,
				d_make_comp (di, D_COMP_BINARY_ARGS, left,
d2357 2
a2358 2
	    struct d_comp *first;
	    struct d_comp *second;
d2362 4
a2365 2
	    return d_make_comp (di, D_COMP_TRINARY, op,
				d_make_comp (di, D_COMP_TRINARY_ARG1, first,
d2367 1
a2367 1
							  D_COMP_TRINARY_ARG2,
d2382 1
a2382 1
static struct d_comp *
d2386 1
a2386 1
  struct d_comp *ret;
d2391 1
a2391 1
    ret = d_mangled_name (di, 0);
d2394 2
a2395 2
      struct d_comp *type;
      enum d_comp_type t;
d2398 1
a2398 1
      type = d_type (di);
d2402 1
a2402 1
      if (type->type == D_COMP_BUILTIN_TYPE
d2417 1
a2417 1
      t = D_COMP_LITERAL;
d2420 1
a2420 1
	  t = D_COMP_LITERAL_NEG;
d2437 1
a2437 1
static struct d_comp *
d2441 1
a2441 1
  struct d_comp *function;
d2456 1
a2456 1
      return d_make_comp (di, D_COMP_LOCAL_NAME, function,
d2462 1
a2462 1
      struct d_comp *name;
d2467 1
a2467 1
      return d_make_comp (di, D_COMP_LOCAL_NAME, function, name);
d2496 1
a2496 1
     struct d_comp *dc;
d2551 1
a2551 1
static struct d_comp *
d2730 3
a2732 2
static char *
d_print (options, dc, estimate, palc)
d2734 1
a2734 1
     const struct d_comp *dc;
d2773 1
a2773 1
     const struct d_comp *dc;
d2785 1
a2785 1
    case D_COMP_NAME:
d2792 2
a2793 2
    case D_COMP_QUAL_NAME:
    case D_COMP_LOCAL_NAME:
d2802 1
a2802 1
    case D_COMP_TYPED_NAME:
d2805 1
a2805 1
	struct d_comp *typed_name;
d2831 3
a2833 3
	    if (typed_name->type != D_COMP_RESTRICT_THIS
		&& typed_name->type != D_COMP_VOLATILE_THIS
		&& typed_name->type != D_COMP_CONST_THIS)
d2841 1
a2841 1
	if (typed_name->type == D_COMP_TEMPLATE)
d2848 5
a2852 5
	/* If typed_name is a D_COMP_LOCAL_NAME, then there may be
	   CV-qualifiers on its right argument which really apply
	   here; this happens when parsing a class which is local to a
	   function.  */
	if (typed_name->type == D_COMP_LOCAL_NAME)
d2854 1
a2854 1
	    struct d_comp *local_name;
d2857 3
a2859 3
	    while (local_name->type == D_COMP_RESTRICT_THIS
		   || local_name->type == D_COMP_VOLATILE_THIS
		   || local_name->type == D_COMP_CONST_THIS)
d2882 1
a2882 1
	if (typed_name->type == D_COMP_TEMPLATE)
d2902 1
a2902 1
    case D_COMP_TEMPLATE:
d2929 1
a2929 1
    case D_COMP_TEMPLATE_PARAM:
d2932 1
a2932 1
	struct d_comp *a;
d2945 1
a2945 1
	    if (a->type != D_COMP_TEMPLATE_ARGLIST)
d2975 1
a2975 1
    case D_COMP_CTOR:
d2979 1
a2979 1
    case D_COMP_DTOR:
d2984 1
a2984 1
    case D_COMP_VTABLE:
d2989 1
a2989 1
    case D_COMP_VTT:
d2994 1
a2994 1
    case D_COMP_CONSTRUCTION_VTABLE:
d3001 1
a3001 1
    case D_COMP_TYPEINFO:
d3006 1
a3006 1
    case D_COMP_TYPEINFO_NAME:
d3011 1
a3011 1
    case D_COMP_TYPEINFO_FN:
d3016 1
a3016 1
    case D_COMP_THUNK:
d3021 1
a3021 1
    case D_COMP_VIRTUAL_THUNK:
d3026 1
a3026 1
    case D_COMP_COVARIANT_THUNK:
d3031 1
a3031 1
    case D_COMP_JAVA_CLASS:
d3036 1
a3036 1
    case D_COMP_GUARD:
d3041 1
a3041 1
    case D_COMP_REFTEMP:
d3046 1
a3046 1
    case D_COMP_SUB_STD:
d3050 11
a3060 11
    case D_COMP_RESTRICT:
    case D_COMP_VOLATILE:
    case D_COMP_CONST:
    case D_COMP_RESTRICT_THIS:
    case D_COMP_VOLATILE_THIS:
    case D_COMP_CONST_THIS:
    case D_COMP_VENDOR_TYPE_QUAL:
    case D_COMP_POINTER:
    case D_COMP_REFERENCE:
    case D_COMP_COMPLEX:
    case D_COMP_IMAGINARY:
d3083 1
a3083 1
    case D_COMP_BUILTIN_TYPE:
d3092 1
a3092 1
    case D_COMP_VENDOR_TYPE:
d3096 1
a3096 1
    case D_COMP_FUNCTION_TYPE:
d3126 1
a3126 1
    case D_COMP_ARRAY_TYPE:
d3151 1
a3151 1
    case D_COMP_PTRMEM_TYPE:
d3177 2
a3178 2
    case D_COMP_ARGLIST:
    case D_COMP_TEMPLATE_ARGLIST:
d3187 1
a3187 1
    case D_COMP_OPERATOR:
d3200 1
a3200 1
    case D_COMP_EXTENDED_OPERATOR:
d3205 1
a3205 1
    case D_COMP_CAST:
d3210 2
a3211 2
    case D_COMP_UNARY:
      if (d_left (dc)->type != D_COMP_CAST)
d3222 1
a3222 1
      if (d_left (dc)->type == D_COMP_CAST)
d3226 2
a3227 2
    case D_COMP_BINARY:
      if (d_right (dc)->type != D_COMP_BINARY_ARGS)
d3236 1
a3236 1
      if (d_left (dc)->type == D_COMP_OPERATOR
d3249 1
a3249 1
      if (d_left (dc)->type == D_COMP_OPERATOR
d3256 2
a3257 2
    case D_COMP_BINARY_ARGS:
      /* We should only see this as part of D_COMP_BINARY.  */
d3261 3
a3263 3
    case D_COMP_TRINARY:
      if (d_right (dc)->type != D_COMP_TRINARY_ARG1
	  || d_right (d_right (dc))->type != D_COMP_TRINARY_ARG2)
d3279 3
a3281 3
    case D_COMP_TRINARY_ARG1:
    case D_COMP_TRINARY_ARG2:
      /* We should only see these are part of D_COMP_TRINARY.  */
d3285 2
a3286 2
    case D_COMP_LITERAL:
    case D_COMP_LITERAL_NEG:
d3288 1
a3288 1
      if (d_left (dc)->type == D_COMP_BUILTIN_TYPE)
d3293 1
a3293 1
	      if (d_right (dc)->type == D_COMP_NAME)
d3295 1
a3295 1
		  if (dc->type == D_COMP_LITERAL_NEG)
d3303 1
a3303 1
	      if (d_right (dc)->type == D_COMP_NAME)
d3305 1
a3305 1
		  if (dc->type == D_COMP_LITERAL_NEG)
d3314 1
a3314 1
	      if (d_right (dc)->type == D_COMP_NAME
d3316 1
a3316 1
		  && dc->type == D_COMP_LITERAL)
d3340 1
a3340 1
      if (dc->type == D_COMP_LITERAL_NEG)
d3422 3
a3424 3
	  && (mods->mod->type == D_COMP_RESTRICT_THIS
	      || mods->mod->type == D_COMP_VOLATILE_THIS
	      || mods->mod->type == D_COMP_CONST_THIS)))
d3435 1
a3435 1
  if (mods->mod->type == D_COMP_FUNCTION_TYPE)
d3441 1
a3441 1
  else if (mods->mod->type == D_COMP_ARRAY_TYPE)
d3447 1
a3447 1
  else if (mods->mod->type == D_COMP_LOCAL_NAME)
d3450 1
a3450 1
      struct d_comp *dc;
d3468 3
a3470 3
      while (dc->type == D_COMP_RESTRICT_THIS
	     || dc->type == D_COMP_VOLATILE_THIS
	     || dc->type == D_COMP_CONST_THIS)
d3491 1
a3491 1
     const struct d_comp *mod;
d3495 2
a3496 2
    case D_COMP_RESTRICT:
    case D_COMP_RESTRICT_THIS:
d3499 2
a3500 2
    case D_COMP_VOLATILE:
    case D_COMP_VOLATILE_THIS:
d3503 2
a3504 2
    case D_COMP_CONST:
    case D_COMP_CONST_THIS:
d3507 1
a3507 1
    case D_COMP_VENDOR_TYPE_QUAL:
d3511 1
a3511 1
    case D_COMP_POINTER:
d3516 1
a3516 1
    case D_COMP_REFERENCE:
d3519 1
a3519 1
    case D_COMP_COMPLEX:
d3522 1
a3522 1
    case D_COMP_IMAGINARY:
d3525 1
a3525 1
    case D_COMP_PTRMEM_TYPE:
d3531 1
a3531 1
    case D_COMP_TYPED_NAME:
d3547 1
a3547 1
     const struct d_comp *dc;
d3565 9
a3573 9
	case D_COMP_RESTRICT:
	case D_COMP_VOLATILE:
	case D_COMP_CONST:
	case D_COMP_VENDOR_TYPE_QUAL:
	case D_COMP_POINTER:
	case D_COMP_REFERENCE:
	case D_COMP_COMPLEX:
	case D_COMP_IMAGINARY:
	case D_COMP_PTRMEM_TYPE:
d3576 3
a3578 3
	case D_COMP_RESTRICT_THIS:
	case D_COMP_VOLATILE_THIS:
	case D_COMP_CONST_THIS:
d3632 1
a3632 1
     const struct d_comp *dc;
d3649 1
a3649 1
	  if (p->mod->type == D_COMP_ARRAY_TYPE)
d3687 1
a3687 1
     const struct d_comp *dc;
d3689 1
a3689 1
  if (dc->type == D_COMP_OPERATOR)
d3701 1
a3701 1
     const struct d_comp *dc;
d3703 1
a3703 1
  if (d_left (dc)->type != D_COMP_TEMPLATE)
d3743 3
a3745 2
static void
d_init_info (mangled, options, len, di)
d3790 1
a3790 1
  struct d_comp *dc;
d3827 1
a3827 1
  d_init_info (mangled, options, len, &di);
d3831 2
a3832 2
    __extension__ struct d_comp comps[di.num_comps];
    __extension__ struct d_comp *subs[di.num_subs];
d3837 4
a3840 4
    di.comps = (struct d_comp *) malloc (di.num_comps
					 * sizeof (struct d_comp));
    di.subs = (struct d_comp **) malloc (di.num_subs
					 * sizeof (struct d_comp *));
d3853 1
a3853 1
      dc = d_mangled_name (&di, 1);
d3855 1
a3855 1
      dc = d_type (&di);
d3878 1
a3878 1
      ret = d_print (options, dc, estimate, palc);
d4079 1
a4079 1
  struct d_comp *dc;
d4085 1
a4085 1
  d_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di);
d4089 2
a4090 2
    __extension__ struct d_comp comps[di.num_comps];
    __extension__ struct d_comp *subs[di.num_subs];
d4095 4
a4098 4
    di.comps = (struct d_comp *) malloc (di.num_comps
					 * sizeof (struct d_comp));
    di.subs = (struct d_comp **) malloc (di.num_subs
					 * sizeof (struct d_comp *));
d4109 1
a4109 1
    dc = d_mangled_name (&di, 1);
d4122 5
a4126 5
	  case D_COMP_TYPED_NAME:
	  case D_COMP_TEMPLATE:
	  case D_COMP_RESTRICT_THIS:
	  case D_COMP_VOLATILE_THIS:
	  case D_COMP_CONST_THIS:
d4129 2
a4130 2
	  case D_COMP_QUAL_NAME:
	  case D_COMP_LOCAL_NAME:
d4133 1
a4133 1
	  case D_COMP_CTOR:
d4138 1
a4138 1
	  case D_COMP_DTOR:
@


1.44
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright (C) 2003 Free Software Foundation, Inc.
d1112 17
@


1.43
log
@merge from gcc
@
text
@d4088 1
a4088 2
	*palc = 1;
	return NULL;
@


1.42
log
@merge from gcc
@
text
@d85 14
d126 2
d154 2
d158 2
d172 2
d177 2
d183 2
d349 1
d377 2
d395 4
d401 4
d484 2
a485 7
#define d_append_string(dpi, s) \
  do \
    { \
      size_t d_append_string_len = strlen (s); \
      d_append_buffer ((dpi), (s), d_append_string_len); \
    } \
  while (0)
d513 1
a513 1
static struct d_comp *d_make_sub PARAMS ((struct d_info *, const char *));
d551 1
a551 1
static char *d_print PARAMS ((int, const struct d_comp *, size_t *));
d554 2
a555 2
static void d_print_identifier PARAMS ((struct d_print_info *, const char *,
					int));
d570 1
a570 1
static int d_init_info PARAMS ((const char *, int, size_t, struct d_info *));
d996 1
a996 1
d_make_sub (di, name)
d999 1
d1005 4
a1008 1
    p->u.s_string.string = name;
d1164 1
d1315 8
a1322 1
    return d_operator_name (di);
d1352 1
a1352 1
  int sign;
d1356 1
a1356 1
  sign = 1;
d1360 1
a1360 1
      sign = -1;
d1369 5
a1373 1
	return ret * sign;
d1390 4
d1415 5
a1419 2
	return d_make_name (di, "(anonymous namespace)",
			    sizeof "(anonymous namespace)" - 1);
d1430 2
d1434 49
a1482 49
  { "aN", "&=",        2 },
  { "aS", "=",         2 },
  { "aa", "&&",        2 },
  { "ad", "&",         1 },
  { "an", "&",         2 },
  { "cl", "()",        0 },
  { "cm", ",",         2 },
  { "co", "~",         1 },
  { "dV", "/=",        2 },
  { "da", "delete[]",  1 },
  { "de", "*",         1 },
  { "dl", "delete",    1 },
  { "dv", "/",         2 },
  { "eO", "^=",        2 },
  { "eo", "^",         2 },
  { "eq", "==",        2 },
  { "ge", ">=",        2 },
  { "gt", ">",         2 },
  { "ix", "[]",        2 },
  { "lS", "<<=",       2 },
  { "le", "<=",        2 },
  { "ls", "<<",        2 },
  { "lt", "<",         2 },
  { "mI", "-=",        2 },
  { "mL", "*=",        2 },
  { "mi", "-",         2 },
  { "ml", "*",         2 },
  { "mm", "--",        1 },
  { "na", "new[]",     1 },
  { "ne", "!=",        2 },
  { "ng", "-",         1 },
  { "nt", "!",         1 },
  { "nw", "new",       1 },
  { "oR", "|=",        2 },
  { "oo", "||",        2 },
  { "or", "|",         2 },
  { "pL", "+=",        2 },
  { "pl", "+",         2 },
  { "pm", "->*",       2 },
  { "pp", "++",        1 },
  { "ps", "+",         1 },
  { "pt", "->",        2 },
  { "qu", "?",         3 },
  { "rM", "%=",        2 },
  { "rS", ">>=",       2 },
  { "rm", "%",         2 },
  { "rs", ">>",        2 },
  { "st", "sizeof ",   1 },
  { "sz", "sizeof ",   1 }
d1544 1
d1551 1
d1554 1
d1595 1
d1681 7
d1758 26
a1783 26
  /* a */ { "signed char",	"signed char",		D_PRINT_INT },
  /* b */ { "bool",		"boolean",		D_PRINT_BOOL },
  /* c */ { "char",		"byte",			D_PRINT_INT },
  /* d */ { "double",		"double",		D_PRINT_DEFAULT },
  /* e */ { "long double",	"long double",		D_PRINT_DEFAULT },
  /* f */ { "float",		"float",		D_PRINT_DEFAULT },
  /* g */ { "__float128",	"__float128",		D_PRINT_DEFAULT },
  /* h */ { "unsigned char",	"unsigned char",	D_PRINT_INT },
  /* i */ { "int",		"int",			D_PRINT_INT },
  /* j */ { "unsigned int",	"unsigned",		D_PRINT_INT },
  /* k */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* l */ { "long",		"long",			D_PRINT_LONG },
  /* m */ { "unsigned long",	"unsigned long",	D_PRINT_LONG },
  /* n */ { "__int128",		"__int128",		D_PRINT_DEFAULT },
  /* o */ { "unsigned __int128", "unsigned __int128",	D_PRINT_DEFAULT },
  /* p */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* q */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* r */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* s */ { "short",		"short",		D_PRINT_INT },
  /* t */ { "unsigned short",	"unsigned short",	D_PRINT_INT },
  /* u */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* v */ { "void",		"void",			D_PRINT_VOID },
  /* w */ { "wchar_t",		"char",			D_PRINT_INT },
  /* x */ { "long long",	"long",			D_PRINT_DEFAULT },
  /* y */ { "unsigned long long", "unsigned long long",	D_PRINT_DEFAULT },
  /* z */ { "...",		"...",			D_PRINT_DEFAULT },
d1832 1
d1963 4
a1966 1
	t = member_fn ? D_COMP_RESTRICT_THIS: D_COMP_RESTRICT;
d1968 4
a1971 1
	t = member_fn ? D_COMP_VOLATILE_THIS : D_COMP_VOLATILE;
d1973 4
a1976 1
	t = member_fn ? D_COMP_CONST_THIS: D_COMP_CONST;
d2060 4
a2063 1
    tl = NULL;
d2184 2
d2307 3
d2385 6
d2513 21
a2533 15
  { 't', "std", "std", NULL },
  { 'a', "std::allocator", "std::allocator", "allocator" },
  { 'b', "std::basic_string", "std::basic_string", "basic_string" },
  { 's', "std::string",
    "std::basic_string<char, std::char_traits<char>, std::allocator<char> >",
    "basic_string" },
  { 'i', "std::istream",
    "std::basic_istream<char, std::char_traits<char> >",
    "basic_istream" },
  { 'o', "std::ostream",
    "std::basic_ostream<char, std::char_traits<char> >",
    "basic_ostream" },
  { 'd', "std::iostream",
    "std::basic_iostream<char, std::char_traits<char> >",
    "basic_iostream" }
d2572 2
d2598 3
d2602 2
a2603 1
		di->last_name = d_make_sub (di, p->set_last_name);
d2605 4
a2608 1
		return d_make_sub (di, p->full_expansion);
d2610 6
a2615 1
		return d_make_sub (di, p->simple_expansion);
d2707 7
a2713 4
/* Turn components into a human readable string.  Returns a string
   allocated by malloc, or NULL on error.  On success, this sets *PALC
   to the size of the allocated buffer.  On failure, this sets *PALC
   to 0 for a bad parse, or to 1 for a memory allocation failure.  */
d2716 1
a2716 1
d_print (options, dc, palc)
d2719 1
d2726 1
a2726 1
  dpi.alc = 64;
d2770 4
a2773 1
      d_print_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);
d2779 4
a2782 1
      d_append_string (dpi, (dpi->options & DMGL_JAVA) == 0 ? "::" : ".");
d2969 1
a2969 1
      d_append_string (dpi, "vtable for ");
d2974 1
a2974 1
      d_append_string (dpi, "VTT for ");
d2979 1
a2979 1
      d_append_string (dpi, "construction vtable for ");
d2981 1
a2981 1
      d_append_string (dpi, "-in-");
d2986 1
a2986 1
      d_append_string (dpi, "typeinfo for ");
d2991 1
a2991 1
      d_append_string (dpi, "typeinfo name for ");
d2996 1
a2996 1
      d_append_string (dpi, "typeinfo fn for ");
d3001 1
a3001 1
      d_append_string (dpi, "non-virtual thunk to ");
d3006 1
a3006 1
      d_append_string (dpi, "virtual thunk to ");
d3011 1
a3011 1
      d_append_string (dpi, "covariant return thunk to ");
d3016 1
a3016 1
      d_append_string (dpi, "java Class for ");
d3021 1
a3021 1
      d_append_string (dpi, "guard variable for ");
d3026 1
a3026 1
      d_append_string (dpi, "reference temporary for ");
d3031 1
a3031 1
      d_append_string (dpi, dc->u.s_string.string);
d3069 2
a3070 1
	d_append_string (dpi, dc->u.s_builtin.type->name);
d3072 2
a3073 1
	d_append_string (dpi, dc->u.s_builtin.type->java_name);
d3153 1
a3153 1
	    d_append_string (dpi, "::*");
d3166 1
a3166 1
	  d_append_string (dpi, ", ");
d3175 1
a3175 1
	d_append_string (dpi, "operator");
d3179 2
a3180 1
	d_append_string (dpi, dc->u.s_operator.op->name);
d3185 1
a3185 1
      d_append_string (dpi, "operator ");
d3190 1
a3190 1
      d_append_string (dpi, "operator ");
d3199 1
a3199 1
	  d_append_string (dpi, "((");
d3221 2
a3222 1
	  && strcmp (d_left (dc)->u.s_operator.op->name, ">") == 0)
d3227 1
a3227 1
      d_append_string (dpi, ") ");
d3229 1
a3229 1
      d_append_string (dpi, " (");
d3234 2
a3235 1
	  && strcmp (d_left (dc)->u.s_operator.op->name, ">") == 0)
d3254 1
a3254 1
      d_append_string (dpi, ") ");
d3256 1
a3256 1
      d_append_string (dpi, " (");
d3258 1
a3258 1
      d_append_string (dpi, ") : (");
d3305 1
a3305 1
		      d_append_string (dpi, "false");
d3308 1
a3308 1
		      d_append_string (dpi, "true");
d3335 4
a3338 1
/* Print an identifier.  */
d3341 1
a3341 1
d_print_identifier (dpi, name, len)
d3346 5
a3350 3
  if ((dpi->options & DMGL_JAVA) == 0)
    d_append_buffer (dpi, name, len);
  else
d3352 7
a3358 2
      const char *p;
      const char *end;
d3360 2
a3361 11
      /* For Java we try to handle encoded extended Unicode
	 characters.  The C++ ABI doesn't mention Unicode encoding, so
	 we don't it for C++.  Characters are encoded as
	 __U<hex-char>+_.  */
      end = name + len;
      for (p = name; p < end; ++p)
	{
	  if (end - p > 3
	      && p[0] == '_'
	      && p[1] == '_'
	      && p[2] == 'U')
d3363 1
a3363 2
	      unsigned long c;
	      const char *q;
d3365 8
a3372 4
	      c = 0;
	      for (q = p + 3; q < end; ++q)
		{
		  int dig;
d3374 9
a3382 19
		  if (IS_DIGIT (*q))
		    dig = *q - '0';
		  else if (*q >= 'A' && *q <= 'F')
		    dig = *q - 'A' + 10;
		  else if (*q >= 'a' && *q <= 'f')
		    dig = *q - 'a' + 10;
		  else
		    break;

		  c = c * 16 + dig;
		}
	      /* If the Unicode character is larger than 256, we don't
		 try to deal with it here.  FIXME.  */
	      if (q < end && *q == '_' && c < 256)
		{
		  d_append_char (dpi, c);
		  p = q;
		  continue;
		}
d3384 1
d3386 1
a3386 2
	  d_append_char (dpi, *p);
	}
d3446 4
a3449 1
      d_append_string (dpi, (dpi->options & DMGL_JAVA) == 0 ? "::" : ".");
d3481 1
a3481 1
      d_append_string (dpi, " restrict");
d3485 1
a3485 1
      d_append_string (dpi, " volatile");
d3489 1
a3489 1
      d_append_string (dpi, " const");
d3504 1
a3504 1
      d_append_string (dpi, "complex ");
d3507 1
a3507 1
      d_append_string (dpi, "imaginary ");
d3513 1
a3513 1
      d_append_string (dpi, "::*");
d3647 1
a3647 1
	d_append_string (dpi, " (");
d3674 2
a3675 1
    d_append_string (dpi, dc->u.s_operator.op->name);
d3727 1
a3727 1
static int
d3735 1
a3743 2
  di->comps = (struct d_comp *) malloc (di->num_comps
					* sizeof (struct d_comp));
a3748 2
  di->subs = (struct d_comp **) malloc (di->num_subs
					* sizeof (struct d_comp *));
d3750 1
d3754 1
a3754 10
  if (di->comps == NULL || di->subs == NULL)
    {
      if (di->comps != NULL)
	free (di->comps);
      if (di->subs != NULL)
	free (di->subs);
      return 0;
    }

  return 1;
d3774 1
d3810 1
a3810 5
  if (! d_init_info (mangled, options, len, &di))
    {
      *palc = 1;
      return NULL;
    }
d3812 22
a3833 4
  if (! type)
    dc = d_mangled_name (&di, 1);
  else
    dc = d_type (&di);
d3835 11
a3845 6
  /* If DMGL_PARAMS is set, then if we didn't consume the entire
     mangled string, then we didn't successfully demangle it.  If
     DMGL_PARAMS is not set, we didn't look at the trailing
     parameters.  */
  if (((options & DMGL_PARAMS) != 0) && d_peek_char (&di) != '\0')
    dc = NULL;
d3848 4
a3851 4
  if (dc == NULL)
    printf ("failed demangling\n");
  else
    d_dump (dc, 0);
d3854 13
a3866 2
  free (di.subs);
  di.subs = NULL;
d3868 4
a3871 3
  ret = NULL;
  if (dc != NULL)
    ret = d_print (options, dc, palc);
d3873 13
a3885 1
  free (di.comps);
d4068 24
a4091 2
  if (! d_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di))
    return 0;
d4093 1
a4093 1
  dc = d_mangled_name (&di, 1);
d4095 2
a4096 2
  /* Note that because we did not pass DMGL_PARAMS, we don't expect to
     demangle the entire string.  */
d4098 31
a4128 31
  ret = 0;
  while (dc != NULL)
    {
      switch (dc->type)
	{
	default:
	  dc = NULL;
	  break;
	case D_COMP_TYPED_NAME:
	case D_COMP_TEMPLATE:
	case D_COMP_RESTRICT_THIS:
	case D_COMP_VOLATILE_THIS:
	case D_COMP_CONST_THIS:
	  dc = d_left (dc);
	  break;
	case D_COMP_QUAL_NAME:
	case D_COMP_LOCAL_NAME:
	  dc = d_right (dc);
	  break;
	case D_COMP_CTOR:
	  *ctor_kind = dc->u.s_ctor.kind;
	  ret = 1;
	  dc = NULL;
	  break;
	case D_COMP_DTOR:
	  *dtor_kind = dc->u.s_dtor.kind;
	  ret = 1;
	  dc = NULL;
	  break;
	}
    }
d4130 5
a4134 2
  free (di.subs);
  free (di.comps);
@


1.41
log
@merge from gcc
@
text
@d1344 7
@


1.40
log
@merge from gcc
@
text
@d169 2
d590 3
d756 1
d1034 1
d2342 1
a2342 1
      return d_make_comp (di, D_COMP_QUAL_NAME, function,
d2353 1
a2353 1
      return d_make_comp (di, D_COMP_QUAL_NAME, function, name);
d2651 1
d2703 32
d3303 28
d3406 1
d3460 3
d3471 1
a3471 8
    {
      struct d_print_mod *hold_modifiers;

      hold_modifiers = dpi->modifiers;
      dpi->modifiers = NULL;
      d_print_comp (dpi, d_right (dc));
      dpi->modifiers = hold_modifiers;
    }
d3476 2
d3927 1
@


1.39
log
@merge from gcc
@
text
@d3399 8
a3406 1
    d_print_comp (dpi, d_right (dc));
d3632 5
a3636 3
  /* If we didn't consume the entire mangled string, then we didn't
     successfully demangle it.  */
  if (d_peek_char (&di) != '\0')
d3841 3
d3845 1
a3845 1
  if (d_peek_char (&di) == '\0')
d3847 1
a3847 1
      while (dc != NULL)
d3849 23
a3871 26
	  switch (dc->type)
	    {
	    default:
	      dc = NULL;
	      break;
	    case D_COMP_TYPED_NAME:
	    case D_COMP_TEMPLATE:
	    case D_COMP_RESTRICT_THIS:
	    case D_COMP_VOLATILE_THIS:
	    case D_COMP_CONST_THIS:
	      dc = d_left (dc);
	      break;
	    case D_COMP_QUAL_NAME:
	      dc = d_right (dc);
	      break;
	    case D_COMP_CTOR:
	      *ctor_kind = dc->u.s_ctor.kind;
	      ret = 1;
	      dc = NULL;
	      break;
	    case D_COMP_DTOR:
	      *dtor_kind = dc->u.s_dtor.kind;
	      ret = 1;
	      dc = NULL;
	      break;
	    }
@


1.38
log
@merge from gcc
@
text
@d144 17
d259 3
a261 1
  D_COMP_LITERAL
d511 1
a511 1
static struct d_comp *d_substitution PARAMS ((struct d_info *));
d705 3
d762 1
d1113 1
a1113 1
	    dc = d_substitution (di);
d1228 1
a1228 1
	dc = d_substitution (di);
d1802 1
a1802 1
	    ret = d_substitution (di);
d2280 1
d2296 6
d2305 1
a2305 2
      ret = d_make_comp (di, D_COMP_LITERAL, type,
			 d_make_name (di, s, d_str (di) - s));
d2395 8
d2405 19
d2425 1
a2425 1
d_substitution (di)
d2427 1
d2464 6
a2469 1
      switch (c)
d2471 20
a2490 22
	case 't':
	  return d_make_sub (di, "std");
	case 'a':
	  di->last_name = d_make_sub (di, "allocator");
	  return d_make_sub (di, "std::allocator");
	case 'b':
	  di->last_name = d_make_sub (di, "basic_string");
	  return d_make_sub (di, "std::basic_string");
	case 's':
	  di->last_name = d_make_sub (di, "string");
	  return d_make_sub (di, "std::string");
	case 'i':
	  di->last_name = d_make_sub (di, "istream");
	  return d_make_sub (di, "std::istream");
	case 'o':
	  di->last_name = d_make_sub (di, "ostream");
	  return d_make_sub (di, "std::ostream");
	case 'd':
	  di->last_name = d_make_sub (di, "iostream");
	  return d_make_sub (di, "std::iostream");
	default:
	  return NULL;
d2492 2
d3096 1
d3105 2
d3115 2
d3125 2
a3126 1
		  && d_right (dc)->u.s_name.len == 1)
d3150 2
@


1.37
log
@merge from gcc
@
text
@d31 37
d85 8
a92 10
/* This code implements a demangler for the g++ V3 ABI.  The ABI is
   described on this web page:
       http://www.codesourcery.com/cxx-abi/abi.html#mangling

   This code was written while looking at the demangler written by
   Alex Samuel <samuel@@codesourcery.com>.

   This code first pulls the mangled name apart into a list of
   components, and then walks the list generating the demangled
   name.  */
a93 1
/* Avoid pulling in the ctype tables for this simple usage.  */
d95 2
d194 6
d434 3
d478 1
a478 1
						struct d_comp **));
d504 1
a504 1
				      struct d_print_mod *));
d620 9
d782 3
d811 2
d984 3
a986 4
    case D_COMP_RESTRICT:
    case D_COMP_VOLATILE:
    case D_COMP_CONST:
    case D_COMP_VENDOR_TYPE_QUAL:
d1042 3
a1044 3
	  while (dc->type == D_COMP_RESTRICT
		 || dc->type == D_COMP_VOLATILE
		 || dc->type == D_COMP_CONST)
d1153 1
a1153 1
  pret = d_cv_qualifiers (di, &ret);
d1200 1
a1200 1
	  || (peek >= 'a' && peek <= 'z')
d1247 1
a1247 1
  else if (peek >= 'a' && peek <= 'z')
d1709 1
a1709 1
      pret = d_cv_qualifiers (di, &ret);
d1777 1
a1777 1
	    || (peek_next >= 'A' && peek_next <= 'Z'))
d1843 1
a1843 1
d_cv_qualifiers (di, pret)
d1846 1
d1857 1
a1857 1
	t = D_COMP_RESTRICT;
d1859 1
a1859 1
	t = D_COMP_VOLATILE;
d1861 1
a1861 1
	t = D_COMP_CONST;
d2032 1
a2032 1
  pmem = d_cv_qualifiers (di, &mem);
d2378 1
a2378 1
  if (c == '_' || IS_DIGIT (c) || (c >= 'A' && c <= 'Z'))
d2389 1
a2389 1
	      else if (c >= 'A' && c <= 'Z')
d2589 4
a2592 2
	const struct d_comp *typed_name;
	struct d_print_mod dpm;
d2596 4
a2599 5
	   the right place for the type.  If the name has
	   CV-qualifiers, they are really method qualifiers; pull them
	   off now and print them after everything else.  Note that we
	   don't handle D_COMP_VENDOR_TYPE_QUAL here; it's not
	   accepted by d_cv_qualifiers() either.  */
d2601 19
a2619 5
	while (typed_name != NULL
	       && (typed_name->type == D_COMP_RESTRICT
		   || typed_name->type == D_COMP_VOLATILE
		   || typed_name->type == D_COMP_CONST))
	  typed_name = d_left (typed_name);
d2621 2
a2622 5
	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = typed_name;
	dpm.printed = 0;
	dpm.templates = dpi->templates;
d2638 1
a2638 1
	/* If the modifier didn't get printed by the type, print it
d2640 1
a2640 1
	if (! dpm.printed)
d2642 6
a2647 2
	    d_append_char (dpi, ' ');
	    d_print_comp (dpi, typed_name);
d2650 1
a2650 12
	dpi->modifiers = dpm.next;

	/* Now print any CV-qualifiers on the type.  */
	typed_name = d_left (dc);
	while (typed_name != NULL
	       && (typed_name->type == D_COMP_RESTRICT
		   || typed_name->type == D_COMP_VOLATILE
		   || typed_name->type == D_COMP_CONST))
	  {
	    d_print_mod (dpi, typed_name);
	    typed_name = d_left (typed_name);
	  }
d2667 2
d2673 1
a2673 1
	if (dpi->buf != NULL && dpi->buf[dpi->len - 1] == '>')
d2806 3
a2903 1
	const struct d_comp *target_type;
a2905 11
	/* Pass the name down to the type so that it can be printed in
	   the right place for the type.  If the type has
	   CV-qualifiers, they are really method qualifiers; pull them
	   off now and print them after everything else.  */
	target_type = d_right (dc);
	while (target_type != NULL
	       && (target_type->type == D_COMP_RESTRICT
		   || target_type->type == D_COMP_VOLATILE
		   || target_type->type == D_COMP_CONST))
	  target_type = d_left (target_type);

d2912 1
a2912 1
	d_print_comp (dpi, target_type);
a2924 11
	/* Now print any CV-qualifiers on the type.  */
	target_type = d_right (dc);
	while (target_type != NULL
	       && (target_type->type == D_COMP_RESTRICT
		   || target_type->type == D_COMP_VOLATILE
		   || target_type->type == D_COMP_CONST))
	  {
	    d_print_mod (dpi, target_type);
	    target_type = d_left (target_type);
	  }

d2944 1
a2944 1
	if (c >= 'a' && c <= 'z')
d2982 8
d2997 5
d3126 1
a3126 1
		  if (*q >= '0' && *q <= '9')
d3152 2
a3153 1
/* Print a list of modifiers.  */
d3156 1
a3156 1
d_print_mod_list (dpi, mods)
d3159 1
d3163 1
a3163 1
  if (mods == NULL || mods->printed || d_print_saw_error (dpi))
d3166 10
d3198 1
a3198 1
  d_print_mod_list (dpi, mods->next);
d3211 1
d3215 1
d3219 1
d3241 1
a3241 1
      if (dpi->buf != NULL && dpi->buf[dpi->len - 1] != '(')
d3290 4
d3305 12
a3316 1
    d_append_char (dpi, '(');
d3318 4
a3321 1
  d_print_mod_list (dpi, mods);
d3332 2
d3374 1
a3374 1
      d_print_mod_list (dpi, mods);
d3434 2
d3440 1
a3440 1
      if (dpi->buf != NULL && dpi->buf[dpi->len - 1] == '>')
d3752 1
d3762 2
a3763 4
  if (dc == NULL || d_peek_char (&di) != '\0')
    return 0;

  while (dc != NULL)
d3765 1
a3765 1
      switch (dc->type)
d3767 26
a3792 19
	default:
	  return 0;
	case D_COMP_TYPED_NAME:
	case D_COMP_TEMPLATE:
	case D_COMP_RESTRICT:
	case D_COMP_VOLATILE:
	case D_COMP_CONST:
	case D_COMP_VENDOR_TYPE_QUAL:
	  dc = d_left (dc);
	  break;
	case D_COMP_QUAL_NAME:
	  dc = d_right (dc);
	  break;
	case D_COMP_CTOR:
	  *ctor_kind = dc->u.s_ctor.kind;
	  return 1;
	case D_COMP_DTOR:
	  *dtor_kind = dc->u.s_dtor.kind;
	  return 1;
d3796 4
a3799 1
  return 0;
@


1.36
log
@merge from gcc
@
text
@d3327 1
a3327 1
	 the template printing here.  FIXME: Verify this.  */
d3459 5
d3665 1
a3665 1
  if (dc == NULL)
@


1.35
log
@merge from gcc
@
text
@d334 2
d416 1
a416 1
static struct d_comp *d_mangled_name PARAMS ((struct d_info *));
d669 2
a670 1
     from a subroutine.  We catch here, and return NULL on upward.  */
d772 2
d805 2
d826 2
d847 2
d888 3
a890 1
/* <mangled-name> ::= _Z <encoding> */
d893 1
a893 1
d_mangled_name (di)
d895 1
d901 1
a901 1
  return d_encoding (di, 1);
d978 13
d992 1
a992 3
      if (peek == '\0'
	  || peek == 'E'
	  || (top_level && (di->options & DMGL_PARAMS) == 0))
d1638 7
a1644 3
     FIXME: The ABI specifies that vendor qualifiers are handled just
     like the standard CV-qualifiers with respect to subsetting and
     substitution, but g++ does not appear to work this way.  */
d1652 2
d1737 1
a1737 1
	    if (ret->type == D_COMP_SUB_STD)
d1870 2
d1929 2
d1974 2
d2039 2
d2194 1
a2194 1
    ret = d_mangled_name (di);
d2289 2
d2385 2
d2551 1
d2592 23
a2614 9
      d_print_comp (dpi, d_left (dc));
      d_append_char (dpi, '<');
      d_print_comp (dpi, d_right (dc));
      /* Avoid generating two consecutive '>' characters, to avoid the
	 C++ syntactic ambiguity.  */
      if (dpi->buf[dpi->len - 1] == '>')
	d_append_char (dpi, ' ');
      d_append_char (dpi, '>');
      return;
d2753 1
d2791 1
d2819 1
d2853 1
d3100 2
d3105 5
a3111 1
      mods->printed = 1;
d3113 1
a3117 1
      mods->printed = 1;
d3119 1
d3123 1
a3123 1
  mods->printed = 1;
d3125 1
a3125 1
  d_print_mod (dpi, mods->mod);
d3129 1
a3129 1
 
d3167 1
a3167 1
      if (dpi->buf[dpi->len - 1] != '(')
d3191 7
a3197 1
  if (mods != NULL)
d3199 2
a3200 3
      int need_paren;
      int saw_mod;
      struct d_print_mod *p;
d3202 2
a3203 3
      need_paren = 0;
      saw_mod = 0;
      for (p = mods; p != NULL; p = p->next)
d3205 13
a3217 22
	  if (p->printed)
	    break;

	  saw_mod = 1;
	  switch (p->mod->type)
	    {
	    case D_COMP_RESTRICT:
	    case D_COMP_VOLATILE:
	    case D_COMP_CONST:
	    case D_COMP_VENDOR_TYPE_QUAL:
	    case D_COMP_POINTER:
	    case D_COMP_REFERENCE:
	    case D_COMP_COMPLEX:
	    case D_COMP_IMAGINARY:
	    case D_COMP_PTRMEM_TYPE:
	      need_paren = 1;
	      break;
	    default:
	      break;
	    }
	  if (need_paren)
	    break;
d3219 3
d3223 2
a3224 2
      if (d_left (dc) != NULL && ! saw_mod)
	need_paren = 1;
d3226 2
a3227 2
      if (need_paren)
	d_append_char (dpi, '(');
d3229 1
a3229 1
      d_print_mod_list (dpi, mods);
d3231 2
a3232 3
      if (need_paren)
	d_append_char (dpi, ')');
    }
d3321 1
d3329 3
d3344 1
a3344 1
      if (dpi->buf[dpi->len - 1] == '>')
d3347 2
d3376 2
a3377 3
     chars in the mangled string divided by 2, since it takes at least
     two chars to refer to a substitution.  */
  di->num_subs = (len + 1) / 2;
d3455 1
a3455 1
    dc = d_mangled_name (&di);
d3658 1
a3658 1
  dc = d_mangled_name (&di);
@


1.34
log
@merge from gcc
@
text
@d3531 1
a3531 1
  demangled = d_demangle (mangled, DMGL_JAVA, &alc);
@


1.33
log
@merge from gcc
@
text
@d417 1
a417 1
static struct d_comp *d_encoding PARAMS ((struct d_info *));
d887 1
a887 1
  return d_encoding (di);
d943 6
a948 1
              ::= <special-name>  */
d951 1
a951 1
d_encoding (di)
d953 1
d965 3
a967 1
      if (peek == '\0' || peek == 'E')
d1384 1
a1384 1
	  return d_make_comp (di, D_COMP_THUNK, d_encoding (di), NULL);
d1389 1
a1389 1
	  return d_make_comp (di, D_COMP_VIRTUAL_THUNK, d_encoding (di),
d1397 1
a1397 1
	  return d_make_comp (di, D_COMP_COVARIANT_THUNK, d_encoding (di),
a1636 1
      /* FIXME: The old demangler handles Java types here.  */
d2198 1
a2198 1
  function = d_encoding (di);
d3683 1
d3693 4
a3696 3
  { "help",    no_argument, NULL, 'h' },
  { "verbose", no_argument, NULL, 'v' },
  { NULL,      no_argument, NULL, 0   },
d3719 1
a3719 1
      opt_char = getopt_long (argc, argv, "hv", long_options, NULL);
d3728 4
@


1.32
log
@merge from gcc
@
text
@d911 5
@


1.31
log
@merge from gcc
@
text
@d1 3
a3 3
/* Demangler for IA64 / g++ V3 ABI.
   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
   Written by Alex Samuel <samuel@@codesourcery.com>. 
a30 7
/* This file implements demangling of C++ names mangled according to
   the IA64 / g++ V3 ABI.  Use the cp_demangle function to
   demangle a mangled name, or compile with the preprocessor macro
   STANDALONE_DEMANGLER defined to create a demangling filter
   executable (functionally similar to c++filt, but includes this
   demangler only).  */

d35 1
a35 1
#include <sys/types.h>
a39 3

#include <stdio.h>

a43 2
#include <ctype.h>

a45 1
#include "dyn-string.h"
d48 10
a57 9
/* If CP_DEMANGLE_DEBUG is defined, a trace of the grammar evaluation,
   and other debugging output, will be generated. */
#ifdef CP_DEMANGLE_DEBUG
#define DEMANGLE_TRACE(PRODUCTION, DM)                                  \
  fprintf (stderr, " -> %-24s at position %3d\n",                       \
           (PRODUCTION), current_position (DM));
#else
#define DEMANGLE_TRACE(PRODUCTION, DM)
#endif
d59 2
a60 6
/* Don't include <ctype.h>, to prevent additional unresolved symbols
   from being dragged into the C++ runtime library.  */
#define IS_DIGIT(CHAR) ((CHAR) >= '0' && (CHAR) <= '9')
#define IS_ALPHA(CHAR)                                                  \
  (((CHAR) >= 'a' && (CHAR) <= 'z')                                     \
   || ((CHAR) >= 'A' && (CHAR) <= 'Z'))
d65 4
d70 9
a78 2
/* Character(s) to use for namespace separation in demangled output */
#define NAMESPACE_SEPARATOR (dm->style == DMGL_JAVA ? "." : "::")
d80 1
a80 25
/* If flag_verbose is zero, some simplifications will be made to the
   output to make it easier to read and supress details that are
   generally not of interest to the average C++ programmer.
   Otherwise, the demangled representation will attempt to convey as
   much information as the mangled form.  */
static int flag_verbose;

/* If flag_strict is non-zero, demangle strictly according to the
   specification -- don't demangle special g++ manglings.  */
static int flag_strict;

/* String_list_t is an extended form of dyn_string_t which provides a
   link field and a caret position for additions to the string.  A
   string_list_t may safely be cast to and used as a dyn_string_t.  */

struct string_list_def
{
  /* The dyn_string; must be first.  */
  struct dyn_string string;

  /* The position at which additional text is added to this string
     (using the result_add* macros).  This value is an offset from the
     end of the string, not the beginning (and should be
     non-positive).  */
  int caret_position;
d82 12
a93 2
  /* The next string in the list.  */
  struct string_list_def *next;
d96 11
a106 1
typedef struct string_list_def *string_list_t;
d108 1
a108 1
/* Data structure representing a potential substitution.  */
d110 1
a110 1
struct substitution_def
d112 89
a200 5
  /* The demangled text of the substitution.  */
  dyn_string_t text;

  /* Whether this substitution represents a template item.  */
  int template_p : 1;
d203 1
a203 1
/* Data structure representing a template argument list.  */
d205 1
a205 1
struct template_arg_list_def
d207 19
a225 3
  /* The next (lower) template argument list in the stack of currently
     active template arguments.  */
  struct template_arg_list_def *next;
d227 8
a234 3
  /* The first element in the list of template arguments in
     left-to-right order.  */
  string_list_t first_argument;
d236 6
a241 3
  /* The last element in the arguments lists.  */
  string_list_t last_argument;
};
d243 6
a248 1
typedef struct template_arg_list_def *template_arg_list_t;
d250 5
a254 1
/* Data structure to maintain the state of the current demangling.  */
d256 5
a260 4
struct demangling_def
{
  /* The full mangled name being mangled.  */
  const char *name;
d262 5
a266 2
  /* Pointer into name at the current position.  */
  const char *next;
d268 6
a273 3
  /* Stack for strings containing demangled result generated so far.
     Text is emitted to the topmost (first) string.  */
  string_list_t result;
d275 2
a276 2
  /* The number of presently available substitutions.  */
  int num_substitutions;
d278 2
a279 2
  /* The allocated size of the substitutions array.  */
  int substitutions_allocated;
d281 1
a281 3
  /* An array of available substitutions.  The number of elements in
     the array is given by num_substitions, and the allocated array
     size in substitutions_size.  
d283 23
a305 1
     The most recent substition is at the end, so
d307 15
a321 2
       - `S_'  corresponds to substititutions[num_substitutions - 1] 
       - `S0_' corresponds to substititutions[num_substitutions - 2]
d323 1
a323 2
     etc. */
  struct substitution_def *substitutions;
d325 10
a334 2
  /* The stack of template argument lists.  */
  template_arg_list_t template_arg_lists;
d336 1
a336 5
  /* The most recently demangled source-name.  */
  dyn_string_t last_source_name;
  
  /* Language style to use for demangled output. */
  int style;
d338 18
a355 3
  /* Set to non-zero iff this name is a constructor.  The actual value
     indicates what sort of constructor this is; see demangle.h.  */
  enum gnu_v3_ctor_kinds is_constructor;
d357 1
a357 3
  /* Set to non-zero iff this name is a destructor.  The actual value
     indicates what sort of destructor this is; see demangle.h.  */
  enum gnu_v3_dtor_kinds is_destructor;
d359 9
a367 1
};
d369 12
a380 1
typedef struct demangling_def *demangling_t;
d382 6
a387 27
/* This type is the standard return code from most functions.  Values
   other than STATUS_OK contain descriptive messages.  */
typedef const char *status_t;

/* Special values that can be used as a status_t.  */
#define STATUS_OK                       NULL
#define STATUS_ERROR                    "Error."
#define STATUS_UNIMPLEMENTED            "Unimplemented."
#define STATUS_INTERNAL_ERROR           "Internal error."

/* This status code indicates a failure in malloc or realloc.  */
static const char *const status_allocation_failed = "Allocation failed.";
#define STATUS_ALLOCATION_FAILED        status_allocation_failed

/* Non-zero if STATUS indicates that no error has occurred.  */
#define STATUS_NO_ERROR(STATUS)         ((STATUS) == STATUS_OK)

/* Evaluate EXPR, which must produce a status_t.  If the status code
   indicates an error, return from the current function with that
   status code.  */
#define RETURN_IF_ERROR(EXPR)                                           \
  do                                                                    \
    {                                                                   \
      status_t s = EXPR;                                                \
      if (!STATUS_NO_ERROR (s))                                         \
	return s;                                                       \
    }                                                                   \
a389 18
static status_t int_to_dyn_string 
  PARAMS ((int, dyn_string_t));
static string_list_t string_list_new
  PARAMS ((int));
static void string_list_delete
  PARAMS ((string_list_t));
static status_t result_add_separated_char
  PARAMS ((demangling_t, int));
static status_t result_push
  PARAMS ((demangling_t));
static string_list_t result_pop
  PARAMS ((demangling_t));
static int substitution_start
  PARAMS ((demangling_t));
static status_t substitution_add
  PARAMS ((demangling_t, int, int));
static dyn_string_t substitution_get
  PARAMS ((demangling_t, int, int *));
d391 1
a391 2
static void substitutions_print 
  PARAMS ((demangling_t, FILE *));
d393 80
a472 12
static template_arg_list_t template_arg_list_new
  PARAMS ((void));
static void template_arg_list_delete
  PARAMS ((template_arg_list_t));
static void template_arg_list_add_arg 
  PARAMS ((template_arg_list_t, string_list_t));
static string_list_t template_arg_list_get_arg
  PARAMS ((template_arg_list_t, int));
static void push_template_arg_list
  PARAMS ((demangling_t, template_arg_list_t));
static void pop_to_template_arg_list
  PARAMS ((demangling_t, template_arg_list_t));
a473 21
static void template_arg_list_print
  PARAMS ((template_arg_list_t, FILE *));
#endif
static template_arg_list_t current_template_arg_list
  PARAMS ((demangling_t));
static demangling_t demangling_new
  PARAMS ((const char *, int));
static void demangling_delete 
  PARAMS ((demangling_t));

/* The last character of DS.  Warning: DS is evaluated twice.  */
#define dyn_string_last_char(DS)                                        \
  (dyn_string_buf (DS)[dyn_string_length (DS) - 1])

/* Append a space character (` ') to DS if it does not already end
   with one.  Evaluates to 1 on success, or 0 on allocation failure.  */
#define dyn_string_append_space(DS)                                     \
      ((dyn_string_length (DS) > 0                                      \
        && dyn_string_last_char (DS) != ' ')                            \
       ? dyn_string_append_char ((DS), ' ')                             \
       : 1)
d475 4
a478 83
/* Returns the index of the current position in the mangled name.  */
#define current_position(DM)    ((DM)->next - (DM)->name)

/* Returns the character at the current position of the mangled name.  */
#define peek_char(DM)           (*((DM)->next))

/* Returns the character one past the current position of the mangled
   name.  */
#define peek_char_next(DM)                                              \
  (peek_char (DM) == '\0' ? '\0' : (*((DM)->next + 1)))

/* Returns the character at the current position, and advances the
   current position to the next character.  */
#define next_char(DM)           (*((DM)->next)++)

/* Returns non-zero if the current position is the end of the mangled
   name, i.e. one past the last character.  */
#define end_of_name_p(DM)       (peek_char (DM) == '\0')

/* Advances the current position by one character.  */
#define advance_char(DM)        (++(DM)->next)

/* Returns the string containing the current demangled result.  */
#define result_string(DM)       (&(DM)->result->string)

/* Returns the position at which new text is inserted into the
   demangled result.  */
#define result_caret_pos(DM)                                            \
  (result_length (DM) +                                                 \
   ((string_list_t) result_string (DM))->caret_position)

/* Adds a dyn_string_t to the demangled result.  */
#define result_add_string(DM, STRING)                                   \
  (dyn_string_insert (&(DM)->result->string,                            \
		      result_caret_pos (DM), (STRING))                  \
   ? STATUS_OK : STATUS_ALLOCATION_FAILED)

/* Adds NUL-terminated string CSTR to the demangled result.    */
#define result_add(DM, CSTR)                                            \
  (dyn_string_insert_cstr (&(DM)->result->string,                       \
			   result_caret_pos (DM), (CSTR))               \
   ? STATUS_OK : STATUS_ALLOCATION_FAILED)

/* Adds character CHAR to the demangled result.  */
#define result_add_char(DM, CHAR)                                       \
  (dyn_string_insert_char (&(DM)->result->string,                       \
			   result_caret_pos (DM), (CHAR))               \
   ? STATUS_OK : STATUS_ALLOCATION_FAILED)

/* Inserts a dyn_string_t to the demangled result at position POS.  */
#define result_insert_string(DM, POS, STRING)                           \
  (dyn_string_insert (&(DM)->result->string, (POS), (STRING))           \
   ? STATUS_OK : STATUS_ALLOCATION_FAILED)

/* Inserts NUL-terminated string CSTR to the demangled result at
   position POS.  */
#define result_insert(DM, POS, CSTR)                                    \
  (dyn_string_insert_cstr (&(DM)->result->string, (POS), (CSTR))        \
   ? STATUS_OK : STATUS_ALLOCATION_FAILED)

/* Inserts character CHAR to the demangled result at position POS.  */
#define result_insert_char(DM, POS, CHAR)                               \
  (dyn_string_insert_char (&(DM)->result->string, (POS), (CHAR))        \
   ? STATUS_OK : STATUS_ALLOCATION_FAILED)

/* The length of the current demangled result.  */
#define result_length(DM)                                               \
  dyn_string_length (&(DM)->result->string)

/* Appends a (less-than, greater-than) character to the result in DM
   to (open, close) a template argument or parameter list.  Appends a
   space first if necessary to prevent spurious elision of angle
   brackets with the previous character.  */
#define result_open_template_list(DM) result_add_separated_char(DM, '<')
#define result_close_template_list(DM) result_add_separated_char(DM, '>')

/* Appends a base 10 representation of VALUE to DS.  STATUS_OK on
   success.  On failure, deletes DS and returns an error code.  */

static status_t
int_to_dyn_string (value, ds)
     int value;
     dyn_string_t ds;
a480 1
  int mask = 1;
d482 2
a483 7
  /* Handle zero up front.  */
  if (value == 0)
    {
      if (!dyn_string_append_char (ds, '0'))
	return STATUS_ALLOCATION_FAILED;
      return STATUS_OK;
    }
d485 2
a486 15
  /* For negative numbers, emit a minus sign.  */
  if (value < 0)
    {
      if (!dyn_string_append_char (ds, '-'))
	return STATUS_ALLOCATION_FAILED;
      value = -value;
    }
  
  /* Find the power of 10 of the first digit.  */
  i = value;
  while (i > 9)
    {
      mask *= 10;
      i /= 10;
    }
d488 1
a488 2
  /* Write the digits.  */
  while (mask > 0)
d490 28
a517 1
      int digit = value / mask;
d519 111
a629 5
      if (!dyn_string_append_char (ds, '0' + digit))
	return STATUS_ALLOCATION_FAILED;

      value -= digit * mask;
      mask /= 10;
d632 2
a633 1
  return STATUS_OK;
d636 3
a638 4
/* Creates a new string list node.  The contents of the string are
   empty, but the initial buffer allocation is LENGTH.  The string
   list node should be deleted with string_list_delete.  Returns NULL
   if allocation fails.  */
d640 4
a643 3
static string_list_t 
string_list_new (length)
     int length;
d645 3
a647 3
  string_list_t s = (string_list_t) malloc (sizeof (struct string_list_def));
  s->caret_position = 0;
  if (s == NULL)
d649 77
a725 4
  if (!dyn_string_init ((dyn_string_t) s, length))
    return NULL;
  return s;
}  
d727 4
a730 1
/* Deletes the entire string list starting at NODE.  */
d732 2
a733 5
static void
string_list_delete (node)
     string_list_t node;
{
  while (node != NULL)
d735 2
a736 3
      string_list_t next = node->next;
      dyn_string_delete ((dyn_string_t) node);
      node = next;
d738 1
d741 1
a741 2
/* Appends CHARACTER to the demangled result.  If the current trailing
   character of the result is CHARACTER, a space is inserted first.  */
d743 5
a747 4
static status_t
result_add_separated_char (dm, character)
     demangling_t dm;
     int character;
d749 1
a749 2
  char *result = dyn_string_buf (result_string (dm));
  int caret_pos = result_caret_pos (dm);
d751 7
a757 8
  /* Add a space if the last character is already the character we
     want to add.  */
  if (caret_pos > 0 && result[caret_pos - 1] == character)
    RETURN_IF_ERROR (result_add_char (dm, ' '));
  /* Add the character.  */
  RETURN_IF_ERROR (result_add_char (dm, character));

  return STATUS_OK;
d760 1
a760 4
/* Allocates and pushes a new string onto the demangled results stack
   for DM.  Subsequent demangling with DM will emit to the new string.
   Returns STATUS_OK on success, STATUS_ALLOCATION_FAILED on
   allocation failure.  */
d762 4
a765 3
static status_t
result_push (dm)
     demangling_t dm;
d767 1
a767 4
  string_list_t new_string = string_list_new (0);
  if (new_string == NULL)
    /* Allocation failed.  */
    return STATUS_ALLOCATION_FAILED;
d769 4
a772 4
  /* Link the new string to the front of the list of result strings.  */
  new_string->next = (string_list_t) dm->result;
  dm->result = new_string;
  return STATUS_OK;
d775 1
a775 3
/* Removes and returns the topmost element on the demangled results
   stack for DM.  The caller assumes ownership for the returned
   string.  */
d777 4
a780 3
static string_list_t
result_pop (dm)
     demangling_t dm;
d782 1
a782 4
  string_list_t top = dm->result;
  dm->result = top->next;
  return top;
}
d784 4
a787 8
/* Returns the current value of the caret for the result string.  The
   value is an offet from the end of the result string.  */

static int
result_get_caret (dm)
     demangling_t dm;
{
  return ((string_list_t) result_string (dm))->caret_position;
d790 1
a790 2
/* Sets the value of the caret for the result string, counted as an
   offet from the end of the result string.  */
d792 5
a796 4
static void
result_set_caret (dm, position)
     demangling_t dm;
     int position;
d798 1
a798 2
  ((string_list_t) result_string (dm))->caret_position = position;
}
d800 7
a806 9
/* Shifts the position of the next addition to the result by
   POSITION_OFFSET.  A negative value shifts the caret to the left.  */

static void
result_shift_caret (dm, position_offset)
     demangling_t dm;
     int position_offset;
{
  ((string_list_t) result_string (dm))->caret_position += position_offset;
d809 1
a809 3
/* Returns non-zero if the character that comes right before the place
   where text will be added to the result is a space.  In this case,
   the caller should supress adding another space.  */
d811 5
a815 3
static int
result_previous_char_is_space (dm)
     demangling_t dm;
d817 1
a817 4
  char *result = dyn_string_buf (result_string (dm));
  int pos = result_caret_pos (dm);
  return pos > 0 && result[pos - 1] == ' ';
}
d819 7
a825 9
/* Returns the start position of a fragment of the demangled result
   that will be a substitution candidate.  Should be called at the
   start of productions that can add substitutions.  */

static int
substitution_start (dm)
     demangling_t dm;
{
  return result_caret_pos (dm);
d828 1
a828 3
/* Adds the suffix of the current demangled result of DM starting at
   START_POSITION as a potential substitution.  If TEMPLATE_P is
   non-zero, this potential substitution is a template-id.  */
d830 5
a834 5
static status_t
substitution_add (dm, start_position, template_p)
     demangling_t dm;
     int start_position;
     int template_p;
d836 1
a836 15
  dyn_string_t result = result_string (dm);
  dyn_string_t substitution = dyn_string_new (0);
  int i;

  if (substitution == NULL)
    return STATUS_ALLOCATION_FAILED;

  /* Extract the substring of the current demangling result that
     represents the subsitution candidate.  */
  if (!dyn_string_substring (substitution, 
			     result, start_position, result_caret_pos (dm)))
    {
      dyn_string_delete (substitution);
      return STATUS_ALLOCATION_FAILED;
    }
d838 2
a839 2
  /* If there's no room for the new entry, grow the array.  */
  if (dm->substitutions_allocated == dm->num_substitutions)
d841 2
a842 16
      size_t new_array_size;
      if (dm->substitutions_allocated > 0)
	dm->substitutions_allocated *= 2;
      else
	dm->substitutions_allocated = 2;
      new_array_size = 
	sizeof (struct substitution_def) * dm->substitutions_allocated;

      dm->substitutions = (struct substitution_def *)
	realloc (dm->substitutions, new_array_size);
      if (dm->substitutions == NULL)
	/* Realloc failed.  */
	{
	  dyn_string_delete (substitution);
	  return STATUS_ALLOCATION_FAILED;
	}
d844 1
a844 11

  /* Add the substitution to the array.  */
  i = dm->num_substitutions++;
  dm->substitutions[i].text = substitution;
  dm->substitutions[i].template_p = template_p;

#ifdef CP_DEMANGLE_DEBUG
  substitutions_print (dm, stderr);
#endif

  return STATUS_OK;
d847 1
a847 5
/* Returns the Nth-most-recent substitution.  Sets *TEMPLATE_P to
   non-zero if the substitution is a template-id, zero otherwise.  
   N is numbered from zero.  DM retains ownership of the returned
   string.  If N is negative, or equal to or greater than the current
   number of substitution candidates, returns NULL.  */
d849 4
a852 5
static dyn_string_t
substitution_get (dm, n, template_p)
     demangling_t dm;
     int n;
     int *template_p;
d854 1
a854 5
  struct substitution_def *sub;

  /* Make sure N is in the valid range.  */
  if (n < 0 || n >= dm->num_substitutions)
    return NULL;
d856 4
a859 3
  sub = &(dm->substitutions[n]);
  *template_p = sub->template_p;
  return sub->text;
d862 1
a862 2
#ifdef CP_DEMANGLE_DEBUG
/* Debugging routine to print the current substitutions to FP.  */
d864 4
a867 4
static void
substitutions_print (dm, fp)
     demangling_t dm;
     FILE *fp;
d869 1
a869 8
  int seq_id;
  int num = dm->num_substitutions;

  fprintf (fp, "SUBSTITUTIONS:\n");
  for (seq_id = -1; seq_id < num - 1; ++seq_id)
    {
      int template_p;
      dyn_string_t text = substitution_get (dm, seq_id + 1, &template_p);
d871 4
a874 6
      if (seq_id == -1)
	fprintf (fp, " S_ ");
      else
	fprintf (fp, " S%d_", seq_id);
      fprintf (fp, " %c: %s\n", template_p ? '*' : ' ', dyn_string_buf (text));
    }
d877 1
a877 4
#endif /* CP_DEMANGLE_DEBUG */

/* Creates a new template argument list.  Returns NULL if allocation
   fails.  */
d879 3
a881 2
static template_arg_list_t
template_arg_list_new ()
d883 3
a885 3
  template_arg_list_t new_list =
    (template_arg_list_t) malloc (sizeof (struct template_arg_list_def));
  if (new_list == NULL)
d887 1
a887 5
  /* Initialize the new list to have no arguments.  */
  new_list->first_argument = NULL;
  new_list->last_argument = NULL;
  /* Return the new list.  */
  return new_list;
d890 8
a897 2
/* Deletes a template argument list and the template arguments it
   contains.  */
d899 3
a901 3
static void
template_arg_list_delete (list)
     template_arg_list_t list;
d903 8
a910 43
  /* If there are any arguments on LIST, delete them.  */
  if (list->first_argument != NULL)
    string_list_delete (list->first_argument);
  /* Delete LIST.  */
  free (list);
}

/* Adds ARG to the template argument list ARG_LIST.  */

static void 
template_arg_list_add_arg (arg_list, arg)
     template_arg_list_t arg_list;
     string_list_t arg;
{
  if (arg_list->first_argument == NULL)
    /* If there were no arguments before, ARG is the first one.  */
    arg_list->first_argument = arg;
  else
    /* Make ARG the last argument on the list.  */
    arg_list->last_argument->next = arg;
  /* Make ARG the last on the list.  */
  arg_list->last_argument = arg;
  arg->next = NULL;
}

/* Returns the template arugment at position INDEX in template
   argument list ARG_LIST.  */

static string_list_t
template_arg_list_get_arg (arg_list, index)
     template_arg_list_t arg_list;
     int index;
{
  string_list_t arg = arg_list->first_argument;
  /* Scan down the list of arguments to find the one at position
     INDEX.  */
  while (index--)
    {
      arg = arg->next;
      if (arg == NULL)
	/* Ran out of arguments before INDEX hit zero.  That's an
	   error.  */
	return NULL;
a911 2
  /* Return the argument at position INDEX.  */
  return arg;
d914 2
a915 1
/* Pushes ARG_LIST onto the top of the template argument list stack.  */
d917 3
a919 4
static void
push_template_arg_list (dm, arg_list)
     demangling_t dm;
     template_arg_list_t arg_list;
d921 12
a932 27
  arg_list->next = dm->template_arg_lists;
  dm->template_arg_lists = arg_list;
#ifdef CP_DEMANGLE_DEBUG
  fprintf (stderr, " ** pushing template arg list\n");
  template_arg_list_print (arg_list, stderr);
#endif 
}

/* Pops and deletes elements on the template argument list stack until
   arg_list is the topmost element.  If arg_list is NULL, all elements
   are popped and deleted.  */

static void
pop_to_template_arg_list (dm, arg_list)
     demangling_t dm;
     template_arg_list_t arg_list;
{
  while (dm->template_arg_lists != arg_list)
    {
      template_arg_list_t top = dm->template_arg_lists;
      /* Disconnect the topmost element from the list.  */
      dm->template_arg_lists = top->next;
      /* Delete the popped element.  */
      template_arg_list_delete (top);
#ifdef CP_DEMANGLE_DEBUG
      fprintf (stderr, " ** removing template arg list\n");
#endif
d936 3
a938 3
#ifdef CP_DEMANGLE_DEBUG

/* Prints the contents of ARG_LIST to FP.  */
d940 3
a942 4
static void
template_arg_list_print (arg_list, fp)
  template_arg_list_t arg_list;
  FILE *fp;
d944 1
a944 2
  string_list_t arg;
  int index = -1;
d946 3
a948 2
  fprintf (fp, "TEMPLATE ARGUMENT LIST:\n");
  for (arg = arg_list->first_argument; arg != NULL; arg = arg->next)
d950 8
a957 6
      if (index == -1)
	fprintf (fp, " T_  : ");
      else
	fprintf (fp, " T%d_ : ", index);
      ++index;
      fprintf (fp, "%s\n", dyn_string_buf ((dyn_string_t) arg));
d961 4
a964 1
#endif /* CP_DEMANGLE_DEBUG */
d966 2
a967 2
/* Returns the topmost element on the stack of template argument
   lists.  If there is no list of template arguments, returns NULL.  */
d969 3
a971 6
static template_arg_list_t
current_template_arg_list (dm)
     demangling_t dm;
{
  return dm->template_arg_lists;
}
d973 3
a975 8
/* Allocates a demangling_t object for demangling mangled NAME.  A new
   result must be pushed before the returned object can be used.
   Returns NULL if allocation fails.  */

static demangling_t
demangling_new (name, style)
     const char *name;
     int style;
d977 2
a978 4
  demangling_t dm;
  dm = (demangling_t) malloc (sizeof (struct demangling_def));
  if (dm == NULL)
    return NULL;
d980 1
a980 12
  dm->name = name;
  dm->next = name;
  dm->result = NULL;
  dm->num_substitutions = 0;
  dm->substitutions_allocated = 10;
  dm->template_arg_lists = NULL;
  dm->last_source_name = dyn_string_new (0);
  if (dm->last_source_name == NULL)
    return NULL;
  dm->substitutions = (struct substitution_def *)
    malloc (dm->substitutions_allocated * sizeof (struct substitution_def));
  if (dm->substitutions == NULL)
d982 5
a986 6
      dyn_string_delete (dm->last_source_name);
      return NULL;
    }
  dm->style = style;
  dm->is_constructor = (enum gnu_v3_ctor_kinds) 0;
  dm->is_destructor = (enum gnu_v3_dtor_kinds) 0;
d988 3
a990 2
  return dm;
}
d992 12
a1003 2
/* Deallocates a demangling_t object and all memory associated with
   it.  */
d1005 19
a1023 6
static void
demangling_delete (dm)
     demangling_t dm;
{
  int i;
  template_arg_list_t arg_list = dm->template_arg_lists;
d1025 2
a1026 114
  /* Delete the stack of template argument lists.  */
  while (arg_list != NULL)
    {
      template_arg_list_t next = arg_list->next;
      template_arg_list_delete (arg_list);
      arg_list = next;
    }
  /* Delete the list of substitutions.  */
  for (i = dm->num_substitutions; --i >= 0; )
    dyn_string_delete (dm->substitutions[i].text);
  free (dm->substitutions);
  /* Delete the demangled result.  */
  string_list_delete (dm->result);
  /* Delete the stored identifier name.  */
  dyn_string_delete (dm->last_source_name);
  /* Delete the context object itself.  */
  free (dm);
}

/* These functions demangle an alternative of the corresponding
   production in the mangling spec.  The first argument of each is a
   demangling context structure for the current demangling
   operation.  Most emit demangled text directly to the topmost result
   string on the result string stack in the demangling context
   structure.  */

static status_t demangle_char
  PARAMS ((demangling_t, int));
static status_t demangle_mangled_name 
  PARAMS ((demangling_t));
static status_t demangle_encoding
  PARAMS ((demangling_t));
static status_t demangle_name
  PARAMS ((demangling_t, int *));
static status_t demangle_nested_name
  PARAMS ((demangling_t, int *));
static status_t demangle_prefix
  PARAMS ((demangling_t, int *));
static status_t demangle_unqualified_name
  PARAMS ((demangling_t, int *));
static status_t demangle_source_name
  PARAMS ((demangling_t));
static status_t demangle_number
  PARAMS ((demangling_t, int *, int, int));
static status_t demangle_number_literally
  PARAMS ((demangling_t, dyn_string_t, int, int));
static status_t demangle_identifier
  PARAMS ((demangling_t, int, dyn_string_t));
static status_t demangle_operator_name
  PARAMS ((demangling_t, int, int *, int *));
static status_t demangle_nv_offset
  PARAMS ((demangling_t));
static status_t demangle_v_offset
  PARAMS ((demangling_t));
static status_t demangle_call_offset
  PARAMS ((demangling_t));
static status_t demangle_special_name
  PARAMS ((demangling_t));
static status_t demangle_ctor_dtor_name
  PARAMS ((demangling_t));
static status_t demangle_type_ptr
  PARAMS ((demangling_t, int *, int));
static status_t demangle_type
  PARAMS ((demangling_t));
static status_t demangle_CV_qualifiers
  PARAMS ((demangling_t, dyn_string_t));
static status_t demangle_builtin_type
  PARAMS ((demangling_t));
static status_t demangle_function_type
  PARAMS ((demangling_t, int *));
static status_t demangle_bare_function_type
  PARAMS ((demangling_t, int *));
static status_t demangle_class_enum_type
  PARAMS ((demangling_t, int *));
static status_t demangle_array_type
  PARAMS ((demangling_t, int *));
static status_t demangle_template_param
  PARAMS ((demangling_t));
static status_t demangle_template_args
  PARAMS ((demangling_t));
static status_t demangle_literal
  PARAMS ((demangling_t));
static status_t demangle_template_arg
  PARAMS ((demangling_t));
static status_t demangle_expression
  PARAMS ((demangling_t));
static status_t demangle_scope_expression
  PARAMS ((demangling_t));
static status_t demangle_expr_primary
  PARAMS ((demangling_t));
static status_t demangle_substitution
  PARAMS ((demangling_t, int *));
static status_t demangle_local_name
  PARAMS ((demangling_t));
static status_t demangle_discriminator 
  PARAMS ((demangling_t, int));
static status_t cp_demangle
  PARAMS ((const char *, dyn_string_t, int));
static status_t cp_demangle_type
  PARAMS ((const char*, dyn_string_t));

/* When passed to demangle_bare_function_type, indicates that the
   function's return type is not encoded before its parameter types.  */
#define BFT_NO_RETURN_TYPE    NULL

/* Check that the next character is C.  If so, consume it.  If not,
   return an error.  */

static status_t
demangle_char (dm, c)
     demangling_t dm;
     int c;
{
  static char *error_message = NULL;
d1028 12
a1039 11
  if (peek_char (dm) == c)
    {
      advance_char (dm);
      return STATUS_OK;
    }
  else
    {
      if (error_message == NULL)
	error_message = (char *) strdup ("Expected ?");
      error_message[9] = c;
      return error_message;
d1043 3
a1045 1
/* Demangles and emits a <mangled-name>.  
d1047 3
a1049 5
    <mangled-name>      ::= _Z <encoding>  */

static status_t
demangle_mangled_name (dm)
     demangling_t dm;
d1051 2
a1052 6
  DEMANGLE_TRACE ("mangled-name", dm);
  RETURN_IF_ERROR (demangle_char (dm, '_'));
  RETURN_IF_ERROR (demangle_char (dm, 'Z'));
  RETURN_IF_ERROR (demangle_encoding (dm));
  return STATUS_OK;
}
d1054 2
a1055 1
/* Demangles and emits an <encoding>.  
d1057 3
a1059 3
    <encoding>		::= <function name> <bare-function-type>
			::= <data name>
			::= <special-name>  */
d1061 3
a1063 8
static status_t
demangle_encoding (dm)
     demangling_t dm;
{
  int encode_return_type;
  int start_position;
  template_arg_list_t old_arg_list = current_template_arg_list (dm);
  char peek = peek_char (dm);
d1065 2
a1066 5
  DEMANGLE_TRACE ("encoding", dm);
  
  /* Remember where the name starts.  If it turns out to be a template
     function, we'll have to insert the return type here.  */
  start_position = result_caret_pos (dm);
d1068 2
a1069 6
  if (peek == 'G' || peek == 'T')
    RETURN_IF_ERROR (demangle_special_name (dm));
  else
    {
      /* Now demangle the name.  */
      RETURN_IF_ERROR (demangle_name (dm, &encode_return_type));
d1071 10
a1080 17
      /* If there's anything left, the name was a function name, with
	 maybe its return type, and its parameter types, following.  */
      if (!end_of_name_p (dm) 
	  && peek_char (dm) != 'E')
	{
	  if (encode_return_type)
	    /* Template functions have their return type encoded.  The
	       return type should be inserted at start_position.  */
	    RETURN_IF_ERROR 
	      (demangle_bare_function_type (dm, &start_position));
	  else
	    /* Non-template functions don't have their return type
	       encoded.  */
	    RETURN_IF_ERROR 
	      (demangle_bare_function_type (dm, BFT_NO_RETURN_TYPE)); 
	}
    }
d1082 5
a1086 3
  /* Pop off template argument lists that were built during the
     mangling of this name, to restore the old template context.  */
  pop_to_template_arg_list (dm, old_arg_list);
d1088 5
a1092 2
  return STATUS_OK;
}
d1094 3
a1096 1
/* Demangles and emits a <name>.
d1098 3
a1100 4
    <name>              ::= <unscoped-name>
                        ::= <unscoped-template-name> <template-args>
			::= <nested-name>
                        ::= <local-name>
d1102 21
a1122 2
    <unscoped-name>     ::= <unqualified-name>
			::= St <unqualified-name>   # ::std::
d1124 4
a1127 3
    <unscoped-template-name>    
                        ::= <unscoped-name>
                        ::= <substitution>  */
d1129 7
a1135 8
static status_t
demangle_name (dm, encode_return_type)
     demangling_t dm;
     int *encode_return_type;
{
  int start = substitution_start (dm);
  char peek = peek_char (dm);
  int is_std_substitution = 0;
d1137 4
a1140 5
  /* Generally, the return type is encoded if the function is a
     template-id, and suppressed otherwise.  There are a few cases,
     though, in which the return type is not encoded even for a
     templated function.  In these cases, this flag is set.  */
  int suppress_return_type = 0;
d1142 5
a1146 1
  DEMANGLE_TRACE ("name", dm);
d1148 10
a1157 6
  switch (peek)
    {
    case 'N':
      /* This is a <nested-name>.  */
      RETURN_IF_ERROR (demangle_nested_name (dm, encode_return_type));
      break;
d1159 1
a1159 4
    case 'Z':
      RETURN_IF_ERROR (demangle_local_name (dm));
      *encode_return_type = 0;
      break;
d1161 6
a1166 28
    case 'S':
      /* The `St' substitution allows a name nested in std:: to appear
	 without being enclosed in a nested name.  */
      if (peek_char_next (dm) == 't') 
	{
	  (void) next_char (dm);
	  (void) next_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "std::"));
	  RETURN_IF_ERROR 
	    (demangle_unqualified_name (dm, &suppress_return_type));
	  is_std_substitution = 1;
	}
      else
	RETURN_IF_ERROR (demangle_substitution (dm, encode_return_type));
      /* Check if a template argument list immediately follows.
	 If so, then we just demangled an <unqualified-template-name>.  */
      if (peek_char (dm) == 'I') 
	{
	  /* A template name of the form std::<unqualified-name> is a
             substitution candidate.  */
	  if (is_std_substitution)
	    RETURN_IF_ERROR (substitution_add (dm, start, 0));
	  /* Demangle the <template-args> here.  */
	  RETURN_IF_ERROR (demangle_template_args (dm));
	  *encode_return_type = !suppress_return_type;
	}
      else
	*encode_return_type = 0;
d1168 7
a1174 1
      break;
d1176 1
a1176 3
    default:
      /* This is an <unscoped-name> or <unscoped-template-name>.  */
      RETURN_IF_ERROR (demangle_unqualified_name (dm, &suppress_return_type));
d1178 7
a1184 6
      /* If the <unqualified-name> is followed by template args, this
	 is an <unscoped-template-name>.  */
      if (peek_char (dm) == 'I')
	{
	  /* Add a substitution for the unqualified template name.  */
	  RETURN_IF_ERROR (substitution_add (dm, start, 0));
d1186 8
a1193 5
	  RETURN_IF_ERROR (demangle_template_args (dm));
	  *encode_return_type = !suppress_return_type;
	}
      else
	*encode_return_type = 0;
d1195 8
a1202 1
      break;
d1204 1
d1206 1
a1206 2
  return STATUS_OK;
}
d1208 6
a1213 1
/* Demangles and emits a <nested-name>. 
d1215 2
a1216 1
    <nested-name>     ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E  */
d1218 8
a1225 6
static status_t
demangle_nested_name (dm, encode_return_type)
     demangling_t dm;
     int *encode_return_type;
{
  char peek;
d1227 6
a1232 1
  DEMANGLE_TRACE ("nested-name", dm);
d1234 2
a1235 1
  RETURN_IF_ERROR (demangle_char (dm, 'N'));
d1237 4
a1240 5
  peek = peek_char (dm);
  if (peek == 'r' || peek == 'V' || peek == 'K')
    {
      dyn_string_t cv_qualifiers;
      status_t status;
d1242 52
a1293 56
      /* Snarf up CV qualifiers.  */
      cv_qualifiers = dyn_string_new (24);
      if (cv_qualifiers == NULL)
	return STATUS_ALLOCATION_FAILED;
      demangle_CV_qualifiers (dm, cv_qualifiers);

      /* Emit them, preceded by a space.  */
      status = result_add_char (dm, ' ');
      if (STATUS_NO_ERROR (status)) 
	status = result_add_string (dm, cv_qualifiers);
      /* The CV qualifiers that occur in a <nested-name> will be
	 qualifiers for member functions.  These are placed at the end
	 of the function.  Therefore, shift the caret to the left by
	 the length of the qualifiers, so other text is inserted
	 before them and they stay at the end.  */
      result_shift_caret (dm, -dyn_string_length (cv_qualifiers) - 1);
      /* Clean up.  */
      dyn_string_delete (cv_qualifiers);
      RETURN_IF_ERROR (status);
    }

  RETURN_IF_ERROR (demangle_prefix (dm, encode_return_type));
  /* No need to demangle the final <unqualified-name>; demangle_prefix
     will handle it.  */
  RETURN_IF_ERROR (demangle_char (dm, 'E'));

  return STATUS_OK;
}

/* Demangles and emits a <prefix>.

    <prefix>            ::= <prefix> <unqualified-name>
                        ::= <template-prefix> <template-args>
			::= # empty
			::= <substitution>

    <template-prefix>   ::= <prefix>
                        ::= <substitution>  */

static status_t
demangle_prefix (dm, encode_return_type)
     demangling_t dm;
     int *encode_return_type;
{
  int start = substitution_start (dm);
  int nested = 0;

  /* ENCODE_RETURN_TYPE is updated as we decend the nesting chain.
     After <template-args>, it is set to non-zero; after everything
     else it is set to zero.  */

  /* Generally, the return type is encoded if the function is a
     template-id, and suppressed otherwise.  There are a few cases,
     though, in which the return type is not encoded even for a
     templated function.  In these cases, this flag is set.  */
  int suppress_return_type = 0;
d1295 6
a1300 1
  DEMANGLE_TRACE ("prefix", dm);
d1302 7
a1308 1
  while (1)
d1310 2
a1311 1
      char peek;
d1313 4
a1316 2
      if (end_of_name_p (dm))
	return "Unexpected end of name in <compound-name>.";
d1318 2
a1319 10
      peek = peek_char (dm);
      
      /* We'll initialize suppress_return_type to false, and set it to true
	 if we end up demangling a constructor name.  However, make
	 sure we're not actually about to demangle template arguments
	 -- if so, this is the <template-args> following a
	 <template-prefix>, so we'll want the previous flag value
	 around.  */
      if (peek != 'I')
	suppress_return_type = 0;
d1321 2
a1322 10
      if (IS_DIGIT ((unsigned char) peek)
	  || (peek >= 'a' && peek <= 'z')
	  || peek == 'C' || peek == 'D'
	  || peek == 'S')
	{
	  /* We have another level of scope qualification.  */
	  if (nested)
	    RETURN_IF_ERROR (result_add (dm, NAMESPACE_SEPARATOR));
	  else
	    nested = 1;
d1324 2
a1325 4
	  if (peek == 'S')
	    /* The substitution determines whether this is a
	       template-id.  */
	    RETURN_IF_ERROR (demangle_substitution (dm, encode_return_type));
d1327 3
a1329 6
	    {
	      /* It's just a name.  */
	      RETURN_IF_ERROR 
		(demangle_unqualified_name (dm, &suppress_return_type));
	      *encode_return_type = 0;
	    }
a1330 25
      else if (peek == 'Z')
	RETURN_IF_ERROR (demangle_local_name (dm));
      else if (peek == 'I')
	{
	  RETURN_IF_ERROR (demangle_template_args (dm));

	  /* Now we want to indicate to the caller that we've
	     demangled template arguments, thus the prefix was a
	     <template-prefix>.  That's so that the caller knows to
	     demangle the function's return type, if this turns out to
	     be a function name.  But, if it's a member template
	     constructor or a templated conversion operator, report it
	     as untemplated.  Those never get encoded return types.  */
	  *encode_return_type = !suppress_return_type;
	}
      else if (peek == 'E')
	/* All done.  */
	return STATUS_OK;
      else
	return "Unexpected character in <compound-name>.";

      if (peek != 'S'
	  && peek_char (dm) != 'E')
	/* Add a new substitution for the prefix thus far.  */
	RETURN_IF_ERROR (substitution_add (dm, start, *encode_return_type));
d1334 13
a1346 5
/* Demangles and emits an <unqualified-name>.  If this
   <unqualified-name> is for a special function type that should never
   have its return type encoded (particularly, a constructor or
   conversion operator), *SUPPRESS_RETURN_TYPE is set to 1; otherwise,
   it is set to zero.
d1348 5
a1352 3
    <unqualified-name>  ::= <operator-name>
			::= <special-name>  
			::= <source-name>  */
d1354 18
a1371 6
static status_t
demangle_unqualified_name (dm, suppress_return_type)
     demangling_t dm;
     int *suppress_return_type;
{
  char peek = peek_char (dm);
d1373 5
a1377 1
  DEMANGLE_TRACE ("unqualified-name", dm);
d1379 7
a1385 3
  /* By default, don't force suppression of the return type (though
     non-template functions still don't get a return type encoded).  */ 
  *suppress_return_type = 0;
d1387 18
a1404 5
  if (IS_DIGIT ((unsigned char) peek))
    RETURN_IF_ERROR (demangle_source_name (dm));
  else if (peek >= 'a' && peek <= 'z')
    {
      int num_args;
d1406 4
a1409 3
      /* Conversion operators never have a return type encoded.  */
      if (peek == 'c' && peek_char_next (dm) == 'v')
	*suppress_return_type = 1;
d1411 3
a1413 1
      RETURN_IF_ERROR (demangle_operator_name (dm, 0, &num_args, NULL));
d1415 1
a1415 1
  else if (peek == 'C' || peek == 'D')
d1417 7
a1423 3
      /* Constructors never have a return type encoded.  */
      if (peek == 'C')
	*suppress_return_type = 1;
d1425 3
a1427 1
      RETURN_IF_ERROR (demangle_ctor_dtor_name (dm));
d1430 1
a1430 3
    return "Unexpected character in <unqualified-name>.";

  return STATUS_OK;
d1433 2
a1434 1
/* Demangles and emits <source-name>.  
d1436 1
a1436 1
    <source-name> ::= <length number> <identifier>  */
d1438 1
a1438 5
static status_t
demangle_source_name (dm)
     demangling_t dm;
{
  int length;
d1440 2
a1441 1
  DEMANGLE_TRACE ("source-name", dm);
d1443 2
a1444 4
  /* Decode the length of the identifier.  */
  RETURN_IF_ERROR (demangle_number (dm, &length, 10, 0));
  if (length == 0)
    return "Zero length in <source-name>.";
d1446 7
a1452 4
  /* Now the identifier itself.  It's placed into last_source_name,
     where it can be used to build a constructor or destructor name.  */
  RETURN_IF_ERROR (demangle_identifier (dm, length, 
					dm->last_source_name));
d1454 2
a1455 2
  /* Emit it.  */
  RETURN_IF_ERROR (result_add_string (dm, dm->last_source_name));
d1457 11
a1467 2
  return STATUS_OK;
}
d1469 2
a1470 5
/* Demangles a number, either a <number> or a <positive-number> at the
   current position, consuming all consecutive digit characters.  Sets
   *VALUE to the resulting numberand returns STATUS_OK.  The number is
   interpreted as BASE, which must be either 10 or 36.  If IS_SIGNED
   is non-zero, negative numbers -- prefixed with `n' -- are accepted.
d1472 2
a1473 1
    <number> ::= [n] <positive-number>
d1475 7
a1481 1
    <positive-number> ::= <decimal integer>  */
d1483 3
a1485 6
static status_t
demangle_number (dm, value, base, is_signed)
     demangling_t dm;
     int *value;
     int base;
     int is_signed;
d1487 5
a1491 1
  dyn_string_t number = dyn_string_new (10);
d1493 16
a1508 1
  DEMANGLE_TRACE ("number", dm);
d1510 3
a1512 2
  if (number == NULL)
    return STATUS_ALLOCATION_FAILED;
d1514 16
a1529 3
  demangle_number_literally (dm, number, base, is_signed);
  *value = strtol (dyn_string_buf (number), NULL, base);
  dyn_string_delete (number);
d1531 3
a1533 1
  return STATUS_OK;
d1536 48
a1583 6
/* Demangles a number at the current position.  The digits (and minus
   sign, if present) that make up the number are appended to STR.
   Only base-BASE digits are accepted; BASE must be either 10 or 36.
   If IS_SIGNED, negative numbers -- prefixed with `n' -- are
   accepted.  Does not consume a trailing underscore or other
   terminating character.  */
d1585 3
a1587 6
static status_t
demangle_number_literally (dm, str, base, is_signed)
     demangling_t dm;
     dyn_string_t str;
     int base;
     int is_signed;
d1589 3
a1591 1
  DEMANGLE_TRACE ("number*", dm);
d1593 10
a1602 2
  if (base != 10 && base != 36)
    return STATUS_INTERNAL_ERROR;
d1604 2
a1605 2
  /* An `n' denotes a negative number.  */
  if (is_signed && peek_char (dm) == 'n')
d1607 7
a1613 6
      /* Skip past the n.  */
      advance_char (dm);
      /* The normal way to write a negative number is with a minus
	 sign.  */
      if (!dyn_string_append_char (str, '-'))
	return STATUS_ALLOCATION_FAILED;
d1616 3
a1618 2
  /* Loop until we hit a non-digit.  */
  while (1)
d1620 9
a1628 12
      char peek = peek_char (dm);
      if (IS_DIGIT ((unsigned char) peek)
	  || (base == 36 && peek >= 'A' && peek <= 'Z'))
	{
	  /* Accumulate digits.  */
	  if (!dyn_string_append_char (str, next_char (dm)))
	    return STATUS_ALLOCATION_FAILED;
	}
      else
	/* Not a digit?  All done.  */
	break;
    }
d1630 4
a1633 2
  return STATUS_OK;
}
d1635 3
a1637 2
/* Demangles an identifier at the current position of LENGTH
   characters and places it in IDENTIFIER.  */
d1639 6
a1644 7
static status_t
demangle_identifier (dm, length, identifier)
     demangling_t dm;
     int length;
     dyn_string_t identifier;
{
  DEMANGLE_TRACE ("identifier", dm);
d1646 3
a1648 3
  dyn_string_clear (identifier);
  if (!dyn_string_resize (identifier, length))
    return STATUS_ALLOCATION_FAILED;
d1650 3
a1652 6
  while (length-- > 0)
    {
      int ch;
      if (end_of_name_p (dm))
	return "Unexpected end of name in <identifier>.";
      ch = next_char (dm);
d1654 10
a1663 31
      /* Handle extended Unicode characters.  We encode them as __U{hex}_,
         where {hex} omits leading 0's.  For instance, '$' is encoded as
         "__U24_".  */
      if (ch == '_'
	  && peek_char (dm) == '_'
	  && peek_char_next (dm) == 'U')
	{
	  char buf[10];
	  int pos = 0;
	  advance_char (dm); advance_char (dm); length -= 2;
	  while (length-- > 0)
	    {
	      ch = next_char (dm);
	      if (!isxdigit (ch))
		break;
	      buf[pos++] = ch;
	    }
	  if (ch != '_' || length < 0)
	    return STATUS_ERROR;
	  if (pos == 0)
	    {
	      /* __U_ just means __U.  */
	      if (!dyn_string_append_cstr (identifier, "__U"))
		return STATUS_ALLOCATION_FAILED;
	      continue;
	    }
	  else
	    {
	      buf[pos] = '\0';
	      ch = strtol (buf, 0, 16);
	    }
d1665 1
d1667 5
a1671 3
      if (!dyn_string_append_char (identifier, ch))
	return STATUS_ALLOCATION_FAILED;
    }
d1673 26
a1698 22
  /* GCC encodes anonymous namespaces using a `_GLOBAL_[_.$]N.'
     followed by the source file name and some random characters.
     Unless we're in strict mode, decipher these names appropriately.  */
  if (!flag_strict)
    {
      char *name = dyn_string_buf (identifier);
      int prefix_length = strlen (ANONYMOUS_NAMESPACE_PREFIX);

      /* Compare the first, fixed part.  */
      if (strncmp (name, ANONYMOUS_NAMESPACE_PREFIX, prefix_length) == 0)
        {
	  name += prefix_length;
	  /* The next character might be a period, an underscore, or
	     dollar sign, depending on the target architecture's
	     assembler's capabilities.  After that comes an `N'.  */
	  if ((*name == '.' || *name == '_' || *name == '$')
	      && *(name + 1) == 'N')
	    /* This looks like the anonymous namespace identifier.
	       Replace it with something comprehensible.  */
	    dyn_string_copy_cstr (identifier, "(anonymous namespace)");
	}
    }
d1700 4
a1703 2
  return STATUS_OK;
}
d1705 4
a1708 76
/* Demangles and emits an <operator-name>.  If SHORT_NAME is non-zero,
   the short form is emitted; otherwise the full source form
   (`operator +' etc.) is emitted.  *NUM_ARGS is set to the number of
   operands that the operator takes.  If TYPE_ARG is non-NULL,
   *TYPE_ARG is set to 1 if the first argument is a type and 0
   otherwise.

    <operator-name>
                  ::= nw        # new           
                  ::= na        # new[]
                  ::= dl        # delete        
                  ::= da        # delete[]      
		  ::= ps        # + (unary)
                  ::= ng        # - (unary)     
                  ::= ad        # & (unary)     
                  ::= de        # * (unary)     
                  ::= co        # ~             
                  ::= pl        # +             
                  ::= mi        # -             
                  ::= ml        # *             
                  ::= dv        # /             
                  ::= rm        # %             
                  ::= an        # &             
                  ::= or        # |             
                  ::= eo        # ^             
                  ::= aS        # =             
                  ::= pL        # +=            
                  ::= mI        # -=            
                  ::= mL        # *=            
                  ::= dV        # /=            
                  ::= rM        # %=            
                  ::= aN        # &=            
                  ::= oR        # |=            
                  ::= eO        # ^=            
                  ::= ls        # <<            
                  ::= rs        # >>            
                  ::= lS        # <<=           
                  ::= rS        # >>=           
                  ::= eq        # ==            
                  ::= ne        # !=            
                  ::= lt        # <             
                  ::= gt        # >             
                  ::= le        # <=            
                  ::= ge        # >=            
                  ::= nt        # !             
                  ::= aa        # &&            
                  ::= oo        # ||            
                  ::= pp        # ++            
                  ::= mm        # --            
                  ::= cm        # ,             
                  ::= pm        # ->*           
                  ::= pt        # ->            
                  ::= cl        # ()            
                  ::= ix        # []            
                  ::= qu        # ?
		  ::= st        # sizeof (a type)
                  ::= sz        # sizeof (an expression)
                  ::= cv <type> # cast        
		  ::= v [0-9] <source-name>  # vendor extended operator  */

static status_t
demangle_operator_name (dm, short_name, num_args, type_arg)
     demangling_t dm;
     int short_name;
     int *num_args;
     int *type_arg;
{
  struct operator_code
  {
    /* The mangled code for this operator.  */
    const char *const code;
    /* The source name of this operator.  */
    const char *const name;
    /* The number of arguments this operator takes.  */
    const int num_args;
  };
d1710 4
a1713 94
  static const struct operator_code operators[] = 
  {
    { "aN", "&="       , 2 },
    { "aS", "="        , 2 },
    { "aa", "&&"       , 2 },
    { "ad", "&"        , 1 },
    { "an", "&"        , 2 },
    { "cl", "()"       , 0 },
    { "cm", ","        , 2 },
    { "co", "~"        , 1 },
    { "dV", "/="       , 2 },
    { "da", " delete[]", 1 },
    { "de", "*"        , 1 },
    { "dl", " delete"  , 1 },
    { "dv", "/"        , 2 },
    { "eO", "^="       , 2 },
    { "eo", "^"        , 2 },
    { "eq", "=="       , 2 },
    { "ge", ">="       , 2 },
    { "gt", ">"        , 2 },
    { "ix", "[]"       , 2 },
    { "lS", "<<="      , 2 },
    { "le", "<="       , 2 },
    { "ls", "<<"       , 2 },
    { "lt", "<"        , 2 },
    { "mI", "-="       , 2 },
    { "mL", "*="       , 2 },
    { "mi", "-"        , 2 },
    { "ml", "*"        , 2 },
    { "mm", "--"       , 1 },
    { "na", " new[]"   , 1 },
    { "ne", "!="       , 2 },
    { "ng", "-"        , 1 },
    { "nt", "!"        , 1 },
    { "nw", " new"     , 1 },
    { "oR", "|="       , 2 },
    { "oo", "||"       , 2 },
    { "or", "|"        , 2 },
    { "pL", "+="       , 2 },
    { "pl", "+"        , 2 },
    { "pm", "->*"      , 2 },
    { "pp", "++"       , 1 },
    { "ps", "+"        , 1 },
    { "pt", "->"       , 2 },
    { "qu", "?"        , 3 },
    { "rM", "%="       , 2 },
    { "rS", ">>="      , 2 },
    { "rm", "%"        , 2 },
    { "rs", ">>"       , 2 },
    { "sz", "sizeof"  , 1 }
  };

  const int num_operators = 
    sizeof (operators) / sizeof (struct operator_code);

  int c0 = next_char (dm);
  int c1 = next_char (dm);
  const struct operator_code* p1 = operators;
  const struct operator_code* p2 = operators + num_operators;

  DEMANGLE_TRACE ("operator-name", dm);

  /* Assume the first argument is not a type.  */
  if (type_arg)
    *type_arg = 0;

  /* Is this a vendor-extended operator?  */
  if (c0 == 'v' && IS_DIGIT (c1))
    {
      RETURN_IF_ERROR (result_add (dm, "operator "));
      RETURN_IF_ERROR (demangle_source_name (dm));
      *num_args = 0;
      return STATUS_OK;
    }

  /* Is this a conversion operator?  */
  if (c0 == 'c' && c1 == 'v')
    {
      RETURN_IF_ERROR (result_add (dm, "operator "));
      /* Demangle the converted-to type.  */
      RETURN_IF_ERROR (demangle_type (dm));
      *num_args = 0;
      return STATUS_OK;
    }

  /* Is it the sizeof variant that takes a type?  */
  if (c0 == 's' && c1 == 't')
    {
      RETURN_IF_ERROR (result_add (dm, " sizeof"));
      *num_args = 1;
      if (type_arg)
	*type_arg = 1;
      return STATUS_OK;
    }
d1715 4
a1718 6
  /* Perform a binary search for the operator code.  */
  while (1)
    {
      const struct operator_code* p = p1 + (p2 - p1) / 2;
      char match0 = p->code[0];
      char match1 = p->code[1];
d1720 5
a1724 7
      if (c0 == match0 && c1 == match1)
	/* Found it.  */
	{
	  if (!short_name)
	    RETURN_IF_ERROR (result_add (dm, "operator"));
	  RETURN_IF_ERROR (result_add (dm, p->name));
	  *num_args = p->num_args;
d1726 3
a1728 2
	  return STATUS_OK;
	}
d1730 4
a1733 9
      if (p == p1)
	/* Couldn't find it.  */
	return "Unknown code in <operator-name>.";

      /* Try again.  */
      if (c0 < match0 || (c0 == match0 && c1 < match1))
	p2 = p;
      else
	p1 = p;
d1735 2
d1739 1
a1739 1
/* Demangles and omits an <nv-offset>.
d1741 6
a1746 1
    <nv-offset> ::= <offset number>   # non-virtual base override  */
d1748 4
a1751 6
static status_t
demangle_nv_offset (dm)
     demangling_t dm;
{
  dyn_string_t number;
  status_t status = STATUS_OK;
d1753 7
a1759 1
  DEMANGLE_TRACE ("h-offset", dm);
d1761 4
a1764 5
  /* Demangle the offset.  */
  number = dyn_string_new (4);
  if (number == NULL)
    return STATUS_ALLOCATION_FAILED;
  demangle_number_literally (dm, number, 10, 1);
d1766 1
a1766 8
  /* Don't display the offset unless in verbose mode.  */
  if (flag_verbose)
    {
      status = result_add (dm, " [nv:");
      if (STATUS_NO_ERROR (status))
	status = result_add_string (dm, number);
      if (STATUS_NO_ERROR (status))
	status = result_add_char (dm, ']');
d1769 1
a1769 4
  /* Clean up.  */
  dyn_string_delete (number);
  RETURN_IF_ERROR (status);
  return STATUS_OK;
d1772 1
a1772 4
/* Demangles and emits a <v-offset>. 

    <v-offset>  ::= <offset number> _ <virtual offset number>
			# virtual base override, with vcall offset  */
d1774 3
a1776 3
static status_t
demangle_v_offset (dm)
     demangling_t dm;
d1778 1
a1778 2
  dyn_string_t number;
  status_t status = STATUS_OK;
d1780 3
a1782 10
  DEMANGLE_TRACE ("v-offset", dm);

  /* Demangle the offset.  */
  number = dyn_string_new (4);
  if (number == NULL)
    return STATUS_ALLOCATION_FAILED;
  demangle_number_literally (dm, number, 10, 1);

  /* Don't display the offset unless in verbose mode.  */
  if (flag_verbose)
d1784 3
a1786 5
      status = result_add (dm, " [v:");
      if (STATUS_NO_ERROR (status))
	status = result_add_string (dm, number);
      if (STATUS_NO_ERROR (status))
	result_add_char (dm, ',');
d1788 5
a1792 2
  dyn_string_delete (number);
  RETURN_IF_ERROR (status);
d1794 1
a1794 2
  /* Demangle the separator.  */
  RETURN_IF_ERROR (demangle_char (dm, '_'));
d1796 8
a1803 5
  /* Demangle the vcall offset.  */
  number = dyn_string_new (4);
  if (number == NULL)
    return STATUS_ALLOCATION_FAILED;
  demangle_number_literally (dm, number, 10, 1);
d1805 4
a1808 2
  /* Don't display the vcall offset unless in verbose mode.  */
  if (flag_verbose)
d1810 19
a1828 3
      status = result_add_string (dm, number);
      if (STATUS_NO_ERROR (status))
	status = result_add_char (dm, ']');
a1829 2
  dyn_string_delete (number);
  RETURN_IF_ERROR (status);
d1831 13
a1843 1
  return STATUS_OK;
d1846 1
a1846 1
/* Demangles and emits a <call-offset>.
d1848 6
a1853 2
    <call-offset> ::= h <nv-offset> _
		  ::= v <v-offset> _  */
d1855 7
a1861 3
static status_t
demangle_call_offset (dm)
     demangling_t dm;
d1863 5
a1867 1
  DEMANGLE_TRACE ("call-offset", dm);
d1869 4
a1872 1
  switch (peek_char (dm))
d1874 1
a1874 7
    case 'h':
      advance_char (dm);
      /* Demangle the offset.  */
      RETURN_IF_ERROR (demangle_nv_offset (dm));
      /* Demangle the separator.  */
      RETURN_IF_ERROR (demangle_char (dm, '_'));
      break;
d1876 15
a1890 7
    case 'v':
      advance_char (dm);
      /* Demangle the offset.  */
      RETURN_IF_ERROR (demangle_v_offset (dm));
      /* Demangle the separator.  */
      RETURN_IF_ERROR (demangle_char (dm, '_'));
      break;
d1892 2
a1893 3
    default:
      return "Unrecognized <call-offset>.";
    }
d1895 1
a1895 1
  return STATUS_OK;
d1898 1
a1898 1
/* Demangles and emits a <special-name>.  
d1900 7
a1906 5
    <special-name> ::= GV <object name>   # Guard variable
                   ::= TV <type>          # virtual table
                   ::= TT <type>          # VTT
                   ::= TI <type>          # typeinfo structure
		   ::= TS <type>          # typeinfo name  
d1908 2
a1909 1
   Other relevant productions include thunks:
d1911 1
a1911 2
    <special-name> ::= T <call-offset> <base encoding>
 			 # base is the nominal target function of thunk
d1913 12
a1924 4
    <special-name> ::= Tc <call-offset> <call-offset> <base encoding>
			 # base is the nominal target function of thunk
			 # first call-offset is 'this' adjustment
			 # second call-offset is result adjustment
d1926 2
a1927 1
   where
d1929 2
a1930 2
    <call-offset>  ::= h <nv-offset> _
		   ::= v <v-offset> _
d1932 3
a1934 1
   Also demangles the special g++ manglings,
d1936 3
a1938 8
    <special-name> ::= TC <type> <offset number> _ <base type>
                                          # construction vtable
		   ::= TF <type>	  # typeinfo function (old ABI only)
		   ::= TJ <type>	  # java Class structure  */

static status_t
demangle_special_name (dm)
     demangling_t dm;
d1940 1
a1940 3
  dyn_string_t number;
  int unused;
  char peek = peek_char (dm);
d1942 2
a1943 1
  DEMANGLE_TRACE ("special-name", dm);
d1945 3
a1947 1
  if (peek == 'G')
d1949 8
a1956 10
      /* Consume the G.  */
      advance_char (dm);
      switch (peek_char (dm))
	{
	case 'V':
	  /* A guard variable name.  */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "guard variable for "));
	  RETURN_IF_ERROR (demangle_name (dm, &unused));
	  break;
d1958 2
a1959 14
	case 'R':
	  /* A reference temporary.  */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "reference temporary for "));
	  RETURN_IF_ERROR (demangle_name (dm, &unused));
	  break;
	  
	default:
	  return "Unrecognized <special-name>.";
	}
    }
  else if (peek == 'T')
    {
      status_t status = STATUS_OK;
d1961 1
a1961 2
      /* Other C++ implementation miscellania.  Consume the T.  */
      advance_char (dm);
d1963 7
a1969 8
      switch (peek_char (dm))
	{
	case 'V':
	  /* Virtual table.  */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "vtable for "));
	  RETURN_IF_ERROR (demangle_type (dm));
	  break;
d1971 4
a1974 6
	case 'T':
	  /* VTT structure.  */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "VTT for "));
	  RETURN_IF_ERROR (demangle_type (dm));
	  break;
d1976 2
a1977 6
	case 'I':
	  /* Typeinfo structure.  */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "typeinfo for "));
	  RETURN_IF_ERROR (demangle_type (dm));
	  break;
d1979 5
a1983 6
	case 'F':
	  /* Typeinfo function.  Used only in old ABI with new mangling.  */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "typeinfo fn for "));
	  RETURN_IF_ERROR (demangle_type (dm));
	  break;
d1985 3
a1987 6
	case 'S':
	  /* Character string containing type name, used in typeinfo. */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "typeinfo name for "));
	  RETURN_IF_ERROR (demangle_type (dm));
	  break;
d1989 2
a1990 6
	case 'J':
	  /* The java Class variable corresponding to a C++ class.  */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "java Class for "));
	  RETURN_IF_ERROR (demangle_type (dm));
	  break;
d1992 3
a1994 10
	case 'h':
	  /* Non-virtual thunk.  */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "non-virtual thunk"));
	  RETURN_IF_ERROR (demangle_nv_offset (dm));
	  /* Demangle the separator.  */
	  RETURN_IF_ERROR (demangle_char (dm, '_'));
	  /* Demangle and emit the target name and function type.  */
	  RETURN_IF_ERROR (result_add (dm, " to "));
	  RETURN_IF_ERROR (demangle_encoding (dm));
d1996 2
d1999 1
a1999 11
	case 'v':
	  /* Virtual thunk.  */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "virtual thunk"));
	  RETURN_IF_ERROR (demangle_v_offset (dm));
	  /* Demangle the separator.  */
	  RETURN_IF_ERROR (demangle_char (dm, '_'));
	  /* Demangle and emit the target function.  */
	  RETURN_IF_ERROR (result_add (dm, " to "));
	  RETURN_IF_ERROR (demangle_encoding (dm));
	  break;
d2001 2
a2002 10
	case 'c':
	  /* Covariant return thunk.  */
	  advance_char (dm);
	  RETURN_IF_ERROR (result_add (dm, "covariant return thunk"));
	  RETURN_IF_ERROR (demangle_call_offset (dm));
	  RETURN_IF_ERROR (demangle_call_offset (dm));
	  /* Demangle and emit the target function.  */
	  RETURN_IF_ERROR (result_add (dm, " to "));
	  RETURN_IF_ERROR (demangle_encoding (dm));
	  break;
d2004 4
a2007 5
	case 'C':
	  /* TC is a special g++ mangling for a construction vtable. */
	  if (!flag_strict)
	    {
	      dyn_string_t derived_type;
d2009 5
a2013 2
	      advance_char (dm);
	      RETURN_IF_ERROR (result_add (dm, "construction vtable for "));
d2015 8
a2022 26
	      /* Demangle the derived type off to the side.  */
	      RETURN_IF_ERROR (result_push (dm));
	      RETURN_IF_ERROR (demangle_type (dm));
	      derived_type = (dyn_string_t) result_pop (dm);

	      /* Demangle the offset.  */
	      number = dyn_string_new (4);
	      if (number == NULL)
		{
		  dyn_string_delete (derived_type);
		  return STATUS_ALLOCATION_FAILED;
		}
	      demangle_number_literally (dm, number, 10, 1);
	      /* Demangle the underscore separator.  */
	      status = demangle_char (dm, '_');

	      /* Demangle the base type.  */
	      if (STATUS_NO_ERROR (status))
		status = demangle_type (dm);

	      /* Emit the derived type.  */
	      if (STATUS_NO_ERROR (status))
		status = result_add (dm, "-in-");
	      if (STATUS_NO_ERROR (status))
		status = result_add_string (dm, derived_type);
	      dyn_string_delete (derived_type);
d2024 2
a2025 12
	      /* Don't display the offset unless in verbose mode.  */
	      if (flag_verbose)
		{
		  status = result_add_char (dm, ' ');
		  if (STATUS_NO_ERROR (status))
		    result_add_string (dm, number);
		}
	      dyn_string_delete (number);
	      RETURN_IF_ERROR (status);
	      break;
	    }
	  /* If flag_strict, fall through.  */
d2027 2
a2028 3
	default:
	  return "Unrecognized <special-name>.";
	}
d2030 1
a2030 2
  else
    return STATUS_ERROR;
d2032 9
a2040 2
  return STATUS_OK;
}
d2042 3
a2044 13
/* Demangles and emits a <ctor-dtor-name>.  
   
    <ctor-dtor-name>
                   ::= C1  # complete object (in-charge) ctor
                   ::= C2  # base object (not-in-charge) ctor
                   ::= C3  # complete object (in-charge) allocating ctor
                   ::= D0  # deleting (in-charge) dtor
                   ::= D1  # complete object (in-charge) dtor
                   ::= D2  # base object (not-in-charge) dtor  */

static status_t
demangle_ctor_dtor_name (dm)
     demangling_t dm;
d2046 21
a2066 42
  static const char *const ctor_flavors[] = 
  {
    "in-charge",
    "not-in-charge",
    "allocating"
  };
  static const char *const dtor_flavors[] = 
  {
    "in-charge deleting",
    "in-charge",
    "not-in-charge"
  };

  int flavor;
  char peek = peek_char (dm);

  DEMANGLE_TRACE ("ctor-dtor-name", dm);
  
  if (peek == 'C')
    {
      /* A constructor name.  Consume the C.  */
      advance_char (dm);
      flavor = next_char (dm);
      if (flavor < '1' || flavor > '3')
	return "Unrecognized constructor.";
      RETURN_IF_ERROR (result_add_string (dm, dm->last_source_name));
      switch (flavor)
	{
	case '1': dm->is_constructor = gnu_v3_complete_object_ctor;
	  break;
	case '2': dm->is_constructor = gnu_v3_base_object_ctor;
	  break;
	case '3': dm->is_constructor = gnu_v3_complete_object_allocating_ctor;
	  break;
	}
      /* Print the flavor of the constructor if in verbose mode.  */
      if (flag_verbose)
	{
	  RETURN_IF_ERROR (result_add (dm, "["));
	  RETURN_IF_ERROR (result_add (dm, ctor_flavors[flavor - '1']));
	  RETURN_IF_ERROR (result_add_char (dm, ']'));
	}
d2068 1
a2068 1
  else if (peek == 'D')
d2070 12
a2081 8
      /* A destructor name.  Consume the D.  */
      advance_char (dm);
      flavor = next_char (dm);
      if (flavor < '0' || flavor > '2')
	return "Unrecognized destructor.";
      RETURN_IF_ERROR (result_add_char (dm, '~'));
      RETURN_IF_ERROR (result_add_string (dm, dm->last_source_name));
      switch (flavor)
d2083 4
a2086 1
	case '0': dm->is_destructor = gnu_v3_deleting_dtor;
d2088 2
a2089 1
	case '1': dm->is_destructor = gnu_v3_complete_object_dtor;
d2091 2
a2092 1
	case '2': dm->is_destructor = gnu_v3_base_object_dtor;
d2095 2
a2096 2
      /* Print the flavor of the destructor if in verbose mode.  */
      if (flag_verbose)
d2098 27
a2124 3
	  RETURN_IF_ERROR (result_add (dm, " ["));
	  RETURN_IF_ERROR (result_add (dm, dtor_flavors[flavor - '0']));
	  RETURN_IF_ERROR (result_add_char (dm, ']'));
a2126 4
  else
    return STATUS_ERROR;

  return STATUS_OK;
d2129 4
a2132 56
/* Handle pointer, reference, and pointer-to-member cases for
   demangle_type.  All consecutive `P's, `R's, and 'M's are joined to
   build a pointer/reference type.  We snarf all these, plus the
   following <type>, all at once since we need to know whether we have
   a pointer to data or pointer to function to construct the right
   output syntax.  C++'s pointer syntax is hairy.  

   This function adds substitution candidates for every nested
   pointer/reference type it processes, including the outermost, final
   type, assuming the substitution starts at SUBSTITUTION_START in the
   demangling result.  For example, if this function demangles
   `PP3Foo', it will add a substitution for `Foo', `Foo*', and
   `Foo**', in that order.

   *INSERT_POS is a quantity used internally, when this function calls
   itself recursively, to figure out where to insert pointer
   punctuation on the way up.  On entry to this function, INSERT_POS
   should point to a temporary value, but that value need not be
   initialized.

     <type> ::= P <type>
            ::= R <type>
            ::= <pointer-to-member-type>

     <pointer-to-member-type> ::= M </class/ type> </member/ type>  */

static status_t
demangle_type_ptr (dm, insert_pos, substitution_start)
     demangling_t dm;
     int *insert_pos;
     int substitution_start;
{
  status_t status;
  int is_substitution_candidate = 1;

  DEMANGLE_TRACE ("type*", dm);

  /* Scan forward, collecting pointers and references into symbols,
     until we hit something else.  Then emit the type.  */
  switch (peek_char (dm))
    {
    case 'P':
      /* A pointer.  Snarf the `P'.  */
      advance_char (dm);
      /* Demangle the underlying type.  */
      RETURN_IF_ERROR (demangle_type_ptr (dm, insert_pos, 
					  substitution_start));
      /* Insert an asterisk where we're told to; it doesn't
	 necessarily go at the end.  If we're doing Java style output, 
	 there is no pointer symbol.  */
      if (dm->style != DMGL_JAVA)
	RETURN_IF_ERROR (result_insert_char (dm, *insert_pos, '*'));
      /* The next (outermost) pointer or reference character should go
	 after this one.  */
      ++(*insert_pos);
      break;
d2134 5
a2138 13
    case 'R':
      /* A reference.  Snarf the `R'.  */
      advance_char (dm);
      /* Demangle the underlying type.  */
      RETURN_IF_ERROR (demangle_type_ptr (dm, insert_pos, 
					  substitution_start));
      /* Insert an ampersand where we're told to; it doesn't
	 necessarily go at the end.  */
      RETURN_IF_ERROR (result_insert_char (dm, *insert_pos, '&'));
      /* The next (outermost) pointer or reference character should go
	 after this one.  */
      ++(*insert_pos);
      break;
d2140 5
a2144 1
    case 'M':
d2146 4
a2149 20
      /* A pointer-to-member.  */
      dyn_string_t class_type;
      char peek;
      int reset_caret = 0;
      int old_caret_position;
      
      /* Eat the 'M'.  */
      advance_char (dm);
      
      /* Capture the type of which this is a pointer-to-member.  */
      RETURN_IF_ERROR (result_push (dm));
      RETURN_IF_ERROR (demangle_type (dm));
      class_type = (dyn_string_t) result_pop (dm);
      
      peek = peek_char (dm);
      old_caret_position = result_get_caret (dm);
      if (peek == 'r' || peek == 'V' || peek == 'K')
	{
	  dyn_string_t cv_qualifiers = dyn_string_new (24);
	  status_t status;
d2151 21
a2171 2
	  if (cv_qualifiers == NULL)
	    return STATUS_ALLOCATION_FAILED;
d2173 3
a2175 2
	  /* Decode all adjacent CV qualifiers.  */
	  demangle_CV_qualifiers (dm, cv_qualifiers);
d2177 5
a2181 11
	  /* Emit them, and shift the caret left so that the
	     underlying type will be emitted before the
	     qualifiers.  */
	  status = result_add_string (dm, cv_qualifiers);
	  result_shift_caret (dm, -dyn_string_length (cv_qualifiers));

	  dyn_string_delete (cv_qualifiers);
	  RETURN_IF_ERROR (status);
	  /* Prepend a blank.  */
	  RETURN_IF_ERROR (result_add_char (dm, ' '));
	  result_shift_caret (dm, -1);
d2183 2
a2184 3
	  peek = peek_char (dm);
	  reset_caret = 1;
	}
d2186 1
a2186 26
      if (peek == 'F')
	/* A pointer-to-member function.  We want output along the
	   lines of `void (C::*) (int, int)'.  Demangle the function
	   type, which would in this case give `void () (int, int)'
	   and set *insert_pos to the spot between the first
	   parentheses.  */
	status = demangle_type_ptr (dm, insert_pos, substitution_start);
      else if (peek == 'A')
	/* A pointer-to-member array variable.  We want output that
	   looks like `int (Klass::*) [10]'.  Demangle the array type
	   as `int () [10]', and set *insert_pos to the spot between
	   the parentheses.  */
	status = demangle_array_type (dm, insert_pos);
      else
        {
	  /* A pointer-to-member variable.  Demangle the type of the
             pointed-to member.  */
	  status = demangle_type (dm);
	  /* Make it pretty.  */
	  if (STATUS_NO_ERROR (status)
	      && !result_previous_char_is_space (dm))
	    status = result_add_char (dm, ' ');
	  /* The pointer-to-member notation (e.g. `C::*') follows the
             member's type.  */
	  *insert_pos = result_caret_pos (dm);
	}
d2188 2
a2189 13
      /* Build the pointer-to-member notation.  */
      if (STATUS_NO_ERROR (status))
	status = result_insert (dm, *insert_pos, "::*");
      if (STATUS_NO_ERROR (status))
	status = result_insert_string (dm, *insert_pos, class_type);
      /* There may be additional levels of (pointer or reference)
	 indirection in this type.  If so, the `*' and `&' should be
	 added after the pointer-to-member notation (e.g. `C::*&' for
	 a reference to a pointer-to-member of class C).  */
      *insert_pos += dyn_string_length (class_type) + 3;

      /* Clean up. */
      dyn_string_delete (class_type);
d2191 12
a2202 2
      if (reset_caret)
	result_set_caret (dm, old_caret_position);
d2204 4
a2207 1
      RETURN_IF_ERROR (status);
d2209 1
a2209 1
    break;
d2211 4
a2214 20
    case 'F':
      /* Ooh, tricky, a pointer-to-function.  When we demangle the
	 function type, the return type should go at the very
	 beginning.  */
      *insert_pos = result_caret_pos (dm);
      /* The parentheses indicate this is a function pointer or
	 reference type.  */
      RETURN_IF_ERROR (result_add (dm, "()"));
      /* Now demangle the function type.  The return type will be
	 inserted before the `()', and the argument list will go after
	 it.  */
      RETURN_IF_ERROR (demangle_function_type (dm, insert_pos));
      /* We should now have something along the lines of 
	 `void () (int, int)'.  The pointer or reference characters
	 have to inside the first set of parentheses.  *insert_pos has
	 already been updated to point past the end of the return
	 type.  Move it one character over so it points inside the
	 `()'.  */
      ++(*insert_pos);
      break;
d2216 5
a2220 5
    case 'A':
      /* An array pointer or reference.  demangle_array_type will figure
	 out where the asterisks and ampersands go.  */
      RETURN_IF_ERROR (demangle_array_type (dm, insert_pos));
      break;
d2222 8
a2229 6
    case 'r':
    case 'V':
    case 'K':
      /* Qualified base type.  Pick up the qualifiers.  */
      {
	dyn_string_t cv_qualifiers = dyn_string_new (24);
d2231 1
a2231 2
	if (cv_qualifiers == NULL)
	  return STATUS_ALLOCATION_FAILED;
d2233 11
a2243 2
	/* Pick up all adjacent CV qualifiers.  */
	demangle_CV_qualifiers (dm, cv_qualifiers);
d2245 10
a2254 2
	/* Demangle the underlying type.  */
	status = demangle_type_ptr (dm, insert_pos, substitution_start);
d2256 5
a2260 8
	/* Insert the qualifiers where we're told to.  */
	if (STATUS_NO_ERROR (status))
	  {
	    status = result_insert_char (dm, *insert_pos, ' ');
	    ++(*insert_pos);
	    if (STATUS_NO_ERROR (status))
	      status = result_insert_string (dm, *insert_pos, cv_qualifiers);
	  }
d2262 2
a2263 2
	/* The next character should go after the qualifiers.  */
	*insert_pos += dyn_string_length (cv_qualifiers);
d2265 4
a2268 4
	dyn_string_delete (cv_qualifiers);
	RETURN_IF_ERROR (status);
      }
      break;
d2270 2
a2271 77
    default:
      /* No more pointer or reference tokens; this is therefore a
	 pointer to data.  Finish up by demangling the underlying
	 type.  */
      RETURN_IF_ERROR (demangle_type (dm));
      /* The pointer or reference characters follow the underlying
	 type, as in `int*&'.  */
      *insert_pos = result_caret_pos (dm);
      /* Because of the production <type> ::= <substitution>,
	 demangle_type will already have added the underlying type as
	 a substitution candidate.  Don't do it again.  */
      is_substitution_candidate = 0;
      break;
    }
  
  if (is_substitution_candidate)
    RETURN_IF_ERROR (substitution_add (dm, substitution_start, 0));
  
  return STATUS_OK;
}

/* Demangles and emits a <type>.  

    <type> ::= <builtin-type>
	   ::= <function-type>
	   ::= <class-enum-type>
	   ::= <array-type>
	   ::= <pointer-to-member-type>
	   ::= <template-param>
	   ::= <template-template-param> <template-args>
           ::= <CV-qualifiers> <type>
	   ::= P <type>   # pointer-to
	   ::= R <type>   # reference-to
	   ::= C <type>   # complex pair (C 2000)
	   ::= G <type>   # imaginary (C 2000)
	   ::= U <source-name> <type>     # vendor extended type qualifier
	   ::= <substitution>  */

static status_t
demangle_type (dm)
     demangling_t dm;
{
  int start = substitution_start (dm);
  char peek = peek_char (dm);
  char peek_next;
  int encode_return_type = 0;
  template_arg_list_t old_arg_list = current_template_arg_list (dm);
  int insert_pos;

  /* A <type> can be a <substitution>; therefore, this <type> is a
     substitution candidate unless a special condition holds (see
     below).  */
  int is_substitution_candidate = 1;

  DEMANGLE_TRACE ("type", dm);

  /* A <class-enum-type> can start with a digit (a <source-name>), an
     N (a <nested-name>), or a Z (a <local-name>).  */
  if (IS_DIGIT ((unsigned char) peek) || peek == 'N' || peek == 'Z')
    RETURN_IF_ERROR (demangle_class_enum_type (dm, &encode_return_type));
  /* Lower-case letters begin <builtin-type>s, except for `r', which
     denotes restrict.  */
  else if (peek >= 'a' && peek <= 'z' && peek != 'r')
    {
      RETURN_IF_ERROR (demangle_builtin_type (dm));
      /* Built-in types are not substitution candidates.  */
      is_substitution_candidate = 0;
    }
  else
    switch (peek)
      {
      case 'r':
      case 'V':
      case 'K':
	/* CV-qualifiers (including restrict).  We have to demangle
	   them off to the side, since C++ syntax puts them in a funny
	   place for qualified pointer and reference types.  */
d2273 1
a2273 15
	  status_t status;
	  dyn_string_t cv_qualifiers = dyn_string_new (24);
	  int old_caret_position = result_get_caret (dm);

	  if (cv_qualifiers == NULL)
	    return STATUS_ALLOCATION_FAILED;

	  /* Decode all adjacent CV qualifiers.  */
	  demangle_CV_qualifiers (dm, cv_qualifiers);

	  /* If the underlying type is a pointer or reference type, we
	     need to call demangle_type_ptr to find out where to put
	     the qualifiers.  */
	  peek = peek_char (dm);
	  if (peek == 'P' || peek == 'R' || peek == 'M')
d2275 7
a2281 11
	      status = demangle_type_ptr (dm, &insert_pos,
					  substitution_start (dm));
	      if (STATUS_NO_ERROR (status))
		{
		  status = result_insert_char (dm, insert_pos, ' ');
		  if (STATUS_NO_ERROR (status))
		    status = result_insert_string (dm, insert_pos + 1,
						   cv_qualifiers);
		}
	      dyn_string_delete (cv_qualifiers);
	      RETURN_IF_ERROR (status);
d2283 1
a2283 16
	  else
	    {
	      /* Emit the qualifiers, and shift the caret left so that
		 the underlying type will be emitted first.  */
	      status = result_add_string (dm, cv_qualifiers);
	      result_shift_caret (dm, -dyn_string_length (cv_qualifiers));
	      /* Clean up.  */
	      dyn_string_delete (cv_qualifiers);
	      RETURN_IF_ERROR (status);
	      /* Also prepend a blank, if needed.  */
	      RETURN_IF_ERROR (result_add_char (dm, ' '));
	      result_shift_caret (dm, -1);

	      /* Demangle the underlying type.  It will be emitted before
		 the CV qualifiers, since we moved the caret.  */
	      RETURN_IF_ERROR (demangle_type (dm));
d2285 1
a2285 3
	      /* Put the caret back where it was previously.  */
	      result_set_caret (dm, old_caret_position);
	    }
a2286 1
	break;
d2288 2
a2289 10
      case 'F':
	/* The return type should go at the current position.  */
	insert_pos = result_caret_pos (dm);
	/* Put in parentheses to indicate that this is a function.  */
	RETURN_IF_ERROR (result_add (dm, "()"));
	/* Demangle the function type.  The return type will be
	   inserted before the '()', and the argument list will go
	   after it.  */
	RETURN_IF_ERROR (demangle_function_type (dm, &insert_pos));
	break;
d2291 31
a2321 3
      case 'A':
	RETURN_IF_ERROR (demangle_array_type (dm, NULL));
	break;
d2323 1
a2323 22
      case 'T':
	/* It's either a <template-param> or a
	   <template-template-param>.  In either case, demangle the
	   `T' token first.  */
	RETURN_IF_ERROR (demangle_template_param (dm));

	/* Check for a template argument list; if one is found, it's a
	     <template-template-param> ::= <template-param>
                                       ::= <substitution>  */
	if (peek_char (dm) == 'I')
	  {
	    /* Add a substitution candidate.  The template parameter
	       `T' token is a substitution candidate by itself,
	       without the template argument list.  */
	    RETURN_IF_ERROR (substitution_add (dm, start, encode_return_type));

	    /* Now demangle the template argument list.  */
	    RETURN_IF_ERROR (demangle_template_args (dm));
	    /* The entire type, including the template template
	       parameter and its argument list, will be added as a
	       substitution candidate below.  */
	  }
d2325 6
a2330 1
	break;
d2332 5
a2336 49
      case 'S':
	/* First check if this is a special substitution.  If it is,
	   this is a <class-enum-type>.  Special substitutions have a
	   lower-case letter following the `S'; other substitutions
	   have a digit, upper-case letter, or underscore.  */
	peek_next = peek_char_next (dm);
	if (IS_DIGIT (peek_next) 
	    || (peek_next >= 'A' && peek_next <= 'Z')
	    || peek_next == '_')
	  {
	    RETURN_IF_ERROR (demangle_substitution (dm, &encode_return_type));
	    
	    /* The substituted name may have been a template name.
	       Check if template arguments follow, and if so, demangle
	       them.  */
	    if (peek_char (dm) == 'I')
	      RETURN_IF_ERROR (demangle_template_args (dm));
	    else
	      /* A substitution token is not itself a substitution
		 candidate.  (However, if the substituted template is
		 instantiated, the resulting type is.)  */
	      is_substitution_candidate = 0;
	  }
	else
	  {
	    /* Now some trickiness.  We have a special substitution
	       here.  Often, the special substitution provides the
	       name of a template that's subsequently instantiated,
	       for instance `SaIcE' => std::allocator<char>.  In these
	       cases we need to add a substitution candidate for the
	       entire <class-enum-type> and thus don't want to clear
	       the is_substitution_candidate flag.

	       However, it's possible that what we have here is a
	       substitution token representing an entire type, such as
	       `Ss' => std::string.  In this case, we mustn't add a
	       new substitution candidate for this substitution token.
	       To detect this case, remember where the start of the
	       substitution token is.  */
 	    const char *next = dm->next;
	    /* Now demangle the <class-enum-type>.  */
	    RETURN_IF_ERROR 
	      (demangle_class_enum_type (dm, &encode_return_type));
	    /* If all that was just demangled is the two-character
	       special substitution token, supress the addition of a
	       new candidate for it.  */
	    if (dm->next == next + 2)
	      is_substitution_candidate = 0;
	  }
d2338 13
a2350 1
	break;
d2352 1
a2352 8
      case 'P':
      case 'R':
      case 'M':
	RETURN_IF_ERROR (demangle_type_ptr (dm, &insert_pos, start));
	/* demangle_type_ptr adds all applicable substitution
	   candidates.  */
	is_substitution_candidate = 0;
	break;
d2354 13
a2366 6
      case 'C':
	/* A C99 complex type.  */
	RETURN_IF_ERROR (result_add (dm, "complex "));
	advance_char (dm);
	RETURN_IF_ERROR (demangle_type (dm));
	break;
d2368 4
a2371 14
      case 'G':
	/* A C99 imaginary type.  */
	RETURN_IF_ERROR (result_add (dm, "imaginary "));
	advance_char (dm);
	RETURN_IF_ERROR (demangle_type (dm));
	break;

      case 'U':
	/* Vendor-extended type qualifier.  */
	advance_char (dm);
	RETURN_IF_ERROR (demangle_source_name (dm));
	RETURN_IF_ERROR (result_add_char (dm, ' '));
	RETURN_IF_ERROR (demangle_type (dm));
	break;
d2373 1
a2373 3
      default:
	return "Unexpected character in <type>.";
      }
d2375 14
a2388 45
  if (is_substitution_candidate)
    /* Add a new substitution for the type. If this type was a
       <template-param>, pass its index since from the point of
       substitutions; a <template-param> token is a substitution
       candidate distinct from the type that is substituted for it.  */
    RETURN_IF_ERROR (substitution_add (dm, start, encode_return_type));

  /* Pop off template argument lists added during mangling of this
     type.  */
  pop_to_template_arg_list (dm, old_arg_list);

  return STATUS_OK;
}

/* C++ source names of builtin types, indexed by the mangled code
   letter's position in the alphabet ('a' -> 0, 'b' -> 1, etc).  */
static const char *const builtin_type_names[26] = 
{
  "signed char",              /* a */
  "bool",                     /* b */
  "char",                     /* c */
  "double",                   /* d */
  "long double",              /* e */
  "float",                    /* f */
  "__float128",               /* g */
  "unsigned char",            /* h */
  "int",                      /* i */
  "unsigned",                 /* j */
  NULL,                       /* k */
  "long",                     /* l */
  "unsigned long",            /* m */
  "__int128",                 /* n */
  "unsigned __int128",        /* o */
  NULL,                       /* p */
  NULL,                       /* q */
  NULL,                       /* r */
  "short",                    /* s */
  "unsigned short",           /* t */
  NULL,                       /* u */
  "void",                     /* v */
  "wchar_t",                  /* w */
  "long long",                /* x */
  "unsigned long long",       /* y */
  "..."                       /* z */
};
d2390 4
a2393 32
/* Java source names of builtin types.  Types that arn't valid in Java
   are also included here - we don't fail if someone attempts to demangle a 
   C++ symbol in Java style. */
static const char *const java_builtin_type_names[26] = 
{
  "signed char",                /* a */
  "boolean", /* C++ "bool" */   /* b */
  "byte", /* C++ "char" */      /* c */
  "double",                     /* d */
  "long double",                /* e */
  "float",                      /* f */
  "__float128",                 /* g */
  "unsigned char",              /* h */
  "int",                        /* i */
  "unsigned",                   /* j */
  NULL,                         /* k */
  "long",                       /* l */
  "unsigned long",              /* m */
  "__int128",                   /* n */
  "unsigned __int128",          /* o */
  NULL,                         /* p */
  NULL,                         /* q */
  NULL,                         /* r */
  "short",                      /* s */
  "unsigned short",             /* t */
  NULL,                         /* u */
  "void",                       /* v */
  "char", /* C++ "wchar_t" */   /* w */
  "long", /* C++ "long long" */ /* x */
  "unsigned long long",         /* y */
  "..."                         /* z */
};
d2395 1
a2395 1
/* Demangles and emits a <builtin-type>.  
d2397 6
a2402 55
    <builtin-type> ::= v  # void
		   ::= w  # wchar_t
		   ::= b  # bool
		   ::= c  # char
		   ::= a  # signed char
		   ::= h  # unsigned char
		   ::= s  # short
		   ::= t  # unsigned short
		   ::= i  # int
		   ::= j  # unsigned int
		   ::= l  # long
		   ::= m  # unsigned long
		   ::= x  # long long, __int64
		   ::= y  # unsigned long long, __int64
		   ::= n  # __int128
		   ::= o  # unsigned __int128
		   ::= f  # float
		   ::= d  # double
		   ::= e  # long double, __float80
		   ::= g  # __float128
		   ::= z  # ellipsis
		   ::= u <source-name>    # vendor extended type  */

static status_t
demangle_builtin_type (dm)
     demangling_t dm;
{

  char code = peek_char (dm);

  DEMANGLE_TRACE ("builtin-type", dm);

  if (code == 'u')
    {
      advance_char (dm);
      RETURN_IF_ERROR (demangle_source_name (dm));
      return STATUS_OK;
    }
  else if (code >= 'a' && code <= 'z')
    {
      const char *type_name;
      /* Java uses different names for some built-in types. */
      if (dm->style == DMGL_JAVA)
        type_name = java_builtin_type_names[code - 'a'];
      else
        type_name = builtin_type_names[code - 'a'];
      if (type_name == NULL)
	return "Unrecognized <builtin-type> code.";

      RETURN_IF_ERROR (result_add (dm, type_name));
      advance_char (dm);
      return STATUS_OK;
    }
  else
    return "Non-alphabetic <builtin-type> code.";
d2405 4
a2408 3
/* Demangles all consecutive CV-qualifiers (const, volatile, and
   restrict) at the current position.  The qualifiers are appended to
   QUALIFIERS.  Returns STATUS_OK.  */
d2410 5
a2414 4
static status_t
demangle_CV_qualifiers (dm, qualifiers)
     demangling_t dm;
     dyn_string_t qualifiers;
d2416 3
a2418 1
  DEMANGLE_TRACE ("CV-qualifiers", dm);
d2420 3
a2422 1
  while (1)
d2424 9
a2432 8
      switch (peek_char (dm))
	{
	case 'r':
	  if (!dyn_string_append_space (qualifiers))
	    return STATUS_ALLOCATION_FAILED;
	  if (!dyn_string_append_cstr (qualifiers, "restrict"))
	    return STATUS_ALLOCATION_FAILED;
	  break;
d2434 1
a2434 6
	case 'V':
	  if (!dyn_string_append_space (qualifiers))
	    return STATUS_ALLOCATION_FAILED;
	  if (!dyn_string_append_cstr (qualifiers, "volatile"))
	    return STATUS_ALLOCATION_FAILED;
	  break;
d2436 1
a2436 6
	case 'K':
	  if (!dyn_string_append_space (qualifiers))
	    return STATUS_ALLOCATION_FAILED;
	  if (!dyn_string_append_cstr (qualifiers, "const"))
	    return STATUS_ALLOCATION_FAILED;
	  break;
d2438 4
a2441 3
	default:
	  return STATUS_OK;
	}
d2443 1
a2443 2
      advance_char (dm);
    }
d2446 1
a2446 5
/* Demangles and emits a <function-type>.  *FUNCTION_NAME_POS is the
   position in the result string of the start of the function
   identifier, at which the function's return type will be inserted;
   *FUNCTION_NAME_POS is updated to position past the end of the
   function's return type.
d2448 4
a2451 6
    <function-type> ::= F [Y] <bare-function-type> E  */

static status_t
demangle_function_type (dm, function_name_pos)
     demangling_t dm;
     int *function_name_pos;
d2453 1
a2453 3
  DEMANGLE_TRACE ("function-type", dm);
  RETURN_IF_ERROR (demangle_char (dm, 'F'));  
  if (peek_char (dm) == 'Y')
d2455 2
a2456 4
      /* Indicate this function has C linkage if in verbose mode.  */
      if (flag_verbose)
	RETURN_IF_ERROR (result_add (dm, " [extern \"C\"] "));
      advance_char (dm);
d2458 2
a2459 4
  RETURN_IF_ERROR (demangle_bare_function_type (dm, function_name_pos));
  RETURN_IF_ERROR (demangle_char (dm, 'E'));
  return STATUS_OK;
}
d2461 5
a2465 4
/* Demangles and emits a <bare-function-type>.  RETURN_TYPE_POS is the
   position in the result string at which the function return type
   should be inserted.  If RETURN_TYPE_POS is BFT_NO_RETURN_TYPE, the
   function's return type is assumed not to be encoded.  
d2467 5
a2471 1
    <bare-function-type> ::= <signature type>+  */
d2473 32
a2504 9
static status_t
demangle_bare_function_type (dm, return_type_pos)
     demangling_t dm;
     int *return_type_pos;
{
  /* Sequence is the index of the current function parameter, counting
     from zero.  The value -1 denotes the return type.  */
  int sequence = 
    (return_type_pos == BFT_NO_RETURN_TYPE ? 0 : -1);
d2506 1
a2506 1
  DEMANGLE_TRACE ("bare-function-type", dm);
d2508 2
a2509 8
  RETURN_IF_ERROR (result_add_char (dm, '('));
  while (!end_of_name_p (dm) && peek_char (dm) != 'E')
    {
      if (sequence == -1)
	/* We're decoding the function's return type.  */
	{
	  dyn_string_t return_type;
	  status_t status = STATUS_OK;
d2511 7
a2517 17
	  /* Decode the return type off to the side.  */
	  RETURN_IF_ERROR (result_push (dm));
	  RETURN_IF_ERROR (demangle_type (dm));
	  return_type = (dyn_string_t) result_pop (dm);

	  /* Add a space to the end of the type.  Insert the return
             type where we've been asked to. */
	  if (!dyn_string_append_space (return_type))
	    status = STATUS_ALLOCATION_FAILED;
	  if (STATUS_NO_ERROR (status))
	    {
	      if (!dyn_string_insert (result_string (dm), *return_type_pos, 
				      return_type))
		status = STATUS_ALLOCATION_FAILED;
	      else
		*return_type_pos += dyn_string_length (return_type);
	    }
d2519 1
a2519 20
	  dyn_string_delete (return_type);
	  RETURN_IF_ERROR (status);
	}
      else 
	{
	  /* Skip `void' parameter types.  One should only occur as
	     the only type in a parameter list; in that case, we want
	     to print `foo ()' instead of `foo (void)'.  */
	  if (peek_char (dm) == 'v')
	    /* Consume the v.  */
	    advance_char (dm);
	  else
	    {
	      /* Separate parameter types by commas.  */
	      if (sequence > 0)
		RETURN_IF_ERROR (result_add (dm, ", "));
	      /* Demangle the type.  */
	      RETURN_IF_ERROR (demangle_type (dm));
	    }
	}
d2521 10
a2530 3
      ++sequence;
    }
  RETURN_IF_ERROR (result_add_char (dm, ')'));
d2532 2
a2533 7
  /* We should have demangled at least one parameter type (which would
     be void, for a function that takes no parameters), plus the
     return type, if we were supposed to demangle that.  */
  if (sequence == -1)
    return "Missing function return type.";
  else if (sequence == 0)
    return "Missing function parameter.";
d2535 10
a2544 2
  return STATUS_OK;
}
d2546 5
a2550 2
/* Demangles and emits a <class-enum-type>.  *ENCODE_RETURN_TYPE is set to
   non-zero if the type is a template-id, zero otherwise.  
d2552 24
a2575 1
    <class-enum-type> ::= <name>  */
d2577 4
a2580 6
static status_t
demangle_class_enum_type (dm, encode_return_type)
     demangling_t dm;
     int *encode_return_type;
{
  DEMANGLE_TRACE ("class-enum-type", dm);
d2582 2
a2583 3
  RETURN_IF_ERROR (demangle_name (dm, encode_return_type));
  return STATUS_OK;
}
d2585 1
a2585 1
/* Demangles and emits an <array-type>.  
d2587 1
a2587 7
   If PTR_INSERT_POS is not NULL, the array type is formatted as a
   pointer or reference to an array, except that asterisk and
   ampersand punctuation is omitted (since it's not know at this
   point).  *PTR_INSERT_POS is set to the position in the demangled
   name at which this punctuation should be inserted.  For example,
   `A10_i' is demangled to `int () [10]' and *PTR_INSERT_POS points
   between the parentheses.
d2589 2
a2590 3
   If PTR_INSERT_POS is NULL, the array type is assumed not to be
   pointer- or reference-qualified.  Then, for example, `A10_i' is
   demangled simply as `int[10]'.  
d2592 86
a2677 2
    <array-type> ::= A [<dimension number>] _ <element type>  
                 ::= A <dimension expression> _ <element type>  */
d2679 4
a2682 8
static status_t
demangle_array_type (dm, ptr_insert_pos)
     demangling_t dm;
     int *ptr_insert_pos;
{
  status_t status = STATUS_OK;
  dyn_string_t array_size = NULL;
  char peek;
d2684 1
a2684 1
  DEMANGLE_TRACE ("array-type", dm);
d2686 4
a2689 1
  RETURN_IF_ERROR (demangle_char (dm, 'A'));
d2691 1
a2691 86
  /* Demangle the array size into array_size.  */
  peek = peek_char (dm);
  if (peek == '_')
    /* Array bound is omitted.  This is a C99-style VLA.  */
    ;
  else if (IS_DIGIT (peek_char (dm))) 
    {
      /* It looks like a constant array bound.  */
      array_size = dyn_string_new (10);
      if (array_size == NULL)
	return STATUS_ALLOCATION_FAILED;
      status = demangle_number_literally (dm, array_size, 10, 0);
    }
  else
    {
      /* Anything is must be an expression for a nont-constant array
	 bound.  This happens if the array type occurs in a template
	 and the array bound references a template parameter.  */
      RETURN_IF_ERROR (result_push (dm));
      RETURN_IF_ERROR (demangle_expression (dm));
      array_size = (dyn_string_t) result_pop (dm);
    }
  /* array_size may have been allocated by now, so we can't use
     RETURN_IF_ERROR until it's been deallocated.  */

  /* Demangle the base type of the array.  */
  if (STATUS_NO_ERROR (status))
    status = demangle_char (dm, '_');
  if (STATUS_NO_ERROR (status))
    status = demangle_type (dm);

  if (ptr_insert_pos != NULL)
    {
      /* This array is actually part of an pointer- or
	 reference-to-array type.  Format appropriately, except we
	 don't know which and how much punctuation to use.  */
      if (STATUS_NO_ERROR (status))
	status = result_add (dm, " () ");
      /* Let the caller know where to insert the punctuation.  */
      *ptr_insert_pos = result_caret_pos (dm) - 2;
    }

  /* Emit the array dimension syntax.  */
  if (STATUS_NO_ERROR (status))
    status = result_add_char (dm, '[');
  if (STATUS_NO_ERROR (status) && array_size != NULL)
    status = result_add_string (dm, array_size);
  if (STATUS_NO_ERROR (status))
    status = result_add_char (dm, ']');
  if (array_size != NULL)
    dyn_string_delete (array_size);
  
  RETURN_IF_ERROR (status);

  return STATUS_OK;
}

/* Demangles and emits a <template-param>.  

    <template-param> ::= T_       # first template parameter
                     ::= T <parameter-2 number> _  */

static status_t
demangle_template_param (dm)
     demangling_t dm;
{
  int parm_number;
  template_arg_list_t current_arg_list = current_template_arg_list (dm);
  string_list_t arg;

  DEMANGLE_TRACE ("template-param", dm);

  /* Make sure there is a template argmust list in which to look up
     this parameter reference.  */
  if (current_arg_list == NULL)
    return "Template parameter outside of template.";

  RETURN_IF_ERROR (demangle_char (dm, 'T'));
  if (peek_char (dm) == '_')
    parm_number = 0;
  else
    {
      RETURN_IF_ERROR (demangle_number (dm, &parm_number, 10, 0));
      ++parm_number;
    }
  RETURN_IF_ERROR (demangle_char (dm, '_'));
d2693 2
a2694 6
  arg = template_arg_list_get_arg (current_arg_list, parm_number);
  if (arg == NULL)
    /* parm_number exceeded the number of arguments in the current
       template argument list.  */
    return "Template parameter number out of bounds.";
  RETURN_IF_ERROR (result_add_string (dm, (dyn_string_t) arg));
d2696 6
a2701 2
  return STATUS_OK;
}
d2703 3
a2705 1
/* Demangles and emits a <template-args>.  
d2707 5
a2711 1
    <template-args> ::= I <template-arg>+ E  */
d2713 2
a2714 7
static status_t
demangle_template_args (dm)
     demangling_t dm;
{
  int first = 1;
  dyn_string_t old_last_source_name;
  template_arg_list_t arg_list = template_arg_list_new ();
d2716 4
a2719 2
  if (arg_list == NULL)
    return STATUS_ALLOCATION_FAILED;
d2721 1
a2721 3
  /* Preserve the most recently demangled source name.  */
  old_last_source_name = dm->last_source_name;
  dm->last_source_name = dyn_string_new (0);
d2723 1
a2723 1
  DEMANGLE_TRACE ("template-args", dm);
d2725 2
a2726 2
  if (dm->last_source_name == NULL)
    return STATUS_ALLOCATION_FAILED;
d2728 2
a2729 5
  RETURN_IF_ERROR (demangle_char (dm, 'I'));
  RETURN_IF_ERROR (result_open_template_list (dm));
  do
    {
      string_list_t arg;
d2731 1
a2731 4
      if (first)
	first = 0;
      else
	RETURN_IF_ERROR (result_add (dm, ", "));
d2733 2
a2734 4
      /* Capture the template arg.  */
      RETURN_IF_ERROR (result_push (dm));
      RETURN_IF_ERROR (demangle_template_arg (dm));
      arg = result_pop (dm);
d2736 3
a2738 2
      /* Emit it in the demangled name.  */
      RETURN_IF_ERROR (result_add_string (dm, (dyn_string_t) arg));
d2740 2
a2741 6
      /* Save it for use in expanding <template-param>s.  */
      template_arg_list_add_arg (arg_list, arg);
    }
  while (peek_char (dm) != 'E');
  /* Append the '>'.  */
  RETURN_IF_ERROR (result_close_template_list (dm));
d2743 4
a2746 2
  /* Consume the 'E'.  */
  advance_char (dm);
d2748 1
a2748 3
  /* Restore the most recent demangled source name.  */
  dyn_string_delete (dm->last_source_name);
  dm->last_source_name = old_last_source_name;
d2750 1
a2750 4
  /* Push the list onto the top of the stack of template argument
     lists, so that arguments from it are used from now on when
     expanding <template-param>s.  */
  push_template_arg_list (dm, arg_list);
d2752 2
a2753 2
  return STATUS_OK;
}
d2755 1
a2755 4
/* This function, which does not correspond to a production in the
   mangling spec, handles the `literal' production for both
   <template-arg> and <expr-primary>.  It does not expect or consume
   the initial `L' or final `E'.  The demangling is given by:
d2757 2
a2758 1
     <literal> ::= <type> </value/ number>
d2760 4
a2763 1
   and the emitted output is `(type)number'.  */
d2765 26
a2790 7
static status_t
demangle_literal (dm)
     demangling_t dm;
{
  char peek = peek_char (dm);
  dyn_string_t value_string;
  status_t status;
d2792 1
a2792 1
  DEMANGLE_TRACE ("literal", dm);
d2794 10
a2803 7
  if (!flag_verbose && peek >= 'a' && peek <= 'z')
    {
      /* If not in verbose mode and this is a builtin type, see if we
	 can produce simpler numerical output.  In particular, for
	 integer types shorter than `long', just write the number
	 without type information; for bools, write `true' or `false'.
	 Other refinements could be made here too.  */
d2805 2
a2806 9
      /* This constant string is used to map from <builtin-type> codes
	 (26 letters of the alphabet) to codes that determine how the 
	 value will be displayed.  The codes are:
	   b: display as bool
	   i: display as int
           l: display as long
	 A space means the value will be represented using cast
	 notation. */
      static const char *const code_map = "ibi    iii ll     ii  i  ";
d2808 4
a2811 5
      char code = code_map[peek - 'a'];
      /* FIXME: Implement demangling of floats and doubles.  */
      if (code == 'u')
	return STATUS_UNIMPLEMENTED;
      if (code == 'b')
d2813 8
a2820 2
	  /* It's a boolean.  */
	  char value;
d2822 81
a2902 16
	  /* Consume the b.  */
	  advance_char (dm);
	  /* Look at the next character.  It should be 0 or 1,
	     corresponding to false or true, respectively.  */
	  value = peek_char (dm);
	  if (value == '0')
	    RETURN_IF_ERROR (result_add (dm, "false"));
	  else if (value == '1')
	    RETURN_IF_ERROR (result_add (dm, "true"));
	  else
	    return "Unrecognized bool constant.";
	  /* Consume the 0 or 1.  */
	  advance_char (dm);
	  return STATUS_OK;
	}
      else if (code == 'i' || code == 'l')
d2904 9
a2912 1
	  /* It's an integer or long.  */
d2914 8
a2921 2
	  /* Consume the type character.  */
	  advance_char (dm);
d2923 17
a2939 9
	  /* Demangle the number and write it out.  */
	  value_string = dyn_string_new (0);
	  status = demangle_number_literally (dm, value_string, 10, 1);
	  if (STATUS_NO_ERROR (status))
	    status = result_add_string (dm, value_string);
	  /* For long integers, append an l.  */
	  if (code == 'l' && STATUS_NO_ERROR (status))
	    status = result_add_char (dm, code);
	  dyn_string_delete (value_string);
d2941 3
a2943 2
	  RETURN_IF_ERROR (status);
	  return STATUS_OK;
a2944 3
      /* ...else code == ' ', so fall through to represent this
	 literal's type explicitly using cast syntax.  */
    }
d2946 5
a2950 3
  RETURN_IF_ERROR (result_add_char (dm, '('));
  RETURN_IF_ERROR (demangle_type (dm));
  RETURN_IF_ERROR (result_add_char (dm, ')'));
d2952 4
a2955 11
  value_string = dyn_string_new (0);
  if (value_string == NULL)
    return STATUS_ALLOCATION_FAILED;

  status = demangle_number_literally (dm, value_string, 10, 1);
  if (STATUS_NO_ERROR (status))
    status = result_add_string (dm, value_string);
  dyn_string_delete (value_string);
  RETURN_IF_ERROR (status);

  return STATUS_OK;
d2958 1
a2958 1
/* Demangles and emits a <template-arg>.  
d2960 5
a2964 8
    <template-arg> ::= <type>                     # type
                   ::= L <type> <value number> E  # literal
                   ::= LZ <encoding> E            # external name
                   ::= X <expression> E           # expression  */

static status_t
demangle_template_arg (dm)
     demangling_t dm;
d2966 3
a2968 3
  DEMANGLE_TRACE ("template-arg", dm);

  switch (peek_char (dm))
d2970 2
a2971 2
    case 'L':
      advance_char (dm);
d2973 6
a2978 1
      if (peek_char (dm) == 'Z')
d2980 21
a3000 9
	  /* External name.  */
	  advance_char (dm);
	  /* FIXME: Standard is contradictory here.  */
	  RETURN_IF_ERROR (demangle_encoding (dm));
	}
      else
	RETURN_IF_ERROR (demangle_literal (dm));
      RETURN_IF_ERROR (demangle_char (dm, 'E'));
      break;
d3002 11
a3012 6
    case 'X':
      /* Expression.  */
      advance_char (dm);
      RETURN_IF_ERROR (demangle_expression (dm));
      RETURN_IF_ERROR (demangle_char (dm, 'E'));
      break;
d3014 2
a3015 3
    default:
      RETURN_IF_ERROR (demangle_type (dm));
      break;
a3016 2

  return STATUS_OK;
d3019 1
a3019 1
/* Demangles and emits an <expression>.
d3021 4
a3024 8
    <expression> ::= <unary operator-name> <expression>
		 ::= <binary operator-name> <expression> <expression>
		 ::= <expr-primary>  
                 ::= <scope-expression>  */

static status_t
demangle_expression (dm)
     demangling_t dm;
d3026 2
a3027 1
  char peek = peek_char (dm);
d3029 12
a3040 1
  DEMANGLE_TRACE ("expression", dm);
d3042 1
a3042 19
  if (peek == 'L' || peek == 'T')
    RETURN_IF_ERROR (demangle_expr_primary (dm));
  else if (peek == 's' && peek_char_next (dm) == 'r')
    RETURN_IF_ERROR (demangle_scope_expression (dm));
  else
    /* An operator expression.  */
    {
      int num_args;
      int type_arg;
      status_t status = STATUS_OK;
      dyn_string_t operator_name;

      /* We have an operator name.  Since we want to output binary
	 operations in infix notation, capture the operator name
	 first.  */
      RETURN_IF_ERROR (result_push (dm));
      RETURN_IF_ERROR (demangle_operator_name (dm, 1, &num_args,
					       &type_arg));
      operator_name = (dyn_string_t) result_pop (dm);
d3044 1
a3044 9
      /* If it's binary, do an operand first.  */
      if (num_args > 1)
	{
	  status = result_add_char (dm, '(');
	  if (STATUS_NO_ERROR (status))
	    status = demangle_expression (dm);
	  if (STATUS_NO_ERROR (status))
	    status = result_add_char (dm, ')');
	}
d3046 4
a3049 13
      /* Emit the operator.  */  
      if (STATUS_NO_ERROR (status))
	status = result_add_string (dm, operator_name);
      dyn_string_delete (operator_name);
      RETURN_IF_ERROR (status);
      
      /* Emit its second (if binary) or only (if unary) operand.  */
      RETURN_IF_ERROR (result_add_char (dm, '('));
      if (type_arg)
	RETURN_IF_ERROR (demangle_type (dm));
      else
	RETURN_IF_ERROR (demangle_expression (dm));
      RETURN_IF_ERROR (result_add_char (dm, ')'));
d3051 48
a3098 7
      /* The ternary operator takes a third operand.  */
      if (num_args == 3)
	{
	  RETURN_IF_ERROR (result_add (dm, ":("));
	  RETURN_IF_ERROR (demangle_expression (dm));
	  RETURN_IF_ERROR (result_add_char (dm, ')'));
	}
a3099 2

  return STATUS_OK;
d3102 1
a3102 1
/* Demangles and emits a <scope-expression>.  
d3104 18
a3121 2
    <scope-expression> ::= sr <qualifying type> <source-name>
                       ::= sr <qualifying type> <encoding>  */
d3123 20
a3142 11
static status_t
demangle_scope_expression (dm)
     demangling_t dm;
{
  RETURN_IF_ERROR (demangle_char (dm, 's'));
  RETURN_IF_ERROR (demangle_char (dm, 'r'));
  RETURN_IF_ERROR (demangle_type (dm));
  RETURN_IF_ERROR (result_add (dm, "::"));
  RETURN_IF_ERROR (demangle_encoding (dm));
  return STATUS_OK;
}
d3144 2
a3145 1
/* Demangles and emits an <expr-primary>.  
d3147 2
a3148 3
    <expr-primary> ::= <template-param>
		   ::= L <type> <value number> E  # literal
		   ::= L <mangled-name> E         # external name  */
d3150 1
a3150 5
static status_t
demangle_expr_primary (dm)
     demangling_t dm;
{
  char peek = peek_char (dm);
d3152 3
a3154 1
  DEMANGLE_TRACE ("expr-primary", dm);
d3156 1
a3156 12
  if (peek == 'T')
    RETURN_IF_ERROR (demangle_template_param (dm));
  else if (peek == 'L')
    {
      /* Consume the `L'.  */
      advance_char (dm);
      peek = peek_char (dm);

      if (peek == '_')
	RETURN_IF_ERROR (demangle_mangled_name (dm));
      else
	RETURN_IF_ERROR (demangle_literal (dm));
d3158 2
a3159 4
      RETURN_IF_ERROR (demangle_char (dm, 'E'));
    }
  else
    return STATUS_ERROR;
d3161 1
a3161 1
  return STATUS_OK;
d3164 1
a3164 2
/* Demangles and emits a <substitution>.  Sets *TEMPLATE_P to non-zero
   if the substitution is the name of a template, zero otherwise. 
d3166 7
a3172 16
     <substitution> ::= S <seq-id> _
                    ::= S_

                    ::= St   # ::std::
                    ::= Sa   # ::std::allocator
                    ::= Sb   # ::std::basic_string
                    ::= Ss   # ::std::basic_string<char,
				    		   ::std::char_traits<char>,
						   ::std::allocator<char> >
                    ::= Si   # ::std::basic_istream<char,  
                                                    std::char_traits<char> >
                    ::= So   # ::std::basic_ostream<char,  
                                                    std::char_traits<char> >
                    ::= Sd   # ::std::basic_iostream<char, 
                                                    std::char_traits<char> >
*/
d3174 2
a3175 25
static status_t
demangle_substitution (dm, template_p)
     demangling_t dm;
     int *template_p;
{
  int seq_id;
  int peek;
  dyn_string_t text;

  DEMANGLE_TRACE ("substitution", dm);

  RETURN_IF_ERROR (demangle_char (dm, 'S'));

  /* Scan the substitution sequence index.  A missing number denotes
     the first index.  */
  peek = peek_char (dm);
  if (peek == '_')
    seq_id = -1;
  /* If the following character is 0-9 or a capital letter, interpret
     the sequence up to the next underscore as a base-36 substitution
     index.  */
  else if (IS_DIGIT ((unsigned char) peek) 
	   || (peek >= 'A' && peek <= 'Z'))
    RETURN_IF_ERROR (demangle_number (dm, &seq_id, 36, 0));
  else 
d3177 2
a3178 1
      const char *new_last_source_name = NULL;
d3180 2
a3181 1
      switch (peek)
d3183 2
a3184 3
	case 't':
	  RETURN_IF_ERROR (result_add (dm, "std"));
	  break;
d3186 1
a3186 14
	case 'a':
	  RETURN_IF_ERROR (result_add (dm, "std::allocator"));
	  new_last_source_name = "allocator";
	  *template_p = 1;
	  break;

	case 'b':
	  RETURN_IF_ERROR (result_add (dm, "std::basic_string"));
	  new_last_source_name = "basic_string";
	  *template_p = 1;
	  break;
	  
	case 's':
	  if (!flag_verbose)
d3188 2
a3189 2
	      RETURN_IF_ERROR (result_add (dm, "std::string"));
	      new_last_source_name = "string";
d3193 3
a3195 2
	      RETURN_IF_ERROR (result_add (dm, "std::basic_string<char, std::char_traits<char>, std::allocator<char> >"));
	      new_last_source_name = "basic_string";
d3197 1
a3197 2
	  *template_p = 0;
	  break;
d3199 2
a3200 13
	case 'i':
	  if (!flag_verbose)
	    {
	      RETURN_IF_ERROR (result_add (dm, "std::istream"));
	      new_last_source_name = "istream";
	    }
	  else
	    {
	      RETURN_IF_ERROR (result_add (dm, "std::basic_istream<char, std::char_traits<char> >"));
	      new_last_source_name = "basic_istream";
	    }
	  *template_p = 0;
	  break;
d3202 1
a3202 13
	case 'o':
	  if (!flag_verbose)
	    {
	      RETURN_IF_ERROR (result_add (dm, "std::ostream"));
	      new_last_source_name = "ostream";
	    }
	  else
	    {
	      RETURN_IF_ERROR (result_add (dm, "std::basic_ostream<char, std::char_traits<char> >"));
	      new_last_source_name = "basic_ostream";
	    }
	  *template_p = 0;
	  break;
d3204 3
a3206 13
	case 'd':
	  if (!flag_verbose) 
	    {
	      RETURN_IF_ERROR (result_add (dm, "std::iostream"));
	      new_last_source_name = "iostream";
	    }
	  else
	    {
	      RETURN_IF_ERROR (result_add (dm, "std::basic_iostream<char, std::char_traits<char> >"));
	      new_last_source_name = "basic_iostream";
	    }
	  *template_p = 0;
	  break;
d3208 2
a3209 6
	default:
	  return "Unrecognized <substitution>.";
	}
      
      /* Consume the character we just processed.  */
      advance_char (dm);
d3211 1
a3211 6
      if (new_last_source_name != NULL)
	{
	  if (!dyn_string_copy_cstr (dm->last_source_name, 
				     new_last_source_name))
	    return STATUS_ALLOCATION_FAILED;
	}
d3213 2
a3214 2
      return STATUS_OK;
    }
d3216 2
a3217 6
  /* Look up the substitution text.  Since `S_' is the most recent
     substitution, `S0_' is the second-most-recent, etc., shift the
     numbering by one.  */
  text = substitution_get (dm, seq_id + 1, template_p);
  if (text == NULL) 
    return "Substitution number out of range.";
d3219 1
a3219 2
  /* Emit the substitution text.  */
  RETURN_IF_ERROR (result_add_string (dm, text));
d3221 9
a3229 2
  RETURN_IF_ERROR (demangle_char (dm, '_'));
  return STATUS_OK;
d3232 21
a3252 1
/* Demangles and emits a <local-name>.  
d3254 1
a3254 2
    <local-name> := Z <function encoding> E <entity name> [<discriminator>]
                 := Z <function encoding> E s [<discriminator>]  */
d3256 21
a3276 3
static status_t
demangle_local_name (dm)
     demangling_t dm;
d3278 2
a3279 1
  int old_caret_position = result_get_caret (dm);
d3281 1
a3281 1
  DEMANGLE_TRACE ("local-name", dm);
d3283 7
a3289 2
  RETURN_IF_ERROR (demangle_char (dm, 'Z'));
  RETURN_IF_ERROR (demangle_encoding (dm));
d3291 7
a3297 3
  /* Restore the caret to avoid being confused by any qualifiers we
     may have found during the encoding.  */
  result_set_caret (dm, old_caret_position);
d3299 1
a3299 2
  RETURN_IF_ERROR (demangle_char (dm, 'E'));
  RETURN_IF_ERROR (result_add (dm, "::"));
d3301 1
a3301 60
  if (peek_char (dm) == 's')
    {
      /* Local character string literal.  */
      RETURN_IF_ERROR (result_add (dm, "string literal"));
      /* Consume the s.  */
      advance_char (dm);
      RETURN_IF_ERROR (demangle_discriminator (dm, 0));
    }
  else
    {
      int unused;
      /* Local name for some other entity.  Demangle its name.  */
      RETURN_IF_ERROR (demangle_name (dm, &unused));
      RETURN_IF_ERROR (demangle_discriminator (dm, 1));
     }

   return STATUS_OK;
 }

 /* Optimonally demangles and emits a <discriminator>.  If there is no
    <discriminator> at the current position in the mangled string, the
    descriminator is assumed to be zero.  Emit the discriminator number
    in parentheses, unless SUPPRESS_FIRST is non-zero and the
    discriminator is zero.  

     <discriminator> ::= _ <number>  */

static status_t
demangle_discriminator (dm, suppress_first)
     demangling_t dm;
     int suppress_first;
{
  /* Output for <discriminator>s to the demangled name is completely
     suppressed if not in verbose mode.  */

  if (peek_char (dm) == '_')
    {
      /* Consume the underscore.  */
      advance_char (dm);
      if (flag_verbose)
	RETURN_IF_ERROR (result_add (dm, " [#"));
      /* Check if there's a number following the underscore.  */
      if (IS_DIGIT ((unsigned char) peek_char (dm)))
	{
	  int discriminator;
	  /* Demangle the number.  */
	  RETURN_IF_ERROR (demangle_number (dm, &discriminator, 10, 0));
	  if (flag_verbose)
	    /* Write the discriminator.  The mangled number is two
	       less than the discriminator ordinal, counting from
	       zero.  */
	    RETURN_IF_ERROR (int_to_dyn_string (discriminator + 1,
						(dyn_string_t) dm->result));
	}
      else
	return STATUS_ERROR;
      if (flag_verbose)
	RETURN_IF_ERROR (result_add_char (dm, ']'));
    }
  else if (!suppress_first)
d3303 5
a3307 2
      if (flag_verbose)
	RETURN_IF_ERROR (result_add (dm, " [#0]"));
d3310 1
a3310 1
  return STATUS_OK;
d3313 6
a3318 3
/* Demangle NAME into RESULT, which must be an initialized
   dyn_string_t.  On success, returns STATUS_OK.  On failure, returns
   an error message, and the contents of RESULT are unchanged.  */
d3320 5
a3324 5
static status_t
cp_demangle (name, result, style)
     const char *name;
     dyn_string_t result;
     int style;
d3326 5
a3330 2
  status_t status;
  int length = strlen (name);
d3332 1
a3332 5
  if (length > 2 && name[0] == '_' && name[1] == 'Z')
    {
      demangling_t dm = demangling_new (name, style);
      if (dm == NULL)
	return STATUS_ALLOCATION_FAILED;
d3334 1
a3334 6
      status = result_push (dm);
      if (status != STATUS_OK)
	{
	  demangling_delete (dm);
	  return status;
	}
d3336 13
a3348 2
      status = demangle_mangled_name (dm);
      if (STATUS_NO_ERROR (status))
d3350 5
a3354 4
	  dyn_string_t demangled = (dyn_string_t) result_pop (dm);
	  if (!dyn_string_copy (result, demangled))
	    return STATUS_ALLOCATION_FAILED;
	  dyn_string_delete (demangled);
d3356 1
a3356 2
      
      demangling_delete (dm);
d3360 3
a3362 6
      /* It's evidently not a mangled C++ name.  It could be the name
	 of something with C linkage, though, so just copy NAME into
	 RESULT.  */
      if (!dyn_string_copy_cstr (result, name))
	return STATUS_ALLOCATION_FAILED;
      status = STATUS_OK;
d3365 5
a3369 2
  return status; 
}
d3371 4
a3374 3
/* Demangle TYPE_NAME into RESULT, which must be an initialized
   dyn_string_t.  On success, returns STATUS_OK.  On failiure, returns
   an error message, and the contents of RESULT are unchanged.  */
d3376 6
a3381 18
static status_t
cp_demangle_type (type_name, result)
     const char* type_name;
     dyn_string_t result;
{
  status_t status;
  demangling_t dm = demangling_new (type_name, DMGL_GNU_V3);
  
  if (dm == NULL)
    return STATUS_ALLOCATION_FAILED;

  /* Demangle the type name.  The demangled name is stored in dm.  */
  status = result_push (dm);
  if (status != STATUS_OK)
    {
      demangling_delete (dm);
      return status;
    }
d3383 2
a3384 1
  status = demangle_type (dm);
d3386 3
a3388 9
  if (STATUS_NO_ERROR (status))
    {
      /* The demangling succeeded.  Pop the result out of dm and copy
	 it into RESULT.  */
      dyn_string_t demangled = (dyn_string_t) result_pop (dm);
      if (!dyn_string_copy (result, demangled))
	return STATUS_ALLOCATION_FAILED;
      dyn_string_delete (demangled);
    }
d3390 1
a3390 2
  /* Clean up.  */
  demangling_delete (dm);
d3392 1
a3392 1
  return status;
d3396 1
d3399 3
a3401 3
/* ia64 ABI-mandated entry point in the C++ runtime library for performing
   demangling.  MANGLED_NAME is a NUL-terminated character string
   containing the name to be demangled.  
d3407 1
a3407 1
   is placed in a region of memory allocated with malloc.  
d3410 1
a3410 1
   demangled name, is placed in *LENGTH.  
d3414 1
a3414 1
   responsible for deallocating this memory using free.  
d3418 1
a3418 1
     -1: A memory allocation failiure occurred.
d3422 1
a3422 1
   The demagling is performed using the C++ ABI mangling rules, with
d3432 2
a3433 2
  struct dyn_string demangled_name;
  status_t result;
d3438 13
a3450 4
  if (mangled_name == NULL) {
    *status = -3;
    return NULL;
  }
d3452 3
a3454 5
  /* Did the caller provide a buffer for the demangled name?  */
  if (output_buffer == NULL) {
    /* No; dyn_string will malloc a buffer for us.  */
    if (!dyn_string_init (&demangled_name, 0)) 
      {
d3456 2
a3457 7
	return NULL;
      }
  }
  else {
    /* Yes.  Check that the length was provided.  */
    if (length == NULL) {
      *status = -3;
a3459 13
    /* Install the buffer into a dyn_string.  */
    demangled_name.allocated = *length;
    demangled_name.length = 0;
    demangled_name.s = output_buffer;
  }

  if (mangled_name[0] == '_' && mangled_name[1] == 'Z')
    /* MANGLED_NAME apprears to be a function or variable name.
       Demangle it accordingly.  */
    result = cp_demangle (mangled_name, &demangled_name, 0);
  else
    /* Try to demangled MANGLED_NAME as the name of a type.  */
    result = cp_demangle_type (mangled_name, &demangled_name);
d3461 1
a3461 2
  if (result == STATUS_OK) 
    /* The demangling succeeded.  */
a3462 3
      /* If LENGTH isn't NULL, store the allocated buffer length
	 there; the buffer may have been realloced by dyn_string
	 functions.  */
d3464 1
a3464 11
	*length = demangled_name.allocated;
      /* The operation was a success.  */
      *status = 0;
      return dyn_string_buf (&demangled_name);
    }
  else if (result == STATUS_ALLOCATION_FAILED)
    /* A call to malloc or realloc failed during the demangling
       operation.  */
    {
      *status = -1;
      return NULL;
a3466 2
    /* The demangling failed for another reason, most probably because
       MANGLED_NAME isn't a valid mangled name.  */
d3468 11
a3478 6
      /* If the buffer containing the demangled name wasn't provided
	 by the caller, free it.  */
      if (output_buffer == NULL)
	free (dyn_string_buf (&demangled_name));
      *status = -2;
      return NULL;
d3480 4
d3488 3
a3490 5
/* Variant entry point for integration with the existing cplus-dem
   demangler.  Attempts to demangle MANGLED.  If the demangling
   succeeds, returns a buffer, allocated with malloc, containing the
   demangled name.  The caller must deallocate the buffer using free.
   If the demangling failes, returns NULL.  */
d3497 1
a3497 13
  dyn_string_t demangled;
  status_t status;
  int type = !!(options & DMGL_TYPES);

  if (mangled[0] == '_' && mangled[1] == 'Z')
    /* It is not a type.  */
    type = 0;
  else
    {
      /* It is a type. Stop if we don't want to demangle types. */
      if (!type)
	return NULL;
    }
d3499 1
a3499 32
  flag_verbose = !!(options & DMGL_VERBOSE);

  /* Create a dyn_string to hold the demangled name.  */
  demangled = dyn_string_new (0);
  /* Attempt the demangling.  */
  if (!type)
    /* Appears to be a function or variable name.  */
    status = cp_demangle (mangled, demangled, 0);
  else
    /* Try to demangle it as the name of a type.  */
    status = cp_demangle_type (mangled, demangled);

  if (STATUS_NO_ERROR (status))
    /* Demangling succeeded.  */
    {
      /* Grab the demangled result from the dyn_string.  It was
	 allocated with malloc, so we can return it directly.  */
      char *return_value = dyn_string_release (demangled);
      /* Hand back the demangled name.  */
      return return_value;
    }
  else if (status == STATUS_ALLOCATION_FAILED)
    {
      fprintf (stderr, "Memory allocation failed.\n");
      abort ();
    }
  else
    /* Demangling failed.  */
    {
      dyn_string_delete (demangled);
      return NULL;
    }
d3513 15
a3527 17
  dyn_string_t demangled;
  char *next;
  char *end;
  int len;
  status_t status;
  int nesting = 0;
  char *cplus_demangled;
  char *return_value;
    
  /* Create a dyn_string to hold the demangled name.  */
  demangled = dyn_string_new (0);

  /* Attempt the demangling.  */
  status = cp_demangle ((char *) mangled, demangled, DMGL_JAVA);

  if (STATUS_NO_ERROR (status))
    /* Demangling succeeded.  */
d3529 3
a3531 30
      /* Grab the demangled result from the dyn_string. */
      cplus_demangled = dyn_string_release (demangled);
    }
  else if (status == STATUS_ALLOCATION_FAILED)
    {
      fprintf (stderr, "Memory allocation failed.\n");
      abort ();
    }
  else
    /* Demangling failed.  */
    {
      dyn_string_delete (demangled);
      return NULL;
    }
  
  len = strlen (cplus_demangled);
  next = cplus_demangled;
  end = next + len;
  demangled = NULL;

  /* Replace occurances of JArray<TYPE> with TYPE[]. */
  while (next < end)
    {
      char *open_str = strstr (next, "JArray<");
      char *close_str = NULL;
      if (nesting > 0)
	close_str = strchr (next, '>');
    
      if (open_str != NULL && (close_str == NULL || close_str > open_str))
        {
a3532 11
	  
	  if (!demangled)
	    demangled = dyn_string_new(len);

          /* Copy prepending symbols, if any. */
	  if (open_str > next)
	    {
	      open_str[0] = 0;
	      dyn_string_append_cstr (demangled, next);
	    }	  
	  next = open_str + 7;
d3534 6
a3539 2
      else if (close_str != NULL)
        {
d3541 1
a3541 10
	  
          /* Copy prepending type symbol, if any. Squash any spurious 
	     whitespace. */
	  if (close_str > next && next[0] != ' ')
	    {
	      close_str[0] = 0;
	      dyn_string_append_cstr (demangled, next);
	    }
	  dyn_string_append_cstr (demangled, "[]");	  
	  next = close_str + 1;
d3544 1
a3544 9
        {
	  /* There are no more arrays. Copy the rest of the symbol, or
	     simply return the original symbol if no changes were made. */
	  if (next == cplus_demangled)
	    return cplus_demangled;

          dyn_string_append_cstr (demangled, next);
	  next = end;
	}
d3547 1
a3547 6
  free (cplus_demangled);
  
  if (demangled)
    return_value = dyn_string_release (demangled);
  else
    return_value = NULL;
d3549 1
a3549 1
  return return_value;
d3554 5
d3560 5
a3564 7
#ifndef IN_GLIBCPP_V3
/* Demangle NAME in the G++ V3 ABI demangling style, and return either
   zero, indicating that some error occurred, or a demangling_t
   holding the results.  */
static demangling_t
demangle_v3_with_details (name)
     const char *name;
d3566 2
a3567 2
  demangling_t dm;
  status_t status;
d3569 4
a3572 1
  if (strncmp (name, "_Z", 2))
d3575 4
a3578 6
  dm = demangling_new (name, DMGL_GNU_V3);
  if (dm == NULL)
    {
      fprintf (stderr, "Memory allocation failed.\n");
      abort ();
    }
d3580 1
a3580 2
  status = result_push (dm);
  if (! STATUS_NO_ERROR (status))
d3582 22
a3603 3
      demangling_delete (dm);
      fprintf (stderr, "%s\n", status);
      abort ();
a3605 5
  status = demangle_mangled_name (dm);
  if (STATUS_NO_ERROR (status))
    return dm;

  demangling_delete (dm);
d3609 2
a3611 5
/* Return non-zero iff NAME is the mangled form of a constructor name
   in the G++ V3 ABI demangling style.  Specifically, return:
   - '1' if NAME is a complete object constructor,
   - '2' if NAME is a base object constructor, or
   - '3' if NAME is a complete object allocating constructor.  */
d3616 2
a3617 1
  demangling_t dm = demangle_v3_with_details (name);
d3619 1
a3619 7
  if (dm)
    {
      enum gnu_v3_ctor_kinds result = dm->is_constructor;
      demangling_delete (dm);
      return result;
    }
  else
d3621 1
d3625 3
a3627 5
/* Return non-zero iff NAME is the mangled form of a destructor name
   in the G++ V3 ABI demangling style.  Specifically, return:
   - '0' if NAME is a deleting destructor,
   - '1' if NAME is a complete object destructor, or
   - '2' if NAME is a base object destructor.  */
d3632 2
a3633 1
  demangling_t dm = demangle_v3_with_details (name);
d3635 1
a3635 7
  if (dm)
    {
      enum gnu_v3_dtor_kinds result = dm->is_destructor;
      demangling_delete (dm);
      return result;
    }
  else
d3637 1
d3639 1
a3641 1

d3645 3
d3649 3
a3651 2
static void print_usage
  PARAMS ((FILE* fp, int exit_value));
a3670 1
  fprintf (fp, "  -s,--strict     Demangle standard names only.\n");
a3680 1
  { "strict",  no_argument, NULL, 's' },
a3694 1
  status_t status;
d3697 1
d3705 1
a3705 1
      opt_char = getopt_long (argc, argv, "hsv", long_options, NULL);
a3715 4
	case 's':
	  flag_strict = 1;
	  break;

d3717 1
a3717 1
	  flag_verbose = 1;
d3727 1
a3727 2
      dyn_string_t demangled = dyn_string_new (0);
      status_t status;
d3732 1
a3732 29
	  char c = getchar ();

	  /* The first character of a mangled name is an underscore.  */
	  if (feof (stdin))
	    break;
	  if (c != '_')
	    {
	      /* It's not a mangled name.  Print the character and go
		 on.  */
	      putchar (c);
	      continue;
	    }
	  c = getchar ();
	  
	  /* The second character of a mangled name is a capital `Z'.  */
	  if (feof (stdin))
	    break;
	  if (c != 'Z')
	    {
	      /* It's not a mangled name.  Print the previous
		 underscore, the `Z', and go on.  */
	      putchar ('_');
	      putchar (c);
	      continue;
	    }

	  /* Start keeping track of the candidate mangled name.  */
	  dyn_string_append_char (mangled, '_');
	  dyn_string_append_char (mangled, 'Z');
d3745 15
a3759 2
	  /* Attempt to demangle the name.  */
	  status = cp_demangle (dyn_string_buf (mangled), demangled, 0);
d3761 1
a3761 9
	  /* If the demangling succeeded, great!  Print out the
	     demangled version.  */
	  if (STATUS_NO_ERROR (status))
	    fputs (dyn_string_buf (demangled), stdout);
	  /* Abort on allocation failures.  */
	  else if (status == STATUS_ALLOCATION_FAILED)
	    {
	      fprintf (stderr, "Memory allocation failed.\n");
	      abort ();
a3762 4
	  /* Otherwise, it might not have been a mangled name.  Just
	     print out the original text.  */
	  else
	    fputs (dyn_string_buf (mangled), stdout);
a3767 4

	  /* Clear the candidate mangled name, to start afresh next
	     time we hit a `_Z'.  */
	  dyn_string_clear (mangled);
a3770 1
      dyn_string_delete (demangled);
a3774 2
      dyn_string_t result = dyn_string_new (0);

d3778 2
d3781 1
a3781 1
	  status = cp_demangle (argv[i], result, 0);
d3784 1
a3784 4
	  if (STATUS_NO_ERROR (status))
	    printf ("%s\n", dyn_string_buf (result));
	  /* Abort on allocaiton failures.  */
	  else if (status == STATUS_ALLOCATION_FAILED)
d3786 2
a3787 2
	      fprintf (stderr, "Memory allocation failed.\n");
	      abort ();
d3789 2
a3790 3
	  /* If not, print the error message to stderr instead.  */
	  else 
	    fprintf (stderr, "%s\n", status);
a3791 1
      dyn_string_delete (result);
@


1.30
log
@merge from gcc
@
text
@d2560 2
a2561 2
	   letter following the `S'; other substitutions have a digit
	   or underscore.  */
d2563 3
a2565 1
	if (IS_DIGIT (peek_next) || peek_next == '_')
@


1.29
log
@merge from gcc
@
text
@d1150 1
a1150 1
    <nested-name>     ::= N [<CV-qualifiers>] <prefix> <unqulified-name> E  */
d1665 1
a1665 1
    { "sz", " sizeof"  , 1 }
d2239 3
d2251 30
a2280 1
      if (peek_char (dm) == 'F')
d2287 1
a2287 1
      else if (peek_char (dm) == 'A')
d2321 3
d2355 33
a2474 10
	  /* Emit them, and shift the caret left so that the
	     underlying type will be emitted before the qualifiers.  */
	  status = result_add_string (dm, cv_qualifiers);
	  result_shift_caret (dm, -dyn_string_length (cv_qualifiers));
	  /* Clean up.  */
	  dyn_string_delete (cv_qualifiers);
	  RETURN_IF_ERROR (status);
	  /* Also prepend a blank, if needed.  */
	  RETURN_IF_ERROR (result_add_char (dm, ' '));
	  result_shift_caret (dm, -1);
d2476 34
a2509 3
	  /* Demangle the underlying type.  It will be emitted before
	     the CV qualifiers, since we moved the caret.  */
	  RETURN_IF_ERROR (demangle_type (dm));
d2511 3
a2513 2
	  /* Put the caret back where it was previously.  */
	  result_set_caret (dm, old_caret_position);
d2518 9
a2526 1
	return "Non-pointer or -reference function type.";
d3573 2
d3579 5
@


1.28
log
@merge from gcc
@
text
@d5 1
a5 1
   This file is part of GNU CC.
d7 1
a7 1
   This program is free software; you can redistribute it and/or modify
@


1.27
log
@merge from gcc
@
text
@d3401 1
a3401 1
	      RETURN_IF_ERROR (result_add (dm, "std::basic_istream<char, std::char_traints<char> >"));
@


1.27.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 3
a3 3
/* Demangler for g++ V3 ABI.
   Copyright (C) 2003 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@wasabisystems.com>.
d5 1
a5 1
   This file is part of the libiberty library, which is part of GCC.
d7 1
a7 1
   This file is free software; you can redistribute it and/or modify
d31 6
a36 36
/* This code implements a demangler for the g++ V3 ABI.  The ABI is
   described on this web page:
       http://www.codesourcery.com/cxx-abi/abi.html#mangling

   This code was written while looking at the demangler written by
   Alex Samuel <samuel@@codesourcery.com>.

   This code first pulls the mangled name apart into a list of
   components, and then walks the list generating the demangled
   name.

   This file will normally define the following functions, q.v.:
      char *cplus_demangle_v3(const char *mangled, int options)
      char *java_demangle_v3(const char *mangled)
      enum gnu_v3_ctor_kinds is_gnu_v3_mangled_ctor (const char *name)
      enum gnu_v3_dtor_kinds is_gnu_v3_mangled_dtor (const char *name)

   Preprocessor macros you can define while compiling this file:

   IN_LIBGCC2
      If defined, this file defines the following function, q.v.:
         char *__cxa_demangle (const char *mangled, char *buf, size_t *len,
                               int *status)
      instead of cplus_demangle_v3() and java_demangle_v3().

   IN_GLIBCPP_V3
      If defined, this file defines only __cxa_demangle().

   STANDALONE_DEMANGLER
      If defined, this file defines a main() function which demangles
      any arguments, or, if none, demangles stdin.

   CP_DEMANGLE_DEBUG
      If defined, turns on debugging mode, which prints information on
      stdout about the mangled string.  This is not generally useful.
*/
d42 1
a42 1
#include <stdio.h>
d47 3
d54 2
d58 1
d61 16
a76 12
/* We avoid pulling in the ctype tables, to prevent pulling in
   additional unresolved symbols when this code is used in a library.
   FIXME: Is this really a valid reason?  This comes from the original
   V3 demangler code.

   As of this writing this file has the following undefined references
   when compiled with -DIN_GLIBCPP_V3: malloc, realloc, free, memcpy,
   strcpy, strcat, strlen.  */

#define IS_DIGIT(c) ((c) >= '0' && (c) <= '9')
#define IS_UPPER(c) ((c) >= 'A' && (c) <= 'Z')
#define IS_LOWER(c) ((c) >= 'a' && (c) <= 'z')
a80 2
#define ANONYMOUS_NAMESPACE_PREFIX_LEN \
  (sizeof (ANONYMOUS_NAMESPACE_PREFIX) - 1)
d82 28
a109 1
/* Information we keep for operators.  */
d111 2
a112 8
struct d_operator_info
{
  /* Mangled name.  */
  const char *code;
  /* Real name.  */
  const char *name;
  /* Number of arguments.  */
  int args;
d115 1
a115 1
/* How to print the value of a builtin type.  */
d117 3
a119 1
enum d_builtin_type_print
d121 5
a125 10
  /* Print as (type)val.  */
  D_PRINT_DEFAULT,
  /* Print as integer.  */
  D_PRINT_INT,
  /* Print as long, with trailing `l'.  */
  D_PRINT_LONG,
  /* Print as bool.  */
  D_PRINT_BOOL,
  /* Print in usual way, but here to detect void.  */
  D_PRINT_VOID
d128 1
a128 1
/* Information we keep for a builtin type.  */
d130 1
a130 1
struct d_builtin_type_info
d132 3
a134 7
  /* Type name.  */
  const char *name;
  /* Type name when using Java.  */
  const char *java_name;
  /* How to print a value of this type.  */
  enum d_builtin_type_print print;
};
d136 3
a138 1
/* Component types found in mangled names.  */
d140 2
a141 97
enum d_comp_type
{
  /* A name.  */
  D_COMP_NAME,
  /* A qualified name.  */
  D_COMP_QUAL_NAME,
  /* A typed name.  */
  D_COMP_TYPED_NAME,
  /* A template.  */
  D_COMP_TEMPLATE,
  /* A template parameter.  */
  D_COMP_TEMPLATE_PARAM,
  /* A constructor.  */
  D_COMP_CTOR,
  /* A destructor.  */
  D_COMP_DTOR,
  /* A vtable.  */
  D_COMP_VTABLE,
  /* A VTT structure.  */
  D_COMP_VTT,
  /* A construction vtable.  */
  D_COMP_CONSTRUCTION_VTABLE,
  /* A typeinfo structure.  */
  D_COMP_TYPEINFO,
  /* A typeinfo name.  */
  D_COMP_TYPEINFO_NAME,
  /* A typeinfo function.  */
  D_COMP_TYPEINFO_FN,
  /* A thunk.  */
  D_COMP_THUNK,
  /* A virtual thunk.  */
  D_COMP_VIRTUAL_THUNK,
  /* A covariant thunk.  */
  D_COMP_COVARIANT_THUNK,
  /* A Java class.  */
  D_COMP_JAVA_CLASS,
  /* A guard variable.  */
  D_COMP_GUARD,
  /* A reference temporary.  */
  D_COMP_REFTEMP,
  /* A standard substitution.  */
  D_COMP_SUB_STD,
  /* The restrict qualifier.  */
  D_COMP_RESTRICT,
  /* The volatile qualifier.  */
  D_COMP_VOLATILE,
  /* The const qualifier.  */
  D_COMP_CONST,
  /* The restrict qualifier modifying a member function.  */
  D_COMP_RESTRICT_THIS,
  /* The volatile qualifier modifying a member function.  */
  D_COMP_VOLATILE_THIS,
  /* The const qualifier modifying a member function.  */
  D_COMP_CONST_THIS,
  /* A vendor qualifier.  */
  D_COMP_VENDOR_TYPE_QUAL,
  /* A pointer.  */
  D_COMP_POINTER,
  /* A reference.  */
  D_COMP_REFERENCE,
  /* A complex type.  */
  D_COMP_COMPLEX,
  /* An imaginary type.  */
  D_COMP_IMAGINARY,
  /* A builtin type.  */
  D_COMP_BUILTIN_TYPE,
  /* A vendor's builtin type.  */
  D_COMP_VENDOR_TYPE,
  /* A function type.  */
  D_COMP_FUNCTION_TYPE,
  /* An array type.  */
  D_COMP_ARRAY_TYPE,
  /* A pointer to member type.  */
  D_COMP_PTRMEM_TYPE,
  /* An argument list.  */
  D_COMP_ARGLIST,
  /* A template argument list.  */
  D_COMP_TEMPLATE_ARGLIST,
  /* An operator.  */
  D_COMP_OPERATOR,
  /* An extended operator.  */
  D_COMP_EXTENDED_OPERATOR,
  /* A typecast.  */
  D_COMP_CAST,
  /* A unary expression.  */
  D_COMP_UNARY,
  /* A binary expression.  */
  D_COMP_BINARY,
  /* Arguments to a binary expression.  */
  D_COMP_BINARY_ARGS,
  /* A trinary expression.  */
  D_COMP_TRINARY,
  /* Arguments to a trinary expression.  */
  D_COMP_TRINARY_ARG1,
  D_COMP_TRINARY_ARG2,
  /* A literal.  */
  D_COMP_LITERAL
d144 3
a146 1
/* A component of the mangled name.  */
d148 1
a148 1
struct d_comp
d150 5
a154 12
  /* The type of this component.  */
  enum d_comp_type type;
  union
  {
    /* For D_COMP_NAME.  */
    struct
    {
      /* A pointer to the name (not NULL terminated) and it's
	 length.  */
      const char *s;
      int len;
    } s_name;
d156 3
a158 6
    /* For D_COMP_OPERATOR.  */
    struct
    {
      /* Operator.  */
      const struct d_operator_info *op;
    } s_operator;
d160 2
a161 8
    /* For D_COMP_EXTENDED_OPERATOR.  */
    struct
    {
      /* Number of arguments.  */
      int args;
      /* Name.  */
      struct d_comp *name;
    } s_extended_operator;
d163 2
a164 6
    /* For D_COMP_CTOR.  */
    struct
    {
      enum gnu_v3_ctor_kinds kind;
      struct d_comp *name;
    } s_ctor;
d166 3
a168 6
    /* For D_COMP_DTOR.  */
    struct
    {
      enum gnu_v3_dtor_kinds kind;
      struct d_comp *name;
    } s_dtor;
d170 1
a170 5
    /* For D_COMP_BUILTIN_TYPE.  */
    struct
    {
      const struct d_builtin_type_info *type;
    } s_builtin;
d172 2
a173 5
    /* For D_COMP_SUB_STD.  */
    struct
    {
      const char* string;
    } s_string;
d175 2
a176 5
    /* For D_COMP_TEMPLATE_PARAM.  */
    struct
    {
      long number;
    } s_number;
d178 2
a179 6
    /* For other types.  */
    struct
    {
      struct d_comp *left;
      struct d_comp *right;
    } s_binary;
d181 5
a185 2
  } u;
};
d187 3
a189 2
#define d_left(dc) ((dc)->u.s_binary.left)
#define d_right(dc) ((dc)->u.s_binary.right)
d191 3
a193 1
/* The information structure we pass around.  */
a194 22
struct d_info
{
  /* The string we are demangling.  */
  const char *s;
  /* The options passed to the demangler.  */
  int options;
  /* The next character in the string to consider.  */
  const char *n;
  /* The array of components.  */
  struct d_comp *comps;
  /* The index of the next available component.  */
  int next_comp;
  /* The number of available component structures.  */
  int num_comps;
  /* The array of substitutions.  */
  struct d_comp **subs;
  /* The index of the next substitution.  */
  int next_sub;
  /* The number of available entries in the subs array.  */
  int num_subs;
  /* The last name we saw, for constructors and destructors.  */
  struct d_comp *last_name;
d197 1
a197 15
#define d_peek_char(di) (*((di)->n))
#define d_peek_next_char(di) ((di)->n[1])
#define d_advance(di, i) ((di)->n += (i))
#define d_next_char(di) (*((di)->n++))
#define d_str(di) ((di)->n)

/* A list of templates.  This is used while printing.  */

struct d_print_template
{
  /* Next template on the list.  */
  struct d_print_template *next;
  /* This template.  */
  const struct d_comp *template;
};
d199 28
a226 1
/* A list of type modifiers.  This is used while printing.  */
d228 140
a367 1
struct d_print_mod
d369 2
a370 10
  /* Next modifier on the list.  These are in the reverse of the order
     in which they appeared in the mangled string.  */
  struct d_print_mod *next;
  /* The modifier.  */
  const struct d_comp *mod;
  /* Whether this modifier was printed.  */
  int printed;
  /* The list of templates which applies to this modifier.  */
  struct d_print_template *templates;
};
d372 7
a378 1
/* We use this structure to hold information during printing.  */
d380 15
a394 18
struct d_print_info
{
  /* The options passed to the demangler.  */
  int options;
  /* Buffer holding the result.  */
  char *buf;
  /* Current length of data in buffer.  */
  size_t len;
  /* Allocated size of buffer.  */
  size_t alc;
  /* The current list of templates, if any.  */
  struct d_print_template *templates;
  /* The current list of modifiers (e.g., pointer, reference, etc.),
     if any.  */
  struct d_print_mod *modifiers;
  /* Set to 1 if we had a memory allocation failure.  */
  int allocation_failure;
};
d396 4
a399 1
#define d_print_saw_error(dpi) ((dpi)->buf == NULL)
d401 2
a402 9
#define d_append_char(dpi, c) \
  do \
    { \
      if ((dpi)->buf != NULL && (dpi)->len < (dpi)->alc) \
        (dpi)->buf[(dpi)->len++] = (c); \
      else \
        d_print_append_char ((dpi), (c)); \
    } \
  while (0)
d404 3
a406 12
#define d_append_buffer(dpi, s, l) \
  do \
    { \
      if ((dpi)->buf != NULL && (dpi)->len + (l) <= (dpi)->alc) \
        { \
          memcpy ((dpi)->buf + (dpi)->len, (s), (l)); \
          (dpi)->len += l; \
        } \
      else \
        d_print_append_buffer ((dpi), (s), (l)); \
    } \
  while (0)
d408 2
a409 7
#define d_append_string(dpi, s) \
  do \
    { \
      size_t d_append_string_len = strlen (s); \
      d_append_buffer ((dpi), (s), d_append_string_len); \
    } \
  while (0)
d411 4
a414 2
#define d_last_char(dpi) \
  ((dpi)->buf == NULL || (dpi)->len == 0 ? '\0' : (dpi)->buf[(dpi)->len - 1])
d416 12
a427 82
#ifdef CP_DEMANGLE_DEBUG
static void d_dump PARAMS ((struct d_comp *, int));
#endif
static struct d_comp *d_make_empty PARAMS ((struct d_info *,
					    enum d_comp_type));
static struct d_comp *d_make_comp PARAMS ((struct d_info *, enum d_comp_type,
					   struct d_comp *, struct d_comp *));
static struct d_comp *d_make_name PARAMS ((struct d_info *, const char *,
					   int));
static struct d_comp *d_make_builtin_type PARAMS ((struct d_info *,
						   const struct d_builtin_type_info *));
static struct d_comp *d_make_operator PARAMS ((struct d_info *,
					       const struct d_operator_info *));
static struct d_comp *d_make_extended_operator PARAMS ((struct d_info *,
							int,
							struct d_comp *));
static struct d_comp *d_make_ctor PARAMS ((struct d_info *,
					   enum gnu_v3_ctor_kinds,
					   struct d_comp *));
static struct d_comp *d_make_dtor PARAMS ((struct d_info *,
					   enum gnu_v3_dtor_kinds,
					   struct d_comp *));
static struct d_comp *d_make_template_param PARAMS ((struct d_info *, long));
static struct d_comp *d_make_sub PARAMS ((struct d_info *, const char *));
static struct d_comp *d_mangled_name PARAMS ((struct d_info *, int));
static int has_return_type PARAMS ((struct d_comp *));
static int is_ctor_dtor_or_conversion PARAMS ((struct d_comp *));
static struct d_comp *d_encoding PARAMS ((struct d_info *, int));
static struct d_comp *d_name PARAMS ((struct d_info *));
static struct d_comp *d_nested_name PARAMS ((struct d_info *));
static struct d_comp *d_prefix PARAMS ((struct d_info *));
static struct d_comp *d_unqualified_name PARAMS ((struct d_info *));
static struct d_comp *d_source_name PARAMS ((struct d_info *));
static long d_number PARAMS ((struct d_info *));
static struct d_comp *d_identifier PARAMS ((struct d_info *, int));
static struct d_comp *d_operator_name PARAMS ((struct d_info *));
static struct d_comp *d_special_name PARAMS ((struct d_info *));
static int d_call_offset PARAMS ((struct d_info *, int));
static struct d_comp *d_ctor_dtor_name PARAMS ((struct d_info *));
static struct d_comp *d_type PARAMS ((struct d_info *));
static struct d_comp **d_cv_qualifiers PARAMS ((struct d_info *,
						struct d_comp **, int));
static struct d_comp *d_function_type PARAMS ((struct d_info *));
static struct d_comp *d_bare_function_type PARAMS ((struct d_info *, int));
static struct d_comp *d_class_enum_type PARAMS ((struct d_info *));
static struct d_comp *d_array_type PARAMS ((struct d_info *));
static struct d_comp *d_pointer_to_member_type PARAMS ((struct d_info *));
static struct d_comp *d_template_param PARAMS ((struct d_info *));
static struct d_comp *d_template_args PARAMS ((struct d_info *));
static struct d_comp *d_template_arg PARAMS ((struct d_info *));
static struct d_comp *d_expression PARAMS ((struct d_info *));
static struct d_comp *d_expr_primary PARAMS ((struct d_info *));
static struct d_comp *d_local_name PARAMS ((struct d_info *));
static int d_discriminator PARAMS ((struct d_info *));
static int d_add_substitution PARAMS ((struct d_info *, struct d_comp *));
static struct d_comp *d_substitution PARAMS ((struct d_info *));
static void d_print_resize PARAMS ((struct d_print_info *, size_t));
static void d_print_append_char PARAMS ((struct d_print_info *, int));
static void d_print_append_buffer PARAMS ((struct d_print_info *, const char *,
					   size_t));
static void d_print_error PARAMS ((struct d_print_info *));
static char *d_print PARAMS ((int, const struct d_comp *, size_t *));
static void d_print_comp PARAMS ((struct d_print_info *,
				  const struct d_comp *));
static void d_print_identifier PARAMS ((struct d_print_info *, const char *,
					int));
static void d_print_mod_list PARAMS ((struct d_print_info *,
				      struct d_print_mod *, int));
static void d_print_mod PARAMS ((struct d_print_info *,
				 const struct d_comp *));
static void d_print_function_type PARAMS ((struct d_print_info *,
					   const struct d_comp *,
					   struct d_print_mod *));
static void d_print_array_type PARAMS ((struct d_print_info *,
					const struct d_comp *,
					struct d_print_mod *));
static void d_print_expr_op PARAMS ((struct d_print_info *,
				     const struct d_comp *));
static void d_print_cast PARAMS ((struct d_print_info *,
				  const struct d_comp *));
static int d_init_info PARAMS ((const char *, int, size_t, struct d_info *));
static char *d_demangle PARAMS ((const char *, int, size_t *));
d429 1
a429 1
#ifdef CP_DEMANGLE_DEBUG
d432 2
a433 3
d_dump (dc, indent)
     struct d_comp *dc;
     int indent;
d435 28
a462 1
  int i;
d464 4
a467 2
  if (dc == NULL)
    return;
d469 8
a476 2
  for (i = 0; i < indent; ++i)
    putchar (' ');
d478 5
a482 30
  switch (dc->type)
    {
    case D_COMP_NAME:
      printf ("name '%.*s'\n", dc->u.s_name.len, dc->u.s_name.s);
      return;
    case D_COMP_TEMPLATE_PARAM:
      printf ("template parameter %ld\n", dc->u.s_number.number);
      return;
    case D_COMP_CTOR:
      printf ("constructor %d\n", (int) dc->u.s_ctor.kind);
      d_dump (dc->u.s_ctor.name, indent + 2);
      return;
    case D_COMP_DTOR:
      printf ("destructor %d\n", (int) dc->u.s_dtor.kind);
      d_dump (dc->u.s_dtor.name, indent + 2);
      return;
    case D_COMP_SUB_STD:
      printf ("standard substitution %s\n", dc->u.s_string.string);
      return;
    case D_COMP_BUILTIN_TYPE:
      printf ("builtin type %s\n", dc->u.s_builtin.type->name);
      return;
    case D_COMP_OPERATOR:
      printf ("operator %s\n", dc->u.s_operator.op->name);
      return;
    case D_COMP_EXTENDED_OPERATOR:
      printf ("extended operator with %d args\n",
	      dc->u.s_extended_operator.args);
      d_dump (dc->u.s_extended_operator.name, indent + 2);
      return;
d484 3
a486 121
    case D_COMP_QUAL_NAME:
      printf ("qualified name\n");
      break;
    case D_COMP_TYPED_NAME:
      printf ("typed name\n");
      break;
    case D_COMP_TEMPLATE:
      printf ("template\n");
      break;
    case D_COMP_VTABLE:
      printf ("vtable\n");
      break;
    case D_COMP_VTT:
      printf ("VTT\n");
      break;
    case D_COMP_CONSTRUCTION_VTABLE:
      printf ("construction vtable\n");
      break;
    case D_COMP_TYPEINFO:
      printf ("typeinfo\n");
      break;
    case D_COMP_TYPEINFO_NAME:
      printf ("typeinfo name\n");
      break;
    case D_COMP_TYPEINFO_FN:
      printf ("typeinfo function\n");
      break;
    case D_COMP_THUNK:
      printf ("thunk\n");
      break;
    case D_COMP_VIRTUAL_THUNK:
      printf ("virtual thunk\n");
      break;
    case D_COMP_COVARIANT_THUNK:
      printf ("covariant thunk\n");
      break;
    case D_COMP_JAVA_CLASS:
      printf ("java class\n");
      break;
    case D_COMP_GUARD:
      printf ("guard\n");
      break;
    case D_COMP_REFTEMP:
      printf ("reference temporary\n");
      break;
    case D_COMP_RESTRICT:
      printf ("restrict\n");
      break;
    case D_COMP_VOLATILE:
      printf ("volatile\n");
      break;
    case D_COMP_CONST:
      printf ("const\n");
      break;
    case D_COMP_RESTRICT_THIS:
      printf ("restrict this\n");
      break;
    case D_COMP_VOLATILE_THIS:
      printf ("volatile this\n");
      break;
    case D_COMP_CONST_THIS:
      printf ("const this\n");
      break;
    case D_COMP_VENDOR_TYPE_QUAL:
      printf ("vendor type qualifier\n");
      break;
    case D_COMP_POINTER:
      printf ("pointer\n");
      break;
    case D_COMP_REFERENCE:
      printf ("reference\n");
      break;
    case D_COMP_COMPLEX:
      printf ("complex\n");
      break;
    case D_COMP_IMAGINARY:
      printf ("imaginary\n");
      break;
    case D_COMP_VENDOR_TYPE:
      printf ("vendor type\n");
      break;
    case D_COMP_FUNCTION_TYPE:
      printf ("function type\n");
      break;
    case D_COMP_ARRAY_TYPE:
      printf ("array type\n");
      break;
    case D_COMP_PTRMEM_TYPE:
      printf ("pointer to member type\n");
      break;
    case D_COMP_ARGLIST:
      printf ("argument list\n");
      break;
    case D_COMP_TEMPLATE_ARGLIST:
      printf ("template argument list\n");
      break;
    case D_COMP_CAST:
      printf ("cast\n");
      break;
    case D_COMP_UNARY:
      printf ("unary operator\n");
      break;
    case D_COMP_BINARY:
      printf ("binary operator\n");
      break;
    case D_COMP_BINARY_ARGS:
      printf ("binary operator arguments\n");
      break;
    case D_COMP_TRINARY:
      printf ("trinary operator\n");
      break;
    case D_COMP_TRINARY_ARG1:
      printf ("trinary operator arguments 1\n");
      break;
    case D_COMP_TRINARY_ARG2:
      printf ("trinary operator arguments 1\n");
      break;
    case D_COMP_LITERAL:
      printf ("literal\n");
      break;
    }
d488 7
a494 2
  d_dump (d_left (dc), indent + 2);
  d_dump (d_right (dc), indent + 2);
d497 9
a505 1
#endif /* CP_DEMANGLE_DEBUG */
d507 2
a508 1
/* Add a new component.  */
d510 4
a513 4
static struct d_comp *
d_make_empty (di, type)
     struct d_info *di;
     enum d_comp_type type;
d515 2
a516 1
  struct d_comp *p;
d518 2
a519 40
  if (di->next_comp >= di->num_comps)
    return NULL;
  p = &di->comps[di->next_comp];
  p->type = type;
  ++di->next_comp;
  return p;
}

/* Add a new generic component.  */

static struct d_comp *
d_make_comp (di, type, left, right)
     struct d_info *di;
     enum d_comp_type type;
     struct d_comp *left;
     struct d_comp *right;
{
  struct d_comp *p;

  /* We check for errors here.  A typical error would be a NULL return
     from a subroutine.  We catch those here, and return NULL
     upward.  */
  switch (type)
    {
      /* These types require two parameters.  */
    case D_COMP_QUAL_NAME:
    case D_COMP_TYPED_NAME:
    case D_COMP_TEMPLATE:
    case D_COMP_VENDOR_TYPE_QUAL:
    case D_COMP_PTRMEM_TYPE:
    case D_COMP_UNARY:
    case D_COMP_BINARY:
    case D_COMP_BINARY_ARGS:
    case D_COMP_TRINARY:
    case D_COMP_TRINARY_ARG1:
    case D_COMP_TRINARY_ARG2:
    case D_COMP_LITERAL:
      if (left == NULL || right == NULL)
	return NULL;
      break;
d521 7
a527 24
      /* These types only require one parameter.  */
    case D_COMP_VTABLE:
    case D_COMP_VTT:
    case D_COMP_CONSTRUCTION_VTABLE:
    case D_COMP_TYPEINFO:
    case D_COMP_TYPEINFO_NAME:
    case D_COMP_TYPEINFO_FN:
    case D_COMP_THUNK:
    case D_COMP_VIRTUAL_THUNK:
    case D_COMP_COVARIANT_THUNK:
    case D_COMP_JAVA_CLASS:
    case D_COMP_GUARD:
    case D_COMP_REFTEMP:
    case D_COMP_POINTER:
    case D_COMP_REFERENCE:
    case D_COMP_COMPLEX:
    case D_COMP_IMAGINARY:
    case D_COMP_VENDOR_TYPE:
    case D_COMP_ARGLIST:
    case D_COMP_TEMPLATE_ARGLIST:
    case D_COMP_CAST:
      if (left == NULL)
	return NULL;
      break;
d529 3
a531 6
      /* This needs a right parameter, but the left parameter can be
	 empty.  */
    case D_COMP_ARRAY_TYPE:
      if (right == NULL)
	return NULL;
      break;
d533 8
a540 10
      /* These are allowed to have no parameters--in some cases they
	 will be filled in later.  */
    case D_COMP_FUNCTION_TYPE:
    case D_COMP_RESTRICT:
    case D_COMP_VOLATILE:
    case D_COMP_CONST:
    case D_COMP_RESTRICT_THIS:
    case D_COMP_VOLATILE_THIS:
    case D_COMP_CONST_THIS:
      break;
d542 3
a544 4
      /* Other types should not be seen here.  */
    default:
      return NULL;
    }
d546 5
a550 7
  p = d_make_empty (di, type);
  if (p != NULL)
    {
      p->u.s_binary.left = left;
      p->u.s_binary.right = right;
    }
  return p;
d553 3
a555 1
/* Add a new name component.  */
d557 5
a561 5
static struct d_comp *
d_make_name (di, s, len)
     struct d_info *di;
     const char *s;
     int len;
d563 15
a577 1
  struct d_comp *p;
d579 2
a580 4
  if (s == NULL || len == 0)
    return NULL;
  p = d_make_empty (di, D_COMP_NAME);
  if (p != NULL)
d582 16
a597 2
      p->u.s_name.s = s;
      p->u.s_name.len = len;
d599 11
a609 1
  return p;
d612 5
a616 1
/* Add a new builtin type component.  */
d618 5
a622 4
static struct d_comp *
d_make_builtin_type (di, type)
     struct d_info *di;
     const struct d_builtin_type_info *type;
d624 1
a624 1
  struct d_comp *p;
d626 2
a627 1
  if (type == NULL)
d629 4
a632 4
  p = d_make_empty (di, D_COMP_BUILTIN_TYPE);
  if (p != NULL)
    p->u.s_builtin.type = type;
  return p;
d635 2
a636 1
/* Add a new operator component.  */
d638 4
a641 4
static struct d_comp *
d_make_operator (di, op)
     struct d_info *di;
     const struct d_operator_info *op;
d643 2
a644 1
  struct d_comp *p;
d646 12
a657 4
  p = d_make_empty (di, D_COMP_OPERATOR);
  if (p != NULL)
    p->u.s_operator.op = op;
  return p;
d660 4
a663 1
/* Add a new extended operator component.  */
d665 2
a666 5
static struct d_comp *
d_make_extended_operator (di, args, name)
     struct d_info *di;
     int args;
     struct d_comp *name;
d668 10
a677 1
  struct d_comp *p;
d679 50
a728 7
  if (name == NULL)
    return NULL;
  p = d_make_empty (di, D_COMP_EXTENDED_OPERATOR);
  if (p != NULL)
    {
      p->u.s_extended_operator.args = args;
      p->u.s_extended_operator.name = name;
d730 2
a731 1
  return p;
d734 1
a734 1
/* Add a new constructor component.  */
d736 4
a739 5
static struct d_comp *
d_make_ctor (di, kind,  name)
     struct d_info *di;
     enum gnu_v3_ctor_kinds kind;
     struct d_comp *name;
d741 7
a747 1
  struct d_comp *p;
d749 19
a767 7
  if (name == NULL)
    return NULL;
  p = d_make_empty (di, D_COMP_CTOR);
  if (p != NULL)
    {
      p->u.s_ctor.kind = kind;
      p->u.s_ctor.name = name;
a768 1
  return p;
d771 3
a773 1
/* Add a new destructor component.  */
d775 4
a778 5
static struct d_comp *
d_make_dtor (di, kind, name)
     struct d_info *di;
     enum gnu_v3_dtor_kinds kind;
     struct d_comp *name;
d780 2
a781 1
  struct d_comp *p;
d783 2
a784 4
  if (name == NULL)
    return NULL;
  p = d_make_empty (di, D_COMP_DTOR);
  if (p != NULL)
d786 6
a791 2
      p->u.s_dtor.kind = kind;
      p->u.s_dtor.name = name;
a792 1
  return p;
d795 4
a798 1
/* Add a new template parameter.  */
d800 3
a802 4
static struct d_comp *
d_make_template_param (di, i)
     struct d_info *di;
     long i;
d804 1
a804 6
  struct d_comp *p;

  p = d_make_empty (di, D_COMP_TEMPLATE_PARAM);
  if (p != NULL)
    p->u.s_number.number = i;
  return p;
d807 3
a809 1
/* Add a new standard substitution component.  */
d811 2
a812 3
static struct d_comp *
d_make_sub (di, name)
     struct d_info *di;
d814 1
d816 24
a839 1
  struct d_comp *p;
d841 1
a841 4
  p = d_make_empty (di, D_COMP_SUB_STD);
  if (p != NULL)
    p->u.s_string.string = name;
  return p;
d844 2
a845 1
/* <mangled-name> ::= _Z <encoding>
d847 6
a852 1
   TOP_LEVEL is non-zero when called at the top level.  */
d854 112
a965 4
static struct d_comp *
d_mangled_name (di, top_level)
     struct d_info *di;
     int top_level;
d967 1
a967 6
  if (d_next_char (di) != '_')
    return NULL;
  if (d_next_char (di) != 'Z')
    return NULL;
  return d_encoding (di, top_level);
}
d969 6
a974 16
/* Return whether a function should have a return type.  The argument
   is the function name, which may be qualified in various ways.  The
   rules are that template functions have return types with some
   exceptions, function types which are not part of a function name
   mangling have return types with some exceptions, and non-template
   function names do not have return types.  The exceptions are that
   constructors, destructors, and conversion operators do not have
   return types.  */

static int
has_return_type (dc)
     struct d_comp *dc;
{
  if (dc == NULL)
    return 0;
  switch (dc->type)
d976 4
a979 8
    default:
      return 0;
    case D_COMP_TEMPLATE:
      return ! is_ctor_dtor_or_conversion (d_left (dc));
    case D_COMP_RESTRICT_THIS:
    case D_COMP_VOLATILE_THIS:
    case D_COMP_CONST_THIS:
      return has_return_type (d_left (dc));
d983 1
a983 2
/* Return whether a name is a constructor, a destructor, or a
   conversion operator.  */
d985 5
a989 3
static int
is_ctor_dtor_or_conversion (dc)
     struct d_comp *dc;
d991 5
a995 13
  if (dc == NULL)
    return 0;
  switch (dc->type)
    {
    default:
      return 0;
    case D_COMP_QUAL_NAME:
      return is_ctor_dtor_or_conversion (d_right (dc));
    case D_COMP_CTOR:
    case D_COMP_DTOR:
    case D_COMP_CAST:
      return 1;
    }
d998 9
a1006 13
/* <encoding> ::= <(function) name> <bare-function-type>
              ::= <(data) name>
              ::= <special-name>

   TOP_LEVEL is non-zero when called at the top level, in which case
   if DMGL_PARAMS is not set we do not demangle the function
   parameters.  We only set this at the top level, because otherwise
   we would not correctly demangle names in local scopes.  */

static struct d_comp *
d_encoding (di, top_level)
     struct d_info *di;
     int top_level;
d1008 10
a1017 1
  char peek = d_peek_char (di);
d1020 1
a1020 1
    return d_special_name (di);
d1023 2
a1024 3
      struct d_comp *dc;

      dc = d_name (di);
d1026 4
a1029 1
      if (dc != NULL && top_level && (di->options & DMGL_PARAMS) == 0)
d1031 10
a1040 8
	  /* Strip off any initial CV-qualifiers, as they really apply
	     to the `this' parameter, and they were not output by the
	     v2 demangler without DMGL_PARAMS.  */
	  while (dc->type == D_COMP_RESTRICT_THIS
		 || dc->type == D_COMP_VOLATILE_THIS
		 || dc->type == D_COMP_CONST_THIS)
	    dc = d_left (dc);
	  return dc;
d1042 1
d1044 5
a1048 6
      peek = d_peek_char (di);
      if (peek == '\0' || peek == 'E')
	return dc;
      return d_make_comp (di, D_COMP_TYPED_NAME, dc,
			  d_bare_function_type (di, has_return_type (dc)));
    }
d1051 1
a1051 4
/* <name> ::= <nested-name>
          ::= <unscoped-name>
          ::= <unscoped-template-name> <template-args>
          ::= <local-name>
d1053 4
a1056 2
   <unscoped-name> ::= <unqualified-name>
                   ::= St <unqualified-name>
d1058 6
a1063 3
   <unscoped-template-name> ::= <unscoped-name>
                            ::= <substitution>
*/
d1065 4
a1068 3
static struct d_comp *
d_name (di)
     struct d_info *di;
d1070 11
a1080 2
  char peek = d_peek_char (di);
  struct d_comp *dc;
d1085 3
a1087 1
      return d_nested_name (di);
d1090 3
a1092 1
      return d_local_name (di);
d1095 33
a1127 2
      {
	int subst;
d1129 6
a1134 12
	if (d_peek_next_char (di) != 't')
	  {
	    dc = d_substitution (di);
	    subst = 1;
	  }
	else
	  {
	    d_advance (di, 2);
	    dc = d_make_comp (di, D_COMP_QUAL_NAME, d_make_name (di, "std", 3),
			      d_unqualified_name (di));
	    subst = 0;
	  }
d1136 5
a1140 19
	if (d_peek_char (di) != 'I')
	  {
	    /* The grammar does not permit this case to occur if we
	       called d_substitution() above (i.e., subst == 1).  We
	       don't bother to check.  */
	  }
	else
	  {
	    /* This is <template-args>, which means that we just saw
	       <unscoped-template-name>, which is a substitution
	       candidate if we didn't just get it from a
	       substitution.  */
	    if (! subst)
	      {
		if (! d_add_substitution (di, dc))
		  return NULL;
	      }
	    dc = d_make_comp (di, D_COMP_TEMPLATE, dc, d_template_args (di));
	  }
d1142 2
a1143 2
	return dc;
      }
d1145 1
a1145 13
    default:
      dc = d_unqualified_name (di);
      if (d_peek_char (di) == 'I')
	{
	  /* This is <template-args>, which means that we just saw
	     <unscoped-template-name>, which is a substitution
	     candidate.  */
	  if (! d_add_substitution (di, dc))
	    return NULL;
	  dc = d_make_comp (di, D_COMP_TEMPLATE, dc, d_template_args (di));
	}
      return dc;
    }
d1148 3
a1150 3
/* <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E
                 ::= N [<CV-qualifiers>] <template-prefix> <template-args> E
*/
d1152 4
a1155 3
static struct d_comp *
d_nested_name (di)
     struct d_info *di;
d1157 1
a1157 2
  struct d_comp *ret;
  struct d_comp **pret;
d1159 1
a1159 2
  if (d_next_char (di) != 'N')
    return NULL;
d1161 1
a1161 3
  pret = d_cv_qualifiers (di, &ret, 1);
  if (pret == NULL)
    return NULL;
d1163 5
a1167 9
  *pret = d_prefix (di);
  if (*pret == NULL)
    return NULL;

  if (d_next_char (di) != 'E')
    return NULL;

  return ret;
}
d1169 56
a1224 10
/* <prefix> ::= <prefix> <unqualified-name>
            ::= <template-prefix> <template-args>
            ::= <template-param>
            ::=
            ::= <substitution>

   <template-prefix> ::= <prefix> <(template) unqualified-name>
                     ::= <template-param>
                     ::= <substitution>
*/
d1226 1
a1226 5
static struct d_comp *
d_prefix (di)
     struct d_info *di;
{
  struct d_comp *ret = NULL;
a1230 2
      enum d_comp_type comb_type;
      struct d_comp *dc;
d1232 24
a1255 3
      peek = d_peek_char (di);
      if (peek == '\0')
	return NULL;
d1257 14
a1270 12
      /* The older code accepts a <local-name> here, but I don't see
	 that in the grammar.  The older code does not accept a
	 <template-param> here.  */

      comb_type = D_COMP_QUAL_NAME;
      if (IS_DIGIT (peek)
	  || IS_LOWER (peek)
	  || peek == 'C'
	  || peek == 'D')
	dc = d_unqualified_name (di);
      else if (peek == 'S')
	dc = d_substitution (di);
d1273 10
a1282 4
	  if (ret == NULL)
	    return NULL;
	  comb_type = D_COMP_TEMPLATE;
	  dc = d_template_args (di);
a1283 2
      else if (peek == 'T')
	dc = d_template_param (di);
d1285 2
a1286 1
	return ret;
d1288 1
a1288 6
	return NULL;

      if (ret == NULL)
	ret = dc;
      else
	ret = d_make_comp (di, comb_type, ret, dc);
d1290 4
a1293 5
      if (peek != 'S' && d_peek_char (di) != 'E')
	{
	  if (! d_add_substitution (di, ret))
	    return NULL;
	}
d1297 5
a1301 21
/* <unqualified-name> ::= <operator-name>
                      ::= <ctor-dtor-name>
                      ::= <source-name>
*/

static struct d_comp *
d_unqualified_name (di)
     struct d_info *di;
{
  char peek;

  peek = d_peek_char (di);
  if (IS_DIGIT (peek))
    return d_source_name (di);
  else if (IS_LOWER (peek))
    return d_operator_name (di);
  else if (peek == 'C' || peek == 'D')
    return d_ctor_dtor_name (di);
  else
    return NULL;
}
d1303 3
a1305 1
/* <source-name> ::= <(positive length) number> <identifier>  */
d1307 4
a1310 3
static struct d_comp *
d_source_name (di)
     struct d_info *di;
d1312 1
a1312 10
  long len;
  struct d_comp *ret;

  len = d_number (di);
  if (len <= 0)
    return NULL;
  ret = d_identifier (di, len);
  di->last_name = ret;
  return ret;
}
d1314 1
a1314 1
/* number ::= [n] <(non-negative decimal integer)>  */
d1316 3
a1318 7
static long
d_number (di)
     struct d_info *di;
{
  int sign;
  char peek;
  long ret;
d1320 3
a1322 3
  sign = 1;
  peek = d_peek_char (di);
  if (peek == 'n')
d1324 5
a1328 4
      sign = -1;
      d_advance (di, 1);
      peek = d_peek_char (di);
    }
d1330 1
a1330 8
  ret = 0;
  while (1)
    {
      if (! IS_DIGIT (peek))
	return ret * sign;
      ret = ret * 10 + peek - '0';
      d_advance (di, 1);
      peek = d_peek_char (di);
d1332 1
a1332 20
}

/* identifier ::= <(unqualified source code identifier)>  */

static struct d_comp *
d_identifier (di, len)
     struct d_info *di;
     int len;
{
  const char *name;

  name = d_str (di);
  d_advance (di, len);

  /* Look for something which looks like a gcc encoding of an
     anonymous namespace, and replace it with a more user friendly
     name.  */
  if (len >= (int) ANONYMOUS_NAMESPACE_PREFIX_LEN + 2
      && memcmp (name, ANONYMOUS_NAMESPACE_PREFIX,
		 ANONYMOUS_NAMESPACE_PREFIX_LEN) == 0)
d1334 3
a1336 1
      const char *s;
d1338 1
a1338 5
      s = name + ANONYMOUS_NAMESPACE_PREFIX_LEN;
      if ((*s == '.' || *s == '_' || *s == '$')
	  && s[1] == 'N')
	return d_make_name (di, "(anonymous namespace)",
			    sizeof "(anonymous namespace)" - 1);
d1340 2
d1343 1
a1343 1
  return d_make_name (di, name, len);
d1346 1
a1346 4
/* operator_name ::= many different two character encodings.
                 ::= cv <type>
                 ::= v <digit> <source-name>
*/
d1348 1
a1348 52
static const struct d_operator_info d_operators[] =
{
  { "aN", "&=",        2 },
  { "aS", "=",         2 },
  { "aa", "&&",        2 },
  { "ad", "&",         1 },
  { "an", "&",         2 },
  { "cl", "()",        0 },
  { "cm", ",",         2 },
  { "co", "~",         1 },
  { "dV", "/=",        2 },
  { "da", "delete[]",  1 },
  { "de", "*",         1 },
  { "dl", "delete",    1 },
  { "dv", "/",         2 },
  { "eO", "^=",        2 },
  { "eo", "^",         2 },
  { "eq", "==",        2 },
  { "ge", ">=",        2 },
  { "gt", ">",         2 },
  { "ix", "[]",        2 },
  { "lS", "<<=",       2 },
  { "le", "<=",        2 },
  { "ls", "<<",        2 },
  { "lt", "<",         2 },
  { "mI", "-=",        2 },
  { "mL", "*=",        2 },
  { "mi", "-",         2 },
  { "ml", "*",         2 },
  { "mm", "--",        1 },
  { "na", "new[]",     1 },
  { "ne", "!=",        2 },
  { "ng", "-",         1 },
  { "nt", "!",         1 },
  { "nw", "new",       1 },
  { "oR", "|=",        2 },
  { "oo", "||",        2 },
  { "or", "|",         2 },
  { "pL", "+=",        2 },
  { "pl", "+",         2 },
  { "pm", "->*",       2 },
  { "pp", "++",        1 },
  { "ps", "+",         1 },
  { "pt", "->",        2 },
  { "qu", "?",         3 },
  { "rM", "%=",        2 },
  { "rS", ">>=",       2 },
  { "rm", "%",         2 },
  { "rs", ">>",        2 },
  { "st", "sizeof ",   1 },
  { "sz", "sizeof ",   1 }
};
d1350 3
a1352 3
static struct d_comp *
d_operator_name (di)
     struct d_info *di;
d1354 1
a1354 2
  char c1;
  char c2;
d1356 1
a1356 10
  c1 = d_next_char (di);
  c2 = d_next_char (di);
  if (c1 == 'v' && IS_DIGIT (c2))
    return d_make_extended_operator (di, c2 - '0', d_source_name (di));
  else if (c1 == 'c' && c2 == 'v')
    return d_make_comp (di, D_COMP_CAST, d_type (di), NULL);
  else
    {
      int low = 0;
      int high = sizeof (d_operators) / sizeof (d_operators[0]);
d1358 4
a1361 4
      while (1)
	{
	  int i;
	  const struct d_operator_info *p;
d1363 4
a1366 2
	  i = low + (high - low) / 2;
	  p = d_operators + i;
d1368 2
a1369 2
	  if (c1 == p->code[0] && c2 == p->code[1])
	    return d_make_operator (di, p);
d1371 1
a1371 8
	  if (c1 < p->code[0] || (c1 == p->code[0] && c2 < p->code[1]))
	    high = i;
	  else
	    low = i + 1;
	  if (low == high)
	    return NULL;
	}
    }
d1374 9
a1382 13
/* <special-name> ::= TV <type>
                  ::= TT <type>
                  ::= TI <type>
                  ::= TS <type>
                  ::= GV <(object) name>
                  ::= T <call-offset> <(base) encoding>
                  ::= Tc <call-offset> <call-offset> <(base) encoding>
   Also g++ extensions:
                  ::= TC <type> <(offset) number> _ <(base) type>
                  ::= TF <type>
                  ::= TJ <type>
                  ::= GR <name>
*/
d1384 6
a1389 3
static struct d_comp *
d_special_name (di)
     struct d_info *di;
d1391 1
a1391 1
  char c;
d1393 4
a1396 13
  c = d_next_char (di);
  if (c == 'T')
    {
      switch (d_next_char (di))
	{
	case 'V':
	  return d_make_comp (di, D_COMP_VTABLE, d_type (di), NULL);
	case 'T':
	  return d_make_comp (di, D_COMP_VTT, d_type (di), NULL);
	case 'I':
	  return d_make_comp (di, D_COMP_TYPEINFO, d_type (di), NULL);
	case 'S':
	  return d_make_comp (di, D_COMP_TYPEINFO_NAME, d_type (di), NULL);
d1398 3
a1400 4
	case 'h':
	  if (! d_call_offset (di, 'h'))
	    return NULL;
	  return d_make_comp (di, D_COMP_THUNK, d_encoding (di, 0), NULL);
d1402 2
a1403 5
	case 'v':
	  if (! d_call_offset (di, 'v'))
	    return NULL;
	  return d_make_comp (di, D_COMP_VIRTUAL_THUNK, d_encoding (di, 0),
			      NULL);
d1405 6
a1410 7
	case 'c':
	  if (! d_call_offset (di, '\0'))
	    return NULL;
	  if (! d_call_offset (di, '\0'))
	    return NULL;
	  return d_make_comp (di, D_COMP_COVARIANT_THUNK, d_encoding (di, 0),
			      NULL);
d1412 8
a1419 18
	case 'C':
	  {
	    struct d_comp *derived_type;
	    long offset;
	    struct d_comp *base_type;

	    derived_type = d_type (di);
	    offset = d_number (di);
	    if (offset < 0)
	      return NULL;
	    if (d_next_char (di) != '_')
	      return NULL;
	    base_type = d_type (di);
	    /* We don't display the offset.  FIXME: We should display
	       it in verbose mode.  */
	    return d_make_comp (di, D_COMP_CONSTRUCTION_VTABLE, base_type,
				derived_type);
	  }
d1421 2
a1422 4
	case 'F':
	  return d_make_comp (di, D_COMP_TYPEINFO_FN, d_type (di), NULL);
	case 'J':
	  return d_make_comp (di, D_COMP_JAVA_CLASS, d_type (di), NULL);
d1424 9
a1432 3
	default:
	  return NULL;
	}
d1434 3
a1436 1
  else if (c == 'G')
d1438 3
a1440 1
      switch (d_next_char (di))
d1442 3
a1444 8
	case 'V':
	  return d_make_comp (di, D_COMP_GUARD, d_name (di), NULL);

	case 'R':
	  return d_make_comp (di, D_COMP_REFTEMP, d_name (di), NULL);

	default:
	  return NULL;
d1446 3
d1450 2
a1451 2
  else
    return NULL;
d1454 2
a1455 2
/* <call-offset> ::= h <nv-offset> _
                 ::= v <v-offset> _
d1457 7
a1463 1
   <nv-offset> ::= <(offset) number>
d1465 3
a1467 1
   <v-offset> ::= <(offset) number> _ <(virtual offset) number>
d1469 6
a1474 2
   The C parameter, if not '\0', is a character we just read which is
   the start of the <call-offset>.
d1476 32
a1507 2
   We don't display the offset information anywhere.  FIXME: We should
   display it in verbose mode.  */
d1509 3
a1511 7
static int
d_call_offset (di, c)
     struct d_info *di;
     int c;
{
  long offset;
  long virtual_offset;
d1513 21
a1533 11
  if (c == '\0')
    c = d_next_char (di);

  if (c == 'h')
    offset = d_number (di);
  else if (c == 'v')
    {
      offset = d_number (di);
      if (d_next_char (di) != '_')
	return 0;
      virtual_offset = d_number (di);
a1534 2
  else
    return 0;
d1536 2
a1537 2
  if (d_next_char (di) != '_')
    return 0;
d1539 76
a1614 2
  return 1;
}
d1616 94
a1709 7
/* <ctor-dtor-name> ::= C1
                    ::= C2
                    ::= C3
                    ::= D0
                    ::= D1
                    ::= D2
*/
d1711 2
a1712 5
static struct d_comp *
d_ctor_dtor_name (di)
     struct d_info *di;
{
  switch (d_next_char (di))
d1714 3
a1716 3
    case 'C':
      {
	enum gnu_v3_ctor_kinds kind;
d1718 7
a1724 16
	switch (d_next_char (di))
	  {
	  case '1':
	    kind = gnu_v3_complete_object_ctor;
	    break;
	  case '2':
	    kind = gnu_v3_base_object_ctor;
	    break;
	  case '3':
	    kind = gnu_v3_complete_object_allocating_ctor;
	    break;
	  default:
	    return NULL;
	  }
	return d_make_ctor (di, kind, di->last_name);
      }
d1726 2
a1727 3
    case 'D':
      {
	enum gnu_v3_dtor_kinds kind;
d1729 9
a1737 19
	switch (d_next_char (di))
	  {
	  case '0':
	    kind = gnu_v3_deleting_dtor;
	    break;
	  case '1':
	    kind = gnu_v3_complete_object_dtor;
	    break;
	  case '2':
	    kind = gnu_v3_base_object_dtor;
	    break;
	  default:
	    return NULL;
	  }
	return d_make_dtor (di, kind, di->last_name);
      }

    default:
      return NULL;
d1741 1
a1741 14
/* <type> ::= <builtin-type>
          ::= <function-type>
          ::= <class-enum-type>
          ::= <array-type>
          ::= <pointer-to-member-type>
          ::= <template-param>
          ::= <template-template-param> <template-args>
          ::= <substitution>
          ::= <CV-qualifiers> <type>
          ::= P <type>
          ::= R <type>
          ::= C <type>
          ::= G <type>
          ::= U <source-name> <type>
d1743 1
a1743 3
   <builtin-type> ::= various one letter codes
                  ::= u <source-name>
*/
d1745 3
a1747 1
static const struct d_builtin_type_info d_builtin_types[26] =
d1749 2
a1750 27
  /* a */ { "signed char",	"signed char",		D_PRINT_INT },
  /* b */ { "bool",		"boolean",		D_PRINT_BOOL },
  /* c */ { "char",		"byte",			D_PRINT_INT },
  /* d */ { "double",		"double",		D_PRINT_DEFAULT },
  /* e */ { "long double",	"long double",		D_PRINT_DEFAULT },
  /* f */ { "float",		"float",		D_PRINT_DEFAULT },
  /* g */ { "__float128",	"__float128",		D_PRINT_DEFAULT },
  /* h */ { "unsigned char",	"unsigned char",	D_PRINT_INT },
  /* i */ { "int",		"int",			D_PRINT_INT },
  /* j */ { "unsigned int",	"unsigned",		D_PRINT_INT },
  /* k */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* l */ { "long",		"long",			D_PRINT_LONG },
  /* m */ { "unsigned long",	"unsigned long",	D_PRINT_LONG },
  /* n */ { "__int128",		"__int128",		D_PRINT_DEFAULT },
  /* o */ { "unsigned __int128", "unsigned __int128",	D_PRINT_DEFAULT },
  /* p */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* q */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* r */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* s */ { "short",		"short",		D_PRINT_INT },
  /* t */ { "unsigned short",	"unsigned short",	D_PRINT_INT },
  /* u */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* v */ { "void",		"void",			D_PRINT_VOID },
  /* w */ { "wchar_t",		"char",			D_PRINT_INT },
  /* x */ { "long long",	"long",			D_PRINT_DEFAULT },
  /* y */ { "unsigned long long", "unsigned long long",	D_PRINT_DEFAULT },
  /* z */ { "...",		"...",			D_PRINT_DEFAULT },
};
d1752 1
a1752 7
static struct d_comp *
d_type (di)
     struct d_info *di;
{
  char peek;
  struct d_comp *ret;
  int can_subst;
d1754 5
a1758 14
  /* The ABI specifies that when CV-qualifiers are used, the base type
     is substitutable, and the fully qualified type is substitutable,
     but the base type with a strict subset of the CV-qualifiers is
     not substitutable.  The natural recursive implementation of the
     CV-qualifiers would cause subsets to be substitutable, so instead
     we pull them all off now.

     FIXME: The ABI says that order-insensitive vendor qualifiers
     should be handled in the same way, but we have no way to tell
     which vendor qualifiers are order-insensitive and which are
     order-sensitive.  So we just assume that they are all
     order-sensitive.  g++ 3.4 supports only one vendor qualifier,
     __vector, and it treats it as order-sensitive when mangling
     names.  */
d1760 2
a1761 2
  peek = d_peek_char (di);
  if (peek == 'r' || peek == 'V' || peek == 'K')
d1763 6
a1768 1
      struct d_comp **pret;
d1770 5
a1774 8
      pret = d_cv_qualifiers (di, &ret, 0);
      if (pret == NULL)
	return NULL;
      *pret = d_type (di);
      if (! d_add_substitution (di, ret))
	return NULL;
      return ret;
    }
d1776 1
a1776 1
  can_subst = 1;
d1778 2
a1779 10
  switch (peek)
    {
    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':
    case 'h': case 'i': case 'j':           case 'l': case 'm': case 'n':
    case 'o':                               case 's': case 't':
    case 'v': case 'w': case 'x': case 'y': case 'z':
      ret = d_make_builtin_type (di, &d_builtin_types[peek - 'a']);
      can_subst = 0;
      d_advance (di, 1);
      break;
d1781 6
a1786 4
    case 'u':
      d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_VENDOR_TYPE, d_source_name (di), NULL);
      break;
d1788 1
a1788 3
    case 'F':
      ret = d_function_type (di);
      break;
d1790 5
a1794 6
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    case 'N':
    case 'Z':
      ret = d_class_enum_type (di);
      break;
d1796 11
a1806 3
    case 'A':
      ret = d_array_type (di);
      break;
d1808 2
a1809 3
    case 'M':
      ret = d_pointer_to_member_type (di);
      break;
d1811 5
a1815 12
    case 'T':
      ret = d_template_param (di);
      if (d_peek_char (di) == 'I')
	{
	  /* This is <template-template-param> <template-args>.  The
	     <template-template-param> part is a substitution
	     candidate.  */
	  if (! d_add_substitution (di, ret))
	    return NULL;
	  ret = d_make_comp (di, D_COMP_TEMPLATE, ret, d_template_args (di));
	}
      break;
d1817 9
a1825 5
    case 'S':
      /* If this is a special substitution, then it is the start of
	 <class-enum-type>.  */
      {
	char peek_next;
d1827 2
a1828 26
	peek_next = d_peek_next_char (di);
	if (IS_DIGIT (peek_next)
	    || peek_next == '_'
	    || IS_UPPER (peek_next))
	  {
	    ret = d_substitution (di);
	    /* The substituted name may have been a template name and
	       may be followed by tepmlate args.  */
	    if (d_peek_char (di) == 'I')
	      ret = d_make_comp (di, D_COMP_TEMPLATE, ret,
				 d_template_args (di));
	    else
	      can_subst = 0;
	  }
	else
	  {
	    ret = d_class_enum_type (di);
	    /* If the substitution was a complete type, then it is not
	       a new substitution candidate.  However, if the
	       substitution was followed by template arguments, then
	       the whole thing is a substitution candidate.  */
	    if (ret != NULL && ret->type == D_COMP_SUB_STD)
	      can_subst = 0;
	  }
      }
      break;
d1830 1
a1830 4
    case 'P':
      d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_POINTER, d_type (di), NULL);
      break;
d1832 2
a1833 4
    case 'R':
      d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_REFERENCE, d_type (di), NULL);
      break;
d1835 5
a1839 4
    case 'C':
      d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_COMPLEX, d_type (di), NULL);
      break;
d1841 8
a1848 3
    case 'G':
      d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_IMAGINARY, d_type (di), NULL);
d1851 6
a1856 4
    case 'U':
      d_advance (di, 1);
      ret = d_source_name (di);
      ret = d_make_comp (di, D_COMP_VENDOR_TYPE_QUAL, d_type (di), ret);
d1860 1
a1860 1
      return NULL;
d1863 2
a1864 5
  if (can_subst)
    {
      if (! d_add_substitution (di, ret))
	return NULL;
    }
d1866 1
a1866 2
  return ret;
}
d1868 5
a1872 1
/* <CV-qualifiers> ::= [r] [V] [K]  */
d1874 1
a1874 7
static struct d_comp **
d_cv_qualifiers (di, pret, member_fn)
     struct d_info *di;
     struct d_comp **pret;
     int member_fn;
{
  char peek;
d1876 2
a1877 4
  peek = d_peek_char (di);
  while (peek == 'r' || peek == 'V' || peek == 'K')
    {
      enum d_comp_type t;
d1879 4
a1882 7
      d_advance (di, 1);
      if (peek == 'r')
	t = member_fn ? D_COMP_RESTRICT_THIS: D_COMP_RESTRICT;
      else if (peek == 'V')
	t = member_fn ? D_COMP_VOLATILE_THIS : D_COMP_VOLATILE;
      else
	t = member_fn ? D_COMP_CONST_THIS: D_COMP_CONST;
d1884 1
a1884 4
      *pret = d_make_comp (di, t, NULL, NULL);
      if (*pret == NULL)
	return NULL;
      pret = &d_left (*pret);
d1886 2
a1887 2
      peek = d_peek_char (di);
    }
d1889 1
a1889 2
  return pret;
}
d1891 4
a1894 1
/* <function-type> ::= F [Y] <bare-function-type> E  */
d1896 3
a1898 3
static struct d_comp *
d_function_type (di)
     struct d_info *di;
d1900 3
a1902 17
  struct d_comp *ret;

  if (d_next_char (di) != 'F')
    return NULL;
  if (d_peek_char (di) == 'Y')
    {
      /* Function has C linkage.  We don't print this information.
	 FIXME: We should print it in verbose mode.  */
      d_advance (di, 1);
    }
  ret = d_bare_function_type (di, 1);
  if (d_next_char (di) != 'E')
    return NULL;
  return ret;
}

/* <bare-function-type> ::= <type>+  */
d1904 1
a1904 8
static struct d_comp *
d_bare_function_type (di, has_return_type)
     struct d_info *di;
     int has_return_type;
{
  struct d_comp *return_type;
  struct d_comp *tl;
  struct d_comp **ptl;
d1906 1
a1906 4
  return_type = NULL;
  tl = NULL;
  ptl = &tl;
  while (1)
d1908 10
a1917 2
      char peek;
      struct d_comp *type;
d1919 9
a1927 17
      peek = d_peek_char (di);
      if (peek == '\0' || peek == 'E')
	break;
      type = d_type (di);
      if (type == NULL)
	return NULL;
      if (has_return_type)
	{
	  return_type = type;
	  has_return_type = 0;
	}
      else
	{
	  *ptl = d_make_comp (di, D_COMP_ARGLIST, type, NULL);
	  if (*ptl == NULL)
	    return NULL;
	  ptl = &d_right (*ptl);
d1930 3
d1934 2
a1935 5
  /* There should be at least one parameter type besides the optional
     return type.  A function which takes no arguments will have a
     single parameter type void.  */
  if (tl == NULL)
    return NULL;
d1937 8
a1944 5
  /* If we have a single parameter type void, omit it.  */
  if (d_right (tl) == NULL
      && d_left (tl)->type == D_COMP_BUILTIN_TYPE
      && d_left (tl)->u.s_builtin.type->print == D_PRINT_VOID)
    tl = NULL;
d1946 6
a1951 2
  return d_make_comp (di, D_COMP_FUNCTION_TYPE, return_type, tl);
}
d1953 6
a1958 1
/* <class-enum-type> ::= <name>  */
d1960 6
a1965 6
static struct d_comp *
d_class_enum_type (di)
     struct d_info *di;
{
  return d_name (di);
}
d1967 6
a1972 3
/* <array-type> ::= A <(positive dimension) number> _ <(element) type>
                ::= A [<(dimension) expression>] _ <(element) type>
*/
d1974 6
a1979 6
static struct d_comp *
d_array_type (di)
     struct d_info *di;
{
  char peek;
  struct d_comp *dim;
d1981 11
a1991 2
  if (d_next_char (di) != 'A')
    return NULL;
d1993 11
a2003 6
  peek = d_peek_char (di);
  if (peek == '_')
    dim = NULL;
  else if (IS_DIGIT (peek))
    {
      const char *s;
d2005 10
a2014 17
      s = d_str (di);
      do
	{
	  d_advance (di, 1);
	  peek = d_peek_char (di);
	}
      while (IS_DIGIT (peek));
      dim = d_make_name (di, s, d_str (di) - s);
      if (dim == NULL)
	return NULL;
    }
  else
    {
      dim = d_expression (di);
      if (dim == NULL)
	return NULL;
    }
d2016 5
a2020 2
  if (d_next_char (di) != '_')
    return NULL;
d2022 2
a2023 2
  return d_make_comp (di, D_COMP_ARRAY_TYPE, dim, d_type (di));
}
d2025 26
a2050 1
/* <pointer-to-member-type> ::= M <(class) type> <(member) type>  */
d2052 12
a2063 7
static struct d_comp *
d_pointer_to_member_type (di)
     struct d_info *di;
{
  struct d_comp *cl;
  struct d_comp *mem;
  struct d_comp **pmem;
d2065 6
a2070 22
  if (d_next_char (di) != 'M')
    return NULL;

  cl = d_type (di);

  /* The ABI specifies that any type can be a substitution source, and
     that M is followed by two types, and that when a CV-qualified
     type is seen both the base type and the CV-qualified types are
     substitution sources.  The ABI also specifies that for a pointer
     to a CV-qualified member function, the qualifiers are attached to
     the second type.  Given the grammar, a plain reading of the ABI
     suggests that both the CV-qualified member function and the
     non-qualified member function are substitution sources.  However,
     g++ does not work that way.  g++ treats only the CV-qualified
     member function as a substitution source.  FIXME.  So to work
     with g++, we need to pull off the CV-qualifiers here, in order to
     avoid calling add_substitution() in d_type().  */

  pmem = d_cv_qualifiers (di, &mem, 1);
  if (pmem == NULL)
    return NULL;
  *pmem = d_type (di);
d2072 1
a2072 1
  return d_make_comp (di, D_COMP_PTRMEM_TYPE, cl, mem);
d2075 13
a2087 7
/* <template-param> ::= T_
                    ::= T <(parameter-2 non-negative) number> _
*/

static struct d_comp *
d_template_param (di)
     struct d_info *di;
d2089 42
a2130 13
  long param;

  if (d_next_char (di) != 'T')
    return NULL;

  if (d_peek_char (di) == '_')
    param = 0;
  else
    {
      param = d_number (di);
      if (param < 0)
	return NULL;
      param += 1;
d2132 1
a2132 28

  if (d_next_char (di) != '_')
    return NULL;

  return d_make_template_param (di, param);
}

/* <template-args> ::= I <template-arg>+ E  */

static struct d_comp *
d_template_args (di)
     struct d_info *di;
{
  struct d_comp *hold_last_name;
  struct d_comp *al;
  struct d_comp **pal;

  /* Preserve the last name we saw--don't let the template arguments
     clobber it, as that would give us the wrong name for a subsequent
     constructor or destructor.  */
  hold_last_name = di->last_name;

  if (d_next_char (di) != 'I')
    return NULL;

  al = NULL;
  pal = &al;
  while (1)
d2134 8
a2141 12
      struct d_comp *a;

      a = d_template_arg (di);
      if (a == NULL)
	return NULL;

      *pal = d_make_comp (di, D_COMP_TEMPLATE_ARGLIST, a, NULL);
      if (*pal == NULL)
	return NULL;
      pal = &d_right (*pal);

      if (d_peek_char (di) == 'E')
d2143 5
a2147 1
	  d_advance (di, 1);
d2150 7
d2158 2
d2161 1
a2161 3
  di->last_name = hold_last_name;

  return al;
d2164 56
a2219 4
/* <template-arg> ::= <type>
                  ::= X <expression> E
                  ::= <expr-primary>
*/
d2221 13
a2233 5
static struct d_comp *
d_template_arg (di)
     struct d_info *di;
{
  struct d_comp *ret;
d2235 1
a2235 1
  switch (d_peek_char (di))
d2237 48
a2284 6
    case 'X':
      d_advance (di, 1);
      ret = d_expression (di);
      if (d_next_char (di) != 'E')
	return NULL;
      return ret;
d2286 2
a2287 2
    case 'L':
      return d_expr_primary (di);
d2289 1
a2289 2
    default:
      return d_type (di);
d2291 1
a2291 1
}
d2293 20
a2312 9
/* <expression> ::= <(unary) operator-name> <expression>
                ::= <(binary) operator-name> <expression> <expression>
                ::= <(trinary) operator-name> <expression> <expression> <expression>
                ::= st <type>
                ::= <template-param>
                ::= sr <type> <unqualified-name>
                ::= sr <type> <unqualified-name> <template-args>
                ::= <expr-primary>
*/
d2314 5
a2318 5
static struct d_comp *
d_expression (di)
     struct d_info *di;
{
  char peek;
d2320 67
a2386 19
  peek = d_peek_char (di);
  if (peek == 'L')
    return d_expr_primary (di);
  else if (peek == 'T')
    return d_template_param (di);
  else if (peek == 's' && d_peek_next_char (di) == 'r')
    {
      struct d_comp *type;
      struct d_comp *name;

      d_advance (di, 2);
      type = d_type (di);
      name = d_unqualified_name (di);
      if (d_peek_char (di) != 'I')
	return d_make_comp (di, D_COMP_QUAL_NAME, type, name);
      else
	return d_make_comp (di, D_COMP_QUAL_NAME, type,
			    d_make_comp (di, D_COMP_TEMPLATE, name,
					 d_template_args (di)));
d2389 32
a2420 3
    {
      struct d_comp *op;
      int args;
d2422 4
a2425 3
      op = d_operator_name (di);
      if (op == NULL)
	return NULL;
d2427 2
a2428 3
      if (op->type == D_COMP_OPERATOR
	  && strcmp (op->u.s_operator.op->code, "st") == 0)
	return d_make_comp (di, D_COMP_UNARY, op, d_type (di));
d2430 3
a2432 14
      switch (op->type)
	{
	default:
	  return NULL;
	case D_COMP_OPERATOR:
	  args = op->u.s_operator.op->args;
	  break;
	case D_COMP_EXTENDED_OPERATOR:
	  args = op->u.s_extended_operator.args;
	  break;
	case D_COMP_CAST:
	  args = 1;
	  break;
	}
d2434 10
a2443 5
      switch (args)
	{
	case 1:
	  return d_make_comp (di, D_COMP_UNARY, op, d_expression (di));
	case 2:
d2445 13
a2457 1
	    struct d_comp *left;
d2459 20
a2478 4
	    left = d_expression (di);
	    return d_make_comp (di, D_COMP_BINARY, op,
				d_make_comp (di, D_COMP_BINARY_ARGS, left,
					     d_expression (di)));
d2480 1
a2480 1
	case 3:
d2482 23
a2504 11
	    struct d_comp *first;
	    struct d_comp *second;

	    first = d_expression (di);
	    second = d_expression (di);
	    return d_make_comp (di, D_COMP_TRINARY, op,
				d_make_comp (di, D_COMP_TRINARY_ARG1, first,
					     d_make_comp (di,
							  D_COMP_TRINARY_ARG2,
							  second,
							  d_expression (di))));
a2505 5
	default:
	  return NULL;
	}
    }
}
d2507 1
a2507 4
/* <expr-primary> ::= L <type> <(value) number> E
                  ::= L <type> <(value) float> E
                  ::= L <mangled-name> E
*/
d2509 8
a2516 5
static struct d_comp *
d_expr_primary (di)
     struct d_info *di;
{
  struct d_comp *ret;
d2518 6
a2523 8
  if (d_next_char (di) != 'L')
    return NULL;
  if (d_peek_char (di) == '_')
    ret = d_mangled_name (di, 0);
  else
    {
      struct d_comp *type;
      const char *s;
d2525 6
a2530 1
      type = d_type (di);
d2532 7
a2538 21
      /* Rather than try to interpret the literal value, we just
	 collect it as a string.  Note that it's possible to have a
	 floating point literal here.  The ABI specifies that the
	 format of such literals is machine independent.  That's fine,
	 but what's not fine is that versions of g++ up to 3.2 with
	 -fabi-version=1 used upper case letters in the hex constant,
	 and dumped out gcc's internal representation.  That makes it
	 hard to tell where the constant ends, and hard to dump the
	 constant in any readable form anyhow.  We don't attempt to
	 handle these cases.  */

      s = d_str (di);
      while (d_peek_char (di) != 'E')
	d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_LITERAL, type,
			 d_make_name (di, s, d_str (di) - s));
    }
  if (d_next_char (di) != 'E')
    return NULL;
  return ret;
}
d2540 3
a2542 3
/* <local-name> ::= Z <(function) encoding> E <(entity) name> [<discriminator>]
                ::= Z <(function) encoding> E s [<discriminator>]
*/
d2544 45
a2588 5
static struct d_comp *
d_local_name (di)
     struct d_info *di;
{
  struct d_comp *function;
d2590 32
a2621 2
  if (d_next_char (di) != 'Z')
    return NULL;
d2623 1
a2623 1
  function = d_encoding (di, 0);
d2625 52
a2676 11
  if (d_next_char (di) != 'E')
    return NULL;

  if (d_peek_char (di) == 's')
    {
      d_advance (di, 1);
      if (! d_discriminator (di))
	return NULL;
      return d_make_comp (di, D_COMP_QUAL_NAME, function,
			  d_make_name (di, "string literal",
				       sizeof "string literal" - 1));
d2679 1
a2679 8
    {
      struct d_comp *name;

      name = d_name (di);
      if (! d_discriminator (di))
	return NULL;
      return d_make_comp (di, D_COMP_QUAL_NAME, function, name);
    }
d2682 3
a2684 4
/* <discriminator> ::= _ <(non-negative) number>

   We demangle the discriminator, but we don't print it out.  FIXME:
   We should print it out in verbose mode.  */
d2686 4
a2689 3
static int
d_discriminator (di)
     struct d_info *di;
d2691 1
a2691 1
  long discrim;
d2693 1
a2693 47
  if (d_peek_char (di) != '_')
    return 1;
  d_advance (di, 1);
  discrim = d_number (di);
  if (discrim < 0)
    return 0;
  return 1;
}

/* Add a new substitution.  */

static int
d_add_substitution (di, dc)
     struct d_info *di;
     struct d_comp *dc;
{
  if (dc == NULL)
    return 0;
  if (di->next_sub >= di->num_subs)
    return 0;
  di->subs[di->next_sub] = dc;
  ++di->next_sub;
  return 1;
}

/* <substitution> ::= S <seq-id> _
                  ::= S_
                  ::= St
                  ::= Sa
                  ::= Sb
                  ::= Ss
                  ::= Si
                  ::= So
                  ::= Sd
*/

static struct d_comp *
d_substitution (di)
     struct d_info *di;
{
  char c;

  if (d_next_char (di) != 'S')
    return NULL;

  c = d_next_char (di);
  if (c == '_' || IS_DIGIT (c) || IS_UPPER (c))
d2695 1
a2695 4
      int id;

      id = 0;
      if (c != '_')
d2697 6
a2702 11
	  do
	    {
	      if (IS_DIGIT (c))
		id = id * 36 + c - '0';
	      else if (IS_UPPER (c))
		id = id * 36 + c - 'A' + 10;
	      else
		return NULL;
	      c = d_next_char (di);
	    }
	  while (c != '_');
d2704 6
a2709 2
	  ++id;
	}
d2711 6
a2716 2
      if (id >= di->next_sub)
	return NULL;
a2717 26
      return di->subs[id];
    }
  else
    {
      switch (c)
	{
	case 't':
	  return d_make_sub (di, "std");
	case 'a':
	  di->last_name = d_make_sub (di, "allocator");
	  return d_make_sub (di, "std::allocator");
	case 'b':
	  di->last_name = d_make_sub (di, "basic_string");
	  return d_make_sub (di, "std::basic_string");
	case 's':
	  di->last_name = d_make_sub (di, "string");
	  return d_make_sub (di, "std::string");
	case 'i':
	  di->last_name = d_make_sub (di, "istream");
	  return d_make_sub (di, "std::istream");
	case 'o':
	  di->last_name = d_make_sub (di, "ostream");
	  return d_make_sub (di, "std::ostream");
	case 'd':
	  di->last_name = d_make_sub (di, "iostream");
	  return d_make_sub (di, "std::iostream");
d2719 1
a2719 1
	  return NULL;
d2721 2
d2726 7
a2732 1
/* Resize the print buffer.  */
d2734 4
a2737 4
static void
d_print_resize (dpi, add)
     struct d_print_info *dpi;
     size_t add;
d2739 3
a2741 6
  size_t need;

  if (dpi->buf == NULL)
    return;
  need = dpi->len + add;
  while (need > dpi->alc)
d2743 4
a2746 14
      size_t newalc;
      char *newbuf;

      newalc = dpi->alc * 2;
      newbuf = realloc (dpi->buf, newalc);
      if (newbuf == NULL)
	{
	  free (dpi->buf);
	  dpi->buf = NULL;
	  dpi->allocation_failure = 1;
	  return;
	}
      dpi->buf = newbuf;
      dpi->alc = newalc;
d2748 3
d2753 6
a2758 1
/* Append a character to the print buffer.  */
d2760 4
a2763 4
static void
d_print_append_char (dpi, c)
     struct d_print_info *dpi;
     int c;
d2765 9
a2773 1
  if (dpi->buf != NULL)
d2775 2
a2776 1
      if (dpi->len >= dpi->alc)
d2778 2
a2779 4
	  d_print_resize (dpi, 1);
	  if (dpi->buf == NULL)
	    return;
	}
d2781 17
a2797 4
      dpi->buf[dpi->len] = c;
      ++dpi->len;
    }
}
d2799 4
a2802 11
/* Append a buffer to the print buffer.  */

static void
d_print_append_buffer (dpi, s, l)
     struct d_print_info *dpi;
     const char *s;
     size_t l;
{
  if (dpi->buf != NULL)
    {
      if (dpi->len + l > dpi->alc)
d2804 14
a2817 3
	  d_print_resize (dpi, l);
	  if (dpi->buf == NULL)
	    return;
d2820 1
a2820 2
      memcpy (dpi->buf + dpi->len, s, l);
      dpi->len += l;
d2822 1
a2822 1
}
d2824 7
a2830 1
/* Indicate that an error occurred during printing.  */
d2832 1
a2832 6
static void
d_print_error (dpi)
     struct d_print_info *dpi;
{
  free (dpi->buf);
  dpi->buf = NULL;
d2835 4
a2838 4
/* Turn components into a human readable string.  Returns a string
   allocated by malloc, or NULL on error.  On success, this sets *PALC
   to the size of the allocated buffer.  On failure, this sets *PALC
   to 0 for a bad parse, or to 1 for a memory allocation failure.  */
d2840 4
a2843 5
static char *
d_print (options, dc, palc)
     int options;
     const struct d_comp *dc;
     size_t *palc;
d2845 1
a2845 1
  struct d_print_info dpi;
d2847 3
a2849 1
  dpi.options = options;
d2851 1
a2851 7
  dpi.alc = 64;
  dpi.buf = malloc (dpi.alc);
  if (dpi.buf == NULL)
    {
      *palc = 1;
      return NULL;
    }
d2853 7
a2859 3
  dpi.len = 0;
  dpi.templates = NULL;
  dpi.modifiers = NULL;
d2861 3
a2863 1
  dpi.allocation_failure = 0;
d2865 2
a2866 1
  d_print_comp (&dpi, dc);
d2868 8
a2875 1
  d_append_char (&dpi, '\0');
d2877 1
a2877 4
  if (dpi.buf != NULL)
    *palc = dpi.alc;
  else
    *palc = dpi.allocation_failure;
d2879 1
a2879 2
  return dpi.buf;
}
d2881 81
a2961 8
/* Subroutine to handle components.  */

static void
d_print_comp (dpi, dc)
     struct d_print_info *dpi;
     const struct d_comp *dc;
{
  if (dc == NULL)
d2963 2
a2964 2
      d_print_error (dpi);
      return;
d2966 1
a2966 2
  if (d_print_saw_error (dpi))
    return;
d2968 6
a2973 5
  switch (dc->type)
    {
    case D_COMP_NAME:
      d_print_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);
      return;
d2975 2
a2976 5
    case D_COMP_QUAL_NAME:
      d_print_comp (dpi, d_left (dc));
      d_append_string (dpi, (dpi->options & DMGL_JAVA) == 0 ? "::" : ".");
      d_print_comp (dpi, d_right (dc));
      return;
d2978 1
a2978 33
    case D_COMP_TYPED_NAME:
      {
	struct d_print_mod *hold_modifiers;
	struct d_comp *typed_name;
	struct d_print_mod adpm[4];
	unsigned int i;
	struct d_print_template dpt;

	/* Pass the name down to the type so that it can be printed in
	   the right place for the type.  We also have to pass down
	   any CV-qualifiers, which apply to the this parameter.  */
	hold_modifiers = dpi->modifiers;
	i = 0;
	typed_name = d_left (dc);
	while (typed_name != NULL)
	  {
	    if (i >= sizeof adpm / sizeof adpm[0])
	      {
		d_print_error (dpi);
		return;
	      }

	    adpm[i].next = dpi->modifiers;
	    dpi->modifiers = &adpm[i];
	    adpm[i].mod = typed_name;
	    adpm[i].printed = 0;
	    adpm[i].templates = dpi->templates;
	    ++i;

	    if (typed_name->type != D_COMP_RESTRICT_THIS
		&& typed_name->type != D_COMP_VOLATILE_THIS
		&& typed_name->type != D_COMP_CONST_THIS)
	      break;
d2980 1
a2980 2
	    typed_name = d_left (typed_name);
	  }
d2982 7
a2988 8
	/* If typed_name is a template, then it applies to the
	   function type as well.  */
	if (typed_name->type == D_COMP_TEMPLATE)
	  {
	    dpt.next = dpi->templates;
	    dpi->templates = &dpt;
	    dpt.template = typed_name;
	  }
d2990 2
a2991 1
	d_print_comp (dpi, d_right (dc));
d2993 3
a2995 2
	if (typed_name->type == D_COMP_TEMPLATE)
	  dpi->templates = dpt.next;
d2997 1
a2997 11
	/* If the modifiers didn't get printed by the type, print them
	   now.  */
	while (i > 0)
	  {
	    --i;
	    if (! adpm[i].printed)
	      {
		d_append_char (dpi, ' ');
		d_print_mod (dpi, adpm[i].mod);
	      }
	  }
d2999 2
a3000 1
	dpi->modifiers = hold_modifiers;
d3002 5
a3006 65
	return;
      }

    case D_COMP_TEMPLATE:
      {
	struct d_print_mod *hold_dpm;

	/* Don't push modifiers into a template definition.  Doing so
	   could give the wrong definition for a template argument.
	   Instead, treat the template essentially as a name.  */

	hold_dpm = dpi->modifiers;
	dpi->modifiers = NULL;

	d_print_comp (dpi, d_left (dc));
	if (d_last_char (dpi) == '<')
	  d_append_char (dpi, ' ');
	d_append_char (dpi, '<');
	d_print_comp (dpi, d_right (dc));
	/* Avoid generating two consecutive '>' characters, to avoid
	   the C++ syntactic ambiguity.  */
	if (d_last_char (dpi) == '>')
	  d_append_char (dpi, ' ');
	d_append_char (dpi, '>');

	dpi->modifiers = hold_dpm;

	return;
      }

    case D_COMP_TEMPLATE_PARAM:
      {
	long i;
	struct d_comp *a;
	struct d_print_template *hold_dpt;

	if (dpi->templates == NULL)
	  {
	    d_print_error (dpi);
	    return;
	  }
	i = dc->u.s_number.number;
	for (a = d_right (dpi->templates->template);
	     a != NULL;
	     a = d_right (a))
	  {
	    if (a->type != D_COMP_TEMPLATE_ARGLIST)
	      {
		d_print_error (dpi);
		return;
	      }
	    if (i <= 0)
	      break;
	    --i;
	  }
	if (i != 0 || a == NULL)
	  {
	    d_print_error (dpi);
	    return;
	  }

	/* While processing this parameter, we need to pop the list of
	   templates.  This is because the template parameter may
	   itself be a reference to a parameter of an outer
	   template.  */
d3008 2
a3009 121
	hold_dpt = dpi->templates;
	dpi->templates = hold_dpt->next;

	d_print_comp (dpi, d_left (a));

	dpi->templates = hold_dpt;

	return;
      }

    case D_COMP_CTOR:
      d_print_comp (dpi, dc->u.s_ctor.name);
      return;

    case D_COMP_DTOR:
      d_append_char (dpi, '~');
      d_print_comp (dpi, dc->u.s_dtor.name);
      return;

    case D_COMP_VTABLE:
      d_append_string (dpi, "vtable for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_VTT:
      d_append_string (dpi, "VTT for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_CONSTRUCTION_VTABLE:
      d_append_string (dpi, "construction vtable for ");
      d_print_comp (dpi, d_left (dc));
      d_append_string (dpi, "-in-");
      d_print_comp (dpi, d_right (dc));
      return;

    case D_COMP_TYPEINFO:
      d_append_string (dpi, "typeinfo for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_TYPEINFO_NAME:
      d_append_string (dpi, "typeinfo name for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_TYPEINFO_FN:
      d_append_string (dpi, "typeinfo fn for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_THUNK:
      d_append_string (dpi, "non-virtual thunk to ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_VIRTUAL_THUNK:
      d_append_string (dpi, "virtual thunk to ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_COVARIANT_THUNK:
      d_append_string (dpi, "covariant return thunk to ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_JAVA_CLASS:
      d_append_string (dpi, "java Class for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_GUARD:
      d_append_string (dpi, "guard variable for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_REFTEMP:
      d_append_string (dpi, "reference temporary for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_SUB_STD:
      d_append_string (dpi, dc->u.s_string.string);
      return;

    case D_COMP_RESTRICT:
    case D_COMP_VOLATILE:
    case D_COMP_CONST:
    case D_COMP_RESTRICT_THIS:
    case D_COMP_VOLATILE_THIS:
    case D_COMP_CONST_THIS:
    case D_COMP_VENDOR_TYPE_QUAL:
    case D_COMP_POINTER:
    case D_COMP_REFERENCE:
    case D_COMP_COMPLEX:
    case D_COMP_IMAGINARY:
      {
	/* We keep a list of modifiers on the stack.  */
	struct d_print_mod dpm;

	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;

	d_print_comp (dpi, d_left (dc));

	/* If the modifier didn't get printed by the type, print it
	   now.  */
	if (! dpm.printed)
	  d_print_mod (dpi, dc);

	dpi->modifiers = dpm.next;

	return;
      }

    case D_COMP_BUILTIN_TYPE:
      if ((dpi->options & DMGL_JAVA) == 0)
	d_append_string (dpi, dc->u.s_builtin.type->name);
d3011 1
a3011 2
	d_append_string (dpi, dc->u.s_builtin.type->java_name);
      return;
d3013 4
a3016 3
    case D_COMP_VENDOR_TYPE:
      d_print_comp (dpi, d_left (dc));
      return;
d3018 2
a3019 5
    case D_COMP_FUNCTION_TYPE:
      {
	if (d_left (dc) != NULL)
	  {
	    struct d_print_mod dpm;
d3021 6
a3026 2
	    /* We must pass this type down as a modifier in order to
	       print it in the right location.  */
d3028 2
a3029 5
	    dpm.next = dpi->modifiers;
	    dpi->modifiers = &dpm;
	    dpm.mod = dc;
	    dpm.printed = 0;
	    dpm.templates = dpi->templates;
d3031 3
a3033 1
	    d_print_comp (dpi, d_left (dc));
d3035 4
a3038 1
	    dpi->modifiers = dpm.next;
d3040 2
a3041 2
	    if (dpm.printed)
	      return;
d3043 4
a3046 2
	    d_append_char (dpi, ' ');
	  }
d3048 1
a3048 1
	d_print_function_type (dpi, dc, dpi->modifiers);
d3050 1
a3050 2
	return;
      }
d3052 7
a3058 3
    case D_COMP_ARRAY_TYPE:
      {
	struct d_print_mod dpm;
d3060 1
a3060 2
	/* We must pass this type down as a modifier in order to print
	   multi-dimensional arrays correctly.  */
d3062 7
a3068 5
	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;
d3070 9
a3078 1
	d_print_comp (dpi, d_right (dc));
d3080 8
a3087 1
	dpi->modifiers = dpm.next;
d3089 14
a3102 41
	if (dpm.printed)
	  return;

	d_print_array_type (dpi, dc, dpi->modifiers);

	return;
      }

    case D_COMP_PTRMEM_TYPE:
      {
	struct d_print_mod dpm;

	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;

	d_print_comp (dpi, d_right (dc));

	/* If the modifier didn't get printed by the type, print it
	   now.  */
	if (! dpm.printed)
	  {
	    d_append_char (dpi, ' ');
	    d_print_comp (dpi, d_left (dc));
	    d_append_string (dpi, "::*");
	  }

	dpi->modifiers = dpm.next;

	return;
      }

    case D_COMP_ARGLIST:
    case D_COMP_TEMPLATE_ARGLIST:
      d_print_comp (dpi, d_left (dc));
      if (d_right (dc) != NULL)
	{
	  d_append_string (dpi, ", ");
	  d_print_comp (dpi, d_right (dc));
d3104 1
a3104 100
      return;

    case D_COMP_OPERATOR:
      {
	char c;

	d_append_string (dpi, "operator");
	c = dc->u.s_operator.op->name[0];
	if (IS_LOWER (c))
	  d_append_char (dpi, ' ');
	d_append_string (dpi, dc->u.s_operator.op->name);
	return;
      }

    case D_COMP_EXTENDED_OPERATOR:
      d_append_string (dpi, "operator ");
      d_print_comp (dpi, dc->u.s_extended_operator.name);
      return;

    case D_COMP_CAST:
      d_append_string (dpi, "operator ");
      d_print_cast (dpi, dc);
      return;

    case D_COMP_UNARY:
      if (d_left (dc)->type != D_COMP_CAST)
	d_print_expr_op (dpi, d_left (dc));
      else
	{
	  d_append_string (dpi, "((");
	  d_print_cast (dpi, d_left (dc));
	  d_append_char (dpi, ')');
	}
      d_append_char (dpi, '(');
      d_print_comp (dpi, d_right (dc));
      d_append_char (dpi, ')');
      if (d_left (dc)->type == D_COMP_CAST)
	d_append_char (dpi, ')');
      return;

    case D_COMP_BINARY:
      if (d_right (dc)->type != D_COMP_BINARY_ARGS)
	{
	  d_print_error (dpi);
	  return;
	}

      /* We wrap an expression which uses the greater-than operator in
	 an extra layer of parens so that it does not get confused
	 with the '>' which ends the template parameters.  */
      if (d_left (dc)->type == D_COMP_OPERATOR
	  && strcmp (d_left (dc)->u.s_operator.op->name, ">") == 0)
	d_append_char (dpi, '(');

      d_append_char (dpi, '(');
      d_print_comp (dpi, d_left (d_right (dc)));
      d_append_string (dpi, ") ");
      d_print_expr_op (dpi, d_left (dc));
      d_append_string (dpi, " (");
      d_print_comp (dpi, d_right (d_right (dc)));
      d_append_char (dpi, ')');

      if (d_left (dc)->type == D_COMP_OPERATOR
	  && strcmp (d_left (dc)->u.s_operator.op->name, ">") == 0)
	d_append_char (dpi, ')');

      return;

    case D_COMP_BINARY_ARGS:
      /* We should only see this as part of D_COMP_BINARY.  */
      d_print_error (dpi);
      return;

    case D_COMP_TRINARY:
      if (d_right (dc)->type != D_COMP_TRINARY_ARG1
	  || d_right (d_right (dc))->type != D_COMP_TRINARY_ARG2)
	{
	  d_print_error (dpi);
	  return;
	}
      d_append_char (dpi, '(');
      d_print_comp (dpi, d_left (d_right (dc)));
      d_append_string (dpi, ") ");
      d_print_expr_op (dpi, d_left (dc));
      d_append_string (dpi, " (");
      d_print_comp (dpi, d_left (d_right (d_right (dc))));
      d_append_string (dpi, ") : (");
      d_print_comp (dpi, d_right (d_right (d_right (dc))));
      d_append_char (dpi, ')');
      return;

    case D_COMP_TRINARY_ARG1:
    case D_COMP_TRINARY_ARG2:
      /* We should only see these are part of D_COMP_TRINARY.  */
      d_print_error (dpi);
      return;

    case D_COMP_LITERAL:
      /* For some builtin types, produce simpler output.  */
      if (d_left (dc)->type == D_COMP_BUILTIN_TYPE)
d3106 1
a3106 9
	  switch (d_left (dc)->u.s_builtin.type->print)
	    {
	    case D_PRINT_INT:
	      if (d_right (dc)->type == D_COMP_NAME)
		{
		  d_print_comp (dpi, d_right (dc));
		  return;
		}
	      break;
d3108 2
a3109 8
	    case D_PRINT_LONG:
	      if (d_right (dc)->type == D_COMP_NAME)
		{
		  d_print_comp (dpi, d_right (dc));
		  d_append_char (dpi, 'l');
		  return;
		}
	      break;
d3111 9
a3119 17
	    case D_PRINT_BOOL:
	      if (d_right (dc)->type == D_COMP_NAME
		  && d_right (dc)->u.s_name.len == 1)
		{
		  switch (d_right (dc)->u.s_name.s[0])
		    {
		    case '0':
		      d_append_string (dpi, "false");
		      return;
		    case '1':
		      d_append_string (dpi, "true");
		      return;
		    default:
		      break;
		    }
		}
	      break;
d3121 2
a3122 3
	    default:
	      break;
	    }
d3124 2
a3125 10

      d_append_char (dpi, '(');
      d_print_comp (dpi, d_left (dc));
      d_append_char (dpi, ')');
      d_print_comp (dpi, d_right (dc));
      return;

    default:
      d_print_error (dpi);
      return;
a3126 1
}
d3128 3
a3130 1
/* Print an identifier.  */
d3132 3
a3134 12
static void
d_print_identifier (dpi, name, len)
     struct d_print_info *dpi;
     const char *name;
     int len;
{
  if ((dpi->options & DMGL_JAVA) == 0)
    d_append_buffer (dpi, name, len);
  else
    {
      const char *p;
      const char *end;
d3136 5
a3140 14
      /* For Java we try to handle encoded extended Unicode
	 characters.  The C++ ABI doesn't mention Unicode encoding, so
	 we don't it for C++.  Characters are encoded as
	 __U<hex-char>+_.  */
      end = name + len;
      for (p = name; p < end; ++p)
	{
	  if (end - p > 3
	      && p[0] == '_'
	      && p[1] == '_'
	      && p[2] == 'U')
	    {
	      unsigned long c;
	      const char *q;
d3142 2
a3143 4
	      c = 0;
	      for (q = p + 3; q < end; ++q)
		{
		  int dig;
d3145 1
a3145 8
		  if (IS_DIGIT (*q))
		    dig = *q - '0';
		  else if (*q >= 'A' && *q <= 'F')
		    dig = *q - 'A' + 10;
		  else if (*q >= 'a' && *q <= 'f')
		    dig = *q - 'a' + 10;
		  else
		    break;
d3147 4
a3150 19
		  c = c * 16 + dig;
		}
	      /* If the Unicode character is larger than 256, we don't
		 try to deal with it here.  FIXME.  */
	      if (q < end && *q == '_' && c < 256)
		{
		  d_append_char (dpi, c);
		  p = q;
		  continue;
		}
	    }

	  d_append_char (dpi, *p);
	}
    }
}

/* Print a list of modifiers.  SUFFIX is 1 if we are printing
   qualifiers on this after printing a function.  */
d3152 3
a3154 5
static void
d_print_mod_list (dpi, mods, suffix)
     struct d_print_info *dpi;
     struct d_print_mod *mods;
     int suffix;
d3156 1
a3156 4
  struct d_print_template *hold_dpt;

  if (mods == NULL || d_print_saw_error (dpi))
    return;
d3158 1
a3158 5
  if (mods->printed
      || (! suffix
	  && (mods->mod->type == D_COMP_RESTRICT_THIS
	      || mods->mod->type == D_COMP_VOLATILE_THIS
	      || mods->mod->type == D_COMP_CONST_THIS)))
d3160 2
a3161 3
      d_print_mod_list (dpi, mods->next, suffix);
      return;
    }
d3163 11
a3173 1
  mods->printed = 1;
d3175 6
a3180 2
  hold_dpt = dpi->templates;
  dpi->templates = mods->templates;
d3182 3
a3184 11
  if (mods->mod->type == D_COMP_FUNCTION_TYPE)
    {
      d_print_function_type (dpi, mods->mod, mods->next);
      dpi->templates = hold_dpt;
      return;
    }
  else if (mods->mod->type == D_COMP_ARRAY_TYPE)
    {
      d_print_array_type (dpi, mods->mod, mods->next);
      dpi->templates = hold_dpt;
      return;
d3187 4
a3190 1
  d_print_mod (dpi, mods->mod);
d3192 4
a3195 1
  dpi->templates = hold_dpt;
d3197 5
a3201 2
  d_print_mod_list (dpi, mods->next, suffix);
}
d3203 1
a3203 1
/* Print a modifier.  */
d3205 19
a3223 53
static void
d_print_mod (dpi, mod)
     struct d_print_info *dpi;
     const struct d_comp *mod;
{
  switch (mod->type)
    {
    case D_COMP_RESTRICT:
    case D_COMP_RESTRICT_THIS:
      d_append_string (dpi, " restrict");
      return;
    case D_COMP_VOLATILE:
    case D_COMP_VOLATILE_THIS:
      d_append_string (dpi, " volatile");
      return;
    case D_COMP_CONST:
    case D_COMP_CONST_THIS:
      d_append_string (dpi, " const");
      return;
    case D_COMP_VENDOR_TYPE_QUAL:
      d_append_char (dpi, ' ');
      d_print_comp (dpi, d_right (mod));
      return;
    case D_COMP_POINTER:
      /* There is no pointer symbol in Java.  */
      if ((dpi->options & DMGL_JAVA) == 0)
	d_append_char (dpi, '*');
      return;
    case D_COMP_REFERENCE:
      d_append_char (dpi, '&');
      return;
    case D_COMP_COMPLEX:
      d_append_string (dpi, "complex ");
      return;
    case D_COMP_IMAGINARY:
      d_append_string (dpi, "imaginary ");
      return;
    case D_COMP_PTRMEM_TYPE:
      if (d_last_char (dpi) != '(')
	d_append_char (dpi, ' ');
      d_print_comp (dpi, d_left (mod));
      d_append_string (dpi, "::*");
      return;
    case D_COMP_TYPED_NAME:
      d_print_comp (dpi, d_left (mod));
      return;
    default:
      /* Otherwise, we have something that won't go back on the
	 modifier stack, so we can just print it.  */
      d_print_comp (dpi, mod);
      return;
    }
}
d3225 9
a3233 1
/* Print a function type, except for the return type.  */
d3235 13
a3247 16
static void
d_print_function_type (dpi, dc, mods)
     struct d_print_info *dpi;
     const struct d_comp *dc;
     struct d_print_mod *mods;
{
  int need_paren;
  int saw_mod;
  struct d_print_mod *p;

  need_paren = 0;
  saw_mod = 0;
  for (p = mods; p != NULL; p = p->next)
    {
      if (p->printed)
	break;
d3249 2
a3250 2
      saw_mod = 1;
      switch (p->mod->type)
d3252 3
a3254 17
	case D_COMP_RESTRICT:
	case D_COMP_VOLATILE:
	case D_COMP_CONST:
	case D_COMP_VENDOR_TYPE_QUAL:
	case D_COMP_POINTER:
	case D_COMP_REFERENCE:
	case D_COMP_COMPLEX:
	case D_COMP_IMAGINARY:
	case D_COMP_PTRMEM_TYPE:
	  need_paren = 1;
	  break;
	case D_COMP_RESTRICT_THIS:
	case D_COMP_VOLATILE_THIS:
	case D_COMP_CONST_THIS:
	  break;
	default:
	  break;
a3255 2
      if (need_paren)
	break;
d3258 4
a3261 2
  if (d_left (dc) != NULL && ! saw_mod)
    need_paren = 1;
d3263 14
a3276 8
  if (need_paren)
    {
      switch (d_last_char (dpi))
	{
	case ' ':
	case '(':
	case '*':
	  break;
d3278 1
a3278 4
	default:
	  d_append_char (dpi, ' ');
	  break;
	}
d3280 3
a3282 2
      d_append_char (dpi, '(');
    }
d3284 5
a3288 1
  d_print_mod_list (dpi, mods, 0);
d3290 1
a3290 2
  if (need_paren)
    d_append_char (dpi, ')');
d3292 7
a3298 1
  d_append_char (dpi, '(');
d3300 4
a3303 2
  if (d_right (dc) != NULL)
    d_print_comp (dpi, d_right (dc));
d3305 4
a3308 1
  d_append_char (dpi, ')');
d3310 1
a3310 1
  d_print_mod_list (dpi, mods, 1);
d3313 2
a3314 1
/* Print an array type, except for the element type.  */
d3316 16
a3331 7
static void
d_print_array_type (dpi, dc, mods)
     struct d_print_info *dpi;
     const struct d_comp *dc;
     struct d_print_mod *mods;
{
  int need_space;
d3333 25
a3357 2
  need_space = 1;
  if (mods != NULL)
d3359 1
a3359 2
      int need_paren;
      struct d_print_mod *p;
d3361 1
a3361 2
      need_paren = 0;
      for (p = mods; p != NULL; p = p->next)
d3363 57
a3419 2
	  if (p->printed)
	    break;
d3421 2
a3422 1
	  if (p->mod->type == D_COMP_ARRAY_TYPE)
d3424 2
a3425 2
	      need_space = 0;
	      break;
d3429 2
a3430 3
	      need_paren = 1;
	      need_space = 1;
	      break;
d3432 5
d3438 3
d3442 6
a3447 4
      if (need_paren)
	d_append_string (dpi, " (");

      d_print_mod_list (dpi, mods, 0);
d3449 1
a3449 2
      if (need_paren)
	d_append_char (dpi, ')');
d3452 6
a3457 2
  if (need_space)
    d_append_char (dpi, ' ');
d3459 2
a3460 1
  d_append_char (dpi, '[');
d3462 3
a3464 2
  if (d_left (dc) != NULL)
    d_print_comp (dpi, d_left (dc));
d3466 1
a3466 2
  d_append_char (dpi, ']');
}
d3468 2
a3469 1
/* Print an operator in an expression.  */
d3471 3
a3473 4
static void
d_print_expr_op (dpi, dc)
     struct d_print_info *dpi;
     const struct d_comp *dc;
d3475 1
a3475 5
  if (dc->type == D_COMP_OPERATOR)
    d_append_string (dpi, dc->u.s_operator.op->name);
  else
    d_print_comp (dpi, dc);
}
d3477 4
a3480 1
/* Print a cast.  */
d3482 8
a3489 7
static void
d_print_cast (dpi, dc)
     struct d_print_info *dpi;
     const struct d_comp *dc;
{
  if (d_left (dc)->type != D_COMP_TEMPLATE)
    d_print_comp (dpi, d_left (dc));
d3492 48
a3539 30
      struct d_print_mod *hold_dpm;
      struct d_print_template dpt;

      /* It appears that for a templated cast operator, we need to put
	 the template parameters in scope for the operator name, but
	 not for the parameters.  The effect is that we need to handle
	 the template printing here.  */

      hold_dpm = dpi->modifiers;
      dpi->modifiers = NULL;

      dpt.next = dpi->templates;
      dpi->templates = &dpt;
      dpt.template = d_left (dc);

      d_print_comp (dpi, d_left (d_left (dc)));

      dpi->templates = dpt.next;

      if (d_last_char (dpi) == '<')
	d_append_char (dpi, ' ');
      d_append_char (dpi, '<');
      d_print_comp (dpi, d_right (d_left (dc)));
      /* Avoid generating two consecutive '>' characters, to avoid
	 the C++ syntactic ambiguity.  */
      if (d_last_char (dpi) == '>')
	d_append_char (dpi, ' ');
      d_append_char (dpi, '>');

      dpi->modifiers = hold_dpm;
d3541 1
a3541 35
}

/* Initialize the information structure we use to pass around
   information.  */

static int
d_init_info (mangled, options, len, di)
     const char *mangled;
     int options;
     size_t len;
     struct d_info *di;
{
  di->s = mangled;
  di->options = options;

  di->n = mangled;

  /* We can not need more components than twice the number of chars in
     the mangled string.  Most components correspond directly to
     chars, but the ARGLIST types are exceptions.  */
  di->num_comps = 2 * len;
  di->comps = (struct d_comp *) malloc (di->num_comps
					* sizeof (struct d_comp));
  di->next_comp = 0;

  /* Similarly, we can not need more substitutions than there are
     chars in the mangled string.  */
  di->num_subs = len;
  di->subs = (struct d_comp **) malloc (di->num_subs
					* sizeof (struct d_comp *));
  di->next_sub = 0;

  di->last_name = NULL;

  if (di->comps == NULL || di->subs == NULL)
d3543 2
a3544 5
      if (di->comps != NULL)
	free (di->comps);
      if (di->subs != NULL)
	free (di->subs);
      return 0;
d3547 1
a3547 1
  return 1;
d3550 3
a3552 6
/* Entry point for the demangler.  If MANGLED is a g++ v3 ABI mangled
   name, return a buffer allocated with malloc holding the demangled
   name.  OPTIONS is the usual libiberty demangler options.  On
   success, this sets *PALC to the allocated size of the returned
   buffer.  On failure, this sets *PALC to 0 for a bad name, or 1 for
   a memory allocation failure.  On failure, this returns NULL.  */
d3554 5
a3558 5
static char *
d_demangle (mangled, options, palc)
     const char* mangled;
     int options;
     size_t *palc;
d3560 2
a3561 5
  size_t len;
  int type;
  struct d_info di;
  struct d_comp *dc;
  char *ret;
d3563 5
a3567 1
  *palc = 0;
d3569 6
a3574 1
  len = strlen (mangled);
d3576 2
a3577 13
  if (mangled[0] == '_' && mangled[1] == 'Z')
    type = 0;
  else if (strncmp (mangled, "_GLOBAL_", 8) == 0
	   && (mangled[8] == '.' || mangled[8] == '_' || mangled[8] == '$')
	   && (mangled[9] == 'D' || mangled[9] == 'I')
	   && mangled[10] == '_')
    {
      char *r;

      r = malloc (40 + len - 11);
      if (r == NULL)
	*palc = 1;
      else
d3579 4
a3582 5
	  if (mangled[9] == 'I')
	    strcpy (r, "global constructors keyed to ");
	  else
	    strcpy (r, "global destructors keyed to ");
	  strcat (r, mangled + 11);
d3584 2
a3585 1
      return r;
d3589 6
a3594 3
      if ((options & DMGL_TYPES) == 0)
	return NULL;
      type = 1;
d3597 2
a3598 5
  if (! d_init_info (mangled, options, len, &di))
    {
      *palc = 1;
      return NULL;
    }
d3600 3
a3602 4
  if (! type)
    dc = d_mangled_name (&di, 1);
  else
    dc = d_type (&di);
d3604 10
a3613 4
  /* If we didn't consume the entire mangled string, then we didn't
     successfully demangle it.  */
  if (d_peek_char (&di) != '\0')
    dc = NULL;
d3615 7
a3621 6
#ifdef CP_DEMANGLE_DEBUG
  if (dc == NULL)
    printf ("failed demangling\n");
  else
    d_dump (dc, 0);
#endif
d3623 1
a3623 2
  free (di.subs);
  di.subs = NULL;
d3625 9
a3633 3
  ret = NULL;
  if (dc != NULL)
    ret = d_print (options, dc, palc);
d3635 2
a3636 1
  free (di.comps);
d3638 1
a3638 1
  return ret;
a3641 1

d3644 3
a3646 3
/* ia64 ABI-mandated entry point in the C++ runtime library for
   performing demangling.  MANGLED_NAME is a NUL-terminated character
   string containing the name to be demangled.
d3652 1
a3652 1
   is placed in a region of memory allocated with malloc.
d3655 1
a3655 1
   demangled name, is placed in *LENGTH.
d3659 1
a3659 1
   responsible for deallocating this memory using free.
d3663 1
a3663 1
     -1: A memory allocation failure occurred.
d3667 1
a3667 1
   The demangling is performed using the C++ ABI mangling rules, with
d3677 2
a3678 2
  char *demangled;
  size_t alc;
d3683 17
a3699 2
  if (mangled_name == NULL)
    {
d3703 13
d3717 2
a3718 1
  if (output_buffer != NULL && length == NULL)
d3720 12
a3731 7
      *status = -3;
      return NULL;
    }

  demangled = d_demangle (mangled_name, DMGL_TYPES, &alc);

  if (demangled == NULL)
d3733 1
a3733 4
      if (alc == 1)
	*status = -1;
      else
	*status = -2;
a3735 6

  if (output_buffer == NULL)
    {
      if (length != NULL)
	*length = alc;
    }
d3737 2
d3740 6
a3745 11
      if (strlen (demangled) < *length)
	{
	  strcpy (output_buffer, demangled);
	  free (demangled);
	  demangled = output_buffer;
	}
      else
	{
	  free (output_buffer);
	  *length = alc;
	}
a3746 4

  *status = 0;

  return demangled;
d3751 5
a3755 3
/* Entry point for libiberty demangler.  If MANGLED is a g++ v3 ABI
   mangled name, return a buffer allocated with malloc holding the
   demangled name.  Otherwise, return NULL.  */
d3762 25
a3786 1
  size_t alc;
d3788 20
a3807 1
  return d_demangle (mangled, options, &alc);
d3821 28
a3848 15
  size_t alc;
  char *demangled;
  int nesting;
  char *from;
  char *to;

  demangled = d_demangle (mangled, DMGL_JAVA | DMGL_PARAMS, &alc);

  if (demangled == NULL)
    return NULL;

  nesting = 0;
  from = demangled;
  to = from;
  while (*from != '\0')
d3850 19
a3868 3
      if (strncmp (from, "JArray<", 7) == 0)
	{
	  from += 7;
d3870 11
d3882 2
a3883 6
      else if (nesting > 0 && *from == '>')
	{
	  while (to > demangled && to[-1] == ' ')
	    --to;
	  *to++ = '[';
	  *to++ = ']';
d3885 10
a3894 1
	  ++from;
d3897 9
a3905 1
	*to++ = *from++;
d3908 6
a3913 1
  *to = '\0';
d3915 1
a3915 1
  return demangled;
d3920 1
d3922 9
d3932 1
a3932 18
/* Demangle a string in order to find out whether it is a constructor
   or destructor.  Return non-zero on success.  Set *CTOR_KIND and
   *DTOR_KIND appropriately.  */

static int
is_ctor_or_dtor (mangled, ctor_kind, dtor_kind)
     const char *mangled;
     enum gnu_v3_ctor_kinds *ctor_kind;
     enum gnu_v3_dtor_kinds *dtor_kind;
{
  struct d_info di;
  struct d_comp *dc;
  int ret;

  *ctor_kind = (enum gnu_v3_ctor_kinds) 0;
  *dtor_kind = (enum gnu_v3_dtor_kinds) 0;

  if (! d_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di))
d3935 6
a3940 1
  dc = d_mangled_name (&di, 1);
d3942 2
a3943 2
  ret = 0;
  if (d_peek_char (&di) == '\0')
d3945 3
a3947 29
      while (dc != NULL)
	{
	  switch (dc->type)
	    {
	    default:
	      dc = NULL;
	      break;
	    case D_COMP_TYPED_NAME:
	    case D_COMP_TEMPLATE:
	    case D_COMP_RESTRICT_THIS:
	    case D_COMP_VOLATILE_THIS:
	    case D_COMP_CONST_THIS:
	      dc = d_left (dc);
	      break;
	    case D_COMP_QUAL_NAME:
	      dc = d_right (dc);
	      break;
	    case D_COMP_CTOR:
	      *ctor_kind = dc->u.s_ctor.kind;
	      ret = 1;
	      dc = NULL;
	      break;
	    case D_COMP_DTOR:
	      *dtor_kind = dc->u.s_dtor.kind;
	      ret = 1;
	      dc = NULL;
	      break;
	    }
	}
d3950 3
a3952 2
  free (di.subs);
  free (di.comps);
d3954 2
a3955 1
  return ret;
a3957 2
/* Return whether NAME is the mangled form of a g++ V3 ABI constructor
   name.  A non-zero return indicates the type of constructor.  */
d3959 5
d3968 1
a3968 2
  enum gnu_v3_ctor_kinds ctor_kind;
  enum gnu_v3_dtor_kinds dtor_kind;
d3970 7
a3976 1
  if (! is_ctor_or_dtor (name, &ctor_kind, &dtor_kind))
a3977 1
  return ctor_kind;
d3981 5
a3985 3
/* Return whether NAME is the mangled form of a g++ V3 ABI destructor
   name.  A non-zero return indicates the type of destructor.  */

d3990 1
a3990 2
  enum gnu_v3_ctor_kinds ctor_kind;
  enum gnu_v3_dtor_kinds dtor_kind;
d3992 7
a3998 1
  if (! is_ctor_or_dtor (name, &ctor_kind, &dtor_kind))
a3999 1
  return dtor_kind;
d4001 1
a4002 1
#endif /* IN_GLIBCPP_V3 */
a4006 3
#include "dyn-string.h"

static void print_usage PARAMS ((FILE* fp, int exit_value));
d4008 2
a4009 3
#define IS_ALPHA(CHAR)                                                  \
  (((CHAR) >= 'a' && (CHAR) <= 'z')                                     \
   || ((CHAR) >= 'A' && (CHAR) <= 'Z'))
d4029 1
a4029 1
  fprintf (fp, "  -p,--no-params  Don't display function parameters\n");
d4039 4
a4042 4
  { "help",	 no_argument, NULL, 'h' },
  { "no-params", no_argument, NULL, 'p' },
  { "verbose",   no_argument, NULL, 'v' },
  { NULL,        no_argument, NULL, 0   },
d4055 1
a4057 1
  int options = DMGL_PARAMS | DMGL_ANSI | DMGL_TYPES;
d4065 1
a4065 1
      opt_char = getopt_long (argc, argv, "hpv", long_options, NULL);
d4076 2
a4077 2
	case 'p':
	  options &= ~ DMGL_PARAMS;
d4081 1
a4081 1
	  options |= DMGL_VERBOSE;
d4091 2
a4092 1
      char *s;
d4097 29
a4125 1
	  char c;
d4138 9
a4146 1
	  if (dyn_string_length (mangled) > 0)
d4148 2
a4149 15
	      s = cplus_demangle_v3 (dyn_string_buf (mangled), options);

	      if (s != NULL)
		{
		  fputs (s, stdout);
		  free (s);
		}
	      else
		{
		  /* It might not have been a mangled name.  Print the
		     original text.  */
		  fputs (dyn_string_buf (mangled), stdout);
		}

	      dyn_string_clear (mangled);
d4151 4
d4160 4
d4167 1
d4172 2
a4176 2
	  char *s;

d4178 1
a4178 1
	  s = cplus_demangle_v3 (argv[i], options);
d4181 4
a4184 1
	  if (s != NULL)
d4186 2
a4187 2
	      printf ("%s\n", s);
	      free (s);
d4189 3
a4191 2
	  else
	    fprintf (stderr, "Failed: %s\n", argv[i]);
d4193 1
@


1.27.4.2
log
@Merge from mainline.
@
text
@a143 17
/* Information we keep for the standard substitutions.  */

struct d_standard_sub_info
{
  /* The code for this substitution.  */
  char code;
  /* The simple string it expands to.  */
  const char *simple_expansion;
  /* The results of a full, verbose, expansion.  This is used when
     qualifying a constructor/destructor, or when in verbose mode.  */
  const char *full_expansion;
  /* What to set the last_name field of d_info to; NULL if we should
     not set it.  This is only relevant when qualifying a
     constructor/destructor.  */
  const char *set_last_name;
};

a151 2
  /* A local name.  */
  D_COMP_LOCAL_NAME,
d242 1
a242 3
  D_COMP_LITERAL,
  /* A negative literal.  */
  D_COMP_LITERAL_NEG
d492 1
a492 1
static struct d_comp *d_substitution PARAMS ((struct d_info *, int));
a568 3
    case D_COMP_LOCAL_NAME:
      printf ("local name\n");
      break;
a685 3
    case D_COMP_LITERAL_NEG:
      printf ("negative literal\n");
      break;
a728 1
    case D_COMP_LOCAL_NAME:
a739 1
    case D_COMP_LITERAL_NEG:
a1004 1
    case D_COMP_LOCAL_NAME:
d1090 1
a1090 1
	    dc = d_substitution (di, 0);
d1205 1
a1205 1
	dc = d_substitution (di, 1);
d1779 1
a1779 1
	    ret = d_substitution (di, 0);
a2256 1
      enum d_comp_type t;
a2271 6
      t = D_COMP_LITERAL;
      if (d_peek_char (di) == 'n')
	{
	  t = D_COMP_LITERAL_NEG;
	  d_advance (di, 1);
	}
d2275 2
a2276 1
      ret = d_make_comp (di, t, type, d_make_name (di, s, d_str (di) - s));
d2306 1
a2306 1
      return d_make_comp (di, D_COMP_LOCAL_NAME, function,
d2317 1
a2317 1
      return d_make_comp (di, D_COMP_LOCAL_NAME, function, name);
a2365 8

   If PREFIX is non-zero, then this type is being used as a prefix in
   a qualified name.  In this case, for the standard substitutions, we
   need to check whether we are being used as a prefix for a
   constructor or destructor, and return a full template name.
   Otherwise we will get something like std::iostream::~iostream()
   which does not correspond particularly well to any function which
   actually appears in the source.
a2367 19
static const struct d_standard_sub_info standard_subs[] =
{
  { 't', "std", "std", NULL },
  { 'a', "std::allocator", "std::allocator", "allocator" },
  { 'b', "std::basic_string", "std::basic_string", "basic_string" },
  { 's', "std::string",
    "std::basic_string<char, std::char_traits<char>, std::allocator<char> >",
    "basic_string" },
  { 'i', "std::istream",
    "std::basic_istream<char, std::char_traits<char> >",
    "basic_istream" },
  { 'o', "std::ostream",
    "std::basic_ostream<char, std::char_traits<char> >",
    "basic_ostream" },
  { 'd', "std::iostream",
    "std::basic_iostream<char, std::char_traits<char> >",
    "basic_iostream" }
};

d2369 1
a2369 1
d_substitution (di, prefix)
a2370 1
     int prefix;
d2407 1
a2407 6
      int verbose;
      const struct d_standard_sub_info *p;
      const struct d_standard_sub_info *pend;

      verbose = (di->options & DMGL_VERBOSE) != 0;
      if (! verbose && prefix)
d2409 22
a2430 5
	  char peek;

	  peek = d_peek_char (di);
	  if (peek == 'C' || peek == 'D')
	    verbose = 1;
a2431 17

      pend = (&standard_subs[0]
	      + sizeof standard_subs / sizeof standard_subs[0]);
      for (p = &standard_subs[0]; p < pend; ++p)
	{
	  if (c == p->code)
	    {
	      if (p->set_last_name != NULL)
		di->last_name = d_make_sub (di, p->set_last_name);
	      if (verbose)
		return d_make_sub (di, p->full_expansion);
	      else
		return d_make_sub (di, p->simple_expansion);
	    }
	}

      return NULL;
a2581 1
    case D_COMP_LOCAL_NAME:
a2632 32
	/* If typed_name is a D_COMP_LOCAL_NAME, then there may be
	   CV-qualifiers on its right argument which really apply
	   here; this happens when parsing a class which is local to a
	   function.  */
	if (typed_name->type == D_COMP_LOCAL_NAME)
	  {
	    struct d_comp *local_name;

	    local_name = d_right (typed_name);
	    while (local_name->type == D_COMP_RESTRICT_THIS
		   || local_name->type == D_COMP_VOLATILE_THIS
		   || local_name->type == D_COMP_CONST_THIS)
	      {
		if (i >= sizeof adpm / sizeof adpm[0])
		  {
		    d_print_error (dpi);
		    return;
		  }

		adpm[i] = adpm[i - 1];
		adpm[i].next = &adpm[i - 1];
		dpi->modifiers = &adpm[i];

		adpm[i - 1].mod = local_name;
		adpm[i - 1].printed = 0;
		adpm[i - 1].templates = dpi->templates;
		++i;

		local_name = d_left (local_name);
	      }
	  }

a3033 1
    case D_COMP_LITERAL_NEG:
a3041 2
		  if (dc->type == D_COMP_LITERAL_NEG)
		    d_append_char (dpi, '-');
a3049 2
		  if (dc->type == D_COMP_LITERAL_NEG)
		    d_append_char (dpi, '-');
d3058 1
a3058 2
		  && d_right (dc)->u.s_name.len == 1
		  && dc->type == D_COMP_LITERAL)
a3081 2
      if (dc->type == D_COMP_LITERAL_NEG)
	d_append_char (dpi, '-');
a3192 28
  else if (mods->mod->type == D_COMP_LOCAL_NAME)
    {
      struct d_print_mod *hold_modifiers;
      struct d_comp *dc;

      /* When this is on the modifier stack, we have pulled any
	 qualifiers off the right argument already.  Otherwise, we
	 print it as usual, but don't let the left argument see any
	 modifiers.  */

      hold_modifiers = dpi->modifiers;
      dpi->modifiers = NULL;
      d_print_comp (dpi, d_left (mods->mod));
      dpi->modifiers = hold_modifiers;

      d_append_string (dpi, (dpi->options & DMGL_JAVA) == 0 ? "::" : ".");

      dc = d_right (mods->mod);
      while (dc->type == D_COMP_RESTRICT_THIS
	     || dc->type == D_COMP_VOLATILE_THIS
	     || dc->type == D_COMP_CONST_THIS)
	dc = d_left (dc);

      d_print_comp (dpi, dc);

      dpi->templates = hold_dpt;
      return;
    }
a3267 1
  struct d_print_mod *hold_modifiers;
a3320 3
  hold_modifiers = dpi->modifiers;
  dpi->modifiers = NULL;

a3333 2

  dpi->modifiers = hold_modifiers;
d3555 3
a3557 5
  /* If DMGL_PARAMS is set, then if we didn't consume the entire
     mangled string, then we didn't successfully demangle it.  If
     DMGL_PARAMS is not set, we didn't look at the trailing
     parameters.  */
  if (((options & DMGL_PARAMS) != 0) && d_peek_char (&di) != '\0')
a3761 3
  /* Note that because we did not pass DMGL_PARAMS, we don't expect to
     demangle the entire string.  */

d3763 1
a3763 1
  while (dc != NULL)
d3765 1
a3765 1
      switch (dc->type)
d3767 26
a3792 24
	default:
	  dc = NULL;
	  break;
	case D_COMP_TYPED_NAME:
	case D_COMP_TEMPLATE:
	case D_COMP_RESTRICT_THIS:
	case D_COMP_VOLATILE_THIS:
	case D_COMP_CONST_THIS:
	  dc = d_left (dc);
	  break;
	case D_COMP_QUAL_NAME:
	case D_COMP_LOCAL_NAME:
	  dc = d_right (dc);
	  break;
	case D_COMP_CTOR:
	  *ctor_kind = dc->u.s_ctor.kind;
	  ret = 1;
	  dc = NULL;
	  break;
	case D_COMP_DTOR:
	  *dtor_kind = dc->u.s_dtor.kind;
	  ret = 1;
	  dc = NULL;
	  break;
@


1.27.4.3
log
@Merge from mainline.
@
text
@a84 14
/* See if the compiler supports dynamic arrays.  */

#ifdef __GNUC__
#define CP_DYNAMIC_ARRAYS
#else
#ifdef __STDC__
#ifdef __STDC_VERSION__
#if __STDC_VERSION__ >= 199901L
#define CP_DYNAMIC_ARRAYS
#endif /* __STDC__VERSION >= 199901L */
#endif /* defined (__STDC_VERSION__) */
#endif /* defined (__STDC__) */
#endif /* ! defined (__GNUC__) */

a111 2
  /* Length of real name.  */
  int len;
a137 2
  /* Length of type name.  */
  int len;
a139 2
  /* Length of java name.  */
  int java_len;
a151 2
  /* The length of the simple expansion.  */
  int simple_len;
a154 2
  /* The length of the full expansion.  */
  int full_len;
a158 2
  /* The length of set_last_name.  */
  int set_last_name_len;
a322 1
      int len;
a349 2
  /* The end of the string we are demangling.  */
  const char *send;
a365 4
  /* The number of substitutions which we actually made from the subs
     array, plus the number of template parameter references we
     saw.  */
  int did_subs;
a367 4
  /* A running total of the length of large expansions from the
     mangled name to the demangled name, such as standard
     substitutions and builtin types.  */
  int expansion;
d447 7
a453 2
#define d_append_string_constant(dpi, s) \
  d_append_buffer (dpi, (s), sizeof (s) - 1)
d481 1
a481 1
static struct d_comp *d_make_sub PARAMS ((struct d_info *, const char *, int));
d519 1
a519 1
static char *d_print PARAMS ((int, const struct d_comp *, int, size_t *));
d522 2
a523 2
static void d_print_java_identifier PARAMS ((struct d_print_info *,
					     const char *, int));
d538 1
a538 1
static void d_init_info PARAMS ((const char *, int, size_t, struct d_info *));
d964 1
a964 1
d_make_sub (di, name, len)
a966 1
     int len;
d972 1
a972 4
    {
      p->u.s_string.string = name;
      p->u.s_string.len = len;
    }
a1127 1
	    di->expansion += 3;
d1278 1
a1278 8
    {
      struct d_comp *ret;

      ret = d_operator_name (di);
      if (ret != NULL && ret->type == D_COMP_OPERATOR)
	di->expansion += sizeof "operator" + ret->u.s_operator.op->len - 2;
      return ret;
    }
d1308 1
a1308 1
  int negative;
d1312 1
a1312 1
  negative = 0;
d1316 1
a1316 1
      negative = 1;
d1325 1
a1325 5
	{
	  if (negative)
	    ret = - ret;
	  return ret;
	}
a1341 4

  if (di->send - name < len)
    return NULL;

a1343 7
  /* A Java mangled name may have a trailing '$' if it is a C++
     keyword.  This '$' is not included in the length count.  We just
     ignore the '$'.  */
  if ((di->options & DMGL_JAVA) != 0
      && d_peek_char (di) == '$')
    d_advance (di, 1);

d1356 2
a1357 5
	{
	  di->expansion -= len - sizeof "(anonymous namespace)";
	  return d_make_name (di, "(anonymous namespace)",
			      sizeof "(anonymous namespace)" - 1);
	}
a1367 2
#define NL(s) s, (sizeof s) - 1

d1370 49
a1418 49
  { "aN", NL ("&="),        2 },
  { "aS", NL ("="),         2 },
  { "aa", NL ("&&"),        2 },
  { "ad", NL ("&"),         1 },
  { "an", NL ("&"),         2 },
  { "cl", NL ("()"),        0 },
  { "cm", NL (","),         2 },
  { "co", NL ("~"),         1 },
  { "dV", NL ("/="),        2 },
  { "da", NL ("delete[]"),  1 },
  { "de", NL ("*"),         1 },
  { "dl", NL ("delete"),    1 },
  { "dv", NL ("/"),         2 },
  { "eO", NL ("^="),        2 },
  { "eo", NL ("^"),         2 },
  { "eq", NL ("=="),        2 },
  { "ge", NL (">="),        2 },
  { "gt", NL (">"),         2 },
  { "ix", NL ("[]"),        2 },
  { "lS", NL ("<<="),       2 },
  { "le", NL ("<="),        2 },
  { "ls", NL ("<<"),        2 },
  { "lt", NL ("<"),         2 },
  { "mI", NL ("-="),        2 },
  { "mL", NL ("*="),        2 },
  { "mi", NL ("-"),         2 },
  { "ml", NL ("*"),         2 },
  { "mm", NL ("--"),        1 },
  { "na", NL ("new[]"),     1 },
  { "ne", NL ("!="),        2 },
  { "ng", NL ("-"),         1 },
  { "nt", NL ("!"),         1 },
  { "nw", NL ("new"),       1 },
  { "oR", NL ("|="),        2 },
  { "oo", NL ("||"),        2 },
  { "or", NL ("|"),         2 },
  { "pL", NL ("+="),        2 },
  { "pl", NL ("+"),         2 },
  { "pm", NL ("->*"),       2 },
  { "pp", NL ("++"),        1 },
  { "ps", NL ("+"),         1 },
  { "pt", NL ("->"),        2 },
  { "qu", NL ("?"),         3 },
  { "rM", NL ("%="),        2 },
  { "rS", NL (">>="),       2 },
  { "rm", NL ("%"),         2 },
  { "rs", NL (">>"),        2 },
  { "st", NL ("sizeof "),   1 },
  { "sz", NL ("sizeof "),   1 }
a1479 1
  di->expansion += 20;
a1485 1
	  di->expansion -= 5;
a1487 1
	  di->expansion -= 10;
a1527 1
	    di->expansion += 5;
a1612 7
  if (di->last_name != NULL)
    {
      if (di->last_name->type == D_COMP_NAME)
	di->expansion += di->last_name->u.s_name.len;
      else if (di->last_name->type == D_COMP_SUB_STD)
	di->expansion += di->last_name->u.s_string.len;
    }
d1683 26
a1708 26
  /* a */ { NL ("signed char"),	NL ("signed char"),	D_PRINT_INT },
  /* b */ { NL ("bool"),	NL ("boolean"),		D_PRINT_BOOL },
  /* c */ { NL ("char"),	NL ("byte"),		D_PRINT_INT },
  /* d */ { NL ("double"),	NL ("double"),		D_PRINT_DEFAULT },
  /* e */ { NL ("long double"),	NL ("long double"),	D_PRINT_DEFAULT },
  /* f */ { NL ("float"),	NL ("float"),		D_PRINT_DEFAULT },
  /* g */ { NL ("__float128"),	NL ("__float128"),	D_PRINT_DEFAULT },
  /* h */ { NL ("unsigned char"), NL ("unsigned char"),	D_PRINT_INT },
  /* i */ { NL ("int"),		NL ("int"),		D_PRINT_INT },
  /* j */ { NL ("unsigned int"), NL ("unsigned"),	D_PRINT_INT },
  /* k */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* l */ { NL ("long"),	NL ("long"),		D_PRINT_LONG },
  /* m */ { NL ("unsigned long"), NL ("unsigned long"),	D_PRINT_LONG },
  /* n */ { NL ("__int128"),	NL ("__int128"),	D_PRINT_DEFAULT },
  /* o */ { NL ("unsigned __int128"), NL ("unsigned __int128"),	D_PRINT_DEFAULT },
  /* p */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* q */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* r */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* s */ { NL ("short"),	NL ("short"),		D_PRINT_INT },
  /* t */ { NL ("unsigned short"), NL ("unsigned short"), D_PRINT_INT },
  /* u */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* v */ { NL ("void"),	NL ("void"),		D_PRINT_VOID },
  /* w */ { NL ("wchar_t"),	NL ("char"),		D_PRINT_INT },
  /* x */ { NL ("long long"),	NL ("long"),		D_PRINT_DEFAULT },
  /* y */ { NL ("unsigned long long"), NL ("unsigned long long"), D_PRINT_DEFAULT },
  /* z */ { NL ("..."),		NL ("..."),		D_PRINT_DEFAULT },
a1756 1
      di->expansion += ret->u.s_builtin.type->len;
d1887 1
a1887 4
	{
	  t = member_fn ? D_COMP_RESTRICT_THIS : D_COMP_RESTRICT;
	  di->expansion += sizeof "restrict";
	}
d1889 1
a1889 4
	{
	  t = member_fn ? D_COMP_VOLATILE_THIS : D_COMP_VOLATILE;
	  di->expansion += sizeof "volatile";
	}
d1891 1
a1891 4
	{
	  t = member_fn ? D_COMP_CONST_THIS : D_COMP_CONST;
	  di->expansion += sizeof "const";
	}
d1975 1
a1975 4
    {
      di->expansion -= d_left (tl)->u.s_builtin.type->len;
      tl = NULL;
    }
a2095 2
  ++di->did_subs;

a2216 3
      if (op->type == D_COMP_OPERATOR)
	di->expansion += op->u.s_operator.op->len - 2;

a2291 6
      /* If we have a type we know how to print, we aren't going to
	 print the type name itself.  */
      if (type->type == D_COMP_BUILTIN_TYPE
	  && type->u.s_builtin.type->print != D_PRINT_DEFAULT)
	di->expansion -= type->u.s_builtin.type->len;

d2414 15
a2428 21
  { 't', NL ("std"),
    NL ("std"),
    NULL, 0 },
  { 'a', NL ("std::allocator"),
    NL ("std::allocator"),
    NL ("allocator") },
  { 'b', NL ("std::basic_string"),
    NL ("std::basic_string"),
    NL ("basic_string") },
  { 's', NL ("std::string"),
    NL ("std::basic_string<char, std::char_traits<char>, std::allocator<char> >"),
    NL ("basic_string") },
  { 'i', NL ("std::istream"),
    NL ("std::basic_istream<char, std::char_traits<char> >"),
    NL ("basic_istream") },
  { 'o', NL ("std::ostream"),
    NL ("std::basic_ostream<char, std::char_traits<char> >"),
    NL ("basic_ostream") },
  { 'd', NL ("std::iostream"),
    NL ("std::basic_iostream<char, std::char_traits<char> >"),
    NL ("basic_iostream") }
a2466 2
      ++di->did_subs;

a2490 3
	      const char *s;
	      int len;

d2492 1
a2492 2
		di->last_name = d_make_sub (di, p->set_last_name,
					    p->set_last_name_len);
d2494 1
a2494 4
		{
		  s = p->full_expansion;
		  len = p->full_len;
		}
d2496 1
a2496 6
		{
		  s = p->simple_expansion;
		  len = p->simple_len;
		}
	      di->expansion += len;
	      return d_make_sub (di, s, len);
d2588 4
a2591 7
/* Turn components into a human readable string.  OPTIONS is the
   options bits passed to the demangler.  DC is the tree to print.
   ESTIMATE is a guess at the length of the result.  This returns a
   string allocated by malloc, or NULL on error.  On success, this
   sets *PALC to the size of the allocated buffer.  On failure, this
   sets *PALC to 0 for a bad parse, or to 1 for a memory allocation
   failure.  */
d2594 1
a2594 1
d_print (options, dc, estimate, palc)
a2596 1
     int estimate;
d2603 1
a2603 1
  dpi.alc = estimate + 1;
d2647 1
a2647 4
      if ((dpi->options & DMGL_JAVA) == 0)
	d_append_buffer (dpi, dc->u.s_name.s, dc->u.s_name.len);
      else
	d_print_java_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);
d2653 1
a2653 4
      if ((dpi->options & DMGL_JAVA) == 0)
	d_append_string_constant (dpi, "::");
      else
	d_append_char (dpi, '.');
d2840 1
a2840 1
      d_append_string_constant (dpi, "vtable for ");
d2845 1
a2845 1
      d_append_string_constant (dpi, "VTT for ");
d2850 1
a2850 1
      d_append_string_constant (dpi, "construction vtable for ");
d2852 1
a2852 1
      d_append_string_constant (dpi, "-in-");
d2857 1
a2857 1
      d_append_string_constant (dpi, "typeinfo for ");
d2862 1
a2862 1
      d_append_string_constant (dpi, "typeinfo name for ");
d2867 1
a2867 1
      d_append_string_constant (dpi, "typeinfo fn for ");
d2872 1
a2872 1
      d_append_string_constant (dpi, "non-virtual thunk to ");
d2877 1
a2877 1
      d_append_string_constant (dpi, "virtual thunk to ");
d2882 1
a2882 1
      d_append_string_constant (dpi, "covariant return thunk to ");
d2887 1
a2887 1
      d_append_string_constant (dpi, "java Class for ");
d2892 1
a2892 1
      d_append_string_constant (dpi, "guard variable for ");
d2897 1
a2897 1
      d_append_string_constant (dpi, "reference temporary for ");
d2902 1
a2902 1
      d_append_buffer (dpi, dc->u.s_string.string, dc->u.s_string.len);
d2940 1
a2940 2
	d_append_buffer (dpi, dc->u.s_builtin.type->name,
			 dc->u.s_builtin.type->len);
d2942 1
a2942 2
	d_append_buffer (dpi, dc->u.s_builtin.type->java_name,
			 dc->u.s_builtin.type->java_len);
d3022 1
a3022 1
	    d_append_string_constant (dpi, "::*");
d3035 1
a3035 1
	  d_append_string_constant (dpi, ", ");
d3044 1
a3044 1
	d_append_string_constant (dpi, "operator");
d3048 1
a3048 2
	d_append_buffer (dpi, dc->u.s_operator.op->name,
			 dc->u.s_operator.op->len);
d3053 1
a3053 1
      d_append_string_constant (dpi, "operator ");
d3058 1
a3058 1
      d_append_string_constant (dpi, "operator ");
d3067 1
a3067 1
	  d_append_string_constant (dpi, "((");
d3089 1
a3089 2
	  && d_left (dc)->u.s_operator.op->len == 1
	  && d_left (dc)->u.s_operator.op->name[0] == '>')
d3094 1
a3094 1
      d_append_string_constant (dpi, ") ");
d3096 1
a3096 1
      d_append_string_constant (dpi, " (");
d3101 1
a3101 2
	  && d_left (dc)->u.s_operator.op->len == 1
	  && d_left (dc)->u.s_operator.op->name[0] == '>')
d3120 1
a3120 1
      d_append_string_constant (dpi, ") ");
d3122 1
a3122 1
      d_append_string_constant (dpi, " (");
d3124 1
a3124 1
      d_append_string_constant (dpi, ") : (");
d3171 1
a3171 1
		      d_append_string_constant (dpi, "false");
d3174 1
a3174 1
		      d_append_string_constant (dpi, "true");
d3201 1
a3201 4
/* Print a Java dentifier.  For Java we try to handle encoded extended
   Unicode characters.  The C++ ABI doesn't mention Unicode encoding,
   so we don't it for C++.  Characters are encoded as
   __U<hex-char>+_.  */
d3204 1
a3204 1
d_print_java_identifier (dpi, name, len)
d3209 3
a3211 5
  const char *p;
  const char *end;

  end = name + len;
  for (p = name; p < end; ++p)
d3213 2
a3214 7
      if (end - p > 3
	  && p[0] == '_'
	  && p[1] == '_'
	  && p[2] == 'U')
	{
	  unsigned long c;
	  const char *q;
d3216 11
a3226 2
	  c = 0;
	  for (q = p + 3; q < end; ++q)
d3228 7
a3234 1
	      int dig;
d3236 8
a3243 8
	      if (IS_DIGIT (*q))
		dig = *q - '0';
	      else if (*q >= 'A' && *q <= 'F')
		dig = *q - 'A' + 10;
	      else if (*q >= 'a' && *q <= 'f')
		dig = *q - 'a' + 10;
	      else
		break;
d3245 10
a3254 9
	      c = c * 16 + dig;
	    }
	  /* If the Unicode character is larger than 256, we don't try
	     to deal with it here.  FIXME.  */
	  if (q < end && *q == '_' && c < 256)
	    {
	      d_append_char (dpi, c);
	      p = q;
	      continue;
d3256 2
a3258 2

      d_append_char (dpi, *p);
d3318 1
a3318 4
      if ((dpi->options & DMGL_JAVA) == 0)
	d_append_string_constant (dpi, "::");
      else
	d_append_char (dpi, '.');
d3350 1
a3350 1
      d_append_string_constant (dpi, " restrict");
d3354 1
a3354 1
      d_append_string_constant (dpi, " volatile");
d3358 1
a3358 1
      d_append_string_constant (dpi, " const");
d3373 1
a3373 1
      d_append_string_constant (dpi, "complex ");
d3376 1
a3376 1
      d_append_string_constant (dpi, "imaginary ");
d3382 1
a3382 1
      d_append_string_constant (dpi, "::*");
d3516 1
a3516 1
	d_append_string_constant (dpi, " (");
d3543 1
a3543 2
    d_append_buffer (dpi, dc->u.s_operator.op->name,
		     dc->u.s_operator.op->len);
d3595 1
a3595 1
static void
a3602 1
  di->send = mangled + len;
d3611 2
d3618 2
a3620 1
  di->did_subs = 0;
d3624 10
a3633 1
  di->expansion = 0;
a3652 1
  int estimate;
d3688 5
a3692 1
  d_init_info (mangled, options, len, &di);
d3694 4
a3697 22
  {
#ifdef CP_DYNAMIC_ARRAYS
    __extension__ struct d_comp comps[di.num_comps];
    __extension__ struct d_comp *subs[di.num_subs];

    di.comps = &comps[0];
    di.subs = &subs[0];
#else
    di.comps = (struct d_comp *) malloc (di.num_comps
					 * sizeof (struct d_comp));
    di.subs = (struct d_comp **) malloc (di.num_subs
					 * sizeof (struct d_comp *));
    if (di.comps == NULL || di.subs == NULL)
      {
	if (di.comps != NULL)
	  free (di.comps);
	if (di.subs != NULL)
	  free (di.subs);
	*palc = 1;
	return NULL;
      }
#endif
d3699 6
a3704 11
    if (! type)
      dc = d_mangled_name (&di, 1);
    else
      dc = d_type (&di);

    /* If DMGL_PARAMS is set, then if we didn't consume the entire
       mangled string, then we didn't successfully demangle it.  If
       DMGL_PARAMS is not set, we didn't look at the trailing
       parameters.  */
    if (((options & DMGL_PARAMS) != 0) && d_peek_char (&di) != '\0')
      dc = NULL;
d3707 4
a3710 4
    if (dc == NULL)
      printf ("failed demangling\n");
    else
      d_dump (dc, 0);
d3713 2
a3714 13
    /* We try to guess the length of the demangled string, to minimize
       calls to realloc during demangling.  */
    estimate = len + di.expansion + 10 * di.did_subs;
    estimate += estimate / 8;

    ret = NULL;
    if (dc != NULL)
      ret = d_print (options, dc, estimate, palc);

#ifndef CP_DYNAMIC_ARRAYS
    free (di.comps);
    free (di.subs);
#endif
d3716 3
a3718 4
#ifdef CP_DEMANGLE_DEBUG
    if (ret != NULL)
      {
	int rlen;
d3720 1
a3720 13
	rlen = strlen (ret);
	if (rlen > 2 * estimate)
	  printf ("*** Length %d much greater than estimate %d\n",
		  rlen, estimate);
	else if (rlen > estimate)
	  printf ("*** Length %d greater than estimate %d\n",
		  rlen, estimate);
	else if (rlen < estimate / 2)
	  printf ("*** Length %d much less than estimate %d\n",
		  rlen, estimate);
      }
#endif
  }
d3903 2
a3904 1
  d_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di);
d3906 1
a3906 22
  {
#ifdef CP_DYNAMIC_ARRAYS
    __extension__ struct d_comp comps[di.num_comps];
    __extension__ struct d_comp *subs[di.num_subs];

    di.comps = &comps[0];
    di.subs = &subs[0];
#else
    di.comps = (struct d_comp *) malloc (di.num_comps
					 * sizeof (struct d_comp));
    di.subs = (struct d_comp **) malloc (di.num_subs
					 * sizeof (struct d_comp *));
    if (di.comps == NULL || di.subs == NULL)
      {
	if (di.comps != NULL)
	  free (di.comps);
	if (di.subs != NULL)
	  free (di.subs);
	*palc = 1;
	return NULL;
      }
#endif
d3908 2
a3909 1
    dc = d_mangled_name (&di, 1);
d3911 31
a3941 2
    /* Note that because we did not pass DMGL_PARAMS, we don't expect
       to demangle the entire string.  */
d3943 2
a3944 37
    ret = 0;
    while (dc != NULL)
      {
	switch (dc->type)
	  {
	  default:
	    dc = NULL;
	    break;
	  case D_COMP_TYPED_NAME:
	  case D_COMP_TEMPLATE:
	  case D_COMP_RESTRICT_THIS:
	  case D_COMP_VOLATILE_THIS:
	  case D_COMP_CONST_THIS:
	    dc = d_left (dc);
	    break;
	  case D_COMP_QUAL_NAME:
	  case D_COMP_LOCAL_NAME:
	    dc = d_right (dc);
	    break;
	  case D_COMP_CTOR:
	    *ctor_kind = dc->u.s_ctor.kind;
	    ret = 1;
	    dc = NULL;
	    break;
	  case D_COMP_DTOR:
	    *dtor_kind = dc->u.s_dtor.kind;
	    ret = 1;
	    dc = NULL;
	    break;
	  }
      }

#ifndef CP_DYNAMIC_ARRAYS
    free (di.subs);
    free (di.comps);
#endif
  }
@


1.27.4.4
log
@	* cp-demangle.c: Include cp-demangle.h.  Export some public
	functions and variables.
	(cp_v3_d_init_info_alloc, cp_v3_d_free_info): New functions.
	(d_make_operator_from_string): New function.
	(cp_v3_d_make_empty, cp_v3_d_make_comp, cp_v3_d_make_name)
	(cp_v3_d_make_builtin_type, cp_v3_d_make_extended_operator)
	(cp_v3_d_make_ctor, cp_v3_d_make_dtor, cp_v3_d_print): Renamed
	and made global.  Update calls to renamed functions.

	(d_make_template_param, d_make_sub, d_encoding, d_name, d_prefix)
	(d_identifier, d_operator_name, d_special_name, d_ctor_dtor_name)
	(d_type, d_cv_qualifiers, d_bare_function_type, d_array_type)
	(d_pointer_to_member_type, d_template_args, d_expression)
	(d_expr_primary, d_local_name, d_demangle): Update calls to renamed
	functions.

	(cp_v3_d_make_builtin_type): Accept a character instead of a pointer
	to struct d_builtin_type_info.
	(d_type): Update call to d_make_builtin_type.

	* Makefile.in: Update dependencies for cp-demangle.o.
@
text
@a84 3
#define IN_CP_DEMANGLE
#include "cp-demangle.h"

d132 32
d187 184
d493 8
d503 9
d551 1
d755 2
a756 2
struct d_comp *
cp_v3_d_make_empty (di, type)
d772 2
a773 2
struct d_comp *
cp_v3_d_make_comp (di, type, left, right)
d853 1
a853 1
  p = cp_v3_d_make_empty (di, type);
d864 2
a865 2
struct d_comp *
cp_v3_d_make_name (di, s, len)
d874 1
a874 1
  p = cp_v3_d_make_empty (di, D_COMP_NAME);
d885 2
a886 34
#define NL(s) s, (sizeof s) - 1

const struct d_builtin_type_info d_builtin_types[26] =
{
  /* a */ { NL ("signed char"),	NL ("signed char"),	D_PRINT_INT },
  /* b */ { NL ("bool"),	NL ("boolean"),		D_PRINT_BOOL },
  /* c */ { NL ("char"),	NL ("byte"),		D_PRINT_INT },
  /* d */ { NL ("double"),	NL ("double"),		D_PRINT_DEFAULT },
  /* e */ { NL ("long double"),	NL ("long double"),	D_PRINT_DEFAULT },
  /* f */ { NL ("float"),	NL ("float"),		D_PRINT_DEFAULT },
  /* g */ { NL ("__float128"),	NL ("__float128"),	D_PRINT_DEFAULT },
  /* h */ { NL ("unsigned char"), NL ("unsigned char"),	D_PRINT_INT },
  /* i */ { NL ("int"),		NL ("int"),		D_PRINT_INT },
  /* j */ { NL ("unsigned int"), NL ("unsigned"),	D_PRINT_INT },
  /* k */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* l */ { NL ("long"),	NL ("long"),		D_PRINT_LONG },
  /* m */ { NL ("unsigned long"), NL ("unsigned long"),	D_PRINT_LONG },
  /* n */ { NL ("__int128"),	NL ("__int128"),	D_PRINT_DEFAULT },
  /* o */ { NL ("unsigned __int128"), NL ("unsigned __int128"),	D_PRINT_DEFAULT },
  /* p */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* q */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* r */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* s */ { NL ("short"),	NL ("short"),		D_PRINT_INT },
  /* t */ { NL ("unsigned short"), NL ("unsigned short"), D_PRINT_INT },
  /* u */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* v */ { NL ("void"),	NL ("void"),		D_PRINT_VOID },
  /* w */ { NL ("wchar_t"),	NL ("char"),		D_PRINT_INT },
  /* x */ { NL ("long long"),	NL ("long"),		D_PRINT_DEFAULT },
  /* y */ { NL ("unsigned long long"), NL ("unsigned long long"), D_PRINT_DEFAULT },
  /* z */ { NL ("..."),		NL ("..."),		D_PRINT_DEFAULT },
};

struct d_comp *
cp_v3_d_make_builtin_type (di, c)
d888 1
a888 1
     int c;
a890 1
  const struct d_builtin_type_info *type;
a891 1
  type = &d_builtin_types[c - 'a'];
d894 1
a894 1
  p = cp_v3_d_make_empty (di, D_COMP_BUILTIN_TYPE);
d909 1
a909 1
  p = cp_v3_d_make_empty (di, D_COMP_OPERATOR);
d917 2
a918 2
struct d_comp *
cp_v3_d_make_extended_operator (di, args, name)
d927 1
a927 1
  p = cp_v3_d_make_empty (di, D_COMP_EXTENDED_OPERATOR);
d938 2
a939 2
struct d_comp *
cp_v3_d_make_ctor (di, kind,  name)
d948 1
a948 1
  p = cp_v3_d_make_empty (di, D_COMP_CTOR);
d959 2
a960 2
struct d_comp *
cp_v3_d_make_dtor (di, kind, name)
d969 1
a969 1
  p = cp_v3_d_make_empty (di, D_COMP_DTOR);
d987 1
a987 1
  p = cp_v3_d_make_empty (di, D_COMP_TEMPLATE_PARAM);
d1003 1
a1003 1
  p = cp_v3_d_make_empty (di, D_COMP_SUB_STD);
d1118 1
a1118 1
      return cp_v3_d_make_comp (di, D_COMP_TYPED_NAME, dc,
d1162 1
a1162 1
	    dc = cp_v3_d_make_comp (di, D_COMP_QUAL_NAME, cp_v3_d_make_name (di, "std", 3),
d1185 1
a1185 1
	    dc = cp_v3_d_make_comp (di, D_COMP_TEMPLATE, dc, d_template_args (di));
d1200 1
a1200 1
	  dc = cp_v3_d_make_comp (di, D_COMP_TEMPLATE, dc, d_template_args (di));
d1290 1
a1290 1
	ret = cp_v3_d_make_comp (di, comb_type, ret, dc);
d1417 1
a1417 1
	  return cp_v3_d_make_name (di, "(anonymous namespace)",
d1422 1
a1422 1
  return cp_v3_d_make_name (di, name, len);
d1430 3
a1432 1
const struct d_operator_info d_operators[] =
d1495 1
a1495 1
    return cp_v3_d_make_extended_operator (di, c2 - '0', d_source_name (di));
d1497 1
a1497 1
    return cp_v3_d_make_comp (di, D_COMP_CAST, d_type (di), NULL);
a1523 16
struct d_comp *
cp_v3_d_make_operator_from_string (di, opname)
     struct d_info *di;
     const char *opname;
{
  unsigned int i;

  for (i = 0; i < ARRAY_SIZE (d_operators); i++)
    {
      if (strcmp (d_operators[i].name, opname) == 0)
        return d_make_operator (di, &d_operators[i]);
    }

  return NULL;
}

d1552 1
a1552 1
	  return cp_v3_d_make_comp (di, D_COMP_VTABLE, d_type (di), NULL);
d1555 1
a1555 1
	  return cp_v3_d_make_comp (di, D_COMP_VTT, d_type (di), NULL);
d1557 1
a1557 1
	  return cp_v3_d_make_comp (di, D_COMP_TYPEINFO, d_type (di), NULL);
d1559 1
a1559 1
	  return cp_v3_d_make_comp (di, D_COMP_TYPEINFO_NAME, d_type (di), NULL);
d1564 1
a1564 1
	  return cp_v3_d_make_comp (di, D_COMP_THUNK, d_encoding (di, 0), NULL);
d1569 1
a1569 1
	  return cp_v3_d_make_comp (di, D_COMP_VIRTUAL_THUNK, d_encoding (di, 0),
d1577 1
a1577 1
	  return cp_v3_d_make_comp (di, D_COMP_COVARIANT_THUNK, d_encoding (di, 0),
d1596 1
a1596 1
	    return cp_v3_d_make_comp (di, D_COMP_CONSTRUCTION_VTABLE, base_type,
d1601 1
a1601 1
	  return cp_v3_d_make_comp (di, D_COMP_TYPEINFO_FN, d_type (di), NULL);
d1603 1
a1603 1
	  return cp_v3_d_make_comp (di, D_COMP_JAVA_CLASS, d_type (di), NULL);
d1614 1
a1614 1
	  return cp_v3_d_make_comp (di, D_COMP_GUARD, d_name (di), NULL);
d1617 1
a1617 1
	  return cp_v3_d_make_comp (di, D_COMP_REFTEMP, d_name (di), NULL);
d1708 1
a1708 1
	return cp_v3_d_make_ctor (di, kind, di->last_name);
d1729 1
a1729 1
	return cp_v3_d_make_dtor (di, kind, di->last_name);
d1756 30
d1831 1
a1831 1
      ret = cp_v3_d_make_builtin_type (di, peek);
d1839 1
a1839 1
      ret = cp_v3_d_make_comp (di, D_COMP_VENDOR_TYPE, d_source_name (di), NULL);
d1870 1
a1870 1
	  ret = cp_v3_d_make_comp (di, D_COMP_TEMPLATE, ret, d_template_args (di));
d1889 1
a1889 1
	      ret = cp_v3_d_make_comp (di, D_COMP_TEMPLATE, ret,
d1909 1
a1909 1
      ret = cp_v3_d_make_comp (di, D_COMP_POINTER, d_type (di), NULL);
d1914 1
a1914 1
      ret = cp_v3_d_make_comp (di, D_COMP_REFERENCE, d_type (di), NULL);
d1919 1
a1919 1
      ret = cp_v3_d_make_comp (di, D_COMP_COMPLEX, d_type (di), NULL);
d1924 1
a1924 1
      ret = cp_v3_d_make_comp (di, D_COMP_IMAGINARY, d_type (di), NULL);
d1930 1
a1930 1
      ret = cp_v3_d_make_comp (di, D_COMP_VENDOR_TYPE_QUAL, d_type (di), ret);
d1978 1
a1978 1
      *pret = cp_v3_d_make_comp (di, t, NULL, NULL);
d2043 1
a2043 1
	  *ptl = cp_v3_d_make_comp (di, D_COMP_ARGLIST, type, NULL);
d2065 1
a2065 1
  return cp_v3_d_make_comp (di, D_COMP_FUNCTION_TYPE, return_type, tl);
d2105 1
a2105 1
      dim = cp_v3_d_make_name (di, s, d_str (di) - s);
d2119 1
a2119 1
  return cp_v3_d_make_comp (di, D_COMP_ARRAY_TYPE, dim, d_type (di));
d2155 1
a2155 1
  return cp_v3_d_make_comp (di, D_COMP_PTRMEM_TYPE, cl, mem);
d2217 1
a2217 1
      *pal = cp_v3_d_make_comp (di, D_COMP_TEMPLATE_ARGLIST, a, NULL);
d2292 1
a2292 1
	return cp_v3_d_make_comp (di, D_COMP_QUAL_NAME, type, name);
d2294 2
a2295 2
	return cp_v3_d_make_comp (di, D_COMP_QUAL_NAME, type,
			    cp_v3_d_make_comp (di, D_COMP_TEMPLATE, name,
d2312 1
a2312 1
	return cp_v3_d_make_comp (di, D_COMP_UNARY, op, d_type (di));
d2332 1
a2332 1
	  return cp_v3_d_make_comp (di, D_COMP_UNARY, op, d_expression (di));
d2338 2
a2339 2
	    return cp_v3_d_make_comp (di, D_COMP_BINARY, op,
				cp_v3_d_make_comp (di, D_COMP_BINARY_ARGS, left,
d2349 3
a2351 3
	    return cp_v3_d_make_comp (di, D_COMP_TRINARY, op,
				cp_v3_d_make_comp (di, D_COMP_TRINARY_ARG1, first,
					     cp_v3_d_make_comp (di,
d2411 1
a2411 1
      ret = cp_v3_d_make_comp (di, t, type, cp_v3_d_make_name (di, s, d_str (di) - s));
d2441 2
a2442 2
      return cp_v3_d_make_comp (di, D_COMP_LOCAL_NAME, function,
			  cp_v3_d_make_name (di, "string literal",
d2452 1
a2452 1
      return cp_v3_d_make_comp (di, D_COMP_LOCAL_NAME, function, name);
d2715 2
a2716 2
char *
cp_v3_d_print (options, dc, estimate, palc)
a3756 54
/* Allocate and initialize a d_info structure.  The demangler bypasses
   this in order to allocate everything on the stack, for speed.  */

struct d_info *
cp_v3_d_init_info_alloc (mangled, options, len)
     const char *mangled;
     int options;
     size_t len;
{
  struct d_info *di;

  di = (struct d_info *) malloc (sizeof (struct d_info));
  if (di == NULL)
    return NULL;

  d_init_info (mangled, options, len, di);
  di->comps = (struct d_comp *) malloc (di->num_comps
					* sizeof (struct d_comp));
  if (di->comps == NULL)
    {
      free (di);
      return NULL;
    }

  if (mangled != NULL)
    {
      di->subs = (struct d_comp **) malloc (di->num_subs
					    * sizeof (struct d_comp *));
      if (di->subs == NULL)
	{
	  free (di->comps);
	  free (di);
	  return NULL;
	}
    }
  else
    di->subs = NULL;

  return di;
}

/* Release a d_info structure, as allocated by cp_v3_d_init_info_alloc.  */

void
cp_v3_d_free_info (di)
     struct d_info *di;
{
  if (di->comps != NULL)
    free (di->comps);
  if (di->subs != NULL)
    free (di->subs);
  free (di);
}

d3861 1
a3861 1
      ret = cp_v3_d_print (options, dc, estimate, palc);
@


1.27.4.5
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
a47 16
   Also, the interface to the component list is public, and defined in
   demangle.h.  The interface consists of these types, which are
   defined in demangle.h:
      enum demangle_component_type
      struct demangle_component
   and these functions defined in this file:
      cplus_demangle_fill_name
      cplus_demangle_fill_extended_operator
      cplus_demangle_fill_ctor
      cplus_demangle_fill_dtor
      cplus_demangle_print
   and other functions defined in the file cp-demint.c.

   This file also defines some other functions and variables which are
   only to be used by the file cp-demint.c.

d57 1
a57 2
      If defined, this file defines only __cxa_demangle(), and no other
      publically visible functions or variables.
d84 2
a87 47
/* If IN_GLIBCPP_V3 is defined, some functions are made static.  We
   also rename them via #define to avoid compiler errors when the
   static definition conflicts with the extern declaration in a header
   file.  */
#ifdef IN_GLIBCPP_V3

#define CP_STATIC_IF_GLIBCPP_V3 static

#define cplus_demangle_fill_name d_fill_name
static int
d_fill_name PARAMS ((struct demangle_component *, const char *, int));

#define cplus_demangle_fill_extended_operator d_fill_extended_operator
static int
d_fill_extended_operator PARAMS ((struct demangle_component *, int,
				  struct demangle_component *));

#define cplus_demangle_fill_ctor d_fill_ctor
static int
d_fill_ctor PARAMS ((struct demangle_component *, enum gnu_v3_ctor_kinds,
		     struct demangle_component *));

#define cplus_demangle_fill_dtor d_fill_dtor
static int
d_fill_dtor PARAMS ((struct demangle_component *, enum gnu_v3_dtor_kinds,
		     struct demangle_component *));

#define cplus_demangle_mangled_name d_mangled_name
static struct demangle_component *
d_mangled_name PARAMS ((struct d_info *, int));

#define cplus_demangle_type d_type
static struct demangle_component *
d_type PARAMS ((struct d_info *));

#define cplus_demangle_print d_print
static char *
d_print PARAMS ((int, const struct demangle_component *, int, size_t *));

#define cplus_demangle_init_info d_init_info
static void
d_init_info PARAMS ((const char *, int, size_t, struct d_info *));

#else /* ! defined(IN_GLIBCPP_V3) */
#define CP_STATIC_IF_GLIBCPP_V3
#endif /* ! defined(IN_GLIBCPP_V3) */

d121 14
d158 1
a158 1
/* Accessors for subtrees of struct demangle_component.  */
d160 39
a198 2
#define d_left(dc) ((dc)->u.s_binary.left)
#define d_right(dc) ((dc)->u.s_binary.right)
d207 1
a207 1
  const struct demangle_component *template;
d218 1
a218 1
  const struct demangle_component *mod;
d278 1
a278 2
static void 
d_dump PARAMS ((struct demangle_component *, int));
d280 61
a340 171

static struct demangle_component *
d_make_empty PARAMS ((struct d_info *));

static struct demangle_component *
d_make_comp PARAMS ((struct d_info *, enum demangle_component_type,
		     struct demangle_component *,
		     struct demangle_component *));

static struct demangle_component *
d_make_name PARAMS ((struct d_info *, const char *, int));

static struct demangle_component *
d_make_builtin_type PARAMS ((struct d_info *,
			     const struct demangle_builtin_type_info *));

static struct demangle_component *
d_make_operator PARAMS ((struct d_info *,
			 const struct demangle_operator_info *));

static struct demangle_component *
d_make_extended_operator PARAMS ((struct d_info *, int,
				  struct demangle_component *));

static struct demangle_component *
d_make_ctor PARAMS ((struct d_info *, enum gnu_v3_ctor_kinds,
		     struct demangle_component *));

static struct demangle_component *
d_make_dtor PARAMS ((struct d_info *, enum gnu_v3_dtor_kinds,
		     struct demangle_component *));

static struct demangle_component *
d_make_template_param PARAMS ((struct d_info *, long));

static struct demangle_component *
d_make_sub PARAMS ((struct d_info *, const char *, int));

static int
has_return_type PARAMS ((struct demangle_component *));

static int
is_ctor_dtor_or_conversion PARAMS ((struct demangle_component *));

static struct demangle_component *
d_encoding PARAMS ((struct d_info *, int));

static struct demangle_component *
d_name PARAMS ((struct d_info *));

static struct demangle_component *
d_nested_name PARAMS ((struct d_info *));

static struct demangle_component *
d_prefix PARAMS ((struct d_info *));

static struct demangle_component *
d_unqualified_name PARAMS ((struct d_info *));

static struct demangle_component *
d_source_name PARAMS ((struct d_info *));

static long
d_number PARAMS ((struct d_info *));

static struct demangle_component *
d_identifier PARAMS ((struct d_info *, int));

static struct demangle_component *
d_operator_name PARAMS ((struct d_info *));

static struct demangle_component *
d_special_name PARAMS ((struct d_info *));

static int
d_call_offset PARAMS ((struct d_info *, int));

static struct demangle_component *
d_ctor_dtor_name PARAMS ((struct d_info *));

static struct demangle_component **
d_cv_qualifiers PARAMS ((struct d_info *, struct demangle_component **, int));

static struct demangle_component *
d_function_type PARAMS ((struct d_info *));

static struct demangle_component *
d_bare_function_type PARAMS ((struct d_info *, int));

static struct demangle_component *
d_class_enum_type PARAMS ((struct d_info *));

static struct demangle_component *
d_array_type PARAMS ((struct d_info *));

static struct demangle_component *
d_pointer_to_member_type PARAMS ((struct d_info *));

static struct demangle_component *
d_template_param PARAMS ((struct d_info *));

static struct demangle_component *
d_template_args PARAMS ((struct d_info *));

static struct demangle_component *
d_template_arg PARAMS ((struct d_info *));

static struct demangle_component *
d_expression PARAMS ((struct d_info *));

static struct demangle_component *
d_expr_primary PARAMS ((struct d_info *));

static struct demangle_component *
d_local_name PARAMS ((struct d_info *));

static int
d_discriminator PARAMS ((struct d_info *));

static int
d_add_substitution PARAMS ((struct d_info *, struct demangle_component *));

static struct demangle_component *
d_substitution PARAMS ((struct d_info *, int));

static void
d_print_resize PARAMS ((struct d_print_info *, size_t));

static void
d_print_append_char PARAMS ((struct d_print_info *, int));

static void
d_print_append_buffer PARAMS ((struct d_print_info *, const char *, size_t));

static void
d_print_error PARAMS ((struct d_print_info *));

static void
d_print_comp PARAMS ((struct d_print_info *,
		      const struct demangle_component *));

static void
d_print_java_identifier PARAMS ((struct d_print_info *, const char *, int));

static void
d_print_mod_list PARAMS ((struct d_print_info *, struct d_print_mod *, int));

static void
d_print_mod PARAMS ((struct d_print_info *,
		     const struct demangle_component *));

static void
d_print_function_type PARAMS ((struct d_print_info *,
			       const struct demangle_component *,
			       struct d_print_mod *));

static void
d_print_array_type PARAMS ((struct d_print_info *,
			    const struct demangle_component *,
			    struct d_print_mod *));

static void
d_print_expr_op PARAMS ((struct d_print_info *,
			 const struct demangle_component *));

static void
d_print_cast PARAMS ((struct d_print_info *,
		      const struct demangle_component *));

static char *
d_demangle PARAMS ((const char *, int, size_t *));
d346 1
a346 1
     struct demangle_component *dc;
d359 1
a359 1
    case DEMANGLE_COMPONENT_NAME:
d362 1
a362 1
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
d365 1
a365 1
    case DEMANGLE_COMPONENT_CTOR:
d369 1
a369 1
    case DEMANGLE_COMPONENT_DTOR:
d373 1
a373 1
    case DEMANGLE_COMPONENT_SUB_STD:
d376 1
a376 1
    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
d379 1
a379 1
    case DEMANGLE_COMPONENT_OPERATOR:
d382 1
a382 1
    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
d388 1
a388 1
    case DEMANGLE_COMPONENT_QUAL_NAME:
d391 1
a391 1
    case DEMANGLE_COMPONENT_LOCAL_NAME:
d394 1
a394 1
    case DEMANGLE_COMPONENT_TYPED_NAME:
d397 1
a397 1
    case DEMANGLE_COMPONENT_TEMPLATE:
d400 1
a400 1
    case DEMANGLE_COMPONENT_VTABLE:
d403 1
a403 1
    case DEMANGLE_COMPONENT_VTT:
d406 1
a406 1
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
d409 1
a409 1
    case DEMANGLE_COMPONENT_TYPEINFO:
d412 1
a412 1
    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
d415 1
a415 1
    case DEMANGLE_COMPONENT_TYPEINFO_FN:
d418 1
a418 1
    case DEMANGLE_COMPONENT_THUNK:
d421 1
a421 1
    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
d424 1
a424 1
    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
d427 1
a427 1
    case DEMANGLE_COMPONENT_JAVA_CLASS:
d430 1
a430 1
    case DEMANGLE_COMPONENT_GUARD:
d433 1
a433 1
    case DEMANGLE_COMPONENT_REFTEMP:
d436 1
a436 1
    case DEMANGLE_COMPONENT_RESTRICT:
d439 1
a439 1
    case DEMANGLE_COMPONENT_VOLATILE:
d442 1
a442 1
    case DEMANGLE_COMPONENT_CONST:
d445 1
a445 1
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
d448 1
a448 1
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
d451 1
a451 1
    case DEMANGLE_COMPONENT_CONST_THIS:
d454 1
a454 1
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
d457 1
a457 1
    case DEMANGLE_COMPONENT_POINTER:
d460 1
a460 1
    case DEMANGLE_COMPONENT_REFERENCE:
d463 1
a463 1
    case DEMANGLE_COMPONENT_COMPLEX:
d466 1
a466 1
    case DEMANGLE_COMPONENT_IMAGINARY:
d469 1
a469 1
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
d472 1
a472 1
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
d475 1
a475 1
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
d478 1
a478 1
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
d481 1
a481 1
    case DEMANGLE_COMPONENT_ARGLIST:
d484 1
a484 1
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
d487 1
a487 1
    case DEMANGLE_COMPONENT_CAST:
d490 1
a490 1
    case DEMANGLE_COMPONENT_UNARY:
d493 1
a493 1
    case DEMANGLE_COMPONENT_BINARY:
d496 1
a496 1
    case DEMANGLE_COMPONENT_BINARY_ARGS:
d499 1
a499 1
    case DEMANGLE_COMPONENT_TRINARY:
d502 1
a502 1
    case DEMANGLE_COMPONENT_TRINARY_ARG1:
d505 1
a505 1
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
d508 1
a508 1
    case DEMANGLE_COMPONENT_LITERAL:
d511 1
a511 1
    case DEMANGLE_COMPONENT_LITERAL_NEG:
a521 74
/* Fill in a DEMANGLE_COMPONENT_NAME.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_name (p, s, len)
     struct demangle_component *p;
     const char *s;
     int len;
{
  if (p == NULL || s == NULL || len == 0)
    return 0;
  p->type = DEMANGLE_COMPONENT_NAME;
  p->u.s_name.s = s;
  p->u.s_name.len = len;
  return 1;
}

/* Fill in a DEMANGLE_COMPONENT_EXTENDED_OPERATOR.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_extended_operator (p, args, name)
     struct demangle_component *p;
     int args;
     struct demangle_component *name;
{
  if (p == NULL || args < 0 || name == NULL)
    return 0;
  p->type = DEMANGLE_COMPONENT_EXTENDED_OPERATOR;
  p->u.s_extended_operator.args = args;
  p->u.s_extended_operator.name = name;
  return 1;
}

/* Fill in a DEMANGLE_COMPONENT_CTOR.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_ctor (p, kind, name)
     struct demangle_component *p;
     enum gnu_v3_ctor_kinds kind;
     struct demangle_component *name;
{
  if (p == NULL
      || name == NULL
      || (kind < gnu_v3_complete_object_ctor
	  && kind > gnu_v3_complete_object_allocating_ctor))
    return 0;
  p->type = DEMANGLE_COMPONENT_CTOR;
  p->u.s_ctor.kind = kind;
  p->u.s_ctor.name = name;
  return 1;
}

/* Fill in a DEMANGLE_COMPONENT_DTOR.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_dtor (p, kind, name)
     struct demangle_component *p;
     enum gnu_v3_dtor_kinds kind;
     struct demangle_component *name;
{
  if (p == NULL
      || name == NULL
      || (kind < gnu_v3_deleting_dtor
	  && kind > gnu_v3_base_object_dtor))
    return 0;
  p->type = DEMANGLE_COMPONENT_DTOR;
  p->u.s_dtor.kind = kind;
  p->u.s_dtor.name = name;
  return 1;
}

d524 2
a525 2
static struct demangle_component *
d_make_empty (di)
d527 1
d529 1
a529 1
  struct demangle_component *p;
d534 1
d541 2
a542 2
static struct demangle_component *
d_make_comp (di, type, left, right)
d544 3
a546 3
     enum demangle_component_type type;
     struct demangle_component *left;
     struct demangle_component *right;
d548 1
a548 1
  struct demangle_component *p;
d556 14
a569 14
    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
    case DEMANGLE_COMPONENT_TYPED_NAME:
    case DEMANGLE_COMPONENT_TEMPLATE:
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
    case DEMANGLE_COMPONENT_UNARY:
    case DEMANGLE_COMPONENT_BINARY:
    case DEMANGLE_COMPONENT_BINARY_ARGS:
    case DEMANGLE_COMPONENT_TRINARY:
    case DEMANGLE_COMPONENT_TRINARY_ARG1:
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
    case DEMANGLE_COMPONENT_LITERAL:
    case DEMANGLE_COMPONENT_LITERAL_NEG:
d575 20
a594 20
    case DEMANGLE_COMPONENT_VTABLE:
    case DEMANGLE_COMPONENT_VTT:
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
    case DEMANGLE_COMPONENT_TYPEINFO:
    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
    case DEMANGLE_COMPONENT_TYPEINFO_FN:
    case DEMANGLE_COMPONENT_THUNK:
    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
    case DEMANGLE_COMPONENT_JAVA_CLASS:
    case DEMANGLE_COMPONENT_GUARD:
    case DEMANGLE_COMPONENT_REFTEMP:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_REFERENCE:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
    case DEMANGLE_COMPONENT_ARGLIST:
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
    case DEMANGLE_COMPONENT_CAST:
d601 1
a601 1
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
d608 7
a614 7
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
d622 1
a622 1
  p = d_make_empty (di);
a624 1
      p->type = type;
d633 2
a634 2
static struct demangle_component *
d_make_name (di, s, len)
d639 1
a639 1
  struct demangle_component *p;
d641 1
a641 2
  p = d_make_empty (di);
  if (! cplus_demangle_fill_name (p, s, len))
d643 6
d654 34
a687 2
static struct demangle_component *
d_make_builtin_type (di, type)
d689 1
a689 1
     const struct demangle_builtin_type_info *type;
d691 2
a692 1
  struct demangle_component *p;
d694 1
d697 1
a697 1
  p = d_make_empty (di);
d699 1
a699 4
    {
      p->type = DEMANGLE_COMPONENT_BUILTIN_TYPE;
      p->u.s_builtin.type = type;
    }
d705 1
a705 1
static struct demangle_component *
d708 1
a708 1
     const struct demangle_operator_info *op;
d710 1
a710 1
  struct demangle_component *p;
d712 1
a712 1
  p = d_make_empty (di);
d714 1
a714 4
    {
      p->type = DEMANGLE_COMPONENT_OPERATOR;
      p->u.s_operator.op = op;
    }
d720 2
a721 2
static struct demangle_component *
d_make_extended_operator (di, args, name)
d724 1
a724 1
     struct demangle_component *name;
d726 1
a726 1
  struct demangle_component *p;
d728 1
a728 2
  p = d_make_empty (di);
  if (! cplus_demangle_fill_extended_operator (p, args, name))
d730 6
d741 2
a742 2
static struct demangle_component *
d_make_ctor (di, kind,  name)
d745 1
a745 1
     struct demangle_component *name;
d747 1
a747 1
  struct demangle_component *p;
d749 1
a749 2
  p = d_make_empty (di);
  if (! cplus_demangle_fill_ctor (p, kind, name))
d751 6
d762 2
a763 2
static struct demangle_component *
d_make_dtor (di, kind, name)
d766 1
a766 1
     struct demangle_component *name;
d768 1
a768 1
  struct demangle_component *p;
d770 1
a770 2
  p = d_make_empty (di);
  if (! cplus_demangle_fill_dtor (p, kind, name))
d772 6
d783 1
a783 1
static struct demangle_component *
d788 1
a788 1
  struct demangle_component *p;
d790 1
a790 1
  p = d_make_empty (di);
d792 1
a792 4
    {
      p->type = DEMANGLE_COMPONENT_TEMPLATE_PARAM;
      p->u.s_number.number = i;
    }
d798 1
a798 1
static struct demangle_component *
d804 1
a804 1
  struct demangle_component *p;
d806 1
a806 1
  p = d_make_empty (di);
a808 1
      p->type = DEMANGLE_COMPONENT_SUB_STD;
d819 2
a820 3
CP_STATIC_IF_GLIBCPP_V3
struct demangle_component *
cplus_demangle_mangled_name (di, top_level)
d842 1
a842 1
     struct demangle_component *dc;
d850 1
a850 1
    case DEMANGLE_COMPONENT_TEMPLATE:
d852 3
a854 3
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
d864 1
a864 1
     struct demangle_component *dc;
d872 2
a873 2
    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
d875 3
a877 3
    case DEMANGLE_COMPONENT_CTOR:
    case DEMANGLE_COMPONENT_DTOR:
    case DEMANGLE_COMPONENT_CAST:
d891 1
a891 1
static struct demangle_component *
d902 1
a902 1
      struct demangle_component *dc;
d911 3
a913 3
	  while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS
		 || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS
		 || dc->type == DEMANGLE_COMPONENT_CONST_THIS)
a914 17

	  /* If the top level is a DEMANGLE_COMPONENT_LOCAL_NAME, then
	     there may be CV-qualifiers on its right argument which
	     really apply here; this happens when parsing a class
	     which is local to a function.  */
	  if (dc->type == DEMANGLE_COMPONENT_LOCAL_NAME)
	    {
	      struct demangle_component *dcr;

	      dcr = d_right (dc);
	      while (dcr->type == DEMANGLE_COMPONENT_RESTRICT_THIS
		     || dcr->type == DEMANGLE_COMPONENT_VOLATILE_THIS
		     || dcr->type == DEMANGLE_COMPONENT_CONST_THIS)
		dcr = d_left (dcr);
	      dc->u.s_binary.right = dcr;
	    }

d921 1
a921 1
      return d_make_comp (di, DEMANGLE_COMPONENT_TYPED_NAME, dc,
d938 1
a938 1
static struct demangle_component *
d943 1
a943 1
  struct demangle_component *dc;
d965 1
a965 2
	    dc = d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME,
			      d_make_name (di, "std", 3),
d988 1
a988 2
	    dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,
			      d_template_args (di));
d1003 1
a1003 2
	  dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,
			    d_template_args (di));
d1013 1
a1013 1
static struct demangle_component *
d1017 2
a1018 2
  struct demangle_component *ret;
  struct demangle_component **pret;
d1048 1
a1048 1
static struct demangle_component *
d1052 1
a1052 1
  struct demangle_component *ret = NULL;
d1057 2
a1058 2
      enum demangle_component_type comb_type;
      struct demangle_component *dc;
d1068 1
a1068 1
      comb_type = DEMANGLE_COMPONENT_QUAL_NAME;
d1080 1
a1080 1
	  comb_type = DEMANGLE_COMPONENT_TEMPLATE;
d1093 1
a1093 1
	ret = d_make_comp (di, comb_type, ret, dc);
d1108 1
a1108 1
static struct demangle_component *
d1119 1
a1119 1
      struct demangle_component *ret;
d1122 1
a1122 1
      if (ret != NULL && ret->type == DEMANGLE_COMPONENT_OPERATOR)
d1134 1
a1134 1
static struct demangle_component *
d1139 1
a1139 1
  struct demangle_component *ret;
d1185 1
a1185 1
static struct demangle_component *
d1220 1
a1220 1
	  return d_make_name (di, "(anonymous namespace)",
d1225 1
a1225 1
  return d_make_name (di, name, len);
d1233 1
a1233 4
#define NL(s) s, (sizeof s) - 1

CP_STATIC_IF_GLIBCPP_V3
const struct demangle_operator_info cplus_demangle_operators[] =
d1283 1
a1283 2
  { "sz", NL ("sizeof "),   1 },
  { NULL, NULL, 0,          0 }
d1286 1
a1286 1
static struct demangle_component *
d1296 1
a1296 1
    return d_make_extended_operator (di, c2 - '0', d_source_name (di));
d1298 1
a1298 2
    return d_make_comp (di, DEMANGLE_COMPONENT_CAST,
			cplus_demangle_type (di), NULL);
a1300 1
      /* LOW is the inclusive lower bound.  */
d1302 1
a1302 5
      /* HIGH is the exclusive upper bound.  We subtract one to ignore
	 the sentinel at the end of the array.  */
      int high = ((sizeof (cplus_demangle_operators)
		   / sizeof (cplus_demangle_operators[0]))
		  - 1);
d1307 1
a1307 1
	  const struct demangle_operator_info *p;
d1310 1
a1310 1
	  p = cplus_demangle_operators + i;
d1325 16
d1355 1
a1355 1
static struct demangle_component *
d1369 1
a1369 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_VTABLE,
			      cplus_demangle_type (di), NULL);
d1372 1
a1372 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_VTT,
			      cplus_demangle_type (di), NULL);
d1374 1
a1374 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO,
			      cplus_demangle_type (di), NULL);
d1376 1
a1376 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO_NAME,
			      cplus_demangle_type (di), NULL);
d1381 1
a1381 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_THUNK,
			      d_encoding (di, 0), NULL);
d1386 2
a1387 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_VIRTUAL_THUNK,
			      d_encoding (di, 0), NULL);
d1394 2
a1395 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_COVARIANT_THUNK,
			      d_encoding (di, 0), NULL);
d1399 1
a1399 1
	    struct demangle_component *derived_type;
d1401 1
a1401 1
	    struct demangle_component *base_type;
d1403 1
a1403 1
	    derived_type = cplus_demangle_type (di);
d1409 1
a1409 1
	    base_type = cplus_demangle_type (di);
d1413 2
a1414 2
	    return d_make_comp (di, DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE,
				base_type, derived_type);
d1418 1
a1418 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO_FN,
			      cplus_demangle_type (di), NULL);
d1420 1
a1420 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_JAVA_CLASS,
			      cplus_demangle_type (di), NULL);
d1431 1
a1431 1
	  return d_make_comp (di, DEMANGLE_COMPONENT_GUARD, d_name (di), NULL);
d1434 1
a1434 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_REFTEMP, d_name (di),
			      NULL);
d1494 1
a1494 1
static struct demangle_component *
d1500 1
a1500 1
      if (di->last_name->type == DEMANGLE_COMPONENT_NAME)
d1502 1
a1502 1
      else if (di->last_name->type == DEMANGLE_COMPONENT_SUB_STD)
d1525 1
a1525 1
	return d_make_ctor (di, kind, di->last_name);
d1546 1
a1546 1
	return d_make_dtor (di, kind, di->last_name);
d1573 2
a1574 35
CP_STATIC_IF_GLIBCPP_V3
const struct demangle_builtin_type_info
cplus_demangle_builtin_types[D_BUILTIN_TYPE_COUNT] =
{
  /* a */ { NL ("signed char"),	NL ("signed char"),	D_PRINT_INT },
  /* b */ { NL ("bool"),	NL ("boolean"),		D_PRINT_BOOL },
  /* c */ { NL ("char"),	NL ("byte"),		D_PRINT_INT },
  /* d */ { NL ("double"),	NL ("double"),		D_PRINT_DEFAULT },
  /* e */ { NL ("long double"),	NL ("long double"),	D_PRINT_DEFAULT },
  /* f */ { NL ("float"),	NL ("float"),		D_PRINT_DEFAULT },
  /* g */ { NL ("__float128"),	NL ("__float128"),	D_PRINT_DEFAULT },
  /* h */ { NL ("unsigned char"), NL ("unsigned char"),	D_PRINT_INT },
  /* i */ { NL ("int"),		NL ("int"),		D_PRINT_INT },
  /* j */ { NL ("unsigned int"), NL ("unsigned"),	D_PRINT_INT },
  /* k */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* l */ { NL ("long"),	NL ("long"),		D_PRINT_LONG },
  /* m */ { NL ("unsigned long"), NL ("unsigned long"),	D_PRINT_LONG },
  /* n */ { NL ("__int128"),	NL ("__int128"),	D_PRINT_DEFAULT },
  /* o */ { NL ("unsigned __int128"), NL ("unsigned __int128"),	D_PRINT_DEFAULT },
  /* p */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* q */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* r */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* s */ { NL ("short"),	NL ("short"),		D_PRINT_INT },
  /* t */ { NL ("unsigned short"), NL ("unsigned short"), D_PRINT_INT },
  /* u */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* v */ { NL ("void"),	NL ("void"),		D_PRINT_VOID },
  /* w */ { NL ("wchar_t"),	NL ("char"),		D_PRINT_INT },
  /* x */ { NL ("long long"),	NL ("long"),		D_PRINT_DEFAULT },
  /* y */ { NL ("unsigned long long"), NL ("unsigned long long"), D_PRINT_DEFAULT },
  /* z */ { NL ("..."),		NL ("..."),		D_PRINT_DEFAULT },
};

CP_STATIC_IF_GLIBCPP_V3
struct demangle_component *
cplus_demangle_type (di)
d1578 1
a1578 1
  struct demangle_component *ret;
d1599 1
a1599 1
      struct demangle_component **pret;
d1604 1
a1604 1
      *pret = cplus_demangle_type (di);
d1618 1
a1618 2
      ret = d_make_builtin_type (di,
				 &cplus_demangle_builtin_types[peek - 'a']);
d1626 1
a1626 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE,
			 d_source_name (di), NULL);
d1657 1
a1657 2
	  ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,
			     d_template_args (di));
d1676 1
a1676 1
	      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,
d1688 1
a1688 1
	    if (ret != NULL && ret->type == DEMANGLE_COMPONENT_SUB_STD)
d1696 1
a1696 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_POINTER,
			 cplus_demangle_type (di), NULL);
d1701 1
a1701 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_REFERENCE,
			 cplus_demangle_type (di), NULL);
d1706 1
a1706 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_COMPLEX,
			 cplus_demangle_type (di), NULL);
d1711 1
a1711 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_IMAGINARY,
			 cplus_demangle_type (di), NULL);
d1717 1
a1717 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL,
			 cplus_demangle_type (di), ret);
d1735 1
a1735 1
static struct demangle_component **
d1738 1
a1738 1
     struct demangle_component **pret;
d1746 1
a1746 1
      enum demangle_component_type t;
d1751 1
a1751 3
	  t = (member_fn
	       ? DEMANGLE_COMPONENT_RESTRICT_THIS
	       : DEMANGLE_COMPONENT_RESTRICT);
d1756 1
a1756 3
	  t = (member_fn
	       ? DEMANGLE_COMPONENT_VOLATILE_THIS
	       : DEMANGLE_COMPONENT_VOLATILE);
d1761 1
a1761 3
	  t = (member_fn
	       ? DEMANGLE_COMPONENT_CONST_THIS
	       : DEMANGLE_COMPONENT_CONST);
d1765 1
a1765 1
      *pret = d_make_comp (di, t, NULL, NULL);
d1778 1
a1778 1
static struct demangle_component *
d1782 1
a1782 1
  struct demangle_component *ret;
d1800 1
a1800 1
static struct demangle_component *
d1805 3
a1807 3
  struct demangle_component *return_type;
  struct demangle_component *tl;
  struct demangle_component **ptl;
d1815 1
a1815 1
      struct demangle_component *type;
d1820 1
a1820 1
      type = cplus_demangle_type (di);
d1830 1
a1830 1
	  *ptl = d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, type, NULL);
d1845 1
a1845 1
      && d_left (tl)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE
d1852 1
a1852 1
  return d_make_comp (di, DEMANGLE_COMPONENT_FUNCTION_TYPE, return_type, tl);
d1857 1
a1857 1
static struct demangle_component *
d1868 1
a1868 1
static struct demangle_component *
d1873 1
a1873 1
  struct demangle_component *dim;
d1892 1
a1892 1
      dim = d_make_name (di, s, d_str (di) - s);
d1906 1
a1906 2
  return d_make_comp (di, DEMANGLE_COMPONENT_ARRAY_TYPE, dim,
		      cplus_demangle_type (di));
d1911 1
a1911 1
static struct demangle_component *
d1915 3
a1917 3
  struct demangle_component *cl;
  struct demangle_component *mem;
  struct demangle_component **pmem;
d1922 1
a1922 1
  cl = cplus_demangle_type (di);
d1935 1
a1935 1
     avoid calling add_substitution() in cplus_demangle_type().  */
d1940 1
a1940 1
  *pmem = cplus_demangle_type (di);
d1942 1
a1942 1
  return d_make_comp (di, DEMANGLE_COMPONENT_PTRMEM_TYPE, cl, mem);
d1949 1
a1949 1
static struct demangle_component *
d1978 1
a1978 1
static struct demangle_component *
d1982 3
a1984 3
  struct demangle_component *hold_last_name;
  struct demangle_component *al;
  struct demangle_component **pal;
d1998 1
a1998 1
      struct demangle_component *a;
d2004 1
a2004 1
      *pal = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, a, NULL);
d2026 1
a2026 1
static struct demangle_component *
d2030 1
a2030 1
  struct demangle_component *ret;
d2045 1
a2045 1
      return cplus_demangle_type (di);
d2059 1
a2059 1
static struct demangle_component *
d2072 2
a2073 2
      struct demangle_component *type;
      struct demangle_component *name;
d2076 1
a2076 1
      type = cplus_demangle_type (di);
d2079 1
a2079 1
	return d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);
d2081 2
a2082 2
	return d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type,
			    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,
d2087 1
a2087 1
      struct demangle_component *op;
d2094 1
a2094 1
      if (op->type == DEMANGLE_COMPONENT_OPERATOR)
d2097 1
a2097 1
      if (op->type == DEMANGLE_COMPONENT_OPERATOR
d2099 1
a2099 2
	return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
			    cplus_demangle_type (di));
d2105 1
a2105 1
	case DEMANGLE_COMPONENT_OPERATOR:
d2108 1
a2108 1
	case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
d2111 1
a2111 1
	case DEMANGLE_COMPONENT_CAST:
d2119 1
a2119 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
			      d_expression (di));
d2122 1
a2122 1
	    struct demangle_component *left;
d2125 2
a2126 4
	    return d_make_comp (di, DEMANGLE_COMPONENT_BINARY, op,
				d_make_comp (di,
					     DEMANGLE_COMPONENT_BINARY_ARGS,
					     left,
d2131 2
a2132 2
	    struct demangle_component *first;
	    struct demangle_component *second;
d2136 4
a2139 6
	    return d_make_comp (di, DEMANGLE_COMPONENT_TRINARY, op,
				d_make_comp (di,
					     DEMANGLE_COMPONENT_TRINARY_ARG1,
					     first,
					     d_make_comp (di,
							  DEMANGLE_COMPONENT_TRINARY_ARG2,
d2154 1
a2154 1
static struct demangle_component *
d2158 1
a2158 1
  struct demangle_component *ret;
d2163 1
a2163 1
    ret = cplus_demangle_mangled_name (di, 0);
d2166 2
a2167 2
      struct demangle_component *type;
      enum demangle_component_type t;
d2170 1
a2170 1
      type = cplus_demangle_type (di);
d2174 1
a2174 1
      if (type->type == DEMANGLE_COMPONENT_BUILTIN_TYPE
d2189 1
a2189 1
      t = DEMANGLE_COMPONENT_LITERAL;
d2192 1
a2192 1
	  t = DEMANGLE_COMPONENT_LITERAL_NEG;
d2198 1
a2198 1
      ret = d_make_comp (di, t, type, d_make_name (di, s, d_str (di) - s));
d2209 1
a2209 1
static struct demangle_component *
d2213 1
a2213 1
  struct demangle_component *function;
d2228 2
a2229 2
      return d_make_comp (di, DEMANGLE_COMPONENT_LOCAL_NAME, function,
			  d_make_name (di, "string literal",
d2234 1
a2234 1
      struct demangle_component *name;
d2239 1
a2239 1
      return d_make_comp (di, DEMANGLE_COMPONENT_LOCAL_NAME, function, name);
d2268 1
a2268 1
     struct demangle_component *dc;
d2323 1
a2323 1
static struct demangle_component *
a2501 1
CP_STATIC_IF_GLIBCPP_V3
d2503 1
a2503 1
cplus_demangle_print (options, dc, estimate, palc)
d2505 1
a2505 1
     const struct demangle_component *dc;
d2544 1
a2544 1
     const struct demangle_component *dc;
d2556 1
a2556 1
    case DEMANGLE_COMPONENT_NAME:
d2563 2
a2564 2
    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
d2573 1
a2573 1
    case DEMANGLE_COMPONENT_TYPED_NAME:
d2576 1
a2576 1
	struct demangle_component *typed_name;
d2602 3
a2604 3
	    if (typed_name->type != DEMANGLE_COMPONENT_RESTRICT_THIS
		&& typed_name->type != DEMANGLE_COMPONENT_VOLATILE_THIS
		&& typed_name->type != DEMANGLE_COMPONENT_CONST_THIS)
d2612 1
a2612 1
	if (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)
d2619 5
a2623 5
	/* If typed_name is a DEMANGLE_COMPONENT_LOCAL_NAME, then
	   there may be CV-qualifiers on its right argument which
	   really apply here; this happens when parsing a class which
	   is local to a function.  */
	if (typed_name->type == DEMANGLE_COMPONENT_LOCAL_NAME)
d2625 1
a2625 1
	    struct demangle_component *local_name;
d2628 3
a2630 3
	    while (local_name->type == DEMANGLE_COMPONENT_RESTRICT_THIS
		   || local_name->type == DEMANGLE_COMPONENT_VOLATILE_THIS
		   || local_name->type == DEMANGLE_COMPONENT_CONST_THIS)
d2653 1
a2653 1
	if (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)
d2673 1
a2673 1
    case DEMANGLE_COMPONENT_TEMPLATE:
d2700 1
a2700 1
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
d2703 1
a2703 1
	struct demangle_component *a;
d2716 1
a2716 1
	    if (a->type != DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)
d2746 1
a2746 1
    case DEMANGLE_COMPONENT_CTOR:
d2750 1
a2750 1
    case DEMANGLE_COMPONENT_DTOR:
d2755 1
a2755 1
    case DEMANGLE_COMPONENT_VTABLE:
d2760 1
a2760 1
    case DEMANGLE_COMPONENT_VTT:
d2765 1
a2765 1
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
d2772 1
a2772 1
    case DEMANGLE_COMPONENT_TYPEINFO:
d2777 1
a2777 1
    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
d2782 1
a2782 1
    case DEMANGLE_COMPONENT_TYPEINFO_FN:
d2787 1
a2787 1
    case DEMANGLE_COMPONENT_THUNK:
d2792 1
a2792 1
    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
d2797 1
a2797 1
    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
d2802 1
a2802 1
    case DEMANGLE_COMPONENT_JAVA_CLASS:
d2807 1
a2807 1
    case DEMANGLE_COMPONENT_GUARD:
d2812 1
a2812 1
    case DEMANGLE_COMPONENT_REFTEMP:
d2817 1
a2817 1
    case DEMANGLE_COMPONENT_SUB_STD:
d2821 11
a2831 11
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_REFERENCE:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
d2854 1
a2854 1
    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
d2863 1
a2863 1
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
d2867 1
a2867 1
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
d2897 1
a2897 1
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
d2922 1
a2922 1
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
d2948 2
a2949 2
    case DEMANGLE_COMPONENT_ARGLIST:
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
d2958 1
a2958 1
    case DEMANGLE_COMPONENT_OPERATOR:
d2971 1
a2971 1
    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
d2976 1
a2976 1
    case DEMANGLE_COMPONENT_CAST:
d2981 2
a2982 2
    case DEMANGLE_COMPONENT_UNARY:
      if (d_left (dc)->type != DEMANGLE_COMPONENT_CAST)
d2993 1
a2993 1
      if (d_left (dc)->type == DEMANGLE_COMPONENT_CAST)
d2997 2
a2998 2
    case DEMANGLE_COMPONENT_BINARY:
      if (d_right (dc)->type != DEMANGLE_COMPONENT_BINARY_ARGS)
d3007 1
a3007 1
      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
d3020 1
a3020 1
      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
d3027 2
a3028 2
    case DEMANGLE_COMPONENT_BINARY_ARGS:
      /* We should only see this as part of DEMANGLE_COMPONENT_BINARY.  */
d3032 3
a3034 3
    case DEMANGLE_COMPONENT_TRINARY:
      if (d_right (dc)->type != DEMANGLE_COMPONENT_TRINARY_ARG1
	  || d_right (d_right (dc))->type != DEMANGLE_COMPONENT_TRINARY_ARG2)
d3050 3
a3052 3
    case DEMANGLE_COMPONENT_TRINARY_ARG1:
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
      /* We should only see these are part of DEMANGLE_COMPONENT_TRINARY.  */
d3056 2
a3057 2
    case DEMANGLE_COMPONENT_LITERAL:
    case DEMANGLE_COMPONENT_LITERAL_NEG:
d3059 1
a3059 1
      if (d_left (dc)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE)
d3064 1
a3064 1
	      if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME)
d3066 1
a3066 1
		  if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
d3074 1
a3074 1
	      if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME)
d3076 1
a3076 1
		  if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
d3085 1
a3085 1
	      if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME
d3087 1
a3087 1
		  && dc->type == DEMANGLE_COMPONENT_LITERAL)
d3111 1
a3111 1
      if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
d3193 3
a3195 3
	  && (mods->mod->type == DEMANGLE_COMPONENT_RESTRICT_THIS
	      || mods->mod->type == DEMANGLE_COMPONENT_VOLATILE_THIS
	      || mods->mod->type == DEMANGLE_COMPONENT_CONST_THIS)))
d3206 1
a3206 1
  if (mods->mod->type == DEMANGLE_COMPONENT_FUNCTION_TYPE)
d3212 1
a3212 1
  else if (mods->mod->type == DEMANGLE_COMPONENT_ARRAY_TYPE)
d3218 1
a3218 1
  else if (mods->mod->type == DEMANGLE_COMPONENT_LOCAL_NAME)
d3221 1
a3221 1
      struct demangle_component *dc;
d3239 3
a3241 3
      while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS
	     || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS
	     || dc->type == DEMANGLE_COMPONENT_CONST_THIS)
d3262 1
a3262 1
     const struct demangle_component *mod;
d3266 2
a3267 2
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
d3270 2
a3271 2
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
d3274 2
a3275 2
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_CONST_THIS:
d3278 1
a3278 1
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
d3282 1
a3282 1
    case DEMANGLE_COMPONENT_POINTER:
d3287 1
a3287 1
    case DEMANGLE_COMPONENT_REFERENCE:
d3290 1
a3290 1
    case DEMANGLE_COMPONENT_COMPLEX:
d3293 1
a3293 1
    case DEMANGLE_COMPONENT_IMAGINARY:
d3296 1
a3296 1
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
d3302 1
a3302 1
    case DEMANGLE_COMPONENT_TYPED_NAME:
d3318 1
a3318 1
     const struct demangle_component *dc;
d3336 9
a3344 9
	case DEMANGLE_COMPONENT_RESTRICT:
	case DEMANGLE_COMPONENT_VOLATILE:
	case DEMANGLE_COMPONENT_CONST:
	case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
	case DEMANGLE_COMPONENT_POINTER:
	case DEMANGLE_COMPONENT_REFERENCE:
	case DEMANGLE_COMPONENT_COMPLEX:
	case DEMANGLE_COMPONENT_IMAGINARY:
	case DEMANGLE_COMPONENT_PTRMEM_TYPE:
d3347 3
a3349 3
	case DEMANGLE_COMPONENT_RESTRICT_THIS:
	case DEMANGLE_COMPONENT_VOLATILE_THIS:
	case DEMANGLE_COMPONENT_CONST_THIS:
d3403 1
a3403 1
     const struct demangle_component *dc;
d3420 1
a3420 1
	  if (p->mod->type == DEMANGLE_COMPONENT_ARRAY_TYPE)
d3458 1
a3458 1
     const struct demangle_component *dc;
d3460 1
a3460 1
  if (dc->type == DEMANGLE_COMPONENT_OPERATOR)
d3472 1
a3472 1
     const struct demangle_component *dc;
d3474 1
a3474 1
  if (d_left (dc)->type != DEMANGLE_COMPONENT_TEMPLATE)
d3514 2
a3515 3
CP_STATIC_IF_GLIBCPP_V3
void
cplus_demangle_init_info (mangled, options, len, di)
d3544 54
d3614 1
a3614 1
  struct demangle_component *dc;
d3651 1
a3651 1
  cplus_demangle_init_info (mangled, options, len, &di);
d3655 2
a3656 2
    __extension__ struct demangle_component comps[di.num_comps];
    __extension__ struct demangle_component *subs[di.num_subs];
d3661 4
a3664 4
    di.comps = ((struct demangle_component *)
		malloc (di.num_comps * sizeof (struct demangle_component)));
    di.subs = ((struct demangle_component **)
	       malloc (di.num_subs * sizeof (struct demangle_component *)));
d3677 1
a3677 1
      dc = cplus_demangle_mangled_name (&di, 1);
d3679 1
a3679 1
      dc = cplus_demangle_type (&di);
d3702 1
a3702 1
      ret = cplus_demangle_print (options, dc, estimate, palc);
d3903 1
a3903 1
  struct demangle_component *dc;
d3909 1
a3909 1
  cplus_demangle_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di);
d3913 2
a3914 2
    __extension__ struct demangle_component comps[di.num_comps];
    __extension__ struct demangle_component *subs[di.num_subs];
d3919 4
a3922 4
    di.comps = ((struct demangle_component *)
		malloc (di.num_comps * sizeof (struct demangle_component)));
    di.subs = ((struct demangle_component **)
	       malloc (di.num_subs * sizeof (struct demangle_component *)));
d3929 2
a3930 1
	return 0;
d3934 1
a3934 1
    dc = cplus_demangle_mangled_name (&di, 1);
d3947 5
a3951 5
	  case DEMANGLE_COMPONENT_TYPED_NAME:
	  case DEMANGLE_COMPONENT_TEMPLATE:
	  case DEMANGLE_COMPONENT_RESTRICT_THIS:
	  case DEMANGLE_COMPONENT_VOLATILE_THIS:
	  case DEMANGLE_COMPONENT_CONST_THIS:
d3954 2
a3955 2
	  case DEMANGLE_COMPONENT_QUAL_NAME:
	  case DEMANGLE_COMPONENT_LOCAL_NAME:
d3958 1
a3958 1
	  case DEMANGLE_COMPONENT_CTOR:
d3963 1
a3963 1
	  case DEMANGLE_COMPONENT_DTOR:
@


1.27.4.6
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@a753 1
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
d771 1
@


1.27.2.1
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d3401 1
a3401 1
	      RETURN_IF_ERROR (result_add (dm, "std::basic_istream<char, std::char_traits<char> >"));
@


1.27.2.2
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d5 1
a5 1
   This file is part of the libiberty library, which is part of GCC.
d7 1
a7 1
   This file is free software; you can redistribute it and/or modify
@


1.27.2.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1 3
a3 3
/* Demangler for g++ V3 ABI.
   Copyright (C) 2003 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@wasabisystems.com>.
d31 6
a36 36
/* This code implements a demangler for the g++ V3 ABI.  The ABI is
   described on this web page:
       http://www.codesourcery.com/cxx-abi/abi.html#mangling

   This code was written while looking at the demangler written by
   Alex Samuel <samuel@@codesourcery.com>.

   This code first pulls the mangled name apart into a list of
   components, and then walks the list generating the demangled
   name.

   This file will normally define the following functions, q.v.:
      char *cplus_demangle_v3(const char *mangled, int options)
      char *java_demangle_v3(const char *mangled)
      enum gnu_v3_ctor_kinds is_gnu_v3_mangled_ctor (const char *name)
      enum gnu_v3_dtor_kinds is_gnu_v3_mangled_dtor (const char *name)

   Preprocessor macros you can define while compiling this file:

   IN_LIBGCC2
      If defined, this file defines the following function, q.v.:
         char *__cxa_demangle (const char *mangled, char *buf, size_t *len,
                               int *status)
      instead of cplus_demangle_v3() and java_demangle_v3().

   IN_GLIBCPP_V3
      If defined, this file defines only __cxa_demangle().

   STANDALONE_DEMANGLER
      If defined, this file defines a main() function which demangles
      any arguments, or, if none, demangles stdin.

   CP_DEMANGLE_DEBUG
      If defined, turns on debugging mode, which prints information on
      stdout about the mangled string.  This is not generally useful.
*/
d42 1
a42 1
#include <stdio.h>
d47 3
d54 2
d58 1
d61 16
a76 12
/* We avoid pulling in the ctype tables, to prevent pulling in
   additional unresolved symbols when this code is used in a library.
   FIXME: Is this really a valid reason?  This comes from the original
   V3 demangler code.

   As of this writing this file has the following undefined references
   when compiled with -DIN_GLIBCPP_V3: malloc, realloc, free, memcpy,
   strcpy, strcat, strlen.  */

#define IS_DIGIT(c) ((c) >= '0' && (c) <= '9')
#define IS_UPPER(c) ((c) >= 'A' && (c) <= 'Z')
#define IS_LOWER(c) ((c) >= 'a' && (c) <= 'z')
a80 2
#define ANONYMOUS_NAMESPACE_PREFIX_LEN \
  (sizeof (ANONYMOUS_NAMESPACE_PREFIX) - 1)
d82 36
a117 1
/* Information we keep for operators.  */
d119 1
a119 1
struct d_operator_info
d121 5
a125 6
  /* Mangled name.  */
  const char *code;
  /* Real name.  */
  const char *name;
  /* Number of arguments.  */
  int args;
d128 1
a128 1
/* How to print the value of a builtin type.  */
d130 1
a130 1
enum d_builtin_type_print
d132 10
a141 10
  /* Print as (type)val.  */
  D_PRINT_DEFAULT,
  /* Print as integer.  */
  D_PRINT_INT,
  /* Print as long, with trailing `l'.  */
  D_PRINT_LONG,
  /* Print as bool.  */
  D_PRINT_BOOL,
  /* Print in usual way, but here to detect void.  */
  D_PRINT_VOID
d144 1
a144 1
/* Information we keep for a builtin type.  */
d146 3
a148 1
struct d_builtin_type_info
d150 1
a150 1
  /* Type name.  */
a151 5
  /* Type name when using Java.  */
  const char *java_name;
  /* How to print a value of this type.  */
  enum d_builtin_type_print print;
};
d153 33
a185 1
/* Information we keep for the standard substitutions.  */
d187 3
a189 14
struct d_standard_sub_info
{
  /* The code for this substitution.  */
  char code;
  /* The simple string it expands to.  */
  const char *simple_expansion;
  /* The results of a full, verbose, expansion.  This is used when
     qualifying a constructor/destructor, or when in verbose mode.  */
  const char *full_expansion;
  /* What to set the last_name field of d_info to; NULL if we should
     not set it.  This is only relevant when qualifying a
     constructor/destructor.  */
  const char *set_last_name;
};
d191 3
a193 1
/* Component types found in mangled names.  */
a194 99
enum d_comp_type
{
  /* A name.  */
  D_COMP_NAME,
  /* A qualified name.  */
  D_COMP_QUAL_NAME,
  /* A typed name.  */
  D_COMP_TYPED_NAME,
  /* A template.  */
  D_COMP_TEMPLATE,
  /* A template parameter.  */
  D_COMP_TEMPLATE_PARAM,
  /* A constructor.  */
  D_COMP_CTOR,
  /* A destructor.  */
  D_COMP_DTOR,
  /* A vtable.  */
  D_COMP_VTABLE,
  /* A VTT structure.  */
  D_COMP_VTT,
  /* A construction vtable.  */
  D_COMP_CONSTRUCTION_VTABLE,
  /* A typeinfo structure.  */
  D_COMP_TYPEINFO,
  /* A typeinfo name.  */
  D_COMP_TYPEINFO_NAME,
  /* A typeinfo function.  */
  D_COMP_TYPEINFO_FN,
  /* A thunk.  */
  D_COMP_THUNK,
  /* A virtual thunk.  */
  D_COMP_VIRTUAL_THUNK,
  /* A covariant thunk.  */
  D_COMP_COVARIANT_THUNK,
  /* A Java class.  */
  D_COMP_JAVA_CLASS,
  /* A guard variable.  */
  D_COMP_GUARD,
  /* A reference temporary.  */
  D_COMP_REFTEMP,
  /* A standard substitution.  */
  D_COMP_SUB_STD,
  /* The restrict qualifier.  */
  D_COMP_RESTRICT,
  /* The volatile qualifier.  */
  D_COMP_VOLATILE,
  /* The const qualifier.  */
  D_COMP_CONST,
  /* The restrict qualifier modifying a member function.  */
  D_COMP_RESTRICT_THIS,
  /* The volatile qualifier modifying a member function.  */
  D_COMP_VOLATILE_THIS,
  /* The const qualifier modifying a member function.  */
  D_COMP_CONST_THIS,
  /* A vendor qualifier.  */
  D_COMP_VENDOR_TYPE_QUAL,
  /* A pointer.  */
  D_COMP_POINTER,
  /* A reference.  */
  D_COMP_REFERENCE,
  /* A complex type.  */
  D_COMP_COMPLEX,
  /* An imaginary type.  */
  D_COMP_IMAGINARY,
  /* A builtin type.  */
  D_COMP_BUILTIN_TYPE,
  /* A vendor's builtin type.  */
  D_COMP_VENDOR_TYPE,
  /* A function type.  */
  D_COMP_FUNCTION_TYPE,
  /* An array type.  */
  D_COMP_ARRAY_TYPE,
  /* A pointer to member type.  */
  D_COMP_PTRMEM_TYPE,
  /* An argument list.  */
  D_COMP_ARGLIST,
  /* A template argument list.  */
  D_COMP_TEMPLATE_ARGLIST,
  /* An operator.  */
  D_COMP_OPERATOR,
  /* An extended operator.  */
  D_COMP_EXTENDED_OPERATOR,
  /* A typecast.  */
  D_COMP_CAST,
  /* A unary expression.  */
  D_COMP_UNARY,
  /* A binary expression.  */
  D_COMP_BINARY,
  /* Arguments to a binary expression.  */
  D_COMP_BINARY_ARGS,
  /* A trinary expression.  */
  D_COMP_TRINARY,
  /* Arguments to a trinary expression.  */
  D_COMP_TRINARY_ARG1,
  D_COMP_TRINARY_ARG2,
  /* A literal.  */
  D_COMP_LITERAL,
  /* A negative literal.  */
  D_COMP_LITERAL_NEG
d197 1
a197 1
/* A component of the mangled name.  */
d199 169
a367 1
struct d_comp
d369 5
a373 6
  /* The type of this component.  */
  enum d_comp_type type;
  union
  {
    /* For D_COMP_NAME.  */
    struct
d375 4
a378 5
      /* A pointer to the name (not NULL terminated) and it's
	 length.  */
      const char *s;
      int len;
    } s_name;
d380 2
a381 2
    /* For D_COMP_OPERATOR.  */
    struct
d383 8
a390 6
      /* Operator.  */
      const struct d_operator_info *op;
    } s_operator;

    /* For D_COMP_EXTENDED_OPERATOR.  */
    struct
d392 3
a394 5
      /* Number of arguments.  */
      int args;
      /* Name.  */
      struct d_comp *name;
    } s_extended_operator;
d396 2
a397 2
    /* For D_COMP_CTOR.  */
    struct
d399 1
a399 3
      enum gnu_v3_ctor_kinds kind;
      struct d_comp *name;
    } s_ctor;
d401 2
a402 6
    /* For D_COMP_DTOR.  */
    struct
    {
      enum gnu_v3_dtor_kinds kind;
      struct d_comp *name;
    } s_dtor;
d404 3
a406 5
    /* For D_COMP_BUILTIN_TYPE.  */
    struct
    {
      const struct d_builtin_type_info *type;
    } s_builtin;
d408 2
a409 5
    /* For D_COMP_SUB_STD.  */
    struct
    {
      const char* string;
    } s_string;
d411 4
a414 5
    /* For D_COMP_TEMPLATE_PARAM.  */
    struct
    {
      long number;
    } s_number;
d416 12
a427 6
    /* For other types.  */
    struct
    {
      struct d_comp *left;
      struct d_comp *right;
    } s_binary;
d429 1
a429 2
  } u;
};
d431 11
a441 2
#define d_left(dc) ((dc)->u.s_binary.left)
#define d_right(dc) ((dc)->u.s_binary.right)
d443 2
a444 1
/* The information structure we pass around.  */
d446 4
a449 1
struct d_info
d451 2
a452 21
  /* The string we are demangling.  */
  const char *s;
  /* The options passed to the demangler.  */
  int options;
  /* The next character in the string to consider.  */
  const char *n;
  /* The array of components.  */
  struct d_comp *comps;
  /* The index of the next available component.  */
  int next_comp;
  /* The number of available component structures.  */
  int num_comps;
  /* The array of substitutions.  */
  struct d_comp **subs;
  /* The index of the next substitution.  */
  int next_sub;
  /* The number of available entries in the subs array.  */
  int num_subs;
  /* The last name we saw, for constructors and destructors.  */
  struct d_comp *last_name;
};
d454 6
a459 15
#define d_peek_char(di) (*((di)->n))
#define d_peek_next_char(di) ((di)->n[1])
#define d_advance(di, i) ((di)->n += (i))
#define d_next_char(di) (*((di)->n++))
#define d_str(di) ((di)->n)

/* A list of templates.  This is used while printing.  */

struct d_print_template
{
  /* Next template on the list.  */
  struct d_print_template *next;
  /* This template.  */
  const struct d_comp *template;
};
d461 2
a462 1
/* A list of type modifiers.  This is used while printing.  */
d464 4
a467 12
struct d_print_mod
{
  /* Next modifier on the list.  These are in the reverse of the order
     in which they appeared in the mangled string.  */
  struct d_print_mod *next;
  /* The modifier.  */
  const struct d_comp *mod;
  /* Whether this modifier was printed.  */
  int printed;
  /* The list of templates which applies to this modifier.  */
  struct d_print_template *templates;
};
d469 3
a471 3
/* We use this structure to hold information during printing.  */

struct d_print_info
d473 4
a476 16
  /* The options passed to the demangler.  */
  int options;
  /* Buffer holding the result.  */
  char *buf;
  /* Current length of data in buffer.  */
  size_t len;
  /* Allocated size of buffer.  */
  size_t alc;
  /* The current list of templates, if any.  */
  struct d_print_template *templates;
  /* The current list of modifiers (e.g., pointer, reference, etc.),
     if any.  */
  struct d_print_mod *modifiers;
  /* Set to 1 if we had a memory allocation failure.  */
  int allocation_failure;
};
d478 5
a482 1
#define d_print_saw_error(dpi) ((dpi)->buf == NULL)
d484 3
a486 9
#define d_append_char(dpi, c) \
  do \
    { \
      if ((dpi)->buf != NULL && (dpi)->len < (dpi)->alc) \
        (dpi)->buf[(dpi)->len++] = (c); \
      else \
        d_print_append_char ((dpi), (c)); \
    } \
  while (0)
d488 8
a495 12
#define d_append_buffer(dpi, s, l) \
  do \
    { \
      if ((dpi)->buf != NULL && (dpi)->len + (l) <= (dpi)->alc) \
        { \
          memcpy ((dpi)->buf + (dpi)->len, (s), (l)); \
          (dpi)->len += l; \
        } \
      else \
        d_print_append_buffer ((dpi), (s), (l)); \
    } \
  while (0)
d497 2
a498 7
#define d_append_string(dpi, s) \
  do \
    { \
      size_t d_append_string_len = strlen (s); \
      d_append_buffer ((dpi), (s), d_append_string_len); \
    } \
  while (0)
d500 6
a505 85
#define d_last_char(dpi) \
  ((dpi)->buf == NULL || (dpi)->len == 0 ? '\0' : (dpi)->buf[(dpi)->len - 1])

#ifdef CP_DEMANGLE_DEBUG
static void d_dump PARAMS ((struct d_comp *, int));
#endif
static struct d_comp *d_make_empty PARAMS ((struct d_info *,
					    enum d_comp_type));
static struct d_comp *d_make_comp PARAMS ((struct d_info *, enum d_comp_type,
					   struct d_comp *, struct d_comp *));
static struct d_comp *d_make_name PARAMS ((struct d_info *, const char *,
					   int));
static struct d_comp *d_make_builtin_type PARAMS ((struct d_info *,
						   const struct d_builtin_type_info *));
static struct d_comp *d_make_operator PARAMS ((struct d_info *,
					       const struct d_operator_info *));
static struct d_comp *d_make_extended_operator PARAMS ((struct d_info *,
							int,
							struct d_comp *));
static struct d_comp *d_make_ctor PARAMS ((struct d_info *,
					   enum gnu_v3_ctor_kinds,
					   struct d_comp *));
static struct d_comp *d_make_dtor PARAMS ((struct d_info *,
					   enum gnu_v3_dtor_kinds,
					   struct d_comp *));
static struct d_comp *d_make_template_param PARAMS ((struct d_info *, long));
static struct d_comp *d_make_sub PARAMS ((struct d_info *, const char *));
static struct d_comp *d_mangled_name PARAMS ((struct d_info *, int));
static int has_return_type PARAMS ((struct d_comp *));
static int is_ctor_dtor_or_conversion PARAMS ((struct d_comp *));
static struct d_comp *d_encoding PARAMS ((struct d_info *, int));
static struct d_comp *d_name PARAMS ((struct d_info *));
static struct d_comp *d_nested_name PARAMS ((struct d_info *));
static struct d_comp *d_prefix PARAMS ((struct d_info *));
static struct d_comp *d_unqualified_name PARAMS ((struct d_info *));
static struct d_comp *d_source_name PARAMS ((struct d_info *));
static long d_number PARAMS ((struct d_info *));
static struct d_comp *d_identifier PARAMS ((struct d_info *, int));
static struct d_comp *d_operator_name PARAMS ((struct d_info *));
static struct d_comp *d_special_name PARAMS ((struct d_info *));
static int d_call_offset PARAMS ((struct d_info *, int));
static struct d_comp *d_ctor_dtor_name PARAMS ((struct d_info *));
static struct d_comp *d_type PARAMS ((struct d_info *));
static struct d_comp **d_cv_qualifiers PARAMS ((struct d_info *,
						struct d_comp **, int));
static struct d_comp *d_function_type PARAMS ((struct d_info *));
static struct d_comp *d_bare_function_type PARAMS ((struct d_info *, int));
static struct d_comp *d_class_enum_type PARAMS ((struct d_info *));
static struct d_comp *d_array_type PARAMS ((struct d_info *));
static struct d_comp *d_pointer_to_member_type PARAMS ((struct d_info *));
static struct d_comp *d_template_param PARAMS ((struct d_info *));
static struct d_comp *d_template_args PARAMS ((struct d_info *));
static struct d_comp *d_template_arg PARAMS ((struct d_info *));
static struct d_comp *d_expression PARAMS ((struct d_info *));
static struct d_comp *d_expr_primary PARAMS ((struct d_info *));
static struct d_comp *d_local_name PARAMS ((struct d_info *));
static int d_discriminator PARAMS ((struct d_info *));
static int d_add_substitution PARAMS ((struct d_info *, struct d_comp *));
static struct d_comp *d_substitution PARAMS ((struct d_info *, int));
static void d_print_resize PARAMS ((struct d_print_info *, size_t));
static void d_print_append_char PARAMS ((struct d_print_info *, int));
static void d_print_append_buffer PARAMS ((struct d_print_info *, const char *,
					   size_t));
static void d_print_error PARAMS ((struct d_print_info *));
static char *d_print PARAMS ((int, const struct d_comp *, size_t *));
static void d_print_comp PARAMS ((struct d_print_info *,
				  const struct d_comp *));
static void d_print_identifier PARAMS ((struct d_print_info *, const char *,
					int));
static void d_print_mod_list PARAMS ((struct d_print_info *,
				      struct d_print_mod *, int));
static void d_print_mod PARAMS ((struct d_print_info *,
				 const struct d_comp *));
static void d_print_function_type PARAMS ((struct d_print_info *,
					   const struct d_comp *,
					   struct d_print_mod *));
static void d_print_array_type PARAMS ((struct d_print_info *,
					const struct d_comp *,
					struct d_print_mod *));
static void d_print_expr_op PARAMS ((struct d_print_info *,
				     const struct d_comp *));
static void d_print_cast PARAMS ((struct d_print_info *,
				  const struct d_comp *));
static int d_init_info PARAMS ((const char *, int, size_t, struct d_info *));
static char *d_demangle PARAMS ((const char *, int, size_t *));
d507 2
a508 1
#ifdef CP_DEMANGLE_DEBUG
d511 3
a513 3
d_dump (dc, indent)
     struct d_comp *dc;
     int indent;
d515 2
a516 1
  int i;
d518 2
a519 2
  if (dc == NULL)
    return;
d521 7
a527 2
  for (i = 0; i < indent; ++i)
    putchar (' ');
d529 3
a531 30
  switch (dc->type)
    {
    case D_COMP_NAME:
      printf ("name '%.*s'\n", dc->u.s_name.len, dc->u.s_name.s);
      return;
    case D_COMP_TEMPLATE_PARAM:
      printf ("template parameter %ld\n", dc->u.s_number.number);
      return;
    case D_COMP_CTOR:
      printf ("constructor %d\n", (int) dc->u.s_ctor.kind);
      d_dump (dc->u.s_ctor.name, indent + 2);
      return;
    case D_COMP_DTOR:
      printf ("destructor %d\n", (int) dc->u.s_dtor.kind);
      d_dump (dc->u.s_dtor.name, indent + 2);
      return;
    case D_COMP_SUB_STD:
      printf ("standard substitution %s\n", dc->u.s_string.string);
      return;
    case D_COMP_BUILTIN_TYPE:
      printf ("builtin type %s\n", dc->u.s_builtin.type->name);
      return;
    case D_COMP_OPERATOR:
      printf ("operator %s\n", dc->u.s_operator.op->name);
      return;
    case D_COMP_EXTENDED_OPERATOR:
      printf ("extended operator with %d args\n",
	      dc->u.s_extended_operator.args);
      d_dump (dc->u.s_extended_operator.name, indent + 2);
      return;
d533 7
a539 127
    case D_COMP_QUAL_NAME:
      printf ("qualified name\n");
      break;
    case D_COMP_TYPED_NAME:
      printf ("typed name\n");
      break;
    case D_COMP_TEMPLATE:
      printf ("template\n");
      break;
    case D_COMP_VTABLE:
      printf ("vtable\n");
      break;
    case D_COMP_VTT:
      printf ("VTT\n");
      break;
    case D_COMP_CONSTRUCTION_VTABLE:
      printf ("construction vtable\n");
      break;
    case D_COMP_TYPEINFO:
      printf ("typeinfo\n");
      break;
    case D_COMP_TYPEINFO_NAME:
      printf ("typeinfo name\n");
      break;
    case D_COMP_TYPEINFO_FN:
      printf ("typeinfo function\n");
      break;
    case D_COMP_THUNK:
      printf ("thunk\n");
      break;
    case D_COMP_VIRTUAL_THUNK:
      printf ("virtual thunk\n");
      break;
    case D_COMP_COVARIANT_THUNK:
      printf ("covariant thunk\n");
      break;
    case D_COMP_JAVA_CLASS:
      printf ("java class\n");
      break;
    case D_COMP_GUARD:
      printf ("guard\n");
      break;
    case D_COMP_REFTEMP:
      printf ("reference temporary\n");
      break;
    case D_COMP_RESTRICT:
      printf ("restrict\n");
      break;
    case D_COMP_VOLATILE:
      printf ("volatile\n");
      break;
    case D_COMP_CONST:
      printf ("const\n");
      break;
    case D_COMP_RESTRICT_THIS:
      printf ("restrict this\n");
      break;
    case D_COMP_VOLATILE_THIS:
      printf ("volatile this\n");
      break;
    case D_COMP_CONST_THIS:
      printf ("const this\n");
      break;
    case D_COMP_VENDOR_TYPE_QUAL:
      printf ("vendor type qualifier\n");
      break;
    case D_COMP_POINTER:
      printf ("pointer\n");
      break;
    case D_COMP_REFERENCE:
      printf ("reference\n");
      break;
    case D_COMP_COMPLEX:
      printf ("complex\n");
      break;
    case D_COMP_IMAGINARY:
      printf ("imaginary\n");
      break;
    case D_COMP_VENDOR_TYPE:
      printf ("vendor type\n");
      break;
    case D_COMP_FUNCTION_TYPE:
      printf ("function type\n");
      break;
    case D_COMP_ARRAY_TYPE:
      printf ("array type\n");
      break;
    case D_COMP_PTRMEM_TYPE:
      printf ("pointer to member type\n");
      break;
    case D_COMP_ARGLIST:
      printf ("argument list\n");
      break;
    case D_COMP_TEMPLATE_ARGLIST:
      printf ("template argument list\n");
      break;
    case D_COMP_CAST:
      printf ("cast\n");
      break;
    case D_COMP_UNARY:
      printf ("unary operator\n");
      break;
    case D_COMP_BINARY:
      printf ("binary operator\n");
      break;
    case D_COMP_BINARY_ARGS:
      printf ("binary operator arguments\n");
      break;
    case D_COMP_TRINARY:
      printf ("trinary operator\n");
      break;
    case D_COMP_TRINARY_ARG1:
      printf ("trinary operator arguments 1\n");
      break;
    case D_COMP_TRINARY_ARG2:
      printf ("trinary operator arguments 1\n");
      break;
    case D_COMP_LITERAL:
      printf ("literal\n");
      break;
    case D_COMP_LITERAL_NEG:
      printf ("negative literal\n");
      break;
    }

  d_dump (d_left (dc), indent + 2);
  d_dump (d_right (dc), indent + 2);
d542 3
a544 1
#endif /* CP_DEMANGLE_DEBUG */
d546 3
a548 6
/* Add a new component.  */

static struct d_comp *
d_make_empty (di, type)
     struct d_info *di;
     enum d_comp_type type;
d550 2
a551 1
  struct d_comp *p;
d553 3
a555 41
  if (di->next_comp >= di->num_comps)
    return NULL;
  p = &di->comps[di->next_comp];
  p->type = type;
  ++di->next_comp;
  return p;
}

/* Add a new generic component.  */

static struct d_comp *
d_make_comp (di, type, left, right)
     struct d_info *di;
     enum d_comp_type type;
     struct d_comp *left;
     struct d_comp *right;
{
  struct d_comp *p;

  /* We check for errors here.  A typical error would be a NULL return
     from a subroutine.  We catch those here, and return NULL
     upward.  */
  switch (type)
    {
      /* These types require two parameters.  */
    case D_COMP_QUAL_NAME:
    case D_COMP_TYPED_NAME:
    case D_COMP_TEMPLATE:
    case D_COMP_VENDOR_TYPE_QUAL:
    case D_COMP_PTRMEM_TYPE:
    case D_COMP_UNARY:
    case D_COMP_BINARY:
    case D_COMP_BINARY_ARGS:
    case D_COMP_TRINARY:
    case D_COMP_TRINARY_ARG1:
    case D_COMP_TRINARY_ARG2:
    case D_COMP_LITERAL:
    case D_COMP_LITERAL_NEG:
      if (left == NULL || right == NULL)
	return NULL;
      break;
d557 9
a565 31
      /* These types only require one parameter.  */
    case D_COMP_VTABLE:
    case D_COMP_VTT:
    case D_COMP_CONSTRUCTION_VTABLE:
    case D_COMP_TYPEINFO:
    case D_COMP_TYPEINFO_NAME:
    case D_COMP_TYPEINFO_FN:
    case D_COMP_THUNK:
    case D_COMP_VIRTUAL_THUNK:
    case D_COMP_COVARIANT_THUNK:
    case D_COMP_JAVA_CLASS:
    case D_COMP_GUARD:
    case D_COMP_REFTEMP:
    case D_COMP_POINTER:
    case D_COMP_REFERENCE:
    case D_COMP_COMPLEX:
    case D_COMP_IMAGINARY:
    case D_COMP_VENDOR_TYPE:
    case D_COMP_ARGLIST:
    case D_COMP_TEMPLATE_ARGLIST:
    case D_COMP_CAST:
      if (left == NULL)
	return NULL;
      break;

      /* This needs a right parameter, but the left parameter can be
	 empty.  */
    case D_COMP_ARRAY_TYPE:
      if (right == NULL)
	return NULL;
      break;
d567 2
a568 10
      /* These are allowed to have no parameters--in some cases they
	 will be filled in later.  */
    case D_COMP_FUNCTION_TYPE:
    case D_COMP_RESTRICT:
    case D_COMP_VOLATILE:
    case D_COMP_CONST:
    case D_COMP_RESTRICT_THIS:
    case D_COMP_VOLATILE_THIS:
    case D_COMP_CONST_THIS:
      break;
d570 7
a576 3
      /* Other types should not be seen here.  */
    default:
      return NULL;
d579 2
a580 2
  p = d_make_empty (di, type);
  if (p != NULL)
d582 16
a597 2
      p->u.s_binary.left = left;
      p->u.s_binary.right = right;
d599 11
a609 1
  return p;
d612 5
a616 1
/* Add a new name component.  */
d618 5
a622 5
static struct d_comp *
d_make_name (di, s, len)
     struct d_info *di;
     const char *s;
     int len;
d624 1
a624 1
  struct d_comp *p;
d626 2
a627 1
  if (s == NULL || len == 0)
d629 4
a632 7
  p = d_make_empty (di, D_COMP_NAME);
  if (p != NULL)
    {
      p->u.s_name.s = s;
      p->u.s_name.len = len;
    }
  return p;
d635 2
a636 1
/* Add a new builtin type component.  */
d638 4
a641 4
static struct d_comp *
d_make_builtin_type (di, type)
     struct d_info *di;
     const struct d_builtin_type_info *type;
d643 8
a650 1
  struct d_comp *p;
d652 6
a657 6
  if (type == NULL)
    return NULL;
  p = d_make_empty (di, D_COMP_BUILTIN_TYPE);
  if (p != NULL)
    p->u.s_builtin.type = type;
  return p;
d660 4
a663 1
/* Add a new operator component.  */
d665 2
a666 4
static struct d_comp *
d_make_operator (di, op)
     struct d_info *di;
     const struct d_operator_info *op;
d668 9
a676 6
  struct d_comp *p;

  p = d_make_empty (di, D_COMP_OPERATOR);
  if (p != NULL)
    p->u.s_operator.op = op;
  return p;
d679 2
a680 1
/* Add a new extended operator component.  */
d682 3
a684 5
static struct d_comp *
d_make_extended_operator (di, args, name)
     struct d_info *di;
     int args;
     struct d_comp *name;
d686 43
a728 9
  struct d_comp *p;

  if (name == NULL)
    return NULL;
  p = d_make_empty (di, D_COMP_EXTENDED_OPERATOR);
  if (p != NULL)
    {
      p->u.s_extended_operator.args = args;
      p->u.s_extended_operator.name = name;
d730 2
a731 1
  return p;
d734 1
a734 1
/* Add a new constructor component.  */
d736 4
a739 5
static struct d_comp *
d_make_ctor (di, kind,  name)
     struct d_info *di;
     enum gnu_v3_ctor_kinds kind;
     struct d_comp *name;
d741 11
a751 1
  struct d_comp *p;
d753 15
a767 7
  if (name == NULL)
    return NULL;
  p = d_make_empty (di, D_COMP_CTOR);
  if (p != NULL)
    {
      p->u.s_ctor.kind = kind;
      p->u.s_ctor.name = name;
a768 1
  return p;
d771 3
a773 1
/* Add a new destructor component.  */
d775 4
a778 5
static struct d_comp *
d_make_dtor (di, kind, name)
     struct d_info *di;
     enum gnu_v3_dtor_kinds kind;
     struct d_comp *name;
d780 2
a781 1
  struct d_comp *p;
d783 2
a784 4
  if (name == NULL)
    return NULL;
  p = d_make_empty (di, D_COMP_DTOR);
  if (p != NULL)
d786 6
a791 2
      p->u.s_dtor.kind = kind;
      p->u.s_dtor.name = name;
a792 1
  return p;
d795 4
a798 1
/* Add a new template parameter.  */
d800 3
a802 4
static struct d_comp *
d_make_template_param (di, i)
     struct d_info *di;
     long i;
d804 1
a804 6
  struct d_comp *p;

  p = d_make_empty (di, D_COMP_TEMPLATE_PARAM);
  if (p != NULL)
    p->u.s_number.number = i;
  return p;
d807 3
a809 1
/* Add a new standard substitution component.  */
d811 2
a812 3
static struct d_comp *
d_make_sub (di, name)
     struct d_info *di;
d814 1
d816 4
a819 1
  struct d_comp *p;
d821 21
a841 4
  p = d_make_empty (di, D_COMP_SUB_STD);
  if (p != NULL)
    p->u.s_string.string = name;
  return p;
d844 2
a845 1
/* <mangled-name> ::= _Z <encoding>
d847 6
a852 1
   TOP_LEVEL is non-zero when called at the top level.  */
d854 112
a965 4
static struct d_comp *
d_mangled_name (di, top_level)
     struct d_info *di;
     int top_level;
d967 1
a967 6
  if (d_next_char (di) != '_')
    return NULL;
  if (d_next_char (di) != 'Z')
    return NULL;
  return d_encoding (di, top_level);
}
d969 6
a974 16
/* Return whether a function should have a return type.  The argument
   is the function name, which may be qualified in various ways.  The
   rules are that template functions have return types with some
   exceptions, function types which are not part of a function name
   mangling have return types with some exceptions, and non-template
   function names do not have return types.  The exceptions are that
   constructors, destructors, and conversion operators do not have
   return types.  */

static int
has_return_type (dc)
     struct d_comp *dc;
{
  if (dc == NULL)
    return 0;
  switch (dc->type)
d976 4
a979 8
    default:
      return 0;
    case D_COMP_TEMPLATE:
      return ! is_ctor_dtor_or_conversion (d_left (dc));
    case D_COMP_RESTRICT_THIS:
    case D_COMP_VOLATILE_THIS:
    case D_COMP_CONST_THIS:
      return has_return_type (d_left (dc));
d983 3
a985 2
/* Return whether a name is a constructor, a destructor, or a
   conversion operator.  */
d987 3
a989 3
static int
is_ctor_dtor_or_conversion (dc)
     struct d_comp *dc;
d991 5
a995 13
  if (dc == NULL)
    return 0;
  switch (dc->type)
    {
    default:
      return 0;
    case D_COMP_QUAL_NAME:
      return is_ctor_dtor_or_conversion (d_right (dc));
    case D_COMP_CTOR:
    case D_COMP_DTOR:
    case D_COMP_CAST:
      return 1;
    }
d998 9
a1006 13
/* <encoding> ::= <(function) name> <bare-function-type>
              ::= <(data) name>
              ::= <special-name>

   TOP_LEVEL is non-zero when called at the top level, in which case
   if DMGL_PARAMS is not set we do not demangle the function
   parameters.  We only set this at the top level, because otherwise
   we would not correctly demangle names in local scopes.  */

static struct d_comp *
d_encoding (di, top_level)
     struct d_info *di;
     int top_level;
d1008 10
a1017 1
  char peek = d_peek_char (di);
d1020 1
a1020 1
    return d_special_name (di);
d1023 2
a1024 1
      struct d_comp *dc;
d1026 4
a1029 3
      dc = d_name (di);

      if (dc != NULL && top_level && (di->options & DMGL_PARAMS) == 0)
d1031 10
a1040 8
	  /* Strip off any initial CV-qualifiers, as they really apply
	     to the `this' parameter, and they were not output by the
	     v2 demangler without DMGL_PARAMS.  */
	  while (dc->type == D_COMP_RESTRICT_THIS
		 || dc->type == D_COMP_VOLATILE_THIS
		 || dc->type == D_COMP_CONST_THIS)
	    dc = d_left (dc);
	  return dc;
d1042 5
d1048 1
a1048 6
      peek = d_peek_char (di);
      if (peek == '\0' || peek == 'E')
	return dc;
      return d_make_comp (di, D_COMP_TYPED_NAME, dc,
			  d_bare_function_type (di, has_return_type (dc)));
    }
d1051 6
a1056 4
/* <name> ::= <nested-name>
          ::= <unscoped-name>
          ::= <unscoped-template-name> <template-args>
          ::= <local-name>
d1058 2
a1059 2
   <unscoped-name> ::= <unqualified-name>
                   ::= St <unqualified-name>
d1061 3
a1063 3
   <unscoped-template-name> ::= <unscoped-name>
                            ::= <substitution>
*/
d1065 4
a1068 3
static struct d_comp *
d_name (di)
     struct d_info *di;
d1070 11
a1080 2
  char peek = d_peek_char (di);
  struct d_comp *dc;
d1085 3
a1087 1
      return d_nested_name (di);
d1090 3
a1092 1
      return d_local_name (di);
d1095 29
a1123 2
      {
	int subst;
d1125 3
a1127 12
	if (d_peek_next_char (di) != 't')
	  {
	    dc = d_substitution (di, 0);
	    subst = 1;
	  }
	else
	  {
	    d_advance (di, 2);
	    dc = d_make_comp (di, D_COMP_QUAL_NAME, d_make_name (di, "std", 3),
			      d_unqualified_name (di));
	    subst = 0;
	  }
d1129 6
a1134 19
	if (d_peek_char (di) != 'I')
	  {
	    /* The grammar does not permit this case to occur if we
	       called d_substitution() above (i.e., subst == 1).  We
	       don't bother to check.  */
	  }
	else
	  {
	    /* This is <template-args>, which means that we just saw
	       <unscoped-template-name>, which is a substitution
	       candidate if we didn't just get it from a
	       substitution.  */
	    if (! subst)
	      {
		if (! d_add_substitution (di, dc))
		  return NULL;
	      }
	    dc = d_make_comp (di, D_COMP_TEMPLATE, dc, d_template_args (di));
	  }
d1136 5
a1140 2
	return dc;
      }
d1142 1
a1142 12
    default:
      dc = d_unqualified_name (di);
      if (d_peek_char (di) == 'I')
	{
	  /* This is <template-args>, which means that we just saw
	     <unscoped-template-name>, which is a substitution
	     candidate.  */
	  if (! d_add_substitution (di, dc))
	    return NULL;
	  dc = d_make_comp (di, D_COMP_TEMPLATE, dc, d_template_args (di));
	}
      return dc;
d1144 2
d1148 3
a1150 3
/* <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E
                 ::= N [<CV-qualifiers>] <template-prefix> <template-args> E
*/
d1152 4
a1155 3
static struct d_comp *
d_nested_name (di)
     struct d_info *di;
d1157 1
a1157 2
  struct d_comp *ret;
  struct d_comp **pret;
d1159 1
a1159 2
  if (d_next_char (di) != 'N')
    return NULL;
d1161 1
a1161 3
  pret = d_cv_qualifiers (di, &ret, 1);
  if (pret == NULL)
    return NULL;
d1163 5
a1167 6
  *pret = d_prefix (di);
  if (*pret == NULL)
    return NULL;

  if (d_next_char (di) != 'E')
    return NULL;
d1169 56
a1224 13
  return ret;
}

/* <prefix> ::= <prefix> <unqualified-name>
            ::= <template-prefix> <template-args>
            ::= <template-param>
            ::=
            ::= <substitution>

   <template-prefix> ::= <prefix> <(template) unqualified-name>
                     ::= <template-param>
                     ::= <substitution>
*/
d1226 1
a1226 5
static struct d_comp *
d_prefix (di)
     struct d_info *di;
{
  struct d_comp *ret = NULL;
a1230 2
      enum d_comp_type comb_type;
      struct d_comp *dc;
d1232 24
a1255 3
      peek = d_peek_char (di);
      if (peek == '\0')
	return NULL;
d1257 14
a1270 12
      /* The older code accepts a <local-name> here, but I don't see
	 that in the grammar.  The older code does not accept a
	 <template-param> here.  */

      comb_type = D_COMP_QUAL_NAME;
      if (IS_DIGIT (peek)
	  || IS_LOWER (peek)
	  || peek == 'C'
	  || peek == 'D')
	dc = d_unqualified_name (di);
      else if (peek == 'S')
	dc = d_substitution (di, 1);
d1273 10
a1282 4
	  if (ret == NULL)
	    return NULL;
	  comb_type = D_COMP_TEMPLATE;
	  dc = d_template_args (di);
a1283 2
      else if (peek == 'T')
	dc = d_template_param (di);
d1285 2
a1286 6
	return ret;
      else
	return NULL;

      if (ret == NULL)
	ret = dc;
d1288 1
a1288 1
	ret = d_make_comp (di, comb_type, ret, dc);
d1290 4
a1293 5
      if (peek != 'S' && d_peek_char (di) != 'E')
	{
	  if (! d_add_substitution (di, ret))
	    return NULL;
	}
d1297 5
a1301 21
/* <unqualified-name> ::= <operator-name>
                      ::= <ctor-dtor-name>
                      ::= <source-name>
*/

static struct d_comp *
d_unqualified_name (di)
     struct d_info *di;
{
  char peek;

  peek = d_peek_char (di);
  if (IS_DIGIT (peek))
    return d_source_name (di);
  else if (IS_LOWER (peek))
    return d_operator_name (di);
  else if (peek == 'C' || peek == 'D')
    return d_ctor_dtor_name (di);
  else
    return NULL;
}
d1303 3
a1305 1
/* <source-name> ::= <(positive length) number> <identifier>  */
d1307 4
a1310 3
static struct d_comp *
d_source_name (di)
     struct d_info *di;
d1312 1
a1312 2
  long len;
  struct d_comp *ret;
d1314 1
a1314 7
  len = d_number (di);
  if (len <= 0)
    return NULL;
  ret = d_identifier (di, len);
  di->last_name = ret;
  return ret;
}
d1316 3
a1318 1
/* number ::= [n] <(non-negative decimal integer)>  */
d1320 5
a1324 7
static long
d_number (di)
     struct d_info *di;
{
  int sign;
  char peek;
  long ret;
d1326 3
a1328 8
  sign = 1;
  peek = d_peek_char (di);
  if (peek == 'n')
    {
      sign = -1;
      d_advance (di, 1);
      peek = d_peek_char (di);
    }
d1330 1
a1330 8
  ret = 0;
  while (1)
    {
      if (! IS_DIGIT (peek))
	return ret * sign;
      ret = ret * 10 + peek - '0';
      d_advance (di, 1);
      peek = d_peek_char (di);
d1332 1
a1332 20
}

/* identifier ::= <(unqualified source code identifier)>  */

static struct d_comp *
d_identifier (di, len)
     struct d_info *di;
     int len;
{
  const char *name;

  name = d_str (di);
  d_advance (di, len);

  /* Look for something which looks like a gcc encoding of an
     anonymous namespace, and replace it with a more user friendly
     name.  */
  if (len >= (int) ANONYMOUS_NAMESPACE_PREFIX_LEN + 2
      && memcmp (name, ANONYMOUS_NAMESPACE_PREFIX,
		 ANONYMOUS_NAMESPACE_PREFIX_LEN) == 0)
d1334 3
a1336 1
      const char *s;
d1338 1
a1338 5
      s = name + ANONYMOUS_NAMESPACE_PREFIX_LEN;
      if ((*s == '.' || *s == '_' || *s == '$')
	  && s[1] == 'N')
	return d_make_name (di, "(anonymous namespace)",
			    sizeof "(anonymous namespace)" - 1);
d1340 2
d1343 1
a1343 1
  return d_make_name (di, name, len);
d1346 1
a1346 4
/* operator_name ::= many different two character encodings.
                 ::= cv <type>
                 ::= v <digit> <source-name>
*/
d1348 1
a1348 52
static const struct d_operator_info d_operators[] =
{
  { "aN", "&=",        2 },
  { "aS", "=",         2 },
  { "aa", "&&",        2 },
  { "ad", "&",         1 },
  { "an", "&",         2 },
  { "cl", "()",        0 },
  { "cm", ",",         2 },
  { "co", "~",         1 },
  { "dV", "/=",        2 },
  { "da", "delete[]",  1 },
  { "de", "*",         1 },
  { "dl", "delete",    1 },
  { "dv", "/",         2 },
  { "eO", "^=",        2 },
  { "eo", "^",         2 },
  { "eq", "==",        2 },
  { "ge", ">=",        2 },
  { "gt", ">",         2 },
  { "ix", "[]",        2 },
  { "lS", "<<=",       2 },
  { "le", "<=",        2 },
  { "ls", "<<",        2 },
  { "lt", "<",         2 },
  { "mI", "-=",        2 },
  { "mL", "*=",        2 },
  { "mi", "-",         2 },
  { "ml", "*",         2 },
  { "mm", "--",        1 },
  { "na", "new[]",     1 },
  { "ne", "!=",        2 },
  { "ng", "-",         1 },
  { "nt", "!",         1 },
  { "nw", "new",       1 },
  { "oR", "|=",        2 },
  { "oo", "||",        2 },
  { "or", "|",         2 },
  { "pL", "+=",        2 },
  { "pl", "+",         2 },
  { "pm", "->*",       2 },
  { "pp", "++",        1 },
  { "ps", "+",         1 },
  { "pt", "->",        2 },
  { "qu", "?",         3 },
  { "rM", "%=",        2 },
  { "rS", ">>=",       2 },
  { "rm", "%",         2 },
  { "rs", ">>",        2 },
  { "st", "sizeof ",   1 },
  { "sz", "sizeof ",   1 }
};
d1350 3
a1352 3
static struct d_comp *
d_operator_name (di)
     struct d_info *di;
d1354 1
a1354 2
  char c1;
  char c2;
d1356 1
a1356 10
  c1 = d_next_char (di);
  c2 = d_next_char (di);
  if (c1 == 'v' && IS_DIGIT (c2))
    return d_make_extended_operator (di, c2 - '0', d_source_name (di));
  else if (c1 == 'c' && c2 == 'v')
    return d_make_comp (di, D_COMP_CAST, d_type (di), NULL);
  else
    {
      int low = 0;
      int high = sizeof (d_operators) / sizeof (d_operators[0]);
d1358 4
a1361 4
      while (1)
	{
	  int i;
	  const struct d_operator_info *p;
d1363 4
a1366 2
	  i = low + (high - low) / 2;
	  p = d_operators + i;
d1368 2
a1369 2
	  if (c1 == p->code[0] && c2 == p->code[1])
	    return d_make_operator (di, p);
d1371 1
a1371 8
	  if (c1 < p->code[0] || (c1 == p->code[0] && c2 < p->code[1]))
	    high = i;
	  else
	    low = i + 1;
	  if (low == high)
	    return NULL;
	}
    }
d1374 9
a1382 13
/* <special-name> ::= TV <type>
                  ::= TT <type>
                  ::= TI <type>
                  ::= TS <type>
                  ::= GV <(object) name>
                  ::= T <call-offset> <(base) encoding>
                  ::= Tc <call-offset> <call-offset> <(base) encoding>
   Also g++ extensions:
                  ::= TC <type> <(offset) number> _ <(base) type>
                  ::= TF <type>
                  ::= TJ <type>
                  ::= GR <name>
*/
d1384 6
a1389 3
static struct d_comp *
d_special_name (di)
     struct d_info *di;
d1391 3
a1393 1
  char c;
d1395 2
a1396 13
  c = d_next_char (di);
  if (c == 'T')
    {
      switch (d_next_char (di))
	{
	case 'V':
	  return d_make_comp (di, D_COMP_VTABLE, d_type (di), NULL);
	case 'T':
	  return d_make_comp (di, D_COMP_VTT, d_type (di), NULL);
	case 'I':
	  return d_make_comp (di, D_COMP_TYPEINFO, d_type (di), NULL);
	case 'S':
	  return d_make_comp (di, D_COMP_TYPEINFO_NAME, d_type (di), NULL);
d1398 3
a1400 4
	case 'h':
	  if (! d_call_offset (di, 'h'))
	    return NULL;
	  return d_make_comp (di, D_COMP_THUNK, d_encoding (di, 0), NULL);
d1402 2
a1403 5
	case 'v':
	  if (! d_call_offset (di, 'v'))
	    return NULL;
	  return d_make_comp (di, D_COMP_VIRTUAL_THUNK, d_encoding (di, 0),
			      NULL);
d1405 6
a1410 7
	case 'c':
	  if (! d_call_offset (di, '\0'))
	    return NULL;
	  if (! d_call_offset (di, '\0'))
	    return NULL;
	  return d_make_comp (di, D_COMP_COVARIANT_THUNK, d_encoding (di, 0),
			      NULL);
d1412 8
a1419 18
	case 'C':
	  {
	    struct d_comp *derived_type;
	    long offset;
	    struct d_comp *base_type;

	    derived_type = d_type (di);
	    offset = d_number (di);
	    if (offset < 0)
	      return NULL;
	    if (d_next_char (di) != '_')
	      return NULL;
	    base_type = d_type (di);
	    /* We don't display the offset.  FIXME: We should display
	       it in verbose mode.  */
	    return d_make_comp (di, D_COMP_CONSTRUCTION_VTABLE, base_type,
				derived_type);
	  }
d1421 2
a1422 4
	case 'F':
	  return d_make_comp (di, D_COMP_TYPEINFO_FN, d_type (di), NULL);
	case 'J':
	  return d_make_comp (di, D_COMP_JAVA_CLASS, d_type (di), NULL);
d1424 9
a1432 3
	default:
	  return NULL;
	}
d1434 3
a1436 1
  else if (c == 'G')
d1438 3
a1440 1
      switch (d_next_char (di))
d1442 3
a1444 8
	case 'V':
	  return d_make_comp (di, D_COMP_GUARD, d_name (di), NULL);

	case 'R':
	  return d_make_comp (di, D_COMP_REFTEMP, d_name (di), NULL);

	default:
	  return NULL;
d1446 3
d1450 2
a1451 2
  else
    return NULL;
d1454 2
a1455 2
/* <call-offset> ::= h <nv-offset> _
                 ::= v <v-offset> _
d1457 7
a1463 1
   <nv-offset> ::= <(offset) number>
d1465 3
a1467 1
   <v-offset> ::= <(offset) number> _ <(virtual offset) number>
d1469 6
a1474 2
   The C parameter, if not '\0', is a character we just read which is
   the start of the <call-offset>.
d1476 32
a1507 2
   We don't display the offset information anywhere.  FIXME: We should
   display it in verbose mode.  */
d1509 3
a1511 7
static int
d_call_offset (di, c)
     struct d_info *di;
     int c;
{
  long offset;
  long virtual_offset;
d1513 21
a1533 11
  if (c == '\0')
    c = d_next_char (di);

  if (c == 'h')
    offset = d_number (di);
  else if (c == 'v')
    {
      offset = d_number (di);
      if (d_next_char (di) != '_')
	return 0;
      virtual_offset = d_number (di);
a1534 2
  else
    return 0;
d1536 2
a1537 2
  if (d_next_char (di) != '_')
    return 0;
d1539 76
a1614 2
  return 1;
}
d1616 94
a1709 7
/* <ctor-dtor-name> ::= C1
                    ::= C2
                    ::= C3
                    ::= D0
                    ::= D1
                    ::= D2
*/
d1711 2
a1712 5
static struct d_comp *
d_ctor_dtor_name (di)
     struct d_info *di;
{
  switch (d_next_char (di))
d1714 3
a1716 3
    case 'C':
      {
	enum gnu_v3_ctor_kinds kind;
d1718 7
a1724 16
	switch (d_next_char (di))
	  {
	  case '1':
	    kind = gnu_v3_complete_object_ctor;
	    break;
	  case '2':
	    kind = gnu_v3_base_object_ctor;
	    break;
	  case '3':
	    kind = gnu_v3_complete_object_allocating_ctor;
	    break;
	  default:
	    return NULL;
	  }
	return d_make_ctor (di, kind, di->last_name);
      }
d1726 2
a1727 3
    case 'D':
      {
	enum gnu_v3_dtor_kinds kind;
d1729 9
a1737 19
	switch (d_next_char (di))
	  {
	  case '0':
	    kind = gnu_v3_deleting_dtor;
	    break;
	  case '1':
	    kind = gnu_v3_complete_object_dtor;
	    break;
	  case '2':
	    kind = gnu_v3_base_object_dtor;
	    break;
	  default:
	    return NULL;
	  }
	return d_make_dtor (di, kind, di->last_name);
      }

    default:
      return NULL;
d1741 1
a1741 14
/* <type> ::= <builtin-type>
          ::= <function-type>
          ::= <class-enum-type>
          ::= <array-type>
          ::= <pointer-to-member-type>
          ::= <template-param>
          ::= <template-template-param> <template-args>
          ::= <substitution>
          ::= <CV-qualifiers> <type>
          ::= P <type>
          ::= R <type>
          ::= C <type>
          ::= G <type>
          ::= U <source-name> <type>
d1743 1
a1743 3
   <builtin-type> ::= various one letter codes
                  ::= u <source-name>
*/
d1745 3
a1747 1
static const struct d_builtin_type_info d_builtin_types[26] =
d1749 2
a1750 27
  /* a */ { "signed char",	"signed char",		D_PRINT_INT },
  /* b */ { "bool",		"boolean",		D_PRINT_BOOL },
  /* c */ { "char",		"byte",			D_PRINT_INT },
  /* d */ { "double",		"double",		D_PRINT_DEFAULT },
  /* e */ { "long double",	"long double",		D_PRINT_DEFAULT },
  /* f */ { "float",		"float",		D_PRINT_DEFAULT },
  /* g */ { "__float128",	"__float128",		D_PRINT_DEFAULT },
  /* h */ { "unsigned char",	"unsigned char",	D_PRINT_INT },
  /* i */ { "int",		"int",			D_PRINT_INT },
  /* j */ { "unsigned int",	"unsigned",		D_PRINT_INT },
  /* k */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* l */ { "long",		"long",			D_PRINT_LONG },
  /* m */ { "unsigned long",	"unsigned long",	D_PRINT_LONG },
  /* n */ { "__int128",		"__int128",		D_PRINT_DEFAULT },
  /* o */ { "unsigned __int128", "unsigned __int128",	D_PRINT_DEFAULT },
  /* p */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* q */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* r */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* s */ { "short",		"short",		D_PRINT_INT },
  /* t */ { "unsigned short",	"unsigned short",	D_PRINT_INT },
  /* u */ { NULL,		NULL,			D_PRINT_DEFAULT },
  /* v */ { "void",		"void",			D_PRINT_VOID },
  /* w */ { "wchar_t",		"char",			D_PRINT_INT },
  /* x */ { "long long",	"long",			D_PRINT_DEFAULT },
  /* y */ { "unsigned long long", "unsigned long long",	D_PRINT_DEFAULT },
  /* z */ { "...",		"...",			D_PRINT_DEFAULT },
};
d1752 1
a1752 7
static struct d_comp *
d_type (di)
     struct d_info *di;
{
  char peek;
  struct d_comp *ret;
  int can_subst;
d1754 5
a1758 14
  /* The ABI specifies that when CV-qualifiers are used, the base type
     is substitutable, and the fully qualified type is substitutable,
     but the base type with a strict subset of the CV-qualifiers is
     not substitutable.  The natural recursive implementation of the
     CV-qualifiers would cause subsets to be substitutable, so instead
     we pull them all off now.

     FIXME: The ABI says that order-insensitive vendor qualifiers
     should be handled in the same way, but we have no way to tell
     which vendor qualifiers are order-insensitive and which are
     order-sensitive.  So we just assume that they are all
     order-sensitive.  g++ 3.4 supports only one vendor qualifier,
     __vector, and it treats it as order-sensitive when mangling
     names.  */
d1760 2
a1761 2
  peek = d_peek_char (di);
  if (peek == 'r' || peek == 'V' || peek == 'K')
d1763 6
a1768 1
      struct d_comp **pret;
d1770 5
a1774 8
      pret = d_cv_qualifiers (di, &ret, 0);
      if (pret == NULL)
	return NULL;
      *pret = d_type (di);
      if (! d_add_substitution (di, ret))
	return NULL;
      return ret;
    }
d1776 1
a1776 1
  can_subst = 1;
d1778 2
a1779 10
  switch (peek)
    {
    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':
    case 'h': case 'i': case 'j':           case 'l': case 'm': case 'n':
    case 'o':                               case 's': case 't':
    case 'v': case 'w': case 'x': case 'y': case 'z':
      ret = d_make_builtin_type (di, &d_builtin_types[peek - 'a']);
      can_subst = 0;
      d_advance (di, 1);
      break;
d1781 6
a1786 4
    case 'u':
      d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_VENDOR_TYPE, d_source_name (di), NULL);
      break;
d1788 1
a1788 3
    case 'F':
      ret = d_function_type (di);
      break;
d1790 5
a1794 6
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    case 'N':
    case 'Z':
      ret = d_class_enum_type (di);
      break;
d1796 11
a1806 3
    case 'A':
      ret = d_array_type (di);
      break;
d1808 2
a1809 3
    case 'M':
      ret = d_pointer_to_member_type (di);
      break;
d1811 5
a1815 12
    case 'T':
      ret = d_template_param (di);
      if (d_peek_char (di) == 'I')
	{
	  /* This is <template-template-param> <template-args>.  The
	     <template-template-param> part is a substitution
	     candidate.  */
	  if (! d_add_substitution (di, ret))
	    return NULL;
	  ret = d_make_comp (di, D_COMP_TEMPLATE, ret, d_template_args (di));
	}
      break;
d1817 9
a1825 5
    case 'S':
      /* If this is a special substitution, then it is the start of
	 <class-enum-type>.  */
      {
	char peek_next;
d1827 2
a1828 26
	peek_next = d_peek_next_char (di);
	if (IS_DIGIT (peek_next)
	    || peek_next == '_'
	    || IS_UPPER (peek_next))
	  {
	    ret = d_substitution (di, 0);
	    /* The substituted name may have been a template name and
	       may be followed by tepmlate args.  */
	    if (d_peek_char (di) == 'I')
	      ret = d_make_comp (di, D_COMP_TEMPLATE, ret,
				 d_template_args (di));
	    else
	      can_subst = 0;
	  }
	else
	  {
	    ret = d_class_enum_type (di);
	    /* If the substitution was a complete type, then it is not
	       a new substitution candidate.  However, if the
	       substitution was followed by template arguments, then
	       the whole thing is a substitution candidate.  */
	    if (ret != NULL && ret->type == D_COMP_SUB_STD)
	      can_subst = 0;
	  }
      }
      break;
d1830 1
a1830 4
    case 'P':
      d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_POINTER, d_type (di), NULL);
      break;
d1832 2
a1833 4
    case 'R':
      d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_REFERENCE, d_type (di), NULL);
      break;
d1835 5
a1839 4
    case 'C':
      d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_COMPLEX, d_type (di), NULL);
      break;
d1841 8
a1848 3
    case 'G':
      d_advance (di, 1);
      ret = d_make_comp (di, D_COMP_IMAGINARY, d_type (di), NULL);
d1851 6
a1856 4
    case 'U':
      d_advance (di, 1);
      ret = d_source_name (di);
      ret = d_make_comp (di, D_COMP_VENDOR_TYPE_QUAL, d_type (di), ret);
d1860 1
a1860 1
      return NULL;
d1863 2
a1864 5
  if (can_subst)
    {
      if (! d_add_substitution (di, ret))
	return NULL;
    }
d1866 1
a1866 2
  return ret;
}
d1868 5
a1872 1
/* <CV-qualifiers> ::= [r] [V] [K]  */
d1874 1
a1874 7
static struct d_comp **
d_cv_qualifiers (di, pret, member_fn)
     struct d_info *di;
     struct d_comp **pret;
     int member_fn;
{
  char peek;
d1876 2
a1877 4
  peek = d_peek_char (di);
  while (peek == 'r' || peek == 'V' || peek == 'K')
    {
      enum d_comp_type t;
d1879 4
a1882 7
      d_advance (di, 1);
      if (peek == 'r')
	t = member_fn ? D_COMP_RESTRICT_THIS: D_COMP_RESTRICT;
      else if (peek == 'V')
	t = member_fn ? D_COMP_VOLATILE_THIS : D_COMP_VOLATILE;
      else
	t = member_fn ? D_COMP_CONST_THIS: D_COMP_CONST;
d1884 1
a1884 4
      *pret = d_make_comp (di, t, NULL, NULL);
      if (*pret == NULL)
	return NULL;
      pret = &d_left (*pret);
d1886 2
a1887 2
      peek = d_peek_char (di);
    }
d1889 1
a1889 2
  return pret;
}
d1891 4
a1894 1
/* <function-type> ::= F [Y] <bare-function-type> E  */
d1896 3
a1898 3
static struct d_comp *
d_function_type (di)
     struct d_info *di;
d1900 3
a1902 1
  struct d_comp *ret;
d1904 1
a1904 24
  if (d_next_char (di) != 'F')
    return NULL;
  if (d_peek_char (di) == 'Y')
    {
      /* Function has C linkage.  We don't print this information.
	 FIXME: We should print it in verbose mode.  */
      d_advance (di, 1);
    }
  ret = d_bare_function_type (di, 1);
  if (d_next_char (di) != 'E')
    return NULL;
  return ret;
}

/* <bare-function-type> ::= <type>+  */

static struct d_comp *
d_bare_function_type (di, has_return_type)
     struct d_info *di;
     int has_return_type;
{
  struct d_comp *return_type;
  struct d_comp *tl;
  struct d_comp **ptl;
d1906 1
a1906 4
  return_type = NULL;
  tl = NULL;
  ptl = &tl;
  while (1)
d1908 10
a1917 2
      char peek;
      struct d_comp *type;
d1919 9
a1927 17
      peek = d_peek_char (di);
      if (peek == '\0' || peek == 'E')
	break;
      type = d_type (di);
      if (type == NULL)
	return NULL;
      if (has_return_type)
	{
	  return_type = type;
	  has_return_type = 0;
	}
      else
	{
	  *ptl = d_make_comp (di, D_COMP_ARGLIST, type, NULL);
	  if (*ptl == NULL)
	    return NULL;
	  ptl = &d_right (*ptl);
d1930 3
d1934 2
a1935 5
  /* There should be at least one parameter type besides the optional
     return type.  A function which takes no arguments will have a
     single parameter type void.  */
  if (tl == NULL)
    return NULL;
d1937 8
a1944 5
  /* If we have a single parameter type void, omit it.  */
  if (d_right (tl) == NULL
      && d_left (tl)->type == D_COMP_BUILTIN_TYPE
      && d_left (tl)->u.s_builtin.type->print == D_PRINT_VOID)
    tl = NULL;
d1946 6
a1951 2
  return d_make_comp (di, D_COMP_FUNCTION_TYPE, return_type, tl);
}
d1953 6
a1958 1
/* <class-enum-type> ::= <name>  */
d1960 6
a1965 6
static struct d_comp *
d_class_enum_type (di)
     struct d_info *di;
{
  return d_name (di);
}
d1967 6
a1972 3
/* <array-type> ::= A <(positive dimension) number> _ <(element) type>
                ::= A [<(dimension) expression>] _ <(element) type>
*/
d1974 6
a1979 6
static struct d_comp *
d_array_type (di)
     struct d_info *di;
{
  char peek;
  struct d_comp *dim;
d1981 11
a1991 2
  if (d_next_char (di) != 'A')
    return NULL;
d1993 11
a2003 6
  peek = d_peek_char (di);
  if (peek == '_')
    dim = NULL;
  else if (IS_DIGIT (peek))
    {
      const char *s;
d2005 10
a2014 17
      s = d_str (di);
      do
	{
	  d_advance (di, 1);
	  peek = d_peek_char (di);
	}
      while (IS_DIGIT (peek));
      dim = d_make_name (di, s, d_str (di) - s);
      if (dim == NULL)
	return NULL;
    }
  else
    {
      dim = d_expression (di);
      if (dim == NULL)
	return NULL;
    }
d2016 5
a2020 2
  if (d_next_char (di) != '_')
    return NULL;
d2022 2
a2023 2
  return d_make_comp (di, D_COMP_ARRAY_TYPE, dim, d_type (di));
}
d2025 26
a2050 1
/* <pointer-to-member-type> ::= M <(class) type> <(member) type>  */
d2052 12
a2063 7
static struct d_comp *
d_pointer_to_member_type (di)
     struct d_info *di;
{
  struct d_comp *cl;
  struct d_comp *mem;
  struct d_comp **pmem;
d2065 6
a2070 4
  if (d_next_char (di) != 'M')
    return NULL;

  cl = d_type (di);
d2072 1
a2072 19
  /* The ABI specifies that any type can be a substitution source, and
     that M is followed by two types, and that when a CV-qualified
     type is seen both the base type and the CV-qualified types are
     substitution sources.  The ABI also specifies that for a pointer
     to a CV-qualified member function, the qualifiers are attached to
     the second type.  Given the grammar, a plain reading of the ABI
     suggests that both the CV-qualified member function and the
     non-qualified member function are substitution sources.  However,
     g++ does not work that way.  g++ treats only the CV-qualified
     member function as a substitution source.  FIXME.  So to work
     with g++, we need to pull off the CV-qualifiers here, in order to
     avoid calling add_substitution() in d_type().  */

  pmem = d_cv_qualifiers (di, &mem, 1);
  if (pmem == NULL)
    return NULL;
  *pmem = d_type (di);

  return d_make_comp (di, D_COMP_PTRMEM_TYPE, cl, mem);
d2075 13
a2087 7
/* <template-param> ::= T_
                    ::= T <(parameter-2 non-negative) number> _
*/

static struct d_comp *
d_template_param (di)
     struct d_info *di;
d2089 42
a2130 13
  long param;

  if (d_next_char (di) != 'T')
    return NULL;

  if (d_peek_char (di) == '_')
    param = 0;
  else
    {
      param = d_number (di);
      if (param < 0)
	return NULL;
      param += 1;
d2132 1
a2132 28

  if (d_next_char (di) != '_')
    return NULL;

  return d_make_template_param (di, param);
}

/* <template-args> ::= I <template-arg>+ E  */

static struct d_comp *
d_template_args (di)
     struct d_info *di;
{
  struct d_comp *hold_last_name;
  struct d_comp *al;
  struct d_comp **pal;

  /* Preserve the last name we saw--don't let the template arguments
     clobber it, as that would give us the wrong name for a subsequent
     constructor or destructor.  */
  hold_last_name = di->last_name;

  if (d_next_char (di) != 'I')
    return NULL;

  al = NULL;
  pal = &al;
  while (1)
d2134 8
a2141 12
      struct d_comp *a;

      a = d_template_arg (di);
      if (a == NULL)
	return NULL;

      *pal = d_make_comp (di, D_COMP_TEMPLATE_ARGLIST, a, NULL);
      if (*pal == NULL)
	return NULL;
      pal = &d_right (*pal);

      if (d_peek_char (di) == 'E')
d2143 3
a2145 1
	  d_advance (di, 1);
d2147 9
d2158 2
d2161 1
a2161 3
  di->last_name = hold_last_name;

  return al;
d2164 56
a2219 4
/* <template-arg> ::= <type>
                  ::= X <expression> E
                  ::= <expr-primary>
*/
d2221 13
a2233 5
static struct d_comp *
d_template_arg (di)
     struct d_info *di;
{
  struct d_comp *ret;
d2235 1
a2235 1
  switch (d_peek_char (di))
d2237 48
a2284 6
    case 'X':
      d_advance (di, 1);
      ret = d_expression (di);
      if (d_next_char (di) != 'E')
	return NULL;
      return ret;
d2286 2
a2287 2
    case 'L':
      return d_expr_primary (di);
d2289 1
a2289 2
    default:
      return d_type (di);
d2291 1
a2291 1
}
d2293 20
a2312 9
/* <expression> ::= <(unary) operator-name> <expression>
                ::= <(binary) operator-name> <expression> <expression>
                ::= <(trinary) operator-name> <expression> <expression> <expression>
                ::= st <type>
                ::= <template-param>
                ::= sr <type> <unqualified-name>
                ::= sr <type> <unqualified-name> <template-args>
                ::= <expr-primary>
*/
d2314 5
a2318 5
static struct d_comp *
d_expression (di)
     struct d_info *di;
{
  char peek;
d2320 67
a2386 19
  peek = d_peek_char (di);
  if (peek == 'L')
    return d_expr_primary (di);
  else if (peek == 'T')
    return d_template_param (di);
  else if (peek == 's' && d_peek_next_char (di) == 'r')
    {
      struct d_comp *type;
      struct d_comp *name;

      d_advance (di, 2);
      type = d_type (di);
      name = d_unqualified_name (di);
      if (d_peek_char (di) != 'I')
	return d_make_comp (di, D_COMP_QUAL_NAME, type, name);
      else
	return d_make_comp (di, D_COMP_QUAL_NAME, type,
			    d_make_comp (di, D_COMP_TEMPLATE, name,
					 d_template_args (di)));
d2389 32
a2420 3
    {
      struct d_comp *op;
      int args;
d2422 4
a2425 3
      op = d_operator_name (di);
      if (op == NULL)
	return NULL;
d2427 2
a2428 3
      if (op->type == D_COMP_OPERATOR
	  && strcmp (op->u.s_operator.op->code, "st") == 0)
	return d_make_comp (di, D_COMP_UNARY, op, d_type (di));
d2430 3
a2432 14
      switch (op->type)
	{
	default:
	  return NULL;
	case D_COMP_OPERATOR:
	  args = op->u.s_operator.op->args;
	  break;
	case D_COMP_EXTENDED_OPERATOR:
	  args = op->u.s_extended_operator.args;
	  break;
	case D_COMP_CAST:
	  args = 1;
	  break;
	}
d2434 10
a2443 5
      switch (args)
	{
	case 1:
	  return d_make_comp (di, D_COMP_UNARY, op, d_expression (di));
	case 2:
d2445 11
a2455 1
	    struct d_comp *left;
d2457 22
a2478 4
	    left = d_expression (di);
	    return d_make_comp (di, D_COMP_BINARY, op,
				d_make_comp (di, D_COMP_BINARY_ARGS, left,
					     d_expression (di)));
d2480 1
a2480 1
	case 3:
d2482 24
a2505 2
	    struct d_comp *first;
	    struct d_comp *second;
d2507 82
a2588 14
	    first = d_expression (di);
	    second = d_expression (di);
	    return d_make_comp (di, D_COMP_TRINARY, op,
				d_make_comp (di, D_COMP_TRINARY_ARG1, first,
					     d_make_comp (di,
							  D_COMP_TRINARY_ARG2,
							  second,
							  d_expression (di))));
	  }
	default:
	  return NULL;
	}
    }
}
d2590 32
a2621 4
/* <expr-primary> ::= L <type> <(value) number> E
                  ::= L <type> <(value) float> E
                  ::= L <mangled-name> E
*/
d2623 1
a2623 5
static struct d_comp *
d_expr_primary (di)
     struct d_info *di;
{
  struct d_comp *ret;
d2625 53
a2677 4
  if (d_next_char (di) != 'L')
    return NULL;
  if (d_peek_char (di) == '_')
    ret = d_mangled_name (di, 0);
d2679 1
a2679 32
    {
      struct d_comp *type;
      enum d_comp_type t;
      const char *s;

      type = d_type (di);

      /* Rather than try to interpret the literal value, we just
	 collect it as a string.  Note that it's possible to have a
	 floating point literal here.  The ABI specifies that the
	 format of such literals is machine independent.  That's fine,
	 but what's not fine is that versions of g++ up to 3.2 with
	 -fabi-version=1 used upper case letters in the hex constant,
	 and dumped out gcc's internal representation.  That makes it
	 hard to tell where the constant ends, and hard to dump the
	 constant in any readable form anyhow.  We don't attempt to
	 handle these cases.  */

      t = D_COMP_LITERAL;
      if (d_peek_char (di) == 'n')
	{
	  t = D_COMP_LITERAL_NEG;
	  d_advance (di, 1);
	}
      s = d_str (di);
      while (d_peek_char (di) != 'E')
	d_advance (di, 1);
      ret = d_make_comp (di, t, type, d_make_name (di, s, d_str (di) - s));
    }
  if (d_next_char (di) != 'E')
    return NULL;
  return ret;
d2682 3
a2684 3
/* <local-name> ::= Z <(function) encoding> E <(entity) name> [<discriminator>]
                ::= Z <(function) encoding> E s [<discriminator>]
*/
d2686 4
a2689 3
static struct d_comp *
d_local_name (di)
     struct d_info *di;
d2691 1
a2691 1
  struct d_comp *function;
d2693 10
a2702 2
  if (d_next_char (di) != 'Z')
    return NULL;
d2704 6
a2709 1
  function = d_encoding (di, 0);
d2711 6
a2716 2
  if (d_next_char (di) != 'E')
    return NULL;
d2718 3
a2720 12
  if (d_peek_char (di) == 's')
    {
      d_advance (di, 1);
      if (! d_discriminator (di))
	return NULL;
      return d_make_comp (di, D_COMP_QUAL_NAME, function,
			  d_make_name (di, "string literal",
				       sizeof "string literal" - 1));
    }
  else
    {
      struct d_comp *name;
d2722 1
a2722 4
      name = d_name (di);
      if (! d_discriminator (di))
	return NULL;
      return d_make_comp (di, D_COMP_QUAL_NAME, function, name);
d2726 5
a2730 1
/* <discriminator> ::= _ <(non-negative) number>
d2732 1
a2732 2
   We demangle the discriminator, but we don't print it out.  FIXME:
   We should print it out in verbose mode.  */
d2734 4
a2737 3
static int
d_discriminator (di)
     struct d_info *di;
d2739 12
a2750 9
  long discrim;

  if (d_peek_char (di) != '_')
    return 1;
  d_advance (di, 1);
  discrim = d_number (di);
  if (discrim < 0)
    return 0;
  return 1;
d2753 4
a2756 1
/* Add a new substitution.  */
d2758 1
a2758 32
static int
d_add_substitution (di, dc)
     struct d_info *di;
     struct d_comp *dc;
{
  if (dc == NULL)
    return 0;
  if (di->next_sub >= di->num_subs)
    return 0;
  di->subs[di->next_sub] = dc;
  ++di->next_sub;
  return 1;
}

/* <substitution> ::= S <seq-id> _
                  ::= S_
                  ::= St
                  ::= Sa
                  ::= Sb
                  ::= Ss
                  ::= Si
                  ::= So
                  ::= Sd

   If PREFIX is non-zero, then this type is being used as a prefix in
   a qualified name.  In this case, for the standard substitutions, we
   need to check whether we are being used as a prefix for a
   constructor or destructor, and return a full template name.
   Otherwise we will get something like std::iostream::~iostream()
   which does not correspond particularly well to any function which
   actually appears in the source.
*/
d2760 4
a2763 1
static const struct d_standard_sub_info standard_subs[] =
d2765 4
a2768 16
  { 't', "std", "std", NULL },
  { 'a', "std::allocator", "std::allocator", "allocator" },
  { 'b', "std::basic_string", "std::basic_string", "basic_string" },
  { 's', "std::string",
    "std::basic_string<char, std::char_traits<char>, std::allocator<char> >",
    "basic_string" },
  { 'i', "std::istream",
    "std::basic_istream<char, std::char_traits<char> >",
    "basic_istream" },
  { 'o', "std::ostream",
    "std::basic_ostream<char, std::char_traits<char> >",
    "basic_ostream" },
  { 'd', "std::iostream",
    "std::basic_iostream<char, std::char_traits<char> >",
    "basic_iostream" }
};
d2770 1
a2770 6
static struct d_comp *
d_substitution (di, prefix)
     struct d_info *di;
     int prefix;
{
  char c;
d2772 2
a2773 5
  if (d_next_char (di) != 'S')
    return NULL;

  c = d_next_char (di);
  if (c == '_' || IS_DIGIT (c) || IS_UPPER (c))
d2775 5
a2779 1
      int id;
d2781 10
a2790 4
      id = 0;
      if (c != '_')
	{
	  do
d2792 3
a2794 4
	      if (IS_DIGIT (c))
		id = id * 36 + c - '0';
	      else if (IS_UPPER (c))
		id = id * 36 + c - 'A' + 10;
d2796 1
a2796 2
		return NULL;
	      c = d_next_char (di);
a2797 1
	  while (c != '_');
d2799 2
a2800 1
	  ++id;
d2802 1
a2802 14

      if (id >= di->next_sub)
	return NULL;

      return di->subs[id];
    }
  else
    {
      int verbose;
      const struct d_standard_sub_info *p;
      const struct d_standard_sub_info *pend;

      verbose = (di->options & DMGL_VERBOSE) != 0;
      if (! verbose && prefix)
d2804 7
a2810 12
	  char peek;

	  peek = d_peek_char (di);
	  if (peek == 'C' || peek == 'D')
	    verbose = 1;
	}

      pend = (&standard_subs[0]
	      + sizeof standard_subs / sizeof standard_subs[0]);
      for (p = &standard_subs[0]; p < pend; ++p)
	{
	  if (c == p->code)
d2812 5
a2816 6
	      if (p->set_last_name != NULL)
		di->last_name = d_make_sub (di, p->set_last_name);
	      if (verbose)
		return d_make_sub (di, p->full_expansion);
	      else
		return d_make_sub (di, p->simple_expansion);
d2820 1
a2820 1
      return NULL;
d2822 1
a2822 1
}
d2824 7
a2830 1
/* Resize the print buffer.  */
d2832 2
a2833 6
static void
d_print_resize (dpi, add)
     struct d_print_info *dpi;
     size_t add;
{
  size_t need;
d2835 2
a2836 7
  if (dpi->buf == NULL)
    return;
  need = dpi->len + add;
  while (need > dpi->alc)
    {
      size_t newalc;
      char *newbuf;
d2838 1
a2838 13
      newalc = dpi->alc * 2;
      newbuf = realloc (dpi->buf, newalc);
      if (newbuf == NULL)
	{
	  free (dpi->buf);
	  dpi->buf = NULL;
	  dpi->allocation_failure = 1;
	  return;
	}
      dpi->buf = newbuf;
      dpi->alc = newalc;
    }
}
d2840 4
a2843 6
/* Append a character to the print buffer.  */

static void
d_print_append_char (dpi, c)
     struct d_print_info *dpi;
     int c;
d2845 1
a2845 8
  if (dpi->buf != NULL)
    {
      if (dpi->len >= dpi->alc)
	{
	  d_print_resize (dpi, 1);
	  if (dpi->buf == NULL)
	    return;
	}
d2847 2
a2848 3
      dpi->buf[dpi->len] = c;
      ++dpi->len;
    }
d2851 1
a2851 1
/* Append a buffer to the print buffer.  */
d2853 7
a2859 14
static void
d_print_append_buffer (dpi, s, l)
     struct d_print_info *dpi;
     const char *s;
     size_t l;
{
  if (dpi->buf != NULL)
    {
      if (dpi->len + l > dpi->alc)
	{
	  d_print_resize (dpi, l);
	  if (dpi->buf == NULL)
	    return;
	}
d2861 3
a2863 4
      memcpy (dpi->buf + dpi->len, s, l);
      dpi->len += l;
    }
}
d2865 2
a2866 1
/* Indicate that an error occurred during printing.  */
d2868 4
a2871 3
static void
d_print_error (dpi)
     struct d_print_info *dpi;
d2873 3
a2875 3
  free (dpi->buf);
  dpi->buf = NULL;
}
d2877 1
a2877 4
/* Turn components into a human readable string.  Returns a string
   allocated by malloc, or NULL on error.  On success, this sets *PALC
   to the size of the allocated buffer.  On failure, this sets *PALC
   to 0 for a bad parse, or to 1 for a memory allocation failure.  */
d2879 1
a2879 7
static char *
d_print (options, dc, palc)
     int options;
     const struct d_comp *dc;
     size_t *palc;
{
  struct d_print_info dpi;
d2881 14
a2894 5
  dpi.options = options;

  dpi.alc = 64;
  dpi.buf = malloc (dpi.alc);
  if (dpi.buf == NULL)
d2896 65
a2960 16
      *palc = 1;
      return NULL;
    }

  dpi.len = 0;
  dpi.templates = NULL;
  dpi.modifiers = NULL;

  dpi.allocation_failure = 0;

  d_print_comp (&dpi, dc);

  d_append_char (&dpi, '\0');

  if (dpi.buf != NULL)
    *palc = dpi.alc;
a2961 13
    *palc = dpi.allocation_failure;

  return dpi.buf;
}

/* Subroutine to handle components.  */

static void
d_print_comp (dpi, dc)
     struct d_print_info *dpi;
     const struct d_comp *dc;
{
  if (dc == NULL)
d2963 2
a2964 2
      d_print_error (dpi);
      return;
d2966 1
a2966 2
  if (d_print_saw_error (dpi))
    return;
d2968 6
a2973 5
  switch (dc->type)
    {
    case D_COMP_NAME:
      d_print_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);
      return;
d2975 2
a2976 5
    case D_COMP_QUAL_NAME:
      d_print_comp (dpi, d_left (dc));
      d_append_string (dpi, (dpi->options & DMGL_JAVA) == 0 ? "::" : ".");
      d_print_comp (dpi, d_right (dc));
      return;
d2978 1
a2978 33
    case D_COMP_TYPED_NAME:
      {
	struct d_print_mod *hold_modifiers;
	struct d_comp *typed_name;
	struct d_print_mod adpm[4];
	unsigned int i;
	struct d_print_template dpt;

	/* Pass the name down to the type so that it can be printed in
	   the right place for the type.  We also have to pass down
	   any CV-qualifiers, which apply to the this parameter.  */
	hold_modifiers = dpi->modifiers;
	i = 0;
	typed_name = d_left (dc);
	while (typed_name != NULL)
	  {
	    if (i >= sizeof adpm / sizeof adpm[0])
	      {
		d_print_error (dpi);
		return;
	      }

	    adpm[i].next = dpi->modifiers;
	    dpi->modifiers = &adpm[i];
	    adpm[i].mod = typed_name;
	    adpm[i].printed = 0;
	    adpm[i].templates = dpi->templates;
	    ++i;

	    if (typed_name->type != D_COMP_RESTRICT_THIS
		&& typed_name->type != D_COMP_VOLATILE_THIS
		&& typed_name->type != D_COMP_CONST_THIS)
	      break;
d2980 1
a2980 2
	    typed_name = d_left (typed_name);
	  }
d2982 7
a2988 8
	/* If typed_name is a template, then it applies to the
	   function type as well.  */
	if (typed_name->type == D_COMP_TEMPLATE)
	  {
	    dpt.next = dpi->templates;
	    dpi->templates = &dpt;
	    dpt.template = typed_name;
	  }
d2990 2
a2991 1
	d_print_comp (dpi, d_right (dc));
d2993 3
a2995 2
	if (typed_name->type == D_COMP_TEMPLATE)
	  dpi->templates = dpt.next;
d2997 1
a2997 11
	/* If the modifiers didn't get printed by the type, print them
	   now.  */
	while (i > 0)
	  {
	    --i;
	    if (! adpm[i].printed)
	      {
		d_append_char (dpi, ' ');
		d_print_mod (dpi, adpm[i].mod);
	      }
	  }
d2999 2
a3000 1
	dpi->modifiers = hold_modifiers;
d3002 5
a3006 2
	return;
      }
d3008 4
a3011 3
    case D_COMP_TEMPLATE:
      {
	struct d_print_mod *hold_dpm;
d3013 4
a3016 17
	/* Don't push modifiers into a template definition.  Doing so
	   could give the wrong definition for a template argument.
	   Instead, treat the template essentially as a name.  */

	hold_dpm = dpi->modifiers;
	dpi->modifiers = NULL;

	d_print_comp (dpi, d_left (dc));
	if (d_last_char (dpi) == '<')
	  d_append_char (dpi, ' ');
	d_append_char (dpi, '<');
	d_print_comp (dpi, d_right (dc));
	/* Avoid generating two consecutive '>' characters, to avoid
	   the C++ syntactic ambiguity.  */
	if (d_last_char (dpi) == '>')
	  d_append_char (dpi, ' ');
	d_append_char (dpi, '>');
d3018 2
a3019 1
	dpi->modifiers = hold_dpm;
d3021 6
a3026 2
	return;
      }
d3028 2
a3029 5
    case D_COMP_TEMPLATE_PARAM:
      {
	long i;
	struct d_comp *a;
	struct d_print_template *hold_dpt;
d3031 3
a3033 24
	if (dpi->templates == NULL)
	  {
	    d_print_error (dpi);
	    return;
	  }
	i = dc->u.s_number.number;
	for (a = d_right (dpi->templates->template);
	     a != NULL;
	     a = d_right (a))
	  {
	    if (a->type != D_COMP_TEMPLATE_ARGLIST)
	      {
		d_print_error (dpi);
		return;
	      }
	    if (i <= 0)
	      break;
	    --i;
	  }
	if (i != 0 || a == NULL)
	  {
	    d_print_error (dpi);
	    return;
	  }
d3035 4
a3038 4
	/* While processing this parameter, we need to pop the list of
	   templates.  This is because the template parameter may
	   itself be a reference to a parameter of an outer
	   template.  */
d3040 2
a3041 2
	hold_dpt = dpi->templates;
	dpi->templates = hold_dpt->next;
d3043 4
a3046 1
	d_print_comp (dpi, d_left (a));
d3048 1
a3048 1
	dpi->templates = hold_dpt;
d3050 1
a3050 2
	return;
      }
d3052 7
a3058 89
    case D_COMP_CTOR:
      d_print_comp (dpi, dc->u.s_ctor.name);
      return;

    case D_COMP_DTOR:
      d_append_char (dpi, '~');
      d_print_comp (dpi, dc->u.s_dtor.name);
      return;

    case D_COMP_VTABLE:
      d_append_string (dpi, "vtable for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_VTT:
      d_append_string (dpi, "VTT for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_CONSTRUCTION_VTABLE:
      d_append_string (dpi, "construction vtable for ");
      d_print_comp (dpi, d_left (dc));
      d_append_string (dpi, "-in-");
      d_print_comp (dpi, d_right (dc));
      return;

    case D_COMP_TYPEINFO:
      d_append_string (dpi, "typeinfo for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_TYPEINFO_NAME:
      d_append_string (dpi, "typeinfo name for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_TYPEINFO_FN:
      d_append_string (dpi, "typeinfo fn for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_THUNK:
      d_append_string (dpi, "non-virtual thunk to ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_VIRTUAL_THUNK:
      d_append_string (dpi, "virtual thunk to ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_COVARIANT_THUNK:
      d_append_string (dpi, "covariant return thunk to ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_JAVA_CLASS:
      d_append_string (dpi, "java Class for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_GUARD:
      d_append_string (dpi, "guard variable for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_REFTEMP:
      d_append_string (dpi, "reference temporary for ");
      d_print_comp (dpi, d_left (dc));
      return;

    case D_COMP_SUB_STD:
      d_append_string (dpi, dc->u.s_string.string);
      return;

    case D_COMP_RESTRICT:
    case D_COMP_VOLATILE:
    case D_COMP_CONST:
    case D_COMP_RESTRICT_THIS:
    case D_COMP_VOLATILE_THIS:
    case D_COMP_CONST_THIS:
    case D_COMP_VENDOR_TYPE_QUAL:
    case D_COMP_POINTER:
    case D_COMP_REFERENCE:
    case D_COMP_COMPLEX:
    case D_COMP_IMAGINARY:
      {
	/* We keep a list of modifiers on the stack.  */
	struct d_print_mod dpm;
d3060 1
a3060 5
	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;
d3062 7
a3068 1
	d_print_comp (dpi, d_left (dc));
d3070 9
a3078 4
	/* If the modifier didn't get printed by the type, print it
	   now.  */
	if (! dpm.printed)
	  d_print_mod (dpi, dc);
d3080 8
a3087 1
	dpi->modifiers = dpm.next;
d3089 18
a3106 2
	return;
      }
d3108 2
a3109 6
    case D_COMP_BUILTIN_TYPE:
      if ((dpi->options & DMGL_JAVA) == 0)
	d_append_string (dpi, dc->u.s_builtin.type->name);
      else
	d_append_string (dpi, dc->u.s_builtin.type->java_name);
      return;
d3111 9
a3119 3
    case D_COMP_VENDOR_TYPE:
      d_print_comp (dpi, d_left (dc));
      return;
d3121 6
a3126 5
    case D_COMP_FUNCTION_TYPE:
      {
	if (d_left (dc) != NULL)
	  {
	    struct d_print_mod dpm;
d3128 3
a3130 2
	    /* We must pass this type down as a modifier in order to
	       print it in the right location.  */
d3132 3
a3134 5
	    dpm.next = dpi->modifiers;
	    dpi->modifiers = &dpm;
	    dpm.mod = dc;
	    dpm.printed = 0;
	    dpm.templates = dpi->templates;
d3136 5
a3140 1
	    d_print_comp (dpi, d_left (dc));
d3142 2
a3143 1
	    dpi->modifiers = dpm.next;
d3145 1
a3145 2
	    if (dpm.printed)
	      return;
d3147 4
a3150 2
	    d_append_char (dpi, ' ');
	  }
d3152 5
a3156 1
	d_print_function_type (dpi, dc, dpi->modifiers);
d3158 4
a3161 53
	return;
      }

    case D_COMP_ARRAY_TYPE:
      {
	struct d_print_mod dpm;

	/* We must pass this type down as a modifier in order to print
	   multi-dimensional arrays correctly.  */

	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;

	d_print_comp (dpi, d_right (dc));

	dpi->modifiers = dpm.next;

	if (dpm.printed)
	  return;

	d_print_array_type (dpi, dc, dpi->modifiers);

	return;
      }

    case D_COMP_PTRMEM_TYPE:
      {
	struct d_print_mod dpm;

	dpm.next = dpi->modifiers;
	dpi->modifiers = &dpm;
	dpm.mod = dc;
	dpm.printed = 0;
	dpm.templates = dpi->templates;

	d_print_comp (dpi, d_right (dc));

	/* If the modifier didn't get printed by the type, print it
	   now.  */
	if (! dpm.printed)
	  {
	    d_append_char (dpi, ' ');
	    d_print_comp (dpi, d_left (dc));
	    d_append_string (dpi, "::*");
	  }

	dpi->modifiers = dpm.next;

	return;
      }
d3163 1
a3163 4
    case D_COMP_ARGLIST:
    case D_COMP_TEMPLATE_ARGLIST:
      d_print_comp (dpi, d_left (dc));
      if (d_right (dc) != NULL)
d3165 4
a3168 2
	  d_append_string (dpi, ", ");
	  d_print_comp (dpi, d_right (dc));
a3169 27
      return;

    case D_COMP_OPERATOR:
      {
	char c;

	d_append_string (dpi, "operator");
	c = dc->u.s_operator.op->name[0];
	if (IS_LOWER (c))
	  d_append_char (dpi, ' ');
	d_append_string (dpi, dc->u.s_operator.op->name);
	return;
      }

    case D_COMP_EXTENDED_OPERATOR:
      d_append_string (dpi, "operator ");
      d_print_comp (dpi, dc->u.s_extended_operator.name);
      return;

    case D_COMP_CAST:
      d_append_string (dpi, "operator ");
      d_print_cast (dpi, dc);
      return;

    case D_COMP_UNARY:
      if (d_left (dc)->type != D_COMP_CAST)
	d_print_expr_op (dpi, d_left (dc));
d3171 3
a3173 85
	{
	  d_append_string (dpi, "((");
	  d_print_cast (dpi, d_left (dc));
	  d_append_char (dpi, ')');
	}
      d_append_char (dpi, '(');
      d_print_comp (dpi, d_right (dc));
      d_append_char (dpi, ')');
      if (d_left (dc)->type == D_COMP_CAST)
	d_append_char (dpi, ')');
      return;

    case D_COMP_BINARY:
      if (d_right (dc)->type != D_COMP_BINARY_ARGS)
	{
	  d_print_error (dpi);
	  return;
	}

      /* We wrap an expression which uses the greater-than operator in
	 an extra layer of parens so that it does not get confused
	 with the '>' which ends the template parameters.  */
      if (d_left (dc)->type == D_COMP_OPERATOR
	  && strcmp (d_left (dc)->u.s_operator.op->name, ">") == 0)
	d_append_char (dpi, '(');

      d_append_char (dpi, '(');
      d_print_comp (dpi, d_left (d_right (dc)));
      d_append_string (dpi, ") ");
      d_print_expr_op (dpi, d_left (dc));
      d_append_string (dpi, " (");
      d_print_comp (dpi, d_right (d_right (dc)));
      d_append_char (dpi, ')');

      if (d_left (dc)->type == D_COMP_OPERATOR
	  && strcmp (d_left (dc)->u.s_operator.op->name, ">") == 0)
	d_append_char (dpi, ')');

      return;

    case D_COMP_BINARY_ARGS:
      /* We should only see this as part of D_COMP_BINARY.  */
      d_print_error (dpi);
      return;

    case D_COMP_TRINARY:
      if (d_right (dc)->type != D_COMP_TRINARY_ARG1
	  || d_right (d_right (dc))->type != D_COMP_TRINARY_ARG2)
	{
	  d_print_error (dpi);
	  return;
	}
      d_append_char (dpi, '(');
      d_print_comp (dpi, d_left (d_right (dc)));
      d_append_string (dpi, ") ");
      d_print_expr_op (dpi, d_left (dc));
      d_append_string (dpi, " (");
      d_print_comp (dpi, d_left (d_right (d_right (dc))));
      d_append_string (dpi, ") : (");
      d_print_comp (dpi, d_right (d_right (d_right (dc))));
      d_append_char (dpi, ')');
      return;

    case D_COMP_TRINARY_ARG1:
    case D_COMP_TRINARY_ARG2:
      /* We should only see these are part of D_COMP_TRINARY.  */
      d_print_error (dpi);
      return;

    case D_COMP_LITERAL:
    case D_COMP_LITERAL_NEG:
      /* For some builtin types, produce simpler output.  */
      if (d_left (dc)->type == D_COMP_BUILTIN_TYPE)
	{
	  switch (d_left (dc)->u.s_builtin.type->print)
	    {
	    case D_PRINT_INT:
	      if (d_right (dc)->type == D_COMP_NAME)
		{
		  if (dc->type == D_COMP_LITERAL_NEG)
		    d_append_char (dpi, '-');
		  d_print_comp (dpi, d_right (dc));
		  return;
		}
	      break;
d3175 6
a3180 42
	    case D_PRINT_LONG:
	      if (d_right (dc)->type == D_COMP_NAME)
		{
		  if (dc->type == D_COMP_LITERAL_NEG)
		    d_append_char (dpi, '-');
		  d_print_comp (dpi, d_right (dc));
		  d_append_char (dpi, 'l');
		  return;
		}
	      break;

	    case D_PRINT_BOOL:
	      if (d_right (dc)->type == D_COMP_NAME
		  && d_right (dc)->u.s_name.len == 1
		  && dc->type == D_COMP_LITERAL)
		{
		  switch (d_right (dc)->u.s_name.s[0])
		    {
		    case '0':
		      d_append_string (dpi, "false");
		      return;
		    case '1':
		      d_append_string (dpi, "true");
		      return;
		    default:
		      break;
		    }
		}
	      break;

	    default:
	      break;
	    }
	}

      d_append_char (dpi, '(');
      d_print_comp (dpi, d_left (dc));
      d_append_char (dpi, ')');
      if (dc->type == D_COMP_LITERAL_NEG)
	d_append_char (dpi, '-');
      d_print_comp (dpi, d_right (dc));
      return;
d3183 2
a3184 2
      d_print_error (dpi);
      return;
a3185 57
}

/* Print an identifier.  */

static void
d_print_identifier (dpi, name, len)
     struct d_print_info *dpi;
     const char *name;
     int len;
{
  if ((dpi->options & DMGL_JAVA) == 0)
    d_append_buffer (dpi, name, len);
  else
    {
      const char *p;
      const char *end;

      /* For Java we try to handle encoded extended Unicode
	 characters.  The C++ ABI doesn't mention Unicode encoding, so
	 we don't it for C++.  Characters are encoded as
	 __U<hex-char>+_.  */
      end = name + len;
      for (p = name; p < end; ++p)
	{
	  if (end - p > 3
	      && p[0] == '_'
	      && p[1] == '_'
	      && p[2] == 'U')
	    {
	      unsigned long c;
	      const char *q;

	      c = 0;
	      for (q = p + 3; q < end; ++q)
		{
		  int dig;

		  if (IS_DIGIT (*q))
		    dig = *q - '0';
		  else if (*q >= 'A' && *q <= 'F')
		    dig = *q - 'A' + 10;
		  else if (*q >= 'a' && *q <= 'f')
		    dig = *q - 'a' + 10;
		  else
		    break;

		  c = c * 16 + dig;
		}
	      /* If the Unicode character is larger than 256, we don't
		 try to deal with it here.  FIXME.  */
	      if (q < end && *q == '_' && c < 256)
		{
		  d_append_char (dpi, c);
		  p = q;
		  continue;
		}
	    }
d3187 1
a3187 3
	  d_append_char (dpi, *p);
	}
    }
d3190 6
a3195 2
/* Print a list of modifiers.  SUFFIX is 1 if we are printing
   qualifiers on this after printing a function.  */
d3197 3
a3199 5
static void
d_print_mod_list (dpi, mods, suffix)
     struct d_print_info *dpi;
     struct d_print_mod *mods;
     int suffix;
d3201 1
a3201 1
  struct d_print_template *hold_dpt;
d3203 1
a3203 2
  if (mods == NULL || d_print_saw_error (dpi))
    return;
d3205 6
a3210 5
  if (mods->printed
      || (! suffix
	  && (mods->mod->type == D_COMP_RESTRICT_THIS
	      || mods->mod->type == D_COMP_VOLATILE_THIS
	      || mods->mod->type == D_COMP_CONST_THIS)))
d3212 12
a3223 3
      d_print_mod_list (dpi, mods->next, suffix);
      return;
    }
d3225 9
a3233 1
  mods->printed = 1;
d3235 13
a3247 2
  hold_dpt = dpi->templates;
  dpi->templates = mods->templates;
d3249 7
a3255 11
  if (mods->mod->type == D_COMP_FUNCTION_TYPE)
    {
      d_print_function_type (dpi, mods->mod, mods->next);
      dpi->templates = hold_dpt;
      return;
    }
  else if (mods->mod->type == D_COMP_ARRAY_TYPE)
    {
      d_print_array_type (dpi, mods->mod, mods->next);
      dpi->templates = hold_dpt;
      return;
d3258 2
a3259 1
  d_print_mod (dpi, mods->mod);
d3261 1
a3261 1
  dpi->templates = hold_dpt;
d3263 2
a3264 2
  d_print_mod_list (dpi, mods->next, suffix);
}
d3266 10
a3275 54
/* Print a modifier.  */

static void
d_print_mod (dpi, mod)
     struct d_print_info *dpi;
     const struct d_comp *mod;
{
  switch (mod->type)
    {
    case D_COMP_RESTRICT:
    case D_COMP_RESTRICT_THIS:
      d_append_string (dpi, " restrict");
      return;
    case D_COMP_VOLATILE:
    case D_COMP_VOLATILE_THIS:
      d_append_string (dpi, " volatile");
      return;
    case D_COMP_CONST:
    case D_COMP_CONST_THIS:
      d_append_string (dpi, " const");
      return;
    case D_COMP_VENDOR_TYPE_QUAL:
      d_append_char (dpi, ' ');
      d_print_comp (dpi, d_right (mod));
      return;
    case D_COMP_POINTER:
      /* There is no pointer symbol in Java.  */
      if ((dpi->options & DMGL_JAVA) == 0)
	d_append_char (dpi, '*');
      return;
    case D_COMP_REFERENCE:
      d_append_char (dpi, '&');
      return;
    case D_COMP_COMPLEX:
      d_append_string (dpi, "complex ");
      return;
    case D_COMP_IMAGINARY:
      d_append_string (dpi, "imaginary ");
      return;
    case D_COMP_PTRMEM_TYPE:
      if (d_last_char (dpi) != '(')
	d_append_char (dpi, ' ');
      d_print_comp (dpi, d_left (mod));
      d_append_string (dpi, "::*");
      return;
    case D_COMP_TYPED_NAME:
      d_print_comp (dpi, d_left (mod));
      return;
    default:
      /* Otherwise, we have something that won't go back on the
	 modifier stack, so we can just print it.  */
      d_print_comp (dpi, mod);
      return;
    }
d3278 1
a3278 1
/* Print a function type, except for the return type.  */
d3280 3
a3282 16
static void
d_print_function_type (dpi, dc, mods)
     struct d_print_info *dpi;
     const struct d_comp *dc;
     struct d_print_mod *mods;
{
  int need_paren;
  int saw_mod;
  struct d_print_mod *p;

  need_paren = 0;
  saw_mod = 0;
  for (p = mods; p != NULL; p = p->next)
    {
      if (p->printed)
	break;
d3284 5
a3288 24
      saw_mod = 1;
      switch (p->mod->type)
	{
	case D_COMP_RESTRICT:
	case D_COMP_VOLATILE:
	case D_COMP_CONST:
	case D_COMP_VENDOR_TYPE_QUAL:
	case D_COMP_POINTER:
	case D_COMP_REFERENCE:
	case D_COMP_COMPLEX:
	case D_COMP_IMAGINARY:
	case D_COMP_PTRMEM_TYPE:
	  need_paren = 1;
	  break;
	case D_COMP_RESTRICT_THIS:
	case D_COMP_VOLATILE_THIS:
	case D_COMP_CONST_THIS:
	  break;
	default:
	  break;
	}
      if (need_paren)
	break;
    }
d3290 1
a3290 2
  if (d_left (dc) != NULL && ! saw_mod)
    need_paren = 1;
d3292 3
a3294 1
  if (need_paren)
d3296 3
a3298 6
      switch (d_last_char (dpi))
	{
	case ' ':
	case '(':
	case '*':
	  break;
d3300 4
a3303 4
	default:
	  d_append_char (dpi, ' ');
	  break;
	}
d3305 1
a3305 1
      d_append_char (dpi, '(');
d3307 2
d3310 2
a3311 1
  d_print_mod_list (dpi, mods, 0);
d3313 2
a3314 2
  if (need_paren)
    d_append_char (dpi, ')');
d3316 16
a3331 1
  d_append_char (dpi, '(');
d3333 27
a3359 2
  if (d_right (dc) != NULL)
    d_print_comp (dpi, d_right (dc));
d3361 5
a3365 1
  d_append_char (dpi, ')');
d3367 5
a3371 2
  d_print_mod_list (dpi, mods, 1);
}
d3373 19
a3391 1
/* Print an array type, except for the element type.  */
d3393 13
a3405 7
static void
d_print_array_type (dpi, dc, mods)
     struct d_print_info *dpi;
     const struct d_comp *dc;
     struct d_print_mod *mods;
{
  int need_space;
d3407 13
a3419 11
  need_space = 1;
  if (mods != NULL)
    {
      int need_paren;
      struct d_print_mod *p;

      need_paren = 0;
      for (p = mods; p != NULL; p = p->next)
	{
	  if (p->printed)
	    break;
d3421 2
a3422 1
	  if (p->mod->type == D_COMP_ARRAY_TYPE)
d3424 2
a3425 2
	      need_space = 0;
	      break;
d3429 2
a3430 3
	      need_paren = 1;
	      need_space = 1;
	      break;
d3432 5
d3438 3
d3442 6
a3447 2
      if (need_paren)
	d_append_string (dpi, " (");
d3449 1
a3449 4
      d_print_mod_list (dpi, mods, 0);

      if (need_paren)
	d_append_char (dpi, ')');
d3452 6
a3457 2
  if (need_space)
    d_append_char (dpi, ' ');
d3459 2
a3460 1
  d_append_char (dpi, '[');
d3462 3
a3464 2
  if (d_left (dc) != NULL)
    d_print_comp (dpi, d_left (dc));
d3466 1
a3466 2
  d_append_char (dpi, ']');
}
d3468 2
a3469 1
/* Print an operator in an expression.  */
d3471 3
a3473 4
static void
d_print_expr_op (dpi, dc)
     struct d_print_info *dpi;
     const struct d_comp *dc;
d3475 1
a3475 5
  if (dc->type == D_COMP_OPERATOR)
    d_append_string (dpi, dc->u.s_operator.op->name);
  else
    d_print_comp (dpi, dc);
}
d3477 4
a3480 1
/* Print a cast.  */
d3482 8
a3489 7
static void
d_print_cast (dpi, dc)
     struct d_print_info *dpi;
     const struct d_comp *dc;
{
  if (d_left (dc)->type != D_COMP_TEMPLATE)
    d_print_comp (dpi, d_left (dc));
d3492 48
a3539 30
      struct d_print_mod *hold_dpm;
      struct d_print_template dpt;

      /* It appears that for a templated cast operator, we need to put
	 the template parameters in scope for the operator name, but
	 not for the parameters.  The effect is that we need to handle
	 the template printing here.  */

      hold_dpm = dpi->modifiers;
      dpi->modifiers = NULL;

      dpt.next = dpi->templates;
      dpi->templates = &dpt;
      dpt.template = d_left (dc);

      d_print_comp (dpi, d_left (d_left (dc)));

      dpi->templates = dpt.next;

      if (d_last_char (dpi) == '<')
	d_append_char (dpi, ' ');
      d_append_char (dpi, '<');
      d_print_comp (dpi, d_right (d_left (dc)));
      /* Avoid generating two consecutive '>' characters, to avoid
	 the C++ syntactic ambiguity.  */
      if (d_last_char (dpi) == '>')
	d_append_char (dpi, ' ');
      d_append_char (dpi, '>');

      dpi->modifiers = hold_dpm;
d3541 1
a3541 35
}

/* Initialize the information structure we use to pass around
   information.  */

static int
d_init_info (mangled, options, len, di)
     const char *mangled;
     int options;
     size_t len;
     struct d_info *di;
{
  di->s = mangled;
  di->options = options;

  di->n = mangled;

  /* We can not need more components than twice the number of chars in
     the mangled string.  Most components correspond directly to
     chars, but the ARGLIST types are exceptions.  */
  di->num_comps = 2 * len;
  di->comps = (struct d_comp *) malloc (di->num_comps
					* sizeof (struct d_comp));
  di->next_comp = 0;

  /* Similarly, we can not need more substitutions than there are
     chars in the mangled string.  */
  di->num_subs = len;
  di->subs = (struct d_comp **) malloc (di->num_subs
					* sizeof (struct d_comp *));
  di->next_sub = 0;

  di->last_name = NULL;

  if (di->comps == NULL || di->subs == NULL)
d3543 2
a3544 5
      if (di->comps != NULL)
	free (di->comps);
      if (di->subs != NULL)
	free (di->subs);
      return 0;
d3547 1
a3547 1
  return 1;
d3550 3
a3552 6
/* Entry point for the demangler.  If MANGLED is a g++ v3 ABI mangled
   name, return a buffer allocated with malloc holding the demangled
   name.  OPTIONS is the usual libiberty demangler options.  On
   success, this sets *PALC to the allocated size of the returned
   buffer.  On failure, this sets *PALC to 0 for a bad name, or 1 for
   a memory allocation failure.  On failure, this returns NULL.  */
d3554 5
a3558 5
static char *
d_demangle (mangled, options, palc)
     const char* mangled;
     int options;
     size_t *palc;
d3560 2
a3561 5
  size_t len;
  int type;
  struct d_info di;
  struct d_comp *dc;
  char *ret;
d3563 5
a3567 1
  *palc = 0;
d3569 6
a3574 1
  len = strlen (mangled);
d3576 2
a3577 13
  if (mangled[0] == '_' && mangled[1] == 'Z')
    type = 0;
  else if (strncmp (mangled, "_GLOBAL_", 8) == 0
	   && (mangled[8] == '.' || mangled[8] == '_' || mangled[8] == '$')
	   && (mangled[9] == 'D' || mangled[9] == 'I')
	   && mangled[10] == '_')
    {
      char *r;

      r = malloc (40 + len - 11);
      if (r == NULL)
	*palc = 1;
      else
d3579 4
a3582 5
	  if (mangled[9] == 'I')
	    strcpy (r, "global constructors keyed to ");
	  else
	    strcpy (r, "global destructors keyed to ");
	  strcat (r, mangled + 11);
d3584 2
a3585 1
      return r;
d3589 6
a3594 3
      if ((options & DMGL_TYPES) == 0)
	return NULL;
      type = 1;
d3597 2
a3598 5
  if (! d_init_info (mangled, options, len, &di))
    {
      *palc = 1;
      return NULL;
    }
d3600 3
a3602 4
  if (! type)
    dc = d_mangled_name (&di, 1);
  else
    dc = d_type (&di);
d3604 10
a3613 6
  /* If DMGL_PARAMS is set, then if we didn't consume the entire
     mangled string, then we didn't successfully demangle it.  If
     DMGL_PARAMS is not set, we didn't look at the trailing
     parameters.  */
  if (((options & DMGL_PARAMS) != 0) && d_peek_char (&di) != '\0')
    dc = NULL;
d3615 7
a3621 6
#ifdef CP_DEMANGLE_DEBUG
  if (dc == NULL)
    printf ("failed demangling\n");
  else
    d_dump (dc, 0);
#endif
d3623 1
a3623 2
  free (di.subs);
  di.subs = NULL;
d3625 9
a3633 3
  ret = NULL;
  if (dc != NULL)
    ret = d_print (options, dc, palc);
d3635 2
a3636 1
  free (di.comps);
d3638 1
a3638 1
  return ret;
a3641 1

d3644 3
a3646 3
/* ia64 ABI-mandated entry point in the C++ runtime library for
   performing demangling.  MANGLED_NAME is a NUL-terminated character
   string containing the name to be demangled.
d3652 1
a3652 1
   is placed in a region of memory allocated with malloc.
d3655 1
a3655 1
   demangled name, is placed in *LENGTH.
d3659 1
a3659 1
   responsible for deallocating this memory using free.
d3663 1
a3663 1
     -1: A memory allocation failure occurred.
d3667 1
a3667 1
   The demangling is performed using the C++ ABI mangling rules, with
d3677 2
a3678 2
  char *demangled;
  size_t alc;
d3683 17
a3699 2
  if (mangled_name == NULL)
    {
d3703 13
d3717 2
a3718 1
  if (output_buffer != NULL && length == NULL)
d3720 12
a3731 7
      *status = -3;
      return NULL;
    }

  demangled = d_demangle (mangled_name, DMGL_TYPES, &alc);

  if (demangled == NULL)
d3733 1
a3733 4
      if (alc == 1)
	*status = -1;
      else
	*status = -2;
a3735 6

  if (output_buffer == NULL)
    {
      if (length != NULL)
	*length = alc;
    }
d3737 2
d3740 6
a3745 11
      if (strlen (demangled) < *length)
	{
	  strcpy (output_buffer, demangled);
	  free (demangled);
	  demangled = output_buffer;
	}
      else
	{
	  free (output_buffer);
	  *length = alc;
	}
a3746 4

  *status = 0;

  return demangled;
d3751 5
a3755 3
/* Entry point for libiberty demangler.  If MANGLED is a g++ v3 ABI
   mangled name, return a buffer allocated with malloc holding the
   demangled name.  Otherwise, return NULL.  */
d3762 15
a3776 1
  size_t alc;
d3778 30
a3807 1
  return d_demangle (mangled, options, &alc);
d3821 28
a3848 15
  size_t alc;
  char *demangled;
  int nesting;
  char *from;
  char *to;

  demangled = d_demangle (mangled, DMGL_JAVA | DMGL_PARAMS, &alc);

  if (demangled == NULL)
    return NULL;

  nesting = 0;
  from = demangled;
  to = from;
  while (*from != '\0')
d3850 19
a3868 3
      if (strncmp (from, "JArray<", 7) == 0)
	{
	  from += 7;
d3870 11
d3882 2
a3883 6
      else if (nesting > 0 && *from == '>')
	{
	  while (to > demangled && to[-1] == ' ')
	    --to;
	  *to++ = '[';
	  *to++ = ']';
d3885 10
a3894 1
	  ++from;
d3897 9
a3905 1
	*to++ = *from++;
d3908 6
a3913 1
  *to = '\0';
d3915 1
a3915 1
  return demangled;
d3920 1
d3922 9
d3932 1
a3932 18
/* Demangle a string in order to find out whether it is a constructor
   or destructor.  Return non-zero on success.  Set *CTOR_KIND and
   *DTOR_KIND appropriately.  */

static int
is_ctor_or_dtor (mangled, ctor_kind, dtor_kind)
     const char *mangled;
     enum gnu_v3_ctor_kinds *ctor_kind;
     enum gnu_v3_dtor_kinds *dtor_kind;
{
  struct d_info di;
  struct d_comp *dc;
  int ret;

  *ctor_kind = (enum gnu_v3_ctor_kinds) 0;
  *dtor_kind = (enum gnu_v3_dtor_kinds) 0;

  if (! d_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di))
d3935 6
a3940 4
  dc = d_mangled_name (&di, 1);

  /* Note that because we did not pass DMGL_PARAMS, we don't expect to
     demangle the entire string.  */
d3942 2
a3943 2
  ret = 0;
  while (dc != NULL)
d3945 3
a3947 26
      switch (dc->type)
	{
	default:
	  dc = NULL;
	  break;
	case D_COMP_TYPED_NAME:
	case D_COMP_TEMPLATE:
	case D_COMP_RESTRICT_THIS:
	case D_COMP_VOLATILE_THIS:
	case D_COMP_CONST_THIS:
	  dc = d_left (dc);
	  break;
	case D_COMP_QUAL_NAME:
	  dc = d_right (dc);
	  break;
	case D_COMP_CTOR:
	  *ctor_kind = dc->u.s_ctor.kind;
	  ret = 1;
	  dc = NULL;
	  break;
	case D_COMP_DTOR:
	  *dtor_kind = dc->u.s_dtor.kind;
	  ret = 1;
	  dc = NULL;
	  break;
	}
d3950 3
a3952 2
  free (di.subs);
  free (di.comps);
d3954 2
a3955 1
  return ret;
a3957 2
/* Return whether NAME is the mangled form of a g++ V3 ABI constructor
   name.  A non-zero return indicates the type of constructor.  */
d3959 5
d3968 1
a3968 2
  enum gnu_v3_ctor_kinds ctor_kind;
  enum gnu_v3_dtor_kinds dtor_kind;
d3970 7
a3976 1
  if (! is_ctor_or_dtor (name, &ctor_kind, &dtor_kind))
a3977 1
  return ctor_kind;
d3981 5
a3985 3
/* Return whether NAME is the mangled form of a g++ V3 ABI destructor
   name.  A non-zero return indicates the type of destructor.  */

d3990 1
a3990 2
  enum gnu_v3_ctor_kinds ctor_kind;
  enum gnu_v3_dtor_kinds dtor_kind;
d3992 7
a3998 1
  if (! is_ctor_or_dtor (name, &ctor_kind, &dtor_kind))
a3999 1
  return dtor_kind;
d4001 1
a4002 1
#endif /* IN_GLIBCPP_V3 */
a4006 1
#include "dyn-string.h"
d4008 2
a4009 5
static void print_usage PARAMS ((FILE* fp, int exit_value));

#define IS_ALPHA(CHAR)                                                  \
  (((CHAR) >= 'a' && (CHAR) <= 'z')                                     \
   || ((CHAR) >= 'A' && (CHAR) <= 'Z'))
d4029 1
a4029 1
  fprintf (fp, "  -p,--no-params  Don't display function parameters\n");
d4039 4
a4042 4
  { "help",	 no_argument, NULL, 'h' },
  { "no-params", no_argument, NULL, 'p' },
  { "verbose",   no_argument, NULL, 'v' },
  { NULL,        no_argument, NULL, 0   },
d4055 1
a4057 1
  int options = DMGL_PARAMS | DMGL_ANSI | DMGL_TYPES;
d4065 1
a4065 1
      opt_char = getopt_long (argc, argv, "hpv", long_options, NULL);
d4076 2
a4077 2
	case 'p':
	  options &= ~ DMGL_PARAMS;
d4081 1
a4081 1
	  options |= DMGL_VERBOSE;
d4091 2
a4092 1
      char *s;
d4097 29
a4125 1
	  char c;
d4138 9
a4146 1
	  if (dyn_string_length (mangled) > 0)
d4148 2
a4149 15
	      s = cplus_demangle_v3 (dyn_string_buf (mangled), options);

	      if (s != NULL)
		{
		  fputs (s, stdout);
		  free (s);
		}
	      else
		{
		  /* It might not have been a mangled name.  Print the
		     original text.  */
		  fputs (dyn_string_buf (mangled), stdout);
		}

	      dyn_string_clear (mangled);
d4151 4
d4160 4
d4167 1
d4172 2
a4176 2
	  char *s;

d4178 1
a4178 1
	  s = cplus_demangle_v3 (argv[i], options);
d4181 4
a4184 1
	  if (s != NULL)
d4186 2
a4187 2
	      printf ("%s\n", s);
	      free (s);
d4189 3
a4191 2
	  else
	    fprintf (stderr, "Failed: %s\n", argv[i]);
d4193 1
@


1.27.2.4
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 1
a2 1
   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
a47 16
   Also, the interface to the component list is public, and defined in
   demangle.h.  The interface consists of these types, which are
   defined in demangle.h:
      enum demangle_component_type
      struct demangle_component
   and these functions defined in this file:
      cplus_demangle_fill_name
      cplus_demangle_fill_extended_operator
      cplus_demangle_fill_ctor
      cplus_demangle_fill_dtor
      cplus_demangle_print
   and other functions defined in the file cp-demint.c.

   This file also defines some other functions and variables which are
   only to be used by the file cp-demint.c.

d57 1
a57 2
      If defined, this file defines only __cxa_demangle(), and no other
      publically visible functions or variables.
a83 62
#include "cp-demangle.h"

/* If IN_GLIBCPP_V3 is defined, some functions are made static.  We
   also rename them via #define to avoid compiler errors when the
   static definition conflicts with the extern declaration in a header
   file.  */
#ifdef IN_GLIBCPP_V3

#define CP_STATIC_IF_GLIBCPP_V3 static

#define cplus_demangle_fill_name d_fill_name
static int
d_fill_name PARAMS ((struct demangle_component *, const char *, int));

#define cplus_demangle_fill_extended_operator d_fill_extended_operator
static int
d_fill_extended_operator PARAMS ((struct demangle_component *, int,
				  struct demangle_component *));

#define cplus_demangle_fill_ctor d_fill_ctor
static int
d_fill_ctor PARAMS ((struct demangle_component *, enum gnu_v3_ctor_kinds,
		     struct demangle_component *));

#define cplus_demangle_fill_dtor d_fill_dtor
static int
d_fill_dtor PARAMS ((struct demangle_component *, enum gnu_v3_dtor_kinds,
		     struct demangle_component *));

#define cplus_demangle_mangled_name d_mangled_name
static struct demangle_component *
d_mangled_name PARAMS ((struct d_info *, int));

#define cplus_demangle_type d_type
static struct demangle_component *
d_type PARAMS ((struct d_info *));

#define cplus_demangle_print d_print
static char *
d_print PARAMS ((int, const struct demangle_component *, int, size_t *));

#define cplus_demangle_init_info d_init_info
static void
d_init_info PARAMS ((const char *, int, size_t, struct d_info *));

#else /* ! defined(IN_GLIBCPP_V3) */
#define CP_STATIC_IF_GLIBCPP_V3
#endif /* ! defined(IN_GLIBCPP_V3) */

/* See if the compiler supports dynamic arrays.  */

#ifdef __GNUC__
#define CP_DYNAMIC_ARRAYS
#else
#ifdef __STDC__
#ifdef __STDC_VERSION__
#if __STDC_VERSION__ >= 199901L
#define CP_DYNAMIC_ARRAYS
#endif /* __STDC__VERSION >= 199901L */
#endif /* defined (__STDC_VERSION__) */
#endif /* defined (__STDC__) */
#endif /* ! defined (__GNUC__) */
d104 40
a151 2
  /* The length of the simple expansion.  */
  int simple_len;
a154 2
  /* The length of the full expansion.  */
  int full_len;
a158 2
  /* The length of set_last_name.  */
  int set_last_name_len;
d161 177
a337 1
/* Accessors for subtrees of struct demangle_component.  */
d342 32
d381 1
a381 1
  const struct demangle_component *template;
d392 1
a392 1
  const struct demangle_component *mod;
d445 7
a451 2
#define d_append_string_constant(dpi, s) \
  d_append_buffer (dpi, (s), sizeof (s) - 1)
d457 1
a457 2
static void 
d_dump PARAMS ((struct demangle_component *, int));
d459 79
a537 171

static struct demangle_component *
d_make_empty PARAMS ((struct d_info *));

static struct demangle_component *
d_make_comp PARAMS ((struct d_info *, enum demangle_component_type,
		     struct demangle_component *,
		     struct demangle_component *));

static struct demangle_component *
d_make_name PARAMS ((struct d_info *, const char *, int));

static struct demangle_component *
d_make_builtin_type PARAMS ((struct d_info *,
			     const struct demangle_builtin_type_info *));

static struct demangle_component *
d_make_operator PARAMS ((struct d_info *,
			 const struct demangle_operator_info *));

static struct demangle_component *
d_make_extended_operator PARAMS ((struct d_info *, int,
				  struct demangle_component *));

static struct demangle_component *
d_make_ctor PARAMS ((struct d_info *, enum gnu_v3_ctor_kinds,
		     struct demangle_component *));

static struct demangle_component *
d_make_dtor PARAMS ((struct d_info *, enum gnu_v3_dtor_kinds,
		     struct demangle_component *));

static struct demangle_component *
d_make_template_param PARAMS ((struct d_info *, long));

static struct demangle_component *
d_make_sub PARAMS ((struct d_info *, const char *, int));

static int
has_return_type PARAMS ((struct demangle_component *));

static int
is_ctor_dtor_or_conversion PARAMS ((struct demangle_component *));

static struct demangle_component *
d_encoding PARAMS ((struct d_info *, int));

static struct demangle_component *
d_name PARAMS ((struct d_info *));

static struct demangle_component *
d_nested_name PARAMS ((struct d_info *));

static struct demangle_component *
d_prefix PARAMS ((struct d_info *));

static struct demangle_component *
d_unqualified_name PARAMS ((struct d_info *));

static struct demangle_component *
d_source_name PARAMS ((struct d_info *));

static long
d_number PARAMS ((struct d_info *));

static struct demangle_component *
d_identifier PARAMS ((struct d_info *, int));

static struct demangle_component *
d_operator_name PARAMS ((struct d_info *));

static struct demangle_component *
d_special_name PARAMS ((struct d_info *));

static int
d_call_offset PARAMS ((struct d_info *, int));

static struct demangle_component *
d_ctor_dtor_name PARAMS ((struct d_info *));

static struct demangle_component **
d_cv_qualifiers PARAMS ((struct d_info *, struct demangle_component **, int));

static struct demangle_component *
d_function_type PARAMS ((struct d_info *));

static struct demangle_component *
d_bare_function_type PARAMS ((struct d_info *, int));

static struct demangle_component *
d_class_enum_type PARAMS ((struct d_info *));

static struct demangle_component *
d_array_type PARAMS ((struct d_info *));

static struct demangle_component *
d_pointer_to_member_type PARAMS ((struct d_info *));

static struct demangle_component *
d_template_param PARAMS ((struct d_info *));

static struct demangle_component *
d_template_args PARAMS ((struct d_info *));

static struct demangle_component *
d_template_arg PARAMS ((struct d_info *));

static struct demangle_component *
d_expression PARAMS ((struct d_info *));

static struct demangle_component *
d_expr_primary PARAMS ((struct d_info *));

static struct demangle_component *
d_local_name PARAMS ((struct d_info *));

static int
d_discriminator PARAMS ((struct d_info *));

static int
d_add_substitution PARAMS ((struct d_info *, struct demangle_component *));

static struct demangle_component *
d_substitution PARAMS ((struct d_info *, int));

static void
d_print_resize PARAMS ((struct d_print_info *, size_t));

static void
d_print_append_char PARAMS ((struct d_print_info *, int));

static void
d_print_append_buffer PARAMS ((struct d_print_info *, const char *, size_t));

static void
d_print_error PARAMS ((struct d_print_info *));

static void
d_print_comp PARAMS ((struct d_print_info *,
		      const struct demangle_component *));

static void
d_print_java_identifier PARAMS ((struct d_print_info *, const char *, int));

static void
d_print_mod_list PARAMS ((struct d_print_info *, struct d_print_mod *, int));

static void
d_print_mod PARAMS ((struct d_print_info *,
		     const struct demangle_component *));

static void
d_print_function_type PARAMS ((struct d_print_info *,
			       const struct demangle_component *,
			       struct d_print_mod *));

static void
d_print_array_type PARAMS ((struct d_print_info *,
			    const struct demangle_component *,
			    struct d_print_mod *));

static void
d_print_expr_op PARAMS ((struct d_print_info *,
			 const struct demangle_component *));

static void
d_print_cast PARAMS ((struct d_print_info *,
		      const struct demangle_component *));

static char *
d_demangle PARAMS ((const char *, int, size_t *));
d543 1
a543 1
     struct demangle_component *dc;
d556 1
a556 1
    case DEMANGLE_COMPONENT_NAME:
d559 1
a559 1
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
d562 1
a562 1
    case DEMANGLE_COMPONENT_CTOR:
d566 1
a566 1
    case DEMANGLE_COMPONENT_DTOR:
d570 1
a570 1
    case DEMANGLE_COMPONENT_SUB_STD:
d573 1
a573 1
    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
d576 1
a576 1
    case DEMANGLE_COMPONENT_OPERATOR:
d579 1
a579 1
    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
d585 1
a585 1
    case DEMANGLE_COMPONENT_QUAL_NAME:
d588 1
a588 4
    case DEMANGLE_COMPONENT_LOCAL_NAME:
      printf ("local name\n");
      break;
    case DEMANGLE_COMPONENT_TYPED_NAME:
d591 1
a591 1
    case DEMANGLE_COMPONENT_TEMPLATE:
d594 1
a594 1
    case DEMANGLE_COMPONENT_VTABLE:
d597 1
a597 1
    case DEMANGLE_COMPONENT_VTT:
d600 1
a600 1
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
d603 1
a603 1
    case DEMANGLE_COMPONENT_TYPEINFO:
d606 1
a606 1
    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
d609 1
a609 1
    case DEMANGLE_COMPONENT_TYPEINFO_FN:
d612 1
a612 1
    case DEMANGLE_COMPONENT_THUNK:
d615 1
a615 1
    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
d618 1
a618 1
    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
d621 1
a621 1
    case DEMANGLE_COMPONENT_JAVA_CLASS:
d624 1
a624 1
    case DEMANGLE_COMPONENT_GUARD:
d627 1
a627 1
    case DEMANGLE_COMPONENT_REFTEMP:
d630 1
a630 1
    case DEMANGLE_COMPONENT_RESTRICT:
d633 1
a633 1
    case DEMANGLE_COMPONENT_VOLATILE:
d636 1
a636 1
    case DEMANGLE_COMPONENT_CONST:
d639 1
a639 1
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
d642 1
a642 1
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
d645 1
a645 1
    case DEMANGLE_COMPONENT_CONST_THIS:
d648 1
a648 1
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
d651 1
a651 1
    case DEMANGLE_COMPONENT_POINTER:
d654 1
a654 1
    case DEMANGLE_COMPONENT_REFERENCE:
d657 1
a657 1
    case DEMANGLE_COMPONENT_COMPLEX:
d660 1
a660 1
    case DEMANGLE_COMPONENT_IMAGINARY:
d663 1
a663 1
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
d666 1
a666 1
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
d669 1
a669 1
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
d672 1
a672 1
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
d675 1
a675 1
    case DEMANGLE_COMPONENT_ARGLIST:
d678 1
a678 1
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
d681 1
a681 1
    case DEMANGLE_COMPONENT_CAST:
d684 1
a684 1
    case DEMANGLE_COMPONENT_UNARY:
d687 1
a687 1
    case DEMANGLE_COMPONENT_BINARY:
d690 1
a690 1
    case DEMANGLE_COMPONENT_BINARY_ARGS:
d693 1
a693 1
    case DEMANGLE_COMPONENT_TRINARY:
d696 1
a696 1
    case DEMANGLE_COMPONENT_TRINARY_ARG1:
d699 1
a699 1
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
d702 1
a702 1
    case DEMANGLE_COMPONENT_LITERAL:
d705 1
a705 1
    case DEMANGLE_COMPONENT_LITERAL_NEG:
a715 74
/* Fill in a DEMANGLE_COMPONENT_NAME.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_name (p, s, len)
     struct demangle_component *p;
     const char *s;
     int len;
{
  if (p == NULL || s == NULL || len == 0)
    return 0;
  p->type = DEMANGLE_COMPONENT_NAME;
  p->u.s_name.s = s;
  p->u.s_name.len = len;
  return 1;
}

/* Fill in a DEMANGLE_COMPONENT_EXTENDED_OPERATOR.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_extended_operator (p, args, name)
     struct demangle_component *p;
     int args;
     struct demangle_component *name;
{
  if (p == NULL || args < 0 || name == NULL)
    return 0;
  p->type = DEMANGLE_COMPONENT_EXTENDED_OPERATOR;
  p->u.s_extended_operator.args = args;
  p->u.s_extended_operator.name = name;
  return 1;
}

/* Fill in a DEMANGLE_COMPONENT_CTOR.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_ctor (p, kind, name)
     struct demangle_component *p;
     enum gnu_v3_ctor_kinds kind;
     struct demangle_component *name;
{
  if (p == NULL
      || name == NULL
      || (kind < gnu_v3_complete_object_ctor
	  && kind > gnu_v3_complete_object_allocating_ctor))
    return 0;
  p->type = DEMANGLE_COMPONENT_CTOR;
  p->u.s_ctor.kind = kind;
  p->u.s_ctor.name = name;
  return 1;
}

/* Fill in a DEMANGLE_COMPONENT_DTOR.  */

CP_STATIC_IF_GLIBCPP_V3
int
cplus_demangle_fill_dtor (p, kind, name)
     struct demangle_component *p;
     enum gnu_v3_dtor_kinds kind;
     struct demangle_component *name;
{
  if (p == NULL
      || name == NULL
      || (kind < gnu_v3_deleting_dtor
	  && kind > gnu_v3_base_object_dtor))
    return 0;
  p->type = DEMANGLE_COMPONENT_DTOR;
  p->u.s_dtor.kind = kind;
  p->u.s_dtor.name = name;
  return 1;
}

d718 2
a719 2
static struct demangle_component *
d_make_empty (di)
d721 1
d723 1
a723 1
  struct demangle_component *p;
d728 1
d735 1
a735 1
static struct demangle_component *
d738 3
a740 3
     enum demangle_component_type type;
     struct demangle_component *left;
     struct demangle_component *right;
d742 1
a742 1
  struct demangle_component *p;
d750 13
a762 15
    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
    case DEMANGLE_COMPONENT_TYPED_NAME:
    case DEMANGLE_COMPONENT_TEMPLATE:
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
    case DEMANGLE_COMPONENT_UNARY:
    case DEMANGLE_COMPONENT_BINARY:
    case DEMANGLE_COMPONENT_BINARY_ARGS:
    case DEMANGLE_COMPONENT_TRINARY:
    case DEMANGLE_COMPONENT_TRINARY_ARG1:
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
    case DEMANGLE_COMPONENT_LITERAL:
    case DEMANGLE_COMPONENT_LITERAL_NEG:
d768 20
a787 19
    case DEMANGLE_COMPONENT_VTABLE:
    case DEMANGLE_COMPONENT_VTT:
    case DEMANGLE_COMPONENT_TYPEINFO:
    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
    case DEMANGLE_COMPONENT_TYPEINFO_FN:
    case DEMANGLE_COMPONENT_THUNK:
    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
    case DEMANGLE_COMPONENT_JAVA_CLASS:
    case DEMANGLE_COMPONENT_GUARD:
    case DEMANGLE_COMPONENT_REFTEMP:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_REFERENCE:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
    case DEMANGLE_COMPONENT_ARGLIST:
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
    case DEMANGLE_COMPONENT_CAST:
d794 1
a794 1
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
d801 7
a807 7
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
d815 1
a815 1
  p = d_make_empty (di);
a817 1
      p->type = type;
d826 1
a826 1
static struct demangle_component *
d832 1
a832 1
  struct demangle_component *p;
d834 1
a834 2
  p = d_make_empty (di);
  if (! cplus_demangle_fill_name (p, s, len))
d836 6
d847 1
a847 1
static struct demangle_component *
d850 1
a850 1
     const struct demangle_builtin_type_info *type;
d852 1
a852 1
  struct demangle_component *p;
d856 1
a856 1
  p = d_make_empty (di);
d858 1
a858 4
    {
      p->type = DEMANGLE_COMPONENT_BUILTIN_TYPE;
      p->u.s_builtin.type = type;
    }
d864 1
a864 1
static struct demangle_component *
d867 1
a867 1
     const struct demangle_operator_info *op;
d869 1
a869 1
  struct demangle_component *p;
d871 1
a871 1
  p = d_make_empty (di);
d873 1
a873 4
    {
      p->type = DEMANGLE_COMPONENT_OPERATOR;
      p->u.s_operator.op = op;
    }
d879 1
a879 1
static struct demangle_component *
d883 1
a883 1
     struct demangle_component *name;
d885 1
a885 1
  struct demangle_component *p;
d887 1
a887 2
  p = d_make_empty (di);
  if (! cplus_demangle_fill_extended_operator (p, args, name))
d889 6
d900 1
a900 1
static struct demangle_component *
d904 1
a904 1
     struct demangle_component *name;
d906 1
a906 1
  struct demangle_component *p;
d908 1
a908 2
  p = d_make_empty (di);
  if (! cplus_demangle_fill_ctor (p, kind, name))
d910 6
d921 1
a921 1
static struct demangle_component *
d925 1
a925 1
     struct demangle_component *name;
d927 1
a927 1
  struct demangle_component *p;
d929 1
a929 2
  p = d_make_empty (di);
  if (! cplus_demangle_fill_dtor (p, kind, name))
d931 6
d942 1
a942 1
static struct demangle_component *
d947 1
a947 1
  struct demangle_component *p;
d949 1
a949 1
  p = d_make_empty (di);
d951 1
a951 4
    {
      p->type = DEMANGLE_COMPONENT_TEMPLATE_PARAM;
      p->u.s_number.number = i;
    }
d957 2
a958 2
static struct demangle_component *
d_make_sub (di, name, len)
a960 1
     int len;
d962 1
a962 1
  struct demangle_component *p;
d964 1
a964 1
  p = d_make_empty (di);
d966 1
a966 5
    {
      p->type = DEMANGLE_COMPONENT_SUB_STD;
      p->u.s_string.string = name;
      p->u.s_string.len = len;
    }
d974 2
a975 3
CP_STATIC_IF_GLIBCPP_V3
struct demangle_component *
cplus_demangle_mangled_name (di, top_level)
d997 1
a997 1
     struct demangle_component *dc;
d1005 1
a1005 1
    case DEMANGLE_COMPONENT_TEMPLATE:
d1007 3
a1009 3
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
d1019 1
a1019 1
     struct demangle_component *dc;
d1027 1
a1027 2
    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
d1029 3
a1031 3
    case DEMANGLE_COMPONENT_CTOR:
    case DEMANGLE_COMPONENT_DTOR:
    case DEMANGLE_COMPONENT_CAST:
d1045 1
a1045 1
static struct demangle_component *
d1056 1
a1056 1
      struct demangle_component *dc;
d1065 3
a1067 3
	  while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS
		 || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS
		 || dc->type == DEMANGLE_COMPONENT_CONST_THIS)
a1068 17

	  /* If the top level is a DEMANGLE_COMPONENT_LOCAL_NAME, then
	     there may be CV-qualifiers on its right argument which
	     really apply here; this happens when parsing a class
	     which is local to a function.  */
	  if (dc->type == DEMANGLE_COMPONENT_LOCAL_NAME)
	    {
	      struct demangle_component *dcr;

	      dcr = d_right (dc);
	      while (dcr->type == DEMANGLE_COMPONENT_RESTRICT_THIS
		     || dcr->type == DEMANGLE_COMPONENT_VOLATILE_THIS
		     || dcr->type == DEMANGLE_COMPONENT_CONST_THIS)
		dcr = d_left (dcr);
	      dc->u.s_binary.right = dcr;
	    }

d1075 1
a1075 1
      return d_make_comp (di, DEMANGLE_COMPONENT_TYPED_NAME, dc,
d1092 1
a1092 1
static struct demangle_component *
d1097 1
a1097 1
  struct demangle_component *dc;
d1119 1
a1119 2
	    dc = d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME,
			      d_make_name (di, "std", 3),
a1120 1
	    di->expansion += 3;
d1141 1
a1141 2
	    dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,
			      d_template_args (di));
d1156 1
a1156 2
	  dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,
			    d_template_args (di));
d1166 1
a1166 1
static struct demangle_component *
d1170 2
a1171 2
  struct demangle_component *ret;
  struct demangle_component **pret;
d1201 1
a1201 1
static struct demangle_component *
d1205 1
a1205 1
  struct demangle_component *ret = NULL;
d1210 2
a1211 2
      enum demangle_component_type comb_type;
      struct demangle_component *dc;
d1221 1
a1221 1
      comb_type = DEMANGLE_COMPONENT_QUAL_NAME;
d1233 1
a1233 1
	  comb_type = DEMANGLE_COMPONENT_TEMPLATE;
d1261 1
a1261 1
static struct demangle_component *
d1271 1
a1271 8
    {
      struct demangle_component *ret;

      ret = d_operator_name (di);
      if (ret != NULL && ret->type == DEMANGLE_COMPONENT_OPERATOR)
	di->expansion += sizeof "operator" + ret->u.s_operator.op->len - 2;
      return ret;
    }
d1280 1
a1280 1
static struct demangle_component *
d1285 1
a1285 1
  struct demangle_component *ret;
d1301 1
a1301 1
  int negative;
d1305 1
a1305 1
  negative = 0;
d1309 1
a1309 1
      negative = 1;
d1318 1
a1318 5
	{
	  if (negative)
	    ret = - ret;
	  return ret;
	}
d1327 1
a1327 1
static struct demangle_component *
a1334 4

  if (di->send - name < len)
    return NULL;

a1336 7
  /* A Java mangled name may have a trailing '$' if it is a C++
     keyword.  This '$' is not included in the length count.  We just
     ignore the '$'.  */
  if ((di->options & DMGL_JAVA) != 0
      && d_peek_char (di) == '$')
    d_advance (di, 1);

d1349 2
a1350 5
	{
	  di->expansion -= len - sizeof "(anonymous namespace)";
	  return d_make_name (di, "(anonymous namespace)",
			      sizeof "(anonymous namespace)" - 1);
	}
d1361 1
a1361 4
#define NL(s) s, (sizeof s) - 1

CP_STATIC_IF_GLIBCPP_V3
const struct demangle_operator_info cplus_demangle_operators[] =
d1363 49
a1411 50
  { "aN", NL ("&="),        2 },
  { "aS", NL ("="),         2 },
  { "aa", NL ("&&"),        2 },
  { "ad", NL ("&"),         1 },
  { "an", NL ("&"),         2 },
  { "cl", NL ("()"),        0 },
  { "cm", NL (","),         2 },
  { "co", NL ("~"),         1 },
  { "dV", NL ("/="),        2 },
  { "da", NL ("delete[]"),  1 },
  { "de", NL ("*"),         1 },
  { "dl", NL ("delete"),    1 },
  { "dv", NL ("/"),         2 },
  { "eO", NL ("^="),        2 },
  { "eo", NL ("^"),         2 },
  { "eq", NL ("=="),        2 },
  { "ge", NL (">="),        2 },
  { "gt", NL (">"),         2 },
  { "ix", NL ("[]"),        2 },
  { "lS", NL ("<<="),       2 },
  { "le", NL ("<="),        2 },
  { "ls", NL ("<<"),        2 },
  { "lt", NL ("<"),         2 },
  { "mI", NL ("-="),        2 },
  { "mL", NL ("*="),        2 },
  { "mi", NL ("-"),         2 },
  { "ml", NL ("*"),         2 },
  { "mm", NL ("--"),        1 },
  { "na", NL ("new[]"),     1 },
  { "ne", NL ("!="),        2 },
  { "ng", NL ("-"),         1 },
  { "nt", NL ("!"),         1 },
  { "nw", NL ("new"),       1 },
  { "oR", NL ("|="),        2 },
  { "oo", NL ("||"),        2 },
  { "or", NL ("|"),         2 },
  { "pL", NL ("+="),        2 },
  { "pl", NL ("+"),         2 },
  { "pm", NL ("->*"),       2 },
  { "pp", NL ("++"),        1 },
  { "ps", NL ("+"),         1 },
  { "pt", NL ("->"),        2 },
  { "qu", NL ("?"),         3 },
  { "rM", NL ("%="),        2 },
  { "rS", NL (">>="),       2 },
  { "rm", NL ("%"),         2 },
  { "rs", NL (">>"),        2 },
  { "st", NL ("sizeof "),   1 },
  { "sz", NL ("sizeof "),   1 },
  { NULL, NULL, 0,          0 }
d1414 1
a1414 1
static struct demangle_component *
d1426 1
a1426 2
    return d_make_comp (di, DEMANGLE_COMPONENT_CAST,
			cplus_demangle_type (di), NULL);
a1428 1
      /* LOW is the inclusive lower bound.  */
d1430 1
a1430 5
      /* HIGH is the exclusive upper bound.  We subtract one to ignore
	 the sentinel at the end of the array.  */
      int high = ((sizeof (cplus_demangle_operators)
		   / sizeof (cplus_demangle_operators[0]))
		  - 1);
d1435 1
a1435 1
	  const struct demangle_operator_info *p;
d1438 1
a1438 1
	  p = cplus_demangle_operators + i;
d1467 1
a1467 1
static struct demangle_component *
a1472 1
  di->expansion += 20;
d1479 1
a1479 3
	  di->expansion -= 5;
	  return d_make_comp (di, DEMANGLE_COMPONENT_VTABLE,
			      cplus_demangle_type (di), NULL);
d1481 1
a1481 3
	  di->expansion -= 10;
	  return d_make_comp (di, DEMANGLE_COMPONENT_VTT,
			      cplus_demangle_type (di), NULL);
d1483 1
a1483 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO,
			      cplus_demangle_type (di), NULL);
d1485 1
a1485 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO_NAME,
			      cplus_demangle_type (di), NULL);
d1490 1
a1490 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_THUNK,
			      d_encoding (di, 0), NULL);
d1495 2
a1496 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_VIRTUAL_THUNK,
			      d_encoding (di, 0), NULL);
d1503 2
a1504 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_COVARIANT_THUNK,
			      d_encoding (di, 0), NULL);
d1508 1
a1508 1
	    struct demangle_component *derived_type;
d1510 1
a1510 1
	    struct demangle_component *base_type;
d1512 1
a1512 1
	    derived_type = cplus_demangle_type (di);
d1518 1
a1518 1
	    base_type = cplus_demangle_type (di);
d1521 2
a1522 3
	    di->expansion += 5;
	    return d_make_comp (di, DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE,
				base_type, derived_type);
d1526 1
a1526 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO_FN,
			      cplus_demangle_type (di), NULL);
d1528 1
a1528 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_JAVA_CLASS,
			      cplus_demangle_type (di), NULL);
d1539 1
a1539 1
	  return d_make_comp (di, DEMANGLE_COMPONENT_GUARD, d_name (di), NULL);
d1542 1
a1542 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_REFTEMP, d_name (di),
			      NULL);
d1602 1
a1602 1
static struct demangle_component *
a1605 7
  if (di->last_name != NULL)
    {
      if (di->last_name->type == DEMANGLE_COMPONENT_NAME)
	di->expansion += di->last_name->u.s_name.len;
      else if (di->last_name->type == DEMANGLE_COMPONENT_SUB_STD)
	di->expansion += di->last_name->u.s_string.len;
    }
d1674 28
a1701 30
CP_STATIC_IF_GLIBCPP_V3
const struct demangle_builtin_type_info
cplus_demangle_builtin_types[D_BUILTIN_TYPE_COUNT] =
{
  /* a */ { NL ("signed char"),	NL ("signed char"),	D_PRINT_INT },
  /* b */ { NL ("bool"),	NL ("boolean"),		D_PRINT_BOOL },
  /* c */ { NL ("char"),	NL ("byte"),		D_PRINT_INT },
  /* d */ { NL ("double"),	NL ("double"),		D_PRINT_DEFAULT },
  /* e */ { NL ("long double"),	NL ("long double"),	D_PRINT_DEFAULT },
  /* f */ { NL ("float"),	NL ("float"),		D_PRINT_DEFAULT },
  /* g */ { NL ("__float128"),	NL ("__float128"),	D_PRINT_DEFAULT },
  /* h */ { NL ("unsigned char"), NL ("unsigned char"),	D_PRINT_INT },
  /* i */ { NL ("int"),		NL ("int"),		D_PRINT_INT },
  /* j */ { NL ("unsigned int"), NL ("unsigned"),	D_PRINT_INT },
  /* k */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* l */ { NL ("long"),	NL ("long"),		D_PRINT_LONG },
  /* m */ { NL ("unsigned long"), NL ("unsigned long"),	D_PRINT_LONG },
  /* n */ { NL ("__int128"),	NL ("__int128"),	D_PRINT_DEFAULT },
  /* o */ { NL ("unsigned __int128"), NL ("unsigned __int128"),	D_PRINT_DEFAULT },
  /* p */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* q */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* r */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* s */ { NL ("short"),	NL ("short"),		D_PRINT_INT },
  /* t */ { NL ("unsigned short"), NL ("unsigned short"), D_PRINT_INT },
  /* u */ { NULL, 0,		NULL, 0,		D_PRINT_DEFAULT },
  /* v */ { NL ("void"),	NL ("void"),		D_PRINT_VOID },
  /* w */ { NL ("wchar_t"),	NL ("char"),		D_PRINT_INT },
  /* x */ { NL ("long long"),	NL ("long"),		D_PRINT_DEFAULT },
  /* y */ { NL ("unsigned long long"), NL ("unsigned long long"), D_PRINT_DEFAULT },
  /* z */ { NL ("..."),		NL ("..."),		D_PRINT_DEFAULT },
d1704 2
a1705 3
CP_STATIC_IF_GLIBCPP_V3
struct demangle_component *
cplus_demangle_type (di)
d1709 1
a1709 1
  struct demangle_component *ret;
d1730 1
a1730 1
      struct demangle_component **pret;
d1735 1
a1735 1
      *pret = cplus_demangle_type (di);
d1749 1
a1749 3
      ret = d_make_builtin_type (di,
				 &cplus_demangle_builtin_types[peek - 'a']);
      di->expansion += ret->u.s_builtin.type->len;
d1756 1
a1756 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE,
			 d_source_name (di), NULL);
d1787 1
a1787 2
	  ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,
			     d_template_args (di));
d1806 1
a1806 1
	      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,
d1818 1
a1818 1
	    if (ret != NULL && ret->type == DEMANGLE_COMPONENT_SUB_STD)
d1826 1
a1826 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_POINTER,
			 cplus_demangle_type (di), NULL);
d1831 1
a1831 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_REFERENCE,
			 cplus_demangle_type (di), NULL);
d1836 1
a1836 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_COMPLEX,
			 cplus_demangle_type (di), NULL);
d1841 1
a1841 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_IMAGINARY,
			 cplus_demangle_type (di), NULL);
d1847 1
a1847 2
      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL,
			 cplus_demangle_type (di), ret);
d1865 1
a1865 1
static struct demangle_component **
d1868 1
a1868 1
     struct demangle_component **pret;
d1876 1
a1876 1
      enum demangle_component_type t;
d1880 1
a1880 6
	{
	  t = (member_fn
	       ? DEMANGLE_COMPONENT_RESTRICT_THIS
	       : DEMANGLE_COMPONENT_RESTRICT);
	  di->expansion += sizeof "restrict";
	}
d1882 1
a1882 6
	{
	  t = (member_fn
	       ? DEMANGLE_COMPONENT_VOLATILE_THIS
	       : DEMANGLE_COMPONENT_VOLATILE);
	  di->expansion += sizeof "volatile";
	}
d1884 1
a1884 6
	{
	  t = (member_fn
	       ? DEMANGLE_COMPONENT_CONST_THIS
	       : DEMANGLE_COMPONENT_CONST);
	  di->expansion += sizeof "const";
	}
d1899 1
a1899 1
static struct demangle_component *
d1903 1
a1903 1
  struct demangle_component *ret;
d1921 1
a1921 1
static struct demangle_component *
d1926 3
a1928 3
  struct demangle_component *return_type;
  struct demangle_component *tl;
  struct demangle_component **ptl;
d1936 1
a1936 1
      struct demangle_component *type;
d1941 1
a1941 1
      type = cplus_demangle_type (di);
d1951 1
a1951 1
	  *ptl = d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, type, NULL);
d1966 1
a1966 1
      && d_left (tl)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE
d1968 1
a1968 4
    {
      di->expansion -= d_left (tl)->u.s_builtin.type->len;
      tl = NULL;
    }
d1970 1
a1970 1
  return d_make_comp (di, DEMANGLE_COMPONENT_FUNCTION_TYPE, return_type, tl);
d1975 1
a1975 1
static struct demangle_component *
d1986 1
a1986 1
static struct demangle_component *
d1991 1
a1991 1
  struct demangle_component *dim;
d2024 1
a2024 2
  return d_make_comp (di, DEMANGLE_COMPONENT_ARRAY_TYPE, dim,
		      cplus_demangle_type (di));
d2029 1
a2029 1
static struct demangle_component *
d2033 3
a2035 3
  struct demangle_component *cl;
  struct demangle_component *mem;
  struct demangle_component **pmem;
d2040 1
a2040 1
  cl = cplus_demangle_type (di);
d2053 1
a2053 1
     avoid calling add_substitution() in cplus_demangle_type().  */
d2058 1
a2058 1
  *pmem = cplus_demangle_type (di);
d2060 1
a2060 1
  return d_make_comp (di, DEMANGLE_COMPONENT_PTRMEM_TYPE, cl, mem);
d2067 1
a2067 1
static struct demangle_component *
a2088 2
  ++di->did_subs;

d2094 1
a2094 1
static struct demangle_component *
d2098 3
a2100 3
  struct demangle_component *hold_last_name;
  struct demangle_component *al;
  struct demangle_component **pal;
d2114 1
a2114 1
      struct demangle_component *a;
d2120 1
a2120 1
      *pal = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, a, NULL);
d2142 1
a2142 1
static struct demangle_component *
d2146 1
a2146 1
  struct demangle_component *ret;
d2161 1
a2161 1
      return cplus_demangle_type (di);
d2175 1
a2175 1
static struct demangle_component *
d2188 2
a2189 2
      struct demangle_component *type;
      struct demangle_component *name;
d2192 1
a2192 1
      type = cplus_demangle_type (di);
d2195 1
a2195 1
	return d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);
d2197 2
a2198 2
	return d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type,
			    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,
d2203 1
a2203 1
      struct demangle_component *op;
d2210 1
a2210 4
      if (op->type == DEMANGLE_COMPONENT_OPERATOR)
	di->expansion += op->u.s_operator.op->len - 2;

      if (op->type == DEMANGLE_COMPONENT_OPERATOR
d2212 1
a2212 2
	return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
			    cplus_demangle_type (di));
d2218 1
a2218 1
	case DEMANGLE_COMPONENT_OPERATOR:
d2221 1
a2221 1
	case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
d2224 1
a2224 1
	case DEMANGLE_COMPONENT_CAST:
d2232 1
a2232 2
	  return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,
			      d_expression (di));
d2235 1
a2235 1
	    struct demangle_component *left;
d2238 2
a2239 4
	    return d_make_comp (di, DEMANGLE_COMPONENT_BINARY, op,
				d_make_comp (di,
					     DEMANGLE_COMPONENT_BINARY_ARGS,
					     left,
d2244 2
a2245 2
	    struct demangle_component *first;
	    struct demangle_component *second;
d2249 2
a2250 4
	    return d_make_comp (di, DEMANGLE_COMPONENT_TRINARY, op,
				d_make_comp (di,
					     DEMANGLE_COMPONENT_TRINARY_ARG1,
					     first,
d2252 1
a2252 1
							  DEMANGLE_COMPONENT_TRINARY_ARG2,
d2267 1
a2267 1
static struct demangle_component *
d2271 1
a2271 1
  struct demangle_component *ret;
d2276 1
a2276 1
    ret = cplus_demangle_mangled_name (di, 0);
d2279 2
a2280 2
      struct demangle_component *type;
      enum demangle_component_type t;
d2283 1
a2283 7
      type = cplus_demangle_type (di);

      /* If we have a type we know how to print, we aren't going to
	 print the type name itself.  */
      if (type->type == DEMANGLE_COMPONENT_BUILTIN_TYPE
	  && type->u.s_builtin.type->print != D_PRINT_DEFAULT)
	di->expansion -= type->u.s_builtin.type->len;
d2296 1
a2296 1
      t = DEMANGLE_COMPONENT_LITERAL;
d2299 1
a2299 1
	  t = DEMANGLE_COMPONENT_LITERAL_NEG;
d2316 1
a2316 1
static struct demangle_component *
d2320 1
a2320 1
  struct demangle_component *function;
d2335 1
a2335 1
      return d_make_comp (di, DEMANGLE_COMPONENT_LOCAL_NAME, function,
d2341 1
a2341 1
      struct demangle_component *name;
d2346 1
a2346 1
      return d_make_comp (di, DEMANGLE_COMPONENT_LOCAL_NAME, function, name);
d2375 1
a2375 1
     struct demangle_component *dc;
d2407 15
a2421 21
  { 't', NL ("std"),
    NL ("std"),
    NULL, 0 },
  { 'a', NL ("std::allocator"),
    NL ("std::allocator"),
    NL ("allocator") },
  { 'b', NL ("std::basic_string"),
    NL ("std::basic_string"),
    NL ("basic_string") },
  { 's', NL ("std::string"),
    NL ("std::basic_string<char, std::char_traits<char>, std::allocator<char> >"),
    NL ("basic_string") },
  { 'i', NL ("std::istream"),
    NL ("std::basic_istream<char, std::char_traits<char> >"),
    NL ("basic_istream") },
  { 'o', NL ("std::ostream"),
    NL ("std::basic_ostream<char, std::char_traits<char> >"),
    NL ("basic_ostream") },
  { 'd', NL ("std::iostream"),
    NL ("std::basic_iostream<char, std::char_traits<char> >"),
    NL ("basic_iostream") }
d2424 1
a2424 1
static struct demangle_component *
a2459 2
      ++di->did_subs;

a2483 3
	      const char *s;
	      int len;

d2485 1
a2485 2
		di->last_name = d_make_sub (di, p->set_last_name,
					    p->set_last_name_len);
d2487 1
a2487 4
		{
		  s = p->full_expansion;
		  len = p->full_len;
		}
d2489 1
a2489 6
		{
		  s = p->simple_expansion;
		  len = p->simple_len;
		}
	      di->expansion += len;
	      return d_make_sub (di, s, len);
d2581 4
a2584 7
/* Turn components into a human readable string.  OPTIONS is the
   options bits passed to the demangler.  DC is the tree to print.
   ESTIMATE is a guess at the length of the result.  This returns a
   string allocated by malloc, or NULL on error.  On success, this
   sets *PALC to the size of the allocated buffer.  On failure, this
   sets *PALC to 0 for a bad parse, or to 1 for a memory allocation
   failure.  */
d2586 2
a2587 3
CP_STATIC_IF_GLIBCPP_V3
char *
cplus_demangle_print (options, dc, estimate, palc)
d2589 1
a2589 2
     const struct demangle_component *dc;
     int estimate;
d2596 1
a2596 1
  dpi.alc = estimate + 1;
d2627 1
a2627 1
     const struct demangle_component *dc;
d2639 2
a2640 5
    case DEMANGLE_COMPONENT_NAME:
      if ((dpi->options & DMGL_JAVA) == 0)
	d_append_buffer (dpi, dc->u.s_name.s, dc->u.s_name.len);
      else
	d_print_java_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);
d2643 1
a2643 2
    case DEMANGLE_COMPONENT_QUAL_NAME:
    case DEMANGLE_COMPONENT_LOCAL_NAME:
d2645 1
a2645 4
      if ((dpi->options & DMGL_JAVA) == 0)
	d_append_string_constant (dpi, "::");
      else
	d_append_char (dpi, '.');
d2649 1
a2649 1
    case DEMANGLE_COMPONENT_TYPED_NAME:
d2652 1
a2652 1
	struct demangle_component *typed_name;
d2678 3
a2680 3
	    if (typed_name->type != DEMANGLE_COMPONENT_RESTRICT_THIS
		&& typed_name->type != DEMANGLE_COMPONENT_VOLATILE_THIS
		&& typed_name->type != DEMANGLE_COMPONENT_CONST_THIS)
d2688 1
a2688 1
	if (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)
a2694 32
	/* If typed_name is a DEMANGLE_COMPONENT_LOCAL_NAME, then
	   there may be CV-qualifiers on its right argument which
	   really apply here; this happens when parsing a class which
	   is local to a function.  */
	if (typed_name->type == DEMANGLE_COMPONENT_LOCAL_NAME)
	  {
	    struct demangle_component *local_name;

	    local_name = d_right (typed_name);
	    while (local_name->type == DEMANGLE_COMPONENT_RESTRICT_THIS
		   || local_name->type == DEMANGLE_COMPONENT_VOLATILE_THIS
		   || local_name->type == DEMANGLE_COMPONENT_CONST_THIS)
	      {
		if (i >= sizeof adpm / sizeof adpm[0])
		  {
		    d_print_error (dpi);
		    return;
		  }

		adpm[i] = adpm[i - 1];
		adpm[i].next = &adpm[i - 1];
		dpi->modifiers = &adpm[i];

		adpm[i - 1].mod = local_name;
		adpm[i - 1].printed = 0;
		adpm[i - 1].templates = dpi->templates;
		++i;

		local_name = d_left (local_name);
	      }
	  }

d2697 1
a2697 1
	if (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)
d2717 1
a2717 1
    case DEMANGLE_COMPONENT_TEMPLATE:
d2744 1
a2744 1
    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:
d2747 1
a2747 1
	struct demangle_component *a;
d2760 1
a2760 1
	    if (a->type != DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)
d2790 1
a2790 1
    case DEMANGLE_COMPONENT_CTOR:
d2794 1
a2794 1
    case DEMANGLE_COMPONENT_DTOR:
d2799 2
a2800 2
    case DEMANGLE_COMPONENT_VTABLE:
      d_append_string_constant (dpi, "vtable for ");
d2804 2
a2805 2
    case DEMANGLE_COMPONENT_VTT:
      d_append_string_constant (dpi, "VTT for ");
d2809 2
a2810 2
    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:
      d_append_string_constant (dpi, "construction vtable for ");
d2812 1
a2812 1
      d_append_string_constant (dpi, "-in-");
d2816 2
a2817 2
    case DEMANGLE_COMPONENT_TYPEINFO:
      d_append_string_constant (dpi, "typeinfo for ");
d2821 2
a2822 2
    case DEMANGLE_COMPONENT_TYPEINFO_NAME:
      d_append_string_constant (dpi, "typeinfo name for ");
d2826 2
a2827 2
    case DEMANGLE_COMPONENT_TYPEINFO_FN:
      d_append_string_constant (dpi, "typeinfo fn for ");
d2831 2
a2832 2
    case DEMANGLE_COMPONENT_THUNK:
      d_append_string_constant (dpi, "non-virtual thunk to ");
d2836 2
a2837 2
    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:
      d_append_string_constant (dpi, "virtual thunk to ");
d2841 2
a2842 2
    case DEMANGLE_COMPONENT_COVARIANT_THUNK:
      d_append_string_constant (dpi, "covariant return thunk to ");
d2846 2
a2847 2
    case DEMANGLE_COMPONENT_JAVA_CLASS:
      d_append_string_constant (dpi, "java Class for ");
d2851 2
a2852 2
    case DEMANGLE_COMPONENT_GUARD:
      d_append_string_constant (dpi, "guard variable for ");
d2856 2
a2857 2
    case DEMANGLE_COMPONENT_REFTEMP:
      d_append_string_constant (dpi, "reference temporary for ");
d2861 2
a2862 2
    case DEMANGLE_COMPONENT_SUB_STD:
      d_append_buffer (dpi, dc->u.s_string.string, dc->u.s_string.len);
d2865 11
a2875 11
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
    case DEMANGLE_COMPONENT_CONST_THIS:
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
    case DEMANGLE_COMPONENT_POINTER:
    case DEMANGLE_COMPONENT_REFERENCE:
    case DEMANGLE_COMPONENT_COMPLEX:
    case DEMANGLE_COMPONENT_IMAGINARY:
d2898 1
a2898 1
    case DEMANGLE_COMPONENT_BUILTIN_TYPE:
d2900 1
a2900 2
	d_append_buffer (dpi, dc->u.s_builtin.type->name,
			 dc->u.s_builtin.type->len);
d2902 1
a2902 2
	d_append_buffer (dpi, dc->u.s_builtin.type->java_name,
			 dc->u.s_builtin.type->java_len);
d2905 1
a2905 1
    case DEMANGLE_COMPONENT_VENDOR_TYPE:
d2909 1
a2909 1
    case DEMANGLE_COMPONENT_FUNCTION_TYPE:
d2939 1
a2939 1
    case DEMANGLE_COMPONENT_ARRAY_TYPE:
d2964 1
a2964 1
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
d2982 1
a2982 1
	    d_append_string_constant (dpi, "::*");
d2990 2
a2991 2
    case DEMANGLE_COMPONENT_ARGLIST:
    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
d2995 1
a2995 1
	  d_append_string_constant (dpi, ", ");
d3000 1
a3000 1
    case DEMANGLE_COMPONENT_OPERATOR:
d3004 1
a3004 1
	d_append_string_constant (dpi, "operator");
d3008 1
a3008 2
	d_append_buffer (dpi, dc->u.s_operator.op->name,
			 dc->u.s_operator.op->len);
d3012 2
a3013 2
    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
      d_append_string_constant (dpi, "operator ");
d3017 2
a3018 2
    case DEMANGLE_COMPONENT_CAST:
      d_append_string_constant (dpi, "operator ");
d3022 2
a3023 2
    case DEMANGLE_COMPONENT_UNARY:
      if (d_left (dc)->type != DEMANGLE_COMPONENT_CAST)
d3027 1
a3027 1
	  d_append_string_constant (dpi, "((");
d3034 1
a3034 1
      if (d_left (dc)->type == DEMANGLE_COMPONENT_CAST)
d3038 2
a3039 2
    case DEMANGLE_COMPONENT_BINARY:
      if (d_right (dc)->type != DEMANGLE_COMPONENT_BINARY_ARGS)
d3048 2
a3049 3
      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
	  && d_left (dc)->u.s_operator.op->len == 1
	  && d_left (dc)->u.s_operator.op->name[0] == '>')
d3054 1
a3054 1
      d_append_string_constant (dpi, ") ");
d3056 1
a3056 1
      d_append_string_constant (dpi, " (");
d3060 2
a3061 3
      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR
	  && d_left (dc)->u.s_operator.op->len == 1
	  && d_left (dc)->u.s_operator.op->name[0] == '>')
d3066 2
a3067 2
    case DEMANGLE_COMPONENT_BINARY_ARGS:
      /* We should only see this as part of DEMANGLE_COMPONENT_BINARY.  */
d3071 3
a3073 3
    case DEMANGLE_COMPONENT_TRINARY:
      if (d_right (dc)->type != DEMANGLE_COMPONENT_TRINARY_ARG1
	  || d_right (d_right (dc))->type != DEMANGLE_COMPONENT_TRINARY_ARG2)
d3080 1
a3080 1
      d_append_string_constant (dpi, ") ");
d3082 1
a3082 1
      d_append_string_constant (dpi, " (");
d3084 1
a3084 1
      d_append_string_constant (dpi, ") : (");
d3089 3
a3091 3
    case DEMANGLE_COMPONENT_TRINARY_ARG1:
    case DEMANGLE_COMPONENT_TRINARY_ARG2:
      /* We should only see these are part of DEMANGLE_COMPONENT_TRINARY.  */
d3095 2
a3096 2
    case DEMANGLE_COMPONENT_LITERAL:
    case DEMANGLE_COMPONENT_LITERAL_NEG:
d3098 1
a3098 1
      if (d_left (dc)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE)
d3103 1
a3103 1
	      if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME)
d3105 1
a3105 1
		  if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
d3113 1
a3113 1
	      if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME)
d3115 1
a3115 1
		  if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
d3124 1
a3124 1
	      if (d_right (dc)->type == DEMANGLE_COMPONENT_NAME
d3126 1
a3126 1
		  && dc->type == DEMANGLE_COMPONENT_LITERAL)
d3131 1
a3131 1
		      d_append_string_constant (dpi, "false");
d3134 1
a3134 1
		      d_append_string_constant (dpi, "true");
d3150 1
a3150 1
      if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)
d3161 1
a3161 4
/* Print a Java dentifier.  For Java we try to handle encoded extended
   Unicode characters.  The C++ ABI doesn't mention Unicode encoding,
   so we don't it for C++.  Characters are encoded as
   __U<hex-char>+_.  */
d3164 1
a3164 1
d_print_java_identifier (dpi, name, len)
d3169 3
a3171 5
  const char *p;
  const char *end;

  end = name + len;
  for (p = name; p < end; ++p)
d3173 2
a3174 7
      if (end - p > 3
	  && p[0] == '_'
	  && p[1] == '_'
	  && p[2] == 'U')
	{
	  unsigned long c;
	  const char *q;
d3176 11
a3186 2
	  c = 0;
	  for (q = p + 3; q < end; ++q)
d3188 7
a3194 1
	      int dig;
d3196 8
a3203 8
	      if (IS_DIGIT (*q))
		dig = *q - '0';
	      else if (*q >= 'A' && *q <= 'F')
		dig = *q - 'A' + 10;
	      else if (*q >= 'a' && *q <= 'f')
		dig = *q - 'a' + 10;
	      else
		break;
d3205 10
a3214 9
	      c = c * 16 + dig;
	    }
	  /* If the Unicode character is larger than 256, we don't try
	     to deal with it here.  FIXME.  */
	  if (q < end && *q == '_' && c < 256)
	    {
	      d_append_char (dpi, c);
	      p = q;
	      continue;
d3216 2
a3218 2

      d_append_char (dpi, *p);
d3238 3
a3240 3
	  && (mods->mod->type == DEMANGLE_COMPONENT_RESTRICT_THIS
	      || mods->mod->type == DEMANGLE_COMPONENT_VOLATILE_THIS
	      || mods->mod->type == DEMANGLE_COMPONENT_CONST_THIS)))
d3251 1
a3251 1
  if (mods->mod->type == DEMANGLE_COMPONENT_FUNCTION_TYPE)
d3257 1
a3257 1
  else if (mods->mod->type == DEMANGLE_COMPONENT_ARRAY_TYPE)
a3262 31
  else if (mods->mod->type == DEMANGLE_COMPONENT_LOCAL_NAME)
    {
      struct d_print_mod *hold_modifiers;
      struct demangle_component *dc;

      /* When this is on the modifier stack, we have pulled any
	 qualifiers off the right argument already.  Otherwise, we
	 print it as usual, but don't let the left argument see any
	 modifiers.  */

      hold_modifiers = dpi->modifiers;
      dpi->modifiers = NULL;
      d_print_comp (dpi, d_left (mods->mod));
      dpi->modifiers = hold_modifiers;

      if ((dpi->options & DMGL_JAVA) == 0)
	d_append_string_constant (dpi, "::");
      else
	d_append_char (dpi, '.');

      dc = d_right (mods->mod);
      while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS
	     || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS
	     || dc->type == DEMANGLE_COMPONENT_CONST_THIS)
	dc = d_left (dc);

      d_print_comp (dpi, dc);

      dpi->templates = hold_dpt;
      return;
    }
d3276 1
a3276 1
     const struct demangle_component *mod;
d3280 11
a3290 11
    case DEMANGLE_COMPONENT_RESTRICT:
    case DEMANGLE_COMPONENT_RESTRICT_THIS:
      d_append_string_constant (dpi, " restrict");
      return;
    case DEMANGLE_COMPONENT_VOLATILE:
    case DEMANGLE_COMPONENT_VOLATILE_THIS:
      d_append_string_constant (dpi, " volatile");
      return;
    case DEMANGLE_COMPONENT_CONST:
    case DEMANGLE_COMPONENT_CONST_THIS:
      d_append_string_constant (dpi, " const");
d3292 1
a3292 1
    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
d3296 1
a3296 1
    case DEMANGLE_COMPONENT_POINTER:
d3301 1
a3301 1
    case DEMANGLE_COMPONENT_REFERENCE:
d3304 2
a3305 2
    case DEMANGLE_COMPONENT_COMPLEX:
      d_append_string_constant (dpi, "complex ");
d3307 2
a3308 2
    case DEMANGLE_COMPONENT_IMAGINARY:
      d_append_string_constant (dpi, "imaginary ");
d3310 1
a3310 1
    case DEMANGLE_COMPONENT_PTRMEM_TYPE:
d3314 1
a3314 1
      d_append_string_constant (dpi, "::*");
d3316 1
a3316 1
    case DEMANGLE_COMPONENT_TYPED_NAME:
d3332 1
a3332 1
     const struct demangle_component *dc;
a3337 1
  struct d_print_mod *hold_modifiers;
d3349 9
a3357 9
	case DEMANGLE_COMPONENT_RESTRICT:
	case DEMANGLE_COMPONENT_VOLATILE:
	case DEMANGLE_COMPONENT_CONST:
	case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
	case DEMANGLE_COMPONENT_POINTER:
	case DEMANGLE_COMPONENT_REFERENCE:
	case DEMANGLE_COMPONENT_COMPLEX:
	case DEMANGLE_COMPONENT_IMAGINARY:
	case DEMANGLE_COMPONENT_PTRMEM_TYPE:
d3360 3
a3362 3
	case DEMANGLE_COMPONENT_RESTRICT_THIS:
	case DEMANGLE_COMPONENT_VOLATILE_THIS:
	case DEMANGLE_COMPONENT_CONST_THIS:
a3390 3
  hold_modifiers = dpi->modifiers;
  dpi->modifiers = NULL;

a3403 2

  dpi->modifiers = hold_modifiers;
d3411 1
a3411 1
     const struct demangle_component *dc;
d3428 1
a3428 1
	  if (p->mod->type == DEMANGLE_COMPONENT_ARRAY_TYPE)
d3442 1
a3442 1
	d_append_string_constant (dpi, " (");
d3466 1
a3466 1
     const struct demangle_component *dc;
d3468 2
a3469 3
  if (dc->type == DEMANGLE_COMPONENT_OPERATOR)
    d_append_buffer (dpi, dc->u.s_operator.op->name,
		     dc->u.s_operator.op->len);
d3479 1
a3479 1
     const struct demangle_component *dc;
d3481 1
a3481 1
  if (d_left (dc)->type != DEMANGLE_COMPONENT_TEMPLATE)
d3521 2
a3522 3
CP_STATIC_IF_GLIBCPP_V3
void
cplus_demangle_init_info (mangled, options, len, di)
a3528 1
  di->send = mangled + len;
d3537 2
d3544 2
a3546 1
  di->did_subs = 0;
d3550 10
a3559 1
  di->expansion = 0;
d3578 1
a3578 2
  struct demangle_component *dc;
  int estimate;
d3614 5
a3618 1
  cplus_demangle_init_info (mangled, options, len, &di);
d3620 4
a3623 22
  {
#ifdef CP_DYNAMIC_ARRAYS
    __extension__ struct demangle_component comps[di.num_comps];
    __extension__ struct demangle_component *subs[di.num_subs];

    di.comps = &comps[0];
    di.subs = &subs[0];
#else
    di.comps = ((struct demangle_component *)
		malloc (di.num_comps * sizeof (struct demangle_component)));
    di.subs = ((struct demangle_component **)
	       malloc (di.num_subs * sizeof (struct demangle_component *)));
    if (di.comps == NULL || di.subs == NULL)
      {
	if (di.comps != NULL)
	  free (di.comps);
	if (di.subs != NULL)
	  free (di.subs);
	*palc = 1;
	return NULL;
      }
#endif
d3625 6
a3630 11
    if (! type)
      dc = cplus_demangle_mangled_name (&di, 1);
    else
      dc = cplus_demangle_type (&di);

    /* If DMGL_PARAMS is set, then if we didn't consume the entire
       mangled string, then we didn't successfully demangle it.  If
       DMGL_PARAMS is not set, we didn't look at the trailing
       parameters.  */
    if (((options & DMGL_PARAMS) != 0) && d_peek_char (&di) != '\0')
      dc = NULL;
d3633 4
a3636 4
    if (dc == NULL)
      printf ("failed demangling\n");
    else
      d_dump (dc, 0);
d3639 2
a3640 13
    /* We try to guess the length of the demangled string, to minimize
       calls to realloc during demangling.  */
    estimate = len + di.expansion + 10 * di.did_subs;
    estimate += estimate / 8;

    ret = NULL;
    if (dc != NULL)
      ret = cplus_demangle_print (options, dc, estimate, palc);

#ifndef CP_DYNAMIC_ARRAYS
    free (di.comps);
    free (di.subs);
#endif
d3642 3
a3644 4
#ifdef CP_DEMANGLE_DEBUG
    if (ret != NULL)
      {
	int rlen;
d3646 1
a3646 13
	rlen = strlen (ret);
	if (rlen > 2 * estimate)
	  printf ("*** Length %d much greater than estimate %d\n",
		  rlen, estimate);
	else if (rlen > estimate)
	  printf ("*** Length %d greater than estimate %d\n",
		  rlen, estimate);
	else if (rlen < estimate / 2)
	  printf ("*** Length %d much less than estimate %d\n",
		  rlen, estimate);
      }
#endif
  }
d3823 1
a3823 1
  struct demangle_component *dc;
d3829 2
a3830 1
  cplus_demangle_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di);
d3832 1
a3832 21
  {
#ifdef CP_DYNAMIC_ARRAYS
    __extension__ struct demangle_component comps[di.num_comps];
    __extension__ struct demangle_component *subs[di.num_subs];

    di.comps = &comps[0];
    di.subs = &subs[0];
#else
    di.comps = ((struct demangle_component *)
		malloc (di.num_comps * sizeof (struct demangle_component)));
    di.subs = ((struct demangle_component **)
	       malloc (di.num_subs * sizeof (struct demangle_component *)));
    if (di.comps == NULL || di.subs == NULL)
      {
	if (di.comps != NULL)
	  free (di.comps);
	if (di.subs != NULL)
	  free (di.subs);
	return 0;
      }
#endif
d3834 2
a3835 1
    dc = cplus_demangle_mangled_name (&di, 1);
d3837 30
a3866 34
    /* Note that because we did not pass DMGL_PARAMS, we don't expect
       to demangle the entire string.  */

    ret = 0;
    while (dc != NULL)
      {
	switch (dc->type)
	  {
	  default:
	    dc = NULL;
	    break;
	  case DEMANGLE_COMPONENT_TYPED_NAME:
	  case DEMANGLE_COMPONENT_TEMPLATE:
	  case DEMANGLE_COMPONENT_RESTRICT_THIS:
	  case DEMANGLE_COMPONENT_VOLATILE_THIS:
	  case DEMANGLE_COMPONENT_CONST_THIS:
	    dc = d_left (dc);
	    break;
	  case DEMANGLE_COMPONENT_QUAL_NAME:
	  case DEMANGLE_COMPONENT_LOCAL_NAME:
	    dc = d_right (dc);
	    break;
	  case DEMANGLE_COMPONENT_CTOR:
	    *ctor_kind = dc->u.s_ctor.kind;
	    ret = 1;
	    dc = NULL;
	    break;
	  case DEMANGLE_COMPONENT_DTOR:
	    *dtor_kind = dc->u.s_dtor.kind;
	    ret = 1;
	    dc = NULL;
	    break;
	  }
      }
d3868 2
a3869 5
#ifndef CP_DYNAMIC_ARRAYS
    free (di.subs);
    free (di.comps);
#endif
  }
@


1.27.24.1
log
@Merge from mainline.
@
text
@d3401 1
a3401 1
	      RETURN_IF_ERROR (result_add (dm, "std::basic_istream<char, std::char_traits<char> >"));
@


1.26
log
@merge from gcc
@
text
@d838 2
a839 2
  dm->is_constructor = 0;
  dm->is_destructor = 0;
d977 1
a977 1
	error_message = strdup ("Expected ?");
d3977 1
a3977 1
    return 0;
d3999 1
a3999 1
    return 0;
@


1.25
log
@merge from gcc
@
text
@d54 2
d1471 1
d1474 36
a1509 1
      if (!dyn_string_append_char (identifier, next_char (dm)))
@


1.24
log
@merge from gcc
@
text
@d3883 1
a3920 1
#ifndef IN_GLIBCPP_V3
@


1.23
log
@merge from gcc
@
text
@d901 1
a901 1
  PARAMS ((demangling_t, int, int *));
d1328 1
a1328 1
      RETURN_IF_ERROR (demangle_operator_name (dm, 0, &num_args));
d1504 3
a1506 1
   operands that the operator takes.  
d1556 2
a1557 1
                  ::= sz        # sizeof 
d1562 1
a1562 1
demangle_operator_name (dm, short_name, num_args)
d1566 1
d1640 4
d1663 10
d3175 1
d3183 2
a3184 1
      RETURN_IF_ERROR (demangle_operator_name (dm, 1, &num_args));
d3205 4
a3208 1
      RETURN_IF_ERROR (demangle_expression (dm));
@


1.23.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a53 2
#include <ctype.h>

d901 1
a901 1
  PARAMS ((demangling_t, int, int *, int *));
d1328 1
a1328 1
      RETURN_IF_ERROR (demangle_operator_name (dm, 0, &num_args, NULL));
a1468 1
      int ch;
d1471 1
a1471 36
      ch = next_char (dm);

      /* Handle extended Unicode characters.  We encode them as __U{hex}_,
         where {hex} omits leading 0's.  For instance, '$' is encoded as
         "__U24_".  */
      if (ch == '_'
	  && peek_char (dm) == '_'
	  && peek_char_next (dm) == 'U')
	{
	  char buf[10];
	  int pos = 0;
	  advance_char (dm); advance_char (dm); length -= 2;
	  while (length-- > 0)
	    {
	      ch = next_char (dm);
	      if (!isxdigit (ch))
		break;
	      buf[pos++] = ch;
	    }
	  if (ch != '_' || length < 0)
	    return STATUS_ERROR;
	  if (pos == 0)
	    {
	      /* __U_ just means __U.  */
	      if (!dyn_string_append_cstr (identifier, "__U"))
		return STATUS_ALLOCATION_FAILED;
	      continue;
	    }
	  else
	    {
	      buf[pos] = '\0';
	      ch = strtol (buf, 0, 16);
	    }
	}

      if (!dyn_string_append_char (identifier, ch))
d1504 1
a1504 3
   operands that the operator takes.  If TYPE_ARG is non-NULL,
   *TYPE_ARG is set to 1 if the first argument is a type and 0
   otherwise.
d1554 1
a1554 2
		  ::= st        # sizeof (a type)
                  ::= sz        # sizeof (an expression)
d1559 1
a1559 1
demangle_operator_name (dm, short_name, num_args, type_arg)
a1562 1
     int *type_arg;
a1635 4
  /* Assume the first argument is not a type.  */
  if (type_arg)
    *type_arg = 0;

a1654 10
  /* Is it the sizeof variant that takes a type?  */
  if (c0 == 's' && c1 == 't')
    {
      RETURN_IF_ERROR (result_add (dm, " sizeof"));
      *num_args = 1;
      if (type_arg)
	*type_arg = 1;
      return STATUS_OK;
    }

a3156 1
      int type_arg;
d3164 1
a3164 2
      RETURN_IF_ERROR (demangle_operator_name (dm, 1, &num_args,
					       &type_arg));
d3185 1
a3185 4
      if (type_arg)
	RETURN_IF_ERROR (demangle_type (dm));
      else
	RETURN_IF_ERROR (demangle_expression (dm));
a3859 1
#ifndef IN_GLIBCPP_V3
d3897 1
@


1.23.6.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d838 2
a839 2
  dm->is_constructor = (enum gnu_v3_ctor_kinds) 0;
  dm->is_destructor = (enum gnu_v3_dtor_kinds) 0;
d977 1
a977 1
	error_message = (char *) strdup ("Expected ?");
d3977 1
a3977 1
    return (enum gnu_v3_ctor_kinds) 0;
d3999 1
a3999 1
    return (enum gnu_v3_dtor_kinds) 0;
@


1.22
log
@merge from gcc
@
text
@d3580 1
a3580 1
#ifdef IN_LIBGCC2
d3688 1
a3688 1
#else /* !IN_LIBGCC2 */
d3857 1
a3857 1
#endif /* IN_LIBGCC2 */
d3897 1
d3940 1
@


1.21
log
@merge from gcc
@
text
@d3849 5
a3853 1
  return_value = dyn_string_release (demangled);
@


1.20
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
d11 9
@


1.19
log
@merge from gcc
@
text
@a942 2
static char* cplus_demangle_v3_all
  PARAMS ((const char*, int));
d3688 1
a3688 1
cplus_demangle_v3 (mangled)
d3690 1
a3690 15
{
  return cplus_demangle_v3_all (mangled, 0);
}

char *
cplus_demangle_v3_type (mangled)
     const char* mangled;
{
  return cplus_demangle_v3_all (mangled, 1);
}

static char *
cplus_demangle_v3_all (mangled, type)
     const char* mangled;
     int type;
d3694 1
d3705 2
@


1.18
log
@merge from gcc
@
text
@a940 1
#ifdef IN_LIBGCC2
d943 2
a944 1
#endif
a3535 1
#ifdef IN_LIBGCC2
d3573 1
d3693 15
d3711 9
a3719 3
  /* If this isn't a mangled name, don't pretend to demangle it.  */
  if (strncmp (mangled, "_Z", 2) != 0)
    return NULL;
d3724 6
a3729 1
  status = cp_demangle ((char *) mangled, demangled, 0);
@


1.17
log
@merge from gcc
@
text
@d3543 1
a3543 1
  demangling_t dm = demangling_new (type_name);
@


1.16
log
@merge from gcc
@
text
@d941 1
d944 1
d3536 1
d3543 1
a3543 1
  demangling_t dm = demangling_new (type_name, 0);
a3573 1
#ifdef IN_LIBGCC2
d3696 4
d3703 1
a3703 6
  if (mangled[0] == '_' && mangled[1] == 'Z')
    /* Appears to be a function or variable name.  */
    status = cp_demangle (mangled, demangled, 0);
  else
    /* Try to demangle it as the name of a type.  */
    status = cp_demangle_type (mangled, demangled);
@


1.15
log
@merge from gcc
@
text
@a940 1
#ifdef IN_LIBGCC2
a942 1
#endif
a3533 1
#ifdef IN_LIBGCC2
d3540 1
a3540 1
  demangling_t dm = demangling_new (type_name);
d3571 1
a3693 4
  /* If this isn't a mangled name, don't pretend to demangle it.  */
  if (strncmp (mangled, "_Z", 2) != 0)
    return NULL;

d3697 6
a3702 1
  status = cp_demangle ((char *) mangled, demangled, 0);
@


1.14
log
@merge from gcc
@
text
@d3948 1
a3948 1
static struct option long_options[] = 
@


1.13
log
@merge from gcc
@
text
@d1560 1
a1560 1
    const char *code;
d1562 1
a1562 1
    const char *name;
d1564 1
a1564 1
    int num_args;
@


1.12
log
@merge from gcc
@
text
@d1845 1
a1845 1
      /* A guard variable name.  Consume the G.  */
d1847 19
a1865 3
      RETURN_IF_ERROR (demangle_char (dm, 'V'));
      RETURN_IF_ERROR (result_add (dm, "guard variable for "));
      RETURN_IF_ERROR (demangle_name (dm, &unused));
@


1.11
log
@merge from gcc
@
text
@d3822 2
a3823 1
demangle_v3_with_details (const char *name)
d3861 2
a3862 1
is_gnu_v3_mangled_ctor (const char *name)
d3883 2
a3884 1
is_gnu_v3_mangled_dtor (const char *name)
@


1.10
log
@* cp-demangle.c (string_list_delete): Don't forget to free the
actual contents of the string.
@
text
@d3449 1
a3449 1
	    RETURN_IF_ERROR (int_to_dyn_string (discriminator + 2, 
d3453 1
a3453 5
	{
	  if (flag_verbose)
	    /* A missing digit correspond to one.  */
	    RETURN_IF_ERROR (result_add_char (dm, '1'));
	}
@


1.9
log
@* libiberty/cp-demangle.c (struct demangling_def): New fields:
is_constructor and is_destructor.
(demangling_new): Initialize them.
(demangle_ctor_dtor_name): Set them, if we detect a constructor
or destructor.
(demangle_v3_with_details, is_gnu_v3_mangled_ctor,
is_gnu_v3_mangled_dtor): New functions.

* include/demangle.h (enum gnu_v3_constructor_kinds,
is_gnu_v3_mangled_ctor, enum gnu_v3_destructor_kinds,
is_gnu_v3_mangled_dtor): New declarations.
@
text
@d427 1
a427 1
      free (node);
@


1.8
log
@merge from gcc
@
text
@d175 9
d827 2
d2032 2
a2033 1
      if (peek_char (dm) < '1' || peek_char (dm) > '3')
d2036 9
a2045 1
      flavor = next_char (dm) - '1';
d2049 1
a2049 1
	  RETURN_IF_ERROR (result_add (dm, ctor_flavors[flavor]));
d2057 2
a2058 1
      if (peek_char (dm) < '0' || peek_char (dm) > '2')
d2062 9
a2071 1
      flavor = next_char (dm) - '0';
d2075 1
a2075 1
	  RETURN_IF_ERROR (result_add (dm, dtor_flavors[flavor]));
d3820 79
@


1.7
log
@* cp-demangle.c (cplus_demangle_v3): Check that it's a v3 mangled
name before allocating the dyn_string.
@
text
@d2 1
a2 1
   Copyright (C) 2000 Free Software Foundation, Inc.
d71 3
d172 3
d249 1
a249 1
  PARAMS ((const char *));
d792 1
a792 1
demangling_new (name)
d794 1
d817 1
d929 1
a929 1
  PARAMS ((const char *, dyn_string_t));
d1233 1
a1233 1
	    RETURN_IF_ERROR (result_add (dm, "::"));
d2104 4
a2107 2
	 necessarily go at the end.  */
      RETURN_IF_ERROR (result_insert_char (dm, *insert_pos, '*'));
d2482 33
d2557 6
a2562 1
      const char *type_name = builtin_type_names[code - 'a'];
d3446 1
a3446 1
cp_demangle (name, result)
d3449 1
d3456 1
a3456 1
      demangling_t dm = demangling_new (name);
d3603 1
a3603 1
    result = cp_demangle (mangled_name, &demangled_name);
d3662 1
a3662 1
  status = cp_demangle ((char *) mangled, demangled);
d3686 104
d3927 1
a3927 1
	  status = cp_demangle (dyn_string_buf (mangled), demangled);
d3966 1
a3966 1
	  status = cp_demangle (argv[i], result);
d3974 1
a3974 1
	      fprintf (stderr, "Memory allocaiton failed.\n");
@


1.6
log
@* cp-demangle.c: s/new_abi/v3/.
* cplus-dem.c: Likewise.
(current_demangling_style): Now auto_demangling.
(cplus_demangle): Try v3 demangling if AUTO_DEMANGLING.
(main): Use standard symbol chars for auto_demangling.
@
text
@d3603 7
d3611 1
a3611 1
  dyn_string_t demangled = dyn_string_new (0);
d3613 2
a3614 1
  status_t status = cp_demangle ((char *) mangled, demangled);
@


1.5
log
@[merge from gcc]
* cp-demangle.c (string_list_def): Add caret_position and comments.
(result_caret_pos): New macro.
(result_append_string): Rename to...
(result_add_string): ... this, and insert at caret position.
Rename throughout.
(result_append): Rename to...
(result_add): ... this, and insert at caret position.  Rename
throughout.
(result_append_char): Rename to...
(result_add_char): ... this, and insert at caret position.  Rename
throughout.
(result_append_space): Remove.
(string_list_new): Initialize caret position.
(result_add_separated_char): Use caret position.
(result_get_caret): New funtion.
(result_set_caret): Likewise.
(result_shift_caret): Likewise.
(result_previous_char_is_space): Likewise.
(substitution_start): Use caret position.
(substitution_add): Likewise.
(demangling_new): Initialize caret position.
(demangle_encoding): Use caret position.
(demanglin_nested_name): Put CV qualifiers after name.
(demangle_type_ptr): Use switch statement.  Handle pointers to
arrays.  Don't use result_append_space.  Use caret position.
(demangle_type): Emit CV qualifiers after underlying type.  Adjust
call to demangle_array_type.
(demangle_array_type): Add parameter to handle pointers to arrays.
@
text
@d1 1
a1 1
/* Demangler for IA64 / g++ standard C++ ABI.
d23 1
a23 1
   the IA64 / g++ standard C++ ABI.  Use the cp_demangle function to
d3486 1
a3486 1
/* ABI-mandated entry point in the C++ runtime library for performing
d3600 1
a3600 1
cplus_demangle_new_abi (mangled)
@


1.4
log
@merge from gcc repository
@
text
@d82 3
a84 3
/* String_list_t is an extended form of dyn_string_t which provides a link
   field.  A string_list_t may safely be cast to and used as a
   dyn_string_t.  */
d88 1
d90 8
d284 10
a293 3
/* Appends a dyn_string_t to the demangled result.  */
#define result_append_string(DM, STRING)                                \
  (dyn_string_append (&(DM)->result->string, (STRING))                  \
d296 4
a299 3
/* Appends NUL-terminated string CSTR to the demangled result.  */
#define result_append(DM, CSTR)                                         \
  (dyn_string_append_cstr (&(DM)->result->string, (CSTR))               \
d302 4
a305 3
/* Appends character CHAR to the demangled result.  */
#define result_append_char(DM, CHAR)                                    \
  (dyn_string_append_char (&(DM)->result->string, (CHAR))               \
a327 6
/* Appends a space to the demangled result if the last character is
   not a space.  */
#define result_append_space(DM)                                         \
  (dyn_string_append_space (&(DM)->result->string)                      \
   ? STATUS_OK : STATUS_ALLOCATION_FAILED)

d395 1
d425 2
a426 10
  dyn_string_t s = &dm->result->string;

  /* Add a space if the last character is already a closing angle
     bracket, so that a nested template arg list doesn't look like
     it's closed with a right-shift operator.  */
  if (dyn_string_last_char (s) == character)
    {
      if (!dyn_string_append_char (s, ' '))
	return STATUS_ALLOCATION_FAILED;
    }
d428 6
a433 3
  /* Add closing angle brackets.  */
  if (!dyn_string_append_char (s, character))
    return STATUS_ALLOCATION_FAILED;
d471 45
d524 1
a524 1
  return result_length (dm);
d547 1
a547 1
			     result, start_position, result_length (dm)))
d899 1
a899 1
  PARAMS ((demangling_t));
d989 1
a989 1
  start_position = result_length (dm);
d999 1
a999 1
	 maybe its return type, and its parameters types, following.  */
d1073 1
a1073 1
	  RETURN_IF_ERROR (result_append (dm, "std::"));
d1138 1
d1141 2
a1142 2
      /* Snarf up and emit CV qualifiers.  */
      dyn_string_t cv_qualifiers = dyn_string_new (24);
d1145 1
d1147 11
a1157 2
      demangle_CV_qualifiers (dm, cv_qualifiers);
      status = result_append_string (dm, cv_qualifiers);
a1159 1
      RETURN_IF_ERROR (result_append_space (dm));
d1161 1
a1161 1
  
d1225 1
a1225 1
	    RETURN_IF_ERROR (result_append (dm, "::"));
d1341 1
a1341 1
  RETURN_IF_ERROR (result_append_string (dm, dm->last_source_name));
d1613 1
a1613 1
      RETURN_IF_ERROR (result_append (dm, "operator "));
d1622 1
a1622 1
      RETURN_IF_ERROR (result_append (dm, "operator "));
d1640 2
a1641 2
	    RETURN_IF_ERROR (result_append (dm, "operator"));
	  RETURN_IF_ERROR (result_append (dm, p->name));
d1681 1
a1681 1
      status = result_append (dm, " [nv:");
d1683 1
a1683 1
	status = result_append_string (dm, number);
d1685 1
a1685 1
	status = result_append_char (dm, ']');
d1717 1
a1717 1
      status = result_append (dm, " [v:");
d1719 1
a1719 1
	status = result_append_string (dm, number);
d1721 1
a1721 1
	result_append_char (dm, ',');
d1738 1
a1738 1
      status = result_append_string (dm, number);
d1740 1
a1740 1
	status = result_append_char (dm, ']');
d1829 1
a1829 1
      RETURN_IF_ERROR (result_append (dm, "guard variable for "));
d1844 1
a1844 1
	  RETURN_IF_ERROR (result_append (dm, "vtable for "));
d1851 1
a1851 1
	  RETURN_IF_ERROR (result_append (dm, "VTT for "));
d1858 1
a1858 1
	  RETURN_IF_ERROR (result_append (dm, "typeinfo for "));
d1865 1
a1865 1
	  RETURN_IF_ERROR (result_append (dm, "typeinfo fn for "));
d1872 1
a1872 1
	  RETURN_IF_ERROR (result_append (dm, "typeinfo name for "));
d1879 1
a1879 1
	  RETURN_IF_ERROR (result_append (dm, "java Class for "));
d1886 1
a1886 1
	  RETURN_IF_ERROR (result_append (dm, "non-virtual thunk"));
d1891 1
a1891 1
	  RETURN_IF_ERROR (result_append (dm, " to "));
d1898 1
a1898 1
	  RETURN_IF_ERROR (result_append (dm, "virtual thunk"));
d1903 1
a1903 1
	  RETURN_IF_ERROR (result_append (dm, " to "));
d1910 1
a1910 1
	  RETURN_IF_ERROR (result_append (dm, "covariant return thunk"));
d1914 1
a1914 1
	  RETURN_IF_ERROR (result_append (dm, " to "));
d1925 1
a1925 1
	      RETURN_IF_ERROR (result_append (dm, "construction vtable for "));
d1949 1
a1949 1
		status = result_append (dm, "-in-");
d1951 1
a1951 1
		status = result_append_string (dm, derived_type);
d1957 1
a1957 1
		  status = result_append_char (dm, ' ');
d1959 1
a1959 1
		    result_append_string (dm, number);
d2015 1
a2015 1
      RETURN_IF_ERROR (result_append_string (dm, dm->last_source_name));
d2020 3
a2022 3
	  RETURN_IF_ERROR (result_append (dm, "["));
	  RETURN_IF_ERROR (result_append (dm, ctor_flavors[flavor]));
	  RETURN_IF_ERROR (result_append_char (dm, ']'));
d2031 2
a2032 2
      RETURN_IF_ERROR (result_append_char (dm, '~'));
      RETURN_IF_ERROR (result_append_string (dm, dm->last_source_name));
d2037 3
a2039 3
	  RETURN_IF_ERROR (result_append (dm, " ["));
	  RETURN_IF_ERROR (result_append (dm, dtor_flavors[flavor]));
	  RETURN_IF_ERROR (result_append_char (dm, ']'));
a2079 1
  char next;
d2087 1
a2087 2
  next = peek_char (dm);
  if (next == 'P')
d2089 1
d2101 3
a2103 3
    }
  else if (next == 'R')
    {
d2115 3
a2117 2
    }
  else if (next == 'M')
d2137 6
d2149 3
a2151 2
	  if (STATUS_NO_ERROR (status))
	    status = result_append_space (dm);
d2154 1
a2154 1
	  *insert_pos = result_length (dm);
d2173 3
a2175 2
  else if (next == 'F')
    {
d2179 1
a2179 1
      *insert_pos = result_length (dm);
d2182 1
a2182 1
      RETURN_IF_ERROR (result_append (dm, "()"));
d2194 9
a2202 3
    }
  else
    {
d2209 1
a2209 1
      *insert_pos = result_length (dm);
d2214 1
d2282 1
d2287 1
d2289 10
d2300 3
a2302 19
	  /* If the qualifiers apply to a pointer or reference, they
	     need to come after the whole qualified type.  */
	  if (peek_char (dm) == 'P' || peek_char (dm) == 'R')
	    {
	      status = demangle_type (dm);
	      if (STATUS_NO_ERROR (status))
		status = result_append_space (dm);
	      if (STATUS_NO_ERROR (status))
		status = result_append_string (dm, cv_qualifiers);
	    }
	  /* Otherwise, the qualifiers come first.  */
	  else
	    {
	      status = result_append_string (dm, cv_qualifiers);
	      if (STATUS_NO_ERROR (status))
		status = result_append_space (dm);
	      if (STATUS_NO_ERROR (status))
		status = demangle_type (dm);
	    }
d2304 2
a2305 2
	  dyn_string_delete (cv_qualifiers);
	  RETURN_IF_ERROR (status);
d2313 1
a2313 1
	RETURN_IF_ERROR (demangle_array_type (dm));
d2402 1
a2402 1
	RETURN_IF_ERROR (result_append (dm, "complex "));
d2409 1
a2409 1
	RETURN_IF_ERROR (result_append (dm, "imaginary "));
d2418 1
a2418 1
	RETURN_IF_ERROR (result_append_char (dm, ' '));
d2518 1
a2518 1
      RETURN_IF_ERROR (result_append (dm, type_name));
d2589 1
a2589 1
	RETURN_IF_ERROR (result_append (dm, " [extern \"C\"] "));
d2616 1
a2616 1
  RETURN_IF_ERROR (result_append_char (dm, '('));
d2658 1
a2658 1
		RETURN_IF_ERROR (result_append (dm, ", "));
d2666 1
a2666 1
  RETURN_IF_ERROR (result_append_char (dm, ')'));
d2697 12
d2713 1
a2713 1
demangle_array_type (dm)
d2715 1
d2721 2
d2756 11
d2769 1
a2769 1
    status = result_append_char (dm, '[');
d2771 1
a2771 1
    status = result_append_string (dm, array_size);
d2773 1
a2773 1
    status = result_append_char (dm, ']');
d2817 1
a2817 1
  RETURN_IF_ERROR (result_append_string (dm, (dyn_string_t) arg));
d2855 1
a2855 1
	RETURN_IF_ERROR (result_append (dm, ", "));
d2863 1
a2863 1
      RETURN_IF_ERROR (result_append_string (dm, (dyn_string_t) arg));
d2939 1
a2939 1
	    RETURN_IF_ERROR (result_append (dm, "false"));
d2941 1
a2941 1
	    RETURN_IF_ERROR (result_append (dm, "true"));
d2959 1
a2959 1
	    status = result_append_string (dm, value_string);
d2962 1
a2962 1
	    status = result_append_char (dm, code);
d2972 1
a2972 1
  RETURN_IF_ERROR (result_append_char (dm, '('));
d2974 1
a2974 1
  RETURN_IF_ERROR (result_append_char (dm, ')'));
d2982 1
a2982 1
    status = result_append_string (dm, value_string);
d3070 1
a3070 1
	  status = result_append_char (dm, '(');
d3074 1
a3074 1
	    status = result_append_char (dm, ')');
d3079 1
a3079 1
	status = result_append_string (dm, operator_name);
d3084 1
a3084 1
      RETURN_IF_ERROR (result_append_char (dm, '('));
d3086 1
a3086 1
      RETURN_IF_ERROR (result_append_char (dm, ')'));
d3091 1
a3091 1
	  RETURN_IF_ERROR (result_append (dm, ":("));
d3093 1
a3093 1
	  RETURN_IF_ERROR (result_append_char (dm, ')'));
d3112 1
a3112 1
  RETURN_IF_ERROR (result_append (dm, "::"));
d3203 1
a3203 1
	  RETURN_IF_ERROR (result_append (dm, "std"));
d3207 1
a3207 1
	  RETURN_IF_ERROR (result_append (dm, "std::allocator"));
d3213 1
a3213 1
	  RETURN_IF_ERROR (result_append (dm, "std::basic_string"));
d3221 1
a3221 1
	      RETURN_IF_ERROR (result_append (dm, "std::string"));
d3226 1
a3226 1
	      RETURN_IF_ERROR (result_append (dm, "std::basic_string<char, std::char_traits<char>, std::allocator<char> >"));
d3235 1
a3235 1
	      RETURN_IF_ERROR (result_append (dm, "std::istream"));
d3240 1
a3240 1
	      RETURN_IF_ERROR (result_append (dm, "std::basic_istream<char, std::char_traints<char> >"));
d3249 1
a3249 1
	      RETURN_IF_ERROR (result_append (dm, "std::ostream"));
d3254 1
a3254 1
	      RETURN_IF_ERROR (result_append (dm, "std::basic_ostream<char, std::char_traits<char> >"));
d3263 1
a3263 1
	      RETURN_IF_ERROR (result_append (dm, "std::iostream"));
d3268 1
a3268 1
	      RETURN_IF_ERROR (result_append (dm, "std::basic_iostream<char, std::char_traits<char> >"));
d3299 1
a3299 1
  RETURN_IF_ERROR (result_append_string (dm, text));
d3319 1
a3319 1
  RETURN_IF_ERROR (result_append (dm, "::"));
d3324 1
a3324 1
      RETURN_IF_ERROR (result_append (dm, "string literal"));
d3361 1
a3361 1
	RETURN_IF_ERROR (result_append (dm, " [#"));
d3379 1
a3379 1
	    RETURN_IF_ERROR (result_append_char (dm, '1'));
d3382 1
a3382 1
	RETURN_IF_ERROR (result_append_char (dm, ']'));
d3387 1
a3387 1
	RETURN_IF_ERROR (result_append (dm, " [#0]"));
@


1.4.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright (C) 2000 CodeSourcery LLC.
d5 2
d26 2
a27 1
   executable.  */
d67 4
a100 5
  /* The template parameter that this represents, indexed from zero.
     If this is not a template paramter number, the value is
     NOT_TEMPLATE_PARM.  */
  int template_parm_number;

a104 2
#define NOT_TEMPLATE_PARM (-1)

d175 1
a175 1
static const char* const status_allocation_failed = "Allocation failed.";
d199 2
a200 2
static status_t result_close_template_list 
  PARAMS ((demangling_t));
d208 1
a208 1
  PARAMS ((demangling_t, int, int, int));
d290 16
d316 7
d404 2
a405 4
/* Appends a greater-than character to the demangled result.  If the
   last character is a greater-than character, a space is inserted
   first, so that the two greater-than characters don't look like a
   right shift token.  */
d408 1
a408 1
result_close_template_list (dm)
d410 1
d417 1
a417 1
  if (dyn_string_last_char (s) == '>')
d424 1
a424 1
  if (!dyn_string_append_char (s, '>'))
d476 1
a476 6
   non-zero, this potential substitution is a template-id.  

   If TEMPLATE_PARM_NUMBER is not NOT_TEMPLATE_PARM, the substitution
   is for that particular <template-param>, and is distinct from other
   otherwise-identical types and other <template-param>s with
   different indices.  */
d479 1
a479 1
substitution_add (dm, start_position, template_p, template_parm_number)
a482 1
     int template_parm_number;
a499 12
  /* Check whether SUBSTITUTION already occurs.  */
  for (i = 0; i < dm->num_substitutions; ++i)
    if (dyn_string_eq (dm->substitutions[i].text, substitution)
	&& dm->substitutions[i].template_parm_number == template_parm_number)
      /* Found SUBSTITUTION already present.  */
      {
	/* Callers expect this function to take ownership of
	   SUBSTITUTION, so delete it.  */
	dyn_string_delete (substitution);
	return STATUS_OK;
      }

d504 4
a507 1
      dm->substitutions_allocated *= 2;
d522 1
a524 2
  dm->substitutions[i].template_parm_number = template_parm_number;
  ++dm->num_substitutions;
d810 1
a810 1
  PARAMS ((demangling_t));
d821 6
d832 1
a832 1
  PARAMS ((demangling_t));
d840 1
a840 1
  PARAMS ((demangling_t, int));
d842 1
a842 1
  PARAMS ((demangling_t, int));
d848 1
a848 1
  PARAMS ((demangling_t, int *));
d862 1
a862 1
  PARAMS ((demangling_t, int *, int *));
d869 1
d872 1
d876 1
a876 1
#define BFT_NO_RETURN_TYPE    -1
d927 1
a927 1
  int template_p;
d943 1
a943 1
      RETURN_IF_ERROR (demangle_name (dm, &template_p));
d950 1
a950 1
	  if (template_p)
d954 1
a954 1
	      (demangle_bare_function_type (dm, start_position));
d985 1
a985 1
demangle_name (dm, template_p)
d987 1
a987 1
     int *template_p;
a988 1
  int special_std_substitution;
d990 8
d1001 1
a1001 1
  switch (peek_char (dm))
d1005 1
a1005 1
      RETURN_IF_ERROR (demangle_nested_name (dm, template_p));
d1010 1
d1021 3
a1023 1
	  RETURN_IF_ERROR (demangle_unqualified_name (dm));
d1026 1
a1026 12
	{
	  RETURN_IF_ERROR (demangle_substitution (dm, template_p,
						  &special_std_substitution));
	  if (special_std_substitution)
	    {
	      /* This was the magic `std::' substitution.  We can have
		 a <nested-name> or one of the unscoped names
		 following.  */
	      RETURN_IF_ERROR (result_append (dm, "::"));
	      RETURN_IF_ERROR (demangle_name (dm, template_p));
	    }
	}
d1031 5
a1035 2
	  RETURN_IF_ERROR (substitution_add (dm, start, 0, 
					     NOT_TEMPLATE_PARM));
d1037 1
d1039 3
d1046 1
a1046 1
      RETURN_IF_ERROR (demangle_unqualified_name (dm));
d1053 1
a1053 2
	  RETURN_IF_ERROR (substitution_add (dm, start, 0, 
					     NOT_TEMPLATE_PARM));
d1056 1
a1056 1
	  *template_p = 1;
d1059 1
a1059 1
	*template_p = 0;
d1069 1
a1069 1
    <nested-name>       ::= N [<CV-qualifiers>] <prefix> <component> E  */
d1072 1
a1072 1
demangle_nested_name (dm, template_p)
d1074 1
a1074 1
     int *template_p;
d1099 3
a1101 3
  RETURN_IF_ERROR (demangle_prefix (dm, template_p));
  /* No need to demangle the final <component>; demangle_prefix will
     handle it.  */
d1109 1
a1109 1
    <prefix>            ::= <prefix> <component>
d1115 1
a1115 4
                        ::= <substitution>

    <component>         ::= <unqualified-name>
                        ::= <local-name>  */
d1118 1
a1118 1
demangle_prefix (dm, template_p)
d1120 1
a1120 1
     int *template_p;
d1125 9
a1133 3
  /* TEMPLATE_P is updated as we decend the nesting chain.  After
     <template-args>, it is set to non-zero; after everything else it
     is set to zero.  */
a1139 1
      int unused;
d1146 9
d1168 2
a1169 3
	       template-id.   */
	    RETURN_IF_ERROR (demangle_substitution (dm, template_p, 
						    &unused));
d1172 4
a1175 2
	      RETURN_IF_ERROR (demangle_unqualified_name (dm));
	      *template_p = 0;
a1181 4
	  if (*template_p)
	    return STATUS_INTERNAL_ERROR;
	  /* The template name is a substitution candidate.  */
	  RETURN_IF_ERROR (substitution_add (dm, start, 0, NOT_TEMPLATE_PARM));
d1183 9
a1191 1
	  *template_p = 1;
d1199 4
a1202 3
      /* Add a new substitution for the prefix thus far.  */
      RETURN_IF_ERROR (substitution_add (dm, start, *template_p, 
					 NOT_TEMPLATE_PARM));
d1206 5
a1210 4
/* Demangles and emits an <unqualified-name>.  If the
   <unqualified-name> is a function and the first element in the
   argument list should be taken to be its return type,
   ENCODE_RETURN_TYPE is non-zero.
d1217 1
a1217 1
demangle_unqualified_name (dm)
d1219 1
d1225 4
d1234 5
d1242 7
a1248 1
    RETURN_IF_ERROR (demangle_ctor_dtor_name (dm));
d1386 23
d1467 1
a1467 1
                  ::= vx <source-name>  # vendor extended operator  */
d1528 1
d1547 2
a1548 2
  /* Is this a vendor extended operator?  */
  if (c0 == 'v' && c1 == 'x')
d1550 1
a1550 1
      RETURN_IF_ERROR (result_append (dm, "operator"));
d1596 125
a1723 5
                   ::= Th[n] <offset number> _ <base name> <base encoding>
                                          # non-virtual base override thunk
                   ::= Tv[n] <offset number> _ <vcall offset number> 
                         _ <base encoding>
                                          # virtual base override thunk
d1729 15
d1746 1
a1746 1
    <special-name> ::= CT <type> <offset number> _ <base type>
d1824 1
a1824 14
	  /* Demangle and emit the offset.  */
	  number = dyn_string_new (4);
	  if (number == NULL)
	    return STATUS_ALLOCATION_FAILED;
	  demangle_number_literally (dm, number, 10, 1);
	  /* Don't display the offset unless in verbose mode.  */
	  if (flag_verbose)
	    {
	      status = result_append_char (dm, ' ');
	      if (STATUS_NO_ERROR (status))
		status = result_append_string (dm, number);
	    }
	  dyn_string_delete (number);
	  RETURN_IF_ERROR (status);
d1835 2
a1836 31
	  RETURN_IF_ERROR (result_append (dm, "virtual thunk "));
	  /* Demangle and emit the offset.  */
	  number = dyn_string_new (4);
	  if (number == NULL)
	    return STATUS_ALLOCATION_FAILED;
	  demangle_number_literally (dm, number, 10, 1);
	  /* Don't display the offset unless in verbose mode.  */
	  if (flag_verbose)
	    {
	      status = result_append_string (dm, number);
	      if (STATUS_NO_ERROR (status))
		result_append_char (dm, ' ');
	    }
	  dyn_string_delete (number);
	  RETURN_IF_ERROR (status);
	  /* Demangle the separator.  */
	  RETURN_IF_ERROR (demangle_char (dm, '_'));
	  /* Demangle and emit the vcall offset.  */
	  number = dyn_string_new (4);
	  if (number == NULL)
	    return STATUS_ALLOCATION_FAILED;
	  demangle_number_literally (dm, number, 10, 1);
	  /* Don't display the vcall offset unless in verbose mode.  */
	  if (flag_verbose)
	    {
	      status = result_append_string (dm, number);
	      if (STATUS_NO_ERROR (status))
		status = result_append_char (dm, ' ');
	    }
	  dyn_string_delete (number);
	  RETURN_IF_ERROR (status);
d1840 12
a1851 1
	  RETURN_IF_ERROR (result_append (dm, "to "));
a1919 1
                   ::= C4  # base object (not-in-charge) allocating ctor
d1932 1
a1932 2
    "in-charge allocating",
    "not-in-charge allocating"
d1950 1
a1950 1
      if (peek_char (dm) < '1' || peek_char (dm) > '4')
d1992 13
d2012 1
a2012 1
demangle_type_ptr (dm)
d2014 2
d2019 1
a2019 3

  /* Collect pointer symbols into this string.  */
  dyn_string_t symbols = dyn_string_new (10);
a2022 3
  if (symbols == NULL)
    return STATUS_ALLOCATION_FAILED;

d2025 30
a2054 1
  while (1)
d2056 22
a2077 38
      next = peek_char (dm);
      if (next == 'P')
	{
	  if (!dyn_string_append_char (symbols, '*'))
	    return STATUS_ALLOCATION_FAILED;
	  advance_char (dm);
	}
      else if (next == 'R')
	{
	  if (!dyn_string_append_char (symbols, '&'))
	    return STATUS_ALLOCATION_FAILED;
	  advance_char (dm);
	}
      else if (next == 'M')
	{
	  /* Pointer-to-member.  */
	  dyn_string_t class_type;

	  /* Eat the 'M'.  */
	  advance_char (dm);

	  /* Capture the type of which this is a pointer-to-member.  */
	  RETURN_IF_ERROR (result_push (dm));
	  RETURN_IF_ERROR (demangle_type (dm));
	  class_type = (dyn_string_t) result_pop (dm);

	  /* Build the pointer-to-member notation.  It comes before
	     other pointer and reference qualifiers -- */
	  if (!dyn_string_prepend_cstr (symbols, "::*"))
	    return STATUS_ALLOCATION_FAILED;
	  if (!dyn_string_prepend (symbols, class_type))
	    return STATUS_ALLOCATION_FAILED;
	  dyn_string_delete (class_type);

	  if (peek_char (dm) == 'F')
	    continue;

	  /* Demangle the type of the pointed-to member.  */
d2082 3
a2084 9
	  /* Add the pointer-to-member syntax, and other pointer and
	     reference symbols.  */
	  if (STATUS_NO_ERROR (status))
	    status = result_append_string (dm, symbols);
	  /* Clean up.  */
	  dyn_string_delete (symbols);

	  RETURN_IF_ERROR (status);
	  return STATUS_OK;
a2085 11
      else if (next == 'F')
	{
	  /* Ooh, tricky, a pointer-to-function.  */
	  int position = result_length (dm);
	  status = result_append_char (dm, '(');
	  if (STATUS_NO_ERROR (status))
	    status = result_append_string (dm, symbols);
	  if (STATUS_NO_ERROR (status))
	    status = result_append_char (dm, ')');
	  dyn_string_delete (symbols);
	  RETURN_IF_ERROR (status);
d2087 10
a2096 7
	  RETURN_IF_ERROR (demangle_function_type (dm, position));
	  return STATUS_OK;
	}
      else
	{
	  /* No more pointe or reference tokens.  Finish up.  */
	  status = demangle_type (dm);
d2098 2
a2099 4
	  if (STATUS_NO_ERROR (status))
	    status = result_append_string (dm, symbols);
	  dyn_string_delete (symbols);
	  RETURN_IF_ERROR (status);
d2101 36
a2136 3
	  RETURN_IF_ERROR (status);
	  return STATUS_OK;
	}
d2138 5
d2153 1
d2169 1
a2169 3
  int template_p = 0;
  int special_std_substitution;
  int is_builtin_type = 0;
d2171 6
a2176 1
  int template_parm = NOT_TEMPLATE_PARM;
d2183 4
a2186 2
    RETURN_IF_ERROR (demangle_class_enum_type (dm, &template_p));
  else if (peek >= 'a' && peek <= 'z')
d2189 2
a2190 1
      is_builtin_type = 1;
d2198 3
d2243 22
a2264 1
	RETURN_IF_ERROR (demangle_template_param (dm, &template_parm));
d2274 14
a2287 2
	  RETURN_IF_ERROR (demangle_substitution (dm, &template_p,
						  &special_std_substitution));
d2289 26
a2314 1
	  demangle_class_enum_type (dm, &template_p);
d2320 4
a2323 1
	RETURN_IF_ERROR (demangle_type_ptr (dm));
d2341 1
a2341 1
	/* Vendor extended type qualifier.  */
d2352 1
a2352 2
  /* Unqualified builin types are not substitution candidates.  */
  if (!is_builtin_type)
d2355 1
a2355 1
       substitutions, a <template-param> token is a substitution
d2357 1
a2357 1
    RETURN_IF_ERROR (substitution_add (dm, start, template_p, template_parm));
d2496 1
a2496 1
/* Demangles and emits a <function-type> FUNCTION_NAME_POS is the
d2498 3
a2500 1
   identifier, at which the function's return type will be inserted.  
d2507 1
a2507 1
     int function_name_pos;
d2533 1
a2533 1
     int return_type_pos;
d2558 1
a2558 3
	  if (!dyn_string_append_space (return_type) 
	      || !dyn_string_insert (result_string (dm), return_type_pos, 
				     return_type))
d2560 8
d2578 3
d2582 5
a2586 3
	      /* Consume the v.  */
	      advance_char (dm);
	      continue;
a2587 5
	  /* Separate parameter types by commas.  */
	  if (sequence > 0)
	    RETURN_IF_ERROR (result_append (dm, ", "));
	  /* Demangle the type.  */
	  RETURN_IF_ERROR (demangle_type (dm));
d2594 8
d2605 1
a2605 1
/* Demangles and emits a <class-enum-type>.  *TEMPLATE_P is set to
d2611 1
a2611 1
demangle_class_enum_type (dm, template_p)
d2613 1
a2613 1
     int *template_p;
d2617 1
a2617 1
  RETURN_IF_ERROR (demangle_name (dm, template_p));
d2623 2
a2624 1
    <array-type> ::= A [<dimension number>] _ <element type>  */
d2630 3
a2632 5
  status_t status;
  dyn_string_t array_size = dyn_string_new (10);

  if (array_size == NULL)
    return STATUS_ALLOCATION_FAILED;
d2634 1
a2634 1
  status = demangle_char (dm, 'A');
d2637 23
a2659 2
  if (STATUS_NO_ERROR (status))
    status = demangle_number_literally (dm, array_size, 10, 0);
d2670 1
a2670 1
  if (STATUS_NO_ERROR (status))
d2674 2
a2675 1
  dyn_string_delete (array_size);
d2682 1
a2682 2
/* Demangles and emits a <template-param>.  The zero-indexed position
   in the parameter list is placed in *TEMPLATE_PARM_NUMBER.  
d2688 1
a2688 1
demangle_template_param (dm, template_parm_number)
a2689 1
     int *template_parm_number;
a2718 4
  if (peek_char (dm) == 'I')
    RETURN_IF_ERROR (demangle_template_args (dm));

  *template_parm_number = parm_number;
d2747 1
a2747 1
  RETURN_IF_ERROR (result_append_char (dm, '<'));
d2923 1
a3027 1
  int unused;
d3032 1
a3032 1
    RETURN_IF_ERROR (demangle_template_param (dm, &unused));
d3053 1
a3053 4
   if the substitution is the name of a template, zero otherwise.  If
   the substitution token is St, which corresponds to the `::std::'
   namespace and can appear in a non-nested name, sets
   *SPECIAL_STD_SUBSTITUTION to non-zero; zero otherwise.  
d3069 1
a3069 1
                                                     std::char_traits<char> >
d3073 1
a3073 1
demangle_substitution (dm, template_p, special_std_substitution)
a3075 1
     int *special_std_substitution;
a3083 1
  *special_std_substitution = 0;
a3103 1
	  *special_std_substitution = 1;
d3219 1
a3219 1
  RETURN_IF_ERROR (result_append (dm, "'s "));
a3231 1
      RETURN_IF_ERROR (result_append (dm, "local "));
d3254 1
a3254 1
     supressed if not in verbose mode.  */
d3346 1
a3383 3

#ifdef IN_LIBGCC2

d3540 2
a3541 1
  (IS_ALPHA (CHAR) || IS_DIGIT (CHAR) || (CHAR) == '_')
d3554 1
a3554 1
  fprintf (fp, "Options:\n", program_name);
@


1.3
log
@
        * cp-demangle.c, mkstemps.c: #include <sys/types.h>.
@
text
@d2 1
a2 1
   Copyright (C) 2000 CodeSourcery LLC.
d5 2
d26 2
a27 1
   executable.  */
d67 4
a100 5
  /* The template parameter that this represents, indexed from zero.
     If this is not a template paramter number, the value is
     NOT_TEMPLATE_PARM.  */
  int template_parm_number;

a104 2
#define NOT_TEMPLATE_PARM (-1)

d175 1
a175 1
static const char* const status_allocation_failed = "Allocation failed.";
d199 2
a200 2
static status_t result_close_template_list 
  PARAMS ((demangling_t));
d208 1
a208 1
  PARAMS ((demangling_t, int, int, int));
d290 16
d316 7
d404 2
a405 4
/* Appends a greater-than character to the demangled result.  If the
   last character is a greater-than character, a space is inserted
   first, so that the two greater-than characters don't look like a
   right shift token.  */
d408 1
a408 1
result_close_template_list (dm)
d410 1
d417 1
a417 1
  if (dyn_string_last_char (s) == '>')
d424 1
a424 1
  if (!dyn_string_append_char (s, '>'))
d476 1
a476 6
   non-zero, this potential substitution is a template-id.  

   If TEMPLATE_PARM_NUMBER is not NOT_TEMPLATE_PARM, the substitution
   is for that particular <template-param>, and is distinct from other
   otherwise-identical types and other <template-param>s with
   different indices.  */
d479 1
a479 1
substitution_add (dm, start_position, template_p, template_parm_number)
a482 1
     int template_parm_number;
a499 12
  /* Check whether SUBSTITUTION already occurs.  */
  for (i = 0; i < dm->num_substitutions; ++i)
    if (dyn_string_eq (dm->substitutions[i].text, substitution)
	&& dm->substitutions[i].template_parm_number == template_parm_number)
      /* Found SUBSTITUTION already present.  */
      {
	/* Callers expect this function to take ownership of
	   SUBSTITUTION, so delete it.  */
	dyn_string_delete (substitution);
	return STATUS_OK;
      }

d504 4
a507 1
      dm->substitutions_allocated *= 2;
d522 1
a524 2
  dm->substitutions[i].template_parm_number = template_parm_number;
  ++dm->num_substitutions;
d810 1
a810 1
  PARAMS ((demangling_t));
d821 6
d832 1
a832 1
  PARAMS ((demangling_t));
d840 1
a840 1
  PARAMS ((demangling_t, int));
d842 1
a842 1
  PARAMS ((demangling_t, int));
d848 1
a848 1
  PARAMS ((demangling_t, int *));
d862 1
a862 1
  PARAMS ((demangling_t, int *, int *));
d869 1
d872 1
d876 1
a876 1
#define BFT_NO_RETURN_TYPE    -1
d927 1
a927 1
  int template_p;
d943 1
a943 1
      RETURN_IF_ERROR (demangle_name (dm, &template_p));
d950 1
a950 1
	  if (template_p)
d954 1
a954 1
	      (demangle_bare_function_type (dm, start_position));
d985 1
a985 1
demangle_name (dm, template_p)
d987 1
a987 1
     int *template_p;
a988 1
  int special_std_substitution;
d990 8
d1001 1
a1001 1
  switch (peek_char (dm))
d1005 1
a1005 1
      RETURN_IF_ERROR (demangle_nested_name (dm, template_p));
d1010 1
d1021 3
a1023 1
	  RETURN_IF_ERROR (demangle_unqualified_name (dm));
d1026 1
a1026 12
	{
	  RETURN_IF_ERROR (demangle_substitution (dm, template_p,
						  &special_std_substitution));
	  if (special_std_substitution)
	    {
	      /* This was the magic `std::' substitution.  We can have
		 a <nested-name> or one of the unscoped names
		 following.  */
	      RETURN_IF_ERROR (result_append (dm, "::"));
	      RETURN_IF_ERROR (demangle_name (dm, template_p));
	    }
	}
d1031 5
a1035 2
	  RETURN_IF_ERROR (substitution_add (dm, start, 0, 
					     NOT_TEMPLATE_PARM));
d1037 1
d1039 3
d1046 1
a1046 1
      RETURN_IF_ERROR (demangle_unqualified_name (dm));
d1053 1
a1053 2
	  RETURN_IF_ERROR (substitution_add (dm, start, 0, 
					     NOT_TEMPLATE_PARM));
d1056 1
a1056 1
	  *template_p = 1;
d1059 1
a1059 1
	*template_p = 0;
d1069 1
a1069 1
    <nested-name>       ::= N [<CV-qualifiers>] <prefix> <component> E  */
d1072 1
a1072 1
demangle_nested_name (dm, template_p)
d1074 1
a1074 1
     int *template_p;
d1099 3
a1101 3
  RETURN_IF_ERROR (demangle_prefix (dm, template_p));
  /* No need to demangle the final <component>; demangle_prefix will
     handle it.  */
d1109 1
a1109 1
    <prefix>            ::= <prefix> <component>
d1115 1
a1115 4
                        ::= <substitution>

    <component>         ::= <unqualified-name>
                        ::= <local-name>  */
d1118 1
a1118 1
demangle_prefix (dm, template_p)
d1120 1
a1120 1
     int *template_p;
d1125 9
a1133 3
  /* TEMPLATE_P is updated as we decend the nesting chain.  After
     <template-args>, it is set to non-zero; after everything else it
     is set to zero.  */
a1139 1
      int unused;
d1146 9
d1168 2
a1169 3
	       template-id.   */
	    RETURN_IF_ERROR (demangle_substitution (dm, template_p, 
						    &unused));
d1172 4
a1175 2
	      RETURN_IF_ERROR (demangle_unqualified_name (dm));
	      *template_p = 0;
a1181 4
	  if (*template_p)
	    return STATUS_INTERNAL_ERROR;
	  /* The template name is a substitution candidate.  */
	  RETURN_IF_ERROR (substitution_add (dm, start, 0, NOT_TEMPLATE_PARM));
d1183 9
a1191 1
	  *template_p = 1;
d1199 4
a1202 3
      /* Add a new substitution for the prefix thus far.  */
      RETURN_IF_ERROR (substitution_add (dm, start, *template_p, 
					 NOT_TEMPLATE_PARM));
d1206 5
a1210 4
/* Demangles and emits an <unqualified-name>.  If the
   <unqualified-name> is a function and the first element in the
   argument list should be taken to be its return type,
   ENCODE_RETURN_TYPE is non-zero.
d1217 1
a1217 1
demangle_unqualified_name (dm)
d1219 1
d1225 4
d1234 5
d1242 7
a1248 1
    RETURN_IF_ERROR (demangle_ctor_dtor_name (dm));
d1386 23
d1467 1
a1467 1
                  ::= vx <source-name>  # vendor extended operator  */
d1528 1
d1547 2
a1548 2
  /* Is this a vendor extended operator?  */
  if (c0 == 'v' && c1 == 'x')
d1550 1
a1550 1
      RETURN_IF_ERROR (result_append (dm, "operator"));
d1596 125
a1723 5
                   ::= Th[n] <offset number> _ <base name> <base encoding>
                                          # non-virtual base override thunk
                   ::= Tv[n] <offset number> _ <vcall offset number> 
                         _ <base encoding>
                                          # virtual base override thunk
d1729 15
d1746 1
a1746 1
    <special-name> ::= CT <type> <offset number> _ <base type>
d1824 1
a1824 14
	  /* Demangle and emit the offset.  */
	  number = dyn_string_new (4);
	  if (number == NULL)
	    return STATUS_ALLOCATION_FAILED;
	  demangle_number_literally (dm, number, 10, 1);
	  /* Don't display the offset unless in verbose mode.  */
	  if (flag_verbose)
	    {
	      status = result_append_char (dm, ' ');
	      if (STATUS_NO_ERROR (status))
		status = result_append_string (dm, number);
	    }
	  dyn_string_delete (number);
	  RETURN_IF_ERROR (status);
d1835 2
a1836 31
	  RETURN_IF_ERROR (result_append (dm, "virtual thunk "));
	  /* Demangle and emit the offset.  */
	  number = dyn_string_new (4);
	  if (number == NULL)
	    return STATUS_ALLOCATION_FAILED;
	  demangle_number_literally (dm, number, 10, 1);
	  /* Don't display the offset unless in verbose mode.  */
	  if (flag_verbose)
	    {
	      status = result_append_string (dm, number);
	      if (STATUS_NO_ERROR (status))
		result_append_char (dm, ' ');
	    }
	  dyn_string_delete (number);
	  RETURN_IF_ERROR (status);
	  /* Demangle the separator.  */
	  RETURN_IF_ERROR (demangle_char (dm, '_'));
	  /* Demangle and emit the vcall offset.  */
	  number = dyn_string_new (4);
	  if (number == NULL)
	    return STATUS_ALLOCATION_FAILED;
	  demangle_number_literally (dm, number, 10, 1);
	  /* Don't display the vcall offset unless in verbose mode.  */
	  if (flag_verbose)
	    {
	      status = result_append_string (dm, number);
	      if (STATUS_NO_ERROR (status))
		status = result_append_char (dm, ' ');
	    }
	  dyn_string_delete (number);
	  RETURN_IF_ERROR (status);
d1840 12
a1851 1
	  RETURN_IF_ERROR (result_append (dm, "to "));
a1919 1
                   ::= C4  # base object (not-in-charge) allocating ctor
d1932 1
a1932 2
    "in-charge allocating",
    "not-in-charge allocating"
d1950 1
a1950 1
      if (peek_char (dm) < '1' || peek_char (dm) > '4')
d1992 13
d2012 1
a2012 1
demangle_type_ptr (dm)
d2014 2
d2019 1
a2019 3

  /* Collect pointer symbols into this string.  */
  dyn_string_t symbols = dyn_string_new (10);
a2022 3
  if (symbols == NULL)
    return STATUS_ALLOCATION_FAILED;

d2025 30
a2054 1
  while (1)
d2056 22
a2077 38
      next = peek_char (dm);
      if (next == 'P')
	{
	  if (!dyn_string_append_char (symbols, '*'))
	    return STATUS_ALLOCATION_FAILED;
	  advance_char (dm);
	}
      else if (next == 'R')
	{
	  if (!dyn_string_append_char (symbols, '&'))
	    return STATUS_ALLOCATION_FAILED;
	  advance_char (dm);
	}
      else if (next == 'M')
	{
	  /* Pointer-to-member.  */
	  dyn_string_t class_type;

	  /* Eat the 'M'.  */
	  advance_char (dm);

	  /* Capture the type of which this is a pointer-to-member.  */
	  RETURN_IF_ERROR (result_push (dm));
	  RETURN_IF_ERROR (demangle_type (dm));
	  class_type = (dyn_string_t) result_pop (dm);

	  /* Build the pointer-to-member notation.  It comes before
	     other pointer and reference qualifiers -- */
	  if (!dyn_string_prepend_cstr (symbols, "::*"))
	    return STATUS_ALLOCATION_FAILED;
	  if (!dyn_string_prepend (symbols, class_type))
	    return STATUS_ALLOCATION_FAILED;
	  dyn_string_delete (class_type);

	  if (peek_char (dm) == 'F')
	    continue;

	  /* Demangle the type of the pointed-to member.  */
d2082 3
a2084 9
	  /* Add the pointer-to-member syntax, and other pointer and
	     reference symbols.  */
	  if (STATUS_NO_ERROR (status))
	    status = result_append_string (dm, symbols);
	  /* Clean up.  */
	  dyn_string_delete (symbols);

	  RETURN_IF_ERROR (status);
	  return STATUS_OK;
a2085 11
      else if (next == 'F')
	{
	  /* Ooh, tricky, a pointer-to-function.  */
	  int position = result_length (dm);
	  status = result_append_char (dm, '(');
	  if (STATUS_NO_ERROR (status))
	    status = result_append_string (dm, symbols);
	  if (STATUS_NO_ERROR (status))
	    status = result_append_char (dm, ')');
	  dyn_string_delete (symbols);
	  RETURN_IF_ERROR (status);
d2087 10
a2096 7
	  RETURN_IF_ERROR (demangle_function_type (dm, position));
	  return STATUS_OK;
	}
      else
	{
	  /* No more pointe or reference tokens.  Finish up.  */
	  status = demangle_type (dm);
d2098 2
a2099 4
	  if (STATUS_NO_ERROR (status))
	    status = result_append_string (dm, symbols);
	  dyn_string_delete (symbols);
	  RETURN_IF_ERROR (status);
d2101 36
a2136 3
	  RETURN_IF_ERROR (status);
	  return STATUS_OK;
	}
d2138 5
d2153 1
d2169 1
a2169 3
  int template_p = 0;
  int special_std_substitution;
  int is_builtin_type = 0;
d2171 6
a2176 1
  int template_parm = NOT_TEMPLATE_PARM;
d2183 4
a2186 2
    RETURN_IF_ERROR (demangle_class_enum_type (dm, &template_p));
  else if (peek >= 'a' && peek <= 'z')
d2189 2
a2190 1
      is_builtin_type = 1;
d2198 3
d2243 22
a2264 1
	RETURN_IF_ERROR (demangle_template_param (dm, &template_parm));
d2274 14
a2287 2
	  RETURN_IF_ERROR (demangle_substitution (dm, &template_p,
						  &special_std_substitution));
d2289 26
a2314 1
	  demangle_class_enum_type (dm, &template_p);
d2320 4
a2323 1
	RETURN_IF_ERROR (demangle_type_ptr (dm));
d2341 1
a2341 1
	/* Vendor extended type qualifier.  */
d2352 1
a2352 2
  /* Unqualified builin types are not substitution candidates.  */
  if (!is_builtin_type)
d2355 1
a2355 1
       substitutions, a <template-param> token is a substitution
d2357 1
a2357 1
    RETURN_IF_ERROR (substitution_add (dm, start, template_p, template_parm));
d2496 1
a2496 1
/* Demangles and emits a <function-type> FUNCTION_NAME_POS is the
d2498 3
a2500 1
   identifier, at which the function's return type will be inserted.  
d2507 1
a2507 1
     int function_name_pos;
d2533 1
a2533 1
     int return_type_pos;
d2558 1
a2558 3
	  if (!dyn_string_append_space (return_type) 
	      || !dyn_string_insert (result_string (dm), return_type_pos, 
				     return_type))
d2560 8
d2578 3
d2582 5
a2586 3
	      /* Consume the v.  */
	      advance_char (dm);
	      continue;
a2587 5
	  /* Separate parameter types by commas.  */
	  if (sequence > 0)
	    RETURN_IF_ERROR (result_append (dm, ", "));
	  /* Demangle the type.  */
	  RETURN_IF_ERROR (demangle_type (dm));
d2594 8
d2605 1
a2605 1
/* Demangles and emits a <class-enum-type>.  *TEMPLATE_P is set to
d2611 1
a2611 1
demangle_class_enum_type (dm, template_p)
d2613 1
a2613 1
     int *template_p;
d2617 1
a2617 1
  RETURN_IF_ERROR (demangle_name (dm, template_p));
d2623 2
a2624 1
    <array-type> ::= A [<dimension number>] _ <element type>  */
d2630 3
a2632 5
  status_t status;
  dyn_string_t array_size = dyn_string_new (10);

  if (array_size == NULL)
    return STATUS_ALLOCATION_FAILED;
d2634 1
a2634 1
  status = demangle_char (dm, 'A');
d2637 23
a2659 2
  if (STATUS_NO_ERROR (status))
    status = demangle_number_literally (dm, array_size, 10, 0);
d2670 1
a2670 1
  if (STATUS_NO_ERROR (status))
d2674 2
a2675 1
  dyn_string_delete (array_size);
d2682 1
a2682 2
/* Demangles and emits a <template-param>.  The zero-indexed position
   in the parameter list is placed in *TEMPLATE_PARM_NUMBER.  
d2688 1
a2688 1
demangle_template_param (dm, template_parm_number)
a2689 1
     int *template_parm_number;
a2718 4
  if (peek_char (dm) == 'I')
    RETURN_IF_ERROR (demangle_template_args (dm));

  *template_parm_number = parm_number;
d2747 1
a2747 1
  RETURN_IF_ERROR (result_append_char (dm, '<'));
d2923 1
a3027 1
  int unused;
d3032 1
a3032 1
    RETURN_IF_ERROR (demangle_template_param (dm, &unused));
d3053 1
a3053 4
   if the substitution is the name of a template, zero otherwise.  If
   the substitution token is St, which corresponds to the `::std::'
   namespace and can appear in a non-nested name, sets
   *SPECIAL_STD_SUBSTITUTION to non-zero; zero otherwise.  
d3069 1
a3069 1
                                                     std::char_traits<char> >
d3073 1
a3073 1
demangle_substitution (dm, template_p, special_std_substitution)
a3075 1
     int *special_std_substitution;
a3083 1
  *special_std_substitution = 0;
a3103 1
	  *special_std_substitution = 1;
d3219 1
a3219 1
  RETURN_IF_ERROR (result_append (dm, "'s "));
a3231 1
      RETURN_IF_ERROR (result_append (dm, "local "));
d3254 1
a3254 1
     supressed if not in verbose mode.  */
d3346 1
a3383 3

#ifdef IN_LIBGCC2

d3540 2
a3541 1
  (IS_ALPHA (CHAR) || IS_DIGIT (CHAR) || (CHAR) == '_')
d3554 1
a3554 1
  fprintf (fp, "Options:\n", program_name);
@


1.2
log
@merge with gcc
@
text
@d30 2
@


1.1
log
@Synced with libiberty in the gcc repository.
@
text
@a29 2
#include <ctype.h>

d48 2
a49 2
#define DEMANGLE_TRACE(PRODUCTION, DM) \
  fprintf (stderr, " -> %-24s at position %3d\n", \
d55 7
d126 1
a126 1
  char *name;
d129 1
a129 1
  char *next;
d167 23
a189 4
#define STATUS_OK             NULL
#define STATUS_ERROR          "Error."
#define STATUS_UNIMPLEMENTED  "Unimplemented."
#define STATUS_INTERNAL_ERROR "Internal error."
d191 1
a191 1
static void int_to_dyn_string 
d197 1
a197 1
static void result_close_template_list 
d199 1
a199 1
static void result_push
d205 1
a205 1
static void substitution_add
d232 1
a232 1
  PARAMS ((char *));
d241 1
a241 1
   with one.  */
d243 4
a246 7
  do                                                                    \
    {                                                                   \
      if (dyn_string_length (DS) > 0                                    \
          && dyn_string_last_char (DS) != ' ')                          \
	dyn_string_append_char ((DS), ' ');                             \
    }                                                                   \
  while (0)
d275 2
a276 1
  dyn_string_append (&(DM)->result->string, (STRING))
d280 2
a281 1
  dyn_string_append_cstr (&(DM)->result->string, (CSTR))
d285 2
a286 1
  dyn_string_append_char (&(DM)->result->string, (CHAR))
d295 2
a296 13
  dyn_string_append_space (&(DM)->result->string)

/* Evaluate EXPR, which must produce a status_t.  If the status code
   indicates an error, return from the current function with that
   status code.  */
#define RETURN_IF_ERROR(EXPR)                                           \
  do                                                                    \
    {                                                                   \
      status_t s = EXPR;                                                \
      if (s != STATUS_OK)                                               \
	return s;                                                       \
    }                                                                   \
  while (0)
d298 2
a299 1
/* Appends a base 10 representation of VALUE to DS.  */
d301 1
a301 1
static void 
d312 3
a314 2
      dyn_string_append_char (ds, '0');
      return;
d320 2
a321 1
      dyn_string_append_char (ds, '-');
d337 4
a340 1
      dyn_string_append_char (ds, '0' + digit);
d344 2
d350 2
a351 1
   list node should be deleted with string_list_delete.  */
d357 5
a361 3
  string_list_t s = 
    (string_list_t) xmalloc (sizeof (struct string_list_def));
  dyn_string_init ((dyn_string_t) s, length);
d384 1
a384 1
static void
d389 4
d394 10
a403 2
    dyn_string_append_char (s, ' ');
  dyn_string_append_char (s, '>');
d407 3
a409 1
   for DM.  Subsequent demangling with DM will emit to the new string.  */
d411 1
a411 1
static void
d416 5
d423 1
d459 1
a459 1
static void
d470 11
a480 2
  dyn_string_substring (substitution, 
			result, start_position, result_length (dm));
d491 1
a491 1
	return;
d497 1
d499 11
a509 4
      dm->substitutions = (struct substitution_def *) 
	xrealloc (dm->substitutions,
		  sizeof (struct substitution_def) 
		  * dm->substitutions_allocated);
d521 2
d575 2
a576 1
/* Creates a new template argument list.  */
d581 4
a584 2
  template_arg_list_t new_list 
    = (template_arg_list_t) xmalloc (sizeof (struct template_arg_list_def));
d721 2
a722 1
   result must be pushed before the returned object can be used.  */
d726 1
a726 1
     char *name;
d728 4
a731 2
  demangling_t dm = (demangling_t) 
    xmalloc (sizeof (struct demangling_def));
a735 1
  dm->last_source_name = dyn_string_new (0);
a737 2
  dm->substitutions = (struct substitution_def *) 
    xmalloc (dm->substitutions_allocated * sizeof (struct substitution_def));
d739 10
d854 3
a856 1
  PARAMS ((char *, dyn_string_t));
d905 1
a905 1
			::= <substitution>  */
a911 1
  int special_std_substitution;
a912 1
  int start = substitution_start (dm);
d922 1
a922 12
  if (peek == 'S')
    {
      RETURN_IF_ERROR (demangle_substitution (dm, &template_p,
					      &special_std_substitution));
      if (special_std_substitution)
	{
	  /* This was the magic `std::' substitution.  */
	  result_append (dm, "::");
	  RETURN_IF_ERROR (demangle_encoding (dm));
	}
    }
  else if (peek == 'G' || peek == 'T')
a944 2

      substitution_add (dm, start, template_p, NOT_TEMPLATE_PARM);
d991 1
a991 2
	 without being enclosed in a nested name.
	   <name> ::= St <unqualified-name>     # ::std::  */
d996 1
a996 1
	  result_append (dm, "std::");
d1008 1
a1008 1
	      result_append (dm, "::");
d1012 8
d1031 2
a1032 1
	  substitution_add (dm, start, 0, NOT_TEMPLATE_PARM);
d1064 2
d1068 3
d1072 1
a1072 1
      result_append_string (dm, cv_qualifiers);
d1074 2
a1075 1
      result_append_space (dm);
d1123 1
a1123 1
      if (isdigit ((unsigned char) peek)
d1130 1
a1130 1
	    result_append (dm, "::");
d1152 1
a1152 1
	  substitution_add (dm, start, 0, NOT_TEMPLATE_PARM);
d1163 2
a1164 1
      substitution_add (dm, start, *template_p, NOT_TEMPLATE_PARM);
d1185 1
a1185 1
  if (isdigit ((unsigned char) peek))
d1223 1
a1223 1
  result_append_string (dm, dm->last_source_name);
d1249 3
d1285 2
a1286 1
      dyn_string_append_char (str, '-');
d1293 1
a1293 1
      if (isdigit ((unsigned char) peek)
d1295 5
a1299 2
	/* Accumulate digits.  */
	dyn_string_append_char (str, next_char (dm));
d1320 3
a1322 1
  dyn_string_resize (identifier, length);
d1327 2
a1328 1
      dyn_string_append_char (identifier, next_char (dm));
d1471 1
a1471 1
      result_append (dm, "operator");
d1480 1
a1480 1
      result_append (dm, "operator ");
d1498 2
a1499 2
	    result_append (dm, "operator");
	  result_append (dm, p->name);
d1552 1
a1552 1
      result_append (dm, "guard variable for ");
d1557 2
d1567 1
a1567 1
	  result_append (dm, "vtable for ");
d1574 1
a1574 1
	  result_append (dm, "VTT for ");
d1581 1
a1581 1
	  result_append (dm, "typeinfo for ");
d1588 1
a1588 1
	  result_append (dm, "typeinfo fn for ");
d1595 1
a1595 1
	  result_append (dm, "typeinfo name for ");
d1602 1
a1602 1
	  result_append (dm, "java Class for ");
d1609 1
a1609 1
	  result_append (dm, "non-virtual thunk");
d1612 2
d1618 3
a1620 2
	      result_append_char (dm, ' ');
	      result_append_string (dm, number);
d1623 1
d1627 1
a1627 1
	  result_append (dm, " to ");
d1634 1
a1634 1
	  result_append (dm, "virtual thunk ");
d1637 2
d1643 3
a1645 2
	      result_append_string (dm, number);
	      result_append_char (dm, ' ');
d1648 1
d1653 2
d1659 3
a1661 2
	      result_append_string (dm, number);
	      result_append_char (dm, ' ');
d1664 1
d1668 1
a1668 1
	  result_append (dm, "to ");
d1676 2
d1679 4
a1682 1
	      result_append (dm, "construction vtable for ");
d1684 2
d1688 5
d1695 2
a1696 1
	      RETURN_IF_ERROR (demangle_char (dm, '_'));
d1698 10
a1707 2
	      result_append (dm, "-in-");
	      RETURN_IF_ERROR (demangle_type (dm));
d1711 3
a1713 2
		  result_append_char (dm, ' ');
		  result_append_string (dm, number);
d1716 1
d1771 1
a1771 1
      result_append_string (dm, dm->last_source_name);
d1776 3
a1778 3
	  result_append (dm, "[");
	  result_append (dm, ctor_flavors[flavor]);
	  result_append_char (dm, ']');
d1787 2
a1788 2
      result_append_char (dm, '~');
      result_append_string (dm, dm->last_source_name);
d1793 3
a1795 3
	  result_append (dm, " [");
	  result_append (dm, dtor_flavors[flavor]);
	  result_append_char (dm, ']');
d1829 3
d1839 2
a1840 1
	  dyn_string_append_char (symbols, '*');
d1845 2
a1846 1
	  dyn_string_append_char (symbols, '&');
d1858 1
a1858 1
	  result_push (dm);
d1864 4
a1867 2
	  dyn_string_prepend_cstr (symbols, "::*");
	  dyn_string_prepend (symbols, class_type);
d1876 2
a1877 1
	  result_append_space (dm);
d1880 2
a1881 1
	  result_append_string (dm, symbols);
d1892 5
a1896 3
	  result_append_char (dm, '(');
	  result_append_string (dm, symbols);
	  result_append_char (dm, ')');
d1898 1
d1908 2
a1909 1
	  result_append_string (dm, symbols);
d1911 1
d1941 1
d1952 1
a1952 1
  if (isdigit ((unsigned char) peek) || peek == 'N' || peek == 'Z')
d1968 4
d1979 4
a1982 2
	      result_append_space (dm);
	      result_append_string (dm, cv_qualifiers);
d1987 5
a1991 3
	      result_append_string (dm, cv_qualifiers);
	      result_append_space (dm);
	      status = demangle_type (dm);
d2011 10
a2020 9
	RETURN_IF_ERROR (demangle_substitution (dm, &template_p,
						&special_std_substitution));
	if (special_std_substitution)
	  {
	    /* This was the magic `std::' substitution.  What follows
	       must be a class name in that namespace.  */
	    result_append (dm, "::");
	    RETURN_IF_ERROR (demangle_class_enum_type (dm, &template_p));
	  }
d2031 1
a2031 1
	result_append (dm, "complex ");
d2038 1
a2038 1
	result_append (dm, "imaginary ");
d2047 1
a2047 1
	result_append_char (dm, ' ');
d2061 1
a2061 1
    substitution_add (dm, start, template_p, template_parm);
d2148 1
a2148 1
      result_append (dm, type_name);
d2172 4
a2175 2
	  dyn_string_append_space (qualifiers);
	  dyn_string_append_cstr (qualifiers, "restrict");
d2179 4
a2182 2
	  dyn_string_append_space (qualifiers);
	  dyn_string_append_cstr (qualifiers, "volatile");
d2186 4
a2189 2
	  dyn_string_append_space (qualifiers);
	  dyn_string_append_cstr (qualifiers, "const");
d2217 1
a2217 1
	result_append (dm, " [extern \"C\"] ");
d2244 1
a2244 1
  result_append_char (dm, '(');
d2251 1
d2254 1
a2254 1
	  result_push (dm);
d2258 6
a2263 2
	  /* Add a space to the end of the type.  */
	  dyn_string_append_space (return_type);
a2264 3
	  /* Insert the return type where we've been asked to.  */
	  dyn_string_insert (result_string (dm), return_type_pos, 
			 return_type);
d2266 1
d2281 1
a2281 1
	    result_append (dm, ", ");
d2288 1
a2288 1
  result_append_char (dm, ')');
d2317 1
d2320 4
a2323 1
  RETURN_IF_ERROR (demangle_char (dm, 'A'));
d2326 2
a2327 1
  RETURN_IF_ERROR (demangle_number_literally (dm, array_size, 10, 0));
d2330 4
a2333 2
  RETURN_IF_ERROR (demangle_char (dm, '_'));
  RETURN_IF_ERROR (demangle_type (dm));
d2336 6
a2341 3
  result_append_char (dm, '[');
  result_append_string (dm, array_size);
  result_append_char (dm, ']');
d2344 2
d2386 1
a2386 1
  result_append_string (dm, (dyn_string_t) arg);
d2404 1
d2407 3
d2411 1
a2411 1
  dyn_string_t old_last_source_name = dm->last_source_name;
d2416 3
d2420 1
a2420 1
  result_append_char (dm, '<');
d2428 1
a2428 1
	result_append (dm, ", ");
d2431 1
a2431 1
      result_push (dm);
d2436 1
a2436 1
      result_append_string (dm, (dyn_string_t) arg);
d2443 1
a2443 1
  result_close_template_list (dm);
a2472 1
  dyn_string_t value = dyn_string_new (0);
d2474 2
d2512 1
a2512 1
	    result_append (dm, "false");
d2514 1
a2514 1
	    result_append (dm, "true");
d2527 1
d2529 4
a2532 2
	  RETURN_IF_ERROR (demangle_number_literally (dm, value, 10, 1));
	  result_append_string (dm, value);
d2534 5
a2538 2
	  if (code == 'l')
	    result_append_char (dm, code);
d2545 1
a2545 1
  result_append_char (dm, '(');
d2547 1
a2547 1
  result_append_char (dm, ')');
d2549 9
a2557 3
  RETURN_IF_ERROR (demangle_number_literally (dm, value, 10, 1));
  result_append_string (dm, value);
  dyn_string_delete (value);
d2629 1
d2635 1
a2635 1
      result_push (dm);
d2642 5
a2646 3
	  result_append_char (dm, '(');
	  RETURN_IF_ERROR (demangle_expression (dm));
	  result_append_char (dm, ')');
d2649 3
a2651 3
      /* Now emit the operator, followed by its second (if binary) or
	 only (if unary) operand.  */
      result_append_string (dm, operator_name);
d2653 4
a2656 1
      result_append_char (dm, '(');
d2658 1
a2658 1
      result_append_char (dm, ')');
d2663 1
a2663 1
	  result_append (dm, ":(");
d2665 1
a2665 1
	  result_append_char (dm, ')');
d2684 1
a2684 1
  result_append (dm, "::");
d2771 1
a2771 1
  else if (isdigit ((unsigned char) peek) 
d2776 2
d2781 1
a2781 1
	  result_append (dm, "std");
d2786 3
a2788 2
	  result_append (dm, "std::allocator");
	  dyn_string_copy_cstr (dm->last_source_name, "allocator");
d2792 3
a2794 2
	  result_append (dm, "std::basic_string");
	  dyn_string_copy_cstr (dm->last_source_name, "basic_string");
d2800 2
a2801 2
	      result_append (dm, "std::string");
	      dyn_string_copy_cstr (dm->last_source_name, "string");
d2805 2
a2806 2
	      result_append (dm, "std::basic_string<char, std::char_traits<char>, std::allocator<char> >");
	      dyn_string_copy_cstr (dm->last_source_name, "basic_string");
d2808 1
d2814 2
a2815 2
	      result_append (dm, "std::istream");
	      dyn_string_copy_cstr (dm->last_source_name, "istream");
d2819 2
a2820 2
	      result_append (dm, "std::basic_istream<char, std::char_traints<char> >");
	      dyn_string_copy_cstr (dm->last_source_name, "basic_istream");
d2822 1
d2828 2
a2829 2
	      result_append (dm, "std::ostream");
	      dyn_string_copy_cstr (dm->last_source_name, "ostream");
d2833 2
a2834 2
	      result_append (dm, "std::basic_ostream<char, std::char_traits<char> >");
	      dyn_string_copy_cstr (dm->last_source_name, "basic_ostream");
d2836 1
d2842 2
a2843 2
	      result_append (dm, "std::iostream");
	      dyn_string_copy_cstr (dm->last_source_name, "iostream");
d2847 2
a2848 2
	      result_append (dm, "std::basic_iostream<char, std::char_traits<char> >");
	      dyn_string_copy_cstr (dm->last_source_name, "basic_iostream");
d2850 1
d2857 1
d2859 8
d2874 1
a2874 1
  if (text == NULL)
d2878 1
a2878 1
  result_append_string (dm, text);
d2898 1
a2898 1
  result_append (dm, "'s ");
d2903 1
a2903 1
      result_append (dm, "string literal");
d2911 1
a2911 1
      result_append (dm, "local ");
d2941 1
a2941 1
	result_append (dm, " [#");
d2943 1
a2943 1
      if (isdigit ((unsigned char) peek_char (dm)))
d2952 2
a2953 2
	    int_to_dyn_string (discriminator + 2, 
			       (dyn_string_t) dm->result);
d2959 1
a2959 1
	    result_append_char (dm, '1');
d2962 1
a2962 1
	result_append_char (dm, ']');
d2967 1
a2967 1
	result_append (dm, " [#0]");
d2979 1
a2979 1
     char *name;
d2988 9
a2997 1
      result_push (dm);
d2999 1
a2999 2

      if (status == STATUS_OK)
d3002 2
a3003 1
	  dyn_string_copy (result, demangled);
d3014 2
a3015 1
      dyn_string_copy_cstr (result, name);
d3019 41
d3063 112
d3189 1
a3189 1
  if (status == STATUS_OK)
a3194 2
      /* The dyn_string can go away.  */
      dyn_string_delete (demangled);
d3198 5
d3211 2
d3222 1
a3222 1
  (isalnum ((unsigned char) (CHAR)) || (CHAR) == '_')
d3351 1
a3351 1
	  if (status == STATUS_OK)
d3353 6
d3389 1
a3389 1
	  if (status == STATUS_OK)
d3391 6
@

