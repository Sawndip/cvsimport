head	1.3;
access;
symbols
	sid-snapshot-20180601:1.3
	sid-snapshot-20180501:1.3
	sid-snapshot-20180401:1.3
	sid-snapshot-20180301:1.3
	sid-snapshot-20180201:1.3
	sid-snapshot-20180101:1.3
	sid-snapshot-20171201:1.3
	sid-snapshot-20171101:1.3
	sid-snapshot-20171001:1.3
	sid-snapshot-20170901:1.3
	sid-snapshot-20170801:1.3
	sid-snapshot-20170701:1.3
	sid-snapshot-20170601:1.3
	sid-snapshot-20170501:1.3
	sid-snapshot-20170401:1.3
	sid-snapshot-20170301:1.3
	sid-snapshot-20170201:1.3
	sid-snapshot-20170101:1.3
	sid-snapshot-20161201:1.3
	sid-snapshot-20161101:1.3
	sid-snapshot-20160901:1.3
	sid-snapshot-20160801:1.3
	sid-snapshot-20160701:1.3
	sid-snapshot-20160601:1.3
	sid-snapshot-20160501:1.3
	sid-snapshot-20160401:1.3
	sid-snapshot-20160301:1.3
	sid-snapshot-20160201:1.3
	sid-snapshot-20160101:1.3
	sid-snapshot-20151201:1.3
	sid-snapshot-20151101:1.3
	sid-snapshot-20151001:1.3
	sid-snapshot-20150901:1.3
	sid-snapshot-20150801:1.3
	sid-snapshot-20150701:1.3
	sid-snapshot-20150601:1.3
	sid-snapshot-20150501:1.3
	sid-snapshot-20150401:1.3
	sid-snapshot-20150301:1.3
	sid-snapshot-20150201:1.3
	sid-snapshot-20150101:1.3
	sid-snapshot-20141201:1.3
	sid-snapshot-20141101:1.3
	sid-snapshot-20141001:1.3
	sid-snapshot-20140901:1.3
	sid-snapshot-20140801:1.3
	sid-snapshot-20140701:1.3
	sid-snapshot-20140601:1.3
	sid-snapshot-20140501:1.3
	sid-snapshot-20140401:1.3
	sid-snapshot-20140301:1.3
	sid-snapshot-20140201:1.3
	sid-snapshot-20140101:1.3
	sid-snapshot-20131201:1.3
	sid-snapshot-20131101:1.3
	sid-snapshot-20131001:1.3
	binutils-2_24-branch:1.3.0.4
	binutils-2_24-branchpoint:1.3
	binutils-2_21_1:1.1
	sid-snapshot-20130901:1.3
	gdb_7_6_1-2013-08-30-release:1.3
	sid-snapshot-20130801:1.3
	sid-snapshot-20130701:1.3
	sid-snapshot-20130601:1.3
	sid-snapshot-20130501:1.3
	gdb_7_6-2013-04-26-release:1.3
	sid-snapshot-20130401:1.3
	binutils-2_23_2:1.2
	gdb_7_6-branch:1.3.0.2
	gdb_7_6-2013-03-12-branchpoint:1.3
	sid-snapshot-20130301:1.3
	sid-snapshot-20130201:1.3
	sid-snapshot-20130101:1.2
	sid-snapshot-20121201:1.2
	gdb_7_5_1-2012-11-29-release:1.2
	binutils-2_23_1:1.2
	sid-snapshot-20121101:1.2
	binutils-2_23:1.2
	sid-snapshot-20121001:1.2
	sid-snapshot-20120901:1.2
	gdb_7_5-2012-08-17-release:1.2
	sid-snapshot-20120801:1.2
	binutils-2_23-branch:1.2.0.12
	binutils-2_23-branchpoint:1.2
	gdb_7_5-branch:1.2.0.10
	gdb_7_5-2012-07-18-branchpoint:1.2
	sid-snapshot-20120701:1.2
	sid-snapshot-20120601:1.2
	sid-snapshot-20120501:1.2
	binutils-2_22_branch:1.2.0.8
	gdb_7_4_1-2012-04-26-release:1.2
	sid-snapshot-20120401:1.2
	sid-snapshot-20120301:1.2
	sid-snapshot-20120201:1.2
	gdb_7_4-2012-01-24-release:1.2
	sid-snapshot-20120101:1.2
	gdb_7_4-branch:1.2.0.6
	gdb_7_4-2011-12-13-branchpoint:1.2
	sid-snapshot-20111201:1.2
	binutils-2_22:1.2
	sid-snapshot-20111101:1.2
	sid-snapshot-20111001:1.2
	binutils-2_22-branch:1.2.0.4
	binutils-2_22-branchpoint:1.2
	gdb_7_3_1-2011-09-04-release:1.2
	sid-snapshot-20110901:1.2
	sid-snapshot-20110801:1.2
	gdb_7_3-2011-07-26-release:1.2
	sid-snapshot-20110701:1.2
	sid-snapshot-20110601:1.2
	sid-snapshot-20110501:1.2
	gdb_7_3-branch:1.2.0.2
	gdb_7_3-2011-04-01-branchpoint:1.2
	sid-snapshot-20110401:1.2
	sid-snapshot-20110301:1.2
	cygwin-1_7_8-release:1.2
	sid-snapshot-20110201:1.2
	sid-snapshot-20110101:1.2
	binutils-2_21:1.1
	sid-snapshot-20101201:1.2
	binutils-2_21-branch:1.1.0.2
	binutils-2_21-branchpoint:1.1
	binutils_latest_snapshot:1.3;
locks; strict;
comment	@ * @;


1.3
date	2013.01.07.20.28.44;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.17.02.03.43;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2010.11.02.15.20.47;	author dj;	state Exp;
branches;
next	;


desc
@@


1.3
log
@merge from gcc
@
text
@/* simple-object-common.h -- common structs for object file manipulation.
   Copyright (C) 2010 Free Software Foundation, Inc.

This file is part of the libiberty library.
Libiberty is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

Libiberty is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libiberty; see the file COPYING.LIB.  If not,
write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */

/* Forward reference.  */
struct simple_object_functions;

/* An object file opened for reading.  */

struct simple_object_read_struct
{
  /* The file descriptor.  */
  int descriptor;
  /* The offset within the file.  */
  off_t offset;
  /* The functions which do the actual work.  */
  const struct simple_object_functions *functions;
  /* Private data for the object file format.  */
  void *data;
};

/* Object file attributes.  */

struct simple_object_attributes_struct
{
  /* The functions which do the actual work.  */
  const struct simple_object_functions *functions;
  /* Private data for the object file format.  */
  void *data;
};

/* An object file being created.  */

struct simple_object_write_struct
{
  /* The functions which do the actual work.  */
  const struct simple_object_functions *functions;
  /* The segment_name argument from the user.  */
  char *segment_name;
  /* The start of the list of sections.  */
  simple_object_write_section *sections;
  /* The last entry in the list of sections.  */
  simple_object_write_section *last_section;
  /* Private data for the object file format.  */
  void *data;
};

/* A section in an object file being created.  */

struct simple_object_write_section_struct
{
  /* Next in the list of sections attached to an
     simple_object_write.  */
  simple_object_write_section *next;
  /* The name of this section.  */
  char *name;
  /* The required alignment.  */
  unsigned int align;
  /* The first data attached to this section.  */
  struct simple_object_write_section_buffer *buffers;
  /* The last data attached to this section.  */
  struct simple_object_write_section_buffer *last_buffer;
};

/* Data attached to a section.  */

struct simple_object_write_section_buffer
{
  /* The next data for this section.  */
  struct simple_object_write_section_buffer *next;
  /* The size of the buffer.  */
  size_t size;
  /* The actual bytes.  */
  const void *buffer;
  /* A buffer to free, or NULL.  */
  void *free_buffer;
};

/* The number of bytes we read from the start of the file to pass to
   the match function.  */
#define SIMPLE_OBJECT_MATCH_HEADER_LEN (16)

/* Format-specific object file functions.  */

struct simple_object_functions
{
  /* If this file matches these functions, return a new value for the
     private data for an simple_object_read.  HEADER is the first 16
     bytes of the file.  DESCRIPTOR, OFFSET, SEGMENT_NAME, ERRMSG, and
     ERR are as for simple_object_open_read.  If this file does not
     match, this function should return NULL with *ERRMSG set to
     NULL.  */
  void *(*match) (unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN],
		  int descriptor, off_t offset, const char *segment_name,
		  const char **errmsg, int *err);

  /* Implement simple_object_find_sections.  */
  const char *(*find_sections) (simple_object_read *,
				int (*pfn) (void *, const char *,
					    off_t offset, off_t length),
				void *data,
				int *err);

  /* Return the private data for the attributes for SOBJ.  */
  void *(*fetch_attributes) (simple_object_read *sobj, const char **errmsg,
			     int *err);

  /* Release the private data for an simple_object_read.  */
  void (*release_read) (void *);

  /* Merge the private data for the attributes of two files.  If they
     could be linked together, return NULL.  Otherwise return an error
     message.  */
  const char *(*attributes_merge) (void *, void *, int *err);

  /* Release the private data for an simple_object_attributes.  */
  void (*release_attributes) (void *);

  /* Start creating an object file.  */
  void *(*start_write) (void *attributes_data, const char **errmsg,
			int *err);

  /* Write the complete object file.  */
  const char *(*write_to_file) (simple_object_write *sobj, int descriptor,
				int *err);

  /* Release the private data for an simple_object_write.  */
  void (*release_write) (void *);
};

/* The known object file formats.  */

extern const struct simple_object_functions simple_object_coff_functions;
extern const struct simple_object_functions simple_object_elf_functions;
extern const struct simple_object_functions simple_object_mach_o_functions;
extern const struct simple_object_functions simple_object_xcoff_functions;

/* Read SIZE bytes from DESCRIPTOR at file offset OFFSET into BUFFER.
   Return non-zero on success.  On failure return 0 and set *ERRMSG
   and *ERR.  */

extern int
simple_object_internal_read (int descriptor, off_t offset,
			     unsigned char *buffer, size_t size,
			     const char **errmsg, int *err);

/* Write SIZE bytes from BUFFER to DESCRIPTOR at file offset OFFSET.
   Return non-zero on success.  On failure return 0 and set *ERRMSG
   and *ERR.  */

extern int
simple_object_internal_write (int descriptor, off_t offset,
			      const unsigned char *buffer, size_t size,
			      const char **errmsg, int *err);

/* Define ulong_type as an unsigned 64-bit type if available.
   Otherwise just make it unsigned long.  */

#ifdef UNSIGNED_64BIT_TYPE
__extension__ typedef UNSIGNED_64BIT_TYPE ulong_type;
#else
typedef unsigned long ulong_type;
#endif

/* Fetch a big-endian 16-bit value.  */

static inline unsigned short
simple_object_fetch_big_16 (const unsigned char *buf)
{
  return ((unsigned short) buf[0] << 8) | (unsigned short) buf[1];
}

/* Fetch a little-endian 16-bit value.  */

static inline unsigned short
simple_object_fetch_little_16 (const unsigned char *buf)
{
  return ((unsigned short) buf[1] << 8) | (unsigned short) buf[0];
}

/* Fetch a big-endian 32-bit value.  */

static inline unsigned int
simple_object_fetch_big_32 (const unsigned char *buf)
{
  return (((unsigned int) buf[0] << 24)
	  | ((unsigned int) buf[1] << 16)
	  | ((unsigned int) buf[2] << 8)
	  | (unsigned int) buf[3]);
}

/* Fetch a little-endian 32-bit value.  */

static inline unsigned int
simple_object_fetch_little_32 (const unsigned char *buf)
{
  return (((unsigned int) buf[3] << 24)
	  | ((unsigned int) buf[2] << 16)
	  | ((unsigned int) buf[1] << 8)
	  | (unsigned int) buf[0]);
}

/* Fetch a big-endian 32-bit value as a ulong_type.  */

static inline ulong_type
simple_object_fetch_big_32_ulong (const unsigned char *buf)
{
  return (ulong_type) simple_object_fetch_big_32 (buf);
}

/* Fetch a little-endian 32-bit value as a ulong_type.  */

static inline ulong_type
simple_object_fetch_little_32_ulong (const unsigned char *buf)
{
  return (ulong_type) simple_object_fetch_little_32 (buf);
}

#ifdef UNSIGNED_64BIT_TYPE

/* Fetch a big-endian 64-bit value.  */

static inline ulong_type
simple_object_fetch_big_64 (const unsigned char *buf)
{
  return (((ulong_type) buf[0] << 56)
	  | ((ulong_type) buf[1] << 48)
	  | ((ulong_type) buf[2] << 40)
	  | ((ulong_type) buf[3] << 32)
	  | ((ulong_type) buf[4] << 24)
	  | ((ulong_type) buf[5] << 16)
	  | ((ulong_type) buf[6] << 8)
	  | (ulong_type) buf[7]);
}

/* Fetch a little-endian 64-bit value.  */

static inline ulong_type
simple_object_fetch_little_64 (const unsigned char *buf)
{
  return (((ulong_type) buf[7] << 56)
	  | ((ulong_type) buf[6] << 48)
	  | ((ulong_type) buf[5] << 40)
	  | ((ulong_type) buf[4] << 32)
	  | ((ulong_type) buf[3] << 24)
	  | ((ulong_type) buf[2] << 16)
	  | ((ulong_type) buf[1] << 8)
	  | (ulong_type) buf[0]);
}

#endif

/* Store a big-endian 16-bit value.  */

static inline void
simple_object_set_big_16 (unsigned char *buf, unsigned short val)
{
  buf[0] = (val >> 8) & 0xff;
  buf[1] = val & 0xff;
}

/* Store a little-endian 16-bit value.  */

static inline void
simple_object_set_little_16 (unsigned char *buf, unsigned short val)
{
  buf[1] = (val >> 8) & 0xff;
  buf[0] = val & 0xff;
}

/* Store a big-endian 32-bit value.  */

static inline void
simple_object_set_big_32 (unsigned char *buf, unsigned int val)
{
  buf[0] = (val >> 24) & 0xff;
  buf[1] = (val >> 16) & 0xff;
  buf[2] = (val >> 8) & 0xff;
  buf[3] = val & 0xff;
}

/* Store a little-endian 32-bit value.  */

static inline void
simple_object_set_little_32 (unsigned char *buf, unsigned int val)
{
  buf[3] = (val >> 24) & 0xff;
  buf[2] = (val >> 16) & 0xff;
  buf[1] = (val >> 8) & 0xff;
  buf[0] = val & 0xff;
}

/* Store a big-endian 32-bit value coming in as a ulong_type.  */

static inline void
simple_object_set_big_32_ulong (unsigned char *buf, ulong_type val)
{
  simple_object_set_big_32 (buf, val);
}

/* Store a little-endian 32-bit value coming in as a ulong_type.  */

static inline void
simple_object_set_little_32_ulong (unsigned char *buf, ulong_type val)
{
  simple_object_set_little_32 (buf, val);
}

#ifdef UNSIGNED_64BIT_TYPE

/* Store a big-endian 64-bit value.  */

static inline void
simple_object_set_big_64 (unsigned char *buf, ulong_type val)
{
  buf[0] = (val >> 56) & 0xff;
  buf[1] = (val >> 48) & 0xff;
  buf[2] = (val >> 40) & 0xff;
  buf[3] = (val >> 32) & 0xff;
  buf[4] = (val >> 24) & 0xff;
  buf[5] = (val >> 16) & 0xff;
  buf[6] = (val >> 8) & 0xff;
  buf[7] = val & 0xff;
}

/* Store a little-endian 64-bit value.  */

static inline void
simple_object_set_little_64 (unsigned char *buf, ulong_type val)
{
  buf[7] = (val >> 56) & 0xff;
  buf[6] = (val >> 48) & 0xff;
  buf[5] = (val >> 40) & 0xff;
  buf[4] = (val >> 32) & 0xff;
  buf[3] = (val >> 24) & 0xff;
  buf[2] = (val >> 16) & 0xff;
  buf[1] = (val >> 8) & 0xff;
  buf[0] = val & 0xff;
}

#endif
@


1.2
log
@merge from gcc
@
text
@d151 1
@


1.1
log
@merge from gcc
@
text
@d126 4
a129 4
  /* Compare the private data for the attributes of two files.  If
     they are the same, in the sense that they could be linked
     together, return NULL.  Otherwise return an error message.  */
  const char *(*attributes_compare) (void *, void *, int *err);
@

