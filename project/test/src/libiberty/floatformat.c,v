head	1.30;
access;
symbols
	sid-snapshot-20180601:1.30
	sid-snapshot-20180501:1.30
	sid-snapshot-20180401:1.30
	sid-snapshot-20180301:1.30
	sid-snapshot-20180201:1.30
	sid-snapshot-20180101:1.30
	sid-snapshot-20171201:1.30
	sid-snapshot-20171101:1.30
	sid-snapshot-20171001:1.30
	sid-snapshot-20170901:1.30
	sid-snapshot-20170801:1.30
	sid-snapshot-20170701:1.30
	sid-snapshot-20170601:1.30
	sid-snapshot-20170501:1.30
	sid-snapshot-20170401:1.30
	sid-snapshot-20170301:1.30
	sid-snapshot-20170201:1.30
	sid-snapshot-20170101:1.30
	sid-snapshot-20161201:1.30
	sid-snapshot-20161101:1.30
	sid-snapshot-20160901:1.30
	sid-snapshot-20160801:1.30
	sid-snapshot-20160701:1.30
	sid-snapshot-20160601:1.30
	sid-snapshot-20160501:1.30
	sid-snapshot-20160401:1.30
	sid-snapshot-20160301:1.30
	sid-snapshot-20160201:1.30
	sid-snapshot-20160101:1.30
	sid-snapshot-20151201:1.30
	sid-snapshot-20151101:1.30
	sid-snapshot-20151001:1.30
	sid-snapshot-20150901:1.30
	sid-snapshot-20150801:1.30
	sid-snapshot-20150701:1.30
	sid-snapshot-20150601:1.29
	sid-snapshot-20150501:1.29
	sid-snapshot-20150401:1.29
	sid-snapshot-20150301:1.29
	sid-snapshot-20150201:1.29
	sid-snapshot-20150101:1.29
	sid-snapshot-20141201:1.29
	sid-snapshot-20141101:1.29
	sid-snapshot-20141001:1.29
	sid-snapshot-20140901:1.29
	sid-snapshot-20140801:1.29
	sid-snapshot-20140701:1.29
	sid-snapshot-20140601:1.29
	sid-snapshot-20140501:1.29
	sid-snapshot-20140401:1.29
	sid-snapshot-20140301:1.29
	sid-snapshot-20140201:1.29
	sid-snapshot-20140101:1.29
	sid-snapshot-20131201:1.29
	sid-snapshot-20131101:1.29
	sid-snapshot-20131001:1.29
	binutils-2_24-branch:1.29.0.2
	binutils-2_24-branchpoint:1.29
	binutils-2_21_1:1.26
	sid-snapshot-20130901:1.29
	gdb_7_6_1-2013-08-30-release:1.28
	sid-snapshot-20130801:1.28
	sid-snapshot-20130701:1.28
	sid-snapshot-20130601:1.28
	sid-snapshot-20130501:1.28
	gdb_7_6-2013-04-26-release:1.28
	sid-snapshot-20130401:1.28
	binutils-2_23_2:1.27
	gdb_7_6-branch:1.28.0.2
	gdb_7_6-2013-03-12-branchpoint:1.28
	sid-snapshot-20130301:1.28
	sid-snapshot-20130201:1.28
	sid-snapshot-20130101:1.28
	sid-snapshot-20121201:1.28
	gdb_7_5_1-2012-11-29-release:1.27
	binutils-2_23_1:1.27
	sid-snapshot-20121101:1.28
	binutils-2_23:1.27
	sid-snapshot-20121001:1.28
	sid-snapshot-20120901:1.28
	gdb_7_5-2012-08-17-release:1.27
	sid-snapshot-20120801:1.27
	binutils-2_23-branch:1.27.0.12
	binutils-2_23-branchpoint:1.27
	gdb_7_5-branch:1.27.0.10
	gdb_7_5-2012-07-18-branchpoint:1.27
	sid-snapshot-20120701:1.27
	sid-snapshot-20120601:1.27
	sid-snapshot-20120501:1.27
	binutils-2_22_branch:1.27.0.8
	gdb_7_4_1-2012-04-26-release:1.27
	sid-snapshot-20120401:1.27
	sid-snapshot-20120301:1.27
	sid-snapshot-20120201:1.27
	gdb_7_4-2012-01-24-release:1.27
	sid-snapshot-20120101:1.27
	gdb_7_4-branch:1.27.0.6
	gdb_7_4-2011-12-13-branchpoint:1.27
	sid-snapshot-20111201:1.27
	binutils-2_22:1.27
	sid-snapshot-20111101:1.27
	sid-snapshot-20111001:1.27
	binutils-2_22-branch:1.27.0.4
	binutils-2_22-branchpoint:1.27
	gdb_7_3_1-2011-09-04-release:1.27
	sid-snapshot-20110901:1.27
	sid-snapshot-20110801:1.27
	gdb_7_3-2011-07-26-release:1.27
	sid-snapshot-20110701:1.27
	sid-snapshot-20110601:1.27
	sid-snapshot-20110501:1.27
	gdb_7_3-branch:1.27.0.2
	gdb_7_3-2011-04-01-branchpoint:1.27
	sid-snapshot-20110401:1.27
	sid-snapshot-20110301:1.27
	cygwin-1_7_8-release:1.27
	sid-snapshot-20110201:1.27
	sid-snapshot-20110101:1.26
	binutils-2_21:1.26
	sid-snapshot-20101201:1.26
	binutils-2_21-branch:1.26.0.4
	binutils-2_21-branchpoint:1.26
	sid-snapshot-20101101:1.26
	sid-snapshot-20101001:1.26
	binutils-2_20_1:1.25
	gdb_7_2-2010-09-02-release:1.26
	sid-snapshot-20100901:1.26
	cygwin-1_7_7-release:1.26
	sid-snapshot-20100801:1.26
	gdb_7_2-branch:1.26.0.2
	gdb_7_2-2010-07-07-branchpoint:1.26
	sid-snapshot-20100701:1.25
	sid-snapshot-20100601:1.25
	sid-snapshot-20100501:1.25
	sid-snapshot-20100401:1.25
	gdb_7_1-2010-03-18-release:1.25
	sid-snapshot-20100301:1.25
	gdb_7_1-branch:1.25.0.32
	gdb_7_1-2010-02-18-branchpoint:1.25
	sid-snapshot-20100201:1.25
	sid-snapshot-20100101:1.25
	gdb_7_0_1-2009-12-22-release:1.25
	sid-snapshot-20091201:1.25
	sid-snapshot-20091101:1.25
	binutils-2_20:1.25
	gdb_7_0-2009-10-06-release:1.25
	sid-snapshot-20091001:1.25
	gdb_7_0-branch:1.25.0.30
	gdb_7_0-2009-09-16-branchpoint:1.25
	arc-sim-20090309:1.25
	binutils-arc-20081103-branch:1.25.0.28
	binutils-arc-20081103-branchpoint:1.25
	binutils-2_20-branch:1.25.0.26
	binutils-2_20-branchpoint:1.25
	sid-snapshot-20090901:1.25
	sid-snapshot-20090801:1.25
	msnyder-checkpoint-072509-branch:1.25.0.24
	msnyder-checkpoint-072509-branchpoint:1.25
	sid-snapshot-20090701:1.25
	dje-cgen-play1-branch:1.25.0.22
	dje-cgen-play1-branchpoint:1.25
	sid-snapshot-20090601:1.25
	sid-snapshot-20090501:1.25
	sid-snapshot-20090401:1.25
	arc-20081103-branch:1.25.0.20
	arc-20081103-branchpoint:1.25
	arc-insight_6_8-branch:1.25.0.18
	arc-insight_6_8-branchpoint:1.25
	insight_6_8-branch:1.25.0.16
	insight_6_8-branchpoint:1.25
	sid-snapshot-20090301:1.25
	binutils-2_19_1:1.25
	sid-snapshot-20090201:1.25
	sid-snapshot-20090101:1.25
	reverse-20081226-branch:1.25.0.14
	reverse-20081226-branchpoint:1.25
	sid-snapshot-20081201:1.25
	multiprocess-20081120-branch:1.25.0.12
	multiprocess-20081120-branchpoint:1.25
	sid-snapshot-20081101:1.25
	binutils-2_19:1.25
	sid-snapshot-20081001:1.25
	reverse-20080930-branch:1.25.0.10
	reverse-20080930-branchpoint:1.25
	binutils-2_19-branch:1.25.0.8
	binutils-2_19-branchpoint:1.25
	sid-snapshot-20080901:1.25
	sid-snapshot-20080801:1.25
	reverse-20080717-branch:1.25.0.6
	reverse-20080717-branchpoint:1.25
	sid-snapshot-20080701:1.25
	msnyder-reverse-20080609-branch:1.25.0.4
	msnyder-reverse-20080609-branchpoint:1.25
	drow-reverse-20070409-branch:1.21.0.8
	drow-reverse-20070409-branchpoint:1.21
	sid-snapshot-20080601:1.25
	sid-snapshot-20080501:1.25
	sid-snapshot-20080403:1.25
	sid-snapshot-20080401:1.25
	gdb_6_8-2008-03-27-release:1.25
	sid-snapshot-20080301:1.25
	gdb_6_8-branch:1.25.0.2
	gdb_6_8-2008-02-26-branchpoint:1.25
	sid-snapshot-20080201:1.25
	sid-snapshot-20080101:1.25
	sid-snapshot-20071201:1.25
	sid-snapshot-20071101:1.21
	gdb_6_7_1-2007-10-29-release:1.21
	gdb_6_7-2007-10-10-release:1.21
	sid-snapshot-20071001:1.21
	gdb_6_7-branch:1.21.0.6
	gdb_6_7-2007-09-07-branchpoint:1.21
	binutils-2_18:1.21
	binutils-2_18-branch:1.21.0.4
	binutils-2_18-branchpoint:1.21
	insight_6_6-20070208-release:1.21
	binutils-csl-coldfire-4_1-32:1.19.6.2
	binutils-csl-sourcerygxx-4_1-32:1.19.6.2
	gdb_6_6-2006-12-18-release:1.21
	binutils-csl-innovasic-fido-3_4_4-33:1.19.6.2
	binutils-csl-sourcerygxx-3_4_4-32:1.12
	binutils-csl-coldfire-4_1-30:1.19.6.2
	binutils-csl-sourcerygxx-4_1-30:1.19.6.2
	binutils-csl-coldfire-4_1-28:1.19.6.2
	binutils-csl-sourcerygxx-4_1-29:1.19.6.2
	binutils-csl-sourcerygxx-4_1-28:1.19.6.2
	gdb_6_6-branch:1.21.0.2
	gdb_6_6-2006-11-15-branchpoint:1.21
	binutils-csl-arm-2006q3-27:1.19.6.2
	binutils-csl-sourcerygxx-4_1-27:1.19.6.2
	binutils-csl-arm-2006q3-26:1.19.6.2
	binutils-csl-sourcerygxx-4_1-26:1.19.6.2
	binutils-csl-sourcerygxx-4_1-25:1.19.6.2
	binutils-csl-sourcerygxx-4_1-24:1.19.6.2
	binutils-csl-sourcerygxx-4_1-23:1.19.6.2
	insight_6_5-20061003-release:1.20
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	binutils-csl-sourcerygxx-4_1-21:1.19.6.2
	binutils-csl-arm-2006q3-21:1.19.6.2
	binutils-csl-sourcerygxx-4_1-22:1.19.6.2
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.19.6.2
	binutils-csl-sourcerygxx-4_1-20:1.19.6.2
	binutils-csl-arm-2006q3-19:1.19.6.2
	binutils-csl-sourcerygxx-4_1-19:1.19.6.2
	binutils-csl-sourcerygxx-4_1-18:1.19.6.2
	binutils-csl-renesas-4_1-9:1.19.6.2
	gdb-csl-sourcerygxx-3_4_4-25:1.17
	binutils-csl-sourcerygxx-3_4_4-25:1.12
	nickrob-async-20060828-mergepoint:1.20
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	binutils-csl-renesas-4_1-8:1.19.6.2
	binutils-csl-renesas-4_1-7:1.19.6.1
	binutils-csl-renesas-4_1-6:1.19.6.1
	gdb-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-17:1.19.6.1
	gdb-csl-20060226-branch-local-2:1.19
	cr-0x5f1:1.20.0.8
	gdb-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-14:1.19.6.1
	binutils-csl-sourcerygxx-4_1-15:1.19.6.1
	gdb-csl-sourcerygxx-4_1-13:1.19
	binutils-csl-sourcerygxx-4_1-13:1.19.6.1
	binutils-2_17:1.19
	gdb-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-4_1-12:1.19.6.1
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.19.6.1
	gdb_6_5-20060621-release:1.20
	binutils-csl-wrs-linux-3_4_4-24:1.12
	binutils-csl-wrs-linux-3_4_4-23:1.12
	gdb-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-9:1.19.6.1
	gdb-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-8:1.19.6.1
	gdb-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-sourcerygxx-4_1-7:1.19.6.1
	gdb-csl-arm-2006q1-6:1.19
	binutils-csl-arm-2006q1-6:1.19.6.1
	gdb-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.19.6.1
	binutils-csl-wrs-linux-3_4_4-22:1.12
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	binutils-csl-coldfire-4_1-11:1.19.6.1
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.19.6.1
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.20.0.6
	gdb_6_5-2006-05-14-branchpoint:1.20
	binutils-csl-coldfire-4_1-10:1.19.6.1
	gdb-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-5:1.19.6.1
	nickrob-async-20060513-branch:1.20.0.4
	nickrob-async-20060513-branchpoint:1.20
	gdb-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-sourcerygxx-4_1-4:1.19.6.1
	msnyder-reverse-20060502-branch:1.20.0.2
	msnyder-reverse-20060502-branchpoint:1.20
	binutils-csl-wrs-linux-3_4_4-21:1.12
	gdb-csl-morpho-4_1-4:1.19
	binutils-csl-morpho-4_1-4:1.19.6.1
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.19.6.1
	binutils-csl-wrs-linux-3_4_4-20:1.12
	readline_5_1-import-branch:1.19.0.14
	readline_5_1-import-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	binutils-2_17-branch:1.19.0.12
	binutils-2_17-branchpoint:1.19
	gdb-csl-symbian-20060226-branch:1.19.0.10
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.19.0.8
	msnyder-reverse-20060331-branchpoint:1.19
	binutils-csl-2_17-branch:1.19.0.6
	binutils-csl-2_17-branchpoint:1.19
	gdb-csl-available-20060303-branch:1.19.0.4
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.2
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.17
	msnyder-fork-checkpoint-branch:1.17.0.6
	msnyder-fork-checkpoint-branchpoint:1.17
	gdb-csl-gxxpro-6_3-branch:1.17.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.17
	gdb_6_4-branch:1.17.0.2
	gdb_6_4-2005-11-01-branchpoint:1.17
	gdb-csl-arm-20051020-branch:1.16.0.2
	gdb-csl-arm-20051020-branchpoint:1.16
	binutils-csl-gxxpro-3_4-branch:1.12.0.28
	binutils-csl-gxxpro-3_4-branchpoint:1.12
	binutils-2_16_1:1.12
	msnyder-tracepoint-checkpoint-branch:1.14.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.14
	gdb-csl-arm-20050325-2005-q1b:1.12
	binutils-csl-arm-2005q1b:1.12
	binutils-2_16:1.12
	gdb-csl-arm-20050325-2005-q1a:1.12
	binutils-csl-arm-2005q1a:1.12
	csl-arm-20050325-branch:1.12.0.26
	csl-arm-20050325-branchpoint:1.12
	binutils-csl-arm-2005q1-branch:1.12.0.24
	binutils-csl-arm-2005q1-branchpoint:1.12
	binutils-2_16-branch:1.12.0.22
	binutils-2_16-branchpoint:1.12
	csl-arm-2004-q3d:1.12
	gdb_6_3-20041109-release:1.12
	gdb_6_3-branch:1.12.0.18
	gdb_6_3-20041019-branchpoint:1.12
	csl-arm-2004-q3:1.12
	drow_intercu-merge-20040921:1.12
	drow_intercu-merge-20040915:1.12
	jimb-gdb_6_2-e500-branch:1.12.0.20
	jimb-gdb_6_2-e500-branchpoint:1.12
	gdb_6_2-20040730-release:1.12
	gdb_6_2-branch:1.12.0.16
	gdb_6_2-2004-07-10-gmt-branchpoint:1.12
	gdb_6_1_1-20040616-release:1.12
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	gdb_6_1-2004-04-05-release:1.12
	drow_intercu-merge-20040402:1.12
	drow_intercu-merge-20040327:1.12
	ezannoni_pie-20040323-branch:1.12.0.14
	ezannoni_pie-20040323-branchpoint:1.12
	cagney_tramp-20040321-mergepoint:1.12
	cagney_tramp-20040309-branch:1.12.0.12
	cagney_tramp-20040309-branchpoint:1.12
	gdb_6_1-branch:1.12.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.12
	drow_intercu-20040221-branch:1.12.0.8
	drow_intercu-20040221-branchpoint:1.12
	binutils-2_15-branch:1.12.0.6
	cagney_bfdfile-20040213-branch:1.12.0.4
	cagney_bfdfile-20040213-branchpoint:1.12
	drow-cplus-merge-20040208:1.12
	carlton_dictionary-20040126-merge:1.12
	cagney_bigcore-20040122-branch:1.12.0.2
	cagney_bigcore-20040122-branchpoint:1.12
	drow-cplus-merge-20040113:1.12
	csl-arm-2003-q4:1.12
	drow-cplus-merge-20031224:1.12
	drow-cplus-merge-20031220:1.12
	carlton_dictionary-20031215-merge:1.12
	drow-cplus-merge-20031214:1.12
	carlton-dictionary-20031111-merge:1.11
	gdb_6_0-2003-10-04-release:1.7.18.1
	kettenis_sparc-20030918-branch:1.9.0.4
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.2
	cagney_x86i386-20030821-branch:1.7.0.20
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.18
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.16
	jimb-ppc64-linux-20030613-branchpoint:1.7
	binutils-2_14:1.7
	cagney_convert-20030606-branch:1.7.0.14
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.12
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.10
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.8
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.6
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	binutils-2_14-branch:1.7.0.4
	binutils-2_14-branchpoint:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.2
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.38
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.36
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.34
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.32
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.30
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.28
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.26
	cagney_offbyone-20030303-branchpoint:1.6
	w32api-2_2:1.6
	mingw-runtime-2_4:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.24
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.22
	cagney-unwind-20030108-branchpoint:1.6
	binutils-2_13_2_1:1.6
	binutils-2_13_2:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.6
	carlton_dictionary-20021115-merge:1.6
	binutils-2_13_1:1.6
	kseitz_interps-20021105-merge:1.6
	kseitz_interps-20021103-merge:1.6
	drow-cplus-merge-20021020:1.6
	drow-cplus-merge-20021025:1.6
	carlton_dictionary-20021025-merge:1.6
	carlton_dictionary-20021011-merge:1.6
	drow-cplus-branch:1.6.0.20
	drow-cplus-branchpoint:1.6
	kseitz_interps-20020930-merge:1.6
	carlton_dictionary-20020927-merge:1.6
	carlton_dictionary-branch:1.6.0.18
	carlton_dictionary-20020920-branchpoint:1.6
	sid-20020905-branchpoint:1.6
	sid-20020905-branch:1.6.0.16
	gdb_5_3-branch:1.6.0.14
	gdb_5_3-2002-09-04-branchpoint:1.6
	kseitz_interps-20020829-merge:1.6
	cagney_sysregs-20020825-branch:1.6.0.12
	cagney_sysregs-20020825-branchpoint:1.6
	readline_4_3-import-branch:1.6.0.10
	readline_4_3-import-branchpoint:1.6
	binutils-2_13:1.6
	gdb_5_2_1-2002-07-23-release:1.5
	binutils-2_13-branchpoint:1.6
	binutils-2_13-branch:1.6.0.8
	kseitz_interps-20020528-branch:1.6.0.6
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.4
	cagney_regbuf-20020515-branchpoint:1.6
	binutils-2_12_1:1.5
	jimb-macro-020506-branch:1.6.0.2
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.5
	binutils-2_12:1.5
	gdb_5_2-branch:1.5.0.4
	gdb_5_2-2002-03-03-branchpoint:1.5
	binutils-2_12-branch:1.5.0.2
	binutils-2_12-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.8
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.6
	gdb_5_1-2001-07-29-branchpoint:1.3
	binutils-2_11_2:1.3
	binutils-2_11_1:1.3
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.4
	insight-precleanup-2001-01-01:1.3
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	cygwin-1_1_1:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	egcs_20000222:1.1.1.1
	binutils_latest_snapshot:1.29
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.06.02.03.05.46;	author dj;	state Exp;
branches;
next	1.29;

1.29
date	2013.08.20.06.02.53;	author dj;	state Exp;
branches;
next	1.28;

1.28
date	2012.08.17.21.59.31;	author schwab;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.03.21.05.58;	author dj;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.06.12.56.23;	author uweigand;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.13.15.12.42;	author dj;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.13.01.00.40;	author dj;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.13.00.38.30;	author jsm28;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.08.00.08.48;	author jsm28;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.07.15.17.40;	author jules;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.24.21.34.41;	author jules;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.12.15.54.25;	author dj;	state Exp;
branches
	1.19.6.1;
next	1.18;

1.18
date	2005.12.17.20.51.56;	author dj;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.31.18.01.19;	author dj;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.17.18.03.42;	author dj;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.12.10.35.00;	author dj;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.10.15.33.33;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.28.02.09.01;	author dj;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.03.19.03.29;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.31.13.10.32;	author dj;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.22.17.41.02;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.16.01.47.54;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.15.20.14.39;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.15.21.29.34;	author dj;	state Exp;
branches
	1.7.18.1;
next	1.6;

1.6
date	2002.03.06.06.29.42;	author cagney;	state Exp;
branches
	1.6.18.1
	1.6.20.1;
next	1.5;

1.5
date	2001.08.21.00.20.07;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.14.01.34.00;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.31.10.54.59;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	99.08.03.16.00.39;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.54;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.19.6.1
date	2006.04.24.21.37.24;	author jules;	state Exp;
branches;
next	1.19.6.2;

1.19.6.2
date	2006.08.18.11.56.44;	author jules;	state Exp;
branches;
next	;

1.7.18.1
date	2003.09.21.19.11.47;	author drow;	state Exp;
branches;
next	;

1.6.18.1
date	2003.04.16.19.57.04;	author carlton;	state Exp;
branches;
next	1.6.18.2;

1.6.18.2
date	2003.09.17.21.28.56;	author carlton;	state Exp;
branches;
next	1.6.18.3;

1.6.18.3
date	2003.11.11.23.51.15;	author carlton;	state Exp;
branches;
next	1.6.18.4;

1.6.18.4
date	2003.12.16.00.01.10;	author carlton;	state Exp;
branches;
next	;

1.6.20.1
date	2003.12.14.20.28.03;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.54;	author rth;	state Exp;
branches;
next	;


desc
@@


1.30
log
@merge from gcc
@
text
@/* IEEE floating point support routines, for GDB, the GNU Debugger.
   Copyright 1991, 1994, 1999, 2000, 2003, 2005, 2006, 2010, 2012, 2015
   Free Software Foundation, Inc.

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

/* This is needed to pick up the NAN macro on some systems.  */
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <math.h>

#ifdef HAVE_STRING_H
#include <string.h>
#endif

/* On some platforms, <float.h> provides DBL_QNAN.  */
#ifdef STDC_HEADERS
#include <float.h>
#endif

#include "ansidecl.h"
#include "libiberty.h"
#include "floatformat.h"

#ifndef INFINITY
#ifdef HUGE_VAL
#define INFINITY HUGE_VAL
#else
#define INFINITY (1.0 / 0.0)
#endif
#endif

#ifndef NAN
#ifdef DBL_QNAN
#define NAN DBL_QNAN
#else
#define NAN (0.0 / 0.0)
#endif
#endif

static int mant_bits_set (const struct floatformat *, const unsigned char *);
static unsigned long get_field (const unsigned char *,
                                enum floatformat_byteorders,
                                unsigned int,
                                unsigned int,
                                unsigned int);
static int floatformat_always_valid (const struct floatformat *fmt,
                                     const void *from);

static int
floatformat_always_valid (const struct floatformat *fmt ATTRIBUTE_UNUSED,
                          const void *from ATTRIBUTE_UNUSED)
{
  return 1;
}

/* The odds that CHAR_BIT will be anything but 8 are low enough that I'm not
   going to bother with trying to muck around with whether it is defined in
   a system header, what we do if not, etc.  */
#define FLOATFORMAT_CHAR_BIT 8

/* floatformats for IEEE half, single and double, big and little endian.  */
const struct floatformat floatformat_ieee_half_big =
{
  floatformat_big, 16, 0, 1, 5, 15, 31, 6, 10,
  floatformat_intbit_no,
  "floatformat_ieee_half_big",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_ieee_half_little =
{
  floatformat_little, 16, 0, 1, 5, 15, 31, 6, 10,
  floatformat_intbit_no,
  "floatformat_ieee_half_little",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_ieee_single_big =
{
  floatformat_big, 32, 0, 1, 8, 127, 255, 9, 23,
  floatformat_intbit_no,
  "floatformat_ieee_single_big",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_ieee_single_little =
{
  floatformat_little, 32, 0, 1, 8, 127, 255, 9, 23,
  floatformat_intbit_no,
  "floatformat_ieee_single_little",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_ieee_double_big =
{
  floatformat_big, 64, 0, 1, 11, 1023, 2047, 12, 52,
  floatformat_intbit_no,
  "floatformat_ieee_double_big",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_ieee_double_little =
{
  floatformat_little, 64, 0, 1, 11, 1023, 2047, 12, 52,
  floatformat_intbit_no,
  "floatformat_ieee_double_little",
  floatformat_always_valid,
  NULL
};

/* floatformat for IEEE double, little endian byte order, with big endian word
   ordering, as on the ARM.  */

const struct floatformat floatformat_ieee_double_littlebyte_bigword =
{
  floatformat_littlebyte_bigword, 64, 0, 1, 11, 1023, 2047, 12, 52,
  floatformat_intbit_no,
  "floatformat_ieee_double_littlebyte_bigword",
  floatformat_always_valid,
  NULL
};

/* floatformat for VAX.  Not quite IEEE, but close enough.  */

const struct floatformat floatformat_vax_f =
{
  floatformat_vax, 32, 0, 1, 8, 129, 0, 9, 23,
  floatformat_intbit_no,
  "floatformat_vax_f",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_vax_d =
{
  floatformat_vax, 64, 0, 1, 8, 129, 0, 9, 55,
  floatformat_intbit_no,
  "floatformat_vax_d",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_vax_g =
{
  floatformat_vax, 64, 0, 1, 11, 1025, 0, 12, 52,
  floatformat_intbit_no,
  "floatformat_vax_g",
  floatformat_always_valid,
  NULL
};

static int floatformat_i387_ext_is_valid (const struct floatformat *fmt,
					  const void *from);

static int
floatformat_i387_ext_is_valid (const struct floatformat *fmt, const void *from)
{
  /* In the i387 double-extended format, if the exponent is all ones,
     then the integer bit must be set.  If the exponent is neither 0
     nor ~0, the intbit must also be set.  Only if the exponent is
     zero can it be zero, and then it must be zero.  */
  unsigned long exponent, int_bit;
  const unsigned char *ufrom = (const unsigned char *) from;

  exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			fmt->exp_start, fmt->exp_len);
  int_bit = get_field (ufrom, fmt->byteorder, fmt->totalsize,
		       fmt->man_start, 1);

  if ((exponent == 0) != (int_bit == 0))
    return 0;
  else
    return 1;
}

const struct floatformat floatformat_i387_ext =
{
  floatformat_little, 80, 0, 1, 15, 0x3fff, 0x7fff, 16, 64,
  floatformat_intbit_yes,
  "floatformat_i387_ext",
  floatformat_i387_ext_is_valid,
  NULL
};
const struct floatformat floatformat_m68881_ext =
{
  /* Note that the bits from 16 to 31 are unused.  */
  floatformat_big, 96, 0, 1, 15, 0x3fff, 0x7fff, 32, 64,
  floatformat_intbit_yes,
  "floatformat_m68881_ext",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_i960_ext =
{
  /* Note that the bits from 0 to 15 are unused.  */
  floatformat_little, 96, 16, 17, 15, 0x3fff, 0x7fff, 32, 64,
  floatformat_intbit_yes,
  "floatformat_i960_ext",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_m88110_ext =
{
  floatformat_big, 80, 0, 1, 15, 0x3fff, 0x7fff, 16, 64,
  floatformat_intbit_yes,
  "floatformat_m88110_ext",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_m88110_harris_ext =
{
  /* Harris uses raw format 128 bytes long, but the number is just an ieee
     double, and the last 64 bits are wasted. */
  floatformat_big,128, 0, 1, 11,  0x3ff,  0x7ff, 12, 52,
  floatformat_intbit_no,
  "floatformat_m88110_ext_harris",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_arm_ext_big =
{
  /* Bits 1 to 16 are unused.  */
  floatformat_big, 96, 0, 17, 15, 0x3fff, 0x7fff, 32, 64,
  floatformat_intbit_yes,
  "floatformat_arm_ext_big",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_arm_ext_littlebyte_bigword =
{
  /* Bits 1 to 16 are unused.  */
  floatformat_littlebyte_bigword, 96, 0, 17, 15, 0x3fff, 0x7fff, 32, 64,
  floatformat_intbit_yes,
  "floatformat_arm_ext_littlebyte_bigword",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_ia64_spill_big =
{
  floatformat_big, 128, 0, 1, 17, 65535, 0x1ffff, 18, 64,
  floatformat_intbit_yes,
  "floatformat_ia64_spill_big",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_ia64_spill_little =
{
  floatformat_little, 128, 0, 1, 17, 65535, 0x1ffff, 18, 64,
  floatformat_intbit_yes,
  "floatformat_ia64_spill_little",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_ia64_quad_big =
{
  floatformat_big, 128, 0, 1, 15, 16383, 0x7fff, 16, 112,
  floatformat_intbit_no,
  "floatformat_ia64_quad_big",
  floatformat_always_valid,
  NULL
};
const struct floatformat floatformat_ia64_quad_little =
{
  floatformat_little, 128, 0, 1, 15, 16383, 0x7fff, 16, 112,
  floatformat_intbit_no,
  "floatformat_ia64_quad_little",
  floatformat_always_valid,
  NULL
};

static int
floatformat_ibm_long_double_is_valid (const struct floatformat *fmt,
				      const void *from)
{
  const unsigned char *ufrom = (const unsigned char *) from;
  const struct floatformat *hfmt = fmt->split_half;
  long top_exp, bot_exp;
  int top_nan = 0;

  top_exp = get_field (ufrom, hfmt->byteorder, hfmt->totalsize,
		       hfmt->exp_start, hfmt->exp_len);
  bot_exp = get_field (ufrom + 8, hfmt->byteorder, hfmt->totalsize,
		       hfmt->exp_start, hfmt->exp_len);

  if ((unsigned long) top_exp == hfmt->exp_nan)
    top_nan = mant_bits_set (hfmt, ufrom);

  /* A NaN is valid with any low part.  */
  if (top_nan)
    return 1;

  /* An infinity, zero or denormal requires low part 0 (positive or
     negative).  */
  if ((unsigned long) top_exp == hfmt->exp_nan || top_exp == 0)
    {
      if (bot_exp != 0)
	return 0;

      return !mant_bits_set (hfmt, ufrom + 8);
    }

  /* The top part is now a finite normal value.  The long double value
     is the sum of the two parts, and the top part must equal the
     result of rounding the long double value to nearest double.  Thus
     the bottom part must be <= 0.5ulp of the top part in absolute
     value, and if it is < 0.5ulp then the long double is definitely
     valid.  */
  if (bot_exp < top_exp - 53)
    return 1;
  if (bot_exp > top_exp - 53 && bot_exp != 0)
    return 0;
  if (bot_exp == 0)
    {
      /* The bottom part is 0 or denormal.  Determine which, and if
	 denormal the first two set bits.  */
      int first_bit = -1, second_bit = -1, cur_bit;
      for (cur_bit = 0; (unsigned int) cur_bit < hfmt->man_len; cur_bit++)
	if (get_field (ufrom + 8, hfmt->byteorder, hfmt->totalsize,
		       hfmt->man_start + cur_bit, 1))
	  {
	    if (first_bit == -1)
	      first_bit = cur_bit;
	    else
	      {
		second_bit = cur_bit;
		break;
	      }
	  }
      /* Bottom part 0 is OK.  */
      if (first_bit == -1)
	return 1;
      /* The real exponent of the bottom part is -first_bit.  */
      if (-first_bit < top_exp - 53)
	return 1;
      if (-first_bit > top_exp - 53)
	return 0;
      /* The bottom part is at least 0.5ulp of the top part.  For this
	 to be OK, the bottom part must be exactly 0.5ulp (i.e. no
	 more bits set) and the top part must have last bit 0.  */
      if (second_bit != -1)
	return 0;
      return !get_field (ufrom, hfmt->byteorder, hfmt->totalsize,
			 hfmt->man_start + hfmt->man_len - 1, 1);
    }
  else
    {
      /* The bottom part is at least 0.5ulp of the top part.  For this
	 to be OK, it must be exactly 0.5ulp (i.e. no explicit bits
	 set) and the top part must have last bit 0.  */
      if (get_field (ufrom, hfmt->byteorder, hfmt->totalsize,
		     hfmt->man_start + hfmt->man_len - 1, 1))
	return 0;
      return !mant_bits_set (hfmt, ufrom + 8);
    }
}

const struct floatformat floatformat_ibm_long_double_big =
{
  floatformat_big, 128, 0, 1, 11, 1023, 2047, 12, 52,
  floatformat_intbit_no,
  "floatformat_ibm_long_double_big",
  floatformat_ibm_long_double_is_valid,
  &floatformat_ieee_double_big
};

const struct floatformat floatformat_ibm_long_double_little =
{
  floatformat_little, 128, 0, 1, 11, 1023, 2047, 12, 52,
  floatformat_intbit_no,
  "floatformat_ibm_long_double_little",
  floatformat_ibm_long_double_is_valid,
  &floatformat_ieee_double_little
};


#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif

/* Return 1 if any bits are explicitly set in the mantissa of UFROM,
   format FMT, 0 otherwise.  */
static int
mant_bits_set (const struct floatformat *fmt, const unsigned char *ufrom)
{
  unsigned int mant_bits, mant_off;
  int mant_bits_left;

  mant_off = fmt->man_start;
  mant_bits_left = fmt->man_len;
  while (mant_bits_left > 0)
    {
      mant_bits = min (mant_bits_left, 32);

      if (get_field (ufrom, fmt->byteorder, fmt->totalsize,
		     mant_off, mant_bits) != 0)
	return 1;

      mant_off += mant_bits;
      mant_bits_left -= mant_bits;
    }
  return 0;
}

/* Extract a field which starts at START and is LEN bits long.  DATA and
   TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
static unsigned long
get_field (const unsigned char *data, enum floatformat_byteorders order,
           unsigned int total_len, unsigned int start, unsigned int len)
{
  unsigned long result = 0;
  unsigned int cur_byte;
  int lo_bit, hi_bit, cur_bitshift = 0;
  int nextbyte = (order == floatformat_little) ? 1 : -1;

  /* Start is in big-endian bit order!  Fix that first.  */
  start = total_len - (start + len);

  /* Start at the least significant part of the field.  */
  if (order == floatformat_little)
    cur_byte = start / FLOATFORMAT_CHAR_BIT;
  else
    cur_byte = (total_len - start - 1) / FLOATFORMAT_CHAR_BIT;

  lo_bit = start % FLOATFORMAT_CHAR_BIT;
  hi_bit = min (lo_bit + len, FLOATFORMAT_CHAR_BIT);
  
  do
    {
      unsigned int shifted = *(data + cur_byte) >> lo_bit;
      unsigned int bits = hi_bit - lo_bit;
      unsigned int mask = (1 << bits) - 1;
      result |= (shifted & mask) << cur_bitshift;
      len -= bits;
      cur_bitshift += bits;
      cur_byte += nextbyte;
      lo_bit = 0;
      hi_bit = min (len, FLOATFORMAT_CHAR_BIT);
    }
  while (len != 0);

  return result;
}
  
/* Convert from FMT to a double.
   FROM is the address of the extended float.
   Store the double in *TO.  */

void
floatformat_to_double (const struct floatformat *fmt,
                       const void *from, double *to)
{
  const unsigned char *ufrom = (const unsigned char *) from;
  double dto;
  long exponent;
  unsigned long mant;
  unsigned int mant_bits, mant_off;
  int mant_bits_left;

  /* Split values are not handled specially, since the top half has
     the correctly rounded double value (in the only supported case of
     split values).  */

  exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			fmt->exp_start, fmt->exp_len);

  /* If the exponent indicates a NaN, we don't have information to
     decide what to do.  So we handle it like IEEE, except that we
     don't try to preserve the type of NaN.  FIXME.  */
  if ((unsigned long) exponent == fmt->exp_nan)
    {
      int nan = mant_bits_set (fmt, ufrom);

      /* On certain systems (such as GNU/Linux), the use of the
	 INFINITY macro below may generate a warning that can not be
	 silenced due to a bug in GCC (PR preprocessor/11931).  The
	 preprocessor fails to recognise the __extension__ keyword in
	 conjunction with the GNU/C99 extension for hexadecimal
	 floating point constants and will issue a warning when
	 compiling with -pedantic.  */
      if (nan)
	dto = NAN;
      else
	dto = INFINITY;

      if (get_field (ufrom, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1))
	dto = -dto;

      *to = dto;

      return;
    }

  mant_bits_left = fmt->man_len;
  mant_off = fmt->man_start;
  dto = 0.0;

  /* Build the result algebraically.  Might go infinite, underflow, etc;
     who cares. */

  /* For denorms use minimum exponent.  */
  if (exponent == 0)
    exponent = 1 - fmt->exp_bias;
  else
    {
      exponent -= fmt->exp_bias;

      /* If this format uses a hidden bit, explicitly add it in now.
	 Otherwise, increment the exponent by one to account for the
	 integer bit.  */

      if (fmt->intbit == floatformat_intbit_no)
	dto = ldexp (1.0, exponent);
      else
	exponent++;
    }

  while (mant_bits_left > 0)
    {
      mant_bits = min (mant_bits_left, 32);

      mant = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			 mant_off, mant_bits);

      dto += ldexp ((double) mant, exponent - mant_bits);
      exponent -= mant_bits;
      mant_off += mant_bits;
      mant_bits_left -= mant_bits;
    }

  /* Negate it if negative.  */
  if (get_field (ufrom, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1))
    dto = -dto;
  *to = dto;
}

static void put_field (unsigned char *, enum floatformat_byteorders,
                       unsigned int,
                       unsigned int,
                       unsigned int,
                       unsigned long);

/* Set a field which starts at START and is LEN bits long.  DATA and
   TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
static void
put_field (unsigned char *data, enum floatformat_byteorders order,
           unsigned int total_len, unsigned int start, unsigned int len,
           unsigned long stuff_to_put)
{
  unsigned int cur_byte;
  int lo_bit, hi_bit;
  int nextbyte = (order == floatformat_little) ? 1 : -1;

  /* Start is in big-endian bit order!  Fix that first.  */
  start = total_len - (start + len);

  /* Start at the least significant part of the field.  */
  if (order == floatformat_little)
    cur_byte = start / FLOATFORMAT_CHAR_BIT;
  else
    cur_byte = (total_len - start - 1) / FLOATFORMAT_CHAR_BIT;

  lo_bit = start % FLOATFORMAT_CHAR_BIT;
  hi_bit = min (lo_bit + len, FLOATFORMAT_CHAR_BIT);
  
  do
    {
      unsigned char *byte_ptr = data + cur_byte;
      unsigned int bits = hi_bit - lo_bit;
      unsigned int mask = ((1 << bits) - 1) << lo_bit;
      *byte_ptr = (*byte_ptr & ~mask) | ((stuff_to_put << lo_bit) & mask);
      stuff_to_put >>= bits;
      len -= bits;
      cur_byte += nextbyte;
      lo_bit = 0;
      hi_bit = min (len, FLOATFORMAT_CHAR_BIT);
    }
  while (len != 0);
}

/* The converse: convert the double *FROM to an extended float
   and store where TO points.  Neither FROM nor TO have any alignment
   restrictions.  */

void
floatformat_from_double (const struct floatformat *fmt,
                         const double *from, void *to)
{
  double dfrom;
  int exponent;
  double mant;
  unsigned int mant_bits, mant_off;
  int mant_bits_left;
  unsigned char *uto = (unsigned char *) to;

  dfrom = *from;
  memset (uto, 0, fmt->totalsize / FLOATFORMAT_CHAR_BIT);

  /* Split values are not handled specially, since a bottom half of
     zero is correct for any value representable as double (in the
     only supported case of split values).  */

  /* If negative, set the sign bit.  */
  if (dfrom < 0)
    {
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1, 1);
      dfrom = -dfrom;
    }

  if (dfrom == 0)
    {
      /* 0.0.  */
      return;
    }

  if (dfrom != dfrom)
    {
      /* NaN.  */
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,
		 fmt->exp_len, fmt->exp_nan);
      /* Be sure it's not infinity, but NaN value is irrelevant.  */
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->man_start,
		 32, 1);
      return;
    }

  if (dfrom + dfrom == dfrom)
    {
      /* This can only happen for an infinite value (or zero, which we
	 already handled above).  */
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,
		 fmt->exp_len, fmt->exp_nan);
      return;
    }

  mant = frexp (dfrom, &exponent);
  if (exponent + fmt->exp_bias - 1 > 0)
    put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,
	       fmt->exp_len, exponent + fmt->exp_bias - 1);
  else
    {
      /* Handle a denormalized number.  FIXME: What should we do for
	 non-IEEE formats?  */
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,
		 fmt->exp_len, 0);
      mant = ldexp (mant, exponent + fmt->exp_bias - 1);
    }

  mant_bits_left = fmt->man_len;
  mant_off = fmt->man_start;
  while (mant_bits_left > 0)
    {
      unsigned long mant_long;
      mant_bits = mant_bits_left < 32 ? mant_bits_left : 32;

      mant *= 4294967296.0;
      mant_long = (unsigned long)mant;
      mant -= mant_long;

      /* If the integer bit is implicit, and we are not creating a
	 denormalized number, then we need to discard it.  */
      if ((unsigned int) mant_bits_left == fmt->man_len
	  && fmt->intbit == floatformat_intbit_no
	  && exponent + fmt->exp_bias - 1 > 0)
	{
	  mant_long &= 0x7fffffff;
	  mant_bits -= 1;
	}
      else if (mant_bits < 32)
	{
	  /* The bits we want are in the most significant MANT_BITS bits of
	     mant_long.  Move them to the least significant.  */
	  mant_long >>= 32 - mant_bits;
	}

      put_field (uto, fmt->byteorder, fmt->totalsize,
		 mant_off, mant_bits, mant_long);
      mant_off += mant_bits;
      mant_bits_left -= mant_bits;
    }
}

/* Return non-zero iff the data at FROM is a valid number in format FMT.  */

int
floatformat_is_valid (const struct floatformat *fmt, const void *from)
{
  return fmt->is_valid (fmt, from);
}


#ifdef IEEE_DEBUG

#include <stdio.h>

/* This is to be run on a host which uses IEEE floating point.  */

void
ieee_test (double n)
{
  double result;

  floatformat_to_double (&floatformat_ieee_double_little, &n, &result);
  if ((n != result && (! isnan (n) || ! isnan (result)))
      || (n < 0 && result >= 0)
      || (n >= 0 && result < 0))
    printf ("Differ(to): %.20g -> %.20g\n", n, result);

  floatformat_from_double (&floatformat_ieee_double_little, &n, &result);
  if ((n != result && (! isnan (n) || ! isnan (result)))
      || (n < 0 && result >= 0)
      || (n >= 0 && result < 0))
    printf ("Differ(from): %.20g -> %.20g\n", n, result);

#if 0
  {
    char exten[16];

    floatformat_from_double (&floatformat_m68881_ext, &n, exten);
    floatformat_to_double (&floatformat_m68881_ext, exten, &result);
    if (n != result)
      printf ("Differ(to+from): %.20g -> %.20g\n", n, result);
  }
#endif

#if IEEE_DEBUG > 1
  /* This is to be run on a host which uses 68881 format.  */
  {
    long double ex = *(long double *)exten;
    if (ex != n)
      printf ("Differ(from vs. extended): %.20g\n", n);
  }
#endif
}

int
main (void)
{
  ieee_test (0.0);
  ieee_test (0.5);
  ieee_test (1.1);
  ieee_test (256.0);
  ieee_test (0.12345);
  ieee_test (234235.78907234);
  ieee_test (-512.0);
  ieee_test (-0.004321);
  ieee_test (1.2E-70);
  ieee_test (1.2E-316);
  ieee_test (4.9406564584124654E-324);
  ieee_test (- 4.9406564584124654E-324);
  ieee_test (- 0.0);
  ieee_test (- INFINITY);
  ieee_test (- NAN);
  ieee_test (INFINITY);
  ieee_test (NAN);
  return 0;
}
#endif
@


1.29
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright 1991, 1994, 1999, 2000, 2003, 2005, 2006, 2010, 2012
d22 1
d24 1
@


1.28
log
@* floatformat.c (floatformat_to_double): Correctly handle numbers
between 1 and 2.  Simplify handling of denormal number.
(main): Test with 1.1.
@
text
@d374 1
a374 1
const struct floatformat floatformat_ibm_long_double =
d378 1
a378 1
  "floatformat_ibm_long_double",
d382 9
@


1.27
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright 1991, 1994, 1999, 2000, 2003, 2005, 2006, 2010
a465 1
  int special_exponent;		/* It's a NaN, denorm or zero */
a504 6
  special_exponent = exponent == 0 || (unsigned long) exponent == fmt->exp_nan;

  /* Don't bias zero's, denorms or NaNs.  */
  if (!special_exponent)
    exponent -= fmt->exp_bias;

d508 10
a517 2
  /* If this format uses a hidden bit, explicitly add it in now.  Otherwise,
     increment the exponent by one to account for the integer bit.  */
a518 2
  if (!special_exponent)
    {
d532 2
a533 12
      /* Handle denormalized numbers.  FIXME: What should we do for
	 non-IEEE formats?  */
      if (special_exponent && exponent == 0 && mant != 0)
	dto += ldexp ((double)mant,
		      (- fmt->exp_bias
		       - mant_bits
		       - (mant_off - fmt->man_start)
		       + 1));
      else
	dto += ldexp ((double)mant, exponent - mant_bits);
      if (exponent != 0)
	exponent -= mant_bits;
d748 1
@


1.26
log
@include/ChangeLog:

2010-07-06  Ken Werner  <ken.werner@@de.ibm.com>

	* floatformat.h (floatformat_ieee_half_big): Add declaration.
	(floatformat_ieee_half_little): Likewise.

libiberty/ChangeLog:

2010-07-06  Ken Werner  <ken.werner@@de.ibm.com>

	* floatformat.c (floatformat_ieee_half_big): New variable.
	(floatformat_ieee_half_little): Likewise.

gdb/ChangeLog:

2010-07-06  Ken Werner  <ken.werner@@de.ibm.com>

	* gdbtypes.h (floatformats_ieee_half): Add declaration.
	* gdbtypes.c (floatformats_ieee_half): New variable.
	* doublest.c (floatformat_from_length): Set format to
	gdbarch_half_format if length matches.
	* gdbarch.sh (half_bit): New architecture method.
	(half_format): Likewise.
	* gdbarch.h: Regenerate.
	* gdbarch.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1991, 1994, 1999, 2000, 2003, 2005, 2006
@


1.25
log
@merge from gcc
@
text
@d80 17
a96 1
/* floatformats for IEEE single and double, big and little endian.  */
@


1.24
log
@merge from gcc
@
text
@d286 1
a286 1
  if (top_exp == hfmt->exp_nan)
d295 1
a295 1
  if (top_exp == hfmt->exp_nan || top_exp == 0)
a296 3
      unsigned int mant_bits, mant_off;
      int mant_bits_left;

d318 1
a318 1
      for (cur_bit = 0; cur_bit < hfmt->man_len; cur_bit++)
d363 1
a363 1
  floatformat_always_valid,
@


1.23
log
@	* floatformat.c (floatformat_ibm_long_double_is_valid): Fix
	compiler warnings.
	(floatformat_ibm_long_double): Use
	floatformat_ibm_long_double_is_valid.
@
text
@d286 1
a286 1
  if ((unsigned long) top_exp == hfmt->exp_nan)
d295 1
a295 1
  if ((unsigned long) top_exp == hfmt->exp_nan || top_exp == 0)
d297 3
d321 1
a321 1
      for (cur_bit = 0; (unsigned int) cur_bit < hfmt->man_len; cur_bit++)
d366 1
a366 1
  floatformat_ibm_long_double_is_valid,
@


1.22
log
@include:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* floatformat.h (struct floatformat): Add split_half field.
	(floatformat_ibm_long_double): New.

libiberty:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* floatformat.c (mant_bits_set): New.
	(floatformat_to_double): Use it.  Note no special handling of
	split formats.
	(floatformat_from_double): Note no special handing of split
	formats.
	(floatformat_ibm_long_double_is_valid,
	floatformat_ibm_long_double): New.
	(floatformat_ieee_single_big, floatformat_ieee_single_little,
	floatformat_ieee_double_big, floatformat_ieee_double_little,
	floatformat_ieee_double_littlebyte_bigword, floatformat_vax_f,
	floatformat_vax_d, floatformat_vax_g, floatformat_i387_ext,
	floatformat_m68881_ext, floatformat_i960_ext,
	floatformat_m88110_ext, floatformat_m88110_harris_ext,
	floatformat_arm_ext_big, floatformat_arm_ext_littlebyte_bigword,
	floatformat_ia64_spill_big, floatformat_ia64_spill_little,
	floatformat_ia64_quad_big, floatformat_ia64_quad_little): Update
	for addition of split_half field.

gdb:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdbtypes.c (floatformats_ibm_long_double): New.
	* gdbtypes.h (floatformats_ibm_long_double): Declare.
	* ia64-tdep.c (floatformat_ia64_ext): Update for addition of
	split_half field.
	* mips-tdep.c (n32n64_floatformat_always_valid,
	floatformat_n32n64_long_double_big, floatformats_n32n64_long):
	Remove.
	(mips_gdbarch_init): Use floatformats_ibm_long_double instead of
	floatformats_n32n64_long.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Use 128-bit IBM long
	double.
	* doublest.c (convert_floatformat_to_doublest,
	convert_doublest_to_floatformat): Handle split floating-point
	formats.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Handle IBM long
	double arguments.
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	(do_ppc_sysv_return_value): Handle IBM long double return.
@
text
@d286 1
a286 1
  if (top_exp == hfmt->exp_nan)
d295 1
a295 1
  if (top_exp == hfmt->exp_nan || top_exp == 0)
a296 3
      unsigned int mant_bits, mant_off;
      int mant_bits_left;

d318 1
a318 1
      for (cur_bit = 0; cur_bit < hfmt->man_len; cur_bit++)
d363 1
a363 1
  floatformat_always_valid,
@


1.21
log
@	* floatformat.c (get_field): Fix segfault with little-endian word
	order on 64-bit hosts.
	(put_field): Likewise.
	(min): Move definition.
@
text
@d59 1
d86 2
a87 1
  floatformat_always_valid
d94 2
a95 1
  floatformat_always_valid
d102 2
a103 1
  floatformat_always_valid
d110 2
a111 1
  floatformat_always_valid
d122 2
a123 1
  floatformat_always_valid
d133 2
a134 1
  floatformat_always_valid
d141 2
a142 1
  floatformat_always_valid
d149 2
a150 1
  floatformat_always_valid
d182 2
a183 1
  floatformat_i387_ext_is_valid
d191 2
a192 1
  floatformat_always_valid
d200 2
a201 1
  floatformat_always_valid
d208 2
a209 1
  floatformat_always_valid
d218 2
a219 1
  floatformat_always_valid
d227 2
a228 1
  floatformat_always_valid
d236 2
a237 1
  floatformat_always_valid
d244 2
a245 1
  floatformat_always_valid
d252 2
a253 1
  floatformat_always_valid
d260 2
a261 1
  floatformat_always_valid
d268 100
a367 1
  floatformat_always_valid
d375 24
d455 4
d467 1
a467 20
      int nan;

      mant_off = fmt->man_start;
      mant_bits_left = fmt->man_len;
      nan = 0;
      while (mant_bits_left > 0)
	{
	  mant_bits = min (mant_bits_left, 32);

	  if (get_field (ufrom, fmt->byteorder, fmt->totalsize,
			 mant_off, mant_bits) != 0)
	    {
	      /* This is a NaN.  */
	      nan = 1;
	      break;
	    }

	  mant_off += mant_bits;
	  mant_bits_left -= mant_bits;
	}
d604 4
@


1.20
log
@	* floatformat.c (floatformat_to_double): Fix (biased) exponent=0 case.
@
text
@d252 5
d263 1
a263 1
  unsigned long result;
d265 5
a269 1
  int cur_bitshift;
a271 1
  cur_byte = (start + len) / FLOATFORMAT_CHAR_BIT;
d273 1
a273 7
    cur_byte = (total_len / FLOATFORMAT_CHAR_BIT) - cur_byte - 1;
  cur_bitshift =
    ((start + len) % FLOATFORMAT_CHAR_BIT) - FLOATFORMAT_CHAR_BIT;
  result = *(data + cur_byte) >> (-cur_bitshift);
  cur_bitshift += FLOATFORMAT_CHAR_BIT;
  if (order == floatformat_little)
    ++cur_byte;
d275 1
a275 1
    --cur_byte;
d277 4
a280 2
  /* Move towards the most significant part of the field.  */
  while ((unsigned int) cur_bitshift < len)
d282 9
a290 13
      if (len - cur_bitshift < FLOATFORMAT_CHAR_BIT)
	/* This is the last byte; zero out the bits which are not part of
	   this field.  */
	result |=
	  (*(data + cur_byte) & ((1 << (len - cur_bitshift)) - 1))
	    << cur_bitshift;
      else
	result |= *(data + cur_byte) << cur_bitshift;
      cur_bitshift += FLOATFORMAT_CHAR_BIT;
      if (order == floatformat_little)
	++cur_byte;
      else
	--cur_byte;
d292 2
a296 4
#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif

d429 5
a433 1
  int cur_bitshift;
a435 10
  cur_byte = (start + len) / FLOATFORMAT_CHAR_BIT;
  if (order == floatformat_little)
    cur_byte = (total_len / FLOATFORMAT_CHAR_BIT) - cur_byte - 1;
  cur_bitshift =
    ((start + len) % FLOATFORMAT_CHAR_BIT) - FLOATFORMAT_CHAR_BIT;
  *(data + cur_byte) &=
    ~(((1 << ((start + len) % FLOATFORMAT_CHAR_BIT)) - 1) << (-cur_bitshift));
  *(data + cur_byte) |=
    (stuff_to_put & ((1 << FLOATFORMAT_CHAR_BIT) - 1)) << (-cur_bitshift);
  cur_bitshift += FLOATFORMAT_CHAR_BIT;
d437 1
a437 1
    ++cur_byte;
d439 1
a439 1
    --cur_byte;
d441 4
a444 2
  /* Move towards the most significant part of the field.  */
  while ((unsigned int) cur_bitshift < len)
d446 9
a454 15
      if (len - cur_bitshift < FLOATFORMAT_CHAR_BIT)
	{
	  /* This is the last byte.  */
	  *(data + cur_byte) &=
	    ~((1 << (len - cur_bitshift)) - 1);
	  *(data + cur_byte) |= (stuff_to_put >> cur_bitshift);
	}
      else
	*(data + cur_byte) = ((stuff_to_put >> cur_bitshift)
			      & ((1 << FLOATFORMAT_CHAR_BIT) - 1));
      cur_bitshift += FLOATFORMAT_CHAR_BIT;
      if (order == floatformat_little)
	++cur_byte;
      else
	--cur_byte;
d456 1
@


1.19
log
@merge from gcc
@
text
@d397 1
a397 1
      if (exponent == 0 && mant != 0)
@


1.19.6.1
log
@	* libiberty/floatformat.c (floatformat_to_double): Fix (biased)
	exponent=0 case.
@
text
@d397 1
a397 1
      if (special_exponent && exponent == 0 && mant != 0)
@


1.19.6.2
log
@	libiberty/
	* floatformat.c (get_field): Fix segfault with little-endian word
	order on 64-bit hosts.
	(put_field): Likewise.
	(min): Move definition.
@
text
@a251 5

#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif

d258 1
a258 1
  unsigned long result = 0;
d260 1
a260 5
  int lo_bit, hi_bit, cur_bitshift = 0;
  int nextbyte = (order == floatformat_little) ? 1 : -1;

  /* Start is in big-endian bit order!  Fix that first.  */
  start = total_len - (start + len);
d263 1
d265 7
a271 1
    cur_byte = start / FLOATFORMAT_CHAR_BIT;
d273 1
a273 1
    cur_byte = (total_len - start - 1) / FLOATFORMAT_CHAR_BIT;
d275 2
a276 4
  lo_bit = start % FLOATFORMAT_CHAR_BIT;
  hi_bit = min (lo_bit + len, FLOATFORMAT_CHAR_BIT);
  
  do
d278 13
a290 9
      unsigned int shifted = *(data + cur_byte) >> lo_bit;
      unsigned int bits = hi_bit - lo_bit;
      unsigned int mask = (1 << bits) - 1;
      result |= (shifted & mask) << cur_bitshift;
      len -= bits;
      cur_bitshift += bits;
      cur_byte += nextbyte;
      lo_bit = 0;
      hi_bit = min (len, FLOATFORMAT_CHAR_BIT);
a291 2
  while (len != 0);

d295 4
d431 1
a431 5
  int lo_bit, hi_bit;
  int nextbyte = (order == floatformat_little) ? 1 : -1;

  /* Start is in big-endian bit order!  Fix that first.  */
  start = total_len - (start + len);
d434 10
d445 1
a445 1
    cur_byte = start / FLOATFORMAT_CHAR_BIT;
d447 1
a447 1
    cur_byte = (total_len - start - 1) / FLOATFORMAT_CHAR_BIT;
d449 2
a450 4
  lo_bit = start % FLOATFORMAT_CHAR_BIT;
  hi_bit = min (lo_bit + len, FLOATFORMAT_CHAR_BIT);
  
  do
d452 15
a466 9
      unsigned char *byte_ptr = data + cur_byte;
      unsigned int bits = hi_bit - lo_bit;
      unsigned int mask = ((1 << bits) - 1) << lo_bit;
      *byte_ptr = (*byte_ptr & ~mask) | ((stuff_to_put << lo_bit) & mask);
      stuff_to_put >>= bits;
      len -= bits;
      cur_byte += nextbyte;
      lo_bit = 0;
      hi_bit = min (len, FLOATFORMAT_CHAR_BIT);
a467 1
  while (len != 0);
@


1.18
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright 1991, 1994, 1999, 2000, 2003, 2005
d34 5
d52 3
d57 1
@


1.17
log
@merge from gcc
@
text
@d146 1
a146 1
  const unsigned char *ufrom = from;
d298 1
a298 1
  const unsigned char *ufrom = from;
d474 1
a474 1
  unsigned char *uto = to;
@


1.16
log
@merge from gcc
@
text
@d111 24
@


1.15
log
@merge from gcc
@
text
@d2 2
a3 1
   Copyright (C) 1991, 1994, 1999, 2000, 2003 Free Software Foundation, Inc.
d56 1
a56 1
                                     const char *from);
d60 1
a60 1
                          const char *from ATTRIBUTE_UNUSED)
d111 2
a112 1
static int floatformat_i387_ext_is_valid (const struct floatformat *fmt, const char *from);
d115 1
a115 1
floatformat_i387_ext_is_valid (const struct floatformat *fmt, const char *from)
d122 2
a123 2
  const unsigned char *ufrom = (const unsigned char *) from;
  
d128 1
a128 1
  
d272 1
a272 1
                       const char *from, double *to)
d274 1
a274 1
  const unsigned char *ufrom = (const unsigned char *)from;
d443 1
a443 1
                         const double *from, char *to)
d450 1
a450 1
  unsigned char *uto = (unsigned char *)to;
d538 1
a538 1
floatformat_is_valid (const struct floatformat *fmt, const char *from)
d555 1
a555 2
  floatformat_to_double (&floatformat_ieee_double_little, (char *) &n,
			 &result);
d561 1
a561 2
  floatformat_from_double (&floatformat_ieee_double_little, &n,
			   (char *) &result);
@


1.14
log
@Update the address and phone number of the FSF organization.
@
text
@d309 7
@


1.13
log
@merge from gcc
@
text
@d18 1
a18 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.12
log
@merge from gcc
@
text
@d49 7
a55 7
static unsigned long get_field PARAMS ((const unsigned char *,
					enum floatformat_byteorders,
					unsigned int,
					unsigned int,
					unsigned int));
static int floatformat_always_valid PARAMS ((const struct floatformat *fmt,
					     const char *from));
d58 2
a59 3
floatformat_always_valid (fmt, from)
     const struct floatformat *fmt ATTRIBUTE_UNUSED;
     const char *from ATTRIBUTE_UNUSED;
d110 1
a110 1
static int floatformat_i387_ext_is_valid PARAMS ((const struct floatformat *fmt, const char *from));
d113 1
a113 3
floatformat_i387_ext_is_valid (fmt, from)
     const struct floatformat *fmt;
     const char *from;
d220 2
a221 6
get_field (data, order, total_len, start, len)
     const unsigned char *data;
     enum floatformat_byteorders order;
     unsigned int total_len;
     unsigned int start;
     unsigned int len;
d269 2
a270 4
floatformat_to_double (fmt, from, to)
     const struct floatformat *fmt;
     const char *from;
     double *to;
d375 5
a379 5
static void put_field PARAMS ((unsigned char *, enum floatformat_byteorders,
			       unsigned int,
			       unsigned int,
			       unsigned int,
			       unsigned long));
d384 3
a386 7
put_field (data, order, total_len, start, len, stuff_to_put)
     unsigned char *data;
     enum floatformat_byteorders order;
     unsigned int total_len;
     unsigned int start;
     unsigned int len;
     unsigned long stuff_to_put;
d433 2
a434 4
floatformat_from_double (fmt, from, to)
     const struct floatformat *fmt;
     const double *from;
     char *to;
d529 1
a529 3
floatformat_is_valid (fmt, from)
     const struct floatformat *fmt;
     const char *from;
d542 1
a542 2
ieee_test (n)
     double n;
d582 1
a582 1
main ()
@


1.11
log
@merge from gcc
@
text
@d20 13
d34 1
d36 4
a39 5
#include <math.h>		/* ldexp */
#ifdef ANSI_PROTOTYPES
#include <stddef.h>
extern void *memcpy (void *s1, const void *s2, size_t n);
extern void *memset (void *s, int c, size_t n);
d41 6
a46 2
extern char *memcpy ();
extern char *memset ();
d291 39
a329 3
  /* Note that if exponent indicates a NaN, we can't really do anything useful
     (not knowing if the host has NaN's, or how to build one).  So it will
     end up as an infinity or something close; that is OK.  */
d362 12
a373 2
      dto += ldexp ((double)mant, exponent - mant_bits);
      exponent -= mant_bits;
d458 1
a458 1
  memcpy (&dfrom, from, sizeof (dfrom));
d460 8
d469 5
a473 1
    return;			/* Result is zero */
d476 1
a476 1
      /* From is NaN */
d479 1
a479 1
      /* Be sure it's not infinity, but NaN value is irrel */
d485 1
a485 2
  /* If negative, set the sign bit.  */
  if (dfrom < 0)
d487 5
a491 2
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1, 1);
      dfrom = -dfrom;
a493 2
  /* How to tell an infinity from an ordinary number?  FIXME-someday */

d495 11
a505 2
  put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start, fmt->exp_len,
	     exponent + fmt->exp_bias - 1);
d518 2
a519 4
      /* If the integer bit is implicit, then we need to discard it.
	 If we are discarding a zero, we should be (but are not) creating
	 a denormalized	number which means adjusting the exponent
	 (I think).  */
d521 2
a522 1
	  && fmt->intbit == floatformat_intbit_no)
d554 2
a562 1
  char exten[16];
d564 5
a568 2
  floatformat_to_double (&floatformat_ieee_double_big, &n, &result);
  if (n != result)
d570 6
a575 2
  floatformat_from_double (&floatformat_ieee_double_big, &n, &result);
  if (n != result)
d578 10
a587 4
  floatformat_from_double (&floatformat_m68881_ext, &n, exten);
  floatformat_to_double (&floatformat_m68881_ext, exten, &result);
  if (n != result)
    printf ("Differ(to+from): %.20g -> %.20g\n", n, result);
d602 1
d609 9
@


1.10
log
@2003-09-22  Andrew Cagney  <cagney@@redhat.com>

	* floatformat.h (struct floatformat): Add field "is_valid".

2003-09-22  Andrew Cagney  <cagney@@redhat.com>

	* floatformat.c (floatformat_i387_ext_is_valid): New function.
	(floatformat_always_valid): New function.
	(floatformat_i387_ext): Initialize new "is_valid" field to
	"floatformat_i387_ext_is_valid".
	(floatformat_ieee_single_little): Initialize "is_valid" field to
	floatformat_always_valid.
	(floatformat_ieee_double_big): Ditto.
	(floatformat_ieee_double_little): Ditto.
	(floatformat_ieee_double_little): Ditto.
	(floatformat_ieee_double_littlebyte_bigword): Ditto.
	(floatformat_i960_ext): Ditto.
	(floatformat_m88110_ext): Ditto.
	(floatformat_m88110_harris_ext): Ditto.
	(floatformat_arm_ext_big): Ditto.
	(floatformat_arm_ext_littlebyte_bigword): Ditto.
	(floatformat_ia64_spill_big): Ditto.
	(floatformat_ia64_spill_little): Ditto.
	(floatformat_ia64_quad_big): Ditto.
	(floatformat_ia64_quad_little): Ditto.
	(floatformat_ia64_quad_little): Ditto.
	(floatformat_is_valid): Call "is_valid".
@
text
@d42 2
a43 2
     const struct floatformat *fmt;
     const char *from;
@


1.9
log
@Index: include/ChangeLog
2003-09-15  Andrew Cagney  <cagney@@redhat.com>

	* floatformat.h (floatformat_to_double): Make input buffer constant.
	(floatformat_from_double, floatformat_is_valid): Ditto.

Index: libiberty/ChangeLog
2003-09-15  Andrew Cagney  <cagney@@redhat.com>

	* floatformat.c (get_field): Make "data" constant.
	(floatformat_is_valid, floatformat_to_double): Make "from"
	constant, fix casts.
	(floatformat_from_double): Make "from" constant.
@
text
@d32 16
d58 2
a59 1
  "floatformat_ieee_single_big"
d65 2
a66 1
  "floatformat_ieee_single_little"
d72 2
a73 1
  "floatformat_ieee_double_big"
d79 2
a80 1
  "floatformat_ieee_double_little"
d90 2
a91 1
  "floatformat_ieee_double_littlebyte_bigword"
d94 25
d123 2
a124 1
  "floatformat_i387_ext"
d131 2
a132 1
  "floatformat_m68881_ext"
d139 2
a140 1
  "floatformat_i960_ext"
d146 2
a147 1
  "floatformat_m88110_ext"
d155 2
a156 1
  "floatformat_m88110_ext_harris"
d163 2
a164 1
  "floatformat_arm_ext_big"
d171 2
a172 1
  "floatformat_arm_ext_littlebyte_bigword"
d178 2
a179 1
  "floatformat_ia64_spill_big"
d185 2
a186 1
  "floatformat_ia64_spill_little"
d192 2
a193 1
  "floatformat_ia64_quad_big"
d199 2
a200 1
  "floatformat_ia64_quad_little"
a202 6
static unsigned long get_field PARAMS ((const unsigned char *,
					enum floatformat_byteorders,
					unsigned int,
					unsigned int,
					unsigned int));

d465 1
a465 24
  if (fmt == &floatformat_i387_ext)
    {
      /* In the i387 double-extended format, if the exponent is all
	 ones, then the integer bit must be set.  If the exponent
	 is neither 0 nor ~0, the intbit must also be set.  Only
	 if the exponent is zero can it be zero, and then it must
	 be zero.  */
      unsigned long exponent, int_bit;
      const unsigned char *ufrom = (const unsigned char *) from;

      exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			    fmt->exp_start, fmt->exp_len);
      int_bit = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			   fmt->man_start, 1);

      if ((exponent == 0) != (int_bit == 0))
	return 0;
      else
	return 1;
    }

  /* Other formats with invalid representations should be added
     here.  */
  return 1;
@


1.8
log
@	* floatformat.c (floatformat_is_valid): New function.
	(get_field, put_field): Correct comments.
@
text
@d146 1
a146 1
static unsigned long get_field PARAMS ((unsigned char *,
d156 1
a156 1
     unsigned char *data;
d210 1
a210 1
     char *from;
d213 1
a213 1
  unsigned char *ufrom = (unsigned char *)from;
d334 1
a334 1
     double *from;
d412 1
a412 1
     char *from;
d422 1
a422 1
      unsigned char *ufrom = (unsigned char *) from;
@


1.7
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright (C) 1991, 1994, 1999, 2000 Free Software Foundation, Inc.
d152 1
a152 1
/* Extract a field which starts at START and is LEN bytes long.  DATA and
d276 1
a276 1
/* Set a field which starts at START and is LEN bytes long.  DATA and
d405 33
@


1.7.18.1
log
@gdb
2003-09-19  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2003-09-15  Daniel Jacobowitz  <drow@@mvista.com>

	* values.c (unpack_double): Call floatformat_is_valid.

include
2003-09-15  Andrew Cagney  <cagney@@redhat.com>

	* floatformat.h (floatformat_to_double): Make input buffer constant.
	(floatformat_from_double, floatformat_is_valid): Ditto.

2003-09-15  Daniel Jacobowitz  <drow@@mvista.com>

	* floatformat.h (floatformat_is_valid): Add prototype.

libiberty
2003-09-15  Andrew Cagney  <cagney@@redhat.com>

	* floatformat.c (get_field): Make "data" constant.
	(floatformat_is_valid, floatformat_to_double): Make "from"
	constant, fix casts.
	(floatformat_from_double): Make "from" constant.

2003-09-15  Daniel Jacobowitz  <drow@@mvista.com>

	* floatformat.c (floatformat_is_valid): New function.
	(get_field, put_field): Correct comments.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 1994, 1999, 2000, 2003 Free Software Foundation, Inc.
d146 1
a146 1
static unsigned long get_field PARAMS ((const unsigned char *,
d152 1
a152 1
/* Extract a field which starts at START and is LEN bits long.  DATA and
d156 1
a156 1
     const unsigned char *data;
d210 1
a210 1
     const char *from;
d213 1
a213 1
  const unsigned char *ufrom = (const unsigned char *)from;
d276 1
a276 1
/* Set a field which starts at START and is LEN bits long.  DATA and
d334 1
a334 1
     const double *from;
a404 33
}

/* Return non-zero iff the data at FROM is a valid number in format FMT.  */

int
floatformat_is_valid (fmt, from)
     const struct floatformat *fmt;
     const char *from;
{
  if (fmt == &floatformat_i387_ext)
    {
      /* In the i387 double-extended format, if the exponent is all
	 ones, then the integer bit must be set.  If the exponent
	 is neither 0 nor ~0, the intbit must also be set.  Only
	 if the exponent is zero can it be zero, and then it must
	 be zero.  */
      unsigned long exponent, int_bit;
      const unsigned char *ufrom = (const unsigned char *) from;

      exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			    fmt->exp_start, fmt->exp_len);
      int_bit = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			   fmt->man_start, 1);

      if ((exponent == 0) != (int_bit == 0))
	return 0;
      else
	return 1;
    }

  /* Other formats with invalid representations should be added
     here.  */
  return 1;
@


1.6
log
@Remove floatformat_arm_ext.
@
text
@d20 1
d23 1
a23 1
#ifdef __STDC__
@


1.6.20.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright (C) 1991, 1994, 1999, 2000, 2003 Free Software Foundation, Inc.
a19 15
/* This is needed to pick up the NAN macro on some systems.  */
#define _GNU_SOURCE

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <math.h>

#ifdef HAVE_STRING_H
#include <string.h>
#endif

#include "ansidecl.h"
#include "libiberty.h"
d21 5
a25 4

#ifndef INFINITY
#ifdef HUGE_VAL
#define INFINITY HUGE_VAL
d27 2
a28 2
#define INFINITY (1.0 / 0.0)
#endif
a30 20
#ifndef NAN
#define NAN (0.0 / 0.0)
#endif

static unsigned long get_field PARAMS ((const unsigned char *,
					enum floatformat_byteorders,
					unsigned int,
					unsigned int,
					unsigned int));
static int floatformat_always_valid PARAMS ((const struct floatformat *fmt,
					     const char *from));

static int
floatformat_always_valid (fmt, from)
     const struct floatformat *fmt ATTRIBUTE_UNUSED;
     const char *from ATTRIBUTE_UNUSED;
{
  return 1;
}

d41 1
a41 2
  "floatformat_ieee_single_big",
  floatformat_always_valid
d47 1
a47 2
  "floatformat_ieee_single_little",
  floatformat_always_valid
d53 1
a53 2
  "floatformat_ieee_double_big",
  floatformat_always_valid
d59 1
a59 2
  "floatformat_ieee_double_little",
  floatformat_always_valid
d69 1
a69 2
  "floatformat_ieee_double_littlebyte_bigword",
  floatformat_always_valid
a71 25
static int floatformat_i387_ext_is_valid PARAMS ((const struct floatformat *fmt, const char *from));

static int
floatformat_i387_ext_is_valid (fmt, from)
     const struct floatformat *fmt;
     const char *from;
{
  /* In the i387 double-extended format, if the exponent is all ones,
     then the integer bit must be set.  If the exponent is neither 0
     nor ~0, the intbit must also be set.  Only if the exponent is
     zero can it be zero, and then it must be zero.  */
  unsigned long exponent, int_bit;
  const unsigned char *ufrom = (const unsigned char *) from;
  
  exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			fmt->exp_start, fmt->exp_len);
  int_bit = get_field (ufrom, fmt->byteorder, fmt->totalsize,
		       fmt->man_start, 1);
  
  if ((exponent == 0) != (int_bit == 0))
    return 0;
  else
    return 1;
}

d76 1
a76 2
  "floatformat_i387_ext",
  floatformat_i387_ext_is_valid
d83 1
a83 2
  "floatformat_m68881_ext",
  floatformat_always_valid
d90 1
a90 2
  "floatformat_i960_ext",
  floatformat_always_valid
d96 1
a96 2
  "floatformat_m88110_ext",
  floatformat_always_valid
d104 1
a104 2
  "floatformat_m88110_ext_harris",
  floatformat_always_valid
d111 1
a111 2
  "floatformat_arm_ext_big",
  floatformat_always_valid
d118 1
a118 2
  "floatformat_arm_ext_littlebyte_bigword",
  floatformat_always_valid
d124 1
a124 2
  "floatformat_ia64_spill_big",
  floatformat_always_valid
d130 1
a130 2
  "floatformat_ia64_spill_little",
  floatformat_always_valid
d136 1
a136 2
  "floatformat_ia64_quad_big",
  floatformat_always_valid
d142 1
a142 2
  "floatformat_ia64_quad_little",
  floatformat_always_valid
d145 7
a151 1
/* Extract a field which starts at START and is LEN bits long.  DATA and
d155 1
a155 1
     const unsigned char *data;
d209 1
a209 1
     const char *from;
d212 1
a212 1
  const unsigned char *ufrom = (const unsigned char *)from;
d222 3
a224 39

  /* If the exponent indicates a NaN, we don't have information to
     decide what to do.  So we handle it like IEEE, except that we
     don't try to preserve the type of NaN.  FIXME.  */
  if ((unsigned long) exponent == fmt->exp_nan)
    {
      int nan;

      mant_off = fmt->man_start;
      mant_bits_left = fmt->man_len;
      nan = 0;
      while (mant_bits_left > 0)
	{
	  mant_bits = min (mant_bits_left, 32);

	  if (get_field (ufrom, fmt->byteorder, fmt->totalsize,
			 mant_off, mant_bits) != 0)
	    {
	      /* This is a NaN.  */
	      nan = 1;
	      break;
	    }

	  mant_off += mant_bits;
	  mant_bits_left -= mant_bits;
	}

      if (nan)
	dto = NAN;
      else
	dto = INFINITY;

      if (get_field (ufrom, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1))
	dto = -dto;

      *to = dto;

      return;
    }
d257 2
a258 12
      /* Handle denormalized numbers.  FIXME: What should we do for
	 non-IEEE formats?  */
      if (exponent == 0 && mant != 0)
	dto += ldexp ((double)mant,
		      (- fmt->exp_bias
		       - mant_bits
		       - (mant_off - fmt->man_start)
		       + 1));
      else
	dto += ldexp ((double)mant, exponent - mant_bits);
      if (exponent != 0)
	exponent -= mant_bits;
d275 1
a275 1
/* Set a field which starts at START and is LEN bits long.  DATA and
d333 1
a333 1
     const double *from;
d343 1
a343 1
  dfrom = *from;
a344 8

  /* If negative, set the sign bit.  */
  if (dfrom < 0)
    {
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1, 1);
      dfrom = -dfrom;
    }

d346 1
a346 5
    {
      /* 0.0.  */
      return;
    }

d349 1
a349 1
      /* NaN.  */
d352 1
a352 1
      /* Be sure it's not infinity, but NaN value is irrelevant.  */
d358 2
a359 1
  if (dfrom + dfrom == dfrom)
d361 2
a362 5
      /* This can only happen for an infinite value (or zero, which we
	 already handled above).  */
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,
		 fmt->exp_len, fmt->exp_nan);
      return;
d365 2
d368 2
a369 11
  if (exponent + fmt->exp_bias - 1 > 0)
    put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,
	       fmt->exp_len, exponent + fmt->exp_bias - 1);
  else
    {
      /* Handle a denormalized number.  FIXME: What should we do for
	 non-IEEE formats?  */
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,
		 fmt->exp_len, 0);
      mant = ldexp (mant, exponent + fmt->exp_bias - 1);
    }
d382 4
a385 2
      /* If the integer bit is implicit, and we are not creating a
	 denormalized number, then we need to discard it.  */
d387 1
a387 2
	  && fmt->intbit == floatformat_intbit_no
	  && exponent + fmt->exp_bias - 1 > 0)
a405 10
/* Return non-zero iff the data at FROM is a valid number in format FMT.  */

int
floatformat_is_valid (fmt, from)
     const struct floatformat *fmt;
     const char *from;
{
  return fmt->is_valid (fmt, from);
}

a408 2
#include <stdio.h>

d416 1
d418 2
a419 5
  floatformat_to_double (&floatformat_ieee_double_little, (char *) &n,
			 &result);
  if ((n != result && (! isnan (n) || ! isnan (result)))
      || (n < 0 && result >= 0)
      || (n >= 0 && result < 0))
d421 2
a422 6

  floatformat_from_double (&floatformat_ieee_double_little, &n,
			   (char *) &result);
  if ((n != result && (! isnan (n) || ! isnan (result)))
      || (n < 0 && result >= 0)
      || (n >= 0 && result < 0))
d425 4
a428 10
#if 0
  {
    char exten[16];

    floatformat_from_double (&floatformat_m68881_ext, &n, exten);
    floatformat_to_double (&floatformat_m68881_ext, exten, &result);
    if (n != result)
      printf ("Differ(to+from): %.20g -> %.20g\n", n, result);
  }
#endif
a442 1
  ieee_test (0.0);
a448 9
  ieee_test (1.2E-70);
  ieee_test (1.2E-316);
  ieee_test (4.9406564584124654E-324);
  ieee_test (- 4.9406564584124654E-324);
  ieee_test (- 0.0);
  ieee_test (- INFINITY);
  ieee_test (- NAN);
  ieee_test (INFINITY);
  ieee_test (NAN);
@


1.6.18.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a19 1
#include "ansidecl.h"
d22 1
a22 1
#ifdef ANSI_PROTOTYPES
@


1.6.18.2
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 1994, 1999, 2000, 2003 Free Software Foundation, Inc.
d146 1
a146 1
static unsigned long get_field PARAMS ((const unsigned char *,
d152 1
a152 1
/* Extract a field which starts at START and is LEN bits long.  DATA and
d156 1
a156 1
     const unsigned char *data;
d210 1
a210 1
     const char *from;
d213 1
a213 1
  const unsigned char *ufrom = (const unsigned char *)from;
d276 1
a276 1
/* Set a field which starts at START and is LEN bits long.  DATA and
d334 1
a334 1
     const double *from;
a404 33
}

/* Return non-zero iff the data at FROM is a valid number in format FMT.  */

int
floatformat_is_valid (fmt, from)
     const struct floatformat *fmt;
     const char *from;
{
  if (fmt == &floatformat_i387_ext)
    {
      /* In the i387 double-extended format, if the exponent is all
	 ones, then the integer bit must be set.  If the exponent
	 is neither 0 nor ~0, the intbit must also be set.  Only
	 if the exponent is zero can it be zero, and then it must
	 be zero.  */
      unsigned long exponent, int_bit;
      const unsigned char *ufrom = (const unsigned char *) from;

      exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			    fmt->exp_start, fmt->exp_len);
      int_bit = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			   fmt->man_start, 1);

      if ((exponent == 0) != (int_bit == 0))
	return 0;
      else
	return 1;
    }

  /* Other formats with invalid representations should be added
     here.  */
  return 1;
@


1.6.18.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a31 16
static unsigned long get_field PARAMS ((const unsigned char *,
					enum floatformat_byteorders,
					unsigned int,
					unsigned int,
					unsigned int));
static int floatformat_always_valid PARAMS ((const struct floatformat *fmt,
					     const char *from));

static int
floatformat_always_valid (fmt, from)
     const struct floatformat *fmt ATTRIBUTE_UNUSED;
     const char *from ATTRIBUTE_UNUSED;
{
  return 1;
}

d42 1
a42 2
  "floatformat_ieee_single_big",
  floatformat_always_valid
d48 1
a48 2
  "floatformat_ieee_single_little",
  floatformat_always_valid
d54 1
a54 2
  "floatformat_ieee_double_big",
  floatformat_always_valid
d60 1
a60 2
  "floatformat_ieee_double_little",
  floatformat_always_valid
d70 1
a70 2
  "floatformat_ieee_double_littlebyte_bigword",
  floatformat_always_valid
a72 25
static int floatformat_i387_ext_is_valid PARAMS ((const struct floatformat *fmt, const char *from));

static int
floatformat_i387_ext_is_valid (fmt, from)
     const struct floatformat *fmt;
     const char *from;
{
  /* In the i387 double-extended format, if the exponent is all ones,
     then the integer bit must be set.  If the exponent is neither 0
     nor ~0, the intbit must also be set.  Only if the exponent is
     zero can it be zero, and then it must be zero.  */
  unsigned long exponent, int_bit;
  const unsigned char *ufrom = (const unsigned char *) from;
  
  exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,
			fmt->exp_start, fmt->exp_len);
  int_bit = get_field (ufrom, fmt->byteorder, fmt->totalsize,
		       fmt->man_start, 1);
  
  if ((exponent == 0) != (int_bit == 0))
    return 0;
  else
    return 1;
}

d77 1
a77 2
  "floatformat_i387_ext",
  floatformat_i387_ext_is_valid
d84 1
a84 2
  "floatformat_m68881_ext",
  floatformat_always_valid
d91 1
a91 2
  "floatformat_i960_ext",
  floatformat_always_valid
d97 1
a97 2
  "floatformat_m88110_ext",
  floatformat_always_valid
d105 1
a105 2
  "floatformat_m88110_ext_harris",
  floatformat_always_valid
d112 1
a112 2
  "floatformat_arm_ext_big",
  floatformat_always_valid
d119 1
a119 2
  "floatformat_arm_ext_littlebyte_bigword",
  floatformat_always_valid
d125 1
a125 2
  "floatformat_ia64_spill_big",
  floatformat_always_valid
d131 1
a131 2
  "floatformat_ia64_spill_little",
  floatformat_always_valid
d137 1
a137 2
  "floatformat_ia64_quad_big",
  floatformat_always_valid
d143 1
a143 2
  "floatformat_ia64_quad_little",
  floatformat_always_valid
d146 6
d414 24
a437 1
  return fmt->is_valid (fmt, from);
@


1.6.18.4
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a19 13
/* This is needed to pick up the NAN macro on some systems.  */
#define _GNU_SOURCE

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <math.h>

#ifdef HAVE_STRING_H
#include <string.h>
#endif

a20 1
#include "libiberty.h"
d22 5
a26 4

#ifndef INFINITY
#ifdef HUGE_VAL
#define INFINITY HUGE_VAL
d28 2
a29 6
#define INFINITY (1.0 / 0.0)
#endif
#endif

#ifndef NAN
#define NAN (0.0 / 0.0)
d274 3
a276 39

  /* If the exponent indicates a NaN, we don't have information to
     decide what to do.  So we handle it like IEEE, except that we
     don't try to preserve the type of NaN.  FIXME.  */
  if ((unsigned long) exponent == fmt->exp_nan)
    {
      int nan;

      mant_off = fmt->man_start;
      mant_bits_left = fmt->man_len;
      nan = 0;
      while (mant_bits_left > 0)
	{
	  mant_bits = min (mant_bits_left, 32);

	  if (get_field (ufrom, fmt->byteorder, fmt->totalsize,
			 mant_off, mant_bits) != 0)
	    {
	      /* This is a NaN.  */
	      nan = 1;
	      break;
	    }

	  mant_off += mant_bits;
	  mant_bits_left -= mant_bits;
	}

      if (nan)
	dto = NAN;
      else
	dto = INFINITY;

      if (get_field (ufrom, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1))
	dto = -dto;

      *to = dto;

      return;
    }
d309 2
a310 12
      /* Handle denormalized numbers.  FIXME: What should we do for
	 non-IEEE formats?  */
      if (exponent == 0 && mant != 0)
	dto += ldexp ((double)mant,
		      (- fmt->exp_bias
		       - mant_bits
		       - (mant_off - fmt->man_start)
		       + 1));
      else
	dto += ldexp ((double)mant, exponent - mant_bits);
      if (exponent != 0)
	exponent -= mant_bits;
d395 1
a395 1
  dfrom = *from;
a396 8

  /* If negative, set the sign bit.  */
  if (dfrom < 0)
    {
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1, 1);
      dfrom = -dfrom;
    }

d398 1
a398 5
    {
      /* 0.0.  */
      return;
    }

d401 1
a401 1
      /* NaN.  */
d404 1
a404 1
      /* Be sure it's not infinity, but NaN value is irrelevant.  */
d410 2
a411 1
  if (dfrom + dfrom == dfrom)
d413 2
a414 5
      /* This can only happen for an infinite value (or zero, which we
	 already handled above).  */
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,
		 fmt->exp_len, fmt->exp_nan);
      return;
d417 2
d420 2
a421 11
  if (exponent + fmt->exp_bias - 1 > 0)
    put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,
	       fmt->exp_len, exponent + fmt->exp_bias - 1);
  else
    {
      /* Handle a denormalized number.  FIXME: What should we do for
	 non-IEEE formats?  */
      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,
		 fmt->exp_len, 0);
      mant = ldexp (mant, exponent + fmt->exp_bias - 1);
    }
d434 4
a437 2
      /* If the integer bit is implicit, and we are not creating a
	 denormalized number, then we need to discard it.  */
d439 1
a439 2
	  && fmt->intbit == floatformat_intbit_no
	  && exponent + fmt->exp_bias - 1 > 0)
a470 2
#include <stdio.h>

d478 1
d480 2
a481 5
  floatformat_to_double (&floatformat_ieee_double_little, (char *) &n,
			 &result);
  if ((n != result && (! isnan (n) || ! isnan (result)))
      || (n < 0 && result >= 0)
      || (n >= 0 && result < 0))
d483 2
a484 6

  floatformat_from_double (&floatformat_ieee_double_little, &n,
			   (char *) &result);
  if ((n != result && (! isnan (n) || ! isnan (result)))
      || (n < 0 && result >= 0)
      || (n >= 0 && result < 0))
d487 4
a490 10
#if 0
  {
    char exten[16];

    floatformat_from_double (&floatformat_m68881_ext, &n, exten);
    floatformat_to_double (&floatformat_m68881_ext, exten, &result);
    if (n != result)
      printf ("Differ(to+from): %.20g -> %.20g\n", n, result);
  }
#endif
a504 1
  ieee_test (0.0);
a510 9
  ieee_test (1.2E-70);
  ieee_test (1.2E-316);
  ieee_test (4.9406564584124654E-324);
  ieee_test (- 4.9406564584124654E-324);
  ieee_test (- 0.0);
  ieee_test (- INFINITY);
  ieee_test (- NAN);
  ieee_test (INFINITY);
  ieee_test (NAN);
@


1.5
log
@* floatformat.h (floatformat_arm_ext): Document as deprecated.
(floatformat_arm_ext_big, floatformat_arm_ext_littlebyte_bigword)
(floatformat_ia64_spill_little, floatformat_ia64_quad_little)
(floatformat_ia64_spill_big, floatformat_ia64_quad_big)
(floatformat_m88110_harris_ext): Declare.
@
text
@a105 7
const struct floatformat floatformat_arm_ext =
{
  /* Bits 1 to 16 are unused.  */
  floatformat_big, 96, 0, 17, 15, 0x3fff, 0x7fff, 32, 64,
  floatformat_intbit_yes,
  "floatformat_arm_ext"
};
@


1.4
log
@* floatformat.c (floatformat_ieee_double_littlebyte_bigword): Fix
name.
@
text
@d94 6
a99 1
#ifdef HARRIS_FLOAT_FORMAT
d104 1
a104 6
  "floatformat_m88110_ext(harris)"
#else
  floatformat_big, 80, 0, 1, 15, 0x3fff, 0x7fff, 16, 64,
  floatformat_intbit_yes,
  "floatformat_m88110_ext"
#endif /* HARRIS_FLOAT_FORMAT */
d112 38
@


1.3
log
@Add field ``name'' to floatformat.
@
text
@d69 1
a69 1
  "floatformat_ieee_double_little"
@


1.2
log
@	* floatformat.c: Add casts to avoid signed/unsigned warnings.
	* pexecute.c: Add ATTRIBUTE_UNUSED as needed on Unix.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 1994, 1999 Free Software Foundation, Inc.
d39 3
a41 1
  floatformat_big, 32, 0, 1, 8, 127, 255, 9, 23, floatformat_intbit_no
d45 3
a47 1
  floatformat_little, 32, 0, 1, 8, 127, 255, 9, 23, floatformat_intbit_no
d51 3
a53 1
  floatformat_big, 64, 0, 1, 11, 1023, 2047, 12, 52, floatformat_intbit_no
d57 3
a59 1
  floatformat_little, 64, 0, 1, 11, 1023, 2047, 12, 52, floatformat_intbit_no
d67 3
a69 1
  floatformat_littlebyte_bigword, 64, 0, 1, 11, 1023, 2047, 12, 52, floatformat_intbit_no
d75 2
a76 1
  floatformat_intbit_yes
d81 3
a83 1
  floatformat_big, 96, 0, 1, 15, 0x3fff, 0x7fff, 32, 64, floatformat_intbit_yes
d89 2
a90 1
  floatformat_intbit_yes
d98 2
a99 1
  floatformat_intbit_no
d102 2
a103 1
  floatformat_intbit_yes
d110 2
a111 1
  floatformat_intbit_yes
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1991, 1994 Free Software Foundation, Inc.
d131 1
a131 1
  while (cur_bitshift < len)
d182 1
a182 1
  special_exponent = exponent == 0 || exponent == fmt->exp_nan;
d258 1
a258 1
  while (cur_bitshift < len)
d338 1
a338 1
      if (mant_bits_left == fmt->man_len
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

