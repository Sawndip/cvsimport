head	1.13;
access;
symbols
	sid-snapshot-20180601:1.13
	sid-snapshot-20180501:1.13
	sid-snapshot-20180401:1.13
	sid-snapshot-20180301:1.13
	sid-snapshot-20180201:1.13
	sid-snapshot-20180101:1.13
	sid-snapshot-20171201:1.13
	sid-snapshot-20171101:1.13
	sid-snapshot-20171001:1.13
	sid-snapshot-20170901:1.13
	sid-snapshot-20170801:1.13
	sid-snapshot-20170701:1.13
	sid-snapshot-20170601:1.13
	sid-snapshot-20170501:1.13
	sid-snapshot-20170401:1.13
	sid-snapshot-20170301:1.13
	sid-snapshot-20170201:1.13
	sid-snapshot-20170101:1.13
	sid-snapshot-20161201:1.13
	sid-snapshot-20161101:1.13
	sid-snapshot-20160901:1.13
	sid-snapshot-20160801:1.13
	sid-snapshot-20160701:1.13
	sid-snapshot-20160601:1.13
	sid-snapshot-20160501:1.13
	sid-snapshot-20160401:1.13
	sid-snapshot-20160301:1.13
	sid-snapshot-20160201:1.13
	sid-snapshot-20160101:1.13
	sid-snapshot-20151201:1.13
	sid-snapshot-20151101:1.13
	sid-snapshot-20151001:1.13
	sid-snapshot-20150901:1.13
	sid-snapshot-20150801:1.13
	sid-snapshot-20150701:1.13
	sid-snapshot-20150601:1.13
	sid-snapshot-20150501:1.13
	sid-snapshot-20150401:1.13
	sid-snapshot-20150301:1.13
	sid-snapshot-20150201:1.13
	sid-snapshot-20150101:1.13
	sid-snapshot-20141201:1.13
	sid-snapshot-20141101:1.13
	sid-snapshot-20141001:1.13
	sid-snapshot-20140901:1.12
	sid-snapshot-20140801:1.12
	sid-snapshot-20140701:1.12
	sid-snapshot-20140601:1.12
	sid-snapshot-20140501:1.12
	sid-snapshot-20140401:1.12
	sid-snapshot-20140301:1.12
	sid-snapshot-20140201:1.12
	sid-snapshot-20140101:1.12
	sid-snapshot-20131201:1.12
	sid-snapshot-20131101:1.12
	sid-snapshot-20131001:1.12
	binutils-2_24-branch:1.12.0.14
	binutils-2_24-branchpoint:1.12
	binutils-2_21_1:1.10
	sid-snapshot-20130901:1.12
	gdb_7_6_1-2013-08-30-release:1.12
	sid-snapshot-20130801:1.12
	sid-snapshot-20130701:1.12
	sid-snapshot-20130601:1.12
	sid-snapshot-20130501:1.12
	gdb_7_6-2013-04-26-release:1.12
	sid-snapshot-20130401:1.12
	binutils-2_23_2:1.12
	gdb_7_6-branch:1.12.0.12
	gdb_7_6-2013-03-12-branchpoint:1.12
	sid-snapshot-20130301:1.12
	sid-snapshot-20130201:1.12
	sid-snapshot-20130101:1.12
	sid-snapshot-20121201:1.12
	gdb_7_5_1-2012-11-29-release:1.12
	binutils-2_23_1:1.12
	sid-snapshot-20121101:1.12
	binutils-2_23:1.12
	sid-snapshot-20121001:1.12
	sid-snapshot-20120901:1.12
	gdb_7_5-2012-08-17-release:1.12
	sid-snapshot-20120801:1.12
	binutils-2_23-branch:1.12.0.10
	binutils-2_23-branchpoint:1.12
	gdb_7_5-branch:1.12.0.8
	gdb_7_5-2012-07-18-branchpoint:1.12
	sid-snapshot-20120701:1.12
	sid-snapshot-20120601:1.12
	sid-snapshot-20120501:1.12
	binutils-2_22_branch:1.12.0.6
	gdb_7_4_1-2012-04-26-release:1.12
	sid-snapshot-20120401:1.12
	sid-snapshot-20120301:1.12
	sid-snapshot-20120201:1.12
	gdb_7_4-2012-01-24-release:1.12
	sid-snapshot-20120101:1.12
	gdb_7_4-branch:1.12.0.4
	gdb_7_4-2011-12-13-branchpoint:1.12
	sid-snapshot-20111201:1.12
	binutils-2_22:1.12
	sid-snapshot-20111101:1.12
	sid-snapshot-20111001:1.12
	binutils-2_22-branch:1.12.0.2
	binutils-2_22-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.11
	sid-snapshot-20110901:1.12
	sid-snapshot-20110801:1.12
	gdb_7_3-2011-07-26-release:1.11
	sid-snapshot-20110701:1.12
	sid-snapshot-20110601:1.12
	sid-snapshot-20110501:1.12
	gdb_7_3-branch:1.11.0.2
	gdb_7_3-2011-04-01-branchpoint:1.11
	sid-snapshot-20110401:1.11
	sid-snapshot-20110301:1.11
	cygwin-1_7_8-release:1.11
	sid-snapshot-20110201:1.11
	sid-snapshot-20110101:1.10
	binutils-2_21:1.10
	sid-snapshot-20101201:1.10
	binutils-2_21-branch:1.10.0.2
	binutils-2_21-branchpoint:1.10
	sid-snapshot-20101101:1.10
	sid-snapshot-20101001:1.10
	binutils-2_20_1:1.9
	gdb_7_2-2010-09-02-release:1.9
	sid-snapshot-20100901:1.10
	cygwin-1_7_7-release:1.10
	sid-snapshot-20100801:1.9
	gdb_7_2-branch:1.9.0.12
	gdb_7_2-2010-07-07-branchpoint:1.9
	sid-snapshot-20100701:1.9
	sid-snapshot-20100601:1.9
	sid-snapshot-20100501:1.9
	sid-snapshot-20100401:1.9
	gdb_7_1-2010-03-18-release:1.9
	sid-snapshot-20100301:1.9
	gdb_7_1-branch:1.9.0.10
	gdb_7_1-2010-02-18-branchpoint:1.9
	sid-snapshot-20100201:1.9
	sid-snapshot-20100101:1.9
	gdb_7_0_1-2009-12-22-release:1.9
	sid-snapshot-20091201:1.9
	sid-snapshot-20091101:1.9
	binutils-2_20:1.9
	gdb_7_0-2009-10-06-release:1.9
	sid-snapshot-20091001:1.9
	gdb_7_0-branch:1.9.0.8
	gdb_7_0-2009-09-16-branchpoint:1.9
	arc-sim-20090309:1.8
	binutils-arc-20081103-branch:1.8.0.28
	binutils-arc-20081103-branchpoint:1.8
	binutils-2_20-branch:1.9.0.6
	binutils-2_20-branchpoint:1.9
	sid-snapshot-20090901:1.9
	sid-snapshot-20090801:1.9
	msnyder-checkpoint-072509-branch:1.9.0.4
	msnyder-checkpoint-072509-branchpoint:1.9
	sid-snapshot-20090701:1.9
	dje-cgen-play1-branch:1.9.0.2
	dje-cgen-play1-branchpoint:1.9
	sid-snapshot-20090601:1.9
	sid-snapshot-20090501:1.9
	sid-snapshot-20090401:1.8
	arc-20081103-branch:1.8.0.26
	arc-20081103-branchpoint:1.8
	arc-insight_6_8-branch:1.8.0.24
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.22
	insight_6_8-branchpoint:1.8
	sid-snapshot-20090301:1.8
	binutils-2_19_1:1.8
	sid-snapshot-20090201:1.8
	sid-snapshot-20090101:1.8
	reverse-20081226-branch:1.8.0.20
	reverse-20081226-branchpoint:1.8
	sid-snapshot-20081201:1.8
	multiprocess-20081120-branch:1.8.0.18
	multiprocess-20081120-branchpoint:1.8
	sid-snapshot-20081101:1.8
	binutils-2_19:1.8
	sid-snapshot-20081001:1.8
	reverse-20080930-branch:1.8.0.16
	reverse-20080930-branchpoint:1.8
	binutils-2_19-branch:1.8.0.14
	binutils-2_19-branchpoint:1.8
	sid-snapshot-20080901:1.8
	sid-snapshot-20080801:1.8
	reverse-20080717-branch:1.8.0.12
	reverse-20080717-branchpoint:1.8
	sid-snapshot-20080701:1.8
	msnyder-reverse-20080609-branch:1.8.0.10
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.8.0.8
	drow-reverse-20070409-branchpoint:1.8
	sid-snapshot-20080601:1.8
	sid-snapshot-20080501:1.8
	sid-snapshot-20080403:1.8
	sid-snapshot-20080401:1.8
	gdb_6_8-2008-03-27-release:1.8
	sid-snapshot-20080301:1.8
	gdb_6_8-branch:1.8.0.6
	gdb_6_8-2008-02-26-branchpoint:1.8
	sid-snapshot-20080201:1.8
	sid-snapshot-20080101:1.8
	sid-snapshot-20071201:1.8
	sid-snapshot-20071101:1.8
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	sid-snapshot-20071001:1.8
	gdb_6_7-branch:1.8.0.4
	gdb_6_7-2007-09-07-branchpoint:1.8
	binutils-2_18:1.8
	binutils-2_18-branch:1.8.0.2
	binutils-2_18-branchpoint:1.8
	insight_6_6-20070208-release:1.7
	binutils-csl-coldfire-4_1-32:1.3.16.3
	binutils-csl-sourcerygxx-4_1-32:1.3.16.3
	gdb_6_6-2006-12-18-release:1.7
	binutils-csl-innovasic-fido-3_4_4-33:1.3.16.3
	binutils-csl-coldfire-4_1-30:1.3.16.3
	binutils-csl-sourcerygxx-4_1-30:1.3.16.3
	binutils-csl-coldfire-4_1-28:1.3.16.3
	binutils-csl-sourcerygxx-4_1-29:1.3.16.3
	binutils-csl-sourcerygxx-4_1-28:1.3.16.3
	gdb_6_6-branch:1.7.0.2
	gdb_6_6-2006-11-15-branchpoint:1.7
	binutils-csl-arm-2006q3-27:1.3.16.3
	binutils-csl-sourcerygxx-4_1-27:1.3.16.3
	binutils-csl-arm-2006q3-26:1.3.16.3
	binutils-csl-sourcerygxx-4_1-26:1.3.16.3
	binutils-csl-sourcerygxx-4_1-25:1.3.16.3
	binutils-csl-sourcerygxx-4_1-24:1.3.16.3
	binutils-csl-sourcerygxx-4_1-23:1.3.16.3
	insight_6_5-20061003-release:1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.3.12.2
	binutils-csl-sourcerygxx-4_1-21:1.3.16.3
	binutils-csl-arm-2006q3-21:1.3.16.3
	binutils-csl-sourcerygxx-4_1-22:1.3.16.3
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.3.16.3
	binutils-csl-sourcerygxx-4_1-20:1.3.16.2
	binutils-csl-arm-2006q3-19:1.3.16.2
	binutils-csl-sourcerygxx-4_1-19:1.3.16.2
	binutils-csl-sourcerygxx-4_1-18:1.3.16.2
	binutils-csl-renesas-4_1-9:1.3.16.2
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.3.12.2
	binutils-csl-renesas-4_1-8:1.3.16.1
	binutils-csl-renesas-4_1-7:1.3.16.1
	binutils-csl-renesas-4_1-6:1.3.16.1
	gdb-csl-sourcerygxx-4_1-17:1.3.12.2
	binutils-csl-sourcerygxx-4_1-17:1.3.16.1
	gdb-csl-20060226-branch-local-2:1.3.12.2
	cr-0x5f1:1.6.0.2
	gdb-csl-sourcerygxx-4_1-14:1.3.12.2
	binutils-csl-sourcerygxx-4_1-14:1.3.16.1
	binutils-csl-sourcerygxx-4_1-15:1.3.16.1
	gdb-csl-sourcerygxx-4_1-13:1.3.12.2
	binutils-csl-sourcerygxx-4_1-13:1.3.16.1
	binutils-2_17:1.5
	gdb-csl-sourcerygxx-4_1-12:1.3.12.2
	binutils-csl-sourcerygxx-4_1-12:1.3.16.1
	gdb-csl-sourcerygxx-3_4_4-21:1.3.12.2
	binutils-csl-sourcerygxx-3_4_4-21:1.3.16.1
	gdb_6_5-20060621-release:1.5
	gdb-csl-sourcerygxx-4_1-9:1.3.12.2
	binutils-csl-sourcerygxx-4_1-9:1.3.16.1
	gdb-csl-sourcerygxx-4_1-8:1.3.12.2
	binutils-csl-sourcerygxx-4_1-8:1.3.16.1
	gdb-csl-sourcerygxx-4_1-7:1.3.12.2
	binutils-csl-sourcerygxx-4_1-7:1.3.16.1
	gdb-csl-arm-2006q1-6:1.3.12.2
	binutils-csl-arm-2006q1-6:1.3.16.1
	gdb-csl-sourcerygxx-4_1-6:1.3.12.2
	binutils-csl-sourcerygxx-4_1-6:1.3.16.1
	gdb-csl-symbian-6_4_50_20060226-10:1.3.12.2
	gdb-csl-symbian-6_4_50_20060226-9:1.3.12.2
	gdb-csl-symbian-6_4_50_20060226-8:1.3.12.2
	gdb-csl-coldfire-4_1-11:1.3.12.2
	binutils-csl-coldfire-4_1-11:1.3.16.1
	gdb-csl-sourcerygxx-3_4_4-19:1.3.12.2
	binutils-csl-sourcerygxx-3_4_4-19:1.3.16.1
	gdb-csl-coldfire-4_1-10:1.3.12.2
	gdb_6_5-branch:1.5.0.10
	gdb_6_5-2006-05-14-branchpoint:1.5
	binutils-csl-coldfire-4_1-10:1.3.16.1
	gdb-csl-sourcerygxx-4_1-5:1.3.12.2
	binutils-csl-sourcerygxx-4_1-5:1.3.16.1
	nickrob-async-20060513-branch:1.5.0.8
	nickrob-async-20060513-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-4:1.3.12.2
	binutils-csl-sourcerygxx-4_1-4:1.3.16.1
	msnyder-reverse-20060502-branch:1.5.0.6
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.3.12.2
	binutils-csl-morpho-4_1-4:1.3.16.1
	gdb-csl-sourcerygxx-3_4_4-17:1.3.12.2
	binutils-csl-sourcerygxx-3_4_4-17:1.3.16.1
	readline_5_1-import-branch:1.5.0.4
	readline_5_1-import-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3.12.2
	binutils-2_17-branch:1.5.0.2
	binutils-2_17-branchpoint:1.5
	gdb-csl-symbian-20060226-branch:1.3.12.2.0.2
	gdb-csl-symbian-20060226-branchpoint:1.3.12.2
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3.12.2
	msnyder-reverse-20060331-branch:1.4.0.2
	msnyder-reverse-20060331-branchpoint:1.4
	binutils-csl-2_17-branch:1.3.0.16
	binutils-csl-2_17-branchpoint:1.3
	gdb-csl-available-20060303-branch:1.3.0.14
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.12
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.10
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.6
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.4
	gdb-csl-arm-20051020-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	binutils_latest_snapshot:1.12;
locks; strict;
comment	@ * @;


1.13
date	2014.09.28.17.46.12;	author dj;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.20.19.06.46;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.03.21.05.58;	author dj;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.20.23.58.16;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.13.10.48.27;	author ktietz;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.31.18.49.42;	author vprus;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.28.00.56.12;	author dj;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.01.14.57.50;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.12.18.42.01;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.24.23.02.57;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.24.21.01.31;	author dj;	state Exp;
branches
	1.3.12.1
	1.3.16.1;
next	1.2;

1.2
date	2005.05.10.15.33.33;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.29.02.15.22;	author ian;	state Exp;
branches;
next	;

1.3.12.1
date	2006.03.17.20.36.14;	author jimb;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2006.03.21.07.54.30;	author mmitchel;	state Exp;
branches;
next	;

1.3.16.1
date	2006.03.31.01.17.06;	author mmitchel;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2006.08.22.15.08.45;	author jsm28;	state Exp;
branches;
next	1.3.16.3;

1.3.16.3
date	2006.09.28.20.41.10;	author shinwell;	state Exp;
branches;
next	;


desc
@@


1.13
log
@merge from gcc
@
text
@/* Common code for executing a program in a sub-process.
   Copyright (C) 2005, 2010 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@airs.com>.

This file is part of the libiberty library.
Libiberty is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

Libiberty is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with libiberty; see the file COPYING.LIB.  If not,
write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
Boston, MA 02110-1301, USA.  */

#include "config.h"
#include "libiberty.h"
#include "pex-common.h"

#include <stdio.h>
#include <errno.h>
#ifdef NEED_DECLARATION_ERRNO
extern int errno;
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

extern int mkstemps (char *, int);

/* This file contains subroutines for the program execution routines
   (pex_init, pex_run, etc.).  This file is compiled on all
   systems.  */

static void pex_add_remove (struct pex_obj *, const char *, int);
static int pex_get_status_and_time (struct pex_obj *, int, const char **,
				    int *);

/* Initialize a pex_obj structure.  */

struct pex_obj *
pex_init_common (int flags, const char *pname, const char *tempbase,
		 const struct pex_funcs *funcs)
{
  struct pex_obj *obj;

  obj = XNEW (struct pex_obj);
  obj->flags = flags;
  obj->pname = pname;
  obj->tempbase = tempbase;
  obj->next_input = STDIN_FILE_NO;
  obj->next_input_name = NULL;
  obj->next_input_name_allocated = 0;
  obj->stderr_pipe = -1;
  obj->count = 0;
  obj->children = NULL;
  obj->status = NULL;
  obj->time = NULL;
  obj->number_waited = 0;
  obj->input_file = NULL;
  obj->read_output = NULL;
  obj->read_err = NULL;
  obj->remove_count = 0;
  obj->remove = NULL;
  obj->funcs = funcs;
  obj->sysdep = NULL;
  return obj;
}

/* Add a file to be removed when we are done.  */

static void
pex_add_remove (struct pex_obj *obj, const char *name, int allocated)
{
  char *add;

  ++obj->remove_count;
  obj->remove = XRESIZEVEC (char *, obj->remove, obj->remove_count);
  if (allocated)
    add = (char *) name;
  else
    add = xstrdup (name);
  obj->remove[obj->remove_count - 1] = add;
}

/* Generate a temporary file name based on OBJ, FLAGS, and NAME.
   Return NULL if we were unable to reserve a temporary filename.

   If non-NULL, the result is either allocated with malloc, or the
   same pointer as NAME.  */
static char *
temp_file (struct pex_obj *obj, int flags, char *name)
{
  if (name == NULL)
    {
      if (obj->tempbase == NULL)
        {
          name = make_temp_file (NULL);
        }
      else
        {
          int len = strlen (obj->tempbase);
          int out;

          if (len >= 6
              && strcmp (obj->tempbase + len - 6, "XXXXXX") == 0)
            name = xstrdup (obj->tempbase);
          else
            name = concat (obj->tempbase, "XXXXXX", NULL);

          out = mkstemps (name, 0);
          if (out < 0)
            {
              free (name);
              return NULL;
            }

          /* This isn't obj->funcs->close because we got the
             descriptor from mkstemps, not from a function in
             obj->funcs.  Calling close here is just like what
             make_temp_file does.  */
          close (out);
        }
    }
  else if ((flags & PEX_SUFFIX) != 0)
    {
      if (obj->tempbase == NULL)
        name = make_temp_file (name);
      else
        name = concat (obj->tempbase, name, NULL);
    }

  return name;
}


/* As for pex_run (), but permits the environment for the child process
   to be specified. */

const char *
pex_run_in_environment (struct pex_obj *obj, int flags, const char *executable,
       	                char * const * argv, char * const * env,
                        const char *orig_outname, const char *errname,
                  	int *err)
{
  const char *errmsg;
  int in, out, errdes;
  char *outname;
  int outname_allocated;
  int p[2];
  int toclose;
  pid_t pid;

  in = -1;
  out = -1;
  errdes = -1;
  outname = (char *) orig_outname;
  outname_allocated = 0;

  /* If the user called pex_input_file, close the file now.  */
  if (obj->input_file)
    {
      if (fclose (obj->input_file) == EOF)
        {
          errmsg = "closing pipeline input file";
          goto error_exit;
        }
      obj->input_file = NULL;
    }

  /* Set IN.  */

  if (obj->next_input_name != NULL)
    {
      /* We have to make sure that the previous process has completed
	 before we try to read the file.  */
      if (!pex_get_status_and_time (obj, 0, &errmsg, err))
	goto error_exit;

      in = obj->funcs->open_read (obj, obj->next_input_name,
				  (flags & PEX_BINARY_INPUT) != 0);
      if (in < 0)
	{
	  *err = errno;
	  errmsg = "open temporary file";
	  goto error_exit;
	}
      if (obj->next_input_name_allocated)
	{
	  free (obj->next_input_name);
	  obj->next_input_name_allocated = 0;
	}
      obj->next_input_name = NULL;
    }
  else
    {
      in = obj->next_input;
      if (in < 0)
	{
	  *err = 0;
	  errmsg = "pipeline already complete";
	  goto error_exit;
	}
    }

  /* Set OUT and OBJ->NEXT_INPUT/OBJ->NEXT_INPUT_NAME.  */

  if ((flags & PEX_LAST) != 0)
    {
      if (outname == NULL)
	out = STDOUT_FILE_NO;
      else if ((flags & PEX_SUFFIX) != 0)
	{
	  outname = concat (obj->tempbase, outname, NULL);
	  outname_allocated = 1;
	}
      obj->next_input = -1;
    }
  else if ((obj->flags & PEX_USE_PIPES) == 0)
    {
      outname = temp_file (obj, flags, outname);
      if (! outname)
        {
          *err = 0;
          errmsg = "could not create temporary file";
          goto error_exit;
        }

      if (outname != orig_outname)
        outname_allocated = 1;

      if ((obj->flags & PEX_SAVE_TEMPS) == 0)
	{
	  pex_add_remove (obj, outname, outname_allocated);
	  outname_allocated = 0;
	}

      /* Hand off ownership of outname to the next stage.  */
      obj->next_input_name = outname;
      obj->next_input_name_allocated = outname_allocated;
      outname_allocated = 0;
    }
  else
    {
      if (obj->funcs->pipe (obj, p, (flags & PEX_BINARY_OUTPUT) != 0) < 0)
	{
	  *err = errno;
	  errmsg = "pipe";
	  goto error_exit;
	}

      out = p[WRITE_PORT];
      obj->next_input = p[READ_PORT];
    }

  if (out < 0)
    {
      out = obj->funcs->open_write (obj, outname,
				    (flags & PEX_BINARY_OUTPUT) != 0,
				    (flags & PEX_STDOUT_APPEND) != 0);
      if (out < 0)
	{
	  *err = errno;
	  errmsg = "open temporary output file";
	  goto error_exit;
	}
    }

  if (outname_allocated)
    {
      free (outname);
      outname_allocated = 0;
    }

  /* Set ERRDES.  */

  if (errname != NULL && (flags & PEX_STDERR_TO_PIPE) != 0)
    {
      *err = 0;
      errmsg = "both ERRNAME and PEX_STDERR_TO_PIPE specified.";
      goto error_exit;
    }

  if (obj->stderr_pipe != -1)
    {
      *err = 0;
      errmsg = "PEX_STDERR_TO_PIPE used in the middle of pipeline";
      goto error_exit;
    }

  if (errname == NULL)
    {
      if (flags & PEX_STDERR_TO_PIPE)
	{
	  if (obj->funcs->pipe (obj, p, (flags & PEX_BINARY_ERROR) != 0) < 0)
	    {
	      *err = errno;
	      errmsg = "pipe";
	      goto error_exit;
	    }
	  
	  errdes = p[WRITE_PORT];
	  obj->stderr_pipe = p[READ_PORT];	  
	}
      else
	{
	  errdes = STDERR_FILE_NO;
	}
    }
  else
    {
      errdes = obj->funcs->open_write (obj, errname,
				       (flags & PEX_BINARY_ERROR) != 0,
				       (flags & PEX_STDERR_APPEND) != 0);
      if (errdes < 0)
	{
	  *err = errno;
	  errmsg = "open error file";
	  goto error_exit;
	}
    }

  /* If we are using pipes, the child process has to close the next
     input pipe.  */

  if ((obj->flags & PEX_USE_PIPES) == 0)
    toclose = -1;
  else
    toclose = obj->next_input;

  /* Run the program.  */

  pid = obj->funcs->exec_child (obj, flags, executable, argv, env,
				in, out, errdes, toclose, &errmsg, err);
  if (pid < 0)
    goto error_exit;

  ++obj->count;
  obj->children = XRESIZEVEC (pid_t, obj->children, obj->count);
  obj->children[obj->count - 1] = pid;

  return NULL;

 error_exit:
  if (in >= 0 && in != STDIN_FILE_NO)
    obj->funcs->close (obj, in);
  if (out >= 0 && out != STDOUT_FILE_NO)
    obj->funcs->close (obj, out);
  if (errdes >= 0 && errdes != STDERR_FILE_NO)
    obj->funcs->close (obj, errdes);
  if (outname_allocated)
    free (outname);
  return errmsg;
}

/* Run a program.  */

const char *
pex_run (struct pex_obj *obj, int flags, const char *executable,
       	 char * const * argv, const char *orig_outname, const char *errname,
         int *err)
{
  return pex_run_in_environment (obj, flags, executable, argv, NULL,
				 orig_outname, errname, err);
}

/* Return a FILE pointer for a temporary file to fill with input for
   the pipeline.  */
FILE *
pex_input_file (struct pex_obj *obj, int flags, const char *in_name)
{
  char *name = (char *) in_name;
  FILE *f;

  /* This must be called before the first pipeline stage is run, and
     there must not have been any other input selected.  */
  if (obj->count != 0
      || (obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)
      || obj->next_input_name)
    {
      errno = EINVAL;
      return NULL;
    }

  name = temp_file (obj, flags, name);
  if (! name)
    return NULL;

  f = fopen (name, (flags & PEX_BINARY_OUTPUT) ? "wb" : "w");
  if (! f)
    {
      free (name);
      return NULL;
    }

  obj->input_file = f;
  obj->next_input_name = name;
  obj->next_input_name_allocated = (name != in_name);

  return f;
}

/* Return a stream for a pipe connected to the standard input of the
   first stage of the pipeline.  */
FILE *
pex_input_pipe (struct pex_obj *obj, int binary)
{
  int p[2];
  FILE *f;

  /* You must call pex_input_pipe before the first pex_run or pex_one.  */
  if (obj->count > 0)
    goto usage_error;

  /* You must be using pipes.  Implementations that don't support
     pipes clear this flag before calling pex_init_common.  */
  if (! (obj->flags & PEX_USE_PIPES))
    goto usage_error;

  /* If we have somehow already selected other input, that's a
     mistake.  */
  if ((obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)
      || obj->next_input_name)
    goto usage_error;

  if (obj->funcs->pipe (obj, p, binary != 0) < 0)
    return NULL;

  f = obj->funcs->fdopenw (obj, p[WRITE_PORT], binary != 0);
  if (! f)
    {
      int saved_errno = errno;
      obj->funcs->close (obj, p[READ_PORT]);
      obj->funcs->close (obj, p[WRITE_PORT]);
      errno = saved_errno;
      return NULL;
    }

  obj->next_input = p[READ_PORT];

  return f;

 usage_error:
  errno = EINVAL;
  return NULL;
}

/* Return a FILE pointer for the output of the last program
   executed.  */

FILE *
pex_read_output (struct pex_obj *obj, int binary)
{
  if (obj->next_input_name != NULL)
    {
      const char *errmsg;
      int err;

      /* We have to make sure that the process has completed before we
	 try to read the file.  */
      if (!pex_get_status_and_time (obj, 0, &errmsg, &err))
	{
	  errno = err;
	  return NULL;
	}

      obj->read_output = fopen (obj->next_input_name, binary ? "rb" : "r");

      if (obj->next_input_name_allocated)
	{
	  free (obj->next_input_name);
	  obj->next_input_name_allocated = 0;
	}
      obj->next_input_name = NULL;
    }
  else
    {
      int o;

      o = obj->next_input;
      if (o < 0 || o == STDIN_FILE_NO)
	return NULL;
      obj->read_output = obj->funcs->fdopenr (obj, o, binary);
      obj->next_input = -1;
    }

  return obj->read_output;
}

FILE *
pex_read_err (struct pex_obj *obj, int binary)
{
  int o;
  
  o = obj->stderr_pipe;
  if (o < 0 || o == STDIN_FILE_NO)
    return NULL;
  obj->read_err = obj->funcs->fdopenr (obj, o, binary);
  obj->stderr_pipe = -1;
  return obj->read_err;    
}

/* Get the exit status and, if requested, the resource time for all
   the child processes.  Return 0 on failure, 1 on success.  */

static int
pex_get_status_and_time (struct pex_obj *obj, int done, const char **errmsg,
			 int *err)
{
  int ret;
  int i;

  if (obj->number_waited == obj->count)
    return 1;

  obj->status = XRESIZEVEC (int, obj->status, obj->count);
  if ((obj->flags & PEX_RECORD_TIMES) != 0)
    obj->time = XRESIZEVEC (struct pex_time, obj->time, obj->count);

  ret = 1;
  for (i = obj->number_waited; i < obj->count; ++i)
    {
      if (obj->funcs->wait (obj, obj->children[i], &obj->status[i],
			    obj->time == NULL ? NULL : &obj->time[i],
			    done, errmsg, err) < 0)
	ret = 0;
    }
  obj->number_waited = i;

  return ret;
}

/* Get exit status of executed programs.  */

int
pex_get_status (struct pex_obj *obj, int count, int *vector)
{
  if (obj->status == NULL)
    {
      const char *errmsg;
      int err;

      if (!pex_get_status_and_time (obj, 0, &errmsg, &err))
	return 0;
    }

  if (count > obj->count)
    {
      memset (vector + obj->count, 0, (count - obj->count) * sizeof (int));
      count = obj->count;
    }

  memcpy (vector, obj->status, count * sizeof (int));

  return 1;
}

/* Get process times of executed programs.  */

int
pex_get_times (struct pex_obj *obj, int count, struct pex_time *vector)
{
  if (obj->status == NULL)
    {
      const char *errmsg;
      int err;

      if (!pex_get_status_and_time (obj, 0, &errmsg, &err))
	return 0;
    }

  if (obj->time == NULL)
    return 0;

  if (count > obj->count)
    {
      memset (vector + obj->count, 0,
	      (count - obj->count) * sizeof (struct pex_time));
      count = obj->count;
    }

  memcpy (vector, obj->time, count * sizeof (struct pex_time));

  return 1;
}

/* Free a pex_obj structure.  */

void
pex_free (struct pex_obj *obj)
{
  /* Close pipe file descriptors corresponding to child's stdout and
     stderr so that the child does not hang trying to output something
     while we're waiting for it.  */
  if (obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)
    obj->funcs->close (obj, obj->next_input);
  if (obj->stderr_pipe >= 0 && obj->stderr_pipe != STDIN_FILE_NO)
    obj->funcs->close (obj, obj->stderr_pipe);
  if (obj->read_output != NULL)
    fclose (obj->read_output);
  if (obj->read_err != NULL)
    fclose (obj->read_err);

  /* If the caller forgot to wait for the children, we do it here, to
     avoid zombies.  */
  if (obj->status == NULL)
    {
      const char *errmsg;
      int err;

      obj->flags &= ~ PEX_RECORD_TIMES;
      pex_get_status_and_time (obj, 1, &errmsg, &err);
    }

  if (obj->next_input_name_allocated)
    free (obj->next_input_name);
  free (obj->children);
  free (obj->status);
  free (obj->time);

  if (obj->remove_count > 0)
    {
      int i;

      for (i = 0; i < obj->remove_count; ++i)
	{
	  remove (obj->remove[i]);
	  free (obj->remove[i]);
	}
      free (obj->remove);
    }

  if (obj->funcs->cleanup != NULL)
    obj->funcs->cleanup (obj);

  free (obj);
}
@


1.12
log
@merge from gcc
@
text
@d270 2
a271 1
				    (flags & PEX_BINARY_OUTPUT) != 0);
d323 3
a325 2
      errdes = obj->funcs->open_write (obj, errname, 
				       (flags & PEX_BINARY_ERROR) != 0);
@


1.11
log
@merge from gcc
@
text
@d626 3
a628 6
  if (obj->children != NULL)
    free (obj->children);
  if (obj->status != NULL)
    free (obj->status);
  if (obj->time != NULL)
    free (obj->time);
@


1.10
log
@merge from gcc
@
text
@d2 1
a2 1
   Copyright (C) 2005 Free Software Foundation, Inc.
@


1.9
log
@Merged from gcc head revision 146001.
2009-04-13  Ozkan Sezer  <sezeroz@@gmail.com>

        PR target/39397
        * pex-common.h (struct pex_obj): Store pid values as pid_t,
        not as long (members *children and (*wait))
        * pex-common.c (pex_run_in_environment): Likewise.
        * pex-win32.c (pex_win32_wait): Return pid_t and properly check
        returned pid value.
        * pex-djgpp.c (pex_djgpp_wait): Return pid_t.
        * pex-msdos.c (pex_msdos_wait): Likewise.
@
text
@d508 1
d601 3
d606 6
a631 4
  if (obj->read_output != NULL)
    fclose (obj->read_output);
  if (obj->read_err != NULL)
    fclose (obj->read_err);
@


1.8
log
@        include/
        * libiberty.h (PEX_STDERR_TO_PIPE): New define.
        (PEX_BINARY_ERROR): New define.
        (pex_read_err): New function.

        libiberty/
        * pex-common.h (struct pex_obj): New fields
        stderr_pipe and read_err.
        * pex-common.c (pex_init_common): Initialize
        stderr_pipe.
        (pex_run_in_environment): Add error checking
        for PEX_STDERR_TO_PIPE.  Create a pipe
        for stderr if necessary.
        (pex_read_err): New.
        (pex_free): Close read_err.
        * pexecute.txh: Document changes.
        * functions.texi: Regenerated.
@
text
@d163 1
a163 1
  long pid;
d348 1
a348 1
  obj->children = XRESIZEVEC (long, obj->children, obj->count);
@


1.7
log
@merge from gcc
@
text
@d65 1
d73 1
d287 14
d302 18
a319 1
    errdes = STDERR_FILE_NO;
d322 2
a323 4
      /* We assume that stderr is in text mode--it certainly shouldn't
	 be controlled by PEX_BINARY_OUTPUT.  If necessary, we can add
	 a PEX_BINARY_STDERR flag.  */
      errdes = obj->funcs->open_write (obj, errname, 0);
d499 12
d624 2
@


1.6
log
@merge from gcc
@
text
@d160 1
d301 8
d312 1
a312 1
                                in, out, errdes, &errmsg, err);
@


1.5
log
@merge from gcc
@
text
@d145 3
a147 1
/* Run a program.  */
d150 4
a153 3
pex_run (struct pex_obj *obj, int flags, const char *executable,
	 char * const * argv, const char *orig_outname, const char *errname,
	 int *err)
d302 2
a303 2
  pid = obj->funcs->exec_child (obj, flags, executable, argv, in, out, errdes,
				&errmsg, err);
d325 11
@


1.4
log
@merge from gcc
@
text
@d70 1
d95 50
d165 11
d226 10
a235 43
      if (outname == NULL)
	{
	  if (obj->tempbase == NULL)
	    {
	      outname = make_temp_file (NULL);
	      outname_allocated = 1;
	    }
	  else
	    {
	      int len = strlen (obj->tempbase);

	      if (len >= 6
		  && strcmp (obj->tempbase + len - 6, "XXXXXX") == 0)
		outname = xstrdup (obj->tempbase);
	      else
		outname = concat (obj->tempbase, "XXXXXX", NULL);

	      outname_allocated = 1;

	      out = mkstemps (outname, 0);
	      if (out < 0)
		{
		  *err = 0;
		  errmsg = "could not create temporary output file";
		  goto error_exit;
		}

	      /* This isn't obj->funcs->close because we got the
		 descriptor from mkstemps, not from a function in
		 obj->funcs.  Calling close here is just like what
		 make_temp_file does.  */
	      close (out);
	      out = -1;
	    }
	}
      else if ((flags & PEX_SUFFIX) != 0)
	{
	  if (obj->tempbase == NULL)
	    outname = make_temp_file (outname);
	  else
	    outname = concat (obj->tempbase, outname, NULL);
	  outname_allocated = 1;
	}
d322 81
@


1.3
log
@merge from gcc
@
text
@d214 4
a217 11
      if (!outname_allocated)
	{
	  obj->next_input_name = outname;
	  obj->next_input_name_allocated = 0;
	}
      else
	{
	  obj->next_input_name = outname;
	  outname_allocated = 0;
	  obj->next_input_name_allocated = 1;
	}
@


1.3.16.1
log
@	* libiberty/configure.ac: Add cygpath for mingw hosts.
	* libiberty.configure: Rebuilt.
	* libiberty/Makefile.in: Add cygpath.
	* libiberty/cygpath.c: New.

	* include/libiberty.h (pex_write_input): New declaration.

	* libiberty/pex-common.c (pex_write_input): New function.
	* libiberty/pexecute.txh (pex_write_input): Document it.
	* libiberty/pex-common.h (struct pex_funcs): New function ptr fdopenw.
	* libiberty/pex-unix.c (pex_unix_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* libiberty/pex-win32.c (pex_win32_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* libiberty/pex-djgpp.c (funcs): Leave fdopenw null.
	* libiberty/pex-msdos (funcs): Same.
	* libiberty/functions.texi: Regenerated.

	* libiberty/pex-common.h (struct pex_obj): Doc fixes.

	* libiberty/functions.texi: Regenerate.
@
text
@a110 2
  p[READ_PORT] = -1;
  p[WRITE_PORT] = -1;
a278 2
  if (p[WRITE_PORT] != -1)
    obj->funcs->close (obj, p[WRITE_PORT]);
a299 46
/* Return a FILE pointer for the input of the first program
   executed.  */

FILE *
pex_write_input (struct pex_obj *obj, int binary)
{
  int p[2];
  FILE *write_input;

  /* You must call pex_write_input before the first pex_run or pex_one.  */
  if (obj->count > 0)
    goto usage_error;

  /* You must be using pipes.  Implementations that don't support
     pipes clear this flag before calling pex_init_common.  */
  if (! (obj->flags & PEX_USE_PIPES))
    goto usage_error;

  /* If we have somehow already selected other input, that's a
     mistake.  */
  if ((obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)
      || obj->next_input_name)
    goto usage_error;

  if (obj->funcs->pipe (obj, p, binary != 0) < 0)
    return NULL;

  write_input = obj->funcs->fdopenw (obj, p[WRITE_PORT], binary != 0);
  if (! write_input)
    {
      int saved_errno = errno;
      obj->funcs->close (obj, p[READ_PORT]);
      obj->funcs->close (obj, p[WRITE_PORT]);
      errno = saved_errno;
      return NULL;
    }

  obj->next_input = p[READ_PORT];

  return write_input;

 usage_error:
  errno = EINVAL;
  return NULL;
}

@


1.3.16.2
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a69 1
  obj->input_file = NULL;
a93 50
/* Generate a temporary file name based on OBJ, FLAGS, and NAME.
   Return NULL if we were unable to reserve a temporary filename.

   If non-NULL, the result is either allocated with malloc, or the
   same pointer as NAME.  */
static char *
temp_file (struct pex_obj *obj, int flags, char *name)
{
  if (name == NULL)
    {
      if (obj->tempbase == NULL)
        {
          name = make_temp_file (NULL);
        }
      else
        {
          int len = strlen (obj->tempbase);
          int out;

          if (len >= 6
              && strcmp (obj->tempbase + len - 6, "XXXXXX") == 0)
            name = xstrdup (obj->tempbase);
          else
            name = concat (obj->tempbase, "XXXXXX", NULL);

          out = mkstemps (name, 0);
          if (out < 0)
            {
              free (name);
              return NULL;
            }

          /* This isn't obj->funcs->close because we got the
             descriptor from mkstemps, not from a function in
             obj->funcs.  Calling close here is just like what
             make_temp_file does.  */
          close (out);
        }
    }
  else if ((flags & PEX_SUFFIX) != 0)
    {
      if (obj->tempbase == NULL)
        name = make_temp_file (name);
      else
        name = concat (obj->tempbase, name, NULL);
    }

  return name;
}

a115 11
  /* If the user called pex_input_file, close the file now.  */
  if (obj->input_file)
    {
      if (fclose (obj->input_file) == EOF)
        {
          errmsg = "closing pipeline input file";
          goto error_exit;
        }
      obj->input_file = NULL;
    }

d166 43
a208 10
      outname = temp_file (obj, flags, outname);
      if (! outname)
        {
          *err = 0;
          errmsg = "could not create temporary file";
          goto error_exit;
        }

      if (outname != orig_outname)
        outname_allocated = 1;
d216 11
a226 4
      /* Hand off ownership of outname to the next stage.  */
      obj->next_input_name = outname;
      obj->next_input_name_allocated = outname_allocated;
      outname_allocated = 0;
a349 81
/* Return a FILE pointer for a temporary file to fill with input for
   the pipeline.  */
FILE *
pex_input_file (struct pex_obj *obj, int flags, const char *in_name)
{
  char *name = (char *) in_name;
  FILE *f;

  /* This must be called before the first pipeline stage is run, and
     there must not have been any other input selected.  */
  if (obj->count != 0
      || (obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)
      || obj->next_input_name)
    {
      errno = EINVAL;
      return NULL;
    }

  name = temp_file (obj, flags, name);
  if (! name)
    return NULL;

  f = fopen (name, (flags & PEX_BINARY_OUTPUT) ? "wb" : "w");
  if (! f)
    {
      free (name);
      return NULL;
    }

  obj->input_file = f;
  obj->next_input_name = name;
  obj->next_input_name_allocated = (name != in_name);

  return f;
}

/* Return a stream for a pipe connected to the standard input of the
   first stage of the pipeline.  */
FILE *
pex_input_pipe (struct pex_obj *obj, int binary)
{
  int p[2];
  FILE *f;

  /* You must call pex_input_pipe before the first pex_run or pex_one.  */
  if (obj->count > 0)
    goto usage_error;

  /* You must be using pipes.  Implementations that don't support
     pipes clear this flag before calling pex_init_common.  */
  if (! (obj->flags & PEX_USE_PIPES))
    goto usage_error;

  /* If we have somehow already selected other input, that's a
     mistake.  */
  if ((obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)
      || obj->next_input_name)
    goto usage_error;

  if (obj->funcs->pipe (obj, p, binary != 0) < 0)
    return NULL;

  f = obj->funcs->fdopenw (obj, p[WRITE_PORT], binary != 0);
  if (! f)
    {
      int saved_errno = errno;
      obj->funcs->close (obj, p[READ_PORT]);
      obj->funcs->close (obj, p[WRITE_PORT]);
      errno = saved_errno;
      return NULL;
    }

  obj->next_input = p[READ_PORT];

  return f;

 usage_error:
  errno = EINVAL;
  return NULL;
}

@


1.3.16.3
log
@	include/
	* libiberty.h: Declare pex_run_in_environment.

	libiberty/
	* pex-common.c: New function pex_run_in_environment.
	* pex-common.h: Add environment parameter to exec_child.
	* pex-msdos.c: Add environment parameter to pex_msdos_exec_child.
	* pex-djgpp.c: Add environment parameter to pex_djgpp_exec_child.
	(pex_djgpp_exec_child): Pass environment to child process.
	* pex-unix.c: Add environment parameter to pex_unix_exec_child.
	(pex_unix_exec_child): Pass environment to child process.
	* pex-win32.c: Add environment parameter to pex_win32_exec_child.
	New function env_compare for comparing VAR=VALUE pairs.
	(win32_spawn): Assemble environment block and pass to CreateProcess.
	(spawn_script): Pass environment through to win32_spawn.
	(pex_win32_exec_child): Pass environment through to spawn_script and
	win32_spawn.
	* functions.texi: Regenerate.
	* pexecute.txh: Document pex_run_in_environment.
@
text
@d145 1
a145 3

/* As for pex_run (), but permits the environment for the child process
   to be specified. */
d148 3
a150 4
pex_run_in_environment (struct pex_obj *obj, int flags, const char *executable,
       	                char * const * argv, char * const * env,
                        const char *orig_outname, const char *errname,
                  	int *err)
d301 2
a302 2
  pid = obj->funcs->exec_child (obj, flags, executable, argv, env,
                                in, out, errdes, &errmsg, err);
a371 11
/* Run a program.  */

const char *
pex_run (struct pex_obj *obj, int flags, const char *executable,
       	 char * const * argv, const char *orig_outname, const char *errname,
         int *err)
{
  return pex_run_in_environment (obj, flags, executable, argv, NULL,
				 orig_outname, errname, err);
}

@


1.3.12.1
log
@gdb/ChangeLog:
2006-03-17  Jim Blandy  <jimb@@codesourcery.com>

	Add support for 'target remote |' on MinGW.
	* ser-mingw.c (struct pipe_state): New structure.
	(make_pipe_state, free_pipe_state, cleanup_pipe_state)
	(pipe_windows_open, pipe_windows_close, pipe_windows_read)
	(pipe_windows_write, pipe_wait_handle): New functions.
	(_initialize_ser_windows): Register a "pipe" interface based on
	them.

include/ChangeLog:
2006-03-15  Jim Blandy  <jimb@@codesourcery.com>

	* libiberty.h (pex_write_input): New declaration.

libiberty/ChangeLog:
2006-03-15  Jim Blandy  <jimb@@codesourcery.com>

	* pex-common.c (pex_write_input): New function.
	* pexecute.txh (pex_write_input): Document it.
	* pex-common.h (struct pex_funcs): New function ptr fdopenw.
	* pex-unix.c (pex_unix_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* pex-win32.c (pex_win32_fdopenw): New function.
	(funcs): List it as our fdopenw function.
	* pex-djgpp.c (funcs): Leave fdopenw null.
	* pex-msdos (funcs): Same.
	* functions.texi: Regenerated.

2006-03-12  Jim Blandy  <jimb@@red-bean.com>

	* pex-common.h (struct pex_obj): Doc fixes.

2006-03-11  Jim Blandy  <jimb@@red-bean.com>

	* functions.texi: Regenerate.
@
text
@a299 46
/* Return a FILE pointer for the input of the first program
   executed.  */

FILE *
pex_write_input (struct pex_obj *obj, int binary)
{
  int p[2];
  FILE *write_input;

  /* You must call pex_write_input before the first pex_run or pex_one.  */
  if (obj->count > 0)
    goto usage_error;

  /* You must be using pipes.  Implementations that don't support
     pipes clear this flag before calling pex_init_common.  */
  if (! (obj->flags & PEX_USE_PIPES))
    goto usage_error;

  /* If we have somehow already selected other input, that's a
     mistake.  */
  if ((obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)
      || obj->next_input_name)
    goto usage_error;

  if (obj->funcs->pipe (obj, p, binary != 0) < 0)
    return NULL;

  write_input = obj->funcs->fdopenw (obj, p[WRITE_PORT], binary != 0);
  if (! write_input)
    {
      int saved_errno = errno;
      obj->funcs->close (obj, p[READ_PORT]);
      obj->funcs->close (obj, p[WRITE_PORT]);
      errno = saved_errno;
      return NULL;
    }

  obj->next_input = p[READ_PORT];

  return write_input;

 usage_error:
  errno = EINVAL;
  return NULL;
}

@


1.3.12.2
log
@	* libiberty/pex-common.c (pex_run): Close the write end of the
	pipe after starting the child.
@
text
@a110 2
  p[READ_PORT] = -1;
  p[WRITE_PORT] = -1;
a278 2
  if (p[WRITE_PORT] != -1)
    obj->funcs->close (obj, p[WRITE_PORT]);
@


1.2
log
@Update the address and phone number of the FSF organization.
@
text
@d58 1
a58 1
  obj = xmalloc (sizeof (*obj));
d86 1
a86 1
  obj->remove = xrealloc (obj->remove, obj->remove_count * sizeof (char *));
d283 1
a283 1
  obj->children = xrealloc (obj->children, obj->count * sizeof (long));
d355 1
a355 1
  obj->status = xrealloc (obj->status, obj->count * sizeof (int));
d357 1
a357 1
    obj->time = xrealloc (obj->time, obj->count * sizeof (struct pex_time));
@


1.1
log
@libiberty:
	* pex-common.c: New file.
	* pex-one.c: New file.
	* pexecute.c: New file.
	* pex-common.h: Include <stdio.h>.
	(struct pex_obj): Define.
	(struct pex_funcs): Define.
	(pex_init_common): Declare.
	* pex-unix.c: Rewrite.
	* pex-win32.c: Rewrite.
	* pex-djgpp.c: Rewrite.
	* pex-msdos.c: Rewrite.
	* testsuite/text-pexecute.c: New file.
	* pexecute.txh: Rewrite.
	* configure.ac: Check for wait3 and wait4.  Set CHECK to
	really-check rather than check-cplus-dem.
	* functions.texi: Rebuild.
	* Makefile.in: Rebuild dependencies.
	(CFILES): Add pexecute.c, pex-common.c, pex-one.c.
	(REQUIRED_OFILES): Add pexecute.o, pex-common.o, pex-one.o.
	* testsuite/Makefile.in (really-check): New target.
	(check-pexecute, test-pexecute): New targets.
	* configure: Rebuild.
include:
	* libiberty.h: Include <stdio.h>.
	(PEX_RECORD_TIMES, PEX_USE_PIPES, PEX_SAVE_TEMPS): Define.
	(PEX_LAST, PEX_SEARCH, PEX_SUFFIX, PEX_STDERR_TO_STDOUT): Define.
	(PEX_BINARY_INPUT, PEX_BINARY_OUTPUT): Define.
	(pex_init, pex_run, pex_read_output): Declare.
	(pex_get_status, pex_get_times, pex_free, pex_one): Declare.
	(struct pex_time): Define.
@
text
@d18 2
a19 2
write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
@

