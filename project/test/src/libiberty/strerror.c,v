head	1.13;
access;
symbols
	sid-snapshot-20180601:1.13
	sid-snapshot-20180501:1.13
	sid-snapshot-20180401:1.13
	sid-snapshot-20180301:1.13
	sid-snapshot-20180201:1.13
	sid-snapshot-20180101:1.13
	sid-snapshot-20171201:1.13
	sid-snapshot-20171101:1.13
	sid-snapshot-20171001:1.13
	sid-snapshot-20170901:1.13
	sid-snapshot-20170801:1.13
	sid-snapshot-20170701:1.13
	sid-snapshot-20170601:1.13
	sid-snapshot-20170501:1.13
	sid-snapshot-20170401:1.13
	sid-snapshot-20170301:1.13
	sid-snapshot-20170201:1.13
	sid-snapshot-20170101:1.13
	sid-snapshot-20161201:1.13
	sid-snapshot-20161101:1.13
	sid-snapshot-20160901:1.13
	sid-snapshot-20160801:1.13
	sid-snapshot-20160701:1.13
	sid-snapshot-20160601:1.13
	sid-snapshot-20160501:1.13
	sid-snapshot-20160401:1.13
	sid-snapshot-20160301:1.13
	sid-snapshot-20160201:1.13
	sid-snapshot-20160101:1.13
	sid-snapshot-20151201:1.13
	sid-snapshot-20151101:1.13
	sid-snapshot-20151001:1.13
	sid-snapshot-20150901:1.13
	sid-snapshot-20150801:1.13
	sid-snapshot-20150701:1.13
	sid-snapshot-20150601:1.13
	sid-snapshot-20150501:1.13
	sid-snapshot-20150401:1.13
	sid-snapshot-20150301:1.12
	sid-snapshot-20150201:1.12
	sid-snapshot-20150101:1.12
	sid-snapshot-20141201:1.12
	sid-snapshot-20141101:1.12
	sid-snapshot-20141001:1.12
	sid-snapshot-20140901:1.12
	sid-snapshot-20140801:1.12
	sid-snapshot-20140701:1.12
	sid-snapshot-20140601:1.12
	sid-snapshot-20140501:1.12
	sid-snapshot-20140401:1.12
	sid-snapshot-20140301:1.12
	sid-snapshot-20140201:1.12
	sid-snapshot-20140101:1.12
	sid-snapshot-20131201:1.12
	sid-snapshot-20131101:1.12
	sid-snapshot-20131001:1.12
	binutils-2_24-branch:1.12.0.92
	binutils-2_24-branchpoint:1.12
	binutils-2_21_1:1.12
	sid-snapshot-20130901:1.12
	gdb_7_6_1-2013-08-30-release:1.12
	sid-snapshot-20130801:1.12
	sid-snapshot-20130701:1.12
	sid-snapshot-20130601:1.12
	sid-snapshot-20130501:1.12
	gdb_7_6-2013-04-26-release:1.12
	sid-snapshot-20130401:1.12
	binutils-2_23_2:1.12
	gdb_7_6-branch:1.12.0.90
	gdb_7_6-2013-03-12-branchpoint:1.12
	sid-snapshot-20130301:1.12
	sid-snapshot-20130201:1.12
	sid-snapshot-20130101:1.12
	sid-snapshot-20121201:1.12
	gdb_7_5_1-2012-11-29-release:1.12
	binutils-2_23_1:1.12
	sid-snapshot-20121101:1.12
	binutils-2_23:1.12
	sid-snapshot-20121001:1.12
	sid-snapshot-20120901:1.12
	gdb_7_5-2012-08-17-release:1.12
	sid-snapshot-20120801:1.12
	binutils-2_23-branch:1.12.0.88
	binutils-2_23-branchpoint:1.12
	gdb_7_5-branch:1.12.0.86
	gdb_7_5-2012-07-18-branchpoint:1.12
	sid-snapshot-20120701:1.12
	sid-snapshot-20120601:1.12
	sid-snapshot-20120501:1.12
	binutils-2_22_branch:1.12.0.84
	gdb_7_4_1-2012-04-26-release:1.12
	sid-snapshot-20120401:1.12
	sid-snapshot-20120301:1.12
	sid-snapshot-20120201:1.12
	gdb_7_4-2012-01-24-release:1.12
	sid-snapshot-20120101:1.12
	gdb_7_4-branch:1.12.0.82
	gdb_7_4-2011-12-13-branchpoint:1.12
	sid-snapshot-20111201:1.12
	binutils-2_22:1.12
	sid-snapshot-20111101:1.12
	sid-snapshot-20111001:1.12
	binutils-2_22-branch:1.12.0.80
	binutils-2_22-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.12
	sid-snapshot-20110901:1.12
	sid-snapshot-20110801:1.12
	gdb_7_3-2011-07-26-release:1.12
	sid-snapshot-20110701:1.12
	sid-snapshot-20110601:1.12
	sid-snapshot-20110501:1.12
	gdb_7_3-branch:1.12.0.78
	gdb_7_3-2011-04-01-branchpoint:1.12
	sid-snapshot-20110401:1.12
	sid-snapshot-20110301:1.12
	cygwin-1_7_8-release:1.12
	sid-snapshot-20110201:1.12
	sid-snapshot-20110101:1.12
	binutils-2_21:1.12
	sid-snapshot-20101201:1.12
	binutils-2_21-branch:1.12.0.76
	binutils-2_21-branchpoint:1.12
	sid-snapshot-20101101:1.12
	sid-snapshot-20101001:1.12
	binutils-2_20_1:1.12
	gdb_7_2-2010-09-02-release:1.12
	sid-snapshot-20100901:1.12
	cygwin-1_7_7-release:1.12
	sid-snapshot-20100801:1.12
	gdb_7_2-branch:1.12.0.74
	gdb_7_2-2010-07-07-branchpoint:1.12
	sid-snapshot-20100701:1.12
	sid-snapshot-20100601:1.12
	sid-snapshot-20100501:1.12
	sid-snapshot-20100401:1.12
	gdb_7_1-2010-03-18-release:1.12
	sid-snapshot-20100301:1.12
	gdb_7_1-branch:1.12.0.72
	gdb_7_1-2010-02-18-branchpoint:1.12
	sid-snapshot-20100201:1.12
	sid-snapshot-20100101:1.12
	gdb_7_0_1-2009-12-22-release:1.12
	sid-snapshot-20091201:1.12
	sid-snapshot-20091101:1.12
	binutils-2_20:1.12
	gdb_7_0-2009-10-06-release:1.12
	sid-snapshot-20091001:1.12
	gdb_7_0-branch:1.12.0.70
	gdb_7_0-2009-09-16-branchpoint:1.12
	arc-sim-20090309:1.12
	binutils-arc-20081103-branch:1.12.0.68
	binutils-arc-20081103-branchpoint:1.12
	binutils-2_20-branch:1.12.0.66
	binutils-2_20-branchpoint:1.12
	sid-snapshot-20090901:1.12
	sid-snapshot-20090801:1.12
	msnyder-checkpoint-072509-branch:1.12.0.64
	msnyder-checkpoint-072509-branchpoint:1.12
	sid-snapshot-20090701:1.12
	dje-cgen-play1-branch:1.12.0.62
	dje-cgen-play1-branchpoint:1.12
	sid-snapshot-20090601:1.12
	sid-snapshot-20090501:1.12
	sid-snapshot-20090401:1.12
	arc-20081103-branch:1.12.0.60
	arc-20081103-branchpoint:1.12
	arc-insight_6_8-branch:1.12.0.58
	arc-insight_6_8-branchpoint:1.12
	insight_6_8-branch:1.12.0.56
	insight_6_8-branchpoint:1.12
	sid-snapshot-20090301:1.12
	binutils-2_19_1:1.12
	sid-snapshot-20090201:1.12
	sid-snapshot-20090101:1.12
	reverse-20081226-branch:1.12.0.54
	reverse-20081226-branchpoint:1.12
	sid-snapshot-20081201:1.12
	multiprocess-20081120-branch:1.12.0.52
	multiprocess-20081120-branchpoint:1.12
	sid-snapshot-20081101:1.12
	binutils-2_19:1.12
	sid-snapshot-20081001:1.12
	reverse-20080930-branch:1.12.0.50
	reverse-20080930-branchpoint:1.12
	binutils-2_19-branch:1.12.0.48
	binutils-2_19-branchpoint:1.12
	sid-snapshot-20080901:1.12
	sid-snapshot-20080801:1.12
	reverse-20080717-branch:1.12.0.46
	reverse-20080717-branchpoint:1.12
	sid-snapshot-20080701:1.12
	msnyder-reverse-20080609-branch:1.12.0.44
	msnyder-reverse-20080609-branchpoint:1.12
	drow-reverse-20070409-branch:1.12.0.42
	drow-reverse-20070409-branchpoint:1.12
	sid-snapshot-20080601:1.12
	sid-snapshot-20080501:1.12
	sid-snapshot-20080403:1.12
	sid-snapshot-20080401:1.12
	gdb_6_8-2008-03-27-release:1.12
	sid-snapshot-20080301:1.12
	gdb_6_8-branch:1.12.0.40
	gdb_6_8-2008-02-26-branchpoint:1.12
	sid-snapshot-20080201:1.12
	sid-snapshot-20080101:1.12
	sid-snapshot-20071201:1.12
	sid-snapshot-20071101:1.12
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	sid-snapshot-20071001:1.12
	gdb_6_7-branch:1.12.0.38
	gdb_6_7-2007-09-07-branchpoint:1.12
	binutils-2_18:1.12
	binutils-2_18-branch:1.12.0.36
	binutils-2_18-branchpoint:1.12
	insight_6_6-20070208-release:1.12
	binutils-csl-coldfire-4_1-32:1.12
	binutils-csl-sourcerygxx-4_1-32:1.12
	gdb_6_6-2006-12-18-release:1.12
	binutils-csl-innovasic-fido-3_4_4-33:1.12
	binutils-csl-sourcerygxx-3_4_4-32:1.11
	binutils-csl-coldfire-4_1-30:1.12
	binutils-csl-sourcerygxx-4_1-30:1.12
	binutils-csl-coldfire-4_1-28:1.12
	binutils-csl-sourcerygxx-4_1-29:1.12
	binutils-csl-sourcerygxx-4_1-28:1.12
	gdb_6_6-branch:1.12.0.34
	gdb_6_6-2006-11-15-branchpoint:1.12
	binutils-csl-arm-2006q3-27:1.12
	binutils-csl-sourcerygxx-4_1-27:1.12
	binutils-csl-arm-2006q3-26:1.12
	binutils-csl-sourcerygxx-4_1-26:1.12
	binutils-csl-sourcerygxx-4_1-25:1.12
	binutils-csl-sourcerygxx-4_1-24:1.12
	binutils-csl-sourcerygxx-4_1-23:1.12
	insight_6_5-20061003-release:1.12
	gdb-csl-symbian-6_4_50_20060226-12:1.12
	binutils-csl-sourcerygxx-4_1-21:1.12
	binutils-csl-arm-2006q3-21:1.12
	binutils-csl-sourcerygxx-4_1-22:1.12
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.12
	binutils-csl-sourcerygxx-4_1-20:1.12
	binutils-csl-arm-2006q3-19:1.12
	binutils-csl-sourcerygxx-4_1-19:1.12
	binutils-csl-sourcerygxx-4_1-18:1.12
	binutils-csl-renesas-4_1-9:1.12
	gdb-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-sourcerygxx-3_4_4-25:1.11
	nickrob-async-20060828-mergepoint:1.12
	gdb-csl-symbian-6_4_50_20060226-11:1.12
	binutils-csl-renesas-4_1-8:1.12
	binutils-csl-renesas-4_1-7:1.12
	binutils-csl-renesas-4_1-6:1.12
	gdb-csl-sourcerygxx-4_1-17:1.12
	binutils-csl-sourcerygxx-4_1-17:1.12
	gdb-csl-20060226-branch-local-2:1.12
	cr-0x5f1:1.12.0.32
	gdb-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-15:1.12
	gdb-csl-sourcerygxx-4_1-13:1.12
	binutils-csl-sourcerygxx-4_1-13:1.12
	binutils-2_17:1.12
	gdb-csl-sourcerygxx-4_1-12:1.12
	binutils-csl-sourcerygxx-4_1-12:1.12
	gdb-csl-sourcerygxx-3_4_4-21:1.12
	binutils-csl-sourcerygxx-3_4_4-21:1.12
	gdb_6_5-20060621-release:1.12
	binutils-csl-wrs-linux-3_4_4-24:1.11
	binutils-csl-wrs-linux-3_4_4-23:1.11
	gdb-csl-sourcerygxx-4_1-9:1.12
	binutils-csl-sourcerygxx-4_1-9:1.12
	gdb-csl-sourcerygxx-4_1-8:1.12
	binutils-csl-sourcerygxx-4_1-8:1.12
	gdb-csl-sourcerygxx-4_1-7:1.12
	binutils-csl-sourcerygxx-4_1-7:1.12
	gdb-csl-arm-2006q1-6:1.12
	binutils-csl-arm-2006q1-6:1.12
	gdb-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-wrs-linux-3_4_4-22:1.11
	gdb-csl-symbian-6_4_50_20060226-10:1.12
	gdb-csl-symbian-6_4_50_20060226-9:1.12
	gdb-csl-symbian-6_4_50_20060226-8:1.12
	gdb-csl-coldfire-4_1-11:1.12
	binutils-csl-coldfire-4_1-11:1.12
	gdb-csl-sourcerygxx-3_4_4-19:1.12
	binutils-csl-sourcerygxx-3_4_4-19:1.12
	gdb-csl-coldfire-4_1-10:1.12
	gdb_6_5-branch:1.12.0.30
	gdb_6_5-2006-05-14-branchpoint:1.12
	binutils-csl-coldfire-4_1-10:1.12
	gdb-csl-sourcerygxx-4_1-5:1.12
	binutils-csl-sourcerygxx-4_1-5:1.12
	nickrob-async-20060513-branch:1.12.0.28
	nickrob-async-20060513-branchpoint:1.12
	gdb-csl-sourcerygxx-4_1-4:1.12
	binutils-csl-sourcerygxx-4_1-4:1.12
	msnyder-reverse-20060502-branch:1.12.0.26
	msnyder-reverse-20060502-branchpoint:1.12
	binutils-csl-wrs-linux-3_4_4-21:1.11
	gdb-csl-morpho-4_1-4:1.12
	binutils-csl-morpho-4_1-4:1.12
	gdb-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-wrs-linux-3_4_4-20:1.11
	readline_5_1-import-branch:1.12.0.24
	readline_5_1-import-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.12
	binutils-2_17-branch:1.12.0.22
	binutils-2_17-branchpoint:1.12
	gdb-csl-symbian-20060226-branch:1.12.0.20
	gdb-csl-symbian-20060226-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.12
	msnyder-reverse-20060331-branch:1.12.0.18
	msnyder-reverse-20060331-branchpoint:1.12
	binutils-csl-2_17-branch:1.12.0.16
	binutils-csl-2_17-branchpoint:1.12
	gdb-csl-available-20060303-branch:1.12.0.14
	gdb-csl-available-20060303-branchpoint:1.12
	gdb-csl-20060226-branch:1.12.0.12
	gdb-csl-20060226-branchpoint:1.12
	gdb_6_4-20051202-release:1.12
	msnyder-fork-checkpoint-branch:1.12.0.10
	msnyder-fork-checkpoint-branchpoint:1.12
	gdb-csl-gxxpro-6_3-branch:1.12.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.12
	gdb_6_4-branch:1.12.0.6
	gdb_6_4-2005-11-01-branchpoint:1.12
	gdb-csl-arm-20051020-branch:1.12.0.4
	gdb-csl-arm-20051020-branchpoint:1.12
	binutils-csl-gxxpro-3_4-branch:1.11.0.14
	binutils-csl-gxxpro-3_4-branchpoint:1.11
	binutils-2_16_1:1.11
	msnyder-tracepoint-checkpoint-branch:1.12.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.12
	gdb-csl-arm-20050325-2005-q1b:1.11
	binutils-csl-arm-2005q1b:1.11
	binutils-2_16:1.11
	gdb-csl-arm-20050325-2005-q1a:1.11
	binutils-csl-arm-2005q1a:1.11
	csl-arm-20050325-branch:1.11.0.12
	csl-arm-20050325-branchpoint:1.11
	binutils-csl-arm-2005q1-branch:1.11.0.10
	binutils-csl-arm-2005q1-branchpoint:1.11
	binutils-2_16-branch:1.11.0.8
	binutils-2_16-branchpoint:1.11
	csl-arm-2004-q3d:1.11
	gdb_6_3-20041109-release:1.11
	gdb_6_3-branch:1.11.0.4
	gdb_6_3-20041019-branchpoint:1.11
	csl-arm-2004-q3:1.11
	drow_intercu-merge-20040921:1.11
	drow_intercu-merge-20040915:1.11
	jimb-gdb_6_2-e500-branch:1.11.0.6
	jimb-gdb_6_2-e500-branchpoint:1.11
	gdb_6_2-20040730-release:1.11
	gdb_6_2-branch:1.11.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.11
	gdb_6_1_1-20040616-release:1.10
	binutils-2_15:1.10
	binutils-2_15-branchpoint:1.10
	csl-arm-2004-q1a:1.11
	csl-arm-2004-q1:1.10
	gdb_6_1-2004-04-05-release:1.10
	drow_intercu-merge-20040402:1.10
	drow_intercu-merge-20040327:1.10
	ezannoni_pie-20040323-branch:1.10.0.14
	ezannoni_pie-20040323-branchpoint:1.10
	cagney_tramp-20040321-mergepoint:1.10
	cagney_tramp-20040309-branch:1.10.0.12
	cagney_tramp-20040309-branchpoint:1.10
	gdb_6_1-branch:1.10.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.10
	drow_intercu-20040221-branch:1.10.0.8
	drow_intercu-20040221-branchpoint:1.10
	binutils-2_15-branch:1.10.0.6
	cagney_bfdfile-20040213-branch:1.10.0.4
	cagney_bfdfile-20040213-branchpoint:1.10
	drow-cplus-merge-20040208:1.10
	carlton_dictionary-20040126-merge:1.10
	cagney_bigcore-20040122-branch:1.10.0.2
	cagney_bigcore-20040122-branchpoint:1.10
	drow-cplus-merge-20040113:1.10
	csl-arm-2003-q4:1.10
	drow-cplus-merge-20031224:1.10
	drow-cplus-merge-20031220:1.10
	carlton_dictionary-20031215-merge:1.10
	drow-cplus-merge-20031214:1.10
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.8.0.66
	kettenis_sparc-20030918-branchpoint:1.8
	carlton_dictionary-20030917-merge:1.8
	ezannoni_pie-20030916-branchpoint:1.8
	ezannoni_pie-20030916-branch:1.8.0.64
	cagney_x86i386-20030821-branch:1.8.0.62
	cagney_x86i386-20030821-branchpoint:1.8
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.60
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.58
	jimb-ppc64-linux-20030613-branchpoint:1.8
	binutils-2_14:1.8
	cagney_convert-20030606-branch:1.8.0.56
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.54
	cagney_writestrings-20030508-branchpoint:1.8
	jimb-ppc64-linux-20030528-branch:1.8.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.50
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.8.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.8
	kettenis_i386newframe-20030504-mergepoint:1.8
	carlton_dictionary-20030430-merge:1.8
	binutils-2_14-branch:1.8.0.46
	binutils-2_14-branchpoint:1.8
	kettenis_i386newframe-20030419-branch:1.8.0.44
	kettenis_i386newframe-20030419-branchpoint:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.42
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.40
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.38
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.36
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.34
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.32
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.30
	cagney_offbyone-20030303-branchpoint:1.8
	w32api-2_2:1.8
	mingw-runtime-2_4:1.8
	carlton_dictionary-20030207-merge:1.8
	interps-20030202-branch:1.8.0.28
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.8.0.26
	cagney-unwind-20030108-branchpoint:1.8
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	binutils-2_13_1:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.24
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.22
	carlton_dictionary-20020920-branchpoint:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.20
	gdb_5_3-branch:1.8.0.18
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.16
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.14
	readline_4_3-import-branchpoint:1.8
	binutils-2_13:1.8
	gdb_5_2_1-2002-07-23-release:1.8
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.12
	kseitz_interps-20020528-branch:1.8.0.10
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.8
	cagney_regbuf-20020515-branchpoint:1.8
	binutils-2_12_1:1.8
	jimb-macro-020506-branch:1.8.0.6
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.8
	binutils-2_12:1.8
	gdb_5_2-branch:1.8.0.4
	gdb_5_2-2002-03-03-branchpoint:1.8
	binutils-2_12-branch:1.8.0.2
	binutils-2_12-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	binutils-2_11_2:1.2
	binutils-2_11_1:1.2
	binutils-2_11:1.2
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.4
	insight-precleanup-2001-01-01:1.2
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	cygwin-1_1_1:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	egcs_20000222:1.1.1.1
	binutils_latest_snapshot:1.12
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.03.04.18.01.03;	author dj;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.28.02.09.01;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.14.03.12.51;	author dj;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.02.19.07.17;	author drow;	state Exp;
branches
	1.10.8.1;
next	1.9;

1.9
date	2003.10.01.23.11.45;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.16.02.55.31;	author dj;	state Exp;
branches
	1.8.22.1
	1.8.24.1;
next	1.7;

1.7
date	2001.10.07.22.42.23;	author dj;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.07.17.24.36;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.27.20.27.58;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.26.18.45.50;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.12.13.16.43;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.29.20.45.32;	author zack;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.54;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.10.8.1
date	2004.09.16.17.01.56;	author drow;	state Exp;
branches;
next	;

1.8.22.1
date	2003.11.11.23.51.15;	author carlton;	state Exp;
branches;
next	;

1.8.24.1
date	2003.12.14.20.28.03;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.54;	author rth;	state Exp;
branches;
next	;


desc
@@


1.13
log
@merge from gcc
@
text
@/* Extended support for using errno values.
   Written by Fred Fish.  fnf@@cygnus.com
   This file is in the public domain.  --Per Bothner.  */

#include "config.h"

#ifdef HAVE_SYS_ERRLIST
/* Note that errno.h (not sure what OS) or stdio.h (BSD 4.4, at least)
   might declare sys_errlist in a way that the compiler might consider
   incompatible with our later declaration, perhaps by using const
   attributes.  So we hide the declaration in errno.h (if any) using a
   macro. */
#define sys_nerr sys_nerr__
#define sys_errlist sys_errlist__
#endif

#include "ansidecl.h"
#include "libiberty.h"

#include <stdio.h>
#include <errno.h>

#ifdef HAVE_SYS_ERRLIST
#undef sys_nerr
#undef sys_errlist
#endif

/*  Routines imported from standard C runtime libraries. */

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#else
extern PTR malloc ();
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#else
extern PTR memset ();
#endif

#ifndef MAX
#  define MAX(a,b) ((a) > (b) ? (a) : (b))
#endif

static void init_error_tables (void);

/* Translation table for errno values.  See intro(2) in most UNIX systems
   Programmers Reference Manuals.

   Note that this table is generally only accessed when it is used at runtime
   to initialize errno name and message tables that are indexed by errno
   value.

   Not all of these errnos will exist on all systems.  This table is the only
   thing that should have to be updated as new error numbers are introduced.
   It's sort of ugly, but at least its portable. */

struct error_info
{
  const int value;		/* The numeric value from <errno.h> */
  const char *const name;	/* The equivalent symbolic value */
#ifndef HAVE_SYS_ERRLIST
  const char *const msg;	/* Short message about this value */
#endif
};

#ifndef HAVE_SYS_ERRLIST
#   define ENTRY(value, name, msg)	{value, name, msg}
#else
#   define ENTRY(value, name, msg)	{value, name}
#endif

static const struct error_info error_table[] =
{
#if defined (EPERM)
  ENTRY(EPERM, "EPERM", "Not owner"),
#endif
#if defined (ENOENT)
  ENTRY(ENOENT, "ENOENT", "No such file or directory"),
#endif
#if defined (ESRCH)
  ENTRY(ESRCH, "ESRCH", "No such process"),
#endif
#if defined (EINTR)
  ENTRY(EINTR, "EINTR", "Interrupted system call"),
#endif
#if defined (EIO)
  ENTRY(EIO, "EIO", "I/O error"),
#endif
#if defined (ENXIO)
  ENTRY(ENXIO, "ENXIO", "No such device or address"),
#endif
#if defined (E2BIG)
  ENTRY(E2BIG, "E2BIG", "Arg list too long"),
#endif
#if defined (ENOEXEC)
  ENTRY(ENOEXEC, "ENOEXEC", "Exec format error"),
#endif
#if defined (EBADF)
  ENTRY(EBADF, "EBADF", "Bad file number"),
#endif
#if defined (ECHILD)
  ENTRY(ECHILD, "ECHILD", "No child processes"),
#endif
#if defined (EWOULDBLOCK)	/* Put before EAGAIN, sometimes aliased */
  ENTRY(EWOULDBLOCK, "EWOULDBLOCK", "Operation would block"),
#endif
#if defined (EAGAIN)
  ENTRY(EAGAIN, "EAGAIN", "No more processes"),
#endif
#if defined (ENOMEM)
  ENTRY(ENOMEM, "ENOMEM", "Not enough space"),
#endif
#if defined (EACCES)
  ENTRY(EACCES, "EACCES", "Permission denied"),
#endif
#if defined (EFAULT)
  ENTRY(EFAULT, "EFAULT", "Bad address"),
#endif
#if defined (ENOTBLK)
  ENTRY(ENOTBLK, "ENOTBLK", "Block device required"),
#endif
#if defined (EBUSY)
  ENTRY(EBUSY, "EBUSY", "Device busy"),
#endif
#if defined (EEXIST)
  ENTRY(EEXIST, "EEXIST", "File exists"),
#endif
#if defined (EXDEV)
  ENTRY(EXDEV, "EXDEV", "Cross-device link"),
#endif
#if defined (ENODEV)
  ENTRY(ENODEV, "ENODEV", "No such device"),
#endif
#if defined (ENOTDIR)
  ENTRY(ENOTDIR, "ENOTDIR", "Not a directory"),
#endif
#if defined (EISDIR)
  ENTRY(EISDIR, "EISDIR", "Is a directory"),
#endif
#if defined (EINVAL)
  ENTRY(EINVAL, "EINVAL", "Invalid argument"),
#endif
#if defined (ENFILE)
  ENTRY(ENFILE, "ENFILE", "File table overflow"),
#endif
#if defined (EMFILE)
  ENTRY(EMFILE, "EMFILE", "Too many open files"),
#endif
#if defined (ENOTTY)
  ENTRY(ENOTTY, "ENOTTY", "Not a typewriter"),
#endif
#if defined (ETXTBSY)
  ENTRY(ETXTBSY, "ETXTBSY", "Text file busy"),
#endif
#if defined (EFBIG)
  ENTRY(EFBIG, "EFBIG", "File too large"),
#endif
#if defined (ENOSPC)
  ENTRY(ENOSPC, "ENOSPC", "No space left on device"),
#endif
#if defined (ESPIPE)
  ENTRY(ESPIPE, "ESPIPE", "Illegal seek"),
#endif
#if defined (EROFS)
  ENTRY(EROFS, "EROFS", "Read-only file system"),
#endif
#if defined (EMLINK)
  ENTRY(EMLINK, "EMLINK", "Too many links"),
#endif
#if defined (EPIPE)
  ENTRY(EPIPE, "EPIPE", "Broken pipe"),
#endif
#if defined (EDOM)
  ENTRY(EDOM, "EDOM", "Math argument out of domain of func"),
#endif
#if defined (ERANGE)
  ENTRY(ERANGE, "ERANGE", "Math result not representable"),
#endif
#if defined (ENOMSG)
  ENTRY(ENOMSG, "ENOMSG", "No message of desired type"),
#endif
#if defined (EIDRM)
  ENTRY(EIDRM, "EIDRM", "Identifier removed"),
#endif
#if defined (ECHRNG)
  ENTRY(ECHRNG, "ECHRNG", "Channel number out of range"),
#endif
#if defined (EL2NSYNC)
  ENTRY(EL2NSYNC, "EL2NSYNC", "Level 2 not synchronized"),
#endif
#if defined (EL3HLT)
  ENTRY(EL3HLT, "EL3HLT", "Level 3 halted"),
#endif
#if defined (EL3RST)
  ENTRY(EL3RST, "EL3RST", "Level 3 reset"),
#endif
#if defined (ELNRNG)
  ENTRY(ELNRNG, "ELNRNG", "Link number out of range"),
#endif
#if defined (EUNATCH)
  ENTRY(EUNATCH, "EUNATCH", "Protocol driver not attached"),
#endif
#if defined (ENOCSI)
  ENTRY(ENOCSI, "ENOCSI", "No CSI structure available"),
#endif
#if defined (EL2HLT)
  ENTRY(EL2HLT, "EL2HLT", "Level 2 halted"),
#endif
#if defined (EDEADLK)
  ENTRY(EDEADLK, "EDEADLK", "Deadlock condition"),
#endif
#if defined (ENOLCK)
  ENTRY(ENOLCK, "ENOLCK", "No record locks available"),
#endif
#if defined (EBADE)
  ENTRY(EBADE, "EBADE", "Invalid exchange"),
#endif
#if defined (EBADR)
  ENTRY(EBADR, "EBADR", "Invalid request descriptor"),
#endif
#if defined (EXFULL)
  ENTRY(EXFULL, "EXFULL", "Exchange full"),
#endif
#if defined (ENOANO)
  ENTRY(ENOANO, "ENOANO", "No anode"),
#endif
#if defined (EBADRQC)
  ENTRY(EBADRQC, "EBADRQC", "Invalid request code"),
#endif
#if defined (EBADSLT)
  ENTRY(EBADSLT, "EBADSLT", "Invalid slot"),
#endif
#if defined (EDEADLOCK)
  ENTRY(EDEADLOCK, "EDEADLOCK", "File locking deadlock error"),
#endif
#if defined (EBFONT)
  ENTRY(EBFONT, "EBFONT", "Bad font file format"),
#endif
#if defined (ENOSTR)
  ENTRY(ENOSTR, "ENOSTR", "Device not a stream"),
#endif
#if defined (ENODATA)
  ENTRY(ENODATA, "ENODATA", "No data available"),
#endif
#if defined (ETIME)
  ENTRY(ETIME, "ETIME", "Timer expired"),
#endif
#if defined (ENOSR)
  ENTRY(ENOSR, "ENOSR", "Out of streams resources"),
#endif
#if defined (ENONET)
  ENTRY(ENONET, "ENONET", "Machine is not on the network"),
#endif
#if defined (ENOPKG)
  ENTRY(ENOPKG, "ENOPKG", "Package not installed"),
#endif
#if defined (EREMOTE)
  ENTRY(EREMOTE, "EREMOTE", "Object is remote"),
#endif
#if defined (ENOLINK)
  ENTRY(ENOLINK, "ENOLINK", "Link has been severed"),
#endif
#if defined (EADV)
  ENTRY(EADV, "EADV", "Advertise error"),
#endif
#if defined (ESRMNT)
  ENTRY(ESRMNT, "ESRMNT", "Srmount error"),
#endif
#if defined (ECOMM)
  ENTRY(ECOMM, "ECOMM", "Communication error on send"),
#endif
#if defined (EPROTO)
  ENTRY(EPROTO, "EPROTO", "Protocol error"),
#endif
#if defined (EMULTIHOP)
  ENTRY(EMULTIHOP, "EMULTIHOP", "Multihop attempted"),
#endif
#if defined (EDOTDOT)
  ENTRY(EDOTDOT, "EDOTDOT", "RFS specific error"),
#endif
#if defined (EBADMSG)
  ENTRY(EBADMSG, "EBADMSG", "Not a data message"),
#endif
#if defined (ENAMETOOLONG)
  ENTRY(ENAMETOOLONG, "ENAMETOOLONG", "File name too long"),
#endif
#if defined (EOVERFLOW)
  ENTRY(EOVERFLOW, "EOVERFLOW", "Value too large for defined data type"),
#endif
#if defined (ENOTUNIQ)
  ENTRY(ENOTUNIQ, "ENOTUNIQ", "Name not unique on network"),
#endif
#if defined (EBADFD)
  ENTRY(EBADFD, "EBADFD", "File descriptor in bad state"),
#endif
#if defined (EREMCHG)
  ENTRY(EREMCHG, "EREMCHG", "Remote address changed"),
#endif
#if defined (ELIBACC)
  ENTRY(ELIBACC, "ELIBACC", "Can not access a needed shared library"),
#endif
#if defined (ELIBBAD)
  ENTRY(ELIBBAD, "ELIBBAD", "Accessing a corrupted shared library"),
#endif
#if defined (ELIBSCN)
  ENTRY(ELIBSCN, "ELIBSCN", ".lib section in a.out corrupted"),
#endif
#if defined (ELIBMAX)
  ENTRY(ELIBMAX, "ELIBMAX", "Attempting to link in too many shared libraries"),
#endif
#if defined (ELIBEXEC)
  ENTRY(ELIBEXEC, "ELIBEXEC", "Cannot exec a shared library directly"),
#endif
#if defined (EILSEQ)
  ENTRY(EILSEQ, "EILSEQ", "Illegal byte sequence"),
#endif
#if defined (ENOSYS)
  ENTRY(ENOSYS, "ENOSYS", "Operation not applicable"),
#endif
#if defined (ELOOP)
  ENTRY(ELOOP, "ELOOP", "Too many symbolic links encountered"),
#endif
#if defined (ERESTART)
  ENTRY(ERESTART, "ERESTART", "Interrupted system call should be restarted"),
#endif
#if defined (ESTRPIPE)
  ENTRY(ESTRPIPE, "ESTRPIPE", "Streams pipe error"),
#endif
#if defined (ENOTEMPTY)
  ENTRY(ENOTEMPTY, "ENOTEMPTY", "Directory not empty"),
#endif
#if defined (EUSERS)
  ENTRY(EUSERS, "EUSERS", "Too many users"),
#endif
#if defined (ENOTSOCK)
  ENTRY(ENOTSOCK, "ENOTSOCK", "Socket operation on non-socket"),
#endif
#if defined (EDESTADDRREQ)
  ENTRY(EDESTADDRREQ, "EDESTADDRREQ", "Destination address required"),
#endif
#if defined (EMSGSIZE)
  ENTRY(EMSGSIZE, "EMSGSIZE", "Message too long"),
#endif
#if defined (EPROTOTYPE)
  ENTRY(EPROTOTYPE, "EPROTOTYPE", "Protocol wrong type for socket"),
#endif
#if defined (ENOPROTOOPT)
  ENTRY(ENOPROTOOPT, "ENOPROTOOPT", "Protocol not available"),
#endif
#if defined (EPROTONOSUPPORT)
  ENTRY(EPROTONOSUPPORT, "EPROTONOSUPPORT", "Protocol not supported"),
#endif
#if defined (ESOCKTNOSUPPORT)
  ENTRY(ESOCKTNOSUPPORT, "ESOCKTNOSUPPORT", "Socket type not supported"),
#endif
#if defined (EOPNOTSUPP)
  ENTRY(EOPNOTSUPP, "EOPNOTSUPP", "Operation not supported on transport endpoint"),
#endif
#if defined (EPFNOSUPPORT)
  ENTRY(EPFNOSUPPORT, "EPFNOSUPPORT", "Protocol family not supported"),
#endif
#if defined (EAFNOSUPPORT)
  ENTRY(EAFNOSUPPORT, "EAFNOSUPPORT", "Address family not supported by protocol"),
#endif
#if defined (EADDRINUSE)
  ENTRY(EADDRINUSE, "EADDRINUSE", "Address already in use"),
#endif
#if defined (EADDRNOTAVAIL)
  ENTRY(EADDRNOTAVAIL, "EADDRNOTAVAIL","Cannot assign requested address"),
#endif
#if defined (ENETDOWN)
  ENTRY(ENETDOWN, "ENETDOWN", "Network is down"),
#endif
#if defined (ENETUNREACH)
  ENTRY(ENETUNREACH, "ENETUNREACH", "Network is unreachable"),
#endif
#if defined (ENETRESET)
  ENTRY(ENETRESET, "ENETRESET", "Network dropped connection because of reset"),
#endif
#if defined (ECONNABORTED)
  ENTRY(ECONNABORTED, "ECONNABORTED", "Software caused connection abort"),
#endif
#if defined (ECONNRESET)
  ENTRY(ECONNRESET, "ECONNRESET", "Connection reset by peer"),
#endif
#if defined (ENOBUFS)
  ENTRY(ENOBUFS, "ENOBUFS", "No buffer space available"),
#endif
#if defined (EISCONN)
  ENTRY(EISCONN, "EISCONN", "Transport endpoint is already connected"),
#endif
#if defined (ENOTCONN)
  ENTRY(ENOTCONN, "ENOTCONN", "Transport endpoint is not connected"),
#endif
#if defined (ESHUTDOWN)
  ENTRY(ESHUTDOWN, "ESHUTDOWN", "Cannot send after transport endpoint shutdown"),
#endif
#if defined (ETOOMANYREFS)
  ENTRY(ETOOMANYREFS, "ETOOMANYREFS", "Too many references: cannot splice"),
#endif
#if defined (ETIMEDOUT)
  ENTRY(ETIMEDOUT, "ETIMEDOUT", "Connection timed out"),
#endif
#if defined (ECONNREFUSED)
  ENTRY(ECONNREFUSED, "ECONNREFUSED", "Connection refused"),
#endif
#if defined (EHOSTDOWN)
  ENTRY(EHOSTDOWN, "EHOSTDOWN", "Host is down"),
#endif
#if defined (EHOSTUNREACH)
  ENTRY(EHOSTUNREACH, "EHOSTUNREACH", "No route to host"),
#endif
#if defined (EALREADY)
  ENTRY(EALREADY, "EALREADY", "Operation already in progress"),
#endif
#if defined (EINPROGRESS)
  ENTRY(EINPROGRESS, "EINPROGRESS", "Operation now in progress"),
#endif
#if defined (ESTALE)
  ENTRY(ESTALE, "ESTALE", "Stale NFS file handle"),
#endif
#if defined (EUCLEAN)
  ENTRY(EUCLEAN, "EUCLEAN", "Structure needs cleaning"),
#endif
#if defined (ENOTNAM)
  ENTRY(ENOTNAM, "ENOTNAM", "Not a XENIX named type file"),
#endif
#if defined (ENAVAIL)
  ENTRY(ENAVAIL, "ENAVAIL", "No XENIX semaphores available"),
#endif
#if defined (EISNAM)
  ENTRY(EISNAM, "EISNAM", "Is a named type file"),
#endif
#if defined (EREMOTEIO)
  ENTRY(EREMOTEIO, "EREMOTEIO", "Remote I/O error"),
#endif
  ENTRY(0, NULL, NULL)
};

#ifdef EVMSERR
/* This is not in the table, because the numeric value of EVMSERR (32767)
   lies outside the range of sys_errlist[].  */
static struct { int value; const char *name, *msg; }
  evmserr = { EVMSERR, "EVMSERR", "VMS-specific error" };
#endif

/* Translation table allocated and initialized at runtime.  Indexed by the
   errno value to find the equivalent symbolic value. */

static const char **error_names;
static int num_error_names = 0;

/* Translation table allocated and initialized at runtime, if it does not
   already exist in the host environment.  Indexed by the errno value to find
   the descriptive string.

   We don't export it for use in other modules because even though it has the
   same name, it differs from other implementations in that it is dynamically
   initialized rather than statically initialized. */

#ifndef HAVE_SYS_ERRLIST

#define sys_nerr sys_nerr__
#define sys_errlist sys_errlist__
static int sys_nerr;
static const char **sys_errlist;

#else


#ifndef sys_nerr
extern int sys_nerr;
#endif
#ifndef sys_errlist
extern char *sys_errlist[];
#endif

#endif

/*

NAME

	init_error_tables -- initialize the name and message tables

SYNOPSIS

	static void init_error_tables ();

DESCRIPTION

	Using the error_table, which is initialized at compile time, generate
	the error_names and the sys_errlist (if needed) tables, which are
	indexed at runtime by a specific errno value.

BUGS

	The initialization of the tables may fail under low memory conditions,
	in which case we don't do anything particularly useful, but we don't
	bomb either.  Who knows, it might succeed at a later point if we free
	some memory in the meantime.  In any case, the other routines know
	how to deal with lack of a table after trying to initialize it.  This
	may or may not be considered to be a bug, that we don't specifically
	warn about this particular failure mode.

*/

static void
init_error_tables (void)
{
  const struct error_info *eip;
  int nbytes;

  /* If we haven't already scanned the error_table once to find the maximum
     errno value, then go find it now. */

  if (num_error_names == 0)
    {
      for (eip = error_table; eip -> name != NULL; eip++)
	{
	  if (eip -> value >= num_error_names)
	    {
	      num_error_names = eip -> value + 1;
	    }
	}
    }

  /* Now attempt to allocate the error_names table, zero it out, and then
     initialize it from the statically initialized error_table. */

  if (error_names == NULL)
    {
      nbytes = num_error_names * sizeof (char *);
      if ((error_names = (const char **) malloc (nbytes)) != NULL)
	{
	  memset (error_names, 0, nbytes);
	  for (eip = error_table; eip -> name != NULL; eip++)
	    {
	      error_names[eip -> value] = eip -> name;
	    }
	}
    }

#ifndef HAVE_SYS_ERRLIST

  /* Now attempt to allocate the sys_errlist table, zero it out, and then
     initialize it from the statically initialized error_table. */

  if (sys_errlist == NULL)
    {
      nbytes = num_error_names * sizeof (char *);
      if ((sys_errlist = (const char **) malloc (nbytes)) != NULL)
	{
	  memset (sys_errlist, 0, nbytes);
	  sys_nerr = num_error_names;
	  for (eip = error_table; eip -> name != NULL; eip++)
	    {
	      sys_errlist[eip -> value] = eip -> msg;
	    }
	}
    }

#endif

}

/*


@@deftypefn Extension int errno_max (void)

Returns the maximum @@code{errno} value for which a corresponding
symbolic name or message is available.  Note that in the case where we
use the @@code{sys_errlist} supplied by the system, it is possible for
there to be more symbolic names than messages, or vice versa.  In
fact, the manual page for @@code{perror(3C)} explicitly warns that one
should check the size of the table (@@code{sys_nerr}) before indexing
it, since new error codes may be added to the system before they are
added to the table.  Thus @@code{sys_nerr} might be smaller than value
implied by the largest @@code{errno} value defined in @@code{<errno.h>}.

We return the maximum value that can be used to obtain a meaningful
symbolic name or message.

@@end deftypefn

*/

int
errno_max (void)
{
  int maxsize;

  if (error_names == NULL)
    {
      init_error_tables ();
    }
  maxsize = MAX (sys_nerr, num_error_names);
  return (maxsize - 1);
}

#ifndef HAVE_STRERROR

/*

@@deftypefn Supplemental char* strerror (int @@var{errnoval})

Maps an @@code{errno} number to an error message string, the contents
of which are implementation defined.  On systems which have the
external variables @@code{sys_nerr} and @@code{sys_errlist}, these
strings will be the same as the ones used by @@code{perror}.

If the supplied error number is within the valid range of indices for
the @@code{sys_errlist}, but no message is available for the particular
error number, then returns the string @@samp{Error @@var{num}}, where
@@var{num} is the error number.

If the supplied error number is not a valid index into
@@code{sys_errlist}, returns @@code{NULL}.

The returned string is only guaranteed to be valid only until the
next call to @@code{strerror}.

@@end deftypefn

*/

char *
strerror (int errnoval)
{
  const char *msg;
  static char buf[32];

#ifndef HAVE_SYS_ERRLIST

  if (error_names == NULL)
    {
      init_error_tables ();
    }

#endif

  if ((errnoval < 0) || (errnoval >= sys_nerr))
    {
#ifdef EVMSERR
      if (errnoval == evmserr.value)
	msg = evmserr.msg;
      else
#endif
      /* Out of range, just return NULL */
      msg = NULL;
    }
  else if ((sys_errlist == NULL) || (sys_errlist[errnoval] == NULL))
    {
      /* In range, but no sys_errlist or no entry at this index. */
      sprintf (buf, "Error %d", errnoval);
      msg = buf;
    }
  else
    {
      /* In range, and a valid message.  Just return the message. */
      msg = (char *) sys_errlist[errnoval];
    }
  
  return (msg);
}

#endif	/* ! HAVE_STRERROR */


/*

@@deftypefn Replacement {const char*} strerrno (int @@var{errnum})

Given an error number returned from a system call (typically returned
in @@code{errno}), returns a pointer to a string containing the
symbolic name of that error number, as found in @@code{<errno.h>}.

If the supplied error number is within the valid range of indices for
symbolic names, but no name is available for the particular error
number, then returns the string @@samp{Error @@var{num}}, where @@var{num}
is the error number.

If the supplied error number is not within the range of valid
indices, then returns @@code{NULL}.

The contents of the location pointed to are only guaranteed to be
valid until the next call to @@code{strerrno}.

@@end deftypefn

*/

const char *
strerrno (int errnoval)
{
  const char *name;
  static char buf[32];

  if (error_names == NULL)
    {
      init_error_tables ();
    }

  if ((errnoval < 0) || (errnoval >= num_error_names))
    {
#ifdef EVMSERR
      if (errnoval == evmserr.value)
	name = evmserr.name;
      else
#endif
      /* Out of range, just return NULL */
      name = NULL;
    }
  else if ((error_names == NULL) || (error_names[errnoval] == NULL))
    {
      /* In range, but no error_names or no entry at this index. */
      sprintf (buf, "Error %d", errnoval);
      name = (const char *) buf;
    }
  else
    {
      /* In range, and a valid name.  Just return the name. */
      name = error_names[errnoval];
    }

  return (name);
}

/*

@@deftypefn Extension int strtoerrno (const char *@@var{name})

Given the symbolic name of a error number (e.g., @@code{EACCES}), map it
to an errno value.  If no translation is found, returns 0.

@@end deftypefn

*/

int
strtoerrno (const char *name)
{
  int errnoval = 0;

  if (name != NULL)
    {
      if (error_names == NULL)
	{
	  init_error_tables ();
	}
      for (errnoval = 0; errnoval < num_error_names; errnoval++)
	{
	  if ((error_names[errnoval] != NULL) &&
	      (strcmp (name, error_names[errnoval]) == 0))
	    {
	      break;
	    }
	}
      if (errnoval == num_error_names)
	{
#ifdef EVMSERR
	  if (strcmp (name, evmserr.name) == 0)
	    errnoval = evmserr.value;
	  else
#endif
	  errnoval = 0;
	}
    }
  return (errnoval);
}


/* A simple little main that does nothing but print all the errno translations
   if MAIN is defined and this file is compiled and linked. */

#ifdef MAIN

#include <stdio.h>

int
main (void)
{
  int errn;
  int errnmax;
  const char *name;
  const char *msg;
  char *strerror ();

  errnmax = errno_max ();
  printf ("%d entries in names table.\n", num_error_names);
  printf ("%d entries in messages table.\n", sys_nerr);
  printf ("%d is max useful index.\n", errnmax);

  /* Keep printing values until we get to the end of *both* tables, not
     *either* table.  Note that knowing the maximum useful index does *not*
     relieve us of the responsibility of testing the return pointer for
     NULL. */

  for (errn = 0; errn <= errnmax; errn++)
    {
      name = strerrno (errn);
      name = (name == NULL) ? "<NULL>" : name;
      msg = strerror (errn);
      msg = (msg == NULL) ? "<NULL>" : msg;
      printf ("%-4d%-18s%s\n", errn, name, msg);
    }

  return 0;
}

#endif
@


1.12
log
@merge from gcc
@
text
@d472 2
d475 2
d478 1
@


1.11
log
@merge from gcc
@
text
@d46 1
a46 1
static void init_error_tables PARAMS ((void));
d506 1
a506 1
init_error_tables ()
d587 1
a587 1
errno_max ()
d626 1
a626 2
strerror (errnoval)
  int errnoval;
d692 1
a692 2
strerrno (errnoval)
  int errnoval;
d739 1
a739 2
strtoerrno (name)
     const char *name;
d779 1
a779 1
main ()
@


1.10
log
@	* strerror.c: Revert last change.  Declare static sys_nerr
	and sys_errlist using different names.
@
text
@a4 3
#include "ansidecl.h"
#include "libiberty.h"

d16 3
@


1.10.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d5 3
a19 3
#include "ansidecl.h"
#include "libiberty.h"

@


1.9
log
@	* strerror.c: Don't provide or reference sys_errlist if
	strerror is available.
@
text
@a9 1
#ifndef HAVE_STRERROR
a18 1
#endif
a22 1
#ifndef HAVE_STRERROR
a26 1
#endif
a462 1
#ifndef HAVE_STRERROR
d465 2
a475 1
#endif
a540 1
#ifndef HAVE_STRERROR
a559 1
#endif
@


1.8
log
@merge from gcc
@
text
@d10 1
d20 1
d25 1
d30 1
d467 1
d479 1
a479 1

d545 1
d565 1
@


1.8.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a464 2
#define sys_nerr sys_nerr__
#define sys_errlist sys_errlist__
d474 1
@


1.8.22.1
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a464 2
#define sys_nerr sys_nerr__
#define sys_errlist sys_errlist__
d474 1
@


1.7
log
@merge from gcc
@
text
@d566 1
a566 1
@@deftypefn Replacement int errno_max (void)
d602 1
a602 1
@@deftypefn Replacement char* strerror (int @@var{errnoval})
d611 1
a611 1
error number, then returns the string @@samp{"Error @@var{num}"}, where
d670 1
a670 1
@@deftypefn Replacement const char* strerrno (int @@var{errnum})
d678 1
a678 1
number, then returns the string @@samp{"Error @@var{num}"}, where @@var{num}
d730 1
a730 1
@@deftypefn Replacement int strtoerrno (const char *@@var{name})
@


1.6
log
@merge from gcc
@
text
@d576 1
a576 1
implied by the largest @@code{errno} value defined in @@file{errno.h}.
d615 1
a615 1
@@code{sys_errlist}, returns NULL.
d674 1
a674 1
symbolic name of that error number, as found in @@file{errno.h}.
d682 1
a682 1
indices, then returns NULL.
d732 1
a732 1
Given the symbolic name of a error number (e.g., @@code{EACCESS}), map it
@


1.5
log
@merge from gcc
@
text
@d61 2
a62 2
  int value;		/* The numeric value from <errno.h> */
  const char *name;	/* The equivalent symbolic value */
d64 1
a64 1
  const char *msg;	/* Short message about this value */
d628 1
a628 1
  char *msg;
d786 1
a786 1
  char *msg;
@


1.4
log
@merge from gcc
@
text
@d611 2
a612 2
error number, then returns the string @@samp{"Error NUM"}, where NUM is
the error number.
d678 2
a679 2
number, then returns the string @@samp{"Error NUM"}, where NUM is the
error number.
d685 1
a685 1
valid until the next call to strerrno.
@


1.3
log
@merge from gcc
@
text
@a564 1
NAME
d566 1
a566 1
	errno_max -- return the max errno value
d568 9
a576 1
SYNOPSIS
d578 2
a579 1
	int errno_max ();
d581 1
a581 14
DESCRIPTION

	Returns the maximum errno value for which a corresponding symbolic
	name or message is available.  Note that in the case where
	we use the sys_errlist supplied by the system, it is possible for
	there to be more symbolic names than messages, or vice versa.
	In fact, the manual page for perror(3C) explicitly warns that one
	should check the size of the table (sys_nerr) before indexing it,
	since new error codes may be added to the system before they are
	added to the table.  Thus sys_nerr might be smaller than value
	implied by the largest errno value defined in <errno.h>.

	We return the maximum value that can be used to obtain a meaningful
	symbolic name or message.
d602 1
a602 3
NAME

	strerror -- map an error number to an error message string
d604 4
a607 1
SYNOPSIS
d609 4
a612 1
	char *strerror (int errnoval)
d614 2
a615 1
DESCRIPTION
d617 2
a618 4
	Maps an errno number to an error message string, the contents of
	which are implementation defined.  On systems which have the external
	variables sys_nerr and sys_errlist, these strings will be the same
	as the ones used by perror().
d620 1
a620 10
	If the supplied error number is within the valid range of indices
	for the sys_errlist, but no message is available for the particular
	error number, then returns the string "Error NUM", where NUM is the
	error number.

	If the supplied error number is not a valid index into sys_errlist,
	returns NULL.

	The returned string is only guaranteed to be valid only until the
	next call to strerror.
d670 1
a670 3
NAME

	strerrno -- map an error number to a symbolic name string
d672 3
a674 1
SYNOPSIS
d676 4
a679 1
	const char *strerrno (int errnoval)
d681 2
a682 1
DESCRIPTION
d684 2
a685 3
	Given an error number returned from a system call (typically
	returned in errno), returns a pointer to a string containing the
	symbolic name of that error number, as found in <errno.h>.
d687 1
a687 12
	If the supplied error number is within the valid range of indices
	for symbolic names, but no name is available for the particular
	error number, then returns the string "Error NUM", where NUM is
	the error number.

	If the supplied error number is not within the range of valid
	indices, then returns NULL.

BUGS

	The contents of the location pointed to are only guaranteed to be
	valid until the next call to strerrno.
d730 1
a730 7
NAME

	strtoerrno -- map a symbolic errno name to a numeric value

SYNOPSIS

	int strtoerrno (char *name)
d732 2
a733 1
DESCRIPTION
d735 1
a735 2
	Given the symbolic name of a error number, map it to an errno value.
	If no translation is found, returns 0.
@


1.2
log
@	* hashtab.c, partition.c, xmemdup.c: Include string.h
	if HAVE_STRING_H.
	* pexecute.c, xexit.c: Include stdlib.h if HAVE_STDLIB_H.
	* objalloc.c: Include config.h.  Include stdlib.h and don't
	declare malloc or free if HAVE_STDLIB_H.
	* strerror.c, strsignal.c: Include stdlib.h if HAVE_STDLIB_H,
	else declare malloc without prototype.  Include string.h if
	HAVE_STRING_H, else declare memset without prototype.  Don't
	include stddef.h.

	* sort.c: Bring over from GCC.
@
text
@d16 1
d24 1
@


1.1
log
@Initial revision
@
text
@d28 11
a38 8
#ifdef __STDC__
#include <stddef.h>
extern void *malloc (size_t size);				/* 4.10.3.3 */
extern void *memset (void *s, int c, size_t n);			/* 4.11.6.1 */
#else	/* !__STDC__ */
extern char *malloc ();		/* Standard memory allocater */
extern char *memset ();
#endif	/* __STDC__ */
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

