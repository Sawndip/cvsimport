head	1.1;
branch	1.1.1;
access;
symbols
	cygwin-1_7_35-release:1.1.1.1
	cygwin-1_7_34-release:1.1.1.1
	newlib-2_2_0:1.1.1.1.0.16
	cygwin-1_7_33-release:1.1.1.1
	cygwin-1_7_32-release:1.1.1.1
	cygwin-1_7_31-release:1.1.1.1
	cygwin-1_7_30-release:1.1.1.1
	cygwin-1_7_29-release:1.1.1.1
	cygwin-1_7_28-release:1.1.1.1
	newlib-2_1_0:1.1.1.1
	cygwin-1_7_27-release:1.1.1.1
	cygwin-1_7_26-release:1.1.1.1
	cygwin-1_7_25-release:1.1.1.1
	cygwin-1_7_24-release:1.1.1.1
	cygwin-1_7_23-release:1.1.1.1
	cygwin-1_7_22-release:1.1.1.1
	cygwin-1_7_21-release:1.1.1.1
	cygwin-1_7_20-release:1.1.1.1
	cygwin-1_7_19-release:1.1.1.1
	cygwin-64bit-postmerge:1.1.1.1
	cygwin-64bit-premerge-branch:1.1.1.1.0.14
	cygwin-64bit-premerge:1.1.1.1
	cygwin-1_7_18-release:1.1.1.1
	newlib-2_0_0:1.1.1.1
	cygwin-1_7_17-release:1.1.1.1
	cygwin-64bit-branch:1.1.1.1.0.12
	cygwin-1_7_16-release:1.1.1.1
	cygwin-1_7_15-release:1.1.1.1
	cygwin-1_7_14_2-release:1.1.1.1
	cygwin-1_7_14-release:1.1.1.1
	cygwin-1_7_12-release:1.1.1.1
	cygwin-1_7_11-release:1.1.1.1
	cygwin-1_7_10-release:1.1.1.1
	newlib-1_20_0:1.1.1.1
	cygwin-1_7_9-release:1.1.1.1
	cygwin-1_7_8-release:1.1.1.1
	newlib-1_19_0:1.1.1.1
	cygwin-1_7_7-release:1.1.1.1
	cygwin-1_7_5-release:1.1.1.1
	cygwin-1_7_4-release:1.1.1.1
	cygwin-1_7_3-release:1.1.1.1
	cygwin-1_7_2-release:1.1.1.1
	newlib-1_18_0:1.1.1.1
	cygwin-1_7_1-release:1.1.1.1
	newlib-1_17_0-arc:1.1.1.1.0.10
	binutils-arc-20080908-branch:1.1.1.1.0.8
	binutils-arc-20080908-branchpoint:1.1.1.1
	newlib-1_17_0:1.1.1.1
	newlib-1_16_0:1.1.1.1
	newlib-1_15_0:1.1.1.1
	newlib-csl-coldfire-4_1-32:1.1.1.1
	newlib-csl-sourcerygxx-4_1-32:1.1.1.1
	newlib-csl-innovasic-fido-3_4_4-33:1.1.1.1
	newlib-csl-coldfire-4_1-30:1.1.1.1
	newlib-csl-sourcerygxx-4_1-30:1.1.1.1
	newlib-csl-coldfire-4_1-28:1.1.1.1
	newlib-csl-sourcerygxx-4_1-28:1.1.1.1
	newlib-csl-arm-2006q3-27:1.1.1.1
	newlib-csl-sourcerygxx-4_1-27:1.1.1.1
	newlib-csl-arm-2006q3-26:1.1.1.1
	newlib-csl-sourcerygxx-4_1-26:1.1.1.1
	newlib-csl-sourcerygxx-4_1-24:1.1.1.1
	newlib-csl-sourcerygxx-4_1-23:1.1.1.1
	newlib-csl-sourcerygxx-4_1-21:1.1.1.1
	newlib-csl-arm-2006q3-21:1.1.1.1
	newlib-csl-arm-2006q3-19:1.1.1.1
	newlib-csl-sourcerygxx-4_1-19:1.1.1.1
	newlib-csl-sourcerygxx-4_1-18:1.1.1.1
	newlib-csl-sourcerygxx-3_4_4-25:1.1.1.1
	newlib-csl-sourcerygxx-4_1-17:1.1.1.1
	cr-0x5f1:1.1.1.1.0.6
	newlib-csl-sourcerygxx-4_1-14:1.1.1.1
	newlib-csl-sourcerygxx-4_1-13:1.1.1.1
	newlib-csl-sourcerygxx-4_1-12:1.1.1.1
	newlib-csl-sourcerygxx-4_1-9:1.1.1.1
	newlib-csl-sourcerygxx-4_1-8:1.1.1.1
	newlib-csl-sourcerygxx-4_1-7:1.1.1.1
	newlib-csl-arm-2006q1-6:1.1.1.1
	newlib-csl-sourcerygxx-4_1-6:1.1.1.1
	newlib-csl-sourcerygxx-4_1-5:1.1.1.1
	newlib-csl-sourcerygxx-4_1-4:1.1.1.1
	newlib-autotools-branch:1.1.1.1.0.4
	newlib-csl-20060320-branch:1.1.1.1.0.2
	newlib-csl-20060320-branchpoint:1.1.1.1
	newlib-1_14_0:1.1.1.1
	newlib-csl-arm-2005-q1b:1.1.1.1
	newlib-csl-arm-2005-q1a:1.1.1.1
	newlib-1_13_0:1.1.1.1
	csl-arm-2004-q3:1.1.1.1
	csl-arm-2004-q1a:1.1.1.1
	csl-arm-2004-q1:1.1.1.1
	newlib-1_12_0:1.1.1.1
	csl-arm-2003-q4:1.1.1.1
	w32api-2_2:1.1.1.1
	mingw-runtime-2_4:1.1.1.1
	newlib-1_11_0:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	newlib-1_10_0:1.1.1.1
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2000.02.17.19.39.52;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.52;	author cgf;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@
#include "test.h"
#include <errno.h>


int
_DEFUN_VOID(randi)
{
  static int next;
  next = (next * 1103515245) + 12345;
  return ((next >> 16) & 0xffff);
}

double _DEFUN_VOID(randx)
{
  double res;
  
  do 
  {
    union {
	short parts[4];
	double res;
      } u;
    
    u.parts[0] = randi();
    u.parts[1] = randi();
    u.parts[2] = randi();
    u.parts[3] = randi();
    res = u.res;
    
  } while (!finite(res));
  
  return res ;
}

/* Return a random double, but bias for numbers closer to 0 */
double _DEFUN_VOID(randy)
{
  int pow;
  double r= randx();
  r = frexp(r, &pow);
  return ldexp(r, randi() & 0x1f);
}

void
_DEFUN_VOID(test_frexp)
{
  int i;
  double r;
  int t;
  
  float xf;  
  double gives;

  int pow;

  
  /* Frexp of x return a and n, where a * 2**n == x, so test this with a
     set of random numbers */
  for (t = 0; t < 2; t++)   
  {
    for (i = 0; i < 1000; i++)  
    {
      
      double x = randx();   
      line(i);   
      switch (t) 
      {
      case 0:
	newfunc("frexp/ldexp");
	r = frexp(x, &pow);
	if (r > 1.0 || r < -1.0) 
	{ 
	  /* Answer can never be > 1 or < 1 */
	  test_iok(0,1);
	}
	
	gives = ldexp(r ,pow);
	test_mok(gives,x,62);
	break;
      case 1:
	newfunc("frexpf/ldexpf");
	if (x > FLT_MIN && x < FLT_MAX)
	{
	  /* test floats too, but they have a smaller range so make sure x
	     isn't too big. Also x can get smaller than a float can
	     represent to make sure that doesn't happen too */
	  xf = x;
	  r = frexpf(xf, &pow);
	  if (r > 1.0 || r < -1.0) 
	  { 
	    /* Answer can never be > 1 or < -1 */
	    test_iok(0,1);
	  }

	  gives = ldexpf(r ,pow);
	  test_mok(gives,x, 32);
	  
	}
      }

    }
    
  }
  
  /* test a few numbers manually to make sure frexp/ldexp are not
     testing as ok because both are broken */

  r = frexp(64.0, &i);
  
  test_mok(r, 0.5,64);
  test_iok(i, 7);

  r = frexp(96.0, &i);
  
  test_mok(r, 0.75, 64);
  test_iok(i, 7);
  
}

/* Test mod - this is given a real hammering by the strtod type
   routines, here are some more tests.

   By definition

   modf = func(value, &iptr)

      (*iptr + modf) == value

   we test this

*/
void
_DEFUN_VOID(test_mod)
{
  int i;
  
  newfunc("modf");

  
  for (i = 0; i < 1000; i++) 
  {
    double intpart;
    double n;
    line(i);
    n  = randx();
    if (finite(n) && n != 0.0 )
    {
      double r = modf(n, &intpart);
      line(i);
      test_mok(intpart + r, n, 63);
    }
    
  }
  newfunc("modff");
  
  for (i = 0; i < 1000; i++) 
  {
    float intpart;
    double nd;
    line(i);
    nd  = randx() ;
    if (nd < FLT_MAX && finitef(nd) && nd != 0.0)
    {
      float n = nd;
      double r = modff(n, &intpart);
      line(i);
      test_mok(intpart + r, n, 32);
    }
  }


}

/*
Test pow by multiplying logs  
*/
void
_DEFUN_VOID(test_pow)
{
  unsigned int i;  
  newfunc("pow");

  for (i = 0; i < 1000; i++) 
  {
    double n1;
    double n2;
    double res;
    double shouldbe;

    line(i);  
    n1 = fabs(randy());
    n2 = fabs(randy()/100.0);
    res = pow(n1, n2);
    shouldbe = exp(log(n1) * n2);
    test_mok(shouldbe, res,64);
  }

  newfunc("powf");
  
  for (i = 0; i < 1000; i++) 
  {
    double n1;
    double n2;
    double res;
    double shouldbe;

    errno = 0;
    
    line(i);  
    n1 = fabs(randy());
    n2 = fabs(randy()/100.0);
    res = powf(n1, n2);
    shouldbe = expf(logf(n1) * n2);
    if (!errno)
     test_mok(shouldbe, res,28);
  }




}



void
_DEFUN_VOID(test_math2)
{
  test_mod();  
  test_frexp();
  test_pow();
}
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
