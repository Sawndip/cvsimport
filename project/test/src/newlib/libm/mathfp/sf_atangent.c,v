head	1.2;
access;
symbols
	cygwin-1_7_35-release:1.2
	cygwin-1_7_34-release:1.2
	newlib-2_2_0:1.2.0.16
	cygwin-1_7_33-release:1.2
	cygwin-1_7_32-release:1.2
	cygwin-1_7_31-release:1.2
	cygwin-1_7_30-release:1.2
	cygwin-1_7_29-release:1.2
	cygwin-1_7_28-release:1.2
	newlib-2_1_0:1.2
	cygwin-1_7_27-release:1.2
	cygwin-1_7_26-release:1.2
	cygwin-1_7_25-release:1.2
	cygwin-1_7_24-release:1.2
	cygwin-1_7_23-release:1.2
	cygwin-1_7_22-release:1.2
	cygwin-1_7_21-release:1.2
	cygwin-1_7_20-release:1.2
	cygwin-1_7_19-release:1.2
	cygwin-64bit-postmerge:1.2
	cygwin-64bit-premerge-branch:1.2.0.14
	cygwin-64bit-premerge:1.2
	cygwin-1_7_18-release:1.2
	newlib-2_0_0:1.2
	cygwin-1_7_17-release:1.2
	cygwin-64bit-branch:1.2.0.12
	cygwin-1_7_16-release:1.2
	cygwin-1_7_15-release:1.2
	cygwin-1_7_14_2-release:1.2
	cygwin-1_7_14-release:1.2
	cygwin-1_7_12-release:1.2
	cygwin-1_7_11-release:1.2
	cygwin-1_7_10-release:1.2
	newlib-1_20_0:1.2
	cygwin-1_7_9-release:1.2
	cygwin-1_7_8-release:1.2
	newlib-1_19_0:1.2
	cygwin-1_7_7-release:1.2
	cygwin-1_7_5-release:1.2
	cygwin-1_7_4-release:1.2
	cygwin-1_7_3-release:1.2
	cygwin-1_7_2-release:1.2
	newlib-1_18_0:1.2
	cygwin-1_7_1-release:1.2
	newlib-1_17_0-arc:1.2.0.10
	binutils-arc-20080908-branch:1.2.0.8
	binutils-arc-20080908-branchpoint:1.2
	newlib-1_17_0:1.2
	newlib-1_16_0:1.2
	newlib-1_15_0:1.2
	newlib-csl-coldfire-4_1-32:1.2
	newlib-csl-sourcerygxx-4_1-32:1.2
	newlib-csl-innovasic-fido-3_4_4-33:1.2
	newlib-csl-coldfire-4_1-30:1.2
	newlib-csl-sourcerygxx-4_1-30:1.2
	newlib-csl-coldfire-4_1-28:1.2
	newlib-csl-sourcerygxx-4_1-28:1.2
	newlib-csl-arm-2006q3-27:1.2
	newlib-csl-sourcerygxx-4_1-27:1.2
	newlib-csl-arm-2006q3-26:1.2
	newlib-csl-sourcerygxx-4_1-26:1.2
	newlib-csl-sourcerygxx-4_1-24:1.2
	newlib-csl-sourcerygxx-4_1-23:1.2
	newlib-csl-sourcerygxx-4_1-21:1.2
	newlib-csl-arm-2006q3-21:1.2
	newlib-csl-arm-2006q3-19:1.2
	newlib-csl-sourcerygxx-4_1-19:1.2
	newlib-csl-sourcerygxx-4_1-18:1.2
	newlib-csl-sourcerygxx-3_4_4-25:1.2
	newlib-csl-sourcerygxx-4_1-17:1.2
	cr-0x5f1:1.2.0.6
	newlib-csl-sourcerygxx-4_1-14:1.2
	newlib-csl-sourcerygxx-4_1-13:1.2
	newlib-csl-sourcerygxx-4_1-12:1.2
	newlib-csl-sourcerygxx-4_1-9:1.2
	newlib-csl-sourcerygxx-4_1-8:1.2
	newlib-csl-sourcerygxx-4_1-7:1.2
	newlib-csl-arm-2006q1-6:1.2
	newlib-csl-sourcerygxx-4_1-6:1.2
	newlib-csl-sourcerygxx-4_1-5:1.2
	newlib-csl-sourcerygxx-4_1-4:1.2
	newlib-autotools-branch:1.2.0.4
	newlib-csl-20060320-branch:1.2.0.2
	newlib-csl-20060320-branchpoint:1.2
	newlib-1_14_0:1.1.1.1
	newlib-csl-arm-2005-q1b:1.1.1.1
	newlib-csl-arm-2005-q1a:1.1.1.1
	newlib-1_13_0:1.1.1.1
	csl-arm-2004-q3:1.1.1.1
	csl-arm-2004-q1a:1.1.1.1
	csl-arm-2004-q1:1.1.1.1
	newlib-1_12_0:1.1.1.1
	csl-arm-2003-q4:1.1.1.1
	w32api-2_2:1.1.1.1
	mingw-runtime-2_4:1.1.1.1
	newlib-1_11_0:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	newlib-1_10_0:1.1.1.1
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2006.01.10.16.51.58;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.52;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.52;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.2
log
@
2006-01-10  Jeff Johnston  <jjohnstn@@redhat.com>

        * libm/mathfp/s_frexp.c: Check for special values on
        the original input, not the manipulated output value.
        * libm/mathfp/sf_frexp.c: Ditto.
        * libm/mathfp/s_atangent.c: Don't use local value branch
        when checking for quadrant.
        * libm/mathfp/sf_atangent.c: Ditto.
@
text
@
/* @@(#)z_atangentf.c 1.0 98/08/13 */
/******************************************************************
 * The following routines are coded directly from the algorithms
 * and coefficients given in "Software Manual for the Elementary
 * Functions" by William J. Cody, Jr. and William Waite, Prentice
 * Hall, 1980.
 ******************************************************************/
/******************************************************************
 * Arctangent
 *
 * Input:
 *   x - floating point value
 *
 * Output:
 *   arctangent of x
 *
 * Description:
 *   This routine calculates arctangents.
 *
 *****************************************************************/

#include <float.h>
#include "fdlibm.h"
#include "zmath.h"

static const float ROOT3 = 1.732050807;
static const float a[] = { 0.0, 0.523598775, 1.570796326,
                     1.047197551 };
static const float q[] = { 0.1412500740e+1 };
static const float p[] = { -0.4708325141, -0.5090958253e-1 };

float
_DEFUN (atangentf, (float, float, float, int),
        float x _AND
        float v _AND
        float u _AND
        int arctan2)
{
  float f, g, R, P, Q, A, res;
  int N;
  int branch = 0;
  int expv, expu;

  /* Preparation for calculating arctan2. */
  if (arctan2)
    {
      if (u == 0.0)
        if (v == 0.0)
          {
            errno = ERANGE;
            return (z_notanum_f.f);
          }
        else
          {
            branch = 1;
            res = __PI_OVER_TWO;
          }

      if (!branch)
        {
          int e;
          /* Get the exponent values of the inputs. */
          g = frexpf (v, &expv);
          g = frexpf (u, &expu);

          /* See if a divide will overflow. */
          e = expv - expu;
          if (e > FLT_MAX_EXP)
            {
               branch = 1;
               res = __PI_OVER_TWO;
            }

          /* Also check for underflow. */
          else if (e < FLT_MIN_EXP)
            {
               branch = 2;
               res = 0.0;
            }
         }
    }

  if (!branch)
    {
      if (arctan2)
        f = fabsf (v / u);
      else
        f = fabsf (x);

      if (f > 1.0)
        {
          f = 1.0 / f;
          N = 2;
        }
      else
        N = 0;

      if (f > (2.0 - ROOT3))
        {
          A = ROOT3 - 1.0;
          f = (((A * f - 0.5) - 0.5) + f) / (ROOT3 + f);
          N++;
        }

      /* Check for values that are too small. */
      if (-z_rooteps_f < f && f < z_rooteps_f)
        res = f;

      /* Calculate the Taylor series. */
      else
        {
          g = f * f;
          P = (p[1] * g + p[0]) * g;
          Q = g + q[0];
          R = P / Q;

          res = f + f * R;
        }

      if (N > 1)
        res = -res;

      res += a[N];
    }

  if (arctan2)
    {
      if (u < 0.0)
        res = __PI - res;
      if (v < 0.0)
        res = -res;
    }
  else if (x < 0.0)
    {
      res = -res;
    }

  return (res);
}
@


1.1
log
@Initial revision
@
text
@d129 1
a129 1
      if (u < 0.0 || branch == 2)
d131 1
a131 1
      if (v < 0.0 || branch == 1)
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
