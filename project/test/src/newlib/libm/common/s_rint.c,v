head	1.3;
access;
symbols
	cygwin-1_7_35-release:1.3
	cygwin-1_7_34-release:1.3
	newlib-2_2_0:1.3.0.6
	cygwin-1_7_33-release:1.3
	cygwin-1_7_32-release:1.3
	cygwin-1_7_31-release:1.3
	cygwin-1_7_30-release:1.3
	cygwin-1_7_29-release:1.3
	cygwin-1_7_28-release:1.3
	newlib-2_1_0:1.3
	cygwin-1_7_27-release:1.3
	cygwin-1_7_26-release:1.3
	cygwin-1_7_25-release:1.3
	cygwin-1_7_24-release:1.3
	cygwin-1_7_23-release:1.3
	cygwin-1_7_22-release:1.3
	cygwin-1_7_21-release:1.3
	cygwin-1_7_20-release:1.3
	cygwin-1_7_19-release:1.3
	cygwin-64bit-postmerge:1.3
	cygwin-64bit-premerge-branch:1.3.0.4
	cygwin-64bit-premerge:1.3
	cygwin-1_7_18-release:1.3
	newlib-2_0_0:1.3
	cygwin-1_7_17-release:1.3
	cygwin-64bit-branch:1.3.0.2
	cygwin-1_7_16-release:1.3
	cygwin-1_7_15-release:1.3
	cygwin-1_7_14_2-release:1.3
	cygwin-1_7_14-release:1.3
	cygwin-1_7_12-release:1.3
	cygwin-1_7_11-release:1.3
	cygwin-1_7_10-release:1.3
	newlib-1_20_0:1.3
	cygwin-1_7_9-release:1.3
	cygwin-1_7_8-release:1.3
	newlib-1_19_0:1.3
	cygwin-1_7_7-release:1.3
	cygwin-1_7_5-release:1.3
	cygwin-1_7_4-release:1.3
	cygwin-1_7_3-release:1.3
	cygwin-1_7_2-release:1.3
	newlib-1_18_0:1.2
	cygwin-1_7_1-release:1.2
	newlib-1_17_0-arc:1.1.1.1.0.10
	binutils-arc-20080908-branch:1.1.1.1.0.8
	binutils-arc-20080908-branchpoint:1.1.1.1
	newlib-1_17_0:1.1.1.1
	newlib-1_16_0:1.1.1.1
	newlib-1_15_0:1.1.1.1
	newlib-csl-coldfire-4_1-32:1.1.1.1
	newlib-csl-sourcerygxx-4_1-32:1.1.1.1
	newlib-csl-innovasic-fido-3_4_4-33:1.1.1.1
	newlib-csl-coldfire-4_1-30:1.1.1.1
	newlib-csl-sourcerygxx-4_1-30:1.1.1.1
	newlib-csl-coldfire-4_1-28:1.1.1.1
	newlib-csl-sourcerygxx-4_1-28:1.1.1.1
	newlib-csl-arm-2006q3-27:1.1.1.1
	newlib-csl-sourcerygxx-4_1-27:1.1.1.1
	newlib-csl-arm-2006q3-26:1.1.1.1
	newlib-csl-sourcerygxx-4_1-26:1.1.1.1
	newlib-csl-sourcerygxx-4_1-24:1.1.1.1
	newlib-csl-sourcerygxx-4_1-23:1.1.1.1
	newlib-csl-sourcerygxx-4_1-21:1.1.1.1
	newlib-csl-arm-2006q3-21:1.1.1.1
	newlib-csl-arm-2006q3-19:1.1.1.1
	newlib-csl-sourcerygxx-4_1-19:1.1.1.1
	newlib-csl-sourcerygxx-4_1-18:1.1.1.1
	newlib-csl-sourcerygxx-3_4_4-25:1.1.1.1
	newlib-csl-sourcerygxx-4_1-17:1.1.1.1
	cr-0x5f1:1.1.1.1.0.6
	newlib-csl-sourcerygxx-4_1-14:1.1.1.1
	newlib-csl-sourcerygxx-4_1-13:1.1.1.1
	newlib-csl-sourcerygxx-4_1-12:1.1.1.1
	newlib-csl-sourcerygxx-4_1-9:1.1.1.1
	newlib-csl-sourcerygxx-4_1-8:1.1.1.1
	newlib-csl-sourcerygxx-4_1-7:1.1.1.1
	newlib-csl-arm-2006q1-6:1.1.1.1
	newlib-csl-sourcerygxx-4_1-6:1.1.1.1
	newlib-csl-sourcerygxx-4_1-5:1.1.1.1
	newlib-csl-sourcerygxx-4_1-4:1.1.1.1
	newlib-autotools-branch:1.1.1.1.0.4
	newlib-csl-20060320-branch:1.1.1.1.0.2
	newlib-csl-20060320-branchpoint:1.1.1.1
	newlib-1_14_0:1.1.1.1
	newlib-csl-arm-2005-q1b:1.1.1.1
	newlib-csl-arm-2005-q1a:1.1.1.1
	newlib-1_13_0:1.1.1.1
	csl-arm-2004-q3:1.1.1.1
	csl-arm-2004-q1a:1.1.1.1
	csl-arm-2004-q1:1.1.1.1
	newlib-1_12_0:1.1.1.1
	csl-arm-2003-q4:1.1.1.1
	w32api-2_2:1.1.1.1
	mingw-runtime-2_4:1.1.1.1
	newlib-1_11_0:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	newlib-1_10_0:1.1.1.1
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2010.03.08.17.16.37;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.25.19.13.01;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.51;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.51;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.3
log
@
2010-03-08  Craig Howland <howland@@LGSInnovations.com>

        * libm/common/s_rint.c:  Fix error when integral part had 18 bits and
        fraction had bits set beyond first radix bit.  Also, make 2-part
        adjustment consistent with 1-part adjustment when adjusting fractional
        bits.
        * libm/common/sf_rint.c:  Make fractional-bit adjustment consistent
        with s_rint.c by setting 0b.01 instead of 0b.001.
@
text
@
/* @@(#)s_rint.c 5.1 93/09/24 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */
/*
FUNCTION
<<rint>>, <<rintf>>--round to integer
INDEX
	rint
INDEX
	rintf

ANSI_SYNOPSIS
	#include <math.h>
	double rint(double <[x]>);
	float rintf(float <[x]>);

DESCRIPTION
	The <<rint>> functions round their argument to an integer value in
	floating-point format, using the current rounding direction.  They
	raise the "inexact" floating-point exception if the result differs
	in value from the argument.  See the <<nearbyint>> functions for the
	same function with the "inexact" floating-point exception never being
	raised.  Newlib does not directly support floating-point exceptions.
	The <<rint>> functions are written so that the "inexact" exception is
	raised in hardware implementations that support it, even though Newlib
	does not provide access.

RETURNS
<[x]> rounded to an integral value, using the current rounding direction.

PORTABILITY
ANSI C, POSIX

SEEALSO
<<nearbyint>>, <<round>>

*/

/*
 * rint(x)
 * Return x rounded to integral value according to the prevailing
 * rounding mode.
 * Method:
 *	Using floating addition.
 *	Whenever a fraction is present, if the second or any following bit after
 *	the radix point is set, limit to the second radix point to avoid
 *	possible double rounding in the TWO52 +- steps (in case guard bits are
 *	used).  Specifically, if have any, chop off bits past the 2nd place and
 *	set the second place.
 *	(e.g.	2.0625=0b10.0001 => 0b10.01=2.25;
 *		2.3125=0b10.011  => 0b10.01=2.25;
 *		1.5625= 0b1.1001 =>  0b1.11=1.75;
 *		1.9375= 0b1.1111 =>  0b1.11=1.75.
 *	Pseudo-code:  if(x.frac & ~0b0.10) x.frac = (x.frac & 0b0.11) | 0b0.01;).
 * Exception:
 *	Inexact flag raised if x not equal to rint(x).
 */

#include "fdlibm.h"

#ifndef _DOUBLE_IS_32BITS

#ifdef __STDC__
static const double
#else
static double 
#endif
TWO52[2]={
  4.50359962737049600000e+15, /* 0x43300000, 0x00000000 */
 -4.50359962737049600000e+15, /* 0xC3300000, 0x00000000 */
};

#ifdef __STDC__
	double rint(double x)
#else
	double rint(x)
	double x;
#endif
{
	__int32_t i0,j0,sx;
	__uint32_t i,i1;
	double t;
	volatile double w;
	EXTRACT_WORDS(i0,i1,x);
	sx = (i0>>31)&1;		/* sign */
	j0 = ((i0>>20)&0x7ff)-0x3ff;	/* exponent */
	if(j0<20) {			/* no integral bits in LS part */
	    if(j0<0) { 			/* x is fractional or 0 */
		if(((i0&0x7fffffff)|i1)==0) return x;	/* x == 0 */
		i1 |= (i0&0x0fffff);
		i0 &= 0xfffe0000;
		i0 |= ((i1|-i1)>>12)&0x80000;
		SET_HIGH_WORD(x,i0);
	        w = TWO52[sx]+x;
	        t =  w-TWO52[sx];
		GET_HIGH_WORD(i0,t);
		SET_HIGH_WORD(t,(i0&0x7fffffff)|(sx<<31));
	        return t;
	    } else {			/* x has integer and maybe fraction */
		i = (0x000fffff)>>j0;
		if(((i0&i)|i1)==0) return x; /* x is integral */
		i>>=1;
		if(((i0&i)|i1)!=0) {
		    /* 2nd or any later bit after radix is set */
		    if(j0==19) i1 = 0x80000000; else i1 = 0;
		    i0 = (i0&(~i))|((0x40000)>>j0);
		}
	    }
	} else if (j0>51) {
	    if(j0==0x400) return x+x;	/* inf or NaN */
	    else return x;		/* x is integral */
	} else {
	    i = ((__uint32_t)(0xffffffff))>>(j0-20);
	    if((i1&i)==0) return x;	/* x is integral */
	    i>>=1;
	    if((i1&i)!=0) i1 = (i1&(~i))|((0x40000000)>>(j0-20));
	}
	INSERT_WORDS(x,i0,i1);
	w = TWO52[sx]+x;
	return w-TWO52[sx];
}

#endif /* _DOUBLE_IS_32BITS */
@


1.2
log
@
2009-03-25  Craig Howland <howland@@LGSInnovations.com>

	* libc/include/math.h:  (llround, llroundf): Declare.
	* libm/common/s_llround.c: New file, implementing llround().
	* libm/common/sf_llround.c: New file, implementing llroundf().
	* libm/common/sf_lround.c: Remove spurious cast in _DOUBLE_IS_32BITS
	version of function.
	* libm/common/sf_lrint.c: Ditto.
	* libm/common/sf_logb.c:  Corrected return for subnormal argument
	by replacing existing function with a version created from sf_ilogb.c.
	* libm/common/s_logb.c: Ditto, except starting point s_ilogb.c.  Also
	added documentation for logb() and logbf().
	* libm/common/s_signbit.c:  Add signbit() documentation.
	* libm/common/s_log2.c: Update return values to match what w_log2.c has,
	since log2 uses log(); add note about being derived instead of direct.
	* libm/common/sf_fma.c: Add casts to attempt to get correct results,
	as well as comments pointing out problems with the implementation.
	* libm/common/s_fma.c: Add fma() and fmaf() documentation.
	* libm/common/sf_remquo.c: Incorrect quotient returns for large values
	corrected by discarding existing function and replacing with Sun
	verion, with some enhancements.
	* libm/common/s_remquo.c: Ditto.  Add remquo() and remquof()
	documentation.
	* libm/common/s_fmax.c: Add fmax() and fmaxf() documentation.
	* libm/common/s_fmin.c: Add fmin() and fminf() documentation.
	* libm/common/s_fdim.c: Return NAN for NAN arg, add fdim() and fdimf()
	documentation.
	* libm/common/sf_fdim.c: Return NAN for NAN arg, HUGE_VALF for inf arg.
	* libm/common/s_trunc.c: Add trunc() and truncf() documentation.
	* libm/common/s_rint.c: Add rint() and rintf() documentation.
	* libm/common/s_round.c: Add round() and roundf() documentation.
	* libm/common/s_scalbn.c: Add scalbln() and scalblnf() documentation.
	* libm/common/s_infinity.c: Add infinity() and infinityf()
	documentation.
	* libm/common/s_lround.c: Add lround(), lroundf(), llround(), and
	llroundf() documentation.
	* libm/common/s_lrint.c: Add lrint(), lrintf(), llrint(), and llrintf()
	documentation.
	* libm/common/isgreater.c: New file for documenting math.h function-like
	macros isgreater(), isgreaterequal(), isless(), islessequal(),
	islessgreater(), and isunordered().
	* libm/common/s_isnan.c: Add documentation for function-like macros
	fpclassify(), isfinite(), isinf(), isnan(), and isnormal().
	* libm/common/s_nearbyint.c: Add nearbyint() and nearbyintf()
	documentation.
	* libm/common/Makefile.am: Add s_llround.c (src); sf_llround.c (fsrc);
	s_fdim.def, s_fma.def, s_fmax.def, s_fmin.def,
	s_logb.def, s_lrint.def, s_lround.def, s_nearbyint.def, s_remquo.def,
        s_rint.def, s_round.def, s_signbit.def, s_trunc.def, and
        isgreater.def (chobj);
	re-name all existing chew files (chobj) to match source file base
	names (put in underscores), delete all special targets for chew files
	(leaving all to be generated by rule).
	* libm/common/Makefile.in: regenerate.
	* libm/math/w_exp2.c: Add "base 2" to documentation description (and
	delete TRAD_SYNOPSIS).
	* libm/math/w_gamma.c: Add tgamma() and tgammaf() documentation, along
	with some history behind the function names.
	* libm/math/math.tex: Add includes for newly-added documentation (see
	.def additions to common/Makefile.am and math/Makefile.am in this
	ChangeLog list), adjusted existing .def file names to match source file
	base names (added underscores); add mention of HUGE_VALF; rename
	"Version of library" section to "Error Handling" and add some text
	about floating-point exception; added section "Standards Compliance And
	Portability".
	* libm/math/Makefile.am: Add w_exp2.def (chobj);
	re-name all existing chew files (chobj) to match source file base
	names, delete all special targets for chew files (leaving all to be
	generated by rule).
	* libm/math/Makefile.in: regenerated
	* doc/makedoc.c: Change silent ignoring of commands < 5 characters
	to a failure when reading macro file for commands < 4 characters;
	add -v (verbose) option for printing some debugging information;
	get rid of spurious translation of "@@*" to "*" (no source files used @@*,
	so no existing doc pages were affected); clean up some compiler
	warnings.
	* doc/doc.str: add BUGS and SEEALSO sections (to match texi2pod.pl
	which has them); Remove ITEM command (redundant with makedoc built-in
	"o", not used in any present source file so nothing is lost, anyway).
	* HOWTO: New file to hold information for maintainers regarding how
	to do things.  Initial sections on documentation and ELIX levels.
@
text
@d54 10
d94 5
a98 5
	sx = (i0>>31)&1;
	j0 = ((i0>>20)&0x7ff)-0x3ff;
	if(j0<20) {
	    if(j0<0) { 	
		if(((i0&0x7fffffff)|i1)==0) return x;
d108 1
a108 1
	    } else {
d113 3
a115 2
		    if(j0==19) i1 = 0x40000000; else
		    i0 = (i0&(~i))|((0x20000)>>j0);
a132 3



@


1.1
log
@Initial revision
@
text
@d13 34
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
