head	1.10;
access;
symbols
	cygwin-1_7_35-release:1.10
	cygwin-1_7_34-release:1.10
	newlib-2_2_0:1.10.0.2
	cygwin-1_7_33-release:1.10
	cygwin-1_7_32-release:1.10
	cygwin-1_7_31-release:1.9
	cygwin-1_7_30-release:1.8
	cygwin-1_7_29-release:1.8
	cygwin-1_7_28-release:1.8
	newlib-2_1_0:1.8
	cygwin-1_7_27-release:1.8
	cygwin-1_7_26-release:1.8
	cygwin-1_7_25-release:1.8
	cygwin-1_7_24-release:1.8
	cygwin-1_7_23-release:1.8
	cygwin-1_7_22-release:1.8
	cygwin-1_7_21-release:1.8
	cygwin-1_7_20-release:1.8
	cygwin-1_7_19-release:1.8
	cygwin-64bit-postmerge:1.8
	cygwin-64bit-premerge-branch:1.8.0.4
	cygwin-64bit-premerge:1.8
	cygwin-1_7_18-release:1.8
	newlib-2_0_0:1.8
	cygwin-1_7_17-release:1.8
	cygwin-64bit-branch:1.8.0.2
	cygwin-1_7_16-release:1.8
	cygwin-1_7_15-release:1.8
	cygwin-1_7_14_2-release:1.8
	cygwin-1_7_14-release:1.8
	cygwin-1_7_12-release:1.8
	cygwin-1_7_11-release:1.8
	cygwin-1_7_10-release:1.8
	newlib-1_20_0:1.8
	cygwin-1_7_9-release:1.6
	cygwin-1_7_8-release:1.6
	newlib-1_19_0:1.5
	cygwin-1_7_7-release:1.5
	cygwin-1_7_5-release:1.5
	cygwin-1_7_4-release:1.5
	cygwin-1_7_3-release:1.5
	cygwin-1_7_2-release:1.5
	newlib-1_18_0:1.5
	cygwin-1_7_1-release:1.5
	newlib-1_17_0-arc:1.4.0.2
	binutils-arc-20080908-branch:1.3.0.8
	binutils-arc-20080908-branchpoint:1.3
	newlib-1_17_0:1.4
	newlib-1_16_0:1.3
	newlib-1_15_0:1.3
	newlib-csl-coldfire-4_1-32:1.3
	newlib-csl-sourcerygxx-4_1-32:1.3
	newlib-csl-innovasic-fido-3_4_4-33:1.3
	newlib-csl-coldfire-4_1-30:1.3
	newlib-csl-sourcerygxx-4_1-30:1.3
	newlib-csl-coldfire-4_1-28:1.3
	newlib-csl-sourcerygxx-4_1-28:1.3
	newlib-csl-arm-2006q3-27:1.3
	newlib-csl-sourcerygxx-4_1-27:1.3
	newlib-csl-arm-2006q3-26:1.3
	newlib-csl-sourcerygxx-4_1-26:1.3
	newlib-csl-sourcerygxx-4_1-24:1.3
	newlib-csl-sourcerygxx-4_1-23:1.3
	newlib-csl-sourcerygxx-4_1-21:1.3
	newlib-csl-arm-2006q3-21:1.3
	newlib-csl-arm-2006q3-19:1.3
	newlib-csl-sourcerygxx-4_1-19:1.3
	newlib-csl-sourcerygxx-4_1-18:1.3
	newlib-csl-sourcerygxx-3_4_4-25:1.3
	newlib-csl-sourcerygxx-4_1-17:1.3
	cr-0x5f1:1.3.0.6
	newlib-csl-sourcerygxx-4_1-14:1.3
	newlib-csl-sourcerygxx-4_1-13:1.3
	newlib-csl-sourcerygxx-4_1-12:1.3
	newlib-csl-sourcerygxx-4_1-9:1.3
	newlib-csl-sourcerygxx-4_1-8:1.3
	newlib-csl-sourcerygxx-4_1-7:1.3
	newlib-csl-arm-2006q1-6:1.3
	newlib-csl-sourcerygxx-4_1-6:1.3
	newlib-csl-sourcerygxx-4_1-5:1.3
	newlib-csl-sourcerygxx-4_1-4:1.3
	newlib-autotools-branch:1.3.0.4
	newlib-csl-20060320-branch:1.3.0.2
	newlib-csl-20060320-branchpoint:1.3
	newlib-1_14_0:1.3
	newlib-csl-arm-2005-q1b:1.3
	newlib-csl-arm-2005-q1a:1.3
	newlib-1_13_0:1.3
	csl-arm-2004-q3:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	newlib-1_12_0:1.3
	csl-arm-2003-q4:1.3
	w32api-2_2:1.3
	mingw-runtime-2_4:1.3
	newlib-1_11_0:1.3
	cygnus_cvs_20020108_pre:1.2
	newlib-1_10_0:1.2
	newlib-1_9_0:1.2
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.10
date	2014.07.30.08.02.12;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2014.07.14.13.40.17;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.25.21.05.11;	author ericb;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.25.18.41.10;	author ericb;	state Exp;
branches;
next	1.6;

1.6
date	2011.02.10.16.48.18;	author ericb;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.15.13.41.46;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.19.16.11.35;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.17.23.39.38;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.04.18.01.50;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.48;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.48;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.10
log
@	* libc/string/strerror.c: Fix documentation so makedoc doesn't
	stumble over a sole EAGAIN.
@
text
@/***
**** CAUTION!!! KEEP DOC CONSISTENT---if you change text of a message
****            here, change two places:
****            1) the leading doc section (alphabetized by macro)
****            2) the real text inside switch(errnum)
***/

/*
FUNCTION
	<<strerror>>---convert error number to string

INDEX
	strerror

ANSI_SYNOPSIS
	#include <string.h>
	char *strerror(int <[errnum]>);
	char *_strerror_r(struct _reent <[ptr]>, int <[errnum]>,
			  int <[internal]>, int *<[error]>);

TRAD_SYNOPSIS
	#include <string.h>
	char *strerror(<[errnum]>)
	int <[errnum]>;

DESCRIPTION
<<strerror>> converts the error number <[errnum]> into a
string.  The value of <[errnum]> is usually a copy of <<errno>>.
If <<errnum>> is not a known error number, the result points to an
empty string.

This implementation of <<strerror>> prints out the following strings
for each of the values defined in `<<errno.h>>':

o+
o 0
Success

o E2BIG
Arg list too long

o EACCES
Permission denied

o EADDRINUSE
Address already in use

o EADDRNOTAVAIL
Address not available

o EADV
Advertise error

o EAFNOSUPPORT
Address family not supported by protocol family

o EAGAIN
No more processes

o EALREADY
Socket already connected

o EBADF
Bad file number

o EBADMSG
Bad message

o EBUSY
Device or resource busy

o ECANCELED
Operation canceled

o ECHILD
No children

o ECOMM
Communication error

o ECONNABORTED
Software caused connection abort

o ECONNREFUSED
Connection refused

o ECONNRESET
Connection reset by peer

o EDEADLK
Deadlock

o EDESTADDRREQ
Destination address required

o EEXIST
File exists

o EDOM
Mathematics argument out of domain of function

o EFAULT
Bad address

o EFBIG
File too large

o EHOSTDOWN
Host is down

o EHOSTUNREACH
Host is unreachable

o EIDRM
Identifier removed

o EILSEQ
Illegal byte sequence

o EINPROGRESS
Connection already in progress

o EINTR
Interrupted system call

o EINVAL
Invalid argument

o EIO
I/O error

o EISCONN
Socket is already connected

o EISDIR
Is a directory

o ELIBACC
Cannot access a needed shared library

o ELIBBAD
Accessing a corrupted shared library

o ELIBEXEC
Cannot exec a shared library directly

o ELIBMAX
Attempting to link in more shared libraries than system limit

o ELIBSCN
<<.lib>> section in a.out corrupted

o EMFILE
File descriptor value too large

o EMLINK
Too many links

o EMSGSIZE
Message too long

o EMULTIHOP
Multihop attempted

o ENAMETOOLONG
File or path name too long

o ENETDOWN
Network interface is not configured

o ENETRESET
Connection aborted by network

o ENETUNREACH
Network is unreachable

o ENFILE
Too many open files in system

o ENOBUFS
No buffer space available

o ENODATA
No data

o ENODEV
No such device

o ENOENT
No such file or directory

o ENOEXEC
Exec format error

o ENOLCK
No lock

o ENOLINK
Virtual circuit is gone

o ENOMEM
Not enough space

o ENOMSG
No message of desired type

o ENONET
Machine is not on the network

o ENOPKG
No package

o ENOPROTOOPT
Protocol not available

o ENOSPC
No space left on device

o ENOSR
No stream resources

o ENOSTR
Not a stream

o ENOSYS
Function not implemented

o ENOTBLK
Block device required

o ENOTCONN
Socket is not connected

o ENOTDIR
Not a directory

o ENOTEMPTY
Directory not empty

o ENOTRECOVERABLE
State not recoverable

o ENOTSOCK
Socket operation on non-socket

o ENOTSUP
Not supported

o ENOTTY
Not a character device

o ENXIO
No such device or address

o EOPNOTSUPP
Operation not supported on socket

o EOVERFLOW
Value too large for defined data type

o EOWNERDEAD
Previous owner died

o EPERM
Not owner

o EPIPE
Broken pipe

o EPROTO
Protocol error

o EPROTOTYPE
Protocol wrong type for socket

o EPROTONOSUPPORT
Unknown protocol

o ERANGE
Result too large

o EREMOTE
Resource is remote

o EROFS
Read-only file system

o ESHUTDOWN
Can't send after socket shutdown

o ESOCKTNOSUPPORT
Socket type not supported

o ESPIPE
Illegal seek

o ESRCH
No such process

o ESRMNT
Srmount error

o ESTRPIPE
Strings pipe error

o ETIME
Stream ioctl timeout

o ETIMEDOUT
Connection timed out

o ETXTBSY
Text file busy

o EWOULDBLOCK
Operation would block (usually same as EAGAIN)

o EXDEV
Cross-device link

o-

<<_strerror_r>> is a reentrant version of the above.

RETURNS
This function returns a pointer to a string.  Your application must
not modify that string.

PORTABILITY
ANSI C requires <<strerror>>, but does not specify the strings used
for each error number.

Although this implementation of <<strerror>> is reentrant (depending
on <<_user_strerror>>), ANSI C declares that subsequent calls to
<<strerror>> may overwrite the result string; therefore portable
code cannot depend on the reentrancy of this subroutine.

Although this implementation of <<strerror>> guarantees a non-null
result with a NUL-terminator, some implementations return <<NULL>>
on failure.  Although POSIX allows <<strerror>> to set <<errno>>
to EINVAL on failure, this implementation does not do so (unless
you provide <<_user_strerror>>).

POSIX recommends that unknown <[errnum]> result in a message
including that value, however it is not a requirement and this
implementation does not provide that information (unless you
provide <<_user_strerror>>).

This implementation of <<strerror>> provides for user-defined
extensibility.  <<errno.h>> defines <[__ELASTERROR]>, which can be
used as a base for user-defined error values.  If the user supplies a
routine named <<_user_strerror>>, and <[errnum]> passed to
<<strerror>> does not match any of the supported values,
<<_user_strerror>> is called with three arguments.  The first is of
type <[int]>, and is the <[errnum]> value unknown to <<strerror>>.
The second is of type <[int]>, and matches the <[internal]> argument
of <<_strerror_r>>; this should be zero if called from <<strerror>>
and non-zero if called from any other function; <<_user_strerror>> can
use this information to satisfy the POSIX rule that no other
standardized function can overwrite a static buffer reused by
<<strerror>>.  The third is of type <[int *]>, and matches the
<[error]> argument of <<_strerror_r>>; if a non-zero value is stored
into that location (usually <[EINVAL]>), then <<strerror>> will set
<<errno>> to that value, and the XPG variant of <<strerror_r>> will
return that value instead of zero or <[ERANGE]>.  <<_user_strerror>>
returns a <[char *]> value; returning <[NULL]> implies that the user
function did not choose to handle <[errnum]>.  The default
<<_user_strerror>> returns <[NULL]> for all input values.  Note that
<<_user_sterror>> must be thread-safe, and only denote errors via the
third argument rather than modifying <<errno>>, if <<strerror>> and
<<strerror_r>> are are to comply with POSIX.

<<strerror>> requires no supporting OS subroutines.

QUICKREF
	strerror ansi pure
*/

#include <errno.h>
#include <string.h>

char *
_DEFUN (_strerror_r, (ptr, errnum, internal, errptr),
	struct _reent *ptr _AND
	int errnum _AND
	int internal _AND
	int *errptr)
{
  char *error;
  extern char *_user_strerror _PARAMS ((int, int, int *));

  switch (errnum)
    {
    case 0:
      error = "Success";
      break;
/* go32 defines EPERM as EACCES */
#if defined (EPERM) && (!defined (EACCES) || (EPERM != EACCES))
    case EPERM:
      error = "Not owner";
      break;
#endif
#ifdef ENOENT
    case ENOENT:
      error = "No such file or directory";
      break;
#endif
#ifdef ESRCH
    case ESRCH:
      error = "No such process";
      break;
#endif
#ifdef EINTR
    case EINTR:
      error = "Interrupted system call";
      break;
#endif
#ifdef EIO
    case EIO:
      error = "I/O error";
      break;
#endif
/* go32 defines ENXIO as ENODEV */
#if defined (ENXIO) && (!defined (ENODEV) || (ENXIO != ENODEV))
    case ENXIO:
      error = "No such device or address";
      break;
#endif
#ifdef E2BIG
    case E2BIG:
      error = "Arg list too long";
      break;
#endif
#ifdef ENOEXEC
    case ENOEXEC:
      error = "Exec format error";
      break;
#endif
#ifdef EALREADY
    case EALREADY:
      error = "Socket already connected";
      break;
#endif
#ifdef EBADF
    case EBADF:
      error = "Bad file number";
      break;
#endif
#ifdef ECHILD
    case ECHILD:
      error = "No children";
      break;
#endif
#ifdef EDESTADDRREQ
    case EDESTADDRREQ:
      error = "Destination address required";
      break;
#endif
#ifdef EAGAIN
    case EAGAIN:
      error = "No more processes";
      break;
#endif
#ifdef ENOMEM
    case ENOMEM:
      error = "Not enough space";
      break;
#endif
#ifdef EACCES
    case EACCES:
      error = "Permission denied";
      break;
#endif
#ifdef EFAULT
    case EFAULT:
      error = "Bad address";
      break;
#endif
#ifdef ENOTBLK
    case ENOTBLK:
      error = "Block device required";
      break;
#endif
#ifdef EBUSY
    case EBUSY:
      error = "Device or resource busy";
      break;
#endif
#ifdef EEXIST
    case EEXIST:
      error = "File exists";
      break;
#endif
#ifdef EXDEV
    case EXDEV:
      error = "Cross-device link";
      break;
#endif
#ifdef ENODEV
    case ENODEV:
      error = "No such device";
      break;
#endif
#ifdef ENOTDIR
    case ENOTDIR:
      error = "Not a directory";
      break;
#endif
#ifdef EHOSTDOWN
    case EHOSTDOWN:
      error = "Host is down";
      break;
#endif
#ifdef EINPROGRESS
    case EINPROGRESS:
      error = "Connection already in progress";
      break;
#endif
#ifdef EISDIR
    case EISDIR:
      error = "Is a directory";
      break;
#endif
#ifdef EINVAL
    case EINVAL:
      error = "Invalid argument";
      break;
#endif
#ifdef ENETDOWN
    case ENETDOWN:
      error = "Network interface is not configured";
      break;
#endif
#ifdef ENETRESET
    case ENETRESET:
      error = "Connection aborted by network";
      break;
#endif
#ifdef ENFILE
    case ENFILE:
      error = "Too many open files in system";
      break;
#endif
#ifdef EMFILE
    case EMFILE:
      error = "File descriptor value too large";
      break;
#endif
#ifdef ENOTTY
    case ENOTTY:
      error = "Not a character device";
      break;
#endif
#ifdef ETXTBSY
    case ETXTBSY:
      error = "Text file busy";
      break;
#endif
#ifdef EFBIG
    case EFBIG:
      error = "File too large";
      break;
#endif
#ifdef EHOSTUNREACH
    case EHOSTUNREACH:
      error = "Host is unreachable";
      break;
#endif
#ifdef ENOSPC
    case ENOSPC:
      error = "No space left on device";
      break;
#endif
#ifdef ENOTSUP
    case ENOTSUP:
      error = "Not supported";
      break;
#endif
#ifdef ESPIPE
    case ESPIPE:
      error = "Illegal seek";
      break;
#endif
#ifdef EROFS
    case EROFS:
      error = "Read-only file system";
      break;
#endif
#ifdef EMLINK
    case EMLINK:
      error = "Too many links";
      break;
#endif
#ifdef EPIPE
    case EPIPE:
      error = "Broken pipe";
      break;
#endif
#ifdef EDOM
    case EDOM:
      error = "Mathematics argument out of domain of function";
      break;
#endif
#ifdef ERANGE
    case ERANGE:
      error = "Result too large";
      break;
#endif
#ifdef ENOMSG
    case ENOMSG:
      error = "No message of desired type";
      break;
#endif
#ifdef EIDRM
    case EIDRM:
      error = "Identifier removed";
      break;
#endif
#ifdef EILSEQ
    case EILSEQ:
      error = "Illegal byte sequence";
      break;
#endif
#ifdef EDEADLK
    case EDEADLK:
      error = "Deadlock";
      break;
#endif
#ifdef ENETUNREACH
    case  ENETUNREACH:
      error = "Network is unreachable";
      break;
#endif
#ifdef ENOLCK
    case ENOLCK:
      error = "No lock";
      break;
#endif
#ifdef ENOSTR
    case ENOSTR:
      error = "Not a stream";
      break;
#endif
#ifdef ETIME
    case ETIME:
      error = "Stream ioctl timeout";
      break;
#endif
#ifdef ENOSR
    case ENOSR:
      error = "No stream resources";
      break;
#endif
#ifdef ENONET
    case ENONET:
      error = "Machine is not on the network";
      break;
#endif
#ifdef ENOPKG
    case ENOPKG:
      error = "No package";
      break;
#endif
#ifdef EREMOTE
    case EREMOTE:
      error = "Resource is remote";
      break;
#endif
#ifdef ENOLINK
    case ENOLINK:
      error = "Virtual circuit is gone";
      break;
#endif
#ifdef EADV
    case EADV:
      error = "Advertise error";
      break;
#endif
#ifdef ESRMNT
    case ESRMNT:
      error = "Srmount error";
      break;
#endif
#ifdef ECOMM
    case ECOMM:
      error = "Communication error";
      break;
#endif
#ifdef EPROTO
    case EPROTO:
      error = "Protocol error";
      break;
#endif
#ifdef EPROTONOSUPPORT
    case EPROTONOSUPPORT:
      error = "Unknown protocol";
      break;
#endif
#ifdef EMULTIHOP
    case EMULTIHOP:
      error = "Multihop attempted";
      break;
#endif
#ifdef EBADMSG
    case EBADMSG:
      error = "Bad message";
      break;
#endif
#ifdef ELIBACC
    case ELIBACC:
      error = "Cannot access a needed shared library";
      break;
#endif
#ifdef ELIBBAD
    case ELIBBAD:
      error = "Accessing a corrupted shared library";
      break;
#endif
#ifdef ELIBSCN
    case ELIBSCN:
      error = ".lib section in a.out corrupted";
      break;
#endif
#ifdef ELIBMAX
    case ELIBMAX:
      error = "Attempting to link in more shared libraries than system limit";
      break;
#endif
#ifdef ELIBEXEC
    case ELIBEXEC:
      error = "Cannot exec a shared library directly";
      break;
#endif
#ifdef ENOSYS
    case ENOSYS:
      error = "Function not implemented";
      break;
#endif
#ifdef ENMFILE
    case ENMFILE:
      error = "No more files";
      break;
#endif
#ifdef ENOTEMPTY
    case ENOTEMPTY:
      error = "Directory not empty";
      break;
#endif
#ifdef ENAMETOOLONG
    case ENAMETOOLONG:
      error = "File or path name too long";
      break;
#endif
#ifdef ELOOP
    case ELOOP:
      error = "Too many symbolic links";
      break;
#endif
#ifdef ENOBUFS
    case ENOBUFS:
      error = "No buffer space available";
      break;
#endif
#ifdef ENODATA
    case ENODATA:
      error = "No data";
      break;
#endif
#ifdef EAFNOSUPPORT
    case EAFNOSUPPORT:
      error = "Address family not supported by protocol family";
      break;
#endif
#ifdef EPROTOTYPE
    case EPROTOTYPE:
      error = "Protocol wrong type for socket";
      break;
#endif
#ifdef ENOTSOCK
    case ENOTSOCK:
      error = "Socket operation on non-socket";
      break;
#endif
#ifdef ENOPROTOOPT
    case ENOPROTOOPT:
      error = "Protocol not available";
      break;
#endif
#ifdef ESHUTDOWN
    case ESHUTDOWN:
      error = "Can't send after socket shutdown";
      break;
#endif
#ifdef ECONNREFUSED
    case ECONNREFUSED:
      error = "Connection refused";
      break;
#endif
#ifdef ECONNRESET
    case ECONNRESET:
      error = "Connection reset by peer";
      break;
#endif
#ifdef EADDRINUSE
    case EADDRINUSE:
      error = "Address already in use";
      break;
#endif
#ifdef EADDRNOTAVAIL
    case EADDRNOTAVAIL:
      error = "Address not available";
      break;
#endif
#ifdef ECONNABORTED
    case ECONNABORTED:
      error = "Software caused connection abort";
      break;
#endif
#if (defined(EWOULDBLOCK) && (!defined (EAGAIN) || (EWOULDBLOCK != EAGAIN)))
    case EWOULDBLOCK:
        error = "Operation would block";
        break;
#endif
#ifdef ENOTCONN
    case ENOTCONN:
        error = "Socket is not connected";
        break;
#endif
#ifdef ESOCKTNOSUPPORT
    case ESOCKTNOSUPPORT:
        error = "Socket type not supported";
        break;
#endif
#ifdef EISCONN
    case EISCONN:
        error = "Socket is already connected";
        break;
#endif
#ifdef ECANCELED
    case ECANCELED:
        error = "Operation canceled";
        break;
#endif
#ifdef ENOTRECOVERABLE
    case ENOTRECOVERABLE:
        error = "State not recoverable";
        break;
#endif
#ifdef EOWNERDEAD
    case EOWNERDEAD:
        error = "Previous owner died";
        break;
#endif
#ifdef ESTRPIPE
    case ESTRPIPE:
	error = "Streams pipe error";
	break;
#endif
#if defined(EOPNOTSUPP) && (!defined(ENOTSUP) || (ENOTSUP != EOPNOTSUPP))
    case EOPNOTSUPP:
        error = "Operation not supported on socket";
        break;
#endif
#ifdef EOVERFLOW
    case EOVERFLOW:
      error = "Value too large for defined data type";
      break;
#endif
#ifdef EMSGSIZE
    case EMSGSIZE:
        error = "Message too long";
        break;
#endif
#ifdef ETIMEDOUT
    case ETIMEDOUT:
        error = "Connection timed out";
        break;
#endif
    default:
      if (!errptr)
        errptr = &ptr->_errno;
      if ((error = _user_strerror (errnum, internal, errptr)) == 0)
        error = "";
      break;
    }

  return error;
}

char *
_DEFUN(strerror, (int),
       int errnum)
{
  return _strerror_r (_REENT, errnum, 0, NULL);
}
@


1.9
log
@	* libc/include/sys/errno.h: Fix comments.
	* libc/string/strerror.c: Fix documentation.
	(_strerror_r): Handle ENETRESET, EILSEQ, ENODATA, ECONNRESET,
	EADDRNOTAVAIL, EOVERFLOW.  Fix strings for EMFILE and EDOM.
@
text
@d316 1
a316 1
EAGAIN
@


1.8
log
@* libc/string/strerror.c (_strerror_r): Report "Success" for 0.
@
text
@d48 3
d72 3
d87 3
d100 1
a100 1
Math argument
d117 3
d154 1
a154 1
Too many open files
d169 4
a172 1
Network interface not configured
d180 6
d240 3
d255 9
d303 3
d315 3
a320 12
o ECANCELED
Operation canceled

o ENOTRECOVERABLE
State not recoverable

o EOWNERDEAD
Previous owner died

o ESTRPIPE
Strings pipe error

d534 5
d546 1
a546 1
      error = "Too many open files";
d601 1
a601 1
      error = "Math argument";
d619 5
d764 5
d799 5
d809 5
d864 5
@


1.7
log
@strerror: allow user hook to comply with POSIX rules

* libc/string/strerror.c (strerror): Split body into...
(_strerror_r): ...new reentrant function.
* libc/string/u_strerr.c (_user_strerror): Update signature.
* libc/include/stdio.h (_strerror_r): New prototype.
* libc/posix/collate.c (__collate_err): Adjust callers.
* libc/stdio/perror.c (_perror_r): Likewise.
* libc/string/strerror_r.c (strerror_r): Likewise.
* libc/string/xpg_strerror_r.c (__xpg_strerror_r): Likewise.
@
text
@d36 3
d367 3
@


1.6
log
@strerror_r: provide POSIX implementation

* libc/include/string.h (strerror_r): Update declaration.
* libc/string/strerror.c (strerror): Update documentation.
* libc/string/strerror_r.c (strerror_r): Always return
NUL-terminated string; don't overwrite too-short buf.
* libc/string/xpg_strerror_r.c (__xpg_strerror_r): Implement POSIX
variant.
* libc/string/Makefile.am (GENERAL_SOURCES): Build new file.
* libc/string/Makefile.in: Regenerate.
@
text
@d18 2
d293 2
d303 4
a306 4
Although this implementation of <<strerror>> is reentrant, ANSI C
declares that subsequent calls to <<strerror>> may overwrite the
result string; therefore portable code cannot depend on the reentrancy
of this subroutine.
d324 18
a341 9
<<_user_strerror>> is called with <[errnum]> as its argument.

<<_user_strerror>> takes one argument of type <[int]>, and returns a
character pointer.  If <[errnum]> is unknown to <<_user_strerror>>,
<<_user_strerror>> returns <[NULL]>.  The default <<_user_strerror>>
returns <[NULL]> for all input values.

Note that <<_user_sterror>> must be thread-safe and not alter <<errno>>
if <<strerror_r>> is to comply with POSIX.
d353 5
a357 2
_DEFUN (strerror, (errnum),
	int errnum)
d360 1
a360 1
  extern char *_user_strerror _PARAMS ((int));
d817 4
a820 2
      if ((error = _user_strerror (errnum)) == 0)
	error = "";
d826 7
@


1.5
log
@	* libc/include/sys/errno.h (ESTRPIPE): Define.
	* libc/string/strerror.c (strerror): Decode it.
@
text
@d304 11
d327 3
@


1.4
log
@
2008-09-19  Eric Blake  <ebb9@@byu.net>

        Supply missing POSIX errno values.
        * libc/include/sys/errno.h (ENOTRECOVERABLE, EOWNERDEAD): Define.
        * libc/string/strerror.c (strerror): Decode them, and ECANCELED.
@
text
@d286 3
d766 5
@


1.3
log
@
2002-05-17  Jeff Johnston  <jjohnstn@@redhat.com>

	* Makefile.am: Copy and install headers from sys/machine/include
	directory.  Also pass $toollibdir to lower-level directories.
	* Makefile.in: Regenerated.
	* libc/include/stdio.h[!_REENT_ONLY]: Change stdin, stdout, and
	stderr to use _REENT macro instead of _impure_ptr directly.
	* libc/include/sys/config.h[__i386__][__linux__]: Define
	__DYNAMIC_REENT__.
	* libc/include/sys/reent.h[!_REENT_ONLY]: Change _REENT macro to be
	call to __getreent() function if !__SINGLE_THREAD__ and
	__DYNAMIC_REENT__ is set.
	* libc/reent/Makefile.am: Add support for getreent.c.
	* libc/reent/Makefile.in: Regenerated.
	* libc/string/strerror.c: Add check if EOPNOTSUPP and ENOTSUP are same.
	* libc/sys/linux/Makefile.am: Add support for new files.
	* libc/sys/linux/configure.in: Add $EXTRA_DIRS variable.
	* libc/sys/linux/Makefile.in: Regenerated.
	* libc/sys/linux/configure: Ditto.
	* libc/sys/linux/io.c: Add poll syscall.  Also weak-alias
	__close, __read, __write, __poll, __open, __lseek, __fcntl from
	their __libc_ counterparts.
	* libc/sys/linux/io64.c: Add __libc_ prefix to lseek64 and open64
	and weak-alias to regular names.
	* libc/sys/linux/pread64.c: Rename to __libc_pread64 and weak-alias
	to pread64 and __pread64.
	* libc/sys/linux/process.c: Weak_alias __libc_getpid to __getpid.
	* libc/sys/linux/pwrite64.c: Rename to __libc_pwrite64 and
	weak-alias to pwrite64.
	* libc/sys/linux/sched.c: Weak-alias __libc_sched_getparam,
	__libc_sched_getscheduler, __libc_sched_get_priority_max,
	__libc_sched_get_priority_min, and __libc_sched_setschedule to
	name with __ instead of __libc_.
	* libc/sys/linux/siglongjmp.c: Include <machine/weakalias.h>.
	Rename siglongjmp to __libc_siglongjmp and weak-alias to siglongjmp.
	Call __libc_longjmp instead of longjmp, from __libc_siglongjmp.
	* libc/sys/linux/signal.c: Rename raise to __libc_raise and weak-alias
	to raise.
	* libc/sys/linux/socket.c: Weak-alias __libc_connect to __connect and
	__libc_send to __send.
	* libc/sys/linux/time.c: Weak-alias __libc_gettimeofday to
	__gettimeofday.
	* libc/sys/linux/wait.c: Rename wait to __libc_wait and weak-alias
	it to wait.  Rename wait3 to __libc_wait3 and weak-alias it to wait3.
	* libc/sys/linux/include/setjmp.h: Use __jmp_buf in sigjmp_buf
	type and typedef __jmp_buf to jmp_buf.
	* libc/sys/linux/machine/i386/Makefile.am: Add syscalls.c and
	setjmp.S.
	* libc/sys/linux/machine/i386/Makefile.in: Regenerated.
	* libc/sys/linux/machine/i386/crt0.c: Add support to clear .bss
	section.
	* libc/sys/linux/machine/i386/socketcall.h: Change to use __libc_
	prefix for function macros and then use weak_alias() to regular names.
	* libc/sys/linux/machine/i386/syscall.h: Ditto.
	* libc/sys/linux/sys/errno.h: Define EOPNOTSUP to be ENOTSUP.
	* libc/sys/linux/sys/stdio.h: Define _flockfile and _funlockfile
	to be flockfile() and funlockfile() respectively.
	* libc/sys/linux/sys/types.h
	* libc/reent/getreent.c: New file.
	* libc/sys/linux/flockfile.c: Ditto.
	* libc/sys/linux/funlockfile.c: Ditto.
	* libc/sys/linux/getreent.c: Ditto.
	* libc/sys/linux/pread.c: Ditto.
	* libc/sys/linux/pwrite.c: Ditto.
	* libc/sys/linux/raise.c: Ditto.
	* libc/sys/linux/system.c: Ditto.
	* libc/sys/linux/tcdrain.c: Ditto.
	* libc/sys/linux/machine/i386/i386mach.h: Ditto.
	* libc/sys/linux/machine/i386/setjmp.S: Ditto.
	* libc/sys/linux/machine/i386/syscalls.c: Ditto.
	* libc/sys/linux/machine/i386/weakalias.h: Ditto.
	* libc/sys/linux/machine/i386/include/setjmp.h: Ditto.
@
text
@d277 9
d448 1
a448 1
#ifdef EINPROGRESS 
d553 1
a553 1
#ifdef ENETUNREACH 
d748 15
@


1.2
log
@
2000-12-04 Keith Outwater <vac4050@@cae597.rsc.raytheon.com>

        * libc/include/sys/errno.h: Added comments on many error numbers.
        * libc/string/strerror.c: Added some more strings.
@
text
@d739 1
a739 1
#ifdef EOPNOTSUPP
@


1.1
log
@Initial revision
@
text
@d40 3
d46 3
d52 3
d70 6
d79 3
d94 6
d103 3
d115 3
d142 3
d151 6
d187 3
d205 3
d214 6
d235 6
d250 6
d268 3
d364 5
d379 5
d434 10
d454 5
d484 5
d494 5
d544 5
d607 5
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
