head	1.51;
access;
symbols
	cygwin-1_7_35-release:1.51
	cygwin-1_7_34-release:1.51
	newlib-2_2_0:1.51.0.6
	cygwin-1_7_33-release:1.51
	cygwin-1_7_32-release:1.51
	cygwin-1_7_31-release:1.51
	cygwin-1_7_30-release:1.51
	cygwin-1_7_29-release:1.51
	cygwin-1_7_28-release:1.51
	newlib-2_1_0:1.51
	cygwin-1_7_27-release:1.51
	cygwin-1_7_26-release:1.51
	cygwin-1_7_25-release:1.51
	cygwin-1_7_24-release:1.51
	cygwin-1_7_23-release:1.51
	cygwin-1_7_22-release:1.51
	cygwin-1_7_21-release:1.51
	cygwin-1_7_20-release:1.51
	cygwin-1_7_19-release:1.51
	cygwin-64bit-postmerge:1.51
	cygwin-64bit-premerge-branch:1.51.0.4
	cygwin-64bit-premerge:1.51
	cygwin-1_7_18-release:1.51
	newlib-2_0_0:1.51
	cygwin-1_7_17-release:1.51
	cygwin-64bit-branch:1.51.0.2
	cygwin-1_7_16-release:1.51
	cygwin-1_7_15-release:1.51
	cygwin-1_7_14_2-release:1.51
	cygwin-1_7_14-release:1.51
	cygwin-1_7_12-release:1.51
	cygwin-1_7_11-release:1.50
	cygwin-1_7_10-release:1.50
	newlib-1_20_0:1.50
	cygwin-1_7_9-release:1.48
	cygwin-1_7_8-release:1.48
	newlib-1_19_0:1.48
	cygwin-1_7_7-release:1.46
	cygwin-1_7_5-release:1.43
	cygwin-1_7_4-release:1.43
	cygwin-1_7_3-release:1.43
	cygwin-1_7_2-release:1.42
	newlib-1_18_0:1.29
	cygwin-1_7_1-release:1.29
	newlib-1_17_0-arc:1.8.0.10
	binutils-arc-20080908-branch:1.8.0.8
	binutils-arc-20080908-branchpoint:1.8
	newlib-1_17_0:1.8
	newlib-1_16_0:1.8
	newlib-1_15_0:1.8
	newlib-csl-coldfire-4_1-32:1.8
	newlib-csl-sourcerygxx-4_1-32:1.8
	newlib-csl-innovasic-fido-3_4_4-33:1.8
	newlib-csl-coldfire-4_1-30:1.8
	newlib-csl-sourcerygxx-4_1-30:1.8
	newlib-csl-coldfire-4_1-28:1.8
	newlib-csl-sourcerygxx-4_1-28:1.8
	newlib-csl-arm-2006q3-27:1.8
	newlib-csl-sourcerygxx-4_1-27:1.8
	newlib-csl-arm-2006q3-26:1.8
	newlib-csl-sourcerygxx-4_1-26:1.8
	newlib-csl-sourcerygxx-4_1-24:1.8
	newlib-csl-sourcerygxx-4_1-23:1.8
	newlib-csl-sourcerygxx-4_1-21:1.8
	newlib-csl-arm-2006q3-21:1.8
	newlib-csl-arm-2006q3-19:1.8
	newlib-csl-sourcerygxx-4_1-19:1.8
	newlib-csl-sourcerygxx-4_1-18:1.8
	newlib-csl-sourcerygxx-3_4_4-25:1.8
	newlib-csl-sourcerygxx-4_1-17:1.8
	cr-0x5f1:1.8.0.6
	newlib-csl-sourcerygxx-4_1-14:1.8
	newlib-csl-sourcerygxx-4_1-13:1.8
	newlib-csl-sourcerygxx-4_1-12:1.8
	newlib-csl-sourcerygxx-4_1-9:1.8
	newlib-csl-sourcerygxx-4_1-8:1.8
	newlib-csl-sourcerygxx-4_1-7:1.8
	newlib-csl-arm-2006q1-6:1.8
	newlib-csl-sourcerygxx-4_1-6:1.8
	newlib-csl-sourcerygxx-4_1-5:1.8
	newlib-csl-sourcerygxx-4_1-4:1.8
	newlib-autotools-branch:1.8.0.4
	newlib-csl-20060320-branch:1.8.0.2
	newlib-csl-20060320-branchpoint:1.8
	newlib-1_14_0:1.8
	newlib-csl-arm-2005-q1b:1.8
	newlib-csl-arm-2005-q1a:1.8
	newlib-1_13_0:1.8
	csl-arm-2004-q3:1.8
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.7
	newlib-1_12_0:1.7
	csl-arm-2003-q4:1.7
	w32api-2_2:1.6
	mingw-runtime-2_4:1.6
	newlib-1_11_0:1.6
	cygnus_cvs_20020108_pre:1.2
	newlib-1_10_0:1.2
	newlib-1_9_0:1.2
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.51
date	2012.03.29.20.27.15;	author corinna;	state Exp;
branches;
next	1.50;

1.50
date	2011.05.04.08.54.34;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2011.05.04.08.45.17;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2010.11.19.10.02.36;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2010.11.18.11.02.53;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.11.20.40.14;	author jjohnstn;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.28.09.59.37;	author corinna;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.22.23.32.41;	author dj;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.27.21.04.49;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2010.02.25.16.16.16;	author corinna;	state Exp;
branches;
next	1.41;

1.41
date	2010.02.25.16.10.42;	author corinna;	state Exp;
branches;
next	1.40;

1.40
date	2010.02.09.08.58.38;	author corinna;	state Exp;
branches;
next	1.39;

1.39
date	2010.02.07.13.52.34;	author corinna;	state Exp;
branches;
next	1.38;

1.38
date	2010.02.07.12.57.48;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2010.02.06.18.28.33;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2010.02.05.21.24.42;	author corinna;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.23.16.41.08;	author corinna;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.23.14.32.25;	author corinna;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.22.13.03.42;	author corinna;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.17.14.57.32;	author corinna;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.17.14.41.58;	author corinna;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.17.09.39.06;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.09.08.25.28;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.29.19.12.28;	author corinna;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.27.12.21.16;	author corinna;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.23.17.19.00;	author corinna;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.25.18.47.24;	author jjohnstn;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.24.22.11.10;	author jjohnstn;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.21.20.56.13;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.18.09.13.39;	author corinna;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.16.19.45.17;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.03.19.28.22;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.13.14.54.11;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2009.04.06.10.36.49;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.31.09.31.38;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.26.10.24.38;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.25.13.52.08;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.25.09.00.03;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.24.18.18.14;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.24.16.56.33;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.24.10.13.27;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.23.11.28.12;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.03.09.28.45;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.23.21.44.21;	author jjohnstn;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.20.18.46.36;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.20.20.13.10;	author jjohnstn;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.29.15.32.08;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.17.05.19.17;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.24.20.49.59;	author fitzsim;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.24.16.25.35;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.46;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.46;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.51
log
@	* libc/locale/locale.c (__mb_cur_max): On Cygwin, align default value
	with default UTF-8 charset.
@
text
@/*
FUNCTION
<<setlocale>>, <<localeconv>>---select or query locale

INDEX
	setlocale
INDEX
	localeconv
INDEX
	_setlocale_r
INDEX
	_localeconv_r

ANSI_SYNOPSIS
	#include <locale.h>
	char *setlocale(int <[category]>, const char *<[locale]>);
	lconv *localeconv(void);

	char *_setlocale_r(void *<[reent]>,
                        int <[category]>, const char *<[locale]>);
	lconv *_localeconv_r(void *<[reent]>);

TRAD_SYNOPSIS
	#include <locale.h>
	char *setlocale(<[category]>, <[locale]>)
	int <[category]>;
	char *<[locale]>;

	lconv *localeconv();

	char *_setlocale_r(<[reent]>, <[category]>, <[locale]>)
	char *<[reent]>;
	int <[category]>;
	char *<[locale]>;

	lconv *_localeconv_r(<[reent]>);
	char *<[reent]>;

DESCRIPTION
<<setlocale>> is the facility defined by ANSI C to condition the
execution environment for international collating and formatting
information; <<localeconv>> reports on the settings of the current
locale.

This is a minimal implementation, supporting only the required <<"POSIX">>
and <<"C">> values for <[locale]>; strings representing other locales are not
honored unless _MB_CAPABLE is defined.

If _MB_CAPABLE is defined, POSIX locale strings are allowed, following
the form

  language[_TERRITORY][.charset][@@@@modifier]

<<"language">> is a two character string per ISO 639, or, if not available
for a given language, a three character string per ISO 639-3.
<<"TERRITORY">> is a country code per ISO 3166.  For <<"charset">> and
<<"modifier">> see below.

Additionally to the POSIX specifier, the following extension is supported
for backward compatibility with older implementations using newlib:
<<"C-charset">>.
Instead of <<"C-">>, you can also specify <<"C.">>.  Both variations allow
to specify language neutral locales while using other charsets than ASCII,
for instance <<"C.UTF-8">>, which keeps all settings as in the C locale,
but uses the UTF-8 charset.

The following charsets are recognized:
<<"UTF-8">>, <<"JIS">>, <<"EUCJP">>, <<"SJIS">>, <<"KOI8-R">>, <<"KOI8-U">>,
<<"GEORGIAN-PS">>, <<"PT154">>, <<"TIS-620">>, <<"ISO-8859-x">> with
1 <= x <= 16, or <<"CPxxx">> with xxx in [437, 720, 737, 775, 850, 852, 855,
857, 858, 862, 866, 874, 932, 1125, 1250, 1251, 1252, 1253, 1254, 1255, 1256,
1257, 1258].

Charsets are case insensitive.  For instance, <<"EUCJP">> and <<"eucJP">>
are equivalent.  Charset names with dashes can also be written without
dashes, as in <<"UTF8">>, <<"iso88591">> or <<"koi8r">>.  <<"EUCJP">> and
<<"EUCKR">> are also recognized with dash, <<"EUC-JP">> and <<"EUC-KR">>.

Full support for all of the above charsets requires that newlib has been
build with multibyte support and support for all ISO and Windows Codepage.
Otherwise all singlebyte charsets are simply mapped to ASCII.  Right now,
only newlib for Cygwin is built with full charset support by default.
Under Cygwin, this implementation additionally supports the charsets
<<"GBK">>, <<"GB2312">>, <<"eucCN">>, <<"eucKR">>, and <<"Big5">>.  Cygwin
does not support <<"JIS">>.

Cygwin additionally supports locales from the file
/usr/share/locale/locale.alias.

(<<"">> is also accepted; if given, the settings are read from the
corresponding LC_* environment variables and $LANG according to POSIX rules.

This implementation also supports the modifier <<"cjknarrow">>, which
affects how the functions <<wcwidth>> and <<wcswidth>> handle characters
from the "CJK Ambiguous Width" category of characters described at
http://www.unicode.org/reports/tr11/#Ambiguous. These characters have a width
of 1 for singlebyte charsets and a width of 2 for multibyte charsets
other than UTF-8. For UTF-8, their width depends on the language specifier:
it is 2 for <<"zh">> (Chinese), <<"ja">> (Japanese), and <<"ko">> (Korean),
and 1 for everything else. Specifying <<"cjknarrow">> forces a width of 1,
independent of charset and language.

If you use <<NULL>> as the <[locale]> argument, <<setlocale>> returns a
pointer to the string representing the current locale.  The acceptable
values for <[category]> are defined in `<<locale.h>>' as macros
beginning with <<"LC_">>.

<<localeconv>> returns a pointer to a structure (also defined in
`<<locale.h>>') describing the locale-specific conventions currently
in effect.  

<<_localeconv_r>> and <<_setlocale_r>> are reentrant versions of
<<localeconv>> and <<setlocale>> respectively.  The extra argument
<[reent]> is a pointer to a reentrancy structure.

RETURNS
A successful call to <<setlocale>> returns a pointer to a string
associated with the specified category for the new locale.  The string
returned by <<setlocale>> is such that a subsequent call using that
string will restore that category (or all categories in case of LC_ALL),
to that state.  The application shall not modify the string returned
which may be overwritten by a subsequent call to <<setlocale>>.
On error, <<setlocale>> returns <<NULL>>.

<<localeconv>> returns a pointer to a structure of type <<lconv>>,
which describes the formatting and collating conventions in effect (in
this implementation, always those of the C locale).

PORTABILITY
ANSI C requires <<setlocale>>, but the only locale required across all
implementations is the C locale.

NOTES
There is no ISO-8859-12 codepage.  It's also refused by this implementation.

No supporting OS subroutines are required.
*/

/* Parts of this code are originally taken from FreeBSD. */
/*
 * Copyright (c) 1996 - 2002 FreeBSD Project
 * Copyright (c) 1991, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <newlib.h>
#include <errno.h>
#include <locale.h>
#include <string.h>
#include <limits.h>
#include <reent.h>
#include <stdlib.h>
#include <wchar.h>
#include "lmessages.h"
#include "lmonetary.h"
#include "lnumeric.h"
#include "lctype.h"
#include "timelocal.h"
#include "../stdlib/local.h"

#define _LC_LAST      7
#define ENCODING_LEN 31

#ifdef __CYGWIN__ /* Cygwin starts with LC_CTYPE set to "C.UTF-8". */
int __EXPORT __mb_cur_max = 6;
#else
int __EXPORT __mb_cur_max = 1;
#endif

int __nlocale_changed = 0;
int __mlocale_changed = 0;
char *_PathLocale = NULL;

static
struct lconv lconv = 
{
  ".", "", "", "", "", "", "", "", "", "",
  CHAR_MAX, CHAR_MAX, CHAR_MAX, CHAR_MAX,
  CHAR_MAX, CHAR_MAX, CHAR_MAX, CHAR_MAX,
  CHAR_MAX, CHAR_MAX, CHAR_MAX, CHAR_MAX,
  CHAR_MAX, CHAR_MAX
};

#ifdef _MB_CAPABLE
/*
 * Category names for getenv()
 */
static char *categories[_LC_LAST] = {
  "LC_ALL",
  "LC_COLLATE",
  "LC_CTYPE",
  "LC_MONETARY",
  "LC_NUMERIC",
  "LC_TIME",
  "LC_MESSAGES",
};

/*
 * Default locale per POSIX.  Can be overridden on a per-target base.
 */
#ifndef DEFAULT_LOCALE
#define DEFAULT_LOCALE	"C"
#endif
/*
 * This variable can be changed by any outside mechanism.  This allows,
 * for instance, to load the default locale from a file.
 */
char __default_locale[ENCODING_LEN + 1] = DEFAULT_LOCALE;

/*
 * Current locales for each category
 */
static char current_categories[_LC_LAST][ENCODING_LEN + 1] = {
    "C",
    "C",
#ifdef __CYGWIN__ /* Cygwin starts with LC_CTYPE set to "C.UTF-8". */
    "C.UTF-8",
#else
    "C",
#endif
    "C",
    "C",
    "C",
    "C",
};

/*
 * The locales we are going to try and load
 */
static char new_categories[_LC_LAST][ENCODING_LEN + 1];
static char saved_categories[_LC_LAST][ENCODING_LEN + 1];

static char current_locale_string[_LC_LAST * (ENCODING_LEN + 1/*"/"*/ + 1)];
static char *currentlocale(void);
static char *loadlocale(struct _reent *, int);
static const char *__get_locale_env(struct _reent *, int);

#endif /* _MB_CAPABLE */

#ifdef __CYGWIN__
static char lc_ctype_charset[ENCODING_LEN + 1] = "UTF-8";
#else
static char lc_ctype_charset[ENCODING_LEN + 1] = "ASCII";
#endif
static char lc_message_charset[ENCODING_LEN + 1] = "ASCII";
static int lc_ctype_cjk_lang = 0;

char *
_DEFUN(_setlocale_r, (p, category, locale),
       struct _reent *p _AND
       int category _AND
       _CONST char *locale)
{
#ifndef _MB_CAPABLE
  if (locale)
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
	  && strcmp (locale, ""))
        return NULL;
    }
  return "C";
#else /* !_MB_CAPABLE */
  int i, j, len, saverr;
  const char *env, *r;

  if (category < LC_ALL || category >= _LC_LAST)
    {
      p->_errno = EINVAL;
      return NULL;
    }

  if (locale == NULL)
    return category != LC_ALL ? current_categories[category] : currentlocale();

  /*
   * Default to the current locale for everything.
   */
  for (i = 1; i < _LC_LAST; ++i)
    strcpy (new_categories[i], current_categories[i]);

  /*
   * Now go fill up new_categories from the locale argument
   */
  if (!*locale)
    {
      if (category == LC_ALL)
	{
	  for (i = 1; i < _LC_LAST; ++i)
	    {
	      env = __get_locale_env (p, i);
	      if (strlen (env) > ENCODING_LEN)
		{
		  p->_errno = EINVAL;
		  return NULL;
		}
	      strcpy (new_categories[i], env);
	    }
	}
      else
	{
	  env = __get_locale_env (p, category);
	  if (strlen (env) > ENCODING_LEN)
	    {
	      p->_errno = EINVAL;
	      return NULL;
	    }
	  strcpy (new_categories[category], env);
	}
    }
  else if (category != LC_ALL)
    {
      if (strlen (locale) > ENCODING_LEN)
	{
	  p->_errno = EINVAL;
	  return NULL;
	}
      strcpy (new_categories[category], locale);
    }
  else
    {
      if ((r = strchr (locale, '/')) == NULL)
	{
	  if (strlen (locale) > ENCODING_LEN)
	    {
	      p->_errno = EINVAL;
	      return NULL;
	    }
	  for (i = 1; i < _LC_LAST; ++i)
	    strcpy (new_categories[i], locale);
	}
      else
	{
	  for (i = 1; r[1] == '/'; ++r)
	    ;
	  if (!r[1])
	    {
	      p->_errno = EINVAL;
	      return NULL;  /* Hmm, just slashes... */
	    }
	  do
	    {
	      if (i == _LC_LAST)
		break;  /* Too many slashes... */
	      if ((len = r - locale) > ENCODING_LEN)
		{
		  p->_errno = EINVAL;
		  return NULL;
		}
	      strlcpy (new_categories[i], locale, len + 1);
	      i++;
	      while (*r == '/')
		r++;
	      locale = r;
	      while (*r && *r != '/')
		r++;
	    }
	  while (*locale);
	  while (i < _LC_LAST)
	    {
	      strcpy (new_categories[i], new_categories[i-1]);
	      i++;
	    }
	}
    }

  if (category != LC_ALL)
    return loadlocale (p, category);

  for (i = 1; i < _LC_LAST; ++i)
    {
      strcpy (saved_categories[i], current_categories[i]);
      if (loadlocale (p, i) == NULL)
	{
	  saverr = p->_errno;
	  for (j = 1; j < i; j++)
	    {
	      strcpy (new_categories[j], saved_categories[j]);
	      if (loadlocale (p, j) == NULL)
		{
		  strcpy (new_categories[j], "C");
		  loadlocale (p, j);
		}
	    }
	  p->_errno = saverr;
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* !_MB_CAPABLE */
}

#ifdef _MB_CAPABLE
static char *
currentlocale()
{
        int i;

        (void)strcpy(current_locale_string, current_categories[1]);

        for (i = 2; i < _LC_LAST; ++i)
                if (strcmp(current_categories[1], current_categories[i])) {
                        for (i = 2; i < _LC_LAST; ++i) {
                                (void)strcat(current_locale_string, "/");
                                (void)strcat(current_locale_string,
                                             current_categories[i]);
                        }
                        break;
                }
        return (current_locale_string);
}
#endif /* _MB_CAPABLE */

#ifdef _MB_CAPABLE
#ifdef __CYGWIN__
extern void __set_charset_from_locale (const char *locale, char *charset);
extern char *__set_locale_from_locale_alias (const char *, char *);
extern int __collate_load_locale (const char *, void *, const char *);
#endif /* __CYGWIN__ */

extern void __set_ctype (const char *charset);

static char *
loadlocale(struct _reent *p, int category)
{
  /* At this point a full-featured system would just load the locale
     specific data from the locale files.
     What we do here for now is to check the incoming string for correctness.
     The string must be in one of the allowed locale strings, either
     one in POSIX-style, or one in the old newlib style to maintain
     backward compatibility.  If the local string is correct, the charset
     is extracted and stored in lc_ctype_charset or lc_message_charset
     dependent on the cateogry. */
  char *locale = NULL;
  char charset[ENCODING_LEN + 1];
  unsigned long val;
  char *end, *c = NULL;
  int mbc_max;
  int (*l_wctomb) (struct _reent *, char *, wchar_t, const char *, mbstate_t *);
  int (*l_mbtowc) (struct _reent *, wchar_t *, const char *, size_t,
		   const char *, mbstate_t *);
  int cjknarrow = 0;

  /* Avoid doing everything twice if nothing has changed. */
  if (!strcmp (new_categories[category], current_categories[category]))
    return current_categories[category];

#ifdef __CYGWIN__
  /* This additional code handles the case that the incoming locale string
     is not valid.  If so, it calls the function __set_locale_from_locale_alias,
     which is only available on Cygwin right now.  The function reads the
     file /usr/share/locale/locale.alias.  The file contains locale aliases
     and their replacement locale.  For instance, the alias "french" is
     translated to "fr_FR.ISO-8859-1", the alias "thai" is translated to
     "th_TH.TIS-620".  If successful, the function returns with a pointer
     to the second argument, which is a buffer in which the replacement locale
     gets stored.  Otherwise the function returns NULL. */
  char tmp_locale[ENCODING_LEN + 1];
  int ret = 0;

restart:
  if (!locale)
    locale = new_categories[category];
  else if (locale != tmp_locale)
    {
      locale = __set_locale_from_locale_alias (locale, tmp_locale);
      if (!locale)
	return NULL;
    }
# define FAIL	goto restart
#else
  locale = new_categories[category];
# define FAIL	return NULL
#endif

  /* "POSIX" is translated to "C", as on Linux. */
  if (!strcmp (locale, "POSIX"))
    strcpy (locale, "C");
  if (!strcmp (locale, "C"))				/* Default "C" locale */
    strcpy (charset, "ASCII");
  else if (locale[0] == 'C'
	   && (locale[1] == '-'		/* Old newlib style */
	       || locale[1] == '.'))	/* Extension for the C locale to allow
					   specifying different charsets while
					   sticking to the C locale in terms
					   of sort order, etc.  Proposed in
					   the Debian project. */
    {
      char *chp;

      c = locale + 2;
      strcpy (charset, c);
      if ((chp = strchr (charset, '@@')))
        /* Strip off modifier */
        *chp = '\0';
      c += strlen (charset);
    }
  else							/* POSIX style */
    {
      c = locale;

      /* Don't use ctype macros here, they might be localized. */
      /* Language */
      if (c[0] < 'a' || c[0] > 'z'
	  || c[1] < 'a' || c[1] > 'z')
	FAIL;
      c += 2;
      /* Allow three character Language per ISO 639-3 */
      if (c[0] >= 'a' && c[0] <= 'z')
      	++c;
      if (c[0] == '_')
        {
	  /* Territory */
	  ++c;
	  if (c[0] < 'A' || c[0] > 'Z'
	      || c[1] < 'A' || c[1] > 'Z')
	    FAIL;
	  c += 2;
	}
      if (c[0] == '.')
	{
	  /* Charset */
	  char *chp;

	  ++c;
	  strcpy (charset, c);
	  if ((chp = strchr (charset, '@@')))
	    /* Strip off modifier */
	    *chp = '\0';
	  c += strlen (charset);
	}
      else if (c[0] == '\0' || c[0] == '@@')
	/* End of string or just a modifier */
#ifdef __CYGWIN__
	/* The Cygwin-only function __set_charset_from_locale checks
	   for the default charset which is connected to the given locale.
	   The function uses Windows functions in turn so it can't be easily
	   adapted to other targets.  However, if any other target provides
	   equivalent functionality, preferrably using the same function name
	   it would be sufficient to change the guarding #ifdef. */
	__set_charset_from_locale (locale, charset);
#else
	strcpy (charset, "ISO-8859-1");
#endif
      else
	/* Invalid string */
      	FAIL;
    }
  if (c && c[0] == '@@')
    {
      /* Modifier */
      /* Only one modifier is recognized right now.  "cjknarrow" is used
         to modify the behaviour of wcwidth() for East Asian languages.
         For details see the comment at the end of this function. */
      if (!strcmp (c + 1, "cjknarrow"))
	cjknarrow = 1;
    }
  /* We only support this subset of charsets. */
  switch (charset[0])
    {
    case 'U':
    case 'u':
      if (strcasecmp (charset, "UTF-8") && strcasecmp (charset, "UTF8"))
	FAIL;
      strcpy (charset, "UTF-8");
      mbc_max = 6;
      l_wctomb = __utf8_wctomb;
      l_mbtowc = __utf8_mbtowc;
    break;
#ifndef __CYGWIN__
    /* Cygwin does not support JIS at all. */
    case 'J':
    case 'j':
      if (strcasecmp (charset, "JIS"))
	FAIL;
      strcpy (charset, "JIS");
      mbc_max = 8;
      l_wctomb = __jis_wctomb;
      l_mbtowc = __jis_mbtowc;
    break;
#endif /* !__CYGWIN__ */
    case 'E':
    case 'e':
      if (strncasecmp (charset, "EUC", 3))
	FAIL;
      c = charset + 3;
      if (*c == '-')
	++c;
      if (!strcasecmp (c, "JP"))
	{
	  strcpy (charset, "EUCJP");
	  mbc_max = 3;
	  l_wctomb = __eucjp_wctomb;
	  l_mbtowc = __eucjp_mbtowc;
	}
#ifdef __CYGWIN__
      /* Newlib does neither provide EUC-KR nor EUC-CN, and Cygwin's
      	 implementation requires Windows support. */
      else if (!strcasecmp (c, "KR"))
	{
	  strcpy (charset, "EUCKR");
	  mbc_max = 2;
	  l_wctomb = __kr_wctomb;
	  l_mbtowc = __kr_mbtowc;
	}
      else if (!strcasecmp (c, "CN"))
	{
	  strcpy (charset, "EUCCN");
	  mbc_max = 2;
	  l_wctomb = __gbk_wctomb;
	  l_mbtowc = __gbk_mbtowc;
	}
#endif /* __CYGWIN__ */
      else
	FAIL;
    break;
    case 'S':
    case 's':
      if (strcasecmp (charset, "SJIS"))
	FAIL;
      strcpy (charset, "SJIS");
      mbc_max = 2;
      l_wctomb = __sjis_wctomb;
      l_mbtowc = __sjis_mbtowc;
    break;
    case 'I':
    case 'i':
      /* Must be exactly one of ISO-8859-1, [...] ISO-8859-16, except for
         ISO-8859-12.  This code also recognizes the aliases without dashes. */
      if (strncasecmp (charset, "ISO", 3))
	FAIL;
      c = charset + 3;
      if (*c == '-')
	++c;
      if (strncasecmp (c, "8859", 4))
	FAIL;
      c += 4;
      if (*c == '-')
	++c;
      val = _strtol_r (p, c, &end, 10);
      if (val < 1 || val > 16 || val == 12 || *end)
	FAIL;
      strcpy (charset, "ISO-8859-");
      c = charset + 9;
      if (val > 10)
      	*c++ = '1';
      *c++ = val % 10 + '0';
      *c = '\0';
      mbc_max = 1;
#ifdef _MB_EXTENDED_CHARSETS_ISO
      l_wctomb = __iso_wctomb;
      l_mbtowc = __iso_mbtowc;
#else /* !_MB_EXTENDED_CHARSETS_ISO */
      l_wctomb = __ascii_wctomb;
      l_mbtowc = __ascii_mbtowc;
#endif /* _MB_EXTENDED_CHARSETS_ISO */
    break;
    case 'C':
    case 'c':
      if (charset[1] != 'P' && charset[1] != 'p')
	FAIL;
      strncpy (charset, "CP", 2);
      val = _strtol_r (p, charset + 2, &end, 10);
      if (*end)
	FAIL;
      switch (val)
	{
	case 437:
	case 720:
	case 737:
	case 775:
	case 850:
	case 852:
	case 855:
	case 857:
	case 858:
	case 862:
	case 866:
	case 874:
	case 1125:
	case 1250:
	case 1251:
	case 1252:
	case 1253:
	case 1254:
	case 1255:
	case 1256:
	case 1257:
	case 1258:
	  mbc_max = 1;
#ifdef _MB_EXTENDED_CHARSETS_WINDOWS
	  l_wctomb = __cp_wctomb;
	  l_mbtowc = __cp_mbtowc;
#else /* !_MB_EXTENDED_CHARSETS_WINDOWS */
	  l_wctomb = __ascii_wctomb;
	  l_mbtowc = __ascii_mbtowc;
#endif /* _MB_EXTENDED_CHARSETS_WINDOWS */
	  break;
	case 932:
	  mbc_max = 2;
	  l_wctomb = __sjis_wctomb;
	  l_mbtowc = __sjis_mbtowc;
	  break;
	default:
	  FAIL;
	}
    break;
    case 'K':
    case 'k':
      /* KOI8-R, KOI8-U and the aliases without dash */
      if (strncasecmp (charset, "KOI8", 4))
	FAIL;
      c = charset + 4;
      if (*c == '-')
	++c;
      if (*c == 'R' || *c == 'r')
	strcpy (charset, "CP20866");
      else if (*c == 'U' || *c == 'u')
	strcpy (charset, "CP21866");
      else
	FAIL;
      mbc_max = 1;
#ifdef _MB_EXTENDED_CHARSETS_WINDOWS
      l_wctomb = __cp_wctomb;
      l_mbtowc = __cp_mbtowc;
#else /* !_MB_EXTENDED_CHARSETS_WINDOWS */
      l_wctomb = __ascii_wctomb;
      l_mbtowc = __ascii_mbtowc;
#endif /* _MB_EXTENDED_CHARSETS_WINDOWS */
      break;
    case 'A':
    case 'a':
      if (strcasecmp (charset, "ASCII"))
	FAIL;
      strcpy (charset, "ASCII");
      mbc_max = 1;
      l_wctomb = __ascii_wctomb;
      l_mbtowc = __ascii_mbtowc;
      break;
    case 'G':
    case 'g':
#ifdef __CYGWIN__
      /* Newlib does not provide GBK/GB2312 and Cygwin's implementation
	 requires Windows support. */
      if (!strcasecmp (charset, "GBK")
	  || !strcasecmp (charset, "GB2312"))
      	{
	  strcpy (charset, charset[2] == '2' ? "GB2312" : "GBK");
	  mbc_max = 2;
	  l_wctomb = __gbk_wctomb;
	  l_mbtowc = __gbk_mbtowc;
	}
      else
#endif /* __CYGWIN__ */
      /* GEORGIAN-PS and the alias without dash */
      if (!strncasecmp (charset, "GEORGIAN", 8))
	{
	  c = charset + 8;
	  if (*c == '-')
	    ++c;
	  if (strcasecmp (c, "PS"))
	    FAIL;
	  strcpy (charset, "CP101");
	  mbc_max = 1;
#ifdef _MB_EXTENDED_CHARSETS_WINDOWS
	  l_wctomb = __cp_wctomb;
	  l_mbtowc = __cp_mbtowc;
#else /* !_MB_EXTENDED_CHARSETS_WINDOWS */
	  l_wctomb = __ascii_wctomb;
	  l_mbtowc = __ascii_mbtowc;
#endif /* _MB_EXTENDED_CHARSETS_WINDOWS */
	}
      else
	FAIL;
      break;
    case 'P':
    case 'p':
      /* PT154 */
      if (strcasecmp (charset, "PT154"))
	FAIL;
      strcpy (charset, "CP102");
      mbc_max = 1;
#ifdef _MB_EXTENDED_CHARSETS_WINDOWS
      l_wctomb = __cp_wctomb;
      l_mbtowc = __cp_mbtowc;
#else /* !_MB_EXTENDED_CHARSETS_WINDOWS */
      l_wctomb = __ascii_wctomb;
      l_mbtowc = __ascii_mbtowc;
#endif /* _MB_EXTENDED_CHARSETS_WINDOWS */
      break;
    case 'T':
    case 't':
      if (strncasecmp (charset, "TIS", 3))
      	FAIL;
      c = charset + 3;
      if (*c == '-')
	++c;
      if (strcasecmp (c, "620"))
      	FAIL;
      strcpy (charset, "CP874");
      mbc_max = 1;
#ifdef _MB_EXTENDED_CHARSETS_WINDOWS
      l_wctomb = __cp_wctomb;
      l_mbtowc = __cp_mbtowc;
#else /* !_MB_EXTENDED_CHARSETS_WINDOWS */
      l_wctomb = __ascii_wctomb;
      l_mbtowc = __ascii_mbtowc;
#endif /* _MB_EXTENDED_CHARSETS_WINDOWS */
      break;
#ifdef __CYGWIN__
    /* Newlib does not provide Big5 and Cygwin's implementation
       requires Windows support. */
    case 'B':
    case 'b':
      if (strcasecmp (charset, "BIG5"))
      	FAIL;
      strcpy (charset, "BIG5");
      mbc_max = 2;
      l_wctomb = __big5_wctomb;
      l_mbtowc = __big5_mbtowc;
      break;
#endif /* __CYGWIN__ */
    default:
      FAIL;
    }
  switch (category)
    {
    case LC_CTYPE:
      strcpy (lc_ctype_charset, charset);
      __mb_cur_max = mbc_max;
      __wctomb = l_wctomb;
      __mbtowc = l_mbtowc;
      __set_ctype (charset);
      /* Determine the width for the "CJK Ambiguous Width" category of
         characters. This is used in wcwidth(). Assume single width for
         single-byte charsets, and double width for multi-byte charsets
         other than UTF-8. For UTF-8, use double width for the East Asian
         languages ("ja", "ko", "zh"), and single width for everything else.
         Single width can also be forced with the "@@cjknarrow" modifier. */
      lc_ctype_cjk_lang = !cjknarrow
			  && mbc_max > 1
			  && (charset[0] != 'U'
			      || strncmp (locale, "ja", 2) == 0
			      || strncmp (locale, "ko", 2) == 0
			      || strncmp (locale, "zh", 2) == 0);
#ifdef __HAVE_LOCALE_INFO__
      ret = __ctype_load_locale (locale, (void *) l_wctomb, charset, mbc_max);
#endif /* __HAVE_LOCALE_INFO__ */
      break;
    case LC_MESSAGES:
      strcpy (lc_message_charset, charset);
#ifdef __HAVE_LOCALE_INFO__
      ret = __messages_load_locale (locale, (void *) l_wctomb, charset);
      if (!ret)
#endif /* __HAVE_LOCALE_INFO__ */
      break;
#ifdef __HAVE_LOCALE_INFO__
#ifdef __CYGWIN__
  /* Right now only Cygwin supports a __collate_load_locale function at all. */
    case LC_COLLATE:
      ret = __collate_load_locale (locale, (void *) l_mbtowc, charset);
      break;
#endif
    case LC_MONETARY:
      ret = __monetary_load_locale (locale, (void *) l_wctomb, charset);
      break;
    case LC_NUMERIC:
      ret = __numeric_load_locale (locale, (void *) l_wctomb, charset);
      break;
    case LC_TIME:
      ret = __time_load_locale (locale, (void *) l_wctomb, charset);
      break;
#endif /* __HAVE_LOCALE_INFO__ */
    default:
      break;
    }
#ifdef __HAVE_LOCALE_INFO__
  if (ret)
    FAIL;
#endif /* __HAVE_LOCALE_INFO__ */
  return strcpy(current_categories[category], new_categories[category]);
}

static const char *
__get_locale_env(struct _reent *p, int category)
{
  const char *env;

  /* 1. check LC_ALL. */
  env = _getenv_r (p, categories[0]);

  /* 2. check LC_* */
  if (env == NULL || !*env)
    env = _getenv_r (p, categories[category]);

  /* 3. check LANG */
  if (env == NULL || !*env)
    env = _getenv_r (p, "LANG");

  /* 4. if none is set, fall to default locale */
  if (env == NULL || !*env)
    env = __default_locale;

  return env;
}
#endif /* _MB_CAPABLE */

char *
_DEFUN_VOID(__locale_charset)
{
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->codeset;
#else
  return lc_ctype_charset;
#endif
}

int
_DEFUN_VOID(__locale_mb_cur_max)
{
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __mb_cur_max;
#endif
}


char *
_DEFUN_VOID(__locale_msgcharset)
{
#ifdef __HAVE_LOCALE_INFO__
  return (char *) __get_current_messages_locale ()->codeset;
#else
  return lc_message_charset;
#endif
}

int
_DEFUN_VOID(__locale_cjk_lang)
{
  return lc_ctype_cjk_lang;
}

struct lconv *
_DEFUN(_localeconv_r, (data), 
      struct _reent *data)
{
#ifdef __HAVE_LOCALE_INFO__
  if (__nlocale_changed)
    {
      struct lc_numeric_T *n = __get_current_numeric_locale ();
      lconv.decimal_point = (char *) n->decimal_point;
      lconv.thousands_sep = (char *) n->thousands_sep;
      lconv.grouping = (char *) n->grouping;
      __nlocale_changed = 0;
    }
  if (__mlocale_changed)
    {
      struct lc_monetary_T *m = __get_current_monetary_locale ();
      lconv.int_curr_symbol = (char *) m->int_curr_symbol;
      lconv.currency_symbol = (char *) m->currency_symbol;
      lconv.mon_decimal_point = (char *) m->mon_decimal_point;
      lconv.mon_thousands_sep = (char *) m->mon_thousands_sep;
      lconv.mon_grouping = (char *) m->mon_grouping;
      lconv.positive_sign = (char *) m->positive_sign;
      lconv.negative_sign = (char *) m->negative_sign;
      lconv.int_frac_digits = m->int_frac_digits[0];
      lconv.frac_digits = m->frac_digits[0];
      lconv.p_cs_precedes = m->p_cs_precedes[0];
      lconv.p_sep_by_space = m->p_sep_by_space[0];
      lconv.n_cs_precedes = m->n_cs_precedes[0];
      lconv.n_sep_by_space = m->n_sep_by_space[0];
      lconv.p_sign_posn = m->p_sign_posn[0];
      lconv.n_sign_posn = m->n_sign_posn[0];
#ifdef __HAVE_LOCALE_INFO_EXTENDED__
      lconv.int_p_cs_precedes = m->int_p_cs_precedes[0];
      lconv.int_p_sep_by_space = m->int_p_sep_by_space[0];
      lconv.int_n_cs_precedes = m->int_n_cs_precedes[0];
      lconv.int_n_sep_by_space = m->int_n_sep_by_space[0];
      lconv.int_n_sign_posn = m->int_n_sign_posn[0];
      lconv.int_p_sign_posn = m->int_p_sign_posn[0];
#else /* !__HAVE_LOCALE_INFO_EXTENDED__ */
      lconv.int_p_cs_precedes = m->p_cs_precedes[0];
      lconv.int_p_sep_by_space = m->p_sep_by_space[0];
      lconv.int_n_cs_precedes = m->n_cs_precedes[0];
      lconv.int_n_sep_by_space = m->n_sep_by_space[0];
      lconv.int_n_sign_posn = m->n_sign_posn[0];
      lconv.int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
      __mlocale_changed = 0;
    }
#endif /* __HAVE_LOCALE_INFO__ */
  return (struct lconv *) &lconv;
}

#ifndef _REENT_ONLY

#ifndef __CYGWIN__
/* Cygwin provides its own version of setlocale to perform some more
   initialization work.  It calls _setlocale_r, though. */
char *
_DEFUN(setlocale, (category, locale),
       int category _AND
       _CONST char *locale)
{
  return _setlocale_r (_REENT, category, locale);
}
#endif /* __CYGWIN__ */

struct lconv *
_DEFUN_VOID(localeconv)
{
  return _localeconv_r (_REENT);
}

#endif
@


1.50
log
@	* libc/locale/lmessages.h (__messages_load_locale): Declare.  Remove
	accidental declaration of __numeric_load_locale.
	* libc/locale/locale.c: Include timelocal.h to get declaration of
	__time_load_locale.
	(__set_locale_from_locale_alias): Fix return type.
	(__locale_msgcharset): Avoid compiler warnings.
	(_localeconv_r): Ditto.
@
text
@d191 3
d195 1
@


1.49
log
@	Cygwin-specific patch from Andy Koppe:
	* libc/locale/locale.c (current_categories): On Cygwin, set LC_CTYPE
	to C.UTF-8 to match initial __wctomb and __mbtowc settings.
	(lc_ctype_charset): On Cygwin, initialize to "UTF-8".
	(loadlocale): Remove unused Cygwin-specifc code.
@
text
@d185 1
d439 1
a439 1
extern int __set_locale_from_locale_alias (const char *, char *);
d955 1
a955 1
  return __get_current_messages_locale ()->codeset;
d975 3
a977 3
      lconv.decimal_point = n->decimal_point;
      lconv.thousands_sep = n->thousands_sep;
      lconv.grouping = n->grouping;
d983 7
a989 7
      lconv.int_curr_symbol = m->int_curr_symbol;
      lconv.currency_symbol = m->currency_symbol;
      lconv.mon_decimal_point = m->mon_decimal_point;
      lconv.mon_thousands_sep = m->mon_thousands_sep;
      lconv.mon_grouping = m->mon_grouping;
      lconv.positive_sign = m->positive_sign;
      lconv.negative_sign = m->negative_sign;
@


1.48
log
@	* libc/locale/locale.c (loadlocale): Recognise the "cjknarrow"
	modifier on "C.<charset>" locales too.
@
text
@d238 3
d242 1
d262 1
a262 1
#if 0 /*def __CYGWIN__  TODO: temporarily(?) disable C == UTF-8 */
a263 1
static char lc_message_charset[ENCODING_LEN + 1] = "UTF-8";
d266 1
a267 1
#endif
a500 3
#if 0 /*def __CYGWIN__  TODO: temporarily(?) disable C == UTF-8 */
    strcpy (charset, "UTF-8");
#else
a501 1
#endif
@


1.47
log
@	* libc/locale/locale.c (loadlocale): Fix width of CJK ambigous
	characters to 1 for singlebyte charsets and 2 for non-Unicode
	multibyte charsets. Change documentation accordingly.
@
text
@d455 1
a455 1
  char *end, *c;
d510 10
a519 1
    strcpy (charset, locale + 2);
d570 9
a578 9
      if (c[0] == '@@')
	{
	  /* Modifier */
	  /* Only one modifier is recognized right now.  "cjknarrow" is used
	     to modify the behaviour of wcwidth() for East Asian languages.
	     For details see the comment at the end of this function. */
	  if (!strcmp (c + 1, "cjknarrow"))
	    cjknarrow = 1;
	}
@


1.46
log
@
2010-05-11  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/locale/locale.c (loadlocale): Fix dangling
        switch statement caused by __HAVE_LOCALE_INFO__ not being
        defined.
@
text
@d93 9
a101 10
This implementation also supports a single modifier, <<"cjknarrow">>.
Any other modifier is ignored.  <<"cjknarrow">>, in conjunction with one
of the language specifiers <<"ja">>, <<"ko">>, and <<"zh">> specifies
how the functions <<wcwidth>> and <<wcswidth>> handle characters from
the "CJK Ambiguous Width" character class described in
http://www.unicode.org/unicode/reports/tr11/.  Usually these characters
have a width of 1, unless you specify one of the aforementioned
languages, in which case these characters have a width of 2.  By
specifying the <<"cjknarrow">> modifier, these characters will have a
width of one in the languages <<"ja">>, <<"ko">>, and <<"zh">> as well.
d847 6
a852 6
      /* Check for the language part of the locale specifier.  In case
         of "ja", "ko", or "zh", assume the use of CJK fonts, unless the
	 "@@cjknarrow" modifier has been specifed.
	 The result is stored in lc_ctype_cjk_lang and tested in wcwidth()
	 to figure out the width to return (1 or 2) for the "CJK Ambiguous
	 Width" category of characters. */
d854 3
a856 1
			  && ((strncmp (locale, "ja", 2) == 0
d858 1
a858 1
			      || strncmp (locale, "zh", 2) == 0));
@


1.45
log
@	Extend locale support to maintain wide char values of native strings
	if __HAVE_LOCALE_INFO_EXTENDED__ is defined.
	* libc/include/langinfo.h (enum __nl_item): New type.  Define all
	native values accessible through nl_langinfo.  Define previously
	existing POSIX-compatible values as macros as well.
	* libc/include/stdlib.h (__mb_cur_max): Drop declaration.
	(__locale_mb_cur_max): Declare.
	(MB_CUR_MAX): Re-define calling __locale_mb_cur_max.
	* libc/locale/Makefile.am (ELIX_SOURCES): Add lctype.c.
	* libc/locale/Makefile.in: Regenerate.
	* libc/locale/lctype.c: New file to define and load LC_CTYPE category.
	* libc/locale/lctype.h: New file, matching header.
	* libc/locale/lmessages.c (_C_messages_locale): Add default values for
	wide char members.
	(__messages_load_locale): Add _C_messages_locale in call to
	__set_lc_messages_from_win.
	* libc/locale/lmessages.h (struct lc_messages_T): Add wide char members.
	* libc/locale/lmonetary.c (_C_monetary_locale):  Add default values for
	wide char members.
	(__monetary_load_locale): Add _C_monetary_locale in call to
	__set_lc_monetary_from_win.
	* libc/locale/lmonetary.h (struct lc_monetary_T): Add wide char members.
	Add numerical values for international currency formatting per
	POSIX-1.2008, if __HAVE_LOCALE_INFO_EXTENDED__ is defined.
	* libc/locale/lnumeric.c (_C_numeric_locale): Add default values for
	wide char members.
	(__numeric_load_locale): Add _C_numeric_locale in call to
	__set_lc_numeric_from_win.
	* libc/locale/lnumeric.h (struct lc_numeric_T): Add wide char members.
	* libc/locale/locale.c (loadlocale): Return doing nothing if category
	locale didn't change.  Convert category if chain to switch statement.
	Call __ctype_load_locale in LC_CTYPE case.
	(__locale_charset): Add (but disable for now) returning codeset from
	__get_current_ctype_locale.
	(__locale_mb_cur_max): Add (but disable for now) returning mb_cur_max
	from __get_current_ctype_locale.
	(__locale_msgcharset): Add returning codeset from
	__get_current_messages_locale.
	(_localeconv_r): Accommodate int_XXX values.
	* libc/locale/nl_langinfo.c (nl_ext): New array to define what is to
	be returned for non-POSIX values.
	(nl_Langinfo): Return correct codeset for each locale category.  Return
	extended values if __HAVE_LOCALE_INFO_EXTENDED__ is defined.
	* libc/locale/timelocal.c (_C_time_locale): Add default values for
	wide char members.
	(__time_load_locale): Add _C_time_locale in call to
	__set_lc_time_from_win.
	* libc/locale/timelocal.h (struct lc_time_T): Add wide char members.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R): Use wide char decimal point
	and thousands_sep if __HAVE_LOCALE_INFO_EXTENDED__ is defined.
	* libc/time/strftime.c: Rework to accommodate availability of wide char
	strings in LC_TIME category if __HAVE_LOCALE_INFO_EXTENDED__ is defined.
@
text
@d885 1
d889 1
@


1.44
log
@* libc/Makefile.am (SUBDEFS): Add LIBC_POSIX_DEF.
(libc.info): Add posix.texi.
(libc.dvi): Likewise.
(stmp-posix): New.
(posix.texi): New.
(libc_TEXINFOS): Add posix.texi.
* libc/configure.in (LIBC_POSIX_LIB, LIBC_POSIX_DEF): Add
tests.
* libc/libc.texinfo: Include posix.texi
* libc/locale/locale.c: Fix texinfo typo.
* libc/time/strftime.c: Fix texinfo typo.

* libc/configure: Regenerate.
* libc/Makefile.in: Regenerate.
* libc/argz/Makefile.in: Regenerate.
* libc/ctype/Makefile.in: Regenerate.
* libc/errno/Makefile.in: Regenerate.
* libc/iconv/Makefile.in: Regenerate.
* libc/iconv/ccs/Makefile.in: Regenerate.
* libc/iconv/ccs/binary/Makefile.in: Regenerate.
* libc/iconv/ces/Makefile.in: Regenerate.
* libc/iconv/lib/Makefile.in: Regenerate.
* libc/locale/Makefile.in: Regenerate.
* libc/misc/Makefile.in: Regenerate.
* libc/posix/Makefile.in: Regenerate.
* libc/reent/Makefile.in: Regenerate.
* libc/search/Makefile.in: Regenerate.
* libc/signal/Makefile.in: Regenerate.
* libc/stdio/Makefile.in: Regenerate.
* libc/stdio64/Makefile.in: Regenerate.
* libc/stdlib/Makefile.in: Regenerate.
* libc/string/Makefile.in: Regenerate.
* libc/syscalls/Makefile.in: Regenerate.
* libc/time/Makefile.in: Regenerate.
* libc/unix/Makefile.in: Regenerate.
* libc/xdr/Makefile.in: Regenerate.
@
text
@d182 1
d185 1
d462 5
d840 1
a840 1
  if (category == LC_CTYPE)
d842 1
d858 6
a863 3
    }
  else if (category == LC_MESSAGES)
    {
d868 1
a868 2
      strcpy (lc_message_charset, charset);
    }
d872 3
a874 2
  else if (category == LC_COLLATE)
    ret = __collate_load_locale (locale, (void *) l_mbtowc, charset);
d876 12
a887 6
  else if (category == LC_MONETARY)
    ret = __monetary_load_locale (locale, (void *) l_wctomb, charset);
  else if (category == LC_NUMERIC)
    ret = __numeric_load_locale (locale, (void *) l_wctomb, charset);
  else if (category == LC_TIME)
    ret = __time_load_locale (locale, (void *) l_wctomb, charset);
d921 3
d925 11
d938 1
d942 3
d946 1
d986 10
a998 2
      lconv.int_p_cs_precedes = m->p_cs_precedes[0];
      lconv.int_p_sep_by_space = m->p_sep_by_space[0];
d1000 1
@


1.43
log
@	* libc/locale/locale.c (loadlocale): Optimize "EUC" charset check.
	Cygwin only: Allow GB2312 and EUC-CN as alternative codeset names
	for GBK.  Add to documentation.
	* libc/locale/nl_langinfo.c (nl_langinfo): On Cygwin, translate EUCCN
	to GB2312.
@
text
@d77 1
a77 1
<<"EUCKR"> are also recognized with dash, <<"EUC-JP">> and <<"EUC-KR">>.
@


1.42
log
@	* libc/locale/locale.c (loadlocale): Fix typo in comment.
@
text
@d84 2
a85 1
<<"GBK">>, <<"eucKR">>, and <<"Big5">>.  Cygwin does not support <<"JIS">>.
d591 6
a596 1
      if (!strcasecmp (charset, "EUCJP") || !strcasecmp (charset, "EUC-JP"))
d604 3
a606 4
      /* Newlib does not provide EUC-KR and Cygwin's implementation
	 requires Windows support. */
      else if (!strcasecmp (charset, "EUCKR")
	       || !strcasecmp (charset, "EUC-KR"))
d613 7
d750 1
a750 1
      /* Newlib does not provide GBK and Cygwin's implementation
d752 2
a753 1
      if (!strcasecmp (charset, "GBK"))
d755 1
a755 1
	  strcpy (charset, "GBK");
@


1.41
log
@	* libc/locale/locale.c:  Throughout, extensively comment on the
	reason for using __CYGWIN__.
	(lconv): Remove _CONST entirely.
	(loadlocale): Guard calls to function loading locale-specific
	category data with __HAVE_LOCALE_INFO__ rather than __CYGWIN__.
	* libc/sys/config.h (__HAVE_LOCALE_INFO__): Define for Cygwin.
@
text
@d467 1
a467 1
     to the second argument, which is a buffer in which the reaplcement locale
@


1.40
log
@	* libc/locale/lmessages.c (__messages_load_locale): Take additional
	parameters for wide char to multibyte conversion.  Call
	__set_lc_messages_from_win on Cygwin.
	* libc/locale/lmessages.h: Make C++-safe.
	(__messages_load_locale): Change declaration.
	* libc/locale/lmonetary.c (__monetary_load_locale): Use
	_monetary_locale_buf as buffer pointer.
	* libc/locale/lnumeric.c (__numeric_load_locale): Use
	_numeric_locale_buf as buffer pointer.
	* libc/locale/timelocal.c (__time_load_locale): Use time_locale_buf
	as buffer pointer.
	* libc/locale/locale.c (loadlocale): Enable loading LC_MESSAGES data
	on Cygwin.
@
text
@a194 3
#ifndef __CYGWIN__
_CONST
#endif /* !__CYGWIN__ */
d460 9
d541 6
d577 1
d598 2
d738 2
d805 2
d840 1
a840 1
#ifdef __CYGWIN__
d843 1
a843 1
#endif
d846 1
d848 1
d851 1
d860 1
a860 1
#endif /* __CYGWIN__ */
d910 1
a910 1
#ifdef __CYGWIN__
d945 1
a945 1
#endif /* __CYGWIN__ */
d952 2
@


1.39
log
@	* libc/locale/locale.c: Add Cygwin's /usr/share/locale/locale.alias
	support to documentation.
	(__set_locale_from_locale_alias): Declare when build for Cygwin.
	(loadlocale): On Cygwin, if locale can't be recognized, call
	__set_locale_from_locale_alias to check for locale alias.
	Define FAIL macro to replace `return NULL' statements.  Replace
	throughout.
@
text
@d820 7
a826 1
    strcpy (lc_message_charset, charset);
@


1.38
log
@	* libc/locale/locale.c: Fix typo in documentation.  Remove useless
	_MB_CAPABLE guards within other _MB_CAPABLE guards.  Add comment
	to remaining #endif's.
@
text
@d86 3
d436 1
d453 1
a453 1
  char *locale = new_categories[category];
d463 1
d465 14
d480 1
a480 1
  
d506 1
a506 1
	return NULL;
d517 1
a517 1
	    return NULL;
d541 1
a541 1
      	return NULL;
d558 1
a558 1
	return NULL;
d568 1
a568 1
	return NULL;
d595 1
a595 1
	return NULL;
d600 1
a600 1
	return NULL;
d611 1
a611 1
	return NULL;
d616 1
a616 1
	return NULL;
d622 1
a622 1
	return NULL;
d641 1
a641 1
	return NULL;
d645 1
a645 1
	return NULL;
d685 1
a685 1
	  return NULL;
d692 1
a692 1
	return NULL;
d701 1
a701 1
	return NULL;
d714 1
a714 1
	return NULL;
d739 1
a739 1
	    return NULL;
d751 1
a751 1
	return NULL;
d757 1
a757 1
	return NULL;
d771 1
a771 1
      	return NULL;
d776 1
a776 1
      	return NULL;
d791 1
a791 1
      	return NULL;
d799 1
a799 1
      return NULL;
d831 1
a831 1
    return NULL;
@


1.37
log
@	* libc/ctype/ctype_cp.h (_CTYPE_GEORGIAN_PS_128_254): Define.
	(_CTYPE_GEORGIAN_PS_255): Define.
	(_CTYPE_PT154_128_254): Define.
	(_CTYPE_PT154_255): Define.
	(__ctype_cp): Add array members for above ctype definitions.
	* libc/locale/locale.c (loadlocale): Make TIS-620 charset name
	available for all targets.  Add guards for setting the conversion
	function pointers.  Add support for GEORGIAN-PS and PT154 charsets.
	Change documentation to reflect current behaviour more closely.
	* libc/locale/nl_langinfo.c (nl_langinfo): On Cygwin, translate
	"CP101" to "GEORGIAN-PS" and "CP102" to "PT154".
	* libc/stdlib/sb_charsets.c (__cp_conv): Add conversion arrays
	for GEORGIAN-PS and PT154.
	(__cp_index): Map invalid Windows codepage number 101 to
	GEORGIAN-PS conversion array, 102 to PT154 conversion array.
@
text
@d67 1
a67 1
The following charsets are recogized:
d254 1
a254 1
#endif
d279 1
a279 1
#else
d406 1
a406 1
#endif
d428 1
a428 1
#endif
a456 1
#ifdef _MB_CAPABLE
a457 1
#endif
a522 1
#ifdef _MB_CAPABLE
a531 1
#endif
a541 1
#ifdef _MB_CAPABLE
a543 1
#endif
a551 1
#ifdef _MB_CAPABLE
a553 1
#endif
a561 1
#ifdef _MB_CAPABLE
a563 1
#endif
a570 1
#ifdef _MB_CAPABLE
a572 1
#endif
a583 1
#ifdef _MB_CAPABLE
a585 1
#endif
a610 1
#ifdef _MB_CAPABLE
a617 1
#endif
a651 1
#ifdef _MB_CAPABLE
a658 1
#endif
a661 1
#ifdef _MB_CAPABLE
a663 1
#endif
a683 1
#ifdef _MB_CAPABLE
a690 1
#endif
a697 1
#ifdef _MB_CAPABLE
a699 1
#endif
a707 1
#ifdef _MB_CAPABLE
a709 1
#endif
a722 1
#ifdef _MB_CAPABLE
a729 1
#endif
a740 1
#ifdef _MB_CAPABLE
a747 1
#endif
a759 1
#ifdef _MB_CAPABLE
a766 1
#endif
a774 1
#ifdef _MB_CAPABLE
a776 1
#endif
a785 1
#ifdef _MB_CAPABLE
a798 1
#endif
d839 1
a839 1
#endif
@


1.36
log
@	* libc/locale/locale.c (loadlocale): Handle ISO-8859 and KOI8 charsets
	so that the dashes are optional.  Align documentation.
@
text
@d59 4
a62 8
Additionally to the POSIX specifier, seven extensions are supported for
backward compatibility with older implementations using newlib:
<<"C-UTF-8">>, <<"C-JIS">>, <<"C-eucJP">>, <<"C-SJIS">>, <<C-KOI8-R>>,
<<C-KOI8-U>>, <<"C-ISO-8859-x">> with 1 <= x <= 15, or <<"C-CPxxx">> with
xxx in [437, 720, 737, 775, 850, 852, 855, 857, 858, 862, 866, 874, 932,
1125, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258].

Instead of <<"C-">>, you can specify also <<"C.">>.  Both variations allow
d67 1
a67 1
Even when using POSIX locale strings, the only charsets allowed are
d69 5
a73 3
<<"ISO-8859-x">> with 1 <= x <= 15, or <<"CPxxx">> with xxx in
[437, 720, 737, 775, 850, 852, 855, 857, 858, 862, 866, 874, 932, 1125, 1250,
1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258].
d79 7
a88 3
Under Cygwin, this implementation additionally supports the charsets
<<"GBK">>, <<"eucKR">>, <<"Big5">>, and <<"TIS-620">>.

a724 1
#ifdef __CYGWIN__
d727 22
a748 4
      if (strcasecmp (charset, "GBK"))
      	return NULL;
      strcpy (charset, "GBK");
      mbc_max = 2;
d750 7
a756 2
      l_wctomb = __gbk_wctomb;
      l_mbtowc = __gbk_mbtowc;
d758 3
d762 7
a768 6
    case 'B':
    case 'b':
      if (strcasecmp (charset, "BIG5"))
      	return NULL;
      strcpy (charset, "BIG5");
      mbc_max = 2;
d770 7
a776 2
      l_wctomb = __big5_wctomb;
      l_mbtowc = __big5_mbtowc;
d781 6
a786 1
      if (strcasecmp (charset, "TIS620") && strcasecmp (charset, "TIS-620"))
d791 1
d794 16
@


1.35
log
@	* libc/locale/locale.c (loadlocale): Allow CP932 as alias for SJIS.
	Add to documentation.  Add a few comments to #endif's for Cygwin.
@
text
@d72 1
a72 1
<<"UTF-8">>, <<"JIS">>, <<"EUCJP">>, <<"SJIS">>, <<KOI8-R>>, <<KOI8-U>>,
d77 3
a79 4
are equivalent.  <<"UTF-8">> can also be written without dash, as in
<<"UTF8">> or <<"utf8">>.  <<"EUCJP">> and <<"EUCKR"> can also contain a
dash, <<"EUC-JP">> and <<"EUC-KR">>.

d450 1
a450 1
  char *end;
d481 1
a481 1
      char *c = locale;
d602 2
a603 2
         ISO-8859-12. */
      if (strncasecmp (charset, "ISO-8859-", 9))
d605 9
a613 2
      strncpy (charset, "ISO", 3);
      val = _strtol_r (p, charset + 9, &end, 10);
d616 6
d689 7
a695 1
      if (!strcasecmp (charset, "KOI8-R"))
d697 1
a697 1
      else if (!strcasecmp (charset, "KOI8-U"))
@


1.34
log
@	* libc/locale/locale.c (loadlocale): Disable JIS entirely on Cygwin.
	Allow TIS620 and TIS-620 as aliases for CP874 on Cygwin.
@
text
@d63 2
a64 2
xxx in [437, 720, 737, 775, 850, 852, 855, 857, 858, 862, 866, 874, 1125,
1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258].
d74 1
a74 1
[437, 720, 737, 775, 850, 852, 855, 857, 858, 862, 866, 874, 1125, 1250,
d193 1
a193 1
#endif
d562 1
a562 1
#endif
d585 1
a585 1
#endif
d664 7
d776 1
a776 1
#endif
d861 1
a861 1
#endif
d875 1
a875 1
#endif
@


1.33
log
@	* libc/locale/lmonetary.c (__monetary_load_locale): Take additional
	parameters for wide char to multibyte conversion.  Call
	__set_lc_monetary_from_win on Cygwin.
	* libc/locale/lmonetary.h: Make C++-safe.
	(__monetary_load_locale): Change declaration.
	* libc/locale/lnumeric.c (__numeric_load_locale): Take additional
	parameters for wide char to multibyte conversion.  Call
	__set_lc_numeric_from_win on Cygwin.
	* libc/locale/lnumeric.h: Make C++-safe.
	(__numeric_load_locale): Change declaration.
	* libc/locale/locale.c (lconv): De-constify for Cygwin.
	(__set_charset_from_locale): Rename from
	__set_charset_from_codepage.  Take locale as parameter instead of
	a codepage.
	(loadlocale): Allow "EUC-JP" for "EUCJP" and "EUC-KR" for "EUCKR".
	Change documnetation accordingly.  Enable LC_COLLATE, LC_MONETARY,
	LC_NUMERIC, and LC_TIME handling on Cygwin.
	(_localeconv_r): On Cygwin, copy values from monetary and numeric
	domain if change has been noted.
	* libc/locale/nl_langinfo.c (nl_langinfo): Accommodate change of
	am/pm layout in struct lc_time_T.
	* libc/locale/timelocal.c (_C_time_locale): Accommodate
	redefinition of am/pm members.
	(__time_load_locale): Take additional parameters for wide char
	to multibyte conversion.  Call __set_lc_time_from_win on Cygwin.
	* libc/locale/timelocal.h: Make C++-safe.
	(struct lc_time_T): Convert am and pm to a am_pm array for easier
	consumption by strftime and strptime.
	(__time_load_locale): Change declaration.
	* libc/time/strftime.c: Change documentation to reflect changes to
	strftime.  Remove locale constant strings in favor of access to
	locale-specifc data.
	(_ctloc): Define access method for locale-specifc data.
	(TOLOWER): Define for tolower conversion.
	(strftime): Throughout, convert locale-specific formats to use
	locale-specific data.  Add GNU-specific "%P" format.
	* libc/time/strptime.c: Remove locale constant strings in favor of
	access to locale-specifc data.
	(_ctloc): Define access method for locale-specifc data.
	(strptime): Throughout, convert locale-specific formats to use
	locale-specific data.
@
text
@d86 1
a86 1
<<"GBK">>, <<"eucKR">>, and <<"Big5">>.
d550 1
d562 1
d721 11
@


1.32
log
@	* libc/locale/locale.c (loadlocale): Change comments to refer to
	ISO 639-3 rather than 639-2.
@
text
@d78 3
a80 1
<<"UTF8">> or <<"utf8">>.
d177 2
d190 5
a194 1
static _CONST struct lconv lconv = 
d431 2
a432 1
extern void *__set_charset_from_codepage (unsigned int, char *charset);
d459 3
d517 1
a517 1
	__set_charset_from_codepage (0, charset);
d563 1
a563 1
      if (!strcasecmp (charset, "EUCJP"))
d573 2
a574 1
      else if (!strcasecmp (charset, "EUCKR"))
d745 12
d806 36
@


1.31
log
@	* libc/locale/locale.c (loadlocale): Allow three character
	language codes to accommodate ISO 639-2 codes.
@
text
@d55 1
a55 1
for a given language, a three character string per ISO 639-2.
d478 1
a478 1
      /* Allow three character Language per ISO 639-2 */
@


1.30
log
@	* libc/locale/locale.c (lc_ctype_charset): Disable defaulting to
	"UTF-8" on Cygwin.
	(lc_message_charset): Ditto.
	(loadlocale): Disable setting charset of the "C" locale to "UTF-8" on
	Cygwin.
	* libc/stdlib/mbtowc_r.c (__mbtowc): Add Cygwin-specific comment.
	* libc/stdlib/wctomb_r.c (__wctomb): Ditto.
@
text
@d54 4
a57 2
<<"language">> is a two character string per ISO 639.  <<"TERRITORY">> is a
country code per ISO 3166.  For <<"charset">> and <<"modifier">> see below.
d478 3
@


1.29
log
@	* libc/locale/locale.c (DEFAULT_LOCALE): New define.
	(__default_locale): New global variable set to the default locale.
	(__get_locale_env): Return __default_locale rather than fixed "C".
@
text
@d245 1
a245 1
#ifdef __CYGWIN__
d453 1
a453 1
#ifdef __CYGWIN__
@


1.28
log
@	* libc/locale/locale.c (loadlocale): Allow "C." same as "C-" as locale
	prefix.  Add some words to documentation.
@
text
@d208 12
d746 1
a746 1
  /* 4. if none is set, fall to "C" */
d748 1
a748 1
    env = "C";
@


1.27
log
@	* libc/locale/locale.c (lc_ctype_charset): Set to "UTF-8" on Cygwin.
	(lc_message_charset): Ditto.
	(loadlocale): Set charset of the "C" locale to "UTF-8" on Cygwin.
	* libc/stdlib/mbtowc_r.c (__mbtowc): Default to __utf8_mbtowc on
	Cygwin.
	* libc/stdlib/wctomb_r.c (__wctomb): Default to __utf8_wctomb on
	Cygwin.
@
text
@d64 5
d446 8
a453 2
  else if (locale[0] == 'C' && locale[1] == '-')	/* Old newlib style */
	strcpy (charset, locale + 2);
@


1.26
log
@	* libc/locale/locale.c: Drop Cygwin-specific windows.h include.
	(loadlocale): Call __set_charset_from_codepage with 0 codepage.
@
text
@d228 4
d234 1
d436 3
d440 1
@


1.25
log
@
2009-08-25  Andy Koppe  <andy.koppe@@gmail.com>

        * libc/stdlib/sb_charsets.c (__micro_atoi): Allow five-digit codepage
        numbers.
        * libc/locale/locale.c (loadlocale): Set MB_CUR_MAX to 1 for KOI8
        charsets.
        * libc/stdlib/local.h (__cp_conv): Remove incorrect number of codepages.
@
text
@a168 3
#ifdef __CYGWIN__
#include <windows.h>
#endif
d468 1
a468 1
	__set_charset_from_codepage (GetACP (), charset);
@


1.24
log
@
2009-08-24  Corinna Vinschen  <corinna@@vinschen.de>

        * libc/locale/locale.c: Update documentation.
        (loadlocale): Map "KOI8-R" and "KOI8-U" to CP20866 and CP21866.

2009-08-24  Andy Koppe  <andy.koppe@@gmail.com>

        * libc/stdlib/sb_charsets.c (__cp_conv): Add KOI8-R (Russian, CP20866)
        and KOI8-U (Ukrainian, CP21866) to Windows codepage conversion tables.
        * libc/ctype/ctype_cp.h (__ctype_cp): Likewise for ctype tables.
@
text
@d627 1
@


1.23
log
@	* libc/locale/locale.c (loadlocale): Throughout check charset string
	case insensitive and store internal charset string uppercased.  Allow
	"UTF8" additionally to "UTF-8".  Add this change to documentation.
@
text
@d57 1
a57 1
Additionally to the POSIX specifier, five extensions are supported for
d59 4
a62 4
<<"C-UTF-8">>, <<"C-JIS">>, <<"C-EUCJP">>/<<"C-eucJP">>, <<"C-SJIS">>,
<<"C-ISO-8859-x">> with 1 <= x <= 15, or <<"C-CPxxx">> with xxx in [437,
720, 737, 775, 850, 852, 855, 857, 858, 862, 866, 874, 1125, 1250, 1251,
1252, 1253, 1254, 1255, 1256, 1257, 1258].
d65 7
a71 6
<<"UTF-8">>, <<"JIS">>, <<"EUCJP">>/<<"eucJP">>, <<"SJIS">>, <<"ISO-8859-x">>
with 1 <= x <= 15, or <<"CPxxx">> with xxx in [437, 720, 737, 775, 850,
852, 855, 857, 858, 862, 866, 874, 1125, 1250, 1251, 1252, 1253, 1254,
1255, 1256, 1257, 1258].  Charsets are case insensitive.  For instance,
<<"UTF-8">> and <<"utf-8">> are equivalent.  <<"UTF-8">> can also be
written without dash, as in <<"UTF8">> or <<"utf8">>.
d619 18
@


1.22
log
@	* libc/locale/locale.c (loadlocale): Add handling of "@@cjknarrow"
	modifier on _MB_CAPABLE targets.  Add comment to explain.  Improve
	documentation.
@
text
@d68 4
a71 1
1255, 1256, 1257, 1258]. 
d493 2
a494 1
      if (strcmp (charset, "UTF-8"))
d496 1
d504 2
a505 1
      if (strcmp (charset, "JIS"))
d507 1
d516 1
a516 1
      if (!strcmp (charset, "EUCJP") || !strcmp (charset, "eucJP"))
d526 1
a526 1
      else if (!strcmp (charset, "EUCKR") || !strcmp (charset, "eucKR"))
d540 2
a541 1
      if (strcmp (charset, "SJIS"))
d543 1
d551 1
d554 1
a554 1
      if (strncmp (charset, "ISO-8859-", 9))
d556 1
d572 2
a573 1
      if (charset[1] != 'P')
d575 1
d619 2
a620 1
      if (strcmp (charset, "ASCII"))
d622 1
d631 2
a632 1
      if (strcmp (charset, "GBK"))
d634 1
d642 2
a643 1
      if (strcmp (charset, "BIG5") && strcmp (charset, "Big5"))
@


1.21
log
@	* libc/include/locale.h (struct lconv): Add missing members required
	by POSIX.1-2008.
	* libc/locale/locale.c (lconv): Initialize new members to default
	values in "C" locale.
@
text
@d47 22
a68 11
honored unless _MB_CAPABLE is defined in which case POSIX locale strings
are allowed, plus five extensions supported for backward compatibility with
older implementations using newlib: <<"C-UTF-8">>, <<"C-JIS">>,
<<"C-EUCJP">>/<<"C-eucJP">>, <<"C-SJIS">>, <<"C-ISO-8859-x">> with
1 <= x <= 15, or <<"C-CPxxx">> with xxx in [437, 720, 737, 775, 850, 852,
855, 857, 858, 862, 866, 874, 1125, 1250, 1251, 1252, 1253, 1254, 1255, 1256,
1257, 1258].  Even when using POSIX locale strings, the only charsets allowed
are <<"UTF-8">>, <<"JIS">>, <<"EUCJP">>/<<"eucJP">>, <<"SJIS">>,
<<"ISO-8859-x">> with 1 <= x <= 15, or <<"CPxxx">> with xxx in [437, 720,
737, 775, 850, 852, 855, 857, 858, 862, 866, 874, 1125, 1250, 1251, 1252,
1253, 1254, 1255, 1256, 1257, 1258]. 
d75 15
a89 6
If you use <<NULL>> as the <[locale]> argument, <<setlocale>> returns
a pointer to the string representing the current locale (always
<<"C">> in this implementation).  The acceptable values for
<[category]> are defined in `<<locale.h>>' as macros beginning with
<<"LC_">>, but this implementation does not check the values you pass
in the <[category]> argument.
d422 3
d455 5
a459 2
	  strcpy (charset, c + 1);
	  if ((c = strchr (charset, '@@')))
d461 2
a462 1
	    *c = '\0';
d474 11
d647 9
a655 7
         of "ja", "ko", or "zh", assume the use of CJK fonts.  This is
	 stored in lc_ctype_cjk_lang and tested in wcwidth() to figure
	 out the width to return (1 or 2) for the "CJK Ambiguous Width"
	 category of characters. */
      lc_ctype_cjk_lang = (strncmp (locale, "ja", 2) == 0
			   || strncmp (locale, "ko", 2) == 0
			   || strncmp (locale, "zh", 2) == 0);
@


1.20
log
@	* libc/string/wcwidth.c: Optimize for speed.

	* libc/locale/locale.c (lc_ctype_cjk_lang): New static int.
	(loadlocale): In case of setting LC_CTYPE, set lc_ctype_cjk_lang
	to 1 if the language is "jp", "ko", or "zh", to 0 otherwise.
	(__locale_cjk_lang): New function.
	* libc/string/local.h (__locale_cjk_lang): Declare.
	* libc/string/wcwidth.c: Fix comments.
	(__wcwidth): Handle CJK Ambiguous Width characters according
	to setting returned by __locale_cjk_lang.
@
text
@d163 2
@


1.19
log
@	* libc/locale/locale.c (setlocale): Don't build on Cygwin.
@
text
@d207 1
d606 8
d657 6
@


1.18
log
@	* libc/locale/locale.c (loadlocale): Set mbc_max to 3 for EUCJP.
@
text
@d657 1
d665 1
a665 1

@


1.17
log
@	* libc/ctype/Makefile.am: Remove _tolower.c and _toupper.c
	source files.  Add a dependency rule for ctype_o to note
	changes in ctype_iso.h and ctype_cp.h.
	* libc/ctype/Makefile.in: Regenerate.
	* libc/ctype/_tolower.c: Remove file.
	* libc/ctype/_toupper.c: Remove file.
	* libc/ctype/ctype_.c: Make sure ALLOW_NEGATIVE_CTYPE_INDEX
	is always defined on Cygwin.
	(_ctype_b): Don't make `static const' on Cygwin.
	(ctype_iso.h): Include if _MB_EXTENDED_CHARSETS_ISO is set.
	(ctype_cp.h): Include if _MB_EXTENDED_CHARSETS_WINDOWS is set.
	(__ctype_ptr): Drop definition.
	(__ctype_ptr__): De-constify.  Mark as __EXPORT symbol.
	(_ctype_): Add Cygwin-specifc asm define.
	(__set_ctype): New function to set __ctype_ptr__ according to
	current charset.
	* libc/ctype/ctype_cp.h: New file containing Windows codepage
	specific character class tables.
	* libc/ctype/ctype_iso.h: New file containing ISO-8859-x
	specific character class tables.
	* libc/ctype/tolower.c (tolower): Reimplement to support any singlebyte
	charset if one of the extended charsets is enabled.
	* libc/ctype/toupper.c (toupper): Ditto.
	* libc/include/ctype.h (_tolower): Define as macro per POSIX.
	(_toupper): Ditto.
	(__ctype_ptr__): De-constify.
	(toupper): Disable macro on systems supporting extended charsets.
	(tolower): Ditto.
	* libc/include/sys/config.h (__EXPORT): Define empty if not defined.
	* libc/locale/locale.c (__mb_cur_max): Mark as __EXPORT symbol.
	(__set_ctype): Declare unconditionally.
	(loadlocale): Remove __CYGWIN__ guard around __set_ctype call.
@
text
@d471 1
a471 1
	  mbc_max = 2;
@


1.16
log
@	* libc/locale/locale.c (loadlocale): Revert to charset "GBK" instead
	of "GB2312".  Fix documentation accordingly.
@
text
@d152 1
a152 5
#ifdef __CYGWIN__
int __declspec(dllexport) __mb_cur_max = 1;
#else
int __mb_cur_max = 1;
#endif
d376 2
a378 1
#endif /* __CYGWIN__ */
a603 1
#ifdef __CYGWIN__
a605 1
#endif
@


1.15
log
@	* libc/locale/locale.c (loadlocale): Only change __wctomb and __mbtowc
	pointers if category is LC_CTYPE.
@
text
@d62 1
a62 1
<<"GB2312">>, <<"eucKR">>, and <<"Big5">>.
d578 1
a578 1
      if (strcmp (charset, "GB2312"))
@


1.14
log
@	* libc/locale/locale.c (loadlocale): Rename charset "GBK" to
	"GB2312".  Fix documentation accordingly.
@
text
@d399 3
d456 2
a457 2
      __wctomb = __utf8_wctomb;
      __mbtowc = __utf8_mbtowc;
d465 2
a466 2
      __wctomb = __jis_wctomb;
      __mbtowc = __jis_mbtowc;
d476 2
a477 2
	  __wctomb = __eucjp_wctomb;
	  __mbtowc = __eucjp_mbtowc;
d486 2
a487 2
	  __wctomb = __kr_wctomb;
	  __mbtowc = __kr_mbtowc;
d499 2
a500 2
      __wctomb = __sjis_wctomb;
      __mbtowc = __sjis_mbtowc;
d514 2
a515 2
      __wctomb = __iso_wctomb;
      __mbtowc = __iso_mbtowc;
d517 2
a518 2
      __wctomb = __ascii_wctomb;
      __mbtowc = __ascii_mbtowc;
d555 2
a556 2
	  __wctomb = __cp_wctomb;
	  __mbtowc = __cp_mbtowc;
d558 2
a559 2
	  __wctomb = __ascii_wctomb;
	  __mbtowc = __ascii_mbtowc;
d572 2
a573 2
      __wctomb = __ascii_wctomb;
      __mbtowc = __ascii_mbtowc;
d582 2
a583 2
      __wctomb = __gbk_wctomb;
      __mbtowc = __gbk_mbtowc;
d592 2
a593 2
      __wctomb = __big5_wctomb;
      __mbtowc = __big5_mbtowc;
d604 3
d610 1
@


1.13
log
@	* libc/locale/locale.c (loadlocale): Rename charset "CP949" to
	"eucKR".  Fix documentation accordingly.
@
text
@d61 2
a62 2
Under Cygwin, this implementation additionally supports the charsets <<"GBK">>,
<<"eucKR">>, and <<"Big5">>.
d575 1
a575 1
      if (strcmp (charset, "GBK"))
@


1.12
log
@	* libc/locale/locale.c (loadlocale): Allow charset starting with 'e'
	for "eucJP" charset support.
@
text
@d49 9
a57 8
older implementations using newlib: <<"C-UTF-8">>, <<"C-JIS">>, <<"C-EUCJP">>,
<<"C-SJIS">>, <<"C-ISO-8859-x">> with 1 <= x <= 15, or <<"C-CPxxx">> with
xxx in [437, 720, 737, 775, 850, 852, 855, 857, 858, 862, 866, 874, 1125, 1250,
1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258].  Even when using POSIX
locale strings, the only charsets allowed are <<"UTF-8">>, <<"JIS">>,
<<"EUCJP">>, <<"SJIS">>, <<"ISO-8859-x">> with 1 <= x <= 15, or
<<"CPxxx">> with xxx in [437, 720, 737, 775, 850, 852, 855, 857, 858, 862, 866,
874, 1125, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258]. 
d62 1
a62 1
<<"CP949">>, and <<"BIG5">>.
d468 14
a481 4
      if (strcmp (charset, "EUCJP") && strcmp (charset, "eucJP"))
	return NULL;
      strcpy (charset, "EUCJP");
      mbc_max = 2;
d483 2
a484 2
      __wctomb = __eucjp_wctomb;
      __mbtowc = __eucjp_mbtowc;
d486 4
a559 9
#ifdef __CYGWIN__
	case 949:
	  mbc_max = 2;
#ifdef _MB_CAPABLE
	  __wctomb = __kr_wctomb;
	  __mbtowc = __kr_mbtowc;
#endif
	  break;
#endif
@


1.11
log
@	* libc/ctype/iswalpha.c: Handle all wchar_t as unicode on
	_MB_CAPABLE systems.
	* libc/ctype/iswblank.c: Ditto.
	* libc/ctype/iswcntrl.c: Ditto.
	* libc/ctype/iswprint.c: Ditto.
	* libc/ctype/iswpunct.c: Ditto.
	* libc/ctype/iswspace.c: Ditto.
	* libc/ctype/jp2uc.c (__jp2uc): On Cygwin, just return c.
	Explain why.
	* libc/ctype/towlower.c: Ditto.
	* libc/ctype/towupper.c: Ditto.
	* libc/include/sys/config.h: Define _MB_EXTENDED_CHARSETS_ISO
	and _MB_EXTENDED_CHARSETS_WINDOWS if _MB_EXTENDED_CHARSETS_ALL is
	defined.  Define _MB_EXTENDED_CHARSETS_ALL on Cygwin only for now.
	* libc/include/sys/reent.h (struct _reent): Mark _current_category
	and _current_locale as unused.
	* libc/locale/locale.c: Add new charset support to documentation.
	Include ../stdio/local.h from here.
	(lc_ctype_charset): Set to "ASCII" by default.
	(lc_message_charset): Ditto.
	(_setlocale_r): Don't set _current_category and _current_locale.
	(loadlocale): Add Cygwin codepage support.  On _MB_CAPABLE
	systems, set __mbtowc and __wctomb function pointers to function
	corresponding with current charset.  Don't allow non-existant
	ISO-8859-12 charset.  Add support for Windows singlebyte codepages.
	On Cygwin, add support for GBK, CP949, and BIG5.  On Cygwin,
	call __set_ctype() in case the catorgy is LC_CTYPE.  Don't set
	_current_category and _current_locale.
	* libc/stdlib/Makefile.am (GENERAL_SOURCES): Add sb_charsets.c.
	* libc/stdlib/Makefile.in: Regenerate.
	* libc/stdlib/local.h: Add prototype for __locale_charset.
	Add prototypes for __mbtowc and __wctomb pointers.
	Add prototypes for charset-specific _wctomb_r and _mbtowc_r
	functions.
	Declare tables and functions from sb_charsets.c.
	* libc/stdlib/mbtowc_r.c (__mbtowc): Define.  Set to __ascii_mbtowc
	by default.
	(_mbtowc_r): Just call __mbtowc from here.
	(__ascii_mbtowc): New function.
	(__iso_mbtowc): New function.
	(__cp_mbtowc): New function.
	(__utf8_mbtowc): New function.
	(__sjis_mbtowc): New function.  Disable on Cygwin.
	(__eucjp_mbtowc): New function.  Disable on Cygwin.
	(__jis_mbtowc): New function.  Disable on Cygwin.
	* libc/stdlib/sb_charsets.c: New file, adding singlebyte to UTF
	conversion tables for all ISO and CP charsets.
	(__iso_8859_index): New function.
	(__cp_index): New function.
	* libc/stdlib/wctomb_r.c (__wctomb): Define.  Set to __ascii_wctomb
	by default.
	(_wctomb_r): Just call __wctomb from here.
	(__ascii_wctomb): New function.
	(__utf8_wctomb): New function.
	(__sjis_wctomb): New function.  Disable on Cygwin.
	(__eucjp_wctomb): New function.  Disable on Cygwin.
	(__jis_wctomb): New function.  Disable on Cygwin.
	(__iso_wctomb): New function.
	(__cp_wctomb): New function.
@
text
@d466 1
@


1.10
log
@	* libc/locale/locale.c (loadlocale): Fix typo in language and
	territory evaluation.
@
text
@d50 12
a61 5
<<"C-SJIS">>, or <<"C-ISO-8859-x">> with 1 <= x <= 15.  Even when using
POSIX locale strings, the only charsets allowed are <<"UTF-8">>, <<"JIS">>,
<<"EUCJP">>, <<"SJIS">>, or <<"ISO-8859-x">> with 1 <= x <= 15.  (<<"">> is 
also accepted; if given, the settings are read from the corresponding
LC_* environment variables and $LANG according to POSIX rules.
d95 3
d142 5
d208 2
a209 2
static char lc_ctype_charset[ENCODING_LEN + 1] = "ISO-8859-1";
static char lc_message_charset[ENCODING_LEN + 1] = "ISO-8859-1";
a222 2
      p->_current_category = category;  
      p->_current_locale = locale;
d377 5
d403 1
a403 1
    strcpy (charset, "ISO-8859-1");
d435 3
d439 1
d451 4
d460 4
d466 1
a466 1
      if (strcmp (charset, "EUCJP"))
d468 1
d470 4
d479 4
d485 2
a486 2
    default:
      /* Must be exactly one of ISO-8859-1, [...] ISO-8859-15. */
d489 70
a558 2
      val = strtol (charset + 9, &end, 10);
      if (val < 1 || val > 15 || *end)
d561 14
d576 13
d594 3
a599 2
  p->_current_category = category;  
  p->_current_locale = locale;
@


1.9
log
@	* libc/locale/locale.c (_setlocale_r): New implementation based on
	FreeBSD's setlocale.
	(currentlocale): New helper function.
	(loadlocale): Ditto.
	(__locale_charset): New function.
	(__locale_msgcharset): Rename from __locale_charset.
	* libc/ctype/local.h (__lc_ctype): Remove declaration.
	(__locale_charset): Declare.
	* libc/ctype/iswalpha.c (iswalpha): Call __locale_charset instead of
	using __lc_ctype directly.  Only compare against the charset alone.
	* libc/ctype/iswblank.c (iswblank): Ditto.
	* libc/ctype/iswcntrl.c (iswcntrl): Ditto.
	* libc/ctype/iswprint.c (iswprint): Ditto.
	* libc/ctype/iswpunct.c (iswpunct): Ditto.
	* libc/ctype/iswspace.c (iswspace): Ditto.
	* libc/ctype/towlower.c (towlower): Ditto.
	* libc/ctype/towupper.c (towupper): Ditto.
	* libc/stdlib/mbtowc_r.c (_mbtowc_r): Ditto.
	* libc/stdlib/wctomb_r.c (_wctomb_r): Ditto.
	* libc/sys/linux/intl/loadmsgcat.c (_nl_init_domain_conv): Call
	__locale_msgcharset instead of __locale_charset.
@
text
@d394 2
a395 2
      if (c[0] <= 'a' || c[0] >= 'z'
	  || c[1] <= 'a' || c[1] >= 'z')
d402 2
a403 2
	  if (c[0] <= 'A' || c[0] >= 'Z'
	      || c[1] <= 'A' || c[1] >= 'Z')
@


1.8
log
@
2004-04-23  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * configure.in: Define _MB_CAPABLE if mb supported.
        * configure: Regenerated.
        * configure.host: Remove manual setting of MB_CAPABLE compiler
        flag.
        * newlib.hin: Add _MB_CAPABLE flag.
        * libc/ctype/iswalpha.c, libc/ctype/iswblank.c: Include <newlib.h>
        and check for _MB_CAPABLE flag instead of MB_CAPABLE.
        * libc/ctype/iswcntrl.c, libc/ctype/iswprint.c: Ditto.
        * libc/ctype/iswpunct.c, libc/ctype/iswspace.c: Ditto.
        * libc/ctype/jp2uc.c: Ditto.
        * libc/ctype/towlower.c, libc/ctype/towupper.c: Ditto.
        * libc/locale/locale.c: Ditto
        * libc/machine/powerpc/vfscanf.c: Ditto
        * libc/stdio/vfprintf.c, libc/stdio/vfscanf.c: Ditto
        * libc/stdlib/mblen.c: Ditto
        * libc/stdlib/mblen_r.c, libc/stdlib/mbrlen.c: Ditto
        * libc/stdlib/mbrtowc.c, libc/stdlib/mbsrtowcs.c: Ditto
        * libc/stdlib/mbstowcs.c, libc/stdlib/mbtowc.c: Ditto
        * libc/stdlib/mbtowc_r.c, libc/stdlib/wcrtomb.c: Ditto
        * libc/stdlib/wcsrtombs.c, libc/stdlib/wcstombs.c: Ditto
        * libc/stdlib/wctomb.c, libc/sys/linux/intl/dcigettext.c: Ditto
        * libc/sys/linux/intl/explodename.c: Ditto
        * libc/sys/linux/intl/finddomain.c: Ditto
        * libc/sys/linux/intl/l10nflist.c: Ditto
        * libc/sys/linux/intl/loadmsgcat.c: Ditto
        * libc/sys/linux/intl/localealias.c: Ditto
@
text
@d45 10
a54 7
This is a minimal implementation, supporting only the required <<"C">>
value for <[locale]>; strings representing other locales are not
honored unless _MB_CAPABLE is defined in which case three new
extensions are allowed for LC_CTYPE or LC_MESSAGES only: <<"C-JIS">>, 
<<"C-EUCJP">>, <<"C-SJIS">>, or <<"C-ISO-8859-1">>.  (<<"">> is 
also accepted; it represents the default locale
for an implementation, here equivalent to <<"C">>.)
d72 7
a78 3
<<setlocale>> returns either a pointer to a string naming the locale
currently in effect (always <<"C">> for this implementation, or, if
the locale request cannot be honored, <<NULL>>.
d91 1
d93 30
a122 2
 * setlocale, localeconv : internationalize your locale.
 *                         (Only "C" or null supported).
d126 1
d131 4
d153 13
d167 12
a178 1
char * _EXFUN(__locale_charset,(_VOID));
d180 15
a194 2
static char *charset = "ISO-8859-1";
char __lc_ctype[12] = "C";
d205 3
a207 2
      if (strcmp (locale, "C") && strcmp (locale, ""))
        return 0;
d213 11
a223 3
  static char last_lc_ctype[12] = "C";
  static char lc_messages[12] = "C";
  static char last_lc_messages[12] = "C";
d225 10
a234 1
  if (locale)
d236 13
a248 14
      char *locale_name = (char *)locale;
      if (category != LC_CTYPE && category != LC_MESSAGES) 
        { 
          if (strcmp (locale, "C") && strcmp (locale, ""))
            return 0;
          if (category == LC_ALL)
            {
              strcpy (last_lc_ctype, __lc_ctype);
              strcpy (__lc_ctype, "C");
              strcpy (last_lc_messages, lc_messages);
              strcpy (lc_messages, "C");
              __mb_cur_max = 1;
            }
        }
d250 18
a267 102
        {
          if (locale[0] == 'C' && locale[1] == '-')
            {
              switch (locale[2])
                {
                case 'U':
                  if (strcmp (locale, "C-UTF-8"))
                    return 0;
                break;
                case 'J':
                  if (strcmp (locale, "C-JIS"))
                    return 0;
                break;
                case 'E':
                  if (strcmp (locale, "C-EUCJP"))
                    return 0;
                break;
                case 'S':
                  if (strcmp (locale, "C-SJIS"))
                    return 0;
                break;
                case 'I':
                  if (strcmp (locale, "C-ISO-8859-1"))
                    return 0;
                break;
                default:
                  return 0;
                }
            }
          else 
            {
              if (strcmp (locale, "C") && strcmp (locale, ""))
                return 0;
              locale_name = "C"; /* C is always the default locale */
            }

          if (category == LC_CTYPE)
            {
              strcpy (last_lc_ctype, __lc_ctype);
              strcpy (__lc_ctype, locale_name);

              __mb_cur_max = 1;
              if (locale[1] == '-')
                {
                  switch (locale[2])
                    {
                    case 'U':
                      __mb_cur_max = 6;
                    break;
                    case 'J':
                      __mb_cur_max = 8;
                    break;
                    case 'E':
                      __mb_cur_max = 2;
                    break;
                    case 'S':
                      __mb_cur_max = 2;
                    break;
                    case 'I':
                    default:
                      __mb_cur_max = 1;
                    }
                }
            }
          else
            {
              strcpy (last_lc_messages, lc_messages);
              strcpy (lc_messages, locale_name);

              charset = "ISO-8859-1";
              if (locale[1] == '-')
                {
                  switch (locale[2])
                    {
                    case 'U':
                      charset = "UTF-8";
                    break;
                    case 'J':
                      charset = "JIS";
                    break;
                    case 'E':
                      charset = "EUCJP";
                    break;
                    case 'S':
                      charset = "SJIS";
                    break;
                    case 'I':
                      charset = "ISO-8859-1";
                    break;
                    default:
                      return 0;
                    }
                }
            }
        }
      p->_current_category = category;  
      p->_current_locale = locale;

      if (category == LC_CTYPE)
        return last_lc_ctype;
      else if (category == LC_MESSAGES)
        return last_lc_messages;
d271 66
a336 4
      if (category == LC_CTYPE)
        return __lc_ctype;
      else if (category == LC_MESSAGES)
        return lc_messages;
d338 23
a360 2
 
  return "C";
d362 18
d381 108
d490 1
d495 7
a501 1
  return charset;
@


1.7
log
@
2003-10-20  Bob Wilson  <bob.wilson@@acm.org>

	* libc/locale/locale.c: Use double quotes in code.
	* libc/locale/locale.tex: Likewise.
	* libc/libc.texinfo: Hyphenate "floating-point".
	* libc/machine/necv70/necv70.tex: Likewise.
	* libc/stdio/sprintf.c: Likewise.
	* libc/stdio/sscanf.c: Likewise.
	* libc/stdlib/atof.c: Likewise.
	* libc/stdlib/ldtoa.c: Fix comment typo.
	* libc/stdlib/div.c: Use @@ifnottex instead of @@ifinfo.
	* libc/stdlib/ldiv.c: Likewise.
	* libm/common/s_expm1.c: Likewise.
	* libm/common/s_ilogb.c: Hyphenate "floating-point".  Use "nonzero".
	* libm/common/s_infinity: Hyphenate "double- and single-precision".
	* libm/common/s_nan.c: Likewise.  Also correct the FUNCTION summary.
	* libm/common/s_nextafter.c: Fix typo.  Hyphenate "double-precision"
	and "floating-point".
	* libm/common/s_scalbn.c: Correct the FUNCTION summary.
	* libm/math/e_pow.c: Fix comment typo.
	* libm/math/math.tex: Hyphenate "single-precision" and "floating-point".
	* libm/math/s_asinh.c: Use @@ifnottex instead of @@ifinfo.
	* libm/math/s_atan.c: Likewise.
	* libm/math/s_frexp.c: Likewise.  Also use "nonzero".
	* libm/math/s_isnan.c: Hyphenate "single-precision" and
	"floating-point".  Use "nonzero".
	* libm/math/s_ldexp.c: Use @@ifnottex instead of @@ifinfo.
	* libm/math/w_acos.c: Likewise.
	* libm/math/w_acosh.c: Likewise.
	* libm/math/w_asin.c: Likewise.
	* libm/math/w_atan2.c: Likewise.
	* libm/math/w_atanh.c: Likewise.
	* libm/math/w_cosh.c: Likewise.
	* libm/math/w_exp.c: Likewise.
	* libm/math/w_exp2.c: Likewise.  Add missing @@end and missing @@tex
	version of 2^x in the description.
	* libm/math/w_fmod.c: Use @@ifnottex instead of @@ifinfo.
	* libm/math/w_gamma.c: Likewise.
	* libm/math/w_hypot.c: Likewise.
	* libm/math/w_j0.c: Likewise.
	* libm/math/w_sinh.c: Likewise.
	* libm/math/w_pow.c: Replace "exp1.0nt" with "exponent".
	* libm/mathfp/mathfp.tex: Hyphenate "single-precision" and
	"floating-point".
	* libm/mathfp/e_acosh.c: Use @@ifnottex instead of @@ifinfo.
	* libm/mathfp/e_atanh.c: Likewise.
	* libm/mathfp/e_hypot.c: Likewise.
	* libm/mathfp/er_lgamma.c: Likewise.
	* libm/mathfp/s_acos.c: Likewise.
	* libm/mathfp/s_asine.c: Likewise.
	* libm/mathfp/s_asinh.c: Likewise.
	* libm/mathfp/s_atan.c: Likewise.
	* libm/mathfp/s_atan2.c: Likewise.
	* libm/mathfp/s_atangent.c: Likewise.
	* libm/mathfp/s_cosh.c: Likewise.
	* libm/mathfp/s_exp.c: Likewise.
	* libm/mathfp/s_fmod.c: Likewise.
	* libm/mathfp/s_frexp.c: Likewise.  Also use "nonzero".
	* libm/mathfp/s_isnan.c: Hyphenate "single-precision" and
	"floating-point".  Use "nonzero".
	* libm/math/s_pow.c: Replace "exp1.0nt" with "exponent".
	* libm/mathfp/s_ldexp.c: Use @@ifnottex instead of @@ifinfo.
	* libm/mathfp/s_sineh.c: Likewise.
	* libm/mathfp/w_jn.c: Likewise.
@
text
@d47 1
a47 1
honored unless MB_CAPABLE is defined in which case three new
d89 1
d124 1
a124 1
#ifndef MB_CAPABLE
@


1.6
log
@
2002-09-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/ctype/Makefile.am: Add new files.
        * libc/ctype/Makefile.in: Regenerated.
        * libc/ctype/ctype.tex: Add new iswxxxx, towxxxx, wctype,
        and wctrans functions to documentation index.
        * libc/ctype/iswalnum.c: New file.
        * libc/ctype/iswalpha.c: Ditto.
        * libc/ctype/iswblank.c: Ditto.
        * libc/ctype/iswcntrl.c: Ditto.
        * libc/ctype/iswctype.c: Ditto.
        * libc/ctype/iswdigit.c: Ditto.
        * libc/ctype/iswgraph.c: Ditto.
        * libc/ctype/iswlower.c: Ditto.
        * libc/ctype/iswprint.c: Ditto.
        * libc/ctype/iswpunct.c: Ditto.
        * libc/ctype/iswspace.c: Ditto.
        * libc/ctype/iswupper.c: Ditto.
        * libc/ctype/iswxdigit.c: Ditto.
        * libc/ctype/jp2uc.c: Ditto.
        * libc/ctype/jp2uc.h: Ditto.
        * libc/ctype/local.h: Ditto.
        * libc/ctype/towctrans.c: Ditto.
        * libc/ctype/towlower.c: Ditto.
        * libc/ctype/towupper.c: Ditto.
        * libc/ctype/utf8alpha.h: Ditto.
        * libc/ctype/utf8print.h: Ditto.
        * libc/ctype/utf8punct.h: Ditto.
        * libc/ctype/wctrans.c: Ditto.
        * libc/ctype/wctype.c: Ditto.
        * libc/locale/locale.c (__lc_ctype): New external array to
        replace static lc_ctype array.
        * libc/stdlib/mbtowc_r.c: Use __lc_ctype to check current lc_ctype
        rather than reentrancy structure's _current_locale field.
        * libc/stdlib/wctomb_r.c: Ditto.
@
text
@d45 1
a45 1
This is a minimal implementation, supporting only the required <<``C''>>
d48 2
a49 2
extensions are allowed for LC_CTYPE or LC_MESSAGES only: <<''C-JIS''>>, 
<<''C-EUCJP''>>, <<''C-SJIS''>>, or <<''C-ISO-8859-1''>>.  (<<``''>> is 
d51 1
a51 1
for an implementation, here equivalent to <<``C''>>.)
d55 1
a55 1
<<``C''>> in this implementation).  The acceptable values for
d70 1
a70 1
currently in effect (always <<``C''>> for this implementation, or, if
@


1.5
log
@
2002-08-29  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/locale/locale.c (_setlocale_r)[MB_CAPABLE]: Fix so
        default locale "" is accepted for LC_CTYPE or LC_MESSAGES
        and is treated as if "C" was specified.
@
text
@d115 1
a132 1
  static char lc_ctype[12] = "C";
d146 2
a147 2
              strcpy (last_lc_ctype, lc_ctype);
              strcpy (lc_ctype, "C");
d192 2
a193 2
              strcpy (last_lc_ctype, lc_ctype);
              strcpy (lc_ctype, locale_name);
d260 1
a260 1
        return lc_ctype;
@


1.4
log
@
2002-08-17  Jeff Johnston  <jjohnstn@@redhat.com>

        *  Makefile.am: Move cmath stuff into libc/sys/linux.
        *  Makefile.in: Regenerated.
        *  configure.host: Default -DMB_CAPABLE for x86-linux.
        *  libc/include/reent.h: Define _sbrk to take signed int argument.
        *  libc/include/sys/unistd.h: Ditto for _sbrk_r and sbrk.
        *  libc/locale/locale.c[MB_CAPABLE]: Add LC_MESSAGES support and
        make locale name checking more efficient.  Also allow "C-ISO-8859-1"
        locale for LC_CTYPE and LC_MESSAGES.
        *  libc/reent/sbrkr.c: Change prototype to take ptrdiff_t.
        *  libc/sys/linux/brk.c: Change sbrk prototype.
        *  libc/sys/linux/include/time.h: Remove Cygwin stuff and
        include <sys/features.h>.
        (CLOCK_THREAD_CPUTIME): Renamed to CLOCK_THREAD_CPUTIME_ID.
        (CLOCK_PROCESS_CPUTIME): Renamed to CLOCK_PROCESS_CPUTIME_ID.
        *  libc/sys/linux/sys/cdefs.h: Replace with glibc sys/cdefs.h
        with a few local additions.
        *  libc/sys/linux/sys/features.h: New file.
        *  libc/sys/linux/sys/unistd.h: Change _sbrk_r and sbrk prototypes
        to take signed argument.
        *  libc/syscalls/syssbrk.c: Change sbrk, _sbrk_r, and _sbrk
        prototypes to take signed size argument.
@
text
@d139 1
d147 1
a147 1
              strcpy (lc_ctype, locale);
d149 1
a149 1
              strcpy (lc_messages, locale);
d155 1
a155 3
          if (locale[0] != 'C')
            return 0; 
          if (locale[1] == '-')
d182 7
a188 1
            }   
d193 1
a193 1
              strcpy (lc_ctype, locale);
d221 1
a221 1
              strcpy (lc_messages, locale);
@


1.3
log
@	* Makefile.am (check-DEJAGNU): New target.
	(site.exp): Likewise.
	* acinclude.m4 (NEWLIB_CONFIGURE): Replace AC_CANONICAL_HOST
	with AC_CANONICAL_SYSTEM.  Remove AC_CANONICAL_BUILD.
	* libc/locale/locale.c (_setlocale_r): Add UTF-8 support.
	* libc/stdlib/mbtowc_r.c (_mbtowc_r): Likewise.
	* libc/stdlib/wctomb_r.c (_wctomb_r): Likewise.
	* testsuite: New directory.
	* testsuite/config: Likewise.
	* testsuite/lib: Likewise.
	* testsuite/newlib.locale: Likewise.
	* testsuite/newlib.string: Likewise.
	* testsuite/config/default.exp: New file.
	* testsuite/lib/checkoutput.exp: New file.
	* testsuite/lib/newlib.exp: New file.
	* testsuite/lib/passfail.exp: New file.
	* testsuite/newlib.locale/UTF-8.c: New file.
	* testsuite/newlib.locale/UTF-8.exp: New file.
	* testsuite/newlib.locale/locale.exp: New file.
	* testsuite/newlib.string/string.exp: New file.
	* testsuite/newlib.string/tstring.c: New file.
@
text
@d48 3
a50 2
extensions are allowed for LC_CTYPE only: <<''C-JIS''>>, <<''C-EUCJP''>>,
and <<''C-SJIS''>>.  (<<``''>> is also accepted; it represents the default locale
d100 4
d112 4
d132 4
a135 2
  static char lc_ctype[8] = "C";
  static char last_lc_ctype[8] = "C";
d139 1
a139 1
      if (category != LC_CTYPE) 
d147 2
d153 31
a183 6
        { 
          if (strcmp (locale, "C") && strcmp (locale, "") &&
              strcmp (locale, "C") && strcmp (locale, "C-JIS") && 
              strcmp (locale, "C-EUCJP") && strcmp (locale, "C-SJIS") &&
              strcmp (locale, "UTF-8"))
            return 0;
d185 4
a188 2
          strcpy (last_lc_ctype, lc_ctype);
          strcpy (lc_ctype, locale);
d190 23
a212 6
          if (!strcmp (locale, "UTF-8"))
            __mb_cur_max = 6;
          else if (!strcmp (locale, "C-JIS"))
            __mb_cur_max = 8;
          else if (strlen (locale) > 1)
            __mb_cur_max = 2;
d214 29
a242 1
            __mb_cur_max = 1; 
d249 2
d256 2
d265 5
@


1.2
log
@
2000-08-23  Werner Almesberger  <Werner.Almesberger@@epfl.ch>

        * libc/stdio/stdio.c (__swrite): declare "oldmode" only if it's
        used later (ifdef __SCLE)
        * libc/stdio/vfscanf.c (__svfscanf): declare "state" only if it's
        used later (ifdef MB_CAPABLE)
        * libc/string/memset.c (memset): removed unused variables "count"
        and "unaligned_addr"
        * libc/locale/locale.c (_setlocale_r): declare "lc_ctype" and
        "last_lc_ctype" only of they're used later (ifdef MB_CAPABLE)
        * libc/unix/getpwent.c (getpwnam): removed unused variables "uid"
        and "gid"
@
text
@d143 2
a144 1
              strcmp (locale, "C-EUCJP") && strcmp (locale, "C-SJIS"))
d150 3
a152 1
          if (!strcmp (locale, "C-JIS"))
@


1.1
log
@Initial revision
@
text
@a112 3
  static char lc_ctype[8] = "C";
  static char last_lc_ctype[8] = "C";

d123 3
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
