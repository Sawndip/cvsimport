head	1.23;
access;
symbols
	cygwin-1_7_35-release:1.23
	cygwin-1_7_34-release:1.23
	newlib-2_2_0:1.23.0.2
	cygwin-1_7_33-release:1.23
	cygwin-1_7_32-release:1.22
	cygwin-1_7_31-release:1.22
	cygwin-1_7_30-release:1.22
	cygwin-1_7_29-release:1.22
	cygwin-1_7_28-release:1.22
	newlib-2_1_0:1.22
	cygwin-1_7_27-release:1.22
	cygwin-1_7_26-release:1.22
	cygwin-1_7_25-release:1.21
	cygwin-1_7_24-release:1.21
	cygwin-1_7_23-release:1.21
	cygwin-1_7_22-release:1.21
	cygwin-1_7_21-release:1.21
	cygwin-1_7_20-release:1.20
	cygwin-1_7_19-release:1.20
	cygwin-64bit-postmerge:1.19
	cygwin-64bit-premerge-branch:1.19.0.2
	cygwin-64bit-premerge:1.19
	cygwin-1_7_18-release:1.19
	newlib-2_0_0:1.19
	cygwin-1_7_17-release:1.18
	cygwin-64bit-branch:1.18.0.2
	cygwin-1_7_16-release:1.18
	cygwin-1_7_15-release:1.18
	cygwin-1_7_14_2-release:1.18
	cygwin-1_7_14-release:1.18
	cygwin-1_7_12-release:1.18
	cygwin-1_7_11-release:1.18
	cygwin-1_7_10-release:1.18
	newlib-1_20_0:1.18
	cygwin-1_7_9-release:1.17
	cygwin-1_7_8-release:1.17
	newlib-1_19_0:1.17
	cygwin-1_7_7-release:1.16
	cygwin-1_7_5-release:1.16
	cygwin-1_7_4-release:1.16
	cygwin-1_7_3-release:1.16
	cygwin-1_7_2-release:1.16
	newlib-1_18_0:1.16
	cygwin-1_7_1-release:1.16
	newlib-1_17_0-arc:1.12.0.2
	binutils-arc-20080908-branch:1.11.0.2
	binutils-arc-20080908-branchpoint:1.11
	newlib-1_17_0:1.12
	newlib-1_16_0:1.9
	newlib-1_15_0:1.8
	newlib-csl-coldfire-4_1-32:1.6
	newlib-csl-sourcerygxx-4_1-32:1.6
	newlib-csl-innovasic-fido-3_4_4-33:1.6
	newlib-csl-coldfire-4_1-30:1.6
	newlib-csl-sourcerygxx-4_1-30:1.6
	newlib-csl-coldfire-4_1-28:1.6
	newlib-csl-sourcerygxx-4_1-28:1.6
	newlib-csl-arm-2006q3-27:1.6
	newlib-csl-sourcerygxx-4_1-27:1.6
	newlib-csl-arm-2006q3-26:1.6
	newlib-csl-sourcerygxx-4_1-26:1.6
	newlib-csl-sourcerygxx-4_1-24:1.6
	newlib-csl-sourcerygxx-4_1-23:1.6
	newlib-csl-sourcerygxx-4_1-21:1.6
	newlib-csl-arm-2006q3-21:1.6
	newlib-csl-arm-2006q3-19:1.6
	newlib-csl-sourcerygxx-4_1-19:1.6
	newlib-csl-sourcerygxx-4_1-18:1.6
	newlib-csl-sourcerygxx-3_4_4-25:1.8
	newlib-csl-sourcerygxx-4_1-17:1.6
	cr-0x5f1:1.8.0.2
	newlib-csl-sourcerygxx-4_1-14:1.6
	newlib-csl-sourcerygxx-4_1-13:1.6
	newlib-csl-sourcerygxx-4_1-12:1.6
	newlib-csl-sourcerygxx-4_1-9:1.6
	newlib-csl-sourcerygxx-4_1-8:1.6
	newlib-csl-sourcerygxx-4_1-7:1.6
	newlib-csl-arm-2006q1-6:1.6
	newlib-csl-sourcerygxx-4_1-6:1.6
	newlib-csl-sourcerygxx-4_1-5:1.6
	newlib-csl-sourcerygxx-4_1-4:1.6
	newlib-autotools-branch:1.6.0.4
	newlib-csl-20060320-branch:1.6.0.2
	newlib-csl-20060320-branchpoint:1.6
	newlib-1_14_0:1.6
	newlib-csl-arm-2005-q1b:1.6
	newlib-csl-arm-2005-q1a:1.6
	newlib-1_13_0:1.4
	csl-arm-2004-q3:1.4
	csl-arm-2004-q1a:1.4
	csl-arm-2004-q1:1.4
	newlib-1_12_0:1.4
	csl-arm-2003-q4:1.4
	w32api-2_2:1.4
	mingw-runtime-2_4:1.4
	newlib-1_11_0:1.4
	cygnus_cvs_20020108_pre:1.3
	newlib-1_10_0:1.3
	newlib-1_9_0:1.2
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.23
date	2014.11.12.09.10.22;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.18.17.26.51;	author joel;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.10.15.27.43;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.24.10.21.16;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2012.12.19.10.16.00;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2011.05.16.13.34.06;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.07.21.26.45;	author jjohnstn;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.03.16.11.27;	author jjohnstn;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.16.17.44.20;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.26.10.04.40;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.24.10.13.27;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.27.20.45.37;	author jjohnstn;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2008.06.25.01.45.02;	author hp;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.21.17.14.14;	author ericb;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.31.21.21.27;	author jjohnstn;	state Exp;
branches;
next	1.8;

1.8
date	2006.07.05.16.18.30;	author jjohnstn;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2006.06.22.17.59.52;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.01.09.54.19;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.06.23.31.56;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.06.18.58.51;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.20.22.50.51;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.17.17.10.17;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.48;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.12.2.1
date	2009.09.10.01.29.08;	author amylaar;	state Exp;
branches;
next	;

1.8.2.1
date	2008.02.22.12.36.51;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.39.48;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.23
log
@	* libc/stdlib/strtod.c (sulp): Cast to int32_t to avoid overflow.
	* libc/time/gmtime_r.c (DAYS_PER_*_YEARS): Convert to long constants
	to avoid overflow.
@
text
@/*
FUNCTION
        <<strtod>>, <<strtof>>---string to double or float

INDEX
	strtod
INDEX
	_strtod_r
INDEX
	strtof

ANSI_SYNOPSIS
        #include <stdlib.h>
        double strtod(const char *restrict <[str]>, char **restrict <[tail]>);
        float strtof(const char *restrict <[str]>, char **restrict <[tail]>);

        double _strtod_r(void *<[reent]>,
                         const char *restrict <[str]>, char **restrict <[tail]>);

TRAD_SYNOPSIS
        #include <stdlib.h>
        double strtod(<[str]>,<[tail]>)
        char *<[str]>;
        char **<[tail]>;

        float strtof(<[str]>,<[tail]>)
        char *<[str]>;
        char **<[tail]>;

        double _strtod_r(<[reent]>,<[str]>,<[tail]>)
	char *<[reent]>;
        char *<[str]>;
        char **<[tail]>;

DESCRIPTION
	The function <<strtod>> parses the character string <[str]>,
	producing a substring which can be converted to a double
	value.  The substring converted is the longest initial
	subsequence of <[str]>, beginning with the first
	non-whitespace character, that has one of these formats:
	.[+|-]<[digits]>[.[<[digits]>]][(e|E)[+|-]<[digits]>]
	.[+|-].<[digits]>[(e|E)[+|-]<[digits]>]
	.[+|-](i|I)(n|N)(f|F)[(i|I)(n|N)(i|I)(t|T)(y|Y)]
	.[+|-](n|N)(a|A)(n|N)[<(>[<[hexdigits]>]<)>]
	.[+|-]0(x|X)<[hexdigits]>[.[<[hexdigits]>]][(p|P)[+|-]<[digits]>]
	.[+|-]0(x|X).<[hexdigits]>[(p|P)[+|-]<[digits]>]
	The substring contains no characters if <[str]> is empty, consists
	entirely of whitespace, or if the first non-whitespace
	character is something other than <<+>>, <<->>, <<.>>, or a
	digit, and cannot be parsed as infinity or NaN. If the platform
	does not support NaN, then NaN is treated as an empty substring.
	If the substring is empty, no conversion is done, and
	the value of <[str]> is stored in <<*<[tail]>>>.  Otherwise,
	the substring is converted, and a pointer to the final string
	(which will contain at least the terminating null character of
	<[str]>) is stored in <<*<[tail]>>>.  If you want no
	assignment to <<*<[tail]>>>, pass a null pointer as <[tail]>.
	<<strtof>> is identical to <<strtod>> except for its return type.

	This implementation returns the nearest machine number to the
	input decimal string.  Ties are broken by using the IEEE
	round-even rule.  However, <<strtof>> is currently subject to
	double rounding errors.

	The alternate function <<_strtod_r>> is a reentrant version.
	The extra argument <[reent]> is a pointer to a reentrancy structure.

RETURNS
	<<strtod>> returns the converted substring value, if any.  If
	no conversion could be performed, 0 is returned.  If the
	correct value is out of the range of representable values,
	plus or minus <<HUGE_VAL>> is returned, and <<ERANGE>> is
	stored in errno. If the correct value would cause underflow, 0
	is returned and <<ERANGE>> is stored in errno.

Supporting OS subroutines required: <<close>>, <<fstat>>, <<isatty>>,
<<lseek>>, <<read>>, <<sbrk>>, <<write>>.
*/

/****************************************************************

The author of this software is David M. Gay.

Copyright (C) 1998-2001 by Lucent Technologies
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name of Lucent or any of its entities
not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.

****************************************************************/

/* Please send bug reports to David M. Gay (dmg at acm dot org,
 * with " at " changed at "@@" and " dot " changed to ".").	*/

/* Original file gdtoa-strtod.c Modified 06-21-2006 by Jeff Johnston to work within newlib.  */

#include <_ansi.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include "mprec.h"
#include "gdtoa.h"
#include "gd_qnan.h"

/* #ifndef NO_FENV_H */
/* #include <fenv.h> */
/* #endif */

#include "locale.h"

#ifdef IEEE_Arith
#ifndef NO_IEEE_Scale
#define Avoid_Underflow
#undef tinytens
/* The factor of 2^106 in tinytens[4] helps us avoid setting the underflow */
/* flag unnecessarily.  It leads to a song and dance at the end of strtod. */
static _CONST double tinytens[] = { 1e-16, 1e-32,
#ifdef _DOUBLE_IS_32BITS
				    0.0, 0.0, 0.0
#else
				    1e-64, 1e-128,
				    9007199254740992. * 9007199254740992.e-256
#endif
				  };

#endif
#endif

#ifdef Honor_FLT_ROUNDS
#define Rounding rounding
#undef Check_FLT_ROUNDS
#define Check_FLT_ROUNDS
#else
#define Rounding Flt_Rounds
#endif

#ifdef Avoid_Underflow /*{*/
 static double
_DEFUN (sulp, (x, scale),
       	U x _AND
	int scale)
{
        U u;
        double rv;
        int i;

        rv = ulp(dval(x));
        if (!scale || (i = 2*P + 1 - ((dword0(x) & Exp_mask) >> Exp_shift)) <= 0)
                return rv; /* Is there an example where i <= 0 ? */
        dword0(u) = Exp_1 + ((__int32_t)i << Exp_shift);
#ifndef _DOUBLE_IS_32BITS
        dword1(u) = 0;
#endif
        return rv * u.d;
        }
#endif /*}*/


#ifndef NO_HEX_FP

static void
_DEFUN (ULtod, (L, bits, exp, k),
	__ULong *L _AND
	__ULong *bits _AND
	Long exp _AND
	int k)
{
	switch(k & STRTOG_Retmask) {
	  case STRTOG_NoNumber:
	  case STRTOG_Zero:
		L[0] = L[1] = 0;
		break;

	  case STRTOG_Denormal:
		L[_1] = bits[0];
		L[_0] = bits[1];
		break;

	  case STRTOG_Normal:
	  case STRTOG_NaNbits:
		L[_1] = bits[0];
		L[_0] = (bits[1] & ~0x100000) | ((exp + 0x3ff + 52) << 20);
		break;

	  case STRTOG_Infinite:
		L[_0] = 0x7ff00000;
		L[_1] = 0;
		break;

	  case STRTOG_NaN:
		L[_0] = 0x7fffffff;
		L[_1] = (__ULong)-1;
	  }
	if (k & STRTOG_Neg)
		L[_0] |= 0x80000000L;
}
#endif /* !NO_HEX_FP */

#ifdef INFNAN_CHECK
static int
_DEFUN (match, (sp, t),
	_CONST char **sp _AND
	char *t)
{
	int c, d;
	_CONST char *s = *sp;

	while( (d = *t++) !=0) {
		if ((c = *++s) >= 'A' && c <= 'Z')
			c += 'a' - 'A';
		if (c != d)
			return 0;
		}
	*sp = s + 1;
	return 1;
}
#endif /* INFNAN_CHECK */


double
_DEFUN (_strtod_r, (ptr, s00, se),
	struct _reent *ptr _AND
	_CONST char *__restrict s00 _AND
	char **__restrict se)
{
#ifdef Avoid_Underflow
	int scale;
#endif
	int bb2, bb5, bbe, bd2, bd5, bbbits, bs2, c, decpt, dsign,
		 e, e1, esign, i, j, k, nd, nd0, nf, nz, nz0, sign;
	_CONST char *s, *s0, *s1;
	double aadj, adj;
	U aadj1, rv, rv0;
	Long L;
	__ULong y, z;
	_Bigint *bb = NULL, *bb1, *bd = NULL, *bd0, *bs = NULL, *delta = NULL;
#ifdef Avoid_Underflow
	__ULong Lsb, Lsb1;
#endif
#ifdef SET_INEXACT
	int inexact, oldinexact;
#endif
#ifdef Honor_FLT_ROUNDS
	int rounding;
#endif

	delta = bs = bd = NULL;
	sign = nz0 = nz = decpt = 0;
	dval(rv) = 0.;
	for(s = s00;;s++) switch(*s) {
		case '-':
			sign = 1;
			/* no break */
		case '+':
			if (*++s)
				goto break2;
			/* no break */
		case 0:
			goto ret0;
		case '\t':
		case '\n':
		case '\v':
		case '\f':
		case '\r':
		case ' ':
			continue;
		default:
			goto break2;
		}
 break2:
	if (*s == '0') {
#ifndef NO_HEX_FP
		{
		static _CONST FPI fpi = { 53, 1-1023-53+1, 2046-1023-53+1, 1, SI };
		Long exp;
		__ULong bits[2];
		switch(s[1]) {
		  case 'x':
		  case 'X':
			/* If the number is not hex, then the parse of
                           0 is still valid.  */
			s00 = s + 1;
			{
#if defined(FE_DOWNWARD) && defined(FE_TONEAREST) && defined(FE_TOWARDZERO) && defined(FE_UPWARD)
			FPI fpi1 = fpi;
			switch(fegetround()) {
			  case FE_TOWARDZERO:	fpi1.rounding = 0; break;
			  case FE_UPWARD:	fpi1.rounding = 2; break;
			  case FE_DOWNWARD:	fpi1.rounding = 3;
			  }
#else
#define fpi1 fpi
#endif
			switch((i = gethex(ptr, &s, &fpi1, &exp, &bb, sign)) & STRTOG_Retmask) {
			  case STRTOG_NoNumber:
				s = s00;
				sign = 0;
				/* FALLTHROUGH */
			  case STRTOG_Zero:
				break;
			  default:
				if (bb) {
					copybits(bits, fpi.nbits, bb);
					Bfree(ptr,bb);
					}
				ULtod(rv.i, bits, exp, i);
			  }}
			goto ret;
		  }
		}
#endif
		nz0 = 1;
		while(*++s == '0') ;
		if (!*s)
			goto ret;
		}
	s0 = s;
	y = z = 0;
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
		if (nd < 9)
			y = 10*y + c - '0';
		else
			z = 10*z + c - '0';
	nd0 = nd;
	if (strncmp (s, _localeconv_r (ptr)->decimal_point,
		     strlen (_localeconv_r (ptr)->decimal_point)) == 0)
		{
		decpt = 1;
		c = *(s += strlen (_localeconv_r (ptr)->decimal_point));
		if (!nd) {
			for(; c == '0'; c = *++s)
				nz++;
			if (c > '0' && c <= '9') {
				s0 = s;
				nf += nz;
				nz = 0;
				goto have_dig;
				}
			goto dig_done;
			}
		for(; c >= '0' && c <= '9'; c = *++s) {
 have_dig:
			nz++;
			if (c -= '0') {
				nf += nz;
				for(i = 1; i < nz; i++)
					if (nd++ < 9)
						y *= 10;
					else if (nd <= DBL_DIG + 1)
						z *= 10;
				if (nd++ < 9)
					y = 10*y + c;
				else if (nd <= DBL_DIG + 1)
					z = 10*z + c;
				nz = 0;
				}
			}
		}
 dig_done:
	e = 0;
	if (c == 'e' || c == 'E') {
		if (!nd && !nz && !nz0) {
			goto ret0;
			}
		s00 = s;
		esign = 0;
		switch(c = *++s) {
			case '-':
				esign = 1;
			case '+':
				c = *++s;
			}
		if (c >= '0' && c <= '9') {
			while(c == '0')
				c = *++s;
			if (c > '0' && c <= '9') {
				L = c - '0';
				s1 = s;
				while((c = *++s) >= '0' && c <= '9')
					L = 10*L + c - '0';
				if (s - s1 > 8 || L > 19999)
					/* Avoid confusion from exponents
					 * so large that e might overflow.
					 */
					e = 19999; /* safe for 16 bit ints */
				else
					e = (int)L;
				if (esign)
					e = -e;
				}
			else
				e = 0;
			}
		else
			s = s00;
		}
	if (!nd) {
		if (!nz && !nz0) {
#ifdef INFNAN_CHECK
			/* Check for Nan and Infinity */
			__ULong bits[2];
			static _CONST FPI fpinan =	/* only 52 explicit bits */
				{ 52, 1-1023-53+1, 2046-1023-53+1, 1, SI };
			if (!decpt)
			 switch(c) {
			  case 'i':
			  case 'I':
				if (match(&s,"nf")) {
					--s;
					if (!match(&s,"inity"))
						++s;
					dword0(rv) = 0x7ff00000;
#ifndef _DOUBLE_IS_32BITS
					dword1(rv) = 0;
#endif /*!_DOUBLE_IS_32BITS*/
					goto ret;
					}
				break;
			  case 'n':
			  case 'N':
				if (match(&s, "an")) {
#ifndef No_Hex_NaN
					if (*s == '(' /*)*/
					 && hexnan(&s, &fpinan, bits)
							== STRTOG_NaNbits) {
						dword0(rv) = 0x7ff00000 | bits[1];
#ifndef _DOUBLE_IS_32BITS
						dword1(rv) = bits[0];
#endif /*!_DOUBLE_IS_32BITS*/
						}
					else {
#endif
						dword0(rv) = NAN_WORD0;
#ifndef _DOUBLE_IS_32BITS
						dword1(rv) = NAN_WORD1;
#endif /*!_DOUBLE_IS_32BITS*/
#ifndef No_Hex_NaN
						}
#endif
					goto ret;
					}
			  }
#endif /* INFNAN_CHECK */
 ret0:
			s = s00;
			sign = 0;
			}
		goto ret;
		}
	e1 = e -= nf;

	/* Now we have nd0 digits, starting at s0, followed by a
	 * decimal point, followed by nd-nd0 digits.  The number we're
	 * after is the integer represented by those digits times
	 * 10**e */

	if (!nd0)
		nd0 = nd;
	k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;
	dval(rv) = y;
	if (k > 9) {
#ifdef SET_INEXACT
		if (k > DBL_DIG)
			oldinexact = get_inexact();
#endif
		dval(rv) = tens[k - 9] * dval(rv) + z;
		}
	bd0 = 0;
	if (nd <= DBL_DIG
#ifndef RND_PRODQUOT
#ifndef Honor_FLT_ROUNDS
		&& Flt_Rounds == 1
#endif
#endif
			) {
		if (!e)
			goto ret;
		if (e > 0) {
			if (e <= Ten_pmax) {
#ifdef VAX
				goto vax_ovfl_check;
#else
#ifdef Honor_FLT_ROUNDS
				/* round correctly FLT_ROUNDS = 2 or 3 */
				if (sign) {
					dval(rv) = -dval(rv);
					sign = 0;
					}
#endif
				/* rv = */ rounded_product(dval(rv), tens[e]);
				goto ret;
#endif
				}
			i = DBL_DIG - nd;
			if (e <= Ten_pmax + i) {
				/* A fancier test would sometimes let us do
				 * this for larger i values.
				 */
#ifdef Honor_FLT_ROUNDS
				/* round correctly FLT_ROUNDS = 2 or 3 */
				if (sign) {
					dval(rv) = -dval(rv);
					sign = 0;
					}
#endif
				e -= i;
				dval(rv) *= tens[i];
#ifdef VAX
				/* VAX exponent range is so narrow we must
				 * worry about overflow here...
				 */
 vax_ovfl_check:
				dword0(rv) -= P*Exp_msk1;
				/* rv = */ rounded_product(dval(rv), tens[e]);
				if ((dword0(rv) & Exp_mask)
				 > Exp_msk1*(DBL_MAX_EXP+Bias-1-P))
					goto ovfl;
				dword0(rv) += P*Exp_msk1;
#else
				/* rv = */ rounded_product(dval(rv), tens[e]);
#endif
				goto ret;
				}
			}
#ifndef Inaccurate_Divide
		else if (e >= -Ten_pmax) {
#ifdef Honor_FLT_ROUNDS
			/* round correctly FLT_ROUNDS = 2 or 3 */
			if (sign) {
				dval(rv) = -dval(rv);
				sign = 0;
				}
#endif
			/* rv = */ rounded_quotient(dval(rv), tens[-e]);
			goto ret;
			}
#endif
		}
	e1 += nd - k;

#ifdef IEEE_Arith
#ifdef SET_INEXACT
	inexact = 1;
	if (k <= DBL_DIG)
		oldinexact = get_inexact();
#endif
#ifdef Avoid_Underflow
	scale = 0;
#endif
#ifdef Honor_FLT_ROUNDS
	if ((rounding = Flt_Rounds) >= 2) {
		if (sign)
			rounding = rounding == 2 ? 0 : 2;
		else
			if (rounding != 2)
				rounding = 0;
		}
#endif
#endif /*IEEE_Arith*/

	/* Get starting approximation = rv * 10**e1 */

	if (e1 > 0) {
		if ( (i = e1 & 15) !=0)
			dval(rv) *= tens[i];
		if (e1 &= ~15) {
			if (e1 > DBL_MAX_10_EXP) {
 ovfl:
#ifndef NO_ERRNO
				ptr->_errno = ERANGE;
#endif
				/* Can't trust HUGE_VAL */
#ifdef IEEE_Arith
#ifdef Honor_FLT_ROUNDS
				switch(rounding) {
				  case 0: /* toward 0 */
				  case 3: /* toward -infinity */
					dword0(rv) = Big0;
#ifndef _DOUBLE_IS_32BITS
					dword1(rv) = Big1;
#endif /*!_DOUBLE_IS_32BITS*/
					break;
				  default:
					dword0(rv) = Exp_mask;
#ifndef _DOUBLE_IS_32BITS
					dword1(rv) = 0;
#endif /*!_DOUBLE_IS_32BITS*/
				  }
#else /*Honor_FLT_ROUNDS*/
				dword0(rv) = Exp_mask;
#ifndef _DOUBLE_IS_32BITS
				dword1(rv) = 0;
#endif /*!_DOUBLE_IS_32BITS*/
#endif /*Honor_FLT_ROUNDS*/
#ifdef SET_INEXACT
				/* set overflow bit */
				dval(rv0) = 1e300;
				dval(rv0) *= dval(rv0);
#endif
#else /*IEEE_Arith*/
				dword0(rv) = Big0;
#ifndef _DOUBLE_IS_32BITS
				dword1(rv) = Big1;
#endif /*!_DOUBLE_IS_32BITS*/
#endif /*IEEE_Arith*/
				if (bd0)
					goto retfree;
				goto ret;
				}
			e1 >>= 4;
			for(j = 0; e1 > 1; j++, e1 >>= 1)
				if (e1 & 1)
					dval(rv) *= bigtens[j];
		/* The last multiplication could overflow. */
			dword0(rv) -= P*Exp_msk1;
			dval(rv) *= bigtens[j];
			if ((z = dword0(rv) & Exp_mask)
			 > Exp_msk1*(DBL_MAX_EXP+Bias-P))
				goto ovfl;
			if (z > Exp_msk1*(DBL_MAX_EXP+Bias-1-P)) {
				/* set to largest number */
				/* (Can't trust DBL_MAX) */
				dword0(rv) = Big0;
#ifndef _DOUBLE_IS_32BITS
				dword1(rv) = Big1;
#endif /*!_DOUBLE_IS_32BITS*/
				}
			else
				dword0(rv) += P*Exp_msk1;
			}
		}
	else if (e1 < 0) {
		e1 = -e1;
		if ( (i = e1 & 15) !=0)
			dval(rv) /= tens[i];
		if (e1 >>= 4) {
			if (e1 >= 1 << n_bigtens)
				goto undfl;
#ifdef Avoid_Underflow
			if (e1 & Scale_Bit)
				scale = 2*P;
			for(j = 0; e1 > 0; j++, e1 >>= 1)
				if (e1 & 1)
					dval(rv) *= tinytens[j];
			if (scale && (j = 2*P + 1 - ((dword0(rv) & Exp_mask)
						>> Exp_shift)) > 0) {
				/* scaled rv is denormal; zap j low bits */
				if (j >= 32) {
#ifndef _DOUBLE_IS_32BITS
					dword1(rv) = 0;
#endif /*!_DOUBLE_IS_32BITS*/
					if (j >= 53)
					 dword0(rv) = (P+2)*Exp_msk1;
					else
					 dword0(rv) &= 0xffffffff << (j-32);
					}
#ifndef _DOUBLE_IS_32BITS
				else
					dword1(rv) &= 0xffffffff << j;
#endif /*!_DOUBLE_IS_32BITS*/
				}
#else
			for(j = 0; e1 > 1; j++, e1 >>= 1)
				if (e1 & 1)
					dval(rv) *= tinytens[j];
			/* The last multiplication could underflow. */
			dval(rv0) = dval(rv);
			dval(rv) *= tinytens[j];
			if (!dval(rv)) {
				dval(rv) = 2.*dval(rv0);
				dval(rv) *= tinytens[j];
#endif
				if (!dval(rv)) {
 undfl:
					dval(rv) = 0.;
#ifndef NO_ERRNO
					ptr->_errno = ERANGE;
#endif
					if (bd0)
						goto retfree;
					goto ret;
					}
#ifndef Avoid_Underflow
#ifndef _DOUBLE_IS_32BITS
				dword0(rv) = Tiny0;
				dword1(rv) = Tiny1;
#else
				dword0(rv) = Tiny1;
#endif /*_DOUBLE_IS_32BITS*/
				/* The refinement below will clean
				 * this approximation up.
				 */
				}
#endif
			}
		}

	/* Now the hard part -- adjusting rv to the correct value.*/

	/* Put digits into bd: true value = bd * 10^e */

	bd0 = s2b(ptr, s0, nd0, nd, y);
	if (bd0 == NULL)
		goto ovfl;

	for(;;) {
		bd = Balloc(ptr,bd0->_k);
		if (bd == NULL)
			goto ovfl;
		Bcopy(bd, bd0);
		bb = d2b(ptr,dval(rv), &bbe, &bbbits);	/* rv = bb * 2^bbe */
		if (bb == NULL)
			goto ovfl;
		bs = i2b(ptr,1);
		if (bs == NULL)
			goto ovfl;

		if (e >= 0) {
			bb2 = bb5 = 0;
			bd2 = bd5 = e;
			}
		else {
			bb2 = bb5 = -e;
			bd2 = bd5 = 0;
			}
		if (bbe >= 0)
			bb2 += bbe;
		else
			bd2 -= bbe;
		bs2 = bb2;
#ifdef Honor_FLT_ROUNDS
		if (rounding != 1)
			bs2++;
#endif
#ifdef Avoid_Underflow
		Lsb = LSB;
		Lsb1 = 0;
		j = bbe - scale;
		i = j + bbbits - 1;	/* logb(rv) */
		j = P + 1 - bbbits;
		if (i < Emin) {	/* denormal */
			i = Emin - i;
			j -= i;
			if (i < 32)
				Lsb <<= i;
			else
				Lsb1 = Lsb << (i-32);
			}
#else /*Avoid_Underflow*/
#ifdef Sudden_Underflow
#ifdef IBM
		j = 1 + 4*P - 3 - bbbits + ((bbe + bbbits - 1) & 3);
#else
		j = P + 1 - bbbits;
#endif
#else /*Sudden_Underflow*/
		j = bbe;
		i = j + bbbits - 1;	/* logb(rv) */
		if (i < Emin)	/* denormal */
			j += P - Emin;
		else
			j = P + 1 - bbbits;
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
		bb2 += j;
		bd2 += j;
#ifdef Avoid_Underflow
		bd2 += scale;
#endif
		i = bb2 < bd2 ? bb2 : bd2;
		if (i > bs2)
			i = bs2;
		if (i > 0) {
			bb2 -= i;
			bd2 -= i;
			bs2 -= i;
			}
		if (bb5 > 0) {
			bs = pow5mult(ptr, bs, bb5);
			if (bs == NULL)
				goto ovfl;
			bb1 = mult(ptr, bs, bb);
			if (bb1 == NULL)
				goto ovfl;
			Bfree(ptr, bb);
			bb = bb1;
			}
		if (bb2 > 0) {
			bb = lshift(ptr, bb, bb2);
			if (bb == NULL)
				goto ovfl;
			}
		if (bd5 > 0) {
			bd = pow5mult(ptr, bd, bd5);
			if (bd == NULL)
				goto ovfl;
			}
		if (bd2 > 0) {
			bd = lshift(ptr, bd, bd2);
			if (bd == NULL)
				goto ovfl;
			}
		if (bs2 > 0) {
			bs = lshift(ptr, bs, bs2);
			if (bs == NULL)
				goto ovfl;
			}
		delta = diff(ptr, bb, bd);
		if (delta == NULL)
			goto ovfl;
		dsign = delta->_sign;
		delta->_sign = 0;
		i = cmp(delta, bs);
#ifdef Honor_FLT_ROUNDS
		if (rounding != 1) {
			if (i < 0) {
				/* Error is less than an ulp */
				if (!delta->_x[0] && delta->_wds <= 1) {
					/* exact */
#ifdef SET_INEXACT
					inexact = 0;
#endif
					break;
					}
				if (rounding) {
					if (dsign) {
						adj = 1.;
						goto apply_adj;
						}
					}
				else if (!dsign) {
					adj = -1.;
					if (!dword1(rv)
					    && !(dword0(rv) & Frac_mask)) {
						y = dword0(rv) & Exp_mask;
#ifdef Avoid_Underflow
						if (!scale || y > 2*P*Exp_msk1)
#else
						if (y)
#endif
						  {
						  delta = lshift(ptr, delta,Log2P);
						  if (cmp(delta, bs) <= 0)
							adj = -0.5;
						  }
						}
 apply_adj:
#ifdef Avoid_Underflow
					if (scale && (y = dword0(rv) & Exp_mask)
						<= 2*P*Exp_msk1)
					  dword0(adj) += (2*P+1)*Exp_msk1 - y;
#else
#ifdef Sudden_Underflow
					if ((dword0(rv) & Exp_mask) <=
							P*Exp_msk1) {
						dword0(rv) += P*Exp_msk1;
						dval(rv) += adj*ulp(dval(rv));
						dword0(rv) -= P*Exp_msk1;
						}
					else
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
					dval(rv) += adj*ulp(dval(rv));
					}
				break;
				}
			adj = ratio(delta, bs);
			if (adj < 1.)
				adj = 1.;
			if (adj <= 0x7ffffffe) {
				/* adj = rounding ? ceil(adj) : floor(adj); */
				y = adj;
				if (y != adj) {
					if (!((rounding>>1) ^ dsign))
						y++;
					adj = y;
					}
				}
#ifdef Avoid_Underflow
			if (scale && (y = dword0(rv) & Exp_mask) <= 2*P*Exp_msk1)
				dword0(adj) += (2*P+1)*Exp_msk1 - y;
#else
#ifdef Sudden_Underflow
			if ((dword0(rv) & Exp_mask) <= P*Exp_msk1) {
				dword0(rv) += P*Exp_msk1;
				adj *= ulp(dval(rv));
				if (dsign)
					dval(rv) += adj;
				else
					dval(rv) -= adj;
				dword0(rv) -= P*Exp_msk1;
				goto cont;
				}
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
			adj *= ulp(dval(rv));
			if (dsign) {
				if (dword0(rv) == Big0 && dword1(rv) == Big1)
					goto ovfl;
				dval(rv) += adj;
			else
				dval(rv) -= adj;
			goto cont;
			}
#endif /*Honor_FLT_ROUNDS*/

		if (i < 0) {
			/* Error is less than half an ulp -- check for
			 * special case of mantissa a power of two.
			 */
			if (dsign || dword1(rv) || dword0(rv) & Bndry_mask
#ifdef IEEE_Arith
#ifdef Avoid_Underflow
			 || (dword0(rv) & Exp_mask) <= (2*P+1)*Exp_msk1
#else
			 || (dword0(rv) & Exp_mask) <= Exp_msk1
#endif
#endif
				) {
#ifdef SET_INEXACT
				if (!delta->x[0] && delta->wds <= 1)
					inexact = 0;
#endif
				break;
				}
			if (!delta->_x[0] && delta->_wds <= 1) {
				/* exact result */
#ifdef SET_INEXACT
				inexact = 0;
#endif
				break;
				}
			delta = lshift(ptr,delta,Log2P);
			if (cmp(delta, bs) > 0)
				goto drop_down;
			break;
			}
		if (i == 0) {
			/* exactly half-way between */
			if (dsign) {
				if ((dword0(rv) & Bndry_mask1) == Bndry_mask1
				 &&  dword1(rv) == (
#ifdef Avoid_Underflow
			(scale && (y = dword0(rv) & Exp_mask) <= 2*P*Exp_msk1)
		? (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
#endif
						   0xffffffff)) {
					/*boundary case -- increment exponent*/
					if (dword0(rv) == Big0 && dword1(rv) == Big1)
						goto ovfl;
					dword0(rv) = (dword0(rv) & Exp_mask)
						+ Exp_msk1
#ifdef IBM
						| Exp_msk1 >> 4
#endif
						;
#ifndef _DOUBLE_IS_32BITS
					dword1(rv) = 0;
#endif /*!_DOUBLE_IS_32BITS*/
#ifdef Avoid_Underflow
					dsign = 0;
#endif
					break;
					}
				}
			else if (!(dword0(rv) & Bndry_mask) && !dword1(rv)) {
 drop_down:
				/* boundary case -- decrement exponent */
#ifdef Sudden_Underflow /*{{*/
				L = dword0(rv) & Exp_mask;
#ifdef IBM
				if (L <  Exp_msk1)
#else
#ifdef Avoid_Underflow
				if (L <= (scale ? (2*P+1)*Exp_msk1 : Exp_msk1))
#else
				if (L <= Exp_msk1)
#endif /*Avoid_Underflow*/
#endif /*IBM*/
					goto undfl;
				L -= Exp_msk1;
#else /*Sudden_Underflow}{*/
#ifdef Avoid_Underflow
				if (scale) {
					L = dword0(rv) & Exp_mask;
					if (L <= (2*P+1)*Exp_msk1) {
						if (L > (P+2)*Exp_msk1)
							/* round even ==> */
							/* accept rv */
							break;
						/* rv = smallest denormal */
						goto undfl;
						}
					}
#endif /*Avoid_Underflow*/
				L = (dword0(rv) & Exp_mask) - Exp_msk1;
#endif /*Sudden_Underflow}*/
				dword0(rv) = L | Bndry_mask1;
#ifndef _DOUBLE_IS_32BITS
				dword1(rv) = 0xffffffff;
#endif /*!_DOUBLE_IS_32BITS*/
#ifdef IBM
				goto cont;
#else
				break;
#endif
				}
#ifndef ROUND_BIASED
#ifdef Avoid_Underflow
			if (Lsb1) {
				if (!(dword0(rv) & Lsb1))
					break;
				}
			else if (!(dword1(rv) & Lsb))
				break;
#else
			if (!(dword1(rv) & LSB))
				break;
#endif
#endif
			if (dsign)
#ifdef Avoid_Underflow
				dval(rv) += sulp(rv, scale);
#else
				dval(rv) += ulp(dval(rv));
#endif
#ifndef ROUND_BIASED
			else {
#ifdef Avoid_Underflow
				dval(rv) -= sulp(rv, scale);
#else
				dval(rv) -= ulp(dval(rv));
#endif
#ifndef Sudden_Underflow
				if (!dval(rv))
					goto undfl;
#endif
				}
#ifdef Avoid_Underflow
			dsign = 1 - dsign;
#endif
#endif
			break;
			}
		if ((aadj = ratio(delta, bs)) <= 2.) {
			if (dsign)
				aadj = dval(aadj1) = 1.;
			else if (dword1(rv) || dword0(rv) & Bndry_mask) {
#ifndef Sudden_Underflow
				if (dword1(rv) == Tiny1 && !dword0(rv))
					goto undfl;
#endif
				aadj = 1.;
				dval(aadj1) = -1.;
				}
			else {
				/* special case -- power of FLT_RADIX to be */
				/* rounded down... */

				if (aadj < 2./FLT_RADIX)
					aadj = 1./FLT_RADIX;
				else
					aadj *= 0.5;
				dval(aadj1) = -aadj;
				}
			}
		else {
			aadj *= 0.5;
			dval(aadj1) = dsign ? aadj : -aadj;
#ifdef Check_FLT_ROUNDS
			switch(Rounding) {
				case 2: /* towards +infinity */
					dval(aadj1) -= 0.5;
					break;
				case 0: /* towards 0 */
				case 3: /* towards -infinity */
					dval(aadj1) += 0.5;
				}
#else
			if (Flt_Rounds == 0)
				dval(aadj1) += 0.5;
#endif /*Check_FLT_ROUNDS*/
			}
		y = dword0(rv) & Exp_mask;

		/* Check for overflow */

		if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {
			dval(rv0) = dval(rv);
			dword0(rv) -= P*Exp_msk1;
			adj = dval(aadj1) * ulp(dval(rv));
			dval(rv) += adj;
			if ((dword0(rv) & Exp_mask) >=
					Exp_msk1*(DBL_MAX_EXP+Bias-P)) {
				if (dword0(rv0) == Big0 && dword1(rv0) == Big1)
					goto ovfl;
				dword0(rv) = Big0;
#ifndef _DOUBLE_IS_32BITS
				dword1(rv) = Big1;
#endif /*!_DOUBLE_IS_32BITS*/
				goto cont;
				}
			else
				dword0(rv) += P*Exp_msk1;
			}
		else {
#ifdef Avoid_Underflow
			if (scale && y <= 2*P*Exp_msk1) {
				if (aadj <= 0x7fffffff) {
					if ((z = aadj) == 0)
						z = 1;
					aadj = z;
					dval(aadj1) = dsign ? aadj : -aadj;
					}
				dword0(aadj1) += (2*P+1)*Exp_msk1 - y;
				}
			adj = dval(aadj1) * ulp(dval(rv));
			dval(rv) += adj;
#else
#ifdef Sudden_Underflow
			if ((dword0(rv) & Exp_mask) <= P*Exp_msk1) {
				dval(rv0) = dval(rv);
				dword0(rv) += P*Exp_msk1;
				adj = dval(aadj1) * ulp(dval(rv));
				dval(rv) += adj;
#ifdef IBM
				if ((dword0(rv) & Exp_mask) <  P*Exp_msk1)
#else
				if ((dword0(rv) & Exp_mask) <= P*Exp_msk1)
#endif
					{
					if (dword0(rv0) == Tiny0
					 && dword1(rv0) == Tiny1)
						goto undfl;
#ifndef _DOUBLE_IS_32BITS
					dword0(rv) = Tiny0;
					dword1(rv) = Tiny1;
#else
					dword0(rv) = Tiny1;
#endif /*_DOUBLE_IS_32BITS*/
					goto cont;
					}
				else
					dword0(rv) -= P*Exp_msk1;
				}
			else {
				adj = dval(aadj1) * ulp(dval(rv));
				dval(rv) += adj;
				}
#else /*Sudden_Underflow*/
			/* Compute adj so that the IEEE rounding rules will
			 * correctly round rv + adj in some half-way cases.
			 * If rv * ulp(rv) is denormalized (i.e.,
			 * y <= (P-1)*Exp_msk1), we must adjust aadj to avoid
			 * trouble from bits lost to denormalization;
			 * example: 1.2e-307 .
			 */
			if (y <= (P-1)*Exp_msk1 && aadj > 1.) {
				dval(aadj1) = (double)(int)(aadj + 0.5);
				if (!dsign)
					dval(aadj1) = -dval(aadj1);
				}
			adj = dval(aadj1) * ulp(dval(rv));
			dval(rv) += adj;
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
			}
		z = dword0(rv) & Exp_mask;
#ifndef SET_INEXACT
#ifdef Avoid_Underflow
		if (!scale)
#endif
		if (y == z) {
			/* Can we stop now? */
			L = (Long)aadj;
			aadj -= L;
			/* The tolerances below are conservative. */
			if (dsign || dword1(rv) || dword0(rv) & Bndry_mask) {
				if (aadj < .4999999 || aadj > .5000001)
					break;
				}
			else if (aadj < .4999999/FLT_RADIX)
				break;
			}
#endif
 cont:
		Bfree(ptr,bb);
		Bfree(ptr,bd);
		Bfree(ptr,bs);
		Bfree(ptr,delta);
		}
#ifdef SET_INEXACT
	if (inexact) {
		if (!oldinexact) {
			dword0(rv0) = Exp_1 + (70 << Exp_shift);
#ifndef _DOUBLE_IS_32BITS
			dword1(rv0) = 0;
#endif /*!_DOUBLE_IS_32BITS*/
			dval(rv0) += 1.;
			}
		}
	else if (!oldinexact)
		clear_inexact();
#endif
#ifdef Avoid_Underflow
	if (scale) {
		dword0(rv0) = Exp_1 - 2*P*Exp_msk1;
#ifndef _DOUBLE_IS_32BITS
		dword1(rv0) = 0;
#endif /*!_DOUBLE_IS_32BITS*/
		dval(rv) *= dval(rv0);
#ifndef NO_ERRNO
		/* try to avoid the bug of testing an 8087 register value */
		if (dword0(rv) == 0 && dword1(rv) == 0)
			ptr->_errno = ERANGE;
#endif
		}
#endif /* Avoid_Underflow */
#ifdef SET_INEXACT
	if (inexact && !(dword0(rv) & Exp_mask)) {
		/* set underflow bit */
		dval(rv0) = 1e-300;
		dval(rv0) *= dval(rv0);
		}
#endif
 retfree:
	Bfree(ptr,bb);
	Bfree(ptr,bd);
	Bfree(ptr,bs);
	Bfree(ptr,bd0);
	Bfree(ptr,delta);
 ret:
	if (se)
		*se = (char *)s;
	return sign ? -dval(rv) : dval(rv);
}

#ifndef _REENT_ONLY

double
_DEFUN (strtod, (s00, se),
	_CONST char *__restrict s00 _AND char **__restrict se)
{
  return _strtod_r (_REENT, s00, se);
}

float
_DEFUN (strtof, (s00, se),
	_CONST char *__restrict s00 _AND
	char **__restrict se)
{
  double retval = _strtod_r (_REENT, s00, se);
  if (isnan (retval))
    return nanf (NULL);
  return (float)retval;
}

#endif
@


1.22
log
@2013-11-18  Sahil Patnayakuni  <sahilp@@oarcorp.com>

	* libc/include/stdlib.h, libc/stdlib/mbstowcs.c,
	libc/stdlib/mbstowcs_r.c, libc/stdlib/mbtowc.c,
	libc/stdlib/mbtowc_r.c, libc/stdlib/strtod.c,
	libc/stdlib/strtol.c, libc/stdlib/strtold.c,
	libc/stdlib/strtoll.c, libc/stdlib/strtoll_r.c,
	libc/stdlib/strtoul.c, libc/stdlib/strtoull.c,
	libc/stdlib/strtoull_r.c, libc/stdlib/wcstombs.c,
	libc/stdlib/wcstombs_r.c: Add restrict keyword.
@
text
@d166 1
a166 1
        dword0(u) = Exp_1 + (i << Exp_shift);
@


1.21
log
@	* libc/stdlib/gdtoa-gethex.c (__hexdig): Constify.
	(hexdig_init): Remove.
	(__hexdig_fun): New function.
	hexdig_init, added __hexdig_fun
	(gethex): Call __get_hexdig macro rather than hexdig.
	* libc/stdlib/gdtoa-hexnan.c (hexnan): Constify fpi argument.
	Call __get_hexdig macro rather than hexdig.
	* libc/stdlib/ldtoa.c: Throughout constify functions arguments where
	required by constifying the following arrays.
	(ezero): Constify.
	(eone): Constify.
	(ermsg): Constify.
	(etens): Constify.
	(emtens): Constify.
	(nan113): Constify.
	(nan64): Constify.
	(nan53): Constify.
	(nan24): Constify.
	* libc/stdlib/mprec.h (__get_hexdig): Define.
	(gethex): Constify args in declaration where appropriate.
	(hexnan): Ditto.
	(hexdig_init): Remove declaration.
	(__hexdig_fun): Declare.
	* libc/stdlib/strtod.c (fpi): Constify.
	(fpinan): Constify.
@
text
@d14 2
a15 2
        double strtod(const char *<[str]>, char **<[tail]>);
        float strtof(const char *<[str]>, char **<[tail]>);
d18 1
a18 1
                         const char *<[str]>, char **<[tail]>);
d239 2
a240 2
	_CONST char *s00 _AND
	char **se)
d1258 1
a1258 1
	_CONST char *s00 _AND char **se)
d1265 2
a1266 2
	_CONST char *s00 _AND
	char **se)
@


1.20
log
@	* libc/stdlib/strtod.c: Manual update to latest algorithm from NetBSD.
@
text
@d290 1
a290 1
		static FPI fpi = { 53, 1-1023-53+1, 2046-1023-53+1, 1, SI };
d418 1
a418 1
			static FPI fpinan =	/* only 52 explicit bits */
@


1.19
log
@	* libc/stdlib/strtod.c (_strtod_r): Revert change from 2011-05-16.
@
text
@d131 1
a131 1
/* The factor of 2^53 in tinytens[4] helps us avoid setting the underflow */
d133 9
a141 3
static _CONST double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128,
		9007199254740992.e-256
		};
d153 22
d252 4
a255 1
	_Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;
d313 2
d335 5
a339 8
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++) {
		if (nd < DBL_DIG + 1) {
			if (nd < 9)
				y = 10*y + c - '0';
			else
				z = 10*z + c - '0';
		}
        }
d362 9
a370 14
				for(i = 1; i < nz; i++) {
					if (nd++ <= DBL_DIG + 1) {
						if (nd < 10)
							y *= 10;
						else
							z *= 10;
					}
				}
				if (nd++ <= DBL_DIG + 1) {
					if (nd < 10)
						y = 10*y + c;
					else
						z = 10*z + c;
				}
d719 2
d724 2
d728 2
d731 2
d752 2
d756 9
a764 4
		if (i < Emin)	/* denormal */
			j += P - Emin;
		else
			j = P + 1 - bbbits;
d796 2
d799 2
d804 1
a804 1
		if (bb2 > 0)
d806 4
a809 1
		if (bd5 > 0)
d811 4
a814 1
		if (bd2 > 0)
d816 4
a819 1
		if (bs2 > 0)
d821 3
d825 2
d850 1
a850 1
					 && !(dword0(rv) & Frac_mask)) {
d913 3
a915 1
			if (dsign)
d965 2
d1025 8
d1036 1
d1038 3
d1042 1
d1045 3
d1049 1
d1126 1
a1126 1
					if ((z = aadj) <= 0)
@


1.18
log
@	* libc/stdlib/strtod.c (_strtod_r): Fix nf/nd counts to not exceed
	DBL_DIG.
@
text
@d312 2
a313 1
		     strlen (_localeconv_r (ptr)->decimal_point)) == 0) {
d331 1
d333 2
a334 2
					if (nd <= DBL_DIG + 1) {
						if (nd + i < 10)
d340 2
a341 2
				if (nd <= DBL_DIG + 1) {
					if (nd + i < 10)
d346 1
a346 3
				if (nd <= DBL_DIG + 1) {
					nf += nz;
					nd += nz;
a347 1
				nz = 0;
a349 1
	}
@


1.17
log
@
2010-12-07  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/strtod.c(_strtod_r): Fix code to handle case whereby
        _DOUBLE_IS_32BITS is set and DBL_DIGS is 6 instead of 15.
@
text
@d312 1
a312 2
		     strlen (_localeconv_r (ptr)->decimal_point)) == 0)
		{
a329 1
				nf += nz;
d331 2
a332 2
					if (nd++ <= DBL_DIG + 1) {
						if (nd < 10)
d338 2
a339 2
				if (nd++ <= DBL_DIG + 1) {
					if (nd < 10)
d344 4
a348 1
				}
d351 1
@


1.16
log
@
2009-12-03  Craig Howland <howland@@LGSInnovations.com>

        * libc/stdlib/strtod.c:  Correct "NO_REENT" to "_REENT_ONLY".
        * libc/stdlib/wcstod.c:  Ditto.
        * libc/stdlib/dtoastub.c:  Ditto.
@
text
@d302 8
a309 5
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
		if (nd < 9)
			y = 10*y + c - '0';
		else if (nd < 16)
			z = 10*z + c - '0';
d332 14
a345 9
				for(i = 1; i < nz; i++)
					if (nd++ < 9)
						y *= 10;
					else if (nd <= DBL_DIG + 1)
						z *= 10;
				if (nd++ < 9)
					y = 10*y + c;
				else if (nd <= DBL_DIG + 1)
					z = 10*z + c;
@


1.15
log
@	* libc/stdio/vfprintf.c (_VFPRINTF_R): Use actual length of
	radix char instead of assuming length 1.
	* libc/stdlib/gdtoa-gethex.c: Remove use of USE_LOCALE.
	(gethex): Allow multibyte decimal point.
	Fix compiler warnings due to different signedness of pointer types.
	* libc/stdlib/strtod.c: Remove use of USE_LOCALE.
	(_strtod_r): Allow multibyte decimal point.
	* libc/stdlib/wcstod.c (_wcstod_r): Evaluate correct wide char
	endptr position if the decimal point is a multibyte char.
@
text
@d1167 1
a1167 1
#ifndef NO_REENT
@


1.14
log
@	Revert erroneously checked in files.
@
text
@a124 1
#ifdef USE_LOCALE
a125 1
#endif
d308 2
a309 5
#ifdef USE_LOCALE
	if (c == *localeconv()->decimal_point)
#else
	if (c == '.')
#endif
d312 1
a312 1
		c = *++s;
@


1.13
log
@	* libc/ctype/iswalpha.c: Handle all wchar_t as unicode on
	_MB_CAPABLE systems.
	* libc/ctype/iswblank.c: Ditto.
	* libc/ctype/iswcntrl.c: Ditto.
	* libc/ctype/iswprint.c: Ditto.
	* libc/ctype/iswpunct.c: Ditto.
	* libc/ctype/iswspace.c: Ditto.
	* libc/ctype/jp2uc.c (__jp2uc): On Cygwin, just return c.
	Explain why.
	* libc/ctype/towlower.c: Ditto.
	* libc/ctype/towupper.c: Ditto.
	* libc/include/sys/config.h: Define _MB_EXTENDED_CHARSETS_ISO
	and _MB_EXTENDED_CHARSETS_WINDOWS if _MB_EXTENDED_CHARSETS_ALL is
	defined.  Define _MB_EXTENDED_CHARSETS_ALL on Cygwin only for now.
	* libc/include/sys/reent.h (struct _reent): Mark _current_category
	and _current_locale as unused.
	* libc/locale/locale.c: Add new charset support to documentation.
	Include ../stdio/local.h from here.
	(lc_ctype_charset): Set to "ASCII" by default.
	(lc_message_charset): Ditto.
	(_setlocale_r): Don't set _current_category and _current_locale.
	(loadlocale): Add Cygwin codepage support.  On _MB_CAPABLE
	systems, set __mbtowc and __wctomb function pointers to function
	corresponding with current charset.  Don't allow non-existant
	ISO-8859-12 charset.  Add support for Windows singlebyte codepages.
	On Cygwin, add support for GBK, CP949, and BIG5.  On Cygwin,
	call __set_ctype() in case the catorgy is LC_CTYPE.  Don't set
	_current_category and _current_locale.
	* libc/stdlib/Makefile.am (GENERAL_SOURCES): Add sb_charsets.c.
	* libc/stdlib/Makefile.in: Regenerate.
	* libc/stdlib/local.h: Add prototype for __locale_charset.
	Add prototypes for __mbtowc and __wctomb pointers.
	Add prototypes for charset-specific _wctomb_r and _mbtowc_r
	functions.
	Declare tables and functions from sb_charsets.c.
	* libc/stdlib/mbtowc_r.c (__mbtowc): Define.  Set to __ascii_mbtowc
	by default.
	(_mbtowc_r): Just call __mbtowc from here.
	(__ascii_mbtowc): New function.
	(__iso_mbtowc): New function.
	(__cp_mbtowc): New function.
	(__utf8_mbtowc): New function.
	(__sjis_mbtowc): New function.  Disable on Cygwin.
	(__eucjp_mbtowc): New function.  Disable on Cygwin.
	(__jis_mbtowc): New function.  Disable on Cygwin.
	* libc/stdlib/sb_charsets.c: New file, adding singlebyte to UTF
	conversion tables for all ISO and CP charsets.
	(__iso_8859_index): New function.
	(__cp_index): New function.
	* libc/stdlib/wctomb_r.c (__wctomb): Define.  Set to __ascii_wctomb
	by default.
	(_wctomb_r): Just call __wctomb from here.
	(__ascii_wctomb): New function.
	(__utf8_wctomb): New function.
	(__sjis_wctomb): New function.  Disable on Cygwin.
	(__eucjp_wctomb): New function.  Disable on Cygwin.
	(__jis_wctomb): New function.  Disable on Cygwin.
	(__iso_wctomb): New function.
	(__cp_wctomb): New function.
@
text
@d125 1
d127 1
d310 5
a314 1
	if (strcmp (s, localeconv()->decimal_point) == 0)
d317 1
a317 1
		c = *(s += strlen (localeconv()->decimal_point));
@


1.12
log
@
2008-11-27  Craig Howland <howland@@LGSInnovations.com>

        * libc/argz/argz_add.c:  Added #include <argz.h> to get function
        prototypes.
        * libc/argz/argz_append.c: Ditto.
        * libc/argz/argz_count.c: Ditto.
        * libc/argz/argz_create.c: Ditto.
        * libc/argz/argz_create_sep.c: Ditto.
        * libc/argz/argz_delete.c: Ditto.
        * libc/argz/argz_next.c: Ditto.
        * libc/argz/argz_stringify.c: Ditto
        * libc/stdlib/strtod.c: Added #include <stdlib.h> to get function
        prototypes.
        * libc/stdlib/wcstoul.c: Added #include <wchar.h> to get function
        prototypes, corrected traditional usage comment.
        * libc/include/wchar.h: Added _mbsrtowcs_r() prototype.
@
text
@a124 1
#ifdef USE_LOCALE
a125 1
#endif
d308 1
a308 5
#ifdef USE_LOCALE
	if (c == *localeconv()->decimal_point)
#else
	if (c == '.')
#endif
d311 1
a311 1
		c = *++s;
@


1.12.2.1
log
@Support for ARCompact architecture.
@
text
@a1186 2
  float f_retval;

d1189 1
a1189 11
  f_retval = (float)retval;
#ifndef NO_ERRNO
  if (f_retval == 0 && retval != 0)
    _REENT->_errno = ERANGE;
#ifdef __GNUC__
  else if (f_retval == __builtin_huge_valf()
	   || f_retval == -__builtin_huge_valf())
    _REENT->_errno = ERANGE;
#endif
#endif /* NO_ERRNO */
  return f_retval;
@


1.11
log
@	Fix strict-aliasing issues with _strtod_r and Storeinc.
	* libc/stdlib/strtod.c (_strtod_r): Change local variables aadj,
	rv, rv0 from double to type U.  Use accessor macros dval, dword0
	and dword1 for all accesses except for the ULtod call, where rv.i
	replaces the pointer cast.
	* libc/stdlib/mprec.h (U): Rename member L to i for easier re-use
	of access macros.  Tweak comment.
	Remove #ifdef'd YES_ALIAS code.
	(dword0, dword1, dval): Define in terms of uncast union member
	access.  Ditto for _DOUBLE_IS_32BITS variants.
	(Storeinc): Replace aliasing-flawed microoptimized definition with
	alternative suggested in comment.  Remove now stale comment.
@
text
@d115 1
@


1.10
log
@Fix strtod("-0x", NULL).
* libc/stdlib/strtod.c (_strtod_r): Fall back to 0 if hex parse
fails.
@
text
@d221 2
a222 1
	double aadj, aadj1, adj, rv, rv0;
d290 1
a290 1
				ULtod(((U*)&rv)->L, bits, exp, i);
d473 1
a473 1
					rv = -rv;
d489 1
a489 1
					rv = -rv;
d517 1
a517 1
				rv = -rv;
d980 1
a980 1
				aadj = aadj1 = 1.;
d987 1
a987 1
				aadj1 = -1.;
d997 1
a997 1
				aadj1 = -aadj;
d1002 1
a1002 1
			aadj1 = dsign ? aadj : -aadj;
d1006 1
a1006 1
					aadj1 -= 0.5;
d1010 1
a1010 1
					aadj1 += 0.5;
d1014 1
a1014 1
				aadj1 += 0.5;
d1024 1
a1024 1
			adj = aadj1 * ulp(dval(rv));
d1046 1
a1046 1
					aadj1 = dsign ? aadj : -aadj;
d1050 1
a1050 1
			adj = aadj1 * ulp(dval(rv));
d1057 1
a1057 1
				adj = aadj1 * ulp(dval(rv));
d1080 1
a1080 1
				adj = aadj1 * ulp(dval(rv));
d1092 1
a1092 1
				aadj1 = (double)(int)(aadj + 0.5);
d1094 1
a1094 1
					aadj1 = -aadj1;
d1096 1
a1096 1
			adj = aadj1 * ulp(dval(rv));
@


1.9
log
@
2007-08-31  Antony King  <antony.king@@st.com>

        * libc/stdlib/mprec.h [_DOUBLE_IS_32BITS}: Define IEEE_Arith
        bits and redefine associated dword0 macro (rvalue issue).
        * libc/stdio/vfieeefp.h: Ditto.
        * libc/stdlib/strtod.c: Add checks for _DOUBLE_IS_32BITS
        to prevent setting dword1 which is an rvalue only.
@
text
@d17 1
a17 1
        double _strtod_r(void *<[reent]>, 
d40 7
a46 2
	non-whitespace character, that has the format:
	.[+|-]<[digits]>[.][<[digits]>][(e|E)[+|-]<[digits]>] 
d50 3
a52 1
	digit. If the substring is empty, no conversion is done, and
d62 2
a63 1
	round-even rule.
d187 1
a187 1
 
d265 3
a281 1
				sign = 0;
@


1.8
log
@
2006-07-05  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/mprec.h [_DOUBLE_IS_32BITS]: Turn off C99 hex
        floating-point format support.  Also redefine
        dword0 and dword1 macros.
        * libc/stdlib/strtod.c: Add checks for _DOUBLE_IS_32BITS
        to prevent setting dword1 which is an rvalue only.
@
text
@d389 1
d391 1
d403 1
d405 1
d410 1
d412 1
d636 1
a637 1
#endif /*!_DOUBLE_IS_32BITS*/
d1118 1
d1120 1
d1130 1
d1132 1
@


1.8.2.1
log
@	Fix strtod("-0x", NULL).
	* libc/stdlib/strtod.c (_strtod_r): Fall back to 0 if hex parse
	fails.
@
text
@d17 1
a17 1
        double _strtod_r(void *<[reent]>,
d40 2
a41 7
	non-whitespace character, that has one of these formats:
	.[+|-]<[digits]>[.[<[digits]>]][(e|E)[+|-]<[digits]>]
	.[+|-].<[digits]>[(e|E)[+|-]<[digits]>]
	.[+|-](i|I)(n|N)(f|F)[(i|I)(n|N)(i|I)(t|T)(y|Y)]
	.[+|-](n|N)(a|A)(n|N)[<(>[<[hexdigits]>]<)>]
	.[+|-]0(x|X)<[hexdigits]>[.[<[hexdigits]>]][(p|P)[+|-]<[digits]>]
	.[+|-]0(x|X).<[hexdigits]>[(p|P)[+|-]<[digits]>]
d45 1
a45 3
	digit, and cannot be parsed as infinity or NaN. If the platform
	does not support NaN, then NaN is treated as an empty substring.
	If the substring is empty, no conversion is done, and
d55 1
a55 2
	round-even rule.  However, <<strtof>> is currently subject to
	double rounding errors.
d179 1
a179 1

a256 3
			/* If the number is not hex, then the parse of
                           0 is still valid.  */
			s00 = s + 1;
d271 1
@


1.7
log
@
2006-06-22  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/Makefile.am: Add new gdtoa routines.
        * libc/stdlib/Makefile.in: Regenerated.
        * libc/stdlib/gd_qnan.h: New file.
        * libc/stdlib/gdtoa-gethex.c: Ditto.
        * libc/stdlib/gdtoa-hexnan.c: Ditto.
        * libc/stdlib/gdtoa.h: Ditto.
        * libc/stdlib/mprec.c: Add new helper routines needed by
        the new gdtoa code.
        * libc/stdlib/mprec.h: Integrate some defines and prototypes
        used by gdtoa routines here.
        * libc/stdlib/strtod.c: Rebased on David M. Gay's gdtoa-strtod.c
        which adds C99 support such as nan, inf, and hexadecimal input
        format.
@
text
@d140 2
d178 2
a179 1

d549 1
d551 1
d555 1
d557 1
d561 1
d563 1
d572 1
d574 1
d594 1
d596 1
d619 1
d621 1
d627 1
d631 1
d654 1
d657 3
d890 1
d892 1
d932 1
d934 1
d1014 1
d1016 1
d1051 1
d1054 3
@


1.6
log
@	* libc/stdlib/strtod.c (_strtod_r): Never change s00.
@
text
@d73 31
a103 26
 *
 * The author of this software is David M. Gay.
 *
 * Copyright (c) 1991 by AT&T.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR AT&T MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 ***************************************************************/

/* Please send bug reports to
	David M. Gay
	AT&T Bell Laboratories, Room 2C-463
	600 Mountain Avenue
	Murray Hill, NJ 07974-2070
	U.S.A.
	dmg@@research.att.com or research!dmg
 */
d106 1
a106 1
#include <reent.h>
d109 88
d204 233
a436 168
  int bb2, bb5, bbe, bd2, bd5, bbbits, bs2, c, dsign, e1, esign, i, j,
    k, nd, nd0, nf, nz, nz0, sign;
  long e;
  _CONST char *s, *s0, *s1, *s2;
  double aadj, aadj1, adj;
  long L;
  unsigned long z;
  __ULong y;
  union double_union rv, rv0;
  int nanflag;

  _Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;
  sign = nz0 = nz = nanflag = 0;
  rv.d = 0.;
  for (s = s00;; s++)
    switch (*s)
      {
      case '-':
	sign = 1;
	/* no break */
      case '+':
	if (*++s)
	  goto break2;
	/* no break */
      case 0:
	s = s00;
	goto ret;
      case '\t':
      case '\n':
      case '\v':
      case '\f':
      case '\r':
      case ' ':
	continue;
      default:
	goto break2;
      }
break2:
  if (*s == 'n' || *s == 'N')
    {
      ++s; 
      if (*s == 'a' || *s == 'A')
        {
          ++s;
          if (*s == 'n' || *s == 'N')
            {
              nanflag = 1;
              ++s;
              goto ret;
            }
        }
      s = s00;
      goto ret;
    }
  else if (*s == '0')
    {
      nz0 = 1;
      while (*++s == '0');
      if (!*s)
	goto ret;
    }
  s0 = s;
  y = z = 0;
  for (nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
    if (nd < 9)
      y = 10 * y + c - '0';
    else if (nd < 16)
      z = 10 * z + c - '0';
  nd0 = nd;
  if (c == '.')
    {
      c = *++s;
      if (!nd)
	{
	  for (; c == '0'; c = *++s)
	    nz++;
	  if (c > '0' && c <= '9')
	    {
	      s0 = s;
	      nf += nz;
	      nz = 0;
	      goto have_dig;
	    }
	  goto dig_done;
	}
      for (; c >= '0' && c <= '9'; c = *++s)
	{
	have_dig:
	  nz++;
	  if (c -= '0')
	    {
	      nf += nz;
	      for (i = 1; i < nz; i++)
		if (nd++ < 9)
		  y *= 10;
		else if (nd <= DBL_DIG + 1)
		  z *= 10;
	      if (nd++ < 9)
		y = 10 * y + c;
	      else if (nd <= DBL_DIG + 1)
		z = 10 * z + c;
	      nz = 0;
	    }
	}
    }
dig_done:
  e = 0;
  if (c == 'e' || c == 'E')
    {
      if (!nd && !nz && !nz0)
	{
	  s = s00;
	  goto ret;
	}
      s2 = s;
      esign = 0;
      switch (c = *++s)
	{
	case '-':
	  esign = 1;
	case '+':
	  c = *++s;
	}
      if (c >= '0' && c <= '9')
	{
	  while (c == '0')
	    c = *++s;
	  if (c > '0' && c <= '9')
	    {
	      e = c - '0';
	      s1 = s;
	      while ((c = *++s) >= '0' && c <= '9')
		e = 10 * e + c - '0';
	      if (s - s1 > 8)
		/* Avoid confusion from exponents
		 * so large that e might overflow.
		 */
		e = 9999999L;
	      if (esign)
		e = -e;
	    }
	  else
	    e = 0;
	}
      else
	s = s2;
    }
  if (!nd)
    {
      if (!nz && !nz0)
	s = s00;
      goto ret;
    }
  e1 = e -= nf;

  /* Now we have nd0 digits, starting at s0, followed by a
   * decimal point, followed by nd-nd0 digits.  The number we're
   * after is the integer represented by those digits times
   * 10**e */

  if (!nd0)
    nd0 = nd;
  k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;
  rv.d = y;
  if (k > 9)
    rv.d = tens[k - 9] * rv.d + z;
  bd0 = 0;
  if (nd <= DBL_DIG
d438 3
a440 1
      && FLT_ROUNDS == 1
d442 5
a446 8
    )
    {
      if (!e)
	goto ret;
      if (e > 0)
	{
	  if (e <= Ten_pmax)
	    {
d448 1
a448 1
	      goto vax_ovfl_check;
d450 14
a463 8
	      /* rv.d = */ rounded_product (rv.d, tens[e]);
	      goto ret;
#endif
	    }
	  i = DBL_DIG - nd;
	  if (e <= Ten_pmax + i)
	    {
	      /* A fancier test would sometimes let us do
d466 9
a474 2
	      e -= i;
	      rv.d *= tens[i];
d476 16
a491 16
	      /* VAX exponent range is so narrow we must
	       * worry about overflow here...
	       */
	    vax_ovfl_check:
	      word0 (rv) -= P * Exp_msk1;
	      /* rv.d = */ rounded_product (rv.d, tens[e]);
	      if ((word0 (rv) & Exp_mask)
		  > Exp_msk1 * (DBL_MAX_EXP + Bias - 1 - P))
		goto ovfl;
	      word0 (rv) += P * Exp_msk1;
#else
	      /* rv.d = */ rounded_product (rv.d, tens[e]);
#endif
	      goto ret;
	    }
	}
d493 15
a507 25
      else if (e >= -Ten_pmax)
	{
	  /* rv.d = */ rounded_quotient (rv.d, tens[-e]);
	  goto ret;
	}
#endif
    }
  e1 += nd - k;

  /* Get starting approximation = rv.d * 10**e1 */

  if (e1 > 0)
    {
      if ((i = e1 & 15) != 0)
	rv.d *= tens[i];
      if (e1 &= ~15)
	{
	  if (e1 > DBL_MAX_10_EXP)
	    {
	    ovfl:
	      ptr->_errno = ERANGE;
#ifdef _HAVE_STDC
	      rv.d = HUGE_VAL;
#else
	      /* Can't trust HUGE_VAL */
d509 16
a524 8
	      word0 (rv) = Exp_mask;
#ifndef _DOUBLE_IS_32BITS
	      word1 (rv) = 0;
#endif
#else
	      word0 (rv) = Big0;
#ifndef _DOUBLE_IS_32BITS
	      word1 (rv) = Big1;
d526 12
d539 104
d644 40
a683 100
	      if (bd0)
		goto retfree;
	      goto ret;
	    }
	  if (e1 >>= 4)
	    {
	      for (j = 0; e1 > 1; j++, e1 >>= 1)
		if (e1 & 1)
		  rv.d *= bigtens[j];
	      /* The last multiplication could overflow. */
	      word0 (rv) -= P * Exp_msk1;
	      rv.d *= bigtens[j];
	      if ((z = word0 (rv) & Exp_mask)
		  > Exp_msk1 * (DBL_MAX_EXP + Bias - P))
		goto ovfl;
	      if (z > Exp_msk1 * (DBL_MAX_EXP + Bias - 1 - P))
		{
		  /* set to largest number */
		  /* (Can't trust DBL_MAX) */
		  word0 (rv) = Big0;
#ifndef _DOUBLE_IS_32BITS
		  word1 (rv) = Big1;
#endif
		}
	      else
		word0 (rv) += P * Exp_msk1;
	    }

	}
    }
  else if (e1 < 0)
    {
      e1 = -e1;
      if ((i = e1 & 15) != 0)
	rv.d /= tens[i];
      if (e1 &= ~15)
	{
	  e1 >>= 4;
	  if (e1 >= 1 << n_bigtens)
            goto undfl;
	  for (j = 0; e1 > 1; j++, e1 >>= 1)
	    if (e1 & 1)
	      rv.d *= tinytens[j];
	  /* The last multiplication could underflow. */
	  rv0.d = rv.d;
	  rv.d *= tinytens[j];
	  if (!rv.d)
	    {
	      rv.d = 2. * rv0.d;
	      rv.d *= tinytens[j];
	      if (!rv.d)
		{
		undfl:
		  rv.d = 0.;
		  ptr->_errno = ERANGE;
		  if (bd0)
		    goto retfree;
		  goto ret;
		}
#ifndef _DOUBLE_IS_32BITS
	      word0 (rv) = Tiny0;
	      word1 (rv) = Tiny1;
#else
	      word0 (rv) = Tiny1;
#endif
	      /* The refinement below will clean
	       * this approximation up.
	       */
	    }
	}
    }

  /* Now the hard part -- adjusting rv to the correct value.*/

  /* Put digits into bd: true value = bd * 10^e */

  bd0 = s2b (ptr, s0, nd0, nd, y);

  for (;;)
    {
      bd = Balloc (ptr, bd0->_k);
      Bcopy (bd, bd0);
      bb = d2b (ptr, rv.d, &bbe, &bbbits);	/* rv.d = bb * 2^bbe */
      bs = i2b (ptr, 1);

      if (e >= 0)
	{
	  bb2 = bb5 = 0;
	  bd2 = bd5 = e;
	}
      else
	{
	  bb2 = bb5 = -e;
	  bd2 = bd5 = 0;
	}
      if (bbe >= 0)
	bb2 += bbe;
      else
	bd2 -= bbe;
      bs2 = bb2;
d686 1
a686 1
      j = 1 + 4 * P - 3 - bbbits + ((bbe + bbbits - 1) & 3);
d688 1
a688 1
      j = P + 1 - bbbits;
d690 64
d755 1
a755 61
      i = bbe + bbbits - 1;	/* logb(rv.d) */
      if (i < Emin)		/* denormal */
	j = bbe + (P - Emin);
      else
	j = P + 1 - bbbits;
#endif
      bb2 += j;
      bd2 += j;
      i = bb2 < bd2 ? bb2 : bd2;
      if (i > bs2)
	i = bs2;
      if (i > 0)
	{
	  bb2 -= i;
	  bd2 -= i;
	  bs2 -= i;
	}
      if (bb5 > 0)
	{
	  bs = pow5mult (ptr, bs, bb5);
	  bb1 = mult (ptr, bs, bb);
	  Bfree (ptr, bb);
	  bb = bb1;
	}
      if (bb2 > 0)
	bb = lshift (ptr, bb, bb2);
      if (bd5 > 0)
	bd = pow5mult (ptr, bd, bd5);
      if (bd2 > 0)
	bd = lshift (ptr, bd, bd2);
      if (bs2 > 0)
	bs = lshift (ptr, bs, bs2);
      delta = diff (ptr, bb, bd);
      dsign = delta->_sign;
      delta->_sign = 0;
      i = cmp (delta, bs);
      if (i < 0)
	{
	  /* Error is less than half an ulp -- check for
	   * special case of mantissa a power of two.
	   */
	  if (dsign || word1 (rv) || word0 (rv) & Bndry_mask)
	    break;
	  delta = lshift (ptr, delta, Log2P);
	  if (cmp (delta, bs) > 0)
	    goto drop_down;
	  break;
	}
      if (i == 0)
	{
	  /* exactly half-way between */
	  if (dsign)
	    {
	      if ((word0 (rv) & Bndry_mask1) == Bndry_mask1
		  && word1 (rv) == 0xffffffff)
		{
		  /*boundary case -- increment exponent*/
		  word0 (rv) = (word0 (rv) & Exp_mask)
		    + Exp_msk1
#ifdef IBM
		    | Exp_msk1 >> 4
d757 12
a768 11
		    ;
#ifndef _DOUBLE_IS_32BITS
		  word1 (rv) = 0;
#endif
		  break;
		}
	    }
	  else if (!(word0 (rv) & Bndry_mask) && !word1 (rv))
	    {
	    drop_down:
	      /* boundary case -- decrement exponent */
d770 59
a828 3
	      L = word0 (rv) & Exp_mask;
#ifdef IBM
	      if (L < Exp_msk1)
d830 1
a830 1
	      if (L <= Exp_msk1)
a831 4
		goto undfl;
	      L -= Exp_msk1;
#else
	      L = (word0 (rv) & Exp_mask) - Exp_msk1;
d833 34
a866 3
	      word0 (rv) = L | Bndry_mask1;
#ifndef _DOUBLE_IS_32BITS
	      word1 (rv) = 0xffffffff;
d868 42
d911 1
a911 1
	      goto cont;
d913 1
a913 1
	      break;
d915 1
a915 1
	    }
d917 2
a918 2
	  if (!(word1 (rv) & LSB))
	    break;
d920 2
a921 2
	  if (dsign)
	    rv.d += ulp (rv.d);
d923 2
a924 3
	  else
	    {
	      rv.d -= ulp (rv.d);
d926 2
a927 2
	      if (!rv.d)
		goto undfl;
d929 3
a931 1
	    }
d933 7
a939 8
	  break;
	}
      if ((aadj = ratio (delta, bs)) <= 2.)
	{
	  if (dsign)
	    aadj = aadj1 = 1.;
	  else if (word1 (rv) || word0 (rv) & Bndry_mask)
	    {
d941 2
a942 2
	      if (word1 (rv) == Tiny1 && !word0 (rv))
		goto undfl;
d944 17
a960 19
	      aadj = 1.;
	      aadj1 = -1.;
	    }
	  else
	    {
	      /* special case -- power of FLT_RADIX to be */
	      /* rounded down... */

	      if (aadj < 2. / FLT_RADIX)
		aadj = 1. / FLT_RADIX;
	      else
		aadj *= 0.5;
	      aadj1 = -aadj;
	    }
	}
      else
	{
	  aadj *= 0.5;
	  aadj1 = dsign ? aadj : -aadj;
d962 47
a1008 42
	  switch (FLT_ROUNDS)
	    {
	    case 2:		/* towards +infinity */
	      aadj1 -= 0.5;
	      break;
	    case 0:		/* towards 0 */
	    case 3:		/* towards -infinity */
	      aadj1 += 0.5;
	    }
#else
	  if (FLT_ROUNDS == 0)
	    aadj1 += 0.5;
#endif
	}
      y = word0 (rv) & Exp_mask;

      /* Check for overflow */

      if (y == Exp_msk1 * (DBL_MAX_EXP + Bias - 1))
	{
	  rv0.d = rv.d;
	  word0 (rv) -= P * Exp_msk1;
	  adj = aadj1 * ulp (rv.d);
	  rv.d += adj;
	  if ((word0 (rv) & Exp_mask) >=
	      Exp_msk1 * (DBL_MAX_EXP + Bias - P))
	    {
	      if (word0 (rv0) == Big0 && word1 (rv0) == Big1)
		goto ovfl;
#ifdef _DOUBLE_IS_32BITS
	      word0 (rv) = Big1;
#else
	      word0 (rv) = Big0;
	      word1 (rv) = Big1;
#endif
	      goto cont;
	    }
	  else
	    word0 (rv) += P * Exp_msk1;
	}
      else
	{
d1010 5
a1014 6
	  if ((word0 (rv) & Exp_mask) <= P * Exp_msk1)
	    {
	      rv0.d = rv.d;
	      word0 (rv) += P * Exp_msk1;
	      adj = aadj1 * ulp (rv.d);
	      rv.d += adj;
d1016 1
a1016 1
	      if ((word0 (rv) & Exp_mask) < P * Exp_msk1)
d1018 69
a1086 1
	      if ((word0 (rv) & Exp_mask) <= P * Exp_msk1)
d1088 29
a1116 68
		{
		  if (word0 (rv0) == Tiny0
		      && word1 (rv0) == Tiny1)
		    goto undfl;
		  word0 (rv) = Tiny0;
		  word1 (rv) = Tiny1;
		  goto cont;
		}
	      else
		word0 (rv) -= P * Exp_msk1;
	    }
	  else
	    {
	      adj = aadj1 * ulp (rv.d);
	      rv.d += adj;
	    }
#else
	  /* Compute adj so that the IEEE rounding rules will
	   * correctly round rv.d + adj in some half-way cases.
	   * If rv.d * ulp(rv.d) is denormalized (i.e.,
	   * y <= (P-1)*Exp_msk1), we must adjust aadj to avoid
	   * trouble from bits lost to denormalization;
	   * example: 1.2e-307 .
	   */
	  if (y <= (P - 1) * Exp_msk1 && aadj >= 1.)
	    {
	      aadj1 = (double) (int) (aadj + 0.5);
	      if (!dsign)
		aadj1 = -aadj1;
	    }
	  adj = aadj1 * ulp (rv.d);
	  rv.d += adj;
#endif
	}
      z = word0 (rv) & Exp_mask;
      if (y == z)
	{
	  /* Can we stop now? */
	  L = aadj;
	  aadj -= L;
	  /* The tolerances below are conservative. */
	  if (dsign || word1 (rv) || word0 (rv) & Bndry_mask)
	    {
	      if (aadj < .4999999 || aadj > .5000001)
		break;
	    }
	  else if (aadj < .4999999 / FLT_RADIX)
	    break;
	}
    cont:
      Bfree (ptr, bb);
      Bfree (ptr, bd);
      Bfree (ptr, bs);
      Bfree (ptr, delta);
    }
retfree:
  Bfree (ptr, bb);
  Bfree (ptr, bd);
  Bfree (ptr, bs);
  Bfree (ptr, bd0);
  Bfree (ptr, delta);
ret:
  if (se)
    *se = (char *) s;

  if (nanflag)
    return nan (NULL);
  return (sign && (s != s00)) ? -rv.d : rv.d;
@


1.5
log
@
2005-01-06  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/strtod.c (_strtod_r): Add NaN support.
        * (strtof): Ditto.
        * libc/stdio/vfscanf.c (__svfscanf_r): Ditto.
        * Makefile.am (MATHOBJS_IN_LIBC): Add s_nan and sf_nan
        functions for use by strtod and strtof.
        * Makefile.in: Regenerated.
@
text
@d114 1
a114 1
  _CONST char *s, *s0, *s1;
d225 1
a225 1
      s00 = s;
d256 1
a256 1
	s = s00;
@


1.4
log
@
2002-12-06  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdlib.h (strtof): New prototype (from C99).
        (strtodf): Changed from prototype to macro which redefines
        to strtof.
        * libc/stdlib/atof.c: Change documentation to refer to strtof
        instead of strtodf.
        * libc/stdlib/atoff.c (atoff): Change to call strtof instead of
        strtodf.
        * libc/stdlib/strtod.c (strtodf): Renamed to strtof.
        (strtof): New function.
        * libm/test/convert.c (test_strtodf): Renamed to test_strtof which
        calls strtof.
@
text
@d120 1
d123 1
a123 1
  sign = nz0 = nz = 0;
d149 17
a165 1
  if (*s == '0')
d728 4
a731 1
  return sign ? -rv.d : rv.d;
d748 4
a751 1
  return (float)_strtod_r (_REENT, s00, se);
@


1.3
log
@
2001-04-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdio.h[!_REENT_ONLY]: Moved various functions together
        into one list.
        [!__STRICT_ANSI__]: Moved non-ANSI I/O functions in this list.
        (vfscanf, vscanf, vsscanf, _vfscanf_r, _vscanf_r, _vsscanf_r): New
        function prototypes.
        (_fscanf_r, _sscanf_r): Ditto.
        * libc/include/stdlib.h: Added _strtod_r prototype.
        * libc/stdio/Makefile.am: Add new v*scanf functions.
        * libc/stdio/Makefile.in: Regenerate.
        * libc/stdio/fscanf.c: Reorganized so HAVE_STDC only affects prototype
        and code is shared.  Added reentrant _fscanf_r which calls __svfscanf_r.        * libc/stdio/scanf.c: Changed to call __svfscanf_r.
        * libc/stdio/sscanf.c: Changed documentation to add reentrant routines.
        (sscanf): Changed to call __svfscanf_r with _REENT argument.
        (_sscanf_r): New routine.
        * libc/stdio/local.h: Removed __svfscanf prototype and replaced it
        with __svfscanf_r prototype.
        * libc/stdio/vfscanf.c (vfscanf, _vfscanf_r: New
        routines.
        (__svfscanf_r): Reentrant version of __svfscanf which takes reetrancy
        structure as argument as calls reentrant versions of helper functions
        (e.g. _strtol_r, _strtoul_r). Also replaced calls to atol and atof
        to _strtol_r and _strtod_r respectively.
        * libc/stdio/vfscanf.c: Also changed __svfscanf to call __svfscanf_r.
        * libc/stdlib/strtod.c (strtod): Changed to call _strtod_r with
        _REENT argument.
        * libc/stdio/vscanf.c: New file.
        * libc/stdio/vsscanf.c: Ditto.
@
text
@d3 1
a3 1
        <<strtod>>, <<strtodf>>---string to double or float
d10 1
a10 1
	strtodf
d15 1
a15 1
        float strtodf(const char *<[str]>, char **<[tail]>);
d26 1
a26 1
        float strtodf(<[str]>,<[tail]>)
d51 1
a51 1
	<<strtodf>> is identical to <<strtod>> except for its return type.
d724 1
a724 1
_DEFUN (strtodf, (s00, se),
d728 1
a728 1
  return _strtod_r (_REENT, s00, se);
@


1.2
log
@
Mon Apr 17 12:46:00 2000  Marek Michalkiewicz <marekm@@linux.org.pl>

        * libc/signal/signal.c (_signal_r) : Removed unused local variable temp.        * libc/stdio/findfp.c (std): Added declaration of flags and file.
        * libc/stdio/mktemp.c (_gettemp, _mkstemp_r, mkstemp): Added int
        return type.
        * libc/stdio/putchar.c (putchar): Added return statement.
        * libc/stdio/refill.c (lflush): Added correct parentheses.
        * libc/stdio/vfprintf.c (_VFPRINTF_R): Ditto.
        * libc/stdio/vfscanf.c (__svfscanf): Changed sprintf call which
        prints long value to use l qualifier.
        * libc/stdlib/dtoa.c (_dtoa_r): Added parentheses to remove warning
        messages and initialized local values: ilim, ilim1, and spec_case.
        * libc/stdlib/ecvtbuf.c (print_e): Removed unused variable dp.
        * libc/stdlib/mbctype.h (_issjis1, _issjis2): Added parentheses.
        * libc/stdlib/mprec.c: Ditto.
        * libc/stdlib/setenv_r.c: Ditto.
        * libc/stdlib/strtod.c: Ditto.
        * libc/stdlib/strtol.c: Ditto.
        * libc/stdlib/strtoul.c: Ditto.
        * libm/common/sf_expm1.c: Added curly braces to if else clauses.
        * libm/common/sf_log1p.c: Ditto.
        * libm/common/sf_scalbn.c: Ditto.
        * libm/math/ef_log.c: Ditto.
@
text
@d728 1
a728 1
  return strtod (s00, se);
@


1.1
log
@Initial revision
@
text
@d319 1
a319 1
      if (i = e1 & 15)
d376 1
a376 1
      if (i = e1 & 15)
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
