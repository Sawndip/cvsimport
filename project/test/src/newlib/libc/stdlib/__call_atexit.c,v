head	1.15;
access;
symbols
	cygwin-1_7_35-release:1.15
	cygwin-1_7_34-release:1.15
	newlib-2_2_0:1.15.0.2
	cygwin-1_7_33-release:1.15
	cygwin-1_7_32-release:1.15
	cygwin-1_7_31-release:1.15
	cygwin-1_7_30-release:1.15
	cygwin-1_7_29-release:1.15
	cygwin-1_7_28-release:1.15
	newlib-2_1_0:1.15
	cygwin-1_7_27-release:1.15
	cygwin-1_7_26-release:1.15
	cygwin-1_7_25-release:1.15
	cygwin-1_7_24-release:1.15
	cygwin-1_7_23-release:1.15
	cygwin-1_7_22-release:1.15
	cygwin-1_7_21-release:1.15
	cygwin-1_7_20-release:1.15
	cygwin-1_7_19-release:1.15
	cygwin-64bit-postmerge:1.12
	cygwin-64bit-premerge-branch:1.12.0.4
	cygwin-64bit-premerge:1.12
	cygwin-1_7_18-release:1.12
	newlib-2_0_0:1.12
	cygwin-1_7_17-release:1.12
	cygwin-64bit-branch:1.12.0.2
	cygwin-1_7_16-release:1.12
	cygwin-1_7_15-release:1.12
	cygwin-1_7_14_2-release:1.12
	cygwin-1_7_14-release:1.12
	cygwin-1_7_12-release:1.12
	cygwin-1_7_11-release:1.12
	cygwin-1_7_10-release:1.12
	newlib-1_20_0:1.12
	cygwin-1_7_9-release:1.12
	cygwin-1_7_8-release:1.12
	newlib-1_19_0:1.12
	cygwin-1_7_7-release:1.12
	cygwin-1_7_5-release:1.9
	cygwin-1_7_4-release:1.9
	cygwin-1_7_3-release:1.8
	cygwin-1_7_2-release:1.8
	newlib-1_18_0:1.6
	cygwin-1_7_1-release:1.6
	newlib-1_17_0-arc:1.5.0.4
	binutils-arc-20080908-branch:1.5.0.2
	binutils-arc-20080908-branchpoint:1.5
	newlib-1_17_0:1.5
	newlib-1_16_0:1.5
	newlib-1_15_0:1.4
	newlib-csl-coldfire-4_1-32:1.4.2.1
	newlib-csl-sourcerygxx-4_1-32:1.4.2.1
	newlib-csl-innovasic-fido-3_4_4-33:1.4.2.1
	newlib-csl-coldfire-4_1-30:1.4.2.1
	newlib-csl-sourcerygxx-4_1-30:1.4.2.1
	newlib-csl-coldfire-4_1-28:1.4.2.1
	newlib-csl-sourcerygxx-4_1-28:1.4.2.1
	newlib-csl-arm-2006q3-27:1.4.2.1
	newlib-csl-sourcerygxx-4_1-27:1.4.2.1
	newlib-csl-arm-2006q3-26:1.4.2.1
	newlib-csl-sourcerygxx-4_1-26:1.4.2.1
	newlib-csl-sourcerygxx-4_1-24:1.4.2.1
	newlib-csl-sourcerygxx-4_1-23:1.4.2.1
	newlib-csl-sourcerygxx-4_1-21:1.4.2.1
	newlib-csl-arm-2006q3-21:1.4.2.1
	newlib-csl-arm-2006q3-19:1.4.2.1
	newlib-csl-sourcerygxx-4_1-19:1.4.2.1
	newlib-csl-sourcerygxx-4_1-18:1.4.2.1
	newlib-csl-sourcerygxx-3_4_4-25:1.4
	newlib-csl-sourcerygxx-4_1-17:1.4
	cr-0x5f1:1.4.0.6
	newlib-csl-sourcerygxx-4_1-14:1.4
	newlib-csl-sourcerygxx-4_1-13:1.4
	newlib-csl-sourcerygxx-4_1-12:1.4
	newlib-csl-sourcerygxx-4_1-9:1.4
	newlib-csl-sourcerygxx-4_1-8:1.4
	newlib-csl-sourcerygxx-4_1-7:1.4
	newlib-csl-arm-2006q1-6:1.4
	newlib-csl-sourcerygxx-4_1-6:1.4
	newlib-csl-sourcerygxx-4_1-5:1.4
	newlib-csl-sourcerygxx-4_1-4:1.4
	newlib-autotools-branch:1.4.0.4
	newlib-csl-20060320-branch:1.4.0.2
	newlib-csl-20060320-branchpoint:1.4
	newlib-1_14_0:1.3
	newlib-csl-arm-2005-q1b:1.3
	newlib-csl-arm-2005-q1a:1.3
	newlib-1_13_0:1.3
	csl-arm-2004-q3:1.3;
locks; strict;
comment	@ * @;


1.15
date	2013.05.08.23.13.51;	author jjohnstn;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.07.21.40.10;	author jjohnstn;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.07.18.24.14;	author jjohnstn;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.08.18.44.14;	author jjohnstn;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.04.15.30.40;	author jjohnstn;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.11.20.41.37;	author jjohnstn;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.06.20.20.36;	author jjohnstn;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.24.19.58.17;	author jjohnstn;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.04.17.57.30;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.23.17.54.22;	author jjohnstn;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.05.16.47.38;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.21.00.57.34;	author mmitchel;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2004.09.15.20.50.07;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.14.18.12.52;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2004.09.09.19.46.54;	author jjohnstn;	state Exp;
branches;
next	;

1.4.2.1
date	2006.08.29.21.53.31;	author pbrook;	state Exp;
branches;
next	;


desc
@@


1.15
log
@
2013-05-07  Sebastian Huber <sebastian.huber@@embedded-brains.de>

        * libc/include/sys/config.h (_REENT_GLOBAL_ATEXIT): Define for
        RTEMS.
        * libc/include/sys/reent.h (_reent): Use _REENT_GLOBAL_ATEXIT.
        (_global_atexit): Declare if _REENT_GLOBAL_ATEXIT is defined.
        * libc/reent/reent.c (_reclaim_reent): Remove atexit cleanup if
        _REENT_GLOBAL_ATEXIT is defined.
        (_wrapup_reent): Remove atexit handling if _REENT_GLOBAL_ATEXIT
        is defined.
        * libc/stdlib/__atexit.c (_global_atexit0): Define if
        _REENT_GLOBAL_ATEXIT is defined.
        * libc/stdlib/__call_atexit.c (_global_atexit): Define if
        _REENT_GLOBAL_ATEXIT is defined.
@
text
@/*
 * COmmon routine to call call registered atexit-like routines.
 */


#include <stdlib.h>
#include <reent.h>
#include <sys/lock.h>
#include "atexit.h"

/* Make this a weak reference to avoid pulling in free.  */
void free(void *) _ATTRIBUTE((__weak__));

__LOCK_INIT_RECURSIVE(, __atexit_lock);

#ifdef _REENT_GLOBAL_ATEXIT
struct _atexit *_global_atexit = _NULL;
#endif

#ifdef _WANT_REGISTER_FINI

/* If "__libc_fini" is defined, finalizers (either
   "__libc_fini_array", or "_fini", as appropriate) will be run after
   all user-specified atexit handlers.  For example, you can define
   "__libc_fini" to "_fini" in your linker script if you want the C
   library, rather than startup code, to register finalizers.  If you
   do that, then your startup code need not contain references to
   "atexit" or "exit".  As a result, only applications that reference
   "exit" explicitly will pull in finalization code.

   The choice of whether to register finalizers from libc or from
   startup code is deferred to link-time, rather than being a
   configure-time option, so that the same C library binary can be
   used with multiple BSPs, some of which register finalizers from
   startup code, while others defer to the C library.  */
extern char __libc_fini __attribute__((weak));

/* Register the application finalization function with atexit.  These
   finalizers should run last.  Therefore, we want to call atexit as
   soon as possible.  */
static void 
register_fini(void) __attribute__((constructor (0)));

static void 
register_fini(void)
{
  if (&__libc_fini) {
#ifdef HAVE_INITFINI_ARRAY
    extern void __libc_fini_array (void);
    atexit (__libc_fini_array);
#else
    extern void _fini (void);
    atexit (_fini);
#endif
  }
}

#endif /* _WANT_REGISTER_FINI  */

/*
 * Call registered exit handlers.  If D is null then all handlers are called,
 * otherwise only the handlers from that DSO are called.
 */

void 
_DEFUN (__call_exitprocs, (code, d),
	int code _AND _PTR d)
{
  register struct _atexit *p;
  struct _atexit **lastp;
  register struct _on_exit_args * args;
  register int n;
  int i;
  void (*fn) (void);


#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

 restart:

  p = _GLOBAL_ATEXIT;
  lastp = &_GLOBAL_ATEXIT;
  while (p)
    {
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
#endif
      for (n = p->_ind - 1; n >= 0; n--)
	{
	  int ind;

	  i = 1 << n;

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
	    continue;

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
	  if (n == p->_ind - 1)
	    p->_ind--;
	  else
	    p->_fns[n] = NULL;

	  /* Skip functions that have already been called.  */
	  if (!fn)
	    continue;

	  ind = p->_ind;

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
	    fn ();
	  else if ((args->_is_cxa & i) == 0)
	    (*((void (*)(int, _PTR)) fn))(code, args->_fnargs[n]);
	  else
	    (*((void (*)(_PTR)) fn))(args->_fnargs[n]);

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
	    goto restart;
	}

#ifndef _ATEXIT_DYNAMIC_ALLOC
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
	break;

      /* Move to the next block.  Free empty blocks except the last one,
	 which is part of _GLOBAL_REENT.  */
      if (p->_ind == 0 && p->_next)
	{
	  /* Remove empty block from the list.  */
	  *lastp = p->_next;
#ifdef _REENT_SMALL
	  if (args)
	    free (args);
#endif
	  free (p);
	  p = *lastp;
	}
      else
	{
	  lastp = &p->_next;
	  p = p->_next;
	}
#endif
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif

}
@


1.14
log
@
2013-05-07  Sebastian Huber <sebastian.huber@@embedded-brains.de>

	* libc/include/sys/reent.h (_ATEXIT_INIT): Define.
	(_ATEXIT_INIT_PTR): Likewise.
	(_REENT_INIT_ATEXIT): Likewise.
	(_REENT_INIT_ATEXIT_PTR): Likewise.
	(_GLOBAL_ATEXIT): Likewise.
	* libc/stdlib/__atexit.c (_GLOBAL_ATEXIT0): Define.
	(__register_exitproc): Use _GLOBAL_ATEXIT and _GLOBAL_ATEXIT0.
	* libc/stdlib/__call_atexit.c (__call_exitprocs): Likewise.
-
@
text
@d16 4
@


1.13
log
@
2013-05-07  Sebastian Huber <sebastian.huber@@embedded-brains.de>

        * libc/stdlib/__atexit.c (__atexit_lock): Declare.
        * libc/stdlib/__call_atexit.c (__atexit_lock): Define.
@
text
@d79 2
a80 2
  p = _GLOBAL_REENT->_atexit;
  lastp = &_GLOBAL_REENT->_atexit;
@


1.12
log
@
2010-06-08  Jeff Johnston  <jjohnstn@@redhat.com>

        * configure.in: Add test for enable-newlib-register-fini
        to set the _WANT_REGISTER_FINI flag.
        * configure: Regenerated.
        * Makefile.in: Ditto.
        * newlib.hin: Add _WANT_REGISTER_FINI flag.
        * libc/stdlib/__call_atexit.c: Add test for
        _WANT_REGISTER_FINI to enable the register_fini function.
@
text
@d14 1
a14 3
#ifndef __SINGLE_THREAD__
extern _LOCK_RECURSIVE_T __atexit_lock;
#endif
@


1.11
log
@
2010-06-04  Mark Mitchell  <mark@@codesourcery.com>

        * libc/stdlib/__call_atexit.c (__libc_fini): Declare.
        (register_fini): New function.
        * libc/misc/init.c (_fini): Remove.
        (__libc_fini_array): Likewise.
        * libc/misc/fini.c: New file.
        * libc/misc/Makefile.am (LIB_SOURCES): Add fini.c.
        * libc/misc/Makefile.in: Regenerate.
@
text
@d18 2
d56 2
@


1.10
log
@
2010-05-11  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/__call_atexit.c: Fix lock to be of type
        _LOCK_RECURSIVE_T as recursive usage is needed.
@
text
@d18 36
@


1.9
log
@
2010-04-06  Dave Korn  <dave.korn.cygwin@@googlemail.com>

        * libc/stdlib/__atexit.c (__atexit_lock): Initialise as recursive
        rather than non-recursive lock type.
        (__register_exitproc): Use recursive locking APIs on it.
        * libc/stdlib/__call_atexit.c (__call_exitprocs): Likewise.
@
text
@d15 1
a15 1
extern _LOCK_T __atexit_lock;
@


1.8
log
@
2010-02-24  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/__call_exit.c: Add include of sys/lock.h.
@
text
@d36 1
a36 1
  __lock_acquire(__atexit_lock);
d118 1
a118 1
  __lock_release(__atexit_lock);
@


1.7
log
@* libc/stdlib/__atexit.c (__atexit_lock): Define a global lock for atexit
functions.
(__register_exitproc): Use __atexit_lock rather than a local static lock.
* libc/stdlib/__call_atexit.c: Ditto.
@
text
@d8 1
@


1.6
log
@
2009-04-23  Paul Brook  <paul@@codesourcery.com>
            Kazu Hirata  <kazu@@codesourcery.com>

        * libc/stdlib/__atexit.c (__register_exitproc): Use weak reference
        to malloc.  Allocate dynamically only if it is present.
        * libc/stdlib/__call_atexit.c (__call_exitprocs): Use weak
        reference to free.  Call free only if it is present.
@
text
@d13 4
d33 5
d116 4
@


1.5
log
@	* libc/stdlib/__call_atexit.c (__call_exitprocs): Handle atexit
	functions registering additional atexit functions.
@
text
@d10 3
d82 5
@


1.4
log
@	* acconfig.h (_ATEXIT_DYNAMIC_ALLOC): Undef.
	* configure.in (--disable-newlib-atexit-dynamic-alloc): New
	option.
	* configure: Regenerated.
	* newlib.hin: Regenerated.
	* libc/stdlib/__atexit.c (__register_exitproc): Don't call malloc
	if _ATEXIT_DYNAMIC_ALLOC is undefined.
	* libc/stdlib/__call_atexit.c (__call_exitprocs): Don't call free
	if _ATEXIT_DYNAMIC_ALLOC is undefined.
@
text
@d26 2
d39 2
d59 2
d68 6
@


1.4.2.1
log
@2006-08-29  Paul Brook  <paul@@codesourcery.com>

	newlib/
	* acconfig.h (_ATEXIT_DYNAMIC_ALLOC): Remove.
	* configure.in: Remove --disable-newlib-atexit-dynamic-alloc.
	* libc/stdlib/__atexit.c (__register_exitproc): Use weak reference to
	malloc.  Only allocate dynamically if it is present.
	* libc/stdlib/__call_atexit.c (__call_exitprocs): Use weak reference
	to free.
	* configure: Regenerate.
	* newlib.hin: Regenerate.
@
text
@a14 3
/* Make this a weak reference to avoid pulling in malloc.  */
void free(void *) __attribute__((weak));

d64 3
a66 3
      if (!free)
	break;

d85 1
@


1.3
log
@
2004-09-15  Jeff Johnston  <jjohnstn@@redhat.com>

        * configure.host: Reverting 2004-09-14 change as fix has occurred on
        Cygwin side.
        * configure.in: Ditto.
        * libc/configure.in: Ditto.
        * libc/sys/configure.in: Ditto.
        * configure: Ditto.
        * libc/configure: Ditto.
        * libc/sys/configure: Ditto.
        * libc/include/sys/reent.h: Ditto.
        * libc/stdlib/__atexit.c: Ditto.
        * libc/stdlib/__call_atexit.c: Ditto.
        * libc/stdlib/cxa_atexit.c: Ditto.
        * libc/stdlib/cxa_finalize.c: Ditto.
        * libc/sys/cygwin/Makefile.am: Removed again.
        * libc/sys/cygwin/Makefile.in: Ditto.
        * libc/sys/cygwin/aclocal.m4: Ditto.
        * libc/sys/cygwin/configure: Ditto.
        * libc/sys/cygwin/configure.in: Ditto.
        * libc/sys/cygwin/dummy.c: Ditto.
        * libc/sys/cygwin/sys/reent.h: Ditto.
@
text
@d64 3
d85 1
@


1.2
log
@
2004-09-14  Jeff Johnston  <jjohnstn@@redhat.com>

        * configure.host: Add Cygwin sys directory.
        * configure.in: Do not set CRT0 for cygwin.
        * libc/configure.in: Ditto.
        * libc/sys/configure.in: Ditto.
        * configure: Regenerated.
        * libc/configure: Ditto.
        * libc/sys/configure: Ditto.
        * libc/include/sys/reent.h: Add __REENT_HAS_CXA_SUPPORT flag.
        * libc/stdlib/__atexit.c: Keep cxa support protected by new
        __REENT_HAS_CXA_SUPPORT flag.
        * libc/stdlib/__call_atexit.c: Ditto.
        * libc/stdlib/cxa_atexit.c: Ditto.
        * libc/stdlib/cxa_finalize.c: Ditto.
        * libc/sys/cygwin/Makefile.am: New file.
        * libc/sys/cygwin/Makefile.in: Ditto.
        * libc/sys/cygwin/aclocal.m4: Ditto.
        * libc/sys/cygwin/configure: Ditto.
        * libc/sys/cygwin/configure.in: Ditto.
        * libc/sys/cygwin/dummy.c: Ditto.
        * libc/sys/cygwin/sys/reent.h: Ditto.  This file is stabilized
        version of reent.h.
@
text
@a38 1
#ifdef __REENT_HAS_CXA_SUPPORT
a41 1
#endif
a57 1
#ifdef __REENT_HAS_CXA_SUPPORT
a59 1
#endif
@


1.1
log
@
2004-09-09  Paul Brook  <paul@@codesourcery.com>

        * libc/include/sys/reent.h (struct _on_exit_args): Add _dso_handle
        and _is_cxa.
        (struct _atexit): Add _next when _REENT_SMALL.
        (struct _reent): Add _atexit0 when _REENT_SMALL.
        (_REENT_INIT_PTR): Adjust.
        * libc/stdlib/Makefile.am (GENERAL_SOURCES): Add __atexit.c and
        __call_exit.c.
        (EXTENDED_SOURCES): Add cxa_atexit.c and cxa_finalize.c.
        * libc/stdlib/Makefile.in: Regenerate.
        * libc/stdlib/__atexit.c: New file.
        * libc/stdlib/__call_atexit.c: New file.
        * libc/stdlib/atexit.h: Remove old definitions.  Add new.
        * libc/stdlib/atexit.c (atexit): Use __register_exitproc.
        * libc/stdlib/cxa_atexit.c: New file.
        * libc/stdlib/cxa_finalize.c: New file.
        * libc/stdlib/exit.c (exit): Use __call_exitprocs.
        * libc/stdlib/on_exit.c (on_exit): Use __register_exitproc.
        2004-09-09  Jeff Johnston  <jjohnstn@@redhat.com>
        * libc/reent/reent.c [_REENT_SMALL]: Fix reference to
        _on_exit_args_ptr.
@
text
@d39 1
d43 1
d60 1
d63 1
@

