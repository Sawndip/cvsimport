head	1.3;
access;
symbols
	cygwin-1_7_35-release:1.3
	cygwin-1_7_34-release:1.3
	newlib-2_2_0:1.3.0.2
	cygwin-1_7_33-release:1.3
	cygwin-1_7_32-release:1.3
	cygwin-1_7_31-release:1.3
	cygwin-1_7_30-release:1.3
	cygwin-1_7_29-release:1.3
	cygwin-1_7_28-release:1.3
	newlib-2_1_0:1.3
	cygwin-1_7_27-release:1.3
	cygwin-1_7_26-release:1.3
	cygwin-1_7_25-release:1.3
	cygwin-1_7_24-release:1.3
	cygwin-1_7_23-release:1.3
	cygwin-1_7_22-release:1.3
	cygwin-1_7_21-release:1.3
	cygwin-1_7_20-release:1.3
	cygwin-1_7_19-release:1.3
	cygwin-64bit-postmerge:1.2
	cygwin-64bit-premerge-branch:1.2.0.14
	cygwin-64bit-premerge:1.2
	cygwin-1_7_18-release:1.2
	newlib-2_0_0:1.2
	cygwin-1_7_17-release:1.2
	cygwin-64bit-branch:1.2.0.12
	cygwin-1_7_16-release:1.2
	cygwin-1_7_15-release:1.2
	cygwin-1_7_14_2-release:1.2
	cygwin-1_7_14-release:1.2
	cygwin-1_7_12-release:1.2
	cygwin-1_7_11-release:1.2
	cygwin-1_7_10-release:1.2
	newlib-1_20_0:1.2
	cygwin-1_7_9-release:1.2
	cygwin-1_7_8-release:1.2
	newlib-1_19_0:1.2
	cygwin-1_7_7-release:1.2
	cygwin-1_7_5-release:1.2
	cygwin-1_7_4-release:1.2
	cygwin-1_7_3-release:1.2
	cygwin-1_7_2-release:1.2
	newlib-1_18_0:1.2
	cygwin-1_7_1-release:1.2
	newlib-1_17_0-arc:1.2.0.10
	binutils-arc-20080908-branch:1.2.0.8
	binutils-arc-20080908-branchpoint:1.2
	newlib-1_17_0:1.2
	newlib-1_16_0:1.2
	newlib-1_15_0:1.2
	newlib-csl-coldfire-4_1-32:1.2
	newlib-csl-sourcerygxx-4_1-32:1.2
	newlib-csl-innovasic-fido-3_4_4-33:1.2
	newlib-csl-coldfire-4_1-30:1.2
	newlib-csl-sourcerygxx-4_1-30:1.2
	newlib-csl-coldfire-4_1-28:1.2
	newlib-csl-sourcerygxx-4_1-28:1.2
	newlib-csl-arm-2006q3-27:1.2
	newlib-csl-sourcerygxx-4_1-27:1.2
	newlib-csl-arm-2006q3-26:1.2
	newlib-csl-sourcerygxx-4_1-26:1.2
	newlib-csl-sourcerygxx-4_1-24:1.2
	newlib-csl-sourcerygxx-4_1-23:1.2
	newlib-csl-sourcerygxx-4_1-21:1.2
	newlib-csl-arm-2006q3-21:1.2
	newlib-csl-arm-2006q3-19:1.2
	newlib-csl-sourcerygxx-4_1-19:1.2
	newlib-csl-sourcerygxx-4_1-18:1.2
	newlib-csl-sourcerygxx-3_4_4-25:1.2
	newlib-csl-sourcerygxx-4_1-17:1.2
	cr-0x5f1:1.2.0.6
	newlib-csl-sourcerygxx-4_1-14:1.2
	newlib-csl-sourcerygxx-4_1-13:1.2
	newlib-csl-sourcerygxx-4_1-12:1.2
	newlib-csl-sourcerygxx-4_1-9:1.2
	newlib-csl-sourcerygxx-4_1-8:1.2
	newlib-csl-sourcerygxx-4_1-7:1.2
	newlib-csl-arm-2006q1-6:1.2
	newlib-csl-sourcerygxx-4_1-6:1.2
	newlib-csl-sourcerygxx-4_1-5:1.2
	newlib-csl-sourcerygxx-4_1-4:1.2
	newlib-autotools-branch:1.2.0.4
	newlib-csl-20060320-branch:1.2.0.2
	newlib-csl-20060320-branchpoint:1.2
	newlib-1_14_0:1.2
	newlib-csl-arm-2005-q1b:1.2
	newlib-csl-arm-2005-q1a:1.2
	newlib-1_13_0:1.2
	csl-arm-2004-q3:1.2
	csl-arm-2004-q1a:1.2
	csl-arm-2004-q1:1.2
	newlib-1_12_0:1.2
	csl-arm-2003-q4:1.2
	w32api-2_2:1.2
	mingw-runtime-2_4:1.2
	newlib-1_11_0:1.2
	cygnus_cvs_20020108_pre:1.2
	newlib-1_10_0:1.2
	newlib-1_9_0:1.2
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2013.04.29.21.06.23;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.17.17.10.17;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.3
log
@
2013-04-29  Sebastian Huber <sebastian.huber@@embedded-brains.de>

	* libc/stdio/local.h (CHECK_INIT): Evaluate argument only once.
	(CHECK_STD_INIT): Likewise.
	* libc/stdio/fgetc.c (fgetc): Use local variable for _REENT.
	* libc/stdio/fgetwc.c (fwgetc): Likewise.
	* libc/stdio/fgetws.c (fgetws): Likewise.
	* libc/stdio/fputc.c (fputc): Likewise.
	* libc/stdio/fputwc.c (fputwc): Likewise.
	* libc/stdio/fputws.c (fputws): Likewise.
	* libc/stdio/getc.c (getc): Likewise.
	* libc/stdio/getchar.c (_getchar_r): Likewise.
	* libc/stdio/putc.c (putc): Likewise.
	* libc/stdio/putchar.c (putchar): Likewise.
	* libc/stdio/scanf.c (scanf): Likewise.
	* libc/stdio/setvbuf.c (setvbuf): Likewise.
	* libc/stdio/ungetwc.c (ungetwc): Likewise.
	* libc/stdio/vfscanf.c (VFSCANF): Likewise.
	* libc/stdio/vfwscanf.c (VFWSCANF): Likewise.
	* libc/stdio/viprintf.c (viprintf): Likewise.
	* libc/stdio/viscanf.c (viscanf): Likewise.
	* libc/stdio/vprintf.c (vprintf): Likewise.
	* libc/stdio/vscanf.c (vscanf): Likewise.
	* libc/stdio/vwprintf.c (vwprintf): Likewise.
	* libc/stdio/vwscanf.c (vwscanf): Likewise.
	* libc/stdio/wscanf.c (wscanf): Likewise.
	* libc/stdlib/ecvtbuf.c (fcvtbuf): Likewise.
	(fcvtbuf): Likewise.
	(ecvtbuf): Likewise.
	(ecvtbuf): Likewise.
	* libc/stdlib/mblen.c (mblen): Likewise.
	* libc/stdlib/mbrlen.c (mbrlen): Likewise.
	* libc/stdlib/mbrtowc.c (mbrtowc): Likewise.
	* libc/stdlib/mbtowc.c (mbtowc): Likewise.
	* libc/stdlib/rand.c (srand): Likewise.
	(rand): Likewise.
	* libc/stdlib/wcrtomb.c (wcrtomb): Likewise.
	* libc/stdlib/wctob.c (wctob): Likewise.
	* libc/stdlib/wctomb.c (wctomb): Likewise.
	* libc/string/strtok.c (strtok): Likewise.
	* libc/time/asctime.c (asctime): Likewise.
	* libc/time/gmtime.c (gmtime): Likewise.
	* libc/time/lcltime.c (lcltime): Likewise.
@
text
@/*
FUNCTION
<<ecvtbuf>>, <<fcvtbuf>>---double or float to string

INDEX
	ecvtbuf
INDEX
	fcvtbuf

ANSI_SYNOPSIS
	#include <stdio.h>

	char *ecvtbuf(double <[val]>, int <[chars]>, int *<[decpt]>,
                       int *<[sgn]>, char *<[buf]>);

	char *fcvtbuf(double <[val]>, int <[decimals]>, int *<[decpt]>,
                       int *<[sgn]>, char *<[buf]>);

TRAD_SYNOPSIS
	#include <stdio.h>

	char *ecvtbuf(<[val]>, <[chars]>, <[decpt]>, <[sgn]>, <[buf]>);
	double <[val]>;
	int <[chars]>;
	int *<[decpt]>;
	int *<[sgn]>;
	char *<[buf]>;

	char *fcvtbuf(<[val]>, <[decimals]>, <[decpt]>, <[sgn]>, <[buf]>);
	double <[val]>;
	int <[decimals]>;
	int *<[decpt]>;
	int *<[sgn]>;
	char *<[buf]>;

DESCRIPTION
	<<ecvtbuf>> and <<fcvtbuf>> produce (null-terminated) strings
	of digits representating the <<double>> number <[val]>.

	The only difference between <<ecvtbuf>> and <<fcvtbuf>> is the
	interpretation of the second argument (<[chars]> or
	<[decimals]>). For <<ecvtbuf>>, the second argument <[chars]>
	specifies the total number of characters to write (which is
	also the number of significant digits in the formatted string,
	since these two functions write only digits). For <<fcvtbuf>>,
	the second argument <[decimals]> specifies the number of
	characters to write after the decimal point; all digits for
	the integer part of <[val]> are always included.

	Since <<ecvtbuf>> and <<fcvtbuf>> write only digits in the
	output string, they record the location of the decimal point
	in <<*<[decpt]>>>, and the sign of the number in <<*<[sgn]>>>.
	After formatting a number, <<*<[decpt]>>> contains the number
	of digits to the left of the decimal point.  <<*<[sgn]>>>
	contains <<0>> if the number is positive, and <<1>> if it is
	negative.  For both functions, you supply a pointer <[buf]> to
	an area of memory to hold the converted string.

RETURNS
	Both functions return a pointer to <[buf]>, the string
	containing a character representation of <[val]>.

PORTABILITY
	Neither function is ANSI C.

Supporting OS subroutines required: <<close>>, <<fstat>>, <<isatty>>,
<<lseek>>, <<read>>, <<sbrk>>, <<write>>.
*/

#include <_ansi.h>
#include <stdlib.h>
#include <string.h>
#include <reent.h>
#include "mprec.h"
#include "local.h"

static void
_DEFUN (print_f, (ptr, buf, invalue, ndigit, type, dot, mode),
	struct _reent *ptr _AND
	char *buf _AND
	double invalue _AND
	int ndigit _AND
	char type _AND
	int dot _AND
	int mode)
{
  int decpt;
  int sign;
  char *p, *start, *end;

  start = p = _dtoa_r (ptr, invalue, mode, ndigit, &decpt, &sign, &end);

  if (decpt == 9999)
    {
      strcpy (buf, p);
      return;
    }
  while (*p && decpt > 0)
    {
      *buf++ = *p++;
      decpt--;
    }
  /* Even if not in buffer */
  while (decpt > 0)
    {
      *buf++ = '0';
      decpt--;
    }

  if (dot || *p)
    {
      if (p == start)
	*buf++ = '0';
      *buf++ = '.';
      while (decpt < 0 && ndigit > 0)
	{
	  *buf++ = '0';
	  decpt++;
	  ndigit--;
	}

      /* Print rest of stuff */
      while (*p && ndigit > 0)
	{
	  *buf++ = *p++;
	  ndigit--;
	}
      /* And trailing zeros */
      while (ndigit > 0)
	{
	  *buf++ = '0';
	  ndigit--;
	}
    }
  *buf++ = 0;
}

/* Print number in e format with width chars after.

   TYPE is one of 'e' or 'E'.  It may also be one of 'g' or 'G' indicating
   that _gcvt is calling us and we should remove trailing zeroes.

   WIDTH is the number of digits of precision after the decimal point.  */

static void
_DEFUN (print_e, (ptr, buf, invalue, width, type, dot),
	struct _reent *ptr _AND
	char *buf _AND
	double invalue _AND
	int width _AND
	char type _AND
	int dot)
{
  int sign;
  char *end;
  char *p;
  int decpt;
  int top;
  int ndigit = width;

  p = _dtoa_r (ptr, invalue, 2, width + 1, &decpt, &sign, &end);

  if (decpt == 9999)
    {
      strcpy (buf, p);
      return;
    }

  *buf++ = *p++;
  if (dot || ndigit != 0)
    *buf++ = '.';

  while (*p && ndigit > 0)
    {
      *buf++ = *p++;
      ndigit--;
    }

  /* Add trailing zeroes to fill out to ndigits unless this is 'g' format.
     Also, convert g/G to e/E.  */

  if (type == 'g')
    type = 'e';
  else if (type == 'G')
    type = 'E';
  else
    {
      while (ndigit > 0)
	{
	  *buf++ = '0';
	  ndigit--;
	}
    }

  /* Add the exponent.  */

  *buf++ = type;
  decpt--;
  if (decpt < 0)
    {
      *buf++ = '-';
      decpt = -decpt;
    }
  else
    {
      *buf++ = '+';
    }
  if (decpt > 99)
    {
      int top = decpt / 100;
      *buf++ = top + '0';
      decpt -= top * 100;
    }
  top = decpt / 10;
  *buf++ = top + '0';
  decpt -= top * 10;
  *buf++ = decpt + '0';

  *buf++ = 0;
}

#ifndef _REENT_ONLY

/* Undocumented behaviour: when given NULL as a buffer, return a
   pointer to static space in the rent structure.  This is only to
   support ecvt and fcvt, which aren't ANSI anyway.  */

char *
_DEFUN (fcvtbuf, (invalue, ndigit, decpt, sign, fcvt_buf),
	double invalue _AND
	int ndigit _AND
	int *decpt _AND
	int *sign _AND
	char *fcvt_buf)
{
  struct _reent *reent = _REENT;
  char *save;
  char *p;
  char *end;
  int done = 0;

  if (fcvt_buf == NULL)
    {
      if (reent->_cvtlen <= ndigit + 35)
	{
	  if ((fcvt_buf = (char *) _realloc_r (reent, reent->_cvtbuf,
					       ndigit + 36)) == NULL)
	    return NULL;
	  reent->_cvtlen = ndigit + 36;
	  reent->_cvtbuf = fcvt_buf;
	}

      fcvt_buf = reent->_cvtbuf ;
    }

  save = fcvt_buf;

  if (invalue < 1.0 && invalue > -1.0)
    {
      p = _dtoa_r (reent, invalue, 2, ndigit, decpt, sign, &end);
    }
  else
    {
      p = _dtoa_r (reent, invalue, 3, ndigit, decpt, sign, &end);
    }

  /* Now copy */

  done = -*decpt;
  while (p < end)
    {
      *fcvt_buf++ = *p++;
      done++;
    }
  /* And unsuppress the trailing zeroes */
  while (done < ndigit)
    {
      *fcvt_buf++ = '0';
      done++;
    }
  *fcvt_buf++ = 0;
  return save;
}

char *
_DEFUN (ecvtbuf, (invalue, ndigit, decpt, sign, fcvt_buf),
	double invalue _AND
	int ndigit _AND
	int *decpt _AND
	int *sign _AND
	char *fcvt_buf)
{
  struct _reent *reent = _REENT;
  char *save;
  char *p;
  char *end;
  int done = 0;

  if (fcvt_buf == NULL)
    {
      if (reent->_cvtlen <= ndigit)
	{
	  if ((fcvt_buf = (char *) _realloc_r (reent, reent->_cvtbuf,
					       ndigit + 1)) == NULL)
	    return NULL;
	  reent->_cvtlen = ndigit + 1;
	  reent->_cvtbuf = fcvt_buf;
	}

      fcvt_buf = reent->_cvtbuf ;
    }

  save = fcvt_buf;

  p = _dtoa_r (reent, invalue, 2, ndigit, decpt, sign, &end);

  /* Now copy */

  while (p < end)
    {
      *fcvt_buf++ = *p++;
      done++;
    }
  /* And unsuppress the trailing zeroes */
  while (done < ndigit)
    {
      *fcvt_buf++ = '0';
      done++;
    }
  *fcvt_buf++ = 0;
  return save;
}

#endif

char *
_DEFUN (_gcvt, (ptr, invalue, ndigit, buf, type, dot),
	struct _reent *ptr _AND
	double invalue _AND
	int ndigit _AND
	char *buf _AND
	char type _AND
	int dot)
{
  char *save = buf;

  if (invalue < 0)
    {
      invalue = -invalue;
    }

  if (invalue == 0)
    {
      *buf++ = '0';
      *buf = '\0';
    }
  else
    /* Which one to print ?
       ANSI says that anything with more that 4 zeros after the . or more
       than precision digits before is printed in e with the qualification
       that trailing zeroes are removed from the fraction portion.  */

  if (0.0001 >= invalue || invalue >= _mprec_log10 (ndigit))
    {
      /* We subtract 1 from ndigit because in the 'e' format the precision is
	 the number of digits after the . but in 'g' format it is the number
	 of significant digits.

	 We defer changing type to e/E so that print_e() can know it's us
	 calling and thus should remove trailing zeroes.  */

      print_e (ptr, buf, invalue, ndigit - 1, type, dot);
    }
  else
    {
      int decpt;
      int sign;
      char *end;
      char *p;

      if (invalue < 1.0)
	{
	  /* what we want is ndigits after the point */
	  p = _dtoa_r (ptr, invalue, 3, ndigit, &decpt, &sign, &end);
	}
      else
	{
	  p = _dtoa_r (ptr, invalue, 2, ndigit, &decpt, &sign, &end);
	}

      if (decpt == 9999)
	{
	  strcpy (buf, p);
	  return save;
	}
      while (*p && decpt > 0)
	{
	  *buf++ = *p++;
	  decpt--;
	  ndigit--;
	}
      /* Even if not in buffer */
      while (decpt > 0 && ndigit > 0)
	{
	  *buf++ = '0';
	  decpt--;
	  ndigit--;
	}

      if (dot || *p)
	{
	  if (buf == save)
	    *buf++ = '0';
	  *buf++ = '.';
	  while (decpt < 0 && ndigit > 0)
	    {
	      *buf++ = '0';
	      decpt++;
	      ndigit--;
	    }

	  /* Print rest of stuff */
	  while (*p && ndigit > 0)
	    {
	      *buf++ = *p++;
	      ndigit--;
	    }
	  /* And trailing zeros */
	  if (dot)
	    {
	      while (ndigit > 0)
		{
		  *buf++ = '0';
		  ndigit--;
		}
	    }
	}
      *buf++ = 0;
    }

  return save;
}

char *
_DEFUN (_dcvt, (ptr, buffer, invalue, precision, width, type, dot),
	struct _reent *ptr _AND
	char *buffer _AND
	double invalue _AND
	int precision _AND
	int width _AND
	char type _AND
	int dot)
{
  switch (type)
    {
    case 'f':
    case 'F':
      print_f (ptr, buffer, invalue, precision, type, precision == 0 ? dot : 1, 3);
      break;
    case 'g':
    case 'G':
      if (precision == 0)
	precision = 1;
      _gcvt (ptr, invalue, precision, buffer, type, dot);
      break;
    case 'e':
    case 'E':
      print_e (ptr, buffer, invalue, precision, type, dot);
    }
  return buffer;
}
@


1.2
log
@
Mon Apr 17 12:46:00 2000  Marek Michalkiewicz <marekm@@linux.org.pl>

        * libc/signal/signal.c (_signal_r) : Removed unused local variable temp.        * libc/stdio/findfp.c (std): Added declaration of flags and file.
        * libc/stdio/mktemp.c (_gettemp, _mkstemp_r, mkstemp): Added int
        return type.
        * libc/stdio/putchar.c (putchar): Added return statement.
        * libc/stdio/refill.c (lflush): Added correct parentheses.
        * libc/stdio/vfprintf.c (_VFPRINTF_R): Ditto.
        * libc/stdio/vfscanf.c (__svfscanf): Changed sprintf call which
        prints long value to use l qualifier.
        * libc/stdlib/dtoa.c (_dtoa_r): Added parentheses to remove warning
        messages and initialized local values: ilim, ilim1, and spec_case.
        * libc/stdlib/ecvtbuf.c (print_e): Removed unused variable dp.
        * libc/stdlib/mbctype.h (_issjis1, _issjis2): Added parentheses.
        * libc/stdlib/mprec.c: Ditto.
        * libc/stdlib/setenv_r.c: Ditto.
        * libc/stdlib/strtod.c: Ditto.
        * libc/stdlib/strtol.c: Ditto.
        * libc/stdlib/strtoul.c: Ditto.
        * libm/common/sf_expm1.c: Added curly braces to if else clauses.
        * libm/common/sf_log1p.c: Ditto.
        * libm/common/sf_scalbn.c: Ditto.
        * libm/math/ef_log.c: Ditto.
@
text
@d236 1
d244 1
a244 1
      if (_REENT->_cvtlen <= ndigit + 35)
d246 1
a246 1
	  if ((fcvt_buf = (char *) _realloc_r (_REENT, _REENT->_cvtbuf,
d249 2
a250 2
	  _REENT->_cvtlen = ndigit + 36;
	  _REENT->_cvtbuf = fcvt_buf;
d253 1
a253 1
      fcvt_buf = _REENT->_cvtbuf ;
d260 1
a260 1
      p = _dtoa_r (_REENT, invalue, 2, ndigit, decpt, sign, &end);
d264 1
a264 1
      p = _dtoa_r (_REENT, invalue, 3, ndigit, decpt, sign, &end);
d293 1
d301 1
a301 1
      if (_REENT->_cvtlen <= ndigit)
d303 1
a303 1
	  if ((fcvt_buf = (char *) _realloc_r (_REENT, _REENT->_cvtbuf,
d306 2
a307 2
	  _REENT->_cvtlen = ndigit + 1;
	  _REENT->_cvtbuf = fcvt_buf;
d310 1
a310 1
      fcvt_buf = _REENT->_cvtbuf ;
d315 1
a315 1
  p = _dtoa_r (_REENT, invalue, 2, ndigit, decpt, sign, &end);
@


1.1
log
@Initial revision
@
text
@a153 1
  int dp;
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
