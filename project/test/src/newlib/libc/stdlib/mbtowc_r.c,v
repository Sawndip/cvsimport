head	1.22;
access;
symbols
	cygwin-1_7_35-release:1.22
	cygwin-1_7_34-release:1.22
	newlib-2_2_0:1.22.0.2
	cygwin-1_7_33-release:1.22
	cygwin-1_7_32-release:1.22
	cygwin-1_7_31-release:1.22
	cygwin-1_7_30-release:1.22
	cygwin-1_7_29-release:1.22
	cygwin-1_7_28-release:1.22
	newlib-2_1_0:1.22
	cygwin-1_7_27-release:1.22
	cygwin-1_7_26-release:1.22
	cygwin-1_7_25-release:1.21
	cygwin-1_7_24-release:1.21
	cygwin-1_7_23-release:1.21
	cygwin-1_7_22-release:1.21
	cygwin-1_7_21-release:1.21
	cygwin-1_7_20-release:1.21
	cygwin-1_7_19-release:1.21
	cygwin-64bit-postmerge:1.21
	cygwin-64bit-premerge-branch:1.21.0.4
	cygwin-64bit-premerge:1.21
	cygwin-1_7_18-release:1.21
	newlib-2_0_0:1.21
	cygwin-1_7_17-release:1.21
	cygwin-64bit-branch:1.21.0.2
	cygwin-1_7_16-release:1.20
	cygwin-1_7_15-release:1.20
	cygwin-1_7_14_2-release:1.20
	cygwin-1_7_14-release:1.20
	cygwin-1_7_12-release:1.20
	cygwin-1_7_11-release:1.20
	cygwin-1_7_10-release:1.20
	newlib-1_20_0:1.20
	cygwin-1_7_9-release:1.20
	cygwin-1_7_8-release:1.20
	newlib-1_19_0:1.20
	cygwin-1_7_7-release:1.20
	cygwin-1_7_5-release:1.20
	cygwin-1_7_4-release:1.20
	cygwin-1_7_3-release:1.20
	cygwin-1_7_2-release:1.20
	newlib-1_18_0:1.18
	cygwin-1_7_1-release:1.18
	newlib-1_17_0-arc:1.7.0.10
	binutils-arc-20080908-branch:1.7.0.8
	binutils-arc-20080908-branchpoint:1.7
	newlib-1_17_0:1.7
	newlib-1_16_0:1.7
	newlib-1_15_0:1.7
	newlib-csl-coldfire-4_1-32:1.7
	newlib-csl-sourcerygxx-4_1-32:1.7
	newlib-csl-innovasic-fido-3_4_4-33:1.7
	newlib-csl-coldfire-4_1-30:1.7
	newlib-csl-sourcerygxx-4_1-30:1.7
	newlib-csl-coldfire-4_1-28:1.7
	newlib-csl-sourcerygxx-4_1-28:1.7
	newlib-csl-arm-2006q3-27:1.7
	newlib-csl-sourcerygxx-4_1-27:1.7
	newlib-csl-arm-2006q3-26:1.7
	newlib-csl-sourcerygxx-4_1-26:1.7
	newlib-csl-sourcerygxx-4_1-24:1.7
	newlib-csl-sourcerygxx-4_1-23:1.7
	newlib-csl-sourcerygxx-4_1-21:1.7
	newlib-csl-arm-2006q3-21:1.7
	newlib-csl-arm-2006q3-19:1.7
	newlib-csl-sourcerygxx-4_1-19:1.7
	newlib-csl-sourcerygxx-4_1-18:1.7
	newlib-csl-sourcerygxx-3_4_4-25:1.7
	newlib-csl-sourcerygxx-4_1-17:1.7
	cr-0x5f1:1.7.0.6
	newlib-csl-sourcerygxx-4_1-14:1.7
	newlib-csl-sourcerygxx-4_1-13:1.7
	newlib-csl-sourcerygxx-4_1-12:1.7
	newlib-csl-sourcerygxx-4_1-9:1.7
	newlib-csl-sourcerygxx-4_1-8:1.7
	newlib-csl-sourcerygxx-4_1-7:1.7
	newlib-csl-arm-2006q1-6:1.7
	newlib-csl-sourcerygxx-4_1-6:1.7
	newlib-csl-sourcerygxx-4_1-5:1.7
	newlib-csl-sourcerygxx-4_1-4:1.7
	newlib-autotools-branch:1.7.0.4
	newlib-csl-20060320-branch:1.7.0.2
	newlib-csl-20060320-branchpoint:1.7
	newlib-1_14_0:1.7
	newlib-csl-arm-2005-q1b:1.7
	newlib-csl-arm-2005-q1a:1.7
	newlib-1_13_0:1.7
	csl-arm-2004-q3:1.7
	csl-arm-2004-q1a:1.7
	csl-arm-2004-q1:1.6
	newlib-1_12_0:1.6
	csl-arm-2003-q4:1.6
	w32api-2_2:1.6
	mingw-runtime-2_4:1.6
	newlib-1_11_0:1.6
	cygnus_cvs_20020108_pre:1.2
	newlib-1_10_0:1.2
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.22
date	2013.11.18.17.26.51;	author joel;	state Exp;
branches;
next	1.21;

1.21
date	2012.08.08.11.04.18;	author corinna;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.17.09.39.06;	author corinna;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.10.13.54.34;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.18.09.49.57;	author corinna;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.03.08.51.07;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.27.12.21.16;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.29.08.31.30;	author corinna;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.28.16.49.19;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.09.08.20.10;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.24.10.13.27;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.19.19.47.52;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.03.09.28.45;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.25.09.10.09;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2009.02.18.21.28.41;	author jjohnstn;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.23.21.44.22;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.20.20.13.11;	author jjohnstn;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.09.21.42.14;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.23.01.56.04;	author fitzsim;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.24.20.51.24;	author fitzsim;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.11.17.21.18;	author jlarmour;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.48;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.48;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.22
log
@2013-11-18  Sahil Patnayakuni  <sahilp@@oarcorp.com>

	* libc/include/stdlib.h, libc/stdlib/mbstowcs.c,
	libc/stdlib/mbstowcs_r.c, libc/stdlib/mbtowc.c,
	libc/stdlib/mbtowc_r.c, libc/stdlib/strtod.c,
	libc/stdlib/strtol.c, libc/stdlib/strtold.c,
	libc/stdlib/strtoll.c, libc/stdlib/strtoll_r.c,
	libc/stdlib/strtoul.c, libc/stdlib/strtoull.c,
	libc/stdlib/strtoull_r.c, libc/stdlib/wcstombs.c,
	libc/stdlib/wcstombs_r.c: Add restrict keyword.
@
text
@#include <newlib.h>
#include <stdlib.h>
#include <locale.h>
#include "mbctype.h"
#include <wchar.h>
#include <string.h>
#include <errno.h>
#include "local.h"

int (*__mbtowc) (struct _reent *, wchar_t *, const char *, size_t,
		 const char *, mbstate_t *)
#ifdef __CYGWIN__
   /* Cygwin starts up in UTF-8 mode. */
   = __utf8_mbtowc;
#else
   = __ascii_mbtowc;
#endif

int
_DEFUN (_mbtowc_r, (r, pwc, s, n, state),
        struct _reent *r   _AND
        wchar_t       *__restrict pwc _AND 
        const char    *__restrict s   _AND        
        size_t         n   _AND
        mbstate_t      *state)
{
  return __mbtowc (r, pwc, s, n, __locale_charset (), state);
}

int
_DEFUN (__ascii_mbtowc, (r, pwc, s, n, charset, state),
        struct _reent *r       _AND
        wchar_t       *pwc     _AND 
        const char    *s       _AND        
        size_t         n       _AND
	const char    *charset _AND
        mbstate_t      *state)
{
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;

  if (pwc == NULL)
    pwc = &dummy;

  if (s == NULL)
    return 0;

  if (n == 0)
    return -2;

#ifdef __CYGWIN__
  if ((wchar_t)*t >= 0x80)
    {
      r->_errno = EILSEQ;
      return -1;
    }
#endif

  *pwc = (wchar_t)*t;
  
  if (*t == '\0')
    return 0;

  return 1;
}

#ifdef _MB_CAPABLE
typedef enum { ESCAPE, DOLLAR, BRACKET, AT, B, J, 
               NUL, JIS_CHAR, OTHER, JIS_C_NUM } JIS_CHAR_TYPE;
typedef enum { ASCII, JIS, A_ESC, A_ESC_DL, JIS_1, J_ESC, J_ESC_BR,
               INV, JIS_S_NUM } JIS_STATE; 
typedef enum { COPY_A, COPY_J1, COPY_J2, MAKE_A, NOOP, EMPTY, ERROR } JIS_ACTION;

/************************************************************************************** 
 * state/action tables for processing JIS encoding
 * Where possible, switches to JIS are grouped with proceding JIS characters and switches
 * to ASCII are grouped with preceding JIS characters.  Thus, maximum returned length
 * is 2 (switch to JIS) + 2 (JIS characters) + 2 (switch back to ASCII) = 6.
 *************************************************************************************/

#ifndef  __CYGWIN__
static JIS_STATE JIS_state_table[JIS_S_NUM][JIS_C_NUM] = {
/*              ESCAPE   DOLLAR    BRACKET   AT       B       J        NUL      JIS_CHAR  OTHER */
/* ASCII */   { A_ESC,   ASCII,    ASCII,    ASCII,   ASCII,  ASCII,   ASCII,   ASCII,    ASCII },
/* JIS */     { J_ESC,   JIS_1,    JIS_1,    JIS_1,   JIS_1,  JIS_1,   INV,     JIS_1,    INV },
/* A_ESC */   { ASCII,   A_ESC_DL, ASCII,    ASCII,   ASCII,  ASCII,   ASCII,   ASCII,    ASCII },
/* A_ESC_DL */{ ASCII,   ASCII,    ASCII,    JIS,     JIS,    ASCII,   ASCII,   ASCII,    ASCII }, 
/* JIS_1 */   { INV,     JIS,      JIS,      JIS,     JIS,    JIS,     INV,     JIS,      INV },
/* J_ESC */   { INV,     INV,      J_ESC_BR, INV,     INV,    INV,     INV,     INV,      INV },
/* J_ESC_BR */{ INV,     INV,      INV,      INV,     ASCII,  ASCII,   INV,     INV,      INV },
};

static JIS_ACTION JIS_action_table[JIS_S_NUM][JIS_C_NUM] = {
/*              ESCAPE   DOLLAR    BRACKET   AT       B        J        NUL      JIS_CHAR  OTHER */
/* ASCII */   { NOOP,    COPY_A,   COPY_A,   COPY_A,  COPY_A,  COPY_A,  EMPTY,   COPY_A,  COPY_A},
/* JIS */     { NOOP,    COPY_J1,  COPY_J1,  COPY_J1, COPY_J1, COPY_J1, ERROR,   COPY_J1, ERROR },
/* A_ESC */   { COPY_A,  NOOP,     COPY_A,   COPY_A,  COPY_A,  COPY_A,  COPY_A,  COPY_A,  COPY_A},
/* A_ESC_DL */{ COPY_A,  COPY_A,   COPY_A,   NOOP,    NOOP,    COPY_A,  COPY_A,  COPY_A,  COPY_A},
/* JIS_1 */   { ERROR,   COPY_J2,  COPY_J2,  COPY_J2, COPY_J2, COPY_J2, ERROR,   COPY_J2, ERROR },
/* J_ESC */   { ERROR,   ERROR,    NOOP,     ERROR,   ERROR,   ERROR,   ERROR,   ERROR,   ERROR },
/* J_ESC_BR */{ ERROR,   ERROR,    ERROR,    ERROR,   MAKE_A,  MAKE_A,  ERROR,   ERROR,   ERROR },
};
#endif /* !__CYGWIN__ */

/* we override the mbstate_t __count field for more complex encodings and use it store a state value */
#define __state __count

#ifdef _MB_EXTENDED_CHARSETS_ISO
int
_DEFUN (__iso_mbtowc, (r, pwc, s, n, charset, state),
        struct _reent *r       _AND
        wchar_t       *pwc     _AND 
        const char    *s       _AND        
        size_t         n       _AND
	const char    *charset _AND
        mbstate_t      *state)
{
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;

  if (pwc == NULL)
    pwc = &dummy;

  if (s == NULL)
    return 0;

  if (n == 0)
    return -2;

  if (*t >= 0xa0)
    {
      int iso_idx = __iso_8859_index (charset + 9);
      if (iso_idx >= 0)
	{
	  *pwc = __iso_8859_conv[iso_idx][*t - 0xa0];
	  if (*pwc == 0) /* Invalid character */
	    {
	      r->_errno = EILSEQ;
	      return -1;
	    }
	  return 1;
	}
    }

  *pwc = (wchar_t) *t;
  
  if (*t == '\0')
    return 0;

  return 1;
}
#endif /* _MB_EXTENDED_CHARSETS_ISO */

#ifdef _MB_EXTENDED_CHARSETS_WINDOWS
int
_DEFUN (__cp_mbtowc, (r, pwc, s, n, charset, state),
        struct _reent *r       _AND
        wchar_t       *pwc     _AND 
        const char    *s       _AND        
        size_t         n       _AND
	const char    *charset _AND
        mbstate_t      *state)
{
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;

  if (pwc == NULL)
    pwc = &dummy;

  if (s == NULL)
    return 0;

  if (n == 0)
    return -2;

  if (*t >= 0x80)
    {
      int cp_idx = __cp_index (charset + 2);
      if (cp_idx >= 0)
	{
	  *pwc = __cp_conv[cp_idx][*t - 0x80];
	  if (*pwc == 0) /* Invalid character */
	    {
	      r->_errno = EILSEQ;
	      return -1;
	    }
	  return 1;
	}
    }

  *pwc = (wchar_t)*t;
  
  if (*t == '\0')
    return 0;

  return 1;
}
#endif /* _MB_EXTENDED_CHARSETS_WINDOWS */

int
_DEFUN (__utf8_mbtowc, (r, pwc, s, n, charset, state),
        struct _reent *r       _AND
        wchar_t       *pwc     _AND 
        const char    *s       _AND        
        size_t         n       _AND
	const char    *charset _AND
        mbstate_t      *state)
{
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;
  int ch;
  int i = 0;

  if (pwc == NULL)
    pwc = &dummy;

  if (s == NULL)
    return 0;

  if (n == 0)
    return -2;

  if (state->__count == 0)
    ch = t[i++];
  else
    ch = state->__value.__wchb[0];

  if (ch == '\0')
    {
      *pwc = 0;
      state->__count = 0;
      return 0; /* s points to the null character */
    }

  if (ch <= 0x7f)
    {
      /* single-byte sequence */
      state->__count = 0;
      *pwc = ch;
      return 1;
    }
  if (ch >= 0xc0 && ch <= 0xdf)
    {
      /* two-byte sequence */
      state->__value.__wchb[0] = ch;
      if (state->__count == 0)
	state->__count = 1;
      else if (n < (size_t)-1)
	++n;
      if (n < 2)
	return -2;
      ch = t[i++];
      if (ch < 0x80 || ch > 0xbf)
	{
	  r->_errno = EILSEQ;
	  return -1;
	}
      if (state->__value.__wchb[0] < 0xc2)
	{
	  /* overlong UTF-8 sequence */
	  r->_errno = EILSEQ;
	  return -1;
	}
      state->__count = 0;
      *pwc = (wchar_t)((state->__value.__wchb[0] & 0x1f) << 6)
	|    (wchar_t)(ch & 0x3f);
      return i;
    }
  if (ch >= 0xe0 && ch <= 0xef)
    {
      /* three-byte sequence */
      wchar_t tmp;
      state->__value.__wchb[0] = ch;
      if (state->__count == 0)
	state->__count = 1;
      else if (n < (size_t)-1)
	++n;
      if (n < 2)
	return -2;
      ch = (state->__count == 1) ? t[i++] : state->__value.__wchb[1];
      if (state->__value.__wchb[0] == 0xe0 && ch < 0xa0)
	{
	  /* overlong UTF-8 sequence */
	  r->_errno = EILSEQ;
	  return -1;
	}
      if (ch < 0x80 || ch > 0xbf)
	{
	  r->_errno = EILSEQ;
	  return -1;
	}
      state->__value.__wchb[1] = ch;
      if (state->__count == 1)
	state->__count = 2;
      else if (n < (size_t)-1)
	++n;
      if (n < 3)
	return -2;
      ch = t[i++];
      if (ch < 0x80 || ch > 0xbf)
	{
	  r->_errno = EILSEQ;
	  return -1;
	}
      state->__count = 0;
      tmp = (wchar_t)((state->__value.__wchb[0] & 0x0f) << 12)
	|    (wchar_t)((state->__value.__wchb[1] & 0x3f) << 6)
	|     (wchar_t)(ch & 0x3f);
      *pwc = tmp;
      return i;
    }
  if (ch >= 0xf0 && ch <= 0xf4)
    {
      /* four-byte sequence */
      wint_t tmp;
      state->__value.__wchb[0] = ch;
      if (state->__count == 0)
	state->__count = 1;
      else if (n < (size_t)-1)
	++n;
      if (n < 2)
	return -2;
      ch = (state->__count == 1) ? t[i++] : state->__value.__wchb[1];
      if ((state->__value.__wchb[0] == 0xf0 && ch < 0x90)
	  || (state->__value.__wchb[0] == 0xf4 && ch >= 0x90))
	{
	  /* overlong UTF-8 sequence or result is > 0x10ffff */
	  r->_errno = EILSEQ;
	  return -1;
	}
      if (ch < 0x80 || ch > 0xbf)
	{
	  r->_errno = EILSEQ;
	  return -1;
	}
      state->__value.__wchb[1] = ch;
      if (state->__count == 1)
	state->__count = 2;
      else if (n < (size_t)-1)
	++n;
      if (n < 3)
	return -2;
      ch = (state->__count == 2) ? t[i++] : state->__value.__wchb[2];
      if (ch < 0x80 || ch > 0xbf)
	{
	  r->_errno = EILSEQ;
	  return -1;
	}
      state->__value.__wchb[2] = ch;
      if (state->__count == 2)
	state->__count = 3;
      else if (n < (size_t)-1)
	++n;
      if (state->__count == 3 && sizeof(wchar_t) == 2)
	{
	  /* On systems which have wchar_t being UTF-16 values, the value
	     doesn't fit into a single wchar_t in this case.  So what we
	     do here is to store the state with a special value of __count
	     and return the first half of a surrogate pair.  The first
	     three bytes of a UTF-8 sequence are enough to generate the
	     first half of a UTF-16 surrogate pair.  As return value we
	     choose to return the number of bytes actually read up to
	     here.
	     The second half of the surrogate pair is returned in case we
	     recognize the special __count value of four, and the next
	     byte is actually a valid value.  See below. */
	  tmp = (wint_t)((state->__value.__wchb[0] & 0x07) << 18)
	    |   (wint_t)((state->__value.__wchb[1] & 0x3f) << 12)
	    |   (wint_t)((state->__value.__wchb[2] & 0x3f) << 6);
	  state->__count = 4;
	  *pwc = 0xd800 | ((tmp - 0x10000) >> 10);
	  return i;
	}
      if (n < 4)
	return -2;
      ch = t[i++];
      if (ch < 0x80 || ch > 0xbf)
	{
	  r->_errno = EILSEQ;
	  return -1;
	}
      tmp = (wint_t)((state->__value.__wchb[0] & 0x07) << 18)
	|   (wint_t)((state->__value.__wchb[1] & 0x3f) << 12)
	|   (wint_t)((state->__value.__wchb[2] & 0x3f) << 6)
	|   (wint_t)(ch & 0x3f);
      if (state->__count == 4 && sizeof(wchar_t) == 2)
	/* Create the second half of the surrogate pair for systems with
	   wchar_t == UTF-16 . */
	*pwc = 0xdc00 | (tmp & 0x3ff);
      else
	*pwc = tmp;
      state->__count = 0;
      return i;
    }

  r->_errno = EILSEQ;
  return -1;
}

/* Cygwin defines its own doublebyte charset conversion functions 
   because the underlying OS requires wchar_t == UTF-16. */
#ifndef  __CYGWIN__
int
_DEFUN (__sjis_mbtowc, (r, pwc, s, n, charset, state),
        struct _reent *r       _AND
        wchar_t       *pwc     _AND 
        const char    *s       _AND        
        size_t         n       _AND
	const char    *charset _AND
        mbstate_t      *state)
{
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;
  int ch;
  int i = 0;

  if (pwc == NULL)
    pwc = &dummy;

  if (s == NULL)
    return 0;  /* not state-dependent */

  if (n == 0)
    return -2;

  ch = t[i++];
  if (state->__count == 0)
    {
      if (_issjis1 (ch))
	{
	  state->__value.__wchb[0] = ch;
	  state->__count = 1;
	  if (n <= 1)
	    return -2;
	  ch = t[i++];
	}
    }
  if (state->__count == 1)
    {
      if (_issjis2 (ch))
	{
	  *pwc = (((wchar_t)state->__value.__wchb[0]) << 8) + (wchar_t)ch;
	  state->__count = 0;
	  return i;
	}
      else  
	{
	  r->_errno = EILSEQ;
	  return -1;
	}
    }

  *pwc = (wchar_t)*t;
  
  if (*t == '\0')
    return 0;

  return 1;
}

int
_DEFUN (__eucjp_mbtowc, (r, pwc, s, n, charset, state),
        struct _reent *r       _AND
        wchar_t       *pwc     _AND 
        const char    *s       _AND        
        size_t         n       _AND
	const char    *charset _AND
        mbstate_t      *state)
{
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;
  int ch;
  int i = 0;

  if (pwc == NULL)
    pwc = &dummy;

  if (s == NULL)
    return 0;

  if (n == 0)
    return -2;

  ch = t[i++];
  if (state->__count == 0)
    {
      if (_iseucjp1 (ch))
	{
	  state->__value.__wchb[0] = ch;
	  state->__count = 1;
	  if (n <= 1)
	    return -2;
	  ch = t[i++];
	}
    }
  if (state->__count == 1)
    {
      if (_iseucjp2 (ch))
	{
	  if (state->__value.__wchb[0] == 0x8f)
	    {
	      state->__value.__wchb[1] = ch;
	      state->__count = 2;
	      if (n <= i)
		return -2;
	      ch = t[i++];
	    }
	  else
	    {
	      *pwc = (((wchar_t)state->__value.__wchb[0]) << 8) + (wchar_t)ch;
	      state->__count = 0;
	      return i;
	    }
	}
      else
	{
	  r->_errno = EILSEQ;
	  return -1;
	}
    }
  if (state->__count == 2)
    {
      if (_iseucjp2 (ch))
	{
	  *pwc = (((wchar_t)state->__value.__wchb[1]) << 8)
		 + (wchar_t)(ch & 0x7f);
	  state->__count = 0;
	  return i;
	}
      else
	{
	  r->_errno = EILSEQ;
	  return -1;
	}
    }

  *pwc = (wchar_t)*t;
  
  if (*t == '\0')
    return 0;

  return 1;
}

int
_DEFUN (__jis_mbtowc, (r, pwc, s, n, charset, state),
        struct _reent *r       _AND
        wchar_t       *pwc     _AND 
        const char    *s       _AND        
        size_t         n       _AND
	const char    *charset _AND
        mbstate_t      *state)
{
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;
  JIS_STATE curr_state;
  JIS_ACTION action;
  JIS_CHAR_TYPE ch;
  unsigned char *ptr;
  unsigned int i;
  int curr_ch;

  if (pwc == NULL)
    pwc = &dummy;

  if (s == NULL)
    {
      state->__state = ASCII;
      return 1;  /* state-dependent */
    }

  if (n == 0)
    return -2;

  curr_state = state->__state;
  ptr = t;

  for (i = 0; i < n; ++i)
    {
      curr_ch = t[i];
      switch (curr_ch)
	{
	case ESC_CHAR:
	  ch = ESCAPE;
	  break;
	case '$':
	  ch = DOLLAR;
	  break;
	case '@@':
	  ch = AT;
	  break;
	case '(':
	  ch = BRACKET;
	  break;
	case 'B':
	  ch = B;
	  break;
	case 'J':
	  ch = J;
	  break;
	case '\0':
	  ch = NUL;
	  break;
	default:
	  if (_isjis (curr_ch))
	    ch = JIS_CHAR;
	  else
	    ch = OTHER;
	}

      action = JIS_action_table[curr_state][ch];
      curr_state = JIS_state_table[curr_state][ch];
    
      switch (action)
	{
	case NOOP:
	  break;
	case EMPTY:
	  state->__state = ASCII;
	  *pwc = (wchar_t)0;
	  return 0;
	case COPY_A:
	  state->__state = ASCII;
	  *pwc = (wchar_t)*ptr;
	  return (i + 1);
	case COPY_J1:
	  state->__value.__wchb[0] = t[i];
	  break;
	case COPY_J2:
	  state->__state = JIS;
	  *pwc = (((wchar_t)state->__value.__wchb[0]) << 8) + (wchar_t)(t[i]);
	  return (i + 1);
	case MAKE_A:
	  ptr = (unsigned char *)(t + i + 1);
	  break;
	case ERROR:
	default:
	  r->_errno = EILSEQ;
	  return -1;
	}

    }

  state->__state = curr_state;
  return -2;  /* n < bytes needed */
}
#endif /* !__CYGWIN__*/
#endif /* _MB_CAPABLE */
@


1.21
log
@	Throughout, run newlib with -Wall -Werror option and fix bugs and
	compiler warnings found this way.

	* libc/stdio/freopen.c (_freopen_r): Fix bug setting _flags.

	* libc/include/stdio.h (_rename): Define when building newlib.
	* libc/include/sys/signal.h (_kill): Ditto.
	* libc/include/sys/stat.h (_mkdir): Ditto.
	* libc/include/sys/time.h (_gettimeofday): Ditto.
	* libc/include/sys/times.h (_times): Ditto.
	* libc/include/sys/wait.h (_wait): Ditto.
	* libc/locale/lmessages.c (empty): Don't define for Cygwin.
	* libc/locale/lmonetary.c (cnv): Ditto.
	* libc/locale/nl_langinfo.c (nl_langinfo): Ditto for variable s.
	* libc/posix/collate.c: Throughout cast to avoid compiler warning.
	* libc/posix/engine.c (matcher): Initialize dp to avoid compiler
	warning.
	* libc/posix/glob.c: Disable on Cygwin.  Explain why.
	* libc/posix/regcomp.c: Fix "uninitialized" compiler warnings.
	(dissect): Deliberately silence gcc compiler warning.  Add comment to
	explain why.
	* libc/posix/wordexp.c (wordexp): Remove num_bytes variable since result
	is never used.
	* libc/posix/popen.c (popen): Ditto for variable last.
	* libc/reent/mkdirr.c: Include sys/stat.h.
	* libc/reent/renamer.c: Include stdio.h.
	* libc/search/hash.c:  Throughout use underscored variants of the stat
	function family.
	(init_hash): Add missing definition for the __USE_INTERNAL_STAT64 case.
	* libc/search/hash_bigkey.c (__big_insert): Add parenthesis to avoid
	compiler warning.
	* libc/search/hash_page.c (overflow_page): Initalize freep to NULL to
	avoid compiler warning.
	* libc/stdio/asiprintf.c (_asiprintf_r): Cast unsigned char * to char *
	to avoid compiler warning.
	(asiprintf): Ditto.
	* libc/stdio/asprintf.c (_asprintf_r): Ditto.
	(asprintf): Ditto.
	* libc/stdio/vasiprintf.c (_vasiprintf_r): Ditto.
	* libc/stdio/vasprintf.c (_vasprintf_r): Ditto.
	* libc/stdio/mktemp.c (_gettemp): Cast to unsigned char in call to
	isdigit to avoid compiler warning.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Initialize variables used for
	grouping to avoid compiler warning.  Only define and set nseps and
	nrepeats if they are really used.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R): Ditto.  Only define state if
	it is really used.
	* libc/stdio/vfscanf.c (u_char): Revert to be defined as unsigned char.
	(__SVFSCANF_R): Cast fmt in call to __mbtowc.
	* libc/stdlib/mbtowc_r.c (JIS_state_table): Disable when building
	Cygwin.
	(JIS_action_table): Ditto.
	* libc/stdlib/wctomb_r.c (__utf8_wctomb): Add parenthesis to avoid
	compiler warning.
	* libc/string/strcasestr.c: Deliberately silence gcc compiler warning.
	Add comment to explain why.
	* libc/time/strptime.c (strptime): Cast to unsigned char in calls to
	isspace to avoid compiler warning.
	* libm/math/e_atan2.c (__ieee754_atan2): Add parenthesis to avoid
	compiler warning.
	* libm/math/e_exp.c (__ieee754_exp): Initialize k to 0 to avoid
	compiler warning.  Drop setting it to 0 later.
	* libm/math/ef_exp.c (__ieee754_expf): Ditto.
	* libm/math/e_pow.c (__ieee754_pow): Add braces to avoid compiler
	warning.
	* libm/math/ef_pow.c (__ieee754_powf): Ditto.
	* libm/math/er_lgamma.c (__ieee754_lgamma_r): Initialize nadj to 0 to
	avoid compiler warning.
	* libm/math/erf_lgamma.c (__ieee754_lgammaf_r): Ditto.
	* libm/math/e_rem_pio2.c (__ieee754_rem_pio2): Ditto for variable z.
	* libm/common/sf_round.c (roundf): Remove signbit variable since result
	is never used.
@
text
@d22 2
a23 2
        wchar_t       *pwc _AND 
        const char    *s   _AND        
@


1.20
log
@	* libc/locale/locale.c (lc_ctype_charset): Disable defaulting to
	"UTF-8" on Cygwin.
	(lc_message_charset): Ditto.
	(loadlocale): Disable setting charset of the "C" locale to "UTF-8" on
	Cygwin.
	* libc/stdlib/mbtowc_r.c (__mbtowc): Add Cygwin-specific comment.
	* libc/stdlib/wctomb_r.c (__wctomb): Ditto.
@
text
@d81 1
d103 1
@


1.19
log
@	* libc/stdlib/mbtowc_r.c (__ascii_mbtowc): Disallow conversion of
	non-ASCII chars on Cygwin.
	* libc/stdlib/wctomb_r.c (__ascii_wctomb): Ditto.
@
text
@d13 1
@


1.18
log
@	* libc/stdio/vfprintf.c: Include ../stdlib/local.h.  Replace call to
	_mbtowc_r with direct call to __mbtowc.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdlib/btowc.c: Include local.h.  Replace call to _mbtowc_r
	with direct call to __mbtowc.
	* libc/stdlib/mblen.c: Ditto.
	* libc/stdlib/mblen_r.c: Ditto.
	* libc/stdlib/mbrtowc.c: Ditto.
	* libc/stdlib/mbstowcs_r.c: Ditto.
	* libc/stdlib/mbtowc.c: Ditto.
	* libc/stdlib/wcrtomb.c: Include local.h.  Replace call to _wctomb_r
	with direct call to __wctomb.
	* libc/stdlib/wcsnrtombs.c: Ditto.
	(_wcsnrtombs_r): Ditto.
	* libc/stdlib/wcstombs_r.c: Ditto.
	* libc/stdlib/wctob.c: Ditto.
	* libc/stdlib/wctomb.c: Ditto.

	* libc/stdlib/mbrtowc.c (mbrtowc): Implement independently from
	_mbrtowc_r, unless PREFER_SIZE_OVER_SPEED or __OPTIMIZE_SIZE__ are
	defined.
	* libc/stdlib/wcrtomb.c (wcrtomb): Implement independently from
	_wcrtomb_r, unless PREFER_SIZE_OVER_SPEED or __OPTIMIZE_SIZE__ are
	defined.

	* libc/stdlib/mbtowc_r.c (__utf8_mbtowc): Drop unnecessary test for
	ch >= 0.
@
text
@d50 8
@


1.17
log
@	* libc/stdlib/mbtowc_r.c (__utf8_mbtowc): Allow CESU-8 surrogate
	value encoding.
	* libc/stdlib/wctomb_r.c (__utf8_mbtowc): Allow CESU-8 surrogate
	value decoding.
@
text
@d224 1
a224 1
  if (ch >= 0x0 && ch <= 0x7f)
@


1.16
log
@	* libc/locale/locale.c (lc_ctype_charset): Set to "UTF-8" on Cygwin.
	(lc_message_charset): Ditto.
	(loadlocale): Set charset of the "C" locale to "UTF-8" on Cygwin.
	* libc/stdlib/mbtowc_r.c (__mbtowc): Default to __utf8_mbtowc on
	Cygwin.
	* libc/stdlib/wctomb_r.c (__wctomb): Default to __utf8_wctomb on
	Cygwin.
@
text
@a297 6
      /* Check for invalid CESU-8 encoding of UTF-16 surrogate values. */
      if (tmp >= 0xd800 && tmp <= 0xdfff)
	{
	  r->_errno = EILSEQ;
	  return -1;
	}
@


1.15
log
@	* libc/stdlib/mbtowc_r.c (__utf8_mbtowc): Rework UTF-16 surrogate
	pair handling to be more bullet-proof even with incomplete UTF-8
	sequences.  Add check for 4 byte sequences resulting in values
	outside the valid Unicode range.  Add a comment to clarify checking
	for invalid CESU-8 sequences.
@
text
@d12 3
d16 1
@


1.14
log
@	* libc/stdlib/mbtowc_r.c (__utf8_mbtowc): Fix incrementing n in case
	of handling incomplete sequences.
@
text
@a207 12
  if (state->__count == 4)
    {
      /* Create the second half of the surrogate pair.  For a description
	 see the comment below. */
      wint_t tmp = (wchar_t)((state->__value.__wchb[0] & 0x07) << 18)
	|   (wchar_t)((state->__value.__wchb[1] & 0x3f) << 12)
	|   (wchar_t)((state->__value.__wchb[2] & 0x3f) << 6)
	|   (wchar_t)(state->__value.__wchb[3] & 0x3f);
      state->__count = 0;
      *pwc = 0xdc00 | ((tmp - 0x10000) & 0x3ff);
      return 2;
    }
d294 1
a294 1
    
d303 1
a303 1
  if (ch >= 0xf0 && ch <= 0xf7)
d315 2
a316 1
      if (state->__value.__wchb[0] == 0xf0 && ch < 0x90)
d318 1
a318 1
	  /* overlong UTF-8 sequence */
d345 20
d377 6
a382 15
      if (tmp > 0xffff && sizeof(wchar_t) == 2)
	{
	  /* On systems which have wchar_t being UTF-16 values, the value
	     doesn't fit into a single wchar_t in this case.  So what we
	     do here is to store the state with a special value of __count
	     and return the first half of a surrogate pair.  As return
	     value we choose to return the half of the actual UTF-8 char.
	     The second half is returned in case we recognize the special
	     __count value above. */
	  state->__value.__wchb[3] = ch;
	  state->__count = 4;
	  *pwc = 0xd800 | (((tmp - 0x10000) >> 10) & 0x3ff);
	  return 2;
	}
      *pwc = tmp;
@


1.13
log
@	* libc/stdlib/mbctype.h (_iseucjp1): Like _iseucjp, but also
	recognizes 0x8e and 0x8f lead bytes.
	(_iseucjp2): Rename from _iseucjp.
	* libc/stdlib/mbtowc_r.c (__eucjp_mbtowc): Convert JIS-X-0212
	triplebyte sequences as well.
	* libc/stdlib/wctomb_r.c (__eucjp_wctomb): Convert to JIS-X-0212
	triplebyte sequences as well.
@
text
@d223 1
a223 5
    {
      if (n < (size_t)-1)
	++n;
      ch = state->__value.__wchb[0];
    }
d243 4
a246 1
      state->__count = 1;
d290 4
a293 1
      state->__count = 2;
d352 4
a355 1
      state->__count = 3;
@


1.12
log
@	* libc/ctype/iswalpha.c: Handle all wchar_t as unicode on
	_MB_CAPABLE systems.
	* libc/ctype/iswblank.c: Ditto.
	* libc/ctype/iswcntrl.c: Ditto.
	* libc/ctype/iswprint.c: Ditto.
	* libc/ctype/iswpunct.c: Ditto.
	* libc/ctype/iswspace.c: Ditto.
	* libc/ctype/jp2uc.c (__jp2uc): On Cygwin, just return c.
	Explain why.
	* libc/ctype/towlower.c: Ditto.
	* libc/ctype/towupper.c: Ditto.
	* libc/include/sys/config.h: Define _MB_EXTENDED_CHARSETS_ISO
	and _MB_EXTENDED_CHARSETS_WINDOWS if _MB_EXTENDED_CHARSETS_ALL is
	defined.  Define _MB_EXTENDED_CHARSETS_ALL on Cygwin only for now.
	* libc/include/sys/reent.h (struct _reent): Mark _current_category
	and _current_locale as unused.
	* libc/locale/locale.c: Add new charset support to documentation.
	Include ../stdio/local.h from here.
	(lc_ctype_charset): Set to "ASCII" by default.
	(lc_message_charset): Ditto.
	(_setlocale_r): Don't set _current_category and _current_locale.
	(loadlocale): Add Cygwin codepage support.  On _MB_CAPABLE
	systems, set __mbtowc and __wctomb function pointers to function
	corresponding with current charset.  Don't allow non-existant
	ISO-8859-12 charset.  Add support for Windows singlebyte codepages.
	On Cygwin, add support for GBK, CP949, and BIG5.  On Cygwin,
	call __set_ctype() in case the catorgy is LC_CTYPE.  Don't set
	_current_category and _current_locale.
	* libc/stdlib/Makefile.am (GENERAL_SOURCES): Add sb_charsets.c.
	* libc/stdlib/Makefile.in: Regenerate.
	* libc/stdlib/local.h: Add prototype for __locale_charset.
	Add prototypes for __mbtowc and __wctomb pointers.
	Add prototypes for charset-specific _wctomb_r and _mbtowc_r
	functions.
	Declare tables and functions from sb_charsets.c.
	* libc/stdlib/mbtowc_r.c (__mbtowc): Define.  Set to __ascii_mbtowc
	by default.
	(_mbtowc_r): Just call __mbtowc from here.
	(__ascii_mbtowc): New function.
	(__iso_mbtowc): New function.
	(__cp_mbtowc): New function.
	(__utf8_mbtowc): New function.
	(__sjis_mbtowc): New function.  Disable on Cygwin.
	(__eucjp_mbtowc): New function.  Disable on Cygwin.
	(__jis_mbtowc): New function.  Disable on Cygwin.
	* libc/stdlib/sb_charsets.c: New file, adding singlebyte to UTF
	conversion tables for all ISO and CP charsets.
	(__iso_8859_index): New function.
	(__cp_index): New function.
	* libc/stdlib/wctomb_r.c (__wctomb): Define.  Set to __ascii_wctomb
	by default.
	(_wctomb_r): Just call __wctomb from here.
	(__ascii_wctomb): New function.
	(__utf8_wctomb): New function.
	(__sjis_wctomb): New function.  Disable on Cygwin.
	(__eucjp_wctomb): New function.  Disable on Cygwin.
	(__jis_wctomb): New function.  Disable on Cygwin.
	(__iso_wctomb): New function.
	(__cp_wctomb): New function.
@
text
@d473 1
a473 1
      if (_iseucjp (ch))
d484 1
a484 1
      if (_iseucjp (ch))
d486 27
a512 1
	  *pwc = (((wchar_t)state->__value.__wchb[0]) << 8) + (wchar_t)ch;
@


1.11
log
@	* libc/stdlib/mbtowc_r.c (_mbtowc_r): Return EILSEQ in case of an
	invalid character sequence.

	* libc/stdlib/mbtowc_r.c (_mbtowc_r): Fix compiler warning due to
	missing declaration of __locale_charset.
	* libc/stdlib/wctomb_r.c (_wctomb_r): Ditto.
@
text
@d8 45
a54 2
extern char *__locale_charset ();

a88 1
#endif /* _MB_CAPABLE */
d93 1
d95 6
a100 5
_DEFUN (_mbtowc_r, (r, pwc, s, n, state),
        struct _reent *r   _AND
        wchar_t       *pwc _AND 
        const char    *s   _AND        
        size_t         n   _AND
d109 4
a112 1
  if (s != NULL && n == 0)
d115 4
a118 33
#ifdef _MB_CAPABLE
  if (strlen (__locale_charset ()) <= 1)
    { /* fall-through */ }
  else if (!strcmp (__locale_charset (), "UTF-8"))
    {
      int ch;
      int i = 0;

      if (s == NULL)
        return 0; /* UTF-8 character encodings are not state-dependent */

      if (state->__count == 4)
	{
	  /* Create the second half of the surrogate pair.  For a description
	     see the comment below. */
	  wint_t tmp = (wchar_t)((state->__value.__wchb[0] & 0x07) << 18)
	    |   (wchar_t)((state->__value.__wchb[1] & 0x3f) << 12)
	    |   (wchar_t)((state->__value.__wchb[2] & 0x3f) << 6)
	    |   (wchar_t)(state->__value.__wchb[3] & 0x3f);
	  state->__count = 0;
	  *pwc = 0xdc00 | ((tmp - 0x10000) & 0x3ff);
	  return 2;
	}
      if (state->__count == 0)
	ch = t[i++];
      else
	{
	  if (n < (size_t)-1)
	    ++n;
	  ch = state->__value.__wchb[0];
	}

      if (ch == '\0')
d120 2
a121 21
	  *pwc = 0;
	  state->__count = 0;
	  return 0; /* s points to the null character */
	}

      if (ch >= 0x0 && ch <= 0x7f)
	{
	  /* single-byte sequence */
	  state->__count = 0;
	  *pwc = ch;
	  return 1;
	}
      else if (ch >= 0xc0 && ch <= 0xdf)
	{
	  /* two-byte sequence */
	  state->__value.__wchb[0] = ch;
	  state->__count = 1;
	  if (n < 2)
	    return -2;
	  ch = t[i++];
	  if (ch < 0x80 || ch > 0xbf)
d126 1
a126 10
	  if (state->__value.__wchb[0] < 0xc2)
	    {
	      /* overlong UTF-8 sequence */
	      r->_errno = EILSEQ;
	      return -1;
	    }
	  state->__count = 0;
	  *pwc = (wchar_t)((state->__value.__wchb[0] & 0x1f) << 6)
	    |    (wchar_t)(ch & 0x3f);
	  return i;
d128 37
a164 1
      else if (ch >= 0xe0 && ch <= 0xef)
d166 2
a167 11
	  /* three-byte sequence */
	  wchar_t tmp;
	  state->__value.__wchb[0] = ch;
	  if (state->__count == 0)
	    state->__count = 1;
	  else if (n < (size_t)-1)
	    ++n;
	  if (n < 2)
	    return -2;
	  ch = (state->__count == 1) ? t[i++] : state->__value.__wchb[1];
	  if (state->__value.__wchb[0] == 0xe0 && ch < 0xa0)
a168 1
	      /* overlong UTF-8 sequence */
d172 1
a172 27
	  if (ch < 0x80 || ch > 0xbf)
	    {
	      r->_errno = EILSEQ;
	      return -1;
	    }
	  state->__value.__wchb[1] = ch;
	  state->__count = 2;
	  if (n < 3)
	    return -2;
	  ch = t[i++];
	  if (ch < 0x80 || ch > 0xbf)
	    {
	      r->_errno = EILSEQ;
	      return -1;
	    }
	  state->__count = 0;
	  tmp = (wchar_t)((state->__value.__wchb[0] & 0x0f) << 12)
	    |    (wchar_t)((state->__value.__wchb[1] & 0x3f) << 6)
	    |     (wchar_t)(ch & 0x3f);
	
	  if (tmp >= 0xd800 && tmp <= 0xdfff)
	    {
	      r->_errno = EILSEQ;
	      return -1;
	    }
	  *pwc = tmp;
	  return i;
d174 78
a251 1
      else if (ch >= 0xf0 && ch <= 0xf7)
d253 2
a254 65
	  /* four-byte sequence */
	  wint_t tmp;
	  state->__value.__wchb[0] = ch;
	  if (state->__count == 0)
	    state->__count = 1;
	  else if (n < (size_t)-1)
	    ++n;
	  if (n < 2)
	    return -2;
	  ch = (state->__count == 1) ? t[i++] : state->__value.__wchb[1];
	  if (state->__value.__wchb[0] == 0xf0 && ch < 0x90)
	    {
	      /* overlong UTF-8 sequence */
	      r->_errno = EILSEQ;
	      return -1;
	    }
	  if (ch < 0x80 || ch > 0xbf)
	    {
	      r->_errno = EILSEQ;
	      return -1;
	    }
	  state->__value.__wchb[1] = ch;
	  if (state->__count == 1)
	    state->__count = 2;
	  else if (n < (size_t)-1)
	    ++n;
	  if (n < 3)
	    return -2;
	  ch = (state->__count == 2) ? t[i++] : state->__value.__wchb[2];
	  if (ch < 0x80 || ch > 0xbf)
	    {
	      r->_errno = EILSEQ;
	      return -1;
	    }
	  state->__value.__wchb[2] = ch;
	  state->__count = 3;
	  if (n < 4)
	    return -2;
	  ch = t[i++];
	  if (ch < 0x80 || ch > 0xbf)
	    {
	      r->_errno = EILSEQ;
	      return -1;
	    }
	  tmp = (wint_t)((state->__value.__wchb[0] & 0x07) << 18)
	    |   (wint_t)((state->__value.__wchb[1] & 0x3f) << 12)
	    |   (wint_t)((state->__value.__wchb[2] & 0x3f) << 6)
	    |   (wint_t)(ch & 0x3f);
	  if (tmp > 0xffff && sizeof(wchar_t) == 2)
	    {
	      /* On systems which have wchar_t being UTF-16 values, the value
		 doesn't fit into a single wchar_t in this case.  So what we
		 do here is to store the state with a special value of __count
		 and return the first half of a surrogate pair.  As return
		 value we choose to return the half of the actual UTF-8 char.
		 The second half is returned in case we recognize the special
		 __count value above. */
	      state->__value.__wchb[3] = ch;
	      state->__count = 4;
	      *pwc = 0xd800 | (((tmp - 0x10000) >> 10) & 0x3ff);
	      return 2;
	    }
	  *pwc = tmp;
	  state->__count = 0;
	  return i;
d256 1
a256 1
      else
d258 1
d262 6
a267 2
    }      
  else if (!strcmp (__locale_charset (), "SJIS"))
d269 25
a293 4
      int ch;
      int i = 0;
      if (s == NULL)
        return 0;  /* not state-dependent */
d295 1
a295 1
      if (state->__count == 0)
d297 2
a298 8
	  if (_issjis1 (ch))
	    {
	      state->__value.__wchb[0] = ch;
	      state->__count = 1;
	      if (n <= 1)
		return -2;
	      ch = t[i++];
	    }
d300 6
a305 1
      if (state->__count == 1)
d307 2
a308 11
	  if (_issjis2 (ch))
	    {
	      *pwc = (((wchar_t)state->__value.__wchb[0]) << 8) + (wchar_t)ch;
	      state->__count = 0;
	      return i;
	    }
	  else  
	    {
	      r->_errno = EILSEQ;
	      return -1;
	    }
d310 2
d313 1
a313 1
  else if (!strcmp (__locale_charset (), "EUCJP"))
d315 3
a317 5
      int ch;
      int i = 0;
      if (s == NULL)
        return 0;  /* not state-dependent */
      ch = t[i++];
d319 7
d327 8
a334 8
	  if (_iseucjp (ch))
	    {
	      state->__value.__wchb[0] = ch;
	      state->__count = 1;
	      if (n <= 1)
		return -2;
	      ch = t[i++];
	    }
d336 1
d338 7
d346 76
a421 11
	  if (_iseucjp (ch))
	    {
	      *pwc = (((wchar_t)state->__value.__wchb[0]) << 8) + (wchar_t)ch;
	      state->__count = 0;
	      return i;
	    }
	  else
	    {
	      r->_errno = EILSEQ;
	      return -1;
	    }
d424 1
a424 1
  else if (!strcmp (__locale_charset (), "JIS"))
d426 17
a442 48
      JIS_STATE curr_state;
      JIS_ACTION action;
      JIS_CHAR_TYPE ch;
      unsigned char *ptr;
      unsigned int i;
      int curr_ch;
 
      if (s == NULL)
        {
          state->__state = ASCII;
          return 1;  /* state-dependent */
        }

      curr_state = state->__state;
      ptr = t;

      for (i = 0; i < n; ++i)
        {
          curr_ch = t[i];
          switch (curr_ch)
            {
	    case ESC_CHAR:
              ch = ESCAPE;
              break;
	    case '$':
              ch = DOLLAR;
              break;
            case '@@':
              ch = AT;
              break;
            case '(':
	      ch = BRACKET;
              break;
            case 'B':
              ch = B;
              break;
            case 'J':
              ch = J;
              break;
            case '\0':
              ch = NUL;
              break;
            default:
              if (_isjis (curr_ch))
                ch = JIS_CHAR;
              else
                ch = OTHER;
	    }
d444 2
a445 30
          action = JIS_action_table[curr_state][ch];
          curr_state = JIS_state_table[curr_state][ch];
        
          switch (action)
            {
            case NOOP:
              break;
            case EMPTY:
              state->__state = ASCII;
              *pwc = (wchar_t)0;
              return 0;
            case COPY_A:
	      state->__state = ASCII;
              *pwc = (wchar_t)*ptr;
              return (i + 1);
            case COPY_J1:
              state->__value.__wchb[0] = t[i];
	      break;
            case COPY_J2:
              state->__state = JIS;
              *pwc = (((wchar_t)state->__value.__wchb[0]) << 8) + (wchar_t)(t[i]);
              return (i + 1);
            case MAKE_A:
              ptr = (unsigned char *)(t + i + 1);
              break;
            case ERROR:
            default:
	      r->_errno = EILSEQ;
              return -1;
            }
d447 13
a459 1
        }
d461 2
a462 4
      state->__state = curr_state;
      return -2;  /* n < bytes needed */
    }
#endif /* _MB_CAPABLE */               
a463 1
  /* otherwise this must be the "C" locale or unknown locale */
d465 31
a495 1
    return 0;  /* not state-dependent */
d504 105
@


1.10
log
@	* libc/locale/locale.c (_setlocale_r): New implementation based on
	FreeBSD's setlocale.
	(currentlocale): New helper function.
	(loadlocale): Ditto.
	(__locale_charset): New function.
	(__locale_msgcharset): Rename from __locale_charset.
	* libc/ctype/local.h (__lc_ctype): Remove declaration.
	(__locale_charset): Declare.
	* libc/ctype/iswalpha.c (iswalpha): Call __locale_charset instead of
	using __lc_ctype directly.  Only compare against the charset alone.
	* libc/ctype/iswblank.c (iswblank): Ditto.
	* libc/ctype/iswcntrl.c (iswcntrl): Ditto.
	* libc/ctype/iswprint.c (iswprint): Ditto.
	* libc/ctype/iswpunct.c (iswpunct): Ditto.
	* libc/ctype/iswspace.c (iswspace): Ditto.
	* libc/ctype/towlower.c (towlower): Ditto.
	* libc/ctype/towupper.c (towupper): Ditto.
	* libc/stdlib/mbtowc_r.c (_mbtowc_r): Ditto.
	* libc/stdlib/wctomb_r.c (_wctomb_r): Ditto.
	* libc/sys/linux/intl/loadmsgcat.c (_nl_init_domain_conv): Call
	__locale_msgcharset instead of __locale_charset.
@
text
@d7 1
d10 2
d123 4
a126 1
	    return -1;
d128 5
a132 2
	    /* overlong UTF-8 sequence */
	    return -1;
d151 5
a155 2
	    /* overlong UTF-8 sequence */
	    return -1;
d157 4
a160 1
	    return -1;
d167 4
a170 1
	    return -1;
d177 4
a180 1
	    return -1;
d197 5
a201 2
	    /* overlong UTF-8 sequence */
	    return -1;
d203 4
a206 1
	    return -1;
d216 4
a219 1
	    return -1;
d226 4
a229 1
	    return -1;
d253 4
a256 1
	return -1;
d285 4
a288 1
	    return -1;
d318 4
a321 1
	    return -1;
d402 1
@


1.9
log
@	* mbtowc_r.c (_mbtowc_r): Remove conversion of 5 and 6 byte UTF-8
	sequences since they are invalid in the Unicode standard.
	Handle surrogate pairs in case of wchar_t == UTF-16.
	* wctomb_r.c (_wctomb_r): Don't convert invalid Unicode wchar_t
	values beyond 0x10ffff into UTF-8 chars.  Handle surrogate pairs in
	case of wchar_t == UTF-16.
@
text
@a47 2
extern char __lc_ctype[12];

d66 1
a66 1
  if (strlen (__lc_ctype) <= 1)
d68 1
a68 1
  else if (!strcmp (__lc_ctype, "C-UTF-8"))
d222 1
a222 1
  else if (!strcmp (__lc_ctype, "C-SJIS"))
d252 1
a252 1
  else if (!strcmp (__lc_ctype, "C-EUCJP"))
d282 1
a282 1
  else if (!strcmp (__lc_ctype, "C-JIS"))
@


1.8
log
@
2009-02-18  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/open_memstream.c (internal_open_memstream_r): Fix max
        buffer size to be in wchar_t units if wide == 1 is passed in.  In
        this case, also initialize the first character of the buffer to be
        wide char null.
        (_open_wmemstream_r): Cast buf to be (char **) to avoid warning.
        * libc/stdlib/mbtowc_r.c (_mbtowc_r): Change all occurences of
        incrementing the size_t value n to first check that n is not already
        size_t -1.  Fix some compiler warnings.
        * libc/stdlib/wcstod.c: Add includes for <wctype.h> and <math.h>.
@
text
@d78 12
d168 1
a168 2
	  if (sizeof(wchar_t) < 4)
	    return -1; /* we can't store such a value */
d199 19
a217 119
	  *pwc = (wchar_t)((state->__value.__wchb[0] & 0x07) << 18)
	    |    (wchar_t)((state->__value.__wchb[1] & 0x3f) << 12)
	    |    (wchar_t)((state->__value.__wchb[2] & 0x3f) << 6)
	    |    (wchar_t)(ch & 0x3f);
	
	  state->__count = 0;
	  return i;
	}
      else if (ch >= 0xf8 && ch <= 0xfb)
	{
	  /* five-byte sequence */
	  if (sizeof(wchar_t) < 4)
	    return -1; /* we can't store such a value */
	  state->__value.__wchb[0] = ch;
	  if (state->__count == 0)
	    state->__count = 1;
	  else if (n < (size_t)-1)
	    ++n;
	  if (n < 2)
	    return -2;
	  ch = (state->__count == 1) ? t[i++] : state->__value.__wchb[1];
	  if (state->__value.__wchb[0] == 0xf8 && ch < 0x88)
	    /* overlong UTF-8 sequence */
	    return -1;
	  if (ch < 0x80 || ch > 0xbf)
	    return -1;
	  state->__value.__wchb[1] = ch;
	  if (state->__count == 1)
	    state->__count = 2;
	  else if (n < (size_t)-1)
	    ++n;
	  if (n < 3)
	    return -2;
	  ch = (state->__count == 2) ? t[i++] : state->__value.__wchb[2];
	  if (ch < 0x80 || ch > 0xbf)
	    return -1;
	  state->__value.__wchb[2] = ch;
	  if (state->__count == 2)
	    state->__count = 3;
	  else if (n < (size_t)-1)
	    ++n;
	  if (n < 4)
	    return -2;
	  ch = (state->__count == 3) ? t[i++] : state->__value.__wchb[3];
	  if (ch < 0x80 || ch > 0xbf)
	    return -1;
	  state->__value.__wchb[3] = ch;
	  state->__count = 4;
	  if (n < 5)
	    return -2;
	  ch = t[i++];
	  *pwc = (wchar_t)((state->__value.__wchb[0] & 0x03) << 24)
	    |    (wchar_t)((state->__value.__wchb[1] & 0x3f) << 18)
	    |    (wchar_t)((state->__value.__wchb[2] & 0x3f) << 12)
	    |    (wchar_t)((state->__value.__wchb[3] & 0x3f) << 6)
	    |    (wchar_t)(ch & 0x3f);
	
	  state->__count = 0;
	  return i;
	}
      else if (ch >= 0xfc && ch <= 0xfd)
        {
          /* six-byte sequence */
	  int ch2;
	  if (sizeof(wchar_t) < 4)
	    return -1; /* we can't store such a value */
	  state->__value.__wchb[0] = ch;
	  if (state->__count == 0)
	    state->__count = 1;
	  else if (n < (size_t)-1)
	    ++n;
	  if (n < 2)
	    return -2;
	  ch = (state->__count == 1) ? t[i++] : state->__value.__wchb[1];
	  if (state->__value.__wchb[0] == 0xfc && ch < 0x84)
	    /* overlong UTF-8 sequence */
	    return -1;
	  if (ch < 0x80 || ch > 0xbf)
	    return -1;
	  state->__value.__wchb[1] = ch;
	  if (state->__count == 1)
	    state->__count = 2;
	  else if (n < (size_t)-1)
	    ++n;
	  if (n < 3)
	    return -2;
	  ch = (state->__count == 2) ? t[i++] : state->__value.__wchb[2];
	  if (ch < 0x80 || ch > 0xbf)
	    return -1;
	  state->__value.__wchb[2] = ch;
	  if (state->__count == 2)
	    state->__count = 3;
	  else if (n < (size_t)-1)
	    ++n;
	  if (n < 4)
	    return -2;
	  ch = (state->__count == 3) ? t[i++] : state->__value.__wchb[3];
	  if (ch < 0x80 || ch > 0xbf)
	    return -1;
	  state->__value.__wchb[3] = ch;
	  if (state->__count == 3)
	    state->__count = 4;
	  else if (n < (size_t)-1)
	    ++n;
	  if (n < 5)
	    return -2;
	  if (n == 5)
	    return -1; /* at this point we can't save enough to restart */
	  ch = t[i++];
	  if (ch < 0x80 || ch > 0xbf)
	    return -1;
	  ch2 = t[i++];
	  *pwc = (wchar_t)((state->__value.__wchb[0] & 0x01) << 30)
	    |    (wchar_t)((state->__value.__wchb[1] & 0x3f) << 24)
	    |    (wchar_t)((state->__value.__wchb[2] & 0x3f) << 18)
	    |    (wchar_t)((state->__value.__wchb[3] & 0x3f) << 12)
	    |    (wchar_t)((ch & 0x3f) << 6)
	    |    (wchar_t)(ch2 & 0x3f);
	
@


1.7
log
@
2004-04-23  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * configure.in: Define _MB_CAPABLE if mb supported.
        * configure: Regenerated.
        * configure.host: Remove manual setting of MB_CAPABLE compiler
        flag.
        * newlib.hin: Add _MB_CAPABLE flag.
        * libc/ctype/iswalpha.c, libc/ctype/iswblank.c: Include <newlib.h>
        and check for _MB_CAPABLE flag instead of MB_CAPABLE.
        * libc/ctype/iswcntrl.c, libc/ctype/iswprint.c: Ditto.
        * libc/ctype/iswpunct.c, libc/ctype/iswspace.c: Ditto.
        * libc/ctype/jp2uc.c: Ditto.
        * libc/ctype/towlower.c, libc/ctype/towupper.c: Ditto.
        * libc/locale/locale.c: Ditto
        * libc/machine/powerpc/vfscanf.c: Ditto
        * libc/stdio/vfprintf.c, libc/stdio/vfscanf.c: Ditto
        * libc/stdlib/mblen.c: Ditto
        * libc/stdlib/mblen_r.c, libc/stdlib/mbrlen.c: Ditto
        * libc/stdlib/mbrtowc.c, libc/stdlib/mbsrtowcs.c: Ditto
        * libc/stdlib/mbstowcs.c, libc/stdlib/mbtowc.c: Ditto
        * libc/stdlib/mbtowc_r.c, libc/stdlib/wcrtomb.c: Ditto
        * libc/stdlib/wcsrtombs.c, libc/stdlib/wcstombs.c: Ditto
        * libc/stdlib/wctomb.c, libc/sys/linux/intl/dcigettext.c: Ditto
        * libc/sys/linux/intl/explodename.c: Ditto
        * libc/sys/linux/intl/finddomain.c: Ditto
        * libc/sys/linux/intl/l10nflist.c: Ditto
        * libc/sys/linux/intl/loadmsgcat.c: Ditto
        * libc/sys/linux/intl/localealias.c: Ditto
@
text
@d68 1
a68 2
  if (__lc_ctype == NULL ||
      (strlen (__lc_ctype) <= 1))
d82 2
a83 1
	  ++n;
d126 1
a126 1
	  else
d161 1
a161 1
	  else
d174 1
a174 1
	  else
d204 1
a204 1
	  else
d217 1
a217 1
	  else
d227 1
a227 1
	  else
d257 1
a257 1
	  else
d270 1
a270 1
	  else
d280 1
a280 1
	  else
d290 1
a290 1
	  else
d447 1
a447 1
              ptr = (char *)(t + i + 1);
@


1.6
log
@
2002-09-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/ctype/Makefile.am: Add new files.
        * libc/ctype/Makefile.in: Regenerated.
        * libc/ctype/ctype.tex: Add new iswxxxx, towxxxx, wctype,
        and wctrans functions to documentation index.
        * libc/ctype/iswalnum.c: New file.
        * libc/ctype/iswalpha.c: Ditto.
        * libc/ctype/iswblank.c: Ditto.
        * libc/ctype/iswcntrl.c: Ditto.
        * libc/ctype/iswctype.c: Ditto.
        * libc/ctype/iswdigit.c: Ditto.
        * libc/ctype/iswgraph.c: Ditto.
        * libc/ctype/iswlower.c: Ditto.
        * libc/ctype/iswprint.c: Ditto.
        * libc/ctype/iswpunct.c: Ditto.
        * libc/ctype/iswspace.c: Ditto.
        * libc/ctype/iswupper.c: Ditto.
        * libc/ctype/iswxdigit.c: Ditto.
        * libc/ctype/jp2uc.c: Ditto.
        * libc/ctype/jp2uc.h: Ditto.
        * libc/ctype/local.h: Ditto.
        * libc/ctype/towctrans.c: Ditto.
        * libc/ctype/towlower.c: Ditto.
        * libc/ctype/towupper.c: Ditto.
        * libc/ctype/utf8alpha.h: Ditto.
        * libc/ctype/utf8print.h: Ditto.
        * libc/ctype/utf8punct.h: Ditto.
        * libc/ctype/wctrans.c: Ditto.
        * libc/ctype/wctype.c: Ditto.
        * libc/locale/locale.c (__lc_ctype): New external array to
        replace static lc_ctype array.
        * libc/stdlib/mbtowc_r.c: Use __lc_ctype to check current lc_ctype
        rather than reentrancy structure's _current_locale field.
        * libc/stdlib/wctomb_r.c: Ditto.
@
text
@d1 1
d8 1
a8 1
#ifdef MB_CAPABLE
d43 1
a43 1
#endif /* MB_CAPABLE */
d67 1
a67 1
#ifdef MB_CAPABLE
d459 1
a459 1
#endif /* MB_CAPABLE */               
@


1.5
log
@
2002-09-09  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/sys/_types.h (_mbstate_t): Changed to use
        unsigned char internally.
        * libc/sys/linux/sys/_types.h: Ditto.
        * libc/include/sys/reent.h
        * libc/stdlib/mblen.c (mblen): Use function-specific state
        value from default reentrancy structure.
        * libc/stdlib/mblen_r.c (_mblen_r):  If return code from
        _mbtowc_r is less than 0, reset state __count value and
        return -1.
        * libc/stdlib/mbrlen.c (mbrlen): If the input state pointer
        is NULL, use the function-specific pointer provided in the
        default reentrancy structure.
        * libc/stdlib/mbrtowc.c: Add reentrant form of function.
        If input state pointer is NULL, use function-specific area
        provided in reentrancy structure.
        * libc/stdlib/mbsrtowcs.c: Ditto.
        * libc/stdlib/wcrtomb.c: Ditto.
        * libc/stdlib/wcsrtombs.c: Ditto.
        * libc/stdlib/mbstowcs.c: Reformat.
        * libc/stdlib/wcstombs.c: Ditto.
        * libc/stdlib/mbstowcs_r.c (_mbstowcs_r): If an error occurs,
        reset the state's __count value and return -1.
        * libc/stdlib/mbtowc.c: Ditto.
        * libc/stdlib/mbtowc_r.c (_mbtowc_r): Add restartable functionality.
        If number of bytes is used up before completing a valid multibyte
        character, return -2 and save the state.
        * libc/stdlib/wctomb_r.c (_wctomb_r): Define __state as __count
        and change some __count references to __state for clarity.
@
text
@d47 2
d67 2
a68 2
  if (r->_current_locale == NULL ||
      (strlen (r->_current_locale) <= 1))
d70 1
a70 1
  else if (!strcmp (r->_current_locale, "C-UTF-8"))
d312 1
a312 1
  else if (!strcmp (r->_current_locale, "C-SJIS"))
d342 1
a342 1
  else if (!strcmp (r->_current_locale, "C-EUCJP"))
d372 1
a372 1
  else if (!strcmp (r->_current_locale, "C-JIS"))
@


1.4
log
@	* libc/include/langinfo.h: New file.
	* libc/include/wchar.h: Likewise.
	* libc/include/sys/syslimits.h: Likewise.
	* libc/locale/fix_grouping.c: Likewise.
	* libc/locale/ldpart.c: Likewise.
	* libc/locale/ldpart.h: Likewise.
	* libc/locale/lmessages.c: Likewise.
	* libc/locale/lmessages.h: Likewise.
	* libc/locale/lmonetary.c: Likewise.
	* libc/locale/lmonetary.h: Likewise.
	* libc/locale/lnumeric.c: Likewise.
	* libc/locale/lnumeric.h: Likewise.
	* libc/locale/nl_langinfo.3: Likewise.
	* libc/locale/nl_langinfo.c: Likewise.
	* libc/locale/timelocal.c: Likewise.
	* libc/locale/timelocal.h: Likewise.
	* libc/stdlib/btowc.c: Likewise.
	* libc/stdlib/mbrlen.c: Likewise.
	* libc/stdlib/mbrtowc.c: Likewise.
	* libc/stdlib/mbsinit.c: Likewise.
	* libc/stdlib/mbsrtowcs.c: Likewise.
	* libc/stdlib/wcrtomb.c: Likewise.
	* libc/stdlib/wcsrtombs.c: Likewise.
	* libc/stdlib/wctob.c: Likewise.
	* libc/sys/linux/prof-freq.c: Likewise.
	* libc/sys/linux/profile.c: Likewise.
	* libc/sys/linux/machine/i386/dl-procinfo.c: Likewise.
	* libc/sys/linux/machine/i386/dl-procinfo.h: Likewise.
	* libc/include/stdlib.h: Change re-entrant functions to take
	mbstate_t pointers.
	* libc/include/sys/_types.h: Define _mbstate_t.
	* libc/include/sys/config.h (MB_LEN_MAX): New macro.
	* libc/include/sys/errno.h (EILSEQ): New error code.
	* libc/include/sys/reent.h: Include wchar.h.  Change reentrant
	structure to use mbstate_t.
	* libc/locale/Makefile.am (LIB_SOURCES): Add new files.
	* libc/machine/powerpc/vfprintf.c: Use mbstate_t.
	* libc/machine/powerpc/vfscanf.c: Likewise.
	* libc/stdio/getdelim.c: Reallocate buffer only when necessary.
	* libc/stdio/vfprintf.c: Likewise.
	* libc/stdio/vfscanf.c: Likewise.
	* libc/stdlib/Makefile.am (LIB_SOURCES): Add new files.
	* libc/stdlib/mblen.c: Use mbstate_t.
	* libc/stdlib/mblen_r.c: Likewise.
	* libc/stdlib/mbstowcs.c: Likewise.
	* libc/stdlib/mbstowcs_r.c: Likewise.
	* libc/stdlib/mbtowc.c: Likewise.
	* libc/stdlib/mbtowc_r.c: Likewise.
	* libc/stdlib/wcstombs.c: Likewise.
	* libc/stdlib/wcstombs_r.c: Likewise.
	* libc/stdlib/wctomb_r.c: Likewise.
	* libc/sys/linux/Makefile.am (LIB_SOURCES): Add prof-freq.c and
	profile.c.
	* libc/sys/linux/machine/i386/Makefile.am (LIB_SOURCES): Add
	dl-procinfo.c.
	* libc/sys/linux/sys/errno.h (EILSEQ): New error code.
	* libc/sys/linux/sys/types.h (off_t): Define type.
	* testsuite/newlib.locale/UTF-8.c: Change locale name from UTF-8
	to C-UTF-8.
	* testsuite/newlib.locale/UTF-8.exp: Likewise.
@
text
@d10 3
a12 3
typedef enum { ASCII, A_ESC, A_ESC_DL, JIS, JIS_1, JIS_2, J_ESC, J_ESC_BR,
               J2_ESC, J2_ESC_BR, DONE, INV, JIS_S_NUM } JIS_STATE; 
typedef enum { COPY_A, COPY_J, COPY_J2, MAKE_A, MAKE_J, NOOP, EMPTY, ERROR } JIS_ACTION;
d23 1
a23 3
/* ASCII */   { A_ESC,   DONE,     DONE,     DONE,    DONE,   DONE,    DONE,    DONE,     DONE },
/* A_ESC */   { DONE,    A_ESC_DL, DONE,     DONE,    DONE,   DONE,    DONE,    DONE,     DONE },
/* A_ESC_DL */{ DONE,    DONE,     DONE,     JIS,     JIS,    DONE,    DONE,    DONE,     DONE }, 
d25 3
a27 2
/* JIS_1 */   { INV,     JIS_2,    JIS_2,    JIS_2,   JIS_2,  JIS_2,   INV,     JIS_2,    INV },
/* JIS_2 */   { J2_ESC,  DONE,     DONE,     DONE,    DONE,   DONE,    INV,     DONE,     DONE },
a29 2
/* J2_ESC */  { INV,     INV,      J2_ESC_BR,INV,     INV,    INV,     INV,     INV,      INV },
/* J2_ESC_BR*/{ INV,     INV,      INV,      INV,     DONE,   DONE,    INV,     INV,      INV },
d35 1
d37 2
a38 4
/* A_ESC_DL */{ COPY_A,  COPY_A,   COPY_A,   MAKE_J,  MAKE_J,  COPY_A,  COPY_A,  COPY_A,  COPY_A},
/* JIS */     { NOOP,    NOOP,     NOOP,     NOOP,    NOOP,    NOOP,    ERROR,   NOOP,    ERROR },
/* JIS_1 */   { ERROR,   NOOP,     NOOP,     NOOP,    NOOP,    NOOP,    ERROR,   NOOP,    ERROR },
/* JIS_2 */   { NOOP,    COPY_J2,  COPY_J2,  COPY_J2, COPY_J2, COPY_J2, ERROR,   COPY_J2, COPY_J2},
d40 1
a40 3
/* J_ESC_BR */{ ERROR,   ERROR,    ERROR,    ERROR,   NOOP,    NOOP,    ERROR,   ERROR,   ERROR },
/* J2_ESC */  { ERROR,   ERROR,    NOOP,     ERROR,   ERROR,   ERROR,   ERROR,   ERROR,   ERROR },
/* J2_ESC_BR*/{ ERROR,   ERROR,    ERROR,    ERROR,   COPY_J,  COPY_J,  ERROR,   ERROR,   ERROR },
d44 3
d70 2
a71 1
      wchar_t char1 = 0;
d76 170
a245 138
      /* we know n >= 1 if we get here */
      *pwc = 0;
      char1 = (wchar_t)*t;

      if (char1 == '\0')
        return 0; /* s points to the null character */

      if (char1 >= 0x0 && char1 <= 0x7f)
        {
          /* single-byte sequence */
          *pwc = char1;
          return 1;
        }
      else if (char1 >= 0xc0 && char1 <= 0xdf)
        {
          /* two-byte sequence */
          if (n >= 2)
            {
              wchar_t char2 = (wchar_t)*(t+1);

              if (char2 < 0x80 || char2 > 0xbf)
                return -1;

              if (char1 < 0xc2)
                /* overlong UTF-8 sequence */
                return -1;

              *pwc = ((char1 & 0x1f) << 6)
                |     (char2 & 0x3f);
              return 2;
            }
          else
            return -1;
        }
      else if (char1 >= 0xe0 && char1 <= 0xef)
        {
          /* three-byte sequence */
          if (n >= 3)
            {
              wchar_t char2 = (wchar_t)*(t+1);
              wchar_t char3 = (wchar_t)*(t+2);

              if (char2 < 0x80 || char2 > 0xbf)
                return -1;
              if (char3 < 0x80 || char3 > 0xbf)
                return -1;

              if (char1 == 0xe0)
                {
                  if (char2 < 0xa0)
                    /* overlong UTF-8 sequence */
                    return -1;
                }

              *pwc = ((char1 & 0x0f) << 12)
                |    ((char2 & 0x3f) << 6)
                |     (char3 & 0x3f);

              if (*pwc >= 0xd800 && *pwc <= 0xdfff)
                {
                  return -1;
                }
              else
                return 3;
            }
          else
            return -2;
        }
      else if (char1 >= 0xf0 && char1 <= 0xf7)
        {
          /* four-byte sequence */
          if (n >= 4)
            {
              wchar_t char2 = (wchar_t)*(t+1);
              wchar_t char3 = (wchar_t)*(t+2);
              wchar_t char4 = (wchar_t)*(t+3);

              if (char2 < 0x80 || char2 > 0xbf)
                return -1;
              if (char3 < 0x80 || char3 > 0xbf)
                return -1;
              if (char4 < 0x80 || char4 > 0xbf)
                return -1;

              if (char1 == 0xf0)
                {
                  if (char2 < 0x90)
                    /* overlong UTF-8 sequence */
                    return -1;
                }
                    
              *pwc = ((char1 & 0x07) << 18)
                |    ((char2 & 0x3f) << 12)
                |    ((char3 & 0x3f) << 6)
                |     (char4 & 0x3f);

              return 4;
            }
          else
            return -2;
        }
      else if (char1 >= 0xf8 && char1 <= 0xfb)
        {
          /* five-byte sequence */
          if (n >= 5)
            {
              wchar_t char2 = (wchar_t)*(t+1);
              wchar_t char3 = (wchar_t)*(t+2);
              wchar_t char4 = (wchar_t)*(t+3);
              wchar_t char5 = (wchar_t)*(t+4);

              if (char2 < 0x80 || char2 > 0xbf)
                return -1;
              if (char3 < 0x80 || char3 > 0xbf)
                return -1;
              if (char4 < 0x80 || char4 > 0xbf)
                return -1;
              if (char5 < 0x80 || char5 > 0xbf)
                return -1;

              if (char1 == 0xf8)
                {
                  if (char2 < 0x88)
                    /* overlong UTF-8 sequence */
                    return -1;
                }
                    
              *pwc = ((char1 & 0x03) << 24)
                |    ((char2 & 0x3f) << 18)
                |    ((char3 & 0x3f) << 12)
                |    ((char4 & 0x3f) << 6)
                |     (char5 & 0x3f);
              return 5;
            }
          else
            return -2;
        }
      else if (char1 >= 0xfc && char1 <= 0xfd)
d248 59
a306 37
          if (n >= 6)
            {
              wchar_t char2 = (wchar_t)*(t+1);
              wchar_t char3 = (wchar_t)*(t+2);
              wchar_t char4 = (wchar_t)*(t+3);
              wchar_t char5 = (wchar_t)*(t+4);
              wchar_t char6 = (wchar_t)*(t+5);

              if (char2 < 0x80 || char2 > 0xbf)
                return -1;
              if (char3 < 0x80 || char3 > 0xbf)
                return -1;
              if (char4 < 0x80 || char4 > 0xbf)
                return -1;
              if (char5 < 0x80 || char5 > 0xbf)
                return -1;
              if (char6 < 0x80 || char6 > 0xbf)
                return -1;

              if (char1 == 0xfc)
                {
                  if (char2 < 0x84)
                    /* overlong UTF-8 sequence */
                    return -1;
                }

              *pwc = ((char1 & 0x01) << 30)
                |    ((char2 & 0x3f) << 24)
                |    ((char3 & 0x3f) << 18)
                |    ((char4 & 0x3f) << 12)
                |    ((char5 & 0x3f) << 6)
                |     (char6 & 0x3f);
              return 6;
            }
          else
            return -2;
        }
d308 1
a308 1
        return -1;
d312 2
a313 1
      int char1;
d316 23
a338 14
      char1 = *t;
      if (_issjis1 (char1))
        {
          int char2 = t[1];
          if (n <= 1)
            return -2;
          if (_issjis2 (char2))
            {
              *pwc = (((wchar_t)*t) << 8) + (wchar_t)(*(t+1));
              return 2;
            }
          else  
            return -1;
        }
d342 2
a343 1
      int char1;
d346 23
a368 14
      char1 = *t;
      if (_iseucjp (char1))
        {
          int char2 = t[1];     
          if (n <= 1)
            return -2;
          if (_iseucjp (char2))
            {
              *pwc = (((wchar_t)*t) << 8) + (wchar_t)(*(t+1));
              return 2;
            }
          else
            return -1;
        }
d376 2
a377 1
      int i, curr_ch;
d381 1
a381 1
          state->__count = 0;
d385 1
a385 1
      curr_state = (state->__count == 0 ? ASCII : JIS);
d429 1
a429 1
              state->__count = 0;
d431 1
a431 1
              return i;
d433 1
a433 1
	      state->__count = 0;
d436 6
a441 3
            case COPY_J:
              state->__count = 0;
              *pwc = (((wchar_t)*ptr) << 8) + (wchar_t)(*(ptr+1));
a442 4
            case COPY_J2:
              state->__count = 1;
              *pwc = (((wchar_t)*ptr) << 8) + (wchar_t)(*(ptr+1));
              return (ptr - t) + 2;
a443 1
            case MAKE_J:
d453 1
@


1.3
log
@	* Makefile.am (check-DEJAGNU): New target.
	(site.exp): Likewise.
	* acinclude.m4 (NEWLIB_CONFIGURE): Replace AC_CANONICAL_HOST
	with AC_CANONICAL_SYSTEM.  Remove AC_CANONICAL_BUILD.
	* libc/locale/locale.c (_setlocale_r): Add UTF-8 support.
	* libc/stdlib/mbtowc_r.c (_mbtowc_r): Likewise.
	* libc/stdlib/wctomb_r.c (_wctomb_r): Likewise.
	* testsuite: New directory.
	* testsuite/config: Likewise.
	* testsuite/lib: Likewise.
	* testsuite/newlib.locale: Likewise.
	* testsuite/newlib.string: Likewise.
	* testsuite/config/default.exp: New file.
	* testsuite/lib/checkoutput.exp: New file.
	* testsuite/lib/newlib.exp: New file.
	* testsuite/lib/passfail.exp: New file.
	* testsuite/newlib.locale/UTF-8.c: New file.
	* testsuite/newlib.locale/UTF-8.exp: New file.
	* testsuite/newlib.locale/locale.exp: New file.
	* testsuite/newlib.string/string.exp: New file.
	* testsuite/newlib.string/tstring.c: New file.
@
text
@d4 2
d56 1
a56 1
        int           *state)
d65 1
a65 1
    return -1;
d71 1
a71 1
  else if (!strcmp (r->_current_locale, "UTF-8"))
d144 1
a144 1
            return -1;
d177 1
a177 1
            return -1;
d213 1
a213 1
            return -1;
d253 1
a253 1
            return -1;
d268 1
a268 1
            return -1;
d288 1
a288 1
            return -1;
d308 1
a308 1
          *state = 0;
d312 1
a312 1
      curr_state = (*state == 0 ? ASCII : JIS);
d356 1
a356 1
              *state = 0;
d360 1
a360 1
	      *state = 0;
d364 1
a364 1
              *state = 0;
d368 1
a368 1
              *state = 1;
d382 1
a382 1
      return -1;  /* n < bytes needed */
a396 1

@


1.2
log
@	* libc/stdlib/mbtowc_r.c (_mbtowc_r): Avoid dereferencing
	NULL pointer.
@
text
@d69 187
@


1.1
log
@Initial revision
@
text
@d71 1
a71 1
      int char1 = *t;
d74 1
d91 1
a91 1
      int char1 = *t;
d94 1
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
