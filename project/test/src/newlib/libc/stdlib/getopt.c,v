head	1.10;
access;
symbols
	cygwin-1_7_35-release:1.10
	cygwin-1_7_34-release:1.10
	newlib-2_2_0:1.10.0.2
	cygwin-1_7_33-release:1.10
	cygwin-1_7_32-release:1.10
	cygwin-1_7_31-release:1.10
	cygwin-1_7_30-release:1.10
	cygwin-1_7_29-release:1.10
	cygwin-1_7_28-release:1.10
	newlib-2_1_0:1.10
	cygwin-1_7_27-release:1.10
	cygwin-1_7_26-release:1.10
	cygwin-1_7_25-release:1.7
	cygwin-1_7_24-release:1.7
	cygwin-1_7_23-release:1.7
	cygwin-1_7_22-release:1.7
	cygwin-1_7_21-release:1.7
	cygwin-1_7_20-release:1.7
	cygwin-1_7_19-release:1.7
	cygwin-64bit-postmerge:1.7
	cygwin-64bit-premerge-branch:1.7.0.2
	cygwin-64bit-premerge:1.7
	cygwin-1_7_18-release:1.7
	newlib-2_0_0:1.7
	cygwin-1_7_17-release:1.7
	cygwin-64bit-branch:1.6.0.6
	cygwin-1_7_16-release:1.6
	cygwin-1_7_15-release:1.6
	cygwin-1_7_14_2-release:1.6
	cygwin-1_7_14-release:1.6
	cygwin-1_7_12-release:1.6
	cygwin-1_7_11-release:1.6
	cygwin-1_7_10-release:1.6
	newlib-1_20_0:1.6
	cygwin-1_7_9-release:1.6
	cygwin-1_7_8-release:1.6
	newlib-1_19_0:1.6
	cygwin-1_7_7-release:1.6
	cygwin-1_7_5-release:1.6
	cygwin-1_7_4-release:1.6
	cygwin-1_7_3-release:1.6
	cygwin-1_7_2-release:1.6
	newlib-1_18_0:1.6
	cygwin-1_7_1-release:1.6
	newlib-1_17_0-arc:1.6.0.4
	binutils-arc-20080908-branch:1.6.0.2
	binutils-arc-20080908-branchpoint:1.6
	newlib-1_17_0:1.6
	newlib-1_16_0:1.3
	newlib-1_15_0:1.2
	newlib-csl-coldfire-4_1-32:1.2
	newlib-csl-sourcerygxx-4_1-32:1.2
	newlib-csl-innovasic-fido-3_4_4-33:1.2
	newlib-csl-coldfire-4_1-30:1.2
	newlib-csl-sourcerygxx-4_1-30:1.2
	newlib-csl-coldfire-4_1-28:1.2
	newlib-csl-sourcerygxx-4_1-28:1.2
	newlib-csl-arm-2006q3-27:1.2
	newlib-csl-sourcerygxx-4_1-27:1.2
	newlib-csl-arm-2006q3-26:1.2
	newlib-csl-sourcerygxx-4_1-26:1.2
	newlib-csl-sourcerygxx-4_1-24:1.2
	newlib-csl-sourcerygxx-4_1-23:1.2
	newlib-csl-sourcerygxx-4_1-21:1.2
	newlib-csl-arm-2006q3-21:1.2
	newlib-csl-arm-2006q3-19:1.2
	newlib-csl-sourcerygxx-4_1-19:1.2
	newlib-csl-sourcerygxx-4_1-18:1.2
	newlib-csl-sourcerygxx-3_4_4-25:1.2
	newlib-csl-sourcerygxx-4_1-17:1.2
	cr-0x5f1:1.2.0.6
	newlib-csl-sourcerygxx-4_1-14:1.2
	newlib-csl-sourcerygxx-4_1-13:1.2
	newlib-csl-sourcerygxx-4_1-12:1.2
	newlib-csl-sourcerygxx-4_1-9:1.2
	newlib-csl-sourcerygxx-4_1-8:1.2
	newlib-csl-sourcerygxx-4_1-7:1.2
	newlib-csl-arm-2006q1-6:1.2
	newlib-csl-sourcerygxx-4_1-6:1.2
	newlib-csl-sourcerygxx-4_1-5:1.2
	newlib-csl-sourcerygxx-4_1-4:1.2
	newlib-autotools-branch:1.2.0.4
	newlib-csl-20060320-branch:1.2.0.2
	newlib-csl-20060320-branchpoint:1.2
	newlib-1_14_0:1.1.1.1
	newlib-csl-arm-2005-q1b:1.1.1.1
	newlib-csl-arm-2005-q1a:1.1.1.1
	newlib-1_13_0:1.1.1.1
	csl-arm-2004-q3:1.1.1.1
	csl-arm-2004-q1a:1.1.1.1
	csl-arm-2004-q1:1.1.1.1
	newlib-1_12_0:1.1.1.1
	csl-arm-2003-q4:1.1.1.1
	w32api-2_2:1.1.1.1
	mingw-runtime-2_4:1.1.1.1
	newlib-1_11_0:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	newlib-1_10_0:1.1.1.1
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.10
date	2013.11.13.20.04.18;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.13.09.09.45;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2013.11.12.11.30.32;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2012.10.16.19.11.48;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.07.18.16.35;	author jjohnstn;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2008.02.29.21.11.57;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2008.02.12.17.20.09;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.29.21.26.59;	author ericb;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.04.21.21.52;	author jjohnstn;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.6.6.1
date	2012.10.26.09.27.37;	author corinna;	state Exp;
branches;
next	;

1.2.6.1
date	2007.11.14.15.57.45;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.10
log
@	* newlib/libc/stdlib/getopt.c (getopt_internal): Add missing braces.
@
text
@/****************************************************************************

getopt.c - Read command line options

AUTHOR: Gregory Pietsch
CREATED Fri Jan 10 21:13:05 1997

DESCRIPTION:

The getopt() function parses the command line arguments.  Its arguments argc
and argv are the argument count and array as passed to the main() function
on program invocation.  The argument optstring is a list of available option
characters.  If such a character is followed by a colon (`:'), the option
takes an argument, which is placed in optarg.  If such a character is
followed by two colons, the option takes an optional argument, which is
placed in optarg.  If the option does not take an argument, optarg is NULL.

The external variable optind is the index of the next array element of argv
to be processed; it communicates from one call to the next which element to
process.

The getopt_long() function works like getopt() except that it also accepts
long options started by two dashes `--'.  If these take values, it is either
in the form

--arg=value

 or

--arg value

It takes the additional arguments longopts which is a pointer to the first
element of an array of type struct option.  The last element of the array
has to be filled with NULL for the name field.

The longind pointer points to the index of the current long option relative
to longopts if it is non-NULL.

The getopt() function returns the option character if the option was found
successfully, `:' if there was a missing parameter for one of the options,
`?' for an unknown option character, and EOF for the end of the option list.

The getopt_long() function's return value is described in the header file.

The function getopt_long_only() is identical to getopt_long(), except that a
plus sign `+' can introduce long options as well as `--'.

The following describes how to deal with options that follow non-option
argv-elements.

If the caller did not specify anything, the default is REQUIRE_ORDER if the
environment variable POSIXLY_CORRECT is defined, PERMUTE otherwise.

REQUIRE_ORDER means don't recognize them as options; stop option processing
when the first non-option is seen.  This is what Unix does.  This mode of
operation is selected by either setting the environment variable
POSIXLY_CORRECT, or using `+' as the first character of the optstring
parameter.

PERMUTE is the default.  We permute the contents of ARGV as we scan, so that
eventually all the non-options are at the end.  This allows options to be
given in any order, even with programs that were not written to expect this.

RETURN_IN_ORDER is an option available to programs that were written to
expect options and other argv-elements in any order and that care about the
ordering of the two.  We describe each non-option argv-element as if it were
the argument of an option with character code 1.  Using `-' as the first
character of the optstring parameter selects this mode of operation.

The special argument `--' forces an end of option-scanning regardless of the
value of ordering.  In the case of RETURN_IN_ORDER, only `--' can cause
getopt() and friends to return EOF with optind != argc.

2012-08-26: Tried to make the error handling more sus4-like. The functions
return a colon if getopt() and friends detect a missing argument and the
first character of shortopts/optstring starts with a colon (`:'). If getopt()
and friends detect a missing argument and shortopts/optstring does not start
with a colon, the function returns a question mark (`?'). If it was a missing
argument to a short option, optopt is set to the character in question. The
colon goes after the ordering character (`+' or `-').

COPYRIGHT NOTICE AND DISCLAIMER:

Copyright (C) 1997 Gregory Pietsch

This file and the accompanying getopt.h header file are hereby placed in the 
public domain without restrictions.  Just give the author credit, don't
claim you wrote it or prevent anyone else from using it.

Gregory Pietsch's current e-mail address:
gpietsch@@comcast.net
****************************************************************************/

#ifndef HAVE_GETOPT

/* include files */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define __need_getopt_newlib
#include <getopt.h>

/* macros */

/* types */
typedef enum GETOPT_ORDERING_T
{
  PERMUTE,
  RETURN_IN_ORDER,
  REQUIRE_ORDER
} GETOPT_ORDERING_T;

/* globally-defined variables */
char *optarg = 0;
int optind = 0;
int opterr = 1;
int optopt = '?';

/* static variables */
static int optwhere = 0;

/* functions */

/* reverse_argv_elements:  reverses num elements starting at argv */
static void
reverse_argv_elements (char **argv, int num)
{
  int i;
  char *tmp;

  for (i = 0; i < (num >> 1); i++)
    {
      tmp = argv[i];
      argv[i] = argv[num - i - 1];
      argv[num - i - 1] = tmp;
    }
}

/* permute: swap two blocks of argv-elements given their lengths */
static void
permute (char *const argv[], int len1, int len2)
{
  reverse_argv_elements ((char **) argv, len1);
  reverse_argv_elements ((char **) argv, len1 + len2);
  reverse_argv_elements ((char **) argv, len2);
}

/* is_option: is this argv-element an option or the end of the option list? */
static int
is_option (char *argv_element, int only)
{
  return ((argv_element == 0)
	  || (argv_element[0] == '-') || (only && argv_element[0] == '+'));
}

/* read_globals: read the values from the globals into a getopt_data 
   structure */
static void
read_globals (struct getopt_data *data)
{
  data->optarg = optarg;
  data->optind = optind;
  data->opterr = opterr;
  data->optopt = optopt;
  data->optwhere = optwhere;
}

/* write_globals: write the values into the globals from a getopt_data
   structure */
static void
write_globals (struct getopt_data *data)
{
  optarg = data->optarg;
  optind = data->optind;
  opterr = data->opterr;
  optopt = data->optopt;
  optwhere = data->optwhere;
}

/* getopt_internal:  the function that does all the dirty work
   NOTE: to reduce the code and RAM footprint this function uses
   fputs()/fputc() to do output to stderr instead of fprintf(). */
static int
getopt_internal (int argc, char *const argv[], const char *shortopts,
		 const struct option *longopts, int *longind, int only,
		 struct getopt_data *data)
{
  GETOPT_ORDERING_T ordering = PERMUTE;
  size_t permute_from = 0;
  int num_nonopts = 0;
  int optindex = 0;
  size_t match_chars = 0;
  char *possible_arg = 0;
  int longopt_match = -1;
  int has_arg = -1;
  char *cp = 0;
  int arg_next = 0;
  int initial_colon = 0;

  /* first, deal with silly parameters and easy stuff */
  if (argc == 0 || argv == 0 || (shortopts == 0 && longopts == 0)
      || data->optind >= argc || argv[data->optind] == 0)
    return EOF;
  if (strcmp (argv[data->optind], "--") == 0)
    {
      data->optind++;
      return EOF;
    }

  /* if this is our first time through */
  if (data->optind == 0)
    data->optind = data->optwhere = 1;

  /* define ordering */
  if (shortopts != 0 && (*shortopts == '-' || *shortopts == '+'))
    {
      ordering = (*shortopts == '-') ? RETURN_IN_ORDER : REQUIRE_ORDER;
      shortopts++;
    }
  else
    ordering = (getenv ("POSIXLY_CORRECT") != 0) ? REQUIRE_ORDER : PERMUTE;

  /* check for initial colon in shortopts */
  if (shortopts != 0 && *shortopts == ':')
    {
      ++shortopts;
      initial_colon = 1;
    }

  /*
   * based on ordering, find our next option, if we're at the beginning of
   * one
   */
  if (data->optwhere == 1)
    {
      switch (ordering)
	{
	default:		/* shouldn't happen */
	case PERMUTE:
	  permute_from = data->optind;
	  num_nonopts = 0;
	  while (!is_option (argv[data->optind], only))
	    {
	      data->optind++;
	      num_nonopts++;
	    }
	  if (argv[data->optind] == 0)
	    {
	      /* no more options */
	      data->optind = permute_from;
	      return EOF;
	    }
	  else if (strcmp (argv[data->optind], "--") == 0)
	    {
	      /* no more options, but have to get `--' out of the way */
	      permute (argv + permute_from, num_nonopts, 1);
	      data->optind = permute_from + 1;
	      return EOF;
	    }
	  break;
	case RETURN_IN_ORDER:
	  if (!is_option (argv[data->optind], only))
	    {
	      data->optarg = argv[data->optind++];
	      return (data->optopt = 1);
	    }
	  break;
	case REQUIRE_ORDER:
	  if (!is_option (argv[data->optind], only))
	    return EOF;
	  break;
	}
    }
  /* End of option list? */
  if (argv[data->optind] == 0)
    return EOF;

  /* we've got an option, so parse it */

  /* first, is it a long option? */
  if (longopts != 0
      && (memcmp (argv[data->optind], "--", 2) == 0
	  || (only && argv[data->optind][0] == '+')) && data->optwhere == 1)
    {
      /* handle long options */
      if (memcmp (argv[data->optind], "--", 2) == 0)
	data->optwhere = 2;
      longopt_match = -1;
      possible_arg = strchr (argv[data->optind] + data->optwhere, '=');
      if (possible_arg == 0)
	{
	  /* no =, so next argv might be arg */
	  match_chars = strlen (argv[data->optind]);
	  possible_arg = argv[data->optind] + match_chars;
	  match_chars = match_chars - data->optwhere;
	}
      else
	match_chars = (possible_arg - argv[data->optind]) - data->optwhere;
      for (optindex = 0; longopts[optindex].name != 0; ++optindex)
	{
	  if (memcmp
	      (argv[data->optind] + data->optwhere, longopts[optindex].name,
	       match_chars) == 0)
	    {
	      /* do we have an exact match? */
	      if (match_chars == strlen (longopts[optindex].name))
		{
		  longopt_match = optindex;
		  break;
		}
	      /* do any characters match? */
	      else
		{
		  if (longopt_match < 0)
		    longopt_match = optindex;
		  else
		    {
		      /* we have ambiguous options */
		      if (data->opterr)
			{
			  fputs (argv[0], stderr);
			  fputs (": option `", stderr);
			  fputs (argv[data->optind], stderr);
			  fputs ("' is ambiguous (could be `--", stderr);
			  fputs (longopts[longopt_match].name, stderr);
			  fputs ("' or `--", stderr);
			  fputs (longopts[optindex].name, stderr);
			  fputs ("')\n", stderr);
			}
		      return (data->optopt = '?');
		    }
		}
	    }
	}
      if (longopt_match >= 0)
	has_arg = longopts[longopt_match].has_arg;
    }

  /* if we didn't find a long option, is it a short option? */
  if (longopt_match < 0 && shortopts != 0)
    {
      cp = strchr (shortopts, argv[data->optind][data->optwhere]);
      if (cp == 0)
	{
	  /* couldn't find option in shortopts */
	  if (data->opterr)
	    {
	      fputs (argv[0], stderr);
	      fputs (": invalid option -- `-", stderr);
	      fputc (argv[data->optind][data->optwhere], stderr);
	      fputs ("'\n", stderr);
	    }
	  data->optwhere++;
	  if (argv[data->optind][data->optwhere] == '\0')
	    {
	      data->optind++;
	      data->optwhere = 1;
	    }
	  return (data->optopt = '?');
	}
      has_arg = ((cp[1] == ':')
		 ? ((cp[2] == ':') ? OPTIONAL_ARG : REQUIRED_ARG) : NO_ARG);
      possible_arg = argv[data->optind] + data->optwhere + 1;
      data->optopt = *cp;
    }

  /* get argument and reset data->optwhere */
  arg_next = 0;
  switch (has_arg)
    {
    case OPTIONAL_ARG:
      if (*possible_arg == '=')
	possible_arg++;
      data->optarg = (*possible_arg != '\0') ? possible_arg : 0;
      data->optwhere = 1;
      break;
    case REQUIRED_ARG:
      if (*possible_arg == '=')
	possible_arg++;
      if (*possible_arg != '\0')
	{
	  data->optarg = possible_arg;
	  data->optwhere = 1;
	}
      else if (data->optind + 1 >= argc)
	{
	  if (data->opterr)
	    {
	      fputs (argv[0], stderr);
	      fputs (": argument required for option `-", stderr);
	      if (longopt_match >= 0)
		{
		  fputc ('-', stderr);
		  fputs (longopts[longopt_match].name, stderr);
		  data->optopt = initial_colon ? ':' : '\?';
		}
	      else
		{
		  fputc (*cp, stderr);
		  data->optopt = *cp;
		}
	      fputs ("'\n", stderr);
	    }
	  data->optind++;
	  return initial_colon ? ':' : '\?';
	}
      else
	{
	  data->optarg = argv[data->optind + 1];
	  arg_next = 1;
	  data->optwhere = 1;
	}
      break;
    default:			/* shouldn't happen */
    case NO_ARG:
      if (longopt_match < 0)
	{
	  data->optwhere++;
	  if (argv[data->optind][data->optwhere] == '\0')
	    data->optwhere = 1;
	}
      else
	data->optwhere = 1;
      data->optarg = 0;
      break;
    }

  /* do we have to permute or otherwise modify data->optind? */
  if (ordering == PERMUTE && data->optwhere == 1 && num_nonopts != 0)
    {
      permute (argv + permute_from, num_nonopts, 1 + arg_next);
      data->optind = permute_from + 1 + arg_next;
    }
  else if (data->optwhere == 1)
    data->optind = data->optind + 1 + arg_next;

  /* finally return */
  if (longopt_match >= 0)
    {
      if (longind != 0)
	*longind = longopt_match;
      if (longopts[longopt_match].flag != 0)
	{
	  *(longopts[longopt_match].flag) = longopts[longopt_match].val;
	  return 0;
	}
      else
	return longopts[longopt_match].val;
    }
  else
    return data->optopt;
}

int
getopt (int argc, char *const argv[], const char *optstring)
{
  struct getopt_data data;
  int r;

  read_globals (&data);
  r = getopt_internal (argc, argv, optstring, 0, 0, 0, &data);
  write_globals (&data);
  return r;
}

int
getopt_long (int argc, char *const argv[], const char *shortopts,
	     const struct option *longopts, int *longind)
{
  struct getopt_data data;
  int r;

  read_globals (&data);
  r = getopt_internal (argc, argv, shortopts, longopts, longind, 0, &data);
  write_globals (&data);
  return r;
}

int
getopt_long_only (int argc, char *const argv[], const char *shortopts,
		  const struct option *longopts, int *longind)
{
  struct getopt_data data;
  int r;

  read_globals (&data);
  r = getopt_internal (argc, argv, shortopts, longopts, longind, 1, &data);
  write_globals (&data);
  return r;
}

int
__getopt_r (int argc, char *const argv[], const char *optstring,
	    struct getopt_data *data)
{
  return getopt_internal (argc, argv, optstring, 0, 0, 0, data);
}

int
__getopt_long_r (int argc, char *const argv[], const char *shortopts,
		 const struct option *longopts, int *longind,
		 struct getopt_data *data)
{
  return getopt_internal (argc, argv, shortopts, longopts, longind, 0, data);
}

int
__getopt_long_only_r (int argc, char *const argv[], const char *shortopts,
		      const struct option *longopts, int *longind,
		      struct getopt_data *data)
{
  return getopt_internal (argc, argv, shortopts, longopts, longind, 1, data);
}

#endif /* !HAVE_GETOPT */

/* end of file GETOPT.C */
@


1.9
log
@	* newlib/libc/include/getopt.h (struct option): name field should be
	"const char *".
	* newlib/libc/stdlib/getopt.c (getopt_internal): Use fputs()/fputc()
	instead of fprintf() to save code space.  Fix signed/unsigned
	comparison.
@
text
@d320 10
a329 8
			fputs (argv[0], stderr);
			fputs (": option `", stderr);
			fputs (argv[data->optind], stderr);
			fputs ("' is ambiguous (could be `--", stderr);
			fputs (longopts[longopt_match].name, stderr);
			fputs ("' or `--", stderr);
			fputs (longopts[optindex].name, stderr);
			fputs ("')\n", stderr);
d347 6
a352 4
	    fputs (argv[0], stderr);
	    fputs (": invalid option -- `-", stderr);
	    fputc (argv[data->optind][data->optwhere], stderr);
	    fputs ("'\n", stderr);
@


1.8
log
@	* libc/libc/stdlib/getopt.c (getopt_internal): Fix NULL pointer access.
@
text
@d180 3
a182 1
/* getopt_internal:  the function that does all the dirty work */
d306 1
a306 1
	      if (match_chars == (int) (strlen (longopts[optindex].name)))
d320 8
a327 6
			fprintf (stderr, "%s: option `%s' is ambiguous "
				 "(could be `--%s' or `--%s')\n",
				 argv[0],
				 argv[data->optind],
				 longopts[longopt_match].name,
				 longopts[optindex].name);
d345 4
a348 3
	    fprintf (stderr,
		     "%s: invalid option -- `-%c'\n",
		     argv[0], argv[data->optind][data->optwhere]);
d385 2
a386 1
	      fprintf (stderr, "%s: argument required for option `", argv[0]);
d389 2
a390 1
		  fprintf (stderr, "--%s'\n", longopts[longopt_match].name);
d395 1
a395 1
		  fprintf (stderr, "-%c'\n", *cp);
d398 1
@


1.7
log
@	* libc/stdlib/getopt.c (getopt_internal): Align handling of colon to
	SUSv4 requirements.
	(__getopt_long_r): Fix formatting.
@
text
@d272 4
@


1.6
log
@
2008-03-07  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/getopt.h: Hide newlib extensions under
        the __need_getopt_newlib flag.
        * libc/stdlib/getopt.c: #define __need_getopt_newlib before including
        getopt.h.  Put entire code under !HAVE_GETOPT to support platforms
        with their own getopt implementation.
        * configure.host: Specify HAVE_GETOPT for x86-linux.
@
text
@d74 8
d196 1
d221 7
d378 4
a381 1
		fprintf (stderr, "--%s'\n", longopts[longopt_match].name);
d383 4
a386 1
		fprintf (stderr, "-%c'\n", *cp);
d389 1
a389 1
	  return (data->optopt = ':');
d485 2
a486 2
	         const struct option *longopts, int *longind,
	         struct getopt_data *data)
@


1.6.6.1
log
@Pull in changes from HEAD
@
text
@a73 8
2012-08-26: Tried to make the error handling more sus4-like. The functions
return a colon if getopt() and friends detect a missing argument and the
first character of shortopts/optstring starts with a colon (`:'). If getopt()
and friends detect a missing argument and shortopts/optstring does not start
with a colon, the function returns a question mark (`?'). If it was a missing
argument to a short option, optopt is set to the character in question. The
colon goes after the ordering character (`+' or `-').

a187 1
  int initial_colon = 0;
a211 7
  /* check for initial colon in shortopts */
  if (shortopts != 0 && *shortopts == ':')
    {
      ++shortopts;
      initial_colon = 1;
    }

d362 1
a362 4
		{
		  fprintf (stderr, "--%s'\n", longopts[longopt_match].name);
		  data->optopt = initial_colon ? ':' : '\?';
		}
d364 1
a364 4
		{
		  fprintf (stderr, "-%c'\n", *cp);
		  data->optopt = *cp;
		}
d367 1
a367 1
	  return initial_colon ? ':' : '\?';
d463 2
a464 2
		 const struct option *longopts, int *longind,
		 struct getopt_data *data)
@


1.5
log
@
2008-02-29  Gregory Pietsch  <gpietsch@@comcast.net>

        * libc/stdlib/getopt.c (getopt_internal): Rewrite to accept
        data area so as to support reentrant calls.  Change all callers
        to fill in data area with global values and restore any changes
        to the global values after call.
        (__getopt_r, __getopt_long_r, __getopt_long_only_r): New routines
        to support reentrancy that add a data area argument.
        * libc/include/getopt.h: Add new _r routines and provide macros
        so they can be called with using double-underscores.
@
text
@d86 1
d92 1
d477 2
@


1.4
log
@
2008-02-12  Peter Rosin  <peda@@lysator.liu.se>

        * libc/stdlib/getopt.c (getopt_internal): Handle optional
        arguments better for long options and short options not
        appearing as the first option in a sequence.
@
text
@d86 1
d104 1
a104 1
char *optarg = NULL;
d109 3
d116 1
a116 1
reverse_argv_elements (char ** argv, int num)
d133 3
a135 3
  reverse_argv_elements ((char **)argv, len1);
  reverse_argv_elements ((char **)argv, len1 + len2);
  reverse_argv_elements ((char **)argv, len2);
d142 26
a167 2
  return ((argv_element == NULL)
          || (argv_element[0] == '-') || (only && argv_element[0] == '+'));
d173 2
a174 1
                 const struct option *longopts, int *longind, int only)
a176 1
  static size_t optwhere = 0;
d181 1
a181 1
  char *possible_arg = NULL;
d184 1
a184 1
  char *cp = NULL;
d188 2
a189 1
  if (argc == 0 || argv == NULL || (shortopts == NULL && longopts == NULL))
d191 1
a191 3
  if (optind >= argc || argv[optind] == NULL)
    return EOF;
  if (strcmp (argv[optind], "--") == 0)
d193 1
a193 1
      optind++;
d196 1
d198 2
a199 2
  if (optind == 0)
    optind = optwhere = 1;
d202 1
a202 1
  if (shortopts != NULL && (*shortopts == '-' || *shortopts == '+'))
d208 1
a208 1
    ordering = (getenv ("POSIXLY_CORRECT") != NULL) ? REQUIRE_ORDER : PERMUTE;
d214 1
a214 1
  if (optwhere == 1)
d217 36
a252 35
        {
        case PERMUTE:
          permute_from = optind;
          num_nonopts = 0;
          while (!is_option (argv[optind], only))
            {
              optind++;
              num_nonopts++;
            }
          if (argv[optind] == NULL)
            {
              /* no more options */
              optind = permute_from;
              return EOF;
            }
          else if (strcmp (argv[optind], "--") == 0)
            {
              /* no more options, but have to get `--' out of the way */
              permute (argv + permute_from, num_nonopts, 1);
              optind = permute_from + 1;
              return EOF;
            }
          break;
        case RETURN_IN_ORDER:
          if (!is_option (argv[optind], only))
            {
              optarg = argv[optind++];
              return (optopt = 1);
            }
          break;
        case REQUIRE_ORDER:
          if (!is_option (argv[optind], only))
            return EOF;
          break;
        }
d257 3
a259 3
  if (longopts != NULL
      && (memcmp (argv[optind], "--", 2) == 0
          || (only && argv[optind][0] == '+')) && optwhere == 1)
d262 2
a263 2
      if (memcmp (argv[optind], "--", 2) == 0)
        optwhere = 2;
d265 8
a272 8
      possible_arg = strchr (argv[optind] + optwhere, '=');
      if (possible_arg == NULL)
        {
          /* no =, so next argv might be arg */
          match_chars = strlen (argv[optind]);
          possible_arg = argv[optind] + match_chars;
          match_chars = match_chars - optwhere;
        }
d274 33
a306 32
        match_chars = (possible_arg - argv[optind]) - optwhere;
      for (optindex = 0; longopts[optindex].name != NULL; optindex++)
        {
          if (memcmp (argv[optind] + optwhere,
                      longopts[optindex].name, match_chars) == 0)
            {
              /* do we have an exact match? */
              if (match_chars == (int) (strlen (longopts[optindex].name)))
                {
                  longopt_match = optindex;
                  break;
                }
              /* do any characters match? */
              else
                {
                  if (longopt_match < 0)
                    longopt_match = optindex;
                  else
                    {
                      /* we have ambiguous options */
                      if (opterr)
                        fprintf (stderr, "%s: option `%s' is ambiguous "
                                 "(could be `--%s' or `--%s')\n",
                                 argv[0],
                                 argv[optind],
                                 longopts[longopt_match].name,
                                 longopts[optindex].name);
                      return (optopt = '?');
                    }
                }
            }
        }
d308 1
a308 1
        has_arg = longopts[longopt_match].has_arg;
d310 1
d312 1
a312 1
  if (longopt_match < 0 && shortopts != NULL)
d314 16
a329 16
      cp = strchr (shortopts, argv[optind][optwhere]);
      if (cp == NULL)
        {
          /* couldn't find option in shortopts */
          if (opterr)
            fprintf (stderr,
                     "%s: invalid option -- `-%c'\n",
                     argv[0], argv[optind][optwhere]);
          optwhere++;
          if (argv[optind][optwhere] == '\0')
            {
              optind++;
              optwhere = 1;
            }
          return (optopt = '?');
        }
d331 3
a333 3
                 ? ((cp[2] == ':') ? OPTIONAL_ARG : REQUIRED_ARG) : NO_ARG);
      possible_arg = argv[optind] + optwhere + 1;
      optopt = *cp;
d335 2
a336 1
  /* get argument and reset optwhere */
d342 3
a344 3
        possible_arg++;
      optarg = (*possible_arg != '\0') ? possible_arg : NULL;
      optwhere = 1;
d348 1
a348 1
        possible_arg++;
d350 17
a366 17
        {
          optarg = possible_arg;
          optwhere = 1;
        }
      else if (optind + 1 >= argc)
        {
          if (opterr)
            {
              fprintf (stderr, "%s: argument required for option `", argv[0]);
              if (longopt_match >= 0)
                fprintf (stderr, "--%s'\n", longopts[longopt_match].name);
              else
                fprintf (stderr, "-%c'\n", *cp);
            }
          optind++;
          return (optopt = ':');
        }
d368 5
a372 5
        {
          optarg = argv[optind + 1];
          arg_next = 1;
          optwhere = 1;
        }
d374 1
d377 5
a381 5
        {
          optwhere++;
          if (argv[optind][optwhere] == '\0')
            optwhere = 1;
        }
d383 2
a384 2
        optwhere = 1;
      optarg = NULL;
d388 2
a389 2
  /* do we have to permute or otherwise modify optind? */
  if (ordering == PERMUTE && optwhere == 1 && num_nonopts != 0)
d392 1
a392 1
      optind = permute_from + 1 + arg_next;
d394 2
a395 2
  else if (optwhere == 1)
    optind = optind + 1 + arg_next;
d400 7
a406 7
      if (longind != NULL)
        *longind = longopt_match;
      if (longopts[longopt_match].flag != NULL)
        {
          *(longopts[longopt_match].flag) = longopts[longopt_match].val;
          return 0;
        }
d408 1
a408 1
        return longopts[longopt_match].val;
d411 1
a411 1
    return optopt;
d417 7
a423 1
  return getopt_internal (argc, argv, optstring, NULL, NULL, 0);
d428 1
a428 1
             const struct option *longopts, int *longind)
d430 7
a436 1
  return getopt_internal (argc, argv, shortopts, longopts, longind, 0);
d441 30
a470 1
                  const struct option *longopts, int *longind)
d472 1
a472 1
  return getopt_internal (argc, argv, shortopts, longopts, longind, 1);
@


1.3
log
@Avoid more compiler warnings.
* libc/stdlib/btowc.c: Add missing header.
* libc/stdlib/getopt.c (getopt_internal): Initialize variable.
* libc/stdlib/system.c (do_system) [__CYGWIN__]: Add declaration.
* libc/stdlib/wctob.c: Add missing header.
* libc/string/strcpy.c (strcpy): Avoid warnings.
* libc/string/strrchr.c (strrchr): Likewise.
@
text
@d311 2
a312 7
      if (*possible_arg != '\0')
        {
          optarg = possible_arg;
          optwhere = 1;
        }
      else
        optarg = NULL;
@


1.2
log
@
2006-01-04  Gregory Pietsch  <gpietsch@@comcast.net>

        * libc/stdlib/getopt.c: Replaced with version
        that adds getopt_long and getopt_long_only support.
        * libc/include/getopt.h: New file.
@
text
@d156 1
a156 1
  char *cp;
@


1.2.6.1
log
@2007-10-23  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/stdlib/wcstombs_r.c: Add SUSV2 support for calculating
	size if output buffer is NULL.

2007-10-13  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R) [__OPTIMIZE_SIZE__]:
	Correctly nest else within conditionals.
	Reported by Artur Lipowski.

2007-09-17  Eric Blake  <ebb9@@byu.net>

	Obey POSIX on printf("%.s", (char*)NULL).
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Take precision into account
	for %s on NULL.  Skip NULL check when optimizing for size.

2007-07-31  Eric Blake  <ebb9@@byu.net>

	More POSIX stream corner cases.
	* libc/stdio/findfp.c (__sinit): Open stderr read/write.
	* libc/stdio/fdopen.c (_fdopen_r): Set O_APPEND on fd when
	requested.
	* libc/stdio64/fdopen64.c (_fdopen64_r): Likewise.

2007-07-13  Eric Blake  <ebb9@@byu.net>

	Fix fflush issues.
	* libc/stdio/fflush.c (_fflush_r): New function.
	(fflush): Fix reentrancy and large offset behavior.
	* libc/include/stdio.h (_fflush_r): Add prototype.
	* libc/stdio/fclose.c (_fclose_r): All fflush callers changed.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/fseek.c (_fseek_r): Likewise.
	* libc/stdio/ftell.c (_ftell_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Likewise.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/setvbuf.c (setvbuf): Likewise.
	* libc/stdio/ungetc.c (_ungetc_r): Likewise.
	* libc/stdio/vfprintf.c (__sbprintf): Likewise.
	* libc/stdio/wbuf.c (__swbuf_r): Likewise.
	* libc/stdio64/freopen64.c (_freopen64_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.  Defer to
	32-bit version if not large file.
	* libc/stdio64/ftello64.c (_ftello64_r): Likewise.
	* libc/stdio64/tmpfile64.c (_tmpfile64_r): Avoid compile warning.

2007-06-04  Eric Blake  <ebb9@@byu.net>

	* libc/include/sys/reent.h (struct __sFILE, struct __sFILE64):
	Switch to reentrant callbacks.
	* libc/stdio/local.h (__sread, __swrite, __sseek, __sclose)
	(__sseek64, __swrite64): Fix prototypes.
	[__SCLE]: Pull in setmode declaration.
	* libc/stdio/stdio.c (__sread, __swrite, __sseek, __sclose): Fix
	reentrancy.
	* libc/stdio64/stdio64.c (__sseek64_r, __swrite64_r): Delete.
	(__sseek64, __swrite64): Fix reentrancy.
	* libc/stdio/fseek.c (_fseek_r): Account for overflow, and fix
	reentrancy.
	* libc/stdio/ftell.c (_ftell_r): Likewise.
	* libc/stdio/flags.c (__sflags): Don't lose __SAPP on "a+".
	* libc/stdio/fclose.c (_fclose_r): Fix reentrancy.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Likewise.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/siscanf.c (eofread): Likewise.
	* libc/stdio/sscanf.c (eofread): Likewise.
	* libc/stdio/vsiscanf.c (eofread1): Likewise.
	* libc/stdio/vsscanf.c (eofread1): Likewise.
	* libc/stdio64/freopen64.c (_freopen64_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.
	* libc/stdio64/ftello64.c (_ftello64_r): Likewise.
	* libc/stdio/fflush.c (fflush): Improve reentrancy, although more
	could be fixed.

2007-05-29  Eric Blake  <ebb9@@byu.net>

	Avoid more compiler warnings.
	* libc/stdlib/btowc.c: Add missing header.
	* libc/stdlib/getopt.c (getopt_internal): Initialize variable.
	* libc/stdlib/system.c (do_system) [__CYGWIN__]: Add declaration.
	* libc/stdlib/wctob.c: Add missing header.
	* libc/string/strcpy.c (strcpy): Avoid warnings.
	* libc/string/strrchr.c (strrchr): Likewise.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/argz/argz_add_sep.c (argz_add_sep): Handle empty string
	argument.
	* libc/argz/argz_append.c (argz_append): Handle empty buf argument.
	* libc/argz/argz_create_sep.c (argz_create_sep): Return (NULL, 0)
	on empty input strings.
	* libc/argz/argz_extract.c (argz_extract): Check argz_len before
	looping through argz.
	* libc/argz/argz_stringify.c (argz_stringify): Ditto.

2007-05-27  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Populate 'ox' when
	handling %p.

2007-05-25  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/rewind.c (rewind): Fix regression of 2003-08-22.

2007-05-23  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't truncate %p when
	sizeof(void*) is 8 but sizeof(long) is 4.
	* libc/stdio/vfscanf.c (__SVFSCANF_R): Likewise.  Fix %i scanning
	of "-0x".  Support "-nan" and "inf" for %e.  Audit usage of ungetc
	to fix reentrancy and bug on encoding error in multibyte locales.
	Always return EOF on read error.

2007-05-23  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfscanf.c (__SVFSCANF_R): Support scanf(%1$s).
	Avoid warning when !FLOATING_POINT.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Simplify _NO_POS_ARGS
	slightly.

2007-05-23  Corinna Vinschen  <vinschen@@redhat.com>

	* libc/argz/argz_create_sep.c (argz_create_sep): Initialize *argz_len
	to zero.
	* libc/include/argz.h: Guard against multiple inclusion.  Guard for
	use with C++.

2007-05-17  Charles Wilson  <cygwin@@...>

	* stdio/tmpfile.c: Include <sys/stat.h>.
	* stdio64/tmpfile64.c: Ditto.

2007-05-16  Eric Blake  <ebb9@@byu.net>

	Close security hole in tmpfile.
	* libc/stdio/tmpfile.c (_tmpfile_r): Avoid window between filename
	generation and opening the fd.
	* libc/stdio64/tmpfile64.c (_tmpfile64_r): Likewise.

	* libc/include/math.h (INFINITY, NAN, FP_ILOGB0, FP_ILOGBNAN)
	(MATH_ERRNO, MATH_ERREXCEPT, math_errhandling): Add macros
	required by POSIX.
	* libc/stdlib/ldtoa.c (USE_INFINITY): Rename from INFINITY, to
	avoid clash with <math.h>.

	* libc/stdlib/wctomb_r.c (_wctomb_r): Avoid gcc warnings on cygwin.
	* libc/search/hash.c (__hash_open): Likewise.

2007-05-10  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Fix use of decimal point
	in %f and %e.  Avoid malloc when possible for %S.
	(BUF): Improve stack locality by using smaller size.
	(MAXEXP): Define.
	(exponent): Use for smaller stack size.

2007-05-01  Eric Blake  <ebb9@@byu.net>

	* libc/stdio64/local64.h: Delete, move contents to...
	* libc/stdio/local.h: ...here.
	* libc/stdio64/fdopen64.c: Update includes.
	* libc/stdio64/fopen64.c: Likewise.
	* libc/stdio64/freopen64.c: Likewise.
	* libc/stdio64/fseeko64.c: Likewise.
	* libc/stdio64/ftello64.c: Likewise.
	* libc/stdio/findfp.c (std) [__LARGE64_FILES]: Open stdin, stdout,
	and stderr with 64-bit offset.
	* libc/stdio/fseek.c (_fseek_r): Avoid compile warning.
	* libc/stdio/makebuf.c (__smakebuf_r): Likewise.
	* libc/stdio/mktemp.c (_gettemp): Likewise.

2007-04-25  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (get_arg): Support %1$lc.  Simplify types
	that promote to int.

2007-04-24  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't zero pad on infinity
	or NaN with %05f.

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Avoid multibyte when not
	_MB_CAPABLE.

	* libc/include/limits.h (NL_ARGMAX): Define a default value.
	* libc/stdio/vfprintf.c (MAX_POS_ARGS): Define in terms of
	NL_ARGMAX, if present.

2007-04-23  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/vfprintf.c (_vfprintf_r): When the alternate-form flag
	has been specified with types 'f', 'F', 'g', or 'G', ensure the
	trailing decimal is printed.

2007-04-17  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/sscanf.c: Update documentation comments.
	* libc/stdio/vfscanf.c (__SVFSCANF_R): Handle j, t, and z modifiers.

2007-04-12  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_F, cvt): Don't confuse %F with %e.
	(chclass): Recognize 'F', 'X', 'n', and not 'W'.
	(get_arg): Handle %1$F, %1$n.

2007-04-10  Eric Blake  <ebb9@@byu.net>

	* libc/include/stdio.h (_ELIDABLE_INLINE): Work even when using
	CFLAGS=-O0.

2007-04-09  Eric Blake  <ebb9@@byu.net>

	* libc/include/stdio.h: Add gcc format attributes to printf and
	scanf families.

2007-04-04  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/argz/argz_insert.c: Add stddef.h to get ptrdiff_t type.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/asiprintf.c (_asiprintf_r): Fix reentrancy.
	(asiprintf): Avoid overhead.
	* libc/stdio/asprintf.c (_asprintf_r): Fix reentrancy.
	(asprintf): Avoid overhead.
	* libc/stdio/diprintf.c (_diprintf_r, diprintf): New file.
	* libc/stdio/dprintf.c (_dprintf_r, dprintf): Use _DEFUN.
	* libc/stdio/fiprintf.c (_fiprintf_r): Add reentrant version.
	(fiprintf): Avoid overhead.
	* libc/stdio/fprintf.c (_fprintf_r): Add reentrant version.
	(fprintf): Avoid overhead.
	* libc/stdio/iprintf.c (_iprintf_r): Use _DEFUN.
	(iprintf): Avoid overhead.
	* libc/stdio/printf.c (_printf_r): Use _DEFUN.
	(printf): Avoid overhead.
	* libc/stdio/vasiprintf.c (vasiprintf): Reduce binary size.
	* libc/stdio/vasprintf.c (vasprintf): Reduce binary size.
	* libc/stdio/vdiprintf.c (_vdiprintf_r, vdiprintf): New file.
	* libc/stdio/vdprintf.c (vdprintf): Avoid overhead.
	* libc/stdio/vsiprintf.c (vsiprintf): Reduce binary size.
	* libc/stdio/vsniprintf.c (vsniprintf): Reduce binary size.
	* libc/stdio/vsnprintf.c (vsnprintf): Reduce binary size.
	* libc/stdio/vsprintf.c (vsprintf): Reduce binary size.
	* libc/stdio/Makefile.am (GENERAL_SOURCES): Add diprintf.c,
	vdiprintf.c.
	* libc/include/stdio.h (diprintf, _diprintf_r, vdiprintf)
	(_vdiprintf_r, _fiprintf_r, _vfiprintf_r): Add prototypes.

2007-03-30  Dave Korn  <dave.korn@@artimi.com>

	* libc/include/stdio.h (_ELIDABLE_INLINE):  New macro to conceal
	conflicting inline semantics between C99 and GNU89.
	(__sgetc_r):  Replace static inline with _ELIDABLE_INLINE to be
	compatible with -fkeep-inline-functions usage.
	(__sputc_r):  Likewise for consistency even though disabled.

2007-03-16  Charles Wilson  <cygwin@@...>

	* libc/argz/argz_insert.c: "before" pointer is
	invalid after *argz realloc.  Compute offset
	between "before" and *argz, and use it after
	reallocation instead.

2007-03-16  Eric Blake  <ebb9@@byu.net>

	* libc/stdio64/fseek064.c (_fseeko64_r): Fix reentrancy.
	* libc/stdio64/freopen64.c (_freopen64_r): Ditto.

2007-03-15  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/local.h (cantwrite, FREEUB, FREELB): Make reentrant.
	(__smakebuf): Rename...
	(__smakebuf_r): to this.
	* libc/stdio/fvwrite.h (__swsetup_r): Rename, from __swsetup.
	* libc/stdio/makebuf.c (__smakebuf): Detect failed asprint
	allocation, then rename...
	(__smakebuf_r): ...to this and fix reentrancy.
	* libc/stdio/wsetup.c (__swsetup): Detect failed asprintf
	allocation, then rename...
	(__swsetup_r): ...to this and fix reentrancy.
	* libc/stdio/fseek.c (_fseek_r): Fix reentrancy.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/fclose.c (_fclose_r): Likewise.
	* libc/stdio/fread.c (_fread_r): Likewise.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/wbuf.c (__swbuf_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Set errno properly on
	failed asprintf allocation, and fix reentrancy.
	* libc/stdio/snprintf.c (snprintf, _snprintf_r): Report overflow,
	as required by POSIX.
	* libc/stdio/sniprintf.c (sniprintf, _sniprintf_r): Likewise.
	* libc/stdio/vsnprintf.c (vsnprintf, _vsnprintf_r): Likewise.
	* libc/stdio/vsniprintf.c (vsniprintf, _vsniprintf_r): Likewise.

2007-03-12  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/fvwrite.c (__sfvwrite_r): Fix reentrancy.
	* libc/stdio/vasprintf.c (vasprintf, _vasprintf_r): Pass failed
	allocation to caller.
	* libc/stdio/asprintf.c (_asprintf_r, asprintf): Likewise.
	* libc/stdio/asiprintf.c (_asiprintf_r, asiprintf): Likewise.
	* libc/stdio/vasiprintf.c (vasiprintf, _vasiprintf_r): Likewise.

2007-02-20  Kazunori Asayama <asayama@@sm.sony.co.jp>

	* libc/include/stdio.h: Add declaration for vsiprintf.
@
text
@d156 1
a156 1
  char *cp = NULL;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 37
/*
 * Copyright (c) 1987, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
/* static char sccsid[] = "from: @@(#)getopt.c	8.2 (Berkeley) 4/2/94"; */
static char *rcsid = "$Id: getopt.c,v 1.2 1998/01/21 22:27:05 billm Exp $";
#endif /* LIBC_SCCS and not lint */
d3 84
d90 301
a391 14
int	opterr = 1,		/* if error message should be printed */
	optind = 1,		/* index into parent argv vector */
	optopt,			/* character checked for validity */
	optreset;		/* reset getopt */
char	*optarg;		/* argument associated with option */

#define	BADCH	(int)'?'
#define	BADARG	(int)':'
#define	EMSG	""

/*
 * getopt --
 *	Parse argc/argv argument vector.
 */
d393 4
a396 59
getopt(nargc, nargv, ostr)
	int nargc;
	char * const *nargv;
	const char *ostr;
{
	static char *place = EMSG;		/* option letter processing */
	char *oli;				/* option letter list index */

	if (optreset || !*place) {		/* update scanning pointer */
		optreset = 0;
		if (optind >= nargc || *(place = nargv[optind]) != '-') {
			place = EMSG;
			return (-1);
		}
		if (place[1] && *++place == '-') {	/* found "--" */
			++optind;
			place = EMSG;
			return (-1);
		}
	}					/* option letter okay? */
	if ((optopt = (int)*place++) == (int)':' ||
	    !(oli = strchr(ostr, optopt))) {
		/*
		 * if the user didn't specify '-' as an option,
		 * assume it means -1.
		 */
		if (optopt == (int)'-')
			return (-1);
		if (!*place)
			++optind;
		if (opterr && *ostr != ':')
			(void)fprintf(stderr,
			    "%s: illegal option -- %c\n", nargv[0], optopt);
		return (BADCH);
	}
	if (*++oli != ':') {			/* don't need argument */
		optarg = NULL;
		if (!*place)
			++optind;
	}
	else {					/* need an argument */
		if (*place)			/* no white space */
			optarg = place;
		else if (nargc <= ++optind) {	/* no arg */
			place = EMSG;
			if (*ostr == ':')
				return (BADARG);
			if (opterr)
				(void)fprintf(stderr,
				    "%s: option requires an argument -- %c\n",
				    nargv[0], optopt);
			return (BADCH);
		}
	 	else				/* white space */
			optarg = nargv[optind];
		place = EMSG;
		++optind;
	}
	return (optopt);			/* dump back option letter */
d398 9
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
