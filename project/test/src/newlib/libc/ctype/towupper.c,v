head	1.8;
access;
symbols
	cygwin-1_7_35-release:1.8
	cygwin-1_7_34-release:1.8
	newlib-2_2_0:1.8.0.6
	cygwin-1_7_33-release:1.8
	cygwin-1_7_32-release:1.8
	cygwin-1_7_31-release:1.8
	cygwin-1_7_30-release:1.8
	cygwin-1_7_29-release:1.8
	cygwin-1_7_28-release:1.8
	newlib-2_1_0:1.8
	cygwin-1_7_27-release:1.8
	cygwin-1_7_26-release:1.8
	cygwin-1_7_25-release:1.8
	cygwin-1_7_24-release:1.8
	cygwin-1_7_23-release:1.8
	cygwin-1_7_22-release:1.8
	cygwin-1_7_21-release:1.8
	cygwin-1_7_20-release:1.8
	cygwin-1_7_19-release:1.8
	cygwin-64bit-postmerge:1.8
	cygwin-64bit-premerge-branch:1.8.0.4
	cygwin-64bit-premerge:1.8
	cygwin-1_7_18-release:1.8
	newlib-2_0_0:1.8
	cygwin-1_7_17-release:1.8
	cygwin-64bit-branch:1.8.0.2
	cygwin-1_7_16-release:1.8
	cygwin-1_7_15-release:1.8
	cygwin-1_7_14_2-release:1.8
	cygwin-1_7_14-release:1.8
	cygwin-1_7_12-release:1.8
	cygwin-1_7_11-release:1.8
	cygwin-1_7_10-release:1.8
	newlib-1_20_0:1.8
	cygwin-1_7_9-release:1.8
	cygwin-1_7_8-release:1.8
	newlib-1_19_0:1.8
	cygwin-1_7_7-release:1.8
	cygwin-1_7_5-release:1.8
	cygwin-1_7_4-release:1.8
	cygwin-1_7_3-release:1.8
	cygwin-1_7_2-release:1.8
	newlib-1_18_0:1.7
	cygwin-1_7_1-release:1.7
	newlib-1_17_0-arc:1.4.0.10
	binutils-arc-20080908-branch:1.4.0.8
	binutils-arc-20080908-branchpoint:1.4
	newlib-1_17_0:1.4
	newlib-1_16_0:1.4
	newlib-1_15_0:1.4
	newlib-csl-coldfire-4_1-32:1.4
	newlib-csl-sourcerygxx-4_1-32:1.4
	newlib-csl-innovasic-fido-3_4_4-33:1.4
	newlib-csl-coldfire-4_1-30:1.4
	newlib-csl-sourcerygxx-4_1-30:1.4
	newlib-csl-coldfire-4_1-28:1.4
	newlib-csl-sourcerygxx-4_1-28:1.4
	newlib-csl-arm-2006q3-27:1.4
	newlib-csl-sourcerygxx-4_1-27:1.4
	newlib-csl-arm-2006q3-26:1.4
	newlib-csl-sourcerygxx-4_1-26:1.4
	newlib-csl-sourcerygxx-4_1-24:1.4
	newlib-csl-sourcerygxx-4_1-23:1.4
	newlib-csl-sourcerygxx-4_1-21:1.4
	newlib-csl-arm-2006q3-21:1.4
	newlib-csl-arm-2006q3-19:1.4
	newlib-csl-sourcerygxx-4_1-19:1.4
	newlib-csl-sourcerygxx-4_1-18:1.4
	newlib-csl-sourcerygxx-3_4_4-25:1.4
	newlib-csl-sourcerygxx-4_1-17:1.4
	cr-0x5f1:1.4.0.6
	newlib-csl-sourcerygxx-4_1-14:1.4
	newlib-csl-sourcerygxx-4_1-13:1.4
	newlib-csl-sourcerygxx-4_1-12:1.4
	newlib-csl-sourcerygxx-4_1-9:1.4
	newlib-csl-sourcerygxx-4_1-8:1.4
	newlib-csl-sourcerygxx-4_1-7:1.4
	newlib-csl-arm-2006q1-6:1.4
	newlib-csl-sourcerygxx-4_1-6:1.4
	newlib-csl-sourcerygxx-4_1-5:1.4
	newlib-csl-sourcerygxx-4_1-4:1.4
	newlib-autotools-branch:1.4.0.4
	newlib-csl-20060320-branch:1.4.0.2
	newlib-csl-20060320-branchpoint:1.4
	newlib-1_14_0:1.4
	newlib-csl-arm-2005-q1b:1.3
	newlib-csl-arm-2005-q1a:1.3
	newlib-1_13_0:1.3
	csl-arm-2004-q3:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.2
	newlib-1_12_0:1.2
	csl-arm-2003-q4:1.2
	w32api-2_2:1.1
	mingw-runtime-2_4:1.1
	newlib-1_11_0:1.1;
locks; strict;
comment	@ * @;


1.8
date	2010.02.18.20.37.19;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.14.20.16.21;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.24.10.13.27;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.03.09.28.45;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.28.21.33.22;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.23.21.44.21;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.31.22.24.20;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.20.20.13.10;	author jjohnstn;	state Exp;
branches;
next	;


desc
@@


1.8
log
@	* libc/ctype/iswalpha.c (iswalpha): Update to Unicode 5.2.
	* libc/ctype/iswprint.c (iswprint): Ditto.
	* libc/ctype/iswpunct.c (iswpunct): Drop standalone implementation.
	Define in terms of other wctype functions instead.
	* libc/ctype/towlower.c (towlower): Update to Unicode 5.2.  Add comment
	to explain how to fetch the data from the Unicode database.
	* libc/ctype/towupper.c (towupper): Ditto.
	* libc/ctype/utf8alpha.h: Ditto.
	* libc/ctype/utf8print.h: Ditto.
	* libc/ctype/utf8punct.h: Remove.
	* libc/ctype/iswcntrl.c (iswcntrl): Add comment to explain how to
	fetch the data from the Unicode database.
@
text
@/* Copyright (c) 2002 Red Hat Incorporated.
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

     Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

     Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

     The name of Red Hat Incorporated may not be used to endorse
     or promote products derived from this software without specific
     prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED.  IN NO EVENT SHALL RED HAT INCORPORATED BE LIABLE FOR ANY
   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS   
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
FUNCTION
	<<towupper>>---translate wide characters to uppercase

INDEX
	towupper

ANSI_SYNOPSIS
	#include <wctype.h>
	wint_t towupper(wint_t <[c]>);

TRAD_SYNOPSIS
	#include <wctype.h>
	wint_t towupper(<[c]>)
	wint_t <[c]>;


DESCRIPTION
<<towupper>> is a function which converts lowercase wide characters to
uppercase, leaving all other characters unchanged.

RETURNS
<<towupper>> returns the uppercase equivalent of <[c]> when it is a
lowercase wide character, otherwise, it returns the input character.

PORTABILITY
<<towupper>> is C99.

No supporting OS subroutines are required.
*/

#include <_ansi.h>
#include <newlib.h>
#include <string.h>
#include <reent.h>
#include <ctype.h>
#include <wctype.h>
#include "local.h"

wint_t
_DEFUN(towupper,(c), wint_t c)
{
#ifdef _MB_CAPABLE
  c = _jp2uc (c);
  /* Based on and tested against Unicode 5.2 */

  /* Expression used to filter out the characters for the below code:

     awk -F\; '{ if ( $13 != "" ) print $1; }' UnicodeData.txt
  */
  if (c < 0x100)
    {
      if (c == 0x00b5)
	return 0x039c;
      
      if ((c >= 0x00e0 && c <= 0x00fe && c != 0x00f7) ||
	  (c >= 0x0061 && c <= 0x007a))
	return (c - 0x20);
      
      if (c == 0xff)
	return 0x0178;
      
      return c;
    }
  else if (c < 0x300)
    {
      if ((c >= 0x0101 && c <= 0x012f) ||
	  (c >= 0x0133 && c <= 0x0137) ||
	  (c >= 0x014b && c <= 0x0177) ||
	  (c >= 0x01df && c <= 0x01ef) ||
	  (c >= 0x01f9 && c <= 0x021f) ||
	  (c >= 0x0223 && c <= 0x0233) ||
	  (c >= 0x0247 && c <= 0x024f))
	{
	  if (c & 0x01)
	    return (c - 1);
	  return c;
	}

      if ((c >= 0x013a && c <= 0x0148) ||
	  (c >= 0x01ce && c <= 0x01dc) ||
	  c == 0x023c || c == 0x0242)
	{
	  if (!(c & 0x01))
	    return (c - 1);
	  return c;
	}
      
      if (c == 0x0131)
	return 0x0049;
      
      if (c == 0x017a || c == 0x017c || c == 0x017e)
	return (c - 1);
      
      if (c >= 0x017f && c <= 0x0292)
	{
	  wint_t k;
	  switch (c)
	    {
	    case 0x017f:
	      k = 0x0053;
	      break;
	    case 0x0180:
	      k = 0x0243;
	      break;
	    case 0x0183:
	      k = 0x0182;
	      break;
	    case 0x0185:
	      k = 0x0184;
	      break;
	    case 0x0188:
	      k = 0x0187;
	      break;
	    case 0x018c:
	      k = 0x018b;
	      break;
	    case 0x0192:
	      k = 0x0191;
	      break;
	    case 0x0195:
	      k = 0x01f6;
	      break;
	    case 0x0199:
	      k = 0x0198;
	      break;
	    case 0x019a:
	      k = 0x023d;
	      break;
	    case 0x019e:
	      k = 0x0220;
	      break;
	    case 0x01a1:
	    case 0x01a3:
	    case 0x01a5:
	    case 0x01a8:
	    case 0x01ad:
	    case 0x01b0:
	    case 0x01b4:
	    case 0x01b6:
	    case 0x01b9:
	    case 0x01bd:
	    case 0x01c5:
	    case 0x01c8:
	    case 0x01cb:
	    case 0x01f2:
	    case 0x01f5:
	      k = c - 1;
	      break;
	    case 0x01bf:
	      k = 0x01f7;
	      break;
	    case 0x01c6:
	    case 0x01c9:
	    case 0x01cc:
	      k = c - 2;
	      break;
	    case 0x01dd:
	      k = 0x018e;
	      break;
	    case 0x01f3:
	      k = 0x01f1;
	      break;
	    case 0x023f:
	      k = 0x2c7e;
	      break;
	    case 0x0240:
	      k = 0x2c7f;
	      break;
	    case 0x0250:
	      k = 0x2c6f;
	      break;
	    case 0x0251:
	      k = 0x2c6d;
	      break;
	    case 0x0252:
	      k = 0x2c70;
	      break;
	    case 0x0253:
	      k = 0x0181;
	      break;
	    case 0x0254:
	      k = 0x0186;
	      break;
	    case 0x0256:
	      k = 0x0189;
	      break;
	    case 0x0257:
	      k = 0x018a;
	      break;
	    case 0x0259:
	      k = 0x018f;
	      break;
	    case 0x025b:
	      k = 0x0190;
	      break;
	    case 0x0260:
	      k = 0x0193;
	      break;
	    case 0x0263:
	      k = 0x0194;
	      break;
	    case 0x0268:
	      k = 0x0197;
	      break;
	    case 0x0269:
	      k = 0x0196;
	      break;
	    case 0x026b:
	      k = 0x2c62;
	      break;
	    case 0x026f:
	      k = 0x019c;
	      break;
	    case 0x0271:
	      k = 0x2c6e;
	      break;
	    case 0x0272:
	      k = 0x019d;
	      break;
	    case 0x0275:
	      k = 0x019f;
	      break;
	    case 0x027d:
	      k = 0x2c64;
	      break;
	    case 0x0280:
	      k = 0x01a6;
	      break;
	    case 0x0283:
	      k = 0x01a9;
	      break;
	    case 0x0288:
	      k = 0x01ae;
	      break;
	    case 0x0289:
	      k = 0x0244;
	      break;
	    case 0x028a:
	      k = 0x01b1;
	      break;
	    case 0x028b:
	      k = 0x01b2;
	      break;
	    case 0x028c:
	      k = 0x0245;
	      break;
	    case 0x0292:
	      k = 0x01b7;
	      break;
	    default:
	      k = 0;
	    }
	  if (k != 0)
	    return k;
	}
    }
  else if (c < 0x0400)
    {
      wint_t k;

      if (c >= 0x03ad && c <= 0x03af)
      	return (c - 0x25);

      if (c >= 0x03b1 && c <= 0x03cb && c != 0x03c2)
	return (c - 0x20);
      
      if (c >= 0x03d9 && c <= 0x03ef && (c & 1))
	return (c - 1);

      switch (c)
	{
	case 0x0345:
	  k = 0x0399;
	  break;
	case 0x0371:
	case 0x0373:
	case 0x0377:
	case 0x03f8:
	case 0x03fb:
	  k = c - 1;
	  break;
	case 0x037b:
	case 0x037c:
	case 0x037d:
	  k = c + 0x82;
	  break;
	case 0x03ac:
	  k = 0x0386;
	  break;
	case 0x03c2:
	  k = 0x03a3;
	  break;
	case 0x03cc:
	  k = 0x038c;
	  break;
	case 0x03cd:
	case 0x03ce:
	  k = c - 0x3f;
	  break;
	case 0x03d0:
	  k = 0x0392;
	  break;
	case 0x03d1:
	  k = 0x0398;
	  break;
	case 0x03d5:
	  k = 0x03a6;
	  break;
	case 0x03d6:
	  k = 0x03a0;
	  break;
	case 0x03d7:
	  k = 0x03cf;
	  break;
	case 0x03f0:
	  k = 0x039a;
	  break;
	case 0x03f1:
	  k = 0x03a1;
	  break;
	case 0x03f2:
	  k = 0x03f9;
	  break;
	case 0x03f5:
	  k = 0x0395;
	  break;
	default:
	  k = 0;
	}
      if (k != 0)
	return k;
    }
  else if (c < 0x500)
    {
      if (c >= 0x0430 && c <= 0x044f)
	return (c - 0x20);
      
      if (c >= 0x0450 && c <= 0x045f)
	return (c - 0x50);
      
      if ((c >= 0x0461 && c <= 0x0481) ||
	  (c >= 0x048b && c <= 0x04bf) ||
	  (c >= 0x04d1 && c <= 0x04ff))
	{
	  if (c & 0x01)
	    return (c - 1);
	  return c;
	}
      
      if (c >= 0x04c2 && c <= 0x04ce)
	{
	  if (!(c & 0x01))
	    return (c - 1);
	  return c;
	}
      
      if (c == 0x04cf)
      	return 0x04c0;

      if (c >= 0x04f7 && c <= 0x04f9)
	return (c - 1);
    }
  else if (c < 0x0600)
    {
      if (c >= 0x0501 && c <= 0x0525 && (c & 1))
      	return c - 1;

      if (c >= 0x0561 && c <= 0x0586)
	return (c - 0x30);
    }
  else if (c < 0x1f00)
    {
      if (c == 0x1d79)
      	return 0xa77d;

      if (c == 0x1d7d)
      	return 0x2c63;

      if ((c >= 0x1e01 && c <= 0x1e95) ||
	  (c >= 0x1ea1 && c <= 0x1eff))
	{
	  if (c & 0x01)
	    return (c - 1);
	  return c;
	}
      
      if (c == 0x1e9b)
	return 0x1e60;
    }
  else if (c < 0x2000)
    {
      
      if ((c >= 0x1f00 && c <= 0x1f07) ||
	  (c >= 0x1f10 && c <= 0x1f15) ||
	  (c >= 0x1f20 && c <= 0x1f27) ||
	  (c >= 0x1f30 && c <= 0x1f37) ||
	  (c >= 0x1f40 && c <= 0x1f45) ||
	  (c >= 0x1f60 && c <= 0x1f67) ||
	  (c >= 0x1f80 && c <= 0x1f87) ||
	  (c >= 0x1f90 && c <= 0x1f97) ||
	  (c >= 0x1fa0 && c <= 0x1fa7))
	return (c + 0x08);

      if (c >= 0x1f51 && c <= 0x1f57 && (c & 0x01))
	return (c + 0x08);
      
      if (c >= 0x1f70 && c <= 0x1ff3)
	{
	  wint_t k;
	  switch (c)
	    {
	    case 0x1fb0:
	      k = 0x1fb8;
	      break;
	    case 0x1fb1:
	      k = 0x1fb9;
	      break;
	    case 0x1f70:
	      k = 0x1fba;
	      break;
	    case 0x1f71:
	      k = 0x1fbb;
	      break;
	    case 0x1fb3:
	      k = 0x1fbc;
	      break;
	    case 0x1fbe:
	      k = 0x0399;
	      break;
	    case 0x1f72:
	      k = 0x1fc8;
	      break;
	    case 0x1f73:
	      k = 0x1fc9;
	      break;
	    case 0x1f74:
	      k = 0x1fca;
	      break;
	    case 0x1f75:
	      k = 0x1fcb;
	      break;
	    case 0x1fc3:
	      k = 0x1fcc;
	      break;
	    case 0x1fd0:
	      k = 0x1fd8;
	      break;
	    case 0x1fd1:
	      k = 0x1fd9;
	      break;
	    case 0x1f76:
	      k = 0x1fda;
	      break;
	    case 0x1f77:
	      k = 0x1fdb;
	      break;
	    case 0x1fe0:
	      k = 0x1fe8;
	      break;
	    case 0x1fe1:
	      k = 0x1fe9;
	      break;
	    case 0x1f7a:
	      k = 0x1fea;
	      break;
	    case 0x1f7b:
	      k = 0x1feb;
	      break;
	    case 0x1fe5:
	      k = 0x1fec;
	      break;
	    case 0x1f78:
	      k = 0x1ff8;
	      break;
	    case 0x1f79:
	      k = 0x1ff9;
	      break;
	    case 0x1f7c:
	      k = 0x1ffa;
	      break;
	    case 0x1f7d:
	      k = 0x1ffb;
	      break;
	    case 0x1ff3:
	      k = 0x1ffc;
	      break;
	    default:
	      k = 0;
	    }
	  if (k != 0)
	    return k;
	}
    }
  else if (c < 0x3000)
    {
      if (c == 0x214e)
      	return 0x2132;

      if (c == 0x2184)
      	return 0x2183;

      if (c >= 0x2170 && c <= 0x217f)
	return (c - 0x10);
      
      if (c >= 0x24d0 && c <= 0x24e9)
	return (c - 0x1a);
      
      if (c >= 0x2c30 && c <= 0x2c5e)
	return (c - 0x30);

      if ((c >= 0x2c68 && c <= 0x2c6c && !(c & 1)) ||
	  (c >= 0x2c81 && c <= 0x2ce3 &&  (c & 1)) ||
	  c == 0x2c73 || c == 0x2c76 ||
	  c == 0x2cec || c == 0x2cee)
      	return (c - 1);

      if (c >= 0x2c81 && c <= 0x2ce3 && (c & 1))
	return (c - 1);

      if (c >= 0x2d00 && c <= 0x2d25)
      	return (c - 0x1c60);

      switch (c)
      	{
	case 0x2c61:
	  return 0x2c60;
	case 0x2c65:
	  return 0x023a;
	case 0x2c66:
	  return 0x023e;
	}
    }
  else if (c >= 0xa000 && c < 0xb000)
    {
      if (((c >= 0xa641 && c <= 0xa65f) ||
           (c >= 0xa663 && c <= 0xa66d) ||
           (c >= 0xa681 && c <= 0xa697) ||
           (c >= 0xa723 && c <= 0xa72f) ||
           (c >= 0xa733 && c <= 0xa76f) ||
           (c >= 0xa77f && c <= 0xa787)) &&
	  (c & 1))
	return (c - 1);
      	
      if (c == 0xa77a || c == 0xa77c || c == 0xa78c)
	return (c - 1);
    }
  else
    {
      if (c >= 0xff41 && c <= 0xff5a)
	return (c - 0x20);
      
      if (c >= 0x10428 && c <= 0x1044f)
	return (c - 0x28);
    }
  return c;
#else
  return (c < 0x00ff ? (wint_t)(toupper ((int)c)) : c);
#endif /* _MB_CAPABLE */
}

@


1.7
log
@	* libc/ctype/local.h (JP_JIS, JP_SJIS, JP_EUCJP): Move definition
	to jp2uc.c.
	(__jp2uc): Remove declaration.
	(_jp2uc): Declare.
	* libc/ctype/jp2uc.c (JP_JIS, JP_SJIS, JP_EUCJP): Define.
	(__jp2uc): Remove Cygwin special case.
	(_jp2uc): New function.  On Cygwin, just return c.
	* libc/ctype/iswalpha.c (iswalpha): Just call _jp2uc.
	* libc/ctype/iswblank.c (iswblank): Ditto.
	* libc/ctype/iswcntrl.c (iswcntrl): Ditto.
	* libc/ctype/iswprint.c (iswprint): Ditto.
	* libc/ctype/iswpunct.c (iswpunt): Ditto.
	* libc/ctype/iswspace.c (iswspace): Ditto.
	* libc/ctype/towlower.c (towlower): Ditto.
	* libc/ctype/towupper.c (towupper): Ditto.
@
text
@d74 6
d85 1
a85 1
      if ((c >= 0x00e0 && c <= 0x00fe) ||
d101 2
a102 1
	  (c >= 0x0223 && c <= 0x0233))
d110 2
a111 1
	  (c >= 0x01ce && c <= 0x1dc))
d132 3
d156 3
d193 15
d238 3
d244 3
d253 3
d265 3
d274 3
d289 5
a293 6
      if (c == 0x03ac)
	return 0x0386;
      
      if ((c & 0xfff0) == 0x03a0 && c >= 0x03ad)
	return (c - 0x15);
      
d297 4
a300 4
      if (c == 0x03c2)
	return 0x03a3;
      
      if (c >= 0x03cc && c <= 0x03f5)
d302 57
a358 53
	  wint_t k;
	  switch (c)
	    {
	    case 0x03cc:
	      k = 0x038c;
	      break;
	    case 0x03cd:
	    case 0x03ce:
	      k = c - 0x3f;
	      break;
	    case 0x03d0:
	      k = 0x0392;
	      break;
	    case 0x03d1:
	      k = 0x0398;
	      break;
	    case 0x03d5:
	      k = 0x03a6;
	      break;
	    case 0x03d6:
	      k = 0x03a0;
	      break;
	    case 0x03d9:
	    case 0x03db:
	    case 0x03dd:
	    case 0x03df:
	    case 0x03e1:
	    case 0x03e3:
	    case 0x03e5:
	    case 0x03e7:
	    case 0x03e9:
	    case 0x03eb:
	    case 0x03ed:
	    case 0x03ef:
	      k = c - 1;
	      break;
	    case 0x03f0:
	      k = 0x039a;
	      break;
	    case 0x03f1:
	      k = 0x03a1;
	      break;
	    case 0x03f2:
	      k = 0x03a3;
	      break;
	    case 0x03f5:
	      k = 0x0395;
	      break;
	    default:
	      k = 0;
	    }
	  if (k != 0)
	    return k;
d360 2
d365 3
a370 3
      if (c >= 0x0430 && c <= 0x044f)
	return (c - 0x20);
      
d373 1
a373 1
	  (c >= 0x04d1 && c <= 0x04f5))
d387 13
a399 2
      if (c == 0x04f9)
	return 0x04f8;
d403 8
a410 3
      if ((c >= 0x0501 && c <= 0x050f) ||
	  (c >= 0x1e01 && c <= 0x1e95) ||
	  (c >= 0x1ea1 && c <= 0x1ef9))
a416 3
      if (c >= 0x0561 && c <= 0x0586)
	return (c - 0x30);

d472 3
d524 1
a524 1
  else 
d526 6
d538 41
d582 1
a582 1
      if (c >= 0x10428 && c <= 0x1044d)
@


1.6
log
@	* libc/ctype/iswalpha.c: Handle all wchar_t as unicode on
	_MB_CAPABLE systems.
	* libc/ctype/iswblank.c: Ditto.
	* libc/ctype/iswcntrl.c: Ditto.
	* libc/ctype/iswprint.c: Ditto.
	* libc/ctype/iswpunct.c: Ditto.
	* libc/ctype/iswspace.c: Ditto.
	* libc/ctype/jp2uc.c (__jp2uc): On Cygwin, just return c.
	Explain why.
	* libc/ctype/towlower.c: Ditto.
	* libc/ctype/towupper.c: Ditto.
	* libc/include/sys/config.h: Define _MB_EXTENDED_CHARSETS_ISO
	and _MB_EXTENDED_CHARSETS_WINDOWS if _MB_EXTENDED_CHARSETS_ALL is
	defined.  Define _MB_EXTENDED_CHARSETS_ALL on Cygwin only for now.
	* libc/include/sys/reent.h (struct _reent): Mark _current_category
	and _current_locale as unused.
	* libc/locale/locale.c: Add new charset support to documentation.
	Include ../stdio/local.h from here.
	(lc_ctype_charset): Set to "ASCII" by default.
	(lc_message_charset): Ditto.
	(_setlocale_r): Don't set _current_category and _current_locale.
	(loadlocale): Add Cygwin codepage support.  On _MB_CAPABLE
	systems, set __mbtowc and __wctomb function pointers to function
	corresponding with current charset.  Don't allow non-existant
	ISO-8859-12 charset.  Add support for Windows singlebyte codepages.
	On Cygwin, add support for GBK, CP949, and BIG5.  On Cygwin,
	call __set_ctype() in case the catorgy is LC_CTYPE.  Don't set
	_current_category and _current_locale.
	* libc/stdlib/Makefile.am (GENERAL_SOURCES): Add sb_charsets.c.
	* libc/stdlib/Makefile.in: Regenerate.
	* libc/stdlib/local.h: Add prototype for __locale_charset.
	Add prototypes for __mbtowc and __wctomb pointers.
	Add prototypes for charset-specific _wctomb_r and _mbtowc_r
	functions.
	Declare tables and functions from sb_charsets.c.
	* libc/stdlib/mbtowc_r.c (__mbtowc): Define.  Set to __ascii_mbtowc
	by default.
	(_mbtowc_r): Just call __mbtowc from here.
	(__ascii_mbtowc): New function.
	(__iso_mbtowc): New function.
	(__cp_mbtowc): New function.
	(__utf8_mbtowc): New function.
	(__sjis_mbtowc): New function.  Disable on Cygwin.
	(__eucjp_mbtowc): New function.  Disable on Cygwin.
	(__jis_mbtowc): New function.  Disable on Cygwin.
	* libc/stdlib/sb_charsets.c: New file, adding singlebyte to UTF
	conversion tables for all ISO and CP charsets.
	(__iso_8859_index): New function.
	(__cp_index): New function.
	* libc/stdlib/wctomb_r.c (__wctomb): Define.  Set to __ascii_wctomb
	by default.
	(_wctomb_r): Just call __wctomb from here.
	(__ascii_wctomb): New function.
	(__utf8_wctomb): New function.
	(__sjis_wctomb): New function.  Disable on Cygwin.
	(__eucjp_wctomb): New function.  Disable on Cygwin.
	(__jis_wctomb): New function.  Disable on Cygwin.
	(__iso_wctomb): New function.
	(__cp_wctomb): New function.
@
text
@d73 1
a73 7
  if (!strcmp (__locale_charset (), "JIS"))
    c = __jp2uc (c, JP_JIS);
  else if (!strcmp (__locale_charset (), "SJIS"))
    c = __jp2uc (c, JP_SJIS);
  else if (!strcmp (__locale_charset (), "EUCJP"))
    c = __jp2uc (c, JP_EUCJP);

@


1.5
log
@	* libc/locale/locale.c (_setlocale_r): New implementation based on
	FreeBSD's setlocale.
	(currentlocale): New helper function.
	(loadlocale): Ditto.
	(__locale_charset): New function.
	(__locale_msgcharset): Rename from __locale_charset.
	* libc/ctype/local.h (__lc_ctype): Remove declaration.
	(__locale_charset): Declare.
	* libc/ctype/iswalpha.c (iswalpha): Call __locale_charset instead of
	using __lc_ctype directly.  Only compare against the charset alone.
	* libc/ctype/iswblank.c (iswblank): Ditto.
	* libc/ctype/iswcntrl.c (iswcntrl): Ditto.
	* libc/ctype/iswprint.c (iswprint): Ditto.
	* libc/ctype/iswpunct.c (iswpunct): Ditto.
	* libc/ctype/iswspace.c (iswspace): Ditto.
	* libc/ctype/towlower.c (towlower): Ditto.
	* libc/ctype/towupper.c (towupper): Ditto.
	* libc/stdlib/mbtowc_r.c (_mbtowc_r): Ditto.
	* libc/stdlib/wctomb_r.c (_wctomb_r): Ditto.
	* libc/sys/linux/intl/loadmsgcat.c (_nl_init_domain_conv): Call
	__locale_msgcharset instead of __locale_charset.
@
text
@a72 2
  int unicode = 0;

d74 1
a74 4
    {
      c = __jp2uc (c, JP_JIS);
      unicode = 1;
    }
d76 1
a76 4
    {
      c = __jp2uc (c, JP_SJIS);
      unicode = 1;
    }
d78 3
d82 11
a92 2
      c = __jp2uc (c, JP_EUCJP);
      unicode = 1;
d94 1
a94 1
  else if (!strcmp (__locale_charset (), "UTF-8"))
d96 11
a106 2
      unicode = 1;
    }
d108 2
a109 3
  if (unicode)
    {
      if (c < 0x100)
d111 2
a112 10
	  if (c == 0x00b5)
	    return 0x039c;
	  
	  if ((c >= 0x00e0 && c <= 0x00fe) ||
	      (c >= 0x0061 && c <= 0x007a))
	    return (c - 0x20);
	  
	  if (c == 0xff)
	    return 0x0178;
	  
d115 8
a122 1
      else if (c < 0x300)
d124 2
a125 6
	  if ((c >= 0x0101 && c <= 0x012f) ||
	      (c >= 0x0133 && c <= 0x0137) ||
	      (c >= 0x014b && c <= 0x0177) ||
	      (c >= 0x01df && c <= 0x01ef) ||
	      (c >= 0x01f9 && c <= 0x021f) ||
	      (c >= 0x0223 && c <= 0x0233))
d127 117
a243 3
	      if (c & 0x01)
		return (c - 1);
	      return c;
d245 22
a266 3

	  if ((c >= 0x013a && c <= 0x0148) ||
	      (c >= 0x01ce && c <= 0x1dc))
d268 47
a314 3
	      if (!(c & 0x01))
		return (c - 1);
	      return c;
d316 17
a332 5
	  
	  if (c == 0x0131)
	    return 0x0049;
	  
	  if (c == 0x017a || c == 0x017c || c == 0x017e)
d334 1
a334 127
	  
	  if (c >= 0x017f && c <= 0x0292)
	    {
	      wint_t k;
	      switch (c)
		{
		case 0x017f:
		  k = 0x0053;
		  break;
		case 0x0183:
		  k = 0x0182;
		  break;
		case 0x0185:
		  k = 0x0184;
		  break;
		case 0x0188:
		  k = 0x0187;
		  break;
		case 0x018c:
		  k = 0x018b;
		  break;
		case 0x0192:
		  k = 0x0191;
		  break;
		case 0x0195:
		  k = 0x01f6;
		  break;
		case 0x0199:
		  k = 0x0198;
		  break;
		case 0x019e:
		  k = 0x0220;
		  break;
		case 0x01a1:
		case 0x01a3:
		case 0x01a5:
		case 0x01a8:
		case 0x01ad:
		case 0x01b0:
		case 0x01b4:
		case 0x01b6:
		case 0x01b9:
		case 0x01bd:
		case 0x01c5:
		case 0x01c8:
		case 0x01cb:
		case 0x01f2:
		case 0x01f5:
		  k = c - 1;
		  break;
		case 0x01bf:
		  k = 0x01f7;
		  break;
		case 0x01c6:
		case 0x01c9:
		case 0x01cc:
		  k = c - 2;
		  break;
		case 0x01dd:
		  k = 0x018e;
		  break;
		case 0x01f3:
		  k = 0x01f1;
		  break;
		case 0x0253:
		  k = 0x0181;
		  break;
		case 0x0254:
		  k = 0x0186;
		  break;
		case 0x0256:
		  k = 0x0189;
		  break;
		case 0x0257:
		  k = 0x018a;
		  break;
		case 0x0259:
		  k = 0x018f;
		  break;
		case 0x025b:
		  k = 0x0190;
		  break;
		case 0x0260:
		  k = 0x0193;
		  break;
		case 0x0263:
		  k = 0x0194;
		  break;
		case 0x0268:
		  k = 0x0197;
		  break;
		case 0x0269:
		  k = 0x0196;
		  break;
		case 0x026f:
		  k = 0x019c;
		  break;
		case 0x0272:
		  k = 0x019d;
		  break;
		case 0x0275:
		  k = 0x019f;
		  break;
		case 0x0280:
		  k = 0x01a6;
		  break;
		case 0x0283:
		  k = 0x01a9;
		  break;
		case 0x0288:
		  k = 0x01ae;
		  break;
		case 0x028a:
		  k = 0x01b1;
		  break;
		case 0x028b:
		  k = 0x01b2;
		  break;
		case 0x0292:
		  k = 0x01b7;
		  break;
		default:
		  k = 0;
		}
	      if (k != 0)
		return k;
	    }
d336 2
a337 1
      else if (c < 0x0400)
d339 3
a341 68
	  if (c == 0x03ac)
	    return 0x0386;
	  
	  if ((c & 0xfff0) == 0x03a0 && c >= 0x03ad)
	    return (c - 0x15);
	  
	  if (c >= 0x03b1 && c <= 0x03cb && c != 0x03c2)
	    return (c - 0x20);
	  
	  if (c == 0x03c2)
	    return 0x03a3;
	  
	  if (c >= 0x03cc && c <= 0x03f5)
	    {
	      wint_t k;
	      switch (c)
		{
		case 0x03cc:
		  k = 0x038c;
		  break;
		case 0x03cd:
		case 0x03ce:
		  k = c - 0x3f;
		  break;
		case 0x03d0:
		  k = 0x0392;
		  break;
		case 0x03d1:
		  k = 0x0398;
		  break;
		case 0x03d5:
		  k = 0x03a6;
		  break;
		case 0x03d6:
		  k = 0x03a0;
		  break;
		case 0x03d9:
		case 0x03db:
		case 0x03dd:
		case 0x03df:
		case 0x03e1:
		case 0x03e3:
		case 0x03e5:
		case 0x03e7:
		case 0x03e9:
		case 0x03eb:
		case 0x03ed:
		case 0x03ef:
		  k = c - 1;
		  break;
		case 0x03f0:
		  k = 0x039a;
		  break;
		case 0x03f1:
		  k = 0x03a1;
		  break;
		case 0x03f2:
		  k = 0x03a3;
		  break;
		case 0x03f5:
		  k = 0x0395;
		  break;
		default:
		  k = 0;
		}
	      if (k != 0)
		return k;
	    }
d343 9
a351 1
      else if (c < 0x500)
d353 3
a355 24
	  if (c >= 0x0450 && c <= 0x045f)
	    return (c - 0x50);
	  
	  if (c >= 0x0430 && c <= 0x044f)
	    return (c - 0x20);
	  
	  if ((c >= 0x0461 && c <= 0x0481) ||
	      (c >= 0x048b && c <= 0x04bf) ||
	      (c >= 0x04d1 && c <= 0x04f5))
	    {
	      if (c & 0x01)
		return (c - 1);
	      return c;
	    }
	  
	  if (c >= 0x04c2 && c <= 0x04ce)
	    {
	      if (!(c & 0x01))
		return (c - 1);
	      return c;
	    }
	  
	  if (c == 0x04f9)
	    return 0x04f8;
d357 20
a376 13
      else if (c < 0x1f00)
	{
	  if ((c >= 0x0501 && c <= 0x050f) ||
	      (c >= 0x1e01 && c <= 0x1e95) ||
	      (c >= 0x1ea1 && c <= 0x1ef9))
	    {
	      if (c & 0x01)
		return (c - 1);
	      return c;
	    }
	  
	  if (c >= 0x0561 && c <= 0x0586)
	    return (c - 0x30);
d378 4
a381 4
	  if (c == 0x1e9b)
	    return 0x1e60;
	}
      else if (c < 0x2000)
d383 2
a384 16
	  
	  if ((c >= 0x1f00 && c <= 0x1f07) ||
	      (c >= 0x1f10 && c <= 0x1f15) ||
	      (c >= 0x1f20 && c <= 0x1f27) ||
	      (c >= 0x1f30 && c <= 0x1f37) ||
	      (c >= 0x1f40 && c <= 0x1f45) ||
	      (c >= 0x1f60 && c <= 0x1f67) ||
	      (c >= 0x1f80 && c <= 0x1f87) ||
	      (c >= 0x1f90 && c <= 0x1f97) ||
	      (c >= 0x1fa0 && c <= 0x1fa7))
	    return (c + 0x08);
 
	  if (c >= 0x1f51 && c <= 0x1f57 && (c & 0x01))
	    return (c + 0x08);
	  
	  if (c >= 0x1f70 && c <= 0x1ff3)
d386 74
a459 80
	      wint_t k;
	      switch (c)
		{
		case 0x1fb0:
		  k = 0x1fb8;
		  break;
		case 0x1fb1:
		  k = 0x1fb9;
		  break;
		case 0x1f70:
		  k = 0x1fba;
		  break;
		case 0x1f71:
		  k = 0x1fbb;
		  break;
		case 0x1fb3:
		  k = 0x1fbc;
		  break;
		case 0x1fbe:
		  k = 0x0399;
		  break;
		case 0x1f72:
		  k = 0x1fc8;
		  break;
		case 0x1f73:
		  k = 0x1fc9;
		  break;
		case 0x1f74:
		  k = 0x1fca;
		  break;
		case 0x1f75:
		  k = 0x1fcb;
		  break;
		case 0x1fd0:
		  k = 0x1fd8;
		  break;
		case 0x1fd1:
		  k = 0x1fd9;
		  break;
		case 0x1f76:
		  k = 0x1fda;
		  break;
		case 0x1f77:
		  k = 0x1fdb;
		  break;
		case 0x1fe0:
		  k = 0x1fe8;
		  break;
		case 0x1fe1:
		  k = 0x1fe9;
		  break;
		case 0x1f7a:
		  k = 0x1fea;
		  break;
		case 0x1f7b:
		  k = 0x1feb;
		  break;
		case 0x1fe5:
		  k = 0x1fec;
		  break;
		case 0x1f78:
		  k = 0x1ff8;
		  break;
		case 0x1f79:
		  k = 0x1ff9;
		  break;
		case 0x1f7c:
		  k = 0x1ffa;
		  break;
		case 0x1f7d:
		  k = 0x1ffb;
		  break;
		case 0x1ff3:
		  k = 0x1ffc;
		  break;
		default:
		  k = 0;
		}
	      if (k != 0)
		return k;
d461 2
d464 18
a481 15
      else 
	{
	  if (c >= 0x2170 && c <= 0x217f)
	    return (c - 0x10);
	  
	  if (c >= 0x24d0 && c <= 0x24e9)
	    return (c - 0x1a);
	  
	  if (c >= 0xff41 && c <= 0xff5a)
	    return (c - 0x20);
	  
	  if (c >= 0x10428 && c <= 0x1044d)
	    return (c - 0x28);
	}
    }     
a482 2
  
  return (c < 0x00ff ? (wint_t)(toupper ((int)c)) : c);
@


1.4
log
@
2005-10-28  Bob Wilson  <bob.wilson@@acm.org>

        * libc/ctype/ctype.tex: Use hyphens as appropriate, but not  otherwise.
        * libc/ctype/islower.c: Likewise.
        * libc/ctype/isupper.c: Likewise.
        * libc/ctype/iswalnum.c: Likewise.
        * libc/ctype/iswalpha.c: Likewise.
        * libc/ctype/iswblank.c: Likewise.
        * libc/ctype/iswcntrl.c: Likewise.
        * libc/ctype/iswdigit.c: Likewise.
        * libc/ctype/iswgraph.c: Likewise.
        * libc/ctype/iswlower.c: Likewise.
        * libc/ctype/iswprint.c: Likewise.
        * libc/ctype/iswpunct.c: Likewise.
        * libc/ctype/iswspace.c: Likewise.
        * libc/ctype/iswupper.c: Likewise.
        * libc/ctype/iswxdigit.c: Likewise.
        * libc/ctype/tolower.c: Likewise.
        * libc/ctype/toupper.c: Likewise.
        * libc/ctype/towctrans.c: Likewise.
        * libc/ctype/towlower.c: Likewise.
        * libc/ctype/towupper.c: Likewise.
        * libc/string/strcasecmp.c: Likewise.
        * libc/string/strcoll.c: Likewise.
        * libc/string/strings.tex: Likewise.
        * libc/string/strlwr.c: Likewise.
        * libc/string/strncasecmp.c: Likewise.
        * libc/string/strupr.c: Likewise.
        * libc/string/wcscoll.c: Likewise.
        * libc/string/wcslcat.c: Likewise.
        * libc/string/wcslcpy.c: Likewise.
        * libc/string/wcsnlen.c: Likewise.
        * libc/string/wcsstr.c: Likewise.
        * libc/string/wcstrings.tex: Likewise.
        * libc/string/wmemchr.c: Likewise.
        * libc/string/wmemcmp.c: Likewise.
        * libc/string/wmemcpy.c: Likewise.
        * libc/string/wmemmove.c: Likewise.
        * libc/string/wmemset.c: Likewise.
@
text
@d72 1
d75 1
a75 7
  if (__lc_ctype[0] == 'C' && __lc_ctype[1] == '\0')
    {
      unicode = 0;
      /* fall-through */ 
    }
#ifdef _MB_CAPABLE
  else if (!strcmp (__lc_ctype, "C-JIS"))
d80 1
a80 1
  else if (!strcmp (__lc_ctype, "C-SJIS"))
d85 1
a85 1
  else if (!strcmp (__lc_ctype, "C-EUCJP"))
d90 1
a90 1
  else if (!strcmp (__lc_ctype, "C-UTF-8"))
@


1.3
log
@
2004-04-23  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * configure.in: Define _MB_CAPABLE if mb supported.
        * configure: Regenerated.
        * configure.host: Remove manual setting of MB_CAPABLE compiler
        flag.
        * newlib.hin: Add _MB_CAPABLE flag.
        * libc/ctype/iswalpha.c, libc/ctype/iswblank.c: Include <newlib.h>
        and check for _MB_CAPABLE flag instead of MB_CAPABLE.
        * libc/ctype/iswcntrl.c, libc/ctype/iswprint.c: Ditto.
        * libc/ctype/iswpunct.c, libc/ctype/iswspace.c: Ditto.
        * libc/ctype/jp2uc.c: Ditto.
        * libc/ctype/towlower.c, libc/ctype/towupper.c: Ditto.
        * libc/locale/locale.c: Ditto
        * libc/machine/powerpc/vfscanf.c: Ditto
        * libc/stdio/vfprintf.c, libc/stdio/vfscanf.c: Ditto
        * libc/stdlib/mblen.c: Ditto
        * libc/stdlib/mblen_r.c, libc/stdlib/mbrlen.c: Ditto
        * libc/stdlib/mbrtowc.c, libc/stdlib/mbsrtowcs.c: Ditto
        * libc/stdlib/mbstowcs.c, libc/stdlib/mbtowc.c: Ditto
        * libc/stdlib/mbtowc_r.c, libc/stdlib/wcrtomb.c: Ditto
        * libc/stdlib/wcsrtombs.c, libc/stdlib/wcstombs.c: Ditto
        * libc/stdlib/wctomb.c, libc/sys/linux/intl/dcigettext.c: Ditto
        * libc/sys/linux/intl/explodename.c: Ditto
        * libc/sys/linux/intl/finddomain.c: Ditto
        * libc/sys/linux/intl/l10nflist.c: Ditto
        * libc/sys/linux/intl/loadmsgcat.c: Ditto
        * libc/sys/linux/intl/localealias.c: Ditto
@
text
@d32 1
a32 1
	<<towupper>>---translate wide-characters to upper case
d48 2
a49 2
<<towupper>> is a function which converts lower-case wide-characters to upper
case, leaving all other characters unchanged.
d52 2
a53 2
<<towupper>> returns the upper-case equivalent of <[c]> when it is a
lower-case wide-character, otherwise, it returns the input character.
@


1.2
log
@
2003-07-31  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/ctype/iswalpha.c: Fix calls to __jp2uc to pass the
        correct type of conversion when dealing with EUCJP or SJIS.
        * libc/ctype/iswblank.c: Ditto.
        * libc/ctype/iswcntrl.c: Ditto.
        * libc/ctype/iswprint.c: Ditto.
        * libc/ctype/iswpunct.c: Ditto.
        * libc/ctype/iswspace.c: Ditto.
        * libc/ctype/towlower.c: Ditto.
        * libc/ctype/towupper.c: Ditto.
@
text
@d62 1
d79 1
a79 1
#ifdef MB_CAPABLE
d502 1
a502 1
#endif /* MB_CAPABLE */
@


1.1
log
@
2002-09-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/ctype/Makefile.am: Add new files.
        * libc/ctype/Makefile.in: Regenerated.
        * libc/ctype/ctype.tex: Add new iswxxxx, towxxxx, wctype,
        and wctrans functions to documentation index.
        * libc/ctype/iswalnum.c: New file.
        * libc/ctype/iswalpha.c: Ditto.
        * libc/ctype/iswblank.c: Ditto.
        * libc/ctype/iswcntrl.c: Ditto.
        * libc/ctype/iswctype.c: Ditto.
        * libc/ctype/iswdigit.c: Ditto.
        * libc/ctype/iswgraph.c: Ditto.
        * libc/ctype/iswlower.c: Ditto.
        * libc/ctype/iswprint.c: Ditto.
        * libc/ctype/iswpunct.c: Ditto.
        * libc/ctype/iswspace.c: Ditto.
        * libc/ctype/iswupper.c: Ditto.
        * libc/ctype/iswxdigit.c: Ditto.
        * libc/ctype/jp2uc.c: Ditto.
        * libc/ctype/jp2uc.h: Ditto.
        * libc/ctype/local.h: Ditto.
        * libc/ctype/towctrans.c: Ditto.
        * libc/ctype/towlower.c: Ditto.
        * libc/ctype/towupper.c: Ditto.
        * libc/ctype/utf8alpha.h: Ditto.
        * libc/ctype/utf8print.h: Ditto.
        * libc/ctype/utf8punct.h: Ditto.
        * libc/ctype/wctrans.c: Ditto.
        * libc/ctype/wctype.c: Ditto.
        * libc/locale/locale.c (__lc_ctype): New external array to
        replace static lc_ctype array.
        * libc/stdlib/mbtowc_r.c: Use __lc_ctype to check current lc_ctype
        rather than reentrancy structure's _current_locale field.
        * libc/stdlib/wctomb_r.c: Ditto.
@
text
@d86 1
a86 1
      c = __jp2uc (c, JP_JIS);
d91 1
a91 1
      c = __jp2uc (c, JP_JIS);
@

