head	1.5;
access;
symbols
	cygwin-1_7_35-release:1.5
	cygwin-1_7_34-release:1.5
	newlib-2_2_0:1.5.0.4
	cygwin-1_7_33-release:1.5
	cygwin-1_7_32-release:1.5
	cygwin-1_7_31-release:1.5
	cygwin-1_7_30-release:1.5
	cygwin-1_7_29-release:1.5
	cygwin-1_7_28-release:1.5
	newlib-2_1_0:1.5
	cygwin-1_7_27-release:1.5
	cygwin-1_7_26-release:1.5
	cygwin-1_7_25-release:1.5
	cygwin-1_7_24-release:1.5
	cygwin-1_7_23-release:1.5
	cygwin-1_7_22-release:1.5
	cygwin-1_7_21-release:1.5
	cygwin-1_7_20-release:1.5
	cygwin-1_7_19-release:1.5
	cygwin-64bit-postmerge:1.5
	cygwin-64bit-premerge-branch:1.5.0.2
	cygwin-64bit-premerge:1.5
	cygwin-1_7_18-release:1.5
	newlib-2_0_0:1.5
	cygwin-1_7_17-release:1.4
	cygwin-64bit-branch:1.4.0.12
	cygwin-1_7_16-release:1.4
	cygwin-1_7_15-release:1.4
	cygwin-1_7_14_2-release:1.4
	cygwin-1_7_14-release:1.4
	cygwin-1_7_12-release:1.4
	cygwin-1_7_11-release:1.4
	cygwin-1_7_10-release:1.4
	newlib-1_20_0:1.4
	cygwin-1_7_9-release:1.4
	cygwin-1_7_8-release:1.4
	newlib-1_19_0:1.4
	cygwin-1_7_7-release:1.4
	cygwin-1_7_5-release:1.4
	cygwin-1_7_4-release:1.4
	cygwin-1_7_3-release:1.4
	cygwin-1_7_2-release:1.4
	newlib-1_18_0:1.4
	cygwin-1_7_1-release:1.4
	newlib-1_17_0-arc:1.4.0.10
	binutils-arc-20080908-branch:1.4.0.8
	binutils-arc-20080908-branchpoint:1.4
	newlib-1_17_0:1.4
	newlib-1_16_0:1.4
	newlib-1_15_0:1.4
	newlib-csl-coldfire-4_1-32:1.4
	newlib-csl-sourcerygxx-4_1-32:1.4
	newlib-csl-innovasic-fido-3_4_4-33:1.4
	newlib-csl-coldfire-4_1-30:1.4
	newlib-csl-sourcerygxx-4_1-30:1.4
	newlib-csl-coldfire-4_1-28:1.4
	newlib-csl-sourcerygxx-4_1-28:1.4
	newlib-csl-arm-2006q3-27:1.4
	newlib-csl-sourcerygxx-4_1-27:1.4
	newlib-csl-arm-2006q3-26:1.4
	newlib-csl-sourcerygxx-4_1-26:1.4
	newlib-csl-sourcerygxx-4_1-24:1.4
	newlib-csl-sourcerygxx-4_1-23:1.4
	newlib-csl-sourcerygxx-4_1-21:1.4
	newlib-csl-arm-2006q3-21:1.4
	newlib-csl-arm-2006q3-19:1.4
	newlib-csl-sourcerygxx-4_1-19:1.4
	newlib-csl-sourcerygxx-4_1-18:1.4
	newlib-csl-sourcerygxx-3_4_4-25:1.4
	newlib-csl-sourcerygxx-4_1-17:1.4
	cr-0x5f1:1.4.0.6
	newlib-csl-sourcerygxx-4_1-14:1.4
	newlib-csl-sourcerygxx-4_1-13:1.4
	newlib-csl-sourcerygxx-4_1-12:1.4
	newlib-csl-sourcerygxx-4_1-9:1.4
	newlib-csl-sourcerygxx-4_1-8:1.4
	newlib-csl-sourcerygxx-4_1-7:1.4
	newlib-csl-arm-2006q1-6:1.4
	newlib-csl-sourcerygxx-4_1-6:1.4
	newlib-csl-sourcerygxx-4_1-5:1.4
	newlib-csl-sourcerygxx-4_1-4:1.4
	newlib-autotools-branch:1.4.0.4
	newlib-csl-20060320-branch:1.4.0.2
	newlib-csl-20060320-branchpoint:1.4
	newlib-1_14_0:1.4
	newlib-csl-arm-2005-q1b:1.4
	newlib-csl-arm-2005-q1a:1.4
	newlib-1_13_0:1.4
	csl-arm-2004-q3:1.4
	csl-arm-2004-q1a:1.4
	csl-arm-2004-q1:1.3
	newlib-1_12_0:1.3
	csl-arm-2003-q4:1.3
	w32api-2_2:1.1
	mingw-runtime-2_4:1.1
	newlib-1_11_0:1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.11.29.16.28.30;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.23.20.01.55;	author jjohnstn;	state Exp;
branches
	1.4.12.1;
next	1.3;

1.3
date	2003.08.22.18.52.25;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.14.18.39.05;	author corinna;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.04.19.33.54;	author jjohnstn;	state Exp;
branches;
next	;

1.4.12.1
date	2012.11.29.17.05.43;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.5
log
@	* libc/include/sys/reent.h (__sFILE): Change type of _offset
	from int to _off_t.
	* libc/stdio/ftell.c: Use _ftello_r().
	* libc/stdio/ftello.c: Copy implementation from previous
	_ftell_r().
	* libc/stdio/fseek.c: Use _fseeko_r().
	* libc/stdio/fseeko.c: Copy implementation from previous
	_fseek_r().
@
text
@/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
FUNCTION
<<ftell>>, <<ftello>>---return position in a stream or file

INDEX
	ftell
INDEX
	ftello
INDEX
	_ftell_r
INDEX
	_ftello_r

ANSI_SYNOPSIS
	#include <stdio.h>
	long ftell(FILE *<[fp]>);
	off_t ftello(FILE *<[fp]>);
	long _ftell_r(struct _reent *<[ptr]>, FILE *<[fp]>);
	off_t _ftello_r(struct _reent *<[ptr]>, FILE *<[fp]>);

TRAD_SYNOPSIS
	#include <stdio.h>
	long ftell(<[fp]>)
	FILE *<[fp]>;

	off_t ftello(<[fp]>)
	FILE *<[fp]>;

	long _ftell_r(<[ptr]>, <[fp]>)
	struct _reent *<[ptr]>;
	FILE *<[fp]>;

	off_t _ftello_r(<[ptr]>, <[fp]>)
	struct _reent *<[ptr]>;
	FILE *<[fp]>;

DESCRIPTION
Objects of type <<FILE>> can have a ``position'' that records how much
of the file your program has already read.  Many of the <<stdio>> functions
depend on this position, and many change it as a side effect.

The result of <<ftell>>/<<ftello>> is the current position for a file
identified by <[fp]>.  If you record this result, you can later
use it with <<fseek>>/<<fseeko>> to return the file to this
position.  The difference between <<ftell>> and <<ftello>> is that
<<ftell>> returns <<long>> and <<ftello>> returns <<off_t>>.

In the current implementation, <<ftell>>/<<ftello>> simply uses a character
count to represent the file position; this is the same number that
would be recorded by <<fgetpos>>.

RETURNS
<<ftell>>/<<ftello>> return the file position, if possible.  If they cannot do
this, they return <<-1L>>.  Failure occurs on streams that do not support
positioning; the global <<errno>> indicates this condition with the
value <<ESPIPE>>.

PORTABILITY
<<ftell>> is required by the ANSI C standard, but the meaning of its
result (when successful) is not specified beyond requiring that it be
acceptable as an argument to <<fseek>>.  In particular, other
conforming C implementations may return a different result from
<<ftell>> than what <<fgetpos>> records.

<<ftello>> is defined by the Single Unix specification.

No supporting OS subroutines are required.
*/

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "%W% (Berkeley) %G%";
#endif /* LIBC_SCCS and not lint */

/*
 * ftello: return current offset.
 */

#include <_ansi.h>
#include <reent.h>
#include <stdio.h>
#include <errno.h>
#include "local.h"

_off_t
_DEFUN(_ftello_r, (ptr, fp),
       struct _reent * ptr _AND
       register FILE * fp)
{
  _fpos_t pos;

  /* Ensure stdio is set up.  */

  CHECK_INIT (ptr, fp);

  _newlib_flockfile_start (fp);

  if (fp->_seek == NULL)
    {
      ptr->_errno = ESPIPE;
      _newlib_flockfile_exit (fp);
      return -1L;
    }

  /* Find offset of underlying I/O object, then adjust for buffered
     bytes.  Flush a write stream, since the offset may be altered if
     the stream is appending.  Do not flush a read stream, since we
     must not lose the ungetc buffer.  */
  if (fp->_flags & __SWR)
    _fflush_r (ptr, fp);
  if (fp->_flags & __SOFF)
    pos = fp->_offset;
  else
    {
      pos = fp->_seek (ptr, fp->_cookie, (_fpos_t) 0, SEEK_CUR);
      if (pos == -1L)
        {
          _newlib_flockfile_exit (fp);
          return pos;
        }
    }
  if (fp->_flags & __SRD)
    {
      /*
       * Reading.  Any unread characters (including
       * those from ungetc) cause the position to be
       * smaller than that in the underlying object.
       */
      pos -= fp->_r;
      if (HASUB (fp))
	pos -= fp->_ur;
    }
  else if ((fp->_flags & __SWR) && fp->_p != NULL)
    {
      /*
       * Writing.  Any buffered characters cause the
       * position to be greater than that in the
       * underlying object.
       */
      pos += fp->_p - fp->_bf._base;
    }

  _newlib_flockfile_end (fp);
  return pos;
}

#ifndef _REENT_ONLY

_off_t
_DEFUN(ftello, (fp),
       register FILE * fp)
{
  return _ftello_r (_REENT, fp);
}

#endif /* !_REENT_ONLY */
@


1.4
log
@
2004-04-23  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * libc/stdio/asprintf.c libc/stdio/clearerr.c,
        libc/stdio/fclose.c libc/stdio/fcloseall.c libc/stdio/fdopen.c,
        libc/stdio/feof.c libc/stdio/ferror.c libc/stdio/fflush.c,
        libc/stdio/fgetc.c libc/stdio/fgetpos.c libc/stdio/fgets.c,
        libc/stdio/fileno.c libc/stdio/findfp.c libc/stdio/fiprintf.c,
        libc/stdio/flags.c libc/stdio/fopen.c libc/stdio/fprintf.c,
        libc/stdio/fputc.c libc/stdio/fputs.c libc/stdio/fread.c,
        libc/stdio/freopen.c libc/stdio/fscanf.c libc/stdio/fseek.c,
        libc/stdio/fseeko.c libc/stdio/fsetpos.c libc/stdio/ftell.c,
        libc/stdio/ftello.c libc/stdio/fvwrite.c libc/stdio/fwalk.c,
        libc/stdio/fwrite.c libc/stdio/getc.c libc/stdio/getc_u.c,
        libc/stdio/getchar.c libc/stdio/getchar_u.c,
        libc/stdio/getdelim.c libc/stdio/getline.c libc/stdio/gets.c,
        libc/stdio/getw.c libc/stdio/iprintf.c libc/stdio/local.h,
        libc/stdio/makebuf.c libc/stdio/mktemp.c libc/stdio/perror.c,
        libc/stdio/printf.c libc/stdio/putc.c libc/stdio/putc_u.c,
        libc/stdio/putchar.c libc/stdio/putchar_u.c libc/stdio/puts.c,
        libc/stdio/putw.c libc/stdio/refill.c libc/stdio/remove.c,
        libc/stdio/rename.c libc/stdio/rewind.c libc/stdio/rget.c,
        libc/stdio/scanf.c libc/stdio/setbuf.c libc/stdio/setbuffer.c,
        libc/stdio/setlinebuf.c libc/stdio/setvbuf.c,
        libc/stdio/siprintf.c libc/stdio/snprintf.c,
        libc/stdio/sprintf.c libc/stdio/sscanf.c libc/stdio/stdio.c,
        libc/stdio/tmpfile.c libc/stdio/tmpnam.c libc/stdio/ungetc.c,
        libc/stdio/vasprintf.c libc/stdio/vfieeefp.h,
        libc/stdio/vfprintf.c libc/stdio/vfscanf.c,
        libc/stdio/vprintf.c libc/stdio/vscanf.c,
        libc/stdio/vsnprintf.c libc/stdio/vsprintf.c,
        libc/stdio/vsscanf.c libc/stdio/wbuf.c,
        libc/stdio/wsetup.c: Perform minor formatting changes.  Move
        copyright notices to top of file, ensure that <_ansi.h> is
        included, be consistent with open parentheses, use _DEFUN macro,
        include "local.h" where needed, and remove various compiler
        warnings.
@
text
@d2 1
a2 1
 * Copyright (c) 2002, Red Hat Inc.
d18 77
d98 2
d106 55
a160 2
  /* for now we simply cast since off_t should be long */
  return (_off_t)_ftell_r (ptr, fp);
d169 1
a169 1
  return (_off_t)_ftell_r (_REENT, fp);
@


1.4.12.1
log
@Pull in changes from HEAD
@
text
@d2 1
a2 1
 * Copyright (c) 1990 The Regents of the University of California.
a17 77
/*
FUNCTION
<<ftell>>, <<ftello>>---return position in a stream or file

INDEX
	ftell
INDEX
	ftello
INDEX
	_ftell_r
INDEX
	_ftello_r

ANSI_SYNOPSIS
	#include <stdio.h>
	long ftell(FILE *<[fp]>);
	off_t ftello(FILE *<[fp]>);
	long _ftell_r(struct _reent *<[ptr]>, FILE *<[fp]>);
	off_t _ftello_r(struct _reent *<[ptr]>, FILE *<[fp]>);

TRAD_SYNOPSIS
	#include <stdio.h>
	long ftell(<[fp]>)
	FILE *<[fp]>;

	off_t ftello(<[fp]>)
	FILE *<[fp]>;

	long _ftell_r(<[ptr]>, <[fp]>)
	struct _reent *<[ptr]>;
	FILE *<[fp]>;

	off_t _ftello_r(<[ptr]>, <[fp]>)
	struct _reent *<[ptr]>;
	FILE *<[fp]>;

DESCRIPTION
Objects of type <<FILE>> can have a ``position'' that records how much
of the file your program has already read.  Many of the <<stdio>> functions
depend on this position, and many change it as a side effect.

The result of <<ftell>>/<<ftello>> is the current position for a file
identified by <[fp]>.  If you record this result, you can later
use it with <<fseek>>/<<fseeko>> to return the file to this
position.  The difference between <<ftell>> and <<ftello>> is that
<<ftell>> returns <<long>> and <<ftello>> returns <<off_t>>.

In the current implementation, <<ftell>>/<<ftello>> simply uses a character
count to represent the file position; this is the same number that
would be recorded by <<fgetpos>>.

RETURNS
<<ftell>>/<<ftello>> return the file position, if possible.  If they cannot do
this, they return <<-1L>>.  Failure occurs on streams that do not support
positioning; the global <<errno>> indicates this condition with the
value <<ESPIPE>>.

PORTABILITY
<<ftell>> is required by the ANSI C standard, but the meaning of its
result (when successful) is not specified beyond requiring that it be
acceptable as an argument to <<fseek>>.  In particular, other
conforming C implementations may return a different result from
<<ftell>> than what <<fgetpos>> records.

<<ftello>> is defined by the Single Unix specification.

No supporting OS subroutines are required.
*/

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "%W% (Berkeley) %G%";
#endif /* LIBC_SCCS and not lint */

/*
 * ftello: return current offset.
 */

a20 2
#include <errno.h>
#include "local.h"
d27 2
a28 55
  _fpos_t pos;

  /* Ensure stdio is set up.  */

  CHECK_INIT (ptr, fp);

  _newlib_flockfile_start (fp);

  if (fp->_seek == NULL)
    {
      ptr->_errno = ESPIPE;
      _newlib_flockfile_exit (fp);
      return -1L;
    }

  /* Find offset of underlying I/O object, then adjust for buffered
     bytes.  Flush a write stream, since the offset may be altered if
     the stream is appending.  Do not flush a read stream, since we
     must not lose the ungetc buffer.  */
  if (fp->_flags & __SWR)
    _fflush_r (ptr, fp);
  if (fp->_flags & __SOFF)
    pos = fp->_offset;
  else
    {
      pos = fp->_seek (ptr, fp->_cookie, (_fpos_t) 0, SEEK_CUR);
      if (pos == -1L)
        {
          _newlib_flockfile_exit (fp);
          return pos;
        }
    }
  if (fp->_flags & __SRD)
    {
      /*
       * Reading.  Any unread characters (including
       * those from ungetc) cause the position to be
       * smaller than that in the underlying object.
       */
      pos -= fp->_r;
      if (HASUB (fp))
	pos -= fp->_ur;
    }
  else if ((fp->_flags & __SWR) && fp->_p != NULL)
    {
      /*
       * Writing.  Any buffered characters cause the
       * position to be greater than that in the
       * underlying object.
       */
      pos += fp->_p - fp->_bf._base;
    }

  _newlib_flockfile_end (fp);
  return pos;
d37 1
a37 1
  return _ftello_r (_REENT, fp);
@


1.3
log
@
2003-08-22  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/include/sys/reent.h: Add _GLOBAL_REENT macro.
	* libc/stdio: Globally remove/replace all references to fp->_data.
	Replace with _REENT or _GLOBAL_REENT where appropriate.
	* libc/stdio/asprintf.c: Ditto.
	* libc/stdio/fclose.c: Ditto.
	* libc/stdio/fvwrite.c: Ditto.
	* libc/stdio/makebuf.c: Ditto.
	* libc/stdio/refill.c: Ditto.
	* libc/stdio/local.h: Ditto.
	* libc/stdio/setvbuf.c: Ditto.
	* libc/stdio/sscanf.c: Ditto.
	* libc/stdio/stdio.c: Ditto.
	* libc/stdio/ungetc.c: Ditto.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdio/vsscanf.c: Ditto.
	* libc/stdio/fopen.c: Ditto.  Also use _fseek_r in _fopen_r.
	* libc/stdio/vasprintf.c: Ditto.  Also call _vfprintf_r directly.
	* libc/stdio/vsnprintf.c: Ditto.
	* libc/stdio/vsprintf.c: Ditto.
	* libc/stdio/fcloseall.c(fcloseall): Use _GLOBAL_REENT macro
	instead of _REENT to walk file list.
	* libc/stdio/fflush.c: Ditto.
	* libc/stdio/fgetpos.c: Add reentrant version and have regular
	version call reentrant version with _REENT argument.
	* libc/stdio/fsetpos.c: Ditto.
	* libc/stdio/fseek.c: Ditto.
	* libc/stdio/fseeko.c: Ditto.
	* libc/stdio/ftell.c: Ditto.
	* libc/stdio/ftello.c: Ditto.
	* libc/stdio/freopen.c: Ditto.
	* libc/stdio/findfp.c: Use _GLOBAL_REENT pointer when adding
	new files to chain.  Also use _GLOBAL_REENT pointer for
	cleaning up.
	* libc/stdio/fiprintf.c: Reformatted to minimize duplicate code.
	* libc/stdio/siprintf.c: Ditto.
	* libc/stdio/iprintf.c: Ditto.
	* libc/stdio/fprintf.c: Ditto.
	* libc/stdio/printf.c: Ditto.
	* libc/stdio/snprintf.c: Call _vfprintf_r directly.
	* libc/stdio/sprintf.c: Ditto.
	* libc/stdio/vprintf.c: Ditto.  Also add _REENT_ONLY check.
	* libc/stdio/rewind.c: Call _fseek_r directly.
	* libc/stdio/tmpfile.c: Call _fopen_r and _remove_r directly.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Change _r routines to use
	data pointer.
	(get_arg): Add extra struct _reent pointer argument.
	* libc/stdio64/fgetpos64.c: Add _r versions, remove any reference
	to fp->_data.
	* libc/stdio64/fopen64.c: Ditto.
	* libc/stdio64/freopen64.c: Ditto.
	* libc/stdio64/fsetpos64.c: Ditto.
	* libc/stdio64/ftello64.c: Ditto.
	* libc/stdio64/local64.h: Ditto.
	* libc/stdio64/stdio64.c: Ditto.
	* libc/stdio64/fseeko64.c: Ditto plus use _fstat_r instead of
	_fstat64_r for the meantime.
@
text
@d18 2
d23 3
a25 3
_DEFUN (_ftello_r, (ptr, fp),
	struct _reent * ptr _AND
	register FILE * fp)
d34 2
a35 2
_DEFUN (ftello, (fp),
	register FILE * fp)
@


1.2
log
@	* libc/include/stdio.h: Declare fgetpos, fsetpos, fseeko and ftello
	with internal (_fpos_t and _off_t) datatypes when compiling newlib.
	* libc/include/sys/unistd.h: Declare _lseek using _off_t.
	* libc/reent/lseekr.c (_lseek_r): Use _off_t instead of off_t.
	* libc/stdio/fseeko.c (fseeko): Ditto.
	* libc/stdio/ftello.c (ftello): Ditto.
	* libc/stdio/stdio.c (__swrite): Ditto.
	(__sseek): Ditto.
	* libc/stdio/fgetpos.c (fgetpos): Use _fpos_t instead of fpos_t.
	* libc/stdio/fseek.c (fseek): Ditto.
	* libc/stdio/fsetpos.c (fsetpos): Ditto.
	* libc/stdio/ftell.c (ftell): Ditto.
	* libc/stdio/local.h: Declare __sseek using _off_t.
@
text
@d21 11
d35 1
a35 2
  /* for now we simply cast since off_t should be long */
  return (_off_t)ftell (fp);
d37 2
@


1.1
log
@
2002-07-04  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdio.h: Add new prototypes.
        * libc/stdio/Makefile.am: Add fseeko.c and ftello.c.
        * libc/stdio/Makefile.in: Regenerated.
        * libc/stdio/fseek.c: Add fseeko documentation.
        * libc/stdio/ftell.c: Add ftello documentation.
        * libc/stdio/fseeko.c: New file.
        * libc/stdio/ftello.c: New file.
@
text
@d20 1
a20 1
off_t
d25 1
a25 1
  return (off_t)ftell (fp);
@

