head	1.6;
access;
symbols
	cygwin-1_7_35-release:1.6
	cygwin-1_7_34-release:1.6
	newlib-2_2_0:1.6.0.4
	cygwin-1_7_33-release:1.6
	cygwin-1_7_32-release:1.6
	cygwin-1_7_31-release:1.6
	cygwin-1_7_30-release:1.6
	cygwin-1_7_29-release:1.6
	cygwin-1_7_28-release:1.6
	newlib-2_1_0:1.6
	cygwin-1_7_27-release:1.6
	cygwin-1_7_26-release:1.6
	cygwin-1_7_25-release:1.6
	cygwin-1_7_24-release:1.6
	cygwin-1_7_23-release:1.6
	cygwin-1_7_22-release:1.6
	cygwin-1_7_21-release:1.6
	cygwin-1_7_20-release:1.6
	cygwin-1_7_19-release:1.6
	cygwin-64bit-postmerge:1.6
	cygwin-64bit-premerge-branch:1.6.0.2
	cygwin-64bit-premerge:1.6
	cygwin-1_7_18-release:1.6
	newlib-2_0_0:1.5
	cygwin-1_7_17-release:1.5
	cygwin-64bit-branch:1.5.0.6
	cygwin-1_7_16-release:1.5
	cygwin-1_7_15-release:1.5
	cygwin-1_7_14_2-release:1.5
	cygwin-1_7_14-release:1.5
	cygwin-1_7_12-release:1.5
	cygwin-1_7_11-release:1.5
	cygwin-1_7_10-release:1.5
	newlib-1_20_0:1.5
	cygwin-1_7_9-release:1.5
	cygwin-1_7_8-release:1.5
	newlib-1_19_0:1.5
	cygwin-1_7_7-release:1.5
	cygwin-1_7_5-release:1.5
	cygwin-1_7_4-release:1.5
	cygwin-1_7_3-release:1.5
	cygwin-1_7_2-release:1.5
	newlib-1_18_0:1.5
	cygwin-1_7_1-release:1.5
	newlib-1_17_0-arc:1.5.0.4
	binutils-arc-20080908-branch:1.5.0.2
	binutils-arc-20080908-branchpoint:1.5
	newlib-1_17_0:1.5
	newlib-1_16_0:1.5
	newlib-1_15_0:1.4
	newlib-csl-coldfire-4_1-32:1.4
	newlib-csl-sourcerygxx-4_1-32:1.4
	newlib-csl-innovasic-fido-3_4_4-33:1.4
	newlib-csl-coldfire-4_1-30:1.4
	newlib-csl-sourcerygxx-4_1-30:1.4
	newlib-csl-coldfire-4_1-28:1.4
	newlib-csl-sourcerygxx-4_1-28:1.4
	newlib-csl-arm-2006q3-27:1.4
	newlib-csl-sourcerygxx-4_1-27:1.4
	newlib-csl-arm-2006q3-26:1.4
	newlib-csl-sourcerygxx-4_1-26:1.4
	newlib-csl-sourcerygxx-4_1-24:1.4
	newlib-csl-sourcerygxx-4_1-23:1.4
	newlib-csl-sourcerygxx-4_1-21:1.4
	newlib-csl-arm-2006q3-21:1.4
	newlib-csl-arm-2006q3-19:1.4
	newlib-csl-sourcerygxx-4_1-19:1.4
	newlib-csl-sourcerygxx-4_1-18:1.4
	newlib-csl-sourcerygxx-3_4_4-25:1.4
	newlib-csl-sourcerygxx-4_1-17:1.4
	cr-0x5f1:1.4.0.6
	newlib-csl-sourcerygxx-4_1-14:1.4
	newlib-csl-sourcerygxx-4_1-13:1.4
	newlib-csl-sourcerygxx-4_1-12:1.4
	newlib-csl-sourcerygxx-4_1-9:1.4
	newlib-csl-sourcerygxx-4_1-8:1.4
	newlib-csl-sourcerygxx-4_1-7:1.4
	newlib-csl-arm-2006q1-6:1.4
	newlib-csl-sourcerygxx-4_1-6:1.4
	newlib-csl-sourcerygxx-4_1-5:1.4
	newlib-csl-sourcerygxx-4_1-4:1.4
	newlib-autotools-branch:1.4.0.4
	newlib-csl-20060320-branch:1.4.0.2
	newlib-csl-20060320-branchpoint:1.4
	newlib-1_14_0:1.4
	newlib-csl-arm-2005-q1b:1.4
	newlib-csl-arm-2005-q1a:1.4
	newlib-1_13_0:1.4
	csl-arm-2004-q3:1.4
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	newlib-1_12_0:1.3
	csl-arm-2003-q4:1.3
	w32api-2_2:1.3
	mingw-runtime-2_4:1.3
	newlib-1_11_0:1.3
	cygnus_cvs_20020108_pre:1.3
	newlib-1_10_0:1.3
	newlib-1_9_0:1.3
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2013.04.08.09.34.35;	author mgretton;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.31.21.21.27;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.26.00.19.14;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.14.00.25.06;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.06.23.50.11;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.6
log
@	* libc/stdio/vfieeefp.h (ldieee): Fix typo.
@
text
@/****************************************************************
 *
 * The author of this software is David M. Gay.
 *
 * Copyright (c) 1991 by AT&T.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR AT&T MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 ***************************************************************/

/* Please send bug reports to
	David M. Gay
	AT&T Bell Laboratories, Room 2C-463
	600 Mountain Avenue
	Murray Hill, NJ 07974-2070
	U.S.A.
	dmg@@research.att.com or research!dmg
 */

/* This header file is a modification of mprec.h that only contains floating
   point union code. */

#include <newlib.h>
#include <ieeefp.h>
#include <math.h>
#include <float.h>
#include <errno.h>
#include <sys/config.h>

#ifdef __IEEE_LITTLE_ENDIAN
#define IEEE_8087
#endif

#ifdef __IEEE_BIG_ENDIAN
#define IEEE_MC68k
#endif

#ifdef __Z8000__
#define Just_16
#endif

#ifdef Unsigned_Shifts
#define Sign_Extend(a,b) if (b < 0) a |= (__uint32_t)0xffff0000;
#else
#define Sign_Extend(a,b) /*no-op*/
#endif

#if defined(IEEE_8087) + defined(IEEE_MC68k) + defined(VAX) + defined(IBM) != 1
Exactly one of IEEE_8087, IEEE_MC68k, VAX, or IBM should be defined.
#endif

#ifdef _WANT_IO_LONG_DOUBLE
/* If we are going to examine or modify specific bits in a long double using
   the lword0 or lwordx macros, then we must wrap the long double inside
   a union.  This is necessary to avoid undefined behavior according to
   the ANSI C spec.  */

#ifdef IEEE_8087
#if LDBL_MANT_DIG == 24
struct ldieee
{
  unsigned manh:23;
  unsigned exp:8;
  unsigned sign:1;
};
#elif LDBL_MANT_DIG == 53
struct ldieee
{
  unsigned manl:20;
  unsigned manh:32;
  unsigned exp:11;
  unsigned sign:1;
};
#elif LDBL_MANT_DIG == 64
struct ldieee
{
  unsigned manl:32;
  unsigned manh:32;
  unsigned exp:15;
  unsigned sign:1;
};
#elif LDBL_MANT_DIG > 64
struct ldieee
{
  unsigned manl3:16;
  unsigned manl2:32;
  unsigned manl:32;
  unsigned manh:32;
  unsigned exp:15;
  unsigned sign:1;
};
#endif /* LDBL_MANT_DIG */
#else  /* !IEEE_8087 */
#if LDBL_MANT_DIG == 24
struct ldieee
{
  unsigned sign:1;
  unsigned exp:8;
  unsigned manh:23;
};
#elif LDBL_MANT_DIG == 53
struct ldieee
{
  unsigned sign:1;
  unsigned exp:11;
  unsigned manh:32;
  unsigned manl:20;
};
#elif LDBL_MANT_DIG == 64
struct ldieee
{
  unsigned sign:1;
  unsigned exp:15;
  unsigned manh:32;
  unsigned manl:32;
};
#elif LDBL_MANT_DIG > 64
struct ldieee
{
  unsigned sign:1;
  unsigned exp:15;
  unsigned manh:32;
  unsigned manl:32;
  unsigned manl2:32;
  unsigned manl3:16;
};
#endif /* LDBL_MANT_DIG */
#endif /* !IEEE_8087 */
#endif /* _WANT_IO_LONG_DOUBLE */

/* If we are going to examine or modify specific bits in a double using
   the word0 and/or word1 macros, then we must wrap the double inside
   a union.  This is necessary to avoid undefined behavior according to
   the ANSI C spec.  */
union double_union
{
  double d;
  __uint32_t i[2];
};

#ifdef IEEE_8087
#define word0(x) (x.i[1])
#define word1(x) (x.i[0])
#else
#define word0(x) (x.i[0])
#define word1(x) (x.i[1])
#endif

/* #define P DBL_MANT_DIG */
/* Ten_pmax = floor(P*log(2)/log(5)) */
/* Bletch = (highest power of 2 < DBL_MAX_10_EXP) / 16 */
/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */

#if defined(IEEE_8087) + defined(IEEE_MC68k)
#if defined (_DOUBLE_IS_32BITS) 
#define Exp_shift   23
#define Exp_shift1  23
#define Exp_msk1    ((__uint32_t)0x00800000L)
#define Exp_msk11   ((__uint32_t)0x00800000L)
#define Exp_mask    ((__uint32_t)0x7f800000L)
#define P    	    24
#define Bias 	    127
#define IEEE_Arith
#define Emin        (-126)
#define Exp_1       ((__uint32_t)0x3f800000L)
#define Exp_11      ((__uint32_t)0x3f800000L)
#define Ebits 	    8
#define Frac_mask   ((__uint32_t)0x007fffffL)
#define Frac_mask1  ((__uint32_t)0x007fffffL)
#define Ten_pmax    10
#define Sign_bit    ((__uint32_t)0x80000000L)
#define Ten_pmax    10
#define Bletch	    2
#define Bndry_mask  ((__uint32_t)0x007fffffL)
#define Bndry_mask1 ((__uint32_t)0x007fffffL)
#define LSB 1
#define Sign_bit    ((__uint32_t)0x80000000L)
#define Log2P 	    1
#define Tiny0 	    0
#define Tiny1 	    1
#define Quick_max   5
#define Int_max     6
#define Infinite(x) (word0(x) == ((__uint32_t)0x7f800000L))
#undef word0
#undef word1

#define word0(x) (x.i[0])
#define word1(x) 0
#else

#define Exp_shift  20
#define Exp_shift1 20
#define Exp_msk1    ((__uint32_t)0x100000L)
#define Exp_msk11   ((__uint32_t)0x100000L)
#define Exp_mask  ((__uint32_t)0x7ff00000L)
#define P 53
#define Bias 1023
#define IEEE_Arith
#define Emin (-1022)
#define Exp_1  ((__uint32_t)0x3ff00000L)
#define Exp_11 ((__uint32_t)0x3ff00000L)
#define Ebits 11
#define Frac_mask  ((__uint32_t)0xfffffL)
#define Frac_mask1 ((__uint32_t)0xfffffL)
#define Ten_pmax 22
#define Bletch 0x10
#define Bndry_mask  ((__uint32_t)0xfffffL)
#define Bndry_mask1 ((__uint32_t)0xfffffL)
#define LSB 1
#define Sign_bit ((__uint32_t)0x80000000L)
#define Log2P 1
#define Tiny0 0
#define Tiny1 1
#define Quick_max 14
#define Int_max 14
#define Infinite(x) (word0(x) == ((__uint32_t)0x7ff00000L)) /* sufficient test for here */
#endif

#else
#undef  Sudden_Underflow
#define Sudden_Underflow
#ifdef IBM
#define Exp_shift  24
#define Exp_shift1 24
#define Exp_msk1   ((__uint32_t)0x1000000L)
#define Exp_msk11  ((__uint32_t)0x1000000L)
#define Exp_mask  ((__uint32_t)0x7f000000L)
#define P 14
#define Bias 65
#define Exp_1  ((__uint32_t)0x41000000L)
#define Exp_11 ((__uint32_t)0x41000000L)
#define Ebits 8	/* exponent has 7 bits, but 8 is the right value in b2d */
#define Frac_mask  ((__uint32_t)0xffffffL)
#define Frac_mask1 ((__uint32_t)0xffffffL)
#define Bletch 4
#define Ten_pmax 22
#define Bndry_mask  ((__uint32_t)0xefffffL)
#define Bndry_mask1 ((__uint32_t)0xffffffL)
#define LSB 1
#define Sign_bit ((__uint32_t)0x80000000L)
#define Log2P 4
#define Tiny0 ((__uint32_t)0x100000L)
#define Tiny1 0
#define Quick_max 14
#define Int_max 15
#else /* VAX */
#define Exp_shift  23
#define Exp_shift1 7
#define Exp_msk1    0x80
#define Exp_msk11   ((__uint32_t)0x800000L)
#define Exp_mask  ((__uint32_t)0x7f80L)
#define P 56
#define Bias 129
#define Exp_1  ((__uint32_t)0x40800000L)
#define Exp_11 ((__uint32_t)0x4080L)
#define Ebits 8
#define Frac_mask  ((__uint32_t)0x7fffffL)
#define Frac_mask1 ((__uint32_t)0xffff007fL)
#define Ten_pmax 24
#define Bletch 2
#define Bndry_mask  ((__uint32_t)0xffff007fL)
#define Bndry_mask1 ((__uint32_t)0xffff007fL)
#define LSB ((__uint32_t)0x10000L)
#define Sign_bit ((__uint32_t)0x8000L)
#define Log2P 1
#define Tiny0 0x80
#define Tiny1 0
#define Quick_max 15
#define Int_max 15
#endif
#endif


@


1.5
log
@
2007-08-31  Antony King  <antony.king@@st.com>

        * libc/stdlib/mprec.h [_DOUBLE_IS_32BITS}: Define IEEE_Arith
        bits and redefine associated dword0 macro (rvalue issue).
        * libc/stdio/vfieeefp.h: Ditto.
        * libc/stdlib/strtod.c: Add checks for _DOUBLE_IS_32BITS
        to prevent setting dword1 which is an rvalue only.
@
text
@d134 1
a134 1
  unsigned manl3;16;
@


1.4
log
@
2004-05-25  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * newlib.hin: (_WANT_IO_POS_ARGS): New define.
        (_WANT_IO_LONG_LONG): Ditto.
        (_WANT_IO_LONG_DOUBLE): Ditto.
        * configure.in: Add new configuration options
        --enable-newlib-io-long-long and --enable-newlib-io-long-double
        which tie to new defines in newlib.hin.
        * configure: Regenerated.
        * configure.host: Add checks for new configuration options.  Also
        fix up check for --enable-newlib-io-pos-args so configuration
        option will override any default for a given platform.
        Remove defining compiler flags for the _WANT_IO* options.
        * libc/stdio/vfprintf.c: Change to use new newlib.hin defines
        instead of looking for old compiler flags.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/vfieeefp.h: Ditto.
        * libc/machine/powerpc/vfprintf.c: Ditto.
        * libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@d173 1
a173 3
#if 0
#define IEEE_Arith  /* it is, but the code doesn't handle IEEE singles yet */
#endif
@


1.3
log
@
2000-12-13  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/ldtoa.c (_ldcheck): New routine
        that categorizes a long double as NaN, Infinity, or other.
        * libc/stdio/vfprintf.c [WANT_IO_LONG_DBL](_VFPRINTF_R): Removed
        isinfl and isnanl static routines which were i386-specific.  Changed
        calls to the two removed routines to a single _ldcheck call.
        * libc/stdio/vfieeefp.h (ldieee): Fixed missing semi-colons.
@
text
@d32 1
d61 1
a61 1
#ifdef WANT_IO_LONG_DBL
d138 1
a138 1
#endif /* WANT_IO_LONG_DBL */
@


1.2
log
@
2000-12-06  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/Makefile.am: Added ldtoa.c to list of sources.
        * libc/stdlib/Makefile.in: Regenerated.
        * libc/stdio/floatio.h: Added suitable MAXEXP for long double.
        * libc/stdio/vfieeefp.h: Added long double bit structures.
        * libc/stdio/vfprintf.c[WANT_IO_LONG_DBL]: Added long double support.
        [WANT_IO_LONG_DBL](isinfl, isnanl): New static long double routines.
        (exponent): Changed expbuf to reasonable maximum instead of MAXEXP.
        * libc/stdio/vfscanf.c[WANT_IO_LONG_DBL]: Added long double support.
        * libc/stdlib/ldtoa.c: New file containing _ldtoa_r and
        _strtold routines used for conversions between character
        and long double.
@
text
@d73 1
a73 1
}
d81 1
a81 1
}
d108 1
a108 1
}
d116 1
a116 1
}
d124 1
a124 1
}
@


1.1
log
@Initial revision
@
text
@d60 79
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
