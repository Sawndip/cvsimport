head	1.55;
access;
symbols
	cygwin-1_7_35-release:1.55
	cygwin-1_7_34-release:1.55
	newlib-2_2_0:1.55.0.2
	cygwin-1_7_33-release:1.55
	cygwin-1_7_32-release:1.55
	cygwin-1_7_31-release:1.55
	cygwin-1_7_30-release:1.55
	cygwin-1_7_29-release:1.55
	cygwin-1_7_28-release:1.55
	newlib-2_1_0:1.55
	cygwin-1_7_27-release:1.54
	cygwin-1_7_26-release:1.54
	cygwin-1_7_25-release:1.54
	cygwin-1_7_24-release:1.54
	cygwin-1_7_23-release:1.54
	cygwin-1_7_22-release:1.54
	cygwin-1_7_21-release:1.54
	cygwin-1_7_20-release:1.54
	cygwin-1_7_19-release:1.54
	cygwin-64bit-postmerge:1.53
	cygwin-64bit-premerge-branch:1.53.0.4
	cygwin-64bit-premerge:1.53
	cygwin-1_7_18-release:1.53
	newlib-2_0_0:1.53
	cygwin-1_7_17-release:1.53
	cygwin-64bit-branch:1.53.0.2
	cygwin-1_7_16-release:1.52
	cygwin-1_7_15-release:1.51
	cygwin-1_7_14_2-release:1.51
	cygwin-1_7_14-release:1.51
	cygwin-1_7_12-release:1.51
	cygwin-1_7_11-release:1.51
	cygwin-1_7_10-release:1.51
	newlib-1_20_0:1.51
	cygwin-1_7_9-release:1.50
	cygwin-1_7_8-release:1.50
	newlib-1_19_0:1.49
	cygwin-1_7_7-release:1.49
	cygwin-1_7_5-release:1.49
	cygwin-1_7_4-release:1.49
	cygwin-1_7_3-release:1.49
	cygwin-1_7_2-release:1.49
	newlib-1_18_0:1.48
	cygwin-1_7_1-release:1.48
	newlib-1_17_0-arc:1.45.0.2
	binutils-arc-20080908-branch:1.40.0.2
	binutils-arc-20080908-branchpoint:1.40
	newlib-1_17_0:1.45
	newlib-1_16_0:1.39
	newlib-1_15_0:1.33
	newlib-csl-coldfire-4_1-32:1.31.2.1
	newlib-csl-sourcerygxx-4_1-32:1.31.2.1
	newlib-csl-innovasic-fido-3_4_4-33:1.31.2.1
	newlib-csl-coldfire-4_1-30:1.31.2.1
	newlib-csl-sourcerygxx-4_1-30:1.31.2.1
	newlib-csl-coldfire-4_1-28:1.31.2.1
	newlib-csl-sourcerygxx-4_1-28:1.31.2.1
	newlib-csl-arm-2006q3-27:1.31.2.1
	newlib-csl-sourcerygxx-4_1-27:1.31.2.1
	newlib-csl-arm-2006q3-26:1.31.2.1
	newlib-csl-sourcerygxx-4_1-26:1.31.2.1
	newlib-csl-sourcerygxx-4_1-24:1.31.2.1
	newlib-csl-sourcerygxx-4_1-23:1.31.2.1
	newlib-csl-sourcerygxx-4_1-21:1.31.2.1
	newlib-csl-arm-2006q3-21:1.31.2.1
	newlib-csl-arm-2006q3-19:1.31
	newlib-csl-sourcerygxx-4_1-19:1.31
	newlib-csl-sourcerygxx-4_1-18:1.31
	newlib-csl-sourcerygxx-3_4_4-25:1.32
	newlib-csl-sourcerygxx-4_1-17:1.31
	cr-0x5f1:1.32.0.2
	newlib-csl-sourcerygxx-4_1-14:1.31
	newlib-csl-sourcerygxx-4_1-13:1.31
	newlib-csl-sourcerygxx-4_1-12:1.31
	newlib-csl-sourcerygxx-4_1-9:1.31
	newlib-csl-sourcerygxx-4_1-8:1.31
	newlib-csl-sourcerygxx-4_1-7:1.31
	newlib-csl-arm-2006q1-6:1.31
	newlib-csl-sourcerygxx-4_1-6:1.31
	newlib-csl-sourcerygxx-4_1-5:1.31
	newlib-csl-sourcerygxx-4_1-4:1.31
	newlib-autotools-branch:1.31.0.4
	newlib-csl-20060320-branch:1.31.0.2
	newlib-csl-20060320-branchpoint:1.31
	newlib-1_14_0:1.31
	newlib-csl-arm-2005-q1b:1.30
	newlib-csl-arm-2005-q1a:1.28
	newlib-1_13_0:1.26
	csl-arm-2004-q3:1.24
	csl-arm-2004-q1a:1.21
	csl-arm-2004-q1:1.18
	newlib-1_12_0:1.17
	csl-arm-2003-q4:1.17
	w32api-2_2:1.12
	mingw-runtime-2_4:1.12
	newlib-1_11_0:1.12
	cygnus_cvs_20020108_pre:1.10
	newlib-1_10_0:1.10
	newlib-1_9_0:1.6
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.55
date	2013.12.18.19.23.33;	author corinna;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.29.21.06.23;	author jjohnstn;	state Exp;
branches;
next	1.53;

1.53
date	2012.08.08.11.04.17;	author corinna;	state Exp;
branches;
next	1.52;

1.52
date	2012.05.30.08.58.42;	author corinna;	state Exp;
branches;
next	1.51;

1.51
date	2011.08.23.11.59.55;	author corsepiu;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.28.10.49.11;	author corinna;	state Exp;
branches;
next	1.49;

1.49
date	2010.01.19.23.16.45;	author jjohnstn;	state Exp;
branches;
next	1.48;

1.48
date	2009.11.18.09.49.57;	author corinna;	state Exp;
branches;
next	1.47;

1.47
date	2009.03.11.11.53.22;	author corinna;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.28.18.12.52;	author jjohnstn;	state Exp;
branches;
next	1.45;

1.45
date	2008.12.11.17.27.56;	author jjohnstn;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.10.23.43.12;	author jjohnstn;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.24.17.15.43;	author corinna;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.31.21.08.03;	author jjohnstn;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.15.19.33.10;	author jjohnstn;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.14.21.14.55;	author jjohnstn;	state Exp;
branches;
next	1.39;

1.39
date	2007.07.19.03.42.21;	author ericb;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.24.04.25.18;	author ericb;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.23.20.36.28;	author ericb;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.18.14.33.30;	author ericb;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.11.20.09.00;	author ericb;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.17.20.53.24;	author jjohnstn;	state Exp;
branches;
next	1.33;

1.33
date	2006.09.26.21.22.19;	author jjohnstn;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.14.20.49.11;	author jjohnstn;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2005.10.28.21.38.59;	author jjohnstn;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2005.04.28.18.26.08;	author jjohnstn;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.05.18.38.09;	author jjohnstn;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.08.01.33.17;	author jjohnstn;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.06.23.31.56;	author jjohnstn;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.24.00.45.41;	author jjohnstn;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.04.17.51.50;	author jjohnstn;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.16.17.09.31;	author jjohnstn;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.02.19.22.14;	author jjohnstn;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.26.00.19.14;	author jjohnstn;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.23.21.44.22;	author jjohnstn;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.23.20.01.55;	author jjohnstn;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.22.21.58.15;	author jjohnstn;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.02.00.59.17;	author jjohnstn;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.05.01.42.26;	author jjohnstn;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.21.20.48.49;	author jjohnstn;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.22.18.52.25;	author jjohnstn;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.01.16.27.52;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.20.17.23.57;	author jjohnstn;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.23.01.56.03;	author fitzsim;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.11.22.06.09;	author jjohnstn;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.01.18.05.11;	author jjohnstn;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.13.21.12.32;	author jjohnstn;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.27.21.59.44;	author jjohnstn;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.20.22.50.51;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.07.00.17.20;	author jjohnstn;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.06.23.50.11;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.24.16.25.35;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.17.17.10.16;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.17.20.40.20;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.32.2.1
date	2007.11.14.15.57.45;	author corinna;	state Exp;
branches;
next	;

1.31.2.1
date	2006.09.27.19.57.15;	author pbrook;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.55
log
@	* vfscanf.c (BUF): Change definition to take multibyte decimal point
	into account.
	(__SVFSCANF_R): Handle radix char language-dependent
	per POSIX.
	(__SVFWSCANF_R): Ditto.
@
text
@/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
FUNCTION
<<vfscanf>>, <<vscanf>>, <<vsscanf>>---format argument list

INDEX
	vfscanf
INDEX
	_vfscanf_r
INDEX
	vscanf
INDEX
	_vscanf_r
INDEX
	vsscanf
INDEX
	_vsscanf_r

ANSI_SYNOPSIS
	#include <stdio.h>
	#include <stdarg.h>
	int vscanf(const char *<[fmt]>, va_list <[list]>);
	int vfscanf(FILE *<[fp]>, const char *<[fmt]>, va_list <[list]>);
	int vsscanf(const char *<[str]>, const char *<[fmt]>, va_list <[list]>);

	int _vscanf_r(struct _reent *<[reent]>, const char *<[fmt]>,
                       va_list <[list]>);
	int _vfscanf_r(struct _reent *<[reent]>, FILE *<[fp]>, const char *<[fmt]>,
                       va_list <[list]>);
	int _vsscanf_r(struct _reent *<[reent]>, const char *<[str]>,
                       const char *<[fmt]>, va_list <[list]>);

TRAD_SYNOPSIS
	#include <stdio.h>
	#include <varargs.h>
	int vscanf( <[fmt]>, <[ist]>)
	char *<[fmt]>;
	va_list <[list]>;

	int vfscanf( <[fp]>, <[fmt]>, <[list]>)
	FILE *<[fp]>;
	char *<[fmt]>;
	va_list <[list]>;

	int vsscanf( <[str]>, <[fmt]>, <[list]>)
	char *<[str]>;
	char *<[fmt]>;
	va_list <[list]>;

	int _vscanf_r( <[reent]>, <[fmt]>, <[ist]>)
	struct _reent *<[reent]>;
	char *<[fmt]>;
	va_list <[list]>;

	int _vfscanf_r( <[reent]>, <[fp]>, <[fmt]>, <[list]>)
	struct _reent *<[reent]>;
	FILE *<[fp]>;
	char *<[fmt]>;
	va_list <[list]>;

	int _vsscanf_r( <[reent]>, <[str]>, <[fmt]>, <[list]>)
	struct _reent *<[reent]>;
	char *<[str]>;
	char *<[fmt]>;
	va_list <[list]>;

DESCRIPTION
<<vscanf>>, <<vfscanf>>, and <<vsscanf>> are (respectively) variants
of <<scanf>>, <<fscanf>>, and <<sscanf>>.  They differ only in
allowing their caller to pass the variable argument list as a
<<va_list>> object (initialized by <<va_start>>) rather than
directly accepting a variable number of arguments.

RETURNS
The return values are consistent with the corresponding functions:
<<vscanf>> returns the number of input fields successfully scanned,
converted, and stored; the return value does not include scanned
fields which were not stored.

If <<vscanf>> attempts to read at end-of-file, the return value
is <<EOF>>.

If no fields were stored, the return value is <<0>>.

The routines <<_vscanf_r>>, <<_vfscanf_f>>, and <<_vsscanf_r>> are
reentrant versions which take an additional first parameter which points to the
reentrancy structure.

PORTABILITY
These are GNU extensions.

Supporting OS subroutines required:
*/

#include <_ansi.h>
#include <reent.h>
#include <newlib.h>
#include <ctype.h>
#include <wctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <limits.h>
#include <wchar.h>
#include <string.h>
#include <stdarg.h>
#include <errno.h>
#include "local.h"
#include "../stdlib/local.h"

#ifdef INTEGER_ONLY
#define VFSCANF vfiscanf
#define _VFSCANF_R _vfiscanf_r
#define __SVFSCANF __svfiscanf
#ifdef STRING_ONLY
#  define __SVFSCANF_R __ssvfiscanf_r
#else
#  define __SVFSCANF_R __svfiscanf_r
#endif
#else
#define VFSCANF vfscanf
#define _VFSCANF_R _vfscanf_r
#define __SVFSCANF __svfscanf
#ifdef STRING_ONLY
#  define __SVFSCANF_R __ssvfscanf_r
#else
#  define __SVFSCANF_R __svfscanf_r
#endif
#ifndef NO_FLOATING_POINT
#define FLOATING_POINT
#endif
#endif

#ifdef STRING_ONLY
#undef _newlib_flockfile_start
#undef _newlib_flockfile_exit
#undef _newlib_flockfile_end
#define _newlib_flockfile_start(x) {}
#define _newlib_flockfile_exit(x) {}
#define _newlib_flockfile_end(x) {}
#define _ungetc_r _sungetc_r
#define __srefill_r __ssrefill_r
#define _fread_r _sfread_r
#endif

#ifdef FLOATING_POINT
#include <math.h>
#include <float.h>
#include <locale.h>

/* Currently a test is made to see if long double processing is warranted.
   This could be changed in the future should the _ldtoa_r code be
   preferred over _dtoa_r.  */
#define _NO_LONGDBL
#if defined _WANT_IO_LONG_DOUBLE && (LDBL_MANT_DIG > DBL_MANT_DIG)
#undef _NO_LONGDBL
extern _LONG_DOUBLE _strtold _PARAMS((char *s, char **sptr));
#endif

#include "floatio.h"

#define BUF (MAXEXP+MAXFRACT+MB_LEN_MAX+2) /* decimal point + sign + NUL */

/* An upper bound for how long a long prints in decimal.  4 / 13 approximates
   log (2).  Add one char for roundoff compensation and one for the sign.  */
#define MAX_LONG_LEN ((CHAR_BIT * sizeof (long)  - 1) * 4 / 13 + 2)
#else
#define	BUF	40
#endif

#define _NO_LONGLONG
#if defined _WANT_IO_LONG_LONG \
	&& (defined __GNUC__ || __STDC_VERSION__ >= 199901L)
# undef _NO_LONGLONG
#endif

#define _NO_POS_ARGS
#ifdef _WANT_IO_POS_ARGS
# undef _NO_POS_ARGS
# ifdef NL_ARGMAX
#  define MAX_POS_ARGS NL_ARGMAX
# else
#  define MAX_POS_ARGS 32
# endif

static void * get_arg (int, va_list *, int *, void **);
#endif /* _WANT_IO_POS_ARGS */

/*
 * Flags used during conversion.
 */

#define	LONG		0x01	/* l: long or double */
#define	LONGDBL		0x02	/* L/ll: long double or long long */
#define	SHORT		0x04	/* h: short */
#define CHAR		0x08	/* hh: 8 bit integer */
#define	SUPPRESS	0x10	/* suppress assignment */
#define	POINTER		0x20	/* weird %p pointer (`fake hex') */
#define	NOSKIP		0x40	/* do not skip blanks */

/*
 * The following are used in numeric conversions only:
 * SIGNOK, NDIGITS, DPTOK, and EXPOK are for floating point;
 * SIGNOK, NDIGITS, PFXOK, and NZDIGITS are for integral.
 */

#define	SIGNOK		0x80	/* +/- is (still) legal */
#define	NDIGITS		0x100	/* no digits detected */

#define	DPTOK		0x200	/* (float) decimal point is still legal */
#define	EXPOK		0x400	/* (float) exponent (e+3, etc) still legal */

#define	PFXOK		0x200	/* 0x prefix is (still) legal */
#define	NZDIGITS	0x400	/* no zero digits detected */
#define	NNZDIGITS	0x800	/* no non-zero digits detected */

/*
 * Conversion types.
 */

#define	CT_CHAR		0	/* %c conversion */
#define	CT_CCL		1	/* %[...] conversion */
#define	CT_STRING	2	/* %s conversion */
#define	CT_INT		3	/* integer, i.e., strtol or strtoul */
#define	CT_FLOAT	4	/* floating, i.e., strtod */

#define u_char unsigned char
#define u_long unsigned long

#ifndef _NO_LONGLONG
typedef unsigned long long u_long_long;
#endif

/*
 * vfscanf
 */

#define BufferEmpty (fp->_r <= 0 && __srefill_r(rptr, fp))

#ifndef STRING_ONLY

#ifndef _REENT_ONLY

int
_DEFUN(VFSCANF, (fp, fmt, ap),
       register FILE *fp _AND
       _CONST char *fmt _AND
       va_list ap)
{
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
  return __SVFSCANF_R (reent, fp, fmt, ap);
}

int
_DEFUN(__SVFSCANF, (fp, fmt0, ap),
       register FILE *fp _AND
       char _CONST *fmt0 _AND
       va_list ap)
{
  return __SVFSCANF_R (_REENT, fp, fmt0, ap);
}

#endif /* !_REENT_ONLY */

int
_DEFUN(_VFSCANF_R, (data, fp, fmt, ap),
       struct _reent *data _AND
       register FILE *fp   _AND
       _CONST char *fmt    _AND
       va_list ap)
{
  CHECK_INIT(data, fp);
  return __SVFSCANF_R (data, fp, fmt, ap);
}
#endif /* !STRING_ONLY */

#if defined (STRING_ONLY) && defined (INTEGER_ONLY)
/* When dealing with the sscanf family, we don't want to use the
 * regular ungetc which will drag in file I/O items we don't need.
 * So, we create our own trimmed-down version.  */
int
_DEFUN(_sungetc_r, (data, fp, ch),
	struct _reent *data _AND
	int c               _AND
	register FILE *fp)
{
  if (c == EOF)
    return (EOF);

  /* After ungetc, we won't be at eof anymore */
  fp->_flags &= ~__SEOF;
  c = (unsigned char) c;

  /*
   * If we are in the middle of ungetc'ing, just continue.
   * This may require expanding the current ungetc buffer.
   */

  if (HASUB (fp))
    {
      if (fp->_r >= fp->_ub._size && __submore (data, fp))
        {
          return EOF;
        }
      *--fp->_p = c;
      fp->_r++;
      return c;
    }

  /*
   * If we can handle this by simply backing up, do so,
   * but never replace the original character.
   * (This makes sscanf() work when scanning `const' data.)
   */

  if (fp->_bf._base != NULL && fp->_p > fp->_bf._base && fp->_p[-1] == c)
    {
      fp->_p--;
      fp->_r++;
      return c;
    }

  /*
   * Create an ungetc buffer.
   * Initially, we will use the `reserve' buffer.
   */

  fp->_ur = fp->_r;
  fp->_up = fp->_p;
  fp->_ub._base = fp->_ubuf;
  fp->_ub._size = sizeof (fp->_ubuf);
  fp->_ubuf[sizeof (fp->_ubuf) - 1] = c;
  fp->_p = &fp->_ubuf[sizeof (fp->_ubuf) - 1];
  fp->_r = 1;
  return c;
}

/* String only version of __srefill_r for sscanf family.  */
int
_DEFUN(__ssrefill_r, (ptr, fp),
       struct _reent * ptr _AND
       register FILE * fp)
{
  /*
   * Our only hope of further input is the ungetc buffer.
   * If there is anything in that buffer to read, return.
   */
  if (HASUB (fp))
    {
      FREEUB (ptr, fp);
      if ((fp->_r = fp->_ur) != 0)
        {
          fp->_p = fp->_up;
	  return 0;
        }
    }

  /* Otherwise we are out of character input.  */
  fp->_p = fp->_bf._base;
  fp->_r = 0;
  fp->_flags |= __SEOF;
  return EOF;
}

size_t
_DEFUN(_sfread_r, (ptr, buf, size, count, fp),
       struct _reent * ptr _AND
       _PTR buf _AND
       size_t size _AND
       size_t count _AND
       FILE * fp)
{
  register size_t resid;
  register char *p;
  register int r;
  size_t total;

  if ((resid = count * size) == 0)
    return 0;

  total = resid;
  p = buf;

  while (resid > (r = fp->_r))
    {
      _CAST_VOID memcpy ((_PTR) p, (_PTR) fp->_p, (size_t) r);
      fp->_p += r;
      fp->_r = 0;
      p += r;
      resid -= r;
      if (__ssrefill_r (ptr, fp))
        {
          /* no more input: return partial result */
          return (total - resid) / size;
        }
    }
  _CAST_VOID memcpy ((_PTR) p, (_PTR) fp->_p, resid);
  fp->_r -= resid;
  fp->_p += resid;
  return count;
}
#else /* !STRING_ONLY || !INTEGER_ONLY */
int _EXFUN (_sungetc_r, (struct _reent *, int, register FILE *));
int _EXFUN (__ssrefill_r, (struct _reent *, register FILE *));
size_t _EXFUN (_sfread_r, (struct _reent *, _PTR buf, size_t, size_t, FILE *));
#endif /* !STRING_ONLY || !INTEGER_ONLY */

int
_DEFUN(__SVFSCANF_R, (rptr, fp, fmt0, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       char _CONST *fmt0   _AND
       va_list ap)
{
  register u_char *fmt = (u_char *) fmt0;
  register int c;		/* character from format, or conversion */
  register size_t width;	/* field width, or 0 */
  register char *p;		/* points into all kinds of strings */
  register int n;		/* handy integer */
  register int flags;		/* flags as defined above */
  register char *p0;		/* saves original value of p when necessary */
  int nassigned;		/* number of fields assigned */
  int nread;			/* number of characters consumed from fp */
#ifndef _NO_POS_ARGS
  int N;			/* arg number */
  int arg_index = 0;		/* index into args processed directly */
  int numargs = 0;		/* number of varargs read */
  void *args[MAX_POS_ARGS];	/* positional args read */
  int is_pos_arg;		/* is current format positional? */
#endif
  int base = 0;			/* base argument to strtol/strtoul */
  int nbytes = 1;               /* number of bytes read from fmt string */
  wchar_t wc;                   /* wchar to use to read format string */
  wchar_t *wcp;                 /* handy wide character pointer */
  size_t mbslen;                /* length of converted multibyte sequence */
#ifdef _MB_CAPABLE
  mbstate_t state;              /* value to keep track of multibyte state */
#endif

  #define CCFN_PARAMS	_PARAMS((struct _reent *, const char *, char **, int))
  u_long (*ccfn)CCFN_PARAMS=0;	/* conversion function (strtol/strtoul) */
  char ccltab[256];		/* character class table for %[...] */
  char buf[BUF];		/* buffer for numeric conversions */
  unsigned char *lptr;          /* literal pointer */

  char *cp;
  short *sp;
  int *ip;
#ifdef FLOATING_POINT
  float *flp;
  _LONG_DOUBLE *ldp;
  double *dp;
#endif
  long *lp;
#ifndef _NO_LONGLONG
  long long *llp;
#endif

  /* `basefix' is used to avoid `if' tests in the integer scanner */
  static _CONST short basefix[17] =
    {10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};

  /* Macro to support positional arguments */
#ifndef _NO_POS_ARGS
# define GET_ARG(n, ap, type)					\
  ((type) (is_pos_arg						\
	   ? (n < numargs					\
	      ? args[n]						\
	      : get_arg (n, &ap, &numargs, args))		\
	   : (arg_index++ < numargs				\
	      ? args[n]						\
	      : (numargs < MAX_POS_ARGS				\
		 ? args[numargs++] = va_arg (ap, void *)	\
		 : va_arg (ap, void *)))))
#else
# define GET_ARG(n, ap, type) (va_arg (ap, type))
#endif

  _newlib_flockfile_start (fp);

  ORIENT (fp, -1);

  nassigned = 0;
  nread = 0;
#ifdef _MB_CAPABLE
  memset (&state, 0, sizeof (state));
#endif

  for (;;)
    {
#ifndef _MB_CAPABLE
      wc = *fmt;
#else
      nbytes = __mbtowc (rptr, &wc, (char *) fmt, MB_CUR_MAX,
			 __locale_charset (), &state);
      if (nbytes < 0) {
	wc = 0xFFFD; /* Unicode replacement character */
	nbytes = 1;
	memset (&state, 0, sizeof (state));
      }
#endif
      fmt += nbytes;

      if (wc == 0)
	goto all_done;
      if (nbytes == 1 && isspace (wc))
	{
	  for (;;)
	    {
	      if (BufferEmpty || !isspace (*fp->_p))
		break;
	      nread++, fp->_r--, fp->_p++;
	    }
	  continue;
	}
      if (wc != '%')
	goto literal;
      width = 0;
      flags = 0;
#ifndef _NO_POS_ARGS
      N = arg_index;
      is_pos_arg = 0;
#endif

      /*
       * switch on the format.  continue if done; break once format
       * type is derived.
       */

    again:
      c = *fmt++;

      switch (c)
	{
	case '%':
	literal:
          lptr = fmt - nbytes;
          for (n = 0; n < nbytes; ++n)
            {
	      if (BufferEmpty)
	        goto input_failure;
	      if (*fp->_p != *lptr)
	        goto match_failure;
	      fp->_r--, fp->_p++;
	      nread++;
              ++lptr;
            }
	  continue;

	case '*':
	  flags |= SUPPRESS;
	  goto again;
	case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
	  if (*fmt == 'l')	/* Check for 'll' = long long (SUSv3) */
	    {
	      ++fmt;
	      flags |= LONGDBL;
	    }
	  else
#endif
	    flags |= LONG;
	  goto again;
	case 'L':
	  flags |= LONGDBL;
	  goto again;
	case 'h':
#ifdef _WANT_IO_C99_FORMATS
	  if (*fmt == 'h')	/* Check for 'hh' = char int (SUSv3) */
	    {
	      ++fmt;
	      flags |= CHAR;
	    }
	  else
#endif
	    flags |= SHORT;
	  goto again;
#ifdef _WANT_IO_C99_FORMATS
	case 'j': /* intmax_t */
	  if (sizeof (intmax_t) == sizeof (long))
	    flags |= LONG;
	  else
	    flags |= LONGDBL;
	  goto again;
	case 't': /* ptrdiff_t */
	  if (sizeof (ptrdiff_t) < sizeof (int))
	    /* POSIX states ptrdiff_t is 16 or more bits, as
	       is short.  */
	    flags |= SHORT;
	  else if (sizeof (ptrdiff_t) == sizeof (int))
	    /* no flag needed */;
	  else if (sizeof (ptrdiff_t) <= sizeof (long))
	    flags |= LONG;
	  else
	    /* POSIX states that at least one programming
	       environment must support ptrdiff_t no wider than
	       long, but that means other environments can
	       have ptrdiff_t as wide as long long.  */
	    flags |= LONGDBL;
	  goto again;
	case 'z': /* size_t */
	  if (sizeof (size_t) < sizeof (int))
	    /* POSIX states size_t is 16 or more bits, as is short.  */
	    flags |= SHORT;
	  else if (sizeof (size_t) == sizeof (int))
	    /* no flag needed */;
	  else if (sizeof (size_t) <= sizeof (long))
	    flags |= LONG;
	  else
	    /* POSIX states that at least one programming
	       environment must support size_t no wider than
	       long, but that means other environments can
	       have size_t as wide as long long.  */
	    flags |= LONGDBL;
	  goto again;
#endif /* _WANT_IO_C99_FORMATS */

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  width = width * 10 + c - '0';
	  goto again;

#ifndef _NO_POS_ARGS
	case '$':
	  if (width <= MAX_POS_ARGS)
	    {
	      N = width - 1;
	      is_pos_arg = 1;
	      width = 0;
	      goto again;
	    }
	  rptr->_errno = EINVAL;
	  goto input_failure;
#endif /* !_NO_POS_ARGS */

	  /*
	   * Conversions. Those marked `compat' are for
	   * 4.[123]BSD compatibility.
	   *
	   * (According to ANSI, E and X formats are supposed to
	   * the same as e and x.  Sorry about that.)
	   */

	case 'D':		/* compat */
	  flags |= LONG;
	  /* FALLTHROUGH */
	case 'd':
	  c = CT_INT;
	  ccfn = (u_long (*)CCFN_PARAMS)_strtol_r;
	  base = 10;
	  break;

	case 'i':
	  c = CT_INT;
	  ccfn = (u_long (*)CCFN_PARAMS)_strtol_r;
	  base = 0;
	  break;

	case 'O':		/* compat */
	  flags |= LONG;
	  /* FALLTHROUGH */
	case 'o':
	  c = CT_INT;
	  ccfn = _strtoul_r;
	  base = 8;
	  break;

	case 'u':
	  c = CT_INT;
	  ccfn = _strtoul_r;
	  base = 10;
	  break;

	case 'X':
	case 'x':
	  flags |= PFXOK;	/* enable 0x prefixing */
	  c = CT_INT;
	  ccfn = _strtoul_r;
	  base = 16;
	  break;

#ifdef FLOATING_POINT
# ifdef _WANT_IO_C99_FORMATS
	case 'a':
	case 'A':
	case 'F':
# endif
	case 'E':
	case 'G':
	case 'e':
	case 'f':
	case 'g':
	  c = CT_FLOAT;
	  break;
#endif

#ifdef _WANT_IO_C99_FORMATS
	case 'S':
	  flags |= LONG;
	  /* FALLTHROUGH */
#endif

	case 's':
	  c = CT_STRING;
	  break;

	case '[':
	  fmt = (u_char *) __sccl (ccltab, (unsigned char *) fmt);
	  flags |= NOSKIP;
	  c = CT_CCL;
	  break;

#ifdef _WANT_IO_C99_FORMATS
	case 'C':
	  flags |= LONG;
	  /* FALLTHROUGH */
#endif

	case 'c':
	  flags |= NOSKIP;
	  c = CT_CHAR;
	  break;

	case 'p':		/* pointer format is like hex */
	  flags |= POINTER | PFXOK;
	  c = CT_INT;
	  ccfn = _strtoul_r;
	  base = 16;
	  break;

	case 'n':
	  if (flags & SUPPRESS)	/* ??? */
	    continue;
#ifdef _WANT_IO_C99_FORMATS
	  if (flags & CHAR)
	    {
	      cp = GET_ARG (N, ap, char *);
	      *cp = nread;
	    }
	  else
#endif
	  if (flags & SHORT)
	    {
	      sp = GET_ARG (N, ap, short *);
	      *sp = nread;
	    }
	  else if (flags & LONG)
	    {
	      lp = GET_ARG (N, ap, long *);
	      *lp = nread;
	    }
#ifndef _NO_LONGLONG
	  else if (flags & LONGDBL)
	    {
	      llp = GET_ARG (N, ap, long long*);
	      *llp = nread;
	    }
#endif
	  else
	    {
	      ip = GET_ARG (N, ap, int *);
	      *ip = nread;
	    }
	  continue;

	  /*
	   * Disgusting backwards compatibility hacks.	XXX
	   */
	case '\0':		/* compat */
	  _newlib_flockfile_exit (fp);
	  return EOF;

	default:		/* compat */
	  if (isupper (c))
	    flags |= LONG;
	  c = CT_INT;
	  ccfn = (u_long (*)CCFN_PARAMS)_strtol_r;
	  base = 10;
	  break;
	}

      /*
       * We have a conversion that requires input.
       */
      if (BufferEmpty)
	goto input_failure;

      /*
       * Consume leading white space, except for formats that
       * suppress this.
       */
      if ((flags & NOSKIP) == 0)
	{
	  while (isspace (*fp->_p))
	    {
	      nread++;
	      if (--fp->_r > 0)
		fp->_p++;
	      else
	      if (__srefill_r (rptr, fp))
		goto input_failure;
	    }
	  /*
	   * Note that there is at least one character in the
	   * buffer, so conversions that do not set NOSKIP ca
	   * no longer result in an input failure.
	   */
	}

      /*
       * Do the conversion.
       */
      switch (c)
	{

	case CT_CHAR:
	  /* scan arbitrary characters (sets NOSKIP) */
	  if (width == 0)
	    width = 1;
#if !defined(_ELIX_LEVEL) || _ELIX_LEVEL >= 2
          if (flags & LONG)
            {
              mbstate_t state;
              memset (&state, 0, sizeof (mbstate_t));
              if ((flags & SUPPRESS) == 0)
                wcp = GET_ARG (N, ap, wchar_t *);
              else
                wcp = NULL;
              n = 0;
              while (width != 0)
                {
                  if (n == MB_CUR_MAX)
                    goto input_failure;
                  buf[n++] = *fp->_p;
                  fp->_r -= 1;
                  fp->_p += 1;
                  if ((mbslen = _mbrtowc_r (rptr, wcp, buf, n, &state))
                                                         == (size_t)-1)
                    goto input_failure; /* Invalid sequence */
                  if (mbslen == 0 && !(flags & SUPPRESS))
                    *wcp = L'\0';
                  if (mbslen != (size_t)-2) /* Incomplete sequence */
                    {
                      nread += n;
                      width -= 1;
                      if (!(flags & SUPPRESS))
                        wcp += 1;
                      n = 0;
                    }
                  if (BufferEmpty)
	            {
                      if (n != 0)
                        goto input_failure;
                      break;
                    }
                }
              if (!(flags & SUPPRESS))
                nassigned++;
            }
          else
#endif
        	  if (flags & SUPPRESS)
	    {
	      size_t sum = 0;
	      for (;;)
		{
		  if ((n = fp->_r) < (int)width)
		    {
		      sum += n;
		      width -= n;
		      fp->_p += n;
		      if (__srefill_r (rptr, fp))
			{
			  if (sum == 0)
			    goto input_failure;
			  break;
			}
		    }
		  else
		    {
		      sum += width;
		      fp->_r -= width;
		      fp->_p += width;
		      break;
		    }
		}
	      nread += sum;
	    }
	  else
	    {
	      size_t r = _fread_r (rptr, (_PTR) GET_ARG (N, ap, char *), 1, width, fp);

	      if (r == 0)
		goto input_failure;
	      nread += r;
	      nassigned++;
	    }
	  break;

	case CT_CCL:
	  /* scan a (nonempty) character class (sets NOSKIP) */
	  if (width == 0)
	    width = ~0;		/* `infinity' */
	  /* take only those things in the class */
	  if (flags & SUPPRESS)
	    {
	      n = 0;
	      while (ccltab[*fp->_p])
		{
		  n++, fp->_r--, fp->_p++;
		  if (--width == 0)
		    break;
		  if (BufferEmpty)
		    {
		      if (n == 0)
			goto input_failure;
		      break;
		    }
		}
	      if (n == 0)
		goto match_failure;
	    }
	  else
	    {
	      p0 = p = GET_ARG (N, ap, char *);
	      while (ccltab[*fp->_p])
		{
		  fp->_r--;
		  *p++ = *fp->_p++;
		  if (--width == 0)
		    break;
		  if (BufferEmpty)
		    {
		      if (p == p0)
			goto input_failure;
		      break;
		    }
		}
	      n = p - p0;
	      if (n == 0)
		goto match_failure;
	      *p = 0;
	      nassigned++;
	    }
	  nread += n;
	  break;

	case CT_STRING:
	  /* like CCL, but zero-length string OK, & no NOSKIP */
	  if (width == 0)
            width = (size_t)~0;
#if !defined(_ELIX_LEVEL) || _ELIX_LEVEL >= 2
          if (flags & LONG)
            {
              /* Process %S and %ls placeholders */
              mbstate_t state;
              memset (&state, 0, sizeof (mbstate_t));
              if ((flags & SUPPRESS) == 0)
                wcp = GET_ARG (N, ap, wchar_t *);
              else
                wcp = &wc;
              n = 0;
              while (!isspace (*fp->_p) && width != 0)
                {
                  if (n == MB_CUR_MAX)
                    goto input_failure;
                  buf[n++] = *fp->_p;
                  fp->_r -= 1;
                  fp->_p += 1;
                  if ((mbslen = _mbrtowc_r (rptr, wcp, buf, n, &state))
                                                        == (size_t)-1)
                    goto input_failure;
                  if (mbslen == 0)
                    *wcp = L'\0';
                  if (mbslen != (size_t)-2) /* Incomplete sequence */
                    {
                      if (iswspace(*wcp))
                        {
                          while (n != 0)
                            _ungetc_r (rptr, (unsigned char) buf[--n], fp);
                          break;
                        }
                      nread += n;
                      width -= 1;
                      if ((flags & SUPPRESS) == 0)
                        wcp += 1;
                      n = 0;
                    }
                  if (BufferEmpty)
                    {
                      if (n != 0)
                        goto input_failure;
                      break;
                    }
                }
              if (!(flags & SUPPRESS))
                {
                  *wcp = L'\0';
                  nassigned++;
                }
            }
          else
#endif
        	  if (flags & SUPPRESS)
	    {
	      n = 0;
	      while (!isspace (*fp->_p))
		{
		  n++, fp->_r--, fp->_p++;
		  if (--width == 0)
		    break;
		  if (BufferEmpty)
		    break;
		}
	      nread += n;
	    }
	  else
	    {
	      p0 = p = GET_ARG (N, ap, char *);
	      while (!isspace (*fp->_p))
		{
		  fp->_r--;
		  *p++ = *fp->_p++;
		  if (--width == 0)
		    break;
		  if (BufferEmpty)
		    break;
		}
	      *p = 0;
	      nread += p - p0;
	      nassigned++;
	    }
	  continue;

	case CT_INT:
	{
	  /* scan an integer as if by strtol/strtoul */
	  unsigned width_left = 0;
	  int skips = 0;
#ifdef hardway
	  if (width == 0 || width > sizeof (buf) - 1)
#else
	  /* size_t is unsigned, hence this optimisation */
	  if (width - 1 > sizeof (buf) - 2)
#endif
	    {
	      width_left = width - (sizeof (buf) - 1);
	      width = sizeof (buf) - 1;
	    }
	  flags |= SIGNOK | NDIGITS | NZDIGITS | NNZDIGITS;
	  for (p = buf; width; width--)
	    {
	      c = *fp->_p;
	      /*
	       * Switch on the character; `goto ok' if we
	       * accept it as a part of number.
	       */
	      switch (c)
		{
		  /*
		   * The digit 0 is always legal, but is special.
		   * For %i conversions, if no digits (zero or nonzero)
		   * have been scanned (only signs), we will have base==0.
		   * In that case, we should set it to 8 and enable 0x
		   * prefixing. Also, if we have not scanned zero digits
		   * before this, do not turn off prefixing (someone else
		   * will turn it off if we have scanned any nonzero digits).
		   */
		case '0':
		  if (! (flags & NNZDIGITS))
		    goto ok;
		  if (base == 0)
		    {
		      base = 8;
		      flags |= PFXOK;
		    }
		  if (flags & NZDIGITS)
		    {
		      flags &= ~(SIGNOK | NZDIGITS | NDIGITS);
		      goto ok;
		    }
		  flags &= ~(SIGNOK | PFXOK | NDIGITS);
		  if (width_left)
		    {
		      width_left--;
		      width++;
		    }
		  ++skips;
		  goto skip;

		  /* 1 through 7 always legal */
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		  base = basefix[base];
		  flags &= ~(SIGNOK | PFXOK | NDIGITS | NNZDIGITS);
		  goto ok;

		  /* digits 8 and 9 ok iff decimal or hex */
		case '8':
		case '9':
		  base = basefix[base];
		  if (base <= 8)
		    break;	/* not legal here */
		  flags &= ~(SIGNOK | PFXOK | NDIGITS | NNZDIGITS);
		  goto ok;

		  /* letters ok iff hex */
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		  /* no need to fix base here */
		  if (base <= 10)
		    break;	/* not legal here */
		  flags &= ~(SIGNOK | PFXOK | NDIGITS | NNZDIGITS);
		  goto ok;

		  /* sign ok only as first character */
		case '+':
		case '-':
		  if (flags & SIGNOK)
		    {
		      flags &= ~SIGNOK;
		      goto ok;
		    }
		  break;

		  /* x ok iff flag still set & single 0 seen */
		case 'x':
		case 'X':
		  if ((flags & (PFXOK | NZDIGITS)) == PFXOK)
		    {
		      base = 16;/* if %i */
		      flags &= ~PFXOK;
		      /* We must reset the NZDIGITS and NDIGITS
			 flags that would have been unset by seeing
			 the zero that preceded the X or x.  */
		      flags |= NZDIGITS | NDIGITS;
		      goto ok;
		    }
		  break;
		}

	      /*
	       * If we got here, c is not a legal character
	       * for a number.  Stop accumulating digits.
	       */
	      break;
	    ok:
	      /*
	       * c is legal: store it and look at the next.
	       */
	      *p++ = c;
	    skip:
	      if (--fp->_r > 0)
		fp->_p++;
	      else
	      if (__srefill_r (rptr, fp))
		break;		/* EOF */
	    }
	  /*
	   * If we had only a sign, it is no good; push back the sign.
	   * If the number ends in `x', it was [sign] '0' 'x', so push back
	   * the x and treat it as [sign] '0'.
	   * Use of ungetc here and below assumes ASCII encoding; we are only
	   * pushing back 7-bit characters, so casting to unsigned char is
	   * not necessary.
	   */
	  if (flags & NDIGITS)
	    {
	      if (p > buf)
		_ungetc_r (rptr, *--p, fp); /* [-+xX] */
	      if (p == buf)
		goto match_failure;
	    }
	  if ((flags & SUPPRESS) == 0)
	    {
	      u_long res;

	      *p = 0;
	      res = (*ccfn) (rptr, buf, (char **) NULL, base);
	      if (flags & POINTER)
		{
		  void **vp = GET_ARG (N, ap, void **);
#ifndef _NO_LONGLONG
		  if (sizeof (uintptr_t) > sizeof (u_long))
		    {
		      u_long_long resll;
		      resll = _strtoull_r (rptr, buf, (char **) NULL, base);
		      *vp = (void *) (uintptr_t) resll;
		    }
		  else
#endif /* !_NO_LONGLONG */
		    *vp = (void *) (uintptr_t) res;
		}
#ifdef _WANT_IO_C99_FORMATS
	      else if (flags & CHAR)
		{
		  cp = GET_ARG (N, ap, char *);
		  *cp = res;
		}
#endif
	      else if (flags & SHORT)
		{
		  sp = GET_ARG (N, ap, short *);
		  *sp = res;
		}
	      else if (flags & LONG)
		{
		  lp = GET_ARG (N, ap, long *);
		  *lp = res;
		}
#ifndef _NO_LONGLONG
	      else if (flags & LONGDBL)
		{
		  u_long_long resll;
		  if (ccfn == _strtoul_r)
		    resll = _strtoull_r (rptr, buf, (char **) NULL, base);
		  else
		    resll = _strtoll_r (rptr, buf, (char **) NULL, base);
		  llp = GET_ARG (N, ap, long long*);
		  *llp = resll;
		}
#endif
	      else
		{
		  ip = GET_ARG (N, ap, int *);
		  *ip = res;
		}
	      nassigned++;
	    }
	  nread += p - buf + skips;
	  break;
	}
#ifdef FLOATING_POINT
	case CT_FLOAT:
	{
	  /* scan a floating point number as if by strtod */
	  /* This code used to assume that the number of digits is reasonable.
	     However, ANSI / ISO C makes no such stipulation; we have to get
	     exact results even when there is an unreasonable amount of
	     leading zeroes.  */
	  long leading_zeroes = 0;
	  long zeroes, exp_adjust;
	  char *exp_start = NULL;
	  unsigned width_left = 0;
	  char nancount = 0;
	  char infcount = 0;
	  const char *decpt = _localeconv_r (rptr)->decimal_point;
#ifdef _MB_CAPABLE
	  int decptpos = 0;
#endif
#ifdef hardway
	  if (width == 0 || width > sizeof (buf) - 1)
#else
	  /* size_t is unsigned, hence this optimisation */
	  if (width - 1 > sizeof (buf) - 2)
#endif
	    {
	      width_left = width - (sizeof (buf) - 1);
	      width = sizeof (buf) - 1;
	    }
	  flags |= SIGNOK | NDIGITS | DPTOK | EXPOK;
	  zeroes = 0;
	  exp_adjust = 0;
	  for (p = buf; width; )
	    {
	      c = *fp->_p;
	      /*
	       * This code mimicks the integer conversion
	       * code, but is much simpler.
	       */
	      switch (c)
		{
		case '0':
		  if (flags & NDIGITS)
		    {
		      flags &= ~SIGNOK;
		      zeroes++;
		      if (width_left)
			{
			  width_left--;
			  width++;
			}
		      goto fskip;
		    }
		  /* Fall through.  */
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		  if (nancount + infcount == 0)
		    {
		      flags &= ~(SIGNOK | NDIGITS);
		      goto fok;
		    }
		  break;

		case '+':
		case '-':
		  if (flags & SIGNOK)
		    {
		      flags &= ~SIGNOK;
		      goto fok;
		    }
		  break;
		case 'n':
		case 'N':
		  if (nancount == 0 && zeroes == 0
		      && (flags & (NDIGITS | DPTOK | EXPOK)) ==
				  (NDIGITS | DPTOK | EXPOK))
		    {
		      flags &= ~(SIGNOK | DPTOK | EXPOK | NDIGITS);
		      nancount = 1;
		      goto fok;
		    }
		  if (nancount == 2)
		    {
		      nancount = 3;
		      goto fok;
		    }
		  if (infcount == 1 || infcount == 4)
		    {
		      infcount++;
		      goto fok;
		    }
		  break;
		case 'a':
		case 'A':
		  if (nancount == 1)
		    {
		      nancount = 2;
		      goto fok;
		    }
		  break;
		case 'i':
		case 'I':
		  if (infcount == 0 && zeroes == 0
		      && (flags & (NDIGITS | DPTOK | EXPOK)) ==
				  (NDIGITS | DPTOK | EXPOK))
		    {
		      flags &= ~(SIGNOK | DPTOK | EXPOK | NDIGITS);
		      infcount = 1;
		      goto fok;
		    }
		  if (infcount == 3 || infcount == 5)
		    {
		      infcount++;
		      goto fok;
		    }
		  break;
		case 'f':
		case 'F':
		  if (infcount == 2)
		    {
		      infcount = 3;
		      goto fok;
		    }
		  break;
		case 't':
		case 'T':
		  if (infcount == 6)
		    {
		      infcount = 7;
		      goto fok;
		    }
		  break;
		case 'y':
		case 'Y':
		  if (infcount == 7)
		    {
		      infcount = 8;
		      goto fok;
		    }
		  break;
		case 'e':
		case 'E':
		  /* no exponent without some digits */
		  if ((flags & (NDIGITS | EXPOK)) == EXPOK
		      || ((flags & EXPOK) && zeroes))
		    {
		      if (! (flags & DPTOK))
			{
			  exp_adjust = zeroes - leading_zeroes;
			  exp_start = p;
			}
		      flags =
			(flags & ~(EXPOK | DPTOK)) |
			SIGNOK | NDIGITS;
		      zeroes = 0;
		      goto fok;
		    }
		  break;
		default:
#ifndef _MB_CAPABLE
		  if ((unsigned char) c == (unsigned char) decpt[0]
		      && (flags & DPTOK))
		    {
		      flags &= ~(SIGNOK | DPTOK);
		      leading_zeroes = zeroes;
		      goto fok;
		    }
		  break;
#else
		  if (flags & DPTOK)
		    {
		      while ((unsigned char) c
			     == (unsigned char) decpt[decptpos])
			{
			  if (decpt[++decptpos] == '\0')
			    {
			      /* We read the complete decpt seq. */
			      flags &= ~(SIGNOK | DPTOK);
			      leading_zeroes = zeroes;
			      p = stpncpy (p, decpt, decptpos);
			      decptpos = 0;
			      goto fskip;
			    }
			  ++nread;
			  if (--fp->_r > 0)
			    fp->_p++;
			  else if (__srefill_r (rptr, fp))
			    break;		/* EOF */
			  c = *fp->_p;
			}
		      if (decptpos > 0)
			{
			  /* We read part of a multibyte decimal point,
			     but the rest is invalid or we're at EOF,
			     so back off. */
			  while (decptpos-- > 0)
			    {
			      _ungetc_r (rptr, (unsigned char) decpt[decptpos],
					 fp);
			      --nread;
			    }
			}
		    }
		  break;
#endif
		}
	      break;
	    fok:
	      *p++ = c;
	    fskip:
	      width--;
	      ++nread;
	      if (--fp->_r > 0)
		fp->_p++;
	      else
	      if (__srefill_r (rptr, fp))
		break;		/* EOF */
	    }
	  if (zeroes)
	    flags &= ~NDIGITS;
	  /* We may have a 'N' or possibly even [sign] 'N' 'a' as the
	     start of 'NaN', only to run out of chars before it was
	     complete (or having encountered a non-matching char).  So
	     check here if we have an outstanding nancount, and if so
	     put back the chars we did swallow and treat as a failed
	     match.

	     FIXME - we still don't handle NAN([0xdigits]).  */
	  if (nancount - 1U < 2U) /* nancount && nancount < 3 */
	    {
	      /* Newlib's ungetc works even if we called __srefill in
		 the middle of a partial parse, but POSIX does not
		 guarantee that in all implementations of ungetc.  */
	      while (p > buf)
		{
		  _ungetc_r (rptr, *--p, fp); /* [-+nNaA] */
		  --nread;
		}
	      goto match_failure;
	    }
	  /* Likewise for 'inf' and 'infinity'.	 But be careful that
	     'infinite' consumes only 3 characters, leaving the stream
	     at the second 'i'.	 */
	  if (infcount - 1U < 7U) /* infcount && infcount < 8 */
	    {
	      if (infcount >= 3) /* valid 'inf', but short of 'infinity' */
		while (infcount-- > 3)
		  {
		    _ungetc_r (rptr, *--p, fp); /* [iInNtT] */
		    --nread;
		  }
	      else
		{
		  while (p > buf)
		    {
		      _ungetc_r (rptr, *--p, fp); /* [-+iInN] */
		      --nread;
		    }
		  goto match_failure;
		}
	    }
	  /*
	   * If no digits, might be missing exponent digits
	   * (just give back the exponent) or might be missing
	   * regular digits, but had sign and/or decimal point.
	   */
	  if (flags & NDIGITS)
	    {
	      if (flags & EXPOK)
		{
		  /* no digits at all */
		  while (p > buf)
		    {
		      _ungetc_r (rptr, *--p, fp); /* [-+.] */
		      --nread;
		    }
		  goto match_failure;
		}
	      /* just a bad exponent (e and maybe sign) */
	      c = *--p;
	      --nread;
	      if (c != 'e' && c != 'E')
		{
		  _ungetc_r (rptr, c, fp); /* [-+] */
		  c = *--p;
		  --nread;
		}
	      _ungetc_r (rptr, c, fp); /* [eE] */
	    }
	  if ((flags & SUPPRESS) == 0)
	    {
	      double res = 0;
#ifdef _NO_LONGDBL
#define QUAD_RES res;
#else  /* !_NO_LONG_DBL */
	      long double qres = 0;
#define QUAD_RES qres;
#endif /* !_NO_LONG_DBL */
	      long new_exp = 0;

	      *p = 0;
	      if ((flags & (DPTOK | EXPOK)) == EXPOK)
		{
		  exp_adjust = zeroes - leading_zeroes;
		  new_exp = -exp_adjust;
		  exp_start = p;
		}
	      else if (exp_adjust)
                new_exp = _strtol_r (rptr, (exp_start + 1), NULL, 10) - exp_adjust;
	      if (exp_adjust)
		{

		  /* If there might not be enough space for the new exponent,
		     truncate some trailing digits to make room.  */
		  if (exp_start >= buf + sizeof (buf) - MAX_LONG_LEN)
		    exp_start = buf + sizeof (buf) - MAX_LONG_LEN - 1;
                 sprintf (exp_start, "e%ld", new_exp);
		}

	      /* Current _strtold routine is markedly slower than
	         _strtod_r.  Only use it if we have a long double
	         result.  */
#ifndef _NO_LONGDBL /* !_NO_LONGDBL */
	      if (flags & LONGDBL)
		qres = _strtold (buf, NULL);
	      else
#endif
	        res = _strtod_r (rptr, buf, NULL);

	      if (flags & LONG)
		{
		  dp = GET_ARG (N, ap, double *);
		  *dp = res;
		}
	      else if (flags & LONGDBL)
		{
		  ldp = GET_ARG (N, ap, _LONG_DOUBLE *);
		  *ldp = QUAD_RES;
		}
	      else
		{
		  flp = GET_ARG (N, ap, float *);
		  if (isnan (res))
		    *flp = nanf (NULL);
		  else
		    *flp = res;
		}
	      nassigned++;
	    }
	  break;
	}
#endif /* FLOATING_POINT */
	}
    }
input_failure:
  /* On read failure, return EOF failure regardless of matches; errno
     should have been set prior to here.  On EOF failure (including
     invalid format string), return EOF if no matches yet, else number
     of matches made prior to failure.  */
  _newlib_flockfile_exit (fp);
  return nassigned && !(fp->_flags & __SERR) ? nassigned : EOF;
match_failure:
all_done:
  /* Return number of matches, which can be 0 on match failure.  */
  _newlib_flockfile_end (fp);
  return nassigned;
}

#ifndef _NO_POS_ARGS
/* Process all intermediate arguments.  Fortunately, with scanf, all
   intermediate arguments are sizeof(void*), so we don't need to scan
   ahead in the format string.  */
static void *
get_arg (int n, va_list *ap, int *numargs_p, void **args)
{
  int numargs = *numargs_p;
  while (n >= numargs)
    args[numargs++] = va_arg (*ap, void *);
  *numargs_p = numargs;
  return args[n];
}
#endif /* !_NO_POS_ARGS */
@


1.54
log
@
2013-04-29  Sebastian Huber <sebastian.huber@@embedded-brains.de>

	* libc/stdio/local.h (CHECK_INIT): Evaluate argument only once.
	(CHECK_STD_INIT): Likewise.
	* libc/stdio/fgetc.c (fgetc): Use local variable for _REENT.
	* libc/stdio/fgetwc.c (fwgetc): Likewise.
	* libc/stdio/fgetws.c (fgetws): Likewise.
	* libc/stdio/fputc.c (fputc): Likewise.
	* libc/stdio/fputwc.c (fputwc): Likewise.
	* libc/stdio/fputws.c (fputws): Likewise.
	* libc/stdio/getc.c (getc): Likewise.
	* libc/stdio/getchar.c (_getchar_r): Likewise.
	* libc/stdio/putc.c (putc): Likewise.
	* libc/stdio/putchar.c (putchar): Likewise.
	* libc/stdio/scanf.c (scanf): Likewise.
	* libc/stdio/setvbuf.c (setvbuf): Likewise.
	* libc/stdio/ungetwc.c (ungetwc): Likewise.
	* libc/stdio/vfscanf.c (VFSCANF): Likewise.
	* libc/stdio/vfwscanf.c (VFWSCANF): Likewise.
	* libc/stdio/viprintf.c (viprintf): Likewise.
	* libc/stdio/viscanf.c (viscanf): Likewise.
	* libc/stdio/vprintf.c (vprintf): Likewise.
	* libc/stdio/vscanf.c (vscanf): Likewise.
	* libc/stdio/vwprintf.c (vwprintf): Likewise.
	* libc/stdio/vwscanf.c (vwscanf): Likewise.
	* libc/stdio/wscanf.c (wscanf): Likewise.
	* libc/stdlib/ecvtbuf.c (fcvtbuf): Likewise.
	(fcvtbuf): Likewise.
	(ecvtbuf): Likewise.
	(ecvtbuf): Likewise.
	* libc/stdlib/mblen.c (mblen): Likewise.
	* libc/stdlib/mbrlen.c (mbrlen): Likewise.
	* libc/stdlib/mbrtowc.c (mbrtowc): Likewise.
	* libc/stdlib/mbtowc.c (mbtowc): Likewise.
	* libc/stdlib/rand.c (srand): Likewise.
	(rand): Likewise.
	* libc/stdlib/wcrtomb.c (wcrtomb): Likewise.
	* libc/stdlib/wctob.c (wctob): Likewise.
	* libc/stdlib/wctomb.c (wctomb): Likewise.
	* libc/string/strtok.c (strtok): Likewise.
	* libc/time/asctime.c (asctime): Likewise.
	* libc/time/gmtime.c (gmtime): Likewise.
	* libc/time/lcltime.c (lcltime): Likewise.
@
text
@d165 1
d178 1
a178 5
#if ((MAXEXP+MAXFRACT+3) > MB_LEN_MAX)
#  define BUF (MAXEXP+MAXFRACT+3)        /* 3 = sign + decimal point + NUL */
#else
#  define BUF MB_LEN_MAX
#endif
d1288 4
a1419 8
		case '.':
		  if (flags & DPTOK)
		    {
		      flags &= ~(SIGNOK | DPTOK);
		      leading_zeroes = zeroes;
		      goto fok;
		    }
		  break;
d1438 47
@


1.53
log
@	Throughout, run newlib with -Wall -Werror option and fix bugs and
	compiler warnings found this way.

	* libc/stdio/freopen.c (_freopen_r): Fix bug setting _flags.

	* libc/include/stdio.h (_rename): Define when building newlib.
	* libc/include/sys/signal.h (_kill): Ditto.
	* libc/include/sys/stat.h (_mkdir): Ditto.
	* libc/include/sys/time.h (_gettimeofday): Ditto.
	* libc/include/sys/times.h (_times): Ditto.
	* libc/include/sys/wait.h (_wait): Ditto.
	* libc/locale/lmessages.c (empty): Don't define for Cygwin.
	* libc/locale/lmonetary.c (cnv): Ditto.
	* libc/locale/nl_langinfo.c (nl_langinfo): Ditto for variable s.
	* libc/posix/collate.c: Throughout cast to avoid compiler warning.
	* libc/posix/engine.c (matcher): Initialize dp to avoid compiler
	warning.
	* libc/posix/glob.c: Disable on Cygwin.  Explain why.
	* libc/posix/regcomp.c: Fix "uninitialized" compiler warnings.
	(dissect): Deliberately silence gcc compiler warning.  Add comment to
	explain why.
	* libc/posix/wordexp.c (wordexp): Remove num_bytes variable since result
	is never used.
	* libc/posix/popen.c (popen): Ditto for variable last.
	* libc/reent/mkdirr.c: Include sys/stat.h.
	* libc/reent/renamer.c: Include stdio.h.
	* libc/search/hash.c:  Throughout use underscored variants of the stat
	function family.
	(init_hash): Add missing definition for the __USE_INTERNAL_STAT64 case.
	* libc/search/hash_bigkey.c (__big_insert): Add parenthesis to avoid
	compiler warning.
	* libc/search/hash_page.c (overflow_page): Initalize freep to NULL to
	avoid compiler warning.
	* libc/stdio/asiprintf.c (_asiprintf_r): Cast unsigned char * to char *
	to avoid compiler warning.
	(asiprintf): Ditto.
	* libc/stdio/asprintf.c (_asprintf_r): Ditto.
	(asprintf): Ditto.
	* libc/stdio/vasiprintf.c (_vasiprintf_r): Ditto.
	* libc/stdio/vasprintf.c (_vasprintf_r): Ditto.
	* libc/stdio/mktemp.c (_gettemp): Cast to unsigned char in call to
	isdigit to avoid compiler warning.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Initialize variables used for
	grouping to avoid compiler warning.  Only define and set nseps and
	nrepeats if they are really used.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R): Ditto.  Only define state if
	it is really used.
	* libc/stdio/vfscanf.c (u_char): Revert to be defined as unsigned char.
	(__SVFSCANF_R): Cast fmt in call to __mbtowc.
	* libc/stdlib/mbtowc_r.c (JIS_state_table): Disable when building
	Cygwin.
	(JIS_action_table): Ditto.
	* libc/stdlib/wctomb_r.c (__utf8_wctomb): Add parenthesis to avoid
	compiler warning.
	* libc/string/strcasestr.c: Deliberately silence gcc compiler warning.
	Add comment to explain why.
	* libc/time/strptime.c (strptime): Cast to unsigned char in calls to
	isspace to avoid compiler warning.
	* libm/math/e_atan2.c (__ieee754_atan2): Add parenthesis to avoid
	compiler warning.
	* libm/math/e_exp.c (__ieee754_exp): Initialize k to 0 to avoid
	compiler warning.  Drop setting it to 0 later.
	* libm/math/ef_exp.c (__ieee754_expf): Ditto.
	* libm/math/e_pow.c (__ieee754_pow): Add braces to avoid compiler
	warning.
	* libm/math/ef_pow.c (__ieee754_powf): Ditto.
	* libm/math/er_lgamma.c (__ieee754_lgamma_r): Initialize nadj to 0 to
	avoid compiler warning.
	* libm/math/erf_lgamma.c (__ieee754_lgammaf_r): Ditto.
	* libm/math/e_rem_pio2.c (__ieee754_rem_pio2): Ditto for variable z.
	* libm/common/sf_round.c (roundf): Remove signbit variable since result
	is never used.
@
text
@d269 4
a272 2
  CHECK_INIT(_REENT, fp);
  return __SVFSCANF_R (_REENT, fp, fmt, ap);
@


1.52
log
@	* libc/stdio/local.h (_newlib_flockfile_start): New macro to
	secure stream related critical section against thread cancellation.
	(_newlib_flockfile_exit): Ditto.
	(_newlib_sfp_lock_end): Ditto.
	(_newlib_sfp_lock_start): Ditto for the list of streams.
	(_newlib_sfp_lock_exit): Ditto.
	(_newlib_sfp_lock_end): Ditto.
	Use aforementioned macros in place of _flockfile/_funlockfile
	and __sfp_lock_acquire/__sfp_lock_release throughout the code.
	* libc/stdio/fclose.c: Explicitely disable and re-enable thread
	cancellation.  Explain why.
	* libc/stdio/freopen.c: Ditto.
	* libc/stdio64/freopen64.c: Ditto.
@
text
@a245 1
#if 0
a246 2
#endif
#define u_char char
d513 2
a514 2
      nbytes = __mbtowc (rptr, &wc, fmt, MB_CUR_MAX, __locale_charset (),
			 &state);
@


1.51
log
@2011-08-23  Ralf Corspius  <ralf.corsepius@@rtems.org>

	* libc/posix/regexec.c: Define "nope" only #ifndef NDEBUG.
	* libc/stdio/vfscanf.c: Define "state" only #ifdef _MB_CAPABLE.
	* libc/string/wcwidth.c: Include <wctypes.h> for "iswprint" and
	"iswcntrl".
@
text
@d151 6
a156 4
#undef _flockfile
#undef _funlockfile
#define _flockfile(x) {}
#define _funlockfile(x) {}
d501 1
a501 1
  _flockfile (fp);
d800 1
a800 1
	  _funlockfile (fp);
d1600 1
a1600 1
  _funlockfile (fp);
d1605 1
a1605 1
  _funlockfile (fp);
@


1.50
log
@	* libc/stdio/fclose.c: Only use sfp lock to guard non-atomic
	changes of flags and fp lock.
	* libc/stdio/freopen.c: Ditto.
	* libc/stdio/freopen64.c: Ditto.
	* libc/stdio/fgetc.c: Revert change from 2009-04-24, remove sfp locks
	which guard entire function to avoid potential deadlocks when using
	stdio functions in multiple thraeds.
	* libc/stdio/fgets.c: Ditto.
	* libc/stdio/fgetwc.c: Ditto.
	* libc/stdio/fgetws.c: Ditto.
	* libc/stdio/fread.c: Ditto.
	* libc/stdio/fseek.c: Ditto.
	* libc/stdio/getc.c: Ditto.
	* libc/stdio/getdelim.c: Ditto.
	* libc/stdio/gets.c: Ditto.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdio/vfwscanf.c: Ditto.

	* libc/stdio/fflush.c (_fflush_r): Split out core functionality into
	new function __sflush_r.  Just lock file and call __sflush_r from here.
	* libc/stdio/fwalk.c (_fwalk): Remove static helper function and move
	functionality back into main function. Don't walk a file with flags
	value of 1.  Add comment.
	(_fwalk_reent): Ditto.
	* libc/stdio/local.h (__sflush_r): Declare.
	* libc/stdio/refill.c (__srefill): Before calling fwalk, set flags
	value to 1 so this file pointer isn't walked.  Revert flags afterwards
	and call __sflush_r for this fp if necessary.  Add comments.
@
text
@d456 1
d458 1
@


1.49
log
@
2010-01-19  Andy Koppe  <andy.koppe@@gmail.com>

        * libc/stdio/vfscanf.c (__SVFSCANF_R): Fix handling of non-ASCII
        characters and allow invalid bytes in format string.
@
text
@a496 1
  __sfp_lock_acquire ();
a796 1
	  __sfp_lock_release ();
a1596 1
  __sfp_lock_release ();
a1601 1
  __sfp_lock_release ();
@


1.48
log
@	* libc/stdio/vfprintf.c: Include ../stdlib/local.h.  Replace call to
	_mbtowc_r with direct call to __mbtowc.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdlib/btowc.c: Include local.h.  Replace call to _mbtowc_r
	with direct call to __mbtowc.
	* libc/stdlib/mblen.c: Ditto.
	* libc/stdlib/mblen_r.c: Ditto.
	* libc/stdlib/mbrtowc.c: Ditto.
	* libc/stdlib/mbstowcs_r.c: Ditto.
	* libc/stdlib/mbtowc.c: Ditto.
	* libc/stdlib/wcrtomb.c: Include local.h.  Replace call to _wctomb_r
	with direct call to __wctomb.
	* libc/stdlib/wcsnrtombs.c: Ditto.
	(_wcsnrtombs_r): Ditto.
	* libc/stdlib/wcstombs_r.c: Ditto.
	* libc/stdlib/wctob.c: Ditto.
	* libc/stdlib/wctomb.c: Ditto.

	* libc/stdlib/mbrtowc.c (mbrtowc): Implement independently from
	_mbrtowc_r, unless PREFER_SIZE_OVER_SPEED or __OPTIMIZE_SIZE__ are
	defined.
	* libc/stdlib/wcrtomb.c (wcrtomb): Implement independently from
	_wcrtomb_r, unless PREFER_SIZE_OVER_SPEED or __OPTIMIZE_SIZE__ are
	defined.

	* libc/stdlib/mbtowc_r.c (__utf8_mbtowc): Drop unnecessary test for
	ch >= 0.
@
text
@d462 1
a462 1
  char *lptr;                   /* literal pointer */
d504 4
a512 1
      memset (&state, '\0', sizeof (state));
d515 5
d522 1
d851 2
a864 1
                  memset ((_PTR)&state, '\0', sizeof (mbstate_t));
d984 2
a997 1
                  memset ((_PTR)&state, '\0', sizeof (mbstate_t));
@


1.47
log
@	* libc/include/wchar.h (fwscanf, swscanf, vfwscanf, vswscanf, vwscanf,
	wscanf): Declare.
	(_fwscanf_r, _swscanf_r, _vfwscanf_r, _vswscanf_r, _vwscanf_r,
	_wscanf_r): Declare.
	* libc/stdio/Makefile.am: Add new wscanf files.
	* libc/stdio/Makefile.in: Regenerate.
	* libc/stdio/fwscanf.c: New file.
	* libc/stdio/local.h (__svfwscanf_r, __ssvfwscanf_r, __svfiwscanf_r,
	__ssvfiwscanf_r): Declare.
	* libc/stdio/stdio.tex: Add new documentation references.
	* libc/stdio/swscanf.c: New file.
	* libc/stdio/vfwscanf.c: New file.
	* libc/stdio/vswscanf.c: New file.
	* libc/stdio/vwscanf.c: New file.
	* libc/stdio/wscanf.c: New file.

	* libc/stdio/vfscanf.c (_sungetc_r): Make externaly available.  Only
	define if INTEGER_ONLY is defined.  Declare otherwise.
	(__ssrefill_r): Ditto.
	(_sfread_r): Ditto.

	Remove static eofread/eofread1 functions and use __seofread
	function instead, throughout.
	* libc/stdio/local.h (__seofread): Declare.
	* libc/stdio/stdio.c (__seofread): Define.

	* libc/stdio/fgetwc.c (__fgetwc): Fix compiler warning.
	* libc/stdio/fgetws.c (_fgetws_r): Ditto.
	* libc/stdio/fread.c (_fread_r): Ditto.
	* libc/stdio/vfprintf.c: Ditto.
	* libc/stdio/vswprintf.c: Ditto.
@
text
@d125 1
d510 2
a511 1
      nbytes = _mbtowc_r (rptr, &wc, fmt, MB_CUR_MAX, &state);
@


1.46
log
@
2009-01-28  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__SVFSCANF_R): Add additional check for
        inf and nan processing to not proceed if we have already collected
        zeroes.
@
text
@d296 1
a296 1
#ifdef STRING_ONLY
d300 1
a300 1
static int
d358 1
a358 1
static int
d384 1
a384 1
static size_t
d421 5
a425 1
#endif /* STRING_ONLY */
d724 1
a724 1
	  fmt = __sccl (ccltab, fmt);
@


1.45
log
@
2008-12-11  Craig Howland  <howland@@LGSInnovations.com>

        * libc/include/sys/lock.h:  Add void cast to avoid "statement has no
        effect" warnings from gcc.
        * libc/include/sys/stdio.h:  Ditto.
        * libc/include/sys/time.h:  Correct gettimeofday() prototype.
        * libc/stdlib/__exp10.c:  Add #include "std.h" for function prototype.
        * libc/stdlib/__ten_mu.c:  Ditto.
        * libc/stdlib/std.h:  Correct __exp10's ANSI prototype.
        * libc/stdlib/ldtoa.c:  Change eiisinf definition to ANSI form.  (Are
        already others in file without _ansi method, so did not bother.)
        * libc/stdlib/system.c:  Use _ansi forms for function prototypes and
        definitions.
        * libc/time/mktime.c:  Ditto.
        * libc/misc/__dprintf.c:  Ditto.
        * libc/include/stdio.h:  Add function prototypes for _fgetc_r,
        _fgetpos_r, _fsetpos_r, _freopen_r, _rewind_r, freopen64, _freopen64_r,
        _funopen_r, and _fopencookie_r.
        * libc/include/reent.h:  Add function prototype for _stat64_r, align
        _execve_r prototype with POSIX definition for execve.
        * libc/reent/execr.c:  Align function prototype with POSIX definition.
        * libc/stdio/asniprintf.c:  Add #include "local.h".
        * libc/stdio/vasniprintf.c:  Ditto.
        * libc/stdio/fread.c:  Remove unused variable newcount.
        * libc/stdio/local.h:  Add function prototype for __sccl.
        * libc/stdio/open_memstream.c:  Remove unused variable flags.
        * libc/stdio/vfscanf.c:  Proper prototyping for ccfn, remove prototype
        for __sccl since now in local.h.
        * libc/string/memcpy.c:  Add #include <string.h> (for real and for
        traditional synopsis), remove extraneous stddef.h and limits.h.
        * libc/syscalls/sysclose.c:  Add #include <unistd.h>.
        * libc/syscalls/sysfork.c:  Ditto.
        * libc/syscalls/sysgetpid.c:  Ditto.
        * libc/syscalls/sysexecve.c:  Add #include <unistd.h>, align function
        prototype with POSIX definition.
        * libc/syscalls/sysfstat.c:  Add #include <sys/stat.h>.
        * libc/syscalls/sysgettod.c:  Correct sys/times.h to sys/time.h.
        * libc/syscalls/syskill.c:  Add #include <signal.h>.
        * libc/syscalls/syslink.c:  Add #include <unistd.h>, fix prototype.
        * libc/syscalls/sysunlink.c:  Ditto.
        * libc/syscalls/sysstat.c:  Add #include <sys/stat.h>, fix prototype.
        * libc/syscalls/syswait.c:  Add #include <sys/wait.h>, fix prototype.
@
text
@d492 1
d783 1
d1334 1
a1334 1
		  if (nancount == 0
d1363 1
a1363 1
		  if (infcount == 0
d1582 1
d1588 1
@


1.44
log
@
2008-12-10  Corinna Vinschen  <corinna@@vinschen.de>

        Implement basic wide char stdio functionality, based on FreeBSD.
        * libc/include/stdio.h (__SORD): Define.
        (__SWID): Define.
        * libc/include/wchar.h: Add declarations for new wide char functions.
        (getwc): Define as macro.
        (getwchar): Ditto.
        (putwc): Ditto.
        (putwchar): Ditto.
        * libc/include/sys/reent.h (struct __sFILE): Add _mbstate member.
        (struct __sFILE64): Ditto.
        * libc/stdio/Makefile.am (ELIX_4_SOURCES): Add fgetwc.c, fgetws.c,
        fputwc.c, fputws.c, fwide.c, getwc.c, getwchar.c, putwc.c, putwchar.c
        and ungetwc.c.
        (CHEWOUT_FILES): Add fgetwc.def, fgetws.def, fputwc.def, fputws.def,
        fwide.def, getwc.def, getwchar.def, putwc.def, putwchar.def and
        ungetwc.def.
        Add header dependency rules for the new files.
        * libc/stdio/Makefile.in: Regenerate.
        * libc/stdio/fgetwc.c: New file, implementing fgetwc and _fgetwc_r.
        * libc/stdio/fgetws.c: New file, implementing fgetws and _fgetws_r.
        * libc/stdio/findfp.c (std): Initialize FILE's _mbstate member.
        (__sfmoreglue): Ditto.
        * libc/stdio/fputs.c (_fputs_r): Set stream orientation.
        * libc/stdio/fputwc.c: New file, implementing fputwc and _fputwc_r.
        * libc/stdio/fputws.c: New file, implementing fputws and _fputws_r.
        * libc/stdio/fread.c (_fread_r): Set stream orientation.
        * libc/stdio/freopen.c (_freopen_r): Reset stream orientation.  Reset
        _mbstate.
        * libc/stdio/fseek.c (_fseek_r): Reset _mbstate.
        * libc/stdio/fwide.c: New file, implementing fwide and _fwide_r.
        * libc/stdio/fwrite.c (_fwrite_r): Set stream orientation.
        * libc/stdio/getwc.c: New file, implementing getwc and _getwc_r.
        * libc/stdio/getwchar.c: New file, implementing getwchar and
        _getwchar_r.
        * libc/stdio/local.h (ORIENT): New macro.
        * libc/stdio/puts.c (_puts_r): Set stream orientation.
        * libc/stdio/putwc.c: New file, implementing putwc and _putwc_r.
        * libc/stdio/putwchar.c: New file, implementing putwchar and
        _putwchar_r.
        * libc/stdio/refill.c (__srefill_r): Set stream orientation.
        * libc/stdio/stdio.tex: Add documentation for new functions.
        * libc/stdio/ungetc.c (_ungetc_r): Set stream orientation.
        * libc/stdio/ungetwc.c: New file, implementing ungetwc and _ungetwc_r.
        * libc/stdio/vfscanf.c (__SVFSCANF_R): Set stream orientation.
        * libc/stdio/wbuf.c (__swbuf_r): Ditto.
@
text
@a252 2
/*static*/ u_char *__sccl ();

d453 2
a454 1
  u_long (*ccfn) () = 0;	/* conversion function (strtol/strtoul) */
d660 1
a660 1
	  ccfn = (u_long (*)())_strtol_r;
d666 1
a666 1
	  ccfn = (u_long (*)())_strtol_r;
d788 1
a788 1
	  ccfn = (u_long (*)())_strtol_r;
@


1.43
log
@	* libc/include/stdio.h (__SMOD): Remove definition of unused flag.
	* libc/include/sys/reent.h (struct __sFILE): Add _flags2 member.
	* libc/stdio/findfp.c (std): Initialize _flags2.
	(__sfp): Ditto.
	* libc/stdio/refill.c (__srefill_r): Drop resetting __SMOD flag.
	* libc/stdio/vfscanf.c (__ssrefill_r): Ditto.
	* libc/stdio/fseek.c (_fseek_r): Drop checking __SMOD flag.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Ditto.
@
text
@d495 2
@


1.42
log
@
2008-10-31  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/diprintf.c: Modify documentation so eclipse newlib
        libhover docs generate properly.
        * libc/stdio/dprintf.c: Ditto.
        * libc/stdio/fflush.c: Ditto.
        * libc/stdio/fopencookie.c: Ditto.
        * libc/stdio/fread.c: Ditto.
        * libc/stdio/fsetpos.c: Ditto.
        * libc/stdio/getc_u.c: Ditto.
        * libc/stdio/getchar_u.c: Ditto.
        * libc/stdio/putc_u.c: Ditto.
        * libc/stdio/putchar_u.c: Ditto.
        * libc/stdio/remove.c: Ditto.
        * libc/stdio/siprintf.c: Ditto.
        * libc/stdio/siscanf.c: Ditto.
        * libc/stdio/sprintf.c: Ditto.
        * libc/stdio/sscanf.c: Ditto.
        * libc/stdio/vfprintf.c: Ditto.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/viprintf.c: Ditto.
        * libc/stdio/viscanf.c: Ditto.
        * libc/stdlib/calloc.c: Ditto.
        * libc/stdlib/efgcvt.c: Ditto.
        * libc/stdlib/envlock.c: Ditto.
        * libc/time/asctime.c: Ditto.
        * libc/time/ctime.c: Ditto.
        * libc/time/gmtime.c: Ditto.
        * libc/time/lcltime.c: Ditto.
        * libc/time/tzset.c: Ditto.
        * libc/stdlib/envlock.h: Moved to libc/include.
@
text
@a381 1
  fp->_flags &= ~__SMOD;	/* buffer contents are again pristine */
@


1.41
log
@2008-10-15  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/stdio/vfscanf.c (__ssvfiscanf_r): Do not support %lc, %C, %ls or
	%S conversions when the EL/IX level is 1.
@
text
@d25 2
d29 2
d32 2
@


1.40
log
@
2008-04-14  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/Makefile.am: Build vfprintf.c and vfscanf.c with
        -DSTRING_ONLY defined with and without -DINTEGER_ONLY defined
        to build special versions for sprintf/sscanf family functions.
        * libc/stdio/Makefile.in: Regenerated.
        * libc/stdio/vfprintf.c[STRING_ONLY][INTEGER_ONLY](_VFPRINTF_R):
        Redefine to be _svfiprintf_r which is optimized to work with siprintf
        family of functions (i.e. no I/O) and does not support floating-point.
        [STRING_ONLY][!INTEGER_ONLY](_VFPRINTF_R): Redefine to be
        _svfprintf_r which is optimized to work with sprintf family of
        functions and not use I/O.
        [STRING_ONLY](__sprint_r): New string only version of static function.
        designed to work with sprintf family of functions.
        * libc/stdio/vfscanf.c[STRING_ONLY][INTEGER_ONLY](_SVFSCANF_R):
        Redefine to be _ssvfiscanf_r which is optimized to work with siscanf
        family of functions (i.e. no I/O) and no float-point support.
        [STRING_ONLY][!INTEGER_ONLY](_SVFSCANF_R): Redefine to be
        __ssvfscanf_r which is optimized to work with sscanf family of
        functions and does not require I/O functions.
        * libc/stdio/asprintf.c: Call _svfprintf_r instead of _vfprintf_r.
        * libc/stdio/snprintf.c: Ditto.
        * libc/stdio/sprintf.c: Ditto.
        * libc/stdio/vasnprintf.c: Ditto.
        * libc/stdio/vasprintf.c: Ditto.
        * libc/stdio/siprintf.c: Call _svfiprintf_r instead of _vfiprintf_r.
        * libc/stdio/sniprintf.c: Ditto.
        * libc/stdio/vasiprintf.c: Ditto.
        * libc/stdio/vsiprintf.c: Ditto.
        * libc/stdio/vsniprintf.c: Ditto.
        * libc/stdio/vsprintf.c: Ditto.
        * libc/stdio/local.h: Add prototypes for _svfprintf_r, _svfiprintf_r,
        _ssvfscanf_r, and _ssvfiscanf_r.
        * libc/stdio/sscanf.c: Call _ssvfscanf_r instead of _svfscanf_r.
        * libc/stdio/vsscanf.c: Ditto.
        * libc/stdio/siscanf.c: Call _ssvfiscanf_r instead of _svfiscanf_r.
        * libc/stdio/vsiscanf.c: Ditto.
@
text
@d36 1
a36 1
	int _vscanf_r(struct _reent *<[reent]>, const char *<[fmt]>, 
d38 1
a38 1
	int _vfscanf_r(struct _reent *<[reent]>, FILE *<[fp]>, const char *<[fmt]>, 
d54 1
a54 1
	
d70 1
a70 1
	
d79 3
a81 3
of <<scanf>>, <<fscanf>>, and <<sscanf>>.  They differ only in 
allowing their caller to pass the variable argument list as a 
<<va_list>> object (initialized by <<va_start>>) rather than 
d88 1
a88 1
fields which were not stored.  
d90 1
a90 1
If <<vscanf>> attempts to read at end-of-file, the return value 
d260 3
a262 3
_DEFUN(VFSCANF, (fp, fmt, ap), 
       register FILE *fp _AND 
       _CONST char *fmt _AND 
d282 3
a284 3
       struct _reent *data _AND 
       register FILE *fp   _AND 
       _CONST char *fmt    _AND 
d379 2
a380 2
} 
 
d489 1
a489 1
 
d825 2
a826 1
          if (flags & LONG) 
d833 1
a833 1
              while (width != 0) 
d841 1
a841 1
                  if ((mbslen = _mbrtowc_r (rptr, wcp, buf, n, &state)) 
d854 1
a854 1
                  if (BufferEmpty) 
d856 1
a856 1
                      if (n != 0) 
d863 4
a866 2
            } 
          else if (flags & SUPPRESS) 
d956 2
a957 1
          if (flags & LONG) 
d965 1
a965 1
              while (!isspace (*fp->_p) && width != 0) 
d973 1
a973 1
                  if ((mbslen = _mbrtowc_r (rptr, wcp, buf, n, &state)) 
d992 1
a992 1
                  if (BufferEmpty) 
d999 1
a999 1
              if (!(flags & SUPPRESS)) 
d1005 3
a1007 1
          else if (flags & SUPPRESS) 
d1533 1
a1533 1
	      /* Current _strtold routine is markedly slower than 
@


1.39
log
@Fix 'make info'.
* libc/stdio/stdio.tex: Add missing include.
* libc/stdio/vfprintf.c: Use expected node name.
* libc/stdio/vfscanf.c: Likewise.
* libc/stdio/sscanf.c: Likewise.
* libc/stdio/sprintf.c: Likewise.
* libc/stdio/siscanf.c: Likewise.
* libc/stdio/siprintf.c: Likewise.
* libc/stdio/fopencookie.c: Quote raw {}.
Reported by DJ Delorie.
@
text
@d124 5
a128 1
#define __SVFSCANF_R __svfiscanf_r
d133 5
a137 1
#define __SVFSCANF_R __svfscanf_r
d143 10
d255 2
d290 40
d331 88
d892 1
a892 1
	      size_t r = fread ((_PTR) GET_ARG (N, ap, char *), 1, width, fp);
@


1.38
log
@* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't truncate %p when
sizeof(void*) is 8 but sizeof(long) is 4.
* libc/stdio/vfscanf.c (__SVFSCANF_R): Likewise.  Fix %i scanning
of "-0x".  Support "-nan" and "inf" for %e.  Audit usage of ungetc
to fix reentrancy and bug on encoding error in multibyte locales.
Always return EOF on read error.
@
text
@d20 1
a20 1
<<vscanf>>, <<vfscanf>>, <<vsscanf>>---format argument list
d23 2
a26 2
	vfscanf
INDEX
@


1.37
log
@* libc/stdio/vfscanf.c (__SVFSCANF_R): Support scanf(%1$s).
Avoid warning when !FLOATING_POINT.
* libc/stdio/vfprintf.c (_VFPRINTF_R): Simplify _NO_POS_ARGS
slightly.
@
text
@d828 1
a828 1
                      if (iswspace(*wcp)) 
d831 1
a831 1
                            ungetc (buf[--n], fp);
d990 1
a990 1
		  /* x ok iff flag still set & 2nd char */
d993 1
a993 1
		  if (flags & PFXOK && p == buf + 1)
d998 1
a998 1
		         flags that would have been unset by seeing
d1027 3
d1034 3
a1036 8
		_CAST_VOID ungetc (*(u_char *)-- p, fp);
	      goto match_failure;
	    }
	  c = ((u_char *) p)[-1];
	  if (c == 'x' || c == 'X')
	    {
	      --p;
	      /*(void)*/ ungetc (c, fp);
d1045 13
a1057 1
		*(GET_ARG (N, ap, _PTR *)) = (_PTR) (unsigned _POINTER_INT) res;
d1109 2
a1110 1
	  int nancount = 0;
d1155 1
a1155 1
		  if (nancount == 0)
d1173 2
a1174 2
		      && (flags & (SIGNOK | NDIGITS | DPTOK | EXPOK)) ==
				  (SIGNOK | NDIGITS | DPTOK | EXPOK))
d1180 1
a1180 1
		  else if (nancount == 2)
d1185 5
d1199 40
d1271 1
a1271 1
              ++nread;
d1280 42
a1321 18
          /* We may have a 'N' or possibly even a 'Na' as the start of 'NaN', 
	     only to run out of chars before it was complete (or having 
	     encountered a non- matching char).  So check here if we have an 
	     outstanding nancount, and if so put back the chars we did 
	     swallow and treat as a failed match. */
          if (nancount && nancount != 3)
            {
              /* Ok... what are we supposed to do in the event that the
              __srefill call above was triggered in the middle of the partial
              'NaN' and so we can't put it all back? */
              while (nancount-- && (p > buf))
                {
                  ungetc (*(u_char *)--p, fp);
                  --nread;
                }
              goto match_failure;
            }
          /*
d1332 4
a1335 4
                    {
		      ungetc (*(u_char *)--p, fp);
                      --nread;
                    }
d1339 2
a1340 2
	      c = *(u_char *)-- p;
              --nread;
d1343 3
a1345 3
		  _CAST_VOID ungetc (c, fp);	/* sign */
		  c = *(u_char *)-- p;
                  --nread;
d1347 1
a1347 1
	      _CAST_VOID ungetc (c, fp);
d1415 4
d1420 1
a1420 1
  return nassigned ? nassigned : -1;
d1423 1
@


1.36
log
@* libc/stdio/vfprintf.c [_WANT_IO_LONG_LONG]: Allow non-gcc
compilers.
* libc/stdio/vfscanf.c: Likewise.
@
text
@a115 1
#ifdef _HAVE_STDC
d117 1
a117 3
#else
#include <varargs.h>
#endif
d169 12
d288 7
d310 1
d314 1
d324 16
d369 4
d480 13
d594 1
a594 1
	      cp = va_arg (ap, char *);
d601 1
a601 1
	      sp = va_arg (ap, short *);
d606 1
a606 1
	      lp = va_arg (ap, long *);
d612 1
a612 1
	      llp = va_arg (ap, long long*);
d618 1
a618 1
	      ip = va_arg (ap, int *);
d680 1
a680 1
                wcp = va_arg (ap, wchar_t *);
d744 1
a744 1
	      size_t r = fread ((_PTR) va_arg (ap, char *), 1, width, fp);
d778 1
a778 1
	      p0 = p = va_arg (ap, char *);
d809 1
a809 1
                wcp = va_arg (ap, wchar_t *);
d868 1
a868 1
	      p0 = p = va_arg (ap, char *);
d1047 1
a1047 1
		*(va_arg (ap, _PTR *)) = (_PTR) (unsigned _POINTER_INT) res;
d1051 1
a1051 1
		  cp = va_arg (ap, char *);
d1057 1
a1057 1
		  sp = va_arg (ap, short *);
d1062 1
a1062 1
		  lp = va_arg (ap, long *);
d1073 1
a1073 1
		  llp = va_arg (ap, long long*);
d1079 1
a1079 1
		  ip = va_arg (ap, int *);
d1311 1
a1311 1
		  dp = va_arg (ap, double *);
d1316 1
a1316 1
		  ldp = va_arg (ap, _LONG_DOUBLE *);
d1321 1
a1321 1
		  flp = va_arg (ap, float *);
d1342 15
@


1.35
log
@Minimize printf/scanf size on platforms that don't need C99.
* acconfig.h (_WANT_IO_C99_FORMATS): New macro.
* newlib.hin (_WANT_IO_C99_FORMATS): Likewise.
* configure.in (newlib-io-c99-formats): New configure option.
(_WANT_IO_C99_FORMATS): Define appropriately.
* configure.host (*-linux*, cygwin): Default c99-formats to yes.
* libc/stdio/vfprintf.c (_VFPRINTF_R) [!_WANT_IO_C99_FORMATS]:
Cripple ' flag; hh, z, j, t sizes; a, A, F, C, S specifiers.
* libc/stdio/vfscanf.c (_VFSCANF_R) [!_WANT_IO_C99_FORMATS]:
Likewise.
* configure: Regenerate.
@
text
@d167 2
a168 1
#if defined _WANT_IO_LONG_LONG && defined __GNUC__
@


1.34
log
@
2007-04-17  Brian Dessent  <brian@@dessent.net>

        * libc/stdio/sscanf.c: Update documentation comments.
        * libc/stdio/vfscanf.c (__SVFSCANF_R): Handle j, t, and z modifiers.
@
text
@d364 1
d371 1
d378 1
d385 1
d388 2
a389 1
        case 'j':               /* intmax_t */
d395 1
a395 1
        case 't':               /* ptrdiff_t */
d411 1
a411 1
        case 'z':               /* size_t */
d426 1
d479 1
a479 1
	case 'X':		/* compat   XXX */
d488 7
a494 4
	case 'E':		/* compat   XXX */
	case 'G':		/* compat   XXX */
/* ANSI says that E,G and X behave the same way as e,g,x */
	  /* FALLTHROUGH */
d501 6
a506 3
        case 'S':
          flags |= LONG;
          /* FALLTHROUGH */
d518 5
a522 3
        case 'C':
          flags |= LONG;
          /* FALLTHROUGH */
d539 1
d545 3
a547 1
	  else if (flags & SHORT)
d996 1
d1002 1
d1109 1
a1109 1
	          if (nancount == 0
d1111 1
a1111 1
		      	          (SIGNOK | NDIGITS | DPTOK | EXPOK))
d1252 1
a1252 1
	      	qres = _strtold (buf, NULL);
@


1.33
log
@
2006-09-26  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdio.h[_REENT_SMALL]: Do not allow macros
        for clearerr, feof, or fileno.
        * libc/include/sys/reent.h[_REENT_SMALL](struct _reent): Change
        the dummy std stream scheme to use pointers to const external
        fake files, one for each standard stream.
        * libc/stdio/local.h (CHECK_INIT): Change to take a file pointer
        argument.  For _REENT_SMALL, reset the file pointer if it
        matches one of the fake std stream pointers.
        * libc/stdio/clearerr.c: Fix CHECK_INIT macro to add file pointer
        argument.
        * libc/stdio/fclose.c: Ditto.
        * libc/stdio/feof.c: Ditto.
        * libc/stdio/ferror.c: Ditto.
        * libc/stdio/fflush.c: Ditto.
        * libc/stdio/fgetc.c: Ditto.
        * libc/stdio/fgets.c: Ditto.
        * libc/stdio/fileno.c: Ditto.
        * libc/stdio/findfp.c: Ditto.
        * libc/stdio/fputc.c: Ditto.
        * libc/stdio/fputs.c: Ditto.
        * libc/stdio/fread.c: Ditto.
        * libc/stdio/freopen.c: Ditto.
        * libc/stdio/fseek.c: Ditto.
        * libc/stdio/ftell.c: Ditto.
        * libc/stdio/fwrite.c: Ditto.
        * libc/stdio/getc.c: Ditto.
        * libc/stdio/getdelim.c: Ditto.
        * libc/stdio/putc.c: Ditto.
        * libc/stdio/refill.c: Ditto.
        * libc/stdio/setvbuf.c: Ditto.
        * libc/stdio/ungetc.c: Ditto.
        * libc/stdio/vfprintf.c: Ditto.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/wbuf.c: Ditto.: Ditto.
        * libc/stdio/wsetup.c: Ditto.
        * libc/stdio64/freopen64.c: Ditto.
        * libc/stdio64/fseeko64.c: Ditto.
        * libc/stdio64/ftello64.c: Ditto.
        * libc/machine/powerpc/vfprintf.c: Ditto.
        * libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@d112 1
d384 37
@


1.32
log
@
2006-06-14  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdio.h: Add new reentrant I/O prototypes for
        read/write functions.  Change getc/putc macros to have reentrant underlying
        macros/functions.  This includes __sgetc_raw_r, __sgetc_r, and __sputc_r.
        * libc/stdio/fgetc.c: Fix and/or add reentrant version to call
        new reentrant I/O functions/macros for reading/writing.
        * libc/stdio/fgets.c: Ditto.
        * libc/stdio/fputc.c: Ditto.
        * libc/stdio/fputs.c: Ditto.
        * libc/stdio/fread.c: Ditto.
        * libc/stdio/fseek.c: Ditto.
        * libc/stdio64/fseeko64.c: Ditto.
        * libc/stdio/fwrite.c: Ditto.
        * libc/stdio/getc.c: Ditto.
        * libc/stdio/getc_u.c: Ditto.
        * libc/stdio/getchar.c: Ditto.
        * libc/stdio/getchar_u.c: Ditto.
        * libc/stdio/putc.c: Ditto.
        * libc/stdio/putc_u.c: Ditto.
        * libc/stdio/putchar.c: Ditto.
        * libc/stdio/puts.c: Ditto.
        * libc/stdio/vfprintf.c: Ditto.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/fvwrite.c: Change __sfvwrite into reentrant __sfvwrite_r.
        Change all previous callers of __sfvwrite.  Set errno to EBADF and
        set error flag on if attempt is made to write to file that does not
        allow writing.
        * libc/stdio/fvwrite.h: Fix new reentrant prototypes.
        * libc/stdio/local.h: Ditto.
        * libc/stdio/refill.c: Turn __srefill into reentrant __srefill_r.
        Set errno to EBADF and the error flag on if attempt is made to
        read unreadable file.  Change all previous callers of __srefill.
        * libc/stdio/rget.c
        * libc/stdio/wbuf.c: Turn __swbuf into reentrant __swbuf_r.  Change
        all previous callers of __swbuf.
        * libc/sys/linux/machine/i386/huge_val.h: Ifdef out file contents since
        huge value macros are already defined correctly for i386 by <math.h>.
@
text
@d234 1
a234 1
  CHECK_INIT(_REENT);
d256 1
a256 1
  CHECK_INIT(data);
@


1.32.2.1
log
@2007-10-23  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/stdlib/wcstombs_r.c: Add SUSV2 support for calculating
	size if output buffer is NULL.

2007-10-13  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R) [__OPTIMIZE_SIZE__]:
	Correctly nest else within conditionals.
	Reported by Artur Lipowski.

2007-09-17  Eric Blake  <ebb9@@byu.net>

	Obey POSIX on printf("%.s", (char*)NULL).
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Take precision into account
	for %s on NULL.  Skip NULL check when optimizing for size.

2007-07-31  Eric Blake  <ebb9@@byu.net>

	More POSIX stream corner cases.
	* libc/stdio/findfp.c (__sinit): Open stderr read/write.
	* libc/stdio/fdopen.c (_fdopen_r): Set O_APPEND on fd when
	requested.
	* libc/stdio64/fdopen64.c (_fdopen64_r): Likewise.

2007-07-13  Eric Blake  <ebb9@@byu.net>

	Fix fflush issues.
	* libc/stdio/fflush.c (_fflush_r): New function.
	(fflush): Fix reentrancy and large offset behavior.
	* libc/include/stdio.h (_fflush_r): Add prototype.
	* libc/stdio/fclose.c (_fclose_r): All fflush callers changed.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/fseek.c (_fseek_r): Likewise.
	* libc/stdio/ftell.c (_ftell_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Likewise.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/setvbuf.c (setvbuf): Likewise.
	* libc/stdio/ungetc.c (_ungetc_r): Likewise.
	* libc/stdio/vfprintf.c (__sbprintf): Likewise.
	* libc/stdio/wbuf.c (__swbuf_r): Likewise.
	* libc/stdio64/freopen64.c (_freopen64_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.  Defer to
	32-bit version if not large file.
	* libc/stdio64/ftello64.c (_ftello64_r): Likewise.
	* libc/stdio64/tmpfile64.c (_tmpfile64_r): Avoid compile warning.

2007-06-04  Eric Blake  <ebb9@@byu.net>

	* libc/include/sys/reent.h (struct __sFILE, struct __sFILE64):
	Switch to reentrant callbacks.
	* libc/stdio/local.h (__sread, __swrite, __sseek, __sclose)
	(__sseek64, __swrite64): Fix prototypes.
	[__SCLE]: Pull in setmode declaration.
	* libc/stdio/stdio.c (__sread, __swrite, __sseek, __sclose): Fix
	reentrancy.
	* libc/stdio64/stdio64.c (__sseek64_r, __swrite64_r): Delete.
	(__sseek64, __swrite64): Fix reentrancy.
	* libc/stdio/fseek.c (_fseek_r): Account for overflow, and fix
	reentrancy.
	* libc/stdio/ftell.c (_ftell_r): Likewise.
	* libc/stdio/flags.c (__sflags): Don't lose __SAPP on "a+".
	* libc/stdio/fclose.c (_fclose_r): Fix reentrancy.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Likewise.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/siscanf.c (eofread): Likewise.
	* libc/stdio/sscanf.c (eofread): Likewise.
	* libc/stdio/vsiscanf.c (eofread1): Likewise.
	* libc/stdio/vsscanf.c (eofread1): Likewise.
	* libc/stdio64/freopen64.c (_freopen64_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.
	* libc/stdio64/ftello64.c (_ftello64_r): Likewise.
	* libc/stdio/fflush.c (fflush): Improve reentrancy, although more
	could be fixed.

2007-05-29  Eric Blake  <ebb9@@byu.net>

	Avoid more compiler warnings.
	* libc/stdlib/btowc.c: Add missing header.
	* libc/stdlib/getopt.c (getopt_internal): Initialize variable.
	* libc/stdlib/system.c (do_system) [__CYGWIN__]: Add declaration.
	* libc/stdlib/wctob.c: Add missing header.
	* libc/string/strcpy.c (strcpy): Avoid warnings.
	* libc/string/strrchr.c (strrchr): Likewise.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/argz/argz_add_sep.c (argz_add_sep): Handle empty string
	argument.
	* libc/argz/argz_append.c (argz_append): Handle empty buf argument.
	* libc/argz/argz_create_sep.c (argz_create_sep): Return (NULL, 0)
	on empty input strings.
	* libc/argz/argz_extract.c (argz_extract): Check argz_len before
	looping through argz.
	* libc/argz/argz_stringify.c (argz_stringify): Ditto.

2007-05-27  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Populate 'ox' when
	handling %p.

2007-05-25  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/rewind.c (rewind): Fix regression of 2003-08-22.

2007-05-23  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't truncate %p when
	sizeof(void*) is 8 but sizeof(long) is 4.
	* libc/stdio/vfscanf.c (__SVFSCANF_R): Likewise.  Fix %i scanning
	of "-0x".  Support "-nan" and "inf" for %e.  Audit usage of ungetc
	to fix reentrancy and bug on encoding error in multibyte locales.
	Always return EOF on read error.

2007-05-23  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfscanf.c (__SVFSCANF_R): Support scanf(%1$s).
	Avoid warning when !FLOATING_POINT.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Simplify _NO_POS_ARGS
	slightly.

2007-05-23  Corinna Vinschen  <vinschen@@redhat.com>

	* libc/argz/argz_create_sep.c (argz_create_sep): Initialize *argz_len
	to zero.
	* libc/include/argz.h: Guard against multiple inclusion.  Guard for
	use with C++.

2007-05-17  Charles Wilson  <cygwin@@...>

	* stdio/tmpfile.c: Include <sys/stat.h>.
	* stdio64/tmpfile64.c: Ditto.

2007-05-16  Eric Blake  <ebb9@@byu.net>

	Close security hole in tmpfile.
	* libc/stdio/tmpfile.c (_tmpfile_r): Avoid window between filename
	generation and opening the fd.
	* libc/stdio64/tmpfile64.c (_tmpfile64_r): Likewise.

	* libc/include/math.h (INFINITY, NAN, FP_ILOGB0, FP_ILOGBNAN)
	(MATH_ERRNO, MATH_ERREXCEPT, math_errhandling): Add macros
	required by POSIX.
	* libc/stdlib/ldtoa.c (USE_INFINITY): Rename from INFINITY, to
	avoid clash with <math.h>.

	* libc/stdlib/wctomb_r.c (_wctomb_r): Avoid gcc warnings on cygwin.
	* libc/search/hash.c (__hash_open): Likewise.

2007-05-10  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Fix use of decimal point
	in %f and %e.  Avoid malloc when possible for %S.
	(BUF): Improve stack locality by using smaller size.
	(MAXEXP): Define.
	(exponent): Use for smaller stack size.

2007-05-01  Eric Blake  <ebb9@@byu.net>

	* libc/stdio64/local64.h: Delete, move contents to...
	* libc/stdio/local.h: ...here.
	* libc/stdio64/fdopen64.c: Update includes.
	* libc/stdio64/fopen64.c: Likewise.
	* libc/stdio64/freopen64.c: Likewise.
	* libc/stdio64/fseeko64.c: Likewise.
	* libc/stdio64/ftello64.c: Likewise.
	* libc/stdio/findfp.c (std) [__LARGE64_FILES]: Open stdin, stdout,
	and stderr with 64-bit offset.
	* libc/stdio/fseek.c (_fseek_r): Avoid compile warning.
	* libc/stdio/makebuf.c (__smakebuf_r): Likewise.
	* libc/stdio/mktemp.c (_gettemp): Likewise.

2007-04-25  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (get_arg): Support %1$lc.  Simplify types
	that promote to int.

2007-04-24  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't zero pad on infinity
	or NaN with %05f.

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Avoid multibyte when not
	_MB_CAPABLE.

	* libc/include/limits.h (NL_ARGMAX): Define a default value.
	* libc/stdio/vfprintf.c (MAX_POS_ARGS): Define in terms of
	NL_ARGMAX, if present.

2007-04-23  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/vfprintf.c (_vfprintf_r): When the alternate-form flag
	has been specified with types 'f', 'F', 'g', or 'G', ensure the
	trailing decimal is printed.

2007-04-17  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/sscanf.c: Update documentation comments.
	* libc/stdio/vfscanf.c (__SVFSCANF_R): Handle j, t, and z modifiers.

2007-04-12  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_F, cvt): Don't confuse %F with %e.
	(chclass): Recognize 'F', 'X', 'n', and not 'W'.
	(get_arg): Handle %1$F, %1$n.

2007-04-10  Eric Blake  <ebb9@@byu.net>

	* libc/include/stdio.h (_ELIDABLE_INLINE): Work even when using
	CFLAGS=-O0.

2007-04-09  Eric Blake  <ebb9@@byu.net>

	* libc/include/stdio.h: Add gcc format attributes to printf and
	scanf families.

2007-04-04  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/argz/argz_insert.c: Add stddef.h to get ptrdiff_t type.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/asiprintf.c (_asiprintf_r): Fix reentrancy.
	(asiprintf): Avoid overhead.
	* libc/stdio/asprintf.c (_asprintf_r): Fix reentrancy.
	(asprintf): Avoid overhead.
	* libc/stdio/diprintf.c (_diprintf_r, diprintf): New file.
	* libc/stdio/dprintf.c (_dprintf_r, dprintf): Use _DEFUN.
	* libc/stdio/fiprintf.c (_fiprintf_r): Add reentrant version.
	(fiprintf): Avoid overhead.
	* libc/stdio/fprintf.c (_fprintf_r): Add reentrant version.
	(fprintf): Avoid overhead.
	* libc/stdio/iprintf.c (_iprintf_r): Use _DEFUN.
	(iprintf): Avoid overhead.
	* libc/stdio/printf.c (_printf_r): Use _DEFUN.
	(printf): Avoid overhead.
	* libc/stdio/vasiprintf.c (vasiprintf): Reduce binary size.
	* libc/stdio/vasprintf.c (vasprintf): Reduce binary size.
	* libc/stdio/vdiprintf.c (_vdiprintf_r, vdiprintf): New file.
	* libc/stdio/vdprintf.c (vdprintf): Avoid overhead.
	* libc/stdio/vsiprintf.c (vsiprintf): Reduce binary size.
	* libc/stdio/vsniprintf.c (vsniprintf): Reduce binary size.
	* libc/stdio/vsnprintf.c (vsnprintf): Reduce binary size.
	* libc/stdio/vsprintf.c (vsprintf): Reduce binary size.
	* libc/stdio/Makefile.am (GENERAL_SOURCES): Add diprintf.c,
	vdiprintf.c.
	* libc/include/stdio.h (diprintf, _diprintf_r, vdiprintf)
	(_vdiprintf_r, _fiprintf_r, _vfiprintf_r): Add prototypes.

2007-03-30  Dave Korn  <dave.korn@@artimi.com>

	* libc/include/stdio.h (_ELIDABLE_INLINE):  New macro to conceal
	conflicting inline semantics between C99 and GNU89.
	(__sgetc_r):  Replace static inline with _ELIDABLE_INLINE to be
	compatible with -fkeep-inline-functions usage.
	(__sputc_r):  Likewise for consistency even though disabled.

2007-03-16  Charles Wilson  <cygwin@@...>

	* libc/argz/argz_insert.c: "before" pointer is
	invalid after *argz realloc.  Compute offset
	between "before" and *argz, and use it after
	reallocation instead.

2007-03-16  Eric Blake  <ebb9@@byu.net>

	* libc/stdio64/fseek064.c (_fseeko64_r): Fix reentrancy.
	* libc/stdio64/freopen64.c (_freopen64_r): Ditto.

2007-03-15  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/local.h (cantwrite, FREEUB, FREELB): Make reentrant.
	(__smakebuf): Rename...
	(__smakebuf_r): to this.
	* libc/stdio/fvwrite.h (__swsetup_r): Rename, from __swsetup.
	* libc/stdio/makebuf.c (__smakebuf): Detect failed asprint
	allocation, then rename...
	(__smakebuf_r): ...to this and fix reentrancy.
	* libc/stdio/wsetup.c (__swsetup): Detect failed asprintf
	allocation, then rename...
	(__swsetup_r): ...to this and fix reentrancy.
	* libc/stdio/fseek.c (_fseek_r): Fix reentrancy.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/fclose.c (_fclose_r): Likewise.
	* libc/stdio/fread.c (_fread_r): Likewise.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/wbuf.c (__swbuf_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Set errno properly on
	failed asprintf allocation, and fix reentrancy.
	* libc/stdio/snprintf.c (snprintf, _snprintf_r): Report overflow,
	as required by POSIX.
	* libc/stdio/sniprintf.c (sniprintf, _sniprintf_r): Likewise.
	* libc/stdio/vsnprintf.c (vsnprintf, _vsnprintf_r): Likewise.
	* libc/stdio/vsniprintf.c (vsniprintf, _vsniprintf_r): Likewise.

2007-03-12  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/fvwrite.c (__sfvwrite_r): Fix reentrancy.
	* libc/stdio/vasprintf.c (vasprintf, _vasprintf_r): Pass failed
	allocation to caller.
	* libc/stdio/asprintf.c (_asprintf_r, asprintf): Likewise.
	* libc/stdio/asiprintf.c (_asiprintf_r, asiprintf): Likewise.
	* libc/stdio/vasiprintf.c (vasiprintf, _vasiprintf_r): Likewise.

2007-02-20  Kazunori Asayama <asayama@@sm.sony.co.jp>

	* libc/include/stdio.h: Add declaration for vsiprintf.
@
text
@a111 1
#include <stdint.h>
d115 1
d117 3
a119 1
#include <errno.h>
a169 12
#define _NO_POS_ARGS
#ifdef _WANT_IO_POS_ARGS
# undef _NO_POS_ARGS
# ifdef NL_ARGMAX
#  define MAX_POS_ARGS NL_ARGMAX
# else
#  define MAX_POS_ARGS 32
# endif

static void * get_arg (int, va_list *, int *, void **);
#endif /* _WANT_IO_POS_ARGS */

a276 7
#ifndef _NO_POS_ARGS
  int N;			/* arg number */
  int arg_index = 0;		/* index into args processed directly */
  int numargs = 0;		/* number of varargs read */
  void *args[MAX_POS_ARGS];	/* positional args read */
  int is_pos_arg;		/* is current format positional? */
#endif
a291 1
#ifdef FLOATING_POINT
a294 1
#endif
a303 16
  /* Macro to support positional arguments */
#ifndef _NO_POS_ARGS
# define GET_ARG(n, ap, type)					\
  ((type) (is_pos_arg						\
	   ? (n < numargs					\
	      ? args[n]						\
	      : get_arg (n, &ap, &numargs, args))		\
	   : (arg_index++ < numargs				\
	      ? args[n]						\
	      : (numargs < MAX_POS_ARGS				\
		 ? args[numargs++] = va_arg (ap, void *)	\
		 : va_arg (ap, void *)))))
#else
# define GET_ARG(n, ap, type) (va_arg (ap, type))
#endif

a332 4
#ifndef _NO_POS_ARGS
      N = arg_index;
      is_pos_arg = 0;
#endif
a382 37
        case 'j':               /* intmax_t */
	  if (sizeof (intmax_t) == sizeof (long))
	    flags |= LONG;
	  else
	    flags |= LONGDBL;
	  goto again;
        case 't':               /* ptrdiff_t */
	  if (sizeof (ptrdiff_t) < sizeof (int))
	    /* POSIX states ptrdiff_t is 16 or more bits, as
	       is short.  */
	    flags |= SHORT;
	  else if (sizeof (ptrdiff_t) == sizeof (int))
	    /* no flag needed */;
	  else if (sizeof (ptrdiff_t) <= sizeof (long))
	    flags |= LONG;
	  else
	    /* POSIX states that at least one programming
	       environment must support ptrdiff_t no wider than
	       long, but that means other environments can
	       have ptrdiff_t as wide as long long.  */
	    flags |= LONGDBL;
	  goto again;
        case 'z':               /* size_t */
	  if (sizeof (size_t) < sizeof (int))
	    /* POSIX states size_t is 16 or more bits, as is short.  */
	    flags |= SHORT;
	  else if (sizeof (size_t) == sizeof (int))
	    /* no flag needed */;
	  else if (sizeof (size_t) <= sizeof (long))
	    flags |= LONG;
	  else
	    /* POSIX states that at least one programming
	       environment must support size_t no wider than
	       long, but that means other environments can
	       have size_t as wide as long long.  */
	    flags |= LONGDBL;
	  goto again;
a396 13
#ifndef _NO_POS_ARGS
	case '$':
	  if (width <= MAX_POS_ARGS)
	    {
	      N = width - 1;
	      is_pos_arg = 1;
	      width = 0;
	      goto again;
	    }
	  rptr->_errno = EINVAL;
	  goto input_failure;
#endif /* !_NO_POS_ARGS */

d489 1
a489 1
	      cp = GET_ARG (N, ap, char *);
d494 1
a494 1
	      sp = GET_ARG (N, ap, short *);
d499 1
a499 1
	      lp = GET_ARG (N, ap, long *);
d505 1
a505 1
	      llp = GET_ARG (N, ap, long long*);
d511 1
a511 1
	      ip = GET_ARG (N, ap, int *);
d573 1
a573 1
                wcp = GET_ARG (N, ap, wchar_t *);
d637 1
a637 1
	      size_t r = fread ((_PTR) GET_ARG (N, ap, char *), 1, width, fp);
d671 1
a671 1
	      p0 = p = GET_ARG (N, ap, char *);
d702 1
a702 1
                wcp = GET_ARG (N, ap, wchar_t *);
d721 1
a721 1
                      if (iswspace(*wcp))
d724 1
a724 1
                            _ungetc_r (rptr, (unsigned char) buf[--n], fp);
d761 1
a761 1
	      p0 = p = GET_ARG (N, ap, char *);
d883 1
a883 1
		  /* x ok iff flag still set & single 0 seen */
d886 1
a886 1
		  if ((flags & (PFXOK | NZDIGITS)) == PFXOK)
d891 1
a891 1
			 flags that would have been unset by seeing
a919 3
	   * Use of ungetc here and below assumes ASCII encoding; we are only
	   * pushing back 7-bit characters, so casting to unsigned char is
	   * not necessary.
d924 8
a931 3
		_ungetc_r (rptr, *--p, fp); /* [-+xX] */
	      if (p == buf)
		goto match_failure;
d940 1
a940 13
		{
		  void **vp = GET_ARG (N, ap, void **);
#ifndef _NO_LONGLONG
		  if (sizeof (uintptr_t) > sizeof (u_long))
		    {
		      u_long_long resll;
		      resll = _strtoull_r (rptr, buf, (char **) NULL, base);
		      *vp = (void *) (uintptr_t) resll;
		    }
		  else
#endif /* !_NO_LONGLONG */
		    *vp = (void *) (uintptr_t) res;
		}
d943 1
a943 1
		  cp = GET_ARG (N, ap, char *);
d948 1
a948 1
		  sp = GET_ARG (N, ap, short *);
d953 1
a953 1
		  lp = GET_ARG (N, ap, long *);
d964 1
a964 1
		  llp = GET_ARG (N, ap, long long*);
d970 1
a970 1
		  ip = GET_ARG (N, ap, int *);
d990 1
a990 2
	  char nancount = 0;
	  char infcount = 0;
d1035 1
a1035 1
		  if (nancount + infcount == 0)
d1053 2
a1054 2
		      && (flags & (NDIGITS | DPTOK | EXPOK)) ==
				  (NDIGITS | DPTOK | EXPOK))
d1060 1
a1060 1
		  if (nancount == 2)
a1064 5
		  if (infcount == 1 || infcount == 4)
		    {
		      infcount++;
		      goto fok;
		    }
a1073 40
		case 'i':
		case 'I':
		  if (infcount == 0
		      && (flags & (NDIGITS | DPTOK | EXPOK)) ==
				  (NDIGITS | DPTOK | EXPOK))
		    {
		      flags &= ~(SIGNOK | DPTOK | EXPOK | NDIGITS);
		      infcount = 1;
		      goto fok;
		    }
		  if (infcount == 3 || infcount == 5)
		    {
		      infcount++;
		      goto fok;
		    }
		  break;
		case 'f':
		case 'F':
		  if (infcount == 2)
		    {
		      infcount = 3;
		      goto fok;
		    }
		  break;
		case 't':
		case 'T':
		  if (infcount == 6)
		    {
		      infcount = 7;
		      goto fok;
		    }
		  break;
		case 'y':
		case 'Y':
		  if (infcount == 7)
		    {
		      infcount = 8;
		      goto fok;
		    }
		  break;
d1106 1
a1106 1
	      ++nread;
d1115 18
a1132 42
	  /* We may have a 'N' or possibly even [sign] 'N' 'a' as the
	     start of 'NaN', only to run out of chars before it was
	     complete (or having encountered a non-matching char).  So
	     check here if we have an outstanding nancount, and if so
	     put back the chars we did swallow and treat as a failed
	     match.

	     FIXME - we still don't handle NAN([0xdigits]).  */
	  if (nancount - 1U < 2U) /* nancount && nancount < 3 */
	    {
	      /* Newlib's ungetc works even if we called __srefill in
		 the middle of a partial parse, but POSIX does not
		 guarantee that in all implementations of ungetc.  */
	      while (p > buf)
		{
		  _ungetc_r (rptr, *--p, fp); /* [-+nNaA] */
		  --nread;
		}
	      goto match_failure;
	    }
	  /* Likewise for 'inf' and 'infinity'.	 But be careful that
	     'infinite' consumes only 3 characters, leaving the stream
	     at the second 'i'.	 */
	  if (infcount - 1U < 7U) /* infcount && infcount < 8 */
	    {
	      if (infcount >= 3) /* valid 'inf', but short of 'infinity' */
		while (infcount-- > 3)
		  {
		    _ungetc_r (rptr, *--p, fp); /* [iInNtT] */
		    --nread;
		  }
	      else
		{
		  while (p > buf)
		    {
		      _ungetc_r (rptr, *--p, fp); /* [-+iInN] */
		      --nread;
		    }
		  goto match_failure;
		}
	    }
	  /*
d1143 4
a1146 4
		    {
		      _ungetc_r (rptr, *--p, fp); /* [-+.] */
		      --nread;
		    }
d1150 2
a1151 2
	      c = *--p;
	      --nread;
d1154 3
a1156 3
		  _ungetc_r (rptr, c, fp); /* [-+] */
		  c = *--p;
		  --nread;
d1158 1
a1158 1
	      _ungetc_r (rptr, c, fp); /* [eE] */
d1202 1
a1202 1
		  dp = GET_ARG (N, ap, double *);
d1207 1
a1207 1
		  ldp = GET_ARG (N, ap, _LONG_DOUBLE *);
d1212 1
a1212 1
		  flp = GET_ARG (N, ap, float *);
a1225 4
  /* On read failure, return EOF failure regardless of matches; errno
     should have been set prior to here.  On EOF failure (including
     invalid format string), return EOF if no matches yet, else number
     of matches made prior to failure.  */
d1227 1
a1227 1
  return nassigned && !(fp->_flags & __SERR) ? nassigned : EOF;
a1229 1
  /* Return number of matches, which can be 0 on match failure.  */
a1232 15

#ifndef _NO_POS_ARGS
/* Process all intermediate arguments.  Fortunately, with scanf, all
   intermediate arguments are sizeof(void*), so we don't need to scan
   ahead.  */
static void *
get_arg (int n, va_list *ap, int *numargs_p, void **args)
{
  int numargs = *numargs_p;
  while (n >= numargs)
    args[numargs++] = va_arg (*ap, void *);
  *numargs_p = numargs;
  return args[n];
}
#endif /* !_NO_POS_ARGS */
@


1.31
log
@
2005-10-28  Bob Wilson  <bob.wilson@@acm.org>

        * libc/stdio/siprintf.c: Wrap long lines in ANSI_SYNOPSIS.
        * libc/stdio/siscanf.c: Likewise.
        * libc/stdio/sprintf.c: Likewise.
        * libc/stdio/sscanf.c: Likewise.
        * libc/stdio/vfprintf.c: Likewise.
        * libc/stdio/vfscanf.c: Likewise.
        * libc/stdio/viprintf.c: Likewise.
        * libc/stdio/viscanf.c: Likewise.
@
text
@d224 1
a224 1
#define BufferEmpty (fp->_r <= 0 && __srefill(fp))
d550 1
a550 1
	      if (__srefill (fp))
d618 1
a618 1
		      if (__srefill (fp))
d913 1
a913 1
	      if (__srefill (fp))
d1110 1
a1110 1
	      if (__srefill (fp))
@


1.31.2.1
log
@2006-09-17  Paul Brook  <paul@@codesourcery.com>

	newlib/
	Backport form mainline
	2006-09-26  Jeff Johnston  <jjohnstn@@redhat.com>
	* libc/include/stdio.h: Do not allow macros
	for clearerr, feof, or fileno.
	* libc/include/sys/reent.h[_REENT_SMALL](struct _reent): Change
	the dummy std stream scheme to use pointers to const external
	fake files, one for each standard stream.
	* libc/stdio/local.h (CHECK_INIT): Change to take a file pointer
	argument.  For _REENT_SMALL, reset the file pointer if it
	matches one of the fake std stream pointers.
	* libc/stdio/clearerr.c: Fix CHECK_INIT macro to add file pointer
	argument.
	* libc/stdio/fclose.c: Ditto.
	* libc/stdio/feof.c: Ditto.
	* libc/stdio/ferror.c: Ditto.
	* libc/stdio/fflush.c: Ditto.
	* libc/stdio/fgetc.c: Ditto.
	* libc/stdio/fgets.c: Ditto.
	* libc/stdio/fileno.c: Ditto.
	* libc/stdio/findfp.c: Ditto.
	* libc/stdio/fputc.c: Ditto.
	* libc/stdio/fputs.c: Ditto.
	* libc/stdio/fread.c: Ditto.
	* libc/stdio/freopen.c: Ditto.
	* libc/stdio/fseek.c: Ditto.
	* libc/stdio/ftell.c: Ditto.
	* libc/stdio/fwrite.c: Ditto.
	* libc/stdio/getc.c: Ditto.
	* libc/stdio/getdelim.c: Ditto.
	* libc/stdio/putc.c: Ditto.
	* libc/stdio/refill.c: Ditto.
	* libc/stdio/setvbuf.c: Ditto.
	* libc/stdio/ungetc.c: Ditto.
	* libc/stdio/vfprintf.c: Ditto.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdio/wbuf.c: Ditto.: Ditto.
	* libc/stdio/wsetup.c: Ditto.
	* libc/stdio64/freopen64.c: Ditto.
	* libc/stdio64/fseeko64.c: Ditto.
	* libc/stdio64/ftello64.c: Ditto.
	* libc/machine/powerpc/vfprintf.c: Ditto.
	* libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@d234 1
a234 1
  CHECK_INIT(_REENT, fp);
d256 1
a256 1
  CHECK_INIT(data, fp);
@


1.30
log
@
2005-04-28  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): Fix code thinko
        when checking for multiple flags.
@
text
@d40 2
a41 2
	int _vsscanf_r(struct _reent *<[reent]>, const char *<[str]>, const char *<[fmt]>, 
                       va_list <[list]>);
@


1.29
log
@
2005-04-05  Dave Korn  <dave.korn@@artimi.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): If an error occurs processing
        something that looks like a "NaN", put back the characters processed.
@
text
@d1053 2
a1054 1
		      && (flags & (SIGNOK | NDIGITS | DPTOK | EXPOK)))
@


1.28
log
@
2005-02-07  Antony King  <antony.king@@st.com>

        * libc/stdio/clearerr.c (clearerr): Ensure CHECK_INIT() is
        called before _flockfile to prevent lock object use before
        initialisation. _REENT_SMALL_CHECK_INIT() and CHECK_INIT()
        take a struct _reent * instead of a FILE *.
        * libc/stdio/fclose.c (_fclose_r): Ditto.
        * libc/stdio/feof.c (feof): Ditto.
        * libc/stdio/ferror.c (ferror): Ditto.
        * libc/stdio/fflush.c (fflush): Ditto.
        * libc/stdio/fgetc.c (fgetc): Ditto.
        * libc/stdio/fgets.c (fgets): Ditto.
        * libc/stdio/fileno.c (fileno): Ditto.
        * libc/stdio/fputc.c (fputc): Ditto.
        * libc/stdio/fputs.c (fputs): Ditto.
        * libc/stdio/fread.c (fread): Ditto.
        * libc/stdio/freopen.c (_freopen_r): Ditto.
        * libc/stdio/fseek.c (_fseek_r): Ditto.
        * libc/stdio/ftell.c (_ftell_r): Ditto.
        * libc/stdio/fwrite.c (fwrite): Ditto.
        * libc/stdio/getc.c (getc): Ditto.
        * libc/stdio/getdelim.c (__getdelim): Ditto.
        * libc/stdio/putc.c (putc): Ditto.
        * libc/stdio/setvbuf.c (setvbuf): Ditto.
        * libc/stdio/ungetc.c (_ungetc_r): Ditto.
        * libc/stdio/vfprintf.c (_VFPRINTF_R): Ditto.
        * libc/stdio64/freopen64.c (_freopen64_r): Ditto.
        * libc/stdio64/fseeko64.c (_fseeko64_r): Ditto.
        * libc/stdio64/ftello64.c (_ftello64_r): Ditto.
        * libc/stdio/local.h (CHECK_INIT): Argument is now a struct
        _reent * instead of a FILE * and so replace incorrect use of
        _REENT with argument.
        * libc/sys/arm/syscalls.c (CHECK_INIT): Ditto.
        * libc/stdio/getchar.c (getchar): _REENT_SMALL_CHECK_INIT() and
        CHECK_INIT() take a struct _reent * instead of a FILE *.
        * libc/stdio/iprintf.c (iprintf, _iprintf_r): Ditto.
        * libc/stdio/iscanf.c (iscanf, _iscanf_r): Ditto.
        * libc/stdio/perror.c (perror): Ditto.
        * libc/stdio/printf.c (printf, _printf_r): Ditto.
        * libc/stdio/putchar.c (putchar): Ditto.
        * libc/stdio/puts.c (puts): Ditto.
        * libc/stdio/refill.c (__srefill): Ditto.
        * libc/stdio/scanf.c (scanf, _scanf_r): Ditto.
        * libc/stdio/vfscanf.c (VFSCANF, _VFSCANF_R): Ditto.
        * libc/stdio/viprintf.c (viprintf, _viprintf_r): Ditto.
        * libc/stdio/viscanf.c (viscanf, _viscanf_r): Ditto.
        * libc/stdio/vprintf.c (vprintf, _vprintf_r): Ditto.
        * libc/stdio/vscanf.c (vscanf, _vscanf_r): Ditto.
        * libc/stdio/wbuf.c (__swbuf): Ditto.
        * libc/stdio/wsetup.c (__swsetup): Ditto.
        * libc/stdlib/mallocr.c (malloc_stats): Ditto.
        * libc/stdlib/mstats.c (_mstats_r): Ditto.
        * libc/include/sys/reent.h (_REENT_SMALL_CHECK_INIT): Ditto.
        * libc/machine/powerpc/vfscanf.c (vfscanf): Ditto.
        * libc/stdio/fgetpos.c (_fgetpos_r): Removed unnecessary calls
        to _flockfile and _funlockfile; rely on locking in _ftell_r.
        * libc/stdio64/fgetpos64.c (_fgetpos64_r): Ditto (_ftello64_r).
        * libc/machine/powerpc/vfprintf.c (__sbprintf): Removed unnecessary
        initialision of _data field in FILE structure.
        * libc/machine/powerpc/vfprintf.c (VFPRINTF): Added CHECK_INIT() call.
@
text
@d1114 18
a1131 1
	  /*
d1143 1
a1143 1
		      ungetc (*(u_char *)-- p, fp);
@


1.27
log
@
2005-01-06  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/strtod.c (_strtod_r): Add NaN support.
        * (strtof): Ditto.
        * libc/stdio/vfscanf.c (__svfscanf_r): Ditto.
        * Makefile.am (MATHOBJS_IN_LIBC): Add s_nan and sf_nan
        functions for use by strtod and strtof.
        * Makefile.in: Regenerated.
@
text
@d234 1
a234 1
  CHECK_INIT(fp);
d256 1
@


1.26
log
@
2004-11-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdio.h: Add new iprintf and iscanf variants.  Also
        do some reordering.
        * libc/machine/powerpc/vfscanf.c: Remove __sccl function.
        * libc/stdio/Makefile.am: Add support for new iprintf and iscanf
        family functions.
        * libc/stdio/Makefile.in: Regenerated.
        * libc/stdio/fiprintf.c: Remove doc to siprintf.c.
        * libc/stdio/iprintf.c: Ditto.
        * libc/stdio/local.h (__svfiscanf_r): New prototype.
        * libc/stdio/siprintf.c: Add docs for various iprintf family functions.
        * libc/stdio/sniprintf.c: Move docs to siprintf.c.
        * libc/stdio/stdio.tex: Add new functions.
        * libc/stdio/vfscanf.c: Split out __sccl function to separate
        file and add special name defines so this file can be used
        to build vfiscanf.o.
        * libc/stdio/asiprintf.c: New file.
        * libc/stdio/fiscanf.c: Ditto.
        * libc/stdio/iscanf.c: Ditto.
        * libc/stdio/sccl.c: Ditto.
        * libc/stdio/siscanf.c: Ditto.
        * libc/stdio/vasiprintf.c: Ditto.
        * libc/stdio/viprintf.c: Ditto.
        * libc/stdio/viscanf.c: Ditto.
        * libc/stdio/vsiprintf.c: Ditto.
        * libc/stdio/vsiscanf.c: Ditto.
        * libc/stdio/vsniprintf.c: Ditto.
@
text
@d138 1
d989 1
a1011 1

d1034 6
a1039 2
		  flags &= ~(SIGNOK | NDIGITS);
		  goto fok;
d1049 23
d1194 4
a1197 1
		  *flp = res;
@


1.25
log
@
2004-10-04  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): For int conversions,
        count skipped zero characters as part of the nread count for %n.
        * libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@d122 11
a132 1
#ifndef	NO_FLOATING_POINT
d135 1
d228 1
a228 1
_DEFUN(vfscanf, (fp, fmt, ap), 
d234 1
a234 1
  return __svfscanf_r (_REENT, fp, fmt, ap);
d238 1
a238 1
_DEFUN(__svfscanf, (fp, fmt0, ap),
d243 1
a243 1
  return __svfscanf_r (_REENT, fp, fmt0, ap);
d249 1
a249 1
_DEFUN(_vfscanf_r, (data, fp, fmt, ap),
d255 1
a255 1
  return __svfscanf_r (data, fp, fmt, ap);
d260 1
a260 1
_DEFUN(__svfscanf_r, (rptr, fp, fmt0, ap),
a1182 104

/*
 * Fill in the given table from the scanset at the given format
 * (just after `[').  Return a pointer to the character past the
 * closing `]'.  The table has a 1 wherever characters should be
 * considered part of the scanset.
 */

/*static*/
u_char *
_DEFUN(__sccl, (tab, fmt),
       register char *tab _AND
       register u_char *fmt)
{
  register int c, n, v;

  /* first `clear' the whole table */
  c = *fmt++;			/* first char hat => negated scanset */
  if (c == '^')
    {
      v = 1;			/* default => accept */
      c = *fmt++;		/* get new first char */
    }
  else
    v = 0;			/* default => reject */
  /* should probably use memset here */
  for (n = 0; n < 256; n++)
    tab[n] = v;
  if (c == 0)
    return fmt - 1;		/* format ended before closing ] */

  /*
   * Now set the entries corresponding to the actual scanset to the
   * opposite of the above.
   *
   * The first character may be ']' (or '-') without being special; the
   * last character may be '-'.
   */

  v = 1 - v;
  for (;;)
    {
      tab[c] = v;		/* take character c */
    doswitch:
      n = *fmt++;		/* and examine the next */
      switch (n)
	{

	case 0:		/* format ended too soon */
	  return fmt - 1;

	case '-':
	  /*
	   * A scanset of the form [01+-] is defined as `the digit 0, the
	   * digit 1, the character +, the character -', but the effect of a
	   * scanset such as [a-zA-Z0-9] is implementation defined.  The V7
	   * Unix scanf treats `a-z' as `the letters a through z', but treats
	   * `a-a' as `the letter a, the character -, and the letter a'.
	   *
	   * For compatibility, the `-' is not considerd to define a range if
	   * the character following it is either a close bracket (required by
	   * ANSI) or is not numerically greater than the character we just
	   * stored in the table (c).
	   */
	  n = *fmt;
	  if (n == ']' || n < c)
	    {
	      c = '-';
	      break;		/* resume the for(;;) */
	    }
	  fmt++;
	  do
	    {			/* fill in the range */
	      tab[++c] = v;
	    }
	  while (c < n);
#if 1			/* XXX another disgusting compatibility hack */
	  /*
	   * Alas, the V7 Unix scanf also treats formats such
	   * as [a-c-e] as `the letters a through e'. This too
	   * is permitted by the standard....
	   */
	  goto doswitch;
#else
	  c = *fmt++;
	  if (c == 0)
	    return fmt - 1;
	  if (c == ']')
	    return fmt;
#endif

	  break;


	case ']':		/* end of scanset */
	  return fmt;

	default:		/* just another character */
	  c = n;
	  break;
	}
    }
  /* NOTREACHED */
}
@


1.24
log
@
2004-08-16  Nathan Sidwell  <nathan@@codesourcery.com>

        * libc/stdio/vfscanf.c (_NO_LONGLONG): Move out of FLOATING_POINT
        #if.
@
text
@d768 1
d817 1
d962 1
a962 1
	  nread += p - buf;
@


1.23
log
@
2004-06-02  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): For CT_INT conversions,
        reset digit flags appropriately after we have discovered "0x".
        * libc/machine/powerpc/vfscanf.c (__svfscanf_r): Ditto.
@
text
@a137 5
#define _NO_LONGLONG
#if defined _WANT_IO_LONG_LONG && defined __GNUC__
# undef _NO_LONGLONG
#endif

d153 5
@


1.22
log
@
2004-05-25  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * newlib.hin: (_WANT_IO_POS_ARGS): New define.
        (_WANT_IO_LONG_LONG): Ditto.
        (_WANT_IO_LONG_DOUBLE): Ditto.
        * configure.in: Add new configuration options
        --enable-newlib-io-long-long and --enable-newlib-io-long-double
        which tie to new defines in newlib.hin.
        * configure: Regenerated.
        * configure.host: Add checks for new configuration options.  Also
        fix up check for --enable-newlib-io-pos-args so configuration
        option will override any default for a given platform.
        Remove defining compiler flags for the _WANT_IO* options.
        * libc/stdio/vfprintf.c: Change to use new newlib.hin defines
        instead of looking for old compiler flags.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/vfieeefp.h: Ditto.
        * libc/machine/powerpc/vfprintf.c: Ditto.
        * libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@d875 4
@


1.21
log
@
2004-04-23  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * configure.in: Define _MB_CAPABLE if mb supported.
        * configure: Regenerated.
        * configure.host: Remove manual setting of MB_CAPABLE compiler
        flag.
        * newlib.hin: Add _MB_CAPABLE flag.
        * libc/ctype/iswalpha.c, libc/ctype/iswblank.c: Include <newlib.h>
        and check for _MB_CAPABLE flag instead of MB_CAPABLE.
        * libc/ctype/iswcntrl.c, libc/ctype/iswprint.c: Ditto.
        * libc/ctype/iswpunct.c, libc/ctype/iswspace.c: Ditto.
        * libc/ctype/jp2uc.c: Ditto.
        * libc/ctype/towlower.c, libc/ctype/towupper.c: Ditto.
        * libc/locale/locale.c: Ditto
        * libc/machine/powerpc/vfscanf.c: Ditto
        * libc/stdio/vfprintf.c, libc/stdio/vfscanf.c: Ditto
        * libc/stdlib/mblen.c: Ditto
        * libc/stdlib/mblen_r.c, libc/stdlib/mbrlen.c: Ditto
        * libc/stdlib/mbrtowc.c, libc/stdlib/mbsrtowcs.c: Ditto
        * libc/stdlib/mbstowcs.c, libc/stdlib/mbtowc.c: Ditto
        * libc/stdlib/mbtowc_r.c, libc/stdlib/wcrtomb.c: Ditto
        * libc/stdlib/wcsrtombs.c, libc/stdlib/wcstombs.c: Ditto
        * libc/stdlib/wctomb.c, libc/sys/linux/intl/dcigettext.c: Ditto
        * libc/sys/linux/intl/explodename.c: Ditto
        * libc/sys/linux/intl/finddomain.c: Ditto
        * libc/sys/linux/intl/l10nflist.c: Ditto
        * libc/sys/linux/intl/loadmsgcat.c: Ditto
        * libc/sys/linux/intl/localealias.c: Ditto
@
text
@d106 1
a107 1
#include <reent.h>
d133 1
a133 1
#if defined WANT_IO_LONG_DBL && (LDBL_MANT_DIG > DBL_MANT_DIG)
d139 1
a139 1
#if defined WANT_PRINTF_LONG_LONG && defined __GNUC__
@


1.20
log
@
2004-04-23  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * libc/stdio/asprintf.c libc/stdio/clearerr.c,
        libc/stdio/fclose.c libc/stdio/fcloseall.c libc/stdio/fdopen.c,
        libc/stdio/feof.c libc/stdio/ferror.c libc/stdio/fflush.c,
        libc/stdio/fgetc.c libc/stdio/fgetpos.c libc/stdio/fgets.c,
        libc/stdio/fileno.c libc/stdio/findfp.c libc/stdio/fiprintf.c,
        libc/stdio/flags.c libc/stdio/fopen.c libc/stdio/fprintf.c,
        libc/stdio/fputc.c libc/stdio/fputs.c libc/stdio/fread.c,
        libc/stdio/freopen.c libc/stdio/fscanf.c libc/stdio/fseek.c,
        libc/stdio/fseeko.c libc/stdio/fsetpos.c libc/stdio/ftell.c,
        libc/stdio/ftello.c libc/stdio/fvwrite.c libc/stdio/fwalk.c,
        libc/stdio/fwrite.c libc/stdio/getc.c libc/stdio/getc_u.c,
        libc/stdio/getchar.c libc/stdio/getchar_u.c,
        libc/stdio/getdelim.c libc/stdio/getline.c libc/stdio/gets.c,
        libc/stdio/getw.c libc/stdio/iprintf.c libc/stdio/local.h,
        libc/stdio/makebuf.c libc/stdio/mktemp.c libc/stdio/perror.c,
        libc/stdio/printf.c libc/stdio/putc.c libc/stdio/putc_u.c,
        libc/stdio/putchar.c libc/stdio/putchar_u.c libc/stdio/puts.c,
        libc/stdio/putw.c libc/stdio/refill.c libc/stdio/remove.c,
        libc/stdio/rename.c libc/stdio/rewind.c libc/stdio/rget.c,
        libc/stdio/scanf.c libc/stdio/setbuf.c libc/stdio/setbuffer.c,
        libc/stdio/setlinebuf.c libc/stdio/setvbuf.c,
        libc/stdio/siprintf.c libc/stdio/snprintf.c,
        libc/stdio/sprintf.c libc/stdio/sscanf.c libc/stdio/stdio.c,
        libc/stdio/tmpfile.c libc/stdio/tmpnam.c libc/stdio/ungetc.c,
        libc/stdio/vasprintf.c libc/stdio/vfieeefp.h,
        libc/stdio/vfprintf.c libc/stdio/vfscanf.c,
        libc/stdio/vprintf.c libc/stdio/vscanf.c,
        libc/stdio/vsnprintf.c libc/stdio/vsprintf.c,
        libc/stdio/vsscanf.c libc/stdio/wbuf.c,
        libc/stdio/wsetup.c: Perform minor formatting changes.  Move
        copyright notices to top of file, ensure that <_ansi.h> is
        included, be consistent with open parentheses, use _DEFUN macro,
        include "local.h" where needed, and remove various compiler
        warnings.
@
text
@d106 1
d297 1
a297 1
#ifndef MB_CAPABLE
@


1.19
log
@
2004-04-21  J"orn Rennecke <joern.rennecke@@superh.com>

        * libc/stdio/vfscanf.c (NNZDIGITS): New define.
        (__svfscanf_r): In integer conversions, leave out leading zeroes
        which are not part of a base prefix.
        Keep track of width truncation to fit into buf, not counting left-out
        zeroes against width till the truncation has been compensated for.
@
text
@d1 17
d36 1
a36 1
	int _vscanf_r(void *<[reent]>, const char *<[fmt]>, 
d38 1
a38 1
	int _vfscanf_r(void *<[reent]>, FILE *<[fp]>, const char *<[fmt]>, 
d40 1
a40 1
	int _vsscanf_r(void *<[reent]>, const char *<[str]>, const char *<[fmt]>, 
d61 1
a61 1
	char *<[reent]>;
d66 1
a66 1
	char *<[reent]>;
d72 1
a72 1
	char *<[reent]>;
a104 17
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

d106 1
d216 4
a219 4
_DEFUN (vfscanf, (fp, fmt, ap), 
    register FILE *fp _AND 
    _CONST char *fmt _AND 
    va_list ap)
d226 4
a229 4
__svfscanf (fp, fmt0, ap)
     register FILE *fp;
     char _CONST *fmt0;
     va_list ap;
d237 5
a241 5
_DEFUN (_vfscanf_r, (data, fp, fmt, ap),
    struct _reent *data _AND 
    register FILE *fp _AND 
    _CONST char *fmt _AND 
    va_list ap)
d248 5
a252 5
__svfscanf_r (rptr, fp, fmt0, ap)
     struct _reent *rptr;
     register FILE *fp;
     char _CONST *fmt0;
     va_list ap;
d559 1
a559 1
                wcp = va_arg(ap, wchar_t *);
d570 2
a571 2
                  memset((void *)&state, '\0', sizeof(mbstate_t));
                  if ((mbslen = _mbrtowc_r(rptr, wcp, buf, n, &state)) 
d688 1
a688 1
                wcp = va_arg(ap, wchar_t *);
d692 1
a692 1
              while (!isspace(*fp->_p) && width != 0) 
d699 2
a700 2
                  memset((void *)&state, '\0', sizeof(mbstate_t));
                  if ((mbslen = _mbrtowc_r(rptr, wcp, buf, n, &state)) 
d710 1
a710 1
                            ungetc(buf[--n], fp);
d1175 3
a1177 3
__sccl (tab, fmt)
     register char *tab;
     register u_char *fmt;
@


1.18
log
@
2004-04-01  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): Add locking/unlocking
        of file.
@
text
@d182 1
d763 1
d765 1
a767 1
	    width = sizeof (buf) - 1;
d770 1
a770 3
	  if (--width > sizeof (buf) - 2)
	    width = sizeof (buf) - 2;
	  width++;
d772 5
a776 1
	  flags |= SIGNOK | NDIGITS | NZDIGITS;
d796 2
d804 11
a814 4
		    flags &= ~(SIGNOK | NZDIGITS | NDIGITS);
		  else
		    flags &= ~(SIGNOK | PFXOK | NDIGITS);
		  goto ok;
d825 1
a825 1
		  flags &= ~(SIGNOK | PFXOK | NDIGITS);
d834 1
a834 1
		  flags &= ~(SIGNOK | PFXOK | NDIGITS);
d853 1
a853 1
		  flags &= ~(SIGNOK | PFXOK | NDIGITS);
d888 1
d956 1
a956 1

d968 1
a970 1
	    width = sizeof (buf) - 1;
d973 1
a973 3
	  if (--width > sizeof (buf) - 2)
	    width = sizeof (buf) - 2;
	  width++;
d975 4
d997 5
@


1.17
log
@
2003-12-04  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * libc/stdio/vfprintf.c (_VFPRINTF_R): Use _r versions
        of mb routines for %lc and %ls support.
        * libc/stdio/vfscanf.c (_svfscanf_r): Add %lc, %C,
        %ls, and %S support.  Remove CYGNUS_NEC markers and
        code within.
@
text
@d288 2
d302 1
a302 1
	return nassigned;
d504 1
d1136 1
d1139 2
@


1.16
log
@
2003-11-21  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r)[!_NO_LONGDBL]: Don't use
        _strtold routine for processing floats and doubles since it
        is not as fast as _strtod_r.
@
text
@d107 1
d142 7
a148 1
#define	BUF	(MAXEXP+MAXFRACT+3)	/* 3 = sign + decimal point + NUL */
d264 3
a271 3
#ifdef MB_CAPABLE
  mbstate_t state;                /* value to keep track of multibyte state */
#endif
a281 2
#else
	u_long _uquad;
d436 3
d450 4
a530 1
#ifndef CYGNUS_NEC
a531 1
#endif
d551 39
a589 1
	  if (flags & SUPPRESS)
a591 1

a598 1
#ifndef CYGNUS_NEC
a600 1
#endif
a603 1
#ifndef CYGNUS_NEC
a604 1
#endif
a617 15
#ifdef CYGNUS_NEC
	      /* Kludge city for the moment */
	      char *dest = va_arg (ap, char *);
	      int n = width;
	      if (fp->_r == 0)
		goto input_failure;

	      while (n && fp->_r)
		{
		  *dest++ = *(fp->_p++);
		  n--;
		  fp->_r--;
		  nread++;
		}
#else
a622 1
#endif
d678 50
a727 2
	    width = ~0;
	  if (flags & SUPPRESS)
a874 1
#ifndef CYGNUS_NEC
a875 1
#endif
a1036 1
#ifndef CYGNUS_NEC
a1037 1
#endif
d1072 1
a1072 1
	      double res;
d1076 1
a1076 1
	      long double qres;
@


1.15
log
@
2003-08-22  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/include/sys/reent.h: Add _GLOBAL_REENT macro.
	* libc/stdio: Globally remove/replace all references to fp->_data.
	Replace with _REENT or _GLOBAL_REENT where appropriate.
	* libc/stdio/asprintf.c: Ditto.
	* libc/stdio/fclose.c: Ditto.
	* libc/stdio/fvwrite.c: Ditto.
	* libc/stdio/makebuf.c: Ditto.
	* libc/stdio/refill.c: Ditto.
	* libc/stdio/local.h: Ditto.
	* libc/stdio/setvbuf.c: Ditto.
	* libc/stdio/sscanf.c: Ditto.
	* libc/stdio/stdio.c: Ditto.
	* libc/stdio/ungetc.c: Ditto.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdio/vsscanf.c: Ditto.
	* libc/stdio/fopen.c: Ditto.  Also use _fseek_r in _fopen_r.
	* libc/stdio/vasprintf.c: Ditto.  Also call _vfprintf_r directly.
	* libc/stdio/vsnprintf.c: Ditto.
	* libc/stdio/vsprintf.c: Ditto.
	* libc/stdio/fcloseall.c(fcloseall): Use _GLOBAL_REENT macro
	instead of _REENT to walk file list.
	* libc/stdio/fflush.c: Ditto.
	* libc/stdio/fgetpos.c: Add reentrant version and have regular
	version call reentrant version with _REENT argument.
	* libc/stdio/fsetpos.c: Ditto.
	* libc/stdio/fseek.c: Ditto.
	* libc/stdio/fseeko.c: Ditto.
	* libc/stdio/ftell.c: Ditto.
	* libc/stdio/ftello.c: Ditto.
	* libc/stdio/freopen.c: Ditto.
	* libc/stdio/findfp.c: Use _GLOBAL_REENT pointer when adding
	new files to chain.  Also use _GLOBAL_REENT pointer for
	cleaning up.
	* libc/stdio/fiprintf.c: Reformatted to minimize duplicate code.
	* libc/stdio/siprintf.c: Ditto.
	* libc/stdio/iprintf.c: Ditto.
	* libc/stdio/fprintf.c: Ditto.
	* libc/stdio/printf.c: Ditto.
	* libc/stdio/snprintf.c: Call _vfprintf_r directly.
	* libc/stdio/sprintf.c: Ditto.
	* libc/stdio/vprintf.c: Ditto.  Also add _REENT_ONLY check.
	* libc/stdio/rewind.c: Call _fseek_r directly.
	* libc/stdio/tmpfile.c: Call _fopen_r and _remove_r directly.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Change _r routines to use
	data pointer.
	(get_arg): Add extra struct _reent pointer argument.
	* libc/stdio64/fgetpos64.c: Add _r versions, remove any reference
	to fp->_data.
	* libc/stdio64/fopen64.c: Ditto.
	* libc/stdio64/freopen64.c: Ditto.
	* libc/stdio64/fsetpos64.c: Ditto.
	* libc/stdio64/ftello64.c: Ditto.
	* libc/stdio64/local64.h: Ditto.
	* libc/stdio64/stdio64.c: Ditto.
	* libc/stdio64/fseeko64.c: Ditto plus use _fstat_r instead of
	_fstat64_r for the meantime.
@
text
@d1001 1
d1003 1
a1003 1
	      double res;
d1005 2
a1006 1
	      long double res;
d1028 11
a1038 5
#ifdef _NO_LONGDBL
	      res = _strtod_r (rptr, buf, NULL);
#else  /* !_NO_LONGDBL */
	      res = _strtold (buf, NULL);
#endif /* !_NO_LONGDBL */
d1047 1
a1047 1
		  *ldp = res;
@


1.14
log
@	* libc/stdio/sscanf.c: Update flags description.
	* libc/stdio/vfscanf.c: Add CHAR flag value to denote 8 bit target
	type.
	(__svfscanf_r): Add 'hh' and 'll' handling.
@
text
@d213 1
a213 1
  return __svfscanf_r (fp->_data, fp, fmt, ap);
@


1.13
log
@
2003-03-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): For floating point conversion,
        count all characters used to create number against maximum width.
        * libc/machine/powerpc/vfscanf.c (__svfscanf_r): Ditto.
@
text
@d154 1
a154 1
#define	LONGDBL		0x02	/* L: long double or long long */
d156 4
a159 3
#define	SUPPRESS	0x08	/* suppress assignment */
#define	POINTER		0x10	/* weird %p pointer (`fake hex') */
#define	NOSKIP		0x20	/* do not skip blanks */
d167 2
a168 2
#define	SIGNOK		0x40	/* +/- is (still) legal */
#define	NDIGITS		0x80	/* no digits detected */
d170 2
a171 2
#define	DPTOK		0x100	/* (float) decimal point is still legal */
#define	EXPOK		0x200	/* (float) exponent (e+3, etc) still legal */
d173 2
a174 2
#define	PFXOK		0x100	/* 0x prefix is (still) legal */
#define	NZDIGITS	0x200	/* no zero digits detected */
d266 1
d340 7
a346 1
	  flags |= LONG;
d352 7
a358 1
	  flags |= SHORT;
d457 6
a462 1
	  if (flags & SHORT)
d830 5
@


1.12
log
@	* libc/include/langinfo.h: New file.
	* libc/include/wchar.h: Likewise.
	* libc/include/sys/syslimits.h: Likewise.
	* libc/locale/fix_grouping.c: Likewise.
	* libc/locale/ldpart.c: Likewise.
	* libc/locale/ldpart.h: Likewise.
	* libc/locale/lmessages.c: Likewise.
	* libc/locale/lmessages.h: Likewise.
	* libc/locale/lmonetary.c: Likewise.
	* libc/locale/lmonetary.h: Likewise.
	* libc/locale/lnumeric.c: Likewise.
	* libc/locale/lnumeric.h: Likewise.
	* libc/locale/nl_langinfo.3: Likewise.
	* libc/locale/nl_langinfo.c: Likewise.
	* libc/locale/timelocal.c: Likewise.
	* libc/locale/timelocal.h: Likewise.
	* libc/stdlib/btowc.c: Likewise.
	* libc/stdlib/mbrlen.c: Likewise.
	* libc/stdlib/mbrtowc.c: Likewise.
	* libc/stdlib/mbsinit.c: Likewise.
	* libc/stdlib/mbsrtowcs.c: Likewise.
	* libc/stdlib/wcrtomb.c: Likewise.
	* libc/stdlib/wcsrtombs.c: Likewise.
	* libc/stdlib/wctob.c: Likewise.
	* libc/sys/linux/prof-freq.c: Likewise.
	* libc/sys/linux/profile.c: Likewise.
	* libc/sys/linux/machine/i386/dl-procinfo.c: Likewise.
	* libc/sys/linux/machine/i386/dl-procinfo.h: Likewise.
	* libc/include/stdlib.h: Change re-entrant functions to take
	mbstate_t pointers.
	* libc/include/sys/_types.h: Define _mbstate_t.
	* libc/include/sys/config.h (MB_LEN_MAX): New macro.
	* libc/include/sys/errno.h (EILSEQ): New error code.
	* libc/include/sys/reent.h: Include wchar.h.  Change reentrant
	structure to use mbstate_t.
	* libc/locale/Makefile.am (LIB_SOURCES): Add new files.
	* libc/machine/powerpc/vfprintf.c: Use mbstate_t.
	* libc/machine/powerpc/vfscanf.c: Likewise.
	* libc/stdio/getdelim.c: Reallocate buffer only when necessary.
	* libc/stdio/vfprintf.c: Likewise.
	* libc/stdio/vfscanf.c: Likewise.
	* libc/stdlib/Makefile.am (LIB_SOURCES): Add new files.
	* libc/stdlib/mblen.c: Use mbstate_t.
	* libc/stdlib/mblen_r.c: Likewise.
	* libc/stdlib/mbstowcs.c: Likewise.
	* libc/stdlib/mbstowcs_r.c: Likewise.
	* libc/stdlib/mbtowc.c: Likewise.
	* libc/stdlib/mbtowc_r.c: Likewise.
	* libc/stdlib/wcstombs.c: Likewise.
	* libc/stdlib/wcstombs_r.c: Likewise.
	* libc/stdlib/wctomb_r.c: Likewise.
	* libc/sys/linux/Makefile.am (LIB_SOURCES): Add prof-freq.c and
	profile.c.
	* libc/sys/linux/machine/i386/Makefile.am (LIB_SOURCES): Add
	dl-procinfo.c.
	* libc/sys/linux/sys/errno.h (EILSEQ): New error code.
	* libc/sys/linux/sys/types.h (off_t): Define type.
	* testsuite/newlib.locale/UTF-8.c: Change locale name from UTF-8
	to C-UTF-8.
	* testsuite/newlib.locale/UTF-8.exp: Likewise.
@
text
@d934 1
a935 1
	    fskip:
@


1.11
log
@
2002-01-11 Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): Change loop that
        reads blanks from the input file to break if EOF reached
        rather than end processing.
@
text
@d110 2
d262 1
a262 1
  int state = 0;                /* value to keep track of multibyte state */
d288 1
@


1.10
log
@
2001-10-01  Charles Wilson  <cwilson@@ece.gatech.edu>

        * libc/include/stdlib.h: add declarations for
        _strtoull_r, _strtoll_r, strtoull, and strtoll.
        * libc/stdio/local.h: remove declarations of
        __strtoull_r and __strtoll_r.
        * libc/stdio/vfscanf.c(__svfscanf_r): call
        _strtoull_r instead of __strtoull_r. Ditto
        _strtoll_r vs. __strtoll_r.
        * libc/stdlib/Makefile.am: add new files to
        .c list and .def list
        * libc/stdlib/Makefile.in: regenerate
        * libc/stdlib/strtoll_r.c: rename __strtoll_r
        as _strtoll_r
        * libc/stdlib/strtoull_r.c: rename __strtoull_r
        as _strtoull_r
        * libc/stdlib/strtoull.c: new file
        * libc/stdlib/strtoll.c: new file
@
text
@d295 1
a295 3
	      if (BufferEmpty)
		return nassigned;
	      if (!isspace (*fp->_p))
@


1.9
log
@
2001-09-13  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/Makefile.am: Add support to build strtoll_r.c
        and strtoull_r.c.
        * libc/stdlib/Makefile.in: Regenerated.
        * libc/stdlib/strtoll_r.c: New file.
        * libc/stdlib/strtoull_r.c: New file.
        * libc/stdio/local.h: Add prototypes for long long string
        conversion routines.
        * libc/stdio/vfscanf.c (__svfscanf_r): Add optional long long support
        tied to %L integer conversion specifier.
@
text
@d825 1
a825 1
		    resll = __strtoull_r (rptr, buf, (char **) NULL, base);
d827 1
a827 1
		    resll = __strtoll_r (rptr, buf, (char **) NULL, base);
@


1.8
log
@
2001-04-27  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): Initialize new_exp local var.
@
text
@d133 5
d152 1
a152 1
#define	LONGDBL		0x02	/* L: long double */
d189 4
d269 5
d452 7
d820 12
@


1.7
log
@
2001-04-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdio.h[!_REENT_ONLY]: Moved various functions together
        into one list.
        [!__STRICT_ANSI__]: Moved non-ANSI I/O functions in this list.
        (vfscanf, vscanf, vsscanf, _vfscanf_r, _vscanf_r, _vsscanf_r): New
        function prototypes.
        (_fscanf_r, _sscanf_r): Ditto.
        * libc/include/stdlib.h: Added _strtod_r prototype.
        * libc/stdio/Makefile.am: Add new v*scanf functions.
        * libc/stdio/Makefile.in: Regenerate.
        * libc/stdio/fscanf.c: Reorganized so HAVE_STDC only affects prototype
        and code is shared.  Added reentrant _fscanf_r which calls __svfscanf_r.        * libc/stdio/scanf.c: Changed to call __svfscanf_r.
        * libc/stdio/sscanf.c: Changed documentation to add reentrant routines.
        (sscanf): Changed to call __svfscanf_r with _REENT argument.
        (_sscanf_r): New routine.
        * libc/stdio/local.h: Removed __svfscanf prototype and replaced it
        with __svfscanf_r prototype.
        * libc/stdio/vfscanf.c (vfscanf, _vfscanf_r: New
        routines.
        (__svfscanf_r): Reentrant version of __svfscanf which takes reetrancy
        structure as argument as calls reentrant versions of helper functions
        (e.g. _strtol_r, _strtoul_r). Also replaced calls to atol and atof
        to _strtol_r and _strtod_r respectively.
        * libc/stdio/vfscanf.c: Also changed __svfscanf to call __svfscanf_r.
        * libc/stdlib/strtod.c (strtod): Changed to call _strtod_r with
        _REENT argument.
        * libc/stdio/vscanf.c: New file.
        * libc/stdio/vsscanf.c: Ditto.
@
text
@d948 1
a948 1
	      long new_exp;
@


1.6
log
@
2000-12-06  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c: Fix typo for _NO_LONGDBL macro.
@
text
@d1 83
a83 1
/* No user fns here. Pesch 15apr92. */
d85 4
a88 1
/*
d192 12
d210 23
d272 1
a272 1
      nbytes = _mbtowc_r (_REENT, &wc, fmt, MB_CUR_MAX, &state);
d358 1
a358 1
	  ccfn = (u_long (*)())strtol;
d364 1
a364 1
	  ccfn = (u_long (*)())strtol;
d373 1
a373 1
	  ccfn = strtoul;
d379 1
a379 1
	  ccfn = strtoul;
d387 1
a387 1
	  ccfn = strtoul;
d421 1
a421 1
	  ccfn = strtoul;
d455 1
a455 1
	  ccfn = (u_long (*)())strtol;
d786 1
a786 1
	      res = (*ccfn) (buf, (char **) NULL, base);
d958 1
a958 1
		new_exp = atol (exp_start + 1) - exp_adjust;
d969 1
a969 1
	      res = atof (buf);
@


1.5
log
@
2000-12-06  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/Makefile.am: Added ldtoa.c to list of sources.
        * libc/stdlib/Makefile.in: Regenerated.
        * libc/stdio/floatio.h: Added suitable MAXEXP for long double.
        * libc/stdio/vfieeefp.h: Added long double bit structures.
        * libc/stdio/vfprintf.c[WANT_IO_LONG_DBL]: Added long double support.
        [WANT_IO_LONG_DBL](isinfl, isnanl): New static long double routines.
        (exponent): Changed expbuf to reasonable maximum instead of MAXEXP.
        * libc/stdio/vfscanf.c[WANT_IO_LONG_DBL]: Added long double support.
        * libc/stdlib/ldtoa.c: New file containing _ldtoa_r and
        _strtold routines used for conversions between character
        and long double.
@
text
@d848 1
a848 1
#ifdef _NO_LONG_DBL
d850 1
a850 1
#else  /* !_NO_LONG_DBL */
d852 1
a852 1
#endif /* !_NO_LONG_DBL */
@


1.4
log
@
2000-08-23  Werner Almesberger  <Werner.Almesberger@@epfl.ch>

        * libc/stdio/stdio.c (__swrite): declare "oldmode" only if it's
        used later (ifdef __SCLE)
        * libc/stdio/vfscanf.c (__svfscanf): declare "state" only if it's
        used later (ifdef MB_CAPABLE)
        * libc/string/memset.c (memset): removed unused variables "count"
        and "unaligned_addr"
        * libc/locale/locale.c (_setlocale_r): declare "lc_ctype" and
        "last_lc_ctype" only of they're used later (ifdef MB_CAPABLE)
        * libc/unix/getpwent.c (getpwnam): removed unused variables "uid"
        and "gid"
@
text
@d37 11
d62 1
a62 1
#define	LONGDBL		0x02	/* L: long double; unimplemented */
d386 1
a386 1
		  if ((n = fp->_r) < width)
d697 3
a699 2
	  long leading_zeroes, zeroes, exp_adjust;
	  char *exp_start;
d823 1
d825 3
d848 1
d850 3
@


1.3
log
@
Mon Apr 17 12:46:00 2000  Marek Michalkiewicz <marekm@@linux.org.pl>

        * libc/signal/signal.c (_signal_r) : Removed unused local variable temp.        * libc/stdio/findfp.c (std): Added declaration of flags and file.
        * libc/stdio/mktemp.c (_gettemp, _mkstemp_r, mkstemp): Added int
        return type.
        * libc/stdio/putchar.c (putchar): Added return statement.
        * libc/stdio/refill.c (lflush): Added correct parentheses.
        * libc/stdio/vfprintf.c (_VFPRINTF_R): Ditto.
        * libc/stdio/vfscanf.c (__svfscanf): Changed sprintf call which
        prints long value to use l qualifier.
        * libc/stdlib/dtoa.c (_dtoa_r): Added parentheses to remove warning
        messages and initialized local values: ilim, ilim1, and spec_case.
        * libc/stdlib/ecvtbuf.c (print_e): Removed unused variable dp.
        * libc/stdlib/mbctype.h (_issjis1, _issjis2): Added parentheses.
        * libc/stdlib/mprec.c: Ditto.
        * libc/stdlib/setenv_r.c: Ditto.
        * libc/stdlib/strtod.c: Ditto.
        * libc/stdlib/strtol.c: Ditto.
        * libc/stdlib/strtoul.c: Ditto.
        * libm/common/sf_expm1.c: Added curly braces to if else clauses.
        * libm/common/sf_log1p.c: Ditto.
        * libm/common/sf_scalbn.c: Ditto.
        * libm/math/ef_log.c: Ditto.
@
text
@d119 1
d121 1
@


1.2
log
@
Fri Mar 17 15:37:00 2000  Jeff Johnston <jjohnstn@@cygnus.com>

        * libc/stdio/vfscanf.c (__svfscanf): Fixed floating point
        code to update nread as each character is processed instead
        of using buffer contents which throw away leading zeroes.
@
text
@d828 1
a828 1
		  sprintf (exp_start, "e%d", new_exp);
@


1.1
log
@Initial revision
@
text
@d768 1
d790 4
a793 1
		    ungetc (*(u_char *)-- p, fp);
d798 1
d803 1
a847 1
	  nread += p - buf;
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
