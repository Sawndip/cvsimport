head	1.88;
access;
symbols
	cygwin-1_7_35-release:1.88
	cygwin-1_7_34-release:1.88
	newlib-2_2_0:1.88.0.2
	cygwin-1_7_33-release:1.88
	cygwin-1_7_32-release:1.87
	cygwin-1_7_31-release:1.87
	cygwin-1_7_30-release:1.87
	cygwin-1_7_29-release:1.87
	cygwin-1_7_28-release:1.87
	newlib-2_1_0:1.87
	cygwin-1_7_27-release:1.87
	cygwin-1_7_26-release:1.87
	cygwin-1_7_25-release:1.87
	cygwin-1_7_24-release:1.87
	cygwin-1_7_23-release:1.87
	cygwin-1_7_22-release:1.87
	cygwin-1_7_21-release:1.87
	cygwin-1_7_20-release:1.86
	cygwin-1_7_19-release:1.86
	cygwin-64bit-postmerge:1.86
	cygwin-64bit-premerge-branch:1.86.0.2
	cygwin-64bit-premerge:1.86
	cygwin-1_7_18-release:1.86
	newlib-2_0_0:1.84
	cygwin-1_7_17-release:1.84
	cygwin-64bit-branch:1.82.0.2
	cygwin-1_7_16-release:1.81
	cygwin-1_7_15-release:1.80
	cygwin-1_7_14_2-release:1.80
	cygwin-1_7_14-release:1.80
	cygwin-1_7_12-release:1.80
	cygwin-1_7_11-release:1.80
	cygwin-1_7_10-release:1.80
	newlib-1_20_0:1.79
	cygwin-1_7_9-release:1.79
	cygwin-1_7_8-release:1.79
	newlib-1_19_0:1.79
	cygwin-1_7_7-release:1.79
	cygwin-1_7_5-release:1.79
	cygwin-1_7_4-release:1.79
	cygwin-1_7_3-release:1.79
	cygwin-1_7_2-release:1.79
	newlib-1_18_0:1.76
	cygwin-1_7_1-release:1.76
	newlib-1_17_0-arc:1.72.0.2
	binutils-arc-20080908-branch:1.70.0.2
	binutils-arc-20080908-branchpoint:1.70
	newlib-1_17_0:1.72
	newlib-1_16_0:1.68
	newlib-1_15_0:1.47
	newlib-csl-coldfire-4_1-32:1.43.2.1
	newlib-csl-sourcerygxx-4_1-32:1.43.2.1
	newlib-csl-innovasic-fido-3_4_4-33:1.43.2.1
	newlib-csl-coldfire-4_1-30:1.43.2.1
	newlib-csl-sourcerygxx-4_1-30:1.43.2.1
	newlib-csl-coldfire-4_1-28:1.43.2.1
	newlib-csl-sourcerygxx-4_1-28:1.43.2.1
	newlib-csl-arm-2006q3-27:1.43.2.1
	newlib-csl-sourcerygxx-4_1-27:1.43.2.1
	newlib-csl-arm-2006q3-26:1.43.2.1
	newlib-csl-sourcerygxx-4_1-26:1.43.2.1
	newlib-csl-sourcerygxx-4_1-24:1.43.2.1
	newlib-csl-sourcerygxx-4_1-23:1.43.2.1
	newlib-csl-sourcerygxx-4_1-21:1.43.2.1
	newlib-csl-arm-2006q3-21:1.43.2.1
	newlib-csl-arm-2006q3-19:1.43
	newlib-csl-sourcerygxx-4_1-19:1.43
	newlib-csl-sourcerygxx-4_1-18:1.43
	newlib-csl-sourcerygxx-3_4_4-25:1.44
	newlib-csl-sourcerygxx-4_1-17:1.43
	cr-0x5f1:1.44.0.2
	newlib-csl-sourcerygxx-4_1-14:1.43
	newlib-csl-sourcerygxx-4_1-13:1.43
	newlib-csl-sourcerygxx-4_1-12:1.43
	newlib-csl-sourcerygxx-4_1-9:1.43
	newlib-csl-sourcerygxx-4_1-8:1.43
	newlib-csl-sourcerygxx-4_1-7:1.43
	newlib-csl-arm-2006q1-6:1.43
	newlib-csl-sourcerygxx-4_1-6:1.43
	newlib-csl-sourcerygxx-4_1-5:1.43
	newlib-csl-sourcerygxx-4_1-4:1.43
	newlib-autotools-branch:1.43.0.4
	newlib-csl-20060320-branch:1.43.0.2
	newlib-csl-20060320-branchpoint:1.43
	newlib-1_14_0:1.43
	newlib-csl-arm-2005-q1b:1.39
	newlib-csl-arm-2005-q1a:1.39
	newlib-1_13_0:1.37
	csl-arm-2004-q3:1.37
	csl-arm-2004-q1a:1.32
	csl-arm-2004-q1:1.29
	newlib-1_12_0:1.29
	csl-arm-2003-q4:1.26
	w32api-2_2:1.18
	mingw-runtime-2_4:1.18
	newlib-1_11_0:1.17
	cygnus_cvs_20020108_pre:1.11
	newlib-1_10_0:1.11
	newlib-1_9_0:1.8
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.88
date	2014.10.29.11.06.42;	author corinna;	state Exp;
branches;
next	1.87;

1.87
date	2013.06.19.15.58.50;	author corinna;	state Exp;
branches;
next	1.86;

1.86
date	2013.04.12.12.05.31;	author corinna;	state Exp;
branches;
next	1.85;

1.85
date	2013.03.27.09.38.39;	author corinna;	state Exp;
branches;
next	1.84;

1.84
date	2012.10.16.19.03.01;	author corinna;	state Exp;
branches;
next	1.83;

1.83
date	2012.10.16.18.45.24;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2012.08.08.11.04.17;	author corinna;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2012.05.30.08.58.42;	author corinna;	state Exp;
branches;
next	1.80;

1.80
date	2012.01.13.09.13.57;	author yselkowitz;	state Exp;
branches;
next	1.79;

1.79
date	2010.02.15.16.10.28;	author corinna;	state Exp;
branches;
next	1.78;

1.78
date	2010.02.05.08.35.35;	author corinna;	state Exp;
branches;
next	1.77;

1.77
date	2010.01.14.12.48.58;	author corinna;	state Exp;
branches;
next	1.76;

1.76
date	2009.11.18.09.49.56;	author corinna;	state Exp;
branches;
next	1.75;

1.75
date	2009.06.16.17.44.20;	author corinna;	state Exp;
branches;
next	1.74;

1.74
date	2009.03.11.11.53.22;	author corinna;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.06.09.55.52;	author corinna;	state Exp;
branches;
next	1.72;

1.72
date	2008.12.10.23.43.12;	author jjohnstn;	state Exp;
branches;
next	1.71;

1.71
date	2008.10.31.21.08.03;	author jjohnstn;	state Exp;
branches;
next	1.70;

1.70
date	2008.04.30.02.47.14;	author ericb;	state Exp;
branches;
next	1.69;

1.69
date	2008.04.14.21.14.55;	author jjohnstn;	state Exp;
branches;
next	1.68;

1.68
date	2007.12.19.17.06.19;	author corinna;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.13.15.26.20;	author ericb;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.17.20.14.29;	author ericb;	state Exp;
branches;
next	1.65;

1.65
date	2007.07.19.03.42.21;	author ericb;	state Exp;
branches;
next	1.64;

1.64
date	2007.07.13.20.37.53;	author ericb;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.27.14.19.15;	author ericb;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.24.04.25.18;	author ericb;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.23.20.36.28;	author ericb;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.18.14.33.30;	author ericb;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.14.19.42.47;	author ericb;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.11.20.09.00;	author ericb;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.11.13.09.44;	author ericb;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.08.03.59.13;	author ericb;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.04.02.55.16;	author ericb;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.25.19.47.36;	author jjohnstn;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.24.20.09.50;	author ericb;	state Exp;
branches;
next	1.52;

1.52
date	2007.04.24.19.55.28;	author ericb;	state Exp;
branches;
next	1.51;

1.51
date	2007.04.24.16.01.15;	author ericb;	state Exp;
branches;
next	1.50;

1.50
date	2007.04.23.21.55.31;	author jjohnstn;	state Exp;
branches;
next	1.49;

1.49
date	2007.04.13.01.57.33;	author ericb;	state Exp;
branches;
next	1.48;

1.48
date	2007.03.15.18.40.48;	author jjohnstn;	state Exp;
branches;
next	1.47;

1.47
date	2006.11.14.21.29.26;	author jjohnstn;	state Exp;
branches;
next	1.46;

1.46
date	2006.09.26.21.22.19;	author jjohnstn;	state Exp;
branches;
next	1.45;

1.45
date	2006.09.06.20.03.27;	author jjohnstn;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.14.20.49.11;	author jjohnstn;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2005.10.28.21.38.59;	author jjohnstn;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2005.10.14.21.03.13;	author jjohnstn;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.11.22.51.37;	author jjohnstn;	state Exp;
branches;
next	1.40;

1.40
date	2005.06.16.19.14.01;	author jjohnstn;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.21.22.34.35;	author jjohnstn;	state Exp;
branches;
next	1.38;

1.38
date	2005.02.08.01.33.17;	author jjohnstn;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.11.20.37.10;	author jjohnstn;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.27.14.56.54;	author jjohnstn;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.26.00.19.14;	author jjohnstn;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.11.20.59.20;	author jjohnstn;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.07.21.00.41;	author jjohnstn;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.03.20.17.59;	author jjohnstn;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.23.21.44.22;	author jjohnstn;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.23.20.01.55;	author jjohnstn;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.17.04.29.54;	author cgf;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.16.19.29.16;	author jjohnstn;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.15.19.12.17;	author jjohnstn;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.05.01.42.26;	author jjohnstn;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.24.18.39.04;	author jjohnstn;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.22.01.07.24;	author jjohnstn;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.19.17.07.36;	author jjohnstn;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.07.16.01.17;	author jjohnstn;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.06.00.50.57;	author jjohnstn;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.22.18.52.25;	author jjohnstn;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.29.20.45.11;	author jjohnstn;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.07.20.02.33;	author jjohnstn;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.23.01.56.03;	author fitzsim;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.09.21.12.09;	author jjohnstn;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.04.18.56.17;	author jjohnstn;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.20.19.51.35;	author fitzsim;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.08.00.12.48;	author fitzsim;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.27.23.55.56;	author jjohnstn;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.28.18.22.44;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.13.09.42.52;	author aoliva;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.23.19.49.09;	author jjohnstn;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.14.00.25.06;	author jjohnstn;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.08.00.27.39;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.06.23.50.11;	author jjohnstn;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.16.18.30.40;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.13.18.51.11;	author dj;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.17.17.10.16;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.21.16.59.23;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.82.2.1
date	2012.10.26.09.27.37;	author corinna;	state Exp;
branches;
next	;

1.44.2.1
date	2006.10.19.08.39.45;	author corinna;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2006.11.15.09.22.21;	author corinna;	state Exp;
branches;
next	1.44.2.3;

1.44.2.3
date	2007.11.14.15.57.45;	author corinna;	state Exp;
branches;
next	;

1.43.2.1
date	2006.09.27.19.57.14;	author pbrook;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.88
log
@	* libc/stdio/vfprintf.c (_VFPRINTF_R): Remove unnecessary comparison.
@
text
@/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
FUNCTION
<<vfprintf>>, <<vprintf>>, <<vsprintf>>, <<vsnprintf>>, <<vasprintf>>, <<vasnprintf>>---format argument list

INDEX
	vfprintf
INDEX
	_vfprintf_r
INDEX
	vprintf
INDEX
	_vprintf_r
INDEX
	vsprintf
INDEX
	_vsprintf_r
INDEX
	vsnprintf
INDEX
	_vsnprintf_r
INDEX
	vasprintf
INDEX
	_vasprintf_r
INDEX
	vasnprintf
INDEX
	_vasnprintf_r

ANSI_SYNOPSIS
	#include <stdio.h>
	#include <stdarg.h>
	int vprintf(const char *<[fmt]>, va_list <[list]>);
	int vfprintf(FILE *<[fp]>, const char *<[fmt]>, va_list <[list]>);
	int vsprintf(char *<[str]>, const char *<[fmt]>, va_list <[list]>);
	int vsnprintf(char *<[str]>, size_t <[size]>, const char *<[fmt]>,
                      va_list <[list]>);
	int vasprintf(char **<[strp]>, const char *<[fmt]>, va_list <[list]>);
	char *vasnprintf(char *<[str]>, size_t *<[size]>, const char *<[fmt]>,
                         va_list <[list]>);

	int _vprintf_r(struct _reent *<[reent]>, const char *<[fmt]>,
                        va_list <[list]>);
	int _vfprintf_r(struct _reent *<[reent]>, FILE *<[fp]>,
                        const char *<[fmt]>, va_list <[list]>);
	int _vsprintf_r(struct _reent *<[reent]>, char *<[str]>,
                        const char *<[fmt]>, va_list <[list]>);
	int _vasprintf_r(struct _reent *<[reent]>, char **<[str]>,
                         const char *<[fmt]>, va_list <[list]>);
	int _vsnprintf_r(struct _reent *<[reent]>, char *<[str]>,
                         size_t <[size]>, const char *<[fmt]>, va_list <[list]>);
	char *_vasnprintf_r(struct _reent *<[reent]>, char *<[str]>,
                            size_t *<[size]>, const char *<[fmt]>, va_list <[list]>);

DESCRIPTION
<<vprintf>>, <<vfprintf>>, <<vasprintf>>, <<vsprintf>>, <<vsnprintf>>,
and <<vasnprintf>> are (respectively) variants of <<printf>>,
<<fprintf>>, <<asprintf>>, <<sprintf>>, <<snprintf>>, and
<<asnprintf>>.  They differ only in allowing their caller to pass the
variable argument list as a <<va_list>> object (initialized by
<<va_start>>) rather than directly accepting a variable number of
arguments.  The caller is responsible for calling <<va_end>>.

<<_vprintf_r>>, <<_vfprintf_r>>, <<_vasprintf_r>>, <<_vsprintf_r>>,
<<_vsnprintf_r>>, and <<_vasnprintf_r>> are reentrant versions of the
above.

RETURNS
The return values are consistent with the corresponding functions.

PORTABILITY
ANSI C requires <<vprintf>>, <<vfprintf>>, <<vsprintf>>, and
<<vsnprintf>>.  The remaining functions are newlib extensions.

Supporting OS subroutines required: <<close>>, <<fstat>>, <<isatty>>,
<<lseek>>, <<read>>, <<sbrk>>, <<write>>.
*/

#if defined(LIBC_SCCS) && !defined(lint)
/*static char *sccsid = "from: @@(#)vfprintf.c	5.50 (Berkeley) 12/16/92";*/
static char *rcsid = "$Id: vfprintf.c,v 1.43 2002/08/13 02:40:06 fitzsim Exp $";
#endif /* LIBC_SCCS and not lint */

/*
 * Actual printf innards.
 *
 * This code is large and complicated...
 */
#include <newlib.h>

#ifdef INTEGER_ONLY
# define VFPRINTF vfiprintf
# ifdef STRING_ONLY
#   define _VFPRINTF_R _svfiprintf_r
# else
#   define _VFPRINTF_R _vfiprintf_r
# endif
#else
# define VFPRINTF vfprintf
# ifdef STRING_ONLY
#   define _VFPRINTF_R _svfprintf_r
# else
#   define _VFPRINTF_R _vfprintf_r
# endif
# ifndef NO_FLOATING_POINT
#  define FLOATING_POINT
# endif
#endif

#define _NO_POS_ARGS
#ifdef _WANT_IO_POS_ARGS
# undef _NO_POS_ARGS
#endif

#include <_ansi.h>
#include <reent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <stdint.h>
#include <wchar.h>
#include <sys/lock.h>
#include <stdarg.h>
#include "local.h"
#include "../stdlib/local.h"
#include "fvwrite.h"
#include "vfieeefp.h"

/* Currently a test is made to see if long double processing is warranted.
   This could be changed in the future should the _ldtoa_r code be
   preferred over _dtoa_r.  */
#define _NO_LONGDBL
#if defined _WANT_IO_LONG_DOUBLE && (LDBL_MANT_DIG > DBL_MANT_DIG)
#undef _NO_LONGDBL
#endif

#define _NO_LONGLONG
#if defined _WANT_IO_LONG_LONG \
	&& (defined __GNUC__ || __STDC_VERSION__ >= 199901L)
# undef _NO_LONGLONG
#endif

#ifdef STRING_ONLY
# ifdef _FVWRITE_IN_STREAMIO
#  define __SPRINT __ssprint_r
# else
#  define __SPRINT __ssputs_r
# endif
#else
# ifdef _FVWRITE_IN_STREAMIO
#  define __SPRINT __sprint_r
# else
#  define __SPRINT __sfputs_r
# endif
#endif

/* The __sprint_r/__ssprint_r functions are shared between all versions of
   vfprintf and vfwprintf.  They must only be defined once, which we do in
   the INTEGER_ONLY versions here. */
#ifdef STRING_ONLY
#ifdef INTEGER_ONLY
#ifndef _FVWRITE_IN_STREAMIO
int
_DEFUN(__ssputs_r, (ptr, fp, buf, len),
       struct _reent *ptr _AND
       FILE *fp _AND
       _CONST char *buf _AND
       size_t len)
{
	register int w;

	w = fp->_w;
	if (len >= w && fp->_flags & (__SMBF | __SOPT)) {
		/* must be asprintf family */
		unsigned char *str;
		int curpos = (fp->_p - fp->_bf._base);
		/* Choose a geometric growth factor to avoid
	 	 * quadratic realloc behavior, but use a rate less
		 * than (1+sqrt(5))/2 to accomodate malloc
	 	 * overhead. asprintf EXPECTS us to overallocate, so
	 	 * that it can add a trailing \0 without
	 	 * reallocating.  The new allocation should thus be
	 	 * max(prev_size*1.5, curpos+len+1). */
		int newsize = fp->_bf._size * 3 / 2;
		if (newsize < curpos + len + 1)
			newsize = curpos + len + 1;
		if (fp->_flags & __SOPT)
		{
			/* asnprintf leaves original buffer alone.  */
			str = (unsigned char *)_malloc_r (ptr, newsize);
			if (!str)
			{
				ptr->_errno = ENOMEM;
				goto err;
			}
			memcpy (str, fp->_bf._base, curpos);
			fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
		}
		else
		{
			str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
					newsize);
			if (!str) {
				/* Free unneeded buffer.  */
				_free_r (ptr, fp->_bf._base);
				/* Ensure correct errno, even if free
				 * changed it.  */
				ptr->_errno = ENOMEM;
				goto err;
			}
		}
		fp->_bf._base = str;
		fp->_p = str + curpos;
		fp->_bf._size = newsize;
		w = len;
		fp->_w = newsize - curpos;
	}
	if (len < w)
		w = len;
	(void)memmove ((_PTR) fp->_p, (_PTR) buf, (size_t) (w));
	fp->_w -= w;
	fp->_p += w;

	return 0;

err:
	fp->_flags |= __SERR;
	return EOF;
}
#endif

int
_DEFUN(__ssprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
	register size_t len;
	register int w;
	register struct __siov *iov;
	register _CONST char *p = NULL;

	iov = uio->uio_iov;
	len = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}

        do {
		while (len == 0) {
			p = iov->iov_base;
			len = iov->iov_len;
			iov++;
		}
		w = fp->_w;
		if (len >= w && fp->_flags & (__SMBF | __SOPT)) {
			/* must be asprintf family */
			unsigned char *str;
			int curpos = (fp->_p - fp->_bf._base);
			/* Choose a geometric growth factor to avoid
		 	 * quadratic realloc behavior, but use a rate less
			 * than (1+sqrt(5))/2 to accomodate malloc
		 	 * overhead. asprintf EXPECTS us to overallocate, so
		 	 * that it can add a trailing \0 without
		 	 * reallocating.  The new allocation should thus be
		 	 * max(prev_size*1.5, curpos+len+1). */
			int newsize = fp->_bf._size * 3 / 2;
			if (newsize < curpos + len + 1)
				newsize = curpos + len + 1;
			if (fp->_flags & __SOPT)
			{
				/* asnprintf leaves original buffer alone.  */
				str = (unsigned char *)_malloc_r (ptr, newsize);
				if (!str)
				{
					ptr->_errno = ENOMEM;
					goto err;
				}
				memcpy (str, fp->_bf._base, curpos);
				fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
			}
			else
			{
				str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
						newsize);
				if (!str) {
					/* Free unneeded buffer.  */
					_free_r (ptr, fp->_bf._base);
					/* Ensure correct errno, even if free
					 * changed it.  */
					ptr->_errno = ENOMEM;
					goto err;
				}
			}
			fp->_bf._base = str;
			fp->_p = str + curpos;
			fp->_bf._size = newsize;
			w = len;
			fp->_w = newsize - curpos;
		}
		if (len < w)
			w = len;
		(void)memmove ((_PTR) fp->_p, (_PTR) p, (size_t) (w));
		fp->_w -= w;
		fp->_p += w;
		w = len;          /* pretend we copied all */
		p += w;
		len -= w;
        } while ((uio->uio_resid -= w) != 0);

	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return 0;

err:
  fp->_flags |= __SERR;
  uio->uio_resid = 0;
  uio->uio_iovcnt = 0;
  return EOF;
}
#else /* !INTEGER_ONLY */
#ifndef _FVWRITE_IN_STREAMIO
int __ssputs_r (struct _reent *, FILE *, _CONST char *, size_t);
#endif
int __ssprint_r (struct _reent *, FILE *, register struct __suio *);
#endif /* !INTEGER_ONLY */

#else /* !STRING_ONLY */
#ifdef INTEGER_ONLY

#ifndef _FVWRITE_IN_STREAMIO
int
_DEFUN(__sfputs_r, (ptr, fp, buf, len),
       struct _reent *ptr _AND
       FILE *fp _AND
       _CONST char *buf _AND
       size_t len)
{
	register int i;

#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
		wchar_t *p;

		p = (wchar_t *) buf;
		for (i = 0; i < (len / sizeof (wchar_t)); i++) {
			if (_fputwc_r (ptr, p[i], fp) == WEOF)
				return -1;
		}
	} else {
#else
	{
#endif
		for (i = 0; i < len; i++) {
			if (_fputc_r (ptr, buf[i], fp) == EOF)
				return -1;
		}
	}
	return (0);
}
#endif
/*
 * Flush out all the vectors defined by the given uio,
 * then reset it so that it can be reused.
 */
int
_DEFUN(__sprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
					err = -1;
					goto out;
				}
			}
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return (err);
}
#else /* !INTEGER_ONLY */
#ifndef _FVWRITE_IN_STREAMIO
int __sfputs_r (struct _reent *, FILE *, _CONST char *buf, size_t);
#endif
int __sprint_r (struct _reent *, FILE *, register struct __suio *);
#endif /* !INTEGER_ONLY */

#ifdef _UNBUF_STREAM_OPT
/*
 * Helper function for `fprintf to unbuffered unix file': creates a
 * temporary buffer.  We only work on write-only files; this avoids
 * worries about ungetc buffers and so forth.
 *
 * Make sure to avoid inlining.
 */
_NOINLINE_STATIC int
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
	fake._flags2 = fp->_flags2;
	fake._file = fp->_file;
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
	fake._bf._size = fake._w = sizeof (buf);
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
	if (ret >= 0 && _fflush_r (rptr, &fake))
		ret = EOF;
	if (fake._flags & __SERR)
		fp->_flags |= __SERR;

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
}
#endif /* _UNBUF_STREAM_OPT */
#endif /* !STRING_ONLY */


#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
# include <locale.h>
#endif
#ifdef FLOATING_POINT
# include <math.h>

/* For %La, an exponent of 15 bits occupies the exponent character, a
   sign, and up to 5 digits.  */
# define MAXEXPLEN		7
# define DEFPREC		6

# ifdef _NO_LONGDBL

extern char *_dtoa_r _PARAMS((struct _reent *, double, int,
			      int, int *, int *, char **));

#  define _PRINTF_FLOAT_TYPE double
#  define _DTOA_R _dtoa_r
#  define FREXP frexp

# else /* !_NO_LONGDBL */

extern char *_ldtoa_r _PARAMS((struct _reent *, _LONG_DOUBLE, int,
			      int, int *, int *, char **));

extern int _EXFUN(_ldcheck,(_LONG_DOUBLE *));

#  define _PRINTF_FLOAT_TYPE _LONG_DOUBLE
#  define _DTOA_R _ldtoa_r
/* FIXME - frexpl is not yet supported; and cvt infloops if (double)f
   converts a finite value into infinity.  */
/* #  define FREXP frexpl */
#  define FREXP(f,e) ((_LONG_DOUBLE) frexp ((double)f, e))
# endif /* !_NO_LONGDBL */

static char *cvt(struct _reent *, _PRINTF_FLOAT_TYPE, int, int, char *, int *,
                 int, int *, char *);

static int exponent(char *, int, int);

#endif /* FLOATING_POINT */

/* BUF must be big enough for the maximum %#llo (assuming long long is
   at most 64 bits, this would be 23 characters), the maximum
   multibyte character %C, and the maximum default precision of %La
   (assuming long double is at most 128 bits with 113 bits of
   mantissa, this would be 29 characters).  %e, %f, and %g use
   reentrant storage shared with mprec.  All other formats that use
   buf get by with fewer characters.  Making BUF slightly bigger
   reduces the need for malloc in %.*a and %S, when large precision or
   long strings are processed.
   The bigger size of 100 bytes is used on systems which allow number
   strings using the locale's grouping character.  Since that's a multibyte
   value, we should use a conservative value.
   */
#ifdef _WANT_IO_C99_FORMATS
#define	BUF		100
#else
#define	BUF		40
#endif
#if defined _MB_CAPABLE && MB_LEN_MAX > BUF
# undef BUF
# define BUF MB_LEN_MAX
#endif

#ifndef _NO_LONGLONG
# define quad_t long long
# define u_quad_t unsigned long long
#else
# define quad_t long
# define u_quad_t unsigned long
#endif

typedef quad_t * quad_ptr_t;
typedef _PTR     void_ptr_t;
typedef char *   char_ptr_t;
typedef long *   long_ptr_t;
typedef int  *   int_ptr_t;
typedef short *  short_ptr_t;

#ifndef _NO_POS_ARGS
# ifdef NL_ARGMAX
#  define MAX_POS_ARGS NL_ARGMAX
# else
#  define MAX_POS_ARGS 32
# endif

union arg_val
{
  int val_int;
  u_int val_u_int;
  long val_long;
  u_long val_u_long;
  float val_float;
  double val_double;
  _LONG_DOUBLE val__LONG_DOUBLE;
  int_ptr_t val_int_ptr_t;
  short_ptr_t val_short_ptr_t;
  long_ptr_t val_long_ptr_t;
  char_ptr_t val_char_ptr_t;
  quad_ptr_t val_quad_ptr_t;
  void_ptr_t val_void_ptr_t;
  quad_t val_quad_t;
  u_quad_t val_u_quad_t;
  wint_t val_wint_t;
};

static union arg_val *
_EXFUN(get_arg, (struct _reent *data, int n, char *fmt,
                 va_list *ap, int *numargs, union arg_val *args,
                 int *arg_type, char **last_fmt));
#endif /* !_NO_POS_ARGS */

/*
 * Macros for converting digits to letters and vice versa
 */
#define	to_digit(c)	((c) - '0')
#define is_digit(c)	((unsigned)to_digit (c) <= 9)
#define	to_char(n)	((n) + '0')

/*
 * Flags used during conversion.
 */
#define	ALT		0x001		/* alternate form */
#define	HEXPREFIX	0x002		/* add 0x or 0X prefix */
#define	LADJUST		0x004		/* left adjustment */
#define	LONGDBL		0x008		/* long double */
#define	LONGINT		0x010		/* long integer */
#ifndef _NO_LONGLONG
# define QUADINT	0x020		/* quad integer */
#else /* ifdef _NO_LONGLONG, make QUADINT equivalent to LONGINT, so
	 that %lld behaves the same as %ld, not as %d, as expected if:
	 sizeof (long long) = sizeof long > sizeof int  */
# define QUADINT	LONGINT
#endif
#define	SHORTINT	0x040		/* short integer */
#define	ZEROPAD		0x080		/* zero (as opposed to blank) pad */
#define FPT		0x100		/* Floating point number */
#ifdef _WANT_IO_C99_FORMATS
# define CHARINT	0x200		/* char as integer */
#else /* define as 0, to make SARG and UARG occupy fewer instructions  */
# define CHARINT	0
#endif
#ifdef _WANT_IO_C99_FORMATS
# define GROUPING	0x400		/* use grouping ("'" flag) */
#endif

int _EXFUN(_VFPRINTF_R, (struct _reent *, FILE *, _CONST char *, va_list));

#ifndef STRING_ONLY
int
_DEFUN(VFPRINTF, (fp, fmt0, ap),
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
  return result;
}
#endif /* STRING_ONLY */

int
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
	register char *fmt;	/* format string */
	register int ch;	/* character from fmt */
	register int n, m;	/* handy integers (short term usage) */
	register char *cp;	/* handy char pointer (short term usage) */
	register int flags;	/* flags as above */
	char *fmt_anchor;       /* current format spec being processed */
#ifndef _NO_POS_ARGS
	int N;                  /* arg number */
	int arg_index;          /* index into args processed directly */
	int numargs;            /* number of varargs read */
	char *saved_fmt;        /* saved fmt pointer */
	union arg_val args[MAX_POS_ARGS];
	int arg_type[MAX_POS_ARGS];
	int is_pos_arg;         /* is current format positional? */
	int old_is_pos_arg;     /* is current format positional? */
#endif
	int ret;		/* return value accumulator */
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format (%.3d), or -1 */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */
#ifdef _WANT_IO_C99_FORMATS
				/* locale specific numeric grouping */
	char *thousands_sep = NULL;
	size_t thsnd_len = 0;
	const char *grouping = NULL;
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
	size_t decp_len = strlen (decimal_point);
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
#endif
#if defined (FLOATING_POINT) && defined (_WANT_IO_C99_FORMATS)
	int nseps;		/* number of group separators with ' */
	int nrepeats;		/* number of repeats of the last group */
#endif
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
#ifdef _FVWRITE_IN_STREAMIO
#define NIOV 8
	struct __suio uio;	/* output information: summary */
	struct __siov iov[NIOV];/* ... and individual io vectors */
	register struct __siov *iovp;/* for PRINT macro */
#endif
	char buf[BUF];		/* space for %c, %S, %[diouxX], %[aA] */
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */

	/*
	 * Choose PADSIZE to trade efficiency vs. size.  If larger printf
	 * fields occur frequently, increase PADSIZE and make the initialisers
	 * below longer.
	 */
#define	PADSIZE	16		/* pad chunk size */
	static _CONST char blanks[PADSIZE] =
	 {' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '};
	static _CONST char zeroes[PADSIZE] =
	 {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'};

#ifdef _MB_CAPABLE
	memset (&state, '\0', sizeof (state));
#endif
	/*
	 * BEWARE, these `goto error' on error, and PAD uses `n'.
	 */
#ifdef _FVWRITE_IN_STREAMIO
#define	PRINT(ptr, len) { \
	iovp->iov_base = (ptr); \
	iovp->iov_len = (len); \
	uio.uio_resid += (len); \
	iovp++; \
	if (++uio.uio_iovcnt >= NIOV) { \
		if (__SPRINT(data, fp, &uio)) \
			goto error; \
		iovp = iov; \
	} \
}
#define	PAD(howmany, with) { \
	if ((n = (howmany)) > 0) { \
		while (n > PADSIZE) { \
			PRINT (with, PADSIZE); \
			n -= PADSIZE; \
		} \
		PRINT (with, n); \
	} \
}
#define PRINTANDPAD(p, ep, len, with) { \
	int n = (ep) - (p); \
	if (n > (len)) \
		n = (len); \
	if (n > 0) \
		PRINT((p), n); \
	PAD((len) - (n > 0 ? n : 0), (with)); \
}
#define	FLUSH() { \
	if (uio.uio_resid && __SPRINT(data, fp, &uio)) \
		goto error; \
	uio.uio_iovcnt = 0; \
	iovp = iov; \
}
#else
#define PRINT(ptr, len) {		\
	if (__SPRINT (data, fp, (ptr), (len)) == EOF) \
		goto error;		\
}
#define	PAD(howmany, with) {		\
	if ((n = (howmany)) > 0) {	\
		while (n > PADSIZE) {	\
			PRINT (with, PADSIZE);	\
			n -= PADSIZE;	\
		}			\
		PRINT (with, n);	\
	}				\
}
#define PRINTANDPAD(p, ep, len, with) {	\
	int n = (ep) - (p);		\
	if (n > (len))			\
		n = (len);		\
	if (n > 0)			\
		PRINT((p), n);		\
	PAD((len) - (n > 0 ? n : 0), (with)); \
}
#define FLUSH()
#endif

	/* Macros to support positional arguments */
#ifndef _NO_POS_ARGS
# define GET_ARG(n, ap, type)						\
	(is_pos_arg							\
	 ? (n < numargs							\
	    ? args[n].val_##type					\
	    : get_arg (data, n, fmt_anchor, &ap, &numargs, args,	\
		       arg_type, &saved_fmt)->val_##type)		\
	 : (arg_index++ < numargs					\
	    ? args[n].val_##type					\
	    : (numargs < MAX_POS_ARGS					\
	       ? args[numargs++].val_##type = va_arg (ap, type)		\
	       : va_arg (ap, type))))
#else
# define GET_ARG(n, ap, type) (va_arg (ap, type))
#endif

	/*
	 * To extend shorts properly, we need both signed and unsigned
	 * argument extraction methods.
	 */
#ifndef _NO_LONGLONG
#define	SARG() \
	(flags&QUADINT ? GET_ARG (N, ap, quad_t) : \
	    flags&LONGINT ? GET_ARG (N, ap, long) : \
	    flags&SHORTINT ? (long)(short)GET_ARG (N, ap, int) : \
	    flags&CHARINT ? (long)(signed char)GET_ARG (N, ap, int) : \
	    (long)GET_ARG (N, ap, int))
#define	UARG() \
	(flags&QUADINT ? GET_ARG (N, ap, u_quad_t) : \
	    flags&LONGINT ? GET_ARG (N, ap, u_long) : \
	    flags&SHORTINT ? (u_long)(u_short)GET_ARG (N, ap, int) : \
	    flags&CHARINT ? (u_long)(unsigned char)GET_ARG (N, ap, int) : \
	    (u_long)GET_ARG (N, ap, u_int))
#else
#define	SARG() \
	(flags&LONGINT ? GET_ARG (N, ap, long) : \
	    flags&SHORTINT ? (long)(short)GET_ARG (N, ap, int) : \
	    flags&CHARINT ? (long)(signed char)GET_ARG (N, ap, int) : \
	    (long)GET_ARG (N, ap, int))
#define	UARG() \
	(flags&LONGINT ? GET_ARG (N, ap, u_long) : \
	    flags&SHORTINT ? (u_long)(u_short)GET_ARG (N, ap, int) : \
	    flags&CHARINT ? (u_long)(unsigned char)GET_ARG (N, ap, int) : \
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
		_newlib_flockfile_exit (fp);
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
	}
#endif
#else /* STRING_ONLY */
        /* Create initial buffer if we are called by asprintf family.  */
        if (fp->_flags & __SMBF && !fp->_bf._base)
        {
		fp->_bf._base = fp->_p = _malloc_r (data, 64);
		if (!fp->_p)
		{
			data->_errno = ENOMEM;
			return EOF;
		}
		fp->_bf._size = 64;
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
	uio.uio_resid = 0;
	uio.uio_iovcnt = 0;
#endif
	ret = 0;
#ifndef _NO_POS_ARGS
	arg_index = 0;
	saved_fmt = NULL;
	arg_type[0] = -1;
	numargs = 0;
	is_pos_arg = 0;
#endif

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
#ifdef _MB_CAPABLE
	        while ((n = __mbtowc (data, &wc, fmt, MB_CUR_MAX,
				      __locale_charset (), &state)) != 0) {
		    if (n < 0) {
			/* Wave invalid chars through. */
			memset (&state, 0, sizeof state);
			n = 1;
		    }
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
			ret += m;
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
#ifdef _WANT_IO_C99_FORMATS
		nseps = nrepeats = 0;
#endif
#endif
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
#ifdef _WANT_IO_C99_FORMATS
		case '\'':
			thousands_sep = _localeconv_r (data)->thousands_sep;
			thsnd_len = strlen (thousands_sep);
			grouping = _localeconv_r (data)->grouping;
			if (thsnd_len > 0 && grouping && *grouping)
			  flags |= GROUPING;
			goto rflag;
#endif
		case ' ':
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
				sign = ' ';
			goto rflag;
		case '#':
			flags |= ALT;
			goto rflag;
		case '*':
#ifndef _NO_POS_ARGS
			/* we must check for positional arg used for dynamic width */
			n = N;
			old_is_pos_arg = is_pos_arg;
			is_pos_arg = 0;
			if (is_digit (*fmt)) {
				char *old_fmt = fmt;

				n = 0;
				ch = *fmt++;
				do {
					n = 10 * n + to_digit (ch);
					ch = *fmt++;
				} while (is_digit (ch));

				if (ch == '$') {
					if (n <= MAX_POS_ARGS) {
						n -= 1;
						is_pos_arg = 1;
					}
					else
						goto error;
				}
				else {
					fmt = old_fmt;
					goto rflag;
				}
			}
#endif /* !_NO_POS_ARGS */

			/*
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
				goto rflag;
			width = -width;
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
#ifndef _NO_POS_ARGS
				/* we must check for positional arg used for dynamic width */
				n = N;
				old_is_pos_arg = is_pos_arg;
				is_pos_arg = 0;
				if (is_digit (*fmt)) {
					char *old_fmt = fmt;

					n = 0;
					ch = *fmt++;
					do {
						n = 10 * n + to_digit (ch);
						ch = *fmt++;
					} while (is_digit (ch));

					if (ch == '$') {
						if (n <= MAX_POS_ARGS) {
							n -= 1;
							is_pos_arg = 1;
						}
						else
							goto error;
					}
					else {
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
			goto reswitch;
		case '0':
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			} while (is_digit (ch));
#ifndef _NO_POS_ARGS
			if (ch == '$') {
				if (n <= MAX_POS_ARGS) {
					N = n - 1;
					is_pos_arg = 1;
					goto rflag;
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
			goto reswitch;
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
			goto rflag;
#endif
		case 'h':
#ifdef _WANT_IO_C99_FORMATS
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
			goto rflag;
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
				fmt++;
				flags |= QUADINT;
			} else
#endif
				flags |= LONGINT;
			goto rflag;
		case 'q': /* extension */
			flags |= QUADINT;
			goto rflag;
#ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
		  goto rflag;
		case 'z':
		  if (sizeof (size_t) < sizeof (int))
		    /* POSIX states size_t is 16 or more bits, as is short.  */
		    flags |= SHORTINT;
		  else if (sizeof (size_t) == sizeof (int))
		    /* no flag needed */;
		  else if (sizeof (size_t) <= sizeof (long))
		    flags |= LONGINT;
		  else
		    /* POSIX states that at least one programming
		       environment must support size_t no wider than
		       long, but that means other environments can
		       have size_t as wide as long long.  */
		    flags |= QUADINT;
		  goto rflag;
		case 't':
		  if (sizeof (ptrdiff_t) < sizeof (int))
		    /* POSIX states ptrdiff_t is 16 or more bits, as
		       is short.  */
		    flags |= SHORTINT;
		  else if (sizeof (ptrdiff_t) == sizeof (int))
		    /* no flag needed */;
		  else if (sizeof (ptrdiff_t) <= sizeof (long))
		    flags |= LONGINT;
		  else
		    /* POSIX states that at least one programming
		       environment must support ptrdiff_t no wider than
		       long, but that means other environments can
		       have ptrdiff_t as wide as long long.  */
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
#ifdef _MB_CAPABLE
			if (ch == 'C' || (flags & LONGINT)) {
				mbstate_t ps;

				memset ((_PTR)&ps, '\0', sizeof (mbstate_t));
				if ((size = (int)_wcrtomb_r (data, cp,
					       (wchar_t)GET_ARG (N, ap, wint_t),
						&ps)) == -1) {
					fp->_flags |= __SERR;
					goto error;
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
				sign = '-';
			}
			base = DEC;
			goto number;
#ifdef FLOATING_POINT
# ifdef _WANT_IO_C99_FORMATS
		case 'a':
		case 'A':
		case 'F':
# endif
		case 'e':
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
			} else {
				_fpvalue = GET_ARG (N, ap, double);
			}

			/* do this before tricky precision changes

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
				if (_fpvalue < 0)
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}

# else /* !_NO_LONGDBL */

			if (flags & LONGDBL) {
				_fpvalue = GET_ARG (N, ap, _LONG_DOUBLE);
			} else {
				_fpvalue = (_LONG_DOUBLE)GET_ARG (N, ap, double);
			}

			/* do this before tricky precision changes */
			expt = _ldcheck (&_fpvalue);
			if (expt == 2) {
				if (_fpvalue < 0)
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (expt == 1) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
# endif /* !_NO_LONGDBL */

# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
				  {
				    if ((malloc_buf =
					 (char *)_malloc_r (data, prec + 1))
					== NULL)
				      {
					fp->_flags |= __SERR;
					goto error;
				      }
				    cp = malloc_buf;
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
					ch -= 2; /* 'e' or 'E' */
				else
					ch = 'g';
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
					++size;
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
						1 : 2 - expt);
# ifdef _WANT_IO_C99_FORMATS
				if ((flags & GROUPING) && expt > 0) {
					/* space for thousands' grouping */
					nseps = nrepeats = 0;
					lead = expt;
					while (*grouping != CHAR_MAX) {
						if (lead <= *grouping)
							break;
						lead -= *grouping;
						if (grouping[1]) {
							nseps++;
							grouping++;
						} else
							nrepeats++;
					}
					size += (nseps + nrepeats) * thsnd_len;
				} else
# endif
					lead = expt;
			}

			if (softsign)
				sign = '-';
			break;
#endif /* FLOATING_POINT */
#ifdef _GLIBC_EXTENSION
		case 'm':  /* extension */
			{
				int dummy;
				cp = _strerror_r (data, data->_errno, 1, &dummy);
			}
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
				*GET_ARG (N, ap, short_ptr_t) = ret;
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
			base = OCT;
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			goto nosign;
		case 'p':
			/*
			 * ``The argument shall be a pointer to void.  The
			 * value of the pointer is converted to a sequence
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
				size = ((unsigned) prec > 6U) ? 6 : prec;
			}
			else
#endif /* __OPTIMIZE_SIZE__ */
#ifdef _MB_CAPABLE
			if (ch == 'S' || (flags & LONGINT)) {
				mbstate_t ps;
				_CONST wchar_t *wcp;

				wcp = (_CONST wchar_t *)cp;
				size = m = 0;
				memset ((_PTR)&ps, '\0', sizeof (mbstate_t));

				/* Count number of bytes needed for multibyte
				   string that will be produced from widechar
				   string.  */
				if (prec >= 0) {
					while (1) {
						if (wcp[m] == L'\0')
							break;
						if ((n = (int)_wcrtomb_r (data,
						     buf, wcp[m], &ps)) == -1) {
							fp->_flags |= __SERR;
							goto error;
						}
						if (n + size > prec)
							break;
						m += 1;
						size += n;
						if (size == prec)
							break;
					}
				}
				else {
					if ((size = (int)_wcsrtombs_r (data,
						   NULL, &wcp, 0, &ps)) == -1) {
						fp->_flags |= __SERR;
						goto error;
					}
					wcp = (_CONST wchar_t *)cp;
				}

				if (size == 0)
					break;

				if (size >= BUF) {
					if ((malloc_buf =
					     (char *)_malloc_r (data, size + 1))
					    == NULL) {
						fp->_flags |= __SERR;
						goto error;
					}
					cp = malloc_buf;
				} else
					cp = buf;

				/* Convert widechar string to multibyte string. */
				memset ((_PTR)&ps, '\0', sizeof (mbstate_t));
				if (_wcsrtombs_r (data, cp, &wcp, size, &ps)
				    != size) {
					fp->_flags |= __SERR;
					goto error;
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
				ox[1] = ch;
				flags |= HEXPREFIX;
			}

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
				flags &= ~ZEROPAD;

			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
						_uquad >>= 3;
					} while (_uquad);
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
						*--cp = to_char(_uquad);
						break;
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
#ifdef _WANT_IO_C99_FORMATS
					  ndig++;
					  /* If (*grouping == CHAR_MAX) then no
					     more grouping */
					  if ((flags & GROUPING)
					      && ndig == *grouping
					      && *grouping != CHAR_MAX
					      && _uquad > 9) {
					    cp -= thsnd_len;
					    strncpy (cp, thousands_sep,
						     thsnd_len);
					    ndig = 0;
					    /* If (grouping[1] == '\0') then we
					       have to use *grouping character
					       (last grouping rule) for all
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
						_uquad >>= 4;
					} while (_uquad);
					break;

				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
                       /*
			* ...result is to be converted to an 'alternate form'.
			* For o conversion, it increases the precision to force
			* the first digit of the result to be a zero."
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
		}

		/*
		 * All reasonable formats wind up here.  At this point, `cp'
		 * points to a string which (if not flags&LADJUST) should be
		 * padded out to `width' places.  If flags&ZEROPAD, it should
		 * first be prefixed by any sign or other prefix; otherwise,
		 * it should be blank padded before the prefix is emitted.
		 * After any left-hand padding and prefixing, emit zeroes
		 * required by a decimal [diouxX] precision, then print the
		 * string proper, then emit zeroes required by any leftover
		 * floating precision; finally, if LADJUST, pad with blanks.
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
			realsz++;
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
			PRINT (cp, size);
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
				if (_fpvalue == 0) {
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
						    lead, zeroes);
					cp += lead;
#ifdef _WANT_IO_C99_FORMATS
					if (flags & GROUPING) {
					    while (nseps > 0 || nrepeats > 0) {
						if (nrepeats > 0)
						    nrepeats--;
						else {
						    grouping--;
						    nseps--;
						}
						PRINT(thousands_sep, thsnd_len);
						PRINTANDPAD (cp, convbuf + ndig,
							     *grouping, zeroes);
						cp += *grouping;
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */

                if (malloc_buf != NULL) {
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
error:
	if (malloc_buf != NULL)
		_free_r (data, malloc_buf);
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
	/* NOTREACHED */
}

#ifdef FLOATING_POINT

/* Using reentrant DATA, convert finite VALUE into a string of digits
   with no decimal point, using NDIGITS precision and FLAGS as guides
   to whether trailing zeros must be included.  Set *SIGN to nonzero
   if VALUE was negative.  Set *DECPT to the exponent plus one.  Set
   *LENGTH to the length of the returned string.  CH must be one of
   [aAeEfFgG]; if it is [aA], then the return string lives in BUF,
   otherwise the return value shares the mprec reentrant storage.  */
static char *
cvt(struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
    char *sign, int *decpt, int ch, int *length, char *buf)
{
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
		*sign = '-';
	} else
		*sign = '\000';
# else /* !_NO_LONGDBL */
	union
	{
	  struct ldieee ieee;
	  _LONG_DOUBLE val;
	} ld;

	ld.val = value;
	if (ld.ieee.sign) { /* this will check for < 0 and -0.0 */
		value = -value;
		*sign = '-';
	} else
		*sign = '\000';
# endif /* !_NO_LONGDBL */

# ifdef _WANT_IO_C99_FORMATS
	if (ch == 'a' || ch == 'A') {
		/* This code assumes FLT_RADIX is a power of 2.  The initial
		   division ensures the digit before the decimal will be less
		   than FLT_RADIX (unless it is rounded later).	 There is no
		   loss of precision in these calculations.  */
		value = FREXP (value, decpt) / 8;
		if (!value)
			*decpt = 1;
		digits = ch == 'a' ? "0123456789abcdef" : "0123456789ABCDEF";
		bp = buf;
		do {
			value *= 16;
			mode = (int) value;
			value -= mode;
			*bp++ = digits[mode];
		} while (ndigits-- && value);
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
			/* round to even */
			rve = bp;
			while (*--rve == digits[0xf]) {
				*rve = '0';
			}
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
		} else {
			while (ndigits-- >= 0) {
				*bp++ = '0';
			}
		}
		*length = bp - buf;
		return buf;
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
		mode = 3;		/* ndigits after the decimal point */
	} else {
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
			*rve++ = '0';
	}
	*length = rve - digits;
	return (digits);
}

static int
exponent(char *p0, int exp, int fmtch)
{
	register char *p, *t;
	char expbuf[MAXEXPLEN];
# ifdef _WANT_IO_C99_FORMATS
	int isa = fmtch == 'a' || fmtch == 'A';
# else
#  define isa 0
# endif

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
	if (exp < 0) {
		exp = -exp;
		*p++ = '-';
	}
	else
		*p++ = '+';
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
		do {
			*--t = to_char (exp % 10);
		} while ((exp /= 10) > 9);
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
	}
	else {
		if (!isa)
			*p++ = '0';
		*p++ = to_char (exp);
	}
	return (p - p0);
}
#endif /* FLOATING_POINT */


#ifndef _NO_POS_ARGS

/* Positional argument support.
   Written by Jeff Johnston

   Copyright (c) 2002 Red Hat Incorporated.
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

      Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

      Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

      The name of Red Hat Incorporated may not be used to endorse
      or promote products derived from this software without specific
      prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED.  IN NO EVENT SHALL RED HAT INCORPORATED BE LIABLE FOR ANY
   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/* The below constant state tables are shared between all versions of
   vfprintf and vfwprintf.  They must only be defined once, which we do in
   the STRING_ONLY/INTEGER_ONLY versions here. */
#if defined (STRING_ONLY) && defined(INTEGER_ONLY)

_CONST __CH_CLASS __chclass[256] = {
  /* 00-07 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* 08-0f */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* 10-17 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* 18-1f */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* 20-27 */  FLAG,    OTHER,   OTHER,   FLAG,    DOLLAR,  OTHER,   OTHER,   FLAG,
  /* 28-2f */  OTHER,   OTHER,   STAR,    FLAG,    OTHER,   FLAG,    DOT,     OTHER,
  /* 30-37 */  ZERO,    DIGIT,   DIGIT,   DIGIT,   DIGIT,   DIGIT,   DIGIT,   DIGIT,
  /* 38-3f */  DIGIT,   DIGIT,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* 40-47 */  OTHER,   SPEC,    OTHER,   SPEC,    SPEC,    SPEC,    SPEC,    SPEC,
  /* 48-4f */  OTHER,   OTHER,   OTHER,   OTHER,   MODFR,   OTHER,   OTHER,   SPEC,
  /* 50-57 */  OTHER,   OTHER,   OTHER,   SPEC,    OTHER,   SPEC,    OTHER,   OTHER,
  /* 58-5f */  SPEC,    OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* 60-67 */  OTHER,   SPEC,    OTHER,   SPEC,    SPEC,    SPEC,    SPEC,    SPEC,
  /* 68-6f */  MODFR,   SPEC,    MODFR,   OTHER,   MODFR,   OTHER,   SPEC,    SPEC,
  /* 70-77 */  SPEC,    MODFR,   OTHER,   SPEC,    MODFR,   SPEC,    OTHER,   OTHER,
  /* 78-7f */  SPEC,    OTHER,   MODFR,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* 80-87 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* 88-8f */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* 90-97 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* 98-9f */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* a0-a7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* a8-af */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* b0-b7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* b8-bf */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* c0-c7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* c8-cf */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* d0-d7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* d8-df */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* e0-e7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* e8-ef */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* f0-f7 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
  /* f8-ff */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
};

_CONST __STATE __state_table[MAX_STATE][MAX_CH_CLASS] = {
  /*             '0'     '1-9'     '$'     MODFR    SPEC    '.'     '*'    FLAG    OTHER */
  /* START */  { SFLAG,   WDIG,    DONE,   SMOD,    DONE,   SDOT,  VARW,   SFLAG,  DONE },
  /* SFLAG */  { SFLAG,   WDIG,    DONE,   SMOD,    DONE,   SDOT,  VARW,   SFLAG,  DONE },
  /* WDIG  */  { DONE,    DONE,    WIDTH,  SMOD,    DONE,   SDOT,  DONE,   DONE,   DONE },
  /* WIDTH */  { DONE,    DONE,    DONE,   SMOD,    DONE,   SDOT,  DONE,   DONE,   DONE },
  /* SMOD  */  { DONE,    DONE,    DONE,   DONE,    DONE,   DONE,  DONE,   DONE,   DONE },
  /* SDOT  */  { SDOT,    PREC,    DONE,   SMOD,    DONE,   DONE,  VARP,   DONE,   DONE },
  /* VARW  */  { DONE,    VWDIG,   DONE,   SMOD,    DONE,   SDOT,  DONE,   DONE,   DONE },
  /* VARP  */  { DONE,    VPDIG,   DONE,   SMOD,    DONE,   DONE,  DONE,   DONE,   DONE },
  /* PREC  */  { DONE,    DONE,    DONE,   SMOD,    DONE,   DONE,  DONE,   DONE,   DONE },
  /* VWDIG */  { DONE,    DONE,    WIDTH,  DONE,    DONE,   DONE,  DONE,   DONE,   DONE },
  /* VPDIG */  { DONE,    DONE,    PREC,   DONE,    DONE,   DONE,  DONE,   DONE,   DONE },
};

_CONST __ACTION __action_table[MAX_STATE][MAX_CH_CLASS] = {
  /*             '0'     '1-9'     '$'     MODFR    SPEC    '.'     '*'    FLAG    OTHER */
  /* START */  { NOOP,    NUMBER,  NOOP,   GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
  /* SFLAG */  { NOOP,    NUMBER,  NOOP,   GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
  /* WDIG  */  { NOOP,    NOOP,    GETPOS, GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
  /* WIDTH */  { NOOP,    NOOP,    NOOP,   GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
  /* SMOD  */  { NOOP,    NOOP,    NOOP,   NOOP,    GETARG, NOOP,  NOOP,   NOOP,   NOOP },
  /* SDOT  */  { NOOP,    SKIPNUM, NOOP,   GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
  /* VARW  */  { NOOP,    NUMBER,  NOOP,   GETPW,   GETPWB, GETPW, NOOP,   NOOP,   NOOP },
  /* VARP  */  { NOOP,    NUMBER,  NOOP,   GETPW,   GETPWB, NOOP,  NOOP,   NOOP,   NOOP },
  /* PREC  */  { NOOP,    NOOP,    NOOP,   GETMOD,  GETARG, NOOP,  NOOP,   NOOP,   NOOP },
  /* VWDIG */  { NOOP,    NOOP,    PWPOS,  NOOP,    NOOP,   NOOP,  NOOP,   NOOP,   NOOP },
  /* VPDIG */  { NOOP,    NOOP,    PWPOS,  NOOP,    NOOP,   NOOP,  NOOP,   NOOP,   NOOP },
};

#endif /* STRING_ONLY && INTEGER_ONLY */

/* function to get positional parameter N where n = N - 1 */
static union arg_val *
_DEFUN(get_arg, (data, n, fmt, ap, numargs_p, args, arg_type, last_fmt),
       struct _reent *data _AND
       int n               _AND
       char *fmt           _AND
       va_list *ap         _AND
       int *numargs_p      _AND
       union arg_val *args _AND
       int *arg_type       _AND
       char **last_fmt)
{
  int ch;
  int number, flags;
  int spec_type;
  int numargs = *numargs_p;
  __CH_CLASS chtype;
  __STATE state, next_state;
  __ACTION action;
  int pos, last_arg;
  int max_pos_arg = n;
  /* Only need types that can be reached via vararg promotions.  */
  enum types { INT, LONG_INT, QUAD_INT, CHAR_PTR, DOUBLE, LONG_DOUBLE, WIDE_CHAR };
# ifdef _MB_CAPABLE
  wchar_t wc;
  mbstate_t wc_state;
  int nbytes;
# endif

  /* if this isn't the first call, pick up where we left off last time */
  if (*last_fmt != NULL)
    fmt = *last_fmt;

# ifdef _MB_CAPABLE
  memset (&wc_state, '\0', sizeof (wc_state));
# endif

  /* we need to process either to end of fmt string or until we have actually
     read the desired parameter from the vararg list. */
  while (*fmt && n >= numargs)
    {
# ifdef _MB_CAPABLE
      while ((nbytes = __mbtowc (data, &wc, fmt, MB_CUR_MAX,
				 __locale_charset (), &wc_state)) > 0)
	{
	  fmt += nbytes;
	  if (wc == '%')
	    break;
	}

      if (nbytes <= 0)
	break;
# else
      while (*fmt != '\0' && *fmt != '%')
	fmt += 1;

      if (*fmt == '\0')
	break;
# endif /* ! _MB_CAPABLE */
      state = START;
      flags = 0;
      pos = -1;
      number = 0;
      spec_type = INT;

      /* Use state/action table to process format specifiers.  We ignore invalid
         formats and we are only interested in information that tells us how to
         read the vararg list. */
      while (state != DONE)
	{
	  ch = *fmt++;
	  chtype = __chclass[ch];
	  next_state = __state_table[state][chtype];
	  action = __action_table[state][chtype];
	  state = next_state;

	  switch (action)
	    {
	    case GETMOD:  /* we have format modifier */
	      switch (ch)
		{
		case 'h':
		  /* No flag needed, since short and char promote to int.  */
		  break;
		case 'L':
		  flags |= LONGDBL;
		  break;
		case 'q':
		  flags |= QUADINT;
		  break;
# ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
		  break;
		case 'z':
		  if (sizeof (size_t) <= sizeof (int))
		    /* no flag needed */;
		  else if (sizeof (size_t) <= sizeof (long))
		    flags |= LONGINT;
		  else
		    /* POSIX states that at least one programming
		       environment must support size_t no wider than
		       long, but that means other environments can
		       have size_t as wide as long long.  */
		    flags |= QUADINT;
		  break;
		case 't':
		  if (sizeof (ptrdiff_t) <= sizeof (int))
		    /* no flag needed */;
		  else if (sizeof (ptrdiff_t) <= sizeof (long))
		    flags |= LONGINT;
		  else
		    /* POSIX states that at least one programming
		       environment must support ptrdiff_t no wider than
		       long, but that means other environments can
		       have ptrdiff_t as wide as long long.  */
		    flags |= QUADINT;
		  break;
# endif /* _WANT_IO_C99_FORMATS */
		case 'l':
		default:
# if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
		  if (*fmt == 'l')
		    {
		      flags |= QUADINT;
		      ++fmt;
		    }
		  else
# endif
		    flags |= LONGINT;
		  break;
		}
	      break;
	    case GETARG: /* we have format specifier */
	      {
		numargs &= (MAX_POS_ARGS - 1);
		/* process the specifier and translate it to a type to fetch from varargs */
		switch (ch)
		  {
		  case 'd':
		  case 'i':
		  case 'o':
		  case 'x':
		  case 'X':
		  case 'u':
		    if (flags & LONGINT)
		      spec_type = LONG_INT;
# ifndef _NO_LONGLONG
		    else if (flags & QUADINT)
		      spec_type = QUAD_INT;
# endif
		    else
		      spec_type = INT;
		    break;
		  case 'D':
		  case 'U':
		  case 'O':
		    spec_type = LONG_INT;
		    break;
# ifdef _WANT_IO_C99_FORMATS
		  case 'a':
		  case 'A':
		  case 'F':
# endif
		  case 'f':
		  case 'g':
		  case 'G':
		  case 'E':
		  case 'e':
# ifndef _NO_LONGDBL
		    if (flags & LONGDBL)
		      spec_type = LONG_DOUBLE;
		    else
# endif
		      spec_type = DOUBLE;
		    break;
		  case 's':
# ifdef _WANT_IO_C99_FORMATS
		  case 'S':
# endif
		  case 'p':
		  case 'n':
		    spec_type = CHAR_PTR;
		    break;
		  case 'c':
# ifdef _WANT_IO_C99_FORMATS
		    if (flags & LONGINT)
		      spec_type = WIDE_CHAR;
		    else
# endif
		      spec_type = INT;
		    break;
# ifdef _WANT_IO_C99_FORMATS
		  case 'C':
		    spec_type = WIDE_CHAR;
		    break;
# endif
		  }

		/* if we have a positional parameter, just store the type, otherwise
		   fetch the parameter from the vararg list */
		if (pos != -1)
		  arg_type[pos] = spec_type;
		else
		  {
		    switch (spec_type)
		      {
		      case LONG_INT:
			args[numargs++].val_long = va_arg (*ap, long);
			break;
		      case QUAD_INT:
			args[numargs++].val_quad_t = va_arg (*ap, quad_t);
			break;
		      case WIDE_CHAR:
			args[numargs++].val_wint_t = va_arg (*ap, wint_t);
			break;
		      case INT:
			args[numargs++].val_int = va_arg (*ap, int);
			break;
		      case CHAR_PTR:
			args[numargs++].val_char_ptr_t = va_arg (*ap, char *);
			break;
		      case DOUBLE:
			args[numargs++].val_double = va_arg (*ap, double);
			break;
		      case LONG_DOUBLE:
			args[numargs++].val__LONG_DOUBLE = va_arg (*ap, _LONG_DOUBLE);
			break;
		      }
		  }
	      }
	      break;
	    case GETPOS: /* we have positional specifier */
	      if (arg_type[0] == -1)
		memset (arg_type, 0, sizeof (int) * MAX_POS_ARGS);
	      pos = number - 1;
	      max_pos_arg = (max_pos_arg > pos ? max_pos_arg : pos);
	      break;
	    case PWPOS:  /* we have positional specifier for width or precision */
	      if (arg_type[0] == -1)
		memset (arg_type, 0, sizeof (int) * MAX_POS_ARGS);
	      number -= 1;
	      arg_type[number] = INT;
	      max_pos_arg = (max_pos_arg > number ? max_pos_arg : number);
	      break;
	    case GETPWB: /* we require format pushback */
	      --fmt;
	      /* fallthrough */
	    case GETPW:  /* we have a variable precision or width to acquire */
	      args[numargs++].val_int = va_arg (*ap, int);
	      break;
	    case NUMBER: /* we have a number to process */
	      number = (ch - '0');
	      while ((ch = *fmt) != '\0' && is_digit (ch))
		{
		  number = number * 10 + (ch - '0');
		  ++fmt;
		}
	      break;
	    case SKIPNUM: /* we have a number to skip */
	      while ((ch = *fmt) != '\0' && is_digit (ch))
		++fmt;
	      break;
	    case NOOP:
	    default:
	      break; /* do nothing */
	    }
	}
    }

  /* process all arguments up to at least the one we are looking for and if we
     have seen the end of the string, then process up to the max argument needed */
  if (*fmt == '\0')
    last_arg = max_pos_arg;
  else
    last_arg = n;

  while (numargs <= last_arg)
    {
      switch (arg_type[numargs])
	{
	case LONG_INT:
	  args[numargs++].val_long = va_arg (*ap, long);
	  break;
	case QUAD_INT:
	  args[numargs++].val_quad_t = va_arg (*ap, quad_t);
	  break;
	case CHAR_PTR:
	  args[numargs++].val_char_ptr_t = va_arg (*ap, char *);
	  break;
	case DOUBLE:
	  args[numargs++].val_double = va_arg (*ap, double);
	  break;
	case LONG_DOUBLE:
	  args[numargs++].val__LONG_DOUBLE = va_arg (*ap, _LONG_DOUBLE);
	  break;
	case WIDE_CHAR:
	  args[numargs++].val_wint_t = va_arg (*ap, wint_t);
	  break;
	case INT:
	default:
	  args[numargs++].val_int = va_arg (*ap, int);
	  break;
	}
    }

  /* alter the global numargs value and keep a reference to the last bit of the fmt
     string we processed here because the caller will continue processing where we started */
  *numargs_p = numargs;
  *last_fmt = fmt;
  return &args[n];
}
#endif /* !_NO_POS_ARGS */
@


1.87
log
@	* acconfig.h (_UNBUF_STREAM_OPT): Undefine.
	* newlib.hin (_UNBUF_STREAM_OPT): Undefine.
	* configure.in (--enable-newlib-unbuf-stream-opt): New option.
	* configure: Regenerate.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't do optimization on
	unbuffered stream files.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R): Likewise.
	* README: Add description about the option.
	* newlib.hin (_UNBUF_STREAM_OPT): Undefine.
	* configure.in (--enable-newlib-unbuf-stream-opt): New option.
	* configure: Regenerate.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't do optimization on
	unbuffered stream files.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R): Likewise.
	* README: Add description about the option.
@
text
@d1524 1
a1524 1
				if (p != NULL) {
d1526 1
a1526 3
					if (size > prec)
						size = prec;
				} else
@


1.86
log
@	* acconfig.h (_WCHAR_ORIENT): Undef
	* newlib.hin (_WCHAR_ORIENT): Undef
	* configure.in (--enable-newlib-wchar-orient): New option.
	* configure: Regenerated.
	* libc/configure.in (--enable-newlib-wchar-orient): New option.
	* libc/configure: Regenerated.
	* libc/stdio/Makefile.am (NEWLIB_WIDE_ORIENT): Use.
	* libc/stdio/Makefile.in: Regenerated.
	* libc/stdio/local.h (ORIENT): Use _WCHAR_ORIENT to control
	the definition. Add alternative definition.
	* libc/stdio/vfprintf.c (__sfputs_r, __sprint_r): Use _WCHAR_ORIENT
	to control the wide char output.
@
text
@d450 1
d496 1
d870 1
d877 1
@


1.85
log
@	* acconfig.h (_FVWRITE_IN_STREAMIO): Undefine.
	* newlib.hin (_FVWRITE_IN_STREAMIO): Undefine.
	* configure.in (--disable-newlib-fvwrite-in-streamio): New option.
	* configure: Regenerated.
	* libc/stdio/fputs.c (_fputs_r): Use _FVWRITE_IN_STREAMIO to
	control __sfvwrite_r.  Add alternative implementation.
	* libc/stdio/fputws.c (_fputws_r): Ditto.
	* libc/stdio/fwrite.c (_fwrite_r): Ditto.
	* libc/stdio/puts.c (_puts_r): Ditto.
	* libc/stdio/vfprintf.c (__ssputs_r, __sfputs_r): New function.
	(_VFPRINTF_R): Use _FVWRITE_IN_STREAMIO to control vector buffer.
	(__SPRINT): Use _FVWRITE_IN_STREAMIO to control macro definition.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R): Use _FVWRITE_IN_STREAMIO
	to control vector buffer.
@
text
@d380 1
d390 3
d417 1
d436 1
@


1.84
log
@	* libc/stdio/vfprintf.c (__sbprintf): Fix comment.
@
text
@d181 5
a185 1
#define __SPRINT __ssprint_r
d187 5
a191 1
#define __SPRINT __sprint_r
d199 70
d361 3
d369 28
d438 3
a664 1
	register struct __siov *iovp;/* for PRINT macro */
d711 1
d715 2
d742 1
d777 24
d883 1
d887 1
@


1.83
log
@	* libc/include/sys/features.h (__GNUC_PREREQ): Define.  Use
	throughout in place of explicit GNUC version checks.
	* libc/include/_ansi.h (_NOINLINE): Define.
	(_NOINLINE_STATIC): Define.
	* libc/stdio/vfprintf.c (__sbprintf): Define _NOINLINE_STATIC.
@
text
@d337 1
a337 1
 * Make sure to avoid inlining when optimizing for size.
@


1.82
log
@	Throughout, run newlib with -Wall -Werror option and fix bugs and
	compiler warnings found this way.

	* libc/stdio/freopen.c (_freopen_r): Fix bug setting _flags.

	* libc/include/stdio.h (_rename): Define when building newlib.
	* libc/include/sys/signal.h (_kill): Ditto.
	* libc/include/sys/stat.h (_mkdir): Ditto.
	* libc/include/sys/time.h (_gettimeofday): Ditto.
	* libc/include/sys/times.h (_times): Ditto.
	* libc/include/sys/wait.h (_wait): Ditto.
	* libc/locale/lmessages.c (empty): Don't define for Cygwin.
	* libc/locale/lmonetary.c (cnv): Ditto.
	* libc/locale/nl_langinfo.c (nl_langinfo): Ditto for variable s.
	* libc/posix/collate.c: Throughout cast to avoid compiler warning.
	* libc/posix/engine.c (matcher): Initialize dp to avoid compiler
	warning.
	* libc/posix/glob.c: Disable on Cygwin.  Explain why.
	* libc/posix/regcomp.c: Fix "uninitialized" compiler warnings.
	(dissect): Deliberately silence gcc compiler warning.  Add comment to
	explain why.
	* libc/posix/wordexp.c (wordexp): Remove num_bytes variable since result
	is never used.
	* libc/posix/popen.c (popen): Ditto for variable last.
	* libc/reent/mkdirr.c: Include sys/stat.h.
	* libc/reent/renamer.c: Include stdio.h.
	* libc/search/hash.c:  Throughout use underscored variants of the stat
	function family.
	(init_hash): Add missing definition for the __USE_INTERNAL_STAT64 case.
	* libc/search/hash_bigkey.c (__big_insert): Add parenthesis to avoid
	compiler warning.
	* libc/search/hash_page.c (overflow_page): Initalize freep to NULL to
	avoid compiler warning.
	* libc/stdio/asiprintf.c (_asiprintf_r): Cast unsigned char * to char *
	to avoid compiler warning.
	(asiprintf): Ditto.
	* libc/stdio/asprintf.c (_asprintf_r): Ditto.
	(asprintf): Ditto.
	* libc/stdio/vasiprintf.c (_vasiprintf_r): Ditto.
	* libc/stdio/vasprintf.c (_vasprintf_r): Ditto.
	* libc/stdio/mktemp.c (_gettemp): Cast to unsigned char in call to
	isdigit to avoid compiler warning.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Initialize variables used for
	grouping to avoid compiler warning.  Only define and set nseps and
	nrepeats if they are really used.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R): Ditto.  Only define state if
	it is really used.
	* libc/stdio/vfscanf.c (u_char): Revert to be defined as unsigned char.
	(__SVFSCANF_R): Cast fmt in call to __mbtowc.
	* libc/stdlib/mbtowc_r.c (JIS_state_table): Disable when building
	Cygwin.
	(JIS_action_table): Ditto.
	* libc/stdlib/wctomb_r.c (__utf8_wctomb): Add parenthesis to avoid
	compiler warning.
	* libc/string/strcasestr.c: Deliberately silence gcc compiler warning.
	Add comment to explain why.
	* libc/time/strptime.c (strptime): Cast to unsigned char in calls to
	isspace to avoid compiler warning.
	* libm/math/e_atan2.c (__ieee754_atan2): Add parenthesis to avoid
	compiler warning.
	* libm/math/e_exp.c (__ieee754_exp): Initialize k to 0 to avoid
	compiler warning.  Drop setting it to 0 later.
	* libm/math/ef_exp.c (__ieee754_expf): Ditto.
	* libm/math/e_pow.c (__ieee754_pow): Add braces to avoid compiler
	warning.
	* libm/math/ef_pow.c (__ieee754_powf): Ditto.
	* libm/math/er_lgamma.c (__ieee754_lgamma_r): Initialize nadj to 0 to
	avoid compiler warning.
	* libm/math/erf_lgamma.c (__ieee754_lgammaf_r): Ditto.
	* libm/math/e_rem_pio2.c (__ieee754_rem_pio2): Ditto for variable z.
	* libm/common/sf_round.c (roundf): Remove signbit variable since result
	is never used.
@
text
@d336 2
d339 1
a339 1
static int
@


1.82.2.1
log
@Pull in changes from HEAD
@
text
@a335 2
 *
 * Make sure to avoid inlining.
d337 1
a337 1
_NOINLINE_STATIC int
@


1.81
log
@	* libc/stdio/local.h (_newlib_flockfile_start): New macro to
	secure stream related critical section against thread cancellation.
	(_newlib_flockfile_exit): Ditto.
	(_newlib_sfp_lock_end): Ditto.
	(_newlib_sfp_lock_start): Ditto for the list of streams.
	(_newlib_sfp_lock_exit): Ditto.
	(_newlib_sfp_lock_end): Ditto.
	Use aforementioned macros in place of _flockfile/_funlockfile
	and __sfp_lock_acquire/__sfp_lock_release throughout the code.
	* libc/stdio/fclose.c: Explicitely disable and re-enable thread
	cancellation.  Explain why.
	* libc/stdio/freopen.c: Ditto.
	* libc/stdio64/freopen64.c: Ditto.
@
text
@d570 3
a572 3
	char *thousands_sep;
	size_t thsnd_len;
	const char *grouping;
d588 1
a588 1
#ifdef _WANT_IO_C99_FORMATS
a795 1
#endif
d799 1
@


1.80
log
@	* libc/stdio/sprintf.c: Document 'm' conversion specifier.
	* libc/stdio/swprintf.c: Ditto.
	* libc/stdio/vfprintf.c (_VFPRINTF_R) [_GLIBC_EXTENSION]: Handle 'm'
	conversion specifier.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R) [_GLIBC_EXTENSION]: Ditto.
@
text
@d711 1
a711 1
	_flockfile (fp);
d717 1
a717 1
		_funlockfile (fp);
d724 1
a724 1
		_funlockfile (fp);
d1636 1
a1636 1
	_funlockfile (fp);
@


1.79
log
@	* libc/stdio/vfprintf.c (_VFPRINTF_R): Drop printing a redundant
	decimal point in case the float argument is an integral value.
@
text
@d1228 9
d1284 4
a1288 1
			cp = GET_ARG (N, ap, char_ptr_t);
@


1.78
log
@	* libc/stdio/vfprintf.c: Include locale.h also if _WANT_IO_C99_FORMATS
	is defined.  Raise conversion buffer size to make sure it has enough
	room for numbers plus grouping character.  Define GROUPING flag.
	(_VFPRINTF_R): Add PRINTANDPAD macro.  Handle grouping flag character.
	Handle grouping for decimal integer and float values.
	* libc/stdio/vfwprintf.c: Ditto.
@
text
@d1581 1
a1581 1
					if (prec || flags & ALT)
@


1.77
log
@	* libc/stdio/vfprintf.c (_VFPRINTF_R): Just wave bytes invalid in
	the current charset through.
@
text
@d378 3
a381 1
# include <locale.h>
d428 8
a435 1
   long strings are processed.  */
d437 1
d521 3
d568 6
a581 1
	int ndig = 0;		/* actual number of digits returned by cvt */
d583 1
d585 7
d646 8
d794 6
d809 6
a814 6
		  /* The ' flag is required by POSIX, but not C99.
		     In the C locale, LC_NUMERIC requires
		     thousands_sep to be the empty string.  And since
		     no other locales are supported (yet), this flag
		     is currently a no-op.  */
		  goto rflag;
d1183 14
a1196 2
			} else if (ch == 'f') {		/* f fmt */
				if (expt > 0) {
d1198 25
a1222 13
					if (prec || flags & ALT)
						size += prec + 1;
				} else	/* "0.X" */
					size = (prec || flags & ALT)
						  ? prec + 2
						  : 1;
			} else if (expt >= ndig) {	/* fixed g fmt */
				size = expt;
				if (flags & ALT)
					++size;
			} else
				size = ndig + (expt > 0 ?
					1 : 2 - expt);
d1251 3
d1390 3
d1428 3
a1430 3
					while (_uquad >= 10) {
						*--cp = to_char (_uquad % 10);
						_uquad /= 10;
d1432 27
a1458 1
					*--cp = to_char (_uquad);
a1557 5
				} else if (expt >= ndig) {
					PRINT (cp, ndig);
					PAD (expt - ndig, zeroes);
					if (flags & ALT)
						PRINT (decimal_point, decp_len);
d1559 26
a1584 4
					PRINT (cp, expt);
					cp += expt;
					PRINT (decimal_point, decp_len);
					PRINT (cp, ndig - expt);
@


1.76
log
@	* libc/stdio/vfprintf.c: Include ../stdlib/local.h.  Replace call to
	_mbtowc_r with direct call to __mbtowc.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdlib/btowc.c: Include local.h.  Replace call to _mbtowc_r
	with direct call to __mbtowc.
	* libc/stdlib/mblen.c: Ditto.
	* libc/stdlib/mblen_r.c: Ditto.
	* libc/stdlib/mbrtowc.c: Ditto.
	* libc/stdlib/mbstowcs_r.c: Ditto.
	* libc/stdlib/mbtowc.c: Ditto.
	* libc/stdlib/wcrtomb.c: Include local.h.  Replace call to _wctomb_r
	with direct call to __wctomb.
	* libc/stdlib/wcsnrtombs.c: Ditto.
	(_wcsnrtombs_r): Ditto.
	* libc/stdlib/wcstombs_r.c: Ditto.
	* libc/stdlib/wctob.c: Ditto.
	* libc/stdlib/wctomb.c: Ditto.

	* libc/stdlib/mbrtowc.c (mbrtowc): Implement independently from
	_mbrtowc_r, unless PREFER_SIZE_OVER_SPEED or __OPTIMIZE_SIZE__ are
	defined.
	* libc/stdlib/wcrtomb.c (wcrtomb): Implement independently from
	_wcrtomb_r, unless PREFER_SIZE_OVER_SPEED or __OPTIMIZE_SIZE__ are
	defined.

	* libc/stdlib/mbtowc_r.c (__utf8_mbtowc): Drop unnecessary test for
	ch >= 0.
@
text
@d727 7
a733 2
				      __locale_charset (), &state)) > 0) {
                    if (wc == '%')
@


1.75
log
@	* libc/stdio/vfprintf.c (_VFPRINTF_R): Use actual length of
	radix char instead of assuming length 1.
	* libc/stdlib/gdtoa-gethex.c: Remove use of USE_LOCALE.
	(gethex): Allow multibyte decimal point.
	Fix compiler warnings due to different signedness of pointer types.
	* libc/stdlib/strtod.c: Remove use of USE_LOCALE.
	(_strtod_r): Allow multibyte decimal point.
	* libc/stdlib/wcstod.c (_wcstod_r): Evaluate correct wide char
	endptr position if the decimal point is a multibyte char.
@
text
@d162 1
d726 2
a727 1
	        while ((n = _mbtowc_r (data, &wc, fmt, MB_CUR_MAX, &state)) > 0) {
d1799 2
a1800 1
      while ((nbytes = _mbtowc_r (data, &wc, fmt, MB_CUR_MAX, &wc_state)) > 0)
@


1.74
log
@	* libc/include/wchar.h (fwscanf, swscanf, vfwscanf, vswscanf, vwscanf,
	wscanf): Declare.
	(_fwscanf_r, _swscanf_r, _vfwscanf_r, _vswscanf_r, _vwscanf_r,
	_wscanf_r): Declare.
	* libc/stdio/Makefile.am: Add new wscanf files.
	* libc/stdio/Makefile.in: Regenerate.
	* libc/stdio/fwscanf.c: New file.
	* libc/stdio/local.h (__svfwscanf_r, __ssvfwscanf_r, __svfiwscanf_r,
	__ssvfiwscanf_r): Declare.
	* libc/stdio/stdio.tex: Add new documentation references.
	* libc/stdio/swscanf.c: New file.
	* libc/stdio/vfwscanf.c: New file.
	* libc/stdio/vswscanf.c: New file.
	* libc/stdio/vwscanf.c: New file.
	* libc/stdio/wscanf.c: New file.

	* libc/stdio/vfscanf.c (_sungetc_r): Make externaly available.  Only
	define if INTEGER_ONLY is defined.  Declare otherwise.
	(__ssrefill_r): Ditto.
	(_sfread_r): Ditto.

	Remove static eofread/eofread1 functions and use __seofread
	function instead, throughout.
	* libc/stdio/local.h (__seofread): Declare.
	* libc/stdio/stdio.c (__seofread): Define.

	* libc/stdio/fgetwc.c (__fgetwc): Fix compiler warning.
	* libc/stdio/fgetws.c (_fgetws_r): Ditto.
	* libc/stdio/fread.c (_fread_r): Ditto.
	* libc/stdio/vfprintf.c: Ditto.
	* libc/stdio/vswprintf.c: Ditto.
@
text
@d556 1
d1445 1
a1445 1
						PRINT (decimal_point, 1);
d1451 1
a1451 1
						PRINT (decimal_point, 1);
d1459 1
a1459 1
						PRINT (decimal_point, 1);
d1463 1
a1463 1
					PRINT (decimal_point, 1);
d1470 1
a1470 1
					PRINT (decimal_point, 1);
@


1.73
log
@	* libc/include/stdio.h (__VALIST): Guard against multiple definition.
	* libc/include/wchar.h: Include stdarg.h.
	(__VALIST): Define conditionally.
	(fwprintf, swprintf, vfwprintf, vswprintf, vwprintf, wprintf: Declare.
	(_fwprintf_r, _swprintf_r, _vfwprintf_r, _vswprintf_r, _vwprintf_r,
	 _wprintf_r): Declare.
	* libc/stdio/Makefile.am: Add new files.
	* libc/stdio/Makefile.in: Regenerate.
	* libc/stdio/fwprintf.c: New file.
	* libc/stdio/local.h (_svfwprintf_r, _svfiwprintf_r): Declare.
	(__CH_CLASS, __STATE, __ACTION): Move definition from vfprintf.c here
	and move to the __ namespace.
	(__chclass, __state_table, __action_table): Declare.
	* libc/stdio/stdio.tex: Add new documentation references.
	* libc/stdio/swprintf.c: New file.
	* libc/stdio/vfprintf.c (__SPRINT): New macro to call the right
	__sprint_r function according to compilation unit.  Use throughout.
	(__ssprint_r): Rename STRING_ONLY variant from __sprint_r.
	Make externaly available.  Only define if INTEGER_ONLY is defined.
	(__sprint_r): Make externaly available.  Only define if INTEGER_ONLY
	is defined.  Handle stream orientation.
	(__sbprintf): Copy FILE's _flags2 member as well.
	(__chclass, __state_table, __action_table): Prepend __ to name and
	make externally available.
	* libc/stdio/vfwprintf.c: New file.
	* libc/stdio/vswprintf.c: New file.
	* libc/stdio/vwprintf.c: New file.
	* libc/stdio/wprintf.c: New file.
@
text
@d281 3
a283 1
#endif /* INTEGER_ONLY */
d327 3
a329 1
#endif /* INTEGER_ONLY */
@


1.72
log
@
2008-12-10  Corinna Vinschen  <corinna@@vinschen.de>

        Implement basic wide char stdio functionality, based on FreeBSD.
        * libc/include/stdio.h (__SORD): Define.
        (__SWID): Define.
        * libc/include/wchar.h: Add declarations for new wide char functions.
        (getwc): Define as macro.
        (getwchar): Ditto.
        (putwc): Ditto.
        (putwchar): Ditto.
        * libc/include/sys/reent.h (struct __sFILE): Add _mbstate member.
        (struct __sFILE64): Ditto.
        * libc/stdio/Makefile.am (ELIX_4_SOURCES): Add fgetwc.c, fgetws.c,
        fputwc.c, fputws.c, fwide.c, getwc.c, getwchar.c, putwc.c, putwchar.c
        and ungetwc.c.
        (CHEWOUT_FILES): Add fgetwc.def, fgetws.def, fputwc.def, fputws.def,
        fwide.def, getwc.def, getwchar.def, putwc.def, putwchar.def and
        ungetwc.def.
        Add header dependency rules for the new files.
        * libc/stdio/Makefile.in: Regenerate.
        * libc/stdio/fgetwc.c: New file, implementing fgetwc and _fgetwc_r.
        * libc/stdio/fgetws.c: New file, implementing fgetws and _fgetws_r.
        * libc/stdio/findfp.c (std): Initialize FILE's _mbstate member.
        (__sfmoreglue): Ditto.
        * libc/stdio/fputs.c (_fputs_r): Set stream orientation.
        * libc/stdio/fputwc.c: New file, implementing fputwc and _fputwc_r.
        * libc/stdio/fputws.c: New file, implementing fputws and _fputws_r.
        * libc/stdio/fread.c (_fread_r): Set stream orientation.
        * libc/stdio/freopen.c (_freopen_r): Reset stream orientation.  Reset
        _mbstate.
        * libc/stdio/fseek.c (_fseek_r): Reset _mbstate.
        * libc/stdio/fwide.c: New file, implementing fwide and _fwide_r.
        * libc/stdio/fwrite.c (_fwrite_r): Set stream orientation.
        * libc/stdio/getwc.c: New file, implementing getwc and _getwc_r.
        * libc/stdio/getwchar.c: New file, implementing getwchar and
        _getwchar_r.
        * libc/stdio/local.h (ORIENT): New macro.
        * libc/stdio/puts.c (_puts_r): Set stream orientation.
        * libc/stdio/putwc.c: New file, implementing putwc and _putwc_r.
        * libc/stdio/putwchar.c: New file, implementing putwchar and
        _putwchar_r.
        * libc/stdio/refill.c (__srefill_r): Set stream orientation.
        * libc/stdio/stdio.tex: Add documentation for new functions.
        * libc/stdio/ungetc.c (_ungetc_r): Set stream orientation.
        * libc/stdio/ungetwc.c: New file, implementing ungetwc and _ungetwc_r.
        * libc/stdio/vfscanf.c (__SVFSCANF_R): Set stream orientation.
        * libc/stdio/wbuf.c (__swbuf_r): Ditto.
@
text
@d180 12
a191 2
static int
_DEFUN(__sprint_r, (ptr, fp, uio),
d281 1
d284 1
d289 1
a289 1
static int
d295 1
a295 1
	register int err;
d301 20
a320 1
	err = __sfvwrite_r(ptr, fp, uio);
d325 1
d345 1
d600 1
a600 1
		if (__sprint_r(data, fp, &uio)) \
d615 1
a615 1
	if (uio.uio_resid && __sprint_r(data, fp, &uio)) \
d1678 4
a1681 40
typedef enum {
  ZERO,   /* '0' */
  DIGIT,  /* '1-9' */
  DOLLAR, /* '$' */
  MODFR,  /* spec modifier */
  SPEC,   /* format specifier */
  DOT,    /* '.' */
  STAR,   /* '*' */
  FLAG,   /* format flag */
  OTHER,  /* all other chars */
  MAX_CH_CLASS /* place-holder */
} CH_CLASS;

typedef enum {
  START,  /* start */
  SFLAG,  /* seen a flag */
  WDIG,   /* seen digits in width area */
  WIDTH,  /* processed width */
  SMOD,   /* seen spec modifier */
  SDOT,   /* seen dot */
  VARW,   /* have variable width specifier */
  VARP,   /* have variable precision specifier */
  PREC,   /* processed precision */
  VWDIG,  /* have digits in variable width specification */
  VPDIG,  /* have digits in variable precision specification */
  DONE,   /* done */
  MAX_STATE, /* place-holder */
} STATE;

typedef enum {
  NOOP,  /* do nothing */
  NUMBER, /* build a number from digits */
  SKIPNUM, /* skip over digits */
  GETMOD,  /* get and process format modifier */
  GETARG,  /* get and process argument */
  GETPW,   /* get variable precision or width */
  GETPWB,  /* get variable precision or width and pushback fmt char */
  GETPOS,  /* get positional parameter value */
  PWPOS,   /* get positional parameter value for variable width or precision */
} ACTION;
d1683 1
a1683 1
_CONST static CH_CLASS chclass[256] = {
d1718 1
a1718 1
_CONST static STATE state_table[MAX_STATE][MAX_CH_CLASS] = {
d1733 1
a1733 1
_CONST static ACTION action_table[MAX_STATE][MAX_CH_CLASS] = {
d1748 2
d1766 3
a1768 3
  CH_CLASS chtype;
  STATE state, next_state;
  ACTION action;
d1820 3
a1822 3
	  chtype = chclass[ch];
	  next_state = state_table[state][chtype];
	  action = action_table[state][chtype];
@


1.71
log
@
2008-10-31  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/diprintf.c: Modify documentation so eclipse newlib
        libhover docs generate properly.
        * libc/stdio/dprintf.c: Ditto.
        * libc/stdio/fflush.c: Ditto.
        * libc/stdio/fopencookie.c: Ditto.
        * libc/stdio/fread.c: Ditto.
        * libc/stdio/fsetpos.c: Ditto.
        * libc/stdio/getc_u.c: Ditto.
        * libc/stdio/getchar_u.c: Ditto.
        * libc/stdio/putc_u.c: Ditto.
        * libc/stdio/putchar_u.c: Ditto.
        * libc/stdio/remove.c: Ditto.
        * libc/stdio/siprintf.c: Ditto.
        * libc/stdio/siscanf.c: Ditto.
        * libc/stdio/sprintf.c: Ditto.
        * libc/stdio/sscanf.c: Ditto.
        * libc/stdio/vfprintf.c: Ditto.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/viprintf.c: Ditto.
        * libc/stdio/viscanf.c: Ditto.
        * libc/stdlib/calloc.c: Ditto.
        * libc/stdlib/efgcvt.c: Ditto.
        * libc/stdlib/envlock.c: Ditto.
        * libc/time/asctime.c: Ditto.
        * libc/time/ctime.c: Ditto.
        * libc/time/gmtime.c: Ditto.
        * libc/time/lcltime.c: Ditto.
        * libc/time/tzset.c: Ditto.
        * libc/stdlib/envlock.h: Moved to libc/include.
@
text
@d640 2
@


1.70
log
@Fix 2008-04-14 regression in asprintf(ptr,"").

* libc/stdio/asnprintf.c (asnprintf, _asnprintf_r): Avoid stdio
baggage.
* libc/stdio/asniprintf.c (asniprintf, _asniprintf_r): Likewise.
* libc/stdio/asiprintf.c (asiprintf, _asiprintf_r): Likewise.
* libc/stdio/vasniprintf.c (_vasniprintf_r): Likewise.
* libc/stdio/vsnprintf.c (_vsnprintf_r): Likewise.
* libc/stdio/vfprintf.c (_VFPRINTF_R) [STRING_ONLY]: Always malloc
an initial buffer for asprintf.
@
text
@d44 2
d48 2
d52 2
d56 2
d60 2
d63 2
d87 1
a87 2
                         size_t <[size]>, const char *<[fmt]>,
                         va_list <[list]>);
d89 1
a89 2
                            size_t *<[size]>, const char *<[fmt]>,
                            va_list <[list]>);
@


1.69
log
@
2008-04-14  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/Makefile.am: Build vfprintf.c and vfscanf.c with
        -DSTRING_ONLY defined with and without -DINTEGER_ONLY defined
        to build special versions for sprintf/sscanf family functions.
        * libc/stdio/Makefile.in: Regenerated.
        * libc/stdio/vfprintf.c[STRING_ONLY][INTEGER_ONLY](_VFPRINTF_R):
        Redefine to be _svfiprintf_r which is optimized to work with siprintf
        family of functions (i.e. no I/O) and does not support floating-point.
        [STRING_ONLY][!INTEGER_ONLY](_VFPRINTF_R): Redefine to be
        _svfprintf_r which is optimized to work with sprintf family of
        functions and not use I/O.
        [STRING_ONLY](__sprint_r): New string only version of static function.
        designed to work with sprintf family of functions.
        * libc/stdio/vfscanf.c[STRING_ONLY][INTEGER_ONLY](_SVFSCANF_R):
        Redefine to be _ssvfiscanf_r which is optimized to work with siscanf
        family of functions (i.e. no I/O) and no float-point support.
        [STRING_ONLY][!INTEGER_ONLY](_SVFSCANF_R): Redefine to be
        __ssvfscanf_r which is optimized to work with sscanf family of
        functions and does not require I/O functions.
        * libc/stdio/asprintf.c: Call _svfprintf_r instead of _vfprintf_r.
        * libc/stdio/snprintf.c: Ditto.
        * libc/stdio/sprintf.c: Ditto.
        * libc/stdio/vasnprintf.c: Ditto.
        * libc/stdio/vasprintf.c: Ditto.
        * libc/stdio/siprintf.c: Call _svfiprintf_r instead of _vfiprintf_r.
        * libc/stdio/sniprintf.c: Ditto.
        * libc/stdio/vasiprintf.c: Ditto.
        * libc/stdio/vsiprintf.c: Ditto.
        * libc/stdio/vsniprintf.c: Ditto.
        * libc/stdio/vsprintf.c: Ditto.
        * libc/stdio/local.h: Add prototypes for _svfprintf_r, _svfiprintf_r,
        _ssvfscanf_r, and _ssvfiscanf_r.
        * libc/stdio/sscanf.c: Call _ssvfscanf_r instead of _svfscanf_r.
        * libc/stdio/vsscanf.c: Ditto.
        * libc/stdio/siscanf.c: Call _ssvfiscanf_r instead of _svfiscanf_r.
        * libc/stdio/vsiscanf.c: Ditto.
@
text
@d229 1
a229 1
					/* Ensure correct errno, even if free 
d234 1
a234 1
			}		
d262 1
a262 1
#else /* !STRING_ONLY */ 
d428 2
a429 2
_EXFUN(get_arg, (struct _reent *data, int n, char *fmt, 
                 va_list *ap, int *numargs, union arg_val *args, 
d467 1
a467 1
int 
d479 1
a479 1
int 
d632 1
a632 1
		_funlockfile (fp);	
d642 12
d933 1
a933 1
					goto error; 
d1111 1
a1111 1
			else 
d1617 1
a1617 1
      
d1642 1
a1642 1
  OTHER,  /* all other chars */ 
d1646 1
a1646 1
typedef enum { 
d1652 1
a1652 1
  SDOT,   /* seen dot */ 
d1658 2
a1659 2
  DONE,   /* done */   
  MAX_STATE, /* place-holder */ 
d1684 1
a1684 1
  /* 48-4f */  OTHER,   OTHER,   OTHER,   OTHER,   MODFR,   OTHER,   OTHER,   SPEC, 
d1710 1
a1710 1
  /*             '0'     '1-9'     '$'     MODFR    SPEC    '.'     '*'    FLAG    OTHER */ 
d1725 1
a1725 1
  /*             '0'     '1-9'     '$'     MODFR    SPEC    '.'     '*'    FLAG    OTHER */ 
d1781 1
a1781 1
      while ((nbytes = _mbtowc_r (data, &wc, fmt, MB_CUR_MAX, &wc_state)) > 0) 
d1784 1
a1784 1
	  if (wc == '%') 
@


1.68
log
@	* libc/stdio/vfprintf.c (_VFPRINTF_R): Use correct pointer in call to
	_wcsrtombs_r.
@
text
@d119 5
a123 1
# define _VFPRINTF_R _vfiprintf_r
d126 5
a130 1
# define _VFPRINTF_R _vfprintf_r
d169 94
d327 1
d466 1
d477 1
d625 2
d642 1
d1441 1
d1443 1
@


1.67
log
@* libc/stdio/vfprintf.c (_VFPRINTF_R) [__OPTIMIZE_SIZE__]:
Correctly nest else within conditionals.
Reported by Artur Lipowski.
@
text
@d1098 2
a1099 2
				if (_wcsrtombs_r (data, malloc_buf,
						 &wcp, size, &ps) != size) {
@


1.66
log
@Obey POSIX on printf("%.s", (char*)NULL).
* libc/stdio/vfprintf.c (_VFPRINTF_R): Take precision into account
for %s on NULL.  Skip NULL check when optimizing for size.
@
text
@d1042 1
d1045 1
a1045 1
			else if (ch == 'S' || (flags & LONGINT)) {
d1105 1
d1107 1
a1107 1
			else if (prec >= 0) {
@


1.65
log
@Fix 'make info'.
* libc/stdio/stdio.tex: Add missing include.
* libc/stdio/vfprintf.c: Use expected node name.
* libc/stdio/vfscanf.c: Likewise.
* libc/stdio/sscanf.c: Likewise.
* libc/stdio/sprintf.c: Likewise.
* libc/stdio/siscanf.c: Likewise.
* libc/stdio/siprintf.c: Likewise.
* libc/stdio/fopencookie.c: Quote raw {}.
Reported by DJ Delorie.
@
text
@d1032 7
a1038 1
			if ((cp = GET_ARG (N, ap, char_ptr_t)) == NULL) {
d1040 1
a1040 1
				size = 6;
d1042 1
@


1.64
log
@Fix fflush issues.
* libc/stdio/fflush.c (_fflush_r): New function.
(fflush): Fix reentrancy and large offset behavior.
* libc/include/stdio.h (_fflush_r): Add prototype.
* libc/stdio/fclose.c (_fclose_r): All fflush callers changed.
* libc/stdio/freopen.c (_freopen_r): Likewise.
* libc/stdio/fseek.c (_fseek_r): Likewise.
* libc/stdio/ftell.c (_ftell_r): Likewise.
* libc/stdio/fvwrite.c (__sfvwrite_r): Likewise.
* libc/stdio/refill.c (__srefill_r): Likewise.
* libc/stdio/setvbuf.c (setvbuf): Likewise.
* libc/stdio/ungetc.c (_ungetc_r): Likewise.
* libc/stdio/vfprintf.c (__sbprintf): Likewise.
* libc/stdio/wbuf.c (__swbuf_r): Likewise.
* libc/stdio64/freopen64.c (_freopen64_r): Likewise.
* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.  Defer to
32-bit version if not large file.
* libc/stdio64/ftello64.c (_ftello64_r): Likewise.
* libc/stdio64/tmpfile64.c (_tmpfile64_r): Avoid compile warning.
@
text
@d39 1
a39 1
<<vprintf>>, <<vfprintf>>, <<vsprintf>>, <<vsnprintf>>, <<vasprintf>>, <<vasnprintf>>---format argument list
d42 2
a45 2
	vfprintf
INDEX
@


1.63
log
@* libc/stdio/vfprintf.c (_VFPRINTF_R): Populate 'ox' when
handling %p.
@
text
@d215 1
a215 1
	if (ret >= 0 && fflush(&fake))
@


1.62
log
@* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't truncate %p when
sizeof(void*) is 8 but sizeof(long) is 4.
* libc/stdio/vfscanf.c (__SVFSCANF_R): Likewise.  Fix %i scanning
of "-0x".  Support "-nan" and "inf" for %e.  Audit usage of ungetc
to fix reentrancy and bug on encoding error in multibyte locales.
Always return EOF on read error.
@
text
@d1024 2
a1025 1
			ch = 'x';
@


1.61
log
@* libc/stdio/vfscanf.c (__SVFSCANF_R): Support scanf(%1$s).
Avoid warning when !FLOATING_POINT.
* libc/stdio/vfprintf.c (_VFPRINTF_R): Simplify _NO_POS_ARGS
slightly.
@
text
@d1020 1
a1020 1
			_uquad = (u_long)(unsigned _POINTER_INT)GET_ARG (N, ap, void_ptr_t);
@


1.60
log
@* libc/stdio/vfprintf.c [_WANT_IO_LONG_LONG]: Allow non-gcc
compilers.
* libc/stdio/vfscanf.c: Likewise.
@
text
@d128 2
a129 2
#define _NO_POS_ARGS 
#if defined _WANT_IO_POS_ARGS
d388 1
a390 1
#ifndef _NO_POS_ARGS
d475 11
a485 11
#define GET_ARG(n, ap, type) \
  ( is_pos_arg \
      ? n < numargs \
         ? args[n].val_##type \
         : get_arg (data, n, fmt_anchor, &ap, &numargs, args, arg_type, &saved_fmt)->val_##type \
      : arg_index++ < numargs \
         ? args[n].val_##type \
         : numargs < MAX_POS_ARGS \
           ? args[numargs++].val_##type = va_arg (ap, type) \
           : va_arg (ap, type) \
  )
d487 1
a487 1
#define GET_ARG(n, ap, type) (va_arg (ap, type))
d489 1
a489 1
    
d541 1
a542 1
#ifndef _NO_POS_ARGS
d583 1
a584 1
#ifndef _NO_POS_ARGS
a611 1
			n = N;
d614 1
a663 1
				n = N;
d666 1
@


1.59
log
@Reduce stack size of *printf.
* libc/stdio/vfprintf.c (_VFPRINTF_R): Fix use of decimal point
in %f.  Avoid malloc when possible for %S.
(BUF): Improve stack locality by using smaller size.
(MAXEXPLEN, _PRINTF_FLOAT_TYPE): Define.
(exponent): Use smaller stack size.
@
text
@d156 2
a157 1
#if defined _WANT_IO_LONG_LONG && defined __GNUC__
@


1.58
log
@Minimize printf/scanf size on platforms that don't need C99.
* acconfig.h (_WANT_IO_C99_FORMATS): New macro.
* newlib.hin (_WANT_IO_C99_FORMATS): Likewise.
* configure.in (newlib-io-c99-formats): New configure option.
(_WANT_IO_C99_FORMATS): Define appropriately.
* configure.host (*-linux*, cygwin): Default c99-formats to yes.
* libc/stdio/vfprintf.c (_VFPRINTF_R) [!_WANT_IO_C99_FORMATS]:
Cripple ' flag; hh, z, j, t sizes; a, A, F, C, S specifiers.
* libc/stdio/vfscanf.c (_VFSCANF_R) [!_WANT_IO_C99_FORMATS]:
Likewise.
* configure: Regenerate.
@
text
@d227 2
a228 3
#include <locale.h>
#include <math.h>
#include "floatio.h"
d230 15
a244 5
#if ((MAXEXP+MAXFRACT+1) > MB_LEN_MAX)
#  define BUF (MAXEXP+MAXFRACT+1) /* + decimal point */
#else 
#  define BUF MB_LEN_MAX
#endif
d246 2
a247 1
#define	DEFPREC		6
a248 8
#ifdef _NO_LONGDBL
static char *
_EXFUN(cvt, (struct _reent *, double, int, int, char *, int *, int, int *,
	     char *));
#else
static char *
_EXFUN(cvt, (struct _reent *, _LONG_DOUBLE, int, int, char *, int *, int,
	     int *, char *));
a249 1
#endif
d251 7
a257 1
static int _EXFUN(exponent, (char *, int, int));
d259 2
a260 1
#else /* no FLOATING_POINT */
d262 1
a262 1
#define	BUF		40
d266 15
d282 2
a283 2
#define quad_t long long
#define u_quad_t unsigned long long
d285 2
a286 2
#define quad_t long
#define u_quad_t unsigned long
d404 2
a405 8
# ifdef _NO_LONGDBL
	union { int i; double d; } _double_ = {0};
#  define _fpvalue (_double_.d)
# else
	union { int i; _LONG_DOUBLE ld; } _long_double_ = {0};
#  define _fpvalue (_long_double_.ld)
	int tmp;
# endif
d409 2
a410 2
	char expstr[7];		/* buffer for exponent string */
#endif
d420 1
a420 1
	char buf[BUF];		/* space for %c, %[diouxX], %[eEfgG] */
d895 2
a896 2
			tmp = _ldcheck (&_fpvalue);
			if (tmp == 2) {
d907 1
a907 1
			if (tmp == 1) {
d1050 2
a1051 2
						if ((n = (int)_wcrtomb_r (data, 
                                                     buf, wcp[m], &ps)) == -1) {
d1064 2
a1065 2
					if ((size = (int)_wcsrtombs_r (data, 
                                                   NULL, &wcp, 0, &ps)) == -1) {
d1071 1
a1071 1
 
d1074 12
a1085 7
 
				if ((malloc_buf = 
				    (char *)_malloc_r (data, size + 1)) == NULL) {
					fp->_flags |= __SERR;
					goto error;
				}
                             
d1088 2
a1089 2
				if (_wcsrtombs_r (data, malloc_buf, 
                                                 &wcp, size, &ps) != size) {
a1092 1
				cp = malloc_buf;
d1278 1
a1278 1
						PRINT (".", 1);
d1282 1
a1282 1
					PRINT (".", 1);
a1328 15
# ifdef _NO_LONGDBL
extern char *_dtoa_r _PARAMS((struct _reent *, double, int,
			      int, int *, int *, char **));
#  define _DTOA_R _dtoa_r
#  define FREXP frexp
# else
extern char *_ldtoa_r _PARAMS((struct _reent *, _LONG_DOUBLE, int,
			      int, int *, int *, char **));
#  define _DTOA_R _ldtoa_r
/* FIXME - frexpl is not yet supported; and cvt infloops if (double)f
   converts a finite value into infinity.  */
/* #  define FREXP frexpl */
#  define FREXP(f,e) ((_LONG_DOUBLE) frexp ((double)f, e))
# endif

a1335 13
# ifdef _NO_LONGDBL
static char *
_DEFUN(cvt, (data, value, ndigits, flags, sign, decpt, ch, length, buf),
       struct _reent *data _AND
       double value _AND
       int ndigits  _AND
       int flags    _AND
       char *sign   _AND
       int *decpt   _AND
       int ch       _AND
       int *length  _AND
       char *buf)
# else
d1337 2
a1338 11
_DEFUN(cvt, (data, value, ndigits, flags, sign, decpt, ch, length, buf),
       struct _reent *data _AND
       _LONG_DOUBLE value  _AND
       int ndigits         _AND
       int flags           _AND
       char *sign          _AND
       int *decpt          _AND
       int ch              _AND
       int *length         _AND
       char *buf)
# endif
d1431 1
a1431 4
_DEFUN(exponent, (p0, exp, fmtch),
       char *p0 _AND
       int exp  _AND
       int fmtch)
d1434 1
a1434 1
	char expbuf[10];
d1449 1
a1449 1
	t = expbuf + 10;
d1455 1
a1455 1
		for (; t < expbuf + 10; *p++ = *t++);
@


1.57
log
@* libc/stdio/vfprintf.c (_VFPRINTF_R, cvt, exponent, chclass)
(get_arg): Support '%a' and '%A'.
@
text
@d322 1
a322 1
#define	QUADINT		0x020		/* quad integer */
d326 1
a326 1
#define	QUADINT		LONGINT
d331 5
a335 1
#define CHARINT		0x200		/* char as integer */
d423 1
a423 1
        memset (&state, '\0', sizeof (state));
d572 1
d574 2
a575 1
		  /* In the C locale, LC_NUMERIC requires
d580 1
d724 1
d728 2
a729 1
			} else {
a730 1
			}
d733 1
d737 2
a738 1
			} else {
a739 1
			}
d741 1
a741 1
		case 'q':
d744 1
d782 2
a784 1
		case 'C':
d806 1
a806 1
		case 'D':
d825 1
d828 2
a832 1
		case 'F':
d851 1
a851 1
				if (ch <= 'G') /* 'E', 'F', or 'G' */
d860 1
a860 1
				if (ch <= 'G') /* 'E', 'F', or 'G' */
d882 1
a882 1
				if (ch <= 'G') /* 'E', 'F', or 'G' */
d891 1
a891 1
				if (ch <= 'G') /* 'E', 'F', or 'G' */
d901 1
d919 3
a921 1
			} else if (prec == -1) {
d938 1
d941 1
d979 1
d982 1
d986 1
a986 1
		case 'O':
d1009 1
d1011 1
d1093 1
a1093 1
		case 'U':
d1382 1
d1413 3
a1415 1
	} else if (ch == 'f' || ch == 'F') {
d1454 1
d1456 3
d1648 1
a1648 1
#ifdef _MB_CAPABLE
d1651 3
a1653 3
  int nbytes; 
#endif
    
d1658 1
a1658 1
#ifdef _MB_CAPABLE
d1660 1
a1660 1
#endif
d1666 1
a1666 1
#ifdef _MB_CAPABLE
d1676 1
a1676 1
#else
d1682 1
a1682 1
#endif
d1699 1
a1699 1
	  
d1706 1
a1706 1
                  /* No flag needed, since short and char promote to int.  */
d1714 1
d1745 1
d1748 1
d1755 1
d1774 1
a1774 1
#ifndef _NO_LONGLONG
d1777 1
a1777 1
#endif
d1786 1
d1789 2
a1791 1
		  case 'F':
d1796 1
a1796 1
#ifndef _NO_LONGDBL
d1800 1
a1800 1
#endif
d1804 1
d1806 1
d1812 1
d1816 1
d1819 1
d1823 1
@


1.56
log
@* libc/stdio/vfprintf.c: Fix typo in comments that breaks docs.
@
text
@a140 1
#include <string.h>
a141 1
#ifdef _HAVE_STDC
a142 3
#else
#include <varargs.h>
#endif
d241 2
a242 1
_EXFUN(cvt, (struct _reent *, double, int, int, char *, int *, int, int *));
d245 2
a246 1
_EXFUN(cvt, (struct _reent *, _LONG_DOUBLE, int, int, char *, int *, int, int *));
d375 1
a375 1
	char *decimal_point = localeconv()->decimal_point;
d377 1
a377 1
#ifdef _NO_LONGDBL
d379 2
a380 2
	#define _fpvalue (_double_.d)
#else
d382 3
a384 3
	#define _fpvalue (_long_double_.ld)
	int tmp;  
#endif
d814 2
d822 1
a822 7
			if (prec == -1) {
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

#ifdef _NO_LONGDBL
d856 1
a856 1
#else /* !_NO_LONGDBL */
d886 24
a909 1
#endif /* !_NO_LONGDBL */
d914 1
a914 1
				&expt, ch, &ndig);
d924 1
a924 1
			if (ch <= 'e') {	/* 'e' or 'E' fmt */
d1086 3
a1088 1
			if (flags & ALT && _uquad != 0)
d1090 1
d1183 1
a1183 1
		 * If flags&FPT, ch must be in [eEfg].
d1191 1
a1191 1
		else if (flags & HEXPREFIX)
d1199 1
a1199 1
		if (sign) {
d1201 1
a1201 3
		} else if (flags & HEXPREFIX) {
			ox[0] = '0';
			ox[1] = ch;
a1202 1
		}
d1242 1
a1242 1
			} else {	/* 'e' or 'E' */
d1244 3
a1246 3
					ox[0] = *cp++;
					ox[1] = '.';
					PRINT (ox, 2);
d1257 1
a1257 1
#else
d1286 1
a1286 1
#ifdef _NO_LONGDBL
d1289 3
a1291 1
#else
d1294 6
a1299 3
#undef word0
#define word0(x) ldword0(x)
#endif
d1301 8
a1308 1
#ifdef _NO_LONGDBL
d1310 1
a1310 1
_DEFUN(cvt, (data, value, ndigits, flags, sign, decpt, ch, length),
d1318 3
a1320 2
       int *length)
#else
d1322 1
a1322 1
_DEFUN(cvt, (data, value, ndigits, flags, sign, decpt, ch, length),
d1330 3
a1332 2
       int *length)
#endif
d1336 10
a1345 3
#ifdef _NO_LONGDBL
        union double_union tmp;
#else
a1350 1
#endif
d1352 39
a1390 1
	if (ch == 'f' || ch == 'F') {
d1393 2
a1394 2
		/* To obtain ndigits after the decimal point for the 'e' 
		 * and 'E' formats, round to ndigits + 1 significant 
d1403 1
a1403 20
#ifdef _NO_LONGDBL
        tmp.d = value;

	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
		*sign = '-';
        } else
		*sign = '\000';

	digits = _dtoa_r (data, value, mode, ndigits, decpt, &dsgn, &rve);
#else /* !_NO_LONGDBL */
	ld.val = value;
	if (ld.ieee.sign) { /* this will check for < 0 and -0.0 */
		value = -value;
		*sign = '-';
        } else
		*sign = '\000';

	digits = _ldtoa_r (data, value, mode, ndigits, decpt, &dsgn, &rve);
#endif /* !_NO_LONGDBL */
d1428 2
a1429 1
	char expbuf[40];
d1432 1
a1432 1
	*p++ = fmtch;
d1439 1
a1439 1
	t = expbuf + 40;
d1445 1
a1445 1
		for (; t < expbuf + 40; *p++ = *t++);
d1448 2
a1449 1
		*p++ = '0';
d1540 1
a1540 1
  /* 40-47 */  OTHER,   OTHER,   OTHER,   SPEC,    SPEC,    SPEC,    SPEC,    SPEC,
d1544 1
a1544 1
  /* 60-67 */  OTHER,   OTHER,   OTHER,   SPEC,    SPEC,    SPEC,    SPEC,    SPEC, 
d1753 2
@


1.55
log
@	Add support for asnprintf, and improve *printf documentation.
	* libc/stdio/Makefile.am (ELIX_SOURCES): Rename...
	(ELIX_2_SOURCES): ...to this.
	(ELIX_4_SOURCES): Add new variable.  Build asnprintf.
	(GENERAL_SOURCES): Move dprintf to ELIX_4_SOURCES.
	(CHEWOUT_FILES): Include diprintf in documentation.
	* libc/stdio/Makefile.in: Regenerate.
	* libc/stdio/diprintf.c: Improve documentation.
	* libc/stdio/dprintf.c: Likewise.
	* libc/stdio/siprintf.c: Likewise.
	* libc/stdio/sprintf.c: Likewise.
	* libc/stdio/vfprintf.c: Likewise.
	* libc/stdio/viprintf.c: Likewise.
	* libc/stdio/vsniprintf.c: Consolidate documentation.
	* libc/stdio/asiprintf.c: Refer to documentation.
	* libc/stdio/asprintf.c: Likewise.
	* libc/stdio/fiprintf.c: Likewise.
	* libc/stdio/fprintf.c: Likewise.
	* libc/stdio/iprintf.c: Likewise.
	* libc/stdio/printf.c: Likewise.
	* libc/stdio/sniprintf.c: Likewise.
	* libc/stdio/vdiprintf.c: Likewise.
	* libc/stdio/vdprintf.c: Likewise.
	* libc/stdio/vsiprintf.c: Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Handle asnprintf.
	* libc/stdio/asniprintf.c (asniprintf, _asniprintf_r): New file.
	* libc/stdio/asnprintf.c (asnprintf, _asnprintf_r): New file.
	* libc/stdio/vasniprintf.c (vasniprintf, _vasniprintf_r): New
	file.
	* libc/stdio/vasnprintf.c (vasnprintf, _vasnprintf_r): New file.
	* libc/stdio/vdprintf.c (_vdprintf_r): Rewrite to avoid malloc in
	typical case.
	* libc/stdio/vdiprintf.c (_vdiprintf_r): Likewise.
	* libc/include/stdio.h: Add prototypes for new functions; sort
	existing functions.
@
text
@d39 1
a39 1
<<vprintf>>, <<vfprintf>>, <<vsprintf>>, <<vsnprintf>>, <<vasprintf>>, vasnprintf>>---format argument list
@


1.54
log
@
2007-04-25  Eric Blake  <ebb9@@byu.net>

        * libc/stdio/vfprintf.c (get_arg): Support %1$lc.  Simplify types
        that promote to int.
@
text
@d2 1
a2 1
 * Copyright (c) 1990, 2006 The Regents of the University of California.
d39 1
a39 1
<<vprintf>>, <<vfprintf>>, <<vsprintf>>---format argument list
d49 4
a59 1
	int vasprintf(char **<[strp]>, const char *<[fmt]>, va_list <[list]>);
d62 3
d68 1
a68 3
	int _vfprintf_r(struct _reent *<[reent]>, FILE *<[fp]>, const char *<[fmt]>,
                        va_list <[list]>);
	int _vasprintf_r(struct _reent *<[reent]>, char **<[str]>,
d72 1
a72 1
	int _vsnprintf_r(struct _reent *<[reent]>, char *<[str]>, size_t <[size]>,
d74 6
a79 58

TRAD_SYNOPSIS
	#include <stdio.h>
	#include <varargs.h>
	int vprintf( <[fmt]>, <[list]>)
	char *<[fmt]>;
	va_list <[list]>;

	int vfprintf(<[fp]>, <[fmt]>, <[list]>)
	FILE *<[fp]>;
	char *<[fmt]>;
	va_list <[list]>;

	int vasprintf(<[strp]>, <[fmt]>, <[list]>)
	char **<[strp]>;
	char *<[fmt]>;
	va_list <[list]>;

	int vsprintf(<[str]>, <[fmt]>, <[list]>)
	char *<[str]>;
	char *<[fmt]>;
	va_list <[list]>;

	int vsnprintf(<[str]>, <[size]>, <[fmt]>, <[list]>)
	char *<[str]>;
        size_t <[size]>;
	char *<[fmt]>;
	va_list <[list]>;

	int _vprintf_r(<[reent]>, <[fmt]>, <[list]>)
	struct _reent *<[reent]>;
	char *<[fmt]>;
	va_list <[list]>;

	int _vfprintf_r(<[reent]>, <[fp]>, <[fmt]>, <[list]>)
	struct _reent *<[reent]>;
	FILE *<[fp]>;
	char *<[fmt]>;
	va_list <[list]>;

	int _vasprintf_r(<[reent]>, <[strp]>, <[fmt]>, <[list]>)
	struct _reent *<[reent]>;
	char **<[strp]>;
	char *<[fmt]>;
	va_list <[list]>;

	int _vsprintf_r(<[reent]>, <[str]>, <[fmt]>, <[list]>)
	struct _reent *<[reent]>;
	char *<[str]>;
	char *<[fmt]>;
	va_list <[list]>;

	int _vsnprintf_r(<[reent]>, <[str]>, <[size]>, <[fmt]>, <[list]>)
	struct _reent *<[reent]>;
	char *<[str]>;
        size_t <[size]>;
	char *<[fmt]>;
	va_list <[list]>;
d82 11
a92 5
<<vprintf>>, <<vfprintf>>, <<vasprintf>>, <<vsprintf>> and <<vsnprintf>> are 
(respectively) variants of <<printf>>, <<fprintf>>, <<asprintf>>, <<sprintf>>,
and <<snprintf>>.  They differ only in allowing their caller to pass the 
variable argument list as a <<va_list>> object (initialized by <<va_start>>) 
rather than directly accepting a variable number of arguments.
d95 1
a95 6
The return values are consistent with the corresponding functions:
<<vasprintf>>/<<vsprintf>> returns the number of bytes in the output string,
save that the concluding <<NULL>> is not counted.
<<vprintf>> and <<vfprintf>> return the number of characters transmitted.
If an error occurs, <<vprintf>> and <<vfprintf>> return <<EOF>> and
<<vasprintf>> returns -1.  No error returns occur for <<vsprintf>>.
d98 2
a99 1
ANSI C requires all three functions.
d1204 1
a1204 1
					if (expt < ndig || (flags & ALT) != 0) {
d1210 1
a1210 1
					if(expt || ndig || (flags & ALT)) {
d1224 1
a1224 1
					PRINT (cp, ndig-expt);
d1231 2
a1232 2
                                       if (_fpvalue) {
						PRINT (cp, ndig-1);
@


1.53
log
@	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't zero pad on infinity
	or NaN with %05f.
@
text
@d1606 2
a1607 1
  enum types { INT, LONG_INT, SHORT_INT, CHAR_INT, QUAD_INT, CHAR, CHAR_PTR, DOUBLE, LONG_DOUBLE, WIDE_CHAR };
d1666 1
a1666 7
		  if (*fmt == 'h')
		    {
		      flags |= CHARINT;
		      ++fmt;
		    }
		  else
		    flags |= SHORTINT;
d1681 1
a1681 4
		  if (sizeof (size_t) < sizeof (int))
		    /* POSIX states size_t is 16 or more bits, as is short.  */
		    flags |= SHORTINT;
		  else if (sizeof (size_t) == sizeof (int))
d1693 1
a1693 5
		  if (sizeof (ptrdiff_t) < sizeof (int))
		    /* POSIX states ptrdiff_t is 16 or more bits, as
		       is short.  */
		    flags |= SHORTINT;
		  else if (sizeof (ptrdiff_t) == sizeof (int))
a1729 4
		    else if (flags & SHORTINT)
		      spec_type = SHORT_INT;
		    else if (flags & CHARINT)
		      spec_type = CHAR_INT;
d1762 4
a1765 1
		    spec_type = CHAR;
a1788 3
		      case CHAR:
		      case CHAR_INT:
		      case SHORT_INT:
a1872 3
	case CHAR_INT:
	case SHORT_INT:
	case CHAR:
@


1.52
log
@	* libc/stdio/vfprintf.c (_VFPRINTF_R): Avoid multibyte when not
	_MB_CAPABLE.
@
text
@d882 6
a887 1
			/* do this before tricky precision changes */
d896 1
d905 1
d910 1
a910 1
			
d927 1
d936 1
@


1.51
log
@	* libc/include/limits.h (NL_ARGMAX): Define a default value.
	* libc/stdio/vfprintf.c (MAX_POS_ARGS): Define in terms of
	NL_ARGMAX, if present.
@
text
@d164 2
a165 2
#define VFPRINTF vfiprintf
#define _VFPRINTF_R _vfiprintf_r
d167 5
a171 5
#define VFPRINTF vfprintf
#define _VFPRINTF_R _vfprintf_r
#ifndef NO_FLOATING_POINT
#define FLOATING_POINT
#endif
d824 1
d829 3
a831 3
				if ((size = (int)_wcrtomb_r (data, cp, 
				    	       (wchar_t)GET_ARG (N, ap, wint_t), 
					        &ps)) == -1) {
d836 3
a838 1
			else {
d1016 1
d1020 1
a1020 1
 
d1024 1
a1024 1
 
d1028 1
a1028 1
  				if (prec >= 0) {
d1073 1
@


1.50
log
@
2007-04-23  Brian Dessent  <brian@@dessent.net>

        * libc/stdio/vfprintf.c (_vfprintf_r): When the alternate-form flag
        has been specified with types 'f', 'F', 'g', or 'G', ensure the
        trailing decimal is printed.
@
text
@d323 5
a327 1
#define MAX_POS_ARGS 32
@


1.49
log
@	* libc/stdio/vfprintf.c (_VFPRINTF_F, cvt): Don't confuse %F with %e.
	(chclass): Recognize 'F', 'X', 'n', and not 'W'.
	(get_arg): Handle %1$F, %1$n.
@
text
@d1238 1
a1238 1
					if(expt || ndig) {
@


1.48
log
@
2007-03-15  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/local.h (cantwrite, FREEUB, FREELB): Make reentrant.
	(__smakebuf): Rename...
	(__smakebuf_r): to this.
	* libc/stdio/fvwrite.h (__swsetup_r): Rename, from __swsetup.
	* libc/stdio/makebuf.c (__smakebuf): Detect failed asprint
	allocation, then rename...
	(__smakebuf_r): ...to this and fix reentrancy.
	* libc/stdio/wsetup.c (__swsetup): Detect failed asprintf
	allocation, then rename...
	(__swsetup_r): ...to this and fix reentrancy.
	* libc/stdio/fseek.c (_fseek_r): Fix reentrancy.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/fclose.c (_fclose_r): Likewise.
	* libc/stdio/fread.c (_fread_r): Likewise.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/wbuf.c (__swbuf_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Set errno properly on
	failed asprintf allocation, and fix reentrancy.
	* libc/stdio/snprintf.c (snprintf, _snprintf_r): Report overflow,
	as required by POSIX.
	* libc/stdio/sniprintf.c (sniprintf, _sniprintf_r): Likewise.
	* libc/stdio/vsnprintf.c (vsnprintf, _vsnprintf_r): Likewise.
	* libc/stdio/vsniprintf.c (vsniprintf, _vsniprintf_r): Likewise.
@
text
@d879 1
a879 1
				if (ch == 'E' || ch == 'F' || ch == 'G')
d887 1
a887 1
				if (ch == 'E' || ch == 'F' || ch == 'G')
d908 1
a908 1
				if (ch == 'E' || ch == 'F' || ch == 'G')
d916 1
a916 1
				if (ch == 'E' || ch == 'F' || ch == 'G')
d932 1
a932 1
					ch = (ch == 'g') ? 'e' : 'E';
d935 3
a937 1
			} 
d1192 1
d1344 1
a1344 1
	if (ch == 'f') {
d1380 1
a1380 1
		if (ch == 'f') {
d1511 1
a1511 1
  /* 40-47 */  OTHER,   OTHER,   OTHER,   SPEC,    SPEC,    SPEC,    OTHER,   SPEC, 
d1513 2
a1514 2
  /* 50-57 */  OTHER,   OTHER,   OTHER,   SPEC,    OTHER,   SPEC,    OTHER,   SPEC, 
  /* 58-5f */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
d1516 1
a1516 1
  /* 68-6f */  MODFR,   SPEC,    MODFR,   OTHER,   MODFR,   OTHER,   OTHER,   SPEC, 
d1741 1
d1756 1
@


1.47
log
@
2006-11-14  Eric Blake  <ebb9@@byu.net>

        * libc/stdio/vfprintf.c (_vfprintf_r): Support ' flag.
        (chclass): ' is a flag.  j, t, and z are modifiers.
@
text
@d547 1
a547 1
	if (cantwrite (fp)) {
@


1.46
log
@
2006-09-26  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdio.h[_REENT_SMALL]: Do not allow macros
        for clearerr, feof, or fileno.
        * libc/include/sys/reent.h[_REENT_SMALL](struct _reent): Change
        the dummy std stream scheme to use pointers to const external
        fake files, one for each standard stream.
        * libc/stdio/local.h (CHECK_INIT): Change to take a file pointer
        argument.  For _REENT_SMALL, reset the file pointer if it
        matches one of the fake std stream pointers.
        * libc/stdio/clearerr.c: Fix CHECK_INIT macro to add file pointer
        argument.
        * libc/stdio/fclose.c: Ditto.
        * libc/stdio/feof.c: Ditto.
        * libc/stdio/ferror.c: Ditto.
        * libc/stdio/fflush.c: Ditto.
        * libc/stdio/fgetc.c: Ditto.
        * libc/stdio/fgets.c: Ditto.
        * libc/stdio/fileno.c: Ditto.
        * libc/stdio/findfp.c: Ditto.
        * libc/stdio/fputc.c: Ditto.
        * libc/stdio/fputs.c: Ditto.
        * libc/stdio/fread.c: Ditto.
        * libc/stdio/freopen.c: Ditto.
        * libc/stdio/fseek.c: Ditto.
        * libc/stdio/ftell.c: Ditto.
        * libc/stdio/fwrite.c: Ditto.
        * libc/stdio/getc.c: Ditto.
        * libc/stdio/getdelim.c: Ditto.
        * libc/stdio/putc.c: Ditto.
        * libc/stdio/refill.c: Ditto.
        * libc/stdio/setvbuf.c: Ditto.
        * libc/stdio/ungetc.c: Ditto.
        * libc/stdio/vfprintf.c: Ditto.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/wbuf.c: Ditto.: Ditto.
        * libc/stdio/wsetup.c: Ditto.
        * libc/stdio64/freopen64.c: Ditto.
        * libc/stdio64/fseeko64.c: Ditto.
        * libc/stdio64/ftello64.c: Ditto.
        * libc/machine/powerpc/vfprintf.c: Ditto.
        * libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@d613 6
d1504 1
a1504 1
  /* 20-27 */  FLAG,    OTHER,   OTHER,   FLAG,    DOLLAR,  OTHER,   OTHER,   OTHER,
d1513 3
a1515 3
  /* 68-6f */  MODFR,   SPEC,    OTHER,   OTHER,   MODFR,   OTHER,   OTHER,   SPEC, 
  /* 70-77 */  SPEC,    MODFR,   OTHER,   SPEC,    OTHER,   SPEC,    OTHER,   OTHER,
  /* 78-7f */  SPEC,    OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
@


1.45
log
@
2006-09-06  Eric Blake  <ebb9@@byu.net>

        * libc/stdio/vfprintf.c (_vfprintf_r, get_arg): Add 'hh', 'j',
        't', and 'z' modifiers.
@
text
@d543 1
a543 1
	CHECK_INIT (data);
@


1.44
log
@
2006-06-14  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdio.h: Add new reentrant I/O prototypes for
        read/write functions.  Change getc/putc macros to have reentrant underlying
        macros/functions.  This includes __sgetc_raw_r, __sgetc_r, and __sputc_r.
        * libc/stdio/fgetc.c: Fix and/or add reentrant version to call
        new reentrant I/O functions/macros for reading/writing.
        * libc/stdio/fgets.c: Ditto.
        * libc/stdio/fputc.c: Ditto.
        * libc/stdio/fputs.c: Ditto.
        * libc/stdio/fread.c: Ditto.
        * libc/stdio/fseek.c: Ditto.
        * libc/stdio64/fseeko64.c: Ditto.
        * libc/stdio/fwrite.c: Ditto.
        * libc/stdio/getc.c: Ditto.
        * libc/stdio/getc_u.c: Ditto.
        * libc/stdio/getchar.c: Ditto.
        * libc/stdio/getchar_u.c: Ditto.
        * libc/stdio/putc.c: Ditto.
        * libc/stdio/putc_u.c: Ditto.
        * libc/stdio/putchar.c: Ditto.
        * libc/stdio/puts.c: Ditto.
        * libc/stdio/vfprintf.c: Ditto.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/fvwrite.c: Change __sfvwrite into reentrant __sfvwrite_r.
        Change all previous callers of __sfvwrite.  Set errno to EBADF and
        set error flag on if attempt is made to write to file that does not
        allow writing.
        * libc/stdio/fvwrite.h: Fix new reentrant prototypes.
        * libc/stdio/local.h: Ditto.
        * libc/stdio/refill.c: Turn __srefill into reentrant __srefill_r.
        Set errno to EBADF and the error flag on if attempt is made to
        read unreadable file.  Change all previous callers of __srefill.
        * libc/stdio/rget.c
        * libc/stdio/wbuf.c: Turn __swbuf into reentrant __swbuf_r.  Change
        all previous callers of __swbuf.
        * libc/sys/linux/machine/i386/huge_val.h: Ifdef out file contents since
        huge value macros are already defined correctly for i386 by <math.h>.
@
text
@d2 1
a2 1
 * Copyright (c) 1990 The Regents of the University of California.
d185 1
d376 1
d432 1
a432 1
	int ndig;		/* actual number of digits returned by cvt */
d522 1
d528 1
d534 1
d539 1
d756 6
a761 1
			flags |= SHORTINT;
d774 37
d967 2
d1579 1
a1579 1
  enum types { INT, LONG_INT, SHORT_INT, QUAD_INT, CHAR, CHAR_PTR, DOUBLE, LONG_DOUBLE, WIDE_CHAR };
d1638 7
a1644 1
		  flags |= SHORTINT;
d1652 37
d1717 2
d1774 1
d1860 1
@


1.44.2.1
log
@Apply the following mainline patches to cr-0x5f1 branch:

2006-10-11  Yang Tse  <yangsita@@gmail.com>

	* libc/include/machine/setjmp.h: Use __extension__ keyword for gcc's
	braced-groups.

2006-10-11  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/reent/reeent.c (_reclaim_reent): Free _REENT_MP_RESULT.

2006-09-13  Patrick Mansfield <patmans@@us.ibm.com>

	* libc/include/math.h: Remove _CONST from _LIB_VERSION, as it is
	supposed to be writable.
	* libm/common/s_lib_ver.c: Ditto.

2006-09-06  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_vfprintf_r, get_arg): Add 'hh', 'j',
	't', and 'z' modifiers.

2006-08-22  Eric Blake  <ebb9@@byu.net>

	* libc/posix/popen.c (popen): Don't close output end of pipe in
	child if stdout was closed on entry.
	[HAVE_FCNTL]: In parent, mark file as close-on-exec, per POSIX.

2006-08-17  Brian Ford  <Brian.Ford@@FlightSafety.com>

	* libc/time/gmtime.c: Correct man page; clock is not a
	local time and no conversion occurs.
@
text
@d2 1
a2 1
 * Copyright (c) 1990, 2006 The Regents of the University of California.
a184 1
#include <stdint.h>
a374 1
#define CHARINT		0x200		/* char as integer */
d430 1
a430 1
	int ndig = 0;		/* actual number of digits returned by cvt */
a519 1
	    flags&CHARINT ? (long)(signed char)GET_ARG (N, ap, int) : \
a524 1
	    flags&CHARINT ? (u_long)(unsigned char)GET_ARG (N, ap, int) : \
a529 1
	    flags&CHARINT ? (long)(signed char)GET_ARG (N, ap, int) : \
a533 1
	    flags&CHARINT ? (u_long)(unsigned char)GET_ARG (N, ap, int) : \
d750 1
a750 6
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else {
				flags |= SHORTINT;
			}
a762 37
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
		  goto rflag;
		case 'z':
		  if (sizeof (size_t) < sizeof (int))
		    /* POSIX states size_t is 16 or more bits, as is short.  */
		    flags |= SHORTINT;
		  else if (sizeof (size_t) == sizeof (int))
		    /* no flag needed */;
		  else if (sizeof (size_t) <= sizeof (long))
		    flags |= LONGINT;
		  else
		    /* POSIX states that at least one programming
		       environment must support size_t no wider than
		       long, but that means other environments can
		       have size_t as wide as long long.  */
		    flags |= QUADINT;
		  goto rflag;
		case 't':
		  if (sizeof (ptrdiff_t) < sizeof (int))
		    /* POSIX states ptrdiff_t is 16 or more bits, as
		       is short.  */
		    flags |= SHORTINT;
		  else if (sizeof (ptrdiff_t) == sizeof (int))
		    /* no flag needed */;
		  else if (sizeof (ptrdiff_t) <= sizeof (long))
		    flags |= LONGINT;
		  else
		    /* POSIX states that at least one programming
		       environment must support ptrdiff_t no wider than
		       long, but that means other environments can
		       have ptrdiff_t as wide as long long.  */
		    flags |= QUADINT;
		  goto rflag;
a918 2
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
d1529 1
a1529 1
  enum types { INT, LONG_INT, SHORT_INT, CHAR_INT, QUAD_INT, CHAR, CHAR_PTR, DOUBLE, LONG_DOUBLE, WIDE_CHAR };
d1588 1
a1588 7
		  if (*fmt == 'h')
		    {
		      flags |= CHARINT;
		      ++fmt;
		    }
		  else
		    flags |= SHORTINT;
a1595 37
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
		  break;
		case 'z':
		  if (sizeof (size_t) < sizeof (int))
		    /* POSIX states size_t is 16 or more bits, as is short.  */
		    flags |= SHORTINT;
		  else if (sizeof (size_t) == sizeof (int))
		    /* no flag needed */;
		  else if (sizeof (size_t) <= sizeof (long))
		    flags |= LONGINT;
		  else
		    /* POSIX states that at least one programming
		       environment must support size_t no wider than
		       long, but that means other environments can
		       have size_t as wide as long long.  */
		    flags |= QUADINT;
		  break;
		case 't':
		  if (sizeof (ptrdiff_t) < sizeof (int))
		    /* POSIX states ptrdiff_t is 16 or more bits, as
		       is short.  */
		    flags |= SHORTINT;
		  else if (sizeof (ptrdiff_t) == sizeof (int))
		    /* no flag needed */;
		  else if (sizeof (ptrdiff_t) <= sizeof (long))
		    flags |= LONGINT;
		  else
		    /* POSIX states that at least one programming
		       environment must support ptrdiff_t no wider than
		       long, but that means other environments can
		       have ptrdiff_t as wide as long long.  */
		    flags |= QUADINT;
		  break;
a1623 2
		    else if (flags & CHARINT)
		      spec_type = CHAR_INT;
a1678 1
		      case CHAR_INT:
a1763 1
	case CHAR_INT:
@


1.44.2.2
log
@	* libc/stdio/vfprintf.c (_vfprintf_r): Support ' flag.
	(chclass): ' is a flag.  j, t, and z are modifiers.
@
text
@a612 6
		case '\'':
		  /* In the C locale, LC_NUMERIC requires
		     thousands_sep to be the empty string.  And since
		     no other locales are supported (yet), this flag
		     is currently a no-op.  */
		  goto rflag;
d1498 1
a1498 1
  /* 20-27 */  FLAG,    OTHER,   OTHER,   FLAG,    DOLLAR,  OTHER,   OTHER,   FLAG,
d1507 3
a1509 3
  /* 68-6f */  MODFR,   SPEC,    MODFR,   OTHER,   MODFR,   OTHER,   OTHER,   SPEC, 
  /* 70-77 */  SPEC,    MODFR,   OTHER,   SPEC,    MODFR,   SPEC,    OTHER,   OTHER,
  /* 78-7f */  SPEC,    OTHER,   MODFR,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
@


1.44.2.3
log
@2007-10-23  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/stdlib/wcstombs_r.c: Add SUSV2 support for calculating
	size if output buffer is NULL.

2007-10-13  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R) [__OPTIMIZE_SIZE__]:
	Correctly nest else within conditionals.
	Reported by Artur Lipowski.

2007-09-17  Eric Blake  <ebb9@@byu.net>

	Obey POSIX on printf("%.s", (char*)NULL).
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Take precision into account
	for %s on NULL.  Skip NULL check when optimizing for size.

2007-07-31  Eric Blake  <ebb9@@byu.net>

	More POSIX stream corner cases.
	* libc/stdio/findfp.c (__sinit): Open stderr read/write.
	* libc/stdio/fdopen.c (_fdopen_r): Set O_APPEND on fd when
	requested.
	* libc/stdio64/fdopen64.c (_fdopen64_r): Likewise.

2007-07-13  Eric Blake  <ebb9@@byu.net>

	Fix fflush issues.
	* libc/stdio/fflush.c (_fflush_r): New function.
	(fflush): Fix reentrancy and large offset behavior.
	* libc/include/stdio.h (_fflush_r): Add prototype.
	* libc/stdio/fclose.c (_fclose_r): All fflush callers changed.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/fseek.c (_fseek_r): Likewise.
	* libc/stdio/ftell.c (_ftell_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Likewise.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/setvbuf.c (setvbuf): Likewise.
	* libc/stdio/ungetc.c (_ungetc_r): Likewise.
	* libc/stdio/vfprintf.c (__sbprintf): Likewise.
	* libc/stdio/wbuf.c (__swbuf_r): Likewise.
	* libc/stdio64/freopen64.c (_freopen64_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.  Defer to
	32-bit version if not large file.
	* libc/stdio64/ftello64.c (_ftello64_r): Likewise.
	* libc/stdio64/tmpfile64.c (_tmpfile64_r): Avoid compile warning.

2007-06-04  Eric Blake  <ebb9@@byu.net>

	* libc/include/sys/reent.h (struct __sFILE, struct __sFILE64):
	Switch to reentrant callbacks.
	* libc/stdio/local.h (__sread, __swrite, __sseek, __sclose)
	(__sseek64, __swrite64): Fix prototypes.
	[__SCLE]: Pull in setmode declaration.
	* libc/stdio/stdio.c (__sread, __swrite, __sseek, __sclose): Fix
	reentrancy.
	* libc/stdio64/stdio64.c (__sseek64_r, __swrite64_r): Delete.
	(__sseek64, __swrite64): Fix reentrancy.
	* libc/stdio/fseek.c (_fseek_r): Account for overflow, and fix
	reentrancy.
	* libc/stdio/ftell.c (_ftell_r): Likewise.
	* libc/stdio/flags.c (__sflags): Don't lose __SAPP on "a+".
	* libc/stdio/fclose.c (_fclose_r): Fix reentrancy.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Likewise.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/siscanf.c (eofread): Likewise.
	* libc/stdio/sscanf.c (eofread): Likewise.
	* libc/stdio/vsiscanf.c (eofread1): Likewise.
	* libc/stdio/vsscanf.c (eofread1): Likewise.
	* libc/stdio64/freopen64.c (_freopen64_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.
	* libc/stdio64/ftello64.c (_ftello64_r): Likewise.
	* libc/stdio/fflush.c (fflush): Improve reentrancy, although more
	could be fixed.

2007-05-29  Eric Blake  <ebb9@@byu.net>

	Avoid more compiler warnings.
	* libc/stdlib/btowc.c: Add missing header.
	* libc/stdlib/getopt.c (getopt_internal): Initialize variable.
	* libc/stdlib/system.c (do_system) [__CYGWIN__]: Add declaration.
	* libc/stdlib/wctob.c: Add missing header.
	* libc/string/strcpy.c (strcpy): Avoid warnings.
	* libc/string/strrchr.c (strrchr): Likewise.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/argz/argz_add_sep.c (argz_add_sep): Handle empty string
	argument.
	* libc/argz/argz_append.c (argz_append): Handle empty buf argument.
	* libc/argz/argz_create_sep.c (argz_create_sep): Return (NULL, 0)
	on empty input strings.
	* libc/argz/argz_extract.c (argz_extract): Check argz_len before
	looping through argz.
	* libc/argz/argz_stringify.c (argz_stringify): Ditto.

2007-05-27  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Populate 'ox' when
	handling %p.

2007-05-25  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/rewind.c (rewind): Fix regression of 2003-08-22.

2007-05-23  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't truncate %p when
	sizeof(void*) is 8 but sizeof(long) is 4.
	* libc/stdio/vfscanf.c (__SVFSCANF_R): Likewise.  Fix %i scanning
	of "-0x".  Support "-nan" and "inf" for %e.  Audit usage of ungetc
	to fix reentrancy and bug on encoding error in multibyte locales.
	Always return EOF on read error.

2007-05-23  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfscanf.c (__SVFSCANF_R): Support scanf(%1$s).
	Avoid warning when !FLOATING_POINT.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Simplify _NO_POS_ARGS
	slightly.

2007-05-23  Corinna Vinschen  <vinschen@@redhat.com>

	* libc/argz/argz_create_sep.c (argz_create_sep): Initialize *argz_len
	to zero.
	* libc/include/argz.h: Guard against multiple inclusion.  Guard for
	use with C++.

2007-05-17  Charles Wilson  <cygwin@@...>

	* stdio/tmpfile.c: Include <sys/stat.h>.
	* stdio64/tmpfile64.c: Ditto.

2007-05-16  Eric Blake  <ebb9@@byu.net>

	Close security hole in tmpfile.
	* libc/stdio/tmpfile.c (_tmpfile_r): Avoid window between filename
	generation and opening the fd.
	* libc/stdio64/tmpfile64.c (_tmpfile64_r): Likewise.

	* libc/include/math.h (INFINITY, NAN, FP_ILOGB0, FP_ILOGBNAN)
	(MATH_ERRNO, MATH_ERREXCEPT, math_errhandling): Add macros
	required by POSIX.
	* libc/stdlib/ldtoa.c (USE_INFINITY): Rename from INFINITY, to
	avoid clash with <math.h>.

	* libc/stdlib/wctomb_r.c (_wctomb_r): Avoid gcc warnings on cygwin.
	* libc/search/hash.c (__hash_open): Likewise.

2007-05-10  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Fix use of decimal point
	in %f and %e.  Avoid malloc when possible for %S.
	(BUF): Improve stack locality by using smaller size.
	(MAXEXP): Define.
	(exponent): Use for smaller stack size.

2007-05-01  Eric Blake  <ebb9@@byu.net>

	* libc/stdio64/local64.h: Delete, move contents to...
	* libc/stdio/local.h: ...here.
	* libc/stdio64/fdopen64.c: Update includes.
	* libc/stdio64/fopen64.c: Likewise.
	* libc/stdio64/freopen64.c: Likewise.
	* libc/stdio64/fseeko64.c: Likewise.
	* libc/stdio64/ftello64.c: Likewise.
	* libc/stdio/findfp.c (std) [__LARGE64_FILES]: Open stdin, stdout,
	and stderr with 64-bit offset.
	* libc/stdio/fseek.c (_fseek_r): Avoid compile warning.
	* libc/stdio/makebuf.c (__smakebuf_r): Likewise.
	* libc/stdio/mktemp.c (_gettemp): Likewise.

2007-04-25  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (get_arg): Support %1$lc.  Simplify types
	that promote to int.

2007-04-24  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't zero pad on infinity
	or NaN with %05f.

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Avoid multibyte when not
	_MB_CAPABLE.

	* libc/include/limits.h (NL_ARGMAX): Define a default value.
	* libc/stdio/vfprintf.c (MAX_POS_ARGS): Define in terms of
	NL_ARGMAX, if present.

2007-04-23  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/vfprintf.c (_vfprintf_r): When the alternate-form flag
	has been specified with types 'f', 'F', 'g', or 'G', ensure the
	trailing decimal is printed.

2007-04-17  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/sscanf.c: Update documentation comments.
	* libc/stdio/vfscanf.c (__SVFSCANF_R): Handle j, t, and z modifiers.

2007-04-12  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_F, cvt): Don't confuse %F with %e.
	(chclass): Recognize 'F', 'X', 'n', and not 'W'.
	(get_arg): Handle %1$F, %1$n.

2007-04-10  Eric Blake  <ebb9@@byu.net>

	* libc/include/stdio.h (_ELIDABLE_INLINE): Work even when using
	CFLAGS=-O0.

2007-04-09  Eric Blake  <ebb9@@byu.net>

	* libc/include/stdio.h: Add gcc format attributes to printf and
	scanf families.

2007-04-04  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/argz/argz_insert.c: Add stddef.h to get ptrdiff_t type.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/asiprintf.c (_asiprintf_r): Fix reentrancy.
	(asiprintf): Avoid overhead.
	* libc/stdio/asprintf.c (_asprintf_r): Fix reentrancy.
	(asprintf): Avoid overhead.
	* libc/stdio/diprintf.c (_diprintf_r, diprintf): New file.
	* libc/stdio/dprintf.c (_dprintf_r, dprintf): Use _DEFUN.
	* libc/stdio/fiprintf.c (_fiprintf_r): Add reentrant version.
	(fiprintf): Avoid overhead.
	* libc/stdio/fprintf.c (_fprintf_r): Add reentrant version.
	(fprintf): Avoid overhead.
	* libc/stdio/iprintf.c (_iprintf_r): Use _DEFUN.
	(iprintf): Avoid overhead.
	* libc/stdio/printf.c (_printf_r): Use _DEFUN.
	(printf): Avoid overhead.
	* libc/stdio/vasiprintf.c (vasiprintf): Reduce binary size.
	* libc/stdio/vasprintf.c (vasprintf): Reduce binary size.
	* libc/stdio/vdiprintf.c (_vdiprintf_r, vdiprintf): New file.
	* libc/stdio/vdprintf.c (vdprintf): Avoid overhead.
	* libc/stdio/vsiprintf.c (vsiprintf): Reduce binary size.
	* libc/stdio/vsniprintf.c (vsniprintf): Reduce binary size.
	* libc/stdio/vsnprintf.c (vsnprintf): Reduce binary size.
	* libc/stdio/vsprintf.c (vsprintf): Reduce binary size.
	* libc/stdio/Makefile.am (GENERAL_SOURCES): Add diprintf.c,
	vdiprintf.c.
	* libc/include/stdio.h (diprintf, _diprintf_r, vdiprintf)
	(_vdiprintf_r, _fiprintf_r, _vfiprintf_r): Add prototypes.

2007-03-30  Dave Korn  <dave.korn@@artimi.com>

	* libc/include/stdio.h (_ELIDABLE_INLINE):  New macro to conceal
	conflicting inline semantics between C99 and GNU89.
	(__sgetc_r):  Replace static inline with _ELIDABLE_INLINE to be
	compatible with -fkeep-inline-functions usage.
	(__sputc_r):  Likewise for consistency even though disabled.

2007-03-16  Charles Wilson  <cygwin@@...>

	* libc/argz/argz_insert.c: "before" pointer is
	invalid after *argz realloc.  Compute offset
	between "before" and *argz, and use it after
	reallocation instead.

2007-03-16  Eric Blake  <ebb9@@byu.net>

	* libc/stdio64/fseek064.c (_fseeko64_r): Fix reentrancy.
	* libc/stdio64/freopen64.c (_freopen64_r): Ditto.

2007-03-15  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/local.h (cantwrite, FREEUB, FREELB): Make reentrant.
	(__smakebuf): Rename...
	(__smakebuf_r): to this.
	* libc/stdio/fvwrite.h (__swsetup_r): Rename, from __swsetup.
	* libc/stdio/makebuf.c (__smakebuf): Detect failed asprint
	allocation, then rename...
	(__smakebuf_r): ...to this and fix reentrancy.
	* libc/stdio/wsetup.c (__swsetup): Detect failed asprintf
	allocation, then rename...
	(__swsetup_r): ...to this and fix reentrancy.
	* libc/stdio/fseek.c (_fseek_r): Fix reentrancy.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/fclose.c (_fclose_r): Likewise.
	* libc/stdio/fread.c (_fread_r): Likewise.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/wbuf.c (__swbuf_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Set errno properly on
	failed asprintf allocation, and fix reentrancy.
	* libc/stdio/snprintf.c (snprintf, _snprintf_r): Report overflow,
	as required by POSIX.
	* libc/stdio/sniprintf.c (sniprintf, _sniprintf_r): Likewise.
	* libc/stdio/vsnprintf.c (vsnprintf, _vsnprintf_r): Likewise.
	* libc/stdio/vsniprintf.c (vsniprintf, _vsniprintf_r): Likewise.

2007-03-12  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/fvwrite.c (__sfvwrite_r): Fix reentrancy.
	* libc/stdio/vasprintf.c (vasprintf, _vasprintf_r): Pass failed
	allocation to caller.
	* libc/stdio/asprintf.c (_asprintf_r, asprintf): Likewise.
	* libc/stdio/asiprintf.c (_asiprintf_r, asiprintf): Likewise.
	* libc/stdio/vasiprintf.c (vasiprintf, _vasiprintf_r): Likewise.

2007-02-20  Kazunori Asayama <asayama@@sm.sony.co.jp>

	* libc/include/stdio.h: Add declaration for vsiprintf.
@
text
@d164 2
a165 2
# define VFPRINTF vfiprintf
# define _VFPRINTF_R _vfiprintf_r
d167 5
a171 5
# define VFPRINTF vfprintf
# define _VFPRINTF_R _vfprintf_r
# ifndef NO_FLOATING_POINT
#  define FLOATING_POINT
# endif
d174 2
a175 2
#define _NO_POS_ARGS
#ifdef _WANT_IO_POS_ARGS
d265 1
a265 1
	if (ret >= 0 && _fflush_r (rptr, &fake))
d278 9
a286 2
# include <locale.h>
# include <math.h>
d288 1
a288 4
/* For %La, an exponent of 15 bits occupies the exponent character, a
   sign, and up to 5 digits.  */
# define	MAXEXP		7
# define	DEFPREC		6
d290 1
a290 1
# ifdef _NO_LONGDBL
d293 1
a293 1
# else
d297 1
a297 1
# endif
d301 1
a301 1
#endif /* FLOATING_POINT */
a302 9
/* BUF must be big enough for the maximum %#llo (assuming long long is
   at most 64 bits, this would be 23 characters), the maximum
   multibyte character, and the maximum precision of %La (assuming
   long double is at most 128 bits with 113 bits of mantissa, this
   would be 31 characters).  %e, %f, and %g use reentrant storage
   shared with mprec.  All other formats that use buf get by with
   fewer characters.  Making BUF slightly bigger reduces the need for
   malloc in %a and %S, when large precision or long strings are
   processed.  */
d304 2
a305 4
#if defined _MB_CAPABLE && MB_LEN_MAX > BUF
# undef BUF
# define BUF MB_LEN_MAX
#endif
d323 1
a323 5
# ifdef NL_ARGMAX
#  define MAX_POS_ARGS NL_ARGMAX
# else
#  define MAX_POS_ARGS 32
# endif
a404 1
#ifndef _NO_POS_ARGS
d407 1
d420 1
a420 1
	char *decimal_point = _localeconv_r (data)->decimal_point;
d422 1
a422 1
# ifdef _NO_LONGDBL
d424 2
a425 2
#  define _fpvalue (_double_.d)
# else
d427 3
a429 3
#  define _fpvalue (_long_double_.ld)
	int tmp;
# endif
d433 1
a433 1
	char expstr[MAXEXP];	/* buffer for exponent string */
d444 1
a444 1
	char buf[BUF];		/* space for %c, %S, %[diouxX], %[aA] */
d547 1
a547 1
	if (cantwrite (data, fp)) {
d564 1
a565 1
	arg_index = 0;
d606 1
a607 1
		N = arg_index;
d632 1
a634 1
			n = N;
d684 1
a686 1
				n = N;
a819 1
#ifdef _MB_CAPABLE
d824 3
a826 3
				if ((size = (int)_wcrtomb_r (data, cp,
					       (wchar_t)GET_ARG (N, ap, wint_t),
						&ps)) == -1) {
d831 1
a831 3
			else
#endif /* _MB_CAPABLE */
			{
d875 1
a875 6
			/* do this before tricky precision changes

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
d879 1
a879 1
				if (ch <= 'G') /* 'E', 'F', or 'G' */
a883 1
				flags &= ~ZEROPAD;
d887 1
a887 1
				if (ch <= 'G') /* 'E', 'F', or 'G' */
a891 1
				flags &= ~ZEROPAD;
d896 1
a896 1

d908 1
a908 1
				if (ch <= 'G') /* 'E', 'F', or 'G' */
a912 1
				flags &= ~ZEROPAD;
d916 1
a916 1
				if (ch <= 'G') /* 'E', 'F', or 'G' */
a920 1
				flags &= ~ZEROPAD;
d932 1
a932 1
					ch -= 2; /* 'e' or 'E' */
d935 1
a935 3
			}
			else if (ch == 'F')
				ch = 'f';
d994 1
a994 1
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
d998 1
a998 2
			ox[0] = '0';
			ox[1] = ch = 'x';
d1003 1
a1003 7
			cp = GET_ARG (N, ap, char_ptr_t);
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
d1005 1
a1005 1
				size = ((unsigned) prec > 6U) ? 6 : prec;
d1007 1
a1007 4
			else
#endif /* __OPTIMIZE_SIZE__ */
#ifdef _MB_CAPABLE
			if (ch == 'S' || (flags & LONGINT)) {
d1010 1
a1010 1

d1014 1
a1014 1

d1018 1
a1018 1
				if (prec >= 0) {
d1036 1
a1036 1
					if ((size = (int)_wcsrtombs_r (data,
d1043 1
a1043 1

d1046 7
a1052 12

				if (size >= BUF) {
					if ((malloc_buf =
					     (char *)_malloc_r (data, size + 1))
					    == NULL) {
						fp->_flags |= __SERR;
						goto error;
					}
					cp = malloc_buf;
				} else
					cp = buf;

d1055 2
a1056 2
				if (_wcsrtombs_r (data, cp,
						  &wcp, size, &ps) != size) {
d1060 1
d1063 1
a1063 3
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
a1189 1
		 * If flags&FPT, ch must be in [eEfg].
d1235 1
a1235 1
					if(expt || ndig || (flags & ALT)) {
d1244 1
a1244 1
						PRINT (decimal_point, 1);
d1248 2
a1249 2
					PRINT (decimal_point, 1);
					PRINT (cp, ndig - expt);
d1253 5
a1257 5
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, 1);
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
d1341 1
a1341 1
	if (ch == 'f' || ch == 'F') {
d1377 1
a1377 1
		if (ch == 'f' || ch == 'F') {
d1398 1
a1398 1
	char expbuf[MAXEXP];
d1408 1
a1408 1
	t = expbuf + MAXEXP;
d1414 1
a1414 1
		for (; t < expbuf + MAXEXP; *p++ = *t++);
d1508 1
a1508 1
  /* 40-47 */  OTHER,   OTHER,   OTHER,   SPEC,    SPEC,    SPEC,    SPEC,    SPEC,
d1510 2
a1511 2
  /* 50-57 */  OTHER,   OTHER,   OTHER,   SPEC,    OTHER,   SPEC,    OTHER,   OTHER,
  /* 58-5f */  SPEC,    OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   OTHER,
d1513 1
a1513 1
  /* 68-6f */  MODFR,   SPEC,    MODFR,   OTHER,   MODFR,   OTHER,   SPEC,    SPEC,
d1585 1
a1585 2
  /* Only need types that can be reached via vararg promotions.  */
  enum types { INT, LONG_INT, QUAD_INT, CHAR_PTR, DOUBLE, LONG_DOUBLE, WIDE_CHAR };
d1644 7
a1650 1
                  /* No flag needed, since short and char promote to int.  */
d1665 4
a1668 1
		  if (sizeof (size_t) <= sizeof (int))
d1680 5
a1684 1
		  if (sizeof (ptrdiff_t) <= sizeof (int))
d1721 4
a1737 1
		  case 'F':
a1751 1
		  case 'n':
d1755 1
a1755 4
		    if (flags & LONGINT)
		      spec_type = WIDE_CHAR;
		    else
		      spec_type = INT;
d1779 3
d1866 3
@


1.43
log
@
2005-10-28  Bob Wilson  <bob.wilson@@acm.org>

        * libc/stdio/siprintf.c: Wrap long lines in ANSI_SYNOPSIS.
        * libc/stdio/siscanf.c: Likewise.
        * libc/stdio/sprintf.c: Likewise.
        * libc/stdio/sscanf.c: Likewise.
        * libc/stdio/vfprintf.c: Likewise.
        * libc/stdio/vfscanf.c: Likewise.
        * libc/stdio/viprintf.c: Likewise.
        * libc/stdio/viscanf.c: Likewise.
@
text
@d215 2
a216 1
_DEFUN(__sprint, (fp, uio),
d226 1
a226 1
	err = __sfvwrite(fp, uio);
d473 1
a473 1
		if (__sprint(fp, &uio)) \
d488 1
a488 1
	if (uio.uio_resid && __sprint(fp, &uio)) \
@


1.43.2.1
log
@2006-09-17  Paul Brook  <paul@@codesourcery.com>

	newlib/
	Backport form mainline
	2006-09-26  Jeff Johnston  <jjohnstn@@redhat.com>
	* libc/include/stdio.h: Do not allow macros
	for clearerr, feof, or fileno.
	* libc/include/sys/reent.h[_REENT_SMALL](struct _reent): Change
	the dummy std stream scheme to use pointers to const external
	fake files, one for each standard stream.
	* libc/stdio/local.h (CHECK_INIT): Change to take a file pointer
	argument.  For _REENT_SMALL, reset the file pointer if it
	matches one of the fake std stream pointers.
	* libc/stdio/clearerr.c: Fix CHECK_INIT macro to add file pointer
	argument.
	* libc/stdio/fclose.c: Ditto.
	* libc/stdio/feof.c: Ditto.
	* libc/stdio/ferror.c: Ditto.
	* libc/stdio/fflush.c: Ditto.
	* libc/stdio/fgetc.c: Ditto.
	* libc/stdio/fgets.c: Ditto.
	* libc/stdio/fileno.c: Ditto.
	* libc/stdio/findfp.c: Ditto.
	* libc/stdio/fputc.c: Ditto.
	* libc/stdio/fputs.c: Ditto.
	* libc/stdio/fread.c: Ditto.
	* libc/stdio/freopen.c: Ditto.
	* libc/stdio/fseek.c: Ditto.
	* libc/stdio/ftell.c: Ditto.
	* libc/stdio/fwrite.c: Ditto.
	* libc/stdio/getc.c: Ditto.
	* libc/stdio/getdelim.c: Ditto.
	* libc/stdio/putc.c: Ditto.
	* libc/stdio/refill.c: Ditto.
	* libc/stdio/setvbuf.c: Ditto.
	* libc/stdio/ungetc.c: Ditto.
	* libc/stdio/vfprintf.c: Ditto.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdio/wbuf.c: Ditto.: Ditto.
	* libc/stdio/wsetup.c: Ditto.
	* libc/stdio64/freopen64.c: Ditto.
	* libc/stdio64/fseeko64.c: Ditto.
	* libc/stdio64/ftello64.c: Ditto.
	* libc/machine/powerpc/vfprintf.c: Ditto.
	* libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@d536 1
a536 1
	CHECK_INIT (data, fp);
@


1.42
log
@
2005-10-14  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfprintf.c (_VFPRINTF_R): Fix up "inf" and
        "nan" processing for systems that have long double support.
@
text
@d57 2
a58 1
	int vsnprintf(char *<[str]>, size_t <[size]>, const char *<[fmt]>, va_list <[list]>);
d64 6
a69 6
	int _vasprintf_r(struct _reent *<[reent]>, char **<[str]>, const char *<[fmt]>,
                        va_list <[list]>);
	int _vsprintf_r(struct _reent *<[reent]>, char *<[str]>, const char *<[fmt]>,
                        va_list <[list]>);
	int _vsnprintf_r(struct _reent *<[reent]>, char *<[str]>, size_t <[size]>, const char *<[fmt]>,
                        va_list <[list]>);
@


1.41
log
@
2005-10-11  David Weatherford  <weath@@tensilica.com>

        * libc/stdio/vfprintf.c (_VFPRINTF_R): Recognize 'F' format.
        Print "inf" and "nan" in lowercase for e/f/g formats and in
        uppercase for E/F/G formats.
@
text
@d852 4
a855 1
				cp = "Inf";
d860 4
a863 1
				cp = "NaN";
@


1.40
log
@
2005-06-16  Christopher Faylor  <cgf@@timesys.com>

        * libc/stdio/vfprintf.c (cvt): Don't rely on pointer aliasing to
        determine characteristics of long double.  Use a union instead.
        * ldtoa.c (_ldtoa_r): Ditto.
        (_ldcheck): Ditto.
        (_strtold): Ditto.
        (union uconv): New union.
@
text
@d803 1
d823 4
a826 1
				cp = "Inf";
d831 4
a834 1
				cp = "NaN";
@


1.39
log
@
2005-03-21  Nicholas Wourms  <nwourms@@netscape.net>

        * libc/stdio/vfprintf.c: Move newlib.h before _WANT_IO_POS_ARGS test,
        since _WANT_IO_POS_ARGS is now defined in there.  Remove duplicate
        reent.h include.
@
text
@d1263 5
a1267 1
        struct ldieee *ldptr;
d1294 2
a1295 2
	ldptr = (struct ldieee *)&value;
	if (ldptr->sign) { /* this will check for < 0 and -0.0 */
@


1.38
log
@
2005-02-07  Antony King  <antony.king@@st.com>

        * libc/stdio/clearerr.c (clearerr): Ensure CHECK_INIT() is
        called before _flockfile to prevent lock object use before
        initialisation. _REENT_SMALL_CHECK_INIT() and CHECK_INIT()
        take a struct _reent * instead of a FILE *.
        * libc/stdio/fclose.c (_fclose_r): Ditto.
        * libc/stdio/feof.c (feof): Ditto.
        * libc/stdio/ferror.c (ferror): Ditto.
        * libc/stdio/fflush.c (fflush): Ditto.
        * libc/stdio/fgetc.c (fgetc): Ditto.
        * libc/stdio/fgets.c (fgets): Ditto.
        * libc/stdio/fileno.c (fileno): Ditto.
        * libc/stdio/fputc.c (fputc): Ditto.
        * libc/stdio/fputs.c (fputs): Ditto.
        * libc/stdio/fread.c (fread): Ditto.
        * libc/stdio/freopen.c (_freopen_r): Ditto.
        * libc/stdio/fseek.c (_fseek_r): Ditto.
        * libc/stdio/ftell.c (_ftell_r): Ditto.
        * libc/stdio/fwrite.c (fwrite): Ditto.
        * libc/stdio/getc.c (getc): Ditto.
        * libc/stdio/getdelim.c (__getdelim): Ditto.
        * libc/stdio/putc.c (putc): Ditto.
        * libc/stdio/setvbuf.c (setvbuf): Ditto.
        * libc/stdio/ungetc.c (_ungetc_r): Ditto.
        * libc/stdio/vfprintf.c (_VFPRINTF_R): Ditto.
        * libc/stdio64/freopen64.c (_freopen64_r): Ditto.
        * libc/stdio64/fseeko64.c (_fseeko64_r): Ditto.
        * libc/stdio64/ftello64.c (_ftello64_r): Ditto.
        * libc/stdio/local.h (CHECK_INIT): Argument is now a struct
        _reent * instead of a FILE * and so replace incorrect use of
        _REENT with argument.
        * libc/sys/arm/syscalls.c (CHECK_INIT): Ditto.
        * libc/stdio/getchar.c (getchar): _REENT_SMALL_CHECK_INIT() and
        CHECK_INIT() take a struct _reent * instead of a FILE *.
        * libc/stdio/iprintf.c (iprintf, _iprintf_r): Ditto.
        * libc/stdio/iscanf.c (iscanf, _iscanf_r): Ditto.
        * libc/stdio/perror.c (perror): Ditto.
        * libc/stdio/printf.c (printf, _printf_r): Ditto.
        * libc/stdio/putchar.c (putchar): Ditto.
        * libc/stdio/puts.c (puts): Ditto.
        * libc/stdio/refill.c (__srefill): Ditto.
        * libc/stdio/scanf.c (scanf, _scanf_r): Ditto.
        * libc/stdio/vfscanf.c (VFSCANF, _VFSCANF_R): Ditto.
        * libc/stdio/viprintf.c (viprintf, _viprintf_r): Ditto.
        * libc/stdio/viscanf.c (viscanf, _viscanf_r): Ditto.
        * libc/stdio/vprintf.c (vprintf, _vprintf_r): Ditto.
        * libc/stdio/vscanf.c (vscanf, _vscanf_r): Ditto.
        * libc/stdio/wbuf.c (__swbuf): Ditto.
        * libc/stdio/wsetup.c (__swsetup): Ditto.
        * libc/stdlib/mallocr.c (malloc_stats): Ditto.
        * libc/stdlib/mstats.c (_mstats_r): Ditto.
        * libc/include/sys/reent.h (_REENT_SMALL_CHECK_INIT): Ditto.
        * libc/machine/powerpc/vfscanf.c (vfscanf): Ditto.
        * libc/stdio/fgetpos.c (_fgetpos_r): Removed unnecessary calls
        to _flockfile and _funlockfile; rely on locking in _ftell_r.
        * libc/stdio64/fgetpos64.c (_fgetpos64_r): Ditto (_ftello64_r).
        * libc/machine/powerpc/vfprintf.c (__sbprintf): Removed unnecessary
        initialision of _data field in FILE structure.
        * libc/machine/powerpc/vfprintf.c (VFPRINTF): Added CHECK_INIT() call.
@
text
@d160 1
a179 2
#include <newlib.h>
#include <reent.h>
@


1.37
log
@
2004-06-11  Antony King  <antony.king@@st.com>

        * libc/include/sys/_types.h: Include <sys/lock.h> and change
        _flock_t to be of type _LOCK_RECURSIVE_T.
        * libc/include/sys/reent.h: (_REENT_INIT): Reformat.
        (_REENT_INIT_PTR): Ditto.  Use memset where appropriate.
        (_global_impure_ptr): New declaration.
        (_GLOBAL_REENT): Change to be _global_impure_ptr.
        * libc/include/sys/stdio.h: Include <sys/lock.h> and
        <sys/reent.h>.
        (_flockfile)[!_SINGLE_THREAD]: Add code for lock call.
        (_funlockfile)[!SINGLE_THREAD]: Ditto.
        * libc/reent/impure.c: Set _global_impure_ptr to _impure_ptr.
        * libc/stdio/fclose.c: Remove casting of fp lock to
        _LOCK_RECURSIVE_T.
        * libc/stdio/findfp.c: Ditto.
        * libc/stdio/fopen.c: Ditto.
        * libc/stdio/freopen.c: Ditto.
        * libc/stdio/vfprintf.c: Ditto.
        * libc/stdio64/fopen64.c: Ditto.
        * libc/stdlib/envlock.c: Add default stubs that use generic
        locking code.
        * libc/stdlib/mlock.c: Ditto.

        Jeff Johnston  <jjohnstn@@redhat.com>
        * libc/sys/linux/sys/_types.h (__flock_mutex_t): New subtype.
        (_flock_t): Change to be a struct containing a single member
        named mutex which is of type __flock_mutex_t.
@
text
@d536 1
a537 1
	CHECK_INIT (fp);
@


1.36
log
@
2004-05-27  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfprintf.c (_VFPRINTF): Move file locking
        from here ...
        (_VFPRINTF_R): ... to here so all I/O printf routines
        are covered.
@
text
@d258 1
a258 1
	__lock_init_recursive (*(_LOCK_RECURSIVE_T *)&fake._lock);
d269 1
a269 1
	__lock_close_recursive (*(_LOCK_RECURSIVE_T *)&fake._lock);
@


1.35
log
@
2004-05-25  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * newlib.hin: (_WANT_IO_POS_ARGS): New define.
        (_WANT_IO_LONG_LONG): Ditto.
        (_WANT_IO_LONG_DOUBLE): Ditto.
        * configure.in: Add new configuration options
        --enable-newlib-io-long-long and --enable-newlib-io-long-double
        which tie to new defines in newlib.hin.
        * configure: Regenerated.
        * configure.host: Add checks for new configuration options.  Also
        fix up check for --enable-newlib-io-pos-args so configuration
        option will override any default for a given platform.
        Remove defining compiler flags for the _WANT_IO* options.
        * libc/stdio/vfprintf.c: Change to use new newlib.hin defines
        instead of looking for old compiler flags.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/vfieeefp.h: Ditto.
        * libc/machine/powerpc/vfprintf.c: Ditto.
        * libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@a383 2
  _flockfile (fp);
  CHECK_INIT (fp);
a384 1
  _funlockfile (fp);
d536 3
d540 2
a541 1
	if (cantwrite (fp))
d543 1
d547 2
a548 1
	    fp->_file >= 0)
d550 1
d1218 1
@


1.34
log
@
2004-05-11  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * libc/stdio/vfprintf.c (VFPRINTF_R): Use _free_r instead
        of free.
@
text
@a171 5
#define _NO_LONGLONG
#if defined WANT_PRINTF_LONG_LONG && defined __GNUC__
# undef _NO_LONGLONG
#endif

d173 1
a173 1
#if defined WANT_IO_POS_ARGS
d178 1
d201 1
a201 1
#if defined WANT_IO_LONG_DBL && (LDBL_MANT_DIG > DBL_MANT_DIG)
d205 5
@


1.33
log
@
2004-05-07  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * libc/stdio/iprintf.c (_iprintf_r): Fix old-style argument
        list for reentrant pointer.  Call _vfiprintf_r.
        * libc/stdio/siprintf.c (_siprintf_r): New function.
        * libc/stdio/vfprintf.c (__sbprintf): Add reetrant struct
        pointer argument.  Change all callers.  Call _VFPRINTF_R.
        * libc/include/stdio.h (_siprintf_r, _vfiprintf_r): New
        prototypes.
@
text
@d1204 1
a1204 1
			free (malloc_buf);
d1212 1
a1212 1
		free (malloc_buf);
@


1.32
log
@
2004-05-03  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * libc/stdio/vfprintf.c (_VFPRINTF_R): Set error flag when
        multibyte functions return failure for %C, %S, %lc, and %ls
        format specifiers.
@
text
@d236 3
a238 2
_DEFUN(__sbprintf, (fp, fmt, ap),
       register FILE *fp _AND
d261 1
a261 1
	ret = VFPRINTF (&fake, fmt, ap);
d545 1
a545 1
		return (__sbprintf (fp, fmt0, ap));
@


1.31
log
@
2004-04-23  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * configure.in: Define _MB_CAPABLE if mb supported.
        * configure: Regenerated.
        * configure.host: Remove manual setting of MB_CAPABLE compiler
        flag.
        * newlib.hin: Add _MB_CAPABLE flag.
        * libc/ctype/iswalpha.c, libc/ctype/iswblank.c: Include <newlib.h>
        and check for _MB_CAPABLE flag instead of MB_CAPABLE.
        * libc/ctype/iswcntrl.c, libc/ctype/iswprint.c: Ditto.
        * libc/ctype/iswpunct.c, libc/ctype/iswspace.c: Ditto.
        * libc/ctype/jp2uc.c: Ditto.
        * libc/ctype/towlower.c, libc/ctype/towupper.c: Ditto.
        * libc/locale/locale.c: Ditto
        * libc/machine/powerpc/vfscanf.c: Ditto
        * libc/stdio/vfprintf.c, libc/stdio/vfscanf.c: Ditto
        * libc/stdlib/mblen.c: Ditto
        * libc/stdlib/mblen_r.c, libc/stdlib/mbrlen.c: Ditto
        * libc/stdlib/mbrtowc.c, libc/stdlib/mbsrtowcs.c: Ditto
        * libc/stdlib/mbstowcs.c, libc/stdlib/mbtowc.c: Ditto
        * libc/stdlib/mbtowc_r.c, libc/stdlib/wcrtomb.c: Ditto
        * libc/stdlib/wcsrtombs.c, libc/stdlib/wcstombs.c: Ditto
        * libc/stdlib/wctomb.c, libc/sys/linux/intl/dcigettext.c: Ditto
        * libc/sys/linux/intl/explodename.c: Ditto
        * libc/sys/linux/intl/finddomain.c: Ditto
        * libc/sys/linux/intl/l10nflist.c: Ditto
        * libc/sys/linux/intl/loadmsgcat.c: Ditto
        * libc/sys/linux/intl/localealias.c: Ditto
@
text
@d765 2
a766 1
					        &ps)) == -1)
d768 1
d947 2
a948 1
                                                     buf, wcp[m], &ps)) == -1)
d950 1
d961 4
a964 2
                                                   NULL, &wcp, 0, &ps)) == -1)
						goto error; 
d972 2
a973 1
				    (char *)_malloc_r (data, size + 1)) == NULL)
d975 1
d980 2
a981 1
                                                 &wcp, size, &ps) != size)
d983 1
@


1.30
log
@
2004-04-23  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * libc/stdio/asprintf.c libc/stdio/clearerr.c,
        libc/stdio/fclose.c libc/stdio/fcloseall.c libc/stdio/fdopen.c,
        libc/stdio/feof.c libc/stdio/ferror.c libc/stdio/fflush.c,
        libc/stdio/fgetc.c libc/stdio/fgetpos.c libc/stdio/fgets.c,
        libc/stdio/fileno.c libc/stdio/findfp.c libc/stdio/fiprintf.c,
        libc/stdio/flags.c libc/stdio/fopen.c libc/stdio/fprintf.c,
        libc/stdio/fputc.c libc/stdio/fputs.c libc/stdio/fread.c,
        libc/stdio/freopen.c libc/stdio/fscanf.c libc/stdio/fseek.c,
        libc/stdio/fseeko.c libc/stdio/fsetpos.c libc/stdio/ftell.c,
        libc/stdio/ftello.c libc/stdio/fvwrite.c libc/stdio/fwalk.c,
        libc/stdio/fwrite.c libc/stdio/getc.c libc/stdio/getc_u.c,
        libc/stdio/getchar.c libc/stdio/getchar_u.c,
        libc/stdio/getdelim.c libc/stdio/getline.c libc/stdio/gets.c,
        libc/stdio/getw.c libc/stdio/iprintf.c libc/stdio/local.h,
        libc/stdio/makebuf.c libc/stdio/mktemp.c libc/stdio/perror.c,
        libc/stdio/printf.c libc/stdio/putc.c libc/stdio/putc_u.c,
        libc/stdio/putchar.c libc/stdio/putchar_u.c libc/stdio/puts.c,
        libc/stdio/putw.c libc/stdio/refill.c libc/stdio/remove.c,
        libc/stdio/rename.c libc/stdio/rewind.c libc/stdio/rget.c,
        libc/stdio/scanf.c libc/stdio/setbuf.c libc/stdio/setbuffer.c,
        libc/stdio/setlinebuf.c libc/stdio/setvbuf.c,
        libc/stdio/siprintf.c libc/stdio/snprintf.c,
        libc/stdio/sprintf.c libc/stdio/sscanf.c libc/stdio/stdio.c,
        libc/stdio/tmpfile.c libc/stdio/tmpnam.c libc/stdio/ungetc.c,
        libc/stdio/vasprintf.c libc/stdio/vfieeefp.h,
        libc/stdio/vfprintf.c libc/stdio/vfscanf.c,
        libc/stdio/vprintf.c libc/stdio/vscanf.c,
        libc/stdio/vsnprintf.c libc/stdio/vsprintf.c,
        libc/stdio/vsscanf.c libc/stdio/wbuf.c,
        libc/stdio/wsetup.c: Perform minor formatting changes.  Move
        copyright notices to top of file, ensure that <_ansi.h> is
        included, be consistent with open parentheses, use _DEFUN macro,
        include "local.h" where needed, and remove various compiler
        warnings.
@
text
@d183 1
d444 1
a444 1
#ifdef MB_CAPABLE
d461 1
a461 1
#ifdef MB_CAPABLE
d564 1
a564 1
#ifdef MB_CAPABLE
d578 1
a578 1
#ifdef MB_CAPABLE
d1495 1
a1495 1
#ifdef MB_CAPABLE
d1505 1
a1505 1
#ifdef MB_CAPABLE
d1513 1
a1513 1
#ifdef MB_CAPABLE
@


1.29
log
@* libc/stdio/vfprintf.c: Add sys/lock.h include.
@
text
@d2 36
d59 1
a59 1
	int _vprintf_r(void *<[reent]>, const char *<[fmt]>,
d61 1
a61 1
	int _vfprintf_r(void *<[reent]>, FILE *<[fp]>, const char *<[fmt]>,
d63 1
a63 1
	int _vasprintf_r(void *<[reent]>, char **<[str]>, const char *<[fmt]>,
d65 1
a65 1
	int _vsprintf_r(void *<[reent]>, char *<[str]>, const char *<[fmt]>,
d67 1
a67 1
	int _vsnprintf_r(void *<[reent]>, char *<[str]>, size_t <[size]>, const char *<[fmt]>,
d99 1
a99 1
	char *<[reent]>;
d104 1
a104 1
	char *<[reent]>;
d110 1
a110 1
	char *<[reent]>;
d116 1
a116 1
	char *<[reent]>;
d122 1
a122 1
	char *<[reent]>;
a149 36
/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

d183 1
a187 1
#include <reent.h>
a190 1

a195 1

d213 3
a215 3
__sprint(fp, uio)
	FILE *fp;
	register struct __suio *uio;
d235 4
a238 4
__sbprintf(fp, fmt, ap)
	register FILE *fp;
	const char *fmt;
	va_list ap;
d252 1
a252 1
	fake._bf._size = fake._w = sizeof(buf);
d259 1
a259 1
	ret = VFPRINTF(&fake, fmt, ap);
d286 2
a287 1
static char *cvt _PARAMS((struct _reent *, double, int, int, char *, int *, int, int *));
d289 3
a291 2
static char *cvt _PARAMS((struct _reent *, _LONG_DOUBLE, int, int, char *, int *, int, int *));
extern int  _ldcheck _PARAMS((_LONG_DOUBLE *));
d294 1
a294 1
static int exponent _PARAMS((char *, int, int));
d311 1
a311 1
typedef void *   void_ptr_t;
d340 4
a343 3
static union arg_val *get_arg (struct _reent *data, int n, char *fmt, 
                               va_list *ap, int *numargs, union arg_val *args, 
			       int *arg_type, char **last_fmt);
d350 1
a350 1
#define is_digit(c)	((unsigned)to_digit(c) <= 9)
d372 1
a372 1
int _EXFUN (_VFPRINTF_R, (struct _reent *, FILE *, _CONST char *, va_list));
d375 4
a378 4
_DEFUN (VFPRINTF, (fp, fmt0, ap),
	FILE * fp _AND
	_CONST char *fmt0 _AND
	va_list ap)
d381 1
a381 1
  _flockfile(fp);
d384 1
a384 1
  _funlockfile(fp);
d389 5
a393 5
_DEFUN (_VFPRINTF_R, (data, fp, fmt0, ap),
	struct _reent *data _AND
	FILE * fp _AND
	_CONST char *fmt0 _AND
	va_list ap)
d480 1
a480 1
			PRINT(with, PADSIZE); \
d483 1
a483 1
		PRINT(with, n); \
d503 2
a504 2
           ? args[numargs++].val_##type = va_arg(ap, type) \
           : va_arg(ap, type) \
d507 1
a507 1
#define GET_ARG(n, ap, type) (va_arg(ap, type))
d516 4
a519 4
	(flags&QUADINT ? GET_ARG(N, ap, quad_t) : \
	    flags&LONGINT ? GET_ARG(N, ap, long) : \
	    flags&SHORTINT ? (long)(short)GET_ARG(N, ap, int) : \
	    (long)GET_ARG(N, ap, int))
d521 4
a524 4
	(flags&QUADINT ? GET_ARG(N, ap, u_quad_t) : \
	    flags&LONGINT ? GET_ARG(N, ap, u_long) : \
	    flags&SHORTINT ? (u_long)(u_short)GET_ARG(N, ap, int) : \
	    (u_long)GET_ARG(N, ap, u_int))
d527 3
a529 3
	(flags&LONGINT ? GET_ARG(N, ap, long) : \
	    flags&SHORTINT ? (long)(short)GET_ARG(N, ap, int) : \
	    (long)GET_ARG(N, ap, int))
d531 3
a533 3
	(flags&LONGINT ? GET_ARG(N, ap, u_long) : \
	    flags&SHORTINT ? (u_long)(u_short)GET_ARG(N, ap, int) : \
	    (u_long)GET_ARG(N, ap, u_int))
d537 1
a537 1
	if (cantwrite(fp))
d543 1
a543 1
		return (__sbprintf(fp, fmt0, ap));
d564 1
a564 1
	        while ((n = _mbtowc_r(data, &wc, fmt, MB_CUR_MAX, &state)) > 0) {
d574 1
a574 1
			PRINT(cp, m);
d617 1
a617 1
			if (is_digit(*fmt)) {
d623 1
a623 1
					n = 10 * n + to_digit(ch);
d625 1
a625 1
				} while (is_digit(ch));
d648 1
a648 1
			width = GET_ARG(n, ap, int);
d669 1
a669 1
				if (is_digit(*fmt)) {
d675 1
a675 1
						n = 10 * n + to_digit(ch);
d677 1
a677 1
					} while (is_digit(ch));
d693 1
a693 1
				prec = GET_ARG(n, ap, int);
d702 2
a703 2
			while (is_digit(ch)) {
				n = 10 * n + to_digit(ch);
d720 1
a720 1
				n = 10 * n + to_digit(ch);
d722 1
a722 1
			} while (is_digit(ch));
d761 3
a763 3
				memset((void *)&ps, '\0', sizeof(mbstate_t));
				if ((size = (int)_wcrtomb_r(data, cp, 
				    	       (wchar_t)GET_ARG(N, ap, wint_t), 
d768 1
a768 1
				*cp = GET_ARG(N, ap, int);
d778 1
a778 1
			_uquad = SARG();
d805 1
a805 1
				_fpvalue = (double) GET_ARG(N, ap, _LONG_DOUBLE);
d807 1
a807 1
				_fpvalue = GET_ARG(N, ap, double);
d811 1
a811 1
			if (isinf(_fpvalue)) {
d818 1
a818 1
			if (isnan(_fpvalue)) {
d827 1
a827 1
				_fpvalue = GET_ARG(N, ap, _LONG_DOUBLE);
d829 1
a829 1
				_fpvalue = (_LONG_DOUBLE)GET_ARG(N, ap, double);
d850 1
a850 1
			cp = cvt(data, _fpvalue, prec, flags, &softsign,
d861 1
a861 1
				expsize = exponent(expstr, expt, ch);
d889 1
a889 1
				*GET_ARG(N, ap, quad_ptr_t) = ret;
d893 1
a893 1
				*GET_ARG(N, ap, long_ptr_t) = ret;
d895 1
a895 1
				*GET_ARG(N, ap, short_ptr_t) = ret;
d897 1
a897 1
				*GET_ARG(N, ap, int_ptr_t) = ret;
d903 1
a903 1
			_uquad = UARG();
d915 1
a915 1
			_uquad = (u_long)(unsigned _POINTER_INT)GET_ARG(N, ap, void_ptr_t);
d924 1
a924 1
			if ((cp = GET_ARG(N, ap, char_ptr_t)) == NULL) {
d934 1
a934 1
				memset((void *)&ps, '\0', sizeof(mbstate_t));
d943 1
a943 1
						if ((n = (int)_wcrtomb_r(data, 
d955 1
a955 1
					if ((size = (int)_wcsrtombs_r(data, 
d965 1
a965 1
				    (char *)_malloc_r(data, size + 1)) == NULL)
d969 2
a970 2
				memset((void *)&ps, '\0', sizeof(mbstate_t));
				if (_wcsrtombs_r(data, malloc_buf, 
d980 1
a980 1
				 * strlen() will go further.
d982 1
a982 1
				char *p = memchr(cp, 0, prec);
d991 1
a991 1
				size = strlen(cp);
d998 1
a998 1
			_uquad = UARG();
d1006 1
a1006 1
hex:			_uquad = UARG();
d1037 1
a1037 1
						*--cp = to_char(_uquad & 7);
d1048 1
a1048 1
						*--cp = to_char(_uquad % 10);
d1051 1
a1051 1
					*--cp = to_char(_uquad);
d1063 1
a1063 1
					size = strlen(cp);
d1115 1
a1115 1
			PAD(width - realsz, blanks);
d1119 1
a1119 1
			PRINT(&sign, 1);
d1123 1
a1123 1
			PRINT(ox, 2);
d1128 1
a1128 1
			PAD(width - realsz, zeroes);
d1131 1
a1131 1
		PAD(dprec - size, zeroes);
d1136 1
a1136 1
			PRINT(cp, size);
d1141 1
a1141 1
					PRINT("0", 1);
d1143 2
a1144 2
						PRINT(decimal_point, 1);
						PAD(ndig - 1, zeroes);
d1147 1
a1147 1
					PRINT("0", 1);
d1149 3
a1151 3
						PRINT(decimal_point, 1);
						PAD(-expt, zeroes);
						PRINT(cp, ndig);
d1154 2
a1155 2
					PRINT(cp, ndig);
					PAD(expt - ndig, zeroes);
d1157 1
a1157 1
						PRINT(".", 1);
d1159 1
a1159 1
					PRINT(cp, expt);
d1161 2
a1162 2
					PRINT(".", 1);
					PRINT(cp, ndig-expt);
d1168 1
a1168 1
					PRINT(ox, 2);
d1170 1
a1170 1
						PRINT(cp, ndig-1);
d1173 1
a1173 1
						PAD(ndig - 1, zeroes);
d1175 2
a1176 2
					PRINT(cp, 1);
				PRINT(expstr, expsize);
d1180 1
a1180 1
		PRINT(cp, size);
d1184 1
a1184 1
			PAD(width - realsz, blanks);
d1189 1
a1189 1
		FLUSH();	/* copy out the I/O vectors */
d1192 1
a1192 1
			free(malloc_buf);
d1197 1
a1197 1
	FLUSH();
d1200 2
a1201 2
		free(malloc_buf);
	return (__sferror(fp) ? EOF : ret);
d1217 1
d1219 9
a1227 4
cvt(data, value, ndigits, flags, sign, decpt, ch, length)
	struct _reent *data;
#ifdef _NO_LONGDBL
	double value;
d1229 10
a1238 1
	_LONG_DOUBLE value;
a1239 2
	int ndigits, flags, *decpt, ch, *length;
	char *sign;
d1265 1
a1265 1
	if (word0(tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
d1271 1
a1271 1
	digits = _dtoa_r(data, value, mode, ndigits, decpt, &dsgn, &rve);
d1280 1
a1280 1
	digits = _ldtoa_r(data, value, mode, ndigits, decpt, &dsgn, &rve);
d1300 4
a1303 3
exponent(p0, exp, fmtch)
	char *p0;
	int exp, fmtch;
d1319 1
a1319 1
			*--t = to_char(exp % 10);
d1321 1
a1321 1
		*--t = to_char(exp);
d1326 1
a1326 1
		*p++ = to_char(exp);
d1407 1
a1407 1
const static CH_CLASS chclass[256] = {
d1442 1
a1442 1
const static STATE state_table[MAX_STATE][MAX_CH_CLASS] = {
d1457 1
a1457 1
const static ACTION action_table[MAX_STATE][MAX_CH_CLASS] = {
d1474 9
a1482 3
get_arg (struct _reent *data, int n, char *fmt, va_list *ap, 
         int *numargs_p, union arg_val *args, 
	 int *arg_type, char **last_fmt) 
d1513 1
a1513 1
      while ((nbytes = _mbtowc_r(data, &wc, fmt, MB_CUR_MAX, &wc_state)) > 0) 
d1634 1
a1634 1
			args[numargs++].val_long = va_arg(*ap, long);
d1637 1
a1637 1
			args[numargs++].val_quad_t = va_arg(*ap, quad_t);
d1640 1
a1640 1
			args[numargs++].val_wint_t = va_arg(*ap, wint_t);
d1645 1
a1645 1
			args[numargs++].val_int = va_arg(*ap, int);
d1648 1
a1648 1
			args[numargs++].val_char_ptr_t = va_arg(*ap, char *);
d1651 1
a1651 1
			args[numargs++].val_double = va_arg(*ap, double);
d1654 1
a1654 1
			args[numargs++].val__LONG_DOUBLE = va_arg(*ap, _LONG_DOUBLE);
d1662 1
a1662 1
		memset (arg_type, 0, sizeof(int) * MAX_POS_ARGS);
d1668 1
a1668 1
		memset (arg_type, 0, sizeof(int) * MAX_POS_ARGS);
d1677 1
a1677 1
	      args[numargs++].val_int = va_arg(*ap, int);
d1681 1
a1681 1
	      while ((ch = *fmt) != '\0' && is_digit(ch))
d1688 1
a1688 1
	      while ((ch = *fmt) != '\0' && is_digit(ch))
d1710 1
a1710 1
	  args[numargs++].val_long = va_arg(*ap, long);
d1713 1
a1713 1
	  args[numargs++].val_quad_t = va_arg(*ap, quad_t);
d1716 1
a1716 1
	  args[numargs++].val_char_ptr_t = va_arg(*ap, char *);
d1719 1
a1719 1
	  args[numargs++].val_double = va_arg(*ap, double);
d1722 1
a1722 1
	  args[numargs++].val__LONG_DOUBLE = va_arg(*ap, _LONG_DOUBLE);
d1725 1
a1725 1
	  args[numargs++].val_wint_t = va_arg(*ap, wint_t);
d1731 1
a1731 1
	  args[numargs++].val_int = va_arg(*ap, int);
@


1.28
log
@
2004-01-16  Thomas Pfaff  <tpfaff@@gmx.net>

        * libc/stdio/findfp.c (__sfp): Remove unnecessary memset.
        * libc/stdio/vfprintf.c (__sbprintf): Ditto.
        Add calls to __lock_init_recursive and __lock_close_recursive
        instead.
@
text
@d190 1
@


1.27
log
@
2004-01-15  Thomas Pfaff  <tpfaff@@gmx.net>

        * libc/stdio/fclose.c: Include sys/lock.h.
        (fclose): Destroy lock when file is closed.
        * libc/stdio/findfp.c (__sfp): Initialize file pointers _lock
        member.
        * libc/stdio/freopen.c: Include sys/lock.h.
        (_freopen_r): Destroy lock when file is closed.
        * libc/stdio/vfprintf.c (__sbprintf): Initialize file pointers
        _lock member.
@
text
@d256 1
a256 1
	memset (&fake._lock, 0, sizeof(fake._lock));
d265 4
@


1.26
log
@
2003-12-04  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * libc/stdio/vfprintf.c (_VFPRINTF_R): Use _r versions
        of mb routines for %lc and %ls support.
        * libc/stdio/vfscanf.c (_svfscanf_r): Add %lc, %C,
        %ls, and %S support.  Remove CYGNUS_NEC markers and
        code within.
@
text
@d255 3
@


1.25
log
@
2003-11-24  Artem B. Bityuckiy  <mail_lists@@mail.ru>

        * libc/stdio/vfprintf.c (_VFPRINTF_R): Fix check for 'C' format
        specifier to use ch instead of *fmt.
@
text
@d753 1
a753 1
				if ((size = (int)wcrtomb(cp, 
d934 2
a935 2
						if ((n = (int)wcrtomb(buf, 
							wcp[m], &ps)) == -1)
d946 2
a947 2
					if ((size = (int)wcsrtombs(NULL, &wcp, 
								0, &ps)) == -1)
d956 1
a956 1
				    (char *)malloc(size + 1)) == NULL)
d961 2
a962 2
				if (wcsrtombs(malloc_buf, &wcp, size, &ps) 
				    != size)
@


1.24
log
@
2003-11-21  Artem B. Bityuckiy  <mail_lists@@mail.ru>

        * libc/stdio/vfprintf.c (_VFPRINTF_R, get_arg): Move mb-specific
        code within checks for MB_CAPABLE.  For non-mb-capable platforms,
        use simple byte logic.
@
text
@d749 1
a749 1
			if (*fmt == 'C' || (flags & LONGINT)) {
@


1.23
log
@
2003-11-19  Nicholas Wourms  <nwourms@@netscape.net>

        * configure.host: Enable positional arguments for printf
        family for Cygwin.
        * libc/stdio/vfprintf.c (_VFPRINTF_R): Remove extraneous
        pointer reference for quad_ptr_t.
@
text
@a406 1
	wchar_t wc;
a422 2


a423 1

d434 2
d437 1
d451 1
d453 1
d554 1
d556 3
a558 5
			fmt += n;
			if (wc == '%') {
				fmt--;
				break;
			}
d560 4
d568 1
d570 5
a574 2
			goto done;

d1456 1
a1456 2
  wchar_t wc;
  int nbytes, number, flags;
a1462 1
  mbstate_t wc_state;
d1465 6
a1470 1
  
d1475 1
d1477 1
d1483 1
d1490 1
a1490 1
      
d1493 3
d1497 3
@


1.22
log
@
2003-11-07  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfprintf.c (_VFPRINTF_R): Fix typos that should be
        referring to _NO_LONGLONG macro.
@
text
@d872 1
a872 1
				*GET_ARG(N, ap, quad_ptr_t *) = ret;
@


1.21
log
@
2003-11-05  Jeff Johnston  <jjohnstn@@redhat.com>
            Artem B. Bityuckiy  <mail_lists@@mail.ru>

        * libc/stdio/vfprintf.c (_VFPRINTF_R): Add support for
        %ls, %S, %lc, and %C format specifiers.
        (get_arg): Ditto.
        * libc/stdio/sprintf.c: Add documentation regarding new
        format specifiers added in vfprintf.c.
@
text
@d294 1
a294 1
#ifndef _NO_LONG_LONG
d1539 1
a1539 1
#ifndef _NO_LONG_LONG
@


1.20
log
@
2003-08-22  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/include/sys/reent.h: Add _GLOBAL_REENT macro.
	* libc/stdio: Globally remove/replace all references to fp->_data.
	Replace with _REENT or _GLOBAL_REENT where appropriate.
	* libc/stdio/asprintf.c: Ditto.
	* libc/stdio/fclose.c: Ditto.
	* libc/stdio/fvwrite.c: Ditto.
	* libc/stdio/makebuf.c: Ditto.
	* libc/stdio/refill.c: Ditto.
	* libc/stdio/local.h: Ditto.
	* libc/stdio/setvbuf.c: Ditto.
	* libc/stdio/sscanf.c: Ditto.
	* libc/stdio/stdio.c: Ditto.
	* libc/stdio/ungetc.c: Ditto.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdio/vsscanf.c: Ditto.
	* libc/stdio/fopen.c: Ditto.  Also use _fseek_r in _fopen_r.
	* libc/stdio/vasprintf.c: Ditto.  Also call _vfprintf_r directly.
	* libc/stdio/vsnprintf.c: Ditto.
	* libc/stdio/vsprintf.c: Ditto.
	* libc/stdio/fcloseall.c(fcloseall): Use _GLOBAL_REENT macro
	instead of _REENT to walk file list.
	* libc/stdio/fflush.c: Ditto.
	* libc/stdio/fgetpos.c: Add reentrant version and have regular
	version call reentrant version with _REENT argument.
	* libc/stdio/fsetpos.c: Ditto.
	* libc/stdio/fseek.c: Ditto.
	* libc/stdio/fseeko.c: Ditto.
	* libc/stdio/ftell.c: Ditto.
	* libc/stdio/ftello.c: Ditto.
	* libc/stdio/freopen.c: Ditto.
	* libc/stdio/findfp.c: Use _GLOBAL_REENT pointer when adding
	new files to chain.  Also use _GLOBAL_REENT pointer for
	cleaning up.
	* libc/stdio/fiprintf.c: Reformatted to minimize duplicate code.
	* libc/stdio/siprintf.c: Ditto.
	* libc/stdio/iprintf.c: Ditto.
	* libc/stdio/fprintf.c: Ditto.
	* libc/stdio/printf.c: Ditto.
	* libc/stdio/snprintf.c: Call _vfprintf_r directly.
	* libc/stdio/sprintf.c: Ditto.
	* libc/stdio/vprintf.c: Ditto.  Also add _REENT_ONLY check.
	* libc/stdio/rewind.c: Call _fseek_r directly.
	* libc/stdio/tmpfile.c: Call _fopen_r and _remove_r directly.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Change _r routines to use
	data pointer.
	(get_arg): Add extra struct _reent pointer argument.
	* libc/stdio64/fgetpos64.c: Add _r versions, remove any reference
	to fp->_data.
	* libc/stdio64/fopen64.c: Ditto.
	* libc/stdio64/freopen64.c: Ditto.
	* libc/stdio64/fsetpos64.c: Ditto.
	* libc/stdio64/ftello64.c: Ditto.
	* libc/stdio64/local64.h: Ditto.
	* libc/stdio64/stdio64.c: Ditto.
	* libc/stdio64/fseeko64.c: Ditto plus use _fstat_r instead of
	_fstat64_r for the meantime.
@
text
@d186 1
d271 6
a276 1
#define	BUF		(MAXEXP+MAXFRACT+1)	/* + decimal point */
d329 1
d438 2
a439 1
        mbstate_t state;          /* mbtowc calls from library must not change state */
d739 15
a753 2
			*(cp = buf) = GET_ARG(N, ap, int);
			size = 1;
d905 3
a907 1
			if ((cp = GET_ARG(N, ap, char_ptr_t)) == NULL)
d909 51
a959 1
			if (prec >= 0) {
d975 1
a975 1
			sign = '\0';
d1173 5
d1182 2
d1385 1
a1385 1
  /* 40-47 */  OTHER,   OTHER,   OTHER,   OTHER,   SPEC,    SPEC,    OTHER,   SPEC, 
d1387 1
a1387 1
  /* 50-57 */  OTHER,   OTHER,   OTHER,   OTHER,   OTHER,   SPEC,    OTHER,   SPEC, 
d1458 1
a1458 1
  enum types { INT, LONG_INT, SHORT_INT, QUAD_INT, CHAR, CHAR_PTR, DOUBLE, LONG_DOUBLE };
d1564 1
d1571 3
d1590 3
d1674 3
@


1.19
log
@
2003-07-29  Honda Hiroki  <hhonda@@ipflex.com>

        * libc/stdio/vfprintf.c: Set output size to 1 when
        we have %f format with precision 0 and # flag not specified.
@
text
@a244 1
	fake._data = fp->_data;
d325 2
a326 1
static union arg_val *get_arg (int n, char *fmt, va_list *ap, int *numargs, union arg_val *args, 
d367 1
a367 1
  result = _VFPRINTF_R (fp->_data, fp, fmt0, ap);
d481 1
a481 1
         : get_arg (n, fmt_anchor, &ap, &numargs, args, arg_type, &saved_fmt)->val_##type \
d545 1
a545 1
	        while ((n = _mbtowc_r(_REENT, &wc, fmt, MB_CUR_MAX, &state)) > 0) {
d1363 3
a1365 2
get_arg (int n, char *fmt, va_list *ap, int *numargs_p, union arg_val *args, 
	int *arg_type, char **last_fmt) 
d1390 1
a1390 1
      while ((nbytes = _mbtowc_r(_REENT, &wc, fmt, MB_CUR_MAX, &wc_state)) > 0) 
@


1.18
log
@
2003-01-07  Charles Wilson  <cwilson@@ece.gatech.edu>

        * libc/stdio/sprintf.c: fix typo
        * libc/stdio/vfprintf.c: fix typo
@
text
@d833 3
a835 1
					size = prec + 2;
@


1.17
log
@	* libc/include/langinfo.h: New file.
	* libc/include/wchar.h: Likewise.
	* libc/include/sys/syslimits.h: Likewise.
	* libc/locale/fix_grouping.c: Likewise.
	* libc/locale/ldpart.c: Likewise.
	* libc/locale/ldpart.h: Likewise.
	* libc/locale/lmessages.c: Likewise.
	* libc/locale/lmessages.h: Likewise.
	* libc/locale/lmonetary.c: Likewise.
	* libc/locale/lmonetary.h: Likewise.
	* libc/locale/lnumeric.c: Likewise.
	* libc/locale/lnumeric.h: Likewise.
	* libc/locale/nl_langinfo.3: Likewise.
	* libc/locale/nl_langinfo.c: Likewise.
	* libc/locale/timelocal.c: Likewise.
	* libc/locale/timelocal.h: Likewise.
	* libc/stdlib/btowc.c: Likewise.
	* libc/stdlib/mbrlen.c: Likewise.
	* libc/stdlib/mbrtowc.c: Likewise.
	* libc/stdlib/mbsinit.c: Likewise.
	* libc/stdlib/mbsrtowcs.c: Likewise.
	* libc/stdlib/wcrtomb.c: Likewise.
	* libc/stdlib/wcsrtombs.c: Likewise.
	* libc/stdlib/wctob.c: Likewise.
	* libc/sys/linux/prof-freq.c: Likewise.
	* libc/sys/linux/profile.c: Likewise.
	* libc/sys/linux/machine/i386/dl-procinfo.c: Likewise.
	* libc/sys/linux/machine/i386/dl-procinfo.h: Likewise.
	* libc/include/stdlib.h: Change re-entrant functions to take
	mbstate_t pointers.
	* libc/include/sys/_types.h: Define _mbstate_t.
	* libc/include/sys/config.h (MB_LEN_MAX): New macro.
	* libc/include/sys/errno.h (EILSEQ): New error code.
	* libc/include/sys/reent.h: Include wchar.h.  Change reentrant
	structure to use mbstate_t.
	* libc/locale/Makefile.am (LIB_SOURCES): Add new files.
	* libc/machine/powerpc/vfprintf.c: Use mbstate_t.
	* libc/machine/powerpc/vfscanf.c: Likewise.
	* libc/stdio/getdelim.c: Reallocate buffer only when necessary.
	* libc/stdio/vfprintf.c: Likewise.
	* libc/stdio/vfscanf.c: Likewise.
	* libc/stdlib/Makefile.am (LIB_SOURCES): Add new files.
	* libc/stdlib/mblen.c: Use mbstate_t.
	* libc/stdlib/mblen_r.c: Likewise.
	* libc/stdlib/mbstowcs.c: Likewise.
	* libc/stdlib/mbstowcs_r.c: Likewise.
	* libc/stdlib/mbtowc.c: Likewise.
	* libc/stdlib/mbtowc_r.c: Likewise.
	* libc/stdlib/wcstombs.c: Likewise.
	* libc/stdlib/wcstombs_r.c: Likewise.
	* libc/stdlib/wctomb_r.c: Likewise.
	* libc/sys/linux/Makefile.am (LIB_SOURCES): Add prof-freq.c and
	profile.c.
	* libc/sys/linux/machine/i386/Makefile.am (LIB_SOURCES): Add
	dl-procinfo.c.
	* libc/sys/linux/sys/errno.h (EILSEQ): New error code.
	* libc/sys/linux/sys/types.h (off_t): Define type.
	* testsuite/newlib.locale/UTF-8.c: Change locale name from UTF-8
	to C-UTF-8.
	* testsuite/newlib.locale/UTF-8.exp: Likewise.
@
text
@d94 1
a94 1
(respectively) variants of <<printf>>, <<fprintf>>, <<saprintf>>, <<sprintf>>,
@


1.16
log
@
2002-08-09  Jeff Johnston  <jjohnstn@@redhat.com>

        * configure.host: Add check for --enable-newlib-io-pos-args
        and define WANT_IO_POS_ARGS flag if enabled.  Define
        the flag by default for x86-linux configurations.
        * configure.in: Add support for --enable-newlib-io-pos-args.
        * libc/configure.in: Ditto.
        * configure: Regenerated.
        * libc/configure: Ditto.
        * libc/stdio/Makefile.am: Specify -fshort-enums for compiling
        vfprintf.c and vfiprintf.c.
        * libc/stdio/Makefile.in: Regenerated.
        * libc/stdio/vfprintf.c: Add positional argument support that
        is enabled by compiling with -DWANT_IO_POS_ARGS.
@
text
@d152 1
a152 1
static char *rcsid = "$Id: vfprintf.c,v 1.41 2002/07/04 18:36:19 jjohnstn Exp $";
d187 2
d431 1
a431 1
        int state = 0;          /* mbtowc calls from library must not change state */
d444 1
d1373 1
a1373 1
  int wc_state = 0;
d1380 2
@


1.15
log
@
2002-07-04  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/Makefile.am: Add asprintf.c and vasprintf.c.
        * libc/stdio/Makefile.in: Regenerated.
        * libc/stdio/asprintf.c: New file.
        * libc/stdio/vasprintf.c: Ditto.
        * libc/stdio/fvwrite.c: Add code to dynamically reallocate
        the buffer for asprintf support.
        * libc/stdio/sprintf.c: Add asprintf documentation.
        * libc/stdio/vfprintf.c: Add vasprintf documentation.
        * libc/include/stdio.h: Add new prototypes.
@
text
@d114 1
a114 1
/*-
d177 5
d287 40
d354 2
d383 11
a415 4
#ifndef _NO_LONGLONG
#define	quad_t	  long long
#define	u_quad_t  unsigned long long
#endif
a416 1
#ifndef _NO_LONGLONG
d418 1
a418 3
#else
	u_long _uquad;
#endif
d472 17
d495 4
a498 4
	(flags&QUADINT ? va_arg(ap, quad_t) : \
	    flags&LONGINT ? va_arg(ap, long) : \
	    flags&SHORTINT ? (long)(short)va_arg(ap, int) : \
	    (long)va_arg(ap, int))
d500 4
a503 4
	(flags&QUADINT ? va_arg(ap, u_quad_t) : \
	    flags&LONGINT ? va_arg(ap, u_long) : \
	    flags&SHORTINT ? (u_long)(u_short)va_arg(ap, int) : \
	    (u_long)va_arg(ap, u_int))
d506 3
a508 3
	(flags&LONGINT ? va_arg(ap, long) : \
	    flags&SHORTINT ? (long)(short)va_arg(ap, int) : \
	    (long)va_arg(ap, int))
d510 3
a512 3
	(flags&LONGINT ? va_arg(ap, u_long) : \
	    flags&SHORTINT ? (u_long)(u_short)va_arg(ap, int) : \
	    (u_long)va_arg(ap, u_int))
d529 7
d555 2
d564 4
d584 30
d620 5
a624 1
			if ((width = va_arg(ap, int)) >= 0)
d636 35
a670 2
				n = va_arg(ap, int);
				prec = n < 0 ? -1 : n;
d695 11
d728 1
a728 1
			*(cp = buf) = va_arg(ap, int);
d764 1
a764 1
				_fpvalue = (double) va_arg(ap, _LONG_DOUBLE);
d766 1
a766 1
				_fpvalue = va_arg(ap, double);
d786 1
a786 1
				_fpvalue = va_arg(ap, _LONG_DOUBLE);
d788 1
a788 1
				_fpvalue = (_LONG_DOUBLE)va_arg(ap, double);
d846 1
a846 1
				*va_arg(ap, quad_t *) = ret;
d850 1
a850 1
				*va_arg(ap, long *) = ret;
d852 1
a852 1
				*va_arg(ap, short *) = ret;
d854 1
a854 1
				*va_arg(ap, int *) = ret;
d872 1
a872 1
			_uquad = (u_long)(unsigned _POINTER_INT)va_arg(ap, void *);
d879 1
a879 1
			if ((cp = va_arg(ap, char *)) == NULL)
d1215 381
@


1.14
log
@	* Makefile.am (LIB_OBJECTLISTS): Add
	libc/search/objectlist.awk.in.
	* libc/Makefile.am (SUBDIRS): Add search.
	(SUBLIBS): Add search/libsearch.la.
	* libc/configure.in (AC_OUTPUT): Add search/Makefile.
	* libc/search: New directory.
	* libc/search/Makefile.am: New file.
	* libc/search/extern.h: New file.
	* libc/search/hash.c: New file.
	* libc/search/hash.h: New file.
	* libc/search/hash_bigkey.c: New file.
	* libc/search/hash_buf.c: New file.
	* libc/search/hash_func.c: New file.
	* libc/search/hash_log2.c: New file.
	* libc/search/hash_page.c: New file.
	* libc/search/hcreate.3: New file.
	* libc/search/hcreate.c: New file.
	* libc/search/hcreate.c~: New file.
	* libc/search/hcreate_r.c: New file.
	* libc/search/ndbm.c: New file.
	* libc/search/page.h: New file.
	* libc/search/tdelete.c: New file.
	* libc/search/tdestroy.c: New file.
	* libc/search/tfind.c: New file.
	* libc/search/tsearch.3: New file.
	* libc/search/tsearch.c: New file.
	* libc/search/twalk.c: New file.
	* libc/include/db.h: New file.
	* libc/include/ndbm.h: New file.
	* libc/include/search.h: New file.
	* libc/include/sys/queue.h: New file.
	* libc/include/sys/cdefs.h: New file.
	* libc/include/sys/param.h
	[__IEEE_LITTLE_ENDIAN,__IEEE_BIG_ENDIAN]: Set BYTE_ORDER to
	LITTLE_ENDIAN or BIG_ENDIAN.
	* libc/include/sys/errno.h (EFTYPE): New macro.
	* libc/search/bsearch.c: Move from libc/stdlib.
	* libc/search/qsort.c: Likewise.
	* libc/stdlib/Makefile.am (LIB_SOURCES): Remove bsearch.c and
	qsort.c.
	(CHEWOUT_FILES): Remove bsearch.def and qsort.def.
	* libc/stdlib/stdlib.tex: Remove references to bsearch and qsort.
@
text
@d20 1
d27 2
d46 5
d73 6
d93 5
a97 5
<<vprintf>>, <<vfprintf>>, <<vsprintf>> and <<vsnprintf>> are (respectively)
variants of <<printf>>, <<fprintf>>, <<sprintf>> and <<snprintf>>.  They differ
only in allowing their caller to pass the variable argument list as a
<<va_list>> object (initialized by <<va_start>>) rather than directly
accepting a variable number of arguments.
d101 1
a101 1
<<vsprintf>> returns the number of bytes in the output string,
d104 2
a105 2
If an error occurs, <<vprintf>> and <<vfprintf>> return <<EOF>>. No
error returns occur for <<vsprintf>>.
d152 1
a152 1
static char *rcsid = "$Id: vfprintf.c,v 1.40 2002/05/08 01:25:55 fitzsim Exp $";
@


1.13
log
@	* libc/include/sys/stdio.h: New file.
	* libc/sys/linux/sys/stdio.h: New file.
	* libc/include/stdio.h: Add declarations for flockfile,
	ftrylockfile, and funlockfile.  Include <sys/stdio.h>.
	* libc/stdio/clearerr.c: Add file locking.
	* libc/stdio/fclose.c: Likewise.
	* libc/stdio/feof.c: Likewise.
	* libc/stdio/ferror.c: Likewise.
	* libc/stdio/fflush.c: Likewise.
	* libc/stdio/fgetc.c: Likewise.
	* libc/stdio/fgetpos.c: Likewise.
	* libc/stdio/fgets.c: Likewise.
	* libc/stdio/fileno.c: Likewise.
	* libc/stdio/fputc.c: Likewise.
	* libc/stdio/fputs.c: Likewise.
	* libc/stdio/fread.c: Likewise.
	* libc/stdio/freopen.c: Likewise.
	* libc/stdio/fseek.c: Likewise.
	* libc/stdio/ftell.c: Likewise.
	* libc/stdio/fwrite.c: Likewise.
	* libc/stdio/getc.c: Likewise.
	* libc/stdio/putc.c: Likewise.
	* libc/stdio/setvbuf.c: Likewise.
	* libc/stdio/ungetc.c: Likewise.
	* libc/stdio/vfprintf.c: Likewise.
@
text
@d138 1
a138 1
static char *rcsid = "$Id: vfprintf.c,v 1.34 2000/12/08 00:28:25 jjohnstn Exp $";
@


1.12
log
@
2002-02-27  Jeff Johnston  <jjohnstn@@redhat.com>

        * configure.host: Add check for --disable-newlib-io-float
        configuration option and add -DNO_FLOATING_POINT to newlib cflags
        if appropriate.
        * acinclude.m4: Added --disable-newlib-io-float option.
        * aclocal.m4: Regenerated.
        * configure: Ditto.
        * doc/aclocal.m4 doc/configure libc/aclocal.m4 libc/configure
        * libc/*/aclocal.m4 libc/*/configure
        * libm/*/aclocal.m4 libm/*/configure: Ditto.
        * libc/stdio/vfprintf.c [!INTEGER_ONLY]: Only set FLOATING_POINT
        if NO_FLOATING_POINT flag is not defined.
@
text
@d301 2
d304 3
a306 1
  return _VFPRINTF_R (fp->_data, fp, fmt0, ap);
@


1.11
log
@Handle printf ("%#.0o",0);
@
text
@d153 1
d155 1
@


1.10
log
@* libc/stdio/vfprintf.c (QUADINT) [_NO_LONGLONG]: Make it
equivalent to LONGINT.
@
text
@d793 12
@


1.9
log
@
2001-01-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfprintf.c (_VFPRINTF_R): Modification to fix
        that suppressed . for %.0f, 0.1.  Check now looks if there
        are padding zeroes (expt) in addition to any digits (ndig) to
        print.
@
text
@d282 1
d284 5
@


1.8
log
@
2000-12-13  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/ldtoa.c (_ldcheck): New routine
        that categorizes a long double as NaN, Infinity, or other.
        * libc/stdio/vfprintf.c [WANT_IO_LONG_DBL](_VFPRINTF_R): Removed
        isinfl and isnanl static routines which were i386-specific.  Changed
        calls to the two removed routines to a single _ldcheck call.
        * libc/stdio/vfieeefp.h (ldieee): Fixed missing semi-colons.
@
text
@d856 1
a856 1
					if(ndig) {
@


1.7
log
@
2000-12-07  Jay Kulpinski <jskulpin@@eng01.gdds.com>

        * libc/stdio/vfprintf.c: Minor modification to avoid requiring
        a floating point register unless really printing a floating
        point number.
@
text
@d138 1
a138 1
static char *rcsid = "$Id: vfprintf.c,v 1.28 1999/07/05 18:51:05 cgf Exp $";
d255 1
a255 2
static int isinfl _PARAMS((_LONG_DOUBLE *));
static int isnanl _PARAMS((_LONG_DOUBLE *));
d324 1
d607 2
a608 1
			if (isinfl(&_fpvalue)) {
d615 1
a615 1
			if (isnanl(&_fpvalue)) {
a915 26

static int
isinfl (value)
     _LONG_DOUBLE *value;
{
  struct ldieee *ldptr;

  ldptr = (struct ldieee *)value;

  if (ldptr->exp == 0x7fff && !(ldptr->manh & 0x7fffffff) && !ldptr->manl)
    return 1;
  return 0;
}

static int
isnanl (value)
     _LONG_DOUBLE *value;
{
  struct ldieee *ldptr;

  ldptr = (struct ldieee *)value;

  if (ldptr->exp == 0x7fff && ((ldptr->manh & 0x7fffffff) || ldptr->manl))
    return 1;
  return 0;
}
@


1.6
log
@
2000-12-06  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdlib/Makefile.am: Added ldtoa.c to list of sources.
        * libc/stdlib/Makefile.in: Regenerated.
        * libc/stdio/floatio.h: Added suitable MAXEXP for long double.
        * libc/stdio/vfieeefp.h: Added long double bit structures.
        * libc/stdio/vfprintf.c[WANT_IO_LONG_DBL]: Added long double support.
        [WANT_IO_LONG_DBL](isinfl, isnanl): New static long double routines.
        (exponent): Changed expbuf to reasonable maximum instead of MAXEXP.
        * libc/stdio/vfscanf.c[WANT_IO_LONG_DBL]: Added long double support.
        * libc/stdlib/ldtoa.c: New file containing _ldtoa_r and
        _strtold routines used for conversions between character
        and long double.
@
text
@d320 2
a321 1
	double _fpvalue;	/* floating point arguments %[eEfgG] */
d323 2
a324 1
	_LONG_DOUBLE _fpvalue;  /* floating point arguments %[eEfgG] */
@


1.5
log
@
2000-08-16  Eric Fifer  <efifer@@sanwaint.com>

        * libc/stdio/vfprintf.c (_vfprintf_r): suppress . with "%.0f", 0.1
@
text
@d177 8
d251 1
d253 6
d281 1
a281 1
#define	LONGDBL		0x008		/* long double; unimplemented */
d319 5
a323 1
	double _double;		/* double precision arguments %[eEfgG] */
d325 1
a325 1
	int expsize;		/* character count for expstr */
d344 1
a344 1
	char *xdigs;		/* digits for [xX] conversion */
d575 23
d599 1
a599 1
				_double = (double) va_arg(ap, long double);
d601 1
a601 1
				_double = va_arg(ap, double);
d605 2
a606 2
			if (isinf(_double)) {
				if (_double < 0)
d612 1
a612 1
			if (isnan(_double)) {
d617 1
d620 2
a621 1
			cp = cvt(data, _double, prec, flags, &softsign,
d623 1
d844 1
a844 1
				if (_double == 0) {
d874 1
a874 1
                                       if (_double) {
d905 1
d908 32
d944 1
d946 3
d954 1
d956 3
d973 1
d975 1
d981 1
d983 11
d1016 1
a1016 1
	char expbuf[MAXEXP];
d1026 1
a1026 1
	t = expbuf + MAXEXP;
d1032 1
a1032 1
		for (; t < expbuf + MAXEXP; *p++ = *t++);
@


1.4
log
@* libc/stdio/vfprintf.c: pad 0.0 correctly with %e
@
text
@d808 5
a812 3
					PRINT(decimal_point, 1);
					PAD(-expt, zeroes);
					PRINT(cp, ndig);
@


1.3
log
@
Mon Apr 17 12:46:00 2000  Marek Michalkiewicz <marekm@@linux.org.pl>

        * libc/signal/signal.c (_signal_r) : Removed unused local variable temp.        * libc/stdio/findfp.c (std): Added declaration of flags and file.
        * libc/stdio/mktemp.c (_gettemp, _mkstemp_r, mkstemp): Added int
        return type.
        * libc/stdio/putchar.c (putchar): Added return statement.
        * libc/stdio/refill.c (lflush): Added correct parentheses.
        * libc/stdio/vfprintf.c (_VFPRINTF_R): Ditto.
        * libc/stdio/vfscanf.c (__svfscanf): Changed sprintf call which
        prints long value to use l qualifier.
        * libc/stdlib/dtoa.c (_dtoa_r): Added parentheses to remove warning
        messages and initialized local values: ilim, ilim1, and spec_case.
        * libc/stdlib/ecvtbuf.c (print_e): Removed unused variable dp.
        * libc/stdlib/mbctype.h (_issjis1, _issjis2): Added parentheses.
        * libc/stdlib/mprec.c: Ditto.
        * libc/stdlib/setenv_r.c: Ditto.
        * libc/stdlib/strtod.c: Ditto.
        * libc/stdlib/strtol.c: Ditto.
        * libc/stdlib/strtoul.c: Ditto.
        * libm/common/sf_expm1.c: Added curly braces to if else clauses.
        * libm/common/sf_log1p.c: Ditto.
        * libm/common/sf_scalbn.c: Ditto.
        * libm/math/ef_log.c: Ditto.
@
text
@d827 1
a827 1
                                       if (_double || (flags & ALT) == 0) {
@


1.2
log
@
Mon Feb 21 11:43:50 2000  Jeff Johnston <jjohnstn@@cygnus.com>

        * libc/stdio/vfprintf.c (VFPRINTF): Added CHECK_INIT
        call prior to calling _VFPRINTF_R so reentrant data area is set.
        (_VFPRINTF_R): Removed now extraneous CHECK_INIT call.
@
text
@d827 1
a827 1
					if (_double || flags & ALT == 0) {
@


1.1
log
@Initial revision
@
text
@d279 1
a398 2

	CHECK_INIT (fp);
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
