head	1.17;
access;
symbols
	cygwin-1_7_35-release:1.17
	cygwin-1_7_34-release:1.17
	newlib-2_2_0:1.17.0.2
	cygwin-1_7_33-release:1.17
	cygwin-1_7_32-release:1.17
	cygwin-1_7_31-release:1.17
	cygwin-1_7_30-release:1.16
	cygwin-1_7_29-release:1.16
	cygwin-1_7_28-release:1.16
	newlib-2_1_0:1.16
	cygwin-1_7_27-release:1.16
	cygwin-1_7_26-release:1.16
	cygwin-1_7_25-release:1.15
	cygwin-1_7_24-release:1.15
	cygwin-1_7_23-release:1.15
	cygwin-1_7_22-release:1.15
	cygwin-1_7_21-release:1.15
	cygwin-1_7_20-release:1.15
	cygwin-1_7_19-release:1.15
	cygwin-64bit-postmerge:1.15
	cygwin-64bit-premerge-branch:1.15.0.4
	cygwin-64bit-premerge:1.15
	cygwin-1_7_18-release:1.15
	newlib-2_0_0:1.15
	cygwin-1_7_17-release:1.15
	cygwin-64bit-branch:1.15.0.2
	cygwin-1_7_16-release:1.15
	cygwin-1_7_15-release:1.15
	cygwin-1_7_14_2-release:1.15
	cygwin-1_7_14-release:1.15
	cygwin-1_7_12-release:1.15
	cygwin-1_7_11-release:1.15
	cygwin-1_7_10-release:1.15
	newlib-1_20_0:1.14
	cygwin-1_7_9-release:1.14
	cygwin-1_7_8-release:1.14
	newlib-1_19_0:1.14
	cygwin-1_7_7-release:1.14
	cygwin-1_7_5-release:1.14
	cygwin-1_7_4-release:1.14
	cygwin-1_7_3-release:1.14
	cygwin-1_7_2-release:1.14
	newlib-1_18_0:1.14
	cygwin-1_7_1-release:1.14
	newlib-1_17_0-arc:1.13.0.2
	binutils-arc-20080908-branch:1.12.0.2
	binutils-arc-20080908-branchpoint:1.12
	newlib-1_17_0:1.13
	newlib-1_16_0:1.11
	newlib-1_15_0:1.9
	newlib-csl-coldfire-4_1-32:1.9
	newlib-csl-sourcerygxx-4_1-32:1.9
	newlib-csl-innovasic-fido-3_4_4-33:1.9
	newlib-csl-coldfire-4_1-30:1.9
	newlib-csl-sourcerygxx-4_1-30:1.9
	newlib-csl-coldfire-4_1-28:1.9
	newlib-csl-sourcerygxx-4_1-28:1.9
	newlib-csl-arm-2006q3-27:1.9
	newlib-csl-sourcerygxx-4_1-27:1.9
	newlib-csl-arm-2006q3-26:1.9
	newlib-csl-sourcerygxx-4_1-26:1.9
	newlib-csl-sourcerygxx-4_1-24:1.9
	newlib-csl-sourcerygxx-4_1-23:1.9
	newlib-csl-sourcerygxx-4_1-21:1.9
	newlib-csl-arm-2006q3-21:1.9
	newlib-csl-arm-2006q3-19:1.9
	newlib-csl-sourcerygxx-4_1-19:1.9
	newlib-csl-sourcerygxx-4_1-18:1.9
	newlib-csl-sourcerygxx-3_4_4-25:1.9
	newlib-csl-sourcerygxx-4_1-17:1.9
	cr-0x5f1:1.9.0.6
	newlib-csl-sourcerygxx-4_1-14:1.9
	newlib-csl-sourcerygxx-4_1-13:1.9
	newlib-csl-sourcerygxx-4_1-12:1.9
	newlib-csl-sourcerygxx-4_1-9:1.9
	newlib-csl-sourcerygxx-4_1-8:1.9
	newlib-csl-sourcerygxx-4_1-7:1.9
	newlib-csl-arm-2006q1-6:1.9
	newlib-csl-sourcerygxx-4_1-6:1.9
	newlib-csl-sourcerygxx-4_1-5:1.9
	newlib-csl-sourcerygxx-4_1-4:1.9
	newlib-autotools-branch:1.9.0.4
	newlib-csl-20060320-branch:1.9.0.2
	newlib-csl-20060320-branchpoint:1.9
	newlib-1_14_0:1.9
	newlib-csl-arm-2005-q1b:1.8
	newlib-csl-arm-2005-q1a:1.8
	newlib-1_13_0:1.8
	csl-arm-2004-q3:1.8
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.7
	newlib-1_12_0:1.7
	csl-arm-2003-q4:1.7
	w32api-2_2:1.4
	mingw-runtime-2_4:1.4
	newlib-1_11_0:1.2
	cygnus_cvs_20020108_pre:1.1.1.1
	newlib-1_10_0:1.1.1.1
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2014.07.04.17.21.44;	author jjohnstn;	state Exp;
branches;
next	1.16;

1.16
date	2013.11.18.17.28.06;	author joel;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.13.09.13.56;	author yselkowitz;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.12.10.27.10;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.31.21.08.03;	author jjohnstn;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.14.21.14.55;	author jjohnstn;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.19.03.42.21;	author ericb;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.04.02.55.16;	author ericb;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.28.21.38.59;	author jjohnstn;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.23.20.01.55;	author jjohnstn;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.06.00.50.57;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.20.18.46.37;	author jjohnstn;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.22.18.52.25;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.05.16.52.34;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.07.20.02.33;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.04.18.56.17;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.17
log
@2014-07-04  Bin Cheng  <bin.cheng@@arm.com>

        * README (--enable-newlib-nano-formatted-io): Describe.
        * acconfig.h (_NANO_FORMATTED_IO): Undef.
        * newlib.hin (_NANO_FORMATTED_IO): Undef.
        * configure.in (--enable-newlib-nano-formatted-io): New option.
        * configure: Regenerated.
        * libc/configure.in (--enable-newlib-nano-formatted-io): New option.
        * libc/configure: Regenerated.
        * libc/stdio/Makefile.am (NEWLIB_NANO_FORMATTED_IO): Support new
        configuration option.
        * libc/stdio/Makefile.in: Regenerated.
        * libc/stdio/asnprintf.c (_asniprintf_r, asniprintf): Use
        _NANO_FORMATTED_IO to declare alias prototypes.
        * libc/stdio/asprintf.c (_asiprintf_r, asiprintf): Ditto.
        * libc/stdio/dprintf.c (_diprintf_r, diprintf): Ditto.
        * libc/stdio/fprintf.c (_fiprintf_r, fiprintf): Ditto.
        * libc/stdio/fscanf.c (fiscanf, _fiscanf_r): Ditto.
        * libc/stdio/printf.c (_iprintf_r, iprintf): Ditto.
        * libc/stdio/scanf.c (iscanf, _iscanf_r): Ditto.
        * libc/stdio/snprintf.c (_sniprintf_r, sniprintf): Ditto.
        * libc/stdio/sprintf.c (_siprintf_r, siprintf): Ditto.
        * libc/stdio/sscanf.c (siscanf, _siscanf_r): Ditto.
        * libc/stdio/vasnprintf.c (_vasniprintf_r, vasniprintf): Ditto.
        * libc/stdio/vasprintf.c (vasiprintf, _vasiprintf_r): Ditto.
        * libc/stdio/vdprintf.c (_vdiprintf_r, vdiprintf): Ditto.
        * libc/stdio/vprintf.c (viprintf, _viprintf_r): Ditto.
        * libc/stdio/vscanf.c (viscanf, _viscanf_r): Ditto.
        * libc/stdio/vsnprintf.c (vsniprintf, _vsniprintf_r): Ditto.
        * libc/stdio/vsprintf.c (vsiprintf, _vsiprintf_r): Ditto.
        * libc/stdio/vsscanf.c (vsiscanf, _vsiscanf_r): Ditto.
        * libc/stdio/nano-vfprintf.c: New file.
        * libc/stdio/nano-vfprintf_float.c: New file.
        * libc/stdio/nano-vfprintf_i.c: New file.
        * libc/stdio/nano-vfprintf_local.h: New file.
        * libc/stdio/nano-vfscanf.c: New file.
        * libc/stdio/nano-vfscanf_float.c: New file.
        * libc/stdio/nano-vfscanf_i.c: New file.
        * libc/stdio/nano-vfscanf_local.h: New file.
@
text
@/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
FUNCTION
<<sprintf>>, <<fprintf>>, <<printf>>, <<snprintf>>, <<asprintf>>, <<asnprintf>>---format output

INDEX
	fprintf
INDEX
	_fprintf_r
INDEX
	printf
INDEX
	_printf_r
INDEX
	asprintf
INDEX
	_asprintf_r
INDEX
	sprintf
INDEX
	_sprintf_r
INDEX
	snprintf
INDEX
	_snprintf_r
INDEX
	asnprintf
INDEX
	_asnprintf_r

ANSI_SYNOPSIS
        #include <stdio.h>

        int printf(const char *restrict <[format]>, ...);
        int fprintf(FILE *restrict <[fd]>, const char *restrict <[format]>, ...);
        int sprintf(char *restrict <[str]>, const char *restrict <[format]>, ...);
        int snprintf(char *restrict <[str]>, size_t <[size]>, const char *restrict <[format]>,
                     ...);
        int asprintf(char **restrict <[strp]>, const char *restrict <[format]>, ...);
        char *asnprintf(char *restrict <[str]>, size_t *restrict <[size]>, const char *restrict <[format]>,
                        ...);

        int _printf_r(struct _reent *<[ptr]>, const char *restrict <[format]>, ...);
        int _fprintf_r(struct _reent *<[ptr]>, FILE *restrict <[fd]>,
                       const char *restrict <[format]>, ...);
        int _sprintf_r(struct _reent *<[ptr]>, char *restrict <[str]>,
                       const char *restrict <[format]>, ...);
        int _snprintf_r(struct _reent *<[ptr]>, char *restrict <[str]>, size_t <[size]>,
                        const char *restrict <[format]>, ...);
        int _asprintf_r(struct _reent *<[ptr]>, char **restrict <[strp]>,
                        const char *restrict <[format]>, ...);
        char *_asnprintf_r(struct _reent *<[ptr]>, char *restrict <[str]>,
                           size_t *restrict <[size]>, const char *restrict <[format]>, ...);

DESCRIPTION
        <<printf>> accepts a series of arguments, applies to each a
        format specifier from <<*<[format]>>>, and writes the
        formatted data to <<stdout>>, without a terminating NUL
        character.  The behavior of <<printf>> is undefined if there
        are not enough arguments for the format.  <<printf>> returns
        when it reaches the end of the format string.  If there are
        more arguments than the format requires, excess arguments are
        ignored.

        <<fprintf>> is like <<printf>>, except that output is directed
        to the stream <[fd]> rather than <<stdout>>.

        <<sprintf>> is like <<printf>>, except that output is directed
        to the buffer <[str]>, and a terminating NUL is output.
        Behavior is undefined if more output is generated than the
        buffer can hold.

        <<snprintf>> is like <<sprintf>>, except that output is
        limited to at most <[size]> bytes, including the terminating
        <<NUL>>.  As a special case, if <[size]> is 0, <[str]> can be
        NULL, and <<snprintf>> merely calculates how many bytes would
        be printed.

        <<asprintf>> is like <<sprintf>>, except that the output is
        stored in a dynamically allocated buffer, <[pstr]>, which
        should be freed later with <<free>>.

        <<asnprintf>> is like <<sprintf>>, except that the return type
        is either the original <[str]> if it was large enough, or a
        dynamically allocated string if the output exceeds *<[size]>;
        the length of the result is returned in *<[size]>.  When
        dynamic allocation occurs, the contents of the original
        <[str]> may have been modified.

        For <<sprintf>>, <<snprintf>>, and <<asnprintf>>, the behavior
	is undefined if the output <<*<[str]>>> overlaps with one of
	the arguments.  Behavior is also undefined if the argument for
	<<%n>> within <<*<[format]>>> overlaps another argument.

        <[format]> is a pointer to a character string containing two
	types of objects: ordinary characters (other than <<%>>),
	which are copied unchanged to the output, and conversion
	specifications, each of which is introduced by <<%>>. (To
	include <<%>> in the output, use <<%%>> in the format string.)
	A conversion specification has the following form:

.       %[<[pos]>][<[flags]>][<[width]>][.<[prec]>][<[size]>]<[type]>

        The fields of the conversion specification have the following
        meanings:

        O+
	o <[pos]>

        Conversions normally consume arguments in the order that they
        are presented.  However, it is possible to consume arguments
        out of order, and reuse an argument for more than one
        conversion specification (although the behavior is undefined
        if the same argument is requested with different types), by
        specifying <[pos]>, which is a decimal integer followed by
        '$'.  The integer must be between 1 and <NL_ARGMAX> from
        limits.h, and if argument <<%n$>> is requested, all earlier
        arguments must be requested somewhere within <[format]>.  If
        positional parameters are used, then all conversion
        specifications except for <<%%>> must specify a position.
	This positional parameters method is a POSIX extension to the C
	standard definition for the functions.

	o <[flags]>

	<[flags]> is an optional sequence of characters which control
	output justification, numeric signs, decimal points, trailing
	zeros, and octal and hex prefixes.  The flag characters are
	minus (<<->>), plus (<<+>>), space ( ), zero (<<0>>), sharp
	(<<#>>), and quote (<<'>>).  They can appear in any
	combination, although not all flags can be used for all
	conversion specification types.

		o+
		o '
			A POSIX extension to the C standard.  However, this
			implementation presently treats it as a no-op, which
			is the default behavior for the C locale, anyway.  (If
			it did what it is supposed to, when <[type]> were <<i>>,
			<<d>>, <<u>>, <<f>>, <<F>>, <<g>>, or <<G>>, the
			integer portion of the conversion would be formatted
			with thousands' grouping wide characters.)

		o -
			The result of the conversion is left
			justified, and the right is padded with
			blanks.  If you do not use this flag, the
			result is right justified, and padded on the
			left.

	        o +
			The result of a signed conversion (as
			determined by <[type]> of <<d>>, <<i>>, <<a>>,
			<<A>>, <<e>>, <<E>>, <<f>>, <<F>>, <<g>>, or
			<<G>>) will always begin with a plus or minus
			sign.  (If you do not use this flag, positive
			values do not begin with a plus sign.)

		o " " (space)
			If the first character of a signed conversion
		        specification is not a sign, or if a signed
		        conversion results in no characters, the
		        result will begin with a space.  If the space
		        ( ) flag and the plus (<<+>>) flag both
		        appear, the space flag is ignored.

	        o 0
			If the <[type]> character is <<d>>, <<i>>,
			<<o>>, <<u>>, <<x>>, <<X>>, <<a>>, <<A>>,
			<<e>>, <<E>>, <<f>>, <<F>>, <<g>>, or <<G>>:  leading
			zeros are used to pad the field width
			(following any indication of sign or base); no
			spaces are used for padding.  If the zero
			(<<0>>) and minus (<<->>) flags both appear,
			the zero (<<0>>) flag will be ignored.  For
			<<d>>, <<i>>, <<o>>, <<u>>, <<x>>, and <<X>>
			conversions, if a precision <[prec]> is
			specified, the zero (<<0>>) flag is ignored.

			Note that <<0>> is interpreted as a flag, not
		        as the beginning of a field width.

	        o #
			The result is to be converted to an
			alternative form, according to the <[type]>
			character:

			o+
			o o
				Increases precision to force the first
				digit of the result to be a zero.

			o x
				A non-zero result will have a <<0x>>
				prefix.

			o X
				A non-zero result will have a <<0X>>
				prefix.

			o a, A, e, E, f, or F
				The result will always contain a
			        decimal point even if no digits follow
			        the point.  (Normally, a decimal point
			        appears only if a digit follows it.)
			        Trailing zeros are removed.

			o g or G
				The result will always contain a
			        decimal point even if no digits follow
			        the point.  Trailing zeros are not
			        removed.

			o all others
				Undefined.

			o-
		o-

	o <[width]>

		<[width]> is an optional minimum field width.  You can
		either specify it directly as a decimal integer, or
		indirectly by using instead an asterisk (<<*>>), in
		which case an <<int>> argument is used as the field
		width.  If positional arguments are used, then the
		width must also be specified positionally as <<*m$>>,
		with m as a decimal integer.  Negative field widths
		are treated as specifying the minus (<<->>) flag for
		left justfication, along with a positive field width.
		The resulting format may be wider than the specified
		width.

	o <[prec]>

		<[prec]> is an optional field; if present, it is
		introduced with `<<.>>' (a period). You can specify
		the precision either directly as a decimal integer or
		indirectly by using an asterisk (<<*>>), in which case
		an <<int>> argument is used as the precision.  If
		positional arguments are used, then the precision must
		also be specified positionally as <<*m$>>, with m as a
		decimal integer.  Supplying a negative precision is
		equivalent to omitting the precision.  If only a
		period is specified the precision is zero. The effect
		depends on the conversion <[type]>.

		o+
		o d, i, o, u, x, or X
			Minimum number of digits to appear.  If no
			precision is given, defaults to 1.

		o a or A
			Number of digits to appear after the decimal
			point.  If no precision is given, the
			precision defaults to the minimum needed for
			an exact representation.

		o e, E, f or F
			Number of digits to appear after the decimal
			point.  If no precision is given, the
			precision defaults to 6.

		o g or G
			Maximum number of significant digits.  A
			precision of 0 is treated the same as a
			precision of 1.  If no precision is given, the
			precision defaults to 6.

		o s or S
			Maximum number of characters to print from the
			string.  If no precision is given, the entire
			string is printed.

		o all others
			undefined.

		o-

	o <[size]>

		<[size]> is an optional modifier that changes the data
		type that the corresponding argument has.  Behavior is
		unspecified if a size is given that does not match the
		<[type]>.

		o+
		o hh
			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
			<<X>>, specifies that the argument should be
			converted to a <<signed char>> or <<unsigned
			char>> before printing.

			With <<n>>, specifies that the argument is a
			pointer to a <<signed char>>.

		o h
			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
			<<X>>, specifies that the argument should be
			converted to a <<short>> or <<unsigned short>>
			before printing.

			With <<n>>, specifies that the argument is a
			pointer to a <<short>>.

		o l
			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
			<<X>>, specifies that the argument is a
			<<long>> or <<unsigned long>>.

			With <<c>>, specifies that the argument has
			type <<wint_t>>.

			With <<s>>, specifies that the argument is a
			pointer to <<wchar_t>>.

			With <<n>>, specifies that the argument is a
			pointer to a <<long>>.

			With <<a>>, <<A>>, <<e>>, <<E>>, <<f>>, <<F>>,
			<<g>>, or <<G>>, has no effect (because of
			vararg promotion rules, there is no need to
			distinguish between <<float>> and <<double>>).

		o ll
			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
			<<X>>, specifies that the argument is a
			<<long long>> or <<unsigned long long>>.

			With <<n>>, specifies that the argument is a
			pointer to a <<long long>>.

		o j
			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
			<<X>>, specifies that the argument is an
			<<intmax_t>> or <<uintmax_t>>.

			With <<n>>, specifies that the argument is a
			pointer to an <<intmax_t>>.

		o z
			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
			<<X>>, specifies that the argument is a <<size_t>>.

			With <<n>>, specifies that the argument is a
			pointer to a <<size_t>>.

		o t
			With <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, or
			<<X>>, specifies that the argument is a
			<<ptrdiff_t>>.

			With <<n>>, specifies that the argument is a
			pointer to a <<ptrdiff_t>>.

		o L
			With <<a>>, <<A>>, <<e>>, <<E>>, <<f>>, <<F>>,
			<<g>>, or <<G>>, specifies that the argument
			is a <<long double>>.

		o-

	o   <[type]>

		<[type]> specifies what kind of conversion <<printf>>
		performs.  Here is a table of these:

		o+
		o %
			Prints the percent character (<<%>>).

		o c
			Prints <[arg]> as single character.  If the
			<<l>> size specifier is in effect, a multibyte
			character is printed.

		o C
			Short for <<%lc>>.  A POSIX extension to the C standard.

		o s
			Prints the elements of a pointer to <<char>>
			until the precision or a null character is
			reached.  If the <<l>> size specifier is in
			effect, the pointer is to an array of
			<<wchar_t>>, and the string is converted to
			multibyte characters before printing.

		o S
			Short for <<%ls>>.  A POSIX extension to the C standard.

		o d or i
			Prints a signed decimal integer; takes an
			<<int>>.  Leading zeros are inserted as
			necessary to reach the precision.  A value of 0 with
			a precision of 0 produces an empty string.

		o D
			Newlib extension, short for <<%ld>>.

		o o
			Prints an unsigned octal integer; takes an
			<<unsigned>>.  Leading zeros are inserted as
			necessary to reach the precision.  A value of 0 with
			a precision of 0 produces an empty string.

		o O
			Newlib extension, short for <<%lo>>.

		o u
			Prints an unsigned decimal integer; takes an
			<<unsigned>>.  Leading zeros are inserted as
			necessary to reach the precision.  A value of 0 with
			a precision of 0 produces an empty string.

		o U
			Newlib extension, short for <<%lu>>.

		o x
			Prints an unsigned hexadecimal integer (using
			<<abcdef>> as digits beyond <<9>>); takes an
			<<unsigned>>.  Leading zeros are inserted as
			necessary to reach the precision.  A value of 0 with
			a precision of 0 produces an empty string.

		o X
			Like <<x>>, but uses <<ABCDEF>> as digits
			beyond <<9>>.

		o f
			Prints a signed value of the form
			<<[-]9999.9999>>, with the precision
			determining how many digits follow the decimal
			point; takes a <<double>> (remember that
			<<float>> promotes to <<double>> as a vararg).
			The low order digit is rounded to even.  If
			the precision results in at most DECIMAL_DIG
			digits, the result is rounded correctly; if
			more than DECIMAL_DIG digits are printed, the
			result is only guaranteed to round back to the
			original value.

			If the value is infinite, the result is
			<<inf>>, and no zero padding is performed.  If
			the value is not a number, the result is
			<<nan>>, and no zero padding is performed.

		o F
			Like <<f>>, but uses <<INF>> and <<NAN>> for
			non-finite numbers.

		o e
			Prints a signed value of the form
			<<[-]9.9999e[+|-]999>>; takes a <<double>>.
			The digit before the decimal point is non-zero
			if the value is non-zero.  The precision
			determines how many digits appear between
			<<.>> and <<e>>, and the exponent always
			contains at least two digits.  The value zero
			has an exponent of zero.  If the value is not
			finite, it is printed like <<f>>.

		o E
			Like <<e>>, but using <<E>> to introduce the
			exponent, and like <<F>> for non-finite
			values.

		o g
			Prints a signed value in either <<f>> or <<e>>
			form, based on the given value and
			precision---an exponent less than -4 or
			greater than the precision selects the <<e>>
			form.  Trailing zeros and the decimal point
			are printed only if necessary; takes a
			<<double>>.

		o G
			Like <<g>>, except use <<F>> or <<E>> form.

		o a
			Prints a signed value of the form
			<<[-]0x1.ffffp[+|-]9>>; takes a <<double>>.
			The letters <<abcdef>> are used for digits
			beyond <<9>>.  The precision determines how
			many digits appear after the decimal point.
			The exponent contains at least one digit, and
			is a decimal value representing the power of
			2; a value of 0 has an exponent of 0.
			Non-finite values are printed like <<f>>.

		o A
			Like <<a>>, except uses <<X>>, <<P>>, and
			<<ABCDEF>> instead of lower case.

		o n
			Takes a pointer to <<int>>, and stores a count
			of the number of bytes written so far.  No
			output is created.

		o p
			Takes a pointer to <<void>>, and prints it in
			an implementation-defined format.  This
			implementation is similar to <<%#tx>>), except
			that <<0x>> appears even for the NULL pointer.

		o m
			Prints the output of <<strerror(errno)>>; no
			argument is required.  A GNU extension.

		o-
	O-

        <<_printf_r>>, <<_fprintf_r>>, <<_asprintf_r>>,
        <<_sprintf_r>>, <<_snprintf_r>>, <<_asnprintf_r>> are simply
        reentrant versions of the functions above.

RETURNS
On success, <<sprintf>> and <<asprintf>> return the number of bytes in
the output string, except the concluding <<NUL>> is not counted.
<<snprintf>> returns the number of bytes that would be in the output
string, except the concluding <<NUL>> is not counted.  <<printf>> and
<<fprintf>> return the number of characters transmitted.
<<asnprintf>> returns the original <[str]> if there was enough room,
otherwise it returns an allocated string.

If an error occurs, the result of <<printf>>, <<fprintf>>,
<<snprintf>>, and <<asprintf>> is a negative value, and the result of
<<asnprintf>> is NULL.  No error returns occur for <<sprintf>>.  For
<<printf>> and <<fprintf>>, <<errno>> may be set according to
<<fputc>>.  For <<asprintf>> and <<asnprintf>>, <<errno>> may be set
to ENOMEM if allocation fails, and for <<snprintf>>, <<errno>> may be
set to EOVERFLOW if <[size]> or the output length exceeds INT_MAX.

BUGS
The ``''' (quote) flag does not work when locale's thousands_sep is not empty.

PORTABILITY
ANSI C requires <<printf>>, <<fprintf>>, <<sprintf>>, and
<<snprintf>>.  <<asprintf>> and <<asnprintf>> are newlib extensions.

The ANSI C standard specifies that implementations must support at
least formatted output of up to 509 characters.  This implementation
has no inherent limit.

Depending on how newlib was configured, not all format specifiers are
supported.

Supporting OS subroutines required: <<close>>, <<fstat>>, <<isatty>>,
<<lseek>>, <<read>>, <<sbrk>>, <<write>>.
*/

#include <_ansi.h>
#include <reent.h>
#include <stdio.h>
#ifdef _HAVE_STDC
#include <stdarg.h>
#else
#include <varargs.h>
#endif
#include <limits.h>
#include "local.h"

int
#ifdef _HAVE_STDC
_DEFUN(_sprintf_r, (ptr, str, fmt),
       struct _reent *ptr _AND
       char *__restrict str          _AND
       _CONST char *__restrict fmt _DOTS)
#else
_sprintf_r(ptr, str, fmt, va_alist)
           struct _reent *ptr;
           char *__restrict str;
           _CONST char *__restrict fmt;
           va_dcl
#endif
{
  int ret;
  va_list ap;
  FILE f;

  f._flags = __SWR | __SSTR;
  f._bf._base = f._p = (unsigned char *) str;
  f._bf._size = f._w = INT_MAX;
  f._file = -1;  /* No file. */
#ifdef _HAVE_STDC
  va_start (ap, fmt);
#else
  va_start (ap);
#endif
  ret = _svfprintf_r (ptr, &f, fmt, ap);
  va_end (ap);
  *f._p = '\0';	/* terminate the string */
  return (ret);
}

#ifdef _NANO_FORMATTED_IO
int
_EXFUN(_siprintf_r, (struct _reent *, char *, const char *, ...)
       _ATTRIBUTE ((__alias__("_sprintf_r"))));
#endif

#ifndef _REENT_ONLY

int
#ifdef _HAVE_STDC
_DEFUN(sprintf, (str, fmt),
       char *__restrict str _AND
       _CONST char *__restrict fmt _DOTS)
#else
sprintf(str, fmt, va_alist)
        char *str;
        _CONST char *fmt;
        va_dcl
#endif
{
  int ret;
  va_list ap;
  FILE f;

  f._flags = __SWR | __SSTR;
  f._bf._base = f._p = (unsigned char *) str;
  f._bf._size = f._w = INT_MAX;
  f._file = -1;  /* No file. */
#ifdef _HAVE_STDC
  va_start (ap, fmt);
#else
  va_start (ap);
#endif
  ret = _svfprintf_r (_REENT, &f, fmt, ap);
  va_end (ap);
  *f._p = '\0';	/* terminate the string */
  return (ret);
}

#ifdef _NANO_FORMATTED_IO
int
_EXFUN(siprintf, (char *, const char *, ...)
       _ATTRIBUTE ((__alias__("sprintf"))));
#endif
#endif
@


1.16
log
@2013-11-18  Sahil Patnayakuni  <sahilp@@oarcorp.com>

	* libc/include/stdio.h, libc/machine/powerpc/vfscanf.c,
	libc/machine/spu/fgetpos.c, libc/machine/spu/fgets.c,
	libc/machine/spu/fopen.c, libc/machine/spu/fputs.c,
	libc/machine/spu/fread.c, libc/machine/spu/freopen.c,
	libc/machine/spu/fwrite.c, libc/machine/spu/setbuf.c,
	libc/machine/spu/vfprintf.c, libc/machine/spu/vfscanf.c,
	libc/machine/spu/vsnprintf.c, libc/machine/spu/vsprintf.c,
	libc/machine/spu/vsscanf.c, libc/stdio/asnprintf.c,
	libc/stdio/asprintf.c, libc/stdio/dprintf.c,
	libc/stdio/fgetpos.c, libc/stdio/fgets.c,
	libc/stdio/fmemopen.c, libc/stdio/fopen.c,
	libc/stdio/fprintf.c, libc/stdio/fputs.c,
	libc/stdio/fread.c, libc/stdio/freopen.c,
	libc/stdio/fscanf.c, libc/stdio/fwrite.c,
	libc/stdio/printf.c, libc/stdio/scanf.c,
	libc/stdio/setbuf.c, libc/stdio/snprintf.c,
	libc/stdio/sprintf.c, libc/stdio/sscanf.c,
	libc/stdio/vdprintf.c, libc/stdio/vprintf.c,
	libc/stdio/vscanf.c, libc/stdio/vsnprintf.c,
	libc/stdio/vsprintf.c, libc/stdio/vsscanf.c: Add restrict keyword.
@
text
@d611 6
d650 5
@


1.15
log
@	* libc/stdio/sprintf.c: Document 'm' conversion specifier.
	* libc/stdio/swprintf.c: Ditto.
	* libc/stdio/vfprintf.c (_VFPRINTF_R) [_GLIBC_EXTENSION]: Handle 'm'
	conversion specifier.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R) [_GLIBC_EXTENSION]: Ditto.
@
text
@d50 4
a53 4
        int printf(const char *<[format]>, ...);
        int fprintf(FILE *<[fd]>, const char *<[format]>, ...);
        int sprintf(char *<[str]>, const char *<[format]>, ...);
        int snprintf(char *<[str]>, size_t <[size]>, const char *<[format]>,
d55 2
a56 2
        int asprintf(char **<[strp]>, const char *<[format]>, ...);
        char *asnprintf(char *<[str]>, size_t *<[size]>, const char *<[format]>,
d59 11
a69 11
        int _printf_r(struct _reent *<[ptr]>, const char *<[format]>, ...);
        int _fprintf_r(struct _reent *<[ptr]>, FILE *<[fd]>,
                       const char *<[format]>, ...);
        int _sprintf_r(struct _reent *<[ptr]>, char *<[str]>,
                       const char *<[format]>, ...);
        int _snprintf_r(struct _reent *<[ptr]>, char *<[str]>, size_t <[size]>,
                        const char *<[format]>, ...);
        int _asprintf_r(struct _reent *<[ptr]>, char **<[strp]>,
                        const char *<[format]>, ...);
        char *_asnprintf_r(struct _reent *<[ptr]>, char *<[str]>,
                           size_t *<[size]>, const char *<[format]>, ...);
d582 2
a583 2
       char *str          _AND
       _CONST char *fmt _DOTS)
d587 2
a588 2
           char *str;
           _CONST char *fmt;
d616 2
a617 2
       char *str _AND
       _CONST char *fmt _DOTS)
@


1.14
log
@	* libc/stdio/swprintf.c (_swprintf_r, swprintf):
	correct how terminating L'\0' is added;
	change return to match standard for when output does not fit;
	some corrections and enhancements to the docs.
	* libc/stdio/vswprintf.c (_vswprintf_r):  ditto, except for docs.
	* libc/stdio/vfwprintf.c:  some corrections to the docs and some
	enhancements to comments.  (No code changes.)
	* libc/time/strftime.c:  Correct some problems that made wcsftime()
	not work correctly:  work properly with swprintf returns that are
	different from snprintf returns, correct test vector lengths for
	when sizeof(wchar_t) > 1.
	* libc/stdio/sprintf.c:  Some documentation and comment corrections and
	enhancements to match those done to swprintf.c.
@
text
@d521 4
@


1.13
log
@
2008-10-31  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/diprintf.c: Modify documentation so eclipse newlib
        libhover docs generate properly.
        * libc/stdio/dprintf.c: Ditto.
        * libc/stdio/fflush.c: Ditto.
        * libc/stdio/fopencookie.c: Ditto.
        * libc/stdio/fread.c: Ditto.
        * libc/stdio/fsetpos.c: Ditto.
        * libc/stdio/getc_u.c: Ditto.
        * libc/stdio/getchar_u.c: Ditto.
        * libc/stdio/putc_u.c: Ditto.
        * libc/stdio/putchar_u.c: Ditto.
        * libc/stdio/remove.c: Ditto.
        * libc/stdio/siprintf.c: Ditto.
        * libc/stdio/siscanf.c: Ditto.
        * libc/stdio/sprintf.c: Ditto.
        * libc/stdio/sscanf.c: Ditto.
        * libc/stdio/vfprintf.c: Ditto.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/viprintf.c: Ditto.
        * libc/stdio/viscanf.c: Ditto.
        * libc/stdlib/calloc.c: Ditto.
        * libc/stdlib/efgcvt.c: Ditto.
        * libc/stdlib/envlock.c: Ditto.
        * libc/time/asctime.c: Ditto.
        * libc/time/ctime.c: Ditto.
        * libc/time/gmtime.c: Ditto.
        * libc/time/lcltime.c: Ditto.
        * libc/time/tzset.c: Ditto.
        * libc/stdlib/envlock.h: Moved to libc/include.
@
text
@d137 2
d152 7
a158 6
			Since newlib only supports the C locale, this
			flag has no effect in this implementation.
			But in other locales, when <[type]> is <<i>>,
			<<d>>, <<u>>, <<f>>, <<F>>, <<g>>, or <<G>>,
			the locale-dependent thousand's separator is
			inserted prior to zero padding.
d186 1
a186 1
			<<e>>, <<E>>, <<f>>, <<g>>, or <<G>>: leading
d359 1
a359 2
			<<X>>, specifies that the argument is a
			<<ssize_t>> or <<size_t>>.
d362 1
a362 1
			pointer to a <<ssize_t>>.
d394 1
a394 1
			Short for <<%lc>>.
d405 1
a405 1
			Short for <<%ls>>.
d410 2
a411 2
			necessary to reach the precision.  A precision
			of 0 produces an empty string.
d419 2
a420 2
			necessary to reach the precision.  A precision
			of 0 produces an empty string.
d428 2
a429 2
			necessary to reach the precision.  A precision
			of 0 produces an empty string.
d438 2
a439 2
			necessary to reach the precision.  A precision
			of 0 produces an empty string.
d545 3
d603 1
a603 1
  *f._p = 0;
d636 1
a636 1
  *f._p = 0;
@


1.12
log
@
2008-04-14  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/Makefile.am: Build vfprintf.c and vfscanf.c with
        -DSTRING_ONLY defined with and without -DINTEGER_ONLY defined
        to build special versions for sprintf/sscanf family functions.
        * libc/stdio/Makefile.in: Regenerated.
        * libc/stdio/vfprintf.c[STRING_ONLY][INTEGER_ONLY](_VFPRINTF_R):
        Redefine to be _svfiprintf_r which is optimized to work with siprintf
        family of functions (i.e. no I/O) and does not support floating-point.
        [STRING_ONLY][!INTEGER_ONLY](_VFPRINTF_R): Redefine to be
        _svfprintf_r which is optimized to work with sprintf family of
        functions and not use I/O.
        [STRING_ONLY](__sprint_r): New string only version of static function.
        designed to work with sprintf family of functions.
        * libc/stdio/vfscanf.c[STRING_ONLY][INTEGER_ONLY](_SVFSCANF_R):
        Redefine to be _ssvfiscanf_r which is optimized to work with siscanf
        family of functions (i.e. no I/O) and no float-point support.
        [STRING_ONLY][!INTEGER_ONLY](_SVFSCANF_R): Redefine to be
        __ssvfscanf_r which is optimized to work with sscanf family of
        functions and does not require I/O functions.
        * libc/stdio/asprintf.c: Call _svfprintf_r instead of _vfprintf_r.
        * libc/stdio/snprintf.c: Ditto.
        * libc/stdio/sprintf.c: Ditto.
        * libc/stdio/vasnprintf.c: Ditto.
        * libc/stdio/vasprintf.c: Ditto.
        * libc/stdio/siprintf.c: Call _svfiprintf_r instead of _vfiprintf_r.
        * libc/stdio/sniprintf.c: Ditto.
        * libc/stdio/vasiprintf.c: Ditto.
        * libc/stdio/vsiprintf.c: Ditto.
        * libc/stdio/vsniprintf.c: Ditto.
        * libc/stdio/vsprintf.c: Ditto.
        * libc/stdio/local.h: Add prototypes for _svfprintf_r, _svfiprintf_r,
        _ssvfscanf_r, and _ssvfiscanf_r.
        * libc/stdio/sscanf.c: Call _ssvfscanf_r instead of _svfscanf_r.
        * libc/stdio/vsscanf.c: Ditto.
        * libc/stdio/siscanf.c: Call _ssvfiscanf_r instead of _svfiscanf_r.
        * libc/stdio/vsiscanf.c: Ditto.
@
text
@d25 2
d29 2
d33 2
d37 2
d41 2
d44 2
d50 8
a57 8
        int printf(const char *<[format]> [, <[arg]>, ...]);
        int fprintf(FILE *<[fd]>, const char *<[format]> [, <[arg]>, ...]);
        int sprintf(char *<[str]>, const char *<[format]> [, <[arg]>, ...]);
        int snprintf(char *<[str]>, size_t <[size]>, const char *<[format]>
                     [, <[arg]>, ...]);
        int asprintf(char **<[strp]>, const char *<[format]> [, <[arg]>, ...]);
        char *asnprintf(char *<[str]>, size_t *<[size]>, const char *<[format]>
                        [, <[arg]>, ...]);
d59 1
a59 2
        int _printf_r(struct _reent *<[ptr]>, const char *<[format]>
                      [, <[arg]>, ...]);
d61 1
a61 1
                       const char *<[format]> [, <[arg]>, ...]);
d63 1
a63 1
                       const char *<[format]> [, <[arg]>, ...]);
d65 1
a65 1
                        const char *<[format]> [, <[arg]>, ...]);
d67 1
a67 1
                        const char *<[format]> [, <[arg]>, ...]);
d69 1
a69 2
                           size_t *<[size]>, const char *<[format]>
                           [, <[arg]>, ...]);
@


1.11
log
@Fix 'make info'.
* libc/stdio/stdio.tex: Add missing include.
* libc/stdio/vfprintf.c: Use expected node name.
* libc/stdio/vfscanf.c: Likewise.
* libc/stdio/sscanf.c: Likewise.
* libc/stdio/sprintf.c: Likewise.
* libc/stdio/siscanf.c: Likewise.
* libc/stdio/siprintf.c: Likewise.
* libc/stdio/fopencookie.c: Quote raw {}.
Reported by DJ Delorie.
@
text
@d586 1
a586 1
  ret = _vfprintf_r (ptr, &f, fmt, ap);
d619 1
a619 1
  ret = _vfprintf_r (_REENT, &f, fmt, ap);
@


1.10
log
@	Add support for asnprintf, and improve *printf documentation.
	* libc/stdio/Makefile.am (ELIX_SOURCES): Rename...
	(ELIX_2_SOURCES): ...to this.
	(ELIX_4_SOURCES): Add new variable.  Build asnprintf.
	(GENERAL_SOURCES): Move dprintf to ELIX_4_SOURCES.
	(CHEWOUT_FILES): Include diprintf in documentation.
	* libc/stdio/Makefile.in: Regenerate.
	* libc/stdio/diprintf.c: Improve documentation.
	* libc/stdio/dprintf.c: Likewise.
	* libc/stdio/siprintf.c: Likewise.
	* libc/stdio/sprintf.c: Likewise.
	* libc/stdio/vfprintf.c: Likewise.
	* libc/stdio/viprintf.c: Likewise.
	* libc/stdio/vsniprintf.c: Consolidate documentation.
	* libc/stdio/asiprintf.c: Refer to documentation.
	* libc/stdio/asprintf.c: Likewise.
	* libc/stdio/fiprintf.c: Likewise.
	* libc/stdio/fprintf.c: Likewise.
	* libc/stdio/iprintf.c: Likewise.
	* libc/stdio/printf.c: Likewise.
	* libc/stdio/sniprintf.c: Likewise.
	* libc/stdio/vdiprintf.c: Likewise.
	* libc/stdio/vdprintf.c: Likewise.
	* libc/stdio/vsiprintf.c: Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Handle asnprintf.
	* libc/stdio/asniprintf.c (asniprintf, _asniprintf_r): New file.
	* libc/stdio/asnprintf.c (asnprintf, _asnprintf_r): New file.
	* libc/stdio/vasniprintf.c (vasniprintf, _vasniprintf_r): New
	file.
	* libc/stdio/vasnprintf.c (vasnprintf, _vasnprintf_r): New file.
	* libc/stdio/vdprintf.c (_vdprintf_r): Rewrite to avoid malloc in
	typical case.
	* libc/stdio/vdiprintf.c (_vdiprintf_r): Likewise.
	* libc/include/stdio.h: Add prototypes for new functions; sort
	existing functions.
@
text
@d20 1
a20 1
<<printf>>, <<fprintf>>, <<sprintf>>, <<snprintf>>, <<asprintf>>, <<asnprintf>>---format output
@


1.9
log
@
2005-10-28  Bob Wilson  <bob.wilson@@acm.org>

        * libc/stdio/siprintf.c: Wrap long lines in ANSI_SYNOPSIS.
        * libc/stdio/siscanf.c: Likewise.
        * libc/stdio/sprintf.c: Likewise.
        * libc/stdio/sscanf.c: Likewise.
        * libc/stdio/vfprintf.c: Likewise.
        * libc/stdio/vfscanf.c: Likewise.
        * libc/stdio/viprintf.c: Likewise.
        * libc/stdio/viscanf.c: Likewise.
@
text
@d20 1
a20 1
        <<printf>>, <<fprintf>>, <<asprintf>>, <<sprintf>>, <<snprintf>>---format output
d32 2
a40 1
        int asprintf(char **<[strp]>, const char *<[format]> [, <[arg]>, ...]);
d43 3
d47 13
a59 22
TRAD_SYNOPSIS
	#include <stdio.h>

	int printf(<[format]> [, <[arg]>, ...])
	char *<[format]>;

	int fprintf(<[fd]>, <[format]> [, <[arg]>, ...]);
	FILE *<[fd]>;
	char *<[format]>;

	int asprintf(<[strp]>, <[format]> [, <[arg]>, ...]);
	char **<[strp]>;
	char *<[format]>;

	int sprintf(<[str]>, <[format]> [, <[arg]>, ...]);
	char *<[str]>;
	char *<[format]>;

	int snprintf(<[str]>, size_t <[size]>, <[format]> [, <[arg]>, ...]);
	char *<[str]>;
        size_t <[size]>;
	char *<[format]>;
d64 43
a106 23
        formatted data to <<stdout>>, terminated with a null character.
        The behavior of <<printf>> is undefined if there are not enough
        arguments for the format.
        <<printf>> returns when it reaches the end of the format string.
        If there are more arguments than the format requires, excess
        arguments are ignored.

        <<fprintf>>, <<asprintf>>, <<sprintf>> and <<snprintf>> are identical 
	to <<printf>>, other than the destination of the formatted output: 
	<<fprintf>> sends the output to a specified file <[fd]>, while 
	<<asprintf>> stores the output in a dynamically allocated buffer,
	while <<sprintf>> stores the output in the specified char array 
	<[str]> and <<snprintf>> limits number of characters written to 
	<[str]> to at most <[size]> (including terminating <<0>>).  For 
	<<sprintf>> and <<snprintf>>, the behavior is undefined if the 
	output <<*<[str]>>> overlaps with one of the arguments. For
	<<asprintf>>, <[strp]> points to a pointer to char which is filled
	in with the dynamically allocated buffer.  <[format]> is a pointer 
	to a charater string containing two types of objects: ordinary 
	characters (other than <<%>>), which are copied unchanged to the 
	output, and conversion specifications, each of which is introduced 
	by <<%>>. (To include <<%>> in the output, use <<%%>> in the format 
	string.) A conversion specification has the following form:
d108 1
a108 1
.       %[<[flags]>][<[width]>][.<[prec]>][<[size]>][<[type]>]
d110 2
a111 1
        The fields of the conversion specification have the following meanings:
d114 14
d130 65
a194 46
	an optional sequence of characters which control
	output justification, numeric signs, decimal points,
	trailing zeroes, and octal and hex prefixes.
	The flag characters are minus (<<->>), plus (<<+>>),
	space ( ), zero (<<0>>), and sharp (<<#>>).  They can
	appear in any combination.

	o+
    	o -
		The result of the conversion is left justified, and the right is
		padded with blanks.  If you do not use this flag, the result is right
		justified, and padded on the left.

        o +
		The result of a signed conversion (as determined by <[type]>)
		will always begin with a plus or minus sign.  (If you do not use
        this flag, positive values do not begin with a plus sign.)

        o " " (space)
		If the first character of a signed conversion specification
        is not a sign, or if a signed conversion results in no
		characters, the result will begin with a space.  If the
        space ( ) flag and the plus (<<+>>) flag both appear,
		the space flag is ignored.

        o 0
		If the <[type]> character is <<d>>, <<i>>, <<o>>, <<u>>,
		<<x>>, <<X>>, <<e>>, <<E>>, <<f>>, <<g>>, or <<G>>: leading zeroes,
		are used to pad the field width (following any indication of sign or
		base); no spaces are used for padding.  If the zero (<<0>>) and
		minus (<<->>) flags both appear, the zero (<<0>>) flag will
		be ignored.  For <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, and <<X>>
		conversions, if a precision <[prec]> is specified, the zero (<<0>>)
        flag is ignored.
		
		Note that <<0>> is interpreted as a flag, not as the beginning
        of a field width.

        o #
		The result is to be converted to an alternative form, according
		to the next character:

	    o+
		    o 0
			increases precision to force the first digit
                        of the result to be a zero.
d197 2
a198 1
			a non-zero result will have a <<0x>> prefix.
d201 2
a202 1
			a non-zero result will have a <<0X>> prefix.
d204 6
a209 5
			o e, E or f
			The result will always contain a decimal point
		        even if no digits follow the point.
                        (Normally, a decimal point appears only if a
			digit follows it.)  Trailing zeroes are removed.
d212 4
a215 2
			same as <<e>> or <<E>>, but trailing zeroes
                        are not removed.
d218 61
d281 78
a358 2
			o-
      o-
d360 4
a363 1
      o <[width]>
d365 1
a365 45
	  <[width]> is an optional minimum field width.  You can either
	  specify it directly as a decimal integer, or indirectly by
          using instead an asterisk (<<*>>), in which case an <<int>>
          argument is used as the field width.  Negative field widths
          are not supported; if you attempt to specify a negative field
          width, it is interpreted as a minus (<<->>) flag followed by a
          positive field width.

      o <[prec]>

	  an optional field; if present, it is introduced with `<<.>>'
	  (a period). This field gives the maximum number of
	  characters to print in a conversion; the minimum number of
	  digits of an integer to print, for conversions with <[type]>
	  <<d>>, <<i>>, <<o>>, <<u>>, <<x>>, and <<X>>; the maximum number of
	  significant digits, for the <<g>> and <<G>> conversions;
	  or the number of digits to print after the decimal
	  point, for <<e>>, <<E>>, and <<f>> conversions.  You can specify
	  the precision either directly as a decimal integer or
	  indirectly by using an asterisk (<<*>>), in which case
	  an <<int>> argument is used as the precision.  Supplying a negative
      precision is equivalent to omitting the precision.
	  If only a period is specified the precision is zero.
	  If a precision appears with any other conversion <[type]>
	  than those listed here, the behavior is undefined.

      o  <[size]>

		<<h>>, <<l>>, and <<L>> are optional size characters which
		override the default way that <<printf>> interprets the
		data type of the corresponding argument.  <<h>> forces
		the following <<d>>, <<i>>, <<o>>, <<u>>, <<x>> or <<X>> conversion
		<[type]> to apply to a <<short>> or <<unsigned short>>. <<h>> also
		forces a following <<n>> <[type]> to apply to
		a pointer to a <<short>>. Similarily, an
		<<l>> forces the following <<d>>, <<i>>, <<o>>, <<u>>,
		<<x>> or <<X>> conversion <[type]> to apply to a <<long>> or
		<<unsigned long>>.  <<l>> also forces a following <<n>> <[type]> to
		apply to a pointer to a <<long>>.  <<l>> with <<c>>, <<s>> is
		equivalent to <<C>>, <<S>> respectively.  If an <<h>>
		or an <<l>> appears with another conversion
		specifier, the behavior is undefined.  <<L>> forces a
		following <<e>>, <<E>>, <<f>>, <<g>> or <<G>> conversion <[type]> to
		apply to a <<long double>> argument.  If <<L>> appears with
		any other conversion <[type]>, the behavior is undefined.
d367 1
a367 1
     o   <[type]>
d369 2
a370 2
		<[type]> specifies what kind of conversion <<printf>> performs.
		Here is a table of these:
d372 1
a372 1
	o+
d374 1
a374 1
		prints the percent character (<<%>>)
d377 4
a380 2
		prints <[arg]> as single character
		
d382 2
a383 2
		prints wchar_t <[arg]> as single multibyte character
		
d385 6
a390 2
		prints characters until precision is reached or a null terminator
		is encountered; takes a string pointer
d393 1
a393 3
		converts wchar_t characters to multibyte output characters until
		precision is reached or a null wchar_t terminator
		is encountered; takes a wchar_t pointer
d395 5
a399 2
		o d
		prints a signed decimal integer; takes an <<int>> (same as <<i>>)
d401 2
a402 2
		o i
		prints a signed decimal integer; takes an <<int>> (same as <<d>>)
d405 7
a411 1
		prints a signed octal integer; takes an <<int>>
d414 7
a420 1
		prints an unsigned decimal integer; takes an <<int>>
d423 5
a427 2
		prints an unsigned hexadecimal integer (using <<abcdef>> as
		digits beyond <<9>>); takes an <<int>>
d430 2
a431 2
		prints an unsigned hexadecimal integer (using <<ABCDEF>> as
		digits beyond <<9>>); takes an <<int>>
d434 21
a454 3
		prints a signed value of the form <<[-]9999.9999>>; takes
		a floating-point number
	
d456 9
a464 2
		prints a signed	value of the form <<[-]9.9999e[+|-]999>>; takes a
		floating-point number
d467 3
a469 2
		prints the same way as <<e>>, but using <<E>> to introduce the
		exponent; takes a floating-point number
d472 8
a479 4
		prints a signed value in either <<f>> or <<e>> form, based on given
		value and precision---trailing zeros and the decimal point are
		printed only if necessary; takes a floating-point number
	
d481 16
a496 2
		prints the same way as <<g>>, but using <<E>> for the exponent if an
		exponent is needed; takes a floating-point number
d499 3
a501 2
		stores (in the same object) a count of the characters written;
		takes a pointer to <<int>>
d504 11
a514 6
		prints a pointer in an implementation-defined format.
		This implementation treats the pointer as an
		<<unsigned long>> (same as <<Lu>>).
	o-
O-

d517 15
a531 5
<<sprintf>> and <<asprintf>> return the number of bytes in the output string,
save that the concluding <<NULL>> is not counted.
<<printf>> and <<fprintf>> return the number of characters transmitted.
If an error occurs, <<printf>> and <<fprintf>> return <<EOF>> and
<<asprintf>> returns -1.  No error returns occur for <<sprintf>>.
d534 9
a542 2
        The  ANSI C standard specifies that implementations must
        support at least formatted output of up to 509 characters.
@


1.8
log
@
2004-04-23  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * libc/stdio/asprintf.c libc/stdio/clearerr.c,
        libc/stdio/fclose.c libc/stdio/fcloseall.c libc/stdio/fdopen.c,
        libc/stdio/feof.c libc/stdio/ferror.c libc/stdio/fflush.c,
        libc/stdio/fgetc.c libc/stdio/fgetpos.c libc/stdio/fgets.c,
        libc/stdio/fileno.c libc/stdio/findfp.c libc/stdio/fiprintf.c,
        libc/stdio/flags.c libc/stdio/fopen.c libc/stdio/fprintf.c,
        libc/stdio/fputc.c libc/stdio/fputs.c libc/stdio/fread.c,
        libc/stdio/freopen.c libc/stdio/fscanf.c libc/stdio/fseek.c,
        libc/stdio/fseeko.c libc/stdio/fsetpos.c libc/stdio/ftell.c,
        libc/stdio/ftello.c libc/stdio/fvwrite.c libc/stdio/fwalk.c,
        libc/stdio/fwrite.c libc/stdio/getc.c libc/stdio/getc_u.c,
        libc/stdio/getchar.c libc/stdio/getchar_u.c,
        libc/stdio/getdelim.c libc/stdio/getline.c libc/stdio/gets.c,
        libc/stdio/getw.c libc/stdio/iprintf.c libc/stdio/local.h,
        libc/stdio/makebuf.c libc/stdio/mktemp.c libc/stdio/perror.c,
        libc/stdio/printf.c libc/stdio/putc.c libc/stdio/putc_u.c,
        libc/stdio/putchar.c libc/stdio/putchar_u.c libc/stdio/puts.c,
        libc/stdio/putw.c libc/stdio/refill.c libc/stdio/remove.c,
        libc/stdio/rename.c libc/stdio/rewind.c libc/stdio/rget.c,
        libc/stdio/scanf.c libc/stdio/setbuf.c libc/stdio/setbuffer.c,
        libc/stdio/setlinebuf.c libc/stdio/setvbuf.c,
        libc/stdio/siprintf.c libc/stdio/snprintf.c,
        libc/stdio/sprintf.c libc/stdio/sscanf.c libc/stdio/stdio.c,
        libc/stdio/tmpfile.c libc/stdio/tmpnam.c libc/stdio/ungetc.c,
        libc/stdio/vasprintf.c libc/stdio/vfieeefp.h,
        libc/stdio/vfprintf.c libc/stdio/vfscanf.c,
        libc/stdio/vprintf.c libc/stdio/vscanf.c,
        libc/stdio/vsnprintf.c libc/stdio/vsprintf.c,
        libc/stdio/vsscanf.c libc/stdio/wbuf.c,
        libc/stdio/wsetup.c: Perform minor formatting changes.  Move
        copyright notices to top of file, ensure that <_ansi.h> is
        included, be consistent with open parentheses, use _DEFUN macro,
        include "local.h" where needed, and remove various compiler
        warnings.
@
text
@d40 2
a41 1
        int snprintf(char *<[str]>, size_t <[size]>, const char *<[format]> [, <[arg]>, ...]);
@


1.7
log
@
2003-11-05  Jeff Johnston  <jjohnstn@@redhat.com>
            Artem B. Bityuckiy  <mail_lists@@mail.ru>

        * libc/stdio/vfprintf.c (_VFPRINTF_R): Add support for
        %ls, %S, %lc, and %C format specifiers.
        (get_arg): Ditto.
        * libc/stdio/sprintf.c: Add documentation regarding new
        format specifiers added in vfprintf.c.
@
text
@a18 1

d21 1
d308 2
a316 1
#include <_ansi.h>
d321 4
a324 1
_DEFUN (_sprintf_r, (ptr, str, fmt), struct _reent *ptr _AND char *str _AND _CONST char *fmt _DOTS)
d326 5
a330 5
_sprintf_r (ptr, str, fmt, va_alist)
     struct _reent *ptr;
     char *str;
     _CONST char *fmt;
     va_dcl
d356 3
a358 1
_DEFUN (sprintf, (str, fmt), char *str _AND _CONST char *fmt _DOTS)
d360 4
a363 4
sprintf (str, fmt, va_alist)
     char *str;
     _CONST char *fmt;
     va_dcl
@


1.6
log
@
2003-10-20  Bob Wilson  <bob.wilson@@acm.org>

	* libc/locale/locale.c: Use double quotes in code.
	* libc/locale/locale.tex: Likewise.
	* libc/libc.texinfo: Hyphenate "floating-point".
	* libc/machine/necv70/necv70.tex: Likewise.
	* libc/stdio/sprintf.c: Likewise.
	* libc/stdio/sscanf.c: Likewise.
	* libc/stdlib/atof.c: Likewise.
	* libc/stdlib/ldtoa.c: Fix comment typo.
	* libc/stdlib/div.c: Use @@ifnottex instead of @@ifinfo.
	* libc/stdlib/ldiv.c: Likewise.
	* libm/common/s_expm1.c: Likewise.
	* libm/common/s_ilogb.c: Hyphenate "floating-point".  Use "nonzero".
	* libm/common/s_infinity: Hyphenate "double- and single-precision".
	* libm/common/s_nan.c: Likewise.  Also correct the FUNCTION summary.
	* libm/common/s_nextafter.c: Fix typo.  Hyphenate "double-precision"
	and "floating-point".
	* libm/common/s_scalbn.c: Correct the FUNCTION summary.
	* libm/math/e_pow.c: Fix comment typo.
	* libm/math/math.tex: Hyphenate "single-precision" and "floating-point".
	* libm/math/s_asinh.c: Use @@ifnottex instead of @@ifinfo.
	* libm/math/s_atan.c: Likewise.
	* libm/math/s_frexp.c: Likewise.  Also use "nonzero".
	* libm/math/s_isnan.c: Hyphenate "single-precision" and
	"floating-point".  Use "nonzero".
	* libm/math/s_ldexp.c: Use @@ifnottex instead of @@ifinfo.
	* libm/math/w_acos.c: Likewise.
	* libm/math/w_acosh.c: Likewise.
	* libm/math/w_asin.c: Likewise.
	* libm/math/w_atan2.c: Likewise.
	* libm/math/w_atanh.c: Likewise.
	* libm/math/w_cosh.c: Likewise.
	* libm/math/w_exp.c: Likewise.
	* libm/math/w_exp2.c: Likewise.  Add missing @@end and missing @@tex
	version of 2^x in the description.
	* libm/math/w_fmod.c: Use @@ifnottex instead of @@ifinfo.
	* libm/math/w_gamma.c: Likewise.
	* libm/math/w_hypot.c: Likewise.
	* libm/math/w_j0.c: Likewise.
	* libm/math/w_sinh.c: Likewise.
	* libm/math/w_pow.c: Replace "exp1.0nt" with "exponent".
	* libm/mathfp/mathfp.tex: Hyphenate "single-precision" and
	"floating-point".
	* libm/mathfp/e_acosh.c: Use @@ifnottex instead of @@ifinfo.
	* libm/mathfp/e_atanh.c: Likewise.
	* libm/mathfp/e_hypot.c: Likewise.
	* libm/mathfp/er_lgamma.c: Likewise.
	* libm/mathfp/s_acos.c: Likewise.
	* libm/mathfp/s_asine.c: Likewise.
	* libm/mathfp/s_asinh.c: Likewise.
	* libm/mathfp/s_atan.c: Likewise.
	* libm/mathfp/s_atan2.c: Likewise.
	* libm/mathfp/s_atangent.c: Likewise.
	* libm/mathfp/s_cosh.c: Likewise.
	* libm/mathfp/s_exp.c: Likewise.
	* libm/mathfp/s_fmod.c: Likewise.
	* libm/mathfp/s_frexp.c: Likewise.  Also use "nonzero".
	* libm/mathfp/s_isnan.c: Hyphenate "single-precision" and
	"floating-point".  Use "nonzero".
	* libm/math/s_pow.c: Replace "exp1.0nt" with "exponent".
	* libm/mathfp/s_ldexp.c: Use @@ifnottex instead of @@ifinfo.
	* libm/mathfp/s_sineh.c: Likewise.
	* libm/mathfp/w_jn.c: Likewise.
@
text
@d208 2
a209 1
		apply to a pointer to a <<long>>. If an <<h>>
d228 3
d234 5
@


1.5
log
@
2003-08-22  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/include/sys/reent.h: Add _GLOBAL_REENT macro.
	* libc/stdio: Globally remove/replace all references to fp->_data.
	Replace with _REENT or _GLOBAL_REENT where appropriate.
	* libc/stdio/asprintf.c: Ditto.
	* libc/stdio/fclose.c: Ditto.
	* libc/stdio/fvwrite.c: Ditto.
	* libc/stdio/makebuf.c: Ditto.
	* libc/stdio/refill.c: Ditto.
	* libc/stdio/local.h: Ditto.
	* libc/stdio/setvbuf.c: Ditto.
	* libc/stdio/sscanf.c: Ditto.
	* libc/stdio/stdio.c: Ditto.
	* libc/stdio/ungetc.c: Ditto.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdio/vsscanf.c: Ditto.
	* libc/stdio/fopen.c: Ditto.  Also use _fseek_r in _fopen_r.
	* libc/stdio/vasprintf.c: Ditto.  Also call _vfprintf_r directly.
	* libc/stdio/vsnprintf.c: Ditto.
	* libc/stdio/vsprintf.c: Ditto.
	* libc/stdio/fcloseall.c(fcloseall): Use _GLOBAL_REENT macro
	instead of _REENT to walk file list.
	* libc/stdio/fflush.c: Ditto.
	* libc/stdio/fgetpos.c: Add reentrant version and have regular
	version call reentrant version with _REENT argument.
	* libc/stdio/fsetpos.c: Ditto.
	* libc/stdio/fseek.c: Ditto.
	* libc/stdio/fseeko.c: Ditto.
	* libc/stdio/ftell.c: Ditto.
	* libc/stdio/ftello.c: Ditto.
	* libc/stdio/freopen.c: Ditto.
	* libc/stdio/findfp.c: Use _GLOBAL_REENT pointer when adding
	new files to chain.  Also use _GLOBAL_REENT pointer for
	cleaning up.
	* libc/stdio/fiprintf.c: Reformatted to minimize duplicate code.
	* libc/stdio/siprintf.c: Ditto.
	* libc/stdio/iprintf.c: Ditto.
	* libc/stdio/fprintf.c: Ditto.
	* libc/stdio/printf.c: Ditto.
	* libc/stdio/snprintf.c: Call _vfprintf_r directly.
	* libc/stdio/sprintf.c: Ditto.
	* libc/stdio/vprintf.c: Ditto.  Also add _REENT_ONLY check.
	* libc/stdio/rewind.c: Call _fseek_r directly.
	* libc/stdio/tmpfile.c: Call _fopen_r and _remove_r directly.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Change _r routines to use
	data pointer.
	(get_arg): Add extra struct _reent pointer argument.
	* libc/stdio64/fgetpos64.c: Add _r versions, remove any reference
	to fp->_data.
	* libc/stdio64/fopen64.c: Ditto.
	* libc/stdio64/freopen64.c: Ditto.
	* libc/stdio64/fsetpos64.c: Ditto.
	* libc/stdio64/ftello64.c: Ditto.
	* libc/stdio64/local64.h: Ditto.
	* libc/stdio64/stdio64.c: Ditto.
	* libc/stdio64/fseeko64.c: Ditto plus use _fstat_r instead of
	_fstat64_r for the meantime.
@
text
@d253 1
a253 1
		a floating point number
d257 1
a257 1
		floating point number
d261 1
a261 1
		exponent; takes a floating point number
d266 1
a266 1
		printed only if necessary; takes a floating point number
d270 1
a270 1
		exponent is needed; takes a floating point number
@


1.4
log
@
2003-02-05  Jonathan Larmour  <jifl@@eCosCentric.com>

    * libc/stdio/vsprintf.c (vsprintf, _vsprintf_r): Set _file fd to
    -1 to be sure it cannot later match a valid file fd causing
    isatty() to return 1.
    * libc/stdio/asprintf.c (asprintf, _asprintf_r): Ditto.
    * libc/stdio/sprintf.c (sprintf, _sprintf_r): Ditto.
    * libc/stdio/vasprintf.c (vasprintf, _vasprintf_r): Ditto.
@
text
@a326 1
  f._data = ptr;
d333 1
a333 1
  ret = vfprintf (&f, fmt, ap);
a357 1
  f._data = _REENT;
d364 1
a364 1
  ret = vfprintf (&f, fmt, ap);
@


1.3
log
@
2003-01-07  Charles Wilson  <cwilson@@ece.gatech.edu>

        * libc/stdio/sprintf.c: fix typo
        * libc/stdio/vfprintf.c: fix typo
@
text
@d328 1
d360 1
@


1.2
log
@
2002-07-04  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/Makefile.am: Add asprintf.c and vasprintf.c.
        * libc/stdio/Makefile.in: Regenerated.
        * libc/stdio/asprintf.c: New file.
        * libc/stdio/vasprintf.c: Ditto.
        * libc/stdio/fvwrite.c: Add code to dynamically reallocate
        the buffer for asprintf support.
        * libc/stdio/sprintf.c: Add asprintf documentation.
        * libc/stdio/vfprintf.c: Add vasprintf documentation.
        * libc/include/stdio.h: Add new prototypes.
@
text
@d21 1
a21 1
        <<printf>>, <<fprintf>>, <<saprintf>>, <<sprintf>>, <<snprintf>>---format output
d27 1
a27 1
	saprintf
d39 1
a39 1
        int saprintf(char **<[strp]>, const char *<[format]> [, <[arg]>, ...]);
d52 1
a52 1
	int saprintf(<[strp]>, <[format]> [, <[arg]>, ...]);
d75 1
a75 1
        <<fprintf>>, <<saprintf>>, <<sprintf>> and <<snprintf>> are identical 
d78 1
a78 1
	<<saprintf>> stores the output in a dynamically allocated buffer,
d84 1
a84 1
	<<saprintf>>, <[strp]> points to a pointer to char which is filled
d285 1
a285 1
<<sprintf>> and <<saprintf>> return the number of bytes in the output string,
d289 1
a289 1
<<saprintf>> returns -1.  No error returns occur for <<sprintf>>.
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
        <<printf>>, <<fprintf>>, <<sprintf>>, <<snprintf>>---format output
d27 2
d39 1
d52 4
d75 16
a90 13
        <<fprintf>>, <<sprintf>> and <<snprintf>> are identical to <<printf>>,
        other than the destination of the formatted output: <<fprintf>> sends
        the output to a specified file <[fd]>, while <<sprintf>> stores the
        output in the specified char array <[str]> and <<snprintf>> limits
        number of characters written to <[str]> to at most <[size]> (including
        terminating <<0>>).  For <<sprintf>> and <<snprintf>>, the behavior is
        also undefined if the output <<*<[str]>>> overlaps with one of the
        arguments. <[format]> is a pointer to a charater string containing
        two types of objects: ordinary characters (other than <<%>>), which
        are copied unchanged to the output, and conversion
        specifications, each of which is introduced by <<%>>.
        (To include <<%>> in the output, use <<%%>> in the format string.)
        A conversion specification has the following form:
d285 1
a285 1
<<sprintf>> returns the number of bytes in the output string,
d288 2
a289 2
If an error occurs, <<printf>> and <<fprintf>> return <<EOF>>. No
error returns occur for <<sprintf>>.
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
