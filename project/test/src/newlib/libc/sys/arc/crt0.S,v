head	1.1;
access;
symbols
	cygwin-1_7_35-release:1.1
	cygwin-1_7_34-release:1.1
	newlib-2_2_0:1.1.0.16
	cygwin-1_7_33-release:1.1
	cygwin-1_7_32-release:1.1
	cygwin-1_7_31-release:1.1
	cygwin-1_7_30-release:1.1
	cygwin-1_7_29-release:1.1
	cygwin-1_7_28-release:1.1
	newlib-2_1_0:1.1
	cygwin-1_7_27-release:1.1
	cygwin-1_7_26-release:1.1
	cygwin-1_7_25-release:1.1
	cygwin-1_7_24-release:1.1
	cygwin-1_7_23-release:1.1
	cygwin-1_7_22-release:1.1
	cygwin-1_7_21-release:1.1
	cygwin-1_7_20-release:1.1
	cygwin-1_7_19-release:1.1
	cygwin-64bit-postmerge:1.1
	cygwin-64bit-premerge-branch:1.1.0.14
	cygwin-64bit-premerge:1.1
	cygwin-1_7_18-release:1.1
	newlib-2_0_0:1.1
	cygwin-1_7_17-release:1.1
	cygwin-64bit-branch:1.1.0.12
	cygwin-1_7_16-release:1.1
	cygwin-1_7_15-release:1.1
	cygwin-1_7_14_2-release:1.1
	cygwin-1_7_14-release:1.1
	cygwin-1_7_12-release:1.1
	cygwin-1_7_11-release:1.1
	cygwin-1_7_10-release:1.1
	newlib-1_20_0:1.1
	cygwin-1_7_9-release:1.1
	cygwin-1_7_8-release:1.1
	newlib-1_19_0:1.1
	cygwin-1_7_7-release:1.1
	cygwin-1_7_5-release:1.1
	cygwin-1_7_4-release:1.1
	cygwin-1_7_3-release:1.1
	cygwin-1_7_2-release:1.1
	newlib-1_18_0:1.1
	cygwin-1_7_1-release:1.1
	newlib-1_17_0-arc:1.1.0.10
	binutils-arc-20080908-branch:1.1.0.8
	binutils-arc-20080908-branchpoint:1.1
	newlib-1_17_0:1.1
	newlib-1_16_0:1.1
	newlib-1_15_0:1.1
	newlib-csl-coldfire-4_1-32:1.1
	newlib-csl-sourcerygxx-4_1-32:1.1
	newlib-csl-innovasic-fido-3_4_4-33:1.1
	newlib-csl-coldfire-4_1-30:1.1
	newlib-csl-sourcerygxx-4_1-30:1.1
	newlib-csl-coldfire-4_1-28:1.1
	newlib-csl-sourcerygxx-4_1-28:1.1
	newlib-csl-arm-2006q3-27:1.1
	newlib-csl-sourcerygxx-4_1-27:1.1
	newlib-csl-arm-2006q3-26:1.1
	newlib-csl-sourcerygxx-4_1-26:1.1
	newlib-csl-sourcerygxx-4_1-24:1.1
	newlib-csl-sourcerygxx-4_1-23:1.1
	newlib-csl-sourcerygxx-4_1-21:1.1
	newlib-csl-arm-2006q3-21:1.1
	newlib-csl-arm-2006q3-19:1.1
	newlib-csl-sourcerygxx-4_1-19:1.1
	newlib-csl-sourcerygxx-4_1-18:1.1
	newlib-csl-sourcerygxx-3_4_4-25:1.1
	newlib-csl-sourcerygxx-4_1-17:1.1
	cr-0x5f1:1.1.0.6
	newlib-csl-sourcerygxx-4_1-14:1.1
	newlib-csl-sourcerygxx-4_1-13:1.1
	newlib-csl-sourcerygxx-4_1-12:1.1
	newlib-csl-sourcerygxx-4_1-9:1.1
	newlib-csl-sourcerygxx-4_1-8:1.1
	newlib-csl-sourcerygxx-4_1-7:1.1
	newlib-csl-arm-2006q1-6:1.1
	newlib-csl-sourcerygxx-4_1-6:1.1
	newlib-csl-sourcerygxx-4_1-5:1.1
	newlib-csl-sourcerygxx-4_1-4:1.1
	newlib-autotools-branch:1.1.0.4
	newlib-csl-20060320-branch:1.1.0.2
	newlib-csl-20060320-branchpoint:1.1
	newlib-1_14_0:1.1
	newlib-csl-arm-2005-q1b:1.1
	newlib-csl-arm-2005-q1a:1.1
	newlib-1_13_0:1.1
	csl-arm-2004-q3:1.1
	csl-arm-2004-q1a:1.1
	csl-arm-2004-q1:1.1
	newlib-1_12_0:1.1
	csl-arm-2003-q4:1.1
	w32api-2_2:1.1
	mingw-runtime-2_4:1.1
	newlib-1_11_0:1.1
	cygnus_cvs_20020108_pre:1.1
	newlib-1_10_0:1.1;
locks; strict;
comment	@# @;


1.1
date	2001.01.19.01.25.13;	author jjohnstn;	state Exp;
branches
	1.1.10.1;
next	;

1.1.10.1
date	2009.09.10.01.29.09;	author amylaar;	state Exp;
branches;
next	;


desc
@@


1.1
log
@
2001-01-18  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/sys/arc/Makefile.am: New file.
        * libc/sys/arc/Makefile.in: Ditto.
        * libc/sys/arc/aclocal.m4: Ditto.
        * libc/sys/arc/configure: Ditto.
        * libc/sys/arc/configure.in: Ditto.
        * libc/sys/arc/crt0.S: Ditto.
        * libc/sys/arc/isatty.c: Ditto.
        * libc/sys/arc/mem-layout.c: Ditto.
        * libc/sys/arc/sbrk.c: Ditto.
        * libc/sys/arc/syscalls.c: Ditto.
        * libc/sys/arc/sys/syscall.h: Ditto.
@
text
@; ARC start up file
; In the absence of a custom linker script, go with something simple.
; We do not support passing arguments to "main", but this is an embedded
; system anyway.
;
; We call init/fini here without cpu prefixes because there is always
; only one .init/.fini section per image.

	.section .text
	.align 4

	.global	start
start:

	mov	sp,end		; Round "sp" up to page after "end".
	add	sp,sp,4095
	and	sp,sp,-4096

	ld	r8,[stack_size]	; Add stack size to "sp".
	add	sp,sp,r8

	st	sp,[sbrk_start]	; Initialize malloc heap.
	st	sp,[sbrk_loc]

	sub	sp,sp,16	; callee expects 16 bytes already "pushed".
	mov	fp,0		; Top of stack frame indicator.

	mov	r0,edata	; Zero bss.
	mov	r2,end
	sub	r2,r2,r0
	mov	r1,0

#ifdef __base__
	bl.nd	_memset
	bl.nd	init		; .init section entry point.
	mov	r0,%st(fini)	; .fini section entry point.
	bl.nd	_atexit
	mov	r0,0		; argc
	mov	r1,0		; argv
	bl.nd	_main
	bl.nd	_exit
#endif

#ifdef __host__
	bl.nd	_host_memset
	bl.nd	init		; .init section entry point.
	mov	r0,%st(fini)	; .fini section entry point.
	bl.nd	_host_atexit
	mov	r0,0		; argc
	mov	r1,0		; argv
	bl.nd	_host_main
	bl.nd	_host_exit
#endif

#ifdef __graphics__
	bl.nd	_graphics_memset
	bl.nd	init		; .init section entry point.
	mov	r0,%st(fini)	; .fini section entry point.
	bl.nd	_graphics_atexit
	mov	r0,0		; argc
	mov	r1,0		; argv
	bl.nd	_graphics_main
	bl.nd	_graphics_exit
#endif

#ifdef __audio__
	bl.nd	_audio_memset
	bl.nd	init		; .init section entry point.
	mov	r0,%st(fini)	; .fini section entry point.
	bl.nd	_audio_atexit
	mov	r0,0		; argc
	mov	r1,0		; argv
	bl.nd	_audio_main
	bl.nd	_audio_exit
#endif
@


1.1.10.1
log
@Support for ARCompact architecture.
@
text
@d1 7
a7 36
;; *******************************************************************************************************************
;; -----------------
;; ARC start up file
;; -----------------
;; The startup code for the ARC family of processors does the following before transferring control to user defined
;; _main label :
;;		1. Set sp to __stack_top (link time variable)
;;		2. Set fp to zero
;;		3. Zero out the bss section (for uninitialized globals)
;; After returning from main, the processor is halted and the pipeline is flushed out
;;
;; For Arctangent-A4, we do not support passing arguments to "main".
;; For subsequent processors, we expect arc in r0 and argv in r1.
;; These are saved in r13 / r14 during the initialization code.
;; *******************************************************************************************************************

	.file	"crt0.s"
	.extern main
	.text

	.global	__start
	.type	__start, @@function

#ifdef __A4__
#define mov_s mov

__start:
	mov	sp,@@__stack_top	; initialize stack pointer
	sub	sp,sp,16	; allocate expected call frame
				; it is not required for ARCompact, but is OK.

;; Zero out the bytes in the bss section
__zerobss:
	mov	%r2, @@__bss_start
	mov	%r1, @@_end
	sub	%r0, %r0, %r0	; use r0 as the zero value
d9 1
d11 31
a41 25
__zbss1:
	stb	%r0, [%r2]	; write zero to _bss
	add	%r2, %r2, 1	; increment r2
	sub.f	0, %r2, %r1	; subtract to compare
	nop			; clear pipeline
	blo	@@__zbss1		; branch if below

;; ifdef __A4__	
#else			

;; Startup code for the A5, ARC600 and ARC700 processors
;; -----------------------------------------------------
;; NOTE:  The following restrictions apply on zero overhead loops (other restrictions are not pertinent to this code)
;;	  -  loop end should be 4 instruction words away from the lp_count setting instruction
;;	  -  loop body should have at least two instruction words
__start:
	mov gp, @@__SDATA_BEGIN__
	mov_s %r2, @@__sbss_start		; r2 = start of the bss section
#if 1
	sub r3, @@_end, %r2		; r3 = size of the bss section in bytes
#ifdef __A5__
	asr	r3, r3
	asr.f lp_count, r3		; set up the loop counter register to the size (in words) of the bss section
#else
	asr.f lp_count, r3, 2		; set up the loop counter register to the size (in words) of the bss section
d43 10
a52 2
#else
	mov.f lp_count,(@@_end-@@__sbss_start)/4 ; bss size in words
a53 15
#if defined (__A5__) || defined (__A6__)
	lpnz @@.Lend_zbss		; loop to zero out the bss. Enter loop only if lp_count != 0
	add r3,pcl,20
	sr r3,[2]			; LP_END
	mov sp, @@__stack_top		; initialize stack pointer, and this instruction has 2 words
	mov_s r3,0
	st.ab r3,[%r2, 4]		; zero out the word
.Lend_zbss:
#else
	mov sp, @@__stack_top		; initialize stack pointer, and this instruction has 2 words
	mov_s r3,0
	lpnz @@.Lend_zbss		; loop to zero out the bss. Enter loop only if lp_count != 0
	st.ab r3,[%r2, 4]		; zero out the word
.Lend_zbss:
#endif	
d55 9
a63 1
;; ifdef __A4__
d66 9
a74 25
;; branch to main

/* Some  targets use the .init and .fini sections
   to create constructors and destructors, and for these
   targets we need to call the _init function and arrange
   for _fini to be called at program exit.  */
 	mov_s	r13, r0 
 	mov_s	r14, r1 
#if defined (_REENT_SMALL) || defined (__A4__)
#ifdef __A4__
 	mov	r0, %st(@@_fini)
#else 
 	mov_s	r0, @@_fini 
#endif	
 	bl	@@atexit
#else
	; calling atexit drags in malloc, so instead poke the function
	; address directly into the reent structure
	ld	r1,[gp,@@_impure_ptr@@sda]
 	mov_s	r0, @@_fini 
	add	r1,r1,0x14c	; &_GLOBAL_REENT->atexit0
	st	r1, [r1,-4]	; _GLOBAL_REENT->atexit
	st_s	r0, [r1,8]	; _GLOBAL_REENT->atexit0._fns[0]
	mov_s	r0, 1
	st_s	r0, [r1,4]	; _GLOBAL_REENT->atexit0._ind
a75 21
	bl	@@_init
	mov_s	r0, r13
	mov_s	r1, r14
	bl.d	@@main
	mov	fp, 0		; initialize frame pointer
	; r0 contains exit code
	; we used to jump to exit_halt here, but that is wrong:
	; we have to run destructors and other things registered with atexit.
	j	@@exit

	.global	_exit_halt
	.type	_exit_halt, @@function

_exit_halt:
	; r0 contains exit code
	flag	0x01
	nop
	nop
	nop
	b	@@_exit_halt
	nop
@

