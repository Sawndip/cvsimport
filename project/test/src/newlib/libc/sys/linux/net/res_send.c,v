head	1.2;
access;
symbols
	cygwin-1_7_35-release:1.2
	cygwin-1_7_34-release:1.2
	newlib-2_2_0:1.2.0.10
	cygwin-1_7_33-release:1.2
	cygwin-1_7_32-release:1.2
	cygwin-1_7_31-release:1.2
	cygwin-1_7_30-release:1.2
	cygwin-1_7_29-release:1.2
	cygwin-1_7_28-release:1.2
	newlib-2_1_0:1.2
	cygwin-1_7_27-release:1.2
	cygwin-1_7_26-release:1.2
	cygwin-1_7_25-release:1.2
	cygwin-1_7_24-release:1.2
	cygwin-1_7_23-release:1.2
	cygwin-1_7_22-release:1.2
	cygwin-1_7_21-release:1.2
	cygwin-1_7_20-release:1.2
	cygwin-1_7_19-release:1.2
	cygwin-64bit-postmerge:1.2
	cygwin-64bit-premerge-branch:1.2.0.8
	cygwin-64bit-premerge:1.2
	cygwin-1_7_18-release:1.2
	newlib-2_0_0:1.2
	cygwin-1_7_17-release:1.2
	cygwin-64bit-branch:1.2.0.6
	cygwin-1_7_16-release:1.2
	cygwin-1_7_15-release:1.2
	cygwin-1_7_14_2-release:1.2
	cygwin-1_7_14-release:1.2
	cygwin-1_7_12-release:1.2
	cygwin-1_7_11-release:1.2
	cygwin-1_7_10-release:1.2
	newlib-1_20_0:1.2
	cygwin-1_7_9-release:1.2
	cygwin-1_7_8-release:1.2
	newlib-1_19_0:1.2
	cygwin-1_7_7-release:1.2
	cygwin-1_7_5-release:1.2
	cygwin-1_7_4-release:1.2
	cygwin-1_7_3-release:1.2
	cygwin-1_7_2-release:1.2
	newlib-1_18_0:1.2
	cygwin-1_7_1-release:1.2
	newlib-1_17_0-arc:1.2.0.4
	binutils-arc-20080908-branch:1.2.0.2
	binutils-arc-20080908-branchpoint:1.2
	newlib-1_17_0:1.2
	newlib-1_16_0:1.1
	newlib-1_15_0:1.1
	newlib-csl-coldfire-4_1-32:1.1
	newlib-csl-sourcerygxx-4_1-32:1.1
	newlib-csl-innovasic-fido-3_4_4-33:1.1
	newlib-csl-coldfire-4_1-30:1.1
	newlib-csl-sourcerygxx-4_1-30:1.1
	newlib-csl-coldfire-4_1-28:1.1
	newlib-csl-sourcerygxx-4_1-28:1.1
	newlib-csl-arm-2006q3-27:1.1
	newlib-csl-sourcerygxx-4_1-27:1.1
	newlib-csl-arm-2006q3-26:1.1
	newlib-csl-sourcerygxx-4_1-26:1.1
	newlib-csl-sourcerygxx-4_1-24:1.1
	newlib-csl-sourcerygxx-4_1-23:1.1
	newlib-csl-sourcerygxx-4_1-21:1.1
	newlib-csl-arm-2006q3-21:1.1
	newlib-csl-arm-2006q3-19:1.1
	newlib-csl-sourcerygxx-4_1-19:1.1
	newlib-csl-sourcerygxx-4_1-18:1.1
	newlib-csl-sourcerygxx-3_4_4-25:1.1
	newlib-csl-sourcerygxx-4_1-17:1.1
	cr-0x5f1:1.1.0.6
	newlib-csl-sourcerygxx-4_1-14:1.1
	newlib-csl-sourcerygxx-4_1-13:1.1
	newlib-csl-sourcerygxx-4_1-12:1.1
	newlib-csl-sourcerygxx-4_1-9:1.1
	newlib-csl-sourcerygxx-4_1-8:1.1
	newlib-csl-sourcerygxx-4_1-7:1.1
	newlib-csl-arm-2006q1-6:1.1
	newlib-csl-sourcerygxx-4_1-6:1.1
	newlib-csl-sourcerygxx-4_1-5:1.1
	newlib-csl-sourcerygxx-4_1-4:1.1
	newlib-autotools-branch:1.1.0.4
	newlib-csl-20060320-branch:1.1.0.2
	newlib-csl-20060320-branchpoint:1.1
	newlib-1_14_0:1.1
	newlib-csl-arm-2005-q1b:1.1
	newlib-csl-arm-2005-q1a:1.1
	newlib-1_13_0:1.1
	csl-arm-2004-q3:1.1
	csl-arm-2004-q1a:1.1
	csl-arm-2004-q1:1.1
	newlib-1_12_0:1.1
	csl-arm-2003-q4:1.1;
locks; strict;
comment	@ * @;


1.2
date	2008.05.22.21.30.28;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.28.22.04.40;	author jjohnstn;	state Exp;
branches;
next	;


desc
@@


1.2
log
@
2008-05-22  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/include/sys/reent.h: Add _h_errno field.
	* libc/sys/linux/libc-symbols.h: Add default stubs for new libc macros
	now used in net directory.
	* libc/sys/linux/bits/libc-lock.h: Always define _IO_MTSAFE_IO.
	* libc/sys/linux/include/hesiod.h: Add needed macros for new code
	in net directory.
	* libc/sys/linux/include/netdb.h: Ditto.
	* libc/sys/linux/include/resolv.h: Ditto.
	* libc/sys/linux/include/stdint.h: Ditto.
	* libc/sys/linux/include/arpa/nameser.h: Ditto.
	* libc/sys/linux/include/net/ethernet.h: Ditto.
	* libc/sys/linux/include/net/if_ppp.h: Ditto.
	* libc/sys/linux/include/netinet/if_ether.h: Ditto.
	* libc/sys/linux/machine/i386/get_clockfreq.c: Remove static memmem.
	* libc/sys/linux/machine/i386/include/endian.h: Protect macros with
	flags to avoid duplicate definition.
	* libc/sys/linux/machine/i386/include/param.h: Ditto.
	* libc/sys/linux/net/Makefile.am: Modified to account for removed and
	added files.
	* libc/sys/linux/net/Makefile.in: Regenerated.
	* libc/sys/linux/net/base64.c: Replaced with glibc version of code.
	* libc/sys/linux/net/getaddrinfo.c: Ditto.
	* libc/sys/linux/net/getnameinfo.c: Ditto.
	* libc/sys/linux/net/getproto.c: Ditto.
	* libc/sys/linux/net/getservent.c: Ditto.
	* libc/sys/linux/net/inet_netof.c: Ditto.
	* libc/sys/linux/net/inet_lnaof.c: Ditto.
	* libc/sys/linux/net/ns_name.c: Ditto.
	* libc/sys/linux/net/ns_netint.c: Ditto.
	* libc/sys/linux/net/inet_ntoa.c: Ditto.
	* libc/sys/linux/net/ns_parse.c: Ditto.
	* libc/sys/linux/net/ns_print.c: Ditto.
	* libc/sys/linux/net/ns_ttl.c: Ditto.
	* libc/sys/linux/net/nsap_addr.c: Ditto.
	* libc/sys/linux/net/rcmd.c: Ditto.
	* libc/sys/linux/net/res_comp.c: Ditto.
	* libc/sys/linux/net/res_data.c: Ditto.
	* libc/sys/linux/net/res_debug.c: Ditto.
	* libc/sys/linux/net/res_init.c: Ditto.
	* libc/sys/linux/net/res_mkquery.c: Ditto.
	* libc/sys/linux/net/res_query.c: Ditto.
	* libc/sys/linux/net/res_send.c: Ditto.
	* libc/sys/linux/net/send.c: Ditto.
	* libc/sys/linux/stdlib/collate.c: Ditto.
	* libc/sys/linux/sys/ioctl.h: Ditto.
	* libc/sys/linux/sys/socket.h: Ditto.
	* libc/sys/linux/sys/unistd.h: Ditto.
	* libc/sys/linux/iconv/iconvconfig.c: Removed either because no longer
	used or because licensing includes advertising clause that cannot be
	ignored.
	* libc/sys/linux/iconv/strtab.c: Ditto.
	* libc/sys/linux/include/libc_private.h: Ditto.
	* libc/sys/linux/include/nsswitch.h: Ditto.
	* libc/sys/linux/include/net/if_atm.h: Ditto.
	* libc/sys/linux/include/net/if_media.h: Ditto.
	* libc/sys/linux/include/net/if_pppvar.h: Ditto.
	* libc/sys/linux/include/netinet/if_atm.h: Ditto.
	* libc/sys/linux/include/netinet/ip_flow.h: Ditto.
	* libc/sys/linux/intl/locale.alias: Ditto.
	* libc/sys/linux/net/addr2ascii.3: Ditto.
	* libc/sys/linux/net/bindresvport.c: Ditto.
	* libc/sys/linux/net/byteorder.3: Ditto.
	* libc/sys/linux/net/res_config.h: Ditto.
	* libc/sys/linux/net/ether_addr.c: Ditto.
	* libc/sys/linux/net/ethers.3: Ditto.
	* libc/sys/linux/net/getaddrinfo.3: Ditto.
	* libc/sys/linux/net/gethostbydns.c: Ditto.
	* libc/sys/linux/net/gethostbyht.c: Ditto.
	* libc/sys/linux/net/gethostbyname.3: Ditto.
	* libc/sys/linux/net/gethostbynis.c: Ditto.
	* libc/sys/linux/net/gethostnamadr.c: Ditto.
	* libc/sys/linux/net/getifaddrs.3: Ditto.
	* libc/sys/linux/net/getifaddrs.c: Ditto.
	* libc/sys/linux/net/getipnodebyname.3: Ditto.
	* libc/sys/linux/net/getnameinfo.3: Ditto.
	* libc/sys/linux/net/getnetbydns.c: Ditto.
	* libc/sys/linux/net/getnetbyht.c: Ditto.
	* libc/sys/linux/net/getnetbynis.c: Ditto.
	* libc/sys/linux/net/getnetent.3: Ditto.
	* libc/sys/linux/net/getnetnamadr.c: Ditto.
	* libc/sys/linux/net/getprotoent.3: Ditto.
	* libc/sys/linux/net/getprotoent.c: Ditto.
	* libc/sys/linux/net/getprotoname.c: Ditto.
	* libc/sys/linux/net/getservbyname.c: Ditto.
	* libc/sys/linux/net/getservbyport.c: Ditto.
	* libc/sys/linux/net/getservent.3: Ditto.
	* libc/sys/linux/net/herror.c: Ditto.
	* libc/sys/linux/net/hesiod.3: Ditto.
	* libc/sys/linux/net/hesiod.c: Ditto.
	* libc/sys/linux/net/if_indextoname.3: Ditto.
	* libc/sys/linux/net/inet.3: Ditto.
	* libc/sys/linux/net/inet6_option_space.3: Ditto.
	* libc/sys/linux/net/inet6_rthdr_space.3: Ditto.
	* libc/sys/linux/net/inet_makeaddr.c: Ditto.
	* libc/sys/linux/net/inet_net.3: Ditto.
	* libc/sys/linux/net/inet_network.c: Ditto.
	* libc/sys/linux/net/innetgr-stub.c: Ditto.
	* libc/sys/linux/net/ip6opt.c: Ditto.
	* libc/sys/linux/net/iso_addr.3: Ditto.
	* libc/sys/linux/net/iso_addr.c: Ditto.
	* libc/sys/linux/net/linkaddr.3: Ditto.
	* libc/sys/linux/net/linkaddr.c: Ditto.
	* libc/sys/linux/net/map_v4v6.c: Ditto.
	* libc/sys/linux/net/name6.c: Ditto.
	* libc/sys/linux/net/namespace.h: Ditto.
	* libc/sys/linux/net/ns.3: Ditto.
	* libc/sys/linux/net/ns_addr.c: Ditto.
	* libc/sys/linux/net/ns_ntoa.c: Ditto.
	* libc/sys/linux/net/nsdispatch.3: Ditto.
	* libc/sys/linux/net/nsdispatch.c: Ditto.
	* libc/sys/linux/net/nslexer.c: Ditto.
	* libc/sys/linux/net/nslexer.l: Ditto.
	* libc/sys/linux/net/nsparser.c: Ditto.
	* libc/sys/linux/net/nsparser.h: Ditto.
	* libc/sys/linux/net/nsparser.y: Ditto.
	* libc/sys/linux/net/rcmd.3: Ditto.
	* libc/sys/linux/net/rcmdsh.3: Ditto.
	* libc/sys/linux/net/res_mkupdate.c: Ditto.
	* libc/sys/linux/net/res_update.c: Ditto.
	* libc/sys/linux/net/resolver.3: Ditto.
	* libc/sys/linux/net/rthdr.c: Ditto.
	* libc/sys/linux/net/vars.c: Ditto.
	* libc/sys/linux/shlib-compat.h: New file.
	* libc/sys/linux/machine/i386/atomic.h: Ditto.
	* libc/sys/linux/net/XXX-lookup.c: Ditto.
	* libc/sys/linux/net/alias-lookup.c: Ditto.
	* libc/sys/linux/net/res_libc.c: Ditto.
	* libc/sys/linux/net/aliases.h: Ditto.
	* libc/sys/linux/net/check_pf.c: Ditto.
	* libc/sys/linux/net/databases.def: Ditto.
	* libc/sys/linux/net/digits_dots.c: Ditto.
	* libc/sys/linux/net/ether_aton.c: Ditto.
	* libc/sys/linux/net/ether_aton_r.c: Ditto.
	* libc/sys/linux/net/ether_hton.c: Ditto.
	* libc/sys/linux/net/ether_line.c: Ditto.
	* libc/sys/linux/net/ether_ntoa.c: Ditto.
	* libc/sys/linux/net/ether_ntoa_r.c: Ditto.
	* libc/sys/linux/net/ether_ntoh.c: Ditto.
	* libc/sys/linux/net/etherent.h: Ditto.
	* libc/sys/linux/net/ethers-lookup.c: Ditto.
	* libc/sys/linux/net/function.def: Ditto.
	* libc/sys/linux/net/getXXbyYY.c: Ditto.
	* libc/sys/linux/net/getXXbyYY_r.c: Ditto.
	* libc/sys/linux/net/getXXent.c: Ditto.
	* libc/sys/linux/net/getXXent_r.c: Ditto.
	* libc/sys/linux/net/getaliasent.c: Ditto.
	* libc/sys/linux/net/getaliasent_r.c: Ditto.
	* libc/sys/linux/net/getaliasname.c: Ditto.
	* libc/sys/linux/net/getaliasname_r.c: Ditto.
	* libc/sys/linux/net/gethstbyad.c: Ditto.
	* libc/sys/linux/net/gethstbyad_r.c: Ditto.
	* libc/sys/linux/net/gethstbynm.c: Ditto.
	* libc/sys/linux/net/gethstbynm2.c: Ditto.
	* libc/sys/linux/net/gethstbynm2_r.c: Ditto.
	* libc/sys/linux/net/gethstbynm_r.c: Ditto.
	* libc/sys/linux/net/gethstent.c: Ditto.
	* libc/sys/linux/net/gethstent_r.c: Ditto.
	* libc/sys/linux/net/getnetbyad.c: Ditto.
	* libc/sys/linux/net/getnetbyad_r.c: Ditto.
	* libc/sys/linux/net/getnetbynm.c: Ditto.
	* libc/sys/linux/net/getnetbynm_r.c: Ditto.
	* libc/sys/linux/net/getnetent.c: Ditto.
	* libc/sys/linux/net/getnetent_r.c: Ditto.
	* libc/sys/linux/net/getnetgrent.c: Ditto.
	* libc/sys/linux/net/getnetgrent_r.c: Ditto.
	* libc/sys/linux/net/getnssent.c: Ditto.
	* libc/sys/linux/net/getnssent_r.c: Ditto.
	* libc/sys/linux/net/getproto_r.c: Ditto.
	* libc/sys/linux/net/getprtent.c: Ditto.
	* libc/sys/linux/net/getprtent_r.c: Ditto.
	* libc/sys/linux/net/getprtname.c: Ditto.
	* libc/sys/linux/net/getprtname_r.c: Ditto.
	* libc/sys/linux/net/getrpcbyname.c: Ditto.
	* libc/sys/linux/net/getrpcbyname_r.c: Ditto.
	* libc/sys/linux/net/getrpcbynumber.c: Ditto.
	* libc/sys/linux/net/getrpcbynumber_r.c: Ditto.
	* libc/sys/linux/net/getrpcent.c: Ditto.
	* libc/sys/linux/net/getrpcent_r.c: Ditto.
	* libc/sys/linux/net/getservent_r.c: Ditto.
	* libc/sys/linux/net/getsrvbynm.c: Ditto.
	* libc/sys/linux/net/getsrvbynm_r.c: Ditto.
	* libc/sys/linux/net/getsrvbypt.c: Ditto.
	* libc/sys/linux/net/getsrvbypt_r.c: Ditto.
	* libc/sys/linux/net/grp-lookup.c: Ditto.
	* libc/sys/linux/net/herrno.c: Ditto.
	* libc/sys/linux/net/hosts-lookup.c: Ditto.
	* libc/sys/linux/net/ifaddrs.h: Ditto.
	* libc/sys/linux/net/ifreq.c: Ditto.
	* libc/sys/linux/net/ifreq.h: Ditto.
	* libc/sys/linux/net/in6_addr.c: Ditto.
	* libc/sys/linux/net/inet6_option.c: Ditto.
	* libc/sys/linux/net/inet_mkadr.c: Ditto.
	* libc/sys/linux/net/inet_net.c: Ditto.
	* libc/sys/linux/net/key-lookup.c: Ditto.
	* libc/sys/linux/net/local.h: Ditto.
	* libc/sys/linux/net/netgroup.h: Ditto.
	* libc/sys/linux/net/netgrp-lookup.c: Ditto.
	* libc/sys/linux/net/network-lookup.c: Ditto.
	* libc/sys/linux/net/not-cancel.h: Ditto.
	* libc/sys/linux/net/ns_samedomain.c: Ditto.
	* libc/sys/linux/net/nscd-types.h: Ditto.
	* libc/sys/linux/net/nss.h: Ditto.
	* libc/sys/linux/net/nsswitch.c: Ditto.
	* libc/sys/linux/net/nsswitch.h: Ditto.
	* libc/sys/linux/net/opensock.c: Ditto.
	* libc/sys/linux/net/proto-lookup.c: Ditto.
	* libc/sys/linux/net/pwd-lookup.c: Ditto.
	* libc/sys/linux/net/res_debug.h: Ditto.
	* libc/sys/linux/net/res_hconf.c: Ditto.
	* libc/sys/linux/net/res_hconf.h: Ditto.
	* libc/sys/linux/net/rexec.c: Ditto.
	* libc/sys/linux/net/rpc-lookup.c: Ditto.
	* libc/sys/linux/net/ruserpass.c: Ditto.
	* libc/sys/linux/net/service-lookup.c: Ditto.
	* libc/sys/linux/net/spwd-lookup.c: Ditto.
	* libc/sys/linux/net/nscd/nscd-client.h: Ditto.
	* libc/sys/linux/net/nscd/nscd_proto.h: Ditto.
@
text
@/*
 * Copyright (c) 1985, 1989, 1993
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/*
 * Portions Copyright (c) 1996-1999 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static const char sccsid[] = "@@(#)res_send.c	8.1 (Berkeley) 6/4/93";
static const char rcsid[] = "$BINDId: res_send.c,v 8.38 2000/03/30 20:16:51 vixie Exp $";
#endif /* LIBC_SCCS and not lint */

#define s6_addr32 __u6_addr.__u6_addr32
/*
 * Send query to name server and wait for reply.
 */

#include <assert.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/poll.h>

#include <netinet/in.h>
#include <arpa/nameser.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>

#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <resolv.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "libc-symbols.h"

#if PACKETSZ > 65536
#define MAXPACKET       PACKETSZ
#else
#define MAXPACKET       65536
#endif


/* From ev_streams.c.  */

static inline void
__attribute ((always_inline))
evConsIovec(void *buf, size_t cnt, struct iovec *vec) {
	memset(vec, 0xf5, sizeof (*vec));
	vec->iov_base = buf;
	vec->iov_len = cnt;
}

/* From ev_timers.c.  */

#define BILLION 1000000000

static inline void
evConsTime(struct timespec *res, time_t sec, long nsec) {
	res->tv_sec = sec;
	res->tv_nsec = nsec;
}

static inline void
evAddTime(struct timespec *res, const struct timespec *addend1,
	  const struct timespec *addend2) {
	res->tv_sec = addend1->tv_sec + addend2->tv_sec;
	res->tv_nsec = addend1->tv_nsec + addend2->tv_nsec;
	if (res->tv_nsec >= BILLION) {
		res->tv_sec++;
		res->tv_nsec -= BILLION;
	}
}

static inline void
evSubTime(struct timespec *res, const struct timespec *minuend,
	  const struct timespec *subtrahend) {
       res->tv_sec = minuend->tv_sec - subtrahend->tv_sec;
	if (minuend->tv_nsec >= subtrahend->tv_nsec)
		res->tv_nsec = minuend->tv_nsec - subtrahend->tv_nsec;
	else {
		res->tv_nsec = (BILLION
				- subtrahend->tv_nsec + minuend->tv_nsec);
		res->tv_sec--;
	}
}

static inline int
evCmpTime(struct timespec a, struct timespec b) {
	long x = a.tv_sec - b.tv_sec;

	if (x == 0L)
		x = a.tv_nsec - b.tv_nsec;
	return (x < 0L ? (-1) : x > 0L ? (1) : (0));
}

static inline void
evNowTime(struct timespec *res) {
	struct timeval now;

	if (gettimeofday(&now, NULL) < 0)
		evConsTime(res, 0, 0);
	else
		TIMEVAL_TO_TIMESPEC (&now, res);
}


/* Options.  Leave them on. */
/* #undef DEBUG */
#include "res_debug.h"

#define EXT(res) ((res)->_u._ext)

/* Forward. */

static int		send_vc(res_state, const u_char *, int,
				u_char **, int *, int *, int, u_char **);
static int		send_dg(res_state, const u_char *, int,
				u_char **, int *, int *, int,
				int *, int *, u_char **);
#ifdef DEBUG
static void		Aerror(const res_state, FILE *, const char *, int,
			       const struct sockaddr *);
static void		Perror(const res_state, FILE *, const char *, int);
#endif
static int		sock_eq(struct sockaddr_in6 *, struct sockaddr_in6 *);

/* Reachover. */

static void convaddr4to6(struct sockaddr_in6 *sa);
void res_pquery(const res_state, const u_char *, int, FILE *);

/* Public. */

/* int
 * res_isourserver(ina)
 *	looks up "ina" in _res.ns_addr_list[]
 * returns:
 *	0  : not found
 *	>0 : found
 * author:
 *	paul vixie, 29may94
 */
int
res_ourserver_p(const res_state statp, const struct sockaddr_in6 *inp)
{
	int ns;

        if (inp->sin6_family == AF_INET) {
            struct sockaddr_in *in4p = (struct sockaddr_in *) inp;
	    in_port_t port = in4p->sin_port;
	    in_addr_t addr = in4p->sin_addr.s_addr;

            for (ns = 0;  ns < MAXNS;  ns++) {
                const struct sockaddr_in *srv =
		    (struct sockaddr_in *)EXT(statp).nsaddrs[ns];

                if ((srv != NULL) && (srv->sin_family == AF_INET) &&
                    (srv->sin_port == port) &&
                    (srv->sin_addr.s_addr == INADDR_ANY ||
                     srv->sin_addr.s_addr == addr))
                    return (1);
            }
        } else if (inp->sin6_family == AF_INET6) {
            for (ns = 0;  ns < MAXNS;  ns++) {
                const struct sockaddr_in6 *srv = EXT(statp).nsaddrs[ns];
                if ((srv != NULL) && (srv->sin6_family == AF_INET6) &&
                    (srv->sin6_port == inp->sin6_port) &&
                    !(memcmp(&srv->sin6_addr, &in6addr_any,
                             sizeof (struct in6_addr)) &&
                      memcmp(&srv->sin6_addr, &inp->sin6_addr,
                             sizeof (struct in6_addr))))
                    return (1);
            }
        }
	return (0);
}

/* int
 * res_nameinquery(name, type, class, buf, eom)
 *	look for (name,type,class) in the query section of packet (buf,eom)
 * requires:
 *	buf + HFIXEDSZ <= eom
 * returns:
 *	-1 : format error
 *	0  : not found
 *	>0 : found
 * author:
 *	paul vixie, 29may94
 */
int
res_nameinquery(const char *name, int type, int class,
		const u_char *buf, const u_char *eom)
{
	const u_char *cp = buf + HFIXEDSZ;
	int qdcount = ntohs(((HEADER*)buf)->qdcount);

	while (qdcount-- > 0) {
		char tname[MAXDNAME+1];
		int n, ttype, tclass;

		n = dn_expand(buf, eom, cp, tname, sizeof tname);
		if (n < 0)
			return (-1);
		cp += n;
		if (cp + 2 * INT16SZ > eom)
			return (-1);
		ttype = ns_get16(cp); cp += INT16SZ;
		tclass = ns_get16(cp); cp += INT16SZ;
		if (ttype == type && tclass == class &&
		    ns_samename(tname, name) == 1)
			return (1);
	}
	return (0);
}
libresolv_hidden_def (res_nameinquery)

/* int
 * res_queriesmatch(buf1, eom1, buf2, eom2)
 *	is there a 1:1 mapping of (name,type,class)
 *	in (buf1,eom1) and (buf2,eom2)?
 * returns:
 *	-1 : format error
 *	0  : not a 1:1 mapping
 *	>0 : is a 1:1 mapping
 * author:
 *	paul vixie, 29may94
 */
int
res_queriesmatch(const u_char *buf1, const u_char *eom1,
		 const u_char *buf2, const u_char *eom2)
{
	const u_char *cp = buf1 + HFIXEDSZ;
	int qdcount = ntohs(((HEADER*)buf1)->qdcount);

	if (buf1 + HFIXEDSZ > eom1 || buf2 + HFIXEDSZ > eom2)
		return (-1);

	/*
	 * Only header section present in replies to
	 * dynamic update packets.
	 */
	if ((((HEADER *)buf1)->opcode == ns_o_update) &&
	    (((HEADER *)buf2)->opcode == ns_o_update))
		return (1);

	if (qdcount != ntohs(((HEADER*)buf2)->qdcount))
		return (0);
	while (qdcount-- > 0) {
		char tname[MAXDNAME+1];
		int n, ttype, tclass;

		n = dn_expand(buf1, eom1, cp, tname, sizeof tname);
		if (n < 0)
			return (-1);
		cp += n;
		if (cp + 2 * INT16SZ > eom1)
			return (-1);
		ttype = ns_get16(cp);	cp += INT16SZ;
		tclass = ns_get16(cp); cp += INT16SZ;
		if (!res_nameinquery(tname, ttype, tclass, buf2, eom2))
			return (0);
	}
	return (1);
}
libresolv_hidden_def (res_queriesmatch)

int
__libc_res_nsend(res_state statp, const u_char *buf, int buflen,
		 u_char *ans, int anssiz, u_char **ansp)
{
	int gotsomewhere, terrno, try, v_circuit, resplen, ns, n;

	if (statp->nscount == 0) {
		__set_errno (ESRCH);
		return (-1);
	}

	if (anssiz < HFIXEDSZ) {
		__set_errno (EINVAL);
		return (-1);
	}

	if ((statp->qhook || statp->rhook) && anssiz < MAXPACKET && ansp) {
		u_char *buf = malloc (MAXPACKET);
		if (buf == NULL)
			return (-1);
		memcpy (buf, ans, HFIXEDSZ);
		*ansp = buf;
		ans = buf;
		anssiz = MAXPACKET;
	}

	DprintQ((statp->options & RES_DEBUG) || (statp->pfcode & RES_PRF_QUERY),
		(stdout, ";; res_send()\n"), buf, buflen);
	v_circuit = (statp->options & RES_USEVC) || buflen > PACKETSZ;
	gotsomewhere = 0;
	terrno = ETIMEDOUT;

	/*
	 * If the ns_addr_list in the resolver context has changed, then
	 * invalidate our cached copy and the associated timing data.
	 */
	if (EXT(statp).nsinit) {
		int needclose = 0;

		if (EXT(statp).nscount != statp->nscount)
			needclose++;
		else
			for (ns = 0; ns < MAXNS; ns++) {
				unsigned int map = EXT(statp).nsmap[ns];
				if (map < MAXNS
				    && !sock_eq((struct sockaddr_in6 *)
						&statp->nsaddr_list[map],
						EXT(statp).nsaddrs[ns]))
				{
					needclose++;
					break;
				}
			}
		if (needclose)
			res_nclose(statp);
	}

	/*
	 * Maybe initialize our private copy of the ns_addr_list.
	 */
	if (EXT(statp).nsinit == 0) {
		unsigned char map[MAXNS];

		memset (map, MAXNS, sizeof (map));
		for (n = 0; n < MAXNS; n++) {
			ns = EXT(statp).nsmap[n];
			if (ns < statp->nscount)
				map[ns] = n;
			else if (ns < MAXNS) {
				free(EXT(statp).nsaddrs[n]);
				EXT(statp).nsaddrs[n] = NULL;
				EXT(statp).nsmap[n] = MAXNS;
			}
		}
		n = statp->nscount;
		if (statp->nscount > EXT(statp).nscount)
			for (n = EXT(statp).nscount, ns = 0;
			     n < statp->nscount; n++) {
				while (ns < MAXNS
				       && EXT(statp).nsmap[ns] != MAXNS)
					ns++;
				if (ns == MAXNS)
					break;
				EXT(statp).nsmap[ns] = n;
				map[n] = ns++;
			}
		EXT(statp).nscount = n;
		for (ns = 0; ns < EXT(statp).nscount; ns++) {
			n = map[ns];
			if (EXT(statp).nsaddrs[n] == NULL)
				EXT(statp).nsaddrs[n] =
				    malloc(sizeof (struct sockaddr_in6));
			if (EXT(statp).nsaddrs[n] != NULL) {
				memcpy(EXT(statp).nsaddrs[n],
				       &statp->nsaddr_list[ns],
				       sizeof (struct sockaddr_in));
				EXT(statp).nssocks[n] = -1;
				n++;
			}
		}
		EXT(statp).nsinit = 1;
	}

	/*
	 * Some resolvers want to even out the load on their nameservers.
	 * Note that RES_BLAST overrides RES_ROTATE.
	 */
	if ((statp->options & RES_ROTATE) != 0 &&
	    (statp->options & RES_BLAST) == 0) {
		struct sockaddr_in6 *ina;
		unsigned int map;

		n = 0;
		while (n < MAXNS && EXT(statp).nsmap[n] == MAXNS)
			n++;
		if (n < MAXNS) {
			ina = EXT(statp).nsaddrs[n];
			map = EXT(statp).nsmap[n];
			for (;;) {
				ns = n + 1;
				while (ns < MAXNS
				       && EXT(statp).nsmap[ns] == MAXNS)
					ns++;
				if (ns == MAXNS)
					break;
				EXT(statp).nsaddrs[n] = EXT(statp).nsaddrs[ns];
				EXT(statp).nsmap[n] = EXT(statp).nsmap[ns];
				n = ns;
			}
			EXT(statp).nsaddrs[n] = ina;
			EXT(statp).nsmap[n] = map;
		}
	}

	/*
	 * Send request, RETRY times, or until successful.
	 */
	for (try = 0; try < statp->retry; try++) {
	    for (ns = 0; ns < MAXNS; ns++)
	    {
		struct sockaddr_in6 *nsap = EXT(statp).nsaddrs[ns];

		if (nsap == NULL)
			goto next_ns;
 same_ns:
		if (statp->qhook) {
			int done = 0, loops = 0;

			do {
				res_sendhookact act;

				struct sockaddr_in *nsap4;
				nsap4 = (struct sockaddr_in *) nsap;
				act = (*statp->qhook)(&nsap4, &buf, &buflen,
						      ans, anssiz, &resplen);
				nsap = (struct sockaddr_in6 *) nsap4;
				switch (act) {
				case res_goahead:
					done = 1;
					break;
				case res_nextns:
					res_nclose(statp);
					goto next_ns;
				case res_done:
					return (resplen);
				case res_modified:
					/* give the hook another try */
					if (++loops < 42) /*doug adams*/
						break;
					/*FALLTHROUGH*/
				case res_error:
					/*FALLTHROUGH*/
				default:
					return (-1);
				}
			} while (!done);
		}

#ifdef DEBUG
		char tmpbuf[40];
#endif
		Dprint(statp->options & RES_DEBUG,
		       (stdout, ";; Querying server (# %d) address = %s\n",
			ns + 1, inet_ntop(AF_INET6, &nsap->sin6_addr,
					  tmpbuf, sizeof (tmpbuf))));

		if (v_circuit) {
			/* Use VC; at most one attempt per server. */
			try = statp->retry;
			n = send_vc(statp, buf, buflen, &ans, &anssiz, &terrno,
				    ns, ansp);
			if (n < 0)
				return (-1);
			if (n == 0)
				goto next_ns;
			resplen = n;
		} else {
			/* Use datagrams. */
			n = send_dg(statp, buf, buflen, &ans, &anssiz, &terrno,
				    ns, &v_circuit, &gotsomewhere, ansp);
			if (n < 0)
				return (-1);
			if (n == 0)
				goto next_ns;
			if (v_circuit)
				goto same_ns;
			resplen = n;
		}

		Dprint((statp->options & RES_DEBUG) ||
		       ((statp->pfcode & RES_PRF_REPLY) &&
			(statp->pfcode & RES_PRF_HEAD1)),
		       (stdout, ";; got answer:\n"));

		DprintQ((statp->options & RES_DEBUG) ||
			(statp->pfcode & RES_PRF_REPLY),
			(stdout, "%s", ""),
			ans, (resplen > anssiz) ? anssiz : resplen);

		/*
		 * If we have temporarily opened a virtual circuit,
		 * or if we haven't been asked to keep a socket open,
		 * close the socket.
		 */
		if ((v_circuit && (statp->options & RES_USEVC) == 0) ||
		    (statp->options & RES_STAYOPEN) == 0) {
			res_nclose(statp);
		}
		if (statp->rhook) {
			int done = 0, loops = 0;

			do {
				res_sendhookact act;

				act = (*statp->rhook)((struct sockaddr_in *)
						      nsap, buf, buflen,
						      ans, anssiz, &resplen);
				switch (act) {
				case res_goahead:
				case res_done:
					done = 1;
					break;
				case res_nextns:
					res_nclose(statp);
					goto next_ns;
				case res_modified:
					/* give the hook another try */
					if (++loops < 42) /*doug adams*/
						break;
					/*FALLTHROUGH*/
				case res_error:
					/*FALLTHROUGH*/
				default:
					return (-1);
				}
			} while (!done);

		}
		return (resplen);
 next_ns: ;
	   } /*foreach ns*/
	} /*foreach retry*/
	res_nclose(statp);
	if (!v_circuit) {
		if (!gotsomewhere)
			__set_errno (ECONNREFUSED);	/* no nameservers found */
		else
			__set_errno (ETIMEDOUT);	/* no answer obtained */
	} else
		__set_errno (terrno);
	return (-1);
}

int
res_nsend(res_state statp,
	  const u_char *buf, int buflen, u_char *ans, int anssiz)
{
	return __libc_res_nsend(statp, buf, buflen, ans, anssiz, NULL);
}
libresolv_hidden_def (res_nsend)

/* Private */

static int
send_vc(res_state statp,
	const u_char *buf, int buflen, u_char **ansp, int *anssizp,
	int *terrno, int ns, u_char **anscp)
{
	const HEADER *hp = (HEADER *) buf;
	u_char *ans = *ansp;
	int anssiz = *anssizp;
	HEADER *anhp = (HEADER *) ans;
	struct sockaddr_in6 *nsap = EXT(statp).nsaddrs[ns];
	int truncating, connreset, resplen, n;
	struct iovec iov[2];
	u_short len;
	u_char *cp;

	connreset = 0;
 same_ns:
	truncating = 0;

	/* Are we still talking to whom we want to talk to? */
	if (statp->_vcsock >= 0 && (statp->_flags & RES_F_VC) != 0) {
		struct sockaddr_in6 peer;
		int size = sizeof peer;

		if (getpeername(statp->_vcsock,
				(struct sockaddr *)&peer, &size) < 0 ||
		    !sock_eq(&peer, nsap)) {
			res_nclose(statp);
			statp->_flags &= ~RES_F_VC;
		}
	}

	if (statp->_vcsock < 0 || (statp->_flags & RES_F_VC) == 0) {
		if (statp->_vcsock >= 0)
			res_nclose(statp);

		statp->_vcsock = socket(nsap->sin6_family, SOCK_STREAM, 0);
		if (statp->_vcsock < 0) {
			*terrno = errno;
			Perror(statp, stderr, "socket(vc)", errno);
			return (-1);
		}
		__set_errno (0);
		if (connect(statp->_vcsock, (struct sockaddr *)nsap,
			    sizeof *nsap) < 0) {
			*terrno = errno;
			Aerror(statp, stderr, "connect/vc", errno,
			       (struct sockaddr *) nsap);
			res_nclose(statp);
			return (0);
		}
		statp->_flags |= RES_F_VC;
	}

	/*
	 * Send length & message
	 */
	putshort((u_short)buflen, (u_char*)&len);
	evConsIovec(&len, INT16SZ, &iov[0]);
	evConsIovec((void*)buf, buflen, &iov[1]);
	if (TEMP_FAILURE_RETRY (writev(statp->_vcsock, iov, 2))
	    != (INT16SZ + buflen)) {
		*terrno = errno;
		Perror(statp, stderr, "write failed", errno);
		res_nclose(statp);
		return (0);
	}
	/*
	 * Receive length & response
	 */
 read_len:
	cp = ans;
	len = INT16SZ;
	while ((n = TEMP_FAILURE_RETRY (read(statp->_vcsock, (char *)cp,
					     (int)len))) > 0) {
		cp += n;
		if ((len -= n) <= 0)
			break;
	}
	if (n <= 0) {
		*terrno = errno;
		Perror(statp, stderr, "read failed", errno);
		res_nclose(statp);
		/*
		 * A long running process might get its TCP
		 * connection reset if the remote server was
		 * restarted.  Requery the server instead of
		 * trying a new one.  When there is only one
		 * server, this means that a query might work
		 * instead of failing.  We only allow one reset
		 * per query to prevent looping.
		 */
		if (*terrno == ECONNRESET && !connreset) {
			connreset = 1;
			res_nclose(statp);
			goto same_ns;
		}
		res_nclose(statp);
		return (0);
	}
	resplen = ns_get16(ans);
	if (resplen > anssiz) {
		if (anscp) {
			ans = malloc (MAXPACKET);
			if (ans == NULL) {
				*terrno = ENOMEM;
				res_nclose(statp);
				return (0);
			}
			anssiz = MAXPACKET;
			*anssizp = MAXPACKET;
			*ansp = ans;
			*anscp = ans;
			anhp = (HEADER *) ans;
			len = resplen;
		} else {
			Dprint(statp->options & RES_DEBUG,
				(stdout, ";; response truncated\n")
			);
			truncating = 1;
			len = anssiz;
		}
	} else
		len = resplen;
	if (len < HFIXEDSZ) {
		/*
		 * Undersized message.
		 */
		Dprint(statp->options & RES_DEBUG,
		       (stdout, ";; undersized: %d\n", len));
		*terrno = EMSGSIZE;
		res_nclose(statp);
		return (0);
	}
	cp = ans;
	while (len != 0 && (n = read(statp->_vcsock, (char *)cp, (int)len)) > 0){
		cp += n;
		len -= n;
	}
	if (n <= 0) {
		*terrno = errno;
		Perror(statp, stderr, "read(vc)", errno);
		res_nclose(statp);
		return (0);
	}
	if (truncating) {
		/*
		 * Flush rest of answer so connection stays in synch.
		 */
		anhp->tc = 1;
		len = resplen - anssiz;
		while (len != 0) {
			char junk[PACKETSZ];

			n = read(statp->_vcsock, junk,
				 (len > sizeof junk) ? sizeof junk : len);
			if (n > 0)
				len -= n;
			else
				break;
		}
	}
	/*
	 * If the calling applicating has bailed out of
	 * a previous call and failed to arrange to have
	 * the circuit closed or the server has got
	 * itself confused, then drop the packet and
	 * wait for the correct one.
	 */
	if (hp->id != anhp->id) {
		DprintQ((statp->options & RES_DEBUG) ||
			(statp->pfcode & RES_PRF_REPLY),
			(stdout, ";; old answer (unexpected):\n"),
			ans, (resplen > anssiz) ? anssiz: resplen);
		goto read_len;
	}

	/*
	 * All is well, or the error is fatal.  Signal that the
	 * next nameserver ought not be tried.
	 */
	return (resplen);
}

static int
send_dg(res_state statp,
	const u_char *buf, int buflen, u_char **ansp, int *anssizp,
	int *terrno, int ns, int *v_circuit, int *gotsomewhere, u_char **anscp)
{
	const HEADER *hp = (HEADER *) buf;
	u_char *ans = *ansp;
	int anssiz = *anssizp;
	HEADER *anhp = (HEADER *) ans;
	struct sockaddr_in6 *nsap = EXT(statp).nsaddrs[ns];
	struct timespec now, timeout, finish;
	struct pollfd pfd[1];
        int ptimeout;
	struct sockaddr_in6 from;
	static int socket_pf = 0;
	int fromlen, resplen, seconds, n;

	if (EXT(statp).nssocks[ns] == -1) {
		/* only try IPv6 if IPv6 NS and if not failed before */
		if ((EXT(statp).nscount6 > 0) && (socket_pf != PF_INET)) {
			EXT(statp).nssocks[ns] =
			    socket(PF_INET6, SOCK_DGRAM, 0);
			socket_pf = EXT(statp).nssocks[ns] < 0 ? PF_INET
			                                       : PF_INET6;
		}
		if (EXT(statp).nssocks[ns] < 0)
			EXT(statp).nssocks[ns] = socket(PF_INET, SOCK_DGRAM, 0);
		if (EXT(statp).nssocks[ns] < 0) {
			*terrno = errno;
			Perror(statp, stderr, "socket(dg)", errno);
			return (-1);
		}
		/* If IPv6 socket and nsap is IPv4, make it IPv4-mapped */
		if ((socket_pf == PF_INET6) && (nsap->sin6_family == AF_INET))
			convaddr4to6(nsap);
		/*
		 * On a 4.3BSD+ machine (client and server,
		 * actually), sending to a nameserver datagram
		 * port with no nameserver will cause an
		 * ICMP port unreachable message to be returned.
		 * If our datagram socket is "connected" to the
		 * server, we get an ECONNREFUSED error on the next
		 * socket operation, and select returns if the
		 * error message is received.  We can thus detect
		 * the absence of a nameserver without timing out.
		 */
		if (connect(EXT(statp).nssocks[ns], (struct sockaddr *)nsap,
			    sizeof *nsap) < 0) {
			Aerror(statp, stderr, "connect(dg)", errno,
			       (struct sockaddr *) nsap);
			res_nclose(statp);
			return (0);
		}
		/* Make socket non-blocking.  */
		int fl = fcntl (EXT(statp).nssocks[ns], F_GETFL);
		if  (fl != -1)
			fcntl (EXT(statp).nssocks[ns], F_SETFL,
				 fl | O_NONBLOCK);
		Dprint(statp->options & RES_DEBUG,
		       (stdout, ";; new DG socket\n"))
	}

	/*
	 * Compute time for the total operation.
	 */
	seconds = (statp->retrans << ns);
	if (ns > 0)
		seconds /= statp->nscount;
	if (seconds <= 0)
		seconds = 1;
	evNowTime(&now);
	evConsTime(&timeout, seconds, 0);
	evAddTime(&finish, &now, &timeout);
	int need_recompute = 0;
	int nwritten = 0;
	pfd[0].fd = EXT(statp).nssocks[ns];
	pfd[0].events = POLLOUT;
 wait:
	if (need_recompute) {
		evNowTime(&now);
		if (evCmpTime(finish, now) <= 0) {
			Perror(statp, stderr, "select", errno);
			res_nclose(statp);
			return (0);
		}
		evSubTime(&timeout, &finish, &now);
	}
        /* Convert struct timespec in milliseconds.  */
	ptimeout = timeout.tv_sec * 1000 + timeout.tv_nsec / 1000000;

	n = 0;
	if (nwritten == 0)
	  n = poll (pfd, 1, 0);
	if (__builtin_expect (n == 0, 0)) {
		n = poll (pfd, 1, ptimeout);
		need_recompute = 1;
	}
	if (n == 0) {
		Dprint(statp->options & RES_DEBUG, (stdout,
						    ";; timeout sending\n"));
		*gotsomewhere = 1;
		return (0);
	}
	if (n < 0) {
		if (errno == EINTR) {
		recompute_resend:
			evNowTime(&now);
			if (evCmpTime(finish, now) > 0) {
				evSubTime(&timeout, &finish, &now);
				goto wait;
			}
		}
		Perror(statp, stderr, "poll", errno);
		res_nclose(statp);
		return (0);
	}
	__set_errno (0);
	if (pfd[0].revents & POLLOUT) {
		if (send(pfd[0].fd, (char*)buf, buflen, 0) != buflen) {
			if (errno == EINTR || errno == EAGAIN)
				goto recompute_resend;
			Perror(statp, stderr, "send", errno);
			res_nclose(statp);
			return (0);
		}
		pfd[0].events = POLLIN;
		++nwritten;
		goto wait;
	} else if (pfd[0].revents & POLLIN) {
		fromlen = sizeof(struct sockaddr_in6);
		if (anssiz < MAXPACKET
		    && anscp
		    && (ioctl (pfd[0].fd, FIONREAD, &resplen) < 0
		|| anssiz < resplen)) {
			ans = malloc (MAXPACKET);
			if (ans == NULL)
				ans = *ansp;
			else {
				anssiz = MAXPACKET;
				*anssizp = MAXPACKET;
				*ansp = ans;
				*anscp = ans;
				anhp = (HEADER *) ans;
			}
		}
		resplen = recvfrom(pfd[0].fd, (char*)ans, anssiz,0,
				   (struct sockaddr *)&from, &fromlen);
		if (resplen <= 0) {
			if (errno == EINTR || errno == EAGAIN) {
				need_recompute = 1;
				goto wait;
			}
			Perror(statp, stderr, "recvfrom", errno);
			res_nclose(statp);
			return (0);
		}
		*gotsomewhere = 1;
		if (resplen < HFIXEDSZ) {
			/*
			 * Undersized message.
			 */
			Dprint(statp->options & RES_DEBUG,
			       (stdout, ";; undersized: %d\n",
				resplen));
			*terrno = EMSGSIZE;
			res_nclose(statp);
			return (0);
		}
		if (hp->id != anhp->id) {
			/*
			 * response from old query, ignore it.
			 * XXX - potential security hazard could
			 *	 be detected here.
			 */
			DprintQ((statp->options & RES_DEBUG) ||
				(statp->pfcode & RES_PRF_REPLY),
				(stdout, ";; old answer:\n"),
				ans, (resplen > anssiz) ? anssiz : resplen);
			goto wait;
		}
		if (!(statp->options & RES_INSECURE1) &&
		    !res_ourserver_p(statp, &from)) {
			/*
			 * response from wrong server? ignore it.
			 * XXX - potential security hazard could
			 *	 be detected here.
			 */
			DprintQ((statp->options & RES_DEBUG) ||
				(statp->pfcode & RES_PRF_REPLY),
				(stdout, ";; not our server:\n"),
				ans, (resplen > anssiz) ? anssiz : resplen);
			goto wait;
		}
		if (!(statp->options & RES_INSECURE2) &&
		    !res_queriesmatch(buf, buf + buflen,
				      ans, ans + anssiz)) {
			/*
			 * response contains wrong query? ignore it.
			 * XXX - potential security hazard could
			 *	 be detected here.
			 */
			DprintQ((statp->options & RES_DEBUG) ||
				(statp->pfcode & RES_PRF_REPLY),
				(stdout, ";; wrong query name:\n"),
				ans, (resplen > anssiz) ? anssiz : resplen);
			goto wait;
		}
		if (anhp->rcode == SERVFAIL ||
		    anhp->rcode == NOTIMP ||
		    anhp->rcode == REFUSED) {
			DprintQ(statp->options & RES_DEBUG,
				(stdout, "server rejected query:\n"),
				ans, (resplen > anssiz) ? anssiz : resplen);
			res_nclose(statp);
			/* don't retry if called from dig */
			if (!statp->pfcode)
				return (0);
		}
		if (!(statp->options & RES_IGNTC) && anhp->tc) {
			/*
			 * To get the rest of answer,
			 * use TCP with same server.
			 */
			Dprint(statp->options & RES_DEBUG,
			       (stdout, ";; truncated answer\n"));
			*v_circuit = 1;
			res_nclose(statp);
			return (1);
		}
		/*
		 * All is well, or the error is fatal.  Signal that the
		 * next nameserver ought not be tried.
		 */
		return (resplen);
	} else if (pfd[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {
		/* Something went wrong.  We can stop trying.  */
		res_nclose(statp);
		return (0);
	}
}

#ifdef DEBUG
static void
Aerror(const res_state statp, FILE *file, const char *string, int error,
       const struct sockaddr *address)
{
	int save = errno;

	if ((statp->options & RES_DEBUG) != 0) {
		char tmp[sizeof "xxxx.xxxx.xxxx.255.255.255.255"];

		fprintf(file, "res_send: %s ([%s].%u): %s\n",
			string,
			inet_ntop(address->sa_family, address->sa_data,
				  tmp, sizeof tmp),
			(address->sa_family == AF_INET
			 ? ntohs(((struct sockaddr_in *) address)->sin_port)
			 : address->sa_family == AF_INET6
			 ? ntohs(((struct sockaddr_in6 *) address)->sin6_port)
			 : 0),
			strerror(error));
	}
	__set_errno (save);
}

static void
Perror(const res_state statp, FILE *file, const char *string, int error) {
	int save = errno;

	if ((statp->options & RES_DEBUG) != 0)
		fprintf(file, "res_send: %s: %s\n",
			string, strerror(error));
	__set_errno (save);
}
#endif

static int
sock_eq(struct sockaddr_in6 *a1, struct sockaddr_in6 *a2) {
	if (a1->sin6_family == a2->sin6_family) {
		if (a1->sin6_family == AF_INET)
			return ((((struct sockaddr_in *)a1)->sin_port ==
				 ((struct sockaddr_in *)a2)->sin_port) &&
				(((struct sockaddr_in *)a1)->sin_addr.s_addr ==
				 ((struct sockaddr_in *)a2)->sin_addr.s_addr));
		else
			return ((a1->sin6_port == a2->sin6_port) &&
				!memcmp(&a1->sin6_addr, &a2->sin6_addr,
					sizeof (struct in6_addr)));
	}
	if (a1->sin6_family == AF_INET) {
		struct sockaddr_in6 *sap = a1;
		a1 = a2;
		a2 = sap;
	} /* assumes that AF_INET and AF_INET6 are the only possibilities */
	return ((a1->sin6_port == ((struct sockaddr_in *)a2)->sin_port) &&
		IN6_IS_ADDR_V4MAPPED(&a1->sin6_addr) &&
		(a1->sin6_addr.s6_addr32[3] ==
		 ((struct sockaddr_in *)a2)->sin_addr.s_addr));
}

/*
 * Converts IPv4 family, address and port to
 * IPv6 family, IPv4-mapped IPv6 address and port.
 */
static void
convaddr4to6(struct sockaddr_in6 *sa)
{
    struct sockaddr_in *sa4p = (struct sockaddr_in *) sa;
    in_port_t port = sa4p->sin_port;
    in_addr_t addr = sa4p->sin_addr.s_addr;

    sa->sin6_family = AF_INET6;
    sa->sin6_port = port;
    sa->sin6_addr.s6_addr32[0] = 0;
    sa->sin6_addr.s6_addr32[1] = 0;
    sa->sin6_addr.s6_addr32[2] = htonl(0xFFFF);
    sa->sin6_addr.s6_addr32[3] = addr;
}
@


1.1
log
@
2003-05-28  Jeff Johnston  <jjohnstn@@redhat.com>
	    Tom Fitzsimmons  <fitzsim@@redhat.com>

	* configure.in: Add iconvdata support for x86 linux.
	* configure: Regenerated.
	* libc/sys/linux/Makefile.am: Add EL/IX level 3 network, dynamic
	library, iconv, and linuxthreads support.
	* libc/sys/linux/configure.in: Ditto.
	* libc/sys/linux/Makefile.in: Regenerated.
	* libc/sys/linux/configure: Ditto.
	* iconvdata/EUC-JP.irreversible: New file.
	* iconvdata/Makefile.am: Ditto.
	* iconvdata/Makefile.in: Ditto.
	* iconvdata/SJIS.irreversible: Ditto.
	* iconvdata/aclocal.m4: Ditto.
	* iconvdata/configure: Ditto.
	* iconvdata/configure.in: Ditto.
	* iconvdata/dummy.c: Ditto.
	* iconvdata/euc-jp.c: Ditto.
	* iconvdata/gconv-modules: Ditto.
	* iconvdata/jis0201.c: Ditto.
	* iconvdata/jis0201.h: Ditto.
	* iconvdata/jis0208.c: Ditto.
	* iconvdata/jis0208.h: Ditto.
	* iconvdata/jis0212.c: Ditto.
	* iconvdata/jis0212.h: Ditto.
	* iconvdata/sjis.c: Ditto.
	* libc/include/errno.h: Protect definition of error_t.
	* libc/sys/linux/gethostid.c: New file.
	* libc/sys/linux/sethostid.c: Ditto.
	* libc/sys/linux/dl/Makefile.am: Ditto.
	* libc/sys/linux/dl/Makefile.in: Ditto.
	* libc/sys/linux/dl/abi-tag.h: Ditto.
	* libc/sys/linux/dl/atomicity.h: Ditto.
	* libc/sys/linux/dl/dl-addr.c: Ditto.
	* libc/sys/linux/dl/dl-cache.c: Ditto.
	* libc/sys/linux/dl/dl-cache.h: Ditto.
	* libc/sys/linux/dl/dl-close.c: Ditto.
	* libc/sys/linux/dl/dl-debug.c: Ditto.
	* libc/sys/linux/dl/dl-deps.c: Ditto.
	* libc/sys/linux/dl/dl-dst.h: Ditto.
	* libc/sys/linux/dl/dl-error.c: Ditto.
	* libc/sys/linux/dl/dl-fini.c: Ditto.
	* libc/sys/linux/dl/dl-init.c: Ditto.
	* libc/sys/linux/dl/dl-iteratephdr.c: Ditto.
	* libc/sys/linux/dl/dl-libc.c: Ditto.
	* libc/sys/linux/dl/dl-librecon.h: Ditto.
	* libc/sys/linux/dl/dl-load.c: Ditto.
	* libc/sys/linux/dl/dl-lookup.c: Ditto.
	* libc/sys/linux/dl/dl-lookupcfg.h: Ditto.
	* libc/sys/linux/dl/dl-minimal.c: Ditto.
	* libc/sys/linux/dl/dl-misc.c: Ditto.
	* libc/sys/linux/dl/dl-object.c: Ditto.
	* libc/sys/linux/dl/dl-open.c: Ditto.
	* libc/sys/linux/dl/dl-osinfo.h: Ditto.
	* libc/sys/linux/dl/dl-profile.c: Ditto.
	* libc/sys/linux/dl/dl-profstub.c: Ditto.
	* libc/sys/linux/dl/dl-reloc.c: Ditto.
	* libc/sys/linux/dl/dl-runtime.c: Ditto.
	* libc/sys/linux/dl/dl-support.c: Ditto.
	* libc/sys/linux/dl/dl-sym.c: Ditto.
	* libc/sys/linux/dl/dl-version.c: Ditto.
	* libc/sys/linux/dl/dlfcn.h: Ditto.
	* libc/sys/linux/dl/do-lookup.h: Ditto.
	* libc/sys/linux/dl/do-rel.h: Ditto.
	* libc/sys/linux/dl/dynamic-link.h: Ditto.
	* libc/sys/linux/dl/kernel-features.h: Ditto.
	* libc/sys/linux/dl/ldsodefs.h: Ditto.
	* libc/sys/linux/dl/libintl.h: Ditto.
	* libc/sys/linux/dl/trusted-dirs.h: Ditto.
	* libc/sys/linux/dl/unsecvars.h: Ditto.
	* libc/sys/linux/iconv/Makefile.am: Ditto.
	* libc/sys/linux/iconv/Makefile.in: Ditto.
	* libc/sys/linux/iconv/categories.def: Ditto.
	* libc/sys/linux/iconv/dummy-repertoire.c: Ditto.
	* libc/sys/linux/iconv/gconv.c: Ditto.
	* libc/sys/linux/iconv/gconv_builtin.c: Ditto.
	* libc/sys/linux/iconv/gconv_builtin.h: Ditto.
	* libc/sys/linux/iconv/gconv_cache.c: Ditto.
	* libc/sys/linux/iconv/gconv_charset.h: Ditto.
	* libc/sys/linux/iconv/gconv_close.c: Ditto.
	* libc/sys/linux/iconv/gconv_conf.c: Ditto.
	* libc/sys/linux/iconv/gconv_db.c: Ditto.
	* libc/sys/linux/iconv/gconv_dl.c: Ditto.
	* libc/sys/linux/iconv/gconv_int.h: Ditto.
	* libc/sys/linux/iconv/gconv_open.c: Ditto.
	* libc/sys/linux/iconv/gconv_simple.c: Ditto.
	* libc/sys/linux/iconv/gconv_trans.c: Ditto.
	* libc/sys/linux/iconv/hash-string.h: Ditto.
	* libc/sys/linux/iconv/iconv.c: Ditto.
	* libc/sys/linux/iconv/iconv.h: Ditto.
	* libc/sys/linux/iconv/iconv_charmap.c: Ditto.
	* libc/sys/linux/iconv/iconv_close.c: Ditto.
	* libc/sys/linux/iconv/iconv_open.c: Ditto.
	* libc/sys/linux/iconv/iconvconfig.c: Ditto.
	* libc/sys/linux/iconv/iconvconfig.h: Ditto.
	* libc/sys/linux/iconv/loadinfo.h: Ditto.
	* libc/sys/linux/iconv/localeinfo.h: Ditto.
	* libc/sys/linux/iconv/loop.c: Ditto.
	* libc/sys/linux/iconv/skeleton.c: Ditto.
	* libc/sys/linux/iconv/strtab.c: Ditto.
	* libc/sys/linux/include/dl-hash.h: Ditto.
	* libc/sys/linux/include/dlfcn.h: Ditto.
	* libc/sys/linux/include/fnmatch.h: Ditto.
	* libc/sys/linux/include/gconv.h: Ditto.
	* libc/sys/linux/include/glob.h: Ditto.
	* libc/sys/linux/include/hesiod.h: Ditto.
	* libc/sys/linux/include/ifaddrs.h: Ditto.
	* libc/sys/linux/include/libc_private.h: Ditto.
	* libc/sys/linux/include/link.h: Ditto.
	* libc/sys/linux/include/namespace.h: Ditto.
	* libc/sys/linux/include/netconfig.h: Ditto.
	* libc/sys/linux/include/netdb.h: Ditto.
	* libc/sys/linux/include/nsswitch.h: Ditto.
	* libc/sys/linux/include/regex.h: Ditto.
	* libc/sys/linux/include/resolv.h: Ditto.
	* libc/sys/linux/include/rune.h: Ditto.
	* libc/sys/linux/include/runetype.h: Ditto.
	* libc/sys/linux/include/semaphore.h: Ditto.
	* libc/sys/linux/include/setlocale.h: Ditto.
	* libc/sys/linux/include/un-namespace.h: Ditto.
	* libc/sys/linux/include/wordexp.h: Ditto.
	* libc/sys/linux/include/arpa/ftp.h: Ditto.
	* libc/sys/linux/include/arpa/inet.h: Ditto.
	* libc/sys/linux/include/arpa/nameser.h: Ditto.
	* libc/sys/linux/include/arpa/nameser_compat.h: Ditto.
	* libc/sys/linux/include/arpa/telnet.h: Ditto.
	* libc/sys/linux/include/arpa/tftp.h: Ditto.
	* libc/sys/linux/include/net/bpf.h: Ditto.
	* libc/sys/linux/include/net/bpf_compat.h: Ditto.
	* libc/sys/linux/include/net/bpfdesc.h: Ditto.
	* libc/sys/linux/include/net/bridge.h: Ditto.
	* libc/sys/linux/include/net/ethernet.h: Ditto.
	* libc/sys/linux/include/net/fddi.h: Ditto.
	* libc/sys/linux/include/net/if.h: Ditto.
	* libc/sys/linux/include/net/if_arc.h: Ditto.
	* libc/sys/linux/include/net/if_arp.h: Ditto.
	* libc/sys/linux/include/net/if_atm.h: Ditto.
	* libc/sys/linux/include/net/if_dl.h: Ditto.
	* libc/sys/linux/include/net/if_gif.h: Ditto.
	* libc/sys/linux/include/net/if_ieee80211.h: Ditto.
	* libc/sys/linux/include/net/if_llc.h: Ditto.
	* libc/sys/linux/include/net/if_media.h: Ditto.
	* libc/sys/linux/include/net/if_mib.h: Ditto.
	* libc/sys/linux/include/net/if_ppp.h: Ditto.
	* libc/sys/linux/include/net/if_pppvar.h: Ditto.
	* libc/sys/linux/include/net/if_slvar.h: Ditto.
	* libc/sys/linux/include/net/if_sppp.h: Ditto.
	* libc/sys/linux/include/net/if_stf.h: Ditto.
	* libc/sys/linux/include/net/if_tap.h: Ditto.
	* libc/sys/linux/include/net/if_tapvar.h: Ditto.
	* libc/sys/linux/include/net/if_tun.h: Ditto.
	* libc/sys/linux/include/net/if_tunvar.h: Ditto.
	* libc/sys/linux/include/net/if_types.h: Ditto.
	* libc/sys/linux/include/net/if_var.h: Ditto.
	* libc/sys/linux/include/net/if_vlan_var.h: Ditto.
	* libc/sys/linux/include/net/intrq.h: Ditto.
	* libc/sys/linux/include/net/iso88025.h: Ditto.
	* libc/sys/linux/include/net/net_osdep.h: Ditto.
	* libc/sys/linux/include/net/netisr.h: Ditto.
	* libc/sys/linux/include/net/pfil.h: Ditto.
	* libc/sys/linux/include/net/pfkeyv2.h: Ditto.
	* libc/sys/linux/include/net/ppp_comp.h: Ditto.
	* libc/sys/linux/include/net/ppp_defs.h: Ditto.
	* libc/sys/linux/include/net/radix.h: Ditto.
	* libc/sys/linux/include/net/raw_cb.h: Ditto.
	* libc/sys/linux/include/net/route.h: Ditto.
	* libc/sys/linux/include/net/slcompress.h: Ditto.
	* libc/sys/linux/include/net/slip.h: Ditto.
	* libc/sys/linux/include/net/zlib.h: Ditto.
	* libc/sys/linux/include/netinet/icmp6.h: Ditto.
	* libc/sys/linux/include/netinet/icmp_var.h: Ditto.
	* libc/sys/linux/include/netinet/if_atm.h: Ditto.
	* libc/sys/linux/include/netinet/if_ether.h: Ditto.
	* libc/sys/linux/include/netinet/igmp.h: Ditto.
	* libc/sys/linux/include/netinet/igmp_var.h: Ditto.
	* libc/sys/linux/include/netinet/in.h: Ditto.
	* libc/sys/linux/include/netinet/in_gif.h: Ditto.
	* libc/sys/linux/include/netinet/in_pcb.h: Ditto.
	* libc/sys/linux/include/netinet/in_systm.h: Ditto.
	* libc/sys/linux/include/netinet/in_var.h: Ditto.
	* libc/sys/linux/include/netinet/ip.h: Ditto.
	* libc/sys/linux/include/netinet/ip6.h: Ditto.
	* libc/sys/linux/include/netinet/ip_dummynet.h: Ditto.
	* libc/sys/linux/include/netinet/ip_ecn.h: Ditto.
	* libc/sys/linux/include/netinet/ip_encap.h: Ditto.
	* libc/sys/linux/include/netinet/ip_flow.h: Ditto.
	* libc/sys/linux/include/netinet/ip_fw.h: Ditto.
	* libc/sys/linux/include/netinet/ip_icmp.h: Ditto.
	* libc/sys/linux/include/netinet/ip_mroute.h: Ditto.
	* libc/sys/linux/include/netinet/ip_var.h: Ditto.
	* libc/sys/linux/include/netinet/ipprotosw.h: Ditto.
	* libc/sys/linux/include/netinet/tcp.h: Ditto.
	* libc/sys/linux/include/netinet/tcp_debug.h: Ditto.
	* libc/sys/linux/include/netinet/tcp_fsm.h: Ditto.
	* libc/sys/linux/include/netinet/tcp_seq.h: Ditto.
	* libc/sys/linux/include/netinet/tcp_timer.h: Ditto.
	* libc/sys/linux/include/netinet/tcp_var.h: Ditto.
	* libc/sys/linux/include/netinet/tcpip.h: Ditto.
	* libc/sys/linux/include/netinet/udp.h: Ditto.
	* libc/sys/linux/include/netinet/udp_var.h: Ditto.
	* libc/sys/linux/include/netinet6/ah.h: Ditto.
	* libc/sys/linux/include/netinet6/ah6.h: Ditto.
	* libc/sys/linux/include/netinet6/esp.h: Ditto.
	* libc/sys/linux/include/netinet6/esp6.h: Ditto.
	* libc/sys/linux/include/netinet6/esp_rijndael.h: Ditto.
	* libc/sys/linux/include/netinet6/icmp6.h: Ditto.
	* libc/sys/linux/include/netinet6/in6.h: Ditto.
	* libc/sys/linux/include/netinet6/in6_gif.h: Ditto.
	* libc/sys/linux/include/netinet6/in6_ifattach.h: Ditto.
	* libc/sys/linux/include/netinet6/in6_pcb.h: Ditto.
	* libc/sys/linux/include/netinet6/in6_prefix.h: Ditto.
	* libc/sys/linux/include/netinet6/in6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6_ecn.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6_fw.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6_mroute.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6protosw.h: Ditto.
	* libc/sys/linux/include/netinet6/ipcomp.h: Ditto.
	* libc/sys/linux/include/netinet6/ipcomp6.h: Ditto.
	* libc/sys/linux/include/netinet6/ipsec.h: Ditto.
	* libc/sys/linux/include/netinet6/ipsec6.h: Ditto.
	* libc/sys/linux/include/netinet6/mld6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/nd6.h: Ditto.
	* libc/sys/linux/include/netinet6/pim6.h: Ditto.
	* libc/sys/linux/include/netinet6/pim6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/raw_ip6.h: Ditto.
	* libc/sys/linux/include/netinet6/scope6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/tcp6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/udp6_var.h: Ditto.
	* libc/sys/linux/include/netns/idp.h: Ditto.
	* libc/sys/linux/include/netns/idp_var.h: Ditto.
	* libc/sys/linux/include/netns/ns.h: Ditto.
	* libc/sys/linux/include/netns/ns_error.h: Ditto.
	* libc/sys/linux/include/netns/ns_if.h: Ditto.
	* libc/sys/linux/include/netns/ns_pcb.h: Ditto.
	* libc/sys/linux/include/netns/sp.h: Ditto.
	* libc/sys/linux/include/netns/spidp.h: Ditto.
	* libc/sys/linux/include/netns/spp_debug.h: Ditto.
	* libc/sys/linux/include/netns/spp_timer.h: Ditto.
	* libc/sys/linux/include/netns/spp_var.h: Ditto.
	* libc/sys/linux/include/rpc/Makefile: Ditto.
	* libc/sys/linux/include/rpc/auth.h: Ditto.
	* libc/sys/linux/include/rpc/auth_des.h: Ditto.
	* libc/sys/linux/include/rpc/auth_kerb.h: Ditto.
	* libc/sys/linux/include/rpc/auth_unix.h: Ditto.
	* libc/sys/linux/include/rpc/clnt.h: Ditto.
	* libc/sys/linux/include/rpc/clnt_soc.h: Ditto.
	* libc/sys/linux/include/rpc/clnt_stat.h: Ditto.
	* libc/sys/linux/include/rpc/des.h: Ditto.
	* libc/sys/linux/include/rpc/des_crypt.h: Ditto.
	* libc/sys/linux/include/rpc/nettype.h: Ditto.
	* libc/sys/linux/include/rpc/pmap_clnt.h: Ditto.
	* libc/sys/linux/include/rpc/pmap_prot.h: Ditto.
	* libc/sys/linux/include/rpc/pmap_rmt.h: Ditto.
	* libc/sys/linux/include/rpc/raw.h: Ditto.
	* libc/sys/linux/include/rpc/rpc.h: Ditto.
	* libc/sys/linux/include/rpc/rpc_com.h: Ditto.
	* libc/sys/linux/include/rpc/rpc_msg.h: Ditto.
	* libc/sys/linux/include/rpc/rpcb_clnt.h: Ditto.
	* libc/sys/linux/include/rpc/rpcb_prot.h: Ditto.
	* libc/sys/linux/include/rpc/rpcb_prot.x: Ditto.
	* libc/sys/linux/include/rpc/rpcent.h: Ditto.
	* libc/sys/linux/include/rpc/svc.h: Ditto.
	* libc/sys/linux/include/rpc/svc_auth.h: Ditto.
	* libc/sys/linux/include/rpc/svc_dg.h: Ditto.
	* libc/sys/linux/include/rpc/svc_soc.h: Ditto.
	* libc/sys/linux/include/rpc/types.h: Ditto.
	* libc/sys/linux/include/rpc/xdr.h: Ditto.
	* libc/sys/linux/intl/Makefile.am: Ditto.
	* libc/sys/linux/intl/Makefile.in: Ditto.
	* libc/sys/linux/intl/bindtextdom.c: Ditto.
	* libc/sys/linux/intl/catgets.c: Ditto.
	* libc/sys/linux/intl/catgetsinfo.h: Ditto.
	* libc/sys/linux/intl/config.h: Ditto.
	* libc/sys/linux/intl/dcgettext.c: Ditto.
	* libc/sys/linux/intl/dcigettext.c: Ditto.
	* libc/sys/linux/intl/dcngettext.c: Ditto.
	* libc/sys/linux/intl/dgettext.c: Ditto.
	* libc/sys/linux/intl/dngettext.c: Ditto.
	* libc/sys/linux/intl/explodename.c: Ditto.
	* libc/sys/linux/intl/finddomain.c: Ditto.
	* libc/sys/linux/intl/gettext.c: Ditto.
	* libc/sys/linux/intl/gettext.h: Ditto.
	* libc/sys/linux/intl/gettextP.h: Ditto.
	* libc/sys/linux/intl/hash-string.h: Ditto.
	* libc/sys/linux/intl/l10nflist.c: Ditto.
	* libc/sys/linux/intl/loadinfo.h: Ditto.
	* libc/sys/linux/intl/loadmsgcat.c: Ditto.
	* libc/sys/linux/intl/locale.alias: Ditto.
	* libc/sys/linux/intl/localealias.c: Ditto.
	* libc/sys/linux/intl/ngettext.c: Ditto.
	* libc/sys/linux/intl/open_catalog.c: Ditto.
	* libc/sys/linux/intl/plural.c: Ditto.
	* libc/sys/linux/intl/plural.y: Ditto.
	* libc/sys/linux/intl/stpcpy.c: Ditto.
	* libc/sys/linux/intl/textdomain.c: Ditto.
	* libc/sys/linux/linuxthreads/LICENSE: Ditto.
	* libc/sys/linux/linuxthreads/Makefile.am: Ditto.
	* libc/sys/linux/linuxthreads/Makefile.in: Ditto.
	* libc/sys/linux/linuxthreads/aclocal.m4: Ditto.
	* libc/sys/linux/linuxthreads/attr.c: Ditto.
	* libc/sys/linux/linuxthreads/barrier.c: Ditto.
	* libc/sys/linux/linuxthreads/bp-sym.h: Ditto.
	* libc/sys/linux/linuxthreads/cancel.c: Ditto.
	* libc/sys/linux/linuxthreads/condvar.c: Ditto.
	* libc/sys/linux/linuxthreads/config.h: Ditto.
	* libc/sys/linux/linuxthreads/configure: Ditto.
	* libc/sys/linux/linuxthreads/configure.in: Ditto.
	* libc/sys/linux/linuxthreads/defs.awk: Ditto.
	* libc/sys/linux/linuxthreads/ecmutex.c: Ditto.
	* libc/sys/linux/linuxthreads/events.c: Ditto.
	* libc/sys/linux/linuxthreads/getcpuclockid.c: Ditto.
	* libc/sys/linux/linuxthreads/getreent.c: Ditto.
	* libc/sys/linux/linuxthreads/internals.h: Ditto.
	* libc/sys/linux/linuxthreads/join.c: Ditto.
	* libc/sys/linux/linuxthreads/joinrace.c: Ditto.
	* libc/sys/linux/linuxthreads/kernel-features.h: Ditto.
	* libc/sys/linux/linuxthreads/libc-internal.h: Ditto.
	* libc/sys/linux/linuxthreads/libc-symbols.h: Ditto.
	* libc/sys/linux/linuxthreads/linuxthreads.texi: Ditto.
	* libc/sys/linux/linuxthreads/lockfile.c: Ditto.
	* libc/sys/linux/linuxthreads/manager.c: Ditto.
	* libc/sys/linux/linuxthreads/mq_notify.c: Ditto.
	* libc/sys/linux/linuxthreads/mutex.c: Ditto.
	* libc/sys/linux/linuxthreads/no-tsd.c: Ditto.
	* libc/sys/linux/linuxthreads/oldsemaphore.c: Ditto.
	* libc/sys/linux/linuxthreads/posix-timer.h: Ditto.
	* libc/sys/linux/linuxthreads/prio.c: Ditto.
	* libc/sys/linux/linuxthreads/proc_service.h: Ditto.
	* libc/sys/linux/linuxthreads/pt-machine.c: Ditto.
	* libc/sys/linux/linuxthreads/ptclock_gettime.c: Ditto.
	* libc/sys/linux/linuxthreads/ptclock_settime.c: Ditto.
	* libc/sys/linux/linuxthreads/ptfork.c: Ditto.
	* libc/sys/linux/linuxthreads/pthread.c: Ditto.
	* libc/sys/linux/linuxthreads/ptlongjmp.c: Ditto.
	* libc/sys/linux/linuxthreads/queue.h: Ditto.
	* libc/sys/linux/linuxthreads/reent.c: Ditto.
	* libc/sys/linux/linuxthreads/reqsyscalls.c: Ditto.
	* libc/sys/linux/linuxthreads/restart.h: Ditto.
	* libc/sys/linux/linuxthreads/rwlock.c: Ditto.
	* libc/sys/linux/linuxthreads/semaphore.c: Ditto.
	* libc/sys/linux/linuxthreads/semaphore.h: Ditto.
	* libc/sys/linux/linuxthreads/shlib-compat.h: Ditto.
	* libc/sys/linux/linuxthreads/signals.c: Ditto.
	* libc/sys/linux/linuxthreads/specific.c: Ditto.
	* libc/sys/linux/linuxthreads/spinlock.c: Ditto.
	* libc/sys/linux/linuxthreads/spinlock.h: Ditto.
	* libc/sys/linux/linuxthreads/sysctl.c: Ditto.
	* libc/sys/linux/linuxthreads/td_init.c: Ditto.
	* libc/sys/linux/linuxthreads/td_log.c: Ditto.
	* libc/sys/linux/linuxthreads/td_symbol_list.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_clear_event.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_delete.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_enable_stats.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_event_addr.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_event_getmsg.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_get_nthreads.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_get_ph.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_get_stats.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_map_id2thr.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_map_lwp2thr.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_new.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_reset_stats.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_set_event.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_setconcurrency.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_thr_iter.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_tsd_iter.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_clear_event.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_dbresume.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_dbsuspend.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_event_enable.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_event_getmsg.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_get_info.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_getfpregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_getgregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_getxregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_getxregsize.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_set_event.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_setfpregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_setgregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_setprio.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_setsigpending.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_setxregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_sigsetmask.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_tsd.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_validate.c: Ditto.
	* libc/sys/linux/linuxthreads/testrtsig.h: Ditto.
	* libc/sys/linux/linuxthreads/thread_db.h: Ditto.
	* libc/sys/linux/linuxthreads/thread_dbP.h: Ditto.
	* libc/sys/linux/linuxthreads/timer_create.c: Ditto.
	* libc/sys/linux/linuxthreads/timer_delete.c: Ditto.
	* libc/sys/linux/linuxthreads/timer_getoverr.c: Ditto.
	* libc/sys/linux/linuxthreads/timer_gettime.c: Ditto.
	* libc/sys/linux/linuxthreads/timer_routines.c: Ditto.
	* libc/sys/linux/linuxthreads/timer_settime.c: Ditto.
	* libc/sys/linux/linuxthreads/tst-cancel.c: Ditto.
	* libc/sys/linux/linuxthreads/tst-context.c: Ditto.
	* libc/sys/linux/linuxthreads/tststack.c: Ditto.
	* libc/sys/linux/linuxthreads/unload.c: Ditto.
	* libc/sys/linux/linuxthreads/weaks.c: Ditto.
	* libc/sys/linux/linuxthreads/wrapsyscall.c: Ditto.
	* libc/sys/linux/linuxthreads/bits/initspin.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/libc-lock.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/libc-tsd.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/local_lim.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/posix_opt.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/pthreadtypes.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/sigthread.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/Makefile.am: Ditto.
	* libc/sys/linux/linuxthreads/machine/Makefile.in: Ditto.
	* libc/sys/linux/linuxthreads/machine/aclocal.m4: Ditto.
	* libc/sys/linux/linuxthreads/machine/configure: Ditto.
	* libc/sys/linux/linuxthreads/machine/configure.in: Ditto.
	* libc/sys/linux/linuxthreads/machine/generic/generic-sysd: Ditto.ep.h
	* libc/sys/linux/linuxthreads/machine/i386/Makefile.am: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/Makefile.in: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/aclocal.m4: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/bp-asm.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/clone.S: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/configure: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/configure.in: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/i386-sysdep.S: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/i386-sysdep.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/pspinlock.c: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/pt-machine.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/sigcontextinfo.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/stackinfo.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/sysdep.S: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/sysdep.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/useldt.h: Ditto.
	* libc/sys/linux/machine/i386/dl-machine.h: Ditto.
	* libc/sys/linux/net/Makefile.am: Ditto.
	* libc/sys/linux/net/Makefile.in: Ditto.
	* libc/sys/linux/net/addr2ascii.3: Ditto.
	* libc/sys/linux/net/addr2ascii.c: Ditto.
	* libc/sys/linux/net/ascii2addr.c: Ditto.
	* libc/sys/linux/net/base64.c: Ditto.
	* libc/sys/linux/net/bindresvport.c: Ditto.
	* libc/sys/linux/net/byteorder.3: Ditto.
	* libc/sys/linux/net/ether_addr.c: Ditto.
	* libc/sys/linux/net/ethers.3: Ditto.
	* libc/sys/linux/net/getaddrinfo.3: Ditto.
	* libc/sys/linux/net/getaddrinfo.c: Ditto.
	* libc/sys/linux/net/gethostbydns.c: Ditto.
	* libc/sys/linux/net/gethostbyht.c: Ditto.
	* libc/sys/linux/net/gethostbyname.3: Ditto.
	* libc/sys/linux/net/gethostbynis.c: Ditto.
	* libc/sys/linux/net/gethostnamadr.c: Ditto.
	* libc/sys/linux/net/getifaddrs.3: Ditto.
	* libc/sys/linux/net/getifaddrs.c: Ditto.
	* libc/sys/linux/net/getipnodebyname.3: Ditto.
	* libc/sys/linux/net/getnameinfo.3: Ditto.
	* libc/sys/linux/net/getnameinfo.c: Ditto.
	* libc/sys/linux/net/getnetbydns.c: Ditto.
	* libc/sys/linux/net/getnetbyht.c: Ditto.
	* libc/sys/linux/net/getnetbynis.c: Ditto.
	* libc/sys/linux/net/getnetent.3: Ditto.
	* libc/sys/linux/net/getnetnamadr.c: Ditto.
	* libc/sys/linux/net/getproto.c: Ditto.
	* libc/sys/linux/net/getprotoent.3: Ditto.
	* libc/sys/linux/net/getprotoent.c: Ditto.
	* libc/sys/linux/net/getprotoname.c: Ditto.
	* libc/sys/linux/net/getservbyname.c: Ditto.
	* libc/sys/linux/net/getservbyport.c: Ditto.
	* libc/sys/linux/net/getservent.3: Ditto.
	* libc/sys/linux/net/getservent.c: Ditto.
	* libc/sys/linux/net/herror.c: Ditto.
	* libc/sys/linux/net/hesiod.3: Ditto.
	* libc/sys/linux/net/hesiod.c: Ditto.
	* libc/sys/linux/net/if_indextoname.3: Ditto.
	* libc/sys/linux/net/ifname.c: Ditto.
	* libc/sys/linux/net/inet.3: Ditto.
	* libc/sys/linux/net/inet6_option_s: Ditto.pace.3
	* libc/sys/linux/net/inet6_rthdr_space.3: Ditto.
	* libc/sys/linux/net/inet_addr.c: Ditto.
	* libc/sys/linux/net/inet_lnaof.c: Ditto.
	* libc/sys/linux/net/inet_makeaddr.c: Ditto.
	* libc/sys/linux/net/inet_net.3: Ditto.
	* libc/sys/linux/net/inet_net_ntop.c: Ditto.
	* libc/sys/linux/net/inet_net_pton.c: Ditto.
	* libc/sys/linux/net/inet_neta.c: Ditto.
	* libc/sys/linux/net/inet_netof.c: Ditto.
	* libc/sys/linux/net/inet_network.c: Ditto.
	* libc/sys/linux/net/inet_ntoa.c: Ditto.
	* libc/sys/linux/net/inet_ntop.c: Ditto.
	* libc/sys/linux/net/inet_pton.c: Ditto.
	* libc/sys/linux/net/innetgr-stub.c: Ditto.
	* libc/sys/linux/net/ip6opt.c: Ditto.
	* libc/sys/linux/net/iso_addr.3: Ditto.
	* libc/sys/linux/net/iso_addr.c: Ditto.
	* libc/sys/linux/net/issetugid-stub.c: Ditto.
	* libc/sys/linux/net/linkaddr.3: Ditto.
	* libc/sys/linux/net/linkaddr.c: Ditto.
	* libc/sys/linux/net/map_v4v6.c: Ditto.
	* libc/sys/linux/net/name6.c: Ditto.
	* libc/sys/linux/net/namespace.h: Ditto.
	* libc/sys/linux/net/ns.3: Ditto.
	* libc/sys/linux/net/ns_addr.c: Ditto.
	* libc/sys/linux/net/ns_name.c: Ditto.
	* libc/sys/linux/net/ns_netint.c: Ditto.
	* libc/sys/linux/net/ns_ntoa.c: Ditto.
	* libc/sys/linux/net/ns_parse.c: Ditto.
	* libc/sys/linux/net/ns_print.c: Ditto.
	* libc/sys/linux/net/ns_ttl.c: Ditto.
	* libc/sys/linux/net/nsap_addr.c: Ditto.
	* libc/sys/linux/net/nsdispatch.3: Ditto.
	* libc/sys/linux/net/nsdispatch.c: Ditto.
	* libc/sys/linux/net/nslexer.c: Ditto.
	* libc/sys/linux/net/nslexer.l: Ditto.
	* libc/sys/linux/net/nsparser.c: Ditto.
	* libc/sys/linux/net/nsparser.h: Ditto.
	* libc/sys/linux/net/nsparser.y: Ditto.
	* libc/sys/linux/net/rcmd.3: Ditto.
	* libc/sys/linux/net/rcmd.c: Ditto.
	* libc/sys/linux/net/rcmdsh.3: Ditto.
	* libc/sys/linux/net/rcmdsh.c: Ditto.
	* libc/sys/linux/net/recv.c: Ditto.
	* libc/sys/linux/net/res_comp.c: Ditto.
	* libc/sys/linux/net/res_config.h: Ditto.
	* libc/sys/linux/net/res_data.c: Ditto.
	* libc/sys/linux/net/res_debug.c: Ditto.
	* libc/sys/linux/net/res_init.c: Ditto.
	* libc/sys/linux/net/res_mkquery.c: Ditto.
	* libc/sys/linux/net/res_mkupdate.c: Ditto.
	* libc/sys/linux/net/res_query.c: Ditto.
	* libc/sys/linux/net/res_send.c: Ditto.
	* libc/sys/linux/net/res_update.c: Ditto.
	* libc/sys/linux/net/resolver.3: Ditto.
	* libc/sys/linux/net/rthdr.c: Ditto.
	* libc/sys/linux/net/send.c: Ditto.
	* libc/sys/linux/net/un-namespace.h: Ditto.
	* libc/sys/linux/net/vars.c: Ditto.
	* libc/sys/linux/stdlib/COPYRIGHT: Ditto.
	* libc/sys/linux/stdlib/Makefile.am: Ditto.
	* libc/sys/linux/stdlib/Makefile.in: Ditto.
	* libc/sys/linux/stdlib/cclass.h: Ditto.
	* libc/sys/linux/stdlib/cname.h: Ditto.
	* libc/sys/linux/stdlib/collate.c: Ditto.
	* libc/sys/linux/stdlib/collate.h: Ditto.
	* libc/sys/linux/stdlib/collcmp.c: Ditto.
	* libc/sys/linux/stdlib/engine.c: Ditto.
	* libc/sys/linux/stdlib/fnmatch.3: Ditto.
	* libc/sys/linux/stdlib/fnmatch.c: Ditto.
	* libc/sys/linux/stdlib/glob.3: Ditto.
	* libc/sys/linux/stdlib/glob.c: Ditto.
	* libc/sys/linux/stdlib/reallocf.c: Ditto.
	* libc/sys/linux/stdlib/regcomp.c: Ditto.
	* libc/sys/linux/stdlib/regerror.c: Ditto.
	* libc/sys/linux/stdlib/regex.3: Ditto.
	* libc/sys/linux/stdlib/regex2.h: Ditto.
	* libc/sys/linux/stdlib/regexec.c: Ditto.
	* libc/sys/linux/stdlib/regfree.c: Ditto.
	* libc/sys/linux/stdlib/utils.h: Ditto.
	* libc/sys/linux/stdlib/wordexp.c: Ditto.
	* libc/sys/linux/stdlib/wordfree.c: Ditto.
	* libc/sys/linux/sys/dlfcn.h: Ditto.
	* libc/sys/linux/sys/elfclass.h: Ditto.
	* libc/sys/linux/sys/event.h: Ditto.
	* libc/sys/linux/sys/ioccom.h: Ditto.
	* libc/sys/linux/sys/libc-tsd.h: Ditto.
	* libc/sys/linux/sys/link.h: Ditto.
	* libc/sys/linux/sys/lock.h: Ditto.
	* libc/sys/linux/sys/param.h: Ditto.
	* libc/sys/linux/sys/socket.h: Ditto.
	* libc/sys/linux/sys/sockio.h: Ditto.
@
text
@d4 1
a4 1
 * 
a12 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
d16 1
a16 1
 * 
d32 1
a32 1
 * 
d39 1
a39 1
 * 
d51 1
a51 1
 * Portions Copyright (c) 1996 by Internet Software Consortium.
d68 2
a69 2
static char sccsid[] = "@@(#)res_send.c	8.1 (Berkeley) 6/4/93";
static char orig_rcsid[] = "From: Id: res_send.c,v 8.20 1998/04/06 23:27:51 halley Exp $";
a70 3
#include <sys/cdefs.h>
#include <sys/types.h>
#include <machine/endian.h>
d72 1
d77 1
a78 2
#include <sys/event.h>
#include <sys/poll.h>
d83 1
d88 1
d91 1
d94 1
d99 7
a106 1
#include "res_config.h"
d108 19
a126 34
static int s = -1;		/* socket used for communications */
static int connected = 0;	/* is the socket connected */
static int vc = 0;		/* is the socket a virtual circuit? */
static int af = 0;		/* address family of socket */
static res_send_qhook Qhook = NULL;
static res_send_rhook Rhook = NULL;


#define CAN_RECONNECT 1

#ifndef DEBUG
#   define Dprint(cond, args) /*empty*/
#   define DprintQ(cond, args, query, size) /*empty*/
#   define Aerror(file, string, error, address) /*empty*/
#   define Perror(file, string, error) /*empty*/
#else
#   define Dprint(cond, args) if (cond) {fprintf args;} else {}
#   define DprintQ(cond, args, query, size) if (cond) {\
			fprintf args;\
			__fp_nquery(query, size, stdout);\
		} else {}
static char abuf[NI_MAXHOST];
static char pbuf[NI_MAXSERV];
static void Aerror(FILE *, char *, int, struct sockaddr *);
static void Perror(FILE *, char *, int);

    static void
    Aerror(file, string, error, address)
	FILE *file;
	char *string;
	int error;
	struct sockaddr *address;
    {
	int save = errno;
d128 10
a137 19
	if (_res.options & RES_DEBUG) {
		if (getnameinfo(address, 0, abuf, sizeof(abuf),
		    pbuf, sizeof(pbuf),
		    NI_NUMERICHOST|NI_NUMERICSERV|NI_WITHSCOPEID) != 0) {
			strncpy(abuf, "?", sizeof(abuf));
			strncpy(pbuf, "?", sizeof(pbuf));
		}
		fprintf(file, "res_send: %s ([%s].%s): %s\n",
			string, abuf, pbuf, strerror(error));
	}
	errno = save;
    }
    static void
    Perror(file, string, error)
	FILE *file;
	char *string;
	int error;
    {
	int save = errno;
d139 10
a148 3
	if (_res.options & RES_DEBUG) {
		fprintf(file, "res_send: %s: %s\n",
			string, strerror(error));
d150 1
a150 3
	errno = save;
    }
#endif
d152 8
a159 4
void
res_send_setqhook(hook)
	res_send_qhook hook;
{
d161 8
a168 1
	Qhook = hook;
a170 4
void
res_send_setrhook(hook)
	res_send_rhook hook;
{
d172 19
a190 2
	Rhook = hook;
}
d192 1
a192 1
static struct sockaddr * get_nsaddr(size_t);
d194 2
a195 7
/*
 * pick appropriate nsaddr_list for use.  see res_init() for initialization.
 */
static struct sockaddr *
get_nsaddr(n)
	size_t n;
{
d197 1
a197 16
	if (!_res.nsaddr_list[n].sin_family) {
		/*
		 * - _res_ext.nsaddr_list[n] holds an address that is larger
		 *   than struct sockaddr, and
		 * - user code did not update _res.nsaddr_list[n].
		 */
		return (struct sockaddr *)&_res_ext.nsaddr_list[n];
	} else {
		/*
		 * - user code updated _res.nsaddr_list[n], or
		 * - _res.nsaddr_list[n] has the same content as
		 *   _res_ext.nsaddr_list[n].
		 */
		return (struct sockaddr *)&_res.nsaddr_list[n];
	}
}
d209 1
a209 2
res_isourserver(inp)
	const struct sockaddr_in *inp;
d211 30
a240 35
	const struct sockaddr_in6 *in6p = (const struct sockaddr_in6 *)inp;
	const struct sockaddr_in6 *srv6;
	const struct sockaddr_in *srv;
	int ns, ret;

	ret = 0;
	switch (inp->sin_family) {
	case AF_INET6:
		for (ns = 0; ns < _res.nscount; ns++) {
			srv6 = (struct sockaddr_in6 *)get_nsaddr(ns);
			if (srv6->sin6_family == in6p->sin6_family &&
			    srv6->sin6_port == in6p->sin6_port &&
			    srv6->sin6_scope_id == in6p->sin6_scope_id &&
			    (IN6_IS_ADDR_UNSPECIFIED(&srv6->sin6_addr) ||
			     IN6_ARE_ADDR_EQUAL(&srv6->sin6_addr,
			         &in6p->sin6_addr))) {
				ret++;
				break;
			}
		}
		break;
	case AF_INET:
		for (ns = 0; ns < _res.nscount; ns++) {
			srv = (struct sockaddr_in *)get_nsaddr(ns);
			if (srv->sin_family == inp->sin_family &&
			    srv->sin_port == inp->sin_port &&
			    (srv->sin_addr.s_addr == INADDR_ANY ||
			     srv->sin_addr.s_addr == inp->sin_addr.s_addr)) {
				ret++;
				break;
			}
		}
		break;
	}
	return (ret);
d256 2
a257 4
res_nameinquery(name, type, class, buf, eom)
	const char *name;
	int type, class;
	const u_char *buf, *eom;
d274 2
a275 3
		if (ttype == type &&
		    tclass == class &&
		    strcasecmp(tname, name) == 0)
d280 1
d294 2
a295 3
res_queriesmatch(buf1, eom1, buf2, eom2)
	const u_char *buf1, *eom1;
	const u_char *buf2, *eom2;
d307 2
a308 2
	if ( (((HEADER *)buf1)->opcode == ns_o_update) &&
	     (((HEADER *)buf2)->opcode == ns_o_update) )
d330 1
d333 2
a334 5
res_send(buf, buflen, ans, anssiz)
	const u_char *buf;
	int buflen;
	u_char *ans;
	int anssiz;
d336 1
a336 5
	HEADER *hp = (HEADER *) buf;
	HEADER *anhp = (HEADER *) ans;
	int gotsomewhere, connreset, terrno, try, v_circuit, resplen, ns, n;
	int kq;
	u_int badns;	/* XXX NSMAX can't exceed #/bits in this variable */
d338 2
a339 2
	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
		/* errno should have been set by res_init() in this case. */
d342 1
d344 1
a344 1
		errno = EINVAL;
d347 12
a358 1
	DprintQ((_res.options & RES_DEBUG) || (_res.pfcode & RES_PRF_QUERY),
d360 1
a360 1
	v_circuit = (_res.options & RES_USEVC) || buflen > PACKETSZ;
a361 1
	connreset = 0;
a362 1
	badns = 0;
d365 2
a366 1
	 * Send request, RETRY times, or until successful
d368 5
a372 9
	for (try = 0; try < _res.retry; try++) {
	    for (ns = 0; ns < _res.nscount; ns++) {
		struct sockaddr *nsap = get_nsaddr(ns);
		socklen_t salen;

		if (nsap->sa_family == AF_INET6)
			salen = sizeof(struct sockaddr_in6);
		else if (nsap->sa_family == AF_INET)
			salen = sizeof(struct sockaddr_in);
d374 60
a433 1
			salen = 0;	/*unknown, die on connect*/
d435 28
a462 4
    same_ns:
		if (badns & (1 << ns)) {
			res_close();
			goto next_ns;
d464 9
d474 4
a477 1
		if (Qhook) {
d483 5
a487 3
				act = (*Qhook)((struct sockaddr_in **)&nsap,
					       &buf, &buflen,
					       ans, anssiz, &resplen);
d493 1
a493 1
					res_close();
a495 1
					close(kq);
a504 1
					close(kq);
d510 4
a513 3
		Dprint((_res.options & RES_DEBUG) &&
		       getnameinfo(nsap, salen, abuf, sizeof(abuf),
			   NULL, 0, NI_NUMERICHOST | NI_WITHSCOPEID) == 0,
d515 2
a516 1
			ns + 1, abuf));
d519 7
a525 63
			int truncated;
			u_short len;
			u_char *cp;
			ssize_t rc;

			/*
			 * Use virtual circuit;
			 * at most one attempt per server.
			 */
			try = _res.retry;
			truncated = 0;
			if (s < 0 || !vc || hp->opcode == ns_o_update ||
			    af != nsap->sa_family) {
				if (s >= 0)
					res_close();

				af = nsap->sa_family;
				s = socket(af, SOCK_STREAM, 0);
				if (s < 0) {
					terrno = errno;
					Perror(stderr, "socket(vc)", errno);
					badns |= (1 << ns);
					res_close();
					goto next_ns;
				}
				errno = 0;
				if (connect(s, nsap, salen) < 0) {
					terrno = errno;
					Aerror(stderr, "connect/vc",
					       errno, nsap);
					badns |= (1 << ns);
					res_close();
					goto next_ns;
				}
				vc = 1;
			}
			/*
			 * Send length & message
			 */
			putshort((u_short)buflen, (u_char*)&len);
#if !defined(_ELIX_LEVEL) || _ELIX_LEVEL >= 2
			{
			struct iovec iov[2];
			iov[0].iov_base = (caddr_t)&len;
			iov[0].iov_len = INT16SZ;
			iov[1].iov_base = (caddr_t)buf;
			iov[1].iov_len = buflen;
			rc = writev(s, iov, 2);
			}
#else /* EL/IX level 1 */
			{
			char *tmpbuf;
			tmpbuf = malloc (INT16SZ + buflen);
			memcpy (tmpbuf, &len, INT16SZ);
			memcpy (tmpbuf + INT16SZ, buf, buflen);
			rc = write (s, tmpbuf, INT16SZ + buflen);
			}
#endif /* EL/IX level 1 */
			if (rc != (INT16SZ + buflen)) {
				terrno = errno;
				Perror(stderr, "write failed", errno);
				badns |= (1 << ns);
				res_close();
d527 8
a534 31
			}
			/*
			 * Receive length & response
			 */
 read_len:
			cp = ans;
			len = INT16SZ;
			while ((n = read(s, (char *)cp, (int)len)) > 0) {
				cp += n;
				if ((len -= n) <= 0)
					break;
			}
			if (n <= 0) {
				terrno = errno;
				Perror(stderr, "read failed", errno);
				res_close();
				/*
				 * A long running process might get its TCP
				 * connection reset if the remote server was
				 * restarted.  Requery the server instead of
				 * trying a new one.  When there is only one
				 * server, this means that a query might work
				 * instead of failing.  We only allow one reset
				 * per query to prevent looping.
				 */
				if (terrno == ECONNRESET && !connreset) {
					connreset = 1;
					res_close();
					goto same_ns;
				}
				res_close();
d536 4
a539 134
			}
			resplen = ns_get16(ans);
			if (resplen > anssiz) {
				Dprint(_res.options & RES_DEBUG,
				       (stdout, ";; response truncated\n")
				       );
				truncated = 1;
				len = anssiz;
			} else
				len = resplen;
			if (len < HFIXEDSZ) {
				/*
				 * Undersized message.
				 */
				Dprint(_res.options & RES_DEBUG,
				       (stdout, ";; undersized: %d\n", len));
				terrno = EMSGSIZE;
				badns |= (1 << ns);
				res_close();
				goto next_ns;
			}
			cp = ans;
			while (len != 0 &&
			       (n = read(s, (char *)cp, (int)len)) > 0) {
				cp += n;
				len -= n;
			}
			if (n <= 0) {
				terrno = errno;
				Perror(stderr, "read(vc)", errno);
				res_close();
				goto next_ns;
			}
			if (truncated) {
				/*
				 * Flush rest of answer
				 * so connection stays in synch.
				 */
				anhp->tc = 1;
				len = resplen - anssiz;
				while (len != 0) {
					char junk[PACKETSZ];

					n = (len > sizeof(junk)
					     ? sizeof(junk)
					     : len);
					if ((n = read(s, junk, n)) > 0)
						len -= n;
					else
						break;
				}
			}
			/*
			 * The calling applicating has bailed out of
			 * a previous call and failed to arrange to have
			 * the circuit closed or the server has got
			 * itself confused. Anyway drop the packet and
			 * wait for the correct one.
			 */
			if (hp->id != anhp->id) {
				DprintQ((_res.options & RES_DEBUG) ||
					(_res.pfcode & RES_PRF_REPLY),
					(stdout, ";; old answer (unexpected):\n"),
					ans, (resplen>anssiz)?anssiz:resplen);
				goto read_len;
			}
		} else {
			/*
			 * Use datagrams.
			 */
			struct pollfd pfd[1];
			int ptimeout;
			struct timespec ts;
			struct timeval timeout, ctv;
			struct sockaddr_storage from;
			int fromlen;

			if (s < 0 || vc || af != nsap->sa_family) {
				if (vc)
					res_close();
				af = nsap->sa_family;
				s = socket(af, SOCK_DGRAM, 0);
				if (s < 0) {
#ifndef CAN_RECONNECT
 bad_dg_sock:
#endif
					terrno = errno;
					Perror(stderr, "socket(dg)", errno);
					badns |= (1 << ns);
					res_close();
					goto next_ns;
				}
				connected = 0;
			}
#ifndef CANNOT_CONNECT_DGRAM
			/*
			 * On a 4.3BSD+ machine (client and server,
			 * actually), sending to a nameserver datagram
			 * port with no nameserver will cause an
			 * ICMP port unreachable message to be returned.
			 * If our datagram socket is "connected" to the
			 * server, we get an ECONNREFUSED error on the next
			 * socket operation, and select returns if the
			 * error message is received.  We can thus detect
			 * the absence of a nameserver without timing out.
			 * If we have sent queries to at least two servers,
			 * however, we don't want to remain connected,
			 * as we wish to receive answers from the first
			 * server to respond.
			 *
			 * When the option "insecure1" is specified, we'd
			 * rather expect to see responses from an "unknown"
			 * address.  In order to let the kernel accept such
			 * responses, do not connect the socket here.
			 * XXX: or do we need an explicit option to disable
			 * connecting?
			 */
			if (!(_res.options & RES_INSECURE1) &&
			    (_res.nscount == 1 || (try == 0 && ns == 0))) {
				/*
				 * Connect only if we are sure we won't
				 * receive a response from another server.
				 */
				if (!connected) {
					if (connect(s, nsap, salen) < 0) {
						Aerror(stderr,
						       "connect(dg)",
						       errno, nsap);
						badns |= (1 << ns);
						res_close();
						goto next_ns;
					}
					connected = 1;
				}
d541 4
a544 73
				if (send(s, (char*)buf, buflen, 0) != buflen) {
					Perror(stderr, "send", errno);
					badns |= (1 << ns);
					res_close();
					goto next_ns;
				}
			} else {
				/*
				 * Disconnect if we want to listen
				 * for responses from more than one server.
				 */
				if (connected) {
#ifdef CAN_RECONNECT
					/* XXX: any errornous address */
					struct sockaddr_in no_addr;

					no_addr.sin_family = AF_INET;
					no_addr.sin_addr.s_addr = INADDR_ANY;
					no_addr.sin_port = 0;
					(void) connect(s,
						       (struct sockaddr *)
						        &no_addr,
						       sizeof no_addr);
#else
					int s1 = socket(af, SOCK_DGRAM,0);
					if (s1 < 0)
						goto bad_dg_sock;
					(void)_dup2(s1, s);
					(void)close(s1);
					Dprint(_res.options & RES_DEBUG,
						(stdout, ";; new DG socket\n"))
#endif /* CAN_RECONNECT */
					connected = 0;
					errno = 0;
				}
#endif /* !CANNOT_CONNECT_DGRAM */
				if (sendto(s, (char*)buf, buflen, 0,
					   nsap, salen) != buflen) {
					Aerror(stderr, "sendto", errno, nsap);
					badns |= (1 << ns);
					res_close();
					goto next_ns;
				}
#ifndef CANNOT_CONNECT_DGRAM
			}
#endif /* !CANNOT_CONNECT_DGRAM */

			/*
			 * Wait for reply
			 */

			timeout.tv_sec = (_res.retrans << try);
			if (try > 0)
				timeout.tv_sec /= _res.nscount;
			if ((long) timeout.tv_sec <= 0)
				timeout.tv_sec = 1;
			timeout.tv_usec = 0;
			TIMEVAL_TO_TIMESPEC(&timeout, &ts);
			(void) gettimeofday(&ctv, NULL);
			timeradd(&timeout, &ctv, &timeout);

		       /* Convert struct timespec in milliseconds.  */
		       ptimeout = timeout.tv_sec * 1000 + timeout.tv_usec / 1000;
    wait:
		       pfd[0].fd = s;
		       pfd[0].events = POLLIN;
		       n = poll (pfd, 1, ptimeout);

			if (s < 0) {
				Perror(stderr, "s out-of-bounds", EMFILE);
				res_close();
				goto next_ns;
			}
d546 4
a549 13
			if (n < 0) {
				if (errno == EINTR) {
					(void) gettimeofday(&ctv, NULL);
					if (timercmp(&ctv, &timeout, <)) {
						timersub(&timeout, &ctv, &ctv);
						TIMEVAL_TO_TIMESPEC(&ctv, &ts);
						goto wait;
					}
				}
				Perror(stderr, "poll", errno);
				res_close();
				goto next_ns;
			}
a550 107
			if (n == 0) {
				/*
				 * timeout
				 */
				Dprint(_res.options & RES_DEBUG,
				       (stdout, ";; timeout\n"));
				gotsomewhere = 1;
				res_close();
				goto next_ns;
			}
			errno = 0;
			fromlen = sizeof(from);
			resplen = recvfrom(s, (char*)ans, anssiz, 0,
					   (struct sockaddr *)&from, &fromlen);
			if (resplen <= 0) {
				Perror(stderr, "recvfrom", errno);
				res_close();
				goto next_ns;
			}
			gotsomewhere = 1;
			if (resplen < HFIXEDSZ) {
				/*
				 * Undersized message.
				 */
				Dprint(_res.options & RES_DEBUG,
				       (stdout, ";; undersized: %d\n",
					resplen));
				terrno = EMSGSIZE;
				badns |= (1 << ns);
				res_close();
				goto next_ns;
			}
			if (hp->id != anhp->id) {
				/*
				 * response from old query, ignore it.
				 * XXX - potential security hazard could
				 *	 be detected here.
				 */
				DprintQ((_res.options & RES_DEBUG) ||
					(_res.pfcode & RES_PRF_REPLY),
					(stdout, ";; old answer:\n"),
					ans, (resplen>anssiz)?anssiz:resplen);
				goto wait;
			}
#ifdef CHECK_SRVR_ADDR
			if (!(_res.options & RES_INSECURE1) &&
			    !res_isourserver((struct sockaddr_in *)&from)) {
				/*
				 * response from wrong server? ignore it.
				 * XXX - potential security hazard could
				 *	 be detected here.
				 */
				DprintQ((_res.options & RES_DEBUG) ||
					(_res.pfcode & RES_PRF_REPLY),
					(stdout, ";; not our server:\n"),
					ans, (resplen>anssiz)?anssiz:resplen);
				goto wait;
			}
#endif
			if (!(_res.options & RES_INSECURE2) &&
			    !res_queriesmatch(buf, buf + buflen,
					      ans, ans + anssiz)) {
				/*
				 * response contains wrong query? ignore it.
				 * XXX - potential security hazard could
				 *	 be detected here.
				 */
				DprintQ((_res.options & RES_DEBUG) ||
					(_res.pfcode & RES_PRF_REPLY),
					(stdout, ";; wrong query name:\n"),
					ans, (resplen>anssiz)?anssiz:resplen);
				goto wait;
			}
			if (anhp->rcode == SERVFAIL ||
			    anhp->rcode == NOTIMP ||
			    anhp->rcode == REFUSED) {
				DprintQ(_res.options & RES_DEBUG,
					(stdout, "server rejected query:\n"),
					ans, (resplen>anssiz)?anssiz:resplen);
				badns |= (1 << ns);
				res_close();
				/* don't retry if called from dig */
				if (!_res.pfcode)
					goto next_ns;
			}
			if (!(_res.options & RES_IGNTC) && anhp->tc) {
				/*
				 * get rest of answer;
				 * use TCP with same server.
				 */
				Dprint(_res.options & RES_DEBUG,
				       (stdout, ";; truncated answer\n"));
				v_circuit = 1;
				res_close();
				goto same_ns;
			}
		} /*if vc/dg*/
		Dprint((_res.options & RES_DEBUG) ||
		       ((_res.pfcode & RES_PRF_REPLY) &&
			(_res.pfcode & RES_PRF_HEAD1)),
		       (stdout, ";; got answer:\n"));
#if 0
		DprintQ((_res.options & RES_DEBUG) ||
			(_res.pfcode & RES_PRF_REPLY),
			(stdout, ""),
			ans, (resplen>anssiz)?anssiz:resplen);
#endif
a551 3
		 * If using virtual circuits, we assume that the first server
		 * is preferred over the rest (i.e. it is on the local
		 * machine) and only keep that one open.
d556 3
a558 3
		if ((v_circuit && (!(_res.options & RES_USEVC) || ns != 0)) ||
		    !(_res.options & RES_STAYOPEN)) {
			res_close();
d560 1
a560 1
		if (Rhook) {
d566 3
a568 3
				act = (*Rhook)((struct sockaddr_in *)nsap,
					       buf, buflen,
					       ans, anssiz, &resplen);
d575 1
a575 1
					res_close();
a584 1
					close(kq);
a589 1
		close(kq);
d591 1
a591 1
    next_ns: ;
d594 1
a594 2
	res_close();
	close(kq);
d597 1
a597 1
			errno = ECONNREFUSED;	/* no nameservers found */
d599 1
a599 1
			errno = ETIMEDOUT;	/* no answer obtained */
d601 1
a601 1
		errno = terrno;
d605 439
a1043 9
/*
 * This routine is for closing the socket if a virtual circuit is used and
 * the program wants to close it.  This provides support for endhostent()
 * which expects to close the socket.
 *
 * This routine is not expected to be user visible.
 */
void
res_close()
d1045 42
a1086 6
	if (s >= 0) {
		(void)close(s);
		s = -1;
		connected = 0;
		vc = 0;
		af = 0;
d1088 9
d1100 2
a1101 2
 * Weak aliases for applications that use certain private entry points,
 * and fail to include <resolv.h>.
d1103 14
a1116 4
#undef res_close
__weak_reference(__res_close, _res_close);
#undef res_send
__weak_reference(__res_send, res_send);
@

