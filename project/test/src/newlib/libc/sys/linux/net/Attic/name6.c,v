head	1.3;
access;
symbols
	newlib-1_16_0:1.2
	newlib-1_15_0:1.2
	newlib-csl-coldfire-4_1-32:1.1
	newlib-csl-sourcerygxx-4_1-32:1.1
	newlib-csl-innovasic-fido-3_4_4-33:1.1
	newlib-csl-coldfire-4_1-30:1.1
	newlib-csl-sourcerygxx-4_1-30:1.1
	newlib-csl-coldfire-4_1-28:1.1
	newlib-csl-sourcerygxx-4_1-28:1.1
	newlib-csl-arm-2006q3-27:1.1
	newlib-csl-sourcerygxx-4_1-27:1.1
	newlib-csl-arm-2006q3-26:1.1
	newlib-csl-sourcerygxx-4_1-26:1.1
	newlib-csl-sourcerygxx-4_1-24:1.1
	newlib-csl-sourcerygxx-4_1-23:1.1
	newlib-csl-sourcerygxx-4_1-21:1.1
	newlib-csl-arm-2006q3-21:1.1
	newlib-csl-arm-2006q3-19:1.1
	newlib-csl-sourcerygxx-4_1-19:1.1
	newlib-csl-sourcerygxx-4_1-18:1.1
	newlib-csl-sourcerygxx-3_4_4-25:1.2
	newlib-csl-sourcerygxx-4_1-17:1.1
	cr-0x5f1:1.2.0.4
	newlib-csl-sourcerygxx-4_1-14:1.1
	newlib-csl-sourcerygxx-4_1-13:1.1
	newlib-csl-sourcerygxx-4_1-12:1.1
	newlib-csl-sourcerygxx-4_1-9:1.1
	newlib-csl-sourcerygxx-4_1-8:1.1
	newlib-csl-sourcerygxx-4_1-7:1.1
	newlib-csl-arm-2006q1-6:1.1
	newlib-csl-sourcerygxx-4_1-6:1.1
	newlib-csl-sourcerygxx-4_1-5:1.1
	newlib-csl-sourcerygxx-4_1-4:1.1
	newlib-autotools-branch:1.2.0.2
	newlib-csl-20060320-branch:1.1.0.2
	newlib-csl-20060320-branchpoint:1.1
	newlib-1_14_0:1.1
	newlib-csl-arm-2005-q1b:1.1
	newlib-csl-arm-2005-q1a:1.1
	newlib-1_13_0:1.1
	csl-arm-2004-q3:1.1
	csl-arm-2004-q1a:1.1
	csl-arm-2004-q1:1.1
	newlib-1_12_0:1.1
	csl-arm-2003-q4:1.1;
locks; strict;
comment	@ * @;


1.3
date	2008.05.22.21.30.27;	author jjohnstn;	state dead;
branches;
next	1.2;

1.2
date	2006.03.29.21.45.17;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.28.22.04.39;	author jjohnstn;	state Exp;
branches;
next	;


desc
@@


1.3
log
@
2008-05-22  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/include/sys/reent.h: Add _h_errno field.
	* libc/sys/linux/libc-symbols.h: Add default stubs for new libc macros
	now used in net directory.
	* libc/sys/linux/bits/libc-lock.h: Always define _IO_MTSAFE_IO.
	* libc/sys/linux/include/hesiod.h: Add needed macros for new code
	in net directory.
	* libc/sys/linux/include/netdb.h: Ditto.
	* libc/sys/linux/include/resolv.h: Ditto.
	* libc/sys/linux/include/stdint.h: Ditto.
	* libc/sys/linux/include/arpa/nameser.h: Ditto.
	* libc/sys/linux/include/net/ethernet.h: Ditto.
	* libc/sys/linux/include/net/if_ppp.h: Ditto.
	* libc/sys/linux/include/netinet/if_ether.h: Ditto.
	* libc/sys/linux/machine/i386/get_clockfreq.c: Remove static memmem.
	* libc/sys/linux/machine/i386/include/endian.h: Protect macros with
	flags to avoid duplicate definition.
	* libc/sys/linux/machine/i386/include/param.h: Ditto.
	* libc/sys/linux/net/Makefile.am: Modified to account for removed and
	added files.
	* libc/sys/linux/net/Makefile.in: Regenerated.
	* libc/sys/linux/net/base64.c: Replaced with glibc version of code.
	* libc/sys/linux/net/getaddrinfo.c: Ditto.
	* libc/sys/linux/net/getnameinfo.c: Ditto.
	* libc/sys/linux/net/getproto.c: Ditto.
	* libc/sys/linux/net/getservent.c: Ditto.
	* libc/sys/linux/net/inet_netof.c: Ditto.
	* libc/sys/linux/net/inet_lnaof.c: Ditto.
	* libc/sys/linux/net/ns_name.c: Ditto.
	* libc/sys/linux/net/ns_netint.c: Ditto.
	* libc/sys/linux/net/inet_ntoa.c: Ditto.
	* libc/sys/linux/net/ns_parse.c: Ditto.
	* libc/sys/linux/net/ns_print.c: Ditto.
	* libc/sys/linux/net/ns_ttl.c: Ditto.
	* libc/sys/linux/net/nsap_addr.c: Ditto.
	* libc/sys/linux/net/rcmd.c: Ditto.
	* libc/sys/linux/net/res_comp.c: Ditto.
	* libc/sys/linux/net/res_data.c: Ditto.
	* libc/sys/linux/net/res_debug.c: Ditto.
	* libc/sys/linux/net/res_init.c: Ditto.
	* libc/sys/linux/net/res_mkquery.c: Ditto.
	* libc/sys/linux/net/res_query.c: Ditto.
	* libc/sys/linux/net/res_send.c: Ditto.
	* libc/sys/linux/net/send.c: Ditto.
	* libc/sys/linux/stdlib/collate.c: Ditto.
	* libc/sys/linux/sys/ioctl.h: Ditto.
	* libc/sys/linux/sys/socket.h: Ditto.
	* libc/sys/linux/sys/unistd.h: Ditto.
	* libc/sys/linux/iconv/iconvconfig.c: Removed either because no longer
	used or because licensing includes advertising clause that cannot be
	ignored.
	* libc/sys/linux/iconv/strtab.c: Ditto.
	* libc/sys/linux/include/libc_private.h: Ditto.
	* libc/sys/linux/include/nsswitch.h: Ditto.
	* libc/sys/linux/include/net/if_atm.h: Ditto.
	* libc/sys/linux/include/net/if_media.h: Ditto.
	* libc/sys/linux/include/net/if_pppvar.h: Ditto.
	* libc/sys/linux/include/netinet/if_atm.h: Ditto.
	* libc/sys/linux/include/netinet/ip_flow.h: Ditto.
	* libc/sys/linux/intl/locale.alias: Ditto.
	* libc/sys/linux/net/addr2ascii.3: Ditto.
	* libc/sys/linux/net/bindresvport.c: Ditto.
	* libc/sys/linux/net/byteorder.3: Ditto.
	* libc/sys/linux/net/res_config.h: Ditto.
	* libc/sys/linux/net/ether_addr.c: Ditto.
	* libc/sys/linux/net/ethers.3: Ditto.
	* libc/sys/linux/net/getaddrinfo.3: Ditto.
	* libc/sys/linux/net/gethostbydns.c: Ditto.
	* libc/sys/linux/net/gethostbyht.c: Ditto.
	* libc/sys/linux/net/gethostbyname.3: Ditto.
	* libc/sys/linux/net/gethostbynis.c: Ditto.
	* libc/sys/linux/net/gethostnamadr.c: Ditto.
	* libc/sys/linux/net/getifaddrs.3: Ditto.
	* libc/sys/linux/net/getifaddrs.c: Ditto.
	* libc/sys/linux/net/getipnodebyname.3: Ditto.
	* libc/sys/linux/net/getnameinfo.3: Ditto.
	* libc/sys/linux/net/getnetbydns.c: Ditto.
	* libc/sys/linux/net/getnetbyht.c: Ditto.
	* libc/sys/linux/net/getnetbynis.c: Ditto.
	* libc/sys/linux/net/getnetent.3: Ditto.
	* libc/sys/linux/net/getnetnamadr.c: Ditto.
	* libc/sys/linux/net/getprotoent.3: Ditto.
	* libc/sys/linux/net/getprotoent.c: Ditto.
	* libc/sys/linux/net/getprotoname.c: Ditto.
	* libc/sys/linux/net/getservbyname.c: Ditto.
	* libc/sys/linux/net/getservbyport.c: Ditto.
	* libc/sys/linux/net/getservent.3: Ditto.
	* libc/sys/linux/net/herror.c: Ditto.
	* libc/sys/linux/net/hesiod.3: Ditto.
	* libc/sys/linux/net/hesiod.c: Ditto.
	* libc/sys/linux/net/if_indextoname.3: Ditto.
	* libc/sys/linux/net/inet.3: Ditto.
	* libc/sys/linux/net/inet6_option_space.3: Ditto.
	* libc/sys/linux/net/inet6_rthdr_space.3: Ditto.
	* libc/sys/linux/net/inet_makeaddr.c: Ditto.
	* libc/sys/linux/net/inet_net.3: Ditto.
	* libc/sys/linux/net/inet_network.c: Ditto.
	* libc/sys/linux/net/innetgr-stub.c: Ditto.
	* libc/sys/linux/net/ip6opt.c: Ditto.
	* libc/sys/linux/net/iso_addr.3: Ditto.
	* libc/sys/linux/net/iso_addr.c: Ditto.
	* libc/sys/linux/net/linkaddr.3: Ditto.
	* libc/sys/linux/net/linkaddr.c: Ditto.
	* libc/sys/linux/net/map_v4v6.c: Ditto.
	* libc/sys/linux/net/name6.c: Ditto.
	* libc/sys/linux/net/namespace.h: Ditto.
	* libc/sys/linux/net/ns.3: Ditto.
	* libc/sys/linux/net/ns_addr.c: Ditto.
	* libc/sys/linux/net/ns_ntoa.c: Ditto.
	* libc/sys/linux/net/nsdispatch.3: Ditto.
	* libc/sys/linux/net/nsdispatch.c: Ditto.
	* libc/sys/linux/net/nslexer.c: Ditto.
	* libc/sys/linux/net/nslexer.l: Ditto.
	* libc/sys/linux/net/nsparser.c: Ditto.
	* libc/sys/linux/net/nsparser.h: Ditto.
	* libc/sys/linux/net/nsparser.y: Ditto.
	* libc/sys/linux/net/rcmd.3: Ditto.
	* libc/sys/linux/net/rcmdsh.3: Ditto.
	* libc/sys/linux/net/res_mkupdate.c: Ditto.
	* libc/sys/linux/net/res_update.c: Ditto.
	* libc/sys/linux/net/resolver.3: Ditto.
	* libc/sys/linux/net/rthdr.c: Ditto.
	* libc/sys/linux/net/vars.c: Ditto.
	* libc/sys/linux/shlib-compat.h: New file.
	* libc/sys/linux/machine/i386/atomic.h: Ditto.
	* libc/sys/linux/net/XXX-lookup.c: Ditto.
	* libc/sys/linux/net/alias-lookup.c: Ditto.
	* libc/sys/linux/net/res_libc.c: Ditto.
	* libc/sys/linux/net/aliases.h: Ditto.
	* libc/sys/linux/net/check_pf.c: Ditto.
	* libc/sys/linux/net/databases.def: Ditto.
	* libc/sys/linux/net/digits_dots.c: Ditto.
	* libc/sys/linux/net/ether_aton.c: Ditto.
	* libc/sys/linux/net/ether_aton_r.c: Ditto.
	* libc/sys/linux/net/ether_hton.c: Ditto.
	* libc/sys/linux/net/ether_line.c: Ditto.
	* libc/sys/linux/net/ether_ntoa.c: Ditto.
	* libc/sys/linux/net/ether_ntoa_r.c: Ditto.
	* libc/sys/linux/net/ether_ntoh.c: Ditto.
	* libc/sys/linux/net/etherent.h: Ditto.
	* libc/sys/linux/net/ethers-lookup.c: Ditto.
	* libc/sys/linux/net/function.def: Ditto.
	* libc/sys/linux/net/getXXbyYY.c: Ditto.
	* libc/sys/linux/net/getXXbyYY_r.c: Ditto.
	* libc/sys/linux/net/getXXent.c: Ditto.
	* libc/sys/linux/net/getXXent_r.c: Ditto.
	* libc/sys/linux/net/getaliasent.c: Ditto.
	* libc/sys/linux/net/getaliasent_r.c: Ditto.
	* libc/sys/linux/net/getaliasname.c: Ditto.
	* libc/sys/linux/net/getaliasname_r.c: Ditto.
	* libc/sys/linux/net/gethstbyad.c: Ditto.
	* libc/sys/linux/net/gethstbyad_r.c: Ditto.
	* libc/sys/linux/net/gethstbynm.c: Ditto.
	* libc/sys/linux/net/gethstbynm2.c: Ditto.
	* libc/sys/linux/net/gethstbynm2_r.c: Ditto.
	* libc/sys/linux/net/gethstbynm_r.c: Ditto.
	* libc/sys/linux/net/gethstent.c: Ditto.
	* libc/sys/linux/net/gethstent_r.c: Ditto.
	* libc/sys/linux/net/getnetbyad.c: Ditto.
	* libc/sys/linux/net/getnetbyad_r.c: Ditto.
	* libc/sys/linux/net/getnetbynm.c: Ditto.
	* libc/sys/linux/net/getnetbynm_r.c: Ditto.
	* libc/sys/linux/net/getnetent.c: Ditto.
	* libc/sys/linux/net/getnetent_r.c: Ditto.
	* libc/sys/linux/net/getnetgrent.c: Ditto.
	* libc/sys/linux/net/getnetgrent_r.c: Ditto.
	* libc/sys/linux/net/getnssent.c: Ditto.
	* libc/sys/linux/net/getnssent_r.c: Ditto.
	* libc/sys/linux/net/getproto_r.c: Ditto.
	* libc/sys/linux/net/getprtent.c: Ditto.
	* libc/sys/linux/net/getprtent_r.c: Ditto.
	* libc/sys/linux/net/getprtname.c: Ditto.
	* libc/sys/linux/net/getprtname_r.c: Ditto.
	* libc/sys/linux/net/getrpcbyname.c: Ditto.
	* libc/sys/linux/net/getrpcbyname_r.c: Ditto.
	* libc/sys/linux/net/getrpcbynumber.c: Ditto.
	* libc/sys/linux/net/getrpcbynumber_r.c: Ditto.
	* libc/sys/linux/net/getrpcent.c: Ditto.
	* libc/sys/linux/net/getrpcent_r.c: Ditto.
	* libc/sys/linux/net/getservent_r.c: Ditto.
	* libc/sys/linux/net/getsrvbynm.c: Ditto.
	* libc/sys/linux/net/getsrvbynm_r.c: Ditto.
	* libc/sys/linux/net/getsrvbypt.c: Ditto.
	* libc/sys/linux/net/getsrvbypt_r.c: Ditto.
	* libc/sys/linux/net/grp-lookup.c: Ditto.
	* libc/sys/linux/net/herrno.c: Ditto.
	* libc/sys/linux/net/hosts-lookup.c: Ditto.
	* libc/sys/linux/net/ifaddrs.h: Ditto.
	* libc/sys/linux/net/ifreq.c: Ditto.
	* libc/sys/linux/net/ifreq.h: Ditto.
	* libc/sys/linux/net/in6_addr.c: Ditto.
	* libc/sys/linux/net/inet6_option.c: Ditto.
	* libc/sys/linux/net/inet_mkadr.c: Ditto.
	* libc/sys/linux/net/inet_net.c: Ditto.
	* libc/sys/linux/net/key-lookup.c: Ditto.
	* libc/sys/linux/net/local.h: Ditto.
	* libc/sys/linux/net/netgroup.h: Ditto.
	* libc/sys/linux/net/netgrp-lookup.c: Ditto.
	* libc/sys/linux/net/network-lookup.c: Ditto.
	* libc/sys/linux/net/not-cancel.h: Ditto.
	* libc/sys/linux/net/ns_samedomain.c: Ditto.
	* libc/sys/linux/net/nscd-types.h: Ditto.
	* libc/sys/linux/net/nss.h: Ditto.
	* libc/sys/linux/net/nsswitch.c: Ditto.
	* libc/sys/linux/net/nsswitch.h: Ditto.
	* libc/sys/linux/net/opensock.c: Ditto.
	* libc/sys/linux/net/proto-lookup.c: Ditto.
	* libc/sys/linux/net/pwd-lookup.c: Ditto.
	* libc/sys/linux/net/res_debug.h: Ditto.
	* libc/sys/linux/net/res_hconf.c: Ditto.
	* libc/sys/linux/net/res_hconf.h: Ditto.
	* libc/sys/linux/net/rexec.c: Ditto.
	* libc/sys/linux/net/rpc-lookup.c: Ditto.
	* libc/sys/linux/net/ruserpass.c: Ditto.
	* libc/sys/linux/net/service-lookup.c: Ditto.
	* libc/sys/linux/net/spwd-lookup.c: Ditto.
	* libc/sys/linux/net/nscd/nscd-client.h: Ditto.
	* libc/sys/linux/net/nscd/nscd_proto.h: Ditto.
@
text
@/*	$KAME: name6.c,v 1.25 2000/06/26 16:44:40 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * ++Copyright++ 1985, 1988, 1993
 * -
 * Copyright (c) 1985, 1988, 1993
 *    The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 */

/*
 *	Atsushi Onoe <onoe@@sm.sony.co.jp>
 */

/*
 * TODO for thread safe
 *	use mutex for _hostconf, _hostconf_init.
 *	rewrite resolvers to be thread safe
 */

#include <sys/cdefs.h>
#include <sys/types.h>
#include <machine/endian.h>
#include <sys/types.h>
#include <unistd.h>

#include "namespace.h"
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <netinet/in.h>

#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <errno.h>
#include <netdb.h>
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <nsswitch.h>
#include <unistd.h>
#include "un-namespace.h"

#ifndef _PATH_HOSTS
#define	_PATH_HOSTS	"/etc/hosts"
#endif

#ifndef MAXALIASES
#define	MAXALIASES	35
#endif
#ifndef	MAXADDRS
#define	MAXADDRS	2
#endif
#ifndef MAXDNAME
#define	MAXDNAME	1025
#endif

#ifdef INET6
#define	ADDRLEN(af)	((af) == AF_INET6 ? sizeof(struct in6_addr) : \
					    sizeof(struct in_addr))
#else
#define	ADDRLEN(af)	sizeof(struct in_addr)
#endif

#define	MAPADDR(ab, ina) \
do {									\
	memcpy(&(ab)->map_inaddr, ina, sizeof(struct in_addr));		\
	memset((ab)->map_zero, 0, sizeof((ab)->map_zero));		\
	memset((ab)->map_one, 0xff, sizeof((ab)->map_one));		\
} while (0)
#define	MAPADDRENABLED(flags) \
	(((flags) & AI_V4MAPPED) || \
	 (((flags) & AI_V4MAPPED_CFG) && _mapped_addr_enabled()))

union inx_addr {
	struct in_addr	in_addr;
#ifdef INET6
	struct in6_addr	in6_addr;
#endif
	struct {
		u_char	mau_zero[10];
		u_char	mau_one[2];
		struct in_addr mau_inaddr;
	}		map_addr_un;
#define	map_zero	map_addr_un.mau_zero
#define	map_one		map_addr_un.mau_one
#define	map_inaddr	map_addr_un.mau_inaddr
};

u_int16_t _getshort(const u_char *src);

static struct	 hostent *_hpcopy(struct hostent *hp, int *errp);
static struct	 hostent *_hpaddr(int af, const char *name, void *addr, int *errp);
static struct	 hostent *_hpmerge(struct hostent *hp1, struct hostent *hp2, int *errp);
#ifdef INET6
static struct	 hostent *_hpmapv6(struct hostent *hp, int *errp);
#endif
static struct	 hostent *_hpsort(struct hostent *hp);
static struct	 hostent *_ghbyname(const char *name, int af, int flags, int *errp);
static char	*_hgetword(char **pp);
static int	 _mapped_addr_enabled(void);

static FILE	*_files_open(int *errp);
static int	 _files_ghbyname(void *, void *, va_list);
static int	 _files_ghbyaddr(void *, void *, va_list);
#if 0 // keep gcc happy
static void	 _files_shent(int stayopen);
static void	 _files_ehent(void);
#endif
#ifdef YP
static int	 _nis_ghbyname(void *, void *, va_list);
static int	 _nis_ghbyaddr(void *, void *, va_list);
#endif
static int	 _dns_ghbyname(void *, void *, va_list);
static int	 _dns_ghbyaddr(void *, void *, va_list);
#if 0 // keep gcc happy
static void	 _dns_shent(int stayopen);
static void	 _dns_ehent(void);
#endif

#ifdef ICMPNL
static int	 _icmp_ghbyaddr(void *, void *, va_list);
#endif /* ICMPNL */

/* Host lookup order if nsswitch.conf is broken or nonexistant */
static const ns_src default_src[] = { 
	{ NSSRC_FILES, NS_SUCCESS },
	{ NSSRC_DNS, NS_SUCCESS },
#ifdef ICMPNL
#define NSSRC_ICMP "icmp"
	{ NSSRC_ICMP, NS_SUCCESS },
#endif
	{ 0 }
};

/*
 * Check if kernel supports mapped address.
 *	implementation dependent
 */
#ifdef __KAME__
#include <sys/sysctl.h>
#endif /* __KAME__ */

static int
_mapped_addr_enabled(void)
{
	/* implementation dependent check */
#if defined(__KAME__) && defined(IPV6CTL_MAPPED_ADDR)
	int mib[4];
	size_t len;
	int val;

	mib[0] = CTL_NET;
	mib[1] = PF_INET6;
	mib[2] = IPPROTO_IPV6;
	mib[3] = IPV6CTL_MAPPED_ADDR;
	len = sizeof(val);
	if (__sysctl(mib, 4, &val, &len, 0, 0) == 0 && val != 0)
		return 1;
#endif /* __KAME__ && IPV6CTL_MAPPED_ADDR */
	return 0;
}

/*
 * Functions defined in RFC2553
 *	getipnodebyname, getipnodebyaddr, freehostent
 */

static struct hostent *
_ghbyname(const char *name, int af, int flags, int *errp)
{
	struct hostent *hp;
	int rval;
	
	static const ns_dtab dtab[] = {
		NS_FILES_CB(_files_ghbyname, NULL)
		{ NSSRC_DNS, _dns_ghbyname, NULL },
		NS_NIS_CB(_nis_ghbyname, NULL)
		{ 0 }
	};

	if (flags & AI_ADDRCONFIG) {
		int s;

		/*
		 * TODO:
		 * Note that implementation dependent test for address
		 * configuration should be done everytime called
		 * (or apropriate interval),
		 * because addresses will be dynamically assigned or deleted.
		 */
		if (af == AF_UNSPEC) {
			if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
				af = AF_INET;
			else {
				close(s);
				if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
					af = AF_INET6;
				else
				close(s);
			}

		}
		if (af != AF_UNSPEC) {
			if ((s = socket(af, SOCK_DGRAM, 0)) < 0)
				return NULL;
			close(s);
		}
	}

	rval = nsdispatch(&hp, dtab, NSDB_HOSTS, "ghbyname", default_src,
			  name, af, errp);
	return (rval == NS_SUCCESS) ? hp : NULL;
}

/* getipnodebyname() internal routine for multiple query(PF_UNSPEC) support. */
struct hostent *
_getipnodebyname_multi(const char *name, int af, int flags, int *errp)
{
	struct hostent *hp;
	union inx_addr addrbuf;

	/* XXX: PF_UNSPEC is only supposed to be passed from getaddrinfo() */
	if (af != AF_INET
#ifdef INET6
	    && af != AF_INET6
#endif
	    && af != PF_UNSPEC
		)
	{
		*errp = NO_RECOVERY;
		return NULL;
	}

#ifdef INET6
	/* special case for literal address */
	if (inet_pton(AF_INET6, name, &addrbuf) == 1) {
		if (af != AF_INET6) {
			*errp = HOST_NOT_FOUND;
			return NULL;
		}
		return _hpaddr(af, name, &addrbuf, errp);
	}
#endif
	if (inet_aton(name, (struct in_addr *)&addrbuf) == 1) {
		if (af != AF_INET) {
			if (MAPADDRENABLED(flags)) {
				MAPADDR(&addrbuf, &addrbuf.in_addr);
			} else {
				*errp = HOST_NOT_FOUND;
				return NULL;
			}
		}
		return _hpaddr(af, name, &addrbuf, errp);
	}

	*errp = HOST_NOT_FOUND;
	hp = _ghbyname(name, af, flags, errp);

#ifdef INET6
	if (af == AF_INET6
	&&  ((flags & AI_ALL) || hp == NULL)
	&&  (MAPADDRENABLED(flags))) {
		struct hostent *hp2 = _ghbyname(name, AF_INET, flags, errp);
		if (hp == NULL)
			hp = _hpmapv6(hp2, errp);
		else {
			if (hp2 && strcmp(hp->h_name, hp2->h_name) != 0) {
				freehostent(hp2);
				hp2 = NULL;
			}
			hp = _hpmerge(hp, hp2, errp);
		}
	}
#endif
	return _hpsort(hp);
}

struct hostent *
getipnodebyname(const char *name, int af, int flags, int *errp)
{
	if (af != AF_INET
#ifdef INET6
	    && af != AF_INET6
#endif
		)
	{
		*errp = NO_RECOVERY;
		return NULL;
	}
	return(_getipnodebyname_multi(name, af ,flags, errp));
}

struct hostent *
getipnodebyaddr(const void *src, size_t len, int af, int *errp)
{
	struct hostent *hp;
	int rval;
#ifdef INET6
	struct in6_addr addrbuf;
#else
	struct in_addr addrbuf;
#endif

	static const ns_dtab dtab[] = {
		NS_FILES_CB(_files_ghbyaddr, NULL)
		{ NSSRC_DNS, _dns_ghbyaddr, NULL },
		NS_NIS_CB(_nis_ghbyaddr, NULL)
#ifdef ICMPNL
		{ NSSRC_ICMP, _icmp_ghbyaddr, NULL },
#endif
		{ 0 }
	};

	*errp = HOST_NOT_FOUND;

	switch (af) {
	case AF_INET:
		if (len != sizeof(struct in_addr)) {
			*errp = NO_RECOVERY;
			return NULL;
		}
		if ((long)src & ~(sizeof(struct in_addr) - 1)) {
			memcpy(&addrbuf, src, len);
			src = &addrbuf;
		}
		if (((struct in_addr *)src)->s_addr == 0)
			return NULL;
		break;
#ifdef INET6
	case AF_INET6:
		if (len != sizeof(struct in6_addr)) {
			*errp = NO_RECOVERY;
			return NULL;
		}
		if ((long)src & ~(sizeof(struct in6_addr) / 2 - 1)) {	/*XXX*/
			memcpy(&addrbuf, src, len);
			src = &addrbuf;
		}
		if (IN6_IS_ADDR_UNSPECIFIED((struct in6_addr *)src))
			return NULL;
		if (IN6_IS_ADDR_V4MAPPED((struct in6_addr *)src)
		||  IN6_IS_ADDR_V4COMPAT((struct in6_addr *)src)) {
			src = (char *)src +
			    (sizeof(struct in6_addr) - sizeof(struct in_addr));
			af = AF_INET;
			len = sizeof(struct in_addr);
		}
		break;
#endif
	default:
		*errp = NO_RECOVERY;
		return NULL;
	}

	rval = nsdispatch(&hp, dtab, NSDB_HOSTS, "ghbyaddr", default_src,
			  src, len, af, errp);
	return (rval == NS_SUCCESS) ? hp : NULL;
}

void
freehostent(struct hostent *ptr)
{
	free(ptr);
}

#if 0

/* XXX: should be deprecated */
struct hostent *
getnodebyname(const char *name, int af, int flags)
{
	return getipnodebyname(name, af, flags, &h_errno);
}

#ifdef __warn_references
__warn_references(getnodebyname,
	"warning: getnodebyname() deprecated, "
	"should use getaddrinfo() or getipnodebyname()");
#endif

struct hostent *
getnodebyaddr(const void *src, size_t len, int af)
{
	return getipnodebyaddr(src, len, af, &h_errno);
}

#ifdef __warn_references
__warn_references(getnodebyaddr,
	"warning: getnodebyaddr() deprecated, "
	"should use getnameinfo() or getipnodebyaddr()");
#endif

#endif

/*
 * Private utility functions
 */

/*
 * _hpcopy: allocate and copy hostent structure
 */
static struct hostent *
_hpcopy(struct hostent *hp, int *errp)
{
	struct hostent *nhp;
	char *cp, **pp;
	int size, addrsize;
	int nalias = 0, naddr = 0;
	int al_off;
	int i;

	if (hp == NULL)
		return hp;

	/* count size to be allocated */
	size = sizeof(struct hostent);
	if (hp->h_name != NULL)
		size += strlen(hp->h_name) + 1;
	if ((pp = hp->h_aliases) != NULL) {
		for (i = 0; *pp != NULL; i++, pp++) {
			if (**pp != '\0') {
				size += strlen(*pp) + 1;
				nalias++;
			}
		}
	}
	/* adjust alignment */
#ifdef	ALIGN
	size = ALIGN(size);
#endif
	al_off = size;
	size += sizeof(char *) * (nalias + 1);
#ifdef ALIGN
	addrsize = ALIGN(hp->h_length);
#else
	addrsize = hp->h_length;
#endif
        
	if ((pp = hp->h_addr_list) != NULL) {
		while (*pp++ != NULL)
			naddr++;
	}
	size += addrsize * naddr;
	size += sizeof(char *) * (naddr + 1);

	/* copy */
	if ((nhp = (struct hostent *)malloc(size)) == NULL) {
		*errp = TRY_AGAIN;
		return NULL;
	}
	cp = (char *)&nhp[1];
	if (hp->h_name != NULL) {
		nhp->h_name = cp;
		strcpy(cp, hp->h_name);
		cp += strlen(cp) + 1;
	} else
		nhp->h_name = NULL;
	nhp->h_aliases = (char **)((char *)nhp + al_off);
	if ((pp = hp->h_aliases) != NULL) {
		for (i = 0; *pp != NULL; pp++) {
			if (**pp != '\0') {
				nhp->h_aliases[i++] = cp;
				strcpy(cp, *pp);
				cp += strlen(cp) + 1;
			}
		}
	}
	nhp->h_aliases[nalias] = NULL;
	cp = (char *)&nhp->h_aliases[nalias + 1];
	nhp->h_addrtype = hp->h_addrtype;
	nhp->h_length = hp->h_length;
	nhp->h_addr_list = (char **)cp;
	if ((pp = hp->h_addr_list) != NULL) {
		cp = (char *)&nhp->h_addr_list[naddr + 1];
		for (i = 0; *pp != NULL; pp++) {
			nhp->h_addr_list[i++] = cp;
			memcpy(cp, *pp, hp->h_length);
			cp += addrsize;
		}
	}
	nhp->h_addr_list[naddr] = NULL;
	return nhp;
}

/*
 * _hpaddr: construct hostent structure with one address
 */
static struct hostent *
_hpaddr(int af, const char *name, void *addr, int *errp)
{
	struct hostent *hp, hpbuf;
	char *addrs[2];

	hp = &hpbuf;
	hp->h_name = (char *)name;
	hp->h_aliases = NULL;
	hp->h_addrtype = af;
	hp->h_length = ADDRLEN(af);
	hp->h_addr_list = addrs;
	addrs[0] = (char *)addr;
	addrs[1] = NULL;
	return _hpcopy(hp, errp);
}

/*
 * _hpmerge: merge 2 hostent structure, arguments will be freed
 */
static struct hostent *
_hpmerge(struct hostent *hp1, struct hostent *hp2, int *errp)
{
	int i, j;
	int naddr, nalias;
	char **pp;
	struct hostent *hp, hpbuf;
	char *aliases[MAXALIASES + 1], *addrs[MAXADDRS + 1];
	union inx_addr addrbuf[MAXADDRS];

	if (hp1 == NULL)
		return hp2;
	if (hp2 == NULL)
		return hp1;

#define	HP(i)	(i == 1 ? hp1 : hp2)
	hp = &hpbuf;
	hp->h_name = (hp1->h_name != NULL ? hp1->h_name : hp2->h_name);
	hp->h_aliases = aliases;
	nalias = 0;
	for (i = 1; i <= 2; i++) {
		if ((pp = HP(i)->h_aliases) == NULL)
			continue;
		for (; nalias < MAXALIASES && *pp != NULL; pp++) {
			/* check duplicates */
			for (j = 0; j < nalias; j++)
				if (strcasecmp(*pp, aliases[j]) == 0)
					break;
			if (j == nalias)
				aliases[nalias++] = *pp;
		}
	}
	aliases[nalias] = NULL;
#ifdef INET6
	if (hp1->h_length != hp2->h_length) {
		hp->h_addrtype = AF_INET6;
		hp->h_length = sizeof(struct in6_addr);
	} else {
#endif
		hp->h_addrtype = hp1->h_addrtype;
		hp->h_length = hp1->h_length;
#ifdef INET6
	}
#endif
	hp->h_addr_list = addrs;
	naddr = 0;
	for (i = 1; i <= 2; i++) {
		if ((pp = HP(i)->h_addr_list) == NULL)
			continue;
		if (HP(i)->h_length == hp->h_length) {
			while (naddr < MAXADDRS && *pp != NULL)
				addrs[naddr++] = *pp++;
		} else {
			/* copy IPv4 addr as mapped IPv6 addr */
			while (naddr < MAXADDRS && *pp != NULL) {
				MAPADDR(&addrbuf[naddr], *pp++);
				addrs[naddr] = (char *)&addrbuf[naddr];
				naddr++;
			}
		}
	}
	addrs[naddr] = NULL;
	hp = _hpcopy(hp, errp);
	freehostent(hp1);
	freehostent(hp2);
	return hp;
}

/*
 * _hpmapv6: convert IPv4 hostent into IPv4-mapped IPv6 addresses
 */
#ifdef INET6
static struct hostent *
_hpmapv6(struct hostent *hp, int *errp)
{
	struct hostent *hp6;

	if (hp == NULL)
		return NULL;
	if (hp->h_addrtype == AF_INET6)
		return hp;

	/* make dummy hostent to convert IPv6 address */
	if ((hp6 = (struct hostent *)malloc(sizeof(struct hostent))) == NULL) {
		*errp = TRY_AGAIN;
		return NULL;
	}
	hp6->h_name = NULL;
	hp6->h_aliases = NULL;
	hp6->h_addrtype = AF_INET6;
	hp6->h_length = sizeof(struct in6_addr);
	hp6->h_addr_list = NULL;
	return _hpmerge(hp6, hp, errp);
}
#endif

/*
 * _hpsort: sort address by sortlist
 */
static struct hostent *
_hpsort(struct hostent *hp)
{
	int i, j, n;
	u_char *ap, *sp, *mp, **pp;
	char t;
	char order[MAXADDRS];
	int nsort = _res.nsort;

	if (hp == NULL || hp->h_addr_list[1] == NULL || nsort == 0)
		return hp;
	for (i = 0; (ap = (u_char *)hp->h_addr_list[i]); i++) {
		for (j = 0; j < nsort; j++) {
#ifdef INET6
			if (_res_ext.sort_list[j].af != hp->h_addrtype)
				continue;
			sp = (u_char *)&_res_ext.sort_list[j].addr;
			mp = (u_char *)&_res_ext.sort_list[j].mask;
#else
			sp = (u_char *)&_res.sort_list[j].addr;
			mp = (u_char *)&_res.sort_list[j].mask;
#endif
			for (n = 0; n < hp->h_length; n++) {
				if ((ap[n] & mp[n]) != sp[n])
					break;
			}
			if (n == hp->h_length)
				break;
		}
		order[i] = j;
	}
	n = i;
	pp = (u_char **)hp->h_addr_list;
	for (i = 0; i < n - 1; i++) {
		for (j = i + 1; j < n; j++) {
			if (order[i] > order[j]) {
				ap = pp[i];
				pp[i] = pp[j];
				pp[j] = ap;
				t = order[i];
				order[i] = order[j];
				order[j] = t;
			}
		}
	}
	return hp;
}

static char *
_hgetword(char **pp)
{
	char c, *p, *ret;
	const char *sp;
	static const char sep[] = "# \t\n";

	ret = NULL;
	for (p = *pp; (c = *p) != '\0'; p++) {
		for (sp = sep; *sp != '\0'; sp++) {
			if (c == *sp)
				break;
		}
		if (c == '#')
			p[1] = '\0';	/* ignore rest of line */
		if (ret == NULL) {
			if (*sp == '\0')
				ret = p;
		} else {
			if (*sp != '\0') {
				*p++ = '\0';
				break;
			}
		}
	}
	*pp = p;
	if (ret == NULL || *ret == '\0')
		return NULL;
	return ret;
}

/*
 * FILES (/etc/hosts)
 */

static FILE *
_files_open(int *errp)
{
	FILE *fp;
	fp = fopen(_PATH_HOSTS, "r");
	if (fp == NULL)
		*errp = NO_RECOVERY;
	return fp;
}

static int
_files_ghbyname(void *rval, void *cb_data, va_list ap)
{
	const char *name;
	int af; 
	int *errp;
	int match, nalias;
	char *p, *line, *addrstr, *cname;
	FILE *fp;
	struct hostent *rethp, *hp, hpbuf;
	char *aliases[MAXALIASES + 1], *addrs[2];
	union inx_addr addrbuf;
	char buf[BUFSIZ];
	int af0;

	name = va_arg(ap, const char *);
	af = va_arg(ap, int);
	errp = va_arg(ap, int *);

	*(struct hostent **)rval = NULL;

	if ((fp = _files_open(errp)) == NULL)
		return NS_UNAVAIL;
	rethp = hp = NULL;

	af0 = af;
	while (fgets(buf, sizeof(buf), fp)) {
		line = buf;
		if ((addrstr = _hgetword(&line)) == NULL
		||  (cname = _hgetword(&line)) == NULL)
			continue;
		match = (strcasecmp(cname, name) == 0);
		nalias = 0;
		while ((p = _hgetword(&line)) != NULL) {
			if (!match)
				match = (strcasecmp(p, name) == 0);
			if (nalias < MAXALIASES)
				aliases[nalias++] = p;
		}
		if (!match)
			continue;
		switch (af0) {
		case AF_INET:
			if (inet_aton(addrstr, (struct in_addr *)&addrbuf)
			    != 1) {
				*errp = NO_DATA;	/* name found */
				continue;
			}
			af = af0;
			break;
#ifdef INET6
		case AF_INET6:
			if (inet_pton(af, addrstr, &addrbuf) != 1) {
				*errp = NO_DATA;	/* name found */
				continue;
			}
			af = af0;
			break;
#endif
		case AF_UNSPEC:
			if (inet_aton(addrstr, (struct in_addr *)&addrbuf)
			    == 1) {
				af = AF_INET;
				break;
			}
#ifdef INET6
			if (inet_pton(AF_INET6, addrstr, &addrbuf) == 1) {
				af = AF_INET6;
				break; 
			}
#endif
			*errp = NO_DATA;	/* name found */
			continue;
			/* NOTREACHED */
		}
		hp = &hpbuf;
		hp->h_name = cname;
		hp->h_aliases = aliases;
		aliases[nalias] = NULL;
		hp->h_addrtype = af;
		hp->h_length = ADDRLEN(af);
		hp->h_addr_list = addrs;
		addrs[0] = (char *)&addrbuf;
		addrs[1] = NULL;
		hp = _hpcopy(hp, errp);
		rethp = _hpmerge(rethp, hp, errp);
	}
	fclose(fp);
	*(struct hostent **)rval = rethp;
	return (rethp != NULL) ? NS_SUCCESS : NS_NOTFOUND;
}

static int
_files_ghbyaddr(void *rval, void *cb_data, va_list ap)
{
	const void *addr; 
	int addrlen; 
	int af; 
	int *errp;
	int nalias;
	char *p, *line;
	FILE *fp;
	struct hostent *hp, hpbuf;
	char *aliases[MAXALIASES + 1], *addrs[2];
	union inx_addr addrbuf;
	char buf[BUFSIZ];

	addr = va_arg(ap, const void *);
	addrlen = va_arg(ap, int);
	af = va_arg(ap, int);
	errp = va_arg(ap, int *);

	*(struct hostent**)rval = NULL;

	if ((fp = _files_open(errp)) == NULL)
		return NS_UNAVAIL;
	hp = NULL;
	while (fgets(buf, sizeof(buf), fp)) {
		line = buf;
		if ((p = _hgetword(&line)) == NULL
		||  (af == AF_INET
		     ? inet_aton(p, (struct in_addr *)&addrbuf)
		     : inet_pton(af, p, &addrbuf)) != 1
		||  memcmp(addr, &addrbuf, addrlen) != 0
		||  (p = _hgetword(&line)) == NULL)
			continue;
		hp = &hpbuf;
		hp->h_name = p;
		hp->h_aliases = aliases;
		nalias = 0;
		while ((p = _hgetword(&line)) != NULL) {
			if (nalias < MAXALIASES)
				aliases[nalias++] = p;
		}
		aliases[nalias] = NULL;
		hp->h_addrtype = af;
		hp->h_length = addrlen;
		hp->h_addr_list = addrs;
		addrs[0] = (char *)&addrbuf;
		addrs[1] = NULL;
		hp = _hpcopy(hp, errp);
		break;
	}
	fclose(fp);
	*(struct hostent **)rval = hp;
	return (hp != NULL) ? NS_SUCCESS : NS_NOTFOUND;
}

#ifdef YP
/*
 * NIS
 *
 * XXX actually a hack, these are INET4 specific.
 */
static int
_nis_ghbyname(void *rval, void *cb_data, va_list ap)
{
	const char *name;
	int af;
	int *errp;
	struct hostent *hp = NULL;

	name = va_arg(ap, const char *);
	af = va_arg(ap, int);
	errp = va_arg(ap, int *);
	
	if (af == AF_UNSPEC)
		af = AF_INET;
	if (af == AF_INET) {
		hp = _gethostbynisname(name, af);
		if (hp != NULL)
			hp = _hpcopy(hp, errp);
	}
	
	*(struct hostent **)rval = hp;
	return (hp != NULL) ? NS_SUCCESS : NS_NOTFOUND;
	
}

static int
_nis_ghbyaddr(void *rval, void *cb_data, va_list ap)
{
	const void *addr;
	int addrlen;
	int af;
	int *errp;
	struct hostent *hp = NULL;

	addr = va_arg(ap, const void *);
	addrlen = va_arg(ap, int);
	af = va_arg(ap, int);

	if (af == AF_INET) {
		hp = _gethostbynisaddr(addr, addrlen, af);
		if (hp != NULL)
			hp = _hpcopy(hp, errp);
	}
	*(struct hostent **)rval = hp;
	return (hp != NULL) ? NS_SUCCESS : NS_NOTFOUND;
}
#endif
typedef struct __res_type_list res_type_list;

struct __res_type_list {
        res_type_list * rtl_entry;
        int     rtl_type;
};

#if PACKETSZ > 1024
#define	MAXPACKET	PACKETSZ
#else
#define	MAXPACKET	1024
#endif

typedef union {
	HEADER hdr;
	u_char buf[MAXPACKET];
} querybuf;

static struct hostent *getanswer(const querybuf *, int, const char *, int,
	    struct hostent *, int *);

/*
 * we don't need to take care about sorting, nor IPv4 mapped address here.
 */
static struct hostent *
getanswer(answer, anslen, qname, qtype, template, errp)
	const querybuf *answer;
	int anslen;
	const char *qname;
	int qtype;
	struct hostent *template;
	int *errp;
{
	const HEADER *hp;
	const u_char *cp;
	int n;
	const u_char *eom, *erdata;
	char *bp, **ap, **hap;
	int type, class, buflen, ancount, qdcount;
	int haveanswer, had_error;
	char tbuf[MAXDNAME];
	const char *tname;
	int (*name_ok)(const char *);
	static char *h_addr_ptrs[MAXADDRS + 1];
	static char *host_aliases[MAXALIASES];
	static char hostbuf[8*1024];

#define BOUNDED_INCR(x) \
	do { \
		cp += x; \
		if (cp > eom) { \
			*errp = NO_RECOVERY; \
			return (NULL); \
		} \
	} while (0)

#define BOUNDS_CHECK(ptr, count) \
	do { \
		if ((ptr) + (count) > eom) { \
			*errp = NO_RECOVERY; \
			return (NULL); \
		} \
	} while (0)

/* XXX do {} while (0) cannot be put here */
#define DNS_ASSERT(x) \
	{				\
		if (!(x)) {		\
			cp += n;	\
			continue;	\
		}			\
	}

/* XXX do {} while (0) cannot be put here */
#define DNS_FATAL(x) \
	{				\
		if (!(x)) {		\
			had_error++;	\
			continue;	\
		}			\
	}

	tname = qname;
	template->h_name = NULL;
	eom = answer->buf + anslen;
	switch (qtype) {
	case T_A:
	case T_AAAA:
		name_ok = res_hnok;
		break;
	case T_PTR:
		name_ok = res_dnok;
		break;
	default:
		return (NULL);	/* XXX should be abort(); */
	}
	/*
	 * find first satisfactory answer
	 */
	hp = &answer->hdr;
	ancount = ntohs(hp->ancount);
	qdcount = ntohs(hp->qdcount);
	bp = hostbuf;
	buflen = sizeof hostbuf;
	cp = answer->buf;
	BOUNDED_INCR(HFIXEDSZ);
	if (qdcount != 1) {
		*errp = NO_RECOVERY;
		return (NULL);
	}
	n = dn_expand(answer->buf, eom, cp, bp, buflen);
	if ((n < 0) || !(*name_ok)(bp)) {
		*errp = NO_RECOVERY;
		return (NULL);
	}
	BOUNDED_INCR(n + QFIXEDSZ);
	if (qtype == T_A || qtype == T_AAAA) {
		/* res_send() has already verified that the query name is the
		 * same as the one we sent; this just gets the expanded name
		 * (i.e., with the succeeding search-domain tacked on).
		 */
		n = strlen(bp) + 1;		/* for the \0 */
		if (n >= MAXHOSTNAMELEN) {
			*errp = NO_RECOVERY;
			return (NULL);
		}
		template->h_name = bp;
		bp += n;
		buflen -= n;
		/* The qname can be abbreviated, but h_name is now absolute. */
		qname = template->h_name;
	}
	ap = host_aliases;
	*ap = NULL;
	template->h_aliases = host_aliases;
	hap = h_addr_ptrs;
	*hap = NULL;
	template->h_addr_list = h_addr_ptrs;
	haveanswer = 0;
	had_error = 0;
	while (ancount-- > 0 && cp < eom && !had_error) {
		n = dn_expand(answer->buf, eom, cp, bp, buflen);
		DNS_FATAL(n >= 0);
		DNS_FATAL((*name_ok)(bp));
		cp += n;			/* name */
		BOUNDS_CHECK(cp, 3 * INT16SZ + INT32SZ);
		type = _getshort(cp);
 		cp += INT16SZ;			/* type */
		class = _getshort(cp);
 		cp += INT16SZ + INT32SZ;	/* class, TTL */
		n = _getshort(cp);
		cp += INT16SZ;			/* len */
		BOUNDS_CHECK(cp, n);
		erdata = cp + n;
		DNS_ASSERT(class == C_IN);
		if ((qtype == T_A || qtype == T_AAAA) && type == T_CNAME) {
			if (ap >= &host_aliases[MAXALIASES-1])
				continue;
			n = dn_expand(answer->buf, eom, cp, tbuf, sizeof tbuf);
			DNS_FATAL(n >= 0);
			DNS_FATAL((*name_ok)(tbuf));
			cp += n;
			if (cp != erdata) {
				*errp = NO_RECOVERY;
				return (NULL);
			}
			/* Store alias. */
			*ap++ = bp;
			n = strlen(bp) + 1;	/* for the \0 */
			DNS_FATAL(n < MAXHOSTNAMELEN);
			bp += n;
			buflen -= n;
			/* Get canonical name. */
			n = strlen(tbuf) + 1;	/* for the \0 */
			DNS_FATAL(n <= buflen);
			DNS_FATAL(n < MAXHOSTNAMELEN);
			strcpy(bp, tbuf);
			template->h_name = bp;
			bp += n;
			buflen -= n;
			continue;
		}
		if (qtype == T_PTR && type == T_CNAME) {
			n = dn_expand(answer->buf, eom, cp, tbuf, sizeof tbuf);
			if (n < 0 || !res_dnok(tbuf)) {
				had_error++;
				continue;
			}
			cp += n;
			if (cp != erdata) {
				*errp = NO_RECOVERY;
				return (NULL);
			}
			/* Get canonical name. */
			n = strlen(tbuf) + 1;	/* for the \0 */
			if (n > buflen || n >= MAXHOSTNAMELEN) {
				had_error++;
				continue;
			}
			strcpy(bp, tbuf);
			tname = bp;
			bp += n;
			buflen -= n;
			continue;
		}
		DNS_ASSERT(type == qtype);
		switch (type) {
		case T_PTR:
			DNS_ASSERT(strcasecmp(tname, bp) == 0);
			n = dn_expand(answer->buf, eom, cp, bp, buflen);
			DNS_FATAL(n >= 0);
			DNS_FATAL(res_hnok(bp));
#if MULTI_PTRS_ARE_ALIASES
			cp += n;
			if (cp != erdata) {
				*errp = NO_RECOVERY;
				return (NULL);
			}
			if (!haveanswer)
				template->h_name = bp;
			else if (ap < &host_aliases[MAXALIASES-1])
				*ap++ = bp;
			else
				n = -1;
			if (n != -1) {
				n = strlen(bp) + 1;	/* for the \0 */
				if (n >= MAXHOSTNAMELEN) {
					had_error++;
					break;
				}
				bp += n;
				buflen -= n;
			}
			break;
#else
			template->h_name = bp;
			*errp = NETDB_SUCCESS;
			return (template);
#endif
		case T_A:
		case T_AAAA:
			DNS_ASSERT(strcasecmp(template->h_name, bp) == 0);
			DNS_ASSERT(n == template->h_length);
			if (!haveanswer) {
				int nn;

				template->h_name = bp;
				nn = strlen(bp) + 1;	/* for the \0 */
				bp += nn;
				buflen -= nn;
			}
#ifdef ALIGN
			bp = (char *)ALIGN(bp);
#else
			bp = (char *)(bp);
#endif

			DNS_FATAL(bp + n < &hostbuf[sizeof hostbuf]);
			DNS_ASSERT(hap < &h_addr_ptrs[MAXADDRS-1]);
#ifdef FILTER_V4MAPPED
			if (type == T_AAAA) {
				struct in6_addr in6;
				memcpy(&in6, cp, sizeof(in6));
				DNS_ASSERT(IN6_IS_ADDR_V4MAPPED(&in6) == 0);
			}
#endif
			bcopy(cp, *hap++ = bp, n);
			bp += n;
			buflen -= n;
			cp += n;
			if (cp != erdata) {
				*errp = NO_RECOVERY;
				return (NULL);
			}
			break;
		default:
			abort();
		}
		if (!had_error)
			haveanswer++;
	}
	if (haveanswer) {
		*ap = NULL;
		*hap = NULL;
		if (!template->h_name) {
			n = strlen(qname) + 1;	/* for the \0 */
			if (n > buflen || n >= MAXHOSTNAMELEN)
				goto no_recovery;
			strcpy(bp, qname);
			template->h_name = bp;
			bp += n;
			buflen -= n;
		}
		*errp = NETDB_SUCCESS;
		return (template);
	}
 no_recovery:
	*errp = NO_RECOVERY;
	return (NULL);

#undef BOUNDED_INCR
#undef BOUNDS_CHECK
#undef DNS_ASSERT
#undef DNS_FATAL
}

/* res_search() variant with multiple query support. */
static struct hostent *
_res_search_multi(name, rtl, errp)
	const char *name;	/* domain name */
	struct	__res_type_list *rtl; /* list of query types */
	int *errp;
{
	const char *cp, * const *domain;
	struct hostent *hp0 = NULL, *hp;
	struct hostent hpbuf;
	u_int dots;
	int trailing_dot, ret, saved_herrno;
	int got_nodata = 0, got_servfail = 0, tried_as_is = 0;
	struct __res_type_list *rtl0 = rtl;
	querybuf buf;

	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
		*errp = NETDB_INTERNAL;
		return (NULL);
	}
	dots = 0;
	for (cp = name; *cp; cp++)
		dots += (*cp == '.');
	trailing_dot = 0;
	if (cp > name && *--cp == '.')
		trailing_dot++;

	/* If there aren't any dots, it could be a user-level alias */
	if (!dots && (cp = hostalias(name)) != NULL) {
		for(rtl = rtl0; rtl != NULL;
		    rtl = rtl->rtl_entry) {
			ret = res_query(cp, C_IN, rtl->rtl_type, buf.buf,
					     sizeof(buf.buf));
			if (ret > 0) {
				hpbuf.h_addrtype = (rtl->rtl_type == T_AAAA)
				    ? AF_INET6 : AF_INET;
				hpbuf.h_length = ADDRLEN(hpbuf.h_addrtype);
				hp = getanswer(&buf, ret, name, rtl->rtl_type,
						    &hpbuf, errp);
				if (!hp)
					continue;
				hp = _hpcopy(&hpbuf, errp);
				hp0 = _hpmerge(hp0, hp, errp);
			}
		}
		return (hp0);
	}

	/*
	 * If there are dots in the name already, let's just give it a try
	 * 'as is'.  The threshold can be set with the "ndots" option.
	 */
	saved_herrno = -1;
	if (dots >= _res.ndots) {
		for(rtl = rtl0; rtl != NULL;
		    rtl = rtl->rtl_entry) {
			ret = res_querydomain(name, NULL, C_IN, rtl->rtl_type,
					      buf.buf, sizeof(buf.buf));
			if (ret > 0) {
				hpbuf.h_addrtype = (rtl->rtl_type == T_AAAA)
				    ? AF_INET6 : AF_INET;
				hpbuf.h_length = ADDRLEN(hpbuf.h_addrtype);
				hp = getanswer(&buf, ret, name, rtl->rtl_type,
						    &hpbuf, errp);
				if (!hp)
					continue;
				hp = _hpcopy(&hpbuf, errp);
				hp0 = _hpmerge(hp0, hp, errp);
			}
		}
		if (hp0 != NULL)
			return (hp0);
		saved_herrno = *errp;
		tried_as_is++;
	}

	/*
	 * We do at least one level of search if
	 *	- there is no dot and RES_DEFNAME is set, or
	 *	- there is at least one dot, there is no trailing dot,
	 *	  and RES_DNSRCH is set.
	 */
	if ((!dots && (_res.options & RES_DEFNAMES)) ||
	    (dots && !trailing_dot && (_res.options & RES_DNSRCH))) {
		int done = 0;

		for (domain = (const char * const *)_res.dnsrch;
		     *domain && !done;
		     domain++) {

			for(rtl = rtl0; rtl != NULL;
			    rtl = rtl->rtl_entry) {
				ret = res_querydomain(name, *domain, C_IN,
						      rtl->rtl_type,
						      buf.buf, sizeof(buf.buf));
				if (ret > 0) {
					hpbuf.h_addrtype = (rtl->rtl_type == T_AAAA)
					    ? AF_INET6 : AF_INET;
					hpbuf.h_length = ADDRLEN(hpbuf.h_addrtype);
					hp = getanswer(&buf, ret, name,
					    rtl->rtl_type, &hpbuf, errp);
					if (!hp)
						continue;
					hp = _hpcopy(&hpbuf, errp);
					hp0 = _hpmerge(hp0, hp, errp);
				}
			}
			if (hp0 != NULL)
				return (hp0);

			/*
			 * If no server present, give up.
			 * If name isn't found in this domain,
			 * keep trying higher domains in the search list
			 * (if that's enabled).
			 * On a NO_DATA error, keep trying, otherwise
			 * a wildcard entry of another type could keep us
			 * from finding this entry higher in the domain.
			 * If we get some other error (negative answer or
			 * server failure), then stop searching up,
			 * but try the input name below in case it's
			 * fully-qualified.
			 */
			if (errno == ECONNREFUSED) {
				*errp = TRY_AGAIN;
				return (NULL);
			}

			switch (*errp) {
			case NO_DATA:
				got_nodata++;
				/* FALLTHROUGH */
			case HOST_NOT_FOUND:
				/* keep trying */
				break;
			case TRY_AGAIN:
				if (buf.hdr.rcode == SERVFAIL) {
					/* try next search element, if any */
					got_servfail++;
					break;
				}
				/* FALLTHROUGH */
			default:
				/* anything else implies that we're done */
				done++;
			}

			/* if we got here for some reason other than DNSRCH,
			 * we only wanted one iteration of the loop, so stop.
			 */
			if (!(_res.options & RES_DNSRCH))
				done++;
		}
	}

	/*
	 * If we have not already tried the name "as is", do that now.
	 * note that we do this regardless of how many dots were in the
	 * name or whether it ends with a dot unless NOTLDQUERY is set.
	 */
	if (!tried_as_is && (dots || !(_res.options & RES_NOTLDQUERY))) {
		for(rtl = rtl0; rtl != NULL;
		    rtl = rtl->rtl_entry) {
			ret = res_querydomain(name, NULL, C_IN, rtl->rtl_type,
					      buf.buf, sizeof(buf.buf));
			if (ret > 0) {
				hpbuf.h_addrtype = (rtl->rtl_type == T_AAAA)
				    ? AF_INET6 : AF_INET;
				hpbuf.h_length = ADDRLEN(hpbuf.h_addrtype);
				hp = getanswer(&buf, ret, name, rtl->rtl_type,
				    &hpbuf, errp);
				if (!hp)
					continue;
				hp = _hpcopy(&hpbuf, errp);
				hp0 = _hpmerge(hp0, hp, errp);
			}
		}
		if (hp0 != NULL)
			return (hp0);
	}

	/* if we got here, we didn't satisfy the search.
	 * if we did an initial full query, return that query's h_errno
	 * (note that we wouldn't be here if that query had succeeded).
	 * else if we ever got a nodata, send that back as the reason.
	 * else send back meaningless h_errno, that being the one from
	 * the last DNSRCH we did.
	 */
	if (saved_herrno != -1)
		*errp = saved_herrno;
	else if (got_nodata)
		*errp = NO_DATA;
	else if (got_servfail)
		*errp = TRY_AGAIN;
	return (NULL);
}

static int
_dns_ghbyname(void *rval, void *cb_data, va_list ap)
{
	const char *name;
	int af;
	int *errp;
	res_type_list *rtl, rtl4;
#ifdef INET6
	res_type_list rtl6;
#endif

	name = va_arg(ap, const char *);
	af = va_arg(ap, int);
	errp = va_arg(ap, int *);

#ifdef INET6
	switch (af) {
	case AF_UNSPEC:
		rtl4.rtl_entry = NULL; rtl4.rtl_type = T_A;
		rtl6.rtl_entry = &rtl4; rtl6.rtl_type = T_AAAA;
		rtl = &rtl6;
		break;
	case AF_INET6:
		rtl6.rtl_entry = NULL; rtl6.rtl_type = T_AAAA;
		rtl = &rtl6;
		break;
	case AF_INET:
		rtl4.rtl_entry = NULL; rtl4.rtl_type = T_A;
		rtl = &rtl4;
		break;
	}
#else
	(&rtl4)->rtl_entry = NULL;
        rtl4.rtl_type = T_A;
	rtl = &rtl4;
#endif
	*(struct hostent **)rval = _res_search_multi(name, rtl, errp);
	return (*(struct hostent **)rval != NULL) ? NS_SUCCESS : NS_NOTFOUND;
}

static int
_dns_ghbyaddr(void *rval, void *cb_data, va_list ap)
{
	const void *addr;
	int addrlen;
	int af;
	int *errp;
	int n;
	struct hostent *hp;
	u_char c, *cp;
	char *bp;
	struct hostent hbuf;
	int na;
#ifdef INET6
	static const char hex[] = "0123456789abcdef";
#endif
	querybuf buf;
	char qbuf[MAXDNAME+1];
	char *hlist[2];

	addr = va_arg(ap, const void *);
	addrlen = va_arg(ap, int);
	af = va_arg(ap, int);
	errp = va_arg(ap, int *);

	*(struct hostent **)rval = NULL;

#ifdef INET6
	/* XXX */
	if (af == AF_INET6 && IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)addr))
		return NS_NOTFOUND;
#endif

	if ((_res.options & RES_INIT) == 0) {
		if (res_init() < 0) {
			*errp = h_errno;
			return NS_UNAVAIL;
		}
	}
	memset(&hbuf, 0, sizeof(hbuf));
	hbuf.h_name = NULL;
	hbuf.h_addrtype = af;
	hbuf.h_length = addrlen;
	na = 0;

	/* XXX assumes that MAXDNAME is big enough */
	n = 0;
	bp = qbuf;
	cp = (u_char *)addr+addrlen-1;
	switch (af) {
#ifdef INET6
	case AF_INET6:
		for (; n < addrlen; n++, cp--) {
			c = *cp;
			*bp++ = hex[c & 0xf];
			*bp++ = '.';
			*bp++ = hex[c >> 4];
			*bp++ = '.';
		}
		strcpy(bp, "ip6.int");
		break;
#endif
	default:
		for (; n < addrlen; n++, cp--) {
			c = *cp;
			if (c >= 100)
				*bp++ = '0' + c / 100;
			if (c >= 10)
				*bp++ = '0' + (c % 100) / 10;
			*bp++ = '0' + c % 10;
			*bp++ = '.';
		}
		strcpy(bp, "in-addr.arpa");
		break;
	}

	n = res_query(qbuf, C_IN, T_PTR, buf.buf, sizeof buf.buf);
	if (n < 0) {
		*errp = h_errno;
		return NS_UNAVAIL;
	}
	hp = getanswer(&buf, n, qbuf, T_PTR, &hbuf, errp);
	if (!hp)
		return NS_NOTFOUND;
	hbuf.h_addrtype = af;
	hbuf.h_length = addrlen;
	hbuf.h_addr_list = hlist;
	hlist[0] = (char *)addr;
	hlist[1] = NULL;
	*(struct hostent **)rval = _hpcopy(&hbuf, errp);
	return NS_SUCCESS;
}

#if 0 // keep gcc happy
static void
_dns_shent(int stayopen)
{
	if ((_res.options & RES_INIT) == 0) {
		if (res_init() < 0)
			return;
	}
	if (stayopen)
		_res.options |= RES_STAYOPEN | RES_USEVC;
}

static void
_dns_ehent(void)
{
	_res.options &= ~(RES_STAYOPEN | RES_USEVC);
	res_close();
}
#endif

#ifdef ICMPNL

/*
 * experimental:
 *	draft-ietf-ipngwg-icmp-namelookups-02.txt
 *	ifindex is assumed to be encoded in addr.
 */
#include <sys/uio.h>
#include <netinet/ip6.h>
#include <netinet/icmp6.h>

struct _icmp_host_cache {
	struct _icmp_host_cache *hc_next;
	int hc_ifindex;
	struct in6_addr hc_addr;
	char *hc_name;
};

static char *
_icmp_fqdn_query(const struct in6_addr *addr, int ifindex)
{
	int s;
	struct icmp6_filter filter;
	struct msghdr msg;
	struct cmsghdr *cmsg;
	struct in6_pktinfo *pkt;
	char cbuf[256];
	char buf[1024];
	int cc;
	struct icmp6_fqdn_query *fq;
	struct icmp6_fqdn_reply *fr;
	struct _icmp_host_cache *hc;
	struct sockaddr_in6 sin6;
	struct iovec iov;
	fd_set s_fds, fds;
	struct timeval tout;
	int len;
	char *name;
	static int pid;
	static struct _icmp_host_cache *hc_head;

	for (hc = hc_head; hc; hc = hc->hc_next) {
		if (hc->hc_ifindex == ifindex
		&&  IN6_ARE_ADDR_EQUAL(&hc->hc_addr, addr))
			return hc->hc_name;
	}

	if (pid == 0)
		pid = getpid();

	ICMP6_FILTER_SETBLOCKALL(&filter);
	ICMP6_FILTER_SETPASS(ICMP6_FQDN_REPLY, &filter);

	FD_ZERO(&s_fds);
	tout.tv_sec = 0;
	tout.tv_usec = 200000;	/*XXX: 200ms*/

	fq = (struct icmp6_fqdn_query *)buf;
	fq->icmp6_fqdn_type = ICMP6_FQDN_QUERY;
	fq->icmp6_fqdn_code = 0;
	fq->icmp6_fqdn_cksum = 0;
	fq->icmp6_fqdn_id = (u_short)pid;
	fq->icmp6_fqdn_unused = 0;
	fq->icmp6_fqdn_cookie[0] = 0;
	fq->icmp6_fqdn_cookie[1] = 0;

	memset(&sin6, 0, sizeof(sin6));
	sin6.sin6_family = AF_INET6;
	sin6.sin6_addr = *addr;

	memset(&msg, 0, sizeof(msg));
	msg.msg_name = (caddr_t)&sin6;
	msg.msg_namelen = sizeof(sin6);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = NULL;
	msg.msg_controllen = 0;
	iov.iov_base = (caddr_t)buf;
	iov.iov_len = sizeof(struct icmp6_fqdn_query);

	if (ifindex) {
		msg.msg_control = cbuf;
		msg.msg_controllen = sizeof(cbuf);
		cmsg = CMSG_FIRSTHDR(&msg);
		cmsg->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
		cmsg->cmsg_level = IPPROTO_IPV6;
		cmsg->cmsg_type = IPV6_PKTINFO;
		pkt = (struct in6_pktinfo *)&cmsg[1];
		memset(&pkt->ipi6_addr, 0, sizeof(struct in6_addr));
		pkt->ipi6_ifindex = ifindex;
		cmsg = CMSG_NXTHDR(&msg, cmsg);
		msg.msg_controllen = (char *)cmsg - cbuf;
	}

	if ((s = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0)
		return NULL;
	(void)setsockopt(s, IPPROTO_ICMPV6, ICMP6_FILTER,
			 (char *)&filter, sizeof(filter));
	cc = _sendmsg(s, &msg, 0);
	if (cc < 0) {
		close(s);
		return NULL;
	}
	FD_SET(s, &s_fds);
	for (;;) {
		fds = s_fds;
		if (select(s + 1, &fds, NULL, NULL, &tout) <= 0) {
			close(s);
			return NULL;
		}
		len = sizeof(sin6);
		cc = _recvfrom(s, buf, sizeof(buf), 0,
			      (struct sockaddr *)&sin6, &len);
		if (cc <= 0) {
			close(s);
			return NULL;
		}
		if (cc < sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr))
			continue;
		if (!IN6_ARE_ADDR_EQUAL(addr, &sin6.sin6_addr))
			continue;
		fr = (struct icmp6_fqdn_reply *)(buf + sizeof(struct ip6_hdr));
		if (fr->icmp6_fqdn_type == ICMP6_FQDN_REPLY)
			break;
	}
	close(s);
	if (fr->icmp6_fqdn_cookie[1] != 0) {
		/* rfc1788 type */
		name = buf + sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) + 4;
		len = (buf + cc) - name;
	} else {
		len = fr->icmp6_fqdn_namelen;
		name = fr->icmp6_fqdn_name;
	}
	if (len <= 0)
		return NULL;
	name[len] = 0;

	if ((hc = (struct _icmp_host_cache *)malloc(sizeof(*hc))) == NULL)
		return NULL;
	/* XXX: limit number of cached entries */
	hc->hc_ifindex = ifindex;
	hc->hc_addr = *addr;
	hc->hc_name = strdup(name);
	hc->hc_next = hc_head;
	hc_head = hc;
	return hc->hc_name;
}

static struct hostent *
_icmp_ghbyaddr(const void *addr, int addrlen, int af, int *errp)
{
	char *hname;
	int ifindex;
	struct in6_addr addr6;

	if (af != AF_INET6) {
		/*
		 * Note: rfc1788 defines Who Are You for IPv4,
		 * but no one implements it.
		 */
		return NULL;
	}

	memcpy(&addr6, addr, addrlen);
	ifindex = (addr6.s6_addr[2] << 8) | addr6.s6_addr[3];
	addr6.s6_addr[2] = addr6.s6_addr[3] = 0;

	if (!IN6_IS_ADDR_LINKLOCAL(&addr6))
		return NULL;	/*XXX*/

	if ((hname = _icmp_fqdn_query(&addr6, ifindex)) == NULL)
		return NULL;
	return _hpaddr(af, hname, &addr6, errp);
}
#endif /* ICMPNL */
@


1.2
log
@
2006-03-29  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/sys/linux/net/name6.c: Fix struct references.
@
text
@@


1.1
log
@
2003-05-28  Jeff Johnston  <jjohnstn@@redhat.com>
	    Tom Fitzsimmons  <fitzsim@@redhat.com>

	* configure.in: Add iconvdata support for x86 linux.
	* configure: Regenerated.
	* libc/sys/linux/Makefile.am: Add EL/IX level 3 network, dynamic
	library, iconv, and linuxthreads support.
	* libc/sys/linux/configure.in: Ditto.
	* libc/sys/linux/Makefile.in: Regenerated.
	* libc/sys/linux/configure: Ditto.
	* iconvdata/EUC-JP.irreversible: New file.
	* iconvdata/Makefile.am: Ditto.
	* iconvdata/Makefile.in: Ditto.
	* iconvdata/SJIS.irreversible: Ditto.
	* iconvdata/aclocal.m4: Ditto.
	* iconvdata/configure: Ditto.
	* iconvdata/configure.in: Ditto.
	* iconvdata/dummy.c: Ditto.
	* iconvdata/euc-jp.c: Ditto.
	* iconvdata/gconv-modules: Ditto.
	* iconvdata/jis0201.c: Ditto.
	* iconvdata/jis0201.h: Ditto.
	* iconvdata/jis0208.c: Ditto.
	* iconvdata/jis0208.h: Ditto.
	* iconvdata/jis0212.c: Ditto.
	* iconvdata/jis0212.h: Ditto.
	* iconvdata/sjis.c: Ditto.
	* libc/include/errno.h: Protect definition of error_t.
	* libc/sys/linux/gethostid.c: New file.
	* libc/sys/linux/sethostid.c: Ditto.
	* libc/sys/linux/dl/Makefile.am: Ditto.
	* libc/sys/linux/dl/Makefile.in: Ditto.
	* libc/sys/linux/dl/abi-tag.h: Ditto.
	* libc/sys/linux/dl/atomicity.h: Ditto.
	* libc/sys/linux/dl/dl-addr.c: Ditto.
	* libc/sys/linux/dl/dl-cache.c: Ditto.
	* libc/sys/linux/dl/dl-cache.h: Ditto.
	* libc/sys/linux/dl/dl-close.c: Ditto.
	* libc/sys/linux/dl/dl-debug.c: Ditto.
	* libc/sys/linux/dl/dl-deps.c: Ditto.
	* libc/sys/linux/dl/dl-dst.h: Ditto.
	* libc/sys/linux/dl/dl-error.c: Ditto.
	* libc/sys/linux/dl/dl-fini.c: Ditto.
	* libc/sys/linux/dl/dl-init.c: Ditto.
	* libc/sys/linux/dl/dl-iteratephdr.c: Ditto.
	* libc/sys/linux/dl/dl-libc.c: Ditto.
	* libc/sys/linux/dl/dl-librecon.h: Ditto.
	* libc/sys/linux/dl/dl-load.c: Ditto.
	* libc/sys/linux/dl/dl-lookup.c: Ditto.
	* libc/sys/linux/dl/dl-lookupcfg.h: Ditto.
	* libc/sys/linux/dl/dl-minimal.c: Ditto.
	* libc/sys/linux/dl/dl-misc.c: Ditto.
	* libc/sys/linux/dl/dl-object.c: Ditto.
	* libc/sys/linux/dl/dl-open.c: Ditto.
	* libc/sys/linux/dl/dl-osinfo.h: Ditto.
	* libc/sys/linux/dl/dl-profile.c: Ditto.
	* libc/sys/linux/dl/dl-profstub.c: Ditto.
	* libc/sys/linux/dl/dl-reloc.c: Ditto.
	* libc/sys/linux/dl/dl-runtime.c: Ditto.
	* libc/sys/linux/dl/dl-support.c: Ditto.
	* libc/sys/linux/dl/dl-sym.c: Ditto.
	* libc/sys/linux/dl/dl-version.c: Ditto.
	* libc/sys/linux/dl/dlfcn.h: Ditto.
	* libc/sys/linux/dl/do-lookup.h: Ditto.
	* libc/sys/linux/dl/do-rel.h: Ditto.
	* libc/sys/linux/dl/dynamic-link.h: Ditto.
	* libc/sys/linux/dl/kernel-features.h: Ditto.
	* libc/sys/linux/dl/ldsodefs.h: Ditto.
	* libc/sys/linux/dl/libintl.h: Ditto.
	* libc/sys/linux/dl/trusted-dirs.h: Ditto.
	* libc/sys/linux/dl/unsecvars.h: Ditto.
	* libc/sys/linux/iconv/Makefile.am: Ditto.
	* libc/sys/linux/iconv/Makefile.in: Ditto.
	* libc/sys/linux/iconv/categories.def: Ditto.
	* libc/sys/linux/iconv/dummy-repertoire.c: Ditto.
	* libc/sys/linux/iconv/gconv.c: Ditto.
	* libc/sys/linux/iconv/gconv_builtin.c: Ditto.
	* libc/sys/linux/iconv/gconv_builtin.h: Ditto.
	* libc/sys/linux/iconv/gconv_cache.c: Ditto.
	* libc/sys/linux/iconv/gconv_charset.h: Ditto.
	* libc/sys/linux/iconv/gconv_close.c: Ditto.
	* libc/sys/linux/iconv/gconv_conf.c: Ditto.
	* libc/sys/linux/iconv/gconv_db.c: Ditto.
	* libc/sys/linux/iconv/gconv_dl.c: Ditto.
	* libc/sys/linux/iconv/gconv_int.h: Ditto.
	* libc/sys/linux/iconv/gconv_open.c: Ditto.
	* libc/sys/linux/iconv/gconv_simple.c: Ditto.
	* libc/sys/linux/iconv/gconv_trans.c: Ditto.
	* libc/sys/linux/iconv/hash-string.h: Ditto.
	* libc/sys/linux/iconv/iconv.c: Ditto.
	* libc/sys/linux/iconv/iconv.h: Ditto.
	* libc/sys/linux/iconv/iconv_charmap.c: Ditto.
	* libc/sys/linux/iconv/iconv_close.c: Ditto.
	* libc/sys/linux/iconv/iconv_open.c: Ditto.
	* libc/sys/linux/iconv/iconvconfig.c: Ditto.
	* libc/sys/linux/iconv/iconvconfig.h: Ditto.
	* libc/sys/linux/iconv/loadinfo.h: Ditto.
	* libc/sys/linux/iconv/localeinfo.h: Ditto.
	* libc/sys/linux/iconv/loop.c: Ditto.
	* libc/sys/linux/iconv/skeleton.c: Ditto.
	* libc/sys/linux/iconv/strtab.c: Ditto.
	* libc/sys/linux/include/dl-hash.h: Ditto.
	* libc/sys/linux/include/dlfcn.h: Ditto.
	* libc/sys/linux/include/fnmatch.h: Ditto.
	* libc/sys/linux/include/gconv.h: Ditto.
	* libc/sys/linux/include/glob.h: Ditto.
	* libc/sys/linux/include/hesiod.h: Ditto.
	* libc/sys/linux/include/ifaddrs.h: Ditto.
	* libc/sys/linux/include/libc_private.h: Ditto.
	* libc/sys/linux/include/link.h: Ditto.
	* libc/sys/linux/include/namespace.h: Ditto.
	* libc/sys/linux/include/netconfig.h: Ditto.
	* libc/sys/linux/include/netdb.h: Ditto.
	* libc/sys/linux/include/nsswitch.h: Ditto.
	* libc/sys/linux/include/regex.h: Ditto.
	* libc/sys/linux/include/resolv.h: Ditto.
	* libc/sys/linux/include/rune.h: Ditto.
	* libc/sys/linux/include/runetype.h: Ditto.
	* libc/sys/linux/include/semaphore.h: Ditto.
	* libc/sys/linux/include/setlocale.h: Ditto.
	* libc/sys/linux/include/un-namespace.h: Ditto.
	* libc/sys/linux/include/wordexp.h: Ditto.
	* libc/sys/linux/include/arpa/ftp.h: Ditto.
	* libc/sys/linux/include/arpa/inet.h: Ditto.
	* libc/sys/linux/include/arpa/nameser.h: Ditto.
	* libc/sys/linux/include/arpa/nameser_compat.h: Ditto.
	* libc/sys/linux/include/arpa/telnet.h: Ditto.
	* libc/sys/linux/include/arpa/tftp.h: Ditto.
	* libc/sys/linux/include/net/bpf.h: Ditto.
	* libc/sys/linux/include/net/bpf_compat.h: Ditto.
	* libc/sys/linux/include/net/bpfdesc.h: Ditto.
	* libc/sys/linux/include/net/bridge.h: Ditto.
	* libc/sys/linux/include/net/ethernet.h: Ditto.
	* libc/sys/linux/include/net/fddi.h: Ditto.
	* libc/sys/linux/include/net/if.h: Ditto.
	* libc/sys/linux/include/net/if_arc.h: Ditto.
	* libc/sys/linux/include/net/if_arp.h: Ditto.
	* libc/sys/linux/include/net/if_atm.h: Ditto.
	* libc/sys/linux/include/net/if_dl.h: Ditto.
	* libc/sys/linux/include/net/if_gif.h: Ditto.
	* libc/sys/linux/include/net/if_ieee80211.h: Ditto.
	* libc/sys/linux/include/net/if_llc.h: Ditto.
	* libc/sys/linux/include/net/if_media.h: Ditto.
	* libc/sys/linux/include/net/if_mib.h: Ditto.
	* libc/sys/linux/include/net/if_ppp.h: Ditto.
	* libc/sys/linux/include/net/if_pppvar.h: Ditto.
	* libc/sys/linux/include/net/if_slvar.h: Ditto.
	* libc/sys/linux/include/net/if_sppp.h: Ditto.
	* libc/sys/linux/include/net/if_stf.h: Ditto.
	* libc/sys/linux/include/net/if_tap.h: Ditto.
	* libc/sys/linux/include/net/if_tapvar.h: Ditto.
	* libc/sys/linux/include/net/if_tun.h: Ditto.
	* libc/sys/linux/include/net/if_tunvar.h: Ditto.
	* libc/sys/linux/include/net/if_types.h: Ditto.
	* libc/sys/linux/include/net/if_var.h: Ditto.
	* libc/sys/linux/include/net/if_vlan_var.h: Ditto.
	* libc/sys/linux/include/net/intrq.h: Ditto.
	* libc/sys/linux/include/net/iso88025.h: Ditto.
	* libc/sys/linux/include/net/net_osdep.h: Ditto.
	* libc/sys/linux/include/net/netisr.h: Ditto.
	* libc/sys/linux/include/net/pfil.h: Ditto.
	* libc/sys/linux/include/net/pfkeyv2.h: Ditto.
	* libc/sys/linux/include/net/ppp_comp.h: Ditto.
	* libc/sys/linux/include/net/ppp_defs.h: Ditto.
	* libc/sys/linux/include/net/radix.h: Ditto.
	* libc/sys/linux/include/net/raw_cb.h: Ditto.
	* libc/sys/linux/include/net/route.h: Ditto.
	* libc/sys/linux/include/net/slcompress.h: Ditto.
	* libc/sys/linux/include/net/slip.h: Ditto.
	* libc/sys/linux/include/net/zlib.h: Ditto.
	* libc/sys/linux/include/netinet/icmp6.h: Ditto.
	* libc/sys/linux/include/netinet/icmp_var.h: Ditto.
	* libc/sys/linux/include/netinet/if_atm.h: Ditto.
	* libc/sys/linux/include/netinet/if_ether.h: Ditto.
	* libc/sys/linux/include/netinet/igmp.h: Ditto.
	* libc/sys/linux/include/netinet/igmp_var.h: Ditto.
	* libc/sys/linux/include/netinet/in.h: Ditto.
	* libc/sys/linux/include/netinet/in_gif.h: Ditto.
	* libc/sys/linux/include/netinet/in_pcb.h: Ditto.
	* libc/sys/linux/include/netinet/in_systm.h: Ditto.
	* libc/sys/linux/include/netinet/in_var.h: Ditto.
	* libc/sys/linux/include/netinet/ip.h: Ditto.
	* libc/sys/linux/include/netinet/ip6.h: Ditto.
	* libc/sys/linux/include/netinet/ip_dummynet.h: Ditto.
	* libc/sys/linux/include/netinet/ip_ecn.h: Ditto.
	* libc/sys/linux/include/netinet/ip_encap.h: Ditto.
	* libc/sys/linux/include/netinet/ip_flow.h: Ditto.
	* libc/sys/linux/include/netinet/ip_fw.h: Ditto.
	* libc/sys/linux/include/netinet/ip_icmp.h: Ditto.
	* libc/sys/linux/include/netinet/ip_mroute.h: Ditto.
	* libc/sys/linux/include/netinet/ip_var.h: Ditto.
	* libc/sys/linux/include/netinet/ipprotosw.h: Ditto.
	* libc/sys/linux/include/netinet/tcp.h: Ditto.
	* libc/sys/linux/include/netinet/tcp_debug.h: Ditto.
	* libc/sys/linux/include/netinet/tcp_fsm.h: Ditto.
	* libc/sys/linux/include/netinet/tcp_seq.h: Ditto.
	* libc/sys/linux/include/netinet/tcp_timer.h: Ditto.
	* libc/sys/linux/include/netinet/tcp_var.h: Ditto.
	* libc/sys/linux/include/netinet/tcpip.h: Ditto.
	* libc/sys/linux/include/netinet/udp.h: Ditto.
	* libc/sys/linux/include/netinet/udp_var.h: Ditto.
	* libc/sys/linux/include/netinet6/ah.h: Ditto.
	* libc/sys/linux/include/netinet6/ah6.h: Ditto.
	* libc/sys/linux/include/netinet6/esp.h: Ditto.
	* libc/sys/linux/include/netinet6/esp6.h: Ditto.
	* libc/sys/linux/include/netinet6/esp_rijndael.h: Ditto.
	* libc/sys/linux/include/netinet6/icmp6.h: Ditto.
	* libc/sys/linux/include/netinet6/in6.h: Ditto.
	* libc/sys/linux/include/netinet6/in6_gif.h: Ditto.
	* libc/sys/linux/include/netinet6/in6_ifattach.h: Ditto.
	* libc/sys/linux/include/netinet6/in6_pcb.h: Ditto.
	* libc/sys/linux/include/netinet6/in6_prefix.h: Ditto.
	* libc/sys/linux/include/netinet6/in6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6_ecn.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6_fw.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6_mroute.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/ip6protosw.h: Ditto.
	* libc/sys/linux/include/netinet6/ipcomp.h: Ditto.
	* libc/sys/linux/include/netinet6/ipcomp6.h: Ditto.
	* libc/sys/linux/include/netinet6/ipsec.h: Ditto.
	* libc/sys/linux/include/netinet6/ipsec6.h: Ditto.
	* libc/sys/linux/include/netinet6/mld6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/nd6.h: Ditto.
	* libc/sys/linux/include/netinet6/pim6.h: Ditto.
	* libc/sys/linux/include/netinet6/pim6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/raw_ip6.h: Ditto.
	* libc/sys/linux/include/netinet6/scope6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/tcp6_var.h: Ditto.
	* libc/sys/linux/include/netinet6/udp6_var.h: Ditto.
	* libc/sys/linux/include/netns/idp.h: Ditto.
	* libc/sys/linux/include/netns/idp_var.h: Ditto.
	* libc/sys/linux/include/netns/ns.h: Ditto.
	* libc/sys/linux/include/netns/ns_error.h: Ditto.
	* libc/sys/linux/include/netns/ns_if.h: Ditto.
	* libc/sys/linux/include/netns/ns_pcb.h: Ditto.
	* libc/sys/linux/include/netns/sp.h: Ditto.
	* libc/sys/linux/include/netns/spidp.h: Ditto.
	* libc/sys/linux/include/netns/spp_debug.h: Ditto.
	* libc/sys/linux/include/netns/spp_timer.h: Ditto.
	* libc/sys/linux/include/netns/spp_var.h: Ditto.
	* libc/sys/linux/include/rpc/Makefile: Ditto.
	* libc/sys/linux/include/rpc/auth.h: Ditto.
	* libc/sys/linux/include/rpc/auth_des.h: Ditto.
	* libc/sys/linux/include/rpc/auth_kerb.h: Ditto.
	* libc/sys/linux/include/rpc/auth_unix.h: Ditto.
	* libc/sys/linux/include/rpc/clnt.h: Ditto.
	* libc/sys/linux/include/rpc/clnt_soc.h: Ditto.
	* libc/sys/linux/include/rpc/clnt_stat.h: Ditto.
	* libc/sys/linux/include/rpc/des.h: Ditto.
	* libc/sys/linux/include/rpc/des_crypt.h: Ditto.
	* libc/sys/linux/include/rpc/nettype.h: Ditto.
	* libc/sys/linux/include/rpc/pmap_clnt.h: Ditto.
	* libc/sys/linux/include/rpc/pmap_prot.h: Ditto.
	* libc/sys/linux/include/rpc/pmap_rmt.h: Ditto.
	* libc/sys/linux/include/rpc/raw.h: Ditto.
	* libc/sys/linux/include/rpc/rpc.h: Ditto.
	* libc/sys/linux/include/rpc/rpc_com.h: Ditto.
	* libc/sys/linux/include/rpc/rpc_msg.h: Ditto.
	* libc/sys/linux/include/rpc/rpcb_clnt.h: Ditto.
	* libc/sys/linux/include/rpc/rpcb_prot.h: Ditto.
	* libc/sys/linux/include/rpc/rpcb_prot.x: Ditto.
	* libc/sys/linux/include/rpc/rpcent.h: Ditto.
	* libc/sys/linux/include/rpc/svc.h: Ditto.
	* libc/sys/linux/include/rpc/svc_auth.h: Ditto.
	* libc/sys/linux/include/rpc/svc_dg.h: Ditto.
	* libc/sys/linux/include/rpc/svc_soc.h: Ditto.
	* libc/sys/linux/include/rpc/types.h: Ditto.
	* libc/sys/linux/include/rpc/xdr.h: Ditto.
	* libc/sys/linux/intl/Makefile.am: Ditto.
	* libc/sys/linux/intl/Makefile.in: Ditto.
	* libc/sys/linux/intl/bindtextdom.c: Ditto.
	* libc/sys/linux/intl/catgets.c: Ditto.
	* libc/sys/linux/intl/catgetsinfo.h: Ditto.
	* libc/sys/linux/intl/config.h: Ditto.
	* libc/sys/linux/intl/dcgettext.c: Ditto.
	* libc/sys/linux/intl/dcigettext.c: Ditto.
	* libc/sys/linux/intl/dcngettext.c: Ditto.
	* libc/sys/linux/intl/dgettext.c: Ditto.
	* libc/sys/linux/intl/dngettext.c: Ditto.
	* libc/sys/linux/intl/explodename.c: Ditto.
	* libc/sys/linux/intl/finddomain.c: Ditto.
	* libc/sys/linux/intl/gettext.c: Ditto.
	* libc/sys/linux/intl/gettext.h: Ditto.
	* libc/sys/linux/intl/gettextP.h: Ditto.
	* libc/sys/linux/intl/hash-string.h: Ditto.
	* libc/sys/linux/intl/l10nflist.c: Ditto.
	* libc/sys/linux/intl/loadinfo.h: Ditto.
	* libc/sys/linux/intl/loadmsgcat.c: Ditto.
	* libc/sys/linux/intl/locale.alias: Ditto.
	* libc/sys/linux/intl/localealias.c: Ditto.
	* libc/sys/linux/intl/ngettext.c: Ditto.
	* libc/sys/linux/intl/open_catalog.c: Ditto.
	* libc/sys/linux/intl/plural.c: Ditto.
	* libc/sys/linux/intl/plural.y: Ditto.
	* libc/sys/linux/intl/stpcpy.c: Ditto.
	* libc/sys/linux/intl/textdomain.c: Ditto.
	* libc/sys/linux/linuxthreads/LICENSE: Ditto.
	* libc/sys/linux/linuxthreads/Makefile.am: Ditto.
	* libc/sys/linux/linuxthreads/Makefile.in: Ditto.
	* libc/sys/linux/linuxthreads/aclocal.m4: Ditto.
	* libc/sys/linux/linuxthreads/attr.c: Ditto.
	* libc/sys/linux/linuxthreads/barrier.c: Ditto.
	* libc/sys/linux/linuxthreads/bp-sym.h: Ditto.
	* libc/sys/linux/linuxthreads/cancel.c: Ditto.
	* libc/sys/linux/linuxthreads/condvar.c: Ditto.
	* libc/sys/linux/linuxthreads/config.h: Ditto.
	* libc/sys/linux/linuxthreads/configure: Ditto.
	* libc/sys/linux/linuxthreads/configure.in: Ditto.
	* libc/sys/linux/linuxthreads/defs.awk: Ditto.
	* libc/sys/linux/linuxthreads/ecmutex.c: Ditto.
	* libc/sys/linux/linuxthreads/events.c: Ditto.
	* libc/sys/linux/linuxthreads/getcpuclockid.c: Ditto.
	* libc/sys/linux/linuxthreads/getreent.c: Ditto.
	* libc/sys/linux/linuxthreads/internals.h: Ditto.
	* libc/sys/linux/linuxthreads/join.c: Ditto.
	* libc/sys/linux/linuxthreads/joinrace.c: Ditto.
	* libc/sys/linux/linuxthreads/kernel-features.h: Ditto.
	* libc/sys/linux/linuxthreads/libc-internal.h: Ditto.
	* libc/sys/linux/linuxthreads/libc-symbols.h: Ditto.
	* libc/sys/linux/linuxthreads/linuxthreads.texi: Ditto.
	* libc/sys/linux/linuxthreads/lockfile.c: Ditto.
	* libc/sys/linux/linuxthreads/manager.c: Ditto.
	* libc/sys/linux/linuxthreads/mq_notify.c: Ditto.
	* libc/sys/linux/linuxthreads/mutex.c: Ditto.
	* libc/sys/linux/linuxthreads/no-tsd.c: Ditto.
	* libc/sys/linux/linuxthreads/oldsemaphore.c: Ditto.
	* libc/sys/linux/linuxthreads/posix-timer.h: Ditto.
	* libc/sys/linux/linuxthreads/prio.c: Ditto.
	* libc/sys/linux/linuxthreads/proc_service.h: Ditto.
	* libc/sys/linux/linuxthreads/pt-machine.c: Ditto.
	* libc/sys/linux/linuxthreads/ptclock_gettime.c: Ditto.
	* libc/sys/linux/linuxthreads/ptclock_settime.c: Ditto.
	* libc/sys/linux/linuxthreads/ptfork.c: Ditto.
	* libc/sys/linux/linuxthreads/pthread.c: Ditto.
	* libc/sys/linux/linuxthreads/ptlongjmp.c: Ditto.
	* libc/sys/linux/linuxthreads/queue.h: Ditto.
	* libc/sys/linux/linuxthreads/reent.c: Ditto.
	* libc/sys/linux/linuxthreads/reqsyscalls.c: Ditto.
	* libc/sys/linux/linuxthreads/restart.h: Ditto.
	* libc/sys/linux/linuxthreads/rwlock.c: Ditto.
	* libc/sys/linux/linuxthreads/semaphore.c: Ditto.
	* libc/sys/linux/linuxthreads/semaphore.h: Ditto.
	* libc/sys/linux/linuxthreads/shlib-compat.h: Ditto.
	* libc/sys/linux/linuxthreads/signals.c: Ditto.
	* libc/sys/linux/linuxthreads/specific.c: Ditto.
	* libc/sys/linux/linuxthreads/spinlock.c: Ditto.
	* libc/sys/linux/linuxthreads/spinlock.h: Ditto.
	* libc/sys/linux/linuxthreads/sysctl.c: Ditto.
	* libc/sys/linux/linuxthreads/td_init.c: Ditto.
	* libc/sys/linux/linuxthreads/td_log.c: Ditto.
	* libc/sys/linux/linuxthreads/td_symbol_list.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_clear_event.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_delete.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_enable_stats.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_event_addr.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_event_getmsg.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_get_nthreads.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_get_ph.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_get_stats.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_map_id2thr.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_map_lwp2thr.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_new.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_reset_stats.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_set_event.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_setconcurrency.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_thr_iter.c: Ditto.
	* libc/sys/linux/linuxthreads/td_ta_tsd_iter.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_clear_event.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_dbresume.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_dbsuspend.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_event_enable.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_event_getmsg.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_get_info.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_getfpregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_getgregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_getxregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_getxregsize.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_set_event.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_setfpregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_setgregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_setprio.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_setsigpending.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_setxregs.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_sigsetmask.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_tsd.c: Ditto.
	* libc/sys/linux/linuxthreads/td_thr_validate.c: Ditto.
	* libc/sys/linux/linuxthreads/testrtsig.h: Ditto.
	* libc/sys/linux/linuxthreads/thread_db.h: Ditto.
	* libc/sys/linux/linuxthreads/thread_dbP.h: Ditto.
	* libc/sys/linux/linuxthreads/timer_create.c: Ditto.
	* libc/sys/linux/linuxthreads/timer_delete.c: Ditto.
	* libc/sys/linux/linuxthreads/timer_getoverr.c: Ditto.
	* libc/sys/linux/linuxthreads/timer_gettime.c: Ditto.
	* libc/sys/linux/linuxthreads/timer_routines.c: Ditto.
	* libc/sys/linux/linuxthreads/timer_settime.c: Ditto.
	* libc/sys/linux/linuxthreads/tst-cancel.c: Ditto.
	* libc/sys/linux/linuxthreads/tst-context.c: Ditto.
	* libc/sys/linux/linuxthreads/tststack.c: Ditto.
	* libc/sys/linux/linuxthreads/unload.c: Ditto.
	* libc/sys/linux/linuxthreads/weaks.c: Ditto.
	* libc/sys/linux/linuxthreads/wrapsyscall.c: Ditto.
	* libc/sys/linux/linuxthreads/bits/initspin.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/libc-lock.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/libc-tsd.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/local_lim.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/posix_opt.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/pthreadtypes.h: Ditto.
	* libc/sys/linux/linuxthreads/bits/sigthread.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/Makefile.am: Ditto.
	* libc/sys/linux/linuxthreads/machine/Makefile.in: Ditto.
	* libc/sys/linux/linuxthreads/machine/aclocal.m4: Ditto.
	* libc/sys/linux/linuxthreads/machine/configure: Ditto.
	* libc/sys/linux/linuxthreads/machine/configure.in: Ditto.
	* libc/sys/linux/linuxthreads/machine/generic/generic-sysd: Ditto.ep.h
	* libc/sys/linux/linuxthreads/machine/i386/Makefile.am: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/Makefile.in: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/aclocal.m4: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/bp-asm.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/clone.S: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/configure: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/configure.in: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/i386-sysdep.S: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/i386-sysdep.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/pspinlock.c: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/pt-machine.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/sigcontextinfo.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/stackinfo.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/sysdep.S: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/sysdep.h: Ditto.
	* libc/sys/linux/linuxthreads/machine/i386/useldt.h: Ditto.
	* libc/sys/linux/machine/i386/dl-machine.h: Ditto.
	* libc/sys/linux/net/Makefile.am: Ditto.
	* libc/sys/linux/net/Makefile.in: Ditto.
	* libc/sys/linux/net/addr2ascii.3: Ditto.
	* libc/sys/linux/net/addr2ascii.c: Ditto.
	* libc/sys/linux/net/ascii2addr.c: Ditto.
	* libc/sys/linux/net/base64.c: Ditto.
	* libc/sys/linux/net/bindresvport.c: Ditto.
	* libc/sys/linux/net/byteorder.3: Ditto.
	* libc/sys/linux/net/ether_addr.c: Ditto.
	* libc/sys/linux/net/ethers.3: Ditto.
	* libc/sys/linux/net/getaddrinfo.3: Ditto.
	* libc/sys/linux/net/getaddrinfo.c: Ditto.
	* libc/sys/linux/net/gethostbydns.c: Ditto.
	* libc/sys/linux/net/gethostbyht.c: Ditto.
	* libc/sys/linux/net/gethostbyname.3: Ditto.
	* libc/sys/linux/net/gethostbynis.c: Ditto.
	* libc/sys/linux/net/gethostnamadr.c: Ditto.
	* libc/sys/linux/net/getifaddrs.3: Ditto.
	* libc/sys/linux/net/getifaddrs.c: Ditto.
	* libc/sys/linux/net/getipnodebyname.3: Ditto.
	* libc/sys/linux/net/getnameinfo.3: Ditto.
	* libc/sys/linux/net/getnameinfo.c: Ditto.
	* libc/sys/linux/net/getnetbydns.c: Ditto.
	* libc/sys/linux/net/getnetbyht.c: Ditto.
	* libc/sys/linux/net/getnetbynis.c: Ditto.
	* libc/sys/linux/net/getnetent.3: Ditto.
	* libc/sys/linux/net/getnetnamadr.c: Ditto.
	* libc/sys/linux/net/getproto.c: Ditto.
	* libc/sys/linux/net/getprotoent.3: Ditto.
	* libc/sys/linux/net/getprotoent.c: Ditto.
	* libc/sys/linux/net/getprotoname.c: Ditto.
	* libc/sys/linux/net/getservbyname.c: Ditto.
	* libc/sys/linux/net/getservbyport.c: Ditto.
	* libc/sys/linux/net/getservent.3: Ditto.
	* libc/sys/linux/net/getservent.c: Ditto.
	* libc/sys/linux/net/herror.c: Ditto.
	* libc/sys/linux/net/hesiod.3: Ditto.
	* libc/sys/linux/net/hesiod.c: Ditto.
	* libc/sys/linux/net/if_indextoname.3: Ditto.
	* libc/sys/linux/net/ifname.c: Ditto.
	* libc/sys/linux/net/inet.3: Ditto.
	* libc/sys/linux/net/inet6_option_s: Ditto.pace.3
	* libc/sys/linux/net/inet6_rthdr_space.3: Ditto.
	* libc/sys/linux/net/inet_addr.c: Ditto.
	* libc/sys/linux/net/inet_lnaof.c: Ditto.
	* libc/sys/linux/net/inet_makeaddr.c: Ditto.
	* libc/sys/linux/net/inet_net.3: Ditto.
	* libc/sys/linux/net/inet_net_ntop.c: Ditto.
	* libc/sys/linux/net/inet_net_pton.c: Ditto.
	* libc/sys/linux/net/inet_neta.c: Ditto.
	* libc/sys/linux/net/inet_netof.c: Ditto.
	* libc/sys/linux/net/inet_network.c: Ditto.
	* libc/sys/linux/net/inet_ntoa.c: Ditto.
	* libc/sys/linux/net/inet_ntop.c: Ditto.
	* libc/sys/linux/net/inet_pton.c: Ditto.
	* libc/sys/linux/net/innetgr-stub.c: Ditto.
	* libc/sys/linux/net/ip6opt.c: Ditto.
	* libc/sys/linux/net/iso_addr.3: Ditto.
	* libc/sys/linux/net/iso_addr.c: Ditto.
	* libc/sys/linux/net/issetugid-stub.c: Ditto.
	* libc/sys/linux/net/linkaddr.3: Ditto.
	* libc/sys/linux/net/linkaddr.c: Ditto.
	* libc/sys/linux/net/map_v4v6.c: Ditto.
	* libc/sys/linux/net/name6.c: Ditto.
	* libc/sys/linux/net/namespace.h: Ditto.
	* libc/sys/linux/net/ns.3: Ditto.
	* libc/sys/linux/net/ns_addr.c: Ditto.
	* libc/sys/linux/net/ns_name.c: Ditto.
	* libc/sys/linux/net/ns_netint.c: Ditto.
	* libc/sys/linux/net/ns_ntoa.c: Ditto.
	* libc/sys/linux/net/ns_parse.c: Ditto.
	* libc/sys/linux/net/ns_print.c: Ditto.
	* libc/sys/linux/net/ns_ttl.c: Ditto.
	* libc/sys/linux/net/nsap_addr.c: Ditto.
	* libc/sys/linux/net/nsdispatch.3: Ditto.
	* libc/sys/linux/net/nsdispatch.c: Ditto.
	* libc/sys/linux/net/nslexer.c: Ditto.
	* libc/sys/linux/net/nslexer.l: Ditto.
	* libc/sys/linux/net/nsparser.c: Ditto.
	* libc/sys/linux/net/nsparser.h: Ditto.
	* libc/sys/linux/net/nsparser.y: Ditto.
	* libc/sys/linux/net/rcmd.3: Ditto.
	* libc/sys/linux/net/rcmd.c: Ditto.
	* libc/sys/linux/net/rcmdsh.3: Ditto.
	* libc/sys/linux/net/rcmdsh.c: Ditto.
	* libc/sys/linux/net/recv.c: Ditto.
	* libc/sys/linux/net/res_comp.c: Ditto.
	* libc/sys/linux/net/res_config.h: Ditto.
	* libc/sys/linux/net/res_data.c: Ditto.
	* libc/sys/linux/net/res_debug.c: Ditto.
	* libc/sys/linux/net/res_init.c: Ditto.
	* libc/sys/linux/net/res_mkquery.c: Ditto.
	* libc/sys/linux/net/res_mkupdate.c: Ditto.
	* libc/sys/linux/net/res_query.c: Ditto.
	* libc/sys/linux/net/res_send.c: Ditto.
	* libc/sys/linux/net/res_update.c: Ditto.
	* libc/sys/linux/net/resolver.3: Ditto.
	* libc/sys/linux/net/rthdr.c: Ditto.
	* libc/sys/linux/net/send.c: Ditto.
	* libc/sys/linux/net/un-namespace.h: Ditto.
	* libc/sys/linux/net/vars.c: Ditto.
	* libc/sys/linux/stdlib/COPYRIGHT: Ditto.
	* libc/sys/linux/stdlib/Makefile.am: Ditto.
	* libc/sys/linux/stdlib/Makefile.in: Ditto.
	* libc/sys/linux/stdlib/cclass.h: Ditto.
	* libc/sys/linux/stdlib/cname.h: Ditto.
	* libc/sys/linux/stdlib/collate.c: Ditto.
	* libc/sys/linux/stdlib/collate.h: Ditto.
	* libc/sys/linux/stdlib/collcmp.c: Ditto.
	* libc/sys/linux/stdlib/engine.c: Ditto.
	* libc/sys/linux/stdlib/fnmatch.3: Ditto.
	* libc/sys/linux/stdlib/fnmatch.c: Ditto.
	* libc/sys/linux/stdlib/glob.3: Ditto.
	* libc/sys/linux/stdlib/glob.c: Ditto.
	* libc/sys/linux/stdlib/reallocf.c: Ditto.
	* libc/sys/linux/stdlib/regcomp.c: Ditto.
	* libc/sys/linux/stdlib/regerror.c: Ditto.
	* libc/sys/linux/stdlib/regex.3: Ditto.
	* libc/sys/linux/stdlib/regex2.h: Ditto.
	* libc/sys/linux/stdlib/regexec.c: Ditto.
	* libc/sys/linux/stdlib/regfree.c: Ditto.
	* libc/sys/linux/stdlib/utils.h: Ditto.
	* libc/sys/linux/stdlib/wordexp.c: Ditto.
	* libc/sys/linux/stdlib/wordfree.c: Ditto.
	* libc/sys/linux/sys/dlfcn.h: Ditto.
	* libc/sys/linux/sys/elfclass.h: Ditto.
	* libc/sys/linux/sys/event.h: Ditto.
	* libc/sys/linux/sys/ioccom.h: Ditto.
	* libc/sys/linux/sys/libc-tsd.h: Ditto.
	* libc/sys/linux/sys/link.h: Ditto.
	* libc/sys/linux/sys/lock.h: Ditto.
	* libc/sys/linux/sys/param.h: Ditto.
	* libc/sys/linux/sys/socket.h: Ditto.
	* libc/sys/linux/sys/sockio.h: Ditto.
@
text
@d1502 2
a1503 2
		&rtl4->rtl_entry = NULL; rtl4.rtl_type = T_A;
		&rtl6->rtl_entry = &rtl4; rtl6.rtl_type = T_AAAA;
d1507 1
a1507 1
		&rtl6->rtl_entry = NULL; rtl6.rtl_type = T_AAAA;
d1511 1
a1511 1
		&rtl4->rtl_entry = NULL; rtl4.rtl_type = T_A;
@

