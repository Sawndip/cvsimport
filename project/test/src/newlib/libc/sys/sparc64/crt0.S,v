head	1.1;
branch	1.1.1;
access;
symbols
	cygwin-1_7_35-release:1.1.1.1
	cygwin-1_7_34-release:1.1.1.1
	newlib-2_2_0:1.1.1.1.0.16
	cygwin-1_7_33-release:1.1.1.1
	cygwin-1_7_32-release:1.1.1.1
	cygwin-1_7_31-release:1.1.1.1
	cygwin-1_7_30-release:1.1.1.1
	cygwin-1_7_29-release:1.1.1.1
	cygwin-1_7_28-release:1.1.1.1
	newlib-2_1_0:1.1.1.1
	cygwin-1_7_27-release:1.1.1.1
	cygwin-1_7_26-release:1.1.1.1
	cygwin-1_7_25-release:1.1.1.1
	cygwin-1_7_24-release:1.1.1.1
	cygwin-1_7_23-release:1.1.1.1
	cygwin-1_7_22-release:1.1.1.1
	cygwin-1_7_21-release:1.1.1.1
	cygwin-1_7_20-release:1.1.1.1
	cygwin-1_7_19-release:1.1.1.1
	cygwin-64bit-postmerge:1.1.1.1
	cygwin-64bit-premerge-branch:1.1.1.1.0.14
	cygwin-64bit-premerge:1.1.1.1
	cygwin-1_7_18-release:1.1.1.1
	newlib-2_0_0:1.1.1.1
	cygwin-1_7_17-release:1.1.1.1
	cygwin-64bit-branch:1.1.1.1.0.12
	cygwin-1_7_16-release:1.1.1.1
	cygwin-1_7_15-release:1.1.1.1
	cygwin-1_7_14_2-release:1.1.1.1
	cygwin-1_7_14-release:1.1.1.1
	cygwin-1_7_12-release:1.1.1.1
	cygwin-1_7_11-release:1.1.1.1
	cygwin-1_7_10-release:1.1.1.1
	newlib-1_20_0:1.1.1.1
	cygwin-1_7_9-release:1.1.1.1
	cygwin-1_7_8-release:1.1.1.1
	newlib-1_19_0:1.1.1.1
	cygwin-1_7_7-release:1.1.1.1
	cygwin-1_7_5-release:1.1.1.1
	cygwin-1_7_4-release:1.1.1.1
	cygwin-1_7_3-release:1.1.1.1
	cygwin-1_7_2-release:1.1.1.1
	newlib-1_18_0:1.1.1.1
	cygwin-1_7_1-release:1.1.1.1
	newlib-1_17_0-arc:1.1.1.1.0.10
	binutils-arc-20080908-branch:1.1.1.1.0.8
	binutils-arc-20080908-branchpoint:1.1.1.1
	newlib-1_17_0:1.1.1.1
	newlib-1_16_0:1.1.1.1
	newlib-1_15_0:1.1.1.1
	newlib-csl-coldfire-4_1-32:1.1.1.1
	newlib-csl-sourcerygxx-4_1-32:1.1.1.1
	newlib-csl-innovasic-fido-3_4_4-33:1.1.1.1
	newlib-csl-coldfire-4_1-30:1.1.1.1
	newlib-csl-sourcerygxx-4_1-30:1.1.1.1
	newlib-csl-coldfire-4_1-28:1.1.1.1
	newlib-csl-sourcerygxx-4_1-28:1.1.1.1
	newlib-csl-arm-2006q3-27:1.1.1.1
	newlib-csl-sourcerygxx-4_1-27:1.1.1.1
	newlib-csl-arm-2006q3-26:1.1.1.1
	newlib-csl-sourcerygxx-4_1-26:1.1.1.1
	newlib-csl-sourcerygxx-4_1-24:1.1.1.1
	newlib-csl-sourcerygxx-4_1-23:1.1.1.1
	newlib-csl-sourcerygxx-4_1-21:1.1.1.1
	newlib-csl-arm-2006q3-21:1.1.1.1
	newlib-csl-arm-2006q3-19:1.1.1.1
	newlib-csl-sourcerygxx-4_1-19:1.1.1.1
	newlib-csl-sourcerygxx-4_1-18:1.1.1.1
	newlib-csl-sourcerygxx-3_4_4-25:1.1.1.1
	newlib-csl-sourcerygxx-4_1-17:1.1.1.1
	cr-0x5f1:1.1.1.1.0.6
	newlib-csl-sourcerygxx-4_1-14:1.1.1.1
	newlib-csl-sourcerygxx-4_1-13:1.1.1.1
	newlib-csl-sourcerygxx-4_1-12:1.1.1.1
	newlib-csl-sourcerygxx-4_1-9:1.1.1.1
	newlib-csl-sourcerygxx-4_1-8:1.1.1.1
	newlib-csl-sourcerygxx-4_1-7:1.1.1.1
	newlib-csl-arm-2006q1-6:1.1.1.1
	newlib-csl-sourcerygxx-4_1-6:1.1.1.1
	newlib-csl-sourcerygxx-4_1-5:1.1.1.1
	newlib-csl-sourcerygxx-4_1-4:1.1.1.1
	newlib-autotools-branch:1.1.1.1.0.4
	newlib-csl-20060320-branch:1.1.1.1.0.2
	newlib-csl-20060320-branchpoint:1.1.1.1
	newlib-1_14_0:1.1.1.1
	newlib-csl-arm-2005-q1b:1.1.1.1
	newlib-csl-arm-2005-q1a:1.1.1.1
	newlib-1_13_0:1.1.1.1
	csl-arm-2004-q3:1.1.1.1
	csl-arm-2004-q1a:1.1.1.1
	csl-arm-2004-q1:1.1.1.1
	newlib-1_12_0:1.1.1.1
	csl-arm-2003-q4:1.1.1.1
	w32api-2_2:1.1.1.1
	mingw-runtime-2_4:1.1.1.1
	newlib-1_11_0:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	newlib-1_10_0:1.1.1.1
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2000.02.17.19.39.50;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.50;	author cgf;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@! C run time start off

! This file supports:
!
! - both 32bit pointer and 64bit pointer environments (at compile time)
! - an imposed stack bias (of 2047) (at run time)
! - medium/low and medium/anywhere code models (at run time)

! Initial stack setup:
!
!    bottom of stack (higher memory address)
! 	...
!	text of environment strings
!	text of argument strings
!	envp[envc] = 0 (4/8 bytes)
!	...
!	env[0] (4/8 bytes)
!	argv[argc] = 0 (4/8 bytes)
!	...
!	argv[0] (4/8 bytes)
!	argc (4/8 bytes)
!	register save area (64 bits by 16 registers = 128 bytes)
!	top of stack (%sp)

! Stack Bias:
!
! It is the responsibility of the o/s to set this up.
! We handle both a 0 and 2047 value for the stack bias.

! Medium/Anywhere code model support:
!
! In this model %g4 points to the start of the data segment.
! The text segment can go anywhere, but %g4 points to the *data* segment.
! It is up to the compiler/linker to get this right.
!
! Since this model is statically linked the start of the data segment
! is known at link time.  Eg:
!
!	sethi	%hh(data_start), %g1
!	sethi	%lm(data_start), %g4
!	or	%g1, %hm(data_start), %g1
!	or	%g4, %lo(data_start), %g4
!	sllx	%g1, 32, %g1
!	or	%g4, %g1, %g4
!
! FIXME: For now we just assume 0.

! FIXME: if %g1 contains a non-zero value, atexit() should be invoked
! with this value.

#include <sys/syscallasm.h>

	TEXT_SECTION
	ALIGN (4)
	GLOBAL (ASM_PRIVATE_SYMBOL (start))
ASM_PRIVATE_SYMBOL (start):
	clr	%fp

! We use %g4 even if the code model is Medium/Low (simplifies the code).

	clr	%g4			! Medium/Anywhere base reg

! If there is a stack bias in effect, account for it in %g5.  Then always
! add %g5 to stack references below.  This way the code can be used with
! or without an imposed bias.

	andcc	%sp, 1, %g5
	bnz,a	.LHaveBias
	mov	2047, %g5
.LHaveBias:
	add	%sp, %g5, %sp

#if TARGET_PTR_SIZE == 32
	! FIXME: We apparently assume here that there is no reserved word.
	! This is probably correct, but try to verify it.
	ld	[%sp + 0x80], %o0	! argc
	add	%sp, 0x84, %o1		! argv
	add	%o0, 1, %o2
	sll	%o2, 2, %o2
#else /* TARGET_PTR_SIZE == 64 */
	ld	[%sp + 0x8c], %o0	! argc.lo
	add	%sp, 0x90, %o1		! argv
	add	%o0, 1, %o2
	sll	%o2, 3, %o2
#endif
	add	%o1, %o2, %o2		! envp
	sethi	%hi (ASM_SYMBOL (environ)), %o3
	or	%o3, %lo (ASM_SYMBOL (environ)), %o3
#if TARGET_PTR_SIZE == 32
	st	%o2, [%o3 + %g4]
#else /* TARGET_PTR_SIZE == 64 */
	stx	%o2, [%o3 + %g4]
#endif

! Restore any stack bias before we call main() ...

	sub	%sp, %g5, %sp

	GLOBAL (ASM_SYMBOL (main))
	call	ASM_SYMBOL (main)

! FIXME: Not sure if this is needed anymore.
#if TARGET_PTR_SIZE == 32
	sub	%sp, 0x20, %sp		! room to push args
#else /* TARGET_PTR_SIZE == 64 */
	sub	%sp, 0x30, %sp		! room to push args
#endif

	GLOBAL (ASM_SYMBOL (exit))
	call	ASM_SYMBOL (exit)
	nop

	GLOBAL (ASM_SYMBOL (_exit))
	call	ASM_SYMBOL (_exit)
	nop

	set	SYS_exit, %g1
	ta	SYSCALL_TRAP		! in case user redefines __exit

! If all the above methods fail to terminate the program, try an illegal insn.
! If that does not work, the o/s is hosed more than we are.

	WORD (0)
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
