head	1.5;
access;
symbols
	cygwin-1_7_35-release:1.5
	cygwin-1_7_34-release:1.5
	newlib-2_2_0:1.5.0.10
	cygwin-1_7_33-release:1.5
	cygwin-1_7_32-release:1.5
	cygwin-1_7_31-release:1.5
	cygwin-1_7_30-release:1.5
	cygwin-1_7_29-release:1.5
	cygwin-1_7_28-release:1.5
	newlib-2_1_0:1.5
	cygwin-1_7_27-release:1.5
	cygwin-1_7_26-release:1.5
	cygwin-1_7_25-release:1.5
	cygwin-1_7_24-release:1.5
	cygwin-1_7_23-release:1.5
	cygwin-1_7_22-release:1.5
	cygwin-1_7_21-release:1.5
	cygwin-1_7_20-release:1.5
	cygwin-1_7_19-release:1.5
	cygwin-64bit-postmerge:1.5
	cygwin-64bit-premerge-branch:1.5.0.8
	cygwin-64bit-premerge:1.5
	cygwin-1_7_18-release:1.5
	newlib-2_0_0:1.5
	cygwin-1_7_17-release:1.5
	cygwin-64bit-branch:1.5.0.6
	cygwin-1_7_16-release:1.5
	cygwin-1_7_15-release:1.5
	cygwin-1_7_14_2-release:1.5
	cygwin-1_7_14-release:1.5
	cygwin-1_7_12-release:1.5
	cygwin-1_7_11-release:1.5
	cygwin-1_7_10-release:1.5
	newlib-1_20_0:1.5
	cygwin-1_7_9-release:1.5
	cygwin-1_7_8-release:1.5
	newlib-1_19_0:1.5
	cygwin-1_7_7-release:1.5
	cygwin-1_7_5-release:1.5
	cygwin-1_7_4-release:1.5
	cygwin-1_7_3-release:1.5
	cygwin-1_7_2-release:1.5
	newlib-1_18_0:1.5
	cygwin-1_7_1-release:1.5
	newlib-1_17_0-arc:1.5.0.4
	binutils-arc-20080908-branch:1.5.0.2
	binutils-arc-20080908-branchpoint:1.5
	newlib-1_17_0:1.5
	newlib-1_16_0:1.5
	newlib-1_15_0:1.4
	newlib-csl-coldfire-4_1-32:1.4
	newlib-csl-sourcerygxx-4_1-32:1.4
	newlib-csl-innovasic-fido-3_4_4-33:1.4
	newlib-csl-coldfire-4_1-30:1.4
	newlib-csl-sourcerygxx-4_1-30:1.4
	newlib-csl-coldfire-4_1-28:1.4
	newlib-csl-sourcerygxx-4_1-28:1.4
	newlib-csl-arm-2006q3-27:1.4
	newlib-csl-sourcerygxx-4_1-27:1.4
	newlib-csl-arm-2006q3-26:1.4
	newlib-csl-sourcerygxx-4_1-26:1.4
	newlib-csl-sourcerygxx-4_1-24:1.4
	newlib-csl-sourcerygxx-4_1-23:1.4
	newlib-csl-sourcerygxx-4_1-21:1.4
	newlib-csl-arm-2006q3-21:1.4
	newlib-csl-arm-2006q3-19:1.4
	newlib-csl-sourcerygxx-4_1-19:1.4
	newlib-csl-sourcerygxx-4_1-18:1.4
	newlib-csl-sourcerygxx-3_4_4-25:1.4
	newlib-csl-sourcerygxx-4_1-17:1.4
	cr-0x5f1:1.4.0.6
	newlib-csl-sourcerygxx-4_1-14:1.4
	newlib-csl-sourcerygxx-4_1-13:1.4
	newlib-csl-sourcerygxx-4_1-12:1.4
	newlib-csl-sourcerygxx-4_1-9:1.4
	newlib-csl-sourcerygxx-4_1-8:1.4
	newlib-csl-sourcerygxx-4_1-7:1.4
	newlib-csl-arm-2006q1-6:1.4
	newlib-csl-sourcerygxx-4_1-6:1.4
	newlib-csl-sourcerygxx-4_1-5:1.4
	newlib-csl-sourcerygxx-4_1-4:1.4
	newlib-autotools-branch:1.4.0.4
	newlib-csl-20060320-branch:1.4.0.2
	newlib-csl-20060320-branchpoint:1.4
	newlib-1_14_0:1.4
	newlib-csl-arm-2005-q1b:1.4
	newlib-csl-arm-2005-q1a:1.4
	newlib-1_13_0:1.4
	csl-arm-2004-q3:1.4
	csl-arm-2004-q1a:1.4
	csl-arm-2004-q1:1.4
	newlib-1_12_0:1.4
	csl-arm-2003-q4:1.4
	w32api-2_2:1.4
	mingw-runtime-2_4:1.4
	newlib-1_11_0:1.4
	cygnus_cvs_20020108_pre:1.2
	newlib-1_10_0:1.2;
locks; strict;
comment	@ * @;


1.5
date	2007.06.10.12.54.35;	author hp;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.10.22.15.49;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.13.00.01.27;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.18.23.47.59;	author hp;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.13.02.49.12;	author hp;	state Exp;
branches;
next	;


desc
@@


1.5
log
@	* libc/sys/mmixware/access.c (access): Do not try to use a magic
	file-handle and a direct syscall, just use _open.
	* libc/sys/mmixware/sys/syscall.h (TMPFNO): Remove this magic
	file-handle.

	* libc/sys/mmixware/_exit.c (_exit): Update comment about
	passing on the exit value.
@
text
@/* syscall defines for MMIXware.

   Copyright (C) 2001, 2002, 2007 Hans-Peter Nilsson

   Permission to use, copy, modify, and distribute this software is
   freely granted, provided that the above copyright notice, this notice
   and the following disclaimer are preserved with no changes.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE.  */

/* These are the mmixware simulator calls that are of use in newlib.  */

#define SYS_halt	0
#define	SYS_Fopen	1
#define	SYS_Fclose	2
#define	SYS_Fread	3
#define	SYS_Fgets	4
#define	SYS_Fwrite	6
#define	SYS_Fseek	9
#define	SYS_Ftell	10


enum MMIX_filemode
 {
   TextRead = 0,
   TextWrite = 1,
   BinaryRead = 2,
   BinaryWrite = 3,
   BinaryReadWrite = 4
 };

#define N_MMIX_FILEHANDLES 32

/* We store a bitmap of allocated filehandles
   _MMIX_allocated_filehandle[fileno] in an array.  There are 32 of them.
   Indexes 0, 1 and 2 are allocated from start.  The reason we keep track
   of them is that *we* have to allocate a filehandle when opening a file.
   Had we got a filehandle from the simulator, we wouldn't have to keep
   track of it.  A value of 0 denotes a free handle.  */
extern unsigned char _MMIX_allocated_filehandle[N_MMIX_FILEHANDLES];

/* Simulator call with one argument.  Also used for zero-argument calls;
   pass a zero as ARG1.  Make the asm volatile so we can safely ignore the
   return-value and only get the benefit from the supposed side-effect
   without the asm being optimized away.  */
#define TRAP1i(FUN, ARG1)			\
 ({ long ret_;					\
    __asm__ __volatile__			\
      ("TRAP 0,%1,%2\n\tSET %0,$255"		\
       : "=r" (ret_) : "i" (FUN), "i" (ARG1)	\
       : "memory");				\
    ret_;					\
 })

/* Helper macros to cope with the file-handle parameter to the simulator
   being *constant*.  We support up to 32 simultaneously open files.  Make
   the asm volatile so we can safely ignore the return-value and get the
   benefit from the supposed side-effect without the asm being optimized
   away.  */

#define I3f(FUN, ARG1, N, ARGS)				\
 if (ARG1 == N)						\
   __asm__ __volatile__					\
     ("SET $255,%3\n\tTRAP 0,%1,%2\n\tSET %0,$255"	\
      : "=r" (ret_) : "i" (FUN), "i" (N), "r" (ARGS)	\
      : "memory")

/* Using if:s rather than switches to help GCC optimize the rest away.  */
#define DO32(FUN, ARG1, ARGS)			\
    I3f (FUN, ARG1, 0, ARGS);			\
    else I3f (FUN, ARG1, 1, ARGS);		\
    else I3f (FUN, ARG1, 2, ARGS);		\
    else I3f (FUN, ARG1, 3, ARGS);		\
    else I3f (FUN, ARG1, 4, ARGS);		\
    else I3f (FUN, ARG1, 5, ARGS);		\
    else I3f (FUN, ARG1, 6, ARGS);		\
    else I3f (FUN, ARG1, 7, ARGS);		\
    else I3f (FUN, ARG1, 8, ARGS);		\
    else I3f (FUN, ARG1, 9, ARGS);		\
    else I3f (FUN, ARG1, 10, ARGS);		\
    else I3f (FUN, ARG1, 11, ARGS);		\
    else I3f (FUN, ARG1, 12, ARGS);		\
    else I3f (FUN, ARG1, 13, ARGS);		\
    else I3f (FUN, ARG1, 14, ARGS);		\
    else I3f (FUN, ARG1, 15, ARGS);		\
    else I3f (FUN, ARG1, 16, ARGS);		\
    else I3f (FUN, ARG1, 17, ARGS);		\
    else I3f (FUN, ARG1, 18, ARGS);		\
    else I3f (FUN, ARG1, 19, ARGS);		\
    else I3f (FUN, ARG1, 20, ARGS);		\
    else I3f (FUN, ARG1, 21, ARGS);		\
    else I3f (FUN, ARG1, 22, ARGS);		\
    else I3f (FUN, ARG1, 23, ARGS);		\
    else I3f (FUN, ARG1, 24, ARGS);		\
    else I3f (FUN, ARG1, 25, ARGS);		\
    else I3f (FUN, ARG1, 26, ARGS);		\
    else I3f (FUN, ARG1, 27, ARGS);		\
    else I3f (FUN, ARG1, 28, ARGS);		\
    else I3f (FUN, ARG1, 29, ARGS);		\
    else I3f (FUN, ARG1, 30, ARGS);		\
    else I3f (FUN, ARG1, 31, ARGS);		\
    else					\
      {						\
        errno = EBADF;				\
	return -1;				\
      }

#define TRAP1f(FUN, ARG1)			\
 ({ long ret_;					\
    DO32 (FUN, ARG1, 0);			\
    ret_;					\
 })

#define TRAP2f(FUN, ARG1, ARG2)			\
 ({ long ret_;					\
    DO32 (FUN, ARG1, ARG2);			\
    ret_;					\
 })

#define TRAP3f(FUN, ARG1, ARG2, ARG3)				\
 ({ long ret_;							\
    unsigned long args_[]					\
      = { (unsigned long) (ARG2), (unsigned long) (ARG3) };	\
    DO32 (FUN, ARG1, args_);					\
    ret_;							\
 })

#ifndef __GNUC__
/* Probably will not happen.  Nevertheless...  */
# define UNIMPLEMENTED(MSG)
#else
# define UNIMPLEMENTED(MSG) UNIMPLEMENTEDi MSG
# define UNIMPLEMENTEDi(MSG, ARGS...)					\
 do {									\
     char buf[2000];							\
     sprintf (buf, "UNIMPLEMENTED %s in %s\n", __FUNCTION__, __FILE__);	\
     write (2, buf, strlen (buf));					\
     sprintf (buf, MSG , ##ARGS);					\
     write (2, buf, strlen (buf));					\
     write (2, "\n", 1);						\
 } while (0)
#endif
@


1.4
log
@
2002-07-10  Florian Shrack  <florian.schrack@@freenet.de>

        * libc/sys/mmixware/read.c: Use SYS_Fgets syscall if dealing with
        a terminal.
        * libc/sys/mmixware/sys/syscall.h (SYS_Fgets): Definition added.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002 Hans-Peter Nilsson
a44 4
/* We use this file-handle number as a temporary; not used by usual file
   I/O.  */
#define TMPFNO 127

@


1.3
log
@
2002-02-12  Hans-Peter Nilsson  <hp@@bitrange.com>

        * libc/sys/mmixware/link.c: New.
        * libc/sys/mmixware/sys/syscall.h (TRAP1i, I3f): Make asm
        volatile.
        * libc/sys/mmixware/times.c (_times): Renamed from times.
        * libc/sys/mmixware/open.c (_open): Attempt to handle O_APPEND
        properly by reading previous contents, not through BinaryReadWrite.
        * libc/sys/mmixware/Makefile.am (lib_a_SOURCES): Add link.c
        * libc/sys/mmixware/Makefile.in: Regenerate.
@
text
@d20 1
@


1.2
log
@	* libc/sys/mmixware/*: Tweak license header in all source files.
@
text
@d3 1
a3 1
   Copyright (C) 2001 Hans-Peter Nilsson
d49 10
a58 7
   pass a zero as ARG1.  */
#define TRAP1i(FUN, ARG1)				\
 ({ long ret_;						\
    __asm__ ("TRAP 0,%1,%2\n\tSET %0,$255"		\
	     : "=r" (ret_) : "i" (FUN), "i" (ARG1)	\
	     : "memory");				\
    ret_;						\
d62 11
a72 6
   being *constant*.  We support up to 32 simultaneously open files.  */
#define I3f(FUN, ARG1, N, ARGS)					\
 if (ARG1 == N)							\
   __asm__ ("SET $255,%3\n\tTRAP 0,%1,%2\n\tSET %0,$255"	\
	    : "=r" (ret_) : "i" (FUN), "i" (N), "r" (ARGS)	\
	    : "memory")
@


1.1
log
@	* libc/sys/mmixware/*: Correct spacing in all source files.
	* libc/sys/mmixware/syscall.h: Move misplaced file...
	* libc/sys/mmixware/sys/syscall.h: ...here.
@
text
@d3 6
a8 3
   Copyright (C) 2001 Hans-Peter Nilsson.
   Permission to use, copy, modify, and distribute this software is freely
   granted, provided that this notice is preserved with no changes.
@

