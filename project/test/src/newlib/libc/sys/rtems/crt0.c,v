head	1.15;
access;
symbols
	cygwin-1_7_35-release:1.15
	cygwin-1_7_34-release:1.15
	newlib-2_2_0:1.15.0.2
	cygwin-1_7_33-release:1.15
	cygwin-1_7_32-release:1.15
	cygwin-1_7_31-release:1.15
	cygwin-1_7_30-release:1.15
	cygwin-1_7_29-release:1.15
	cygwin-1_7_28-release:1.15
	newlib-2_1_0:1.15
	cygwin-1_7_27-release:1.15
	cygwin-1_7_26-release:1.15
	cygwin-1_7_25-release:1.14
	cygwin-1_7_24-release:1.14
	cygwin-1_7_23-release:1.14
	cygwin-1_7_22-release:1.14
	cygwin-1_7_21-release:1.14
	cygwin-1_7_20-release:1.14
	cygwin-1_7_19-release:1.14
	cygwin-64bit-postmerge:1.14
	cygwin-64bit-premerge-branch:1.14.0.4
	cygwin-64bit-premerge:1.14
	cygwin-1_7_18-release:1.14
	newlib-2_0_0:1.14
	cygwin-1_7_17-release:1.14
	cygwin-64bit-branch:1.14.0.2
	cygwin-1_7_16-release:1.14
	cygwin-1_7_15-release:1.13
	cygwin-1_7_14_2-release:1.13
	cygwin-1_7_14-release:1.13
	cygwin-1_7_12-release:1.13
	cygwin-1_7_11-release:1.13
	cygwin-1_7_10-release:1.13
	newlib-1_20_0:1.13
	cygwin-1_7_9-release:1.12
	cygwin-1_7_8-release:1.12
	newlib-1_19_0:1.11
	cygwin-1_7_7-release:1.11
	cygwin-1_7_5-release:1.11
	cygwin-1_7_4-release:1.11
	cygwin-1_7_3-release:1.11
	cygwin-1_7_2-release:1.11
	newlib-1_18_0:1.11
	cygwin-1_7_1-release:1.10
	newlib-1_17_0-arc:1.10.0.2
	binutils-arc-20080908-branch:1.9.0.8
	binutils-arc-20080908-branchpoint:1.9
	newlib-1_17_0:1.10
	newlib-1_16_0:1.9
	newlib-1_15_0:1.9
	newlib-csl-coldfire-4_1-32:1.9
	newlib-csl-sourcerygxx-4_1-32:1.9
	newlib-csl-innovasic-fido-3_4_4-33:1.9
	newlib-csl-coldfire-4_1-30:1.9
	newlib-csl-sourcerygxx-4_1-30:1.9
	newlib-csl-coldfire-4_1-28:1.9
	newlib-csl-sourcerygxx-4_1-28:1.9
	newlib-csl-arm-2006q3-27:1.9
	newlib-csl-sourcerygxx-4_1-27:1.9
	newlib-csl-arm-2006q3-26:1.9
	newlib-csl-sourcerygxx-4_1-26:1.9
	newlib-csl-sourcerygxx-4_1-24:1.9
	newlib-csl-sourcerygxx-4_1-23:1.9
	newlib-csl-sourcerygxx-4_1-21:1.9
	newlib-csl-arm-2006q3-21:1.9
	newlib-csl-arm-2006q3-19:1.9
	newlib-csl-sourcerygxx-4_1-19:1.9
	newlib-csl-sourcerygxx-4_1-18:1.9
	newlib-csl-sourcerygxx-3_4_4-25:1.9
	newlib-csl-sourcerygxx-4_1-17:1.9
	cr-0x5f1:1.9.0.6
	newlib-csl-sourcerygxx-4_1-14:1.9
	newlib-csl-sourcerygxx-4_1-13:1.9
	newlib-csl-sourcerygxx-4_1-12:1.9
	newlib-csl-sourcerygxx-4_1-9:1.9
	newlib-csl-sourcerygxx-4_1-8:1.9
	newlib-csl-sourcerygxx-4_1-7:1.9
	newlib-csl-arm-2006q1-6:1.9
	newlib-csl-sourcerygxx-4_1-6:1.9
	newlib-csl-sourcerygxx-4_1-5:1.9
	newlib-csl-sourcerygxx-4_1-4:1.9
	newlib-autotools-branch:1.9.0.4
	newlib-csl-20060320-branch:1.9.0.2
	newlib-csl-20060320-branchpoint:1.9
	newlib-1_14_0:1.9
	newlib-csl-arm-2005-q1b:1.8
	newlib-csl-arm-2005-q1a:1.8
	newlib-1_13_0:1.8
	csl-arm-2004-q3:1.7
	csl-arm-2004-q1a:1.7
	csl-arm-2004-q1:1.7
	newlib-1_12_0:1.7
	csl-arm-2003-q4:1.6
	w32api-2_2:1.6
	mingw-runtime-2_4:1.6
	newlib-1_11_0:1.5
	cygnus_cvs_20020108_pre:1.2
	newlib-1_10_0:1.2
	newlib-1_9_0:1.2
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.15
date	2013.11.23.01.25.47;	author joel;	state Exp;
branches;
next	1.14;

1.14
date	2012.05.09.09.03.06;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2011.08.20.05.34.22;	author corsepiu;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.07.19.27.33;	author jjohnstn;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.16.18.28.14;	author jjohnstn;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.12.17.11.33;	author jjohnstn;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.06.21.58.45;	author jjohnstn;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.25.17.53.19;	author jjohnstn;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.08.19.25.21;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.16.22.37.53;	author jjohnstn;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.08.13.09.05;	author joel;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.19.18.53.40;	author joel;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.12.21.12.19;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.04.18.34.49;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.50;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.50;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.15
log
@2013-11-22  Bryan Dunsmore <dunsmoreb@@gmail.com>

	* libc/include/sys/time.h (gettimeofday): Add restrict keyword.
	(setitimer): Likewise.
	* libc/sys/rdos/gettod.c (gettimeofday): Likewise.
	* libc/sys/rtems/crt0.c (gettimeofday): Likewise.
@
text
@/*
 *  RTEMS Fake crt0
 *
 *  Each RTEMS BSP provides its own crt0 and linker script.  Unfortunately
 *  this means that crt0 and the linker script are not available as
 *  each tool is configured.  Without a crt0 and linker script, some
 *  targets do not successfully link "conftest.c" during the configuration 
 *  process.  So this fake crt0.c provides all the symbols required to
 *  successfully link a program.  The resulting program will not run
 *  but this is enough to satisfy the autoconf macro AC_PROG_CC.
 */

#include <reent.h>

#include <signal.h> /* sigset_t */
#include <time.h> /* struct timespec */
#include <unistd.h> /* isatty */

void rtems_provides_crt0( void ) {}  /* dummy symbol so file always has one */

#define RTEMS_STUB(ret, func, body) \
ret rtems_stub_##func body; \
ret func body

/* RTEMS provides some of its own routines including a Malloc family */
RTEMS_STUB(void *,malloc(size_t s), { return 0; })
RTEMS_STUB(void *,realloc(void* p, size_t s), { return 0; })
RTEMS_STUB(void, free(void* ptr), { })
RTEMS_STUB(_PTR, calloc(size_t s1, size_t s2), { return 0; })

#if defined(__GNUC__)
/*
 * stubs for libstdc++ rtems-threads support functions from gcc/gthr-rtems.h
 */
int rtems_gxx_once() { return -1; }
int rtems_gxx_key_create() { return -1; }
int rtems_gxx_key_delete() { return -1; }
void *rtems_gxx_getspecific() { return 0; }
int rtems_gxx_setspecific() { return -1; }

void rtems_gxx_mutex_init() { }
int rtems_gxx_mutex_lock() { return -1; }
int rtems_gxx_mutex_trylock() { return -1; }
int rtems_gxx_mutex_unlock() { return -1; }

void rtems_gxx_recursive_mutex_init() { }
int rtems_gxx_recursive_mutex_lock() { return -1; }
int rtems_gxx_recursive_mutex_trylock() { return -1; }
int rtems_gxx_recursive_mutex_unlock() { return -1; }
#endif

/* stubs for functions RTEMS provides */
RTEMS_STUB(int, access(const char *pathname, int mode), { return -1; })
RTEMS_STUB(int, clock_gettime(clockid_t clk_id, struct timespec *tp), { return -1; })
RTEMS_STUB(int, close (int fd), { return -1; })
RTEMS_STUB(int, dup2(int oldfd, int newfd), { return -1; })
RTEMS_STUB(int, fcntl( int fd, int cmd, ... /* arg */ ), { return -1; })
RTEMS_STUB(pid_t, fork(void), { return -1; })
RTEMS_STUB(int, fstat(int fd, struct stat *buf), { return -1; })
RTEMS_STUB(int, getdents(int fd, void *dp, int count), { return -1; })
RTEMS_STUB(char *, getlogin(void), { return 0; })
RTEMS_STUB(int, gettimeofday(struct timeval *__restrict tv, struct timezone *__restrict tz), { return -1; })
RTEMS_STUB(struct passwd *, getpwnam(const char *name), { return 0; })
RTEMS_STUB(struct passwd *, getpwuid(uid_t uid), { return 0; })
RTEMS_STUB(uid_t, getuid(void), { return 0; })
RTEMS_STUB(int, nanosleep(const struct timespec *req, struct timespec *rem), { return -1; })
RTEMS_STUB(int, ftruncate(int fd, off_t length), { return -1; })
RTEMS_STUB(_off_t, lseek(int fd, _off_t offset, int whence), { return -1; })
RTEMS_STUB(int, lstat(const char *path, struct stat *buf), { return -1; })
RTEMS_STUB(int, open(const char *pathname, int flags, int mode), { return -1; })
RTEMS_STUB(int, pipe(int pipefd[2]), { return -1; })
RTEMS_STUB(_ssize_t, read(int fd, void *buf, size_t count), { return -1; })
RTEMS_STUB(int, sched_yield(void), { return -1; })
RTEMS_STUB(int, sigfillset(sigset_t *set), { return -1; })
RTEMS_STUB(int, sigprocmask(int how, const sigset_t *set, sigset_t *oldset), { return -1; })
RTEMS_STUB(int, stat(const char *path, struct stat *buf), { return -1; })
RTEMS_STUB(int, unlink(const char *pathname), { return -1; })
RTEMS_STUB(pid_t, vfork(void), { return -1; })
#if !defined(_NO_POPEN) && !defined(_NO_WORDEXP)
/* pulled in by libc/sys/posix/popen.c and libc/sys/posix/word*.c */
RTEMS_STUB(int, waitpid (pid_t pid, int *status, int options), { return -1; })
#endif
RTEMS_STUB(_ssize_t, write (int fd, const void *buf, size_t nbytes), { return -1; })

/* stubs for functions from reent.h */
RTEMS_STUB(int, _close_r (struct _reent *r, int fd), { return -1; })
#if defined(_NO_EXECVE)
RTEMS_STUB(int, _execve_r (struct _reent *r, char *, char **, char **), { return -1; })
#endif
RTEMS_STUB(int, _fcntl_r (struct _reent *ptr, int fd, int cmd, int arg ), { return -1; })
#if !(defined (REENTRANT_SYSCALLS_PROVIDED) || defined (NO_EXEC))
#ifndef NO_FORK
/* cf. newlib/libc/reent/execr.c */
RTEMS_STUB(int, _fork_r (struct _reent *r), { return -1; })
#endif
#endif
RTEMS_STUB(int, _fstat_r (struct _reent *r, int fd, struct stat *buf), { return -1; })
RTEMS_STUB(uid_t, geteuid (), { return -1; })
RTEMS_STUB(gid_t, getgid (), { return -1; })
RTEMS_STUB(gid_t, _getgid_r (struct _reent *r), { return -1; })
RTEMS_STUB(pid_t, getpid (), { return -1; })
RTEMS_STUB(pid_t, getppid (), { return -1; })
RTEMS_STUB(pid_t, _getpid_r (struct _reent *r), { return -1; })
RTEMS_STUB(int, _gettimeofday_r(struct _reent *r, struct timeval *tp, void *tzp), { return 0; })
RTEMS_STUB(int, _isatty_r (struct _reent *r, int fd), { return isatty( fd ); })
RTEMS_STUB(int, _kill_r (struct _reent *r, int pid, int sig ), { return -1; })
#if !defined(REENTRANT_SYSCALLS_PROVIDED)
/* cf. newlib/libc/reent/linkr.c */
RTEMS_STUB(int, _link_r (struct _reent *r, const char *oldpath, const char *newpath), { return -1; })
#endif
RTEMS_STUB(_off_t, _lseek_r ( struct _reent *ptr, int fd, _off_t offset, int whence ), { return -1; })
RTEMS_STUB(int, _open_r (struct _reent *r, const char *buf, int flags, int mode), { return -1; })
RTEMS_STUB(_ssize_t, _read_r (struct _reent *r, int fd, void *buf, size_t nbytes), { return -1; })
RTEMS_STUB(int, _rename_r (struct _reent *r, const char *a, const char *b), { return -1; })
#if !(defined (REENTRANT_SYSCALLS_PROVIDED) || defined (MALLOC_PROVIDED))
/* cf. newlib/libc/reent/sbrkr.c */
RTEMS_STUB(void *,_sbrk_r (struct _reent *r, ptrdiff_t addr), { return 0; })
#endif
RTEMS_STUB(int, _stat_r (struct _reent *r, const char *path, struct stat *buf), { return -1; })
RTEMS_STUB(_CLOCK_T_, _times_r (struct _reent *r, struct tms *ptms), { return -1; })
RTEMS_STUB(int, _unlink_r (struct _reent *r, const char *path), { return -1; })
#if !(defined (REENTRANT_SYSCALLS_PROVIDED) || defined (NO_EXEC))
/* cf. newlib/libc/reent/execr.c */
RTEMS_STUB(int, _wait_r (struct _reent *r, int *status), { return -1; })
#endif
RTEMS_STUB(_ssize_t, _write_r (struct _reent *r, int fd, const void *buf, size_t nbytes), { return -1; })


RTEMS_STUB(int, _execve(const char *path, char * const *argv, char * const *envp), { return -1; })
RTEMS_STUB(void, _exit(int status), { while(1); })

/* Pulled in by newlib/libc/posix/glob.c */
#ifndef _NO_GLOB
#ifndef __NETBSD_SYSCALLS
RTEMS_STUB(int, issetugid (void), { return 0; })
#endif
#endif

/* stdlib.h */
RTEMS_STUB(_PTR, _realloc_r(struct _reent *r, _PTR p, size_t s), { return 0; })
RTEMS_STUB(_PTR, _calloc_r(struct _reent *r, size_t s1, size_t s2), { return 0; })
RTEMS_STUB(_PTR, _malloc_r(struct _reent * r, size_t s), { return 0; })
RTEMS_STUB(_VOID, _free_r(struct _reent *r, _PTR *p), { })

/* stubs for functions required by libc/stdlib */
RTEMS_STUB(void, __assert_func(const char *file, int line, const char *failedexpr), { })

/* The PowerPC expects certain symbols to be defined in the linker script. */

#if defined(__PPC__)
  int __SDATA_START__;  int __SDATA2_START__;
  int __GOT_START__;    int __GOT_END__;
  int __GOT2_START__;   int __GOT2_END__;
  int __SBSS_END__;     int __SBSS2_END__;
  int __FIXUP_START__;  int __FIXUP_END__;
  int __EXCEPT_START__; int __EXCEPT_END__;
  int __init;           int __fini;
  int __CTOR_LIST__;    int __CTOR_END__;
  int __DTOR_LIST__;    int __DTOR_END__;
#endif

/* The SH expects certain symbols to be defined in the linker script. */

#if defined(__sh__)
int __EH_FRAME_BEGIN__;
#endif

#if defined(__AVR__)
/*
 * Initial stack pointer address "__stack"
 *  hard coded into GCC instead of providing it through ldscripts
 */
const char* __stack ;
#endif
@


1.14
log
@	* libc/sys/rtems/crt0.c: Add stubs for access(), ftruncate(),
	_getpid_r(), geteuid(), getgid, _getgid_r, getpid(), getppid(),
	and _getpid_r().
@
text
@d62 1
a62 1
RTEMS_STUB(int, gettimeofday(struct timeval *tv, struct timezone *tz), { return -1; })
@


1.13
log
@2011-08-19  Ralf Corsépius <ralf.corsepius@@rtems.org>

	* libc/sys/rtems/crt0.c: Rework RTEMS_STUB macro.
	Include <unistd.h>.
	Remove C++-style comments.
	Remove hppa, a29k.
	Add clock_gettime, gettimeofday, sched_yield.
@
text
@d53 1
d67 1
d98 6
a103 1
RTEMS_STUB(int, _getpid_r (struct _reent *r), { return -1; })
@


1.12
log
@
2011-01-07  Ralf Corsepius  <ralf.corsepius@@rtems.org>

        * libc/sys/rtems/crt0.c: Adjust free() and calloc() to match their
        public decls.
@
text
@d15 3
a17 2
#include <signal.h> // sigset_t
#include <time.h> // struct timespec
d21 3
a23 3
#define RTEMS_STUB(ret, func) \
ret rtems_stub_##func {}; \
ret func
d26 4
a29 4
RTEMS_STUB(void *,malloc(size_t s)) { return 0; }
RTEMS_STUB(void *,realloc(void* p, size_t s)) { return 0; }
RTEMS_STUB(void, free(void* ptr)) { ; }
RTEMS_STUB(_PTR, calloc(size_t s1, size_t s2)) {}
d53 24
a76 21
RTEMS_STUB(int, close (int fd)) { return -1; }
RTEMS_STUB(int, dup2(int oldfd, int newfd)) { return -1; }
RTEMS_STUB(int, fcntl( int fd, int cmd, ... /* arg */ )) { return -1; }
RTEMS_STUB(pid_t, fork(void)) { return -1; }
RTEMS_STUB(int, fstat(int fd, struct stat *buf)) { return -1; }
RTEMS_STUB(int, getdents(int fd, void *dp, int count)) { return -1; }
RTEMS_STUB(char *, getlogin(void)) { return 0; }
RTEMS_STUB(struct passwd *, getpwnam(const char *name)) { return 0; }
RTEMS_STUB(struct passwd *, getpwuid(uid_t uid)) { return 0; }
RTEMS_STUB(uid_t, getuid(void)) { return 0; }
RTEMS_STUB(int, nanosleep(const struct timespec *req, struct timespec *rem)) { return -1; }
RTEMS_STUB(_off_t, lseek(int fd, _off_t offset, int whence)) { return -1; }
RTEMS_STUB(int, lstat(const char *path, struct stat *buf)) { return -1; }
RTEMS_STUB(int, open(const char *pathname, int flags, int mode)) { return -1; }
RTEMS_STUB(int, pipe(int pipefd[2])) { return -1; }
RTEMS_STUB(_ssize_t, read(int fd, void *buf, size_t count)) { return -1; }
RTEMS_STUB(int, sigfillset(sigset_t *set)) { return -1; }
RTEMS_STUB(int, sigprocmask(int how, const sigset_t *set, sigset_t *oldset)) { return -1; }
RTEMS_STUB(int, stat(const char *path, struct stat *buf)) { return -1; }
RTEMS_STUB(int, unlink(const char *pathname)) { return -1; }
RTEMS_STUB(pid_t, vfork(void)) { return -1; }
d79 1
a79 1
RTEMS_STUB(int, waitpid (pid_t pid, int *status, int options)) { return -1; }
d81 1
a81 1
RTEMS_STUB(_ssize_t, write (int fd, const void *buf, size_t nbytes)) { return -1; }
d84 1
a84 1
RTEMS_STUB(int, _close_r (struct _reent *r, int fd)) { return -1; }
d86 1
a86 1
RTEMS_STUB(int, _execve_r (struct _reent *r, char *, char **, char **)) { return -1; }
d88 1
a88 1
RTEMS_STUB(int, _fcntl_r (struct _reent *ptr, int fd, int cmd, int arg )) { return -1; }
d92 1
a92 1
RTEMS_STUB(int, _fork_r (struct _reent *r)) { return -1; }
d95 5
a99 5
RTEMS_STUB(int, _fstat_r (struct _reent *r, int fd, struct stat *buf)) { return -1; }
RTEMS_STUB(int, _getpid_r (struct _reent *r)) { return -1; }
RTEMS_STUB(int, _gettimeofday_r(struct _reent *r, struct timeval *tp, void *tzp)) { return 0; }
RTEMS_STUB(int, _isatty_r (struct _reent *r, int fd)) { return isatty( fd ); }
RTEMS_STUB(int, _kill_r (struct _reent *r, int pid, int sig )) { return -1; }
d102 1
a102 1
RTEMS_STUB(int, _link_r (struct _reent *, const char *, const char *)) { return -1; }
d104 4
a107 4
RTEMS_STUB(_off_t, _lseek_r ( struct _reent *ptr, int fd, _off_t offset, int whence )) { return -1; }
RTEMS_STUB(int, _open_r (struct _reent *r, const char *buf, int flags, int mode)) { return -1; }
RTEMS_STUB(_ssize_t, _read_r (struct _reent *r, int fd, void *buf, size_t nbytes)) { return -1; }
RTEMS_STUB(int, _rename_r (struct _reent *r, const char *a, const char *b)){ return -1; }
d110 1
a110 1
RTEMS_STUB(void *,_sbrk_r (struct _reent *r, ptrdiff_t)) { return -1; }
d112 3
a114 3
RTEMS_STUB(int, _stat_r (struct _reent *r, const char *path, struct stat *buf)) { return -1; }
RTEMS_STUB(_CLOCK_T_, _times_r (struct _reent *r, struct tms *ptms)) { return -1; }
RTEMS_STUB(int, _unlink_r (struct _reent *r, const char *path)) { return -1; }
d117 1
a117 1
RTEMS_STUB(int, _wait_r (struct _reent *r, int *)) { return -1; }
d119 1
a119 1
RTEMS_STUB(_ssize_t, _write_r (struct _reent *r, int fd, const void *buf, size_t nbytes)) { return -1; }
d122 2
a123 2
RTEMS_STUB(int, _execve(const char *path, char * const *argv, char * const *envp)) { return -1; }
RTEMS_STUB(void, _exit(int status)) { while(1); }
d128 1
a128 1
RTEMS_STUB(int, issetugid (void)) { return 0; }
d133 4
a136 4
RTEMS_STUB(_PTR, _realloc_r(struct _reent *r, _PTR p, size_t s)) {}
RTEMS_STUB(_PTR, _calloc_r(struct _reent *r, size_t s1, size_t s2)) {}
RTEMS_STUB(_PTR, _malloc_r(struct _reent *r, size_t s)) {}
RTEMS_STUB(_VOID, _free_r(struct _reent *r, _PTR p)) {}
d139 1
a139 1
RTEMS_STUB(void, __assert_func(const char *file, int line, const char *failedexpr)) {}
a160 35
/*  The hppa expects this to be defined in the real crt0.s. 
 *  Also for some reason, the hppa1.1 does not find atexit()
 *  during the AC_PROG_CC tests.
 */

#if defined(__hppa__)
/*
  asm ( ".subspa \$GLOBAL\$,QUAD=1,ALIGN=8,ACCESS=0x1f,SORT=40");
  asm ( ".export \$global\$" );
  asm ( "\$global\$:");
*/

  asm (".text");
  asm (".global");
  asm (".EXPORT $$dyncall,ENTRY");
  asm ("$$dyncall:");
  int atexit(void (*function)(void)) { return 0; }
#endif


/*
 *  The AMD a29k generates code expecting the following.
 */

#if defined(_AM29000) || defined(_AM29K)
asm (".global V_SPILL, V_FILL" );
asm (".global V_EPI_OS, V_BSD_OS" );

asm (".equ    V_SPILL, 64" );
asm (".equ    V_FILL, 65" );

asm (".equ    V_BSD_OS, 66" );
asm (".equ    V_EPI_OS, 69" );
#endif

@


1.11
log
@
2009-12-16  Ralf CorsÃ©pius <ralf.corsepius@@rtems.org>

        * libc/sys/rtems/machine/_types.h: New (Derived from
        machine/_default_types.h).
        * libc/sys/rtems/crt0.c: Rework. Introduce macro RTEMS_STUB.
        * libc/sys/rtems/sys/param.h:
        Update copyright notice from FreeBSD.
        Remove HZ.
        Add #include <sys/priority.h>
        Remove priority handling (moved to sys/priority.h).
        Remove CLBYTES (Unused, abandoned in BSD).
        * libc/sys/rtems/sys/queue.h: Update copyright (from FreeBSD).
        Remove CIRCLEQ_*.
@
text
@d27 2
a28 2
RTEMS_STUB(void, free(void)) { ; }
RTEMS_STUB(_PTR, calloc(struct _reent *r, size_t s1, size_t s2)) {}
@


1.10
log
@
2008-12-12  Ralf Corsepius  <ralf.corsepius@@rtems.org>

        * libc/sys/rtems/crt0.c: Add stubs for getdents(), nanosleep(),
        _execve(), _exit().
@
text
@d15 3
d20 4
d25 4
a28 6

void *malloc() { return 0; }
void *realloc() { return 0; }
void free() { ; }
void abort() { ; }
int raise() { return -1; }
d51 28
d80 56
a135 47
int _close_r (struct _reent *r, int fd) { return -1; }
#if NOT_USED_BY_RTEMS
int _execve_r (struct _reent *r, char *, char **, char **) { return -1; }
#endif
int _fcntl_r (  struct _reent *ptr, int fd, int cmd, int arg ) { return -1;}
#if NOT_USED_BY_RTEMS
int _fork_r (struct _reent *r) { return -1; }
#endif
int _fstat_r (struct _reent *r, int fd, struct stat *buf) { return -1; }
int _getpid_r (struct _reent *r) { return -1; }
int _kill_r ( struct _reent *r, int pid, int sig ) { return -1; }
int _link_r ( struct _reent *ptr, const char *existing, const char *new) { return -1; }
_off_t _lseek_r ( struct _reent *ptr, int fd, _off_t offset, int whence ) { return -1; }
int _open_r (struct _reent *r, const char *buf, int flags, int mode) { return -1; }
_ssize_t _read_r (struct _reent *r, int fd, void *buf, size_t nbytes) { return -1; }
#if NOT_USED_BY_RTEMS 
void *_sbrk_r (struct _reent *r, ptrdiff_t) { return -1; }
#endif
int _stat_r (struct _reent *r, const char *path, struct stat *buf) { return -1; }
_CLOCK_T_ _times_r (struct _reent *r, struct tms *ptms) { return -1; }
int _unlink_r (struct _reent *r, const char *path) { return -1; }
#if NOT_USED_BY_RTEMS
int _wait_r (struct _reent *r, int *) { return -1; }
#endif
_ssize_t _write_r (struct _reent *r, int fd, const void *buf, size_t nbytes) { return -1; }

int isatty( int fd ) { return -1; }

_realloc_r() {}
_calloc_r() {}
_malloc_r() {}
_free_r() {}

/* stubs for functions required by libc/posix */
int getdents(int fd, void *dp, int count) { return -1; }
struct timespec;
int nanosleep(const struct timespec *req, struct timespec *rem) { return -1; }
int _execve(const char *path, char * const *argv, char * const *envp) { return -1; }
int _exit(int status) { return -1; }

/* gcc can implicitly generate references to these */
/* strcmp() {} */
/* strcpy() {} */
/* strlen() {} */
/* memcmp() {} */
/* memcpy() {} */
/* memset() {} */
@


1.9
log
@
2005-12-06  Ralf Corsepius <ralf.corsepius@@rtems.org>

        * libc/sys/rtems/crt0.c: Add rtems_gxx_key_create,
        rtems_gxx_key_delete, rtems_gxx_getspecific,
        rtems_gxx_setspecific, rtems_gxx_mutex_trylock,
        rtems_gxx_recursive_mutex_init, rtems_gxx_recursive_mutex_lock,
        rtems_gxx_recursive_mutex_trylock, rtems_gxx_recursive_mutex_unlock.
@
text
@d80 7
@


1.8
log
@
2001-10-25  Ralf Corsepius <corsepiu@@faw.uni-ulm.de>

        * libc/include/machine/setjmp.h: Add AVR support.
        * libc/sys/rtems/crt0.S [__AVR__]: Add __stack.
@
text
@d24 11
d37 1
d39 6
a44 1
int rtems_gxx_once() { return -1; }
@


1.7
log
@
2004-01-08  Joel Sherrill  <joel@@oarcorp.com>

        * libc/sys/rtems/sys/queue.h: New file.
        * libc/include/sys/signal.h: Reflect renumbering of signals to
        fit into 32-bit mask.
        * libc/include/sys/unistd.h: Add fdatasync() prototype.
        * libc/sys/rtems/crt0.c: Add more symbols which may be implicitly
        required.  In particular, add the reentrant variants of libc calls.
        * libc/sys/rtems/sys/dirent.h: Add scandir() prototype.
@
text
@d125 8
@


1.6
log
@
2003-01-16  Joel Sherrill <joel@@OARcorp.com>

        * libc/sys/rtems/include/limits.h, libc/sys/rtems/sys/param.h,
        libc/sys/rtems/sys/syslimits.h: Update to be in sync with what
        constants are defined in each file in the shared versions in
        libc/include.
        * libc/sys/rtems/crt0.c: Define extra symbols on SH and HP-PA to
        autoconf can link programs.
        * libc/include/machine/types.h: Explicitly specify signed on
        intXX_t types to ensure they are signed.
@
text
@a0 1
void rtems_provides_crt0( void ) {}
d13 4
d29 34
d64 6
a69 6
strcmp() {}
strcpy() {}
strlen() {}
memcmp() {}
memcpy() {}
memset() {}
@


1.5
log
@2002-10-07	Joel Sherrill <joel@@OARcorp.com>

	* libc/sys/rtems/crt0.c: Add even more symbols so gcc() can link
	dummy programs.
@
text
@d44 2
d66 4
@


1.4
log
@2002-04-19	Joel Sherrill <joel@@OARcorp.com>

	* libs/sys/rtems/crt0.c: Satisfy gcc's references to libc functions
	while autoconf is trying to link main(){}.
@
text
@d46 6
@


1.3
log
@
2002-04-12  Eric Norum  <eric.norum@@usask.com>

        * libc/sys/rtems/crt0.c (rtems_gxx_mutex_init): Dummy
        routine to allow autoconf to determine that building executables
        for rtems works.
        (rtems_gxx_mutex_lock, rtems_gxx_mutex_unlock): Ditto.
        (rtems_gxx_mutex_once): Ditto.
@
text
@d26 1
a26 3
/* gcc 2.8.1 implicitly can generate references to these for at
 * least sparc-elf */
#if (__GNUC__ == 2) && (__GNUC_MINOR__ == 8)
a32 1
#endif
@


1.2
log
@
2000-12-04  Joel Sherrill <joel@@OARcorp.com>

        * libc/sys/rtems/crt0.c: Add stubs for functions implicitly
        referenced by code generated by gcc 2.8.1.
        (a29k): Add stubs for V_SPILL, V_FILL, V_BSD_OS, V_EPI_OS to
        satisfy gcc.
@
text
@d21 4
@


1.1
log
@Initial revision
@
text
@d21 12
a32 1
 
d60 15
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
