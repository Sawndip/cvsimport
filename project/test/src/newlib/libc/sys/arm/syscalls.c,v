head	1.17;
access;
symbols
	cygwin-1_7_35-release:1.17
	cygwin-1_7_34-release:1.17
	newlib-2_2_0:1.17.0.2
	cygwin-1_7_33-release:1.17
	cygwin-1_7_32-release:1.17
	cygwin-1_7_31-release:1.17
	cygwin-1_7_30-release:1.17
	cygwin-1_7_29-release:1.17
	cygwin-1_7_28-release:1.16
	newlib-2_1_0:1.16
	cygwin-1_7_27-release:1.16
	cygwin-1_7_26-release:1.16
	cygwin-1_7_25-release:1.16
	cygwin-1_7_24-release:1.16
	cygwin-1_7_23-release:1.16
	cygwin-1_7_22-release:1.16
	cygwin-1_7_21-release:1.15
	cygwin-1_7_20-release:1.15
	cygwin-1_7_19-release:1.15
	cygwin-64bit-postmerge:1.15
	cygwin-64bit-premerge-branch:1.15.0.8
	cygwin-64bit-premerge:1.15
	cygwin-1_7_18-release:1.15
	newlib-2_0_0:1.15
	cygwin-1_7_17-release:1.15
	cygwin-64bit-branch:1.15.0.6
	cygwin-1_7_16-release:1.15
	cygwin-1_7_15-release:1.15
	cygwin-1_7_14_2-release:1.15
	cygwin-1_7_14-release:1.15
	cygwin-1_7_12-release:1.15
	cygwin-1_7_11-release:1.15
	cygwin-1_7_10-release:1.15
	newlib-1_20_0:1.15
	cygwin-1_7_9-release:1.15
	cygwin-1_7_8-release:1.15
	newlib-1_19_0:1.15
	cygwin-1_7_7-release:1.15
	cygwin-1_7_5-release:1.15
	cygwin-1_7_4-release:1.15
	cygwin-1_7_3-release:1.15
	cygwin-1_7_2-release:1.15
	newlib-1_18_0:1.15
	cygwin-1_7_1-release:1.15
	newlib-1_17_0-arc:1.15.0.4
	binutils-arc-20080908-branch:1.15.0.2
	binutils-arc-20080908-branchpoint:1.15
	newlib-1_17_0:1.15
	newlib-1_16_0:1.14
	newlib-1_15_0:1.13
	newlib-csl-coldfire-4_1-32:1.11.2.4
	newlib-csl-sourcerygxx-4_1-32:1.11.2.4
	newlib-csl-innovasic-fido-3_4_4-33:1.11.2.4
	newlib-csl-coldfire-4_1-30:1.11.2.4
	newlib-csl-sourcerygxx-4_1-30:1.11.2.4
	newlib-csl-coldfire-4_1-28:1.11.2.4
	newlib-csl-sourcerygxx-4_1-28:1.11.2.4
	newlib-csl-arm-2006q3-27:1.11.2.4
	newlib-csl-sourcerygxx-4_1-27:1.11.2.4
	newlib-csl-arm-2006q3-26:1.11.2.4
	newlib-csl-sourcerygxx-4_1-26:1.11.2.4
	newlib-csl-sourcerygxx-4_1-24:1.11.2.4
	newlib-csl-sourcerygxx-4_1-23:1.11.2.4
	newlib-csl-sourcerygxx-4_1-21:1.11.2.4
	newlib-csl-arm-2006q3-21:1.11.2.4
	newlib-csl-arm-2006q3-19:1.11.2.4
	newlib-csl-sourcerygxx-4_1-19:1.11.2.4
	newlib-csl-sourcerygxx-4_1-18:1.11.2.4
	newlib-csl-sourcerygxx-3_4_4-25:1.13
	newlib-csl-sourcerygxx-4_1-17:1.11.2.3
	cr-0x5f1:1.13.0.2
	newlib-csl-sourcerygxx-4_1-14:1.11.2.3
	newlib-csl-sourcerygxx-4_1-13:1.11.2.3
	newlib-csl-sourcerygxx-4_1-12:1.11.2.3
	newlib-csl-sourcerygxx-4_1-9:1.11.2.3
	newlib-csl-sourcerygxx-4_1-8:1.11.2.3
	newlib-csl-sourcerygxx-4_1-7:1.11.2.2
	newlib-csl-arm-2006q1-6:1.11.2.2
	newlib-csl-sourcerygxx-4_1-6:1.11.2.2
	newlib-csl-sourcerygxx-4_1-5:1.11.2.1
	newlib-csl-sourcerygxx-4_1-4:1.11.2.1
	newlib-autotools-branch:1.11.0.4
	newlib-csl-20060320-branch:1.11.0.2
	newlib-csl-20060320-branchpoint:1.11
	newlib-1_14_0:1.10
	newlib-csl-arm-2005-q1b:1.10
	newlib-csl-arm-2005-q1a:1.10
	newlib-1_13_0:1.9
	csl-arm-2004-q3:1.9
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	newlib-1_12_0:1.9
	csl-arm-2003-q4:1.8
	w32api-2_2:1.8
	mingw-runtime-2_4:1.8
	newlib-1_11_0:1.8
	cygnus_cvs_20020108_pre:1.3
	newlib-1_10_0:1.3
	newlib-1_9_0:1.3
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2014.02.11.19.54.30;	author jjohnstn;	state Exp;
branches;
next	1.16;

1.16
date	2013.07.19.09.57.51;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.03.22.33.37;	author jjohnstn;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.06.16.56.30;	author jjohnstn;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.13.20.50.24;	author jjohnstn;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.05.19.45.08;	author jjohnstn;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.07.18.44.54;	author jjohnstn;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2005.02.08.01.33.19;	author jjohnstn;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.06.19.27.21;	author jjohnstn;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.06.20.46.37;	author fitzsim;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.29.21.52.36;	author jlarmour;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.29.21.49.56;	author jlarmour;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.12.21.25.12;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.17.16.39.53;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.24.18.17.17;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.23.20.19.13;	author fnasser;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.49;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.11.2.1
date	2006.03.23.18.36.10;	author mmitchel;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2006.05.31.13.52.58;	author mmitchel;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2006.06.09.15.52.15;	author sandra;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2006.08.22.20.48.23;	author pbrook;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.39.49;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.17
log
@
2014-02-11  Joey Ye  <joey.ye@@arm.com>

        * libc/sys/arm/syscalls.c (_sbrk): Define as weak symbols.
        (_read, _write): Ditto.
@
text
@/* Support files for GNU libc.  Files in the system namespace go here.
   Files in the C namespace (ie those that do not start with an
   underscore) go in .c.  */

#include <_ansi.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/fcntl.h>
#include <stdio.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>
#include <errno.h>
#include <reent.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>
#include "swi.h"

/* Forward prototypes.  */
int     _system     _PARAMS ((const char *));
int     _rename     _PARAMS ((const char *, const char *));
int     _isatty		_PARAMS ((int));
clock_t _times		_PARAMS ((struct tms *));
int     _gettimeofday	_PARAMS ((struct timeval *, void *));
void    _raise 		_PARAMS ((void));
int     _unlink		_PARAMS ((const char *));
int     _link 		_PARAMS ((void));
int     _stat 		_PARAMS ((const char *, struct stat *));
int     _fstat 		_PARAMS ((int, struct stat *));
caddr_t _sbrk		_PARAMS ((int));
int     _getpid		_PARAMS ((int));
int     _kill		_PARAMS ((int, int));
void    _exit		_PARAMS ((int));
int     _close		_PARAMS ((int));
int     _swiclose	_PARAMS ((int));
int     _open		_PARAMS ((const char *, int, ...));
int     _swiopen	_PARAMS ((const char *, int));
int     _write 		_PARAMS ((int, char *, int));
int     _swiwrite	_PARAMS ((int, char *, int));
int     _lseek		_PARAMS ((int, int, int));
int     _swilseek	_PARAMS ((int, int, int));
int     _read		_PARAMS ((int, char *, int));
int     _swiread	_PARAMS ((int, char *, int));
void    initialise_monitor_handles _PARAMS ((void));

static int	wrap		_PARAMS ((int));
static int	error		_PARAMS ((int));
static int	get_errno	_PARAMS ((void));
static int	remap_handle	_PARAMS ((int));
static int 	findslot	_PARAMS ((int));

/* Register name faking - works in collusion with the linker.  */
register char * stack_ptr asm ("sp");


/* following is copied from libc/stdio/local.h to check std streams */
extern void   _EXFUN(__sinit,(struct _reent *));
#define CHECK_INIT(ptr) \
  do						\
    {						\
      if ((ptr) && !(ptr)->__sdidinit)		\
	__sinit (ptr);				\
    }						\
  while (0)

/* Adjust our internal handles to stay away from std* handles.  */
#define FILE_HANDLE_OFFSET (0x20)

static int monitor_stdin;
static int monitor_stdout;
static int monitor_stderr;

/* Struct used to keep track of the file position, just so we
   can implement fseek(fh,x,SEEK_CUR).  */
typedef struct
{
  int handle;
  int pos;
}
poslog;

#define MAX_OPEN_FILES 20
static poslog openfiles [MAX_OPEN_FILES];

static int
findslot (int fh)
{
  int i;
  for (i = 0; i < MAX_OPEN_FILES; i ++)
    if (openfiles[i].handle == fh)
      break;
  return i;
}

/* Function to convert std(in|out|err) handles to internal versions.  */
static int
remap_handle (int fh)
{
  CHECK_INIT(_REENT);

  if (fh == STDIN_FILENO)
    return monitor_stdin;
  if (fh == STDOUT_FILENO)
    return monitor_stdout;
  if (fh == STDERR_FILENO)
    return monitor_stderr;

  return fh - FILE_HANDLE_OFFSET;
}

void
initialise_monitor_handles (void)
{
  int i;
  
#ifdef ARM_RDI_MONITOR
  int volatile block[3];
  
  block[0] = (int) ":tt";
  block[2] = 3;     /* length of filename */
  block[1] = 0;     /* mode "r" */
  monitor_stdin = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);

  block[0] = (int) ":tt";
  block[2] = 3;     /* length of filename */
  block[1] = 4;     /* mode "w" */
  monitor_stdout = monitor_stderr = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);
#else
  int fh;
  const char * name;

  name = ":tt";
  asm ("mov r0,%2; mov r1, #0; swi %a1; mov %0, r0"
       : "=r"(fh)
       : "i" (SWI_Open),"r"(name)
       : "r0","r1");
  monitor_stdin = fh;

  name = ":tt";
  asm ("mov r0,%2; mov r1, #4; swi %a1; mov %0, r0"
       : "=r"(fh)
       : "i" (SWI_Open),"r"(name)
       : "r0","r1");
  monitor_stdout = monitor_stderr = fh;
#endif

  for (i = 0; i < MAX_OPEN_FILES; i ++)
    openfiles[i].handle = -1;

  openfiles[0].handle = monitor_stdin;
  openfiles[0].pos = 0;
  openfiles[1].handle = monitor_stdout;
  openfiles[1].pos = 0;
}

static int
get_errno (void)
{
#ifdef ARM_RDI_MONITOR
  return do_AngelSWI (AngelSWI_Reason_Errno, NULL);
#else
  asm ("swi %a0" :: "i" (SWI_GetErrno));
#endif
}

static int
error (int result)
{
  errno = get_errno ();
  return result;
}

static int
wrap (int result)
{
  if (result == -1)
    return error (-1);
  return result;
}

/* Returns # chars not! written.  */
int
_swiread (int file,
	  char * ptr,
	  int len)
{
  int fh = remap_handle (file);
#ifdef ARM_RDI_MONITOR
  int block[3];
  
  block[0] = fh;
  block[1] = (int) ptr;
  block[2] = len;
  
  return do_AngelSWI (AngelSWI_Reason_Read, block);
#else
  asm ("mov r0, %1; mov r1, %2;mov r2, %3; swi %a0"
       : /* No outputs */
       : "i"(SWI_Read), "r"(fh), "r"(ptr), "r"(len)
       : "r0","r1","r2");
#endif
}

int __attribute__((weak))
_read (int file,
       char * ptr,
       int len)
{
  int slot = findslot (remap_handle (file));
  int x = _swiread (file, ptr, len);

  if (x < 0)
    return error (-1);

  if (slot != MAX_OPEN_FILES)
    openfiles [slot].pos += len - x;

  /* x == len is not an error, at least if we want feof() to work.  */
  return len - x;
}

int
_swilseek (int file,
	   int ptr,
	   int dir)
{
  int res;
  int fh = remap_handle (file);
  int slot = findslot (fh);
#ifdef ARM_RDI_MONITOR
  int block[2];
#endif

  if (dir == SEEK_CUR)
    {
      if (slot == MAX_OPEN_FILES)
	return -1;
      ptr = openfiles[slot].pos + ptr;
      dir = SEEK_SET;
    }
  
#ifdef ARM_RDI_MONITOR
  if (dir == SEEK_END)
    {
      block[0] = fh;
      ptr += do_AngelSWI (AngelSWI_Reason_FLen, block);
    }
  
  /* This code only does absolute seeks.  */
  block[0] = remap_handle (file);
  block[1] = ptr;
  res = do_AngelSWI (AngelSWI_Reason_Seek, block);
#else
  if (dir == SEEK_END)
    {
      asm ("mov r0, %2; swi %a1; mov %0, r0"
	   : "=r" (res)
	   : "i" (SWI_Flen), "r" (fh)
	   : "r0");
      ptr += res;
    }

  /* This code only does absolute seeks.  */
  asm ("mov r0, %2; mov r1, %3; swi %a1; mov %0, r0"
       : "=r" (res)
       : "i" (SWI_Seek), "r" (fh), "r" (ptr)
       : "r0", "r1");
#endif

  if (slot != MAX_OPEN_FILES && res == 0)
    openfiles[slot].pos = ptr;

  /* This is expected to return the position in the file.  */
  return res == 0 ? ptr : -1;
}

int
_lseek (int file,
	int ptr,
	int dir)
{
  return wrap (_swilseek (file, ptr, dir));
}

/* Returns #chars not! written.  */
int
_swiwrite (
	   int    file,
	   char * ptr,
	   int    len)
{
  int fh = remap_handle (file);
#ifdef ARM_RDI_MONITOR
  int block[3];
  
  block[0] = fh;
  block[1] = (int) ptr;
  block[2] = len;
  
  return do_AngelSWI (AngelSWI_Reason_Write, block);
#else
  asm ("mov r0, %1; mov r1, %2;mov r2, %3; swi %a0"
       : /* No outputs */
       : "i"(SWI_Write), "r"(fh), "r"(ptr), "r"(len)
       : "r0","r1","r2");
#endif
}

int __attribute__((weak))
_write (int    file,
	char * ptr,
	int    len)
{
  int slot = findslot (remap_handle (file));
  int x = _swiwrite (file, ptr,len);

  if (x == -1 || x == len)
    return error (-1);
  
  if (slot != MAX_OPEN_FILES)
    openfiles[slot].pos += len - x;
  
  return len - x;
}

extern int strlen (const char *);

int
_swiopen (const char * path,
	  int          flags)
{
  int aflags = 0, fh;
#ifdef ARM_RDI_MONITOR
  int block[3];
#endif
  
  int i = findslot (-1);
  
  if (i == MAX_OPEN_FILES)
    return -1;

  /* The flags are Unix-style, so we need to convert them.  */
#ifdef O_BINARY
  if (flags & O_BINARY)
    aflags |= 1;
#endif

  if (flags & O_RDWR)
    aflags |= 2;

  if (flags & O_CREAT)
    aflags |= 4;

  if (flags & O_TRUNC)
    aflags |= 4;

  if (flags & O_APPEND)
    {
      aflags &= ~4;     /* Can't ask for w AND a; means just 'a'.  */
      aflags |= 8;
    }
  
#ifdef ARM_RDI_MONITOR
  block[0] = (int) path;
  block[2] = strlen (path);
  block[1] = aflags;
  
  fh = do_AngelSWI (AngelSWI_Reason_Open, block);
  
#else
  asm ("mov r0,%2; mov r1, %3; swi %a1; mov %0, r0"
       : "=r"(fh)
       : "i" (SWI_Open),"r"(path),"r"(aflags)
       : "r0","r1");
#endif
  
  if (fh >= 0)
    {
      openfiles[i].handle = fh;
      openfiles[i].pos = 0;
    }

  return fh >= 0 ? fh + FILE_HANDLE_OFFSET : error (fh);
}

int
_open (const char * path,
       int          flags,
       ...)
{
  return wrap (_swiopen (path, flags));
}

int
_swiclose (int file)
{
  int myhan = remap_handle (file);
  int slot = findslot (myhan);
  
  if (slot != MAX_OPEN_FILES)
    openfiles[slot].handle = -1;

#ifdef ARM_RDI_MONITOR
  return do_AngelSWI (AngelSWI_Reason_Close, & myhan);
#else
  asm ("mov r0, %1; swi %a0" :: "i" (SWI_Close),"r"(myhan):"r0");
#endif
}

int
_close (int file)
{
  return wrap (_swiclose (file));
}

int
_kill (int pid, int sig)
{
  (void)pid; (void)sig;
#ifdef ARM_RDI_MONITOR
  /* Note: The pid argument is thrown away.  */
  switch (sig) {
	  case SIGABRT:
		  return do_AngelSWI (AngelSWI_Reason_ReportException,
				  (void *) ADP_Stopped_RunTimeError);
	  default:
		  return do_AngelSWI (AngelSWI_Reason_ReportException,
				  (void *) ADP_Stopped_ApplicationExit);
  }
#else
  asm ("swi %a0" :: "i" (SWI_Exit));
#endif
}

void
_exit (int status)
{
  /* There is only one SWI for both _exit and _kill. For _exit, call
     the SWI with the second argument set to -1, an invalid value for
     signum, so that the SWI handler can distinguish the two calls.
     Note: The RDI implementation of _kill throws away both its
     arguments.  */
  _kill(status, -1);
}

int
_getpid (int n)
{
  return 1;
  n = n;
}

caddr_t __attribute__((weak))
_sbrk (int incr)
{
  extern char   end asm ("end");	/* Defined by the linker.  */
  static char * heap_end;
  char *        prev_heap_end;

  if (heap_end == NULL)
    heap_end = & end;
  
  prev_heap_end = heap_end;
  
  if (heap_end + incr > stack_ptr)
    {
      /* Some of the libstdc++-v3 tests rely upon detecting
	 out of memory errors, so do not abort here.  */
#if 0
      extern void abort (void);

      _write (1, "_sbrk: Heap and stack collision\n", 32);
      
      abort ();
#else
      errno = ENOMEM;
      return (caddr_t) -1;
#endif
    }
  
  heap_end += incr;

  return (caddr_t) prev_heap_end;
}

extern void memset (struct stat *, int, unsigned int);

int
_fstat (int file, struct stat * st)
{
  memset (st, 0, sizeof (* st));
  st->st_mode = S_IFCHR;
  st->st_blksize = 1024;
  return 0;
  file = file;
}

int _stat (const char *fname, struct stat *st)
{
  int file;

  /* The best we can do is try to open the file readonly.  If it exists,
     then we can guess a few things about it.  */
  if ((file = _open (fname, O_RDONLY)) < 0)
    return -1;

  memset (st, 0, sizeof (* st));
  st->st_mode = S_IFREG | S_IREAD;
  st->st_blksize = 1024;
  _swiclose (file); /* Not interested in the error.  */
  return 0;
}

int
_link (void)
{
  return -1;
}

int
_unlink (const char *path)
{
#ifdef ARM_RDI_MONITOR
  int block[2];
  block[0] = path;
  block[1] = strlen(path);
  return wrap (do_AngelSWI (AngelSWI_Reason_Remove, block)) ? -1 : 0;
#else  
  return -1;
#endif
}

void
_raise (void)
{
  return;
}

int
_gettimeofday (struct timeval * tp, void * tzvp)
{
  struct timezone *tzp = tzvp;
  if (tp)
    {
    /* Ask the host for the seconds since the Unix epoch.  */
#ifdef ARM_RDI_MONITOR
      tp->tv_sec = do_AngelSWI (AngelSWI_Reason_Time,NULL);
#else
      {
        int value;
        asm ("swi %a1; mov %0, r0" : "=r" (value): "i" (SWI_Time) : "r0");
        tp->tv_sec = value;
      }
#endif
      tp->tv_usec = 0;
    }

  /* Return fixed data for the timezone.  */
  if (tzp)
    {
      tzp->tz_minuteswest = 0;
      tzp->tz_dsttime = 0;
    }

  return 0;
}

/* Return a clock that ticks at 100Hz.  */
clock_t 
_times (struct tms * tp)
{
  clock_t timeval;

#ifdef ARM_RDI_MONITOR
  timeval = do_AngelSWI (AngelSWI_Reason_Clock,NULL);
#else
  asm ("swi %a1; mov %0, r0" : "=r" (timeval): "i" (SWI_Clock) : "r0");
#endif

  if (tp)
    {
      tp->tms_utime  = timeval;	/* user time */
      tp->tms_stime  = 0;	/* system time */
      tp->tms_cutime = 0;	/* user time, children */
      tp->tms_cstime = 0;	/* system time, children */
    }
  
  return timeval;
};


int
_isatty (int fd)
{
#ifdef ARM_RDI_MONITOR
  int fh = remap_handle (fd);
  return wrap (do_AngelSWI (AngelSWI_Reason_IsTTY, &fh));
#else
  return (fd <= 2) ? 1 : 0;  /* one of stdin, stdout, stderr */
#endif
}

int
_system (const char *s)
{
#ifdef ARM_RDI_MONITOR
  int block[2];
  int e;

  /* Hmmm.  The ARM debug interface specification doesn't say whether
     SYS_SYSTEM does the right thing with a null argument, or assign any
     meaning to its return value.  Try to do something reasonable....  */
  if (!s)
    return 1;  /* maybe there is a shell available? we can hope. :-P */
  block[0] = s;
  block[1] = strlen (s);
  e = wrap (do_AngelSWI (AngelSWI_Reason_System, block));
  if ((e >= 0) && (e < 256))
    {
      /* We have to convert e, an exit status to the encoded status of
         the command.  To avoid hard coding the exit status, we simply
	 loop until we find the right position.  */
      int exit_code;

      for (exit_code = e; e && WEXITSTATUS (e) != exit_code; e <<= 1)
	continue;
    }
  return e;
#else
  if (s == NULL)
    return 0;
  errno = ENOSYS;
  return -1;
#endif
}

int
_rename (const char * oldpath, const char * newpath)
{
#ifdef ARM_RDI_MONITOR
  int block[4];
  block[0] = oldpath;
  block[1] = strlen(oldpath);
  block[2] = newpath;
  block[3] = strlen(newpath);
  return wrap (do_AngelSWI (AngelSWI_Reason_Rename, block)) ? -1 : 0;
#else  
  errno = ENOSYS;
  return -1;
#endif
}
@


1.16
log
@	* libc/sys/arm/syscalls.c (do_AngelSWI): Delete.
	* libc/sys/arm/libcfuncs.c (do_AngelSWI): Delete.
	* libc/sys/arm/swi.h: Copy over from libgloss.
@
text
@d205 1
a205 1
int
d310 1
a310 1
int
d454 1
a454 1
caddr_t
@


1.15
log
@
2008-01-03  Jeff Johnston  <jjohnstn@@redhat.com>

        Make isatty syscall handling consistent with other newlib syscalls.

        * libc/include/_syslist.h: Add _isatty.
        * libc/include/reent.h: Add _isatty_r.
        * libc/include/sys/unistd.h: Add _isatty.
        * libc/posix/Makefile.am: Add new _isatty.c file.
        * libc/posix/Makefile.in: Regenerated.
        * libc/posix/_isatty.c: New file.
        * libc/posix/isatty.c: Changed to call _isatty().
        * libc/reent/Makefile.am: Add new isattyr.c file.
        * libc/reent/Makefile.in: Regenerated.
        * libc/reent/isattyr.c: New file.
        * libc/stdio/freopen.c: Changed to call _isatty_r().
        * libc/stdio/makebuf.c: Ditto.
        * libc/sys/a29khif/_isatty.S: Change isatty to _isatty.
        * libc/sys/arc/isatty.c: Ditto.
        * libc/sys/arm/syscalls.c: Ditto.
        * libc/sys/d10v/syscalls.c: Ditto.
        * libc/sys/h8300hms/syscalls.c: Ditto.
        * libc/sys/h8500hms/syscalls.c: Ditto.
        * libc/sys/linux/Makefile.am: Add new isatty.c file.
        * libc/sys/linux/Makefile.in: Regenerated.
        * libc/sys/linux/isatty.c: New file.
        * libc/syscalls/Makefile.am: Add new sysisatty.c file.
        * libc/syscalls/Makefile.in: Regenerated.
        * libc/syscalls/sysisatty.c: New file.
@
text
@a50 1
static int	do_AngelSWI	_PARAMS ((int, void *));
a95 20
#ifdef ARM_RDI_MONITOR

static inline int
do_AngelSWI (int reason, void * arg)
{
  int value;
  asm volatile ("mov r0, %1; mov r1, %2; " AngelSWIInsn " %a3; mov %0, r0"
       : "=r" (value) /* Outputs */
       : "r" (reason), "r" (arg), "i" (AngelSWI) /* Inputs */
       : "r0", "r1", "r2", "r3", "ip", "lr", "memory", "cc"
		/* Clobbers r0 and r1, and lr if in supervisor mode */);
                /* Accordingly to page 13-77 of ARM DUI 0040D other registers
                   can also be clobbered.  Some memory positions may also be
                   changed by a system call, so they should not be kept in
                   registers. Note: we are assuming the manual is right and
                   Angel is respecting the APCS.  */
  return value;
}
#endif /* ARM_RDI_MONITOR */

@


1.14
log
@
2007-07-06  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/sys/time.h (gettimeofday): Change to proper
        prototype where second parameter is void *.
        * libc/reent/gettimeofdayr.c (_gettimeofday_r): Change prototype
        accordingly.
        * libc/include/reent.h: Fix prototype for _gettimeofday_r.
        * libc/sys/arm/syscalls.c: Fix gettimeofday function signature.
        * libc/sys/rdos/gettod.c: Ditto.
        * libc/sys/sh/syscalls.c: Ditto.
        * libc/time/time.c (time): Change call to _gettimeofday_r
        to pass NULL as 2nd argument.
@
text
@d23 1
a23 1
int     isatty		_PARAMS ((int));
d615 1
a615 1
isatty (int fd)
@


1.13
log
@
2006-06-13  Sandra Loosemore <sandra@@codesourcery.com>

        * /libc/sys/arm/syscalls.c (_unlink, isatty, _system, _rename):
        Make them do something useful in the ARM_RDI_MONITOR case.
@
text
@d25 1
a25 1
int     _gettimeofday	_PARAMS ((struct timeval *, struct timezone *));
d562 1
a562 1
_gettimeofday (struct timeval * tp, struct timezone * tzp)
d564 1
a564 1

@


1.12
log
@
2006-06-05  Shaun Jackman  <sjackman@@gmail.com>

        configure.host (newlib_cflags) [arm, thumb, xscale]:  Remove
        -DABORT_PROVIDED flag.
        * newlib/libc/sys/arm/syscalls.c (kill, exit): Sync with libgloss.
        * newlib/libc/sys/arm/libcfunc.c (abort): Ditto.
@
text
@d17 1
d27 1
a27 1
int     _unlink		_PARAMS ((void));
d543 1
a543 1
_unlink (void)
d545 6
d552 1
d617 6
a622 2
  return 1;
  fd = fd;
d628 24
d656 1
d662 8
d672 1
@


1.11
log
@
2006-02-07  Paul Brook  <paul@@codesourcery.com>

        * libc/machine/arm/setjmp.S: Add Thumb-2 support.
        * libc/sys/arm/crt0.S: Add Thumb-2 startup code.
        * libc/sys/arm/libcfunc.c (do_AngelSWI): Use AngelSWIInsn.
        * libc/sys/arm/swi.h (AngelSWIInsn, AngelSWIAsm): Define.
        * libc/sys/arm/trap.S: Disable for Thumb-2.
@
text
@d15 1
d437 2
a438 2
void
_exit (int n)
d440 1
a440 2
  /* FIXME: return code is thrown away.  */
  
d442 9
a450 2
  do_AngelSWI (AngelSWI_Reason_ReportException,
	      (void *) ADP_Stopped_ApplicationExit);
a453 1
  n = n;
d456 2
a457 2
int
_kill (int n, int m)
d459 6
a464 7
#ifdef ARM_RDI_MONITOR
  return do_AngelSWI (AngelSWI_Reason_ReportException,
		      (void *) ADP_Stopped_ApplicationExit);
#else
  asm ("swi %a0" :: "i" (SWI_Exit));
#endif
  n = n; m = m;
@


1.11.2.1
log
@2006-03-23  Mark Mitchell  <mark@@codesourcery.com>

	* libc/sys/arm/Makefile.am (extra_objs): Add _exit.o _nmi_isr.o
	_fault_isr.o.
	* libc/sys/arm/Makefile.in: Regenerated.
	* libc/sys/arm/_exit.c: New file.
	* libc/sys/arm/_fault_isr.c: Likewise.
	* libc/sys/arm/_nmi_isr.c: Likewise.
	* libc/sys/arm/configure.in (--enable-newlib-arm-v7m): New option.
	* libc/sys/arm/configure:
	* libc/sys/arm/crt0.S (_start): Do not use semihosting calls in
	_start when configured for ARM V7M.  Do not call
	initialise_monitor_handles.  Indent preprocessor directives.
	(.isr_vector): New section, on ARM V7M.
	* libc/sys/arm/swi.h (do_AngelSWI): New function.
	* syscalls.c (_exit): Remove.
	(do_AngelSWI): Likewise.
	(CHECK_INIT): Remove.
	(remap_handle): Call initialise_monitor_handles.
	(__arm_monitor_handles_lock): New variable.
	(initialise_monitor_handles): Make sure to run only once.
@
text
@d32 1
d43 1
a44 1
static void    initialise_monitor_handles _PARAMS ((void));
d49 1
d55 11
d95 20
d119 1
a119 1
  initialise_monitor_handles ();
a130 4
#ifndef __SINGLE_THREAD__
__LOCK_INIT_RECURSIVE (static, __arm_monitor_handles_lock);
#endif

d135 1
a135 14
  static int initialized;

  /* We need do this only once.  */
  if (initialized)
    return;

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive (__arm_monitor_handles_lock);
#endif
  initialized = 1;
#ifndef __SINGLE_THREAD__
  __lock_release_recursive (__arm_monitor_handles_lock);
#endif

d436 14
@


1.11.2.2
log
@	Issue #667
	* newlib/libc/sys/arm/syscalls.c (findslot): Call
	initialise_monitor_handles.
	(remap_handle): Do not call initialise_monitor_handles.
@
text
@a75 2

  initialise_monitor_handles ();
d86 2
@


1.11.2.3
log
@Add additional ARM_RDI_MONITOR calls
@
text
@a15 1
#include <sys/wait.h>
d25 1
a25 1
int     _unlink		_PARAMS ((const char *));
d507 1
a507 1
_unlink (const char *path)
a508 6
#ifdef ARM_RDI_MONITOR
  int block[2];
  block[0] = path;
  block[1] = strlen(path);
  return wrap (do_AngelSWI (AngelSWI_Reason_Remove, block)) ? -1 : 0;
#else  
a509 1
#endif
d574 2
a575 6
#ifdef ARM_RDI_MONITOR
  int fh = remap_handle (fd);
  return wrap (do_AngelSWI (AngelSWI_Reason_IsTTY, &fh));
#else
  return (fd <= 2) ? 1 : 0;  /* one of stdin, stdout, stderr */
#endif
a580 24
#ifdef ARM_RDI_MONITOR
  int block[2];
  int e;

  /* Hmmm.  The ARM debug interface specification doesn't say whether
     SYS_SYSTEM does the right thing with a null argument, or assign any
     meaning to its return value.  Try to do something reasonable....  */
  if (!s)
    return 1;  /* maybe there is a shell available? we can hope. :-P */
  block[0] = s;
  block[1] = strlen (s);
  e = wrap (do_AngelSWI (AngelSWI_Reason_System, block));
  if ((e >= 0) && (e < 256))
    {
      /* We have to convert e, an exit status to the encoded status of
         the command.  To avoid hard coding the exit status, we simply
	 loop until we find the right position.  */
      int exit_code;

      for (exit_code = e; e && WEXITSTATUS (e) != exit_code; e <<= 1)
	continue;
    }
  return e;
#else
a584 1
#endif
a589 8
#ifdef ARM_RDI_MONITOR
  int block[4];
  block[0] = oldpath;
  block[1] = strlen(oldpath);
  block[2] = newpath;
  block[3] = strlen(newpath);
  return wrap (do_AngelSWI (AngelSWI_Reason_Rename, block)) ? -1 : 0;
#else  
a591 1
#endif
@


1.11.2.4
log
@2006-08-22  Paul Brook  <paul@@codesourcery.com>

	newlib/
	* libc/sys/arm/syscalls.c (initialise_monitor_handles): Fix
	multithreaded locking.
@
text
@d115 4
a118 5
  if (initialized)
    {
      __lock_release_recursive (__arm_monitor_handles_lock);
      return;
    }
a158 5

  initialized = 1;
#ifndef __SINGLE_THREAD__
  __lock_release_recursive (__arm_monitor_handles_lock);
#endif
@


1.10
log
@
2005-02-07  Antony King  <antony.king@@st.com>

        * libc/stdio/clearerr.c (clearerr): Ensure CHECK_INIT() is
        called before _flockfile to prevent lock object use before
        initialisation. _REENT_SMALL_CHECK_INIT() and CHECK_INIT()
        take a struct _reent * instead of a FILE *.
        * libc/stdio/fclose.c (_fclose_r): Ditto.
        * libc/stdio/feof.c (feof): Ditto.
        * libc/stdio/ferror.c (ferror): Ditto.
        * libc/stdio/fflush.c (fflush): Ditto.
        * libc/stdio/fgetc.c (fgetc): Ditto.
        * libc/stdio/fgets.c (fgets): Ditto.
        * libc/stdio/fileno.c (fileno): Ditto.
        * libc/stdio/fputc.c (fputc): Ditto.
        * libc/stdio/fputs.c (fputs): Ditto.
        * libc/stdio/fread.c (fread): Ditto.
        * libc/stdio/freopen.c (_freopen_r): Ditto.
        * libc/stdio/fseek.c (_fseek_r): Ditto.
        * libc/stdio/ftell.c (_ftell_r): Ditto.
        * libc/stdio/fwrite.c (fwrite): Ditto.
        * libc/stdio/getc.c (getc): Ditto.
        * libc/stdio/getdelim.c (__getdelim): Ditto.
        * libc/stdio/putc.c (putc): Ditto.
        * libc/stdio/setvbuf.c (setvbuf): Ditto.
        * libc/stdio/ungetc.c (_ungetc_r): Ditto.
        * libc/stdio/vfprintf.c (_VFPRINTF_R): Ditto.
        * libc/stdio64/freopen64.c (_freopen64_r): Ditto.
        * libc/stdio64/fseeko64.c (_fseeko64_r): Ditto.
        * libc/stdio64/ftello64.c (_ftello64_r): Ditto.
        * libc/stdio/local.h (CHECK_INIT): Argument is now a struct
        _reent * instead of a FILE * and so replace incorrect use of
        _REENT with argument.
        * libc/sys/arm/syscalls.c (CHECK_INIT): Ditto.
        * libc/stdio/getchar.c (getchar): _REENT_SMALL_CHECK_INIT() and
        CHECK_INIT() take a struct _reent * instead of a FILE *.
        * libc/stdio/iprintf.c (iprintf, _iprintf_r): Ditto.
        * libc/stdio/iscanf.c (iscanf, _iscanf_r): Ditto.
        * libc/stdio/perror.c (perror): Ditto.
        * libc/stdio/printf.c (printf, _printf_r): Ditto.
        * libc/stdio/putchar.c (putchar): Ditto.
        * libc/stdio/puts.c (puts): Ditto.
        * libc/stdio/refill.c (__srefill): Ditto.
        * libc/stdio/scanf.c (scanf, _scanf_r): Ditto.
        * libc/stdio/vfscanf.c (VFSCANF, _VFSCANF_R): Ditto.
        * libc/stdio/viprintf.c (viprintf, _viprintf_r): Ditto.
        * libc/stdio/viscanf.c (viscanf, _viscanf_r): Ditto.
        * libc/stdio/vprintf.c (vprintf, _vprintf_r): Ditto.
        * libc/stdio/vscanf.c (vscanf, _vscanf_r): Ditto.
        * libc/stdio/wbuf.c (__swbuf): Ditto.
        * libc/stdio/wsetup.c (__swsetup): Ditto.
        * libc/stdlib/mallocr.c (malloc_stats): Ditto.
        * libc/stdlib/mstats.c (_mstats_r): Ditto.
        * libc/include/sys/reent.h (_REENT_SMALL_CHECK_INIT): Ditto.
        * libc/machine/powerpc/vfscanf.c (vfscanf): Ditto.
        * libc/stdio/fgetpos.c (_fgetpos_r): Removed unnecessary calls
        to _flockfile and _funlockfile; rely on locking in _ftell_r.
        * libc/stdio64/fgetpos64.c (_fgetpos64_r): Ditto (_ftello64_r).
        * libc/machine/powerpc/vfprintf.c (__sbprintf): Removed unnecessary
        initialision of _data field in FILE structure.
        * libc/machine/powerpc/vfprintf.c (VFPRINTF): Added CHECK_INIT() call.
@
text
@d101 1
a101 1
  asm volatile ("mov r0, %1; mov r1, %2; swi %a3; mov %0, r0"
@


1.9
log
@
2004-01-06  Mark Mitchell  <mark@@codesourcery.com>

        * libc/sys/arm/syscalls.c (unistd.h): Include it.
        (remap_handle): Use STDIN_FILENO instead of __sfileno(stdin).
        Similarly for stdout and stderr.
@
text
@d58 6
a63 8
#define CHECK_INIT(fp) \
  do                                    \
    {                                   \
      if ((fp)->_data == 0)             \
        (fp)->_data = _REENT;           \
      if (!(fp)->_data->__sdidinit)     \
        __sinit ((fp)->_data);          \
    }                                   \
a68 1
static int std_files_checked;
d119 2
a120 7
  if (!std_files_checked)
    {
       CHECK_INIT(stdin);
       CHECK_INIT(stdout);
       CHECK_INIT(stderr);
       std_files_checked = 1;
    }
@


1.8
log
@	* libc/sys/arm/syscalls.c (_rename): Add parameter names.
	(_sbrk): Add cast of return value.
@
text
@d15 1
d129 1
a129 1
  if (fh == __sfileno (stdin))
d131 1
a131 1
  if (fh == __sfileno (stdout))
d133 1
a133 1
  if (fh == __sfileno (stderr))
@


1.7
log
@Fix trivial typo in last change
@
text
@d500 1
a500 1
      return -1;
d625 1
a625 1
_rename (const char *oldpath, const char *newpath)
@


1.6
log
@	* libc/sys/arm/syscalls.c (_rename): New function. Just a stub.
	(_system): New function. Ditto.
	* libc/stdlib/system.c (_system_r): Call _system if HAVE_SYSTEM.
	* configure.host: define HAVE_SYSTEM and HAVE_RENAME for xscale
	targets.
@
text
@d625 1
a625 1
_rename (const char *, const char *)
@


1.5
log
@
2002-03-12  Richard Earnshaw  <rearnsha@@arm.com>

        * libc/sys/arm/access.c: New file.
        * libc/sys/arm/Makefile.am (lib_a_SOURCES): Add access.c.
        * libc/sys/arm/Makefile.in: Regenerate.
        * libc/sys/arm/syscalls.c (_stat): New function.
@
text
@d18 2
d613 16
@


1.4
log
@_sbrk(): Return -1 rather than aborting if too much memory is requested.
@
text
@d24 1
d517 16
@


1.3
log
@Fix compile time warning messages.
Add "cc" to list of registers clobbered bu do_AgelSWI
@
text
@a472 2
extern void abort (void);

d487 5
d493 1
d495 4
@


1.2
log
@Thu Mar 22 14:57:00 2000  Fernando Nasser <fnasser@@redhat.com>

	* libc/sys/arm/syscalls.c (do_AngelSWI): Prevent registers with valid
	information to be clobbered by an Angel C library support syscall.
@
text
@a17 3
#ifndef _PARAMS
#error UGG
#endif
d64 1
a64 1
/* Adjust our internal handles to stay away from std* handles */
d103 1
a103 1
       : "r0", "r1", "r2", "r3", "ip", "lr", "memory"
d109 1
a109 1
                   Angel is respecting the APCS */
d114 1
a114 1
/* Function to convert std(in|out|err) handles to internal versions */
d205 1
a205 2
/* Returns # chars not! written */

d242 1
a242 1
  /* x == len is not an error, at least if we want feof() to work */
d273 1
a273 1
  /* This code only does absolute seeks */
d287 1
a287 1
  /* This code only does absolute seeks */
d297 1
a297 1
  /* This is expected to return the position in the file */
d309 1
a309 1
/* Returns #chars not! written */
d350 2
d366 1
a366 1
  /* The flags are Unix-style, so we need to convert them */
d383 1
a383 1
      aflags &= ~4;     /* Can't ask for w AND a; means just 'a' */
d451 1
d463 1
d470 1
d473 2
d478 1
a478 1
  extern char   end asm ("end");	/* Defined by the linker */
d498 2
d507 1
d534 1
a534 1
    /* Ask the host for the seconds since the Unix epoch */
d547 1
a547 1
  /* Return fixed data for the timezone */
d557 1
a557 1
/* Return a clock that ticks at 100Hz. */
d585 1
a586 1

@


1.1
log
@Initial revision
@
text
@d106 1
a106 1
       : "r0", "r1", "lr"
d108 5
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
