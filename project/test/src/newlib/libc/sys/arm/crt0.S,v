head	1.16;
access;
symbols
	cygwin-1_7_35-release:1.16
	cygwin-1_7_34-release:1.16
	newlib-2_2_0:1.16.0.2
	cygwin-1_7_33-release:1.16
	cygwin-1_7_32-release:1.16
	cygwin-1_7_31-release:1.16
	cygwin-1_7_30-release:1.16
	cygwin-1_7_29-release:1.16
	cygwin-1_7_28-release:1.16
	newlib-2_1_0:1.16
	cygwin-1_7_27-release:1.16
	cygwin-1_7_26-release:1.16
	cygwin-1_7_25-release:1.16
	cygwin-1_7_24-release:1.16
	cygwin-1_7_23-release:1.15
	cygwin-1_7_22-release:1.15
	cygwin-1_7_21-release:1.15
	cygwin-1_7_20-release:1.15
	cygwin-1_7_19-release:1.15
	cygwin-64bit-postmerge:1.15
	cygwin-64bit-premerge-branch:1.15.0.4
	cygwin-64bit-premerge:1.15
	cygwin-1_7_18-release:1.15
	newlib-2_0_0:1.15
	cygwin-1_7_17-release:1.15
	cygwin-64bit-branch:1.15.0.2
	cygwin-1_7_16-release:1.15
	cygwin-1_7_15-release:1.15
	cygwin-1_7_14_2-release:1.15
	cygwin-1_7_14-release:1.15
	cygwin-1_7_12-release:1.15
	cygwin-1_7_11-release:1.15
	cygwin-1_7_10-release:1.15
	newlib-1_20_0:1.15
	cygwin-1_7_9-release:1.12
	cygwin-1_7_8-release:1.12
	newlib-1_19_0:1.12
	cygwin-1_7_7-release:1.12
	cygwin-1_7_5-release:1.12
	cygwin-1_7_4-release:1.12
	cygwin-1_7_3-release:1.12
	cygwin-1_7_2-release:1.12
	newlib-1_18_0:1.12
	cygwin-1_7_1-release:1.12
	newlib-1_17_0-arc:1.12.0.10
	binutils-arc-20080908-branch:1.12.0.8
	binutils-arc-20080908-branchpoint:1.12
	newlib-1_17_0:1.12
	newlib-1_16_0:1.12
	newlib-1_15_0:1.12
	newlib-csl-coldfire-4_1-32:1.12.2.2
	newlib-csl-sourcerygxx-4_1-32:1.12.2.2
	newlib-csl-innovasic-fido-3_4_4-33:1.12.2.2
	newlib-csl-coldfire-4_1-30:1.12.2.2
	newlib-csl-sourcerygxx-4_1-30:1.12.2.2
	newlib-csl-coldfire-4_1-28:1.12.2.2
	newlib-csl-sourcerygxx-4_1-28:1.12.2.2
	newlib-csl-arm-2006q3-27:1.12.2.2
	newlib-csl-sourcerygxx-4_1-27:1.12.2.2
	newlib-csl-arm-2006q3-26:1.12.2.2
	newlib-csl-sourcerygxx-4_1-26:1.12.2.2
	newlib-csl-sourcerygxx-4_1-24:1.12.2.2
	newlib-csl-sourcerygxx-4_1-23:1.12.2.2
	newlib-csl-sourcerygxx-4_1-21:1.12.2.2
	newlib-csl-arm-2006q3-21:1.12.2.2
	newlib-csl-arm-2006q3-19:1.12.2.2
	newlib-csl-sourcerygxx-4_1-19:1.12.2.2
	newlib-csl-sourcerygxx-4_1-18:1.12.2.2
	newlib-csl-sourcerygxx-3_4_4-25:1.12
	newlib-csl-sourcerygxx-4_1-17:1.12.2.1
	cr-0x5f1:1.12.0.6
	newlib-csl-sourcerygxx-4_1-14:1.12.2.1
	newlib-csl-sourcerygxx-4_1-13:1.12.2.1
	newlib-csl-sourcerygxx-4_1-12:1.12.2.1
	newlib-csl-sourcerygxx-4_1-9:1.12.2.1
	newlib-csl-sourcerygxx-4_1-8:1.12.2.1
	newlib-csl-sourcerygxx-4_1-7:1.12.2.1
	newlib-csl-arm-2006q1-6:1.12.2.1
	newlib-csl-sourcerygxx-4_1-6:1.12.2.1
	newlib-csl-sourcerygxx-4_1-5:1.12.2.1
	newlib-csl-sourcerygxx-4_1-4:1.12.2.1
	newlib-autotools-branch:1.12.0.4
	newlib-csl-20060320-branch:1.12.0.2
	newlib-csl-20060320-branchpoint:1.12
	newlib-1_14_0:1.11
	newlib-csl-arm-2005-q1b:1.10
	newlib-csl-arm-2005-q1a:1.10
	newlib-1_13_0:1.9
	csl-arm-2004-q3:1.8
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.8
	newlib-1_12_0:1.8
	csl-arm-2003-q4:1.8
	w32api-2_2:1.8
	mingw-runtime-2_4:1.8
	newlib-1_11_0:1.8
	cygnus_cvs_20020108_pre:1.5
	newlib-1_10_0:1.5
	newlib-1_9_0:1.2
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2013.08.12.11.28.28;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2011.12.13.22.40.45;	author jjohnstn;	state Exp;
branches;
next	1.14;

1.14
date	2011.10.11.09.29.56;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2011.10.11.07.38.33;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.07.18.44.54;	author jjohnstn;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2005.07.19.15.14.16;	author jjohnstn;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.07.18.04.39;	author jjohnstn;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.26.16.42.10;	author jjohnstn;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.18.16.30.55;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.18.15.21.24;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.30.18.23.38;	author fitzsim;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.05.11.51.43;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.13.03.31.14;	author green;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.18.15.42.41;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.28.18.14.14;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.49;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.12.2.1
date	2006.03.23.18.36.10;	author mmitchel;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2006.08.30.22.24.19;	author pbrook;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.39.49;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.16
log
@	* libc/sys/arm/crt0.S: Remove 'start'.
@
text
@#include "newlib.h"
#include "arm.h"
#include "swi.h"

/* ANSI concatenation macros.  */
#define CONCAT(a, b) CONCAT2(a, b)
#define CONCAT2(a, b) a ## b

#ifdef __USER_LABEL_PREFIX__
#define FUNCTION( name ) CONCAT (__USER_LABEL_PREFIX__, name)
#else
#error __USER_LABEL_PREFIX is not defined
#endif

#ifdef HAVE_INITFINI_ARRAY
#define _init	__libc_init_array
#define _fini	__libc_fini_array
#endif

#if defined(__ARM_EABI__) && defined(__thumb__) && !defined(__thumb2__)
/* For Thumb1 we need to force the architecture to be sure that we get the
   correct attributes on the object file; otherwise the assembler will get
   confused and mark the object as being v6T2.  */
#if defined(__ARM_ARCH_4T__)
	.arch armv4t
#elif defined(__ARM_ARCH_5T__) || defined(__ARM_ARCH_5TE__)
	/* Nothing in this object requires higher than v5.  */
	.arch armv5t
#elif defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \
	|| defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) \
	|| defined(__ARM_ARCH_6ZK__)
	/* Nothing in this object requires higher than v6.  */
	.arch armv6
#elif defined(__ARM_ARCH_6M__)
#ifdef ARM_RDP_MONITOR
	/* Object file uses SVC, so mark as v6s-m.  */
	.arch armv6s-m
#else
	.arch armv6-m
#endif
#endif
#endif

/* .text is used instead of .section .text so it works with arm-aout too.  */
	.text
	.syntax unified
#ifdef THUMB_V7_V6M
	.thumb
.macro FUNC_START name
	.global \name
	.thumb_func
\name:
.endm	
#else
	.code 32
.macro FUNC_START name
	.global	\name
\name:
.endm	
#endif

.macro indirect_call reg
#ifdef HAVE_CALL_INDIRECT
	blx \reg
#else
	mov	lr, pc
	mov	pc, \reg
#endif
.endm

	.align 	0

	FUNC_START	_mainCRTStartup
	FUNC_START	_start
#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
	/* Annotation for EABI unwinding tables.  */
	.fnstart
#endif

/* Start by setting up a stack.  */
#ifdef ARM_RDP_MONITOR
	/*  Issue Demon SWI to read stack info.  */
	swi	SWI_GetEnv	/*  Returns command line in r0.  */
	mov	sp,r1		/*  and the highest memory address in r1.  */

	/*  Stack limit is at end of data.  */
	/*  Allow slop for stack overflow handling and small frames.  */
#ifdef __ARM_ARCH_6M__
	ldr	r0, .LC2
	adds	r0, #128
	adds	r0, #128
	mov	sl, r0
#else
	ldr	sl, .LC2
	add	sl, sl, #256
#endif
#else
#ifdef ARM_RDI_MONITOR
	/*  Issue Angel SWI to read stack info.  */
	movs	r0, #AngelSWI_Reason_HeapInfo
	adr	r1, .LC0	/*  Point at ptr to 4 words to receive data.  */
#ifdef THUMB_V7M_V6M
	bkpt	AngelSWI
#elif defined(__thumb2__)
	/*  We are in thumb mode for startup on armv7 architectures.  */
	AngelSWIAsm	AngelSWI
#else
	/*  We are always in ARM mode for startup on pre armv7 archs.  */
	AngelSWIAsm	AngelSWI_ARM
#endif
	ldr	r0, .LC0	/*  Point at values read.  */

	ldr     r1, [r0, #0]
	cmp     r1, #0
	bne     .LC32
	/* If the heap base value [r0, #0] is 0 then the heap base is actually 
	   at the end of program data (i.e. __end__). See:
           http://infocenter.arm.com/help/topic/com.arm.doc.dui0471-/Bacbefaa.html
	   for more information.  */
	ldr     r1, .LC31
	str     r1, [r0, #0]
.LC32:	
	ldr	r1, [r0, #8]
	ldr	r2, [r0, #12]
	/*  We skip setting sp/sl if 0 returned from semihosting. 
	    - According to semihosting docs, if 0 returned from semihosting,
	      the system was unable to calculate the real value, so it's ok
	      to skip setting sp/sl to 0 here.
	    - Considering M-profile processors, We might want to initialize
	      sp by the first entry of vector table and return 0 to SYS_HEAPINFO
	      semihosting call, which will be skipped here.  */
	cmp	r1, #0
	beq	.LC26
	mov	sp, r1
.LC26:
	cmp	r2, #0
	beq	.LC27

	/*  Allow slop for stack overflow handling and small frames.  */
#ifdef __ARM_ARCH_6M__
	adds	r2, #128
	adds	r2, #128
	mov	sl, r2
#else
	add	sl, r2, #256
#endif

.LC27:
#else
	/*  Set up the stack pointer to a fixed value.  */
	/*  Changes by toralf:
	    - Allow linker script to provide stack via __stack symbol - see
	      defintion of .Lstack
	    - Provide "hooks" that may be used by the application to add
	      custom init code - see .Lhwinit and .Lswinit	
	    - Go through all execution modes and set up stack for each of them.
	      Loosely based on init.s from ARM/Motorola example code.
              Note: Mode switch via CPSR is not allowed once in non-privileged
		    mode, so we take care not to enter "User" to set up its sp,
		    and also skip most operations if already in that mode.  */

	ldr	r3, .Lstack
	cmp	r3, #0
#ifdef __thumb2__
	it	eq
#endif	
#ifdef __ARM_ARCH_6M__
	bne	.LC28
	ldr	r3, .LC0
.LC28:
#else
	ldreq	r3, .LC0
#endif
	/* Note: This 'mov' is essential when starting in User, and ensures we
		 always get *some* sp value for the initial mode, even if we 
		 have somehow missed it below (in which case it gets the same
		 value as FIQ - not ideal, but better than nothing).  */
	mov	sp, r3
#ifdef THUMB_V7_V6M
	/* XXX Fill in stack assignments for interrupt modes.  */
#else
	mrs	r2, CPSR
	tst	r2, #0x0F	/* Test mode bits - in User of all are 0.  */
	beq	.LC23		/* "eq" means r2 AND #0x0F is 0.  */
	msr     CPSR_c, #0xD1	/* FIRQ mode, interrupts disabled.  */
	mov 	sp, r3
	sub	sl, sp, #0x1000	/* This mode also has its own sl (see below).  */
	
	mov	r3, sl	
	msr     CPSR_c, #0xD7	/* Abort mode, interrupts disabled.  */
	mov	sp, r3
	sub	r3, r3, #0x1000

	msr     CPSR_c, #0xDB	/* Undefined mode, interrupts disabled.  */
	mov	sp, r3
	sub	r3, r3, #0x1000

	msr     CPSR_c, #0xD2	/* IRQ mode, interrupts disabled.  */
	mov	sp, r3
	sub	r3, r3, #0x2000
		
	msr     CPSR_c, #0xD3	/* Supervisory mode, interrupts disabled.  */

	mov	sp, r3
	sub	r3, r3, #0x8000	/* Min size 32k.  */
	bic	r3, r3, #0x00FF	/* Align with current 64k block.  */
	bic	r3, r3, #0xFF00

	str	r3, [r3, #-4]	/* Move value into user mode sp without */ 
	ldmdb	r3, {sp}^       /* changing modes, via '^' form of ldm.  */ 
	orr	r2, r2, #0xC0	/* Back to original mode, presumably SVC, */
	msr	CPSR_c, r2	/* with FIQ/IRQ disable bits forced to 1.  */
#endif	
.LC23:
	/* Setup a default stack-limit in-case the code has been
	   compiled with "-mapcs-stack-check".  Hard-wiring this value
	   is not ideal, since there is currently no support for
	   checking that the heap and stack have not collided, or that
	   this default 64k is enough for the program being executed.
	   However, it ensures that this simple crt0 world will not
	   immediately cause an overflow event:  */
#ifdef __ARM_ARCH_6M__
	movs	r2, #64
	lsls	r2, r2, #10
	subs	r2, r3, r2
	mov	sl, r2
#else
	sub	sl, r3, #64 << 10	/* Still assumes 256bytes below sl.  */
#endif
#endif
#endif
	/* Zero the memory in the .bss section.  */
	movs 	a2, #0			/* Second arg: fill value.  */
	mov	fp, a2			/* Null frame pointer.  */
	mov	r7, a2			/* Null frame pointer for Thumb.  */
	
	ldr	a1, .LC1		/* First arg: start of memory block.  */
	ldr	a3, .LC2	
	subs	a3, a3, a1		/* Third arg: length of block.  */
	

#if defined(__thumb__) && !defined(THUMB_V7_V6M)
	/* Enter Thumb mode...  */
	add	a4, pc, #1	/* Get the address of the Thumb block.  */
	bx	a4		/* Go there and start Thumb decoding.  */

	.code 16
	.global __change_mode
	.thumb_func
__change_mode:	
#endif
	
	bl	FUNCTION (memset)
#if !defined (ARM_RDP_MONITOR) && !defined (ARM_RDI_MONITOR)
/* Changes by toralf: Taken from libgloss/m68k/crt0.S
   initialize target specific stuff. Only execute these
   functions it they exist.  */
	ldr	r3, .Lhwinit
	cmp	r3, #0
	beq	.LC24
	indirect_call r3
.LC24:	
	ldr	r3, .Lswinit
	cmp	r3, #0
	beq	.LC25
	indirect_call r3

.LC25:	
	movs	r0, #0		/* No arguments.  */
	movs	r1, #0		/* No argv either.  */
#else
	/* Need to set up standard file handles.  */
	bl	FUNCTION (initialise_monitor_handles)
	
#ifdef ARM_RDP_MONITOR
	swi	SWI_GetEnv	/* Sets r0 to point to the command line.  */
	movs	r1, r0
#else
	movs	r0, #AngelSWI_Reason_GetCmdLine
	adr	r1, .LC30	/* Space for command line.  */
#ifdef THUMB_V7M_V6M
	bkpt	AngelSWI
#else
 	AngelSWIAsm	AngelSWI
#endif
	ldr	r1, .LC30
#endif
	/*  Parse string at r1.  */
	movs	r0, #0		/* Count of arguments so far.  */
	/* Push a NULL argument onto the end of the list.  */
#ifdef __thumb__
	push	{r0}
#else
	stmfd	sp!, {r0}
#endif
.LC10:
/*  Skip leading blanks.  */
#ifdef __thumb__
	ldrb	r3, [r1]
	adds	r1, #1
#else
	ldrb	r3, [r1], #1
#endif
	cmp	r3, #0
	beq	.LC12
	cmp	r3, #' '
	beq	.LC10

/* See whether we are scanning a string.  */
	cmp	r3, #'\"'
#ifdef __thumb__
	beq	.LC20
	cmp	r3, #'\''
	bne	.LC21
.LC20:
	movs	r2, r3
	b	.LC22

.LC21:
	movs	r2, #' '	/* Terminator type.  */
	subs	r1, r1, #1	/* Adjust back to point at start char.  */
.LC22:
#else
	cmpne	r3, #'\''
	moveq	r2, r3
	movne	r2, #' '	/* Terminator type.  */
	subne	r1, r1, #1	/* Adjust back to point at start char.  */
#endif

/*  Stack a pointer to the current argument.  */
#ifdef __thumb__
	push	{r1}
#else
	stmfd	sp!, {r1}
#endif
	adds	r0, r0, #1
.LC11:
#ifdef __thumb__
	ldrb	r3, [r1]
	adds	r1, #1
#else
	ldrb	r3, [r1], #1
#endif
	cmp	r3, #0
	beq	.LC12
	cmp	r2, r3		/* Reached terminator ?  */
	bne	.LC11
	movs	r2, #0
	subs	r3, r1, #1
	strb	r2, [r3]	/* Terminate the arg string.  */
	b	.LC10

.LC12:
	mov	r1, sp		/* Point at stacked arg pointers.  */
	/* We've now got the stacked args in order, reverse them.  */
#ifdef __thumb__
	movs	r2, r0
	lsls	r2, #2
	add	r2, sp
	mov	r3, sp
.LC15:	cmp	r2, r3
	bls	.LC14
	subs	r2, #4
	ldr	r4, [r2]
	ldr	r5, [r3]
	str	r5, [r2]
	str	r4, [r3]
	adds	r3, #4
	b	.LC15
.LC14:	
	/* Ensure doubleword stack alignment.  */
	mov	r4, sp
	movs	r5, #7
	bics	r4, r5
	mov	sp, r4
#else
	add	r2, sp, r0, LSL #2	/* End of args.  */
	mov	r3, sp			/* Start of args.  */
.LC13:	cmp	r2, r3
	ldrhi	r4,[r2, #-4]		/* Reverse ends of list.  */
	ldrhi	r5, [r3]
	strhi	r5, [r2, #-4]!
	strhi	r4, [r3], #4
	bhi	.LC13
	/* Ensure doubleword stack alignment.  */
	bic	sp, sp, #7
#endif
#endif

#ifdef __USES_INITFINI__
	/* Some arm/elf targets use the .init and .fini sections
	   to create constructors and destructors, and for these
	   targets we need to call the _init function and arrange
	   for _fini to be called at program exit.  */
	movs	r4, r0
	movs	r5, r1
	ldr	r0, .Lfini
	bl	FUNCTION (atexit)
	bl	FUNCTION (_init)
	movs	r0, r4
	movs	r1, r5
#endif	
	bl	FUNCTION (main)

	bl	FUNCTION (exit)		/* Should not return.  */

#if defined(__thumb__) && !defined(THUMB_V7_V6M)
	/* Come out of Thumb mode.  This code should be redundant.  */
	mov	a4, pc
	bx	a4

	.code 32
	.global change_back
change_back:
	/* Halt the execution.  This code should never be executed.  */
	/* With no debug monitor, this probably aborts (eventually).
	   With a Demon debug monitor, this halts cleanly.
	   With an Angel debug monitor, this will report 'Unknown SWI'.	 */
	swi	SWI_Exit
#endif
	
	/* For Thumb, constants must be after the code since only 
	   positive offsets are supported for PC relative addresses.  */	
	.align 0
.LC0:
#ifdef ARM_RDI_MONITOR
	.word	HeapBase
#else
#ifndef ARM_RDP_MONITOR
	/* Changes by toralf: Provide alternative "stack" variable whose value
	   may be defined externally; .Lstack will be used instead of .LC0 if
	   it points to a non-0 value. Also set up references to "hooks" that
           may be used by the application to provide additional init code.  */	
#ifdef __pe__
	.word	0x800000
#else
	.word	0x80000			/* Top of RAM on the PIE board.  */
#endif

.Lstack:	
	.word	__stack
.Lhwinit:	
	.word	FUNCTION (hardware_init_hook)
.Lswinit:
	.word	FUNCTION (software_init_hook)

	/* Set up defaults for the above variables in the form of weak symbols
	   - so that application will link correctly, and get value 0 in
	   runtime (meaning "ignore setting") for the variables, when the user
	   does not provide the symbols. (The linker uses a weak symbol if,
	   and only if, a normal version of the same symbol isn't provided
	   e.g. by a linker script or another object file).  */	

	.weak __stack
	.weak FUNCTION (hardware_init_hook) 
	.weak FUNCTION (software_init_hook)
#endif
	
#endif
#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
	/* Protect against unhandled exceptions.  */
	.cantunwind
	.fnend
#endif
.LC1:
	.word	__bss_start__
.LC2:
	.word	__bss_end__
#ifdef __USES_INITFINI__
.Lfini:
	.word	FUNCTION(_fini)
#endif
#ifdef ARM_RDI_MONITOR
.LC30:
	.word	CommandLine
	.word	255
.LC31:
	.word	__end__

/*  Workspace for Angel calls.  */
	.data
/*  Data returned by monitor SWI.  */
.global	__stack_base__
HeapBase:	.word	0
HeapLimit:	.word	0
__stack_base__:	.word	0
StackLimit:	.word	0
CommandLine:	.space	256,0	/*  Maximum length of 255 chars handled.  */
#endif
	
#ifdef __pe__
	.section .idata$3
	.long	0,0,0,0,0,0,0,0
#endif
@


1.15
log
@
2011-12-13  Richard Earnshaw  <rearnsha@@arm.com>
            Thomas Klein  <th.r.klein@@web.de>

        * libc/sys/arm/crt0.S: Manually set the target architecture
        when compiling for Thumb1 on EABI targets.
        Don't use SWI on M-profile cores.
        Avoid v6-only Thumb-1 MOV instruction.
@
text
@a74 1
	FUNC_START	start
@


1.14
log
@oops - fix typo in previous delta.
@
text
@d20 24
d278 1
a278 1
	mov	r1, r0
d282 5
a286 1
	AngelSWIAsm	AngelSWI
d317 1
a317 1
	mov	r2, r3
d358 1
a358 1
	mov	r2, r0
d396 2
a397 2
	mov	r4, r0
	mov	r5, r1
d401 2
a402 2
	mov	r0, r4
	mov	r1, r5
@


1.13
log
@oops - omitted from previous delta.
@
text
@d57 1
a57 1
/* Start by setting up a stack */
d59 3
a61 3
	/*  Issue Demon SWI to read stack info */
	swi	SWI_GetEnv	/*  Returns command line in r0 */
	mov	sp,r1		/*  and the highest memory address in r1 */
d63 2
a64 2
	/*  stack limit is at end of data */
	/*  allow slop for stack overflow handling and small frames */
d76 1
a76 1
	/*  Issue Angel SWI to read stack info */
d78 1
a78 1
	adr	r1, .LC0	/*  point at ptr to 4 words to receive data */
d82 1
a82 1
	/*  We are in thumb mode for startup on armv7 architectures. */
d85 1
a85 1
	/*  We are always in ARM mode for startup on pre armv7 archs. */
d88 380
a467 1
	ldr	r0, .LC0	/*  point at values read */
@


1.12
log
@
2006-02-07  Paul Brook  <paul@@codesourcery.com>

        * libc/machine/arm/setjmp.S: Add Thumb-2 support.
        * libc/sys/arm/crt0.S: Add Thumb-2 startup code.
        * libc/sys/arm/libcfunc.c (do_AngelSWI): Use AngelSWIInsn.
        * libc/sys/arm/swi.h (AngelSWIInsn, AngelSWIAsm): Define.
        * libc/sys/arm/trap.S: Disable for Thumb-2.
@
text
@d2 1
a21 1
#if defined(__thumb2__)
d23 1
d26 1
a26 1
	.global	\name
d37 10
d62 12
a73 3
	ldr	sl, .LC2	/*  stack limit is at end of data */
	add	sl, sl, #256	/*  allow slop for stack overflow handling */
				/*  and small frames */
d77 1
a77 1
	mov	r0, #AngelSWI_Reason_HeapInfo
d79 1
a79 1
#if defined(__thumb2__)
d81 3
d85 1
a85 1
	/*  We are always in ARM mode for startup */
a88 240
	ldr	sp, [r0, #8]
	ldr	sl, [r0, #12]
	add	sl, sl, #256	/*  allow slop for stack overflow handling */
				/*  and small frames */
#else
	/*  Set up the stack pointer to a fixed value */
	ldr	r3, .LC0
	mov 	sp, r3
	/* Setup a default stack-limit in-case the code has been
	   compiled with "-mapcs-stack-check".  Hard-wiring this value
	   is not ideal, since there is currently no support for
	   checking that the heap and stack have not collided, or that
	   this default 64k is enough for the program being executed.
	   However, it ensures that this simple crt0 world will not
	   immediately cause an overflow event:  */
	sub	sl, sp, #64 << 10	/* Still assumes 256bytes below sl */
#endif
#endif
	/* Zero the memory in the .bss section.  */
	mov 	a2, #0			/* Second arg: fill value */
	mov	fp, a2			/* Null frame pointer */
	mov	r7, a2			/* Null frame pointer for Thumb */
	
	ldr	a1, .LC1		/* First arg: start of memory block */
	ldr	a3, .LC2	
	sub	a3, a3, a1		/* Third arg: length of block */
	

#if defined(__thumb__) && !defined(__thumb2__)
	/* Enter Thumb mode.... */
	add	a4, pc, #1	/* Get the address of the Thumb block */
	bx	a4		/* Go there and start Thumb decoding  */

	.code 16
	.global __change_mode
	.thumb_func
__change_mode:	
#endif
	
	bl	FUNCTION (memset)
#if !defined (ARM_RDP_MONITOR) && !defined (ARM_RDI_MONITOR)
	mov	r0, #0		/*  no arguments  */
	mov	r1, #0		/*  no argv either */
#else
	/* Need to set up standard file handles */
	bl	FUNCTION (initialise_monitor_handles)
	
#ifdef ARM_RDP_MONITOR
	swi	SWI_GetEnv	/*  sets r0 to point to the command line */
	mov	r1, r0
#else
	mov	r0, #AngelSWI_Reason_GetCmdLine
	adr	r1, .LC30	/*  Space for command line */
	AngelSWIAsm	AngelSWI
	ldr	r1, .LC30
#endif
	/*  Parse string at r1 */
	mov	r0, #0		/*  count of arguments so far */
	/* Push a NULL argument onto the end of the list.  */
#ifdef __thumb__
	push	{r0}
#else
	stmfd	sp!, {r0}
#endif
.LC10:
/*  Skip leading blanks */
#ifdef __thumb__
	ldrb	r3, [r1]
	add	r1, #1
#else
	ldrb	r3, [r1], #1
#endif
	cmp	r3, #0
	beq	.LC12
	cmp	r3, #' '
	beq	.LC10

/*  See whether we are scanning a string */
	cmp	r3, #'"'
#ifdef __thumb__
	beq	.LC20
	cmp	r3, #'\''
	bne	.LC21
.LC20:
	mov	r2, r3
	b	.LC22

.LC21:
	mov	r2, #' '	/*  terminator type */
	sub	r1, r1, #1	/*  adjust back to point at start char */
.LC22:
#else
	cmpne	r3, #'\''
	moveq	r2, r3
	movne	r2, #' '	/*  terminator type */
	subne	r1, r1, #1	/*  adjust back to point at start char */
#endif

/*  Stack a pointer to the current argument */
#ifdef __thumb__
	push	{r1}
#else
	stmfd	sp!, {r1}
#endif
	add	r0, r0, #1
.LC11:
#ifdef __thumb__
	ldrb	r3, [r1]
	add	r1, #1
#else
	ldrb	r3, [r1], #1
#endif
	cmp	r3, #0
	beq	.LC12
	cmp	r2, r3		/*  reached terminator? */
	bne	.LC11
	mov	r2, #0
	sub	r3, r1, #1
	strb	r2, [r3]	/*  terminate the arg string */
	b	.LC10

.LC12:
	mov	r1, sp		/*  point at stacked arg pointers */
	/* We've now got the stacked args in order reverse the */
#ifdef __thumb__
	mov	r2, r0
	lsl	r2, #2
	add	r2, sp
	mov	r3, sp
.LC15:	cmp	r2, r3
	bls	.LC14
	sub	r2, #4
	ldr	r4, [r2]
	ldr	r5, [r3]
	str	r5, [r2]
	str	r4, [r3]
	add	r3, #4
	b	.LC15
.LC14:	
	/* Ensure doubleword stack alignment.  */
	mov	r4, sp
	mov	r5, #7
	bic	r4, r5
	mov	sp, r4
#else
	add	r2, sp, r0, LSL #2	/* End of args */
	mov	r3, sp			/* Start of args */
.LC13:	cmp	r2, r3
	ldrhi	r4,[r2, #-4]		/* Reverse ends of list */
	ldrhi	r5, [r3]
	strhi	r5, [r2, #-4]!
	strhi	r4, [r3], #4
	bhi	.LC13
	/* Ensure doubleword stack alignment.  */
	bic	sp, sp, #7
#endif
#endif

#ifdef __USES_INITFINI__
	/* Some arm/elf targets use the .init and .fini sections
	   to create constructors and destructors, and for these
	   targets we need to call the _init function and arrange
	   for _fini to be called at program exit.  */
	mov	r4, r0
	mov	r5, r1
	ldr	r0, .Lfini
	bl	FUNCTION (atexit)
	bl	FUNCTION (_init)
	mov	r0, r4
	mov	r1, r5
#endif	
	bl	FUNCTION (main)

	bl	FUNCTION (exit)		/* Should not return.  */

#if defined(__thumb__) && !defined(__thumb2__)
	/* Come out of Thumb mode.  This code should be redundant.  */

	mov	a4, pc
	bx	a4

	.code 32
	.global change_back
change_back:
	/* Halt the execution.  This code should never be executed.  */
	/* With no debug monitor, this probably aborts (eventually).
	   With a Demon debug monitor, this halts cleanly.
	   With an Angel debug monitor, this will report 'Unknown SWI'.	 */
	swi	SWI_Exit
#endif
	
	/* For Thumb, constants must be after the code since only 
	   positive offsets are supported for PC relative addresses.  */
	
	.align 0
.LC0:
#ifdef ARM_RDI_MONITOR
	.word	HeapBase
#else
#ifndef ARM_RDP_MONITOR
#ifdef __pe__
	.word	0x800000
#else
/*	.word	0x80000	*/		/* Top of RAM on the PIE board.  */
#endif
#endif
#endif
#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
	/* Protect against unhandled exceptions.  */
	.cantunwind
	.fnend
#endif
.LC1:
	.word	__bss_start__
.LC2:
	.word	__bss_end__
#ifdef __USES_INITFINI__
.Lfini:
	.word	FUNCTION(_fini)
#endif
#ifdef ARM_RDI_MONITOR
.LC30:
	.word	CommandLine
	.word	255

/*  Workspace for Angel calls.  */
	.data
/*  Data returned by monitor SWI.  */
.global	__stack_base__
HeapBase:	.word	0
HeapLimit:	.word	0
__stack_base__:	.word	0
StackLimit:	.word	0
CommandLine:	.space	256,0	/*  Maximum length of 255 chars handled.  */
#endif
	
#ifdef __pe__
	.section .idata$3
	.long	0,0,0,0,0,0,0,0
#endif
@


1.12.2.1
log
@2006-03-23  Mark Mitchell  <mark@@codesourcery.com>

	* libc/sys/arm/Makefile.am (extra_objs): Add _exit.o _nmi_isr.o
	_fault_isr.o.
	* libc/sys/arm/Makefile.in: Regenerated.
	* libc/sys/arm/_exit.c: New file.
	* libc/sys/arm/_fault_isr.c: Likewise.
	* libc/sys/arm/_nmi_isr.c: Likewise.
	* libc/sys/arm/configure.in (--enable-newlib-arm-v7m): New option.
	* libc/sys/arm/configure:
	* libc/sys/arm/crt0.S (_start): Do not use semihosting calls in
	_start when configured for ARM V7M.  Do not call
	initialise_monitor_handles.  Indent preprocessor directives.
	(.isr_vector): New section, on ARM V7M.
	* libc/sys/arm/swi.h (do_AngelSWI): New function.
	* syscalls.c (_exit): Remove.
	(do_AngelSWI): Likewise.
	(CHECK_INIT): Remove.
	(remap_handle): Call initialise_monitor_handles.
	(__arm_monitor_handles_lock): New variable.
	(initialise_monitor_handles): Make sure to run only once.
@
text
@d46 2
a47 5
	/* Start by setting up a stack */
#ifdef _ARM_V7M
	/* On ARM V7M, the stack pointer is set up at CPU reset.  */
#else
# ifdef ARM_RDP_MONITOR
d54 2
a55 2
# else
#  ifdef ARM_RDI_MONITOR
d59 1
a59 1
#   if defined(__thumb2__)
d61 1
a61 1
#   else
d64 1
a64 1
#   endif
d70 1
a70 1
#  else
a81 2
#  endif
# endif
d83 1
a83 1
	
d106 1
a106 5
        /* For ARM V7M, we do not want to have semihosting traps in
   	   crt0.o, so that people can use the same programs both with
	   and without semihosting.  */   
#if ((!defined (ARM_RDP_MONITOR) && !defined (ARM_RDI_MONITOR)) \
     || defined (_ARM_V7M))
d110 4
a113 1
# ifdef ARM_RDP_MONITOR
d116 1
a116 1
# else
d121 1
a121 1
# endif
d125 1
a125 1
# ifdef __thumb__
d127 1
a127 1
# else
d129 1
a129 1
# endif
d132 1
a132 1
# ifdef __thumb__
d135 1
a135 1
# else
d137 1
a137 1
# endif
d145 1
a145 1
# ifdef __thumb__
d157 1
a157 1
# else
d162 1
a162 1
# endif
d165 1
a165 1
# ifdef __thumb__
d167 1
a167 1
# else
d169 1
a169 1
# endif
d172 1
a172 1
# ifdef __thumb__
d175 1
a175 1
# else
d177 1
a177 1
# endif
d190 1
a190 1
# ifdef __thumb__
d210 1
a210 1
# else
d221 1
a221 1
# endif
a260 1
#ifndef _ARM_V7M
d262 1
a262 1
# ifdef ARM_RDI_MONITOR
d264 3
a266 3
# else
#  ifndef ARM_RDP_MONITOR
#   ifdef __pe__
d268 1
a268 1
#   else
d270 3
a272 4
#   endif
#  endif
# endif
#endif 	
d286 1
a286 1
#if defined(ARM_RDI_MONITOR) && !defined(_ARM_V7M)
a305 15

#ifdef _ARM_V7M
	/* The hardware uses this vector to handle hardware resets and 
	   exceptions.  */
	.section .isr_vector, "a"
	/* The value for the stack pointer at reset.  */
	.word	_stack
	/* The value for the PC at reset.  */
	.word	_start
	/* The value for the PC if an NMI occurs.  */
	.word	_nmi_isr
	/* The value for the PC if a fault occurs.  */
	.word	_fault_isr
#endif _ARM_V7M
	 
@


1.12.2.2
log
@2006-08-30  Paul Brook  <paul@@codesourcery.com>

	libgloss/
	* arm/Makefile.in: Change armv7m linker script generation.  Add
	armv7m.spec.  Build armv7m-crt0.o.
	* arm/arm.sc: New file.
	* arm/armv7m.specs: New file.
	* arm/crt0.S: Add armv7m code.
	* arm/elf-lm3s10x.ld: Remove.
	* arm/elf-lm3s301.ld: Remove.
	* arm/elf-lm3s31x.ld: Remove.
	* arm/swi.h (do_AngelSWI): Add definition.
	* arm/syscalls.c: Merge lazy semihosting initialization from newlib.

	newlib/
	* libc/sys/arm/crt0.S: Add armv7m rom startup code.
@
text
@d48 1
a48 21
	/* Copy .data into ram.  */
	ldr	r0, =__data_load
	ldr	r1, =__data_start
	cmp	r0, r1 /* If LMA == VMA we are running from ram.  */
	beq	2f
	ldr	r2, =_edata
	/* When running from ROM the stack pointer is set up at CPU reset.  */
	/* Copy .data into RAM.  */
1:
	ldr	r3, [r0], #4
	str	r3, [r1], #4
	cmp	r1, r2
	blt	1b
	b	3f
2:
	/* Set the stack pointer when running from RAM.  */
	ldr	r0, .Lstack
	cmp	r0, #0
	beq	3f
	mov	sp, r0
3:
a280 4
#ifdef _ARM_V7M
.Lstack:	
	.word	__stack
#endif
d320 1
a320 1
	.word	__stack
d327 1
a327 1
#endif /* _ARM_V7M */
@


1.11
log
@
2005-07-19  Paul Brook  <paul@@codesourcery.com>

        * libc/sys/arm/crt0.S: Ensure doubleword stack alignment.
@
text
@d21 9
d31 5
d38 3
a40 6
	.global	_mainCRTStartup
	.global	_start
	.global	start
start:
_start:
_mainCRTStartup:
d59 6
a64 1
	swi	AngelSWI_ARM	/*  We are always in ARM mode for startup */
d94 2
a95 2
#ifdef __thumb__		/* Enter Thumb mode.... */

d119 1
a119 1
	swi	AngelSWI
d241 1
a241 1
#ifdef __thumb__
@


1.10
log
@
2005-01-07  Paul Brook  <paul@@codesourcery.com>

        * configure.in: Add test for .init_array.
        * configure: Regenerate.
        * newlib.hin: Add HAVE_INITFINI_ARRAY.
        * libc/misc/Makefile.am: Add init.c
        * libc/misc/Makefile.in: Regenerate.
        * libc/misc/init.c: New file.
        * libc/sys/arm/crt0.S: Call __libc_{init,fini}_array instead of
        _init/_fini if they exist.
@
text
@d189 5
d203 2
@


1.9
log
@
2004-11-26  Paul Brook  <paul@@codesourcery.com>

        * libc/sys/arm/crt0.S (_start): Add .cantunwind annotation.
@
text
@d1 1
d14 5
@


1.8
log
@Fix bugs in previous delta
@
text
@d24 4
d244 5
@


1.7
log
@ Add NULL to end of argv array.
@
text
@d98 6
a187 8
#endif

	/* Push a NULL argument onto the end of the list.  */
	mov	r2, #0
#ifdef __thumb__
	push	{r2}
#else
	stmfd	sp!, {r1}
@


1.6
log
@	* Various formatting and whitespace changes.
@
text
@d184 7
@


1.5
log
@For __USES_INITFINI__ preserve the argument vector before calling the
initialisation functions.
@
text
@d58 1
a262 1

@


1.4
log
@Add __stack_base__
@
text
@d190 2
d195 2
@


1.3
log
@oops omitted in previous delta
@
text
@d246 1
d249 1
a249 1
StackBase:	.word	0
@


1.2
log
@
Wed Jun 28 14:08:00 2000  Keith Walker  <keith.walker@@arm.com>

        * libc/sys/arm/crt0.S (.LC30): Added missing length parameter
        to argument list for AngelSWI_Reason_GetCmdLine.
@
text
@d184 10
d196 1
a196 1
	bl	FUNCTION (exit)		/* Should not return */
d199 1
a199 1
	/* Come out of Thumb mode... This code should be redundant...   */
d208 3
a210 5
	/*
	** With no debug monitor, this probably aborts (eventually).
	** With a Demon debug monitor, this halts cleanly.
	** With an Angel debug monitor, this will report 'Unknown SWI'.
	*/
d215 1
a215 1
	positive offsets are supported for PC relative addresses. */
d226 1
a226 1
/*	.word	0x80000	*/		/* Top of RAM on the PIE board */
d234 4
a237 1

d239 2
a240 1
.LC30:	.word	CommandLine
d243 1
a243 1
/*  Workspace for Angel calls. */
d245 1
a245 1
/*  Data returned by monitor SWI */
d250 1
a250 1
CommandLine:	.space	256,0	/*  Maximum length of 255 chars handled */
@


1.1
log
@Initial revision
@
text
@d229 1
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
