head	1.5;
access;
symbols
	cygwin-1_7_35-release:1.5
	cygwin-1_7_34-release:1.5
	newlib-2_2_0:1.5.0.10
	cygwin-1_7_33-release:1.5
	cygwin-1_7_32-release:1.5
	cygwin-1_7_31-release:1.5
	cygwin-1_7_30-release:1.5
	cygwin-1_7_29-release:1.5
	cygwin-1_7_28-release:1.5
	newlib-2_1_0:1.5
	cygwin-1_7_27-release:1.5
	cygwin-1_7_26-release:1.5
	cygwin-1_7_25-release:1.5
	cygwin-1_7_24-release:1.5
	cygwin-1_7_23-release:1.5
	cygwin-1_7_22-release:1.5
	cygwin-1_7_21-release:1.5
	cygwin-1_7_20-release:1.5
	cygwin-1_7_19-release:1.5
	cygwin-64bit-postmerge:1.5
	cygwin-64bit-premerge-branch:1.5.0.8
	cygwin-64bit-premerge:1.5
	cygwin-1_7_18-release:1.5
	newlib-2_0_0:1.5
	cygwin-1_7_17-release:1.5
	cygwin-64bit-branch:1.5.0.6
	cygwin-1_7_16-release:1.5
	cygwin-1_7_15-release:1.5
	cygwin-1_7_14_2-release:1.5
	cygwin-1_7_14-release:1.5
	cygwin-1_7_12-release:1.5
	cygwin-1_7_11-release:1.5
	cygwin-1_7_10-release:1.5
	newlib-1_20_0:1.5
	cygwin-1_7_9-release:1.5
	cygwin-1_7_8-release:1.5
	newlib-1_19_0:1.5
	cygwin-1_7_7-release:1.5
	cygwin-1_7_5-release:1.5
	cygwin-1_7_4-release:1.5
	cygwin-1_7_3-release:1.5
	cygwin-1_7_2-release:1.5
	newlib-1_18_0:1.5
	cygwin-1_7_1-release:1.5
	newlib-1_17_0-arc:1.5.0.4
	binutils-arc-20080908-branch:1.5.0.2
	binutils-arc-20080908-branchpoint:1.5
	newlib-1_17_0:1.5
	newlib-1_16_0:1.4
	newlib-1_15_0:1.4
	newlib-csl-coldfire-4_1-32:1.4
	newlib-csl-sourcerygxx-4_1-32:1.4
	newlib-csl-innovasic-fido-3_4_4-33:1.4
	newlib-csl-coldfire-4_1-30:1.4
	newlib-csl-sourcerygxx-4_1-30:1.4
	newlib-csl-coldfire-4_1-28:1.4
	newlib-csl-sourcerygxx-4_1-28:1.4
	newlib-csl-arm-2006q3-27:1.4
	newlib-csl-sourcerygxx-4_1-27:1.4
	newlib-csl-arm-2006q3-26:1.4
	newlib-csl-sourcerygxx-4_1-26:1.4
	newlib-csl-sourcerygxx-4_1-24:1.4
	newlib-csl-sourcerygxx-4_1-23:1.4
	newlib-csl-sourcerygxx-4_1-21:1.4
	newlib-csl-arm-2006q3-21:1.4
	newlib-csl-arm-2006q3-19:1.4
	newlib-csl-sourcerygxx-4_1-19:1.4
	newlib-csl-sourcerygxx-4_1-18:1.4
	newlib-csl-sourcerygxx-3_4_4-25:1.4
	newlib-csl-sourcerygxx-4_1-17:1.4
	cr-0x5f1:1.4.0.6
	newlib-csl-sourcerygxx-4_1-14:1.4
	newlib-csl-sourcerygxx-4_1-13:1.4
	newlib-csl-sourcerygxx-4_1-12:1.4
	newlib-csl-sourcerygxx-4_1-9:1.4
	newlib-csl-sourcerygxx-4_1-8:1.4
	newlib-csl-sourcerygxx-4_1-7:1.4
	newlib-csl-arm-2006q1-6:1.4
	newlib-csl-sourcerygxx-4_1-6:1.4
	newlib-csl-sourcerygxx-4_1-5:1.4
	newlib-csl-sourcerygxx-4_1-4:1.4
	newlib-autotools-branch:1.4.0.4
	newlib-csl-20060320-branch:1.4.0.2
	newlib-csl-20060320-branchpoint:1.4
	newlib-1_14_0:1.4
	newlib-csl-arm-2005-q1b:1.4
	newlib-csl-arm-2005-q1a:1.4
	newlib-1_13_0:1.4
	csl-arm-2004-q3:1.4
	csl-arm-2004-q1a:1.4
	csl-arm-2004-q1:1.4
	newlib-1_12_0:1.4
	csl-arm-2003-q4:1.4
	w32api-2_2:1.4
	mingw-runtime-2_4:1.4
	newlib-1_11_0:1.4;
locks; strict;
comment	@ * @;


1.5
date	2008.07.02.18.38.45;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.02.18.18.58;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.21.19.09.50;	author fitzsim;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.21.18.15.56;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.20.19.51.31;	author fitzsim;	state Exp;
branches;
next	;


desc
@@


1.5
log
@
2008-07-02  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/argz/argz_count.c: Include stddef.h to get size_t.
        * libc/argz/argz_extract.c: Ditto.
        * libc/argz/argz_stringify.c: Ditto.
        * libc/search/hash.h: Ditto.
        * libc/sys/linux/include/sched.h: Ditto.
        * libc/sys/linux/sys/types.h: Ditto.
@
text
@/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Margo Seltzer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)hash.h	8.3 (Berkeley) 5/31/94
 * $FreeBSD: src/lib/libc/db/hash/hash.h,v 1.6 2002/03/21 22:46:26 obrien Exp $
 */

#include <sys/param.h>
#define __need_size_t
#include <stddef.h>

/* Check that newlib understands the byte order of its target system.  */
#ifndef BYTE_ORDER
#error BYTE_ORDER not defined by sys/param.h
#endif

/* Define DB endianness constants based on target endianness.  */
#define DB_LITTLE_ENDIAN 1234
#define DB_BIG_ENDIAN 4321
#if (BYTE_ORDER == LITTLE_ENDIAN)
#define DB_BYTE_ORDER DB_LITTLE_ENDIAN
#else
#define DB_BYTE_ORDER DB_BIG_ENDIAN
#endif

/* Operations */
typedef enum {
	HASH_GET, HASH_PUT, HASH_PUTNEW, HASH_DELETE, HASH_FIRST, HASH_NEXT
} ACTION;

/* Buffer Management structures */
typedef struct _bufhead BUFHEAD;

struct _bufhead {
	BUFHEAD		*prev;		/* LRU links */
	BUFHEAD		*next;		/* LRU links */
	BUFHEAD		*ovfl;		/* Overflow page buffer header */
	__uint32_t	 addr;		/* Address of this page */
	char		*page;		/* Actual page data */
	char	 	flags;
#define	BUF_MOD		0x0001
#define BUF_DISK	0x0002
#define	BUF_BUCKET	0x0004
#define	BUF_PIN		0x0008
};

#define IS_BUCKET(X)	((X) & BUF_BUCKET)

typedef BUFHEAD **SEGMENT;

/* Hash Table Information */
typedef struct hashhdr {		/* Disk resident portion */
	int		magic;		/* Magic NO for hash tables */
	int		version;	/* Version ID */
	__uint32_t	lorder;		/* Byte Order */
	int		bsize;		/* Bucket/Page Size */
	int		bshift;		/* Bucket shift */
	int		dsize;		/* Directory Size */
	int		ssize;		/* Segment Size */
	int		sshift;		/* Segment shift */
	int		ovfl_point;	/* Where overflow pages are being 
					 * allocated */
	int		last_freed;	/* Last overflow page freed */
	int		max_bucket;	/* ID of Maximum bucket in use */
	int		high_mask;	/* Mask to modulo into entire table */
	int		low_mask;	/* Mask to modulo into lower half of 
					 * table */
	int		ffactor;	/* Fill factor */
	int		nkeys;		/* Number of keys in hash table */
	int		hdrpages;	/* Size of table header */
	int		h_charkey;	/* value of hash(CHARKEY) */
#define NCACHED	32			/* number of bit maps and spare 
					 * points */
	int		spares[NCACHED];/* spare pages for overflow */
	__uint16_t	bitmaps[NCACHED];	/* address of overflow page 
						 * bitmaps */
} HASHHDR;

typedef struct htab	 {		/* Memory resident data structure */
	HASHHDR 	hdr;		/* Header */
	int		nsegs;		/* Number of allocated segments */
	int		exsegs;		/* Number of extra allocated 
					 * segments */
	__uint32_t			/* Hash function */
	    (*hash)(const void *, size_t);
	int		flags;		/* Flag values */
	int		fp;		/* File pointer */
	char		*tmp_buf;	/* Temporary Buffer for BIG data */
	char		*tmp_key;	/* Temporary Buffer for BIG keys */
	BUFHEAD 	*cpage;		/* Current page */
	int		cbucket;	/* Current bucket */
	int		cndx;		/* Index of next item on cpage */
	int		error;		/* Error Number -- for DBM 
					 * compatibility */
	int		new_file;	/* Indicates if fd is backing store 
					 * or no */
	int		save_file;	/* Indicates whether we need to flush 
					 * file at
					 * exit */
	__uint32_t	*mapp[NCACHED];	/* Pointers to page maps */
	int		nmaps;		/* Initial number of bitmaps */
	int		nbufs;		/* Number of buffers left to 
					 * allocate */
	BUFHEAD 	bufhead;	/* Header of buffer lru list */
	SEGMENT 	*dir;		/* Hash Bucket directory */
} HTAB;

/*
 * Constants
 */
#define	MAX_BSIZE		65536		/* 2^16 */
#define MIN_BUFFERS		6
#define MINHDRSIZE		512
#define DEF_BUFSIZE		65536		/* 64 K */
#define DEF_BUCKET_SIZE		4096
#define DEF_BUCKET_SHIFT	12		/* log2(BUCKET) */
#define DEF_SEGSIZE		256
#define DEF_SEGSIZE_SHIFT	8		/* log2(SEGSIZE)	 */
#define DEF_DIRSIZE		256
#define DEF_FFACTOR		65536
#define MIN_FFACTOR		4
#define SPLTMAX			8
#define CHARKEY			"%$sniglet^&"
#define NUMKEY			1038583
#define BYTE_SHIFT		3
#define INT_TO_BYTE		2
#define INT_BYTE_SHIFT		5
#define ALL_SET			((__uint32_t)0xFFFFFFFF)
#define ALL_CLEAR		0

#define PTROF(X)	((BUFHEAD *)((ptrdiff_t)(X)&~0x3))
#define ISMOD(X)	((__uint32_t)(ptrdiff_t)(X)&0x1)
#define DOMOD(X)	((X) = (char *)((ptrdiff_t)(X)|0x1))
#define ISDISK(X)	((__uint32_t)(ptrdiff_t)(X)&0x2)
#define DODISK(X)	((X) = (char *)((ptrdiff_t)(X)|0x2))

#define BITS_PER_MAP	32

/* Given the address of the beginning of a big map, clear/set the nth bit */
#define CLRBIT(A, N)	((A)[(N)/BITS_PER_MAP] &= ~(1<<((N)%BITS_PER_MAP)))
#define SETBIT(A, N)	((A)[(N)/BITS_PER_MAP] |= (1<<((N)%BITS_PER_MAP)))
#define ISSET(A, N)	((A)[(N)/BITS_PER_MAP] & (1<<((N)%BITS_PER_MAP)))

/* Overflow management */
/*
 * Overflow page numbers are allocated per split point.  At each doubling of
 * the table, we can allocate extra pages.  So, an overflow page number has
 * the top 5 bits indicate which split point and the lower 11 bits indicate
 * which page at that split point is indicated (pages within split points are
 * numberered starting with 1).
 */

#define SPLITSHIFT	11
#define SPLITMASK	0x7FF
#define SPLITNUM(N)	(((__uint32_t)(N)) >> SPLITSHIFT)
#define OPAGENUM(N)	((N) & SPLITMASK)
#define	OADDR_OF(S,O)	((__uint32_t)((__uint32_t)(S) << SPLITSHIFT) + (O))

#define BUCKET_TO_PAGE(B) \
	(B) + hashp->HDRPAGES + ((B) ? hashp->SPARES[__log2((B)+1)-1] : 0)
#define OADDR_TO_PAGE(B) 	\
	BUCKET_TO_PAGE ( (1 << SPLITNUM((B))) -1 ) + OPAGENUM((B));

/*
 * page.h contains a detailed description of the page format.
 *
 * Normally, keys and data are accessed from offset tables in the top of
 * each page which point to the beginning of the key and data.  There are
 * four flag values which may be stored in these offset tables which indicate
 * the following:
 *
 *
 * OVFLPAGE	Rather than a key data pair, this pair contains
 *		the address of an overflow page.  The format of
 *		the pair is:
 *		    OVERFLOW_PAGE_NUMBER OVFLPAGE
 *
 * PARTIAL_KEY	This must be the first key/data pair on a page
 *		and implies that page contains only a partial key.
 *		That is, the key is too big to fit on a single page
 *		so it starts on this page and continues on the next.
 *		The format of the page is:
 *		    KEY_OFF PARTIAL_KEY OVFL_PAGENO OVFLPAGE
 *
 *		    KEY_OFF -- offset of the beginning of the key
 *		    PARTIAL_KEY -- 1
 *		    OVFL_PAGENO - page number of the next overflow page
 *		    OVFLPAGE -- 0
 *
 * FULL_KEY	This must be the first key/data pair on the page.  It
 *		is used in two cases.
 *
 *		Case 1:
 *		    There is a complete key on the page but no data
 *		    (because it wouldn't fit).  The next page contains
 *		    the data.
 *
 *		    Page format it:
 *		    KEY_OFF FULL_KEY OVFL_PAGENO OVFL_PAGE
 *
 *		    KEY_OFF -- offset of the beginning of the key
 *		    FULL_KEY -- 2
 *		    OVFL_PAGENO - page number of the next overflow page
 *		    OVFLPAGE -- 0
 *
 *		Case 2:
 *		    This page contains no key, but part of a large
 *		    data field, which is continued on the next page.
 *
 *		    Page format it:
 *		    DATA_OFF FULL_KEY OVFL_PAGENO OVFL_PAGE
 *
 *		    KEY_OFF -- offset of the beginning of the data on
 *				this page
 *		    FULL_KEY -- 2
 *		    OVFL_PAGENO - page number of the next overflow page
 *		    OVFLPAGE -- 0
 *
 * FULL_KEY_DATA
 *		This must be the first key/data pair on the page.
 *		There are two cases:
 *
 *		Case 1:
 *		    This page contains a key and the beginning of the
 *		    data field, but the data field is continued on the
 *		    next page.
 *
 *		    Page format is:
 *		    KEY_OFF FULL_KEY_DATA OVFL_PAGENO DATA_OFF
 *
 *		    KEY_OFF -- offset of the beginning of the key
 *		    FULL_KEY_DATA -- 3
 *		    OVFL_PAGENO - page number of the next overflow page
 *		    DATA_OFF -- offset of the beginning of the data
 *
 *		Case 2:
 *		    This page contains the last page of a big data pair.
 *		    There is no key, only the  tail end of the data
 *		    on this page.
 *
 *		    Page format is:
 *		    DATA_OFF FULL_KEY_DATA <OVFL_PAGENO> <OVFLPAGE>
 *
 *		    DATA_OFF -- offset of the beginning of the data on
 *				this page
 *		    FULL_KEY_DATA -- 3
 *		    OVFL_PAGENO - page number of the next overflow page
 *		    OVFLPAGE -- 0
 *
 *		    OVFL_PAGENO and OVFLPAGE are optional (they are
 *		    not present if there is no next page).
 */

#define OVFLPAGE	0
#define PARTIAL_KEY	1
#define FULL_KEY	2
#define FULL_KEY_DATA	3
#define	REAL_KEY	4

/* Short hands for accessing structure */
#define BSIZE		hdr.bsize
#define BSHIFT		hdr.bshift
#define DSIZE		hdr.dsize
#define SGSIZE		hdr.ssize
#define SSHIFT		hdr.sshift
#define LORDER		hdr.lorder
#define OVFL_POINT	hdr.ovfl_point
#define	LAST_FREED	hdr.last_freed
#define MAX_BUCKET	hdr.max_bucket
#define FFACTOR		hdr.ffactor
#define HIGH_MASK	hdr.high_mask
#define LOW_MASK	hdr.low_mask
#define NKEYS		hdr.nkeys
#define HDRPAGES	hdr.hdrpages
#define SPARES		hdr.spares
#define BITMAPS		hdr.bitmaps
#define HASH_VERSION	hdr.version
#define MAGIC		hdr.magic
#define NEXT_FREE	hdr.next_free
#define H_CHARKEY	hdr.h_charkey
@


1.4
log
@
2002-07-02  Chris Demetriou  <cgd@@broadcom.com>

        * libc/include/sys/config.h (__IEEE_LITTLE_ENDIAN)
        (__IEEE_BIG_ENDIAN): Define appropriately for MIPS.
        Check that one of them is defined and error out if not.
        Add any platforms defined in <machine/ieeefp.h> that are missing.
        * libc/search/hash.h (DB_BYTE_ORDER, DB_BIG_ENDIAN)
        (DB_LITTLE_ENDIAN): New defines.
        * libc/search/hash.c: Replace all incorrect checks for
        _IEEE_LITTLE_ENDIAN with tests of BYTE_ORDER, and all uses of
        BYTE_ORDER, LITTLE_ENDIAN, and BIG_ENDIAN with DB_* versions.
        * libc/search/hash_page.c: Likewise.
@
text
@d41 2
@


1.3
log
@	* libc/search/hash.h (LITTLE_ENDIAN, BIG_ENDIAN): Define if not
	previously defined.
@
text
@d42 1
d44 1
a44 2
#ifndef LITTLE_ENDIAN
#define LITTLE_ENDIAN 1234
d46 6
a51 5
#ifndef BIG_ENDIAN
#define BIG_ENDIAN 4321
#endif
#ifdef __IEEE_LITTLE_ENDIAN
#define BYTE_ORDER LITTLE_ENDIAN
d53 1
a53 2
#define BYTE_ORDER BIG_ENDIAN
#endif
@


1.2
log
@
2002-06-21  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/math.h: Add <sys/types.h> to get _uint32_t definition.
        * libc/include/machine/types.h: Skip __off_t, __pid_t, and
        __loff_t definitions if special _HAVE_SYSTYPES macro defined.
        * libc/include/sys/config.h: Removed _uint*, _int* definitions.
        * libc/include/sys/param.h: Remove i386 case which is handled
        by default case.
        (BIG_ENDIAN, LITTLE_ENDIAN): Protect
        definitions in case they are already defined.
        (BYTE_ORDER): Add default case using _IEEE_BIG_ENDIAN and
        _IEEE_LITTLE_ENDIAN flags.
        * libc/include/sys/reent.h: Change __uint32_t references to
        use _ULong instead.
        (_REENT_GETDATE_REENT_P): New macro.
        * libc/include/sys/types.h (__int16_t, __uint16_t): Added.
        (__int32_t, __uint32_t, __int64_t, __uint64_t): Ditto.
        * libc/search/hash.h: Add default setting of BYTE_ORDER,
        LITTLE_ENDIAN, and BIG_ENDIAN, if not already defined.
        * libc/sys/linux/sys/types.h: Include <sys/_types.h>.  Define
        ssize_t based on _ssize_t.  Remove __socklen_t, __uintptr_t,
        pid_t, off_t, loff_t, caddr_t, and daddr_t type
        definitions which are done by subsequent glibc headers.
        Add macro definitions to prevent subsequent header files from
        defining pid_t, off_t, ssize_t, and key_t.  Move uintptr_t and
        intptr_t to after glibc definitions of types they are based on.
@
text
@d43 6
@


1.1
log
@	* Makefile.am (LIB_OBJECTLISTS): Add
	libc/search/objectlist.awk.in.
	* libc/Makefile.am (SUBDIRS): Add search.
	(SUBLIBS): Add search/libsearch.la.
	* libc/configure.in (AC_OUTPUT): Add search/Makefile.
	* libc/search: New directory.
	* libc/search/Makefile.am: New file.
	* libc/search/extern.h: New file.
	* libc/search/hash.c: New file.
	* libc/search/hash.h: New file.
	* libc/search/hash_bigkey.c: New file.
	* libc/search/hash_buf.c: New file.
	* libc/search/hash_func.c: New file.
	* libc/search/hash_log2.c: New file.
	* libc/search/hash_page.c: New file.
	* libc/search/hcreate.3: New file.
	* libc/search/hcreate.c: New file.
	* libc/search/hcreate.c~: New file.
	* libc/search/hcreate_r.c: New file.
	* libc/search/ndbm.c: New file.
	* libc/search/page.h: New file.
	* libc/search/tdelete.c: New file.
	* libc/search/tdestroy.c: New file.
	* libc/search/tfind.c: New file.
	* libc/search/tsearch.3: New file.
	* libc/search/tsearch.c: New file.
	* libc/search/twalk.c: New file.
	* libc/include/db.h: New file.
	* libc/include/ndbm.h: New file.
	* libc/include/search.h: New file.
	* libc/include/sys/queue.h: New file.
	* libc/include/sys/cdefs.h: New file.
	* libc/include/sys/param.h
	[__IEEE_LITTLE_ENDIAN,__IEEE_BIG_ENDIAN]: Set BYTE_ORDER to
	LITTLE_ENDIAN or BIG_ENDIAN.
	* libc/include/sys/errno.h (EFTYPE): New macro.
	* libc/search/bsearch.c: Move from libc/stdlib.
	* libc/search/qsort.c: Likewise.
	* libc/stdlib/Makefile.am (LIB_SOURCES): Remove bsearch.c and
	qsort.c.
	(CHEWOUT_FILES): Remove bsearch.def and qsort.def.
	* libc/stdlib/stdlib.tex: Remove references to bsearch and qsort.
@
text
@d40 10
@

