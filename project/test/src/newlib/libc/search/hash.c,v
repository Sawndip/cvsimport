head	1.13;
access;
symbols
	cygwin-1_7_35-release:1.13
	cygwin-1_7_34-release:1.13
	newlib-2_2_0:1.13.0.2
	cygwin-1_7_33-release:1.13
	cygwin-1_7_32-release:1.13
	cygwin-1_7_31-release:1.13
	cygwin-1_7_30-release:1.13
	cygwin-1_7_29-release:1.13
	cygwin-1_7_28-release:1.13
	newlib-2_1_0:1.12
	cygwin-1_7_27-release:1.12
	cygwin-1_7_26-release:1.12
	cygwin-1_7_25-release:1.12
	cygwin-1_7_24-release:1.12
	cygwin-1_7_23-release:1.12
	cygwin-1_7_22-release:1.12
	cygwin-1_7_21-release:1.12
	cygwin-1_7_20-release:1.12
	cygwin-1_7_19-release:1.12
	cygwin-64bit-postmerge:1.12
	cygwin-64bit-premerge-branch:1.12.0.2
	cygwin-64bit-premerge:1.12
	cygwin-1_7_18-release:1.11
	newlib-2_0_0:1.11
	cygwin-1_7_17-release:1.11
	cygwin-64bit-branch:1.11.0.2
	cygwin-1_7_16-release:1.10
	cygwin-1_7_15-release:1.10
	cygwin-1_7_14_2-release:1.10
	cygwin-1_7_14-release:1.10
	cygwin-1_7_12-release:1.10
	cygwin-1_7_11-release:1.10
	cygwin-1_7_10-release:1.10
	newlib-1_20_0:1.10
	cygwin-1_7_9-release:1.10
	cygwin-1_7_8-release:1.10
	newlib-1_19_0:1.10
	cygwin-1_7_7-release:1.10
	cygwin-1_7_5-release:1.10
	cygwin-1_7_4-release:1.10
	cygwin-1_7_3-release:1.10
	cygwin-1_7_2-release:1.10
	newlib-1_18_0:1.9
	cygwin-1_7_1-release:1.9
	newlib-1_17_0-arc:1.9.0.4
	binutils-arc-20080908-branch:1.9.0.2
	binutils-arc-20080908-branchpoint:1.9
	newlib-1_17_0:1.9
	newlib-1_16_0:1.9
	newlib-1_15_0:1.7
	newlib-csl-coldfire-4_1-32:1.7
	newlib-csl-sourcerygxx-4_1-32:1.7
	newlib-csl-innovasic-fido-3_4_4-33:1.7
	newlib-csl-coldfire-4_1-30:1.7
	newlib-csl-sourcerygxx-4_1-30:1.7
	newlib-csl-coldfire-4_1-28:1.7
	newlib-csl-sourcerygxx-4_1-28:1.7
	newlib-csl-arm-2006q3-27:1.7
	newlib-csl-sourcerygxx-4_1-27:1.7
	newlib-csl-arm-2006q3-26:1.7
	newlib-csl-sourcerygxx-4_1-26:1.7
	newlib-csl-sourcerygxx-4_1-24:1.7
	newlib-csl-sourcerygxx-4_1-23:1.7
	newlib-csl-sourcerygxx-4_1-21:1.7
	newlib-csl-arm-2006q3-21:1.7
	newlib-csl-arm-2006q3-19:1.7
	newlib-csl-sourcerygxx-4_1-19:1.7
	newlib-csl-sourcerygxx-4_1-18:1.7
	newlib-csl-sourcerygxx-3_4_4-25:1.7
	newlib-csl-sourcerygxx-4_1-17:1.7
	cr-0x5f1:1.7.0.6
	newlib-csl-sourcerygxx-4_1-14:1.7
	newlib-csl-sourcerygxx-4_1-13:1.7
	newlib-csl-sourcerygxx-4_1-12:1.7
	newlib-csl-sourcerygxx-4_1-9:1.7
	newlib-csl-sourcerygxx-4_1-8:1.7
	newlib-csl-sourcerygxx-4_1-7:1.7
	newlib-csl-arm-2006q1-6:1.7
	newlib-csl-sourcerygxx-4_1-6:1.7
	newlib-csl-sourcerygxx-4_1-5:1.7
	newlib-csl-sourcerygxx-4_1-4:1.7
	newlib-autotools-branch:1.7.0.4
	newlib-csl-20060320-branch:1.7.0.2
	newlib-csl-20060320-branchpoint:1.7
	newlib-1_14_0:1.7
	newlib-csl-arm-2005-q1b:1.7
	newlib-csl-arm-2005-q1a:1.7
	newlib-1_13_0:1.7
	csl-arm-2004-q3:1.7
	csl-arm-2004-q1a:1.6
	csl-arm-2004-q1:1.6
	newlib-1_12_0:1.6
	csl-arm-2003-q4:1.6
	w32api-2_2:1.4
	mingw-runtime-2_4:1.4
	newlib-1_11_0:1.4;
locks; strict;
comment	@ * @;


1.13
date	2014.01.06.19.50.33;	author jjohnstn;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.19.09.13.27;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2012.08.08.11.04.17;	author corinna;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2010.03.05.08.55.15;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.16.19.31.08;	author ericb;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.30.03.13.29;	author bje;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.26.17.57.10;	author jjohnstn;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2003.05.13.09.19.14;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.11.09.38;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.19.21.28.51;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.02.18.18.58;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.24.23.05.08;	author fitzsim;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.20.19.51.31;	author fitzsim;	state Exp;
branches;
next	;

1.11.2.1
date	2013.04.22.10.34.02;	author corinna;	state Exp;
branches;
next	;

1.7.6.1
date	2007.11.14.15.57.45;	author corinna;	state Exp;
branches;
next	;


desc
@@


1.13
log
@
2014-01-06  Mike Frysinger  <vapier@@gentoo.org>

        * libc/search/hash.c (hash_delete): Change __uint32_t to u_int.
        (hash_get): Likewise.
        (hash_put): Likewise.
        (hash_seq): Likewise.
        (hash_sync): Likewise.

Also fix former ChangeLog entry to be 2014.
@
text
@/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Margo Seltzer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)hash.c	8.9 (Berkeley) 6/16/94";
#endif /* LIBC_SCCS and not lint */
#include <sys/cdefs.h>
#include <sys/types.h>

#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#ifdef DEBUG
#include <assert.h>
#endif

#define __DBINTERFACE_PRIVATE	/* activate prototypes from db_local.h */
#include "db_local.h"
#include "hash.h"
#include "page.h"
#include "extern.h"

static int   alloc_segs(HTAB *, int);
static int   flush_meta(HTAB *);
static int   hash_access(HTAB *, ACTION, DBT *, DBT *);
static int   hash_close(DB *);
static int   hash_delete(const DB *, const DBT *, u_int);
static int   hash_fd(const DB *);
static int   hash_get(const DB *, const DBT *, DBT *, u_int);
static int   hash_put(const DB *, DBT *, const DBT *, u_int);
static void *hash_realloc(SEGMENT **, int, int);
static int   hash_seq(const DB *, DBT *, DBT *, u_int);
static int   hash_sync(const DB *, u_int);
static int   hdestroy(HTAB *);
static HTAB *init_hash(HTAB *, const char *, const HASHINFO *);
static int   init_htab(HTAB *, int);
#if (BYTE_ORDER == LITTLE_ENDIAN)
static void  swap_header(HTAB *);
static void  swap_header_copy(HASHHDR *, HASHHDR *);
#endif

/* Macros for min/max.  */
#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif
#ifndef MAX
#define MAX(a,b) (((a)>(b))?(a):(b))
#endif

/* Fast arithmetic, relying on powers of 2, */
#define MOD(x, y)		((x) & ((y) - 1))

#define RETURN_ERROR(ERR, LOC)	{ save_errno = ERR; goto LOC; }

/* Return values */
#define	SUCCESS	 (0)
#define	ERROR	(-1)
#define	ABNORMAL (1)

#ifdef HASH_STATISTICS
int hash_accesses, hash_collisions, hash_expansions, hash_overflows;
#endif

/************************** INTERFACE ROUTINES ***************************/
/* OPEN/CLOSE */

extern DB *
_DEFUN(__hash_open, (file, flags, mode, info, dflags),
	const char *file _AND
	int flags _AND
	int mode _AND
	int dflags _AND
	const HASHINFO *info)	/* Special directives for create */
{
	HTAB *hashp;

#ifdef __USE_INTERNAL_STAT64
        struct stat64 statbuf;
#else
	struct stat statbuf;
#endif
	DB *dbp;
	int bpages, hdrsize, new_table, nsegs, save_errno;

	if ((flags & O_ACCMODE) == O_WRONLY) {
		errno = EINVAL;
		return (NULL);
	}

	if (!(hashp = (HTAB *)calloc(1, sizeof(HTAB))))
		return (NULL);
	hashp->fp = -1;

	/*
	 * Even if user wants write only, we need to be able to read
	 * the actual file, so we need to open it read/write. But, the
	 * field in the hashp structure needs to be accurate so that
	 * we can check accesses.
	 */
	hashp->flags = flags;

	new_table = 0;
	if (!file || (flags & O_TRUNC) ||
#ifdef __USE_INTERNAL_STAT64
	    (_stat64(file, &statbuf) && (errno == ENOENT))) {
#else
	    (stat(file, &statbuf) && (errno == ENOENT))) {
#endif
		if (errno == ENOENT)
			errno = 0; /* Just in case someone looks at errno */
		new_table = 1;
	}
	if (file) {
		if ((hashp->fp = open(file, flags, mode)) == -1)
			RETURN_ERROR(errno, error0);

		/* if the .db file is empty, and we had permission to create
		   a new .db file, then reinitialize the database */
		if ((flags & O_CREAT) &&
#ifdef __USE_INTERNAL_STAT64
		     _fstat64(hashp->fp, &statbuf) == 0 && statbuf.st_size == 0)
#else
		     fstat(hashp->fp, &statbuf) == 0 && statbuf.st_size == 0)
#endif
			new_table = 1;

#ifdef HAVE_FCNTL
		(void)fcntl(hashp->fp, F_SETFD, 1);
#endif
	}
	if (new_table) {
		if (!(hashp = init_hash(hashp, file, (HASHINFO *)info)))
			RETURN_ERROR(errno, error1);
	} else {
		/* Table already exists */
		if (info && info->hash)
			hashp->hash = info->hash;
		else
			hashp->hash = __default_hash;

		hdrsize = read(hashp->fp, &hashp->hdr, sizeof(HASHHDR));
#if (BYTE_ORDER == LITTLE_ENDIAN)
		swap_header(hashp);
#endif
		if (hdrsize == -1)
			RETURN_ERROR(errno, error1);
		if (hdrsize != sizeof(HASHHDR))
			RETURN_ERROR(EFTYPE, error1);
		/* Verify file type, versions and hash function */
		if (hashp->MAGIC != HASHMAGIC)
			RETURN_ERROR(EFTYPE, error1);
#define	OLDHASHVERSION	1
		if (hashp->HASH_VERSION != HASHVERSION &&
		    hashp->HASH_VERSION != OLDHASHVERSION)
			RETURN_ERROR(EFTYPE, error1);
		if (hashp->hash(CHARKEY, sizeof(CHARKEY)) != hashp->H_CHARKEY)
			RETURN_ERROR(EFTYPE, error1);
		/*
		 * Figure out how many segments we need.  Max_Bucket is the
		 * maximum bucket number, so the number of buckets is
		 * max_bucket + 1.
		 */
		nsegs = (hashp->MAX_BUCKET + 1 + hashp->SGSIZE - 1) /
			 hashp->SGSIZE;
		hashp->nsegs = 0;
		if (alloc_segs(hashp, nsegs))
			/*
			 * If alloc_segs fails, table will have been destroyed
			 * and errno will have been set.
			 */
			return (NULL);
		/* Read in bitmaps */
		bpages = (hashp->SPARES[hashp->OVFL_POINT] +
		    (hashp->BSIZE << BYTE_SHIFT) - 1) >>
		    (hashp->BSHIFT + BYTE_SHIFT);

		hashp->nmaps = bpages;
		(void)memset(&hashp->mapp[0], 0, bpages * sizeof(__uint32_t *));
	}

	/* Initialize Buffer Manager */
	if (info && info->cachesize)
		__buf_init(hashp, info->cachesize);
	else
		__buf_init(hashp, DEF_BUFSIZE);

	hashp->new_file = new_table;
	hashp->save_file = file && (hashp->flags & O_RDWR);
	hashp->cbucket = -1;
	if (!(dbp = (DB *)malloc(sizeof(DB)))) {
		save_errno = errno;
		hdestroy(hashp);
		errno = save_errno;
		return (NULL);
	}
	dbp->internal = hashp;
	dbp->close = hash_close;
	dbp->del = hash_delete;
	dbp->fd = hash_fd;
	dbp->get = hash_get;
	dbp->put = hash_put;
	dbp->seq = hash_seq;
	dbp->sync = hash_sync;
	dbp->type = DB_HASH;

#ifdef DEBUG
	(void)fprintf(stderr,
"%s\n%s%x\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%x\n%s%x\n%s%d\n%s%d\n",
	    "init_htab:",
	    "TABLE POINTER   ", hashp,
	    "BUCKET SIZE     ", hashp->BSIZE,
	    "BUCKET SHIFT    ", hashp->BSHIFT,
	    "DIRECTORY SIZE  ", hashp->DSIZE,
	    "SEGMENT SIZE    ", hashp->SGSIZE,
	    "SEGMENT SHIFT   ", hashp->SSHIFT,
	    "FILL FACTOR     ", hashp->FFACTOR,
	    "MAX BUCKET      ", hashp->MAX_BUCKET,
	    "OVFL POINT	     ", hashp->OVFL_POINT,
	    "LAST FREED      ", hashp->LAST_FREED,
	    "HIGH MASK       ", hashp->HIGH_MASK,
	    "LOW  MASK       ", hashp->LOW_MASK,
	    "NSEGS           ", hashp->nsegs,
	    "NKEYS           ", hashp->NKEYS);
#endif
#ifdef HASH_STATISTICS
	hash_overflows = hash_accesses = hash_collisions = hash_expansions = 0;
#endif
	return (dbp);

error1:
	if (hashp != NULL)
		(void)close(hashp->fp);

error0:
	free(hashp);
	errno = save_errno;
	return (NULL);
}

static int
hash_close(dbp)
	DB *dbp;
{
	HTAB *hashp;
	int retval;

	if (!dbp)
		return (ERROR);

	hashp = (HTAB *)dbp->internal;
	retval = hdestroy(hashp);
	free(dbp);
	return (retval);
}

static int
hash_fd(dbp)
	const DB *dbp;
{
	HTAB *hashp;

	if (!dbp)
		return (ERROR);

	hashp = (HTAB *)dbp->internal;
	if (hashp->fp == -1) {
		errno = ENOENT;
		return (-1);
	}
	return (hashp->fp);
}

/************************** LOCAL CREATION ROUTINES **********************/
static HTAB *
init_hash(hashp, file, info)
	HTAB *hashp;
	const char *file;
	const HASHINFO *info;
{
#ifdef __USE_INTERNAL_STAT64
        struct stat64 statbuf;
#else
	struct stat statbuf;
#endif
	int nelem;

	nelem = 1;
	hashp->NKEYS = 0;
       hashp->LORDER = DB_BYTE_ORDER;
	hashp->BSIZE = DEF_BUCKET_SIZE;
	hashp->BSHIFT = DEF_BUCKET_SHIFT;
	hashp->SGSIZE = DEF_SEGSIZE;
	hashp->SSHIFT = DEF_SEGSIZE_SHIFT;
	hashp->DSIZE = DEF_DIRSIZE;
	hashp->FFACTOR = DEF_FFACTOR;
	hashp->hash = __default_hash;
	memset(hashp->SPARES, 0, sizeof(hashp->SPARES));
	memset(hashp->BITMAPS, 0, sizeof (hashp->BITMAPS));

	/* Fix bucket size to be optimal for file system */
	if (file != NULL) {
#ifdef __USE_INTERNAL_STAT64
		if (_stat64(file, &statbuf))
#else
		if (stat(file, &statbuf))
#endif
			return (NULL);
		hashp->BSIZE = statbuf.st_blksize;
		hashp->BSHIFT = __log2(hashp->BSIZE);
	}

	if (info) {
		if (info->bsize) {
			/* Round pagesize up to power of 2 */
			hashp->BSHIFT = __log2(info->bsize);
			hashp->BSIZE = 1 << hashp->BSHIFT;
			if (hashp->BSIZE > MAX_BSIZE) {
				errno = EINVAL;
				return (NULL);
			}
		}
		if (info->ffactor)
			hashp->FFACTOR = info->ffactor;
		if (info->hash)
			hashp->hash = info->hash;
		if (info->nelem)
			nelem = info->nelem;
		if (info->lorder) {
                       if (info->lorder != DB_BIG_ENDIAN &&
                           info->lorder != DB_LITTLE_ENDIAN) {
				errno = EINVAL;
				return (NULL);
			}
			hashp->LORDER = info->lorder;
		}
	}
	/* init_htab should destroy the table and set errno if it fails */
	if (init_htab(hashp, nelem))
		return (NULL);
	else
		return (hashp);
}
/*
 * This calls alloc_segs which may run out of memory.  Alloc_segs will destroy
 * the table and set errno, so we just pass the error information along.
 *
 * Returns 0 on No Error
 */
static int
init_htab(hashp, nelem)
	HTAB *hashp;
	int nelem;
{
	int nbuckets, nsegs;
	int l2;

	/*
	 * Divide number of elements by the fill factor and determine a
	 * desired number of buckets.  Allocate space for the next greater
	 * power of two number of buckets.
	 */
	nelem = (nelem - 1) / hashp->FFACTOR + 1;

	l2 = __log2(MAX(nelem, 2));
	nbuckets = 1 << l2;

	hashp->SPARES[l2] = l2 + 1;
	hashp->SPARES[l2 + 1] = l2 + 1;
	hashp->OVFL_POINT = l2;
	hashp->LAST_FREED = 2;

	/* First bitmap page is at: splitpoint l2 page offset 1 */
	if (__ibitmap(hashp, OADDR_OF(l2, 1), l2 + 1, 0))
		return (-1);

	hashp->MAX_BUCKET = hashp->LOW_MASK = nbuckets - 1;
	hashp->HIGH_MASK = (nbuckets << 1) - 1;
	hashp->HDRPAGES = ((MAX(sizeof(HASHHDR), MINHDRSIZE) - 1) >>
	    hashp->BSHIFT) + 1;

	nsegs = (nbuckets - 1) / hashp->SGSIZE + 1;
	nsegs = 1 << __log2(nsegs);

	if (nsegs > hashp->DSIZE)
		hashp->DSIZE = nsegs;
	return (alloc_segs(hashp, nsegs));
}

/********************** DESTROY/CLOSE ROUTINES ************************/

/*
 * Flushes any changes to the file if necessary and destroys the hashp
 * structure, freeing all allocated space.
 */
static int
hdestroy(hashp)
	HTAB *hashp;
{
	int i, save_errno;

	save_errno = 0;

#ifdef HASH_STATISTICS
	(void)fprintf(stderr, "hdestroy: accesses %ld collisions %ld\n",
	    hash_accesses, hash_collisions);
	(void)fprintf(stderr, "hdestroy: expansions %ld\n",
	    hash_expansions);
	(void)fprintf(stderr, "hdestroy: overflows %ld\n",
	    hash_overflows);
	(void)fprintf(stderr, "keys %ld maxp %d segmentcount %d\n",
	    hashp->NKEYS, hashp->MAX_BUCKET, hashp->nsegs);

	for (i = 0; i < NCACHED; i++)
		(void)fprintf(stderr,
		    "spares[%d] = %d\n", i, hashp->SPARES[i]);
#endif
	/*
	 * Call on buffer manager to free buffers, and if required,
	 * write them to disk.
	 */
	if (__buf_free(hashp, 1, hashp->save_file))
		save_errno = errno;
	if (hashp->dir) {
		free(*hashp->dir);	/* Free initial segments */
		/* Free extra segments */
		while (hashp->exsegs--)
			free(hashp->dir[--hashp->nsegs]);
		free(hashp->dir);
	}
	if (flush_meta(hashp) && !save_errno)
		save_errno = errno;
	/* Free Bigmaps */
	for (i = 0; i < hashp->nmaps; i++)
		if (hashp->mapp[i])
			free(hashp->mapp[i]);

	if (hashp->fp != -1)
		(void)close(hashp->fp);

	free(hashp);

	if (save_errno) {
		errno = save_errno;
		return (ERROR);
	}
	return (SUCCESS);
}
/*
 * Write modified pages to disk
 *
 * Returns:
 *	 0 == OK
 *	-1 ERROR
 */
static int
hash_sync(dbp, flags)
	const DB *dbp;
	u_int flags;
{
	HTAB *hashp;

	if (flags != 0) {
		errno = EINVAL;
		return (ERROR);
	}

	if (!dbp)
		return (ERROR);

	hashp = (HTAB *)dbp->internal;
	if (!hashp->save_file)
		return (0);
	if (__buf_free(hashp, 0, 1) || flush_meta(hashp))
		return (ERROR);
	hashp->new_file = 0;
	return (0);
}

/*
 * Returns:
 *	 0 == OK
 *	-1 indicates that errno should be set
 */
static int
flush_meta(hashp)
	HTAB *hashp;
{
	HASHHDR *whdrp;
#if (BYTE_ORDER == LITTLE_ENDIAN)
	HASHHDR whdr;
#endif
	int fp, i, wsize;

	if (!hashp->save_file)
		return (0);
	hashp->MAGIC = HASHMAGIC;
	hashp->HASH_VERSION = HASHVERSION;
	hashp->H_CHARKEY = hashp->hash(CHARKEY, sizeof(CHARKEY));

	fp = hashp->fp;
	whdrp = &hashp->hdr;
#if (BYTE_ORDER == LITTLE_ENDIAN)
	whdrp = &whdr;
	swap_header_copy(&hashp->hdr, whdrp);
#endif
	if ((lseek(fp, (off_t)0, SEEK_SET) == -1) ||
	    ((wsize = write(fp, whdrp, sizeof(HASHHDR))) == -1))
		return (-1);
	else
		if (wsize != sizeof(HASHHDR)) {
			errno = EFTYPE;
			hashp->error = errno;
			return (-1);
		}
	for (i = 0; i < NCACHED; i++)
		if (hashp->mapp[i])
			if (__put_page(hashp, (char *)hashp->mapp[i],
				hashp->BITMAPS[i], 0, 1))
				return (-1);
	return (0);
}

/*******************************SEARCH ROUTINES *****************************/
/*
 * All the access routines return
 *
 * Returns:
 *	 0 on SUCCESS
 *	 1 to indicate an external ERROR (i.e. key not found, etc)
 *	-1 to indicate an internal ERROR (i.e. out of memory, etc)
 */
static int
hash_get(dbp, key, data, flag)
	const DB *dbp;
	const DBT *key;
	DBT *data;
	u_int flag;
{
	HTAB *hashp;

	hashp = (HTAB *)dbp->internal;
	if (flag) {
		hashp->error = errno = EINVAL;
		return (ERROR);
	}
	return (hash_access(hashp, HASH_GET, (DBT *)key, data));
}

static int
hash_put(dbp, key, data, flag)
	const DB *dbp;
	DBT *key;
	const DBT *data;
	u_int flag;
{
	HTAB *hashp;

	hashp = (HTAB *)dbp->internal;
	if (flag && flag != R_NOOVERWRITE) {
		hashp->error = EINVAL;
		errno = EINVAL;
		return (ERROR);
	}
	if ((hashp->flags & O_ACCMODE) == O_RDONLY) {
		hashp->error = errno = EPERM;
		return (ERROR);
	}
	return (hash_access(hashp, flag == R_NOOVERWRITE ?
	    HASH_PUTNEW : HASH_PUT, (DBT *)key, (DBT *)data));
}

static int
hash_delete(dbp, key, flag)
	const DB *dbp;
	const DBT *key;
	u_int flag;		/* Ignored */
{
	HTAB *hashp;

	hashp = (HTAB *)dbp->internal;
	if (flag && flag != R_CURSOR) {
		hashp->error = errno = EINVAL;
		return (ERROR);
	}
	if ((hashp->flags & O_ACCMODE) == O_RDONLY) {
		hashp->error = errno = EPERM;
		return (ERROR);
	}
	return (hash_access(hashp, HASH_DELETE, (DBT *)key, NULL));
}

/*
 * Assume that hashp has been set in wrapper routine.
 */
static int
hash_access(hashp, action, key, val)
	HTAB *hashp;
	ACTION action;
	DBT *key, *val;
{
	BUFHEAD *rbufp;
	BUFHEAD *bufp, *save_bufp;
	__uint16_t *bp;
	int n, ndx, off, size;
	char *kp;
	__uint16_t pageno;

#ifdef HASH_STATISTICS
	hash_accesses++;
#endif

	off = hashp->BSIZE;
	size = key->size;
	kp = (char *)key->data;
	rbufp = __get_buf(hashp, __call_hash(hashp, kp, size), NULL, 0);
	if (!rbufp)
		return (ERROR);
	save_bufp = rbufp;

	/* Pin the bucket chain */
	rbufp->flags |= BUF_PIN;
	for (bp = (__uint16_t *)rbufp->page, n = *bp++, ndx = 1; ndx < n;)
		if (bp[1] >= REAL_KEY) {
			/* Real key/data pair */
			if (size == off - *bp &&
			    memcmp(kp, rbufp->page + *bp, size) == 0)
				goto found;
			off = bp[1];
#ifdef HASH_STATISTICS
			hash_collisions++;
#endif
			bp += 2;
			ndx += 2;
		} else if (bp[1] == OVFLPAGE) {
			rbufp = __get_buf(hashp, *bp, rbufp, 0);
			if (!rbufp) {
				save_bufp->flags &= ~BUF_PIN;
				return (ERROR);
			}
			/* FOR LOOP INIT */
			bp = (__uint16_t *)rbufp->page;
			n = *bp++;
			ndx = 1;
			off = hashp->BSIZE;
		} else if (bp[1] < REAL_KEY) {
			if ((ndx =
			    __find_bigpair(hashp, rbufp, ndx, kp, size)) > 0)
				goto found;
			if (ndx == -2) {
				bufp = rbufp;
				if (!(pageno =
				    __find_last_page(hashp, &bufp))) {
					ndx = 0;
					rbufp = bufp;
					break;	/* FOR */
				}
				rbufp = __get_buf(hashp, pageno, bufp, 0);
				if (!rbufp) {
					save_bufp->flags &= ~BUF_PIN;
					return (ERROR);
				}
				/* FOR LOOP INIT */
				bp = (__uint16_t *)rbufp->page;
				n = *bp++;
				ndx = 1;
				off = hashp->BSIZE;
			} else {
				save_bufp->flags &= ~BUF_PIN;
				return (ERROR);
			}
		}

	/* Not found */
	switch (action) {
	case HASH_PUT:
	case HASH_PUTNEW:
		if (__addel(hashp, rbufp, key, val)) {
			save_bufp->flags &= ~BUF_PIN;
			return (ERROR);
		} else {
			save_bufp->flags &= ~BUF_PIN;
			return (SUCCESS);
		}
	case HASH_GET:
	case HASH_DELETE:
	default:
		save_bufp->flags &= ~BUF_PIN;
		return (ABNORMAL);
	}

found:
	switch (action) {
	case HASH_PUTNEW:
		save_bufp->flags &= ~BUF_PIN;
		return (ABNORMAL);
	case HASH_GET:
		bp = (__uint16_t *)rbufp->page;
		if (bp[ndx + 1] < REAL_KEY) {
			if (__big_return(hashp, rbufp, ndx, val, 0))
				return (ERROR);
		} else {
			val->data = (u_char *)rbufp->page + (int)bp[ndx + 1];
			val->size = bp[ndx] - bp[ndx + 1];
		}
		break;
	case HASH_PUT:
		if ((__delpair(hashp, rbufp, ndx)) ||
		    (__addel(hashp, rbufp, key, val))) {
			save_bufp->flags &= ~BUF_PIN;
			return (ERROR);
		}
		break;
	case HASH_DELETE:
		if (__delpair(hashp, rbufp, ndx))
			return (ERROR);
		break;
	default:
		abort();
	}
	save_bufp->flags &= ~BUF_PIN;
	return (SUCCESS);
}

static int
hash_seq(dbp, key, data, flag)
	const DB *dbp;
	DBT *key, *data;
	u_int flag;
{
	__uint32_t bucket;
	BUFHEAD *bufp;
	HTAB *hashp;
	__uint16_t *bp, ndx;

	hashp = (HTAB *)dbp->internal;
	if (flag && flag != R_FIRST && flag != R_NEXT) {
		hashp->error = errno = EINVAL;
		return (ERROR);
	}
#ifdef HASH_STATISTICS
	hash_accesses++;
#endif
	if ((hashp->cbucket < 0) || (flag == R_FIRST)) {
		hashp->cbucket = 0;
		hashp->cndx = 1;
		hashp->cpage = NULL;
	}

	for (bp = NULL; !bp || !bp[0]; ) {
		if (!(bufp = hashp->cpage)) {
			for (bucket = hashp->cbucket;
			    bucket <= hashp->MAX_BUCKET;
			    bucket++, hashp->cndx = 1) {
				bufp = __get_buf(hashp, bucket, NULL, 0);
				if (!bufp)
					return (ERROR);
				hashp->cpage = bufp;
				bp = (__uint16_t *)bufp->page;
				if (bp[0])
					break;
			}
			hashp->cbucket = bucket;
			if (hashp->cbucket > hashp->MAX_BUCKET) {
				hashp->cbucket = -1;
				return (ABNORMAL);
			}
		} else
			bp = (__uint16_t *)hashp->cpage->page;

#ifdef DEBUG
		assert(bp);
		assert(bufp);
#endif
		while (bp[hashp->cndx + 1] == OVFLPAGE) {
			bufp = hashp->cpage =
			    __get_buf(hashp, bp[hashp->cndx], bufp, 0);
			if (!bufp)
				return (ERROR);
			bp = (__uint16_t *)(bufp->page);
			hashp->cndx = 1;
		}
		if (!bp[0]) {
			hashp->cpage = NULL;
			++hashp->cbucket;
		}
	}
	ndx = hashp->cndx;
	if (bp[ndx + 1] < REAL_KEY) {
		if (__big_keydata(hashp, bufp, key, data, 1))
			return (ERROR);
	} else {
		key->data = (u_char *)hashp->cpage->page + bp[ndx];
		key->size = (ndx > 1 ? bp[ndx - 1] : hashp->BSIZE) - bp[ndx];
		data->data = (u_char *)hashp->cpage->page + bp[ndx + 1];
		data->size = bp[ndx] - bp[ndx + 1];
		ndx += 2;
		if (ndx > bp[0]) {
			hashp->cpage = NULL;
			hashp->cbucket++;
			hashp->cndx = 1;
		} else
			hashp->cndx = ndx;
	}
	return (SUCCESS);
}

/********************************* UTILITIES ************************/

/*
 * Returns:
 *	 0 ==> OK
 *	-1 ==> Error
 */
extern int
__expand_table(hashp)
	HTAB *hashp;
{
	__uint32_t old_bucket, new_bucket;
	int dirsize, new_segnum, spare_ndx;

#ifdef HASH_STATISTICS
	hash_expansions++;
#endif
	new_bucket = ++hashp->MAX_BUCKET;
	old_bucket = (hashp->MAX_BUCKET & hashp->LOW_MASK);

	new_segnum = new_bucket >> hashp->SSHIFT;

	/* Check if we need a new segment */
	if (new_segnum >= hashp->nsegs) {
		/* Check if we need to expand directory */
		if (new_segnum >= hashp->DSIZE) {
			/* Reallocate directory */
			dirsize = hashp->DSIZE * sizeof(SEGMENT *);
			if (!hash_realloc(&hashp->dir, dirsize, dirsize << 1))
				return (-1);
			hashp->DSIZE = dirsize << 1;
		}
		if ((hashp->dir[new_segnum] =
		    (SEGMENT)calloc(hashp->SGSIZE, sizeof(SEGMENT))) == NULL)
			return (-1);
		hashp->exsegs++;
		hashp->nsegs++;
	}
	/*
	 * If the split point is increasing (MAX_BUCKET's log base 2
	 * * increases), we need to copy the current contents of the spare
	 * split bucket to the next bucket.
	 */
	spare_ndx = __log2(hashp->MAX_BUCKET + 1);
	if (spare_ndx > hashp->OVFL_POINT) {
		hashp->SPARES[spare_ndx] = hashp->SPARES[hashp->OVFL_POINT];
		hashp->OVFL_POINT = spare_ndx;
	}

	if (new_bucket > hashp->HIGH_MASK) {
		/* Starting a new doubling */
		hashp->LOW_MASK = hashp->HIGH_MASK;
		hashp->HIGH_MASK = new_bucket | hashp->LOW_MASK;
	}
	/* Relocate records to the new bucket */
	return (__split_page(hashp, old_bucket, new_bucket));
}

/*
 * If realloc guarantees that the pointer is not destroyed if the realloc
 * fails, then this routine can go away.
 */
static void *
hash_realloc(p_ptr, oldsize, newsize)
	SEGMENT **p_ptr;
	int oldsize, newsize;
{
	void *p;

	if ( (p = malloc(newsize)) ) {
		memmove(p, *p_ptr, oldsize);
		memset((char *)p + oldsize, 0, newsize - oldsize);
		free(*p_ptr);
		*p_ptr = p;
	}
	return (p);
}

extern __uint32_t
__call_hash(hashp, k, len)
	HTAB *hashp;
	char *k;
	int len;
{
	int n, bucket;

	n = hashp->hash(k, len);
	bucket = n & hashp->HIGH_MASK;
	if (bucket > hashp->MAX_BUCKET)
		bucket = bucket & hashp->LOW_MASK;
	return (bucket);
}

/*
 * Allocate segment table.  On error, destroy the table and set errno.
 *
 * Returns 0 on success
 */
static int
alloc_segs(hashp, nsegs)
	HTAB *hashp;
	int nsegs;
{
	int i;
	SEGMENT store;

	int save_errno;

	if ((hashp->dir =
	    (SEGMENT *)calloc(hashp->DSIZE, sizeof(SEGMENT *))) == NULL) {
		save_errno = errno;
		(void)hdestroy(hashp);
		errno = save_errno;
		return (-1);
	}
	/* Allocate segments */
	if ((store =
	    (SEGMENT)calloc(nsegs << hashp->SSHIFT, sizeof(SEGMENT))) == NULL) {
		save_errno = errno;
		(void)hdestroy(hashp);
		errno = save_errno;
		return (-1);
	}
	for (i = 0; i < nsegs; i++, hashp->nsegs++)
		hashp->dir[i] = &store[i << hashp->SSHIFT];
	return (0);
}

#if (BYTE_ORDER == LITTLE_ENDIAN)
/*
 * Hashp->hdr needs to be byteswapped.
 */
static void
swap_header_copy(srcp, destp)
	HASHHDR *srcp, *destp;
{
	int i;

	P_32_COPY(srcp->magic, destp->magic);
	P_32_COPY(srcp->version, destp->version);
	P_32_COPY(srcp->lorder, destp->lorder);
	P_32_COPY(srcp->bsize, destp->bsize);
	P_32_COPY(srcp->bshift, destp->bshift);
	P_32_COPY(srcp->dsize, destp->dsize);
	P_32_COPY(srcp->ssize, destp->ssize);
	P_32_COPY(srcp->sshift, destp->sshift);
	P_32_COPY(srcp->ovfl_point, destp->ovfl_point);
	P_32_COPY(srcp->last_freed, destp->last_freed);
	P_32_COPY(srcp->max_bucket, destp->max_bucket);
	P_32_COPY(srcp->high_mask, destp->high_mask);
	P_32_COPY(srcp->low_mask, destp->low_mask);
	P_32_COPY(srcp->ffactor, destp->ffactor);
	P_32_COPY(srcp->nkeys, destp->nkeys);
	P_32_COPY(srcp->hdrpages, destp->hdrpages);
	P_32_COPY(srcp->h_charkey, destp->h_charkey);
	for (i = 0; i < NCACHED; i++) {
		P_32_COPY(srcp->spares[i], destp->spares[i]);
		P_16_COPY(srcp->bitmaps[i], destp->bitmaps[i]);
	}
}

static void
swap_header(hashp)
	HTAB *hashp;
{
	HASHHDR *hdrp;
	int i;

	hdrp = &hashp->hdr;

	M_32_SWAP(hdrp->magic);
	M_32_SWAP(hdrp->version);
	M_32_SWAP(hdrp->lorder);
	M_32_SWAP(hdrp->bsize);
	M_32_SWAP(hdrp->bshift);
	M_32_SWAP(hdrp->dsize);
	M_32_SWAP(hdrp->ssize);
	M_32_SWAP(hdrp->sshift);
	M_32_SWAP(hdrp->ovfl_point);
	M_32_SWAP(hdrp->last_freed);
	M_32_SWAP(hdrp->max_bucket);
	M_32_SWAP(hdrp->high_mask);
	M_32_SWAP(hdrp->low_mask);
	M_32_SWAP(hdrp->ffactor);
	M_32_SWAP(hdrp->nkeys);
	M_32_SWAP(hdrp->hdrpages);
	M_32_SWAP(hdrp->h_charkey);
	for (i = 0; i < NCACHED; i++) {
		M_32_SWAP(hdrp->spares[i]);
		M_16_SWAP(hdrp->bitmaps[i]);
	}
}
#endif
@


1.12
log
@	* newlib/libc/search/hash.c: Revert patch from 2012-08-08.
@
text
@d66 1
a66 1
static int   hash_delete(const DB *, const DBT *, __uint32_t);
d68 2
a69 2
static int   hash_get(const DB *, const DBT *, DBT *, __uint32_t);
static int   hash_put(const DB *, DBT *, const DBT *, __uint32_t);
d71 2
a72 2
static int   hash_seq(const DB *, DBT *, DBT *, __uint32_t);
static int   hash_sync(const DB *, __uint32_t);
d497 1
a497 1
	__uint32_t flags;
d576 1
a576 1
	__uint32_t flag;
d593 1
a593 1
	__uint32_t flag;
d615 1
a615 1
	__uint32_t flag;		/* Ignored */
d767 1
a767 1
	__uint32_t flag;
@


1.11
log
@	Throughout, run newlib with -Wall -Werror option and fix bugs and
	compiler warnings found this way.

	* libc/stdio/freopen.c (_freopen_r): Fix bug setting _flags.

	* libc/include/stdio.h (_rename): Define when building newlib.
	* libc/include/sys/signal.h (_kill): Ditto.
	* libc/include/sys/stat.h (_mkdir): Ditto.
	* libc/include/sys/time.h (_gettimeofday): Ditto.
	* libc/include/sys/times.h (_times): Ditto.
	* libc/include/sys/wait.h (_wait): Ditto.
	* libc/locale/lmessages.c (empty): Don't define for Cygwin.
	* libc/locale/lmonetary.c (cnv): Ditto.
	* libc/locale/nl_langinfo.c (nl_langinfo): Ditto for variable s.
	* libc/posix/collate.c: Throughout cast to avoid compiler warning.
	* libc/posix/engine.c (matcher): Initialize dp to avoid compiler
	warning.
	* libc/posix/glob.c: Disable on Cygwin.  Explain why.
	* libc/posix/regcomp.c: Fix "uninitialized" compiler warnings.
	(dissect): Deliberately silence gcc compiler warning.  Add comment to
	explain why.
	* libc/posix/wordexp.c (wordexp): Remove num_bytes variable since result
	is never used.
	* libc/posix/popen.c (popen): Ditto for variable last.
	* libc/reent/mkdirr.c: Include sys/stat.h.
	* libc/reent/renamer.c: Include stdio.h.
	* libc/search/hash.c:  Throughout use underscored variants of the stat
	function family.
	(init_hash): Add missing definition for the __USE_INTERNAL_STAT64 case.
	* libc/search/hash_bigkey.c (__big_insert): Add parenthesis to avoid
	compiler warning.
	* libc/search/hash_page.c (overflow_page): Initalize freep to NULL to
	avoid compiler warning.
	* libc/stdio/asiprintf.c (_asiprintf_r): Cast unsigned char * to char *
	to avoid compiler warning.
	(asiprintf): Ditto.
	* libc/stdio/asprintf.c (_asprintf_r): Ditto.
	(asprintf): Ditto.
	* libc/stdio/vasiprintf.c (_vasiprintf_r): Ditto.
	* libc/stdio/vasprintf.c (_vasprintf_r): Ditto.
	* libc/stdio/mktemp.c (_gettemp): Cast to unsigned char in call to
	isdigit to avoid compiler warning.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Initialize variables used for
	grouping to avoid compiler warning.  Only define and set nseps and
	nrepeats if they are really used.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R): Ditto.  Only define state if
	it is really used.
	* libc/stdio/vfscanf.c (u_char): Revert to be defined as unsigned char.
	(__SVFSCANF_R): Cast fmt in call to __mbtowc.
	* libc/stdlib/mbtowc_r.c (JIS_state_table): Disable when building
	Cygwin.
	(JIS_action_table): Ditto.
	* libc/stdlib/wctomb_r.c (__utf8_wctomb): Add parenthesis to avoid
	compiler warning.
	* libc/string/strcasestr.c: Deliberately silence gcc compiler warning.
	Add comment to explain why.
	* libc/time/strptime.c (strptime): Cast to unsigned char in calls to
	isspace to avoid compiler warning.
	* libm/math/e_atan2.c (__ieee754_atan2): Add parenthesis to avoid
	compiler warning.
	* libm/math/e_exp.c (__ieee754_exp): Initialize k to 0 to avoid
	compiler warning.  Drop setting it to 0 later.
	* libm/math/ef_exp.c (__ieee754_expf): Ditto.
	* libm/math/e_pow.c (__ieee754_pow): Add braces to avoid compiler
	warning.
	* libm/math/ef_pow.c (__ieee754_powf): Ditto.
	* libm/math/er_lgamma.c (__ieee754_lgamma_r): Initialize nadj to 0 to
	avoid compiler warning.
	* libm/math/erf_lgamma.c (__ieee754_lgammaf_r): Ditto.
	* libm/math/e_rem_pio2.c (__ieee754_rem_pio2): Ditto for variable z.
	* libm/common/sf_round.c (roundf): Remove signbit variable since result
	is never used.
@
text
@d146 1
a146 1
	    (_stat(file, &statbuf) && (errno == ENOENT))) {
d162 1
a162 1
		     _fstat(hashp->fp, &statbuf) == 0 && statbuf.st_size == 0)
d344 1
a344 1
		if (_stat(file, &statbuf))
@


1.11.2.1
log
@Pull in changes from HEAD
@
text
@d146 1
a146 1
	    (stat(file, &statbuf) && (errno == ENOENT))) {
d162 1
a162 1
		     fstat(hashp->fp, &statbuf) == 0 && statbuf.st_size == 0)
d344 1
a344 1
		if (stat(file, &statbuf))
@


1.10
log
@	* libm/math/ef_sqrt.c: Delete unused variable sign.
	* libc/stdlib/getenv.c: Delete "char *_findenv_r ();", as is not a
	proper prototype, and is properly prototyped in stdlib.h, anyway.
	* libc/stdlib/getenv_r.c: Ditto.
	* libc/search/hash.c: Add _DEFUN to __hash_open() declaration; add
	#define __DBINTERFACE_PRIVATE to activate prototypes from db_local.h.
	* libc/search/db_local.h: Correct __hash_open() prototype.
	* libc/sys/linux/cmath/math_private.h:  Eliminate compiler warnings:
	Remove #define INFINITY (redefines from math.h); remove #define __isnanf
	and #define __isinff isinff.
@
text
@d144 1
a144 1
	    (stat64(file, &statbuf) && (errno == ENOENT))) {
d146 1
a146 1
	    (stat(file, &statbuf) && (errno == ENOENT))) {
d160 1
a160 1
		     fstat64(hashp->fp, &statbuf) == 0 && statbuf.st_size == 0)
d162 1
a162 1
		     fstat(hashp->fp, &statbuf) == 0 && statbuf.st_size == 0)
d319 3
d323 1
d342 1
a342 1
		if (stat64(file, &statbuf))
d344 1
a344 1
		if (stat(file, &statbuf))
@


1.9
log
@* libc/stdlib/wctomb_r.c (_wctomb_r): Avoid gcc warnings on cygwin.
* libc/search/hash.c (__hash_open): Likewise.
@
text
@d56 1
d107 6
a112 4
__hash_open(file, flags, mode, info, dflags)
	const char *file;
	int flags, mode, dflags;
	const HASHINFO *info;	/* Special directives for create */
@


1.8
log
@	* libc/search/hash.c (init_hash): Make `info' parameter const.
@
text
@d113 3
d117 1
@


1.7
log
@
2004-05-26  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/search/hash_buf.c: Protect MAX and MIN macros from
        redefinition.
        * libc/search/hash.c: Ditto.
@
text
@d73 1
a73 1
static HTAB *init_hash(HTAB *, const char *, HASHINFO *);
d310 1
a310 1
	HASHINFO *info;
@


1.7.6.1
log
@2007-10-23  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/stdlib/wcstombs_r.c: Add SUSV2 support for calculating
	size if output buffer is NULL.

2007-10-13  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R) [__OPTIMIZE_SIZE__]:
	Correctly nest else within conditionals.
	Reported by Artur Lipowski.

2007-09-17  Eric Blake  <ebb9@@byu.net>

	Obey POSIX on printf("%.s", (char*)NULL).
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Take precision into account
	for %s on NULL.  Skip NULL check when optimizing for size.

2007-07-31  Eric Blake  <ebb9@@byu.net>

	More POSIX stream corner cases.
	* libc/stdio/findfp.c (__sinit): Open stderr read/write.
	* libc/stdio/fdopen.c (_fdopen_r): Set O_APPEND on fd when
	requested.
	* libc/stdio64/fdopen64.c (_fdopen64_r): Likewise.

2007-07-13  Eric Blake  <ebb9@@byu.net>

	Fix fflush issues.
	* libc/stdio/fflush.c (_fflush_r): New function.
	(fflush): Fix reentrancy and large offset behavior.
	* libc/include/stdio.h (_fflush_r): Add prototype.
	* libc/stdio/fclose.c (_fclose_r): All fflush callers changed.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/fseek.c (_fseek_r): Likewise.
	* libc/stdio/ftell.c (_ftell_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Likewise.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/setvbuf.c (setvbuf): Likewise.
	* libc/stdio/ungetc.c (_ungetc_r): Likewise.
	* libc/stdio/vfprintf.c (__sbprintf): Likewise.
	* libc/stdio/wbuf.c (__swbuf_r): Likewise.
	* libc/stdio64/freopen64.c (_freopen64_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.  Defer to
	32-bit version if not large file.
	* libc/stdio64/ftello64.c (_ftello64_r): Likewise.
	* libc/stdio64/tmpfile64.c (_tmpfile64_r): Avoid compile warning.

2007-06-04  Eric Blake  <ebb9@@byu.net>

	* libc/include/sys/reent.h (struct __sFILE, struct __sFILE64):
	Switch to reentrant callbacks.
	* libc/stdio/local.h (__sread, __swrite, __sseek, __sclose)
	(__sseek64, __swrite64): Fix prototypes.
	[__SCLE]: Pull in setmode declaration.
	* libc/stdio/stdio.c (__sread, __swrite, __sseek, __sclose): Fix
	reentrancy.
	* libc/stdio64/stdio64.c (__sseek64_r, __swrite64_r): Delete.
	(__sseek64, __swrite64): Fix reentrancy.
	* libc/stdio/fseek.c (_fseek_r): Account for overflow, and fix
	reentrancy.
	* libc/stdio/ftell.c (_ftell_r): Likewise.
	* libc/stdio/flags.c (__sflags): Don't lose __SAPP on "a+".
	* libc/stdio/fclose.c (_fclose_r): Fix reentrancy.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Likewise.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/siscanf.c (eofread): Likewise.
	* libc/stdio/sscanf.c (eofread): Likewise.
	* libc/stdio/vsiscanf.c (eofread1): Likewise.
	* libc/stdio/vsscanf.c (eofread1): Likewise.
	* libc/stdio64/freopen64.c (_freopen64_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.
	* libc/stdio64/ftello64.c (_ftello64_r): Likewise.
	* libc/stdio/fflush.c (fflush): Improve reentrancy, although more
	could be fixed.

2007-05-29  Eric Blake  <ebb9@@byu.net>

	Avoid more compiler warnings.
	* libc/stdlib/btowc.c: Add missing header.
	* libc/stdlib/getopt.c (getopt_internal): Initialize variable.
	* libc/stdlib/system.c (do_system) [__CYGWIN__]: Add declaration.
	* libc/stdlib/wctob.c: Add missing header.
	* libc/string/strcpy.c (strcpy): Avoid warnings.
	* libc/string/strrchr.c (strrchr): Likewise.

2007-05-29  Corinna Vinschen  <corinna@@vinschen.de>

	* libc/argz/argz_add_sep.c (argz_add_sep): Handle empty string
	argument.
	* libc/argz/argz_append.c (argz_append): Handle empty buf argument.
	* libc/argz/argz_create_sep.c (argz_create_sep): Return (NULL, 0)
	on empty input strings.
	* libc/argz/argz_extract.c (argz_extract): Check argz_len before
	looping through argz.
	* libc/argz/argz_stringify.c (argz_stringify): Ditto.

2007-05-27  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Populate 'ox' when
	handling %p.

2007-05-25  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/rewind.c (rewind): Fix regression of 2003-08-22.

2007-05-23  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't truncate %p when
	sizeof(void*) is 8 but sizeof(long) is 4.
	* libc/stdio/vfscanf.c (__SVFSCANF_R): Likewise.  Fix %i scanning
	of "-0x".  Support "-nan" and "inf" for %e.  Audit usage of ungetc
	to fix reentrancy and bug on encoding error in multibyte locales.
	Always return EOF on read error.

2007-05-23  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfscanf.c (__SVFSCANF_R): Support scanf(%1$s).
	Avoid warning when !FLOATING_POINT.
	* libc/stdio/vfprintf.c (_VFPRINTF_R): Simplify _NO_POS_ARGS
	slightly.

2007-05-23  Corinna Vinschen  <vinschen@@redhat.com>

	* libc/argz/argz_create_sep.c (argz_create_sep): Initialize *argz_len
	to zero.
	* libc/include/argz.h: Guard against multiple inclusion.  Guard for
	use with C++.

2007-05-17  Charles Wilson  <cygwin@@...>

	* stdio/tmpfile.c: Include <sys/stat.h>.
	* stdio64/tmpfile64.c: Ditto.

2007-05-16  Eric Blake  <ebb9@@byu.net>

	Close security hole in tmpfile.
	* libc/stdio/tmpfile.c (_tmpfile_r): Avoid window between filename
	generation and opening the fd.
	* libc/stdio64/tmpfile64.c (_tmpfile64_r): Likewise.

	* libc/include/math.h (INFINITY, NAN, FP_ILOGB0, FP_ILOGBNAN)
	(MATH_ERRNO, MATH_ERREXCEPT, math_errhandling): Add macros
	required by POSIX.
	* libc/stdlib/ldtoa.c (USE_INFINITY): Rename from INFINITY, to
	avoid clash with <math.h>.

	* libc/stdlib/wctomb_r.c (_wctomb_r): Avoid gcc warnings on cygwin.
	* libc/search/hash.c (__hash_open): Likewise.

2007-05-10  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Fix use of decimal point
	in %f and %e.  Avoid malloc when possible for %S.
	(BUF): Improve stack locality by using smaller size.
	(MAXEXP): Define.
	(exponent): Use for smaller stack size.

2007-05-01  Eric Blake  <ebb9@@byu.net>

	* libc/stdio64/local64.h: Delete, move contents to...
	* libc/stdio/local.h: ...here.
	* libc/stdio64/fdopen64.c: Update includes.
	* libc/stdio64/fopen64.c: Likewise.
	* libc/stdio64/freopen64.c: Likewise.
	* libc/stdio64/fseeko64.c: Likewise.
	* libc/stdio64/ftello64.c: Likewise.
	* libc/stdio/findfp.c (std) [__LARGE64_FILES]: Open stdin, stdout,
	and stderr with 64-bit offset.
	* libc/stdio/fseek.c (_fseek_r): Avoid compile warning.
	* libc/stdio/makebuf.c (__smakebuf_r): Likewise.
	* libc/stdio/mktemp.c (_gettemp): Likewise.

2007-04-25  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (get_arg): Support %1$lc.  Simplify types
	that promote to int.

2007-04-24  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Don't zero pad on infinity
	or NaN with %05f.

	* libc/stdio/vfprintf.c (_VFPRINTF_R): Avoid multibyte when not
	_MB_CAPABLE.

	* libc/include/limits.h (NL_ARGMAX): Define a default value.
	* libc/stdio/vfprintf.c (MAX_POS_ARGS): Define in terms of
	NL_ARGMAX, if present.

2007-04-23  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/vfprintf.c (_vfprintf_r): When the alternate-form flag
	has been specified with types 'f', 'F', 'g', or 'G', ensure the
	trailing decimal is printed.

2007-04-17  Brian Dessent  <brian@@dessent.net>

	* libc/stdio/sscanf.c: Update documentation comments.
	* libc/stdio/vfscanf.c (__SVFSCANF_R): Handle j, t, and z modifiers.

2007-04-12  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/vfprintf.c (_VFPRINTF_F, cvt): Don't confuse %F with %e.
	(chclass): Recognize 'F', 'X', 'n', and not 'W'.
	(get_arg): Handle %1$F, %1$n.

2007-04-10  Eric Blake  <ebb9@@byu.net>

	* libc/include/stdio.h (_ELIDABLE_INLINE): Work even when using
	CFLAGS=-O0.

2007-04-09  Eric Blake  <ebb9@@byu.net>

	* libc/include/stdio.h: Add gcc format attributes to printf and
	scanf families.

2007-04-04  Jeff Johnston  <jjohnstn@@redhat.com>

	* libc/argz/argz_insert.c: Add stddef.h to get ptrdiff_t type.

2007-04-04  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/asiprintf.c (_asiprintf_r): Fix reentrancy.
	(asiprintf): Avoid overhead.
	* libc/stdio/asprintf.c (_asprintf_r): Fix reentrancy.
	(asprintf): Avoid overhead.
	* libc/stdio/diprintf.c (_diprintf_r, diprintf): New file.
	* libc/stdio/dprintf.c (_dprintf_r, dprintf): Use _DEFUN.
	* libc/stdio/fiprintf.c (_fiprintf_r): Add reentrant version.
	(fiprintf): Avoid overhead.
	* libc/stdio/fprintf.c (_fprintf_r): Add reentrant version.
	(fprintf): Avoid overhead.
	* libc/stdio/iprintf.c (_iprintf_r): Use _DEFUN.
	(iprintf): Avoid overhead.
	* libc/stdio/printf.c (_printf_r): Use _DEFUN.
	(printf): Avoid overhead.
	* libc/stdio/vasiprintf.c (vasiprintf): Reduce binary size.
	* libc/stdio/vasprintf.c (vasprintf): Reduce binary size.
	* libc/stdio/vdiprintf.c (_vdiprintf_r, vdiprintf): New file.
	* libc/stdio/vdprintf.c (vdprintf): Avoid overhead.
	* libc/stdio/vsiprintf.c (vsiprintf): Reduce binary size.
	* libc/stdio/vsniprintf.c (vsniprintf): Reduce binary size.
	* libc/stdio/vsnprintf.c (vsnprintf): Reduce binary size.
	* libc/stdio/vsprintf.c (vsprintf): Reduce binary size.
	* libc/stdio/Makefile.am (GENERAL_SOURCES): Add diprintf.c,
	vdiprintf.c.
	* libc/include/stdio.h (diprintf, _diprintf_r, vdiprintf)
	(_vdiprintf_r, _fiprintf_r, _vfiprintf_r): Add prototypes.

2007-03-30  Dave Korn  <dave.korn@@artimi.com>

	* libc/include/stdio.h (_ELIDABLE_INLINE):  New macro to conceal
	conflicting inline semantics between C99 and GNU89.
	(__sgetc_r):  Replace static inline with _ELIDABLE_INLINE to be
	compatible with -fkeep-inline-functions usage.
	(__sputc_r):  Likewise for consistency even though disabled.

2007-03-16  Charles Wilson  <cygwin@@...>

	* libc/argz/argz_insert.c: "before" pointer is
	invalid after *argz realloc.  Compute offset
	between "before" and *argz, and use it after
	reallocation instead.

2007-03-16  Eric Blake  <ebb9@@byu.net>

	* libc/stdio64/fseek064.c (_fseeko64_r): Fix reentrancy.
	* libc/stdio64/freopen64.c (_freopen64_r): Ditto.

2007-03-15  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/local.h (cantwrite, FREEUB, FREELB): Make reentrant.
	(__smakebuf): Rename...
	(__smakebuf_r): to this.
	* libc/stdio/fvwrite.h (__swsetup_r): Rename, from __swsetup.
	* libc/stdio/makebuf.c (__smakebuf): Detect failed asprint
	allocation, then rename...
	(__smakebuf_r): ...to this and fix reentrancy.
	* libc/stdio/wsetup.c (__swsetup): Detect failed asprintf
	allocation, then rename...
	(__swsetup_r): ...to this and fix reentrancy.
	* libc/stdio/fseek.c (_fseek_r): Fix reentrancy.
	* libc/stdio/refill.c (__srefill_r): Likewise.
	* libc/stdio/fclose.c (_fclose_r): Likewise.
	* libc/stdio/fread.c (_fread_r): Likewise.
	* libc/stdio/freopen.c (_freopen_r): Likewise.
	* libc/stdio/wbuf.c (__swbuf_r): Likewise.
	* libc/stdio64/fseeko64.c (_fseeko64_r): Likewise.
	* libc/stdio/fvwrite.c (__sfvwrite_r): Set errno properly on
	failed asprintf allocation, and fix reentrancy.
	* libc/stdio/snprintf.c (snprintf, _snprintf_r): Report overflow,
	as required by POSIX.
	* libc/stdio/sniprintf.c (sniprintf, _sniprintf_r): Likewise.
	* libc/stdio/vsnprintf.c (vsnprintf, _vsnprintf_r): Likewise.
	* libc/stdio/vsniprintf.c (vsniprintf, _vsniprintf_r): Likewise.

2007-03-12  Eric Blake  <ebb9@@byu.net>

	* libc/stdio/fvwrite.c (__sfvwrite_r): Fix reentrancy.
	* libc/stdio/vasprintf.c (vasprintf, _vasprintf_r): Pass failed
	allocation to caller.
	* libc/stdio/asprintf.c (_asprintf_r, asprintf): Likewise.
	* libc/stdio/asiprintf.c (_asiprintf_r, asiprintf): Likewise.
	* libc/stdio/vasiprintf.c (vasiprintf, _vasiprintf_r): Likewise.

2007-02-20  Kazunori Asayama <asayama@@sm.sony.co.jp>

	* libc/include/stdio.h: Add declaration for vsiprintf.
@
text
@a112 3
#ifdef __USE_INTERNAL_STAT64
        struct stat64 statbuf;
#else
a113 1
#endif
@


1.6
log
@	* libc/locale/ldpart.c (__part_load_locale): Substitute
	__CYGWIN_USE_BIG_TYPES__ by __USE_INTERNAL_STAT64.
	* libc/search/hash.c (__hash_open): Ditto.
	(init_hash): Ditto.
	* libc/stdio/fseek.c (fseek): Ditto.
	* libc/stdio/makebuf.c (__smakebuf): Ditto.
	* libc/stdio/mktemp.c (_gettemp): Ditto.
@
text
@d81 1
d83 2
d86 1
@


1.5
log
@	* configure.host: Accomodate removing the libc/sys/cygwin dir.
	* libc/locale/ldpart.c (__part_load_locale): Use 64 bit stat call
	if __CYGWIN_USE_BIG_TYPES__ is set.
	* libc/search/hash.c (__hash_open): Ditto.
	(init_hash): Ditto.
	* libc/stdio/fseek.c (fseek): Ditto.
	* libc/stdio/makebuf.c (__smakebuf): Ditto.
	* libc/stdio/mktemp.c (_gettemp): Ditto.
	* libc/sys/cygwin/Makefile.am: Remove.
	* libc/sys/cygwin/Makefile.in: Remove.
	* libc/sys/cygwin/aclocal.m4: Remove.
	* libc/sys/cygwin/configure: Remove.
	* libc/sys/cygwin/configure.in: Remove.
	* libc/sys/cygwin/crt0.c: Move to winsup/cygwin directory.
	* libc/sys/cygwin/sys/dirent.h: Move to winsup/cygwin/include/sys
	directory.
	* libc/sys/cygwin/sys/param.h: Ditto.
	* libc/sys/cygwin/sys/utime.h: Ditto.
	* libc/sys/cygwin/sys/utmp.h: Ditto.
@
text
@d132 1
a132 1
#ifdef __CYGWIN_USE_BIG_TYPES__
d148 1
a148 1
#ifdef __CYGWIN_USE_BIG_TYPES__
d326 1
a326 1
#ifdef __CYGWIN_USE_BIG_TYPES__
@


1.4
log
@
2002-09-19  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/posix/opendir.c (opendir): Change code to check
        for HAVE_FCNTL before calling fcntl.
        * libc/search/hash.c (hash_open): Ditto.
        * libc/search/hash_page.c (open_tmp): Ditto.
        * libc/reent/Makefile.am: Add fcntlr.c.
        * libc/reent/Makefile.in: Regenerated.
        * libc/reent/fcntlr.c: New file.
        * libc/stdio/fdopen.c (_fdopen_r): Change to call _fcntl_r
        instead of _fcntl when HAVE_FCNTL flag is set.
        * libc/syscalls/sysfcntl.c (fcntl): Check for HAVE_FCNTL flag
        to see if _fcntl or _fcntl_r should be called.  If flag is not
        set, default to ENOSYS stub.
@
text
@d108 1
d132 3
d136 1
d148 3
d152 1
d326 3
d330 1
@


1.3
log
@
2002-07-02  Chris Demetriou  <cgd@@broadcom.com>

        * libc/include/sys/config.h (__IEEE_LITTLE_ENDIAN)
        (__IEEE_BIG_ENDIAN): Define appropriately for MIPS.
        Check that one of them is defined and error out if not.
        Add any platforms defined in <machine/ieeefp.h> that are missing.
        * libc/search/hash.h (DB_BYTE_ORDER, DB_BIG_ENDIAN)
        (DB_LITTLE_ENDIAN): New defines.
        * libc/search/hash.c: Replace all incorrect checks for
        _IEEE_LITTLE_ENDIAN with tests of BYTE_ORDER, and all uses of
        BYTE_ORDER, LITTLE_ENDIAN, and BIG_ENDIAN with DB_* versions.
        * libc/search/hash_page.c: Likewise.
@
text
@d146 1
d148 1
@


1.2
log
@	* libc/search/db_local.h: New file.
	* libc/include/db.h: Remove.
	* libc/search/Makefile.am (LIB_SOURCES): Add db_local.h.
	* libc/search/hash.c (MIN,MAX): Add macros.  Change <db.h> to
	"db_local.h".
	* libc/search/hash_bigkey.c: Likewise.
	* libc/search/hash_buf.c: Likewise.
	* libc/search/hash_func.c: Likewise.
	* libc/search/hash_log2.c: Likewise.
	* libc/search/hash_page.c: Likewise.
@
text
@d75 1
a75 1
#ifdef _IEEE_LITTLE_ENDIAN
d159 1
a159 1
#ifdef _IEEE_LITTLE_ENDIAN
d302 1
a302 1
	hashp->LORDER = BYTE_ORDER;
d338 2
a339 2
			if (info->lorder != BIG_ENDIAN &&
			    info->lorder != LITTLE_ENDIAN) {
d498 1
a498 1
#ifdef _IEEE_LITTLE_ENDIAN
d511 1
a511 1
#ifdef _IEEE_LITTLE_ENDIAN
d944 1
a944 1
#ifdef _IEEE_LITTLE_ENDIAN
@


1.1
log
@	* Makefile.am (LIB_OBJECTLISTS): Add
	libc/search/objectlist.awk.in.
	* libc/Makefile.am (SUBDIRS): Add search.
	(SUBLIBS): Add search/libsearch.la.
	* libc/configure.in (AC_OUTPUT): Add search/Makefile.
	* libc/search: New directory.
	* libc/search/Makefile.am: New file.
	* libc/search/extern.h: New file.
	* libc/search/hash.c: New file.
	* libc/search/hash.h: New file.
	* libc/search/hash_bigkey.c: New file.
	* libc/search/hash_buf.c: New file.
	* libc/search/hash_func.c: New file.
	* libc/search/hash_log2.c: New file.
	* libc/search/hash_page.c: New file.
	* libc/search/hcreate.3: New file.
	* libc/search/hcreate.c: New file.
	* libc/search/hcreate.c~: New file.
	* libc/search/hcreate_r.c: New file.
	* libc/search/ndbm.c: New file.
	* libc/search/page.h: New file.
	* libc/search/tdelete.c: New file.
	* libc/search/tdestroy.c: New file.
	* libc/search/tfind.c: New file.
	* libc/search/tsearch.3: New file.
	* libc/search/tsearch.c: New file.
	* libc/search/twalk.c: New file.
	* libc/include/db.h: New file.
	* libc/include/ndbm.h: New file.
	* libc/include/search.h: New file.
	* libc/include/sys/queue.h: New file.
	* libc/include/sys/cdefs.h: New file.
	* libc/include/sys/param.h
	[__IEEE_LITTLE_ENDIAN,__IEEE_BIG_ENDIAN]: Set BYTE_ORDER to
	LITTLE_ENDIAN or BIG_ENDIAN.
	* libc/include/sys/errno.h (EFTYPE): New macro.
	* libc/search/bsearch.c: Move from libc/stdlib.
	* libc/search/qsort.c: Likewise.
	* libc/stdlib/Makefile.am (LIB_SOURCES): Remove bsearch.c and
	qsort.c.
	(CHEWOUT_FILES): Remove bsearch.def and qsort.def.
	* libc/stdlib/stdlib.tex: Remove references to bsearch and qsort.
@
text
@d56 1
a56 1
#include <db.h>
d79 4
@

