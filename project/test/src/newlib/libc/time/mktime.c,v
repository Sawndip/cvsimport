head	1.10;
access;
symbols
	cygwin-1_7_35-release:1.10
	cygwin-1_7_34-release:1.10
	newlib-2_2_0:1.10.0.6
	cygwin-1_7_33-release:1.10
	cygwin-1_7_32-release:1.10
	cygwin-1_7_31-release:1.10
	cygwin-1_7_30-release:1.10
	cygwin-1_7_29-release:1.10
	cygwin-1_7_28-release:1.10
	newlib-2_1_0:1.10
	cygwin-1_7_27-release:1.10
	cygwin-1_7_26-release:1.10
	cygwin-1_7_25-release:1.10
	cygwin-1_7_24-release:1.10
	cygwin-1_7_23-release:1.10
	cygwin-1_7_22-release:1.10
	cygwin-1_7_21-release:1.10
	cygwin-1_7_20-release:1.10
	cygwin-1_7_19-release:1.10
	cygwin-64bit-postmerge:1.10
	cygwin-64bit-premerge-branch:1.10.0.4
	cygwin-64bit-premerge:1.10
	cygwin-1_7_18-release:1.10
	newlib-2_0_0:1.10
	cygwin-1_7_17-release:1.10
	cygwin-64bit-branch:1.10.0.2
	cygwin-1_7_16-release:1.10
	cygwin-1_7_15-release:1.10
	cygwin-1_7_14_2-release:1.10
	cygwin-1_7_14-release:1.10
	cygwin-1_7_12-release:1.10
	cygwin-1_7_11-release:1.10
	cygwin-1_7_10-release:1.10
	newlib-1_20_0:1.10
	cygwin-1_7_9-release:1.7
	cygwin-1_7_8-release:1.7
	newlib-1_19_0:1.7
	cygwin-1_7_7-release:1.7
	cygwin-1_7_5-release:1.7
	cygwin-1_7_4-release:1.7
	cygwin-1_7_3-release:1.7
	cygwin-1_7_2-release:1.7
	newlib-1_18_0:1.7
	cygwin-1_7_1-release:1.7
	newlib-1_17_0-arc:1.7.0.2
	binutils-arc-20080908-branch:1.6.0.2
	binutils-arc-20080908-branchpoint:1.6
	newlib-1_17_0:1.7
	newlib-1_16_0:1.5
	newlib-1_15_0:1.5
	newlib-csl-coldfire-4_1-32:1.5
	newlib-csl-sourcerygxx-4_1-32:1.5
	newlib-csl-innovasic-fido-3_4_4-33:1.5
	newlib-csl-coldfire-4_1-30:1.5
	newlib-csl-sourcerygxx-4_1-30:1.5
	newlib-csl-coldfire-4_1-28:1.5
	newlib-csl-sourcerygxx-4_1-28:1.5
	newlib-csl-arm-2006q3-27:1.5
	newlib-csl-sourcerygxx-4_1-27:1.5
	newlib-csl-arm-2006q3-26:1.5
	newlib-csl-sourcerygxx-4_1-26:1.5
	newlib-csl-sourcerygxx-4_1-24:1.5
	newlib-csl-sourcerygxx-4_1-23:1.5
	newlib-csl-sourcerygxx-4_1-21:1.5
	newlib-csl-arm-2006q3-21:1.5
	newlib-csl-arm-2006q3-19:1.5
	newlib-csl-sourcerygxx-4_1-19:1.5
	newlib-csl-sourcerygxx-4_1-18:1.5
	newlib-csl-sourcerygxx-3_4_4-25:1.5
	newlib-csl-sourcerygxx-4_1-17:1.5
	cr-0x5f1:1.5.0.6
	newlib-csl-sourcerygxx-4_1-14:1.5
	newlib-csl-sourcerygxx-4_1-13:1.5
	newlib-csl-sourcerygxx-4_1-12:1.5
	newlib-csl-sourcerygxx-4_1-9:1.5
	newlib-csl-sourcerygxx-4_1-8:1.5
	newlib-csl-sourcerygxx-4_1-7:1.5
	newlib-csl-arm-2006q1-6:1.5
	newlib-csl-sourcerygxx-4_1-6:1.5
	newlib-csl-sourcerygxx-4_1-5:1.5
	newlib-csl-sourcerygxx-4_1-4:1.5
	newlib-autotools-branch:1.5.0.4
	newlib-csl-20060320-branch:1.5.0.2
	newlib-csl-20060320-branchpoint:1.5
	newlib-1_14_0:1.5
	newlib-csl-arm-2005-q1b:1.5
	newlib-csl-arm-2005-q1a:1.5
	newlib-1_13_0:1.3
	csl-arm-2004-q3:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	newlib-1_12_0:1.3
	csl-arm-2003-q4:1.3
	w32api-2_2:1.3
	mingw-runtime-2_4:1.3
	newlib-1_11_0:1.3
	cygnus_cvs_20020108_pre:1.2
	newlib-1_10_0:1.2
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.10
date	2011.10.11.11.28.05;	author corinna;	state Exp;
branches;
next	1.9;

1.9
date	2011.08.19.14.14.18;	author corinna;	state Exp;
branches;
next	1.8;

1.8
date	2011.06.27.10.13.11;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.11.17.27.56;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.28.18.18.12;	author jjohnstn;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.25.22.31.21;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.23.19.08.58;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.17.21.23.31;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.05.21.07.20;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.51;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.51;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.10
log
@	* libc/time/mktm_r.c: (__tzcalc_limits) Fix Julian day calculation.
	* libc/time/mktime.c: (mktime) Fix tm_yday, tm_mday updating when
	timezone causes roll over.
@
text
@/*
 * mktime.c
 * Original Author:	G. Haley
 *
 * Converts the broken-down time, expressed as local time, in the structure
 * pointed to by tim_p into a calendar time value. The original values of the
 * tm_wday and tm_yday fields of the structure are ignored, and the original
 * values of the other fields have no restrictions. On successful completion
 * the fields of the structure are set to represent the specified calendar
 * time. Returns the specified calendar time. If the calendar time can not be
 * represented, returns the value (time_t) -1.
 *
 * Modifications:	Fixed tm_isdst usage - 27 August 2008 Craig Howland.
 */

/*
FUNCTION
<<mktime>>---convert time to arithmetic representation

INDEX
	mktime

ANSI_SYNOPSIS
	#include <time.h>
	time_t mktime(struct tm *<[timp]>);

TRAD_SYNOPSIS
	#include <time.h>
	time_t mktime(<[timp]>)
	struct tm *<[timp]>;

DESCRIPTION
<<mktime>> assumes the time at <[timp]> is a local time, and converts
its representation from the traditional representation defined by
<<struct tm>> into a representation suitable for arithmetic.

<<localtime>> is the inverse of <<mktime>>.

RETURNS
If the contents of the structure at <[timp]> do not form a valid
calendar time representation, the result is <<-1>>.  Otherwise, the
result is the time, converted to a <<time_t>> value.

PORTABILITY
ANSI C requires <<mktime>>.

<<mktime>> requires no supporting OS subroutines.
*/

#include <stdlib.h>
#include <time.h>
#include "local.h"

#define _SEC_IN_MINUTE 60L
#define _SEC_IN_HOUR 3600L
#define _SEC_IN_DAY 86400L

static _CONST int DAYS_IN_MONTH[12] =
{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

#define _DAYS_IN_MONTH(x) ((x == 1) ? days_in_feb : DAYS_IN_MONTH[x])

static _CONST int _DAYS_BEFORE_MONTH[12] =
{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};

#define _ISLEAP(y) (((y) % 4) == 0 && (((y) % 100) != 0 || (((y)+1900) % 400) == 0))
#define _DAYS_IN_YEAR(year) (_ISLEAP(year) ? 366 : 365)

static void 
_DEFUN(validate_structure, (tim_p),
     struct tm *tim_p)
{
  div_t res;
  int days_in_feb = 28;

  /* calculate time & date to account for out of range values */
  if (tim_p->tm_sec < 0 || tim_p->tm_sec > 59)
    {
      res = div (tim_p->tm_sec, 60);
      tim_p->tm_min += res.quot;
      if ((tim_p->tm_sec = res.rem) < 0)
	{
	  tim_p->tm_sec += 60;
	  --tim_p->tm_min;
	}
    }

  if (tim_p->tm_min < 0 || tim_p->tm_min > 59)
    {
      res = div (tim_p->tm_min, 60);
      tim_p->tm_hour += res.quot;
      if ((tim_p->tm_min = res.rem) < 0)
	{
	  tim_p->tm_min += 60;
	  --tim_p->tm_hour;
        }
    }

  if (tim_p->tm_hour < 0 || tim_p->tm_hour > 23)
    {
      res = div (tim_p->tm_hour, 24);
      tim_p->tm_mday += res.quot;
      if ((tim_p->tm_hour = res.rem) < 0)
	{
	  tim_p->tm_hour += 24;
	  --tim_p->tm_mday;
        }
    }

  if (tim_p->tm_mon < 0 || tim_p->tm_mon > 11)
    {
      res = div (tim_p->tm_mon, 12);
      tim_p->tm_year += res.quot;
      if ((tim_p->tm_mon = res.rem) < 0)
        {
	  tim_p->tm_mon += 12;
	  --tim_p->tm_year;
        }
    }

  if (_DAYS_IN_YEAR (tim_p->tm_year) == 366)
    days_in_feb = 29;

  if (tim_p->tm_mday <= 0)
    {
      while (tim_p->tm_mday <= 0)
	{
	  if (--tim_p->tm_mon == -1)
	    {
	      tim_p->tm_year--;
	      tim_p->tm_mon = 11;
	      days_in_feb =
		((_DAYS_IN_YEAR (tim_p->tm_year) == 366) ?
		 29 : 28);
	    }
	  tim_p->tm_mday += _DAYS_IN_MONTH (tim_p->tm_mon);
	}
    }
  else
    {
      while (tim_p->tm_mday > _DAYS_IN_MONTH (tim_p->tm_mon))
	{
	  tim_p->tm_mday -= _DAYS_IN_MONTH (tim_p->tm_mon);
	  if (++tim_p->tm_mon == 12)
	    {
	      tim_p->tm_year++;
	      tim_p->tm_mon = 0;
	      days_in_feb =
		((_DAYS_IN_YEAR (tim_p->tm_year) == 366) ?
		 29 : 28);
	    }
	}
    }
}

time_t 
_DEFUN(mktime, (tim_p),
     struct tm *tim_p)
{
  time_t tim = 0;
  long days = 0;
  int year, isdst=0;
  __tzinfo_type *tz = __gettzinfo ();

  /* validate structure */
  validate_structure (tim_p);

  /* compute hours, minutes, seconds */
  tim += tim_p->tm_sec + (tim_p->tm_min * _SEC_IN_MINUTE) +
    (tim_p->tm_hour * _SEC_IN_HOUR);

  /* compute days in year */
  days += tim_p->tm_mday - 1;
  days += _DAYS_BEFORE_MONTH[tim_p->tm_mon];
  if (tim_p->tm_mon > 1 && _DAYS_IN_YEAR (tim_p->tm_year) == 366)
    days++;

  /* compute day of the year */
  tim_p->tm_yday = days;

  if (tim_p->tm_year > 10000 || tim_p->tm_year < -10000)
      return (time_t) -1;

  /* compute days in other years */
  if ((year = tim_p->tm_year) > 70)
    {
      for (year = 70; year < tim_p->tm_year; year++)
	days += _DAYS_IN_YEAR (year);
    }
  else if (year < 70)
    {
      for (year = 69; year > tim_p->tm_year; year--)
	days -= _DAYS_IN_YEAR (year);
      days -= _DAYS_IN_YEAR (year);
    }

  /* compute total seconds */
  tim += (days * _SEC_IN_DAY);

  TZ_LOCK;

  if (_daylight)
    {
      int tm_isdst;
      int y = tim_p->tm_year + YEAR_BASE;
      /* Convert user positive into 1 */
      tm_isdst = tim_p->tm_isdst > 0  ?  1 : tim_p->tm_isdst;
      isdst = tm_isdst;

      if (y == tz->__tzyear || __tzcalc_limits (y))
	{
	  /* calculate start of dst in dst local time and 
	     start of std in both std local time and dst local time */
          time_t startdst_dst = tz->__tzrule[0].change
	    - (time_t) tz->__tzrule[1].offset;
	  time_t startstd_dst = tz->__tzrule[1].change
	    - (time_t) tz->__tzrule[1].offset;
	  time_t startstd_std = tz->__tzrule[1].change
	    - (time_t) tz->__tzrule[0].offset;
	  /* if the time is in the overlap between dst and std local times */
	  if (tim >= startstd_std && tim < startstd_dst)
	    ; /* we let user decide or leave as -1 */
          else
	    {
	      isdst = (tz->__tznorth
		       ? (tim >= startdst_dst && tim < startstd_std)
		       : (tim >= startdst_dst || tim < startstd_std));
 	      /* if user committed and was wrong, perform correction, but not
 	       * if the user has given a negative value (which
 	       * asks mktime() to determine if DST is in effect or not) */
 	      if (tm_isdst >= 0  &&  (isdst ^ tm_isdst) == 1)
		{
		  /* we either subtract or add the difference between
		     time zone offsets, depending on which way the user got it
		     wrong. The diff is typically one hour, or 3600 seconds,
		     and should fit in a 16-bit int, even though offset
		     is a long to accomodate 12 hours. */
		  int diff = (int) (tz->__tzrule[0].offset
				    - tz->__tzrule[1].offset);
		  if (!isdst)
		    diff = -diff;
		  tim_p->tm_sec += diff;
		  tim += diff;  /* we also need to correct our current time calculation */
		  int mday = tim_p->tm_mday;
		  validate_structure (tim_p);
		  mday = tim_p->tm_mday - mday;
		  /* roll over occurred */
		  if (mday) {
		    /* compensate for month roll overs */
		    if (mday > 1)
			  mday = -1;
		    else if (mday < -1)
			  mday = 1;
		    /* update days for wday calculation */
		    days += mday;
		    /* handle yday */
		    if ((tim_p->tm_yday += mday) < 0) {
			  --year;
			  tim_p->tm_yday = _DAYS_IN_YEAR(year) - 1;
		    } else {
			  mday = _DAYS_IN_YEAR(year);
			  if (tim_p->tm_yday > (mday - 1))
				tim_p->tm_yday -= mday;
		    }
		  }
		}
	    }
	}
    }

  /* add appropriate offset to put time in gmt format */
  if (isdst == 1)
    tim += (time_t) tz->__tzrule[1].offset;
  else /* otherwise assume std time */
    tim += (time_t) tz->__tzrule[0].offset;

  TZ_UNLOCK;

  /* reset isdst flag to what we have calculated */
  tim_p->tm_isdst = isdst;

  /* compute day of the week */
  if ((tim_p->tm_wday = (days + 4) % 7) < 0)
    tim_p->tm_wday += 7;
	
  return tim;
}
@


1.9
log
@	* libc/time/mktime.c (validate_structure): Account for tm_mon possibly
	being given as negative.
	(mktime): Set tm_isdst=0 when !daylight.
@
text
@d181 1
a181 3
  if (tim_p->tm_year > 10000
      || tim_p->tm_year < -10000)
    {
a182 1
    }
d185 1
a185 1
  if (tim_p->tm_year > 70)
d190 1
a190 1
  else if (tim_p->tm_year < 70)
a196 4
  /* compute day of the week */
  if ((tim_p->tm_wday = (days + 4) % 7) < 0)
    tim_p->tm_wday += 7;

d243 2
d246 20
a265 1
		  tim += diff;  /* we also need to correct our current time calculation */
d282 4
@


1.8
log
@	* libc/time/mktime.c (mktime): Lock global timezone info while
	accessing it.
@
text
@d110 1
a110 1
  if (tim_p->tm_mon > 11)
d162 1
a162 1
  int year, isdst, tm_isdst;
a206 4
  /* Convert user positive into 1 */
  tm_isdst = tim_p->tm_isdst > 0  ?  1 : tim_p->tm_isdst;
  isdst = tm_isdst;

d211 1
d213 4
@


1.7
log
@
2008-12-11  Craig Howland  <howland@@LGSInnovations.com>

        * libc/include/sys/lock.h:  Add void cast to avoid "statement has no
        effect" warnings from gcc.
        * libc/include/sys/stdio.h:  Ditto.
        * libc/include/sys/time.h:  Correct gettimeofday() prototype.
        * libc/stdlib/__exp10.c:  Add #include "std.h" for function prototype.
        * libc/stdlib/__ten_mu.c:  Ditto.
        * libc/stdlib/std.h:  Correct __exp10's ANSI prototype.
        * libc/stdlib/ldtoa.c:  Change eiisinf definition to ANSI form.  (Are
        already others in file without _ansi method, so did not bother.)
        * libc/stdlib/system.c:  Use _ansi forms for function prototypes and
        definitions.
        * libc/time/mktime.c:  Ditto.
        * libc/misc/__dprintf.c:  Ditto.
        * libc/include/stdio.h:  Add function prototypes for _fgetc_r,
        _fgetpos_r, _fsetpos_r, _freopen_r, _rewind_r, freopen64, _freopen64_r,
        _funopen_r, and _fopencookie_r.
        * libc/include/reent.h:  Add function prototype for _stat64_r, align
        _execve_r prototype with POSIX definition for execve.
        * libc/reent/execr.c:  Align function prototype with POSIX definition.
        * libc/stdio/asniprintf.c:  Add #include "local.h".
        * libc/stdio/vasniprintf.c:  Ditto.
        * libc/stdio/fread.c:  Remove unused variable newcount.
        * libc/stdio/local.h:  Add function prototype for __sccl.
        * libc/stdio/open_memstream.c:  Remove unused variable flags.
        * libc/stdio/vfscanf.c:  Proper prototyping for ccfn, remove prototype
        for __sccl since now in local.h.
        * libc/string/memcpy.c:  Add #include <string.h> (for real and for
        traditional synopsis), remove extraneous stddef.h and limits.h.
        * libc/syscalls/sysclose.c:  Add #include <unistd.h>.
        * libc/syscalls/sysfork.c:  Ditto.
        * libc/syscalls/sysgetpid.c:  Ditto.
        * libc/syscalls/sysexecve.c:  Add #include <unistd.h>, align function
        prototype with POSIX definition.
        * libc/syscalls/sysfstat.c:  Add #include <sys/stat.h>.
        * libc/syscalls/sysgettod.c:  Correct sys/times.h to sys/time.h.
        * libc/syscalls/syskill.c:  Add #include <signal.h>.
        * libc/syscalls/syslink.c:  Add #include <unistd.h>, fix prototype.
        * libc/syscalls/sysunlink.c:  Ditto.
        * libc/syscalls/sysstat.c:  Add #include <sys/stat.h>, fix prototype.
        * libc/syscalls/syswait.c:  Add #include <sys/wait.h>, fix prototype.
@
text
@d211 2
d262 2
@


1.6
log
@
2008-08-28  Craig Howland  <howland@@LGSInnovations.com>

        * libc/time/mktime.c (mktime): Fix tm_isdst value usage (allowing
        any positive value from user (per std) rather than depending
        upon 1).
@
text
@d70 2
a71 2
validate_structure (tim_p)
     struct tm *tim_p;
d157 2
a158 2
mktime (tim_p)
     struct tm *tim_p;
@


1.5
log
@
2005-02-25  Eric Blake  <ebb9@@byu.net>

        * libc/include/time.h (__tzrule_struct): Make offset long, since
        a 16-bit int overflows on a 12-hour offset.
        * libc/sys/linux/include/time.h: Ditto.
        * libc/time/mktime.c (mktime): Use new type of __tzrule.offset.
        * libc/time/mktm_r.c: Ditto.
        * libc/time/gettzinfo.c: Ditto.
        * libc/time/strftime.c (strftime): Fix '%x' to deal with negative
        years.  Fix '%z' to use long, not int.
@
text
@d12 2
d162 1
a162 1
  int year, isdst;
d207 3
a209 1
  isdst = tim_p->tm_isdst;
d232 4
a235 2
	      /* if user committed and was wrong, perform correction */
	      if ((isdst ^ tim_p->tm_isdst) == 1)
@


1.4
log
@
2005-02-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/time.h [!CYGWIN](_timezone): Change to long.
        (__tzrule_type, __tzinfo_type): New types.
        (__gettzinfo): New function.
        * libc/sys/linux/include/time.h: Ditto.
        * libc/time/Makefile.am: Add gettzinfo.c.
        * libc/time/Makefile.in: Regenerated.
        * libc/time/local.h: Moved __tzrule_type to time.h.
        * libc/time/mktime.c: Call __gettzinfo to reference
        __tznorth, __tzyear, and __tzrule array.
        * libc/time/mktm_r.c: Ditto.
        * libc/time/strftime.c: Ditto.
        * libc/time/tzset_r.c: Ditto.  Also remove definition
        of __tzrule which is now in gettzinfo.c.  Change _timezone
        references to not cast to time_t.
        * libc/time/gettzinfo.c: New file.
@
text
@d214 6
a219 3
          time_t startdst_dst = tz->__tzrule[0].change - tz->__tzrule[1].offset;
	  time_t startstd_dst = tz->__tzrule[1].change - tz->__tzrule[1].offset;
	  time_t startstd_std = tz->__tzrule[1].change - tz->__tzrule[0].offset;
d232 6
a237 2
		     time zone offsets, depending on which way the user got it wrong */
		  int diff = tz->__tzrule[0].offset - tz->__tzrule[1].offset;
d250 1
a250 1
    tim += tz->__tzrule[1].offset;
d252 1
a252 1
    tim += tz->__tzrule[0].offset;
@


1.3
log
@
2002-04-17  Jeff Johnston  <jjohnstn@@redhat.com>

        *  libc/include/time.h (tzset, _tzset_r): Added prototypes.
        (strptime): Moved prototype to be within !__STRICT_ANSI__.
        (_tzname, _daylight, _timezone): No long __CYGWIN__ only.
        (tzname): Defined for all platforms.
        (daylight, timezone): Defined only for CYGWIN.
        *  libc/sys/linux/machine/i386/crt0.c: Add call to tzset() after
        environment set up.
        * libc/stdlib/setenv_r.c (_setenv_r): Call tzset() if the TZ
        environment variable is set.
        *  libc/time/Makefile.am: Add support for tzset.c, tzlock.c, and
        tzset_r.c.
        *  libc/time/Makefile.in: Regenerated.
        *  libc/time/gmtime.c (gmtime): Changed to call gmtime_r.
        *  libc/time/gmtime_r.c (gmtime_r): Changed to call _mktm_r.
        *  libc/time/lcltime_r.c (lcltime_r): Ditto.
        *  libc/time/local.h: New local header file.
        *  libc/time/mktime.c (mktime): Add timezone support.
        *  libc/time/mktm_r.c: New file which is the common engine
        for gmtime_r and lcltime_r.  This code has timezone support.
        *  libc/time/strftime.c (strftime): Add %Z timezone support.
        *  libc/time/tzlock.c: New file containing timezone lock stubs.
        *  libc/time/tzset.c: New file containing tzset() routine.
        *  libc/time/tzset_r.c: New file containing _tzset_r and
        internal routine for calculating timezone changes for specified year.
@
text
@d161 1
d210 1
a210 1
      if (y == __tzyear || __tzcalc_limits (y))
d214 3
a216 3
          time_t startdst_dst = __tzrule[0].change - __tzrule[1].offset;
	  time_t startstd_dst = __tzrule[1].change - __tzrule[1].offset;
	  time_t startstd_std = __tzrule[1].change - __tzrule[0].offset;
d222 1
a222 1
	      isdst = (__tznorth
d230 1
a230 1
		  int diff = __tzrule[0].offset - __tzrule[1].offset;
d243 1
a243 1
    tim += __tzrule[1].offset;
d245 1
a245 1
    tim += __tzrule[0].offset;
@


1.2
log
@
2001-03-05  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/time/mktime.c: Add L suffix to _SEC_IN_xxxx constants.
@
text
@d50 1
d160 1
a160 1
  int year;
d203 45
@


1.1
log
@Initial revision
@
text
@d51 3
a53 3
#define _SEC_IN_MINUTE 60
#define _SEC_IN_HOUR 3600
#define _SEC_IN_DAY 86400
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
