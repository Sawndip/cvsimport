head	1.24;
access;
symbols
	cygwin-1_7_35-release:1.24
	cygwin-1_7_34-release:1.24
	newlib-2_2_0:1.23.0.2
	cygwin-1_7_33-release:1.23
	cygwin-1_7_32-release:1.22
	cygwin-1_7_31-release:1.22
	cygwin-1_7_30-release:1.22
	cygwin-1_7_29-release:1.22
	cygwin-1_7_28-release:1.22
	newlib-2_1_0:1.22
	cygwin-1_7_27-release:1.22
	cygwin-1_7_26-release:1.22
	cygwin-1_7_25-release:1.19
	cygwin-1_7_24-release:1.19
	cygwin-1_7_23-release:1.19
	cygwin-1_7_22-release:1.19
	cygwin-1_7_21-release:1.19
	cygwin-1_7_20-release:1.19
	cygwin-1_7_19-release:1.19
	cygwin-64bit-postmerge:1.19
	cygwin-64bit-premerge-branch:1.19.0.2
	cygwin-64bit-premerge:1.19
	cygwin-1_7_18-release:1.19
	newlib-2_0_0:1.19
	cygwin-1_7_17-release:1.19
	cygwin-64bit-branch:1.18.0.2
	cygwin-1_7_16-release:1.18
	cygwin-1_7_15-release:1.18
	cygwin-1_7_14_2-release:1.18
	cygwin-1_7_14-release:1.18
	cygwin-1_7_12-release:1.18
	cygwin-1_7_11-release:1.18
	cygwin-1_7_10-release:1.18
	newlib-1_20_0:1.18
	cygwin-1_7_9-release:1.16
	cygwin-1_7_8-release:1.16
	newlib-1_19_0:1.16
	cygwin-1_7_7-release:1.16
	cygwin-1_7_5-release:1.14
	cygwin-1_7_4-release:1.14
	cygwin-1_7_3-release:1.14
	cygwin-1_7_2-release:1.14
	newlib-1_18_0:1.12
	cygwin-1_7_1-release:1.12
	newlib-1_17_0-arc:1.10.0.10
	binutils-arc-20080908-branch:1.10.0.8
	binutils-arc-20080908-branchpoint:1.10
	newlib-1_17_0:1.10
	newlib-1_16_0:1.10
	newlib-1_15_0:1.10
	newlib-csl-coldfire-4_1-32:1.10
	newlib-csl-sourcerygxx-4_1-32:1.10
	newlib-csl-innovasic-fido-3_4_4-33:1.10
	newlib-csl-coldfire-4_1-30:1.10
	newlib-csl-sourcerygxx-4_1-30:1.10
	newlib-csl-coldfire-4_1-28:1.10
	newlib-csl-sourcerygxx-4_1-28:1.10
	newlib-csl-arm-2006q3-27:1.10
	newlib-csl-sourcerygxx-4_1-27:1.10
	newlib-csl-arm-2006q3-26:1.10
	newlib-csl-sourcerygxx-4_1-26:1.10
	newlib-csl-sourcerygxx-4_1-24:1.10
	newlib-csl-sourcerygxx-4_1-23:1.10
	newlib-csl-sourcerygxx-4_1-21:1.10
	newlib-csl-arm-2006q3-21:1.10
	newlib-csl-arm-2006q3-19:1.10
	newlib-csl-sourcerygxx-4_1-19:1.10
	newlib-csl-sourcerygxx-4_1-18:1.10
	newlib-csl-sourcerygxx-3_4_4-25:1.10
	newlib-csl-sourcerygxx-4_1-17:1.10
	cr-0x5f1:1.10.0.6
	newlib-csl-sourcerygxx-4_1-14:1.10
	newlib-csl-sourcerygxx-4_1-13:1.10
	newlib-csl-sourcerygxx-4_1-12:1.10
	newlib-csl-sourcerygxx-4_1-9:1.10
	newlib-csl-sourcerygxx-4_1-8:1.10
	newlib-csl-sourcerygxx-4_1-7:1.10
	newlib-csl-arm-2006q1-6:1.10
	newlib-csl-sourcerygxx-4_1-6:1.10
	newlib-csl-sourcerygxx-4_1-5:1.10
	newlib-csl-sourcerygxx-4_1-4:1.10
	newlib-autotools-branch:1.10.0.4
	newlib-csl-20060320-branch:1.10.0.2
	newlib-csl-20060320-branchpoint:1.10
	newlib-1_14_0:1.10
	newlib-csl-arm-2005-q1b:1.10
	newlib-csl-arm-2005-q1a:1.10
	newlib-1_13_0:1.5
	csl-arm-2004-q3:1.5
	csl-arm-2004-q1a:1.5
	csl-arm-2004-q1:1.5
	newlib-1_12_0:1.5
	csl-arm-2003-q4:1.5
	w32api-2_2:1.5
	mingw-runtime-2_4:1.5
	newlib-1_11_0:1.4
	cygnus_cvs_20020108_pre:1.2
	newlib-1_10_0:1.2
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.24
date	2015.01.08.09.51.34;	author corinna;	state Exp;
branches;
next	1.23;

1.23
date	2014.09.04.08.27.03;	author corinna;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.26.14.38.58;	author joel;	state Exp;
branches;
next	1.21;

1.21
date	2013.11.25.17.55.33;	author joel;	state Exp;
branches;
next	1.20;

1.20
date	2013.11.25.13.46.23;	author joel;	state Exp;
branches;
next	1.19;

1.19
date	2012.08.10.15.21.57;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.12.10.48.29;	author corinna;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2011.06.14.14.31.59;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.28.09.59.37;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.22.23.32.42;	author dj;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.26.09.41.44;	author corinna;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.22.13.03.42;	author corinna;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.12.10.27.10;	author corinna;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.09.12.35.03;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.25.22.31.21;	author jjohnstn;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.24.06.14.44;	author joshuadfranklin;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.23.19.08.58;	author jjohnstn;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.16.21.15.37;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.20.19.56.27;	author jjohnstn;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.15.18.52.02;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.21.20.04.40;	author corinna;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.17.21.23.31;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.13.20.40.49;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.51;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.18.2.1
date	2012.08.10.15.59.06;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.39.51;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.24
log
@	* libc/time/strftime.c (__strftime): Utilize __TM_GMTOFF and __TM_ZONE
	on systems where available.  On Cygwin, call function to get values.
	Add comment to explain why.  Drop TZ_LOCK/TZ_UNLOCK in 'z' case since
	it's not necessary.  In 'Z' case, add a comment to document a potential
	codeset problem.
@
text
@/* NOTE:  This file defines both strftime() and wcsftime().  Take care when
 * making changes.  See also wcsftime.c, and note the (small) overlap in the
 * manual description, taking care to edit both as needed.  */
/*
 * strftime.c
 * Original Author:	G. Haley
 * Additions from:	Eric Blake
 * Changes to allow dual use as wcstime, also:	Craig Howland
 *
 * Places characters into the array pointed to by s as controlled by the string
 * pointed to by format. If the total number of resulting characters including
 * the terminating null character is not more than maxsize, returns the number
 * of characters placed into the array pointed to by s (not including the
 * terminating null character); otherwise zero is returned and the contents of
 * the array indeterminate.
 */

/*
FUNCTION
<<strftime>>---convert date and time to a formatted string

INDEX
	strftime

ANSI_SYNOPSIS
	#include <time.h>
	size_t strftime(char *restrict <[s]>, size_t <[maxsize]>,
			const char *restrict <[format]>,
                        const struct tm *restrict <[timp]>);

TRAD_SYNOPSIS
	#include <time.h>
	size_t strftime(<[s]>, <[maxsize]>, <[format]>, <[timp]>)
	char *<[s]>;
	size_t <[maxsize]>;
	char *<[format]>;
	struct tm *<[timp]>;

DESCRIPTION
<<strftime>> converts a <<struct tm>> representation of the time (at
<[timp]>) into a null-terminated string, starting at <[s]> and occupying
no more than <[maxsize]> characters.

You control the format of the output using the string at <[format]>.
<<*<[format]>>> can contain two kinds of specifications: text to be
copied literally into the formatted string, and time conversion
specifications.  Time conversion specifications are two- and
three-character sequences beginning with `<<%>>' (use `<<%%>>' to
include a percent sign in the output).  Each defined conversion
specification selects only the specified field(s) of calendar time
data from <<*<[timp]>>>, and converts it to a string in one of the
following ways:

o+
o %a
The abbreviated weekday name according to the current locale. [tm_wday]

o %A
The full weekday name according to the current locale.
In the default "C" locale, one of `<<Sunday>>', `<<Monday>>', `<<Tuesday>>',
`<<Wednesday>>', `<<Thursday>>', `<<Friday>>', `<<Saturday>>'. [tm_wday]

o %b
The abbreviated month name according to the current locale. [tm_mon]

o %B
The full month name according to the current locale.
In the default "C" locale, one of `<<January>>', `<<February>>',
`<<March>>', `<<April>>', `<<May>>', `<<June>>', `<<July>>',
`<<August>>', `<<September>>', `<<October>>', `<<November>>',
`<<December>>'. [tm_mon]

o %c
The preferred date and time representation for the current locale.
[tm_sec, tm_min, tm_hour, tm_mday, tm_mon, tm_year, tm_wday]

o %C
The century, that is, the year divided by 100 then truncated.  For
4-digit years, the result is zero-padded and exactly two characters;
but for other years, there may a negative sign or more digits.  In
this way, `<<%C%y>>' is equivalent to `<<%Y>>'. [tm_year]
 
o %d
The day of the month, formatted with two digits (from `<<01>>' to
`<<31>>'). [tm_mday]

o %D
A string representing the date, in the form `<<"%m/%d/%y">>'.
[tm_mday, tm_mon, tm_year]

o %e
The day of the month, formatted with leading space if single digit
(from `<<1>>' to `<<31>>'). [tm_mday]

o %E<<x>>
In some locales, the E modifier selects alternative representations of
certain modifiers <<x>>.  In newlib, it is ignored, and treated as %<<x>>.

o %F
A string representing the ISO 8601:2000 date format, in the form
`<<"%Y-%m-%d">>'. [tm_mday, tm_mon, tm_year]

o %g
The last two digits of the week-based year, see specifier %G (from
`<<00>>' to `<<99>>'). [tm_year, tm_wday, tm_yday]

o %G
The week-based year. In the ISO 8601:2000 calendar, week 1 of the year
includes January 4th, and begin on Mondays. Therefore, if January 1st,
2nd, or 3rd falls on a Sunday, that day and earlier belong to the last
week of the previous year; and if December 29th, 30th, or 31st falls
on Monday, that day and later belong to week 1 of the next year.  For
consistency with %Y, it always has at least four characters. 
Example: "%G" for Saturday 2nd January 1999 gives "1998", and for
Tuesday 30th December 1997 gives "1998". [tm_year, tm_wday, tm_yday]

o %h
Synonym for "%b". [tm_mon]

o %H
The hour (on a 24-hour clock), formatted with two digits (from
`<<00>>' to `<<23>>'). [tm_hour]

o %I
The hour (on a 12-hour clock), formatted with two digits (from
`<<01>>' to `<<12>>'). [tm_hour]

o %j
The count of days in the year, formatted with three digits
(from `<<001>>' to `<<366>>'). [tm_yday]

o %k
The hour (on a 24-hour clock), formatted with leading space if single
digit (from `<<0>>' to `<<23>>'). Non-POSIX extension (c.p. %I). [tm_hour]

o %l
The hour (on a 12-hour clock), formatted with leading space if single
digit (from `<<1>>' to `<<12>>'). Non-POSIX extension (c.p. %H). [tm_hour]

o %m
The month number, formatted with two digits (from `<<01>>' to `<<12>>').
[tm_mon]

o %M
The minute, formatted with two digits (from `<<00>>' to `<<59>>'). [tm_min]

o %n
A newline character (`<<\n>>').

o %O<<x>>
In some locales, the O modifier selects alternative digit characters
for certain modifiers <<x>>.  In newlib, it is ignored, and treated as %<<x>>.

o %p
Either `<<AM>>' or `<<PM>>' as appropriate, or the corresponding strings for
the current locale. [tm_hour]

o %P
Same as '<<%p>>', but in lowercase.  This is a GNU extension. [tm_hour]

o %r
Replaced by the time in a.m. and p.m. notation.  In the "C" locale this
is equivalent to "%I:%M:%S %p".  In locales which don't define a.m./p.m.
notations, the result is an empty string. [tm_sec, tm_min, tm_hour]

o %R
The 24-hour time, to the minute.  Equivalent to "%H:%M". [tm_min, tm_hour]

o %S
The second, formatted with two digits (from `<<00>>' to `<<60>>').  The
value 60 accounts for the occasional leap second. [tm_sec]

o %t
A tab character (`<<\t>>').

o %T
The 24-hour time, to the second.  Equivalent to "%H:%M:%S". [tm_sec,
tm_min, tm_hour]

o %u
The weekday as a number, 1-based from Monday (from `<<1>>' to
`<<7>>'). [tm_wday]

o %U
The week number, where weeks start on Sunday, week 1 contains the first
Sunday in a year, and earlier days are in week 0.  Formatted with two
digits (from `<<00>>' to `<<53>>').  See also <<%W>>. [tm_wday, tm_yday]

o %V
The week number, where weeks start on Monday, week 1 contains January 4th,
and earlier days are in the previous year.  Formatted with two digits
(from `<<01>>' to `<<53>>').  See also <<%G>>. [tm_year, tm_wday, tm_yday]

o %w
The weekday as a number, 0-based from Sunday (from `<<0>>' to `<<6>>').
[tm_wday]

o %W
The week number, where weeks start on Monday, week 1 contains the first
Monday in a year, and earlier days are in week 0.  Formatted with two
digits (from `<<00>>' to `<<53>>'). [tm_wday, tm_yday]

o %x
Replaced by the preferred date representation in the current locale.
In the "C" locale this is equivalent to "%m/%d/%y".
[tm_mon, tm_mday, tm_year]

o %X
Replaced by the preferred time representation in the current locale.
In the "C" locale this is equivalent to "%H:%M:%S". [tm_sec, tm_min, tm_hour]

o %y
The last two digits of the year (from `<<00>>' to `<<99>>'). [tm_year]
(Implementation interpretation:  always positive, even for negative years.)

o %Y
The full year, equivalent to <<%C%y>>.  It will always have at least four
characters, but may have more.  The year is accurate even when tm_year
added to the offset of 1900 overflows an int. [tm_year]

o %z
The offset from UTC.  The format consists of a sign (negative is west of
Greewich), two characters for hour, then two characters for minutes
(-hhmm or +hhmm).  If tm_isdst is negative, the offset is unknown and no
output is generated; if it is zero, the offset is the standard offset for
the current time zone; and if it is positive, the offset is the daylight
savings offset for the current timezone. The offset is determined from
the TZ environment variable, as if by calling tzset(). [tm_isdst]

o %Z
The time zone name.  If tm_isdst is negative, no output is generated.
Otherwise, the time zone name is based on the TZ environment variable,
as if by calling tzset(). [tm_isdst]

o %%
A single character, `<<%>>'.
o-

RETURNS
When the formatted time takes up no more than <[maxsize]> characters,
the result is the length of the formatted string.  Otherwise, if the
formatting operation was abandoned due to lack of room, the result is
<<0>>, and the string starting at <[s]> corresponds to just those
parts of <<*<[format]>>> that could be completely filled in within the
<[maxsize]> limit.

PORTABILITY
ANSI C requires <<strftime>>, but does not specify the contents of
<<*<[s]>>> when the formatted string would require more than
<[maxsize]> characters.  Unrecognized specifiers and fields of
<<timp>> that are out of range cause undefined results.  Since some
formats expand to 0 bytes, it is wise to set <<*<[s]>>> to a nonzero
value beforehand to distinguish between failure and an empty string.
This implementation does not support <<s>> being NULL, nor overlapping
<<s>> and <<format>>.

<<strftime>> requires no supporting OS subroutines.

BUGS
<<strftime>> ignores the LC_TIME category of the current locale, hard-coding
the "C" locale settings.
*/

#include <newlib.h>
#include <sys/config.h>
#include <stddef.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <wctype.h>
#include "local.h"
#include "../locale/timelocal.h"
 
/* Defines to make the file dual use for either strftime() or wcsftime().
 * To get wcsftime, define MAKE_WCSFTIME.
 * To get strftime, do not define MAKE_WCSFTIME.
 * Names are kept friendly to strftime() usage.  The biggest ugliness is the
 * use of the CQ() macro to make either regular character constants and
 * string literals or wide-character constants and wide-character-string
 * literals, as appropriate.  */
#if !defined(MAKE_WCSFTIME)
#  define CHAR		char		/* string type basis */
#  define CQ(a)		a		/* character constant qualifier */
#  define SFLG				/* %s flag (null for normal char) */
#  define _ctloc(x) (ctloclen = strlen (ctloc = _CurrentTimeLocale->x), ctloc)
#  define snprintf	sniprintf	/* avoid to pull in FP functions. */
#  define TOLOWER(c)	tolower((int)(unsigned char)(c))
#  define STRTOUL(c,p,b) strtoul((c),(p),(b))
#  define STRCPY(a,b)	strcpy((a),(b))
#  define STRCHR(a,b)	strchr((a),(b))
#  define STRLEN(a)	strlen(a)
# else
#  define strftime	wcsftime	/* Alternate function name */
#  define CHAR		wchar_t		/* string type basis */
#  define CQ(a)		L##a		/* character constant qualifier */
#  define snprintf	swprintf	/* wide-char equivalent function name */
#  define strncmp	wcsncmp		/* wide-char equivalent function name */
#  define TOLOWER(c)	towlower((wint_t)(c))
#  define STRTOUL(c,p,b) wcstoul((c),(p),(b))
#  define STRCPY(a,b)	wcscpy((a),(b))
#  define STRCHR(a,b)	wcschr((a),(b))
#  define STRLEN(a)	wcslen(a)
#  define SFLG		"l"		/* %s flag (l for wide char) */
#  ifdef __HAVE_LOCALE_INFO_EXTENDED__
#   define _ctloc(x) (ctloclen = wcslen (ctloc = _CurrentTimeLocale->w##x), \
		      ctloc)
#  else
#   define CTLOCBUFLEN   256		/* Arbitrary big buffer size */
    const wchar_t *
    __ctloc (wchar_t *buf, const char *elem, size_t *len_ret)
    {
      buf[CTLOCBUFLEN - 1] = L'\0';
      *len_ret = mbstowcs (buf, elem, CTLOCBUFLEN - 1);
      if (*len_ret == (size_t) -1 )
	*len_ret = 0;
      return buf;
    }
#   define _ctloc(x) (ctloc = __ctloc (ctlocbuf, _CurrentTimeLocale->x, \
		      &ctloclen))
#  endif
#endif  /* MAKE_WCSFTIME */

#define CHECK_LENGTH()	if (len < 0 || (count += len) >= maxsize) \
			  return 0

/* Enforce the coding assumptions that YEAR_BASE is positive.  (%C, %Y, etc.) */
#if YEAR_BASE < 0
#  error "YEAR_BASE < 0"
#endif

static _CONST int dname_len[7] =
{6, 6, 7, 9, 8, 6, 8};

/* Using the tm_year, tm_wday, and tm_yday components of TIM_P, return
   -1, 0, or 1 as the adjustment to add to the year for the ISO week
   numbering used in "%g%G%V", avoiding overflow.  */
static int
_DEFUN (iso_year_adjust, (tim_p),
	_CONST struct tm *tim_p)
{
  /* Account for fact that tm_year==0 is year 1900.  */
  int leap = isleap (tim_p->tm_year + (YEAR_BASE
				       - (tim_p->tm_year < 0 ? 0 : 2000)));

  /* Pack the yday, wday, and leap year into a single int since there are so
     many disparate cases.  */
#define PACK(yd, wd, lp) (((yd) << 4) + (wd << 1) + (lp))
  switch (PACK (tim_p->tm_yday, tim_p->tm_wday, leap))
    {
    case PACK (0, 5, 0): /* Jan 1 is Fri, not leap.  */
    case PACK (0, 6, 0): /* Jan 1 is Sat, not leap.  */
    case PACK (0, 0, 0): /* Jan 1 is Sun, not leap.  */
    case PACK (0, 5, 1): /* Jan 1 is Fri, leap year.  */
    case PACK (0, 6, 1): /* Jan 1 is Sat, leap year.  */
    case PACK (0, 0, 1): /* Jan 1 is Sun, leap year.  */
    case PACK (1, 6, 0): /* Jan 2 is Sat, not leap.  */
    case PACK (1, 0, 0): /* Jan 2 is Sun, not leap.  */
    case PACK (1, 6, 1): /* Jan 2 is Sat, leap year.  */
    case PACK (1, 0, 1): /* Jan 2 is Sun, leap year.  */
    case PACK (2, 0, 0): /* Jan 3 is Sun, not leap.  */
    case PACK (2, 0, 1): /* Jan 3 is Sun, leap year.  */
      return -1; /* Belongs to last week of previous year.  */
    case PACK (362, 1, 0): /* Dec 29 is Mon, not leap.  */
    case PACK (363, 1, 1): /* Dec 29 is Mon, leap year.  */
    case PACK (363, 1, 0): /* Dec 30 is Mon, not leap.  */
    case PACK (363, 2, 0): /* Dec 30 is Tue, not leap.  */
    case PACK (364, 1, 1): /* Dec 30 is Mon, leap year.  */
    case PACK (364, 2, 1): /* Dec 30 is Tue, leap year.  */
    case PACK (364, 1, 0): /* Dec 31 is Mon, not leap.  */
    case PACK (364, 2, 0): /* Dec 31 is Tue, not leap.  */
    case PACK (364, 3, 0): /* Dec 31 is Wed, not leap.  */
    case PACK (365, 1, 1): /* Dec 31 is Mon, leap year.  */
    case PACK (365, 2, 1): /* Dec 31 is Tue, leap year.  */
    case PACK (365, 3, 1): /* Dec 31 is Wed, leap year.  */
      return 1; /* Belongs to first week of next year.  */
    }
  return 0; /* Belongs to specified year.  */
#undef PACK
}

#ifdef _WANT_C99_TIME_FORMATS
typedef struct {
  int   year;
  CHAR *era_C;
  CHAR *era_Y;
} era_info_t;

static era_info_t *
#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
get_era_info (const struct tm *tim_p, const wchar_t *era)
#else
get_era_info (const struct tm *tim_p, const char *era)
#endif
{
#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
  wchar_t *c;
  const wchar_t *dir;
# define ERA_STRCHR(a,b)	wcschr((a),(b))
# define ERA_STRNCPY(a,b,c)	wcsncpy((a),(b),(c))
# define ERA_STRTOL(a,b,c)	wcstol((a),(b),(c))
#else
  char *c;
  const char *dir;
# define ERA_STRCHR(a,b)	strchr((a),(b))
# define ERA_STRNCPY(a,b,c)	strncpy((a),(b),(c))
# define ERA_STRTOL(a,b,c)	strtol((a),(b),(c))
#endif
  long offset;
  struct tm stm, etm;
  era_info_t *ei;

  ei = (era_info_t *) calloc (1, sizeof (era_info_t));
  if (!ei)
    return NULL;

  stm.tm_isdst = etm.tm_isdst = 0;
  while (era)
    {
      dir = era;
      era += 2;
      offset = ERA_STRTOL (era, &c, 10);
      era = c + 1;
      stm.tm_year = ERA_STRTOL (era, &c, 10) - YEAR_BASE;
      /* Adjust offset for negative gregorian dates. */
      if (stm.tm_year <= -YEAR_BASE)
      	++stm.tm_year;
      stm.tm_mon = ERA_STRTOL (c + 1, &c, 10) - 1;
      stm.tm_mday = ERA_STRTOL (c + 1, &c, 10);
      stm.tm_hour = stm.tm_min = stm.tm_sec = 0;
      era = c + 1;
      if (era[0] == '-' && era[1] == '*')
      	{
	  etm = stm;
	  stm.tm_year = INT_MIN;
	  stm.tm_mon = stm.tm_mday = stm.tm_hour = stm.tm_min = stm.tm_sec = 0;
	  era += 3;
	}
      else if (era[0] == '+' && era[1] == '*')
	{
	  etm.tm_year = INT_MAX;
	  etm.tm_mon = 11;
	  etm.tm_mday = 31;
	  etm.tm_hour = 23;
	  etm.tm_min = etm.tm_sec = 59;
	  era += 3;
	}
      else
      	{
	  etm.tm_year = ERA_STRTOL (era, &c, 10) - YEAR_BASE;
	  /* Adjust offset for negative gregorian dates. */
	  if (etm.tm_year <= -YEAR_BASE)
	    ++etm.tm_year;
	  etm.tm_mon = ERA_STRTOL (c + 1, &c, 10) - 1;
	  etm.tm_mday = ERA_STRTOL (c + 1, &c, 10);
	  etm.tm_mday = 31;
	  etm.tm_hour = 23;
	  etm.tm_min = etm.tm_sec = 59;
	  era = c + 1;
	}
      if ((tim_p->tm_year > stm.tm_year
	   || (tim_p->tm_year == stm.tm_year
	       && (tim_p->tm_mon > stm.tm_mon
		   || (tim_p->tm_mon == stm.tm_mon
		       && tim_p->tm_mday >= stm.tm_mday))))
	  && (tim_p->tm_year < etm.tm_year
	      || (tim_p->tm_year == etm.tm_year
		  && (tim_p->tm_mon < etm.tm_mon
		      || (tim_p->tm_mon == etm.tm_mon
			  && tim_p->tm_mday <= etm.tm_mday)))))
	{
	  /* Gotcha */
	  size_t len;

	  /* year */
	  if (*dir == '+' && stm.tm_year != INT_MIN)
	    ei->year = tim_p->tm_year - stm.tm_year + offset;
	  else
	    ei->year = etm.tm_year - tim_p->tm_year + offset;
	  /* era_C */
	  c = ERA_STRCHR (era, ':');
#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
	  len = mbsnrtowcs (NULL, &era, c - era, 0, NULL);
	  if (len == (size_t) -1)
	    {
	      free (ei);
	      return NULL;
	    }
#else
	  len = c - era;
#endif
	  ei->era_C = (CHAR *) malloc ((len + 1) * sizeof (CHAR));
	  if (!ei->era_C)
	    {
	      free (ei);
	      return NULL;
	    }
#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
	  len = mbsnrtowcs (ei->era_C, &era, c - era, len + 1, NULL);
#else
	  ERA_STRNCPY (ei->era_C, era, len);
	  era += len;
#endif
	  ei->era_C[len] = CQ('\0');
	  /* era_Y */
	  ++era;
	  c = ERA_STRCHR (era, ';');
	  if (!c)
	    c = ERA_STRCHR (era, '\0');
#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
	  len = mbsnrtowcs (NULL, &era, c - era, 0, NULL);
	  if (len == (size_t) -1)
	    {
	      free (ei->era_C);
	      free (ei);
	      return NULL;
	    }
#else
	  len = c - era;
#endif
	  ei->era_Y = (CHAR *) malloc ((len + 1) * sizeof (CHAR));
	  if (!ei->era_Y)
	    {
	      free (ei->era_C);
	      free (ei);
	      return NULL;
	    }
#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
	  len = mbsnrtowcs (ei->era_Y, &era, c - era, len + 1, NULL);
#else
	  ERA_STRNCPY (ei->era_Y, era, len);
	  era += len;
#endif
	  ei->era_Y[len] = CQ('\0');
	  return ei;
	}
      else
	era = ERA_STRCHR (era, ';');
      if (era)
	++era;
    }
  return NULL;
}

static void
free_era_info (era_info_t *ei)
{
  free (ei->era_C);
  free (ei->era_Y);
  free (ei);
}

typedef struct {
  size_t num;
  CHAR **digit;
  CHAR *buffer;
} alt_digits_t;

static alt_digits_t *
#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
get_alt_digits (const wchar_t *alt_digits)
#else
get_alt_digits (const char *alt_digits)
#endif
{
  alt_digits_t *adi;
#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
  const wchar_t *a, *e;
# define ALT_STRCHR(a,b)	wcschr((a),(b))
# define ALT_STRCPY(a,b)	wcscpy((a),(b))
# define ALT_STRLEN(a)		wcslen(a)
#else
  const char *a, *e;
# define ALT_STRCHR(a,b)	strchr((a),(b))
# define ALT_STRCPY(a,b)	strcpy((a),(b))
# define ALT_STRLEN(a)		strlen(a)
#endif
  CHAR *aa, *ae;
  size_t len;

  adi = (alt_digits_t *) calloc (1, sizeof (alt_digits_t));
  if (!adi)
    return NULL;

  /* Compute number of alt_digits. */
  adi->num = 1;
  for (a = alt_digits; (e = ALT_STRCHR (a, ';')) != NULL; a = e + 1)
      ++adi->num;
  /* Allocate the `digit' array, which is an array of `num' pointers into
     `buffer'. */
  adi->digit = (CHAR **) calloc (adi->num, sizeof (CHAR **));
  if (!adi->digit)
    {
      free (adi);
      return NULL;
    }
  /* Compute memory required for `buffer'. */
#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
  len = mbstowcs (NULL, alt_digits, 0);
  if (len == (size_t) -1)
    {
      free (adi->digit);
      free (adi);
      return NULL;
    }
#else
  len = ALT_STRLEN (alt_digits);
#endif
  /* Allocate it. */
  adi->buffer = (CHAR *) malloc ((len + 1) * sizeof (CHAR));
  if (!adi->buffer)
    {
      free (adi->digit);
      free (adi);
      return NULL;
    }
  /* Store digits in it. */
#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
  mbstowcs (adi->buffer, alt_digits, len + 1);
#else
  ALT_STRCPY (adi->buffer, alt_digits);
#endif
  /* Store the pointers into `buffer' into the appropriate `digit' slot. */
  for (len = 0, aa = adi->buffer; (ae = STRCHR (aa, CQ(';'))) != NULL;
       ++len, aa = ae + 1)
    {
      *ae = '\0';
      adi->digit[len] = aa;
    }
  adi->digit[len] = aa;
  return adi;
}

static void
free_alt_digits (alt_digits_t *adi)
{
  free (adi->digit);
  free (adi->buffer);
  free (adi);
}

/* Return 0 if no alt_digit is available for a number.
   Return -1 if buffer size isn't sufficient to hold alternative digit.
   Return length of new digit otherwise. */
static int
conv_to_alt_digits (CHAR *buf, size_t bufsiz, unsigned num, alt_digits_t *adi)
{
  if (num < adi->num)
    {
      size_t len = STRLEN (adi->digit[num]);
      if (bufsiz < len)
      	return -1;
      STRCPY (buf, adi->digit[num]);
      return (int) len;
    }
  return 0;
}

static size_t __strftime (CHAR *, size_t, const CHAR *, const struct tm *,
			  era_info_t **, alt_digits_t **);

size_t
_DEFUN (strftime, (s, maxsize, format, tim_p),
	CHAR *__restrict s _AND
	size_t maxsize _AND
	_CONST CHAR *__restrict format _AND
	_CONST struct tm *__restrict tim_p)
{
  era_info_t *era_info = NULL;
  alt_digits_t *alt_digits = NULL;
  size_t ret = __strftime (s, maxsize, format, tim_p, &era_info, &alt_digits);
  if (era_info)
    free_era_info (era_info);
  if (alt_digits)
    free_alt_digits (alt_digits);
  return ret;
}

static size_t
__strftime (CHAR *s, size_t maxsize, const CHAR *format,
	    const struct tm *tim_p, era_info_t **era_info,
	    alt_digits_t **alt_digits)
#else /* !_WANT_C99_TIME_FORMATS */
# define __strftime(s,m,f,t,e,a)	strftime((s),(m),(f),(t))

size_t
_DEFUN (strftime, (s, maxsize, format, tim_p),
	CHAR *__restrict s _AND
	size_t maxsize _AND
	_CONST CHAR *__restrict format _AND
	_CONST struct tm *__restrict tim_p)
#endif /* !_WANT_C99_TIME_FORMATS */
{
  size_t count = 0;
  int len = 0;
  const CHAR *ctloc;
#if defined (MAKE_WCSFTIME) && !defined (__HAVE_LOCALE_INFO_EXTENDED__)
  CHAR ctlocbuf[CTLOCBUFLEN];
#endif
  size_t i, ctloclen;
  CHAR alt;
  CHAR pad;
  unsigned long width;

  struct lc_time_T *_CurrentTimeLocale = __get_current_time_locale ();
  for (;;)
    {
      while (*format && *format != CQ('%'))
	{
	  if (count < maxsize - 1)
	    s[count++] = *format++;
	  else
	    return 0;
	}
      if (*format == CQ('\0'))
	break;
      format++;
      pad = '\0';
      width = 0;

      /* POSIX-1.2008 feature: '0' and '+' modifiers require 0-padding with
         slightly different semantics. */
      if (*format == CQ('0') || *format == CQ('+'))
	pad = *format++;

      /* POSIX-1.2008 feature: A minimum field width can be specified. */
      if (*format >= CQ('1') && *format <= CQ('9'))
      	{
	  CHAR *fp;
	  width = STRTOUL (format, &fp, 10);
	  format = fp;
	}

      alt = CQ('\0');
      if (*format == CQ('E'))
	{
	  alt = *format++;
#ifdef _WANT_C99_TIME_FORMATS      
#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
	  if (!*era_info && *_CurrentTimeLocale->wera)
	    *era_info = get_era_info (tim_p, _CurrentTimeLocale->wera);
#else
	  if (!*era_info && *_CurrentTimeLocale->era)
	    *era_info = get_era_info (tim_p, _CurrentTimeLocale->era);
#endif
#endif /* _WANT_C99_TIME_FORMATS */
	}
      else if (*format == CQ('O'))
	{
	  alt = *format++;
#ifdef _WANT_C99_TIME_FORMATS      
#if defined (MAKE_WCSFTIME) && defined (__HAVE_LOCALE_INFO_EXTENDED__)
	  if (!*alt_digits && *_CurrentTimeLocale->walt_digits)
	    *alt_digits = get_alt_digits (_CurrentTimeLocale->walt_digits);
#else
	  if (!*alt_digits && *_CurrentTimeLocale->alt_digits)
	    *alt_digits = get_alt_digits (_CurrentTimeLocale->alt_digits);
#endif
#endif /* _WANT_C99_TIME_FORMATS */
	}

      switch (*format)
	{
	case CQ('a'):
	  _ctloc (wday[tim_p->tm_wday]);
	  for (i = 0; i < ctloclen; i++)
	    {
	      if (count < maxsize - 1)
		s[count++] = ctloc[i];
	      else
		return 0;
	    }
	  break;
	case CQ('A'):
	  _ctloc (weekday[tim_p->tm_wday]);
	  for (i = 0; i < ctloclen; i++)
	    {
	      if (count < maxsize - 1)
		s[count++] = ctloc[i];
	      else
		return 0;
	    }
	  break;
	case CQ('b'):
	case CQ('h'):
	  _ctloc (mon[tim_p->tm_mon]);
	  for (i = 0; i < ctloclen; i++)
	    {
	      if (count < maxsize - 1)
		s[count++] = ctloc[i];
	      else
		return 0;
	    }
	  break;
	case CQ('B'):
	  _ctloc (month[tim_p->tm_mon]);
	  for (i = 0; i < ctloclen; i++)
	    {
	      if (count < maxsize - 1)
		s[count++] = ctloc[i];
	      else
		return 0;
	    }
	  break;
	case CQ('c'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt == 'E' && *era_info && *_CurrentTimeLocale->era_d_t_fmt)
	    _ctloc (era_d_t_fmt);
	  else
#endif /* _WANT_C99_TIME_FORMATS */
	    _ctloc (c_fmt);
	  goto recurse;
	case CQ('r'):
	  _ctloc (ampm_fmt);
	  goto recurse;
	case CQ('x'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt == 'E' && *era_info && *_CurrentTimeLocale->era_d_fmt)
	    _ctloc (era_d_fmt);
	  else
#endif /* _WANT_C99_TIME_FORMATS */
	    _ctloc (x_fmt);
	  goto recurse;
	case CQ('X'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt == 'E' && *era_info && *_CurrentTimeLocale->era_t_fmt)
	    _ctloc (era_t_fmt);
	  else
#endif /* _WANT_C99_TIME_FORMATS */
	    _ctloc (X_fmt);
recurse:
	  if (*ctloc)
	    {
	      /* Recurse to avoid need to replicate %Y formation. */
	      len = __strftime (&s[count], maxsize - count, ctloc, tim_p,
				era_info, alt_digits);
	      if (len > 0)
		count += len;
	      else
		return 0;
	    }
	  break;
	case CQ('C'):
	  {
	    /* Examples of (tm_year + YEAR_BASE) that show how %Y == %C%y
	       with 32-bit int.
	       %Y		%C		%y
	       2147485547	21474855	47
	       10000		100		00
	       9999		99		99
	       0999		09		99
	       0099		00		99
	       0001		00		01
	       0000		00		00
	       -001		-0		01
	       -099		-0		99
	       -999		-9		99
	       -1000		-10		00
	       -10000		-100		00
	       -2147481748	-21474817	48

	       Be careful of both overflow and sign adjustment due to the
	       asymmetric range of years.
	    */
#ifdef _WANT_C99_TIME_FORMATS
	    if (alt == 'E' && *era_info)
	      len = snprintf (&s[count], maxsize - count, CQ("%" SFLG "s"),
			      (*era_info)->era_C);
	    else
#endif /* _WANT_C99_TIME_FORMATS */
	      {
		CHAR *fmt = CQ("%s%.*d");
		char *pos = "";
		int neg = tim_p->tm_year < -YEAR_BASE;
		int century = tim_p->tm_year >= 0
		  ? tim_p->tm_year / 100 + YEAR_BASE / 100
		  : abs (tim_p->tm_year + YEAR_BASE) / 100;
		if (pad) /* '0' or '+' */
		  {
		    fmt = CQ("%s%0.*d");
		    if (century >= 100 && pad == CQ('+'))
		      pos = "+";
		  }
		if (width < 2)
		  width = 2;
		len = snprintf (&s[count], maxsize - count, fmt,
				neg ? "-" : pos, width - neg, century);
	      }
            CHECK_LENGTH ();
	  }
	  break;
	case CQ('d'):
	case CQ('e'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt == CQ('O') && *alt_digits)
	    {
	      if (tim_p->tm_mday < 10)
	      	{
		  if (*format == CQ('d'))
		    {
		      if (maxsize - count < 2) return 0;
		      len = conv_to_alt_digits (&s[count], maxsize - count,
						0, *alt_digits);
		      CHECK_LENGTH ();
		    }
		  if (*format == CQ('e') || len == 0)
		    s[count++] = CQ(' ');
		}
	      len = conv_to_alt_digits (&s[count], maxsize - count,
					tim_p->tm_mday, *alt_digits);
	      CHECK_LENGTH ();
	      if (len > 0)
		break;
	    }
#endif /* _WANT_C99_TIME_FORMATS */
	  len = snprintf (&s[count], maxsize - count,
			  *format == CQ('d') ? CQ("%.2d") : CQ("%2d"),
			  tim_p->tm_mday);
	  CHECK_LENGTH ();
	  break;
	case CQ('D'):
	  /* %m/%d/%y */
	  len = snprintf (&s[count], maxsize - count,
			  CQ("%.2d/%.2d/%.2d"),
			  tim_p->tm_mon + 1, tim_p->tm_mday,
			  tim_p->tm_year >= 0 ? tim_p->tm_year % 100
			  : abs (tim_p->tm_year + YEAR_BASE) % 100);
          CHECK_LENGTH ();
	  break;
	case CQ('F'):
	  { /* %F is equivalent to "%+4Y-%m-%d", flags and width can change
	       that.  Recurse to avoid need to replicate %Y formation. */
	    CHAR fmtbuf[32], *fmt = fmtbuf;
	    
	    *fmt++ = CQ('%');
	    if (pad) /* '0' or '+' */
	      *fmt++ = pad;
	    else
	      *fmt++ = '+';
	    if (!pad)
	      width = 10;
	    if (width < 6)
	      width = 6;
	    width -= 6;
	    if (width)
	      {
		len = snprintf (fmt, fmtbuf + 32 - fmt, CQ("%lu"), width);
		if (len > 0)
		  fmt += len;
	      }
	    STRCPY (fmt, CQ("Y-%m-%d"));
	    len = __strftime (&s[count], maxsize - count, fmtbuf, tim_p,
			      era_info, alt_digits);
	    if (len > 0)
	      count += len;
	    else
	      return 0;
	  }
          break;
	case CQ('g'):
	  /* Be careful of both overflow and negative years, thanks to
		 the asymmetric range of years.  */
	  {
	    int adjust = iso_year_adjust (tim_p);
	    int year = tim_p->tm_year >= 0 ? tim_p->tm_year % 100
		: abs (tim_p->tm_year + YEAR_BASE) % 100;
	    if (adjust < 0 && tim_p->tm_year <= -YEAR_BASE)
		adjust = 1;
	    else if (adjust > 0 && tim_p->tm_year < -YEAR_BASE)
		adjust = -1;
	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
			    ((year + adjust) % 100 + 100) % 100);
            CHECK_LENGTH ();
	  }
          break;
	case CQ('G'):
	  {
	    /* See the comments for 'C' and 'Y'; this is a variable length
	       field.  Although there is no requirement for a minimum number
	       of digits, we use 4 for consistency with 'Y'.  */
	    int sign = tim_p->tm_year < -YEAR_BASE;
	    int adjust = iso_year_adjust (tim_p);
	    int century = tim_p->tm_year >= 0
	      ? tim_p->tm_year / 100 + YEAR_BASE / 100
	      : abs (tim_p->tm_year + YEAR_BASE) / 100;
	    int year = tim_p->tm_year >= 0 ? tim_p->tm_year % 100
	      : abs (tim_p->tm_year + YEAR_BASE) % 100;
	    if (adjust < 0 && tim_p->tm_year <= -YEAR_BASE)
	      sign = adjust = 1;
	    else if (adjust > 0 && sign)
	      adjust = -1;
	    year += adjust;
	    if (year == -1)
	      {
		year = 99;
		--century;
	      }
	    else if (year == 100)
	      {
		year = 0;
		++century;
	      }
	    CHAR fmtbuf[10], *fmt = fmtbuf;
	    /* int potentially overflows, so use unsigned instead.  */
	    unsigned p_year = century * 100 + year;
	    if (sign)
	      *fmt++ = CQ('-');
	    else if (pad == CQ('+') && p_year >= 10000)
	      {
		*fmt++ = CQ('+');
		sign = 1;
	      }
	    if (width && sign)
	      --width;
	    *fmt++ = CQ('%');
	    if (pad)
	      *fmt++ = CQ('0');
	    STRCPY (fmt, CQ(".*u"));
	    len = snprintf (&s[count], maxsize - count, fmtbuf, width, p_year);
            if (len < 0  ||  (count+=len) >= maxsize)
              return 0;
	  }
          break;
	case CQ('H'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt == CQ('O') && *alt_digits)
	    {
	      len = conv_to_alt_digits (&s[count], maxsize - count,
					tim_p->tm_hour, *alt_digits);
	      CHECK_LENGTH ();
	      if (len > 0)
		break;
	    }
#endif /* _WANT_C99_TIME_FORMATS */
	  /*FALLTHRU*/
	case CQ('k'):	/* newlib extension */
	  len = snprintf (&s[count], maxsize - count,
			  *format == CQ('k') ? CQ("%2d") : CQ("%.2d"),
			  tim_p->tm_hour);
          CHECK_LENGTH ();
	  break;
	case CQ('l'):	/* newlib extension */
	  if (alt == CQ('O'))
	    alt = CQ('\0');
	  /*FALLTHRU*/
	case CQ('I'):
	  {
	    register int  h12;
	    h12 = (tim_p->tm_hour == 0 || tim_p->tm_hour == 12)  ?
						12  :  tim_p->tm_hour % 12;
#ifdef _WANT_C99_TIME_FORMATS
	    if (alt != CQ('O') || !*alt_digits
		|| !(len = conv_to_alt_digits (&s[count], maxsize - count,
					       h12, *alt_digits)))
#endif /* _WANT_C99_TIME_FORMATS */
	      len = snprintf (&s[count], maxsize - count,
			      *format == CQ('I') ? CQ("%.2d") : CQ("%2d"), h12);
	    CHECK_LENGTH ();
	  }
	  break;
	case CQ('j'):
	  len = snprintf (&s[count], maxsize - count, CQ("%.3d"),
			  tim_p->tm_yday + 1);
          CHECK_LENGTH ();
	  break;
	case CQ('m'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt != CQ('O') || !*alt_digits
	      || !(len = conv_to_alt_digits (&s[count], maxsize - count,
					     tim_p->tm_mon + 1, *alt_digits)))
#endif /* _WANT_C99_TIME_FORMATS */
	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
			    tim_p->tm_mon + 1);
          CHECK_LENGTH ();
	  break;
	case CQ('M'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt != CQ('O') || !*alt_digits
	      || !(len = conv_to_alt_digits (&s[count], maxsize - count,
					     tim_p->tm_min, *alt_digits)))
#endif /* _WANT_C99_TIME_FORMATS */
	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
			    tim_p->tm_min);
          CHECK_LENGTH ();
	  break;
	case CQ('n'):
	  if (count < maxsize - 1)
	    s[count++] = CQ('\n');
	  else
	    return 0;
	  break;
	case CQ('p'):
	case CQ('P'):
	  _ctloc (am_pm[tim_p->tm_hour < 12 ? 0 : 1]);
	  for (i = 0; i < ctloclen; i++)
	    {
	      if (count < maxsize - 1)
		s[count++] = (*format == CQ('P') ? TOLOWER (ctloc[i])
						 : ctloc[i]);
	      else
		return 0;
	    }
	  break;
	case CQ('R'):
          len = snprintf (&s[count], maxsize - count, CQ("%.2d:%.2d"),
			  tim_p->tm_hour, tim_p->tm_min);
          CHECK_LENGTH ();
          break;
	case CQ('S'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt != CQ('O') || !*alt_digits
	      || !(len = conv_to_alt_digits (&s[count], maxsize - count,
					     tim_p->tm_sec, *alt_digits)))
#endif /* _WANT_C99_TIME_FORMATS */
	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
			    tim_p->tm_sec);
          CHECK_LENGTH ();
	  break;
	case CQ('t'):
	  if (count < maxsize - 1)
	    s[count++] = CQ('\t');
	  else
	    return 0;
	  break;
	case CQ('T'):
          len = snprintf (&s[count], maxsize - count, CQ("%.2d:%.2d:%.2d"),
			  tim_p->tm_hour, tim_p->tm_min, tim_p->tm_sec);
          CHECK_LENGTH ();
          break;
	case CQ('u'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt == CQ('O') && *alt_digits)
	    {
	      len = conv_to_alt_digits (&s[count], maxsize - count,
					tim_p->tm_wday == 0 ? 7
							    : tim_p->tm_wday,
					*alt_digits);
	      CHECK_LENGTH ();
	      if (len > 0)
		break;
	    }
#endif /* _WANT_C99_TIME_FORMATS */
          if (count < maxsize - 1)
            {
              if (tim_p->tm_wday == 0)
                s[count++] = CQ('7');
              else
                s[count++] = CQ('0') + tim_p->tm_wday;
            }
          else
            return 0;
          break;
	case CQ('U'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt != CQ('O') || !*alt_digits
	      || !(len = conv_to_alt_digits (&s[count], maxsize - count,
					     (tim_p->tm_yday + 7 -
					      tim_p->tm_wday) / 7,
					     *alt_digits)))
#endif /* _WANT_C99_TIME_FORMATS */
	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
			 (tim_p->tm_yday + 7 -
			  tim_p->tm_wday) / 7);
          CHECK_LENGTH ();
	  break;
	case CQ('V'):
	  {
	    int adjust = iso_year_adjust (tim_p);
	    int wday = (tim_p->tm_wday) ? tim_p->tm_wday - 1 : 6;
	    int week = (tim_p->tm_yday + 10 - wday) / 7;
	    if (adjust > 0)
		week = 1;
	    else if (adjust < 0)
		/* Previous year has 53 weeks if current year starts on
		   Fri, and also if current year starts on Sat and
		   previous year was leap year.  */
		week = 52 + (4 >= (wday - tim_p->tm_yday
				   - isleap (tim_p->tm_year
					     + (YEAR_BASE - 1
						- (tim_p->tm_year < 0
						   ? 0 : 2000)))));
#ifdef _WANT_C99_TIME_FORMATS
	    if (alt != CQ('O') || !*alt_digits
		|| !(len = conv_to_alt_digits (&s[count], maxsize - count,
					       week, *alt_digits)))
#endif /* _WANT_C99_TIME_FORMATS */
	      len = snprintf (&s[count], maxsize - count, CQ("%.2d"), week);
            CHECK_LENGTH ();
	  }
          break;
	case CQ('w'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt == CQ('O') && *alt_digits)
	    {
	      len = conv_to_alt_digits (&s[count], maxsize - count,
					tim_p->tm_wday, *alt_digits);
	      CHECK_LENGTH ();
	      if (len > 0)
		break;
	    }
#endif /* _WANT_C99_TIME_FORMATS */
	  if (count < maxsize - 1)
            s[count++] = CQ('0') + tim_p->tm_wday;
	  else
	    return 0;
	  break;
	case CQ('W'):
	  {
	    int wday = (tim_p->tm_wday) ? tim_p->tm_wday - 1 : 6;
	    wday = (tim_p->tm_yday + 7 - wday) / 7;
#ifdef _WANT_C99_TIME_FORMATS
	    if (alt != CQ('O') || !*alt_digits
		|| !(len = conv_to_alt_digits (&s[count], maxsize - count,
					       wday, *alt_digits)))
#endif /* _WANT_C99_TIME_FORMATS */
	      len = snprintf (&s[count], maxsize - count, CQ("%.2d"), wday);
            CHECK_LENGTH ();
	  }
	  break;
	case CQ('y'):
	    {
#ifdef _WANT_C99_TIME_FORMATS
	      if (alt == 'E' && *era_info)
		len = snprintf (&s[count], maxsize - count, CQ("%d"),
				(*era_info)->year);
	      else
#endif /* _WANT_C99_TIME_FORMATS */
		{
		  /* Be careful of both overflow and negative years, thanks to
		     the asymmetric range of years.  */
		  int year = tim_p->tm_year >= 0 ? tim_p->tm_year % 100
			     : abs (tim_p->tm_year + YEAR_BASE) % 100;
#ifdef _WANT_C99_TIME_FORMATS
		  if (alt != CQ('O') || !*alt_digits
		      || !(len = conv_to_alt_digits (&s[count], maxsize - count,
						     year, *alt_digits)))
#endif /* _WANT_C99_TIME_FORMATS */
		    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
				    year);
		}
              CHECK_LENGTH ();
	    }
	  break;
	case CQ('Y'):
#ifdef _WANT_C99_TIME_FORMATS
	  if (alt == 'E' && *era_info)
	    {
	      ctloc = (*era_info)->era_Y;
	      goto recurse;
	    }
	  else
#endif /* _WANT_C99_TIME_FORMATS */
	    {
	      CHAR fmtbuf[10], *fmt = fmtbuf;
	      int sign = tim_p->tm_year < -YEAR_BASE;
	      /* int potentially overflows, so use unsigned instead.  */
	      register unsigned year = (unsigned) tim_p->tm_year
				       + (unsigned) YEAR_BASE;
	      if (sign)
		{
		  *fmt++ = CQ('-');
		  year = UINT_MAX - year + 1;
		}
	      else if (pad == CQ('+') && year >= 10000)
		{
		  *fmt++ = CQ('+');
		  sign = 1;
		}
	      if (width && sign)
		--width;
	      *fmt++ = CQ('%');
	      if (pad)
		*fmt++ = CQ('0');
	      STRCPY (fmt, CQ(".*u"));
	      len = snprintf (&s[count], maxsize - count, fmtbuf, width,
			      year);
	      CHECK_LENGTH ();
	    }
	  break;
	case CQ('z'):
          if (tim_p->tm_isdst >= 0)
            {
	      long offset;

#if defined (__CYGWIN__)
	      /* Cygwin must check if the application has been built with or
		 without the extra tm members for backward compatibility, and
		 then use either that or the old method fetching from tzinfo.
		 Rather than pulling in the version check infrastructure, we
		 just call a Cygwin function. */
	      extern long __cygwin_gettzoffset (const struct tm *tmp);
	      offset = __cygwin_gettzoffset (tim_p);
#elif defined (__TM_GMTOFF)
	      offset = tim_p->__TM_GMTOFF;
#else
	      __tzinfo_type *tz = __gettzinfo ();
	      /* The sign of this is exactly opposite the envvar TZ.  We
		 could directly use the global _timezone for tm_isdst==0,
		 but have to use __tzrule for daylight savings.  */
	      offset = -tz->__tzrule[tim_p->tm_isdst > 0].offset;
#endif
	      len = snprintf (&s[count], maxsize - count, CQ("%+03ld%.2ld"),
			      offset / SECSPERHOUR,
			      labs (offset / SECSPERMIN) % 60L);
              CHECK_LENGTH ();
            }
          break;
	case CQ('Z'):
	  if (tim_p->tm_isdst >= 0)
	    {
	      size_t size;
	      const char *tznam;

	      TZ_LOCK;
#if defined (__CYGWIN__)
	      /* See above. */
	      extern const char *__cygwin_gettzname (const struct tm *tmp);
	      tznam = __cygwin_gettzname (tim_p);
#elif defined (__TM_ZONE)
	      tznam = tim_p->__TM_ZONE;
#else
	      tznam = _tzname[tim_p->tm_isdst > 0];
#endif
	      /* Note that in case of wcsftime this loop only works for
	         timezone abbreviations using the portable codeset (aka ASCII).
		 This seems to be the case, but if that ever changes, this
		 loop needs revisiting. */
	      size = strlen (tznam);
	      for (i = 0; i < size; i++)
		{
		  if (count < maxsize - 1)
		    s[count++] = tznam[i];
		  else
		    {
		      TZ_UNLOCK;
		      return 0;
		    }
		}
	      TZ_UNLOCK;
	    }
	  break;
	case CQ('%'):
	  if (count < maxsize - 1)
	    s[count++] = CQ('%');
	  else
	    return 0;
	  break;
	default:
	  return 0;
	}
      if (*format)
	format++;
      else
	break;
    }
  if (maxsize)
    s[count] = CQ('\0');

  return count;
}

/* The remainder of this file can serve as a regression test.  Compile
 *  with -D_REGRESSION_TEST.  */
#if defined(_REGRESSION_TEST)	/* [Test code:  */
 
/* This test code relies on ANSI C features, in particular on the ability
 * of adjacent strings to be pasted together into one string.  */
 
/* Test output buffer size (should be larger than all expected results) */
#define OUTSIZE	256
 
struct test {
	CHAR  *fmt;	/* Testing format */
	size_t  max;	/* Testing maxsize */
	size_t	ret;	/* Expected return value */
	CHAR  *out;	/* Expected output string */
	};
struct list {
	const struct tm  *tms;	/* Time used for these vectors */
	const struct test *vec;	/* Test vectors */
	int  cnt;		/* Number of vectors */
	};
 
const char  TZ[]="TZ=EST5EDT";
 
/* Define list of test inputs and expected outputs, for the given time zone
 * and time.  */
const struct tm  tm0 = {
	/* Tue Dec 30 10:53:47 EST 2008 (time_t=1230648827) */
	.tm_sec 	= 47,
	.tm_min 	= 53,
	.tm_hour	= 9,
	.tm_mday	= 30,
	.tm_mon 	= 11,
	.tm_year	= 108,
	.tm_wday	= 2,
	.tm_yday	= 364,
	.tm_isdst	= 0
	};
const struct test  Vec0[] = {
	/* Testing fields one at a time, expecting to pass, using exact
	 * allowed length as what is needed.  */
	/* Using tm0 for time: */
	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
	{ CQ("%a"), 3+1, EXP(CQ("Tue")) },
	{ CQ("%A"), 7+1, EXP(CQ("Tuesday")) },
	{ CQ("%b"), 3+1, EXP(CQ("Dec")) },
	{ CQ("%B"), 8+1, EXP(CQ("December")) },
	{ CQ("%c"), 24+1, EXP(CQ("Tue Dec 30 09:53:47 2008")) },
	{ CQ("%C"), 2+1, EXP(CQ("20")) },
	{ CQ("%d"), 2+1, EXP(CQ("30")) },
	{ CQ("%D"), 8+1, EXP(CQ("12/30/08")) },
	{ CQ("%e"), 2+1, EXP(CQ("30")) },
	{ CQ("%F"), 10+1, EXP(CQ("2008-12-30")) },
	{ CQ("%g"), 2+1, EXP(CQ("09")) },
	{ CQ("%G"), 4+1, EXP(CQ("2009")) },
	{ CQ("%h"), 3+1, EXP(CQ("Dec")) },
	{ CQ("%H"), 2+1, EXP(CQ("09")) },
	{ CQ("%I"), 2+1, EXP(CQ("09")) },
	{ CQ("%j"), 3+1, EXP(CQ("365")) },
	{ CQ("%k"), 2+1, EXP(CQ(" 9")) },
	{ CQ("%l"), 2+1, EXP(CQ(" 9")) },
	{ CQ("%m"), 2+1, EXP(CQ("12")) },
	{ CQ("%M"), 2+1, EXP(CQ("53")) },
	{ CQ("%n"), 1+1, EXP(CQ("\n")) },
	{ CQ("%p"), 2+1, EXP(CQ("AM")) },
	{ CQ("%r"), 11+1, EXP(CQ("09:53:47 AM")) },
	{ CQ("%R"), 5+1, EXP(CQ("09:53")) },
	{ CQ("%S"), 2+1, EXP(CQ("47")) },
	{ CQ("%t"), 1+1, EXP(CQ("\t")) },
	{ CQ("%T"), 8+1, EXP(CQ("09:53:47")) },
	{ CQ("%u"), 1+1, EXP(CQ("2")) },
	{ CQ("%U"), 2+1, EXP(CQ("52")) },
	{ CQ("%V"), 2+1, EXP(CQ("01")) },
	{ CQ("%w"), 1+1, EXP(CQ("2")) },
	{ CQ("%W"), 2+1, EXP(CQ("52")) },
	{ CQ("%x"), 8+1, EXP(CQ("12/30/08")) },
	{ CQ("%X"), 8+1, EXP(CQ("09:53:47")) },
	{ CQ("%y"), 2+1, EXP(CQ("08")) },
	{ CQ("%Y"), 4+1, EXP(CQ("2008")) },
	{ CQ("%z"), 5+1, EXP(CQ("-0500")) },
	{ CQ("%Z"), 3+1, EXP(CQ("EST")) },
	{ CQ("%%"), 1+1, EXP(CQ("%")) },
	#undef EXP
	};
/* Define list of test inputs and expected outputs, for the given time zone
 * and time.  */
const struct tm  tm1 = {
	/* Wed Jul  2 23:01:13 EDT 2008 (time_t=1215054073) */
	.tm_sec 	= 13,
	.tm_min 	= 1,
	.tm_hour	= 23,
	.tm_mday	= 2,
	.tm_mon 	= 6,
	.tm_year	= 108,
	.tm_wday	= 3,
	.tm_yday	= 183,
	.tm_isdst	= 1
	};
const struct test  Vec1[] = {
	/* Testing fields one at a time, expecting to pass, using exact
	 * allowed length as what is needed.  */
	/* Using tm1 for time: */
	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
	{ CQ("%a"), 3+1, EXP(CQ("Wed")) },
	{ CQ("%A"), 9+1, EXP(CQ("Wednesday")) },
	{ CQ("%b"), 3+1, EXP(CQ("Jul")) },
	{ CQ("%B"), 4+1, EXP(CQ("July")) },
	{ CQ("%c"), 24+1, EXP(CQ("Wed Jul  2 23:01:13 2008")) },
	{ CQ("%C"), 2+1, EXP(CQ("20")) },
	{ CQ("%d"), 2+1, EXP(CQ("02")) },
	{ CQ("%D"), 8+1, EXP(CQ("07/02/08")) },
	{ CQ("%e"), 2+1, EXP(CQ(" 2")) },
	{ CQ("%F"), 10+1, EXP(CQ("2008-07-02")) },
	{ CQ("%g"), 2+1, EXP(CQ("08")) },
	{ CQ("%G"), 4+1, EXP(CQ("2008")) },
	{ CQ("%h"), 3+1, EXP(CQ("Jul")) },
	{ CQ("%H"), 2+1, EXP(CQ("23")) },
	{ CQ("%I"), 2+1, EXP(CQ("11")) },
	{ CQ("%j"), 3+1, EXP(CQ("184")) },
	{ CQ("%k"), 2+1, EXP(CQ("23")) },
	{ CQ("%l"), 2+1, EXP(CQ("11")) },
	{ CQ("%m"), 2+1, EXP(CQ("07")) },
	{ CQ("%M"), 2+1, EXP(CQ("01")) },
	{ CQ("%n"), 1+1, EXP(CQ("\n")) },
	{ CQ("%p"), 2+1, EXP(CQ("PM")) },
	{ CQ("%r"), 11+1, EXP(CQ("11:01:13 PM")) },
	{ CQ("%R"), 5+1, EXP(CQ("23:01")) },
	{ CQ("%S"), 2+1, EXP(CQ("13")) },
	{ CQ("%t"), 1+1, EXP(CQ("\t")) },
	{ CQ("%T"), 8+1, EXP(CQ("23:01:13")) },
	{ CQ("%u"), 1+1, EXP(CQ("3")) },
	{ CQ("%U"), 2+1, EXP(CQ("26")) },
	{ CQ("%V"), 2+1, EXP(CQ("27")) },
	{ CQ("%w"), 1+1, EXP(CQ("3")) },
	{ CQ("%W"), 2+1, EXP(CQ("26")) },
	{ CQ("%x"), 8+1, EXP(CQ("07/02/08")) },
	{ CQ("%X"), 8+1, EXP(CQ("23:01:13")) },
	{ CQ("%y"), 2+1, EXP(CQ("08")) },
	{ CQ("%Y"), 4+1, EXP(CQ("2008")) },
	{ CQ("%z"), 5+1, EXP(CQ("-0400")) },
	{ CQ("%Z"), 3+1, EXP(CQ("EDT")) },
	{ CQ("%%"), 1+1, EXP(CQ("%")) },
	#undef EXP
	#define VEC(s)	s, sizeof(s)/sizeof(CHAR), sizeof(s)/sizeof(CHAR)-1, s
	#define EXP(s)	sizeof(s)/sizeof(CHAR), sizeof(s)/sizeof(CHAR)-1, s
	{ VEC(CQ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")) },
	{ CQ("0123456789%%%h:`~"), EXP(CQ("0123456789%Jul:`~")) },
	{ CQ("%R%h:`~ %x %w"), EXP(CQ("23:01Jul:`~ 07/02/08 3")) },
	#undef VEC
	#undef EXP
	};
 
#if YEAR_BASE == 1900  /* ( */
/* Checks for very large years.  YEAR_BASE value relied upon so that the
 * answer strings can be predetermined.
 * Years more than 4 digits are not mentioned in the standard for %C, so the
 * test for those cases are based on the design intent (which is to print the
 * whole number, being the century).  */
const struct tm  tmyr0 = {
	/* Wed Jul  2 23:01:13 EDT [HUGE#] */
	.tm_sec 	= 13,
	.tm_min 	= 1,
	.tm_hour	= 23,
	.tm_mday	= 2,
	.tm_mon 	= 6,
	.tm_year	= INT_MAX - YEAR_BASE/2,
	.tm_wday	= 3,
	.tm_yday	= 183,
	.tm_isdst	= 1
	};
#if INT_MAX == 32767
#  define YEAR	CQ("33717")		/* INT_MAX + YEAR_BASE/2 */
#  define CENT	CQ("337")
#  define Year	   CQ("17")
# elif INT_MAX == 2147483647
#  define YEAR	CQ("2147484597")
#  define CENT	CQ("21474845")
#  define Year	        CQ("97")
# elif INT_MAX == 9223372036854775807
#  define YEAR	CQ("9223372036854776757")
#  define CENT	CQ("92233720368547777")
#  define Year	                 CQ("57")
# else
#  error "Unrecognized INT_MAX value:  enhance me to recognize what you have"
#endif
const struct test  Vecyr0[] = {
	/* Testing fields one at a time, expecting to pass, using a larger
	 * allowed length than what is needed.  */
	/* Using tmyr0 for time: */
	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
	{ CQ("%C"), OUTSIZE, EXP(CENT) },
	{ CQ("%c"), OUTSIZE, EXP(CQ("Wed Jul  2 23:01:13 ")YEAR) },
	{ CQ("%D"), OUTSIZE, EXP(CQ("07/02/")Year) },
	{ CQ("%F"), OUTSIZE, EXP(YEAR CQ("-07-02")) },
	{ CQ("%x"), OUTSIZE, EXP(CQ("07/02/")Year) },
	{ CQ("%y"), OUTSIZE, EXP(Year) },
	{ CQ("%Y"), OUTSIZE, EXP(YEAR) },
	#undef EXP
	};
#undef YEAR
#undef CENT
#undef Year
/* Checks for very large negative years.  YEAR_BASE value relied upon so that
 * the answer strings can be predetermined.  */
const struct tm  tmyr1 = {
	/* Wed Jul  2 23:01:13 EDT [HUGE#] */
	.tm_sec 	= 13,
	.tm_min 	= 1,
	.tm_hour	= 23,
	.tm_mday	= 2,
	.tm_mon 	= 6,
	.tm_year	= INT_MIN,
	.tm_wday	= 3,
	.tm_yday	= 183,
	.tm_isdst	= 1
	};
#if INT_MAX == 32767
#  define YEAR	CQ("-30868")		/* INT_MIN + YEAR_BASE */
#  define CENT	CQ("-308")
#  define Year	    CQ("68")
# elif INT_MAX == 2147483647
#  define YEAR	CQ("-2147481748")
#  define CENT	CQ("-21474817")
#  define Year	         CQ("48")
# elif INT_MAX == 9223372036854775807
#  define YEAR	CQ("-9223372036854773908")
#  define CENT	CQ("-92233720368547739")
#  define Year	                  CQ("08")
# else
#  error "Unrecognized INT_MAX value:  enhance me to recognize what you have"
#endif
const struct test  Vecyr1[] = {
	/* Testing fields one at a time, expecting to pass, using a larger
	 * allowed length than what is needed.  */
	/* Using tmyr1 for time: */
	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
	{ CQ("%C"), OUTSIZE, EXP(CENT) },
	{ CQ("%c"), OUTSIZE, EXP(CQ("Wed Jul  2 23:01:13 ")YEAR) },
	{ CQ("%D"), OUTSIZE, EXP(CQ("07/02/")Year) },
	{ CQ("%F"), OUTSIZE, EXP(YEAR CQ("-07-02")) },
	{ CQ("%x"), OUTSIZE, EXP(CQ("07/02/")Year) },
	{ CQ("%y"), OUTSIZE, EXP(Year) },
	{ CQ("%Y"), OUTSIZE, EXP(YEAR) },
	#undef EXP
	};
#undef YEAR
#undef CENT
#undef Year
#endif /* YEAR_BASE ) */
 
/* Checks for years just over zero (also test for s=60).
 * Years less than 4 digits are not mentioned for %Y in the standard, so the
 * test for that case is based on the design intent.  */
const struct tm  tmyrzp = {
	/* Wed Jul  2 23:01:60 EDT 0007 */
	.tm_sec 	= 60,
	.tm_min 	= 1,
	.tm_hour	= 23,
	.tm_mday	= 2,
	.tm_mon 	= 6,
	.tm_year	= 7-YEAR_BASE,
	.tm_wday	= 3,
	.tm_yday	= 183,
	.tm_isdst	= 1
	};
#define YEAR	CQ("0007")	/* Design intent:  %Y=%C%y */
#define CENT	CQ("00")
#define Year	  CQ("07")
const struct test  Vecyrzp[] = {
	/* Testing fields one at a time, expecting to pass, using a larger
	 * allowed length than what is needed.  */
	/* Using tmyrzp for time: */
	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
	{ CQ("%C"), OUTSIZE, EXP(CENT) },
	{ CQ("%c"), OUTSIZE, EXP(CQ("Wed Jul  2 23:01:60 ")YEAR) },
	{ CQ("%D"), OUTSIZE, EXP(CQ("07/02/")Year) },
	{ CQ("%F"), OUTSIZE, EXP(YEAR CQ("-07-02")) },
	{ CQ("%x"), OUTSIZE, EXP(CQ("07/02/")Year) },
	{ CQ("%y"), OUTSIZE, EXP(Year) },
	{ CQ("%Y"), OUTSIZE, EXP(YEAR) },
	#undef EXP
	};
#undef YEAR
#undef CENT
#undef Year
/* Checks for years just under zero.
 * Negative years are not handled by the standard, so the vectors here are
 * verifying the chosen implemtation.  */
const struct tm  tmyrzn = {
	/* Wed Jul  2 23:01:00 EDT -004 */
	.tm_sec 	= 00,
	.tm_min 	= 1,
	.tm_hour	= 23,
	.tm_mday	= 2,
	.tm_mon 	= 6,
	.tm_year	= -4-YEAR_BASE,
	.tm_wday	= 3,
	.tm_yday	= 183,
	.tm_isdst	= 1
	};
#define YEAR	CQ("-004")
#define CENT	CQ("-0")
#define Year	  CQ("04")
const struct test  Vecyrzn[] = {
	/* Testing fields one at a time, expecting to pass, using a larger
	 * allowed length than what is needed.  */
	/* Using tmyrzn for time: */
	#define EXP(s)	sizeof(s)/sizeof(CHAR)-1, s
	{ CQ("%C"), OUTSIZE, EXP(CENT) },
	{ CQ("%c"), OUTSIZE, EXP(CQ("Wed Jul  2 23:01:00 ")YEAR) },
	{ CQ("%D"), OUTSIZE, EXP(CQ("07/02/")Year) },
	{ CQ("%F"), OUTSIZE, EXP(YEAR CQ("-07-02")) },
	{ CQ("%x"), OUTSIZE, EXP(CQ("07/02/")Year) },
	{ CQ("%y"), OUTSIZE, EXP(Year) },
	{ CQ("%Y"), OUTSIZE, EXP(YEAR) },
	#undef EXP
	};
#undef YEAR
#undef CENT
#undef Year
 
const struct list  ListYr[] = {
	{ &tmyrzp, Vecyrzp, sizeof(Vecyrzp)/sizeof(Vecyrzp[0]) },
	{ &tmyrzn, Vecyrzn, sizeof(Vecyrzn)/sizeof(Vecyrzn[0]) },
	#if YEAR_BASE == 1900
	{ &tmyr0, Vecyr0, sizeof(Vecyr0)/sizeof(Vecyr0[0]) },
	{ &tmyr1, Vecyr1, sizeof(Vecyr1)/sizeof(Vecyr1[0]) },
	#endif
	};
 
 
/* List of tests to be run */
const struct list  List[] = {
	{ &tm0, Vec0, sizeof(Vec0)/sizeof(Vec0[0]) },
	{ &tm1, Vec1, sizeof(Vec1)/sizeof(Vec1[0]) },
	};
 
#if defined(STUB_getenv_r)
char *
_getenv_r(struct _reent *p, const char *cp) { return getenv(cp); }
#endif
 
int
main(void)
{
int  i, l, errr=0, erro=0, tot=0;
const char  *cp;
CHAR  out[OUTSIZE];
size_t  ret;
 
/* Set timezone so that %z and %Z tests come out right */
cp = TZ;
if((i=putenv(cp)))  {
    printf( "putenv(%s) FAILED, ret %d\n", cp, i);
    return(-1);
    }
if(strcmp(getenv("TZ"),strchr(TZ,'=')+1))  {
    printf( "TZ not set properly in environment\n");
    return(-2);
    }
tzset();
 
#if defined(VERBOSE)
printf("_timezone=%d, _daylight=%d, _tzname[0]=%s, _tzname[1]=%s\n", _timezone, _daylight, _tzname[0], _tzname[1]);
{
long offset;
__tzinfo_type *tz = __gettzinfo ();
/* The sign of this is exactly opposite the envvar TZ.  We
   could directly use the global _timezone for tm_isdst==0,
   but have to use __tzrule for daylight savings.  */
printf("tz->__tzrule[0].offset=%d, tz->__tzrule[1].offset=%d\n", tz->__tzrule[0].offset, tz->__tzrule[1].offset);
}
#endif
 
/* Run all of the exact-length tests as-given--results should match */
for(l=0; l<sizeof(List)/sizeof(List[0]); l++)  {
    const struct list  *test = &List[l];
    for(i=0; i<test->cnt; i++)  {
	tot++;	/* Keep track of number of tests */
	ret = strftime(out, test->vec[i].max, test->vec[i].fmt, test->tms);
	if(ret != test->vec[i].ret)  {
	    errr++;
	    fprintf(stderr,
		"ERROR:  return %d != %d expected for List[%d].vec[%d]\n",
						ret, test->vec[i].ret, l, i);
	    }
	if(strncmp(out, test->vec[i].out, test->vec[i].max-1))  {
	    erro++;
	    fprintf(stderr,
		"ERROR:  \"%"SFLG"s\" != \"%"SFLG"s\" expected for List[%d].vec[%d]\n",
						out, test->vec[i].out, l, i);
	    }
	}
    }
 
/* Run all of the exact-length tests with the length made too short--expect to
 * fail.  */
for(l=0; l<sizeof(List)/sizeof(List[0]); l++)  {
    const struct list  *test = &List[l];
    for(i=0; i<test->cnt; i++)  {
	tot++;	/* Keep track of number of tests */
	ret = strftime(out, test->vec[i].max-1, test->vec[i].fmt, test->tms);
	if(ret != 0)  {
	    errr++;
	    fprintf(stderr,
		"ERROR:  return %d != %d expected for List[%d].vec[%d]\n",
						ret, 0, l, i);
	    }
	/* Almost every conversion puts out as many characters as possible, so
	 * go ahead and test the output even though have failed.  (The test
	 * times chosen happen to not hit any of the cases that fail this, so it
	 * works.)  */
	if(strncmp(out, test->vec[i].out, test->vec[i].max-1-1))  {
	    erro++;
	    fprintf(stderr,
		"ERROR:  \"%"SFLG"s\" != \"%"SFLG"s\" expected for List[%d].vec[%d]\n",
						out, test->vec[i].out, l, i);
	    }
	}
    }
 
/* Run all of the special year test cases */
for(l=0; l<sizeof(ListYr)/sizeof(ListYr[0]); l++)  {
    const struct list  *test = &ListYr[l];
    for(i=0; i<test->cnt; i++)  {
	tot++;	/* Keep track of number of tests */
	ret = strftime(out, test->vec[i].max, test->vec[i].fmt, test->tms);
	if(ret != test->vec[i].ret)  {
	    errr++;
	    fprintf(stderr,
		"ERROR:  return %d != %d expected for ListYr[%d].vec[%d]\n",
						ret, test->vec[i].ret, l, i);
	    }
	if(strncmp(out, test->vec[i].out, test->vec[i].max-1))  {
	    erro++;
	    fprintf(stderr,
		"ERROR:  \"%"SFLG"s\" != \"%"SFLG"s\" expected for ListYr[%d].vec[%d]\n",
						out, test->vec[i].out, l, i);
	    }
	}
    }
 
#define STRIZE(f)	#f
#define NAME(f)	STRIZE(f)
printf(NAME(strftime) "() test ");
if(errr || erro)  printf("FAILED %d/%d of", errr, erro);
  else    printf("passed");
printf(" %d test cases.\n", tot);
 
return(errr || erro);
}
#endif /* defined(_REGRESSION_TEST) ] */
@


1.23
log
@	* libc/time/clock.c (clock): Fix warnings about signed-unsigned
	comparisons.
	* libc/time/strftime.c (strftime): Likewise.
	* libc/time/strptime.c (match_string): Fix warning about discarding
	'restrict' qualifier from pointer target type.
@
text
@d1286 12
a1298 1
	      TZ_LOCK;
d1300 2
a1301 2
	         could directly use the global _timezone for tm_isdst==0,
	         but have to use __tzrule for daylight savings.  */
d1303 1
a1303 1
	      TZ_UNLOCK;
d1314 2
d1317 14
a1330 1
	      size = strlen(_tzname[tim_p->tm_isdst > 0]);
d1334 1
a1334 1
		    s[count++] = _tzname[tim_p->tm_isdst > 0][i];
@


1.22
log
@2013-11-25  Joel Sherrill <joel.sherrill@@oarcorp.com>

        * libc/iconv/lib/iconv.c, libc/time/strftime.c: Change "restrict<" to
        "restrict <" to fix formatting.
@
text
@d697 1
a697 1
  int i, len = 0;
d702 1
a702 1
  size_t ctloclen;
d1302 1
a1302 1
	      int size;
@


1.21
log
@2013-11-25  Joel Sherrill <joel.sherrill@@oarcorp.com>

	* libc/iconv/lib/iconv.c, libc/time/strftime.c: Change "restrict<" to
	"restrict <" to fix formatting.
@
text
@d27 1
a27 1
	size_t strftime(char *restrict<[s]>, size_t <[maxsize]>,
@


1.20
log
@2013-11-25  Sahil Patnayakuni <sahil.patnayakuni@@gmail.com>

	* libc/include/time.h (time): Add restrict keyword.
	* libc/include/wchar.h (wcsftime): Add restrict keyword.
	* libc/time/asctime_r.c (asctime_r): Same.
	* libc/time/gmtime_r.c (gmtime_r): Same.
	* libc/time/lcltime_r.c (lcltime_r): Same.
	* libc/time/strftime.c (strftime): Same.
	* libc/time/strptime.c (strptime): Same.
	* libc/sys/linux/linuxthreads/timer_create.c (timer_create): Same.
	* libc/sys/linux/linuxthreads/timer_settime.c (timer_settime): Same.
@
text
@d28 2
a29 2
			const char *restrict<[format]>,
                        const struct tm *restrict<[timp]>);
@


1.19
log
@	* libc/stdlib/btowc.c (btowc): Cast to avoid compiler warning.
	* libc/search/hash_buf.c (__get_buf): Initialize local vars to avoid
	compiler warning.
	* libc/stdio/fgets.c (_fgets_r): Ditto.
	* libc/time/strftime.c (strftime): Ditto.
@
text
@d27 3
a29 2
	size_t strftime(char *<[s]>, size_t <[maxsize]>,
			const char *<[format]>, const struct tm *<[timp]>);
d666 1
a666 1
	CHAR *s _AND
d668 2
a669 2
	_CONST CHAR *format _AND
	_CONST struct tm *tim_p)
d690 1
a690 1
	CHAR *s _AND
d692 2
a693 2
	_CONST CHAR *format _AND
	_CONST struct tm *tim_p)
@


1.18
log
@	* libc/time/strftime.c (get_era_info): Fix off-by-one error in month
	calculation.
@
text
@d696 1
a696 1
  int i, len;
@


1.18.2.1
log
@Update branch
@
text
@d696 1
a696 1
  int i, len = 0;
@


1.17
log
@	* libc/time/asctime_r.c (asctime_r): Replace call to sprintf with call
	to siprintf.
	* libc/time/strftime.c: Define snprintf to sniprintf in multibyte case.
	* libc/time/tzset_r.c: Define sscanf to siscanf.
@
text
@d429 1
a429 1
      stm.tm_mon = ERA_STRTOL (c + 1, &c, 10);
d443 1
a443 1
	  etm.tm_mon = 12;
d455 1
a455 1
	  etm.tm_mon = ERA_STRTOL (c + 1, &c, 10);
@


1.16
log
@	Extend locale support to maintain wide char values of native strings
	if __HAVE_LOCALE_INFO_EXTENDED__ is defined.
	* libc/include/langinfo.h (enum __nl_item): New type.  Define all
	native values accessible through nl_langinfo.  Define previously
	existing POSIX-compatible values as macros as well.
	* libc/include/stdlib.h (__mb_cur_max): Drop declaration.
	(__locale_mb_cur_max): Declare.
	(MB_CUR_MAX): Re-define calling __locale_mb_cur_max.
	* libc/locale/Makefile.am (ELIX_SOURCES): Add lctype.c.
	* libc/locale/Makefile.in: Regenerate.
	* libc/locale/lctype.c: New file to define and load LC_CTYPE category.
	* libc/locale/lctype.h: New file, matching header.
	* libc/locale/lmessages.c (_C_messages_locale): Add default values for
	wide char members.
	(__messages_load_locale): Add _C_messages_locale in call to
	__set_lc_messages_from_win.
	* libc/locale/lmessages.h (struct lc_messages_T): Add wide char members.
	* libc/locale/lmonetary.c (_C_monetary_locale):  Add default values for
	wide char members.
	(__monetary_load_locale): Add _C_monetary_locale in call to
	__set_lc_monetary_from_win.
	* libc/locale/lmonetary.h (struct lc_monetary_T): Add wide char members.
	Add numerical values for international currency formatting per
	POSIX-1.2008, if __HAVE_LOCALE_INFO_EXTENDED__ is defined.
	* libc/locale/lnumeric.c (_C_numeric_locale): Add default values for
	wide char members.
	(__numeric_load_locale): Add _C_numeric_locale in call to
	__set_lc_numeric_from_win.
	* libc/locale/lnumeric.h (struct lc_numeric_T): Add wide char members.
	* libc/locale/locale.c (loadlocale): Return doing nothing if category
	locale didn't change.  Convert category if chain to switch statement.
	Call __ctype_load_locale in LC_CTYPE case.
	(__locale_charset): Add (but disable for now) returning codeset from
	__get_current_ctype_locale.
	(__locale_mb_cur_max): Add (but disable for now) returning mb_cur_max
	from __get_current_ctype_locale.
	(__locale_msgcharset): Add returning codeset from
	__get_current_messages_locale.
	(_localeconv_r): Accommodate int_XXX values.
	* libc/locale/nl_langinfo.c (nl_ext): New array to define what is to
	be returned for non-POSIX values.
	(nl_Langinfo): Return correct codeset for each locale category.  Return
	extended values if __HAVE_LOCALE_INFO_EXTENDED__ is defined.
	* libc/locale/timelocal.c (_C_time_locale): Add default values for
	wide char members.
	(__time_load_locale): Add _C_time_locale in call to
	__set_lc_time_from_win.
	* libc/locale/timelocal.h (struct lc_time_T): Add wide char members.
	* libc/stdio/vfwprintf.c (_VFWPRINTF_R): Use wide char decimal point
	and thousands_sep if __HAVE_LOCALE_INFO_EXTENDED__ is defined.
	* libc/time/strftime.c: Rework to accommodate availability of wide char
	strings in LC_TIME category if __HAVE_LOCALE_INFO_EXTENDED__ is defined.
@
text
@d288 1
@


1.15
log
@* libc/Makefile.am (SUBDEFS): Add LIBC_POSIX_DEF.
(libc.info): Add posix.texi.
(libc.dvi): Likewise.
(stmp-posix): New.
(posix.texi): New.
(libc_TEXINFOS): Add posix.texi.
* libc/configure.in (LIBC_POSIX_LIB, LIBC_POSIX_DEF): Add
tests.
* libc/libc.texinfo: Include posix.texi
* libc/locale/locale.c: Fix texinfo typo.
* libc/time/strftime.c: Fix texinfo typo.

* libc/configure: Regenerate.
* libc/Makefile.in: Regenerate.
* libc/argz/Makefile.in: Regenerate.
* libc/ctype/Makefile.in: Regenerate.
* libc/errno/Makefile.in: Regenerate.
* libc/iconv/Makefile.in: Regenerate.
* libc/iconv/ccs/Makefile.in: Regenerate.
* libc/iconv/ccs/binary/Makefile.in: Regenerate.
* libc/iconv/ces/Makefile.in: Regenerate.
* libc/iconv/lib/Makefile.in: Regenerate.
* libc/locale/Makefile.in: Regenerate.
* libc/misc/Makefile.in: Regenerate.
* libc/posix/Makefile.in: Regenerate.
* libc/reent/Makefile.in: Regenerate.
* libc/search/Makefile.in: Regenerate.
* libc/signal/Makefile.in: Regenerate.
* libc/stdio/Makefile.in: Regenerate.
* libc/stdio64/Makefile.in: Regenerate.
* libc/stdlib/Makefile.in: Regenerate.
* libc/string/Makefile.in: Regenerate.
* libc/syscalls/Makefile.in: Regenerate.
* libc/time/Makefile.in: Regenerate.
* libc/unix/Makefile.in: Regenerate.
* libc/xdr/Makefile.in: Regenerate.
@
text
@d263 2
d305 17
a321 12
#  define CTLOCBUFLEN   256		/* Arbitrary big buffer size */
   const wchar_t *
   __ctloc (wchar_t *buf, const char *elem, size_t *len_ret)
   {
     buf[CTLOCBUFLEN - 1] = L'\0';
     *len_ret = mbstowcs (buf, elem, CTLOCBUFLEN - 1);
     if (*len_ret == (size_t) -1 )
       *len_ret = 0;
     return buf;
   }
#  define _ctloc(x) (ctloc = __ctloc (ctlocbuf, _CurrentTimeLocale->x, \
		     &ctloclen))
d390 3
d394 1
d396 7
d405 4
d422 1
a422 1
      offset = strtol (era, &c, 10);
d424 1
a424 1
      stm.tm_year = strtol (era, &c, 10) - YEAR_BASE;
d428 2
a429 2
      stm.tm_mon = strtol (c + 1, &c, 10);
      stm.tm_mday = strtol (c + 1, &c, 10);
d450 1
a450 1
	  etm.tm_year = strtol (era, &c, 10) - YEAR_BASE;
d454 2
a455 2
	  etm.tm_mon = strtol (c + 1, &c, 10);
	  etm.tm_mday = strtol (c + 1, &c, 10);
d481 2
a482 2
	  c = strchr (era, ':');
#ifdef MAKE_WCSFTIME
d498 1
a498 1
#ifdef MAKE_WCSFTIME
d501 1
a501 1
	  strncpy (ei->era_C, era, len);
d507 1
a507 1
	  c = strchr (era, ';');
d509 2
a510 2
	    c = strchr (era, '\0');
#ifdef MAKE_WCSFTIME
d528 1
a528 1
#ifdef MAKE_WCSFTIME
d531 1
a531 1
	  strncpy (ei->era_Y, era, len);
d538 1
a538 1
	era = strchr (era, ';');
d560 3
d564 1
d567 6
d574 4
d587 1
a587 1
  for (a = alt_digits; (e = strchr (a, ';')) != NULL; a = e + 1)
d598 1
a598 1
#ifdef MAKE_WCSFTIME
d607 1
a607 1
  len = strlen (alt_digits);
d618 1
a618 1
#ifdef MAKE_WCSFTIME
d621 1
a621 1
  strcpy (adi->buffer, alt_digits);
d697 1
a697 1
#ifdef MAKE_WCSFTIME
d739 4
d745 1
d752 4
d758 1
@


1.14
log
@	* libc/time/strftime.c: Add support for era and alt_digits data from
	LC_TIME locale category.  Conditionalize using _WANT_C99_TIME_FORMATS
	flag.
	(STRTOUL): Define differently for building strftime or wcsftime.
	(STRCPY): Ditto.
	(STRCHR): Ditto.
	(STRLEN): Ditto.
	(CHECK_LENGTH): Define to simplify code.
	(era_info_t): New type to store era info.
	(get_era_info): New function to fetch era info matching incoming
	struct tm.
	(free_era_info): New function to free era info.
	(alt_digits_t): New type to store alternative digits.
	(get_alt_digits): New function to convert alt_digits string into
	alt_digits_t structure.
	(free_alt_digits): New function to free alt_digits info.
	(conv_to_alt_digits): New function to convert unsigned value into
	alternative digits.
	(strftime): Conditionalize on _WANT_C99_TIME_FORMATS.  If
	_WANT_C99_TIME_FORMATS is defined, define as just a wrapper function
	providing era_info and alt_digits pointers and call ...
	(__strftime): Rename from strftime and make static if
	_WANT_C99_TIME_FORMATS is defined.  Add parameters for era_info and
	alt_digits pointers.  Handle conversion modifiers according to
	POSIX-1.2008.  Redefine %F and %Y according to POSIX.  Add default case
	to allow to bail out on invalid conversion specifiers.
	* libc/include/sys/config.h: Move Cygwin build flags to Cygwin's
	config.h.

	* libc/include/stdio.h: Remove __CYGWIN_USE_BIG_TYPES__ condition.
@
text
@d60 1
a60 1
`<<Wednesday>>', `<Thursday>>', `<<Friday>>', `<<Saturday>>'. [tm_wday]
@


1.13
log
@	* libc/locale/lmonetary.c (__monetary_load_locale): Take additional
	parameters for wide char to multibyte conversion.  Call
	__set_lc_monetary_from_win on Cygwin.
	* libc/locale/lmonetary.h: Make C++-safe.
	(__monetary_load_locale): Change declaration.
	* libc/locale/lnumeric.c (__numeric_load_locale): Take additional
	parameters for wide char to multibyte conversion.  Call
	__set_lc_numeric_from_win on Cygwin.
	* libc/locale/lnumeric.h: Make C++-safe.
	(__numeric_load_locale): Change declaration.
	* libc/locale/locale.c (lconv): De-constify for Cygwin.
	(__set_charset_from_locale): Rename from
	__set_charset_from_codepage.  Take locale as parameter instead of
	a codepage.
	(loadlocale): Allow "EUC-JP" for "EUCJP" and "EUC-KR" for "EUCKR".
	Change documnetation accordingly.  Enable LC_COLLATE, LC_MONETARY,
	LC_NUMERIC, and LC_TIME handling on Cygwin.
	(_localeconv_r): On Cygwin, copy values from monetary and numeric
	domain if change has been noted.
	* libc/locale/nl_langinfo.c (nl_langinfo): Accommodate change of
	am/pm layout in struct lc_time_T.
	* libc/locale/timelocal.c (_C_time_locale): Accommodate
	redefinition of am/pm members.
	(__time_load_locale): Take additional parameters for wide char
	to multibyte conversion.  Call __set_lc_time_from_win on Cygwin.
	* libc/locale/timelocal.h: Make C++-safe.
	(struct lc_time_T): Convert am and pm to a am_pm array for easier
	consumption by strftime and strptime.
	(__time_load_locale): Change declaration.
	* libc/time/strftime.c: Change documentation to reflect changes to
	strftime.  Remove locale constant strings in favor of access to
	locale-specifc data.
	(_ctloc): Define access method for locale-specifc data.
	(TOLOWER): Define for tolower conversion.
	(strftime): Throughout, convert locale-specific formats to use
	locale-specific data.  Add GNU-specific "%P" format.
	* libc/time/strptime.c: Remove locale constant strings in favor of
	access to locale-specifc data.
	(_ctloc): Define access method for locale-specifc data.
	(strptime): Throughout, convert locale-specific formats to use
	locale-specific data.
@
text
@d287 4
d298 4
d317 3
d375 275
d656 1
d665 3
a678 1

d681 3
d685 30
a714 3
      format++;
      if (*format == CQ('E') || *format == CQ('O'))
	format++;
d760 6
a765 1
	  _ctloc (c_fmt);
d771 6
a776 1
	  _ctloc (x_fmt);
d779 6
a784 1
	  _ctloc (X_fmt);
d789 4
a792 4
	      size_t adjust = strftime (&s[count], maxsize - count, ctloc,
					tim_p);
	      if (adjust > 0)
		count += adjust;
d819 25
a843 7
	    int neg = tim_p->tm_year < -YEAR_BASE;
	    int century = tim_p->tm_year >= 0
	      ? tim_p->tm_year / 100 + YEAR_BASE / 100
	      : abs (tim_p->tm_year + YEAR_BASE) / 100;
            len = snprintf (&s[count], maxsize - count, CQ("%s%.*d"),
                               neg ? CQ("-") : CQ(""), 2 - neg, century);
            if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d848 22
d871 3
a873 3
			*format == CQ('d') ? CQ("%.2d") : CQ("%2d"),
			tim_p->tm_mday);
	  if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d878 5
a882 5
			CQ("%.2d/%.2d/%.2d"),
			tim_p->tm_mon + 1, tim_p->tm_mday,
			tim_p->tm_year >= 0 ? tim_p->tm_year % 100
			: abs (tim_p->tm_year + YEAR_BASE) % 100);
          if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d885 25
a909 6
	  { /* %F is equivalent to "%Y-%m-%d" */
	    /* Recurse to avoid need to replicate %Y formation. */
	    size_t adjust = strftime (&s[count], maxsize - count,
				      CQ("%Y-%m-%d"), tim_p);
	    if (adjust > 0)
	      count += adjust;
d926 2
a927 2
		       ((year + adjust) % 100 + 100) % 100);
            if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d935 1
a935 1
	    int neg = tim_p->tm_year < -YEAR_BASE;
d943 2
a944 2
	      neg = adjust = 1;
	    else if (adjust > 0 && neg)
d957 17
a973 2
            len = snprintf (&s[count], maxsize - count, CQ("%s%.*d%.2d"),
                               neg ? CQ("-") : CQ(""), 2 - neg, century, year);
d979 11
d992 3
a994 3
			*format == CQ('k') ? CQ("%2d") : CQ("%.2d"),
			tim_p->tm_hour);
          if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d996 4
a1000 1
	case CQ('l'):	/* newlib extension */
d1005 8
a1012 4
	    len = snprintf (&s[count], maxsize - count,
			*format == CQ('I') ? CQ("%.2d") : CQ("%2d"),
			h12);
	    if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1017 2
a1018 2
			tim_p->tm_yday + 1);
          if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1021 8
a1028 3
	  len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
			tim_p->tm_mon + 1);
          if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1031 8
a1038 3
	  len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
			tim_p->tm_min);
          if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1060 2
a1061 2
			tim_p->tm_hour, tim_p->tm_min);
          if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1064 8
a1071 3
	  len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
			tim_p->tm_sec);
          if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1081 2
a1082 2
			tim_p->tm_hour, tim_p->tm_min, tim_p->tm_sec);
          if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1085 12
d1108 11
a1118 4
	  len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
		       (tim_p->tm_yday + 7 -
			tim_p->tm_wday) / 7);
          if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1136 7
a1142 2
	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"), week);
            if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1146 10
d1164 8
a1171 3
	    len = snprintf (&s[count], maxsize - count, CQ("%.2d"),
			(tim_p->tm_yday + 7 - wday) / 7);
            if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1176 20
a1195 6
	      /* Be careful of both overflow and negative years, thanks to
		 the asymmetric range of years.  */
	      int year = tim_p->tm_year >= 0 ? tim_p->tm_year % 100
		: abs (tim_p->tm_year + YEAR_BASE) % 100;
	      len = snprintf (&s[count], maxsize - count, CQ("%.2d"), year);
              if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1199 34
a1232 15
	  /* An implementation choice is to have %Y match %C%y, so that it
	   * gives at least 4 digits, with leading zeros as needed.  */
	  if(tim_p->tm_year <= INT_MAX-YEAR_BASE)  {
	    /* For normal, non-overflow case.  */
	    len = snprintf (&s[count], maxsize - count, CQ("%04d"),
				tim_p->tm_year + YEAR_BASE);
	  }
	  else  {
	    /* int would overflow, so use unsigned instead.  */
	    register unsigned year;
	    year = (unsigned) tim_p->tm_year + (unsigned) YEAR_BASE;
	    len = snprintf (&s[count], maxsize - count, CQ("%04u"),
				tim_p->tm_year + YEAR_BASE);
	  }
          if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1246 3
a1248 3
			offset / SECSPERHOUR,
			labs (offset / SECSPERMIN) % 60L);
              if (len < 0  ||  (count+=len) >= maxsize)  return 0;
d1276 2
d1289 1
a1289 1
 
@


1.12
log
@	* libc/stdio/swprintf.c (_swprintf_r, swprintf):
	correct how terminating L'\0' is added;
	change return to match standard for when output does not fit;
	some corrections and enhancements to the docs.
	* libc/stdio/vswprintf.c (_vswprintf_r):  ditto, except for docs.
	* libc/stdio/vfwprintf.c:  some corrections to the docs and some
	enhancements to comments.  (No code changes.)
	* libc/time/strftime.c:  Correct some problems that made wcsftime()
	not work correctly:  work properly with swprintf returns that are
	different from snprintf returns, correct test vector lengths for
	when sizeof(wchar_t) > 1.
	* libc/stdio/sprintf.c:  Some documentation and comment corrections and
	enhancements to match those done to swprintf.c.
@
text
@d55 1
a55 1
A three-letter abbreviation for the day of the week. [tm_wday]
d58 3
a60 3
The full name for the day of the week, one of `<<Sunday>>',
`<<Monday>>', `<<Tuesday>>', `<<Wednesday>>', `<<Thursday>>',
`<<Friday>>', or `<<Saturday>>'. [tm_wday]
d63 1
a63 1
A three-letter abbreviation for the month name. [tm_mon]
d66 2
a67 1
The full name of the month, one of `<<January>>', `<<February>>',
d73 2
a74 3
A string representing the complete date and time, in the form
`<<"%a %b %e %H:%M:%S %Y">>' (example "Mon Apr 01 13:13:13
1992"). [tm_sec, tm_min, tm_hour, tm_mday, tm_mon, tm_year, tm_wday]
d96 1
a96 2
certain modifiers <<x>>.  But in the "C" locale supported by newlib,
it is ignored, and treated as %<<x>>.
d117 1
a117 2
A three-letter abbreviation for the month name (synonym for
"%b"). [tm_mon]
d151 1
a151 2
for certain modifiers <<x>>.  But in the "C" locale supported by newlib, it
is ignored, and treated as %<<x>>.
d154 5
a158 1
Either `<<AM>>' or `<<PM>>' as appropriate. [tm_hour]
d161 3
a163 2
The 12-hour time, to the second.  Equivalent to "%I:%M:%S %p". [tm_sec,
tm_min, tm_hour]
d203 2
a204 1
A string representing the complete date, equivalent to "%m/%d/%y".
d208 2
a209 2
A string representing the full time of day (hours, minutes, and
seconds), equivalent to "%H:%M:%S". [tm_sec, tm_min, tm_hour]
d269 2
d272 1
d285 2
d293 1
d295 12
a316 12
static _CONST CHAR *_CONST dname[7] =
{CQ("Sunday"), CQ("Monday"), CQ("Tuesday"), CQ("Wednesday"),
 CQ("Thursday"), CQ("Friday"), CQ("Saturday")};

static _CONST int mname_len[12] =
{7, 8, 5, 5, 3, 4, 4, 6, 9, 7, 8, 8};

static _CONST CHAR *_CONST mname[12] =
{CQ("January"), CQ("February"), CQ("March"), CQ("April"),
 CQ("May"), CQ("June"), CQ("July"), CQ("August"),
 CQ("September"), CQ("October"), CQ("November"), CQ("December")};

d373 5
d379 1
d400 2
a401 1
	  for (i = 0; i < 3; i++)
d404 1
a404 2
		s[count++] =
		  dname[tim_p->tm_wday][i];
d410 2
a411 1
	  for (i = 0; i < dname_len[tim_p->tm_wday]; i++)
d414 1
a414 2
		s[count++] =
		  dname[tim_p->tm_wday][i];
d421 2
a422 1
	  for (i = 0; i < 3; i++)
d425 1
a425 2
		s[count++] =
		  mname[tim_p->tm_mon][i];
d431 2
a432 1
	  for (i = 0; i < mname_len[tim_p->tm_mon]; i++)
d435 1
a435 2
		s[count++] =
		  mname[tim_p->tm_mon][i];
d441 21
a461 9
	  {
	    /* Recurse to avoid need to replicate %Y formation. */
	    size_t adjust = strftime (&s[count], maxsize - count,
				      CQ("%a %b %e %H:%M:%S %Y"), tim_p);
	    if (adjust > 0)
	      count += adjust;
	    else
	      return 0;
	  }
a501 1
	case CQ('x'):
d611 3
a613 1
	  if (count < maxsize - 1)
d615 3
a617 2
	      if (tim_p->tm_hour < 12)
		s[count++] = CQ('A');
d619 1
a619 5
		s[count++] = CQ('P');
	    }
	  if (count < maxsize - 1)
	    {
	      s[count++] = CQ('M');
a620 16
	  else
	    return 0;
	  break;
	case CQ('r'):
	  {
	    register int  h12;
	    h12 = (tim_p->tm_hour == 0 || tim_p->tm_hour == 12)  ?
						12  :  tim_p->tm_hour % 12;
	    len = snprintf (&s[count], maxsize - count,
			CQ("%.2d:%.2d:%.2d %cM"),
			h12, 
			tim_p->tm_min,
			tim_p->tm_sec,
			(tim_p->tm_hour < 12)  ?  CQ('A') :  CQ('P'));
	    if (len < 0  ||  (count+=len) >= maxsize)  return 0;
	  }
a638 1
	case CQ('X'):
@


1.11
log
@	* libc/time/strftime.c:  Adapt for dual-purpose use so not only
	defines strftime(), but can also define wcsftime(); add optional
	test package; speed up %Y handling.
	* libc/time/wcsftime.c:  New file, defining wcsftime() (albeit
	indirectly by including strftime.c) and its documentation.
	* libc/time/time.tex:  Enhance tm_isdst explanation, change strftime
	description to match modified description in strftime.c
	* libc/time/Makefile.am:  Add wcsftime.c and wcsftime.def.  Add a rule
	so that wcsftime.o gets rebuilt when strftime changes.
	* libc/time/Makefile.in:  Regenerate.
	* libc/include/wchar.h (wcsftime): Declare.
@
text
@d254 4
d363 1
a363 1
  int i;
d462 1
a462 1
            count += snprintf (&s[count], maxsize - count, CQ("%s%.*d"),
d464 1
a464 2
            if (count >= maxsize)
              return 0;
d469 1
a469 1
	  count += snprintf (&s[count], maxsize - count,
d472 1
a472 1
	  if (count >= maxsize)  return 0;
d477 1
a477 1
	  count += snprintf (&s[count], maxsize - count,
d482 1
a482 1
          if (count >= maxsize)  return 0;
d506 1
a506 1
	    count += snprintf (&s[count], maxsize - count, CQ("%.2d"),
d508 1
a508 1
            if (count >= maxsize)  return 0;
d538 1
a538 1
            count += snprintf (&s[count], maxsize - count, CQ("%s%.*d%.2d"),
d540 1
a540 1
            if (count >= maxsize)
d546 1
a546 1
	  count += snprintf (&s[count], maxsize - count,
d549 1
a549 1
          if (count >= maxsize)  return 0;
d557 1
a557 1
	    count += snprintf (&s[count], maxsize - count,
d560 1
a560 1
	    if (count >= maxsize)  return 0;
d564 1
a564 1
	  count += snprintf (&s[count], maxsize - count, CQ("%.3d"),
d566 1
a566 1
          if (count >= maxsize)  return 0;
d569 1
a569 1
	  count += snprintf (&s[count], maxsize - count, CQ("%.2d"),
d571 1
a571 1
          if (count >= maxsize)  return 0;
d574 1
a574 1
	  count += snprintf (&s[count], maxsize - count, CQ("%.2d"),
d576 1
a576 1
          if (count >= maxsize)  return 0;
d604 1
a604 1
	    count += snprintf (&s[count], maxsize - count,
d610 1
a610 1
	    if (count >= maxsize)  return 0;
d614 1
a614 1
          count += snprintf (&s[count], maxsize - count, CQ("%.2d:%.2d"),
d616 1
a616 1
          if (count >= maxsize)  return 0;
d619 1
a619 1
	  count += snprintf (&s[count], maxsize - count, CQ("%.2d"),
d621 1
a621 1
          if (count >= maxsize)  return 0;
d631 1
a631 1
          count += snprintf (&s[count], maxsize - count, CQ("%.2d:%.2d:%.2d"),
d633 1
a633 1
          if (count >= maxsize)  return 0;
d647 1
a647 1
	  count += snprintf (&s[count], maxsize - count, CQ("%.2d"),
d650 1
a650 1
          if (count >= maxsize)  return 0;
d668 2
a669 2
	    count += snprintf (&s[count], maxsize - count, CQ("%.2d"), week);
            if (count >= maxsize)  return 0;
d681 1
a681 1
	    count += snprintf (&s[count], maxsize - count, CQ("%.2d"),
d683 1
a683 1
            if (count >= maxsize)  return 0;
d692 2
a693 2
	      count += snprintf (&s[count], maxsize - count, CQ("%.2d"), year);
              if (count >= maxsize)  return 0;
d701 1
a701 1
	    count += snprintf (&s[count], maxsize - count, CQ("%04d"),
d708 1
a708 1
	    count += snprintf (&s[count], maxsize - count, CQ("%04u"),
d711 1
a711 1
          if (count >= maxsize)  return 0;
d724 1
a724 1
	      count += snprintf (&s[count], maxsize - count, CQ("%+03ld%.2ld"),
d727 1
a727 1
              if (count >= maxsize)  return 0;
d809 1
a809 1
	#define EXP(s)	sizeof(s)-1, s
d868 2
a869 2
	/* Using tm0 for time: */
	#define EXP(s)	sizeof(s)-1, s
d910 2
a911 2
	#define VEC(s)	s, sizeof(s), sizeof(s)-1, s
	#define EXP(s)	sizeof(s), sizeof(s)-1, s
d914 1
d956 1
a956 1
	#define EXP(s)	sizeof(s)-1, s
d1002 1
a1002 1
	#define EXP(s)	sizeof(s)-1, s
d1039 1
a1039 1
	#define EXP(s)	sizeof(s)-1, s
d1074 1
a1074 1
	#define EXP(s)	sizeof(s)-1, s
@


1.10
log
@
2005-02-25  Eric Blake  <ebb9@@byu.net>

        * libc/include/time.h (__tzrule_struct): Make offset long, since
        a 16-bit int overflows on a 12-hour offset.
        * libc/sys/linux/include/time.h: Ditto.
        * libc/time/mktime.c (mktime): Use new type of __tzrule.offset.
        * libc/time/mktm_r.c: Ditto.
        * libc/time/gettzinfo.c: Ditto.
        * libc/time/strftime.c (strftime): Fix '%x' to deal with negative
        years.  Fix '%z' to use long, not int.
@
text
@d1 3
d8 1
d20 1
a20 1
<<strftime>>---flexible calendar time formatter
d135 1
a135 1
digit (from `<<0>>' to `<<23>>'). Non-POSIX extension. [tm_hour]
d139 1
a139 1
digit (from `<<1>>' to `<<12>>'). Non-POSIX extension. [tm_hour]
d210 1
d261 1
d263 25
d292 3
a294 3
static _CONST char *_CONST dname[7] =
{"Sunday", "Monday", "Tuesday", "Wednesday",
 "Thursday", "Friday", "Saturday"};
d299 4
a302 4
static _CONST char *_CONST mname[12] =
{"January", "February", "March", "April",
 "May", "June", "July", "August", "September", "October", "November",
 "December"};
d353 1
a353 1
	char *s _AND
d355 1
a355 1
	_CONST char *format _AND
d363 1
a363 1
      while (*format && *format != '%')
d371 1
a371 1
      if (*format == '\0')
d375 1
a375 1
      if (*format == 'E' || *format == 'O')
d380 1
a380 1
	case 'a':
d390 1
a390 1
	case 'A':
d400 2
a401 2
	case 'b':
	case 'h':
d411 1
a411 1
	case 'B':
d421 1
a421 1
	case 'c':
d423 1
a423 1
	    /* Length is not known because of %C%y, so recurse. */
d425 1
a425 1
				      "%a %b %e %H:%M:%S %C%y", tim_p);
d432 1
a432 1
	case 'C':
d458 2
a459 2
            count += snprintf (&s[count], maxsize - count, "%s%.*d",
                               neg ? "-" : "", 2 - neg, century);
d464 6
a469 10
	case 'd':
	case 'e':
	  if (count < maxsize - 2)
	    {
	      sprintf (&s[count], *format == 'd' ? "%.2d" : "%2d",
		       tim_p->tm_mday);
	      count += 2;
	    }
	  else
	    return 0;
d471 2
a472 2
	case 'D':
	case 'x':
d474 10
a483 14
	  if (count < maxsize - 8)
	    {
	      sprintf (&s[count], "%.2d/%.2d/%.2d",
		       tim_p->tm_mon + 1, tim_p->tm_mday,
		       tim_p->tm_year >= 0 ? tim_p->tm_year % 100
		       : abs (tim_p->tm_year + YEAR_BASE) % 100);
	      count += 8;
	    }
	  else
	    return 0;
	  break;
        case 'F':
	  {
	    /* Length is not known because of %C%y, so recurse. */
d485 1
a485 1
				      "%C%y-%m-%d", tim_p);
d492 2
a493 4
        case 'g':
	  if (count < maxsize - 2)
	    {
	      /* Be careful of both overflow and negative years, thanks to
d495 3
a497 2
	      int adjust = iso_year_adjust (tim_p);
	      int year = tim_p->tm_year >= 0 ? tim_p->tm_year % 100
d499 1
a499 1
	      if (adjust < 0 && tim_p->tm_year <= -YEAR_BASE)
d501 1
a501 1
	      else if (adjust > 0 && tim_p->tm_year < -YEAR_BASE)
d503 1
a503 1
	      sprintf (&s[count], "%.2d",
d505 2
a506 4
	      count += 2;
	    }
	  else
	    return 0;
d508 1
a508 1
        case 'G':
d535 2
a536 2
            count += snprintf (&s[count], maxsize - count, "%s%.*d%.2d",
                               neg ? "-" : "", 2 - neg, century, year);
d541 6
a546 10
	case 'H':
	case 'k':
	  if (count < maxsize - 2)
	    {
	      sprintf (&s[count], *format == 'k' ? "%2d" : "%.2d",
		       tim_p->tm_hour);
	      count += 2;
	    }
	  else
	    return 0;
d548 11
a558 29
	case 'I':
	case 'l':
	  if (count < maxsize - 2)
	    {
	      if (tim_p->tm_hour == 0 ||
		  tim_p->tm_hour == 12)
		{
		  s[count++] = '1';
		  s[count++] = '2';
		}
	      else
		{
		  sprintf (&s[count], *format == 'I' ? "%.2d" : "%2d",
			   tim_p->tm_hour % 12);
		  count += 2;
		}
	    }
	  else
	    return 0;
	  break;
	case 'j':
	  if (count < maxsize - 3)
	    {
	      sprintf (&s[count], "%.3d",
		       tim_p->tm_yday + 1);
	      count += 3;
	    }
	  else
	    return 0;
d560 14
a573 9
	case 'm':
	  if (count < maxsize - 2)
	    {
	      sprintf (&s[count], "%.2d",
		       tim_p->tm_mon + 1);
	      count += 2;
	    }
	  else
	    return 0;
d575 3
a577 7
	case 'M':
	  if (count < maxsize - 2)
	    {
	      sprintf (&s[count], "%.2d",
		       tim_p->tm_min);
	      count += 2;
	    }
d581 1
a581 1
	case 'n':
a582 6
	    s[count++] = '\n';
	  else
	    return 0;
	  break;
	case 'p':
	  if (count < maxsize - 2)
d585 1
a585 1
		s[count++] = 'A';
d587 1
a587 3
		s[count++] = 'P';

	      s[count++] = 'M';
d589 1
a589 5
	  else
	    return 0;
	  break;
	case 'r':
	  if (count < maxsize - 11)
d591 1
a591 26
	      if (tim_p->tm_hour == 0 ||
		  tim_p->tm_hour == 12)
		{
		  s[count++] = '1';
		  s[count++] = '2';
		}
	      else
		{
		  sprintf (&s[count], "%.2d", tim_p->tm_hour % 12);
		  count += 2;
		}
	      s[count++] = ':';
	      sprintf (&s[count], "%.2d",
		       tim_p->tm_min);
	      count += 2;
	      s[count++] = ':';
	      sprintf (&s[count], "%.2d",
		       tim_p->tm_sec);
	      count += 2;
	      s[count++] = ' ';
	      if (tim_p->tm_hour < 12)
		s[count++] = 'A';
	      else
		s[count++] = 'P';

	      s[count++] = 'M';
d596 18
a613 8
        case 'R':
          if (count < maxsize - 5)
            {
              sprintf (&s[count], "%.2d:%.2d", tim_p->tm_hour, tim_p->tm_min);
              count += 5;
            }
          else
            return 0;
d615 4
a618 9
	case 'S':
	  if (count < maxsize - 2)
	    {
	      sprintf (&s[count], "%.2d",
		       tim_p->tm_sec);
	      count += 2;
	    }
	  else
	    return 0;
d620 1
a620 1
	case 't':
d622 1
a622 1
	    s[count++] = '\t';
d626 5
a630 10
        case 'T':
        case 'X':
          if (count < maxsize - 8)
            {
              sprintf (&s[count], "%.2d:%.2d:%.2d", tim_p->tm_hour,
                       tim_p->tm_min, tim_p->tm_sec);
              count += 8;
            }
          else
            return 0;
d632 1
a632 1
        case 'u':
d636 1
a636 1
                s[count++] = '7';
d638 1
a638 1
                s[count++] = '0' + tim_p->tm_wday;
d643 2
a644 4
	case 'U':
	  if (count < maxsize - 2)
	    {
	      sprintf (&s[count], "%.2d",
d647 1
a647 4
	      count += 2;
	    }
	  else
	    return 0;
d649 6
a654 7
        case 'V':
	  if (count < maxsize - 2)
	    {
	      int adjust = iso_year_adjust (tim_p);
	      int wday = (tim_p->tm_wday) ? tim_p->tm_wday - 1 : 6;
	      int week = (tim_p->tm_yday + 10 - wday) / 7;
	      if (adjust > 0)
d656 1
a656 1
	      else if (adjust < 0)
d665 3
a667 5
	      sprintf (&s[count], "%.2d", week);
	      count += 2;
	    }
	  else
	    return 0;
d669 1
a669 1
	case 'w':
d671 1
a671 1
            s[count++] = '0' + tim_p->tm_wday;
d675 7
a681 10
	case 'W':
	  if (count < maxsize - 2)
	    {
	      int wday = (tim_p->tm_wday) ? tim_p->tm_wday - 1 : 6;
	      sprintf (&s[count], "%.2d",
		       (tim_p->tm_yday + 7 - wday) / 7);
	      count += 2;
	    }
	  else
	    return 0;
d683 1
a683 2
	case 'y':
	  if (count < maxsize - 2)
d689 2
a690 2
	      sprintf (&s[count], "%.2d", year);
	      count += 2;
a691 2
	  else
	    return 0;
d693 14
a706 9
	case 'Y':
	  {
	    /* Length is not known because of %C%y, so recurse. */
	    size_t adjust = strftime (&s[count], maxsize - count,
				      "%C%y", tim_p);
	    if (adjust > 0)
	      count += adjust;
	    else
	      return 0;
d708 1
d710 1
a710 1
        case 'z':
d713 12
a724 16
	      if (count < maxsize - 5)
		{
		  long offset;
		  __tzinfo_type *tz = __gettzinfo ();
		  TZ_LOCK;
		  /* The sign of this is exactly opposite the envvar TZ.  We
		     could directly use the global _timezone for tm_isdst==0,
		     but have to use __tzrule for daylight savings.  */
		  offset = -tz->__tzrule[tim_p->tm_isdst > 0].offset;
		  TZ_UNLOCK;
		  sprintf (&s[count], "%+03ld%.2ld", offset / SECSPERHOUR,
			   labs (offset / SECSPERMIN) % 60L);
		  count += 5;
		}
	      else
		return 0;
d727 1
a727 1
	case 'Z':
d746 1
a746 1
	case '%':
d748 1
a748 1
	    s[count++] = '%';
d759 1
a759 1
    s[count] = '\0';
d763 452
@


1.9
log
@Fix minor typo
@
text
@d4 1
d106 3
a108 3
2nd, or 3rd falls on a Sunday, that day and earlier belong to week 53
of the previous year; and if December 29th, 30th, or 31st falls on
Monday, that day and later belong to week 1 of the next year.  For
d451 2
a452 1
		       (tim_p->tm_year % 100 + 100) % 100);
d761 1
a761 1
		  int offset;
d769 2
a770 2
		  sprintf (&s[count], "%+03ld%.2d", offset / SECSPERHOUR,
			   abs (offset / SECSPERMIN) % 60);
@


1.8
log
@
2005-02-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/time.h [!CYGWIN](_timezone): Change to long.
        (__tzrule_type, __tzinfo_type): New types.
        (__gettzinfo): New function.
        * libc/sys/linux/include/time.h: Ditto.
        * libc/time/Makefile.am: Add gettzinfo.c.
        * libc/time/Makefile.in: Regenerated.
        * libc/time/local.h: Moved __tzrule_type to time.h.
        * libc/time/mktime.c: Call __gettzinfo to reference
        __tznorth, __tzyear, and __tzrule array.
        * libc/time/mktm_r.c: Ditto.
        * libc/time/strftime.c: Ditto.
        * libc/time/tzset_r.c: Ditto.  Also remove definition
        of __tzrule which is now in gettzinfo.c.  Change _timezone
        references to not cast to time_t.
        * libc/time/gettzinfo.c: New file.
@
text
@d87 1
a87 1
(from `<< 1>>' to `<<31>>'). [tm_mday]
d130 1
a130 1
digit (from `<< 0>>' to `<<23>>'). Non-POSIX extension. [tm_hour]
d134 1
a134 1
digit (from `<< 1>>' to `<<12>>'). Non-POSIX extension. [tm_hour]
@


1.7
log
@
2005-02-16  Eric Blake  <ebb9@@byu.net>

        * libc/time/time.tex: Improve the documentation.
        * libc/time/strftime.c: Improve the documentation.
        (iso_year_adjust): New helper function.
        (strftime): Simplify '%E' and '%O'. Change '%c' to use
        recursion. Fix '%C', '%y', and '%Y' to deal with years with more
        than 4 characters.  Combine '%d' and '%e'. Implement '%D', '%F',
        '%g', '%G', '%n', '%R', '%t', '%T', '%u', '%V', '%X', and '%z'.
        Avoid core dumps on valid inputs (maxsize == 0, or
        tim_p->tm_isdst > 1).
@
text
@d760 1
d765 1
a765 1
		  offset = -__tzrule[tim_p->tm_isdst > 0].offset;
@


1.6
log
@
2005-01-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/time/strftime.c (strftime): Change %r and %x to be compliant
        to POSIX standard for "C" locale.  Allow %E and %O modifiers
        to be ignored as long as they precede valid specifiers according
        to POSIX.
@
text
@d35 2
a36 2
<[timp]>) into a string, starting at <[s]> and occupying no more than
<[maxsize]> characters.
d41 6
a46 5
specifications.  Time conversion specifications are two-character
sequences beginning with `<<%>>' (use `<<%%>>' to include a percent
sign in the output).  Each defined conversion specification selects a
field of calendar time data from <<*<[timp]>>>, and converts it to a
string in one of the following ways:
d50 1
a50 1
An abbreviation for the day of the week.
d53 3
a55 1
The full name for the day of the week.
d58 1
a58 1
An abbreviation for the month name.
d61 4
a64 1
The full name of the month.
d68 2
a69 1
. Mon Apr 01 13:13:13 1992
d71 6
d78 6
a83 1
The day of the month, formatted with two digits.
d86 29
a114 1
The day of the month, formatted with leading space if single digit.
d117 2
a118 1
The hour (on a 24-hour clock), formatted with two digits.
d121 2
a122 1
The hour (on a 12-hour clock), formatted with two digits.
d126 9
a134 1
(from `<<001>>' to `<<366>>').
d137 2
a138 1
The month number, formatted with two digits.
d141 9
a149 1
The minute, formatted with two digits.
d152 1
a152 1
Either `<<AM>>' or `<<PM>>' as appropriate.
d155 5
a159 1
Equivalent to "%I:%M:%S %p".
d162 13
a174 1
The second, formatted with two digits.
d177 8
a184 3
The week number, formatted with two digits (from `<<00>>' to `<<53>>';
week number 1 is taken as beginning with the first Sunday in a year).
See also <<%W>>.
d187 2
a188 1
A single digit representing the day of the week: Sunday is day <<0>>.
d191 3
a193 2
Another version of the week number: like `<<%U>>', but counting week 1
as beginning with the first Monday in a year.
a194 1
o
d197 1
d201 1
a201 1
seconds), equivalent to "%T".
d204 1
a204 1
The last two digits of the year.
d207 12
a218 1
The full year, formatted with four digits to include the century.
d221 3
a223 3
The time zone name.  If tm_isdst is -1, no output is generated.
Otherwise, the time zone name based on the TZ environment variable
is used.
d240 6
a245 1
<[maxsize]> characters.
d254 1
d272 47
d343 2
a344 2

check_format:
d390 45
a434 1
	  if (count < maxsize - 24)
d436 3
a438 15
	      for (i = 0; i < 3; i++)
		s[count++] =
		  dname[tim_p->tm_wday][i];
	      s[count++] = ' ';
	      for (i = 0; i < 3; i++)
		s[count++] =
		  mname[tim_p->tm_mon][i];

	      sprintf (&s[count],
		       " %.2d %2.2d:%2.2d:%2.2d %.4d",
		       tim_p->tm_mday, tim_p->tm_hour,
		       tim_p->tm_min,
		       tim_p->tm_sec, 1900 +
		       tim_p->tm_year);
	      count += 17;
d443 4
a446 2
	case 'd':
	  if (count < maxsize - 2)
d448 4
a451 3
	      sprintf (&s[count], "%.2d",
		       tim_p->tm_mday);
	      count += 2;
d456 10
a465 15
	case 'E':
	  ++format;
	  switch (*format)
            {
              case 'c':
              case 'C':
              case 'x':
              case 'X':
              case 'y':
              case 'Y':
	        /* Ignore.  */
	        goto check_format;
	      default:
		--format;
            }
d467 1
a467 1
	case 'e':
d470 11
a480 2
	      sprintf (&s[count], "%2d",
		       tim_p->tm_mday);
d485 34
a518 1
	  break;
d523 1
a523 1
	      sprintf (&s[count], *format == 'k' ? "%2d" : "%2.2d",
d542 1
a542 1
		  sprintf (&s[count], (*format == 'I') ? "%.2d" : "%2d",
d573 1
a573 1
	      sprintf (&s[count], "%2.2d",
d580 6
a585 23
	case 'O':
	  ++format;
	  switch (*format)
            {
              case 'd':
              case 'e':
              case 'H':
              case 'I':
              case 'm':
              case 'M':
              case 'S':
              case 'u':
              case 'U':
              case 'V':
              case 'w':
              case 'W':
              case 'y':
	        /* Ignore.  */
	        goto check_format;
	      default:
		--format;
            }
          break;
d614 1
a614 1
	      sprintf (&s[count], "%2.2d",
d618 1
a618 1
	      sprintf (&s[count], "%2.2d",
d632 9
d644 1
a644 1
	      sprintf (&s[count], "%2.2d",
d651 28
d682 1
a682 1
	      sprintf (&s[count], "%2.2d",
d690 23
d715 1
a715 5
	    {
	      sprintf (&s[count], "%1.1d",
		       tim_p->tm_wday);
	      count++;
	    }
a722 11
	      sprintf (&s[count], "%2.2d",
		       (tim_p->tm_yday + 7 -
			wday) / 7);
	      count += 2;
	    }
	  else
	    return 0;
	  break;
	case 'x':
	  if (count < maxsize - 8)
	    {
d724 1
a724 12
		       tim_p->tm_mon + 1);
	      count += 2;
	      s[count++] = '/';
	      sprintf (&s[count], "%.2d",
		       tim_p->tm_mday);
	      count += 2;
	      s[count++] = '/';
	      /* The year could be greater than 100, so we need the value
		 modulo 100.  The year could be negative, so we need to
		 correct for a possible negative remainder.  */
	      sprintf (&s[count], "%2.2d",
		       (tim_p->tm_year % 100 + 100) % 100);
a729 12
	case 'X':
	  if (count < maxsize - 8)
	    {
	      sprintf (&s[count],
		       "%2.2d:%2.2d:%2.2d",
		       tim_p->tm_hour, tim_p->tm_min,
		       tim_p->tm_sec);
	      count += 8;
	    }
	  else
	    return 0;
	  break;
d733 5
a737 5
	      /* The year could be greater than 100, so we need the value
		 modulo 100.  The year could be negative, so we need to
		 correct for a possible negative remainder.  */
	      sprintf (&s[count], "%2.2d",
		       (tim_p->tm_year % 100 + 100) % 100);
d744 9
a752 8
	  if (count < maxsize - 4)
	    {
	      sprintf (&s[count], "%.4d",
		       1900 + tim_p->tm_year);
	      count += 4;
	    }
	  else
	    return 0;
d754 20
d779 1
a779 1
	      size = strlen(_tzname[tim_p->tm_isdst]);
d783 1
a783 1
		    s[count++] = _tzname[tim_p->tm_isdst][i];
d805 2
a806 1
  s[count] = '\0';
@


1.5
log
@* libc/time/strftime.c (strftime): Add '%h' and '%l, %k' GNU extensions.
@
text
@d89 3
d109 1
a109 2
A string representing the complete date, in a format like
. Mon Apr 01 1992
d113 1
a113 2
seconds), in a format like
. 13:13:13
d149 1
d191 3
d269 16
d356 23
d392 33
d469 1
a469 1
	  if (count < maxsize - 15)
d471 14
a484 12
	      for (i = 0; i < 3; i++)
		s[count++] =
		  dname[tim_p->tm_wday][i];
	      s[count++] = ' ';
	      for (i = 0; i < 3; i++)
		s[count++] =
		  mname[tim_p->tm_mon][i];

	      sprintf (&s[count],
		       " %.2d %.4d", tim_p->tm_mday,
		       1900 + tim_p->tm_year);
	      count += 8;
@


1.4
log
@	* libc/time/strftime.c (strftime): Add %e format specifier.
@
text
@d212 1
d275 1
d278 1
a278 1
	      sprintf (&s[count], "%2.2d",
d286 1
d297 1
a297 1
		  sprintf (&s[count], "%.2d",
@


1.3
log
@
2002-04-17  Jeff Johnston  <jjohnstn@@redhat.com>

        *  libc/include/time.h (tzset, _tzset_r): Added prototypes.
        (strptime): Moved prototype to be within !__STRICT_ANSI__.
        (_tzname, _daylight, _timezone): No long __CYGWIN__ only.
        (tzname): Defined for all platforms.
        (daylight, timezone): Defined only for CYGWIN.
        *  libc/sys/linux/machine/i386/crt0.c: Add call to tzset() after
        environment set up.
        * libc/stdlib/setenv_r.c (_setenv_r): Call tzset() if the TZ
        environment variable is set.
        *  libc/time/Makefile.am: Add support for tzset.c, tzlock.c, and
        tzset_r.c.
        *  libc/time/Makefile.in: Regenerated.
        *  libc/time/gmtime.c (gmtime): Changed to call gmtime_r.
        *  libc/time/gmtime_r.c (gmtime_r): Changed to call _mktm_r.
        *  libc/time/lcltime_r.c (lcltime_r): Ditto.
        *  libc/time/local.h: New local header file.
        *  libc/time/mktime.c (mktime): Add timezone support.
        *  libc/time/mktm_r.c: New file which is the common engine
        for gmtime_r and lcltime_r.  This code has timezone support.
        *  libc/time/strftime.c (strftime): Add %Z timezone support.
        *  libc/time/tzlock.c: New file containing timezone lock stubs.
        *  libc/time/tzset.c: New file containing tzset() routine.
        *  libc/time/tzset_r.c: New file containing _tzset_r and
        internal routine for calculating timezone changes for specified year.
@
text
@d67 3
d257 10
@


1.2
log
@
Thu Sep 13 08:49:49 2001  Jason Tishler <jason@@tishler.net>

        * strftime.c (strftime): Fix "%W" implementation to properly handle
        Mondays too.
@
text
@d118 3
a120 3
Defined by ANSI C as eliciting the time zone if available; it is not
available in this implementation (which accepts `<<%Z>>' but generates
no output for it).
d145 1
d430 17
@


1.1
log
@Initial revision
@
text
@d365 1
d367 2
a368 2
		       (tim_p->tm_yday + ((8 -
					   tim_p->tm_wday) % 7)) / 7);
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
