head	1.9;
access;
symbols
	cygwin-1_7_32-release:1.7
	cygwin-1_7_31-release:1.7
	cygwin-1_7_30-release:1.7
	cygwin-1_7_29-release:1.7
	cygwin-1_7_28-release:1.7
	newlib-2_1_0:1.7
	cygwin-1_7_27-release:1.7
	cygwin-1_7_26-release:1.7
	cygwin-1_7_25-release:1.7
	cygwin-1_7_24-release:1.7
	cygwin-1_7_23-release:1.7
	cygwin-1_7_22-release:1.7
	cygwin-1_7_21-release:1.7
	cygwin-1_7_20-release:1.7
	cygwin-1_7_19-release:1.7
	cygwin-64bit-postmerge:1.7
	cygwin-64bit-premerge-branch:1.7.0.4
	cygwin-64bit-premerge:1.7
	cygwin-1_7_18-release:1.7
	newlib-2_0_0:1.7
	cygwin-1_7_17-release:1.7
	cygwin-64bit-branch:1.7.0.2
	cygwin-1_7_16-release:1.7
	cygwin-1_7_15-release:1.7
	cygwin-1_7_14_2-release:1.7
	cygwin-1_7_14-release:1.7
	cygwin-1_7_12-release:1.7
	cygwin-1_7_11-release:1.7
	cygwin-1_7_10-release:1.7
	newlib-1_20_0:1.7
	cygwin-1_7_9-release:1.4
	cygwin-1_7_8-release:1.4
	newlib-1_19_0:1.4
	cygwin-1_7_7-release:1.4
	cygwin-1_7_5-release:1.4
	cygwin-1_7_4-release:1.4
	cygwin-1_7_3-release:1.4
	cygwin-1_7_2-release:1.4
	newlib-1_18_0:1.4
	cygwin-1_7_1-release:1.4
	newlib-1_17_0-arc:1.4.0.10
	binutils-arc-20080908-branch:1.4.0.8
	binutils-arc-20080908-branchpoint:1.4
	newlib-1_17_0:1.4
	newlib-1_16_0:1.4
	newlib-1_15_0:1.4
	newlib-csl-coldfire-4_1-32:1.4
	newlib-csl-sourcerygxx-4_1-32:1.4
	newlib-csl-innovasic-fido-3_4_4-33:1.4
	newlib-csl-coldfire-4_1-30:1.4
	newlib-csl-sourcerygxx-4_1-30:1.4
	newlib-csl-coldfire-4_1-28:1.4
	newlib-csl-sourcerygxx-4_1-28:1.4
	newlib-csl-arm-2006q3-27:1.4
	newlib-csl-sourcerygxx-4_1-27:1.4
	newlib-csl-arm-2006q3-26:1.4
	newlib-csl-sourcerygxx-4_1-26:1.4
	newlib-csl-sourcerygxx-4_1-24:1.4
	newlib-csl-sourcerygxx-4_1-23:1.4
	newlib-csl-sourcerygxx-4_1-21:1.4
	newlib-csl-arm-2006q3-21:1.4
	newlib-csl-arm-2006q3-19:1.4
	newlib-csl-sourcerygxx-4_1-19:1.4
	newlib-csl-sourcerygxx-4_1-18:1.4
	newlib-csl-sourcerygxx-3_4_4-25:1.4
	newlib-csl-sourcerygxx-4_1-17:1.4
	cr-0x5f1:1.4.0.6
	newlib-csl-sourcerygxx-4_1-14:1.4
	newlib-csl-sourcerygxx-4_1-13:1.4
	newlib-csl-sourcerygxx-4_1-12:1.4
	newlib-csl-sourcerygxx-4_1-9:1.4
	newlib-csl-sourcerygxx-4_1-8:1.4
	newlib-csl-sourcerygxx-4_1-7:1.4
	newlib-csl-arm-2006q1-6:1.4
	newlib-csl-sourcerygxx-4_1-6:1.4
	newlib-csl-sourcerygxx-4_1-5:1.4
	newlib-csl-sourcerygxx-4_1-4:1.4
	newlib-autotools-branch:1.4.0.4
	newlib-csl-20060320-branch:1.4.0.2
	newlib-csl-20060320-branchpoint:1.4
	newlib-1_14_0:1.4
	newlib-csl-arm-2005-q1b:1.4
	newlib-csl-arm-2005-q1a:1.4
	newlib-1_13_0:1.2
	csl-arm-2004-q3:1.1
	csl-arm-2004-q1a:1.1
	csl-arm-2004-q1:1.1
	newlib-1_12_0:1.1
	csl-arm-2003-q4:1.1
	w32api-2_2:1.1
	mingw-runtime-2_4:1.1
	newlib-1_11_0:1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.09.11.21.55.01;	author jjohnstn;	state dead;
branches;
next	1.8;

1.8
date	2014.09.04.09.47.14;	author corinna;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.11.11.28.05;	author corinna;	state Exp;
branches;
next	1.6;

1.6
date	2011.08.26.07.23.42;	author corinna;	state Exp;
branches;
next	1.5;

1.5
date	2011.08.24.13.38.32;	author corinna;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.25.22.31.21;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.23.19.08.58;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.08.17.54.38;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.17.21.23.31;	author jjohnstn;	state Exp;
branches;
next	;


desc
@@


1.9
log
@
2014-09-11  Freddie Chopin  <freddie_chopin@@op.pl>

        * libc/time/month_lengths.c: New file with __month_lengths array
        (previously mon_lengths array in mktm_r.c)
        * libc/time/tzcalc_limits.c: New file with __tzcalc_limits() from
        mktm_r.c
        * libc/time/lcltime_r.c (localtime_r): Simplify by changing call to
        _mktm_r() with call to gmtime_r() and code moved from _mktm_r() which
        was used to do time zone adjustments
        * libc/time/gmtime_r.c (gmtime_r): Simplify by moving all relevant
        code from _mktm_r(), breaking all dependencies on time zone related
        functions
        * libc/time/mktm_r.c: Delete file
        * libc/time/local.h: Update accordingly - remove declaration of
        _mktm_r(), add declaration of __month_lengths[]
        * libc/time/Makefile.am: Modify accordingly.
        * libc/time/Makefile.in: Regenerate.
@
text
@/*
 * mktm_r.c
 * Original Author:	Adapted from tzcode maintained by Arthur David Olson.
 * Modifications:       Changed to mktm_r and added __tzcalc_limits - 04/10/02, Jeff Johnston
 *                      Fixed bug in mday computations - 08/12/04, Alex Mogilnikov <alx@@intellectronika.ru>
 *                      Fixed bug in __tzcalc_limits - 08/12/04, Alex Mogilnikov <alx@@intellectronika.ru>
 *
 * Converts the calendar time pointed to by tim_p into a broken-down time
 * expressed as local time. Returns a pointer to a structure containing the
 * broken-down time.
 */

#include <stdlib.h>
#include <time.h>
#include "local.h"

/* there are 97 leap years in 400-year periods */
#define DAYS_PER_400_YEARS	((400 - 97) * 365 + 97 * 366)
/* there are 24 leap years in 100-year periods */
#define DAYS_PER_100_YEARS	((100 - 24) * 365 + 24 * 366)
/* there is one leap year every 4 years */
#define DAYS_PER_4_YEARS	(3 * 365 + 366)

static _CONST int mon_lengths[2][MONSPERYEAR] = {
  {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
  {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
} ;

static _CONST int days_per_year[4] = {
  365,  /* 1970 or 1966 */
  365,  /* 1971 or 1967 */
  366,  /* 1972 or 1968 */
  365   /* 1973 or 1969 */
} ;

struct tm *
_DEFUN (_mktm_r, (tim_p, res, is_gmtime),
	_CONST time_t * tim_p _AND
	struct tm *res _AND
	int is_gmtime)
{
  long days, rem;
  time_t lcltime;
  int y;
  int years400, years100, years4;
  int yleap;
  _CONST int *ip;
   __tzinfo_type *tz = __gettzinfo ();

  /* base decision about std/dst time on current time */
  lcltime = *tim_p;
   
  days = ((long)lcltime) / SECSPERDAY;
  rem = ((long)lcltime) % SECSPERDAY;
  while (rem < 0) 
    {
      rem += SECSPERDAY;
      --days;
    }
  while (rem >= SECSPERDAY)
    {
      rem -= SECSPERDAY;
      ++days;
    }
 
  /* compute hour, min, and sec */  
  res->tm_hour = (int) (rem / SECSPERHOUR);
  rem %= SECSPERHOUR;
  res->tm_min = (int) (rem / SECSPERMIN);
  res->tm_sec = (int) (rem % SECSPERMIN);

  /* compute day of week */
  if ((res->tm_wday = ((EPOCH_WDAY + days) % DAYSPERWEEK)) < 0)
    res->tm_wday += DAYSPERWEEK;

  /* compute year & day of year */
  years400 = days / DAYS_PER_400_YEARS;
  days -= years400 * DAYS_PER_400_YEARS;
  years100 = days / DAYS_PER_100_YEARS;
  days -= years100 * DAYS_PER_100_YEARS;
  years4 = days / DAYS_PER_4_YEARS;
  days -= years4 * DAYS_PER_4_YEARS;

  y = EPOCH_YEAR + years400 * 400 + years100 * 100 + years4 * 4;

  /* the value left in days is based in 1970 */
  if (days < 0)
    {
      ip = &days_per_year[3];
      while (days < 0)
	{
	  days += *ip--;
	  --y;
	}
    }
  else
    {
      ip = &days_per_year[0];
      while (days >= *ip)
	{
	  days -= *ip++;
	  ++y;
	}
    }

  res->tm_year = y - YEAR_BASE;
  res->tm_yday = days;
  yleap = isleap(y);
  ip = mon_lengths[yleap];
  for (res->tm_mon = 0; days >= ip[res->tm_mon]; ++res->tm_mon)
    days -= ip[res->tm_mon];
  res->tm_mday = days + 1;

  if (!is_gmtime)
    {
      long offset;
      int hours, mins, secs;

      TZ_LOCK;
      if (_daylight)
	{
	  if (y == tz->__tzyear || __tzcalc_limits (y))
	    res->tm_isdst = (tz->__tznorth 
			     ? (*tim_p >= tz->__tzrule[0].change 
				&& *tim_p < tz->__tzrule[1].change)
			     : (*tim_p >= tz->__tzrule[0].change 
				|| *tim_p < tz->__tzrule[1].change));
	  else
	    res->tm_isdst = -1;
	}
      else
	res->tm_isdst = 0;

      offset = (res->tm_isdst == 1 
		  ? tz->__tzrule[1].offset 
		  : tz->__tzrule[0].offset);

      hours = (int) (offset / SECSPERHOUR);
      offset = offset % SECSPERHOUR;
      
      mins = (int) (offset / SECSPERMIN);
      secs = (int) (offset % SECSPERMIN);

      res->tm_sec -= secs;
      res->tm_min -= mins;
      res->tm_hour -= hours;

      if (res->tm_sec >= SECSPERMIN)
	{
	  res->tm_min += 1;
	  res->tm_sec -= SECSPERMIN;
	}
      else if (res->tm_sec < 0)
	{
	  res->tm_min -= 1;
	  res->tm_sec += SECSPERMIN;
	}
      if (res->tm_min >= MINSPERHOUR)
	{
	  res->tm_hour += 1;
	  res->tm_min -= MINSPERHOUR;
	}
      else if (res->tm_min < 0)
	{
	  res->tm_hour -= 1;
	  res->tm_min += MINSPERHOUR;
	}
      if (res->tm_hour >= HOURSPERDAY)
	{
	  ++res->tm_yday;
	  ++res->tm_wday;
	  if (res->tm_wday > 6)
	    res->tm_wday = 0;
	  ++res->tm_mday;
	  res->tm_hour -= HOURSPERDAY;
	  if (res->tm_mday > ip[res->tm_mon])
	    {
	      res->tm_mday -= ip[res->tm_mon];
	      res->tm_mon += 1;
	      if (res->tm_mon == 12)
		{
		  res->tm_mon = 0;
		  res->tm_year += 1;
		  res->tm_yday = 0;
		}
	    }
	}
       else if (res->tm_hour < 0)
	{
	  res->tm_yday -= 1;
	  res->tm_wday -= 1;
	  if (res->tm_wday < 0)
	    res->tm_wday = 6;
	  res->tm_mday -= 1;
	  res->tm_hour += 24;
	  if (res->tm_mday == 0)
	    {
	      res->tm_mon -= 1;
	      if (res->tm_mon < 0)
		{
		  res->tm_mon = 11;
		  res->tm_year -= 1;
		  res->tm_yday = 364 + isleap(res->tm_year + 1900);
		}
	      res->tm_mday = ip[res->tm_mon];
	    }
	}
      TZ_UNLOCK;
    }
  else
    res->tm_isdst = 0;

  return (res);
}

int
_DEFUN (__tzcalc_limits, (year),
	int year)
{
  int days, year_days, years;
  int i, j;
  __tzinfo_type *tz = __gettzinfo ();

  if (year < EPOCH_YEAR)
    return 0;

  tz->__tzyear = year;

  years = (year - EPOCH_YEAR);

  year_days = years * 365 +
    (years - 1 + EPOCH_YEARS_SINCE_LEAP) / 4 - (years - 1 + EPOCH_YEARS_SINCE_CENTURY) / 100 + 
    (years - 1 + EPOCH_YEARS_SINCE_LEAP_CENTURY) / 400;
  
  for (i = 0; i < 2; ++i)
    {
	if (tz->__tzrule[i].ch == 'J') {
        /* The Julian day n (1 <= n <= 365). */
	days = year_days + tz->__tzrule[i].d + 
		(isleap(year) && tz->__tzrule[i].d >= 60);
        /* Convert to yday */
        --days;
	} else if (tz->__tzrule[i].ch == 'D')
	days = year_days + tz->__tzrule[i].d;
      else
	{
	  int yleap = isleap(year);
	  int m_day, m_wday, wday_diff;
	  _CONST int *ip = mon_lengths[yleap];

	  days = year_days;

	  for (j = 1; j < tz->__tzrule[i].m; ++j)
	    days += ip[j-1];

	  m_wday = (EPOCH_WDAY + days) % DAYSPERWEEK;
	  
	  wday_diff = tz->__tzrule[i].d - m_wday;
	  if (wday_diff < 0)
	    wday_diff += DAYSPERWEEK;
	  m_day = (tz->__tzrule[i].n - 1) * DAYSPERWEEK + wday_diff;

	  while (m_day >= ip[j-1])
	    m_day -= DAYSPERWEEK;

	  days += m_day;
	}

      /* store the change-over time in GMT form by adding offset */
      tz->__tzrule[i].change = days * SECSPERDAY + 
	      			tz->__tzrule[i].s + tz->__tzrule[i].offset;
    }

  tz->__tznorth = (tz->__tzrule[0].change < tz->__tzrule[1].change);

  return 1;
}
@


1.8
log
@	* libc/time/mktm_r.c (_mktm_r): Optimize speed.
@
text
@@


1.7
log
@	* libc/time/mktm_r.c: (__tzcalc_limits) Fix Julian day calculation.
	* libc/time/mktime.c: (mktime) Fix tm_yday, tm_mday updating when
	timezone causes roll over.
@
text
@d17 7
d29 5
a33 3
static _CONST int year_lengths[2] = {
  365,
  366
d45 1
d77 11
a87 2
  y = EPOCH_YEAR;
  if (days >= 0)
d89 2
a90 1
      for (;;)
d92 2
a93 5
	  yleap = isleap(y);
	  if (days < year_lengths[yleap])
	    break;
	  y++;
	  days -= year_lengths[yleap];
d98 2
a99 1
      do
d101 3
a103 4
	  --y;
	  yleap = isleap(y);
	  days += year_lengths[yleap];
	} while (days < 0);
d108 1
@


1.6
log
@	* libc/time/mktm_r.c (_mktm_r): Fix previous fix.
@
text
@d219 2
a220 1
      if (tz->__tzrule[i].ch == 'J')
d223 3
a225 1
      else if (tz->__tzrule[i].ch == 'D')
@


1.5
log
@	* libc/time/mktm_r.c (_mktm_r): Fix computing tm_year.
@
text
@d185 1
a185 1
		  res->tm_yday = 364 + isleap(res->tm_year);
a256 1

@


1.4
log
@
2005-02-25  Eric Blake  <ebb9@@byu.net>

        * libc/include/time.h (__tzrule_struct): Make offset long, since
        a 16-bit int overflows on a 12-hour offset.
        * libc/sys/linux/include/time.h: Ditto.
        * libc/time/mktime.c (mktime): Use new type of __tzrule.offset.
        * libc/time/mktm_r.c: Ditto.
        * libc/time/gettzinfo.c: Ditto.
        * libc/time/strftime.c (strftime): Fix '%x' to deal with negative
        years.  Fix '%z' to use long, not int.
@
text
@d185 1
a185 1
		  res->tm_yday = 365 + isleap(res->tm_year);
@


1.3
log
@
2005-02-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/time.h [!CYGWIN](_timezone): Change to long.
        (__tzrule_type, __tzinfo_type): New types.
        (__gettzinfo): New function.
        * libc/sys/linux/include/time.h: Ditto.
        * libc/time/Makefile.am: Add gettzinfo.c.
        * libc/time/Makefile.in: Regenerated.
        * libc/time/local.h: Moved __tzrule_type to time.h.
        * libc/time/mktime.c: Call __gettzinfo to reference
        __tznorth, __tzyear, and __tzrule array.
        * libc/time/mktm_r.c: Ditto.
        * libc/time/strftime.c: Ditto.
        * libc/time/tzset_r.c: Ditto.  Also remove definition
        of __tzrule which is now in gettzinfo.c.  Change _timezone
        references to not cast to time_t.
        * libc/time/gettzinfo.c: New file.
@
text
@d98 1
a98 1
      int offset;
d120 1
a120 1
      hours = offset / SECSPERHOUR;
d123 2
a124 2
      mins = offset / SECSPERMIN;
      secs = offset % SECSPERMIN;
@


1.2
log
@
2004-12-08  Alex Mogilnikov  <alx@@intellectronika.ru>

        * libc/time/mktm_r (_mktm_r): Fix overflow calculation for
        m_day.
        (__tzcalc_limits): Fix reference to month array to be zero-based.
@
text
@a34 1
  int i;
d38 1
d104 6
a109 4
	  if (y == __tzyear || __tzcalc_limits (y))
	    res->tm_isdst = (__tznorth 
			     ? (*tim_p >= __tzrule[0].change && *tim_p < __tzrule[1].change)
			     : (*tim_p >= __tzrule[0].change || *tim_p < __tzrule[1].change));
d116 3
a118 1
      offset = (res->tm_isdst == 1 ? __tzrule[1].offset : __tzrule[0].offset);
d204 1
d209 1
a209 1
  __tzyear = year;
d219 5
a223 4
      if (__tzrule[i].ch == 'J')
	days = year_days + __tzrule[i].d + (isleap(year) && __tzrule[i].d >= 60);
      else if (__tzrule[i].ch == 'D')
	days = year_days + __tzrule[i].d;
d232 1
a232 1
	  for (j = 1; j < __tzrule[i].m; ++j)
d237 1
a237 1
	  wday_diff = __tzrule[i].d - m_wday;
d240 1
a240 1
	  m_day = (__tzrule[i].n - 1) * DAYSPERWEEK + wday_diff;
d249 2
a250 1
      __tzrule[i].change = days * SECSPERDAY + __tzrule[i].s + __tzrule[i].offset;
d253 1
a253 1
  __tznorth = (__tzrule[0].change < __tzrule[1].change);
@


1.1
log
@
2002-04-17  Jeff Johnston  <jjohnstn@@redhat.com>

        *  libc/include/time.h (tzset, _tzset_r): Added prototypes.
        (strptime): Moved prototype to be within !__STRICT_ANSI__.
        (_tzname, _daylight, _timezone): No long __CYGWIN__ only.
        (tzname): Defined for all platforms.
        (daylight, timezone): Defined only for CYGWIN.
        *  libc/sys/linux/machine/i386/crt0.c: Add call to tzset() after
        environment set up.
        * libc/stdlib/setenv_r.c (_setenv_r): Call tzset() if the TZ
        environment variable is set.
        *  libc/time/Makefile.am: Add support for tzset.c, tzlock.c, and
        tzset_r.c.
        *  libc/time/Makefile.in: Regenerated.
        *  libc/time/gmtime.c (gmtime): Changed to call gmtime_r.
        *  libc/time/gmtime_r.c (gmtime_r): Changed to call _mktm_r.
        *  libc/time/lcltime_r.c (lcltime_r): Ditto.
        *  libc/time/local.h: New local header file.
        *  libc/time/mktime.c (mktime): Add timezone support.
        *  libc/time/mktm_r.c: New file which is the common engine
        for gmtime_r and lcltime_r.  This code has timezone support.
        *  libc/time/strftime.c (strftime): Add %Z timezone support.
        *  libc/time/tzlock.c: New file containing timezone lock stubs.
        *  libc/time/tzset.c: New file containing tzset() routine.
        *  libc/time/tzset_r.c: New file containing _tzset_r and
        internal routine for calculating timezone changes for specified year.
@
text
@d5 2
d154 1
a154 1
	  if (res->tm_mday >= ip[res->tm_mon])
d156 1
a156 1
	      res->tm_mday -= ip[res->tm_mon] - 1;
d236 1
a236 1
	  while (m_day >= ip[j])
@

