head	1.3;
access;
symbols
	cygwin-1_7_35-release:1.3
	cygwin-1_7_34-release:1.3
	newlib-2_2_0:1.3.0.16
	cygwin-1_7_33-release:1.3
	cygwin-1_7_32-release:1.3
	cygwin-1_7_31-release:1.3
	cygwin-1_7_30-release:1.3
	cygwin-1_7_29-release:1.3
	cygwin-1_7_28-release:1.3
	newlib-2_1_0:1.3
	cygwin-1_7_27-release:1.3
	cygwin-1_7_26-release:1.3
	cygwin-1_7_25-release:1.3
	cygwin-1_7_24-release:1.3
	cygwin-1_7_23-release:1.3
	cygwin-1_7_22-release:1.3
	cygwin-1_7_21-release:1.3
	cygwin-1_7_20-release:1.3
	cygwin-1_7_19-release:1.3
	cygwin-64bit-postmerge:1.3
	cygwin-64bit-premerge-branch:1.3.0.14
	cygwin-64bit-premerge:1.3
	cygwin-1_7_18-release:1.3
	newlib-2_0_0:1.3
	cygwin-1_7_17-release:1.3
	cygwin-64bit-branch:1.3.0.12
	cygwin-1_7_16-release:1.3
	cygwin-1_7_15-release:1.3
	cygwin-1_7_14_2-release:1.3
	cygwin-1_7_14-release:1.3
	cygwin-1_7_12-release:1.3
	cygwin-1_7_11-release:1.3
	cygwin-1_7_10-release:1.3
	newlib-1_20_0:1.3
	cygwin-1_7_9-release:1.3
	cygwin-1_7_8-release:1.3
	newlib-1_19_0:1.3
	cygwin-1_7_7-release:1.3
	cygwin-1_7_5-release:1.3
	cygwin-1_7_4-release:1.3
	cygwin-1_7_3-release:1.3
	cygwin-1_7_2-release:1.3
	newlib-1_18_0:1.3
	cygwin-1_7_1-release:1.3
	newlib-1_17_0-arc:1.3.0.10
	binutils-arc-20080908-branch:1.3.0.8
	binutils-arc-20080908-branchpoint:1.3
	newlib-1_17_0:1.3
	newlib-1_16_0:1.3
	newlib-1_15_0:1.3
	newlib-csl-coldfire-4_1-32:1.3
	newlib-csl-sourcerygxx-4_1-32:1.3
	newlib-csl-innovasic-fido-3_4_4-33:1.3
	newlib-csl-coldfire-4_1-30:1.3
	newlib-csl-sourcerygxx-4_1-30:1.3
	newlib-csl-coldfire-4_1-28:1.3
	newlib-csl-sourcerygxx-4_1-28:1.3
	newlib-csl-arm-2006q3-27:1.3
	newlib-csl-sourcerygxx-4_1-27:1.3
	newlib-csl-arm-2006q3-26:1.3
	newlib-csl-sourcerygxx-4_1-26:1.3
	newlib-csl-sourcerygxx-4_1-24:1.3
	newlib-csl-sourcerygxx-4_1-23:1.3
	newlib-csl-sourcerygxx-4_1-21:1.3
	newlib-csl-arm-2006q3-21:1.3
	newlib-csl-arm-2006q3-19:1.3
	newlib-csl-sourcerygxx-4_1-19:1.3
	newlib-csl-sourcerygxx-4_1-18:1.3
	newlib-csl-sourcerygxx-3_4_4-25:1.3
	newlib-csl-sourcerygxx-4_1-17:1.3
	cr-0x5f1:1.3.0.6
	newlib-csl-sourcerygxx-4_1-14:1.3
	newlib-csl-sourcerygxx-4_1-13:1.3
	newlib-csl-sourcerygxx-4_1-12:1.3
	newlib-csl-sourcerygxx-4_1-9:1.3
	newlib-csl-sourcerygxx-4_1-8:1.3
	newlib-csl-sourcerygxx-4_1-7:1.3
	newlib-csl-arm-2006q1-6:1.3
	newlib-csl-sourcerygxx-4_1-6:1.3
	newlib-csl-sourcerygxx-4_1-5:1.3
	newlib-csl-sourcerygxx-4_1-4:1.3
	newlib-autotools-branch:1.3.0.4
	newlib-csl-20060320-branch:1.3.0.2
	newlib-csl-20060320-branchpoint:1.3
	newlib-1_14_0:1.3
	newlib-csl-arm-2005-q1b:1.3
	newlib-csl-arm-2005-q1a:1.3
	newlib-1_13_0:1.3
	csl-arm-2004-q3:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	newlib-1_12_0:1.3
	csl-arm-2003-q4:1.3
	w32api-2_2:1.3
	mingw-runtime-2_4:1.3
	newlib-1_11_0:1.3
	cygnus_cvs_20020108_pre:1.1.1.1
	newlib-1_10_0:1.1.1.1
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2002.03.26.17.22.16;	author amylaar;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.06.10.43.18;	author amylaar;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.17.19.39.47;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.3
log
@	* libc/machine/sh/memcpy.S (Large): Fix alignment rounding.
	Store high part of leading bytes too.
@
text
@!
! Fast SH memcpy
!
! by Toshiyasu Morita (tm@@netcom.com)
! hacked by J"orn Rernnecke (joern.rennecke@@superh.com) ("o for o-umlaut)
! SH5 code Copyright 2002 SuperH Ltd.
!
! Entry: ARG0: destination pointer
!        ARG1: source pointer
!        ARG3: byte count
!
! Exit:  RESULT: destination pointer
!        any other registers in the range r0-r7: trashed
!
! Notes: Usually one wants to do small reads and write a longword, but
!        unfortunately it is difficult in some cases to concatanate bytes
!        into a longword on the SH, so this does a longword read and small
!        writes.
!
! This implementation makes two assumptions about how it is called:
!
! 1.: If the byte count is nonzero, the address of the last byte to be
!     copied is unsigned greater than the address of the first byte to
!     be copied.  This could be easily swapped for a signed comparison,
!     but the algorithm used needs some comparison.
!
! 2.: When there are two or three bytes in the last word of an 11-or-more
!     bytes memory chunk to b copied, the rest of the word can be read
!     without side effects.
!     This could be easily changed by increasing the minumum size of
!     a fast memcpy and the amount subtracted from r7 before L_2l_loop be 2,
!     however, this would cost a few extra cyles on average.
!     For SHmedia, the assumption is that any quadword can be read in its
!     enirety if at least one byte is included in the copy.
!

#include "asm.h"

ENTRY(memcpy)

#if __SHMEDIA__

#define LDUAQ(P,O,D0,D1) ldlo.q P,O,D0; ldhi.q P,O+7,D1
#define STUAQ(P,O,D0,D1) stlo.q P,O,D0; sthi.q P,O+7,D1
#define LDUAL(P,O,D0,D1) ldlo.l P,O,D0; ldhi.l P,O+3,D1
#define STUAL(P,O,D0,D1) stlo.l P,O,D0; sthi.l P,O+3,D1

	ld.b r3,0,r63
	pta/l Large,tr0
	movi 25,r0
	bgeu/u r4,r0,tr0
	nsb r4,r0
	shlli r0,5,r0
	movi (L1-L0+63*32 + 1) & 0xffff,r1
	sub r1, r0, r0
L0:	ptrel r0,tr0
	add r2,r4,r5
	ptabs r18,tr1
	add r3,r4,r6
	blink tr0,r63

	.balign 8
L1:
	/* 0 byte memcpy */
	blink tr1,r63

L4_7:	/* 4..7 byte memcpy cntd. */
	stlo.l r2, 0, r0
	or r6, r7, r6
	sthi.l r5, -1, r6
	stlo.l r5, -4, r6
	blink tr1,r63

L2_3:	/* 2 or 3 byte memcpy cntd. */
	st.b r5,-1,r6
	blink tr1,r63

	/* 1 byte memcpy */
	ld.b r3,0,r0
	st.b r2,0,r0
	blink tr1,r63

L8_15:	/* 8..15 byte memcpy cntd. */
	stlo.q r2, 0, r0
	or r6, r7, r6
	sthi.q r5, -1, r6
	stlo.q r5, -8, r6
	blink tr1,r63
	
	/* 2 or 3 byte memcpy */
	ld.b r3,0,r0
	ld.b r2,0,r63
	ld.b r3,1,r1
	st.b r2,0,r0
	pta/l L2_3,tr0
	ld.b r6,-1,r6
	st.b r2,1,r1
	blink tr0, r63

	/* 4 .. 7 byte memcpy */
	LDUAL (r3, 0, r0, r1)
	pta L4_7, tr0
	ldlo.l r6, -4, r7
	or r0, r1, r0
	sthi.l r2, 3, r0
	ldhi.l r6, -1, r6
	blink tr0, r63

	/* 8 .. 15 byte memcpy */
	LDUAQ (r3, 0, r0, r1)
	pta L8_15, tr0
	ldlo.q r6, -8, r7
	or r0, r1, r0
	sthi.q r2, 7, r0
	ldhi.q r6, -1, r6
	blink tr0, r63

	/* 16 .. 24 byte memcpy */
	LDUAQ (r3, 0, r0, r1)
	LDUAQ (r3, 8, r8, r9)
	or r0, r1, r0
	sthi.q r2, 7, r0
	or r8, r9, r8
	sthi.q r2, 15, r8
	ldlo.q r6, -8, r7
	ldhi.q r6, -1, r6
	stlo.q r2, 8, r8
	stlo.q r2, 0, r0
	or r6, r7, r6
	sthi.q r5, -1, r6
	stlo.q r5, -8, r6
	blink tr1,r63

Large:
	ld.b r2, 0, r63
	pta/l  Loop_ua, tr1
	ori r3, -8, r7
	sub r2, r7, r22
	sub r3, r2, r6
	add r2, r4, r5
	ldlo.q r3, 0, r0
	addi r5, -16, r5
	movi 64+8, r27 // could subtract r7 from that.
	stlo.q r2, 0, r0
	sthi.q r2, 7, r0
	ldx.q r22, r6, r0
	bgtu/l r27, r4, tr1

	addi r5, -48, r27
	pta/l Loop_line, tr0
	addi r6, 64, r36
	addi r6, -24, r19
	addi r6, -16, r20
	addi r6, -8, r21

Loop_line:
	ldx.q r22, r36, r63
	alloco r22, 32
	addi r22, 32, r22
	ldx.q r22, r19, r23
	sthi.q r22, -25, r0
	ldx.q r22, r20, r24
	ldx.q r22, r21, r25
	stlo.q r22, -32, r0
	ldx.q r22, r6,  r0
	sthi.q r22, -17, r23
	sthi.q r22,  -9, r24
	sthi.q r22,  -1, r25
	stlo.q r22, -24, r23
	stlo.q r22, -16, r24
	stlo.q r22,  -8, r25
	bgeu r27, r22, tr0

Loop_ua:
	addi r22, 8, r22
	sthi.q r22, -1, r0
	stlo.q r22, -8, r0
	ldx.q r22, r6, r0
	bgtu/l r5, r22, tr1

	add r3, r4, r7
	ldlo.q r7, -8, r1
	sthi.q r22, 7, r0
	ldhi.q r7, -1, r7
	ptabs r18,tr1
	stlo.q r22, 0, r0
	or r1, r7, r1
	sthi.q r5, 15, r1
	stlo.q r5, 8, r1
	blink tr1, r63

#else /* ! SHMEDIA, i.e. SH1 .. SH4 / SHcompact */

#ifdef __SH5__
#define DST r2
#define SRC r3
#define COUNT r4
#define TMP0 r5
#define TMP1 r6
#define RESULT r2
#else
#define DST r4
#define SRC r5
#define COUNT r6
#define TMP0 r2
#define TMP1 r3
#define RESULT r0
#endif

#ifdef __LITTLE_ENDIAN__
	! Little endian version copies with increasing addresses.
	mov DST,TMP1	! Save return value
	mov #11,r0	! Check if small number of bytes
	cmp/hs r0,COUNT
			! COUNT becomes src end address
	SL(bf, L_small, add SRC,COUNT)
	mov #1,r1
	tst r1,SRC	! check if source even
	SL(bt, L_even, mov COUNT,r7)
	mov.b @@SRC+,r0	! no, make it even.
	mov.b r0,@@DST
	add #1,DST
L_even:	tst r1,DST	! check if destination is even
	add #-3,r7
	SL(bf, L_odddst, mov #2,r1)
	tst r1,DST	! check if destination is 4-byte aligned
	mov DST,r0
	SL(bt, L_al4dst, sub SRC,r0)
	mov.w @@SRC+,TMP0
	mov.w TMP0,@@DST
	! add #2,DST  DST is dead here.
L_al4dst:
	tst r1,SRC
	bt L_al4both
	mov.w @@SRC+,r1
	swap.w r1,r1
	add #-6,r0
	add #-6,r7	! r7 := src end address minus 9.
	.align 2
L_2l_loop:
	mov.l @@SRC+,TMP0 ! Read & write two longwords per iteration
	xtrct TMP0,r1
	mov.l r1,@@(r0,SRC)
	cmp/hs r7,SRC
	mov.l @@SRC+,r1
	xtrct r1,TMP0
	mov.l TMP0,@@(r0,SRC)
	bf L_2l_loop
	add #-2,SRC
	bra  L_cleanup
	add #5,r0
L_al4both:
	add #-4,r0
	.align 2
L_al4both_loop:
	mov.l @@SRC+,DST   ! Read longword, write longword per iteration
	cmp/hs r7,SRC
	SL(bf, L_al4both_loop, mov.l DST,@@(r0,SRC))

	bra L_cleanup
	add #3,r0

L_odddst:
	tst r1,SRC
	SL(bt, L_al4src, add #-1,DST)
	mov.w @@SRC+,r0
	mov.b r0,@@(1,DST)
	shlr8 r0
	mov.b r0,@@(2,DST)
	add #2,DST
L_al4src:
	.align 2
L_odd_loop:
	mov.l @@SRC+,r0   ! Read longword, write byte, word, byte per iteration
	cmp/hs r7,SRC
	mov.b r0,@@(1,DST)
	shlr8 r0
	mov.w r0,@@(2,DST)
	shlr16 r0
	mov.b r0,@@(4,DST)
	SL(bf, L_odd_loop, add #4,DST)
	.align 2 ! avoid nop in more frequently executed code.
L_cleanup2:
	mov	DST,r0
	sub	SRC,r0
L_cleanup:
	cmp/eq	COUNT,SRC
	bt	L_ready
	.align 2
L_cleanup_loop:
	mov.b	@@SRC+,r1
	cmp/eq	COUNT,SRC
	mov.b	r1,@@(r0,SRC)
	bf	L_cleanup_loop
L_ready:
	rts
	mov	TMP1,RESULT
L_small:
	bra L_cleanup2
	add #-1,DST
#else /* ! __LITTLE_ENDIAN__ */
	! Big endian version copies with decreasing addresses.
	mov DST,r0
	add COUNT,r0
	sub DST,SRC
	mov #11,r1
	cmp/hs r1,COUNT
	SL(bf, L_small, add #-1,SRC)
	mov SRC,TMP1
	add r0,TMP1
	shlr TMP1
	SL(bt, L_even,
	mov DST,r7)
	mov.b @@(r0,SRC),TMP0
	add #-1,TMP1
	mov.b TMP0,@@-r0
L_even:
	tst #1,r0
	add #-1,SRC
	SL(bf, L_odddst, add #8,r7)
	tst #2,r0
	bt L_al4dst
	add #-1,TMP1
	mov.w @@(r0,SRC),r1
	mov.w r1,@@-r0
L_al4dst:
	shlr TMP1
	bt L_al4both
	mov.w @@(r0,SRC),r1
	swap.w r1,r1
	add #4,r7
	add #-4,SRC
	.align 2
L_2l_loop:
	mov.l @@(r0,SRC),TMP0
	xtrct TMP0,r1
	mov.l r1,@@-r0
	cmp/hs r7,r0
	mov.l @@(r0,SRC),r1
	xtrct r1,TMP0
	mov.l TMP0,@@-r0
	bt L_2l_loop
	bra L_cleanup
	add #5,SRC

	nop ! avoid nop in executed code.
L_al4both:
	add #-2,SRC
	.align 2
L_al4both_loop:
	mov.l @@(r0,SRC),r1
	cmp/hs r7,r0
	SL(bt, L_al4both_loop,
	mov.l r1,@@-r0)
	bra L_cleanup
	add #3,SRC

	nop ! avoid nop in executed code.
L_odddst:
	shlr TMP1
	bt L_al4src
	mov.w @@(r0,SRC),r1
	mov.b r1,@@-r0
	shlr8 r1
	mov.b r1,@@-r0
L_al4src:
	add #-2,SRC
	.align 2
L_odd_loop:
	mov.l @@(r0,SRC),TMP0
	cmp/hs r7,r0
	mov.b TMP0,@@-r0
	shlr8 TMP0
	mov.w TMP0,@@-r0
	shlr16 TMP0
	mov.b TMP0,@@-r0
	bt L_odd_loop

	add #3,SRC
L_cleanup:
L_small:
	cmp/eq DST,r0
	bt L_ready
	add #1,DST
	.align 2
L_cleanup_loop:
	mov.b @@(r0,SRC),TMP0
	cmp/eq DST,r0
	mov.b TMP0,@@-r0
	bf L_cleanup_loop
L_ready:
	rts
	mov r0,RESULT
#endif /* ! __LITTLE_ENDIAN__ */
#endif /* ! SHMEDIA */
@


1.2
log
@	* Makefile.am (lib_a_SOURCES, SH64 case): Add memcpy.S, memset.S
	and strcpy.S.
	* Makefile.in: Regenerate.
	* asm.h (_ENTRY): Set SH5 alignment to 8 bytes.
	(SHHI, SHLO): Define.
	* memcpy.S: Add code for SH5.
	* memset.S: Likewise.
	* strcpy.S: Likewise.
@
text
@d137 1
a137 1
	andi r3, 7, r7
d145 1
@


1.1
log
@Initial revision
@
text
@d5 2
a6 1
! hacked by J"orn Rernnecke (amylaar@@cygnus.co.uk) ("o for o-umlaut)
d8 3
a10 3
! Entry: r4: destination pointer
!        r5: source pointer
!        r6: byte count
d12 2
a13 2
! Exit:  r0: destination pointer
!        r1-r7: trashed
d27 1
a27 1
! 2.: When there are two or three bytes in the last word of an 11-or-bore
d29 1
a29 1
!     without size effects.
d33 2
d40 169
d211 1
a211 1
	mov r4,r3	! Save return value
d213 3
a215 3
	cmp/hs r0,r6
			! r6 becomes src end address
	SL(bf, L_small, add r5,r6)
d217 6
a222 6
	tst r1,r5	! check if source even
	SL(bt, L_even, mov r6,r7)
	mov.b @@r5+,r0	! no, make it even.
	mov.b r0,@@r4
	add #1,r4
L_even:	tst r1,r4	! check if destination is even
d225 6
a230 6
	tst r1,r4	! check if destination is 4-byte aligned
	mov r4,r0
	SL(bt, L_al4dst, sub r5,r0)
	mov.w @@r5+,r2
	mov.w r2,@@r4
	! add #2,r4  r4 is dead here.
d232 1
a232 1
	tst r1,r5
d234 1
a234 1
	mov.w @@r5+,r1
d240 7
a246 7
	mov.l @@r5+,r2 ! Read & write two longwords per iteration
	xtrct r2,r1
	mov.l r1,@@(r0,r5)
	cmp/hs r7,r5
	mov.l @@r5+,r1
	xtrct r1,r2
	mov.l r2,@@(r0,r5)
d248 1
a248 1
	add #-2,r5
d255 3
a257 3
	mov.l @@r5+,r4   ! Read longword, write longword per iteration
	cmp/hs r7,r5
	SL(bf, L_al4both_loop, mov.l r4,@@(r0,r5))
d263 4
a266 4
	tst r1,r5
	SL(bt, L_al4src, add #-1,r4)
	mov.w @@r5+,r0
	mov.b r0,@@(1,r4)
d268 2
a269 2
	mov.b r0,@@(2,r4)
	add #2,r4
d273 3
a275 3
	mov.l @@r5+,r0   ! Read longword, write byte, word, byte per iteration
	cmp/hs r7,r5
	mov.b r0,@@(1,r4)
d277 1
a277 1
	mov.w r0,@@(2,r4)
d279 2
a280 2
	mov.b r0,@@(4,r4)
	SL(bf, L_odd_loop, add #4,r4)
d283 2
a284 2
	mov	r4,r0
	sub	r5,r0
d286 1
a286 1
	cmp/eq	r6,r5
d290 3
a292 3
	mov.b	@@r5+,r1
	cmp/eq	r6,r5
	mov.b	r1,@@(r0,r5)
d296 1
a296 1
	mov	r3,r0
d299 2
a300 2
	add #-1,r4
#else
d302 3
a304 3
	mov r4,r0
	add r6,r0
	sub r4,r5
d306 5
a310 5
	cmp/hs r1,r6
	SL(bf, L_small, add #-1,r5)
	mov r5,r3
	add r0,r3
	shlr r3
d312 4
a315 4
	mov r4,r7)
	mov.b @@(r0,r5),r2
	add #-1,r3
	mov.b r2,@@-r0
d318 1
a318 1
	add #-1,r5
d322 2
a323 2
	add #-1,r3
	mov.w @@(r0,r5),r1
d326 1
a326 1
	shlr r3
d328 1
a328 1
	mov.w @@(r0,r5),r1
d331 1
a331 1
	add #-4,r5
d334 2
a335 2
	mov.l @@(r0,r5),r2
	xtrct r2,r1
d338 3
a340 3
	mov.l @@(r0,r5),r1
	xtrct r1,r2
	mov.l r2,@@-r0
d343 1
a343 1
	add #5,r5
d347 1
a347 1
	add #-2,r5
d350 1
a350 1
	mov.l @@(r0,r5),r1
d355 1
a355 1
	add #3,r5
d359 1
a359 1
	shlr r3
d361 1
a361 1
	mov.w @@(r0,r5),r1
d366 1
a366 1
	add #-2,r5
d369 1
a369 1
	mov.l @@(r0,r5),r2
d371 5
a375 5
	mov.b r2,@@-r0
	shlr8 r2
	mov.w r2,@@-r0
	shlr16 r2
	mov.b r2,@@-r0
d378 1
a378 1
	add #3,r5
d381 1
a381 1
	cmp/eq r4,r0
d383 1
a383 1
	add #1,r4
d386 3
a388 3
	mov.b @@(r0,r5),r2
	cmp/eq r4,r0
	mov.b r2,@@-r0
d392 3
a394 2
	nop
#endif
@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
