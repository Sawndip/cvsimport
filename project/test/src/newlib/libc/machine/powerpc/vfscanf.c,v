head	1.18;
access;
symbols
	cygwin-1_7_35-release:1.18
	cygwin-1_7_34-release:1.18
	newlib-2_2_0:1.18.0.2
	cygwin-1_7_33-release:1.18
	cygwin-1_7_32-release:1.18
	cygwin-1_7_31-release:1.18
	cygwin-1_7_30-release:1.18
	cygwin-1_7_29-release:1.18
	cygwin-1_7_28-release:1.18
	newlib-2_1_0:1.18
	cygwin-1_7_27-release:1.18
	cygwin-1_7_26-release:1.18
	cygwin-1_7_25-release:1.17
	cygwin-1_7_24-release:1.17
	cygwin-1_7_23-release:1.17
	cygwin-1_7_22-release:1.17
	cygwin-1_7_21-release:1.17
	cygwin-1_7_20-release:1.17
	cygwin-1_7_19-release:1.17
	cygwin-64bit-postmerge:1.17
	cygwin-64bit-premerge-branch:1.17.0.4
	cygwin-64bit-premerge:1.17
	cygwin-1_7_18-release:1.17
	newlib-2_0_0:1.17
	cygwin-1_7_17-release:1.17
	cygwin-64bit-branch:1.17.0.2
	cygwin-1_7_16-release:1.17
	cygwin-1_7_15-release:1.17
	cygwin-1_7_14_2-release:1.17
	cygwin-1_7_14-release:1.17
	cygwin-1_7_12-release:1.17
	cygwin-1_7_11-release:1.17
	cygwin-1_7_10-release:1.17
	newlib-1_20_0:1.17
	cygwin-1_7_9-release:1.17
	cygwin-1_7_8-release:1.17
	newlib-1_19_0:1.17
	cygwin-1_7_7-release:1.17
	cygwin-1_7_5-release:1.17
	cygwin-1_7_4-release:1.17
	cygwin-1_7_3-release:1.17
	cygwin-1_7_2-release:1.17
	newlib-1_18_0:1.17
	cygwin-1_7_1-release:1.17
	newlib-1_17_0-arc:1.16.0.4
	binutils-arc-20080908-branch:1.16.0.2
	binutils-arc-20080908-branchpoint:1.16
	newlib-1_17_0:1.16
	newlib-1_16_0:1.16
	newlib-1_15_0:1.16
	newlib-csl-coldfire-4_1-32:1.15.2.1
	newlib-csl-sourcerygxx-4_1-32:1.15.2.1
	newlib-csl-innovasic-fido-3_4_4-33:1.15.2.1
	newlib-csl-coldfire-4_1-30:1.15.2.1
	newlib-csl-sourcerygxx-4_1-30:1.15.2.1
	newlib-csl-coldfire-4_1-28:1.15.2.1
	newlib-csl-sourcerygxx-4_1-28:1.15.2.1
	newlib-csl-arm-2006q3-27:1.15.2.1
	newlib-csl-sourcerygxx-4_1-27:1.15.2.1
	newlib-csl-arm-2006q3-26:1.15.2.1
	newlib-csl-sourcerygxx-4_1-26:1.15.2.1
	newlib-csl-sourcerygxx-4_1-24:1.15.2.1
	newlib-csl-sourcerygxx-4_1-23:1.15.2.1
	newlib-csl-sourcerygxx-4_1-21:1.15.2.1
	newlib-csl-arm-2006q3-21:1.15.2.1
	newlib-csl-arm-2006q3-19:1.15
	newlib-csl-sourcerygxx-4_1-19:1.15
	newlib-csl-sourcerygxx-4_1-18:1.15
	newlib-csl-sourcerygxx-3_4_4-25:1.15
	newlib-csl-sourcerygxx-4_1-17:1.15
	cr-0x5f1:1.15.0.6
	newlib-csl-sourcerygxx-4_1-14:1.15
	newlib-csl-sourcerygxx-4_1-13:1.15
	newlib-csl-sourcerygxx-4_1-12:1.15
	newlib-csl-sourcerygxx-4_1-9:1.15
	newlib-csl-sourcerygxx-4_1-8:1.15
	newlib-csl-sourcerygxx-4_1-7:1.15
	newlib-csl-arm-2006q1-6:1.15
	newlib-csl-sourcerygxx-4_1-6:1.15
	newlib-csl-sourcerygxx-4_1-5:1.15
	newlib-csl-sourcerygxx-4_1-4:1.15
	newlib-autotools-branch:1.15.0.4
	newlib-csl-20060320-branch:1.15.0.2
	newlib-csl-20060320-branchpoint:1.15
	newlib-1_14_0:1.15
	newlib-csl-arm-2005-q1b:1.15
	newlib-csl-arm-2005-q1a:1.15
	newlib-1_13_0:1.14
	csl-arm-2004-q3:1.12
	csl-arm-2004-q1a:1.10
	csl-arm-2004-q1:1.7
	newlib-1_12_0:1.7
	csl-arm-2003-q4:1.7
	w32api-2_2:1.6
	mingw-runtime-2_4:1.6
	newlib-1_11_0:1.6;
locks; strict;
comment	@ * @;


1.18
date	2013.11.18.17.28.03;	author joel;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.12.23.32.37;	author jjohnstn;	state Exp;
branches;
next	1.16;

1.16
date	2006.09.26.21.22.19;	author jjohnstn;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.08.01.33.16;	author jjohnstn;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2004.11.24.00.45.41;	author jjohnstn;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.04.17.51.50;	author jjohnstn;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.02.19.22.14;	author jjohnstn;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.26.00.19.14;	author jjohnstn;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.26.22.43.34;	author aldyh;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.23.21.44.22;	author jjohnstn;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.23.21.30.04;	author jjohnstn;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.20.17.23.57;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.23.01.56.03;	author fitzsim;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.20.01.40.39;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.17.05.57.19;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.13.19.52.17;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.08.01.23.44;	author fitzsim;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.19.19.16.18;	author jjohnstn;	state Exp;
branches;
next	;

1.15.2.1
date	2006.09.27.19.57.14;	author pbrook;	state Exp;
branches;
next	;


desc
@@


1.18
log
@2013-11-18  Sahil Patnayakuni  <sahilp@@oarcorp.com>

	* libc/include/stdio.h, libc/machine/powerpc/vfscanf.c,
	libc/machine/spu/fgetpos.c, libc/machine/spu/fgets.c,
	libc/machine/spu/fopen.c, libc/machine/spu/fputs.c,
	libc/machine/spu/fread.c, libc/machine/spu/freopen.c,
	libc/machine/spu/fwrite.c, libc/machine/spu/setbuf.c,
	libc/machine/spu/vfprintf.c, libc/machine/spu/vfscanf.c,
	libc/machine/spu/vsnprintf.c, libc/machine/spu/vsprintf.c,
	libc/machine/spu/vsscanf.c, libc/stdio/asnprintf.c,
	libc/stdio/asprintf.c, libc/stdio/dprintf.c,
	libc/stdio/fgetpos.c, libc/stdio/fgets.c,
	libc/stdio/fmemopen.c, libc/stdio/fopen.c,
	libc/stdio/fprintf.c, libc/stdio/fputs.c,
	libc/stdio/fread.c, libc/stdio/freopen.c,
	libc/stdio/fscanf.c, libc/stdio/fwrite.c,
	libc/stdio/printf.c, libc/stdio/scanf.c,
	libc/stdio/setbuf.c, libc/stdio/snprintf.c,
	libc/stdio/sprintf.c, libc/stdio/sscanf.c,
	libc/stdio/vdprintf.c, libc/stdio/vprintf.c,
	libc/stdio/vscanf.c, libc/stdio/vsnprintf.c,
	libc/stdio/vsprintf.c, libc/stdio/vsscanf.c: Add restrict keyword.
@
text
@/*
FUNCTION
<<vscanf>>, <<vfscanf>>, <<vsscanf>>---format argument list

INDEX
	vscanf
INDEX
	vfscanf
INDEX
	vsscanf

ANSI_SYNOPSIS
	#include <stdio.h>
	#include <stdarg.h>
	int vscanf(const char *restrict <[fmt]>, va_list <[list]>);
	int vfscanf(FILE *restrict <[fp]>, const char *restrict <[fmt]>, va_list <[list]>);
	int vsscanf(const char *restrict <[str]>, const char *restrict <[fmt]>, va_list <[list]>);

	int _vscanf_r(void *<[reent]>, const char *restrict <[fmt]>, 
                       va_list <[list]>);
	int _vfscanf_r(void *<[reent]>, FILE *restrict <[fp]>, const char *restrict <[fmt]>, 
                       va_list <[list]>);
	int _vsscanf_r(void *<[reent]>, const char *restrict <[str]>, const char *restrict <[fmt]>, 
                       va_list <[list]>);

TRAD_SYNOPSIS
	#include <stdio.h>
	#include <varargs.h>
	int vscanf( <[fmt]>, <[ist]>)
	char *<[fmt]>;
	va_list <[list]>;

	int vfscanf( <[fp]>, <[fmt]>, <[list]>)
	FILE *<[fp]>;
	char *<[fmt]>;
	va_list <[list]>;
	
	int vsscanf( <[str]>, <[fmt]>, <[list]>)
	char *<[str]>;
	char *<[fmt]>;
	va_list <[list]>;

	int _vscanf_r( <[reent]>, <[fmt]>, <[ist]>)
	char *<[reent]>;
	char *<[fmt]>;
	va_list <[list]>;

	int _vfscanf_r( <[reent]>, <[fp]>, <[fmt]>, <[list]>)
	char *<[reent]>;
	FILE *<[fp]>;
	char *<[fmt]>;
	va_list <[list]>;
	
	int _vsscanf_r( <[reent]>, <[str]>, <[fmt]>, <[list]>)
	char *<[reent]>;
	char *<[str]>;
	char *<[fmt]>;
	va_list <[list]>;

DESCRIPTION
<<vscanf>>, <<vfscanf>>, and <<vsscanf>> are (respectively) variants
of <<scanf>>, <<fscanf>>, and <<sscanf>>.  They differ only in 
allowing their caller to pass the variable argument list as a 
<<va_list>> object (initialized by <<va_start>>) rather than 
directly accepting a variable number of arguments.

RETURNS
The return values are consistent with the corresponding functions:
<<vscanf>> returns the number of input fields successfully scanned,
converted, and stored; the return value does not include scanned
fields which were not stored.  

If <<vscanf>> attempts to read at end-of-file, the return value 
is <<EOF>>.

If no fields were stored, the return value is <<0>>.

The routines <<_vscanf_r>>, <<_vfscanf_f>>, and <<_vsscanf_r>> are
reentrant versions which take an additional first parameter which points to the
reentrancy structure.

PORTABILITY
These are GNU extensions.

Supporting OS subroutines required:
*/

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <_ansi.h>
#include <reent.h>
#include <newlib.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <wchar.h>
#include <string.h>
#ifdef _HAVE_STDC
#include <stdarg.h>
#else
#include <varargs.h>
#endif
#include "local.h"

#ifndef	NO_FLOATING_POINT
#define FLOATING_POINT
#endif

#ifdef FLOATING_POINT
#include <float.h>

/* Currently a test is made to see if long double processing is warranted.
   This could be changed in the future should the _ldtoa_r code be
   preferred over _dtoa_r.  */
#define _NO_LONGDBL
#if defined _WANT_IO_LONG_DOUBLE && (LDBL_MANT_DIG > DBL_MANT_DIG)
#undef _NO_LONGDBL
extern _LONG_DOUBLE _strtold _PARAMS((char *s, char **sptr));
#endif

#define _NO_LONGLONG
#if defined _WANT_IO_LONG_LONG && defined __GNUC__
# undef _NO_LONGLONG
#endif

#include "floatio.h"
#define	BUF	(MAXEXP+MAXFRACT+3)	/* 3 = sign + decimal point + NUL */
/* An upper bound for how long a long prints in decimal.  4 / 13 approximates
   log (2).  Add one char for roundoff compensation and one for the sign.  */
#define MAX_LONG_LEN ((CHAR_BIT * sizeof (long)  - 1) * 4 / 13 + 2)
#else
#define	BUF	40
#endif

/*
 * Flags used during conversion.
 */

#define	LONG		0x01	/* l: long or double */
#define	LONGDBL		0x02	/* L: long double or long long */
#define	SHORT		0x04	/* h: short */
#define	SUPPRESS	0x10	/* suppress assignment */
#define	POINTER		0x20	/* weird %p pointer (`fake hex') */
#define	NOSKIP		0x40	/* do not skip blanks */

/*
 * The following are used in numeric conversions only:
 * SIGNOK, NDIGITS, DPTOK, and EXPOK are for floating point;
 * SIGNOK, NDIGITS, PFXOK, and NZDIGITS are for integral.
 */

#define	SIGNOK		0x80	/* +/- is (still) legal */
#define	NDIGITS		0x100	/* no digits detected */

#define	DPTOK		0x200	/* (float) decimal point is still legal */
#define	EXPOK		0x400	/* (float) exponent (e+3, etc) still legal */

#define	PFXOK		0x200	/* 0x prefix is (still) legal */
#define	NZDIGITS	0x400	/* no zero digits detected */
#define	NNZDIGITS	0x800	/* no non-zero digits detected */

#define	VECTOR		0x2000	/* v: vector */
#define	FIXEDPOINT	0x4000	/* r/R: fixed-point */
#define	SIGNED  	0x8000	/* r: signed fixed-point */

/*
 * Conversion types.
 */

#define	CT_CHAR		0	/* %c conversion */
#define	CT_CCL		1	/* %[...] conversion */
#define	CT_STRING	2	/* %s conversion */
#define	CT_INT		3	/* integer, i.e., strtol or strtoul */
#define	CT_FLOAT	4	/* floating, i.e., strtod */

#if 0
#define u_char unsigned char
#endif
#define u_char char
#define u_long unsigned long

#ifndef _NO_LONGLONG
typedef unsigned long long u_long_long;
#endif

typedef union
{
  char c[16] __attribute__ ((__aligned__ (16)));
  short h[8];
  long l[4];
  int i[4];
  float f[4];
} vec_union;

/*
 * vfscanf
 */

#define BufferEmpty (fp->_r <= 0 && __srefill(fp))

#ifndef _REENT_ONLY

int
_DEFUN (vfscanf, (fp, fmt, ap), 
    register FILE *__restrict fp _AND 
    _CONST char *__restrict fmt _AND 
    va_list ap)
{
  CHECK_INIT(_REENT, fp);
  return __svfscanf_r (_REENT, fp, fmt, ap);
}

int
__svfscanf (fp, fmt0, ap)
     register FILE *fp;
     char _CONST *fmt0;
     va_list ap;
{
  return __svfscanf_r (_REENT, fp, fmt0, ap);
}

#endif /* !_REENT_ONLY */

int
_DEFUN (_vfscanf_r, (data, fp, fmt, ap),
    struct _reent *data _AND 
    register FILE *__restrict fp _AND 
    _CONST char *__restrict fmt _AND 
    va_list ap)
{
  return __svfscanf_r (data, fp, fmt, ap);
}


int
__svfscanf_r (rptr, fp, fmt0, ap)
     struct _reent *rptr;
     register FILE *fp;
     char _CONST *fmt0;
     va_list ap;
{
  register u_char *fmt = (u_char *) fmt0;
  register int c;		/* character from format, or conversion */
  register int type;		/* conversion type */
  register size_t width;	/* field width, or 0 */
  register char *p;		/* points into all kinds of strings */
  register int n;		/* handy integer */
  register int flags;		/* flags as defined above */
  register char *p0;		/* saves original value of p when necessary */
  int orig_flags;               /* saved flags used when processing vector */
  int int_width;                /* tmp area to store width when processing int */
  int nassigned;		/* number of fields assigned */
  int nread;			/* number of characters consumed from fp */
  int base = 0;			/* base argument to strtol/strtoul */
  int nbytes = 1;               /* number of bytes read from fmt string */
  wchar_t wc;                   /* wchar to use to read format string */
  char vec_sep;                 /* vector separator char */
  char last_space_char;         /* last white-space char eaten - needed for vec support */
  int vec_read_count;           /* number of vector items to read separately */
  int looped;                   /* has vector processing looped */
  u_long (*ccfn) () = 0;	/* conversion function (strtol/strtoul) */
  char ccltab[256];		/* character class table for %[...] */
  char buf[BUF];		/* buffer for numeric conversions */
  vec_union vec_buf;
  char *lptr;                   /* literal pointer */
#ifdef _MB_CAPABLE
  mbstate_t state;                /* value to keep track of multibyte state */
#endif

  char *ch_dest;
  short *sp;
  int *ip;
  float *flp;
  _LONG_DOUBLE *ldp;
  double *dp;
  long *lp;
#ifndef _NO_LONGLONG
  long long *llp;
#else
	u_long _uquad;
#endif

  /* `basefix' is used to avoid `if' tests in the integer scanner */
  static _CONST short basefix[17] =
    {10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};

  nassigned = 0;
  nread = 0;
  for (;;)
    {
#ifndef _MB_CAPABLE
      wc = *fmt;
#else
      memset (&state, '\0', sizeof (state));
      nbytes = _mbtowc_r (rptr, &wc, fmt, MB_CUR_MAX, &state);
#endif
      fmt += nbytes;
      if (wc == 0)
	return nassigned;
      if (nbytes == 1 && isspace (wc))
	{
	  for (;;)
	    {
	      if (BufferEmpty)
		return nassigned;
	      if (!isspace (*fp->_p))
		break;
	      nread++, fp->_r--, fp->_p++;
	    }
	  continue;
	}
      if (wc != '%')
	goto literal;
      width = 0;
      flags = 0;
      vec_sep = ' ';
      vec_read_count = 0;
      looped = 0;

      /*
       * switch on the format.  continue if done; break once format
       * type is derived.
       */

    again:
      c = *fmt++;

      switch (c)
	{
	case '%':
	literal:
          lptr = fmt - nbytes;
          for (n = 0; n < nbytes; ++n)
            {
	      if (BufferEmpty)
	        goto input_failure;
	      if (*fp->_p != *lptr)
	        goto match_failure;
	      fp->_r--, fp->_p++;
	      nread++;
              ++lptr;
            }
	  continue;

	case '*':
	  flags |= SUPPRESS;
	  goto again;
	case ',':
	case ';':
	case ':':
	case '_':
	  if (flags == SUPPRESS || flags == 0)
	    vec_sep = c;
	  goto again;
	case 'l':
	  if (flags & SHORT)
	    continue; /* invalid format, don't process any further */
	  if (flags & LONG)
	    {
	      flags &= ~LONG;
	      flags &= ~VECTOR;
	      flags |= LONGDBL;
	    }
	  else
	    {
	      flags |= LONG;
	      if (flags & VECTOR)
		vec_read_count = 4;
	    }
	  goto again;
	case 'L':
	  flags |= LONGDBL;
	  flags &= ~VECTOR;
	  goto again;
	case 'h':
	  flags |= SHORT;
	  if (flags & LONG)
	    continue;  /* invalid format, don't process any further */
	  if (flags & VECTOR)
	    vec_read_count = 8;
	  goto again;
#ifdef __ALTIVEC__
	case 'v':
	  flags |= VECTOR;
	  vec_read_count = (flags & SHORT) ? 8 : ((flags & LONG) ? 4 : 16);
	  goto again;
#endif
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  width = width * 10 + c - '0';
	  goto again;

	  /*
	   * Conversions. Those marked `compat' are for
	   * 4.[123]BSD compatibility.
	   *
	   * (According to ANSI, E and X formats are supposed to
	   * the same as e and x.  Sorry about that.)
	   */

	case 'D':		/* compat */
	  flags |= LONG;
	  /* FALLTHROUGH */
	case 'd':
	  type = CT_INT;
	  ccfn = (u_long (*)())_strtol_r;
	  base = 10;
	  break;

	case 'i':
	  type = CT_INT;
	  ccfn = (u_long (*)())_strtol_r;
	  base = 0;
	  break;

	case 'O':		/* compat */
	  flags |= LONG;
	  /* FALLTHROUGH */
	case 'o':
	  type = CT_INT;
	  ccfn = _strtoul_r;
	  base = 8;
	  break;

	case 'u':
	  type = CT_INT;
	  ccfn = _strtoul_r;
	  base = 10;
	  break;

	case 'X':		/* compat   XXX */
	case 'x':
	  flags |= PFXOK;	/* enable 0x prefixing */
	  type = CT_INT;
	  ccfn = _strtoul_r;
	  base = 16;
	  break;

#ifdef FLOATING_POINT
	case 'E':		/* compat   XXX */
	case 'G':		/* compat   XXX */
/* ANSI says that E,G and X behave the same way as e,g,x */
	  /* FALLTHROUGH */
	case 'e':
	case 'f':
	case 'g':
	  type = CT_FLOAT;
	  if (flags & VECTOR)
	    vec_read_count = 4;
	  break;
       
# ifdef __SPE__
	  /* treat fixed-point like %f floating point */
        case 'r':
	  flags |= SIGNED;
	  /* fallthrough */
        case 'R':
          flags |= FIXEDPOINT;
	  type = CT_FLOAT;
          break;
# endif
#endif

	case 's':
	  flags &= ~VECTOR;
	  type = CT_STRING;
	  break;

	case '[':
	  fmt = __sccl (ccltab, fmt);
	  flags |= NOSKIP;
	  flags &= ~VECTOR;
	  type = CT_CCL;
	  break;

	case 'c':
	  flags |= NOSKIP;
	  type = CT_CHAR;
	  if (flags & VECTOR)
	    {
	      /* not allowed to have h or l with c specifier */
	      if (flags & (LONG | SHORT))
		continue;  /* invalid format don't process any further */
	      width = 0;
	      vec_read_count = 16;
	    }
	  break;

	case 'p':		/* pointer format is like hex */
	  flags |= POINTER | PFXOK;
	  type = CT_INT;
	  ccfn = _strtoul_r;
	  base = 16;
	  break;

	case 'n':
	  if (flags & SUPPRESS)	/* ??? */
	    continue;
	  flags &= ~VECTOR;
	  if (flags & SHORT)
	    {
	      sp = va_arg (ap, short *);
	      *sp = nread;
	    }
	  else if (flags & LONG)
	    {
	      lp = va_arg (ap, long *);
	      *lp = nread;
	    }
#ifndef _NO_LONGLONG
	  else if (flags & LONGDBL)
	    {
	      llp = va_arg (ap, long long*);
	      *llp = nread;
	    }
#endif
	  else
	    {
	      ip = va_arg (ap, int *);
	      *ip = nread;
	    }
	  continue;

	  /*
	   * Disgusting backwards compatibility hacks.	XXX
	   */
	case '\0':		/* compat */
	  return EOF;

	default:		/* compat */
	  if (isupper (c))
	    flags |= LONG;
	  type = CT_INT;
	  ccfn = (u_long (*)())_strtol_r;
	  base = 10;
	  break;
	}

    process:
      /*
       * We have a conversion that requires input.
       */
      if (BufferEmpty)
	goto input_failure;

      /*
       * Consume leading white space, except for formats that
       * suppress this.
       */
      last_space_char = '\0';

      if ((flags & NOSKIP) == 0)
	{
	  while (isspace (*fp->_p))
	    {
	      last_space_char = *fp->_p;
	      nread++;
	      if (--fp->_r > 0)
		fp->_p++;
	      else
#ifndef CYGNUS_NEC
	      if (__srefill (fp))
#endif
		goto input_failure;
	    }
	  /*
	   * Note that there is at least one character in the
	   * buffer, so conversions that do not set NOSKIP ca
	   * no longer result in an input failure.
	   */
	}

      /* for vector formats process separator characters after first loop */
      if (looped && (flags & VECTOR))
	{
	  flags = orig_flags; 
	  /* all formats other than default char have a separator char */
	  if (vec_sep != ' ' || type != CT_CHAR)
	    {
	      if (vec_sep == ' ' && last_space_char != ' ' ||
		  vec_sep != ' ' && *fp->_p != vec_sep)
		goto match_failure;
	      if (vec_sep != ' ')
		{
		  nread++;
		  if (--fp->_r > 0)
		    fp->_p++;
		  else
#ifndef CYGNUS_NEC
		    if (__srefill (fp))
#endif
		      goto input_failure;
		}
	    }
	  /* after eating the separator char, we must eat any white-space
	     after the separator char that precedes the data to convert */
	  if ((flags & NOSKIP) == 0)
	    {
	      while (isspace (*fp->_p))
		{
		  last_space_char = *fp->_p;
		  nread++;
		  if (--fp->_r > 0)
		    fp->_p++;
		  else
#ifndef CYGNUS_NEC
		    if (__srefill (fp))
#endif
		      goto input_failure;
		}
	    }

 	}
      else /* save to counter-act changes made to flags when processing */
	orig_flags = flags;

      /*
       * Do the conversion.
       */
      switch (type)
	{

	case CT_CHAR:
	  /* scan arbitrary characters (sets NOSKIP) */
	  if (width == 0)
	    width = 1;
	  if (flags & SUPPRESS)
	    {
	      size_t sum = 0;

	      for (;;)
		{
		  if ((n = fp->_r) < (int)width)
		    {
		      sum += n;
		      width -= n;
		      fp->_p += n;
#ifndef CYGNUS_NEC
		      if (__srefill (fp))
			{
#endif
			  if (sum == 0)
			    goto input_failure;
			  break;
#ifndef CYGNUS_NEC
			}
#endif
		    }
		  else
		    {
		      sum += width;
		      fp->_r -= width;
		      fp->_p += width;
		      break;
		    }
		}
	      nread += sum;
	    }
	  else
	    {
	      int n = width;
	      if (!looped)
		{
		  if (flags & VECTOR)
		    ch_dest = vec_buf.c;
		  else
		    ch_dest = va_arg (ap, char *);
		}
#ifdef CYGNUS_NEC
	      /* Kludge city for the moment */
	      if (fp->_r == 0)
		goto input_failure;

	      while (n && fp->_r)
		{
		  *ch_dest++ = *(fp->_p++);
		  n--;
		  fp->_r--;
		  nread++;
		}
#else
	      size_t r = fread (ch_dest, 1, width, fp);

	      if (r == 0)
		goto input_failure;
	      nread += r;
	      ch_dest += r;
#endif
	      if (!(flags & VECTOR))
		nassigned++;
	    }
	  break;

	case CT_CCL:
	  /* scan a (nonempty) character class (sets NOSKIP) */
	  if (width == 0)
	    width = ~0;		/* `infinity' */
	  /* take only those things in the class */
	  if (flags & SUPPRESS)
	    {
	      n = 0;
	      while (ccltab[*fp->_p])
		{
		  n++, fp->_r--, fp->_p++;
		  if (--width == 0)
		    break;
		  if (BufferEmpty)
		    {
		      if (n == 0)
			goto input_failure;
		      break;
		    }
		}
	      if (n == 0)
		goto match_failure;
	    }
	  else
	    {
	      p0 = p = va_arg (ap, char *);
	      while (ccltab[*fp->_p])
		{
		  fp->_r--;
		  *p++ = *fp->_p++;
		  if (--width == 0)
		    break;
		  if (BufferEmpty)
		    {
		      if (p == p0)
			goto input_failure;
		      break;
		    }
		}
	      n = p - p0;
	      if (n == 0)
		goto match_failure;
	      *p = 0;
	      nassigned++;
	    }
	  nread += n;
	  break;

	case CT_STRING:
	  /* like CCL, but zero-length string OK, & no NOSKIP */
	  if (width == 0)
	    width = ~0;
	  if (flags & SUPPRESS)
	    {
	      n = 0;
	      while (!isspace (*fp->_p))
		{
		  n++, fp->_r--, fp->_p++;
		  if (--width == 0)
		    break;
		  if (BufferEmpty)
		    break;
		}
	      nread += n;
	    }
	  else
	    {
	      p0 = p = va_arg (ap, char *);
	      while (!isspace (*fp->_p))
		{
		  fp->_r--;
		  *p++ = *fp->_p++;
		  if (--width == 0)
		    break;
		  if (BufferEmpty)
		    break;
		}
	      *p = 0;
	      nread += p - p0;
	      nassigned++;
	    }
	  continue;

	case CT_INT:
	  {
	  unsigned int_width_left = 0;
	  int skips = 0;
	  int_width = width;
#ifdef hardway
	  if (int_width == 0 || int_width > sizeof (buf) - 1)
#else
	  /* size_t is unsigned, hence this optimisation */
	  if (int_width - 1 > sizeof (buf) - 2)
#endif
	    {
	      int_width_left = width - (sizeof (buf) - 1);
	      int_width = sizeof (buf) - 1;
	    }
	  flags |= SIGNOK | NDIGITS | NZDIGITS | NNZDIGITS;
	  for (p = buf; int_width; int_width--)
	    {
	      c = *fp->_p;
	      /*
	       * Switch on the character; `goto ok' if we
	       * accept it as a part of number.
	       */
	      switch (c)
		{
		  /*
		   * The digit 0 is always legal, but is special.
		   * For %i conversions, if no digits (zero or nonzero)
		   * have been scanned (only signs), we will have base==0.
		   * In that case, we should set it to 8 and enable 0x
		   * prefixing. Also, if we have not scanned zero digits
		   * before this, do not turn off prefixing (someone else
		   * will turn it off if we have scanned any nonzero digits).
		   */
		case '0':
		  if (! (flags & NNZDIGITS))
		    goto ok;
		  if (base == 0)
		    {
		      base = 8;
		      flags |= PFXOK;
		    }
		  if (flags & NZDIGITS)
		    {
		      flags &= ~(SIGNOK | NZDIGITS | NDIGITS);
		      goto ok;
		    }
		  flags &= ~(SIGNOK | PFXOK | NDIGITS);
		  if (int_width_left)
		    {
		      int_width_left--;
		      int_width++;
		    }
		  ++skips;
		  goto skip;

		  /* 1 through 7 always legal */
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		  base = basefix[base];
		  flags &= ~(SIGNOK | PFXOK | NDIGITS | NNZDIGITS);
		  goto ok;

		  /* digits 8 and 9 ok iff decimal or hex */
		case '8':
		case '9':
		  base = basefix[base];
		  if (base <= 8)
		    break;	/* not legal here */
		  flags &= ~(SIGNOK | PFXOK | NDIGITS | NNZDIGITS);
		  goto ok;

		  /* letters ok iff hex */
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		  /* no need to fix base here */
		  if (base <= 10)
		    break;	/* not legal here */
		  flags &= ~(SIGNOK | PFXOK | NDIGITS | NNZDIGITS);
		  goto ok;

		  /* sign ok only as first character */
		case '+':
		case '-':
		  if (flags & SIGNOK)
		    {
		      flags &= ~SIGNOK;
		      goto ok;
		    }
		  break;

		  /* x ok iff flag still set & 2nd char */
		case 'x':
		case 'X':
		  if (flags & PFXOK && p == buf + 1)
		    {
		      base = 16;/* if %i */
		      flags &= ~PFXOK;
		      /* We must reset the NZDIGITS and NDIGITS
		         flags that would have been unset by seeing
		         the zero that preceded the X or x.  */
		      flags |= NZDIGITS | NDIGITS;
		      goto ok;
		    }
		  break;
		}

	      /*
	       * If we got here, c is not a legal character
	       * for a number.  Stop accumulating digits.
	       */
	      break;
	    ok:
	      /*
	       * c is legal: store it and look at the next.
	       */
	      *p++ = c;
	    skip:
	      if (--fp->_r > 0)
		fp->_p++;
	      else
#ifndef CYGNUS_NEC
	      if (__srefill (fp))
#endif
		break;		/* EOF */
	    }
	  /*
	   * If we had only a sign, it is no good; push back the sign.
	   * If the number ends in `x', it was [sign] '0' 'x', so push back
	   * the x and treat it as [sign] '0'.
	   */
	  if (flags & NDIGITS)
	    {
	      if (p > buf)
		_CAST_VOID ungetc (*(u_char *)-- p, fp);
	      goto match_failure;
	    }
	  c = ((u_char *) p)[-1];
	  if (c == 'x' || c == 'X')
	    {
	      --p;
	      /*(void)*/ ungetc (c, fp);
	    }
	  if ((flags & SUPPRESS) == 0)
	    {
	      u_long res;

	      *p = 0;
	      res = (*ccfn) (rptr, buf, (char **) NULL, base);
	      if ((flags & POINTER) && !(flags & VECTOR))
		*(va_arg (ap, _PTR *)) = (_PTR) (unsigned _POINTER_INT) res;
	      else if (flags & SHORT)
		{
		  if (!(flags & VECTOR))
		    sp = va_arg (ap, short *);
		  else if (!looped)
		    sp = vec_buf.h;
		  *sp++ = res;
		}
	      else if (flags & LONG)
		{
		  if (!(flags & VECTOR))
		    lp = va_arg (ap, long *);
		  else if (!looped)
		    lp = vec_buf.l;
		  *lp++ = res;
		}
#ifndef _NO_LONGLONG
	      else if (flags & LONGDBL)
		{
		  u_long_long resll;
		  if (ccfn == _strtoul_r)
		    resll = _strtoull_r (rptr, buf, (char **) NULL, base);
		  else
		    resll = _strtoll_r (rptr, buf, (char **) NULL, base);
		  llp = va_arg (ap, long long*);
		  *llp = resll;
		}
#endif
	      else
		{
		  if (!(flags & VECTOR))
		    {
		      ip = va_arg (ap, int *);
		      *ip++ = res;
		    }
		  else
		    {
		      if (!looped)
			ch_dest = vec_buf.c;
		      *ch_dest++ = (char)res;
		    }
		}
	      if (!(flags & VECTOR))
		nassigned++;
	    }
	  nread += p - buf + skips;
	  break;
	  }

#ifdef FLOATING_POINT
	case CT_FLOAT:
	{
	  /* scan a floating point number as if by strtod */
	  /* This code used to assume that the number of digits is reasonable.
	     However, ANSI / ISO C makes no such stipulation; we have to get
	     exact results even when there is an unreasonable amount of
	     leading zeroes.  */
	  long leading_zeroes = 0;
	  long zeroes, exp_adjust;
	  char *exp_start = NULL;
	  unsigned fl_width = width;
	  unsigned width_left = 0;
#ifdef hardway
	  if (fl_width == 0 || fl_width > sizeof (buf) - 1)
#else
	  /* size_t is unsigned, hence this optimisation */
	  if (fl_width - 1 > sizeof (buf) - 2)
#endif
	    {
	      width_left = fl_width - (sizeof (buf) - 1);
	      fl_width = sizeof (buf) - 1;
	    }
	  flags |= SIGNOK | NDIGITS | DPTOK | EXPOK;
	  zeroes = 0;
	  exp_adjust = 0;
	  for (p = buf; fl_width; )
	    {
	      c = *fp->_p;
	      /*
	       * This code mimicks the integer conversion
	       * code, but is much simpler.
	       */
	      switch (c)
		{

		case '0':
		  if (flags & NDIGITS)
		    {
		      flags &= ~SIGNOK;
		      zeroes++;
		      if (width_left)
			{
			  width_left--;
			  fl_width++;
			}
		      goto fskip;
		    }
		  /* Fall through.  */
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		  flags &= ~(SIGNOK | NDIGITS);
		  goto fok;

		case '+':
		case '-':
		  if (flags & SIGNOK)
		    {
		      flags &= ~SIGNOK;
		      goto fok;
		    }
		  break;
		case '.':
		  if (flags & DPTOK)
		    {
		      flags &= ~(SIGNOK | DPTOK);
		      leading_zeroes = zeroes;
		      goto fok;
		    }
		  break;
		case 'e':
		case 'E':
		  /* no exponent without some digits */
		  if ((flags & (NDIGITS | EXPOK)) == EXPOK
		      || ((flags & EXPOK) && zeroes))
		    {
		      if (! (flags & DPTOK))
			{
			  exp_adjust = zeroes - leading_zeroes;
			  exp_start = p;
			}
		      flags =
			(flags & ~(EXPOK | DPTOK)) |
			SIGNOK | NDIGITS;
		      zeroes = 0;
		      goto fok;
		    }
		  break;
		}
	      break;
	    fok:
	      *p++ = c;
	    fskip:
	      fl_width--;
              ++nread;
	      if (--fp->_r > 0)
		fp->_p++;
	      else
#ifndef CYGNUS_NEC
	      if (__srefill (fp))
#endif
		break;		/* EOF */
	    }
	  if (zeroes)
	    flags &= ~NDIGITS;
	  /*
	   * If no digits, might be missing exponent digits
	   * (just give back the exponent) or might be missing
	   * regular digits, but had sign and/or decimal point.
	   */
	  if (flags & NDIGITS)
	    {
	      if (flags & EXPOK)
		{
		  /* no digits at all */
		  while (p > buf)
                    {
		      ungetc (*(u_char *)-- p, fp);
                      --nread;
                    }
		  goto match_failure;
		}
	      /* just a bad exponent (e and maybe sign) */
	      c = *(u_char *)-- p;
              --nread;
	      if (c != 'e' && c != 'E')
		{
		  _CAST_VOID ungetc (c, fp);	/* sign */
		  c = *(u_char *)-- p;
                  --nread;
		}
	      _CAST_VOID ungetc (c, fp);
	    }
	  if ((flags & SUPPRESS) == 0)
	    {
#ifdef _NO_LONGDBL
	      double res;
#else  /* !_NO_LONG_DBL */
	      long double res;
#endif /* !_NO_LONG_DBL */
	      long new_exp = 0;

	      *p = 0;
	      if ((flags & (DPTOK | EXPOK)) == EXPOK)
		{
		  exp_adjust = zeroes - leading_zeroes;
		  new_exp = -exp_adjust;
		  exp_start = p;
		}
	      else if (exp_adjust)
                new_exp = _strtol_r (rptr, (exp_start + 1), NULL, 10) - exp_adjust;
	      if (exp_adjust)
		{

		  /* If there might not be enough space for the new exponent,
		     truncate some trailing digits to make room.  */
		  if (exp_start >= buf + sizeof (buf) - MAX_LONG_LEN)
		    exp_start = buf + sizeof (buf) - MAX_LONG_LEN - 1;
                 sprintf (exp_start, "e%ld", new_exp);
		}
#ifdef __SPE__
	      if (flags & FIXEDPOINT)
		{
		  __uint64_t ufix64;
		  if (flags & SIGNED)
		    ufix64 = (__uint64_t)_strtosfix64_r (rptr, buf, NULL);
                  else
		    ufix64 = _strtoufix64_r (rptr, buf, NULL);
		  if (flags & SHORT)
		    {
		      __uint16_t *sp = va_arg (ap, __uint16_t *);
		      *sp = (__uint16_t)(ufix64 >> 48);
		    }
		  else if (flags & LONG)
		    {
		      __uint64_t *llp = va_arg (ap, __uint64_t *);
		      *llp = ufix64;
		    }
		  else
		    {
		      __uint32_t *lp = va_arg (ap, __uint32_t *);
		      *lp = (__uint32_t)(ufix64 >> 32);
		    }
		  nassigned++;
		  break;
		}
	      
#endif /* __SPE__ */
#ifdef _NO_LONGDBL
	      res = _strtod_r (rptr, buf, NULL);
#else  /* !_NO_LONGDBL */
	      res = _strtold (buf, NULL);
#endif /* !_NO_LONGDBL */
	      if (flags & LONG)
		{
		  dp = va_arg (ap, double *);
		  *dp = res;
		}
	      else if (flags & LONGDBL)
		{
		  ldp = va_arg (ap, _LONG_DOUBLE *);
		  *ldp = res;
		}
	      else
		{
		  if (!(flags & VECTOR))
		    flp = va_arg (ap, float *);
		  else if (!looped)
		    flp = vec_buf.f;
		  *flp++ = res;
		}
	      if (!(flags & VECTOR))
		nassigned++;
	    }
	  break;
	}
#endif /* FLOATING_POINT */
	}
      if (vec_read_count-- > 1)
	{
	  looped = 1;
	  goto process;
	}
      if (flags & VECTOR)
	{
	  int i;
	  unsigned long *vp = va_arg (ap, unsigned long *);
	  for (i = 0; i < 4; ++i)
	    *vp++ = vec_buf.l[i];
	  nassigned++;
	}
    }
input_failure:
  return nassigned ? nassigned : -1;
match_failure:
  return nassigned;
}

@


1.17
log
@
2009-01-12  Nathan Froyd  <froydnj@@codesourcery.com>

        * libc/machine/powerpc/vfscanf.c (__sccl): Remove declaration.
@
text
@d15 3
a17 3
	int vscanf(const char *<[fmt]>, va_list <[list]>);
	int vfscanf(FILE *<[fp]>, const char *<[fmt]>, va_list <[list]>);
	int vsscanf(const char *<[str]>, const char *<[fmt]>, va_list <[list]>);
d19 1
a19 1
	int _vscanf_r(void *<[reent]>, const char *<[fmt]>, 
d21 1
a21 1
	int _vfscanf_r(void *<[reent]>, FILE *<[fp]>, const char *<[fmt]>, 
d23 1
a23 1
	int _vsscanf_r(void *<[reent]>, const char *<[str]>, const char *<[fmt]>, 
d221 2
a222 2
    register FILE *fp _AND 
    _CONST char *fmt _AND 
d243 2
a244 2
    register FILE *fp _AND 
    _CONST char *fmt _AND 
@


1.16
log
@
2006-09-26  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdio.h[_REENT_SMALL]: Do not allow macros
        for clearerr, feof, or fileno.
        * libc/include/sys/reent.h[_REENT_SMALL](struct _reent): Change
        the dummy std stream scheme to use pointers to const external
        fake files, one for each standard stream.
        * libc/stdio/local.h (CHECK_INIT): Change to take a file pointer
        argument.  For _REENT_SMALL, reset the file pointer if it
        matches one of the fake std stream pointers.
        * libc/stdio/clearerr.c: Fix CHECK_INIT macro to add file pointer
        argument.
        * libc/stdio/fclose.c: Ditto.
        * libc/stdio/feof.c: Ditto.
        * libc/stdio/ferror.c: Ditto.
        * libc/stdio/fflush.c: Ditto.
        * libc/stdio/fgetc.c: Ditto.
        * libc/stdio/fgets.c: Ditto.
        * libc/stdio/fileno.c: Ditto.
        * libc/stdio/findfp.c: Ditto.
        * libc/stdio/fputc.c: Ditto.
        * libc/stdio/fputs.c: Ditto.
        * libc/stdio/fread.c: Ditto.
        * libc/stdio/freopen.c: Ditto.
        * libc/stdio/fseek.c: Ditto.
        * libc/stdio/ftell.c: Ditto.
        * libc/stdio/fwrite.c: Ditto.
        * libc/stdio/getc.c: Ditto.
        * libc/stdio/getdelim.c: Ditto.
        * libc/stdio/putc.c: Ditto.
        * libc/stdio/refill.c: Ditto.
        * libc/stdio/setvbuf.c: Ditto.
        * libc/stdio/ungetc.c: Ditto.
        * libc/stdio/vfprintf.c: Ditto.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/wbuf.c: Ditto.: Ditto.
        * libc/stdio/wsetup.c: Ditto.
        * libc/stdio64/freopen64.c: Ditto.
        * libc/stdio64/fseeko64.c: Ditto.
        * libc/stdio64/ftello64.c: Ditto.
        * libc/machine/powerpc/vfprintf.c: Ditto.
        * libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@a210 2
/*static*/ u_char *__sccl ();

@


1.15
log
@
2005-02-07  Antony King  <antony.king@@st.com>

        * libc/stdio/clearerr.c (clearerr): Ensure CHECK_INIT() is
        called before _flockfile to prevent lock object use before
        initialisation. _REENT_SMALL_CHECK_INIT() and CHECK_INIT()
        take a struct _reent * instead of a FILE *.
        * libc/stdio/fclose.c (_fclose_r): Ditto.
        * libc/stdio/feof.c (feof): Ditto.
        * libc/stdio/ferror.c (ferror): Ditto.
        * libc/stdio/fflush.c (fflush): Ditto.
        * libc/stdio/fgetc.c (fgetc): Ditto.
        * libc/stdio/fgets.c (fgets): Ditto.
        * libc/stdio/fileno.c (fileno): Ditto.
        * libc/stdio/fputc.c (fputc): Ditto.
        * libc/stdio/fputs.c (fputs): Ditto.
        * libc/stdio/fread.c (fread): Ditto.
        * libc/stdio/freopen.c (_freopen_r): Ditto.
        * libc/stdio/fseek.c (_fseek_r): Ditto.
        * libc/stdio/ftell.c (_ftell_r): Ditto.
        * libc/stdio/fwrite.c (fwrite): Ditto.
        * libc/stdio/getc.c (getc): Ditto.
        * libc/stdio/getdelim.c (__getdelim): Ditto.
        * libc/stdio/putc.c (putc): Ditto.
        * libc/stdio/setvbuf.c (setvbuf): Ditto.
        * libc/stdio/ungetc.c (_ungetc_r): Ditto.
        * libc/stdio/vfprintf.c (_VFPRINTF_R): Ditto.
        * libc/stdio64/freopen64.c (_freopen64_r): Ditto.
        * libc/stdio64/fseeko64.c (_fseeko64_r): Ditto.
        * libc/stdio64/ftello64.c (_ftello64_r): Ditto.
        * libc/stdio/local.h (CHECK_INIT): Argument is now a struct
        _reent * instead of a FILE * and so replace incorrect use of
        _REENT with argument.
        * libc/sys/arm/syscalls.c (CHECK_INIT): Ditto.
        * libc/stdio/getchar.c (getchar): _REENT_SMALL_CHECK_INIT() and
        CHECK_INIT() take a struct _reent * instead of a FILE *.
        * libc/stdio/iprintf.c (iprintf, _iprintf_r): Ditto.
        * libc/stdio/iscanf.c (iscanf, _iscanf_r): Ditto.
        * libc/stdio/perror.c (perror): Ditto.
        * libc/stdio/printf.c (printf, _printf_r): Ditto.
        * libc/stdio/putchar.c (putchar): Ditto.
        * libc/stdio/puts.c (puts): Ditto.
        * libc/stdio/refill.c (__srefill): Ditto.
        * libc/stdio/scanf.c (scanf, _scanf_r): Ditto.
        * libc/stdio/vfscanf.c (VFSCANF, _VFSCANF_R): Ditto.
        * libc/stdio/viprintf.c (viprintf, _viprintf_r): Ditto.
        * libc/stdio/viscanf.c (viscanf, _viscanf_r): Ditto.
        * libc/stdio/vprintf.c (vprintf, _vprintf_r): Ditto.
        * libc/stdio/vscanf.c (vscanf, _vscanf_r): Ditto.
        * libc/stdio/wbuf.c (__swbuf): Ditto.
        * libc/stdio/wsetup.c (__swsetup): Ditto.
        * libc/stdlib/mallocr.c (malloc_stats): Ditto.
        * libc/stdlib/mstats.c (_mstats_r): Ditto.
        * libc/include/sys/reent.h (_REENT_SMALL_CHECK_INIT): Ditto.
        * libc/machine/powerpc/vfscanf.c (vfscanf): Ditto.
        * libc/stdio/fgetpos.c (_fgetpos_r): Removed unnecessary calls
        to _flockfile and _funlockfile; rely on locking in _ftell_r.
        * libc/stdio64/fgetpos64.c (_fgetpos64_r): Ditto (_ftello64_r).
        * libc/machine/powerpc/vfprintf.c (__sbprintf): Removed unnecessary
        initialision of _data field in FILE structure.
        * libc/machine/powerpc/vfprintf.c (VFPRINTF): Added CHECK_INIT() call.
@
text
@d227 1
a227 1
  CHECK_INIT(_REENT);
@


1.15.2.1
log
@2006-09-17  Paul Brook  <paul@@codesourcery.com>

	newlib/
	Backport form mainline
	2006-09-26  Jeff Johnston  <jjohnstn@@redhat.com>
	* libc/include/stdio.h: Do not allow macros
	for clearerr, feof, or fileno.
	* libc/include/sys/reent.h[_REENT_SMALL](struct _reent): Change
	the dummy std stream scheme to use pointers to const external
	fake files, one for each standard stream.
	* libc/stdio/local.h (CHECK_INIT): Change to take a file pointer
	argument.  For _REENT_SMALL, reset the file pointer if it
	matches one of the fake std stream pointers.
	* libc/stdio/clearerr.c: Fix CHECK_INIT macro to add file pointer
	argument.
	* libc/stdio/fclose.c: Ditto.
	* libc/stdio/feof.c: Ditto.
	* libc/stdio/ferror.c: Ditto.
	* libc/stdio/fflush.c: Ditto.
	* libc/stdio/fgetc.c: Ditto.
	* libc/stdio/fgets.c: Ditto.
	* libc/stdio/fileno.c: Ditto.
	* libc/stdio/findfp.c: Ditto.
	* libc/stdio/fputc.c: Ditto.
	* libc/stdio/fputs.c: Ditto.
	* libc/stdio/fread.c: Ditto.
	* libc/stdio/freopen.c: Ditto.
	* libc/stdio/fseek.c: Ditto.
	* libc/stdio/ftell.c: Ditto.
	* libc/stdio/fwrite.c: Ditto.
	* libc/stdio/getc.c: Ditto.
	* libc/stdio/getdelim.c: Ditto.
	* libc/stdio/putc.c: Ditto.
	* libc/stdio/refill.c: Ditto.
	* libc/stdio/setvbuf.c: Ditto.
	* libc/stdio/ungetc.c: Ditto.
	* libc/stdio/vfprintf.c: Ditto.
	* libc/stdio/vfscanf.c: Ditto.
	* libc/stdio/wbuf.c: Ditto.: Ditto.
	* libc/stdio/wsetup.c: Ditto.
	* libc/stdio64/freopen64.c: Ditto.
	* libc/stdio64/fseeko64.c: Ditto.
	* libc/stdio64/ftello64.c: Ditto.
	* libc/machine/powerpc/vfprintf.c: Ditto.
	* libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@d227 1
a227 1
  CHECK_INIT(_REENT, fp);
@


1.14
log
@
2004-11-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/stdio.h: Add new iprintf and iscanf variants.  Also
        do some reordering.
        * libc/machine/powerpc/vfscanf.c: Remove __sccl function.
        * libc/stdio/Makefile.am: Add support for new iprintf and iscanf
        family functions.
        * libc/stdio/Makefile.in: Regenerated.
        * libc/stdio/fiprintf.c: Remove doc to siprintf.c.
        * libc/stdio/iprintf.c: Ditto.
        * libc/stdio/local.h (__svfiscanf_r): New prototype.
        * libc/stdio/siprintf.c: Add docs for various iprintf family functions.
        * libc/stdio/sniprintf.c: Move docs to siprintf.c.
        * libc/stdio/stdio.tex: Add new functions.
        * libc/stdio/vfscanf.c: Split out __sccl function to separate
        file and add special name defines so this file can be used
        to build vfiscanf.o.
        * libc/stdio/asiprintf.c: New file.
        * libc/stdio/fiscanf.c: Ditto.
        * libc/stdio/iscanf.c: Ditto.
        * libc/stdio/sccl.c: Ditto.
        * libc/stdio/siscanf.c: Ditto.
        * libc/stdio/vasiprintf.c: Ditto.
        * libc/stdio/viprintf.c: Ditto.
        * libc/stdio/viscanf.c: Ditto.
        * libc/stdio/vsiprintf.c: Ditto.
        * libc/stdio/vsiscanf.c: Ditto.
        * libc/stdio/vsniprintf.c: Ditto.
@
text
@d227 2
a228 2
  CHECK_INIT(fp);
  return __svfscanf_r (fp->_data, fp, fmt, ap);
@


1.13
log
@
2004-10-04  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): For int conversions,
        count skipped zero characters as part of the nread count for %n.
        * libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@a1262 103
/*
 * Fill in the given table from the scanset at the given format
 * (just after `[').  Return a pointer to the character past the
 * closing `]'.  The table has a 1 wherever characters should be
 * considered part of the scanset.
 */

/*static*/
u_char *
__sccl (tab, fmt)
     register char *tab;
     register u_char *fmt;
{
  register int c, n, v;

  /* first `clear' the whole table */
  c = *fmt++;			/* first char hat => negated scanset */
  if (c == '^')
    {
      v = 1;			/* default => accept */
      c = *fmt++;		/* get new first char */
    }
  else
    v = 0;			/* default => reject */
  /* should probably use memset here */
  for (n = 0; n < 256; n++)
    tab[n] = v;
  if (c == 0)
    return fmt - 1;		/* format ended before closing ] */

  /*
   * Now set the entries corresponding to the actual scanset to the
   * opposite of the above.
   *
   * The first character may be ']' (or '-') without being special; the
   * last character may be '-'.
   */

  v = 1 - v;
  for (;;)
    {
      tab[c] = v;		/* take character c */
    doswitch:
      n = *fmt++;		/* and examine the next */
      switch (n)
	{

	case 0:		/* format ended too soon */
	  return fmt - 1;

	case '-':
	  /*
	   * A scanset of the form [01+-] is defined as `the digit 0, the
	   * digit 1, the character +, the character -', but the effect of a
	   * scanset such as [a-zA-Z0-9] is implementation defined.  The V7
	   * Unix scanf treats `a-z' as `the letters a through z', but treats
	   * `a-a' as `the letter a, the character -, and the letter a'.
	   *
	   * For compatibility, the `-' is not considerd to define a range if
	   * the character following it is either a close bracket (required by
	   * ANSI) or is not numerically greater than the character we just
	   * stored in the table (c).
	   */
	  n = *fmt;
	  if (n == ']' || n < c)
	    {
	      c = '-';
	      break;		/* resume the for(;;) */
	    }
	  fmt++;
	  do
	    {			/* fill in the range */
	      tab[++c] = v;
	    }
	  while (c < n);
#if 1			/* XXX another disgusting compatibility hack */
	  /*
	   * Alas, the V7 Unix scanf also treats formats such
	   * as [a-c-e] as `the letters a through e'. This too
	   * is permitted by the standard....
	   */
	  goto doswitch;
#else
	  c = *fmt++;
	  if (c == 0)
	    return fmt - 1;
	  if (c == ']')
	    return fmt;
#endif

	  break;


	case ']':		/* end of scanset */
	  return fmt;

	default:		/* just another character */
	  c = n;
	  break;
	}
    }
  /* NOTREACHED */
}
@


1.12
log
@
2004-06-02  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): For CT_INT conversions,
        reset digit flags appropriately after we have discovered "0x".
        * libc/machine/powerpc/vfscanf.c (__svfscanf_r): Ditto.
@
text
@d806 1
d856 1
d1014 1
a1014 1
	  nread += p - buf;
@


1.11
log
@
2004-05-25  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * newlib.hin: (_WANT_IO_POS_ARGS): New define.
        (_WANT_IO_LONG_LONG): Ditto.
        (_WANT_IO_LONG_DOUBLE): Ditto.
        * configure.in: Add new configuration options
        --enable-newlib-io-long-long and --enable-newlib-io-long-double
        which tie to new defines in newlib.hin.
        * configure: Regenerated.
        * configure.host: Add checks for new configuration options.  Also
        fix up check for --enable-newlib-io-pos-args so configuration
        option will override any default for a given platform.
        Remove defining compiler flags for the _WANT_IO* options.
        * libc/stdio/vfprintf.c: Change to use new newlib.hin defines
        instead of looking for old compiler flags.
        * libc/stdio/vfscanf.c: Ditto.
        * libc/stdio/vfieeefp.h: Ditto.
        * libc/machine/powerpc/vfprintf.c: Ditto.
        * libc/machine/powerpc/vfscanf.c: Ditto.
@
text
@d914 4
@


1.10
log
@        * libc/machine/powerpc/vfscanf.c (__svfscanf_r): Fix typo in
        CT_INT case.
@
text
@d106 1
d132 1
a132 1
#if defined WANT_IO_LONG_DBL && (LDBL_MANT_DIG > DBL_MANT_DIG)
d138 1
a138 1
#if defined WANT_PRINTF_LONG_LONG && defined __GNUC__
@


1.9
log
@
2004-04-23  Artem B. Bityuckiy  <abitytsky@@softminecorp.com>

        * configure.in: Define _MB_CAPABLE if mb supported.
        * configure: Regenerated.
        * configure.host: Remove manual setting of MB_CAPABLE compiler
        flag.
        * newlib.hin: Add _MB_CAPABLE flag.
        * libc/ctype/iswalpha.c, libc/ctype/iswblank.c: Include <newlib.h>
        and check for _MB_CAPABLE flag instead of MB_CAPABLE.
        * libc/ctype/iswcntrl.c, libc/ctype/iswprint.c: Ditto.
        * libc/ctype/iswpunct.c, libc/ctype/iswspace.c: Ditto.
        * libc/ctype/jp2uc.c: Ditto.
        * libc/ctype/towlower.c, libc/ctype/towupper.c: Ditto.
        * libc/locale/locale.c: Ditto
        * libc/machine/powerpc/vfscanf.c: Ditto
        * libc/stdio/vfprintf.c, libc/stdio/vfscanf.c: Ditto
        * libc/stdlib/mblen.c: Ditto
        * libc/stdlib/mblen_r.c, libc/stdlib/mbrlen.c: Ditto
        * libc/stdlib/mbrtowc.c, libc/stdlib/mbsrtowcs.c: Ditto
        * libc/stdlib/mbstowcs.c, libc/stdlib/mbtowc.c: Ditto
        * libc/stdlib/mbtowc_r.c, libc/stdlib/wcrtomb.c: Ditto
        * libc/stdlib/wcsrtombs.c, libc/stdlib/wcstombs.c: Ditto
        * libc/stdlib/wctomb.c, libc/sys/linux/intl/dcigettext.c: Ditto
        * libc/sys/linux/intl/explodename.c: Ditto
        * libc/sys/linux/intl/finddomain.c: Ditto
        * libc/sys/linux/intl/l10nflist.c: Ditto
        * libc/sys/linux/intl/loadmsgcat.c: Ditto
        * libc/sys/linux/intl/localealias.c: Ditto
@
text
@d803 1
d1009 1
@


1.8
log
@
2004-04-23  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/machine/powerpc/vfscanf.c (NNZDIGITS): New define.
        (__svfscanf_r): In integer conversions, leave out leading zeroes
        which are not part of a base prefix.
        Keep track of width truncation to fit into buf, not counting left-out
        zeroes against width till the truncation has been compensated for.
        This is based on Joern's patch of 04/21 for libc/stdio/vfscanf.c.
@
text
@d106 1
d283 1
a283 1
#ifdef MB_CAPABLE
d308 1
a308 1
#ifndef MB_CAPABLE
@


1.7
log
@
2003-03-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/stdio/vfscanf.c (__svfscanf_r): For floating point conversion,
        count all characters used to create number against maximum width.
        * libc/machine/powerpc/vfscanf.c (__svfscanf_r): Ditto.
@
text
@d156 3
a158 3
#define	SUPPRESS	0x08	/* suppress assignment */
#define	POINTER		0x10	/* weird %p pointer (`fake hex') */
#define	NOSKIP		0x20	/* do not skip blanks */
d166 2
a167 2
#define	SIGNOK		0x40	/* +/- is (still) legal */
#define	NDIGITS		0x80	/* no digits detected */
d169 2
a170 2
#define	DPTOK		0x100	/* (float) decimal point is still legal */
#define	EXPOK		0x200	/* (float) exponent (e+3, etc) still legal */
d172 7
a178 6
#define	PFXOK		0x100	/* 0x prefix is (still) legal */
#define	NZDIGITS	0x200	/* no zero digits detected */

#define	VECTOR		0x400	/* v: vector */
#define	FIXEDPOINT	0x800	/* r/R: fixed-point */
#define	SIGNED  	0x1000	/* r: signed fixed-point */
d802 1
a802 1
	  /* scan an integer as if by strtol/strtoul */
a805 1
	    int_width = sizeof (buf) - 1;
d808 1
a808 3
	  if (--int_width > sizeof (buf) - 2)
	    int_width = sizeof (buf) - 2;
	  int_width++;
d810 5
a814 1
	  flags |= SIGNOK | NDIGITS | NZDIGITS;
d834 2
d842 11
a852 4
		    flags &= ~(SIGNOK | NZDIGITS | NDIGITS);
		  else
		    flags &= ~(SIGNOK | PFXOK | NDIGITS);
		  goto ok;
d863 1
a863 1
		  flags &= ~(SIGNOK | PFXOK | NDIGITS);
d872 1
a872 1
		  flags &= ~(SIGNOK | PFXOK | NDIGITS);
d891 1
a891 1
		  flags &= ~(SIGNOK | PFXOK | NDIGITS);
d926 1
d1019 2
a1020 1
	  int fl_width = width;
a1022 1
	    fl_width = sizeof (buf) - 1;
d1025 1
a1025 3
	  if (--fl_width > sizeof (buf) - 2)
	    fl_width = sizeof (buf) - 2;
	  fl_width++;
d1027 4
d1049 5
@


1.6
log
@	* libc/include/langinfo.h: New file.
	* libc/include/wchar.h: Likewise.
	* libc/include/sys/syslimits.h: Likewise.
	* libc/locale/fix_grouping.c: Likewise.
	* libc/locale/ldpart.c: Likewise.
	* libc/locale/ldpart.h: Likewise.
	* libc/locale/lmessages.c: Likewise.
	* libc/locale/lmessages.h: Likewise.
	* libc/locale/lmonetary.c: Likewise.
	* libc/locale/lmonetary.h: Likewise.
	* libc/locale/lnumeric.c: Likewise.
	* libc/locale/lnumeric.h: Likewise.
	* libc/locale/nl_langinfo.3: Likewise.
	* libc/locale/nl_langinfo.c: Likewise.
	* libc/locale/timelocal.c: Likewise.
	* libc/locale/timelocal.h: Likewise.
	* libc/stdlib/btowc.c: Likewise.
	* libc/stdlib/mbrlen.c: Likewise.
	* libc/stdlib/mbrtowc.c: Likewise.
	* libc/stdlib/mbsinit.c: Likewise.
	* libc/stdlib/mbsrtowcs.c: Likewise.
	* libc/stdlib/wcrtomb.c: Likewise.
	* libc/stdlib/wcsrtombs.c: Likewise.
	* libc/stdlib/wctob.c: Likewise.
	* libc/sys/linux/prof-freq.c: Likewise.
	* libc/sys/linux/profile.c: Likewise.
	* libc/sys/linux/machine/i386/dl-procinfo.c: Likewise.
	* libc/sys/linux/machine/i386/dl-procinfo.h: Likewise.
	* libc/include/stdlib.h: Change re-entrant functions to take
	mbstate_t pointers.
	* libc/include/sys/_types.h: Define _mbstate_t.
	* libc/include/sys/config.h (MB_LEN_MAX): New macro.
	* libc/include/sys/errno.h (EILSEQ): New error code.
	* libc/include/sys/reent.h: Include wchar.h.  Change reentrant
	structure to use mbstate_t.
	* libc/locale/Makefile.am (LIB_SOURCES): Add new files.
	* libc/machine/powerpc/vfprintf.c: Use mbstate_t.
	* libc/machine/powerpc/vfscanf.c: Likewise.
	* libc/stdio/getdelim.c: Reallocate buffer only when necessary.
	* libc/stdio/vfprintf.c: Likewise.
	* libc/stdio/vfscanf.c: Likewise.
	* libc/stdlib/Makefile.am (LIB_SOURCES): Add new files.
	* libc/stdlib/mblen.c: Use mbstate_t.
	* libc/stdlib/mblen_r.c: Likewise.
	* libc/stdlib/mbstowcs.c: Likewise.
	* libc/stdlib/mbstowcs_r.c: Likewise.
	* libc/stdlib/mbtowc.c: Likewise.
	* libc/stdlib/mbtowc_r.c: Likewise.
	* libc/stdlib/wcstombs.c: Likewise.
	* libc/stdlib/wcstombs_r.c: Likewise.
	* libc/stdlib/wctomb_r.c: Likewise.
	* libc/sys/linux/Makefile.am (LIB_SOURCES): Add prof-freq.c and
	profile.c.
	* libc/sys/linux/machine/i386/Makefile.am (LIB_SOURCES): Add
	dl-procinfo.c.
	* libc/sys/linux/sys/errno.h (EILSEQ): New error code.
	* libc/sys/linux/sys/types.h (off_t): Define type.
	* testsuite/newlib.locale/UTF-8.c: Change locale name from UTF-8
	to C-UTF-8.
	* testsuite/newlib.locale/UTF-8.exp: Likewise.
@
text
@d1088 1
a1089 1
	    fskip:
@


1.5
log
@
2002-08-19  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/include/sys/types.h: Support __need_inttypes macro
        that only sets the __intxx and __uintxx types.
        * libc/machine/powerpc/Makefile.am: Add stdlib to include directories
        to get mprec.h.
        * libc/machine/powerpc/Makefile.in: Regenerated.
        * libc/machine/powerpc/vfprintf.c: Fix state variable type.
        * libc/machine/powerpc/vfscanf.c: Fix state variable type.  Remove
        redundant fixed-point conversion prototypes.
        * libc/machine/powerpc/machine/stdlib.h[__SPE__]: Include <sys/types.h>
        after setting __need_inttypes.
@
text
@d110 1
d282 1
a282 1
  int state;                    /* value to keep track of multibyte state */
@


1.4
log
@
2002-08-17  Jeff Johnston  <jjohnstn@@redhat.com>

        * configure.host: Add powerpc*-*-eabispe* configuration.
        * libc/machine/powerpc/atosfix16.c: New fixed-point conversion file.
        * libc/machine/powerpc/atosfix32.c: Ditto.
        * libc/machine/powerpc/atosfix64.c: Ditto.
        * libc/machine/powerpc/atoufix16.c: Ditto.
        * libc/machine/powerpc/atoufix32.c: Ditto.
        * libc/machine/powerpc/atoufix64.c: Ditto.
        * libc/machine/powerpc/fix64.h: Ditto.
        * libc/machine/powerpc/simdldtoa.c: Ditto.
        * libc/machine/powerpc/strtosfix16.c: Ditto.
        * libc/machine/powerpc/strtosfix32.c: Ditto.
        * libc/machine/powerpc/strtosfix64.c: Ditto.
        * libc/machine/powerpc/strtoufix16.c: Ditto.
        * libc/machine/powerpc/strtoufix32.c: Ditto.
        * libc/machine/powerpc/strtoufix64.c: Ditto.
        * libc/machine/powerpc/ufix64toa.c: Ditto.
        * libc/machine/powerpc/configure.in: Add check for
        powerpc*-eabispe and add fixed-point conversion functions.
        * libc/machine/powerpc/configure: Regenerated.
        * libc/machine/powerpc/vfprintf.c[__SPE__]: Add support for
        %r and %R format specifiers which handle fixed-point data.
        * libc/machine/powerpc/vfscanf.c[__SPE__]: Ditto.
        * libc/machine/powerpc/machine/stdlib.h[__SPE__]: Add fixed-point
        function prototypes.
@
text
@a109 1
#include <wchar.h>
a133 5
#ifdef __SPE__
extern __int64_t _strtosfix64_r _PARAMS((struct _reent *, char *s, char **sptr));
extern __uint64_t _strtoufix64_r _PARAMS((struct _reent *, char *s, char **sptr));
#endif

d281 1
a281 1
  mbstate_t state;                /* value to keep track of multibyte state */
@


1.3
log
@
2002-05-13  Jeff Johnston  <jjohnstn@@redhat.com>

        * libc/machine/powerpc/vfprintf.c(__VFPRINTF_R)[__ALTIVEC__]: Restore
        the original format specifier when looping for vectors to compensate
        for any changes made in vector %g format processing.
        Also add syntax checking for various invalid scenarios
        involving vector format extensions.
        * libc/machine/powerpc/vfscanf.c(__VFSCANF_R)[__ALTIVEC__]: Fix
        return code setting for vector formats.  Also treat vector
        separator mismatch as a match error instead of an input error.
        Perform some syntax checking for vector formats.
@
text
@d110 2
d135 5
d181 2
d287 1
a287 1
  int state = 0;                /* value to keep track of multibyte state */
d314 1
d480 10
d1161 28
@


1.2
log
@	* libc/machine/powerpc/vfprintf.c[__ALTIVEC__]: Add vector
	support for 'p' format.  Fix code to print bytes for vector
	integer formats that do not specify 'h' or 'l'.
	* libc/machine/powerpc/vfscanf.c[__ALTIVEC__]: Add vector support
	for 'p' specifier.  Fix code to scan 16 bytes for vector integer
	formats that do not specify 'h' or 'l'.
@
text
@d366 2
d387 2
d489 3
d590 1
a590 1
		goto input_failure;
d968 1
a968 1
		  else 
d1182 1
@


1.1
log
@
2002-04-19  Jeff Johnston  <jjohnstn@@redhat.com>

        *  configure.host: Add support for powerpc-eabialtivec*.
        *  libc/include/malloc.h: Add include of <machine/malloc.h>.
        *  libc/include/stdlib.h: Add include of <machine/stdlib.h>.
        *  libc/include/machine/malloc.h: New file.
        *  libc/include/machine/stdlib.h: Ditto.
        *  libc/include/machine/setjmp.h: Add support for powerpc altivec.
        *  libc/machine/powerpc/Makefile.am: Add conditional objects and
        sources based on configuration.
        *  libc/machine/powerpc/Makefile.in: Regenerated.
        *  libc/machine/powerpc/configure: Ditto.
        *  libc/machine/powerpc/configure.in: Add check for
        powerpc-eabialtivec* in which case add in additional source files.
        *  libc/machine/powerpc/setjmp.S: Add altivec support.
        *  libc/machine/powerpc/vec_calloc.c: New file.
        *  libc/machine/powerpc/vec_free.c: Ditto.
        *  libc/machine/powerpc/vec_malloc.c: Ditto.
        *  libc/machine/powerpc/vec_mallocr.c: Ditto.
        *  libc/machine/powerpc/vec_realloc.c: Ditto.
        *  libc/machine/powerpc/machine/malloc.h: Ditto.
        *  libc/machine/powerpc/machine/stdlib.h: Ditto.
        *  libc/machine/powerpc/vfprintf.c: New file that is vfprintf.c
        with added altivec format specifiers.
        *  libc/machine/powerpc/vfscanf.c: New file that is vfscanf.c with
        added altivec format specifiers.
@
text
@d373 5
a377 1
	    flags |= LONG;
d391 1
a391 1
	  vec_read_count = (flags & SHORT) ? 8 : 4;
a491 1
	  flags &= ~VECTOR;
d924 1
a924 1
	      if (flags & POINTER)
d957 10
a966 4
		    ip = va_arg (ap, int *);
		  else if (!looped)
		    ip = vec_buf.i;
		  *ip++ = res;
@

