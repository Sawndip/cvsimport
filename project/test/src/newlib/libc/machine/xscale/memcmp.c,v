head	1.5;
access;
symbols
	cygwin-1_7_35-release:1.5
	cygwin-1_7_34-release:1.5
	newlib-2_2_0:1.5.0.16
	cygwin-1_7_33-release:1.5
	cygwin-1_7_32-release:1.5
	cygwin-1_7_31-release:1.5
	cygwin-1_7_30-release:1.5
	cygwin-1_7_29-release:1.5
	cygwin-1_7_28-release:1.5
	newlib-2_1_0:1.5
	cygwin-1_7_27-release:1.5
	cygwin-1_7_26-release:1.5
	cygwin-1_7_25-release:1.5
	cygwin-1_7_24-release:1.5
	cygwin-1_7_23-release:1.5
	cygwin-1_7_22-release:1.5
	cygwin-1_7_21-release:1.5
	cygwin-1_7_20-release:1.5
	cygwin-1_7_19-release:1.5
	cygwin-64bit-postmerge:1.5
	cygwin-64bit-premerge-branch:1.5.0.14
	cygwin-64bit-premerge:1.5
	cygwin-1_7_18-release:1.5
	newlib-2_0_0:1.5
	cygwin-1_7_17-release:1.5
	cygwin-64bit-branch:1.5.0.12
	cygwin-1_7_16-release:1.5
	cygwin-1_7_15-release:1.5
	cygwin-1_7_14_2-release:1.5
	cygwin-1_7_14-release:1.5
	cygwin-1_7_12-release:1.5
	cygwin-1_7_11-release:1.5
	cygwin-1_7_10-release:1.5
	newlib-1_20_0:1.5
	cygwin-1_7_9-release:1.5
	cygwin-1_7_8-release:1.5
	newlib-1_19_0:1.5
	cygwin-1_7_7-release:1.5
	cygwin-1_7_5-release:1.5
	cygwin-1_7_4-release:1.5
	cygwin-1_7_3-release:1.5
	cygwin-1_7_2-release:1.5
	newlib-1_18_0:1.5
	cygwin-1_7_1-release:1.5
	newlib-1_17_0-arc:1.5.0.10
	binutils-arc-20080908-branch:1.5.0.8
	binutils-arc-20080908-branchpoint:1.5
	newlib-1_17_0:1.5
	newlib-1_16_0:1.5
	newlib-1_15_0:1.5
	newlib-csl-coldfire-4_1-32:1.5
	newlib-csl-sourcerygxx-4_1-32:1.5
	newlib-csl-innovasic-fido-3_4_4-33:1.5
	newlib-csl-coldfire-4_1-30:1.5
	newlib-csl-sourcerygxx-4_1-30:1.5
	newlib-csl-coldfire-4_1-28:1.5
	newlib-csl-sourcerygxx-4_1-28:1.5
	newlib-csl-arm-2006q3-27:1.5
	newlib-csl-sourcerygxx-4_1-27:1.5
	newlib-csl-arm-2006q3-26:1.5
	newlib-csl-sourcerygxx-4_1-26:1.5
	newlib-csl-sourcerygxx-4_1-24:1.5
	newlib-csl-sourcerygxx-4_1-23:1.5
	newlib-csl-sourcerygxx-4_1-21:1.5
	newlib-csl-arm-2006q3-21:1.5
	newlib-csl-arm-2006q3-19:1.5
	newlib-csl-sourcerygxx-4_1-19:1.5
	newlib-csl-sourcerygxx-4_1-18:1.5
	newlib-csl-sourcerygxx-3_4_4-25:1.5
	newlib-csl-sourcerygxx-4_1-17:1.5
	cr-0x5f1:1.5.0.6
	newlib-csl-sourcerygxx-4_1-14:1.5
	newlib-csl-sourcerygxx-4_1-13:1.5
	newlib-csl-sourcerygxx-4_1-12:1.5
	newlib-csl-sourcerygxx-4_1-9:1.5
	newlib-csl-sourcerygxx-4_1-8:1.5
	newlib-csl-sourcerygxx-4_1-7:1.5
	newlib-csl-arm-2006q1-6:1.5
	newlib-csl-sourcerygxx-4_1-6:1.5
	newlib-csl-sourcerygxx-4_1-5:1.5
	newlib-csl-sourcerygxx-4_1-4:1.5
	newlib-autotools-branch:1.5.0.4
	newlib-csl-20060320-branch:1.5.0.2
	newlib-csl-20060320-branchpoint:1.5
	newlib-1_14_0:1.5
	newlib-csl-arm-2005-q1b:1.5
	newlib-csl-arm-2005-q1a:1.5
	newlib-1_13_0:1.5
	csl-arm-2004-q3:1.5
	csl-arm-2004-q1a:1.5
	csl-arm-2004-q1:1.5
	newlib-1_12_0:1.5
	csl-arm-2003-q4:1.5
	w32api-2_2:1.4
	mingw-runtime-2_4:1.4
	newlib-1_11_0:1.4
	cygnus_cvs_20020108_pre:1.3
	newlib-1_10_0:1.3
	newlib-1_9_0:1.1;
locks; strict;
comment	@ * @;


1.5
date	2003.09.05.00.45.54;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.20.00.29.51;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.25.21.17.06;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.19.20.37.18;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.30.01.57.27;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.5
log
@	* libc/machine/xscale/memcmp.c (memcmp): Strip trailing whitespace
	after continuation characters that induces a warning from modern
	versions of GCC.
@
text
@#if defined __thumb__

#include "../../string/memcmp.c"

#else

#include <string.h>
#include "xscale.h"

int
memcmp (const void * s1, const void * s2, size_t len)
{
  int result;
  asm (
#ifndef __OPTIMIZE_SIZE__ 
"\n\
	cmp	%2, #0x3	@@ Is the length a multiple of four ?\n\
	bls	6f		@@ no  = goto SLOW CHECK\n\
	and	r2, %0, #0x3	@@ get alignment of first pointer\n\
	and	r3, %1, #0x3	@@ get alignment of second pointer\n\
	cmp	r2, r3		@@ Do the two pointers share the same alignment ?\n\
	bne	6f		@@ no = goto SLOW CHECK\n\
	mov	lr, %0		@@ copy first pointer into LR\n\
	mov	r4, %1		@@ copy second pointer into R4\n\
	cmp	r2, #0x0	@@ Are we comparing word aligned pointers ?\n\
	beq	3f		@@ yes = goto START WORD CHECK LOOP\n\
	b	1f		@@ jump to LOOP TEST\n\
0:			       @@ LOOP START\n\
	ldrb	r2, [lr], #1	@@ load byte from LR, post inc.\n\
"	PRELOADSTR("lr") "	@@ preload\n\
	ldrb	r3, [r4], #1	@@ load byte from R4, post inc.\n\
"	PRELOADSTR("r4") "	@@ preload\n\
	cmp	r2, r3		@@ are the two bytes the same ?\n\
	bne	5f		@@ no = goto EXIT\n\
	tst	lr, #0x3	@@ has the LR become word aligned ?\n\
	bne     1f		@@ no = skip the next test\n\
	cmp     %2, #4		@@ is the count >= 4 ?\n\
	bhs     3f		@@ yes = goto START WORD CHECK LOOP\n\
1:			       @@ LOOP TEST\n\
	sub	%2, %2, #1	@@ decrement count by one\n\
	cmn	%2, #0x1	@@ has the count reached -1 ?\n\
	bne	0b		@@ no = loop back to LOOP START\n\
	b	4f		@@ goto PASS END\n\
\n\
0:			       @@ ??\n\
	cmp	%2, #0x7	@@ Is the count a multiple of 8 ?\n\
	bls	3f		@@ no = goto ???\n\
	ldmia	lr,{r2, r3}	@@ get two words from first pointer, post inc\n\
	ldmia	r4,{r5, r6}	@@ get two words from second pointer, post inc\n\
	sub	%2, %2, #0x4	@@ decrement count by 4\n\
	cmp	r2, r5		@@ has the count reached ????\n\
	bne	1f		@@ no = goto\n\
	sub	%2, %2, #0x4	@@ decrement the count by 4\n\
	add	lr, lr, #0x4	@@ add 4 to first pointer\n\
	add	r4, r4, #0x4	@@ add 4 to second pointer\n\
	cmp	r3, r6		@@ ???\n\
	beq	0b		@@ goto ???\n\
1:			       @@ ??\n\
	add	%2, %2, #0x4	@@ Add four to count\n\
	sub	%0, lr, #0x4	@@ decrement first pointer by 4\n\
	sub	%1, r4, #0x4	@@ decrement second pointer by 4\n\
	b	6f		@@ goto SLOW CHECK\n\
\n\
3:			       @@ START WORD CHECK LOOP\n\
	cmp	%2, #0x3	@@ is the count <= 3 ?\n\
	bls	1f		@@ yes = goto CHECK BYTES BY HAND\n\
	ldr	r2, [lr], #4	@@ get word from LR, post inc\n\
	ldr	r3, [r4], #4	@@ get word from R4, post inc\n\
	sub	%2, %2, #4	@@ decrement count by 4\n\
	cmp	r2, r3		@@ are the two words the same ?\n\
	bne	1f		@@ no = goto CHECK WORD CONTENTS\n\
0:			       @@ WORD CHECK LOOP\n\
	cmp	%2, #0x3	@@ is the count <= 3 ?\n\
	bls	1f		@@ yes = goto CHECK BYTES BY HAND\n\
	ldr	r2, [lr], #4	@@ load word from LR, post inc\n\
"	PRELOADSTR("lr") "	@@ preload\n\
	ldr	r3, [r4], #4	@@ load word from R4, post inc\n\
"	PRELOADSTR("r4") "	@@ preload\n\
	sub	%2, %2, #4	@@ decrement count by 4\n\
	cmp	r2, r3		@@ are the two words the same ?\n\
	beq	0b		@@ yes = goto WORD CHECK LOOP\n\
1:			       @@ CHECK BYTES BY HAND\n\
	sub	%0, lr, #0x4	@@ move LR back a word and put into first pointer\n\
	sub	%1, r4, #0x4	@@ move R4 back a word and put into second pointer\n\
	add	%2, %2, #4	@@ increment the count by 4\n\
				@@ fall through into SLOW CHECK"
#endif /* !__OPTIMIZE_SIZE__ */
"\n\
6:			       @@ SLOW CHECK\n\
	sub	%2, %2, #1	@@ Decrement the count by one\n\
	cmn	%2, #0x1	@@ Has the count reached -1 ?\n\
	beq	4f		@@ Yes - we are finished, goto PASS END\n\
0:			       @@ LOOP1\n\
	ldrb	r2, [%0], #1	@@ get byte from first pointer\n\
"	PRELOADSTR("%0") "	@@ preload first pointer\n\
	ldrb	r3, [%1], #1	@@ get byte from second pointer\n\
"	PRELOADSTR("%1") "	@@ preload second pointer\n\
	cmp	r2, r3		@@ compare the two loaded bytes\n\
	bne	5f		@@ if they are not equal goto EXIT\n\
	sub	%2, %2, #1	@@ decremented count by 1\n\
	cmn	%2, #0x1	@@ has the count reached -1 ?\n\
	bne	0b		@@ no = then go back to LOOP1\n\
4:			       @@ PASS END\n\
	mov	r3, r2		@@ Default return value is 0\n\
5:			       @@ EXIT\n\
	rsb	%0, r3, r2	@@ return difference between last two bytes loaded"
       : "=r" (result), "=&r" (s2), "=&r" (len)
       : "0" (s1), "1" (s2), "2" (len)
       : "r2", "r3", "r4", "r5", "r6", "cc", "lr");
  return result;
}
#endif
@


1.4
log
@
2002-04-19  Bill Siegmund

        * libc/machine/xscale/memchr.c: Don't use multi-line strings.
        * libc/machine/xscale/memcmp.c: Ditto.
        * libc/machine/xscale/memcpy.c: Ditto.
        * libc/machine/xscale/memmove.c: Ditto.
        * libc/machine/xscale/memset.c: Ditto.
        * libc/machine/xscale/strchr.c: Ditto.
        * libc/machine/xscale/strcmp.c: Ditto.
        * libc/machine/xscale/strcpy.c: Ditto.
        * libc/machine/xscale/strlen.c: Ditto.
@
text
@d30 1
a30 1
"	PRELOADSTR("lr") "	@@ preload\n\ 
d52 1
a52 1
	bne	1f		@@ no = goto\n\ 
@


1.3
log
@Fix  bug when both pointers have matching, non-word alignment, and the length
is <= 4 but more than enough to move them over a word boundary.
Add comments explaining what each instruction does.
@
text
@d16 70
a85 70
"		
	cmp	%2, #0x3	@@ Is the length a multiple of four ?
	bls	6f		@@ no  = goto SLOW CHECK
	and	r2, %0, #0x3	@@ get alignment of first pointer
	and	r3, %1, #0x3	@@ get alignment of second pointer
	cmp	r2, r3		@@ Do the two pointers share the same alignment ?
	bne	6f		@@ no = goto SLOW CHECK
	mov	lr, %0		@@ copy first pointer into LR
	mov	r4, %1		@@ copy second pointer into R4
	cmp	r2, #0x0	@@ Are we comparing word aligned pointers ?
	beq	3f		@@ yes = goto START WORD CHECK LOOP
	b	1f		@@ jump to LOOP TEST
0:			       @@ LOOP START
	ldrb	r2, [lr], #1	@@ load byte from LR, post inc.
"	PRELOADSTR("lr") "	@@ preload 
	ldrb	r3, [r4], #1	@@ load byte from R4, post inc.
"	PRELOADSTR("r4") "	@@ preload
	cmp	r2, r3		@@ are the two bytes the same ?
	bne	5f		@@ no = goto EXIT
	tst	lr, #0x3	@@ has the LR become word aligned ?
	bne     1f		@@ no = skip the next test
	cmp     %2, #4		@@ is the count >= 4 ?
	bhs     3f		@@ yes = goto START WORD CHECK LOOP
1:			       @@ LOOP TEST
	sub	%2, %2, #1	@@ decrement count by one
	cmn	%2, #0x1	@@ has the count reached -1 ?
	bne	0b		@@ no = loop back to LOOP START
	b	4f		@@ goto PASS END

0:			       @@ ??
	cmp	%2, #0x7	@@ Is the count a multiple of 8 ?
	bls	3f		@@ no = goto ???
	ldmia	lr,{r2, r3}	@@ get two words from first pointer, post inc
	ldmia	r4,{r5, r6}	@@ get two words from second pointer, post inc
	sub	%2, %2, #0x4	@@ decrement count by 4
	cmp	r2, r5		@@ has the count reached ????
	bne	1f		@@ no = goto 
	sub	%2, %2, #0x4	@@ decrement the count by 4
	add	lr, lr, #0x4	@@ add 4 to first pointer
	add	r4, r4, #0x4	@@ add 4 to second pointer
	cmp	r3, r6		@@ ???
	beq	0b		@@ goto ???
1:			       @@ ??
	add	%2, %2, #0x4	@@ Add four to count
	sub	%0, lr, #0x4	@@ decrement first pointer by 4
	sub	%1, r4, #0x4	@@ decrement second pointer by 4
	b	6f		@@ goto SLOW CHECK

3:			       @@ START WORD CHECK LOOP
	cmp	%2, #0x3	@@ is the count <= 3 ?
	bls	1f		@@ yes = goto CHECK BYTES BY HAND
	ldr	r2, [lr], #4	@@ get word from LR, post inc
	ldr	r3, [r4], #4	@@ get word from R4, post inc
	sub	%2, %2, #4	@@ decrement count by 4
	cmp	r2, r3		@@ are the two words the same ?
	bne	1f		@@ no = goto CHECK WORD CONTENTS
0:			       @@ WORD CHECK LOOP
	cmp	%2, #0x3	@@ is the count <= 3 ?
	bls	1f		@@ yes = goto CHECK BYTES BY HAND
	ldr	r2, [lr], #4	@@ load word from LR, post inc
"	PRELOADSTR("lr") "	@@ preload
	ldr	r3, [r4], #4	@@ load word from R4, post inc
"	PRELOADSTR("r4") "	@@ preload
	sub	%2, %2, #4	@@ decrement count by 4
	cmp	r2, r3		@@ are the two words the same ?
	beq	0b		@@ yes = goto WORD CHECK LOOP
1:			       @@ CHECK BYTES BY HAND
	sub	%0, lr, #0x4	@@ move LR back a word and put into first pointer
	sub	%1, r4, #0x4	@@ move R4 back a word and put into second pointer
	add	%2, %2, #4	@@ increment the count by 4
d88 18
a105 18
"
6:			       @@ SLOW CHECK
	sub	%2, %2, #1	@@ Decrement the count by one
	cmn	%2, #0x1	@@ Has the count reached -1 ?
	beq	4f		@@ Yes - we are finished, goto PASS END
0:			       @@ LOOP1
	ldrb	r2, [%0], #1	@@ get byte from first pointer
"	PRELOADSTR("%0") "	@@ preload first pointer
	ldrb	r3, [%1], #1	@@ get byte from second pointer
"	PRELOADSTR("%1") "	@@ preload second pointer
	cmp	r2, r3		@@ compare the two loaded bytes
	bne	5f		@@ if they are not equal goto EXIT
	sub	%2, %2, #1	@@ decremented count by 1
	cmn	%2, #0x1	@@ has the count reached -1 ?
	bne	0b		@@ no = then go back to LOOP1
4:			       @@ PASS END
	mov	r3, r2		@@ Default return value is 0
5:			       @@ EXIT
@


1.2
log
@Add missing clobber of LR
@
text
@d11 1
a11 1
memcmp (const void *s1, const void *s2, size_t len)
d17 27
a43 25
	cmp	%2, #0x3
	bls	6f
	and	r2, %0, #0x3
	and	r3, %1, #0x3
	cmp	r2, r3
	bne	6f
	mov	lr, %0
	mov	r4, %1
	cmp	r2, #0x0
	beq	3f
	b	1f
0:
	ldrb	r2, [lr], #1	@@ zero_extendqisi2
"	PRELOADSTR("lr") "
	ldrb	r3, [r4], #1	@@ zero_extendqisi2
"	PRELOADSTR("r4") "
	cmp	r2, r3
	bne	5f
	tst	lr, #0x3
	beq	3f
1:
	sub	%2, %2, #1
	cmn	%2, #0x1
	bne	0b
	b	4f
d45 42
a86 41
0:
	cmp	%2, #0x7
	bls	3f
	ldmia	lr,{r2, r3}
	ldmia	r4,{r5, r6}
	sub	%2, %2, #0x4
	cmp	r2, r5
	bne	1f
	sub	%2, %2, #0x4
	add	lr, lr, #0x4
	add	r4, r4, #0x4
	cmp	r3, r6
	beq	0b
1:
	add	%2, %2, #0x4
	sub	%0, lr, #0x4
	sub	%1, r4, #0x4
	b	6f
3:
	cmp	%2, #0x3
	bls	1f
	ldr	r2, [lr], #4
	ldr	r3, [r4], #4
	sub	%2, %2, #4
	cmp	r2, r3
	bne	1f
0:
	cmp	%2, #0x3
	bls	1f
	ldr	r2, [lr], #4
"	PRELOADSTR("lr") "
	ldr	r3, [r4], #4
"	PRELOADSTR("r4") "
	sub	%2, %2, #4
	cmp	r2, r3
	beq	0b
1:
	sub	%0, lr, #0x4
	sub	%1, r4, #0x4
	add	%2, %2, #4
"
d89 18
a106 18
6:				
	sub	%2, %2, #1
	cmn	%2, #0x1
	beq	4f
0:
	ldrb	r2, [%0], #1	@@ zero_extendqisi2
"	PRELOADSTR("%0") "
	ldrb	r3, [%1], #1	@@ zero_extendqisi2
"	PRELOADSTR("%1") "
	cmp	r2, r3
	bne	5f
	sub	%2, %2, #1
	cmn	%2, #0x1
	bne	0b
4:		
	mov	r3, r2
5:		
	rsb	%0, r3, r2"
@


1.1
log
@Add support for Intel's XScale processor
@
text
@d106 1
a106 1
       : "r2", "r3", "r4", "r5", "r6", "cc");
@

