head	1.5;
access;
symbols
	cygwin-1_7_35-release:1.5
	cygwin-1_7_34-release:1.5
	newlib-2_2_0:1.4.0.4
	cygwin-1_7_33-release:1.4
	cygwin-1_7_32-release:1.4
	cygwin-1_7_31-release:1.4
	cygwin-1_7_30-release:1.4
	cygwin-1_7_29-release:1.4
	cygwin-1_7_28-release:1.4
	newlib-2_1_0:1.4
	cygwin-1_7_27-release:1.4
	cygwin-1_7_26-release:1.4
	cygwin-1_7_25-release:1.4
	cygwin-1_7_24-release:1.4
	cygwin-1_7_23-release:1.4
	cygwin-1_7_22-release:1.4
	cygwin-1_7_21-release:1.4
	cygwin-1_7_20-release:1.4
	cygwin-1_7_19-release:1.4
	cygwin-64bit-postmerge:1.4
	cygwin-64bit-premerge-branch:1.4.0.2
	cygwin-64bit-premerge:1.4
	cygwin-1_7_18-release:1.4
	newlib-2_0_0:1.4
	cygwin-1_7_17-release:1.4
	cygwin-64bit-branch:1.3.0.2
	cygwin-1_7_16-release:1.3
	cygwin-1_7_15-release:1.3
	cygwin-1_7_14_2-release:1.3
	cygwin-1_7_14-release:1.3
	cygwin-1_7_12-release:1.3
	cygwin-1_7_11-release:1.3
	cygwin-1_7_10-release:1.3
	newlib-1_20_0:1.3
	cygwin-1_7_9-release:1.3
	cygwin-1_7_8-release:1.3
	newlib-1_19_0:1.3
	cygwin-1_7_7-release:1.3
	cygwin-1_7_5-release:1.3
	cygwin-1_7_4-release:1.3
	cygwin-1_7_3-release:1.3
	cygwin-1_7_2-release:1.3
	newlib-1_18_0:1.3
	cygwin-1_7_1-release:1.3
	newlib-1_17_0-arc:1.2.0.4
	binutils-arc-20080908-branch:1.2.0.2
	binutils-arc-20080908-branchpoint:1.2
	newlib-1_17_0:1.2
	newlib-1_16_0:1.2
	newlib-1_15_0:1.1.1.1
	newlib-csl-coldfire-4_1-32:1.1.1.1
	newlib-csl-sourcerygxx-4_1-32:1.1.1.1
	newlib-csl-innovasic-fido-3_4_4-33:1.1.1.1
	newlib-csl-coldfire-4_1-30:1.1.1.1
	newlib-csl-sourcerygxx-4_1-30:1.1.1.1
	newlib-csl-coldfire-4_1-28:1.1.1.1
	newlib-csl-sourcerygxx-4_1-28:1.1.1.1
	newlib-csl-arm-2006q3-27:1.1.1.1
	newlib-csl-sourcerygxx-4_1-27:1.1.1.1
	newlib-csl-arm-2006q3-26:1.1.1.1
	newlib-csl-sourcerygxx-4_1-26:1.1.1.1
	newlib-csl-sourcerygxx-4_1-24:1.1.1.1
	newlib-csl-sourcerygxx-4_1-23:1.1.1.1
	newlib-csl-sourcerygxx-4_1-21:1.1.1.1
	newlib-csl-arm-2006q3-21:1.1.1.1
	newlib-csl-arm-2006q3-19:1.1.1.1
	newlib-csl-sourcerygxx-4_1-19:1.1.1.1
	newlib-csl-sourcerygxx-4_1-18:1.1.1.1
	newlib-csl-sourcerygxx-3_4_4-25:1.1.1.1
	newlib-csl-sourcerygxx-4_1-17:1.1.1.1
	cr-0x5f1:1.1.1.1.0.6
	newlib-csl-sourcerygxx-4_1-14:1.1.1.1
	newlib-csl-sourcerygxx-4_1-13:1.1.1.1
	newlib-csl-sourcerygxx-4_1-12:1.1.1.1
	newlib-csl-sourcerygxx-4_1-9:1.1.1.1
	newlib-csl-sourcerygxx-4_1-8:1.1.1.1
	newlib-csl-sourcerygxx-4_1-7:1.1.1.1
	newlib-csl-arm-2006q1-6:1.1.1.1
	newlib-csl-sourcerygxx-4_1-6:1.1.1.1
	newlib-csl-sourcerygxx-4_1-5:1.1.1.1
	newlib-csl-sourcerygxx-4_1-4:1.1.1.1
	newlib-autotools-branch:1.1.1.1.0.4
	newlib-csl-20060320-branch:1.1.1.1.0.2
	newlib-csl-20060320-branchpoint:1.1.1.1
	newlib-1_14_0:1.1.1.1
	newlib-csl-arm-2005-q1b:1.1.1.1
	newlib-csl-arm-2005-q1a:1.1.1.1
	newlib-1_13_0:1.1.1.1
	csl-arm-2004-q3:1.1.1.1
	csl-arm-2004-q1a:1.1.1.1
	csl-arm-2004-q1:1.1.1.1
	newlib-1_12_0:1.1.1.1
	csl-arm-2003-q4:1.1.1.1
	w32api-2_2:1.1.1.1
	mingw-runtime-2_4:1.1.1.1
	newlib-1_11_0:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	newlib-1_10_0:1.1.1.1
	newlib-1_9_0:1.1.1.1
	newlib-2000-02-17:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2015.01.14.21.15.36;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2012.09.26.19.11.41;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.25.21.16.04;	author jjohnstn;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2007.01.02.16.59.59;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.17.19.39.46;	author cgf;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2012.10.16.15.58.09;	author corinna;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.17.19.39.46;	author cgf;	state Exp;
branches;
next	;


desc
@@


1.5
log
@
2015-01-14  Joel Sherrill <joel.sherrill@@oarcorp.com>

        * doc/makedoc.c: Use uintptr_t to avoid int/pointer size warnings
@
text
@/* chew
   Copyright (C) 1990-1992 Free Software Foundation, Inc.
   Contributed by steve chamberlain @@cygnus


This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/*
 Yet another way of extracting documentation from source.
 No, I haven't finished it yet, but I hope you people like it better
 that the old way
  
 sac

Basically, this is a sort of string forth, maybe we should call it
struth?

You define new words thus:
: <newword> <oldwords> ;
There is  no

*/



#include "ansidecl.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <stdint.h>

#define DEF_SIZE 5000
#define STACK 50
#define MIN_CMDLEN	4	/* Minimum length of a command */

int internal_wanted;
int internal_mode;
int Verbose=0;



/* Here is a string type ... */

typedef struct buffer 
{
    char *ptr;
    unsigned int write_idx;
    unsigned int size;
} string_type;







static void DEFUN(init_string_with_size,(buffer, size),
	   string_type *buffer AND
	   unsigned int size )
{
  buffer->write_idx = 0;
  buffer->size = size;
  buffer->ptr = malloc(size);
}

static void DEFUN(init_string,(buffer),
	   string_type *buffer)
{
    init_string_with_size(buffer, DEF_SIZE);

}

static int DEFUN(find, (str, what),
	  string_type *str AND
	  char *what)
{
    unsigned int i;
    char *p;
    p = what;
    for (i = 0; i < str->write_idx && *p; i++) 
    {
	if (*p == str->ptr[i])
	 p++;
	else
	 p = what;
    }
    return (*p == 0);
    
}

static void DEFUN(write_buffer,(buffer),
	   string_type *buffer)
{
    fwrite(buffer->ptr, buffer->write_idx, 1, stdout);
}


static void DEFUN(delete_string,(buffer),
	   string_type *buffer)
{
    free(buffer->ptr);
}


static char *DEFUN(addr, (buffer, idx),
	    string_type *buffer AND
	    unsigned int idx)
{
    return buffer->ptr + idx;
}

static char DEFUN(at,(buffer, pos),
	   string_type *buffer AND
	   unsigned int pos) 
{
    if ( pos >= buffer->write_idx) 
    {
	return 0;
    }
    return buffer->ptr[pos];
}

static void DEFUN(catchar,(buffer, ch), 
	   string_type *buffer AND
	   char ch)
{
  if (buffer->write_idx == buffer->size) 
  {
    buffer->size *=2;
    buffer->ptr = realloc(buffer->ptr, buffer->size);
  }

  buffer->ptr[buffer->write_idx ++ ] = ch;
}


static void DEFUN(overwrite_string,(dst,   src),
	   string_type *dst AND
	   string_type *src)
{
    free(dst->ptr);
    dst->size = src->size;
    dst->write_idx = src->write_idx;
    dst->ptr = src->ptr;
}

static void DEFUN(catstr,(dst, src),
	   string_type *dst AND
	   string_type *src)
{
    unsigned int i;
    for (i = 0; i < src->write_idx; i++) 
    {
	catchar(dst, src->ptr[i]);
    }
}


static void DEFUN(cattext,(buffer, string),
	   string_type *buffer AND
	   char *string)
{
    
    while (*string) 
    {
	catchar(buffer, *string);
	string++;
    }
}

static void DEFUN(catbuf,(buffer, buf, len),
	   string_type *buffer AND
	   char *buf AND
	   unsigned int len)
{
    
    while (len--) 
    {
	catchar(buffer, *buf);
	buf++;
    }
}



static unsigned int 
DEFUN(skip_white_and_stars,(src, idx),
      string_type *src AND
      unsigned int idx)
{
    while (isspace(at(src,idx)) 
	   || (at(src,idx) == '*' && at(src,idx +1) !='/')) 
     idx++;
    return idx;
    

}
/***********************************************************************/


string_type stack[STACK];
string_type *tos;

unsigned int idx = 0; /* Pos in input buffer */
string_type *ptr; /* and the buffer */
typedef void (*stinst_type)(NOARGS);
stinst_type *pc;
stinst_type sstack[STACK];
stinst_type *ssp = &sstack[0];
uintptr_t istack[STACK];
uintptr_t *isp = &istack[0];

typedef uintptr_t *word_type;



struct dict_struct
{
    char *word;
    struct dict_struct *next;
   stinst_type *code;
    int code_length;
    int code_end;
    int var;
    
};
typedef struct dict_struct dict_type;
#define WORD(x) static void x(NOARGS)

static void DEFUN(exec,(word),
		  dict_type *word)
{
    pc = word->code;
    while (*pc) 
    {
	(*pc)();
    }
    
}
WORD(call)
{
stinst_type *oldpc = pc;
    dict_type *e;
    e =  (dict_type *)(pc [1]);
    exec(e);
    pc = oldpc + 2;
    
}

WORD(remchar)
{
    tos->write_idx--;    
    pc++;
    
}

WORD(push_number)
{
    isp++;
    pc++;
    *isp = (uintptr_t)(*pc);
    pc++;
    
}




WORD(push_text)
{
    
    tos++;
    init_string(tos);
    pc++;
    cattext(tos,*((char **)pc));
    pc++;
    
}


   
/* This function removes everything not inside comments starting on
   the first char of the line from the  string, also when copying
   comments, removes blank space and leading *'s 
   Blank lines are turned into one blank line
 */

static void 
DEFUN(remove_noncomments,(src,dst),
	   string_type *src AND
	   string_type *dst)
{
    unsigned int idx = 0;
    
    while (at(src,idx)) 
    {
	/* Now see if we have a comment at the start of the line */
	if (at(src,idx) == '\n' 
	    && at(src,idx+1) ==  '/' 
	    && at(src,idx+2) == '*') 
	{
	    idx+=3;
	    
	    idx = skip_white_and_stars(src,idx);

	    /* Remove leading dot */
	    if (at(src, idx) == '.')
	     idx++;
	    
	    /* Copy to the end of the line, or till the end of the
	       comment */
	    while (at(src, idx))
	    {
		if (at(src, idx) == '\n') 
		{
		    /* end of line, echo and scrape of leading blanks  */
		    if (at(src,idx +1) == '\n')
		     catchar(dst,'\n');
		    catchar(dst,'\n');
		    idx++;
		    idx =   skip_white_and_stars(src, idx);
		}
		else if (at(src, idx) == '*' && at(src,idx+1) == '/') 
		{
		    idx +=2 ;
		    cattext(dst,"\nENDDD\n");
		    break;
		}
		else 
		{
		    catchar(dst, at(src, idx));
		    idx++;
		}
	    }
	}
	else idx++;
    }
}
/* turn foobar name(stuff); into foobar EXFUN(name,(stuff));

 */

static void
DEFUN_VOID(exfunstuff)
{
    unsigned int openp;
    unsigned int fname;
    unsigned int idx;
    string_type out;
    init_string(&out);
    

    /* make sure that it's not already exfuned */
    if(find(tos,"EXFUN") || find(tos,"PROTO") || !find(tos,"(")) {
	    catstr(&out,tos);
	}
    else 
    {
	
	/*Find the open paren*/
	for (openp = 0; at(tos, openp) != '('  && at(tos,openp); openp++)
	 ;

	fname = openp;
	/* Step back to the fname */
	fname--;
	while (fname && isspace(at(tos, fname)))
	 fname --;
	while (fname && !isspace(at(tos,fname)) && at(tos,fname) != '*')
	 fname--;

	fname++;
	
	for (idx = 0; idx < fname; idx++) 
	{
	    catchar(&out, at(tos,idx));
	}
    
	cattext(&out,"EXFUN(");
	for (idx = fname; idx < openp; idx++) 
	{
	    catchar(&out, at(tos,idx));
	}
	cattext(&out,", ");
	while (at(tos,idx) && at(tos,idx) !=';') 
	{
	    catchar(&out, at(tos, idx));
	    idx++;
	}
	cattext(&out,");\n");
    }
    overwrite_string(tos, &out);    
    pc++;
    
}



/* turn {*
   and *} into comments */

WORD(translatecomments)
{
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) 
    {
	if (at(tos,idx) == '{' && at(tos,idx+1) =='*') 
	{
	    cattext(&out,"	/*");
	    idx+=2;
	}
	else if (at(tos,idx) == '*' && at(tos,idx+1) =='}') 
	{
	    cattext(&out,"*/");
	    idx+=2;
	}
	else  
	{
	    catchar(&out, at(tos, idx));
	    idx++;
	}
    }


    overwrite_string(tos, &out);
    
    pc++;
    
}

/* find something like
   QUICKREF
     memchar ansi  pure

     into
     merge with words on tos and output them to stderror

*/
WORD(quickref)
{
  string_type *nos = tos-1;
  unsigned int nosscan = 0;
  unsigned int idx = 0;
  
  while (at(tos, idx)) 
  {
    if (at(tos,idx) == '~')
    {
      /* Skip the whitespace */
      while (at(nos, nosscan) == ' ')
       nosscan++;
    
      /* Sub the next word from the nos*/
      while (at(nos, nosscan) != ' ' &&
	     at(nos, nosscan) != 0)
      {
	fprintf(stderr, "%c", at(nos, nosscan));
	nosscan++;
      }
    }
  
    else 
    {
      fprintf(stderr,"%c", at(tos, idx));
    
    }
    idx++;
  }

  delete_string(tos);
  delete_string(nos);
  tos-=2;
  pc++;
  
}

#if 0
/* turn everything not starting with a . into a comment */

WORD(manglecomments)
{
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) 
    {
	if (at(tos,idx) == '\n' && at(tos,idx+1) =='*') 
	{
	    cattext(&out,"	/*");
	    idx+=2;
	}
	else if (at(tos,idx) == '*' && at(tos,idx+1) =='}') 
	{
	    cattext(&out,"*/");
	    idx+=2;
	}
	else  
	{
	    catchar(&out, at(tos, idx));
	    idx++;
	}
    }


    overwrite_string(tos, &out);
    
    pc++;
    
}
#endif

/* Mod tos so that only lines with leading dots remain */
static void
DEFUN_VOID(outputdots)
{
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) 
    {
	if (at(tos, idx) == '\n' && at(tos, idx+1) == '.') 
	{
	    idx += 2;
	    
	    while (at(tos, idx) && at(tos, idx)!='\n')
	    {
		if (at(tos,idx) == '{' && at(tos,idx+1) =='*') 
		{
		    cattext(&out," /*");
		    idx+=2;
		}
		else if (at(tos,idx) == '*' && at(tos,idx+1) =='}') 
		{
		    cattext(&out,"*/");
		    idx+=2;
		}
		else  
		{
		    catchar(&out, at(tos, idx));
		    idx++;
		}
	    }
	    catchar(&out,'\n');
	}
	else 
	{
	    idx++;
	}
    }	

    overwrite_string(tos, &out);
    pc++;
    
}

/* Find lines starting with . and | and put example around them on tos
   turn 
   {*  into open comment and *} into close comment
   escape curlies
   
*/
WORD(courierize)
{
    string_type out;
    unsigned int idx = 0;
    
    init_string(&out);
    
    while (at(tos, idx)) 
    {
	if (at(tos, idx) == '\n' 
	    && (at(tos, idx +1 ) == '.'
		|| at(tos,idx+1) == '|')) 
	{
	    cattext(&out,"\n@@smallexample\n");
	    do 
	    {
		idx += 2;
		
		while (at(tos, idx) && at(tos, idx)!='\n')
		{
		    if (at(tos,idx)=='{' && at(tos,idx+1) =='*') 
		    {
			cattext(&out," /*");
			idx+=2;
		    }
		    else if (at(tos,idx)=='*' && at(tos,idx+1) =='}') 
		    {
			cattext(&out,"*/");
			idx+=2;
		    }
	            else if (at(tos,idx) == '{')
		    {
			cattext(&out,"@@{");
			idx++;
		    }
	            else if (at(tos,idx) == '}')
		    {
			cattext(&out,"@@}");
			idx++;
		    }
		    else 
		    {
			catchar(&out, at(tos, idx));
			idx++;
		    }
		    
		}
		catchar(&out,'\n');
	    }  
	    while (at(tos, idx) == '\n' 
		   && (at(tos, idx+1) == '.')
		   || (at(tos,idx+1) == '|'));
	    cattext(&out,"@@end smallexample");
	}
	else 
	{    
	    catchar(&out, at(tos, idx));
	    idx++;
	}
    }    

    overwrite_string(tos, &out);
    pc++;

    
}

/* 
bulletize:  look for bullet item commands at start of line
 Bullet list:
   O+  emit @@itemize @@bullet
   o   emit @@item	[note lowercase]
   O-  emit @@end itemize

 Variable label list:
   o+  emit @@table @@code
   o   emit @@item
   o-  emit @@end table
*/


WORD(bulletize)
{
  unsigned int idx = 0;
  string_type out;
  init_string(&out);
    
  while (at(tos, idx)) {
       if (at(tos, idx) == '\n' &&  at(tos, idx+1) == 'o')
       {
	 if (at(tos,idx+2) == '+') {
	     cattext(&out,"\n@@table @@code\n");
	     idx+=3;
	   }
	 else if (at(tos,idx+2) == '-') {
	     cattext(&out,"\n@@end table\n");
	     idx+=3;
	   }
	 else if (isspace(at(tos,idx+2))) {
	     cattext(&out,"\n@@item ");
	     idx+=3;
	   }
	 else {
	     catchar(&out, at(tos, idx));
	     idx++;
	   }
       }
      
       else
	if (at(tos, idx) == '\n' &&  at(tos, idx+1) == 'O')
	{
	  if (at(tos,idx+2) == '+') {
	      cattext(&out,"\n@@itemize @@bullet\n");
	      idx+=3;
	    }

	  else if (at(tos,idx+2) == '-') {
	      cattext(&out,"\n@@end itemize\n");
	      idx+=3;
	    }
	  else {
	      catchar(&out, at(tos, idx));
	      idx++;
	    }
	}	      
	else
	{
	  catchar(&out, at(tos, idx));
	  idx++;
	}
    }

  delete_string(tos);
  *tos = out;
  pc++;
    
}

/* Turn <<foo>> into @@code{foo} in place at TOS 
   Turn <[foo]> into @@var{foo} in place at TOS
   nest them too !

*/
   

WORD(do_fancy_stuff)
 {
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    while (at(tos, idx)) 
    {
	if (at(tos, idx) == '<' 
	    && at(tos, idx+1) == '<'
	    && (!isspace(at(tos,idx + 2)) || at(tos,idx+3) == '>')) 
	{
	    /* This qualifies as a << startup */
	    idx +=2;
	    cattext(&out,"@@code{");
	  }
	
	else 	if (at(tos, idx) == '<' 
	    && at(tos, idx+1) == '['
	    && !isspace(at(tos,idx + 2))) 
	{
	    /* This qualifies as a <[ startup */
	    idx +=2;
	    cattext(&out,"@@var{");
	  }
	else if (at(tos, idx) == '>' 
		 && at(tos,idx+1) =='>') 
	{
	  
	    cattext(&out,"}");
	    idx+=2;
	}
	else if (at(tos, idx) == ']' 
		 && at(tos,idx+1) =='>') 
	{
	    cattext(&out,"}");
	    idx+=2;
	}
	else 
	{
	    catchar(&out, at(tos, idx));
	    idx++;
	}
    }
    delete_string(tos);
    *tos = out;
    pc++;
    
}
/* A command is all upper case,and alone on a line */
static int 
DEFUN( iscommand,(ptr, idx),
      string_type *ptr AND
      unsigned int idx)
{
    unsigned int len = 0;
    while (at(ptr,idx)) {
	    if (isupper(at(ptr,idx)) || at(ptr,idx) == ' ' ||
		at(ptr,idx) == '_') 
	    {
	     len++;
	     idx++;
	 }
	    else if(at(ptr,idx) == '\n')
	    {
		/* The length check will never fail on a real command
		 * because the commands are screened as the definitions file
		 * is read.  */
		if (len >= MIN_CMDLEN) return 1;
		return 0;
	    }
	    else return 0;
	}
    return 0;

}


unsigned int
DEFUN(copy_past_newline,(ptr, idx, dst),
      string_type *ptr AND
      unsigned int idx AND
      string_type *dst)
{
    while (at(ptr, idx) && at(ptr, idx) != '\n') 
    {
	catchar(dst, at(ptr, idx));
	idx++;
	
    }    
    catchar(dst, at(ptr, idx));
    idx++;
    return idx;

}

WORD(icopy_past_newline)
{
    tos++;
    init_string(tos);
    idx = copy_past_newline(ptr, idx, tos);
    pc++;	
}


/* indent
   Take the string at the top of the stack, do some prettying */




WORD(kill_bogus_lines)
{
    int sl ;
    
    int idx = 0;
    int c;
    int dot = 0    ;
    
    string_type out;    
    init_string(&out);
    /* Drop leading nl */
    while (at(tos,idx) == '\n')
    {
	idx++;
    }
    c = idx;
    
    /* Find the last char */
    while (at(tos,idx))
    {
	idx++;
    }
    
    /* find the last non white before the nl */
    idx--;
    
    while (idx && isspace(at(tos,idx)))
     idx--;
    idx++;
    
    /* Copy buffer upto last char, but blank lines before and after
       dots don't count */
    sl = 1;

    while (c < idx)
    {
	if (at(tos,c) == '\n' 
	    && at(tos,c+1) == '\n'
	    && at(tos,c+2) == '.') 
	{
	    /* Ignore two linelines before  a dot*/
	    c++;
	}
	else if (at(tos,c) == '.' && sl)
	{
	    /* remember that this line started with a dot */
	    dot=2;
	}
	else if (at(tos,c) == '\n' 
		 && at(tos,c+1) == '\n'
		 && dot)
	{
	    c++;
	    /* Ignore two newlines when last line was dot */
	}

	catchar(&out, at(tos,c));
	if (at(tos,c) == '\n')
	{
	    sl = 1;
	    
	    if (dot == 2)dot=1;else dot = 0;
	}
	
	c++;	

    }
    
    /* Append nl*/
    catchar(&out, '\n');
    pc++;
    delete_string(tos);
    *tos = out;
    
    
}

WORD(indent)
{
    string_type out;
    int tab = 0;
    int idx = 0;
    int ol =0;
    init_string(&out);
    while (at(tos,idx)) {
	    switch (at(tos,idx)) 
	    {
	      case '\n':
		cattext(&out,"\n");
		idx++;
		if (tab) 
		{
		    cattext(&out,"    ");
		}
		ol = 0;
		break;
	      case '(':
		tab++;
		if (ol == 0)
		    cattext(&out,"   ");
		idx++;
		cattext(&out,"(");
		ol = 1;
		break;
	      case ')':
		tab--;
		cattext(&out,")");
		idx++;
		ol=1;
		
		break;
	      default:
		catchar(&out,at(tos,idx));
		ol=1;
		
		idx++;
		break;
	    }
	}	

    pc++;
    delete_string(tos);
    *tos = out;

}

/* Change the TOS so that all that is left is the stuff inside the
 first <<foo>> .
*/

WORD(get_stuff_in_angle)
{
  unsigned int idx = 0;
  string_type out;
  init_string(&out);
    
  while (at(tos, idx)) 
    {
      if (at(tos,idx) == '<' && at(tos,idx+1) =='<') 
	{
	  idx+=2;
	  
	  while (!(at(tos,idx) == '>' && at(tos,idx+1) == '>'))
	    {
	      catchar(&out, at(tos, idx));
	      idx++;
	    }
	  break;
	}
      idx++;
    }
  catchar(&out,'\n');
  
  overwrite_string(tos, &out);
  pc++;
}


WORD(get_stuff_in_command)
{
  tos++;
  init_string(tos);

  while (at(ptr, idx)) {
    if (iscommand(ptr, idx))  break;
    idx =   copy_past_newline(ptr, idx, tos);
  }
  pc++;    
}

WORD(swap)
{
    string_type t;
    
    t = tos[0];
    tos[0] = tos[-1];
    tos[-1] =t; 
    pc++;
    
}

WORD(dup_)
{
    tos++;
    init_string(tos);
    catstr(tos, tos-1);
    pc++;
    
}



WORD(icatstr)
{
    catstr(tos-1, tos);
    delete_string(tos);
    tos--;
    pc++;
    
}

WORD(skip_past_newline)
{
    while (at(ptr,idx) 
	   && at(ptr,idx) != '\n')
     idx++;
    idx++;
    pc++;
}


WORD(internalmode)
{
    internal_mode = *(isp);
    isp--;
    pc++;
}

WORD(maybecatstr)
{
    if (internal_wanted == internal_mode) 
    {
	catstr(tos-1, tos);
    }
    delete_string(tos);
    tos--;
    pc++;
    
}

char *
DEFUN(nextword,(string, word),
      char *string AND
      char **word)
{
  char *word_start;
  int idx;
  char *dst;
  char *src;
    
  int length = 0;
    
  while (isspace(*string) || *string == '-') {
      if (*string == '-') 
      {
	while (*string && *string != '\n') 
	 string++;
		
      }
      else {
	  string++;
	}
    }
  if (!*string) return 0;
    
  word_start = string;    	
  if (*string == '"') 
  {
    string++;
    length++;
	
    while (*string != '"') 
    {
      string++;
      length++;
    }
  }
  else     
  {
	

    while (!isspace(*string)) 
    {
      string++;
      length++;
    }
  }
    
  *word = malloc(length + 1);

  dst = *word;
  src = word_start;


  for (idx= 0; idx < length; idx++) 
  {
    
    if (src[idx] == '\\' && src[idx+1] == 'n') 
    {
      *dst++ = '\n';
      idx++;
    
    }
    else *dst++ = src[idx];
  }
  *dst++ = 0;





  if(*string)    
   return string + 1;
  else 
   return 0;
    
}
dict_type *root;
dict_type *
DEFUN(lookup_word,(word),
      char *word)
{
    dict_type *ptr = root;
    while (ptr) {
	    if (strcmp(ptr->word, word) == 0) return ptr;
	    ptr = ptr->next;
	    
	 }
    fprintf(stderr,"Can't find %s\n",word);
    return 0;
    
    
}

static void DEFUN_VOID(perform)
{
    tos = stack;
    
    while (at(ptr, idx)) {
	    /* It's worth looking through the command list */
	    if (iscommand(ptr, idx))
	    {
		char *next;
		dict_type *word ;
		
		(void)		nextword(addr(ptr, idx), &next);


		word = lookup_word(next);


		

		if (word) 
		{
		    if(Verbose)  fprintf(stderr, "CMD '%s'\n", word->word);
		    exec(word);
		}
		else
		{
		    fprintf(stderr,"warning, %s is not recognised\n",  next);
		    skip_past_newline();
		}
		
	    }
	    else skip_past_newline();

	}
}

dict_type *
DEFUN(newentry,(word),
      char *word)
{
    dict_type *new = (dict_type *)malloc(sizeof(dict_type));
    new->word = word;
    new->next = root;
    root = new;
    new->code = (stinst_type *)malloc(sizeof(stinst_type ));
    new->code_length = 1;
    new->code_end = 0;
    return new;
    
}


unsigned int
DEFUN(add_to_definition,(entry, word), 
      dict_type *entry AND
      stinst_type word)
{
    if (entry->code_end == entry->code_length) 
    {
	entry->code_length += 2;
	entry->code =
	 (stinst_type *) realloc((char *)(entry->code),
			       entry->code_length *sizeof(word_type));
    }
    entry->code[entry->code_end] = word;
    
return     entry->code_end++;  
}







void
DEFUN(add_intrinsic,(name, func),
      char *name AND
      void (*func)(NOARGS))
{
    dict_type *new = newentry(name);
    add_to_definition(new, func);
    add_to_definition(new, 0);
}

void
DEFUN(add_var,(name),
      char *name)
{
    dict_type *new = newentry(name);
    add_to_definition(new, push_number);
    add_to_definition(new, (stinst_type)(&(new->var)));
    add_to_definition(new,0);
    
}
      



int
DEFUN(compile, (string), 
      char *string)

{
    int  ret=0;
    /* add words to the dictionary */
    char *word;
    string = nextword(string, &word);
    while (string && *string && word[0]) 
    {
	if (strcmp(word,"var")==0) 
	{
	  string=nextword(string, &word);
	  
	  add_var(word);
	  string=nextword(string, &word);
	}
	else	
	    
	if (word[0] == ':')
	{
	    dict_type *ptr;
	    /* Compile a word and add to dictionary */
	    string = nextword(string, &word);
	    if(Verbose)  fprintf(stderr, "Found command '%s'\n", word);
	    if(strlen(word) < MIN_CMDLEN)  {
		fprintf(stderr, "ERROR:  Command '%s' is too short ", word);
		fprintf(stderr, "(MIN_CMDLEN is %d)\n", MIN_CMDLEN);
		ret++;
	    }
	    
	    ptr = newentry(word);
	    string = nextword(string, &word);
	    while (word[0] != ';' ) 
	    {
		 switch (word[0]) 
		 {
		    
		    
		   case '"':
		     /* got a string, embed magic push string
			function */
		     add_to_definition(ptr, push_text);
		     add_to_definition(ptr, (stinst_type)(word+1));
		     break;
		   case '0':
		   case '1':
		   case '2':
		   case '3':
		   case '4':
		   case '5':
		   case '6':
		   case '7':
		   case '8':
		   case '9':
		     /* Got a number, embedd the magic push number
			function */
		     add_to_definition(ptr, push_number);
		     add_to_definition(ptr, atol(word));
		     break;
		   default:
		     add_to_definition(ptr, call);
		     add_to_definition(ptr, lookup_word(word));
		 }

		string = nextword(string, &word);		     
	    }
	    add_to_definition(ptr,0);
	    string = nextword(string, &word);
	}
	else 
	{
	    fprintf(stderr,"syntax error at %s\n",string-1);
	    ret++;
	}	    
    }

return(ret);
}

 
static void DEFUN_VOID(bang)
{
*(uintptr_t *)((isp[0])) = isp[-1];
isp-=2;
pc++;

}

WORD(atsign)
{
    isp[0] = *(uintptr_t *)(isp[0]);
    pc++;
}

WORD(hello)
{
    
    printf("hello\n");
    pc++;    
}



static void DEFUN(read_in, (str, file), 
	   string_type *str AND
		  FILE *file)
{
    char buff[10000];    
    unsigned int r;
    do 
    {
	r = fread(buff, 1, sizeof(buff), file);
	catbuf(str, buff, r);
    }
    while (r);
    buff[0] = 0;
    
    catbuf(str, buff,1);
    
}


#if 0
static void DEFUN_VOID(usage)
{
    fprintf(stderr,"usage: -[i|v] -f macrofile <file >file\n");
    exit(33);    
}
#endif

int DEFUN(main,(ac,av),
int ac AND
char *av[])
{
    unsigned int i;
    

    string_type buffer;
    string_type pptr;
    

    init_string(&buffer);
    init_string(&pptr);
    init_string(stack+0);
    tos=stack+1;
    ptr = &pptr;
    
    add_intrinsic("push_text", push_text);
    add_intrinsic("!", bang);
    add_intrinsic("@@", atsign);
    add_intrinsic("hello",hello);    
    add_intrinsic("skip_past_newline", skip_past_newline );
    add_intrinsic("catstr", icatstr );
    add_intrinsic("copy_past_newline", icopy_past_newline );
    add_intrinsic("dup", dup_ );
    add_intrinsic("remchar", remchar );
    add_intrinsic("get_stuff_in_command", get_stuff_in_command );
    add_intrinsic("get_stuff_in_angle", get_stuff_in_angle );
    add_intrinsic("do_fancy_stuff", do_fancy_stuff );
    add_intrinsic("bulletize", bulletize );
    add_intrinsic("courierize", courierize );
    add_intrinsic("swap", swap );
    add_intrinsic("outputdots", outputdots );
    add_intrinsic("exfunstuff", exfunstuff );
    add_intrinsic("maybecatstr", maybecatstr );
    add_intrinsic("translatecomments", translatecomments );
    add_intrinsic("kill_bogus_lines", kill_bogus_lines);
    add_intrinsic("indent", indent);
    add_intrinsic("quickref", quickref);
    add_intrinsic("internalmode", internalmode);
    
    /* Put a nl at the start */
    catchar(&buffer,'\n');

    read_in(&buffer, stdin); 
    remove_noncomments(&buffer, ptr);
    for (i= 1; i < ac; i++) 
    {
	if (av[i][0] == '-')
	{
	    if (av[i][1] == 'f')
	    {
		string_type b;
		FILE *f;
		init_string(&b);

		f  = fopen(av[i+1],"r");
		if (!f) 
		{
		  fprintf(stderr,"Can't open the input file %s\n",av[i+1]);
		  return 33;
		}
		if(Verbose)  fprintf(stderr, "Reading -f '%s'\n", av[i+1]);
		
		  
		read_in(&b, f);
		if( compile(b.ptr) )  { fclose(f); exit(1); }
		perform();	
		fclose(f);
	    }
	    else    if (av[i][1] == 'i') 
	    {
		internal_wanted = 1;
	    }
	    else    if (av[i][1] == 'v') 
	    {
		Verbose++;
	    }
	}

    }      
    write_buffer(stack+0);
    return 0;
}



@


1.4
log
@
2012-09-26  Michael Hope  <michael.hope@@linaro.org>

        * doc/makedoc.c (dup_): Rename to avoid colliding with dup(2).
@
text
@d43 1
d223 2
a224 2
int istack[STACK];
int *isp = &istack[0];
d226 1
a226 1
typedef int *word_type;
d274 1
a274 1
    *isp = (int)(*pc);
d1342 1
a1342 1
*(int *)((isp[0])) = isp[-1];
d1350 1
a1350 1
    isp[0] = *(int *)(isp[0]);
@


1.3
log
@
2009-03-25  Craig Howland <howland@@LGSInnovations.com>

	* libc/include/math.h:  (llround, llroundf): Declare.
	* libm/common/s_llround.c: New file, implementing llround().
	* libm/common/sf_llround.c: New file, implementing llroundf().
	* libm/common/sf_lround.c: Remove spurious cast in _DOUBLE_IS_32BITS
	version of function.
	* libm/common/sf_lrint.c: Ditto.
	* libm/common/sf_logb.c:  Corrected return for subnormal argument
	by replacing existing function with a version created from sf_ilogb.c.
	* libm/common/s_logb.c: Ditto, except starting point s_ilogb.c.  Also
	added documentation for logb() and logbf().
	* libm/common/s_signbit.c:  Add signbit() documentation.
	* libm/common/s_log2.c: Update return values to match what w_log2.c has,
	since log2 uses log(); add note about being derived instead of direct.
	* libm/common/sf_fma.c: Add casts to attempt to get correct results,
	as well as comments pointing out problems with the implementation.
	* libm/common/s_fma.c: Add fma() and fmaf() documentation.
	* libm/common/sf_remquo.c: Incorrect quotient returns for large values
	corrected by discarding existing function and replacing with Sun
	verion, with some enhancements.
	* libm/common/s_remquo.c: Ditto.  Add remquo() and remquof()
	documentation.
	* libm/common/s_fmax.c: Add fmax() and fmaxf() documentation.
	* libm/common/s_fmin.c: Add fmin() and fminf() documentation.
	* libm/common/s_fdim.c: Return NAN for NAN arg, add fdim() and fdimf()
	documentation.
	* libm/common/sf_fdim.c: Return NAN for NAN arg, HUGE_VALF for inf arg.
	* libm/common/s_trunc.c: Add trunc() and truncf() documentation.
	* libm/common/s_rint.c: Add rint() and rintf() documentation.
	* libm/common/s_round.c: Add round() and roundf() documentation.
	* libm/common/s_scalbn.c: Add scalbln() and scalblnf() documentation.
	* libm/common/s_infinity.c: Add infinity() and infinityf()
	documentation.
	* libm/common/s_lround.c: Add lround(), lroundf(), llround(), and
	llroundf() documentation.
	* libm/common/s_lrint.c: Add lrint(), lrintf(), llrint(), and llrintf()
	documentation.
	* libm/common/isgreater.c: New file for documenting math.h function-like
	macros isgreater(), isgreaterequal(), isless(), islessequal(),
	islessgreater(), and isunordered().
	* libm/common/s_isnan.c: Add documentation for function-like macros
	fpclassify(), isfinite(), isinf(), isnan(), and isnormal().
	* libm/common/s_nearbyint.c: Add nearbyint() and nearbyintf()
	documentation.
	* libm/common/Makefile.am: Add s_llround.c (src); sf_llround.c (fsrc);
	s_fdim.def, s_fma.def, s_fmax.def, s_fmin.def,
	s_logb.def, s_lrint.def, s_lround.def, s_nearbyint.def, s_remquo.def,
        s_rint.def, s_round.def, s_signbit.def, s_trunc.def, and
        isgreater.def (chobj);
	re-name all existing chew files (chobj) to match source file base
	names (put in underscores), delete all special targets for chew files
	(leaving all to be generated by rule).
	* libm/common/Makefile.in: regenerate.
	* libm/math/w_exp2.c: Add "base 2" to documentation description (and
	delete TRAD_SYNOPSIS).
	* libm/math/w_gamma.c: Add tgamma() and tgammaf() documentation, along
	with some history behind the function names.
	* libm/math/math.tex: Add includes for newly-added documentation (see
	.def additions to common/Makefile.am and math/Makefile.am in this
	ChangeLog list), adjusted existing .def file names to match source file
	base names (added underscores); add mention of HUGE_VALF; rename
	"Version of library" section to "Error Handling" and add some text
	about floating-point exception; added section "Standards Compliance And
	Portability".
	* libm/math/Makefile.am: Add w_exp2.def (chobj);
	re-name all existing chew files (chobj) to match source file base
	names, delete all special targets for chew files (leaving all to be
	generated by rule).
	* libm/math/Makefile.in: regenerated
	* doc/makedoc.c: Change silent ignoring of commands < 5 characters
	to a failure when reading macro file for commands < 4 characters;
	add -v (verbose) option for printing some debugging information;
	get rid of spurious translation of "@@*" to "*" (no source files used @@*,
	so no existing doc pages were affected); clean up some compiler
	warnings.
	* doc/doc.str: add BUGS and SEEALSO sections (to match texi2pod.pl
	which has them); Remove ITEM command (redundant with makedoc built-in
	"o", not used in any present source file so nothing is lost, anyway).
	* HOWTO: New file to hold information for maintainers regarding how
	to do things.  Initial sections on documentation and ELIX levels.
@
text
@d1015 1
a1015 1
WORD(dup)
d1413 1
a1413 1
    add_intrinsic("dup", dup );
@


1.3.2.1
log
@	Pull in changes from HEAD
	Align ChangeLog with head
	New file ChangeLog.64bit
@
text
@d1015 1
a1015 1
WORD(dup_)
d1413 1
a1413 1
    add_intrinsic("dup", dup_ );
@


1.2
log
@
2007-01-02  Ben Elliston  <bje@@au.ibm.com>

        * doc/makedoc.c: Include <stdlib.h>.
        (malloc, realloc): Remove extern declarations.
@
text
@d42 1
d46 1
d50 1
d218 1
a218 1
typedef void (*stinst_type)();
d240 1
a240 1
#define WORD(x) static void x()
a456 1
  unsigned int scan=0;
d492 1
d526 1
d647 2
d650 1
a650 1
   OO  emit @@item
d653 1
d655 1
a655 1
   oo  @@item
a662 1
  int on = 0;
a666 8
      if (at(tos, idx) == '@@' &&
	  at(tos, idx+1) == '*') 
      {
	cattext(&out,"*");
	idx+=2;
      }
	
      else
d788 4
a791 1
		if (len >4) return 1;
d801 1
a837 1
    int nl = 0;
a1165 3
		unsigned int i;
		int found = 0;

d1179 1
d1236 1
a1236 1
      void (*func)())
a1242 6
WORD(push_addr)
{
    

}

d1257 1
a1257 1
void 
d1262 1
a1262 2
    int jstack[STACK];
    int *jptr = jstack;
d1270 1
a1270 1
 string=nextword(string, &word);
d1273 1
a1273 1
 string=nextword(string, &word);
d1275 1
a1275 1
else	
d1282 6
d1331 1
d1335 1
d1381 1
d1384 1
a1384 1
    fprintf(stderr,"usage: -[d|i|g] <file >file\n");
d1387 1
d1451 1
d1455 1
a1455 1
		compile(b.ptr);
d1457 1
d1463 4
@


1.1
log
@Initial revision
@
text
@d40 1
a42 3
extern PTR malloc();
extern PTR realloc();

@


1.1.1.1
log
@import newlib-2000-02-17 snapshot
@
text
@@
