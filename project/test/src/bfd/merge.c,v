head	1.43;
access;
symbols
	sid-snapshot-20180601:1.43
	sid-snapshot-20180501:1.43
	sid-snapshot-20180401:1.43
	sid-snapshot-20180301:1.43
	sid-snapshot-20180201:1.43
	sid-snapshot-20180101:1.43
	sid-snapshot-20171201:1.43
	sid-snapshot-20171101:1.43
	sid-snapshot-20171001:1.43
	sid-snapshot-20170901:1.43
	sid-snapshot-20170801:1.43
	sid-snapshot-20170701:1.43
	sid-snapshot-20170601:1.43
	sid-snapshot-20170501:1.43
	sid-snapshot-20170401:1.43
	sid-snapshot-20170301:1.43
	sid-snapshot-20170201:1.43
	sid-snapshot-20170101:1.43
	sid-snapshot-20161201:1.43
	sid-snapshot-20161101:1.43
	sid-snapshot-20160901:1.43
	sid-snapshot-20160801:1.43
	sid-snapshot-20160701:1.43
	sid-snapshot-20160601:1.43
	sid-snapshot-20160501:1.43
	sid-snapshot-20160401:1.43
	sid-snapshot-20160301:1.43
	sid-snapshot-20160201:1.43
	sid-snapshot-20160101:1.43
	sid-snapshot-20151201:1.43
	sid-snapshot-20151101:1.43
	sid-snapshot-20151001:1.43
	sid-snapshot-20150901:1.43
	sid-snapshot-20150801:1.43
	sid-snapshot-20150701:1.43
	sid-snapshot-20150601:1.43
	sid-snapshot-20150501:1.43
	sid-snapshot-20150401:1.43
	sid-snapshot-20150301:1.43
	sid-snapshot-20150201:1.43
	sid-snapshot-20150101:1.43
	sid-snapshot-20141201:1.43
	sid-snapshot-20141101:1.43
	sid-snapshot-20141001:1.43
	sid-snapshot-20140901:1.43
	sid-snapshot-20140801:1.43
	sid-snapshot-20140701:1.43
	sid-snapshot-20140601:1.43
	sid-snapshot-20140501:1.43
	sid-snapshot-20140401:1.43
	sid-snapshot-20140301:1.43
	sid-snapshot-20140201:1.43
	sid-snapshot-20140101:1.43
	sid-snapshot-20131201:1.43
	sid-snapshot-20131101:1.43
	sid-snapshot-20131001:1.43
	binutils-2_24-branch:1.43.0.4
	binutils-2_24-branchpoint:1.43
	binutils-2_21_1:1.42
	sid-snapshot-20130901:1.43
	gdb_7_6_1-2013-08-30-release:1.43
	sid-snapshot-20130801:1.43
	sid-snapshot-20130701:1.43
	sid-snapshot-20130601:1.43
	sid-snapshot-20130501:1.43
	gdb_7_6-2013-04-26-release:1.43
	sid-snapshot-20130401:1.43
	binutils-2_23_2:1.42
	gdb_7_6-branch:1.43.0.2
	gdb_7_6-2013-03-12-branchpoint:1.43
	sid-snapshot-20130301:1.43
	sid-snapshot-20130201:1.42
	sid-snapshot-20130101:1.42
	sid-snapshot-20121201:1.42
	gdb_7_5_1-2012-11-29-release:1.42
	binutils-2_23_1:1.42
	sid-snapshot-20121101:1.42
	binutils-2_23:1.42
	sid-snapshot-20121001:1.42
	sid-snapshot-20120901:1.42
	gdb_7_5-2012-08-17-release:1.42
	sid-snapshot-20120801:1.42
	binutils-2_23-branch:1.42.0.14
	binutils-2_23-branchpoint:1.42
	gdb_7_5-branch:1.42.0.12
	gdb_7_5-2012-07-18-branchpoint:1.42
	sid-snapshot-20120701:1.42
	sid-snapshot-20120601:1.42
	sid-snapshot-20120501:1.42
	binutils-2_22_branch:1.42.0.10
	gdb_7_4_1-2012-04-26-release:1.42
	sid-snapshot-20120401:1.42
	sid-snapshot-20120301:1.42
	sid-snapshot-20120201:1.42
	gdb_7_4-2012-01-24-release:1.42
	sid-snapshot-20120101:1.42
	gdb_7_4-branch:1.42.0.8
	gdb_7_4-2011-12-13-branchpoint:1.42
	sid-snapshot-20111201:1.42
	binutils-2_22:1.42
	sid-snapshot-20111101:1.42
	sid-snapshot-20111001:1.42
	binutils-2_22-branch:1.42.0.6
	binutils-2_22-branchpoint:1.42
	gdb_7_3_1-2011-09-04-release:1.42
	sid-snapshot-20110901:1.42
	sid-snapshot-20110801:1.42
	gdb_7_3-2011-07-26-release:1.42
	sid-snapshot-20110701:1.42
	sid-snapshot-20110601:1.42
	sid-snapshot-20110501:1.42
	gdb_7_3-branch:1.42.0.4
	gdb_7_3-2011-04-01-branchpoint:1.42
	sid-snapshot-20110401:1.42
	sid-snapshot-20110301:1.42
	sid-snapshot-20110201:1.42
	sid-snapshot-20110101:1.42
	binutils-2_21:1.42
	sid-snapshot-20101201:1.42
	binutils-2_21-branch:1.42.0.2
	binutils-2_21-branchpoint:1.42
	sid-snapshot-20101101:1.42
	sid-snapshot-20101001:1.41
	binutils-2_20_1:1.37.2.1
	gdb_7_2-2010-09-02-release:1.39
	sid-snapshot-20100901:1.41
	sid-snapshot-20100801:1.39
	gdb_7_2-branch:1.39.0.4
	gdb_7_2-2010-07-07-branchpoint:1.39
	sid-snapshot-20100701:1.39
	sid-snapshot-20100601:1.39
	sid-snapshot-20100501:1.39
	sid-snapshot-20100401:1.39
	gdb_7_1-2010-03-18-release:1.39
	sid-snapshot-20100301:1.39
	gdb_7_1-branch:1.39.0.2
	gdb_7_1-2010-02-18-branchpoint:1.39
	sid-snapshot-20100201:1.39
	sid-snapshot-20100101:1.39
	gdb_7_0_1-2009-12-22-release:1.38
	sid-snapshot-20091201:1.38
	sid-snapshot-20091101:1.38
	binutils-2_20:1.37.2.1
	gdb_7_0-2009-10-06-release:1.38
	sid-snapshot-20091001:1.38
	gdb_7_0-branch:1.38.0.2
	gdb_7_0-2009-09-16-branchpoint:1.38
	arc-sim-20090309:1.35
	binutils-arc-20081103-branch:1.35.0.26
	binutils-arc-20081103-branchpoint:1.35
	binutils-2_20-branch:1.37.0.2
	binutils-2_20-branchpoint:1.37
	sid-snapshot-20090901:1.36
	sid-snapshot-20090801:1.35
	msnyder-checkpoint-072509-branch:1.35.0.24
	msnyder-checkpoint-072509-branchpoint:1.35
	sid-snapshot-20090701:1.35
	dje-cgen-play1-branch:1.35.0.22
	dje-cgen-play1-branchpoint:1.35
	sid-snapshot-20090601:1.35
	sid-snapshot-20090501:1.35
	sid-snapshot-20090401:1.35
	arc-20081103-branch:1.35.0.20
	arc-20081103-branchpoint:1.35
	arc-insight_6_8-branch:1.35.0.18
	arc-insight_6_8-branchpoint:1.35
	insight_6_8-branch:1.35.0.16
	insight_6_8-branchpoint:1.35
	sid-snapshot-20090301:1.35
	binutils-2_19_1:1.35
	sid-snapshot-20090201:1.35
	sid-snapshot-20090101:1.35
	reverse-20081226-branch:1.35.0.14
	reverse-20081226-branchpoint:1.35
	sid-snapshot-20081201:1.35
	multiprocess-20081120-branch:1.35.0.12
	multiprocess-20081120-branchpoint:1.35
	sid-snapshot-20081101:1.35
	binutils-2_19:1.35
	sid-snapshot-20081001:1.35
	reverse-20080930-branch:1.35.0.10
	reverse-20080930-branchpoint:1.35
	binutils-2_19-branch:1.35.0.8
	binutils-2_19-branchpoint:1.35
	sid-snapshot-20080901:1.35
	sid-snapshot-20080801:1.35
	reverse-20080717-branch:1.35.0.6
	reverse-20080717-branchpoint:1.35
	sid-snapshot-20080701:1.35
	msnyder-reverse-20080609-branch:1.35.0.4
	msnyder-reverse-20080609-branchpoint:1.35
	drow-reverse-20070409-branch:1.30.0.4
	drow-reverse-20070409-branchpoint:1.30
	sid-snapshot-20080601:1.35
	sid-snapshot-20080501:1.35
	sid-snapshot-20080403:1.35
	sid-snapshot-20080401:1.35
	gdb_6_8-2008-03-27-release:1.35
	sid-snapshot-20080301:1.35
	gdb_6_8-branch:1.35.0.2
	gdb_6_8-2008-02-26-branchpoint:1.35
	sid-snapshot-20080201:1.35
	sid-snapshot-20080101:1.35
	sid-snapshot-20071201:1.35
	sid-snapshot-20071101:1.34
	gdb_6_7_1-2007-10-29-release:1.32
	gdb_6_7-2007-10-10-release:1.32
	sid-snapshot-20071001:1.33
	gdb_6_7-branch:1.32.0.4
	gdb_6_7-2007-09-07-branchpoint:1.32
	binutils-2_18:1.32
	binutils-2_18-branch:1.32.0.2
	binutils-2_18-branchpoint:1.32
	insight_6_6-20070208-release:1.30
	binutils-csl-coldfire-4_1-32:1.29
	binutils-csl-sourcerygxx-4_1-32:1.29
	gdb_6_6-2006-12-18-release:1.30
	binutils-csl-innovasic-fido-3_4_4-33:1.29
	binutils-csl-sourcerygxx-3_4_4-32:1.22
	binutils-csl-coldfire-4_1-30:1.29
	binutils-csl-sourcerygxx-4_1-30:1.29
	binutils-csl-coldfire-4_1-28:1.29
	binutils-csl-sourcerygxx-4_1-29:1.29
	binutils-csl-sourcerygxx-4_1-28:1.29
	gdb_6_6-branch:1.30.0.2
	gdb_6_6-2006-11-15-branchpoint:1.30
	binutils-csl-arm-2006q3-27:1.29
	binutils-csl-sourcerygxx-4_1-27:1.29
	binutils-csl-arm-2006q3-26:1.29
	binutils-csl-sourcerygxx-4_1-26:1.29
	binutils-csl-sourcerygxx-4_1-25:1.29
	binutils-csl-sourcerygxx-4_1-24:1.29
	binutils-csl-sourcerygxx-4_1-23:1.29
	insight_6_5-20061003-release:1.29
	gdb-csl-symbian-6_4_50_20060226-12:1.28
	binutils-csl-sourcerygxx-4_1-21:1.29
	binutils-csl-arm-2006q3-21:1.29
	binutils-csl-sourcerygxx-4_1-22:1.29
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.29
	binutils-csl-sourcerygxx-4_1-20:1.29
	binutils-csl-arm-2006q3-19:1.29
	binutils-csl-sourcerygxx-4_1-19:1.29
	binutils-csl-sourcerygxx-4_1-18:1.29
	binutils-csl-renesas-4_1-9:1.29
	gdb-csl-sourcerygxx-3_4_4-25:1.28
	binutils-csl-sourcerygxx-3_4_4-25:1.22
	nickrob-async-20060828-mergepoint:1.29
	gdb-csl-symbian-6_4_50_20060226-11:1.28
	binutils-csl-renesas-4_1-8:1.29
	binutils-csl-renesas-4_1-7:1.29
	binutils-csl-renesas-4_1-6:1.29
	gdb-csl-sourcerygxx-4_1-17:1.28
	binutils-csl-sourcerygxx-4_1-17:1.29
	gdb-csl-20060226-branch-local-2:1.28
	gdb-csl-sourcerygxx-4_1-14:1.28
	binutils-csl-sourcerygxx-4_1-14:1.29
	binutils-csl-sourcerygxx-4_1-15:1.29
	gdb-csl-sourcerygxx-4_1-13:1.28
	binutils-csl-sourcerygxx-4_1-13:1.29
	binutils-2_17:1.29
	gdb-csl-sourcerygxx-4_1-12:1.28
	binutils-csl-sourcerygxx-4_1-12:1.29
	gdb-csl-sourcerygxx-3_4_4-21:1.28
	binutils-csl-sourcerygxx-3_4_4-21:1.29
	gdb_6_5-20060621-release:1.29
	binutils-csl-wrs-linux-3_4_4-24:1.22
	binutils-csl-wrs-linux-3_4_4-23:1.22
	gdb-csl-sourcerygxx-4_1-9:1.28
	binutils-csl-sourcerygxx-4_1-9:1.29
	gdb-csl-sourcerygxx-4_1-8:1.28
	binutils-csl-sourcerygxx-4_1-8:1.29
	gdb-csl-sourcerygxx-4_1-7:1.28
	binutils-csl-sourcerygxx-4_1-7:1.29
	gdb-csl-arm-2006q1-6:1.28
	binutils-csl-arm-2006q1-6:1.29
	gdb-csl-sourcerygxx-4_1-6:1.28
	binutils-csl-sourcerygxx-4_1-6:1.29
	binutils-csl-wrs-linux-3_4_4-22:1.22
	gdb-csl-symbian-6_4_50_20060226-10:1.28
	gdb-csl-symbian-6_4_50_20060226-9:1.28
	gdb-csl-symbian-6_4_50_20060226-8:1.28
	gdb-csl-coldfire-4_1-11:1.28
	binutils-csl-coldfire-4_1-11:1.29
	gdb-csl-sourcerygxx-3_4_4-19:1.28
	binutils-csl-sourcerygxx-3_4_4-19:1.29
	gdb-csl-coldfire-4_1-10:1.28
	gdb_6_5-branch:1.29.0.14
	gdb_6_5-2006-05-14-branchpoint:1.29
	binutils-csl-coldfire-4_1-10:1.29
	gdb-csl-sourcerygxx-4_1-5:1.28
	binutils-csl-sourcerygxx-4_1-5:1.29
	nickrob-async-20060513-branch:1.29.0.12
	nickrob-async-20060513-branchpoint:1.29
	gdb-csl-sourcerygxx-4_1-4:1.28
	binutils-csl-sourcerygxx-4_1-4:1.29
	msnyder-reverse-20060502-branch:1.29.0.10
	msnyder-reverse-20060502-branchpoint:1.29
	binutils-csl-wrs-linux-3_4_4-21:1.22
	gdb-csl-morpho-4_1-4:1.28
	binutils-csl-morpho-4_1-4:1.29
	gdb-csl-sourcerygxx-3_4_4-17:1.28
	binutils-csl-sourcerygxx-3_4_4-17:1.29
	binutils-csl-wrs-linux-3_4_4-20:1.22
	readline_5_1-import-branch:1.29.0.8
	readline_5_1-import-branchpoint:1.29
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.28
	binutils-2_17-branch:1.29.0.6
	binutils-2_17-branchpoint:1.29
	gdb-csl-symbian-20060226-branch:1.28.0.16
	gdb-csl-symbian-20060226-branchpoint:1.28
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.28
	msnyder-reverse-20060331-branch:1.29.0.4
	msnyder-reverse-20060331-branchpoint:1.29
	binutils-csl-2_17-branch:1.29.0.2
	binutils-csl-2_17-branchpoint:1.29
	gdb-csl-available-20060303-branch:1.28.0.14
	gdb-csl-available-20060303-branchpoint:1.28
	gdb-csl-20060226-branch:1.28.0.12
	gdb-csl-20060226-branchpoint:1.28
	gdb_6_4-20051202-release:1.28
	msnyder-fork-checkpoint-branch:1.28.0.10
	msnyder-fork-checkpoint-branchpoint:1.28
	gdb-csl-gxxpro-6_3-branch:1.28.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.28
	gdb_6_4-branch:1.28.0.6
	gdb_6_4-2005-11-01-branchpoint:1.28
	gdb-csl-arm-20051020-branch:1.28.0.4
	gdb-csl-arm-20051020-branchpoint:1.28
	binutils-csl-gxxpro-3_4-branch:1.22.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.22
	binutils-2_16_1:1.22
	msnyder-tracepoint-checkpoint-branch:1.28.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.28
	gdb-csl-arm-20050325-2005-q1b:1.22
	binutils-csl-arm-2005q1b:1.22
	binutils-2_16:1.22
	gdb-csl-arm-20050325-2005-q1a:1.22
	binutils-csl-arm-2005q1a:1.22
	csl-arm-20050325-branch:1.22.0.6
	csl-arm-20050325-branchpoint:1.22
	binutils-csl-arm-2005q1-branch:1.22.0.4
	binutils-csl-arm-2005q1-branchpoint:1.22
	binutils-2_16-branch:1.22.0.2
	binutils-2_16-branchpoint:1.22
	csl-arm-2004-q3d:1.21
	gdb_6_3-20041109-release:1.21
	gdb_6_3-branch:1.21.0.4
	gdb_6_3-20041019-branchpoint:1.21
	csl-arm-2004-q3:1.21
	drow_intercu-merge-20040921:1.21
	drow_intercu-merge-20040915:1.21
	jimb-gdb_6_2-e500-branch:1.21.0.6
	jimb-gdb_6_2-e500-branchpoint:1.21
	gdb_6_2-20040730-release:1.21
	gdb_6_2-branch:1.21.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.21
	gdb_6_1_1-20040616-release:1.18
	binutils-2_15:1.18
	binutils-2_15-branchpoint:1.18
	csl-arm-2004-q1a:1.18
	csl-arm-2004-q1:1.18
	gdb_6_1-2004-04-05-release:1.18
	drow_intercu-merge-20040402:1.18
	drow_intercu-merge-20040327:1.18
	ezannoni_pie-20040323-branch:1.18.0.14
	ezannoni_pie-20040323-branchpoint:1.18
	cagney_tramp-20040321-mergepoint:1.18
	cagney_tramp-20040309-branch:1.18.0.12
	cagney_tramp-20040309-branchpoint:1.18
	gdb_6_1-branch:1.18.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.18
	drow_intercu-20040221-branch:1.18.0.8
	drow_intercu-20040221-branchpoint:1.18
	binutils-2_15-branch:1.18.0.6
	cagney_bfdfile-20040213-branch:1.18.0.4
	cagney_bfdfile-20040213-branchpoint:1.18
	drow-cplus-merge-20040208:1.18
	carlton_dictionary-20040126-merge:1.18
	cagney_bigcore-20040122-branch:1.18.0.2
	cagney_bigcore-20040122-branchpoint:1.18
	drow-cplus-merge-20040113:1.18
	csl-arm-2003-q4:1.18
	drow-cplus-merge-20031224:1.18
	drow-cplus-merge-20031220:1.18
	carlton_dictionary-20031215-merge:1.18
	drow-cplus-merge-20031214:1.18
	carlton-dictionary-20031111-merge:1.18
	gdb_6_0-2003-10-04-release:1.15
	kettenis_sparc-20030918-branch:1.16.0.4
	kettenis_sparc-20030918-branchpoint:1.16
	carlton_dictionary-20030917-merge:1.16
	ezannoni_pie-20030916-branchpoint:1.16
	ezannoni_pie-20030916-branch:1.16.0.2
	cagney_x86i386-20030821-branch:1.15.0.38
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.15.0.36
	gdb_6_0-2003-06-23-branchpoint:1.15
	jimb-ppc64-linux-20030613-branch:1.15.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.15
	binutils-2_14:1.15
	cagney_convert-20030606-branch:1.15.0.32
	cagney_convert-20030606-branchpoint:1.15
	cagney_writestrings-20030508-branch:1.15.0.30
	cagney_writestrings-20030508-branchpoint:1.15
	jimb-ppc64-linux-20030528-branch:1.15.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.15
	carlton_dictionary-20030523-merge:1.15
	cagney_fileio-20030521-branch:1.15.0.26
	cagney_fileio-20030521-branchpoint:1.15
	kettenis_i386newframe-20030517-mergepoint:1.15
	jimb-ppc64-linux-20030509-branch:1.15.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.15
	kettenis_i386newframe-20030504-mergepoint:1.15
	carlton_dictionary-20030430-merge:1.15
	binutils-2_14-branch:1.15.0.22
	binutils-2_14-branchpoint:1.15
	kettenis_i386newframe-20030419-branch:1.15.0.20
	kettenis_i386newframe-20030419-branchpoint:1.15
	carlton_dictionary-20030416-merge:1.15
	cagney_frameaddr-20030409-mergepoint:1.15
	kettenis_i386newframe-20030406-branch:1.15.0.18
	kettenis_i386newframe-20030406-branchpoint:1.15
	cagney_frameaddr-20030403-branchpoint:1.15
	cagney_frameaddr-20030403-branch:1.15.0.16
	cagney_framebase-20030330-mergepoint:1.15
	cagney_framebase-20030326-branch:1.15.0.14
	cagney_framebase-20030326-branchpoint:1.15
	cagney_lazyid-20030317-branch:1.15.0.12
	cagney_lazyid-20030317-branchpoint:1.15
	kettenis-i386newframe-20030316-mergepoint:1.15
	offbyone-20030313-branch:1.15.0.10
	offbyone-20030313-branchpoint:1.15
	kettenis-i386newframe-20030308-branch:1.15.0.8
	kettenis-i386newframe-20030308-branchpoint:1.15
	carlton_dictionary-20030305-merge:1.15
	cagney_offbyone-20030303-branch:1.15.0.6
	cagney_offbyone-20030303-branchpoint:1.15
	carlton_dictionary-20030207-merge:1.15
	interps-20030202-branch:1.15.0.4
	interps-20030202-branchpoint:1.15
	cagney-unwind-20030108-branch:1.15.0.2
	cagney-unwind-20030108-branchpoint:1.15
	binutils-2_13_2_1:1.13.2.1
	binutils-2_13_2:1.13.2.1
	carlton_dictionary-20021223-merge:1.15
	gdb_5_3-2002-12-12-release:1.13
	carlton_dictionary-20021115-merge:1.14
	binutils-2_13_1:1.13.2.1
	kseitz_interps-20021105-merge:1.14
	kseitz_interps-20021103-merge:1.14
	drow-cplus-merge-20021020:1.13
	drow-cplus-merge-20021025:1.13
	carlton_dictionary-20021025-merge:1.14
	carlton_dictionary-20021011-merge:1.13
	drow-cplus-branch:1.13.0.14
	drow-cplus-branchpoint:1.13
	kseitz_interps-20020930-merge:1.13
	carlton_dictionary-20020927-merge:1.13
	carlton_dictionary-branch:1.13.0.12
	carlton_dictionary-20020920-branchpoint:1.13
	sid-20020905-branchpoint:1.13
	sid-20020905-branch:1.13.0.10
	gdb_5_3-branch:1.13.0.8
	gdb_5_3-2002-09-04-branchpoint:1.13
	kseitz_interps-20020829-merge:1.13
	cagney_sysregs-20020825-branch:1.13.0.6
	cagney_sysregs-20020825-branchpoint:1.13
	readline_4_3-import-branch:1.13.0.4
	readline_4_3-import-branchpoint:1.13
	binutils-2_13:1.13
	gdb_5_2_1-2002-07-23-release:1.8
	binutils-2_13-branchpoint:1.13
	binutils-2_13-branch:1.13.0.2
	kseitz_interps-20020528-branch:1.9.0.6
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.4
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.8.2.1
	jimb-macro-020506-branch:1.9.0.2
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.8
	binutils-2_12:1.8
	gdb_5_2-branch:1.8.0.4
	gdb_5_2-2002-03-03-branchpoint:1.8
	binutils-2_12-branch:1.8.0.2
	binutils-2_12-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	binutils_latest_snapshot:1.43;
locks; strict;
comment	@ * @;


1.43
date	2013.02.11.05.30.54;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2010.10.29.12.10.24;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2010.08.20.22.29.28;	author hjl;	state Exp;
branches;
next	1.40;

1.40
date	2010.08.20.14.41.48;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.09.21.38.58;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2009.08.11.02.21.34;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.05.02.13.46;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.01.11.45.20;	author jsm28;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.19.12.08.34;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.27.03.22.08;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.04.15.53.35;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.04.11.00.23;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.04.07.19.32;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.02.13.59.16;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.14.02.27.56;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.14.00.27.20;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.24.04.46.25;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.25.06.33.47;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.22.01.56.30;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.29.22.59.37;	author amodra;	state Exp;
branches
	1.18.8.1;
next	1.17;

1.17
date	2003.10.04.10.19.26;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.31.10.07.46;	author aj;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.25.02.45.53;	author danglin;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.09.23.47.22;	author amodra;	state Exp;
branches
	1.13.2.1
	1.13.12.1
	1.13.14.1;
next	1.12;

1.12
date	2002.07.04.15.57.24;	author jakub;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.10.10.18.33;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.06.10.47.26;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.05.12.19.08;	author jakub;	state Exp;
branches
	1.9.4.1
	1.9.6.1;
next	1.8;

1.8
date	2002.01.15.12.52.15;	author jakub;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.09.21.02.12.28;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.19.05.33.12;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.18.09.57.25;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.09.14.38.04;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.11.12.23.46;	author jakub;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.24.17.55.57;	author jakub;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.13.00.34.36;	author jakub;	state Exp;
branches;
next	;

1.37.2.1
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	;

1.18.8.1
date	2004.09.16.17.00.34;	author drow;	state Exp;
branches;
next	;

1.13.2.1
date	2002.10.28.18.45.45;	author drow;	state Exp;
branches;
next	;

1.13.12.1
date	2002.10.25.23.49.49;	author carlton;	state Exp;
branches;
next	1.13.12.2;

1.13.12.2
date	2002.12.23.19.37.55;	author carlton;	state Exp;
branches;
next	1.13.12.3;

1.13.12.3
date	2003.09.17.21.27.57;	author carlton;	state Exp;
branches;
next	1.13.12.4;

1.13.12.4
date	2003.11.11.23.50.28;	author carlton;	state Exp;
branches;
next	;

1.13.14.1
date	2003.12.14.20.26.49;	author drow;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.15.16.42.40;	author cagney;	state Exp;
branches;
next	;

1.9.6.1
date	2002.06.20.01.31.01;	author kseitz;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2002.07.22.21.46.48;	author kseitz;	state Exp;
branches;
next	1.9.6.3;

1.9.6.3
date	2002.11.03.22.01.37;	author ezannoni;	state Exp;
branches;
next	;

1.8.2.1
date	2002.03.28.06.20.03;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.43
log
@	* elfcode.h (elf_checksum_contents): Free contents.
	* elf-bfd.h (_bfd_elf_link_hash_table_free): Declare.
	* elflink.c (_bfd_elf_link_hash_table_free): New function.
	(elf_final_link_free): New function, extracted from..
	(bfd_elf_final_link): ..here.  Always call
	_bfd_elf_write_section_eh_frame_hdr.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Default to
	_bfd_elf_link_hash_table_free.
	* libbfd-in.h (_bfd_merge_sections_free): Declare.
	* libbfd.h: Regenerate.
	* merge.c (_bfd_merge_sections_free): New function.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): Free
	hdr_info->array.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): Call
	_bfd_elf_link_hash_table_free.
	* elf32-arm.c (elf32_arm_link_hash_table_free): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_free): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_free): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_free): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_free): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_free): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_free): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_free): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_hash_table_free): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_free): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_free): Likewise.
	* elfnn-ia64.c (elfNN_ia64_hash_table_free): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Don't define.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Dont' define.
@
text
@/* SEC_MERGE support.
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
   Written by Jakub Jelinek <jakub@@redhat.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* This file contains support for merging duplicate entities within sections,
   as used in ELF SHF_MERGE.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "hashtab.h"
#include "libiberty.h"

struct sec_merge_sec_info;

/* An entry in the section merge hash table.  */

struct sec_merge_hash_entry
{
  struct bfd_hash_entry root;
  /* Length of this entry.  This includes the zero terminator.  */
  unsigned int len;
  /* Start of this string needs to be aligned to
     alignment octets (not 1 << align).  */
  unsigned int alignment;
  union
  {
    /* Index within the merged section.  */
    bfd_size_type index;
    /* Entry this is a suffix of (if alignment is 0).  */
    struct sec_merge_hash_entry *suffix;
  } u;
  /* Which section is it in.  */
  struct sec_merge_sec_info *secinfo;
  /* Next entity in the hash table.  */
  struct sec_merge_hash_entry *next;
};

/* The section merge hash table.  */

struct sec_merge_hash
{
  struct bfd_hash_table table;
  /* Next available index.  */
  bfd_size_type size;
  /* First entity in the SEC_MERGE sections of this type.  */
  struct sec_merge_hash_entry *first;
  /* Last entity in the SEC_MERGE sections of this type.  */
  struct sec_merge_hash_entry *last;
  /* Entity size.  */
  unsigned int entsize;
  /* Are entries fixed size or zero terminated strings?  */
  bfd_boolean strings;
};

struct sec_merge_info
{
  /* Chain of sec_merge_infos.  */
  struct sec_merge_info *next;
  /* Chain of sec_merge_sec_infos.  */
  struct sec_merge_sec_info *chain;
  /* A hash table used to hold section content.  */
  struct sec_merge_hash *htab;
};

struct sec_merge_sec_info
{
  /* Chain of sec_merge_sec_infos.  */
  struct sec_merge_sec_info *next;
  /* The corresponding section.  */
  asection *sec;
  /* Pointer to merge_info pointing to us.  */
  void **psecinfo;
  /* A hash table used to hold section content.  */
  struct sec_merge_hash *htab;
  /* First string in this section.  */
  struct sec_merge_hash_entry *first_str;
  /* Original section content.  */
  unsigned char contents[1];
};


/* Routine to create an entry in a section merge hashtab.  */

static struct bfd_hash_entry *
sec_merge_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table, const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    entry = (struct bfd_hash_entry *)
        bfd_hash_allocate (table, sizeof (struct sec_merge_hash_entry));
  if (entry == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  entry = bfd_hash_newfunc (entry, table, string);

  if (entry != NULL)
    {
      /* Initialize the local fields.  */
      struct sec_merge_hash_entry *ret = (struct sec_merge_hash_entry *) entry;

      ret->u.suffix = NULL;
      ret->alignment = 0;
      ret->secinfo = NULL;
      ret->next = NULL;
    }

  return entry;
}

/* Look up an entry in a section merge hash table.  */

static struct sec_merge_hash_entry *
sec_merge_hash_lookup (struct sec_merge_hash *table, const char *string,
		       unsigned int alignment, bfd_boolean create)
{
  const unsigned char *s;
  unsigned long hash;
  unsigned int c;
  struct sec_merge_hash_entry *hashp;
  unsigned int len, i;
  unsigned int _index;

  hash = 0;
  len = 0;
  s = (const unsigned char *) string;
  if (table->strings)
    {
      if (table->entsize == 1)
	{
	  while ((c = *s++) != '\0')
	    {
	      hash += c + (c << 17);
	      hash ^= hash >> 2;
	      ++len;
	    }
	  hash += len + (len << 17);
	}
      else
	{
	  for (;;)
	    {
	      for (i = 0; i < table->entsize; ++i)
		if (s[i] != '\0')
		  break;
	      if (i == table->entsize)
		break;
	      for (i = 0; i < table->entsize; ++i)
		{
		  c = *s++;
		  hash += c + (c << 17);
		  hash ^= hash >> 2;
		}
	      ++len;
	    }
	  hash += len + (len << 17);
	  len *= table->entsize;
	}
      hash ^= hash >> 2;
      len += table->entsize;
    }
  else
    {
      for (i = 0; i < table->entsize; ++i)
	{
	  c = *s++;
	  hash += c + (c << 17);
	  hash ^= hash >> 2;
	}
      len = table->entsize;
    }

  _index = hash % table->table.size;
  for (hashp = (struct sec_merge_hash_entry *) table->table.table[_index];
       hashp != NULL;
       hashp = (struct sec_merge_hash_entry *) hashp->root.next)
    {
      if (hashp->root.hash == hash
	  && len == hashp->len
	  && memcmp (hashp->root.string, string, len) == 0)
	{
	  /* If the string we found does not have at least the required
	     alignment, we need to insert another copy.  */
	  if (hashp->alignment < alignment)
	    {
	      if (create)
		{
		  /*  Mark the less aligned copy as deleted.  */
		  hashp->len = 0;
		  hashp->alignment = 0;
		}
	      break;
	    }
	  return hashp;
	}
    }

  if (! create)
    return NULL;

  hashp = ((struct sec_merge_hash_entry *)
	   bfd_hash_insert (&table->table, string, hash));
  if (hashp == NULL)
    return NULL;
  hashp->len = len;
  hashp->alignment = alignment;
  return hashp;
}

/* Create a new hash table.  */

static struct sec_merge_hash *
sec_merge_init (unsigned int entsize, bfd_boolean strings)
{
  struct sec_merge_hash *table;

  table = (struct sec_merge_hash *) bfd_malloc (sizeof (struct sec_merge_hash));
  if (table == NULL)
    return NULL;

  if (! bfd_hash_table_init_n (&table->table, sec_merge_hash_newfunc,
			       sizeof (struct sec_merge_hash_entry), 16699))
    {
      free (table);
      return NULL;
    }

  table->size = 0;
  table->first = NULL;
  table->last = NULL;
  table->entsize = entsize;
  table->strings = strings;

  return table;
}

/* Get the index of an entity in a hash table, adding it if it is not
   already present.  */

static struct sec_merge_hash_entry *
sec_merge_add (struct sec_merge_hash *tab, const char *str,
	       unsigned int alignment, struct sec_merge_sec_info *secinfo)
{
  struct sec_merge_hash_entry *entry;

  entry = sec_merge_hash_lookup (tab, str, alignment, TRUE);
  if (entry == NULL)
    return NULL;

  if (entry->secinfo == NULL)
    {
      tab->size++;
      entry->secinfo = secinfo;
      if (tab->first == NULL)
	tab->first = entry;
      else
	tab->last->next = entry;
      tab->last = entry;
    }

  return entry;
}

static bfd_boolean
sec_merge_emit (bfd *abfd, struct sec_merge_hash_entry *entry)
{
  struct sec_merge_sec_info *secinfo = entry->secinfo;
  asection *sec = secinfo->sec;
  char *pad = NULL;
  bfd_size_type off = 0;
  int alignment_power = sec->output_section->alignment_power;

  if (alignment_power)
    {
      pad = (char *) bfd_zmalloc ((bfd_size_type) 1 << alignment_power);
      if (pad == NULL)
	return FALSE;
    }

  for (; entry != NULL && entry->secinfo == secinfo; entry = entry->next)
    {
      const char *str;
      bfd_size_type len;

      len = -off & (entry->alignment - 1);
      if (len != 0)
	{
	  if (bfd_bwrite (pad, len, abfd) != len)
	    goto err;
	  off += len;
	}

      str = entry->root.string;
      len = entry->len;

      if (bfd_bwrite (str, len, abfd) != len)
	goto err;

      off += len;
    }

  /* Trailing alignment needed?  */
  off = sec->size - off;
  if (off != 0
      && bfd_bwrite (pad, off, abfd) != off)
    goto err;

  if (pad != NULL)
    free (pad);
  return TRUE;

 err:
  if (pad != NULL)
    free (pad);
  return FALSE;
}

/* Register a SEC_MERGE section as a candidate for merging.
   This function is called for all non-dynamic SEC_MERGE input sections.  */

bfd_boolean
_bfd_add_merge_section (bfd *abfd, void **psinfo, asection *sec,
			void **psecinfo)
{
  struct sec_merge_info *sinfo;
  struct sec_merge_sec_info *secinfo;
  unsigned int align;
  bfd_size_type amt;
  bfd_byte *contents;

  if ((abfd->flags & DYNAMIC) != 0
      || (sec->flags & SEC_MERGE) == 0)
    abort ();

  if (sec->size == 0
      || (sec->flags & SEC_EXCLUDE) != 0
      || sec->entsize == 0)
    return TRUE;

  if ((sec->flags & SEC_RELOC) != 0)
    {
      /* We aren't prepared to handle relocations in merged sections.  */
      return TRUE;
    }

  align = sec->alignment_power;
  if ((sec->entsize < (unsigned) 1 << align
       && ((sec->entsize & (sec->entsize - 1))
	   || !(sec->flags & SEC_STRINGS)))
      || (sec->entsize > (unsigned) 1 << align
	  && (sec->entsize & (((unsigned) 1 << align) - 1))))
    {
      /* Sanity check.  If string character size is smaller than
	 alignment, then we require character size to be a power
	 of 2, otherwise character size must be integer multiple
	 of alignment.  For non-string constants, alignment must
	 be smaller than or equal to entity size and entity size
	 must be integer multiple of alignment.  */
      return TRUE;
    }

  for (sinfo = (struct sec_merge_info *) *psinfo; sinfo; sinfo = sinfo->next)
    if ((secinfo = sinfo->chain)
	&& ! ((secinfo->sec->flags ^ sec->flags) & (SEC_MERGE | SEC_STRINGS))
	&& secinfo->sec->entsize == sec->entsize
	&& secinfo->sec->alignment_power == sec->alignment_power
	&& secinfo->sec->output_section == sec->output_section)
      break;

  if (sinfo == NULL)
    {
      /* Initialize the information we need to keep track of.  */
      sinfo = (struct sec_merge_info *)
          bfd_alloc (abfd, sizeof (struct sec_merge_info));
      if (sinfo == NULL)
	goto error_return;
      sinfo->next = (struct sec_merge_info *) *psinfo;
      sinfo->chain = NULL;
      *psinfo = sinfo;
      sinfo->htab = sec_merge_init (sec->entsize, (sec->flags & SEC_STRINGS));
      if (sinfo->htab == NULL)
	goto error_return;
    }

  /* Read the section from abfd.  */

  amt = sizeof (struct sec_merge_sec_info) - 1 + sec->size;
  if (sec->flags & SEC_STRINGS)
    /* Some versions of gcc may emit a string without a zero terminator.
       See http://gcc.gnu.org/ml/gcc-patches/2006-06/msg01004.html
       Allocate space for an extra zero.  */
    amt += sec->entsize;
  *psecinfo = bfd_alloc (abfd, amt);
  if (*psecinfo == NULL)
    goto error_return;

  secinfo = (struct sec_merge_sec_info *) *psecinfo;
  if (sinfo->chain)
    {
      secinfo->next = sinfo->chain->next;
      sinfo->chain->next = secinfo;
    }
  else
    secinfo->next = secinfo;
  sinfo->chain = secinfo;
  secinfo->sec = sec;
  secinfo->psecinfo = psecinfo;
  secinfo->htab = sinfo->htab;
  secinfo->first_str = NULL;

  sec->rawsize = sec->size;
  if (sec->flags & SEC_STRINGS)
    memset (secinfo->contents + sec->size, 0, sec->entsize);
  contents = secinfo->contents;
  if (! bfd_get_full_section_contents (sec->owner, sec, &contents))
    goto error_return;

  return TRUE;

 error_return:
  *psecinfo = NULL;
  return FALSE;
}

/* Record one section into the hash table.  */
static bfd_boolean
record_section (struct sec_merge_info *sinfo,
		struct sec_merge_sec_info *secinfo)
{
  asection *sec = secinfo->sec;
  struct sec_merge_hash_entry *entry;
  bfd_boolean nul;
  unsigned char *p, *end;
  bfd_vma mask, eltalign;
  unsigned int align, i;

  align = sec->alignment_power;
  end = secinfo->contents + sec->size;
  nul = FALSE;
  mask = ((bfd_vma) 1 << align) - 1;
  if (sec->flags & SEC_STRINGS)
    {
      for (p = secinfo->contents; p < end; )
	{
	  eltalign = p - secinfo->contents;
	  eltalign = ((eltalign ^ (eltalign - 1)) + 1) >> 1;
	  if (!eltalign || eltalign > mask)
	    eltalign = mask + 1;
	  entry = sec_merge_add (sinfo->htab, (char *) p, (unsigned) eltalign,
				 secinfo);
	  if (! entry)
	    goto error_return;
	  p += entry->len;
	  if (sec->entsize == 1)
	    {
	      while (p < end && *p == 0)
		{
		  if (!nul && !((p - secinfo->contents) & mask))
		    {
		      nul = TRUE;
		      entry = sec_merge_add (sinfo->htab, "",
					     (unsigned) mask + 1, secinfo);
		      if (! entry)
			goto error_return;
		    }
		  p++;
		}
	    }
	  else
	    {
	      while (p < end)
		{
		  for (i = 0; i < sec->entsize; i++)
		    if (p[i] != '\0')
		      break;
		  if (i != sec->entsize)
		    break;
		  if (!nul && !((p - secinfo->contents) & mask))
		    {
		      nul = TRUE;
		      entry = sec_merge_add (sinfo->htab, (char *) p,
					     (unsigned) mask + 1, secinfo);
		      if (! entry)
			goto error_return;
		    }
		  p += sec->entsize;
		}
	    }
	}
    }
  else
    {
      for (p = secinfo->contents; p < end; p += sec->entsize)
	{
	  entry = sec_merge_add (sinfo->htab, (char *) p, 1, secinfo);
	  if (! entry)
	    goto error_return;
	}
    }

  return TRUE;

error_return:
  for (secinfo = sinfo->chain; secinfo; secinfo = secinfo->next)
    *secinfo->psecinfo = NULL;
  return FALSE;
}

static int
strrevcmp (const void *a, const void *b)
{
  struct sec_merge_hash_entry *A = *(struct sec_merge_hash_entry **) a;
  struct sec_merge_hash_entry *B = *(struct sec_merge_hash_entry **) b;
  unsigned int lenA = A->len;
  unsigned int lenB = B->len;
  const unsigned char *s = (const unsigned char *) A->root.string + lenA - 1;
  const unsigned char *t = (const unsigned char *) B->root.string + lenB - 1;
  int l = lenA < lenB ? lenA : lenB;

  while (l)
    {
      if (*s != *t)
	return (int) *s - (int) *t;
      s--;
      t--;
      l--;
    }
  return lenA - lenB;
}

/* Like strrevcmp, but for the case where all strings have the same
   alignment > entsize.  */

static int
strrevcmp_align (const void *a, const void *b)
{
  struct sec_merge_hash_entry *A = *(struct sec_merge_hash_entry **) a;
  struct sec_merge_hash_entry *B = *(struct sec_merge_hash_entry **) b;
  unsigned int lenA = A->len;
  unsigned int lenB = B->len;
  const unsigned char *s = (const unsigned char *) A->root.string + lenA - 1;
  const unsigned char *t = (const unsigned char *) B->root.string + lenB - 1;
  int l = lenA < lenB ? lenA : lenB;
  int tail_align = (lenA & (A->alignment - 1)) - (lenB & (A->alignment - 1));

  if (tail_align != 0)
    return tail_align;

  while (l)
    {
      if (*s != *t)
	return (int) *s - (int) *t;
      s--;
      t--;
      l--;
    }
  return lenA - lenB;
}

static inline int
is_suffix (const struct sec_merge_hash_entry *A,
	   const struct sec_merge_hash_entry *B)
{
  if (A->len <= B->len)
    /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
       not to be equal by the hash table.  */
    return 0;

  return memcmp (A->root.string + (A->len - B->len),
		 B->root.string, B->len) == 0;
}

/* This is a helper function for _bfd_merge_sections.  It attempts to
   merge strings matching suffixes of longer strings.  */
static void
merge_strings (struct sec_merge_info *sinfo)
{
  struct sec_merge_hash_entry **array, **a, *e;
  struct sec_merge_sec_info *secinfo;
  bfd_size_type size, amt;
  unsigned int alignment = 0;

  /* Now sort the strings */
  amt = sinfo->htab->size * sizeof (struct sec_merge_hash_entry *);
  array = (struct sec_merge_hash_entry **) bfd_malloc (amt);
  if (array == NULL)
    goto alloc_failure;

  for (e = sinfo->htab->first, a = array; e; e = e->next)
    if (e->alignment)
      {
	*a++ = e;
	/* Adjust the length to not include the zero terminator.  */
	e->len -= sinfo->htab->entsize;
	if (alignment != e->alignment)
	  {
	    if (alignment == 0)
	      alignment = e->alignment;
	    else
	      alignment = (unsigned) -1;
	  }
      }

  sinfo->htab->size = a - array;
  if (sinfo->htab->size != 0)
    {
      qsort (array, (size_t) sinfo->htab->size,
	     sizeof (struct sec_merge_hash_entry *),
	     (alignment != (unsigned) -1 && alignment > sinfo->htab->entsize
	      ? strrevcmp_align : strrevcmp));

      /* Loop over the sorted array and merge suffixes */
      e = *--a;
      e->len += sinfo->htab->entsize;
      while (--a >= array)
	{
	  struct sec_merge_hash_entry *cmp = *a;

	  cmp->len += sinfo->htab->entsize;
	  if (e->alignment >= cmp->alignment
	      && !((e->len - cmp->len) & (cmp->alignment - 1))
	      && is_suffix (e, cmp))
	    {
	      cmp->u.suffix = e;
	      cmp->alignment = 0;
	    }
	  else
	    e = cmp;
	}
    }

alloc_failure:
  if (array)
    free (array);

  /* Now assign positions to the strings we want to keep.  */
  size = 0;
  secinfo = sinfo->htab->first->secinfo;
  for (e = sinfo->htab->first; e; e = e->next)
    {
      if (e->secinfo != secinfo)
	{
	  secinfo->sec->size = size;
	  secinfo = e->secinfo;
	}
      if (e->alignment)
	{
	  if (e->secinfo->first_str == NULL)
	    {
	      e->secinfo->first_str = e;
	      size = 0;
	    }
	  size = (size + e->alignment - 1) & ~((bfd_vma) e->alignment - 1);
	  e->u.index = size;
	  size += e->len;
	}
    }
  secinfo->sec->size = size;
  if (secinfo->sec->alignment_power != 0)
    {
      bfd_size_type align = (bfd_size_type) 1 << secinfo->sec->alignment_power;
      secinfo->sec->size = (secinfo->sec->size + align - 1) & -align;
    }

  /* And now adjust the rest, removing them from the chain (but not hashtable)
     at the same time.  */
  for (a = &sinfo->htab->first, e = *a; e; e = e->next)
    if (e->alignment)
      a = &e->next;
    else
      {
	*a = e->next;
	if (e->len)
	  {
	    e->secinfo = e->u.suffix->secinfo;
	    e->alignment = e->u.suffix->alignment;
	    e->u.index = e->u.suffix->u.index + (e->u.suffix->len - e->len);
	  }
      }
}

/* This function is called once after all SEC_MERGE sections are registered
   with _bfd_merge_section.  */

bfd_boolean
_bfd_merge_sections (bfd *abfd,
		     struct bfd_link_info *info ATTRIBUTE_UNUSED,
		     void *xsinfo,
		     void (*remove_hook) (bfd *, asection *))
{
  struct sec_merge_info *sinfo;

  for (sinfo = (struct sec_merge_info *) xsinfo; sinfo; sinfo = sinfo->next)
    {
      struct sec_merge_sec_info * secinfo;

      if (! sinfo->chain)
	continue;

      /* Move sinfo->chain to head of the chain, terminate it.  */
      secinfo = sinfo->chain;
      sinfo->chain = secinfo->next;
      secinfo->next = NULL;

      /* Record the sections into the hash table.  */
      for (secinfo = sinfo->chain; secinfo; secinfo = secinfo->next)
	if (secinfo->sec->flags & SEC_EXCLUDE)
	  {
	    *secinfo->psecinfo = NULL;
	    if (remove_hook)
	      (*remove_hook) (abfd, secinfo->sec);
	  }
	else if (! record_section (sinfo, secinfo))
	  break;

      if (secinfo)
	continue;

      if (sinfo->htab->first == NULL)
	continue;

      if (sinfo->htab->strings)
	merge_strings (sinfo);
      else
	{
	  struct sec_merge_hash_entry *e;
	  bfd_size_type size = 0;

	  /* Things are much simpler for non-strings.
	     Just assign them slots in the section.  */
	  secinfo = NULL;
	  for (e = sinfo->htab->first; e; e = e->next)
	    {
	      if (e->secinfo->first_str == NULL)
		{
		  if (secinfo)
		    secinfo->sec->size = size;
		  e->secinfo->first_str = e;
		  size = 0;
		}
	      size = (size + e->alignment - 1)
		     & ~((bfd_vma) e->alignment - 1);
	      e->u.index = size;
	      size += e->len;
	      secinfo = e->secinfo;
	    }
	  secinfo->sec->size = size;
	}

	/* Finally remove all input sections which have not made it into
	   the hash table at all.  */
	for (secinfo = sinfo->chain; secinfo; secinfo = secinfo->next)
	  if (secinfo->first_str == NULL)
	    secinfo->sec->flags |= SEC_EXCLUDE | SEC_KEEP;
    }

  return TRUE;
}

/* Write out the merged section.  */

bfd_boolean
_bfd_write_merged_section (bfd *output_bfd, asection *sec, void *psecinfo)
{
  struct sec_merge_sec_info *secinfo;
  file_ptr pos;

  secinfo = (struct sec_merge_sec_info *) psecinfo;

  if (!secinfo)
    return FALSE;

  if (secinfo->first_str == NULL)
    return TRUE;

  /* FIXME: octets_per_byte.  */
  pos = sec->output_section->filepos + sec->output_offset;
  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0)
    return FALSE;

  if (! sec_merge_emit (output_bfd, secinfo->first_str))
    return FALSE;

  return TRUE;
}

/* Adjust an address in the SEC_MERGE section.  Given OFFSET within
   *PSEC, this returns the new offset in the adjusted SEC_MERGE
   section and writes the new section back into *PSEC.  */

bfd_vma
_bfd_merged_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED, asection **psec,
			    void *psecinfo, bfd_vma offset)
{
  struct sec_merge_sec_info *secinfo;
  struct sec_merge_hash_entry *entry;
  unsigned char *p;
  asection *sec = *psec;

  secinfo = (struct sec_merge_sec_info *) psecinfo;

  if (!secinfo)
    return offset;

  if (offset >= sec->rawsize)
    {
      if (offset > sec->rawsize)
	{
	  (*_bfd_error_handler)
	    (_("%s: access beyond end of merged section (%ld)"),
	     bfd_get_filename (sec->owner), (long) offset);
	}
      return secinfo->first_str ? sec->size : 0;
    }

  if (secinfo->htab->strings)
    {
      if (sec->entsize == 1)
	{
	  p = secinfo->contents + offset - 1;
	  while (p >= secinfo->contents && *p)
	    --p;
	  ++p;
	}
      else
	{
	  p = secinfo->contents + (offset / sec->entsize) * sec->entsize;
	  p -= sec->entsize;
	  while (p >= secinfo->contents)
	    {
	      unsigned int i;

	      for (i = 0; i < sec->entsize; ++i)
		if (p[i] != '\0')
		  break;
	      if (i == sec->entsize)
		break;
	      p -= sec->entsize;
	    }
	  p += sec->entsize;
	}
    }
  else
    {
      p = secinfo->contents + (offset / sec->entsize) * sec->entsize;
    }
  entry = sec_merge_hash_lookup (secinfo->htab, (char *) p, 0, FALSE);
  if (!entry)
    {
      if (! secinfo->htab->strings)
	abort ();
      /* This should only happen if somebody points into the padding
	 after a NUL character but before next entity.  */
      if (*p)
	abort ();
      if (! secinfo->htab->first)
	abort ();
      entry = secinfo->htab->first;
      p = (secinfo->contents + (offset / sec->entsize + 1) * sec->entsize
	   - entry->len);
    }

  *psec = entry->secinfo->sec;
  return entry->u.index + (secinfo->contents + offset - p);
}

/* Tidy up when done.  */

void
_bfd_merge_sections_free (void *xsinfo)
{
  struct sec_merge_info *sinfo;

  for (sinfo = (struct sec_merge_info *) xsinfo; sinfo; sinfo = sinfo->next)
    {
      bfd_hash_table_free (&sinfo->htab->table);
      free (sinfo->htab);
    }
}
@


1.42
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d888 14
@


1.41
log
@Revert the last checkin on sec_merge_emit.

2010-08-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* merge.c (sec_merge_emit): Revert the last checkin.
@
text
@d351 1
d436 2
a437 2
  if (! bfd_get_section_contents (sec->owner, sec, secinfo->contents,
				  0, sec->size))
@


1.40
log
@        * merge.c (sec_merge_emit): Do not zero pad sections that do not
        have an alignment.
@
text
@a309 3
	  /* We should never have an entry with an alignment
	     greater than the section's alignment.  */
	  BFD_ASSERT (len <= (bfd_size_type) (1 << alignment_power));
a326 1
      && alignment_power
@


1.39
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d310 3
d330 1
@


1.38
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d139 3
a141 3
  register const unsigned char *s;
  register unsigned long hash;
  register unsigned int c;
d144 1
a144 1
  unsigned int index;
d195 2
a196 2
  index = hash % table->table.size;
  for (hashp = (struct sec_merge_hash_entry *) table->table.table[index];
d266 1
a266 1
  register struct sec_merge_hash_entry *entry;
@


1.37
log
@update copyright dates
@
text
@d111 2
a112 1
    entry = bfd_hash_allocate (table, sizeof (struct sec_merge_hash_entry));
d239 1
a239 1
  table = bfd_malloc (sizeof (struct sec_merge_hash));
d297 1
a297 1
      pad = bfd_zmalloc ((bfd_size_type) 1 << alignment_power);
d394 2
a395 1
      sinfo = bfd_alloc (abfd, sizeof (struct sec_merge_info));
d606 1
a606 1
  array = bfd_malloc (amt);
@


1.37.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d111 1
a111 2
    entry = (struct bfd_hash_entry *)
        bfd_hash_allocate (table, sizeof (struct sec_merge_hash_entry));
d238 1
a238 1
  table = (struct sec_merge_hash *) bfd_malloc (sizeof (struct sec_merge_hash));
d296 1
a296 1
      pad = (char *) bfd_zmalloc ((bfd_size_type) 1 << alignment_power);
d393 1
a393 2
      sinfo = (struct sec_merge_info *)
          bfd_alloc (abfd, sizeof (struct sec_merge_info));
d604 1
a604 1
  array = (struct sec_merge_hash_entry **) bfd_malloc (amt);
@


1.36
log
@	* elflink.c: Add FIXMEs for some places that require octets_per_byte
	adjustments.
	* elf-eh-frame.c: Likewise.
	* merge.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.35
log
@	* merge.c (sec_merge_hash_lookup): Revert last change.
	(record_section): Likewise.
	(_bfd_merge_sections): Likewise.
	(_bfd_merged_section_offset): Properly handle NULL secinfo.
	(_bfd_add_merge_section): Allocate extra space for a zero
	terminator on SEC_STRINGS sections.
@
text
@d795 1
@


1.34
log
@bfd:
	* merge.c (sec_merge_hash_lookup): Add parameter sec_end.  Check
	for unterminated strings.  All callers changed.
	(record_section): Add parameter abfd.  Give error message for
	unterminated strings.
	(_bfd_merge_sections): Update call to record_section.
	(_bfd_write_merged_section, _bfd_merged_section_offset): Handle
	NULL secinfo from merge failures.

ld/testsuite:
	* ld-elf/merge3.d, ld-elf/merge3.s: New.
@
text
@a135 1
		       const unsigned char *sec_end,
a156 2
	      if (sec_end && s >= sec_end)
		return NULL;
a163 2
	      if (sec_end && s + table->entsize > sec_end)
		return NULL;
d267 1
a267 3
  entry = sec_merge_hash_lookup (tab, str,
				 secinfo->contents + secinfo->sec->size,
				 alignment, TRUE);
d406 6
a411 1
  amt = sizeof (struct sec_merge_sec_info) + sec->size - 1;
d431 2
d446 1
a446 2
record_section (bfd *abfd,
		struct sec_merge_info *sinfo,
a522 4
  if (bfd_get_error () != bfd_error_no_memory)
    (*_bfd_error_handler)
      (_("%B: unterminated string in section `%A' marked for merging"),
       abfd, sec);
d732 1
a732 1
	else if (! record_section (abfd, sinfo, secinfo))
d821 1
a821 1
    return 0;
d865 1
a865 1
  entry = sec_merge_hash_lookup (secinfo->htab, (char *) p, NULL, 0, FALSE);
@


1.33
log
@	* bfd-in.h (bfd_hash_insert): Declare.
	* bfd-in2.h: Regenerate.
	* hash.c (bfd_hash_insert): New function.  Split out from..
	(bfd_hash_lookup): ..here.
	* merge.c (sec_merge_hash_lookup): Use bfd_hash_insert.
@
text
@d136 1
d158 2
d167 2
d272 3
a274 1
  entry = sec_merge_hash_lookup (tab, str, alignment, TRUE);
d446 2
a447 1
record_section (struct sec_merge_info *sinfo,
d524 4
d710 1
a710 1
_bfd_merge_sections (bfd *abfd ATTRIBUTE_UNUSED,
d737 1
a737 1
	else if (! record_section (sinfo, secinfo))
d794 3
d825 3
d870 1
a870 1
  entry = sec_merge_hash_lookup (secinfo->htab, (char *) p, 0, FALSE);
@


1.32
log
@Switch sources over to use the GPL version 3
@
text
@d223 1
a223 1
	   sec_merge_hash_newfunc (NULL, &table->table, string));
a225 2
  hashp->root.string = string;
  hashp->root.hash = hash;
a227 3
  hashp->root.next = table->table.table[index];
  table->table.table[index] = (struct bfd_hash_entry *) hashp;

@


1.31
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 3
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.30
log
@bfd/
	* section.c (SEC_KEEP): Update comment.
	* bfd-in2.h: Regenerate.
	* elflink.c (bfd_elf_gc_sections): Ignore SEC_EXCLUDE sections.
	* merge.c (_bfd_merge_sections): Set SEC_KEEP on excluded sections.
	* stabs.c (_bfd_discard_section_stabs): Likewise.
	(_bfd_link_section_stabs): Likewise.  Simplify abs_section check.
ld/
	* ldlang.c (lang_map): Don't say SEC_LINKER_CREATED and SEC_KEEP
	sections have been discarded.
	(lang_do_version_exports_section): Set SEC_KEEP on export section.
	* emultempl/elf32.em (before_allocation): Set SEC_KEEP on warning
	sections.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006
d25 1
a26 1
#include "sysdep.h"
@


1.29
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d769 1
a769 1
	    secinfo->sec->flags |= SEC_EXCLUDE;
@


1.28
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2 2
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d246 1
a246 1
			       16699))
@


1.27
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.26
log
@Update the FSF address in the copyright/GPL notice
@
text
@d700 4
a703 2
_bfd_merge_sections (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info,
		     void *xsinfo, void (*remove_hook) (bfd *, asection *))
d768 1
a768 1
	    _bfd_strip_section_from_output (info, secinfo->sec);
@


1.25
log
@2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* merge.c (sec_merge_init): Call bfd_hash_table_init_n with
	hash table size 16699 instead of bfd_hash_table_init.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.24
log
@	* merge.c (sec_merge_emit): Tidy.  Check for bfd_zmalloc errors.
	Write trailing padding.
@
text
@d244 2
a245 1
  if (! bfd_hash_table_init (&table->table, sec_merge_hash_newfunc))
@


1.23
log
@	* merge.c (merge_strings): Round up section size for alignment.
@
text
@d291 1
a291 1
  char *pad = "";
d296 5
a300 1
    pad = bfd_zmalloc ((bfd_size_type) 1 << alignment_power);
d304 2
a305 2
      register const char *str;
      register size_t len;
d307 2
a308 2
      len = off & (entry->alignment - 1);
      if (len)
a309 1
	  len = entry->alignment - len;
d311 1
a311 1
	    break;
d319 1
a319 1
	break;
d324 7
a330 1
  if (alignment_power)
d332 1
d334 4
a337 1
  return entry == NULL || entry->secinfo != secinfo;
@


1.22
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d659 5
@


1.21
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d449 2
a450 1
	  entry = sec_merge_add (sinfo->htab, p, (unsigned) eltalign, secinfo);
d481 1
a481 1
		      entry = sec_merge_add (sinfo->htab, p,
d495 1
a495 1
	  entry = sec_merge_add (sinfo->htab, p, 1, secinfo);
d516 2
a517 2
  const unsigned char *s = A->root.string + lenA - 1;
  const unsigned char *t = B->root.string + lenB - 1;
d541 2
a542 2
  const unsigned char *s = A->root.string + lenA - 1;
  const unsigned char *t = B->root.string + lenB - 1;
d833 1
a833 1
  entry = sec_merge_hash_lookup (secinfo->htab, p, 0, FALSE);
@


1.20
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Don't set up merge
	section data here..
	* elf.c (_bfd_elf_merge_sections): .. Do it here instead.
	* merge.c: Formatting.  Remove unnecessary casts.  Expand
	bfd_get_section_alignment macro.
	(struct sec_merge_sec_info): Rename "first" to "first_str".  Update
	use throughout file.
	(_bfd_add_merge_section): Rename from _bfd_merge_section.  Update
	comment.  Abort on dynamic or non-SEC_MERGE input.  Don't test
	section name to determine sinfo group, instead test output section
	and alignment.
	(_bfd_merge_sections): Add struct bfd_link_info param.  Call
	_bfd_strip_section_from_output rather than just twiddling flags.
	* libbfd-in.h (_bfd_add_merge_section): Rename, update comment.
	(_bfd_merge_sections): Update prototype.
	* libbfd.h: Regenerate.
ld/
	* ldlang.c (lang_process): Call bfd_merge_sections later, and
	only when not a relocatable link.
	(print_input_section): Handle SEC_EXCLUDE sections.
	(size_input_section): Don't update dot on SEC_EXCLUDE sections.
	(lang_do_assignments_1): Likewise.
	* ldwrite.c (build_link_order): Ignore SEC_EXCLUDE input sections.
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Likewise.
	* emultempl/hppaelf.em (build_section_lists): Likewise.
	* emultempl/ppc64elf.em (build_toc_list): Likewise.
	(build_section_lists): Likewise.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d343 1
a343 1
  if (sec->_raw_size == 0
d394 1
a394 1
  amt = sizeof (struct sec_merge_sec_info) + sec->_raw_size - 1;
d413 1
d415 1
a415 1
				  0, sec->_raw_size))
d438 1
a438 1
  end = secinfo->contents + sec->_raw_size;
d642 1
a642 1
	  secinfo->sec->_cooked_size = size;
d657 1
a657 1
  secinfo->sec->_cooked_size = size;
d729 1
a729 1
		    secinfo->sec->_cooked_size = size;
d739 1
a739 1
	  secinfo->sec->_cooked_size = size;
d790 1
a790 1
  if (offset >= sec->_raw_size)
d792 1
a792 1
      if (offset > sec->_raw_size)
d798 1
a798 1
      return (secinfo->first_str ? sec->_cooked_size : 0);
@


1.19
log
@	* merge.c (_bfd_merged_section_offset): Remove "addend" param.
	* libbfd-in.h (_bfd_merged_section_offset): Adjust prototype.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_rela_local_sym): Adjust call.
	(_bfd_elf_rel_local_sym): Likewise.
	* elflink.c (_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_relocate_section): Likewise.
@
text
@d93 1
a93 1
  struct sec_merge_hash_entry *first;
a104 2
  struct sec_merge_hash_entry *ret = (struct sec_merge_hash_entry *) entry;

d107 3
a109 4
  if (ret == (struct sec_merge_hash_entry *) NULL)
    ret = ((struct sec_merge_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct sec_merge_hash_entry)));
  if (ret == (struct sec_merge_hash_entry *) NULL)
d113 1
a113 2
  ret = ((struct sec_merge_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
d115 1
a115 1
  if (ret)
d118 2
d126 1
a126 1
  return (struct bfd_hash_entry *) ret;
d193 1
a193 1
       hashp != (struct sec_merge_hash_entry *) NULL;
d217 1
a217 1
    return (struct sec_merge_hash_entry *) NULL;
d219 4
a222 5
  hashp = (struct sec_merge_hash_entry *)
	  sec_merge_hash_newfunc ((struct bfd_hash_entry *) NULL,
				  (struct bfd_hash_table *) table, string);
  if (hashp == (struct sec_merge_hash_entry *) NULL)
    return (struct sec_merge_hash_entry *) NULL;
a238 1
  bfd_size_type amt = sizeof (struct sec_merge_hash);
d240 1
a240 1
  table = (struct sec_merge_hash *) bfd_malloc (amt);
d293 1
a293 1
  int alignment_power = bfd_get_section_alignment (abfd, sec->output_section);
d307 1
a307 1
	  if (bfd_bwrite (pad, (bfd_size_type) len, abfd) != len)
d315 1
a315 1
      if (bfd_bwrite (str, (bfd_size_type) len, abfd) != len)
d327 2
a328 2
/* This function is called for each input file from the add_symbols
   pass of the linker.  */
d331 2
a332 1
_bfd_merge_section (bfd *abfd, void **psinfo, asection *sec, void **psecinfo)
d339 4
d344 1
a344 2
      || (sec->flags & SEC_EXCLUDE)
      || (sec->flags & SEC_MERGE) == 0
d354 2
a355 2
  align = bfd_get_section_alignment (sec->owner, sec);
  if ((sec->entsize < (unsigned int)(1 << align)
d358 2
a359 2
      || (sec->entsize > (unsigned int)(1 << align)
	  && (sec->entsize & ((1 << align) - 1))))
d374 2
a375 1
	&& ! strcmp (secinfo->sec->name, sec->name))
d381 1
a381 2
      amt = sizeof (struct sec_merge_info);
      sinfo = (struct sec_merge_info *) bfd_alloc (abfd, amt);
d399 1
a399 1
  secinfo = (struct sec_merge_sec_info *)*psecinfo;
d411 1
a411 1
  secinfo->first = NULL;
d414 1
a414 1
				  (bfd_vma) 0, sec->_raw_size))
d436 1
a436 1
  align = bfd_get_section_alignment (sec->owner, sec);
d583 1
a583 1
  array = (struct sec_merge_hash_entry **) bfd_malloc (amt);
d646 1
a646 1
	  if (e->secinfo->first == NULL)
d648 1
a648 1
	      e->secinfo->first = e;
d679 2
a680 2
_bfd_merge_sections (bfd *abfd ATTRIBUTE_UNUSED, void *xsinfo,
		     void (*remove_hook) (bfd *, asection *))
d725 1
a725 1
	      if (e->secinfo->first == NULL)
d729 1
a729 1
		  e->secinfo->first = e;
d744 2
a745 5
	  if (secinfo->first == NULL)
	    {
	      secinfo->sec->_cooked_size = 0;
	      secinfo->sec->flags |= SEC_EXCLUDE;
	    }
d761 1
a761 1
  if (!secinfo->first)
d768 1
a768 1
  if (! sec_merge_emit (output_bfd, secinfo->first))
d797 1
a797 1
      return (secinfo->first ? sec->_cooked_size : 0);
@


1.18
log
@	* merge.c (struct sec_merge_sec_info): Update comment.
	(struct sec_merge_hash_entry): Remove entsize.
	(sec_merge_hash_lookup): Only adjust alignment when creating.
	(sec_merge_emit): Remove register keyword.
	(cmplengthentry, last4_eq, last_eq): Delete.
	(strrevcmp, strrevcmp_align, is_suffix): New.
	(merge_strings): Use them to implement fast suffix merging.
	* elf-strtab.c (struct elf_strtab_hash_entry): Update comments.
	Make "len" signed.
	(_bfd_elf_strtab_add): Lose on >2G strings.
	(_bfd_elf_strtab_emit): Don't emit strings with len < 0.
	(cmplengthentry, last4_eq): Delete.
	(strrevcmp, is_suffix): New.
	(_bfd_elf_strtab_finalize): Rework to implement fast suffix merging.
@
text
@d783 1
a783 1
			    void *psecinfo, bfd_vma offset, bfd_vma addend)
d792 1
a792 1
  if (offset + addend >= sec->_raw_size)
d794 1
a794 1
      if (offset + addend > sec->_raw_size)
d797 2
a798 2
	    (_("%s: access beyond end of merged section (%ld + %ld)"),
	     bfd_get_filename (sec->owner), (long) offset, (long) addend);
d807 1
a807 1
	  p = secinfo->contents + offset + addend - 1;
d814 1
a814 2
	  p = secinfo->contents
	      + ((offset + addend) / sec->entsize) * sec->entsize;
d832 1
a832 2
      p = secinfo->contents
	  + ((offset + addend) / sec->entsize) * sec->entsize;
d846 2
a847 3
      p = secinfo->contents
	  + ((offset + addend) / sec->entsize + 1) * sec->entsize
	  - entry->len;
@


1.18.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d93 1
a93 1
  struct sec_merge_hash_entry *first_str;
d105 2
d109 4
a112 3
  if (entry == NULL)
    entry = bfd_hash_allocate (table, sizeof (struct sec_merge_hash_entry));
  if (entry == NULL)
d116 2
a117 1
  entry = bfd_hash_newfunc (entry, table, string);
d119 1
a119 1
  if (entry != NULL)
a121 2
      struct sec_merge_hash_entry *ret = (struct sec_merge_hash_entry *) entry;

d128 1
a128 1
  return entry;
d195 1
a195 1
       hashp != NULL;
d219 1
a219 1
    return NULL;
d221 5
a225 4
  hashp = ((struct sec_merge_hash_entry *)
	   sec_merge_hash_newfunc (NULL, &table->table, string));
  if (hashp == NULL)
    return NULL;
d242 1
d244 1
a244 1
  table = bfd_malloc (sizeof (struct sec_merge_hash));
d297 1
a297 1
  int alignment_power = sec->output_section->alignment_power;
d311 1
a311 1
	  if (bfd_bwrite (pad, len, abfd) != len)
d319 1
a319 1
      if (bfd_bwrite (str, len, abfd) != len)
d331 2
a332 2
/* Register a SEC_MERGE section as a candidate for merging.
   This function is called for all non-dynamic SEC_MERGE input sections.  */
d335 1
a335 2
_bfd_add_merge_section (bfd *abfd, void **psinfo, asection *sec,
			void **psecinfo)
d342 3
a344 6
  if ((abfd->flags & DYNAMIC) != 0
      || (sec->flags & SEC_MERGE) == 0)
    abort ();

  if (sec->size == 0
      || (sec->flags & SEC_EXCLUDE) != 0
d354 2
a355 2
  align = sec->alignment_power;
  if ((sec->entsize < (unsigned) 1 << align
d358 2
a359 2
      || (sec->entsize > (unsigned) 1 << align
	  && (sec->entsize & (((unsigned) 1 << align) - 1))))
d374 1
a374 2
	&& secinfo->sec->alignment_power == sec->alignment_power
	&& secinfo->sec->output_section == sec->output_section)
d380 2
a381 1
      sinfo = bfd_alloc (abfd, sizeof (struct sec_merge_info));
d394 1
a394 1
  amt = sizeof (struct sec_merge_sec_info) + sec->size - 1;
d399 1
a399 1
  secinfo = (struct sec_merge_sec_info *) *psecinfo;
d411 1
a411 1
  secinfo->first_str = NULL;
a412 1
  sec->rawsize = sec->size;
d414 1
a414 1
				  0, sec->size))
d436 2
a437 2
  align = sec->alignment_power;
  end = secinfo->contents + sec->size;
d583 1
a583 1
  array = bfd_malloc (amt);
d641 1
a641 1
	  secinfo->sec->size = size;
d646 1
a646 1
	  if (e->secinfo->first_str == NULL)
d648 1
a648 1
	      e->secinfo->first_str = e;
d656 1
a656 1
  secinfo->sec->size = size;
d679 2
a680 2
_bfd_merge_sections (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info,
		     void *xsinfo, void (*remove_hook) (bfd *, asection *))
d725 1
a725 1
	      if (e->secinfo->first_str == NULL)
d728 2
a729 2
		    secinfo->sec->size = size;
		  e->secinfo->first_str = e;
d738 1
a738 1
	  secinfo->sec->size = size;
d744 5
a748 2
	  if (secinfo->first_str == NULL)
	    _bfd_strip_section_from_output (info, secinfo->sec);
d764 1
a764 1
  if (secinfo->first_str == NULL)
d771 1
a771 1
  if (! sec_merge_emit (output_bfd, secinfo->first_str))
d783 1
a783 1
			    void *psecinfo, bfd_vma offset)
d792 1
a792 1
  if (offset >= sec->rawsize)
d794 1
a794 1
      if (offset > sec->rawsize)
d797 2
a798 2
	    (_("%s: access beyond end of merged section (%ld)"),
	     bfd_get_filename (sec->owner), (long) offset);
d800 1
a800 1
      return secinfo->first_str ? sec->size : 0;
d807 1
a807 1
	  p = secinfo->contents + offset - 1;
d814 2
a815 1
	  p = secinfo->contents + (offset / sec->entsize) * sec->entsize;
d833 2
a834 1
      p = secinfo->contents + (offset / sec->entsize) * sec->entsize;
d848 3
a850 2
      p = (secinfo->contents + (offset / sec->entsize + 1) * sec->entsize
	   - entry->len);
@


1.17
log
@Set SEC_EXCLUDE flag on sections which become empty after merging.
@
text
@d37 1
a37 1
  /* Length of this entry.  */
a45 2
    /* Entity size (if present in suffix hash tables).  */
    unsigned int entsize;
d206 6
a211 3
	      /*  Mark the less aligned copy as deleted.  */
	      hashp->len = 0;
	      hashp->alignment = 0;
d291 1
a291 1
sec_merge_emit (register bfd *abfd, struct sec_merge_hash_entry *entry)
a423 73
/* Compare two sec_merge_hash_entry structures.  This is called via qsort.  */

static int
cmplengthentry (const void *a, const void *b)
{
  struct sec_merge_hash_entry * A = *(struct sec_merge_hash_entry **) a;
  struct sec_merge_hash_entry * B = *(struct sec_merge_hash_entry **) b;

  if (A->len < B->len)
    return 1;
  else if (A->len > B->len)
    return -1;

  return memcmp (A->root.string, B->root.string, A->len);
}

static int
last4_eq (const void *a, const void *b)
{
  struct sec_merge_hash_entry * A = (struct sec_merge_hash_entry *) a;
  struct sec_merge_hash_entry * B = (struct sec_merge_hash_entry *) b;

  if (memcmp (A->root.string + A->len - 5 * A->u.entsize,
	      B->root.string + B->len - 5 * A->u.entsize,
	      4 * A->u.entsize) != 0)
    /* This was a hashtable collision.  */
    return 0;

  if (A->len <= B->len)
    /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
       not to be equal by the hash table.  */
    return 0;

  if (A->alignment < B->alignment
      || ((A->len - B->len) & (B->alignment - 1)))
    /* The suffix is not sufficiently aligned.  */
    return 0;

  return memcmp (A->root.string + (A->len - B->len),
		 B->root.string, B->len - 5 * A->u.entsize) == 0;
}

static int
last_eq (const void *a, const void *b)
{
  struct sec_merge_hash_entry * A = (struct sec_merge_hash_entry *) a;
  struct sec_merge_hash_entry * B = (struct sec_merge_hash_entry *) b;

  if (B->len >= 5 * A->u.entsize)
    /* Longer strings are just pushed into the hash table,
       they'll be used when looking up for very short strings.  */
    return 0;

  if (memcmp (A->root.string + A->len - 2 * A->u.entsize,
	      B->root.string + B->len - 2 * A->u.entsize,
	      A->u.entsize) != 0)
    /* This was a hashtable collision.  */
    return 0;

  if (A->len <= B->len)
    /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
       not to be equal by the hash table.  */
    return 0;

  if (A->alignment < B->alignment
      || ((A->len - B->len) & (B->alignment - 1)))
    /* The suffix is not sufficiently aligned.  */
    return 0;

  return memcmp (A->root.string + (A->len - B->len),
		 B->root.string, B->len - 2 * A->u.entsize) == 0;
}

d465 1
a465 1
	        }
d507 64
d576 1
a576 1
  struct sec_merge_hash_entry **array, **a, **end, *e;
a577 1
  htab_t lasttab = NULL, last4tab = NULL;
d579 1
d581 1
a581 2
  /* Now sort the strings by length, longest first.  */
  array = NULL;
d589 12
a600 1
      *a++ = e;
d603 13
d617 4
a620 39
  qsort (array, (size_t) sinfo->htab->size,
	 sizeof (struct sec_merge_hash_entry *), cmplengthentry);

  last4tab = htab_create_alloc ((size_t) sinfo->htab->size * 4,
				NULL, last4_eq, NULL, calloc, free);
  lasttab = htab_create_alloc ((size_t) sinfo->htab->size * 4,
			       NULL, last_eq, NULL, calloc, free);
  if (lasttab == NULL || last4tab == NULL)
    goto alloc_failure;

  /* Now insert the strings into hash tables (strings with last 4 characters
     and strings with last character equal), look for longer strings which
     we're suffix of.  */
  for (a = array, end = array + sinfo->htab->size; a < end; a++)
    {
      register hashval_t hash;
      unsigned int c;
      unsigned int i;
      const unsigned char *s;
      void **p;

      e = *a;
      e->u.entsize = sinfo->htab->entsize;
      if (e->len <= e->u.entsize)
	break;
      if (e->len > 4 * e->u.entsize)
	{
	  s = (const unsigned char *) (e->root.string + e->len - e->u.entsize);
	  hash = 0;
	  for (i = 0; i < 4 * e->u.entsize; i++)
	    {
	      c = *--s;
	      hash += c + (c << 17);
	      hash ^= hash >> 2;
	    }
	  p = htab_find_slot_with_hash (last4tab, e, hash, INSERT);
	  if (p == NULL)
	    goto alloc_failure;
	  if (*p)
d622 2
a623 6
	      struct sec_merge_hash_entry *ent;

	      ent = (struct sec_merge_hash_entry *) *p;
	      e->u.suffix = ent;
	      e->alignment = 0;
	      continue;
d626 1
a626 9
	    *p = e;
	}
      s = (const unsigned char *) (e->root.string + e->len - e->u.entsize);
      hash = 0;
      for (i = 0; i < e->u.entsize; i++)
	{
	  c = *--s;
	  hash += c + (c << 17);
	  hash ^= hash >> 2;
a627 13
      p = htab_find_slot_with_hash (lasttab, e, hash, INSERT);
      if (p == NULL)
	goto alloc_failure;
      if (*p)
	{
	  struct sec_merge_hash_entry *ent;

	  ent = (struct sec_merge_hash_entry *) *p;
	  e->u.suffix = ent;
	  e->alignment = 0;
	}
      else
	*p = e;
a632 4
  if (lasttab)
    htab_delete (lasttab);
  if (last4tab)
    htab_delete (last4tab);
@


1.16
log
@	* merge.c: Update to ISO C90.
@
text
@d790 1
a790 1
	/* Finally shrink all input sections which have not made it into
d794 4
a797 1
	    secinfo->sec->_cooked_size = 0;
@


1.15
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d91 1
a91 1
  PTR *psecinfo;
a99 21
static struct bfd_hash_entry *sec_merge_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct sec_merge_hash_entry *sec_merge_hash_lookup
  PARAMS ((struct sec_merge_hash *, const char *, unsigned int, bfd_boolean));
static struct sec_merge_hash *sec_merge_init
  PARAMS ((unsigned int, bfd_boolean));
static struct sec_merge_hash_entry *sec_merge_add
  PARAMS ((struct sec_merge_hash *, const char *, unsigned int,
	   struct sec_merge_sec_info *));
static bfd_boolean sec_merge_emit
  PARAMS ((bfd *, struct sec_merge_hash_entry *));
static int cmplengthentry
  PARAMS ((const PTR, const PTR));
static int last4_eq
  PARAMS ((const PTR, const PTR));
static int last_eq
  PARAMS ((const PTR, const PTR));
static bfd_boolean record_section
  PARAMS ((struct sec_merge_info *, struct sec_merge_sec_info *));
static void merge_strings
  PARAMS ((struct sec_merge_info *));
d104 2
a105 4
sec_merge_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d136 2
a137 5
sec_merge_hash_lookup (table, string, alignment, create)
     struct sec_merge_hash *table;
     const char *string;
     unsigned int alignment;
     bfd_boolean create;
d238 1
a238 3
sec_merge_init (entsize, strings)
     unsigned int entsize;
     bfd_boolean strings;
d266 2
a267 5
sec_merge_add (tab, str, alignment, secinfo)
     struct sec_merge_hash *tab;
     const char *str;
     unsigned int alignment;
     struct sec_merge_sec_info *secinfo;
d290 1
a290 3
sec_merge_emit (abfd, entry)
     register bfd *abfd;
     struct sec_merge_hash_entry *entry;
d310 1
a310 1
	  if (bfd_bwrite ((PTR) pad, (bfd_size_type) len, abfd) != len)
d318 1
a318 1
      if (bfd_bwrite ((PTR) str, (bfd_size_type) len, abfd) != len)
d334 1
a334 5
_bfd_merge_section (abfd, psinfo, sec, psecinfo)
     bfd *abfd;
     PTR *psinfo;
     asection *sec;
     PTR *psecinfo;
d385 1
a385 1
      *psinfo = (PTR) sinfo;
d426 1
a426 3
cmplengthentry (a, b)
     const PTR a;
     const PTR b;
d440 1
a440 3
last4_eq (a, b)
     const PTR a;
     const PTR b;
d466 1
a466 3
last_eq (a, b)
     const PTR a;
     const PTR b;
d498 2
a499 3
record_section (sinfo, secinfo)
     struct sec_merge_info *sinfo;
     struct sec_merge_sec_info *secinfo;
d582 1
a582 2
merge_strings (sinfo)
     struct sec_merge_info *sinfo;
d621 1
a621 1
      PTR *p;
d650 1
a650 1
	    *p = (PTR) e;
d672 1
a672 1
	*p = (PTR) e;
d728 2
a729 4
_bfd_merge_sections (abfd, xsinfo, remove_hook)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR xsinfo;
     void (*remove_hook) PARAMS((bfd *, asection *));
d793 1
a793 1
  	  if (secinfo->first == NULL)
d803 1
a803 4
_bfd_write_merged_section (output_bfd, sec, psecinfo)
     bfd *output_bfd;
     asection *sec;
     PTR psecinfo;
d828 2
a829 5
_bfd_merged_section_offset (output_bfd, psec, psecinfo, offset, addend)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     asection **psec;
     PTR psecinfo;
     bfd_vma offset, addend;
@


1.14
log
@	* aoutx.h (NAME(aout,swap_ext_reloc_in)): Cast bytes->r_index to
	unsigned int.  Cast RELOC_BASE10, RELOC_BASE13 and RELOC_BASE22 to
	unsigned int.
	(NAME(aout,final_link)): Cast enum used in assignment.
	(aout_link_write_symbols): Cast enums in comparisons, int values to
	boolean, enums in assignments to int.
	(aout_link_input_section_std): Cast rel->r_index to unsigned int.
	(aout_link_input_section_ext): Likewise.  Cast enums used in comparisons
	with unsigned ints.
	(aout_link_reloc_link_order): Cast enum to int in assignment.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Cast result of memchr
	calls to char *.
	* bfd-in.h (bfd_set_section_vma): Cast enum true to unsigned int in
	assignment.
	* bfd-in2.h (bfd_set_section_vma): Likewise.
	* bfd.c (bfd_record_phdr): Cast enums in assignments.
	* binary.c (bfd_alloc): Cast enum to long.
	* coffgen.c (_bfd_coff_is_local_label_name): Cast return to boolean.
	* dwarf2.c (read_abbrevs): Add casts to enum types.
	(read_attribute_value): Likewise.
	(arange_add): Cast result of bfd_zalloc call.
	(comp_unit_contains_address): Return true and false.
	(comp_unit_find_nearest_line): Cast return to boolean.
	* format.c (bfd_check_format_matches, bfd_set_format): Likewise.
	* gen-aout.c: define macro '_' if not defined.
	* libbfd.c (bfd_realloc): Cast malloc and realloc to PTR.
	(bfd_bwrite): Cast bfd_realloc to bfd_byte *.
	(bfd_write_bigendian_4byte_int): Cast return to boolean.
	(bfd_seek): Cast bfd_realloc to bfd_byte *.
	(bfd_generic_is_local_label_name): Cast return to boolean.
	* libcoff.h (_bfd_coff_adjust_symndx): Remove extraneous '\'.
	* linker.c (_bfd_link_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(_bfd_generic_link_hash_newfunc): likewise.
	(_bfd_generic_final_link): Cast enum to unsigned int.
	* merge.c (sec_merge_emit): Cast return to boolean.
	(merge_strings): Add casts to const unsigned char *.
	* reloc.c (bfd_get_reloc_code_name): Cast enums in comparison to int.
	(bfd_generic_get_relocated_section_content): Cast enum to unsigned int.
	* section.c (bfd_section_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(bfd_set_section_content): Add cast to PTR in comparison.
	* simple.c (simple_dummy_warning, simple_dummy_undefined_symbol,
	simple_dummy_reloc_overflow, simple_dummy_reloc_dangerous,
	simple_dummy_unattached_reloc,
	bfd_simple_get_relocated_section_contents): Add K&R declarations and
	function definitions.
	* srec.c (S3Forced): Initialize to false.
	(srec_get_symtab): Cast return value from bfd_alloc to asymbol *.
	* stabs.c (_bfd_link_section_stabs): Cast enum to int in comparisons.
	(_bfd_discard_section_stabs): Likewise.  Also cast return to boolean.
	* syms.c (bfd_is_undefined_symclass): Cast return to boolean.
	(_bfd_stab_section_find_nearest_line): Cast enum to bfd_byte in
	comparisons.
@
text
@d71 1
a71 1
  boolean strings;
d103 1
a103 1
  PARAMS ((struct sec_merge_hash *, const char *, unsigned int, boolean));
d105 1
a105 1
  PARAMS ((unsigned int, boolean));
d109 1
a109 1
static boolean sec_merge_emit
d111 7
a117 4
static int cmplengthentry PARAMS ((const PTR, const PTR));
static int last4_eq PARAMS ((const PTR, const PTR));
static int last_eq PARAMS ((const PTR, const PTR));
static boolean record_section
d119 2
a120 1
static void merge_strings PARAMS ((struct sec_merge_info *));
d163 1
a163 1
     boolean create;
d266 1
a266 1
     boolean strings;
d302 1
a302 1
  entry = sec_merge_hash_lookup (tab, str, alignment, true);
d320 1
a320 1
static boolean
d360 1
a360 1
  return (boolean) (entry == NULL || entry->secinfo != secinfo);
d366 1
a366 1
boolean
d382 1
a382 1
    return true;
d387 1
a387 1
      return true;
d403 1
a403 1
      return true;
d453 1
a453 1
  return true;
d457 1
a457 1
  return false;
d540 1
a540 1
static boolean
d547 1
a547 1
  boolean nul;
d554 1
a554 1
  nul = false;
d574 1
a574 1
		      nul = true;
d594 1
a594 1
		      nul = true;
d615 1
a615 1
  return true;
d620 1
a620 1
  return false;
d650 1
a650 1
  last4tab = htab_create_alloc ((size_t) sinfo->htab->size * 4, 
d652 1
a652 1
  lasttab = htab_create_alloc ((size_t) sinfo->htab->size * 4, 
d772 1
a772 1
boolean
d844 1
a844 1
  return true;
d849 1
a849 1
boolean
d861 1
a861 1
    return true;
d865 1
a865 1
    return false;
d868 1
a868 1
    return false;
d870 1
a870 1
  return true;
d935 1
a935 1
  entry = sec_merge_hash_lookup (secinfo->htab, p, 0, false);
@


1.13
log
@	* merge.c (_bfd_merge_section): Remove redundant output_section check.
	Formatting.
	(_bfd_merge_sections): Don't set SEC_EXCLUDE on unused sections.
@
text
@d356 1
a356 1
  return entry == NULL || entry->secinfo != secinfo;
d670 1
a670 1
	  s = e->root.string + e->len - e->u.entsize;
d693 1
a693 1
      s = e->root.string + e->len - e->u.entsize;
@


1.13.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d37 1
a37 1
  /* Length of this entry.  This includes the zero terminator.  */
d46 2
d71 1
a71 1
  bfd_boolean strings;
d91 1
a91 1
  void **psecinfo;
d100 17
d121 4
a124 2
sec_merge_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table, const char *string)
d155 5
a159 2
sec_merge_hash_lookup (struct sec_merge_hash *table, const char *string,
		       unsigned int alignment, bfd_boolean create)
d230 3
a232 6
	      if (create)
		{
		  /*  Mark the less aligned copy as deleted.  */
		  hashp->len = 0;
		  hashp->alignment = 0;
		}
d260 3
a262 1
sec_merge_init (unsigned int entsize, bfd_boolean strings)
d290 5
a294 2
sec_merge_add (struct sec_merge_hash *tab, const char *str,
	       unsigned int alignment, struct sec_merge_sec_info *secinfo)
d298 1
a298 1
  entry = sec_merge_hash_lookup (tab, str, alignment, TRUE);
d316 4
a319 2
static bfd_boolean
sec_merge_emit (bfd *abfd, struct sec_merge_hash_entry *entry)
d339 1
a339 1
	  if (bfd_bwrite (pad, (bfd_size_type) len, abfd) != len)
d347 1
a347 1
      if (bfd_bwrite (str, (bfd_size_type) len, abfd) != len)
d362 6
a367 2
bfd_boolean
_bfd_merge_section (bfd *abfd, void **psinfo, asection *sec, void **psecinfo)
d378 1
a378 1
    return TRUE;
d383 1
a383 1
      return TRUE;
d399 1
a399 1
      return TRUE;
d418 1
a418 1
      *psinfo = sinfo;
d449 1
a449 1
  return TRUE;
d453 80
a532 1
  return FALSE;
d536 4
a539 3
static bfd_boolean
record_section (struct sec_merge_info *sinfo,
		struct sec_merge_sec_info *secinfo)
d543 1
a543 1
  bfd_boolean nul;
d550 1
a550 1
  nul = FALSE;
d570 1
a570 1
		      nul = TRUE;
d577 1
a577 1
		}
d590 1
a590 1
		      nul = TRUE;
d611 1
a611 1
  return TRUE;
d616 1
a616 65
  return FALSE;
}

static int
strrevcmp (const void *a, const void *b)
{
  struct sec_merge_hash_entry *A = *(struct sec_merge_hash_entry **) a;
  struct sec_merge_hash_entry *B = *(struct sec_merge_hash_entry **) b;
  unsigned int lenA = A->len;
  unsigned int lenB = B->len;
  const unsigned char *s = A->root.string + lenA - 1;
  const unsigned char *t = B->root.string + lenB - 1;
  int l = lenA < lenB ? lenA : lenB;

  while (l)
    {
      if (*s != *t)
	return (int) *s - (int) *t;
      s--;
      t--;
      l--;
    }
  return lenA - lenB;
}

/* Like strrevcmp, but for the case where all strings have the same
   alignment > entsize.  */

static int
strrevcmp_align (const void *a, const void *b)
{
  struct sec_merge_hash_entry *A = *(struct sec_merge_hash_entry **) a;
  struct sec_merge_hash_entry *B = *(struct sec_merge_hash_entry **) b;
  unsigned int lenA = A->len;
  unsigned int lenB = B->len;
  const unsigned char *s = A->root.string + lenA - 1;
  const unsigned char *t = B->root.string + lenB - 1;
  int l = lenA < lenB ? lenA : lenB;
  int tail_align = (lenA & (A->alignment - 1)) - (lenB & (A->alignment - 1));

  if (tail_align != 0)
    return tail_align;

  while (l)
    {
      if (*s != *t)
	return (int) *s - (int) *t;
      s--;
      t--;
      l--;
    }
  return lenA - lenB;
}

static inline int
is_suffix (const struct sec_merge_hash_entry *A,
	   const struct sec_merge_hash_entry *B)
{
  if (A->len <= B->len)
    /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
       not to be equal by the hash table.  */
    return 0;

  return memcmp (A->root.string + (A->len - B->len),
		 B->root.string, B->len) == 0;
d622 2
a623 1
merge_strings (struct sec_merge_info *sinfo)
d625 1
a625 1
  struct sec_merge_hash_entry **array, **a, *e;
d627 1
a628 1
  unsigned int alignment = 0;
d630 2
a631 1
  /* Now sort the strings */
d639 1
a639 12
      {
	*a++ = e;
	/* Adjust the length to not include the zero terminator.  */
	e->len -= sinfo->htab->entsize;
	if (alignment != e->alignment)
	  {
	    if (alignment == 0)
	      alignment = e->alignment;
	    else
	      alignment = (unsigned) -1;
	  }
      }
d642 31
a672 18
  if (sinfo->htab->size != 0)
    {
      qsort (array, (size_t) sinfo->htab->size,
	     sizeof (struct sec_merge_hash_entry *),
	     (alignment != (unsigned) -1 && alignment > sinfo->htab->entsize
	      ? strrevcmp_align : strrevcmp));

      /* Loop over the sorted array and merge suffixes */
      e = *--a;
      e->len += sinfo->htab->entsize;
      while (--a >= array)
	{
	  struct sec_merge_hash_entry *cmp = *a;

	  cmp->len += sinfo->htab->entsize;
	  if (e->alignment >= cmp->alignment
	      && !((e->len - cmp->len) & (cmp->alignment - 1))
	      && is_suffix (e, cmp))
d674 15
a688 2
	      cmp->u.suffix = e;
	      cmp->alignment = 0;
d691 9
a699 1
	    e = cmp;
d701 13
d719 4
d768 5
a772 3
bfd_boolean
_bfd_merge_sections (bfd *abfd ATTRIBUTE_UNUSED, void *xsinfo,
		     void (*remove_hook) (bfd *, asection *))
d833 1
a833 1
	/* Finally remove all input sections which have not made it into
d836 2
a837 5
	  if (secinfo->first == NULL)
	    {
	      secinfo->sec->_cooked_size = 0;
	      secinfo->sec->flags |= SEC_EXCLUDE;
	    }
d840 1
a840 1
  return TRUE;
d845 5
a849 2
bfd_boolean
_bfd_write_merged_section (bfd *output_bfd, asection *sec, void *psecinfo)
d857 1
a857 1
    return TRUE;
d861 1
a861 1
    return FALSE;
d864 1
a864 1
    return FALSE;
d866 1
a866 1
  return TRUE;
d874 5
a878 2
_bfd_merged_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED, asection **psec,
			    void *psecinfo, bfd_vma offset, bfd_vma addend)
d931 1
a931 1
  entry = sec_merge_hash_lookup (secinfo->htab, p, 0, FALSE);
@


1.13.2.1
log
@Merge from mainline.
@
text
@d356 1
a356 1
  return (boolean) (entry == NULL || entry->secinfo != secinfo);
d670 1
a670 1
	  s = (const unsigned char *) (e->root.string + e->len - e->u.entsize);
d693 1
a693 1
      s = (const unsigned char *) (e->root.string + e->len - e->u.entsize);
@


1.13.12.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d356 1
a356 1
  return (boolean) (entry == NULL || entry->secinfo != secinfo);
d670 1
a670 1
	  s = (const unsigned char *) (e->root.string + e->len - e->u.entsize);
d693 1
a693 1
      s = (const unsigned char *) (e->root.string + e->len - e->u.entsize);
@


1.13.12.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d71 1
a71 1
  bfd_boolean strings;
d103 1
a103 1
  PARAMS ((struct sec_merge_hash *, const char *, unsigned int, bfd_boolean));
d105 1
a105 1
  PARAMS ((unsigned int, bfd_boolean));
d109 1
a109 1
static bfd_boolean sec_merge_emit
d111 4
a114 7
static int cmplengthentry
  PARAMS ((const PTR, const PTR));
static int last4_eq
  PARAMS ((const PTR, const PTR));
static int last_eq
  PARAMS ((const PTR, const PTR));
static bfd_boolean record_section
d116 1
a116 2
static void merge_strings
  PARAMS ((struct sec_merge_info *));
d159 1
a159 1
     bfd_boolean create;
d262 1
a262 1
     bfd_boolean strings;
d298 1
a298 1
  entry = sec_merge_hash_lookup (tab, str, alignment, TRUE);
d316 1
a316 1
static bfd_boolean
d356 1
a356 1
  return entry == NULL || entry->secinfo != secinfo;
d362 1
a362 1
bfd_boolean
d378 1
a378 1
    return TRUE;
d383 1
a383 1
      return TRUE;
d399 1
a399 1
      return TRUE;
d449 1
a449 1
  return TRUE;
d453 1
a453 1
  return FALSE;
d536 1
a536 1
static bfd_boolean
d543 1
a543 1
  bfd_boolean nul;
d550 1
a550 1
  nul = FALSE;
d570 1
a570 1
		      nul = TRUE;
d590 1
a590 1
		      nul = TRUE;
d611 1
a611 1
  return TRUE;
d616 1
a616 1
  return FALSE;
d646 1
a646 1
  last4tab = htab_create_alloc ((size_t) sinfo->htab->size * 4,
d648 1
a648 1
  lasttab = htab_create_alloc ((size_t) sinfo->htab->size * 4,
d768 1
a768 1
bfd_boolean
d840 1
a840 1
  return TRUE;
d845 1
a845 1
bfd_boolean
d857 1
a857 1
    return TRUE;
d861 1
a861 1
    return FALSE;
d864 1
a864 1
    return FALSE;
d866 1
a866 1
  return TRUE;
d931 1
a931 1
  entry = sec_merge_hash_lookup (secinfo->htab, p, 0, FALSE);
@


1.13.12.3
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d91 1
a91 1
  void **psecinfo;
d100 21
d125 4
a128 2
sec_merge_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table, const char *string)
d159 5
a163 2
sec_merge_hash_lookup (struct sec_merge_hash *table, const char *string,
		       unsigned int alignment, bfd_boolean create)
d264 3
a266 1
sec_merge_init (unsigned int entsize, bfd_boolean strings)
d294 5
a298 2
sec_merge_add (struct sec_merge_hash *tab, const char *str,
	       unsigned int alignment, struct sec_merge_sec_info *secinfo)
d321 3
a323 1
sec_merge_emit (register bfd *abfd, struct sec_merge_hash_entry *entry)
d343 1
a343 1
	  if (bfd_bwrite (pad, (bfd_size_type) len, abfd) != len)
d351 1
a351 1
      if (bfd_bwrite (str, (bfd_size_type) len, abfd) != len)
d367 5
a371 1
_bfd_merge_section (bfd *abfd, void **psinfo, asection *sec, void **psecinfo)
d422 1
a422 1
      *psinfo = sinfo;
d463 3
a465 1
cmplengthentry (const void *a, const void *b)
d479 3
a481 1
last4_eq (const void *a, const void *b)
d507 3
a509 1
last_eq (const void *a, const void *b)
d541 3
a543 2
record_section (struct sec_merge_info *sinfo,
		struct sec_merge_sec_info *secinfo)
d626 2
a627 1
merge_strings (struct sec_merge_info *sinfo)
d666 1
a666 1
      void **p;
d695 1
a695 1
	    *p = e;
d717 1
a717 1
	*p = e;
d773 4
a776 2
_bfd_merge_sections (bfd *abfd ATTRIBUTE_UNUSED, void *xsinfo,
		     void (*remove_hook) (bfd *, asection *))
d840 1
a840 1
	  if (secinfo->first == NULL)
d850 4
a853 1
_bfd_write_merged_section (bfd *output_bfd, asection *sec, void *psecinfo)
d878 5
a882 2
_bfd_merged_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED, asection **psec,
			    void *psecinfo, bfd_vma offset, bfd_vma addend)
@


1.13.12.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d37 1
a37 1
  /* Length of this entry.  This includes the zero terminator.  */
d46 2
d208 3
a210 6
	      if (create)
		{
		  /*  Mark the less aligned copy as deleted.  */
		  hashp->len = 0;
		  hashp->alignment = 0;
		}
d290 1
a290 1
sec_merge_emit (bfd *abfd, struct sec_merge_hash_entry *entry)
d423 73
d537 1
a537 1
		}
a578 64
static int
strrevcmp (const void *a, const void *b)
{
  struct sec_merge_hash_entry *A = *(struct sec_merge_hash_entry **) a;
  struct sec_merge_hash_entry *B = *(struct sec_merge_hash_entry **) b;
  unsigned int lenA = A->len;
  unsigned int lenB = B->len;
  const unsigned char *s = A->root.string + lenA - 1;
  const unsigned char *t = B->root.string + lenB - 1;
  int l = lenA < lenB ? lenA : lenB;

  while (l)
    {
      if (*s != *t)
	return (int) *s - (int) *t;
      s--;
      t--;
      l--;
    }
  return lenA - lenB;
}

/* Like strrevcmp, but for the case where all strings have the same
   alignment > entsize.  */

static int
strrevcmp_align (const void *a, const void *b)
{
  struct sec_merge_hash_entry *A = *(struct sec_merge_hash_entry **) a;
  struct sec_merge_hash_entry *B = *(struct sec_merge_hash_entry **) b;
  unsigned int lenA = A->len;
  unsigned int lenB = B->len;
  const unsigned char *s = A->root.string + lenA - 1;
  const unsigned char *t = B->root.string + lenB - 1;
  int l = lenA < lenB ? lenA : lenB;
  int tail_align = (lenA & (A->alignment - 1)) - (lenB & (A->alignment - 1));

  if (tail_align != 0)
    return tail_align;

  while (l)
    {
      if (*s != *t)
	return (int) *s - (int) *t;
      s--;
      t--;
      l--;
    }
  return lenA - lenB;
}

static inline int
is_suffix (const struct sec_merge_hash_entry *A,
	   const struct sec_merge_hash_entry *B)
{
  if (A->len <= B->len)
    /* B cannot be a suffix of A unless A is equal to B, which is guaranteed
       not to be equal by the hash table.  */
    return 0;

  return memcmp (A->root.string + (A->len - B->len),
		 B->root.string, B->len) == 0;
}

d584 1
a584 1
  struct sec_merge_hash_entry **array, **a, *e;
d586 1
a587 1
  unsigned int alignment = 0;
d589 2
a590 1
  /* Now sort the strings */
d598 1
a598 12
      {
	*a++ = e;
	/* Adjust the length to not include the zero terminator.  */
	e->len -= sinfo->htab->entsize;
	if (alignment != e->alignment)
	  {
	    if (alignment == 0)
	      alignment = e->alignment;
	    else
	      alignment = (unsigned) -1;
	  }
      }
d601 40
a640 18
  if (sinfo->htab->size != 0)
    {
      qsort (array, (size_t) sinfo->htab->size,
	     sizeof (struct sec_merge_hash_entry *),
	     (alignment != (unsigned) -1 && alignment > sinfo->htab->entsize
	      ? strrevcmp_align : strrevcmp));

      /* Loop over the sorted array and merge suffixes */
      e = *--a;
      e->len += sinfo->htab->entsize;
      while (--a >= array)
	{
	  struct sec_merge_hash_entry *cmp = *a;

	  cmp->len += sinfo->htab->entsize;
	  if (e->alignment >= cmp->alignment
	      && !((e->len - cmp->len) & (cmp->alignment - 1))
	      && is_suffix (e, cmp))
d642 6
a647 2
	      cmp->u.suffix = e;
	      cmp->alignment = 0;
d650 20
a669 1
	    e = cmp;
d671 2
d678 4
d790 1
a790 1
	/* Finally remove all input sections which have not made it into
d794 1
a794 4
	    {
	      secinfo->sec->_cooked_size = 0;
	      secinfo->sec->flags |= SEC_EXCLUDE;
	    }
@


1.12
log
@	* merge.c (_bfd_merged_section_offset): Avoid accessing byte before
	section content start.
	Reported by Michael Schumacher <mike@@hightec-rt.com>.
@
text
@a385 8
  if (sec->output_section != NULL
      && bfd_is_abs_section (sec->output_section))
    {
      /* The section is being discarded from the link, so we should
	 just ignore it.  */
      return true;
    }

d412 2
a413 2
      sinfo = (struct sec_merge_info *)
	      bfd_alloc (abfd, (bfd_size_type) sizeof (struct sec_merge_info));
d419 1
a419 2
      sinfo->htab =
	sec_merge_init (sec->entsize, (sec->flags & SEC_STRINGS));
d837 1
a837 4
	    {
	      secinfo->sec->_cooked_size = 0;
	      secinfo->sec->flags |= SEC_EXCLUDE;
	    }
@


1.11
log
@Use htab_create_alloc with calloc, not htab_alloc.
@
text
@d915 1
a915 1
	  while (*p && p >= secinfo->contents)
@


1.10
log
@Include libiberty.h
@
text
@d655 4
a658 2
  last4tab = htab_create ((size_t) sinfo->htab->size * 4, NULL, last4_eq, NULL);
  lasttab = htab_create ((size_t) sinfo->htab->size * 4, NULL, last_eq, NULL);
@


1.9
log
@	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.
@
text
@d2 1
a2 1
   Copyright 2001 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 1
d42 2
a43 1
  union {
d149 1
a149 1
  return (struct bfd_hash_entry *)ret;
@


1.9.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a27 1
#include "libiberty.h"
d41 1
a41 2
  union
  {
d147 1
a147 1
  return (struct bfd_hash_entry *) ret;
d653 2
a654 4
  last4tab = htab_create_alloc ((size_t) sinfo->htab->size * 4, 
				NULL, last4_eq, NULL, calloc, free);
  lasttab = htab_create_alloc ((size_t) sinfo->htab->size * 4, 
			       NULL, last_eq, NULL, calloc, free);
@


1.9.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d386 8
d420 2
a421 2
      amt = sizeof (struct sec_merge_info);
      sinfo = (struct sec_merge_info *) bfd_alloc (abfd, amt);
d427 2
a428 1
      sinfo->htab = sec_merge_init (sec->entsize, (sec->flags & SEC_STRINGS));
d846 4
a849 1
	    secinfo->sec->_cooked_size = 0;
d915 1
a915 1
	  while (p >= secinfo->contents && *p)
@


1.9.6.3
log
@merge from mainline
@
text
@d356 1
a356 1
  return (boolean) (entry == NULL || entry->secinfo != secinfo);
d670 1
a670 1
	  s = (const unsigned char *) (e->root.string + e->len - e->u.entsize);
d693 1
a693 1
      s = (const unsigned char *) (e->root.string + e->len - e->u.entsize);
@


1.9.4.1
log
@merge from trunk
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a27 1
#include "libiberty.h"
d41 1
a41 2
  union
  {
d147 1
a147 1
  return (struct bfd_hash_entry *) ret;
d653 2
a654 4
  last4tab = htab_create_alloc ((size_t) sinfo->htab->size * 4, 
				NULL, last4_eq, NULL, calloc, free);
  lasttab = htab_create_alloc ((size_t) sinfo->htab->size * 4, 
			       NULL, last_eq, NULL, calloc, free);
@


1.8
log
@	* elflink.h (elf_link_input_bfd): Back out 2002-01-07 change.
	* elf.c (merge_sections_remove_hook): New function.
	(_bfd_elf_merge_sections): Pass it as 3rd argument to
	_bfd_merge_sections.
	* libbfd-in.h (_bfd_merge_sections): Add 3rd argument.
	* libbfd.h: Rebuilt.
	* merge.c (_bfd_merge_sections): Add remove_hook argument.
	Call remove_hook if a SEC_EXCLUDE section is encountered.
@
text
@d807 3
@


1.8.2.1
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@a806 3
      if (sinfo->htab->first == NULL)
	continue;

@


1.7
log
@	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.

	* aoutx.h: Formatting fixes.
	* merge.c (_bfd_merged_section_offset): Break line at 80 chars.

	* linker.c: Replace bfd_get_filename with bfd_archive_filename
	in error message.
@
text
@d774 1
a774 1
_bfd_merge_sections (abfd, xsinfo)
d777 1
d796 5
a800 1
	  *secinfo->psecinfo = NULL;
@


1.6
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d890 5
a894 3
	(*_bfd_error_handler) (_("%s: access beyond end of merged section (%ld + %ld)"),
			       bfd_get_filename (sec->owner), (long)offset,
			       (long) addend);
@


1.5
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@a28 2
#include <ctype.h>

@


1.4
log
@	* coff-rs6000.c: Add missing prototypes.
	(xcoff_ppc_relocate_section, xcoff_is_lineno_count_overflow,
	xcoff_is_reloc_count_overflow, xcoff_loader_symbol_offset,
	xcoff_loader_reloc_offset): Make static.
	* dwarf1.c: Add missing prototypes.
	* dwarf2.c: Add missing prototypes.
	(struct abbrev_info): Move definition.
	(struct attr_abbrev, ABBREV_HASH_SIZE, ATTR_ALLOC_CHUNK): Likewise.
	* elf.c: Add missing prototypes.
	* elf32-gen.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-ppc.c: Likewise.
	(ppc_elf_sort_rela): Use PTR instead of "void *".
	* elflink.h: Add missing prototypes.  Formatting fixes.
	* merge.c: Add missing prototypes.
	(last4_eq): Use PTR instead of "void *".
	(last_eq): Likewise.
	* syms.c: Add missing prototypes.
@
text
@d205 1
a205 1
    }      
d265 1
d267 1
a267 2
  table = ((struct sec_merge_hash *)
	   bfd_malloc (sizeof (struct sec_merge_hash)));
d328 1
a328 1
    pad = bfd_zmalloc (1 << alignment_power);
d339 1
a339 1
	  if (bfd_write ((PTR) pad, 1, len, abfd) != len)
d347 1
a347 1
      if (bfd_write ((PTR) str, 1, len, abfd) != len)
d372 1
d421 1
a421 1
	      bfd_alloc (abfd, sizeof (struct sec_merge_info));
d435 2
a436 2
  *psecinfo = bfd_alloc (abfd, sizeof (struct sec_merge_sec_info)
			       + sec->_raw_size - 1);
d454 2
a455 2
  if (! bfd_get_section_contents (sec->owner, sec, secinfo->contents, 0,
				  sec->_raw_size))
d474 1
a474 1
              
d560 1
a560 1
  mask = ((bfd_vma)1 << align) - 1;
d563 1
a563 1
      for (p = secinfo->contents; p < end;)
d569 1
a569 1
	  entry = sec_merge_add (sinfo->htab, p, eltalign, secinfo);
d580 2
a581 2
		      entry = sec_merge_add (sinfo->htab, "", mask + 1,
					     secinfo);
d600 2
a601 2
		      entry = sec_merge_add (sinfo->htab, p, mask + 1,
					     secinfo);
d637 1
a637 1
  bfd_size_type size;
d640 3
a642 3
  array = (struct sec_merge_hash_entry **)
	  malloc (sinfo->htab->size
		  * sizeof (struct sec_merge_hash_entry *));
d652 2
a653 2
  qsort (array, sinfo->htab->size, sizeof (struct sec_merge_hash_entry *),
	 cmplengthentry);
d655 2
a656 2
  last4tab = htab_create (sinfo->htab->size * 4, NULL, last4_eq, NULL);
  lasttab = htab_create (sinfo->htab->size * 4, NULL, last_eq, NULL);
d854 1
d861 2
a862 3
  if (bfd_seek (output_bfd,
		(sec->output_section->filepos + sec->output_offset),
		SEEK_SET) != 0)
@


1.3
log
@	* merge.c (struct sec_merge_hash_entry): Add u.entsize and u.suffix
	fields, change sec into secinfo.
	(struct sec_merge_info): Add chain, remove last fields.
	(struct sec_merge_sec_info): Add next, sec, psecinfo fields.
	(sec_merge_hash_lookup): If lookup could not use a string only
	because it has bad alignment, mark the old string for deletion.
	(sec_merge_add): Add secinfo argument. Don't compute entry's
	position, instead record the section.
	(sec_merge_emit): Update for the sec into secinfo change in
	struct sec_merge_hash_entry.
	(_bfd_merge_section): Only record the section for merging, defer
	putting strings into the hash table.
	(cmplengthentry, last4_eq, last_eq, record_section, merge_strings,
	_bfd_merge_sections): New functions.
	(_bfd_merged_section_offset): Update for the sec_merge_hash_entry
	changes.
	* libbfd-in.h (_bfd_merge_sections): Add prototype.
	(_bfd_nolink_bfd_merge_sections): Define.
	* libbfd.h: Likewise.
	(bfd_generic_merge_sections): Add prototype.
	* targets.c (BFD_JUMP_TABLE_LINK): Add _bfd_merge_sections.
	(struct bfd_target): Likewise.
	* bfd.c (bfd_merge_sections): Define.
	* bfd-in2.h: Rebuilt.
	* elf.c (_bfd_elf_merge_sections): New function.
	* elf-bfd.h (_bfd_elf_merge_sections): Add prototype.
	* elfxx-target.h (bfd_elfNN_bfd_merge_sections): Define.
	* reloc.c (bfd_generic_merge_sections): New function.
	* vms.c (vms_bfd_merge_sections): New function.
	* aout-adobe.c (aout_32_bfd_merge_sections): Define.
	* aout-target.h (MY_bfd_merge_sections): Define.
	* aout-tic30.c (MY_bfd_merge_sections): Define.
	* binary.c (binary_bfd_merge_sections): Define.
	* bout.c (b_out_bfd_merge_sections): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_merge_sections): Define.
	* coffcode.c (coff_bfd_merge_sections): Define.
	* coff-mips.c (_bfd_ecoff_bfd_merge_sections): Define.
	* i386msdos.c (msdos_bfd_merge_sections): Define.
	* i386os9k.c (os9k_bfd_merge_sections): Define.
	* ieee.c (ieee_bfd_merge_sections): Define.
	* ihex.c (ihex_bfd_merge_sections): Define.
	* nlm-target.h (nlm_bfd_merge_sections): Define.
	* oasys.c (oasys_bfd_merge_sections): Define.
	* ppcboot.c (ppcboot_bfd_merge_sections): Define.
	* som.c (som_bfd_merge_sections): Define.
	* srec.c (srec_bfd_merge_sections): Define.
	* tekhex.c (tekhex_bfd_merge_sections): Define.
	* versados.c (versados_bfd_merge_sections): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_merge_sections): Define.

	* ldlang.c (lang_process): Call bfd_merge_sections.
@
text
@d111 6
d484 2
a485 1
     const void *a, *b;
d512 2
a513 1
     const void *a, *b;
@


1.2
log
@	* merge.c (struct sec_merge_hash_entry): Add alignment field.
	(struct sec_merge_hash): Remove alignment_power.
	(sec_merge_hash_newfunc): Clear alignment.
	(sec_merge_hash_lookup): Pass alignment as argument.
	Use hashp->root.next, not hashp->next to walk the hash chain.
	If a string already in the hashtable does not have required
	alignment, create a new hashtable entry.
	(sec_merge_init): Remove alignment_power argument.
	(sec_merge_add): Add alignment argument.
	(sec_merge_emit): Alignment is now a per-entity thing, not per
	section.
	(_bfd_merge_section): Sanity check even non-SEC_STRINGS sections
	for proper alignment.
	Pass alignment information to sec_merge_add.
@
text
@d27 1
d31 2
d43 8
a50 2
  /* Index within the merged section.  */
  bfd_size_type index;
d52 1
a52 1
  asection *sec;
d78 2
a81 2
  /* The last section attempted for merge.  */
  asection *last;
d86 6
d107 2
a108 1
  PARAMS ((struct sec_merge_hash *, const char *, unsigned int));
d137 1
a137 1
      ret->index = (bfd_size_type) -1;
d139 1
a139 1
      ret->sec = NULL;
d221 1
a221 3
	     alignment, we need to insert another copy.
	     FIXME: The old copy could be removed and the space allocated
	     for it filled by some new string (similarly with padding).  */
d223 6
a228 1
	    break;
d284 1
a284 1
sec_merge_add (tab, str, alignment)
d288 1
d296 1
a296 1
  if (entry->index == (bfd_size_type) -1)
d298 2
a299 3
      tab->size = (tab->size + alignment - 1) & ~((bfd_vma) alignment - 1);
      entry->index = tab->size;
      tab->size += entry->len;
d315 2
a316 1
  asection *sec = entry->sec;
d324 1
a324 1
  for (; entry != NULL && entry->sec == sec; entry = entry->next)
d350 1
a350 1
  return entry == NULL || entry->sec != sec;
a362 1
  boolean first, nul;
a364 2
  unsigned char *p, *end;
  bfd_vma mask, eltalign;
a365 1
  unsigned int i;
d368 1
d387 1
a387 1
  align = bfd_get_section_alignment (abfd, sec);
a402 2
  first = false;

d404 4
a407 3
    if (! ((sinfo->last->flags ^ sec->flags) & (SEC_MERGE | SEC_STRINGS))
	&& sinfo->last->entsize == sec->entsize
	&& ! strcmp (sinfo->last->name, sec->name))
a412 1
      first = true;
d418 1
d434 10
a444 1
  sinfo->htab->size = 0;
d447 1
a447 1
  if (! bfd_get_section_contents (abfd, sec, secinfo->contents, 0,
d451 98
a555 2
	  struct sec_merge_hash_entry *entry;

d560 3
a562 7
	  entry = sec_merge_add (sinfo->htab, p, eltalign);
	  if (entry->sec == NULL)
	    {
	      if (secinfo->first == NULL)
		secinfo->first = entry;
	      entry->sec = sec;
	    }
d571 4
a574 7
		      entry = sec_merge_add (sinfo->htab, "", mask + 1);
		      if (entry->sec == NULL)
		        {
			  if (secinfo->first == NULL)
			    secinfo->first = entry;
			  entry->sec = sec;
		        }
d591 4
a594 7
		      entry = sec_merge_add (sinfo->htab, p, mask + 1);
		      if (entry->sec == NULL)
			{
			  if (secinfo->first == NULL)
			    secinfo->first = entry;
			  entry->sec = sec;
			}
d605 7
a611 1
	  struct sec_merge_hash_entry *entry;
d613 58
a670 2
	  entry = sec_merge_add (sinfo->htab, p, 1);
	  if (entry->sec == NULL)
d672 147
a818 3
	      if (secinfo->first == NULL)
		secinfo->first = entry;
	      entry->sec = sec;
d820 1
d822 9
a832 4
  sec->_cooked_size = sinfo->htab->size;
  if (!sec->_cooked_size)
    sec->flags |= SEC_EXCLUDE;
  sinfo->last = sec;
a833 6

 error_return:
  if (*psecinfo != NULL)
    free (*psecinfo);
  *psecinfo = NULL;
  return false;
d939 2
a940 2
  *psec = entry->sec;
  return entry->index + (secinfo->contents + offset - p);
@


1.1
log
@bfd/
	* libbfd-in.h (_bfd_merge_section): New.
	(_bfd_write_merged_section): New.
	(_bfd_merged_section_offset): New.
	* libbfd.h: Rebuilt.
	* linker.c (_bfd_generic_link_output_symbols): Handle
	discard_sec_merge.
	* aoutx.h (aout_link_write_symbols): Likewise.
	* pdp11.c (aout_link_write_symbols): Likewise.
	* elflink.h (elf_link_add_object_symbols): Call _bfd_merge_section.
	(elf_bfd_final_link): Adjust global symbols pointing into SEC_MERGE
	sections.
	(elf_link_sec_merge_syms): New.
	(elf_link_input_bfd): Call _bfd_merged_section_offset
	and _bfd_write_merged_section.
	Handle discard_sec_merge.
	* elf-bfd.h (struct elf_link_hash_table): Add merge_info
	field.
	(struct bfd_elf_section_data): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_MERGE and
	SEC_STRINGS section flags and entsize from their ELF counterparts.
	(_bfd_elf_link_hash_table_init): Initialize merge_info.
	(elf_fake_sections): Set SHF_MERGE, SHF_STRINGS and sh_entsize
	from their BFD counterparts.
	* merge.c: New file.
	* Makefile.am: Add strtab.lo.
	* Makefile.in: Rebuilt.
include/
	* bfdlink.h (bfd_link_discard): Add discard_sec_merge.
gas/
	* config/obj-elf.c (obj_elf_change_section): Add entsize argument,
	handle SHF_MERGE and SHF_STRINGS.
	(obj_elf_parse_section_letters): Set SHF_MERGE and SHF_STRINGS.
	(obj_elf_section): Allow additional argument specifying entity size.
	* write.c (adjust_reloc_syms): Keep relocations against local symbols
	in SEC_MERGE sections.
ld/
	* ldmain.c (main): Default to discard_sec_merge.
	* lexsup.c (OPTION_DISCARD_NONE): Define.
	(ld_options): Add --discard-none.
	(parse_args): Handle OPTION_DISCARD_NONE.
	* ldlang.c (wild_doit): SEC_MERGE should be set in the output
	section only if SEC_MERGE and SEC_STRINGS flags and entsize of
	all its input sections match.
@
text
@d37 3
a60 3
  /* Start of each string needs to be aligned to 1 << alignment_power
     octets.  */
  unsigned int alignment_power;
d88 1
a88 1
  PARAMS ((struct sec_merge_hash *, const char *, boolean));
d90 1
a90 1
  PARAMS ((unsigned int, unsigned int, boolean));
d92 1
a92 1
  PARAMS ((struct sec_merge_hash *, const char *));
d94 1
a94 1
  PARAMS ((bfd *, struct sec_merge_hash *, struct sec_merge_hash_entry *));
d122 1
d133 1
a133 1
sec_merge_hash_lookup (table, string, create)
d136 1
d198 1
a198 1
       hashp = (struct sec_merge_hash_entry *) hashp->next)
d203 9
a211 1
	return hashp;
d225 1
d235 2
a236 2
sec_merge_init (alignment_power, entsize, strings)
     unsigned int alignment_power, entsize;
a254 1
  table->alignment_power = alignment_power;
d265 1
a265 1
sec_merge_add (tab, str)
d268 1
d272 1
a272 1
  entry = sec_merge_hash_lookup (tab, str, true);
d278 1
a280 1
      tab->size = align_power (tab->size, tab->alignment_power);
d292 1
a292 1
sec_merge_emit (abfd, tab, entry)
a293 1
     struct sec_merge_hash *tab;
d298 2
d301 2
a302 2
  if (tab->alignment_power)
    pad = bfd_zmalloc (1 << tab->alignment_power);
d309 9
d324 1
a324 8
      if (tab->alignment_power)
	{
	  len &= (1 << tab->alignment_power) - 1;
	  if (len && bfd_write ((PTR) pad, 1,
				(1 << tab->alignment_power) - len,
				abfd) != (1 << tab->alignment_power) - len)
	    break;
	}
d327 1
a327 1
  if (tab->alignment_power)
d347 1
a347 1
  bfd_vma mask;
d371 5
a375 5
  if ((sec->flags & SEC_STRINGS)
      && ((sec->entsize < (unsigned int)(1 << align)
	   && (sec->entsize & (sec->entsize - 1)))
	  || (sec->entsize > (unsigned int)(1 << align)
	      && (sec->entsize & ((1 << align) - 1)))))
d380 3
a382 1
	 of alignment.  */
d391 1
a391 2
	&& ! strcmp (sinfo->last->name, sec->name)
	&& bfd_get_section_alignment (abfd, sinfo->last) == align)
d405 1
a405 2
	sec_merge_init ((sec->flags & SEC_STRINGS) ? align : 0,
			sec->entsize, (sec->flags & SEC_STRINGS));
d428 1
a428 1
  mask = ((bfd_vma)1 << sinfo->htab->alignment_power) - 1;
d435 5
a439 1
	  entry = sec_merge_add (sinfo->htab, p);
d454 1
a454 1
		      entry = sec_merge_add (sinfo->htab, "");
d477 1
a477 1
		      entry = sec_merge_add (sinfo->htab, p);
d496 1
a496 1
	  entry = sec_merge_add (sinfo->htab, p);
d539 1
a539 1
  if (! sec_merge_emit (output_bfd, secinfo->htab, secinfo->first))
d605 1
a605 1
  entry = sec_merge_hash_lookup (secinfo->htab, p, false);
@

