head	1.188;
access;
symbols
	sid-snapshot-20180601:1.188
	sid-snapshot-20180501:1.188
	sid-snapshot-20180401:1.188
	sid-snapshot-20180301:1.188
	sid-snapshot-20180201:1.188
	sid-snapshot-20180101:1.188
	sid-snapshot-20171201:1.188
	sid-snapshot-20171101:1.188
	sid-snapshot-20171001:1.188
	sid-snapshot-20170901:1.188
	sid-snapshot-20170801:1.188
	sid-snapshot-20170701:1.188
	sid-snapshot-20170601:1.188
	sid-snapshot-20170501:1.188
	sid-snapshot-20170401:1.188
	sid-snapshot-20170301:1.188
	sid-snapshot-20170201:1.188
	sid-snapshot-20170101:1.188
	sid-snapshot-20161201:1.188
	sid-snapshot-20161101:1.188
	sid-snapshot-20160901:1.188
	sid-snapshot-20160801:1.188
	sid-snapshot-20160701:1.188
	sid-snapshot-20160601:1.188
	sid-snapshot-20160501:1.188
	sid-snapshot-20160401:1.188
	sid-snapshot-20160301:1.188
	sid-snapshot-20160201:1.188
	sid-snapshot-20160101:1.188
	sid-snapshot-20151201:1.188
	sid-snapshot-20151101:1.188
	sid-snapshot-20151001:1.188
	sid-snapshot-20150901:1.188
	sid-snapshot-20150801:1.188
	sid-snapshot-20150701:1.188
	sid-snapshot-20150601:1.188
	sid-snapshot-20150501:1.188
	sid-snapshot-20150401:1.188
	sid-snapshot-20150301:1.188
	sid-snapshot-20150201:1.188
	sid-snapshot-20150101:1.188
	sid-snapshot-20141201:1.188
	sid-snapshot-20141101:1.188
	sid-snapshot-20141001:1.188
	sid-snapshot-20140901:1.188
	sid-snapshot-20140801:1.188
	sid-snapshot-20140701:1.188
	sid-snapshot-20140601:1.188
	sid-snapshot-20140501:1.188
	sid-snapshot-20140401:1.188
	sid-snapshot-20140301:1.188
	sid-snapshot-20140201:1.188
	sid-snapshot-20140101:1.188
	sid-snapshot-20131201:1.188
	sid-snapshot-20131101:1.188
	sid-snapshot-20131001:1.188
	binutils-2_24-branch:1.188.0.2
	binutils-2_24-branchpoint:1.188
	binutils-2_21_1:1.171.2.1
	sid-snapshot-20130901:1.188
	gdb_7_6_1-2013-08-30-release:1.184
	sid-snapshot-20130801:1.187
	sid-snapshot-20130701:1.186
	sid-snapshot-20130601:1.186
	sid-snapshot-20130501:1.185
	gdb_7_6-2013-04-26-release:1.184
	sid-snapshot-20130401:1.184
	binutils-2_23_2:1.182
	gdb_7_6-branch:1.184.0.2
	gdb_7_6-2013-03-12-branchpoint:1.184
	sid-snapshot-20130301:1.184
	sid-snapshot-20130201:1.184
	sid-snapshot-20130101:1.183
	sid-snapshot-20121201:1.183
	gdb_7_5_1-2012-11-29-release:1.182
	binutils-2_23_1:1.182
	sid-snapshot-20121101:1.183
	binutils-2_23:1.182
	sid-snapshot-20121001:1.182
	sid-snapshot-20120901:1.182
	gdb_7_5-2012-08-17-release:1.182
	sid-snapshot-20120801:1.182
	binutils-2_23-branch:1.182.0.6
	binutils-2_23-branchpoint:1.182
	gdb_7_5-branch:1.182.0.4
	gdb_7_5-2012-07-18-branchpoint:1.182
	sid-snapshot-20120701:1.182
	sid-snapshot-20120601:1.182
	sid-snapshot-20120501:1.182
	binutils-2_22_branch:1.181.0.4
	gdb_7_4_1-2012-04-26-release:1.182
	sid-snapshot-20120401:1.182
	sid-snapshot-20120301:1.182
	sid-snapshot-20120201:1.182
	gdb_7_4-2012-01-24-release:1.182
	sid-snapshot-20120101:1.182
	gdb_7_4-branch:1.182.0.2
	gdb_7_4-2011-12-13-branchpoint:1.182
	sid-snapshot-20111201:1.182
	binutils-2_22:1.181
	sid-snapshot-20111101:1.182
	sid-snapshot-20111001:1.182
	binutils-2_22-branch:1.181.0.2
	binutils-2_22-branchpoint:1.181
	gdb_7_3_1-2011-09-04-release:1.175
	sid-snapshot-20110901:1.181
	sid-snapshot-20110801:1.180
	gdb_7_3-2011-07-26-release:1.175
	sid-snapshot-20110701:1.179
	sid-snapshot-20110601:1.178
	sid-snapshot-20110501:1.177
	gdb_7_3-branch:1.175.0.2
	gdb_7_3-2011-04-01-branchpoint:1.175
	sid-snapshot-20110401:1.175
	sid-snapshot-20110301:1.172
	sid-snapshot-20110201:1.172
	sid-snapshot-20110101:1.171
	binutils-2_21:1.171
	sid-snapshot-20101201:1.171
	binutils-2_21-branch:1.171.0.2
	binutils-2_21-branchpoint:1.171
	sid-snapshot-20101101:1.170
	sid-snapshot-20101001:1.169
	binutils-2_20_1:1.158.2.2
	gdb_7_2-2010-09-02-release:1.167
	sid-snapshot-20100901:1.168
	sid-snapshot-20100801:1.167
	gdb_7_2-branch:1.167.0.2
	gdb_7_2-2010-07-07-branchpoint:1.167
	sid-snapshot-20100701:1.167
	sid-snapshot-20100601:1.165
	sid-snapshot-20100501:1.164
	sid-snapshot-20100401:1.163
	gdb_7_1-2010-03-18-release:1.163
	sid-snapshot-20100301:1.163
	gdb_7_1-branch:1.163.0.2
	gdb_7_1-2010-02-18-branchpoint:1.163
	sid-snapshot-20100201:1.163
	sid-snapshot-20100101:1.162
	gdb_7_0_1-2009-12-22-release:1.161
	sid-snapshot-20091201:1.162
	sid-snapshot-20091101:1.161
	binutils-2_20:1.158.2.2
	gdb_7_0-2009-10-06-release:1.161
	sid-snapshot-20091001:1.161
	gdb_7_0-branch:1.161.0.2
	gdb_7_0-2009-09-16-branchpoint:1.161
	arc-sim-20090309:1.142
	binutils-arc-20081103-branch:1.144.0.10
	binutils-arc-20081103-branchpoint:1.144
	binutils-2_20-branch:1.158.0.2
	binutils-2_20-branchpoint:1.158
	sid-snapshot-20090901:1.158
	sid-snapshot-20090801:1.157
	msnyder-checkpoint-072509-branch:1.157.0.2
	msnyder-checkpoint-072509-branchpoint:1.157
	sid-snapshot-20090701:1.156
	dje-cgen-play1-branch:1.156.0.2
	dje-cgen-play1-branchpoint:1.156
	sid-snapshot-20090601:1.155
	sid-snapshot-20090501:1.155
	sid-snapshot-20090401:1.150
	arc-20081103-branch:1.144.0.8
	arc-20081103-branchpoint:1.144
	arc-insight_6_8-branch:1.142.0.14
	arc-insight_6_8-branchpoint:1.142
	insight_6_8-branch:1.142.0.12
	insight_6_8-branchpoint:1.142
	sid-snapshot-20090301:1.148
	binutils-2_19_1:1.144
	sid-snapshot-20090201:1.146
	sid-snapshot-20090101:1.145
	reverse-20081226-branch:1.145.0.2
	reverse-20081226-branchpoint:1.145
	sid-snapshot-20081201:1.144
	multiprocess-20081120-branch:1.144.0.6
	multiprocess-20081120-branchpoint:1.144
	sid-snapshot-20081101:1.144
	binutils-2_19:1.144
	sid-snapshot-20081001:1.144
	reverse-20080930-branch:1.144.0.4
	reverse-20080930-branchpoint:1.144
	binutils-2_19-branch:1.144.0.2
	binutils-2_19-branchpoint:1.144
	sid-snapshot-20080901:1.144
	sid-snapshot-20080801:1.143
	reverse-20080717-branch:1.142.0.10
	reverse-20080717-branchpoint:1.142
	sid-snapshot-20080701:1.142
	msnyder-reverse-20080609-branch:1.142.0.8
	msnyder-reverse-20080609-branchpoint:1.142
	drow-reverse-20070409-branch:1.136.0.2
	drow-reverse-20070409-branchpoint:1.136
	sid-snapshot-20080601:1.142
	sid-snapshot-20080501:1.142
	sid-snapshot-20080403:1.142
	sid-snapshot-20080401:1.142
	gdb_6_8-2008-03-27-release:1.142
	sid-snapshot-20080301:1.142
	gdb_6_8-branch:1.142.0.6
	gdb_6_8-2008-02-26-branchpoint:1.142
	sid-snapshot-20080201:1.142
	sid-snapshot-20080101:1.142
	sid-snapshot-20071201:1.142
	sid-snapshot-20071101:1.142
	gdb_6_7_1-2007-10-29-release:1.142
	gdb_6_7-2007-10-10-release:1.142
	sid-snapshot-20071001:1.142
	gdb_6_7-branch:1.142.0.4
	gdb_6_7-2007-09-07-branchpoint:1.142
	binutils-2_18:1.142
	binutils-2_18-branch:1.142.0.2
	binutils-2_18-branchpoint:1.142
	insight_6_6-20070208-release:1.135
	binutils-csl-coldfire-4_1-32:1.130
	binutils-csl-sourcerygxx-4_1-32:1.130
	gdb_6_6-2006-12-18-release:1.135
	binutils-csl-innovasic-fido-3_4_4-33:1.130
	binutils-csl-sourcerygxx-3_4_4-32:1.120
	binutils-csl-coldfire-4_1-30:1.130
	binutils-csl-sourcerygxx-4_1-30:1.130
	binutils-csl-coldfire-4_1-28:1.130
	binutils-csl-sourcerygxx-4_1-29:1.130
	binutils-csl-sourcerygxx-4_1-28:1.130
	gdb_6_6-branch:1.135.0.2
	gdb_6_6-2006-11-15-branchpoint:1.135
	binutils-csl-arm-2006q3-27:1.130
	binutils-csl-sourcerygxx-4_1-27:1.130
	binutils-csl-arm-2006q3-26:1.130
	binutils-csl-sourcerygxx-4_1-26:1.130
	binutils-csl-sourcerygxx-4_1-25:1.130
	binutils-csl-sourcerygxx-4_1-24:1.130
	binutils-csl-sourcerygxx-4_1-23:1.130
	insight_6_5-20061003-release:1.132
	gdb-csl-symbian-6_4_50_20060226-12:1.130
	binutils-csl-sourcerygxx-4_1-21:1.130
	binutils-csl-arm-2006q3-21:1.130
	binutils-csl-sourcerygxx-4_1-22:1.130
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.130
	binutils-csl-sourcerygxx-4_1-20:1.130
	binutils-csl-arm-2006q3-19:1.130
	binutils-csl-sourcerygxx-4_1-19:1.130
	binutils-csl-sourcerygxx-4_1-18:1.130
	binutils-csl-renesas-4_1-9:1.130
	gdb-csl-sourcerygxx-3_4_4-25:1.130
	binutils-csl-sourcerygxx-3_4_4-25:1.120
	nickrob-async-20060828-mergepoint:1.132
	gdb-csl-symbian-6_4_50_20060226-11:1.130
	binutils-csl-renesas-4_1-8:1.130
	binutils-csl-renesas-4_1-7:1.130
	binutils-csl-renesas-4_1-6:1.130
	gdb-csl-sourcerygxx-4_1-17:1.130
	binutils-csl-sourcerygxx-4_1-17:1.130
	gdb-csl-20060226-branch-local-2:1.130
	gdb-csl-sourcerygxx-4_1-14:1.130
	binutils-csl-sourcerygxx-4_1-14:1.130
	binutils-csl-sourcerygxx-4_1-15:1.130
	gdb-csl-sourcerygxx-4_1-13:1.130
	binutils-csl-sourcerygxx-4_1-13:1.130
	binutils-2_17:1.130
	gdb-csl-sourcerygxx-4_1-12:1.130
	binutils-csl-sourcerygxx-4_1-12:1.130
	gdb-csl-sourcerygxx-3_4_4-21:1.130
	binutils-csl-sourcerygxx-3_4_4-21:1.130
	gdb_6_5-20060621-release:1.132
	binutils-csl-wrs-linux-3_4_4-24:1.120
	binutils-csl-wrs-linux-3_4_4-23:1.120
	gdb-csl-sourcerygxx-4_1-9:1.130
	binutils-csl-sourcerygxx-4_1-9:1.130
	gdb-csl-sourcerygxx-4_1-8:1.130
	binutils-csl-sourcerygxx-4_1-8:1.130
	gdb-csl-sourcerygxx-4_1-7:1.130
	binutils-csl-sourcerygxx-4_1-7:1.130
	gdb-csl-arm-2006q1-6:1.130
	binutils-csl-arm-2006q1-6:1.130
	gdb-csl-sourcerygxx-4_1-6:1.130
	binutils-csl-sourcerygxx-4_1-6:1.130
	binutils-csl-wrs-linux-3_4_4-22:1.120
	gdb-csl-symbian-6_4_50_20060226-10:1.130
	gdb-csl-symbian-6_4_50_20060226-9:1.130
	gdb-csl-symbian-6_4_50_20060226-8:1.130
	gdb-csl-coldfire-4_1-11:1.130
	binutils-csl-coldfire-4_1-11:1.130
	gdb-csl-sourcerygxx-3_4_4-19:1.130
	binutils-csl-sourcerygxx-3_4_4-19:1.130
	gdb-csl-coldfire-4_1-10:1.130
	gdb_6_5-branch:1.132.0.4
	gdb_6_5-2006-05-14-branchpoint:1.132
	binutils-csl-coldfire-4_1-10:1.130
	gdb-csl-sourcerygxx-4_1-5:1.130
	binutils-csl-sourcerygxx-4_1-5:1.130
	nickrob-async-20060513-branch:1.132.0.2
	nickrob-async-20060513-branchpoint:1.132
	gdb-csl-sourcerygxx-4_1-4:1.130
	binutils-csl-sourcerygxx-4_1-4:1.130
	msnyder-reverse-20060502-branch:1.130.0.22
	msnyder-reverse-20060502-branchpoint:1.130
	binutils-csl-wrs-linux-3_4_4-21:1.120
	gdb-csl-morpho-4_1-4:1.130
	binutils-csl-morpho-4_1-4:1.130
	gdb-csl-sourcerygxx-3_4_4-17:1.130
	binutils-csl-sourcerygxx-3_4_4-17:1.130
	binutils-csl-wrs-linux-3_4_4-20:1.120
	readline_5_1-import-branch:1.130.0.20
	readline_5_1-import-branchpoint:1.130
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.130
	binutils-2_17-branch:1.130.0.18
	binutils-2_17-branchpoint:1.130
	gdb-csl-symbian-20060226-branch:1.130.0.16
	gdb-csl-symbian-20060226-branchpoint:1.130
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.130
	msnyder-reverse-20060331-branch:1.130.0.14
	msnyder-reverse-20060331-branchpoint:1.130
	binutils-csl-2_17-branch:1.130.0.12
	binutils-csl-2_17-branchpoint:1.130
	gdb-csl-available-20060303-branch:1.130.0.10
	gdb-csl-available-20060303-branchpoint:1.130
	gdb-csl-20060226-branch:1.130.0.8
	gdb-csl-20060226-branchpoint:1.130
	gdb_6_4-20051202-release:1.130
	msnyder-fork-checkpoint-branch:1.130.0.6
	msnyder-fork-checkpoint-branchpoint:1.130
	gdb-csl-gxxpro-6_3-branch:1.130.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.130
	gdb_6_4-branch:1.130.0.2
	gdb_6_4-2005-11-01-branchpoint:1.130
	gdb-csl-arm-20051020-branch:1.129.0.2
	gdb-csl-arm-20051020-branchpoint:1.129
	binutils-csl-gxxpro-3_4-branch:1.120.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.120
	binutils-2_16_1:1.120
	msnyder-tracepoint-checkpoint-branch:1.125.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.125
	gdb-csl-arm-20050325-2005-q1b:1.120
	binutils-csl-arm-2005q1b:1.120
	binutils-2_16:1.120
	gdb-csl-arm-20050325-2005-q1a:1.120
	binutils-csl-arm-2005q1a:1.120
	csl-arm-20050325-branch:1.120.0.6
	csl-arm-20050325-branchpoint:1.120
	binutils-csl-arm-2005q1-branch:1.120.0.4
	binutils-csl-arm-2005q1-branchpoint:1.120
	binutils-2_16-branch:1.120.0.2
	binutils-2_16-branchpoint:1.120
	csl-arm-2004-q3d:1.113
	gdb_6_3-20041109-release:1.113
	gdb_6_3-branch:1.113.0.2
	gdb_6_3-20041019-branchpoint:1.113
	csl-arm-2004-q3:1.111
	drow_intercu-merge-20040921:1.111
	drow_intercu-merge-20040915:1.111
	jimb-gdb_6_2-e500-branch:1.108.0.6
	jimb-gdb_6_2-e500-branchpoint:1.108
	gdb_6_2-20040730-release:1.108
	gdb_6_2-branch:1.108.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.108
	gdb_6_1_1-20040616-release:1.101
	binutils-2_15:1.101
	binutils-2_15-branchpoint:1.101
	csl-arm-2004-q1a:1.103
	csl-arm-2004-q1:1.101
	gdb_6_1-2004-04-05-release:1.101
	drow_intercu-merge-20040402:1.101
	drow_intercu-merge-20040327:1.101
	ezannoni_pie-20040323-branch:1.101.0.14
	ezannoni_pie-20040323-branchpoint:1.101
	cagney_tramp-20040321-mergepoint:1.101
	cagney_tramp-20040309-branch:1.101.0.12
	cagney_tramp-20040309-branchpoint:1.101
	gdb_6_1-branch:1.101.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.101
	drow_intercu-20040221-branch:1.101.0.8
	drow_intercu-20040221-branchpoint:1.101
	binutils-2_15-branch:1.101.0.6
	cagney_bfdfile-20040213-branch:1.101.0.4
	cagney_bfdfile-20040213-branchpoint:1.101
	drow-cplus-merge-20040208:1.101
	carlton_dictionary-20040126-merge:1.101
	cagney_bigcore-20040122-branch:1.101.0.2
	cagney_bigcore-20040122-branchpoint:1.101
	drow-cplus-merge-20040113:1.101
	csl-arm-2003-q4:1.101
	drow-cplus-merge-20031224:1.101
	drow-cplus-merge-20031220:1.101
	carlton_dictionary-20031215-merge:1.100
	drow-cplus-merge-20031214:1.100
	carlton-dictionary-20031111-merge:1.97
	gdb_6_0-2003-10-04-release:1.92
	kettenis_sparc-20030918-branch:1.95.0.6
	kettenis_sparc-20030918-branchpoint:1.95
	carlton_dictionary-20030917-merge:1.95
	ezannoni_pie-20030916-branchpoint:1.95
	ezannoni_pie-20030916-branch:1.95.0.4
	cagney_x86i386-20030821-branch:1.95.0.2
	cagney_x86i386-20030821-branchpoint:1.95
	carlton_dictionary-20030805-merge:1.95
	carlton_dictionary-20030627-merge:1.92
	gdb_6_0-branch:1.92.0.6
	gdb_6_0-2003-06-23-branchpoint:1.92
	jimb-ppc64-linux-20030613-branch:1.92.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.92
	binutils-2_14:1.90
	cagney_convert-20030606-branch:1.92.0.2
	cagney_convert-20030606-branchpoint:1.92
	cagney_writestrings-20030508-branch:1.90.0.10
	cagney_writestrings-20030508-branchpoint:1.90
	jimb-ppc64-linux-20030528-branch:1.90.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.90
	carlton_dictionary-20030523-merge:1.90
	cagney_fileio-20030521-branch:1.90.0.6
	cagney_fileio-20030521-branchpoint:1.90
	kettenis_i386newframe-20030517-mergepoint:1.90
	jimb-ppc64-linux-20030509-branch:1.90.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.90
	kettenis_i386newframe-20030504-mergepoint:1.90
	carlton_dictionary-20030430-merge:1.90
	binutils-2_14-branch:1.90.0.2
	binutils-2_14-branchpoint:1.90
	kettenis_i386newframe-20030419-branch:1.89.0.6
	kettenis_i386newframe-20030419-branchpoint:1.89
	carlton_dictionary-20030416-merge:1.89
	cagney_frameaddr-20030409-mergepoint:1.89
	kettenis_i386newframe-20030406-branch:1.89.0.4
	kettenis_i386newframe-20030406-branchpoint:1.89
	cagney_frameaddr-20030403-branchpoint:1.89
	cagney_frameaddr-20030403-branch:1.89.0.2
	cagney_framebase-20030330-mergepoint:1.88
	cagney_framebase-20030326-branch:1.88.0.2
	cagney_framebase-20030326-branchpoint:1.88
	cagney_lazyid-20030317-branch:1.87.0.8
	cagney_lazyid-20030317-branchpoint:1.87
	kettenis-i386newframe-20030316-mergepoint:1.87
	offbyone-20030313-branch:1.87.0.6
	offbyone-20030313-branchpoint:1.87
	kettenis-i386newframe-20030308-branch:1.87.0.4
	kettenis-i386newframe-20030308-branchpoint:1.87
	carlton_dictionary-20030305-merge:1.87
	cagney_offbyone-20030303-branch:1.87.0.2
	cagney_offbyone-20030303-branchpoint:1.87
	carlton_dictionary-20030207-merge:1.86
	interps-20030202-branch:1.86.0.2
	interps-20030202-branchpoint:1.86
	cagney-unwind-20030108-branch:1.85.0.2
	cagney-unwind-20030108-branchpoint:1.85
	binutils-2_13_2_1:1.80.2.2
	binutils-2_13_2:1.80.2.2
	carlton_dictionary-20021223-merge:1.85
	gdb_5_3-2002-12-12-release:1.82
	carlton_dictionary-20021115-merge:1.83
	binutils-2_13_1:1.80.2.2
	kseitz_interps-20021105-merge:1.83
	kseitz_interps-20021103-merge:1.83
	drow-cplus-merge-20021020:1.82
	drow-cplus-merge-20021025:1.82
	carlton_dictionary-20021025-merge:1.82
	carlton_dictionary-20021011-merge:1.82
	drow-cplus-branch:1.82.0.8
	drow-cplus-branchpoint:1.82
	kseitz_interps-20020930-merge:1.82
	carlton_dictionary-20020927-merge:1.82
	carlton_dictionary-branch:1.82.0.6
	carlton_dictionary-20020920-branchpoint:1.82
	sid-20020905-branchpoint:1.82
	sid-20020905-branch:1.82.0.4
	gdb_5_3-branch:1.82.0.2
	gdb_5_3-2002-09-04-branchpoint:1.82
	kseitz_interps-20020829-merge:1.81
	cagney_sysregs-20020825-branch:1.80.0.6
	cagney_sysregs-20020825-branchpoint:1.80
	readline_4_3-import-branch:1.80.0.4
	readline_4_3-import-branchpoint:1.80
	binutils-2_13:1.80
	gdb_5_2_1-2002-07-23-release:1.69
	binutils-2_13-branchpoint:1.80
	binutils-2_13-branch:1.80.0.2
	kseitz_interps-20020528-branch:1.76.0.2
	kseitz_interps-20020528-branchpoint:1.76
	cagney_regbuf-20020515-branch:1.75.0.4
	cagney_regbuf-20020515-branchpoint:1.75
	binutils-2_12_1:1.69.2.2
	jimb-macro-020506-branch:1.75.0.2
	jimb-macro-020506-branchpoint:1.75
	gdb_5_2-2002-04-29-release:1.69
	binutils-2_12:1.69
	gdb_5_2-branch:1.69.0.4
	gdb_5_2-2002-03-03-branchpoint:1.69
	binutils-2_12-branch:1.69.0.2
	binutils-2_12-branchpoint:1.69
	gdb_5_1_1-2002-01-24-release:1.59
	gdb_5_1_0_1-2002-01-03-release:1.59
	cygnus_cvs_20020108_pre:1.67
	gdb_5_1_0_1-2002-01-03-branch:1.59.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.59
	gdb_5_1-2001-11-21-release:1.59
	gdb_s390-2001-09-26-branch:1.59.0.4
	gdb_s390-2001-09-26-branchpoint:1.59
	gdb_5_1-2001-07-29-branch:1.59.0.2
	gdb_5_1-2001-07-29-branchpoint:1.59
	binutils-2_11_2:1.53.2.2
	binutils-2_11_1:1.53.2.2
	binutils-2_11:1.53
	x86_64versiong3:1.54
	binutils-2_11-branch:1.53.0.2
	insight-precleanup-2001-01-01:1.52
	binutils-2_10_1:1.33.2.1
	binutils-2_10:1.33
	gdb-premipsmulti-2000-06-06-branch:1.41.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.41
	gdb_5_0-2000-05-19-release:1.35
	gdb_4_18_2-2000-05-18-release:1.35
	gdb_4_95_1-2000-05-11-snapshot:1.35
	gdb_4_95_0-2000-04-27-snapshot:1.35
	gdb_5_0-2000-04-10-branch:1.35.0.2
	gdb_5_0-2000-04-10-branchpoint:1.35
	binutils-2_10-branch:1.33.0.2
	binutils-2_10-branchpoint:1.33
	binutils_latest_snapshot:1.188
	repo-unification-2000-02-06:1.28
	binu_ss_19990721:1.7
	binu_ss_19990602:1.3
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.188
date	2013.08.21.08.15.23;	author gingold;	state Exp;
branches;
next	1.187;

1.187
date	2013.07.05.10.20.49;	author gingold;	state Exp;
branches;
next	1.186;

1.186
date	2013.05.10.13.08.24;	author brobecke;	state Exp;
branches;
next	1.185;

1.185
date	2013.04.17.14.16.00;	author nickc;	state Exp;
branches;
next	1.184;

1.184
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.183;

1.183
date	2012.10.18.17.42.28;	author ktietz;	state Exp;
branches;
next	1.182;

1.182
date	2011.09.27.16.03.49;	author ktietz;	state Exp;
branches;
next	1.181;

1.181
date	2011.08.17.00.39.38;	author amodra;	state Exp;
branches;
next	1.180;

1.180
date	2011.07.11.15.03.04;	author clm;	state Exp;
branches;
next	1.179;

1.179
date	2011.06.06.01.26.02;	author amodra;	state Exp;
branches;
next	1.178;

1.178
date	2011.05.18.07.58.31;	author gingold;	state Exp;
branches;
next	1.177;

1.177
date	2011.04.26.15.28.05;	author nickc;	state Exp;
branches;
next	1.176;

1.176
date	2011.04.09.16.05.59;	author ktietz;	state Exp;
branches;
next	1.175;

1.175
date	2011.03.31.08.13.48;	author gingold;	state Exp;
branches;
next	1.174;

1.174
date	2011.03.25.18.02.25;	author nickc;	state Exp;
branches;
next	1.173;

1.173
date	2011.03.25.17.06.53;	author nickc;	state Exp;
branches;
next	1.172;

1.172
date	2011.01.18.14.13.43;	author nickc;	state Exp;
branches;
next	1.171;

1.171
date	2010.11.04.16.03.22;	author ktietz;	state Exp;
branches
	1.171.2.1;
next	1.170;

1.170
date	2010.10.29.13.20.04;	author nickc;	state Exp;
branches;
next	1.169;

1.169
date	2010.09.22.14.19.35;	author ktietz;	state Exp;
branches;
next	1.168;

1.168
date	2010.09.01.07.50.48;	author gingold;	state Exp;
branches;
next	1.167;

1.167
date	2010.06.29.04.17.20;	author amodra;	state Exp;
branches;
next	1.166;

1.166
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.165;

1.165
date	2010.05.11.04.42.10;	author amodra;	state Exp;
branches;
next	1.164;

1.164
date	2010.04.27.17.26.03;	author ktietz;	state Exp;
branches;
next	1.163;

1.163
date	2010.01.18.07.21.46;	author amodra;	state Exp;
branches;
next	1.162;

1.162
date	2009.11.23.14.41.29;	author pbrook;	state Exp;
branches;
next	1.161;

1.161
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.160;

1.160
date	2009.09.05.16.38.48;	author eliz;	state Exp;
branches;
next	1.159;

1.159
date	2009.09.05.07.56.21;	author nickc;	state Exp;
branches;
next	1.158;

1.158
date	2009.08.10.21.56.42;	author jkratoch;	state Exp;
branches
	1.158.2.1;
next	1.157;

1.157
date	2009.07.03.16.07.38;	author davek;	state Exp;
branches;
next	1.156;

1.156
date	2009.06.25.13.39.27;	author ktietz;	state Exp;
branches;
next	1.155;

1.155
date	2009.04.21.17.08.20;	author hjl;	state Exp;
branches;
next	1.154;

1.154
date	2009.04.17.13.46.11;	author hjl;	state Exp;
branches;
next	1.153;

1.153
date	2009.04.16.23.06.58;	author rsandifo;	state Exp;
branches;
next	1.152;

1.152
date	2009.04.16.15.39.41;	author nickc;	state Exp;
branches;
next	1.151;

1.151
date	2009.04.14.09.47.43;	author davek;	state Exp;
branches;
next	1.150;

1.150
date	2009.03.19.11.02.09;	author ktietz;	state Exp;
branches;
next	1.149;

1.149
date	2009.03.14.09.34.27;	author rsandifo;	state Exp;
branches;
next	1.148;

1.148
date	2009.02.18.18.38.06;	author davek;	state Exp;
branches;
next	1.147;

1.147
date	2009.02.18.18.23.06;	author davek;	state Exp;
branches;
next	1.146;

1.146
date	2009.01.16.15.09.20;	author ktietz;	state Exp;
branches;
next	1.145;

1.145
date	2008.12.23.10.59.55;	author nickc;	state Exp;
branches;
next	1.144;

1.144
date	2008.08.05.03.03.46;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2008.07.18.11.30.22;	author nickc;	state Exp;
branches;
next	1.142;

1.142
date	2007.08.02.16.02.01;	author hjl;	state Exp;
branches;
next	1.141;

1.141
date	2007.08.01.16.55.54;	author nickc;	state Exp;
branches;
next	1.140;

1.140
date	2007.07.12.07.16.40;	author nickc;	state Exp;
branches;
next	1.139;

1.139
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.138;

1.138
date	2007.04.24.13.05.46;	author nickc;	state Exp;
branches;
next	1.137;

1.137
date	2007.04.19.13.36.41;	author nickc;	state Exp;
branches;
next	1.136;

1.136
date	2007.03.26.12.22.59;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2006.09.20.11.35.07;	author nickc;	state Exp;
branches;
next	1.134;

1.134
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	2006.09.05.18.56.50;	author hjl;	state Exp;
branches;
next	1.132;

1.132
date	2006.05.09.11.47.47;	author nickc;	state Exp;
branches;
next	1.131;

1.131
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2005.10.25.17.40.09;	author nickc;	state Exp;
branches
	1.130.18.1;
next	1.129;

1.129
date	2005.08.18.03.48.26;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2005.06.17.13.39.56;	author jakub;	state Exp;
branches;
next	1.127;

1.127
date	2005.06.09.19.22.15;	author cgf;	state Exp;
branches;
next	1.126;

1.126
date	2005.06.09.14.40.50;	author cgf;	state Exp;
branches;
next	1.125;

1.125
date	2005.05.04.15.53.05;	author nickc;	state Exp;
branches;
next	1.124;

1.124
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.123;

1.123
date	2005.05.03.01.05.00;	author hjl;	state Exp;
branches;
next	1.122;

1.122
date	2005.04.21.07.45.36;	author nickc;	state Exp;
branches;
next	1.121;

1.121
date	2005.04.11.16.55.48;	author hjl;	state Exp;
branches;
next	1.120;

1.120
date	2005.02.24.20.16.55;	author bje;	state Exp;
branches;
next	1.119;

1.119
date	2005.02.24.13.34.38;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2005.02.22.00.50.04;	author hjl;	state Exp;
branches;
next	1.117;

1.117
date	2005.02.11.17.10.07;	author nickc;	state Exp;
branches;
next	1.116;

1.116
date	2005.01.31.23.13.16;	author bje;	state Exp;
branches;
next	1.115;

1.115
date	2005.01.10.16.33.48;	author nickc;	state Exp;
branches;
next	1.114;

1.114
date	2004.11.08.13.17.32;	author nickc;	state Exp;
branches;
next	1.113;

1.113
date	2004.10.13.18.14.40;	author hjl;	state Exp;
branches;
next	1.112;

1.112
date	2004.10.08.14.53.56;	author nickc;	state Exp;
branches;
next	1.111;

1.111
date	2004.09.03.14.11.38;	author nickc;	state Exp;
branches;
next	1.110;

1.110
date	2004.08.13.03.15.56;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.108;

1.108
date	2004.06.24.04.46.16;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2004.06.21.14.40.41;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2004.06.15.01.24.22;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2004.05.17.16.40.00;	author bwilson;	state Exp;
branches;
next	1.104;

1.104
date	2004.05.07.15.08.48;	author ford;	state Exp;
branches;
next	1.103;

1.103
date	2004.04.30.14.23.39;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2004.04.29.16.40.19;	author nickc;	state Exp;
branches;
next	1.101;

1.101
date	2003.12.19.10.01.59;	author nickc;	state Exp;
branches
	1.101.8.1;
next	1.100;

1.100
date	2003.12.01.18.46.21;	author nickc;	state Exp;
branches;
next	1.99;

1.99
date	2003.12.01.06.33.00;	author kazu;	state Exp;
branches;
next	1.98;

1.98
date	2003.11.24.18.06.40;	author kazu;	state Exp;
branches;
next	1.97;

1.97
date	2003.11.04.10.41.51;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2003.10.07.08.49.11;	author nathan;	state Exp;
branches;
next	1.95;

1.95
date	2003.08.05.08.25.17;	author nickc;	state Exp;
branches;
next	1.94;

1.94
date	2003.07.22.09.06.49;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2003.07.12.10.55.05;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	2003.06.04.11.38.30;	author sveinse;	state Exp;
branches;
next	1.91;

1.91
date	2003.06.04.10.47.33;	author sveinse;	state Exp;
branches;
next	1.90;

1.90
date	2003.04.24.12.36.06;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2003.04.01.13.08.05;	author nickc;	state Exp;
branches
	1.89.6.1;
next	1.88;

1.88
date	2003.03.25.20.55.57;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2003.02.14.11.16.09;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2003.01.20.22.34.38;	author sveinse;	state Exp;
branches;
next	1.85;

1.85
date	2002.12.20.22.41.13;	author kazu;	state Exp;
branches;
next	1.84;

1.84
date	2002.11.30.08.39.36;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2002.10.30.15.50.17;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2002.09.02.11.47.42;	author amodra;	state Exp;
branches
	1.82.6.1
	1.82.8.1;
next	1.81;

1.81
date	2002.08.26.09.01.41;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2002.07.08.05.34.08;	author mmitchel;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2002.06.25.06.21.47;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.12.16.04.39;	author trix;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.05.03.43.09;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2002.05.15.00.18.55;	author amodra;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2002.04.26.06.01.20;	author amodra;	state Exp;
branches
	1.75.4.1;
next	1.74;

1.74
date	2002.04.26.03.16.43;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2002.04.09.16.43.26;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	2002.04.04.19.53.35;	author drow;	state Exp;
branches;
next	1.71;

1.71
date	2002.03.18.12.45.37;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2002.03.14.18.30.40;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2002.02.06.16.29.28;	author nickc;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2002.01.31.17.32.54;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2002.01.05.13.11.31;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2001.12.20.21.29.21;	author trix;	state Exp;
branches;
next	1.65;

1.65
date	2001.12.18.00.32.32;	author trix;	state Exp;
branches;
next	1.64;

1.64
date	2001.10.10.12.08.27;	author kazu;	state Exp;
branches;
next	1.63;

1.63
date	2001.09.21.14.25.08;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2001.09.20.23.30.34;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2001.09.18.09.57.22;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2001.08.17.08.57.41;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.15.09.03.13;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2001.05.24.20.50.50;	author trix;	state Exp;
branches;
next	1.57;

1.57
date	2001.05.11.12.23.47;	author jakub;	state Exp;
branches;
next	1.56;

1.56
date	2001.04.15.04.23.46;	author dj;	state Exp;
branches;
next	1.55;

1.55
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2001.02.27.01.38.06;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2001.01.13.19.42.22;	author nickc;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2000.12.21.18.40.21;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2000.12.08.22.50.07;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2000.11.28.21.42.16;	author kazu;	state Exp;
branches;
next	1.49;

1.49
date	2000.11.27.12.45.17;	author pb;	state Exp;
branches;
next	1.48;

1.48
date	2000.11.25.00.21.34;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2000.10.06.19.47.51;	author dj;	state Exp;
branches;
next	1.46;

1.46
date	2000.08.22.20.11.36;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2000.07.31.18.49.55;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2000.06.19.01.22.37;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2000.06.16.20.45.33;	author nsd;	state Exp;
branches;
next	1.42;

1.42
date	2000.06.16.20.40.50;	author nsd;	state Exp;
branches;
next	1.41;

1.41
date	2000.05.06.01.41.50;	author cpopetz;	state Exp;
branches;
next	1.40;

1.40
date	2000.04.29.02.41.36;	author cpopetz;	state Exp;
branches;
next	1.39;

1.39
date	2000.04.26.15.09.42;	author cpopetz;	state Exp;
branches;
next	1.38;

1.38
date	2000.04.18.04.03.16;	author wilson;	state Exp;
branches;
next	1.37;

1.37
date	2000.04.18.02.21.27;	author twall;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.11.04.11.02;	author twall;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.07.17.06.57;	author twall;	state Exp;
branches;
next	1.34;

1.34
date	2000.04.07.00.58.05;	author twall;	state Exp;
branches;
next	1.33;

1.33
date	2000.03.01.20.39.07;	author nickc;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2000.02.28.18.56.10;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.19.01.11.19;	author geoffk;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.19.00.59.26;	author geoffk;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.10.21.21.55;	author twall;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.24.19.38.04;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.13.23.55.21;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	99.09.13.23.55.22;	author ian;	state Exp;
branches;
next	1.25;

1.25
date	99.09.13.23.42.43;	author ian;	state Exp;
branches;
next	1.24;

1.24
date	99.09.11.23.46.09;	author ian;	state Exp;
branches;
next	1.23;

1.23
date	99.09.11.22.46.37;	author ian;	state Exp;
branches;
next	1.22;

1.22
date	99.09.11.22.33.45;	author ian;	state Exp;
branches;
next	1.21;

1.21
date	99.09.11.21.39.03;	author ian;	state Exp;
branches;
next	1.20;

1.20
date	99.09.11.21.04.09;	author ian;	state Exp;
branches;
next	1.19;

1.19
date	99.09.07.04.28.27;	author ian;	state Exp;
branches;
next	1.18;

1.18
date	99.09.07.04.14.35;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	99.09.07.04.06.50;	author ian;	state Exp;
branches;
next	1.16;

1.16
date	99.09.07.03.42.53;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	99.09.07.03.40.32;	author ian;	state Exp;
branches;
next	1.14;

1.14
date	99.09.07.03.00.32;	author ian;	state Exp;
branches;
next	1.13;

1.13
date	99.09.07.02.11.54;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	99.08.18.06.00.13;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	99.08.09.02.56.16;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	99.08.08.16.50.27;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.08.05.21.01.37;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.07.22.01.39.23;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.07.19.14.55.15;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	99.07.12.10.28.52;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.07.05.07.28.23;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	99.06.02.15.36.48;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	99.05.19.07.27.13;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.05.11.21.05.40;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.171.2.1
date	2011.05.29.04.51.00;	author amodra;	state Exp;
branches;
next	;

1.158.2.1
date	2009.09.05.08.00.18;	author nickc;	state Exp;
branches;
next	1.158.2.2;

1.158.2.2
date	2009.09.09.21.40.18;	author nickc;	state Exp;
branches;
next	;

1.130.18.1
date	2006.08.08.08.19.57;	author nickc;	state Exp;
branches;
next	;

1.101.8.1
date	2004.09.16.17.00.14;	author drow;	state Exp;
branches;
next	;

1.89.6.1
date	2003.05.04.11.37.35;	author kettenis;	state Exp;
branches;
next	;

1.82.6.1
date	2002.11.15.19.18.23;	author carlton;	state Exp;
branches;
next	1.82.6.2;

1.82.6.2
date	2002.12.23.19.37.29;	author carlton;	state Exp;
branches;
next	1.82.6.3;

1.82.6.3
date	2003.02.07.19.17.36;	author carlton;	state Exp;
branches;
next	1.82.6.4;

1.82.6.4
date	2003.03.06.00.56.14;	author carlton;	state Exp;
branches;
next	1.82.6.5;

1.82.6.5
date	2003.04.16.19.56.41;	author carlton;	state Exp;
branches;
next	1.82.6.6;

1.82.6.6
date	2003.05.01.00.46.39;	author carlton;	state Exp;
branches;
next	1.82.6.7;

1.82.6.7
date	2003.06.27.21.49.07;	author carlton;	state Exp;
branches;
next	1.82.6.8;

1.82.6.8
date	2003.08.05.17.12.44;	author carlton;	state Exp;
branches;
next	1.82.6.9;

1.82.6.9
date	2003.11.11.23.50.09;	author carlton;	state Exp;
branches;
next	1.82.6.10;

1.82.6.10
date	2003.12.15.23.59.15;	author carlton;	state Exp;
branches;
next	1.82.6.11;

1.82.6.11
date	2004.01.26.19.11.03;	author carlton;	state Exp;
branches;
next	;

1.82.8.1
date	2003.12.14.20.26.35;	author drow;	state Exp;
branches;
next	1.82.8.2;

1.82.8.2
date	2003.12.20.18.16.45;	author drow;	state Exp;
branches;
next	;

1.80.2.1
date	2002.08.26.09.02.42;	author amodra;	state Exp;
branches;
next	1.80.2.2;

1.80.2.2
date	2002.10.30.15.52.52;	author drow;	state Exp;
branches;
next	;

1.76.2.1
date	2002.06.20.01.29.46;	author kseitz;	state Exp;
branches;
next	1.76.2.2;

1.76.2.2
date	2002.07.22.21.46.39;	author kseitz;	state Exp;
branches;
next	1.76.2.3;

1.76.2.3
date	2002.08.30.22.52.35;	author kseitz;	state Exp;
branches;
next	1.76.2.4;

1.76.2.4
date	2002.10.01.00.45.42;	author kseitz;	state Exp;
branches;
next	1.76.2.5;

1.76.2.5
date	2002.11.03.22.01.33;	author ezannoni;	state Exp;
branches;
next	;

1.75.4.1
date	2002.06.15.16.42.34;	author cagney;	state Exp;
branches;
next	;

1.69.2.1
date	2002.03.28.06.20.02;	author amodra;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2002.04.27.08.30.09;	author amodra;	state Exp;
branches;
next	;

1.53.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	1.53.2.2;

1.53.2.2
date	2001.06.11.10.04.01;	author amodra;	state Exp;
branches;
next	;

1.33.2.1
date	2000.08.22.21.02.06;	author nickc;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.188
log
@2013-08-21  Tristan Gingold  <gingold@@adacore.com>

	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Also count
	.ovrflo sections.
	* coffcode.h (coff_compute_section_file_positions): Force
	match between file offset and vma offset.
@
text
@/* Support for the generic parts of most COFF variants, for BFD.
   Copyright 1990-2013 Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/* Most of this hacked by  Steve Chamberlain,
			sac@@cygnus.com.  */
/*
SECTION
	coff backends

	BFD supports a number of different flavours of coff format.
	The major differences between formats are the sizes and
	alignments of fields in structures on disk, and the occasional
	extra field.

	Coff in all its varieties is implemented with a few common
	files and a number of implementation specific files. For
	example, The 88k bcs coff format is implemented in the file
	@@file{coff-m88k.c}. This file @@code{#include}s
	@@file{coff/m88k.h} which defines the external structure of the
	coff format for the 88k, and @@file{coff/internal.h} which
	defines the internal structure. @@file{coff-m88k.c} also
	defines the relocations used by the 88k format
	@@xref{Relocations}.

	The Intel i960 processor version of coff is implemented in
	@@file{coff-i960.c}. This file has the same structure as
	@@file{coff-m88k.c}, except that it includes @@file{coff/i960.h}
	rather than @@file{coff-m88k.h}.

SUBSECTION
	Porting to a new version of coff

	The recommended method is to select from the existing
	implementations the version of coff which is most like the one
	you want to use.  For example, we'll say that i386 coff is
	the one you select, and that your coff flavour is called foo.
	Copy @@file{i386coff.c} to @@file{foocoff.c}, copy
	@@file{../include/coff/i386.h} to @@file{../include/coff/foo.h},
	and add the lines to @@file{targets.c} and @@file{Makefile.in}
	so that your new back end is used. Alter the shapes of the
	structures in @@file{../include/coff/foo.h} so that they match
	what you need. You will probably also have to add
	@@code{#ifdef}s to the code in @@file{coff/internal.h} and
	@@file{coffcode.h} if your version of coff is too wild.

	You can verify that your new BFD backend works quite simply by
	building @@file{objdump} from the @@file{binutils} directory,
	and making sure that its version of what's going on and your
	host system's idea (assuming it has the pretty standard coff
	dump utility, usually called @@code{att-dump} or just
	@@code{dump}) are the same.  Then clean up your code, and send
	what you've done to Cygnus. Then your stuff will be in the
	next release, and you won't have to keep integrating it.

SUBSECTION
	How the coff backend works

SUBSUBSECTION
	File layout

	The Coff backend is split into generic routines that are
	applicable to any Coff target and routines that are specific
	to a particular target.  The target-specific routines are
	further split into ones which are basically the same for all
	Coff targets except that they use the external symbol format
	or use different values for certain constants.

	The generic routines are in @@file{coffgen.c}.  These routines
	work for any Coff target.  They use some hooks into the target
	specific code; the hooks are in a @@code{bfd_coff_backend_data}
	structure, one of which exists for each target.

	The essentially similar target-specific routines are in
	@@file{coffcode.h}.  This header file includes executable C code.
	The various Coff targets first include the appropriate Coff
	header file, make any special defines that are needed, and
	then include @@file{coffcode.h}.

	Some of the Coff targets then also have additional routines in
	the target source file itself.

	For example, @@file{coff-i960.c} includes
	@@file{coff/internal.h} and @@file{coff/i960.h}.  It then
	defines a few constants, such as @@code{I960}, and includes
	@@file{coffcode.h}.  Since the i960 has complex relocation
	types, @@file{coff-i960.c} also includes some code to
	manipulate the i960 relocs.  This code is not in
	@@file{coffcode.h} because it would not be used by any other
	target.

SUBSUBSECTION
	Coff long section names

	In the standard Coff object format, section names are limited to
	the eight bytes available in the @@code{s_name} field of the
	@@code{SCNHDR} section header structure.  The format requires the
	field to be NUL-padded, but not necessarily NUL-terminated, so
	the longest section names permitted are a full eight characters.

	The Microsoft PE variants of the Coff object file format add
	an extension to support the use of long section names.  This
	extension is defined in section 4 of the Microsoft PE/COFF
	specification (rev 8.1).  If a section name is too long to fit
	into the section header's @@code{s_name} field, it is instead
	placed into the string table, and the @@code{s_name} field is
	filled with a slash ("/") followed by the ASCII decimal
	representation of the offset of the full name relative to the
	string table base.

	Note that this implies that the extension can only be used in object
	files, as executables do not contain a string table.  The standard
	specifies that long section names from objects emitted into executable
	images are to be truncated.

	However, as a GNU extension, BFD can generate executable images
	that contain a string table and long section names.  This
	would appear to be technically valid, as the standard only says
	that Coff debugging information is deprecated, not forbidden,
	and in practice it works, although some tools that parse PE files
	expecting the MS standard format may become confused; @@file{PEview} is
	one known example.

	The functionality is supported in BFD by code implemented under
	the control of the macro @@code{COFF_LONG_SECTION_NAMES}.  If not
	defined, the format does not support long section names in any way.
	If defined, it is used to initialise a flag,
	@@code{_bfd_coff_long_section_names}, and a hook function pointer,
	@@code{_bfd_coff_set_long_section_names}, in the Coff backend data
	structure.  The flag controls the generation of long section names
	in output BFDs at runtime; if it is false, as it will be by default
	when generating an executable image, long section names are truncated;
	if true, the long section names extension is employed.  The hook
	points to a function that allows the value of the flag to be altered
	at runtime, on formats that support long section names at all; on
	other formats it points to a stub that returns an error indication.

	With input BFDs, the flag is set according to whether any long section
	names are detected while reading the section headers.  For a completely
	new BFD, the flag is set to the default for the target format.  This
	information can be used by a client of the BFD library when deciding
	what output format to generate, and means that a BFD that is opened
	for read and subsequently converted to a writeable BFD and modified
	in-place will retain whatever format it had on input.

	If @@code{COFF_LONG_SECTION_NAMES} is simply defined (blank), or is
	defined to the value "1", then long section names are enabled by
	default; if it is defined to the value zero, they are disabled by
	default (but still accepted in input BFDs).  The header @@file{coffcode.h}
	defines a macro, @@code{COFF_DEFAULT_LONG_SECTION_NAMES}, which is
	used in the backends to initialise the backend data structure fields
	appropriately; see the comments for further detail.

SUBSUBSECTION
	Bit twiddling

	Each flavour of coff supported in BFD has its own header file
	describing the external layout of the structures. There is also
	an internal description of the coff layout, in
	@@file{coff/internal.h}. A major function of the
	coff backend is swapping the bytes and twiddling the bits to
	translate the external form of the structures into the normal
	internal form. This is all performed in the
	@@code{bfd_swap}_@@i{thing}_@@i{direction} routines. Some
	elements are different sizes between different versions of
	coff; it is the duty of the coff version specific include file
	to override the definitions of various packing routines in
	@@file{coffcode.h}. E.g., the size of line number entry in coff is
	sometimes 16 bits, and sometimes 32 bits. @@code{#define}ing
	@@code{PUT_LNSZ_LNNO} and @@code{GET_LNSZ_LNNO} will select the
	correct one. No doubt, some day someone will find a version of
	coff which has a varying field size not catered to at the
	moment. To port BFD, that person will have to add more @@code{#defines}.
	Three of the bit twiddling routines are exported to
	@@code{gdb}; @@code{coff_swap_aux_in}, @@code{coff_swap_sym_in}
	and @@code{coff_swap_lineno_in}. @@code{GDB} reads the symbol
	table on its own, but uses BFD to fix things up.  More of the
	bit twiddlers are exported for @@code{gas};
	@@code{coff_swap_aux_out}, @@code{coff_swap_sym_out},
	@@code{coff_swap_lineno_out}, @@code{coff_swap_reloc_out},
	@@code{coff_swap_filehdr_out}, @@code{coff_swap_aouthdr_out},
	@@code{coff_swap_scnhdr_out}. @@code{Gas} currently keeps track
	of all the symbol table and reloc drudgery itself, thereby
	saving the internal BFD overhead, but uses BFD to swap things
	on the way out, making cross ports much safer.  Doing so also
	allows BFD (and thus the linker) to use the same header files
	as @@code{gas}, which makes one avenue to disaster disappear.

SUBSUBSECTION
	Symbol reading

	The simple canonical form for symbols used by BFD is not rich
	enough to keep all the information available in a coff symbol
	table. The back end gets around this problem by keeping the original
	symbol table around, "behind the scenes".

	When a symbol table is requested (through a call to
	@@code{bfd_canonicalize_symtab}), a request gets through to
	@@code{coff_get_normalized_symtab}. This reads the symbol table from
	the coff file and swaps all the structures inside into the
	internal form. It also fixes up all the pointers in the table
	(represented in the file by offsets from the first symbol in
	the table) into physical pointers to elements in the new
	internal table. This involves some work since the meanings of
	fields change depending upon context: a field that is a
	pointer to another structure in the symbol table at one moment
	may be the size in bytes of a structure at the next.  Another
	pass is made over the table. All symbols which mark file names
	(<<C_FILE>> symbols) are modified so that the internal
	string points to the value in the auxent (the real filename)
	rather than the normal text associated with the symbol
	(@@code{".file"}).

	At this time the symbol names are moved around. Coff stores
	all symbols less than nine characters long physically
	within the symbol table; longer strings are kept at the end of
	the file in the string table. This pass moves all strings
	into memory and replaces them with pointers to the strings.

	The symbol table is massaged once again, this time to create
	the canonical table used by the BFD application. Each symbol
	is inspected in turn, and a decision made (using the
	@@code{sclass} field) about the various flags to set in the
	@@code{asymbol}.  @@xref{Symbols}. The generated canonical table
	shares strings with the hidden internal symbol table.

	Any linenumbers are read from the coff file too, and attached
	to the symbols which own the functions the linenumbers belong to.

SUBSUBSECTION
	Symbol writing

	Writing a symbol to a coff file which didn't come from a coff
	file will lose any debugging information. The @@code{asymbol}
	structure remembers the BFD from which the symbol was taken, and on
	output the back end makes sure that the same destination target as
	source target is present.

	When the symbols have come from a coff file then all the
	debugging information is preserved.

	Symbol tables are provided for writing to the back end in a
	vector of pointers to pointers. This allows applications like
	the linker to accumulate and output large symbol tables
	without having to do too much byte copying.

	This function runs through the provided symbol table and
	patches each symbol marked as a file place holder
	(@@code{C_FILE}) to point to the next file place holder in the
	list. It also marks each @@code{offset} field in the list with
	the offset from the first symbol of the current symbol.

	Another function of this procedure is to turn the canonical
	value form of BFD into the form used by coff. Internally, BFD
	expects symbol values to be offsets from a section base; so a
	symbol physically at 0x120, but in a section starting at
	0x100, would have the value 0x20. Coff expects symbols to
	contain their final value, so symbols have their values
	changed at this point to reflect their sum with their owning
	section.  This transformation uses the
	<<output_section>> field of the @@code{asymbol}'s
	@@code{asection} @@xref{Sections}.

	o <<coff_mangle_symbols>>

	This routine runs though the provided symbol table and uses
	the offsets generated by the previous pass and the pointers
	generated when the symbol table was read in to create the
	structured hierarchy required by coff. It changes each pointer
	to a symbol into the index into the symbol table of the asymbol.

	o <<coff_write_symbols>>

	This routine runs through the symbol table and patches up the
	symbols from their internal form into the coff way, calls the
	bit twiddlers, and writes out the table to the file.

*/

/*
INTERNAL_DEFINITION
	coff_symbol_type

DESCRIPTION
	The hidden information for an <<asymbol>> is described in a
	<<combined_entry_type>>:

CODE_FRAGMENT
.
.typedef struct coff_ptr_struct
.{
.  {* Remembers the offset from the first symbol in the file for
.     this symbol. Generated by coff_renumber_symbols. *}
.  unsigned int offset;
.
.  {* Should the value of this symbol be renumbered.  Used for
.     XCOFF C_BSTAT symbols.  Set by coff_slurp_symbol_table.  *}
.  unsigned int fix_value : 1;
.
.  {* Should the tag field of this symbol be renumbered.
.     Created by coff_pointerize_aux. *}
.  unsigned int fix_tag : 1;
.
.  {* Should the endidx field of this symbol be renumbered.
.     Created by coff_pointerize_aux. *}
.  unsigned int fix_end : 1;
.
.  {* Should the x_csect.x_scnlen field be renumbered.
.     Created by coff_pointerize_aux. *}
.  unsigned int fix_scnlen : 1;
.
.  {* Fix up an XCOFF C_BINCL/C_EINCL symbol.  The value is the
.     index into the line number entries.  Set by coff_slurp_symbol_table.  *}
.  unsigned int fix_line : 1;
.
.  {* The container for the symbol structure as read and translated
.     from the file. *}
.  union
.  {
.    union internal_auxent auxent;
.    struct internal_syment syment;
.  } u;
.} combined_entry_type;
.
.
.{* Each canonical asymbol really looks like this: *}
.
.typedef struct coff_symbol_struct
.{
.  {* The actual symbol which the rest of BFD works with *}
.  asymbol symbol;
.
.  {* A pointer to the hidden information for this symbol *}
.  combined_entry_type *native;
.
.  {* A pointer to the linenumber information for this symbol *}
.  struct lineno_cache_entry *lineno;
.
.  {* Have the line numbers been relocated yet ? *}
.  bfd_boolean done_lineno;
.} coff_symbol_type;

*/

#include "libiberty.h"

#ifdef COFF_WITH_PE
#include "peicode.h"
#else
#include "coffswap.h"
#endif

#define STRING_SIZE_SIZE 4

#define DOT_DEBUG	".debug"
#define DOT_ZDEBUG	".zdebug"
#define GNU_LINKONCE_WI ".gnu.linkonce.wi."
#define GNU_LINKONCE_WT ".gnu.linkonce.wt."
#define DOT_RELOC	".reloc"

#if defined (COFF_LONG_SECTION_NAMES)
/* Needed to expand the inputs to BLANKOR1TOODD.  */
#define COFFLONGSECTIONCATHELPER(x,y)    x ## y
/* If the input macro Y is blank or '1', return an odd number; if it is
   '0', return an even number.  Result undefined in all other cases.  */
#define BLANKOR1TOODD(y)                 COFFLONGSECTIONCATHELPER(1,y)
/* Defined to numerical 0 or 1 according to whether generation of long
   section names is disabled or enabled by default.  */
#define COFF_ENABLE_LONG_SECTION_NAMES   (BLANKOR1TOODD(COFF_LONG_SECTION_NAMES) & 1)
/* Where long section names are supported, we allow them to be enabled
   and disabled at runtime, so select an appropriate hook function for
   _bfd_coff_set_long_section_names.  */
#define COFF_LONG_SECTION_NAMES_SETTER   bfd_coff_set_long_section_names_allowed
#else /* !defined (COFF_LONG_SECTION_NAMES) */
/* If long section names are not supported, this stub disallows any
   attempt to enable them at run-time.  */
#define COFF_LONG_SECTION_NAMES_SETTER   bfd_coff_set_long_section_names_disallowed
#endif /* defined (COFF_LONG_SECTION_NAMES) */

/* Define a macro that can be used to initialise both the fields relating
   to long section names in the backend data struct simultaneously.  */
#if COFF_ENABLE_LONG_SECTION_NAMES
#define COFF_DEFAULT_LONG_SECTION_NAMES  (TRUE), COFF_LONG_SECTION_NAMES_SETTER
#else /* !COFF_ENABLE_LONG_SECTION_NAMES */
#define COFF_DEFAULT_LONG_SECTION_NAMES  (FALSE), COFF_LONG_SECTION_NAMES_SETTER
#endif /* COFF_ENABLE_LONG_SECTION_NAMES */

#if defined (COFF_LONG_SECTION_NAMES)
static bfd_boolean bfd_coff_set_long_section_names_allowed
  (bfd *, int);
#else /* !defined (COFF_LONG_SECTION_NAMES) */
static bfd_boolean bfd_coff_set_long_section_names_disallowed
  (bfd *, int);
#endif /* defined (COFF_LONG_SECTION_NAMES) */
static long sec_to_styp_flags
  (const char *, flagword);
static bfd_boolean styp_to_sec_flags
  (bfd *, void *, const char *, asection *, flagword *);
static bfd_boolean coff_bad_format_hook
  (bfd *, void *);
static void coff_set_custom_section_alignment
  (bfd *, asection *, const struct coff_section_alignment_entry *,
   const unsigned int);
static bfd_boolean coff_new_section_hook
  (bfd *, asection *);
static bfd_boolean coff_set_arch_mach_hook
  (bfd *, void *);
static bfd_boolean coff_write_relocs
  (bfd *, int);
static bfd_boolean coff_set_flags
  (bfd *, unsigned int *, unsigned short *);
static bfd_boolean coff_set_arch_mach
  (bfd *, enum bfd_architecture, unsigned long) ATTRIBUTE_UNUSED;
static bfd_boolean coff_compute_section_file_positions
  (bfd *);
static bfd_boolean coff_write_object_contents
  (bfd *) ATTRIBUTE_UNUSED;
static bfd_boolean coff_set_section_contents
  (bfd *, asection *, const void *, file_ptr, bfd_size_type);
static void * buy_and_read
  (bfd *, file_ptr, bfd_size_type);
static bfd_boolean coff_slurp_line_table
  (bfd *, asection *);
static bfd_boolean coff_slurp_symbol_table
  (bfd *);
static enum coff_symbol_classification coff_classify_symbol
  (bfd *, struct internal_syment *);
static bfd_boolean coff_slurp_reloc_table
  (bfd *, asection *, asymbol **);
static long coff_canonicalize_reloc
  (bfd *, asection *, arelent **, asymbol **);
#ifndef coff_mkobject_hook
static void * coff_mkobject_hook
  (bfd *, void *,  void *);
#endif
#ifdef COFF_WITH_PE
static flagword handle_COMDAT
  (bfd *, flagword, void *, const char *, asection *);
#endif
#ifdef COFF_IMAGE_WITH_PE
static bfd_boolean coff_read_word
  (bfd *, unsigned int *);
static unsigned int coff_compute_checksum
  (bfd *);
static bfd_boolean coff_apply_checksum
  (bfd *);
#endif
#ifdef TICOFF
static bfd_boolean ticoff0_bad_format_hook
  (bfd *, void * );
static bfd_boolean ticoff1_bad_format_hook
  (bfd *, void * );
#endif

/* void warning(); */

#if defined (COFF_LONG_SECTION_NAMES)
static bfd_boolean
bfd_coff_set_long_section_names_allowed (bfd *abfd, int enable)
{
  coff_backend_info (abfd)->_bfd_coff_long_section_names = enable;
  return TRUE;
}
#else /* !defined (COFF_LONG_SECTION_NAMES) */
static bfd_boolean
bfd_coff_set_long_section_names_disallowed (bfd *abfd, int enable)
{
  (void) abfd;
  (void) enable;
  return FALSE;
}
#endif /* defined (COFF_LONG_SECTION_NAMES) */

/* Return a word with STYP_* (scnhdr.s_flags) flags set to represent
   the incoming SEC_* flags.  The inverse of this function is
   styp_to_sec_flags().  NOTE: If you add to/change this routine, you
   should probably mirror the changes in styp_to_sec_flags().  */

#ifndef COFF_WITH_PE

/* Macros for setting debugging flags.  */

#ifdef STYP_DEBUG
#define STYP_XCOFF_DEBUG STYP_DEBUG
#else
#define STYP_XCOFF_DEBUG STYP_INFO
#endif

#ifdef COFF_ALIGN_IN_S_FLAGS
#define STYP_DEBUG_INFO STYP_DSECT
#else
#define STYP_DEBUG_INFO STYP_INFO
#endif

static long
sec_to_styp_flags (const char *sec_name, flagword sec_flags)
{
  long styp_flags = 0;

  if (!strcmp (sec_name, _TEXT))
    {
      styp_flags = STYP_TEXT;
    }
  else if (!strcmp (sec_name, _DATA))
    {
      styp_flags = STYP_DATA;
    }
  else if (!strcmp (sec_name, _BSS))
    {
      styp_flags = STYP_BSS;
#ifdef _COMMENT
    }
  else if (!strcmp (sec_name, _COMMENT))
    {
      styp_flags = STYP_INFO;
#endif /* _COMMENT */
#ifdef _LIB
    }
  else if (!strcmp (sec_name, _LIB))
    {
      styp_flags = STYP_LIB;
#endif /* _LIB */
#ifdef _LIT
    }
  else if (!strcmp (sec_name, _LIT))
    {
      styp_flags = STYP_LIT;
#endif /* _LIT */
    }
  else if (CONST_STRNEQ (sec_name, DOT_DEBUG)
           || CONST_STRNEQ (sec_name, DOT_ZDEBUG))
    {
      /* Handle the XCOFF debug section and DWARF2 debug sections.  */
      if (!sec_name[6])
	styp_flags = STYP_XCOFF_DEBUG;
      else
	styp_flags = STYP_DEBUG_INFO;
    }
  else if (CONST_STRNEQ (sec_name, ".stab"))
    {
      styp_flags = STYP_DEBUG_INFO;
    }
#ifdef COFF_LONG_SECTION_NAMES
  else if (CONST_STRNEQ (sec_name, GNU_LINKONCE_WI)
  	   || CONST_STRNEQ (sec_name, GNU_LINKONCE_WT))
    {
      styp_flags = STYP_DEBUG_INFO;
    }
#endif
#ifdef RS6000COFF_C
  else if (!strcmp (sec_name, _PAD))
    {
      styp_flags = STYP_PAD;
    }
  else if (!strcmp (sec_name, _LOADER))
    {
      styp_flags = STYP_LOADER;
    }
  else if (!strcmp (sec_name, _EXCEPT))
    {
      styp_flags = STYP_EXCEPT;
    }
  else if (!strcmp (sec_name, _TYPCHK))
    {
      styp_flags = STYP_TYPCHK;
    }
  else if (sec_flags & SEC_DEBUGGING)
    {
      int i;

      for (i = 0; i < XCOFF_DWSECT_NBR_NAMES; i++)
        if (!strcmp (sec_name, xcoff_dwsect_names[i].name))
          {
            styp_flags = STYP_DWARF | xcoff_dwsect_names[i].flag;
            break;
          }
    }
#endif
  /* Try and figure out what it should be */
  else if (sec_flags & SEC_CODE)
    {
      styp_flags = STYP_TEXT;
    }
  else if (sec_flags & SEC_DATA)
    {
      styp_flags = STYP_DATA;
    }
  else if (sec_flags & SEC_READONLY)
    {
#ifdef STYP_LIT			/* 29k readonly text/data section */
      styp_flags = STYP_LIT;
#else
      styp_flags = STYP_TEXT;
#endif /* STYP_LIT */
    }
  else if (sec_flags & SEC_LOAD)
    {
      styp_flags = STYP_TEXT;
    }
  else if (sec_flags & SEC_ALLOC)
    {
      styp_flags = STYP_BSS;
    }

#ifdef STYP_CLINK
  if (sec_flags & SEC_TIC54X_CLINK)
    styp_flags |= STYP_CLINK;
#endif

#ifdef STYP_BLOCK
  if (sec_flags & SEC_TIC54X_BLOCK)
    styp_flags |= STYP_BLOCK;
#endif

#ifdef STYP_NOLOAD
  if ((sec_flags & (SEC_NEVER_LOAD | SEC_COFF_SHARED_LIBRARY)) != 0)
    styp_flags |= STYP_NOLOAD;
#endif

  return styp_flags;
}

#else /* COFF_WITH_PE */

/* The PE version; see above for the general comments.  The non-PE
   case seems to be more guessing, and breaks PE format; specifically,
   .rdata is readonly, but it sure ain't text.  Really, all this
   should be set up properly in gas (or whatever assembler is in use),
   and honor whatever objcopy/strip, etc. sent us as input.  */

static long
sec_to_styp_flags (const char *sec_name, flagword sec_flags)
{
  long styp_flags = 0;
  bfd_boolean is_dbg = FALSE;

  if (CONST_STRNEQ (sec_name, DOT_DEBUG)
      || CONST_STRNEQ (sec_name, DOT_ZDEBUG)
#ifdef COFF_LONG_SECTION_NAMES
      || CONST_STRNEQ (sec_name, GNU_LINKONCE_WI)
      || CONST_STRNEQ (sec_name, GNU_LINKONCE_WT)
#endif
      || CONST_STRNEQ (sec_name, ".stab"))
    is_dbg = TRUE;

  /* caution: there are at least three groups of symbols that have
     very similar bits and meanings: IMAGE_SCN*, SEC_*, and STYP_*.
     SEC_* are the BFD internal flags, used for generic BFD
     information.  STYP_* are the COFF section flags which appear in
     COFF files.  IMAGE_SCN_* are the PE section flags which appear in
     PE files.  The STYP_* flags and the IMAGE_SCN_* flags overlap,
     but there are more IMAGE_SCN_* flags.  */

  /* FIXME: There is no gas syntax to specify the debug section flag.  */
  if (is_dbg)
    {
      sec_flags &= (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD
      		    | SEC_LINK_DUPLICATES_SAME_CONTENTS
      		    | SEC_LINK_DUPLICATES_SAME_SIZE);
      sec_flags |= SEC_DEBUGGING | SEC_READONLY;
    }

  /* skip LOAD */
  /* READONLY later */
  /* skip RELOC */
  if ((sec_flags & SEC_CODE) != 0)
    styp_flags |= IMAGE_SCN_CNT_CODE;
  if ((sec_flags & (SEC_DATA | SEC_DEBUGGING)) != 0)
    styp_flags |= IMAGE_SCN_CNT_INITIALIZED_DATA;
  if ((sec_flags & SEC_ALLOC) != 0 && (sec_flags & SEC_LOAD) == 0)
    styp_flags |= IMAGE_SCN_CNT_UNINITIALIZED_DATA;  /* ==STYP_BSS */
  /* skip ROM */
  /* skip constRUCTOR */
  /* skip CONTENTS */
  if ((sec_flags & SEC_IS_COMMON) != 0)
    styp_flags |= IMAGE_SCN_LNK_COMDAT;
  if ((sec_flags & SEC_DEBUGGING) != 0)
    styp_flags |= IMAGE_SCN_MEM_DISCARDABLE;
  if ((sec_flags & SEC_EXCLUDE) != 0 && !is_dbg)
    styp_flags |= IMAGE_SCN_LNK_REMOVE;
  if ((sec_flags & SEC_NEVER_LOAD) != 0 && !is_dbg)
    styp_flags |= IMAGE_SCN_LNK_REMOVE;
  /* skip IN_MEMORY */
  /* skip SORT */
  if (sec_flags & SEC_LINK_ONCE)
    styp_flags |= IMAGE_SCN_LNK_COMDAT;
  if ((sec_flags
       & (SEC_LINK_DUPLICATES_DISCARD | SEC_LINK_DUPLICATES_SAME_CONTENTS
          | SEC_LINK_DUPLICATES_SAME_SIZE)) != 0)
    styp_flags |= IMAGE_SCN_LNK_COMDAT;

  /* skip LINKER_CREATED */

  if ((sec_flags & SEC_COFF_NOREAD) == 0)
    styp_flags |= IMAGE_SCN_MEM_READ;     /* Invert NOREAD for read.  */
  if ((sec_flags & SEC_READONLY) == 0)
    styp_flags |= IMAGE_SCN_MEM_WRITE;    /* Invert READONLY for write.  */
  if (sec_flags & SEC_CODE)
    styp_flags |= IMAGE_SCN_MEM_EXECUTE;  /* CODE->EXECUTE.  */
  if (sec_flags & SEC_COFF_SHARED)
    styp_flags |= IMAGE_SCN_MEM_SHARED;   /* Shared remains meaningful.  */

  return styp_flags;
}

#endif /* COFF_WITH_PE */

/* Return a word with SEC_* flags set to represent the incoming STYP_*
   flags (from scnhdr.s_flags).  The inverse of this function is
   sec_to_styp_flags().  NOTE: If you add to/change this routine, you
   should probably mirror the changes in sec_to_styp_flags().  */

#ifndef COFF_WITH_PE

static bfd_boolean
styp_to_sec_flags (bfd *abfd ATTRIBUTE_UNUSED,
		   void * hdr,
		   const char *name,
		   asection *section ATTRIBUTE_UNUSED,
		   flagword *flags_ptr)
{
  struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
  long styp_flags = internal_s->s_flags;
  flagword sec_flags = 0;

#ifdef STYP_BLOCK
  if (styp_flags & STYP_BLOCK)
    sec_flags |= SEC_TIC54X_BLOCK;
#endif

#ifdef STYP_CLINK
  if (styp_flags & STYP_CLINK)
    sec_flags |= SEC_TIC54X_CLINK;
#endif

#ifdef STYP_NOLOAD
  if (styp_flags & STYP_NOLOAD)
    sec_flags |= SEC_NEVER_LOAD;
#endif /* STYP_NOLOAD */

  /* For 386 COFF, at least, an unloadable text or data section is
     actually a shared library section.  */
  if (styp_flags & STYP_TEXT)
    {
      if (sec_flags & SEC_NEVER_LOAD)
	sec_flags |= SEC_CODE | SEC_COFF_SHARED_LIBRARY;
      else
	sec_flags |= SEC_CODE | SEC_LOAD | SEC_ALLOC;
    }
  else if (styp_flags & STYP_DATA)
    {
      if (sec_flags & SEC_NEVER_LOAD)
	sec_flags |= SEC_DATA | SEC_COFF_SHARED_LIBRARY;
      else
	sec_flags |= SEC_DATA | SEC_LOAD | SEC_ALLOC;
    }
  else if (styp_flags & STYP_BSS)
    {
#ifdef BSS_NOLOAD_IS_SHARED_LIBRARY
      if (sec_flags & SEC_NEVER_LOAD)
	sec_flags |= SEC_ALLOC | SEC_COFF_SHARED_LIBRARY;
      else
#endif
	sec_flags |= SEC_ALLOC;
    }
  else if (styp_flags & STYP_INFO)
    {
      /* We mark these as SEC_DEBUGGING, but only if COFF_PAGE_SIZE is
	 defined.  coff_compute_section_file_positions uses
	 COFF_PAGE_SIZE to ensure that the low order bits of the
	 section VMA and the file offset match.  If we don't know
	 COFF_PAGE_SIZE, we can't ensure the correct correspondence,
	 and demand page loading of the file will fail.  */
#if defined (COFF_PAGE_SIZE) && !defined (COFF_ALIGN_IN_S_FLAGS)
      sec_flags |= SEC_DEBUGGING;
#endif
    }
  else if (styp_flags & STYP_PAD)
    sec_flags = 0;
#ifdef RS6000COFF_C
  else if (styp_flags & STYP_EXCEPT)
    sec_flags |= SEC_LOAD;
  else if (styp_flags & STYP_LOADER)
    sec_flags |= SEC_LOAD;
  else if (styp_flags & STYP_TYPCHK)
    sec_flags |= SEC_LOAD;
  else if (styp_flags & STYP_DWARF)
    sec_flags |= SEC_DEBUGGING;
#endif
  else if (strcmp (name, _TEXT) == 0)
    {
      if (sec_flags & SEC_NEVER_LOAD)
	sec_flags |= SEC_CODE | SEC_COFF_SHARED_LIBRARY;
      else
	sec_flags |= SEC_CODE | SEC_LOAD | SEC_ALLOC;
    }
  else if (strcmp (name, _DATA) == 0)
    {
      if (sec_flags & SEC_NEVER_LOAD)
	sec_flags |= SEC_DATA | SEC_COFF_SHARED_LIBRARY;
      else
	sec_flags |= SEC_DATA | SEC_LOAD | SEC_ALLOC;
    }
  else if (strcmp (name, _BSS) == 0)
    {
#ifdef BSS_NOLOAD_IS_SHARED_LIBRARY
      if (sec_flags & SEC_NEVER_LOAD)
	sec_flags |= SEC_ALLOC | SEC_COFF_SHARED_LIBRARY;
      else
#endif
	sec_flags |= SEC_ALLOC;
    }
  else if (CONST_STRNEQ (name, DOT_DEBUG)
	   || CONST_STRNEQ (name, DOT_ZDEBUG)
#ifdef _COMMENT
	   || strcmp (name, _COMMENT) == 0
#endif
#ifdef COFF_LONG_SECTION_NAMES
	   || CONST_STRNEQ (name, GNU_LINKONCE_WI)
	   || CONST_STRNEQ (name, GNU_LINKONCE_WT)
#endif
	   || CONST_STRNEQ (name, ".stab"))
    {
#ifdef COFF_PAGE_SIZE
      sec_flags |= SEC_DEBUGGING;
#endif
    }
#ifdef _LIB
  else if (strcmp (name, _LIB) == 0)
    ;
#endif
#ifdef _LIT
  else if (strcmp (name, _LIT) == 0)
    sec_flags = SEC_LOAD | SEC_ALLOC | SEC_READONLY;
#endif
  else
    sec_flags |= SEC_ALLOC | SEC_LOAD;

#ifdef STYP_LIT			/* A29k readonly text/data section type.  */
  if ((styp_flags & STYP_LIT) == STYP_LIT)
    sec_flags = (SEC_LOAD | SEC_ALLOC | SEC_READONLY);
#endif /* STYP_LIT */

#ifdef STYP_OTHER_LOAD		/* Other loaded sections.  */
  if (styp_flags & STYP_OTHER_LOAD)
    sec_flags = (SEC_LOAD | SEC_ALLOC);
#endif /* STYP_SDATA */

#if defined (COFF_LONG_SECTION_NAMES) && defined (COFF_SUPPORT_GNU_LINKONCE)
  /* As a GNU extension, if the name begins with .gnu.linkonce, we
     only link a single copy of the section.  This is used to support
     g++.  g++ will emit each template expansion in its own section.
     The symbols will be defined as weak, so that multiple definitions
     are permitted.  The GNU linker extension is to actually discard
     all but one of the sections.  */
  if (CONST_STRNEQ (name, ".gnu.linkonce"))
    sec_flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
#endif

  if (flags_ptr == NULL)
    return FALSE;

  * flags_ptr = sec_flags;
  return TRUE;
}

#else /* COFF_WITH_PE */

static flagword
handle_COMDAT (bfd * abfd,
	       flagword sec_flags,
	       void * hdr,
	       const char *name,
	       asection *section)
{
  struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
  bfd_byte *esymstart, *esym, *esymend;
  int seen_state = 0;
  char *target_name = NULL;

  sec_flags |= SEC_LINK_ONCE;

  /* Unfortunately, the PE format stores essential information in
     the symbol table, of all places.  We need to extract that
     information now, so that objdump and the linker will know how
     to handle the section without worrying about the symbols.  We
     can't call slurp_symtab, because the linker doesn't want the
     swapped symbols.  */

  /* COMDAT sections are special.  The first symbol is the section
     symbol, which tells what kind of COMDAT section it is.  The
     second symbol is the "comdat symbol" - the one with the
     unique name.  GNU uses the section symbol for the unique
     name; MS uses ".text" for every comdat section.  Sigh.  - DJ */

  /* This is not mirrored in sec_to_styp_flags(), but there
     doesn't seem to be a need to, either, and it would at best be
     rather messy.  */

  if (! _bfd_coff_get_external_symbols (abfd))
    return sec_flags;

  esymstart = esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esymend = esym + obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd);

  while (esym < esymend)
    {
      struct internal_syment isym;
      char buf[SYMNMLEN + 1];
      const char *symname;

      bfd_coff_swap_sym_in (abfd, esym, & isym);

      if (sizeof (internal_s->s_name) > SYMNMLEN)
	{
	  /* This case implies that the matching
	     symbol name will be in the string table.  */
	  abort ();
	}

      if (isym.n_scnum == section->target_index)
	{
	  /* According to the MSVC documentation, the first
	     TWO entries with the section # are both of
	     interest to us.  The first one is the "section
	     symbol" (section name).  The second is the comdat
	     symbol name.  Here, we've found the first
	     qualifying entry; we distinguish it from the
	     second with a state flag.

	     In the case of gas-generated (at least until that
	     is fixed) .o files, it isn't necessarily the
	     second one.  It may be some other later symbol.

	     Since gas also doesn't follow MS conventions and
	     emits the section similar to .text$<name>, where
	     <something> is the name we're looking for, we
	     distinguish the two as follows:

	     If the section name is simply a section name (no
	     $) we presume it's MS-generated, and look at
	     precisely the second symbol for the comdat name.
	     If the section name has a $, we assume it's
	     gas-generated, and look for <something> (whatever
	     follows the $) as the comdat symbol.  */

	  /* All 3 branches use this.  */
	  symname = _bfd_coff_internal_syment_name (abfd, &isym, buf);

	  if (symname == NULL)
	    abort ();

	  switch (seen_state)
	    {
	    case 0:
	      {
		/* The first time we've seen the symbol.  */
		union internal_auxent aux;

		/* If it isn't the stuff we're expecting, die;
		   The MS documentation is vague, but it
		   appears that the second entry serves BOTH
		   as the comdat symbol and the defining
		   symbol record (either C_STAT or C_EXT,
		   possibly with an aux entry with debug
		   information if it's a function.)  It
		   appears the only way to find the second one
		   is to count.  (On Intel, they appear to be
		   adjacent, but on Alpha, they have been
		   found separated.)

		   Here, we think we've found the first one,
		   but there's some checking we can do to be
		   sure.  */

		if (! ((isym.n_sclass == C_STAT
			|| isym.n_sclass == C_EXT)
		       && BTYPE (isym.n_type) == T_NULL
		       && isym.n_value == 0))
		  abort ();

		/* FIXME LATER: MSVC generates section names
		   like .text for comdats.  Gas generates
		   names like .text$foo__Fv (in the case of a
		   function).  See comment above for more.  */

		if (isym.n_sclass == C_STAT && strcmp (name, symname) != 0)
		  _bfd_error_handler (_("%B: warning: COMDAT symbol '%s' does not match section name '%s'"),
				      abfd, symname, name);

		seen_state = 1;

		/* This is the section symbol.  */
		bfd_coff_swap_aux_in (abfd, (esym + bfd_coff_symesz (abfd)),
				      isym.n_type, isym.n_sclass,
				      0, isym.n_numaux, & aux);

		target_name = strchr (name, '$');
		if (target_name != NULL)
		  {
		    /* Gas mode.  */
		    seen_state = 2;
		    /* Skip the `$'.  */
		    target_name += 1;
		  }

		/* FIXME: Microsoft uses NODUPLICATES and
		   ASSOCIATIVE, but gnu uses ANY and
		   SAME_SIZE.  Unfortunately, gnu doesn't do
		   the comdat symbols right.  So, until we can
		   fix it to do the right thing, we are
		   temporarily disabling comdats for the MS
		   types (they're used in DLLs and C++, but we
		   don't support *their* C++ libraries anyway
		   - DJ.  */

		/* Cygwin does not follow the MS style, and
		   uses ANY and SAME_SIZE where NODUPLICATES
		   and ASSOCIATIVE should be used.  For
		   Interix, we just do the right thing up
		   front.  */

		switch (aux.x_scn.x_comdat)
		  {
		  case IMAGE_COMDAT_SELECT_NODUPLICATES:
#ifdef STRICT_PE_FORMAT
		    sec_flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
#else
		    sec_flags &= ~SEC_LINK_ONCE;
#endif
		    break;

		  case IMAGE_COMDAT_SELECT_ANY:
		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
		    break;

		  case IMAGE_COMDAT_SELECT_SAME_SIZE:
		    sec_flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
		    break;

		  case IMAGE_COMDAT_SELECT_EXACT_MATCH:
		    /* Not yet fully implemented ??? */
		    sec_flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
		    break;

		    /* debug$S gets this case; other
		       implications ??? */

		    /* There may be no symbol... we'll search
		       the whole table... Is this the right
		       place to play this game? Or should we do
		       it when reading it in.  */
		  case IMAGE_COMDAT_SELECT_ASSOCIATIVE:
#ifdef STRICT_PE_FORMAT
		    /* FIXME: This is not currently implemented.  */
		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
#else
		    sec_flags &= ~SEC_LINK_ONCE;
#endif
		    break;

		  default:  /* 0 means "no symbol" */
		    /* debug$F gets this case; other
		       implications ??? */
		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
		    break;
		  }
	      }
	      break;

	    case 2:
	      /* Gas mode: the first matching on partial name.  */

#ifndef TARGET_UNDERSCORE
#define TARGET_UNDERSCORE 0
#endif
	      /* Is this the name we're looking for ?  */
	      if (strcmp (target_name,
			  symname + (TARGET_UNDERSCORE ? 1 : 0)) != 0)
		{
		  /* Not the name we're looking for */
		  esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd);
		  continue;
		}
	      /* Fall through.  */
	    case 1:
	      /* MSVC mode: the lexically second symbol (or
		 drop through from the above).  */
	      {
		char *newname;
		bfd_size_type amt;

		/* This must the second symbol with the
		   section #.  It is the actual symbol name.
		   Intel puts the two adjacent, but Alpha (at
		   least) spreads them out.  */

		amt = sizeof (struct coff_comdat_info);
		coff_section_data (abfd, section)->comdat
		  = (struct coff_comdat_info *) bfd_alloc (abfd, amt);
		if (coff_section_data (abfd, section)->comdat == NULL)
		  abort ();

		coff_section_data (abfd, section)->comdat->symbol =
		  (esym - esymstart) / bfd_coff_symesz (abfd);

		amt = strlen (symname) + 1;
		newname = (char *) bfd_alloc (abfd, amt);
		if (newname == NULL)
		  abort ();

		strcpy (newname, symname);
		coff_section_data (abfd, section)->comdat->name
		  = newname;
	      }

	      goto breakloop;
	    }
	}

      esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd);
    }

 breakloop:
  return sec_flags;
}


/* The PE version; see above for the general comments.

   Since to set the SEC_LINK_ONCE and associated flags, we have to
   look at the symbol table anyway, we return the symbol table index
   of the symbol being used as the COMDAT symbol.  This is admittedly
   ugly, but there's really nowhere else that we have access to the
   required information.  FIXME: Is the COMDAT symbol index used for
   any purpose other than objdump?  */

static bfd_boolean
styp_to_sec_flags (bfd *abfd,
		   void * hdr,
		   const char *name,
		   asection *section,
		   flagword *flags_ptr)
{
  struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
  long styp_flags = internal_s->s_flags;
  flagword sec_flags;
  bfd_boolean result = TRUE;
  bfd_boolean is_dbg = FALSE;

  if (CONST_STRNEQ (name, DOT_DEBUG)
      || CONST_STRNEQ (name, DOT_ZDEBUG)
#ifdef COFF_LONG_SECTION_NAMES
      || CONST_STRNEQ (name, GNU_LINKONCE_WI)
      || CONST_STRNEQ (name, GNU_LINKONCE_WT)
#endif
      || CONST_STRNEQ (name, ".stab"))
    is_dbg = TRUE;
  /* Assume read only unless IMAGE_SCN_MEM_WRITE is specified.  */
  sec_flags = SEC_READONLY;

  /* If section disallows read, then set the NOREAD flag. */
  if ((styp_flags & IMAGE_SCN_MEM_READ) == 0)
    sec_flags |= SEC_COFF_NOREAD;

  /* Process each flag bit in styp_flags in turn.  */
  while (styp_flags)
    {
      long flag = styp_flags & - styp_flags;
      char * unhandled = NULL;

      styp_flags &= ~ flag;

      /* We infer from the distinct read/write/execute bits the settings
	 of some of the bfd flags; the actual values, should we need them,
	 are also in pei_section_data (abfd, section)->pe_flags.  */

      switch (flag)
	{
	case STYP_DSECT:
	  unhandled = "STYP_DSECT";
	  break;
	case STYP_GROUP:
	  unhandled = "STYP_GROUP";
	  break;
	case STYP_COPY:
	  unhandled = "STYP_COPY";
	  break;
	case STYP_OVER:
	  unhandled = "STYP_OVER";
	  break;
#ifdef SEC_NEVER_LOAD
	case STYP_NOLOAD:
	  sec_flags |= SEC_NEVER_LOAD;
	  break;
#endif
	case IMAGE_SCN_MEM_READ:
	  sec_flags &= ~SEC_COFF_NOREAD;
	  break;
	case IMAGE_SCN_TYPE_NO_PAD:
	  /* Skip.  */
	  break;
	case IMAGE_SCN_LNK_OTHER:
	  unhandled = "IMAGE_SCN_LNK_OTHER";
	  break;
	case IMAGE_SCN_MEM_NOT_CACHED:
	  unhandled = "IMAGE_SCN_MEM_NOT_CACHED";
	  break;
	case IMAGE_SCN_MEM_NOT_PAGED:
	  /* Generate a warning message rather using the 'unhandled'
	     variable as this will allow some .sys files generate by
	     other toolchains to be processed.  See bugzilla issue 196.  */
	  _bfd_error_handler (_("%B: Warning: Ignoring section flag IMAGE_SCN_MEM_NOT_PAGED in section %s"),
			      abfd, name);
	  break;
	case IMAGE_SCN_MEM_EXECUTE:
	  sec_flags |= SEC_CODE;
	  break;
	case IMAGE_SCN_MEM_WRITE:
	  sec_flags &= ~ SEC_READONLY;
	  break;
	case IMAGE_SCN_MEM_DISCARDABLE:
	  /* The MS PE spec says that debug sections are DISCARDABLE,
	     but the presence of a DISCARDABLE flag does not necessarily
	     mean that a given section contains debug information.  Thus
	     we only set the SEC_DEBUGGING flag on sections that we
	     recognise as containing debug information.  */
	     if (is_dbg
#ifdef _COMMENT
	      || strcmp (name, _COMMENT) == 0
#endif
	      )
	    {
	      sec_flags |= SEC_DEBUGGING | SEC_READONLY;
	    }
	  break;
	case IMAGE_SCN_MEM_SHARED:
	  sec_flags |= SEC_COFF_SHARED;
	  break;
	case IMAGE_SCN_LNK_REMOVE:
	  if (!is_dbg)
	    sec_flags |= SEC_EXCLUDE;
	  break;
	case IMAGE_SCN_CNT_CODE:
	  sec_flags |= SEC_CODE | SEC_ALLOC | SEC_LOAD;
	  break;
	case IMAGE_SCN_CNT_INITIALIZED_DATA:
	  if (is_dbg)
	    sec_flags |= SEC_DEBUGGING;
	  else
	    sec_flags |= SEC_DATA | SEC_ALLOC | SEC_LOAD;
	  break;
	case IMAGE_SCN_CNT_UNINITIALIZED_DATA:
	  sec_flags |= SEC_ALLOC;
	  break;
	case IMAGE_SCN_LNK_INFO:
	  /* We mark these as SEC_DEBUGGING, but only if COFF_PAGE_SIZE is
	     defined.  coff_compute_section_file_positions uses
	     COFF_PAGE_SIZE to ensure that the low order bits of the
	     section VMA and the file offset match.  If we don't know
	     COFF_PAGE_SIZE, we can't ensure the correct correspondence,
	     and demand page loading of the file will fail.  */
#ifdef COFF_PAGE_SIZE
	  sec_flags |= SEC_DEBUGGING;
#endif
	  break;
	case IMAGE_SCN_LNK_COMDAT:
	  /* COMDAT gets very special treatment.  */
	  sec_flags = handle_COMDAT (abfd, sec_flags, hdr, name, section);
	  break;
	default:
	  /* Silently ignore for now.  */
	  break;
	}

      /* If the section flag was not handled, report it here.  */
      if (unhandled != NULL)
	{
	  (*_bfd_error_handler)
	    (_("%B (%s): Section flag %s (0x%x) ignored"),
	     abfd, name, unhandled, flag);
	  result = FALSE;
	}
    }

#if defined (COFF_LONG_SECTION_NAMES) && defined (COFF_SUPPORT_GNU_LINKONCE)
  /* As a GNU extension, if the name begins with .gnu.linkonce, we
     only link a single copy of the section.  This is used to support
     g++.  g++ will emit each template expansion in its own section.
     The symbols will be defined as weak, so that multiple definitions
     are permitted.  The GNU linker extension is to actually discard
     all but one of the sections.  */
  if (CONST_STRNEQ (name, ".gnu.linkonce"))
    sec_flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
#endif

  if (flags_ptr)
    * flags_ptr = sec_flags;

  return result;
}

#endif /* COFF_WITH_PE */

#define	get_index(symbol)	((symbol)->udata.i)

/*
INTERNAL_DEFINITION
	bfd_coff_backend_data

CODE_FRAGMENT

.{* COFF symbol classifications.  *}
.
.enum coff_symbol_classification
.{
.  {* Global symbol.  *}
.  COFF_SYMBOL_GLOBAL,
.  {* Common symbol.  *}
.  COFF_SYMBOL_COMMON,
.  {* Undefined symbol.  *}
.  COFF_SYMBOL_UNDEFINED,
.  {* Local symbol.  *}
.  COFF_SYMBOL_LOCAL,
.  {* PE section symbol.  *}
.  COFF_SYMBOL_PE_SECTION
.};
.
Special entry points for gdb to swap in coff symbol table parts:
.typedef struct
.{
.  void (*_bfd_coff_swap_aux_in)
.    (bfd *, void *, int, int, int, int, void *);
.
.  void (*_bfd_coff_swap_sym_in)
.    (bfd *, void *, void *);
.
.  void (*_bfd_coff_swap_lineno_in)
.    (bfd *, void *, void *);
.
.  unsigned int (*_bfd_coff_swap_aux_out)
.    (bfd *, void *, int, int, int, int, void *);
.
.  unsigned int (*_bfd_coff_swap_sym_out)
.    (bfd *, void *, void *);
.
.  unsigned int (*_bfd_coff_swap_lineno_out)
.    (bfd *, void *, void *);
.
.  unsigned int (*_bfd_coff_swap_reloc_out)
.    (bfd *, void *, void *);
.
.  unsigned int (*_bfd_coff_swap_filehdr_out)
.    (bfd *, void *, void *);
.
.  unsigned int (*_bfd_coff_swap_aouthdr_out)
.    (bfd *, void *, void *);
.
.  unsigned int (*_bfd_coff_swap_scnhdr_out)
.    (bfd *, void *, void *);
.
.  unsigned int _bfd_filhsz;
.  unsigned int _bfd_aoutsz;
.  unsigned int _bfd_scnhsz;
.  unsigned int _bfd_symesz;
.  unsigned int _bfd_auxesz;
.  unsigned int _bfd_relsz;
.  unsigned int _bfd_linesz;
.  unsigned int _bfd_filnmlen;
.  bfd_boolean _bfd_coff_long_filenames;
.
.  bfd_boolean _bfd_coff_long_section_names;
.  bfd_boolean (*_bfd_coff_set_long_section_names)
.    (bfd *, int);
.
.  unsigned int _bfd_coff_default_section_alignment_power;
.  bfd_boolean _bfd_coff_force_symnames_in_strings;
.  unsigned int _bfd_coff_debug_string_prefix_length;
.
.  void (*_bfd_coff_swap_filehdr_in)
.    (bfd *, void *, void *);
.
.  void (*_bfd_coff_swap_aouthdr_in)
.    (bfd *, void *, void *);
.
.  void (*_bfd_coff_swap_scnhdr_in)
.    (bfd *, void *, void *);
.
.  void (*_bfd_coff_swap_reloc_in)
.    (bfd *abfd, void *, void *);
.
.  bfd_boolean (*_bfd_coff_bad_format_hook)
.    (bfd *, void *);
.
.  bfd_boolean (*_bfd_coff_set_arch_mach_hook)
.    (bfd *, void *);
.
.  void * (*_bfd_coff_mkobject_hook)
.    (bfd *, void *, void *);
.
.  bfd_boolean (*_bfd_styp_to_sec_flags_hook)
.    (bfd *, void *, const char *, asection *, flagword *);
.
.  void (*_bfd_set_alignment_hook)
.    (bfd *, asection *, void *);
.
.  bfd_boolean (*_bfd_coff_slurp_symbol_table)
.    (bfd *);
.
.  bfd_boolean (*_bfd_coff_symname_in_debug)
.    (bfd *, struct internal_syment *);
.
.  bfd_boolean (*_bfd_coff_pointerize_aux_hook)
.    (bfd *, combined_entry_type *, combined_entry_type *,
.	     unsigned int, combined_entry_type *);
.
.  bfd_boolean (*_bfd_coff_print_aux)
.    (bfd *, FILE *, combined_entry_type *, combined_entry_type *,
.	     combined_entry_type *, unsigned int);
.
.  void (*_bfd_coff_reloc16_extra_cases)
.    (bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
.	    bfd_byte *, unsigned int *, unsigned int *);
.
.  int (*_bfd_coff_reloc16_estimate)
.    (bfd *, asection *, arelent *, unsigned int,
.	     struct bfd_link_info *);
.
.  enum coff_symbol_classification (*_bfd_coff_classify_symbol)
.    (bfd *, struct internal_syment *);
.
.  bfd_boolean (*_bfd_coff_compute_section_file_positions)
.    (bfd *);
.
.  bfd_boolean (*_bfd_coff_start_final_link)
.    (bfd *, struct bfd_link_info *);
.
.  bfd_boolean (*_bfd_coff_relocate_section)
.    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
.	     struct internal_reloc *, struct internal_syment *, asection **);
.
.  reloc_howto_type *(*_bfd_coff_rtype_to_howto)
.    (bfd *, asection *, struct internal_reloc *,
.	     struct coff_link_hash_entry *, struct internal_syment *,
.	     bfd_vma *);
.
.  bfd_boolean (*_bfd_coff_adjust_symndx)
.    (bfd *, struct bfd_link_info *, bfd *, asection *,
.	     struct internal_reloc *, bfd_boolean *);
.
.  bfd_boolean (*_bfd_coff_link_add_one_symbol)
.    (struct bfd_link_info *, bfd *, const char *, flagword,
.	     asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
.	     struct bfd_link_hash_entry **);
.
.  bfd_boolean (*_bfd_coff_link_output_has_begun)
.    (bfd *, struct coff_final_link_info *);
.
.  bfd_boolean (*_bfd_coff_final_link_postscript)
.    (bfd *, struct coff_final_link_info *);
.
.  bfd_boolean (*_bfd_coff_print_pdata)
.    (bfd *, void *);
.
.} bfd_coff_backend_data;
.
.#define coff_backend_info(abfd) \
.  ((bfd_coff_backend_data *) (abfd)->xvec->backend_data)
.
.#define bfd_coff_swap_aux_in(a,e,t,c,ind,num,i) \
.  ((coff_backend_info (a)->_bfd_coff_swap_aux_in) (a,e,t,c,ind,num,i))
.
.#define bfd_coff_swap_sym_in(a,e,i) \
.  ((coff_backend_info (a)->_bfd_coff_swap_sym_in) (a,e,i))
.
.#define bfd_coff_swap_lineno_in(a,e,i) \
.  ((coff_backend_info ( a)->_bfd_coff_swap_lineno_in) (a,e,i))
.
.#define bfd_coff_swap_reloc_out(abfd, i, o) \
.  ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_out) (abfd, i, o))
.
.#define bfd_coff_swap_lineno_out(abfd, i, o) \
.  ((coff_backend_info (abfd)->_bfd_coff_swap_lineno_out) (abfd, i, o))
.
.#define bfd_coff_swap_aux_out(a,i,t,c,ind,num,o) \
.  ((coff_backend_info (a)->_bfd_coff_swap_aux_out) (a,i,t,c,ind,num,o))
.
.#define bfd_coff_swap_sym_out(abfd, i,o) \
.  ((coff_backend_info (abfd)->_bfd_coff_swap_sym_out) (abfd, i, o))
.
.#define bfd_coff_swap_scnhdr_out(abfd, i,o) \
.  ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_out) (abfd, i, o))
.
.#define bfd_coff_swap_filehdr_out(abfd, i,o) \
.  ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_out) (abfd, i, o))
.
.#define bfd_coff_swap_aouthdr_out(abfd, i,o) \
.  ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o))
.
.#define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz)
.#define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz)
.#define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz)
.#define bfd_coff_symesz(abfd) (coff_backend_info (abfd)->_bfd_symesz)
.#define bfd_coff_auxesz(abfd) (coff_backend_info (abfd)->_bfd_auxesz)
.#define bfd_coff_relsz(abfd)  (coff_backend_info (abfd)->_bfd_relsz)
.#define bfd_coff_linesz(abfd) (coff_backend_info (abfd)->_bfd_linesz)
.#define bfd_coff_filnmlen(abfd) (coff_backend_info (abfd)->_bfd_filnmlen)
.#define bfd_coff_long_filenames(abfd) \
.  (coff_backend_info (abfd)->_bfd_coff_long_filenames)
.#define bfd_coff_long_section_names(abfd) \
.  (coff_backend_info (abfd)->_bfd_coff_long_section_names)
.#define bfd_coff_set_long_section_names(abfd, enable) \
.  ((coff_backend_info (abfd)->_bfd_coff_set_long_section_names) (abfd, enable))
.#define bfd_coff_default_section_alignment_power(abfd) \
.  (coff_backend_info (abfd)->_bfd_coff_default_section_alignment_power)
.#define bfd_coff_swap_filehdr_in(abfd, i,o) \
.  ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_in) (abfd, i, o))
.
.#define bfd_coff_swap_aouthdr_in(abfd, i,o) \
.  ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_in) (abfd, i, o))
.
.#define bfd_coff_swap_scnhdr_in(abfd, i,o) \
.  ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_in) (abfd, i, o))
.
.#define bfd_coff_swap_reloc_in(abfd, i, o) \
.  ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_in) (abfd, i, o))
.
.#define bfd_coff_bad_format_hook(abfd, filehdr) \
.  ((coff_backend_info (abfd)->_bfd_coff_bad_format_hook) (abfd, filehdr))
.
.#define bfd_coff_set_arch_mach_hook(abfd, filehdr)\
.  ((coff_backend_info (abfd)->_bfd_coff_set_arch_mach_hook) (abfd, filehdr))
.#define bfd_coff_mkobject_hook(abfd, filehdr, aouthdr)\
.  ((coff_backend_info (abfd)->_bfd_coff_mkobject_hook)\
.   (abfd, filehdr, aouthdr))
.
.#define bfd_coff_styp_to_sec_flags_hook(abfd, scnhdr, name, section, flags_ptr)\
.  ((coff_backend_info (abfd)->_bfd_styp_to_sec_flags_hook)\
.   (abfd, scnhdr, name, section, flags_ptr))
.
.#define bfd_coff_set_alignment_hook(abfd, sec, scnhdr)\
.  ((coff_backend_info (abfd)->_bfd_set_alignment_hook) (abfd, sec, scnhdr))
.
.#define bfd_coff_slurp_symbol_table(abfd)\
.  ((coff_backend_info (abfd)->_bfd_coff_slurp_symbol_table) (abfd))
.
.#define bfd_coff_symname_in_debug(abfd, sym)\
.  ((coff_backend_info (abfd)->_bfd_coff_symname_in_debug) (abfd, sym))
.
.#define bfd_coff_force_symnames_in_strings(abfd)\
.  (coff_backend_info (abfd)->_bfd_coff_force_symnames_in_strings)
.
.#define bfd_coff_debug_string_prefix_length(abfd)\
.  (coff_backend_info (abfd)->_bfd_coff_debug_string_prefix_length)
.
.#define bfd_coff_print_aux(abfd, file, base, symbol, aux, indaux)\
.  ((coff_backend_info (abfd)->_bfd_coff_print_aux)\
.   (abfd, file, base, symbol, aux, indaux))
.
.#define bfd_coff_reloc16_extra_cases(abfd, link_info, link_order,\
.                                     reloc, data, src_ptr, dst_ptr)\
.  ((coff_backend_info (abfd)->_bfd_coff_reloc16_extra_cases)\
.   (abfd, link_info, link_order, reloc, data, src_ptr, dst_ptr))
.
.#define bfd_coff_reloc16_estimate(abfd, section, reloc, shrink, link_info)\
.  ((coff_backend_info (abfd)->_bfd_coff_reloc16_estimate)\
.   (abfd, section, reloc, shrink, link_info))
.
.#define bfd_coff_classify_symbol(abfd, sym)\
.  ((coff_backend_info (abfd)->_bfd_coff_classify_symbol)\
.   (abfd, sym))
.
.#define bfd_coff_compute_section_file_positions(abfd)\
.  ((coff_backend_info (abfd)->_bfd_coff_compute_section_file_positions)\
.   (abfd))
.
.#define bfd_coff_start_final_link(obfd, info)\
.  ((coff_backend_info (obfd)->_bfd_coff_start_final_link)\
.   (obfd, info))
.#define bfd_coff_relocate_section(obfd,info,ibfd,o,con,rel,isyms,secs)\
.  ((coff_backend_info (ibfd)->_bfd_coff_relocate_section)\
.   (obfd, info, ibfd, o, con, rel, isyms, secs))
.#define bfd_coff_rtype_to_howto(abfd, sec, rel, h, sym, addendp)\
.  ((coff_backend_info (abfd)->_bfd_coff_rtype_to_howto)\
.   (abfd, sec, rel, h, sym, addendp))
.#define bfd_coff_adjust_symndx(obfd, info, ibfd, sec, rel, adjustedp)\
.  ((coff_backend_info (abfd)->_bfd_coff_adjust_symndx)\
.   (obfd, info, ibfd, sec, rel, adjustedp))
.#define bfd_coff_link_add_one_symbol(info, abfd, name, flags, section,\
.                                     value, string, cp, coll, hashp)\
.  ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\
.   (info, abfd, name, flags, section, value, string, cp, coll, hashp))
.
.#define bfd_coff_link_output_has_begun(a,p) \
.  ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a, p))
.#define bfd_coff_final_link_postscript(a,p) \
.  ((coff_backend_info (a)->_bfd_coff_final_link_postscript) (a, p))
.
.#define bfd_coff_have_print_pdata(a) \
.  (coff_backend_info (a)->_bfd_coff_print_pdata)
.#define bfd_coff_print_pdata(a,p) \
.  ((coff_backend_info (a)->_bfd_coff_print_pdata) (a, p))
.
.{* Macro: Returns true if the bfd is a PE executable as opposed to a
.   PE object file.  *}
.#define bfd_pei_p(abfd) \
.  (CONST_STRNEQ ((abfd)->xvec->name, "pei-"))
*/

/* See whether the magic number matches.  */

static bfd_boolean
coff_bad_format_hook (bfd * abfd ATTRIBUTE_UNUSED, void * filehdr)
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

  if (BADMAG (*internal_f))
    return FALSE;

  /* If the optional header is NULL or not the correct size then
     quit; the only difference I can see between m88k dgux headers (MC88DMAGIC)
     and Intel 960 readwrite headers (I960WRMAGIC) is that the
     optional header is of a different size.

     But the mips keeps extra stuff in it's opthdr, so dont check
     when doing that.  */

#if defined(M88) || defined(I960)
  if (internal_f->f_opthdr != 0 && bfd_coff_aoutsz (abfd) != internal_f->f_opthdr)
    return FALSE;
#endif

  return TRUE;
}

#ifdef TICOFF
static bfd_boolean
ticoff0_bad_format_hook (bfd *abfd ATTRIBUTE_UNUSED, void * filehdr)
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

  if (COFF0_BADMAG (*internal_f))
    return FALSE;

  return TRUE;
}
#endif

#ifdef TICOFF
static bfd_boolean
ticoff1_bad_format_hook (bfd *abfd ATTRIBUTE_UNUSED, void * filehdr)
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

  if (COFF1_BADMAG (*internal_f))
    return FALSE;

  return TRUE;
}
#endif

/* Check whether this section uses an alignment other than the
   default.  */

static void
coff_set_custom_section_alignment (bfd *abfd ATTRIBUTE_UNUSED,
				   asection *section,
				   const struct coff_section_alignment_entry *alignment_table,
				   const unsigned int table_size)
{
  const unsigned int default_alignment = COFF_DEFAULT_SECTION_ALIGNMENT_POWER;
  unsigned int i;

  for (i = 0; i < table_size; ++i)
    {
      const char *secname = bfd_get_section_name (abfd, section);

      if (alignment_table[i].comparison_length == (unsigned int) -1
	  ? strcmp (alignment_table[i].name, secname) == 0
	  : strncmp (alignment_table[i].name, secname,
		     alignment_table[i].comparison_length) == 0)
	break;
    }
  if (i >= table_size)
    return;

  if (alignment_table[i].default_alignment_min != COFF_ALIGNMENT_FIELD_EMPTY
      && default_alignment < alignment_table[i].default_alignment_min)
    return;

  if (alignment_table[i].default_alignment_max != COFF_ALIGNMENT_FIELD_EMPTY
#if COFF_DEFAULT_SECTION_ALIGNMENT_POWER != 0
      && default_alignment > alignment_table[i].default_alignment_max
#endif
      )
    return;

  section->alignment_power = alignment_table[i].alignment_power;
}

/* Custom section alignment records.  */

static const struct coff_section_alignment_entry
coff_section_alignment_table[] =
{
#ifdef COFF_SECTION_ALIGNMENT_ENTRIES
  COFF_SECTION_ALIGNMENT_ENTRIES,
#endif
  /* There must not be any gaps between .stabstr sections.  */
  { COFF_SECTION_NAME_PARTIAL_MATCH (".stabstr"),
    1, COFF_ALIGNMENT_FIELD_EMPTY, 0 },
  /* The .stab section must be aligned to 2**2 at most, to avoid gaps.  */
  { COFF_SECTION_NAME_PARTIAL_MATCH (".stab"),
    3, COFF_ALIGNMENT_FIELD_EMPTY, 2 },
  /* Similarly for the .ctors and .dtors sections.  */
  { COFF_SECTION_NAME_EXACT_MATCH (".ctors"),
    3, COFF_ALIGNMENT_FIELD_EMPTY, 2 },
  { COFF_SECTION_NAME_EXACT_MATCH (".dtors"),
    3, COFF_ALIGNMENT_FIELD_EMPTY, 2 }
};

static const unsigned int coff_section_alignment_table_size =
  sizeof coff_section_alignment_table / sizeof coff_section_alignment_table[0];

/* Initialize a section structure with information peculiar to this
   particular implementation of COFF.  */

static bfd_boolean
coff_new_section_hook (bfd * abfd, asection * section)
{
  combined_entry_type *native;
  bfd_size_type amt;
  unsigned char sclass = C_STAT;

  section->alignment_power = COFF_DEFAULT_SECTION_ALIGNMENT_POWER;

#ifdef RS6000COFF_C
  if (bfd_xcoff_text_align_power (abfd) != 0
      && strcmp (bfd_get_section_name (abfd, section), ".text") == 0)
    section->alignment_power = bfd_xcoff_text_align_power (abfd);
  else if (bfd_xcoff_data_align_power (abfd) != 0
      && strcmp (bfd_get_section_name (abfd, section), ".data") == 0)
    section->alignment_power = bfd_xcoff_data_align_power (abfd);
  else
    {
      int i;

      for (i = 0; i < XCOFF_DWSECT_NBR_NAMES; i++)
        if (strcmp (bfd_get_section_name (abfd, section),
                    xcoff_dwsect_names[i].name) == 0)
          {
            section->alignment_power = 0;
            sclass = C_DWARF;
            break;
          }
    }
#endif

  /* Set up the section symbol.  */
  if (!_bfd_generic_new_section_hook (abfd, section))
    return FALSE;

  /* Allocate aux records for section symbols, to store size and
     related info.

     @@@@ The 10 is a guess at a plausible maximum number of aux entries
     (but shouldn't be a constant).  */
  amt = sizeof (combined_entry_type) * 10;
  native = (combined_entry_type *) bfd_zalloc (abfd, amt);
  if (native == NULL)
    return FALSE;

  /* We don't need to set up n_name, n_value, or n_scnum in the native
     symbol information, since they'll be overridden by the BFD symbol
     anyhow.  However, we do need to set the type and storage class,
     in case this symbol winds up getting written out.  The value 0
     for n_numaux is already correct.  */

  native->u.syment.n_type = T_NULL;
  native->u.syment.n_sclass = sclass;

  coffsymbol (section->symbol)->native = native;

  coff_set_custom_section_alignment (abfd, section,
				     coff_section_alignment_table,
				     coff_section_alignment_table_size);

  return TRUE;
}

#ifdef COFF_ALIGN_IN_SECTION_HEADER

/* Set the alignment of a BFD section.  */

static void
coff_set_alignment_hook (bfd * abfd ATTRIBUTE_UNUSED,
			 asection * section,
			 void * scnhdr)
{
  struct internal_scnhdr *hdr = (struct internal_scnhdr *) scnhdr;
  unsigned int i;

#ifdef I960
  /* Extract ALIGN from 2**ALIGN stored in section header.  */
  for (i = 0; i < 32; i++)
    if ((1 << i) >= hdr->s_align)
      break;
#endif
#ifdef TIC80COFF
  /* TI tools puts the alignment power in bits 8-11.  */
  i = (hdr->s_flags >> 8) & 0xF ;
#endif
#ifdef COFF_DECODE_ALIGNMENT
  i = COFF_DECODE_ALIGNMENT(hdr->s_flags);
#endif
  section->alignment_power = i;

#ifdef coff_set_section_load_page
  coff_set_section_load_page (section, hdr->s_page);
#endif
}

#else /* ! COFF_ALIGN_IN_SECTION_HEADER */
#ifdef COFF_WITH_PE

static void
coff_set_alignment_hook (bfd * abfd ATTRIBUTE_UNUSED,
			 asection * section,
			 void * scnhdr)
{
  struct internal_scnhdr *hdr = (struct internal_scnhdr *) scnhdr;
  bfd_size_type amt;
  unsigned int alignment_power_const
    = hdr->s_flags & IMAGE_SCN_ALIGN_POWER_BIT_MASK;

  switch (alignment_power_const)
    {
    case IMAGE_SCN_ALIGN_8192BYTES:
    case IMAGE_SCN_ALIGN_4096BYTES:
    case IMAGE_SCN_ALIGN_2048BYTES:
    case IMAGE_SCN_ALIGN_1024BYTES:
    case IMAGE_SCN_ALIGN_512BYTES:
    case IMAGE_SCN_ALIGN_256BYTES:
    case IMAGE_SCN_ALIGN_128BYTES:
    case IMAGE_SCN_ALIGN_64BYTES:
    case IMAGE_SCN_ALIGN_32BYTES:
    case IMAGE_SCN_ALIGN_16BYTES:
    case IMAGE_SCN_ALIGN_8BYTES:
    case IMAGE_SCN_ALIGN_4BYTES:
    case IMAGE_SCN_ALIGN_2BYTES:
    case IMAGE_SCN_ALIGN_1BYTES:
      section->alignment_power
	= IMAGE_SCN_ALIGN_POWER_NUM (alignment_power_const);
      break;
    default:
      break;
    }

  /* In a PE image file, the s_paddr field holds the virtual size of a
     section, while the s_size field holds the raw size.  We also keep
     the original section flag value, since not every bit can be
     mapped onto a generic BFD section bit.  */
  if (coff_section_data (abfd, section) == NULL)
    {
      amt = sizeof (struct coff_section_tdata);
      section->used_by_bfd = bfd_zalloc (abfd, amt);
      if (section->used_by_bfd == NULL)
	/* FIXME: Return error.  */
	abort ();
    }

  if (pei_section_data (abfd, section) == NULL)
    {
      amt = sizeof (struct pei_section_tdata);
      coff_section_data (abfd, section)->tdata = bfd_zalloc (abfd, amt);
      if (coff_section_data (abfd, section)->tdata == NULL)
	/* FIXME: Return error.  */
	abort ();
    }
  pei_section_data (abfd, section)->virt_size = hdr->s_paddr;
  pei_section_data (abfd, section)->pe_flags = hdr->s_flags;

  section->lma = hdr->s_vaddr;

  /* Check for extended relocs.  */
  if (hdr->s_flags & IMAGE_SCN_LNK_NRELOC_OVFL)
    {
      struct external_reloc dst;
      struct internal_reloc n;
      file_ptr oldpos = bfd_tell (abfd);
      bfd_size_type relsz = bfd_coff_relsz (abfd);

      if (bfd_seek (abfd, (file_ptr) hdr->s_relptr, 0) != 0)
	return;
      if (bfd_bread (& dst, relsz, abfd) != relsz)
	return;

      coff_swap_reloc_in (abfd, &dst, &n);
      if (bfd_seek (abfd, oldpos, 0) != 0)
	return;
      section->reloc_count = hdr->s_nreloc = n.r_vaddr - 1;
      section->rel_filepos += relsz;
    }
  else if (hdr->s_nreloc == 0xffff)
    (*_bfd_error_handler)
      ("%s: warning: claims to have 0xffff relocs, without overflow",
       bfd_get_filename (abfd));
}
#undef ALIGN_SET
#undef ELIFALIGN_SET

#else /* ! COFF_WITH_PE */
#ifdef RS6000COFF_C

/* We grossly abuse this function to handle XCOFF overflow headers.
   When we see one, we correct the reloc and line number counts in the
   real header, and remove the section we just created.  */

static void
coff_set_alignment_hook (bfd *abfd, asection *section, void * scnhdr)
{
  struct internal_scnhdr *hdr = (struct internal_scnhdr *) scnhdr;
  asection *real_sec;

  if ((hdr->s_flags & STYP_OVRFLO) == 0)
    return;

  real_sec = coff_section_from_bfd_index (abfd, (int) hdr->s_nreloc);
  if (real_sec == NULL)
    return;

  real_sec->reloc_count = hdr->s_paddr;
  real_sec->lineno_count = hdr->s_vaddr;

  if (!bfd_section_removed_from_list (abfd, section))
    {
      bfd_section_list_remove (abfd, section);
      --abfd->section_count;
    }
}

#else /* ! RS6000COFF_C */

#define coff_set_alignment_hook \
  ((void (*) (bfd *, asection *, void *)) bfd_void)

#endif /* ! RS6000COFF_C */
#endif /* ! COFF_WITH_PE */
#endif /* ! COFF_ALIGN_IN_SECTION_HEADER */

#ifndef coff_mkobject

static bfd_boolean
coff_mkobject (bfd * abfd)
{
  coff_data_type *coff;
  bfd_size_type amt = sizeof (coff_data_type);

  abfd->tdata.coff_obj_data = bfd_zalloc (abfd, amt);
  if (abfd->tdata.coff_obj_data == NULL)
    return FALSE;
  coff = coff_data (abfd);
  coff->symbols = NULL;
  coff->conversion_table = NULL;
  coff->raw_syments = NULL;
  coff->relocbase = 0;
  coff->local_toc_sym_map = 0;

/*  make_abs_section(abfd);*/

  return TRUE;
}
#endif

/* Create the COFF backend specific information.  */

#ifndef coff_mkobject_hook
static void *
coff_mkobject_hook (bfd * abfd,
		    void * filehdr,
		    void * aouthdr ATTRIBUTE_UNUSED)
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
  coff_data_type *coff;

  if (! coff_mkobject (abfd))
    return NULL;

  coff = coff_data (abfd);

  coff->sym_filepos = internal_f->f_symptr;

  /* These members communicate important constants about the symbol
     table to GDB's symbol-reading code.  These `constants'
     unfortunately vary among coff implementations...  */
  coff->local_n_btmask = N_BTMASK;
  coff->local_n_btshft = N_BTSHFT;
  coff->local_n_tmask = N_TMASK;
  coff->local_n_tshift = N_TSHIFT;
  coff->local_symesz = bfd_coff_symesz (abfd);
  coff->local_auxesz = bfd_coff_auxesz (abfd);
  coff->local_linesz = bfd_coff_linesz (abfd);

  coff->timestamp = internal_f->f_timdat;

  obj_raw_syment_count (abfd) =
    obj_conv_table_size (abfd) =
      internal_f->f_nsyms;

#ifdef RS6000COFF_C
  if ((internal_f->f_flags & F_SHROBJ) != 0)
    abfd->flags |= DYNAMIC;
  if (aouthdr != NULL && internal_f->f_opthdr >= bfd_coff_aoutsz (abfd))
    {
      struct internal_aouthdr *internal_a =
	(struct internal_aouthdr *) aouthdr;
      struct xcoff_tdata *xcoff;

      xcoff = xcoff_data (abfd);
# ifdef U803XTOCMAGIC
      xcoff->xcoff64 = internal_f->f_magic == U803XTOCMAGIC;
# else
      xcoff->xcoff64 = 0;
# endif
      xcoff->full_aouthdr = TRUE;
      xcoff->toc = internal_a->o_toc;
      xcoff->sntoc = internal_a->o_sntoc;
      xcoff->snentry = internal_a->o_snentry;
      bfd_xcoff_text_align_power (abfd) = internal_a->o_algntext;
      bfd_xcoff_data_align_power (abfd) = internal_a->o_algndata;
      xcoff->modtype = internal_a->o_modtype;
      xcoff->cputype = internal_a->o_cputype;
      xcoff->maxdata = internal_a->o_maxdata;
      xcoff->maxstack = internal_a->o_maxstack;
    }
#endif

#ifdef ARM
  /* Set the flags field from the COFF header read in.  */
  if (! _bfd_coff_arm_set_private_flags (abfd, internal_f->f_flags))
    coff->flags = 0;
#endif

#ifdef COFF_WITH_PE
  /* FIXME: I'm not sure this is ever executed, since peicode.h
     defines coff_mkobject_hook.  */
  if ((internal_f->f_flags & IMAGE_FILE_DEBUG_STRIPPED) == 0)
    abfd->flags |= HAS_DEBUG;
#endif

  if ((internal_f->f_flags & F_GO32STUB) != 0)
    coff->go32stub = (char *) bfd_alloc (abfd, (bfd_size_type) GO32_STUBSIZE);
  if (coff->go32stub != NULL)
    memcpy (coff->go32stub, internal_f->go32stub, GO32_STUBSIZE);

  return coff;
}
#endif

/* Determine the machine architecture and type.  FIXME: This is target
   dependent because the magic numbers are defined in the target
   dependent header files.  But there is no particular need for this.
   If the magic numbers were moved to a separate file, this function
   would be target independent and would also be much more successful
   at linking together COFF files for different architectures.  */

static bfd_boolean
coff_set_arch_mach_hook (bfd *abfd, void * filehdr)
{
  unsigned long machine;
  enum bfd_architecture arch;
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

  /* Zero selects the default machine for an arch.  */
  machine = 0;
  switch (internal_f->f_magic)
    {
#ifdef OR32_MAGIC_BIG
    case OR32_MAGIC_BIG:
    case OR32_MAGIC_LITTLE:
      arch = bfd_arch_or32;
      break;
#endif
#ifdef PPCMAGIC
    case PPCMAGIC:
      arch = bfd_arch_powerpc;
      break;
#endif
#ifdef I386MAGIC
    case I386MAGIC:
    case I386PTXMAGIC:
    case I386AIXMAGIC:		/* Danbury PS/2 AIX C Compiler.  */
    case LYNXCOFFMAGIC:		/* Shadows the m68k Lynx number below, sigh.  */
      arch = bfd_arch_i386;
      break;
#endif
#ifdef AMD64MAGIC
    case AMD64MAGIC:
      arch = bfd_arch_i386;
      machine = bfd_mach_x86_64;
      break;
#endif
#ifdef IA64MAGIC
    case IA64MAGIC:
      arch = bfd_arch_ia64;
      break;
#endif
#ifdef ARMMAGIC
    case ARMMAGIC:
    case ARMPEMAGIC:
    case THUMBPEMAGIC:
      arch = bfd_arch_arm;
      machine = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);
      if (machine == bfd_mach_arm_unknown)
	{
	  switch (internal_f->f_flags & F_ARM_ARCHITECTURE_MASK)
	    {
	    case F_ARM_2:  machine = bfd_mach_arm_2;  break;
	    case F_ARM_2a: machine = bfd_mach_arm_2a; break;
	    case F_ARM_3:  machine = bfd_mach_arm_3;  break;
	    default:
	    case F_ARM_3M: machine = bfd_mach_arm_3M; break;
	    case F_ARM_4:  machine = bfd_mach_arm_4;  break;
	    case F_ARM_4T: machine = bfd_mach_arm_4T; break;
	      /* The COFF header does not have enough bits available
		 to cover all the different ARM architectures.  So
		 we interpret F_ARM_5, the highest flag value to mean
		 "the highest ARM architecture known to BFD" which is
		 currently the XScale.  */
	    case F_ARM_5:  machine = bfd_mach_arm_XScale;  break;
	    }
	}
      break;
#endif
#ifdef MC68MAGIC
    case MC68MAGIC:
    case M68MAGIC:
#ifdef MC68KBCSMAGIC
    case MC68KBCSMAGIC:
#endif
#ifdef APOLLOM68KMAGIC
    case APOLLOM68KMAGIC:
#endif
#ifdef LYNXCOFFMAGIC
    case LYNXCOFFMAGIC:
#endif
      arch = bfd_arch_m68k;
      machine = bfd_mach_m68020;
      break;
#endif
#ifdef MC88MAGIC
    case MC88MAGIC:
    case MC88DMAGIC:
    case MC88OMAGIC:
      arch = bfd_arch_m88k;
      machine = 88100;
      break;
#endif
#ifdef Z80MAGIC
    case Z80MAGIC:
      arch = bfd_arch_z80;
      switch (internal_f->f_flags & F_MACHMASK)
	{
	case 0:
	case bfd_mach_z80strict << 12:
	case bfd_mach_z80 << 12:
	case bfd_mach_z80full << 12:
	case bfd_mach_r800 << 12:
	  machine = ((unsigned)internal_f->f_flags & F_MACHMASK) >> 12;
	  break;
	default:
	  return FALSE;
	}
      break;
#endif
#ifdef Z8KMAGIC
    case Z8KMAGIC:
      arch = bfd_arch_z8k;
      switch (internal_f->f_flags & F_MACHMASK)
	{
	case F_Z8001:
	  machine = bfd_mach_z8001;
	  break;
	case F_Z8002:
	  machine = bfd_mach_z8002;
	  break;
	default:
	  return FALSE;
	}
      break;
#endif
#ifdef I860
    case I860MAGIC:
      arch = bfd_arch_i860;
      break;
#endif
#ifdef I960
#ifdef I960ROMAGIC
    case I960ROMAGIC:
    case I960RWMAGIC:
      arch = bfd_arch_i960;
      switch (F_I960TYPE & internal_f->f_flags)
	{
	default:
	case F_I960CORE:
	  machine = bfd_mach_i960_core;
	  break;
	case F_I960KB:
	  machine = bfd_mach_i960_kb_sb;
	  break;
	case F_I960MC:
	  machine = bfd_mach_i960_mc;
	  break;
	case F_I960XA:
	  machine = bfd_mach_i960_xa;
	  break;
	case F_I960CA:
	  machine = bfd_mach_i960_ca;
	  break;
	case F_I960KA:
	  machine = bfd_mach_i960_ka_sa;
	  break;
	case F_I960JX:
	  machine = bfd_mach_i960_jx;
	  break;
	case F_I960HX:
	  machine = bfd_mach_i960_hx;
	  break;
	}
      break;
#endif
#endif

#ifdef RS6000COFF_C
#ifdef XCOFF64
    case U64_TOCMAGIC:
    case U803XTOCMAGIC:
#else
    case U802ROMAGIC:
    case U802WRMAGIC:
    case U802TOCMAGIC:
#endif
      {
	int cputype;

	if (xcoff_data (abfd)->cputype != -1)
	  cputype = xcoff_data (abfd)->cputype & 0xff;
	else
	  {
	    /* We did not get a value from the a.out header.  If the
	       file has not been stripped, we may be able to get the
	       architecture information from the first symbol, if it
	       is a .file symbol.  */
	    if (obj_raw_syment_count (abfd) == 0)
	      cputype = 0;
	    else
	      {
		bfd_byte *buf;
		struct internal_syment sym;
		bfd_size_type amt = bfd_coff_symesz (abfd);

		buf = bfd_malloc (amt);
		if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0
		    || bfd_bread (buf, amt, abfd) != amt)
		  {
		    free (buf);
		    return FALSE;
		  }
		bfd_coff_swap_sym_in (abfd, buf, & sym);
		if (sym.n_sclass == C_FILE)
		  cputype = sym.n_type & 0xff;
		else
		  cputype = 0;
		free (buf);
	      }
	  }

	/* FIXME: We don't handle all cases here.  */
	switch (cputype)
	  {
	  default:
	  case 0:
	    arch = bfd_xcoff_architecture (abfd);
	    machine = bfd_xcoff_machine (abfd);
	    break;

	  case 1:
	    arch = bfd_arch_powerpc;
	    machine = bfd_mach_ppc_601;
	    break;
	  case 2: /* 64 bit PowerPC */
	    arch = bfd_arch_powerpc;
	    machine = bfd_mach_ppc_620;
	    break;
	  case 3:
	    arch = bfd_arch_powerpc;
	    machine = bfd_mach_ppc;
	    break;
	  case 4:
	    arch = bfd_arch_rs6000;
	    machine = bfd_mach_rs6k;
	    break;
	  }
      }
      break;
#endif

#ifdef WE32KMAGIC
    case WE32KMAGIC:
      arch = bfd_arch_we32k;
      break;
#endif

#ifdef H8300MAGIC
    case H8300MAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300;
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef H8300HMAGIC
    case H8300HMAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300h;
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef H8300SMAGIC
    case H8300SMAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300s;
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef H8300HNMAGIC
    case H8300HNMAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300hn;
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef H8300SNMAGIC
    case H8300SNMAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300sn;
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef SH_ARCH_MAGIC_BIG
    case SH_ARCH_MAGIC_BIG:
    case SH_ARCH_MAGIC_LITTLE:
#ifdef COFF_WITH_PE
    case SH_ARCH_MAGIC_WINCE:
#endif
      arch = bfd_arch_sh;
      break;
#endif

#ifdef MIPS_ARCH_MAGIC_WINCE
    case MIPS_ARCH_MAGIC_WINCE:
      arch = bfd_arch_mips;
      break;
#endif

#ifdef H8500MAGIC
    case H8500MAGIC:
      arch = bfd_arch_h8500;
      break;
#endif

#ifdef SPARCMAGIC
    case SPARCMAGIC:
#ifdef LYNXCOFFMAGIC
    case LYNXCOFFMAGIC:
#endif
      arch = bfd_arch_sparc;
      break;
#endif

#ifdef TIC30MAGIC
    case TIC30MAGIC:
      arch = bfd_arch_tic30;
      break;
#endif

#ifdef TICOFF0MAGIC
#ifdef TICOFF_TARGET_ARCH
      /* This TI COFF section should be used by all new TI COFF v0 targets.  */
    case TICOFF0MAGIC:
      arch = TICOFF_TARGET_ARCH;
      machine = TICOFF_TARGET_MACHINE_GET (internal_f->f_flags);
      break;
#endif
#endif

#ifdef TICOFF1MAGIC
      /* This TI COFF section should be used by all new TI COFF v1/2 targets.  */
      /* TI COFF1 and COFF2 use the target_id field to specify which arch.  */
    case TICOFF1MAGIC:
    case TICOFF2MAGIC:
      switch (internal_f->f_target_id)
	{
#ifdef TI_TARGET_ID
	case TI_TARGET_ID:
	  arch = TICOFF_TARGET_ARCH;
	  machine = TICOFF_TARGET_MACHINE_GET (internal_f->f_flags);
	  break;
#endif
	default:
	  arch = bfd_arch_obscure;
	  (*_bfd_error_handler)
	    (_("Unrecognized TI COFF target id '0x%x'"),
	     internal_f->f_target_id);
	  break;
	}
      break;
#endif

#ifdef TIC80_ARCH_MAGIC
    case TIC80_ARCH_MAGIC:
      arch = bfd_arch_tic80;
      break;
#endif

#ifdef MCOREMAGIC
    case MCOREMAGIC:
      arch = bfd_arch_mcore;
      break;
#endif

#ifdef W65MAGIC
    case W65MAGIC:
      arch = bfd_arch_w65;
      break;
#endif

    default:			/* Unreadable input file type.  */
      arch = bfd_arch_obscure;
      break;
    }

  bfd_default_set_arch_mach (abfd, arch, machine);
  return TRUE;
}

#ifdef SYMNAME_IN_DEBUG

static bfd_boolean
symname_in_debug_hook (bfd * abfd ATTRIBUTE_UNUSED, struct internal_syment *sym)
{
  return SYMNAME_IN_DEBUG (sym) != 0;
}

#else

#define symname_in_debug_hook \
  (bfd_boolean (*) (bfd *, struct internal_syment *)) bfd_false

#endif

#ifdef RS6000COFF_C

#ifdef XCOFF64
#define FORCE_SYMNAMES_IN_STRINGS
#endif

/* Handle the csect auxent of a C_EXT, C_AIX_WEAKEXT or C_HIDEXT symbol.  */

static bfd_boolean
coff_pointerize_aux_hook (bfd *abfd ATTRIBUTE_UNUSED,
			  combined_entry_type *table_base,
			  combined_entry_type *symbol,
			  unsigned int indaux,
			  combined_entry_type *aux)
{
  int n_sclass = symbol->u.syment.n_sclass;

  if (CSECT_SYM_P (n_sclass)
      && indaux + 1 == symbol->u.syment.n_numaux)
    {
      if (SMTYP_SMTYP (aux->u.auxent.x_csect.x_smtyp) == XTY_LD)
	{
	  aux->u.auxent.x_csect.x_scnlen.p =
	    table_base + aux->u.auxent.x_csect.x_scnlen.l;
	  aux->fix_scnlen = 1;
	}

      /* Return TRUE to indicate that the caller should not do any
	 further work on this auxent.  */
      return TRUE;
    }

  /* Return FALSE to indicate that this auxent should be handled by
     the caller.  */
  return FALSE;
}

#else
#ifdef I960

/* We don't want to pointerize bal entries.  */

static bfd_boolean
coff_pointerize_aux_hook (bfd *abfd ATTRIBUTE_UNUSED,
			  combined_entry_type *table_base ATTRIBUTE_UNUSED,
			  combined_entry_type *symbol,
			  unsigned int indaux,
			  combined_entry_type *aux ATTRIBUTE_UNUSED)
{
  /* Return TRUE if we don't want to pointerize this aux entry, which
     is the case for the lastfirst aux entry for a C_LEAFPROC symbol.  */
  return (indaux == 1
	  && (symbol->u.syment.n_sclass == C_LEAFPROC
	      || symbol->u.syment.n_sclass == C_LEAFSTAT
	      || symbol->u.syment.n_sclass == C_LEAFEXT));
}

#else /* ! I960 */

#define coff_pointerize_aux_hook 0

#endif /* ! I960 */
#endif /* ! RS6000COFF_C */

/* Print an aux entry.  This returns TRUE if it has printed it.  */

static bfd_boolean
coff_print_aux (bfd *abfd ATTRIBUTE_UNUSED,
		FILE *file ATTRIBUTE_UNUSED,
		combined_entry_type *table_base ATTRIBUTE_UNUSED,
		combined_entry_type *symbol ATTRIBUTE_UNUSED,
		combined_entry_type *aux ATTRIBUTE_UNUSED,
		unsigned int indaux ATTRIBUTE_UNUSED)
{
#ifdef RS6000COFF_C
  if (CSECT_SYM_P (symbol->u.syment.n_sclass)
      && indaux + 1 == symbol->u.syment.n_numaux)
    {
      /* This is a csect entry.  */
      fprintf (file, "AUX ");
      if (SMTYP_SMTYP (aux->u.auxent.x_csect.x_smtyp) != XTY_LD)
	{
	  BFD_ASSERT (! aux->fix_scnlen);
#ifdef XCOFF64
	  fprintf (file, "val %5lld",
		   (long long) aux->u.auxent.x_csect.x_scnlen.l);
#else
	  fprintf (file, "val %5ld", (long) aux->u.auxent.x_csect.x_scnlen.l);
#endif
	}
      else
	{
	  fprintf (file, "indx ");
	  if (! aux->fix_scnlen)
#ifdef XCOFF64
	    fprintf (file, "%4lld",
		     (long long) aux->u.auxent.x_csect.x_scnlen.l);
#else
	    fprintf (file, "%4ld", (long) aux->u.auxent.x_csect.x_scnlen.l);
#endif
	  else
	    fprintf (file, "%4ld",
		     (long) (aux->u.auxent.x_csect.x_scnlen.p - table_base));
	}
      fprintf (file,
	       " prmhsh %ld snhsh %u typ %d algn %d clss %u stb %ld snstb %u",
	       aux->u.auxent.x_csect.x_parmhash,
	       (unsigned int) aux->u.auxent.x_csect.x_snhash,
	       SMTYP_SMTYP (aux->u.auxent.x_csect.x_smtyp),
	       SMTYP_ALIGN (aux->u.auxent.x_csect.x_smtyp),
	       (unsigned int) aux->u.auxent.x_csect.x_smclas,
	       aux->u.auxent.x_csect.x_stab,
	       (unsigned int) aux->u.auxent.x_csect.x_snstab);
      return TRUE;
    }
#endif

  /* Return FALSE to indicate that no special action was taken.  */
  return FALSE;
}

/*
SUBSUBSECTION
	Writing relocations

	To write relocations, the back end steps though the
	canonical relocation table and create an
	@@code{internal_reloc}. The symbol index to use is removed from
	the @@code{offset} field in the symbol table supplied.  The
	address comes directly from the sum of the section base
	address and the relocation offset; the type is dug directly
	from the howto field.  Then the @@code{internal_reloc} is
	swapped into the shape of an @@code{external_reloc} and written
	out to disk.

*/

#ifdef TARG_AUX


/* AUX's ld wants relocations to be sorted.  */
static int
compare_arelent_ptr (const void * x, const void * y)
{
  const arelent **a = (const arelent **) x;
  const arelent **b = (const arelent **) y;
  bfd_size_type aadr = (*a)->address;
  bfd_size_type badr = (*b)->address;

  return (aadr < badr ? -1 : badr < aadr ? 1 : 0);
}

#endif /* TARG_AUX */

static bfd_boolean
coff_write_relocs (bfd * abfd, int first_undef)
{
  asection *s;

  for (s = abfd->sections; s != NULL; s = s->next)
    {
      unsigned int i;
      struct external_reloc dst;
      arelent **p;

#ifndef TARG_AUX
      p = s->orelocation;
#else
      {
	/* Sort relocations before we write them out.  */
	bfd_size_type amt;

	amt = s->reloc_count;
	amt *= sizeof (arelent *);
	p = bfd_malloc (amt);
	if (p == NULL && s->reloc_count > 0)
	  return FALSE;
	memcpy (p, s->orelocation, (size_t) amt);
	qsort (p, s->reloc_count, sizeof (arelent *), compare_arelent_ptr);
      }
#endif

      if (bfd_seek (abfd, s->rel_filepos, SEEK_SET) != 0)
	return FALSE;

#ifdef COFF_WITH_PE
      if (obj_pe (abfd) && s->reloc_count >= 0xffff)
	{
	  /* Encode real count here as first reloc.  */
	  struct internal_reloc n;

	  memset (& n, 0, sizeof (n));
	  /* Add one to count *this* reloc (grr).  */
	  n.r_vaddr = s->reloc_count + 1;
	  coff_swap_reloc_out (abfd, &n, &dst);
	  if (bfd_bwrite (& dst, (bfd_size_type) bfd_coff_relsz (abfd),
			  abfd) != bfd_coff_relsz (abfd))
	    return FALSE;
	}
#endif

      for (i = 0; i < s->reloc_count; i++)
	{
	  struct internal_reloc n;
	  arelent *q = p[i];

	  memset (& n, 0, sizeof (n));

	  /* Now we've renumbered the symbols we know where the
	     undefined symbols live in the table.  Check the reloc
	     entries for symbols who's output bfd isn't the right one.
	     This is because the symbol was undefined (which means
	     that all the pointers are never made to point to the same
	     place). This is a bad thing,'cause the symbols attached
	     to the output bfd are indexed, so that the relocation
	     entries know which symbol index they point to.  So we
	     have to look up the output symbol here.  */

	  if (q->sym_ptr_ptr[0] != NULL && q->sym_ptr_ptr[0]->the_bfd != abfd)
	    {
	      int j;
	      const char *sname = q->sym_ptr_ptr[0]->name;
	      asymbol **outsyms = abfd->outsymbols;

	      for (j = first_undef; outsyms[j]; j++)
		{
		  const char *intable = outsyms[j]->name;

		  if (strcmp (intable, sname) == 0)
		    {
		      /* Got a hit, so repoint the reloc.  */
		      q->sym_ptr_ptr = outsyms + j;
		      break;
		    }
		}
	    }

	  n.r_vaddr = q->address + s->vma;

#ifdef R_IHCONST
	  /* The 29k const/consth reloc pair is a real kludge.  The consth
	     part doesn't have a symbol; it has an offset.  So rebuilt
	     that here.  */
	  if (q->howto->type == R_IHCONST)
	    n.r_symndx = q->addend;
	  else
#endif
	    if (q->sym_ptr_ptr && q->sym_ptr_ptr[0] != NULL)
	      {
#ifdef SECTION_RELATIVE_ABSOLUTE_SYMBOL_P
		if (SECTION_RELATIVE_ABSOLUTE_SYMBOL_P (q, s))
#else
		if ((*q->sym_ptr_ptr)->section == bfd_abs_section_ptr
		    && ((*q->sym_ptr_ptr)->flags & BSF_SECTION_SYM) != 0)
#endif
		  /* This is a relocation relative to the absolute symbol.  */
		  n.r_symndx = -1;
		else
		  {
		    n.r_symndx = get_index ((*(q->sym_ptr_ptr)));
		    /* Check to see if the symbol reloc points to a symbol
		       we don't have in our symbol table.  */
		    if (n.r_symndx > obj_conv_table_size (abfd))
		      {
			bfd_set_error (bfd_error_bad_value);
			_bfd_error_handler (_("%B: reloc against a non-existant symbol index: %ld"),
					    abfd, n.r_symndx);
			return FALSE;
		      }
		  }
	      }

#ifdef SWAP_OUT_RELOC_OFFSET
	  n.r_offset = q->addend;
#endif

#ifdef SELECT_RELOC
	  /* Work out reloc type from what is required.  */
	  SELECT_RELOC (n, q->howto);
#else
	  n.r_type = q->howto->type;
#endif
	  coff_swap_reloc_out (abfd, &n, &dst);

	  if (bfd_bwrite (& dst, (bfd_size_type) bfd_coff_relsz (abfd),
			 abfd) != bfd_coff_relsz (abfd))
	    return FALSE;
	}

#ifdef TARG_AUX
      if (p != NULL)
	free (p);
#endif
    }

  return TRUE;
}

/* Set flags and magic number of a coff file from architecture and machine
   type.  Result is TRUE if we can represent the arch&type, FALSE if not.  */

static bfd_boolean
coff_set_flags (bfd * abfd,
		unsigned int *magicp ATTRIBUTE_UNUSED,
		unsigned short *flagsp ATTRIBUTE_UNUSED)
{
  switch (bfd_get_arch (abfd))
    {
#ifdef Z80MAGIC
    case bfd_arch_z80:
      *magicp = Z80MAGIC;
      switch (bfd_get_mach (abfd))
	{
	case 0:
	case bfd_mach_z80strict:
	case bfd_mach_z80:
	case bfd_mach_z80full:
	case bfd_mach_r800:
	  *flagsp = bfd_get_mach (abfd) << 12;
	  break;
	default:
	  return FALSE;
	}
      return TRUE;
#endif

#ifdef Z8KMAGIC
    case bfd_arch_z8k:
      *magicp = Z8KMAGIC;

      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_z8001: *flagsp = F_Z8001;	break;
	case bfd_mach_z8002: *flagsp = F_Z8002;	break;
	default:	     return FALSE;
	}
      return TRUE;
#endif

#ifdef I960ROMAGIC
    case bfd_arch_i960:

      {
	unsigned flags;

	*magicp = I960ROMAGIC;

	switch (bfd_get_mach (abfd))
	  {
	  case bfd_mach_i960_core:  flags = F_I960CORE; break;
	  case bfd_mach_i960_kb_sb: flags = F_I960KB;	break;
	  case bfd_mach_i960_mc:    flags = F_I960MC;	break;
	  case bfd_mach_i960_xa:    flags = F_I960XA;	break;
	  case bfd_mach_i960_ca:    flags = F_I960CA;	break;
	  case bfd_mach_i960_ka_sa: flags = F_I960KA;	break;
	  case bfd_mach_i960_jx:    flags = F_I960JX;	break;
	  case bfd_mach_i960_hx:    flags = F_I960HX;	break;
	  default:		    return FALSE;
	  }
	*flagsp = flags;
	return TRUE;
      }
      break;
#endif

#ifdef TIC30MAGIC
    case bfd_arch_tic30:
      *magicp = TIC30MAGIC;
      return TRUE;
#endif

#ifdef TICOFF_DEFAULT_MAGIC
    case TICOFF_TARGET_ARCH:
      /* If there's no indication of which version we want, use the default.  */
      if (!abfd->xvec )
	*magicp = TICOFF_DEFAULT_MAGIC;
      else
	{
	  /* We may want to output in a different COFF version.  */
	  switch (abfd->xvec->name[4])
	    {
	    case '0':
	      *magicp = TICOFF0MAGIC;
	      break;
	    case '1':
	      *magicp = TICOFF1MAGIC;
	      break;
	    case '2':
	      *magicp = TICOFF2MAGIC;
	      break;
	    default:
	      return FALSE;
	    }
	}
      TICOFF_TARGET_MACHINE_SET (flagsp, bfd_get_mach (abfd));
      return TRUE;
#endif

#ifdef TIC80_ARCH_MAGIC
    case bfd_arch_tic80:
      *magicp = TIC80_ARCH_MAGIC;
      return TRUE;
#endif

#ifdef ARMMAGIC
    case bfd_arch_arm:
#ifdef ARM_WINCE
      * magicp = ARMPEMAGIC;
#else
      * magicp = ARMMAGIC;
#endif
      * flagsp = 0;
      if (APCS_SET (abfd))
	{
	  if (APCS_26_FLAG (abfd))
	    * flagsp |= F_APCS26;

	  if (APCS_FLOAT_FLAG (abfd))
	    * flagsp |= F_APCS_FLOAT;

	  if (PIC_FLAG (abfd))
	    * flagsp |= F_PIC;
	}
      if (INTERWORK_SET (abfd) && INTERWORK_FLAG (abfd))
	* flagsp |= F_INTERWORK;
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_arm_2:  * flagsp |= F_ARM_2;  break;
	case bfd_mach_arm_2a: * flagsp |= F_ARM_2a; break;
	case bfd_mach_arm_3:  * flagsp |= F_ARM_3;  break;
	case bfd_mach_arm_3M: * flagsp |= F_ARM_3M; break;
	case bfd_mach_arm_4:  * flagsp |= F_ARM_4;  break;
	case bfd_mach_arm_4T: * flagsp |= F_ARM_4T; break;
	case bfd_mach_arm_5:  * flagsp |= F_ARM_5;  break;
	  /* FIXME: we do not have F_ARM vaues greater than F_ARM_5.
	     See also the comment in coff_set_arch_mach_hook().  */
	case bfd_mach_arm_5T: * flagsp |= F_ARM_5;  break;
	case bfd_mach_arm_5TE: * flagsp |= F_ARM_5; break;
	case bfd_mach_arm_XScale: * flagsp |= F_ARM_5; break;
	}
      return TRUE;
#endif

#ifdef PPCMAGIC
    case bfd_arch_powerpc:
      *magicp = PPCMAGIC;
      return TRUE;
#endif

#if defined(I386MAGIC) || defined(AMD64MAGIC)
    case bfd_arch_i386:
#if defined(I386MAGIC)
      *magicp = I386MAGIC;
#endif
#if defined LYNXOS
      /* Just overwrite the usual value if we're doing Lynx.  */
      *magicp = LYNXCOFFMAGIC;
#endif
#if defined AMD64MAGIC
      *magicp = AMD64MAGIC;
#endif
      return TRUE;
#endif

#ifdef I860MAGIC
    case bfd_arch_i860:
      *magicp = I860MAGIC;
      return TRUE;
#endif

#ifdef IA64MAGIC
    case bfd_arch_ia64:
      *magicp = IA64MAGIC;
      return TRUE;
#endif

#ifdef MC68MAGIC
    case bfd_arch_m68k:
#ifdef APOLLOM68KMAGIC
      *magicp = APOLLO_COFF_VERSION_NUMBER;
#else
      /* NAMES_HAVE_UNDERSCORE may be defined by coff-u68k.c.  */
#ifdef NAMES_HAVE_UNDERSCORE
      *magicp = MC68KBCSMAGIC;
#else
      *magicp = MC68MAGIC;
#endif
#endif
#ifdef LYNXOS
      /* Just overwrite the usual value if we're doing Lynx.  */
      *magicp = LYNXCOFFMAGIC;
#endif
      return TRUE;
#endif

#ifdef MC88MAGIC
    case bfd_arch_m88k:
      *magicp = MC88OMAGIC;
      return TRUE;
#endif

#ifdef H8300MAGIC
    case bfd_arch_h8300:
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_h8300:   *magicp = H8300MAGIC;   return TRUE;
	case bfd_mach_h8300h:  *magicp = H8300HMAGIC;  return TRUE;
	case bfd_mach_h8300s:  *magicp = H8300SMAGIC;  return TRUE;
	case bfd_mach_h8300hn: *magicp = H8300HNMAGIC; return TRUE;
	case bfd_mach_h8300sn: *magicp = H8300SNMAGIC; return TRUE;
	default: break;
	}
      break;
#endif

#ifdef SH_ARCH_MAGIC_BIG
    case bfd_arch_sh:
#ifdef COFF_IMAGE_WITH_PE
      *magicp = SH_ARCH_MAGIC_WINCE;
#else
      if (bfd_big_endian (abfd))
	*magicp = SH_ARCH_MAGIC_BIG;
      else
	*magicp = SH_ARCH_MAGIC_LITTLE;
#endif
      return TRUE;
#endif

#ifdef MIPS_ARCH_MAGIC_WINCE
    case bfd_arch_mips:
      *magicp = MIPS_ARCH_MAGIC_WINCE;
      return TRUE;
#endif

#ifdef SPARCMAGIC
    case bfd_arch_sparc:
      *magicp = SPARCMAGIC;
#ifdef LYNXOS
      /* Just overwrite the usual value if we're doing Lynx.  */
      *magicp = LYNXCOFFMAGIC;
#endif
      return TRUE;
#endif

#ifdef H8500MAGIC
    case bfd_arch_h8500:
      *magicp = H8500MAGIC;
      return TRUE;
      break;
#endif

#ifdef WE32KMAGIC
    case bfd_arch_we32k:
      *magicp = WE32KMAGIC;
      return TRUE;
#endif

#ifdef RS6000COFF_C
    case bfd_arch_rs6000:
#ifndef PPCMAGIC
    case bfd_arch_powerpc:
#endif
      BFD_ASSERT (bfd_get_flavour (abfd) == bfd_target_xcoff_flavour);
      *magicp = bfd_xcoff_magic_number (abfd);
      return TRUE;
#endif

#ifdef MCOREMAGIC
    case bfd_arch_mcore:
      * magicp = MCOREMAGIC;
      return TRUE;
#endif

#ifdef W65MAGIC
    case bfd_arch_w65:
      *magicp = W65MAGIC;
      return TRUE;
#endif

#ifdef OR32_MAGIC_BIG
    case bfd_arch_or32:
      if (bfd_big_endian (abfd))
	* magicp = OR32_MAGIC_BIG;
      else
	* magicp = OR32_MAGIC_LITTLE;
      return TRUE;
#endif

    default:			/* Unknown architecture.  */
      /* Fall through to "return FALSE" below, to avoid
	 "statement never reached" errors on the one below.  */
      break;
    }

  return FALSE;
}

static bfd_boolean
coff_set_arch_mach (bfd * abfd,
		    enum bfd_architecture arch,
		    unsigned long machine)
{
  unsigned dummy1;
  unsigned short dummy2;

  if (! bfd_default_set_arch_mach (abfd, arch, machine))
    return FALSE;

  if (arch != bfd_arch_unknown
      && ! coff_set_flags (abfd, &dummy1, &dummy2))
    return FALSE;		/* We can't represent this type.  */

  return TRUE;			/* We're easy...  */
}

#ifdef COFF_IMAGE_WITH_PE

/* This is used to sort sections by VMA, as required by PE image
   files.  */

static int
sort_by_secaddr (const void * arg1, const void * arg2)
{
  const asection *a = *(const asection **) arg1;
  const asection *b = *(const asection **) arg2;

  if (a->vma < b->vma)
    return -1;
  else if (a->vma > b->vma)
    return 1;

  return 0;
}

#endif /* COFF_IMAGE_WITH_PE */

/* Calculate the file position for each section.  */

#ifndef I960
#define ALIGN_SECTIONS_IN_FILE
#endif
#if defined(TIC80COFF) || defined(TICOFF)
#undef ALIGN_SECTIONS_IN_FILE
#endif

static bfd_boolean
coff_compute_section_file_positions (bfd * abfd)
{
  asection *current;
  file_ptr sofar = bfd_coff_filhsz (abfd);
  bfd_boolean align_adjust;
  int target_index;
#ifdef ALIGN_SECTIONS_IN_FILE
  asection *previous = NULL;
  file_ptr old_sofar;
#endif

#ifdef COFF_IMAGE_WITH_PE
  int page_size;

  if (coff_data (abfd)->link_info)
    {
      page_size = pe_data (abfd)->pe_opthdr.FileAlignment;

      /* If no file alignment has been set, default to one.
	 This repairs 'ld -r' for arm-wince-pe target.  */
      if (page_size == 0)
	page_size = 1;
    }
  else
    page_size = PE_DEF_FILE_ALIGNMENT;
#else
#ifdef COFF_PAGE_SIZE
  int page_size = COFF_PAGE_SIZE;
#endif
#endif

#ifdef RS6000COFF_C
  /* On XCOFF, if we have symbols, set up the .debug section.  */
  if (bfd_get_symcount (abfd) > 0)
    {
      bfd_size_type sz;
      bfd_size_type i, symcount;
      asymbol **symp;

      sz = 0;
      symcount = bfd_get_symcount (abfd);
      for (symp = abfd->outsymbols, i = 0; i < symcount; symp++, i++)
	{
	  coff_symbol_type *cf;

	  cf = coff_symbol_from (abfd, *symp);
	  if (cf != NULL
	      && cf->native != NULL
	      && SYMNAME_IN_DEBUG (&cf->native->u.syment))
	    {
	      size_t len;

	      len = strlen (bfd_asymbol_name (*symp));
	      if (len > SYMNMLEN || bfd_coff_force_symnames_in_strings (abfd))
		sz += len + 1 + bfd_coff_debug_string_prefix_length (abfd);
	    }
	}
      if (sz > 0)
	{
	  asection *dsec;

	  dsec = bfd_make_section_old_way (abfd, DOT_DEBUG);
	  if (dsec == NULL)
	    abort ();
	  dsec->size = sz;
	  dsec->flags |= SEC_HAS_CONTENTS;
	}
    }
#endif

  if (bfd_get_start_address (abfd))
    /*  A start address may have been added to the original file. In this
	case it will need an optional header to record it.  */
    abfd->flags |= EXEC_P;

  if (abfd->flags & EXEC_P)
    sofar += bfd_coff_aoutsz (abfd);
#ifdef RS6000COFF_C
  else if (xcoff_data (abfd)->full_aouthdr)
    sofar += bfd_coff_aoutsz (abfd);
  else
    sofar += SMALL_AOUTSZ;
#endif

  sofar += abfd->section_count * bfd_coff_scnhsz (abfd);

#ifdef RS6000COFF_C
  /* XCOFF handles overflows in the reloc and line number count fields
     by allocating a new section header to hold the correct counts.  */
  for (current = abfd->sections; current != NULL; current = current->next)
    if (current->reloc_count >= 0xffff || current->lineno_count >= 0xffff)
      sofar += bfd_coff_scnhsz (abfd);
#endif

#ifdef COFF_IMAGE_WITH_PE
  {
    /* PE requires the sections to be in memory order when listed in
       the section headers.  It also does not like empty loadable
       sections.  The sections apparently do not have to be in the
       right order in the image file itself, but we do need to get the
       target_index values right.  */

    unsigned int count;
    asection **section_list;
    unsigned int i;
    bfd_size_type amt;

#ifdef COFF_PAGE_SIZE
    /* Clear D_PAGED if section alignment is smaller than
       COFF_PAGE_SIZE.  */
   if (pe_data (abfd)->pe_opthdr.SectionAlignment < COFF_PAGE_SIZE)
     abfd->flags &= ~D_PAGED;
#endif

    count = 0;
    for (current = abfd->sections; current != NULL; current = current->next)
      ++count;

    /* We allocate an extra cell to simplify the final loop.  */
    amt = sizeof (struct asection *) * (count + 1);
    section_list = (asection **) bfd_malloc (amt);
    if (section_list == NULL)
      return FALSE;

    i = 0;
    for (current = abfd->sections; current != NULL; current = current->next)
      {
	section_list[i] = current;
	++i;
      }
    section_list[i] = NULL;

    qsort (section_list, count, sizeof (asection *), sort_by_secaddr);

    /* Rethread the linked list into sorted order; at the same time,
       assign target_index values.  */
    target_index = 1;
    abfd->sections = NULL;
    abfd->section_last = NULL;
    for (i = 0; i < count; i++)
      {
	current = section_list[i];
	bfd_section_list_append (abfd, current);

	/* Later, if the section has zero size, we'll be throwing it
	   away, so we don't want to number it now.  Note that having
	   a zero size and having real contents are different
	   concepts: .bss has no contents, but (usually) non-zero
	   size.  */
	if (current->size == 0)
	  {
	    /* Discard.  However, it still might have (valid) symbols
	       in it, so arbitrarily set it to section 1 (indexing is
	       1-based here; usually .text).  __end__ and other
	       contents of .endsection really have this happen.
	       FIXME: This seems somewhat dubious.  */
	    current->target_index = 1;
	  }
	else
	  current->target_index = target_index++;
      }

    free (section_list);
  }
#else /* ! COFF_IMAGE_WITH_PE */
  {
    /* Set the target_index field.  */
    target_index = 1;
    for (current = abfd->sections; current != NULL; current = current->next)
      current->target_index = target_index++;
  }
#endif /* ! COFF_IMAGE_WITH_PE */

  if (target_index >= 32768)
    {
      bfd_set_error (bfd_error_file_too_big);
      (*_bfd_error_handler)
	(_("%B: too many sections (%d)"), abfd, target_index);
      return FALSE;
    }

  align_adjust = FALSE;
  for (current = abfd->sections;
       current != NULL;
       current = current->next)
    {
#ifdef COFF_IMAGE_WITH_PE
      /* With PE we have to pad each section to be a multiple of its
	 page size too, and remember both sizes.  */
      if (coff_section_data (abfd, current) == NULL)
	{
	  bfd_size_type amt = sizeof (struct coff_section_tdata);

	  current->used_by_bfd = bfd_zalloc (abfd, amt);
	  if (current->used_by_bfd == NULL)
	    return FALSE;
	}
      if (pei_section_data (abfd, current) == NULL)
	{
	  bfd_size_type amt = sizeof (struct pei_section_tdata);

	  coff_section_data (abfd, current)->tdata = bfd_zalloc (abfd, amt);
	  if (coff_section_data (abfd, current)->tdata == NULL)
	    return FALSE;
	}
      if (pei_section_data (abfd, current)->virt_size == 0)
	pei_section_data (abfd, current)->virt_size = current->size;
#endif

      /* Only deal with sections which have contents.  */
      if (!(current->flags & SEC_HAS_CONTENTS))
	continue;

      current->rawsize = current->size;

#ifdef COFF_IMAGE_WITH_PE
      /* Make sure we skip empty sections in a PE image.  */
      if (current->size == 0)
	continue;
#endif

      /* Align the sections in the file to the same boundary on
	 which they are aligned in virtual memory.  I960 doesn't
	 do this (FIXME) so we can stay in sync with Intel.  960
	 doesn't yet page from files...  */
#ifdef ALIGN_SECTIONS_IN_FILE
      if ((abfd->flags & EXEC_P) != 0)
	{
	  /* Make sure this section is aligned on the right boundary - by
	     padding the previous section up if necessary.  */
	  old_sofar = sofar;

	  sofar = BFD_ALIGN (sofar, 1 << current->alignment_power);

#ifdef RS6000COFF_C
	  /* Make sure the file offset and the vma of .text/.data are at the
	     same page offset, so that the file can be mmap'ed without being
	     relocated.  Failing that, AIX is able to load and execute the
	     program, but it will be silently relocated (possible as
	     executables are PIE).  But the relocation is slightly costly and
	     complexify the use of addr2line or gdb.  So better to avoid it,
	     like does the native linker.  Usually gnu ld makes sure that
	     the vma of .text is the file offset so this issue shouldn't
	     appear unless you are stripping such an executable.

	     AIX loader checks the text section alignment of (vma - filepos),
	     and the native linker doesn't try to align the text sections.
	     For example:

	     0 .text         000054cc  10000128  10000128  00000128  2**5
                             CONTENTS, ALLOC, LOAD, CODE
	  */

	  if (!strcmp (current->name, _TEXT)
	      || !strcmp (current->name, _DATA))
	    {
	      bfd_vma align = 4096;
	      bfd_vma sofar_off = sofar % align;
	      bfd_vma vma_off = current->vma % align;

	      if (vma_off > sofar_off)
		sofar += vma_off - sofar_off;
	      else if (vma_off < sofar_off)
		sofar += align + vma_off - sofar_off;
	    }
#endif
	  if (previous != NULL)
	    previous->size += sofar - old_sofar;
	}

#endif

      /* In demand paged files the low order bits of the file offset
	 must match the low order bits of the virtual address.  */
#ifdef COFF_PAGE_SIZE
      if ((abfd->flags & D_PAGED) != 0
	  && (current->flags & SEC_ALLOC) != 0)
	sofar += (current->vma - (bfd_vma) sofar) % page_size;
#endif
      current->filepos = sofar;

#ifdef COFF_IMAGE_WITH_PE
      /* Set the padded size.  */
      current->size = (current->size + page_size - 1) & -page_size;
#endif

      sofar += current->size;

#ifdef ALIGN_SECTIONS_IN_FILE
      /* Make sure that this section is of the right size too.  */
      if ((abfd->flags & EXEC_P) == 0)
	{
	  bfd_size_type old_size;

	  old_size = current->size;
	  current->size = BFD_ALIGN (current->size,
				     1 << current->alignment_power);
	  align_adjust = current->size != old_size;
	  sofar += current->size - old_size;
	}
      else
	{
	  old_sofar = sofar;
	  sofar = BFD_ALIGN (sofar, 1 << current->alignment_power);
	  align_adjust = sofar != old_sofar;
	  current->size += sofar - old_sofar;
	}
#endif

#ifdef COFF_IMAGE_WITH_PE
      /* For PE we need to make sure we pad out to the aligned
	 size, in case the caller only writes out data to the
	 unaligned size.  */
      if (pei_section_data (abfd, current)->virt_size < current->size)
	align_adjust = TRUE;
#endif

#ifdef _LIB
      /* Force .lib sections to start at zero.  The vma is then
	 incremented in coff_set_section_contents.  This is right for
	 SVR3.2.  */
      if (strcmp (current->name, _LIB) == 0)
	(void) bfd_set_section_vma (abfd, current, 0);
#endif

#ifdef ALIGN_SECTIONS_IN_FILE
      previous = current;
#endif
    }

  /* It is now safe to write to the output file.  If we needed an
     alignment adjustment for the last section, then make sure that
     there is a byte at offset sofar.  If there are no symbols and no
     relocs, then nothing follows the last section.  If we don't force
     the last byte out, then the file may appear to be truncated.  */
  if (align_adjust)
    {
      bfd_byte b;

      b = 0;
      if (bfd_seek (abfd, sofar - 1, SEEK_SET) != 0
	  || bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
	return FALSE;
    }

  /* Make sure the relocations are aligned.  We don't need to make
     sure that this byte exists, because it will only matter if there
     really are relocs.  */
  sofar = BFD_ALIGN (sofar, 1 << COFF_DEFAULT_SECTION_ALIGNMENT_POWER);

  obj_relocbase (abfd) = sofar;
  abfd->output_has_begun = TRUE;

  return TRUE;
}

#ifdef COFF_IMAGE_WITH_PE

static unsigned int pelength;
static unsigned int peheader;

static bfd_boolean
coff_read_word (bfd *abfd, unsigned int *value)
{
  unsigned char b[2];
  int status;

  status = bfd_bread (b, (bfd_size_type) 2, abfd);
  if (status < 1)
    {
      *value = 0;
      return FALSE;
    }

  if (status == 1)
    *value = (unsigned int) b[0];
  else
    *value = (unsigned int) (b[0] + (b[1] << 8));

  pelength += (unsigned int) status;

  return TRUE;
}

static unsigned int
coff_compute_checksum (bfd *abfd)
{
  bfd_boolean more_data;
  file_ptr filepos;
  unsigned int value;
  unsigned int total;

  total = 0;
  pelength = 0;
  filepos = (file_ptr) 0;

  do
    {
      if (bfd_seek (abfd, filepos, SEEK_SET) != 0)
	return 0;

      more_data = coff_read_word (abfd, &value);
      total += value;
      total = 0xffff & (total + (total >> 0x10));
      filepos += 2;
    }
  while (more_data);

  return (0xffff & (total + (total >> 0x10)));
}

static bfd_boolean
coff_apply_checksum (bfd *abfd)
{
  unsigned int computed;
  unsigned int checksum = 0;

  if (bfd_seek (abfd, 0x3c, SEEK_SET) != 0)
    return FALSE;

  if (!coff_read_word (abfd, &peheader))
    return FALSE;

  if (bfd_seek (abfd, peheader + 0x58, SEEK_SET) != 0)
    return FALSE;

  checksum = 0;
  bfd_bwrite (&checksum, (bfd_size_type) 4, abfd);

  if (bfd_seek (abfd, peheader, SEEK_SET) != 0)
    return FALSE;

  computed = coff_compute_checksum (abfd);

  checksum = computed + pelength;

  if (bfd_seek (abfd, peheader + 0x58, SEEK_SET) != 0)
    return FALSE;

  bfd_bwrite (&checksum, (bfd_size_type) 4, abfd);

  return TRUE;
}

#endif /* COFF_IMAGE_WITH_PE */

static bfd_boolean
coff_write_object_contents (bfd * abfd)
{
  asection *current;
  bfd_boolean hasrelocs = FALSE;
  bfd_boolean haslinno = FALSE;
#ifdef COFF_IMAGE_WITH_PE
  bfd_boolean hasdebug = FALSE;
#endif
  file_ptr scn_base;
  file_ptr reloc_base;
  file_ptr lineno_base;
  file_ptr sym_base;
  unsigned long reloc_size = 0, reloc_count = 0;
  unsigned long lnno_size = 0;
  bfd_boolean long_section_names;
  asection *text_sec = NULL;
  asection *data_sec = NULL;
  asection *bss_sec = NULL;
  struct internal_filehdr internal_f;
  struct internal_aouthdr internal_a;
#ifdef COFF_LONG_SECTION_NAMES
  size_t string_size = STRING_SIZE_SIZE;
#endif

  bfd_set_error (bfd_error_system_call);

  /* Make a pass through the symbol table to count line number entries and
     put them into the correct asections.  */
  lnno_size = coff_count_linenumbers (abfd) * bfd_coff_linesz (abfd);

  if (! abfd->output_has_begun)
    {
      if (! coff_compute_section_file_positions (abfd))
	return FALSE;
    }

  reloc_base = obj_relocbase (abfd);

  /* Work out the size of the reloc and linno areas.  */

  for (current = abfd->sections; current != NULL; current =
       current->next)
    {
#ifdef COFF_WITH_PE
      /* We store the actual reloc count in the first reloc's addr.  */
      if (obj_pe (abfd) && current->reloc_count >= 0xffff)
	reloc_count ++;
#endif
      reloc_count += current->reloc_count;
    }

  reloc_size = reloc_count * bfd_coff_relsz (abfd);

  lineno_base = reloc_base + reloc_size;
  sym_base = lineno_base + lnno_size;

  /* Indicate in each section->line_filepos its actual file address.  */
  for (current = abfd->sections; current != NULL; current =
       current->next)
    {
      if (current->lineno_count)
	{
	  current->line_filepos = lineno_base;
	  current->moving_line_filepos = lineno_base;
	  lineno_base += current->lineno_count * bfd_coff_linesz (abfd);
	}
      else
	current->line_filepos = 0;

      if (current->reloc_count)
	{
	  current->rel_filepos = reloc_base;
	  reloc_base += current->reloc_count * bfd_coff_relsz (abfd);
#ifdef COFF_WITH_PE
	  /* Extra reloc to hold real count.  */
	  if (obj_pe (abfd) && current->reloc_count >= 0xffff)
	    reloc_base += bfd_coff_relsz (abfd);
#endif
	}
      else
	current->rel_filepos = 0;
    }

  /* Write section headers to the file.  */
  internal_f.f_nscns = 0;

  if ((abfd->flags & EXEC_P) != 0)
    scn_base = bfd_coff_filhsz (abfd) + bfd_coff_aoutsz (abfd);
  else
    {
      scn_base = bfd_coff_filhsz (abfd);
#ifdef RS6000COFF_C
#ifndef XCOFF64
      if (xcoff_data (abfd)->full_aouthdr)
	scn_base += bfd_coff_aoutsz (abfd);
      else
	scn_base += SMALL_AOUTSZ;
#endif
#endif
    }

  if (bfd_seek (abfd, scn_base, SEEK_SET) != 0)
    return FALSE;

  long_section_names = FALSE;
  for (current = abfd->sections;
       current != NULL;
       current = current->next)
    {
      struct internal_scnhdr section;
#ifdef COFF_IMAGE_WITH_PE
      bfd_boolean is_reloc_section = FALSE;

      if (strcmp (current->name, DOT_RELOC) == 0)
	{
	  is_reloc_section = TRUE;
	  hasrelocs = TRUE;
	  pe_data (abfd)->has_reloc_section = 1;
	}
#endif

      internal_f.f_nscns++;

      strncpy (section.s_name, current->name, SCNNMLEN);

#ifdef COFF_LONG_SECTION_NAMES
      /* Handle long section names as in PE.  This must be compatible
	 with the code in coff_write_symbols and _bfd_coff_final_link.  */
      if (bfd_coff_long_section_names (abfd))
	{
	  size_t len;

	  len = strlen (current->name);
	  if (len > SCNNMLEN)
	    {
	      /* The s_name field is defined to be NUL-padded but need not be
		 NUL-terminated.  We use a temporary buffer so that we can still
		 sprintf all eight chars without splatting a terminating NUL
		 over the first byte of the following member (s_paddr).  */
	      char s_name_buf[SCNNMLEN + 1];

	      /* An inherent limitation of the /nnnnnnn notation used to indicate
		 the offset of the long name in the string table is that we
		 cannot address entries beyone the ten million byte boundary.  */
	      if (string_size >= 10000000)
		{
		  bfd_set_error (bfd_error_file_too_big);
		  (*_bfd_error_handler)
		    (_("%B: section %s: string table overflow at offset %ld"),
		    abfd, current->name, string_size);
		  return FALSE;
		}

	      /* snprintf not strictly necessary now we've verified the value
		 has less than eight ASCII digits, but never mind.  */
	      snprintf (s_name_buf, SCNNMLEN + 1, "/%lu", (unsigned long) string_size);
	      /* Then strncpy takes care of any padding for us.  */
	      strncpy (section.s_name, s_name_buf, SCNNMLEN);
	      string_size += len + 1;
	      long_section_names = TRUE;
	    }
	}
#endif

#ifdef _LIB
      /* Always set s_vaddr of .lib to 0.  This is right for SVR3.2
	 Ian Taylor <ian@@cygnus.com>.  */
      if (strcmp (current->name, _LIB) == 0)
	section.s_vaddr = 0;
      else
#endif
      section.s_vaddr = current->vma;
      section.s_paddr = current->lma;
      section.s_size =  current->size;
#ifdef coff_get_section_load_page
      section.s_page = coff_get_section_load_page (current);
#else
      section.s_page = 0;
#endif

#ifdef COFF_WITH_PE
      section.s_paddr = 0;
#endif
#ifdef COFF_IMAGE_WITH_PE
      /* Reminder: s_paddr holds the virtual size of the section.  */
      if (coff_section_data (abfd, current) != NULL
	  && pei_section_data (abfd, current) != NULL)
	section.s_paddr = pei_section_data (abfd, current)->virt_size;
      else
	section.s_paddr = 0;
#endif

      /* If this section has no size or is unloadable then the scnptr
	 will be 0 too.  */
      if (current->size == 0
	  || (current->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	section.s_scnptr = 0;
      else
	section.s_scnptr = current->filepos;

      section.s_relptr = current->rel_filepos;
      section.s_lnnoptr = current->line_filepos;
      section.s_nreloc = current->reloc_count;
      section.s_nlnno = current->lineno_count;
#ifndef COFF_IMAGE_WITH_PE
      /* In PEI, relocs come in the .reloc section.  */
      if (current->reloc_count != 0)
	hasrelocs = TRUE;
#endif
      if (current->lineno_count != 0)
	haslinno = TRUE;
#ifdef COFF_IMAGE_WITH_PE
      if ((current->flags & SEC_DEBUGGING) != 0
	  && ! is_reloc_section)
	hasdebug = TRUE;
#endif

#ifdef RS6000COFF_C
#ifndef XCOFF64
      /* Indicate the use of an XCOFF overflow section header.  */
      if (current->reloc_count >= 0xffff || current->lineno_count >= 0xffff)
	{
	  section.s_nreloc = 0xffff;
	  section.s_nlnno = 0xffff;
	}
#endif
#endif

      section.s_flags = sec_to_styp_flags (current->name, current->flags);

      if (!strcmp (current->name, _TEXT))
	text_sec = current;
      else if (!strcmp (current->name, _DATA))
	data_sec = current;
      else if (!strcmp (current->name, _BSS))
	bss_sec = current;

#ifdef I960
      section.s_align = (current->alignment_power
			 ? 1 << current->alignment_power
			 : 0);
#endif
#ifdef TIC80COFF
      /* TI COFF puts the alignment power in bits 8-11 of the flags.  */
      section.s_flags |= (current->alignment_power & 0xF) << 8;
#endif
#ifdef COFF_ENCODE_ALIGNMENT
      COFF_ENCODE_ALIGNMENT(section, current->alignment_power);
#endif

#ifdef COFF_IMAGE_WITH_PE
      /* Suppress output of the sections if they are null.  ld
	 includes the bss and data sections even if there is no size
	 assigned to them.  NT loader doesn't like it if these section
	 headers are included if the sections themselves are not
	 needed.  See also coff_compute_section_file_positions.  */
      if (section.s_size == 0)
	internal_f.f_nscns--;
      else
#endif
	{
	  SCNHDR buff;
	  bfd_size_type amt = bfd_coff_scnhsz (abfd);

	  if (coff_swap_scnhdr_out (abfd, &section, &buff) == 0
	      || bfd_bwrite (& buff, amt, abfd) != amt)
	    return FALSE;
	}

#ifdef COFF_WITH_PE
      /* PE stores COMDAT section information in the symbol table.  If
	 this section is supposed to have some COMDAT info, track down
	 the symbol in the symbol table and modify it.  */
      if ((current->flags & SEC_LINK_ONCE) != 0)
	{
	  unsigned int i, count;
	  asymbol **psym;
	  coff_symbol_type *csym = NULL;
	  asymbol **psymsec;

	  psymsec = NULL;
	  count = bfd_get_symcount (abfd);
	  for (i = 0, psym = abfd->outsymbols; i < count; i++, psym++)
	    {
	      if ((*psym)->section != current)
		continue;

	      /* Remember the location of the first symbol in this
		 section.  */
	      if (psymsec == NULL)
		psymsec = psym;

	      /* See if this is the section symbol.  */
	      if (strcmp ((*psym)->name, current->name) == 0)
		{
		  csym = coff_symbol_from (abfd, *psym);
		  if (csym == NULL
		      || csym->native == NULL
		      || csym->native->u.syment.n_numaux < 1
		      || csym->native->u.syment.n_sclass != C_STAT
		      || csym->native->u.syment.n_type != T_NULL)
		    continue;

		  /* Here *PSYM is the section symbol for CURRENT.  */

		  break;
		}
	    }

	  /* Did we find it?
	     Note that we might not if we're converting the file from
	     some other object file format.  */
	  if (i < count)
	    {
	      combined_entry_type *aux;

	      /* We don't touch the x_checksum field.  The
		 x_associated field is not currently supported.  */

	      aux = csym->native + 1;
	      switch (current->flags & SEC_LINK_DUPLICATES)
		{
		case SEC_LINK_DUPLICATES_DISCARD:
		  aux->u.auxent.x_scn.x_comdat = IMAGE_COMDAT_SELECT_ANY;
		  break;

		case SEC_LINK_DUPLICATES_ONE_ONLY:
		  aux->u.auxent.x_scn.x_comdat =
		    IMAGE_COMDAT_SELECT_NODUPLICATES;
		  break;

		case SEC_LINK_DUPLICATES_SAME_SIZE:
		  aux->u.auxent.x_scn.x_comdat =
		    IMAGE_COMDAT_SELECT_SAME_SIZE;
		  break;

		case SEC_LINK_DUPLICATES_SAME_CONTENTS:
		  aux->u.auxent.x_scn.x_comdat =
		    IMAGE_COMDAT_SELECT_EXACT_MATCH;
		  break;
		}

	      /* The COMDAT symbol must be the first symbol from this
		 section in the symbol table.  In order to make this
		 work, we move the COMDAT symbol before the first
		 symbol we found in the search above.  It's OK to
		 rearrange the symbol table at this point, because
		 coff_renumber_symbols is going to rearrange it
		 further and fix up all the aux entries.  */
	      if (psym != psymsec)
		{
		  asymbol *hold;
		  asymbol **pcopy;

		  hold = *psym;
		  for (pcopy = psym; pcopy > psymsec; pcopy--)
		    pcopy[0] = pcopy[-1];
		  *psymsec = hold;
		}
	    }
	}
#endif /* COFF_WITH_PE */
    }

#ifdef RS6000COFF_C
#ifndef XCOFF64
  /* XCOFF handles overflows in the reloc and line number count fields
     by creating a new section header to hold the correct values.  */
  for (current = abfd->sections; current != NULL; current = current->next)
    {
      if (current->reloc_count >= 0xffff || current->lineno_count >= 0xffff)
	{
	  struct internal_scnhdr scnhdr;
	  SCNHDR buff;
	  bfd_size_type amt;

	  internal_f.f_nscns++;
	  memcpy (scnhdr.s_name, ".ovrflo", 8);
	  scnhdr.s_paddr = current->reloc_count;
	  scnhdr.s_vaddr = current->lineno_count;
	  scnhdr.s_size = 0;
	  scnhdr.s_scnptr = 0;
	  scnhdr.s_relptr = current->rel_filepos;
	  scnhdr.s_lnnoptr = current->line_filepos;
	  scnhdr.s_nreloc = current->target_index;
	  scnhdr.s_nlnno = current->target_index;
	  scnhdr.s_flags = STYP_OVRFLO;
	  amt = bfd_coff_scnhsz (abfd);
	  if (coff_swap_scnhdr_out (abfd, &scnhdr, &buff) == 0
	      || bfd_bwrite (& buff, amt, abfd) != amt)
	    return FALSE;
	}
    }
#endif
#endif

  /* OK, now set up the filehdr...  */

  /* Don't include the internal abs section in the section count */

  /* We will NOT put a fucking timestamp in the header here. Every time you
     put it back, I will come in and take it out again.  I'm sorry.  This
     field does not belong here.  We fill it with a 0 so it compares the
     same but is not a reasonable time. -- gnu@@cygnus.com  */
  internal_f.f_timdat = 0;
  internal_f.f_flags = 0;

  if (abfd->flags & EXEC_P)
    internal_f.f_opthdr = bfd_coff_aoutsz (abfd);
  else
    {
      internal_f.f_opthdr = 0;
#ifdef RS6000COFF_C
#ifndef XCOFF64
      if (xcoff_data (abfd)->full_aouthdr)
	internal_f.f_opthdr = bfd_coff_aoutsz (abfd);
      else
	internal_f.f_opthdr = SMALL_AOUTSZ;
#endif
#endif
    }

  if (!hasrelocs)
    internal_f.f_flags |= F_RELFLG;
  if (!haslinno)
    internal_f.f_flags |= F_LNNO;
  if (abfd->flags & EXEC_P)
    internal_f.f_flags |= F_EXEC;
#ifdef COFF_IMAGE_WITH_PE
  if (! hasdebug)
    internal_f.f_flags |= IMAGE_FILE_DEBUG_STRIPPED;
  if (pe_data (abfd)->real_flags & IMAGE_FILE_LARGE_ADDRESS_AWARE)
    internal_f.f_flags |= IMAGE_FILE_LARGE_ADDRESS_AWARE;
#endif

#ifndef COFF_WITH_pex64
#ifdef COFF_WITH_PE
  internal_f.f_flags |= IMAGE_FILE_32BIT_MACHINE;
#else
  if (bfd_little_endian (abfd))
    internal_f.f_flags |= F_AR32WR;
  else
    internal_f.f_flags |= F_AR32W;
#endif
#endif

#ifdef TI_TARGET_ID
  /* Target id is used in TI COFF v1 and later; COFF0 won't use this field,
     but it doesn't hurt to set it internally.  */
  internal_f.f_target_id = TI_TARGET_ID;
#endif
#ifdef TIC80_TARGET_ID
  internal_f.f_target_id = TIC80_TARGET_ID;
#endif

  /* FIXME, should do something about the other byte orders and
     architectures.  */

#ifdef RS6000COFF_C
  if ((abfd->flags & DYNAMIC) != 0)
    internal_f.f_flags |= F_SHROBJ;
  if (bfd_get_section_by_name (abfd, _LOADER) != NULL)
    internal_f.f_flags |= F_DYNLOAD;
#endif

  memset (&internal_a, 0, sizeof internal_a);

  /* Set up architecture-dependent stuff.  */
  {
    unsigned int magic = 0;
    unsigned short flags = 0;

    coff_set_flags (abfd, &magic, &flags);
    internal_f.f_magic = magic;
    internal_f.f_flags |= flags;
    /* ...and the "opt"hdr...  */

#ifdef TICOFF_AOUT_MAGIC
    internal_a.magic = TICOFF_AOUT_MAGIC;
#define __A_MAGIC_SET__
#endif
#ifdef TIC80COFF
    internal_a.magic = TIC80_ARCH_MAGIC;
#define __A_MAGIC_SET__
#endif /* TIC80 */
#ifdef I860
    /* FIXME: What are the a.out magic numbers for the i860?  */
    internal_a.magic = 0;
#define __A_MAGIC_SET__
#endif /* I860 */
#ifdef I960
    internal_a.magic = (magic == I960ROMAGIC ? NMAGIC : OMAGIC);
#define __A_MAGIC_SET__
#endif /* I960 */
#if M88
#define __A_MAGIC_SET__
    internal_a.magic = PAGEMAGICBCS;
#endif /* M88 */

#if APOLLO_M68
#define __A_MAGIC_SET__
    internal_a.magic = APOLLO_COFF_VERSION_NUMBER;
#endif

#if defined(M68) || defined(WE32K) || defined(M68K)
#define __A_MAGIC_SET__
#if defined(LYNXOS)
    internal_a.magic = LYNXCOFFMAGIC;
#else
#if defined(TARG_AUX)
    internal_a.magic = (abfd->flags & D_PAGED ? PAGEMAGICPEXECPAGED :
			abfd->flags & WP_TEXT ? PAGEMAGICPEXECSWAPPED :
			PAGEMAGICEXECSWAPPED);
#else
#if defined (PAGEMAGICPEXECPAGED)
    internal_a.magic = PAGEMAGICPEXECPAGED;
#endif
#endif /* TARG_AUX */
#endif /* LYNXOS */
#endif /* M68 || WE32K || M68K */

#if defined(ARM)
#define __A_MAGIC_SET__
    internal_a.magic = ZMAGIC;
#endif

#if defined(PPC_PE)
#define __A_MAGIC_SET__
    internal_a.magic = IMAGE_NT_OPTIONAL_HDR_MAGIC;
#endif

#if defined MCORE_PE
#define __A_MAGIC_SET__
    internal_a.magic = IMAGE_NT_OPTIONAL_HDR_MAGIC;
#endif

#if defined(I386)
#define __A_MAGIC_SET__
#if defined LYNXOS
    internal_a.magic = LYNXCOFFMAGIC;
#elif defined AMD64
    internal_a.magic = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
#else
    internal_a.magic = ZMAGIC;
#endif
#endif /* I386 */

#if defined(IA64)
#define __A_MAGIC_SET__
    internal_a.magic = PE32PMAGIC;
#endif /* IA64 */

#if defined(SPARC)
#define __A_MAGIC_SET__
#if defined(LYNXOS)
    internal_a.magic = LYNXCOFFMAGIC;
#endif /* LYNXOS */
#endif /* SPARC */

#ifdef RS6000COFF_C
#define __A_MAGIC_SET__
    internal_a.magic = (abfd->flags & D_PAGED) ? RS6K_AOUTHDR_ZMAGIC :
    (abfd->flags & WP_TEXT) ? RS6K_AOUTHDR_NMAGIC :
    RS6K_AOUTHDR_OMAGIC;
#endif

#if defined(SH) && defined(COFF_WITH_PE)
#define __A_MAGIC_SET__
    internal_a.magic = SH_PE_MAGIC;
#endif

#if defined(MIPS) && defined(COFF_WITH_PE)
#define __A_MAGIC_SET__
    internal_a.magic = MIPS_PE_MAGIC;
#endif

#ifdef OR32
#define __A_MAGIC_SET__
    internal_a.magic = NMAGIC; /* Assume separate i/d.  */
#endif

#ifndef __A_MAGIC_SET__
#include "Your aouthdr magic number is not being set!"
#else
#undef __A_MAGIC_SET__
#endif
  }

  /* FIXME: Does anybody ever set this to another value?  */
  internal_a.vstamp = 0;

  /* Now should write relocs, strings, syms.  */
  obj_sym_filepos (abfd) = sym_base;

  if (bfd_get_symcount (abfd) != 0)
    {
      int firstundef;

      if (!coff_renumber_symbols (abfd, &firstundef))
	return FALSE;
      coff_mangle_symbols (abfd);
      if (! coff_write_symbols (abfd))
	return FALSE;
      if (! coff_write_linenumbers (abfd))
	return FALSE;
      if (! coff_write_relocs (abfd, firstundef))
	return FALSE;
    }
#ifdef COFF_LONG_SECTION_NAMES
  else if (long_section_names && ! obj_coff_strings_written (abfd))
    {
      /* If we have long section names we have to write out the string
	 table even if there are no symbols.  */
      if (! coff_write_symbols (abfd))
	return FALSE;
    }
#endif
#ifdef COFF_IMAGE_WITH_PE
#ifdef PPC_PE
  else if ((abfd->flags & EXEC_P) != 0)
    {
      bfd_byte b;

      /* PowerPC PE appears to require that all executable files be
	 rounded up to the page size.  */
      b = 0;
      if (bfd_seek (abfd,
		    (file_ptr) BFD_ALIGN (sym_base, COFF_PAGE_SIZE) - 1,
		    SEEK_SET) != 0
	  || bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
	return FALSE;
    }
#endif
#endif

  /* If bfd_get_symcount (abfd) != 0, then we are not using the COFF
     backend linker, and obj_raw_syment_count is not valid until after
     coff_write_symbols is called.  */
  if (obj_raw_syment_count (abfd) != 0)
    {
      internal_f.f_symptr = sym_base;
#ifdef RS6000COFF_C
      /* AIX appears to require that F_RELFLG not be set if there are
	 local symbols but no relocations.  */
      internal_f.f_flags &=~ F_RELFLG;
#endif
    }
  else
    {
      if (long_section_names)
	internal_f.f_symptr = sym_base;
      else
	internal_f.f_symptr = 0;
      internal_f.f_flags |= F_LSYMS;
    }

  if (text_sec)
    {
      internal_a.tsize = text_sec->size;
      internal_a.text_start = internal_a.tsize ? text_sec->vma : 0;
    }
  if (data_sec)
    {
      internal_a.dsize = data_sec->size;
      internal_a.data_start = internal_a.dsize ? data_sec->vma : 0;
    }
  if (bss_sec)
    {
      internal_a.bsize = bss_sec->size;
      if (internal_a.bsize && bss_sec->vma < internal_a.data_start)
	internal_a.data_start = bss_sec->vma;
    }

  internal_a.entry = bfd_get_start_address (abfd);
  internal_f.f_nsyms = obj_raw_syment_count (abfd);

#ifdef RS6000COFF_C
  if (xcoff_data (abfd)->full_aouthdr)
    {
      bfd_vma toc;
      asection *loader_sec;

      internal_a.vstamp = 1;

      internal_a.o_snentry = xcoff_data (abfd)->snentry;
      if (internal_a.o_snentry == 0)
	internal_a.entry = (bfd_vma) -1;

      if (text_sec != NULL)
	{
	  internal_a.o_sntext = text_sec->target_index;
	  internal_a.o_algntext = bfd_get_section_alignment (abfd, text_sec);
	}
      else
	{
	  internal_a.o_sntext = 0;
	  internal_a.o_algntext = 0;
	}
      if (data_sec != NULL)
	{
	  internal_a.o_sndata = data_sec->target_index;
	  internal_a.o_algndata = bfd_get_section_alignment (abfd, data_sec);
	}
      else
	{
	  internal_a.o_sndata = 0;
	  internal_a.o_algndata = 0;
	}
      loader_sec = bfd_get_section_by_name (abfd, ".loader");
      if (loader_sec != NULL)
	internal_a.o_snloader = loader_sec->target_index;
      else
	internal_a.o_snloader = 0;
      if (bss_sec != NULL)
	internal_a.o_snbss = bss_sec->target_index;
      else
	internal_a.o_snbss = 0;

      toc = xcoff_data (abfd)->toc;
      internal_a.o_toc = toc;
      internal_a.o_sntoc = xcoff_data (abfd)->sntoc;

      internal_a.o_modtype = xcoff_data (abfd)->modtype;
      if (xcoff_data (abfd)->cputype != -1)
	internal_a.o_cputype = xcoff_data (abfd)->cputype;
      else
	{
	  switch (bfd_get_arch (abfd))
	    {
	    case bfd_arch_rs6000:
	      internal_a.o_cputype = 4;
	      break;
	    case bfd_arch_powerpc:
	      if (bfd_get_mach (abfd) == bfd_mach_ppc)
		internal_a.o_cputype = 3;
	      else
		internal_a.o_cputype = 1;
	      break;
	    default:
	      abort ();
	    }
	}
      internal_a.o_maxstack = xcoff_data (abfd)->maxstack;
      internal_a.o_maxdata = xcoff_data (abfd)->maxdata;
    }
#endif

  /* Now write them.  */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;

  {
    char * buff;
    bfd_size_type amount = bfd_coff_filhsz (abfd);

    buff = (char *) bfd_malloc (amount);
    if (buff == NULL)
      return FALSE;

    bfd_coff_swap_filehdr_out (abfd, & internal_f, buff);
    amount = bfd_bwrite (buff, amount, abfd);

    free (buff);

    if (amount != bfd_coff_filhsz (abfd))
      return FALSE;
  }

  if (abfd->flags & EXEC_P)
    {
      /* Note that peicode.h fills in a PEAOUTHDR, not an AOUTHDR.
	 include/coff/pe.h sets AOUTSZ == sizeof (PEAOUTHDR)).  */
      char * buff;
      bfd_size_type amount = bfd_coff_aoutsz (abfd);

      buff = (char *) bfd_malloc (amount);
      if (buff == NULL)
	return FALSE;

      coff_swap_aouthdr_out (abfd, & internal_a, buff);
      amount = bfd_bwrite (buff, amount, abfd);

      free (buff);

      if (amount != bfd_coff_aoutsz (abfd))
	return FALSE;

#ifdef COFF_IMAGE_WITH_PE
      if (! coff_apply_checksum (abfd))
	return FALSE;
#endif
    }
#ifdef RS6000COFF_C
  else
    {
      AOUTHDR buff;
      size_t size;

      /* XCOFF seems to always write at least a small a.out header.  */
      coff_swap_aouthdr_out (abfd, & internal_a, & buff);
      if (xcoff_data (abfd)->full_aouthdr)
	size = bfd_coff_aoutsz (abfd);
      else
	size = SMALL_AOUTSZ;
      if (bfd_bwrite (& buff, (bfd_size_type) size, abfd) != size)
	return FALSE;
    }
#endif

  return TRUE;
}

static bfd_boolean
coff_set_section_contents (bfd * abfd,
			   sec_ptr section,
			   const void * location,
			   file_ptr offset,
			   bfd_size_type count)
{
  if (! abfd->output_has_begun)	/* Set by bfd.c handler.  */
    {
      if (! coff_compute_section_file_positions (abfd))
	return FALSE;
    }

#if defined(_LIB) && !defined(TARG_AUX)
   /* The physical address field of a .lib section is used to hold the
      number of shared libraries in the section.  This code counts the
      number of sections being written, and increments the lma field
      with the number.

      I have found no documentation on the contents of this section.
      Experimentation indicates that the section contains zero or more
      records, each of which has the following structure:

      - a (four byte) word holding the length of this record, in words,
      - a word that always seems to be set to "2",
      - the path to a shared library, null-terminated and then padded
        to a whole word boundary.

      bfd_assert calls have been added to alert if an attempt is made
      to write a section which doesn't follow these assumptions.  The
      code has been tested on ISC 4.1 by me, and on SCO by Robert Lipe
      <robertl@@arnet.com> (Thanks!).

      Gvran Uddeborg <gvran@@uddeborg.pp.se>.  */
    if (strcmp (section->name, _LIB) == 0)
      {
	bfd_byte *rec, *recend;

	rec = (bfd_byte *) location;
	recend = rec + count;
	while (rec < recend)
	  {
	    ++section->lma;
	    rec += bfd_get_32 (abfd, rec) * 4;
	  }

	BFD_ASSERT (rec == recend);
      }
#endif

  /* Don't write out bss sections - one way to do this is to
       see if the filepos has not been set.  */
  if (section->filepos == 0)
    return TRUE;

  if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0)
    return FALSE;

  if (count == 0)
    return TRUE;

  return bfd_bwrite (location, count, abfd) == count;
}

static void *
buy_and_read (bfd *abfd, file_ptr where, bfd_size_type size)
{
  void * area = bfd_alloc (abfd, size);

  if (!area)
    return (NULL);
  if (bfd_seek (abfd, where, SEEK_SET) != 0
      || bfd_bread (area, size, abfd) != size)
    return (NULL);
  return (area);
}

/*
SUBSUBSECTION
	Reading linenumbers

	Creating the linenumber table is done by reading in the entire
	coff linenumber table, and creating another table for internal use.

	A coff linenumber table is structured so that each function
	is marked as having a line number of 0. Each line within the
	function is an offset from the first line in the function. The
	base of the line number information for the table is stored in
	the symbol associated with the function.

	Note: The PE format uses line number 0 for a flag indicating a
	new source file.

	The information is copied from the external to the internal
	table, and each symbol which marks a function is marked by
	pointing its...

	How does this work ?
*/

static int
coff_sort_func_alent (const void * arg1, const void * arg2)
{
  const alent *al1 = *(const alent **) arg1;
  const alent *al2 = *(const alent **) arg2;
  const coff_symbol_type *s1 = (const coff_symbol_type *) (al1->u.sym);
  const coff_symbol_type *s2 = (const coff_symbol_type *) (al2->u.sym);

  if (s1->symbol.value < s2->symbol.value)
    return -1;
  else if (s1->symbol.value > s2->symbol.value)
    return 1;

  return 0;
}

static bfd_boolean
coff_slurp_line_table (bfd *abfd, asection *asect)
{
  LINENO *native_lineno;
  alent *lineno_cache;
  bfd_size_type amt;
  unsigned int counter;
  alent *cache_ptr;
  bfd_vma prev_offset = 0;
  int ordered = 1;
  unsigned int nbr_func;
  LINENO *src;

  BFD_ASSERT (asect->lineno == NULL);

  amt = ((bfd_size_type) asect->lineno_count + 1) * sizeof (alent);
  lineno_cache = (alent *) bfd_alloc (abfd, amt);
  if (lineno_cache == NULL)
    return FALSE;

  amt = (bfd_size_type) bfd_coff_linesz (abfd) * asect->lineno_count;
  native_lineno = (LINENO *) buy_and_read (abfd, asect->line_filepos, amt);
  if (native_lineno == NULL)
    {
      (*_bfd_error_handler)
	(_("%B: warning: line number table read failed"), abfd);
      bfd_release (abfd, lineno_cache);
      return FALSE;
    }

  cache_ptr = lineno_cache;
  asect->lineno = lineno_cache;
  src = native_lineno;
  nbr_func = 0;

  for (counter = 0; counter < asect->lineno_count; counter++)
    {
      struct internal_lineno dst;

      bfd_coff_swap_lineno_in (abfd, src, &dst);
      cache_ptr->line_number = dst.l_lnno;

      if (cache_ptr->line_number == 0)
	{
	  bfd_boolean warned;
	  bfd_signed_vma symndx;
	  coff_symbol_type *sym;

	  nbr_func++;
	  warned = FALSE;
	  symndx = dst.l_addr.l_symndx;
	  if (symndx < 0
	      || (bfd_vma) symndx >= obj_raw_syment_count (abfd))
	    {
	      (*_bfd_error_handler)
		(_("%B: warning: illegal symbol index %ld in line numbers"),
		 abfd, (long) symndx);
	      symndx = 0;
	      warned = TRUE;
	    }

	  /* FIXME: We should not be casting between ints and
	     pointers like this.  */
	  sym = ((coff_symbol_type *)
		 ((symndx + obj_raw_syments (abfd))
		  ->u.syment._n._n_n._n_zeroes));
	  cache_ptr->u.sym = (asymbol *) sym;
	  if (sym->lineno != NULL && ! warned)
	    (*_bfd_error_handler)
	      (_("%B: warning: duplicate line number information for `%s'"),
	       abfd, bfd_asymbol_name (&sym->symbol));

	  sym->lineno = cache_ptr;
	  if (sym->symbol.value < prev_offset)
	    ordered = 0;
	  prev_offset = sym->symbol.value;
	}
      else
	cache_ptr->u.offset = dst.l_addr.l_paddr
	  - bfd_section_vma (abfd, asect);

      cache_ptr++;
      src++;
    }
  cache_ptr->line_number = 0;
  bfd_release (abfd, native_lineno);

  /* On some systems (eg AIX5.3) the lineno table may not be sorted.  */
  if (!ordered)
    {
      /* Sort the table.  */
      alent **func_table;
      alent *n_lineno_cache;

      /* Create a table of functions.  */
      func_table = (alent **) bfd_alloc (abfd, nbr_func * sizeof (alent *));
      if (func_table != NULL)
	{
	  alent **p = func_table;
	  unsigned int i;

	  for (i = 0; i < counter; i++)
	    if (lineno_cache[i].line_number == 0)
	      *p++ = &lineno_cache[i];

	  /* Sort by functions.  */
	  qsort (func_table, nbr_func, sizeof (alent *), coff_sort_func_alent);

	  /* Create the new sorted table.  */
	  amt = ((bfd_size_type) asect->lineno_count + 1) * sizeof (alent);
	  n_lineno_cache = (alent *) bfd_alloc (abfd, amt);
	  if (n_lineno_cache != NULL)
	    {
	      alent *n_cache_ptr = n_lineno_cache;

	      for (i = 0; i < nbr_func; i++)
		{
		  coff_symbol_type *sym;
		  alent *old_ptr = func_table[i];

		  /* Copy the function entry and update it.  */
		  *n_cache_ptr = *old_ptr;
		  sym = (coff_symbol_type *)n_cache_ptr->u.sym;
		  sym->lineno = n_cache_ptr;
		  n_cache_ptr++;
		  old_ptr++;

		  /* Copy the line number entries.  */
		  while (old_ptr->line_number != 0)
		    *n_cache_ptr++ = *old_ptr++;
		}
	      n_cache_ptr->line_number = 0;
	      memcpy (lineno_cache, n_lineno_cache, amt);
	    }
	  bfd_release (abfd, func_table);
	}
    }

  return TRUE;
}

/* Slurp in the symbol table, converting it to generic form.  Note
   that if coff_relocate_section is defined, the linker will read
   symbols via coff_link_add_symbols, rather than via this routine.  */

static bfd_boolean
coff_slurp_symbol_table (bfd * abfd)
{
  combined_entry_type *native_symbols;
  coff_symbol_type *cached_area;
  unsigned int *table_ptr;
  bfd_size_type amt;
  unsigned int number_of_symbols = 0;

  if (obj_symbols (abfd))
    return TRUE;

  /* Read in the symbol table.  */
  if ((native_symbols = coff_get_normalized_symtab (abfd)) == NULL)
    return FALSE;

  /* Allocate enough room for all the symbols in cached form.  */
  amt = obj_raw_syment_count (abfd);
  amt *= sizeof (coff_symbol_type);
  cached_area = (coff_symbol_type *) bfd_alloc (abfd, amt);
  if (cached_area == NULL)
    return FALSE;

  amt = obj_raw_syment_count (abfd);
  amt *= sizeof (unsigned int);
  table_ptr = (unsigned int *) bfd_alloc (abfd, amt);

  if (table_ptr == NULL)
    return FALSE;
  else
    {
      coff_symbol_type *dst = cached_area;
      unsigned int last_native_index = obj_raw_syment_count (abfd);
      unsigned int this_index = 0;

      while (this_index < last_native_index)
	{
	  combined_entry_type *src = native_symbols + this_index;
	  table_ptr[this_index] = number_of_symbols;
	  dst->symbol.the_bfd = abfd;

	  dst->symbol.name = (char *) (src->u.syment._n._n_n._n_offset);
	  /* We use the native name field to point to the cached field.  */
	  src->u.syment._n._n_n._n_zeroes = (bfd_hostptr_t) dst;
	  dst->symbol.section = coff_section_from_bfd_index (abfd,
						     src->u.syment.n_scnum);
	  dst->symbol.flags = 0;
	  dst->done_lineno = FALSE;

	  switch (src->u.syment.n_sclass)
	    {
#ifdef I960
	    case C_LEAFEXT:
	      /* Fall through to next case.  */
#endif

	    case C_EXT:
	    case C_WEAKEXT:
#if defined ARM
	    case C_THUMBEXT:
	    case C_THUMBEXTFUNC:
#endif
#ifdef RS6000COFF_C
	    case C_HIDEXT:
#endif
#ifdef C_SYSTEM
	    case C_SYSTEM:	/* System Wide variable.  */
#endif
#ifdef COFF_WITH_PE
	    /* In PE, 0x68 (104) denotes a section symbol.  */
	    case C_SECTION:
	    /* In PE, 0x69 (105) denotes a weak external symbol.  */
	    case C_NT_WEAK:
#endif
	      switch (coff_classify_symbol (abfd, &src->u.syment))
		{
		case COFF_SYMBOL_GLOBAL:
		  dst->symbol.flags = BSF_EXPORT | BSF_GLOBAL;
#if defined COFF_WITH_PE
		  /* PE sets the symbol to a value relative to the
		     start of the section.  */
		  dst->symbol.value = src->u.syment.n_value;
#else
		  dst->symbol.value = (src->u.syment.n_value
				       - dst->symbol.section->vma);
#endif
		  if (ISFCN ((src->u.syment.n_type)))
		    /* A function ext does not go at the end of a
		       file.  */
		    dst->symbol.flags |= BSF_NOT_AT_END | BSF_FUNCTION;
		  break;

		case COFF_SYMBOL_COMMON:
		  dst->symbol.section = bfd_com_section_ptr;
		  dst->symbol.value = src->u.syment.n_value;
		  break;

		case COFF_SYMBOL_UNDEFINED:
		  dst->symbol.section = bfd_und_section_ptr;
		  dst->symbol.value = 0;
		  break;

		case COFF_SYMBOL_PE_SECTION:
		  dst->symbol.flags |= BSF_EXPORT | BSF_SECTION_SYM;
		  dst->symbol.value = 0;
		  break;

		case COFF_SYMBOL_LOCAL:
		  dst->symbol.flags = BSF_LOCAL;
#if defined COFF_WITH_PE
		  /* PE sets the symbol to a value relative to the
		     start of the section.  */
		  dst->symbol.value = src->u.syment.n_value;
#else
		  dst->symbol.value = (src->u.syment.n_value
				       - dst->symbol.section->vma);
#endif
		  if (ISFCN ((src->u.syment.n_type)))
		    dst->symbol.flags |= BSF_NOT_AT_END | BSF_FUNCTION;
		  break;
		}

#ifdef RS6000COFF_C
	      /* A symbol with a csect entry should not go at the end.  */
	      if (src->u.syment.n_numaux > 0)
		dst->symbol.flags |= BSF_NOT_AT_END;
#endif

#ifdef COFF_WITH_PE
	      if (src->u.syment.n_sclass == C_NT_WEAK)
		dst->symbol.flags |= BSF_WEAK;

	      if (src->u.syment.n_sclass == C_SECTION
		  && src->u.syment.n_scnum > 0)
		dst->symbol.flags = BSF_LOCAL;
#endif
	      if (src->u.syment.n_sclass == C_WEAKEXT)
		dst->symbol.flags |= BSF_WEAK;

	      break;

	    case C_STAT:	 /* Static.  */
#ifdef I960
	    case C_LEAFSTAT:	 /* Static leaf procedure.  */
#endif
#if defined ARM
	    case C_THUMBSTAT:    /* Thumb static.  */
	    case C_THUMBLABEL:   /* Thumb label.  */
	    case C_THUMBSTATFUNC:/* Thumb static function.  */
#endif
#ifdef RS6000COFF_C
            case C_DWARF:	 /* A label in a dwarf section.  */
            case C_INFO:	 /* A label in a comment section.  */
#endif
	    case C_LABEL:	 /* Label.  */
	      if (src->u.syment.n_scnum == N_DEBUG)
		dst->symbol.flags = BSF_DEBUGGING;
	      else
		dst->symbol.flags = BSF_LOCAL;

	      /* Base the value as an index from the base of the
		 section, if there is one.  */
	      if (dst->symbol.section)
		{
#if defined COFF_WITH_PE
		  /* PE sets the symbol to a value relative to the
		     start of the section.  */
		  dst->symbol.value = src->u.syment.n_value;
#else
		  dst->symbol.value = (src->u.syment.n_value
				       - dst->symbol.section->vma);
#endif
		}
	      else
		dst->symbol.value = src->u.syment.n_value;
	      break;

	    case C_MOS:		/* Member of structure.  */
	    case C_EOS:		/* End of structure.  */
	    case C_REGPARM:	/* Register parameter.  */
	    case C_REG:		/* register variable.  */
	      /* C_AUTOARG conflicts with TI COFF C_UEXT.  */
#if !defined (TIC80COFF) && !defined (TICOFF)
#ifdef C_AUTOARG
	    case C_AUTOARG:	/* 960-specific storage class.  */
#endif
#endif
	    case C_TPDEF:	/* Type definition.  */
	    case C_ARG:
	    case C_AUTO:	/* Automatic variable.  */
	    case C_FIELD:	/* Bit field.  */
	    case C_ENTAG:	/* Enumeration tag.  */
	    case C_MOE:		/* Member of enumeration.  */
	    case C_MOU:		/* Member of union.  */
	    case C_UNTAG:	/* Union tag.  */
	      dst->symbol.flags = BSF_DEBUGGING;
	      dst->symbol.value = (src->u.syment.n_value);
	      break;

	    case C_FILE:	/* File name.  */
	    case C_STRTAG:	/* Structure tag.  */
#ifdef RS6000COFF_C
	    case C_GSYM:
	    case C_LSYM:
	    case C_PSYM:
	    case C_RSYM:
	    case C_RPSYM:
	    case C_STSYM:
	    case C_TCSYM:
	    case C_BCOMM:
	    case C_ECOML:
	    case C_ECOMM:
	    case C_DECL:
	    case C_ENTRY:
	    case C_FUN:
	    case C_ESTAT:
#endif
	      dst->symbol.flags = BSF_DEBUGGING;
	      dst->symbol.value = (src->u.syment.n_value);
	      break;

#ifdef RS6000COFF_C
	    case C_BINCL:	/* Beginning of include file.  */
	    case C_EINCL:	/* Ending of include file.  */
	      /* The value is actually a pointer into the line numbers
		 of the file.  We locate the line number entry, and
		 set the section to the section which contains it, and
		 the value to the index in that section.  */
	      {
		asection *sec;

		dst->symbol.flags = BSF_DEBUGGING;
		for (sec = abfd->sections; sec != NULL; sec = sec->next)
		  if (sec->line_filepos <= (file_ptr) src->u.syment.n_value
		      && ((file_ptr) (sec->line_filepos
				      + sec->lineno_count * bfd_coff_linesz (abfd))
			  > (file_ptr) src->u.syment.n_value))
		    break;
		if (sec == NULL)
		  dst->symbol.value = 0;
		else
		  {
		    dst->symbol.section = sec;
		    dst->symbol.value = ((src->u.syment.n_value
					  - sec->line_filepos)
					 / bfd_coff_linesz (abfd));
		    src->fix_line = 1;
		  }
	      }
	      break;

	    case C_BSTAT:
	      dst->symbol.flags = BSF_DEBUGGING;

	      /* The value is actually a symbol index.  Save a pointer
		 to the symbol instead of the index.  FIXME: This
		 should use a union.  */
	      src->u.syment.n_value =
		(long) (intptr_t) (native_symbols + src->u.syment.n_value);
	      dst->symbol.value = src->u.syment.n_value;
	      src->fix_value = 1;
	      break;
#endif

	    case C_BLOCK:	/* ".bb" or ".eb".  */
	    case C_FCN:		/* ".bf" or ".ef" (or PE ".lf").  */
	    case C_EFCN:	/* Physical end of function.  */
#if defined COFF_WITH_PE
	      /* PE sets the symbol to a value relative to the start
		 of the section.  */
	      dst->symbol.value = src->u.syment.n_value;
	      if (strcmp (dst->symbol.name, ".bf") != 0)
		{
		  /* PE uses funny values for .ef and .lf; don't
		     relocate them.  */
		  dst->symbol.flags = BSF_DEBUGGING;
		}
	      else
		dst->symbol.flags = BSF_DEBUGGING | BSF_DEBUGGING_RELOC;
#else
	      /* Base the value as an index from the base of the
		 section.  */
	      dst->symbol.flags = BSF_LOCAL;
	      dst->symbol.value = (src->u.syment.n_value
				   - dst->symbol.section->vma);
#endif
	      break;

	    case C_STATLAB:	/* Static load time label.  */
	      dst->symbol.value = src->u.syment.n_value;
	      dst->symbol.flags = BSF_GLOBAL;
	      break;

	    case C_NULL:
	      /* PE DLLs sometimes have zeroed out symbols for some
		 reason.  Just ignore them without a warning.  */
	      if (src->u.syment.n_type == 0
		  && src->u.syment.n_value == 0
		  && src->u.syment.n_scnum == 0)
		break;
#ifdef RS6000COFF_C
              /* XCOFF specific: deleted entry.  */
              if (src->u.syment.n_value == C_NULL_VALUE)
                break;
#endif
	      /* Fall through.  */
	    case C_EXTDEF:	/* External definition.  */
	    case C_ULABEL:	/* Undefined label.  */
	    case C_USTATIC:	/* Undefined static.  */
#ifndef COFF_WITH_PE
	    /* C_LINE in regular coff is 0x68.  NT has taken over this storage
	       class to represent a section symbol.  */
	    case C_LINE:	/* line # reformatted as symbol table entry.  */
	      /* NT uses 0x67 for a weak symbol, not C_ALIAS.  */
	    case C_ALIAS:	/* Duplicate tag.  */
#endif
	      /* New storage classes for TI COFF.  */
#if defined(TIC80COFF) || defined(TICOFF)
	    case C_UEXT:	/* Tentative external definition.  */
#endif
	    case C_EXTLAB:	/* External load time label.  */
	    case C_HIDDEN:	/* Ext symbol in dmert public lib.  */
	    default:
	      (*_bfd_error_handler)
		(_("%B: Unrecognized storage class %d for %s symbol `%s'"),
		 abfd, src->u.syment.n_sclass,
		 dst->symbol.section->name, dst->symbol.name);
	      dst->symbol.flags = BSF_DEBUGGING;
	      dst->symbol.value = (src->u.syment.n_value);
	      break;
	    }

	  dst->native = src;

	  dst->symbol.udata.i = 0;
	  dst->lineno = NULL;
	  this_index += (src->u.syment.n_numaux) + 1;
	  dst++;
	  number_of_symbols++;
	}
    }

  obj_symbols (abfd) = cached_area;
  obj_raw_syments (abfd) = native_symbols;

  bfd_get_symcount (abfd) = number_of_symbols;
  obj_convert (abfd) = table_ptr;
  /* Slurp the line tables for each section too.  */
  {
    asection *p;

    p = abfd->sections;
    while (p)
      {
	coff_slurp_line_table (abfd, p);
	p = p->next;
      }
  }

  return TRUE;
}

/* Classify a COFF symbol.  A couple of targets have globally visible
   symbols which are not class C_EXT, and this handles those.  It also
   recognizes some special PE cases.  */

static enum coff_symbol_classification
coff_classify_symbol (bfd *abfd,
		      struct internal_syment *syment)
{
  /* FIXME: This partially duplicates the switch in
     coff_slurp_symbol_table.  */
  switch (syment->n_sclass)
    {
    case C_EXT:
    case C_WEAKEXT:
#ifdef I960
    case C_LEAFEXT:
#endif
#ifdef ARM
    case C_THUMBEXT:
    case C_THUMBEXTFUNC:
#endif
#ifdef C_SYSTEM
    case C_SYSTEM:
#endif
#ifdef COFF_WITH_PE
    case C_NT_WEAK:
#endif
      if (syment->n_scnum == 0)
	{
	  if (syment->n_value == 0)
	    return COFF_SYMBOL_UNDEFINED;
	  else
	    return COFF_SYMBOL_COMMON;
	}
      return COFF_SYMBOL_GLOBAL;

    default:
      break;
    }

#ifdef COFF_WITH_PE
  if (syment->n_sclass == C_STAT)
    {
      if (syment->n_scnum == 0)
	/* The Microsoft compiler sometimes generates these if a
	   small static function is inlined every time it is used.
	   The function is discarded, but the symbol table entry
	   remains.  */
	return COFF_SYMBOL_LOCAL;

#ifdef STRICT_PE_FORMAT
      /* This is correct for Microsoft generated objects, but it
	 breaks gas generated objects.  */
      if (syment->n_value == 0)
	{
	  asection *sec;
	  char buf[SYMNMLEN + 1];

	  sec = coff_section_from_bfd_index (abfd, syment->n_scnum);
	  if (sec != NULL
	      && (strcmp (bfd_get_section_name (abfd, sec),
			  _bfd_coff_internal_syment_name (abfd, syment, buf))
		  == 0))
	    return COFF_SYMBOL_PE_SECTION;
	}
#endif

      return COFF_SYMBOL_LOCAL;
    }

  if (syment->n_sclass == C_SECTION)
    {
      /* In some cases in a DLL generated by the Microsoft linker, the
	 n_value field will contain garbage.  FIXME: This should
	 probably be handled by the swapping function instead.  */
      syment->n_value = 0;
      if (syment->n_scnum == 0)
	return COFF_SYMBOL_UNDEFINED;
      return COFF_SYMBOL_PE_SECTION;
    }
#endif /* COFF_WITH_PE */

  /* If it is not a global symbol, we presume it is a local symbol.  */
  if (syment->n_scnum == 0)
    {
      char buf[SYMNMLEN + 1];

      (*_bfd_error_handler)
	(_("warning: %B: local symbol `%s' has no section"),
	 abfd, _bfd_coff_internal_syment_name (abfd, syment, buf));
    }

  return COFF_SYMBOL_LOCAL;
}

/*
SUBSUBSECTION
	Reading relocations

	Coff relocations are easily transformed into the internal BFD form
	(@@code{arelent}).

	Reading a coff relocation table is done in the following stages:

	o Read the entire coff relocation table into memory.

	o Process each relocation in turn; first swap it from the
	external to the internal form.

	o Turn the symbol referenced in the relocation's symbol index
	into a pointer into the canonical symbol table.
	This table is the same as the one returned by a call to
	@@code{bfd_canonicalize_symtab}. The back end will call that
	routine and save the result if a canonicalization hasn't been done.

	o The reloc index is turned into a pointer to a howto
	structure, in a back end specific way. For instance, the 386
	and 960 use the @@code{r_type} to directly produce an index
	into a howto table vector; the 88k subtracts a number from the
	@@code{r_type} field and creates an addend field.
*/

#ifndef CALC_ADDEND
#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)		\
  {								\
    coff_symbol_type *coffsym = NULL;				\
								\
    if (ptr && bfd_asymbol_bfd (ptr) != abfd)			\
      coffsym = (obj_symbols (abfd)				\
		 + (cache_ptr->sym_ptr_ptr - symbols));		\
    else if (ptr)						\
      coffsym = coff_symbol_from (abfd, ptr);			\
    if (coffsym != NULL						\
	&& coffsym->native->u.syment.n_scnum == 0)		\
      cache_ptr->addend = 0;					\
    else if (ptr && bfd_asymbol_bfd (ptr) == abfd		\
	     && ptr->section != NULL)				\
      cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
    else							\
      cache_ptr->addend = 0;					\
  }
#endif

static bfd_boolean
coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)
{
  RELOC *native_relocs;
  arelent *reloc_cache;
  arelent *cache_ptr;
  unsigned int idx;
  bfd_size_type amt;

  if (asect->relocation)
    return TRUE;
  if (asect->reloc_count == 0)
    return TRUE;
  if (asect->flags & SEC_CONSTRUCTOR)
    return TRUE;
  if (!coff_slurp_symbol_table (abfd))
    return FALSE;

  amt = (bfd_size_type) bfd_coff_relsz (abfd) * asect->reloc_count;
  native_relocs = (RELOC *) buy_and_read (abfd, asect->rel_filepos, amt);
  amt = (bfd_size_type) asect->reloc_count * sizeof (arelent);
  reloc_cache = (arelent *) bfd_alloc (abfd, amt);

  if (reloc_cache == NULL || native_relocs == NULL)
    return FALSE;

  for (idx = 0; idx < asect->reloc_count; idx++)
    {
      struct internal_reloc dst;
      struct external_reloc *src;
#ifndef RELOC_PROCESSING
      asymbol *ptr;
#endif

      cache_ptr = reloc_cache + idx;
      src = native_relocs + idx;

      dst.r_offset = 0;
      coff_swap_reloc_in (abfd, src, &dst);

#ifdef RELOC_PROCESSING
      RELOC_PROCESSING (cache_ptr, &dst, symbols, abfd, asect);
#else
      cache_ptr->address = dst.r_vaddr;

      if (dst.r_symndx != -1)
	{
	  if (dst.r_symndx < 0 || dst.r_symndx >= obj_conv_table_size (abfd))
	    {
	      (*_bfd_error_handler)
		(_("%B: warning: illegal symbol index %ld in relocs"),
		 abfd, (long) dst.r_symndx);
	      cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	      ptr = NULL;
	    }
	  else
	    {
	      cache_ptr->sym_ptr_ptr = (symbols
					+ obj_convert (abfd)[dst.r_symndx]);
	      ptr = *(cache_ptr->sym_ptr_ptr);
	    }
	}
      else
	{
	  cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	  ptr = NULL;
	}

      /* The symbols definitions that we have read in have been
	 relocated as if their sections started at 0. But the offsets
	 refering to the symbols in the raw data have not been
	 modified, so we have to have a negative addend to compensate.

	 Note that symbols which used to be common must be left alone.  */

      /* Calculate any reloc addend by looking at the symbol.  */
      CALC_ADDEND (abfd, ptr, dst, cache_ptr);
      (void) ptr;

      cache_ptr->address -= asect->vma;
      /* !! cache_ptr->section = NULL;*/

      /* Fill in the cache_ptr->howto field from dst.r_type.  */
      RTYPE2HOWTO (cache_ptr, &dst);
#endif	/* RELOC_PROCESSING */

      if (cache_ptr->howto == NULL)
	{
	  (*_bfd_error_handler)
	    (_("%B: illegal relocation type %d at address 0x%lx"),
	     abfd, dst.r_type, (long) dst.r_vaddr);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
    }

  asect->relocation = reloc_cache;
  return TRUE;
}

#ifndef coff_rtype_to_howto
#ifdef RTYPE2HOWTO

/* Get the howto structure for a reloc.  This is only used if the file
   including this one defines coff_relocate_section to be
   _bfd_coff_generic_relocate_section, so it is OK if it does not
   always work.  It is the responsibility of the including file to
   make sure it is reasonable if it is needed.  */

static reloc_howto_type *
coff_rtype_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
		     asection *sec ATTRIBUTE_UNUSED,
		     struct internal_reloc *rel,
		     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED,
		     struct internal_syment *sym ATTRIBUTE_UNUSED,
		     bfd_vma *addendp ATTRIBUTE_UNUSED)
{
  arelent genrel;

  genrel.howto = NULL;
  RTYPE2HOWTO (&genrel, rel);
  return genrel.howto;
}

#else /* ! defined (RTYPE2HOWTO) */

#define coff_rtype_to_howto NULL

#endif /* ! defined (RTYPE2HOWTO) */
#endif /* ! defined (coff_rtype_to_howto) */

/* This is stupid.  This function should be a boolean predicate.  */

static long
coff_canonicalize_reloc (bfd * abfd,
			 sec_ptr section,
			 arelent ** relptr,
			 asymbol ** symbols)
{
  arelent *tblptr = section->relocation;
  unsigned int count = 0;

  if (section->flags & SEC_CONSTRUCTOR)
    {
      /* This section has relocs made up by us, they are not in the
	 file, so take them out of their chain and place them into
	 the data area provided.  */
      arelent_chain *chain = section->constructor_chain;

      for (count = 0; count < section->reloc_count; count++)
	{
	  *relptr++ = &chain->relent;
	  chain = chain->next;
	}
    }
  else
    {
      if (! coff_slurp_reloc_table (abfd, section, symbols))
	return -1;

      tblptr = section->relocation;

      for (; count++ < section->reloc_count;)
	*relptr++ = tblptr++;
    }
  *relptr = 0;
  return section->reloc_count;
}

#ifndef coff_reloc16_estimate
#define coff_reloc16_estimate dummy_reloc16_estimate

static int
dummy_reloc16_estimate (bfd *abfd ATTRIBUTE_UNUSED,
			asection *input_section ATTRIBUTE_UNUSED,
			arelent *reloc ATTRIBUTE_UNUSED,
			unsigned int shrink ATTRIBUTE_UNUSED,
			struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
{
  abort ();
  return 0;
}

#endif

#ifndef coff_reloc16_extra_cases

#define coff_reloc16_extra_cases dummy_reloc16_extra_cases

/* This works even if abort is not declared in any header file.  */

static void
dummy_reloc16_extra_cases (bfd *abfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
			   struct bfd_link_order *link_order ATTRIBUTE_UNUSED,
			   arelent *reloc ATTRIBUTE_UNUSED,
			   bfd_byte *data ATTRIBUTE_UNUSED,
			   unsigned int *src_ptr ATTRIBUTE_UNUSED,
			   unsigned int *dst_ptr ATTRIBUTE_UNUSED)
{
  abort ();
}
#endif

#ifndef coff_bfd_link_hash_table_free
#define coff_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#endif

/* If coff_relocate_section is defined, we can use the optimized COFF
   backend linker.  Otherwise we must continue to use the old linker.  */

#ifdef coff_relocate_section

#ifndef coff_bfd_link_hash_table_create
#define coff_bfd_link_hash_table_create _bfd_coff_link_hash_table_create
#endif
#ifndef coff_bfd_link_add_symbols
#define coff_bfd_link_add_symbols _bfd_coff_link_add_symbols
#endif
#ifndef coff_bfd_final_link
#define coff_bfd_final_link _bfd_coff_final_link
#endif

#else /* ! defined (coff_relocate_section) */

#define coff_relocate_section NULL
#ifndef coff_bfd_link_hash_table_create
#define coff_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#endif
#ifndef coff_bfd_link_add_symbols
#define coff_bfd_link_add_symbols _bfd_generic_link_add_symbols
#endif
#define coff_bfd_final_link _bfd_generic_final_link

#endif /* ! defined (coff_relocate_section) */

#define coff_bfd_link_just_syms      _bfd_generic_link_just_syms
#define coff_bfd_copy_link_hash_symbol_type \
  _bfd_generic_copy_link_hash_symbol_type
#define coff_bfd_link_split_section  _bfd_generic_link_split_section

#ifndef coff_start_final_link
#define coff_start_final_link NULL
#endif

#ifndef coff_adjust_symndx
#define coff_adjust_symndx NULL
#endif

#ifndef coff_link_add_one_symbol
#define coff_link_add_one_symbol _bfd_generic_link_add_one_symbol
#endif

#ifndef coff_link_output_has_begun

static bfd_boolean
coff_link_output_has_begun (bfd * abfd,
			    struct coff_final_link_info * info ATTRIBUTE_UNUSED)
{
  return abfd->output_has_begun;
}
#endif

#ifndef coff_final_link_postscript

static bfd_boolean
coff_final_link_postscript (bfd * abfd ATTRIBUTE_UNUSED,
			    struct coff_final_link_info * pfinfo ATTRIBUTE_UNUSED)
{
  return TRUE;
}
#endif

#ifndef coff_SWAP_aux_in
#define coff_SWAP_aux_in coff_swap_aux_in
#endif
#ifndef coff_SWAP_sym_in
#define coff_SWAP_sym_in coff_swap_sym_in
#endif
#ifndef coff_SWAP_lineno_in
#define coff_SWAP_lineno_in coff_swap_lineno_in
#endif
#ifndef coff_SWAP_aux_out
#define coff_SWAP_aux_out coff_swap_aux_out
#endif
#ifndef coff_SWAP_sym_out
#define coff_SWAP_sym_out coff_swap_sym_out
#endif
#ifndef coff_SWAP_lineno_out
#define coff_SWAP_lineno_out coff_swap_lineno_out
#endif
#ifndef coff_SWAP_reloc_out
#define coff_SWAP_reloc_out coff_swap_reloc_out
#endif
#ifndef coff_SWAP_filehdr_out
#define coff_SWAP_filehdr_out coff_swap_filehdr_out
#endif
#ifndef coff_SWAP_aouthdr_out
#define coff_SWAP_aouthdr_out coff_swap_aouthdr_out
#endif
#ifndef coff_SWAP_scnhdr_out
#define coff_SWAP_scnhdr_out coff_swap_scnhdr_out
#endif
#ifndef coff_SWAP_reloc_in
#define coff_SWAP_reloc_in coff_swap_reloc_in
#endif
#ifndef coff_SWAP_filehdr_in
#define coff_SWAP_filehdr_in coff_swap_filehdr_in
#endif
#ifndef coff_SWAP_aouthdr_in
#define coff_SWAP_aouthdr_in coff_swap_aouthdr_in
#endif
#ifndef coff_SWAP_scnhdr_in
#define coff_SWAP_scnhdr_in coff_swap_scnhdr_in
#endif

static bfd_coff_backend_data bfd_coff_std_swap_table ATTRIBUTE_UNUSED =
{
  coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
  coff_SWAP_aux_out, coff_SWAP_sym_out,
  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
  coff_SWAP_filehdr_out, coff_SWAP_aouthdr_out,
  coff_SWAP_scnhdr_out,
  FILHSZ, AOUTSZ, SCNHSZ, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,
#ifdef COFF_LONG_FILENAMES
  TRUE,
#else
  FALSE,
#endif
  COFF_DEFAULT_LONG_SECTION_NAMES,
  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
  4,
#else
  2,
#endif
  coff_SWAP_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
  coff_SWAP_reloc_in, coff_bad_format_hook, coff_set_arch_mach_hook,
  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
  coff_classify_symbol, coff_compute_section_file_positions,
  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
  coff_adjust_symndx, coff_link_add_one_symbol,
  coff_link_output_has_begun, coff_final_link_postscript,
  bfd_pe_print_pdata
};

#ifdef TICOFF
/* COFF0 differs in file/section header size and relocation entry size.  */

static bfd_coff_backend_data ticoff0_swap_table =
{
  coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
  coff_SWAP_aux_out, coff_SWAP_sym_out,
  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
  coff_SWAP_filehdr_out, coff_SWAP_aouthdr_out,
  coff_SWAP_scnhdr_out,
  FILHSZ_V0, AOUTSZ, SCNHSZ_V01, SYMESZ, AUXESZ, RELSZ_V0, LINESZ, FILNMLEN,
#ifdef COFF_LONG_FILENAMES
  TRUE,
#else
  FALSE,
#endif
  COFF_DEFAULT_LONG_SECTION_NAMES,
  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
  4,
#else
  2,
#endif
  coff_SWAP_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
  coff_SWAP_reloc_in, ticoff0_bad_format_hook, coff_set_arch_mach_hook,
  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
  coff_classify_symbol, coff_compute_section_file_positions,
  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
  coff_adjust_symndx, coff_link_add_one_symbol,
  coff_link_output_has_begun, coff_final_link_postscript,
  bfd_pe_print_pdata
};
#endif

#ifdef TICOFF
/* COFF1 differs in section header size.  */

static bfd_coff_backend_data ticoff1_swap_table =
{
  coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
  coff_SWAP_aux_out, coff_SWAP_sym_out,
  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
  coff_SWAP_filehdr_out, coff_SWAP_aouthdr_out,
  coff_SWAP_scnhdr_out,
  FILHSZ, AOUTSZ, SCNHSZ_V01, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,
#ifdef COFF_LONG_FILENAMES
  TRUE,
#else
  FALSE,
#endif
  COFF_DEFAULT_LONG_SECTION_NAMES,
  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
  4,
#else
  2,
#endif
  coff_SWAP_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
  coff_SWAP_reloc_in, ticoff1_bad_format_hook, coff_set_arch_mach_hook,
  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
  coff_classify_symbol, coff_compute_section_file_positions,
  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
  coff_adjust_symndx, coff_link_add_one_symbol,
  coff_link_output_has_begun, coff_final_link_postscript,
  bfd_pe_print_pdata	/* huh */
};
#endif

#ifndef coff_close_and_cleanup
#define coff_close_and_cleanup		    _bfd_generic_close_and_cleanup
#endif

#ifndef coff_bfd_free_cached_info
#define coff_bfd_free_cached_info	    _bfd_generic_bfd_free_cached_info
#endif

#ifndef coff_get_section_contents
#define coff_get_section_contents	    _bfd_generic_get_section_contents
#endif

#ifndef coff_bfd_copy_private_symbol_data
#define coff_bfd_copy_private_symbol_data   _bfd_generic_bfd_copy_private_symbol_data
#endif

#ifndef coff_bfd_copy_private_header_data
#define coff_bfd_copy_private_header_data   _bfd_generic_bfd_copy_private_header_data
#endif

#ifndef coff_bfd_copy_private_section_data
#define coff_bfd_copy_private_section_data  _bfd_generic_bfd_copy_private_section_data
#endif

#ifndef coff_bfd_copy_private_bfd_data
#define coff_bfd_copy_private_bfd_data      _bfd_generic_bfd_copy_private_bfd_data
#endif

#ifndef coff_bfd_merge_private_bfd_data
#define coff_bfd_merge_private_bfd_data     _bfd_generic_bfd_merge_private_bfd_data
#endif

#ifndef coff_bfd_set_private_flags
#define coff_bfd_set_private_flags	    _bfd_generic_bfd_set_private_flags
#endif

#ifndef coff_bfd_print_private_bfd_data
#define coff_bfd_print_private_bfd_data     _bfd_generic_bfd_print_private_bfd_data
#endif

#ifndef coff_bfd_is_local_label_name
#define coff_bfd_is_local_label_name	    _bfd_coff_is_local_label_name
#endif

#ifndef coff_bfd_is_target_special_symbol
#define coff_bfd_is_target_special_symbol   ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
#endif

#ifndef coff_read_minisymbols
#define coff_read_minisymbols		    _bfd_generic_read_minisymbols
#endif

#ifndef coff_minisymbol_to_symbol
#define coff_minisymbol_to_symbol	    _bfd_generic_minisymbol_to_symbol
#endif

/* The reloc lookup routine must be supplied by each individual COFF
   backend.  */
#ifndef coff_bfd_reloc_type_lookup
#define coff_bfd_reloc_type_lookup	    _bfd_norelocs_bfd_reloc_type_lookup
#endif
#ifndef coff_bfd_reloc_name_lookup
#define coff_bfd_reloc_name_lookup    _bfd_norelocs_bfd_reloc_name_lookup
#endif

#ifndef coff_bfd_get_relocated_section_contents
#define coff_bfd_get_relocated_section_contents \
  bfd_generic_get_relocated_section_contents
#endif

#ifndef coff_bfd_relax_section
#define coff_bfd_relax_section		    bfd_generic_relax_section
#endif

#ifndef coff_bfd_gc_sections
#define coff_bfd_gc_sections		    bfd_generic_gc_sections
#endif

#ifndef coff_bfd_lookup_section_flags
#define coff_bfd_lookup_section_flags	    bfd_generic_lookup_section_flags
#endif

#ifndef coff_bfd_merge_sections
#define coff_bfd_merge_sections		    bfd_generic_merge_sections
#endif

#ifndef coff_bfd_is_group_section
#define coff_bfd_is_group_section	    bfd_generic_is_group_section
#endif

#ifndef coff_bfd_discard_group
#define coff_bfd_discard_group		    bfd_generic_discard_group
#endif

#ifndef coff_section_already_linked
#define coff_section_already_linked \
  _bfd_coff_section_already_linked
#endif

#ifndef coff_bfd_define_common_symbol
#define coff_bfd_define_common_symbol	    bfd_generic_define_common_symbol
#endif

#define CREATE_BIG_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
const bfd_target VAR =							\
{									\
  NAME ,								\
  bfd_target_coff_flavour,						\
  BFD_ENDIAN_BIG,		/* Data byte order is big.  */		\
  BFD_ENDIAN_BIG,		/* Header byte order is big.  */	\
  /* object flags */							\
  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |			\
   HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),			\
  /* section flags */							\
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),\
  UNDER,			/* Leading symbol underscore.  */	\
  '/',				/* AR_pad_char.  */			\
  15,				/* AR_max_namelen.  */			\
  0,				/* match priority.  */			\
									\
  /* Data conversion functions.  */					\
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
									\
  /* Header conversion functions.  */					\
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
									\
	/* bfd_check_format.  */					\
  { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p,		\
    _bfd_dummy_target },						\
	/* bfd_set_format.  */						\
  { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },	\
	/* bfd_write_contents.  */					\
  { bfd_false, coff_write_object_contents, _bfd_write_archive_contents,	\
    bfd_false },							\
									\
  BFD_JUMP_TABLE_GENERIC (coff),					\
  BFD_JUMP_TABLE_COPY (coff),						\
  BFD_JUMP_TABLE_CORE (_bfd_nocore),					\
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),				\
  BFD_JUMP_TABLE_SYMBOLS (coff),					\
  BFD_JUMP_TABLE_RELOCS (coff),						\
  BFD_JUMP_TABLE_WRITE (coff),						\
  BFD_JUMP_TABLE_LINK (coff),						\
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),				\
									\
  ALTERNATIVE,								\
									\
  SWAP_TABLE								\
};

#define CREATE_BIGHDR_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
const bfd_target VAR =							\
{									\
  NAME ,								\
  bfd_target_coff_flavour,						\
  BFD_ENDIAN_LITTLE,		/* Data byte order is little.  */	\
  BFD_ENDIAN_BIG,		/* Header byte order is big.  */	\
  /* object flags */							\
  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |			\
   HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),			\
  /* section flags */							\
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),\
  UNDER,			/* Leading symbol underscore.  */	\
  '/',				/* AR_pad_char.  */			\
  15,				/* AR_max_namelen.  */			\
  0,				/* match priority.  */			\
									\
  /* Data conversion functions.  */					\
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
									\
  /* Header conversion functions.  */					\
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
									\
	/* bfd_check_format.  */					\
  { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p,		\
    _bfd_dummy_target },						\
	/* bfd_set_format.  */						\
  { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },	\
	/* bfd_write_contents.  */					\
  { bfd_false, coff_write_object_contents, _bfd_write_archive_contents,	\
    bfd_false },							\
									\
  BFD_JUMP_TABLE_GENERIC (coff),					\
  BFD_JUMP_TABLE_COPY (coff),						\
  BFD_JUMP_TABLE_CORE (_bfd_nocore),					\
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),				\
  BFD_JUMP_TABLE_SYMBOLS (coff),					\
  BFD_JUMP_TABLE_RELOCS (coff),						\
  BFD_JUMP_TABLE_WRITE (coff),						\
  BFD_JUMP_TABLE_LINK (coff),						\
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),				\
									\
  ALTERNATIVE,								\
									\
  SWAP_TABLE								\
};

#define CREATE_LITTLE_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
const bfd_target VAR =							\
{									\
  NAME ,								\
  bfd_target_coff_flavour,						\
  BFD_ENDIAN_LITTLE,		/* Data byte order is little.  */	\
  BFD_ENDIAN_LITTLE,		/* Header byte order is little.  */	\
	/* object flags */						\
  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |			\
   HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),			\
	/* section flags */						\
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),\
  UNDER,			/* Leading symbol underscore.  */	\
  '/',				/* AR_pad_char.  */			\
  15,				/* AR_max_namelen.  */			\
  0,				/* match priority.  */			\
									\
  /* Data conversion functions.  */					\
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,				\
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,				\
  bfd_getl16, bfd_getl_signed_16, bfd_putl16,				\
  /* Header conversion functions.  */					\
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,				\
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,				\
  bfd_getl16, bfd_getl_signed_16, bfd_putl16,				\
	/* bfd_check_format.  */					\
  { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p,		\
    _bfd_dummy_target },						\
       /* bfd_set_format.  */						\
  { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },	\
	/* bfd_write_contents.  */					\
  { bfd_false, coff_write_object_contents, _bfd_write_archive_contents,	\
    bfd_false },							\
									\
  BFD_JUMP_TABLE_GENERIC (coff),					\
  BFD_JUMP_TABLE_COPY (coff),						\
  BFD_JUMP_TABLE_CORE (_bfd_nocore),					\
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),				\
  BFD_JUMP_TABLE_SYMBOLS (coff),					\
  BFD_JUMP_TABLE_RELOCS (coff),						\
  BFD_JUMP_TABLE_WRITE (coff),						\
  BFD_JUMP_TABLE_LINK (coff),						\
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),				\
									\
  ALTERNATIVE,								\
									\
  SWAP_TABLE								\
};
@


1.187
log
@2013-07-05  Tristan Gingold  <gingold@@adacore.com>

        * coffcode.h (coff_write_object_contents): Use ".ovrflo" name for
        overflow sections.
@
text
@d3366 2
d3369 18
a3386 8
	  /* AIX loader checks the text section alignment of (vma - filepos)
	     So even though the filepos may be aligned wrt the o_algntext, for
	     AIX executables, this check fails. This shows up when a native
	     AIX executable is stripped with gnu strip because the default vma
	     of native is 0x10000150 but default for gnu is 0x10000140.  Gnu
	     stripped gnu excutable passes this check because the filepos is
	     0x0140.  This problem also show up with 64 bit shared objects. The
	     data section must also be aligned.  */
d3390 8
a3397 18
	      bfd_vma pad;
	      bfd_vma align;

	      sofar = BFD_ALIGN (sofar, 1 << current->alignment_power);

	      align = 1 << current->alignment_power;
	      pad = abs (current->vma - sofar) % align;

	      if (pad)
		{
		  pad = align - pad;
		  sofar += pad;
		}
	    }
	  else
#else
	    {
	      sofar = BFD_ALIGN (sofar, 1 << current->alignment_power);
@


1.186
log
@XCOFF/AIX: Remove SEC_ALLOC flags for unmapped sections.

The .except, .loader and .typchk are not mapped to memory,
so do not set their SEC_ALLOC flag.

bfd/ChangeLog:

        * coffcode.h (styp_to_sec_flags) [RS6000COFF_C]: Add handling
        of STYP_EXCEPT, STYP_LOADER and STYP_TYPCHK sections.

ld/testsuite/ChangeLog:

        * ld-powerpc/aix-core-sec-1.hd, ld-powerpc/aix-core-sec-2.hd,
        ld-powerpc/aix-core-sec-3.hd: Adjust expected section flags
        for section .loader.
@
text
@d3956 1
a3956 1
	  strncpy (&(scnhdr.s_name[0]), current->name, 8);
@


1.185
log
@	* coffcode.h: Added a cast to void when a bfd_set_section_*()
	macro's return value is ignored.
	* elf32-hppa.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* mach-o.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* peicode.h: Likewise.
	* elf32-m32r.c: Check return value of bfd_set_section_*().
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* vms-alpha.c: Likewise.
@
text
@d798 6
@


1.184
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d2 1
a2 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
d3448 1
a3448 1
	bfd_set_section_vma (abfd, current, 0);
@


1.183
log
@ChangeLog bfd

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* coff-i386.c (bfd_target): Add section flag SEC_EXCLUDE.
	Allow BFD_COMPRESS and BFD_DECOMPRESS flags.
	* coff-x86_64.c: Likewise.
	* coffcode.h (DOT_ZDEBUG): New define.
	(sec_to_styp_flags): Check for .zdebug.
	(styp_to_sec_flags): Likewise.
	* coffgen.c (make_a_section): Handle .debug_* section
	compression/decompression flags.
	* cofflink.c (mark_relocs): Ignore relocations
	for a section, which isn't marked as used.
	(_bfd_coff_link_input_bfd): Add support of compressed
	debug sections.
	* compress.c (decompress_contents): Loop as long
	as there is input available and there is room for
	output.
	* bfd/pe-arm.c: Add .zdebug_ partial match entry.
	* pe-i386.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Don't clear all
	data-directories as this might destroy content.

        * coff-i386.c (_bfd_generic_find_nearest_line_discriminator):
        define as coff_find_nearest_line_discriminator.
        * libcoff-in.h (coff_find_nearest_line_discriminator): New
        * libcoff.h: Regenerated.
        * coff-x86_64.c: Likewise.
        * coffgen.c (coff_find_nearest_line_discriminator): New function.
        prototype.

ChangeLog binutils

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	* objdump.c (dump_bfd): Call dump headers after
	call of slurp_symtab.

ChangeLog ld

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* NEWS: Menition new feature.
	* scripttempl/pep.sc: Add zdebug sections.
	* scripttempl/pe.sc: L
@
text
@d122 1
a122 1
	extension is defined in section 4 of the Microsoft PE/COFF 
d126 1
a126 1
	filled with a slash ("/") followed by the ASCII decimal 
d143 1
a143 1
	The functionality is supported in BFD by code implemented under 
d146 2
a147 2
	If defined, it is used to initialise a flag, 
	@@code{_bfd_coff_long_section_names}, and a hook function pointer, 
d156 1
a156 1
	
d710 1
a710 1
  
d1388 1
a1388 1
.  
@


1.182
log
@	* coffcode.h (sec_to_styp_flags): Handle
	SEC_LINK_DUPLICATES_SAME_CONTENTS, and
	SEC_LINK_DUPLICATES_SAME_SIZE.
@
text
@d375 1
d549 2
a550 1
  else if (CONST_STRNEQ (sec_name, DOT_DEBUG))
d657 1
d827 1
d1165 1
@


1.181
log
@	PR ld/12762
bfd/
	* bfd-in.h (struct bfd_section_already_linked): Forward declare.
	(_bfd_handle_already_linked): Declare.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Define as
	_bfd_coff_section_already_linked.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* cofflink.c (coff_link_add_symbols): Revert 2011-07-09 changes.
	* elf-bfd.h: Likewise.
	* libbfd-in.h: Likewise.
	* targets.c: Likewise.
	* linker.c (bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(_bfd_generic_section_already_linked): Likewise.  Call
	_bfd_handle_already_linked.
	(_bfd_handle_already_linked): New function, split out from..
	* elflink.c (_bfd_elf_section_already_linked): ..here.  Revert
	2011-07-09 changes.  Avoid unnecessary strcmp when matching
	already_linked_list entries.  Match plugin linkonce section.
	(section_signature): Delete.
	* coffgen.c (_bfd_coff_section_already_linked): New function.
	* libcoff-in.h (_bfd_coff_section_already_linked): Declare.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (section_already_linked): Revert 2011-07-09 changes.
	* plugin.c: Likewise.
	(asymbol_from_plugin_symbol): Create linkonce section for syms
	with comdat_key.
@
text
@d673 3
a675 1
      sec_flags &= (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD);
d703 5
a707 1
  /* skip LINK_DUPLICATES */
@


1.180
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d5673 1
a5673 1
  _bfd_generic_section_already_linked
@


1.179
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d5655 4
@


1.178
log
@bfd
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* libxcoff.h (struct xcoff_dwsect_name): New type.
	(XCOFF_DWSECT_NBR_NAMES): New macro.
	(xcoff_dwsect_names): Declare.
	* coffcode.h (sec_to_styp_flags): Handle xcoff dwarf sections.
	(styp_to_sec_flags): Ditto.
	(coff_new_section_hook): Ditto.
	(coff_slurp_symbol_table): Handle C_DWARF and C_INFO.
	* coff-rs6000.c (xcoff_dwsect_name): New variable.

gas
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ppc.h (ppc_tc_sy): Reorder fields.
	Put size into an union with dw.
	(OBJ_COPY_SYMBOL_ATTRIBUTES): Adjust.
	(ppc_xcoff_end): Declare.
	(md_end): Define.
	* config/tc-ppc.c: Add includes for xcoff.
	(ppc_dwsect): New function.
	(md_pseudo_table): Add dwsect.
	(struct dw_subsection): New.
	(dw_sections): New.
	(ppc_change_debug_section): New function.
	(ppc_xcoff_end): Ditto.
	(ppc_function): Adjust for ppc_tc_sy.
	(ppc_symbol_new_hook): Ditto.
	(ppc_frob_symbol): Ditto.
	(ppc_frob_section): Do not set vma for debug sections.
	(ppc_fix_adjustable): Return true for debug sections.
	* config/obj-coff.c: Add includes for xcoff.
	(coff_frob_section): Handle dwarf section.

gas/testsuite
2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* gas/ppc/xcoff-dwsect-1-32.d: New test.
	* gas/ppc/xcoff-dwsect-1-64.d: Ditto.
	* gas/ppc/xcoff-dwsect-1.s: New file.
	* gas/ppc/aix.exp (do_align_test): Add tests.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d5691 1
d5742 1
d5793 1
@


1.177
log
@	* dw2gencfi.c (dwcfi_seg_list): New struct.
	(dwcfi_hash): New static hash variable.
	(get_debugseg_name): New.
	(alloc_debugseg_item): New.
	(make_debug_seg): New.
	(dwcfi_hash_insert): New.
	(dwcfi_hash_find): New.
	(dwcfi_hash_find_or_make): New.
	(cfi_insn_data): New member cur_seg.
	(cie_entry): Likewise.
	(fde_entry): New cseg and handled members.
	(alloc_fde_entry): Initialize cseg member.
	(alloc_cfi_insn_data): Initialize cur_seg member.
	(dot_cfi_sections): Compare for beginning of
	section names via strncmp.
	(get_cfi_seg): New.
	(cfi_finish): Treat link-once sections.
	(is_now_linkonce_segment): New local helper.
	(output_cie): Ignore cie entries not member of current
	segment.
	(output_fde): Likewise.
	(select_cie_for_fde): Likewise.
	(cfi_change_reg_numbers): Add new argument for current segment
	and ignore insn elements, if not part of current segment.
	* ehopt.c (get_cie_info): Use strncmp for
	section name matching.
	(heck_eh_frame): Likewise.

	* coffcode.h (sec_to_styp_flags): Allow linkonce for
	debugging sections.

	* scripttempl/pe.sc: Handle .eh_frame($|.)* sections.
	* scripttempl/pep.sc: Likewise.

	* ld-pe/pe.exp: Add cfi/cfi32 tests.
	* ld-pe/cfi.d: New.
	* ld-pe/cfi32.d: New.
	* ld-pe/cfia.s: New.
	* ld-pe/cfib.s: New.
@
text
@d584 11
d790 4
d1735 1
d1743 1
a1743 1
  if (bfd_xcoff_data_align_power (abfd) != 0
d1746 13
d1782 1
a1782 1
  native->u.syment.n_sclass = C_STAT;
d4787 4
@


1.176
log
@2011-04-09  Kai Tietz  <ktietz@@redhat.com>

        * peXXigen.c (_bfd_XXi_final_link_postscripte): Sort pdata in temporary
        buffer and use rawsize for sorting.
        * coffcode.h (coff_compute_section_file_positions): Set rawsize
        before doing alignment.
@
text
@d661 4
a664 1
      sec_flags = SEC_DEBUGGING | SEC_READONLY;
@


1.175
log
@include/coff
2011-03-31  Tristan Gingold  <gingold@@adacore.com>

	* internal.h (C_NULL_VALUE): Define.

bfd/
2011-03-31  Tristan Gingold  <gingold@@adacore.com>

	* coffcode.h (coff_slurp_symbol_table): Silently discard C_NULL
	entry on xcoff when value is C_NULL_VALUE.
@
text
@d3300 2
d3368 1
a3368 1
      current->size = (current->size + page_size -1) & -page_size;
@


1.174
log
@oops - fix typo
@
text
@d4899 5
@


1.173
log
@	* coffcode.h (coff_set_alignment_hook): Check return of bfd_seek.
@
text
@d1859 1
a1859 1
      struct internal_reloc an;
@


1.172
log
@	Fix compilation for mingw64.
	* coffcode.h (coff_slurp_symbol_table): Add intptr_t intermediate
	typecast to avoid warning.
	* elf32-rx.c: Add "bfd_stdint.h" include required for int32_t type
	usage.
	* elfxx-ia64.c (elfNN_ia64_relax_br): Use intptr_t typeacast instead
	of long for pointer to avoid warning.
	(elfNN_ia64_relax_brl): Idem.
	(elfNN_ia64_install_value): Idem.
	* vms-alpha.c (_bfd_vms_slurp_etir): Idem.
@
text
@d1859 1
a1859 1
      struct internal_reloc n;
d1863 2
a1864 1
      bfd_seek (abfd, (file_ptr) hdr->s_relptr, 0);
d1869 2
a1870 1
      bfd_seek (abfd, oldpos, 0);
@


1.171
log
@bfd/
2010-11-04  Kai Tietz  <kai.tietz@@onevision.com>

        * coffcode.h (GNU_LINKONCE_WT): New.
        (sec_to_styp_flags): Add handling of new debug
        section.
        (styp_to_sec_flags): Likewise.

ld/
010-11-04  Kai Tietz  <kai.tietz@@onevision.com>

       * scripttempl/pe.sc (.debug_types): New.
       * scripttempl/pep.sc: Likewise.
@
text
@d4855 1
a4855 1
		(long) (native_symbols + src->u.syment.n_value);
@


1.171.2.1
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@a3297 2
      current->rawsize = current->size;

d3364 1
a3364 1
      current->size = (current->size + page_size - 1) & -page_size;
d4855 1
a4855 1
		(long) (intptr_t) (native_symbols + src->u.syment.n_value);
@


1.170
log
@        PR bintils/6962
        * coffcode.h (handle_COMDAT): Only check the base type when
        looking for a section symbol.
@
text
@d376 1
d561 2
a562 1
  else if (CONST_STRNEQ (sec_name, GNU_LINKONCE_WI))
d646 1
d805 1
d1139 1
@


1.169
log
@2010-09-22  Kai Tietz  <kai.tietz@@onevision.com>

        * coffcode.h (sec_to_styp_flags): Adjust debug
        sections to be conform to pe-coff specification
        and avoid marking them as excluded.
        (styp_to_sec_flags): Doing reverse mapping.
@
text
@d959 1
a959 1
		       && isym.n_type == T_NULL
@


1.168
log
@2010-09-01  Tristan Gingold  <gingold@@adacore.com>

	* coffcode.h (coff_slurp_line_table): Add a cast.
	(coff_slurp_reloc_table): Ditto.
@
text
@d639 8
d657 2
a658 3
  if (CONST_STRNEQ (sec_name, DOT_DEBUG)
      || CONST_STRNEQ (sec_name, GNU_LINKONCE_WI))
    sec_flags = SEC_DEBUGGING | SEC_READONLY;
d665 1
a665 1
  if ((sec_flags & SEC_DATA) != 0)
d676 1
a676 1
  if ((sec_flags & SEC_EXCLUDE) != 0)
d678 1
a678 1
  if ((sec_flags & SEC_NEVER_LOAD) != 0)
d1130 1
d1132 6
d1207 1
a1207 1
	     if (CONST_STRNEQ (name, DOT_DEBUG)
d1211 4
a1214 5
#ifdef COFF_LONG_SECTION_NAMES
  	      || CONST_STRNEQ (name, GNU_LINKONCE_WI)
#endif
	      || CONST_STRNEQ (name, ".stab"))
	    sec_flags |= SEC_DEBUGGING;
d1220 2
a1221 1
	  sec_flags |= SEC_EXCLUDE;
d1227 4
a1230 1
	  sec_flags |= SEC_DATA | SEC_ALLOC | SEC_LOAD;
@


1.167
log
@remove maxq-coff port
@
text
@d4490 1
a4490 1
		 abfd, dst.l_addr.l_symndx);
d5126 1
a5126 1
		 abfd, dst.r_symndx);
@


1.166
log
@fix set but unused variable warnings
@
text
@a2096 16
#ifdef MAXQ20MAGIC
    case MAXQ20MAGIC:
      arch = bfd_arch_maxq;
      switch (internal_f->f_flags & F_MACHMASK)
	{
	case F_MAXQ10:
	  machine = bfd_mach_maxq10;
	  break;
	case F_MAXQ20:
	  machine = bfd_mach_maxq20;
	  break;
	default:
	  return FALSE;
	}
      break;
#endif
a3004 11
#ifdef MAXQ20MAGIC
    case bfd_arch_maxq:
      * magicp = MAXQ20MAGIC;
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_maxq10: * flagsp = F_MAXQ10; return TRUE;
	case bfd_mach_maxq20: * flagsp = F_MAXQ20; return TRUE;
	default:	      return FALSE;
	}
#endif

a4086 5
#ifdef MAXQ20MAGIC
#define __A_MAGIC_SET__
      internal_a.magic = MAXQ20MAGIC;
#endif

@


1.165
log
@	* coffcode.h (coff_write_object_contents): Enclose all occurrences
	of hasdebug and is_reloc_section in #ifdef COFF_IMAGE_WITH_PE.
@
text
@a3092 1
  asection *previous = NULL;
d3097 1
d3411 1
d3413 1
d5184 1
@


1.164
log
@2010-04-27  Kai Tietz  <kai.tietz@@onevision.com>

	* pe-x86_64.c (TARGET_UNDERSCORE): Set value dependent
	to USE_MINGW64_LEADING_UNDERSCORES.
        * pei-x86_64.c (TARGET_UNDERSCORE): Likewise.
	* config.bfd: Change underscoring default for x64 mingw
	to false.
	* coffcode.h (coff_write_relocs): Add check that dereferenced
	sym_ptr_ptr isn't NULL.
	* config.in (USE_MINGW64_LEADING_UNDERSCORES): New.
	* configure: Regenerated.
	* configure.in: Add option '--enable-leading-mingw64-underscores'
	and define config.in variable USE_MINGW64_LEADING_UNDERSCORES.
@
text
@d3536 1
d3538 1
d3641 1
a3643 1
#ifdef COFF_IMAGE_WITH_PE
d3742 1
d3746 1
@


1.163
log
@	PR 11168
	* coffcode.h (coff_compute_section_file_positions): Move Rs6000COFF_C
	block past vars in COFF_IMAGE_WITH_PE block.  Report error on more
	than 32k sections.
@
text
@d2651 1
a2651 1
	  if (q->sym_ptr_ptr[0]->the_bfd != abfd)
d2680 1
a2680 1
	    if (q->sym_ptr_ptr)
@


1.162
log
@2009-11-23  Paul Brook  <paul@@codesourcery.com>

	ld/
	* ldexp.c: Copy symbol type for simple assignments.

	bfd/
	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
	prototype.
	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New function.
	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
	_copy_link_hash_symbol_type.
	* bfd/coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* bfd/coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	ld/testsuite
	* ld-arm/script-type.sym: New test.
	* ld-arm/script-type.s: New test.
	* ld-arm/script-type.s: New test.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d3096 1
d3101 20
a3159 20
#ifdef COFF_IMAGE_WITH_PE
  int page_size;

  if (coff_data (abfd)->link_info)
    {
      page_size = pe_data (abfd)->pe_opthdr.FileAlignment;

      /* If no file alignment has been set, default to one.
	 This repairs 'ld -r' for arm-wince-pe target.  */
      if (page_size == 0)
	page_size = 1;
    }
  else
    page_size = PE_DEF_FILE_ALIGNMENT;
#else
#ifdef COFF_PAGE_SIZE
  int page_size = COFF_PAGE_SIZE;
#endif
#endif

a3194 1
    int target_index;
a3256 2
    int target_index;

d3263 8
@


1.161
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d5331 2
@


1.160
log
@
	* coffcode.h: Include libiberty.h.
@
text
@d1074 1
a1074 1
		  = bfd_alloc (abfd, amt);
d1082 1
a1082 1
		newname = bfd_alloc (abfd, amt);
d1717 1
a1717 1
  native = bfd_zalloc (abfd, amt);
d3210 1
a3210 1
    section_list = bfd_malloc (amt);
d4281 1
a4281 1
    buff = bfd_malloc (amount);
d4301 1
a4301 1
      buff = bfd_malloc (amount);
d4470 1
a4470 1
  lineno_cache = bfd_alloc (abfd, amt);
d4549 1
a4549 1
      func_table = bfd_alloc (abfd, nbr_func * sizeof (alent *));
d4564 1
a4564 1
	  n_lineno_cache = bfd_alloc (abfd, amt);
d4618 1
a4618 1
  cached_area = bfd_alloc (abfd, amt);
d4624 1
a4624 1
  table_ptr = bfd_alloc (abfd, amt);
d5116 1
a5116 1
  reloc_cache = bfd_alloc (abfd, amt);
@


1.159
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d364 2
@


1.158
log
@bfd/
	Stop using bfd_usrdata in libbfd.
	* coff-stgo32.c (bfd_coff_go32stub): Remove.
	(stub_bytes, comment): Replace STUBSIZE by GO32_STUBSIZE.
	(adjust_filehdr_in_post): Declare the abfd parameter as unused.
	Replace STUBSIZE by GO32_STUBSIZE.  Save now the stub in
	filehdr_dst->u.go32.stub.  New comment with the reason.
	(adjust_filehdr_out_pre): Replace STUBSIZE by GO32_STUBSIZE.
	Substitute the removed macro bfd_coff_go32stub.
	(adjust_filehdr_out_post, adjust_scnhdr_in_post, adjust_scnhdr_out_pre)
	(adjust_scnhdr_out_post, adjust_aux_in_post, adjust_aux_out_pre)
	(adjust_aux_out_post): Replace STUBSIZE by GO32_STUBSIZE.
	(create_go32_stub, go32_stubbed_coff_bfd_copy_private_bfd_data):
	Replace STUBSIZE by GO32_STUBSIZE.  Substitute the removed macro
	bfd_coff_go32stub.
	* coffcode.h (coff_mkobject_hook): Initialize coff->go32stub.
	* libcoff-in.h (coff_data_type): New field go32stub.
	* libcoff.h: Regenerated.

include/coff/
	Stop using bfd_usrdata in libbfd.
	* go32exe.h (struct external_filehdr_go32_exe <stub>, FILHSZ): Replace
	STUBSIZE by GO32_STUBSIZE.
	(STUBSIZE): Move the definition ...
	* internal.h (GO32_STUBSIZE): ... here and rename it.
	(struct internal_filehdr <go32stub>, F_GO32STUB): New.
@
text
@d2446 1
a2446 1
  int class = symbol->u.syment.n_sclass;
d2448 1
a2448 1
  if (CSECT_SYM_P (class)
@


1.158.2.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d2446 1
a2446 1
  int n_sclass = symbol->u.syment.n_sclass;
d2448 1
a2448 1
  if (CSECT_SYM_P (n_sclass)
@


1.158.2.2
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d1072 1
a1072 1
		  = (struct coff_comdat_info *) bfd_alloc (abfd, amt);
d1080 1
a1080 1
		newname = (char *) bfd_alloc (abfd, amt);
d1715 1
a1715 1
  native = (combined_entry_type *) bfd_zalloc (abfd, amt);
d3208 1
a3208 1
    section_list = (asection **) bfd_malloc (amt);
d4279 1
a4279 1
    buff = (char *) bfd_malloc (amount);
d4299 1
a4299 1
      buff = (char *) bfd_malloc (amount);
d4468 1
a4468 1
  lineno_cache = (alent *) bfd_alloc (abfd, amt);
d4547 1
a4547 1
      func_table = (alent **) bfd_alloc (abfd, nbr_func * sizeof (alent *));
d4562 1
a4562 1
	  n_lineno_cache = (alent *) bfd_alloc (abfd, amt);
d4616 1
a4616 1
  cached_area = (coff_symbol_type *) bfd_alloc (abfd, amt);
d4622 1
a4622 1
  table_ptr = (unsigned int *) bfd_alloc (abfd, amt);
d5114 1
a5114 1
  reloc_cache = (arelent *) bfd_alloc (abfd, amt);
@


1.157
log
@2009-07-03  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* coffcode.h (sec_to_styp_flags):  Partially revert (functional
	changes only) earlier patch:-

  2009-06-25  Kai Tietz  <kai.tietz@@onevision.com>

	  * coffcode.h (sec_to_styp_flags): Set discardable for .reloc and
	  give .debug and .reloc data characteristics.
	  (DOT_RELOC): New define for .reloc section string.
	  (coff_write_object_contents): Use DOT_RELOC instead of string.
@
text
@d1995 5
@


1.156
log
@2009-06-25  Kai Tietz  <kai.tietz@@onevision.com>

        * coffcode.h (sec_to_styp_flags): Set discardable for .reloc and
        give .debug and .reloc data characteristics.
        (DOT_RELOC): New define for .reloc section string.
        (coff_write_object_contents): Use DOT_RELOC instead of string.
@
text
@d649 1
a649 6
    sec_flags = SEC_DATA | SEC_LOAD | SEC_ALLOC | SEC_DEBUGGING | SEC_READONLY;
  else if (CONST_STRNEQ (sec_name, DOT_RELOC))
    {
      sec_flags = SEC_DATA | SEC_LOAD | SEC_ALLOC | SEC_READONLY;
      styp_flags |= IMAGE_SCN_MEM_DISCARDABLE;
    }
@


1.155
log
@2009-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* coff-ia64.c (COFF_PAGE_SIZE): Changed to 8K.

	* coffcode.h (coff_compute_section_file_positions): Clear
	D_PAGED if PE section alignment is smaller than COFF_PAGE_SIZE.

	* libcoff-in.h (pe_tdata): Remove force_minimum_alignment and
	force_minimum_alignment.

	* libcoff.h: Regenerated.

	* pei-ia64.c (PEI_TARGET_SUBSYSTEM): Removed.
	(PEI_FORCE_MINIMUM_ALIGNMENT): Likewise.

	* peicode.h (pe_mkobject): Don't set force_minimum_alignment
	nor target_subsystem.

	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Don't check
	force_minimum_alignment nor target_subsystem.
@
text
@d374 1
d649 6
a654 1
    sec_flags = SEC_DEBUGGING | SEC_READONLY;
d3634 1
a3634 1
      if (strcmp (current->name, ".reloc") == 0)
@


1.154
log
@bfd/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10074
	* coffcode.h (bfd_pei_p): New.

	* config.bfd: Remove bfd_efi_bsdrv_ia32_vec,
	bfd_efi_rtdrv_ia32_vec, bfd_efi_bsdrv_x86_64_vec,
	bfd_efi_rtdrv_x86_64_vec, bfd_efi_bsdrv_ia64_vec and
	bfd_efi_rtdrv_ia64_vec.  Replace bfd_efi_app_ia32_vec,
	bfd_efi_app_x86_64_vec and bfd_efi_app_ia64_vec with
	i386pei_vec, x86_64pei_vec and bfd_pei_ia64_vec, respectively.

	* configure.in: Remove bfd_efi_bsdrv_ia32_vec,
	bfd_efi_rtdrv_ia32_vec, bfd_efi_bsdrv_x86_64_vec,
	bfd_efi_rtdrv_x86_64_vec,
	bfd_efi_bsdrv_ia64_vec and bfd_efi_rtdrv_ia64_vec.  Replace
	bfd_efi_ia64_vec with bfd_pei_ia64_vec.
	* targets.c: Likewise.

	* configure: Regenerated.
	* libcoff.h: Likewise.
	* Makefile.in: Likewise.

	* efi-app-ia32.c: Removed.
	* efi-app-x86_64.c: Likewise.
	* efi-bsdrv-ia32.c: Likewise.
	* efi-bsdrv-ia64.c: Likewise.
	* efi-bsdrv-x86_64.c: Likewise.
	* efi-rtdrv-ia32.c: Likewise.
	* efi-rtdrv-ia64.c: Likewise.
	* efi-rtdrv-x86_64.c: Likewise.
	* efi-rtdrv-ia32.c: Likewise.

	* efi-app-ia64.c: Moved to ...
	* pei-ia64.c: This.
	(TARGET_SYM): Set to bfd_pei_ia64_vec.
	(TARGET_NAME): Set to pei-ia64.

	* libpei.h (bfd_target_pei_p): Removed.
	(bfd_target_pei_arch): Likewise.
	(bfd_target_efi_app_p): Likewise.
	(bfd_target_efi_app_arch): Likewise.
	(bfd_target_efi_bsdrv_p): Likewise.
	(bfd_target_efi_bsdrv_arch): Likewise.
	(bfd_target_efi_rtdrv_p): Likewise.
	(bfd_target_efi_rtdrv_arch): Likewise.
	(bfd_pe_executable_p): Likewise.

	* Makefile.am (BFD32_BACKENDS): Remove efi-app-ia32.lo,
	efi-bsdrv-ia32.lo and efi-rtdrv-ia32.lo.
	(BFD32_BACKENDS_CFILES): Remove efi-app-ia32.c, efi-bsdrv-ia32.c
	and efi-rtdrv-ia32.c.
	(BFD64_BACKENDS): Remove efi-app-ia64.lo, efi-bsdrv-ia64.lo,
	efi-rtdrv-ia64.lo, efi-app-x86_64.lo, efi-bsdrv-x86_64.lo and
	efi-rtdrv-x86_64.lo. Add pei-ia64.lo.
	(BFD64_BACKENDS_CFILES): Remove efi-app-ia64.c, efi-bsdrv-ia64.c,
	efi-rtdrv-ia64.c, efi-app-x86_64.c, efi-bsdrv-x86_64.c and
	efi-rtdrv-x86_64.c. Add pei-ia64.c.
	(efi-app-ia64.lo): Removed.
	(efi-bsdrv-ia32.lo): Likewise.
	(efi-rtdrv-ia32.lo): Likewise.
	(efi-app-ia64.lo): Likewise.
	(efi-bsdrv-ia64.lo): Likewise.
	(efi-rtdrv-ia64.lo): Likewise.
	(efi-app-x86_64.lo): Likewise.
	(efi-bsdrv-x86_64.lo): Likewise.
	(efi-rtdrv-x86_64.lo): Likewise.
	(pei-ia64.lo): New.

	* peicode.h (coff_swap_scnhdr_in): Replace bfd_pe_executable_p
	with bfd_pei_p.
	(arch_type): Removed.
	(pe_arch): Likewise.
	(pe_bfd_object_p): Just return coff_object_p.

	* peXXigen.c (_bfd_XXi_swap_scnhdr_out): Replace
	bfd_pe_executable_p with bfd_pei_p.

binutils/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10074
	* objcopy.c: Include coff/i386.h and coff/pe.h.
	(pe_file_alignment): New.
	(pe_heap_commit): Likewise.
	(pe_heap_reserve): Likewise.
	(pe_image_base): Likewise.
	(pe_section_alignment): Likewise.
	(pe_stack_commit): Likewise.
	(pe_stack_reserve): Likewise.
	(pe_subsystem): Likewise.
	(pe_major_subsystem_version): Likewise.
	(pe_minor_subsystem_version): Likewise.
	(set_pe_subsystem): Likewise.
	(convert_efi_target): Likewise.
	(command_line_switch): Add OPTION_FILE_ALIGNMENT,
	OPTION_HEAP, OPTION_IMAGE_BASE, OPTION_SECTION_ALIGNMENT,
	OPTION_STACK and OPTION_SUBSYSTEM.
	(copy_options): Likewise.
	(copy_usage): Add --file-alignment, --heap, --image-base,
	--section-alignment, --stack and --subsystem.
	(copy_object): Set up PE parameters.
	(copy_main): Process Add OPTION_FILE_ALIGNMENT,
	OPTION_HEAP, OPTION_IMAGE_BASE, OPTION_SECTION_ALIGNMENT,
	OPTION_STACK and OPTION_SUBSYSTEM.   Convert EFI target to
	PEI target.

	* NEWS: Mention --file-alignment, --heap, --image-base,
	--section-alignment, --stack and --subsystem command line
	options for objcopy.

	* doc/binutils.texi: Document --file-alignment, --heap,
	--image-base, --section-alignment, --stack and --subsystem
	command line options for objcopy.
@
text
@d3189 7
@


1.153
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d1563 4
@


1.152
log
@Add new binutils target: moxie
@
text
@d5603 4
@


1.151
log
@bfd/ChangeLog

	* coffgen.c (make_a_section_from_file):  Set the backend long
	section names enable if long section names found on input.
	* coffcode.h:  Extend long section names documentation to match.

binutils/ChangeLog

	* objcopy.c (enum long_section_name_handling):  New enum type.
	(enum command_line_switch):  Add OPTION_LONG_SECTION_NAMES.
	(copy_options[]):  Add entry for --long-section-names option.
	(copy_usage):  Document it.
	(set_long_section_mode):  New subroutine.
	(copy_file):  Call it.
	(copy_main):  Accept OPTION_LONG_SECTION_NAMES and parse arg.
	* doc/binutils.texi:  Update objcopy documentation with details
	of new option.
@
text
@d947 2
a948 1
		if (! (isym.n_sclass == C_STAT
d958 1
a958 1
		if (strcmp (name, symname) != 0)
@


1.150
log
@2009-03-19  Kai Tietz  <kai.tietz@@onevision.com>

        * bfd-in2.h: Regenerated.
        * coffcode.h (sec_to_styp_flags): For pe-coff add SEC_READONLY
        for debugging sections and map memory read/write dependent on
        SEC_COFF_NOREAD.
        (styp_to_sec_flags): Set SEC_COFF_NOREAD for sections
        without memory read flags set.
        * section.c: Add SEC_COFF_NOREAD to section flags.
@
text
@d156 8
@


1.149
log
@include/coff/
	* internal.h (C_AIX_WEAKEXT): New macro.
	(C_WEAKEXT): Use the GNU definition in the generic part of the file,
	and conditionally reset it to C_AIX_WEAKEXT in the XCOFF part of
	the file.
	(CSECT_SYM_P): New macro.
	* xcoff.h (L_WEAK): Define.
	(EXTERN_SYM_P): New macro.

bfd/
	* coffcode.h (coff_pointerize_aux_hook): Update CSECT_SYM_P to
	check whether a symbol has csect information.
	(coff_print_aux): Likewise.
	* coff-rs6000.c (_bfd_xcoff_swap_aux_in): Handle auxillary csect
	information for C_AIX_WEAKEXT too.
	(_bfd_xcoff_swap_aux_out): Likewise.
	(xcoff_reloc_type_br): Handle defweak symbols too.
	* coff64-rs6000.c (_bfd_xcoff64_swap_aux_in): Handle auxillary csect
	information for C_AIX_WEAKEXT too.
	(_bfd_xcoff64_swap_aux_out): Likewise.
	(xcoff64_reloc_type_br): Handle defweak symbols too.
	* coffgen.c (coff_print_symbol): Handle auxillary function
	information for C_AIX_WEAKEXT too.
	* xcofflink.c (_bfd_xcoff_canonicalize_dynamic_symtab): Set BSF_WEAK
	instead of BSF_GLOBAL if the L_WEAK flag is set.
	(xcoff_dynamic_definition_p): New function.
	(xcoff_link_add_dynamic_symbols): Use it to decide whether ldsym
	defines h.  Don't change h if ldsym isn't the definition.  Otherwise,
	always take the symbol class from the ldsym.  Use weak bfd symbol
	types for weak ldsyms.
	(xcoff_link_add_symbols): Use CSECT_SYM_P and EXTERN_SYM_P.
	Fix the check for whether a definition is from a shared object.
	Allow redefinitions of weak symbols.
	(xcoff_link_check_ar_symbols): Use EXTERN_SYM_P.
	(xcoff_keep_symbol_p): Likewise.
	(bfd_xcoff_size_dynamic_sections): Use CSECT_SYM_P.
	(xcoff_link_input_bfd): Use CSECT_SYM_P and EXTERN_SYM_P.
	Add .loader entries for C_AIX_WEAKEXT as well as C_EXT symbols,
	but mark them as L_WEAK.
	(xcoff_write_global_symbol): Treat weak symbols as C_AIX_WEAKEXT
	instead of C_EXT if C_AIX_WEAKEXT == C_WEAKEXT.

gas/
	* config/tc-ppc.c (ppc_frob_symbol): Add csect information for
	C_AIX_WEAKEXT too.

ld/testsuite/
	* ld-powerpc/aix-glink-2a.s, ld-powerpc/aix-glink-2a.ex,
	ld-powerpc/aix-glink-2b.s, ld-powerpc/aix-glink-2c.s,
	ld-powerpc/aix-glink-2c.ex, ld-powerpc/aix-glink-2d.s,
	ld-powerpc/aix-glink-2-32.dd, ld-powerpc/aix-glink-2-64.dd,
	ld-powerpc/aix-weak-1a.s, ld-powerpc/aix-weak-1b.s,
	ld-powerpc/aix-weak-1-rel.hd, ld-powerpc/aix-weak-1-rel.nd,
	ld-powerpc/aix-weak-1-dso.hd, ld-powerpc/aix-weak-1-dso.nd,
	ld-powerpc/aix-weak-1-dso.dnd, ld-powerpc/aix-weak-1.ex,
	ld-powerpc/aix-weak-2a.s, ld-powerpc/aix-weak-2a.ex,
	ld-powerpc/aix-weak-2a.nd, ld-powerpc/aix-weak-2b.s,
	ld-powerpc/aix-weak-2b.nd, ld-powerpc/aix-weak-2c.s,
	ld-powerpc/aix-weak-2c.ex, ld-powerpc/aix-weak-2c.nd,
	ld-powerpc/aix-weak-2c.od, ld-powerpc/aix-weak-3a.s,
	ld-powerpc/aix-weak-3a.ex, ld-powerpc/aix-weak-3b.s,
	ld-powerpc/aix-weak-3b.ex, ld-powerpc/aix-weak-3-32.d,
	ld-powerpc/aix-weak-3-32.dd, ld-powerpc/aix-weak-3-64.d,
	ld-powerpc/aix-weak-3-64.dd: New tests.
	* ld-powerpc/aix52.exp: Run them.  Replace tmp/aix-* with
	tmp/aix64-* in 64-bit ld options.
@
text
@d640 1
a640 1
    sec_flags = SEC_DEBUGGING;
d669 8
a676 13
  if (sec_flags & (SEC_ALLOC | SEC_LOAD))
    {
      /* For now, the read/write bits are mapped onto SEC_READONLY, even
	 though the semantics don't quite match.  The bits from the input
	 are retained in pei_section_data(abfd, section)->pe_flags.  */
      styp_flags |= IMAGE_SCN_MEM_READ;       /* Always readable.  */
      if ((sec_flags & SEC_READONLY) == 0)
	styp_flags |= IMAGE_SCN_MEM_WRITE;    /* Invert READONLY for write.  */
      if (sec_flags & SEC_CODE)
	styp_flags |= IMAGE_SCN_MEM_EXECUTE;  /* CODE->EXECUTE.  */
      if (sec_flags & SEC_COFF_SHARED)
	styp_flags |= IMAGE_SCN_MEM_SHARED;   /* Shared remains meaningful.  */
    }
d1115 4
d1151 1
a1151 1
	  /* Ignored, assume it always to be true.  */
@


1.148
log
@	PR gas/7059
	* coffcode.h (coff_write_object_contents):  Don't let the string
	table offset overflow the s_name field when using long section names.
@
text
@d2419 1
a2419 1
/* Handle the csect auxent of a C_EXT or C_HIDEXT symbol.  */
d2430 1
a2430 1
  if ((class == C_EXT || class == C_HIDEXT)
d2488 1
a2488 2
  if ((symbol->u.syment.n_sclass == C_EXT
       || symbol->u.syment.n_sclass == C_HIDEXT)
@


1.147
log
@bfd/ChangeLog

	* coff-alpha.c (alpha_ecoff_backend_data):  Initialise fields which
	control long section name handling with ECOFF_NO_LONG_SECTION_NAMES.
	* coff-mips.c (mips_ecoff_backend_data):  Likewise.
	* coff-rs6000.c (bfd_xcoff_backend_data):  Initialise fields which
	control long section name handling with XCOFF_NO_LONG_SECTION_NAMES.
	(bfd_pmac_xcoff_backend_data):  Likewise.
	* coff64-rs6000.c (bfd_xcoff_backend_data):  Likewise.
	(bfd_xcoff_aix5_backend_data):  Likewise.
	(xcoff64_write_object_contents):  Delete unused long_section_names
	local variable.
	* coff-sh.c (bfd_coff_small_swap_table):  Initialise long section
	name members using COFF_DEFAULT_LONG_SECTION_NAMES and make entire
	struct non-const.
	* coffcode.h (documentation):  Update to describe long section names.
	(COFFLONGSECTIONCATHELPER):  New helper macro.
	(BLANKOR1TOODD):  Likewise.
	(COFF_ENABLE_LONG_SECTION_NAMES):  Likewise.
	(COFF_LONG_SECTION_NAMES_SETTER):  Likewise.
	(COFF_DEFAULT_LONG_SECTION_NAMES):  Likewise.
	(bfd_coff_set_long_section_names_allowed):  New function.
	(bfd_coff_set_long_section_names_disallowed):  Likewise.
	(struct bfd_coff_backend_data):  Add new backend hook function
	pointer _bfd_coff_set_long_section_names.
	(bfd_coff_set_long_section_names):  New backend hook.
	(coff_write_object_contents):  Only generate long section names if
	bfd_coff_long_section_names() indicates they are currently enabled.
	(bfd_coff_std_swap_table):  Make non-const, and initialise long
	section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff0_swap_table):  Likewise to both.
	(ticoff1_swap_table):  Again, likewise to both.
	* coffgen.c (make_a_section_from_file):  Allow long section names
	as inputs even if not currently allowed for outputs.
	* ecoff.c (_bfd_ecoff_no_long_sections):  New function.
	* efi-app-ia32.c (COFF_LONG_SECTION_NAMES):  Define to 0, not blank.
	* efi-app-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-app-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-arm.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-i386.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mcore.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mips.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-ppc.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-sh.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* libcoff-in.h:  Update copyright year to cause updated copyright
	year in generated libcoff.h, and fix typo.
	* libcoff.h:  Regenerated.
	* libecoff.h (ECOFF_NO_LONG_SECTION_NAMES):  New macro.
	(_bfd_ecoff_no_long_sections):  Add prototype.
	* libxcoff.h (XCOFF_NO_LONG_SECTION_NAMES):  New macro.
	* pe-mips.c (COFF_LONG_SECTION_NAMES):  Define empty if not already
	defined by an including .c file.
	* ticoff.h (ticoff0_swap_table):  Make non-const, and initialise
	long section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff1_swap_table):  Likewise to both.

ld/ChangeLog

	* ld.texinfo:  Update to mention long section name options.
	* NEWS:  Mention new behaviour and command-line options.
	* pe-dll.c (pe_use_coff_long_section_names):  New global variable.
	(pe_output_file_set_long_section_names):  New function.
	(pe_dll_build_sections):  Call it on output BFDs.
	(pe_exe_build_sections):  Likewise.
	(pe_dll_fill_sections):  Likewise.
	(pe_exe_fill_sections):  Likewise.
	* pe-dll.h (pe_use_coff_long_section_names):  Declare extern.
	(pe_output_file_set_long_section_names):  Add prototype.
	* pep-dll.c (pe_use_coff_long_section_names):  Define pep_ alias.
	(pe_output_file_set_long_section_names):  Likewise.
	* pep-dll.h (pep_use_coff_long_section_names):  Declare extern.
	(pep_output_file_set_long_section_names):  Add prototype.
	* pe.em (OPTION_ENABLE_LONG_SECTION_NAMES):  New getopt value macro.
	(OPTION_DISABLE_LONG_SECTION_NAMES):  Likewise.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pe_output_file_set_long_section_names.
	* pep.em (enum options):  Extend enum with new getopt option values.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pep_output_file_set_long_section_names.

ld/testsuite/ChangeLog

	* ld-pe/longsecn-1.d:  New test file.
	* ld-pe/longsecn-2.d:  Likewise.
	* ld-pe/longsecn-3.d:  Likewise.
	* ld-pe/longsecn-4.d:  Likewise.
	* ld-pe/longsecn-5.d:  Likewise.
	* ld-pe/longsecn.d:  Likewise.
	* ld-pe/longsecn.exp:  New test control script.
	* ld-pe/longsecn.s:  New test source file.
@
text
@d3632 23
a3654 2
	      memset (section.s_name, 0, SCNNMLEN);
	      sprintf (section.s_name, "/%lu", (unsigned long) string_size);
@


1.146
log
@2009-01-16  Kai Tietz  <kai.tietz@@onevision.com>

	* coffcode.h (styp_to_sec_flags): Correct interpretation of
	IMAGE_SCN_MEM_DISCARDABLE.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d112 54
d367 34
d463 17
d1322 1
d1324 3
d1463 2
d3625 3
a3627 2
      {
	size_t len;
d3629 9
a3637 9
	len = strlen (current->name);
	if (len > SCNNMLEN)
	  {
	    memset (section.s_name, 0, SCNNMLEN);
	    sprintf (section.s_name, "/%lu", (unsigned long) string_size);
	    string_size += len + 1;
	    long_section_names = TRUE;
	  }
      }
d5361 1
a5361 1
static const bfd_coff_backend_data bfd_coff_std_swap_table ATTRIBUTE_UNUSED =
d5374 1
a5374 5
#ifdef COFF_LONG_SECTION_NAMES
  TRUE,
#else
  FALSE,
#endif
d5401 1
a5401 1
static const bfd_coff_backend_data ticoff0_swap_table =
d5414 1
a5414 5
#ifdef COFF_LONG_SECTION_NAMES
  TRUE,
#else
  FALSE,
#endif
d5442 1
a5442 1
static const bfd_coff_backend_data ticoff1_swap_table =
d5455 1
a5455 5
#ifdef COFF_LONG_SECTION_NAMES
  TRUE,
#else
  FALSE,
#endif
@


1.145
log
@            * coffcode.h (coff_write_object_contents): Always initialise
            section.s_page.

            * ti.h (COFF_ADJUST_SCNHDR_OUT_PRE): Define.
@
text
@d1072 13
a1084 4
	  /* The MS PE spec sets the DISCARDABLE flag on .reloc sections
	     but we do not want them to be labelled as debug section, since
	     then strip would remove them.  */
	  if (! CONST_STRNEQ (name, ".reloc"))
@


1.144
log
@	* coffcode.h (coff_slurp_line_table): bfd_alloc lineno_cache first
	so that we don't inadvertently free it.  Use bfd_alloc for sort
	arrays, and memcpy sorted line table.
@
text
@d3531 2
@


1.143
log
@        * pe-arm-wince.c (pe_print_compressed_pdata): Define new function to
        print compressed pdata structure as described on MSDN. This only
        applies to a limited set of architectures (ARM, SH4).
        (slurp_symtab, my_symbol_for_address): Define static helper
        functions for pe_print_compressed_pdata.
        * coffcode.h (bfd_coff_backend_data): Add _bfd_coff_print_pdata field.
        (bfd_coff_have_print_pdata, bfd_coff_print_pdata): Define.
        * bfd/peXXigen.c (_bfd_XX_print_private_bfd_data_common): Add check on
        bfd_coff_backend_data, call the function if non-null.
        * pei-mcore.c: Add target dependent initialisation for
        bfd_coff_backend_data.
        * coff-sh.c: Likewise.
        * coff64-rs6000.c: Likewise.
        * coff-rs6000.c: Likewise.
        * libcoff-in.h: Likewise.
        * cf-i386lynx.c: Likewise.
        * coff-alpha.c: Likewise.
        * coff-apollo.c: Likewise.
        * coff-arm.c: Likewise.
        * coff-aux.c: Likewise.
        * coff-h8300.c: Likewise.
        * coff-h8500.c: Likewise.
        * coff-i386.c: Likewise.
        * coff-i860.c: Likewise.
        * coff-i960.c: Likewise.
        * coff-ia64.c: Likewise.
        * coff-m68k.c: Likewise.
        * coff-m88k.c: Likewise.
        * coff-maxq.c: Likewise.
        * coff-mips.c: Likewise.
        * coff-or32.c: Likewise.
        * coff-sparc.c: Likewise.
        * coff-tic30.c: Likewise.
        * coff-tic4x.c: Likewise.
        * coff-tic54x.c: Likewise.
        * coff-tic80.c: Likewise.
        * coff-w65.c: Likewise.
        * coff-we32k.c: Likewise.
        * coff-x86_64.c: Likewise.
        * coff-z80.c: Likewise.
        * coff-z8k.c: Likewise.
        * pe-mcore.c: Likewise.
        * pe-mips.c: Likewise.
        * pe-ppc.c: Likewise.
        * peXXigen.c: Likewise.
        * pei-ppc.c: Likewise.
        * libcoff.h: Regenerate.
@
text
@d174 1
a174 1
	the file in the string 	table. This pass moves all strings
d435 1
a435 1
        styp_flags = STYP_XCOFF_DEBUG;
d437 1
a437 1
        styp_flags = STYP_DEBUG_INFO;
d1705 1
a1705 1
      
d1961 9
a1969 9
	{ 
        case F_MAXQ10:
          machine = bfd_mach_maxq10;
          break;
        case F_MAXQ20:
          machine = bfd_mach_maxq20;
          break;
        default:
          return FALSE;
d2234 1
a2234 1
        {
d2236 2
a2237 2
        case TI_TARGET_ID:
          arch = TICOFF_TARGET_ARCH;
d2239 1
a2239 1
          break;
d2241 7
a2247 7
        default:
          arch = bfd_arch_obscure;
          (*_bfd_error_handler)
            (_("Unrecognized TI COFF target id '0x%x'"),
             internal_f->f_target_id);
          break;
        }
d2321 1
a2321 1
         further work on this auxent.  */
d2544 1
a2544 1
                if (SECTION_RELATIVE_ABSOLUTE_SYMBOL_P (q, s))
d2651 1
a2651 1
	  default:	            return FALSE;
d2669 1
a2669 1
        *magicp = TICOFF_DEFAULT_MAGIC;
d2671 17
a2687 17
        {
          /* We may want to output in a different COFF version.  */
          switch (abfd->xvec->name[4])
            {
            case '0':
              *magicp = TICOFF0MAGIC;
              break;
            case '1':
              *magicp = TICOFF1MAGIC;
              break;
            case '2':
              *magicp = TICOFF2MAGIC;
              break;
            default:
              return FALSE;
            }
        }
d2876 1
a2876 1
        * magicp = OR32_MAGIC_BIG;
d2878 1
a2878 1
        * magicp = OR32_MAGIC_LITTLE;
d3010 1
a3010 1
        page_size = 1;
d3245 2
a3246 2
         size, in case the caller only writes out data to the
         unaligned size.  */
d3504 1
a3504 1
         with the code in coff_write_symbols and _bfd_coff_final_link.  */
d3622 2
a3623 2
         this section is supposed to have some COMDAT info, track down
         the symbol in the symbol table and modify it.  */
d3639 1
a3639 1
                 section.  */
d3694 6
a3699 6
                 section in the symbol table.  In order to make this
                 work, we move the COMDAT symbol before the first
                 symbol we found in the search above.  It's OK to
                 rearrange the symbol table at this point, because
                 coff_renumber_symbols is going to rearrange it
                 further and fix up all the aux entries.  */
d3936 1
a3936 1
 
d3968 1
a3968 1
         table even if there are no symbols.  */
d3980 1
a3980 1
         rounded up to the page size.  */
d3999 1
a3999 1
         local symbols but no relocations.  */
d4299 5
d4309 2
a4310 1
        (_("%B: warning: line number table read failed"), abfd);
a4313 5
  amt = ((bfd_size_type) asect->lineno_count + 1) * sizeof (alent);
  lineno_cache = bfd_alloc (abfd, amt);
  if (lineno_cache == NULL)
    return FALSE;

d4315 1
d4369 1
d4379 1
a4379 1
      func_table = bfd_malloc (nbr_func * sizeof (alent *));
d4393 1
d4416 1
a4416 2
	      bfd_release (abfd, lineno_cache);
	      lineno_cache = n_lineno_cache;
d4418 1
a4418 1
	  free (func_table);
a4421 2
  asect->lineno = lineno_cache;
  bfd_release (abfd, native_lineno);
d4488 2
a4489 2
            case C_THUMBEXT:
            case C_THUMBEXTFUNC:
d4498 2
a4499 2
            /* In PE, 0x68 (104) denotes a section symbol.  */
            case C_SECTION:
d4509 1
a4509 1
                     start of the section.  */
d4540 1
a4540 1
                     start of the section.  */
d4575 3
a4577 3
            case C_THUMBSTAT:    /* Thumb static.  */
            case C_THUMBLABEL:   /* Thumb label.  */
            case C_THUMBSTATFUNC:/* Thumb static function.  */
d4591 1
a4591 1
                     start of the section.  */
d4606 1
a4606 1
              /* C_AUTOARG conflicts with TI COFF C_UEXT.  */
d4650 3
a4652 3
                 of the file.  We locate the line number entry, and
                 set the section to the section which contains it, and
                 the value to the index in that section.  */
d4699 1
a4699 1
                     relocate them.  */
d4714 3
a4716 3
              dst->symbol.value = src->u.syment.n_value;
              dst->symbol.flags = BSF_GLOBAL;
              break;
d4720 1
a4720 1
                 reason.  Just ignore them without a warning.  */
d4730 2
a4731 2
            /* C_LINE in regular coff is 0x68.  NT has taken over this storage
               class to represent a section symbol.  */
d4834 1
a4834 1
         breaks gas generated objects.  */
d4855 2
a4856 2
         n_value field will contain garbage.  FIXME: This should
         probably be handled by the swapping function instead.  */
d4905 17
a4921 17
#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)                \
  {                                                             \
    coff_symbol_type *coffsym = NULL;      			\
                                                                \
    if (ptr && bfd_asymbol_bfd (ptr) != abfd)                   \
      coffsym = (obj_symbols (abfd)                             \
                 + (cache_ptr->sym_ptr_ptr - symbols));         \
    else if (ptr)                                               \
      coffsym = coff_symbol_from (abfd, ptr);                   \
    if (coffsym != NULL				                \
        && coffsym->native->u.syment.n_scnum == 0)              \
      cache_ptr->addend = 0;                                    \
    else if (ptr && bfd_asymbol_bfd (ptr) == abfd               \
             && ptr->section != NULL)		                \
      cache_ptr->addend = - (ptr->section->vma + ptr->value);   \
    else                                                        \
      cache_ptr->addend = 0;                                    \
d5370 1
a5370 1
#define	coff_close_and_cleanup              _bfd_generic_close_and_cleanup
d5374 1
a5374 1
#define coff_bfd_free_cached_info           _bfd_generic_bfd_free_cached_info
d5378 1
a5378 1
#define	coff_get_section_contents           _bfd_generic_get_section_contents
d5402 1
a5402 1
#define coff_bfd_set_private_flags          _bfd_generic_bfd_set_private_flags
d5479 1
a5479 1
  									\
d5484 1
a5484 1
  									\
d5508 1
a5508 1
  									\
d5510 1
a5510 1
  									\
d5529 1
a5529 1
  									\
d5534 1
a5534 1
  									\
d5558 1
a5558 1
  									\
d5560 1
a5560 1
  									\
d5608 1
a5608 1
  									\
@


1.142
log
@bfd/

2007-08-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* coffcode.h (ALIGN_SET): Removed.
	(ELIFALIGN_SET): Likewise.
	(coff_set_alignment_hook): Handle IMAGE_SCN_ALIGN_128BYTES,
	IMAGE_SCN_ALIGN_256BYTES, IMAGE_SCN_ALIGN_512BYTES,
	IMAGE_SCN_ALIGN_1024BYTES, IMAGE_SCN_ALIGN_2048BYTES,
	IMAGE_SCN_ALIGN_4096BYTES and IMAGE_SCN_ALIGN_8192BYTES.

include/coff/

2007-08-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* pe.h (IMAGE_SCN_ALIGN_POWER_BIT_POS): New.
	(IMAGE_SCN_ALIGN_POWER_BIT_MASK): Likewise.
	(IMAGE_SCN_ALIGN_POWER_NUM): Likewise.
	(IMAGE_SCN_ALIGN_POWER_CONST): Likewise.
	(IMAGE_SCN_ALIGN_128BYTES): Likewise.
	(IMAGE_SCN_ALIGN_256BYTES): Likewise.
	(IMAGE_SCN_ALIGN_512BYTES): Likewise.
	(IMAGE_SCN_ALIGN_1024BYTES): Likewise.
	(IMAGE_SCN_ALIGN_2048BYTES): Likewise.
	(IMAGE_SCN_ALIGN_4096BYTES): Likewise.
	(IMAGE_SCN_ALIGN_8192BYTES): Likewise.
	(IMAGE_SCN_ALIGN_1BYTES): Redefined with
	IMAGE_SCN_ALIGN_POWER_CONST.
	(IMAGE_SCN_ALIGN_2BYTES): Likewise.
	(IMAGE_SCN_ALIGN_4BYTES): Likewise.
	(IMAGE_SCN_ALIGN_8BYTES): Likewise.
	(IMAGE_SCN_ALIGN_16BYTES): Likewise.
	(IMAGE_SCN_ALIGN_32BYTES): Likewise.
	(IMAGE_SCN_ALIGN_64BYTES): Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d1295 3
d1430 5
d5274 2
a5275 1
  coff_link_output_has_begun, coff_final_link_postscript
d5318 2
a5319 1
  coff_link_output_has_begun, coff_final_link_postscript
d5363 2
a5364 1
  coff_link_output_has_begun, coff_final_link_postscript
@


1.141
log
@* coffcode.h (coff_sort_func_alent): New function.
  (coff_slurp_line_table): Sort line table if not already sorted.
@
text
@a1630 13
/* A couple of macros to help setting the alignment power field.  */
#define ALIGN_SET(field, x, y) \
  if (((field) & IMAGE_SCN_ALIGN_64BYTES) == x)\
    {\
      section->alignment_power = y;\
    }

#define ELIFALIGN_SET(field, x, y) \
  else if (((field) & IMAGE_SCN_ALIGN_64BYTES) == x) \
    {\
      section->alignment_power = y;\
    }

d1638 2
d1641 22
a1662 7
  ALIGN_SET     (hdr->s_flags, IMAGE_SCN_ALIGN_64BYTES, 6)
  ELIFALIGN_SET (hdr->s_flags, IMAGE_SCN_ALIGN_32BYTES, 5)
  ELIFALIGN_SET (hdr->s_flags, IMAGE_SCN_ALIGN_16BYTES, 4)
  ELIFALIGN_SET (hdr->s_flags, IMAGE_SCN_ALIGN_8BYTES,  3)
  ELIFALIGN_SET (hdr->s_flags, IMAGE_SCN_ALIGN_4BYTES,  2)
  ELIFALIGN_SET (hdr->s_flags, IMAGE_SCN_ALIGN_2BYTES,  1)
  ELIFALIGN_SET (hdr->s_flags, IMAGE_SCN_ALIGN_1BYTES,  0)
@


1.140
log
@Add support for building on a 64-bit Windows host.
@
text
@d4256 16
d4278 6
d4295 1
d4300 6
a4305 1
  else
d4307 1
a4307 3
      unsigned int counter = 0;
      alent *cache_ptr = lineno_cache;
      LINENO *src = native_lineno;
d4309 4
a4312 1
      while (counter < asect->lineno_count)
d4314 16
a4329 1
	  struct internal_lineno dst;
d4331 24
a4354 2
	  bfd_coff_swap_lineno_in (abfd, src, &dst);
	  cache_ptr->line_number = dst.l_lnno;
d4356 24
a4379 1
	  if (cache_ptr->line_number == 0)
d4381 3
a4383 8
	      bfd_boolean warned;
	      bfd_signed_vma symndx;
	      coff_symbol_type *sym;

	      warned = FALSE;
	      symndx = dst.l_addr.l_symndx;
	      if (symndx < 0
		  || (bfd_vma) symndx >= obj_raw_syment_count (abfd))
d4385 13
a4397 17
		  (*_bfd_error_handler)
		    (_("%B: warning: illegal symbol index %ld in line numbers"),
		     abfd, dst.l_addr.l_symndx);
		  symndx = 0;
		  warned = TRUE;
		}
	      /* FIXME: We should not be casting between ints and
                 pointers like this.  */
	      sym = ((coff_symbol_type *)
		     ((symndx + obj_raw_syments (abfd))
		      ->u.syment._n._n_n._n_zeroes));
	      cache_ptr->u.sym = (asymbol *) sym;
	      if (sym->lineno != NULL && ! warned)
		{
		  (*_bfd_error_handler)
		    (_("%B: warning: duplicate line number information for `%s'"),
		     abfd, bfd_asymbol_name (&sym->symbol));
d4399 3
a4401 1
	      sym->lineno = cache_ptr;
d4403 1
a4403 7
	  else
	    cache_ptr->u.offset = dst.l_addr.l_paddr
	      - bfd_section_vma (abfd, asect);

	  cache_ptr++;
	  src++;
	  counter++;
d4405 1
a4405 1
      cache_ptr->line_number = 0;
a4406 1
    }
d4408 1
a4408 1
  /* FIXME, free native_lineno here, or use alloca or something.  */
@


1.139
log
@Switch sources over to use the GPL version 3
@
text
@d4384 1
a4384 1
	  src->u.syment._n._n_n._n_zeroes = (long) dst;
@


1.138
log
@Fix compile time warnings (at -O3 with gcc 4.1.2)
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.137
log
@* coffcode.h (coff_rtype_to_howto): Initialise genrel.howto.
@
text
@d4873 1
@


1.136
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d4953 1
@


1.135
log
@Add x86_64-mingw64 target
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006
d5336 3
@


1.134
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d1885 2
a1886 2
    case I386AIXMAGIC:		/* Danbury PS/2 AIX C Compiler */
    case LYNXCOFFMAGIC:	/* shadows the m68k Lynx number below, sigh */
d1890 6
d2730 1
a2730 1
#ifdef I386MAGIC
d2732 1
d2734 2
a2735 1
#ifdef LYNXOS
d2739 3
d3773 1
d3782 1
d3876 1
a3876 1
#if defined(LYNXOS)
d3878 3
a3880 1
#else  /* LYNXOS */
d3882 1
a3882 1
#endif /* LYNXOS */
@


1.133
log
@2006-09-05  Bibo Mao  <bibo.mao@@intel.com>

	PR binutils/3171
	* coffcode.h (coff_write_object_contents): Set the optional
	header magic number to PE32PMAGIC instead of ZMAGIC for ia64.
@
text
@d430 1
a430 1
  else if (!strncmp (sec_name, DOT_DEBUG, sizeof (DOT_DEBUG) - 1))
d438 1
a438 1
  else if (!strncmp (sec_name, ".stab", 5))
d443 1
a443 1
  else if (!strncmp (sec_name, GNU_LINKONCE_WI, sizeof (GNU_LINKONCE_WI) - 1))
d532 2
a533 2
  if (strncmp (sec_name, DOT_DEBUG, sizeof (DOT_DEBUG) - 1) == 0
      || strncmp (sec_name, GNU_LINKONCE_WI, sizeof (GNU_LINKONCE_WI) - 1) == 0)
d677 1
a677 1
  else if (strncmp (name, DOT_DEBUG, sizeof (DOT_DEBUG) - 1) == 0
d682 1
a682 1
	   || strncmp (name, GNU_LINKONCE_WI, sizeof (GNU_LINKONCE_WI) - 1) == 0
d684 1
a684 1
	   || strncmp (name, ".stab", 5) == 0)
d718 1
a718 1
  if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0)
d1074 1
a1074 1
	  if (strncmp (name, ".reloc", sizeof ".reloc" - 1) != 0)
d1129 1
a1129 1
  if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0)
@


1.132
log
@* config/tc-arm.c (arm_fix_adjustable): For COFF, convert fixups against
   symbols which are not going to be placed into the symbol table.
* coffcode.h (coff_write_relocs): Produce an error message if a an
   out-of-range symbol index is detected in a reloc.
@
text
@d3872 1
a3872 1
    internal_a.magic = ZMAGIC;
@


1.131
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d2535 2
a2536 3
		    /* Take notice if the symbol reloc points to a symbol
		       we don't have in our symbol table.  What should we
		       do for this??  */
d2538 6
a2543 1
		      abort ();
@


1.130
log
@Add support for the Z80 processor family
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
d1563 4
@


1.130.18.1
log
@PR binutils/2724
* coffcode.h (coff_new_section_hook): Only modify the section symbol of
  sections which were created by the user.
@
text
@d1549 3
d1563 18
a1580 16
  /* PR binutils/2724: Only real sections have a symbol that
     has the coff_symbol_type structure allocated for it.  */
  if (! bfd_is_const_section (section))
    {
      combined_entry_type *native;
      bfd_size_type amt;

      /* Allocate aux records for section symbols, to store size and
	 related info.

	 @@@@ The 10 is a guess at a plausible maximum number of aux entries
	 (but shouldn't be a constant).  */
      amt = sizeof (combined_entry_type) * 10;
      native = bfd_zalloc (abfd, amt);
      if (native == NULL)
	return FALSE;
d1582 1
a1582 7
      /* We don't need to set up n_name, n_value, or n_scnum in the native
	 symbol information, since they'll be overridden by the BFD symbol
	 anyhow.  However, we do need to set the type and storage class,
	 in case this symbol winds up getting written out.  The value 0
	 for n_numaux is already correct.  */
      native->u.syment.n_type = T_NULL;
      native->u.syment.n_sclass = C_STAT;
a1583 3
      coffsymbol (section->symbol)->native = native;
    }
  
@


1.129
log
@Remove a29k support.
@
text
@d1958 17
d2575 18
@


1.128
log
@	* elf.c (bfd_section_from_shdr): Fail if sh_entsize is bogus for
	symbol, relocation, group or versym sections.

	* coffcode.h (coff_slurp_reloc_table): Don't crash if native_relocs
	is NULL.
	* peXXigen.c (pe_print_idata): Don't crash if dll_name or start_address
	doesn't point into the section.
@
text
@a1890 6
#ifdef A29K_MAGIC_BIG
    case A29K_MAGIC_BIG:
    case A29K_MAGIC_LITTLE:
      arch = bfd_arch_a29k;
      break;
#endif
a2777 9
#ifdef A29K_MAGIC_BIG
    case bfd_arch_a29k:
      if (bfd_big_endian (abfd))
	*magicp = A29K_MAGIC_BIG;
      else
	*magicp = A29K_MAGIC_LITTLE;
      return TRUE;
#endif

a3758 12
#ifdef A29K
#ifdef ULTRA3			/* NYU's machine */
    /* FIXME: This is a bogus check.  I really want to see if there
       is a .shbss or a .shdata section, if so then set the magic
       number to indicate a shared data executable.  */
    if (internal_f.f_nscns >= 7)
      internal_a.magic = SHMAGIC; /* Shared magic.  */
    else
#endif /* ULTRA3 */
      internal_a.magic = NMAGIC; /* Assume separate i/d.  */
#define __A_MAGIC_SET__
#endif /* A29K */
a4456 5
#ifdef NOTDEF			/* C_AUTOARG has the same value.  */
#ifdef C_GLBLREG
	    case C_GLBLREG:	/* A29k-specific storage class.  */
#endif
#endif
@


1.127
log
@* coffcode.h (sec_to_styp_flags): Set appropriate section flags when either
SEC_ALLOC OR SEC_LOAD.
@
text
@d4833 1
a4833 1
  if (reloc_cache == NULL)
@


1.126
log
@* coffcode.h (sec_to_styp_flags): Remove read/write flags from noload section
header.  Do not add STYP_NOLOAD since it does not appear to be a valid PE flag.
@
text
@d563 1
a563 1
  if (sec_flags & SEC_ALLOC)
@


1.125
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d534 1
a534 1
    sec_flags = SEC_READONLY | SEC_DEBUGGING;
a547 4
#ifdef STYP_NOLOAD
  if ((sec_flags & (SEC_NEVER_LOAD | SEC_COFF_SHARED_LIBRARY)) != 0)
    styp_flags |= STYP_NOLOAD;
#endif
d563 13
a575 11
  /* For now, the read/write bits are mapped onto SEC_READONLY, even
     though the semantics don't quite match.  The bits from the input
     are retained in pei_section_data(abfd, section)->pe_flags.  */

  styp_flags |= IMAGE_SCN_MEM_READ;       /* Always readable.  */
  if ((sec_flags & SEC_READONLY) == 0)
    styp_flags |= IMAGE_SCN_MEM_WRITE;    /* Invert READONLY for write.  */
  if (sec_flags & SEC_CODE)
    styp_flags |= IMAGE_SCN_MEM_EXECUTE;  /* CODE->EXECUTE.  */
  if (sec_flags & SEC_COFF_SHARED)
    styp_flags |= IMAGE_SCN_MEM_SHARED;   /* Shared remains meaningful.  */
@


1.124
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.123
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.122
log
@Update to ISO-C90 and fix formatting
@
text
@a1719 1
  asection **ps;
d1731 1
a1731 1
  for (ps = &abfd->sections; *ps != NULL; ps = &(*ps)->next)
d1733 2
a1734 6
      if (*ps == section)
	{
	  bfd_section_list_remove (abfd, ps);
	  --abfd->section_count;
	  break;
	}
d3031 2
a3032 1
    abfd->sections = section_list[0];
d3036 1
a3036 1
	current->next = section_list[i + 1];
a3054 1
    abfd->section_tail = &current->next;
@


1.121
log
@2005-04-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* coffcode.h (STRING_SIZE_SIZE): Updated to match libcoff-in.h.
@
text
@d23 2
a25 5
Most of this hacked by  Steve Chamberlain,
			sac@@cygnus.com
*/
/*

d313 1
a313 1
  PARAMS ((const char *, flagword));
d315 1
a315 1
  PARAMS ((bfd *, PTR, const char *, asection *, flagword *));
d317 1
a317 1
  PARAMS ((bfd *, PTR));
d319 2
a320 2
  PARAMS ((bfd *, asection *, const struct coff_section_alignment_entry *,
	   const unsigned int));
d322 1
a322 1
  PARAMS ((bfd *, asection *));
d324 1
a324 1
  PARAMS ((bfd *, PTR));
d326 1
a326 1
  PARAMS ((bfd *, int));
d328 1
a328 1
  PARAMS ((bfd *, unsigned int *, unsigned short *));
d330 1
a330 1
  PARAMS ((bfd *, enum bfd_architecture, unsigned long)) ATTRIBUTE_UNUSED;
d332 1
a332 1
  PARAMS ((bfd *));
d334 1
a334 1
  PARAMS ((bfd *)) ATTRIBUTE_UNUSED;
d336 3
a338 3
  PARAMS ((bfd *, asection *, const PTR, file_ptr, bfd_size_type));
static PTR buy_and_read
  PARAMS ((bfd *, file_ptr, bfd_size_type));
d340 1
a340 1
  PARAMS ((bfd *, asection *));
d342 1
a342 1
  PARAMS ((bfd *));
d344 1
a344 1
  PARAMS ((bfd *, struct internal_syment *));
d346 1
a346 1
  PARAMS ((bfd *, asection *, asymbol **));
d348 1
a348 1
  PARAMS ((bfd *, asection *, arelent **, asymbol **));
d350 2
a351 2
static PTR coff_mkobject_hook
  PARAMS ((bfd *, PTR,  PTR));
d355 1
a355 1
  PARAMS ((bfd *, flagword, PTR, const char *, asection *));
d359 1
a359 1
  PARAMS ((bfd *, unsigned int *));
d361 1
a361 1
  PARAMS ((bfd *));
d363 1
a363 1
  PARAMS ((bfd *));
d367 1
a367 1
    PARAMS ((bfd *, PTR ));
d369 1
a369 1
    PARAMS ((bfd *, PTR ));
d382 1
d396 1
a396 3
sec_to_styp_flags (sec_name, sec_flags)
     const char *sec_name;
     flagword sec_flags;
d519 1
a519 3
sec_to_styp_flags (sec_name, sec_flags)
     const char *sec_name;
     flagword sec_flags;
d592 5
a596 6
styp_to_sec_flags (abfd, hdr, name, section, flags_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR hdr;
     const char *name;
     asection *section ATTRIBUTE_UNUSED;
     flagword *flags_ptr;
d734 5
a738 6
handle_COMDAT (abfd, sec_flags, hdr, name, section)
     bfd * abfd;
     flagword sec_flags;
     PTR hdr;
     const char *name;
     asection *section;
d776 1
a776 1
      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &isym);
d857 1
a857 1
		bfd_coff_swap_aux_in (abfd, (PTR) (esym + bfd_coff_symesz (abfd)),
d859 1
a859 1
				      0, isym.n_numaux, (PTR) &aux);
d1002 5
a1006 6
styp_to_sec_flags (abfd, hdr, name, section, flags_ptr)
     bfd *abfd;
     PTR hdr;
     const char *name;
     asection *section;
     flagword *flags_ptr;
d1171 1
a1171 1
.    PARAMS ((bfd *, PTR, int, int, int, int, PTR));
d1174 1
a1174 1
.    PARAMS ((bfd *, PTR, PTR));
d1177 1
a1177 1
.    PARAMS ((bfd *, PTR, PTR));
d1180 1
a1180 1
.    PARAMS ((bfd *, PTR, int, int, int, int, PTR));
d1183 1
a1183 1
.    PARAMS ((bfd *, PTR, PTR));
d1186 1
a1186 1
.    PARAMS ((bfd *, PTR, PTR));
d1189 1
a1189 1
.    PARAMS ((bfd *, PTR, PTR));
d1192 1
a1192 1
.    PARAMS ((bfd *, PTR, PTR));
d1195 1
a1195 1
.    PARAMS ((bfd *, PTR, PTR));
d1198 1
a1198 1
.    PARAMS ((bfd *, PTR, PTR));
d1215 1
a1215 1
.    PARAMS ((bfd *, PTR, PTR));
d1218 1
a1218 1
.    PARAMS ((bfd *, PTR, PTR));
d1221 1
a1221 1
.    PARAMS ((bfd *, PTR, PTR));
d1224 1
a1224 1
.    PARAMS ((bfd *abfd, PTR, PTR));
d1227 1
a1227 1
.    PARAMS ((bfd *, PTR));
d1230 1
a1230 1
.    PARAMS ((bfd *, PTR));
d1232 2
a1233 2
.  PTR (*_bfd_coff_mkobject_hook)
.    PARAMS ((bfd *, PTR, PTR));
d1236 1
a1236 1
.    PARAMS ((bfd *, PTR, const char *, asection *, flagword *));
d1239 1
a1239 1
.    PARAMS ((bfd *, asection *, PTR));
d1242 1
a1242 1
.    PARAMS ((bfd *));
d1245 1
a1245 1
.    PARAMS ((bfd *, struct internal_syment *));
d1248 2
a1249 2
.    PARAMS ((bfd *, combined_entry_type *, combined_entry_type *,
.	     unsigned int, combined_entry_type *));
d1252 2
a1253 2
.    PARAMS ((bfd *, FILE *, combined_entry_type *, combined_entry_type *,
.	     combined_entry_type *, unsigned int));
d1256 2
a1257 2
.    PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
.	    bfd_byte *, unsigned int *, unsigned int *));
d1260 2
a1261 2
.    PARAMS ((bfd *, asection *, arelent *, unsigned int,
.	     struct bfd_link_info *));
d1264 1
a1264 1
.    PARAMS ((bfd *, struct internal_syment *));
d1267 1
a1267 1
.    PARAMS ((bfd *));
d1270 1
a1270 1
.    PARAMS ((bfd *, struct bfd_link_info *));
d1273 2
a1274 2
.    PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
.	     struct internal_reloc *, struct internal_syment *, asection **));
d1277 1
a1277 1
.    PARAMS ((bfd *, asection *, struct internal_reloc *,
d1279 1
a1279 1
.	     bfd_vma *));
d1282 2
a1283 2
.    PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
.	     struct internal_reloc *, bfd_boolean *));
d1286 1
a1286 1
.    PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword,
d1288 1
a1288 1
.	     struct bfd_link_hash_entry **));
d1291 1
a1291 1
.    PARAMS ((bfd *, struct coff_final_link_info *));
d1294 1
a1294 1
.    PARAMS ((bfd *, struct coff_final_link_info *));
d1424 1
a1424 1
.  ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a,p))
d1426 1
a1426 1
.  ((coff_backend_info (a)->_bfd_coff_final_link_postscript) (a,p))
d1433 1
a1433 3
coff_bad_format_hook (abfd, filehdr)
     bfd * abfd ATTRIBUTE_UNUSED;
     PTR filehdr;
d1458 1
a1458 3
ticoff0_bad_format_hook (abfd, filehdr)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR filehdr;
d1471 1
a1471 3
ticoff1_bad_format_hook (abfd, filehdr)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR filehdr;
d1486 4
a1489 5
coff_set_custom_section_alignment (abfd, section, alignment_table, table_size)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
     const struct coff_section_alignment_entry *alignment_table;
     const unsigned int table_size;
d1549 1
a1549 3
coff_new_section_hook (abfd, section)
     bfd * abfd;
     asection * section;
d1571 1
a1571 1
  native = (combined_entry_type *) bfd_zalloc (abfd, amt);
a1596 2
static void coff_set_alignment_hook PARAMS ((bfd *, asection *, PTR));

d1598 3
a1600 4
coff_set_alignment_hook (abfd, section, scnhdr)
     bfd * abfd ATTRIBUTE_UNUSED;
     asection * section;
     PTR scnhdr;
d1629 5
a1633 5
#define ALIGN_SET(field,x,y) \
  if (((field) & IMAGE_SCN_ALIGN_64BYTES) == x )\
  {\
     section->alignment_power = y;\
  }
d1635 5
a1639 7
#define ELIFALIGN_SET(field,x,y) \
  else if (( (field) & IMAGE_SCN_ALIGN_64BYTES) == x ) \
  {\
     section->alignment_power = y;\
  }

static void coff_set_alignment_hook PARAMS ((bfd *, asection *, PTR));
d1642 3
a1644 4
coff_set_alignment_hook (abfd, section, scnhdr)
     bfd * abfd ATTRIBUTE_UNUSED;
     asection * section;
     PTR scnhdr;
d1664 1
a1664 1
      section->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d1666 2
a1667 4
	{
	  /* FIXME: Return error.  */
	  abort ();
	}
d1669 1
d1673 1
a1673 1
      coff_section_data (abfd, section)->tdata = (PTR) bfd_zalloc (abfd, amt);
d1675 2
a1676 4
	{
	  /* FIXME: Return error.  */
	  abort ();
	}
d1692 1
a1692 1
      if (bfd_bread ((PTR) &dst, relsz, abfd) != relsz)
a1714 2
static void coff_set_alignment_hook PARAMS ((bfd *, asection *, PTR));

d1716 1
a1716 4
coff_set_alignment_hook (abfd, section, scnhdr)
     bfd *abfd;
     asection *section;
     PTR scnhdr;
d1746 1
a1746 1
  ((void (*) PARAMS ((bfd *, asection *, PTR))) bfd_void)
a1753 2
static bfd_boolean coff_mkobject PARAMS ((bfd *));

d1755 1
a1755 2
coff_mkobject (abfd)
     bfd * abfd;
d1760 2
a1761 2
  abfd->tdata.coff_obj_data = (struct coff_tdata *) bfd_zalloc (abfd, amt);
  if (abfd->tdata.coff_obj_data == 0)
d1764 3
a1766 3
  coff->symbols = (coff_symbol_type *) NULL;
  coff->conversion_table = (unsigned int *) NULL;
  coff->raw_syments = (struct coff_ptr_struct *) NULL;
d1779 4
a1782 5
static PTR
coff_mkobject_hook (abfd, filehdr, aouthdr)
     bfd * abfd;
     PTR filehdr;
     PTR aouthdr ATTRIBUTE_UNUSED;
d1852 1
a1852 1
  return (PTR) coff;
d1864 1
a1864 3
coff_set_arch_mach_hook (abfd, filehdr)
     bfd *abfd;
     PTR filehdr;
d2057 1
a2057 1
		buf = (bfd_byte *) bfd_malloc (amt);
d2064 1
a2064 1
		bfd_coff_swap_sym_in (abfd, (PTR) buf, (PTR) &sym);
a2252 3
static bfd_boolean symname_in_debug_hook
  PARAMS ((bfd *, struct internal_syment *));

d2254 1
a2254 3
symname_in_debug_hook (abfd, sym)
     bfd * abfd ATTRIBUTE_UNUSED;
     struct internal_syment *sym;
d2262 1
a2262 1
  (bfd_boolean (*) PARAMS ((bfd *, struct internal_syment *))) bfd_false
a2273 4
static bfd_boolean coff_pointerize_aux_hook
  PARAMS ((bfd *, combined_entry_type *, combined_entry_type *,
	   unsigned int, combined_entry_type *));

d2275 5
a2279 6
coff_pointerize_aux_hook (abfd, table_base, symbol, indaux, aux)
     bfd *abfd ATTRIBUTE_UNUSED;
     combined_entry_type *table_base;
     combined_entry_type *symbol;
     unsigned int indaux;
     combined_entry_type *aux;
a2307 4
static bfd_boolean coff_pointerize_aux_hook
  PARAMS ((bfd *, combined_entry_type *, combined_entry_type *,
	   unsigned int, combined_entry_type *));

d2309 5
a2313 6
coff_pointerize_aux_hook (abfd, table_base, symbol, indaux, aux)
     bfd *abfd ATTRIBUTE_UNUSED;
     combined_entry_type *table_base ATTRIBUTE_UNUSED;
     combined_entry_type *symbol;
     unsigned int indaux;
     combined_entry_type *aux ATTRIBUTE_UNUSED;
a2331 4
static bfd_boolean coff_print_aux
  PARAMS ((bfd *, FILE *, combined_entry_type *, combined_entry_type *,
	   combined_entry_type *, unsigned int));

d2333 6
a2338 7
coff_print_aux (abfd, file, table_base, symbol, aux, indaux)
     bfd *abfd ATTRIBUTE_UNUSED;
     FILE *file ATTRIBUTE_UNUSED;
     combined_entry_type *table_base ATTRIBUTE_UNUSED;
     combined_entry_type *symbol ATTRIBUTE_UNUSED;
     combined_entry_type *aux ATTRIBUTE_UNUSED;
     unsigned int indaux ATTRIBUTE_UNUSED;
a2405 1
static int compare_arelent_ptr PARAMS ((const PTR, const PTR));
d2409 1
a2409 3
compare_arelent_ptr (x, y)
     const PTR x;
     const PTR y;
d2422 1
a2422 3
coff_write_relocs (abfd, first_undef)
     bfd * abfd;
     int first_undef;
d2426 1
a2426 1
  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
d2441 1
a2441 1
	p = (arelent **) bfd_malloc (amt);
d2458 1
a2458 1
	  memset ((PTR) & n, 0, sizeof (n));
d2462 2
a2463 2
	  if (bfd_bwrite ((PTR) & dst, (bfd_size_type) bfd_coff_relsz (abfd),
			 abfd) != bfd_coff_relsz (abfd))
d2473 1
a2473 1
	  memset ((PTR) & n, 0, sizeof (n));
d2495 6
a2500 5
		  if (strcmp (intable, sname) == 0) {
		    /* Got a hit, so repoint the reloc.  */
		    q->sym_ptr_ptr = outsyms + j;
		    break;
		  }
d2517 1
a2517 1
                if (SECTION_RELATIVE_ABSOLUTE_SYMBOL_P (q,s))
d2547 1
a2547 1
	  if (bfd_bwrite ((PTR) & dst, (bfd_size_type) bfd_coff_relsz (abfd),
d2565 3
a2567 4
coff_set_flags (abfd, magicp, flagsp)
     bfd * abfd;
     unsigned int *magicp ATTRIBUTE_UNUSED;
     unsigned short *flagsp ATTRIBUTE_UNUSED;
d2574 1
d2577 3
a2579 8
	case bfd_mach_z8001:
	  *flagsp = F_Z8001;
	  break;
	case bfd_mach_z8002:
	  *flagsp = F_Z8002;
	  break;
	default:
	  return FALSE;
d2583 1
a2584 1

d2589 1
d2591 1
a2591 4
	/*
	  ((bfd_get_file_flags(abfd) & WP_TEXT) ? I960ROMAGIC :
	  I960RWMAGIC);   FIXME???
	  */
d2594 9
a2602 26
	  case bfd_mach_i960_core:
	    flags = F_I960CORE;
	    break;
	  case bfd_mach_i960_kb_sb:
	    flags = F_I960KB;
	    break;
	  case bfd_mach_i960_mc:
	    flags = F_I960MC;
	    break;
	  case bfd_mach_i960_xa:
	    flags = F_I960XA;
	    break;
	  case bfd_mach_i960_ca:
	    flags = F_I960CA;
	    break;
	  case bfd_mach_i960_ka_sa:
	    flags = F_I960KA;
	    break;
	  case bfd_mach_i960_jx:
	    flags = F_I960JX;
	    break;
	  case bfd_mach_i960_hx:
	    flags = F_I960HX;
	    break;
	  default:
	    return FALSE;
d2648 1
d2687 1
a2691 1
      break;
d2693 1
a2701 1
      break;
d2703 1
a2707 1
      break;
d2709 1
a2713 1
      break;
d2715 1
a2732 1
      break;
a2738 1
      break;
d2740 1
d2745 6
a2750 15
	case bfd_mach_h8300:
	  *magicp = H8300MAGIC;
	  return TRUE;
	case bfd_mach_h8300h:
	  *magicp = H8300HMAGIC;
	  return TRUE;
	case bfd_mach_h8300s:
	  *magicp = H8300SMAGIC;
	  return TRUE;
	case bfd_mach_h8300hn:
	  *magicp = H8300HNMAGIC;
	  return TRUE;
	case bfd_mach_h8300sn:
	  *magicp = H8300SNMAGIC;
	  return TRUE;
a2765 1
      break;
a2771 1
      break;
a2781 1
      break;
d2790 1
a2797 1
      break;
a2803 1
      break;
a2813 1
      break;
d2842 3
a2844 8
	case bfd_mach_maxq10:
	  * flagsp = F_MAXQ10;
	  return TRUE;
	case bfd_mach_maxq20:
	  * flagsp = F_MAXQ20;
	  return TRUE;
	default:
	  return FALSE;
d2858 3
a2860 4
coff_set_arch_mach (abfd, arch, machine)
     bfd * abfd;
     enum bfd_architecture arch;
     unsigned long machine;
d2870 1
a2870 1
    return FALSE;		/* We can't represent this type */
d2872 1
a2872 1
  return TRUE;			/* We're easy ...  */
a2879 2
static int sort_by_secaddr PARAMS ((const PTR, const PTR));

d2881 1
a2881 3
sort_by_secaddr (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d2890 2
a2891 2
  else
    return 0;
d2906 1
a2906 2
coff_compute_section_file_positions (abfd)
     bfd * abfd;
d2909 1
a2909 1
  asection *previous = (asection *) NULL;
d2957 1
d2976 3
a2978 5
    {
      /*  A start address may have been added to the original file. In this
	  case it will need an optional header to record it.  */
      abfd->flags |= EXEC_P;
    }
d3076 1
a3076 1
       current != (asection *) NULL;
d3085 2
a3086 1
	  current->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d3093 2
a3094 2
	  coff_section_data (abfd, current)->tdata
	    = (PTR) bfd_zalloc (abfd, amt);
d3121 1
a3122 1
	  old_sofar = sofar;
d3155 1
a3155 1
	  if (previous != (asection *) NULL)
d3249 1
a3249 3
coff_read_word (abfd, value)
  bfd *abfd;
  unsigned int *value;
d3272 1
a3272 2
coff_compute_checksum (abfd)
  bfd *abfd;
d3299 1
a3299 2
coff_apply_checksum (abfd)
  bfd *abfd;
a3332 2
/* SUPPRESS 558 */
/* SUPPRESS 529 */
d3334 1
a3334 2
coff_write_object_contents (abfd)
     bfd * abfd;
a3359 1

d3399 2
a3400 3
	{
	  current->line_filepos = 0;
	}
d3412 1
a3412 3
	{
	  current->rel_filepos = 0;
	}
d3571 1
a3571 1
	      || bfd_bwrite ((PTR) &buff, amt, abfd) != amt)
d3695 1
a3695 1
	      || bfd_bwrite ((PTR) &buff, amt, abfd) != amt)
d4066 1
a4066 1
  /* now write them */
d4078 2
a4079 2
    bfd_coff_swap_filehdr_out (abfd, (PTR) &internal_f, (PTR) buff);
    amount = bfd_bwrite ((PTR) buff, amount, abfd);
d4098 2
a4099 2
      coff_swap_aouthdr_out (abfd, (PTR) &internal_a, (PTR) buff);
      amount = bfd_bwrite ((PTR) buff, amount, abfd);
d4118 1
a4118 1
      coff_swap_aouthdr_out (abfd, (PTR) &internal_a, (PTR) &buff);
d4123 1
a4123 1
      if (bfd_bwrite ((PTR) &buff, (bfd_size_type) size, abfd) != size)
d4132 5
a4136 6
coff_set_section_contents (abfd, section, location, offset, count)
     bfd * abfd;
     sec_ptr section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
a4144 1

a4164 1

a4178 1

d4195 2
a4196 5
static PTR
buy_and_read (abfd, where, size)
     bfd *abfd;
     file_ptr where;
     bfd_size_type size;
d4198 2
a4199 1
  PTR area = (PTR) bfd_alloc (abfd, size);
d4206 1
a4206 1
}				/* buy_and_read() */
a4228 1

d4232 1
a4232 3
coff_slurp_line_table (abfd, asect)
     bfd *abfd;
     asection *asect;
d4238 1
a4238 1
  BFD_ASSERT (asect->lineno == (alent *) NULL);
d4249 1
a4249 1
  lineno_cache = (alent *) bfd_alloc (abfd, amt);
d4297 2
a4298 4
	    {
	      cache_ptr->u.offset = dst.l_addr.l_paddr
		- bfd_section_vma (abfd, asect);
	    }			/* If no linenumber expect a symbol index */
d4317 1
a4317 2
coff_slurp_symbol_table (abfd)
     bfd * abfd;
d4335 1
a4335 1
  cached_area = (coff_symbol_type *) bfd_alloc (abfd, amt);
d4341 1
a4341 1
  table_ptr = (unsigned int *) bfd_alloc (abfd, amt);
d4403 3
a4405 5
		    {
		      /* A function ext does not go at the end of a
			 file.  */
		      dst->symbol.flags |= BSF_NOT_AT_END | BSF_FUNCTION;
		    }
a4643 2
/*      BFD_ASSERT(dst->symbol.flags != 0);*/

d4647 1
a4647 1
	  dst->lineno = (alent *) NULL;
d4672 1
a4672 1
}				/* coff_slurp_symbol_table() */
d4679 2
a4680 3
coff_classify_symbol (abfd, syment)
     bfd *abfd;
     struct internal_syment *syment;
d4718 5
a4722 7
	{
	  /* The Microsoft compiler sometimes generates these if a
             small static function is inlined every time it is used.
             The function is discarded, but the symbol table entry
             remains.  */
	  return COFF_SYMBOL_LOCAL;
	}
a4726 1

a4756 1

a4793 1

d4799 2
a4800 1
    coff_symbol_type *coffsym = (coff_symbol_type *) NULL;      \
d4806 1
a4806 1
    if (coffsym != (coff_symbol_type *) NULL                    \
d4810 1
a4810 1
             && ptr->section != (asection *) NULL)              \
d4818 1
a4818 4
coff_slurp_reloc_table (abfd, asect, symbols)
     bfd * abfd;
     sec_ptr asect;
     asymbol ** symbols;
d4834 1
d4838 1
a4838 1
  reloc_cache = (arelent *) bfd_alloc (abfd, amt);
d4895 1
a4895 1
/* !!     cache_ptr->section = (asection *) NULL;*/
a4923 5
static reloc_howto_type *coff_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));

d4925 6
a4930 7
coff_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     bfd_vma *addendp ATTRIBUTE_UNUSED;
d4946 1
d4948 4
a4951 5
coff_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd * abfd;
     sec_ptr section;
     arelent ** relptr;
     asymbol ** symbols;
a4985 4
static int dummy_reloc16_estimate
  PARAMS ((bfd *, asection *, arelent *, unsigned int,
	   struct bfd_link_info *));

d4987 5
a4991 6
dummy_reloc16_estimate (abfd, input_section, reloc, shrink, link_info)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     arelent *reloc ATTRIBUTE_UNUSED;
     unsigned int shrink ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
a5004 4
static void dummy_reloc16_extra_cases
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
	   bfd_byte *, unsigned int *, unsigned int *));

d5006 7
a5012 9
dummy_reloc16_extra_cases (abfd, link_info, link_order, reloc, data, src_ptr,
			   dst_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info ATTRIBUTE_UNUSED;
     struct bfd_link_order *link_order ATTRIBUTE_UNUSED;
     arelent *reloc ATTRIBUTE_UNUSED;
     bfd_byte *data ATTRIBUTE_UNUSED;
     unsigned int *src_ptr ATTRIBUTE_UNUSED;
     unsigned int *dst_ptr ATTRIBUTE_UNUSED;
d5024 1
d5026 1
d5036 1
d5038 1
d5047 1
d5050 1
a5050 1
#define coff_bfd_link_just_syms _bfd_generic_link_just_syms
a5066 3
static bfd_boolean coff_link_output_has_begun
  PARAMS ((bfd *, struct coff_final_link_info *));

d5068 2
a5069 3
coff_link_output_has_begun (abfd, info)
     bfd * abfd;
     struct coff_final_link_info * info ATTRIBUTE_UNUSED;
a5076 3
static bfd_boolean coff_final_link_postscript
  PARAMS ((bfd *, struct coff_final_link_info *));

d5078 2
a5079 3
coff_final_link_postscript (abfd, pfinfo)
     bfd * abfd ATTRIBUTE_UNUSED;
     struct coff_final_link_info * pfinfo ATTRIBUTE_UNUSED;
d5170 1
d5214 1
d5353 2
a5354 2
  BFD_ENDIAN_BIG,		/* data byte order is big */		\
  BFD_ENDIAN_BIG,		/* header byte order is big */		\
d5360 3
a5362 3
  UNDER,			/* leading symbol underscore */		\
  '/',				/* ar_pad_char */			\
  15,				/* ar_max_namelen */			\
d5374 1
a5374 1
	/* bfd_check_format */						\
d5377 1
a5377 1
	/* bfd_set_format */						\
d5379 1
a5379 1
	/* bfd_write_contents */					\
d5403 2
a5404 2
  BFD_ENDIAN_LITTLE,		/* data byte order is little */		\
  BFD_ENDIAN_BIG,		/* header byte order is big */		\
d5410 3
a5412 3
  UNDER,			/* leading symbol underscore */		\
  '/',				/* ar_pad_char */			\
  15,				/* ar_max_namelen */			\
d5424 1
a5424 1
	/* bfd_check_format */						\
d5427 1
a5427 1
	/* bfd_set_format */						\
d5429 1
a5429 1
	/* bfd_write_contents */					\
d5453 2
a5454 2
  BFD_ENDIAN_LITTLE,		/* data byte order is little */		\
  BFD_ENDIAN_LITTLE,		/* header byte order is little */	\
d5460 3
a5462 3
  UNDER,			/* leading symbol underscore */		\
  '/',				/* ar_pad_char */			\
  15,				/* ar_max_namelen */			\
d5472 1
a5472 1
	/* bfd_check_format */						\
d5475 1
a5475 1
       /* bfd_set_format */						\
d5477 1
a5477 1
	/* bfd_write_contents */					\
@


1.120
log
@	* coffcode.h (coff_sym_filepos): Remove GNU960 conditional code.
	* format.c (bfd_check_format_matches): Likewise.
	* archive.c (BFD_GNU960_ARMAG): Likewise.
	(bfd_generic_archive_p): Likewise.
	(_bfd_write_archive_contents): Likewise.
@
text
@d310 1
a310 1
#define STRING_SIZE_SIZE (4)
@


1.119
log
@	* coffcode.h (coff_print_aux): Warning fix.
	* elf-m10300.c (mn10300_elf_relax_section): Use section->id
	instead of section pointer to identify.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.  Allocate
	the correct size buffer for local sym mangling too.
	(h8300_bfd_link_add_symbols): Likewise.
	* elf32-sh-symbian.c (sh_symbian_process_embedded_commands): Fix
	warning.
	* elf32-sh64.c (shmedia_prepare_reloc): Use %B and %p in error message
	* elf32-xtensa.c (literal_value_hash): Warning fix.
	* versados.c (process_otr): Warning fix.
	(versados_canonicalize_reloc): Likewise.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Warning fix.
	* vms.c (fill_section_ptr): Warning fix.
@
text
@a5132 9
#ifdef GNU960
file_ptr
coff_sym_filepos (abfd)
     bfd *abfd;
{
  return obj_sym_filepos (abfd);
}
#endif

@


1.118
log
@bfd/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* coffcode.h (sec_to_styp_flags): Replaced SEC_CLINK with
	SEC_TIC54X_CLINK. Replace SEC_BLOCK with SEC_TIC54X_BLOCK.
	Replace SEC_SHARED with SEC_COFF_SHARED.
	(styp_to_sec_flags): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Remove SEC_ARCH_BIT_0.
	(TARGET_LITTLE_SYM): Likewise.

	* section.c (SEC_ARCH_BIT_0): Removed.
	(SEC_LINK_DUPLICATES_SAME_CONTENTS): Defined with
	SEC_LINK_DUPLICATES_ONE_ONLY and SEC_LINK_DUPLICATES_SAME_SIZE.
	(SEC_SHARED): Renamed to ...
	(SEC_COFF_SHARED): This.
	(SEC_BLOCK): Renamed to ...
	(SEC_TIC54X_BLOCK): This.
	(SEC_CLINK): Renamed to ...
	(SEC_TIC54X_CLINK): This.
	(SEC_XXX): Rearranged. Move SEC_COFF_SHARED_LIBRARY,
	SEC_COFF_SHARED, SEC_TIC54X_BLOCK and SEC_TIC54X_CLINK to the
	end.
	* bfd-in2.h: Regenerated.

binutils/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (parse_flags): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* objdump.c (dump_section_header): Dump SEC_TIC54X_BLOCK and
	SEC_TIC54X_CLINK for TI c54x only. Remove SEC_ARCH_BIT_0. Dump
	SEC_COFF_SHARED for COFF only.

gas/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-coff.c (obj_coff_section): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* config/tc-tic54x.c (tic54x_bss): Replace SEC_BLOCK with
	SEC_TIC54X_BLOCK.
	(demand_empty_rest_of_line): Likewise.
	(tic54x_sblock): Likewise.
	(tic54x_clink): Replace with SEC_CLINK with SEC_TIC54X_CLINK.

ld/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_add_section): Check SEC_TIC54X_BLOCK for TI
	tic54x input only.
	(lang_size_sections_1): Check SEC_COFF_SHARED_LIBRARY for COFF
	and ECOFF output only.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d2409 2
a2410 1
	  fprintf (file, "val %5lld", aux->u.auxent.x_csect.x_scnlen.l);
d2420 2
a2421 1
	    fprintf (file, "%4lld", aux->u.auxent.x_csect.x_scnlen.l);
@


1.117
log
@(coff_std_swap_table): Add an unused attribute in case it is not used.
@
text
@d497 1
a497 1
  if (sec_flags & SEC_CLINK)
d502 1
a502 1
  if (sec_flags & SEC_BLOCK)
d582 1
a582 1
  if (sec_flags & SEC_SHARED)
d611 1
a611 1
    sec_flags |= SEC_BLOCK;
d616 1
a616 1
    sec_flags |= SEC_CLINK;
d1089 1
a1089 1
	  sec_flags |= SEC_SHARED;
@


1.116
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d5299 1
a5299 1
static const bfd_coff_backend_data bfd_coff_std_swap_table =
@


1.115
log
@Add support for maxq10 and maxq20 machine values
@
text
@a1068 3
#if 0
	  unhandled = "IMAGE_SCN_MEM_NOT_PAGED";
#else
a1073 1
#endif
a3350 80
#if 0

/* This can never work, because it is called too late--after the
   section positions have been set.  I can't figure out what it is
   for, so I am going to disable it--Ian Taylor 20 March 1996.  */

/* If .file, .text, .data, .bss symbols are missing, add them.  */
/* @@@@ Should we only be adding missing symbols, or overriding the aux
   values for existing section symbols?  */
static bfd_boolean
coff_add_missing_symbols (abfd)
     bfd *abfd;
{
  unsigned int nsyms = bfd_get_symcount (abfd);
  asymbol **sympp = abfd->outsymbols;
  asymbol **sympp2;
  unsigned int i;
  int need_text = 1, need_data = 1, need_bss = 1, need_file = 1;
  bfd_size_type amt;

  for (i = 0; i < nsyms; i++)
    {
      coff_symbol_type *csym = coff_symbol_from (abfd, sympp[i]);
      const char *name;

      if (csym)
	{
	  /* Only do this if there is a coff representation of the input
	     symbol.  */
	  if (csym->native && csym->native->u.syment.n_sclass == C_FILE)
	    {
	      need_file = 0;
	      continue;
	    }
	  name = csym->symbol.name;
	  if (!name)
	    continue;
	  if (!strcmp (name, _TEXT))
	    need_text = 0;
#ifdef APOLLO_M68
	  else if (!strcmp (name, ".wtext"))
	    need_text = 0;
#endif
	  else if (!strcmp (name, _DATA))
	    need_data = 0;
	  else if (!strcmp (name, _BSS))
	    need_bss = 0;
	}
    }
  /* Now i == bfd_get_symcount (abfd).  */
  /* @@@@ For now, don't deal with .file symbol.  */
  need_file = 0;

  if (!need_text && !need_data && !need_bss && !need_file)
    return TRUE;
  nsyms += need_text + need_data + need_bss + need_file;
  amt = nsyms;
  amt *= sizeof (asymbol *);
  sympp2 = (asymbol **) bfd_alloc (abfd, amt);
  if (!sympp2)
    return FALSE;
  memcpy (sympp2, sympp, i * sizeof (asymbol *));

  if (need_file)
    /* @@@@ Generate fake .file symbol, in sympp2[i], and increment i.  */
    abort ();

  if (need_text)
    sympp2[i++] = coff_section_symbol (abfd, _TEXT);
  if (need_data)
    sympp2[i++] = coff_section_symbol (abfd, _DATA);
  if (need_bss)
    sympp2[i++] = coff_section_symbol (abfd, _BSS);
  BFD_ASSERT (i == nsyms);
  bfd_set_symtab (abfd, sympp2, nsyms);
  return TRUE;
}

#endif /* 0 */

d4035 1
a4035 4
#if 0
      if (!coff_add_missing_symbols (abfd))
	return FALSE;
#endif
a4316 26
#if 0
static bfd_boolean
coff_close_and_cleanup (abfd)
     bfd *abfd;
{
  if (!bfd_read_p (abfd))
    switch (abfd->format)
      {
      case bfd_archive:
	if (!_bfd_write_archive_contents (abfd))
	  return FALSE;
	break;
      case bfd_object:
	if (!coff_write_object_contents (abfd))
	  return FALSE;
	break;
      default:
	bfd_set_error (bfd_error_invalid_operation);
	return FALSE;
      }

  /* We depend on bfd_close to free all the memory on the objalloc.  */
  return TRUE;
}

#endif
a4499 5
#if 0
	      dst->symbol.value = src->u.syment.n_value - dst->symbol.section->vma;
	      dst->symbol.flags = BSF_EXPORT | BSF_GLOBAL;
	      dst->symbol.flags |= BSF_NOT_AT_END | BSF_FUNCTION;
#endif
@


1.114
log
@Add support fpr MAXQ processor
@
text
@d1992 11
a2002 1
      machine = 0;
d2940 12
a2951 3
        *magicp = MAXQ20MAGIC;
      return TRUE;
      break;
@


1.113
log
@2004-10-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 440
	* coffcode.h (coff_compute_section_file_positions): Cast to
	bfd_vma when computing page alignment.
@
text
@d1989 6
d2928 7
d4079 5
@


1.112
log
@Implement a new BFD API function: bfd_is_target_special_symbol.  Use this in nm
and objdump to skip the displaying of ARM Mapping symbols unless specifically
requested.
@
text
@d3246 1
a3246 1
	sofar += (current->vma - sofar) % page_size;
@


1.111
log
@PR 360
(handle_COMDAT): Replace abort with an warning message and allow the scan to
continue.
@
text
@d5550 4
@


1.110
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@a831 2
		seen_state = 1;

d859 4
a862 1
		  abort ();
@


1.109
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d1074 2
a1075 2
	  _bfd_error_handler (_("%s: Warning: Ignoring section flag IMAGE_SCN_MEM_NOT_PAGED in section %s"),
	     bfd_archive_filename (abfd), name);
d1130 2
a1131 2
	    (_("%s (%s): Section flag %s (0x%x) ignored"),
	     bfd_archive_filename (abfd), name, unhandled, flag);
d4448 1
a4448 2
        (_("%s: warning: line number table read failed"),
	 bfd_archive_filename (abfd));
d4480 2
a4481 2
		    (_("%s: warning: illegal symbol index %ld in line numbers"),
		     bfd_archive_filename (abfd), dst.l_addr.l_symndx);
d4494 2
a4495 3
		    (_("%s: warning: duplicate line number information for `%s'"),
		     bfd_archive_filename (abfd),
		     bfd_asymbol_name (&sym->symbol));
d4849 2
a4850 2
		(_("%s: Unrecognized storage class %d for %s symbol `%s'"),
		 bfd_archive_filename (abfd), src->u.syment.n_sclass,
d4982 2
a4983 3
	(_("warning: %s: local symbol `%s' has no section"),
	 bfd_archive_filename (abfd),
	 _bfd_coff_internal_syment_name (abfd, syment, buf));
d5088 2
a5089 2
		(_("%s: warning: illegal symbol index %ld in relocs"),
		 bfd_archive_filename (abfd), dst.r_symndx);
d5126 2
a5127 2
	    (_("%s: illegal relocation type %d at address 0x%lx"),
	     bfd_archive_filename (abfd), dst.r_type, (long) dst.r_vaddr);
@


1.108
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d968 4
a971 3
		amt = sizeof (struct bfd_comdat_info);
		section->comdat = bfd_alloc (abfd, amt);
		if (section->comdat == NULL)
d974 1
a974 1
		section->comdat->symbol =
d983 2
a984 1
		section->comdat->name = newname;
d5591 5
@


1.107
log
@* coffcode.h (styp_to_sec_flags): Ignore IMAGE_SCN_MEM_NOT_PAGED flags.
@
text
@d3026 1
a3026 1
	  dsec->_raw_size = sz;
d3125 1
a3125 1
	if (current->_raw_size == 0)
d3176 1
a3176 1
	pei_section_data (abfd, current)->virt_size = current->_raw_size;
d3185 1
a3185 1
      if (current->_raw_size == 0)
d3233 1
a3233 1
	    previous->_raw_size += sofar - old_sofar;
d3249 1
a3249 1
      current->_raw_size = (current->_raw_size + page_size -1) & -page_size;
d3252 1
a3252 1
      sofar += current->_raw_size;
d3260 5
a3264 5
	  old_size = current->_raw_size;
	  current->_raw_size = BFD_ALIGN (current->_raw_size,
					  1 << current->alignment_power);
	  align_adjust = current->_raw_size != old_size;
	  sofar += current->_raw_size - old_size;
d3271 1
a3271 1
	  current->_raw_size += sofar - old_sofar;
d3277 3
a3279 3
         _raw_size, in case the caller only writes out data to the
         unaligned _raw_size.  */
      if (pei_section_data (abfd, current)->virt_size < current->_raw_size)
d3651 1
a3651 1
      section.s_size =  current->_raw_size;
d3670 2
a3671 2
      if (current->_raw_size == 0 ||
	  (current->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
d4143 1
a4143 1
      internal_a.tsize = bfd_get_section_size (text_sec);
d4148 1
a4148 1
      internal_a.dsize = bfd_get_section_size (data_sec);
d4153 1
a4153 1
      internal_a.bsize = bfd_get_section_size (bss_sec);
@


1.106
log
@	* section.c (struct sec): Remove usused flags.  Reorganize a little.
	(bfd_get_section_size_before_reloc): Delete.
	(bfd_get_section_size_after_reloc): Delete.
	(STD_SECTION): Update.
	(bfd_get_section_size_now): Delete.
	(bfd_set_section_contents): Don't referece reloc_done.
	(bfd_get_section_contents): Remove reloc_done comment.
	* bout.c (b_out_bfd_get_relocated_section_contents): Don't set
	reloc_done.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents): Likewise.
	* ecoff.c (bfd_debug_section): Update initializer.
	* elfxx-mips.c (_bfd_elf_mips_get_relocated_section_contents): Ditto.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* bfd-in.h (bfd_section_size): Expand.
	(bfd_get_section_size): New macro.
	* bfd-in2.h: Regenerate.
	* coff64-rs6000.c (xcoff64_write_object_contents): Replace
	bfd_get_section_size_before_reloc with bfd_get_section_size.
	* coffcode.h (coff_write_object_contents): Likewise.
	* coffgen.c (build_debug_section): Likewise.
	* dwarf1.c (parse_line_table): Likewise.
	(_bfd_dwarf1_find_nearest_line): Likewise.
	* ecoff.c (_bfd_ecoff_write_object_contents): Likewise.
	* i386msdos.c (msdos_write_object_contents): Likewise.
	* pdp11.c (squirt_out_relocs): Likewise.
	* elf32-sh64.c (sh64_find_section_for_address): Remove comment.
	* elf64-mmix.c (mmix_elf_final_link): Update comment.
@
text
@d1066 1
d1068 7
@


1.105
log
@binutils ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* objcopy.c (setup_bfd_headers): New function.
	(copy_object): Call setup_bfd_headers.
bfd ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* aout-target.h (MY_bfd_copy_private_header_data): Define.
	* aout-tic30.c (MY_bfd_copy_private_header_data): Define.
	* bfd.c (bfd_copy_private_header_data): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add entries for new
	interface.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_copy_private_header_data): Define.
	* elf-bfd.h (_bfd_elf_copy_private_header_data): Declare.
	* elf.c (_bfd_elf_copy_private_section_data): Remove code to set up
	segments by calling copy_private_bfd_data.
	(_bfd_elf_copy_private_header_data): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_private_header_data): Define.
	* libbfd-in.h (_bfd_generic_bfd_copy_private_header_data): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_private_header_data): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_private_header_data): Define.
	* mmo.c (mmo_bfd_copy_private_header_data): Define.
	* ppcboot.c (ppcboot_bfd_copy_private_header_data): Define.
	* som.c (som_bfd_copy_private_header_data): Define.
	* targets.c (BFD_JUMP_TABLE_COPY): Add _bfd_copy_private_header_data.
	* vms.c (vms_bfd_copy_private_header_data): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d4135 1
a4135 1
      internal_a.tsize = bfd_get_section_size_before_reloc (text_sec);
d4140 1
a4140 1
      internal_a.dsize = bfd_get_section_size_before_reloc (data_sec);
d4145 1
a4145 1
      internal_a.bsize = bfd_get_section_size_before_reloc (bss_sec);
@


1.104
log
@* coffcode.h (coff_write_object_contents) [COFF_IMAGE_WITH_PE]:
Propagate IMAGE_FILE_LARGE_ADDRESS_AWARE.
* peXXigen.c (_bfd_XX_print_private_bfd_data_common): Recognize
IMAGE_FILE_LARGE_ADDRESS_AWARE.  Use PE defines.
@
text
@d5514 4
@


1.103
log
@	* section.c (bfd_make_section_anyway): Add all sections to hash tab.

	* elf-bfd.h (bfd_elf_is_group_section): Declare.
	* elf.c (bfd_elf_is_group_section): New function.
	* elfxx-target.h (bfd_elfNN_bfd_is_group_section
	* section.c (bfd_generic_is_group_section): New function.
	* targets.c (struct bfd_target): Add _bfd_is_group_section field.
	(BFD_JUMP_TABLE_LINK): Adjust.
	* aout-adobe.c (aout_32_bfd_is_group_section): Define.
	* aout-target.h (MY_bfd_is_group_section): Define.
	* aout-tic30.c (MY_bfd_is_group_section): Define.
	* bfd.c (bfd_is_group_section): Define.
	* binary.c (binary_bfd_is_group_section): Define.
	* bout.c (b_out_bfd_is_group_section): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-mips.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Adjust.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Adjust.
	* coffcode.h (coff_bfd_is_group_section): Define.
	* i386msdos.c (msdos_bfd_is_group_section): Define.
	* i386os9k.c (os9k_bfd_is_group_section): Define.
	* ieee.c (ieee_bfd_is_group_section): Define.
	* ihex.c (ihex_bfd_is_group_section): Define.
	* libbfd-in.h (_bfd_nolink_bfd_is_group_section): Define.
	* mach-o.c (bfd_mach_o_bfd_is_group_section): Define.
	* mmo.c (mmo_bfd_is_group_section): Define.
	* nlm-target.h (nlm_bfd_is_group_section): Define.
	* oasys.c (oasys_bfd_is_group_section): Define.
	* pef.c (bfd_pef_bfd_is_group_section): Define.
	* ppcboot.c (ppcboot_bfd_is_group_section): Define.
	* srec.c (srec_bfd_is_group_section): Define.
	* tekhex.c (tekhex_bfd_is_group_section): Define.
	* versados.c (versados_bfd_is_group_section): Define.
	* vms.c (vms_bfd_is_group_section): Define.
	* xsym.c (bfd_sym_bfd_is_group_section): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d3897 2
@


1.102
log
@Add support for generating DWARF2 debug sections in the x86 PE port
@
text
@d5567 4
@


1.101
log
@Do not mark .reloc sections as containing debug info.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d312 3
d434 1
a434 1
  else if (!strncmp (sec_name, ".debug", 6))
d447 1
a447 1
  else if (!strncmp (sec_name, ".gnu.linkonce.wi.", 17))
d524 1
a524 1
     const char *sec_name ATTRIBUTE_UNUSED;
d537 5
d686 1
a686 1
  else if (strncmp (name, ".debug", 6) == 0
d691 1
a691 1
	   || strncmp (name, ".gnu.linkonce.wi.", 17) == 0
d3015 1
a3015 1
	  dsec = bfd_make_section_old_way (abfd, ".debug");
@


1.101.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
a311 3
#define DOT_DEBUG	".debug"
#define GNU_LINKONCE_WI ".gnu.linkonce.wi."

d431 1
a431 1
  else if (!strncmp (sec_name, DOT_DEBUG, sizeof (DOT_DEBUG) - 1))
d444 1
a444 1
  else if (!strncmp (sec_name, GNU_LINKONCE_WI, sizeof (GNU_LINKONCE_WI) - 1))
d521 1
a521 1
     const char *sec_name;
a533 5
  /* FIXME: There is no gas syntax to specify the debug section flag.  */
  if (strncmp (sec_name, DOT_DEBUG, sizeof (DOT_DEBUG) - 1) == 0
      || strncmp (sec_name, GNU_LINKONCE_WI, sizeof (GNU_LINKONCE_WI) - 1) == 0)
    sec_flags = SEC_READONLY | SEC_DEBUGGING;

d678 1
a678 1
  else if (strncmp (name, DOT_DEBUG, sizeof (DOT_DEBUG) - 1) == 0
d683 1
a683 1
	   || strncmp (name, GNU_LINKONCE_WI, sizeof (GNU_LINKONCE_WI) - 1) == 0
d824 2
d853 1
a853 4
		  _bfd_error_handler (_("%B: warning: COMDAT symbol '%s' does not match section name '%s'"),
				      abfd, symname, name);

		seen_state = 1;
d960 3
a962 4
		amt = sizeof (struct coff_comdat_info);
		coff_section_data (abfd, section)->comdat
		  = bfd_alloc (abfd, amt);
		if (coff_section_data (abfd, section)->comdat == NULL)
d965 1
a965 1
		coff_section_data (abfd, section)->comdat->symbol =
d974 1
a974 2
		coff_section_data (abfd, section)->comdat->name
		  = newname;
a1057 1
#if 0
a1058 7
#else
	  /* Generate a warning message rather using the 'unhandled'
	     variable as this will allow some .sys files generate by
	     other toolchains to be processed.  See bugzilla issue 196.  */
	  _bfd_error_handler (_("%B: Warning: Ignoring section flag IMAGE_SCN_MEM_NOT_PAGED in section %s"),
			      abfd, name);
#endif
d1112 2
a1113 2
	    (_("%B (%s): Section flag %s (0x%x) ignored"),
	     abfd, name, unhandled, flag);
d3007 1
a3007 1
	  dsec = bfd_make_section_old_way (abfd, DOT_DEBUG);
d3010 1
a3010 1
	  dsec->size = sz;
d3109 1
a3109 1
	if (current->size == 0)
d3160 1
a3160 1
	pei_section_data (abfd, current)->virt_size = current->size;
d3169 1
a3169 1
      if (current->size == 0)
d3217 1
a3217 1
	    previous->size += sofar - old_sofar;
d3233 1
a3233 1
      current->size = (current->size + page_size -1) & -page_size;
d3236 1
a3236 1
      sofar += current->size;
d3244 5
a3248 5
	  old_size = current->size;
	  current->size = BFD_ALIGN (current->size,
				     1 << current->alignment_power);
	  align_adjust = current->size != old_size;
	  sofar += current->size - old_size;
d3255 1
a3255 1
	  current->size += sofar - old_sofar;
d3261 3
a3263 3
         size, in case the caller only writes out data to the
         unaligned size.  */
      if (pei_section_data (abfd, current)->virt_size < current->size)
d3635 1
a3635 1
      section.s_size =  current->size;
d3654 2
a3655 2
      if (current->size == 0
	  || (current->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
a3888 2
  if (pe_data (abfd)->real_flags & IMAGE_FILE_LARGE_ADDRESS_AWARE)
    internal_f.f_flags |= IMAGE_FILE_LARGE_ADDRESS_AWARE;
d4125 1
a4125 1
      internal_a.tsize = text_sec->size;
d4130 1
a4130 1
      internal_a.dsize = data_sec->size;
d4135 1
a4135 1
      internal_a.bsize = bss_sec->size;
d4428 2
a4429 1
        (_("%B: warning: line number table read failed"), abfd);
d4461 2
a4462 2
		    (_("%B: warning: illegal symbol index %ld in line numbers"),
		     abfd, dst.l_addr.l_symndx);
d4475 3
a4477 2
		    (_("%B: warning: duplicate line number information for `%s'"),
		     abfd, bfd_asymbol_name (&sym->symbol));
d4831 2
a4832 2
		(_("%B: Unrecognized storage class %d for %s symbol `%s'"),
		 abfd, src->u.syment.n_sclass,
d4964 3
a4966 2
	(_("warning: %B: local symbol `%s' has no section"),
	 abfd, _bfd_coff_internal_syment_name (abfd, syment, buf));
d5071 2
a5072 2
		(_("%B: warning: illegal symbol index %ld in relocs"),
		 abfd, dst.r_symndx);
d5109 2
a5110 2
	    (_("%B: illegal relocation type %d at address 0x%lx"),
	     abfd, dst.r_type, (long) dst.r_vaddr);
a5503 4
#ifndef coff_bfd_copy_private_header_data
#define coff_bfd_copy_private_header_data   _bfd_generic_bfd_copy_private_header_data
#endif

a5558 4
#ifndef coff_bfd_is_group_section
#define coff_bfd_is_group_section	    bfd_generic_is_group_section
#endif

a5562 5
#ifndef coff_section_already_linked
#define coff_section_already_linked \
  _bfd_generic_section_already_linked
#endif

@


1.100
log
@Set page_size to 1 instead of 0 in the case file alignment value is zero.
@
text
@d1067 5
a1071 1
	  sec_flags |= SEC_DEBUGGING;
@


1.99
log
@	* coff-rs6000.c: Remove ARGSUSED and VARARGS.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* elf32-vax.c: Likewise.
	* hash.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* ihex.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* pdp11.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* section.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
@
text
@d3017 5
@


1.98
log
@	* aix5ppc-core.c: Fix comment typos.
	* aout-arm.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd.c: Likewise.
	* bfdio.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-z8k.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* cofflink.c: Likewise.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* dwarf2.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@a5124 1
/*ARGSUSED*/
@


1.97
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d1575 1
a1575 1
     symbol information, since they'll be overriden by the BFD symbol
d4684 1
a4684 1
              /* C_AUTOARG conflictes with TI COFF C_UEXT.  */
@


1.96
log
@	* coffcode.h (coff_set_alignment_hook): With PE_COFF reloc
	overflow, set reloc start position to after the count
	reloc. Subtract one from num relocs. Give error on 0xffff relocs
	and no overflow.
	* cofflink.c (_bfd_coff_final_link): Deal with PE_COFF reloc
	overflow.
	* peXXigen.c (_bfd_XXi_swap_scnhdr_out): Do overflow if >=
	0xffff.
@
text
@d336 1
a336 1
  PARAMS ((bfd *, asection *, PTR, file_ptr, bfd_size_type));
d4274 1
a4274 1
     PTR location;
@


1.95
log
@Detect and issue a warning message if the line number table could not be read.
@
text
@d1697 2
d1700 1
a1700 2
      if (bfd_bread ((PTR) &dst, (bfd_size_type) bfd_coff_relsz (abfd), abfd)
	  != bfd_coff_relsz (abfd))
d1705 2
a1706 1
      section->reloc_count = hdr->s_nreloc = n.r_vaddr;
d1708 4
@


1.94
log
@Add C_TCSYM and C_ECOML to expected RS6000 storage classes.
@
text
@d4410 7
@


1.93
log
@Set the IMAGE_FILE_32BIT_MACHINE flag for PE targets.
@
text
@d4698 1
d4700 1
@


1.92
log
@Moved the ticoff0/1 swaptables and coff0/1 bad format hooks to coffcode.h
@
text
@d3876 3
a3878 1
#ifndef COFF_WITH_PE
@


1.91
log
@Altered the CREATE_xxx_COFF_TARGET_VEC macro arguments
@
text
@d365 6
d1448 30
d5376 86
@


1.90
log
@Add support for h8300hn and h8300sn
@
text
@d5416 1
a5416 1
#define CREATE_BIG_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE)	\
d5463 1
a5463 1
  COFF_SWAP_TABLE							\
d5466 51
a5516 1
#define CREATE_LITTLE_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE)	\
d5561 1
a5561 1
  COFF_SWAP_TABLE							\
@


1.89
log
@Fixes for iWMMXt contribution.
@
text
@d2074 1
a2074 1
      /* !! FIXME this probably isn't the right place for this */
d2083 1
a2083 1
      /* !! FIXME this probably isn't the right place for this */
d2092 19
a2110 1
      /* !! FIXME this probably isn't the right place for this */
d2759 6
@


1.89.6.1
log
@Merge from mainline.
@
text
@d2074 1
a2074 1
      /* !! FIXME this probably isn't the right place for this.  */
d2083 1
a2083 1
      /* !! FIXME this probably isn't the right place for this.  */
d2092 1
a2092 19
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef H8300HNMAGIC
    case H8300HNMAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300hn;
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef H8300SNMAGIC
    case H8300SNMAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300sn;
      /* !! FIXME this probably isn't the right place for this.  */
a2740 6
	  return TRUE;
	case bfd_mach_h8300hn:
	  *magicp = H8300HNMAGIC;
	  return TRUE;
	case bfd_mach_h8300sn:
	  *magicp = H8300SNMAGIC;
@


1.88
log
@Add iWMMXt support
@
text
@d1886 2
a1887 1
      switch (internal_f->f_flags & F_ARM_ARCHITECTURE_MASK)
d1889 16
a1904 13
        case F_ARM_2:  machine = bfd_mach_arm_2;  break;
        case F_ARM_2a: machine = bfd_mach_arm_2a; break;
        case F_ARM_3:  machine = bfd_mach_arm_3;  break;
        default:
        case F_ARM_3M: machine = bfd_mach_arm_3M; break;
        case F_ARM_4:  machine = bfd_mach_arm_4;  break;
        case F_ARM_4T: machine = bfd_mach_arm_4T; break;
	  /* The COFF header does not have enough bits available
	     to cover all the different ARM architectures.  So
	     we interpret F_ARM_5, the highest flag value to mean
	     "the highest ARM architecture known to BFD" which is
	     currently the XScale.  */
        case F_ARM_5:  machine = bfd_mach_arm_XScale;  break;
a1905 21

      {
	asection * arm_arch_section;
  
	arm_arch_section = bfd_get_section_by_name (abfd, ".note");

	if (arm_arch_section)
	  {
	    bfd_byte buffer [4];

	    if (! bfd_get_section_contents (abfd, arm_arch_section, buffer,
					    (file_ptr) 0, sizeof buffer))
	      (*_bfd_error_handler)
		(_("%s: warning: unable to retrieve .note section from %s"),
		 bfd_get_filename (abfd));
	      
	    /* We have to extract the value this way to allow for a
	       host whose endian-ness is different from the target.  */
	    machine = bfd_get_32 (abfd, buffer);
	  }
      }
@


1.87
log
@Change embedded documentation to use consistent indentation and to split up
long lines.  Change informal style of description for functions lacking real
documentation.
@
text
@d1902 21
@


1.86
log
@Updates for fixing tic4x arch tagging of its object files.

	* bfd/coffcode.h (coff_set_flags): Added get/set arch hooks.
	* include/coff/tic4x.h (TICOFF_TARGET_MACHINE_GET): Fixed define bug
	* include/coff/ti.h (TICOFF_TARGET_MACHINE_GET): Added macros
	* ld/Makefile.am: Added etic3xcoff.o and etic4xcoff_onchip.o
	* ld/Makefile.in: Regenerate
	* ld/configure.tgt: Added extra target emulations
	* ld/emulparams/tic3xcoff.sh: Remove old settings
	* ld/emulparams/tic4xcoff.sh: Ditto
	* ld/emulparams/tic3xcoff-onchip.sh: Added new
	* ld/scripttempl/tic4xcoff.sc: Revise and combine both c3x and c4x
	* ld/scripttempl/tic3xcoff.sc: Remove
@
text
@d3 1
a3 1
   2000, 2001, 2002
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d228 1
a228 1
	structured hierachy required by coff. It changes each pointer
d561 1
a561 1
     are retained in pei_section_data(abfd, section)->pe_flags */
d563 1
a563 1
  styp_flags |= IMAGE_SCN_MEM_READ;       /* always readable.  */
d565 1
a565 1
    styp_flags |= IMAGE_SCN_MEM_WRITE;    /* Invert READONLY for write */
d567 1
a567 1
    styp_flags |= IMAGE_SCN_MEM_EXECUTE;  /* CODE->EXECUTE */
d569 1
a569 1
    styp_flags |= IMAGE_SCN_MEM_SHARED;   /* Shared remains meaningful */
d696 1
a696 1
#ifdef STYP_LIT			/* A29k readonly text/data section type */
d701 1
a701 1
#ifdef STYP_OTHER_LOAD		/* Other loaded sections */
d805 1
a805 1
	  /* All 3 branches use this */
d933 1
a933 1
	      /* Is this the name we're looking for? */
d1347 2
a1348 1
.  ((coff_backend_info (abfd)->_bfd_coff_mkobject_hook) (abfd, filehdr, aouthdr))
d1373 2
a1374 1
.#define bfd_coff_reloc16_extra_cases(abfd, link_info, link_order, reloc, data, src_ptr, dst_ptr)\
d1402 2
a1403 1
.#define bfd_coff_link_add_one_symbol(info,abfd,name,flags,section,value,string,cp,coll,hashp)\
d1426 1
a1426 1
  /* if the optional header is NULL or not the correct size then
d1432 1
a1432 2
     when doing that
     */
d1458 1
d1572 1
a1572 1
  /* Extract ALIGN from 2**ALIGN stored in section header */
d1578 1
a1578 1
  /* TI tools puts the alignment power in bits 8-11 */
d1594 1
a1594 1
/* a couple of macros to help setting the alignment power field */
d1655 1
a1655 1
  /* check for extended relocs */
d1751 1
d2132 1
a2132 1
      /* this TI COFF section should be used by all new TI COFF v0 targets */
d2141 2
a2142 2
      /* this TI COFF section should be used by all new TI COFF v1/2 targets */
      /* TI COFF1 and COFF2 use the target_id field to specify which arch */
d2181 1
a2181 1
    default:			/* Unreadable input file type */
a2221 1
/*ARGSUSED*/
a2260 1
/*ARGSUSED*/
d2365 1
a2365 1
/* AUX's ld wants relocations to be sorted */
d2398 1
a2398 1
	/* sort relocations before we write them out */
d2417 1
a2417 1
	  /* encode real count here as first reloc */
d2419 1
d2421 1
a2421 1
	  /* add one to count *this* reloc (grr) */
d2434 1
d2452 1
d2456 1
d2458 1
a2458 1
		    /* got a hit, so repoint the reloc */
d2501 1
a2501 1
	  /* Work out reloc type from what is required */
d2507 1
d2603 1
a2603 1
      /* if there's no indication of which version we want, use the default */
d2608 1
a2608 1
          /* we may want to output in a different COFF version */
d3101 2
a3102 2
	  /* make sure this section is aligned on the right boundary - by
	     padding the previous section up if necessary */
d3138 1
a3138 3
	    {
	      previous->_raw_size += sofar - old_sofar;
	    }
d3160 1
a3160 1
      /* make sure that this section is of the right size too */
d3249 1
d3252 2
a3253 2
	  /* only do this if there is a coff representation of the input
	   symbol */
d3287 1
d3289 3
a3291 4
    {
      /* @@@@ Generate fake .file symbol, in sympp2[i], and increment i.  */
      abort ();
    }
d3428 1
a3428 1
     put them into the correct asections */
d3440 1
a3440 1
  /* Work out the size of the reloc and linno areas */
d3446 1
a3446 1
      /* we store the actual reloc count in the first reloc's addr */
d3458 1
a3458 1
  /* Indicate in each section->line_filepos its actual file address */
d3477 1
a3477 1
	  /* extra reloc to hold real count */
d3573 2
a3574 4
      /*
	 If this section has no size or is unloadable then the scnptr
	 will be 0 too
	 */
d3577 1
a3577 3
	{
	  section.s_scnptr = 0;
	}
d3579 2
a3580 3
	{
	  section.s_scnptr = current->filepos;
	}
d3610 1
a3610 3
	{
	  text_sec = current;
	}
d3612 1
a3612 3
	{
	  data_sec = current;
	}
d3614 1
a3614 3
	{
	  bss_sec = current;
	}
d3622 1
a3622 1
      /* TI COFF puts the alignment power in bits 8-11 of the flags */
d3779 1
a3779 2
  /*
     We will NOT put a fucking timestamp in the header here. Every time you
d3782 1
a3782 2
     same but is not a reasonable time. -- gnu@@cygnus.com
     */
a3783 1

d3820 2
a3821 2
  /* target id is used in TI COFF v1 and later; COFF0 won't use this field,
     but it doesn't hurt to set it internally */
d3828 2
a3829 4
  /*
     FIXME, should do something about the other byte orders and
     architectures.
     */
d3840 1
a3840 2
  /* Set up architecture-dependent stuff */

d3844 1
d3853 2
a3854 3
     * is a .shbss or a .shdata section, if so then set the magic
     * number to indicate a shared data executable.
     */
d3856 1
a3856 1
      internal_a.magic = SHMAGIC; /* Shared magic */
d3859 1
a3859 1
      internal_a.magic = NMAGIC; /* Assume separate i/d */
d3974 1
a3974 1
  /* Now should write relocs, strings, syms */
d4157 1
a4157 1
	 include/coff/pe.h sets AOUTSZ == sizeof (PEAOUTHDR)) */
d4206 1
a4206 1
  if (! abfd->output_has_begun)	/* set by bfd.c handler */
d4233 1
a4233 1
      Gvran Uddeborg <gvran@@uddeborg.pp.se> */
d4357 1
a4422 1

d4428 1
a4428 1
  /* Read in the symbol table */
d4430 1
a4430 3
    {
      return FALSE;
    }				/* on error */
d4432 1
a4432 1
  /* Allocate enough room for all the symbols in cached form */
d4450 1
d4474 1
a4474 2
	      /* Fall through to next case */

d4487 1
a4487 1
	    case C_SYSTEM:	/* System Wide variable */
d4490 1
a4490 1
            /* In PE, 0x68 (104) denotes a section symbol */
d4564 1
a4564 1
	    case C_STAT:	/* static			 */
d4566 1
a4566 1
	    case C_LEAFSTAT:	/* static leaf procedure        */
d4569 3
a4571 3
            case C_THUMBSTAT:   /* Thumb static                  */
            case C_THUMBLABEL:  /* Thumb label                   */
            case C_THUMBSTATFUNC:/* Thumb static function        */
d4573 1
a4573 1
	    case C_LABEL:	/* label			 */
d4596 3
a4598 3
	    case C_MOS:	/* member of structure	 */
	    case C_EOS:	/* end of structure		 */
#ifdef NOTDEF			/* C_AUTOARG has the same value */
d4600 1
a4600 1
	    case C_GLBLREG:	/* A29k-specific storage class */
d4603 3
a4605 3
	    case C_REGPARM:	/* register parameter		 */
	    case C_REG:	/* register variable		 */
              /* C_AUTOARG conflictes with TI COFF C_UEXT */
d4608 1
a4608 1
	    case C_AUTOARG:	/* 960-specific storage class */
d4611 1
a4611 1
	    case C_TPDEF:	/* type definition		 */
d4613 6
a4618 6
	    case C_AUTO:	/* automatic variable */
	    case C_FIELD:	/* bit field */
	    case C_ENTAG:	/* enumeration tag		 */
	    case C_MOE:	/* member of enumeration	 */
	    case C_MOU:	/* member of union		 */
	    case C_UNTAG:	/* union tag			 */
d4623 2
a4624 2
	    case C_FILE:	/* file name			 */
	    case C_STRTAG:	/* structure tag		 */
d4644 2
a4645 2
	    case C_BINCL:	/* beginning of include file     */
	    case C_EINCL:	/* ending of include file        */
d4686 3
a4688 3
	    case C_BLOCK:	/* ".bb" or ".eb"		 */
	    case C_FCN:		/* ".bf" or ".ef" (or PE ".lf")  */
	    case C_EFCN:	/* physical end of function	 */
d4710 1
a4710 1
	    case C_STATLAB:	/* Static load time label */
d4723 3
a4725 3
	    case C_EXTDEF:	/* external definition		 */
	    case C_ULABEL:	/* undefined label		 */
	    case C_USTATIC:	/* undefined static		 */
d4728 2
a4729 2
               class to represent a section symbol */
	    case C_LINE:	/* line # reformatted as symbol table entry */
d4731 1
a4731 1
	    case C_ALIAS:	/* duplicate tag		 */
d4733 1
a4733 1
	      /* New storage classes for TI COFF */
d4735 1
a4735 1
	    case C_UEXT:	/* Tentative external definition */
d4737 2
a4738 2
	    case C_EXTLAB:	/* External load time label */
	    case C_HIDDEN:	/* ext symbol in dmert public lib */
d4758 2
a4759 2
	}			/* walk the native symtab */
    }				/* bfdize the native symtab */
d4766 1
a4766 1
  /* Slurp the line tables for each section too */
d4769 1
d4777 1
d5004 1
a5004 1
	 Note that symbols which used to be common must be left alone */
d5006 1
a5006 1
      /* Calculate any reloc addend by looking at the symbol */
d5012 1
a5012 1
      /* Fill in the cache_ptr->howto field from dst.r_type */
d5080 3
a5082 3
      /* this section has relocs made up by us, they are not in the
       file, so take them out of their chain and place them into
       the data area provided */
d5084 1
a5089 1

@


1.85
log
@	* coff-h8300.c: Fix comment typos.
	* coffcode.h: Likewise.
	* cpu-cris.c: Likewise.
	* elf32-vax.c: Likewise.
	* genlink.h: Likewise.
	* linker.c: Likewise.
	* som.c: Likewise.
	* tekhex.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d2131 1
d2146 1
d2617 1
@


1.84
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3098 1
a3098 1
	     AIX executables, this check fails. This shows up when an native
@


1.83
log
@	* coffcode.h: Remove extraneous '\'.
@
text
@d299 1
a299 1
.  boolean done_lineno;
d312 3
a314 2
static long sec_to_styp_flags PARAMS ((const char *, flagword));
static boolean styp_to_sec_flags
d316 2
a317 1
static boolean coff_bad_format_hook PARAMS ((bfd *, PTR));
d321 7
a327 4
static boolean coff_new_section_hook PARAMS ((bfd *, asection *));
static boolean coff_set_arch_mach_hook PARAMS ((bfd *, PTR));
static boolean coff_write_relocs PARAMS ((bfd *, int));
static boolean coff_set_flags
d329 1
a329 1
static boolean coff_set_arch_mach
d331 5
a335 3
static boolean coff_compute_section_file_positions PARAMS ((bfd *));
static boolean coff_write_object_contents PARAMS ((bfd *)) ATTRIBUTE_UNUSED;
static boolean coff_set_section_contents
d337 6
a342 3
static PTR buy_and_read PARAMS ((bfd *, file_ptr, bfd_size_type));
static boolean coff_slurp_line_table PARAMS ((bfd *, asection *));
static boolean coff_slurp_symbol_table PARAMS ((bfd *));
d345 2
a346 1
static boolean coff_slurp_reloc_table PARAMS ((bfd *, asection *, asymbol **));
d350 2
a351 1
static PTR coff_mkobject_hook PARAMS ((bfd *, PTR,  PTR));
d354 2
a355 1
static flagword handle_COMDAT PARAMS ((bfd *, flagword, PTR, const char *, asection *));
d358 6
a363 3
static boolean coff_read_word PARAMS ((bfd *, unsigned int *));
static unsigned int coff_compute_checksum PARAMS ((bfd *));
static boolean coff_apply_checksum PARAMS ((bfd *));
d583 1
a583 1
static boolean
d718 1
a718 1
    return false;
d721 1
a721 1
  return true;
d992 1
a992 1
static boolean
d1003 1
a1003 1
  boolean result = true;
d1104 1
a1104 1
	  result = false;
d1192 2
a1193 2
.  boolean _bfd_coff_long_filenames;
.  boolean _bfd_coff_long_section_names;
d1195 1
a1195 1
.  boolean _bfd_coff_force_symnames_in_strings;
d1210 1
a1210 1
.  boolean (*_bfd_coff_bad_format_hook)
d1213 1
a1213 1
.  boolean (*_bfd_coff_set_arch_mach_hook)
d1219 1
a1219 1
.  boolean (*_bfd_styp_to_sec_flags_hook)
d1225 1
a1225 1
.  boolean (*_bfd_coff_slurp_symbol_table)
d1228 1
a1228 1
.  boolean (*_bfd_coff_symname_in_debug)
d1231 1
a1231 1
.  boolean (*_bfd_coff_pointerize_aux_hook)
d1235 1
a1235 1
.  boolean (*_bfd_coff_print_aux)
d1250 1
a1250 1
.  boolean (*_bfd_coff_compute_section_file_positions)
d1253 1
a1253 1
.  boolean (*_bfd_coff_start_final_link)
d1256 1
a1256 1
.  boolean (*_bfd_coff_relocate_section)
d1265 1
a1265 1
.  boolean (*_bfd_coff_adjust_symndx)
d1267 1
a1267 1
.	     struct internal_reloc *, boolean *));
d1269 1
a1269 1
.  boolean (*_bfd_coff_link_add_one_symbol)
d1271 1
a1271 1
.	     asection *, bfd_vma, const char *, boolean, boolean,
d1274 1
a1274 1
.  boolean (*_bfd_coff_link_output_has_begun)
d1277 1
a1277 1
.  boolean (*_bfd_coff_final_link_postscript)
d1413 1
a1413 1
static boolean
d1421 1
a1421 1
    return false;
d1434 1
a1434 1
    return false;
d1437 1
a1437 1
  return true;
d1506 1
a1506 1
static boolean
d1533 1
a1533 1
    return false;
d1550 1
a1550 1
  return true;
d1722 1
a1722 1
static boolean coff_mkobject PARAMS ((bfd *));
d1724 1
a1724 1
static boolean
d1733 1
a1733 1
    return false;
d1743 1
a1743 1
  return true;
d1797 1
a1797 1
      xcoff->full_aouthdr = true;
d1834 1
a1834 1
static boolean
d1936 1
a1936 1
	  return false;
d2015 1
a2015 1
		    return false;
d2181 1
a2181 1
  return true;
d2186 1
a2186 1
static boolean symname_in_debug_hook
d2189 1
a2189 1
static boolean
d2200 1
a2200 1
  (boolean (*) PARAMS ((bfd *, struct internal_syment *))) bfd_false
d2212 1
a2212 1
static boolean coff_pointerize_aux_hook
d2217 1
a2217 1
static boolean
d2237 1
a2237 1
      /* Return true to indicate that the caller should not do any
d2239 1
a2239 1
      return true;
d2242 1
a2242 1
  /* Return false to indicate that this auxent should be handled by
d2244 1
a2244 1
  return false;
d2252 1
a2252 1
static boolean coff_pointerize_aux_hook
d2257 1
a2257 1
static boolean
d2265 1
a2265 1
  /* Return true if we don't want to pointerize this aux entry, which
d2280 1
a2280 1
/* Print an aux entry.  This returns true if it has printed it.  */
d2282 1
a2282 1
static boolean coff_print_aux
d2286 1
a2286 1
static boolean
d2333 1
a2333 1
      return true;
d2337 2
a2338 2
  /* Return false to indicate that no special action was taken.  */
  return false;
d2377 1
a2377 1
static boolean
d2401 1
a2401 1
	  return false;
d2408 1
a2408 1
	return false;
d2421 1
a2421 1
	    return false;
d2501 1
a2501 1
	    return false;
d2510 1
a2510 1
  return true;
d2514 1
a2514 1
   type.  Result is true if we can represent the arch&type, false if not.  */
d2516 1
a2516 1
static boolean
d2536 1
a2536 1
	  return false;
d2538 1
a2538 1
      return true;
d2578 1
a2578 1
	    return false;
d2581 1
a2581 1
	return true;
d2589 1
a2589 1
      return true;
d2612 1
a2612 1
              return false;
d2615 1
a2615 1
      return true;
d2621 1
a2621 1
      return true;
d2659 1
a2659 1
      return true;
d2664 1
a2664 1
      return true;
d2674 1
a2674 1
      return true;
d2680 1
a2680 1
      return true;
d2686 1
a2686 1
      return true;
d2705 1
a2705 1
      return true;
d2712 1
a2712 1
      return true;
d2721 1
a2721 1
	  return true;
d2724 1
a2724 1
	  return true;
d2727 1
a2727 1
	  return true;
d2742 1
a2742 1
      return true;
d2749 1
a2749 1
      return true;
d2760 1
a2760 1
      return true;
d2767 1
a2767 1
      return true;
d2776 1
a2776 1
      return true;
d2783 1
a2783 1
      return true;
d2794 1
a2794 1
      return true;
d2801 1
a2801 1
      return true;
d2807 1
a2807 1
      return true;
d2816 1
a2816 1
      return true;
d2820 1
a2820 1
      /* Fall through to "return false" below, to avoid
d2825 1
a2825 1
  return false;
d2828 1
a2828 1
static boolean
d2838 1
a2838 1
    return false;
d2842 1
a2842 1
    return false;		/* We can't represent this type */
d2844 1
a2844 1
  return true;			/* We're easy ...  */
d2881 1
a2881 1
static boolean
d2888 1
a2888 1
  boolean align_adjust;
d2994 1
a2994 1
      return false;
d3047 1
a3047 1
  align_adjust = false;
d3060 1
a3060 1
	    return false;
d3068 1
a3068 1
	    return false;
d3098 1
a3098 1
	     AIX executables, this check fails. This shows up when an native 
d3101 1
a3101 1
	     stripped gnu excutable passes this check because the filepos is 
d3104 2
a3105 2
	  if (!strcmp (current->name, _TEXT) 
	      || !strcmp (current->name, _DATA)) 
d3114 2
a3115 2
	      
	      if (pad) 
d3177 1
a3177 1
	align_adjust = true;
d3203 1
a3203 1
	return false;
d3212 1
a3212 1
  abfd->output_has_begun = true;
d3214 1
a3214 1
  return true;
d3226 1
a3226 1
static boolean
d3270 1
a3270 1
    return true;
d3276 1
a3276 1
    return false;
d3291 1
a3291 1
  return true;
d3301 1
a3301 1
static boolean
d3313 1
a3313 1
      return false;
d3323 1
a3323 1
  return true;
d3330 1
a3330 1
  boolean more_data;
d3354 1
a3354 1
static boolean
d3362 1
a3362 1
    return false;
d3365 1
a3365 1
    return false;
d3368 1
a3368 1
    return false;
d3374 1
a3374 1
    return false;
d3381 1
a3381 1
    return false;
d3385 1
a3385 1
  return true;
d3392 1
a3392 1
static boolean
d3397 3
a3399 3
  boolean hasrelocs = false;
  boolean haslinno = false;
  boolean hasdebug = false;
d3406 1
a3406 1
  boolean long_section_names;
d3426 1
a3426 1
	return false;
d3498 1
a3498 1
    return false;
d3500 1
a3500 1
  long_section_names = false;
d3506 1
a3506 1
      boolean is_reloc_section = false;
d3511 2
a3512 2
	  is_reloc_section = true;
	  hasrelocs = true;
d3533 1
a3533 1
	    long_section_names = true;
d3584 1
a3584 1
	hasrelocs = true;
d3587 1
a3587 1
	haslinno = true;
d3590 1
a3590 1
	hasdebug = true;
d3647 1
a3647 1
	    return false;
d3771 1
a3771 1
	    return false;
d3990 1
a3990 1
	return false;
d3993 1
a3993 1
	return false;
d3996 1
a3996 1
	return false;
d3998 1
a3998 1
	return false;
d4000 1
a4000 1
	return false;
d4008 1
a4008 1
	return false;
d4024 1
a4024 1
	return false;
d4143 1
a4143 1
    return false;
d4151 1
a4151 1
      return false;
d4159 1
a4159 1
      return false;
d4171 1
a4171 1
	return false;
d4179 1
a4179 1
	return false;
d4183 1
a4183 1
	return false;
d4199 1
a4199 1
	return false;
d4203 1
a4203 1
  return true;
d4206 1
a4206 1
static boolean
d4217 1
a4217 1
	return false;
d4263 1
a4263 1
    return true;
d4266 1
a4266 1
    return false;
d4269 1
a4269 1
    return true;
d4274 1
a4274 1
static boolean
d4283 1
a4283 1
	  return false;
d4287 1
a4287 1
	  return false;
d4291 1
a4291 1
	return false;
d4295 1
a4295 1
  return true;
d4339 1
a4339 1
static boolean
d4355 1
a4355 1
    return false;
d4370 1
a4370 1
	      boolean warned;
d4374 1
a4374 1
	      warned = false;
d4383 1
a4383 1
		  warned = true;
d4415 1
a4415 1
  return true;
d4422 1
a4422 1
static boolean
d4434 1
a4434 1
    return true;
d4439 1
a4439 1
      return (false);
d4447 1
a4447 1
    return false;
d4454 1
a4454 1
    return false;
d4472 1
a4472 1
	  dst->done_lineno = false;
d4786 1
a4786 1
  return true;
d4938 1
a4938 1
static boolean
d4951 1
a4951 1
    return true;
d4953 1
a4953 1
    return true;
d4955 1
a4955 1
    return true;
d4957 1
a4957 1
    return false;
d4964 1
a4964 1
    return false;
d5030 1
a5030 1
	  return false;
d5035 1
a5035 1
  return true;
d5212 1
a5212 1
static boolean coff_link_output_has_begun
d5215 1
a5215 1
static boolean
d5226 1
a5226 1
static boolean coff_final_link_postscript
d5229 1
a5229 1
static boolean
d5234 1
a5234 1
  return true;
d5290 1
a5290 1
  true,
d5292 1
a5292 1
  false,
d5295 1
a5295 1
  true,
d5297 1
a5297 1
  false,
d5301 1
a5301 1
  true,
d5303 1
a5303 1
  false,
@


1.82
log
@	* ecoff.c (_bfd_ecoff_set_arch_mach_hook): Don't use hard-coded
	bfd_mach constants.
	(ecoff_get_magic): Likewise.
	* elf32-v850.c (v850_elf_object_p): Likewise.
	(v850_elf_final_write_processing): Likewise.
	* mipsbsd.c (MY(set_arch_mach)): Likewise.
	(MY(write_object_contents)): Likewise.
	* coff64-rs6000.c (xcoff64_write_object_contents): Likewise.
	* coffcode.h (coff_write_object_contents): Likewise.
	(coff_set_arch_mach_hook): Add comment describing machine == 0.
	Remove unnecessary "machine" assignments.
	(coff_write_relocs): Test for the absolute section sym by testing
	section and flags.

	* pdp11.c (NAME(aout,machine_type)): Like aoutx.h.
@
text
@d1249 1
a1249 1
.  boolean (*_bfd_coff_adjust_symndx)\
@


1.82.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d228 1
a228 1
	structured hierarchy required by coff. It changes each pointer
d299 1
a299 1
.  bfd_boolean done_lineno;
d312 2
a313 3
static long sec_to_styp_flags
  PARAMS ((const char *, flagword));
static bfd_boolean styp_to_sec_flags
d315 1
a315 2
static bfd_boolean coff_bad_format_hook
  PARAMS ((bfd *, PTR));
d319 4
a322 7
static bfd_boolean coff_new_section_hook
  PARAMS ((bfd *, asection *));
static bfd_boolean coff_set_arch_mach_hook
  PARAMS ((bfd *, PTR));
static bfd_boolean coff_write_relocs
  PARAMS ((bfd *, int));
static bfd_boolean coff_set_flags
d324 1
a324 1
static bfd_boolean coff_set_arch_mach
d326 7
a332 12
static bfd_boolean coff_compute_section_file_positions
  PARAMS ((bfd *));
static bfd_boolean coff_write_object_contents
  PARAMS ((bfd *)) ATTRIBUTE_UNUSED;
static bfd_boolean coff_set_section_contents
  PARAMS ((bfd *, asection *, const PTR, file_ptr, bfd_size_type));
static PTR buy_and_read
  PARAMS ((bfd *, file_ptr, bfd_size_type));
static bfd_boolean coff_slurp_line_table
  PARAMS ((bfd *, asection *));
static bfd_boolean coff_slurp_symbol_table
  PARAMS ((bfd *));
d335 1
a335 2
static bfd_boolean coff_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **));
d339 1
a339 2
static PTR coff_mkobject_hook
  PARAMS ((bfd *, PTR,  PTR));
d342 1
a342 2
static flagword handle_COMDAT
  PARAMS ((bfd *, flagword, PTR, const char *, asection *));
d345 3
a347 12
static bfd_boolean coff_read_word
  PARAMS ((bfd *, unsigned int *));
static unsigned int coff_compute_checksum
  PARAMS ((bfd *));
static bfd_boolean coff_apply_checksum
  PARAMS ((bfd *));
#endif
#ifdef TICOFF
static bfd_boolean ticoff0_bad_format_hook
    PARAMS ((bfd *, PTR ));
static bfd_boolean ticoff1_bad_format_hook
    PARAMS ((bfd *, PTR ));
d545 1
a545 1
     are retained in pei_section_data(abfd, section)->pe_flags.  */
d547 1
a547 1
  styp_flags |= IMAGE_SCN_MEM_READ;       /* Always readable.  */
d549 1
a549 1
    styp_flags |= IMAGE_SCN_MEM_WRITE;    /* Invert READONLY for write.  */
d551 1
a551 1
    styp_flags |= IMAGE_SCN_MEM_EXECUTE;  /* CODE->EXECUTE.  */
d553 1
a553 1
    styp_flags |= IMAGE_SCN_MEM_SHARED;   /* Shared remains meaningful.  */
d567 1
a567 1
static bfd_boolean
d680 1
a680 1
#ifdef STYP_LIT			/* A29k readonly text/data section type.  */
d685 1
a685 1
#ifdef STYP_OTHER_LOAD		/* Other loaded sections.  */
d702 1
a702 1
    return FALSE;
d705 1
a705 1
  return TRUE;
d789 1
a789 1
	  /* All 3 branches use this.  */
d917 1
a917 1
	      /* Is this the name we're looking for ?  */
d976 1
a976 1
static bfd_boolean
d987 1
a987 1
  bfd_boolean result = TRUE;
d1088 1
a1088 1
	  result = FALSE;
d1176 2
a1177 2
.  bfd_boolean _bfd_coff_long_filenames;
.  bfd_boolean _bfd_coff_long_section_names;
d1179 1
a1179 1
.  bfd_boolean _bfd_coff_force_symnames_in_strings;
d1194 1
a1194 1
.  bfd_boolean (*_bfd_coff_bad_format_hook)
d1197 1
a1197 1
.  bfd_boolean (*_bfd_coff_set_arch_mach_hook)
d1203 1
a1203 1
.  bfd_boolean (*_bfd_styp_to_sec_flags_hook)
d1209 1
a1209 1
.  bfd_boolean (*_bfd_coff_slurp_symbol_table)
d1212 1
a1212 1
.  bfd_boolean (*_bfd_coff_symname_in_debug)
d1215 1
a1215 1
.  bfd_boolean (*_bfd_coff_pointerize_aux_hook)
d1219 1
a1219 1
.  bfd_boolean (*_bfd_coff_print_aux)
d1234 1
a1234 1
.  bfd_boolean (*_bfd_coff_compute_section_file_positions)
d1237 1
a1237 1
.  bfd_boolean (*_bfd_coff_start_final_link)
d1240 1
a1240 1
.  bfd_boolean (*_bfd_coff_relocate_section)
d1249 1
a1249 1
.  bfd_boolean (*_bfd_coff_adjust_symndx)
d1251 1
a1251 1
.	     struct internal_reloc *, bfd_boolean *));
d1253 1
a1253 1
.  bfd_boolean (*_bfd_coff_link_add_one_symbol)
d1255 1
a1255 1
.	     asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
d1258 1
a1258 1
.  bfd_boolean (*_bfd_coff_link_output_has_begun)
d1261 1
a1261 1
.  bfd_boolean (*_bfd_coff_final_link_postscript)
d1331 1
a1331 2
.  ((coff_backend_info (abfd)->_bfd_coff_mkobject_hook)\
.   (abfd, filehdr, aouthdr))
d1356 1
a1356 2
.#define bfd_coff_reloc16_extra_cases(abfd, link_info, link_order,\
.                                     reloc, data, src_ptr, dst_ptr)\
d1384 1
a1384 2
.#define bfd_coff_link_add_one_symbol(info, abfd, name, flags, section,\
.                                     value, string, cp, coll, hashp)\
d1397 1
a1397 1
static bfd_boolean
d1405 1
a1405 1
    return FALSE;
d1407 1
a1407 1
  /* If the optional header is NULL or not the correct size then
d1413 2
a1414 1
     when doing that.  */
d1418 1
a1418 1
    return FALSE;
d1421 1
a1421 1
  return TRUE;
a1423 30
#ifdef TICOFF
static bfd_boolean
ticoff0_bad_format_hook (abfd, filehdr)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR filehdr;
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

  if (COFF0_BADMAG (*internal_f))
    return FALSE;

  return TRUE;
}
#endif

#ifdef TICOFF
static bfd_boolean
ticoff1_bad_format_hook (abfd, filehdr)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR filehdr;
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

  if (COFF1_BADMAG (*internal_f))
    return FALSE;

  return TRUE;
}
#endif

a1439 1

d1490 1
a1490 1
static bfd_boolean
d1517 1
a1517 1
    return FALSE;
d1520 1
a1520 1
     symbol information, since they'll be overridden by the BFD symbol
d1534 1
a1534 1
  return TRUE;
d1553 1
a1553 1
  /* Extract ALIGN from 2**ALIGN stored in section header.  */
d1559 1
a1559 1
  /* TI tools puts the alignment power in bits 8-11.  */
d1575 1
a1575 1
/* A couple of macros to help setting the alignment power field.  */
d1636 1
a1636 1
  /* Check for extended relocs.  */
a1641 2
      bfd_size_type relsz = bfd_coff_relsz (abfd);
      
d1643 2
a1644 1
      if (bfd_bread ((PTR) &dst, relsz, abfd) != relsz)
d1649 1
a1649 2
      section->reloc_count = hdr->s_nreloc = n.r_vaddr - 1;
      section->rel_filepos += relsz;
a1650 4
  else if (hdr->s_nreloc == 0xffff)
    (*_bfd_error_handler)
      ("%s: warning: claims to have 0xffff relocs, without overflow",
       bfd_get_filename (abfd));
d1706 1
a1706 1
static bfd_boolean coff_mkobject PARAMS ((bfd *));
d1708 1
a1708 1
static bfd_boolean
d1717 1
a1717 1
    return FALSE;
d1727 1
a1727 1
  return TRUE;
a1731 1

d1781 1
a1781 1
      xcoff->full_aouthdr = TRUE;
d1818 1
a1818 1
static bfd_boolean
d1866 1
a1866 2
      machine = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);
      if (machine == bfd_mach_arm_unknown)
d1868 13
a1880 16
	  switch (internal_f->f_flags & F_ARM_ARCHITECTURE_MASK)
	    {
	    case F_ARM_2:  machine = bfd_mach_arm_2;  break;
	    case F_ARM_2a: machine = bfd_mach_arm_2a; break;
	    case F_ARM_3:  machine = bfd_mach_arm_3;  break;
	    default:
	    case F_ARM_3M: machine = bfd_mach_arm_3M; break;
	    case F_ARM_4:  machine = bfd_mach_arm_4;  break;
	    case F_ARM_4T: machine = bfd_mach_arm_4T; break;
	      /* The COFF header does not have enough bits available
		 to cover all the different ARM architectures.  So
		 we interpret F_ARM_5, the highest flag value to mean
		 "the highest ARM architecture known to BFD" which is
		 currently the XScale.  */
	    case F_ARM_5:  machine = bfd_mach_arm_XScale;  break;
	    }
d1920 1
a1920 1
	  return FALSE;
d1999 1
a1999 1
		    return FALSE;
d2050 1
a2050 1
      /* !! FIXME this probably isn't the right place for this.  */
d2059 1
a2059 1
      /* !! FIXME this probably isn't the right place for this.  */
d2068 1
a2068 19
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef H8300HNMAGIC
    case H8300HNMAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300hn;
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef H8300SNMAGIC
    case H8300SNMAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300sn;
      /* !! FIXME this probably isn't the right place for this.  */
d2112 1
a2112 1
      /* This TI COFF section should be used by all new TI COFF v0 targets.  */
a2114 1
      machine = TICOFF_TARGET_MACHINE_GET (internal_f->f_flags);
d2120 2
a2121 2
      /* This TI COFF section should be used by all new TI COFF v1/2 targets.  */
      /* TI COFF1 and COFF2 use the target_id field to specify which arch.  */
a2128 1
	  machine = TICOFF_TARGET_MACHINE_GET (internal_f->f_flags);
d2159 1
a2159 1
    default:			/* Unreadable input file type.  */
d2165 1
a2165 1
  return TRUE;
d2170 1
a2170 1
static bfd_boolean symname_in_debug_hook
d2173 1
a2173 1
static bfd_boolean
d2184 1
a2184 1
  (bfd_boolean (*) PARAMS ((bfd *, struct internal_syment *))) bfd_false
d2196 1
a2196 1
static bfd_boolean coff_pointerize_aux_hook
d2200 2
a2201 1
static bfd_boolean
d2221 1
a2221 1
      /* Return TRUE to indicate that the caller should not do any
d2223 1
a2223 1
      return TRUE;
d2226 1
a2226 1
  /* Return FALSE to indicate that this auxent should be handled by
d2228 1
a2228 1
  return FALSE;
d2236 1
a2236 1
static bfd_boolean coff_pointerize_aux_hook
d2240 2
a2241 1
static bfd_boolean
d2249 1
a2249 1
  /* Return TRUE if we don't want to pointerize this aux entry, which
d2264 1
a2264 1
/* Print an aux entry.  This returns TRUE if it has printed it.  */
d2266 1
a2266 1
static bfd_boolean coff_print_aux
d2270 1
a2270 1
static bfd_boolean
d2317 1
a2317 1
      return TRUE;
d2321 2
a2322 2
  /* Return FALSE to indicate that no special action was taken.  */
  return FALSE;
d2345 1
a2345 1
/* AUX's ld wants relocations to be sorted.  */
d2361 1
a2361 1
static bfd_boolean
d2378 1
a2378 1
	/* Sort relocations before we write them out.  */
d2385 1
a2385 1
	  return FALSE;
d2392 1
a2392 1
	return FALSE;
d2397 1
a2397 1
	  /* Encode real count here as first reloc.  */
a2398 1

d2400 1
a2400 1
	  /* Add one to count *this* reloc (grr).  */
d2405 1
a2405 1
	    return FALSE;
a2412 1

a2429 1

a2432 1

d2434 1
a2434 1
		    /* Got a hit, so repoint the reloc.  */
d2477 1
a2477 1
	  /* Work out reloc type from what is required.  */
a2482 1

d2485 1
a2485 1
	    return FALSE;
d2494 1
a2494 1
  return TRUE;
d2498 1
a2498 1
   type.  Result is TRUE if we can represent the arch&type, FALSE if not.  */
d2500 1
a2500 1
static bfd_boolean
d2520 1
a2520 1
	  return FALSE;
d2522 1
a2522 1
      return TRUE;
d2562 1
a2562 1
	    return FALSE;
d2565 1
a2565 1
	return TRUE;
d2573 1
a2573 1
      return TRUE;
d2578 1
a2578 1
      /* If there's no indication of which version we want, use the default.  */
d2583 1
a2583 1
          /* We may want to output in a different COFF version.  */
d2596 1
a2596 1
              return FALSE;
d2599 1
a2599 2
      TICOFF_TARGET_MACHINE_SET (flagsp, bfd_get_mach (abfd));
      return TRUE;
d2605 1
a2605 1
      return TRUE;
d2643 1
a2643 1
      return TRUE;
d2648 1
a2648 1
      return TRUE;
d2658 1
a2658 1
      return TRUE;
d2664 1
a2664 1
      return TRUE;
d2670 1
a2670 1
      return TRUE;
d2689 1
a2689 1
      return TRUE;
d2696 1
a2696 1
      return TRUE;
d2705 1
a2705 1
	  return TRUE;
d2708 1
a2708 1
	  return TRUE;
d2711 1
a2711 7
	  return TRUE;
	case bfd_mach_h8300hn:
	  *magicp = H8300HNMAGIC;
	  return TRUE;
	case bfd_mach_h8300sn:
	  *magicp = H8300SNMAGIC;
	  return TRUE;
d2726 1
a2726 1
      return TRUE;
d2733 1
a2733 1
      return TRUE;
d2744 1
a2744 1
      return TRUE;
d2751 1
a2751 1
      return TRUE;
d2760 1
a2760 1
      return TRUE;
d2767 1
a2767 1
      return TRUE;
d2778 1
a2778 1
      return TRUE;
d2785 1
a2785 1
      return TRUE;
d2791 1
a2791 1
      return TRUE;
d2800 1
a2800 1
      return TRUE;
d2804 1
a2804 1
      /* Fall through to "return FALSE" below, to avoid
d2809 1
a2809 1
  return FALSE;
d2812 1
a2812 1
static bfd_boolean
d2822 1
a2822 1
    return FALSE;
d2826 1
a2826 1
    return FALSE;		/* We can't represent this type */
d2828 1
a2828 1
  return TRUE;			/* We're easy ...  */
d2865 1
a2865 1
static bfd_boolean
d2872 1
a2872 1
  bfd_boolean align_adjust;
a2920 5

      /* If no file alignment has been set, default to one.
	 This repairs 'ld -r' for arm-wince-pe target.  */
      if (page_size == 0)
        page_size = 1;
d2978 1
a2978 1
      return FALSE;
d3031 1
a3031 1
  align_adjust = FALSE;
d3044 1
a3044 1
	    return FALSE;
d3052 1
a3052 1
	    return FALSE;
d3075 2
a3076 2
	  /* Make sure this section is aligned on the right boundary - by
	     padding the previous section up if necessary.  */
d3082 1
a3082 1
	     AIX executables, this check fails. This shows up when a native
d3085 1
a3085 1
	     stripped gnu excutable passes this check because the filepos is
d3088 2
a3089 2
	  if (!strcmp (current->name, _TEXT)
	      || !strcmp (current->name, _DATA))
d3098 2
a3099 2

	      if (pad)
d3112 3
a3114 1
	    previous->_raw_size += sofar - old_sofar;
d3136 1
a3136 1
      /* Make sure that this section is of the right size too.  */
d3161 1
a3161 1
	align_adjust = TRUE;
d3187 1
a3187 1
	return FALSE;
d3196 1
a3196 1
  abfd->output_has_begun = TRUE;
d3198 1
a3198 1
  return TRUE;
d3210 1
a3210 1
static bfd_boolean
a3224 1

d3227 2
a3228 2
	  /* Only do this if there is a coff representation of the input
	     symbol.  */
d3254 1
a3254 1
    return TRUE;
d3260 1
a3260 1
    return FALSE;
a3261 1

d3263 4
a3266 3
    /* @@@@ Generate fake .file symbol, in sympp2[i], and increment i.  */
    abort ();

d3275 1
a3275 1
  return TRUE;
d3285 1
a3285 1
static bfd_boolean
d3297 1
a3297 1
      return FALSE;
d3307 1
a3307 1
  return TRUE;
d3314 1
a3314 1
  bfd_boolean more_data;
d3338 1
a3338 1
static bfd_boolean
d3346 1
a3346 1
    return FALSE;
d3349 1
a3349 1
    return FALSE;
d3352 1
a3352 1
    return FALSE;
d3358 1
a3358 1
    return FALSE;
d3365 1
a3365 1
    return FALSE;
d3369 1
a3369 1
  return TRUE;
d3376 1
a3376 1
static bfd_boolean
d3381 3
a3383 3
  bfd_boolean hasrelocs = FALSE;
  bfd_boolean haslinno = FALSE;
  bfd_boolean hasdebug = FALSE;
d3390 1
a3390 1
  bfd_boolean long_section_names;
d3403 1
a3403 1
     put them into the correct asections.  */
d3410 1
a3410 1
	return FALSE;
d3415 1
a3415 1
  /* Work out the size of the reloc and linno areas.  */
d3421 1
a3421 1
      /* We store the actual reloc count in the first reloc's addr.  */
d3433 1
a3433 1
  /* Indicate in each section->line_filepos its actual file address.  */
d3452 1
a3452 1
	  /* Extra reloc to hold real count.  */
d3482 1
a3482 1
    return FALSE;
d3484 1
a3484 1
  long_section_names = FALSE;
d3490 1
a3490 1
      bfd_boolean is_reloc_section = FALSE;
d3495 2
a3496 2
	  is_reloc_section = TRUE;
	  hasrelocs = TRUE;
d3517 1
a3517 1
	    long_section_names = TRUE;
d3548 4
a3551 2
      /* If this section has no size or is unloadable then the scnptr
	 will be 0 too.  */
d3554 3
a3556 1
	section.s_scnptr = 0;
d3558 3
a3560 2
	section.s_scnptr = current->filepos;

d3568 1
a3568 1
	hasrelocs = TRUE;
d3571 1
a3571 1
	haslinno = TRUE;
d3574 1
a3574 1
	hasdebug = TRUE;
d3590 3
a3592 1
	text_sec = current;
d3594 3
a3596 1
	data_sec = current;
d3598 3
a3600 1
	bss_sec = current;
d3608 1
a3608 1
      /* TI COFF puts the alignment power in bits 8-11 of the flags.  */
d3631 1
a3631 1
	    return FALSE;
d3755 1
a3755 1
	    return FALSE;
d3765 2
a3766 1
  /* We will NOT put a fucking timestamp in the header here. Every time you
d3769 2
a3770 1
     same but is not a reasonable time. -- gnu@@cygnus.com  */
d3772 1
d3801 1
a3801 3
#ifdef COFF_WITH_PE
  internal_f.f_flags |= IMAGE_FILE_32BIT_MACHINE;
#else
d3809 2
a3810 2
  /* Target id is used in TI COFF v1 and later; COFF0 won't use this field,
     but it doesn't hurt to set it internally.  */
d3817 4
a3820 2
  /* FIXME, should do something about the other byte orders and
     architectures.  */
d3831 2
a3832 1
  /* Set up architecture-dependent stuff.  */
a3835 1

d3844 3
a3846 2
       is a .shbss or a .shdata section, if so then set the magic
       number to indicate a shared data executable.  */
d3848 1
a3848 1
      internal_a.magic = SHMAGIC; /* Shared magic.  */
d3851 1
a3851 1
      internal_a.magic = NMAGIC; /* Assume separate i/d.  */
d3966 1
a3966 1
  /* Now should write relocs, strings, syms.  */
d3974 1
a3974 1
	return FALSE;
d3977 1
a3977 1
	return FALSE;
d3980 1
a3980 1
	return FALSE;
d3982 1
a3982 1
	return FALSE;
d3984 1
a3984 1
	return FALSE;
d3992 1
a3992 1
	return FALSE;
d4008 1
a4008 1
	return FALSE;
d4127 1
a4127 1
    return FALSE;
d4135 1
a4135 1
      return FALSE;
d4143 1
a4143 1
      return FALSE;
d4149 1
a4149 1
	 include/coff/pe.h sets AOUTSZ == sizeof (PEAOUTHDR)).  */
d4155 1
a4155 1
	return FALSE;
d4163 1
a4163 1
	return FALSE;
d4167 1
a4167 1
	return FALSE;
d4183 1
a4183 1
	return FALSE;
d4187 1
a4187 1
  return TRUE;
d4190 1
a4190 1
static bfd_boolean
d4194 1
a4194 1
     const PTR location;
d4198 1
a4198 1
  if (! abfd->output_has_begun)	/* Set by bfd.c handler.  */
d4201 1
a4201 1
	return FALSE;
d4225 1
a4225 1
      Gvran Uddeborg <gvran@@uddeborg.pp.se>.  */
d4247 1
a4247 1
    return TRUE;
d4250 1
a4250 1
    return FALSE;
d4253 1
a4253 1
    return TRUE;
d4258 1
a4258 1
static bfd_boolean
d4267 1
a4267 1
	  return FALSE;
d4271 1
a4271 1
	  return FALSE;
d4275 1
a4275 1
	return FALSE;
d4279 1
a4279 1
  return TRUE;
d4323 1
a4323 1
static bfd_boolean
a4335 7
  if (native_lineno == NULL)
    {
      (*_bfd_error_handler)
        (_("%s: warning: line number table read failed"),
	 bfd_archive_filename (abfd));
      return FALSE;
    }
d4339 1
a4339 1
    return FALSE;
a4348 1

d4354 1
a4354 1
	      bfd_boolean warned;
d4358 1
a4358 1
	      warned = FALSE;
d4367 1
a4367 1
		  warned = TRUE;
d4399 1
a4399 1
  return TRUE;
d4406 1
a4406 1
static bfd_boolean
d4414 1
d4418 1
a4418 1
    return TRUE;
d4420 1
a4420 1
  /* Read in the symbol table.  */
d4422 3
a4424 1
    return FALSE;
d4426 1
a4426 1
  /* Allocate enough room for all the symbols in cached form.  */
d4431 1
a4431 1
    return FALSE;
d4438 1
a4438 1
    return FALSE;
a4443 1

d4456 1
a4456 1
	  dst->done_lineno = FALSE;
d4467 2
a4468 1
	      /* Fall through to next case.  */
d4481 1
a4481 1
	    case C_SYSTEM:	/* System Wide variable.  */
d4484 1
a4484 1
            /* In PE, 0x68 (104) denotes a section symbol.  */
d4558 1
a4558 1
	    case C_STAT:	 /* Static.  */
d4560 1
a4560 1
	    case C_LEAFSTAT:	 /* Static leaf procedure.  */
d4563 3
a4565 3
            case C_THUMBSTAT:    /* Thumb static.  */
            case C_THUMBLABEL:   /* Thumb label.  */
            case C_THUMBSTATFUNC:/* Thumb static function.  */
d4567 1
a4567 1
	    case C_LABEL:	 /* Label.  */
d4590 3
a4592 3
	    case C_MOS:		/* Member of structure.  */
	    case C_EOS:		/* End of structure.  */
#ifdef NOTDEF			/* C_AUTOARG has the same value.  */
d4594 1
a4594 1
	    case C_GLBLREG:	/* A29k-specific storage class.  */
d4597 3
a4599 3
	    case C_REGPARM:	/* Register parameter.  */
	    case C_REG:		/* register variable.  */
              /* C_AUTOARG conflicts with TI COFF C_UEXT.  */
d4602 1
a4602 1
	    case C_AUTOARG:	/* 960-specific storage class.  */
d4605 1
a4605 1
	    case C_TPDEF:	/* Type definition.  */
d4607 6
a4612 6
	    case C_AUTO:	/* Automatic variable.  */
	    case C_FIELD:	/* Bit field.  */
	    case C_ENTAG:	/* Enumeration tag.  */
	    case C_MOE:		/* Member of enumeration.  */
	    case C_MOU:		/* Member of union.  */
	    case C_UNTAG:	/* Union tag.  */
d4617 2
a4618 2
	    case C_FILE:	/* File name.  */
	    case C_STRTAG:	/* Structure tag.  */
a4625 1
	    case C_TCSYM:
a4626 1
	    case C_ECOML:
d4638 2
a4639 2
	    case C_BINCL:	/* Beginning of include file.  */
	    case C_EINCL:	/* Ending of include file.  */
d4680 3
a4682 3
	    case C_BLOCK:	/* ".bb" or ".eb".  */
	    case C_FCN:		/* ".bf" or ".ef" (or PE ".lf").  */
	    case C_EFCN:	/* Physical end of function.  */
d4704 1
a4704 1
	    case C_STATLAB:	/* Static load time label.  */
d4717 3
a4719 3
	    case C_EXTDEF:	/* External definition.  */
	    case C_ULABEL:	/* Undefined label.  */
	    case C_USTATIC:	/* Undefined static.  */
d4722 2
a4723 2
               class to represent a section symbol.  */
	    case C_LINE:	/* line # reformatted as symbol table entry.  */
d4725 1
a4725 1
	    case C_ALIAS:	/* Duplicate tag.  */
d4727 1
a4727 1
	      /* New storage classes for TI COFF.  */
d4729 1
a4729 1
	    case C_UEXT:	/* Tentative external definition.  */
d4731 2
a4732 2
	    case C_EXTLAB:	/* External load time label.  */
	    case C_HIDDEN:	/* Ext symbol in dmert public lib.  */
d4752 2
a4753 2
	}
    }
d4760 1
a4760 1
  /* Slurp the line tables for each section too.  */
a4762 1

d4770 1
a4770 2

  return TRUE;
d4922 1
a4922 1
static bfd_boolean
d4935 1
a4935 1
    return TRUE;
d4937 1
a4937 1
    return TRUE;
d4939 1
a4939 1
    return TRUE;
d4941 1
a4941 1
    return FALSE;
d4948 1
a4948 1
    return FALSE;
d4996 1
a4996 1
	 Note that symbols which used to be common must be left alone.  */
d4998 1
a4998 1
      /* Calculate any reloc addend by looking at the symbol.  */
d5004 1
a5004 1
      /* Fill in the cache_ptr->howto field from dst.r_type.  */
d5014 1
a5014 1
	  return FALSE;
d5019 1
a5019 1
  return TRUE;
d5036 1
d5072 3
a5074 3
      /* This section has relocs made up by us, they are not in the
	 file, so take them out of their chain and place them into
	 the data area provided.  */
a5075 1

d5081 1
d5196 1
a5196 1
static bfd_boolean coff_link_output_has_begun
d5199 1
a5199 1
static bfd_boolean
d5210 1
a5210 1
static bfd_boolean coff_final_link_postscript
d5213 1
a5213 1
static bfd_boolean
d5218 1
a5218 1
  return TRUE;
d5274 1
a5274 1
  TRUE,
d5276 1
a5276 1
  FALSE,
d5279 1
a5279 1
  TRUE,
d5281 1
a5281 1
  FALSE,
d5285 1
a5285 1
  TRUE,
d5287 1
a5287 1
  FALSE,
a5304 86
#ifdef TICOFF
/* COFF0 differs in file/section header size and relocation entry size.  */
static const bfd_coff_backend_data ticoff0_swap_table =
{
  coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
  coff_SWAP_aux_out, coff_SWAP_sym_out,
  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
  coff_SWAP_filehdr_out, coff_SWAP_aouthdr_out,
  coff_SWAP_scnhdr_out,
  FILHSZ_V0, AOUTSZ, SCNHSZ_V01, SYMESZ, AUXESZ, RELSZ_V0, LINESZ, FILNMLEN,
#ifdef COFF_LONG_FILENAMES
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_LONG_SECTION_NAMES
  TRUE,
#else
  FALSE,
#endif
  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
  4,
#else
  2,
#endif
  coff_SWAP_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
  coff_SWAP_reloc_in, ticoff0_bad_format_hook, coff_set_arch_mach_hook,
  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
  coff_classify_symbol, coff_compute_section_file_positions,
  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
  coff_adjust_symndx, coff_link_add_one_symbol,
  coff_link_output_has_begun, coff_final_link_postscript
};
#endif

#ifdef TICOFF
/* COFF1 differs in section header size.  */
static const bfd_coff_backend_data ticoff1_swap_table =
{
  coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
  coff_SWAP_aux_out, coff_SWAP_sym_out,
  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
  coff_SWAP_filehdr_out, coff_SWAP_aouthdr_out,
  coff_SWAP_scnhdr_out,
  FILHSZ, AOUTSZ, SCNHSZ_V01, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,
#ifdef COFF_LONG_FILENAMES
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_LONG_SECTION_NAMES
  TRUE,
#else
  FALSE,
#endif
  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
  4,
#else
  2,
#endif
  coff_SWAP_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
  coff_SWAP_reloc_in, ticoff1_bad_format_hook, coff_set_arch_mach_hook,
  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
  coff_classify_symbol, coff_compute_section_file_positions,
  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
  coff_adjust_symndx, coff_link_add_one_symbol,
  coff_link_output_has_begun, coff_final_link_postscript
};
#endif

d5380 1
a5380 1
#define CREATE_BIG_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
d5427 1
a5427 51
  SWAP_TABLE								\
};

#define CREATE_BIGHDR_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
const bfd_target VAR =							\
{									\
  NAME ,								\
  bfd_target_coff_flavour,						\
  BFD_ENDIAN_LITTLE,		/* data byte order is little */		\
  BFD_ENDIAN_BIG,		/* header byte order is big */		\
  /* object flags */							\
  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |			\
   HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),			\
  /* section flags */							\
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),\
  UNDER,			/* leading symbol underscore */		\
  '/',				/* ar_pad_char */			\
  15,				/* ar_max_namelen */			\
  									\
  /* Data conversion functions.  */					\
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
  									\
  /* Header conversion functions.  */					\
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
									\
	/* bfd_check_format */						\
  { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p,		\
    _bfd_dummy_target },						\
	/* bfd_set_format */						\
  { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },	\
	/* bfd_write_contents */					\
  { bfd_false, coff_write_object_contents, _bfd_write_archive_contents,	\
    bfd_false },							\
									\
  BFD_JUMP_TABLE_GENERIC (coff),					\
  BFD_JUMP_TABLE_COPY (coff),						\
  BFD_JUMP_TABLE_CORE (_bfd_nocore),					\
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),				\
  BFD_JUMP_TABLE_SYMBOLS (coff),					\
  BFD_JUMP_TABLE_RELOCS (coff),						\
  BFD_JUMP_TABLE_WRITE (coff),						\
  BFD_JUMP_TABLE_LINK (coff),						\
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),				\
  									\
  ALTERNATIVE,								\
  									\
  SWAP_TABLE								\
d5430 1
a5430 1
#define CREATE_LITTLE_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
d5475 1
a5475 1
  SWAP_TABLE								\
@


1.82.8.2
log
@Merge from mainline.
@
text
@d1067 1
a1067 5
	  /* The MS PE spec sets the DISCARDABLE flag on .reloc sections
	     but we do not want them to be labelled as debug section, since
	     then strip would remove them.  */
	  if (strncmp (name, ".reloc", sizeof ".reloc" - 1) != 0)
	    sec_flags |= SEC_DEBUGGING;
@


1.82.6.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d1249 1
a1249 1
.  boolean (*_bfd_coff_adjust_symndx)
@


1.82.6.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d299 1
a299 1
.  bfd_boolean done_lineno;
d312 2
a313 3
static long sec_to_styp_flags
  PARAMS ((const char *, flagword));
static bfd_boolean styp_to_sec_flags
d315 1
a315 2
static bfd_boolean coff_bad_format_hook
  PARAMS ((bfd *, PTR));
d319 4
a322 7
static bfd_boolean coff_new_section_hook
  PARAMS ((bfd *, asection *));
static bfd_boolean coff_set_arch_mach_hook
  PARAMS ((bfd *, PTR));
static bfd_boolean coff_write_relocs
  PARAMS ((bfd *, int));
static bfd_boolean coff_set_flags
d324 1
a324 1
static bfd_boolean coff_set_arch_mach
d326 3
a328 5
static bfd_boolean coff_compute_section_file_positions
  PARAMS ((bfd *));
static bfd_boolean coff_write_object_contents
  PARAMS ((bfd *)) ATTRIBUTE_UNUSED;
static bfd_boolean coff_set_section_contents
d330 3
a332 6
static PTR buy_and_read
  PARAMS ((bfd *, file_ptr, bfd_size_type));
static bfd_boolean coff_slurp_line_table
  PARAMS ((bfd *, asection *));
static bfd_boolean coff_slurp_symbol_table
  PARAMS ((bfd *));
d335 1
a335 2
static bfd_boolean coff_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **));
d339 1
a339 2
static PTR coff_mkobject_hook
  PARAMS ((bfd *, PTR,  PTR));
d342 1
a342 2
static flagword handle_COMDAT
  PARAMS ((bfd *, flagword, PTR, const char *, asection *));
d345 3
a347 6
static bfd_boolean coff_read_word
  PARAMS ((bfd *, unsigned int *));
static unsigned int coff_compute_checksum
  PARAMS ((bfd *));
static bfd_boolean coff_apply_checksum
  PARAMS ((bfd *));
d567 1
a567 1
static bfd_boolean
d702 1
a702 1
    return FALSE;
d705 1
a705 1
  return TRUE;
d976 1
a976 1
static bfd_boolean
d987 1
a987 1
  bfd_boolean result = TRUE;
d1088 1
a1088 1
	  result = FALSE;
d1176 2
a1177 2
.  bfd_boolean _bfd_coff_long_filenames;
.  bfd_boolean _bfd_coff_long_section_names;
d1179 1
a1179 1
.  bfd_boolean _bfd_coff_force_symnames_in_strings;
d1194 1
a1194 1
.  bfd_boolean (*_bfd_coff_bad_format_hook)
d1197 1
a1197 1
.  bfd_boolean (*_bfd_coff_set_arch_mach_hook)
d1203 1
a1203 1
.  bfd_boolean (*_bfd_styp_to_sec_flags_hook)
d1209 1
a1209 1
.  bfd_boolean (*_bfd_coff_slurp_symbol_table)
d1212 1
a1212 1
.  bfd_boolean (*_bfd_coff_symname_in_debug)
d1215 1
a1215 1
.  bfd_boolean (*_bfd_coff_pointerize_aux_hook)
d1219 1
a1219 1
.  bfd_boolean (*_bfd_coff_print_aux)
d1234 1
a1234 1
.  bfd_boolean (*_bfd_coff_compute_section_file_positions)
d1237 1
a1237 1
.  bfd_boolean (*_bfd_coff_start_final_link)
d1240 1
a1240 1
.  bfd_boolean (*_bfd_coff_relocate_section)
d1249 1
a1249 1
.  bfd_boolean (*_bfd_coff_adjust_symndx)
d1251 1
a1251 1
.	     struct internal_reloc *, bfd_boolean *));
d1253 1
a1253 1
.  bfd_boolean (*_bfd_coff_link_add_one_symbol)
d1255 1
a1255 1
.	     asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
d1258 1
a1258 1
.  bfd_boolean (*_bfd_coff_link_output_has_begun)
d1261 1
a1261 1
.  bfd_boolean (*_bfd_coff_final_link_postscript)
d1397 1
a1397 1
static bfd_boolean
d1405 1
a1405 1
    return FALSE;
d1418 1
a1418 1
    return FALSE;
d1421 1
a1421 1
  return TRUE;
d1490 1
a1490 1
static bfd_boolean
d1517 1
a1517 1
    return FALSE;
d1534 1
a1534 1
  return TRUE;
d1706 1
a1706 1
static bfd_boolean coff_mkobject PARAMS ((bfd *));
d1708 1
a1708 1
static bfd_boolean
d1717 1
a1717 1
    return FALSE;
d1727 1
a1727 1
  return TRUE;
d1781 1
a1781 1
      xcoff->full_aouthdr = TRUE;
d1818 1
a1818 1
static bfd_boolean
d1920 1
a1920 1
	  return FALSE;
d1999 1
a1999 1
		    return FALSE;
d2165 1
a2165 1
  return TRUE;
d2170 1
a2170 1
static bfd_boolean symname_in_debug_hook
d2173 1
a2173 1
static bfd_boolean
d2184 1
a2184 1
  (bfd_boolean (*) PARAMS ((bfd *, struct internal_syment *))) bfd_false
d2196 1
a2196 1
static bfd_boolean coff_pointerize_aux_hook
d2201 1
a2201 1
static bfd_boolean
d2221 1
a2221 1
      /* Return TRUE to indicate that the caller should not do any
d2223 1
a2223 1
      return TRUE;
d2226 1
a2226 1
  /* Return FALSE to indicate that this auxent should be handled by
d2228 1
a2228 1
  return FALSE;
d2236 1
a2236 1
static bfd_boolean coff_pointerize_aux_hook
d2241 1
a2241 1
static bfd_boolean
d2249 1
a2249 1
  /* Return TRUE if we don't want to pointerize this aux entry, which
d2264 1
a2264 1
/* Print an aux entry.  This returns TRUE if it has printed it.  */
d2266 1
a2266 1
static bfd_boolean coff_print_aux
d2270 1
a2270 1
static bfd_boolean
d2317 1
a2317 1
      return TRUE;
d2321 2
a2322 2
  /* Return FALSE to indicate that no special action was taken.  */
  return FALSE;
d2361 1
a2361 1
static bfd_boolean
d2385 1
a2385 1
	  return FALSE;
d2392 1
a2392 1
	return FALSE;
d2405 1
a2405 1
	    return FALSE;
d2485 1
a2485 1
	    return FALSE;
d2494 1
a2494 1
  return TRUE;
d2498 1
a2498 1
   type.  Result is TRUE if we can represent the arch&type, FALSE if not.  */
d2500 1
a2500 1
static bfd_boolean
d2520 1
a2520 1
	  return FALSE;
d2522 1
a2522 1
      return TRUE;
d2562 1
a2562 1
	    return FALSE;
d2565 1
a2565 1
	return TRUE;
d2573 1
a2573 1
      return TRUE;
d2596 1
a2596 1
              return FALSE;
d2599 1
a2599 1
      return TRUE;
d2605 1
a2605 1
      return TRUE;
d2643 1
a2643 1
      return TRUE;
d2648 1
a2648 1
      return TRUE;
d2658 1
a2658 1
      return TRUE;
d2664 1
a2664 1
      return TRUE;
d2670 1
a2670 1
      return TRUE;
d2689 1
a2689 1
      return TRUE;
d2696 1
a2696 1
      return TRUE;
d2705 1
a2705 1
	  return TRUE;
d2708 1
a2708 1
	  return TRUE;
d2711 1
a2711 1
	  return TRUE;
d2726 1
a2726 1
      return TRUE;
d2733 1
a2733 1
      return TRUE;
d2744 1
a2744 1
      return TRUE;
d2751 1
a2751 1
      return TRUE;
d2760 1
a2760 1
      return TRUE;
d2767 1
a2767 1
      return TRUE;
d2778 1
a2778 1
      return TRUE;
d2785 1
a2785 1
      return TRUE;
d2791 1
a2791 1
      return TRUE;
d2800 1
a2800 1
      return TRUE;
d2804 1
a2804 1
      /* Fall through to "return FALSE" below, to avoid
d2809 1
a2809 1
  return FALSE;
d2812 1
a2812 1
static bfd_boolean
d2822 1
a2822 1
    return FALSE;
d2826 1
a2826 1
    return FALSE;		/* We can't represent this type */
d2828 1
a2828 1
  return TRUE;			/* We're easy ...  */
d2865 1
a2865 1
static bfd_boolean
d2872 1
a2872 1
  bfd_boolean align_adjust;
d2978 1
a2978 1
      return FALSE;
d3031 1
a3031 1
  align_adjust = FALSE;
d3044 1
a3044 1
	    return FALSE;
d3052 1
a3052 1
	    return FALSE;
d3082 1
a3082 1
	     AIX executables, this check fails. This shows up when a native
d3085 1
a3085 1
	     stripped gnu excutable passes this check because the filepos is
d3088 2
a3089 2
	  if (!strcmp (current->name, _TEXT)
	      || !strcmp (current->name, _DATA))
d3098 2
a3099 2

	      if (pad)
d3161 1
a3161 1
	align_adjust = TRUE;
d3187 1
a3187 1
	return FALSE;
d3196 1
a3196 1
  abfd->output_has_begun = TRUE;
d3198 1
a3198 1
  return TRUE;
d3210 1
a3210 1
static bfd_boolean
d3254 1
a3254 1
    return TRUE;
d3260 1
a3260 1
    return FALSE;
d3275 1
a3275 1
  return TRUE;
d3285 1
a3285 1
static bfd_boolean
d3297 1
a3297 1
      return FALSE;
d3307 1
a3307 1
  return TRUE;
d3314 1
a3314 1
  bfd_boolean more_data;
d3338 1
a3338 1
static bfd_boolean
d3346 1
a3346 1
    return FALSE;
d3349 1
a3349 1
    return FALSE;
d3352 1
a3352 1
    return FALSE;
d3358 1
a3358 1
    return FALSE;
d3365 1
a3365 1
    return FALSE;
d3369 1
a3369 1
  return TRUE;
d3376 1
a3376 1
static bfd_boolean
d3381 3
a3383 3
  bfd_boolean hasrelocs = FALSE;
  bfd_boolean haslinno = FALSE;
  bfd_boolean hasdebug = FALSE;
d3390 1
a3390 1
  bfd_boolean long_section_names;
d3410 1
a3410 1
	return FALSE;
d3482 1
a3482 1
    return FALSE;
d3484 1
a3484 1
  long_section_names = FALSE;
d3490 1
a3490 1
      bfd_boolean is_reloc_section = FALSE;
d3495 2
a3496 2
	  is_reloc_section = TRUE;
	  hasrelocs = TRUE;
d3517 1
a3517 1
	    long_section_names = TRUE;
d3568 1
a3568 1
	hasrelocs = TRUE;
d3571 1
a3571 1
	haslinno = TRUE;
d3574 1
a3574 1
	hasdebug = TRUE;
d3631 1
a3631 1
	    return FALSE;
d3755 1
a3755 1
	    return FALSE;
d3974 1
a3974 1
	return FALSE;
d3977 1
a3977 1
	return FALSE;
d3980 1
a3980 1
	return FALSE;
d3982 1
a3982 1
	return FALSE;
d3984 1
a3984 1
	return FALSE;
d3992 1
a3992 1
	return FALSE;
d4008 1
a4008 1
	return FALSE;
d4127 1
a4127 1
    return FALSE;
d4135 1
a4135 1
      return FALSE;
d4143 1
a4143 1
      return FALSE;
d4155 1
a4155 1
	return FALSE;
d4163 1
a4163 1
	return FALSE;
d4167 1
a4167 1
	return FALSE;
d4183 1
a4183 1
	return FALSE;
d4187 1
a4187 1
  return TRUE;
d4190 1
a4190 1
static bfd_boolean
d4201 1
a4201 1
	return FALSE;
d4247 1
a4247 1
    return TRUE;
d4250 1
a4250 1
    return FALSE;
d4253 1
a4253 1
    return TRUE;
d4258 1
a4258 1
static bfd_boolean
d4267 1
a4267 1
	  return FALSE;
d4271 1
a4271 1
	  return FALSE;
d4275 1
a4275 1
	return FALSE;
d4279 1
a4279 1
  return TRUE;
d4323 1
a4323 1
static bfd_boolean
d4339 1
a4339 1
    return FALSE;
d4354 1
a4354 1
	      bfd_boolean warned;
d4358 1
a4358 1
	      warned = FALSE;
d4367 1
a4367 1
		  warned = TRUE;
d4399 1
a4399 1
  return TRUE;
d4406 1
a4406 1
static bfd_boolean
d4418 1
a4418 1
    return TRUE;
d4423 1
a4423 1
      return FALSE;
d4431 1
a4431 1
    return FALSE;
d4438 1
a4438 1
    return FALSE;
d4456 1
a4456 1
	  dst->done_lineno = FALSE;
d4770 1
a4770 1
  return TRUE;
d4922 1
a4922 1
static bfd_boolean
d4935 1
a4935 1
    return TRUE;
d4937 1
a4937 1
    return TRUE;
d4939 1
a4939 1
    return TRUE;
d4941 1
a4941 1
    return FALSE;
d4948 1
a4948 1
    return FALSE;
d5014 1
a5014 1
	  return FALSE;
d5019 1
a5019 1
  return TRUE;
d5196 1
a5196 1
static bfd_boolean coff_link_output_has_begun
d5199 1
a5199 1
static bfd_boolean
d5210 1
a5210 1
static bfd_boolean coff_final_link_postscript
d5213 1
a5213 1
static bfd_boolean
d5218 1
a5218 1
  return TRUE;
d5274 1
a5274 1
  TRUE,
d5276 1
a5276 1
  FALSE,
d5279 1
a5279 1
  TRUE,
d5281 1
a5281 1
  FALSE,
d5285 1
a5285 1
  TRUE,
d5287 1
a5287 1
  FALSE,
@


1.82.6.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a2130 1
      machine = TICOFF_TARGET_MACHINE_GET (internal_f->f_flags);
a2144 1
	  machine = TICOFF_TARGET_MACHINE_GET (internal_f->f_flags);
a2614 1
      TICOFF_TARGET_MACHINE_SET (flagsp, bfd_get_mach (abfd));
@


1.82.6.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d228 1
a228 1
	structured hierarchy required by coff. It changes each pointer
d561 1
a561 1
     are retained in pei_section_data(abfd, section)->pe_flags.  */
d563 1
a563 1
  styp_flags |= IMAGE_SCN_MEM_READ;       /* Always readable.  */
d565 1
a565 1
    styp_flags |= IMAGE_SCN_MEM_WRITE;    /* Invert READONLY for write.  */
d567 1
a567 1
    styp_flags |= IMAGE_SCN_MEM_EXECUTE;  /* CODE->EXECUTE.  */
d569 1
a569 1
    styp_flags |= IMAGE_SCN_MEM_SHARED;   /* Shared remains meaningful.  */
d696 1
a696 1
#ifdef STYP_LIT			/* A29k readonly text/data section type.  */
d701 1
a701 1
#ifdef STYP_OTHER_LOAD		/* Other loaded sections.  */
d805 1
a805 1
	  /* All 3 branches use this.  */
d933 1
a933 1
	      /* Is this the name we're looking for ?  */
d1347 1
a1347 2
.  ((coff_backend_info (abfd)->_bfd_coff_mkobject_hook)\
.   (abfd, filehdr, aouthdr))
d1372 1
a1372 2
.#define bfd_coff_reloc16_extra_cases(abfd, link_info, link_order,\
.                                     reloc, data, src_ptr, dst_ptr)\
d1400 1
a1400 2
.#define bfd_coff_link_add_one_symbol(info, abfd, name, flags, section,\
.                                     value, string, cp, coll, hashp)\
d1423 1
a1423 1
  /* If the optional header is NULL or not the correct size then
d1429 2
a1430 1
     when doing that.  */
a1455 1

d1569 1
a1569 1
  /* Extract ALIGN from 2**ALIGN stored in section header.  */
d1575 1
a1575 1
  /* TI tools puts the alignment power in bits 8-11.  */
d1591 1
a1591 1
/* A couple of macros to help setting the alignment power field.  */
d1652 1
a1652 1
  /* Check for extended relocs.  */
a1747 1

d2128 1
a2128 1
      /* This TI COFF section should be used by all new TI COFF v0 targets.  */
d2137 2
a2138 2
      /* This TI COFF section should be used by all new TI COFF v1/2 targets.  */
      /* TI COFF1 and COFF2 use the target_id field to specify which arch.  */
d2177 1
a2177 1
    default:			/* Unreadable input file type.  */
d2218 1
d2258 1
d2363 1
a2363 1
/* AUX's ld wants relocations to be sorted.  */
d2396 1
a2396 1
	/* Sort relocations before we write them out.  */
d2415 1
a2415 1
	  /* Encode real count here as first reloc.  */
a2416 1

d2418 1
a2418 1
	  /* Add one to count *this* reloc (grr).  */
a2430 1

a2447 1

a2450 1

d2452 1
a2452 1
		    /* Got a hit, so repoint the reloc.  */
d2495 1
a2495 1
	  /* Work out reloc type from what is required.  */
a2500 1

d2596 1
a2596 1
      /* If there's no indication of which version we want, use the default.  */
d2601 1
a2601 1
          /* We may want to output in a different COFF version.  */
d3094 2
a3095 2
	  /* Make sure this section is aligned on the right boundary - by
	     padding the previous section up if necessary.  */
d3131 3
a3133 1
	    previous->_raw_size += sofar - old_sofar;
d3155 1
a3155 1
      /* Make sure that this section is of the right size too.  */
a3243 1

d3246 2
a3247 2
	  /* Only do this if there is a coff representation of the input
	     symbol.  */
a3280 1

d3282 4
a3285 3
    /* @@@@ Generate fake .file symbol, in sympp2[i], and increment i.  */
    abort ();

d3422 1
a3422 1
     put them into the correct asections.  */
d3434 1
a3434 1
  /* Work out the size of the reloc and linno areas.  */
d3440 1
a3440 1
      /* We store the actual reloc count in the first reloc's addr.  */
d3452 1
a3452 1
  /* Indicate in each section->line_filepos its actual file address.  */
d3471 1
a3471 1
	  /* Extra reloc to hold real count.  */
d3567 4
a3570 2
      /* If this section has no size or is unloadable then the scnptr
	 will be 0 too.  */
d3573 3
a3575 1
	section.s_scnptr = 0;
d3577 3
a3579 2
	section.s_scnptr = current->filepos;

d3609 3
a3611 1
	text_sec = current;
d3613 3
a3615 1
	data_sec = current;
d3617 3
a3619 1
	bss_sec = current;
d3627 1
a3627 1
      /* TI COFF puts the alignment power in bits 8-11 of the flags.  */
d3784 2
a3785 1
  /* We will NOT put a fucking timestamp in the header here. Every time you
d3788 2
a3789 1
     same but is not a reasonable time. -- gnu@@cygnus.com  */
d3791 1
d3828 2
a3829 2
  /* Target id is used in TI COFF v1 and later; COFF0 won't use this field,
     but it doesn't hurt to set it internally.  */
d3836 4
a3839 2
  /* FIXME, should do something about the other byte orders and
     architectures.  */
d3850 2
a3851 1
  /* Set up architecture-dependent stuff.  */
a3854 1

d3863 3
a3865 2
       is a .shbss or a .shdata section, if so then set the magic
       number to indicate a shared data executable.  */
d3867 1
a3867 1
      internal_a.magic = SHMAGIC; /* Shared magic.  */
d3870 1
a3870 1
      internal_a.magic = NMAGIC; /* Assume separate i/d.  */
d3985 1
a3985 1
  /* Now should write relocs, strings, syms.  */
d4168 1
a4168 1
	 include/coff/pe.h sets AOUTSZ == sizeof (PEAOUTHDR)).  */
d4217 1
a4217 1
  if (! abfd->output_has_begun)	/* Set by bfd.c handler.  */
d4244 1
a4244 1
      Gvran Uddeborg <gvran@@uddeborg.pp.se>.  */
a4367 1

d4433 1
d4439 1
a4439 1
  /* Read in the symbol table.  */
d4441 3
a4443 1
    return FALSE;
d4445 1
a4445 1
  /* Allocate enough room for all the symbols in cached form.  */
a4462 1

d4486 2
a4487 1
	      /* Fall through to next case.  */
d4500 1
a4500 1
	    case C_SYSTEM:	/* System Wide variable.  */
d4503 1
a4503 1
            /* In PE, 0x68 (104) denotes a section symbol.  */
d4577 1
a4577 1
	    case C_STAT:	 /* Static.  */
d4579 1
a4579 1
	    case C_LEAFSTAT:	 /* Static leaf procedure.  */
d4582 3
a4584 3
            case C_THUMBSTAT:    /* Thumb static.  */
            case C_THUMBLABEL:   /* Thumb label.  */
            case C_THUMBSTATFUNC:/* Thumb static function.  */
d4586 1
a4586 1
	    case C_LABEL:	 /* Label.  */
d4609 3
a4611 3
	    case C_MOS:		/* Member of structure.  */
	    case C_EOS:		/* End of structure.  */
#ifdef NOTDEF			/* C_AUTOARG has the same value.  */
d4613 1
a4613 1
	    case C_GLBLREG:	/* A29k-specific storage class.  */
d4616 3
a4618 3
	    case C_REGPARM:	/* Register parameter.  */
	    case C_REG:		/* register variable.  */
              /* C_AUTOARG conflictes with TI COFF C_UEXT.  */
d4621 1
a4621 1
	    case C_AUTOARG:	/* 960-specific storage class.  */
d4624 1
a4624 1
	    case C_TPDEF:	/* Type definition.  */
d4626 6
a4631 6
	    case C_AUTO:	/* Automatic variable.  */
	    case C_FIELD:	/* Bit field.  */
	    case C_ENTAG:	/* Enumeration tag.  */
	    case C_MOE:		/* Member of enumeration.  */
	    case C_MOU:		/* Member of union.  */
	    case C_UNTAG:	/* Union tag.  */
d4636 2
a4637 2
	    case C_FILE:	/* File name.  */
	    case C_STRTAG:	/* Structure tag.  */
d4657 2
a4658 2
	    case C_BINCL:	/* Beginning of include file.  */
	    case C_EINCL:	/* Ending of include file.  */
d4699 3
a4701 3
	    case C_BLOCK:	/* ".bb" or ".eb".  */
	    case C_FCN:		/* ".bf" or ".ef" (or PE ".lf").  */
	    case C_EFCN:	/* Physical end of function.  */
d4723 1
a4723 1
	    case C_STATLAB:	/* Static load time label.  */
d4736 3
a4738 3
	    case C_EXTDEF:	/* External definition.  */
	    case C_ULABEL:	/* Undefined label.  */
	    case C_USTATIC:	/* Undefined static.  */
d4741 2
a4742 2
               class to represent a section symbol.  */
	    case C_LINE:	/* line # reformatted as symbol table entry.  */
d4744 1
a4744 1
	    case C_ALIAS:	/* Duplicate tag.  */
d4746 1
a4746 1
	      /* New storage classes for TI COFF.  */
d4748 1
a4748 1
	    case C_UEXT:	/* Tentative external definition.  */
d4750 2
a4751 2
	    case C_EXTLAB:	/* External load time label.  */
	    case C_HIDDEN:	/* Ext symbol in dmert public lib.  */
d4771 2
a4772 2
	}
    }
d4779 1
a4779 1
  /* Slurp the line tables for each section too.  */
a4781 1

a4788 1

d5015 1
a5015 1
	 Note that symbols which used to be common must be left alone.  */
d5017 1
a5017 1
      /* Calculate any reloc addend by looking at the symbol.  */
d5023 1
a5023 1
      /* Fill in the cache_ptr->howto field from dst.r_type.  */
d5091 3
a5093 3
      /* This section has relocs made up by us, they are not in the
	 file, so take them out of their chain and place them into
	 the data area provided.  */
a5094 1

d5100 1
@


1.82.6.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1886 1
a1886 2
      machine = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);
      if (machine == bfd_mach_arm_unknown)
d1888 13
a1900 16
	  switch (internal_f->f_flags & F_ARM_ARCHITECTURE_MASK)
	    {
	    case F_ARM_2:  machine = bfd_mach_arm_2;  break;
	    case F_ARM_2a: machine = bfd_mach_arm_2a; break;
	    case F_ARM_3:  machine = bfd_mach_arm_3;  break;
	    default:
	    case F_ARM_3M: machine = bfd_mach_arm_3M; break;
	    case F_ARM_4:  machine = bfd_mach_arm_4;  break;
	    case F_ARM_4T: machine = bfd_mach_arm_4T; break;
	      /* The COFF header does not have enough bits available
		 to cover all the different ARM architectures.  So
		 we interpret F_ARM_5, the highest flag value to mean
		 "the highest ARM architecture known to BFD" which is
		 currently the XScale.  */
	    case F_ARM_5:  machine = bfd_mach_arm_XScale;  break;
	    }
@


1.82.6.6
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d2074 1
a2074 1
      /* !! FIXME this probably isn't the right place for this.  */
d2083 1
a2083 1
      /* !! FIXME this probably isn't the right place for this.  */
d2092 1
a2092 19
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef H8300HNMAGIC
    case H8300HNMAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300hn;
      /* !! FIXME this probably isn't the right place for this.  */
      abfd->flags |= BFD_IS_RELAXABLE;
      break;
#endif

#ifdef H8300SNMAGIC
    case H8300SNMAGIC:
      arch = bfd_arch_h8300;
      machine = bfd_mach_h8300sn;
      /* !! FIXME this probably isn't the right place for this.  */
a2740 6
	  return TRUE;
	case bfd_mach_h8300hn:
	  *magicp = H8300HNMAGIC;
	  return TRUE;
	case bfd_mach_h8300sn:
	  *magicp = H8300SNMAGIC;
@


1.82.6.7
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a364 6
#ifdef TICOFF
static bfd_boolean ticoff0_bad_format_hook
    PARAMS ((bfd *, PTR ));
static bfd_boolean ticoff1_bad_format_hook
    PARAMS ((bfd *, PTR ));
#endif
a1441 30
#ifdef TICOFF
static bfd_boolean
ticoff0_bad_format_hook (abfd, filehdr)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR filehdr;
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

  if (COFF0_BADMAG (*internal_f))
    return FALSE;

  return TRUE;
}
#endif

#ifdef TICOFF
static bfd_boolean
ticoff1_bad_format_hook (abfd, filehdr)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR filehdr;
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

  if (COFF1_BADMAG (*internal_f))
    return FALSE;

  return TRUE;
}
#endif

a5340 86
#ifdef TICOFF
/* COFF0 differs in file/section header size and relocation entry size.  */
static const bfd_coff_backend_data ticoff0_swap_table =
{
  coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
  coff_SWAP_aux_out, coff_SWAP_sym_out,
  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
  coff_SWAP_filehdr_out, coff_SWAP_aouthdr_out,
  coff_SWAP_scnhdr_out,
  FILHSZ_V0, AOUTSZ, SCNHSZ_V01, SYMESZ, AUXESZ, RELSZ_V0, LINESZ, FILNMLEN,
#ifdef COFF_LONG_FILENAMES
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_LONG_SECTION_NAMES
  TRUE,
#else
  FALSE,
#endif
  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
  4,
#else
  2,
#endif
  coff_SWAP_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
  coff_SWAP_reloc_in, ticoff0_bad_format_hook, coff_set_arch_mach_hook,
  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
  coff_classify_symbol, coff_compute_section_file_positions,
  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
  coff_adjust_symndx, coff_link_add_one_symbol,
  coff_link_output_has_begun, coff_final_link_postscript
};
#endif

#ifdef TICOFF
/* COFF1 differs in section header size.  */
static const bfd_coff_backend_data ticoff1_swap_table =
{
  coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
  coff_SWAP_aux_out, coff_SWAP_sym_out,
  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
  coff_SWAP_filehdr_out, coff_SWAP_aouthdr_out,
  coff_SWAP_scnhdr_out,
  FILHSZ, AOUTSZ, SCNHSZ_V01, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,
#ifdef COFF_LONG_FILENAMES
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_LONG_SECTION_NAMES
  TRUE,
#else
  FALSE,
#endif
  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
  TRUE,
#else
  FALSE,
#endif
#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
  4,
#else
  2,
#endif
  coff_SWAP_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
  coff_SWAP_reloc_in, ticoff1_bad_format_hook, coff_set_arch_mach_hook,
  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
  coff_classify_symbol, coff_compute_section_file_positions,
  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
  coff_adjust_symndx, coff_link_add_one_symbol,
  coff_link_output_has_begun, coff_final_link_postscript
};
#endif

d5416 1
a5416 1
#define CREATE_BIG_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
d5463 1
a5463 51
  SWAP_TABLE								\
};

#define CREATE_BIGHDR_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
const bfd_target VAR =							\
{									\
  NAME ,								\
  bfd_target_coff_flavour,						\
  BFD_ENDIAN_LITTLE,		/* data byte order is little */		\
  BFD_ENDIAN_BIG,		/* header byte order is big */		\
  /* object flags */							\
  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |			\
   HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),			\
  /* section flags */							\
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),\
  UNDER,			/* leading symbol underscore */		\
  '/',				/* ar_pad_char */			\
  15,				/* ar_max_namelen */			\
  									\
  /* Data conversion functions.  */					\
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
  									\
  /* Header conversion functions.  */					\
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
									\
	/* bfd_check_format */						\
  { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p,		\
    _bfd_dummy_target },						\
	/* bfd_set_format */						\
  { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },	\
	/* bfd_write_contents */					\
  { bfd_false, coff_write_object_contents, _bfd_write_archive_contents,	\
    bfd_false },							\
									\
  BFD_JUMP_TABLE_GENERIC (coff),					\
  BFD_JUMP_TABLE_COPY (coff),						\
  BFD_JUMP_TABLE_CORE (_bfd_nocore),					\
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),				\
  BFD_JUMP_TABLE_SYMBOLS (coff),					\
  BFD_JUMP_TABLE_RELOCS (coff),						\
  BFD_JUMP_TABLE_WRITE (coff),						\
  BFD_JUMP_TABLE_LINK (coff),						\
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),				\
  									\
  ALTERNATIVE,								\
  									\
  SWAP_TABLE								\
d5466 1
a5466 1
#define CREATE_LITTLE_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
d5511 1
a5511 1
  SWAP_TABLE								\
@


1.82.6.8
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d3876 1
a3876 3
#ifdef COFF_WITH_PE
  internal_f.f_flags |= IMAGE_FILE_32BIT_MACHINE;
#else
a4407 7
  if (native_lineno == NULL)
    {
      (*_bfd_error_handler)
        (_("%s: warning: line number table read failed"),
	 bfd_archive_filename (abfd));
      return FALSE;
    }
a4695 1
	    case C_TCSYM:
a4696 1
	    case C_ECOML:
@


1.82.6.9
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d336 1
a336 1
  PARAMS ((bfd *, asection *, const PTR, file_ptr, bfd_size_type));
a1696 2
      bfd_size_type relsz = bfd_coff_relsz (abfd);
      
d1698 2
a1699 1
      if (bfd_bread ((PTR) &dst, relsz, abfd) != relsz)
d1704 1
a1704 2
      section->reloc_count = hdr->s_nreloc = n.r_vaddr - 1;
      section->rel_filepos += relsz;
a1705 4
  else if (hdr->s_nreloc == 0xffff)
    (*_bfd_error_handler)
      ("%s: warning: claims to have 0xffff relocs, without overflow",
       bfd_get_filename (abfd));
d4268 1
a4268 1
     const PTR location;
@


1.82.6.10
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1575 1
a1575 1
     symbol information, since they'll be overridden by the BFD symbol
a3016 5

      /* If no file alignment has been set, default to one.
	 This repairs 'ld -r' for arm-wince-pe target.  */
      if (page_size == 0)
        page_size = 1;
d4684 1
a4684 1
              /* C_AUTOARG conflicts with TI COFF C_UEXT.  */
d5125 1
@


1.82.6.11
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1067 1
a1067 5
	  /* The MS PE spec sets the DISCARDABLE flag on .reloc sections
	     but we do not want them to be labelled as debug section, since
	     then strip would remove them.  */
	  if (strncmp (name, ".reloc", sizeof ".reloc" - 1) != 0)
	    sec_flags |= SEC_DEBUGGING;
@


1.81
log
@	* coffcode.h (coff_set_arch_mach_hook): Handle W65MAGIC.
@
text
@d1827 1
a1834 1
      machine = 0;
a1839 1
      machine = 0; /* what does this mean? (krk) */
a1847 1
      machine = 0;
a1852 1
      machine = 0;
a1858 1
      machine = 0;
a2042 1
      machine = 0;
a2079 1
      machine = 0;
a2085 1
      machine = 0;
a2091 1
      machine = 0;
a2100 1
      machine = 0;
d2456 2
a2457 1
		if (q->sym_ptr_ptr == bfd_abs_section_ptr->symbol_ptr_ptr)
d4111 1
a4111 1
	      if (bfd_get_mach (abfd) == 0)
@


1.80
log
@	* cofflink.c (_bfd_coff_final_link): On PE COFF systems, take into
	account the impact of relocation count overflow when computing
	section offsets.
	* coffcode.h (coff_write_relocs): Use obj_pe when deciding whether
	or not to apply the PE COFF reloc overflow handling.  Fix a
	fencepost error in deciding whether or not to use that technique.
@
text
@d2161 7
@


1.80.2.1
log
@	* coffcode.h (coff_set_arch_mach_hook): Handle W65MAGIC.
@
text
@a2160 7

#ifdef W65MAGIC
    case W65MAGIC:
      arch = bfd_arch_w65;
      break;
#endif

@


1.80.2.2
log
@	* coffcode.h: Remove extraneous '\'.
@
text
@d1249 1
a1249 1
.  boolean (*_bfd_coff_adjust_symndx)
@


1.79
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d2397 1
a2397 1
      if (s->reloc_count > 0xffff)
d3423 1
a3423 1
      if (current->reloc_count > 0xffff)
d3454 1
a3454 1
	  if (current->reloc_count > 0xffff)
@


1.78
log
@Change text alignement to 4 bytes.
@
text
@d1742 1
a1742 1
  if (coff_mkobject (abfd) == false)
d2180 1
a2180 1
  return SYMNAME_IN_DEBUG (sym) ? true : false;
d2825 2
a2826 2
  if (arch != bfd_arch_unknown &&
      coff_set_flags (abfd, &dummy1, &dummy2) != true)
d3408 1
a3408 1
  if (abfd->output_has_begun == false)
d4199 1
a4199 1
  if (abfd->output_has_begun == false)	/* set by bfd.c handler */
@


1.77
log
@	* bfd-in.h: Remove "taken from the source" comment.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	* elf.c (bfd_elf_discard_group): Return true.
	* elf-bfd.h (bfd_elf_discard_group): Declare.
	* bfd-in.h (bfd_elf_discard_group): Don't declare here.
	* section.c (bfd_discard_group): Rename to bfd_generic_discard_group.
	* bfd.c (bfd_discard_group): Define.
	* targets.c (struct bfd_target): Add _bfd_discard_group.
	(BFD_JUMP_TABLE_LINK): Here too.
	* libbfd-in.h (_bfd_nolink_bfd_discard_group): Define.
	* aout-adobe.c (aout_32_bfd_discard_group): Define.
	* aout-target.h (MY_bfd_discard_group): Define.
	* aout-tic30.c (MY_bfd_discard_group): Define.
	* binary.c (binary_bfd_discard_group): Define.
	* bout.c (b_out_bfd_discard_group): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_discard_group): Define.
	* coffcode.h (coff_bfd_discard_group): Define.
	* coff-mips.c (_bfd_ecoff_bfd_discard_group): Define.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Define.
	* i386msdos.c (msdos_bfd_discard_group): Define.
	* i386os9k.c (os9k_bfd_discard_group): Define.
	* ieee.c (ieee_bfd_discard_group): Define.
	* ihex.c (ihex_bfd_discard_group): Define.
	* mmo.c (mmo_bfd_discard_group): Define.
	* nlm-target.h (nlm_bfd_discard_group): Define.
	* oasys.c (oasys_bfd_discard_group): Define.
	* ppcboot.c (ppcboot_bfd_discard_group): Define.
	* som.c (som_bfd_discard_group): Define.
	* srec.c (srec_bfd_discard_group): Define.
	* tekhex.c (tekhex_bfd_discard_group): Define.
	* versados.c (versados_bfd_discard_group): Define.
	* vms.c (vms_bfd_discard_group): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_discard_group): Define.
	* coff64-rs6000.c (rs6000coff64_vec): Update initialiser.
	(aix5coff64_vec): Likewise.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
@
text
@d1785 2
a1786 2
      xcoff->text_align_power = internal_a->o_algntext;
      xcoff->data_align_power = internal_a->o_algndata;
d3087 4
a3090 2
	     0x0140. */
	  if (!strcmp (current->name, _TEXT)) 
@


1.76
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d5375 4
@


1.76.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1785 2
a1786 2
      bfd_xcoff_text_align_power (abfd) = internal_a->o_algntext;
      bfd_xcoff_data_align_power (abfd) = internal_a->o_algndata;
d3087 2
a3088 4
	     0x0140.  This problem also show up with 64 bit shared objects. The
	     data section must also be aligned.  */
	  if (!strcmp (current->name, _TEXT) 
	      || !strcmp (current->name, _DATA)) 
a5372 4
#endif

#ifndef coff_bfd_discard_group
#define coff_bfd_discard_group		    bfd_generic_discard_group
@


1.76.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1742 1
a1742 1
  if (! coff_mkobject (abfd))
d2180 1
a2180 1
  return SYMNAME_IN_DEBUG (sym) != 0;
d2397 1
a2397 1
      if (obj_pe (abfd) && s->reloc_count >= 0xffff)
d2825 2
a2826 2
  if (arch != bfd_arch_unknown
      && ! coff_set_flags (abfd, &dummy1, &dummy2))
d3408 1
a3408 1
  if (! abfd->output_has_begun)
d3423 1
a3423 1
      if (obj_pe (abfd) && current->reloc_count >= 0xffff)
d3454 1
a3454 1
	  if (obj_pe (abfd) && current->reloc_count >= 0xffff)
d4199 1
a4199 1
  if (! abfd->output_has_begun)	/* set by bfd.c handler */
@


1.76.2.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a2160 7

#ifdef W65MAGIC
    case W65MAGIC:
      arch = bfd_arch_w65;
      break;
#endif

@


1.76.2.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a1826 1
  /* Zero selects the default machine for an arch.  */
d1834 1
d1840 1
d1849 1
d1855 1
d1862 1
d2047 1
d2085 1
d2092 1
d2099 1
d2109 1
d2465 1
a2465 2
		if ((*q->sym_ptr_ptr)->section == bfd_abs_section_ptr
		    && ((*q->sym_ptr_ptr)->flags & BSF_SECTION_SYM) != 0)
d4119 1
a4119 1
	      if (bfd_get_mach (abfd) == bfd_mach_ppc)
@


1.76.2.5
log
@merge from mainline
@
text
@d1249 1
a1249 1
.  boolean (*_bfd_coff_adjust_symndx)
@


1.75
log
@typo fix in last change
@
text
@d5178 1
@


1.75.4.1
log
@merge from trunk
@
text
@d1785 2
a1786 2
      bfd_xcoff_text_align_power (abfd) = internal_a->o_algntext;
      bfd_xcoff_data_align_power (abfd) = internal_a->o_algndata;
d3087 2
a3088 4
	     0x0140.  This problem also show up with 64 bit shared objects. The
	     data section must also be aligned.  */
	  if (!strcmp (current->name, _TEXT) 
	      || !strcmp (current->name, _DATA)) 
a5177 1
#define coff_bfd_link_just_syms _bfd_generic_link_just_syms
a5371 4
#endif

#ifndef coff_bfd_discard_group
#define coff_bfd_discard_group		    bfd_generic_discard_group
@


1.74
log
@	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.
@
text
@d3017 1
a3017 1
    abfd->section_tail = &current->next
@


1.73
log
@Compute checksum for PE images.
@
text
@d3017 1
@


1.72
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d344 5
d3278 94
d4162 5
@


1.71
log
@Add AIX 64 shared library support and emulation layer for binutils
@
text
@d5046 4
@


1.70
log
@When adding BSF_WEAK flag, OR it in rather than replacing previously selected
flags.
@
text
@d1496 1
a1496 1
  if (xcoff_data (abfd)->text_align_power != 0
d1498 2
a1499 2
    section->alignment_power = xcoff_data (abfd)->text_align_power;
  if (xcoff_data (abfd)->data_align_power != 0
d1501 1
a1501 1
    section->alignment_power = xcoff_data (abfd)->data_align_power;
d1967 1
d2772 2
a2773 8
#ifdef XCOFF64
      if (bfd_get_mach (abfd) == bfd_mach_ppc_620
	  && !strncmp (abfd->xvec->name,"aix", 3))
	*magicp = U803XTOCMAGIC;
      else
#else
    	*magicp = U802TOCMAGIC;
#endif
d4445 1
a4445 1
		  dst->symbol.flags = BSF_LOCAL;
@


1.69
log
@Select the highest known ARM architecture when an F_ARM_5 flag is detected,
since we cannot be sure exactly which architecture this represents.
@
text
@d4446 2
a4447 1
		dst->symbol.flags = BSF_WEAK;
a4449 1
		{
a4450 1
		}
a4451 1

d4453 1
a4453 1
		dst->symbol.flags = BSF_WEAK;
@


1.69.2.1
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d4446 1
a4446 2
		dst->symbol.flags |= BSF_WEAK;

d4449 3
a4451 1
		dst->symbol.flags = BSF_LOCAL;
d4453 1
d4455 1
a4455 1
		dst->symbol.flags |= BSF_WEAK;
@


1.69.2.2
log
@	* reloc.c: Move sh relocs to where they belong.
	* libbfd.h, bfd-in2.h: Regenerate.

	Merge from mainline
	2002-04-26  Alan Modra  <amodra@@bigpond.net.au>
	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.

	2002-04-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.
	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.

	2002-04-20  Alan Modra  <amodra@@bigpond.net.au>
	* archures.c (bfd_arch_info): Add comment on list order.
	(bfd_default_set_arch_mach): Use bfd_lookup_arch.
	* cpu-powerpc.c (bfd_powerpc_archs): Re-order so that the default
	is always at head of list.
	* bfd-in2.h: Regenerate.

	2002-04-16  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.

	2002-04-15  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.

	2002-04-08  Randolph Chung  <tausq@@debian.org>
	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@a3016 1
    abfd->section_tail = &current->next;
@


1.68
log
@Add support for OpenRISC 32-bit embedded processor
@
text
@d1790 1
a1790 1
  /* Set the flags field from the COFF header read in */
d1874 6
a1879 1
        case F_ARM_5:  machine = bfd_mach_arm_5;  break;
d2632 2
a2633 1
	  /* FIXME: we do not have F_ARM vaues greater than F_ARM_5.  */
@


1.67
log
@	* section.c (bfd_section_init): Remove unnecessary initialisations.
	(bfd_section_list_clear): New function.
	(bfd_section_list_remove, bfd_section_list_insert): New macros.
	(_bfd_strip_section_from_output): Use them.
	* coffcode.h (coff_set_alignment_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_final_link): Likewise.
	* elf64-mips.c (mips_elf64_final_link): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.
	* bfd-in2.h: Regenerate.

	* netbsd-core.c (netbsd_core_file_p): Use bfd_make_section_anyway
	rather than doing our own section handling.  Clean up after errors
	with bfd_release and bfd_section_list_clear.  Handle unexpected
	flags.
	* aoutf1.h (sunos4_core_file_p): Likewise.
	* aix386-core.c (aix386_core_file_p): Likewise.
	* cisco-core.c (cisco_core_file_validate): Likewise.
	* ptrace-core.c (ptrace_unix_core_file_p): Likewise.
	* trad-core.c (trad_unix_core_file_p): Likewise.

	* hppabsd-core.c (hppabsd_core_core_file_p):  Clean up after errors
	with bfd_release and bfd_section_list_clear.
	* hpux-core.c (hpux_core_core_file_p): Likewise.
	* irix-core.c (irix_core_core_file_p): Likewise.
	* lynx-core.c (lynx_core_file_p): Likewise.
	* osf-core.c (osf_core_core_file_p): Likewise.
	* rs6000-core.c (rs6000coff_core_p): Likewise.
	* sco5-core.c (sco5_core_file_p): Likewise.
@
text
@d1825 7
d2789 9
d3847 5
@


1.66
log
@Special handling of AIX xcoff text alignment fix.
@
text
@d3 1
a3 1
   2000, 2001
d1683 1
a1683 1
	  *ps = (*ps)->next;
@


1.65
log
@Minimal handle .typchk and .except section.
@
text
@d3057 30
a3086 1
	  sofar = BFD_ALIGN (sofar, 1 << current->alignment_power);
@


1.64
log
@	* aout-encap.c: Fix comment typos.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mips.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m32r.c: Likewise.
	* libcoff-in.h: Likewise.
	* libecoff.h: Likewise.
	* libxcoff.h: Likewise.
	* nlm32-i386.c: Likewise.
	* pdp11.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libcoff.h: Likewise.
@
text
@d431 8
@


1.63
log
@Fix compile time warnings
@
text
@d920 1
a920 1
		/* This must the the second symbol with the
@


1.62
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d1441 4
a1444 1
      && default_alignment > alignment_table[i].default_alignment_max)
@


1.61
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1074 1
a1074 1
	     bfd_get_filename (abfd), name, unhandled, flag);
d4197 1
a4197 1
		     bfd_get_filename (abfd), dst.l_addr.l_symndx);
d4211 1
a4211 1
		     bfd_get_filename (abfd),
d4570 1
a4570 1
		 bfd_get_filename (abfd), src->u.syment.n_sclass,
d4701 1
a4701 1
	 bfd_get_filename (abfd),
d4808 1
a4808 1
		 bfd_get_filename (abfd), dst.r_symndx);
d4846 1
a4846 1
	     bfd_get_filename (abfd), dst.r_type, (long) dst.r_vaddr);
@


1.60
log
@	* coffcode.h (coff_write_object_contents): Add ATTRIBUTE_UNUSED to
	silence warning.
	* coffgen.c (coff_print_symbol): Fix warnings.
	(coff_find_nearest_line): Likewise.
	* cofflink.c (_bfd_coff_link_input_bfd): Likewise.
	* coff-alpha.c (alpha_convert_external_reloc): Likewise.
	* format.c (bfd_check_format_matches): Likewise.
	(bfd_set_format): Likewise.
	* coff-ia64.c: Add missing prototypes.
	* elf64-alpha.c (struct alpha_elf_link_hash_entry): Make addend
	signed to silence warnings.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_find_reloc_at_ofs): Fix warnings.
	(elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_final_link): Likewise.
	(elf64_alpha_relax_section): Remove redundant assign to info.gotent.
	(elf64_alpha_merge_gots): Add ATTRIBUTE_UNUSED to unused args.
	(elf64_alpha_size_got_sections): Likewise.
	* elfxx-ia64.c: Add missing prototypes.
	(elfNN_ia64_relocate_section): Fix warning.
	(elfNN_ia64_unwind_entry_compare): Make params const.
@
text
@d251 31
a281 33
.
.       {* Remembers the offset from the first symbol in the file for
.          this symbol. Generated by coff_renumber_symbols. *}
.unsigned int offset;
.
.       {* Should the value of this symbol be renumbered.  Used for
.          XCOFF C_BSTAT symbols.  Set by coff_slurp_symbol_table.  *}
.unsigned int fix_value : 1;
.
.       {* Should the tag field of this symbol be renumbered.
.          Created by coff_pointerize_aux. *}
.unsigned int fix_tag : 1;
.
.       {* Should the endidx field of this symbol be renumbered.
.          Created by coff_pointerize_aux. *}
.unsigned int fix_end : 1;
.
.       {* Should the x_csect.x_scnlen field be renumbered.
.          Created by coff_pointerize_aux. *}
.unsigned int fix_scnlen : 1;
.
.       {* Fix up an XCOFF C_BINCL/C_EINCL symbol.  The value is the
.          index into the line number entries.  Set by
.          coff_slurp_symbol_table.  *}
.unsigned int fix_line : 1;
.
.       {* The container for the symbol structure as read and translated
.           from the file. *}
.
.union {
.   union internal_auxent auxent;
.   struct internal_syment syment;
. } u;
d289 2
a290 2
.   {* The actual symbol which the rest of BFD works with *}
.asymbol symbol;
d292 2
a293 2
.   {* A pointer to the hidden information for this symbol *}
.combined_entry_type *native;
d295 2
a296 2
.   {* A pointer to the linenumber information for this symbol *}
.struct lineno_cache_entry *lineno;
d298 2
a299 2
.   {* Have the line numbers been relocated yet ? *}
.boolean done_lineno;
d325 1
a325 1
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
d330 1
a330 1
static PTR buy_and_read PARAMS ((bfd *, file_ptr, int, size_t));
d369 1
a369 1
     CONST char *sec_name;
d509 1
a509 1
  /* skip CONSTRUCTOR */
d731 1
a731 1
  
d918 1
d925 2
a926 2
		section->comdat =
		  bfd_alloc (abfd, sizeof (struct bfd_comdat_info));
d933 2
a934 1
		newname = bfd_alloc (abfd, strlen (symname) + 1);
d984 1
a984 1
      
d1009 1
a1009 1
#endif	
d1066 1
a1066 1
	  break;	  
d1092 1
a1092 1
  
d1125 125
a1249 195
.  void (*_bfd_coff_swap_aux_in) PARAMS ((
.       bfd            *abfd,
.       PTR             ext,
.       int             type,
.       int             class,
.       int             indaux,
.       int             numaux,
.       PTR             in));
.
.  void (*_bfd_coff_swap_sym_in) PARAMS ((
.       bfd            *abfd ,
.       PTR             ext,
.       PTR             in));
.
.  void (*_bfd_coff_swap_lineno_in) PARAMS ((
.       bfd            *abfd,
.       PTR            ext,
.       PTR             in));
.

Special entry points for gas to swap out coff parts:

. unsigned int (*_bfd_coff_swap_aux_out) PARAMS ((
.       bfd   	*abfd,
.       PTR	in,
.       int    	type,
.       int    	class,
.       int     indaux,
.       int     numaux,
.       PTR    	ext));
.
. unsigned int (*_bfd_coff_swap_sym_out) PARAMS ((
.      bfd      *abfd,
.      PTR	in,
.      PTR	ext));
.
. unsigned int (*_bfd_coff_swap_lineno_out) PARAMS ((
.      	bfd   	*abfd,
.      	PTR	in,
.	PTR	ext));
.
. unsigned int (*_bfd_coff_swap_reloc_out) PARAMS ((
.      	bfd     *abfd,
.     	PTR	src,
.	PTR	dst));
.
. unsigned int (*_bfd_coff_swap_filehdr_out) PARAMS ((
.      	bfd  	*abfd,
.	PTR 	in,
.	PTR 	out));
.
. unsigned int (*_bfd_coff_swap_aouthdr_out) PARAMS ((
.      	bfd 	*abfd,
.	PTR 	in,
.	PTR	out));
.
. unsigned int (*_bfd_coff_swap_scnhdr_out) PARAMS ((
.      	bfd  	*abfd,
.      	PTR	in,
.	PTR	out));
.

Special entry points for generic COFF routines to call target
dependent COFF routines:

. unsigned int _bfd_filhsz;
. unsigned int _bfd_aoutsz;
. unsigned int _bfd_scnhsz;
. unsigned int _bfd_symesz;
. unsigned int _bfd_auxesz;
. unsigned int _bfd_relsz;
. unsigned int _bfd_linesz;
. unsigned int _bfd_filnmlen;
. boolean _bfd_coff_long_filenames;
. boolean _bfd_coff_long_section_names;
. unsigned int _bfd_coff_default_section_alignment_power;
. boolean _bfd_coff_force_symnames_in_strings;
. unsigned int _bfd_coff_debug_string_prefix_length;
. void (*_bfd_coff_swap_filehdr_in) PARAMS ((
.       bfd     *abfd,
.       PTR     ext,
.       PTR     in));
. void (*_bfd_coff_swap_aouthdr_in) PARAMS ((
.       bfd     *abfd,
.       PTR     ext,
.       PTR     in));
. void (*_bfd_coff_swap_scnhdr_in) PARAMS ((
.       bfd     *abfd,
.       PTR     ext,
.       PTR     in));
. void (*_bfd_coff_swap_reloc_in) PARAMS ((
.       bfd     *abfd,
.       PTR     ext,
.       PTR     in));
. boolean (*_bfd_coff_bad_format_hook) PARAMS ((
.       bfd     *abfd,
.       PTR     internal_filehdr));
. boolean (*_bfd_coff_set_arch_mach_hook) PARAMS ((
.       bfd     *abfd,
.       PTR     internal_filehdr));
. PTR (*_bfd_coff_mkobject_hook) PARAMS ((
.       bfd     *abfd,
.       PTR     internal_filehdr,
.       PTR     internal_aouthdr));
. boolean (*_bfd_styp_to_sec_flags_hook) PARAMS ((
.       bfd     *abfd,
.       PTR     internal_scnhdr,
.       const char *name,
.       asection *section,
.       flagword *flags_ptr));
. void (*_bfd_set_alignment_hook) PARAMS ((
.       bfd     *abfd,
.       asection *sec,
.       PTR     internal_scnhdr));
. boolean (*_bfd_coff_slurp_symbol_table) PARAMS ((
.       bfd     *abfd));
. boolean (*_bfd_coff_symname_in_debug) PARAMS ((
.       bfd     *abfd,
.       struct internal_syment *sym));
. boolean (*_bfd_coff_pointerize_aux_hook) PARAMS ((
.       bfd *abfd,
.       combined_entry_type *table_base,
.       combined_entry_type *symbol,
.       unsigned int indaux,
.       combined_entry_type *aux));
. boolean (*_bfd_coff_print_aux) PARAMS ((
.       bfd *abfd,
.       FILE *file,
.       combined_entry_type *table_base,
.       combined_entry_type *symbol,
.       combined_entry_type *aux,
.       unsigned int indaux));
. void (*_bfd_coff_reloc16_extra_cases) PARAMS ((
.       bfd     *abfd,
.       struct bfd_link_info *link_info,
.       struct bfd_link_order *link_order,
.       arelent *reloc,
.       bfd_byte *data,
.       unsigned int *src_ptr,
.       unsigned int *dst_ptr));
. int (*_bfd_coff_reloc16_estimate) PARAMS ((
.       bfd *abfd,
.       asection *input_section,
.       arelent *r,
.       unsigned int shrink,
.       struct bfd_link_info *link_info));
. enum coff_symbol_classification (*_bfd_coff_classify_symbol) PARAMS ((
.       bfd *abfd,
.       struct internal_syment *));
. boolean (*_bfd_coff_compute_section_file_positions) PARAMS ((
.       bfd *abfd));
. boolean (*_bfd_coff_start_final_link) PARAMS ((
.       bfd *output_bfd,
.       struct bfd_link_info *info));
. boolean (*_bfd_coff_relocate_section) PARAMS ((
.       bfd *output_bfd,
.       struct bfd_link_info *info,
.       bfd *input_bfd,
.       asection *input_section,
.       bfd_byte *contents,
.       struct internal_reloc *relocs,
.       struct internal_syment *syms,
.       asection **sections));
. reloc_howto_type *(*_bfd_coff_rtype_to_howto) PARAMS ((
.       bfd *abfd,
.       asection *sec,
.       struct internal_reloc *rel,
.       struct coff_link_hash_entry *h,
.       struct internal_syment *sym,
.       bfd_vma *addendp));
. boolean (*_bfd_coff_adjust_symndx) PARAMS ((
.       bfd *obfd,
.       struct bfd_link_info *info,
.       bfd *ibfd,
.       asection *sec,
.       struct internal_reloc *reloc,
.       boolean *adjustedp));
. boolean (*_bfd_coff_link_add_one_symbol) PARAMS ((
.       struct bfd_link_info *info,
.       bfd *abfd,
.       const char *name,
.       flagword flags,
.       asection *section,
.       bfd_vma value,
.       const char *string,
.       boolean copy,
.       boolean collect,
.       struct bfd_link_hash_entry **hashp));
.
. boolean (*_bfd_coff_link_output_has_begun) PARAMS ((
.	bfd * abfd,
.       struct coff_final_link_info * pfinfo));
. boolean (*_bfd_coff_final_link_postscript) PARAMS ((
.	bfd * abfd,
.	struct coff_final_link_info * pfinfo));
d1253 2
a1254 1
.#define coff_backend_info(abfd) ((bfd_coff_backend_data *) (abfd)->xvec->backend_data)
d1257 1
a1257 1
.        ((coff_backend_info (a)->_bfd_coff_swap_aux_in) (a,e,t,c,ind,num,i))
d1260 1
a1260 1
.        ((coff_backend_info (a)->_bfd_coff_swap_sym_in) (a,e,i))
d1263 1
a1263 1
.        ((coff_backend_info ( a)->_bfd_coff_swap_lineno_in) (a,e,i))
d1266 1
a1266 1
.        ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_out) (abfd, i, o))
d1269 1
a1269 1
.        ((coff_backend_info (abfd)->_bfd_coff_swap_lineno_out) (abfd, i, o))
d1272 1
a1272 1
.        ((coff_backend_info (a)->_bfd_coff_swap_aux_out) (a,i,t,c,ind,num,o))
d1275 1
a1275 1
.        ((coff_backend_info (abfd)->_bfd_coff_swap_sym_out) (abfd, i, o))
d1278 1
a1278 1
.        ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_out) (abfd, i, o))
d1281 1
a1281 1
.        ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_out) (abfd, i, o))
d1284 1
a1284 1
.        ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o))
d1294 2
a1295 1
.#define bfd_coff_long_filenames(abfd) (coff_backend_info (abfd)->_bfd_coff_long_filenames)
d1297 1
a1297 1
.        (coff_backend_info (abfd)->_bfd_coff_long_section_names)
d1299 1
a1299 1
.	 (coff_backend_info (abfd)->_bfd_coff_default_section_alignment_power)
d1301 1
a1301 1
.        ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_in) (abfd, i, o))
d1304 1
a1304 1
.        ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_in) (abfd, i, o))
d1307 1
a1307 1
.        ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_in) (abfd, i, o))
d1310 1
a1310 1
.        ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_in) (abfd, i, o))
d1313 1
a1313 1
.        ((coff_backend_info (abfd)->_bfd_coff_bad_format_hook) (abfd, filehdr))
d1316 1
a1316 1
.        ((coff_backend_info (abfd)->_bfd_coff_set_arch_mach_hook) (abfd, filehdr))
d1318 1
a1318 1
.        ((coff_backend_info (abfd)->_bfd_coff_mkobject_hook) (abfd, filehdr, aouthdr))
d1321 2
a1322 2
.        ((coff_backend_info (abfd)->_bfd_styp_to_sec_flags_hook)\
.         (abfd, scnhdr, name, section, flags_ptr))
d1325 1
a1325 1
.        ((coff_backend_info (abfd)->_bfd_set_alignment_hook) (abfd, sec, scnhdr))
d1328 1
a1328 1
.        ((coff_backend_info (abfd)->_bfd_coff_slurp_symbol_table) (abfd))
d1331 1
a1331 1
.        ((coff_backend_info (abfd)->_bfd_coff_symname_in_debug) (abfd, sym))
d1334 1
a1334 1
.    	(coff_backend_info (abfd)->_bfd_coff_force_symnames_in_strings)
d1337 1
a1337 1
.    	(coff_backend_info (abfd)->_bfd_coff_debug_string_prefix_length)
d1340 2
a1341 2
.        ((coff_backend_info (abfd)->_bfd_coff_print_aux)\
.         (abfd, file, base, symbol, aux, indaux))
d1344 2
a1345 2
.        ((coff_backend_info (abfd)->_bfd_coff_reloc16_extra_cases)\
.         (abfd, link_info, link_order, reloc, data, src_ptr, dst_ptr))
d1348 2
a1349 2
.        ((coff_backend_info (abfd)->_bfd_coff_reloc16_estimate)\
.         (abfd, section, reloc, shrink, link_info))
d1352 2
a1353 2
.        ((coff_backend_info (abfd)->_bfd_coff_classify_symbol)\
.         (abfd, sym))
d1356 2
a1357 2
.        ((coff_backend_info (abfd)->_bfd_coff_compute_section_file_positions)\
.         (abfd))
d1360 2
a1361 2
.        ((coff_backend_info (obfd)->_bfd_coff_start_final_link)\
.         (obfd, info))
d1363 2
a1364 2
.        ((coff_backend_info (ibfd)->_bfd_coff_relocate_section)\
.         (obfd, info, ibfd, o, con, rel, isyms, secs))
d1366 2
a1367 2
.        ((coff_backend_info (abfd)->_bfd_coff_rtype_to_howto)\
.         (abfd, sec, rel, h, sym, addendp))
d1369 2
a1370 2
.        ((coff_backend_info (abfd)->_bfd_coff_adjust_symndx)\
.         (obfd, info, ibfd, sec, rel, adjustedp))
d1372 2
a1373 2
.        ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\
.         (info, abfd, name, flags, section, value, string, cp, coll, hashp))
d1376 1
a1376 1
.        ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a,p))
d1378 1
a1378 1
.        ((coff_backend_info (a)->_bfd_coff_final_link_postscript) (a,p))
d1480 1
d1498 2
a1499 2
  native = ((combined_entry_type *)
	    bfd_zalloc (abfd, sizeof (combined_entry_type) * 10));
d1581 1
d1597 2
a1598 2
      section->used_by_bfd =
	(PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata));
d1607 2
a1608 2
      coff_section_data (abfd, section)->tdata =
	(PTR) bfd_zalloc (abfd, sizeof (struct pei_section_tdata));
d1625 3
a1627 3
      int oldpos = bfd_tell (abfd);
      bfd_seek (abfd, hdr->s_relptr, 0);
      if (bfd_read ((PTR) & dst, 1, bfd_coff_relsz (abfd), abfd)
d1633 1
a1633 2
      section->reloc_count =
	hdr->s_nreloc = n.r_vaddr;
d1661 1
a1661 1
  real_sec = coff_section_from_bfd_index (abfd, hdr->s_nreloc);
d1697 1
d1699 1
a1699 1
  abfd->tdata.coff_obj_data = (struct coff_tdata *) bfd_zalloc (abfd, sizeof (coff_data_type));
d1807 1
a1807 1
  long machine;
d1967 1
d1969 1
a1969 1
		buf = (bfd_byte *) bfd_malloc (bfd_coff_symesz (abfd));
d1971 1
a1971 2
		    || (bfd_read (buf, 1, bfd_coff_symesz (abfd), abfd)
			!= bfd_coff_symesz (abfd)))
d2262 1
a2262 1
#ifdef XCOFF64 
d2350 12
a2361 6
      /* sort relocations before we write them out */
      p = (arelent **) bfd_malloc (s->reloc_count * sizeof (arelent *));
      if (p == NULL && s->reloc_count > 0)
	return false;
      memcpy (p, s->orelocation, s->reloc_count * sizeof (arelent *));
      qsort (p, s->reloc_count, sizeof (arelent *), compare_arelent_ptr);
d2376 2
a2377 2
	  if (bfd_write ((PTR) & dst, 1, bfd_coff_relsz (abfd), abfd)
	      != bfd_coff_relsz (abfd))
d2400 1
a2400 1
	      int i;
d2403 1
a2403 1
	      for (i = first_undef; outsyms[i]; i++)
d2405 1
a2405 1
		  const char *intable = outsyms[i]->name;
d2408 1
a2408 1
		    q->sym_ptr_ptr = outsyms + i;
d2455 2
a2456 2
	  if (bfd_write ((PTR) & dst, 1, bfd_coff_relsz (abfd), abfd)
	      != bfd_coff_relsz (abfd))
d2932 1
a2932 1
    int count;
d2934 1
a2934 1
    int i;
d2936 1
d2943 2
a2944 1
    section_list = bfd_malloc (sizeof (struct asection *) * (count + 1));
d3008 2
a3009 2
	  current->used_by_bfd =
	    (PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata));
d3015 3
a3017 2
	  coff_section_data (abfd, current)->tdata =
	    (PTR) bfd_zalloc (abfd, sizeof (struct pei_section_tdata));
d3122 1
a3122 1
	  || bfd_write (&b, 1, 1, abfd) != 1)
d3155 1
d3160 1
a3160 1
      CONST char *name;
d3192 3
a3194 1
  sympp2 = (asymbol **) bfd_alloc (abfd, nsyms * sizeof (asymbol *));
d3314 1
a3314 1
#ifndef XCOFF64	  
d3319 1
a3319 1
#endif	  
d3469 2
d3472 1
a3472 2
	      || bfd_write ((PTR) (&buff), 1, bfd_coff_scnhsz (abfd), abfd)
	      != bfd_coff_scnhsz (abfd))
d3572 1
a3572 1
#ifndef XCOFF64  
d3581 1
d3594 1
d3596 1
a3596 2
	      || bfd_write ((PTR) &buff, 1, bfd_coff_scnhsz (abfd), abfd)
	      != bfd_coff_scnhsz (abfd))
d3623 1
a3623 1
#ifndef XCOFF64	  
d3628 1
a3628 1
#endif	  
d3842 1
a3842 1
		    BFD_ALIGN (sym_base, COFF_PAGE_SIZE) - 1,
d3844 1
a3844 1
	  || bfd_write (&b, 1, 1, abfd) != 1)
d3968 1
a3968 1
    bfd_size_type amount;
d3970 1
a3970 1
    buff = bfd_malloc (bfd_coff_filhsz (abfd));
d3974 2
a3975 2
    bfd_coff_swap_filehdr_out (abfd, (PTR) & internal_f, (PTR) buff);
    amount = bfd_write ((PTR) buff, 1, bfd_coff_filhsz (abfd), abfd);
d3988 1
a3988 1
      bfd_size_type amount;
d3990 1
a3990 1
      buff = bfd_malloc (bfd_coff_aoutsz (abfd));
d3994 2
a3995 2
      coff_swap_aouthdr_out (abfd, (PTR) & internal_a, (PTR) buff);
      amount = bfd_write ((PTR) buff, 1, bfd_coff_aoutsz (abfd), abfd);
d4014 1
a4014 1
      if (bfd_write ((PTR) &buff, 1, size, abfd) != size)
d4081 1
a4081 1
  if (bfd_seek (abfd, (file_ptr) (section->filepos + offset), SEEK_SET) != 0)
d4084 4
a4087 5
  if (count != 0)
    {
      return (bfd_write (location, 1, count, abfd) == count) ? true : false;
    }
  return true;
d4117 1
a4117 1
buy_and_read (abfd, where, seek_direction, size)
d4120 1
a4120 2
     int seek_direction;
     size_t size;
d4125 2
a4126 2
  if (bfd_seek (abfd, where, seek_direction) != 0
      || bfd_read (area, 1, size, abfd) != size)
d4162 1
d4166 4
a4169 7
  native_lineno = (LINENO *) buy_and_read (abfd,
					   asect->line_filepos,
					   SEEK_SET,
					   (size_t) (bfd_coff_linesz (abfd) *
						     asect->lineno_count));
  lineno_cache =
    (alent *) bfd_alloc (abfd, (size_t) ((asect->lineno_count + 1) * sizeof (alent)));
d4245 1
d4259 3
a4261 5
  cached_area = ((coff_symbol_type *)
		 bfd_alloc (abfd,
			    (obj_raw_syment_count (abfd)
			     * sizeof (coff_symbol_type))));

d4264 4
a4267 4
  table_ptr = ((unsigned int *)
	       bfd_alloc (abfd,
			  (obj_raw_syment_count (abfd)
			   * sizeof (unsigned int))));
a4764 1

d4766 1
d4776 4
a4779 8
  native_relocs =
    (RELOC *) buy_and_read (abfd,
			    asect->rel_filepos,
			    SEEK_SET,
			    (size_t) (bfd_coff_relsz (abfd) *
				      asect->reloc_count));
  reloc_cache = (arelent *)
    bfd_alloc (abfd, (size_t) (asect->reloc_count * sizeof (arelent)));
@


1.59
log
@Chnage styp_flags_to_sec_flags() to a boolean function
@
text
@d329 1
a329 1
static boolean coff_write_object_contents PARAMS ((bfd *));
@


1.58
log
@Support for xcoff64
@
text
@d315 2
a316 2
static flagword styp_to_sec_flags
  PARAMS ((bfd *, PTR, const char *, asection *));
d556 2
a557 2
static flagword
styp_to_sec_flags (abfd, hdr, name, section)
d562 1
d570 1
a570 1
      sec_flags |= SEC_BLOCK;
d575 1
a575 1
      sec_flags |= SEC_CLINK;
d580 1
a580 3
    {
      sec_flags |= SEC_NEVER_LOAD;
    }
d621 1
a621 3
    {
      sec_flags = 0;
    }
d664 1
a664 3
    {
      sec_flags = SEC_LOAD | SEC_ALLOC | SEC_READONLY;
    }
d667 1
a667 3
    {
      sec_flags |= SEC_ALLOC | SEC_LOAD;
    }
d671 1
a671 3
    {
      sec_flags = (SEC_LOAD | SEC_ALLOC | SEC_READONLY);
    }
d673 1
d676 1
a676 3
    {
      sec_flags = (SEC_LOAD | SEC_ALLOC);
    }
d690 5
a694 1
  return sec_flags;
d963 2
a964 2
static flagword
styp_to_sec_flags (abfd, hdr, name, section)
d969 1
d974 1
d1069 1
a1069 4
      /* If the section flag was not handled, report it here.  This will allow
	 users of the BFD library to report a problem but continue executing.
	 Tools which need to be aware of these problems (such as the linker)
	 can override the default bfd_error_handler to intercept these reports.  */
d1071 6
a1076 3
	(*_bfd_error_handler)
	  (_("%s (%s): Section flag %s (0x%x) ignored"),
	   bfd_get_filename (abfd), name, unhandled, flag);
d1090 4
a1093 1
  return sec_flags;
d1229 1
a1229 1
. flagword (*_bfd_styp_to_sec_flags_hook) PARAMS ((
d1233 2
a1234 1
.       asection *section));
d1388 1
a1388 1
.#define bfd_coff_styp_to_sec_flags_hook(abfd, scnhdr, name, section)\
d1390 1
a1390 1
.         (abfd, scnhdr, name, section))
@


1.57
log
@	* merge.c (struct sec_merge_hash_entry): Add u.entsize and u.suffix
	fields, change sec into secinfo.
	(struct sec_merge_info): Add chain, remove last fields.
	(struct sec_merge_sec_info): Add next, sec, psecinfo fields.
	(sec_merge_hash_lookup): If lookup could not use a string only
	because it has bad alignment, mark the old string for deletion.
	(sec_merge_add): Add secinfo argument. Don't compute entry's
	position, instead record the section.
	(sec_merge_emit): Update for the sec into secinfo change in
	struct sec_merge_hash_entry.
	(_bfd_merge_section): Only record the section for merging, defer
	putting strings into the hash table.
	(cmplengthentry, last4_eq, last_eq, record_section, merge_strings,
	_bfd_merge_sections): New functions.
	(_bfd_merged_section_offset): Update for the sec_merge_hash_entry
	changes.
	* libbfd-in.h (_bfd_merge_sections): Add prototype.
	(_bfd_nolink_bfd_merge_sections): Define.
	* libbfd.h: Likewise.
	(bfd_generic_merge_sections): Add prototype.
	* targets.c (BFD_JUMP_TABLE_LINK): Add _bfd_merge_sections.
	(struct bfd_target): Likewise.
	* bfd.c (bfd_merge_sections): Define.
	* bfd-in2.h: Rebuilt.
	* elf.c (_bfd_elf_merge_sections): New function.
	* elf-bfd.h (_bfd_elf_merge_sections): Add prototype.
	* elfxx-target.h (bfd_elfNN_bfd_merge_sections): Define.
	* reloc.c (bfd_generic_merge_sections): New function.
	* vms.c (vms_bfd_merge_sections): New function.
	* aout-adobe.c (aout_32_bfd_merge_sections): Define.
	* aout-target.h (MY_bfd_merge_sections): Define.
	* aout-tic30.c (MY_bfd_merge_sections): Define.
	* binary.c (binary_bfd_merge_sections): Define.
	* bout.c (b_out_bfd_merge_sections): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_merge_sections): Define.
	* coffcode.c (coff_bfd_merge_sections): Define.
	* coff-mips.c (_bfd_ecoff_bfd_merge_sections): Define.
	* i386msdos.c (msdos_bfd_merge_sections): Define.
	* i386os9k.c (os9k_bfd_merge_sections): Define.
	* ieee.c (ieee_bfd_merge_sections): Define.
	* ihex.c (ihex_bfd_merge_sections): Define.
	* nlm-target.h (nlm_bfd_merge_sections): Define.
	* oasys.c (oasys_bfd_merge_sections): Define.
	* ppcboot.c (ppcboot_bfd_merge_sections): Define.
	* som.c (som_bfd_merge_sections): Define.
	* srec.c (srec_bfd_merge_sections): Define.
	* tekhex.c (tekhex_bfd_merge_sections): Define.
	* versados.c (versados_bfd_merge_sections): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_merge_sections): Define.

	* ldlang.c (lang_process): Call bfd_merge_sections.
@
text
@d2056 2
a2057 15
#ifdef POWERMAC
	    /* PowerPC Macs use the same magic numbers as RS/6000
	       (because that's how they were bootstrapped originally),
	       but they are always PowerPC architecture.  */
	    arch = bfd_arch_powerpc;
	    machine = bfd_mach_ppc;
#else
#ifdef XCOFF64
	    arch = bfd_arch_powerpc;
	    machine = bfd_mach_ppc_620;
#else
	    arch = bfd_arch_rs6000;
	    machine = bfd_mach_rs6k;
#endif
#endif /* POWERMAC */
d2328 5
a2332 1
	  fprintf (file, "val %5ld", aux->u.auxent.x_csect.x_scnlen.l);
d2338 5
a2342 1
	    fprintf (file, "%4ld", aux->u.auxent.x_csect.x_scnlen.l);
d3368 1
d3373 1
d3625 1
d3653 1
d3675 1
d3680 1
d4243 1
a4243 1
	      long symndx;
d4249 1
a4249 1
		  || (unsigned long) symndx >= obj_raw_syment_count (abfd))
@


1.56
log
@* coffcode.h (coff_write_object_contents): Use
bfd_coff_swap_filehdr_out instead of coff_swap_filehdr_out.
@
text
@d5261 4
@


1.55
log
@Update copyright notices
@
text
@d4025 1
a4025 1
    coff_swap_filehdr_out (abfd, (PTR) & internal_f, (PTR) buff);
@


1.54
log
@BFD: Catch & report unhandled PE section flags.
LD: Catch BFD errors whilst loading symbols and do not produce an executable.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.53
log
@formatting fix
@
text
@d342 3
a703 9
/* The PE version; see above for the general comments.

   Since to set the SEC_LINK_ONCE and associated flags, we have to
   look at the symbol table anyway, we return the symbol table index
   of the symbol being used as the COMDAT symbol.  This is admittedly
   ugly, but there's really nowhere else that we have access to the
   required information.  FIXME: Is the COMDAT symbol index used for
   any purpose other than objdump?  */

d705 3
a707 2
styp_to_sec_flags (abfd, hdr, name, section)
     bfd *abfd ATTRIBUTE_UNUSED;
d713 36
a748 2
  long styp_flags = internal_s->s_flags;
  flagword sec_flags = 0;
d750 6
a755 77
  if (styp_flags & STYP_DSECT)
    abort ();  /* Don't know what to do */
#ifdef SEC_NEVER_LOAD
  if (styp_flags & STYP_NOLOAD)
    sec_flags |= SEC_NEVER_LOAD;
#endif
  if (styp_flags & STYP_GROUP)
    abort ();  /* Don't know what to do */
  /* skip IMAGE_SCN_TYPE_NO_PAD */
  if (styp_flags & STYP_COPY)
    abort ();  /* Don't know what to do */
  if (styp_flags & IMAGE_SCN_CNT_CODE)
    sec_flags |= SEC_CODE | SEC_ALLOC | SEC_LOAD;
  if (styp_flags & IMAGE_SCN_CNT_INITIALIZED_DATA)
    sec_flags |= SEC_DATA | SEC_ALLOC | SEC_LOAD;
  if (styp_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA)
    sec_flags |= SEC_ALLOC;
  if (styp_flags & IMAGE_SCN_LNK_OTHER)
    abort ();  /* Don't know what to do */
  if (styp_flags & IMAGE_SCN_LNK_INFO)
    {
      /* We mark these as SEC_DEBUGGING, but only if COFF_PAGE_SIZE is
	 defined.  coff_compute_section_file_positions uses
	 COFF_PAGE_SIZE to ensure that the low order bits of the
	 section VMA and the file offset match.  If we don't know
	 COFF_PAGE_SIZE, we can't ensure the correct correspondence,
	 and demand page loading of the file will fail.  */
#ifdef COFF_PAGE_SIZE
      sec_flags |= SEC_DEBUGGING;
#endif
    }
  if (styp_flags & STYP_OVER)
    abort ();  /* Don't know what to do */
  if (styp_flags & IMAGE_SCN_LNK_REMOVE)
    sec_flags |= SEC_EXCLUDE;

  if (styp_flags & IMAGE_SCN_MEM_SHARED)
    sec_flags |= SEC_SHARED;
  /* COMDAT: see below */
  if (styp_flags & IMAGE_SCN_MEM_DISCARDABLE)
    sec_flags |= SEC_DEBUGGING;
  if (styp_flags & IMAGE_SCN_MEM_NOT_CACHED)
    abort ();/* Don't know what to do */
  if (styp_flags & IMAGE_SCN_MEM_NOT_PAGED)
    abort (); /* Don't know what to do */

  /* We infer from the distinct read/write/execute bits the settings
     of some of the bfd flags; the actual values, should we need them,
     are also in pei_section_data (abfd, section)->pe_flags.  */

  if (styp_flags & IMAGE_SCN_MEM_EXECUTE)
    sec_flags |= SEC_CODE;   /* Probably redundant */
  /* IMAGE_SCN_MEM_READ is simply ignored, assuming it always to be true.  */
  if ((styp_flags & IMAGE_SCN_MEM_WRITE) == 0)
    sec_flags |= SEC_READONLY;

  /* COMDAT gets very special treatment.  */
  if (styp_flags & IMAGE_SCN_LNK_COMDAT)
    {
      sec_flags |= SEC_LINK_ONCE;

      /* Unfortunately, the PE format stores essential information in
         the symbol table, of all places.  We need to extract that
         information now, so that objdump and the linker will know how
         to handle the section without worrying about the symbols.  We
         can't call slurp_symtab, because the linker doesn't want the
         swapped symbols.  */

      /* COMDAT sections are special.  The first symbol is the section
	 symbol, which tells what kind of COMDAT section it is.  The
	 second symbol is the "comdat symbol" - the one with the
	 unique name.  GNU uses the section symbol for the unique
	 name; MS uses ".text" for every comdat section.  Sigh.  - DJ */

      /* This is not mirrored in sec_to_styp_flags(), but there
	 doesn't seem to be a need to, either, and it would at best be
	 rather messy.  */
d757 1
a757 1
      if (_bfd_coff_get_external_symbols (abfd))
d759 26
a784 3
	  bfd_byte *esymstart, *esym, *esymend;
	  int seen_state = 0;
	  char *target_name = NULL;
d786 2
a787 2
	  esymstart = esym = (bfd_byte *) obj_coff_external_syms (abfd);
	  esymend = esym + obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd);
d789 1
a789 1
	  while (esym < esymend)
d791 27
a817 3
	      struct internal_syment isym;
	      char buf[SYMNMLEN + 1];
	      const char *symname;
d819 4
a822 1
	      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &isym);
d824 1
a824 4
	      if (sizeof (internal_s->s_name) > SYMNMLEN)
		{
		  /* This case implies that the matching symbol name
                     will be in the string table.  */
a825 1
		}
d827 33
a859 104
	      if (isym.n_scnum == section->target_index)
		{
		  /* According to the MSVC documentation, the first
		     TWO entries with the section # are both of
		     interest to us.  The first one is the "section
		     symbol" (section name).  The second is the comdat
		     symbol name.  Here, we've found the first
		     qualifying entry; we distinguish it from the
		     second with a state flag.

		     In the case of gas-generated (at least until that
		     is fixed) .o files, it isn't necessarily the
		     second one.  It may be some other later symbol.

		     Since gas also doesn't follow MS conventions and
		     emits the section similar to .text$<name>, where
		     <something> is the name we're looking for, we
		     distinguish the two as follows:

		     If the section name is simply a section name (no
		     $) we presume it's MS-generated, and look at
		     precisely the second symbol for the comdat name.
		     If the section name has a $, we assume it's
		     gas-generated, and look for <something> (whatever
		     follows the $) as the comdat symbol.  */

		  /* All 3 branches use this */
		  symname = _bfd_coff_internal_syment_name (abfd, &isym, buf);

		  if (symname == NULL)
		    abort ();

		  switch (seen_state)
		    {
		    case 0:
		      {
			/* The first time we've seen the symbol.  */
			union internal_auxent aux;

			seen_state = 1;

			/* If it isn't the stuff we're expecting, die;
			   The MS documentation is vague, but it
			   appears that the second entry serves BOTH
			   as the comdat symbol and the defining
			   symbol record (either C_STAT or C_EXT,
			   possibly with an aux entry with debug
			   information if it's a function.)  It
			   appears the only way to find the second one
			   is to count.  (On Intel, they appear to be
			   adjacent, but on Alpha, they have been
			   found separated.)

			   Here, we think we've found the first one,
			   but there's some checking we can do to be
			   sure.  */

			if (! (isym.n_sclass == C_STAT
			       && isym.n_type == T_NULL
			       && isym.n_value == 0))
			  abort ();

			/* FIXME LATER: MSVC generates section names
			   like .text for comdats.  Gas generates
			   names like .text$foo__Fv (in the case of a
			   function).  See comment above for more.  */

			if (strcmp (name, symname) != 0)
			  abort ();

			/* This is the section symbol.  */

			bfd_coff_swap_aux_in (abfd, (PTR) (esym + bfd_coff_symesz (abfd)),
					      isym.n_type, isym.n_sclass,
					      0, isym.n_numaux, (PTR) &aux);

			target_name = strchr (name, '$');
			if (target_name != NULL)
			  {
			    /* Gas mode.  */
			    seen_state = 2;
			    /* Skip the `$'.  */
			    target_name += 1;
			  }

			/* FIXME: Microsoft uses NODUPLICATES and
			   ASSOCIATIVE, but gnu uses ANY and
			   SAME_SIZE.  Unfortunately, gnu doesn't do
			   the comdat symbols right.  So, until we can
			   fix it to do the right thing, we are
			   temporarily disabling comdats for the MS
			   types (they're used in DLLs and C++, but we
			   don't support *their* C++ libraries anyway
			   - DJ.  */

			/* Cygwin does not follow the MS style, and
			   uses ANY and SAME_SIZE where NODUPLICATES
			   and ASSOCIATIVE should be used.  For
			   Interix, we just do the right thing up
			   front.  */

			switch (aux.x_scn.x_comdat)
			  {
			  case IMAGE_COMDAT_SELECT_NODUPLICATES:
d861 1
a861 1
			    sec_flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
d863 1
a863 1
			    sec_flags &= ~SEC_LINK_ONCE;
d865 1
a865 1
			    break;
d867 21
a887 21
			  case IMAGE_COMDAT_SELECT_ANY:
			    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
			    break;

			  case IMAGE_COMDAT_SELECT_SAME_SIZE:
			    sec_flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
			    break;

			  case IMAGE_COMDAT_SELECT_EXACT_MATCH:
			    /* Not yet fully implemented ??? */
			    sec_flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
			    break;

			  /* debug$S gets this case; other
                             implications ??? */

			  /* There may be no symbol... we'll search
			     the whole table... Is this the right
			     place to play this game? Or should we do
			     it when reading it in.  */
			  case IMAGE_COMDAT_SELECT_ASSOCIATIVE:
d889 2
a890 2
			    /* FIXME: This is not currently implemented.  */
			    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
d892 1
a892 1
			    sec_flags &= ~SEC_LINK_ONCE;
d894 1
a894 1
			    break;
d896 8
a903 8
			  default:  /* 0 means "no symbol" */
			    /* debug$F gets this case; other
                               implications ??? */
			    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
			    break;
			  }
	 	      }
		      break;
d905 2
a906 2
		    case 2:
		      /* Gas mode: the first matching on partial name.  */
d911 24
a934 30
		      /* Is this the name we're looking for? */
		      if (strcmp (target_name,
				  symname + (TARGET_UNDERSCORE ? 1 : 0)) != 0)
			{
			    /* Not the name we're looking for */
	                    esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd);
			    continue;
			}
		      /* Fall through.  */
		    case 1:
		      /* MSVC mode: the lexically second symbol (or
			 drop through from the above).  */
		      {
		        char *newname;

			/* This must the the second symbol with the
			   section #.  It is the actual symbol name.
			   Intel puts the two adjacent, but Alpha (at
			   least) spreads them out.  */

		        section->comdat =
			  bfd_alloc (abfd, sizeof (struct bfd_comdat_info));
		        if (section->comdat == NULL)
		          abort ();
		        section->comdat->symbol =
			  (esym - esymstart) / bfd_coff_symesz (abfd);

		        newname = bfd_alloc (abfd, strlen (symname) + 1);
		        if (newname == NULL)
		          abort ();
d936 2
a937 2
		        strcpy (newname, symname);
		        section->comdat->name = newname;
d939 3
a941 1
		      }
d943 3
a945 3
		      goto breakloop;
		    }
		}
d947 1
a947 1
	      esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd);
a948 3
	breakloop:
	  /* SunOS requires a statement after any label.  */
	  ;
d950 130
@


1.53.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.53.2.2
log
@Merge from mainline.
@
text
@a342 3
#ifdef COFF_WITH_PE
static flagword handle_COMDAT PARAMS ((bfd *, flagword, PTR, const char *, asection *));
#endif
d702 9
d712 2
a713 3
handle_COMDAT (abfd, sec_flags, hdr, name, section)
     bfd * abfd;
     flagword sec_flags;
d719 2
a720 34
  bfd_byte *esymstart, *esym, *esymend;
  int seen_state = 0;
  char *target_name = NULL;

  sec_flags |= SEC_LINK_ONCE;

  /* Unfortunately, the PE format stores essential information in
     the symbol table, of all places.  We need to extract that
     information now, so that objdump and the linker will know how
     to handle the section without worrying about the symbols.  We
     can't call slurp_symtab, because the linker doesn't want the
     swapped symbols.  */

  /* COMDAT sections are special.  The first symbol is the section
     symbol, which tells what kind of COMDAT section it is.  The
     second symbol is the "comdat symbol" - the one with the
     unique name.  GNU uses the section symbol for the unique
     name; MS uses ".text" for every comdat section.  Sigh.  - DJ */

  /* This is not mirrored in sec_to_styp_flags(), but there
     doesn't seem to be a need to, either, and it would at best be
     rather messy.  */

  if (! _bfd_coff_get_external_symbols (abfd))
    return sec_flags;
  
  esymstart = esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esymend = esym + obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd);

  while (esym < esymend)
    {
      struct internal_syment isym;
      char buf[SYMNMLEN + 1];
      const char *symname;
d722 83
a804 1
      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &isym);
d806 2
a807 32
      if (sizeof (internal_s->s_name) > SYMNMLEN)
	{
	  /* This case implies that the matching
	     symbol name will be in the string table.  */
	  abort ();
	}

      if (isym.n_scnum == section->target_index)
	{
	  /* According to the MSVC documentation, the first
	     TWO entries with the section # are both of
	     interest to us.  The first one is the "section
	     symbol" (section name).  The second is the comdat
	     symbol name.  Here, we've found the first
	     qualifying entry; we distinguish it from the
	     second with a state flag.

	     In the case of gas-generated (at least until that
	     is fixed) .o files, it isn't necessarily the
	     second one.  It may be some other later symbol.

	     Since gas also doesn't follow MS conventions and
	     emits the section similar to .text$<name>, where
	     <something> is the name we're looking for, we
	     distinguish the two as follows:

	     If the section name is simply a section name (no
	     $) we presume it's MS-generated, and look at
	     precisely the second symbol for the comdat name.
	     If the section name has a $, we assume it's
	     gas-generated, and look for <something> (whatever
	     follows the $) as the comdat symbol.  */
d809 1
a809 7
	  /* All 3 branches use this */
	  symname = _bfd_coff_internal_syment_name (abfd, &isym, buf);

	  if (symname == NULL)
	    abort ();

	  switch (seen_state)
d811 3
a813 4
	    case 0:
	      {
		/* The first time we've seen the symbol.  */
		union internal_auxent aux;
d815 1
a815 1
		seen_state = 1;
d817 4
a820 19
		/* If it isn't the stuff we're expecting, die;
		   The MS documentation is vague, but it
		   appears that the second entry serves BOTH
		   as the comdat symbol and the defining
		   symbol record (either C_STAT or C_EXT,
		   possibly with an aux entry with debug
		   information if it's a function.)  It
		   appears the only way to find the second one
		   is to count.  (On Intel, they appear to be
		   adjacent, but on Alpha, they have been
		   found separated.)

		   Here, we think we've found the first one,
		   but there's some checking we can do to be
		   sure.  */

		if (! (isym.n_sclass == C_STAT
		       && isym.n_type == T_NULL
		       && isym.n_value == 0))
d822 1
d824 104
a927 41
		/* FIXME LATER: MSVC generates section names
		   like .text for comdats.  Gas generates
		   names like .text$foo__Fv (in the case of a
		   function).  See comment above for more.  */

		if (strcmp (name, symname) != 0)
		  abort ();

		/* This is the section symbol.  */
		bfd_coff_swap_aux_in (abfd, (PTR) (esym + bfd_coff_symesz (abfd)),
				      isym.n_type, isym.n_sclass,
				      0, isym.n_numaux, (PTR) &aux);

		target_name = strchr (name, '$');
		if (target_name != NULL)
		  {
		    /* Gas mode.  */
		    seen_state = 2;
		    /* Skip the `$'.  */
		    target_name += 1;
		  }

		/* FIXME: Microsoft uses NODUPLICATES and
		   ASSOCIATIVE, but gnu uses ANY and
		   SAME_SIZE.  Unfortunately, gnu doesn't do
		   the comdat symbols right.  So, until we can
		   fix it to do the right thing, we are
		   temporarily disabling comdats for the MS
		   types (they're used in DLLs and C++, but we
		   don't support *their* C++ libraries anyway
		   - DJ.  */

		/* Cygwin does not follow the MS style, and
		   uses ANY and SAME_SIZE where NODUPLICATES
		   and ASSOCIATIVE should be used.  For
		   Interix, we just do the right thing up
		   front.  */

		switch (aux.x_scn.x_comdat)
		  {
		  case IMAGE_COMDAT_SELECT_NODUPLICATES:
d929 1
a929 1
		    sec_flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
d931 1
a931 1
		    sec_flags &= ~SEC_LINK_ONCE;
d933 1
a933 1
		    break;
d935 3
a937 3
		  case IMAGE_COMDAT_SELECT_ANY:
		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
		    break;
d939 3
a941 3
		  case IMAGE_COMDAT_SELECT_SAME_SIZE:
		    sec_flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
		    break;
d943 4
a946 4
		  case IMAGE_COMDAT_SELECT_EXACT_MATCH:
		    /* Not yet fully implemented ??? */
		    sec_flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
		    break;
d948 2
a949 2
		    /* debug$S gets this case; other
		       implications ??? */
d951 5
a955 5
		    /* There may be no symbol... we'll search
		       the whole table... Is this the right
		       place to play this game? Or should we do
		       it when reading it in.  */
		  case IMAGE_COMDAT_SELECT_ASSOCIATIVE:
d957 2
a958 2
		    /* FIXME: This is not currently implemented.  */
		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
d960 1
a960 1
		    sec_flags &= ~SEC_LINK_ONCE;
d962 1
a962 1
		    break;
d964 8
a971 8
		  default:  /* 0 means "no symbol" */
		    /* debug$F gets this case; other
		       implications ??? */
		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
		    break;
		  }
	      }
	      break;
d973 2
a974 2
	    case 2:
	      /* Gas mode: the first matching on partial name.  */
d979 30
a1008 14
	      /* Is this the name we're looking for? */
	      if (strcmp (target_name,
			  symname + (TARGET_UNDERSCORE ? 1 : 0)) != 0)
		{
		  /* Not the name we're looking for */
		  esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd);
		  continue;
		}
	      /* Fall through.  */
	    case 1:
	      /* MSVC mode: the lexically second symbol (or
		 drop through from the above).  */
	      {
		char *newname;
d1010 2
a1011 9
		/* This must the the second symbol with the
		   section #.  It is the actual symbol name.
		   Intel puts the two adjacent, but Alpha (at
		   least) spreads them out.  */

		section->comdat =
		  bfd_alloc (abfd, sizeof (struct bfd_comdat_info));
		if (section->comdat == NULL)
		  abort ();
d1013 1
a1013 2
		section->comdat->symbol =
		  (esym - esymstart) / bfd_coff_symesz (abfd);
d1015 3
a1017 3
		newname = bfd_alloc (abfd, strlen (symname) + 1);
		if (newname == NULL)
		  abort ();
d1019 1
a1019 5
		strcpy (newname, symname);
		section->comdat->name = newname;
	      }

	      goto breakloop;
d1021 3
a1024 130

      esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd);
    }

 breakloop:
  return sec_flags;
}


/* The PE version; see above for the general comments.

   Since to set the SEC_LINK_ONCE and associated flags, we have to
   look at the symbol table anyway, we return the symbol table index
   of the symbol being used as the COMDAT symbol.  This is admittedly
   ugly, but there's really nowhere else that we have access to the
   required information.  FIXME: Is the COMDAT symbol index used for
   any purpose other than objdump?  */

static flagword
styp_to_sec_flags (abfd, hdr, name, section)
     bfd *abfd;
     PTR hdr;
     const char *name;
     asection *section;
{
  struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
  long styp_flags = internal_s->s_flags;
  flagword sec_flags;

  /* Assume read only unless IMAGE_SCN_MEM_WRITE is specified.  */
  sec_flags = SEC_READONLY;

  /* Process each flag bit in styp_flags in turn.  */
  while (styp_flags)
    {
      long flag = styp_flags & - styp_flags;
      char * unhandled = NULL;
      
      styp_flags &= ~ flag;

      /* We infer from the distinct read/write/execute bits the settings
	 of some of the bfd flags; the actual values, should we need them,
	 are also in pei_section_data (abfd, section)->pe_flags.  */

      switch (flag)
	{
	case STYP_DSECT:
	  unhandled = "STYP_DSECT";
	  break;
	case STYP_GROUP:
	  unhandled = "STYP_GROUP";
	  break;
	case STYP_COPY:
	  unhandled = "STYP_COPY";
	  break;
	case STYP_OVER:
	  unhandled = "STYP_OVER";
	  break;
#ifdef SEC_NEVER_LOAD
	case STYP_NOLOAD:
	  sec_flags |= SEC_NEVER_LOAD;
	  break;
#endif	
	case IMAGE_SCN_MEM_READ:
	  /* Ignored, assume it always to be true.  */
	  break;
	case IMAGE_SCN_TYPE_NO_PAD:
	  /* Skip.  */
	  break;
	case IMAGE_SCN_LNK_OTHER:
	  unhandled = "IMAGE_SCN_LNK_OTHER";
	  break;
	case IMAGE_SCN_MEM_NOT_CACHED:
	  unhandled = "IMAGE_SCN_MEM_NOT_CACHED";
	  break;
	case IMAGE_SCN_MEM_NOT_PAGED:
	  unhandled = "IMAGE_SCN_MEM_NOT_PAGED";
	  break;
	case IMAGE_SCN_MEM_EXECUTE:
	  sec_flags |= SEC_CODE;
	  break;
	case IMAGE_SCN_MEM_WRITE:
	  sec_flags &= ~ SEC_READONLY;
	  break;
	case IMAGE_SCN_MEM_DISCARDABLE:
	  sec_flags |= SEC_DEBUGGING;
	  break;
	case IMAGE_SCN_MEM_SHARED:
	  sec_flags |= SEC_SHARED;
	  break;
	case IMAGE_SCN_LNK_REMOVE:
	  sec_flags |= SEC_EXCLUDE;
	  break;
	case IMAGE_SCN_CNT_CODE:
	  sec_flags |= SEC_CODE | SEC_ALLOC | SEC_LOAD;
	  break;
	case IMAGE_SCN_CNT_INITIALIZED_DATA:
	  sec_flags |= SEC_DATA | SEC_ALLOC | SEC_LOAD;
	  break;
	case IMAGE_SCN_CNT_UNINITIALIZED_DATA:
	  sec_flags |= SEC_ALLOC;
	  break;
	case IMAGE_SCN_LNK_INFO:
	  /* We mark these as SEC_DEBUGGING, but only if COFF_PAGE_SIZE is
	     defined.  coff_compute_section_file_positions uses
	     COFF_PAGE_SIZE to ensure that the low order bits of the
	     section VMA and the file offset match.  If we don't know
	     COFF_PAGE_SIZE, we can't ensure the correct correspondence,
	     and demand page loading of the file will fail.  */
#ifdef COFF_PAGE_SIZE
	  sec_flags |= SEC_DEBUGGING;
#endif
	  break;
	case IMAGE_SCN_LNK_COMDAT:
	  /* COMDAT gets very special treatment.  */
	  sec_flags = handle_COMDAT (abfd, sec_flags, hdr, name, section);
	  break;
	default:
	  /* Silently ignore for now.  */
	  break;	  
	}

      /* If the section flag was not handled, report it here.  This will allow
	 users of the BFD library to report a problem but continue executing.
	 Tools which need to be aware of these problems (such as the linker)
	 can override the default bfd_error_handler to intercept these reports.  */
      if (unhandled != NULL)
	(*_bfd_error_handler)
	  (_("%s (%s): Section flag %s (0x%x) ignored"),
	   bfd_get_filename (abfd), name, unhandled, flag);
d3969 1
a3969 1
    bfd_coff_swap_filehdr_out (abfd, (PTR) & internal_f, (PTR) buff);
@


1.52
log
@Fixes to allow sources to compile under Solaris 2.8
@
text
@a4928 1

@


1.51
log
@Generalize DWARF2 and COFF support.
@
text
@d1020 3
a1022 1
	  breakloop:
@


1.50
log
@2000-11-28  Kazu Hirata  <kazu@@hxi.com>

	* aoutx.h: Fix formatting.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffswap.h: Likewise.
	* corefile.c: Likewise.
@
text
@d352 13
d402 1
a402 1
  else if (!strcmp (sec_name, ".debug"))
d404 5
a408 5
#ifdef STYP_DEBUG
      styp_flags = STYP_DEBUG;
#else
      styp_flags = STYP_INFO;
#endif
d412 7
a418 4
#ifdef COFF_ALIGN_IN_S_FLAGS
      styp_flags = STYP_DSECT;
#else
      styp_flags = STYP_INFO;
a419 1
    }
d644 1
a644 1
  else if (strcmp (name, ".debug") == 0
d647 3
@


1.49
log
@2000-11-27  Philip Blundell  <pb@@futuretv.com>

	* libcoff-in.h (coff_tdata): Add `strings_written' flag.
	(obj_coff_strings_written): New accessor macro for above.
	* libcoff.h: Regenerate.
	* cofflink.c (_bfd_coff_final_link): Say that we wrote the
	strings.
	* coffcode.h (coff_write_object_contents): No need to write out
	the string table if it's already been done.
@
text
@a177 1

a302 1

d508 2
a509 2
  if (sec_flags & SEC_LINK_ONCE) 
    styp_flags |= IMAGE_SCN_LNK_COMDAT; 
d517 1
a517 1
  styp_flags |= IMAGE_SCN_MEM_READ;       /* always readable. */
d525 1
a525 1
  return styp_flags; 
d551 1
a551 1
#endif  
d556 1
a556 1
#endif  
d755 1
a755 1
  /* IMAGE_SCN_MEM_READ is simply ignored, assuming it always to be true. */
d874 1
a874 1
  
d909 1
a909 1
#ifdef STRICT_PE_FORMAT 
d961 1
a961 1
		      if (strcmp (target_name, 
d969 1
a969 1
		    case 1: 
d980 1
a980 1
		        section->comdat = 
d1229 1
a1229 1
.       flagword flags, 
d1234 1
a1234 1
.       boolean collect, 
d1619 1
a1619 1
      
d1767 1
a1767 1
#ifdef ARM 
d1772 1
a1772 1
  
d1807 1
a1807 1
      break; 
d1959 1
a1959 1
		    || (bfd_read (buf, 1, bfd_coff_symesz (abfd), abfd) 
d2116 1
a2116 1
            (_("Unrecognized TI COFF target id '0x%x'"), 
d2384 1
a2384 1
	     have to look up the output symbol here. */
d2579 1
a2579 1
	  
d2582 1
a2582 1
	  
d2614 1
a2614 1
      /* Just overwrite the usual value if we're doing Lynx. */
d2645 1
a2645 1
      /* Just overwrite the usual value if we're doing Lynx. */
d2700 1
a2700 1
      /* Just overwrite the usual value if we're doing Lynx. */
d2738 1
a2738 1
	*magicp = U803XTOCMAGIC; 
d2741 1
a2741 1
    	*magicp = U802TOCMAGIC; 
d2752 1
a2752 1
      
a2767 1

d2784 1
a2784 1
  return true;			/* We're easy ... */
d2812 1
a2812 1
/* Calculate the file position for each section. */
d2874 1
a2874 1
  if (coff_data (abfd)->link_info) 
d3023 1
a3023 1
	 doesn't yet page from files... */
d3355 1
a3355 1
      section.s_page = coff_get_section_load_page (current); 
d3429 1
a3429 1
#ifdef TIC80COFF 
d3579 1
a3579 1
  /* OK, now set up the filehdr... */
d3655 1
a3655 1
    /* ...and the "opt"hdr... */
d3717 1
a3717 1
#endif 
d3727 1
a3727 1
#endif 
d3939 1
a3939 1
  
d3943 1
a3943 1
    
d3945 1
a3945 1
    if (buff == NULL) 
d3947 1
a3947 1
    
d3950 1
a3950 1
    
d3952 1
a3952 1
    
d3956 1
a3956 1
  
d3959 2
a3960 2
      /* Note that peicode.h fills in a PEAOUTHDR, not an AOUTHDR. 
	 include/coff/pe.h sets AOUTSZ == sizeof(PEAOUTHDR)) */
d3965 1
a3965 1
      if (buff == NULL) 
d3967 1
a3967 1
      
d3970 1
a3970 1
      
d3972 1
a3972 1
      
d4030 1
a4030 1
  
d4051 1
a4051 1
       see if the filepos has not been set. */
d4208 1
a4208 1
  /* FIXME, free native_lineno here, or use alloca or something. */
d4328 1
a4328 1
		  break; 
d4375 1
a4375 1
#if defined ARM 
d4540 1
a4540 1
	      /* New storage classes for TI COFF */ 
a4712 1

a4766 1

a4886 1

a4909 1

d5138 1
a5138 1
#ifndef coff_bfd_copy_private_bfd_data 
d5150 1
a5150 1
#ifndef coff_bfd_print_private_bfd_data 
@


1.48
log
@Add ARM v5t, v5te and XScale support
@
text
@d3801 1
a3801 1
  else if (long_section_names)
@


1.47
log
@* peigen.c (_bfd_pei_swap_scnhdr_out): note extended relocs
* coffcode.h (coff_set_alignment_hook): read extended reloc count
(coff_write_relocs): write extended reloc count
(coff_write_object_contents): account for extended relocs
@
text
@d2599 4
a2602 1
	case bfd_mach_arm_5T: * flagsp |= F_ARM_5;  break; /* XXX - we do not have an F_ARM_5T */
@


1.46
log
@Fix bugs detecting w65 architecture.
@
text
@d1610 17
d2356 16
d3212 1
a3212 1
  unsigned long reloc_size = 0;
d3243 10
a3252 1
    reloc_size += current->reloc_count * bfd_coff_relsz (abfd);
d3275 5
@


1.45
log
@Minor formatting fixes.
@
text
@d2719 9
a2727 3
    default:			/* Unknown architecture */
      /* return false;  -- fall through to "return false" below, to avoid
       "statement never reached" errors on the one below. */
@


1.44
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d2153 1
a2153 1
  
d5047 1
a5047 1
  COFF_DEFAULT_SECTION_ALIGNMENT_POWER, 
@


1.43
log
@	* archures.c (enum bfd_architecture): #define constants for
	PowerPc and RS6000 machine numbers.
	* bfd-in2.h: Regenerate.
	* coffcode.h (coff_set_arch_mach_hook): #ifdef XCOFF64, set arch
	to bfd_arch_powerpc instead of bfd_arch_rs6000.  Refer to PowerPc
	and RS6000 machine numbers using #defined constants from
	archures.c.
	* cpu-powerpc.c (arch_info_struct): Refer to PowerPc and RS6000
	machine numbers using #defined constants from archures.c.  Add
	entries for EC603e, 630, A35, RS64II, RS64III, 7400.  Specify
	64-bit words in 620 entry.
	* cpu-rs6000.c (arch_info_struct): Create with entries for RS1,
	RSC, and RS2.
	(bfd_rs6000_arch): Change default machine to 0 (bfd_mach_rs6k).
@
text
@d1469 2
a1470 2
     bfd *abfd;
     asection *section;
d3345 1
a3345 1
#ifdef RS6000COFF_C 
d3398 1
a3398 1
	           != bfd_coff_scnhsz (abfd))
d3520 1
a3520 1
	           != bfd_coff_scnhsz (abfd))
d4441 1
a4441 1
	    case C_FCN:		/* ".bf" or ".ef" (or PE ".lf")	 */
@


1.42
log
@	* coffcode.h (coff_mkobject_hook): Set xcoff_tdata.xcoff64.
	* libcoff-in.h (struct xcoff_tdata): Define xcoff64 field.
	* libcoff.h (struct xcoff_tdata): Define xcoff64 field.
@
text
@d1969 1
a1969 1
	    machine = 0;
a1970 1
	    arch = bfd_arch_rs6000;
d1972 2
a1973 1
	    machine = 620;
d1975 2
a1976 1
	    machine = 6000;
d1983 1
a1983 1
	    machine = 601;
d1987 1
a1987 1
	    machine = 620;
d1991 1
a1991 1
	    machine = 0;
d1995 1
a1995 1
	    machine = 6000;
d2702 2
a2703 1
      if (bfd_get_mach (abfd) == 620 && !strncmp (abfd->xvec->name,"aix", 3))
@


1.41
log
@bfd:
	* coffcode.h (coff_set_arch_mach_hook, coff_set_flags):
	Change U802TOC64MAGIC to U803XTOCMAGIC.

include:
	* coff/rs6k64.h (U802TOC64MAGIC): Change to U803XTOCMAGIC.
@
text
@d1734 5
@


1.40
log
@	* coffcode.h Copy changes mistakenly done to libcoff.h in
	4/24/2000 patch.
@
text
@d1913 1
a1913 1
    case U802TOC64MAGIC:
d2697 1
a2697 1
	*magicp = U802TOC64MAGIC; 
@


1.39
log
@	Add XCOFF64 support.

	bfd:
	* Makefile.am (coff64-rs6000.lo): New rule.
	* Makefile.in: Regenerate.
	* coff-rs6000.c (xcoff_mkobject, xcoff_copy_private_bfd_data,
	xcoff_is_local_label_name, xcoff_rtype2howto,
	xcoff_reloc_type_lookup, xcoff_slurp_armap, xcoff_archive_p,
	xcoff_read_ar_hdr, xcoff_openr_next_archived_file, xcoff_write_armap,
	xcoff_write_archive_contents): No longer static, and prefix with _bfd_.
	(NO_COFF_SYMBOLS): Define.
	(xcoff64_swap_sym_in, xcoff64_swap_sym_out, xcoff64_swap_aux_in,
	xcoff64_swap_aux_out): New functions; handle xcoff symbol tables
	internally.
	(MINUS_ONE): New macro.
	(xcoff_howto_tabl, xcoff_reloc_type_lookup): Add 64 bit POS
	relocation.
	(coff_SWAP_sym_in, coff_SWAP_sym_out, coff_SWAP_aux_in,
	coff_SWAP_aux_out): Map to the new functions.
	* coff64-rs6000.c: New file.
	* libcoff.h (bfd_coff_backend_data): Add new fields
	_bfd_coff_force_symnames_in_strings and
	_bfd_coff_debug_string_prefix_length.
	(bfd_coff_force_symnames_in_strings,
	bfd_coff_debug_string_prefix_length): New macros for above fields.
	* coffcode.h (coff_set_arch_mach_hook): Handle XCOFF64 magic.
	Set machine to 620 for XCOFF64.  Use bfd_coff_swap_sym_in instead
	of using coff_swap_sym_in directly.
	(FORCE_SYMNAMES_IN_STRINGS): New macro, defined for XCOFF64.
	(coff_set_flags) Set magic for XCOFF64.
	(coff_compute_section_file_positions): Add symbol name length to
	string section length if bfd_coff_debug_string_prefix_length is
	true.
	(coff_write_object_contents): Don't do reloc overflow for XCOFF64.
	(coff_slurp_line_table): Use bfd_coff_swap_lineno_in instead of
	using coff_swap_lineno_in directly.
	(bfd_coff_backend_data): Add _bfd_coff_force_symnames_in_strings
	and _bfd_coff_debug_string_prefix_length fields.
	* coffgen.c (coff_fix_symbol_name, coff_write_symbols): Force
	symbol names into strings table when
	bfd_coff_force_symnames_in_strings is true.
	* coffswap.h (MAX_SCNHDR_NRELOC, MAX_SCNHDR_NLNNO, GET_RELOC_VADDR,
	SET_RELOC_VADDR): New macros.
	(coff_swap_reloc_in, coff_swap_reloc_out): Use above macros.
	(coff_swap_aux_in, coff_swap_aux_out): Remove RS6000COFF_C
	code.
	(coff_swap_aouthdr_in, coff_swap_aouthdr_out): Handle XCOFF64
	changes within RS6000COFF_C specific code.
	(coff_swap_scnhdr_out): Use PUT_SCNHDR_NLNNO, PUT_SCNHDR_NRELOC,
	MAX_SCNHDR_NRELOC, and MAX_SCNHDR_NLNNO.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation):
	Extend existing hack on target name.
	* xcofflink.c (XCOFF_XVECP): Extend existing hack on
	target name.
	* coff-tic54x.c (ticof): Keep up to date with new fields
	in bfd_coff_backend_data.
	* config.bfd: Add bfd_powerpc_64_arch to targ_arch and define
	targ_selvecs to include rs6000coff64_vec for rs6000.
	* configure.in: Add rs6000coff64_vec case.
 	* cpu-powerpc.c: New bfd_arch_info_type.

	gas:
	* as.c (parse_args): Allow md_parse_option to override -a listing
	option.
	* config/obj-coff.c (add_lineno): Change type of offset parameter
	from "int" to "bfd_vma."
	* config/tc-ppc.c (md_pseudo_table): Add "llong" and "machine."
	(ppc_mach, ppc_subseg_align, ppc_target_format): New.
	(ppc_change_csect): Align correctly for XCOFF64.
	(ppc_machine): New function, which discards "ppc_machine" line.
	(ppc_tc): Cons for 8 when code is 64 bit.
	(md_apply_fix3): Don't check operand->insert.  Handle 64 bit
	relocations.
	(md_parse_option): Handle -a64 and -a32.
	(ppc_xcoff64): New.
	* config/tc-ppc.h (TARGET_MACH): Define.
	(TARGET_FORMAT): Move to function.
	(SUB_SEGMENT_ALIGN): Use ppc_subseg_align.

	include:
	* include/coff/rs6k64.h: New file.

	opcodes:
	* configure.in: Add bfd_powerpc_64_arch.
	* disassemble.c (disassembler): Use print_insn_big_powerpc for
	64 bit code.
@
text
@d1127 2
d1325 6
@


1.38
log
@Bfd support for generating IA-64 EFI binaries.
	* Makefile.am (BFD64_BACKENDS): Mention coff-ia64.lo.
	(BFD64_BACKENDS_CFILES): Mention coff-ia64.c
	(coff-ia64.lo): Add dependency.
	* Makefile.in: Regenerate.
	* coff-ia64.c: New file.
	* efi-app-ia32.c: Ditto.
	* efi-app-ia64.c: Ditto.
	...
@
text
@d1904 3
d1910 1
d1937 1
a1937 1
		coff_swap_sym_in (abfd, (PTR) buf, (PTR) &sym);
d1959 3
d1963 1
d2136 4
d2682 1
a2682 1
#ifdef U802TOCMAGIC
d2687 7
a2693 1
      *magicp = U802TOCMAGIC;
d2801 2
a2802 2
	      if (len > SYMNMLEN)
		sz += len + 3;
d3330 2
a3331 1
#ifdef RS6000COFF_C
d3339 1
d4091 1
a4091 1
	  coff_swap_lineno_in (abfd, src, &dst);
d5032 11
a5042 1
  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
@


1.37
log
@Clean up load page support for tic54x.
@
text
@d1790 6
d2566 6
d3649 5
@


1.36
log
@Mods to allow compilation of BFD all targets.
@
text
@d1534 4
d3256 3
@


1.35
log
@BFD and include/coff support for tic54x target.
@
text
@d2067 1
@


1.34
log
@SEC_BLOCK, SEC_CLINK, and C_STATLAB added (TI COFF support).
@
text
@d401 3
d405 1
d1527 1
a1527 1
  /* TI tools hijack bits 8-11 for the alignment */
d1530 3
d2045 30
d2467 27
d2728 1
a2728 1
#ifdef TIC80COFF
d3320 3
a3322 2
#else
#ifdef TIC80COFF
d3325 2
d3516 5
d3562 4
d4299 2
a4300 1
#ifndef TIC80COFF
d4427 2
a4428 2
	      /* New storage classes for TIc80 */
#ifdef TIC80COFF
@


1.33
log
@Fix building with --enable-targets=all
@
text
@d439 10
d546 10
d4327 5
a4353 1
	    case C_STATLAB:	/* Static load time label */
@


1.33.2.1
log
@Fix typo and code omission preventing the detection of w65 binaries
@
text
@a2584 6
#ifdef W65MAGIC
    case bfd_arch_w65:
      *magicp = W65MAGIC;
      return true;
#endif

@


1.32
log
@Add WinCE support.
@
text
@d763 1
a763 1
	  char *target_name;
@


1.31
log
@* coffcode.h (coff_set_arch_mach_hook): Use free(), because there
is no bfd_free().  Revert bfd_free part of previous change.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d1768 2
d1980 3
d1988 7
d2417 3
d2421 1
d2516 3
d2523 8
d3546 10
@


1.30
log
@* coffcode.h (coff_set_arch_mach_hook): Don't use variable-size
arrays.
(coff_compute_section_file_positions): Use bfd_free to pair
bfd_malloc.
(coff_write_object_contents): Likewise.

* coff-rs6000.c (xcoff_howto_table_16): New variable.
(xcoff_rtype2howto): Handle 16-bit variants of 32-bit relocs.
@
text
@d1891 1
a1891 1
		    bfd_free (buf);
d1899 1
a1899 1
		bfd_free (buf);
d2771 1
a2771 1
    bfd_free (section_list);
d3705 1
a3705 1
    bfd_free (buff);
d3725 1
a3725 1
      bfd_free (buff);
@


1.29
log
@Add hooks to support TI COFF handling.
@
text
@d1883 1
a1883 1
		bfd_byte buf[bfd_coff_symesz (abfd)];
d1886 1
d1888 6
a1893 2
		    || bfd_read (buf, 1, bfd_coff_symesz (abfd), abfd) != bfd_coff_symesz (abfd))
		  return false;
d1899 1
d2771 1
a2771 1
    free (section_list);
d3705 1
a3705 1
    free (buff);
d3725 1
a3725 1
      free (buff);
@


1.28
log
@Remove use of a GCC extension when allocating local arrays.
@
text
@d2271 3
d2275 1
@


1.27
log
@Applied Tim Wall's patch to replace RELSZ and friends with bfd_coff_relsz and
friends.
@
text
@d3683 1
d3685 7
a3691 1
    char buff[bfd_coff_filhsz (abfd)];
d3693 5
a3697 2
    if (bfd_write ((PTR) buff, 1, bfd_coff_filhsz (abfd), abfd)
	!= bfd_coff_filhsz (abfd))
d3700 1
d3705 7
a3711 1
      char buff[bfd_coff_aoutsz (abfd)];
d3713 5
a3717 1
      if (bfd_write ((PTR) buff, 1, bfd_coff_aoutsz (abfd), abfd) != bfd_coff_aoutsz (abfd))
@


1.26
log
@1999-09-13  Donn Terry  <donn@@interix.com>

	* coffcode.h (styp_to_sec_flags): Further refinement of COMDAT
	handling to support both GNU and MS objects.
@
text
@d766 1
a766 1
	  esymend = esym + obj_raw_syment_count (abfd) * SYMESZ;
d855 1
a855 1
			bfd_coff_swap_aux_in (abfd, (PTR) (esym + SYMESZ),
d943 1
a943 1
	                    esym += (isym.n_numaux + 1) * SYMESZ;
d963 1
a963 1
			  (esym - esymstart) / SYMESZ;
d978 1
a978 1
	      esym += (isym.n_numaux + 1) * SYMESZ;
d1365 1
a1365 1
  if (internal_f->f_opthdr != 0 && AOUTSZ != internal_f->f_opthdr)
d1675 3
a1677 3
  coff->local_symesz = SYMESZ;
  coff->local_auxesz = AUXESZ;
  coff->local_linesz = LINESZ;
d1688 1
a1688 1
  if (aouthdr != NULL && internal_f->f_opthdr >= AOUTSZ)
d1883 1
a1883 1
		bfd_byte buf[SYMESZ];
d1887 1
a1887 1
		    || bfd_read (buf, 1, SYMESZ, abfd) != SYMESZ)
d2296 2
a2297 1
	  if (bfd_write ((PTR) & dst, 1, RELSZ, abfd) != RELSZ)
d2617 1
a2617 1
  file_ptr sofar = FILHSZ;
d2684 1
a2684 1
    sofar += AOUTSZ;
d2687 1
a2687 1
    sofar += AOUTSZ;
d2692 1
a2692 1
  sofar += abfd->section_count * SCNHSZ;
d2699 1
a2699 1
      sofar += SCNHSZ;
d3019 1
a3019 1
  lnno_size = coff_count_linenumbers (abfd) * LINESZ;
d3033 1
a3033 1
    reloc_size += current->reloc_count * RELSZ;
d3046 1
a3046 1
	  lineno_base += current->lineno_count * LINESZ;
d3055 1
a3055 1
	  reloc_base += current->reloc_count * RELSZ;
d3067 1
a3067 1
    scn_base = FILHSZ + AOUTSZ;
d3070 1
a3070 1
      scn_base = FILHSZ;
d3073 1
a3073 1
	scn_base += AOUTSZ;
d3218 2
a3219 1
	      || bfd_write ((PTR) (&buff), 1, SCNHSZ, abfd) != SCNHSZ)
d3340 2
a3341 1
	      || bfd_write ((PTR) &buff, 1, SCNHSZ, abfd) != SCNHSZ)
d3362 1
a3362 1
    internal_f.f_opthdr = AOUTSZ;
d3368 1
a3368 1
	internal_f.f_opthdr = AOUTSZ;
d3684 1
a3684 1
    char buff[FILHSZ];
d3686 2
a3687 1
    if (bfd_write ((PTR) buff, 1, FILHSZ, abfd) != FILHSZ)
d3694 1
a3694 1
      char buff[AOUTSZ];
d3696 1
a3696 1
      if (bfd_write ((PTR) buff, 1, AOUTSZ, abfd) != AOUTSZ)
d3708 1
a3708 1
	size = AOUTSZ;
d3867 1
a3867 1
					   (size_t) (LINESZ *
d4186 1
a4186 1
				      + sec->lineno_count * LINESZ)
d4196 1
a4196 1
					 / LINESZ);
d4478 1
a4478 1
			    (size_t) (RELSZ *
@


1.25
log
@1999-09-13  Donn Terry  <donn@@interix.com>

	* coffcode.h (coff_write_object_contents): Don't check reloc_count
	when determining whether to set F_RELFLG.
@
text
@d762 2
d783 1
a783 9
	      /* The MS documentation is vague, but it appears to
		 require that n_sclass be C_STAT for both entries;
		 However, the Alpha compiler uses C_EXT for the one
		 with the "real" name, at least for string-pooled
		 constants.  */
	      if (isym.n_scnum == section->target_index
		  && (isym.n_sclass == C_STAT || isym.n_sclass == C_EXT)
		  && isym.n_type == T_NULL
		  && isym.n_value == 0)
d785 3
a787 2
		  /* The first TWO entries with the section # are both
		     of interest to us.  The first one is the "section
d789 22
a810 9
		     symbol name.  'value' must be zero for it to
		     apply.  Here, we've found a qualifying entry; we
		     distinguish the first from the second by numaux
		     (which should be 0 for the second).  FIXME: We
		     should use the first one first rather than
		     counting on numaux.  */
		  if (isym.n_numaux == 1)
		    {
		      union internal_auxent aux;
d812 2
a813 22
		      symname = _bfd_coff_internal_syment_name (abfd, &isym,
								buf);
		      if (symname == NULL)
			abort ();

		      if (strcmp (name, symname) != 0)
			abort ();

		      /* This is the section symbol.  */

		      bfd_coff_swap_aux_in (abfd, (PTR) (esym + SYMESZ),
					    isym.n_type, isym.n_sclass,
					    0, isym.n_numaux, (PTR) &aux);

		      /* FIXME: Microsoft uses NODUPLICATES and
			 ASSOCIATIVE, but gnu uses ANY and SAME_SIZE.
			 Unfortunately, gnu doesn't do the comdat
			 symbols right.  So, until we can fix it to do
			 the right thing, we are temporarily disabling
			 comdats for the MS types (they're used in
			 DLLs and C++, but we don't support *their*
			 C++ libraries anyway - DJ.  */
d815 74
a888 5
		      switch (aux.x_scn.x_comdat)
			{
			case IMAGE_COMDAT_SELECT_NODUPLICATES:
#ifdef STRICT_PE_FORMAT
			  sec_flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
d890 1
a890 1
			  sec_flags &= ~SEC_LINK_ONCE;
d892 1
a892 14
			  break;

			case IMAGE_COMDAT_SELECT_ANY:
			  sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
			  break;

			case IMAGE_COMDAT_SELECT_SAME_SIZE:
			  sec_flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
			  break;

			case IMAGE_COMDAT_SELECT_EXACT_MATCH:
			  /* Not yet fully implemented in the linker.  */
			  sec_flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
			  break;
d894 21
a914 1
			case IMAGE_COMDAT_SELECT_ASSOCIATIVE:
d916 2
a917 2
			  /* FIXME: This is not currently implemented.  */
			  sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
d919 1
a919 1
			  sec_flags &= ~SEC_LINK_ONCE;
d921 10
a930 1
			  break;
d932 13
a944 5
			default:
			  /* FIXME: Shouldn't this be at least a
                             warning?  */
			  sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
			  break;
d946 25
a970 4
		    }
		  else 
		    {
		      char *newname;
d972 1
a972 20
		      /* This should be the the second symbol with the
			 section #.  It is the actual symbol name.
			 Intel puts the two adjacent, but Alpha (at
			 least) spreads them out.  */

		      section->comdat =
			bfd_alloc (abfd, sizeof (struct bfd_comdat_info));
		      if (section->comdat == NULL)
			abort ();
		      section->comdat->symbol = (esym - esymstart) / SYMESZ;
		      symname = _bfd_coff_internal_syment_name (abfd, &isym,
								buf);
		      if (symname == NULL)
			abort ();

		      newname = bfd_alloc (abfd, strlen (symname) + 1);
		      if (newname == NULL)
			abort ();
		      strcpy (newname, symname);
		      section->comdat->name = newname;
d974 1
a974 1
		      break;
d980 1
@


1.24
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* config.bfd (i[3456]86-*-interix*): Set targ_cflags to
	-DSTRICT_PE_FORMAT.
	* coffcode.h (styp_to_sec_flags): Check STRICT_PE_FORMAT rather
	than __INTERIX.
	(coff_classify_symbol): Re-revert 1999-08-08 patch if
	STRICT_PE_FORMAT.
@
text
@d3075 2
d3079 1
@


1.23
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* coffcode.h (coff_mkobject_hook): Set timestamp field in
	coff_data_type to f_timdat.
	* peicode.h (pe_mkobject_hook): Likewise.
@
text
@d830 1
a830 2
/* FIXME: This is bogus.  It breaks cross-compilers.  */
#ifdef __INTERIX
d851 1
a851 2
/* FIXME: This is bogus.  It breaks cross-compilers.  */
#ifdef __INTERIX
d4266 1
a4266 1
#if 0
@


1.22
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* coffcode.h (coff_mkobject_hook): If COFF_WITH_PE, set HAS_DEBUG
	to the reverse of IMAGE_FILE_DEBUG_STRIPPED.
	(coff_write_object_contents): Set IMAGE_FILE_DEBUG_STRIPPED if
	there is no SEC_DEBUGGING section.
	* peicode.h (pe_mkobject_hook): Set HAS_DEBUG to the reverse of
	IMAGE_FILE_DEBUG_STRIPPED.
@
text
@d1597 2
@


1.21
log
@	* coff-ppc.c (COFF_SECTION_ALIGNMENT_ENTRIES): Define.

1999-09-11  Donn Terry  <donn@@interix.com>

	* coffcode.h (coff_set_alignment_hook): Delete POWERPC_LE_PE
	special handling.
@
text
@d1630 7
d2912 1
d3003 1
a3003 3

#ifdef COFF_WITH_PE
      /* If we've got a .reloc section, remember. */
d3008 2
a3013 1
#endif
d3079 3
d3290 4
@


1.20
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* coffcode.h (coff_slurp_symbol_table): If PE, set BSF_DEBUGGING
	for C_FCN/C_EFCN symbols, and set BSF_DEBUGGING_RELOC for such
	symbols named .bf.
@
text
@a1460 31
#ifdef POWERPC_LE_PE
  if (strcmp (section->name, ".idata$2") == 0)
    {
      section->alignment_power = 0;
    }
  else if (strcmp (section->name, ".idata$3") == 0)
    {
      section->alignment_power = 0;
    }
  else if (strcmp (section->name, ".idata$4") == 0)
    {
      section->alignment_power = 2;
    }
  else if (strcmp (section->name, ".idata$5") == 0)
    {
      section->alignment_power = 2;
    }
  else if (strcmp (section->name, ".idata$6") == 0)
    {
      section->alignment_power = 1;
    }
  else if (strcmp (section->name, ".reloc") == 0)
    {
      section->alignment_power = 1;
    }
  else if (strncmp (section->name, ".stab", 5) == 0)
    {
      section->alignment_power = 2;
    }
#endif

@


1.19
log
@	* coffcode.h (bfd_coff_backend_data): Add _bfd_filnmlen field.
	(bfd_coff_filnmlen): Define.
	(bfd_coff_std_swap_table): Initialize new field.
	* coffgen.c (coff_fix_symbol_name): Use bfd_coff_filnmlen rather
	than FILNMLEN.
	(coff_write_symbols): Likewise.
	(coff_get_normalized_symtab): Likewise.
	* coff-sh.c (bfd_coff_small_swap_table): Initialize new field.
	* libcoff.h: Rebuild.
@
text
@d4142 1
a4142 1
	    case C_FCN:		/* ".bf" or ".ef"		 */
a4143 1
	      dst->symbol.flags = BSF_LOCAL;
d4148 8
d4159 1
@


1.18
log
@reformat for 80 column screen
@
text
@d1017 1
d1179 1
d4718 1
a4718 3


static CONST bfd_coff_backend_data bfd_coff_std_swap_table =
d4725 1
a4725 1
  FILHSZ, AOUTSZ, SCNHSZ, SYMESZ, AUXESZ, RELSZ, LINESZ,
@


1.17
log
@1999-09-06  Donn Terry  <donn@@interix.com>

	* coffcode.h (sort_by_secaddr): New static function if
	COFF_IMAGE_WITH_PE.
	(coff_compute_section_file_positions): If COFF_IMAGE_WITH_PE, sort
	sections by VMA when assigning target_index values.  Always set
	virt_size.
@
text
@d4816 47
a4862 45
const bfd_target VAR =										\
{												\
  NAME ,											\
  bfd_target_coff_flavour,									\
  BFD_ENDIAN_BIG,		/* data byte order is big */					\
  BFD_ENDIAN_BIG,		/* header byte order is big */					\
  /* object flags */										\
  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |						\
   HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),						\
  /* section flags */										\
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),			\
  UNDER,			/* leading symbol underscore */					\
  '/',				/* ar_pad_char */						\
  15,				/* ar_max_namelen */						\
  												\
  /* Data conversion functions.  */								\
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,							\
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,							\
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,							\
  												\
  /* Header conversion functions.  */								\
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,							\
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,							\
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,							\
												\
	/* bfd_check_format */									\
  { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p, _bfd_dummy_target },		\
	/* bfd_set_format */									\
  { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },				\
	/* bfd_write_contents */								\
  { bfd_false, coff_write_object_contents, _bfd_write_archive_contents, bfd_false },		\
												\
  BFD_JUMP_TABLE_GENERIC (coff),								\
  BFD_JUMP_TABLE_COPY (coff),									\
  BFD_JUMP_TABLE_CORE (_bfd_nocore),								\
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),							\
  BFD_JUMP_TABLE_SYMBOLS (coff),								\
  BFD_JUMP_TABLE_RELOCS (coff),									\
  BFD_JUMP_TABLE_WRITE (coff),									\
  BFD_JUMP_TABLE_LINK (coff),									\
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),							\
  												\
  ALTERNATIVE,											\
  												\
  COFF_SWAP_TABLE										\
d4866 45
a4910 43
const bfd_target VAR =										\
{												\
  NAME ,											\
  bfd_target_coff_flavour,									\
  BFD_ENDIAN_LITTLE,		/* data byte order is little */					\
  BFD_ENDIAN_LITTLE,		/* header byte order is little */				\
	/* object flags */									\
  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |						\
   HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),						\
	/* section flags */									\
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),			\
  UNDER,			/* leading symbol underscore */					\
  '/',				/* ar_pad_char */						\
  15,				/* ar_max_namelen */						\
												\
  /* Data conversion functions.  */								\
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,							\
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,							\
  bfd_getl16, bfd_getl_signed_16, bfd_putl16,							\
  /* Header conversion functions.  */								\
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,							\
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,							\
  bfd_getl16, bfd_getl_signed_16, bfd_putl16,							\
	/* bfd_check_format */									\
  { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p, _bfd_dummy_target },		\
       /* bfd_set_format */									\
  { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },				\
	/* bfd_write_contents */								\
  { bfd_false, coff_write_object_contents, _bfd_write_archive_contents, bfd_false },		\
												\
  BFD_JUMP_TABLE_GENERIC (coff),								\
  BFD_JUMP_TABLE_COPY (coff),									\
  BFD_JUMP_TABLE_CORE (_bfd_nocore),								\
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),							\
  BFD_JUMP_TABLE_SYMBOLS (coff),								\
  BFD_JUMP_TABLE_RELOCS (coff),									\
  BFD_JUMP_TABLE_WRITE (coff),									\
  BFD_JUMP_TABLE_LINK (coff),									\
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),							\
												\
  ALTERNATIVE,											\
  												\
  COFF_SWAP_TABLE										\
@


1.16
log
@remove unneeded ifdefs
@
text
@d2514 24
a2555 1
  unsigned int count;
d2639 72
d2712 1
a2712 1
  for (current = abfd->sections, count = 1;
d2714 1
a2714 1
       current = current->next, ++count)
d2717 10
a2726 5
      /* The NT loader does not want empty section headers, so we omit
         them.  We don't actually remove the section from the BFD,
         although we probably should.  This matches code in
         coff_write_object_contents.  */
      if (current->_raw_size == 0)
d2728 4
a2731 3
	  current->target_index = -1;
	  --count;
	  continue;
d2733 2
d2737 3
a2739 1
      current->target_index = count;
d2741 3
a2743 2
      /* Only deal with sections which have contents */
      if (!(current->flags & SEC_HAS_CONTENTS))
d2745 1
d2777 1
a2777 20
      /* With PE we have to pad each section to be a multiple of its
	 page size too, and remember both sizes.  */

      if (coff_section_data (abfd, current) == NULL)
	{
	  current->used_by_bfd =
	    (PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata));
	  if (current->used_by_bfd == NULL)
	    return false;
	}
      if (pei_section_data (abfd, current) == NULL)
	{
	  coff_section_data (abfd, current)->tdata =
	    (PTR) bfd_zalloc (abfd, sizeof (struct pei_section_tdata));
	  if (coff_section_data (abfd, current)->tdata == NULL)
	    return false;
	}
      if (pei_section_data (abfd, current)->virt_size == 0)
	pei_section_data (abfd, current)->virt_size = current->_raw_size;

@


1.15
log
@1999-09-06  Donn Terry  <donn@@interix.com>

	* libcoff-in.h (struct pei_section_tdata): Add pe_flags field.
	* coffcode.h (coff_set_alignment_hook): Set pe_flags field if
	COFF_WITH_PE.
	* libcoff.h: Rebuild.
@
text
@a1489 1
#ifdef COFF_WITH_PE
a1517 1
#endif /* COFF_WITH_PE */
@


1.14
log
@1999-09-06  Donn Terry  <donn@@interix.com>

	* coffcode.h (coff_set_custom_section_alignment): Add const to
	declaration to match definition.
	(coff_write_object_contents): Don't set F_AR32W(R)? if
	COFF_WITH_PE.
@
text
@d1490 1
a1490 1
#ifdef COFF_IMAGE_WITH_PE
d1492 4
a1495 2
     section, while the s_size field holds the raw size.  */
  if (hdr->s_paddr != 0)
d1497 3
a1499 1
      if (coff_section_data (abfd, section) == NULL)
d1501 2
a1502 7
	  section->used_by_bfd =
	    (PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata));
	  if (section->used_by_bfd == NULL)
	    {
	      /* FIXME: Return error.  */
	      abort ();
	    }
d1504 6
a1509 1
      if (pei_section_data (abfd, section) == NULL)
d1511 2
a1512 7
	  coff_section_data (abfd, section)->tdata =
	    (PTR) bfd_zalloc (abfd, sizeof (struct pei_section_tdata));
	  if (coff_section_data (abfd, section)->tdata == NULL)
	    {
	      /* FIXME: Return error.  */
	      abort ();
	    }
a1513 1
      pei_section_data (abfd, section)->virt_size = hdr->s_paddr;
d1515 2
a1516 1
#endif
a1517 1
#ifdef COFF_WITH_PE
d1519 1
a1519 1
#endif
@


1.13
log
@1999-09-06  Donn Terry  <donn@@interix.com>

	* coffcode.h (sec_to_styp_flags): Write separate COFF_WITH_PE
	version.  Move COFF_WITH_PE specific code to new version.
	(stype_to_sec_flags): Likewise.  Add section parameter.
	* coffgen.c (make_a_section_from_file): Set target_index before
	calling styp_to_sec_flags.  Pass section to styp_to_sec_flags.
	* libcoff.h: Rebuild.
@
text
@d321 1
a321 1
	   unsigned int));
d3226 1
a3226 1
  /* FIXME: this is wrong for PPC_PE! */
d3231 1
@


1.12
log
@1999-08-18  Donn Terry  <donn@@interix.com>

	* coff-i386.c (coff_i386_reloc): Handle R_IMAGEBASE.
	(RTYPE2HOWTO): Return NULL if reloc type is out of range.
	(coff_i386_rtype_to_howto): Likewise.
	* coffcode.h (coff_slurp_symbol_table): Change a -2 to N_DEBUG.
	Completely ignore symbols which are all zero.
	(dummy_reloc16_estimate): Add return 0.
	* cofflink.c (_bfd_coff_link_input_bfd): Rename inner scope
	variable copy to name_copy to avoid shadowing outer scope
	variable.
	* libcoff-in.h (coff_data_type): Change raw_syment_count field
	from unsigned int to unsigned long.  Add timestamp field.
	* libcoff.h: Rebuild.

Also comment changes.
@
text
@d316 2
a317 1
static flagword styp_to_sec_flags PARAMS ((bfd *, PTR, const char *));
d347 7
a353 6
/*
 * Return a word with STYP_* (scnhdr.s_flags) flags set to represent the
 * incoming SEC_* flags.  The inverse of this function is styp_to_sec_flags().
 * NOTE: If you add to/change this routine, you should mirror the changes
 * 	in styp_to_sec_flags().
 */
a402 6
#ifdef COFF_WITH_PE
  else if (!strcmp (sec_name, ".edata"))
    {
      styp_flags = STYP_DATA;
    }
#endif
d444 43
a486 2
#ifdef COFF_WITH_PE
  if (sec_flags & SEC_LINK_ONCE)
d488 22
d511 1
a511 2
    styp_flags |= IMAGE_SCN_MEM_SHARED;
#endif
d513 1
a513 1
  return (styp_flags);
d515 10
a524 7
/*
 * Return a word with SEC_* flags set to represent the incoming
 * STYP_* flags (from scnhdr.s_flags).   The inverse of this
 * function is sec_to_styp_flags().
 * NOTE: If you add to/change this routine, you should mirror the changes
 *      in sec_to_styp_flags().
 */
d526 1
a526 1
styp_to_sec_flags (abfd, hdr, name)
d530 1
d645 69
a713 1
#ifdef COFF_WITH_PE
d719 17
d737 1
d751 1
a751 1
	 *second* symbol is the "comdat symbol" - the one with the
d755 4
d761 1
a761 1
	  bfd_byte *esym, *esymend;
d763 1
a763 1
	  esym = (bfd_byte *) obj_coff_external_syms (abfd);
d769 2
d781 7
a787 1
	      if (isym.n_sclass == C_STAT
d789 1
a789 1
		  && isym.n_numaux == 1)
d791 12
a802 2
		  char buf[SYMNMLEN + 1];
		  const char *symname;
d804 4
a807 3
		  symname = _bfd_coff_internal_syment_name (abfd, &isym, buf);
		  if (symname == NULL)
		    abort ();
d809 2
a810 3
		  if (strcmp (name, symname) == 0)
		    {
		      union internal_auxent aux;
d825 1
a825 1
			 C++ libraries anyway - DJ */
d830 2
a831 1
#if 0
a837 1
			default:
d847 1
d852 2
a853 1
#if 0
d860 6
d867 25
a900 1
#endif
d913 1
a913 1
  return (sec_flags);
d916 2
d1049 2
a1050 1
.       const char *name));
d1203 3
a1205 2
.#define bfd_coff_styp_to_sec_flags_hook(abfd, scnhdr, name)\
.        ((coff_backend_info (abfd)->_bfd_styp_to_sec_flags_hook) (abfd, scnhdr, name))
@


1.11
log
@1999-08-08  Mark Elbrecht  <snowball3@@bigfoot.com>

	* libcoff-in.h (struct coff_section_alignment_entry): Define.
	* coffcode.h (coff_set_custom_section_alignment): New static
	function.
	(coff_section_alignment_table): New static array.
	(coff_new_section_hook): Use coff_set_customer_section_alignment.
	* coff-go32.c (COFF_SECTION_ALIGNMENT_ENTRIES): Define.
	* coff-stgo32.c (COFF_SECTION_ALIGNMENT_ENTRIES): Define.
	* libcoff.h: Rebuild.
@
text
@d134 1
a134 1
	and @@code{coff_swap_linno_in}. @@code{GDB} reads the symbol
d2752 1
a2752 1
         with the code in coff_write_symbols.  */
d2847 5
a2851 4
      /* suppress output of the sections if they are null.  ld includes
	 the bss and data sections even if there is no size assigned
	 to them.  NT loader doesn't like it if these section headers are
	 included if the sections themselves are not needed */
d3476 3
d3568 4
d3737 1
a3737 1
	      if (src->u.syment.n_scnum == -2)
d3865 7
d4287 1
@


1.10
log
@1999-08-08  Mumit Khan  <khan@@xraylith.wisc.edu>

	* section.c (SEC_SHARED): Define.
	* coffcode.h (sec_to_styp_flags): Handle SEC_SHARED.
	(styp_to_sec_flags): Likewise.
	* peicode.h (coff_swap_scnhdr_out): Likewise.
	* bfd-in2.h: Rebuild.

1999-08-08  Ian Lance Taylor  <ian@@zembu.com>

	* coffcode.h (coff_classify_symbol): Comment out part of
	1999-08-05 change which breaks cygwin DLLs.
@
text
@d318 3
d1082 62
a1143 4
/*
   initialize a section structure with information peculiar to this
   particular implementation of coff
*/
d1147 2
a1148 2
     bfd * abfd;
     asection * section;
d1184 3
a1186 16
  /* The .stab section must be aligned to 2**2 at most, because
     otherwise there may be gaps in the section which gdb will not
     know how to interpret.  Examining the section name is a hack, but
     that is also how gdb locates the section.
     We need to handle the .ctors and .dtors sections similarly, to
     avoid introducing null words in the tables.  */
  if (COFF_DEFAULT_SECTION_ALIGNMENT_POWER > 2
      && (strncmp (section->name, ".stab", 5) == 0
	  || strcmp (section->name, ".ctors") == 0
	  || strcmp (section->name, ".dtors") == 0))
    section->alignment_power = 2;

  /* Similarly, the .stabstr section must be aligned to 2**0 at most.  */
  if (COFF_DEFAULT_SECTION_ALIGNMENT_POWER > 0
      && strncmp (section->name, ".stabstr", 8) == 0)
    section->alignment_power = 0;
@


1.9
log
@	Based on patches from Donn Terry <donn@@interix.com>:
	* coffcode.h (enum coff_symbol_classification): Define.
	(bfd_coff_backend_data): Rename _bfd_coff_sym_is_global to
	_bfd_coff_classify_symbol.  Change return type.
	(bfd_coff_classify_symbol): Rename from bfd_coff_sym_is_global.
	(coff_slurp_symbol_table): Use coff_classify_symbol.
	(coff_classify_symbol): New static function.
	(coff_sym_is_global): Never define.
	(bfd_coff_std_swap_table): Initialize with coff_classify_symbol.
	* cofflink.c (coff_link_check_ar_symbols): Use
	bfd_coff_classify_symbol rather than bfd_coff_sym_is_global.
	(coff_link_add_symbols): Likewise.
	(_bfd_coff_link_input_bfd): Likewise.
	* coff-sh.c (bfd_coff_small_swap_table): Initialize with
	coff_classify_symbol.
	* libcoff.h: Rebuild.
@
text
@d448 2
d584 3
d3919 4
d3935 1
@


1.8
log
@1999-07-21  Mark Elbrecht  <snowball3@@bigfoot.com>

	* coffcode.h (styp_to_sec_flags): If COFF_LONG_SECTION_NAMES and
	COFF_SUPPORT_GNU_LINKONCE, mark sections whose names begin with
	.gnu.linkonce with SEC_LINKONCE and SEC_LINK_DUPLICATES_DISCARD.
	* coff-go32.c: (COFF_LONG_SECTION_NAMES): Define.
	(COFF_SUPPORT_GNU_LINKONCE): Define.
	* coff-stgo32.c: (COFF_LONG_SECTION_NAMES): Define.
	(COFF_SUPPORT_GNU_LINKONCE): Define.
@
text
@d332 2
d714 16
d874 1
a874 1
. boolean (*_bfd_coff_sym_is_global) PARAMS ((
d1014 2
a1015 2
.#define bfd_coff_sym_is_global(abfd, sym)\
.        ((coff_backend_info (abfd)->_bfd_coff_sym_is_global)\
d3590 1
a3590 1
            /* PE uses storage class 0x68 to denote a section symbol */
d3592 1
a3592 1
	    /* PE uses storage class 0x69 for a weak external symbol.  */
d3595 1
a3595 14
	      if ((src->u.syment.n_scnum) == 0)
		{
		  if ((src->u.syment.n_value) == 0)
		    {
		      dst->symbol.section = bfd_und_section_ptr;
		      dst->symbol.value = 0;
		    }
		  else
		    {
		      dst->symbol.section = bfd_com_section_ptr;
		      dst->symbol.value = (src->u.syment.n_value);
		    }
		}
	      else
d3597 1
a3597 3
		  /* Base the value as an index from the base of the
		     section */

a3598 1

a3606 1

d3613 30
a3645 3
	      /* A C_HIDEXT symbol is not global.  */
	      if (src->u.syment.n_sclass == C_HIDEXT)
		dst->symbol.flags = BSF_LOCAL;
d3861 3
a3863 6
/* Check whether a symbol is globally visible.  This is used by the
   COFF backend linker code in cofflink.c, since a couple of targets
   have globally visible symbols which are not class C_EXT.  This
   function need not handle the case of n_class == C_EXT.  */

#undef OTHER_GLOBAL_CLASS
d3865 11
d3877 11
a3887 1
#define OTHER_GLOBAL_CLASS C_LEAFEXT
d3889 12
a3901 3
#ifdef COFFARM
#define OTHER_GLOBAL_CLASS C_THUMBEXT || syment->n_sclass == C_THUMBEXTFUNC
#else
d3903 10
a3912 3
#define OTHER_GLOBAL_CLASS C_SECTION
#endif
#endif
d3914 4
a3917 1
#ifdef OTHER_GLOBAL_CLASS
d3919 7
a3925 1
static boolean coff_sym_is_global PARAMS ((bfd *, struct internal_syment *));
d3927 2
a3928 7
static boolean
coff_sym_is_global (abfd, syment)
     bfd * abfd ATTRIBUTE_UNUSED;
     struct internal_syment * syment;
{
  return (syment->n_sclass == OTHER_GLOBAL_CLASS);
}
d3930 11
a3940 1
#undef OTHER_GLOBAL_CLASS
d3942 1
a3942 1
#else /* ! defined (OTHER_GLOBAL_CLASS) */
d3944 3
a3946 1
/* sym_is_global should not be defined if it has nothing to do.  */
d3948 5
a3952 1
#define coff_sym_is_global 0
d3954 2
a3955 1
#endif /* ! defined (OTHER_GLOBAL_CLASS) */
d4377 1
a4377 1
  coff_sym_is_global, coff_compute_section_file_positions,
@


1.7
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d690 11
@


1.6
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d4355 94
@


1.5
log
@Add support for arm v5 architectures.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d459 1
a459 1
     bfd *abfd;
d1020 1
a1020 1
     bfd * abfd;
d1117 1
a1117 1
     bfd * abfd;
d1157 1
a1157 1
     bfd * abfd;
d1319 1
a1319 1
     PTR aouthdr;
d1681 1
a1681 1
     bfd * abfd;
d1705 1
a1705 1
     bfd *abfd;
d1745 2
a1746 2
     bfd *abfd;
     combined_entry_type *table_base;
d1749 1
a1749 1
     combined_entry_type *aux;
d1774 6
a1779 6
     bfd *abfd;
     FILE *file;
     combined_entry_type *table_base;
     combined_entry_type *symbol;
     combined_entry_type *aux;
     unsigned int indaux;
d1969 2
a1970 2
     unsigned int *magicp;
     unsigned short *flagsp;
d3847 1
a3847 1
     bfd * abfd;
d4034 2
a4035 2
     bfd *abfd;
     asection *sec;
d4037 3
a4039 3
     struct coff_link_hash_entry *h;
     struct internal_syment *sym;
     bfd_vma *addendp;
d4113 5
a4117 5
     bfd *abfd;
     asection *input_section;
     arelent *reloc;
     unsigned int shrink;
     struct bfd_link_info *link_info;
d4137 7
a4143 7
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     arelent *reloc;
     bfd_byte *data;
     unsigned int *src_ptr;
     unsigned int *dst_ptr;
d4194 1
a4194 1
     struct coff_final_link_info * info;
d4207 2
a4208 2
     bfd * abfd;
     struct coff_final_link_info * pfinfo;
@


1.4
log
@Mark Salter  <msalter@@cygnus.com>
        * coffcode.h (coff_set_alignment_hook): Set lma from s_vaddr if
        COFF_WITH_PE defined.
@
text
@d1432 1
d2071 2
@


1.3
log
@Use renamed ARM cpu flag bits
@
text
@d1231 3
@


1.2
log
@	* ecoff.c (_bfd_ecoff_write_armap): give the symtab element a
	reasonable mode until "ar x" is smart enough to skip it (fixes
	gcc/libgcc.a builds on mips-ecoff targets
	* coffcode.h (styp_to_sec_flags): Explain how COMDATs are supposed
	to work.  Hack to support MS import libraries, which use different
	COMDAT types than GNU.
	(coff_slurp_symbol_table): C_SECTION symbols are local; they refer
	to implied zero-length sections (see peicode below)
	* coffgen.c (coff_get_normalized_symtab): Properly read long MS
	filename symbols, which use one *or more* auxents.
	* coffswap.h (coff_swap_aux_in): ditto
	* peicode.h (coff_swap_sym_in): Build the implied zero-length
	sections
@
text
@d1422 7
a1428 5
	case F_ARM_2:  machine = bfd_mach_arm_2;  break;
	case F_ARM_3:  machine = bfd_mach_arm_3;  break;
	default:
	case F_ARM_4:  machine = bfd_mach_arm_4;  break;
	case F_ARM_4T: machine = bfd_mach_arm_4T; break;
d2055 1
a2055 1
	    * flagsp |= F_PIC_INT;
@


1.1
log
@Initial revision
@
text
@d591 6
d638 9
d650 1
d652 3
d671 1
d674 3
d3607 5
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

