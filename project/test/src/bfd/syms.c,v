head	1.60;
access;
symbols
	sid-snapshot-20180601:1.60
	sid-snapshot-20180501:1.60
	sid-snapshot-20180401:1.60
	sid-snapshot-20180301:1.60
	sid-snapshot-20180201:1.60
	sid-snapshot-20180101:1.60
	sid-snapshot-20171201:1.60
	sid-snapshot-20171101:1.60
	sid-snapshot-20171001:1.60
	sid-snapshot-20170901:1.60
	sid-snapshot-20170801:1.60
	sid-snapshot-20170701:1.60
	sid-snapshot-20170601:1.60
	sid-snapshot-20170501:1.60
	sid-snapshot-20170401:1.60
	sid-snapshot-20170301:1.60
	sid-snapshot-20170201:1.60
	sid-snapshot-20170101:1.60
	sid-snapshot-20161201:1.60
	sid-snapshot-20161101:1.60
	sid-snapshot-20160901:1.60
	sid-snapshot-20160801:1.60
	sid-snapshot-20160701:1.60
	sid-snapshot-20160601:1.60
	sid-snapshot-20160501:1.60
	sid-snapshot-20160401:1.60
	sid-snapshot-20160301:1.60
	sid-snapshot-20160201:1.60
	sid-snapshot-20160101:1.60
	sid-snapshot-20151201:1.60
	sid-snapshot-20151101:1.60
	sid-snapshot-20151001:1.60
	sid-snapshot-20150901:1.60
	sid-snapshot-20150801:1.60
	sid-snapshot-20150701:1.60
	sid-snapshot-20150601:1.60
	sid-snapshot-20150501:1.60
	sid-snapshot-20150401:1.60
	sid-snapshot-20150301:1.60
	sid-snapshot-20150201:1.60
	sid-snapshot-20150101:1.60
	sid-snapshot-20141201:1.60
	sid-snapshot-20141101:1.60
	sid-snapshot-20141001:1.60
	sid-snapshot-20140901:1.60
	sid-snapshot-20140801:1.60
	sid-snapshot-20140701:1.60
	sid-snapshot-20140601:1.60
	sid-snapshot-20140501:1.60
	sid-snapshot-20140401:1.60
	sid-snapshot-20140301:1.60
	sid-snapshot-20140201:1.60
	sid-snapshot-20140101:1.60
	sid-snapshot-20131201:1.60
	sid-snapshot-20131101:1.60
	sid-snapshot-20131001:1.60
	binutils-2_24-branch:1.59.0.2
	binutils-2_24-branchpoint:1.59
	binutils-2_21_1:1.55
	sid-snapshot-20130901:1.59
	gdb_7_6_1-2013-08-30-release:1.58
	sid-snapshot-20130801:1.59
	sid-snapshot-20130701:1.59
	sid-snapshot-20130601:1.58
	sid-snapshot-20130501:1.58
	gdb_7_6-2013-04-26-release:1.58
	sid-snapshot-20130401:1.58
	binutils-2_23_2:1.57
	gdb_7_6-branch:1.58.0.2
	gdb_7_6-2013-03-12-branchpoint:1.58
	sid-snapshot-20130301:1.58
	sid-snapshot-20130201:1.58
	sid-snapshot-20130101:1.57
	sid-snapshot-20121201:1.57
	gdb_7_5_1-2012-11-29-release:1.57
	binutils-2_23_1:1.57
	sid-snapshot-20121101:1.57
	binutils-2_23:1.57
	sid-snapshot-20121001:1.57
	sid-snapshot-20120901:1.57
	gdb_7_5-2012-08-17-release:1.57
	sid-snapshot-20120801:1.57
	binutils-2_23-branch:1.57.0.4
	binutils-2_23-branchpoint:1.57
	gdb_7_5-branch:1.57.0.2
	gdb_7_5-2012-07-18-branchpoint:1.57
	sid-snapshot-20120701:1.57
	sid-snapshot-20120601:1.57
	sid-snapshot-20120501:1.56
	binutils-2_22_branch:1.56.0.8
	gdb_7_4_1-2012-04-26-release:1.56
	sid-snapshot-20120401:1.56
	sid-snapshot-20120301:1.56
	sid-snapshot-20120201:1.56
	gdb_7_4-2012-01-24-release:1.56
	sid-snapshot-20120101:1.56
	gdb_7_4-branch:1.56.0.6
	gdb_7_4-2011-12-13-branchpoint:1.56
	sid-snapshot-20111201:1.56
	binutils-2_22:1.56
	sid-snapshot-20111101:1.56
	sid-snapshot-20111001:1.56
	binutils-2_22-branch:1.56.0.4
	binutils-2_22-branchpoint:1.56
	gdb_7_3_1-2011-09-04-release:1.56
	sid-snapshot-20110901:1.56
	sid-snapshot-20110801:1.56
	gdb_7_3-2011-07-26-release:1.56
	sid-snapshot-20110701:1.56
	sid-snapshot-20110601:1.56
	sid-snapshot-20110501:1.56
	gdb_7_3-branch:1.56.0.2
	gdb_7_3-2011-04-01-branchpoint:1.56
	sid-snapshot-20110401:1.56
	sid-snapshot-20110301:1.56
	sid-snapshot-20110201:1.55
	sid-snapshot-20110101:1.55
	binutils-2_21:1.55
	sid-snapshot-20101201:1.55
	binutils-2_21-branch:1.55.0.8
	binutils-2_21-branchpoint:1.55
	sid-snapshot-20101101:1.55
	sid-snapshot-20101001:1.55
	binutils-2_20_1:1.54.2.1
	gdb_7_2-2010-09-02-release:1.55
	sid-snapshot-20100901:1.55
	sid-snapshot-20100801:1.55
	gdb_7_2-branch:1.55.0.6
	gdb_7_2-2010-07-07-branchpoint:1.55
	sid-snapshot-20100701:1.55
	sid-snapshot-20100601:1.55
	sid-snapshot-20100501:1.55
	sid-snapshot-20100401:1.55
	gdb_7_1-2010-03-18-release:1.55
	sid-snapshot-20100301:1.55
	gdb_7_1-branch:1.55.0.4
	gdb_7_1-2010-02-18-branchpoint:1.55
	sid-snapshot-20100201:1.55
	sid-snapshot-20100101:1.55
	gdb_7_0_1-2009-12-22-release:1.55
	sid-snapshot-20091201:1.55
	sid-snapshot-20091101:1.55
	binutils-2_20:1.54.2.1
	gdb_7_0-2009-10-06-release:1.55
	sid-snapshot-20091001:1.55
	gdb_7_0-branch:1.55.0.2
	gdb_7_0-2009-09-16-branchpoint:1.55
	arc-sim-20090309:1.46
	binutils-arc-20081103-branch:1.47.0.12
	binutils-arc-20081103-branchpoint:1.47
	binutils-2_20-branch:1.54.0.2
	binutils-2_20-branchpoint:1.54
	sid-snapshot-20090901:1.53
	sid-snapshot-20090801:1.52
	msnyder-checkpoint-072509-branch:1.52.0.2
	msnyder-checkpoint-072509-branchpoint:1.52
	sid-snapshot-20090701:1.51
	dje-cgen-play1-branch:1.51.0.2
	dje-cgen-play1-branchpoint:1.51
	sid-snapshot-20090601:1.51
	sid-snapshot-20090501:1.51
	sid-snapshot-20090401:1.50
	arc-20081103-branch:1.47.0.10
	arc-20081103-branchpoint:1.47
	arc-insight_6_8-branch:1.46.0.8
	arc-insight_6_8-branchpoint:1.46
	insight_6_8-branch:1.46.0.6
	insight_6_8-branchpoint:1.46
	sid-snapshot-20090301:1.50
	binutils-2_19_1:1.47
	sid-snapshot-20090201:1.50
	sid-snapshot-20090101:1.49
	reverse-20081226-branch:1.49.0.2
	reverse-20081226-branchpoint:1.49
	sid-snapshot-20081201:1.47
	multiprocess-20081120-branch:1.47.0.8
	multiprocess-20081120-branchpoint:1.47
	sid-snapshot-20081101:1.47
	binutils-2_19:1.47
	sid-snapshot-20081001:1.47
	reverse-20080930-branch:1.47.0.6
	reverse-20080930-branchpoint:1.47
	binutils-2_19-branch:1.47.0.4
	binutils-2_19-branchpoint:1.47
	sid-snapshot-20080901:1.47
	sid-snapshot-20080801:1.47
	reverse-20080717-branch:1.47.0.2
	reverse-20080717-branchpoint:1.47
	sid-snapshot-20080701:1.47
	msnyder-reverse-20080609-branch:1.46.0.4
	msnyder-reverse-20080609-branchpoint:1.46
	drow-reverse-20070409-branch:1.42.0.2
	drow-reverse-20070409-branchpoint:1.42
	sid-snapshot-20080601:1.46
	sid-snapshot-20080501:1.46
	sid-snapshot-20080403:1.46
	sid-snapshot-20080401:1.46
	gdb_6_8-2008-03-27-release:1.46
	sid-snapshot-20080301:1.46
	gdb_6_8-branch:1.46.0.2
	gdb_6_8-2008-02-26-branchpoint:1.46
	sid-snapshot-20080201:1.46
	sid-snapshot-20080101:1.46
	sid-snapshot-20071201:1.46
	sid-snapshot-20071101:1.46
	gdb_6_7_1-2007-10-29-release:1.45
	gdb_6_7-2007-10-10-release:1.45
	sid-snapshot-20071001:1.46
	gdb_6_7-branch:1.45.0.4
	gdb_6_7-2007-09-07-branchpoint:1.45
	binutils-2_18:1.45
	binutils-2_18-branch:1.45.0.2
	binutils-2_18-branchpoint:1.45
	insight_6_6-20070208-release:1.41
	binutils-csl-coldfire-4_1-32:1.41
	binutils-csl-sourcerygxx-4_1-32:1.41
	gdb_6_6-2006-12-18-release:1.41
	binutils-csl-innovasic-fido-3_4_4-33:1.41
	binutils-csl-sourcerygxx-3_4_4-32:1.39
	binutils-csl-coldfire-4_1-30:1.41
	binutils-csl-sourcerygxx-4_1-30:1.41
	binutils-csl-coldfire-4_1-28:1.41
	binutils-csl-sourcerygxx-4_1-29:1.41
	binutils-csl-sourcerygxx-4_1-28:1.41
	gdb_6_6-branch:1.41.0.32
	gdb_6_6-2006-11-15-branchpoint:1.41
	binutils-csl-arm-2006q3-27:1.41
	binutils-csl-sourcerygxx-4_1-27:1.41
	binutils-csl-arm-2006q3-26:1.41
	binutils-csl-sourcerygxx-4_1-26:1.41
	binutils-csl-sourcerygxx-4_1-25:1.41
	binutils-csl-sourcerygxx-4_1-24:1.41
	binutils-csl-sourcerygxx-4_1-23:1.41
	insight_6_5-20061003-release:1.41
	gdb-csl-symbian-6_4_50_20060226-12:1.41
	binutils-csl-sourcerygxx-4_1-21:1.41
	binutils-csl-arm-2006q3-21:1.41
	binutils-csl-sourcerygxx-4_1-22:1.41
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.41
	binutils-csl-sourcerygxx-4_1-20:1.41
	binutils-csl-arm-2006q3-19:1.41
	binutils-csl-sourcerygxx-4_1-19:1.41
	binutils-csl-sourcerygxx-4_1-18:1.41
	binutils-csl-renesas-4_1-9:1.41
	gdb-csl-sourcerygxx-3_4_4-25:1.41
	binutils-csl-sourcerygxx-3_4_4-25:1.39
	nickrob-async-20060828-mergepoint:1.41
	gdb-csl-symbian-6_4_50_20060226-11:1.41
	binutils-csl-renesas-4_1-8:1.41
	binutils-csl-renesas-4_1-7:1.41
	binutils-csl-renesas-4_1-6:1.41
	gdb-csl-sourcerygxx-4_1-17:1.41
	binutils-csl-sourcerygxx-4_1-17:1.41
	gdb-csl-20060226-branch-local-2:1.41
	gdb-csl-sourcerygxx-4_1-14:1.41
	binutils-csl-sourcerygxx-4_1-14:1.41
	binutils-csl-sourcerygxx-4_1-15:1.41
	gdb-csl-sourcerygxx-4_1-13:1.41
	binutils-csl-sourcerygxx-4_1-13:1.41
	binutils-2_17:1.41
	gdb-csl-sourcerygxx-4_1-12:1.41
	binutils-csl-sourcerygxx-4_1-12:1.41
	gdb-csl-sourcerygxx-3_4_4-21:1.41
	binutils-csl-sourcerygxx-3_4_4-21:1.41
	gdb_6_5-20060621-release:1.41
	binutils-csl-wrs-linux-3_4_4-24:1.39
	binutils-csl-wrs-linux-3_4_4-23:1.39
	gdb-csl-sourcerygxx-4_1-9:1.41
	binutils-csl-sourcerygxx-4_1-9:1.41
	gdb-csl-sourcerygxx-4_1-8:1.41
	binutils-csl-sourcerygxx-4_1-8:1.41
	gdb-csl-sourcerygxx-4_1-7:1.41
	binutils-csl-sourcerygxx-4_1-7:1.41
	gdb-csl-arm-2006q1-6:1.41
	binutils-csl-arm-2006q1-6:1.41
	gdb-csl-sourcerygxx-4_1-6:1.41
	binutils-csl-sourcerygxx-4_1-6:1.41
	binutils-csl-wrs-linux-3_4_4-22:1.39
	gdb-csl-symbian-6_4_50_20060226-10:1.41
	gdb-csl-symbian-6_4_50_20060226-9:1.41
	gdb-csl-symbian-6_4_50_20060226-8:1.41
	gdb-csl-coldfire-4_1-11:1.41
	binutils-csl-coldfire-4_1-11:1.41
	gdb-csl-sourcerygxx-3_4_4-19:1.41
	binutils-csl-sourcerygxx-3_4_4-19:1.41
	gdb-csl-coldfire-4_1-10:1.41
	gdb_6_5-branch:1.41.0.30
	gdb_6_5-2006-05-14-branchpoint:1.41
	binutils-csl-coldfire-4_1-10:1.41
	gdb-csl-sourcerygxx-4_1-5:1.41
	binutils-csl-sourcerygxx-4_1-5:1.41
	nickrob-async-20060513-branch:1.41.0.28
	nickrob-async-20060513-branchpoint:1.41
	gdb-csl-sourcerygxx-4_1-4:1.41
	binutils-csl-sourcerygxx-4_1-4:1.41
	msnyder-reverse-20060502-branch:1.41.0.26
	msnyder-reverse-20060502-branchpoint:1.41
	binutils-csl-wrs-linux-3_4_4-21:1.39
	gdb-csl-morpho-4_1-4:1.41
	binutils-csl-morpho-4_1-4:1.41
	gdb-csl-sourcerygxx-3_4_4-17:1.41
	binutils-csl-sourcerygxx-3_4_4-17:1.41
	binutils-csl-wrs-linux-3_4_4-20:1.39
	readline_5_1-import-branch:1.41.0.24
	readline_5_1-import-branchpoint:1.41
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.41
	binutils-2_17-branch:1.41.0.22
	binutils-2_17-branchpoint:1.41
	gdb-csl-symbian-20060226-branch:1.41.0.20
	gdb-csl-symbian-20060226-branchpoint:1.41
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.41
	msnyder-reverse-20060331-branch:1.41.0.18
	msnyder-reverse-20060331-branchpoint:1.41
	binutils-csl-2_17-branch:1.41.0.16
	binutils-csl-2_17-branchpoint:1.41
	gdb-csl-available-20060303-branch:1.41.0.14
	gdb-csl-available-20060303-branchpoint:1.41
	gdb-csl-20060226-branch:1.41.0.12
	gdb-csl-20060226-branchpoint:1.41
	gdb_6_4-20051202-release:1.41
	msnyder-fork-checkpoint-branch:1.41.0.10
	msnyder-fork-checkpoint-branchpoint:1.41
	gdb-csl-gxxpro-6_3-branch:1.41.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.41
	gdb_6_4-branch:1.41.0.6
	gdb_6_4-2005-11-01-branchpoint:1.41
	gdb-csl-arm-20051020-branch:1.41.0.4
	gdb-csl-arm-20051020-branchpoint:1.41
	binutils-csl-gxxpro-3_4-branch:1.39.0.10
	binutils-csl-gxxpro-3_4-branchpoint:1.39
	binutils-2_16_1:1.39
	msnyder-tracepoint-checkpoint-branch:1.41.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.41
	gdb-csl-arm-20050325-2005-q1b:1.39
	binutils-csl-arm-2005q1b:1.39
	binutils-2_16:1.39
	gdb-csl-arm-20050325-2005-q1a:1.39
	binutils-csl-arm-2005q1a:1.39
	csl-arm-20050325-branch:1.39.0.8
	csl-arm-20050325-branchpoint:1.39
	binutils-csl-arm-2005q1-branch:1.39.0.6
	binutils-csl-arm-2005q1-branchpoint:1.39
	binutils-2_16-branch:1.39.0.4
	binutils-2_16-branchpoint:1.39
	csl-arm-2004-q3d:1.39
	gdb_6_3-20041109-release:1.39
	gdb_6_3-branch:1.39.0.2
	gdb_6_3-20041019-branchpoint:1.39
	csl-arm-2004-q3:1.36
	drow_intercu-merge-20040921:1.36
	drow_intercu-merge-20040915:1.36
	jimb-gdb_6_2-e500-branch:1.36.0.6
	jimb-gdb_6_2-e500-branchpoint:1.36
	gdb_6_2-20040730-release:1.36
	gdb_6_2-branch:1.36.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.36
	gdb_6_1_1-20040616-release:1.35
	binutils-2_15:1.35
	binutils-2_15-branchpoint:1.35
	csl-arm-2004-q1a:1.35
	csl-arm-2004-q1:1.35
	gdb_6_1-2004-04-05-release:1.35
	drow_intercu-merge-20040402:1.35
	drow_intercu-merge-20040327:1.35
	ezannoni_pie-20040323-branch:1.35.0.14
	ezannoni_pie-20040323-branchpoint:1.35
	cagney_tramp-20040321-mergepoint:1.35
	cagney_tramp-20040309-branch:1.35.0.12
	cagney_tramp-20040309-branchpoint:1.35
	gdb_6_1-branch:1.35.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.35
	drow_intercu-20040221-branch:1.35.0.8
	drow_intercu-20040221-branchpoint:1.35
	binutils-2_15-branch:1.35.0.6
	cagney_bfdfile-20040213-branch:1.35.0.4
	cagney_bfdfile-20040213-branchpoint:1.35
	drow-cplus-merge-20040208:1.35
	carlton_dictionary-20040126-merge:1.35
	cagney_bigcore-20040122-branch:1.35.0.2
	cagney_bigcore-20040122-branchpoint:1.35
	drow-cplus-merge-20040113:1.35
	csl-arm-2003-q4:1.35
	drow-cplus-merge-20031224:1.35
	drow-cplus-merge-20031220:1.35
	carlton_dictionary-20031215-merge:1.35
	drow-cplus-merge-20031214:1.35
	carlton-dictionary-20031111-merge:1.34
	gdb_6_0-2003-10-04-release:1.30
	kettenis_sparc-20030918-branch:1.32.0.6
	kettenis_sparc-20030918-branchpoint:1.32
	carlton_dictionary-20030917-merge:1.32
	ezannoni_pie-20030916-branchpoint:1.32
	ezannoni_pie-20030916-branch:1.32.0.4
	cagney_x86i386-20030821-branch:1.32.0.2
	cagney_x86i386-20030821-branchpoint:1.32
	carlton_dictionary-20030805-merge:1.32
	carlton_dictionary-20030627-merge:1.31
	gdb_6_0-branch:1.30.0.6
	gdb_6_0-2003-06-23-branchpoint:1.30
	jimb-ppc64-linux-20030613-branch:1.30.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.30
	binutils-2_14:1.29
	cagney_convert-20030606-branch:1.30.0.2
	cagney_convert-20030606-branchpoint:1.30
	cagney_writestrings-20030508-branch:1.29.0.26
	cagney_writestrings-20030508-branchpoint:1.29
	jimb-ppc64-linux-20030528-branch:1.29.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.29
	carlton_dictionary-20030523-merge:1.29
	cagney_fileio-20030521-branch:1.29.0.22
	cagney_fileio-20030521-branchpoint:1.29
	kettenis_i386newframe-20030517-mergepoint:1.29
	jimb-ppc64-linux-20030509-branch:1.29.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.29
	kettenis_i386newframe-20030504-mergepoint:1.29
	carlton_dictionary-20030430-merge:1.29
	binutils-2_14-branch:1.29.0.18
	binutils-2_14-branchpoint:1.29
	kettenis_i386newframe-20030419-branch:1.29.0.16
	kettenis_i386newframe-20030419-branchpoint:1.29
	carlton_dictionary-20030416-merge:1.29
	cagney_frameaddr-20030409-mergepoint:1.29
	kettenis_i386newframe-20030406-branch:1.29.0.14
	kettenis_i386newframe-20030406-branchpoint:1.29
	cagney_frameaddr-20030403-branchpoint:1.29
	cagney_frameaddr-20030403-branch:1.29.0.12
	cagney_framebase-20030330-mergepoint:1.29
	cagney_framebase-20030326-branch:1.29.0.10
	cagney_framebase-20030326-branchpoint:1.29
	cagney_lazyid-20030317-branch:1.29.0.8
	cagney_lazyid-20030317-branchpoint:1.29
	kettenis-i386newframe-20030316-mergepoint:1.29
	offbyone-20030313-branch:1.29.0.6
	offbyone-20030313-branchpoint:1.29
	kettenis-i386newframe-20030308-branch:1.29.0.4
	kettenis-i386newframe-20030308-branchpoint:1.29
	carlton_dictionary-20030305-merge:1.29
	cagney_offbyone-20030303-branch:1.29.0.2
	cagney_offbyone-20030303-branchpoint:1.29
	carlton_dictionary-20030207-merge:1.27
	interps-20030202-branch:1.27.0.4
	interps-20030202-branchpoint:1.27
	cagney-unwind-20030108-branch:1.27.0.2
	cagney-unwind-20030108-branchpoint:1.27
	binutils-2_13_2_1:1.24.2.1
	binutils-2_13_2:1.24.2.1
	carlton_dictionary-20021223-merge:1.27
	gdb_5_3-2002-12-12-release:1.25
	carlton_dictionary-20021115-merge:1.26
	binutils-2_13_1:1.24.2.1
	kseitz_interps-20021105-merge:1.26
	kseitz_interps-20021103-merge:1.26
	drow-cplus-merge-20021020:1.25
	drow-cplus-merge-20021025:1.25
	carlton_dictionary-20021025-merge:1.26
	carlton_dictionary-20021011-merge:1.25
	drow-cplus-branch:1.25.0.12
	drow-cplus-branchpoint:1.25
	kseitz_interps-20020930-merge:1.25
	carlton_dictionary-20020927-merge:1.25
	carlton_dictionary-branch:1.25.0.10
	carlton_dictionary-20020920-branchpoint:1.25
	sid-20020905-branchpoint:1.25
	sid-20020905-branch:1.25.0.8
	gdb_5_3-branch:1.25.0.6
	gdb_5_3-2002-09-04-branchpoint:1.25
	kseitz_interps-20020829-merge:1.25
	cagney_sysregs-20020825-branch:1.25.0.4
	cagney_sysregs-20020825-branchpoint:1.25
	readline_4_3-import-branch:1.25.0.2
	readline_4_3-import-branchpoint:1.25
	binutils-2_13:1.24
	gdb_5_2_1-2002-07-23-release:1.18
	binutils-2_13-branchpoint:1.24
	binutils-2_13-branch:1.24.0.2
	kseitz_interps-20020528-branch:1.22.0.2
	kseitz_interps-20020528-branchpoint:1.22
	cagney_regbuf-20020515-branch:1.20.0.4
	cagney_regbuf-20020515-branchpoint:1.20
	binutils-2_12_1:1.17.2.2
	jimb-macro-020506-branch:1.20.0.2
	jimb-macro-020506-branchpoint:1.20
	gdb_5_2-2002-04-29-release:1.18
	binutils-2_12:1.17
	gdb_5_2-branch:1.18.0.2
	gdb_5_2-2002-03-03-branchpoint:1.18
	binutils-2_12-branch:1.17.0.2
	binutils-2_12-branchpoint:1.17
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	binutils-2_11_2:1.8.2.1
	binutils-2_11_1:1.8.2.1
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	insight-precleanup-2001-01-01:1.8
	binutils-2_10_1:1.5
	binutils-2_10:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.4
	gdb_5_0-2000-04-10-branchpoint:1.5
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.60
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.60
date	2013.09.24.06.57.36;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2013.06.03.04.11.09;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2013.01.10.20.03.55;	author hjl;	state Exp;
branches;
next	1.57;

1.57
date	2012.05.16.14.26.46;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2011.02.28.18.30.16;	author ktietz;	state Exp;
branches;
next	1.55;

1.55
date	2009.09.09.21.38.58;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2009.07.23.13.00.20;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2009.04.30.15.47.10;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2009.01.13.23.44.45;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2008.12.23.09.01.45;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2008.12.03.14.50.57;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2008.06.30.20.51.58;	author rsandifo;	state Exp;
branches
	1.47.4.1;
next	1.46;

1.46
date	2007.09.21.07.58.03;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2007.07.26.18.53.51;	author msnyder;	state Exp;
branches;
next	1.44;

1.44
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.05.19.50.12;	author brolley;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.04.15.53.39;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.04.07.19.37;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2004.10.08.14.54.01;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2004.10.08.05.53.59;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.05.11.12.56;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.24.04.46.26;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches
	1.35.8.1;
next	1.34;

1.34
date	2003.10.31.05.32.46;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.20.14.38.39;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.29.10.06.39;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.25.06.40.22;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.03.17.45.48;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.28.23.43.35;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.14.09.31.57;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.25.02.45.54;	author danglin;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.22.16.12.00;	author nickc;	state Exp;
branches
	1.25.10.1
	1.25.12.1;
next	1.24;

1.24
date	2002.07.05.20.29.38;	author wilson;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.06.25.09.40.45;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.28.14.05.19;	author nickc;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2002.05.23.13.12.47;	author jakub;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.01.07.36.39;	author amodra;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2002.03.20.19.15.30;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.19.16.33.04;	author fche;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.30.18.12.16;	author nickc;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2002.01.06.07.30.35;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.12.19.05.26;	author rth;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.19.05.33.13;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.23.15.45.19;	author hjl;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.09.14.38.04;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.05.18.27.55;	author wilson;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.20.00.21.57;	author kazu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.07.10.05.14.13;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.29.15.06.34;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.28.01.06.37;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	99.09.11.14.41.11;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.09.06.18.44.56;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.11.19.49.46;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.54.2.1
date	2009.09.09.21.40.20;	author nickc;	state Exp;
branches;
next	;

1.47.4.1
date	2009.03.02.13.49.22;	author amodra;	state Exp;
branches;
next	;

1.35.8.1
date	2004.09.16.17.00.38;	author drow;	state Exp;
branches;
next	;

1.25.10.1
date	2002.10.25.23.49.49;	author carlton;	state Exp;
branches;
next	1.25.10.2;

1.25.10.2
date	2002.12.23.19.38.00;	author carlton;	state Exp;
branches;
next	1.25.10.3;

1.25.10.3
date	2003.03.06.00.56.19;	author carlton;	state Exp;
branches;
next	1.25.10.4;

1.25.10.4
date	2003.06.27.21.49.30;	author carlton;	state Exp;
branches;
next	1.25.10.5;

1.25.10.5
date	2003.08.05.17.12.55;	author carlton;	state Exp;
branches;
next	1.25.10.6;

1.25.10.6
date	2003.11.11.23.50.30;	author carlton;	state Exp;
branches;
next	1.25.10.7;

1.25.10.7
date	2003.12.15.23.59.53;	author carlton;	state Exp;
branches;
next	;

1.25.12.1
date	2003.12.14.20.26.53;	author drow;	state Exp;
branches;
next	;

1.24.2.1
date	2002.10.28.18.45.46;	author drow;	state Exp;
branches;
next	;

1.22.2.1
date	2002.07.22.21.46.49;	author kseitz;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.08.30.22.52.38;	author kseitz;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.11.03.22.01.38;	author ezannoni;	state Exp;
branches;
next	;

1.20.4.1
date	2002.06.15.16.42.41;	author cagney;	state Exp;
branches;
next	;

1.17.2.1
date	2002.03.28.06.20.03;	author amodra;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.05.09.11.50.34;	author amodra;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.60
log
@	* syms.c (_bfd_stab_section_find_nearest_line): Ignore partial
	stabs at end of .stab.  Tidy variable usage.  Don't drop the need
	for a NULL function name stab if If N_FUN stab is ignored.
	Ensure index entry count loop matches write loop.
@
text
@/* Generic symbol-table support for the BFD library.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2012
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/*
SECTION
	Symbols

	BFD tries to maintain as much symbol information as it can when
	it moves information from file to file. BFD passes information
	to applications though the <<asymbol>> structure. When the
	application requests the symbol table, BFD reads the table in
	the native form and translates parts of it into the internal
	format. To maintain more than the information passed to
	applications, some targets keep some information ``behind the
	scenes'' in a structure only the particular back end knows
	about. For example, the coff back end keeps the original
	symbol table structure as well as the canonical structure when
	a BFD is read in. On output, the coff back end can reconstruct
	the output symbol table so that no information is lost, even
	information unique to coff which BFD doesn't know or
	understand. If a coff symbol table were read, but were written
	through an a.out back end, all the coff specific information
	would be lost. The symbol table of a BFD
	is not necessarily read in until a canonicalize request is
	made. Then the BFD back end fills in a table provided by the
	application with pointers to the canonical information.  To
	output symbols, the application provides BFD with a table of
	pointers to pointers to <<asymbol>>s. This allows applications
	like the linker to output a symbol as it was read, since the ``behind
	the scenes'' information will be still available.
@@menu
@@* Reading Symbols::
@@* Writing Symbols::
@@* Mini Symbols::
@@* typedef asymbol::
@@* symbol handling functions::
@@end menu

INODE
Reading Symbols, Writing Symbols, Symbols, Symbols
SUBSECTION
	Reading symbols

	There are two stages to reading a symbol table from a BFD:
	allocating storage, and the actual reading process. This is an
	excerpt from an application which reads the symbol table:

|	  long storage_needed;
|	  asymbol **symbol_table;
|	  long number_of_symbols;
|	  long i;
|
|	  storage_needed = bfd_get_symtab_upper_bound (abfd);
|
|         if (storage_needed < 0)
|           FAIL
|
|	  if (storage_needed == 0)
|	    return;
|
|	  symbol_table = xmalloc (storage_needed);
|	    ...
|	  number_of_symbols =
|	     bfd_canonicalize_symtab (abfd, symbol_table);
|
|         if (number_of_symbols < 0)
|           FAIL
|
|	  for (i = 0; i < number_of_symbols; i++)
|	    process_symbol (symbol_table[i]);

	All storage for the symbols themselves is in an objalloc
	connected to the BFD; it is freed when the BFD is closed.

INODE
Writing Symbols, Mini Symbols, Reading Symbols, Symbols
SUBSECTION
	Writing symbols

	Writing of a symbol table is automatic when a BFD open for
	writing is closed. The application attaches a vector of
	pointers to pointers to symbols to the BFD being written, and
	fills in the symbol count. The close and cleanup code reads
	through the table provided and performs all the necessary
	operations. The BFD output code must always be provided with an
	``owned'' symbol: one which has come from another BFD, or one
	which has been created using <<bfd_make_empty_symbol>>.  Here is an
	example showing the creation of a symbol table with only one element:

|	#include "sysdep.h"
|	#include "bfd.h"
|	int main (void)
|	{
|	  bfd *abfd;
|	  asymbol *ptrs[2];
|	  asymbol *new;
|
|	  abfd = bfd_openw ("foo","a.out-sunos-big");
|	  bfd_set_format (abfd, bfd_object);
|	  new = bfd_make_empty_symbol (abfd);
|	  new->name = "dummy_symbol";
|	  new->section = bfd_make_section_old_way (abfd, ".text");
|	  new->flags = BSF_GLOBAL;
|	  new->value = 0x12345;
|
|	  ptrs[0] = new;
|	  ptrs[1] = 0;
|
|	  bfd_set_symtab (abfd, ptrs, 1);
|	  bfd_close (abfd);
|	  return 0;
|	}
|
|	./makesym
|	nm foo
|	00012345 A dummy_symbol

	Many formats cannot represent arbitrary symbol information; for
 	instance, the <<a.out>> object format does not allow an
	arbitrary number of sections. A symbol pointing to a section
	which is not one  of <<.text>>, <<.data>> or <<.bss>> cannot
	be described.

INODE
Mini Symbols, typedef asymbol, Writing Symbols, Symbols
SUBSECTION
	Mini Symbols

	Mini symbols provide read-only access to the symbol table.
	They use less memory space, but require more time to access.
	They can be useful for tools like nm or objdump, which may
	have to handle symbol tables of extremely large executables.

	The <<bfd_read_minisymbols>> function will read the symbols
	into memory in an internal form.  It will return a <<void *>>
	pointer to a block of memory, a symbol count, and the size of
	each symbol.  The pointer is allocated using <<malloc>>, and
	should be freed by the caller when it is no longer needed.

	The function <<bfd_minisymbol_to_symbol>> will take a pointer
	to a minisymbol, and a pointer to a structure returned by
	<<bfd_make_empty_symbol>>, and return a <<asymbol>> structure.
	The return value may or may not be the same as the value from
	<<bfd_make_empty_symbol>> which was passed in.

*/

/*
DOCDD
INODE
typedef asymbol, symbol handling functions, Mini Symbols, Symbols

*/
/*
SUBSECTION
	typedef asymbol

	An <<asymbol>> has the form:

*/

/*
CODE_FRAGMENT

.
.typedef struct bfd_symbol
.{
.  {* A pointer to the BFD which owns the symbol. This information
.     is necessary so that a back end can work out what additional
.     information (invisible to the application writer) is carried
.     with the symbol.
.
.     This field is *almost* redundant, since you can use section->owner
.     instead, except that some symbols point to the global sections
.     bfd_{abs,com,und}_section.  This could be fixed by making
.     these globals be per-bfd (or per-target-flavor).  FIXME.  *}
.  struct bfd *the_bfd; {* Use bfd_asymbol_bfd(sym) to access this field.  *}
.
.  {* The text of the symbol. The name is left alone, and not copied; the
.     application may not alter it.  *}
.  const char *name;
.
.  {* The value of the symbol.  This really should be a union of a
.     numeric value with a pointer, since some flags indicate that
.     a pointer to another symbol is stored here.  *}
.  symvalue value;
.
.  {* Attributes of a symbol.  *}
.#define BSF_NO_FLAGS    	0x00
.
.  {* The symbol has local scope; <<static>> in <<C>>. The value
.     is the offset into the section of the data.  *}
.#define BSF_LOCAL		(1 << 0)
.
.  {* The symbol has global scope; initialized data in <<C>>. The
.     value is the offset into the section of the data.  *}
.#define BSF_GLOBAL		(1 << 1)
.
.  {* The symbol has global scope and is exported. The value is
.     the offset into the section of the data.  *}
.#define BSF_EXPORT	BSF_GLOBAL {* No real difference.  *}
.
.  {* A normal C symbol would be one of:
.     <<BSF_LOCAL>>, <<BSF_COMMON>>,  <<BSF_UNDEFINED>> or
.     <<BSF_GLOBAL>>.  *}
.
.  {* The symbol is a debugging record. The value has an arbitrary
.     meaning, unless BSF_DEBUGGING_RELOC is also set.  *}
.#define BSF_DEBUGGING		(1 << 2)
.
.  {* The symbol denotes a function entry point.  Used in ELF,
.     perhaps others someday.  *}
.#define BSF_FUNCTION		(1 << 3)
.
.  {* Used by the linker.  *}
.#define BSF_KEEP		(1 << 5)
.#define BSF_KEEP_G		(1 << 6)
.
.  {* A weak global symbol, overridable without warnings by
.     a regular global symbol of the same name.  *}
.#define BSF_WEAK		(1 << 7)
.
.  {* This symbol was created to point to a section, e.g. ELF's
.     STT_SECTION symbols.  *}
.#define BSF_SECTION_SYM	(1 << 8)
.
.  {* The symbol used to be a common symbol, but now it is
.     allocated.  *}
.#define BSF_OLD_COMMON		(1 << 9)
.
.  {* In some files the type of a symbol sometimes alters its
.     location in an output file - ie in coff a <<ISFCN>> symbol
.     which is also <<C_EXT>> symbol appears where it was
.     declared and not at the end of a section.  This bit is set
.     by the target BFD part to convey this information.  *}
.#define BSF_NOT_AT_END		(1 << 10)
.
.  {* Signal that the symbol is the label of constructor section.  *}
.#define BSF_CONSTRUCTOR	(1 << 11)
.
.  {* Signal that the symbol is a warning symbol.  The name is a
.     warning.  The name of the next symbol is the one to warn about;
.     if a reference is made to a symbol with the same name as the next
.     symbol, a warning is issued by the linker.  *}
.#define BSF_WARNING		(1 << 12)
.
.  {* Signal that the symbol is indirect.  This symbol is an indirect
.     pointer to the symbol with the same name as the next symbol.  *}
.#define BSF_INDIRECT		(1 << 13)
.
.  {* BSF_FILE marks symbols that contain a file name.  This is used
.     for ELF STT_FILE symbols.  *}
.#define BSF_FILE		(1 << 14)
.
.  {* Symbol is from dynamic linking information.  *}
.#define BSF_DYNAMIC		(1 << 15)
.
.  {* The symbol denotes a data object.  Used in ELF, and perhaps
.     others someday.  *}
.#define BSF_OBJECT		(1 << 16)
.
.  {* This symbol is a debugging symbol.  The value is the offset
.     into the section of the data.  BSF_DEBUGGING should be set
.     as well.  *}
.#define BSF_DEBUGGING_RELOC	(1 << 17)
.
.  {* This symbol is thread local.  Used in ELF.  *}
.#define BSF_THREAD_LOCAL	(1 << 18)
.
.  {* This symbol represents a complex relocation expression,
.     with the expression tree serialized in the symbol name.  *}
.#define BSF_RELC		(1 << 19)
.
.  {* This symbol represents a signed complex relocation expression,
.     with the expression tree serialized in the symbol name.  *}
.#define BSF_SRELC		(1 << 20)
.
.  {* This symbol was created by bfd_get_synthetic_symtab.  *}
.#define BSF_SYNTHETIC		(1 << 21)
.
.  {* This symbol is an indirect code object.  Unrelated to BSF_INDIRECT.
.     The dynamic linker will compute the value of this symbol by
.     calling the function that it points to.  BSF_FUNCTION must
.     also be also set.  *}
.#define BSF_GNU_INDIRECT_FUNCTION (1 << 22)
.  {* This symbol is a globally unique data object.  The dynamic linker
.     will make sure that in the entire process there is just one symbol
.     with this name and type in use.  BSF_OBJECT must also be set.  *}
.#define BSF_GNU_UNIQUE		(1 << 23)
.
.  flagword flags;
.
.  {* A pointer to the section to which this symbol is
.     relative.  This will always be non NULL, there are special
.     sections for undefined and absolute symbols.  *}
.  struct bfd_section *section;
.
.  {* Back end special data.  *}
.  union
.    {
.      void *p;
.      bfd_vma i;
.    }
.  udata;
.}
.asymbol;
.
*/

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "safe-ctype.h"
#include "bfdlink.h"
#include "aout/stab_gnu.h"

/*
DOCDD
INODE
symbol handling functions,  , typedef asymbol, Symbols
SUBSECTION
	Symbol handling functions
*/

/*
FUNCTION
	bfd_get_symtab_upper_bound

DESCRIPTION
	Return the number of bytes required to store a vector of pointers
	to <<asymbols>> for all the symbols in the BFD @@var{abfd},
	including a terminal NULL pointer. If there are no symbols in
	the BFD, then return 0.  If an error occurs, return -1.

.#define bfd_get_symtab_upper_bound(abfd) \
.     BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))
.
*/

/*
FUNCTION
	bfd_is_local_label

SYNOPSIS
        bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);

DESCRIPTION
	Return TRUE if the given symbol @@var{sym} in the BFD @@var{abfd} is
	a compiler generated local label, else return FALSE.
*/

bfd_boolean
bfd_is_local_label (bfd *abfd, asymbol *sym)
{
  /* The BSF_SECTION_SYM check is needed for IA-64, where every label that
     starts with '.' is local.  This would accidentally catch section names
     if we didn't reject them here.  */
  if ((sym->flags & (BSF_GLOBAL | BSF_WEAK | BSF_FILE | BSF_SECTION_SYM)) != 0)
    return FALSE;
  if (sym->name == NULL)
    return FALSE;
  return bfd_is_local_label_name (abfd, sym->name);
}

/*
FUNCTION
	bfd_is_local_label_name

SYNOPSIS
        bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);

DESCRIPTION
	Return TRUE if a symbol with the name @@var{name} in the BFD
	@@var{abfd} is a compiler generated local label, else return
	FALSE.  This just checks whether the name has the form of a
	local label.

.#define bfd_is_local_label_name(abfd, name) \
.  BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
.
*/

/*
FUNCTION
	bfd_is_target_special_symbol

SYNOPSIS
        bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);

DESCRIPTION
	Return TRUE iff a symbol @@var{sym} in the BFD @@var{abfd} is something
	special to the particular target represented by the BFD.  Such symbols
	should normally not be mentioned to the user.

.#define bfd_is_target_special_symbol(abfd, sym) \
.  BFD_SEND (abfd, _bfd_is_target_special_symbol, (abfd, sym))
.
*/

/*
FUNCTION
	bfd_canonicalize_symtab

DESCRIPTION
	Read the symbols from the BFD @@var{abfd}, and fills in
	the vector @@var{location} with pointers to the symbols and
	a trailing NULL.
	Return the actual number of symbol pointers, not
	including the NULL.

.#define bfd_canonicalize_symtab(abfd, location) \
.  BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))
.
*/

/*
FUNCTION
	bfd_set_symtab

SYNOPSIS
	bfd_boolean bfd_set_symtab
	  (bfd *abfd, asymbol **location, unsigned int count);

DESCRIPTION
	Arrange that when the output BFD @@var{abfd} is closed,
	the table @@var{location} of @@var{count} pointers to symbols
	will be written.
*/

bfd_boolean
bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int symcount)
{
  if (abfd->format != bfd_object || bfd_read_p (abfd))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  bfd_get_outsymbols (abfd) = location;
  bfd_get_symcount (abfd) = symcount;
  return TRUE;
}

/*
FUNCTION
	bfd_print_symbol_vandf

SYNOPSIS
	void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);

DESCRIPTION
	Print the value and flags of the @@var{symbol} supplied to the
	stream @@var{file}.
*/
void
bfd_print_symbol_vandf (bfd *abfd, void *arg, asymbol *symbol)
{
  FILE *file = (FILE *) arg;

  flagword type = symbol->flags;

  if (symbol->section != NULL)
    bfd_fprintf_vma (abfd, file, symbol->value + symbol->section->vma);
  else
    bfd_fprintf_vma (abfd, file, symbol->value);

  /* This presumes that a symbol can not be both BSF_DEBUGGING and
     BSF_DYNAMIC, nor more than one of BSF_FUNCTION, BSF_FILE, and
     BSF_OBJECT.  */
  fprintf (file, " %c%c%c%c%c%c%c",
	   ((type & BSF_LOCAL)
	    ? (type & BSF_GLOBAL) ? '!' : 'l'
	    : (type & BSF_GLOBAL) ? 'g'
	    : (type & BSF_GNU_UNIQUE) ? 'u' : ' '),
	   (type & BSF_WEAK) ? 'w' : ' ',
	   (type & BSF_CONSTRUCTOR) ? 'C' : ' ',
	   (type & BSF_WARNING) ? 'W' : ' ',
	   (type & BSF_INDIRECT) ? 'I' : (type & BSF_GNU_INDIRECT_FUNCTION) ? 'i' : ' ',
	   (type & BSF_DEBUGGING) ? 'd' : (type & BSF_DYNAMIC) ? 'D' : ' ',
	   ((type & BSF_FUNCTION)
	    ? 'F'
	    : ((type & BSF_FILE)
	       ? 'f'
	       : ((type & BSF_OBJECT) ? 'O' : ' '))));
}

/*
FUNCTION
	bfd_make_empty_symbol

DESCRIPTION
	Create a new <<asymbol>> structure for the BFD @@var{abfd}
	and return a pointer to it.

	This routine is necessary because each back end has private
	information surrounding the <<asymbol>>. Building your own
	<<asymbol>> and pointing to it will not create the private
	information, and will cause problems later on.

.#define bfd_make_empty_symbol(abfd) \
.  BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
.
*/

/*
FUNCTION
	_bfd_generic_make_empty_symbol

SYNOPSIS
	asymbol *_bfd_generic_make_empty_symbol (bfd *);

DESCRIPTION
	Create a new <<asymbol>> structure for the BFD @@var{abfd}
	and return a pointer to it.  Used by core file routines,
	binary back-end and anywhere else where no private info
	is needed.
*/

asymbol *
_bfd_generic_make_empty_symbol (bfd *abfd)
{
  bfd_size_type amt = sizeof (asymbol);
  asymbol *new_symbol = (asymbol *) bfd_zalloc (abfd, amt);
  if (new_symbol)
    new_symbol->the_bfd = abfd;
  return new_symbol;
}

/*
FUNCTION
	bfd_make_debug_symbol

DESCRIPTION
	Create a new <<asymbol>> structure for the BFD @@var{abfd},
	to be used as a debugging symbol.  Further details of its use have
	yet to be worked out.

.#define bfd_make_debug_symbol(abfd,ptr,size) \
.  BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
.
*/

struct section_to_type
{
  const char *section;
  char type;
};

/* Map section names to POSIX/BSD single-character symbol types.
   This table is probably incomplete.  It is sorted for convenience of
   adding entries.  Since it is so short, a linear search is used.  */
static const struct section_to_type stt[] =
{
  {".bss", 'b'},
  {"code", 't'},		/* MRI .text */
  {".data", 'd'},
  {"*DEBUG*", 'N'},
  {".debug", 'N'},              /* MSVC's .debug (non-standard debug syms) */
  {".drectve", 'i'},            /* MSVC's .drective section */
  {".edata", 'e'},              /* MSVC's .edata (export) section */
  {".fini", 't'},		/* ELF fini section */
  {".idata", 'i'},              /* MSVC's .idata (import) section */
  {".init", 't'},		/* ELF init section */
  {".pdata", 'p'},              /* MSVC's .pdata (stack unwind) section */
  {".rdata", 'r'},		/* Read only data.  */
  {".rodata", 'r'},		/* Read only data.  */
  {".sbss", 's'},		/* Small BSS (uninitialized data).  */
  {".scommon", 'c'},		/* Small common.  */
  {".sdata", 'g'},		/* Small initialized data.  */
  {".text", 't'},
  {"vars", 'd'},		/* MRI .data */
  {"zerovars", 'b'},		/* MRI .bss */
  {0, 0}
};

/* Return the single-character symbol type corresponding to
   section S, or '?' for an unknown COFF section.

   Check for any leading string which matches, so .text5 returns
   't' as well as .text */

static char
coff_section_type (const char *s)
{
  const struct section_to_type *t;

  for (t = &stt[0]; t->section; t++)
    if (!strncmp (s, t->section, strlen (t->section)))
      return t->type;

  return '?';
}

/* Return the single-character symbol type corresponding to section
   SECTION, or '?' for an unknown section.  This uses section flags to
   identify sections.

   FIXME These types are unhandled: c, i, e, p.  If we handled these also,
   we could perhaps obsolete coff_section_type.  */

static char
decode_section_type (const struct bfd_section *section)
{
  if (section->flags & SEC_CODE)
    return 't';
  if (section->flags & SEC_DATA)
    {
      if (section->flags & SEC_READONLY)
	return 'r';
      else if (section->flags & SEC_SMALL_DATA)
	return 'g';
      else
	return 'd';
    }
  if ((section->flags & SEC_HAS_CONTENTS) == 0)
    {
      if (section->flags & SEC_SMALL_DATA)
	return 's';
      else
	return 'b';
    }
  if (section->flags & SEC_DEBUGGING)
    return 'N';
  if ((section->flags & SEC_HAS_CONTENTS) && (section->flags & SEC_READONLY))
    return 'n';

  return '?';
}

/*
FUNCTION
	bfd_decode_symclass

DESCRIPTION
	Return a character corresponding to the symbol
	class of @@var{symbol}, or '?' for an unknown class.

SYNOPSIS
	int bfd_decode_symclass (asymbol *symbol);
*/
int
bfd_decode_symclass (asymbol *symbol)
{
  char c;

  if (symbol->section && bfd_is_com_section (symbol->section))
    return 'C';
  if (bfd_is_und_section (symbol->section))
    {
      if (symbol->flags & BSF_WEAK)
	{
	  /* If weak, determine if it's specifically an object
	     or non-object weak.  */
	  if (symbol->flags & BSF_OBJECT)
	    return 'v';
	  else
	    return 'w';
	}
      else
	return 'U';
    }
  if (bfd_is_ind_section (symbol->section))
    return 'I';
  if (symbol->flags & BSF_GNU_INDIRECT_FUNCTION)
    return 'i';
  if (symbol->flags & BSF_WEAK)
    {
      /* If weak, determine if it's specifically an object
	 or non-object weak.  */
      if (symbol->flags & BSF_OBJECT)
	return 'V';
      else
	return 'W';
    }
  if (symbol->flags & BSF_GNU_UNIQUE)
    return 'u';
  if (!(symbol->flags & (BSF_GLOBAL | BSF_LOCAL)))
    return '?';

  if (bfd_is_abs_section (symbol->section))
    c = 'a';
  else if (symbol->section)
    {
      c = coff_section_type (symbol->section->name);
      if (c == '?')
	c = decode_section_type (symbol->section);
    }
  else
    return '?';
  if (symbol->flags & BSF_GLOBAL)
    c = TOUPPER (c);
  return c;

  /* We don't have to handle these cases just yet, but we will soon:
     N_SETV: 'v';
     N_SETA: 'l';
     N_SETT: 'x';
     N_SETD: 'z';
     N_SETB: 's';
     N_INDR: 'i';
     */
}

/*
FUNCTION
	bfd_is_undefined_symclass

DESCRIPTION
	Returns non-zero if the class symbol returned by
	bfd_decode_symclass represents an undefined symbol.
	Returns zero otherwise.

SYNOPSIS
	bfd_boolean bfd_is_undefined_symclass (int symclass);
*/

bfd_boolean
bfd_is_undefined_symclass (int symclass)
{
  return symclass == 'U' || symclass == 'w' || symclass == 'v';
}

/*
FUNCTION
	bfd_symbol_info

DESCRIPTION
	Fill in the basic info about symbol that nm needs.
	Additional info may be added by the back-ends after
	calling this function.

SYNOPSIS
	void bfd_symbol_info (asymbol *symbol, symbol_info *ret);
*/

void
bfd_symbol_info (asymbol *symbol, symbol_info *ret)
{
  ret->type = bfd_decode_symclass (symbol);

  if (bfd_is_undefined_symclass (ret->type))
    ret->value = 0;
  else
    ret->value = symbol->value + symbol->section->vma;

  ret->name = symbol->name;
}

/*
FUNCTION
	bfd_copy_private_symbol_data

SYNOPSIS
	bfd_boolean bfd_copy_private_symbol_data
	  (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);

DESCRIPTION
	Copy private symbol information from @@var{isym} in the BFD
	@@var{ibfd} to the symbol @@var{osym} in the BFD @@var{obfd}.
	Return <<TRUE>> on success, <<FALSE>> on error.  Possible error
	returns are:

	o <<bfd_error_no_memory>> -
	Not enough memory exists to create private data for @@var{osec}.

.#define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
.  BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
.            (ibfd, isymbol, obfd, osymbol))
.
*/

/* The generic version of the function which returns mini symbols.
   This is used when the backend does not provide a more efficient
   version.  It just uses BFD asymbol structures as mini symbols.  */

long
_bfd_generic_read_minisymbols (bfd *abfd,
			       bfd_boolean dynamic,
			       void **minisymsp,
			       unsigned int *sizep)
{
  long storage;
  asymbol **syms = NULL;
  long symcount;

  if (dynamic)
    storage = bfd_get_dynamic_symtab_upper_bound (abfd);
  else
    storage = bfd_get_symtab_upper_bound (abfd);
  if (storage < 0)
    goto error_return;
  if (storage == 0)
    return 0;

  syms = (asymbol **) bfd_malloc (storage);
  if (syms == NULL)
    goto error_return;

  if (dynamic)
    symcount = bfd_canonicalize_dynamic_symtab (abfd, syms);
  else
    symcount = bfd_canonicalize_symtab (abfd, syms);
  if (symcount < 0)
    goto error_return;

  *minisymsp = syms;
  *sizep = sizeof (asymbol *);
  return symcount;

 error_return:
  bfd_set_error (bfd_error_no_symbols);
  if (syms != NULL)
    free (syms);
  return -1;
}

/* The generic version of the function which converts a minisymbol to
   an asymbol.  We don't worry about the sym argument we are passed;
   we just return the asymbol the minisymbol points to.  */

asymbol *
_bfd_generic_minisymbol_to_symbol (bfd *abfd ATTRIBUTE_UNUSED,
				   bfd_boolean dynamic ATTRIBUTE_UNUSED,
				   const void *minisym,
				   asymbol *sym ATTRIBUTE_UNUSED)
{
  return *(asymbol **) minisym;
}

/* Look through stabs debugging information in .stab and .stabstr
   sections to find the source file and line closest to a desired
   location.  This is used by COFF and ELF targets.  It sets *pfound
   to TRUE if it finds some information.  The *pinfo field is used to
   pass cached information in and out of this routine; this first time
   the routine is called for a BFD, *pinfo should be NULL.  The value
   placed in *pinfo should be saved with the BFD, and passed back each
   time this function is called.  */

/* We use a cache by default.  */

#define ENABLE_CACHING

/* We keep an array of indexentry structures to record where in the
   stabs section we should look to find line number information for a
   particular address.  */

struct indexentry
{
  bfd_vma val;
  bfd_byte *stab;
  bfd_byte *str;
  char *directory_name;
  char *file_name;
  char *function_name;
};

/* Compare two indexentry structures.  This is called via qsort.  */

static int
cmpindexentry (const void *a, const void *b)
{
  const struct indexentry *contestantA = (const struct indexentry *) a;
  const struct indexentry *contestantB = (const struct indexentry *) b;

  if (contestantA->val < contestantB->val)
    return -1;
  else if (contestantA->val > contestantB->val)
    return 1;
  else
    return 0;
}

/* A pointer to this structure is stored in *pinfo.  */

struct stab_find_info
{
  /* The .stab section.  */
  asection *stabsec;
  /* The .stabstr section.  */
  asection *strsec;
  /* The contents of the .stab section.  */
  bfd_byte *stabs;
  /* The contents of the .stabstr section.  */
  bfd_byte *strs;

  /* A table that indexes stabs by memory address.  */
  struct indexentry *indextable;
  /* The number of entries in indextable.  */
  int indextablesize;

#ifdef ENABLE_CACHING
  /* Cached values to restart quickly.  */
  struct indexentry *cached_indexentry;
  bfd_vma cached_offset;
  bfd_byte *cached_stab;
  char *cached_file_name;
#endif

  /* Saved ptr to malloc'ed filename.  */
  char *filename;
};

bfd_boolean
_bfd_stab_section_find_nearest_line (bfd *abfd,
				     asymbol **symbols,
				     asection *section,
				     bfd_vma offset,
				     bfd_boolean *pfound,
				     const char **pfilename,
				     const char **pfnname,
				     unsigned int *pline,
				     void **pinfo)
{
  struct stab_find_info *info;
  bfd_size_type stabsize, strsize;
  bfd_byte *stab, *str;
  bfd_byte *nul_fun, *nul_str;
  bfd_size_type stroff;
  struct indexentry *indexentry;
  char *file_name;
  char *directory_name;
  bfd_boolean saw_line, saw_func;

  *pfound = FALSE;
  *pfilename = bfd_get_filename (abfd);
  *pfnname = NULL;
  *pline = 0;

  /* Stabs entries use a 12 byte format:
       4 byte string table index
       1 byte stab type
       1 byte stab other field
       2 byte stab desc field
       4 byte stab value
     FIXME: This will have to change for a 64 bit object format.

     The stabs symbols are divided into compilation units.  For the
     first entry in each unit, the type of 0, the value is the length
     of the string table for this unit, and the desc field is the
     number of stabs symbols for this unit.  */

#define STRDXOFF (0)
#define TYPEOFF (4)
#define OTHEROFF (5)
#define DESCOFF (6)
#define VALOFF (8)
#define STABSIZE (12)

  info = (struct stab_find_info *) *pinfo;
  if (info != NULL)
    {
      if (info->stabsec == NULL || info->strsec == NULL)
	{
	  /* No stabs debugging information.  */
	  return TRUE;
	}

      stabsize = (info->stabsec->rawsize
		  ? info->stabsec->rawsize
		  : info->stabsec->size);
      strsize = (info->strsec->rawsize
		 ? info->strsec->rawsize
		 : info->strsec->size);
    }
  else
    {
      long reloc_size, reloc_count;
      arelent **reloc_vector;
      int i;
      char *function_name;
      bfd_size_type amt = sizeof *info;

      info = (struct stab_find_info *) bfd_zalloc (abfd, amt);
      if (info == NULL)
	return FALSE;

      /* FIXME: When using the linker --split-by-file or
	 --split-by-reloc options, it is possible for the .stab and
	 .stabstr sections to be split.  We should handle that.  */

      info->stabsec = bfd_get_section_by_name (abfd, ".stab");
      info->strsec = bfd_get_section_by_name (abfd, ".stabstr");

      if (info->stabsec == NULL || info->strsec == NULL)
	{
	  /* Try SOM section names.  */
	  info->stabsec = bfd_get_section_by_name (abfd, "$GDB_SYMBOLS$");
	  info->strsec  = bfd_get_section_by_name (abfd, "$GDB_STRINGS$");

	  if (info->stabsec == NULL || info->strsec == NULL)
	    {
	      /* No stabs debugging information.  Set *pinfo so that we
		 can return quickly in the info != NULL case above.  */
	      *pinfo = info;
	      return TRUE;
	    }
	}

      stabsize = (info->stabsec->rawsize
		  ? info->stabsec->rawsize
		  : info->stabsec->size);
      stabsize = (stabsize / STABSIZE) * STABSIZE;
      strsize = (info->strsec->rawsize
		 ? info->strsec->rawsize
		 : info->strsec->size);

      info->stabs = (bfd_byte *) bfd_alloc (abfd, stabsize);
      info->strs = (bfd_byte *) bfd_alloc (abfd, strsize);
      if (info->stabs == NULL || info->strs == NULL)
	return FALSE;

      if (! bfd_get_section_contents (abfd, info->stabsec, info->stabs,
				      0, stabsize)
	  || ! bfd_get_section_contents (abfd, info->strsec, info->strs,
					 0, strsize))
	return FALSE;

      /* If this is a relocatable object file, we have to relocate
	 the entries in .stab.  This should always be simple 32 bit
	 relocations against symbols defined in this object file, so
	 this should be no big deal.  */
      reloc_size = bfd_get_reloc_upper_bound (abfd, info->stabsec);
      if (reloc_size < 0)
	return FALSE;
      reloc_vector = (arelent **) bfd_malloc (reloc_size);
      if (reloc_vector == NULL && reloc_size != 0)
	return FALSE;
      reloc_count = bfd_canonicalize_reloc (abfd, info->stabsec, reloc_vector,
					    symbols);
      if (reloc_count < 0)
	{
	  if (reloc_vector != NULL)
	    free (reloc_vector);
	  return FALSE;
	}
      if (reloc_count > 0)
	{
	  arelent **pr;

	  for (pr = reloc_vector; *pr != NULL; pr++)
	    {
	      arelent *r;
	      unsigned long val;
	      asymbol *sym;

	      r = *pr;
	      /* Ignore R_*_NONE relocs.  */
	      if (r->howto->dst_mask == 0)
		continue;

	      if (r->howto->rightshift != 0
		  || r->howto->size != 2
		  || r->howto->bitsize != 32
		  || r->howto->pc_relative
		  || r->howto->bitpos != 0
		  || r->howto->dst_mask != 0xffffffff)
		{
		  (*_bfd_error_handler)
		    (_("Unsupported .stab relocation"));
		  bfd_set_error (bfd_error_invalid_operation);
		  if (reloc_vector != NULL)
		    free (reloc_vector);
		  return FALSE;
		}

	      val = bfd_get_32 (abfd, info->stabs + r->address);
	      val &= r->howto->src_mask;
	      sym = *r->sym_ptr_ptr;
	      val += sym->value + sym->section->vma + r->addend;
	      bfd_put_32 (abfd, (bfd_vma) val, info->stabs + r->address);
	    }
	}

      if (reloc_vector != NULL)
	free (reloc_vector);

      /* First time through this function, build a table matching
	 function VM addresses to stabs, then sort based on starting
	 VM address.  Do this in two passes: once to count how many
	 table entries we'll need, and a second to actually build the
	 table.  */

      info->indextablesize = 0;
      nul_fun = NULL;
      for (stab = info->stabs; stab < info->stabs + stabsize; stab += STABSIZE)
	{
	  if (stab[TYPEOFF] == (bfd_byte) N_SO)
	    {
	      /* if we did not see a function def, leave space for one.  */
	      if (nul_fun != NULL)
		++info->indextablesize;

	      /* N_SO with null name indicates EOF */
	      if (bfd_get_32 (abfd, stab + STRDXOFF) == 0)
		nul_fun = NULL;
	      else
		{
		  nul_fun = stab;

		  /* two N_SO's in a row is a filename and directory. Skip */
		  if (stab + STABSIZE + TYPEOFF < info->stabs + stabsize
		      && *(stab + STABSIZE + TYPEOFF) == (bfd_byte) N_SO)
		    stab += STABSIZE;
		}
	    }
	  else if (stab[TYPEOFF] == (bfd_byte) N_FUN
		   && bfd_get_32 (abfd, stab + STRDXOFF) != 0)
	    {
	      nul_fun = NULL;
	      ++info->indextablesize;
	    }
	}

      if (nul_fun != NULL)
	++info->indextablesize;

      if (info->indextablesize == 0)
	return TRUE;
      ++info->indextablesize;

      amt = info->indextablesize;
      amt *= sizeof (struct indexentry);
      info->indextable = (struct indexentry *) bfd_alloc (abfd, amt);
      if (info->indextable == NULL)
	return FALSE;

      file_name = NULL;
      directory_name = NULL;
      nul_fun = NULL;
      stroff = 0;

      for (i = 0, stab = info->stabs, nul_str = str = info->strs;
	   i < info->indextablesize && stab < info->stabs + stabsize;
	   stab += STABSIZE)
	{
	  switch (stab[TYPEOFF])
	    {
	    case 0:
	      /* This is the first entry in a compilation unit.  */
	      if ((bfd_size_type) ((info->strs + strsize) - str) < stroff)
		break;
	      str += stroff;
	      stroff = bfd_get_32 (abfd, stab + VALOFF);
	      break;

	    case N_SO:
	      /* The main file name.  */

	      /* The following code creates a new indextable entry with
	         a NULL function name if there were no N_FUNs in a file.
	         Note that a N_SO without a file name is an EOF and
	         there could be 2 N_SO following it with the new filename
	         and directory.  */
	      if (nul_fun != NULL)
		{
		  info->indextable[i].val = bfd_get_32 (abfd, nul_fun + VALOFF);
		  info->indextable[i].stab = nul_fun;
		  info->indextable[i].str = nul_str;
		  info->indextable[i].directory_name = directory_name;
		  info->indextable[i].file_name = file_name;
		  info->indextable[i].function_name = NULL;
		  ++i;
		}

	      directory_name = NULL;
	      file_name = (char *) str + bfd_get_32 (abfd, stab + STRDXOFF);
	      if (file_name == (char *) str)
		{
		  file_name = NULL;
		  nul_fun = NULL;
		}
	      else
		{
		  nul_fun = stab;
		  nul_str = str;
		  if (stab + STABSIZE + TYPEOFF < info->stabs + stabsize
		      && *(stab + STABSIZE + TYPEOFF) == (bfd_byte) N_SO)
		    {
		      /* Two consecutive N_SOs are a directory and a
			 file name.  */
		      stab += STABSIZE;
		      directory_name = file_name;
		      file_name = ((char *) str
				   + bfd_get_32 (abfd, stab + STRDXOFF));
		    }
		}
	      break;

	    case N_SOL:
	      /* The name of an include file.  */
	      file_name = (char *) str + bfd_get_32 (abfd, stab + STRDXOFF);
	      break;

	    case N_FUN:
	      /* A function name.  */
	      function_name = (char *) str + bfd_get_32 (abfd, stab + STRDXOFF);
	      if (function_name == (char *) str)
		continue;

	      nul_fun = NULL;
	      info->indextable[i].val = bfd_get_32 (abfd, stab + VALOFF);
	      info->indextable[i].stab = stab;
	      info->indextable[i].str = str;
	      info->indextable[i].directory_name = directory_name;
	      info->indextable[i].file_name = file_name;
	      info->indextable[i].function_name = function_name;
	      ++i;
	      break;
	    }
	}

      if (nul_fun != NULL)
	{
	  info->indextable[i].val = bfd_get_32 (abfd, nul_fun + VALOFF);
	  info->indextable[i].stab = nul_fun;
	  info->indextable[i].str = nul_str;
	  info->indextable[i].directory_name = directory_name;
	  info->indextable[i].file_name = file_name;
	  info->indextable[i].function_name = NULL;
	  ++i;
	}

      info->indextable[i].val = (bfd_vma) -1;
      info->indextable[i].stab = info->stabs + stabsize;
      info->indextable[i].str = str;
      info->indextable[i].directory_name = NULL;
      info->indextable[i].file_name = NULL;
      info->indextable[i].function_name = NULL;
      ++i;

      info->indextablesize = i;
      qsort (info->indextable, (size_t) i, sizeof (struct indexentry),
	     cmpindexentry);

      *pinfo = info;
    }

  /* We are passed a section relative offset.  The offsets in the
     stabs information are absolute.  */
  offset += bfd_get_section_vma (abfd, section);

#ifdef ENABLE_CACHING
  if (info->cached_indexentry != NULL
      && offset >= info->cached_offset
      && offset < (info->cached_indexentry + 1)->val)
    {
      stab = info->cached_stab;
      indexentry = info->cached_indexentry;
      file_name = info->cached_file_name;
    }
  else
#endif
    {
      long low, high;
      long mid = -1;

      /* Cache non-existent or invalid.  Do binary search on
         indextable.  */
      indexentry = NULL;

      low = 0;
      high = info->indextablesize - 1;
      while (low != high)
	{
	  mid = (high + low) / 2;
	  if (offset >= info->indextable[mid].val
	      && offset < info->indextable[mid + 1].val)
	    {
	      indexentry = &info->indextable[mid];
	      break;
	    }

	  if (info->indextable[mid].val > offset)
	    high = mid;
	  else
	    low = mid + 1;
	}

      if (indexentry == NULL)
	return TRUE;

      stab = indexentry->stab + STABSIZE;
      file_name = indexentry->file_name;
    }

  directory_name = indexentry->directory_name;
  str = indexentry->str;

  saw_line = FALSE;
  saw_func = FALSE;
  for (; stab < (indexentry+1)->stab; stab += STABSIZE)
    {
      bfd_boolean done;
      bfd_vma val;

      done = FALSE;

      switch (stab[TYPEOFF])
	{
	case N_SOL:
	  /* The name of an include file.  */
	  val = bfd_get_32 (abfd, stab + VALOFF);
	  if (val <= offset)
	    {
	      file_name = (char *) str + bfd_get_32 (abfd, stab + STRDXOFF);
	      *pline = 0;
	    }
	  break;

	case N_SLINE:
	case N_DSLINE:
	case N_BSLINE:
	  /* A line number.  If the function was specified, then the value
	     is relative to the start of the function.  Otherwise, the
	     value is an absolute address.  */
	  val = ((indexentry->function_name ? indexentry->val : 0)
		 + bfd_get_32 (abfd, stab + VALOFF));
	  /* If this line starts before our desired offset, or if it's
	     the first line we've been able to find, use it.  The
	     !saw_line check works around a bug in GCC 2.95.3, which emits
	     the first N_SLINE late.  */
	  if (!saw_line || val <= offset)
	    {
	      *pline = bfd_get_16 (abfd, stab + DESCOFF);

#ifdef ENABLE_CACHING
	      info->cached_stab = stab;
	      info->cached_offset = val;
	      info->cached_file_name = file_name;
	      info->cached_indexentry = indexentry;
#endif
	    }
	  if (val > offset)
	    done = TRUE;
	  saw_line = TRUE;
	  break;

	case N_FUN:
	case N_SO:
	  if (saw_func || saw_line)
	    done = TRUE;
	  saw_func = TRUE;
	  break;
	}

      if (done)
	break;
    }

  *pfound = TRUE;

  if (file_name == NULL || IS_ABSOLUTE_PATH (file_name)
      || directory_name == NULL)
    *pfilename = file_name;
  else
    {
      size_t dirlen;

      dirlen = strlen (directory_name);
      if (info->filename == NULL
	  || filename_ncmp (info->filename, directory_name, dirlen) != 0
	  || filename_cmp (info->filename + dirlen, file_name) != 0)
	{
	  size_t len;

	  /* Don't free info->filename here.  objdump and other
	     apps keep a copy of a previously returned file name
	     pointer.  */
	  len = strlen (file_name) + 1;
	  info->filename = (char *) bfd_alloc (abfd, dirlen + len);
	  if (info->filename == NULL)
	    return FALSE;
	  memcpy (info->filename, directory_name, dirlen);
	  memcpy (info->filename + dirlen, file_name, len);
	}

      *pfilename = info->filename;
    }

  if (indexentry->function_name != NULL)
    {
      char *s;

      /* This will typically be something like main:F(0,1), so we want
         to clobber the colon.  It's OK to change the name, since the
         string is in our own local storage anyhow.  */
      s = strchr (indexentry->function_name, ':');
      if (s != NULL)
	*s = '\0';

      *pfnname = indexentry->function_name;
    }

  return TRUE;
}
@


1.59
log
@	* syms.c (_bfd_stab_section_find_nearest_line): Add last_str
	var.  Use it with last_stab.
@
text
@d937 1
a937 1
  bfd_byte *last_stab, *last_str;
a941 1
  int saw_fun;
a989 1
      char *name;
d1022 1
d1104 1
a1104 1
      saw_fun = 1;
a1108 4
	      /* N_SO with null name indicates EOF */
	      if (bfd_get_32 (abfd, stab + STRDXOFF) == 0)
		continue;

d1110 1
a1110 1
	      if (saw_fun == 0)
d1113 6
a1118 1
	      saw_fun = 0;
d1120 4
a1123 5
	      /* two N_SO's in a row is a filename and directory. Skip */
	      if (stab + STABSIZE < info->stabs + stabsize
		  && *(stab + STABSIZE + TYPEOFF) == (bfd_byte) N_SO)
		{
		  stab += STABSIZE;
d1126 2
a1127 1
	  else if (stab[TYPEOFF] == (bfd_byte) N_FUN)
d1129 1
a1129 1
	      saw_fun = 1;
d1134 1
a1134 1
      if (saw_fun == 0)
d1149 1
a1149 1
      saw_fun = 1;
d1152 1
a1152 1
      for (i = 0, last_stab = stab = info->stabs, last_str = str = info->strs;
d1174 1
a1174 1
	      if (saw_fun == 0)
d1176 3
a1178 3
		  info->indextable[i].val = bfd_get_32 (abfd, last_stab + VALOFF);
		  info->indextable[i].stab = last_stab;
		  info->indextable[i].str = last_str;
a1183 1
	      saw_fun = 0;
d1185 1
d1187 1
a1187 1
	      if (*file_name == '\0')
a1188 1
		  directory_name = NULL;
d1190 1
a1190 1
		  saw_fun = 1;
d1194 4
a1197 8
		  last_stab = stab;
		  last_str = str;
		  if (stab + STABSIZE >= info->stabs + stabsize
		      || *(stab + STABSIZE + TYPEOFF) != (bfd_byte) N_SO)
		    {
		      directory_name = NULL;
		    }
		  else
d1216 2
a1217 9
	      saw_fun = 1;
	      name = (char *) str + bfd_get_32 (abfd, stab + STRDXOFF);

	      if (*name == '\0')
		name = NULL;

	      function_name = name;

	      if (name == NULL)
d1220 1
d1232 1
a1232 1
      if (saw_fun == 0)
d1234 3
a1236 3
	  info->indextable[i].val = bfd_get_32 (abfd, last_stab + VALOFF);
	  info->indextable[i].stab = last_stab;
	  info->indextable[i].str = last_str;
@


1.58
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d937 1
a937 1
  bfd_byte *last_stab = NULL;
d1150 1
d1152 1
a1152 1
      for (i = 0, stroff = 0, stab = info->stabs, str = info->strs;
d1178 1
a1178 1
		  info->indextable[i].str = str;
d1196 1
d1247 1
a1247 1
	  info->indextable[i].str = str;
@


1.57
log
@	PR binutils/13558
	* bfd/aout-cris.c: Include sysdep.h before bfd.h.
	* bfd/aout-ns32k.c: Likewise.
	* bfd/aout-sparcle.c: Likewise.
	* bfd/aout0.c: Likewise.
	* bfd/bfd-in2.h: Likewise.
	* bfd/coff-stgo32.c: Likewise.
	* bfd/cpu-lm32.c: Likewise.
	* bfd/cpu-microblaze.c: Likewise.
	* bfd/cpu-score.c: Likewise.
	* bfd/cpu-tilegx.c: Likewise.
	* bfd/cpu-tilepro.c: Likewise.
	* bfd/elf32-lm32.c: Likewise.
	* bfd/elf32-microblaze.c: Likewise.
	* bfd/elf32-score7.c: Likewise.
	* bfd/elf32-tilepro.c: Likewise.
	* bfd/elfxx-tilegx.c: Likewise.
	* bfd/mach-o.h: Likewise.
	* bfd/nlm32-ppc.c: Likewise.
	* bfd/ns32knetbsd.c: Likewise.
	* bfd/pef.h: Likewise.
	* bfd/plugin.c: Likewise.
	* bfd/stab-syms.c: Likewise.
	* bfd/sunos.c: Likewise.
	* bfd/syms.c: Likewise.
	* bfd/xsym.h: Likewise.

	* Makefile.am (CFILES): Add syslex_wrap.c.
	(sysinfo): Depend upon syslex_wrap.o.
	(syslex_wrap.o): New rule.
	(syslex.o): Delete rule.
	* syslex_wrap.c: New file.
	* Makefile.in: Regenerate.
@
text
@d80 1
a80 1
|	  
d1011 1
a1011 1
  
@


1.56
log
@ChangeLog libiberty/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filename_cmp.c (filename_ncmp): New function.
	* functions.texi: Regenerated.

ChangeLog include/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filenames.h (filename_ncmp): New prototype.

ChangeLog bfd/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* archive.c (_bfd_find_nested_archive): Use filename_(n)cmp.
	(adjust_relative_path): Likewise.
	(_bfd_construct_extended_name_table): Likewise.
	* corefile.c (generic_core_file_matches_executable_p): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-spu.c (sort_bfds): Likewise.
	(spu_elf_auto_overlay): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* xcofflink.c (xcoff_set_import_path): Likewise.
	* xtensa-isa.c (xtensa_regfile_lookup): Likewise.
	(xtensa_regfile_lookup_shortname): Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
d110 1
@


1.55
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d1389 2
a1390 2
	  || strncmp (info->filename, directory_name, dirlen) != 0
	  || strcmp (info->filename + dirlen, file_name) != 0)
@


1.54
log
@update copyright dates
@
text
@d477 1
a477 1
  FILE *file = arg;
d814 1
a814 1
  syms = bfd_malloc (storage);
d881 2
a882 2
  const struct indexentry *contestantA = a;
  const struct indexentry *contestantB = b;
d969 1
a969 1
  info = *pinfo;
d994 1
a994 1
      info = bfd_zalloc (abfd, amt);
d1027 2
a1028 2
      info->stabs = bfd_alloc (abfd, stabsize);
      info->strs = bfd_alloc (abfd, strsize);
d1045 1
a1045 1
      reloc_vector = bfd_malloc (reloc_size);
d1142 1
a1142 1
      info->indextable = bfd_alloc (abfd, amt);
d1398 1
a1398 1
	  info->filename = bfd_alloc (abfd, dirlen + len);
@


1.54.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d477 1
a477 1
  FILE *file = (FILE *) arg;
d814 1
a814 1
  syms = (asymbol **) bfd_malloc (storage);
d881 2
a882 2
  const struct indexentry *contestantA = (const struct indexentry *) a;
  const struct indexentry *contestantB = (const struct indexentry *) b;
d969 1
a969 1
  info = (struct stab_find_info *) *pinfo;
d994 1
a994 1
      info = (struct stab_find_info *) bfd_zalloc (abfd, amt);
d1027 2
a1028 2
      info->stabs = (bfd_byte *) bfd_alloc (abfd, stabsize);
      info->strs = (bfd_byte *) bfd_alloc (abfd, strsize);
d1045 1
a1045 1
      reloc_vector = (arelent **) bfd_malloc (reloc_size);
d1142 1
a1142 1
      info->indextable = (struct indexentry *) bfd_alloc (abfd, amt);
d1398 1
a1398 1
	  info->filename = (char *) bfd_alloc (abfd, dirlen + len);
@


1.53
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009
@


1.52
log
@        * config/obj-elf.c (obj_elf_type): Add code to support a type of
        gnu_unique_object.
        * doc/as.texinfo: Document new feature of .type directive.
        * NEWS: Mention support for gnu_unique_object symbol type.

        * common.h (STB_GNU_UNIQUE): Define.

        * NEWS: Mention the linker's support for symbols with a binding of
        STB_GNU_UNIQUE.

        * gas/elf/type.s: Add unique global symbol definition.
        * gas/elf/type.e: Add expected readelf output for global unique
        symbol.

        * elfcpp.h (enum STB): Add STB_GNU_UNIQUE.

        * readelf.c (get_symbol_binding): For Linux targeted files return
        UNIQUE for symbols with the STB_GNU_UNIQUE binding.
        * doc/binutils.texi: Document the meaning of the 'u' symbol
        binding in the output of nm and objdump --syms.

        * elf-bfd.h (struct elf_link_hash_entry): Add unique_global field.
        * elf.c (swap_out_syms): Set binding to STB_GNU_UNIQUE for symbols
        with the BSF_GNU_UNIQUE flag bit set.
        * elfcode.h (elf_slurp_symbol_table): Set the BSF_GNU_UNIQUE flag
        for symbols with STB_GNU_UNIQUE binding.
        * elflink.c (_bfd_elf_merge_symbol): Set unique_global for symbols
        with the STB_GNU_UNIQUE binding.
        (elf_link_add_object_symbols): Set the BSF_GNU_UNIQUE flag for
        symbols with STB_GNU_UNIQUE binding.  Set STB_GNU_UNIQUE for
        symbols with the unique_global field set.
        (elf_link_output_extsym): Set unique_global field for symbols with
        the STB_GNU_UNIQUE binding.
        * syms.c (struct bfd_symbol): Define BSF_GNU_UNIQUE flag bit.
        (bfd_print_symbol_vandf): Print a 'u' character for BSF_GNU_UNIQUE
        symbols.
        (bfd_decode_symclass): Return a 'u' character for BSF_GNU_UNIQUE
        symbols.
        * bfd-in2.h: Regenerate.
@
text
@d542 4
a545 4
  asymbol *new = bfd_zalloc (abfd, amt);
  if (new)
    new->the_bfd = abfd;
  return new;
@


1.51
log
@include/elf
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * common.h (STT_GNU_IFUNC): Define.

elfcpp
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * (enum STT): Add STT_GNU_IFUNC.

gas
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * config/obj-elf.c (obj_elf_type): Add support for a
        gnu_indirect_function type.
        * config/tc-i386.c (tc_i386_fix_adjustable): Do not adjust fixups
        against indirect function symbols.
        * doc/as.texinfo (.type): Document the support for the
        gnu_indirect_function symbol type.
        * NEWS: Mention the new feature.

gas/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * gas/elf/elf.exp: Extend type test to include an ifunc symbol.
        Provide an alternative test for targets which do not support ifunc
        symbols.
        (type.s): Add entry for an ifunc symbol.
        (type.e): Add ifunc entry to expected symbol dump.
        (section2.e-armelf): Add  entry for ifunc symbol.
        (type-noifunc.s): New file.
        (type-noifunc.e): New file.

bfd/
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs
        section pointer.
        (struct elf_obj_data): Add has_ifunc_symbols boolean.
        * elf.c (swap_out_syms): Convert BSF_GNU_INDIRECT_FUNCTION flags
        into a STT_GNU_IFUNC symbol type.
        (_bfd_elf_is_function_type): Accept STT_GNU_IFUNC as a function
        type.
        (_bfd_elf_set_osabi): Set the osasbi field to ELFOSABI_LINUX if
        the binary contains ifunc symbols.
        * elfcode.h (elf_slurp_symbol_table): Translate the STT_GNU_IFUNC
        symbol type into a BSF_GNU_INDIRECT_FUNCTION flag.
        * elf32-i386.c (is_indirect_function): New function.
        (elf_i386_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf_i386_relocate_section): Emit a reloc against an ifunc symbol
        if necessary.
        (elf_i386_add_symbol_hook): New function. Set the
        has_ifunc_symbols field of the elf_obj_data structure if an ifunc
        symbol is encountered.
        (elf_backend_post_process_headers): Define.
        (elf_backend_add_symbol_hook): Define.
        (elf_i386_post_process_headers): Rename to
        elf_i388_fbsd_post_process_headers.
        * elf64-x86_64.c (IS_X86_64_PCREL_TYPE): New macro.
        (is_indirect_function): New function.
        (elf64_x86_64_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf64_x86_64_relocate_section): Emit a reloc against an ifunc
        symbol if necessary.
        (elf_i386_add_symbol_hook): Set the has_ifunc_symbols field of the
        elf_obj_data structure if an ifunc symbol is encountered.
        (elf_backend_post_process_headers): Define.
        * elflink.c (_bfd_elf_adjust_dynamic_symbol): Always create a PLT
        if we have ifunc symbols to handle.
        (get_ifunc_reloc_section_name): New function.  Computes the name
        for an ifunc section.
        (_bfd_elf_make_ifunc_reloc_section): New function.  Creates a
        section to hold ifunc relocs.
        * syms.c (BSF_GNU_INDIRECT_FUNCTION): Define.
        (bfd_print_symbol_vandf): Handle ifunc symbols.
        (bfd_decode_symclass): Likewise.
        * bfd-in2.h: Regenerate.

binutils
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * readelf.c (dump_relocations): Display a relocation against an
        ifunc symbol as if it were a function invocation.
        (get_symbol_type): Handle STT_GNU_IFUNC.

ld
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * NEWS: Mention support for IFUNC symbols.

ld/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * ld-ifunc: New directory.
        * ld-ifunc/ifunc.exp: New file: Run the IFUNC tests.
        * ld-ifunc/prog.c: New file.
        * ld-ifunc/lib.c: New file.
@
text
@d305 4
d492 2
a493 1
	    : (type & BSF_GLOBAL) ? 'g' : ' '),
d694 2
@


1.50
log
@	PR 9735
	* syms.c (_bfd_stab_section_find_nearest_line): Don't free
	saved filename, use bfd_alloc rather than bfd_malloc for it.
@
text
@d300 6
d492 1
a492 1
	   (type & BSF_INDIRECT) ? 'I' : ' ',
d678 2
@


1.49
log
@Remove STT_IFUNC support.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2007, 2008
d1379 3
a1381 2
	  if (info->filename != NULL)
	    free (info->filename);
d1383 1
a1383 1
	  info->filename = bfd_malloc (dirlen + len);
@


1.48
log
@include/elf/
            * common.h (STT_IFUNC): Define.
elfcpp/
            * elfcpp.h (enum STT): Add STT_IFUNC.
bfd/
            * syms.c (struct bfd_symbol): Add new flag BSF_INDIRECT_FUNCTION.
            Remove redundant flag BFD_FORT_COMM_DEFAULT_VALUE.  Renumber flags
            to remove gaps.
            (bfd_print_symbol_vandf): Return 'i' for BSF_INDIRECT_FUNCTION.
            (bfd_decode_symclass): Likewise.
            * elf.c (swap_out_syms): Translate BSF_INDIRECT_FUNCTION into
            STT_IFUNC.
            (elf_find_function): Treat STT_IFUNC in the same way as STT_FUNC.
            (_bfd_elf_is_function_type): Likewise.
            * elf32-arm.c (arm_elf_find_function): Likewise.
            (elf32_arm_adjust_dynamic_symbol): Likewise.
            (elf32_arm_swap_symbol_in): Likewise.
            (elf32_arm_additional_program_headers): Likewise.
            * elf32-i386.c (is_indirect_symbol): New function.
            (elf_i386_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf_i386_relocate_section): Likewise.
            * elf64-x86-64.c (is_indirect_symbol): New function.
            (elf64_x86_64_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf64_x86_64_relocate_section): Likewise.
            * elfcode.h (elf_slurp_symbol_table): Translate STT_IFUNC into
            BSF_INDIRECT_FUNCTION.
            * elflink.c (_bfd_elf_adjust_dynamic_reloc_section): Add support
            for STT_IFUNC symbols.
            (get_ifunc_reloc_section_name): New function.
            (_bfd_elf_make_ifunc_reloc_section): New function.
            * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs field.
            * bfd-in2.h: Regenerate.
gas/
            * config/obj-elf.c (obj_elf_type): Add support for STT_IFUNC type.
            * doc/as.texinfo: Document new feature.
            * NEWS: Mention new feature.
gas/testsuite/
            * gas/elf/type.s: Add test of STT_IFUNC symbol type.
            * gas/elf/type.e: Update expected disassembly.
            * gas/elf/elf.exp: Update grep of symbol types.
ld/
            * NEWS: Mention new feature.
            * pe-dll.c (process_def_file): Replace use of redundant
            BFD_FORT_COMM_DEFAULT_VALUE with 0.
            * scripttempl/elf.sc: Add .rel.ifunc.dyn and .rela.ifunc.dyn
            sections.
ld/testsuite/
            * ld-mips-elf/reloc-1-n32.d: Updated expected output for reloc
            descriptions.
            * ld-mips-elf/reloc-1-n64.d: Likewise.
            * ld-i386/ifunc.d: New test.
            * ld-i386/ifunc.s: Source file for the new test.
            * ld-i386/i386.exp: Run the new test.
@
text
@a233 7
.  {* The symbol is an indirect code object.  Unrelated to BSF_INDIRECT.
.     Relocations against a symbol with this flag have to evaluated at
.     run-time, where the function pointed to by this symbol is invoked
.     in order to determine the value to be used in the relocation.
.     BSF_FUNCTION must also be set for symbols with this flag.  *}
.#define BSF_INDIRECT_FUNCTION	(1 << 4)
. 
d486 1
a486 1
	   (type & BSF_INDIRECT) ? 'I' : (type & BSF_INDIRECT_FUNCTION) ? 'i' : ' ',
a671 2
  if (symbol->flags & BSF_INDIRECT_FUNCTION)
    return 'i';
@


1.47
log
@bfd/
	* syms.c (BSF_SYNTHETIC): New flag.
	* elf.c (_bfd_elf_get_synthetic_symtab): Set it.
	* elf32-ppc.c (ppc_elf_get_synthetic_symtab): Likewise.
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Likewise.
	* bfd-in.h (bfd_asymbol_flavour): Return bfd_target_unknown_flavour
	for synthetic symbols.
	* bfd-in2.h: Regenerate.

opcodes/
	* mips-dis.c (_print_insn_mips): Use bfd_asymbol_flavour to check
	for ELF symbols.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2007
d208 1
a208 1
.#define BSF_NO_FLAGS    0x00
d212 1
a212 1
.#define BSF_LOCAL	0x01
d216 1
a216 1
.#define BSF_GLOBAL	0x02
d223 1
a223 1
.     <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
d228 1
a228 1
.#define BSF_DEBUGGING	0x08
d232 1
a232 1
.#define BSF_FUNCTION    0x10
d234 7
d242 2
a243 2
.#define BSF_KEEP        0x20
.#define BSF_KEEP_G      0x40
d247 1
a247 1
.#define BSF_WEAK        0x80
d251 1
a251 1
.#define BSF_SECTION_SYM 0x100
d255 1
a255 4
.#define BSF_OLD_COMMON  0x200
.
.  {* The default value for common data.  *}
.#define BFD_FORT_COMM_DEFAULT_VALUE 0
d262 1
a262 1
.#define BSF_NOT_AT_END    0x400
d265 1
a265 1
.#define BSF_CONSTRUCTOR   0x800
d271 1
a271 1
.#define BSF_WARNING       0x1000
d275 1
a275 1
.#define BSF_INDIRECT      0x2000
d279 1
a279 1
.#define BSF_FILE          0x4000
d282 1
a282 1
.#define BSF_DYNAMIC	   0x8000
d286 1
a286 1
.#define BSF_OBJECT	   0x10000
d291 1
a291 1
.#define BSF_DEBUGGING_RELOC 0x20000
d294 1
a294 1
.#define BSF_THREAD_LOCAL  0x40000
d298 1
a298 1
.#define BSF_RELC 0x80000
d302 1
a302 1
.#define BSF_SRELC 0x100000
d305 1
a305 1
.#define BSF_SYNTHETIC 0x200000
d493 1
a493 1
	   (type & BSF_INDIRECT) ? 'I' : ' ',
d679 2
@


1.47.4.1
log
@backport 2009-01-14  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009
d1382 2
a1383 3
	  /* Don't free info->filename here.  objdump and other
	     apps keep a copy of a previously returned file name
	     pointer.  */
d1385 1
a1385 1
	  info->filename = bfd_alloc (abfd, dirlen + len);
@


1.46
log
@* syms.c (_bfd_stab_section_find_nearest_line): Look at the
  specific SOM sections for stabs if the regular ones are not found.
* som.h (struct somdata): Add a line_info field, to be used by som_find_nearest_line.
* som.c (som_find_nearest_line): Implement using the bfd stabs function above.
@
text
@d300 3
@


1.45
log
@2007-07-26  Michael Snyder  <msnyder@@access-company.com>

	* syms.c (bfd_decode_symclass): Guard against NULL, since
	bfd_is_com_section dereferences the pointer.
@
text
@d992 11
a1002 4
	  /* No stabs debugging information.  Set *pinfo so that we
             can return quickly in the info != NULL case above.  */
	  *pinfo = info;
	  return TRUE;
@


1.44
log
@Switch sources over to use the GPL version 3
@
text
@d654 1
a654 1
  if (bfd_is_com_section (symbol->section))
@


1.43
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.42
log
@Support for Toshiba MeP and for complex relocations.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d318 1
a319 1
#include "sysdep.h"
@


1.41
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d291 8
@


1.40
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.39
log
@Implement a new BFD API function: bfd_is_target_special_symbol.  Use this in nm
and objdump to skip the displaying of ARM Mapping symbols unless specifically
requested.
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.38
log
@	* syms.c (bfd_is_local_label): Return false for file symbols.
@
text
@d385 17
@


1.37
log
@	PR 425
	* syms.c (_bfd_stab_section_find_nearest_line): Ignore R_*_NONE relocs.
@
text
@d358 1
a358 1
  if ((sym->flags & (BSF_GLOBAL | BSF_WEAK | BSF_SECTION_SYM)) != 0)
@


1.36
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d1019 4
@


1.35
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d937 6
a942 2
      stabsize = info->stabsec->_raw_size;
      strsize = info->strsec->_raw_size;
d972 6
a977 2
      stabsize = info->stabsec->_raw_size;
      strsize = info->strsec->_raw_size;
d985 1
a985 1
				      (bfd_vma) 0, stabsize)
d987 1
a987 1
					 (bfd_vma) 0, strsize))
@


1.35.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d937 2
a938 6
      stabsize = (info->stabsec->rawsize
		  ? info->stabsec->rawsize
		  : info->stabsec->size);
      strsize = (info->strsec->rawsize
		 ? info->strsec->rawsize
		 : info->strsec->size);
d968 2
a969 6
      stabsize = (info->stabsec->rawsize
		  ? info->stabsec->rawsize
		  : info->stabsec->size);
      strsize = (info->strsec->rawsize
		 ? info->strsec->rawsize
		 : info->strsec->size);
d977 1
a977 1
				      0, stabsize)
d979 1
a979 1
					 0, strsize))
@


1.34
log
@Index: sim/frv/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* traps.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/d10v/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* simops.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/common/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* sim-trace.c, sim-base.h: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: ld/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* emultempl/pe.em, pe-dll.c: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: bfd/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* syms.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".
	* vms.h, targets.c, section.c, reloc.c, peicode.h: Ditto.
	* mipsbsd.c, elf.c, linker.c, elf-bfd.h, ecoff.c: Ditto.
	* cpu-z8k.c, cpu-ns32k.c, cpu-h8500.c, bfd.c, bfd-in.h: Ditto.
	* bfd-in2.h: Re-generate.
@
text
@d136 1
a136 1
	Many formats cannot represent arbitary symbol information; for
d138 1
a138 1
	arbitary number of sections. A symbol pointing to a section
d225 1
a225 1
.  {* The symbol is a debugging record. The value has an arbitary
d1225 1
a1225 1
      /* Cache non-existant or invalid.  Do binary search on
@


1.33
log
@2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* targets.c: Replace "struct sec" with "struct bfd_section"
	* syms.c, sparclynx.c, section.c, opncls.c: Ditto.
	* libcoff-in.h, libbfd-in.h, elfxx-target.h: Ditto.
	* elf.c, coffgen.c, bfd.c, bfd-in.h, aoutf1.h: Ditto.
	* aout-tic30.c, aout-target.h:
	* bfd-in2.h, libcoff.h, libbfd.h: Regenerate.

Index: binutils/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* coffgrok.h (coff_section): Replace 'struct sec" with "struct
	bfd_section".

Index: gdb/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c: Replace "struct sec" with "struct bfd_section".
	* objfiles.c, linespec.c, blockframe.c, block.c: Ditto.

Index: ld/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* pe-dll.c: Replace "struct sec" with "struct bfd_section".

Index: sim/common/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* sim-base.h: Replace "struct sec" with "struct bfd_section".
@
text
@d184 1
a184 1
.typedef struct symbol_cache_entry
@


1.32
log
@Convert to C90 and a few tweaks.
@
text
@d296 1
a296 1
.  struct sec *section;
d584 1
a584 1
decode_section_type (const struct sec *section)
@


1.31
log
@Correct spelling of "relocatable".
@
text
@d80 1
a80 1
|	  symbol_table = (asymbol **) xmalloc (storage_needed);
d125 1
a125 1
|	  ptrs[1] = (asymbol *)0;
d301 1
a301 1
.      PTR p;
a316 4
static char coff_section_type PARAMS ((const char *));
static char decode_section_type PARAMS ((const struct sec *));
static int cmpindexentry PARAMS ((const PTR, const PTR));

d353 1
a353 3
bfd_is_local_label (abfd, sym)
     bfd *abfd;
     asymbol *sym;
d379 1
a379 1
.     BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
d395 1
a395 2
.     BFD_SEND (abfd, _bfd_canonicalize_symtab,\
.                  (abfd, location))
d404 2
a405 1
	bfd_boolean bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int count);
d414 1
a414 4
bfd_set_symtab (abfd, location, symcount)
     bfd *abfd;
     asymbol **location;
     unsigned int symcount;
d416 1
a416 1
  if ((abfd->format != bfd_object) || (bfd_read_p (abfd)))
d432 1
a432 1
	void bfd_print_symbol_vandf (bfd *abfd, PTR file, asymbol *symbol);
d439 1
a439 4
bfd_print_symbol_vandf (abfd, arg, symbol)
     bfd *abfd;
     PTR arg;
     asymbol *symbol;
d441 1
a441 1
  FILE *file = (FILE *) arg;
d445 2
a446 3
  if (symbol->section != (asection *) NULL)
    bfd_fprintf_vma (abfd, file,
		     symbol->value + symbol->section->vma);
d483 1
a483 1
.     BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
d492 1
a492 1
	asymbol * _bfd_generic_make_empty_symbol (bfd *);
d502 1
a502 2
_bfd_generic_make_empty_symbol (abfd)
     bfd *abfd;
d505 1
a505 1
  asymbol *new = (asymbol *) bfd_zalloc (abfd, amt);
d521 1
a521 1
.        BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
d565 1
a565 2
coff_section_type (s)
     const char *s;
d584 1
a584 2
decode_section_type (section)
     const struct sec *section;
d606 1
a606 2
  if ((section->flags & SEC_HAS_CONTENTS) &&
      (section->flags & SEC_READONLY))
d624 1
a624 2
bfd_decode_symclass (symbol)
     asymbol *symbol;
d696 1
a696 2
bfd_is_undefined_symclass (symclass)
     int symclass;
d715 1
a715 3
bfd_symbol_info (symbol, ret)
     asymbol *symbol;
     symbol_info *ret;
d732 2
a733 1
	bfd_boolean bfd_copy_private_symbol_data (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
d745 2
a746 2
.     BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
.		(ibfd, isymbol, obfd, osymbol))
d755 4
a758 5
_bfd_generic_read_minisymbols (abfd, dynamic, minisymsp, sizep)
     bfd *abfd;
     bfd_boolean dynamic;
     PTR *minisymsp;
     unsigned int *sizep;
d773 1
a773 1
  syms = (asymbol **) bfd_malloc ((bfd_size_type) storage);
d784 1
a784 1
  *minisymsp = (PTR) syms;
d800 4
a803 5
_bfd_generic_minisymbol_to_symbol (abfd, dynamic, minisym, sym)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean dynamic ATTRIBUTE_UNUSED;
     const PTR minisym;
     asymbol *sym ATTRIBUTE_UNUSED;
d838 1
a838 3
cmpindexentry (a, b)
     const PTR a;
     const PTR b;
d840 2
a841 2
  const struct indexentry *contestantA = (const struct indexentry *) a;
  const struct indexentry *contestantB = (const struct indexentry *) b;
d882 9
a890 11
_bfd_stab_section_find_nearest_line (abfd, symbols, section, offset, pfound,
				     pfilename, pfnname, pline, pinfo)
     bfd *abfd;
     asymbol **symbols;
     asection *section;
     bfd_vma offset;
     bfd_boolean *pfound;
     const char **pfilename;
     const char **pfnname;
     unsigned int *pline;
     PTR *pinfo;
d928 1
a928 1
  info = (struct stab_find_info *) *pinfo;
d949 1
a949 1
      info = (struct stab_find_info *) bfd_zalloc (abfd, amt);
d964 1
a964 1
	  *pinfo = (PTR) info;
d971 2
a972 2
      info->stabs = (bfd_byte *) bfd_alloc (abfd, stabsize);
      info->strs = (bfd_byte *) bfd_alloc (abfd, strsize);
d989 1
a989 1
      reloc_vector = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
d1082 1
a1082 1
      info->indextable = (struct indexentry *) bfd_alloc (abfd, amt);
d1203 1
a1203 1
      *pinfo = (PTR) info;
d1337 1
a1337 1
	  info->filename = (char *) bfd_malloc ((bfd_size_type) dirlen + len);
@


1.30
log
@Return 'n' if section flags are	SEC_HAS_CONTENTS && SEC_READONLY.
@
text
@d1008 1
a1008 1
      /* If this is a relocateable object file, we have to relocate
@


1.29
log
@	* bfd-in.h (_bfd): Don't define.
	* bfd.c: Rename occurrences of "struct _bfd" to "struct bfd".
	* syms.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d622 3
@


1.28
log
@(_bfd_stab_section_find_nearest_line): For line number stabs outside of
functions, treat values as absolute addresses.
@
text
@d195 1
a195 1
.  struct _bfd *the_bfd; {* Use bfd_asymbol_bfd(sym) to access this field.  *}
@


1.27
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d77 3
a79 3
|	  if (storage_needed == 0) {
|	     return ;
|	  }
d88 2
a89 3
|	  for (i = 0; i < number_of_symbols; i++) {
|	     process_symbol (symbol_table[i]);
|	  }
d110 1
a110 1
|	main()
d116 3
a118 3
|	  abfd = bfd_openw("foo","a.out-sunos-big");
|	  bfd_set_format(abfd, bfd_object);
|	  new = bfd_make_empty_symbol(abfd);
d120 1
a120 1
|	  new->section = bfd_make_section_old_way(abfd, ".text");
d127 3
a129 2
|	  bfd_set_symtab(abfd, ptrs, 1);
|	  bfd_close(abfd);
d349 1
a349 1
        bfd_boolean bfd_is_local_label(bfd *abfd, asymbol *sym);
d441 1
a441 1
	void bfd_print_symbol_vandf(bfd *abfd, PTR file, asymbol *symbol);
d454 1
d456 1
d458 2
a459 4
    {
      bfd_fprintf_vma (abfd, file,
		       symbol->value + symbol->section->vma);
    }
d461 1
a461 3
    {
      bfd_fprintf_vma (abfd, file, symbol->value);
    }
d505 1
a505 1
	asymbol *_bfd_generic_make_empty_symbol (bfd *);
d635 1
a635 1
	int bfd_decode_symclass(asymbol *symbol);
d727 1
a727 1
	void bfd_symbol_info(asymbol *symbol, symbol_info *ret);
d750 1
a750 1
	bfd_boolean bfd_copy_private_symbol_data(bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
a816 1
/*ARGSUSED*/
a1244 3
      /* Cache non-existant or invalid.  Do binary search on
         indextable.  */

d1248 2
d1304 5
a1308 3
	  /* A line number.  The value is relative to the start of the
             current function.  */
	  val = indexentry->val + bfd_get_32 (abfd, stab + VALOFF);
a1376 1

@


1.26
log
@	* aoutx.h (NAME(aout,swap_ext_reloc_in)): Cast bytes->r_index to
	unsigned int.  Cast RELOC_BASE10, RELOC_BASE13 and RELOC_BASE22 to
	unsigned int.
	(NAME(aout,final_link)): Cast enum used in assignment.
	(aout_link_write_symbols): Cast enums in comparisons, int values to
	boolean, enums in assignments to int.
	(aout_link_input_section_std): Cast rel->r_index to unsigned int.
	(aout_link_input_section_ext): Likewise.  Cast enums used in comparisons
	with unsigned ints.
	(aout_link_reloc_link_order): Cast enum to int in assignment.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Cast result of memchr
	calls to char *.
	* bfd-in.h (bfd_set_section_vma): Cast enum true to unsigned int in
	assignment.
	* bfd-in2.h (bfd_set_section_vma): Likewise.
	* bfd.c (bfd_record_phdr): Cast enums in assignments.
	* binary.c (bfd_alloc): Cast enum to long.
	* coffgen.c (_bfd_coff_is_local_label_name): Cast return to boolean.
	* dwarf2.c (read_abbrevs): Add casts to enum types.
	(read_attribute_value): Likewise.
	(arange_add): Cast result of bfd_zalloc call.
	(comp_unit_contains_address): Return true and false.
	(comp_unit_find_nearest_line): Cast return to boolean.
	* format.c (bfd_check_format_matches, bfd_set_format): Likewise.
	* gen-aout.c: define macro '_' if not defined.
	* libbfd.c (bfd_realloc): Cast malloc and realloc to PTR.
	(bfd_bwrite): Cast bfd_realloc to bfd_byte *.
	(bfd_write_bigendian_4byte_int): Cast return to boolean.
	(bfd_seek): Cast bfd_realloc to bfd_byte *.
	(bfd_generic_is_local_label_name): Cast return to boolean.
	* libcoff.h (_bfd_coff_adjust_symndx): Remove extraneous '\'.
	* linker.c (_bfd_link_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(_bfd_generic_link_hash_newfunc): likewise.
	(_bfd_generic_final_link): Cast enum to unsigned int.
	* merge.c (sec_merge_emit): Cast return to boolean.
	(merge_strings): Add casts to const unsigned char *.
	* reloc.c (bfd_get_reloc_code_name): Cast enums in comparison to int.
	(bfd_generic_get_relocated_section_content): Cast enum to unsigned int.
	* section.c (bfd_section_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(bfd_set_section_content): Add cast to PTR in comparison.
	* simple.c (simple_dummy_warning, simple_dummy_undefined_symbol,
	simple_dummy_reloc_overflow, simple_dummy_reloc_dangerous,
	simple_dummy_unattached_reloc,
	bfd_simple_get_relocated_section_contents): Add K&R declarations and
	function definitions.
	* srec.c (S3Forced): Initialize to false.
	(srec_get_symtab): Cast return value from bfd_alloc to asymbol *.
	* stabs.c (_bfd_link_section_stabs): Cast enum to int in comparisons.
	(_bfd_discard_section_stabs): Likewise.  Also cast return to boolean.
	* syms.c (bfd_is_undefined_symclass): Cast return to boolean.
	(_bfd_stab_section_find_nearest_line): Cast enum to bfd_byte in
	comparisons.
@
text
@d349 1
a349 1
        boolean bfd_is_local_label(bfd *abfd, asymbol *sym);
d352 2
a353 2
	Return true if the given symbol @@var{sym} in the BFD @@var{abfd} is
	a compiler generated local label, else return false.
d356 1
a356 1
boolean
d365 1
a365 1
    return false;
d367 1
a367 1
    return false;
d376 1
a376 1
        boolean bfd_is_local_label_name(bfd *abfd, const char *name);
d379 1
a379 1
	Return true if a symbol with the name @@var{name} in the BFD
d381 1
a381 1
	false.  This just checks whether the name has the form of a
d411 1
a411 1
	boolean bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int count);
d419 1
a419 1
boolean
d428 1
a428 1
      return false;
d433 1
a433 1
  return true;
d709 1
a709 1
	boolean bfd_is_undefined_symclass (int symclass);
d712 1
a712 1
boolean
d716 1
a716 1
  return (boolean) (symclass == 'U' || symclass == 'w' || symclass == 'v');
d752 1
a752 1
	boolean bfd_copy_private_symbol_data(bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
d757 1
a757 1
	Return <<true>> on success, <<false>> on error.  Possible error
d776 1
a776 1
     boolean dynamic;
d823 1
a823 1
     boolean dynamic ATTRIBUTE_UNUSED;
d833 1
a833 1
   to true if it finds some information.  The *pinfo field is used to
d905 1
a905 1
boolean
d912 1
a912 1
     boolean *pfound;
d927 1
a927 1
  boolean saw_line, saw_func;
d929 1
a929 1
  *pfound = false;
d960 1
a960 1
	  return true;
d977 1
a977 1
	return false;
d991 1
a991 1
	  return true;
d1000 1
a1000 1
	return false;
d1006 1
a1006 1
	return false;
d1014 1
a1014 1
	return false;
d1017 1
a1017 1
	return false;
d1024 1
a1024 1
	  return false;
d1049 1
a1049 1
		  return false;
d1103 1
a1103 1
	return true;
d1110 1
a1110 1
	return false;
d1275 1
a1275 1
	return true;
d1284 2
a1285 2
  saw_line = false;
  saw_func = false;
d1288 1
a1288 1
      boolean done;
d1291 1
a1291 1
      done = false;
d1327 2
a1328 2
	    done = true;
	  saw_line = true;
d1334 2
a1335 2
	    done = true;
	  saw_func = true;
d1343 1
a1343 1
  *pfound = true;
d1364 1
a1364 1
	    return false;
d1387 1
a1387 1
  return true;
@


1.25
log
@Set bfd_error to no_symbols if the symbols could not be read.
@
text
@d716 1
a716 1
  return symclass == 'U' || symclass == 'w' || symclass == 'v';
d1073 1
a1073 1
	  if (stab[TYPEOFF] == N_SO)
d1087 1
a1087 1
		  && *(stab + STABSIZE + TYPEOFF) == N_SO)
d1092 1
a1092 1
	  else if (stab[TYPEOFF] == N_FUN)
d1161 1
a1161 1
		      || *(stab + STABSIZE + TYPEOFF) != N_SO)
@


1.25.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d77 4
a80 4
|	  if (storage_needed == 0)
|	    return;
|	  
|	  symbol_table = xmalloc (storage_needed);
d88 3
a90 2
|	  for (i = 0; i < number_of_symbols; i++)
|	    process_symbol (symbol_table[i]);
d111 1
a111 1
|	int main (void)
d117 3
a119 3
|	  abfd = bfd_openw ("foo","a.out-sunos-big");
|	  bfd_set_format (abfd, bfd_object);
|	  new = bfd_make_empty_symbol (abfd);
d121 1
a121 1
|	  new->section = bfd_make_section_old_way (abfd, ".text");
d126 1
a126 1
|	  ptrs[1] = 0;
d128 2
a129 3
|	  bfd_set_symtab (abfd, ptrs, 1);
|	  bfd_close (abfd);
|	  return 0;
d136 1
a136 1
	Many formats cannot represent arbitrary symbol information; for
d138 1
a138 1
	arbitrary number of sections. A symbol pointing to a section
d184 1
a184 1
.typedef struct bfd_symbol
d195 1
a195 1
.  struct bfd *the_bfd; {* Use bfd_asymbol_bfd(sym) to access this field.  *}
d225 1
a225 1
.  {* The symbol is a debugging record. The value has an arbitrary
d296 1
a296 1
.  struct bfd_section *section;
d301 1
a301 1
.      void *p;
d317 4
d349 1
a349 1
        bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);
d352 2
a353 2
	Return TRUE if the given symbol @@var{sym} in the BFD @@var{abfd} is
	a compiler generated local label, else return FALSE.
d356 4
a359 2
bfd_boolean
bfd_is_local_label (bfd *abfd, asymbol *sym)
d365 1
a365 1
    return FALSE;
d367 1
a367 1
    return FALSE;
d376 1
a376 1
        bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);
d379 1
a379 1
	Return TRUE if a symbol with the name @@var{name} in the BFD
d381 1
a381 1
	FALSE.  This just checks whether the name has the form of a
d385 1
a385 1
.  BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
d401 2
a402 1
.  BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))
d411 1
a411 2
	bfd_boolean bfd_set_symtab
	  (bfd *abfd, asymbol **location, unsigned int count);
d419 5
a423 2
bfd_boolean
bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int symcount)
d425 1
a425 1
  if (abfd->format != bfd_object || bfd_read_p (abfd))
d428 1
a428 1
      return FALSE;
d433 1
a433 1
  return TRUE;
d441 1
a441 1
	void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);
d448 4
a451 1
bfd_print_symbol_vandf (bfd *abfd, void *arg, asymbol *symbol)
d453 1
a453 2
  FILE *file = arg;

d455 5
a459 3

  if (symbol->section != NULL)
    bfd_fprintf_vma (abfd, file, symbol->value + symbol->section->vma);
d461 3
a463 1
    bfd_fprintf_vma (abfd, file, symbol->value);
d498 1
a498 1
.  BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
d517 2
a518 1
_bfd_generic_make_empty_symbol (bfd *abfd)
d521 1
a521 1
  asymbol *new = bfd_zalloc (abfd, amt);
d537 1
a537 1
.  BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
d581 2
a582 1
coff_section_type (const char *s)
d601 2
a602 1
decode_section_type (const struct bfd_section *section)
a623 2
  if ((section->flags & SEC_HAS_CONTENTS) && (section->flags & SEC_READONLY))
    return 'n';
d637 1
a637 1
	int bfd_decode_symclass (asymbol *symbol);
d640 2
a641 1
bfd_decode_symclass (asymbol *symbol)
d709 1
a709 1
	bfd_boolean bfd_is_undefined_symclass (int symclass);
d712 3
a714 2
bfd_boolean
bfd_is_undefined_symclass (int symclass)
d729 1
a729 1
	void bfd_symbol_info (asymbol *symbol, symbol_info *ret);
d733 3
a735 1
bfd_symbol_info (asymbol *symbol, symbol_info *ret)
d752 1
a752 2
	bfd_boolean bfd_copy_private_symbol_data
	  (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
d757 1
a757 1
	Return <<TRUE>> on success, <<FALSE>> on error.  Possible error
d764 2
a765 2
.  BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
.            (ibfd, isymbol, obfd, osymbol))
d774 5
a778 4
_bfd_generic_read_minisymbols (bfd *abfd,
			       bfd_boolean dynamic,
			       void **minisymsp,
			       unsigned int *sizep)
d793 1
a793 1
  syms = bfd_malloc (storage);
d804 1
a804 1
  *minisymsp = syms;
d819 1
d821 5
a825 4
_bfd_generic_minisymbol_to_symbol (bfd *abfd ATTRIBUTE_UNUSED,
				   bfd_boolean dynamic ATTRIBUTE_UNUSED,
				   const void *minisym,
				   asymbol *sym ATTRIBUTE_UNUSED)
d833 1
a833 1
   to TRUE if it finds some information.  The *pinfo field is used to
d860 3
a862 1
cmpindexentry (const void *a, const void *b)
d864 2
a865 2
  const struct indexentry *contestantA = a;
  const struct indexentry *contestantB = b;
d905 12
a916 10
bfd_boolean
_bfd_stab_section_find_nearest_line (bfd *abfd,
				     asymbol **symbols,
				     asection *section,
				     bfd_vma offset,
				     bfd_boolean *pfound,
				     const char **pfilename,
				     const char **pfnname,
				     unsigned int *pline,
				     void **pinfo)
d927 1
a927 1
  bfd_boolean saw_line, saw_func;
d929 1
a929 1
  *pfound = FALSE;
d954 1
a954 1
  info = *pinfo;
d960 1
a960 1
	  return TRUE;
d975 1
a975 1
      info = bfd_zalloc (abfd, amt);
d977 1
a977 1
	return FALSE;
d990 2
a991 2
	  *pinfo = info;
	  return TRUE;
d997 2
a998 2
      info->stabs = bfd_alloc (abfd, stabsize);
      info->strs = bfd_alloc (abfd, strsize);
d1000 1
a1000 1
	return FALSE;
d1006 1
a1006 1
	return FALSE;
d1008 1
a1008 1
      /* If this is a relocatable object file, we have to relocate
d1014 2
a1015 2
	return FALSE;
      reloc_vector = bfd_malloc (reloc_size);
d1017 1
a1017 1
	return FALSE;
d1024 1
a1024 1
	  return FALSE;
d1049 1
a1049 1
		  return FALSE;
d1073 1
a1073 1
	  if (stab[TYPEOFF] == (bfd_byte) N_SO)
d1087 1
a1087 1
		  && *(stab + STABSIZE + TYPEOFF) == (bfd_byte) N_SO)
d1092 1
a1092 1
	  else if (stab[TYPEOFF] == (bfd_byte) N_FUN)
d1103 1
a1103 1
	return TRUE;
d1108 1
a1108 1
      info->indextable = bfd_alloc (abfd, amt);
d1110 1
a1110 1
	return FALSE;
d1161 1
a1161 1
		      || *(stab + STABSIZE + TYPEOFF) != (bfd_byte) N_SO)
d1229 1
a1229 1
      *pinfo = info;
d1248 3
a1253 2
      /* Cache non-existent or invalid.  Do binary search on
         indextable.  */
d1275 1
a1275 1
	return TRUE;
d1284 2
a1285 2
  saw_line = FALSE;
  saw_func = FALSE;
d1288 1
a1288 1
      bfd_boolean done;
d1291 1
a1291 1
      done = FALSE;
d1308 3
a1310 5
	  /* A line number.  If the function was specified, then the value
	     is relative to the start of the function.  Otherwise, the
	     value is an absolute address.  */
	  val = ((indexentry->function_name ? indexentry->val : 0)
		 + bfd_get_32 (abfd, stab + VALOFF));
d1327 2
a1328 2
	    done = TRUE;
	  saw_line = TRUE;
d1334 2
a1335 2
	    done = TRUE;
	  saw_func = TRUE;
d1343 1
a1343 1
  *pfound = TRUE;
d1362 1
a1362 1
	  info->filename = bfd_malloc (dirlen + len);
d1364 1
a1364 1
	    return FALSE;
d1379 1
d1387 1
a1387 1
  return TRUE;
@


1.25.10.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d716 1
a716 1
  return (boolean) (symclass == 'U' || symclass == 'w' || symclass == 'v');
d1073 1
a1073 1
	  if (stab[TYPEOFF] == (bfd_byte) N_SO)
d1087 1
a1087 1
		  && *(stab + STABSIZE + TYPEOFF) == (bfd_byte) N_SO)
d1092 1
a1092 1
	  else if (stab[TYPEOFF] == (bfd_byte) N_FUN)
d1161 1
a1161 1
		      || *(stab + STABSIZE + TYPEOFF) != (bfd_byte) N_SO)
@


1.25.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d349 1
a349 1
        bfd_boolean bfd_is_local_label(bfd *abfd, asymbol *sym);
d352 2
a353 2
	Return TRUE if the given symbol @@var{sym} in the BFD @@var{abfd} is
	a compiler generated local label, else return FALSE.
d356 1
a356 1
bfd_boolean
d365 1
a365 1
    return FALSE;
d367 1
a367 1
    return FALSE;
d376 1
a376 1
        bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);
d379 1
a379 1
	Return TRUE if a symbol with the name @@var{name} in the BFD
d381 1
a381 1
	FALSE.  This just checks whether the name has the form of a
d411 1
a411 1
	bfd_boolean bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int count);
d419 1
a419 1
bfd_boolean
d428 1
a428 1
      return FALSE;
d433 1
a433 1
  return TRUE;
d709 1
a709 1
	bfd_boolean bfd_is_undefined_symclass (int symclass);
d712 1
a712 1
bfd_boolean
d716 1
a716 1
  return symclass == 'U' || symclass == 'w' || symclass == 'v';
d752 1
a752 1
	bfd_boolean bfd_copy_private_symbol_data(bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
d757 1
a757 1
	Return <<TRUE>> on success, <<FALSE>> on error.  Possible error
d776 1
a776 1
     bfd_boolean dynamic;
d823 1
a823 1
     bfd_boolean dynamic ATTRIBUTE_UNUSED;
d833 1
a833 1
   to TRUE if it finds some information.  The *pinfo field is used to
d905 1
a905 1
bfd_boolean
d912 1
a912 1
     bfd_boolean *pfound;
d927 1
a927 1
  bfd_boolean saw_line, saw_func;
d929 1
a929 1
  *pfound = FALSE;
d960 1
a960 1
	  return TRUE;
d977 1
a977 1
	return FALSE;
d991 1
a991 1
	  return TRUE;
d1000 1
a1000 1
	return FALSE;
d1006 1
a1006 1
	return FALSE;
d1014 1
a1014 1
	return FALSE;
d1017 1
a1017 1
	return FALSE;
d1024 1
a1024 1
	  return FALSE;
d1049 1
a1049 1
		  return FALSE;
d1103 1
a1103 1
	return TRUE;
d1110 1
a1110 1
	return FALSE;
d1275 1
a1275 1
	return TRUE;
d1284 2
a1285 2
  saw_line = FALSE;
  saw_func = FALSE;
d1288 1
a1288 1
      bfd_boolean done;
d1291 1
a1291 1
      done = FALSE;
d1327 2
a1328 2
	    done = TRUE;
	  saw_line = TRUE;
d1334 2
a1335 2
	    done = TRUE;
	  saw_func = TRUE;
d1343 1
a1343 1
  *pfound = TRUE;
d1364 1
a1364 1
	    return FALSE;
d1387 1
a1387 1
  return TRUE;
@


1.25.10.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d77 3
a79 3
|	  if (storage_needed == 0)
|	    return;
|	  
d88 3
a90 2
|	  for (i = 0; i < number_of_symbols; i++)
|	    process_symbol (symbol_table[i]);
d111 1
a111 1
|	int main (void)
d117 3
a119 3
|	  abfd = bfd_openw ("foo","a.out-sunos-big");
|	  bfd_set_format (abfd, bfd_object);
|	  new = bfd_make_empty_symbol (abfd);
d121 1
a121 1
|	  new->section = bfd_make_section_old_way (abfd, ".text");
d128 2
a129 3
|	  bfd_set_symtab (abfd, ptrs, 1);
|	  bfd_close (abfd);
|	  return 0;
d195 1
a195 1
.  struct bfd *the_bfd; {* Use bfd_asymbol_bfd(sym) to access this field.  *}
d349 1
a349 1
        bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);
d441 1
a441 1
	void bfd_print_symbol_vandf (bfd *abfd, PTR file, asymbol *symbol);
a453 1

a454 1

d456 4
a459 2
    bfd_fprintf_vma (abfd, file,
		     symbol->value + symbol->section->vma);
d461 3
a463 1
    bfd_fprintf_vma (abfd, file, symbol->value);
d507 1
a507 1
	asymbol * _bfd_generic_make_empty_symbol (bfd *);
d637 1
a637 1
	int bfd_decode_symclass (asymbol *symbol);
d729 1
a729 1
	void bfd_symbol_info (asymbol *symbol, symbol_info *ret);
d752 1
a752 1
	bfd_boolean bfd_copy_private_symbol_data (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
d819 1
d1248 3
a1253 2
      /* Cache non-existant or invalid.  Do binary search on
         indextable.  */
d1308 3
a1310 5
	  /* A line number.  If the function was specified, then the value
	     is relative to the start of the function.  Otherwise, the
	     value is an absolute address.  */
	  val = ((indexentry->function_name ? indexentry->val : 0)
		 + bfd_get_32 (abfd, stab + VALOFF));
d1379 1
@


1.25.10.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a621 3
  if ((section->flags & SEC_HAS_CONTENTS) &&
      (section->flags & SEC_READONLY))
    return 'n';
d1005 1
a1005 1
      /* If this is a relocatable object file, we have to relocate
@


1.25.10.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d80 1
a80 1
|	  symbol_table = xmalloc (storage_needed);
d125 1
a125 1
|	  ptrs[1] = 0;
d301 1
a301 1
.      void *p;
d317 4
d357 3
a359 1
bfd_is_local_label (bfd *abfd, asymbol *sym)
d385 1
a385 1
.  BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
d401 2
a402 1
.  BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))
d411 1
a411 2
	bfd_boolean bfd_set_symtab
	  (bfd *abfd, asymbol **location, unsigned int count);
d420 4
a423 1
bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int symcount)
d425 1
a425 1
  if (abfd->format != bfd_object || bfd_read_p (abfd))
d441 1
a441 1
	void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);
d448 4
a451 1
bfd_print_symbol_vandf (bfd *abfd, void *arg, asymbol *symbol)
d453 1
a453 1
  FILE *file = arg;
d457 3
a459 2
  if (symbol->section != NULL)
    bfd_fprintf_vma (abfd, file, symbol->value + symbol->section->vma);
d496 1
a496 1
.  BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
d505 1
a505 1
	asymbol *_bfd_generic_make_empty_symbol (bfd *);
d515 2
a516 1
_bfd_generic_make_empty_symbol (bfd *abfd)
d519 1
a519 1
  asymbol *new = bfd_zalloc (abfd, amt);
d535 1
a535 1
.  BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
d579 2
a580 1
coff_section_type (const char *s)
d599 2
a600 1
decode_section_type (const struct sec *section)
d622 2
a623 1
  if ((section->flags & SEC_HAS_CONTENTS) && (section->flags & SEC_READONLY))
d641 2
a642 1
bfd_decode_symclass (asymbol *symbol)
d714 2
a715 1
bfd_is_undefined_symclass (int symclass)
d734 3
a736 1
bfd_symbol_info (asymbol *symbol, symbol_info *ret)
d753 1
a753 2
	bfd_boolean bfd_copy_private_symbol_data
	  (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
d765 2
a766 2
.  BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
.            (ibfd, isymbol, obfd, osymbol))
d775 5
a779 4
_bfd_generic_read_minisymbols (bfd *abfd,
			       bfd_boolean dynamic,
			       void **minisymsp,
			       unsigned int *sizep)
d794 1
a794 1
  syms = bfd_malloc (storage);
d805 1
a805 1
  *minisymsp = syms;
d821 5
a825 4
_bfd_generic_minisymbol_to_symbol (bfd *abfd ATTRIBUTE_UNUSED,
				   bfd_boolean dynamic ATTRIBUTE_UNUSED,
				   const void *minisym,
				   asymbol *sym ATTRIBUTE_UNUSED)
d860 3
a862 1
cmpindexentry (const void *a, const void *b)
d864 2
a865 2
  const struct indexentry *contestantA = a;
  const struct indexentry *contestantB = b;
d906 11
a916 9
_bfd_stab_section_find_nearest_line (bfd *abfd,
				     asymbol **symbols,
				     asection *section,
				     bfd_vma offset,
				     bfd_boolean *pfound,
				     const char **pfilename,
				     const char **pfnname,
				     unsigned int *pline,
				     void **pinfo)
d954 1
a954 1
  info = *pinfo;
d975 1
a975 1
      info = bfd_zalloc (abfd, amt);
d990 1
a990 1
	  *pinfo = info;
d997 2
a998 2
      info->stabs = bfd_alloc (abfd, stabsize);
      info->strs = bfd_alloc (abfd, strsize);
d1015 1
a1015 1
      reloc_vector = bfd_malloc (reloc_size);
d1108 1
a1108 1
      info->indextable = bfd_alloc (abfd, amt);
d1229 1
a1229 1
      *pinfo = info;
d1363 1
a1363 1
	  info->filename = bfd_malloc (dirlen + len);
@


1.25.10.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d184 1
a184 1
.typedef struct bfd_symbol
d296 1
a296 1
.  struct bfd_section *section;
d584 1
a584 1
decode_section_type (const struct bfd_section *section)
@


1.25.10.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d136 1
a136 1
	Many formats cannot represent arbitrary symbol information; for
d138 1
a138 1
	arbitrary number of sections. A symbol pointing to a section
d225 1
a225 1
.  {* The symbol is a debugging record. The value has an arbitrary
d1225 1
a1225 1
      /* Cache non-existent or invalid.  Do binary search on
@


1.24
log
@This makes gprof work with non-standard text sections.
	* syms.c (decode_section_type): New.
	(bfd_decode_symclass): Call decode_section_type.
@
text
@d809 1
@


1.24.2.1
log
@Merge from mainline.
@
text
@d716 1
a716 1
  return (boolean) (symclass == 'U' || symclass == 'w' || symclass == 'v');
d1072 1
a1072 1
	  if (stab[TYPEOFF] == (bfd_byte) N_SO)
d1086 1
a1086 1
		  && *(stab + STABSIZE + TYPEOFF) == (bfd_byte) N_SO)
d1091 1
a1091 1
	  else if (stab[TYPEOFF] == (bfd_byte) N_FUN)
d1160 1
a1160 1
		      || *(stab + STABSIZE + TYPEOFF) != (bfd_byte) N_SO)
@


1.23
log
@	* elf64-ppc.c (ppc_add_stub): Replace strcpy/strncpy with memcpy.
	* elf32-hppa.c (hppa_add_stub): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_add_default_symbol): Fix comment typo.
	(elf_add_default_symbol): Replace strcpy and strncpy with memcpy.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_assign_sym_version): Likewise.
	* hash.c (bfd_hash_lookup): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
	* section.c (bfd_get_unique_section_name): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* elf.c (_bfd_elf_make_section_from_phdr): Likewise.
	(assign_section_numbers): Likewise.
	(_bfd_elfcore_make_pseudosection): Likewise.
	(elfcore_grok_lwpstatus): Likewise.
	(elfcore_grok_win32pstatus): Likewise.
	(elfcore_write_note): Constify input params.  Use PTR instead of
	void *.  Include terminating NUL in namesz.  Correct padding.
	Support NULL "name" param.  Use memcpy instead of strcpy.
	(elfcore_write_prpsinfo): Constify input params.
	(elfcore_write_prstatus): Likewise.  Use PTR instead of void *.
	(elfcore_write_lwpstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	* elf-bfd.h (elfcore_write_note): Update declaration.
	(elfcore_write_prpsinfo): Likewise.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	(elfcore_write_lwpstatus): Likewise.
@
text
@d318 1
d593 35
d678 5
a682 1
    c = coff_section_type (symbol->section->name);
@


1.22
log
@Add DLX target
@
text
@d1316 2
d1320 2
a1321 2
	  info->filename = (char *) bfd_malloc ((bfd_size_type) dirlen
						+ strlen (file_name) + 1);
d1324 2
a1325 2
	  strcpy (info->filename, directory_name);
	  strcpy (info->filename + dirlen, file_name);
@


1.22.2.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a317 1
static char decode_section_type PARAMS ((const struct sec *));
a591 35
/* Return the single-character symbol type corresponding to section
   SECTION, or '?' for an unknown section.  This uses section flags to
   identify sections.

   FIXME These types are unhandled: c, i, e, p.  If we handled these also,
   we could perhaps obsolete coff_section_type.  */

static char
decode_section_type (section)
     const struct sec *section;
{
  if (section->flags & SEC_CODE)
    return 't';
  if (section->flags & SEC_DATA)
    {
      if (section->flags & SEC_READONLY)
	return 'r';
      else if (section->flags & SEC_SMALL_DATA)
	return 'g';
      else
	return 'd';
    }
  if ((section->flags & SEC_HAS_CONTENTS) == 0)
    {
      if (section->flags & SEC_SMALL_DATA)
	return 's';
      else
	return 'b';
    }
  if (section->flags & SEC_DEBUGGING)
    return 'N';

  return '?';
}

d642 1
a642 5
    {
      c = coff_section_type (symbol->section->name);
      if (c == '?')
	c = decode_section_type (symbol->section);
    }
a1315 2
	  size_t len;

d1318 2
a1319 2
	  len = strlen (file_name) + 1;
	  info->filename = (char *) bfd_malloc ((bfd_size_type) dirlen + len);
d1322 2
a1323 2
	  memcpy (info->filename, directory_name, dirlen);
	  memcpy (info->filename + dirlen, file_name, len);
@


1.22.2.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a808 1
  bfd_set_error (bfd_error_no_symbols);
@


1.22.2.3
log
@merge from mainline
@
text
@d716 1
a716 1
  return (boolean) (symclass == 'U' || symclass == 'w' || symclass == 'v');
d1073 1
a1073 1
	  if (stab[TYPEOFF] == (bfd_byte) N_SO)
d1087 1
a1087 1
		  && *(stab + STABSIZE + TYPEOFF) == (bfd_byte) N_SO)
d1092 1
a1092 1
	  else if (stab[TYPEOFF] == (bfd_byte) N_FUN)
d1161 1
a1161 1
		      || *(stab + STABSIZE + TYPEOFF) != (bfd_byte) N_SO)
@


1.21
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d886 1
d1243 2
d1247 1
a1247 1
      boolean done, saw_line, saw_func;
a1249 2
      saw_line = false;
      saw_func = false;
@


1.20
log
@	* syms.c (_bfd_stab_section_find_nearest_line): Don't bomb on NULL
	file_name.
@
text
@d288 3
@


1.20.4.1
log
@merge from trunk
@
text
@a287 3
.  {* This symbol is thread local.  Used in ELF.  *}
.#define BSF_THREAD_LOCAL  0x40000
.
a882 1
  boolean saw_line, saw_func;
a1238 2
  saw_line = false;
  saw_func = false;
d1241 1
a1241 1
      boolean done;
d1244 2
@


1.19
log
@2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>

        * dwarf2.c (struct funcinfo): Move up.
        (lookup_address_in_function_table): New argument function_ptr.
        Set it.
        (lookup_address_in_line_table): New argument function.  If function
        is non-NULL, use it to handle ``addr'' before the first line note of
        the function.
        (comp_unit_find_nearest_line): Update and swap calls to
        lookup_address_in_function_table and lookup_address_in_line_table.
        * syms.c (_bfd_stab_section_find_nearest_line): Use the first
        N_SLINE encountered if we see an N_FUN before any N_SLINE.
@
text
@d1300 2
a1301 1
  if (IS_ABSOLUTE_PATH(file_name) || directory_name == NULL)
@


1.18
log
@2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>

        * syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.
@
text
@d1241 1
a1241 1
      boolean done;
d1244 2
d1266 5
a1270 1
	  if (val <= offset)
d1283 1
d1288 3
a1290 1
	  done = true;
@


1.17
log
@Tidy up formatting in bfd-in2.h
@
text
@a547 1
  {"*DEBUG*", 'N'},
d549 1
a549 1
  {"zerovars", 'b'},		/* MRI .bss */
d551 8
a558 1
  {"vars", 'd'},		/* MRI .data */
d565 2
a566 6
  {"code", 't'},		/* MRI .text */
  {".drectve", 'i'},            /* MSVC's .drective section */
  {".idata", 'i'},              /* MSVC's .idata (import) section */
  {".edata", 'e'},              /* MSVC's .edata (export) section */
  {".pdata", 'p'},              /* MSVC's .pdata (stack unwind) section */
  {".debug", 'N'},              /* MSVC's .debug (non-standard debug syms) */
@


1.17.2.1
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d548 1
d550 1
a550 1
  {"code", 't'},		/* MRI .text */
d552 1
a552 8
  {"*DEBUG*", 'N'},
  {".debug", 'N'},              /* MSVC's .debug (non-standard debug syms) */
  {".drectve", 'i'},            /* MSVC's .drective section */
  {".edata", 'e'},              /* MSVC's .edata (export) section */
  {".fini", 't'},		/* ELF fini section */
  {".idata", 'i'},              /* MSVC's .idata (import) section */
  {".init", 't'},		/* ELF init section */
  {".pdata", 'p'},              /* MSVC's .pdata (stack unwind) section */
d559 6
a564 2
  {"vars", 'd'},		/* MRI .data */
  {"zerovars", 'b'},		/* MRI .bss */
d1239 1
a1239 1
      boolean done, saw_line, saw_func;
a1241 2
      saw_line = false;
      saw_func = false;
d1262 1
a1262 5
	  /* If this line starts before our desired offset, or if it's
	     the first line we've been able to find, use it.  The
	     !saw_line check works around a bug in GCC 2.95.3, which emits
	     the first N_SLINE late.  */
	  if (!saw_line || val <= offset)
a1274 1
	  saw_line = true;
d1279 1
a1279 3
	  if (saw_func || saw_line)
	    done = true;
	  saw_func = true;
@


1.17.2.2
log
@Merge from mainline
@
text
@d1300 1
a1300 2
  if (file_name == NULL || IS_ABSOLUTE_PATH (file_name)
      || directory_name == NULL)
@


1.16
log
@	* syms.c (_bfd_generic_make_empty_symbol): New function.
	* libbfd-in.h (_bfd_nosymbols_make_empty_symbol): Define as
	_bfd_generic_make_empty_symbol.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* hppabsd-core.c (hppabsd_core_make_empty_symbol): Delete function.
	(hppabsd_core_get_symtab_upper_bound): Don't define.
	(hppabsd_core_get_symtab): Likewise.
	(hppabsd_core_print_symbol): Likewise.
	(hppabsd_core_get_symbol_info): Likewise.
	(hppabsd_core_bfd_is_local_label_name): Likewise.
	(hppabsd_core_get_lineno): Likewise.
	(hppabsd_core_find_nearest_line): Likewise.
	(hppabsd_core_bfd_make_debug_symbol): Likewise.
	(hppabsd_core_read_minisymbols): Likewise.
	(hppabsd_core_minisymbol_to_symbol): Likewise.
	(hppabsd_core_vec): Use BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols).
	Formatting fixes.
	* hpux-core.c: Similarly.
	* irix-core.c: Similarly.
	* osf-core.c: Similarly.
	* sco5-core.c: Similarly.
	* binary.c (binary_make_empty_symbol): Remove function, define as
	_bfd_generic_make_empty_symbol.
	* ihex.c (ihex_make_empty_symbol): Likewise.
	* mmo.c (mmo_make_empty_symbol): Likewise.
	* ppcboot.c (ppcboot_make_empty_symbol): Likewise.
	* srec.c (srec_make_empty_symbol): Likewise.
	* versados.c (versados_make_empty_symbol): Likewise.
	* vms.c (_bfd_vms_make_empty_symbol): Remove.
	(vms_make_empty_symbol): Define as _bfd_generic_make_empty_symbol.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Call bfd_make_empty_symbol
	rather than _bfd_vms_make_empty_symbol.
	* vms-misc.c (new_symbol): Likewise.
@
text
@d3 1
a3 1
   2000, 2001
d186 10
a195 9
.	{* A pointer to the BFD which owns the symbol. This information
.	   is necessary so that a back end can work out what additional
.   	   information (invisible to the application writer) is carried
.	   with the symbol.
.
.	   This field is *almost* redundant, since you can use section->owner
.	   instead, except that some symbols point to the global sections
.	   bfd_{abs,com,und}_section.  This could be fixed by making
.	   these globals be per-bfd (or per-target-flavor).  FIXME. *}
d197 2
a198 4
.  struct _bfd *the_bfd; {* Use bfd_asymbol_bfd(sym) to access this field. *}
.
.	{* The text of the symbol. The name is left alone, and not copied; the
.	   application may not alter it. *}
d201 3
a203 3
.	{* The value of the symbol.  This really should be a union of a
.          numeric value with a pointer, since some flags indicate that
.          a pointer to another symbol is stored here.  *}
d206 1
a206 2
.	{* Attributes of a symbol: *}
.
d209 2
a210 2
.	{* The symbol has local scope; <<static>> in <<C>>. The value
. 	   is the offset into the section of the data. *}
d213 2
a214 2
.	{* The symbol has global scope; initialized data in <<C>>. The
.	   value is the offset into the section of the data. *}
d217 7
a223 7
.	{* The symbol has global scope and is exported. The value is
.	   the offset into the section of the data. *}
.#define BSF_EXPORT	BSF_GLOBAL {* no real difference *}
.
.	{* A normal C symbol would be one of:
.	   <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
.	   <<BSF_GLOBAL>> *}
d225 2
a226 2
.	{* The symbol is a debugging record. The value has an arbitary
.	   meaning, unless BSF_DEBUGGING_RELOC is also set.  *}
d229 2
a230 2
.	{* The symbol denotes a function entry point.  Used in ELF,
.	   perhaps others someday.  *}
d233 1
a233 1
.	{* Used by the linker. *}
d237 2
a238 2
.	{* A weak global symbol, overridable without warnings by
.	   a regular global symbol of the same name.  *}
d241 2
a242 2
.       {* This symbol was created to point to a section, e.g. ELF's
.	   STT_SECTION symbols.  *}
d245 2
a246 2
.	{* The symbol used to be a common symbol, but now it is
.	   allocated. *}
d249 1
a249 1
.	{* The default value for common data. *}
d252 5
a256 6
.	{* In some files the type of a symbol sometimes alters its
.	   location in an output file - ie in coff a <<ISFCN>> symbol
.	   which is also <<C_EXT>> symbol appears where it was
.	   declared and not at the end of a section.  This bit is set
.  	   by the target BFD part to convey this information. *}
.
d259 1
a259 1
.	{* Signal that the symbol is the label of constructor section. *}
d262 4
a265 4
.	{* Signal that the symbol is a warning symbol.  The name is a
.	   warning.  The name of the next symbol is the one to warn about;
.	   if a reference is made to a symbol with the same name as the next
.	   symbol, a warning is issued by the linker. *}
d268 2
a269 2
.	{* Signal that the symbol is indirect.  This symbol is an indirect
.	   pointer to the symbol with the same name as the next symbol. *}
d272 2
a273 2
.	{* BSF_FILE marks symbols that contain a file name.  This is used
.	   for ELF STT_FILE symbols.  *}
d276 1
a276 1
.	{* Symbol is from dynamic linking information.  *}
d279 2
a280 2
.       {* The symbol denotes a data object.  Used in ELF, and perhaps
.          others someday.  *}
d283 3
a285 3
.       {* This symbol is a debugging symbol.  The value is the offset
.          into the section of the data.  BSF_DEBUGGING should be set
.          as well.  *}
d290 3
a292 3
.	{* A pointer to the section to which this symbol is
.	   relative.  This will always be non NULL, there are special
.          sections for undefined and absolute symbols.  *}
d295 1
a295 1
.	{* Back end special data.  *}
d300 4
a303 1
.    } udata;
a304 1
.} asymbol;
d337 1
a337 1

d382 1
d399 1
a399 1

d495 1
d534 1
d721 1
a721 1

@


1.15
log
@        * syms.c (_bfd_generic_read_minisymbols): Early return for
        no symbols.  Patch from FreeBSD folk; exact origin unknown.
@
text
@d499 25
@


1.14
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d718 2
@


1.13
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d311 1
a559 7
#ifndef islower
#define islower(c) ((c) >= 'a' && (c) <= 'z')
#endif
#ifndef toupper
#define toupper(c) (islower(c) ? ((c) & ~0x20) : (c))
#endif

d614 1
a614 1
    c = toupper (c);
@


1.12
log
@2001-08-23  H.J. Lu  <hjl@@gnu.org>

	* syms.c (bfd_print_symbol_vandf): Add abfd to arg.
	* bfd-in2.h (bfd_print_symbol_vandf): Regenerated.

	* aoutx.h (NAME(aout,print_symbol)): Pass abfd to
	bfd_print_symbol_vandf.
	* coffgen.c (coff_print_symbol): Likewise.
	* elf.c (bfd_elf_print_symbol): Likewise.
	* ieee.c (ieee_print_symbol): Likewise.
	* nlmcode.h (nlm_print_symbol): Likewise.
	* oasys.c (oasys_print_symbol): Likewise.
	* pdp11.c (NAME(aout,print_symbol)): Likewise.
	* som.c (som_print_symbol): Likewise.
	* srec.c (srec_print_symbol): Likewise.
	* tekhex.c (tekhex_print_symbol): Likewise.
	* versados.c (versados_print_symbol): Likewise.
	* vms.c (vms_print_symbol): Likewise.

	* elf.c (_bfd_elf_print_private_bfd_data): Replace fprintf_vma
	with bfd_fprintf_vma.
	(bfd_elf_print_symbol): Likewise.
	* syms.c (bfd_print_symbol_vandf): Likewise.
@
text
@d200 1
a200 1
.  CONST char *name;
d511 1
a511 1
  CONST char *section;
d518 1
a518 1
static CONST struct section_to_type stt[] =
d550 1
a550 1
  CONST struct section_to_type *t;
d725 1
a725 1
  syms = (asymbol **) bfd_malloc ((size_t) storage);
d855 2
a856 1
  char *directory_name, *file_name;
a901 2
      char *file_name;
      char *directory_name;
d903 1
d905 1
a905 1
      info = (struct stab_find_info *) bfd_zalloc (abfd, sizeof *info);
d932 4
a935 4
      if (! bfd_get_section_contents (abfd, info->stabsec, info->stabs, 0,
				      stabsize)
	  || ! bfd_get_section_contents (abfd, info->strsec, info->strs, 0,
					 strsize))
d945 1
a945 1
      reloc_vector = (arelent **) bfd_malloc (reloc_size);
d986 1
a986 1
	      bfd_put_32 (abfd, val, info->stabs + r->address);
d1036 3
a1038 4
      info->indextable = ((struct indexentry *)
			  bfd_alloc (abfd,
				     (sizeof (struct indexentry)
				      * info->indextablesize)));
d1156 2
a1157 1
      qsort (info->indextable, i, sizeof (struct indexentry), cmpindexentry);
d1279 2
a1280 3
	  info->filename = (char *) bfd_malloc (dirlen +
						strlen (file_name)
						+ 1);
@


1.11
log
@	* coff-rs6000.c: Add missing prototypes.
	(xcoff_ppc_relocate_section, xcoff_is_lineno_count_overflow,
	xcoff_is_reloc_count_overflow, xcoff_loader_symbol_offset,
	xcoff_loader_reloc_offset): Make static.
	* dwarf1.c: Add missing prototypes.
	* dwarf2.c: Add missing prototypes.
	(struct abbrev_info): Move definition.
	(struct attr_abbrev, ABBREV_HASH_SIZE, ATTR_ALLOC_CHUNK): Likewise.
	* elf.c: Add missing prototypes.
	* elf32-gen.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-ppc.c: Likewise.
	(ppc_elf_sort_rela): Use PTR instead of "void *".
	* elflink.h: Add missing prototypes.  Formatting fixes.
	* merge.c: Add missing prototypes.
	(last4_eq): Use PTR instead of "void *".
	(last_eq): Likewise.
	* syms.c: Add missing prototypes.
@
text
@d436 1
a436 1
	void bfd_print_symbol_vandf(PTR file, asymbol *symbol);
d443 2
a444 1
bfd_print_symbol_vandf (arg, symbol)
d452 2
a453 1
      fprintf_vma (file, symbol->value + symbol->section->vma);
d457 1
a457 1
      fprintf_vma (file, symbol->value);
@


1.10
log
@Fix ia64-linux binutils readelf -s testsuite failure.
	* syms.c (bfd_is_local_label): Return false if BSF_SECTION_SYM.
@
text
@d3 1
a3 1
   2000
d315 1
@


1.9
log
@Update copyright notices
@
text
@d356 4
a359 1
  if ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0)
@


1.8
log
@2000-12-19  Kazu Hirata  <kazu@@hxi.com>

	* sco5-core.c: Fix formatting.
	* section.c: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* sparcnetbsd.c: Likewise.
	* srec.c: Likewise.
	* stabs.c: Likewise.
	* stab-syms.c: Likewise.
	* sunos.c: Likewise.
	* syms.c: Likewise.
	* sysdep.h: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000
@


1.7
log
@Ryan Bradetich's warning fixes.
@
text
@a93 1

a164 2


a389 1

a395 1

a471 1

d534 1
a534 1
   section S, or '?' for an unknown COFF section.  
d545 1
a545 1
  for (t = &stt[0]; t->section; t++) 
d628 1
a628 1
	bfd_is_undefined_symclass 
d665 1
a665 1
  
d670 1
a670 1
  
d1002 1
a1002 1
	      /* if we did not see a function def, leave space for one. */
d1024 1
a1024 1
      
d1060 2
a1061 2
	         there could be 2 N_SO following it with the new filename 
	         and directory. */
d1073 1
a1073 1
	      
@


1.6
log
@* syms.c (_bfd_stab_section_find_neares_line): Use IS_ABSOLUTE_PATH.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d791 2
a792 2
     const PTR *a;
     const PTR *b;
@


1.5
log
@Apply patch from Thomas de Lellis to allow nm to distinguish between weak
function symbols and weak data symbols.
@
text
@d1265 1
a1265 1
  if (file_name[0] == '/' || directory_name == NULL)
@


1.4
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* syms.c (BSF_DEBUGGING_RELOC): Define.
	* coffgen.c (fixup_symbol_value): Relocate a symbol which has
	BSF_DEBUGGING_RELOC set.
	* bfd-in2.h: Rebuild.
@
text
@d587 8
a594 1
	return 'w';
d601 8
a608 1
    return 'W';
d634 20
d671 4
a674 1
  if (ret->type != 'U' && ret->type != 'w')
d676 1
a676 2
  else
    ret->value = 0;
@


1.3
log
@1999-09-06  Donn Terry  <donn@@interix.com>

	* syms.c (stt): Add some PE/PEI section names.
	(bfd_decode_symclass): Return 'w', not 'U', for a weak undefined
	symbol.
	(bfd_symbol_info): Check for 'w'.
@
text
@d230 1
a230 1
.	   meaning. *}
d287 5
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@d526 5
d580 6
a585 1
    return 'U';
d632 1
a632 1
  if (ret->type != 'U')
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d701 2
a702 2
     bfd *abfd;
     boolean dynamic;
d704 1
a704 1
     asymbol *sym;
d799 2
a800 1
  bfd_byte *stab, *str, *last_stab;
d1036 18
a1053 17
	      else {
		last_stab = stab;
		if (stab + STABSIZE >= info->stabs + stabsize
		    || *(stab + STABSIZE + TYPEOFF) != N_SO)
		  {
		    directory_name = NULL;
		  }
		else
		  {
		    /* Two consecutive N_SOs are a directory and a file
		       name.  */
		    stab += STABSIZE;
		    directory_name = file_name;
		    file_name = ((char *) str
				 + bfd_get_32 (abfd, stab + STRDXOFF));
		  }
	      }
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

