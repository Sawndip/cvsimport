head	1.17;
access;
symbols
	sid-snapshot-20180601:1.17
	sid-snapshot-20180501:1.17
	sid-snapshot-20180401:1.17
	sid-snapshot-20180301:1.17
	sid-snapshot-20180201:1.17
	sid-snapshot-20180101:1.17
	sid-snapshot-20171201:1.17
	sid-snapshot-20171101:1.17
	sid-snapshot-20171001:1.17
	sid-snapshot-20170901:1.17
	sid-snapshot-20170801:1.17
	sid-snapshot-20170701:1.17
	sid-snapshot-20170601:1.17
	sid-snapshot-20170501:1.17
	sid-snapshot-20170401:1.17
	sid-snapshot-20170301:1.17
	sid-snapshot-20170201:1.17
	sid-snapshot-20170101:1.17
	sid-snapshot-20161201:1.17
	sid-snapshot-20161101:1.17
	sid-snapshot-20160901:1.17
	sid-snapshot-20160801:1.17
	sid-snapshot-20160701:1.17
	sid-snapshot-20160601:1.17
	sid-snapshot-20160501:1.17
	sid-snapshot-20160401:1.17
	sid-snapshot-20160301:1.17
	sid-snapshot-20160201:1.17
	sid-snapshot-20160101:1.17
	sid-snapshot-20151201:1.17
	sid-snapshot-20151101:1.17
	sid-snapshot-20151001:1.17
	sid-snapshot-20150901:1.17
	sid-snapshot-20150801:1.17
	sid-snapshot-20150701:1.17
	sid-snapshot-20150601:1.17
	sid-snapshot-20150501:1.17
	sid-snapshot-20150401:1.17
	sid-snapshot-20150301:1.17
	sid-snapshot-20150201:1.17
	sid-snapshot-20150101:1.17
	sid-snapshot-20141201:1.17
	sid-snapshot-20141101:1.17
	sid-snapshot-20141001:1.17
	sid-snapshot-20140901:1.17
	sid-snapshot-20140801:1.17
	sid-snapshot-20140701:1.17
	sid-snapshot-20140601:1.17
	sid-snapshot-20140501:1.17
	sid-snapshot-20140401:1.17
	sid-snapshot-20140301:1.17
	sid-snapshot-20140201:1.17
	sid-snapshot-20140101:1.17
	sid-snapshot-20131201:1.17
	sid-snapshot-20131101:1.17
	sid-snapshot-20131001:1.17
	binutils-2_24-branch:1.17.0.8
	binutils-2_24-branchpoint:1.17
	binutils-2_21_1:1.15
	sid-snapshot-20130901:1.17
	gdb_7_6_1-2013-08-30-release:1.17
	sid-snapshot-20130801:1.17
	sid-snapshot-20130701:1.17
	sid-snapshot-20130601:1.17
	sid-snapshot-20130501:1.17
	gdb_7_6-2013-04-26-release:1.17
	sid-snapshot-20130401:1.17
	binutils-2_23_2:1.17
	gdb_7_6-branch:1.17.0.6
	gdb_7_6-2013-03-12-branchpoint:1.17
	sid-snapshot-20130301:1.17
	sid-snapshot-20130201:1.17
	sid-snapshot-20130101:1.17
	sid-snapshot-20121201:1.17
	gdb_7_5_1-2012-11-29-release:1.17
	binutils-2_23_1:1.17
	sid-snapshot-20121101:1.17
	binutils-2_23:1.17
	sid-snapshot-20121001:1.17
	sid-snapshot-20120901:1.17
	gdb_7_5-2012-08-17-release:1.17
	sid-snapshot-20120801:1.17
	binutils-2_23-branch:1.17.0.4
	binutils-2_23-branchpoint:1.17
	gdb_7_5-branch:1.17.0.2
	gdb_7_5-2012-07-18-branchpoint:1.17
	sid-snapshot-20120701:1.16
	sid-snapshot-20120601:1.16
	sid-snapshot-20120501:1.16
	binutils-2_22_branch:1.16.0.6
	gdb_7_4_1-2012-04-26-release:1.16
	sid-snapshot-20120401:1.16
	sid-snapshot-20120301:1.16
	sid-snapshot-20120201:1.16
	gdb_7_4-2012-01-24-release:1.16
	sid-snapshot-20120101:1.16
	gdb_7_4-branch:1.16.0.4
	gdb_7_4-2011-12-13-branchpoint:1.16
	sid-snapshot-20111201:1.16
	binutils-2_22:1.16
	sid-snapshot-20111101:1.16
	sid-snapshot-20111001:1.16
	binutils-2_22-branch:1.16.0.2
	binutils-2_22-branchpoint:1.16
	gdb_7_3_1-2011-09-04-release:1.15
	sid-snapshot-20110901:1.16
	sid-snapshot-20110801:1.16
	gdb_7_3-2011-07-26-release:1.15
	sid-snapshot-20110701:1.16
	sid-snapshot-20110601:1.15
	sid-snapshot-20110501:1.15
	gdb_7_3-branch:1.15.0.12
	gdb_7_3-2011-04-01-branchpoint:1.15
	sid-snapshot-20110401:1.15
	sid-snapshot-20110301:1.15
	sid-snapshot-20110201:1.15
	sid-snapshot-20110101:1.15
	binutils-2_21:1.15
	sid-snapshot-20101201:1.15
	binutils-2_21-branch:1.15.0.10
	binutils-2_21-branchpoint:1.15
	sid-snapshot-20101101:1.15
	sid-snapshot-20101001:1.15
	binutils-2_20_1:1.15
	gdb_7_2-2010-09-02-release:1.15
	sid-snapshot-20100901:1.15
	sid-snapshot-20100801:1.15
	gdb_7_2-branch:1.15.0.8
	gdb_7_2-2010-07-07-branchpoint:1.15
	sid-snapshot-20100701:1.15
	sid-snapshot-20100601:1.15
	sid-snapshot-20100501:1.15
	sid-snapshot-20100401:1.15
	gdb_7_1-2010-03-18-release:1.15
	sid-snapshot-20100301:1.15
	gdb_7_1-branch:1.15.0.6
	gdb_7_1-2010-02-18-branchpoint:1.15
	sid-snapshot-20100201:1.15
	sid-snapshot-20100101:1.15
	gdb_7_0_1-2009-12-22-release:1.15
	sid-snapshot-20091201:1.15
	sid-snapshot-20091101:1.15
	binutils-2_20:1.15
	gdb_7_0-2009-10-06-release:1.15
	sid-snapshot-20091001:1.15
	gdb_7_0-branch:1.15.0.4
	gdb_7_0-2009-09-16-branchpoint:1.15
	arc-sim-20090309:1.13
	binutils-arc-20081103-branch:1.14.0.16
	binutils-arc-20081103-branchpoint:1.14
	binutils-2_20-branch:1.15.0.2
	binutils-2_20-branchpoint:1.15
	sid-snapshot-20090901:1.14
	sid-snapshot-20090801:1.14
	msnyder-checkpoint-072509-branch:1.14.0.14
	msnyder-checkpoint-072509-branchpoint:1.14
	sid-snapshot-20090701:1.14
	dje-cgen-play1-branch:1.14.0.12
	dje-cgen-play1-branchpoint:1.14
	sid-snapshot-20090601:1.14
	sid-snapshot-20090501:1.14
	sid-snapshot-20090401:1.14
	arc-20081103-branch:1.14.0.10
	arc-20081103-branchpoint:1.14
	arc-insight_6_8-branch:1.13.0.14
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.12
	insight_6_8-branchpoint:1.13
	sid-snapshot-20090301:1.14
	binutils-2_19_1:1.14
	sid-snapshot-20090201:1.14
	sid-snapshot-20090101:1.14
	reverse-20081226-branch:1.14.0.8
	reverse-20081226-branchpoint:1.14
	sid-snapshot-20081201:1.14
	multiprocess-20081120-branch:1.14.0.6
	multiprocess-20081120-branchpoint:1.14
	sid-snapshot-20081101:1.14
	binutils-2_19:1.14
	sid-snapshot-20081001:1.14
	reverse-20080930-branch:1.14.0.4
	reverse-20080930-branchpoint:1.14
	binutils-2_19-branch:1.14.0.2
	binutils-2_19-branchpoint:1.14
	sid-snapshot-20080901:1.14
	sid-snapshot-20080801:1.14
	reverse-20080717-branch:1.13.0.10
	reverse-20080717-branchpoint:1.13
	sid-snapshot-20080701:1.13
	msnyder-reverse-20080609-branch:1.13.0.8
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.11.0.8
	drow-reverse-20070409-branchpoint:1.11
	sid-snapshot-20080601:1.13
	sid-snapshot-20080501:1.13
	sid-snapshot-20080403:1.13
	sid-snapshot-20080401:1.13
	gdb_6_8-2008-03-27-release:1.13
	sid-snapshot-20080301:1.13
	gdb_6_8-branch:1.13.0.6
	gdb_6_8-2008-02-26-branchpoint:1.13
	sid-snapshot-20080201:1.13
	sid-snapshot-20080101:1.13
	sid-snapshot-20071201:1.13
	sid-snapshot-20071101:1.13
	gdb_6_7_1-2007-10-29-release:1.13
	gdb_6_7-2007-10-10-release:1.13
	sid-snapshot-20071001:1.13
	gdb_6_7-branch:1.13.0.4
	gdb_6_7-2007-09-07-branchpoint:1.13
	binutils-2_18:1.13
	binutils-2_18-branch:1.13.0.2
	binutils-2_18-branchpoint:1.13
	insight_6_6-20070208-release:1.11
	binutils-csl-coldfire-4_1-32:1.10
	binutils-csl-sourcerygxx-4_1-32:1.10
	gdb_6_6-2006-12-18-release:1.11
	binutils-csl-innovasic-fido-3_4_4-33:1.10
	binutils-csl-sourcerygxx-3_4_4-32:1.8
	binutils-csl-coldfire-4_1-30:1.10
	binutils-csl-sourcerygxx-4_1-30:1.10
	binutils-csl-coldfire-4_1-28:1.10
	binutils-csl-sourcerygxx-4_1-29:1.10
	binutils-csl-sourcerygxx-4_1-28:1.10
	gdb_6_6-branch:1.11.0.6
	gdb_6_6-2006-11-15-branchpoint:1.11
	binutils-csl-arm-2006q3-27:1.10
	binutils-csl-sourcerygxx-4_1-27:1.10
	binutils-csl-arm-2006q3-26:1.10
	binutils-csl-sourcerygxx-4_1-26:1.10
	binutils-csl-sourcerygxx-4_1-25:1.10
	binutils-csl-sourcerygxx-4_1-24:1.10
	binutils-csl-sourcerygxx-4_1-23:1.10
	insight_6_5-20061003-release:1.11
	gdb-csl-symbian-6_4_50_20060226-12:1.10
	binutils-csl-sourcerygxx-4_1-21:1.10
	binutils-csl-arm-2006q3-21:1.10
	binutils-csl-sourcerygxx-4_1-22:1.10
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.10
	binutils-csl-sourcerygxx-4_1-20:1.10
	binutils-csl-arm-2006q3-19:1.10
	binutils-csl-sourcerygxx-4_1-19:1.10
	binutils-csl-sourcerygxx-4_1-18:1.10
	binutils-csl-renesas-4_1-9:1.10
	gdb-csl-sourcerygxx-3_4_4-25:1.10
	binutils-csl-sourcerygxx-3_4_4-25:1.8
	nickrob-async-20060828-mergepoint:1.11
	gdb-csl-symbian-6_4_50_20060226-11:1.10
	binutils-csl-renesas-4_1-8:1.10
	binutils-csl-renesas-4_1-7:1.10
	binutils-csl-renesas-4_1-6:1.10
	gdb-csl-sourcerygxx-4_1-17:1.10
	binutils-csl-sourcerygxx-4_1-17:1.10
	gdb-csl-20060226-branch-local-2:1.10
	gdb-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-15:1.10
	gdb-csl-sourcerygxx-4_1-13:1.10
	binutils-csl-sourcerygxx-4_1-13:1.10
	binutils-2_17:1.10
	gdb-csl-sourcerygxx-4_1-12:1.10
	binutils-csl-sourcerygxx-4_1-12:1.10
	gdb-csl-sourcerygxx-3_4_4-21:1.10
	binutils-csl-sourcerygxx-3_4_4-21:1.10
	gdb_6_5-20060621-release:1.11
	binutils-csl-wrs-linux-3_4_4-24:1.8
	binutils-csl-wrs-linux-3_4_4-23:1.8
	gdb-csl-sourcerygxx-4_1-9:1.10
	binutils-csl-sourcerygxx-4_1-9:1.10
	gdb-csl-sourcerygxx-4_1-8:1.10
	binutils-csl-sourcerygxx-4_1-8:1.10
	gdb-csl-sourcerygxx-4_1-7:1.10
	binutils-csl-sourcerygxx-4_1-7:1.10
	gdb-csl-arm-2006q1-6:1.10
	binutils-csl-arm-2006q1-6:1.10
	gdb-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-wrs-linux-3_4_4-22:1.8
	gdb-csl-symbian-6_4_50_20060226-10:1.10
	gdb-csl-symbian-6_4_50_20060226-9:1.10
	gdb-csl-symbian-6_4_50_20060226-8:1.10
	gdb-csl-coldfire-4_1-11:1.10
	binutils-csl-coldfire-4_1-11:1.10
	gdb-csl-sourcerygxx-3_4_4-19:1.10
	binutils-csl-sourcerygxx-3_4_4-19:1.10
	gdb-csl-coldfire-4_1-10:1.10
	gdb_6_5-branch:1.11.0.4
	gdb_6_5-2006-05-14-branchpoint:1.11
	binutils-csl-coldfire-4_1-10:1.10
	gdb-csl-sourcerygxx-4_1-5:1.10
	binutils-csl-sourcerygxx-4_1-5:1.10
	nickrob-async-20060513-branch:1.11.0.2
	nickrob-async-20060513-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-4:1.10
	binutils-csl-sourcerygxx-4_1-4:1.10
	msnyder-reverse-20060502-branch:1.10.0.26
	msnyder-reverse-20060502-branchpoint:1.10
	binutils-csl-wrs-linux-3_4_4-21:1.8
	gdb-csl-morpho-4_1-4:1.10
	binutils-csl-morpho-4_1-4:1.10
	gdb-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-wrs-linux-3_4_4-20:1.8
	readline_5_1-import-branch:1.10.0.24
	readline_5_1-import-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.10
	binutils-2_17-branch:1.10.0.22
	binutils-2_17-branchpoint:1.10
	gdb-csl-symbian-20060226-branch:1.10.0.20
	gdb-csl-symbian-20060226-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.10
	msnyder-reverse-20060331-branch:1.10.0.18
	msnyder-reverse-20060331-branchpoint:1.10
	binutils-csl-2_17-branch:1.10.0.16
	binutils-csl-2_17-branchpoint:1.10
	gdb-csl-available-20060303-branch:1.10.0.14
	gdb-csl-available-20060303-branchpoint:1.10
	gdb-csl-20060226-branch:1.10.0.12
	gdb-csl-20060226-branchpoint:1.10
	gdb_6_4-20051202-release:1.10
	msnyder-fork-checkpoint-branch:1.10.0.10
	msnyder-fork-checkpoint-branchpoint:1.10
	gdb-csl-gxxpro-6_3-branch:1.10.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.10
	gdb_6_4-branch:1.10.0.6
	gdb_6_4-2005-11-01-branchpoint:1.10
	gdb-csl-arm-20051020-branch:1.10.0.4
	gdb-csl-arm-20051020-branchpoint:1.10
	binutils-csl-gxxpro-3_4-branch:1.8.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.8
	binutils-2_16_1:1.8
	msnyder-tracepoint-checkpoint-branch:1.10.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb-csl-arm-20050325-2005-q1b:1.8
	binutils-csl-arm-2005q1b:1.8
	binutils-2_16:1.8
	gdb-csl-arm-20050325-2005-q1a:1.8
	binutils-csl-arm-2005q1a:1.8
	csl-arm-20050325-branch:1.8.0.6
	csl-arm-20050325-branchpoint:1.8
	binutils-csl-arm-2005q1-branch:1.8.0.4
	binutils-csl-arm-2005q1-branchpoint:1.8
	binutils-2_16-branch:1.8.0.2
	binutils-2_16-branchpoint:1.8
	csl-arm-2004-q3d:1.6
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.24
	gdb_6_3-20041019-branchpoint:1.5
	csl-arm-2004-q3:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.26
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.22
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	binutils-2_15:1.5
	binutils-2_15-branchpoint:1.5
	csl-arm-2004-q1a:1.5
	csl-arm-2004-q1:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.20
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.18
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.14
	drow_intercu-20040221-branchpoint:1.5
	binutils-2_15-branch:1.5.0.12
	cagney_bfdfile-20040213-branch:1.5.0.10
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.8
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	csl-arm-2003-q4:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.5.0.6
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.4
	cagney_x86i386-20030821-branch:1.5.0.2
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.4.0.36
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.4
	binutils-2_14:1.4
	cagney_convert-20030606-branch:1.4.0.32
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.30
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.26
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	binutils-2_14-branch:1.4.0.22
	binutils-2_14-branchpoint:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	binutils-2_13_2_1:1.3
	binutils-2_13_2:1.3
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	binutils-2_13_1:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.14
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.12
	carlton_dictionary-20020920-branchpoint:1.3
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.10
	gdb_5_3-branch:1.3.0.8
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.6
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.4
	readline_4_3-import-branchpoint:1.3
	binutils-2_13:1.3
	gdb_5_2_1-2002-07-23-release:1.2
	binutils-2_13-branchpoint:1.3
	binutils-2_13-branch:1.3.0.2
	kseitz_interps-20020528-branch:1.2.0.10
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.8
	cagney_regbuf-20020515-branchpoint:1.2
	binutils-2_12_1:1.2
	jimb-macro-020506-branch:1.2.0.6
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	binutils-2_12:1.2
	gdb_5_2-branch:1.2.0.4
	gdb_5_2-2002-03-03-branchpoint:1.2
	binutils-2_12-branch:1.2.0.2
	binutils-2_12-branchpoint:1.2
	binutils_latest_snapshot:1.17;
locks; strict;
comment	@ * @;


1.17
date	2012.07.13.14.22.43;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2011.06.06.01.26.01;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.18.11.30.22;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.04.05.05.25;	author bje;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.04.15.53.02;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.03.11.40.57;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.31.23.13.16;	author bje;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.21.15.28.16;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.25.06.40.24;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.30.08.39.35;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.25.06.21.47;	author amodra;	state Exp;
branches
	1.3.12.1
	1.3.14.1;
next	1.2;

1.2
date	2002.02.08.12.12.14;	author nickc;	state Exp;
branches
	1.2.10.1;
next	1.1;

1.1
date	2002.01.31.17.32.54;	author nickc;	state Exp;
branches;
next	;

1.3.12.1
date	2002.12.23.19.37.27;	author carlton;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2003.06.27.21.49.06;	author carlton;	state Exp;
branches;
next	;

1.3.14.1
date	2003.12.14.20.26.34;	author drow;	state Exp;
branches;
next	;

1.2.10.1
date	2002.07.22.21.46.39;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.17
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@/* BFD back-end for OpenRISC 1000 COFF binaries.
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2011, 2012
   Free Software Foundation, Inc.
   Contributed by Ivan Guzvinec  <ivang@@opencores.org>

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define OR32 1

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "coff/or32.h"
#include "coff/internal.h"
#include "libcoff.h"

static bfd_reloc_status_type or32_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)

#define INSERT_HWORD(WORD,HWORD)              \
    (((WORD) & 0xffff0000) | ((HWORD)& 0x0000ffff))
#define EXTRACT_HWORD(WORD)                   \
    ((WORD) & 0x0000ffff)
#define SIGN_EXTEND_HWORD(HWORD)              \
    ((HWORD) & 0x8000 ? (HWORD)|(~0xffffL) : (HWORD))

#define INSERT_JUMPTARG(WORD,JT)              \
    (((WORD) & 0xfc000000) | ((JT)& 0x03ffffff))
#define EXTRACT_JUMPTARG(WORD)                   \
    ((WORD) & 0x03ffffff)
#define SIGN_EXTEND_JUMPTARG(JT)              \
    ((JT) & 0x04000000 ? (JT)|(~0x03ffffffL) : (JT))

/* Provided the symbol, returns the value reffed.  */

static long
get_symbol_value (asymbol *symbol)
{
  long relocation = 0;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value +
      symbol->section->output_section->vma +
      symbol->section->output_offset;

  return relocation;
}

/* This function is in charge of performing all the or32 relocations.  */

static bfd_reloc_status_type
or32_reloc (bfd *abfd,
	    arelent *reloc_entry,
	    asymbol *symbol_in,
	    void * data,
	    asection *input_section,
	    bfd *output_bfd,
	    char **error_message)
{
  /* The consth relocation comes in two parts, we have to remember
     the state between calls, in these variables.  */
  static bfd_boolean part1_consth_active = FALSE;
  static unsigned long part1_consth_value;

  unsigned long insn;
  unsigned long sym_value;
  unsigned long unsigned_value;
  unsigned short r_type;
  long signed_value;

  unsigned long addr = reloc_entry->address ;   /*+ input_section->vma*/
  bfd_byte *hit_data =addr + (bfd_byte *)(data);

  r_type = reloc_entry->howto->type;

  if (output_bfd)
    {
      /* Partial linking - do nothing.  */
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (symbol_in != NULL
      && bfd_is_und_section (symbol_in->section))
    {
      /* Keep the state machine happy in case we're called again.  */
      if (r_type == R_IHIHALF)
        {
          part1_consth_active = TRUE;
          part1_consth_value  = 0;
        }

      return bfd_reloc_undefined;
    }

  if ((part1_consth_active) && (r_type != R_IHCONST))
    {
      part1_consth_active = FALSE;
      *error_message = (char *) "Missing IHCONST";

      return bfd_reloc_dangerous;
    }

  sym_value = get_symbol_value (symbol_in);

  switch (r_type)
    {
    case R_IREL:
      insn = bfd_get_32(abfd, hit_data);

      /* Take the value in the field and sign extend it.  */
      signed_value = EXTRACT_JUMPTARG (insn);
      signed_value = SIGN_EXTEND_JUMPTARG (signed_value);
      signed_value <<= 2;

      /* See the note on the R_IREL reloc in coff_or32_relocate_section.  */
      if (signed_value == - (long) reloc_entry->address)
        signed_value = 0;

      signed_value += sym_value + reloc_entry->addend;
      /* Relative jmp/call, so subtract from the value the
	 address of the place we're coming from.  */
      signed_value -= (reloc_entry->address
		       + input_section->output_section->vma
		       + input_section->output_offset);
      if (signed_value > 0x7ffffff || signed_value < -0x8000000)
	return bfd_reloc_overflow;

      signed_value >>= 2;
      insn = INSERT_JUMPTARG (insn, signed_value);
      bfd_put_32 (abfd, insn, hit_data);
      break;

    case R_ILOHALF:
      insn = bfd_get_32 (abfd, hit_data);
      unsigned_value = EXTRACT_HWORD (insn);
      unsigned_value +=  sym_value + reloc_entry->addend;
      insn = INSERT_HWORD (insn, unsigned_value);
      bfd_put_32 (abfd, insn, hit_data);
      break;

    case R_IHIHALF:
      insn = bfd_get_32 (abfd, hit_data);

      /* consth, part 1
         Just get the symbol value that is referenced.  */
      part1_consth_active = TRUE;
      part1_consth_value = sym_value + reloc_entry->addend;

      /* Don't modify insn until R_IHCONST.  */
      break;

    case R_IHCONST:
      insn = bfd_get_32 (abfd, hit_data);

      /* consth, part 2
         Now relocate the reference.  */
      if (! part1_consth_active)
        {
          *error_message = (char *) "Missing IHIHALF";
          return bfd_reloc_dangerous;
        }

      /* sym_ptr_ptr = r_symndx, in coff_slurp_reloc_table() */
      unsigned_value = 0;   /*EXTRACT_HWORD(insn) << 16;*/
      unsigned_value += reloc_entry->addend; /* r_symndx */
      unsigned_value += part1_consth_value;
      unsigned_value = unsigned_value >> 16;
      insn = INSERT_HWORD (insn, unsigned_value);
      part1_consth_active = FALSE;
      bfd_put_32 (abfd, insn, hit_data);
      break;

    case R_BYTE:
      insn = bfd_get_8 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
      if (unsigned_value & 0xffffff00)
        return bfd_reloc_overflow;
      bfd_put_8 (abfd, unsigned_value, hit_data);
      break;

    case R_HWORD:
      insn = bfd_get_16 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
      if (unsigned_value & 0xffff0000)
        return bfd_reloc_overflow;
      bfd_put_16 (abfd, insn, hit_data);
      break;

    case R_WORD:
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
      bfd_put_32 (abfd, insn, hit_data);
      break;

    default:
      *error_message = _("Unrecognized reloc");
      return bfd_reloc_dangerous;
    }

  return bfd_reloc_ok;
}

/*      type     rightshift
           size
        bitsize
             pc-relative
             bitpos
           absolute
               complain_on_overflow
              special_function
                relocation name
                     partial_inplace
                      src_mask
*/

/* FIXME: I'm not real sure about this table.  */
static reloc_howto_type howto_table[] =
{
  { R_ABS,      0, 3, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "ABS",     TRUE, 0xffffffff,0xffffffff, FALSE },
    EMPTY_HOWTO (1),
    EMPTY_HOWTO (2),
    EMPTY_HOWTO (3),
    EMPTY_HOWTO (4),
    EMPTY_HOWTO (5),
    EMPTY_HOWTO (6),
    EMPTY_HOWTO (7),
    EMPTY_HOWTO (8),
    EMPTY_HOWTO (9),
    EMPTY_HOWTO (10),
    EMPTY_HOWTO (11),
    EMPTY_HOWTO (12),
    EMPTY_HOWTO (13),
    EMPTY_HOWTO (14),
    EMPTY_HOWTO (15),
    EMPTY_HOWTO (16),
    EMPTY_HOWTO (17),
    EMPTY_HOWTO (18),
    EMPTY_HOWTO (19),
    EMPTY_HOWTO (20),
    EMPTY_HOWTO (21),
    EMPTY_HOWTO (22),
    EMPTY_HOWTO (23),
  { R_IREL,     0, 3, 32, TRUE,   0, complain_overflow_signed,    or32_reloc, "IREL",    TRUE, 0xffffffff,0xffffffff, FALSE },
  { R_IABS,     0, 3, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "IABS",    TRUE, 0xffffffff,0xffffffff, FALSE },
  { R_ILOHALF,  0, 3, 16, TRUE,   0, complain_overflow_signed,    or32_reloc, "ILOHALF", TRUE, 0x0000ffff,0x0000ffff, FALSE },
  { R_IHIHALF,  0, 3, 16, TRUE,   16,complain_overflow_signed,    or32_reloc, "IHIHALF", TRUE, 0xffff0000,0xffff0000, FALSE },
  { R_IHCONST,  0, 3, 16, TRUE,   0, complain_overflow_signed,    or32_reloc, "IHCONST", TRUE, 0xffff0000,0xffff0000, FALSE },
  { R_BYTE,     0, 0, 8,  FALSE,  0, complain_overflow_bitfield,  or32_reloc, "BYTE",    TRUE, 0x000000ff,0x000000ff, FALSE },
  { R_HWORD,    0, 1, 16, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "HWORD",   TRUE, 0x0000ffff,0x0000ffff, FALSE },
  { R_WORD,     0, 2, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "WORD",    TRUE, 0xffffffff,0xffffffff, FALSE },
};

#define BADMAG(x) OR32BADMAG (x)

#define RELOC_PROCESSING(relent, reloc, symbols, abfd, section) \
  reloc_processing (relent, reloc, symbols, abfd, section)

static void
reloc_processing (arelent *relent,
		  struct internal_reloc *reloc,
		  asymbol **symbols,
		  bfd *abfd,
		  asection *section)
{
  static bfd_vma ihihalf_vaddr = (bfd_vma) -1;

  relent->address = reloc->r_vaddr;
  relent->howto = howto_table + reloc->r_type;

  if (reloc->r_type == R_IHCONST)
    {
      /* The address of an R_IHCONST should always be the address of
	 the immediately preceding R_IHIHALF.  relocs generated by gas
	 are correct, but relocs generated by High C are different (I
	 can't figure out what the address means for High C).  We can
	 handle both gas and High C by ignoring the address here, and
	 simply reusing the address saved for R_IHIHALF.  */
      if (ihihalf_vaddr == (bfd_vma) -1)
	abort ();

      relent->address = ihihalf_vaddr;
      ihihalf_vaddr = (bfd_vma) -1;
      relent->addend = reloc->r_symndx;
      relent->sym_ptr_ptr= bfd_abs_section_ptr->symbol_ptr_ptr;
    }
  else
    {
      relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
      relent->addend = 0;
      relent->address-= section->vma;

      if (reloc->r_type == R_IHIHALF)
	ihihalf_vaddr = relent->address;
      else if (ihihalf_vaddr != (bfd_vma) -1)
	abort ();
    }
}

/* The reloc processing routine for the optimized COFF linker.  */

static bfd_boolean
coff_or32_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info,
			    bfd *input_bfd,
			    asection *input_section,
			    bfd_byte *contents,
			    struct internal_reloc *relocs,
			    struct internal_syment *syms,
			    asection **sections)
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;
  bfd_boolean hihalf;
  bfd_vma hihalf_val;

  /* If we are performing a relocatable link, we don't need to do a
     thing.  The caller will take care of adjusting the reloc
     addresses and symbol indices.  */
  if (info->relocatable)
    return TRUE;

  hihalf = FALSE;
  hihalf_val = 0;

  rel = relocs;
  relend = rel + input_section->reloc_count;

  for (; rel < relend; rel++)
    {
      long symndx;
      bfd_byte *loc;
      struct coff_link_hash_entry *h;
      struct internal_syment *sym;
      asection *sec;
      bfd_vma val;
      bfd_boolean overflow;
      unsigned long insn;
      long signed_value;
      unsigned long unsigned_value;
      bfd_reloc_status_type rstat;

      symndx = rel->r_symndx;
      loc = contents + rel->r_vaddr - input_section->vma;

      if (symndx == -1 || rel->r_type == R_IHCONST)
        h = NULL;
      else
        h = obj_coff_sym_hashes (input_bfd)[symndx];

      sym = NULL;
      sec = NULL;
      val = 0;

      /* An R_IHCONST reloc does not have a symbol.  Instead, the
         symbol index is an addend.  R_IHCONST is always used in
         conjunction with R_IHHALF.  */
      if (rel->r_type != R_IHCONST)
        {
          if (h == NULL)
            {
              if (symndx == -1)
                sec = bfd_abs_section_ptr;
              else
                {
                  sym = syms + symndx;
                  sec = sections[symndx];
                  val = (sec->output_section->vma
                         + sec->output_offset
                         + sym->n_value
                         - sec->vma);
                }
            }
          else
            {
              if (h->root.type == bfd_link_hash_defined
                  || h->root.type == bfd_link_hash_defweak)
                {
                  sec = h->root.u.def.section;
                  val = (h->root.u.def.value
                         + sec->output_section->vma
                         + sec->output_offset);
                }
              else
                {
                  if (! ((*info->callbacks->undefined_symbol)
                         (info, h->root.root.string, input_bfd, input_section,
                          rel->r_vaddr - input_section->vma, TRUE)))
                    return FALSE;
                }
            }

          if (hihalf)
            {
              if (! ((*info->callbacks->reloc_dangerous)
                     (info, "missing IHCONST reloc", input_bfd,
                      input_section, rel->r_vaddr - input_section->vma)))
                return FALSE;
              hihalf = FALSE;
            }
        }

      overflow = FALSE;

      switch (rel->r_type)
        {
        default:
          bfd_set_error (bfd_error_bad_value);
          return FALSE;

        case R_IREL:
          insn = bfd_get_32 (input_bfd, loc);

          /* Extract the addend.  */
          signed_value = EXTRACT_JUMPTARG (insn);
          signed_value = SIGN_EXTEND_JUMPTARG (signed_value);
          signed_value <<= 2;

          /* Determine the destination of the jump.  */
          signed_value += val;

	  /* Make the destination PC relative.  */
	  signed_value -= (input_section->output_section->vma
			   + input_section->output_offset
			   + (rel->r_vaddr - input_section->vma));
	  if (signed_value > 0x7ffffff || signed_value < - 0x8000000)
	    {
	      overflow = TRUE;
	      signed_value = 0;
	    }

          /* Put the adjusted value back into the instruction.  */
          signed_value >>= 2;
          insn = INSERT_JUMPTARG(insn, signed_value);

          bfd_put_32 (input_bfd, (bfd_vma) insn, loc);
          break;

        case R_ILOHALF:
          insn = bfd_get_32 (input_bfd, loc);
          unsigned_value = EXTRACT_HWORD (insn);
          unsigned_value += val;
          insn = INSERT_HWORD (insn, unsigned_value);
          bfd_put_32 (input_bfd, insn, loc);
          break;

        case R_IHIHALF:
          /* Save the value for the R_IHCONST reloc.  */
          hihalf = TRUE;
          hihalf_val = val;
          break;

        case R_IHCONST:
          if (! hihalf)
            {
              if (! ((*info->callbacks->reloc_dangerous)
                     (info, "missing IHIHALF reloc", input_bfd,
                      input_section, rel->r_vaddr - input_section->vma)))
                return FALSE;
              hihalf_val = 0;
            }

          insn = bfd_get_32 (input_bfd, loc);
          unsigned_value = rel->r_symndx + hihalf_val;
          unsigned_value >>= 16;
          insn = INSERT_HWORD (insn, unsigned_value);
          bfd_put_32 (input_bfd, (bfd_vma) insn, loc);

          hihalf = FALSE;
          break;

        case R_BYTE:
        case R_HWORD:
        case R_WORD:
          rstat = _bfd_relocate_contents (howto_table + rel->r_type,
                                          input_bfd, val, loc);
          if (rstat == bfd_reloc_overflow)
            overflow = TRUE;
          else if (rstat != bfd_reloc_ok)
            abort ();
          break;
        }

      if (overflow)
        {
          const char *name;
          char buf[SYMNMLEN + 1];

          if (symndx == -1)
            name = "*ABS*";
          else if (h != NULL)
            name = NULL;
          else if (sym == NULL)
            name = "*unknown*";
          else if (sym->_n._n_n._n_zeroes == 0
                   && sym->_n._n_n._n_offset != 0)
            name = obj_coff_strings (input_bfd) + sym->_n._n_n._n_offset;
          else
            {
              strncpy (buf, sym->_n._n_name, SYMNMLEN);
              buf[SYMNMLEN] = '\0';
              name = buf;
            }

          if (! ((*info->callbacks->reloc_overflow)
                 (info, (h ? &h->root : NULL), name,
		  howto_table[rel->r_type].name, (bfd_vma) 0, input_bfd,
		  input_section, rel->r_vaddr - input_section->vma)))
            return FALSE;
        }
    }

  return TRUE;
}

#define coff_relocate_section coff_or32_relocate_section

/* We don't want to change the symndx of a R_IHCONST reloc, since it
   is actually an addend, not a symbol index at all.  */

static bfd_boolean
coff_or32_adjust_symndx (bfd *obfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 bfd *ibfd ATTRIBUTE_UNUSED,
			 asection *sec ATTRIBUTE_UNUSED,
			 struct internal_reloc *irel,
			 bfd_boolean *adjustedp)
{
  if (irel->r_type == R_IHCONST)
    *adjustedp = TRUE;
  else
    *adjustedp = FALSE;
  return TRUE;
}

#define coff_adjust_symndx coff_or32_adjust_symndx

#ifndef bfd_pe_print_pdata
#define bfd_pe_print_pdata	NULL
#endif

#include "coffcode.h"

const bfd_target or32coff_big_vec =
{
  "coff-or32-big",  /* Name.  */
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,   /* Data byte order is big.  */
  BFD_ENDIAN_BIG,   /* Header byte order is big.  */

  (HAS_RELOC  | EXEC_P |    /* Object flags.  */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS   | HAS_LOCALS | WP_TEXT),

  (SEC_HAS_CONTENTS | SEC_ALLOC | /* Section flags.  */
   SEC_LOAD | SEC_RELOC |
   SEC_READONLY ),
  '_',        /* Leading underscore.  */
  '/',        /* ar_pad_char.  */
  15,         /* ar_max_namelen.  */
  0,          /* match priority.  */

  /* Data.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,

  /* Headers.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,

  {
    _bfd_dummy_target,
    coff_object_p,
    bfd_generic_archive_p,
    _bfd_dummy_target
  },
  {
    bfd_false,
    coff_mkobject,
    _bfd_generic_mkarchive,
    bfd_false
  },
  {
    bfd_false,
    coff_write_object_contents,
    _bfd_write_archive_contents,
    bfd_false
  },

  BFD_JUMP_TABLE_GENERIC (coff),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

 /* Alternative_target.  */
#ifdef TARGET_LITTLE_SYM
  & TARGET_LITTLE_SYM,
#else
  NULL,
#endif

  COFF_SWAP_TABLE
};
@


1.16
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2011
a31 2
static long get_symbol_value
  PARAMS ((asymbol *));
d33 1
a33 9
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean coff_or32_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static bfd_boolean coff_or32_adjust_symndx
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   struct internal_reloc *, bfd_boolean *));
static void reloc_processing
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
d54 1
a54 2
get_symbol_value (symbol)
     asymbol *symbol;
d71 7
a77 9
or32_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
            error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d279 5
a283 6
reloc_processing (relent,reloc, symbols, abfd, section)
     arelent *relent;
     struct internal_reloc *reloc;
     asymbol **symbols;
     bfd *abfd;
     asection *section;
d322 8
a329 10
coff_or32_relocate_section (output_bfd, info, input_bfd, input_section,
                            contents, relocs, syms, sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
d541 6
a546 7
coff_or32_adjust_symndx (obfd, info, ibfd, sec, irel, adjustedp)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *ibfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     struct internal_reloc *irel;
     bfd_boolean *adjustedp;
@


1.15
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008
d597 1
@


1.14
log
@        * pe-arm-wince.c (pe_print_compressed_pdata): Define new function to
        print compressed pdata structure as described on MSDN. This only
        applies to a limited set of architectures (ARM, SH4).
        (slurp_symtab, my_symbol_for_address): Define static helper
        functions for pe_print_compressed_pdata.
        * coffcode.h (bfd_coff_backend_data): Add _bfd_coff_print_pdata field.
        (bfd_coff_have_print_pdata, bfd_coff_print_pdata): Define.
        * bfd/peXXigen.c (_bfd_XX_print_private_bfd_data_common): Add check on
        bfd_coff_backend_data, call the function if non-null.
        * pei-mcore.c: Add target dependent initialisation for
        bfd_coff_backend_data.
        * coff-sh.c: Likewise.
        * coff64-rs6000.c: Likewise.
        * coff-rs6000.c: Likewise.
        * libcoff-in.h: Likewise.
        * cf-i386lynx.c: Likewise.
        * coff-alpha.c: Likewise.
        * coff-apollo.c: Likewise.
        * coff-arm.c: Likewise.
        * coff-aux.c: Likewise.
        * coff-h8300.c: Likewise.
        * coff-h8500.c: Likewise.
        * coff-i386.c: Likewise.
        * coff-i860.c: Likewise.
        * coff-i960.c: Likewise.
        * coff-ia64.c: Likewise.
        * coff-m68k.c: Likewise.
        * coff-m88k.c: Likewise.
        * coff-maxq.c: Likewise.
        * coff-mips.c: Likewise.
        * coff-or32.c: Likewise.
        * coff-sparc.c: Likewise.
        * coff-tic30.c: Likewise.
        * coff-tic4x.c: Likewise.
        * coff-tic54x.c: Likewise.
        * coff-tic80.c: Likewise.
        * coff-w65.c: Likewise.
        * coff-we32k.c: Likewise.
        * coff-x86_64.c: Likewise.
        * coff-z80.c: Likewise.
        * coff-z8k.c: Likewise.
        * pe-mcore.c: Likewise.
        * pe-mips.c: Likewise.
        * pe-ppc.c: Likewise.
        * peXXigen.c: Likewise.
        * pei-ppc.c: Likewise.
        * libcoff.h: Regenerate.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005, 2007, 2008
@


1.13
log
@Switch sources over to use the GPL version 3
@
text
@d2 2
a3 1
   Copyright 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
d574 4
@


1.12
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.11
log
@	* coff-or32.c (bfd_section_from_shdr): Remove unused local
	variable `ptr'.
	* cofflink.c (process_embedded_commands): Remove unused local
	variables `had_read' and `had_shared'.
	* ecofflink.c (bfd_ecoff_debug_accumulate): Remove unused local
	variable `fdr_adr'.
	* ihex.c (ihex_read_section): Remove unused local variable `addr'.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d23 1
a24 1
#include "sysdep.h"
@


1.10
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@a319 1
      asymbol *ptr;
a320 3

      ptr = *(relent->sym_ptr_ptr);

@


1.9
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.8
log
@update copyright dates
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.7
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
@


1.6
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d151 8
a158 17
#if 0
      if ((signed_value & ~0x3ffff) == 0)
        {                     /* Absolute jmp/call.  */
          insn |= (1<<24);    /* Make it absolute.  */
          /* FIXME: Should we change r_type to R_IABS.  */
        }
      else
#endif
        {
          /* Relative jmp/call, so subtract from the value the
             address of the place we're coming from.  */
          signed_value -= (reloc_entry->address
                           + input_section->output_section->vma
                           + input_section->output_offset);
          if (signed_value > 0x7ffffff || signed_value < -0x8000000)
            return bfd_reloc_overflow;
        }
d459 9
a467 19
#if 0
          if ((signed_value & ~0x3ffff) == 0)
            {
              /* We can use an absolute jump.  */
              insn |= (1 << 24);
            }
          else
#endif
            {
              /* Make the destination PC relative.  */
              signed_value -= (input_section->output_section->vma
                               + input_section->output_offset
                               + (rel->r_vaddr - input_section->vma));
              if (signed_value > 0x7ffffff || signed_value < - 0x8000000)
                {
                  overflow = TRUE;
                  signed_value = 0;
                }
            }
@


1.5
log
@Correct spelling of "relocatable".
@
text
@d548 1
a548 1
            name = h->root.root.string;
d562 3
a564 3
                 (info, name, howto_table[rel->r_type].name, (bfd_vma) 0,
                  input_bfd, input_section,
                  rel->r_vaddr - input_section->vma)))
@


1.4
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 2002 Free Software Foundation, Inc.
d363 1
a363 1
  /* If we are performing a relocateable link, we don't need to do a
d366 1
a366 1
  if (info->relocateable)
@


1.3
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d30 12
a41 5
static long                   get_symbol_value           PARAMS ((asymbol *));
static bfd_reloc_status_type  or32_reloc                 PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static boolean                coff_or32_relocate_section PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, struct internal_reloc *, struct internal_syment *, asection **));
static boolean                coff_or32_adjust_symndx    PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, struct internal_reloc *, boolean *));
static void                   reloc_processing           PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
d62 1
a62 1
get_symbol_value (symbol)       
d64 1
a64 1
{                                             
d68 2
a69 2
    relocation = 0;                           
  else 
d92 1
a92 1
  static boolean part1_consth_active = false;
d103 1
a103 1
  
d106 1
a106 1
  if (output_bfd) 
d117 1
a117 1
      if (r_type == R_IHIHALF) 
d119 1
a119 1
          part1_consth_active = true;
d126 1
a126 1
  if ((part1_consth_active) && (r_type != R_IHCONST)) 
d128 1
a128 1
      part1_consth_active = false;
d136 1
a136 1
  switch (r_type) 
d138 2
a139 2
    case R_IREL:  
      insn = bfd_get_32(abfd, hit_data); 
d156 2
a157 2
        } 
      else 
d165 1
a165 1
          if (signed_value > 0x7ffffff || signed_value < -0x8000000) 
d170 1
a170 1
      bfd_put_32 (abfd, insn, hit_data); 
d173 2
a174 2
    case R_ILOHALF: 
      insn = bfd_get_32 (abfd, hit_data); 
d178 1
a178 1
      bfd_put_32 (abfd, insn, hit_data); 
d182 1
a182 1
      insn = bfd_get_32 (abfd, hit_data); 
d184 1
a184 1
      /* consth, part 1 
d186 1
a186 1
      part1_consth_active = true;
d192 2
a193 2
    case R_IHCONST: 
      insn = bfd_get_32 (abfd, hit_data); 
d195 1
a195 1
      /* consth, part 2 
d197 1
a197 1
      if (! part1_consth_active) 
d209 2
a210 2
      part1_consth_active = false;
      bfd_put_32 (abfd, insn, hit_data); 
d214 2
a215 2
      insn = bfd_get_8 (abfd, hit_data); 
      unsigned_value = insn + sym_value + reloc_entry->addend;  
d218 1
a218 1
      bfd_put_8 (abfd, unsigned_value, hit_data); 
d222 2
a223 2
      insn = bfd_get_16 (abfd, hit_data); 
      unsigned_value = insn + sym_value + reloc_entry->addend;  
d226 1
a226 1
      bfd_put_16 (abfd, insn, hit_data); 
d230 2
a231 2
      insn = bfd_get_32 (abfd, hit_data); 
      insn += sym_value + reloc_entry->addend;  
d252 1
a252 1
                     partial_inplace 
d257 1
a257 1
static reloc_howto_type howto_table[] = 
d259 1
a259 1
  { R_ABS,      0, 3, 32, false,  0, complain_overflow_bitfield,  or32_reloc, "ABS",     true, 0xffffffff,0xffffffff, false },
d283 8
a290 8
  { R_IREL,     0, 3, 32, true,   0, complain_overflow_signed,    or32_reloc, "IREL",    true, 0xffffffff,0xffffffff, false },
  { R_IABS,     0, 3, 32, false,  0, complain_overflow_bitfield,  or32_reloc, "IABS",    true, 0xffffffff,0xffffffff, false },
  { R_ILOHALF,  0, 3, 16, true,   0, complain_overflow_signed,    or32_reloc, "ILOHALF", true, 0x0000ffff,0x0000ffff, false },
  { R_IHIHALF,  0, 3, 16, true,   16,complain_overflow_signed,    or32_reloc, "IHIHALF", true, 0xffff0000,0xffff0000, false },
  { R_IHCONST,  0, 3, 16, true,   0, complain_overflow_signed,    or32_reloc, "IHCONST", true, 0xffff0000,0xffff0000, false },
  { R_BYTE,     0, 0, 8,  false,  0, complain_overflow_bitfield,  or32_reloc, "BYTE",    true, 0x000000ff,0x000000ff, false },
  { R_HWORD,    0, 1, 16, false,  0, complain_overflow_bitfield,  or32_reloc, "HWORD",   true, 0x0000ffff,0x0000ffff, false },
  { R_WORD,     0, 2, 32, false,  0, complain_overflow_bitfield,  or32_reloc, "WORD",    true, 0xffffffff,0xffffffff, false },
d308 1
a308 1
  relent->address = reloc->r_vaddr;   
d311 2
a312 2
  if (reloc->r_type == R_IHCONST) 
    {   
d346 1
a346 1
static boolean
d360 1
a360 1
  boolean hihalf;
d367 1
a367 1
    return true;
d369 1
a369 1
  hihalf = false;
d383 1
a383 1
      boolean overflow;
d434 2
a435 2
                          rel->r_vaddr - input_section->vma, true)))
                    return false;
d444 2
a445 2
                return false;
              hihalf = false;
d449 1
a449 1
      overflow = false;
d455 1
a455 1
          return false;
d483 1
a483 1
                  overflow = true;
d505 1
a505 1
          hihalf = true;
d515 1
a515 1
                return false;
d525 1
a525 1
          hihalf = false;
d534 1
a534 1
            overflow = true;
d565 1
a565 1
            return false;
d567 1
a567 1
    }   
d569 1
a569 1
  return true;
d577 1
a577 1
static boolean
d584 1
a584 1
     boolean *adjustedp;
d587 1
a587 1
    *adjustedp = true;
d589 2
a590 2
    *adjustedp = false;
  return true;
d609 1
a609 1
   SEC_LOAD | SEC_RELOC | 
d625 1
a625 1
  { 
d653 1
a653 1
   
@


1.3.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d30 5
a34 12
static long get_symbol_value
  PARAMS ((asymbol *));
static bfd_reloc_status_type or32_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean coff_or32_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static bfd_boolean coff_or32_adjust_symndx
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   struct internal_reloc *, bfd_boolean *));
static void reloc_processing
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
d55 1
a55 1
get_symbol_value (symbol)
d57 1
a57 1
{
d61 2
a62 2
    relocation = 0;
  else
d85 1
a85 1
  static bfd_boolean part1_consth_active = FALSE;
d96 1
a96 1

d99 1
a99 1
  if (output_bfd)
d110 1
a110 1
      if (r_type == R_IHIHALF)
d112 1
a112 1
          part1_consth_active = TRUE;
d119 1
a119 1
  if ((part1_consth_active) && (r_type != R_IHCONST))
d121 1
a121 1
      part1_consth_active = FALSE;
d129 1
a129 1
  switch (r_type)
d131 2
a132 2
    case R_IREL:
      insn = bfd_get_32(abfd, hit_data);
d149 2
a150 2
        }
      else
d158 1
a158 1
          if (signed_value > 0x7ffffff || signed_value < -0x8000000)
d163 1
a163 1
      bfd_put_32 (abfd, insn, hit_data);
d166 2
a167 2
    case R_ILOHALF:
      insn = bfd_get_32 (abfd, hit_data);
d171 1
a171 1
      bfd_put_32 (abfd, insn, hit_data);
d175 1
a175 1
      insn = bfd_get_32 (abfd, hit_data);
d177 1
a177 1
      /* consth, part 1
d179 1
a179 1
      part1_consth_active = TRUE;
d185 2
a186 2
    case R_IHCONST:
      insn = bfd_get_32 (abfd, hit_data);
d188 1
a188 1
      /* consth, part 2
d190 1
a190 1
      if (! part1_consth_active)
d202 2
a203 2
      part1_consth_active = FALSE;
      bfd_put_32 (abfd, insn, hit_data);
d207 2
a208 2
      insn = bfd_get_8 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
d211 1
a211 1
      bfd_put_8 (abfd, unsigned_value, hit_data);
d215 2
a216 2
      insn = bfd_get_16 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
d219 1
a219 1
      bfd_put_16 (abfd, insn, hit_data);
d223 2
a224 2
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
d245 1
a245 1
                     partial_inplace
d250 1
a250 1
static reloc_howto_type howto_table[] =
d252 1
a252 1
  { R_ABS,      0, 3, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "ABS",     TRUE, 0xffffffff,0xffffffff, FALSE },
d276 8
a283 8
  { R_IREL,     0, 3, 32, TRUE,   0, complain_overflow_signed,    or32_reloc, "IREL",    TRUE, 0xffffffff,0xffffffff, FALSE },
  { R_IABS,     0, 3, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "IABS",    TRUE, 0xffffffff,0xffffffff, FALSE },
  { R_ILOHALF,  0, 3, 16, TRUE,   0, complain_overflow_signed,    or32_reloc, "ILOHALF", TRUE, 0x0000ffff,0x0000ffff, FALSE },
  { R_IHIHALF,  0, 3, 16, TRUE,   16,complain_overflow_signed,    or32_reloc, "IHIHALF", TRUE, 0xffff0000,0xffff0000, FALSE },
  { R_IHCONST,  0, 3, 16, TRUE,   0, complain_overflow_signed,    or32_reloc, "IHCONST", TRUE, 0xffff0000,0xffff0000, FALSE },
  { R_BYTE,     0, 0, 8,  FALSE,  0, complain_overflow_bitfield,  or32_reloc, "BYTE",    TRUE, 0x000000ff,0x000000ff, FALSE },
  { R_HWORD,    0, 1, 16, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "HWORD",   TRUE, 0x0000ffff,0x0000ffff, FALSE },
  { R_WORD,     0, 2, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "WORD",    TRUE, 0xffffffff,0xffffffff, FALSE },
d301 1
a301 1
  relent->address = reloc->r_vaddr;
d304 2
a305 2
  if (reloc->r_type == R_IHCONST)
    {
d339 1
a339 1
static bfd_boolean
d353 1
a353 1
  bfd_boolean hihalf;
d356 1
a356 1
  /* If we are performing a relocatable link, we don't need to do a
d359 2
a360 2
  if (info->relocatable)
    return TRUE;
d362 1
a362 1
  hihalf = FALSE;
d376 1
a376 1
      bfd_boolean overflow;
d427 2
a428 2
                          rel->r_vaddr - input_section->vma, TRUE)))
                    return FALSE;
d437 2
a438 2
                return FALSE;
              hihalf = FALSE;
d442 1
a442 1
      overflow = FALSE;
d448 1
a448 1
          return FALSE;
d476 1
a476 1
                  overflow = TRUE;
d498 1
a498 1
          hihalf = TRUE;
d508 1
a508 1
                return FALSE;
d518 1
a518 1
          hihalf = FALSE;
d527 1
a527 1
            overflow = TRUE;
d558 1
a558 1
            return FALSE;
d560 1
a560 1
    }
d562 1
a562 1
  return TRUE;
d570 1
a570 1
static bfd_boolean
d577 1
a577 1
     bfd_boolean *adjustedp;
d580 1
a580 1
    *adjustedp = TRUE;
d582 2
a583 2
    *adjustedp = FALSE;
  return TRUE;
d602 1
a602 1
   SEC_LOAD | SEC_RELOC |
d618 1
a618 1
  {
d646 1
a646 1

@


1.3.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d30 5
a34 12
static long get_symbol_value
  PARAMS ((asymbol *));
static bfd_reloc_status_type or32_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean coff_or32_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static bfd_boolean coff_or32_adjust_symndx
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	   struct internal_reloc *, bfd_boolean *));
static void reloc_processing
  PARAMS ((arelent *, struct internal_reloc *, asymbol **, bfd *, asection *));
d55 1
a55 1
get_symbol_value (symbol)
d57 1
a57 1
{
d61 2
a62 2
    relocation = 0;
  else
d85 1
a85 1
  static bfd_boolean part1_consth_active = FALSE;
d96 1
a96 1

d99 1
a99 1
  if (output_bfd)
d110 1
a110 1
      if (r_type == R_IHIHALF)
d112 1
a112 1
          part1_consth_active = TRUE;
d119 1
a119 1
  if ((part1_consth_active) && (r_type != R_IHCONST))
d121 1
a121 1
      part1_consth_active = FALSE;
d129 1
a129 1
  switch (r_type)
d131 2
a132 2
    case R_IREL:
      insn = bfd_get_32(abfd, hit_data);
d149 2
a150 2
        }
      else
d158 1
a158 1
          if (signed_value > 0x7ffffff || signed_value < -0x8000000)
d163 1
a163 1
      bfd_put_32 (abfd, insn, hit_data);
d166 2
a167 2
    case R_ILOHALF:
      insn = bfd_get_32 (abfd, hit_data);
d171 1
a171 1
      bfd_put_32 (abfd, insn, hit_data);
d175 1
a175 1
      insn = bfd_get_32 (abfd, hit_data);
d177 1
a177 1
      /* consth, part 1
d179 1
a179 1
      part1_consth_active = TRUE;
d185 2
a186 2
    case R_IHCONST:
      insn = bfd_get_32 (abfd, hit_data);
d188 1
a188 1
      /* consth, part 2
d190 1
a190 1
      if (! part1_consth_active)
d202 2
a203 2
      part1_consth_active = FALSE;
      bfd_put_32 (abfd, insn, hit_data);
d207 2
a208 2
      insn = bfd_get_8 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
d211 1
a211 1
      bfd_put_8 (abfd, unsigned_value, hit_data);
d215 2
a216 2
      insn = bfd_get_16 (abfd, hit_data);
      unsigned_value = insn + sym_value + reloc_entry->addend;
d219 1
a219 1
      bfd_put_16 (abfd, insn, hit_data);
d223 2
a224 2
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
d245 1
a245 1
                     partial_inplace
d250 1
a250 1
static reloc_howto_type howto_table[] =
d252 1
a252 1
  { R_ABS,      0, 3, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "ABS",     TRUE, 0xffffffff,0xffffffff, FALSE },
d276 8
a283 8
  { R_IREL,     0, 3, 32, TRUE,   0, complain_overflow_signed,    or32_reloc, "IREL",    TRUE, 0xffffffff,0xffffffff, FALSE },
  { R_IABS,     0, 3, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "IABS",    TRUE, 0xffffffff,0xffffffff, FALSE },
  { R_ILOHALF,  0, 3, 16, TRUE,   0, complain_overflow_signed,    or32_reloc, "ILOHALF", TRUE, 0x0000ffff,0x0000ffff, FALSE },
  { R_IHIHALF,  0, 3, 16, TRUE,   16,complain_overflow_signed,    or32_reloc, "IHIHALF", TRUE, 0xffff0000,0xffff0000, FALSE },
  { R_IHCONST,  0, 3, 16, TRUE,   0, complain_overflow_signed,    or32_reloc, "IHCONST", TRUE, 0xffff0000,0xffff0000, FALSE },
  { R_BYTE,     0, 0, 8,  FALSE,  0, complain_overflow_bitfield,  or32_reloc, "BYTE",    TRUE, 0x000000ff,0x000000ff, FALSE },
  { R_HWORD,    0, 1, 16, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "HWORD",   TRUE, 0x0000ffff,0x0000ffff, FALSE },
  { R_WORD,     0, 2, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "WORD",    TRUE, 0xffffffff,0xffffffff, FALSE },
d301 1
a301 1
  relent->address = reloc->r_vaddr;
d304 2
a305 2
  if (reloc->r_type == R_IHCONST)
    {
d339 1
a339 1
static bfd_boolean
d353 1
a353 1
  bfd_boolean hihalf;
d360 1
a360 1
    return TRUE;
d362 1
a362 1
  hihalf = FALSE;
d376 1
a376 1
      bfd_boolean overflow;
d427 2
a428 2
                          rel->r_vaddr - input_section->vma, TRUE)))
                    return FALSE;
d437 2
a438 2
                return FALSE;
              hihalf = FALSE;
d442 1
a442 1
      overflow = FALSE;
d448 1
a448 1
          return FALSE;
d476 1
a476 1
                  overflow = TRUE;
d498 1
a498 1
          hihalf = TRUE;
d508 1
a508 1
                return FALSE;
d518 1
a518 1
          hihalf = FALSE;
d527 1
a527 1
            overflow = TRUE;
d558 1
a558 1
            return FALSE;
d560 1
a560 1
    }
d562 1
a562 1
  return TRUE;
d570 1
a570 1
static bfd_boolean
d577 1
a577 1
     bfd_boolean *adjustedp;
d580 1
a580 1
    *adjustedp = TRUE;
d582 2
a583 2
    *adjustedp = FALSE;
  return TRUE;
d602 1
a602 1
   SEC_LOAD | SEC_RELOC |
d618 1
a618 1
  {
d646 1
a646 1

@


1.3.12.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d363 1
a363 1
  /* If we are performing a relocatable link, we don't need to do a
d366 1
a366 1
  if (info->relocatable)
@


1.2
log
@Fix compile time warning messages
@
text
@d190 1
a190 1
      if (part1_consth_active == false) 
@


1.2.10.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d190 1
a190 1
      if (! part1_consth_active) 
@


1.1
log
@Add support for OpenRISC 32-bit embedded processor
@
text
@d31 4
a34 3
static bfd_reloc_status_type  or1_reloc                  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static boolean                coff_or1_relocate_section  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, struct internal_reloc *, struct internal_syment *, asection **));
static boolean                coff_or1_adjust_symndx     PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, struct internal_reloc *, boolean *));
d253 23
a275 3
  {1},  {2},  {3},   {4},  {5},  {6},  {7},  {8},  {9}, {10},
  {11}, {12}, {13}, {14}, {15}, {16}, {17}, {18}, {19}, {20},
  {21}, {22}, {23},
d342 1
a342 1
     bfd *output_bfd;
@

