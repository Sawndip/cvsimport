head	1.362;
access;
symbols
	sid-snapshot-20180601:1.362
	sid-snapshot-20180501:1.362
	sid-snapshot-20180401:1.362
	sid-snapshot-20180301:1.362
	sid-snapshot-20180201:1.362
	sid-snapshot-20180101:1.362
	sid-snapshot-20171201:1.362
	sid-snapshot-20171101:1.362
	sid-snapshot-20171001:1.362
	sid-snapshot-20170901:1.362
	sid-snapshot-20170801:1.362
	sid-snapshot-20170701:1.362
	sid-snapshot-20170601:1.362
	sid-snapshot-20170501:1.362
	sid-snapshot-20170401:1.362
	sid-snapshot-20170301:1.362
	sid-snapshot-20170201:1.362
	sid-snapshot-20170101:1.362
	sid-snapshot-20161201:1.362
	sid-snapshot-20161101:1.362
	sid-snapshot-20160901:1.362
	sid-snapshot-20160801:1.362
	sid-snapshot-20160701:1.362
	sid-snapshot-20160601:1.362
	sid-snapshot-20160501:1.362
	sid-snapshot-20160401:1.362
	sid-snapshot-20160301:1.362
	sid-snapshot-20160201:1.362
	sid-snapshot-20160101:1.362
	sid-snapshot-20151201:1.362
	sid-snapshot-20151101:1.362
	sid-snapshot-20151001:1.362
	sid-snapshot-20150901:1.362
	sid-snapshot-20150801:1.362
	sid-snapshot-20150701:1.362
	sid-snapshot-20150601:1.362
	sid-snapshot-20150501:1.362
	sid-snapshot-20150401:1.362
	sid-snapshot-20150301:1.362
	sid-snapshot-20150201:1.362
	sid-snapshot-20150101:1.362
	sid-snapshot-20141201:1.362
	sid-snapshot-20141101:1.362
	sid-snapshot-20141001:1.362
	sid-snapshot-20140901:1.362
	sid-snapshot-20140801:1.362
	sid-snapshot-20140701:1.362
	sid-snapshot-20140601:1.362
	sid-snapshot-20140501:1.362
	sid-snapshot-20140401:1.362
	sid-snapshot-20140301:1.362
	sid-snapshot-20140201:1.362
	sid-snapshot-20140101:1.362
	sid-snapshot-20131201:1.362
	sid-snapshot-20131101:1.362
	sid-snapshot-20131001:1.360
	binutils-2_24-branch:1.359.0.2
	binutils-2_24-branchpoint:1.359
	binutils-2_21_1:1.279.2.3
	sid-snapshot-20130901:1.358
	gdb_7_6_1-2013-08-30-release:1.351
	sid-snapshot-20130801:1.358
	sid-snapshot-20130701:1.356
	sid-snapshot-20130601:1.354
	sid-snapshot-20130501:1.353
	gdb_7_6-2013-04-26-release:1.351
	sid-snapshot-20130401:1.352
	binutils-2_23_2:1.309.2.2
	gdb_7_6-branch:1.351.0.2
	gdb_7_6-2013-03-12-branchpoint:1.351
	sid-snapshot-20130301:1.350
	sid-snapshot-20130201:1.322
	sid-snapshot-20130101:1.320
	sid-snapshot-20121201:1.316
	gdb_7_5_1-2012-11-29-release:1.308
	binutils-2_23_1:1.309.2.1
	sid-snapshot-20121101:1.316
	binutils-2_23:1.309.2.1
	sid-snapshot-20121001:1.316
	sid-snapshot-20120901:1.315
	gdb_7_5-2012-08-17-release:1.308
	sid-snapshot-20120801:1.309
	binutils-2_23-branch:1.309.0.2
	binutils-2_23-branchpoint:1.309
	gdb_7_5-branch:1.308.0.2
	gdb_7_5-2012-07-18-branchpoint:1.308
	sid-snapshot-20120701:1.306
	sid-snapshot-20120601:1.305
	sid-snapshot-20120501:1.303
	binutils-2_22_branch:1.292.2.1.0.2
	gdb_7_4_1-2012-04-26-release:1.299
	sid-snapshot-20120401:1.301
	sid-snapshot-20120301:1.301
	sid-snapshot-20120201:1.301
	gdb_7_4-2012-01-24-release:1.299
	sid-snapshot-20120101:1.301
	gdb_7_4-branch:1.299.0.2
	gdb_7_4-2011-12-13-branchpoint:1.299
	sid-snapshot-20111201:1.296
	binutils-2_22:1.292.2.1
	sid-snapshot-20111101:1.294
	sid-snapshot-20111001:1.293
	binutils-2_22-branch:1.292.0.2
	binutils-2_22-branchpoint:1.292
	gdb_7_3_1-2011-09-04-release:1.282
	sid-snapshot-20110901:1.292
	sid-snapshot-20110801:1.291
	gdb_7_3-2011-07-26-release:1.282
	sid-snapshot-20110701:1.287
	sid-snapshot-20110601:1.284
	sid-snapshot-20110501:1.283
	gdb_7_3-branch:1.282.0.2
	gdb_7_3-2011-04-01-branchpoint:1.282
	sid-snapshot-20110401:1.282
	sid-snapshot-20110301:1.282
	sid-snapshot-20110201:1.282
	sid-snapshot-20110101:1.281
	binutils-2_21:1.279
	sid-snapshot-20101201:1.281
	binutils-2_21-branch:1.279.0.2
	binutils-2_21-branchpoint:1.279
	sid-snapshot-20101101:1.278
	sid-snapshot-20101001:1.275
	binutils-2_20_1:1.260
	gdb_7_2-2010-09-02-release:1.267
	sid-snapshot-20100901:1.270
	sid-snapshot-20100801:1.268
	gdb_7_2-branch:1.267.0.2
	gdb_7_2-2010-07-07-branchpoint:1.267
	sid-snapshot-20100701:1.267
	sid-snapshot-20100601:1.267
	sid-snapshot-20100501:1.267
	sid-snapshot-20100401:1.267
	gdb_7_1-2010-03-18-release:1.266
	sid-snapshot-20100301:1.267
	gdb_7_1-branch:1.266.0.2
	gdb_7_1-2010-02-18-branchpoint:1.266
	sid-snapshot-20100201:1.265
	sid-snapshot-20100101:1.264
	gdb_7_0_1-2009-12-22-release:1.260
	sid-snapshot-20091201:1.262
	sid-snapshot-20091101:1.262
	binutils-2_20:1.260
	gdb_7_0-2009-10-06-release:1.260
	sid-snapshot-20091001:1.262
	gdb_7_0-branch:1.260.0.4
	gdb_7_0-2009-09-16-branchpoint:1.260
	arc-sim-20090309:1.226
	binutils-arc-20081103-branch:1.250.0.8
	binutils-arc-20081103-branchpoint:1.250
	binutils-2_20-branch:1.260.0.2
	binutils-2_20-branchpoint:1.260
	sid-snapshot-20090901:1.257
	sid-snapshot-20090801:1.256
	msnyder-checkpoint-072509-branch:1.256.0.2
	msnyder-checkpoint-072509-branchpoint:1.256
	sid-snapshot-20090701:1.255
	dje-cgen-play1-branch:1.255.0.2
	dje-cgen-play1-branchpoint:1.255
	sid-snapshot-20090601:1.255
	sid-snapshot-20090501:1.254
	sid-snapshot-20090401:1.254
	arc-20081103-branch:1.250.0.6
	arc-20081103-branchpoint:1.250
	arc-insight_6_8-branch:1.226.0.6
	arc-insight_6_8-branchpoint:1.226
	insight_6_8-branch:1.226.0.4
	insight_6_8-branchpoint:1.226
	sid-snapshot-20090301:1.254
	binutils-2_19_1:1.249
	sid-snapshot-20090201:1.252
	sid-snapshot-20090101:1.251
	reverse-20081226-branch:1.251.0.2
	reverse-20081226-branchpoint:1.251
	sid-snapshot-20081201:1.251
	multiprocess-20081120-branch:1.250.0.4
	multiprocess-20081120-branchpoint:1.250
	sid-snapshot-20081101:1.250
	binutils-2_19:1.249
	sid-snapshot-20081001:1.250
	reverse-20080930-branch:1.250.0.2
	reverse-20080930-branchpoint:1.250
	binutils-2_19-branch:1.249.0.2
	binutils-2_19-branchpoint:1.249
	sid-snapshot-20080901:1.249
	sid-snapshot-20080801:1.235
	reverse-20080717-branch:1.234.0.2
	reverse-20080717-branchpoint:1.234
	sid-snapshot-20080701:1.230
	msnyder-reverse-20080609-branch:1.230.0.2
	msnyder-reverse-20080609-branchpoint:1.230
	drow-reverse-20070409-branch:1.198.0.2
	drow-reverse-20070409-branchpoint:1.198
	sid-snapshot-20080601:1.230
	sid-snapshot-20080501:1.230
	sid-snapshot-20080403:1.229
	sid-snapshot-20080401:1.229
	gdb_6_8-2008-03-27-release:1.226
	sid-snapshot-20080301:1.227
	gdb_6_8-branch:1.226.0.2
	gdb_6_8-2008-02-26-branchpoint:1.226
	sid-snapshot-20080201:1.224
	sid-snapshot-20080101:1.223
	sid-snapshot-20071201:1.223
	sid-snapshot-20071101:1.217
	gdb_6_7_1-2007-10-29-release:1.213
	gdb_6_7-2007-10-10-release:1.213
	sid-snapshot-20071001:1.215
	gdb_6_7-branch:1.213.0.2
	gdb_6_7-2007-09-07-branchpoint:1.213
	binutils-2_18:1.212.2.1
	binutils-2_18-branch:1.212.0.2
	binutils-2_18-branchpoint:1.212
	insight_6_6-20070208-release:1.192
	binutils-csl-coldfire-4_1-32:1.162.2.2
	binutils-csl-sourcerygxx-4_1-32:1.162.2.2
	gdb_6_6-2006-12-18-release:1.192
	binutils-csl-innovasic-fido-3_4_4-33:1.162.2.2
	binutils-csl-sourcerygxx-3_4_4-32:1.126.2.4
	binutils-csl-coldfire-4_1-30:1.162.2.2
	binutils-csl-sourcerygxx-4_1-30:1.162.2.2
	binutils-csl-coldfire-4_1-28:1.162.2.2
	binutils-csl-sourcerygxx-4_1-29:1.162.2.2
	binutils-csl-sourcerygxx-4_1-28:1.162.2.2
	gdb_6_6-branch:1.192.0.2
	gdb_6_6-2006-11-15-branchpoint:1.192
	binutils-csl-arm-2006q3-27:1.162.2.2
	binutils-csl-sourcerygxx-4_1-27:1.162.2.2
	binutils-csl-arm-2006q3-26:1.162.2.2
	binutils-csl-sourcerygxx-4_1-26:1.162.2.2
	binutils-csl-sourcerygxx-4_1-25:1.162.2.2
	binutils-csl-sourcerygxx-4_1-24:1.162.2.2
	binutils-csl-sourcerygxx-4_1-23:1.162.2.2
	insight_6_5-20061003-release:1.168
	gdb-csl-symbian-6_4_50_20060226-12:1.158
	binutils-csl-sourcerygxx-4_1-21:1.162.2.2
	binutils-csl-arm-2006q3-21:1.162.2.2
	binutils-csl-sourcerygxx-4_1-22:1.162.2.2
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.162.2.2
	binutils-csl-sourcerygxx-4_1-20:1.162.2.2
	binutils-csl-arm-2006q3-19:1.162.2.2
	binutils-csl-sourcerygxx-4_1-19:1.162.2.2
	binutils-csl-sourcerygxx-4_1-18:1.162.2.2
	binutils-csl-renesas-4_1-9:1.162.2.2
	gdb-csl-sourcerygxx-3_4_4-25:1.154
	binutils-csl-sourcerygxx-3_4_4-25:1.126.2.4
	nickrob-async-20060828-mergepoint:1.181
	gdb-csl-symbian-6_4_50_20060226-11:1.158
	binutils-csl-renesas-4_1-8:1.162.2.1
	binutils-csl-renesas-4_1-7:1.162.2.1
	binutils-csl-renesas-4_1-6:1.162.2.1
	gdb-csl-sourcerygxx-4_1-17:1.158
	binutils-csl-sourcerygxx-4_1-17:1.162.2.1
	gdb-csl-20060226-branch-local-2:1.158
	gdb-csl-sourcerygxx-4_1-14:1.158
	binutils-csl-sourcerygxx-4_1-14:1.162
	binutils-csl-sourcerygxx-4_1-15:1.162
	gdb-csl-sourcerygxx-4_1-13:1.158
	binutils-csl-sourcerygxx-4_1-13:1.162
	binutils-2_17:1.165.4.3
	gdb-csl-sourcerygxx-4_1-12:1.158
	binutils-csl-sourcerygxx-4_1-12:1.162
	gdb-csl-sourcerygxx-3_4_4-21:1.158
	binutils-csl-sourcerygxx-3_4_4-21:1.162
	gdb_6_5-20060621-release:1.168
	binutils-csl-wrs-linux-3_4_4-24:1.126
	binutils-csl-wrs-linux-3_4_4-23:1.126
	gdb-csl-sourcerygxx-4_1-9:1.158
	binutils-csl-sourcerygxx-4_1-9:1.162
	gdb-csl-sourcerygxx-4_1-8:1.158
	binutils-csl-sourcerygxx-4_1-8:1.162
	gdb-csl-sourcerygxx-4_1-7:1.158
	binutils-csl-sourcerygxx-4_1-7:1.162
	gdb-csl-arm-2006q1-6:1.158
	binutils-csl-arm-2006q1-6:1.162
	gdb-csl-sourcerygxx-4_1-6:1.158
	binutils-csl-sourcerygxx-4_1-6:1.162
	binutils-csl-wrs-linux-3_4_4-22:1.126
	gdb-csl-symbian-6_4_50_20060226-10:1.158
	gdb-csl-symbian-6_4_50_20060226-9:1.158
	gdb-csl-symbian-6_4_50_20060226-8:1.158
	gdb-csl-coldfire-4_1-11:1.158
	binutils-csl-coldfire-4_1-11:1.162
	gdb-csl-sourcerygxx-3_4_4-19:1.158
	binutils-csl-sourcerygxx-3_4_4-19:1.162
	gdb-csl-coldfire-4_1-10:1.158
	gdb_6_5-branch:1.168.0.4
	gdb_6_5-2006-05-14-branchpoint:1.168
	binutils-csl-coldfire-4_1-10:1.162
	gdb-csl-sourcerygxx-4_1-5:1.158
	binutils-csl-sourcerygxx-4_1-5:1.162
	nickrob-async-20060513-branch:1.168.0.2
	nickrob-async-20060513-branchpoint:1.168
	gdb-csl-sourcerygxx-4_1-4:1.158
	binutils-csl-sourcerygxx-4_1-4:1.162
	msnyder-reverse-20060502-branch:1.165.0.8
	msnyder-reverse-20060502-branchpoint:1.165
	binutils-csl-wrs-linux-3_4_4-21:1.126
	gdb-csl-morpho-4_1-4:1.158
	binutils-csl-morpho-4_1-4:1.162
	gdb-csl-sourcerygxx-3_4_4-17:1.158
	binutils-csl-sourcerygxx-3_4_4-17:1.162
	binutils-csl-wrs-linux-3_4_4-20:1.126
	readline_5_1-import-branch:1.165.0.6
	readline_5_1-import-branchpoint:1.165
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.158
	binutils-2_17-branch:1.165.0.4
	binutils-2_17-branchpoint:1.165
	gdb-csl-symbian-20060226-branch:1.158.0.4
	gdb-csl-symbian-20060226-branchpoint:1.158
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.158
	msnyder-reverse-20060331-branch:1.165.0.2
	msnyder-reverse-20060331-branchpoint:1.165
	binutils-csl-2_17-branch:1.162.0.2
	binutils-csl-2_17-branchpoint:1.162
	gdb-csl-available-20060303-branch:1.159.0.2
	gdb-csl-available-20060303-branchpoint:1.159
	gdb-csl-20060226-branch:1.158.0.2
	gdb-csl-20060226-branchpoint:1.158
	gdb_6_4-20051202-release:1.152
	msnyder-fork-checkpoint-branch:1.154.0.4
	msnyder-fork-checkpoint-branchpoint:1.154
	gdb-csl-gxxpro-6_3-branch:1.154.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.154
	gdb_6_4-branch:1.152.0.2
	gdb_6_4-2005-11-01-branchpoint:1.152
	gdb-csl-arm-20051020-branch:1.151.0.2
	gdb-csl-arm-20051020-branchpoint:1.151
	binutils-csl-gxxpro-3_4-branch:1.126.2.4.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.126.2.4
	binutils-2_16_1:1.126.2.4
	msnyder-tracepoint-checkpoint-branch:1.141.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.141
	gdb-csl-arm-20050325-2005-q1b:1.129
	binutils-csl-arm-2005q1b:1.126
	binutils-2_16:1.126.2.2
	gdb-csl-arm-20050325-2005-q1a:1.129
	binutils-csl-arm-2005q1a:1.126
	csl-arm-20050325-branch:1.129.0.2
	csl-arm-20050325-branchpoint:1.129
	binutils-csl-arm-2005q1-branch:1.126.0.4
	binutils-csl-arm-2005q1-branchpoint:1.126
	binutils-2_16-branch:1.126.0.2
	binutils-2_16-branchpoint:1.126
	csl-arm-2004-q3d:1.112
	gdb_6_3-20041109-release:1.111
	gdb_6_3-branch:1.111.0.2
	gdb_6_3-20041019-branchpoint:1.111
	csl-arm-2004-q3:1.111
	drow_intercu-merge-20040921:1.111
	drow_intercu-merge-20040915:1.109
	jimb-gdb_6_2-e500-branch:1.106.0.6
	jimb-gdb_6_2-e500-branchpoint:1.106
	gdb_6_2-20040730-release:1.106
	gdb_6_2-branch:1.106.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.106
	gdb_6_1_1-20040616-release:1.90
	binutils-2_15:1.90.2.2
	binutils-2_15-branchpoint:1.90
	csl-arm-2004-q1a:1.100
	csl-arm-2004-q1:1.97
	gdb_6_1-2004-04-05-release:1.90
	drow_intercu-merge-20040402:1.96
	drow_intercu-merge-20040327:1.95
	ezannoni_pie-20040323-branch:1.93.0.2
	ezannoni_pie-20040323-branchpoint:1.93
	cagney_tramp-20040321-mergepoint:1.93
	cagney_tramp-20040309-branch:1.91.0.2
	cagney_tramp-20040309-branchpoint:1.91
	gdb_6_1-branch:1.90.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.90
	drow_intercu-20040221-branch:1.90.0.4
	drow_intercu-20040221-branchpoint:1.90
	binutils-2_15-branch:1.90.0.2
	cagney_bfdfile-20040213-branch:1.89.0.2
	cagney_bfdfile-20040213-branchpoint:1.89
	drow-cplus-merge-20040208:1.88
	carlton_dictionary-20040126-merge:1.88
	cagney_bigcore-20040122-branch:1.88.0.2
	cagney_bigcore-20040122-branchpoint:1.88
	drow-cplus-merge-20040113:1.88
	csl-arm-2003-q4:1.88
	drow-cplus-merge-20031224:1.88
	drow-cplus-merge-20031220:1.88
	carlton_dictionary-20031215-merge:1.87
	drow-cplus-merge-20031214:1.87
	carlton-dictionary-20031111-merge:1.81
	gdb_6_0-2003-10-04-release:1.59
	kettenis_sparc-20030918-branch:1.74.0.6
	kettenis_sparc-20030918-branchpoint:1.74
	carlton_dictionary-20030917-merge:1.74
	ezannoni_pie-20030916-branchpoint:1.74
	ezannoni_pie-20030916-branch:1.74.0.4
	cagney_x86i386-20030821-branch:1.74.0.2
	cagney_x86i386-20030821-branchpoint:1.74
	carlton_dictionary-20030805-merge:1.71
	carlton_dictionary-20030627-merge:1.62
	gdb_6_0-branch:1.59.0.4
	gdb_6_0-2003-06-23-branchpoint:1.59
	jimb-ppc64-linux-20030613-branch:1.59.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.59
	binutils-2_14:1.51.4.3
	cagney_convert-20030606-branch:1.57.0.2
	cagney_convert-20030606-branchpoint:1.57
	cagney_writestrings-20030508-branch:1.53.0.6
	cagney_writestrings-20030508-branchpoint:1.53
	jimb-ppc64-linux-20030528-branch:1.55.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.55
	carlton_dictionary-20030523-merge:1.54
	cagney_fileio-20030521-branch:1.53.0.4
	cagney_fileio-20030521-branchpoint:1.53
	kettenis_i386newframe-20030517-mergepoint:1.53
	jimb-ppc64-linux-20030509-branch:1.53.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.53
	kettenis_i386newframe-20030504-mergepoint:1.51
	carlton_dictionary-20030430-merge:1.51
	binutils-2_14-branch:1.51.0.4
	binutils-2_14-branchpoint:1.51
	kettenis_i386newframe-20030419-branch:1.51.0.2
	kettenis_i386newframe-20030419-branchpoint:1.51
	carlton_dictionary-20030416-merge:1.51
	cagney_frameaddr-20030409-mergepoint:1.48
	kettenis_i386newframe-20030406-branch:1.48.0.4
	kettenis_i386newframe-20030406-branchpoint:1.48
	cagney_frameaddr-20030403-branchpoint:1.48
	cagney_frameaddr-20030403-branch:1.48.0.2
	cagney_framebase-20030330-mergepoint:1.47
	cagney_framebase-20030326-branch:1.47.0.2
	cagney_framebase-20030326-branchpoint:1.47
	cagney_lazyid-20030317-branch:1.46.0.4
	cagney_lazyid-20030317-branchpoint:1.46
	kettenis-i386newframe-20030316-mergepoint:1.46
	offbyone-20030313-branch:1.46.0.2
	offbyone-20030313-branchpoint:1.46
	kettenis-i386newframe-20030308-branch:1.44.0.4
	kettenis-i386newframe-20030308-branchpoint:1.44
	carlton_dictionary-20030305-merge:1.44
	cagney_offbyone-20030303-branch:1.44.0.2
	cagney_offbyone-20030303-branchpoint:1.44
	carlton_dictionary-20030207-merge:1.42
	interps-20030202-branch:1.41.0.2
	interps-20030202-branchpoint:1.41
	cagney-unwind-20030108-branch:1.37.0.2
	cagney-unwind-20030108-branchpoint:1.37
	binutils-2_13_2_1:1.14.2.5
	binutils-2_13_2:1.14.2.5
	carlton_dictionary-20021223-merge:1.35
	gdb_5_3-2002-12-12-release:1.21
	carlton_dictionary-20021115-merge:1.29
	binutils-2_13_1:1.14.2.5
	kseitz_interps-20021105-merge:1.29
	kseitz_interps-20021103-merge:1.29
	drow-cplus-merge-20021020:1.27
	drow-cplus-merge-20021025:1.29
	carlton_dictionary-20021025-merge:1.29
	carlton_dictionary-20021011-merge:1.26
	drow-cplus-branch:1.24.0.2
	drow-cplus-branchpoint:1.24
	kseitz_interps-20020930-merge:1.24
	carlton_dictionary-20020927-merge:1.23
	carlton_dictionary-branch:1.22.0.2
	carlton_dictionary-20020920-branchpoint:1.22
	sid-20020905-branchpoint:1.21
	sid-20020905-branch:1.21.0.8
	gdb_5_3-branch:1.21.0.6
	gdb_5_3-2002-09-04-branchpoint:1.21
	kseitz_interps-20020829-merge:1.21
	cagney_sysregs-20020825-branch:1.21.0.4
	cagney_sysregs-20020825-branchpoint:1.21
	readline_4_3-import-branch:1.21.0.2
	readline_4_3-import-branchpoint:1.21
	binutils-2_13:1.14.2.1
	binutils-2_13-branchpoint:1.14
	binutils-2_13-branch:1.14.0.2
	kseitz_interps-20020528-branch:1.5.0.2
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.4.0.4
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.2
	jimb-macro-020506-branchpoint:1.4
	binutils_latest_snapshot:1.362;
locks; strict;
comment	@ * @;


1.362
date	2013.10.14.18.43.39;	author chaoyingfu;	state Exp;
branches;
next	1.361;

1.361
date	2013.10.13.10.03.21;	author rsandifo;	state Exp;
branches;
next	1.360;

1.360
date	2013.09.24.22.15.37;	author rsandifo;	state Exp;
branches;
next	1.359;

1.359
date	2013.09.17.21.07.13;	author sje;	state Exp;
branches
	1.359.2.1;
next	1.358;

1.358
date	2013.07.15.15.07.29;	author macro;	state Exp;
branches;
next	1.357;

1.357
date	2013.07.12.15.58.13;	author macro;	state Exp;
branches;
next	1.356;

1.356
date	2013.06.25.18.02.33;	author macro;	state Exp;
branches;
next	1.355;

1.355
date	2013.06.24.23.55.44;	author macro;	state Exp;
branches;
next	1.354;

1.354
date	2013.05.22.08.39.52;	author amodra;	state Exp;
branches;
next	1.353;

1.353
date	2013.04.17.14.16.01;	author nickc;	state Exp;
branches;
next	1.352;

1.352
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.351;

1.351
date	2013.03.08.11.50.27;	author macro;	state Exp;
branches;
next	1.350;

1.350
date	2013.02.21.02.29.10;	author amodra;	state Exp;
branches;
next	1.349;

1.349
date	2013.02.19.21.58.46;	author macro;	state Exp;
branches;
next	1.348;

1.348
date	2013.02.18.23.18.16;	author macro;	state Exp;
branches;
next	1.347;

1.347
date	2013.02.18.23.16.35;	author macro;	state Exp;
branches;
next	1.346;

1.346
date	2013.02.18.02.56.58;	author amodra;	state Exp;
branches;
next	1.345;

1.345
date	2013.02.13.14.08.55;	author rsandifo;	state Exp;
branches;
next	1.344;

1.344
date	2013.02.12.09.54.56;	author rsandifo;	state Exp;
branches;
next	1.343;

1.343
date	2013.02.11.18.20.51;	author rsandifo;	state Exp;
branches;
next	1.342;

1.342
date	2013.02.11.18.17.57;	author rsandifo;	state Exp;
branches;
next	1.341;

1.341
date	2013.02.11.18.15.46;	author rsandifo;	state Exp;
branches;
next	1.340;

1.340
date	2013.02.11.18.12.27;	author rsandifo;	state Exp;
branches;
next	1.339;

1.339
date	2013.02.11.18.11.17;	author rsandifo;	state Exp;
branches;
next	1.338;

1.338
date	2013.02.11.18.09.23;	author rsandifo;	state Exp;
branches;
next	1.337;

1.337
date	2013.02.11.18.06.08;	author rsandifo;	state Exp;
branches;
next	1.336;

1.336
date	2013.02.11.18.01.58;	author rsandifo;	state Exp;
branches;
next	1.335;

1.335
date	2013.02.11.17.59.31;	author rsandifo;	state Exp;
branches;
next	1.334;

1.334
date	2013.02.11.17.55.27;	author rsandifo;	state Exp;
branches;
next	1.333;

1.333
date	2013.02.11.17.54.15;	author rsandifo;	state Exp;
branches;
next	1.332;

1.332
date	2013.02.11.17.46.01;	author rsandifo;	state Exp;
branches;
next	1.331;

1.331
date	2013.02.11.17.43.00;	author rsandifo;	state Exp;
branches;
next	1.330;

1.330
date	2013.02.11.17.40.51;	author rsandifo;	state Exp;
branches;
next	1.329;

1.329
date	2013.02.11.17.38.53;	author rsandifo;	state Exp;
branches;
next	1.328;

1.328
date	2013.02.11.17.31.23;	author rsandifo;	state Exp;
branches;
next	1.327;

1.327
date	2013.02.11.17.29.31;	author rsandifo;	state Exp;
branches;
next	1.326;

1.326
date	2013.02.11.17.27.57;	author rsandifo;	state Exp;
branches;
next	1.325;

1.325
date	2013.02.11.17.25.23;	author rsandifo;	state Exp;
branches;
next	1.324;

1.324
date	2013.02.11.17.21.30;	author rsandifo;	state Exp;
branches;
next	1.323;

1.323
date	2013.02.10.04.36.32;	author amodra;	state Exp;
branches;
next	1.322;

1.322
date	2013.01.10.20.03.54;	author hjl;	state Exp;
branches;
next	1.321;

1.321
date	2013.01.04.17.22.45;	author nickc;	state Exp;
branches;
next	1.320;

1.320
date	2012.12.06.00.09.13;	author amodra;	state Exp;
branches;
next	1.319;

1.319
date	2012.12.03.16.37.51;	author macro;	state Exp;
branches;
next	1.318;

1.318
date	2012.12.03.16.17.46;	author macro;	state Exp;
branches;
next	1.317;

1.317
date	2012.12.03.15.57.44;	author macro;	state Exp;
branches;
next	1.316;

1.316
date	2012.09.02.12.17.27;	author hjl;	state Exp;
branches;
next	1.315;

1.315
date	2012.08.17.02.39.26;	author amodra;	state Exp;
branches;
next	1.314;

1.314
date	2012.08.13.19.43.38;	author macro;	state Exp;
branches;
next	1.313;

1.313
date	2012.08.13.13.06.14;	author macro;	state Exp;
branches;
next	1.312;

1.312
date	2012.08.09.12.05.15;	author macro;	state Exp;
branches;
next	1.311;

1.311
date	2012.08.03.22.14.20;	author macro;	state Exp;
branches;
next	1.310;

1.310
date	2012.08.03.22.09.40;	author macro;	state Exp;
branches;
next	1.309;

1.309
date	2012.07.24.21.06.58;	author ccoutant;	state Exp;
branches
	1.309.2.1;
next	1.308;

1.308
date	2012.07.13.14.22.48;	author nickc;	state Exp;
branches;
next	1.307;

1.307
date	2012.07.02.03.02.44;	author amodra;	state Exp;
branches;
next	1.306;

1.306
date	2012.06.29.14.46.03;	author amodra;	state Exp;
branches;
next	1.305;

1.305
date	2012.05.19.19.30.45;	author macro;	state Exp;
branches;
next	1.304;

1.304
date	2012.05.07.03.27.52;	author macro;	state Exp;
branches;
next	1.303;

1.303
date	2012.04.24.05.12.37;	author amodra;	state Exp;
branches;
next	1.302;

1.302
date	2012.04.16.11.45.56;	author macro;	state Exp;
branches;
next	1.301;

1.301
date	2011.12.19.07.58.00;	author cltang;	state Exp;
branches;
next	1.300;

1.300
date	2011.12.19.07.31.07;	author cltang;	state Exp;
branches;
next	1.299;

1.299
date	2011.12.13.06.22.01;	author cltang;	state Exp;
branches;
next	1.298;

1.298
date	2011.12.11.02.05.40;	author daney;	state Exp;
branches;
next	1.297;

1.297
date	2011.12.08.20.47.24;	author pinskia;	state Exp;
branches;
next	1.296;

1.296
date	2011.11.29.20.28.54;	author pinskia;	state Exp;
branches;
next	1.295;

1.295
date	2011.11.15.03.23.56;	author mkuvyrkov;	state Exp;
branches;
next	1.294;

1.294
date	2011.10.24.13.58.47;	author macro;	state Exp;
branches;
next	1.293;

1.293
date	2011.09.30.10.39.45;	author gingold;	state Exp;
branches;
next	1.292;

1.292
date	2011.08.02.14.28.26;	author macro;	state Exp;
branches
	1.292.2.1;
next	1.291;

1.291
date	2011.07.29.22.56.57;	author macro;	state Exp;
branches;
next	1.290;

1.290
date	2011.07.29.22.52.21;	author macro;	state Exp;
branches;
next	1.289;

1.289
date	2011.07.29.22.46.27;	author macro;	state Exp;
branches;
next	1.288;

1.288
date	2011.07.24.14.20.06;	author rsandifo;	state Exp;
branches;
next	1.287;

1.287
date	2011.06.13.00.59.15;	author amodra;	state Exp;
branches;
next	1.286;

1.286
date	2011.06.09.10.36.20;	author nickc;	state Exp;
branches;
next	1.285;

1.285
date	2011.06.03.10.11.06;	author nickc;	state Exp;
branches;
next	1.284;

1.284
date	2011.05.15.18.52.00;	author rsandifo;	state Exp;
branches;
next	1.283;

1.283
date	2011.04.10.11.10.29;	author rsandifo;	state Exp;
branches;
next	1.282;

1.282
date	2011.01.22.10.16.28;	author rsandifo;	state Exp;
branches;
next	1.281;

1.281
date	2010.11.23.17.04.13;	author nickc;	state Exp;
branches;
next	1.280;

1.280
date	2010.11.11.10.23.35;	author nickc;	state Exp;
branches;
next	1.279;

1.279
date	2010.11.04.18.00.54;	author macro;	state Exp;
branches
	1.279.2.1;
next	1.278;

1.278
date	2010.10.29.21.28.31;	author macro;	state Exp;
branches;
next	1.277;

1.277
date	2010.10.25.15.54.16;	author drow;	state Exp;
branches;
next	1.276;

1.276
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches;
next	1.275;

1.275
date	2010.09.24.12.14.26;	author tschwinge;	state Exp;
branches;
next	1.274;

1.274
date	2010.09.19.10.52.17;	author rsandifo;	state Exp;
branches;
next	1.273;

1.273
date	2010.09.19.10.26.27;	author rsandifo;	state Exp;
branches;
next	1.272;

1.272
date	2010.09.19.10.07.30;	author rsandifo;	state Exp;
branches;
next	1.271;

1.271
date	2010.09.19.10.03.28;	author rsandifo;	state Exp;
branches;
next	1.270;

1.270
date	2010.08.25.14.53.45;	author hjl;	state Exp;
branches;
next	1.269;

1.269
date	2010.08.09.19.54.12;	author clm;	state Exp;
branches;
next	1.268;

1.268
date	2010.07.27.21.18.52;	author macro;	state Exp;
branches;
next	1.267;

1.267
date	2010.02.24.14.21.51;	author nickc;	state Exp;
branches;
next	1.266;

1.266
date	2010.02.04.09.16.41;	author nickc;	state Exp;
branches;
next	1.265;

1.265
date	2010.01.13.22.30.53;	author chaoyingfu;	state Exp;
branches;
next	1.264;

1.264
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.263;

1.263
date	2009.12.10.14.20.03;	author macro;	state Exp;
branches;
next	1.262;

1.262
date	2009.09.18.20.34.30;	author hjl;	state Exp;
branches;
next	1.261;

1.261
date	2009.09.18.07.54.45;	author nickc;	state Exp;
branches;
next	1.260;

1.260
date	2009.09.03.18.31.00;	author nemet;	state Exp;
branches;
next	1.259;

1.259
date	2009.09.03.18.21.21;	author nemet;	state Exp;
branches;
next	1.258;

1.258
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches;
next	1.257;

1.257
date	2009.08.05.21.17.51;	author chaoyingfu;	state Exp;
branches;
next	1.256;

1.256
date	2009.07.17.09.46.00;	author nickc;	state Exp;
branches;
next	1.255;

1.255
date	2009.05.21.14.15.49;	author amodra;	state Exp;
branches;
next	1.254;

1.254
date	2009.02.06.14.11.00;	author jsm28;	state Exp;
branches;
next	1.253;

1.253
date	2009.02.03.18.16.02;	author jsm28;	state Exp;
branches;
next	1.252;

1.252
date	2009.01.29.16.35.03;	author jsm28;	state Exp;
branches;
next	1.251;

1.251
date	2008.11.28.18.02.16;	author ths;	state Exp;
branches;
next	1.250;

1.250
date	2008.09.09.03.17.13;	author tromey;	state Exp;
branches;
next	1.249;

1.249
date	2008.08.18.18.14.04;	author rsandifo;	state Exp;
branches;
next	1.248;

1.248
date	2008.08.17.20.39.34;	author nickc;	state Exp;
branches;
next	1.247;

1.247
date	2008.08.08.19.24.48;	author drow;	state Exp;
branches;
next	1.246;

1.246
date	2008.08.07.20.03.25;	author rsandifo;	state Exp;
branches;
next	1.245;

1.245
date	2008.08.07.20.01.38;	author rsandifo;	state Exp;
branches;
next	1.244;

1.244
date	2008.08.07.20.01.14;	author rsandifo;	state Exp;
branches;
next	1.243;

1.243
date	2008.08.07.19.59.16;	author rsandifo;	state Exp;
branches;
next	1.242;

1.242
date	2008.08.07.19.58.38;	author rsandifo;	state Exp;
branches;
next	1.241;

1.241
date	2008.08.07.19.57.28;	author rsandifo;	state Exp;
branches;
next	1.240;

1.240
date	2008.08.07.19.50.05;	author rsandifo;	state Exp;
branches;
next	1.239;

1.239
date	2008.08.06.19.53.30;	author rsandifo;	state Exp;
branches;
next	1.238;

1.238
date	2008.08.06.19.51.29;	author rsandifo;	state Exp;
branches;
next	1.237;

1.237
date	2008.08.06.19.49.06;	author rsandifo;	state Exp;
branches;
next	1.236;

1.236
date	2008.08.06.19.44.47;	author rsandifo;	state Exp;
branches;
next	1.235;

1.235
date	2008.07.28.22.14.53;	author drow;	state Exp;
branches;
next	1.234;

1.234
date	2008.07.10.19.06.53;	author rsandifo;	state Exp;
branches;
next	1.233;

1.233
date	2008.07.10.19.05.28;	author rsandifo;	state Exp;
branches;
next	1.232;

1.232
date	2008.07.10.16.24.03;	author schwab;	state Exp;
branches;
next	1.231;

1.231
date	2008.07.10.01.32.22;	author csilvers;	state Exp;
branches;
next	1.230;

1.230
date	2008.04.21.17.54.24;	author nathan;	state Exp;
branches;
next	1.229;

1.229
date	2008.03.31.14.02.26;	author drow;	state Exp;
branches;
next	1.228;

1.228
date	2008.03.20.10.52.14;	author rsandifo;	state Exp;
branches;
next	1.227;

1.227
date	2008.02.27.17.06.06;	author clm;	state Exp;
branches;
next	1.226;

1.226
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.225;

1.225
date	2008.02.04.19.15.52;	author nemet;	state Exp;
branches;
next	1.224;

1.224
date	2008.01.11.09.07.04;	author gingold;	state Exp;
branches;
next	1.223;

1.223
date	2007.11.29.12.23.43;	author shinwell;	state Exp;
branches;
next	1.222;

1.222
date	2007.11.17.13.38.56;	author ths;	state Exp;
branches;
next	1.221;

1.221
date	2007.11.14.20.46.15;	author rsandifo;	state Exp;
branches;
next	1.220;

1.220
date	2007.11.14.20.04.22;	author ths;	state Exp;
branches;
next	1.219;

1.219
date	2007.11.08.13.51.06;	author nathan;	state Exp;
branches;
next	1.218;

1.218
date	2007.11.07.14.52.44;	author nickc;	state Exp;
branches;
next	1.217;

1.217
date	2007.10.25.11.38.30;	author jsm28;	state Exp;
branches;
next	1.216;

1.216
date	2007.10.12.15.59.19;	author drow;	state Exp;
branches;
next	1.215;

1.215
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.214;

1.214
date	2007.09.19.16.21.59;	author drow;	state Exp;
branches;
next	1.213;

1.213
date	2007.08.13.21.16.38;	author rsandifo;	state Exp;
branches;
next	1.212;

1.212
date	2007.07.22.16.45.06;	author nemet;	state Exp;
branches
	1.212.2.1;
next	1.211;

1.211
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.210;

1.210
date	2007.07.02.10.49.41;	author jsm28;	state Exp;
branches;
next	1.209;

1.209
date	2007.06.29.16.41.31;	author jsm28;	state Exp;
branches;
next	1.208;

1.208
date	2007.06.25.10.13.57;	author rsandifo;	state Exp;
branches;
next	1.207;

1.207
date	2007.05.31.20.22.56;	author rsandifo;	state Exp;
branches;
next	1.206;

1.206
date	2007.05.15.13.55.54;	author hjl;	state Exp;
branches;
next	1.205;

1.205
date	2007.05.15.12.18.53;	author rsandifo;	state Exp;
branches;
next	1.204;

1.204
date	2007.05.15.08.39.58;	author amodra;	state Exp;
branches;
next	1.203;

1.203
date	2007.04.28.22.31.45;	author ths;	state Exp;
branches;
next	1.202;

1.202
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.201;

1.201
date	2007.04.17.13.14.08;	author drow;	state Exp;
branches;
next	1.200;

1.200
date	2007.04.12.19.27.35;	author rsandifo;	state Exp;
branches;
next	1.199;

1.199
date	2007.04.12.19.26.08;	author rsandifo;	state Exp;
branches;
next	1.198;

1.198
date	2007.03.26.10.29.35;	author ths;	state Exp;
branches;
next	1.197;

1.197
date	2007.03.21.04.03.09;	author hjl;	state Exp;
branches;
next	1.196;

1.196
date	2007.03.07.08.54.35;	author amodra;	state Exp;
branches;
next	1.195;

1.195
date	2007.02.20.12.35.19;	author ths;	state Exp;
branches;
next	1.194;

1.194
date	2007.02.16.17.48.12;	author carlos;	state Exp;
branches;
next	1.193;

1.193
date	2007.01.29.16.29.21;	author jules;	state Exp;
branches;
next	1.192;

1.192
date	2006.11.03.00.58.10;	author drow;	state Exp;
branches;
next	1.191;

1.191
date	2006.11.02.15.20.31;	author ths;	state Exp;
branches;
next	1.190;

1.190
date	2006.11.01.16.07.46;	author drow;	state Exp;
branches;
next	1.189;

1.189
date	2006.10.20.07.59.44;	author rsandifo;	state Exp;
branches;
next	1.188;

1.188
date	2006.10.20.07.58.17;	author rsandifo;	state Exp;
branches;
next	1.187;

1.187
date	2006.10.20.07.57.02;	author rsandifo;	state Exp;
branches;
next	1.186;

1.186
date	2006.10.19.13.47.10;	author rsandifo;	state Exp;
branches;
next	1.185;

1.185
date	2006.10.19.13.42.17;	author rsandifo;	state Exp;
branches;
next	1.184;

1.184
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.183;

1.183
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.182;

1.182
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.181;

1.181
date	2006.08.15.18.28.47;	author ths;	state Exp;
branches;
next	1.180;

1.180
date	2006.08.14.12.19.20;	author ths;	state Exp;
branches;
next	1.179;

1.179
date	2006.08.11.13.55.38;	author ths;	state Exp;
branches;
next	1.178;

1.178
date	2006.07.25.09.17.56;	author ths;	state Exp;
branches;
next	1.177;

1.177
date	2006.07.25.09.06.05;	author ths;	state Exp;
branches;
next	1.176;

1.176
date	2006.07.25.09.01.02;	author ths;	state Exp;
branches;
next	1.175;

1.175
date	2006.07.18.08.56.44;	author nickc;	state Exp;
branches;
next	1.174;

1.174
date	2006.06.20.02.22.13;	author amodra;	state Exp;
branches;
next	1.173;

1.173
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.172;

1.172
date	2006.06.11.08.33.26;	author rsandifo;	state Exp;
branches;
next	1.171;

1.171
date	2006.06.09.13.47.41;	author ths;	state Exp;
branches;
next	1.170;

1.170
date	2006.06.08.23.51.25;	author daney;	state Exp;
branches;
next	1.169;

1.169
date	2006.05.22.15.06.22;	author drow;	state Exp;
branches;
next	1.168;

1.168
date	2006.05.04.19.03.24;	author drow;	state Exp;
branches;
next	1.167;

1.167
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.166;

1.166
date	2006.05.02.10.01.56;	author bje;	state Exp;
branches;
next	1.165;

1.165
date	2006.03.27.11.30.53;	author rsandifo;	state Exp;
branches
	1.165.4.1;
next	1.164;

1.164
date	2006.03.22.17.15.08;	author rsandifo;	state Exp;
branches;
next	1.163;

1.163
date	2006.03.22.09.28.13;	author rsandifo;	state Exp;
branches;
next	1.162;

1.162
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches
	1.162.2.1;
next	1.161;

1.161
date	2006.03.14.07.47.49;	author rsandifo;	state Exp;
branches;
next	1.160;

1.160
date	2006.03.13.19.14.23;	author rsandifo;	state Exp;
branches;
next	1.159;

1.159
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.158;

1.158
date	2006.02.04.08.29.58;	author rsandifo;	state Exp;
branches;
next	1.157;

1.157
date	2005.12.31.05.02.22;	author echristo;	state Exp;
branches;
next	1.156;

1.156
date	2005.12.23.12.29.36;	author nickc;	state Exp;
branches;
next	1.155;

1.155
date	2005.11.23.14.04.17;	author drow;	state Exp;
branches;
next	1.154;

1.154
date	2005.11.11.11.06.33;	author nickc;	state Exp;
branches;
next	1.153;

1.153
date	2005.11.03.11.45.14;	author ths;	state Exp;
branches;
next	1.152;

1.152
date	2005.10.25.16.19.08;	author amodra;	state Exp;
branches;
next	1.151;

1.151
date	2005.10.06.19.21.14;	author drow;	state Exp;
branches;
next	1.150;

1.150
date	2005.08.29.16.42.15;	author nickc;	state Exp;
branches;
next	1.149;

1.149
date	2005.08.17.10.04.26;	author amodra;	state Exp;
branches;
next	1.148;

1.148
date	2005.08.01.11.59.31;	author rsandifo;	state Exp;
branches;
next	1.147;

1.147
date	2005.07.29.23.24.01;	author daney;	state Exp;
branches;
next	1.146;

1.146
date	2005.07.08.06.20.05;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2005.07.08.00.26.53;	author hjl;	state Exp;
branches;
next	1.144;

1.144
date	2005.07.05.06.23.37;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2005.07.04.01.53.40;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2005.06.20.18.12.10;	author hjl;	state Exp;
branches;
next	1.141;

1.141
date	2005.05.28.22.00.27;	author drow;	state Exp;
branches;
next	1.140;

1.140
date	2005.05.26.18.51.11;	author macro;	state Exp;
branches;
next	1.139;

1.139
date	2005.05.23.17.44.54;	author fnf;	state Exp;
branches;
next	1.138;

1.138
date	2005.05.07.13.22.55;	author hjl;	state Exp;
branches;
next	1.137;

1.137
date	2005.05.05.14.34.03;	author hjl;	state Exp;
branches;
next	1.136;

1.136
date	2005.05.04.15.53.31;	author nickc;	state Exp;
branches;
next	1.135;

1.135
date	2005.05.04.11.00.22;	author amodra;	state Exp;
branches;
next	1.134;

1.134
date	2005.05.04.07.19.26;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	2005.05.03.01.05.02;	author hjl;	state Exp;
branches;
next	1.132;

1.132
date	2005.04.19.18.33.20;	author drow;	state Exp;
branches;
next	1.131;

1.131
date	2005.04.05.07.35.12;	author rsandifo;	state Exp;
branches;
next	1.130;

1.130
date	2005.04.05.06.58.46;	author echristo;	state Exp;
branches;
next	1.129;

1.129
date	2005.03.24.22.47.51;	author echristo;	state Exp;
branches;
next	1.128;

1.128
date	2005.03.24.01.30.44;	author echristo;	state Exp;
branches;
next	1.127;

1.127
date	2005.03.20.23.36.19;	author hjl;	state Exp;
branches;
next	1.126;

1.126
date	2005.03.05.00.01.33;	author ths;	state Exp;
branches
	1.126.2.1;
next	1.125;

1.125
date	2005.03.02.21.23.20;	author drow;	state Exp;
branches;
next	1.124;

1.124
date	2005.02.23.11.39.14;	author nickc;	state Exp;
branches;
next	1.123;

1.123
date	2005.02.21.13.57.55;	author ths;	state Exp;
branches;
next	1.122;

1.122
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2005.02.16.04.45.23;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2005.02.15.19.57.48;	author macro;	state Exp;
branches;
next	1.119;

1.119
date	2005.02.01.01.11.15;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2005.01.31.20.39.09;	author rsandifo;	state Exp;
branches;
next	1.117;

1.117
date	2004.12.14.09.48.10;	author rsandifo;	state Exp;
branches;
next	1.116;

1.116
date	2004.12.09.07.12.28;	author ian;	state Exp;
branches;
next	1.115;

1.115
date	2004.12.09.06.08.45;	author ian;	state Exp;
branches;
next	1.114;

1.114
date	2004.12.08.20.27.50;	author ian;	state Exp;
branches;
next	1.113;

1.113
date	2004.11.16.09.54.10;	author rsandifo;	state Exp;
branches;
next	1.112;

1.112
date	2004.10.21.15.28.29;	author hjl;	state Exp;
branches;
next	1.111;

1.111
date	2004.09.17.07.14.30;	author amodra;	state Exp;
branches;
next	1.110;

1.110
date	2004.09.16.14.52.08;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2004.08.13.03.15.59;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2004.08.01.20.13.16;	author ths;	state Exp;
branches;
next	1.107;

1.107
date	2004.07.30.23.56.04;	author ths;	state Exp;
branches;
next	1.106;

1.106
date	2004.07.01.14.53.40;	author nickc;	state Exp;
branches
	1.106.2.1;
next	1.105;

1.105
date	2004.06.29.13.46.34;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2004.06.24.04.46.23;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2004.06.15.01.24.22;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2004.06.14.18.25.09;	author cgd;	state Exp;
branches;
next	1.101;

1.101
date	2004.05.15.18.58.05;	author ths;	state Exp;
branches;
next	1.100;

1.100
date	2004.04.24.22.07.13;	author cgd;	state Exp;
branches;
next	1.99;

1.99
date	2004.04.24.06.12.24;	author cgd;	state Exp;
branches;
next	1.98;

1.98
date	2004.04.24.00.15.32;	author cgd;	state Exp;
branches;
next	1.97;

1.97
date	2004.04.06.15.48.50;	author drow;	state Exp;
branches;
next	1.96;

1.96
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2004.03.26.06.13.40;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2004.03.25.12.48.42;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2004.03.20.23.16.42;	author hjl;	state Exp;
branches;
next	1.92;

1.92
date	2004.03.17.12.27.05;	author nathan;	state Exp;
branches;
next	1.91;

1.91
date	2004.03.05.23.50.54;	author fnf;	state Exp;
branches
	1.91.2.1;
next	1.90;

1.90
date	2004.02.17.10.19.23;	author rsandifo;	state Exp;
branches
	1.90.2.1
	1.90.4.1;
next	1.89;

1.89
date	2004.02.09.08.04.00;	author rsandifo;	state Exp;
branches;
next	1.88;

1.88
date	2003.12.18.10.23.07;	author rsandifo;	state Exp;
branches;
next	1.87;

1.87
date	2003.12.08.20.04.34;	author rsandifo;	state Exp;
branches;
next	1.86;

1.86
date	2003.12.08.13.05.10;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2003.11.27.18.49.39;	author kazu;	state Exp;
branches;
next	1.84;

1.84
date	2003.11.27.16.43.24;	author aoliva;	state Exp;
branches;
next	1.83;

1.83
date	2003.11.26.20.58.45;	author rsandifo;	state Exp;
branches;
next	1.82;

1.82
date	2003.11.14.16.05.13;	author drow;	state Exp;
branches;
next	1.81;

1.81
date	2003.11.11.13.32.38;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2003.11.04.10.41.51;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2003.10.24.15.18.29;	author rsandifo;	state Exp;
branches;
next	1.78;

1.78
date	2003.10.13.19.51.09;	author rsandifo;	state Exp;
branches;
next	1.77;

1.77
date	2003.10.08.17.36.19;	author ths;	state Exp;
branches;
next	1.76;

1.76
date	2003.09.30.16.17.11;	author cgd;	state Exp;
branches;
next	1.75;

1.75
date	2003.09.23.00.40.49;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2003.08.20.08.37.19;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2003.08.14.09.30.34;	author rsandifo;	state Exp;
branches;
next	1.72;

1.72
date	2003.08.07.08.38.10;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2003.07.25.14.35.56;	author hjl;	state Exp;
branches;
next	1.70;

1.70
date	2003.07.15.07.50.37;	author rsandifo;	state Exp;
branches;
next	1.69;

1.69
date	2003.07.09.11.55.49;	author rsandifo;	state Exp;
branches;
next	1.68;

1.68
date	2003.07.09.11.53.36;	author rsandifo;	state Exp;
branches;
next	1.67;

1.67
date	2003.07.09.11.52.52;	author rsandifo;	state Exp;
branches;
next	1.66;

1.66
date	2003.07.09.11.51.53;	author rsandifo;	state Exp;
branches;
next	1.65;

1.65
date	2003.07.09.11.50.16;	author rsandifo;	state Exp;
branches;
next	1.64;

1.64
date	2003.07.09.11.48.17;	author rsandifo;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.28.22.13.37;	author ths;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.27.07.32.33;	author ths;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.27.01.16.29;	author ths;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.25.06.40.24;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.11.21.01.48;	author ths;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.11.16.22.25;	author ths;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.30.19.13.36;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.29.02.28.32;	author ths;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.27.08.04.12;	author rsandifo;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.21.21.53.32;	author echristo;	state Exp;
branches;
next	1.53;

1.53
date	2003.05.09.02.27.09;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.07.05.09.25;	author aoliva;	state Exp;
branches;
next	1.51;

1.51
date	2003.04.12.08.50.28;	author aoliva;	state Exp;
branches
	1.51.2.1
	1.51.4.1;
next	1.50;

1.50
date	2003.04.12.00.31.42;	author aoliva;	state Exp;
branches;
next	1.49;

1.49
date	2003.04.11.01.56.49;	author aoliva;	state Exp;
branches;
next	1.48;

1.48
date	2003.04.01.23.44.45;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2003.03.26.01.04.22;	author aoliva;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.12.23.05.51;	author aoliva;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.11.19.11.38;	author aoliva;	state Exp;
branches;
next	1.44;

1.44
date	2003.03.02.21.30.14;	author ths;	state Exp;
branches
	1.44.4.1;
next	1.43;

1.43
date	2003.02.17.18.24.40;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.29.08.29.34;	author aoliva;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.28.00.18.45;	author aoliva;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.28.00.01.27;	author aoliva;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.23.11.51.33;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.02.21.31.31;	author rsandifo;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.31.07.29.25;	author cgd;	state Exp;
branches;
next	1.35;

1.35
date	2002.12.12.04.42.06;	author aoliva;	state Exp;
branches;
next	1.34;

1.34
date	2002.12.12.02.55.41;	author aoliva;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.28.11.55.43;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.19.20.52.32;	author aoliva;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.19.20.50.43;	author aoliva;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.22.22.17.11;	author aoliva;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.22.21.00.10;	author aoliva;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.13.21.22.31;	author aoliva;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.10.05.11.18.13;	author aoliva;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.30.11.53.56;	author rsandifo;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.09.26.09.10.57;	author ths;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.18.01.38.20;	author scox;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2002.08.22.01.27.20;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.17.15.31.29;	author scox;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.09.05.35.26;	author ths;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.07.04.44.14;	author ths;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.07.04.37.24;	author ths;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.26.18.56.24;	author rsandifo;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.19.21.34.02;	author ths;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.07.09.10.40;	author amodra;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2002.07.01.10.01.01;	author ths;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.01.08.06.46;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.25.06.21.53;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.07.23.43.41;	author ths;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.05.10.31.47;	author macro;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.05.06.50.16;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.04.00.51.08;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.03.18.42.54;	author macro;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.14.23.23.59;	author ths;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.05.03.19.53.20;	author hjl;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2002.04.24.18.49.00;	author cgd;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.04.07.09.59;	author ths;	state Exp;
branches;
next	;

1.359.2.1
date	2013.10.05.09.13.24;	author rsandifo;	state Exp;
branches;
next	;

1.309.2.1
date	2012.09.04.14.37.53;	author gingold;	state Exp;
branches;
next	1.309.2.2;

1.309.2.2
date	2013.02.11.17.23.02;	author rsandifo;	state Exp;
branches;
next	;

1.292.2.1
date	2011.11.16.01.05.00;	author mkuvyrkov;	state Exp;
branches;
next	1.292.2.2;

1.292.2.2
date	2011.12.11.02.28.11;	author daney;	state Exp;
branches;
next	1.292.2.3;

1.292.2.3
date	2011.12.19.10.34.16;	author cltang;	state Exp;
branches;
next	1.292.2.4;

1.292.2.4
date	2011.12.19.10.39.27;	author cltang;	state Exp;
branches;
next	1.292.2.5;

1.292.2.5
date	2011.12.19.10.49.25;	author cltang;	state Exp;
branches;
next	1.292.2.6;

1.292.2.6
date	2012.05.11.12.24.31;	author nickc;	state Exp;
branches;
next	;

1.279.2.1
date	2011.02.01.12.25.34;	author amodra;	state Exp;
branches;
next	1.279.2.2;

1.279.2.2
date	2011.05.15.19.04.20;	author rsandifo;	state Exp;
branches;
next	1.279.2.3;

1.279.2.3
date	2011.05.15.19.04.55;	author rsandifo;	state Exp;
branches;
next	;

1.212.2.1
date	2007.08.20.12.49.30;	author rsandifo;	state Exp;
branches;
next	1.212.2.2;

1.212.2.2
date	2007.10.25.15.36.50;	author jsm28;	state Exp;
branches;
next	1.212.2.3;

1.212.2.3
date	2007.10.26.17.58.52;	author drow;	state Exp;
branches;
next	;

1.165.4.1
date	2006.05.22.15.07.06;	author drow;	state Exp;
branches;
next	1.165.4.2;

1.165.4.2
date	2006.06.09.03.39.13;	author daney;	state Exp;
branches;
next	1.165.4.3;

1.165.4.3
date	2006.06.11.08.38.29;	author rsandifo;	state Exp;
branches;
next	;

1.162.2.1
date	2006.07.28.17.26.04;	author carlos;	state Exp;
branches;
next	1.162.2.2;

1.162.2.2
date	2006.08.22.15.08.29;	author jsm28;	state Exp;
branches;
next	;

1.126.2.1
date	2005.04.05.07.36.56;	author rsandifo;	state Exp;
branches;
next	1.126.2.2;

1.126.2.2
date	2005.04.19.18.37.25;	author drow;	state Exp;
branches;
next	1.126.2.3;

1.126.2.3
date	2005.05.26.18.51.37;	author macro;	state Exp;
branches;
next	1.126.2.4;

1.126.2.4
date	2005.05.28.21.59.37;	author drow;	state Exp;
branches;
next	;

1.106.2.1
date	2004.07.31.00.14.49;	author brobecke;	state Exp;
branches;
next	;

1.91.2.1
date	2004.03.21.23.57.28;	author cagney;	state Exp;
branches;
next	;

1.90.2.1
date	2004.04.08.12.41.46;	author amodra;	state Exp;
branches;
next	1.90.2.2;

1.90.2.2
date	2004.04.09.18.28.02;	author drow;	state Exp;
branches;
next	;

1.90.4.1
date	2004.03.27.17.37.36;	author drow;	state Exp;
branches;
next	1.90.4.2;

1.90.4.2
date	2004.04.02.16.47.37;	author drow;	state Exp;
branches;
next	1.90.4.3;

1.90.4.3
date	2004.09.16.17.00.33;	author drow;	state Exp;
branches;
next	1.90.4.4;

1.90.4.4
date	2004.09.21.20.44.04;	author drow;	state Exp;
branches;
next	;

1.51.2.1
date	2003.05.18.09.43.49;	author kettenis;	state Exp;
branches;
next	;

1.51.4.1
date	2003.05.15.19.20.23;	author drow;	state Exp;
branches;
next	1.51.4.2;

1.51.4.2
date	2003.05.29.01.10.14;	author ths;	state Exp;
branches;
next	1.51.4.3;

1.51.4.3
date	2003.05.30.20.13.05;	author drow;	state Exp;
branches;
next	;

1.44.4.1
date	2003.03.16.14.01.43;	author kettenis;	state Exp;
branches;
next	;

1.24.2.1
date	2002.10.26.17.12.00;	author drow;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2003.12.14.20.26.45;	author drow;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2003.12.20.18.16.46;	author drow;	state Exp;
branches;
next	;

1.22.2.1
date	2002.09.27.20.02.56;	author carlton;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.10.11.22.22.49;	author carlton;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.10.25.23.49.49;	author carlton;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2002.12.23.19.37.51;	author carlton;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2003.02.07.19.17.40;	author carlton;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2003.03.06.00.56.18;	author carlton;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2003.04.16.19.56.46;	author carlton;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2003.05.23.18.40.28;	author carlton;	state Exp;
branches;
next	1.22.2.9;

1.22.2.9
date	2003.06.27.21.49.27;	author carlton;	state Exp;
branches;
next	1.22.2.10;

1.22.2.10
date	2003.08.05.17.12.54;	author carlton;	state Exp;
branches;
next	1.22.2.11;

1.22.2.11
date	2003.09.17.21.27.57;	author carlton;	state Exp;
branches;
next	1.22.2.12;

1.22.2.12
date	2003.11.11.23.50.26;	author carlton;	state Exp;
branches;
next	1.22.2.13;

1.22.2.13
date	2003.12.15.23.59.48;	author carlton;	state Exp;
branches;
next	1.22.2.14;

1.22.2.14
date	2004.01.26.19.11.09;	author carlton;	state Exp;
branches;
next	;

1.14.2.1
date	2002.07.30.18.19.42;	author drow;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.08.22.01.34.16;	author amodra;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.09.23.22.12.41;	author drow;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2002.10.11.08.56.14;	author amodra;	state Exp;
branches;
next	1.14.2.5;

1.14.2.5
date	2002.10.28.18.45.45;	author drow;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.20.01.30.52;	author kseitz;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.07.22.21.46.47;	author kseitz;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.08.09.18.34.17;	author kseitz;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2002.08.30.22.52.38;	author kseitz;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2002.10.01.00.45.49;	author kseitz;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2002.11.03.22.01.37;	author ezannoni;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.15.16.42.39;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.362
log
@2013-10-14  Chao-ying Fu  <Chao-ying.Fu@@imgtec.com>

	* elfxx-mips.c (mips_elf_obj_tdata): Add abi_msa_bfd.
	(mips_elf_merge_obj_attributes): Set abi_msa_bfd to the first object
	file that has a Tag_GNU_MIPS_ABI_MSA attribute.
	Merge Tag_GNU_MIPS_ABI_MSA attributes.
@
text
@/* MIPS-specific support for ELF
   Copyright 1993-2013 Free Software Foundation, Inc.

   Most of the information added by Ian Lance Taylor, Cygnus Support,
   <ian@@cygnus.com>.
   N32/64 ABI support added by Mark Mitchell, CodeSourcery, LLC.
   <mark@@codesourcery.com>
   Traditional MIPS targets support added by Koundinya.K, Dansk Data
   Elektronik & Operations Research Group. <kk@@ddeorg.soft.net>

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* This file handles functionality common to the different MIPS ABI's.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "libiberty.h"
#include "elf-bfd.h"
#include "elfxx-mips.h"
#include "elf/mips.h"
#include "elf-vxworks.h"

/* Get the ECOFF swapping routines.  */
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/ecoff.h"
#include "coff/mips.h"

#include "hashtab.h"

/* Types of TLS GOT entry.  */
enum mips_got_tls_type {
  GOT_TLS_NONE,
  GOT_TLS_GD,
  GOT_TLS_LDM,
  GOT_TLS_IE
};

/* This structure is used to hold information about one GOT entry.
   There are four types of entry:

      (1) an absolute address
	    requires: abfd == NULL
	    fields: d.address

      (2) a SYMBOL + OFFSET address, where SYMBOL is local to an input bfd
	    requires: abfd != NULL, symndx >= 0, tls_type != GOT_TLS_LDM
	    fields: abfd, symndx, d.addend, tls_type

      (3) a SYMBOL address, where SYMBOL is not local to an input bfd
	    requires: abfd != NULL, symndx == -1
	    fields: d.h, tls_type

      (4) a TLS LDM slot
	    requires: abfd != NULL, symndx == 0, tls_type == GOT_TLS_LDM
	    fields: none; there's only one of these per GOT.  */
struct mips_got_entry
{
  /* One input bfd that needs the GOT entry.  */
  bfd *abfd;
  /* The index of the symbol, as stored in the relocation r_info, if
     we have a local symbol; -1 otherwise.  */
  long symndx;
  union
  {
    /* If abfd == NULL, an address that must be stored in the got.  */
    bfd_vma address;
    /* If abfd != NULL && symndx != -1, the addend of the relocation
       that should be added to the symbol value.  */
    bfd_vma addend;
    /* If abfd != NULL && symndx == -1, the hash table entry
       corresponding to a symbol in the GOT.  The symbol's entry
       is in the local area if h->global_got_area is GGA_NONE,
       otherwise it is in the global area.  */
    struct mips_elf_link_hash_entry *h;
  } d;

  /* The TLS type of this GOT entry.  An LDM GOT entry will be a local
     symbol entry with r_symndx == 0.  */
  unsigned char tls_type;

  /* True if we have filled in the GOT contents for a TLS entry,
     and created the associated relocations.  */
  unsigned char tls_initialized;

  /* The offset from the beginning of the .got section to the entry
     corresponding to this symbol+addend.  If it's a global symbol
     whose offset is yet to be decided, it's going to be -1.  */
  long gotidx;
};

/* This structure represents a GOT page reference from an input bfd.
   Each instance represents a symbol + ADDEND, where the representation
   of the symbol depends on whether it is local to the input bfd.
   If it is, then SYMNDX >= 0, and the symbol has index SYMNDX in U.ABFD.
   Otherwise, SYMNDX < 0 and U.H points to the symbol's hash table entry.

   Page references with SYMNDX >= 0 always become page references
   in the output.  Page references with SYMNDX < 0 only become page
   references if the symbol binds locally; in other cases, the page
   reference decays to a global GOT reference.  */
struct mips_got_page_ref
{
  long symndx;
  union
  {
    struct mips_elf_link_hash_entry *h;
    bfd *abfd;
  } u;
  bfd_vma addend;
};

/* This structure describes a range of addends: [MIN_ADDEND, MAX_ADDEND].
   The structures form a non-overlapping list that is sorted by increasing
   MIN_ADDEND.  */
struct mips_got_page_range
{
  struct mips_got_page_range *next;
  bfd_signed_vma min_addend;
  bfd_signed_vma max_addend;
};

/* This structure describes the range of addends that are applied to page
   relocations against a given section.  */
struct mips_got_page_entry
{
  /* The section that these entries are based on.  */
  asection *sec;
  /* The ranges for this page entry.  */
  struct mips_got_page_range *ranges;
  /* The maximum number of page entries needed for RANGES.  */
  bfd_vma num_pages;
};

/* This structure is used to hold .got information when linking.  */

struct mips_got_info
{
  /* The number of global .got entries.  */
  unsigned int global_gotno;
  /* The number of global .got entries that are in the GGA_RELOC_ONLY area.  */
  unsigned int reloc_only_gotno;
  /* The number of .got slots used for TLS.  */
  unsigned int tls_gotno;
  /* The first unused TLS .got entry.  Used only during
     mips_elf_initialize_tls_index.  */
  unsigned int tls_assigned_gotno;
  /* The number of local .got entries, eventually including page entries.  */
  unsigned int local_gotno;
  /* The maximum number of page entries needed.  */
  unsigned int page_gotno;
  /* The number of relocations needed for the GOT entries.  */
  unsigned int relocs;
  /* The number of local .got entries we have used.  */
  unsigned int assigned_gotno;
  /* A hash table holding members of the got.  */
  struct htab *got_entries;
  /* A hash table holding mips_got_page_ref structures.  */
  struct htab *got_page_refs;
  /* A hash table of mips_got_page_entry structures.  */
  struct htab *got_page_entries;
  /* In multi-got links, a pointer to the next got (err, rather, most
     of the time, it points to the previous got).  */
  struct mips_got_info *next;
};

/* Structure passed when merging bfds' gots.  */

struct mips_elf_got_per_bfd_arg
{
  /* The output bfd.  */
  bfd *obfd;
  /* The link information.  */
  struct bfd_link_info *info;
  /* A pointer to the primary got, i.e., the one that's going to get
     the implicit relocations from DT_MIPS_LOCAL_GOTNO and
     DT_MIPS_GOTSYM.  */
  struct mips_got_info *primary;
  /* A non-primary got we're trying to merge with other input bfd's
     gots.  */
  struct mips_got_info *current;
  /* The maximum number of got entries that can be addressed with a
     16-bit offset.  */
  unsigned int max_count;
  /* The maximum number of page entries needed by each got.  */
  unsigned int max_pages;
  /* The total number of global entries which will live in the
     primary got and be automatically relocated.  This includes
     those not referenced by the primary GOT but included in
     the "master" GOT.  */
  unsigned int global_count;
};

/* A structure used to pass information to htab_traverse callbacks
   when laying out the GOT.  */

struct mips_elf_traverse_got_arg
{
  struct bfd_link_info *info;
  struct mips_got_info *g;
  int value;
};

struct _mips_elf_section_data
{
  struct bfd_elf_section_data elf;
  union
  {
    bfd_byte *tdata;
  } u;
};

#define mips_elf_section_data(sec) \
  ((struct _mips_elf_section_data *) elf_section_data (sec))

#define is_mips_elf(bfd)				\
  (bfd_get_flavour (bfd) == bfd_target_elf_flavour	\
   && elf_tdata (bfd) != NULL				\
   && elf_object_id (bfd) == MIPS_ELF_DATA)

/* The ABI says that every symbol used by dynamic relocations must have
   a global GOT entry.  Among other things, this provides the dynamic
   linker with a free, directly-indexed cache.  The GOT can therefore
   contain symbols that are not referenced by GOT relocations themselves
   (in other words, it may have symbols that are not referenced by things
   like R_MIPS_GOT16 and R_MIPS_GOT_PAGE).

   GOT relocations are less likely to overflow if we put the associated
   GOT entries towards the beginning.  We therefore divide the global
   GOT entries into two areas: "normal" and "reloc-only".  Entries in
   the first area can be used for both dynamic relocations and GP-relative
   accesses, while those in the "reloc-only" area are for dynamic
   relocations only.

   These GGA_* ("Global GOT Area") values are organised so that lower
   values are more general than higher values.  Also, non-GGA_NONE
   values are ordered by the position of the area in the GOT.  */
#define GGA_NORMAL 0
#define GGA_RELOC_ONLY 1
#define GGA_NONE 2

/* Information about a non-PIC interface to a PIC function.  There are
   two ways of creating these interfaces.  The first is to add:

	lui	$25,%hi(func)
	addiu	$25,$25,%lo(func)

   immediately before a PIC function "func".  The second is to add:

	lui	$25,%hi(func)
	j	func
	addiu	$25,$25,%lo(func)

   to a separate trampoline section.

   Stubs of the first kind go in a new section immediately before the
   target function.  Stubs of the second kind go in a single section
   pointed to by the hash table's "strampoline" field.  */
struct mips_elf_la25_stub {
  /* The generated section that contains this stub.  */
  asection *stub_section;

  /* The offset of the stub from the start of STUB_SECTION.  */
  bfd_vma offset;

  /* One symbol for the original function.  Its location is available
     in H->root.root.u.def.  */
  struct mips_elf_link_hash_entry *h;
};

/* Macros for populating a mips_elf_la25_stub.  */

#define LA25_LUI(VAL) (0x3c190000 | (VAL))	/* lui t9,VAL */
#define LA25_J(VAL) (0x08000000 | (((VAL) >> 2) & 0x3ffffff)) /* j VAL */
#define LA25_ADDIU(VAL) (0x27390000 | (VAL))	/* addiu t9,t9,VAL */
#define LA25_LUI_MICROMIPS(VAL)						\
  (0x41b90000 | (VAL))				/* lui t9,VAL */
#define LA25_J_MICROMIPS(VAL)						\
  (0xd4000000 | (((VAL) >> 1) & 0x3ffffff))	/* j VAL */
#define LA25_ADDIU_MICROMIPS(VAL)					\
  (0x33390000 | (VAL))				/* addiu t9,t9,VAL */

/* This structure is passed to mips_elf_sort_hash_table_f when sorting
   the dynamic symbols.  */

struct mips_elf_hash_sort_data
{
  /* The symbol in the global GOT with the lowest dynamic symbol table
     index.  */
  struct elf_link_hash_entry *low;
  /* The least dynamic symbol table index corresponding to a non-TLS
     symbol with a GOT entry.  */
  long min_got_dynindx;
  /* The greatest dynamic symbol table index corresponding to a symbol
     with a GOT entry that is not referenced (e.g., a dynamic symbol
     with dynamic relocations pointing to it from non-primary GOTs).  */
  long max_unref_got_dynindx;
  /* The greatest dynamic symbol table index not corresponding to a
     symbol without a GOT entry.  */
  long max_non_got_dynindx;
};

/* We make up to two PLT entries if needed, one for standard MIPS code
   and one for compressed code, either a MIPS16 or microMIPS one.  We
   keep a separate record of traditional lazy-binding stubs, for easier
   processing.  */

struct plt_entry
{
  /* Traditional SVR4 stub offset, or -1 if none.  */
  bfd_vma stub_offset;

  /* Standard PLT entry offset, or -1 if none.  */
  bfd_vma mips_offset;

  /* Compressed PLT entry offset, or -1 if none.  */
  bfd_vma comp_offset;

  /* The corresponding .got.plt index, or -1 if none.  */
  bfd_vma gotplt_index;

  /* Whether we need a standard PLT entry.  */
  unsigned int need_mips : 1;

  /* Whether we need a compressed PLT entry.  */
  unsigned int need_comp : 1;
};

/* The MIPS ELF linker needs additional information for each symbol in
   the global hash table.  */

struct mips_elf_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* External symbol information.  */
  EXTR esym;

  /* The la25 stub we have created for ths symbol, if any.  */
  struct mips_elf_la25_stub *la25_stub;

  /* Number of R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 relocs against
     this symbol.  */
  unsigned int possibly_dynamic_relocs;

  /* If there is a stub that 32 bit functions should use to call this
     16 bit function, this points to the section containing the stub.  */
  asection *fn_stub;

  /* If there is a stub that 16 bit functions should use to call this
     32 bit function, this points to the section containing the stub.  */
  asection *call_stub;

  /* This is like the call_stub field, but it is used if the function
     being called returns a floating point value.  */
  asection *call_fp_stub;

  /* The highest GGA_* value that satisfies all references to this symbol.  */
  unsigned int global_got_area : 2;

  /* True if all GOT relocations against this symbol are for calls.  This is
     a looser condition than no_fn_stub below, because there may be other
     non-call non-GOT relocations against the symbol.  */
  unsigned int got_only_for_calls : 1;

  /* True if one of the relocations described by possibly_dynamic_relocs
     is against a readonly section.  */
  unsigned int readonly_reloc : 1;

  /* True if there is a relocation against this symbol that must be
     resolved by the static linker (in other words, if the relocation
     cannot possibly be made dynamic).  */
  unsigned int has_static_relocs : 1;

  /* True if we must not create a .MIPS.stubs entry for this symbol.
     This is set, for example, if there are relocations related to
     taking the function's address, i.e. any but R_MIPS_CALL*16 ones.
     See "MIPS ABI Supplement, 3rd Edition", p. 4-20.  */
  unsigned int no_fn_stub : 1;

  /* Whether we need the fn_stub; this is true if this symbol appears
     in any relocs other than a 16 bit call.  */
  unsigned int need_fn_stub : 1;

  /* True if this symbol is referenced by branch relocations from
     any non-PIC input file.  This is used to determine whether an
     la25 stub is required.  */
  unsigned int has_nonpic_branches : 1;

  /* Does this symbol need a traditional MIPS lazy-binding stub
     (as opposed to a PLT entry)?  */
  unsigned int needs_lazy_stub : 1;

  /* Does this symbol resolve to a PLT entry?  */
  unsigned int use_plt_entry : 1;
};

/* MIPS ELF linker hash table.  */

struct mips_elf_link_hash_table
{
  struct elf_link_hash_table root;

  /* The number of .rtproc entries.  */
  bfd_size_type procedure_count;

  /* The size of the .compact_rel section (if SGI_COMPAT).  */
  bfd_size_type compact_rel_size;

  /* This flag indicates that the value of DT_MIPS_RLD_MAP dynamic entry
     is set to the address of __rld_obj_head as in IRIX5 and IRIX6.  */
  bfd_boolean use_rld_obj_head;

  /* The  __rld_map or __rld_obj_head symbol. */
  struct elf_link_hash_entry *rld_symbol;

  /* This is set if we see any mips16 stub sections.  */
  bfd_boolean mips16_stubs_seen;

  /* True if we can generate copy relocs and PLTs.  */
  bfd_boolean use_plts_and_copy_relocs;

  /* True if we can only use 32-bit microMIPS instructions.  */
  bfd_boolean insn32;

  /* True if we're generating code for VxWorks.  */
  bfd_boolean is_vxworks;

  /* True if we already reported the small-data section overflow.  */
  bfd_boolean small_data_overflow_reported;

  /* Shortcuts to some dynamic sections, or NULL if they are not
     being used.  */
  asection *srelbss;
  asection *sdynbss;
  asection *srelplt;
  asection *srelplt2;
  asection *sgotplt;
  asection *splt;
  asection *sstubs;
  asection *sgot;

  /* The master GOT information.  */
  struct mips_got_info *got_info;

  /* The global symbol in the GOT with the lowest index in the dynamic
     symbol table.  */
  struct elf_link_hash_entry *global_gotsym;

  /* The size of the PLT header in bytes.  */
  bfd_vma plt_header_size;

  /* The size of a standard PLT entry in bytes.  */
  bfd_vma plt_mips_entry_size;

  /* The size of a compressed PLT entry in bytes.  */
  bfd_vma plt_comp_entry_size;

  /* The offset of the next standard PLT entry to create.  */
  bfd_vma plt_mips_offset;

  /* The offset of the next compressed PLT entry to create.  */
  bfd_vma plt_comp_offset;

  /* The index of the next .got.plt entry to create.  */
  bfd_vma plt_got_index;

  /* The number of functions that need a lazy-binding stub.  */
  bfd_vma lazy_stub_count;

  /* The size of a function stub entry in bytes.  */
  bfd_vma function_stub_size;

  /* The number of reserved entries at the beginning of the GOT.  */
  unsigned int reserved_gotno;

  /* The section used for mips_elf_la25_stub trampolines.
     See the comment above that structure for details.  */
  asection *strampoline;

  /* A table of mips_elf_la25_stubs, indexed by (input_section, offset)
     pairs.  */
  htab_t la25_stubs;

  /* A function FN (NAME, IS, OS) that creates a new input section
     called NAME and links it to output section OS.  If IS is nonnull,
     the new section should go immediately before it, otherwise it
     should go at the (current) beginning of OS.

     The function returns the new section on success, otherwise it
     returns null.  */
  asection *(*add_stub_section) (const char *, asection *, asection *);

  /* Small local sym cache.  */
  struct sym_cache sym_cache;

  /* Is the PLT header compressed?  */
  unsigned int plt_header_is_comp : 1;
};

/* Get the MIPS ELF linker hash table from a link_info structure.  */

#define mips_elf_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == MIPS_ELF_DATA ? ((struct mips_elf_link_hash_table *) ((p)->hash)) : NULL)

/* A structure used to communicate with htab_traverse callbacks.  */
struct mips_htab_traverse_info
{
  /* The usual link-wide information.  */
  struct bfd_link_info *info;
  bfd *output_bfd;

  /* Starts off FALSE and is set to TRUE if the link should be aborted.  */
  bfd_boolean error;
};

/* MIPS ELF private object data.  */

struct mips_elf_obj_tdata
{
  /* Generic ELF private object data.  */
  struct elf_obj_tdata root;

  /* Input BFD providing Tag_GNU_MIPS_ABI_FP attribute for output.  */
  bfd *abi_fp_bfd;

  /* Input BFD providing Tag_GNU_MIPS_ABI_MSA attribute for output.  */
  bfd *abi_msa_bfd;

  /* The GOT requirements of input bfds.  */
  struct mips_got_info *got;

  /* Used by _bfd_mips_elf_find_nearest_line.  The structure could be
     included directly in this one, but there's no point to wasting
     the memory just for the infrequently called find_nearest_line.  */
  struct mips_elf_find_line *find_line_info;

  /* An array of stub sections indexed by symbol number.  */
  asection **local_stubs;
  asection **local_call_stubs;

  /* The Irix 5 support uses two virtual sections, which represent
     text/data symbols defined in dynamic objects.  */
  asymbol *elf_data_symbol;
  asymbol *elf_text_symbol;
  asection *elf_data_section;
  asection *elf_text_section;
};

/* Get MIPS ELF private object data from BFD's tdata.  */

#define mips_elf_tdata(bfd) \
  ((struct mips_elf_obj_tdata *) (bfd)->tdata.any)

#define TLS_RELOC_P(r_type) \
  (r_type == R_MIPS_TLS_DTPMOD32		\
   || r_type == R_MIPS_TLS_DTPMOD64		\
   || r_type == R_MIPS_TLS_DTPREL32		\
   || r_type == R_MIPS_TLS_DTPREL64		\
   || r_type == R_MIPS_TLS_GD			\
   || r_type == R_MIPS_TLS_LDM			\
   || r_type == R_MIPS_TLS_DTPREL_HI16		\
   || r_type == R_MIPS_TLS_DTPREL_LO16		\
   || r_type == R_MIPS_TLS_GOTTPREL		\
   || r_type == R_MIPS_TLS_TPREL32		\
   || r_type == R_MIPS_TLS_TPREL64		\
   || r_type == R_MIPS_TLS_TPREL_HI16		\
   || r_type == R_MIPS_TLS_TPREL_LO16		\
   || r_type == R_MIPS16_TLS_GD			\
   || r_type == R_MIPS16_TLS_LDM		\
   || r_type == R_MIPS16_TLS_DTPREL_HI16	\
   || r_type == R_MIPS16_TLS_DTPREL_LO16	\
   || r_type == R_MIPS16_TLS_GOTTPREL		\
   || r_type == R_MIPS16_TLS_TPREL_HI16		\
   || r_type == R_MIPS16_TLS_TPREL_LO16		\
   || r_type == R_MICROMIPS_TLS_GD		\
   || r_type == R_MICROMIPS_TLS_LDM		\
   || r_type == R_MICROMIPS_TLS_DTPREL_HI16	\
   || r_type == R_MICROMIPS_TLS_DTPREL_LO16	\
   || r_type == R_MICROMIPS_TLS_GOTTPREL	\
   || r_type == R_MICROMIPS_TLS_TPREL_HI16	\
   || r_type == R_MICROMIPS_TLS_TPREL_LO16)

/* Structure used to pass information to mips_elf_output_extsym.  */

struct extsym_info
{
  bfd *abfd;
  struct bfd_link_info *info;
  struct ecoff_debug_info *debug;
  const struct ecoff_debug_swap *swap;
  bfd_boolean failed;
};

/* The names of the runtime procedure table symbols used on IRIX5.  */

static const char * const mips_elf_dynsym_rtproc_names[] =
{
  "_procedure_table",
  "_procedure_string_table",
  "_procedure_table_size",
  NULL
};

/* These structures are used to generate the .compact_rel section on
   IRIX5.  */

typedef struct
{
  unsigned long id1;		/* Always one?  */
  unsigned long num;		/* Number of compact relocation entries.  */
  unsigned long id2;		/* Always two?  */
  unsigned long offset;		/* The file offset of the first relocation.  */
  unsigned long reserved0;	/* Zero?  */
  unsigned long reserved1;	/* Zero?  */
} Elf32_compact_rel;

typedef struct
{
  bfd_byte id1[4];
  bfd_byte num[4];
  bfd_byte id2[4];
  bfd_byte offset[4];
  bfd_byte reserved0[4];
  bfd_byte reserved1[4];
} Elf32_External_compact_rel;

typedef struct
{
  unsigned int ctype : 1;	/* 1: long 0: short format. See below.  */
  unsigned int rtype : 4;	/* Relocation types. See below.  */
  unsigned int dist2to : 8;
  unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
  unsigned long konst;		/* KONST field. See below.  */
  unsigned long vaddr;		/* VADDR to be relocated.  */
} Elf32_crinfo;

typedef struct
{
  unsigned int ctype : 1;	/* 1: long 0: short format. See below.  */
  unsigned int rtype : 4;	/* Relocation types. See below.  */
  unsigned int dist2to : 8;
  unsigned int relvaddr : 19;	/* (VADDR - vaddr of the previous entry)/ 4 */
  unsigned long konst;		/* KONST field. See below.  */
} Elf32_crinfo2;

typedef struct
{
  bfd_byte info[4];
  bfd_byte konst[4];
  bfd_byte vaddr[4];
} Elf32_External_crinfo;

typedef struct
{
  bfd_byte info[4];
  bfd_byte konst[4];
} Elf32_External_crinfo2;

/* These are the constants used to swap the bitfields in a crinfo.  */

#define CRINFO_CTYPE (0x1)
#define CRINFO_CTYPE_SH (31)
#define CRINFO_RTYPE (0xf)
#define CRINFO_RTYPE_SH (27)
#define CRINFO_DIST2TO (0xff)
#define CRINFO_DIST2TO_SH (19)
#define CRINFO_RELVADDR (0x7ffff)
#define CRINFO_RELVADDR_SH (0)

/* A compact relocation info has long (3 words) or short (2 words)
   formats.  A short format doesn't have VADDR field and relvaddr
   fields contains ((VADDR - vaddr of the previous entry) >> 2).  */
#define CRF_MIPS_LONG			1
#define CRF_MIPS_SHORT			0

/* There are 4 types of compact relocation at least. The value KONST
   has different meaning for each type:

   (type)		(konst)
   CT_MIPS_REL32	Address in data
   CT_MIPS_WORD		Address in word (XXX)
   CT_MIPS_GPHI_LO	GP - vaddr
   CT_MIPS_JMPAD	Address to jump
   */

#define CRT_MIPS_REL32			0xa
#define CRT_MIPS_WORD			0xb
#define CRT_MIPS_GPHI_LO		0xc
#define CRT_MIPS_JMPAD			0xd

#define mips_elf_set_cr_format(x,format)	((x).ctype = (format))
#define mips_elf_set_cr_type(x,type)		((x).rtype = (type))
#define mips_elf_set_cr_dist2to(x,v)		((x).dist2to = (v))
#define mips_elf_set_cr_relvaddr(x,d)		((x).relvaddr = (d)<<2)

/* The structure of the runtime procedure descriptor created by the
   loader for use by the static exception system.  */

typedef struct runtime_pdr {
	bfd_vma	adr;		/* Memory address of start of procedure.  */
	long	regmask;	/* Save register mask.  */
	long	regoffset;	/* Save register offset.  */
	long	fregmask;	/* Save floating point register mask.  */
	long	fregoffset;	/* Save floating point register offset.  */
	long	frameoffset;	/* Frame size.  */
	short	framereg;	/* Frame pointer register.  */
	short	pcreg;		/* Offset or reg of return pc.  */
	long	irpss;		/* Index into the runtime string table.  */
	long	reserved;
	struct exception_info *exception_info;/* Pointer to exception array.  */
} RPDR, *pRPDR;
#define cbRPDR sizeof (RPDR)
#define rpdNil ((pRPDR) 0)

static struct mips_got_entry *mips_elf_create_local_got_entry
  (bfd *, struct bfd_link_info *, bfd *, bfd_vma, unsigned long,
   struct mips_elf_link_hash_entry *, int);
static bfd_boolean mips_elf_sort_hash_table_f
  (struct mips_elf_link_hash_entry *, void *);
static bfd_vma mips_elf_high
  (bfd_vma);
static bfd_boolean mips_elf_create_dynamic_relocation
  (bfd *, struct bfd_link_info *, const Elf_Internal_Rela *,
   struct mips_elf_link_hash_entry *, asection *, bfd_vma,
   bfd_vma *, asection *);
static bfd_vma mips_elf_adjust_gp
  (bfd *, struct mips_got_info *, bfd *);

/* This will be used when we sort the dynamic relocation records.  */
static bfd *reldyn_sorting_bfd;

/* True if ABFD is for CPUs with load interlocking that include
   non-MIPS1 CPUs and R3900.  */
#define LOAD_INTERLOCKS_P(abfd) \
  (   ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) != E_MIPS_ARCH_1) \
   || ((elf_elfheader (abfd)->e_flags & EF_MIPS_MACH) == E_MIPS_MACH_3900))

/* True if ABFD is for CPUs that are faster if JAL is converted to BAL.
   This should be safe for all architectures.  We enable this predicate
   for RM9000 for now.  */
#define JAL_TO_BAL_P(abfd) \
  ((elf_elfheader (abfd)->e_flags & EF_MIPS_MACH) == E_MIPS_MACH_9000)

/* True if ABFD is for CPUs that are faster if JALR is converted to BAL.
   This should be safe for all architectures.  We enable this predicate for
   all CPUs.  */
#define JALR_TO_BAL_P(abfd) 1

/* True if ABFD is for CPUs that are faster if JR is converted to B.
   This should be safe for all architectures.  We enable this predicate for
   all CPUs.  */
#define JR_TO_B_P(abfd) 1

/* True if ABFD is a PIC object.  */
#define PIC_OBJECT_P(abfd) \
  ((elf_elfheader (abfd)->e_flags & EF_MIPS_PIC) != 0)

/* Nonzero if ABFD is using the N32 ABI.  */
#define ABI_N32_P(abfd) \
  ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI2) != 0)

/* Nonzero if ABFD is using the N64 ABI.  */
#define ABI_64_P(abfd) \
  (get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64)

/* Nonzero if ABFD is using NewABI conventions.  */
#define NEWABI_P(abfd) (ABI_N32_P (abfd) || ABI_64_P (abfd))

/* Nonzero if ABFD has microMIPS code.  */
#define MICROMIPS_P(abfd) \
  ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH_ASE_MICROMIPS) != 0)

/* The IRIX compatibility level we are striving for.  */
#define IRIX_COMPAT(abfd) \
  (get_elf_backend_data (abfd)->elf_backend_mips_irix_compat (abfd))

/* Whether we are trying to be compatible with IRIX at all.  */
#define SGI_COMPAT(abfd) \
  (IRIX_COMPAT (abfd) != ict_none)

/* The name of the options section.  */
#define MIPS_ELF_OPTIONS_SECTION_NAME(abfd) \
  (NEWABI_P (abfd) ? ".MIPS.options" : ".options")

/* True if NAME is the recognized name of any SHT_MIPS_OPTIONS section.
   Some IRIX system files do not use MIPS_ELF_OPTIONS_SECTION_NAME.  */
#define MIPS_ELF_OPTIONS_SECTION_NAME_P(NAME) \
  (strcmp (NAME, ".MIPS.options") == 0 || strcmp (NAME, ".options") == 0)

/* Whether the section is readonly.  */
#define MIPS_ELF_READONLY_SECTION(sec) \
  ((sec->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))		\
   == (SEC_ALLOC | SEC_LOAD | SEC_READONLY))

/* The name of the stub section.  */
#define MIPS_ELF_STUB_SECTION_NAME(abfd) ".MIPS.stubs"

/* The size of an external REL relocation.  */
#define MIPS_ELF_REL_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_rel)

/* The size of an external RELA relocation.  */
#define MIPS_ELF_RELA_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_rela)

/* The size of an external dynamic table entry.  */
#define MIPS_ELF_DYN_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_dyn)

/* The size of a GOT entry.  */
#define MIPS_ELF_GOT_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->arch_size / 8)

/* The size of the .rld_map section. */
#define MIPS_ELF_RLD_MAP_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->arch_size / 8)

/* The size of a symbol-table entry.  */
#define MIPS_ELF_SYM_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_sym)

/* The default alignment for sections, as a power of two.  */
#define MIPS_ELF_LOG_FILE_ALIGN(abfd)				\
  (get_elf_backend_data (abfd)->s->log_file_align)

/* Get word-sized data.  */
#define MIPS_ELF_GET_WORD(abfd, ptr) \
  (ABI_64_P (abfd) ? bfd_get_64 (abfd, ptr) : bfd_get_32 (abfd, ptr))

/* Put out word-sized data.  */
#define MIPS_ELF_PUT_WORD(abfd, val, ptr)	\
  (ABI_64_P (abfd) 				\
   ? bfd_put_64 (abfd, val, ptr) 		\
   : bfd_put_32 (abfd, val, ptr))

/* The opcode for word-sized loads (LW or LD).  */
#define MIPS_ELF_LOAD_WORD(abfd) \
  (ABI_64_P (abfd) ? 0xdc000000 : 0x8c000000)

/* Add a dynamic symbol table-entry.  */
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)	\
  _bfd_elf_add_dynamic_entry (info, tag, val)

#define MIPS_ELF_RTYPE_TO_HOWTO(abfd, rtype, rela)			\
  (get_elf_backend_data (abfd)->elf_backend_mips_rtype_to_howto (rtype, rela))

/* The name of the dynamic relocation section.  */
#define MIPS_ELF_REL_DYN_NAME(INFO) \
  (mips_elf_hash_table (INFO)->is_vxworks ? ".rela.dyn" : ".rel.dyn")

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)
#define MINUS_TWO	(((bfd_vma)0) - 2)

/* The value to write into got[1] for SVR4 targets, to identify it is
   a GNU object.  The dynamic linker can then use got[1] to store the
   module pointer.  */
#define MIPS_ELF_GNU_GOT1_MASK(abfd) \
  ((bfd_vma) 1 << (ABI_64_P (abfd) ? 63 : 31))

/* The offset of $gp from the beginning of the .got section.  */
#define ELF_MIPS_GP_OFFSET(INFO) \
  (mips_elf_hash_table (INFO)->is_vxworks ? 0x0 : 0x7ff0)

/* The maximum size of the GOT for it to be addressable using 16-bit
   offsets from $gp.  */
#define MIPS_ELF_GOT_MAX_SIZE(INFO) (ELF_MIPS_GP_OFFSET (INFO) + 0x7fff)

/* Instructions which appear in a stub.  */
#define STUB_LW(abfd)							\
  ((ABI_64_P (abfd)							\
    ? 0xdf998010				/* ld t9,0x8010(gp) */	\
    : 0x8f998010))              		/* lw t9,0x8010(gp) */
#define STUB_MOVE(abfd)							\
   ((ABI_64_P (abfd)							\
     ? 0x03e0782d				/* daddu t7,ra */	\
     : 0x03e07821))				/* addu t7,ra */
#define STUB_LUI(VAL) (0x3c180000 + (VAL))	/* lui t8,VAL */
#define STUB_JALR 0x0320f809			/* jalr t9,ra */
#define STUB_ORI(VAL) (0x37180000 + (VAL))	/* ori t8,t8,VAL */
#define STUB_LI16U(VAL) (0x34180000 + (VAL))	/* ori t8,zero,VAL unsigned */
#define STUB_LI16S(abfd, VAL)						\
   ((ABI_64_P (abfd)							\
    ? (0x64180000 + (VAL))	/* daddiu t8,zero,VAL sign extended */	\
    : (0x24180000 + (VAL))))	/* addiu t8,zero,VAL sign extended */

/* Likewise for the microMIPS ASE.  */
#define STUB_LW_MICROMIPS(abfd)						\
  (ABI_64_P (abfd)							\
   ? 0xdf3c8010					/* ld t9,0x8010(gp) */	\
   : 0xff3c8010)				/* lw t9,0x8010(gp) */
#define STUB_MOVE_MICROMIPS 0x0dff		/* move t7,ra */
#define STUB_MOVE32_MICROMIPS(abfd)					\
   (ABI_64_P (abfd)							\
    ? 0x581f7950				/* daddu t7,ra,zero */	\
    : 0x001f7950)				/* addu t7,ra,zero */
#define STUB_LUI_MICROMIPS(VAL)						\
   (0x41b80000 + (VAL))				/* lui t8,VAL */
#define STUB_JALR_MICROMIPS 0x45d9		/* jalr t9 */
#define STUB_JALR32_MICROMIPS 0x03f90f3c	/* jalr ra,t9 */
#define STUB_ORI_MICROMIPS(VAL)						\
  (0x53180000 + (VAL))				/* ori t8,t8,VAL */
#define STUB_LI16U_MICROMIPS(VAL)					\
  (0x53000000 + (VAL))				/* ori t8,zero,VAL unsigned */
#define STUB_LI16S_MICROMIPS(abfd, VAL)					\
   (ABI_64_P (abfd)							\
    ? 0x5f000000 + (VAL)	/* daddiu t8,zero,VAL sign extended */	\
    : 0x33000000 + (VAL))	/* addiu t8,zero,VAL sign extended */

#define MIPS_FUNCTION_STUB_NORMAL_SIZE 16
#define MIPS_FUNCTION_STUB_BIG_SIZE 20
#define MICROMIPS_FUNCTION_STUB_NORMAL_SIZE 12
#define MICROMIPS_FUNCTION_STUB_BIG_SIZE 16
#define MICROMIPS_INSN32_FUNCTION_STUB_NORMAL_SIZE 16
#define MICROMIPS_INSN32_FUNCTION_STUB_BIG_SIZE 20

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER(abfd) 		\
   (ABI_N32_P (abfd) ? "/usr/lib32/libc.so.1" 	\
    : ABI_64_P (abfd) ? "/usr/lib64/libc.so.1" 	\
    : "/usr/lib/libc.so.1")

#ifdef BFD64
#define MNAME(bfd,pre,pos) \
  (ABI_64_P (bfd) ? CONCAT4 (pre,64,_,pos) : CONCAT4 (pre,32,_,pos))
#define ELF_R_SYM(bfd, i)					\
  (ABI_64_P (bfd) ? ELF64_R_SYM (i) : ELF32_R_SYM (i))
#define ELF_R_TYPE(bfd, i)					\
  (ABI_64_P (bfd) ? ELF64_MIPS_R_TYPE (i) : ELF32_R_TYPE (i))
#define ELF_R_INFO(bfd, s, t)					\
  (ABI_64_P (bfd) ? ELF64_R_INFO (s, t) : ELF32_R_INFO (s, t))
#else
#define MNAME(bfd,pre,pos) CONCAT4 (pre,32,_,pos)
#define ELF_R_SYM(bfd, i)					\
  (ELF32_R_SYM (i))
#define ELF_R_TYPE(bfd, i)					\
  (ELF32_R_TYPE (i))
#define ELF_R_INFO(bfd, s, t)					\
  (ELF32_R_INFO (s, t))
#endif

  /* The mips16 compiler uses a couple of special sections to handle
     floating point arguments.

     Section names that look like .mips16.fn.FNNAME contain stubs that
     copy floating point arguments from the fp regs to the gp regs and
     then jump to FNNAME.  If any 32 bit function calls FNNAME, the
     call should be redirected to the stub instead.  If no 32 bit
     function calls FNNAME, the stub should be discarded.  We need to
     consider any reference to the function, not just a call, because
     if the address of the function is taken we will need the stub,
     since the address might be passed to a 32 bit function.

     Section names that look like .mips16.call.FNNAME contain stubs
     that copy floating point arguments from the gp regs to the fp
     regs and then jump to FNNAME.  If FNNAME is a 32 bit function,
     then any 16 bit function that calls FNNAME should be redirected
     to the stub instead.  If FNNAME is not a 32 bit function, the
     stub should be discarded.

     .mips16.call.fp.FNNAME sections are similar, but contain stubs
     which call FNNAME and then copy the return value from the fp regs
     to the gp regs.  These stubs store the return value in $18 while
     calling FNNAME; any function which might call one of these stubs
     must arrange to save $18 around the call.  (This case is not
     needed for 32 bit functions that call 16 bit functions, because
     16 bit functions always return floating point values in both
     $f0/$f1 and $2/$3.)

     Note that in all cases FNNAME might be defined statically.
     Therefore, FNNAME is not used literally.  Instead, the relocation
     information will indicate which symbol the section is for.

     We record any stubs that we find in the symbol table.  */

#define FN_STUB ".mips16.fn."
#define CALL_STUB ".mips16.call."
#define CALL_FP_STUB ".mips16.call.fp."

#define FN_STUB_P(name) CONST_STRNEQ (name, FN_STUB)
#define CALL_STUB_P(name) CONST_STRNEQ (name, CALL_STUB)
#define CALL_FP_STUB_P(name) CONST_STRNEQ (name, CALL_FP_STUB)

/* The format of the first PLT entry in an O32 executable.  */
static const bfd_vma mips_o32_exec_plt0_entry[] =
{
  0x3c1c0000,	/* lui $28, %hi(&GOTPLT[0])				*/
  0x8f990000,	/* lw $25, %lo(&GOTPLT[0])($28)				*/
  0x279c0000,	/* addiu $28, $28, %lo(&GOTPLT[0])			*/
  0x031cc023,	/* subu $24, $24, $28					*/
  0x03e07821,	/* move $15, $31	# 32-bit move (addu)		*/
  0x0018c082,	/* srl $24, $24, 2					*/
  0x0320f809,	/* jalr $25						*/
  0x2718fffe	/* subu $24, $24, 2					*/
};

/* The format of the first PLT entry in an N32 executable.  Different
   because gp ($28) is not available; we use t2 ($14) instead.  */
static const bfd_vma mips_n32_exec_plt0_entry[] =
{
  0x3c0e0000,	/* lui $14, %hi(&GOTPLT[0])				*/
  0x8dd90000,	/* lw $25, %lo(&GOTPLT[0])($14)				*/
  0x25ce0000,	/* addiu $14, $14, %lo(&GOTPLT[0])			*/
  0x030ec023,	/* subu $24, $24, $14					*/
  0x03e07821,	/* move $15, $31	# 32-bit move (addu)		*/
  0x0018c082,	/* srl $24, $24, 2					*/
  0x0320f809,	/* jalr $25						*/
  0x2718fffe	/* subu $24, $24, 2					*/
};

/* The format of the first PLT entry in an N64 executable.  Different
   from N32 because of the increased size of GOT entries.  */
static const bfd_vma mips_n64_exec_plt0_entry[] =
{
  0x3c0e0000,	/* lui $14, %hi(&GOTPLT[0])				*/
  0xddd90000,	/* ld $25, %lo(&GOTPLT[0])($14)				*/
  0x25ce0000,	/* addiu $14, $14, %lo(&GOTPLT[0])			*/
  0x030ec023,	/* subu $24, $24, $14					*/
  0x03e0782d,	/* move $15, $31	# 64-bit move (daddu)		*/
  0x0018c0c2,	/* srl $24, $24, 3					*/
  0x0320f809,	/* jalr $25						*/
  0x2718fffe	/* subu $24, $24, 2					*/
};

/* The format of the microMIPS first PLT entry in an O32 executable.
   We rely on v0 ($2) rather than t8 ($24) to contain the address
   of the GOTPLT entry handled, so this stub may only be used when
   all the subsequent PLT entries are microMIPS code too.

   The trailing NOP is for alignment and correct disassembly only.  */
static const bfd_vma micromips_o32_exec_plt0_entry[] =
{
  0x7980, 0x0000,	/* addiupc $3, (&GOTPLT[0]) - .			*/
  0xff23, 0x0000,	/* lw $25, 0($3)				*/
  0x0535,		/* subu $2, $2, $3				*/
  0x2525,		/* srl $2, $2, 2				*/
  0x3302, 0xfffe,	/* subu $24, $2, 2				*/
  0x0dff,		/* move $15, $31				*/
  0x45f9,		/* jalrs $25					*/
  0x0f83,		/* move $28, $3					*/
  0x0c00		/* nop						*/
};

/* The format of the microMIPS first PLT entry in an O32 executable
   in the insn32 mode.  */
static const bfd_vma micromips_insn32_o32_exec_plt0_entry[] =
{
  0x41bc, 0x0000,	/* lui $28, %hi(&GOTPLT[0])			*/
  0xff3c, 0x0000,	/* lw $25, %lo(&GOTPLT[0])($28)			*/
  0x339c, 0x0000,	/* addiu $28, $28, %lo(&GOTPLT[0])		*/
  0x0398, 0xc1d0,	/* subu $24, $24, $28				*/
  0x001f, 0x7950,	/* move $15, $31				*/
  0x0318, 0x1040,	/* srl $24, $24, 2				*/
  0x03f9, 0x0f3c,	/* jalr $25					*/
  0x3318, 0xfffe	/* subu $24, $24, 2				*/
};

/* The format of subsequent standard PLT entries.  */
static const bfd_vma mips_exec_plt_entry[] =
{
  0x3c0f0000,	/* lui $15, %hi(.got.plt entry)			*/
  0x01f90000,	/* l[wd] $25, %lo(.got.plt entry)($15)		*/
  0x25f80000,	/* addiu $24, $15, %lo(.got.plt entry)		*/
  0x03200008	/* jr $25					*/
};

/* The format of subsequent MIPS16 o32 PLT entries.  We use v0 ($2)
   and v1 ($3) as temporaries because t8 ($24) and t9 ($25) are not
   directly addressable.  */
static const bfd_vma mips16_o32_exec_plt_entry[] =
{
  0xb203,		/* lw $2, 12($pc)			*/
  0x9a60,		/* lw $3, 0($2)				*/
  0x651a,		/* move $24, $2				*/
  0xeb00,		/* jr $3				*/
  0x653b,		/* move $25, $3				*/
  0x6500,		/* nop					*/
  0x0000, 0x0000	/* .word (.got.plt entry)		*/
};

/* The format of subsequent microMIPS o32 PLT entries.  We use v0 ($2)
   as a temporary because t8 ($24) is not addressable with ADDIUPC.  */
static const bfd_vma micromips_o32_exec_plt_entry[] =
{
  0x7900, 0x0000,	/* addiupc $2, (.got.plt entry) - .	*/
  0xff22, 0x0000,	/* lw $25, 0($2)			*/
  0x4599,		/* jr $25				*/
  0x0f02		/* move $24, $2				*/
};

/* The format of subsequent microMIPS o32 PLT entries in the insn32 mode.  */
static const bfd_vma micromips_insn32_o32_exec_plt_entry[] =
{
  0x41af, 0x0000,	/* lui $15, %hi(.got.plt entry)		*/
  0xff2f, 0x0000,	/* lw $25, %lo(.got.plt entry)($15)	*/
  0x0019, 0x0f3c,	/* jr $25				*/
  0x330f, 0x0000	/* addiu $24, $15, %lo(.got.plt entry)	*/
};

/* The format of the first PLT entry in a VxWorks executable.  */
static const bfd_vma mips_vxworks_exec_plt0_entry[] =
{
  0x3c190000,	/* lui t9, %hi(_GLOBAL_OFFSET_TABLE_)		*/
  0x27390000,	/* addiu t9, t9, %lo(_GLOBAL_OFFSET_TABLE_)	*/
  0x8f390008,	/* lw t9, 8(t9)					*/
  0x00000000,	/* nop						*/
  0x03200008,	/* jr t9					*/
  0x00000000	/* nop						*/
};

/* The format of subsequent PLT entries.  */
static const bfd_vma mips_vxworks_exec_plt_entry[] =
{
  0x10000000,	/* b .PLT_resolver			*/
  0x24180000,	/* li t8, <pltindex>			*/
  0x3c190000,	/* lui t9, %hi(<.got.plt slot>)		*/
  0x27390000,	/* addiu t9, t9, %lo(<.got.plt slot>)	*/
  0x8f390000,	/* lw t9, 0(t9)				*/
  0x00000000,	/* nop					*/
  0x03200008,	/* jr t9				*/
  0x00000000	/* nop					*/
};

/* The format of the first PLT entry in a VxWorks shared object.  */
static const bfd_vma mips_vxworks_shared_plt0_entry[] =
{
  0x8f990008,	/* lw t9, 8(gp)		*/
  0x00000000,	/* nop			*/
  0x03200008,	/* jr t9		*/
  0x00000000,	/* nop			*/
  0x00000000,	/* nop			*/
  0x00000000	/* nop			*/
};

/* The format of subsequent PLT entries.  */
static const bfd_vma mips_vxworks_shared_plt_entry[] =
{
  0x10000000,	/* b .PLT_resolver	*/
  0x24180000	/* li t8, <pltindex>	*/
};

/* microMIPS 32-bit opcode helper installer.  */

static void
bfd_put_micromips_32 (const bfd *abfd, bfd_vma opcode, bfd_byte *ptr)
{
  bfd_put_16 (abfd, (opcode >> 16) & 0xffff, ptr);
  bfd_put_16 (abfd,  opcode        & 0xffff, ptr + 2);
}

/* microMIPS 32-bit opcode helper retriever.  */

static bfd_vma
bfd_get_micromips_32 (const bfd *abfd, const bfd_byte *ptr)
{
  return (bfd_get_16 (abfd, ptr) << 16) | bfd_get_16 (abfd, ptr + 2);
}

/* Look up an entry in a MIPS ELF linker hash table.  */

#define mips_elf_link_hash_lookup(table, string, create, copy, follow)	\
  ((struct mips_elf_link_hash_entry *)					\
   elf_link_hash_lookup (&(table)->root, (string), (create),		\
			 (copy), (follow)))

/* Traverse a MIPS ELF linker hash table.  */

#define mips_elf_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\
    (info)))

/* Find the base offsets for thread-local storage in this object,
   for GD/LD and IE/LE respectively.  */

#define TP_OFFSET 0x7000
#define DTP_OFFSET 0x8000

static bfd_vma
dtprel_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma + DTP_OFFSET;
}

static bfd_vma
tprel_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma + TP_OFFSET;
}

/* Create an entry in a MIPS ELF linker hash table.  */

static struct bfd_hash_entry *
mips_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table, const char *string)
{
  struct mips_elf_link_hash_entry *ret =
    (struct mips_elf_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = bfd_hash_allocate (table, sizeof (struct mips_elf_link_hash_entry));
  if (ret == NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct mips_elf_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != NULL)
    {
      /* Set local fields.  */
      memset (&ret->esym, 0, sizeof (EXTR));
      /* We use -2 as a marker to indicate that the information has
	 not been set.  -1 means there is no associated ifd.  */
      ret->esym.ifd = -2;
      ret->la25_stub = 0;
      ret->possibly_dynamic_relocs = 0;
      ret->fn_stub = NULL;
      ret->call_stub = NULL;
      ret->call_fp_stub = NULL;
      ret->global_got_area = GGA_NONE;
      ret->got_only_for_calls = TRUE;
      ret->readonly_reloc = FALSE;
      ret->has_static_relocs = FALSE;
      ret->no_fn_stub = FALSE;
      ret->need_fn_stub = FALSE;
      ret->has_nonpic_branches = FALSE;
      ret->needs_lazy_stub = FALSE;
      ret->use_plt_entry = FALSE;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Allocate MIPS ELF private object data.  */

bfd_boolean
_bfd_mips_elf_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct mips_elf_obj_tdata),
				  MIPS_ELF_DATA);
}

bfd_boolean
_bfd_mips_elf_new_section_hook (bfd *abfd, asection *sec)
{
  if (!sec->used_by_bfd)
    {
      struct _mips_elf_section_data *sdata;
      bfd_size_type amt = sizeof (*sdata);

      sdata = bfd_zalloc (abfd, amt);
      if (sdata == NULL)
	return FALSE;
      sec->used_by_bfd = sdata;
    }

  return _bfd_elf_new_section_hook (abfd, sec);
}

/* Read ECOFF debugging information from a .mdebug section into a
   ecoff_debug_info structure.  */

bfd_boolean
_bfd_mips_elf_read_ecoff_info (bfd *abfd, asection *section,
			       struct ecoff_debug_info *debug)
{
  HDRR *symhdr;
  const struct ecoff_debug_swap *swap;
  char *ext_hdr;

  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  memset (debug, 0, sizeof (*debug));

  ext_hdr = bfd_malloc (swap->external_hdr_size);
  if (ext_hdr == NULL && swap->external_hdr_size != 0)
    goto error_return;

  if (! bfd_get_section_contents (abfd, section, ext_hdr, 0,
				  swap->external_hdr_size))
    goto error_return;

  symhdr = &debug->symbolic_header;
  (*swap->swap_hdr_in) (abfd, ext_hdr, symhdr);

  /* The symbolic header contains absolute file offsets and sizes to
     read.  */
#define READ(ptr, offset, count, size, type)				\
  if (symhdr->count == 0)						\
    debug->ptr = NULL;							\
  else									\
    {									\
      bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\
      debug->ptr = bfd_malloc (amt);					\
      if (debug->ptr == NULL)						\
	goto error_return;						\
      if (bfd_seek (abfd, symhdr->offset, SEEK_SET) != 0		\
	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\
	goto error_return;						\
    }

  READ (line, cbLineOffset, cbLine, sizeof (unsigned char), unsigned char *);
  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, void *);
  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, void *);
  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, void *);
  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, void *);
  READ (external_aux, cbAuxOffset, iauxMax, sizeof (union aux_ext),
	union aux_ext *);
  READ (ss, cbSsOffset, issMax, sizeof (char), char *);
  READ (ssext, cbSsExtOffset, issExtMax, sizeof (char), char *);
  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, void *);
  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, void *);
  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, void *);
#undef READ

  debug->fdr = NULL;

  return TRUE;

 error_return:
  if (ext_hdr != NULL)
    free (ext_hdr);
  if (debug->line != NULL)
    free (debug->line);
  if (debug->external_dnr != NULL)
    free (debug->external_dnr);
  if (debug->external_pdr != NULL)
    free (debug->external_pdr);
  if (debug->external_sym != NULL)
    free (debug->external_sym);
  if (debug->external_opt != NULL)
    free (debug->external_opt);
  if (debug->external_aux != NULL)
    free (debug->external_aux);
  if (debug->ss != NULL)
    free (debug->ss);
  if (debug->ssext != NULL)
    free (debug->ssext);
  if (debug->external_fdr != NULL)
    free (debug->external_fdr);
  if (debug->external_rfd != NULL)
    free (debug->external_rfd);
  if (debug->external_ext != NULL)
    free (debug->external_ext);
  return FALSE;
}

/* Swap RPDR (runtime procedure table entry) for output.  */

static void
ecoff_swap_rpdr_out (bfd *abfd, const RPDR *in, struct rpdr_ext *ex)
{
  H_PUT_S32 (abfd, in->adr, ex->p_adr);
  H_PUT_32 (abfd, in->regmask, ex->p_regmask);
  H_PUT_32 (abfd, in->regoffset, ex->p_regoffset);
  H_PUT_32 (abfd, in->fregmask, ex->p_fregmask);
  H_PUT_32 (abfd, in->fregoffset, ex->p_fregoffset);
  H_PUT_32 (abfd, in->frameoffset, ex->p_frameoffset);

  H_PUT_16 (abfd, in->framereg, ex->p_framereg);
  H_PUT_16 (abfd, in->pcreg, ex->p_pcreg);

  H_PUT_32 (abfd, in->irpss, ex->p_irpss);
}

/* Create a runtime procedure table from the .mdebug section.  */

static bfd_boolean
mips_elf_create_procedure_table (void *handle, bfd *abfd,
				 struct bfd_link_info *info, asection *s,
				 struct ecoff_debug_info *debug)
{
  const struct ecoff_debug_swap *swap;
  HDRR *hdr = &debug->symbolic_header;
  RPDR *rpdr, *rp;
  struct rpdr_ext *erp;
  void *rtproc;
  struct pdr_ext *epdr;
  struct sym_ext *esym;
  char *ss, **sv;
  char *str;
  bfd_size_type size;
  bfd_size_type count;
  unsigned long sindex;
  unsigned long i;
  PDR pdr;
  SYMR sym;
  const char *no_name_func = _("static procedure (no name)");

  epdr = NULL;
  rpdr = NULL;
  esym = NULL;
  ss = NULL;
  sv = NULL;

  swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;

  sindex = strlen (no_name_func) + 1;
  count = hdr->ipdMax;
  if (count > 0)
    {
      size = swap->external_pdr_size;

      epdr = bfd_malloc (size * count);
      if (epdr == NULL)
	goto error_return;

      if (! _bfd_ecoff_get_accumulated_pdr (handle, (bfd_byte *) epdr))
	goto error_return;

      size = sizeof (RPDR);
      rp = rpdr = bfd_malloc (size * count);
      if (rpdr == NULL)
	goto error_return;

      size = sizeof (char *);
      sv = bfd_malloc (size * count);
      if (sv == NULL)
	goto error_return;

      count = hdr->isymMax;
      size = swap->external_sym_size;
      esym = bfd_malloc (size * count);
      if (esym == NULL)
	goto error_return;

      if (! _bfd_ecoff_get_accumulated_sym (handle, (bfd_byte *) esym))
	goto error_return;

      count = hdr->issMax;
      ss = bfd_malloc (count);
      if (ss == NULL)
	goto error_return;
      if (! _bfd_ecoff_get_accumulated_ss (handle, (bfd_byte *) ss))
	goto error_return;

      count = hdr->ipdMax;
      for (i = 0; i < (unsigned long) count; i++, rp++)
	{
	  (*swap->swap_pdr_in) (abfd, epdr + i, &pdr);
	  (*swap->swap_sym_in) (abfd, &esym[pdr.isym], &sym);
	  rp->adr = sym.value;
	  rp->regmask = pdr.regmask;
	  rp->regoffset = pdr.regoffset;
	  rp->fregmask = pdr.fregmask;
	  rp->fregoffset = pdr.fregoffset;
	  rp->frameoffset = pdr.frameoffset;
	  rp->framereg = pdr.framereg;
	  rp->pcreg = pdr.pcreg;
	  rp->irpss = sindex;
	  sv[i] = ss + sym.iss;
	  sindex += strlen (sv[i]) + 1;
	}
    }

  size = sizeof (struct rpdr_ext) * (count + 2) + sindex;
  size = BFD_ALIGN (size, 16);
  rtproc = bfd_alloc (abfd, size);
  if (rtproc == NULL)
    {
      mips_elf_hash_table (info)->procedure_count = 0;
      goto error_return;
    }

  mips_elf_hash_table (info)->procedure_count = count + 2;

  erp = rtproc;
  memset (erp, 0, sizeof (struct rpdr_ext));
  erp++;
  str = (char *) rtproc + sizeof (struct rpdr_ext) * (count + 2);
  strcpy (str, no_name_func);
  str += strlen (no_name_func) + 1;
  for (i = 0; i < count; i++)
    {
      ecoff_swap_rpdr_out (abfd, rpdr + i, erp + i);
      strcpy (str, sv[i]);
      str += strlen (sv[i]) + 1;
    }
  H_PUT_S32 (abfd, -1, (erp + count)->p_adr);

  /* Set the size and contents of .rtproc section.  */
  s->size = size;
  s->contents = rtproc;

  /* Skip this section later on (I don't think this currently
     matters, but someday it might).  */
  s->map_head.link_order = NULL;

  if (epdr != NULL)
    free (epdr);
  if (rpdr != NULL)
    free (rpdr);
  if (esym != NULL)
    free (esym);
  if (ss != NULL)
    free (ss);
  if (sv != NULL)
    free (sv);

  return TRUE;

 error_return:
  if (epdr != NULL)
    free (epdr);
  if (rpdr != NULL)
    free (rpdr);
  if (esym != NULL)
    free (esym);
  if (ss != NULL)
    free (ss);
  if (sv != NULL)
    free (sv);
  return FALSE;
}

/* We're going to create a stub for H.  Create a symbol for the stub's
   value and size, to help make the disassembly easier to read.  */

static bfd_boolean
mips_elf_create_stub_symbol (struct bfd_link_info *info,
			     struct mips_elf_link_hash_entry *h,
			     const char *prefix, asection *s, bfd_vma value,
			     bfd_vma size)
{
  struct bfd_link_hash_entry *bh;
  struct elf_link_hash_entry *elfh;
  const char *name;

  if (ELF_ST_IS_MICROMIPS (h->root.other))
    value |= 1;

  /* Create a new symbol.  */
  name = ACONCAT ((prefix, h->root.root.root.string, NULL));
  bh = NULL;
  if (!_bfd_generic_link_add_one_symbol (info, s->owner, name,
					 BSF_LOCAL, s, value, NULL,
					 TRUE, FALSE, &bh))
    return FALSE;

  /* Make it a local function.  */
  elfh = (struct elf_link_hash_entry *) bh;
  elfh->type = ELF_ST_INFO (STB_LOCAL, STT_FUNC);
  elfh->size = size;
  elfh->forced_local = 1;
  return TRUE;
}

/* We're about to redefine H.  Create a symbol to represent H's
   current value and size, to help make the disassembly easier
   to read.  */

static bfd_boolean
mips_elf_create_shadow_symbol (struct bfd_link_info *info,
			       struct mips_elf_link_hash_entry *h,
			       const char *prefix)
{
  struct bfd_link_hash_entry *bh;
  struct elf_link_hash_entry *elfh;
  const char *name;
  asection *s;
  bfd_vma value;

  /* Read the symbol's value.  */
  BFD_ASSERT (h->root.root.type == bfd_link_hash_defined
	      || h->root.root.type == bfd_link_hash_defweak);
  s = h->root.root.u.def.section;
  value = h->root.root.u.def.value;

  /* Create a new symbol.  */
  name = ACONCAT ((prefix, h->root.root.root.string, NULL));
  bh = NULL;
  if (!_bfd_generic_link_add_one_symbol (info, s->owner, name,
					 BSF_LOCAL, s, value, NULL,
					 TRUE, FALSE, &bh))
    return FALSE;

  /* Make it local and copy the other attributes from H.  */
  elfh = (struct elf_link_hash_entry *) bh;
  elfh->type = ELF_ST_INFO (STB_LOCAL, ELF_ST_TYPE (h->root.type));
  elfh->other = h->root.other;
  elfh->size = h->root.size;
  elfh->forced_local = 1;
  return TRUE;
}

/* Return TRUE if relocations in SECTION can refer directly to a MIPS16
   function rather than to a hard-float stub.  */

static bfd_boolean
section_allows_mips16_refs_p (asection *section)
{
  const char *name;

  name = bfd_get_section_name (section->owner, section);
  return (FN_STUB_P (name)
	  || CALL_STUB_P (name)
	  || CALL_FP_STUB_P (name)
	  || strcmp (name, ".pdr") == 0);
}

/* [RELOCS, RELEND) are the relocations against SEC, which is a MIPS16
   stub section of some kind.  Return the R_SYMNDX of the target
   function, or 0 if we can't decide which function that is.  */

static unsigned long
mips16_stub_symndx (const struct elf_backend_data *bed,
		    asection *sec ATTRIBUTE_UNUSED,
		    const Elf_Internal_Rela *relocs,
		    const Elf_Internal_Rela *relend)
{
  int int_rels_per_ext_rel = bed->s->int_rels_per_ext_rel;
  const Elf_Internal_Rela *rel;

  /* Trust the first R_MIPS_NONE relocation, if any, but not a subsequent
     one in a compound relocation.  */
  for (rel = relocs; rel < relend; rel += int_rels_per_ext_rel)
    if (ELF_R_TYPE (sec->owner, rel->r_info) == R_MIPS_NONE)
      return ELF_R_SYM (sec->owner, rel->r_info);

  /* Otherwise trust the first relocation, whatever its kind.  This is
     the traditional behavior.  */
  if (relocs < relend)
    return ELF_R_SYM (sec->owner, relocs->r_info);

  return 0;
}

/* Check the mips16 stubs for a particular symbol, and see if we can
   discard them.  */

static void
mips_elf_check_mips16_stubs (struct bfd_link_info *info,
			     struct mips_elf_link_hash_entry *h)
{
  /* Dynamic symbols must use the standard call interface, in case other
     objects try to call them.  */
  if (h->fn_stub != NULL
      && h->root.dynindx != -1)
    {
      mips_elf_create_shadow_symbol (info, h, ".mips16.");
      h->need_fn_stub = TRUE;
    }

  if (h->fn_stub != NULL
      && ! h->need_fn_stub)
    {
      /* We don't need the fn_stub; the only references to this symbol
         are 16 bit calls.  Clobber the size to 0 to prevent it from
         being included in the link.  */
      h->fn_stub->size = 0;
      h->fn_stub->flags &= ~SEC_RELOC;
      h->fn_stub->reloc_count = 0;
      h->fn_stub->flags |= SEC_EXCLUDE;
    }

  if (h->call_stub != NULL
      && ELF_ST_IS_MIPS16 (h->root.other))
    {
      /* We don't need the call_stub; this is a 16 bit function, so
         calls from other 16 bit functions are OK.  Clobber the size
         to 0 to prevent it from being included in the link.  */
      h->call_stub->size = 0;
      h->call_stub->flags &= ~SEC_RELOC;
      h->call_stub->reloc_count = 0;
      h->call_stub->flags |= SEC_EXCLUDE;
    }

  if (h->call_fp_stub != NULL
      && ELF_ST_IS_MIPS16 (h->root.other))
    {
      /* We don't need the call_stub; this is a 16 bit function, so
         calls from other 16 bit functions are OK.  Clobber the size
         to 0 to prevent it from being included in the link.  */
      h->call_fp_stub->size = 0;
      h->call_fp_stub->flags &= ~SEC_RELOC;
      h->call_fp_stub->reloc_count = 0;
      h->call_fp_stub->flags |= SEC_EXCLUDE;
    }
}

/* Hashtable callbacks for mips_elf_la25_stubs.  */

static hashval_t
mips_elf_la25_stub_hash (const void *entry_)
{
  const struct mips_elf_la25_stub *entry;

  entry = (struct mips_elf_la25_stub *) entry_;
  return entry->h->root.root.u.def.section->id
    + entry->h->root.root.u.def.value;
}

static int
mips_elf_la25_stub_eq (const void *entry1_, const void *entry2_)
{
  const struct mips_elf_la25_stub *entry1, *entry2;

  entry1 = (struct mips_elf_la25_stub *) entry1_;
  entry2 = (struct mips_elf_la25_stub *) entry2_;
  return ((entry1->h->root.root.u.def.section
	   == entry2->h->root.root.u.def.section)
	  && (entry1->h->root.root.u.def.value
	      == entry2->h->root.root.u.def.value));
}

/* Called by the linker to set up the la25 stub-creation code.  FN is
   the linker's implementation of add_stub_function.  Return true on
   success.  */

bfd_boolean
_bfd_mips_elf_init_stubs (struct bfd_link_info *info,
			  asection *(*fn) (const char *, asection *,
					   asection *))
{
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  htab->add_stub_section = fn;
  htab->la25_stubs = htab_try_create (1, mips_elf_la25_stub_hash,
				      mips_elf_la25_stub_eq, NULL);
  if (htab->la25_stubs == NULL)
    return FALSE;

  return TRUE;
}

/* Return true if H is a locally-defined PIC function, in the sense
   that it or its fn_stub might need $25 to be valid on entry.
   Note that MIPS16 functions set up $gp using PC-relative instructions,
   so they themselves never need $25 to be valid.  Only non-MIPS16
   entry points are of interest here.  */

static bfd_boolean
mips_elf_local_pic_function_p (struct mips_elf_link_hash_entry *h)
{
  return ((h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
	  && h->root.def_regular
	  && !bfd_is_abs_section (h->root.root.u.def.section)
	  && (!ELF_ST_IS_MIPS16 (h->root.other)
	      || (h->fn_stub && h->need_fn_stub))
	  && (PIC_OBJECT_P (h->root.root.u.def.section->owner)
	      || ELF_ST_IS_MIPS_PIC (h->root.other)));
}

/* Set *SEC to the input section that contains the target of STUB.
   Return the offset of the target from the start of that section.  */

static bfd_vma
mips_elf_get_la25_target (struct mips_elf_la25_stub *stub,
			  asection **sec)
{
  if (ELF_ST_IS_MIPS16 (stub->h->root.other))
    {
      BFD_ASSERT (stub->h->need_fn_stub);
      *sec = stub->h->fn_stub;
      return 0;
    }
  else
    {
      *sec = stub->h->root.root.u.def.section;
      return stub->h->root.root.u.def.value;
    }
}

/* STUB describes an la25 stub that we have decided to implement
   by inserting an LUI/ADDIU pair before the target function.
   Create the section and redirect the function symbol to it.  */

static bfd_boolean
mips_elf_add_la25_intro (struct mips_elf_la25_stub *stub,
			 struct bfd_link_info *info)
{
  struct mips_elf_link_hash_table *htab;
  char *name;
  asection *s, *input_section;
  unsigned int align;

  htab = mips_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Create a unique name for the new section.  */
  name = bfd_malloc (11 + sizeof (".text.stub."));
  if (name == NULL)
    return FALSE;
  sprintf (name, ".text.stub.%d", (int) htab_elements (htab->la25_stubs));

  /* Create the section.  */
  mips_elf_get_la25_target (stub, &input_section);
  s = htab->add_stub_section (name, input_section,
			      input_section->output_section);
  if (s == NULL)
    return FALSE;

  /* Make sure that any padding goes before the stub.  */
  align = input_section->alignment_power;
  if (!bfd_set_section_alignment (s->owner, s, align))
    return FALSE;
  if (align > 3)
    s->size = (1 << align) - 8;

  /* Create a symbol for the stub.  */
  mips_elf_create_stub_symbol (info, stub->h, ".pic.", s, s->size, 8);
  stub->stub_section = s;
  stub->offset = s->size;

  /* Allocate room for it.  */
  s->size += 8;
  return TRUE;
}

/* STUB describes an la25 stub that we have decided to implement
   with a separate trampoline.  Allocate room for it and redirect
   the function symbol to it.  */

static bfd_boolean
mips_elf_add_la25_trampoline (struct mips_elf_la25_stub *stub,
			      struct bfd_link_info *info)
{
  struct mips_elf_link_hash_table *htab;
  asection *s;

  htab = mips_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Create a trampoline section, if we haven't already.  */
  s = htab->strampoline;
  if (s == NULL)
    {
      asection *input_section = stub->h->root.root.u.def.section;
      s = htab->add_stub_section (".text", NULL,
				  input_section->output_section);
      if (s == NULL || !bfd_set_section_alignment (s->owner, s, 4))
	return FALSE;
      htab->strampoline = s;
    }

  /* Create a symbol for the stub.  */
  mips_elf_create_stub_symbol (info, stub->h, ".pic.", s, s->size, 16);
  stub->stub_section = s;
  stub->offset = s->size;

  /* Allocate room for it.  */
  s->size += 16;
  return TRUE;
}

/* H describes a symbol that needs an la25 stub.  Make sure that an
   appropriate stub exists and point H at it.  */

static bfd_boolean
mips_elf_add_la25_stub (struct bfd_link_info *info,
			struct mips_elf_link_hash_entry *h)
{
  struct mips_elf_link_hash_table *htab;
  struct mips_elf_la25_stub search, *stub;
  bfd_boolean use_trampoline_p;
  asection *s;
  bfd_vma value;
  void **slot;

  /* Describe the stub we want.  */
  search.stub_section = NULL;
  search.offset = 0;
  search.h = h;

  /* See if we've already created an equivalent stub.  */
  htab = mips_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  slot = htab_find_slot (htab->la25_stubs, &search, INSERT);
  if (slot == NULL)
    return FALSE;

  stub = (struct mips_elf_la25_stub *) *slot;
  if (stub != NULL)
    {
      /* We can reuse the existing stub.  */
      h->la25_stub = stub;
      return TRUE;
    }

  /* Create a permanent copy of ENTRY and add it to the hash table.  */
  stub = bfd_malloc (sizeof (search));
  if (stub == NULL)
    return FALSE;
  *stub = search;
  *slot = stub;

  /* Prefer to use LUI/ADDIU stubs if the function is at the beginning
     of the section and if we would need no more than 2 nops.  */
  value = mips_elf_get_la25_target (stub, &s);
  use_trampoline_p = (value != 0 || s->alignment_power > 4);

  h->la25_stub = stub;
  return (use_trampoline_p
	  ? mips_elf_add_la25_trampoline (stub, info)
	  : mips_elf_add_la25_intro (stub, info));
}

/* A mips_elf_link_hash_traverse callback that is called before sizing
   sections.  DATA points to a mips_htab_traverse_info structure.  */

static bfd_boolean
mips_elf_check_symbols (struct mips_elf_link_hash_entry *h, void *data)
{
  struct mips_htab_traverse_info *hti;

  hti = (struct mips_htab_traverse_info *) data;
  if (!hti->info->relocatable)
    mips_elf_check_mips16_stubs (hti->info, h);

  if (mips_elf_local_pic_function_p (h))
    {
      /* PR 12845: If H is in a section that has been garbage
	 collected it will have its output section set to *ABS*.  */
      if (bfd_is_abs_section (h->root.root.u.def.section->output_section))
	return TRUE;

      /* H is a function that might need $25 to be valid on entry.
	 If we're creating a non-PIC relocatable object, mark H as
	 being PIC.  If we're creating a non-relocatable object with
	 non-PIC branches and jumps to H, make sure that H has an la25
	 stub.  */
      if (hti->info->relocatable)
	{
	  if (!PIC_OBJECT_P (hti->output_bfd))
	    h->root.other = ELF_ST_SET_MIPS_PIC (h->root.other);
	}
      else if (h->has_nonpic_branches && !mips_elf_add_la25_stub (hti->info, h))
	{
	  hti->error = TRUE;
	  return FALSE;
	}
    }
  return TRUE;
}

/* R_MIPS16_26 is used for the mips16 jal and jalx instructions.
   Most mips16 instructions are 16 bits, but these instructions
   are 32 bits.

   The format of these instructions is:

   +--------------+--------------------------------+
   |     JALX     | X|   Imm 20:16  |   Imm 25:21  |
   +--------------+--------------------------------+
   |                Immediate  15:0                |
   +-----------------------------------------------+

   JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx.
   Note that the immediate value in the first word is swapped.

   When producing a relocatable object file, R_MIPS16_26 is
   handled mostly like R_MIPS_26.  In particular, the addend is
   stored as a straight 26-bit value in a 32-bit instruction.
   (gas makes life simpler for itself by never adjusting a
   R_MIPS16_26 reloc to be against a section, so the addend is
   always zero).  However, the 32 bit instruction is stored as 2
   16-bit values, rather than a single 32-bit value.  In a
   big-endian file, the result is the same; in a little-endian
   file, the two 16-bit halves of the 32 bit value are swapped.
   This is so that a disassembler can recognize the jal
   instruction.

   When doing a final link, R_MIPS16_26 is treated as a 32 bit
   instruction stored as two 16-bit values.  The addend A is the
   contents of the targ26 field.  The calculation is the same as
   R_MIPS_26.  When storing the calculated value, reorder the
   immediate value as shown above, and don't forget to store the
   value as two 16-bit values.

   To put it in MIPS ABI terms, the relocation field is T-targ26-16,
   defined as

   big-endian:
   +--------+----------------------+
   |        |                      |
   |        |    targ26-16         |
   |31    26|25                   0|
   +--------+----------------------+

   little-endian:
   +----------+------+-------------+
   |          |      |             |
   |  sub1    |      |     sub2    |
   |0        9|10  15|16         31|
   +----------+--------------------+
   where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is
   ((sub1 << 16) | sub2)).

   When producing a relocatable object file, the calculation is
   (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
   When producing a fully linked file, the calculation is
   let R = (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
   ((R & 0x1f0000) << 5) | ((R & 0x3e00000) >> 5) | (R & 0xffff)

   The table below lists the other MIPS16 instruction relocations.
   Each one is calculated in the same way as the non-MIPS16 relocation
   given on the right, but using the extended MIPS16 layout of 16-bit
   immediate fields:

	R_MIPS16_GPREL		R_MIPS_GPREL16
	R_MIPS16_GOT16		R_MIPS_GOT16
	R_MIPS16_CALL16		R_MIPS_CALL16
	R_MIPS16_HI16		R_MIPS_HI16
	R_MIPS16_LO16		R_MIPS_LO16

   A typical instruction will have a format like this:

   +--------------+--------------------------------+
   |    EXTEND    |     Imm 10:5    |   Imm 15:11  |
   +--------------+--------------------------------+
   |    Major     |   rx   |   ry   |   Imm  4:0   |
   +--------------+--------------------------------+

   EXTEND is the five bit value 11110.  Major is the instruction
   opcode.

   All we need to do here is shuffle the bits appropriately.
   As above, the two 16-bit halves must be swapped on a
   little-endian system.  */

static inline bfd_boolean
mips16_reloc_p (int r_type)
{
  switch (r_type)
    {
    case R_MIPS16_26:
    case R_MIPS16_GPREL:
    case R_MIPS16_GOT16:
    case R_MIPS16_CALL16:
    case R_MIPS16_HI16:
    case R_MIPS16_LO16:
    case R_MIPS16_TLS_GD:
    case R_MIPS16_TLS_LDM:
    case R_MIPS16_TLS_DTPREL_HI16:
    case R_MIPS16_TLS_DTPREL_LO16:
    case R_MIPS16_TLS_GOTTPREL:
    case R_MIPS16_TLS_TPREL_HI16:
    case R_MIPS16_TLS_TPREL_LO16:
      return TRUE;

    default:
      return FALSE;
    }
}

/* Check if a microMIPS reloc.  */

static inline bfd_boolean
micromips_reloc_p (unsigned int r_type)
{
  return r_type >= R_MICROMIPS_min && r_type < R_MICROMIPS_max;
}

/* Similar to MIPS16, the two 16-bit halves in microMIPS must be swapped
   on a little-endian system.  This does not apply to R_MICROMIPS_PC7_S1
   and R_MICROMIPS_PC10_S1 relocs that apply to 16-bit instructions.  */

static inline bfd_boolean
micromips_reloc_shuffle_p (unsigned int r_type)
{
  return (micromips_reloc_p (r_type)
	  && r_type != R_MICROMIPS_PC7_S1
	  && r_type != R_MICROMIPS_PC10_S1);
}

static inline bfd_boolean
got16_reloc_p (int r_type)
{
  return (r_type == R_MIPS_GOT16
	  || r_type == R_MIPS16_GOT16
	  || r_type == R_MICROMIPS_GOT16);
}

static inline bfd_boolean
call16_reloc_p (int r_type)
{
  return (r_type == R_MIPS_CALL16
	  || r_type == R_MIPS16_CALL16
	  || r_type == R_MICROMIPS_CALL16);
}

static inline bfd_boolean
got_disp_reloc_p (unsigned int r_type)
{
  return r_type == R_MIPS_GOT_DISP || r_type == R_MICROMIPS_GOT_DISP;
}

static inline bfd_boolean
got_page_reloc_p (unsigned int r_type)
{
  return r_type == R_MIPS_GOT_PAGE || r_type == R_MICROMIPS_GOT_PAGE;
}

static inline bfd_boolean
got_ofst_reloc_p (unsigned int r_type)
{
  return r_type == R_MIPS_GOT_OFST || r_type == R_MICROMIPS_GOT_OFST;
}

static inline bfd_boolean
got_hi16_reloc_p (unsigned int r_type)
{
  return r_type == R_MIPS_GOT_HI16 || r_type == R_MICROMIPS_GOT_HI16;
}

static inline bfd_boolean
got_lo16_reloc_p (unsigned int r_type)
{
  return r_type == R_MIPS_GOT_LO16 || r_type == R_MICROMIPS_GOT_LO16;
}

static inline bfd_boolean
call_hi16_reloc_p (unsigned int r_type)
{
  return r_type == R_MIPS_CALL_HI16 || r_type == R_MICROMIPS_CALL_HI16;
}

static inline bfd_boolean
call_lo16_reloc_p (unsigned int r_type)
{
  return r_type == R_MIPS_CALL_LO16 || r_type == R_MICROMIPS_CALL_LO16;
}

static inline bfd_boolean
hi16_reloc_p (int r_type)
{
  return (r_type == R_MIPS_HI16
	  || r_type == R_MIPS16_HI16
	  || r_type == R_MICROMIPS_HI16);
}

static inline bfd_boolean
lo16_reloc_p (int r_type)
{
  return (r_type == R_MIPS_LO16
	  || r_type == R_MIPS16_LO16
	  || r_type == R_MICROMIPS_LO16);
}

static inline bfd_boolean
mips16_call_reloc_p (int r_type)
{
  return r_type == R_MIPS16_26 || r_type == R_MIPS16_CALL16;
}

static inline bfd_boolean
jal_reloc_p (int r_type)
{
  return (r_type == R_MIPS_26
	  || r_type == R_MIPS16_26
	  || r_type == R_MICROMIPS_26_S1);
}

static inline bfd_boolean
micromips_branch_reloc_p (int r_type)
{
  return (r_type == R_MICROMIPS_26_S1
	  || r_type == R_MICROMIPS_PC16_S1
	  || r_type == R_MICROMIPS_PC10_S1
	  || r_type == R_MICROMIPS_PC7_S1);
}

static inline bfd_boolean
tls_gd_reloc_p (unsigned int r_type)
{
  return (r_type == R_MIPS_TLS_GD
	  || r_type == R_MIPS16_TLS_GD
	  || r_type == R_MICROMIPS_TLS_GD);
}

static inline bfd_boolean
tls_ldm_reloc_p (unsigned int r_type)
{
  return (r_type == R_MIPS_TLS_LDM
	  || r_type == R_MIPS16_TLS_LDM
	  || r_type == R_MICROMIPS_TLS_LDM);
}

static inline bfd_boolean
tls_gottprel_reloc_p (unsigned int r_type)
{
  return (r_type == R_MIPS_TLS_GOTTPREL
	  || r_type == R_MIPS16_TLS_GOTTPREL
	  || r_type == R_MICROMIPS_TLS_GOTTPREL);
}

void
_bfd_mips_elf_reloc_unshuffle (bfd *abfd, int r_type,
			       bfd_boolean jal_shuffle, bfd_byte *data)
{
  bfd_vma first, second, val;

  if (!mips16_reloc_p (r_type) && !micromips_reloc_shuffle_p (r_type))
    return;

  /* Pick up the first and second halfwords of the instruction.  */
  first = bfd_get_16 (abfd, data);
  second = bfd_get_16 (abfd, data + 2);
  if (micromips_reloc_p (r_type) || (r_type == R_MIPS16_26 && !jal_shuffle))
    val = first << 16 | second;
  else if (r_type != R_MIPS16_26)
    val = (((first & 0xf800) << 16) | ((second & 0xffe0) << 11)
	   | ((first & 0x1f) << 11) | (first & 0x7e0) | (second & 0x1f));
  else
    val = (((first & 0xfc00) << 16) | ((first & 0x3e0) << 11)
	   | ((first & 0x1f) << 21) | second);
  bfd_put_32 (abfd, val, data);
}

void
_bfd_mips_elf_reloc_shuffle (bfd *abfd, int r_type,
			     bfd_boolean jal_shuffle, bfd_byte *data)
{
  bfd_vma first, second, val;

  if (!mips16_reloc_p (r_type) && !micromips_reloc_shuffle_p (r_type))
    return;

  val = bfd_get_32 (abfd, data);
  if (micromips_reloc_p (r_type) || (r_type == R_MIPS16_26 && !jal_shuffle))
    {
      second = val & 0xffff;
      first = val >> 16;
    }
  else if (r_type != R_MIPS16_26)
    {
      second = ((val >> 11) & 0xffe0) | (val & 0x1f);
      first = ((val >> 16) & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0);
    }
  else
    {
      second = val & 0xffff;
      first = ((val >> 16) & 0xfc00) | ((val >> 11) & 0x3e0)
	       | ((val >> 21) & 0x1f);
    }
  bfd_put_16 (abfd, second, data + 2);
  bfd_put_16 (abfd, first, data);
}

bfd_reloc_status_type
_bfd_mips_elf_gprel16_with_gp (bfd *abfd, asymbol *symbol,
			       arelent *reloc_entry, asection *input_section,
			       bfd_boolean relocatable, void *data, bfd_vma gp)
{
  bfd_vma relocation;
  bfd_signed_vma val;
  bfd_reloc_status_type status;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  _bfd_mips_elf_sign_extend (val, 16);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      status = _bfd_relocate_contents (reloc_entry->howto, abfd, val,
				       (bfd_byte *) data
				       + reloc_entry->address);
      if (status != bfd_reloc_ok)
	return status;
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* Used to store a REL high-part relocation such as R_MIPS_HI16 or
   R_MIPS_GOT16.  REL is the relocation, INPUT_SECTION is the section
   that contains the relocation field and DATA points to the start of
   INPUT_SECTION.  */

struct mips_hi16
{
  struct mips_hi16 *next;
  bfd_byte *data;
  asection *input_section;
  arelent rel;
};

/* FIXME: This should not be a static variable.  */

static struct mips_hi16 *mips_hi16_list;

/* A howto special_function for REL *HI16 relocations.  We can only
   calculate the correct value once we've seen the partnering
   *LO16 relocation, so just save the information for later.

   The ABI requires that the *LO16 immediately follow the *HI16.
   However, as a GNU extension, we permit an arbitrary number of
   *HI16s to be associated with a single *LO16.  This significantly
   simplies the relocation handling in gcc.  */

bfd_reloc_status_type
_bfd_mips_elf_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			  asymbol *symbol ATTRIBUTE_UNUSED, void *data,
			  asection *input_section, bfd *output_bfd,
			  char **error_message ATTRIBUTE_UNUSED)
{
  struct mips_hi16 *n;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  n = bfd_malloc (sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;

  n->next = mips_hi16_list;
  n->data = data;
  n->input_section = input_section;
  n->rel = *reloc_entry;
  mips_hi16_list = n;

  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* A howto special_function for REL R_MIPS*_GOT16 relocations.  This is just
   like any other 16-bit relocation when applied to global symbols, but is
   treated in the same as R_MIPS_HI16 when applied to local symbols.  */

bfd_reloc_status_type
_bfd_mips_elf_got16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			   void *data, asection *input_section,
			   bfd *output_bfd, char **error_message)
{
  if ((symbol->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
      || bfd_is_und_section (bfd_get_section (symbol))
      || bfd_is_com_section (bfd_get_section (symbol)))
    /* The relocation is against a global symbol.  */
    return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
					input_section, output_bfd,
					error_message);

  return _bfd_mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
				   input_section, output_bfd, error_message);
}

/* A howto special_function for REL *LO16 relocations.  The *LO16 itself
   is a straightforward 16 bit inplace relocation, but we must deal with
   any partnering high-part relocations as well.  */

bfd_reloc_status_type
_bfd_mips_elf_lo16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section,
			  bfd *output_bfd, char **error_message)
{
  bfd_vma vallo;
  bfd_byte *location = (bfd_byte *) data + reloc_entry->address;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  _bfd_mips_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
				 location);
  vallo = bfd_get_32 (abfd, location);
  _bfd_mips_elf_reloc_shuffle (abfd, reloc_entry->howto->type, FALSE,
			       location);

  while (mips_hi16_list != NULL)
    {
      bfd_reloc_status_type ret;
      struct mips_hi16 *hi;

      hi = mips_hi16_list;

      /* R_MIPS*_GOT16 relocations are something of a special case.  We
	 want to install the addend in the same way as for a R_MIPS*_HI16
	 relocation (with a rightshift of 16).  However, since GOT16
	 relocations can also be used with global symbols, their howto
	 has a rightshift of 0.  */
      if (hi->rel.howto->type == R_MIPS_GOT16)
	hi->rel.howto = MIPS_ELF_RTYPE_TO_HOWTO (abfd, R_MIPS_HI16, FALSE);
      else if (hi->rel.howto->type == R_MIPS16_GOT16)
	hi->rel.howto = MIPS_ELF_RTYPE_TO_HOWTO (abfd, R_MIPS16_HI16, FALSE);
      else if (hi->rel.howto->type == R_MICROMIPS_GOT16)
	hi->rel.howto = MIPS_ELF_RTYPE_TO_HOWTO (abfd, R_MICROMIPS_HI16, FALSE);

      /* VALLO is a signed 16-bit number.  Bias it by 0x8000 so that any
	 carry or borrow will induce a change of +1 or -1 in the high part.  */
      hi->rel.addend += (vallo + 0x8000) & 0xffff;

      ret = _bfd_mips_elf_generic_reloc (abfd, &hi->rel, symbol, hi->data,
					 hi->input_section, output_bfd,
					 error_message);
      if (ret != bfd_reloc_ok)
	return ret;

      mips_hi16_list = hi->next;
      free (hi);
    }

  return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				      input_section, output_bfd,
				      error_message);
}

/* A generic howto special_function.  This calculates and installs the
   relocation itself, thus avoiding the oft-discussed problems in
   bfd_perform_relocation and bfd_install_relocation.  */

bfd_reloc_status_type
_bfd_mips_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			     asymbol *symbol, void *data ATTRIBUTE_UNUSED,
			     asection *input_section, bfd *output_bfd,
			     char **error_message ATTRIBUTE_UNUSED)
{
  bfd_signed_vma val;
  bfd_reloc_status_type status;
  bfd_boolean relocatable;

  relocatable = (output_bfd != NULL);

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  /* Build up the field adjustment in VAL.  */
  val = 0;
  if (!relocatable || (symbol->flags & BSF_SECTION_SYM) != 0)
    {
      /* Either we're calculating the final field value or we have a
	 relocation against a section symbol.  Add in the section's
	 offset or address.  */
      val += symbol->section->output_section->vma;
      val += symbol->section->output_offset;
    }

  if (!relocatable)
    {
      /* We're calculating the final field value.  Add in the symbol's value
	 and, if pc-relative, subtract the address of the field itself.  */
      val += symbol->value;
      if (reloc_entry->howto->pc_relative)
	{
	  val -= input_section->output_section->vma;
	  val -= input_section->output_offset;
	  val -= reloc_entry->address;
	}
    }

  /* VAL is now the final adjustment.  If we're keeping this relocation
     in the output file, and if the relocation uses a separate addend,
     we just need to add VAL to that addend.  Otherwise we need to add
     VAL to the relocation field itself.  */
  if (relocatable && !reloc_entry->howto->partial_inplace)
    reloc_entry->addend += val;
  else
    {
      bfd_byte *location = (bfd_byte *) data + reloc_entry->address;

      /* Add in the separate addend, if any.  */
      val += reloc_entry->addend;

      /* Add VAL to the relocation field.  */
      _bfd_mips_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
				     location);
      status = _bfd_relocate_contents (reloc_entry->howto, abfd, val,
				       location);
      _bfd_mips_elf_reloc_shuffle (abfd, reloc_entry->howto->type, FALSE,
				   location);

      if (status != bfd_reloc_ok)
	return status;
    }

  if (relocatable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* Swap an entry in a .gptab section.  Note that these routines rely
   on the equivalence of the two elements of the union.  */

static void
bfd_mips_elf32_swap_gptab_in (bfd *abfd, const Elf32_External_gptab *ex,
			      Elf32_gptab *in)
{
  in->gt_entry.gt_g_value = H_GET_32 (abfd, ex->gt_entry.gt_g_value);
  in->gt_entry.gt_bytes = H_GET_32 (abfd, ex->gt_entry.gt_bytes);
}

static void
bfd_mips_elf32_swap_gptab_out (bfd *abfd, const Elf32_gptab *in,
			       Elf32_External_gptab *ex)
{
  H_PUT_32 (abfd, in->gt_entry.gt_g_value, ex->gt_entry.gt_g_value);
  H_PUT_32 (abfd, in->gt_entry.gt_bytes, ex->gt_entry.gt_bytes);
}

static void
bfd_elf32_swap_compact_rel_out (bfd *abfd, const Elf32_compact_rel *in,
				Elf32_External_compact_rel *ex)
{
  H_PUT_32 (abfd, in->id1, ex->id1);
  H_PUT_32 (abfd, in->num, ex->num);
  H_PUT_32 (abfd, in->id2, ex->id2);
  H_PUT_32 (abfd, in->offset, ex->offset);
  H_PUT_32 (abfd, in->reserved0, ex->reserved0);
  H_PUT_32 (abfd, in->reserved1, ex->reserved1);
}

static void
bfd_elf32_swap_crinfo_out (bfd *abfd, const Elf32_crinfo *in,
			   Elf32_External_crinfo *ex)
{
  unsigned long l;

  l = (((in->ctype & CRINFO_CTYPE) << CRINFO_CTYPE_SH)
       | ((in->rtype & CRINFO_RTYPE) << CRINFO_RTYPE_SH)
       | ((in->dist2to & CRINFO_DIST2TO) << CRINFO_DIST2TO_SH)
       | ((in->relvaddr & CRINFO_RELVADDR) << CRINFO_RELVADDR_SH));
  H_PUT_32 (abfd, l, ex->info);
  H_PUT_32 (abfd, in->konst, ex->konst);
  H_PUT_32 (abfd, in->vaddr, ex->vaddr);
}

/* A .reginfo section holds a single Elf32_RegInfo structure.  These
   routines swap this structure in and out.  They are used outside of
   BFD, so they are globally visible.  */

void
bfd_mips_elf32_swap_reginfo_in (bfd *abfd, const Elf32_External_RegInfo *ex,
				Elf32_RegInfo *in)
{
  in->ri_gprmask = H_GET_32 (abfd, ex->ri_gprmask);
  in->ri_cprmask[0] = H_GET_32 (abfd, ex->ri_cprmask[0]);
  in->ri_cprmask[1] = H_GET_32 (abfd, ex->ri_cprmask[1]);
  in->ri_cprmask[2] = H_GET_32 (abfd, ex->ri_cprmask[2]);
  in->ri_cprmask[3] = H_GET_32 (abfd, ex->ri_cprmask[3]);
  in->ri_gp_value = H_GET_32 (abfd, ex->ri_gp_value);
}

void
bfd_mips_elf32_swap_reginfo_out (bfd *abfd, const Elf32_RegInfo *in,
				 Elf32_External_RegInfo *ex)
{
  H_PUT_32 (abfd, in->ri_gprmask, ex->ri_gprmask);
  H_PUT_32 (abfd, in->ri_cprmask[0], ex->ri_cprmask[0]);
  H_PUT_32 (abfd, in->ri_cprmask[1], ex->ri_cprmask[1]);
  H_PUT_32 (abfd, in->ri_cprmask[2], ex->ri_cprmask[2]);
  H_PUT_32 (abfd, in->ri_cprmask[3], ex->ri_cprmask[3]);
  H_PUT_32 (abfd, in->ri_gp_value, ex->ri_gp_value);
}

/* In the 64 bit ABI, the .MIPS.options section holds register
   information in an Elf64_Reginfo structure.  These routines swap
   them in and out.  They are globally visible because they are used
   outside of BFD.  These routines are here so that gas can call them
   without worrying about whether the 64 bit ABI has been included.  */

void
bfd_mips_elf64_swap_reginfo_in (bfd *abfd, const Elf64_External_RegInfo *ex,
				Elf64_Internal_RegInfo *in)
{
  in->ri_gprmask = H_GET_32 (abfd, ex->ri_gprmask);
  in->ri_pad = H_GET_32 (abfd, ex->ri_pad);
  in->ri_cprmask[0] = H_GET_32 (abfd, ex->ri_cprmask[0]);
  in->ri_cprmask[1] = H_GET_32 (abfd, ex->ri_cprmask[1]);
  in->ri_cprmask[2] = H_GET_32 (abfd, ex->ri_cprmask[2]);
  in->ri_cprmask[3] = H_GET_32 (abfd, ex->ri_cprmask[3]);
  in->ri_gp_value = H_GET_64 (abfd, ex->ri_gp_value);
}

void
bfd_mips_elf64_swap_reginfo_out (bfd *abfd, const Elf64_Internal_RegInfo *in,
				 Elf64_External_RegInfo *ex)
{
  H_PUT_32 (abfd, in->ri_gprmask, ex->ri_gprmask);
  H_PUT_32 (abfd, in->ri_pad, ex->ri_pad);
  H_PUT_32 (abfd, in->ri_cprmask[0], ex->ri_cprmask[0]);
  H_PUT_32 (abfd, in->ri_cprmask[1], ex->ri_cprmask[1]);
  H_PUT_32 (abfd, in->ri_cprmask[2], ex->ri_cprmask[2]);
  H_PUT_32 (abfd, in->ri_cprmask[3], ex->ri_cprmask[3]);
  H_PUT_64 (abfd, in->ri_gp_value, ex->ri_gp_value);
}

/* Swap in an options header.  */

void
bfd_mips_elf_swap_options_in (bfd *abfd, const Elf_External_Options *ex,
			      Elf_Internal_Options *in)
{
  in->kind = H_GET_8 (abfd, ex->kind);
  in->size = H_GET_8 (abfd, ex->size);
  in->section = H_GET_16 (abfd, ex->section);
  in->info = H_GET_32 (abfd, ex->info);
}

/* Swap out an options header.  */

void
bfd_mips_elf_swap_options_out (bfd *abfd, const Elf_Internal_Options *in,
			       Elf_External_Options *ex)
{
  H_PUT_8 (abfd, in->kind, ex->kind);
  H_PUT_8 (abfd, in->size, ex->size);
  H_PUT_16 (abfd, in->section, ex->section);
  H_PUT_32 (abfd, in->info, ex->info);
}

/* This function is called via qsort() to sort the dynamic relocation
   entries by increasing r_symndx value.  */

static int
sort_dynamic_relocs (const void *arg1, const void *arg2)
{
  Elf_Internal_Rela int_reloc1;
  Elf_Internal_Rela int_reloc2;
  int diff;

  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg1, &int_reloc1);
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg2, &int_reloc2);

  diff = ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info);
  if (diff != 0)
    return diff;

  if (int_reloc1.r_offset < int_reloc2.r_offset)
    return -1;
  if (int_reloc1.r_offset > int_reloc2.r_offset)
    return 1;
  return 0;
}

/* Like sort_dynamic_relocs, but used for elf64 relocations.  */

static int
sort_dynamic_relocs_64 (const void *arg1 ATTRIBUTE_UNUSED,
			const void *arg2 ATTRIBUTE_UNUSED)
{
#ifdef BFD64
  Elf_Internal_Rela int_reloc1[3];
  Elf_Internal_Rela int_reloc2[3];

  (*get_elf_backend_data (reldyn_sorting_bfd)->s->swap_reloc_in)
    (reldyn_sorting_bfd, arg1, int_reloc1);
  (*get_elf_backend_data (reldyn_sorting_bfd)->s->swap_reloc_in)
    (reldyn_sorting_bfd, arg2, int_reloc2);

  if (ELF64_R_SYM (int_reloc1[0].r_info) < ELF64_R_SYM (int_reloc2[0].r_info))
    return -1;
  if (ELF64_R_SYM (int_reloc1[0].r_info) > ELF64_R_SYM (int_reloc2[0].r_info))
    return 1;

  if (int_reloc1[0].r_offset < int_reloc2[0].r_offset)
    return -1;
  if (int_reloc1[0].r_offset > int_reloc2[0].r_offset)
    return 1;
  return 0;
#else
  abort ();
#endif
}


/* This routine is used to write out ECOFF debugging external symbol
   information.  It is called via mips_elf_link_hash_traverse.  The
   ECOFF external symbol information must match the ELF external
   symbol information.  Unfortunately, at this point we don't know
   whether a symbol is required by reloc information, so the two
   tables may wind up being different.  We must sort out the external
   symbol information before we can set the final size of the .mdebug
   section, and we must set the size of the .mdebug section before we
   can relocate any sections, and we can't know which symbols are
   required by relocation until we relocate the sections.
   Fortunately, it is relatively unlikely that any symbol will be
   stripped but required by a reloc.  In particular, it can not happen
   when generating a final executable.  */

static bfd_boolean
mips_elf_output_extsym (struct mips_elf_link_hash_entry *h, void *data)
{
  struct extsym_info *einfo = data;
  bfd_boolean strip;
  asection *sec, *output_section;

  if (h->root.indx == -2)
    strip = FALSE;
  else if ((h->root.def_dynamic
	    || h->root.ref_dynamic
	    || h->root.type == bfd_link_hash_new)
	   && !h->root.def_regular
	   && !h->root.ref_regular)
    strip = TRUE;
  else if (einfo->info->strip == strip_all
	   || (einfo->info->strip == strip_some
	       && bfd_hash_lookup (einfo->info->keep_hash,
				   h->root.root.root.string,
				   FALSE, FALSE) == NULL))
    strip = TRUE;
  else
    strip = FALSE;

  if (strip)
    return TRUE;

  if (h->esym.ifd == -2)
    {
      h->esym.jmptbl = 0;
      h->esym.cobol_main = 0;
      h->esym.weakext = 0;
      h->esym.reserved = 0;
      h->esym.ifd = ifdNil;
      h->esym.asym.value = 0;
      h->esym.asym.st = stGlobal;

      if (h->root.root.type == bfd_link_hash_undefined
	  || h->root.root.type == bfd_link_hash_undefweak)
	{
	  const char *name;

	  /* Use undefined class.  Also, set class and type for some
             special symbols.  */
	  name = h->root.root.root.string;
	  if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
	      || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
	    {
	      h->esym.asym.sc = scData;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value = 0;
	    }
	  else if (strcmp (name, mips_elf_dynsym_rtproc_names[2]) == 0)
	    {
	      h->esym.asym.sc = scAbs;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value =
		mips_elf_hash_table (einfo->info)->procedure_count;
	    }
	  else if (strcmp (name, "_gp_disp") == 0 && ! NEWABI_P (einfo->abfd))
	    {
	      h->esym.asym.sc = scAbs;
	      h->esym.asym.st = stLabel;
	      h->esym.asym.value = elf_gp (einfo->abfd);
	    }
	  else
	    h->esym.asym.sc = scUndefined;
	}
      else if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak)
	h->esym.asym.sc = scAbs;
      else
	{
	  const char *name;

	  sec = h->root.root.u.def.section;
	  output_section = sec->output_section;

	  /* When making a shared library and symbol h is the one from
	     the another shared library, OUTPUT_SECTION may be null.  */
	  if (output_section == NULL)
	    h->esym.asym.sc = scUndefined;
	  else
	    {
	      name = bfd_section_name (output_section->owner, output_section);

	      if (strcmp (name, ".text") == 0)
		h->esym.asym.sc = scText;
	      else if (strcmp (name, ".data") == 0)
		h->esym.asym.sc = scData;
	      else if (strcmp (name, ".sdata") == 0)
		h->esym.asym.sc = scSData;
	      else if (strcmp (name, ".rodata") == 0
		       || strcmp (name, ".rdata") == 0)
		h->esym.asym.sc = scRData;
	      else if (strcmp (name, ".bss") == 0)
		h->esym.asym.sc = scBss;
	      else if (strcmp (name, ".sbss") == 0)
		h->esym.asym.sc = scSBss;
	      else if (strcmp (name, ".init") == 0)
		h->esym.asym.sc = scInit;
	      else if (strcmp (name, ".fini") == 0)
		h->esym.asym.sc = scFini;
	      else
		h->esym.asym.sc = scAbs;
	    }
	}

      h->esym.asym.reserved = 0;
      h->esym.asym.index = indexNil;
    }

  if (h->root.root.type == bfd_link_hash_common)
    h->esym.asym.value = h->root.root.u.c.size;
  else if (h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
    {
      if (h->esym.asym.sc == scCommon)
	h->esym.asym.sc = scBss;
      else if (h->esym.asym.sc == scSCommon)
	h->esym.asym.sc = scSBss;

      sec = h->root.root.u.def.section;
      output_section = sec->output_section;
      if (output_section != NULL)
	h->esym.asym.value = (h->root.root.u.def.value
			      + sec->output_offset
			      + output_section->vma);
      else
	h->esym.asym.value = 0;
    }
  else
    {
      struct mips_elf_link_hash_entry *hd = h;

      while (hd->root.root.type == bfd_link_hash_indirect)
	hd = (struct mips_elf_link_hash_entry *)h->root.root.u.i.link;

      if (hd->needs_lazy_stub)
	{
	  BFD_ASSERT (hd->root.plt.plist != NULL);
	  BFD_ASSERT (hd->root.plt.plist->stub_offset != MINUS_ONE);
	  /* Set type and value for a symbol with a function stub.  */
	  h->esym.asym.st = stProc;
	  sec = hd->root.root.u.def.section;
	  if (sec == NULL)
	    h->esym.asym.value = 0;
	  else
	    {
	      output_section = sec->output_section;
	      if (output_section != NULL)
		h->esym.asym.value = (hd->root.plt.plist->stub_offset
				      + sec->output_offset
				      + output_section->vma);
	      else
		h->esym.asym.value = 0;
	    }
	}
    }

  if (! bfd_ecoff_debug_one_external (einfo->abfd, einfo->debug, einfo->swap,
				      h->root.root.root.string,
				      &h->esym))
    {
      einfo->failed = TRUE;
      return FALSE;
    }

  return TRUE;
}

/* A comparison routine used to sort .gptab entries.  */

static int
gptab_compare (const void *p1, const void *p2)
{
  const Elf32_gptab *a1 = p1;
  const Elf32_gptab *a2 = p2;

  return a1->gt_entry.gt_g_value - a2->gt_entry.gt_g_value;
}

/* Functions to manage the got entry hash table.  */

/* Use all 64 bits of a bfd_vma for the computation of a 32-bit
   hash number.  */

static INLINE hashval_t
mips_elf_hash_bfd_vma (bfd_vma addr)
{
#ifdef BFD64
  return addr + (addr >> 32);
#else
  return addr;
#endif
}

static hashval_t
mips_elf_got_entry_hash (const void *entry_)
{
  const struct mips_got_entry *entry = (struct mips_got_entry *)entry_;

  return (entry->symndx
	  + ((entry->tls_type == GOT_TLS_LDM) << 18)
	  + (entry->tls_type == GOT_TLS_LDM ? 0
	     : !entry->abfd ? mips_elf_hash_bfd_vma (entry->d.address)
	     : entry->symndx >= 0 ? (entry->abfd->id
				     + mips_elf_hash_bfd_vma (entry->d.addend))
	     : entry->d.h->root.root.root.hash));
}

static int
mips_elf_got_entry_eq (const void *entry1, const void *entry2)
{
  const struct mips_got_entry *e1 = (struct mips_got_entry *)entry1;
  const struct mips_got_entry *e2 = (struct mips_got_entry *)entry2;

  return (e1->symndx == e2->symndx
	  && e1->tls_type == e2->tls_type
	  && (e1->tls_type == GOT_TLS_LDM ? TRUE
	      : !e1->abfd ? !e2->abfd && e1->d.address == e2->d.address
	      : e1->symndx >= 0 ? (e1->abfd == e2->abfd
				   && e1->d.addend == e2->d.addend)
	      : e2->abfd && e1->d.h == e2->d.h));
}

static hashval_t
mips_got_page_ref_hash (const void *ref_)
{
  const struct mips_got_page_ref *ref;

  ref = (const struct mips_got_page_ref *) ref_;
  return ((ref->symndx >= 0
	   ? (hashval_t) (ref->u.abfd->id + ref->symndx)
	   : ref->u.h->root.root.root.hash)
	  + mips_elf_hash_bfd_vma (ref->addend));
}

static int
mips_got_page_ref_eq (const void *ref1_, const void *ref2_)
{
  const struct mips_got_page_ref *ref1, *ref2;

  ref1 = (const struct mips_got_page_ref *) ref1_;
  ref2 = (const struct mips_got_page_ref *) ref2_;
  return (ref1->symndx == ref2->symndx
	  && (ref1->symndx < 0
	      ? ref1->u.h == ref2->u.h
	      : ref1->u.abfd == ref2->u.abfd)
	  && ref1->addend == ref2->addend);
}

static hashval_t
mips_got_page_entry_hash (const void *entry_)
{
  const struct mips_got_page_entry *entry;

  entry = (const struct mips_got_page_entry *) entry_;
  return entry->sec->id;
}

static int
mips_got_page_entry_eq (const void *entry1_, const void *entry2_)
{
  const struct mips_got_page_entry *entry1, *entry2;

  entry1 = (const struct mips_got_page_entry *) entry1_;
  entry2 = (const struct mips_got_page_entry *) entry2_;
  return entry1->sec == entry2->sec;
}

/* Create and return a new mips_got_info structure.  */

static struct mips_got_info *
mips_elf_create_got_info (bfd *abfd)
{
  struct mips_got_info *g;

  g = bfd_zalloc (abfd, sizeof (struct mips_got_info));
  if (g == NULL)
    return NULL;

  g->got_entries = htab_try_create (1, mips_elf_got_entry_hash,
				    mips_elf_got_entry_eq, NULL);
  if (g->got_entries == NULL)
    return NULL;

  g->got_page_refs = htab_try_create (1, mips_got_page_ref_hash,
				      mips_got_page_ref_eq, NULL);
  if (g->got_page_refs == NULL)
    return NULL;

  return g;
}

/* Return the GOT info for input bfd ABFD, trying to create a new one if
   CREATE_P and if ABFD doesn't already have a GOT.  */

static struct mips_got_info *
mips_elf_bfd_got (bfd *abfd, bfd_boolean create_p)
{
  struct mips_elf_obj_tdata *tdata;

  if (!is_mips_elf (abfd))
    return NULL;

  tdata = mips_elf_tdata (abfd);
  if (!tdata->got && create_p)
    tdata->got = mips_elf_create_got_info (abfd);
  return tdata->got;
}

/* Record that ABFD should use output GOT G.  */

static void
mips_elf_replace_bfd_got (bfd *abfd, struct mips_got_info *g)
{
  struct mips_elf_obj_tdata *tdata;

  BFD_ASSERT (is_mips_elf (abfd));
  tdata = mips_elf_tdata (abfd);
  if (tdata->got)
    {
      /* The GOT structure itself and the hash table entries are
	 allocated to a bfd, but the hash tables aren't.  */
      htab_delete (tdata->got->got_entries);
      htab_delete (tdata->got->got_page_refs);
      if (tdata->got->got_page_entries)
	htab_delete (tdata->got->got_page_entries);
    }
  tdata->got = g;
}

/* Return the dynamic relocation section.  If it doesn't exist, try to
   create a new it if CREATE_P, otherwise return NULL.  Also return NULL
   if creation fails.  */

static asection *
mips_elf_rel_dyn_section (struct bfd_link_info *info, bfd_boolean create_p)
{
  const char *dname;
  asection *sreloc;
  bfd *dynobj;

  dname = MIPS_ELF_REL_DYN_NAME (info);
  dynobj = elf_hash_table (info)->dynobj;
  sreloc = bfd_get_linker_section (dynobj, dname);
  if (sreloc == NULL && create_p)
    {
      sreloc = bfd_make_section_anyway_with_flags (dynobj, dname,
						   (SEC_ALLOC
						    | SEC_LOAD
						    | SEC_HAS_CONTENTS
						    | SEC_IN_MEMORY
						    | SEC_LINKER_CREATED
						    | SEC_READONLY));
      if (sreloc == NULL
	  || ! bfd_set_section_alignment (dynobj, sreloc,
					  MIPS_ELF_LOG_FILE_ALIGN (dynobj)))
	return NULL;
    }
  return sreloc;
}

/* Return the GOT_TLS_* type required by relocation type R_TYPE.  */

static int
mips_elf_reloc_tls_type (unsigned int r_type)
{
  if (tls_gd_reloc_p (r_type))
    return GOT_TLS_GD;

  if (tls_ldm_reloc_p (r_type))
    return GOT_TLS_LDM;

  if (tls_gottprel_reloc_p (r_type))
    return GOT_TLS_IE;

  return GOT_TLS_NONE;
}

/* Return the number of GOT slots needed for GOT TLS type TYPE.  */

static int
mips_tls_got_entries (unsigned int type)
{
  switch (type)
    {
    case GOT_TLS_GD:
    case GOT_TLS_LDM:
      return 2;

    case GOT_TLS_IE:
      return 1;

    case GOT_TLS_NONE:
      return 0;
    }
  abort ();
}

/* Count the number of relocations needed for a TLS GOT entry, with
   access types from TLS_TYPE, and symbol H (or a local symbol if H
   is NULL).  */

static int
mips_tls_got_relocs (struct bfd_link_info *info, unsigned char tls_type,
		     struct elf_link_hash_entry *h)
{
  int indx = 0;
  bfd_boolean need_relocs = FALSE;
  bfd_boolean dyn = elf_hash_table (info)->dynamic_sections_created;

  if (h && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
      && (!info->shared || !SYMBOL_REFERENCES_LOCAL (info, h)))
    indx = h->dynindx;

  if ((info->shared || indx != 0)
      && (h == NULL
	  || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
    need_relocs = TRUE;

  if (!need_relocs)
    return 0;

  switch (tls_type)
    {
    case GOT_TLS_GD:
      return indx != 0 ? 2 : 1;

    case GOT_TLS_IE:
      return 1;

    case GOT_TLS_LDM:
      return info->shared ? 1 : 0;

    default:
      return 0;
    }
}

/* Add the number of GOT entries and TLS relocations required by ENTRY
   to G.  */

static void
mips_elf_count_got_entry (struct bfd_link_info *info,
			  struct mips_got_info *g,
			  struct mips_got_entry *entry)
{
  if (entry->tls_type)
    {
      g->tls_gotno += mips_tls_got_entries (entry->tls_type);
      g->relocs += mips_tls_got_relocs (info, entry->tls_type,
					entry->symndx < 0
					? &entry->d.h->root : NULL);
    }
  else if (entry->symndx >= 0 || entry->d.h->global_got_area == GGA_NONE)
    g->local_gotno += 1;
  else
    g->global_gotno += 1;
}

/* Output a simple dynamic relocation into SRELOC.  */

static void
mips_elf_output_dynamic_relocation (bfd *output_bfd,
				    asection *sreloc,
				    unsigned long reloc_index,
				    unsigned long indx,
				    int r_type,
				    bfd_vma offset)
{
  Elf_Internal_Rela rel[3];

  memset (rel, 0, sizeof (rel));

  rel[0].r_info = ELF_R_INFO (output_bfd, indx, r_type);
  rel[0].r_offset = rel[1].r_offset = rel[2].r_offset = offset;

  if (ABI_64_P (output_bfd))
    {
      (*get_elf_backend_data (output_bfd)->s->swap_reloc_out)
	(output_bfd, &rel[0],
	 (sreloc->contents
	  + reloc_index * sizeof (Elf64_Mips_External_Rel)));
    }
  else
    bfd_elf32_swap_reloc_out
      (output_bfd, &rel[0],
       (sreloc->contents
	+ reloc_index * sizeof (Elf32_External_Rel)));
}

/* Initialize a set of TLS GOT entries for one symbol.  */

static void
mips_elf_initialize_tls_slots (bfd *abfd, struct bfd_link_info *info,
			       struct mips_got_entry *entry,
			       struct mips_elf_link_hash_entry *h,
			       bfd_vma value)
{
  struct mips_elf_link_hash_table *htab;
  int indx;
  asection *sreloc, *sgot;
  bfd_vma got_offset, got_offset2;
  bfd_boolean need_relocs = FALSE;

  htab = mips_elf_hash_table (info);
  if (htab == NULL)
    return;

  sgot = htab->sgot;

  indx = 0;
  if (h != NULL)
    {
      bfd_boolean dyn = elf_hash_table (info)->dynamic_sections_created;

      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, &h->root)
	  && (!info->shared || !SYMBOL_REFERENCES_LOCAL (info, &h->root)))
	indx = h->root.dynindx;
    }

  if (entry->tls_initialized)
    return;

  if ((info->shared || indx != 0)
      && (h == NULL
	  || ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
    need_relocs = TRUE;

  /* MINUS_ONE means the symbol is not defined in this object.  It may not
     be defined at all; assume that the value doesn't matter in that
     case.  Otherwise complain if we would use the value.  */
  BFD_ASSERT (value != MINUS_ONE || (indx != 0 && need_relocs)
	      || h->root.root.type == bfd_link_hash_undefweak);

  /* Emit necessary relocations.  */
  sreloc = mips_elf_rel_dyn_section (info, FALSE);
  got_offset = entry->gotidx;

  switch (entry->tls_type)
    {
    case GOT_TLS_GD:
      /* General Dynamic.  */
      got_offset2 = got_offset + MIPS_ELF_GOT_SIZE (abfd);

      if (need_relocs)
	{
	  mips_elf_output_dynamic_relocation
	    (abfd, sreloc, sreloc->reloc_count++, indx,
	     ABI_64_P (abfd) ? R_MIPS_TLS_DTPMOD64 : R_MIPS_TLS_DTPMOD32,
	     sgot->output_offset + sgot->output_section->vma + got_offset);

	  if (indx)
	    mips_elf_output_dynamic_relocation
	      (abfd, sreloc, sreloc->reloc_count++, indx,
	       ABI_64_P (abfd) ? R_MIPS_TLS_DTPREL64 : R_MIPS_TLS_DTPREL32,
	       sgot->output_offset + sgot->output_section->vma + got_offset2);
	  else
	    MIPS_ELF_PUT_WORD (abfd, value - dtprel_base (info),
			       sgot->contents + got_offset2);
	}
      else
	{
	  MIPS_ELF_PUT_WORD (abfd, 1,
			     sgot->contents + got_offset);
	  MIPS_ELF_PUT_WORD (abfd, value - dtprel_base (info),
			     sgot->contents + got_offset2);
	}
      break;

    case GOT_TLS_IE:
      /* Initial Exec model.  */
      if (need_relocs)
	{
	  if (indx == 0)
	    MIPS_ELF_PUT_WORD (abfd, value - elf_hash_table (info)->tls_sec->vma,
			       sgot->contents + got_offset);
	  else
	    MIPS_ELF_PUT_WORD (abfd, 0,
			       sgot->contents + got_offset);

	  mips_elf_output_dynamic_relocation
	    (abfd, sreloc, sreloc->reloc_count++, indx,
	     ABI_64_P (abfd) ? R_MIPS_TLS_TPREL64 : R_MIPS_TLS_TPREL32,
	     sgot->output_offset + sgot->output_section->vma + got_offset);
	}
      else
	MIPS_ELF_PUT_WORD (abfd, value - tprel_base (info),
			   sgot->contents + got_offset);
      break;

    case GOT_TLS_LDM:
      /* The initial offset is zero, and the LD offsets will include the
	 bias by DTP_OFFSET.  */
      MIPS_ELF_PUT_WORD (abfd, 0,
			 sgot->contents + got_offset
			 + MIPS_ELF_GOT_SIZE (abfd));

      if (!info->shared)
	MIPS_ELF_PUT_WORD (abfd, 1,
			   sgot->contents + got_offset);
      else
	mips_elf_output_dynamic_relocation
	  (abfd, sreloc, sreloc->reloc_count++, indx,
	   ABI_64_P (abfd) ? R_MIPS_TLS_DTPMOD64 : R_MIPS_TLS_DTPMOD32,
	   sgot->output_offset + sgot->output_section->vma + got_offset);
      break;

    default:
      abort ();
    }

  entry->tls_initialized = TRUE;
}

/* Return the offset from _GLOBAL_OFFSET_TABLE_ of the .got.plt entry
   for global symbol H.  .got.plt comes before the GOT, so the offset
   will be negative.  */

static bfd_vma
mips_elf_gotplt_index (struct bfd_link_info *info,
		       struct elf_link_hash_entry *h)
{
  bfd_vma got_address, got_value;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  BFD_ASSERT (h->plt.plist != NULL);
  BFD_ASSERT (h->plt.plist->gotplt_index != MINUS_ONE);

  /* Calculate the address of the associated .got.plt entry.  */
  got_address = (htab->sgotplt->output_section->vma
		 + htab->sgotplt->output_offset
		 + (h->plt.plist->gotplt_index
		    * MIPS_ELF_GOT_SIZE (info->output_bfd)));

  /* Calculate the value of _GLOBAL_OFFSET_TABLE_.  */
  got_value = (htab->root.hgot->root.u.def.section->output_section->vma
	       + htab->root.hgot->root.u.def.section->output_offset
	       + htab->root.hgot->root.u.def.value);

  return got_address - got_value;
}

/* Return the GOT offset for address VALUE.   If there is not yet a GOT
   entry for this value, create one.  If R_SYMNDX refers to a TLS symbol,
   create a TLS GOT entry instead.  Return -1 if no satisfactory GOT
   offset can be found.  */

static bfd_vma
mips_elf_local_got_index (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
			  bfd_vma value, unsigned long r_symndx,
			  struct mips_elf_link_hash_entry *h, int r_type)
{
  struct mips_elf_link_hash_table *htab;
  struct mips_got_entry *entry;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  entry = mips_elf_create_local_got_entry (abfd, info, ibfd, value,
					   r_symndx, h, r_type);
  if (!entry)
    return MINUS_ONE;

  if (entry->tls_type)
    mips_elf_initialize_tls_slots (abfd, info, entry, h, value);
  return entry->gotidx;
}

/* Return the GOT index of global symbol H in the primary GOT.  */

static bfd_vma
mips_elf_primary_global_got_index (bfd *obfd, struct bfd_link_info *info,
				   struct elf_link_hash_entry *h)
{
  struct mips_elf_link_hash_table *htab;
  long global_got_dynindx;
  struct mips_got_info *g;
  bfd_vma got_index;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  global_got_dynindx = 0;
  if (htab->global_gotsym != NULL)
    global_got_dynindx = htab->global_gotsym->dynindx;

  /* Once we determine the global GOT entry with the lowest dynamic
     symbol table index, we must put all dynamic symbols with greater
     indices into the primary GOT.  That makes it easy to calculate the
     GOT offset.  */
  BFD_ASSERT (h->dynindx >= global_got_dynindx);
  g = mips_elf_bfd_got (obfd, FALSE);
  got_index = ((h->dynindx - global_got_dynindx + g->local_gotno)
	       * MIPS_ELF_GOT_SIZE (obfd));
  BFD_ASSERT (got_index < htab->sgot->size);

  return got_index;
}

/* Return the GOT index for the global symbol indicated by H, which is
   referenced by a relocation of type R_TYPE in IBFD.  */

static bfd_vma
mips_elf_global_got_index (bfd *obfd, struct bfd_link_info *info, bfd *ibfd,
			   struct elf_link_hash_entry *h, int r_type)
{
  struct mips_elf_link_hash_table *htab;
  struct mips_got_info *g;
  struct mips_got_entry lookup, *entry;
  bfd_vma gotidx;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  g = mips_elf_bfd_got (ibfd, FALSE);
  BFD_ASSERT (g);

  lookup.tls_type = mips_elf_reloc_tls_type (r_type);
  if (!lookup.tls_type && g == mips_elf_bfd_got (obfd, FALSE))
    return mips_elf_primary_global_got_index (obfd, info, h);

  lookup.abfd = ibfd;
  lookup.symndx = -1;
  lookup.d.h = (struct mips_elf_link_hash_entry *) h;
  entry = htab_find (g->got_entries, &lookup);
  BFD_ASSERT (entry);

  gotidx = entry->gotidx;
  BFD_ASSERT (gotidx > 0 && gotidx < htab->sgot->size);

  if (lookup.tls_type)
    {
      bfd_vma value = MINUS_ONE;

      if ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section->output_section)
	value = (h->root.u.def.value
		 + h->root.u.def.section->output_offset
		 + h->root.u.def.section->output_section->vma);

      mips_elf_initialize_tls_slots (obfd, info, entry, lookup.d.h, value);
    }
  return gotidx;
}

/* Find a GOT page entry that points to within 32KB of VALUE.  These
   entries are supposed to be placed at small offsets in the GOT, i.e.,
   within 32KB of GP.  Return the index of the GOT entry, or -1 if no
   entry could be created.  If OFFSETP is nonnull, use it to return the
   offset of the GOT entry from VALUE.  */

static bfd_vma
mips_elf_got_page (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
		   bfd_vma value, bfd_vma *offsetp)
{
  bfd_vma page, got_index;
  struct mips_got_entry *entry;

  page = (value + 0x8000) & ~(bfd_vma) 0xffff;
  entry = mips_elf_create_local_got_entry (abfd, info, ibfd, page, 0,
					   NULL, R_MIPS_GOT_PAGE);

  if (!entry)
    return MINUS_ONE;

  got_index = entry->gotidx;

  if (offsetp)
    *offsetp = value - entry->d.address;

  return got_index;
}

/* Find a local GOT entry for an R_MIPS*_GOT16 relocation against VALUE.
   EXTERNAL is true if the relocation was originally against a global
   symbol that binds locally.  */

static bfd_vma
mips_elf_got16_entry (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
		      bfd_vma value, bfd_boolean external)
{
  struct mips_got_entry *entry;

  /* GOT16 relocations against local symbols are followed by a LO16
     relocation; those against global symbols are not.  Thus if the
     symbol was originally local, the GOT16 relocation should load the
     equivalent of %hi(VALUE), otherwise it should load VALUE itself.  */
  if (! external)
    value = mips_elf_high (value) << 16;

  /* It doesn't matter whether the original relocation was R_MIPS_GOT16,
     R_MIPS16_GOT16, R_MIPS_CALL16, etc.  The format of the entry is the
     same in all cases.  */
  entry = mips_elf_create_local_got_entry (abfd, info, ibfd, value, 0,
					   NULL, R_MIPS_GOT16);
  if (entry)
    return entry->gotidx;
  else
    return MINUS_ONE;
}

/* Returns the offset for the entry at the INDEXth position
   in the GOT.  */

static bfd_vma
mips_elf_got_offset_from_index (struct bfd_link_info *info, bfd *output_bfd,
				bfd *input_bfd, bfd_vma got_index)
{
  struct mips_elf_link_hash_table *htab;
  asection *sgot;
  bfd_vma gp;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  sgot = htab->sgot;
  gp = _bfd_get_gp_value (output_bfd)
    + mips_elf_adjust_gp (output_bfd, htab->got_info, input_bfd);

  return sgot->output_section->vma + sgot->output_offset + got_index - gp;
}

/* Create and return a local GOT entry for VALUE, which was calculated
   from a symbol belonging to INPUT_SECTON.  Return NULL if it could not
   be created.  If R_SYMNDX refers to a TLS symbol, create a TLS entry
   instead.  */

static struct mips_got_entry *
mips_elf_create_local_got_entry (bfd *abfd, struct bfd_link_info *info,
				 bfd *ibfd, bfd_vma value,
				 unsigned long r_symndx,
				 struct mips_elf_link_hash_entry *h,
				 int r_type)
{
  struct mips_got_entry lookup, *entry;
  void **loc;
  struct mips_got_info *g;
  struct mips_elf_link_hash_table *htab;
  bfd_vma gotidx;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  g = mips_elf_bfd_got (ibfd, FALSE);
  if (g == NULL)
    {
      g = mips_elf_bfd_got (abfd, FALSE);
      BFD_ASSERT (g != NULL);
    }

  /* This function shouldn't be called for symbols that live in the global
     area of the GOT.  */
  BFD_ASSERT (h == NULL || h->global_got_area == GGA_NONE);

  lookup.tls_type = mips_elf_reloc_tls_type (r_type);
  if (lookup.tls_type)
    {
      lookup.abfd = ibfd;
      if (tls_ldm_reloc_p (r_type))
	{
	  lookup.symndx = 0;
	  lookup.d.addend = 0;
	}
      else if (h == NULL)
	{
	  lookup.symndx = r_symndx;
	  lookup.d.addend = 0;
	}
      else
	{
	  lookup.symndx = -1;
	  lookup.d.h = h;
	}

      entry = (struct mips_got_entry *) htab_find (g->got_entries, &lookup);
      BFD_ASSERT (entry);

      gotidx = entry->gotidx;
      BFD_ASSERT (gotidx > 0 && gotidx < htab->sgot->size);

      return entry;
    }

  lookup.abfd = NULL;
  lookup.symndx = -1;
  lookup.d.address = value;
  loc = htab_find_slot (g->got_entries, &lookup, INSERT);
  if (!loc)
    return NULL;

  entry = (struct mips_got_entry *) *loc;
  if (entry)
    return entry;

  if (g->assigned_gotno >= g->local_gotno)
    {
      /* We didn't allocate enough space in the GOT.  */
      (*_bfd_error_handler)
	(_("not enough GOT space for local GOT entries"));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  entry = (struct mips_got_entry *) bfd_alloc (abfd, sizeof (*entry));
  if (!entry)
    return NULL;

  lookup.gotidx = MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno++;
  *entry = lookup;
  *loc = entry;

  MIPS_ELF_PUT_WORD (abfd, value, htab->sgot->contents + entry->gotidx);

  /* These GOT entries need a dynamic relocation on VxWorks.  */
  if (htab->is_vxworks)
    {
      Elf_Internal_Rela outrel;
      asection *s;
      bfd_byte *rloc;
      bfd_vma got_address;

      s = mips_elf_rel_dyn_section (info, FALSE);
      got_address = (htab->sgot->output_section->vma
		     + htab->sgot->output_offset
		     + entry->gotidx);

      rloc = s->contents + (s->reloc_count++ * sizeof (Elf32_External_Rela));
      outrel.r_offset = got_address;
      outrel.r_info = ELF32_R_INFO (STN_UNDEF, R_MIPS_32);
      outrel.r_addend = value;
      bfd_elf32_swap_reloca_out (abfd, &outrel, rloc);
    }

  return entry;
}

/* Return the number of dynamic section symbols required by OUTPUT_BFD.
   The number might be exact or a worst-case estimate, depending on how
   much information is available to elf_backend_omit_section_dynsym at
   the current linking stage.  */

static bfd_size_type
count_section_dynsyms (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd_size_type count;

  count = 0;
  if (info->shared || elf_hash_table (info)->is_relocatable_executable)
    {
      asection *p;
      const struct elf_backend_data *bed;

      bed = get_elf_backend_data (output_bfd);
      for (p = output_bfd->sections; p ; p = p->next)
	if ((p->flags & SEC_EXCLUDE) == 0
	    && (p->flags & SEC_ALLOC) != 0
	    && !(*bed->elf_backend_omit_section_dynsym) (output_bfd, info, p))
	  ++count;
    }
  return count;
}

/* Sort the dynamic symbol table so that symbols that need GOT entries
   appear towards the end.  */

static bfd_boolean
mips_elf_sort_hash_table (bfd *abfd, struct bfd_link_info *info)
{
  struct mips_elf_link_hash_table *htab;
  struct mips_elf_hash_sort_data hsd;
  struct mips_got_info *g;

  if (elf_hash_table (info)->dynsymcount == 0)
    return TRUE;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  g = htab->got_info;
  if (g == NULL)
    return TRUE;

  hsd.low = NULL;
  hsd.max_unref_got_dynindx
    = hsd.min_got_dynindx
    = (elf_hash_table (info)->dynsymcount - g->reloc_only_gotno);
  hsd.max_non_got_dynindx = count_section_dynsyms (abfd, info) + 1;
  mips_elf_link_hash_traverse (((struct mips_elf_link_hash_table *)
				elf_hash_table (info)),
			       mips_elf_sort_hash_table_f,
			       &hsd);

  /* There should have been enough room in the symbol table to
     accommodate both the GOT and non-GOT symbols.  */
  BFD_ASSERT (hsd.max_non_got_dynindx <= hsd.min_got_dynindx);
  BFD_ASSERT ((unsigned long) hsd.max_unref_got_dynindx
	      == elf_hash_table (info)->dynsymcount);
  BFD_ASSERT (elf_hash_table (info)->dynsymcount - hsd.min_got_dynindx
	      == g->global_gotno);

  /* Now we know which dynamic symbol has the lowest dynamic symbol
     table index in the GOT.  */
  htab->global_gotsym = hsd.low;

  return TRUE;
}

/* If H needs a GOT entry, assign it the highest available dynamic
   index.  Otherwise, assign it the lowest available dynamic
   index.  */

static bfd_boolean
mips_elf_sort_hash_table_f (struct mips_elf_link_hash_entry *h, void *data)
{
  struct mips_elf_hash_sort_data *hsd = data;

  /* Symbols without dynamic symbol table entries aren't interesting
     at all.  */
  if (h->root.dynindx == -1)
    return TRUE;

  switch (h->global_got_area)
    {
    case GGA_NONE:
      h->root.dynindx = hsd->max_non_got_dynindx++;
      break;

    case GGA_NORMAL:
      h->root.dynindx = --hsd->min_got_dynindx;
      hsd->low = (struct elf_link_hash_entry *) h;
      break;

    case GGA_RELOC_ONLY:
      if (hsd->max_unref_got_dynindx == hsd->min_got_dynindx)
	hsd->low = (struct elf_link_hash_entry *) h;
      h->root.dynindx = hsd->max_unref_got_dynindx++;
      break;
    }

  return TRUE;
}

/* Record that input bfd ABFD requires a GOT entry like *LOOKUP
   (which is owned by the caller and shouldn't be added to the
   hash table directly).  */

static bfd_boolean
mips_elf_record_got_entry (struct bfd_link_info *info, bfd *abfd,
			   struct mips_got_entry *lookup)
{
  struct mips_elf_link_hash_table *htab;
  struct mips_got_entry *entry;
  struct mips_got_info *g;
  void **loc, **bfd_loc;

  /* Make sure there's a slot for this entry in the master GOT.  */
  htab = mips_elf_hash_table (info);
  g = htab->got_info;
  loc = htab_find_slot (g->got_entries, lookup, INSERT);
  if (!loc)
    return FALSE;

  /* Populate the entry if it isn't already.  */
  entry = (struct mips_got_entry *) *loc;
  if (!entry)
    {
      entry = (struct mips_got_entry *) bfd_alloc (abfd, sizeof (*entry));
      if (!entry)
	return FALSE;

      lookup->tls_initialized = FALSE;
      lookup->gotidx = -1;
      *entry = *lookup;
      *loc = entry;
    }

  /* Reuse the same GOT entry for the BFD's GOT.  */
  g = mips_elf_bfd_got (abfd, TRUE);
  if (!g)
    return FALSE;

  bfd_loc = htab_find_slot (g->got_entries, lookup, INSERT);
  if (!bfd_loc)
    return FALSE;

  if (!*bfd_loc)
    *bfd_loc = entry;
  return TRUE;
}

/* ABFD has a GOT relocation of type R_TYPE against H.  Reserve a GOT
   entry for it.  FOR_CALL is true if the caller is only interested in
   using the GOT entry for calls.  */

static bfd_boolean
mips_elf_record_global_got_symbol (struct elf_link_hash_entry *h,
				   bfd *abfd, struct bfd_link_info *info,
				   bfd_boolean for_call, int r_type)
{
  struct mips_elf_link_hash_table *htab;
  struct mips_elf_link_hash_entry *hmips;
  struct mips_got_entry entry;
  unsigned char tls_type;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  hmips = (struct mips_elf_link_hash_entry *) h;
  if (!for_call)
    hmips->got_only_for_calls = FALSE;

  /* A global symbol in the GOT must also be in the dynamic symbol
     table.  */
  if (h->dynindx == -1)
    {
      switch (ELF_ST_VISIBILITY (h->other))
	{
	case STV_INTERNAL:
	case STV_HIDDEN:
	  _bfd_elf_link_hash_hide_symbol (info, h, TRUE);
	  break;
	}
      if (!bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  tls_type = mips_elf_reloc_tls_type (r_type);
  if (tls_type == GOT_TLS_NONE && hmips->global_got_area > GGA_NORMAL)
    hmips->global_got_area = GGA_NORMAL;

  entry.abfd = abfd;
  entry.symndx = -1;
  entry.d.h = (struct mips_elf_link_hash_entry *) h;
  entry.tls_type = tls_type;
  return mips_elf_record_got_entry (info, abfd, &entry);
}

/* ABFD has a GOT relocation of type R_TYPE against symbol SYMNDX + ADDEND,
   where SYMNDX is a local symbol.  Reserve a GOT entry for it.  */

static bfd_boolean
mips_elf_record_local_got_symbol (bfd *abfd, long symndx, bfd_vma addend,
				  struct bfd_link_info *info, int r_type)
{
  struct mips_elf_link_hash_table *htab;
  struct mips_got_info *g;
  struct mips_got_entry entry;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  g = htab->got_info;
  BFD_ASSERT (g != NULL);

  entry.abfd = abfd;
  entry.symndx = symndx;
  entry.d.addend = addend;
  entry.tls_type = mips_elf_reloc_tls_type (r_type);
  return mips_elf_record_got_entry (info, abfd, &entry);
}

/* Record that ABFD has a page relocation against SYMNDX + ADDEND.
   H is the symbol's hash table entry, or null if SYMNDX is local
   to ABFD.  */

static bfd_boolean
mips_elf_record_got_page_ref (struct bfd_link_info *info, bfd *abfd,
			      long symndx, struct elf_link_hash_entry *h,
			      bfd_signed_vma addend)
{
  struct mips_elf_link_hash_table *htab;
  struct mips_got_info *g1, *g2;
  struct mips_got_page_ref lookup, *entry;
  void **loc, **bfd_loc;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  g1 = htab->got_info;
  BFD_ASSERT (g1 != NULL);

  if (h)
    {
      lookup.symndx = -1;
      lookup.u.h = (struct mips_elf_link_hash_entry *) h;
    }
  else
    {
      lookup.symndx = symndx;
      lookup.u.abfd = abfd;
    }
  lookup.addend = addend;
  loc = htab_find_slot (g1->got_page_refs, &lookup, INSERT);
  if (loc == NULL)
    return FALSE;

  entry = (struct mips_got_page_ref *) *loc;
  if (!entry)
    {
      entry = bfd_alloc (abfd, sizeof (*entry));
      if (!entry)
	return FALSE;

      *entry = lookup;
      *loc = entry;
    }

  /* Add the same entry to the BFD's GOT.  */
  g2 = mips_elf_bfd_got (abfd, TRUE);
  if (!g2)
    return FALSE;

  bfd_loc = htab_find_slot (g2->got_page_refs, &lookup, INSERT);
  if (!bfd_loc)
    return FALSE;

  if (!*bfd_loc)
    *bfd_loc = entry;

  return TRUE;
}

/* Add room for N relocations to the .rel(a).dyn section in ABFD.  */

static void
mips_elf_allocate_dynamic_relocations (bfd *abfd, struct bfd_link_info *info,
				       unsigned int n)
{
  asection *s;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  s = mips_elf_rel_dyn_section (info, FALSE);
  BFD_ASSERT (s != NULL);

  if (htab->is_vxworks)
    s->size += n * MIPS_ELF_RELA_SIZE (abfd);
  else
    {
      if (s->size == 0)
	{
	  /* Make room for a null element.  */
	  s->size += MIPS_ELF_REL_SIZE (abfd);
	  ++s->reloc_count;
	}
      s->size += n * MIPS_ELF_REL_SIZE (abfd);
    }
}

/* A htab_traverse callback for GOT entries, with DATA pointing to a
   mips_elf_traverse_got_arg structure.  Count the number of GOT
   entries and TLS relocs.  Set DATA->value to true if we need
   to resolve indirect or warning symbols and then recreate the GOT.  */

static int
mips_elf_check_recreate_got (void **entryp, void *data)
{
  struct mips_got_entry *entry;
  struct mips_elf_traverse_got_arg *arg;

  entry = (struct mips_got_entry *) *entryp;
  arg = (struct mips_elf_traverse_got_arg *) data;
  if (entry->abfd != NULL && entry->symndx == -1)
    {
      struct mips_elf_link_hash_entry *h;

      h = entry->d.h;
      if (h->root.root.type == bfd_link_hash_indirect
	  || h->root.root.type == bfd_link_hash_warning)
	{
	  arg->value = TRUE;
	  return 0;
	}
    }
  mips_elf_count_got_entry (arg->info, arg->g, entry);
  return 1;
}

/* A htab_traverse callback for GOT entries, with DATA pointing to a
   mips_elf_traverse_got_arg structure.  Add all entries to DATA->g,
   converting entries for indirect and warning symbols into entries
   for the target symbol.  Set DATA->g to null on error.  */

static int
mips_elf_recreate_got (void **entryp, void *data)
{
  struct mips_got_entry new_entry, *entry;
  struct mips_elf_traverse_got_arg *arg;
  void **slot;

  entry = (struct mips_got_entry *) *entryp;
  arg = (struct mips_elf_traverse_got_arg *) data;
  if (entry->abfd != NULL
      && entry->symndx == -1
      && (entry->d.h->root.root.type == bfd_link_hash_indirect
	  || entry->d.h->root.root.type == bfd_link_hash_warning))
    {
      struct mips_elf_link_hash_entry *h;

      new_entry = *entry;
      entry = &new_entry;
      h = entry->d.h;
      do
	{
	  BFD_ASSERT (h->global_got_area == GGA_NONE);
	  h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;
	}
      while (h->root.root.type == bfd_link_hash_indirect
	     || h->root.root.type == bfd_link_hash_warning);
      entry->d.h = h;
    }
  slot = htab_find_slot (arg->g->got_entries, entry, INSERT);
  if (slot == NULL)
    {
      arg->g = NULL;
      return 0;
    }
  if (*slot == NULL)
    {
      if (entry == &new_entry)
	{
	  entry = bfd_alloc (entry->abfd, sizeof (*entry));
	  if (!entry)
	    {
	      arg->g = NULL;
	      return 0;
	    }
	  *entry = new_entry;
	}
      *slot = entry;
      mips_elf_count_got_entry (arg->info, arg->g, entry);
    }
  return 1;
}

/* Return the maximum number of GOT page entries required for RANGE.  */

static bfd_vma
mips_elf_pages_for_range (const struct mips_got_page_range *range)
{
  return (range->max_addend - range->min_addend + 0x1ffff) >> 16;
}

/* Record that G requires a page entry that can reach SEC + ADDEND.  */

static bfd_boolean
mips_elf_record_got_page_entry (struct mips_got_info *g,
				asection *sec, bfd_signed_vma addend)
{
  struct mips_got_page_entry lookup, *entry;
  struct mips_got_page_range **range_ptr, *range;
  bfd_vma old_pages, new_pages;
  void **loc;

  /* Find the mips_got_page_entry hash table entry for this section.  */
  lookup.sec = sec;
  loc = htab_find_slot (g->got_page_entries, &lookup, INSERT);
  if (loc == NULL)
    return FALSE;

  /* Create a mips_got_page_entry if this is the first time we've
     seen the section.  */
  entry = (struct mips_got_page_entry *) *loc;
  if (!entry)
    {
      entry = bfd_zalloc (sec->owner, sizeof (*entry));
      if (!entry)
	return FALSE;

      entry->sec = sec;
      *loc = entry;
    }

  /* Skip over ranges whose maximum extent cannot share a page entry
     with ADDEND.  */
  range_ptr = &entry->ranges;
  while (*range_ptr && addend > (*range_ptr)->max_addend + 0xffff)
    range_ptr = &(*range_ptr)->next;

  /* If we scanned to the end of the list, or found a range whose
     minimum extent cannot share a page entry with ADDEND, create
     a new singleton range.  */
  range = *range_ptr;
  if (!range || addend < range->min_addend - 0xffff)
    {
      range = bfd_zalloc (sec->owner, sizeof (*range));
      if (!range)
	return FALSE;

      range->next = *range_ptr;
      range->min_addend = addend;
      range->max_addend = addend;

      *range_ptr = range;
      entry->num_pages++;
      g->page_gotno++;
      return TRUE;
    }

  /* Remember how many pages the old range contributed.  */
  old_pages = mips_elf_pages_for_range (range);

  /* Update the ranges.  */
  if (addend < range->min_addend)
    range->min_addend = addend;
  else if (addend > range->max_addend)
    {
      if (range->next && addend >= range->next->min_addend - 0xffff)
	{
	  old_pages += mips_elf_pages_for_range (range->next);
	  range->max_addend = range->next->max_addend;
	  range->next = range->next->next;
	}
      else
	range->max_addend = addend;
    }

  /* Record any change in the total estimate.  */
  new_pages = mips_elf_pages_for_range (range);
  if (old_pages != new_pages)
    {
      entry->num_pages += new_pages - old_pages;
      g->page_gotno += new_pages - old_pages;
    }

  return TRUE;
}

/* A htab_traverse callback for which *REFP points to a mips_got_page_ref
   and for which DATA points to a mips_elf_traverse_got_arg.  Work out
   whether the page reference described by *REFP needs a GOT page entry,
   and record that entry in DATA->g if so.  Set DATA->g to null on failure.  */

static bfd_boolean
mips_elf_resolve_got_page_ref (void **refp, void *data)
{
  struct mips_got_page_ref *ref;
  struct mips_elf_traverse_got_arg *arg;
  struct mips_elf_link_hash_table *htab;
  asection *sec;
  bfd_vma addend;

  ref = (struct mips_got_page_ref *) *refp;
  arg = (struct mips_elf_traverse_got_arg *) data;
  htab = mips_elf_hash_table (arg->info);

  if (ref->symndx < 0)
    {
      struct mips_elf_link_hash_entry *h;

      /* Global GOT_PAGEs decay to GOT_DISP and so don't need page entries.  */
      h = ref->u.h;
      if (!SYMBOL_REFERENCES_LOCAL (arg->info, &h->root))
	return 1;

      /* Ignore undefined symbols; we'll issue an error later if
	 appropriate.  */
      if (!((h->root.root.type == bfd_link_hash_defined
	     || h->root.root.type == bfd_link_hash_defweak)
	    && h->root.root.u.def.section))
	return 1;

      sec = h->root.root.u.def.section;
      addend = h->root.root.u.def.value + ref->addend;
    }
  else
    {
      Elf_Internal_Sym *isym;

      /* Read in the symbol.  */
      isym = bfd_sym_from_r_symndx (&htab->sym_cache, ref->u.abfd,
				    ref->symndx);
      if (isym == NULL)
	{
	  arg->g = NULL;
	  return 0;
	}

      /* Get the associated input section.  */
      sec = bfd_section_from_elf_index (ref->u.abfd, isym->st_shndx);
      if (sec == NULL)
	{
	  arg->g = NULL;
	  return 0;
	}

      /* If this is a mergable section, work out the section and offset
	 of the merged data.  For section symbols, the addend specifies
	 of the offset _of_ the first byte in the data, otherwise it
	 specifies the offset _from_ the first byte.  */
      if (sec->flags & SEC_MERGE)
	{
	  void *secinfo;

	  secinfo = elf_section_data (sec)->sec_info;
	  if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
	    addend = _bfd_merged_section_offset (ref->u.abfd, &sec, secinfo,
						 isym->st_value + ref->addend);
	  else
	    addend = _bfd_merged_section_offset (ref->u.abfd, &sec, secinfo,
						 isym->st_value) + ref->addend;
	}
      else
	addend = isym->st_value + ref->addend;
    }
  if (!mips_elf_record_got_page_entry (arg->g, sec, addend))
    {
      arg->g = NULL;
      return 0;
    }
  return 1;
}

/* If any entries in G->got_entries are for indirect or warning symbols,
   replace them with entries for the target symbol.  Convert g->got_page_refs
   into got_page_entry structures and estimate the number of page entries
   that they require.  */

static bfd_boolean
mips_elf_resolve_final_got_entries (struct bfd_link_info *info,
				    struct mips_got_info *g)
{
  struct mips_elf_traverse_got_arg tga;
  struct mips_got_info oldg;

  oldg = *g;

  tga.info = info;
  tga.g = g;
  tga.value = FALSE;
  htab_traverse (g->got_entries, mips_elf_check_recreate_got, &tga);
  if (tga.value)
    {
      *g = oldg;
      g->got_entries = htab_create (htab_size (oldg.got_entries),
				    mips_elf_got_entry_hash,
				    mips_elf_got_entry_eq, NULL);
      if (!g->got_entries)
	return FALSE;

      htab_traverse (oldg.got_entries, mips_elf_recreate_got, &tga);
      if (!tga.g)
	return FALSE;

      htab_delete (oldg.got_entries);
    }

  g->got_page_entries = htab_try_create (1, mips_got_page_entry_hash,
					 mips_got_page_entry_eq, NULL);
  if (g->got_page_entries == NULL)
    return FALSE;

  tga.info = info;
  tga.g = g;
  htab_traverse (g->got_page_refs, mips_elf_resolve_got_page_ref, &tga);

  return TRUE;
}

/* Return true if a GOT entry for H should live in the local rather than
   global GOT area.  */

static bfd_boolean
mips_use_local_got_p (struct bfd_link_info *info,
		      struct mips_elf_link_hash_entry *h)
{
  /* Symbols that aren't in the dynamic symbol table must live in the
     local GOT.  This includes symbols that are completely undefined
     and which therefore don't bind locally.  We'll report undefined
     symbols later if appropriate.  */
  if (h->root.dynindx == -1)
    return TRUE;

  /* Symbols that bind locally can (and in the case of forced-local
     symbols, must) live in the local GOT.  */
  if (h->got_only_for_calls
      ? SYMBOL_CALLS_LOCAL (info, &h->root)
      : SYMBOL_REFERENCES_LOCAL (info, &h->root))
    return TRUE;

  /* If this is an executable that must provide a definition of the symbol,
     either though PLTs or copy relocations, then that address should go in
     the local rather than global GOT.  */
  if (info->executable && h->has_static_relocs)
    return TRUE;

  return FALSE;
}

/* A mips_elf_link_hash_traverse callback for which DATA points to the
   link_info structure.  Decide whether the hash entry needs an entry in
   the global part of the primary GOT, setting global_got_area accordingly.
   Count the number of global symbols that are in the primary GOT only
   because they have relocations against them (reloc_only_gotno).  */

static int
mips_elf_count_got_symbols (struct mips_elf_link_hash_entry *h, void *data)
{
  struct bfd_link_info *info;
  struct mips_elf_link_hash_table *htab;
  struct mips_got_info *g;

  info = (struct bfd_link_info *) data;
  htab = mips_elf_hash_table (info);
  g = htab->got_info;
  if (h->global_got_area != GGA_NONE)
    {
      /* Make a final decision about whether the symbol belongs in the
	 local or global GOT.  */
      if (mips_use_local_got_p (info, h))
	/* The symbol belongs in the local GOT.  We no longer need this
	   entry if it was only used for relocations; those relocations
	   will be against the null or section symbol instead of H.  */
	h->global_got_area = GGA_NONE;
      else if (htab->is_vxworks
	       && h->got_only_for_calls
	       && h->root.plt.plist->mips_offset != MINUS_ONE)
	/* On VxWorks, calls can refer directly to the .got.plt entry;
	   they don't need entries in the regular GOT.  .got.plt entries
	   will be allocated by _bfd_mips_elf_adjust_dynamic_symbol.  */
	h->global_got_area = GGA_NONE;
      else if (h->global_got_area == GGA_RELOC_ONLY)
	{
	  g->reloc_only_gotno++;
	  g->global_gotno++;
	}
    }
  return 1;
}

/* A htab_traverse callback for GOT entries.  Add each one to the GOT
   given in mips_elf_traverse_got_arg DATA.  Clear DATA->G on error.  */

static int
mips_elf_add_got_entry (void **entryp, void *data)
{
  struct mips_got_entry *entry;
  struct mips_elf_traverse_got_arg *arg;
  void **slot;

  entry = (struct mips_got_entry *) *entryp;
  arg = (struct mips_elf_traverse_got_arg *) data;
  slot = htab_find_slot (arg->g->got_entries, entry, INSERT);
  if (!slot)
    {
      arg->g = NULL;
      return 0;
    }
  if (!*slot)
    {
      *slot = entry;
      mips_elf_count_got_entry (arg->info, arg->g, entry);
    }
  return 1;
}

/* A htab_traverse callback for GOT page entries.  Add each one to the GOT
   given in mips_elf_traverse_got_arg DATA.  Clear DATA->G on error.  */

static int
mips_elf_add_got_page_entry (void **entryp, void *data)
{
  struct mips_got_page_entry *entry;
  struct mips_elf_traverse_got_arg *arg;
  void **slot;

  entry = (struct mips_got_page_entry *) *entryp;
  arg = (struct mips_elf_traverse_got_arg *) data;
  slot = htab_find_slot (arg->g->got_page_entries, entry, INSERT);
  if (!slot)
    {
      arg->g = NULL;
      return 0;
    }
  if (!*slot)
    {
      *slot = entry;
      arg->g->page_gotno += entry->num_pages;
    }
  return 1;
}

/* Consider merging FROM, which is ABFD's GOT, into TO.  Return -1 if
   this would lead to overflow, 1 if they were merged successfully,
   and 0 if a merge failed due to lack of memory.  (These values are chosen
   so that nonnegative return values can be returned by a htab_traverse
   callback.)  */

static int
mips_elf_merge_got_with (bfd *abfd, struct mips_got_info *from,
			 struct mips_got_info *to,
			 struct mips_elf_got_per_bfd_arg *arg)
{
  struct mips_elf_traverse_got_arg tga;
  unsigned int estimate;

  /* Work out how many page entries we would need for the combined GOT.  */
  estimate = arg->max_pages;
  if (estimate >= from->page_gotno + to->page_gotno)
    estimate = from->page_gotno + to->page_gotno;

  /* And conservatively estimate how many local and TLS entries
     would be needed.  */
  estimate += from->local_gotno + to->local_gotno;
  estimate += from->tls_gotno + to->tls_gotno;

  /* If we're merging with the primary got, any TLS relocations will
     come after the full set of global entries.  Otherwise estimate those
     conservatively as well.  */
  if (to == arg->primary && from->tls_gotno + to->tls_gotno)
    estimate += arg->global_count;
  else
    estimate += from->global_gotno + to->global_gotno;

  /* Bail out if the combined GOT might be too big.  */
  if (estimate > arg->max_count)
    return -1;

  /* Transfer the bfd's got information from FROM to TO.  */
  tga.info = arg->info;
  tga.g = to;
  htab_traverse (from->got_entries, mips_elf_add_got_entry, &tga);
  if (!tga.g)
    return 0;

  htab_traverse (from->got_page_entries, mips_elf_add_got_page_entry, &tga);
  if (!tga.g)
    return 0;

  mips_elf_replace_bfd_got (abfd, to);
  return 1;
}

/* Attempt to merge GOT G, which belongs to ABFD.  Try to use as much
   as possible of the primary got, since it doesn't require explicit
   dynamic relocations, but don't use bfds that would reference global
   symbols out of the addressable range.  Failing the primary got,
   attempt to merge with the current got, or finish the current got
   and then make make the new got current.  */

static bfd_boolean
mips_elf_merge_got (bfd *abfd, struct mips_got_info *g,
		    struct mips_elf_got_per_bfd_arg *arg)
{
  unsigned int estimate;
  int result;

  if (!mips_elf_resolve_final_got_entries (arg->info, g))
    return FALSE;

  /* Work out the number of page, local and TLS entries.  */
  estimate = arg->max_pages;
  if (estimate > g->page_gotno)
    estimate = g->page_gotno;
  estimate += g->local_gotno + g->tls_gotno;

  /* We place TLS GOT entries after both locals and globals.  The globals
     for the primary GOT may overflow the normal GOT size limit, so be
     sure not to merge a GOT which requires TLS with the primary GOT in that
     case.  This doesn't affect non-primary GOTs.  */
  estimate += (g->tls_gotno > 0 ? arg->global_count : g->global_gotno);

  if (estimate <= arg->max_count)
    {
      /* If we don't have a primary GOT, use it as
	 a starting point for the primary GOT.  */
      if (!arg->primary)
	{
	  arg->primary = g;
	  return TRUE;
	}

      /* Try merging with the primary GOT.  */
      result = mips_elf_merge_got_with (abfd, g, arg->primary, arg);
      if (result >= 0)
	return result;
    }

  /* If we can merge with the last-created got, do it.  */
  if (arg->current)
    {
      result = mips_elf_merge_got_with (abfd, g, arg->current, arg);
      if (result >= 0)
	return result;
    }

  /* Well, we couldn't merge, so create a new GOT.  Don't check if it
     fits; if it turns out that it doesn't, we'll get relocation
     overflows anyway.  */
  g->next = arg->current;
  arg->current = g;

  return TRUE;
}

/* ENTRYP is a hash table entry for a mips_got_entry.  Set its gotidx
   to GOTIDX, duplicating the entry if it has already been assigned
   an index in a different GOT.  */

static bfd_boolean
mips_elf_set_gotidx (void **entryp, long gotidx)
{
  struct mips_got_entry *entry;

  entry = (struct mips_got_entry *) *entryp;
  if (entry->gotidx > 0)
    {
      struct mips_got_entry *new_entry;

      new_entry = bfd_alloc (entry->abfd, sizeof (*entry));
      if (!new_entry)
	return FALSE;

      *new_entry = *entry;
      *entryp = new_entry;
      entry = new_entry;
    }
  entry->gotidx = gotidx;
  return TRUE;
}

/* Set the TLS GOT index for the GOT entry in ENTRYP.  DATA points to a
   mips_elf_traverse_got_arg in which DATA->value is the size of one
   GOT entry.  Set DATA->g to null on failure.  */

static int
mips_elf_initialize_tls_index (void **entryp, void *data)
{
  struct mips_got_entry *entry;
  struct mips_elf_traverse_got_arg *arg;

  /* We're only interested in TLS symbols.  */
  entry = (struct mips_got_entry *) *entryp;
  if (entry->tls_type == GOT_TLS_NONE)
    return 1;

  arg = (struct mips_elf_traverse_got_arg *) data;
  if (!mips_elf_set_gotidx (entryp, arg->value * arg->g->tls_assigned_gotno))
    {
      arg->g = NULL;
      return 0;
    }

  /* Account for the entries we've just allocated.  */
  arg->g->tls_assigned_gotno += mips_tls_got_entries (entry->tls_type);
  return 1;
}

/* A htab_traverse callback for GOT entries, where DATA points to a
   mips_elf_traverse_got_arg.  Set the global_got_area of each global
   symbol to DATA->value.  */

static int
mips_elf_set_global_got_area (void **entryp, void *data)
{
  struct mips_got_entry *entry;
  struct mips_elf_traverse_got_arg *arg;

  entry = (struct mips_got_entry *) *entryp;
  arg = (struct mips_elf_traverse_got_arg *) data;
  if (entry->abfd != NULL
      && entry->symndx == -1
      && entry->d.h->global_got_area != GGA_NONE)
    entry->d.h->global_got_area = arg->value;
  return 1;
}

/* A htab_traverse callback for secondary GOT entries, where DATA points
   to a mips_elf_traverse_got_arg.  Assign GOT indices to global entries
   and record the number of relocations they require.  DATA->value is
   the size of one GOT entry.  Set DATA->g to null on failure.  */

static int
mips_elf_set_global_gotidx (void **entryp, void *data)
{
  struct mips_got_entry *entry;
  struct mips_elf_traverse_got_arg *arg;

  entry = (struct mips_got_entry *) *entryp;
  arg = (struct mips_elf_traverse_got_arg *) data;
  if (entry->abfd != NULL
      && entry->symndx == -1
      && entry->d.h->global_got_area != GGA_NONE)
    {
      if (!mips_elf_set_gotidx (entryp, arg->value * arg->g->assigned_gotno))
	{
	  arg->g = NULL;
	  return 0;
	}
      arg->g->assigned_gotno += 1;

      if (arg->info->shared
	  || (elf_hash_table (arg->info)->dynamic_sections_created
	      && entry->d.h->root.def_dynamic
	      && !entry->d.h->root.def_regular))
	arg->g->relocs += 1;
    }

  return 1;
}

/* A htab_traverse callback for GOT entries for which DATA is the
   bfd_link_info.  Forbid any global symbols from having traditional
   lazy-binding stubs.  */

static int
mips_elf_forbid_lazy_stubs (void **entryp, void *data)
{
  struct bfd_link_info *info;
  struct mips_elf_link_hash_table *htab;
  struct mips_got_entry *entry;

  entry = (struct mips_got_entry *) *entryp;
  info = (struct bfd_link_info *) data;
  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  if (entry->abfd != NULL
      && entry->symndx == -1
      && entry->d.h->needs_lazy_stub)
    {
      entry->d.h->needs_lazy_stub = FALSE;
      htab->lazy_stub_count--;
    }

  return 1;
}

/* Return the offset of an input bfd IBFD's GOT from the beginning of
   the primary GOT.  */
static bfd_vma
mips_elf_adjust_gp (bfd *abfd, struct mips_got_info *g, bfd *ibfd)
{
  if (!g->next)
    return 0;

  g = mips_elf_bfd_got (ibfd, FALSE);
  if (! g)
    return 0;

  BFD_ASSERT (g->next);

  g = g->next;

  return (g->local_gotno + g->global_gotno + g->tls_gotno)
    * MIPS_ELF_GOT_SIZE (abfd);
}

/* Turn a single GOT that is too big for 16-bit addressing into
   a sequence of GOTs, each one 16-bit addressable.  */

static bfd_boolean
mips_elf_multi_got (bfd *abfd, struct bfd_link_info *info,
		    asection *got, bfd_size_type pages)
{
  struct mips_elf_link_hash_table *htab;
  struct mips_elf_got_per_bfd_arg got_per_bfd_arg;
  struct mips_elf_traverse_got_arg tga;
  struct mips_got_info *g, *gg;
  unsigned int assign, needed_relocs;
  bfd *dynobj, *ibfd;

  dynobj = elf_hash_table (info)->dynobj;
  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  g = htab->got_info;

  got_per_bfd_arg.obfd = abfd;
  got_per_bfd_arg.info = info;
  got_per_bfd_arg.current = NULL;
  got_per_bfd_arg.primary = NULL;
  got_per_bfd_arg.max_count = ((MIPS_ELF_GOT_MAX_SIZE (info)
				/ MIPS_ELF_GOT_SIZE (abfd))
			       - htab->reserved_gotno);
  got_per_bfd_arg.max_pages = pages;
  /* The number of globals that will be included in the primary GOT.
     See the calls to mips_elf_set_global_got_area below for more
     information.  */
  got_per_bfd_arg.global_count = g->global_gotno;

  /* Try to merge the GOTs of input bfds together, as long as they
     don't seem to exceed the maximum GOT size, choosing one of them
     to be the primary GOT.  */
  for (ibfd = info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      gg = mips_elf_bfd_got (ibfd, FALSE);
      if (gg && !mips_elf_merge_got (ibfd, gg, &got_per_bfd_arg))
	return FALSE;
    }

  /* If we do not find any suitable primary GOT, create an empty one.  */
  if (got_per_bfd_arg.primary == NULL)
    g->next = mips_elf_create_got_info (abfd);
  else
    g->next = got_per_bfd_arg.primary;
  g->next->next = got_per_bfd_arg.current;

  /* GG is now the master GOT, and G is the primary GOT.  */
  gg = g;
  g = g->next;

  /* Map the output bfd to the primary got.  That's what we're going
     to use for bfds that use GOT16 or GOT_PAGE relocations that we
     didn't mark in check_relocs, and we want a quick way to find it.
     We can't just use gg->next because we're going to reverse the
     list.  */
  mips_elf_replace_bfd_got (abfd, g);

  /* Every symbol that is referenced in a dynamic relocation must be
     present in the primary GOT, so arrange for them to appear after
     those that are actually referenced.  */
  gg->reloc_only_gotno = gg->global_gotno - g->global_gotno;
  g->global_gotno = gg->global_gotno;

  tga.info = info;
  tga.value = GGA_RELOC_ONLY;
  htab_traverse (gg->got_entries, mips_elf_set_global_got_area, &tga);
  tga.value = GGA_NORMAL;
  htab_traverse (g->got_entries, mips_elf_set_global_got_area, &tga);

  /* Now go through the GOTs assigning them offset ranges.
     [assigned_gotno, local_gotno[ will be set to the range of local
     entries in each GOT.  We can then compute the end of a GOT by
     adding local_gotno to global_gotno.  We reverse the list and make
     it circular since then we'll be able to quickly compute the
     beginning of a GOT, by computing the end of its predecessor.  To
     avoid special cases for the primary GOT, while still preserving
     assertions that are valid for both single- and multi-got links,
     we arrange for the main got struct to have the right number of
     global entries, but set its local_gotno such that the initial
     offset of the primary GOT is zero.  Remember that the primary GOT
     will become the last item in the circular linked list, so it
     points back to the master GOT.  */
  gg->local_gotno = -g->global_gotno;
  gg->global_gotno = g->global_gotno;
  gg->tls_gotno = 0;
  assign = 0;
  gg->next = gg;

  do
    {
      struct mips_got_info *gn;

      assign += htab->reserved_gotno;
      g->assigned_gotno = assign;
      g->local_gotno += assign;
      g->local_gotno += (pages < g->page_gotno ? pages : g->page_gotno);
      assign = g->local_gotno + g->global_gotno + g->tls_gotno;

      /* Take g out of the direct list, and push it onto the reversed
	 list that gg points to.  g->next is guaranteed to be nonnull after
	 this operation, as required by mips_elf_initialize_tls_index. */
      gn = g->next;
      g->next = gg->next;
      gg->next = g;

      /* Set up any TLS entries.  We always place the TLS entries after
	 all non-TLS entries.  */
      g->tls_assigned_gotno = g->local_gotno + g->global_gotno;
      tga.g = g;
      tga.value = MIPS_ELF_GOT_SIZE (abfd);
      htab_traverse (g->got_entries, mips_elf_initialize_tls_index, &tga);
      if (!tga.g)
	return FALSE;
      BFD_ASSERT (g->tls_assigned_gotno == assign);

      /* Move onto the next GOT.  It will be a secondary GOT if nonull.  */
      g = gn;

      /* Forbid global symbols in every non-primary GOT from having
	 lazy-binding stubs.  */
      if (g)
	htab_traverse (g->got_entries, mips_elf_forbid_lazy_stubs, info);
    }
  while (g);

  got->size = assign * MIPS_ELF_GOT_SIZE (abfd);

  needed_relocs = 0;
  for (g = gg->next; g && g->next != gg; g = g->next)
    {
      unsigned int save_assign;

      /* Assign offsets to global GOT entries and count how many
	 relocations they need.  */
      save_assign = g->assigned_gotno;
      g->assigned_gotno = g->local_gotno;
      tga.info = info;
      tga.value = MIPS_ELF_GOT_SIZE (abfd);
      tga.g = g;
      htab_traverse (g->got_entries, mips_elf_set_global_gotidx, &tga);
      if (!tga.g)
	return FALSE;
      BFD_ASSERT (g->assigned_gotno == g->local_gotno + g->global_gotno);
      g->assigned_gotno = save_assign;

      if (info->shared)
	{
	  g->relocs += g->local_gotno - g->assigned_gotno;
	  BFD_ASSERT (g->assigned_gotno == g->next->local_gotno
		      + g->next->global_gotno
		      + g->next->tls_gotno
		      + htab->reserved_gotno);
	}
      needed_relocs += g->relocs;
    }
  needed_relocs += g->relocs;

  if (needed_relocs)
    mips_elf_allocate_dynamic_relocations (dynobj, info,
					   needed_relocs);

  return TRUE;
}


/* Returns the first relocation of type r_type found, beginning with
   RELOCATION.  RELEND is one-past-the-end of the relocation table.  */

static const Elf_Internal_Rela *
mips_elf_next_relocation (bfd *abfd ATTRIBUTE_UNUSED, unsigned int r_type,
			  const Elf_Internal_Rela *relocation,
			  const Elf_Internal_Rela *relend)
{
  unsigned long r_symndx = ELF_R_SYM (abfd, relocation->r_info);

  while (relocation < relend)
    {
      if (ELF_R_TYPE (abfd, relocation->r_info) == r_type
	  && ELF_R_SYM (abfd, relocation->r_info) == r_symndx)
	return relocation;

      ++relocation;
    }

  /* We didn't find it.  */
  return NULL;
}

/* Return whether an input relocation is against a local symbol.  */

static bfd_boolean
mips_elf_local_relocation_p (bfd *input_bfd,
			     const Elf_Internal_Rela *relocation,
			     asection **local_sections)
{
  unsigned long r_symndx;
  Elf_Internal_Shdr *symtab_hdr;
  size_t extsymoff;

  r_symndx = ELF_R_SYM (input_bfd, relocation->r_info);
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  extsymoff = (elf_bad_symtab (input_bfd)) ? 0 : symtab_hdr->sh_info;

  if (r_symndx < extsymoff)
    return TRUE;
  if (elf_bad_symtab (input_bfd) && local_sections[r_symndx] != NULL)
    return TRUE;

  return FALSE;
}

/* Sign-extend VALUE, which has the indicated number of BITS.  */

bfd_vma
_bfd_mips_elf_sign_extend (bfd_vma value, int bits)
{
  if (value & ((bfd_vma) 1 << (bits - 1)))
    /* VALUE is negative.  */
    value |= ((bfd_vma) - 1) << bits;

  return value;
}

/* Return non-zero if the indicated VALUE has overflowed the maximum
   range expressible by a signed number with the indicated number of
   BITS.  */

static bfd_boolean
mips_elf_overflow_p (bfd_vma value, int bits)
{
  bfd_signed_vma svalue = (bfd_signed_vma) value;

  if (svalue > (1 << (bits - 1)) - 1)
    /* The value is too big.  */
    return TRUE;
  else if (svalue < -(1 << (bits - 1)))
    /* The value is too small.  */
    return TRUE;

  /* All is well.  */
  return FALSE;
}

/* Calculate the %high function.  */

static bfd_vma
mips_elf_high (bfd_vma value)
{
  return ((value + (bfd_vma) 0x8000) >> 16) & 0xffff;
}

/* Calculate the %higher function.  */

static bfd_vma
mips_elf_higher (bfd_vma value ATTRIBUTE_UNUSED)
{
#ifdef BFD64
  return ((value + (bfd_vma) 0x80008000) >> 32) & 0xffff;
#else
  abort ();
  return MINUS_ONE;
#endif
}

/* Calculate the %highest function.  */

static bfd_vma
mips_elf_highest (bfd_vma value ATTRIBUTE_UNUSED)
{
#ifdef BFD64
  return ((value + (((bfd_vma) 0x8000 << 32) | 0x80008000)) >> 48) & 0xffff;
#else
  abort ();
  return MINUS_ONE;
#endif
}

/* Create the .compact_rel section.  */

static bfd_boolean
mips_elf_create_compact_rel_section
  (bfd *abfd, struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  flagword flags;
  register asection *s;

  if (bfd_get_linker_section (abfd, ".compact_rel") == NULL)
    {
      flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED
	       | SEC_READONLY);

      s = bfd_make_section_anyway_with_flags (abfd, ".compact_rel", flags);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return FALSE;

      s->size = sizeof (Elf32_External_compact_rel);
    }

  return TRUE;
}

/* Create the .got section to hold the global offset table.  */

static bfd_boolean
mips_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags;
  register asection *s;
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  /* This function may be called more than once.  */
  if (htab->sgot)
    return TRUE;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  /* We have to use an alignment of 2**4 here because this is hardcoded
     in the function stub generation and in the linker script.  */
  s = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, 4))
    return FALSE;
  htab->sgot = s;

  /* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the
     linker script because we don't want to define the symbol if we
     are not creating a global offset table.  */
  bh = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	  0, NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;

  h = (struct elf_link_hash_entry *) bh;
  h->non_elf = 0;
  h->def_regular = 1;
  h->type = STT_OBJECT;
  h->other = (h->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;
  elf_hash_table (info)->hgot = h;

  if (info->shared
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

  htab->got_info = mips_elf_create_got_info (abfd);
  mips_elf_section_data (s)->elf.this_hdr.sh_flags
    |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;

  /* We also need a .got.plt section when generating PLTs.  */
  s = bfd_make_section_anyway_with_flags (abfd, ".got.plt",
					  SEC_ALLOC | SEC_LOAD
					  | SEC_HAS_CONTENTS
					  | SEC_IN_MEMORY
					  | SEC_LINKER_CREATED);
  if (s == NULL)
    return FALSE;
  htab->sgotplt = s;

  return TRUE;
}

/* Return true if H refers to the special VxWorks __GOTT_BASE__ or
   __GOTT_INDEX__ symbols.  These symbols are only special for
   shared objects; they are not used in executables.  */

static bfd_boolean
is_gott_symbol (struct bfd_link_info *info, struct elf_link_hash_entry *h)
{
  return (mips_elf_hash_table (info)->is_vxworks
	  && info->shared
	  && (strcmp (h->root.root.string, "__GOTT_BASE__") == 0
	      || strcmp (h->root.root.string, "__GOTT_INDEX__") == 0));
}

/* Return TRUE if a relocation of type R_TYPE from INPUT_BFD might
   require an la25 stub.  See also mips_elf_local_pic_function_p,
   which determines whether the destination function ever requires a
   stub.  */

static bfd_boolean
mips_elf_relocation_needs_la25_stub (bfd *input_bfd, int r_type,
				     bfd_boolean target_is_16_bit_code_p)
{
  /* We specifically ignore branches and jumps from EF_PIC objects,
     where the onus is on the compiler or programmer to perform any
     necessary initialization of $25.  Sometimes such initialization
     is unnecessary; for example, -mno-shared functions do not use
     the incoming value of $25, and may therefore be called directly.  */
  if (PIC_OBJECT_P (input_bfd))
    return FALSE;

  switch (r_type)
    {
    case R_MIPS_26:
    case R_MIPS_PC16:
    case R_MICROMIPS_26_S1:
    case R_MICROMIPS_PC7_S1:
    case R_MICROMIPS_PC10_S1:
    case R_MICROMIPS_PC16_S1:
    case R_MICROMIPS_PC23_S2:
      return TRUE;

    case R_MIPS16_26:
      return !target_is_16_bit_code_p;

    default:
      return FALSE;
    }
}

/* Calculate the value produced by the RELOCATION (which comes from
   the INPUT_BFD).  The ADDEND is the addend to use for this
   RELOCATION; RELOCATION->R_ADDEND is ignored.

   The result of the relocation calculation is stored in VALUEP.
   On exit, set *CROSS_MODE_JUMP_P to true if the relocation field
   is a MIPS16 or microMIPS jump to standard MIPS code, or vice versa.

   This function returns bfd_reloc_continue if the caller need take no
   further action regarding this relocation, bfd_reloc_notsupported if
   something goes dramatically wrong, bfd_reloc_overflow if an
   overflow occurs, and bfd_reloc_ok to indicate success.  */

static bfd_reloc_status_type
mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
			       asection *input_section,
			       struct bfd_link_info *info,
			       const Elf_Internal_Rela *relocation,
			       bfd_vma addend, reloc_howto_type *howto,
			       Elf_Internal_Sym *local_syms,
			       asection **local_sections, bfd_vma *valuep,
			       const char **namep,
			       bfd_boolean *cross_mode_jump_p,
			       bfd_boolean save_addend)
{
  /* The eventual value we will return.  */
  bfd_vma value;
  /* The address of the symbol against which the relocation is
     occurring.  */
  bfd_vma symbol = 0;
  /* The final GP value to be used for the relocatable, executable, or
     shared object file being produced.  */
  bfd_vma gp;
  /* The place (section offset or address) of the storage unit being
     relocated.  */
  bfd_vma p;
  /* The value of GP used to create the relocatable object.  */
  bfd_vma gp0;
  /* The offset into the global offset table at which the address of
     the relocation entry symbol, adjusted by the addend, resides
     during execution.  */
  bfd_vma g = MINUS_ONE;
  /* The section in which the symbol referenced by the relocation is
     located.  */
  asection *sec = NULL;
  struct mips_elf_link_hash_entry *h = NULL;
  /* TRUE if the symbol referred to by this relocation is a local
     symbol.  */
  bfd_boolean local_p, was_local_p;
  /* TRUE if the symbol referred to by this relocation is "_gp_disp".  */
  bfd_boolean gp_disp_p = FALSE;
  /* TRUE if the symbol referred to by this relocation is
     "__gnu_local_gp".  */
  bfd_boolean gnu_local_gp_p = FALSE;
  Elf_Internal_Shdr *symtab_hdr;
  size_t extsymoff;
  unsigned long r_symndx;
  int r_type;
  /* TRUE if overflow occurred during the calculation of the
     relocation value.  */
  bfd_boolean overflowed_p;
  /* TRUE if this relocation refers to a MIPS16 function.  */
  bfd_boolean target_is_16_bit_code_p = FALSE;
  bfd_boolean target_is_micromips_code_p = FALSE;
  struct mips_elf_link_hash_table *htab;
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;
  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  /* Parse the relocation.  */
  r_symndx = ELF_R_SYM (input_bfd, relocation->r_info);
  r_type = ELF_R_TYPE (input_bfd, relocation->r_info);
  p = (input_section->output_section->vma
       + input_section->output_offset
       + relocation->r_offset);

  /* Assume that there will be no overflow.  */
  overflowed_p = FALSE;

  /* Figure out whether or not the symbol is local, and get the offset
     used in the array of hash table entries.  */
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  local_p = mips_elf_local_relocation_p (input_bfd, relocation,
					 local_sections);
  was_local_p = local_p;
  if (! elf_bad_symtab (input_bfd))
    extsymoff = symtab_hdr->sh_info;
  else
    {
      /* The symbol table does not follow the rule that local symbols
	 must come before globals.  */
      extsymoff = 0;
    }

  /* Figure out the value of the symbol.  */
  if (local_p)
    {
      Elf_Internal_Sym *sym;

      sym = local_syms + r_symndx;
      sec = local_sections[r_symndx];

      symbol = sec->output_section->vma + sec->output_offset;
      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION
	  || (sec->flags & SEC_MERGE))
	symbol += sym->st_value;
      if ((sec->flags & SEC_MERGE)
	  && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	{
	  addend = _bfd_elf_rel_local_sym (abfd, sym, &sec, addend);
	  addend -= symbol;
	  addend += sec->output_section->vma + sec->output_offset;
	}

      /* MIPS16/microMIPS text labels should be treated as odd.  */
      if (ELF_ST_IS_COMPRESSED (sym->st_other))
	++symbol;

      /* Record the name of this symbol, for our caller.  */
      *namep = bfd_elf_string_from_elf_section (input_bfd,
						symtab_hdr->sh_link,
						sym->st_name);
      if (*namep == '\0')
	*namep = bfd_section_name (input_bfd, sec);

      target_is_16_bit_code_p = ELF_ST_IS_MIPS16 (sym->st_other);
      target_is_micromips_code_p = ELF_ST_IS_MICROMIPS (sym->st_other);
    }
  else
    {
      /* ??? Could we use RELOC_FOR_GLOBAL_SYMBOL here ?  */

      /* For global symbols we look up the symbol in the hash-table.  */
      h = ((struct mips_elf_link_hash_entry *)
	   elf_sym_hashes (input_bfd) [r_symndx - extsymoff]);
      /* Find the real hash-table entry for this symbol.  */
      while (h->root.root.type == bfd_link_hash_indirect
	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

      /* Record the name of this symbol, for our caller.  */
      *namep = h->root.root.root.string;

      /* See if this is the special _gp_disp symbol.  Note that such a
	 symbol must always be a global symbol.  */
      if (strcmp (*namep, "_gp_disp") == 0
	  && ! NEWABI_P (input_bfd))
	{
	  /* Relocations against _gp_disp are permitted only with
	     R_MIPS_HI16 and R_MIPS_LO16 relocations.  */
	  if (!hi16_reloc_p (r_type) && !lo16_reloc_p (r_type))
	    return bfd_reloc_notsupported;

	  gp_disp_p = TRUE;
	}
      /* See if this is the special _gp symbol.  Note that such a
	 symbol must always be a global symbol.  */
      else if (strcmp (*namep, "__gnu_local_gp") == 0)
	gnu_local_gp_p = TRUE;


      /* If this symbol is defined, calculate its address.  Note that
	 _gp_disp is a magic symbol, always implicitly defined by the
	 linker, so it's inappropriate to check to see whether or not
	 its defined.  */
      else if ((h->root.root.type == bfd_link_hash_defined
		|| h->root.root.type == bfd_link_hash_defweak)
	       && h->root.root.u.def.section)
	{
	  sec = h->root.root.u.def.section;
	  if (sec->output_section)
	    symbol = (h->root.root.u.def.value
		      + sec->output_section->vma
		      + sec->output_offset);
	  else
	    symbol = h->root.root.u.def.value;
	}
      else if (h->root.root.type == bfd_link_hash_undefweak)
	/* We allow relocations against undefined weak symbols, giving
	   it the value zero, so that you can undefined weak functions
	   and check to see if they exist by looking at their
	   addresses.  */
	symbol = 0;
      else if (info->unresolved_syms_in_objects == RM_IGNORE
	       && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
	symbol = 0;
      else if (strcmp (*namep, SGI_COMPAT (input_bfd)
		       ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING") == 0)
	{
	  /* If this is a dynamic link, we should have created a
	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal mips) symbol
	     in in _bfd_mips_elf_create_dynamic_sections.
	     Otherwise, we should define the symbol with a value of 0.
	     FIXME: It should probably get into the symbol table
	     somehow as well.  */
	  BFD_ASSERT (! info->shared);
	  BFD_ASSERT (bfd_get_section_by_name (abfd, ".dynamic") == NULL);
	  symbol = 0;
	}
      else if (ELF_MIPS_IS_OPTIONAL (h->root.other))
	{
	  /* This is an optional symbol - an Irix specific extension to the
	     ELF spec.  Ignore it for now.
	     XXX - FIXME - there is more to the spec for OPTIONAL symbols
	     than simply ignoring them, but we do not handle this for now.
	     For information see the "64-bit ELF Object File Specification"
	     which is available from here:
	     http://techpubs.sgi.com/library/manuals/4000/007-4658-001/pdf/007-4658-001.pdf  */
	  symbol = 0;
	}
      else if ((*info->callbacks->undefined_symbol)
	       (info, h->root.root.root.string, input_bfd,
		input_section, relocation->r_offset,
		(info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
		 || ELF_ST_VISIBILITY (h->root.other)))
	{
	  return bfd_reloc_undefined;
	}
      else
	{
	  return bfd_reloc_notsupported;
	}

      target_is_16_bit_code_p = ELF_ST_IS_MIPS16 (h->root.other);
      target_is_micromips_code_p = ELF_ST_IS_MICROMIPS (h->root.other);
    }

  /* If this is a reference to a 16-bit function with a stub, we need
     to redirect the relocation to the stub unless:

     (a) the relocation is for a MIPS16 JAL;

     (b) the relocation is for a MIPS16 PIC call, and there are no
	 non-MIPS16 uses of the GOT slot; or

     (c) the section allows direct references to MIPS16 functions.  */
  if (r_type != R_MIPS16_26
      && !info->relocatable
      && ((h != NULL
	   && h->fn_stub != NULL
	   && (r_type != R_MIPS16_CALL16 || h->need_fn_stub))
	  || (local_p
	      && mips_elf_tdata (input_bfd)->local_stubs != NULL
	      && mips_elf_tdata (input_bfd)->local_stubs[r_symndx] != NULL))
      && !section_allows_mips16_refs_p (input_section))
    {
      /* This is a 32- or 64-bit call to a 16-bit function.  We should
	 have already noticed that we were going to need the
	 stub.  */
      if (local_p)
	{
	  sec = mips_elf_tdata (input_bfd)->local_stubs[r_symndx];
	  value = 0;
	}
      else
	{
	  BFD_ASSERT (h->need_fn_stub);
	  if (h->la25_stub)
	    {
	      /* If a LA25 header for the stub itself exists, point to the
		 prepended LUI/ADDIU sequence.  */
	      sec = h->la25_stub->stub_section;
	      value = h->la25_stub->offset;
	    }
	  else
	    {
	      sec = h->fn_stub;
	      value = 0;
	    }
	}

      symbol = sec->output_section->vma + sec->output_offset + value;
      /* The target is 16-bit, but the stub isn't.  */
      target_is_16_bit_code_p = FALSE;
    }
  /* If this is a MIPS16 call with a stub, that is made through the PLT or
     to a standard MIPS function, we need to redirect the call to the stub.
     Note that we specifically exclude R_MIPS16_CALL16 from this behavior;
     indirect calls should use an indirect stub instead.  */
  else if (r_type == R_MIPS16_26 && !info->relocatable
	   && ((h != NULL && (h->call_stub != NULL || h->call_fp_stub != NULL))
	       || (local_p
		   && mips_elf_tdata (input_bfd)->local_call_stubs != NULL
		   && mips_elf_tdata (input_bfd)->local_call_stubs[r_symndx] != NULL))
	   && ((h != NULL && h->use_plt_entry) || !target_is_16_bit_code_p))
    {
      if (local_p)
	sec = mips_elf_tdata (input_bfd)->local_call_stubs[r_symndx];
      else
	{
	  /* If both call_stub and call_fp_stub are defined, we can figure
	     out which one to use by checking which one appears in the input
	     file.  */
	  if (h->call_stub != NULL && h->call_fp_stub != NULL)
	    {
	      asection *o;

	      sec = NULL;
	      for (o = input_bfd->sections; o != NULL; o = o->next)
		{
		  if (CALL_FP_STUB_P (bfd_get_section_name (input_bfd, o)))
		    {
		      sec = h->call_fp_stub;
		      break;
		    }
		}
	      if (sec == NULL)
		sec = h->call_stub;
	    }
	  else if (h->call_stub != NULL)
	    sec = h->call_stub;
	  else
	    sec = h->call_fp_stub;
  	}

      BFD_ASSERT (sec->size > 0);
      symbol = sec->output_section->vma + sec->output_offset;
    }
  /* If this is a direct call to a PIC function, redirect to the
     non-PIC stub.  */
  else if (h != NULL && h->la25_stub
	   && mips_elf_relocation_needs_la25_stub (input_bfd, r_type,
						   target_is_16_bit_code_p))
    symbol = (h->la25_stub->stub_section->output_section->vma
	      + h->la25_stub->stub_section->output_offset
	      + h->la25_stub->offset);
  /* For direct MIPS16 and microMIPS calls make sure the compressed PLT
     entry is used if a standard PLT entry has also been made.  In this
     case the symbol will have been set by mips_elf_set_plt_sym_value
     to point to the standard PLT entry, so redirect to the compressed
     one.  */
  else if ((r_type == R_MIPS16_26 || r_type == R_MICROMIPS_26_S1)
	   && !info->relocatable
	   && h != NULL
	   && h->use_plt_entry
	   && h->root.plt.plist->comp_offset != MINUS_ONE
	   && h->root.plt.plist->mips_offset != MINUS_ONE)
    {
      bfd_boolean micromips_p = MICROMIPS_P (abfd);

      sec = htab->splt;
      symbol = (sec->output_section->vma
		+ sec->output_offset
		+ htab->plt_header_size
		+ htab->plt_mips_offset
		+ h->root.plt.plist->comp_offset
		+ 1);

      target_is_16_bit_code_p = !micromips_p;
      target_is_micromips_code_p = micromips_p;
    }

  /* Make sure MIPS16 and microMIPS are not used together.  */
  if ((r_type == R_MIPS16_26 && target_is_micromips_code_p)
      || (micromips_branch_reloc_p (r_type) && target_is_16_bit_code_p))
   {
      (*_bfd_error_handler)
	(_("MIPS16 and microMIPS functions cannot call each other"));
      return bfd_reloc_notsupported;
   }

  /* Calls from 16-bit code to 32-bit code and vice versa require the
     mode change.  However, we can ignore calls to undefined weak symbols,
     which should never be executed at runtime.  This exception is important
     because the assembly writer may have "known" that any definition of the
     symbol would be 16-bit code, and that direct jumps were therefore
     acceptable.  */
  *cross_mode_jump_p = (!info->relocatable
			&& !(h && h->root.root.type == bfd_link_hash_undefweak)
			&& ((r_type == R_MIPS16_26 && !target_is_16_bit_code_p)
			    || (r_type == R_MICROMIPS_26_S1
				&& !target_is_micromips_code_p)
			    || ((r_type == R_MIPS_26 || r_type == R_MIPS_JALR)
				&& (target_is_16_bit_code_p
				    || target_is_micromips_code_p))));

  local_p = (h == NULL || mips_use_local_got_p (info, h));

  gp0 = _bfd_get_gp_value (input_bfd);
  gp = _bfd_get_gp_value (abfd);
  if (htab->got_info)
    gp += mips_elf_adjust_gp (abfd, htab->got_info, input_bfd);

  if (gnu_local_gp_p)
    symbol = gp;

  /* Global R_MIPS_GOT_PAGE/R_MICROMIPS_GOT_PAGE relocations are equivalent
     to R_MIPS_GOT_DISP/R_MICROMIPS_GOT_DISP.  The addend is applied by the
     corresponding R_MIPS_GOT_OFST/R_MICROMIPS_GOT_OFST.  */
  if (got_page_reloc_p (r_type) && !local_p)
    {
      r_type = (micromips_reloc_p (r_type)
		? R_MICROMIPS_GOT_DISP : R_MIPS_GOT_DISP);
      addend = 0;
    }

  /* If we haven't already determined the GOT offset, and we're going
     to need it, get it now.  */
  switch (r_type)
    {
    case R_MIPS16_CALL16:
    case R_MIPS16_GOT16:
    case R_MIPS_CALL16:
    case R_MIPS_GOT16:
    case R_MIPS_GOT_DISP:
    case R_MIPS_GOT_HI16:
    case R_MIPS_CALL_HI16:
    case R_MIPS_GOT_LO16:
    case R_MIPS_CALL_LO16:
    case R_MICROMIPS_CALL16:
    case R_MICROMIPS_GOT16:
    case R_MICROMIPS_GOT_DISP:
    case R_MICROMIPS_GOT_HI16:
    case R_MICROMIPS_CALL_HI16:
    case R_MICROMIPS_GOT_LO16:
    case R_MICROMIPS_CALL_LO16:
    case R_MIPS_TLS_GD:
    case R_MIPS_TLS_GOTTPREL:
    case R_MIPS_TLS_LDM:
    case R_MIPS16_TLS_GD:
    case R_MIPS16_TLS_GOTTPREL:
    case R_MIPS16_TLS_LDM:
    case R_MICROMIPS_TLS_GD:
    case R_MICROMIPS_TLS_GOTTPREL:
    case R_MICROMIPS_TLS_LDM:
      /* Find the index into the GOT where this value is located.  */
      if (tls_ldm_reloc_p (r_type))
	{
	  g = mips_elf_local_got_index (abfd, input_bfd, info,
					0, 0, NULL, r_type);
	  if (g == MINUS_ONE)
	    return bfd_reloc_outofrange;
	}
      else if (!local_p)
	{
	  /* On VxWorks, CALL relocations should refer to the .got.plt
	     entry, which is initialized to point at the PLT stub.  */
	  if (htab->is_vxworks
	      && (call_hi16_reloc_p (r_type)
		  || call_lo16_reloc_p (r_type)
		  || call16_reloc_p (r_type)))
	    {
	      BFD_ASSERT (addend == 0);
	      BFD_ASSERT (h->root.needs_plt);
	      g = mips_elf_gotplt_index (info, &h->root);
	    }
	  else
	    {
	      BFD_ASSERT (addend == 0);
	      g = mips_elf_global_got_index (abfd, info, input_bfd,
					     &h->root, r_type);
	      if (!TLS_RELOC_P (r_type)
		  && !elf_hash_table (info)->dynamic_sections_created)
		/* This is a static link.  We must initialize the GOT entry.  */
		MIPS_ELF_PUT_WORD (dynobj, symbol, htab->sgot->contents + g);
	    }
	}
      else if (!htab->is_vxworks
	       && (call16_reloc_p (r_type) || got16_reloc_p (r_type)))
	/* The calculation below does not involve "g".  */
	break;
      else
	{
	  g = mips_elf_local_got_index (abfd, input_bfd, info,
					symbol + addend, r_symndx, h, r_type);
	  if (g == MINUS_ONE)
	    return bfd_reloc_outofrange;
	}

      /* Convert GOT indices to actual offsets.  */
      g = mips_elf_got_offset_from_index (info, abfd, input_bfd, g);
      break;
    }

  /* Relocations against the VxWorks __GOTT_BASE__ and __GOTT_INDEX__
     symbols are resolved by the loader.  Add them to .rela.dyn.  */
  if (h != NULL && is_gott_symbol (info, &h->root))
    {
      Elf_Internal_Rela outrel;
      bfd_byte *loc;
      asection *s;

      s = mips_elf_rel_dyn_section (info, FALSE);
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);

      outrel.r_offset = (input_section->output_section->vma
			 + input_section->output_offset
			 + relocation->r_offset);
      outrel.r_info = ELF32_R_INFO (h->root.dynindx, r_type);
      outrel.r_addend = addend;
      bfd_elf32_swap_reloca_out (abfd, &outrel, loc);

      /* If we've written this relocation for a readonly section,
	 we need to set DF_TEXTREL again, so that we do not delete the
	 DT_TEXTREL tag.  */
      if (MIPS_ELF_READONLY_SECTION (input_section))
	info->flags |= DF_TEXTREL;

      *valuep = 0;
      return bfd_reloc_ok;
    }

  /* Figure out what kind of relocation is being performed.  */
  switch (r_type)
    {
    case R_MIPS_NONE:
      return bfd_reloc_continue;

    case R_MIPS_16:
      value = symbol + _bfd_mips_elf_sign_extend (addend, 16);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_32:
    case R_MIPS_REL32:
    case R_MIPS_64:
      if ((info->shared
	   || (htab->root.dynamic_sections_created
	       && h != NULL
	       && h->root.def_dynamic
	       && !h->root.def_regular
	       && !h->has_static_relocs))
	  && r_symndx != STN_UNDEF
	  && (h == NULL
	      || h->root.root.type != bfd_link_hash_undefweak
	      || ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
	  && (input_section->flags & SEC_ALLOC) != 0)
	{
	  /* If we're creating a shared library, then we can't know
	     where the symbol will end up.  So, we create a relocation
	     record in the output, and leave the job up to the dynamic
	     linker.  We must do the same for executable references to
	     shared library symbols, unless we've decided to use copy
	     relocs or PLTs instead.  */
	  value = addend;
	  if (!mips_elf_create_dynamic_relocation (abfd,
						   info,
						   relocation,
						   h,
						   sec,
						   symbol,
						   &value,
						   input_section))
	    return bfd_reloc_undefined;
	}
      else
	{
	  if (r_type != R_MIPS_REL32)
	    value = symbol + addend;
	  else
	    value = addend;
	}
      value &= howto->dst_mask;
      break;

    case R_MIPS_PC32:
      value = symbol + addend - p;
      value &= howto->dst_mask;
      break;

    case R_MIPS16_26:
      /* The calculation for R_MIPS16_26 is just the same as for an
	 R_MIPS_26.  It's only the storage of the relocated field into
	 the output file that's different.  That's handled in
	 mips_elf_perform_relocation.  So, we just fall through to the
	 R_MIPS_26 case here.  */
    case R_MIPS_26:
    case R_MICROMIPS_26_S1:
      {
	unsigned int shift;

	/* Make sure the target of JALX is word-aligned.  Bit 0 must be
	   the correct ISA mode selector and bit 1 must be 0.  */
	if (*cross_mode_jump_p && (symbol & 3) != (r_type == R_MIPS_26))
	  return bfd_reloc_outofrange;

	/* Shift is 2, unusually, for microMIPS JALX.  */
	shift = (!*cross_mode_jump_p && r_type == R_MICROMIPS_26_S1) ? 1 : 2;

	if (was_local_p)
	  value = addend | ((p + 4) & (0xfc000000 << shift));
	else
	  value = _bfd_mips_elf_sign_extend (addend, 26 + shift);
	value = (value + symbol) >> shift;
	if (!was_local_p && h->root.root.type != bfd_link_hash_undefweak)
	  overflowed_p = (value >> 26) != ((p + 4) >> (26 + shift));
	value &= howto->dst_mask;
      }
      break;

    case R_MIPS_TLS_DTPREL_HI16:
    case R_MIPS16_TLS_DTPREL_HI16:
    case R_MICROMIPS_TLS_DTPREL_HI16:
      value = (mips_elf_high (addend + symbol - dtprel_base (info))
	       & howto->dst_mask);
      break;

    case R_MIPS_TLS_DTPREL_LO16:
    case R_MIPS_TLS_DTPREL32:
    case R_MIPS_TLS_DTPREL64:
    case R_MIPS16_TLS_DTPREL_LO16:
    case R_MICROMIPS_TLS_DTPREL_LO16:
      value = (symbol + addend - dtprel_base (info)) & howto->dst_mask;
      break;

    case R_MIPS_TLS_TPREL_HI16:
    case R_MIPS16_TLS_TPREL_HI16:
    case R_MICROMIPS_TLS_TPREL_HI16:
      value = (mips_elf_high (addend + symbol - tprel_base (info))
	       & howto->dst_mask);
      break;

    case R_MIPS_TLS_TPREL_LO16:
    case R_MIPS_TLS_TPREL32:
    case R_MIPS_TLS_TPREL64:
    case R_MIPS16_TLS_TPREL_LO16:
    case R_MICROMIPS_TLS_TPREL_LO16:
      value = (symbol + addend - tprel_base (info)) & howto->dst_mask;
      break;

    case R_MIPS_HI16:
    case R_MIPS16_HI16:
    case R_MICROMIPS_HI16:
      if (!gp_disp_p)
	{
	  value = mips_elf_high (addend + symbol);
	  value &= howto->dst_mask;
	}
      else
	{
	  /* For MIPS16 ABI code we generate this sequence
	        0: li      $v0,%hi(_gp_disp)
	        4: addiupc $v1,%lo(_gp_disp)
	        8: sll     $v0,16
	       12: addu    $v0,$v1
	       14: move    $gp,$v0
	     So the offsets of hi and lo relocs are the same, but the
	     base $pc is that used by the ADDIUPC instruction at $t9 + 4.
	     ADDIUPC clears the low two bits of the instruction address,
	     so the base is ($t9 + 4) & ~3.  */
	  if (r_type == R_MIPS16_HI16)
	    value = mips_elf_high (addend + gp - ((p + 4) & ~(bfd_vma) 0x3));
	  /* The microMIPS .cpload sequence uses the same assembly
	     instructions as the traditional psABI version, but the
	     incoming $t9 has the low bit set.  */
	  else if (r_type == R_MICROMIPS_HI16)
	    value = mips_elf_high (addend + gp - p - 1);
	  else
	    value = mips_elf_high (addend + gp - p);
	  overflowed_p = mips_elf_overflow_p (value, 16);
	}
      break;

    case R_MIPS_LO16:
    case R_MIPS16_LO16:
    case R_MICROMIPS_LO16:
    case R_MICROMIPS_HI0_LO16:
      if (!gp_disp_p)
	value = (symbol + addend) & howto->dst_mask;
      else
	{
	  /* See the comment for R_MIPS16_HI16 above for the reason
	     for this conditional.  */
	  if (r_type == R_MIPS16_LO16)
	    value = addend + gp - (p & ~(bfd_vma) 0x3);
	  else if (r_type == R_MICROMIPS_LO16
		   || r_type == R_MICROMIPS_HI0_LO16)
	    value = addend + gp - p + 3;
	  else
	    value = addend + gp - p + 4;
	  /* The MIPS ABI requires checking the R_MIPS_LO16 relocation
	     for overflow.  But, on, say, IRIX5, relocations against
	     _gp_disp are normally generated from the .cpload
	     pseudo-op.  It generates code that normally looks like
	     this:

	       lui    $gp,%hi(_gp_disp)
	       addiu  $gp,$gp,%lo(_gp_disp)
	       addu   $gp,$gp,$t9

	     Here $t9 holds the address of the function being called,
	     as required by the MIPS ELF ABI.  The R_MIPS_LO16
	     relocation can easily overflow in this situation, but the
	     R_MIPS_HI16 relocation will handle the overflow.
	     Therefore, we consider this a bug in the MIPS ABI, and do
	     not check for overflow here.  */
	}
      break;

    case R_MIPS_LITERAL:
    case R_MICROMIPS_LITERAL:
      /* Because we don't merge literal sections, we can handle this
	 just like R_MIPS_GPREL16.  In the long run, we should merge
	 shared literals, and then we will need to additional work
	 here.  */

      /* Fall through.  */

    case R_MIPS16_GPREL:
      /* The R_MIPS16_GPREL performs the same calculation as
	 R_MIPS_GPREL16, but stores the relocated bits in a different
	 order.  We don't need to do anything special here; the
	 differences are handled in mips_elf_perform_relocation.  */
    case R_MIPS_GPREL16:
    case R_MICROMIPS_GPREL7_S2:
    case R_MICROMIPS_GPREL16:
      /* Only sign-extend the addend if it was extracted from the
	 instruction.  If the addend was separate, leave it alone,
	 otherwise we may lose significant bits.  */
      if (howto->partial_inplace)
	addend = _bfd_mips_elf_sign_extend (addend, 16);
      value = symbol + addend - gp;
      /* If the symbol was local, any earlier relocatable links will
	 have adjusted its addend with the gp offset, so compensate
	 for that now.  Don't do it for symbols forced local in this
	 link, though, since they won't have had the gp offset applied
	 to them before.  */
      if (was_local_p)
	value += gp0;
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS16_GOT16:
    case R_MIPS16_CALL16:
    case R_MIPS_GOT16:
    case R_MIPS_CALL16:
    case R_MICROMIPS_GOT16:
    case R_MICROMIPS_CALL16:
      /* VxWorks does not have separate local and global semantics for
	 R_MIPS*_GOT16; every relocation evaluates to "G".  */
      if (!htab->is_vxworks && local_p)
	{
	  value = mips_elf_got16_entry (abfd, input_bfd, info,
					symbol + addend, !was_local_p);
	  if (value == MINUS_ONE)
	    return bfd_reloc_outofrange;
	  value
	    = mips_elf_got_offset_from_index (info, abfd, input_bfd, value);
	  overflowed_p = mips_elf_overflow_p (value, 16);
	  break;
	}

      /* Fall through.  */

    case R_MIPS_TLS_GD:
    case R_MIPS_TLS_GOTTPREL:
    case R_MIPS_TLS_LDM:
    case R_MIPS_GOT_DISP:
    case R_MIPS16_TLS_GD:
    case R_MIPS16_TLS_GOTTPREL:
    case R_MIPS16_TLS_LDM:
    case R_MICROMIPS_TLS_GD:
    case R_MICROMIPS_TLS_GOTTPREL:
    case R_MICROMIPS_TLS_LDM:
    case R_MICROMIPS_GOT_DISP:
      value = g;
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_GPREL32:
      value = (addend + symbol + gp0 - gp);
      if (!save_addend)
	value &= howto->dst_mask;
      break;

    case R_MIPS_PC16:
    case R_MIPS_GNU_REL16_S2:
      value = symbol + _bfd_mips_elf_sign_extend (addend, 18) - p;
      overflowed_p = mips_elf_overflow_p (value, 18);
      value >>= howto->rightshift;
      value &= howto->dst_mask;
      break;

    case R_MICROMIPS_PC7_S1:
      value = symbol + _bfd_mips_elf_sign_extend (addend, 8) - p;
      overflowed_p = mips_elf_overflow_p (value, 8);
      value >>= howto->rightshift;
      value &= howto->dst_mask;
      break;

    case R_MICROMIPS_PC10_S1:
      value = symbol + _bfd_mips_elf_sign_extend (addend, 11) - p;
      overflowed_p = mips_elf_overflow_p (value, 11);
      value >>= howto->rightshift;
      value &= howto->dst_mask;
      break;

    case R_MICROMIPS_PC16_S1:
      value = symbol + _bfd_mips_elf_sign_extend (addend, 17) - p;
      overflowed_p = mips_elf_overflow_p (value, 17);
      value >>= howto->rightshift;
      value &= howto->dst_mask;
      break;

    case R_MICROMIPS_PC23_S2:
      value = symbol + _bfd_mips_elf_sign_extend (addend, 25) - ((p | 3) ^ 3);
      overflowed_p = mips_elf_overflow_p (value, 25);
      value >>= howto->rightshift;
      value &= howto->dst_mask;
      break;

    case R_MIPS_GOT_HI16:
    case R_MIPS_CALL_HI16:
    case R_MICROMIPS_GOT_HI16:
    case R_MICROMIPS_CALL_HI16:
      /* We're allowed to handle these two relocations identically.
	 The dynamic linker is allowed to handle the CALL relocations
	 differently by creating a lazy evaluation stub.  */
      value = g;
      value = mips_elf_high (value);
      value &= howto->dst_mask;
      break;

    case R_MIPS_GOT_LO16:
    case R_MIPS_CALL_LO16:
    case R_MICROMIPS_GOT_LO16:
    case R_MICROMIPS_CALL_LO16:
      value = g & howto->dst_mask;
      break;

    case R_MIPS_GOT_PAGE:
    case R_MICROMIPS_GOT_PAGE:
      value = mips_elf_got_page (abfd, input_bfd, info, symbol + addend, NULL);
      if (value == MINUS_ONE)
	return bfd_reloc_outofrange;
      value = mips_elf_got_offset_from_index (info, abfd, input_bfd, value);
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_GOT_OFST:
    case R_MICROMIPS_GOT_OFST:
      if (local_p)
	mips_elf_got_page (abfd, input_bfd, info, symbol + addend, &value);
      else
	value = addend;
      overflowed_p = mips_elf_overflow_p (value, 16);
      break;

    case R_MIPS_SUB:
    case R_MICROMIPS_SUB:
      value = symbol - addend;
      value &= howto->dst_mask;
      break;

    case R_MIPS_HIGHER:
    case R_MICROMIPS_HIGHER:
      value = mips_elf_higher (addend + symbol);
      value &= howto->dst_mask;
      break;

    case R_MIPS_HIGHEST:
    case R_MICROMIPS_HIGHEST:
      value = mips_elf_highest (addend + symbol);
      value &= howto->dst_mask;
      break;

    case R_MIPS_SCN_DISP:
    case R_MICROMIPS_SCN_DISP:
      value = symbol + addend - sec->output_offset;
      value &= howto->dst_mask;
      break;

    case R_MIPS_JALR:
    case R_MICROMIPS_JALR:
      /* This relocation is only a hint.  In some cases, we optimize
	 it into a bal instruction.  But we don't try to optimize
	 when the symbol does not resolve locally.  */
      if (h != NULL && !SYMBOL_CALLS_LOCAL (info, &h->root))
	return bfd_reloc_continue;
      value = symbol + addend;
      break;

    case R_MIPS_PJUMP:
    case R_MIPS_GNU_VTINHERIT:
    case R_MIPS_GNU_VTENTRY:
      /* We don't do anything with these at present.  */
      return bfd_reloc_continue;

    default:
      /* An unrecognized relocation type.  */
      return bfd_reloc_notsupported;
    }

  /* Store the VALUE for our caller.  */
  *valuep = value;
  return overflowed_p ? bfd_reloc_overflow : bfd_reloc_ok;
}

/* Obtain the field relocated by RELOCATION.  */

static bfd_vma
mips_elf_obtain_contents (reloc_howto_type *howto,
			  const Elf_Internal_Rela *relocation,
			  bfd *input_bfd, bfd_byte *contents)
{
  bfd_vma x;
  bfd_byte *location = contents + relocation->r_offset;

  /* Obtain the bytes.  */
  x = bfd_get ((8 * bfd_get_reloc_size (howto)), input_bfd, location);

  return x;
}

/* It has been determined that the result of the RELOCATION is the
   VALUE.  Use HOWTO to place VALUE into the output file at the
   appropriate position.  The SECTION is the section to which the
   relocation applies.
   CROSS_MODE_JUMP_P is true if the relocation field
   is a MIPS16 or microMIPS jump to standard MIPS code, or vice versa.

   Returns FALSE if anything goes wrong.  */

static bfd_boolean
mips_elf_perform_relocation (struct bfd_link_info *info,
			     reloc_howto_type *howto,
			     const Elf_Internal_Rela *relocation,
			     bfd_vma value, bfd *input_bfd,
			     asection *input_section, bfd_byte *contents,
			     bfd_boolean cross_mode_jump_p)
{
  bfd_vma x;
  bfd_byte *location;
  int r_type = ELF_R_TYPE (input_bfd, relocation->r_info);

  /* Figure out where the relocation is occurring.  */
  location = contents + relocation->r_offset;

  _bfd_mips_elf_reloc_unshuffle (input_bfd, r_type, FALSE, location);

  /* Obtain the current value.  */
  x = mips_elf_obtain_contents (howto, relocation, input_bfd, contents);

  /* Clear the field we are setting.  */
  x &= ~howto->dst_mask;

  /* Set the field.  */
  x |= (value & howto->dst_mask);

  /* If required, turn JAL into JALX.  */
  if (cross_mode_jump_p && jal_reloc_p (r_type))
    {
      bfd_boolean ok;
      bfd_vma opcode = x >> 26;
      bfd_vma jalx_opcode;

      /* Check to see if the opcode is already JAL or JALX.  */
      if (r_type == R_MIPS16_26)
	{
	  ok = ((opcode == 0x6) || (opcode == 0x7));
	  jalx_opcode = 0x7;
	}
      else if (r_type == R_MICROMIPS_26_S1)
	{
	  ok = ((opcode == 0x3d) || (opcode == 0x3c));
	  jalx_opcode = 0x3c;
	}
      else
	{
	  ok = ((opcode == 0x3) || (opcode == 0x1d));
	  jalx_opcode = 0x1d;
	}

      /* If the opcode is not JAL or JALX, there's a problem.  We cannot
         convert J or JALS to JALX.  */
      if (!ok)
	{
	  (*_bfd_error_handler)
	    (_("%B: %A+0x%lx: Unsupported jump between ISA modes; consider recompiling with interlinking enabled."),
	     input_bfd,
	     input_section,
	     (unsigned long) relocation->r_offset);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      /* Make this the JALX opcode.  */
      x = (x & ~(0x3f << 26)) | (jalx_opcode << 26);
    }

  /* Try converting JAL to BAL and J(AL)R to B(AL), if the target is in
     range.  */
  if (!info->relocatable
      && !cross_mode_jump_p
      && ((JAL_TO_BAL_P (input_bfd)
	   && r_type == R_MIPS_26
	   && (x >> 26) == 0x3)		/* jal addr */
	  || (JALR_TO_BAL_P (input_bfd)
	      && r_type == R_MIPS_JALR
	      && x == 0x0320f809)	/* jalr t9 */
	  || (JR_TO_B_P (input_bfd)
	      && r_type == R_MIPS_JALR
	      && x == 0x03200008)))	/* jr t9 */
    {
      bfd_vma addr;
      bfd_vma dest;
      bfd_signed_vma off;

      addr = (input_section->output_section->vma
	      + input_section->output_offset
	      + relocation->r_offset
	      + 4);
      if (r_type == R_MIPS_26)
	dest = (value << 2) | ((addr >> 28) << 28);
      else
	dest = value;
      off = dest - addr;
      if (off <= 0x1ffff && off >= -0x20000)
	{
	  if (x == 0x03200008)	/* jr t9 */
	    x = 0x10000000 | (((bfd_vma) off >> 2) & 0xffff);   /* b addr */
	  else
	    x = 0x04110000 | (((bfd_vma) off >> 2) & 0xffff);   /* bal addr */
	}
    }

  /* Put the value into the output.  */
  bfd_put (8 * bfd_get_reloc_size (howto), input_bfd, x, location);

  _bfd_mips_elf_reloc_shuffle (input_bfd, r_type, !info->relocatable,
			       location);

  return TRUE;
}

/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL
   is the original relocation, which is now being transformed into a
   dynamic relocation.  The ADDENDP is adjusted if necessary; the
   caller should store the result in place of the original addend.  */

static bfd_boolean
mips_elf_create_dynamic_relocation (bfd *output_bfd,
				    struct bfd_link_info *info,
				    const Elf_Internal_Rela *rel,
				    struct mips_elf_link_hash_entry *h,
				    asection *sec, bfd_vma symbol,
				    bfd_vma *addendp, asection *input_section)
{
  Elf_Internal_Rela outrel[3];
  asection *sreloc;
  bfd *dynobj;
  int r_type;
  long indx;
  bfd_boolean defined_p;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  r_type = ELF_R_TYPE (output_bfd, rel->r_info);
  dynobj = elf_hash_table (info)->dynobj;
  sreloc = mips_elf_rel_dyn_section (info, FALSE);
  BFD_ASSERT (sreloc != NULL);
  BFD_ASSERT (sreloc->contents != NULL);
  BFD_ASSERT (sreloc->reloc_count * MIPS_ELF_REL_SIZE (output_bfd)
	      < sreloc->size);

  outrel[0].r_offset =
    _bfd_elf_section_offset (output_bfd, info, input_section, rel[0].r_offset);
  if (ABI_64_P (output_bfd))
    {
      outrel[1].r_offset =
	_bfd_elf_section_offset (output_bfd, info, input_section, rel[1].r_offset);
      outrel[2].r_offset =
	_bfd_elf_section_offset (output_bfd, info, input_section, rel[2].r_offset);
    }

  if (outrel[0].r_offset == MINUS_ONE)
    /* The relocation field has been deleted.  */
    return TRUE;

  if (outrel[0].r_offset == MINUS_TWO)
    {
      /* The relocation field has been converted into a relative value of
	 some sort.  Functions like _bfd_elf_write_section_eh_frame expect
	 the field to be fully relocated, so add in the symbol's value.  */
      *addendp += symbol;
      return TRUE;
    }

  /* We must now calculate the dynamic symbol table index to use
     in the relocation.  */
  if (h != NULL && ! SYMBOL_REFERENCES_LOCAL (info, &h->root))
    {
      BFD_ASSERT (htab->is_vxworks || h->global_got_area != GGA_NONE);
      indx = h->root.dynindx;
      if (SGI_COMPAT (output_bfd))
	defined_p = h->root.def_regular;
      else
	/* ??? glibc's ld.so just adds the final GOT entry to the
	   relocation field.  It therefore treats relocs against
	   defined symbols in the same way as relocs against
	   undefined symbols.  */
	defined_p = FALSE;
    }
  else
    {
      if (sec != NULL && bfd_is_abs_section (sec))
	indx = 0;
      else if (sec == NULL || sec->owner == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      else
	{
	  indx = elf_section_data (sec->output_section)->dynindx;
	  if (indx == 0)
	    {
	      asection *osec = htab->root.text_index_section;
	      indx = elf_section_data (osec)->dynindx;
	    }
	  if (indx == 0)
	    abort ();
	}

      /* Instead of generating a relocation using the section
	 symbol, we may as well make it a fully relative
	 relocation.  We want to avoid generating relocations to
	 local symbols because we used to generate them
	 incorrectly, without adding the original symbol value,
	 which is mandated by the ABI for section symbols.  In
	 order to give dynamic loaders and applications time to
	 phase out the incorrect use, we refrain from emitting
	 section-relative relocations.  It's not like they're
	 useful, after all.  This should be a bit more efficient
	 as well.  */
      /* ??? Although this behavior is compatible with glibc's ld.so,
	 the ABI says that relocations against STN_UNDEF should have
	 a symbol value of 0.  Irix rld honors this, so relocations
	 against STN_UNDEF have no effect.  */
      if (!SGI_COMPAT (output_bfd))
	indx = 0;
      defined_p = TRUE;
    }

  /* If the relocation was previously an absolute relocation and
     this symbol will not be referred to by the relocation, we must
     adjust it by the value we give it in the dynamic symbol table.
     Otherwise leave the job up to the dynamic linker.  */
  if (defined_p && r_type != R_MIPS_REL32)
    *addendp += symbol;

  if (htab->is_vxworks)
    /* VxWorks uses non-relative relocations for this.  */
    outrel[0].r_info = ELF32_R_INFO (indx, R_MIPS_32);
  else
    /* The relocation is always an REL32 relocation because we don't
       know where the shared library will wind up at load-time.  */
    outrel[0].r_info = ELF_R_INFO (output_bfd, (unsigned long) indx,
				   R_MIPS_REL32);

  /* For strict adherence to the ABI specification, we should
     generate a R_MIPS_64 relocation record by itself before the
     _REL32/_64 record as well, such that the addend is read in as
     a 64-bit value (REL32 is a 32-bit relocation, after all).
     However, since none of the existing ELF64 MIPS dynamic
     loaders seems to care, we don't waste space with these
     artificial relocations.  If this turns out to not be true,
     mips_elf_allocate_dynamic_relocation() should be tweaked so
     as to make room for a pair of dynamic relocations per
     invocation if ABI_64_P, and here we should generate an
     additional relocation record with R_MIPS_64 by itself for a
     NULL symbol before this relocation record.  */
  outrel[1].r_info = ELF_R_INFO (output_bfd, 0,
				 ABI_64_P (output_bfd)
				 ? R_MIPS_64
				 : R_MIPS_NONE);
  outrel[2].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_NONE);

  /* Adjust the output offset of the relocation to reference the
     correct location in the output file.  */
  outrel[0].r_offset += (input_section->output_section->vma
			 + input_section->output_offset);
  outrel[1].r_offset += (input_section->output_section->vma
			 + input_section->output_offset);
  outrel[2].r_offset += (input_section->output_section->vma
			 + input_section->output_offset);

  /* Put the relocation back out.  We have to use the special
     relocation outputter in the 64-bit case since the 64-bit
     relocation format is non-standard.  */
  if (ABI_64_P (output_bfd))
    {
      (*get_elf_backend_data (output_bfd)->s->swap_reloc_out)
	(output_bfd, &outrel[0],
	 (sreloc->contents
	  + sreloc->reloc_count * sizeof (Elf64_Mips_External_Rel)));
    }
  else if (htab->is_vxworks)
    {
      /* VxWorks uses RELA rather than REL dynamic relocations.  */
      outrel[0].r_addend = *addendp;
      bfd_elf32_swap_reloca_out
	(output_bfd, &outrel[0],
	 (sreloc->contents
	  + sreloc->reloc_count * sizeof (Elf32_External_Rela)));
    }
  else
    bfd_elf32_swap_reloc_out
      (output_bfd, &outrel[0],
       (sreloc->contents + sreloc->reloc_count * sizeof (Elf32_External_Rel)));

  /* We've now added another relocation.  */
  ++sreloc->reloc_count;

  /* Make sure the output section is writable.  The dynamic linker
     will be writing to it.  */
  elf_section_data (input_section->output_section)->this_hdr.sh_flags
    |= SHF_WRITE;

  /* On IRIX5, make an entry of compact relocation info.  */
  if (IRIX_COMPAT (output_bfd) == ict_irix5)
    {
      asection *scpt = bfd_get_linker_section (dynobj, ".compact_rel");
      bfd_byte *cr;

      if (scpt)
	{
	  Elf32_crinfo cptrel;

	  mips_elf_set_cr_format (cptrel, CRF_MIPS_LONG);
	  cptrel.vaddr = (rel->r_offset
			  + input_section->output_section->vma
			  + input_section->output_offset);
	  if (r_type == R_MIPS_REL32)
	    mips_elf_set_cr_type (cptrel, CRT_MIPS_REL32);
	  else
	    mips_elf_set_cr_type (cptrel, CRT_MIPS_WORD);
	  mips_elf_set_cr_dist2to (cptrel, 0);
	  cptrel.konst = *addendp;

	  cr = (scpt->contents
		+ sizeof (Elf32_External_compact_rel));
	  mips_elf_set_cr_relvaddr (cptrel, 0);
	  bfd_elf32_swap_crinfo_out (output_bfd, &cptrel,
				     ((Elf32_External_crinfo *) cr
				      + scpt->reloc_count));
	  ++scpt->reloc_count;
	}
    }

  /* If we've written this relocation for a readonly section,
     we need to set DF_TEXTREL again, so that we do not delete the
     DT_TEXTREL tag.  */
  if (MIPS_ELF_READONLY_SECTION (input_section))
    info->flags |= DF_TEXTREL;

  return TRUE;
}

/* Return the MACH for a MIPS e_flags value.  */

unsigned long
_bfd_elf_mips_mach (flagword flags)
{
  switch (flags & EF_MIPS_MACH)
    {
    case E_MIPS_MACH_3900:
      return bfd_mach_mips3900;

    case E_MIPS_MACH_4010:
      return bfd_mach_mips4010;

    case E_MIPS_MACH_4100:
      return bfd_mach_mips4100;

    case E_MIPS_MACH_4111:
      return bfd_mach_mips4111;

    case E_MIPS_MACH_4120:
      return bfd_mach_mips4120;

    case E_MIPS_MACH_4650:
      return bfd_mach_mips4650;

    case E_MIPS_MACH_5400:
      return bfd_mach_mips5400;

    case E_MIPS_MACH_5500:
      return bfd_mach_mips5500;

    case E_MIPS_MACH_5900:
      return bfd_mach_mips5900;

    case E_MIPS_MACH_9000:
      return bfd_mach_mips9000;

    case E_MIPS_MACH_SB1:
      return bfd_mach_mips_sb1;

    case E_MIPS_MACH_LS2E:
      return bfd_mach_mips_loongson_2e;

    case E_MIPS_MACH_LS2F:
      return bfd_mach_mips_loongson_2f;

    case E_MIPS_MACH_LS3A:
      return bfd_mach_mips_loongson_3a;

    case E_MIPS_MACH_OCTEON2:
      return bfd_mach_mips_octeon2;

    case E_MIPS_MACH_OCTEON:
      return bfd_mach_mips_octeon;

    case E_MIPS_MACH_XLR:
      return bfd_mach_mips_xlr;

    default:
      switch (flags & EF_MIPS_ARCH)
	{
	default:
	case E_MIPS_ARCH_1:
	  return bfd_mach_mips3000;

	case E_MIPS_ARCH_2:
	  return bfd_mach_mips6000;

	case E_MIPS_ARCH_3:
	  return bfd_mach_mips4000;

	case E_MIPS_ARCH_4:
	  return bfd_mach_mips8000;

	case E_MIPS_ARCH_5:
	  return bfd_mach_mips5;

	case E_MIPS_ARCH_32:
	  return bfd_mach_mipsisa32;

	case E_MIPS_ARCH_64:
	  return bfd_mach_mipsisa64;

	case E_MIPS_ARCH_32R2:
	  return bfd_mach_mipsisa32r2;

	case E_MIPS_ARCH_64R2:
	  return bfd_mach_mipsisa64r2;
	}
    }

  return 0;
}

/* Return printable name for ABI.  */

static INLINE char *
elf_mips_abi_name (bfd *abfd)
{
  flagword flags;

  flags = elf_elfheader (abfd)->e_flags;
  switch (flags & EF_MIPS_ABI)
    {
    case 0:
      if (ABI_N32_P (abfd))
	return "N32";
      else if (ABI_64_P (abfd))
	return "64";
      else
	return "none";
    case E_MIPS_ABI_O32:
      return "O32";
    case E_MIPS_ABI_O64:
      return "O64";
    case E_MIPS_ABI_EABI32:
      return "EABI32";
    case E_MIPS_ABI_EABI64:
      return "EABI64";
    default:
      return "unknown abi";
    }
}

/* MIPS ELF uses two common sections.  One is the usual one, and the
   other is for small objects.  All the small objects are kept
   together, and then referenced via the gp pointer, which yields
   faster assembler code.  This is what we use for the small common
   section.  This approach is copied from ecoff.c.  */
static asection mips_elf_scom_section;
static asymbol mips_elf_scom_symbol;
static asymbol *mips_elf_scom_symbol_ptr;

/* MIPS ELF also uses an acommon section, which represents an
   allocated common symbol which may be overridden by a
   definition in a shared library.  */
static asection mips_elf_acom_section;
static asymbol mips_elf_acom_symbol;
static asymbol *mips_elf_acom_symbol_ptr;

/* This is used for both the 32-bit and the 64-bit ABI.  */

void
_bfd_mips_elf_symbol_processing (bfd *abfd, asymbol *asym)
{
  elf_symbol_type *elfsym;

  /* Handle the special MIPS section numbers that a symbol may use.  */
  elfsym = (elf_symbol_type *) asym;
  switch (elfsym->internal_elf_sym.st_shndx)
    {
    case SHN_MIPS_ACOMMON:
      /* This section is used in a dynamically linked executable file.
	 It is an allocated common section.  The dynamic linker can
	 either resolve these symbols to something in a shared
	 library, or it can just leave them here.  For our purposes,
	 we can consider these symbols to be in a new section.  */
      if (mips_elf_acom_section.name == NULL)
	{
	  /* Initialize the acommon section.  */
	  mips_elf_acom_section.name = ".acommon";
	  mips_elf_acom_section.flags = SEC_ALLOC;
	  mips_elf_acom_section.output_section = &mips_elf_acom_section;
	  mips_elf_acom_section.symbol = &mips_elf_acom_symbol;
	  mips_elf_acom_section.symbol_ptr_ptr = &mips_elf_acom_symbol_ptr;
	  mips_elf_acom_symbol.name = ".acommon";
	  mips_elf_acom_symbol.flags = BSF_SECTION_SYM;
	  mips_elf_acom_symbol.section = &mips_elf_acom_section;
	  mips_elf_acom_symbol_ptr = &mips_elf_acom_symbol;
	}
      asym->section = &mips_elf_acom_section;
      break;

    case SHN_COMMON:
      /* Common symbols less than the GP size are automatically
	 treated as SHN_MIPS_SCOMMON symbols on IRIX5.  */
      if (asym->value > elf_gp_size (abfd)
	  || ELF_ST_TYPE (elfsym->internal_elf_sym.st_info) == STT_TLS
	  || IRIX_COMPAT (abfd) == ict_irix6)
	break;
      /* Fall through.  */
    case SHN_MIPS_SCOMMON:
      if (mips_elf_scom_section.name == NULL)
	{
	  /* Initialize the small common section.  */
	  mips_elf_scom_section.name = ".scommon";
	  mips_elf_scom_section.flags = SEC_IS_COMMON;
	  mips_elf_scom_section.output_section = &mips_elf_scom_section;
	  mips_elf_scom_section.symbol = &mips_elf_scom_symbol;
	  mips_elf_scom_section.symbol_ptr_ptr = &mips_elf_scom_symbol_ptr;
	  mips_elf_scom_symbol.name = ".scommon";
	  mips_elf_scom_symbol.flags = BSF_SECTION_SYM;
	  mips_elf_scom_symbol.section = &mips_elf_scom_section;
	  mips_elf_scom_symbol_ptr = &mips_elf_scom_symbol;
	}
      asym->section = &mips_elf_scom_section;
      asym->value = elfsym->internal_elf_sym.st_size;
      break;

    case SHN_MIPS_SUNDEFINED:
      asym->section = bfd_und_section_ptr;
      break;

    case SHN_MIPS_TEXT:
      {
	asection *section = bfd_get_section_by_name (abfd, ".text");

	if (section != NULL)
	  {
	    asym->section = section;
	    /* MIPS_TEXT is a bit special, the address is not an offset
	       to the base of the .text section.  So substract the section
	       base address to make it an offset.  */
	    asym->value -= section->vma;
	  }
      }
      break;

    case SHN_MIPS_DATA:
      {
	asection *section = bfd_get_section_by_name (abfd, ".data");

	if (section != NULL)
	  {
	    asym->section = section;
	    /* MIPS_DATA is a bit special, the address is not an offset
	       to the base of the .data section.  So substract the section
	       base address to make it an offset.  */
	    asym->value -= section->vma;
	  }
      }
      break;
    }

  /* If this is an odd-valued function symbol, assume it's a MIPS16
     or microMIPS one.  */
  if (ELF_ST_TYPE (elfsym->internal_elf_sym.st_info) == STT_FUNC
      && (asym->value & 1) != 0)
    {
      asym->value--;
      if (MICROMIPS_P (abfd))
	elfsym->internal_elf_sym.st_other
	  = ELF_ST_SET_MICROMIPS (elfsym->internal_elf_sym.st_other);
      else
	elfsym->internal_elf_sym.st_other
	  = ELF_ST_SET_MIPS16 (elfsym->internal_elf_sym.st_other);
    }
}

/* Implement elf_backend_eh_frame_address_size.  This differs from
   the default in the way it handles EABI64.

   EABI64 was originally specified as an LP64 ABI, and that is what
   -mabi=eabi normally gives on a 64-bit target.  However, gcc has
   historically accepted the combination of -mabi=eabi and -mlong32,
   and this ILP32 variation has become semi-official over time.
   Both forms use elf32 and have pointer-sized FDE addresses.

   If an EABI object was generated by GCC 4.0 or above, it will have
   an empty .gcc_compiled_longXX section, where XX is the size of longs
   in bits.  Unfortunately, ILP32 objects generated by earlier compilers
   have no special marking to distinguish them from LP64 objects.

   We don't want users of the official LP64 ABI to be punished for the
   existence of the ILP32 variant, but at the same time, we don't want
   to mistakenly interpret pre-4.0 ILP32 objects as being LP64 objects.
   We therefore take the following approach:

      - If ABFD contains a .gcc_compiled_longXX section, use it to
        determine the pointer size.

      - Otherwise check the type of the first relocation.  Assume that
        the LP64 ABI is being used if the relocation is of type R_MIPS_64.

      - Otherwise punt.

   The second check is enough to detect LP64 objects generated by pre-4.0
   compilers because, in the kind of output generated by those compilers,
   the first relocation will be associated with either a CIE personality
   routine or an FDE start address.  Furthermore, the compilers never
   used a special (non-pointer) encoding for this ABI.

   Checking the relocation type should also be safe because there is no
   reason to use R_MIPS_64 in an ILP32 object.  Pre-4.0 compilers never
   did so.  */

unsigned int
_bfd_mips_elf_eh_frame_address_size (bfd *abfd, asection *sec)
{
  if (elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64)
    return 8;
  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64)
    {
      bfd_boolean long32_p, long64_p;

      long32_p = bfd_get_section_by_name (abfd, ".gcc_compiled_long32") != 0;
      long64_p = bfd_get_section_by_name (abfd, ".gcc_compiled_long64") != 0;
      if (long32_p && long64_p)
	return 0;
      if (long32_p)
	return 4;
      if (long64_p)
	return 8;

      if (sec->reloc_count > 0
	  && elf_section_data (sec)->relocs != NULL
	  && (ELF32_R_TYPE (elf_section_data (sec)->relocs[0].r_info)
	      == R_MIPS_64))
	return 8;

      return 0;
    }
  return 4;
}

/* There appears to be a bug in the MIPSpro linker that causes GOT_DISP
   relocations against two unnamed section symbols to resolve to the
   same address.  For example, if we have code like:

	lw	$4,%got_disp(.data)($gp)
	lw	$25,%got_disp(.text)($gp)
	jalr	$25

   then the linker will resolve both relocations to .data and the program
   will jump there rather than to .text.

   We can work around this problem by giving names to local section symbols.
   This is also what the MIPSpro tools do.  */

bfd_boolean
_bfd_mips_elf_name_local_section_symbols (bfd *abfd)
{
  return SGI_COMPAT (abfd);
}

/* Work over a section just before writing it out.  This routine is
   used by both the 32-bit and the 64-bit ABI.  FIXME: We recognize
   sections that need the SHF_MIPS_GPREL flag by name; there has to be
   a better way.  */

bfd_boolean
_bfd_mips_elf_section_processing (bfd *abfd, Elf_Internal_Shdr *hdr)
{
  if (hdr->sh_type == SHT_MIPS_REGINFO
      && hdr->sh_size > 0)
    {
      bfd_byte buf[4];

      BFD_ASSERT (hdr->sh_size == sizeof (Elf32_External_RegInfo));
      BFD_ASSERT (hdr->contents == NULL);

      if (bfd_seek (abfd,
		    hdr->sh_offset + sizeof (Elf32_External_RegInfo) - 4,
		    SEEK_SET) != 0)
	return FALSE;
      H_PUT_32 (abfd, elf_gp (abfd), buf);
      if (bfd_bwrite (buf, 4, abfd) != 4)
	return FALSE;
    }

  if (hdr->sh_type == SHT_MIPS_OPTIONS
      && hdr->bfd_section != NULL
      && mips_elf_section_data (hdr->bfd_section) != NULL
      && mips_elf_section_data (hdr->bfd_section)->u.tdata != NULL)
    {
      bfd_byte *contents, *l, *lend;

      /* We stored the section contents in the tdata field in the
	 set_section_contents routine.  We save the section contents
	 so that we don't have to read them again.
	 At this point we know that elf_gp is set, so we can look
	 through the section contents to see if there is an
	 ODK_REGINFO structure.  */

      contents = mips_elf_section_data (hdr->bfd_section)->u.tdata;
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (intopt.size < sizeof (Elf_External_Options))
	    {
	      (*_bfd_error_handler)
		(_("%B: Warning: bad `%s' option size %u smaller than its header"),
		abfd, MIPS_ELF_OPTIONS_SECTION_NAME (abfd), intopt.size);
	      break;
	    }
	  if (ABI_64_P (abfd) && intopt.kind == ODK_REGINFO)
	    {
	      bfd_byte buf[8];

	      if (bfd_seek (abfd,
			    (hdr->sh_offset
			     + (l - contents)
			     + sizeof (Elf_External_Options)
			     + (sizeof (Elf64_External_RegInfo) - 8)),
			     SEEK_SET) != 0)
		return FALSE;
	      H_PUT_64 (abfd, elf_gp (abfd), buf);
	      if (bfd_bwrite (buf, 8, abfd) != 8)
		return FALSE;
	    }
	  else if (intopt.kind == ODK_REGINFO)
	    {
	      bfd_byte buf[4];

	      if (bfd_seek (abfd,
			    (hdr->sh_offset
			     + (l - contents)
			     + sizeof (Elf_External_Options)
			     + (sizeof (Elf32_External_RegInfo) - 4)),
			    SEEK_SET) != 0)
		return FALSE;
	      H_PUT_32 (abfd, elf_gp (abfd), buf);
	      if (bfd_bwrite (buf, 4, abfd) != 4)
		return FALSE;
	    }
	  l += intopt.size;
	}
    }

  if (hdr->bfd_section != NULL)
    {
      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);

      /* .sbss is not handled specially here because the GNU/Linux
	 prelinker can convert .sbss from NOBITS to PROGBITS and
	 changing it back to NOBITS breaks the binary.  The entry in
	 _bfd_mips_elf_special_sections will ensure the correct flags
	 are set on .sbss if BFD creates it without reading it from an
	 input file, and without special handling here the flags set
	 on it in an input file will be followed.  */
      if (strcmp (name, ".sdata") == 0
	  || strcmp (name, ".lit8") == 0
	  || strcmp (name, ".lit4") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".srdata") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".compact_rel") == 0)
	{
	  hdr->sh_flags = 0;
	  hdr->sh_type = SHT_PROGBITS;
	}
      else if (strcmp (name, ".rtproc") == 0)
	{
	  if (hdr->sh_addralign != 0 && hdr->sh_entsize == 0)
	    {
	      unsigned int adjust;

	      adjust = hdr->sh_size % hdr->sh_addralign;
	      if (adjust != 0)
		hdr->sh_size += hdr->sh_addralign - adjust;
	    }
	}
    }

  return TRUE;
}

/* Handle a MIPS specific section when reading an object file.  This
   is called when elfcode.h finds a section with an unknown type.
   This routine supports both the 32-bit and 64-bit ELF ABI.

   FIXME: We need to handle the SHF_MIPS_GPREL flag, but I'm not sure
   how to.  */

bfd_boolean
_bfd_mips_elf_section_from_shdr (bfd *abfd,
				 Elf_Internal_Shdr *hdr,
				 const char *name,
				 int shindex)
{
  flagword flags = 0;

  /* There ought to be a place to keep ELF backend specific flags, but
     at the moment there isn't one.  We just keep track of the
     sections by their name, instead.  Fortunately, the ABI gives
     suggested names for all the MIPS specific sections, so we will
     probably get away with this.  */
  switch (hdr->sh_type)
    {
    case SHT_MIPS_LIBLIST:
      if (strcmp (name, ".liblist") != 0)
	return FALSE;
      break;
    case SHT_MIPS_MSYM:
      if (strcmp (name, ".msym") != 0)
	return FALSE;
      break;
    case SHT_MIPS_CONFLICT:
      if (strcmp (name, ".conflict") != 0)
	return FALSE;
      break;
    case SHT_MIPS_GPTAB:
      if (! CONST_STRNEQ (name, ".gptab."))
	return FALSE;
      break;
    case SHT_MIPS_UCODE:
      if (strcmp (name, ".ucode") != 0)
	return FALSE;
      break;
    case SHT_MIPS_DEBUG:
      if (strcmp (name, ".mdebug") != 0)
	return FALSE;
      flags = SEC_DEBUGGING;
      break;
    case SHT_MIPS_REGINFO:
      if (strcmp (name, ".reginfo") != 0
	  || hdr->sh_size != sizeof (Elf32_External_RegInfo))
	return FALSE;
      flags = (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_SIZE);
      break;
    case SHT_MIPS_IFACE:
      if (strcmp (name, ".MIPS.interfaces") != 0)
	return FALSE;
      break;
    case SHT_MIPS_CONTENT:
      if (! CONST_STRNEQ (name, ".MIPS.content"))
	return FALSE;
      break;
    case SHT_MIPS_OPTIONS:
      if (!MIPS_ELF_OPTIONS_SECTION_NAME_P (name))
	return FALSE;
      break;
    case SHT_MIPS_DWARF:
      if (! CONST_STRNEQ (name, ".debug_")
          && ! CONST_STRNEQ (name, ".zdebug_"))
	return FALSE;
      break;
    case SHT_MIPS_SYMBOL_LIB:
      if (strcmp (name, ".MIPS.symlib") != 0)
	return FALSE;
      break;
    case SHT_MIPS_EVENTS:
      if (! CONST_STRNEQ (name, ".MIPS.events")
	  && ! CONST_STRNEQ (name, ".MIPS.post_rel"))
	return FALSE;
      break;
    default:
      break;
    }

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
    return FALSE;

  if (flags)
    {
      if (! bfd_set_section_flags (abfd, hdr->bfd_section,
				   (bfd_get_section_flags (abfd,
							   hdr->bfd_section)
				    | flags)))
	return FALSE;
    }

  /* FIXME: We should record sh_info for a .gptab section.  */

  /* For a .reginfo section, set the gp value in the tdata information
     from the contents of this section.  We need the gp value while
     processing relocs, so we just get it now.  The .reginfo section
     is not used in the 64-bit MIPS ELF ABI.  */
  if (hdr->sh_type == SHT_MIPS_REGINFO)
    {
      Elf32_External_RegInfo ext;
      Elf32_RegInfo s;

      if (! bfd_get_section_contents (abfd, hdr->bfd_section,
				      &ext, 0, sizeof ext))
	return FALSE;
      bfd_mips_elf32_swap_reginfo_in (abfd, &ext, &s);
      elf_gp (abfd) = s.ri_gp_value;
    }

  /* For a SHT_MIPS_OPTIONS section, look for a ODK_REGINFO entry, and
     set the gp value based on what we find.  We may see both
     SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS/ODK_REGINFO; in that case,
     they should agree.  */
  if (hdr->sh_type == SHT_MIPS_OPTIONS)
    {
      bfd_byte *contents, *l, *lend;

      contents = bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	return FALSE;
      if (! bfd_get_section_contents (abfd, hdr->bfd_section, contents,
				      0, hdr->sh_size))
	{
	  free (contents);
	  return FALSE;
	}
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (intopt.size < sizeof (Elf_External_Options))
	    {
	      (*_bfd_error_handler)
		(_("%B: Warning: bad `%s' option size %u smaller than its header"),
		abfd, MIPS_ELF_OPTIONS_SECTION_NAME (abfd), intopt.size);
	      break;
	    }
	  if (ABI_64_P (abfd) && intopt.kind == ODK_REGINFO)
	    {
	      Elf64_Internal_RegInfo intreg;

	      bfd_mips_elf64_swap_reginfo_in
		(abfd,
		 ((Elf64_External_RegInfo *)
		  (l + sizeof (Elf_External_Options))),
		 &intreg);
	      elf_gp (abfd) = intreg.ri_gp_value;
	    }
	  else if (intopt.kind == ODK_REGINFO)
	    {
	      Elf32_RegInfo intreg;

	      bfd_mips_elf32_swap_reginfo_in
		(abfd,
		 ((Elf32_External_RegInfo *)
		  (l + sizeof (Elf_External_Options))),
		 &intreg);
	      elf_gp (abfd) = intreg.ri_gp_value;
	    }
	  l += intopt.size;
	}
      free (contents);
    }

  return TRUE;
}

/* Set the correct type for a MIPS ELF section.  We do this by the
   section name, which is a hack, but ought to work.  This routine is
   used by both the 32-bit and the 64-bit ABI.  */

bfd_boolean
_bfd_mips_elf_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec)
{
  const char *name = bfd_get_section_name (abfd, sec);

  if (strcmp (name, ".liblist") == 0)
    {
      hdr->sh_type = SHT_MIPS_LIBLIST;
      hdr->sh_info = sec->size / sizeof (Elf32_Lib);
      /* The sh_link field is set in final_write_processing.  */
    }
  else if (strcmp (name, ".conflict") == 0)
    hdr->sh_type = SHT_MIPS_CONFLICT;
  else if (CONST_STRNEQ (name, ".gptab."))
    {
      hdr->sh_type = SHT_MIPS_GPTAB;
      hdr->sh_entsize = sizeof (Elf32_External_gptab);
      /* The sh_info field is set in final_write_processing.  */
    }
  else if (strcmp (name, ".ucode") == 0)
    hdr->sh_type = SHT_MIPS_UCODE;
  else if (strcmp (name, ".mdebug") == 0)
    {
      hdr->sh_type = SHT_MIPS_DEBUG;
      /* In a shared object on IRIX 5.3, the .mdebug section has an
         entsize of 0.  FIXME: Does this matter?  */
      if (SGI_COMPAT (abfd) && (abfd->flags & DYNAMIC) != 0)
	hdr->sh_entsize = 0;
      else
	hdr->sh_entsize = 1;
    }
  else if (strcmp (name, ".reginfo") == 0)
    {
      hdr->sh_type = SHT_MIPS_REGINFO;
      /* In a shared object on IRIX 5.3, the .reginfo section has an
         entsize of 0x18.  FIXME: Does this matter?  */
      if (SGI_COMPAT (abfd))
	{
	  if ((abfd->flags & DYNAMIC) != 0)
	    hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
	  else
	    hdr->sh_entsize = 1;
	}
      else
	hdr->sh_entsize = sizeof (Elf32_External_RegInfo);
    }
  else if (SGI_COMPAT (abfd)
	   && (strcmp (name, ".hash") == 0
	       || strcmp (name, ".dynamic") == 0
	       || strcmp (name, ".dynstr") == 0))
    {
      if (SGI_COMPAT (abfd))
	hdr->sh_entsize = 0;
#if 0
      /* This isn't how the IRIX6 linker behaves.  */
      hdr->sh_info = SIZEOF_MIPS_DYNSYM_SECNAMES;
#endif
    }
  else if (strcmp (name, ".got") == 0
	   || strcmp (name, ".srdata") == 0
	   || strcmp (name, ".sdata") == 0
	   || strcmp (name, ".sbss") == 0
	   || strcmp (name, ".lit4") == 0
	   || strcmp (name, ".lit8") == 0)
    hdr->sh_flags |= SHF_MIPS_GPREL;
  else if (strcmp (name, ".MIPS.interfaces") == 0)
    {
      hdr->sh_type = SHT_MIPS_IFACE;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
    }
  else if (CONST_STRNEQ (name, ".MIPS.content"))
    {
      hdr->sh_type = SHT_MIPS_CONTENT;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
      /* The sh_info field is set in final_write_processing.  */
    }
  else if (MIPS_ELF_OPTIONS_SECTION_NAME_P (name))
    {
      hdr->sh_type = SHT_MIPS_OPTIONS;
      hdr->sh_entsize = 1;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
    }
  else if (CONST_STRNEQ (name, ".debug_")
           || CONST_STRNEQ (name, ".zdebug_"))
    {
      hdr->sh_type = SHT_MIPS_DWARF;

      /* Irix facilities such as libexc expect a single .debug_frame
	 per executable, the system ones have NOSTRIP set and the linker
	 doesn't merge sections with different flags so ...  */
      if (SGI_COMPAT (abfd) && CONST_STRNEQ (name, ".debug_frame"))
	hdr->sh_flags |= SHF_MIPS_NOSTRIP;
    }
  else if (strcmp (name, ".MIPS.symlib") == 0)
    {
      hdr->sh_type = SHT_MIPS_SYMBOL_LIB;
      /* The sh_link and sh_info fields are set in
         final_write_processing.  */
    }
  else if (CONST_STRNEQ (name, ".MIPS.events")
	   || CONST_STRNEQ (name, ".MIPS.post_rel"))
    {
      hdr->sh_type = SHT_MIPS_EVENTS;
      hdr->sh_flags |= SHF_MIPS_NOSTRIP;
      /* The sh_link field is set in final_write_processing.  */
    }
  else if (strcmp (name, ".msym") == 0)
    {
      hdr->sh_type = SHT_MIPS_MSYM;
      hdr->sh_flags |= SHF_ALLOC;
      hdr->sh_entsize = 8;
    }

  /* The generic elf_fake_sections will set up REL_HDR using the default
   kind of relocations.  We used to set up a second header for the
   non-default kind of relocations here, but only NewABI would use
   these, and the IRIX ld doesn't like resulting empty RELA sections.
   Thus we create those header only on demand now.  */

  return TRUE;
}

/* Given a BFD section, try to locate the corresponding ELF section
   index.  This is used by both the 32-bit and the 64-bit ABI.
   Actually, it's not clear to me that the 64-bit ABI supports these,
   but for non-PIC objects we will certainly want support for at least
   the .scommon section.  */

bfd_boolean
_bfd_mips_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
					asection *sec, int *retval)
{
  if (strcmp (bfd_get_section_name (abfd, sec), ".scommon") == 0)
    {
      *retval = SHN_MIPS_SCOMMON;
      return TRUE;
    }
  if (strcmp (bfd_get_section_name (abfd, sec), ".acommon") == 0)
    {
      *retval = SHN_MIPS_ACOMMON;
      return TRUE;
    }
  return FALSE;
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We must handle the special MIPS section numbers here.  */

bfd_boolean
_bfd_mips_elf_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
			       Elf_Internal_Sym *sym, const char **namep,
			       flagword *flagsp ATTRIBUTE_UNUSED,
			       asection **secp, bfd_vma *valp)
{
  if (SGI_COMPAT (abfd)
      && (abfd->flags & DYNAMIC) != 0
      && strcmp (*namep, "_rld_new_interface") == 0)
    {
      /* Skip IRIX5 rld entry name.  */
      *namep = NULL;
      return TRUE;
    }

  /* Shared objects may have a dynamic symbol '_gp_disp' defined as
     a SECTION *ABS*.  This causes ld to think it can resolve _gp_disp
     by setting a DT_NEEDED for the shared object.  Since _gp_disp is
     a magic symbol resolved by the linker, we ignore this bogus definition
     of _gp_disp.  New ABI objects do not suffer from this problem so this
     is not done for them. */
  if (!NEWABI_P(abfd)
      && (sym->st_shndx == SHN_ABS)
      && (strcmp (*namep, "_gp_disp") == 0))
    {
      *namep = NULL;
      return TRUE;
    }

  switch (sym->st_shndx)
    {
    case SHN_COMMON:
      /* Common symbols less than the GP size are automatically
	 treated as SHN_MIPS_SCOMMON symbols.  */
      if (sym->st_size > elf_gp_size (abfd)
	  || ELF_ST_TYPE (sym->st_info) == STT_TLS
	  || IRIX_COMPAT (abfd) == ict_irix6)
	break;
      /* Fall through.  */
    case SHN_MIPS_SCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".scommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;

    case SHN_MIPS_TEXT:
      /* This section is used in a shared object.  */
      if (mips_elf_tdata (abfd)->elf_text_section == NULL)
	{
	  asymbol *elf_text_symbol;
	  asection *elf_text_section;
	  bfd_size_type amt = sizeof (asection);

	  elf_text_section = bfd_zalloc (abfd, amt);
	  if (elf_text_section == NULL)
	    return FALSE;

	  amt = sizeof (asymbol);
	  elf_text_symbol = bfd_zalloc (abfd, amt);
	  if (elf_text_symbol == NULL)
	    return FALSE;

	  /* Initialize the section.  */

	  mips_elf_tdata (abfd)->elf_text_section = elf_text_section;
	  mips_elf_tdata (abfd)->elf_text_symbol = elf_text_symbol;

	  elf_text_section->symbol = elf_text_symbol;
	  elf_text_section->symbol_ptr_ptr = &mips_elf_tdata (abfd)->elf_text_symbol;

	  elf_text_section->name = ".text";
	  elf_text_section->flags = SEC_NO_FLAGS;
	  elf_text_section->output_section = NULL;
	  elf_text_section->owner = abfd;
	  elf_text_symbol->name = ".text";
	  elf_text_symbol->flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  elf_text_symbol->section = elf_text_section;
	}
      /* This code used to do *secp = bfd_und_section_ptr if
         info->shared.  I don't know why, and that doesn't make sense,
         so I took it out.  */
      *secp = mips_elf_tdata (abfd)->elf_text_section;
      break;

    case SHN_MIPS_ACOMMON:
      /* Fall through. XXX Can we treat this as allocated data?  */
    case SHN_MIPS_DATA:
      /* This section is used in a shared object.  */
      if (mips_elf_tdata (abfd)->elf_data_section == NULL)
	{
	  asymbol *elf_data_symbol;
	  asection *elf_data_section;
	  bfd_size_type amt = sizeof (asection);

	  elf_data_section = bfd_zalloc (abfd, amt);
	  if (elf_data_section == NULL)
	    return FALSE;

	  amt = sizeof (asymbol);
	  elf_data_symbol = bfd_zalloc (abfd, amt);
	  if (elf_data_symbol == NULL)
	    return FALSE;

	  /* Initialize the section.  */

	  mips_elf_tdata (abfd)->elf_data_section = elf_data_section;
	  mips_elf_tdata (abfd)->elf_data_symbol = elf_data_symbol;

	  elf_data_section->symbol = elf_data_symbol;
	  elf_data_section->symbol_ptr_ptr = &mips_elf_tdata (abfd)->elf_data_symbol;

	  elf_data_section->name = ".data";
	  elf_data_section->flags = SEC_NO_FLAGS;
	  elf_data_section->output_section = NULL;
	  elf_data_section->owner = abfd;
	  elf_data_symbol->name = ".data";
	  elf_data_symbol->flags = BSF_SECTION_SYM | BSF_DYNAMIC;
	  elf_data_symbol->section = elf_data_section;
	}
      /* This code used to do *secp = bfd_und_section_ptr if
         info->shared.  I don't know why, and that doesn't make sense,
         so I took it out.  */
      *secp = mips_elf_tdata (abfd)->elf_data_section;
      break;

    case SHN_MIPS_SUNDEFINED:
      *secp = bfd_und_section_ptr;
      break;
    }

  if (SGI_COMPAT (abfd)
      && ! info->shared
      && info->output_bfd->xvec == abfd->xvec
      && strcmp (*namep, "__rld_obj_head") == 0)
    {
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh;

      /* Mark __rld_obj_head as dynamic.  */
      bh = NULL;
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, *namep, BSF_GLOBAL, *secp, *valp, NULL, FALSE,
	      get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;

      h = (struct elf_link_hash_entry *) bh;
      h->non_elf = 0;
      h->def_regular = 1;
      h->type = STT_OBJECT;

      if (! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;

      mips_elf_hash_table (info)->use_rld_obj_head = TRUE;
      mips_elf_hash_table (info)->rld_symbol = h;
    }

  /* If this is a mips16 text symbol, add 1 to the value to make it
     odd.  This will cause something like .word SYM to come up with
     the right value when it is loaded into the PC.  */
  if (ELF_ST_IS_COMPRESSED (sym->st_other))
    ++*valp;

  return TRUE;
}

/* This hook function is called before the linker writes out a global
   symbol.  We mark symbols as small common if appropriate.  This is
   also where we undo the increment of the value for a mips16 symbol.  */

int
_bfd_mips_elf_link_output_symbol_hook
  (struct bfd_link_info *info ATTRIBUTE_UNUSED,
   const char *name ATTRIBUTE_UNUSED, Elf_Internal_Sym *sym,
   asection *input_sec, struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
{
  /* If we see a common symbol, which implies a relocatable link, then
     if a symbol was small common in an input file, mark it as small
     common in the output file.  */
  if (sym->st_shndx == SHN_COMMON
      && strcmp (input_sec->name, ".scommon") == 0)
    sym->st_shndx = SHN_MIPS_SCOMMON;

  if (ELF_ST_IS_COMPRESSED (sym->st_other))
    sym->st_value &= ~1;

  return 1;
}

/* Functions for the dynamic linker.  */

/* Create dynamic sections when linking against a dynamic object.  */

bfd_boolean
_bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  flagword flags;
  register asection *s;
  const char * const *namep;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED | SEC_READONLY);

  /* The psABI requires a read-only .dynamic section, but the VxWorks
     EABI doesn't.  */
  if (!htab->is_vxworks)
    {
      s = bfd_get_linker_section (abfd, ".dynamic");
      if (s != NULL)
	{
	  if (! bfd_set_section_flags (abfd, s, flags))
	    return FALSE;
	}
    }

  /* We need to create .got section.  */
  if (!mips_elf_create_got_section (abfd, info))
    return FALSE;

  if (! mips_elf_rel_dyn_section (info, TRUE))
    return FALSE;

  /* Create .stub section.  */
  s = bfd_make_section_anyway_with_flags (abfd,
					  MIPS_ELF_STUB_SECTION_NAME (abfd),
					  flags | SEC_CODE);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s,
				      MIPS_ELF_LOG_FILE_ALIGN (abfd)))
    return FALSE;
  htab->sstubs = s;

  if (!mips_elf_hash_table (info)->use_rld_obj_head
      && !info->shared
      && bfd_get_linker_section (abfd, ".rld_map") == NULL)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".rld_map",
					      flags &~ (flagword) SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return FALSE;
    }

  /* On IRIX5, we adjust add some additional symbols and change the
     alignments of several sections.  There is no ABI documentation
     indicating that this is necessary on IRIX6, nor any evidence that
     the linker takes such action.  */
  if (IRIX_COMPAT (abfd) == ict_irix5)
    {
      for (namep = mips_elf_dynsym_rtproc_names; *namep != NULL; namep++)
	{
	  bh = NULL;
	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, *namep, BSF_GLOBAL, bfd_und_section_ptr, 0,
		  NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	    return FALSE;

	  h = (struct elf_link_hash_entry *) bh;
	  h->non_elf = 0;
	  h->def_regular = 1;
	  h->type = STT_SECTION;

	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      /* We need to create a .compact_rel section.  */
      if (SGI_COMPAT (abfd))
	{
	  if (!mips_elf_create_compact_rel_section (abfd, info))
	    return FALSE;
	}

      /* Change alignments of some sections.  */
      s = bfd_get_linker_section (abfd, ".hash");
      if (s != NULL)
	(void) bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));

      s = bfd_get_linker_section (abfd, ".dynsym");
      if (s != NULL)
	(void) bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));

      s = bfd_get_linker_section (abfd, ".dynstr");
      if (s != NULL)
	(void) bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));

      /* ??? */
      s = bfd_get_section_by_name (abfd, ".reginfo");
      if (s != NULL)
	(void) bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));

      s = bfd_get_linker_section (abfd, ".dynamic");
      if (s != NULL)
	(void) bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
    }

  if (!info->shared)
    {
      const char *name;

      name = SGI_COMPAT (abfd) ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING";
      bh = NULL;
      if (!(_bfd_generic_link_add_one_symbol
	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr, 0,
	     NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;

      h = (struct elf_link_hash_entry *) bh;
      h->non_elf = 0;
      h->def_regular = 1;
      h->type = STT_SECTION;

      if (! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;

      if (! mips_elf_hash_table (info)->use_rld_obj_head)
	{
	  /* __rld_map is a four byte word located in the .data section
	     and is filled in by the rtld to contain a pointer to
	     the _r_debug structure. Its symbol value will be set in
	     _bfd_mips_elf_finish_dynamic_symbol.  */
	  s = bfd_get_linker_section (abfd, ".rld_map");
	  BFD_ASSERT (s != NULL);

	  name = SGI_COMPAT (abfd) ? "__rld_map" : "__RLD_MAP";
	  bh = NULL;
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, name, BSF_GLOBAL, s, 0, NULL, FALSE,
		 get_elf_backend_data (abfd)->collect, &bh)))
	    return FALSE;

	  h = (struct elf_link_hash_entry *) bh;
	  h->non_elf = 0;
	  h->def_regular = 1;
	  h->type = STT_OBJECT;

	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	  mips_elf_hash_table (info)->rld_symbol = h;
	}
    }

  /* Create the .plt, .rel(a).plt, .dynbss and .rel(a).bss sections.
     Also, on VxWorks, create the _PROCEDURE_LINKAGE_TABLE_ symbol.  */
  if (!_bfd_elf_create_dynamic_sections (abfd, info))
    return FALSE;

  /* Cache the sections created above.  */
  htab->splt = bfd_get_linker_section (abfd, ".plt");
  htab->sdynbss = bfd_get_linker_section (abfd, ".dynbss");
  if (htab->is_vxworks)
    {
      htab->srelbss = bfd_get_linker_section (abfd, ".rela.bss");
      htab->srelplt = bfd_get_linker_section (abfd, ".rela.plt");
    }
  else
    htab->srelplt = bfd_get_linker_section (abfd, ".rel.plt");
  if (!htab->sdynbss
      || (htab->is_vxworks && !htab->srelbss && !info->shared)
      || !htab->srelplt
      || !htab->splt)
    abort ();

  /* Do the usual VxWorks handling.  */
  if (htab->is_vxworks
      && !elf_vxworks_create_dynamic_sections (abfd, info, &htab->srelplt2))
    return FALSE;

  return TRUE;
}

/* Return true if relocation REL against section SEC is a REL rather than
   RELA relocation.  RELOCS is the first relocation in the section and
   ABFD is the bfd that contains SEC.  */

static bfd_boolean
mips_elf_rel_relocation_p (bfd *abfd, asection *sec,
			   const Elf_Internal_Rela *relocs,
			   const Elf_Internal_Rela *rel)
{
  Elf_Internal_Shdr *rel_hdr;
  const struct elf_backend_data *bed;

  /* To determine which flavor of relocation this is, we depend on the
     fact that the INPUT_SECTION's REL_HDR is read before RELA_HDR.  */
  rel_hdr = elf_section_data (sec)->rel.hdr;
  if (rel_hdr == NULL)
    return FALSE;
  bed = get_elf_backend_data (abfd);
  return ((size_t) (rel - relocs)
	  < NUM_SHDR_ENTRIES (rel_hdr) * bed->s->int_rels_per_ext_rel);
}

/* Read the addend for REL relocation REL, which belongs to bfd ABFD.
   HOWTO is the relocation's howto and CONTENTS points to the contents
   of the section that REL is against.  */

static bfd_vma
mips_elf_read_rel_addend (bfd *abfd, const Elf_Internal_Rela *rel,
			  reloc_howto_type *howto, bfd_byte *contents)
{
  bfd_byte *location;
  unsigned int r_type;
  bfd_vma addend;

  r_type = ELF_R_TYPE (abfd, rel->r_info);
  location = contents + rel->r_offset;

  /* Get the addend, which is stored in the input file.  */
  _bfd_mips_elf_reloc_unshuffle (abfd, r_type, FALSE, location);
  addend = mips_elf_obtain_contents (howto, rel, abfd, contents);
  _bfd_mips_elf_reloc_shuffle (abfd, r_type, FALSE, location);

  return addend & howto->src_mask;
}

/* REL is a relocation in ABFD that needs a partnering LO16 relocation
   and *ADDEND is the addend for REL itself.  Look for the LO16 relocation
   and update *ADDEND with the final addend.  Return true on success
   or false if the LO16 could not be found.  RELEND is the exclusive
   upper bound on the relocations for REL's section.  */

static bfd_boolean
mips_elf_add_lo16_rel_addend (bfd *abfd,
			      const Elf_Internal_Rela *rel,
			      const Elf_Internal_Rela *relend,
			      bfd_byte *contents, bfd_vma *addend)
{
  unsigned int r_type, lo16_type;
  const Elf_Internal_Rela *lo16_relocation;
  reloc_howto_type *lo16_howto;
  bfd_vma l;

  r_type = ELF_R_TYPE (abfd, rel->r_info);
  if (mips16_reloc_p (r_type))
    lo16_type = R_MIPS16_LO16;
  else if (micromips_reloc_p (r_type))
    lo16_type = R_MICROMIPS_LO16;
  else
    lo16_type = R_MIPS_LO16;

  /* The combined value is the sum of the HI16 addend, left-shifted by
     sixteen bits, and the LO16 addend, sign extended.  (Usually, the
     code does a `lui' of the HI16 value, and then an `addiu' of the
     LO16 value.)

     Scan ahead to find a matching LO16 relocation.

     According to the MIPS ELF ABI, the R_MIPS_LO16 relocation must
     be immediately following.  However, for the IRIX6 ABI, the next
     relocation may be a composed relocation consisting of several
     relocations for the same address.  In that case, the R_MIPS_LO16
     relocation may occur as one of these.  We permit a similar
     extension in general, as that is useful for GCC.

     In some cases GCC dead code elimination removes the LO16 but keeps
     the corresponding HI16.  This is strictly speaking a violation of
     the ABI but not immediately harmful.  */
  lo16_relocation = mips_elf_next_relocation (abfd, lo16_type, rel, relend);
  if (lo16_relocation == NULL)
    return FALSE;

  /* Obtain the addend kept there.  */
  lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (abfd, lo16_type, FALSE);
  l = mips_elf_read_rel_addend (abfd, lo16_relocation, lo16_howto, contents);

  l <<= lo16_howto->rightshift;
  l = _bfd_mips_elf_sign_extend (l, 16);

  *addend <<= 16;
  *addend += l;
  return TRUE;
}

/* Try to read the contents of section SEC in bfd ABFD.  Return true and
   store the contents in *CONTENTS on success.  Assume that *CONTENTS
   already holds the contents if it is nonull on entry.  */

static bfd_boolean
mips_elf_get_section_contents (bfd *abfd, asection *sec, bfd_byte **contents)
{
  if (*contents)
    return TRUE;

  /* Get cached copy if it exists.  */
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    {
      *contents = elf_section_data (sec)->this_hdr.contents;
      return TRUE;
    }

  return bfd_malloc_and_get_section (abfd, sec, contents);
}

/* Make a new PLT record to keep internal data.  */

static struct plt_entry *
mips_elf_make_plt_record (bfd *abfd)
{
  struct plt_entry *entry;

  entry = bfd_zalloc (abfd, sizeof (*entry));
  if (entry == NULL)
    return NULL;

  entry->stub_offset = MINUS_ONE;
  entry->mips_offset = MINUS_ONE;
  entry->comp_offset = MINUS_ONE;
  entry->gotplt_index = MINUS_ONE;
  return entry;
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table and record the need for
   standard MIPS and compressed procedure linkage table entries.  */

bfd_boolean
_bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
			    asection *sec, const Elf_Internal_Rela *relocs)
{
  const char *name;
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  size_t extsymoff;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sreloc;
  const struct elf_backend_data *bed;
  struct mips_elf_link_hash_table *htab;
  bfd_byte *contents;
  bfd_vma addend;
  reloc_howto_type *howto;

  if (info->relocatable)
    return TRUE;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;

  bed = get_elf_backend_data (abfd);
  rel_end = relocs + sec->reloc_count * bed->s->int_rels_per_ext_rel;

  /* Check for the mips16 stub sections.  */

  name = bfd_get_section_name (abfd, sec);
  if (FN_STUB_P (name))
    {
      unsigned long r_symndx;

      /* Look at the relocation information to figure out which symbol
         this is for.  */

      r_symndx = mips16_stub_symndx (bed, sec, relocs, rel_end);
      if (r_symndx == 0)
	{
	  (*_bfd_error_handler)
	    (_("%B: Warning: cannot determine the target function for"
	       " stub section `%s'"),
	     abfd, name);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (r_symndx < extsymoff
	  || sym_hashes[r_symndx - extsymoff] == NULL)
	{
	  asection *o;

	  /* This stub is for a local symbol.  This stub will only be
             needed if there is some relocation in this BFD, other
             than a 16 bit function call, which refers to this symbol.  */
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      Elf_Internal_Rela *sec_relocs;
	      const Elf_Internal_Rela *r, *rend;

	      /* We can ignore stub sections when looking for relocs.  */
	      if ((o->flags & SEC_RELOC) == 0
		  || o->reloc_count == 0
		  || section_allows_mips16_refs_p (o))
		continue;

	      sec_relocs
		= _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
					     info->keep_memory);
	      if (sec_relocs == NULL)
		return FALSE;

	      rend = sec_relocs + o->reloc_count;
	      for (r = sec_relocs; r < rend; r++)
		if (ELF_R_SYM (abfd, r->r_info) == r_symndx
		    && !mips16_call_reloc_p (ELF_R_TYPE (abfd, r->r_info)))
		  break;

	      if (elf_section_data (o)->relocs != sec_relocs)
		free (sec_relocs);

	      if (r < rend)
		break;
	    }

	  if (o == NULL)
	    {
	      /* There is no non-call reloc for this stub, so we do
                 not need it.  Since this function is called before
                 the linker maps input sections to output sections, we
                 can easily discard it by setting the SEC_EXCLUDE
                 flag.  */
	      sec->flags |= SEC_EXCLUDE;
	      return TRUE;
	    }

	  /* Record this stub in an array of local symbol stubs for
             this BFD.  */
	  if (mips_elf_tdata (abfd)->local_stubs == NULL)
	    {
	      unsigned long symcount;
	      asection **n;
	      bfd_size_type amt;

	      if (elf_bad_symtab (abfd))
		symcount = NUM_SHDR_ENTRIES (symtab_hdr);
	      else
		symcount = symtab_hdr->sh_info;
	      amt = symcount * sizeof (asection *);
	      n = bfd_zalloc (abfd, amt);
	      if (n == NULL)
		return FALSE;
	      mips_elf_tdata (abfd)->local_stubs = n;
	    }

	  sec->flags |= SEC_KEEP;
	  mips_elf_tdata (abfd)->local_stubs[r_symndx] = sec;

	  /* We don't need to set mips16_stubs_seen in this case.
             That flag is used to see whether we need to look through
             the global symbol table for stubs.  We don't need to set
             it here, because we just have a local stub.  */
	}
      else
	{
	  struct mips_elf_link_hash_entry *h;

	  h = ((struct mips_elf_link_hash_entry *)
	       sym_hashes[r_symndx - extsymoff]);

	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

	  /* H is the symbol this stub is for.  */

	  /* If we already have an appropriate stub for this function, we
	     don't need another one, so we can discard this one.  Since
	     this function is called before the linker maps input sections
	     to output sections, we can easily discard it by setting the
	     SEC_EXCLUDE flag.  */
	  if (h->fn_stub != NULL)
	    {
	      sec->flags |= SEC_EXCLUDE;
	      return TRUE;
	    }

	  sec->flags |= SEC_KEEP;
	  h->fn_stub = sec;
	  mips_elf_hash_table (info)->mips16_stubs_seen = TRUE;
	}
    }
  else if (CALL_STUB_P (name) || CALL_FP_STUB_P (name))
    {
      unsigned long r_symndx;
      struct mips_elf_link_hash_entry *h;
      asection **loc;

      /* Look at the relocation information to figure out which symbol
         this is for.  */

      r_symndx = mips16_stub_symndx (bed, sec, relocs, rel_end);
      if (r_symndx == 0)
	{
	  (*_bfd_error_handler)
	    (_("%B: Warning: cannot determine the target function for"
	       " stub section `%s'"),
	     abfd, name);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (r_symndx < extsymoff
	  || sym_hashes[r_symndx - extsymoff] == NULL)
	{
	  asection *o;

	  /* This stub is for a local symbol.  This stub will only be
             needed if there is some relocation (R_MIPS16_26) in this BFD
             that refers to this symbol.  */
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      Elf_Internal_Rela *sec_relocs;
	      const Elf_Internal_Rela *r, *rend;

	      /* We can ignore stub sections when looking for relocs.  */
	      if ((o->flags & SEC_RELOC) == 0
		  || o->reloc_count == 0
		  || section_allows_mips16_refs_p (o))
		continue;

	      sec_relocs
		= _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
					     info->keep_memory);
	      if (sec_relocs == NULL)
		return FALSE;

	      rend = sec_relocs + o->reloc_count;
	      for (r = sec_relocs; r < rend; r++)
		if (ELF_R_SYM (abfd, r->r_info) == r_symndx
		    && ELF_R_TYPE (abfd, r->r_info) == R_MIPS16_26)
		    break;

	      if (elf_section_data (o)->relocs != sec_relocs)
		free (sec_relocs);

	      if (r < rend)
		break;
	    }

	  if (o == NULL)
	    {
	      /* There is no non-call reloc for this stub, so we do
                 not need it.  Since this function is called before
                 the linker maps input sections to output sections, we
                 can easily discard it by setting the SEC_EXCLUDE
                 flag.  */
	      sec->flags |= SEC_EXCLUDE;
	      return TRUE;
	    }

	  /* Record this stub in an array of local symbol call_stubs for
             this BFD.  */
	  if (mips_elf_tdata (abfd)->local_call_stubs == NULL)
	    {
	      unsigned long symcount;
	      asection **n;
	      bfd_size_type amt;

	      if (elf_bad_symtab (abfd))
		symcount = NUM_SHDR_ENTRIES (symtab_hdr);
	      else
		symcount = symtab_hdr->sh_info;
	      amt = symcount * sizeof (asection *);
	      n = bfd_zalloc (abfd, amt);
	      if (n == NULL)
		return FALSE;
	      mips_elf_tdata (abfd)->local_call_stubs = n;
	    }

	  sec->flags |= SEC_KEEP;
	  mips_elf_tdata (abfd)->local_call_stubs[r_symndx] = sec;

	  /* We don't need to set mips16_stubs_seen in this case.
             That flag is used to see whether we need to look through
             the global symbol table for stubs.  We don't need to set
             it here, because we just have a local stub.  */
	}
      else
	{
	  h = ((struct mips_elf_link_hash_entry *)
	       sym_hashes[r_symndx - extsymoff]);

	  /* H is the symbol this stub is for.  */

	  if (CALL_FP_STUB_P (name))
	    loc = &h->call_fp_stub;
	  else
	    loc = &h->call_stub;

	  /* If we already have an appropriate stub for this function, we
	     don't need another one, so we can discard this one.  Since
	     this function is called before the linker maps input sections
	     to output sections, we can easily discard it by setting the
	     SEC_EXCLUDE flag.  */
	  if (*loc != NULL)
	    {
	      sec->flags |= SEC_EXCLUDE;
	      return TRUE;
	    }

	  sec->flags |= SEC_KEEP;
	  *loc = sec;
	  mips_elf_hash_table (info)->mips16_stubs_seen = TRUE;
	}
    }

  sreloc = NULL;
  contents = NULL;
  for (rel = relocs; rel < rel_end; ++rel)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h;
      bfd_boolean can_make_dynamic_p;
      bfd_boolean call_reloc_p;
      bfd_boolean constrain_symbol_p;

      r_symndx = ELF_R_SYM (abfd, rel->r_info);
      r_type = ELF_R_TYPE (abfd, rel->r_info);

      if (r_symndx < extsymoff)
	h = NULL;
      else if (r_symndx >= extsymoff + NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler)
	    (_("%B: Malformed reloc detected for section %s"),
	     abfd, name);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      else
	{
	  h = sym_hashes[r_symndx - extsymoff];
	  if (h != NULL)
	    {
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;

	      /* PR15323, ref flags aren't set for references in the
		 same object.  */
	      h->root.non_ir_ref = 1;
	    }
	}

      /* Set CAN_MAKE_DYNAMIC_P to true if we can convert this
	 relocation into a dynamic one.  */
      can_make_dynamic_p = FALSE;

      /* Set CALL_RELOC_P to true if the relocation is for a call,
	 and if pointer equality therefore doesn't matter.  */
      call_reloc_p = FALSE;

      /* Set CONSTRAIN_SYMBOL_P if we need to take the relocation
	 into account when deciding how to define the symbol.
	 Relocations in nonallocatable sections such as .pdr and
	 .debug* should have no effect.  */
      constrain_symbol_p = ((sec->flags & SEC_ALLOC) != 0);

      switch (r_type)
	{
	case R_MIPS_CALL16:
	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	case R_MIPS16_CALL16:
	case R_MICROMIPS_CALL16:
	case R_MICROMIPS_CALL_HI16:
	case R_MICROMIPS_CALL_LO16:
	  call_reloc_p = TRUE;
	  /* Fall through.  */

	case R_MIPS_GOT16:
	case R_MIPS_GOT_HI16:
	case R_MIPS_GOT_LO16:
	case R_MIPS_GOT_PAGE:
	case R_MIPS_GOT_OFST:
	case R_MIPS_GOT_DISP:
	case R_MIPS_TLS_GOTTPREL:
	case R_MIPS_TLS_GD:
	case R_MIPS_TLS_LDM:
	case R_MIPS16_GOT16:
	case R_MIPS16_TLS_GOTTPREL:
	case R_MIPS16_TLS_GD:
	case R_MIPS16_TLS_LDM:
	case R_MICROMIPS_GOT16:
	case R_MICROMIPS_GOT_HI16:
	case R_MICROMIPS_GOT_LO16:
	case R_MICROMIPS_GOT_PAGE:
	case R_MICROMIPS_GOT_OFST:
	case R_MICROMIPS_GOT_DISP:
	case R_MICROMIPS_TLS_GOTTPREL:
	case R_MICROMIPS_TLS_GD:
	case R_MICROMIPS_TLS_LDM:
	  if (dynobj == NULL)
	    elf_hash_table (info)->dynobj = dynobj = abfd;
	  if (!mips_elf_create_got_section (dynobj, info))
	    return FALSE;
	  if (htab->is_vxworks && !info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%B: GOT reloc at 0x%lx not expected in executables"),
		 abfd, (unsigned long) rel->r_offset);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  can_make_dynamic_p = TRUE;
	  break;

	case R_MIPS_NONE:
	case R_MIPS_JALR:
	case R_MICROMIPS_JALR:
	  /* These relocations have empty fields and are purely there to
	     provide link information.  The symbol value doesn't matter.  */
	  constrain_symbol_p = FALSE;
	  break;

	case R_MIPS_GPREL16:
	case R_MIPS_GPREL32:
	case R_MIPS16_GPREL:
	case R_MICROMIPS_GPREL16:
	  /* GP-relative relocations always resolve to a definition in a
	     regular input file, ignoring the one-definition rule.  This is
	     important for the GP setup sequence in NewABI code, which
	     always resolves to a local function even if other relocations
	     against the symbol wouldn't.  */
	  constrain_symbol_p = FALSE;
	  break;

	case R_MIPS_32:
	case R_MIPS_REL32:
	case R_MIPS_64:
	  /* In VxWorks executables, references to external symbols
	     must be handled using copy relocs or PLT entries; it is not
	     possible to convert this relocation into a dynamic one.

	     For executables that use PLTs and copy-relocs, we have a
	     choice between converting the relocation into a dynamic
	     one or using copy relocations or PLT entries.  It is
	     usually better to do the former, unless the relocation is
	     against a read-only section.  */
	  if ((info->shared
	       || (h != NULL
		   && !htab->is_vxworks
		   && strcmp (h->root.root.string, "__gnu_local_gp") != 0
		   && !(!info->nocopyreloc
			&& !PIC_OBJECT_P (abfd)
			&& MIPS_ELF_READONLY_SECTION (sec))))
	      && (sec->flags & SEC_ALLOC) != 0)
	    {
	      can_make_dynamic_p = TRUE;
	      if (dynobj == NULL)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	    }
	  break;

	case R_MIPS_26:
	case R_MIPS_PC16:
	case R_MIPS16_26:
	case R_MICROMIPS_26_S1:
	case R_MICROMIPS_PC7_S1:
	case R_MICROMIPS_PC10_S1:
	case R_MICROMIPS_PC16_S1:
	case R_MICROMIPS_PC23_S2:
	  call_reloc_p = TRUE;
	  break;
	}

      if (h)
	{
	  if (constrain_symbol_p)
	    {
	      if (!can_make_dynamic_p)
		((struct mips_elf_link_hash_entry *) h)->has_static_relocs = 1;

	      if (!call_reloc_p)
		h->pointer_equality_needed = 1;

	      /* We must not create a stub for a symbol that has
		 relocations related to taking the function's address.
		 This doesn't apply to VxWorks, where CALL relocs refer
		 to a .got.plt entry instead of a normal .got entry.  */
	      if (!htab->is_vxworks && (!can_make_dynamic_p || !call_reloc_p))
		((struct mips_elf_link_hash_entry *) h)->no_fn_stub = TRUE;
	    }

	  /* Relocations against the special VxWorks __GOTT_BASE__ and
	     __GOTT_INDEX__ symbols must be left to the loader.  Allocate
	     room for them in .rela.dyn.  */
	  if (is_gott_symbol (info, h))
	    {
	      if (sreloc == NULL)
		{
		  sreloc = mips_elf_rel_dyn_section (info, TRUE);
		  if (sreloc == NULL)
		    return FALSE;
		}
	      mips_elf_allocate_dynamic_relocations (dynobj, info, 1);
	      if (MIPS_ELF_READONLY_SECTION (sec))
		/* We tell the dynamic linker that there are
		   relocations against the text segment.  */
		info->flags |= DF_TEXTREL;
	    }
	}
      else if (call_lo16_reloc_p (r_type)
	       || got_lo16_reloc_p (r_type)
	       || got_disp_reloc_p (r_type)
	       || (got16_reloc_p (r_type) && htab->is_vxworks))
	{
	  /* We may need a local GOT entry for this relocation.  We
	     don't count R_MIPS_GOT_PAGE because we can estimate the
	     maximum number of pages needed by looking at the size of
	     the segment.  Similar comments apply to R_MIPS*_GOT16 and
	     R_MIPS*_CALL16, except on VxWorks, where GOT relocations
	     always evaluate to "G".  We don't count R_MIPS_GOT_HI16, or
	     R_MIPS_CALL_HI16 because these are always followed by an
	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.  */
	  if (!mips_elf_record_local_got_symbol (abfd, r_symndx,
						 rel->r_addend, info, r_type))
	    return FALSE;
	}

      if (h != NULL
	  && mips_elf_relocation_needs_la25_stub (abfd, r_type,
						  ELF_ST_IS_MIPS16 (h->other)))
	((struct mips_elf_link_hash_entry *) h)->has_nonpic_branches = TRUE;

      switch (r_type)
	{
	case R_MIPS_CALL16:
	case R_MIPS16_CALL16:
	case R_MICROMIPS_CALL16:
	  if (h == NULL)
	    {
	      (*_bfd_error_handler)
		(_("%B: CALL16 reloc at 0x%lx not against global symbol"),
		 abfd, (unsigned long) rel->r_offset);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  /* Fall through.  */

	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	case R_MICROMIPS_CALL_HI16:
	case R_MICROMIPS_CALL_LO16:
	  if (h != NULL)
	    {
	      /* Make sure there is room in the regular GOT to hold the
		 function's address.  We may eliminate it in favour of
		 a .got.plt entry later; see mips_elf_count_got_symbols.  */
	      if (!mips_elf_record_global_got_symbol (h, abfd, info, TRUE,
						      r_type))
		return FALSE;

	      /* We need a stub, not a plt entry for the undefined
		 function.  But we record it as if it needs plt.  See
		 _bfd_elf_adjust_dynamic_symbol.  */
	      h->needs_plt = 1;
	      h->type = STT_FUNC;
	    }
	  break;

	case R_MIPS_GOT_PAGE:
	case R_MICROMIPS_GOT_PAGE:
	case R_MIPS16_GOT16:
	case R_MIPS_GOT16:
	case R_MIPS_GOT_HI16:
	case R_MIPS_GOT_LO16:
	case R_MICROMIPS_GOT16:
	case R_MICROMIPS_GOT_HI16:
	case R_MICROMIPS_GOT_LO16:
	  if (!h || got_page_reloc_p (r_type))
	    {
	      /* This relocation needs (or may need, if h != NULL) a
		 page entry in the GOT.  For R_MIPS_GOT_PAGE we do not
		 know for sure until we know whether the symbol is
		 preemptible.  */
	      if (mips_elf_rel_relocation_p (abfd, sec, relocs, rel))
		{
		  if (!mips_elf_get_section_contents (abfd, sec, &contents))
		    return FALSE;
		  howto = MIPS_ELF_RTYPE_TO_HOWTO (abfd, r_type, FALSE);
		  addend = mips_elf_read_rel_addend (abfd, rel,
						     howto, contents);
		  if (got16_reloc_p (r_type))
		    mips_elf_add_lo16_rel_addend (abfd, rel, rel_end,
						  contents, &addend);
		  else
		    addend <<= howto->rightshift;
		}
	      else
		addend = rel->r_addend;
	      if (!mips_elf_record_got_page_ref (info, abfd, r_symndx,
						 h, addend))
		return FALSE;

	      if (h)
		{
		  struct mips_elf_link_hash_entry *hmips =
		    (struct mips_elf_link_hash_entry *) h;

		  /* This symbol is definitely not overridable.  */
		  if (hmips->root.def_regular
		      && ! (info->shared && ! info->symbolic
			    && ! hmips->root.forced_local))
		    h = NULL;
		}
	    }
	  /* If this is a global, overridable symbol, GOT_PAGE will
	     decay to GOT_DISP, so we'll need a GOT entry for it.  */
	  /* Fall through.  */

	case R_MIPS_GOT_DISP:
	case R_MICROMIPS_GOT_DISP:
	  if (h && !mips_elf_record_global_got_symbol (h, abfd, info,
						       FALSE, r_type))
	    return FALSE;
	  break;

	case R_MIPS_TLS_GOTTPREL:
	case R_MIPS16_TLS_GOTTPREL:
	case R_MICROMIPS_TLS_GOTTPREL:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through */

	case R_MIPS_TLS_LDM:
	case R_MIPS16_TLS_LDM:
	case R_MICROMIPS_TLS_LDM:
	  if (tls_ldm_reloc_p (r_type))
	    {
	      r_symndx = STN_UNDEF;
	      h = NULL;
	    }
	  /* Fall through */

	case R_MIPS_TLS_GD:
	case R_MIPS16_TLS_GD:
	case R_MICROMIPS_TLS_GD:
	  /* This symbol requires a global offset table entry, or two
	     for TLS GD relocations.  */
	  if (h != NULL)
	    {
	      if (!mips_elf_record_global_got_symbol (h, abfd, info,
						      FALSE, r_type))
		return FALSE;
	    }
	  else
	    {
	      if (!mips_elf_record_local_got_symbol (abfd, r_symndx,
						     rel->r_addend,
						     info, r_type))
		return FALSE;
	    }
	  break;

	case R_MIPS_32:
	case R_MIPS_REL32:
	case R_MIPS_64:
	  /* In VxWorks executables, references to external symbols
	     are handled using copy relocs or PLT stubs, so there's
	     no need to add a .rela.dyn entry for this relocation.  */
	  if (can_make_dynamic_p)
	    {
	      if (sreloc == NULL)
		{
		  sreloc = mips_elf_rel_dyn_section (info, TRUE);
		  if (sreloc == NULL)
		    return FALSE;
		}
	      if (info->shared && h == NULL)
		{
		  /* When creating a shared object, we must copy these
		     reloc types into the output file as R_MIPS_REL32
		     relocs.  Make room for this reloc in .rel(a).dyn.  */
		  mips_elf_allocate_dynamic_relocations (dynobj, info, 1);
		  if (MIPS_ELF_READONLY_SECTION (sec))
		    /* We tell the dynamic linker that there are
		       relocations against the text segment.  */
		    info->flags |= DF_TEXTREL;
		}
	      else
		{
		  struct mips_elf_link_hash_entry *hmips;

		  /* For a shared object, we must copy this relocation
		     unless the symbol turns out to be undefined and
		     weak with non-default visibility, in which case
		     it will be left as zero.

		     We could elide R_MIPS_REL32 for locally binding symbols
		     in shared libraries, but do not yet do so.

		     For an executable, we only need to copy this
		     reloc if the symbol is defined in a dynamic
		     object.  */
		  hmips = (struct mips_elf_link_hash_entry *) h;
		  ++hmips->possibly_dynamic_relocs;
		  if (MIPS_ELF_READONLY_SECTION (sec))
		    /* We need it to tell the dynamic linker if there
		       are relocations against the text segment.  */
		    hmips->readonly_reloc = TRUE;
		}
	    }

	  if (SGI_COMPAT (abfd))
	    mips_elf_hash_table (info)->compact_rel_size +=
	      sizeof (Elf32_External_crinfo);
	  break;

	case R_MIPS_26:
	case R_MIPS_GPREL16:
	case R_MIPS_LITERAL:
	case R_MIPS_GPREL32:
	case R_MICROMIPS_26_S1:
	case R_MICROMIPS_GPREL16:
	case R_MICROMIPS_LITERAL:
	case R_MICROMIPS_GPREL7_S2:
	  if (SGI_COMPAT (abfd))
	    mips_elf_hash_table (info)->compact_rel_size +=
	      sizeof (Elf32_External_crinfo);
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_MIPS_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_MIPS_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	default:
	  break;
	}

      /* Record the need for a PLT entry.  At this point we don't know
         yet if we are going to create a PLT in the first place, but
         we only record whether the relocation requires a standard MIPS
         or a compressed code entry anyway.  If we don't make a PLT after
         all, then we'll just ignore these arrangements.  Likewise if
         a PLT entry is not created because the symbol is satisfied
         locally.  */
      if (h != NULL
	  && jal_reloc_p (r_type)
	  && !SYMBOL_CALLS_LOCAL (info, h))
	{
	  if (h->plt.plist == NULL)
	    h->plt.plist = mips_elf_make_plt_record (abfd);
	  if (h->plt.plist == NULL)
	    return FALSE;

	  if (r_type == R_MIPS_26)
	    h->plt.plist->need_mips = TRUE;
	  else
	    h->plt.plist->need_comp = TRUE;
	}

      /* See if this reloc would need to refer to a MIPS16 hard-float stub,
	 if there is one.  We only need to handle global symbols here;
	 we decide whether to keep or delete stubs for local symbols
	 when processing the stub's relocations.  */
      if (h != NULL
	  && !mips16_call_reloc_p (r_type)
	  && !section_allows_mips16_refs_p (sec))
	{
	  struct mips_elf_link_hash_entry *mh;

	  mh = (struct mips_elf_link_hash_entry *) h;
	  mh->need_fn_stub = TRUE;
	}

      /* Refuse some position-dependent relocations when creating a
	 shared library.  Do not refuse R_MIPS_32 / R_MIPS_64; they're
	 not PIC, but we can create dynamic relocations and the result
	 will be fine.  Also do not refuse R_MIPS_LO16, which can be
	 combined with R_MIPS_GOT16.  */
      if (info->shared)
	{
	  switch (r_type)
	    {
	    case R_MIPS16_HI16:
	    case R_MIPS_HI16:
	    case R_MIPS_HIGHER:
	    case R_MIPS_HIGHEST:
	    case R_MICROMIPS_HI16:
	    case R_MICROMIPS_HIGHER:
	    case R_MICROMIPS_HIGHEST:
	      /* Don't refuse a high part relocation if it's against
		 no symbol (e.g. part of a compound relocation).  */
	      if (r_symndx == STN_UNDEF)
		break;

	      /* R_MIPS_HI16 against _gp_disp is used for $gp setup,
		 and has a special meaning.  */
	      if (!NEWABI_P (abfd) && h != NULL
		  && strcmp (h->root.root.string, "_gp_disp") == 0)
		break;

	      /* Likewise __GOTT_BASE__ and __GOTT_INDEX__ on VxWorks.  */
	      if (is_gott_symbol (info, h))
		break;

	      /* FALLTHROUGH */

	    case R_MIPS16_26:
	    case R_MIPS_26:
	    case R_MICROMIPS_26_S1:
	      howto = MIPS_ELF_RTYPE_TO_HOWTO (abfd, r_type, FALSE);
	      (*_bfd_error_handler)
		(_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		 abfd, howto->name,
		 (h) ? h->root.root.string : "a local symbol");
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    default:
	      break;
	    }
	}
    }

  return TRUE;
}

bfd_boolean
_bfd_mips_relax_section (bfd *abfd, asection *sec,
			 struct bfd_link_info *link_info,
			 bfd_boolean *again)
{
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Shdr *symtab_hdr;
  bfd_byte *contents = NULL;
  size_t extsymoff;
  bfd_boolean changed_contents = FALSE;
  bfd_vma sec_start = sec->output_section->vma + sec->output_offset;
  Elf_Internal_Sym *isymbuf = NULL;

  /* We are not currently changing any sizes, so only one pass.  */
  *again = FALSE;

  if (link_info->relocatable)
    return TRUE;

  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
					       link_info->keep_memory);
  if (internal_relocs == NULL)
    return TRUE;

  irelend = internal_relocs + sec->reloc_count
    * get_elf_backend_data (abfd)->s->int_rels_per_ext_rel;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      bfd_signed_vma sym_offset;
      unsigned int r_type;
      unsigned long r_symndx;
      asection *sym_sec;
      unsigned long instruction;

      /* Turn jalr into bgezal, and jr into beq, if they're marked
	 with a JALR relocation, that indicate where they jump to.
	 This saves some pipeline bubbles.  */
      r_type = ELF_R_TYPE (abfd, irel->r_info);
      if (r_type != R_MIPS_JALR)
	continue;

      r_symndx = ELF_R_SYM (abfd, irel->r_info);
      /* Compute the address of the jump target.  */
      if (r_symndx >= extsymoff)
	{
	  struct mips_elf_link_hash_entry *h
	    = ((struct mips_elf_link_hash_entry *)
	       elf_sym_hashes (abfd) [r_symndx - extsymoff]);

	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

	  /* If a symbol is undefined, or if it may be overridden,
	     skip it.  */
	  if (! ((h->root.root.type == bfd_link_hash_defined
		  || h->root.root.type == bfd_link_hash_defweak)
		 && h->root.root.u.def.section)
	      || (link_info->shared && ! link_info->symbolic
		  && !h->root.forced_local))
	    continue;

	  sym_sec = h->root.root.u.def.section;
	  if (sym_sec->output_section)
	    symval = (h->root.root.u.def.value
		      + sym_sec->output_section->vma
		      + sym_sec->output_offset);
	  else
	    symval = h->root.root.u.def.value;
	}
      else
	{
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's symbols if we haven't done so already.  */
	  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto relax_return;
	    }

	  isym = isymbuf + r_symndx;
	  if (isym->st_shndx == SHN_UNDEF)
	    continue;
	  else if (isym->st_shndx == SHN_ABS)
	    sym_sec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    sym_sec = bfd_com_section_ptr;
	  else
	    sym_sec
	      = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = isym->st_value
	    + sym_sec->output_section->vma
	    + sym_sec->output_offset;
	}

      /* Compute branch offset, from delay slot of the jump to the
	 branch target.  */
      sym_offset = (symval + irel->r_addend)
	- (sec_start + irel->r_offset + 4);

      /* Branch offset must be properly aligned.  */
      if ((sym_offset & 3) != 0)
	continue;

      sym_offset >>= 2;

      /* Check that it's in range.  */
      if (sym_offset < -0x8000 || sym_offset >= 0x8000)
	continue;

      /* Get the section contents if we haven't done so already.  */
      if (!mips_elf_get_section_contents (abfd, sec, &contents))
	goto relax_return;

      instruction = bfd_get_32 (abfd, contents + irel->r_offset);

      /* If it was jalr <reg>, turn it into bgezal $zero, <target>.  */
      if ((instruction & 0xfc1fffff) == 0x0000f809)
	instruction = 0x04110000;
      /* If it was jr <reg>, turn it into b <target>.  */
      else if ((instruction & 0xfc1fffff) == 0x00000008)
	instruction = 0x10000000;
      else
	continue;

      instruction |= (sym_offset & 0xffff);
      bfd_put_32 (abfd, instruction, contents + irel->r_offset);
      changed_contents = TRUE;
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (!changed_contents && !link_info->keep_memory)
        free (contents);
      else
        {
          /* Cache the section contents for elf_link_input_bfd.  */
          elf_section_data (sec)->this_hdr.contents = contents;
        }
    }
  return TRUE;

 relax_return:
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  return FALSE;
}

/* Allocate space for global sym dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info = inf;
  bfd *dynobj;
  struct mips_elf_link_hash_entry *hmips;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  dynobj = elf_hash_table (info)->dynobj;
  hmips = (struct mips_elf_link_hash_entry *) h;

  /* VxWorks executables are handled elsewhere; we only need to
     allocate relocations in shared objects.  */
  if (htab->is_vxworks && !info->shared)
    return TRUE;

  /* Ignore indirect symbols.  All relocations against such symbols
     will be redirected to the target symbol.  */
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  /* If this symbol is defined in a dynamic object, or we are creating
     a shared library, we will need to copy any R_MIPS_32 or
     R_MIPS_REL32 relocs against it into the output file.  */
  if (! info->relocatable
      && hmips->possibly_dynamic_relocs != 0
      && (h->root.type == bfd_link_hash_defweak
	  || (!h->def_regular && !ELF_COMMON_DEF_P (h))
	  || info->shared))
    {
      bfd_boolean do_copy = TRUE;

      if (h->root.type == bfd_link_hash_undefweak)
	{
	  /* Do not copy relocations for undefined weak symbols with
	     non-default visibility.  */
	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	    do_copy = FALSE;

	  /* Make sure undefined weak symbols are output as a dynamic
	     symbol in PIEs.  */
	  else if (h->dynindx == -1 && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
	}

      if (do_copy)
	{
	  /* Even though we don't directly need a GOT entry for this symbol,
	     the SVR4 psABI requires it to have a dynamic symbol table
	     index greater that DT_MIPS_GOTSYM if there are dynamic
	     relocations against it.

	     VxWorks does not enforce the same mapping between the GOT
	     and the symbol table, so the same requirement does not
	     apply there.  */
	  if (!htab->is_vxworks)
	    {
	      if (hmips->global_got_area > GGA_RELOC_ONLY)
		hmips->global_got_area = GGA_RELOC_ONLY;
	      hmips->got_only_for_calls = FALSE;
	    }

	  mips_elf_allocate_dynamic_relocations
	    (dynobj, info, hmips->possibly_dynamic_relocs);
	  if (hmips->readonly_reloc)
	    /* We tell the dynamic linker that there are relocations
	       against the text segment.  */
	    info->flags |= DF_TEXTREL;
	}
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

bfd_boolean
_bfd_mips_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
				     struct elf_link_hash_entry *h)
{
  bfd *dynobj;
  struct mips_elf_link_hash_entry *hmips;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  dynobj = elf_hash_table (info)->dynobj;
  hmips = (struct mips_elf_link_hash_entry *) h;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  hmips = (struct mips_elf_link_hash_entry *) h;

  /* If there are call relocations against an externally-defined symbol,
     see whether we can create a MIPS lazy-binding stub for it.  We can
     only do this if all references to the function are through call
     relocations, and in that case, the traditional lazy-binding stubs
     are much more efficient than PLT entries.

     Traditional stubs are only available on SVR4 psABI-based systems;
     VxWorks always uses PLTs instead.  */
  if (!htab->is_vxworks && h->needs_plt && !hmips->no_fn_stub)
    {
      if (! elf_hash_table (info)->dynamic_sections_created)
	return TRUE;

      /* If this symbol is not defined in a regular file, then set
	 the symbol to the stub location.  This is required to make
	 function pointers compare as equal between the normal
	 executable and the shared library.  */
      if (!h->def_regular)
	{
	  hmips->needs_lazy_stub = TRUE;
	  htab->lazy_stub_count++;
	  return TRUE;
	}
    }
  /* As above, VxWorks requires PLT entries for externally-defined
     functions that are only accessed through call relocations.

     Both VxWorks and non-VxWorks targets also need PLT entries if there
     are static-only relocations against an externally-defined function.
     This can technically occur for shared libraries if there are
     branches to the symbol, although it is unlikely that this will be
     used in practice due to the short ranges involved.  It can occur
     for any relative or absolute relocation in executables; in that
     case, the PLT entry becomes the function's canonical address.  */
  else if (((h->needs_plt && !hmips->no_fn_stub)
	    || (h->type == STT_FUNC && hmips->has_static_relocs))
	   && htab->use_plts_and_copy_relocs
	   && !SYMBOL_CALLS_LOCAL (info, h)
	   && !(ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
		&& h->root.type == bfd_link_hash_undefweak))
    {
      bfd_boolean micromips_p = MICROMIPS_P (info->output_bfd);
      bfd_boolean newabi_p = NEWABI_P (info->output_bfd);

      /* If this is the first symbol to need a PLT entry, then make some
         basic setup.  Also work out PLT entry sizes.  We'll need them
         for PLT offset calculations.  */
      if (htab->plt_mips_offset + htab->plt_comp_offset == 0)
	{
	  BFD_ASSERT (htab->sgotplt->size == 0);
	  BFD_ASSERT (htab->plt_got_index == 0);

	  /* If we're using the PLT additions to the psABI, each PLT
	     entry is 16 bytes and the PLT0 entry is 32 bytes.
	     Encourage better cache usage by aligning.  We do this
	     lazily to avoid pessimizing traditional objects.  */
	  if (!htab->is_vxworks
	      && !bfd_set_section_alignment (dynobj, htab->splt, 5))
	    return FALSE;

	  /* Make sure that .got.plt is word-aligned.  We do this lazily
	     for the same reason as above.  */
	  if (!bfd_set_section_alignment (dynobj, htab->sgotplt,
					  MIPS_ELF_LOG_FILE_ALIGN (dynobj)))
	    return FALSE;

	  /* On non-VxWorks targets, the first two entries in .got.plt
	     are reserved.  */
	  if (!htab->is_vxworks)
	    htab->plt_got_index
	      += (get_elf_backend_data (dynobj)->got_header_size
		  / MIPS_ELF_GOT_SIZE (dynobj));

	  /* On VxWorks, also allocate room for the header's
	     .rela.plt.unloaded entries.  */
	  if (htab->is_vxworks && !info->shared)
	    htab->srelplt2->size += 2 * sizeof (Elf32_External_Rela);

	  /* Now work out the sizes of individual PLT entries.  */
	  if (htab->is_vxworks && info->shared)
	    htab->plt_mips_entry_size
	      = 4 * ARRAY_SIZE (mips_vxworks_shared_plt_entry);
	  else if (htab->is_vxworks)
	    htab->plt_mips_entry_size
	      = 4 * ARRAY_SIZE (mips_vxworks_exec_plt_entry);
	  else if (newabi_p)
	    htab->plt_mips_entry_size
	      = 4 * ARRAY_SIZE (mips_exec_plt_entry);
	  else if (!micromips_p)
	    {
	      htab->plt_mips_entry_size
		= 4 * ARRAY_SIZE (mips_exec_plt_entry);
	      htab->plt_comp_entry_size
		= 2 * ARRAY_SIZE (mips16_o32_exec_plt_entry);
	    }
	  else if (htab->insn32)
	    {
	      htab->plt_mips_entry_size
		= 4 * ARRAY_SIZE (mips_exec_plt_entry);
	      htab->plt_comp_entry_size
		= 2 * ARRAY_SIZE (micromips_insn32_o32_exec_plt_entry);
	    }
	  else
	    {
	      htab->plt_mips_entry_size
		= 4 * ARRAY_SIZE (mips_exec_plt_entry);
	      htab->plt_comp_entry_size
		= 2 * ARRAY_SIZE (micromips_o32_exec_plt_entry);
	    }
	}

      if (h->plt.plist == NULL)
	h->plt.plist = mips_elf_make_plt_record (dynobj);
      if (h->plt.plist == NULL)
	return FALSE;

      /* There are no defined MIPS16 or microMIPS PLT entries for VxWorks,
         n32 or n64, so always use a standard entry there.

         If the symbol has a MIPS16 call stub and gets a PLT entry, then
         all MIPS16 calls will go via that stub, and there is no benefit
         to having a MIPS16 entry.  And in the case of call_stub a
         standard entry actually has to be used as the stub ends with a J
         instruction.  */
      if (newabi_p
	  || htab->is_vxworks
	  || hmips->call_stub
	  || hmips->call_fp_stub)
	{
	  h->plt.plist->need_mips = TRUE;
	  h->plt.plist->need_comp = FALSE;
	}

      /* Otherwise, if there are no direct calls to the function, we
         have a free choice of whether to use standard or compressed
         entries.  Prefer microMIPS entries if the object is known to
         contain microMIPS code, so that it becomes possible to create
         pure microMIPS binaries.  Prefer standard entries otherwise,
         because MIPS16 ones are no smaller and are usually slower.  */
      if (!h->plt.plist->need_mips && !h->plt.plist->need_comp)
	{
	  if (micromips_p)
	    h->plt.plist->need_comp = TRUE;
	  else
	    h->plt.plist->need_mips = TRUE;
	}

      if (h->plt.plist->need_mips)
	{
	  h->plt.plist->mips_offset = htab->plt_mips_offset;
	  htab->plt_mips_offset += htab->plt_mips_entry_size;
	}
      if (h->plt.plist->need_comp)
	{
	  h->plt.plist->comp_offset = htab->plt_comp_offset;
	  htab->plt_comp_offset += htab->plt_comp_entry_size;
	}

      /* Reserve the corresponding .got.plt entry now too.  */
      h->plt.plist->gotplt_index = htab->plt_got_index++;

      /* If the output file has no definition of the symbol, set the
	 symbol's value to the address of the stub.  */
      if (!info->shared && !h->def_regular)
	hmips->use_plt_entry = TRUE;

      /* Make room for the R_MIPS_JUMP_SLOT relocation.  */
      htab->srelplt->size += (htab->is_vxworks
			      ? MIPS_ELF_RELA_SIZE (dynobj)
			      : MIPS_ELF_REL_SIZE (dynobj));

      /* Make room for the .rela.plt.unloaded relocations.  */
      if (htab->is_vxworks && !info->shared)
	htab->srelplt2->size += 3 * sizeof (Elf32_External_Rela);

      /* All relocations against this symbol that could have been made
	 dynamic will now refer to the PLT entry instead.  */
      hmips->possibly_dynamic_relocs = 0;

      return TRUE;
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* Otherwise, there is nothing further to do for symbols defined
     in regular objects.  */
  if (h->def_regular)
    return TRUE;

  /* There's also nothing more to do if we'll convert all relocations
     against this symbol into dynamic relocations.  */
  if (!hmips->has_static_relocs)
    return TRUE;

  /* We're now relying on copy relocations.  Complain if we have
     some that we can't convert.  */
  if (!htab->use_plts_and_copy_relocs || info->shared)
    {
      (*_bfd_error_handler) (_("non-dynamic relocations refer to "
			       "dynamic symbol %s"),
			     h->root.root.string);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      if (htab->is_vxworks)
	htab->srelbss->size += sizeof (Elf32_External_Rela);
      else
	mips_elf_allocate_dynamic_relocations (dynobj, info, 1);
      h->needs_copy = 1;
    }

  /* All relocations against this symbol that could have been made
     dynamic will now refer to the local copy instead.  */
  hmips->possibly_dynamic_relocs = 0;

  return _bfd_elf_adjust_dynamic_copy (h, htab->sdynbss);
}

/* This function is called after all the input files have been read,
   and the input sections have been assigned to output sections.  We
   check for any mips16 stub sections that we can discard.  */

bfd_boolean
_bfd_mips_elf_always_size_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
{
  asection *ri;
  struct mips_elf_link_hash_table *htab;
  struct mips_htab_traverse_info hti;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  /* The .reginfo section has a fixed size.  */
  ri = bfd_get_section_by_name (output_bfd, ".reginfo");
  if (ri != NULL)
    bfd_set_section_size (output_bfd, ri, sizeof (Elf32_External_RegInfo));

  hti.info = info;
  hti.output_bfd = output_bfd;
  hti.error = FALSE;
  mips_elf_link_hash_traverse (mips_elf_hash_table (info),
			       mips_elf_check_symbols, &hti);
  if (hti.error)
    return FALSE;

  return TRUE;
}

/* If the link uses a GOT, lay it out and work out its size.  */

static bfd_boolean
mips_elf_lay_out_got (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  struct mips_got_info *g;
  bfd_size_type loadable_size = 0;
  bfd_size_type page_gotno;
  bfd *ibfd;
  struct mips_elf_traverse_got_arg tga;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  s = htab->sgot;
  if (s == NULL)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  g = htab->got_info;

  /* Allocate room for the reserved entries.  VxWorks always reserves
     3 entries; other objects only reserve 2 entries.  */
  BFD_ASSERT (g->assigned_gotno == 0);
  if (htab->is_vxworks)
    htab->reserved_gotno = 3;
  else
    htab->reserved_gotno = 2;
  g->local_gotno += htab->reserved_gotno;
  g->assigned_gotno = htab->reserved_gotno;

  /* Decide which symbols need to go in the global part of the GOT and
     count the number of reloc-only GOT symbols.  */
  mips_elf_link_hash_traverse (htab, mips_elf_count_got_symbols, info);

  if (!mips_elf_resolve_final_got_entries (info, g))
    return FALSE;

  /* Calculate the total loadable size of the output.  That
     will give us the maximum number of GOT_PAGE entries
     required.  */
  for (ibfd = info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      asection *subsection;

      for (subsection = ibfd->sections;
	   subsection;
	   subsection = subsection->next)
	{
	  if ((subsection->flags & SEC_ALLOC) == 0)
	    continue;
	  loadable_size += ((subsection->size + 0xf)
			    &~ (bfd_size_type) 0xf);
	}
    }

  if (htab->is_vxworks)
    /* There's no need to allocate page entries for VxWorks; R_MIPS*_GOT16
       relocations against local symbols evaluate to "G", and the EABI does
       not include R_MIPS_GOT_PAGE.  */
    page_gotno = 0;
  else
    /* Assume there are two loadable segments consisting of contiguous
       sections.  Is 5 enough?  */
    page_gotno = (loadable_size >> 16) + 5;

  /* Choose the smaller of the two page estimates; both are intended to be
     conservative.  */
  if (page_gotno > g->page_gotno)
    page_gotno = g->page_gotno;

  g->local_gotno += page_gotno;

  s->size += g->local_gotno * MIPS_ELF_GOT_SIZE (output_bfd);
  s->size += g->global_gotno * MIPS_ELF_GOT_SIZE (output_bfd);
  s->size += g->tls_gotno * MIPS_ELF_GOT_SIZE (output_bfd);

  /* VxWorks does not support multiple GOTs.  It initializes $gp to
     __GOTT_BASE__[__GOTT_INDEX__], the value of which is set by the
     dynamic loader.  */
  if (!htab->is_vxworks && s->size > MIPS_ELF_GOT_MAX_SIZE (info))
    {
      if (!mips_elf_multi_got (output_bfd, info, s, page_gotno))
	return FALSE;
    }
  else
    {
      /* Record that all bfds use G.  This also has the effect of freeing
	 the per-bfd GOTs, which we no longer need.  */
      for (ibfd = info->input_bfds; ibfd; ibfd = ibfd->link_next)
	if (mips_elf_bfd_got (ibfd, FALSE))
	  mips_elf_replace_bfd_got (ibfd, g);
      mips_elf_replace_bfd_got (output_bfd, g);

      /* Set up TLS entries.  */
      g->tls_assigned_gotno = g->global_gotno + g->local_gotno;
      tga.info = info;
      tga.g = g;
      tga.value = MIPS_ELF_GOT_SIZE (output_bfd);
      htab_traverse (g->got_entries, mips_elf_initialize_tls_index, &tga);
      if (!tga.g)
	return FALSE;
      BFD_ASSERT (g->tls_assigned_gotno
		  == g->global_gotno + g->local_gotno + g->tls_gotno);

      /* Each VxWorks GOT entry needs an explicit relocation.  */
      if (htab->is_vxworks && info->shared)
	g->relocs += g->global_gotno + g->local_gotno - htab->reserved_gotno;

      /* Allocate room for the TLS relocations.  */
      if (g->relocs)
	mips_elf_allocate_dynamic_relocations (dynobj, info, g->relocs);
    }

  return TRUE;
}

/* Estimate the size of the .MIPS.stubs section.  */

static void
mips_elf_estimate_stub_size (bfd *output_bfd, struct bfd_link_info *info)
{
  struct mips_elf_link_hash_table *htab;
  bfd_size_type dynsymcount;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  if (htab->lazy_stub_count == 0)
    return;

  /* IRIX rld assumes that a function stub isn't at the end of the .text
     section, so add a dummy entry to the end.  */
  htab->lazy_stub_count++;

  /* Get a worst-case estimate of the number of dynamic symbols needed.
     At this point, dynsymcount does not account for section symbols
     and count_section_dynsyms may overestimate the number that will
     be needed.  */
  dynsymcount = (elf_hash_table (info)->dynsymcount
		 + count_section_dynsyms (output_bfd, info));

  /* Determine the size of one stub entry.  There's no disadvantage
     from using microMIPS code here, so for the sake of pure-microMIPS
     binaries we prefer it whenever there's any microMIPS code in
     output produced at all.  This has a benefit of stubs being
     shorter by 4 bytes each too, unless in the insn32 mode.  */
  if (!MICROMIPS_P (output_bfd))
    htab->function_stub_size = (dynsymcount > 0x10000
				? MIPS_FUNCTION_STUB_BIG_SIZE
				: MIPS_FUNCTION_STUB_NORMAL_SIZE);
  else if (htab->insn32)
    htab->function_stub_size = (dynsymcount > 0x10000
				? MICROMIPS_INSN32_FUNCTION_STUB_BIG_SIZE
				: MICROMIPS_INSN32_FUNCTION_STUB_NORMAL_SIZE);
  else
    htab->function_stub_size = (dynsymcount > 0x10000
				? MICROMIPS_FUNCTION_STUB_BIG_SIZE
				: MICROMIPS_FUNCTION_STUB_NORMAL_SIZE);

  htab->sstubs->size = htab->lazy_stub_count * htab->function_stub_size;
}

/* A mips_elf_link_hash_traverse callback for which DATA points to a
   mips_htab_traverse_info.  If H needs a traditional MIPS lazy-binding
   stub, allocate an entry in the stubs section.  */

static bfd_boolean
mips_elf_allocate_lazy_stub (struct mips_elf_link_hash_entry *h, void *data)
{
  struct mips_htab_traverse_info *hti = data;
  struct mips_elf_link_hash_table *htab;
  struct bfd_link_info *info;
  bfd *output_bfd;

  info = hti->info;
  output_bfd = hti->output_bfd;
  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  if (h->needs_lazy_stub)
    {
      bfd_boolean micromips_p = MICROMIPS_P (output_bfd);
      unsigned int other = micromips_p ? STO_MICROMIPS : 0;
      bfd_vma isa_bit = micromips_p;

      BFD_ASSERT (htab->root.dynobj != NULL);
      if (h->root.plt.plist == NULL)
	h->root.plt.plist = mips_elf_make_plt_record (htab->sstubs->owner);
      if (h->root.plt.plist == NULL)
	{
	  hti->error = TRUE;
	  return FALSE;
	}
      h->root.root.u.def.section = htab->sstubs;
      h->root.root.u.def.value = htab->sstubs->size + isa_bit;
      h->root.plt.plist->stub_offset = htab->sstubs->size;
      h->root.other = other;
      htab->sstubs->size += htab->function_stub_size;
    }
  return TRUE;
}

/* Allocate offsets in the stubs section to each symbol that needs one.
   Set the final size of the .MIPS.stub section.  */

static bfd_boolean
mips_elf_lay_out_lazy_stubs (struct bfd_link_info *info)
{
  bfd *output_bfd = info->output_bfd;
  bfd_boolean micromips_p = MICROMIPS_P (output_bfd);
  unsigned int other = micromips_p ? STO_MICROMIPS : 0;
  bfd_vma isa_bit = micromips_p;
  struct mips_elf_link_hash_table *htab;
  struct mips_htab_traverse_info hti;
  struct elf_link_hash_entry *h;
  bfd *dynobj;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  if (htab->lazy_stub_count == 0)
    return TRUE;

  htab->sstubs->size = 0;
  hti.info = info;
  hti.output_bfd = output_bfd;
  hti.error = FALSE;
  mips_elf_link_hash_traverse (htab, mips_elf_allocate_lazy_stub, &hti);
  if (hti.error)
    return FALSE;
  htab->sstubs->size += htab->function_stub_size;
  BFD_ASSERT (htab->sstubs->size
	      == htab->lazy_stub_count * htab->function_stub_size);

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
  h = _bfd_elf_define_linkage_sym (dynobj, info, htab->sstubs, "_MIPS_STUBS_");
  if (h == NULL)
    return FALSE;
  h->root.u.def.value = isa_bit;
  h->other = other;
  h->type = STT_FUNC;

  return TRUE;
}

/* A mips_elf_link_hash_traverse callback for which DATA points to a
   bfd_link_info.  If H uses the address of a PLT entry as the value
   of the symbol, then set the entry in the symbol table now.  Prefer
   a standard MIPS PLT entry.  */

static bfd_boolean
mips_elf_set_plt_sym_value (struct mips_elf_link_hash_entry *h, void *data)
{
  struct bfd_link_info *info = data;
  bfd_boolean micromips_p = MICROMIPS_P (info->output_bfd);
  struct mips_elf_link_hash_table *htab;
  unsigned int other;
  bfd_vma isa_bit;
  bfd_vma val;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  if (h->use_plt_entry)
    {
      BFD_ASSERT (h->root.plt.plist != NULL);
      BFD_ASSERT (h->root.plt.plist->mips_offset != MINUS_ONE
		  || h->root.plt.plist->comp_offset != MINUS_ONE);

      val = htab->plt_header_size;
      if (h->root.plt.plist->mips_offset != MINUS_ONE)
	{
	  isa_bit = 0;
	  val += h->root.plt.plist->mips_offset;
	  other = 0;
	}
      else
	{
	  isa_bit = 1;
	  val += htab->plt_mips_offset + h->root.plt.plist->comp_offset;
	  other = micromips_p ? STO_MICROMIPS : STO_MIPS16;
	}
      val += isa_bit;
      /* For VxWorks, point at the PLT load stub rather than the lazy
         resolution stub; this stub will become the canonical function
         address.  */
      if (htab->is_vxworks)
	val += 8;

      h->root.root.u.def.section = htab->splt;
      h->root.root.u.def.value = val;
      h->root.other = other;
    }

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

bfd_boolean
_bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,
				     struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s, *sreldyn;
  bfd_boolean reltext;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size
	    = strlen (ELF_DYNAMIC_INTERPRETER (output_bfd)) + 1;
	  s->contents
	    = (bfd_byte *) ELF_DYNAMIC_INTERPRETER (output_bfd);
	}

      /* Figure out the size of the PLT header if we know that we
         are using it.  For the sake of cache alignment always use
         a standard header whenever any standard entries are present
         even if microMIPS entries are present as well.  This also
         lets the microMIPS header rely on the value of $v0 only set
         by microMIPS entries, for a small size reduction.

         Set symbol table entry values for symbols that use the
         address of their PLT entry now that we can calculate it.

         Also create the _PROCEDURE_LINKAGE_TABLE_ symbol if we
         haven't already in _bfd_elf_create_dynamic_sections.  */
      if (htab->splt && htab->plt_mips_offset + htab->plt_comp_offset != 0)
	{
	  bfd_boolean micromips_p = (MICROMIPS_P (output_bfd)
				     && !htab->plt_mips_offset);
	  unsigned int other = micromips_p ? STO_MICROMIPS : 0;
	  bfd_vma isa_bit = micromips_p;
	  struct elf_link_hash_entry *h;
	  bfd_vma size;

	  BFD_ASSERT (htab->use_plts_and_copy_relocs);
	  BFD_ASSERT (htab->sgotplt->size == 0);
	  BFD_ASSERT (htab->splt->size == 0);

	  if (htab->is_vxworks && info->shared)
	    size = 4 * ARRAY_SIZE (mips_vxworks_shared_plt0_entry);
	  else if (htab->is_vxworks)
	    size = 4 * ARRAY_SIZE (mips_vxworks_exec_plt0_entry);
	  else if (ABI_64_P (output_bfd))
	    size = 4 * ARRAY_SIZE (mips_n64_exec_plt0_entry);
	  else if (ABI_N32_P (output_bfd))
	    size = 4 * ARRAY_SIZE (mips_n32_exec_plt0_entry);
	  else if (!micromips_p)
	    size = 4 * ARRAY_SIZE (mips_o32_exec_plt0_entry);
	  else if (htab->insn32)
	    size = 2 * ARRAY_SIZE (micromips_insn32_o32_exec_plt0_entry);
	  else
	    size = 2 * ARRAY_SIZE (micromips_o32_exec_plt0_entry);

	  htab->plt_header_is_comp = micromips_p;
	  htab->plt_header_size = size;
	  htab->splt->size = (size
			      + htab->plt_mips_offset
			      + htab->plt_comp_offset);
	  htab->sgotplt->size = (htab->plt_got_index
				 * MIPS_ELF_GOT_SIZE (dynobj));

	  mips_elf_link_hash_traverse (htab, mips_elf_set_plt_sym_value, info);

	  if (htab->root.hplt == NULL)
	    {
	      h = _bfd_elf_define_linkage_sym (dynobj, info, htab->splt,
					       "_PROCEDURE_LINKAGE_TABLE_");
	      htab->root.hplt = h;
	      if (h == NULL)
		return FALSE;
	    }

	  h = htab->root.hplt;
	  h->root.u.def.value = isa_bit;
	  h->other = other;
	  h->type = STT_FUNC;
	}
    }

  /* Allocate space for global sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);

  mips_elf_estimate_stub_size (output_bfd, info);

  if (!mips_elf_lay_out_got (output_bfd, info))
    return FALSE;

  mips_elf_lay_out_lazy_stubs (info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  reltext = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (CONST_STRNEQ (name, ".rel"))
	{
	  if (s->size != 0)
	    {
	      const char *outname;
	      asection *target;

	      /* If this relocation section applies to a read only
                 section, then we probably need a DT_TEXTREL entry.
                 If the relocation section is .rel(a).dyn, we always
                 assert a DT_TEXTREL entry rather than testing whether
                 there exists a relocation to a read only section or
                 not.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 4);
	      if ((target != NULL
		   && (target->flags & SEC_READONLY) != 0
		   && (target->flags & SEC_ALLOC) != 0)
		  || strcmp (outname, MIPS_ELF_REL_DYN_NAME (info)) == 0)
		reltext = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      if (strcmp (name, MIPS_ELF_REL_DYN_NAME (info)) != 0)
		s->reloc_count = 0;

	      /* If combreloc is enabled, elf_link_sort_relocs() will
		 sort relocations, but in a different way than we do,
		 and before we're done creating relocations.  Also, it
		 will move them around between input sections'
		 relocation's contents, so our sorting would be
		 broken, so don't let it run.  */
	      info->combreloc = 0;
	    }
	}
      else if (! info->shared
	       && ! mips_elf_hash_table (info)->use_rld_obj_head
	       && CONST_STRNEQ (name, ".rld_map"))
	{
	  /* We add a room for __rld_map.  It will be filled in by the
	     rtld to contain a pointer to the _r_debug structure.  */
	  s->size += MIPS_ELF_RLD_MAP_SIZE (output_bfd);
	}
      else if (SGI_COMPAT (output_bfd)
	       && CONST_STRNEQ (name, ".compact_rel"))
	s->size += mips_elf_hash_table (info)->compact_rel_size;
      else if (s == htab->splt)
	{
	  /* If the last PLT entry has a branch delay slot, allocate
	     room for an extra nop to fill the delay slot.  This is
	     for CPUs without load interlocking.  */
	  if (! LOAD_INTERLOCKS_P (output_bfd)
	      && ! htab->is_vxworks && s->size > 0)
	    s->size += 4;
	}
      else if (! CONST_STRNEQ (name, ".init")
	       && s != htab->sgot
	       && s != htab->sgotplt
	       && s != htab->sstubs
	       && s != htab->sdynbss)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  */
      s->contents = bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return FALSE;
	}
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in _bfd_mips_elf_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  */

      /* SGI object has the equivalence of DT_DEBUG in the
	 DT_MIPS_RLD_MAP entry.  This must come first because glibc
	 only fills in DT_MIPS_RLD_MAP (not DT_DEBUG) and some tools
	 may only look at the first one they see.  */
      if (!info->shared
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_MAP, 0))
	return FALSE;

      /* The DT_DEBUG entry may be filled in by the dynamic linker and
	 used by the debugger.  */
      if (info->executable
	  && !SGI_COMPAT (output_bfd)
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
	return FALSE;

      if (reltext && (SGI_COMPAT (output_bfd) || htab->is_vxworks))
	info->flags |= DF_TEXTREL;

      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_TEXTREL, 0))
	    return FALSE;

	  /* Clear the DF_TEXTREL flag.  It will be set again if we
	     write out an actual text relocation; we may not, because
	     at this point we do not know whether e.g. any .eh_frame
	     absolute relocations have been converted to PC-relative.  */
	  info->flags &= ~DF_TEXTREL;
	}

      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTGOT, 0))
	return FALSE;

      sreldyn = mips_elf_rel_dyn_section (info, FALSE);
      if (htab->is_vxworks)
	{
	  /* VxWorks uses .rela.dyn instead of .rel.dyn.  It does not
	     use any of the DT_MIPS_* tags.  */
	  if (sreldyn && sreldyn->size > 0)
	    {
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELA, 0))
		return FALSE;

	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELASZ, 0))
		return FALSE;

	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELAENT, 0))
		return FALSE;
	    }
	}
      else
	{
	  if (sreldyn && sreldyn->size > 0)
	    {
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_REL, 0))
		return FALSE;

	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELSZ, 0))
		return FALSE;

	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELENT, 0))
		return FALSE;
	    }

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_VERSION, 0))
	    return FALSE;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_FLAGS, 0))
	    return FALSE;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_BASE_ADDRESS, 0))
	    return FALSE;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LOCAL_GOTNO, 0))
	    return FALSE;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_SYMTABNO, 0))
	    return FALSE;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_UNREFEXTNO, 0))
	    return FALSE;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_GOTSYM, 0))
	    return FALSE;

	  if (IRIX_COMPAT (dynobj) == ict_irix5
	      && ! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_HIPAGENO, 0))
	    return FALSE;

	  if (IRIX_COMPAT (dynobj) == ict_irix6
	      && (bfd_get_section_by_name
		  (output_bfd, MIPS_ELF_OPTIONS_SECTION_NAME (dynobj)))
	      && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_OPTIONS, 0))
	    return FALSE;
	}
      if (htab->splt->size > 0)
	{
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTREL, 0))
	    return FALSE;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_JMPREL, 0))
	    return FALSE;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTRELSZ, 0))
	    return FALSE;

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_PLTGOT, 0))
	    return FALSE;
	}
      if (htab->is_vxworks
	  && !elf_vxworks_add_dynamic_entries (output_bfd, info))
	return FALSE;
    }

  return TRUE;
}

/* REL is a relocation in INPUT_BFD that is being copied to OUTPUT_BFD.
   Adjust its R_ADDEND field so that it is correct for the output file.
   LOCAL_SYMS and LOCAL_SECTIONS are arrays of INPUT_BFD's local symbols
   and sections respectively; both use symbol indexes.  */

static void
mips_elf_adjust_addend (bfd *output_bfd, struct bfd_link_info *info,
			bfd *input_bfd, Elf_Internal_Sym *local_syms,
			asection **local_sections, Elf_Internal_Rela *rel)
{
  unsigned int r_type, r_symndx;
  Elf_Internal_Sym *sym;
  asection *sec;

  if (mips_elf_local_relocation_p (input_bfd, rel, local_sections))
    {
      r_type = ELF_R_TYPE (output_bfd, rel->r_info);
      if (gprel16_reloc_p (r_type)
	  || r_type == R_MIPS_GPREL32
	  || literal_reloc_p (r_type))
	{
	  rel->r_addend += _bfd_get_gp_value (input_bfd);
	  rel->r_addend -= _bfd_get_gp_value (output_bfd);
	}

      r_symndx = ELF_R_SYM (output_bfd, rel->r_info);
      sym = local_syms + r_symndx;

      /* Adjust REL's addend to account for section merging.  */
      if (!info->relocatable)
	{
	  sec = local_sections[r_symndx];
	  _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}

      /* This would normally be done by the rela_normal code in elflink.c.  */
      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	rel->r_addend += local_sections[r_symndx]->output_offset;
    }
}

/* Handle relocations against symbols from removed linkonce sections,
   or sections discarded by a linker script.  We use this wrapper around
   RELOC_AGAINST_DISCARDED_SECTION to handle triplets of compound relocs
   on 64-bit ELF targets.  In this case for any relocation handled, which
   always be the first in a triplet, the remaining two have to be processed
   together with the first, even if they are R_MIPS_NONE.  It is the symbol
   index referred by the first reloc that applies to all the three and the
   remaining two never refer to an object symbol.  And it is the final
   relocation (the last non-null one) that determines the output field of
   the whole relocation so retrieve the corresponding howto structure for
   the relocatable field to be cleared by RELOC_AGAINST_DISCARDED_SECTION.

   Note that RELOC_AGAINST_DISCARDED_SECTION is a macro that uses "continue"
   and therefore requires to be pasted in a loop.  It also defines a block
   and does not protect any of its arguments, hence the extra brackets.  */

static void
mips_reloc_against_discarded_section (bfd *output_bfd,
				      struct bfd_link_info *info,
				      bfd *input_bfd, asection *input_section,
				      Elf_Internal_Rela **rel,
				      const Elf_Internal_Rela **relend,
				      bfd_boolean rel_reloc,
				      reloc_howto_type *howto,
				      bfd_byte *contents)
{
  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
  int count = bed->s->int_rels_per_ext_rel;
  unsigned int r_type;
  int i;

  for (i = count - 1; i > 0; i--)
    {
      r_type = ELF_R_TYPE (output_bfd, (*rel)[i].r_info);
      if (r_type != R_MIPS_NONE)
	{
	  howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, r_type, !rel_reloc);
	  break;
	}
    }
  do
    {
       RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					(*rel), count, (*relend),
					howto, i, contents);
    }
  while (0);
}

/* Relocate a MIPS ELF section.  */

bfd_boolean
_bfd_mips_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
				bfd *input_bfd, asection *input_section,
				bfd_byte *contents, Elf_Internal_Rela *relocs,
				Elf_Internal_Sym *local_syms,
				asection **local_sections)
{
  Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *relend;
  bfd_vma addend = 0;
  bfd_boolean use_saved_addend_p = FALSE;
  const struct elf_backend_data *bed;

  bed = get_elf_backend_data (output_bfd);
  relend = relocs + input_section->reloc_count * bed->s->int_rels_per_ext_rel;
  for (rel = relocs; rel < relend; ++rel)
    {
      const char *name;
      bfd_vma value = 0;
      reloc_howto_type *howto;
      bfd_boolean cross_mode_jump_p = FALSE;
      /* TRUE if the relocation is a RELA relocation, rather than a
         REL relocation.  */
      bfd_boolean rela_relocation_p = TRUE;
      unsigned int r_type = ELF_R_TYPE (output_bfd, rel->r_info);
      const char *msg;
      unsigned long r_symndx;
      asection *sec;
      Elf_Internal_Shdr *symtab_hdr;
      struct elf_link_hash_entry *h;
      bfd_boolean rel_reloc;

      rel_reloc = (NEWABI_P (input_bfd)
		   && mips_elf_rel_relocation_p (input_bfd, input_section,
						 relocs, rel));
      /* Find the relocation howto for this relocation.  */
      howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, r_type, !rel_reloc);

      r_symndx = ELF_R_SYM (input_bfd, rel->r_info);
      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      if (mips_elf_local_relocation_p (input_bfd, rel, local_sections))
	{
	  sec = local_sections[r_symndx];
	  h = NULL;
	}
      else
	{
	  unsigned long extsymoff;

	  extsymoff = 0;
	  if (!elf_bad_symtab (input_bfd))
	    extsymoff = symtab_hdr->sh_info;
	  h = elf_sym_hashes (input_bfd) [r_symndx - extsymoff];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  sec = NULL;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    sec = h->root.u.def.section;
	}

      if (sec != NULL && discarded_section (sec))
	{
	  mips_reloc_against_discarded_section (output_bfd, info, input_bfd,
						input_section, &rel, &relend,
						rel_reloc, howto, contents);
	  continue;
	}

      if (r_type == R_MIPS_64 && ! NEWABI_P (input_bfd))
	{
	  /* Some 32-bit code uses R_MIPS_64.  In particular, people use
	     64-bit code, but make sure all their addresses are in the
	     lowermost or uppermost 32-bit section of the 64-bit address
	     space.  Thus, when they use an R_MIPS_64 they mean what is
	     usually meant by R_MIPS_32, with the exception that the
	     stored value is sign-extended to 64 bits.  */
	  howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, R_MIPS_32, FALSE);

	  /* On big-endian systems, we need to lie about the position
	     of the reloc.  */
	  if (bfd_big_endian (input_bfd))
	    rel->r_offset += 4;
	}

      if (!use_saved_addend_p)
	{
	  /* If these relocations were originally of the REL variety,
	     we must pull the addend out of the field that will be
	     relocated.  Otherwise, we simply use the contents of the
	     RELA relocation.  */
	  if (mips_elf_rel_relocation_p (input_bfd, input_section,
					 relocs, rel))
	    {
	      rela_relocation_p = FALSE;
	      addend = mips_elf_read_rel_addend (input_bfd, rel,
						 howto, contents);
	      if (hi16_reloc_p (r_type)
		  || (got16_reloc_p (r_type)
		      && mips_elf_local_relocation_p (input_bfd, rel,
						      local_sections)))
		{
		  if (!mips_elf_add_lo16_rel_addend (input_bfd, rel, relend,
						     contents, &addend))
		    {
		      if (h)
			name = h->root.root.string;
		      else
			name = bfd_elf_sym_name (input_bfd, symtab_hdr,
						 local_syms + r_symndx,
						 sec);
		      (*_bfd_error_handler)
			(_("%B: Can't find matching LO16 reloc against `%s' for %s at 0x%lx in section `%A'"),
			 input_bfd, input_section, name, howto->name,
			 rel->r_offset);
		    }
		}
	      else
		addend <<= howto->rightshift;
	    }
	  else
	    addend = rel->r_addend;
	  mips_elf_adjust_addend (output_bfd, info, input_bfd,
				  local_syms, local_sections, rel);
	}

      if (info->relocatable)
	{
	  if (r_type == R_MIPS_64 && ! NEWABI_P (output_bfd)
	      && bfd_big_endian (input_bfd))
	    rel->r_offset -= 4;

	  if (!rela_relocation_p && rel->r_addend)
	    {
	      addend += rel->r_addend;
	      if (hi16_reloc_p (r_type) || got16_reloc_p (r_type))
		addend = mips_elf_high (addend);
	      else if (r_type == R_MIPS_HIGHER)
		addend = mips_elf_higher (addend);
	      else if (r_type == R_MIPS_HIGHEST)
		addend = mips_elf_highest (addend);
	      else
		addend >>= howto->rightshift;

	      /* We use the source mask, rather than the destination
		 mask because the place to which we are writing will be
		 source of the addend in the final link.  */
	      addend &= howto->src_mask;

	      if (r_type == R_MIPS_64 && ! NEWABI_P (output_bfd))
		/* See the comment above about using R_MIPS_64 in the 32-bit
		   ABI.  Here, we need to update the addend.  It would be
		   possible to get away with just using the R_MIPS_32 reloc
		   but for endianness.  */
		{
		  bfd_vma sign_bits;
		  bfd_vma low_bits;
		  bfd_vma high_bits;

		  if (addend & ((bfd_vma) 1 << 31))
#ifdef BFD64
		    sign_bits = ((bfd_vma) 1 << 32) - 1;
#else
		    sign_bits = -1;
#endif
		  else
		    sign_bits = 0;

		  /* If we don't know that we have a 64-bit type,
		     do two separate stores.  */
		  if (bfd_big_endian (input_bfd))
		    {
		      /* Store the sign-bits (which are most significant)
			 first.  */
		      low_bits = sign_bits;
		      high_bits = addend;
		    }
		  else
		    {
		      low_bits = addend;
		      high_bits = sign_bits;
		    }
		  bfd_put_32 (input_bfd, low_bits,
			      contents + rel->r_offset);
		  bfd_put_32 (input_bfd, high_bits,
			      contents + rel->r_offset + 4);
		  continue;
		}

	      if (! mips_elf_perform_relocation (info, howto, rel, addend,
						 input_bfd, input_section,
						 contents, FALSE))
		return FALSE;
	    }

	  /* Go on to the next relocation.  */
	  continue;
	}

      /* In the N32 and 64-bit ABIs there may be multiple consecutive
	 relocations for the same offset.  In that case we are
	 supposed to treat the output of each relocation as the addend
	 for the next.  */
      if (rel + 1 < relend
	  && rel->r_offset == rel[1].r_offset
	  && ELF_R_TYPE (input_bfd, rel[1].r_info) != R_MIPS_NONE)
	use_saved_addend_p = TRUE;
      else
	use_saved_addend_p = FALSE;

      /* Figure out what value we are supposed to relocate.  */
      switch (mips_elf_calculate_relocation (output_bfd, input_bfd,
					     input_section, info, rel,
					     addend, howto, local_syms,
					     local_sections, &value,
					     &name, &cross_mode_jump_p,
					     use_saved_addend_p))
	{
	case bfd_reloc_continue:
	  /* There's nothing to do.  */
	  continue;

	case bfd_reloc_undefined:
	  /* mips_elf_calculate_relocation already called the
	     undefined_symbol callback.  There's no real point in
	     trying to perform the relocation at this point, so we
	     just skip ahead to the next relocation.  */
	  continue;

	case bfd_reloc_notsupported:
	  msg = _("internal error: unsupported relocation error");
	  info->callbacks->warning
	    (info, msg, name, input_bfd, input_section, rel->r_offset);
	  return FALSE;

	case bfd_reloc_overflow:
	  if (use_saved_addend_p)
	    /* Ignore overflow until we reach the last relocation for
	       a given location.  */
	    ;
	  else
	    {
	      struct mips_elf_link_hash_table *htab;

	      htab = mips_elf_hash_table (info);
	      BFD_ASSERT (htab != NULL);
	      BFD_ASSERT (name != NULL);
	      if (!htab->small_data_overflow_reported
		  && (gprel16_reloc_p (howto->type)
		      || literal_reloc_p (howto->type)))
		{
		  msg = _("small-data section exceeds 64KB;"
			  " lower small-data size limit (see option -G)");

		  htab->small_data_overflow_reported = TRUE;
		  (*info->callbacks->einfo) ("%P: %s\n", msg);
		}
	      if (! ((*info->callbacks->reloc_overflow)
		     (info, NULL, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
		return FALSE;
	    }
	  break;

	case bfd_reloc_ok:
	  break;

	case bfd_reloc_outofrange:
	  if (jal_reloc_p (howto->type))
	    {
	      msg = _("JALX to a non-word-aligned address");
	      info->callbacks->warning
		(info, msg, name, input_bfd, input_section, rel->r_offset);
	      return FALSE;
	    }
	  /* Fall through.  */

	default:
	  abort ();
	  break;
	}

      /* If we've got another relocation for the address, keep going
	 until we reach the last one.  */
      if (use_saved_addend_p)
	{
	  addend = value;
	  continue;
	}

      if (r_type == R_MIPS_64 && ! NEWABI_P (output_bfd))
	/* See the comment above about using R_MIPS_64 in the 32-bit
	   ABI.  Until now, we've been using the HOWTO for R_MIPS_32;
	   that calculated the right value.  Now, however, we
	   sign-extend the 32-bit result to 64-bits, and store it as a
	   64-bit value.  We are especially generous here in that we
	   go to extreme lengths to support this usage on systems with
	   only a 32-bit VMA.  */
	{
	  bfd_vma sign_bits;
	  bfd_vma low_bits;
	  bfd_vma high_bits;

	  if (value & ((bfd_vma) 1 << 31))
#ifdef BFD64
	    sign_bits = ((bfd_vma) 1 << 32) - 1;
#else
	    sign_bits = -1;
#endif
	  else
	    sign_bits = 0;

	  /* If we don't know that we have a 64-bit type,
	     do two separate stores.  */
	  if (bfd_big_endian (input_bfd))
	    {
	      /* Undo what we did above.  */
	      rel->r_offset -= 4;
	      /* Store the sign-bits (which are most significant)
		 first.  */
	      low_bits = sign_bits;
	      high_bits = value;
	    }
	  else
	    {
	      low_bits = value;
	      high_bits = sign_bits;
	    }
	  bfd_put_32 (input_bfd, low_bits,
		      contents + rel->r_offset);
	  bfd_put_32 (input_bfd, high_bits,
		      contents + rel->r_offset + 4);
	  continue;
	}

      /* Actually perform the relocation.  */
      if (! mips_elf_perform_relocation (info, howto, rel, value,
					 input_bfd, input_section,
					 contents, cross_mode_jump_p))
	return FALSE;
    }

  return TRUE;
}

/* A function that iterates over each entry in la25_stubs and fills
   in the code for each one.  DATA points to a mips_htab_traverse_info.  */

static int
mips_elf_create_la25_stub (void **slot, void *data)
{
  struct mips_htab_traverse_info *hti;
  struct mips_elf_link_hash_table *htab;
  struct mips_elf_la25_stub *stub;
  asection *s;
  bfd_byte *loc;
  bfd_vma offset, target, target_high, target_low;

  stub = (struct mips_elf_la25_stub *) *slot;
  hti = (struct mips_htab_traverse_info *) data;
  htab = mips_elf_hash_table (hti->info);
  BFD_ASSERT (htab != NULL);

  /* Create the section contents, if we haven't already.  */
  s = stub->stub_section;
  loc = s->contents;
  if (loc == NULL)
    {
      loc = bfd_malloc (s->size);
      if (loc == NULL)
	{
	  hti->error = TRUE;
	  return FALSE;
	}
      s->contents = loc;
    }

  /* Work out where in the section this stub should go.  */
  offset = stub->offset;

  /* Work out the target address.  */
  target = mips_elf_get_la25_target (stub, &s);
  target += s->output_section->vma + s->output_offset;

  target_high = ((target + 0x8000) >> 16) & 0xffff;
  target_low = (target & 0xffff);

  if (stub->stub_section != htab->strampoline)
    {
      /* This is a simple LUI/ADDIU stub.  Zero out the beginning
	 of the section and write the two instructions at the end.  */
      memset (loc, 0, offset);
      loc += offset;
      if (ELF_ST_IS_MICROMIPS (stub->h->root.other))
	{
	  bfd_put_micromips_32 (hti->output_bfd,
				LA25_LUI_MICROMIPS (target_high),
				loc);
	  bfd_put_micromips_32 (hti->output_bfd,
				LA25_ADDIU_MICROMIPS (target_low),
				loc + 4);
	}
      else
	{
	  bfd_put_32 (hti->output_bfd, LA25_LUI (target_high), loc);
	  bfd_put_32 (hti->output_bfd, LA25_ADDIU (target_low), loc + 4);
	}
    }
  else
    {
      /* This is trampoline.  */
      loc += offset;
      if (ELF_ST_IS_MICROMIPS (stub->h->root.other))
	{
	  bfd_put_micromips_32 (hti->output_bfd,
				LA25_LUI_MICROMIPS (target_high), loc);
	  bfd_put_micromips_32 (hti->output_bfd,
				LA25_J_MICROMIPS (target), loc + 4);
	  bfd_put_micromips_32 (hti->output_bfd,
				LA25_ADDIU_MICROMIPS (target_low), loc + 8);
	  bfd_put_32 (hti->output_bfd, 0, loc + 12);
	}
      else
	{
	  bfd_put_32 (hti->output_bfd, LA25_LUI (target_high), loc);
	  bfd_put_32 (hti->output_bfd, LA25_J (target), loc + 4);
	  bfd_put_32 (hti->output_bfd, LA25_ADDIU (target_low), loc + 8);
	  bfd_put_32 (hti->output_bfd, 0, loc + 12);
	}
    }
  return TRUE;
}

/* If NAME is one of the special IRIX6 symbols defined by the linker,
   adjust it appropriately now.  */

static void
mips_elf_irix6_finish_dynamic_symbol (bfd *abfd ATTRIBUTE_UNUSED,
				      const char *name, Elf_Internal_Sym *sym)
{
  /* The linker script takes care of providing names and values for
     these, but we must place them into the right sections.  */
  static const char* const text_section_symbols[] = {
    "_ftext",
    "_etext",
    "__dso_displacement",
    "__elf_header",
    "__program_header_table",
    NULL
  };

  static const char* const data_section_symbols[] = {
    "_fdata",
    "_edata",
    "_end",
    "_fbss",
    NULL
  };

  const char* const *p;
  int i;

  for (i = 0; i < 2; ++i)
    for (p = (i == 0) ? text_section_symbols : data_section_symbols;
	 *p;
	 ++p)
      if (strcmp (*p, name) == 0)
	{
	  /* All of these symbols are given type STT_SECTION by the
	     IRIX6 linker.  */
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_other = STO_PROTECTED;

	  /* The IRIX linker puts these symbols in special sections.  */
	  if (i == 0)
	    sym->st_shndx = SHN_MIPS_TEXT;
	  else
	    sym->st_shndx = SHN_MIPS_DATA;

	  break;
	}
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

bfd_boolean
_bfd_mips_elf_finish_dynamic_symbol (bfd *output_bfd,
				     struct bfd_link_info *info,
				     struct elf_link_hash_entry *h,
				     Elf_Internal_Sym *sym)
{
  bfd *dynobj;
  asection *sgot;
  struct mips_got_info *g, *gg;
  const char *name;
  int idx;
  struct mips_elf_link_hash_table *htab;
  struct mips_elf_link_hash_entry *hmips;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);
  dynobj = elf_hash_table (info)->dynobj;
  hmips = (struct mips_elf_link_hash_entry *) h;

  BFD_ASSERT (!htab->is_vxworks);

  if (h->plt.plist != NULL
      && (h->plt.plist->mips_offset != MINUS_ONE
	  || h->plt.plist->comp_offset != MINUS_ONE))
    {
      /* We've decided to create a PLT entry for this symbol.  */
      bfd_byte *loc;
      bfd_vma header_address, got_address;
      bfd_vma got_address_high, got_address_low, load;
      bfd_vma got_index;
      bfd_vma isa_bit;

      got_index = h->plt.plist->gotplt_index;

      BFD_ASSERT (htab->use_plts_and_copy_relocs);
      BFD_ASSERT (h->dynindx != -1);
      BFD_ASSERT (htab->splt != NULL);
      BFD_ASSERT (got_index != MINUS_ONE);
      BFD_ASSERT (!h->def_regular);

      /* Calculate the address of the PLT header.  */
      isa_bit = htab->plt_header_is_comp;
      header_address = (htab->splt->output_section->vma
			+ htab->splt->output_offset + isa_bit);

      /* Calculate the address of the .got.plt entry.  */
      got_address = (htab->sgotplt->output_section->vma
		     + htab->sgotplt->output_offset
		     + got_index * MIPS_ELF_GOT_SIZE (dynobj));

      got_address_high = ((got_address + 0x8000) >> 16) & 0xffff;
      got_address_low = got_address & 0xffff;

      /* Initially point the .got.plt entry at the PLT header.  */
      loc = (htab->sgotplt->contents + got_index * MIPS_ELF_GOT_SIZE (dynobj));
      if (ABI_64_P (output_bfd))
	bfd_put_64 (output_bfd, header_address, loc);
      else
	bfd_put_32 (output_bfd, header_address, loc);

      /* Now handle the PLT itself.  First the standard entry (the order
         does not matter, we just have to pick one).  */
      if (h->plt.plist->mips_offset != MINUS_ONE)
	{
	  const bfd_vma *plt_entry;
	  bfd_vma plt_offset;

	  plt_offset = htab->plt_header_size + h->plt.plist->mips_offset;

	  BFD_ASSERT (plt_offset <= htab->splt->size);

	  /* Find out where the .plt entry should go.  */
	  loc = htab->splt->contents + plt_offset;

	  /* Pick the load opcode.  */
	  load = MIPS_ELF_LOAD_WORD (output_bfd);

	  /* Fill in the PLT entry itself.  */
	  plt_entry = mips_exec_plt_entry;
	  bfd_put_32 (output_bfd, plt_entry[0] | got_address_high, loc);
	  bfd_put_32 (output_bfd, plt_entry[1] | got_address_low | load,
		      loc + 4);

	  if (! LOAD_INTERLOCKS_P (output_bfd))
	    {
	      bfd_put_32 (output_bfd, plt_entry[2] | got_address_low, loc + 8);
	      bfd_put_32 (output_bfd, plt_entry[3], loc + 12);
	    }
	  else
	    {
	      bfd_put_32 (output_bfd, plt_entry[3], loc + 8);
	      bfd_put_32 (output_bfd, plt_entry[2] | got_address_low,
			  loc + 12);
	    }
	}

      /* Now the compressed entry.  They come after any standard ones.  */
      if (h->plt.plist->comp_offset != MINUS_ONE)
	{
	  bfd_vma plt_offset;

	  plt_offset = (htab->plt_header_size + htab->plt_mips_offset
			+ h->plt.plist->comp_offset);

	  BFD_ASSERT (plt_offset <= htab->splt->size);

	  /* Find out where the .plt entry should go.  */
	  loc = htab->splt->contents + plt_offset;

	  /* Fill in the PLT entry itself.  */
	  if (!MICROMIPS_P (output_bfd))
	    {
	      const bfd_vma *plt_entry = mips16_o32_exec_plt_entry;

	      bfd_put_16 (output_bfd, plt_entry[0], loc);
	      bfd_put_16 (output_bfd, plt_entry[1], loc + 2);
	      bfd_put_16 (output_bfd, plt_entry[2], loc + 4);
	      bfd_put_16 (output_bfd, plt_entry[3], loc + 6);
	      bfd_put_16 (output_bfd, plt_entry[4], loc + 8);
	      bfd_put_16 (output_bfd, plt_entry[5], loc + 10);
	      bfd_put_32 (output_bfd, got_address, loc + 12);
	    }
	  else if (htab->insn32)
	    {
	      const bfd_vma *plt_entry = micromips_insn32_o32_exec_plt_entry;

	      bfd_put_16 (output_bfd, plt_entry[0], loc);
	      bfd_put_16 (output_bfd, got_address_high, loc + 2);
	      bfd_put_16 (output_bfd, plt_entry[2], loc + 4);
	      bfd_put_16 (output_bfd, got_address_low, loc + 6);
	      bfd_put_16 (output_bfd, plt_entry[4], loc + 8);
	      bfd_put_16 (output_bfd, plt_entry[5], loc + 10);
	      bfd_put_16 (output_bfd, plt_entry[6], loc + 12);
	      bfd_put_16 (output_bfd, got_address_low, loc + 14);
	    }
	  else
	    {
	      const bfd_vma *plt_entry = micromips_o32_exec_plt_entry;
	      bfd_signed_vma gotpc_offset;
	      bfd_vma loc_address;

	      BFD_ASSERT (got_address % 4 == 0);

	      loc_address = (htab->splt->output_section->vma
			     + htab->splt->output_offset + plt_offset);
	      gotpc_offset = got_address - ((loc_address | 3) ^ 3);

	      /* ADDIUPC has a span of +/-16MB, check we're in range.  */
	      if (gotpc_offset + 0x1000000 >= 0x2000000)
		{
		  (*_bfd_error_handler)
		    (_("%B: `%A' offset of %ld from `%A' "
		       "beyond the range of ADDIUPC"),
		     output_bfd,
		     htab->sgotplt->output_section,
		     htab->splt->output_section,
		     (long) gotpc_offset);
		  bfd_set_error (bfd_error_no_error);
		  return FALSE;
		}
	      bfd_put_16 (output_bfd,
			  plt_entry[0] | ((gotpc_offset >> 18) & 0x7f), loc);
	      bfd_put_16 (output_bfd, (gotpc_offset >> 2) & 0xffff, loc + 2);
	      bfd_put_16 (output_bfd, plt_entry[2], loc + 4);
	      bfd_put_16 (output_bfd, plt_entry[3], loc + 6);
	      bfd_put_16 (output_bfd, plt_entry[4], loc + 8);
	      bfd_put_16 (output_bfd, plt_entry[5], loc + 10);
	    }
	}

      /* Emit an R_MIPS_JUMP_SLOT relocation against the .got.plt entry.  */
      mips_elf_output_dynamic_relocation (output_bfd, htab->srelplt,
					  got_index - 2, h->dynindx,
					  R_MIPS_JUMP_SLOT, got_address);

      /* We distinguish between PLT entries and lazy-binding stubs by
	 giving the former an st_other value of STO_MIPS_PLT.  Set the
	 flag and leave the value if there are any relocations in the
	 binary where pointer equality matters.  */
      sym->st_shndx = SHN_UNDEF;
      if (h->pointer_equality_needed)
	sym->st_other = ELF_ST_SET_MIPS_PLT (sym->st_other);
      else
	{
	  sym->st_value = 0;
	  sym->st_other = 0;
	}
    }

  if (h->plt.plist != NULL && h->plt.plist->stub_offset != MINUS_ONE)
    {
      /* We've decided to create a lazy-binding stub.  */
      bfd_boolean micromips_p = MICROMIPS_P (output_bfd);
      unsigned int other = micromips_p ? STO_MICROMIPS : 0;
      bfd_vma stub_size = htab->function_stub_size;
      bfd_byte stub[MIPS_FUNCTION_STUB_BIG_SIZE];
      bfd_vma isa_bit = micromips_p;
      bfd_vma stub_big_size;

      if (!micromips_p)
	stub_big_size = MIPS_FUNCTION_STUB_BIG_SIZE;
      else if (htab->insn32)
	stub_big_size = MICROMIPS_INSN32_FUNCTION_STUB_BIG_SIZE;
      else
	stub_big_size = MICROMIPS_FUNCTION_STUB_BIG_SIZE;

      /* This symbol has a stub.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1);

      BFD_ASSERT (stub_size == stub_big_size || h->dynindx <= 0xffff);

      /* Values up to 2^31 - 1 are allowed.  Larger values would cause
	 sign extension at runtime in the stub, resulting in a negative
	 index value.  */
      if (h->dynindx & ~0x7fffffff)
	return FALSE;

      /* Fill the stub.  */
      if (micromips_p)
	{
	  idx = 0;
	  bfd_put_micromips_32 (output_bfd, STUB_LW_MICROMIPS (output_bfd),
				stub + idx);
	  idx += 4;
	  if (htab->insn32)
	    {
	      bfd_put_micromips_32 (output_bfd,
				    STUB_MOVE32_MICROMIPS (output_bfd),
				    stub + idx);
	      idx += 4;
	    }
	  else
	    {
	      bfd_put_16 (output_bfd, STUB_MOVE_MICROMIPS, stub + idx);
	      idx += 2;
	    }
	  if (stub_size == stub_big_size)
	    {
	      long dynindx_hi = (h->dynindx >> 16) & 0x7fff;

	      bfd_put_micromips_32 (output_bfd,
				    STUB_LUI_MICROMIPS (dynindx_hi),
				    stub + idx);
	      idx += 4;
	    }
	  if (htab->insn32)
	    {
	      bfd_put_micromips_32 (output_bfd, STUB_JALR32_MICROMIPS,
				    stub + idx);
	      idx += 4;
	    }
	  else
	    {
	      bfd_put_16 (output_bfd, STUB_JALR_MICROMIPS, stub + idx);
	      idx += 2;
	    }

	  /* If a large stub is not required and sign extension is not a
	     problem, then use legacy code in the stub.  */
	  if (stub_size == stub_big_size)
	    bfd_put_micromips_32 (output_bfd,
				  STUB_ORI_MICROMIPS (h->dynindx & 0xffff),
				  stub + idx);
	  else if (h->dynindx & ~0x7fff)
	    bfd_put_micromips_32 (output_bfd,
				  STUB_LI16U_MICROMIPS (h->dynindx & 0xffff),
				  stub + idx);
	  else
	    bfd_put_micromips_32 (output_bfd,
				  STUB_LI16S_MICROMIPS (output_bfd,
							h->dynindx),
				  stub + idx);
	}
      else
	{
	  idx = 0;
	  bfd_put_32 (output_bfd, STUB_LW (output_bfd), stub + idx);
	  idx += 4;
	  bfd_put_32 (output_bfd, STUB_MOVE (output_bfd), stub + idx);
	  idx += 4;
	  if (stub_size == stub_big_size)
	    {
	      bfd_put_32 (output_bfd, STUB_LUI ((h->dynindx >> 16) & 0x7fff),
			  stub + idx);
	      idx += 4;
	    }
	  bfd_put_32 (output_bfd, STUB_JALR, stub + idx);
	  idx += 4;

	  /* If a large stub is not required and sign extension is not a
	     problem, then use legacy code in the stub.  */
	  if (stub_size == stub_big_size)
	    bfd_put_32 (output_bfd, STUB_ORI (h->dynindx & 0xffff),
			stub + idx);
	  else if (h->dynindx & ~0x7fff)
	    bfd_put_32 (output_bfd, STUB_LI16U (h->dynindx & 0xffff),
			stub + idx);
	  else
	    bfd_put_32 (output_bfd, STUB_LI16S (output_bfd, h->dynindx),
			stub + idx);
	}

      BFD_ASSERT (h->plt.plist->stub_offset <= htab->sstubs->size);
      memcpy (htab->sstubs->contents + h->plt.plist->stub_offset,
	      stub, stub_size);

      /* Mark the symbol as undefined.  stub_offset != -1 occurs
	 only for the referenced symbol.  */
      sym->st_shndx = SHN_UNDEF;

      /* The run-time linker uses the st_value field of the symbol
	 to reset the global offset table entry for this external
	 to its stub address when unlinking a shared object.  */
      sym->st_value = (htab->sstubs->output_section->vma
		       + htab->sstubs->output_offset
		       + h->plt.plist->stub_offset
		       + isa_bit);
      sym->st_other = other;
    }

  /* If we have a MIPS16 function with a stub, the dynamic symbol must
     refer to the stub, since only the stub uses the standard calling
     conventions.  */
  if (h->dynindx != -1 && hmips->fn_stub != NULL)
    {
      BFD_ASSERT (hmips->need_fn_stub);
      sym->st_value = (hmips->fn_stub->output_section->vma
		       + hmips->fn_stub->output_offset);
      sym->st_size = hmips->fn_stub->size;
      sym->st_other = ELF_ST_VISIBILITY (sym->st_other);
    }

  BFD_ASSERT (h->dynindx != -1
	      || h->forced_local);

  sgot = htab->sgot;
  g = htab->got_info;
  BFD_ASSERT (g != NULL);

  /* Run through the global symbol table, creating GOT entries for all
     the symbols that need them.  */
  if (hmips->global_got_area != GGA_NONE)
    {
      bfd_vma offset;
      bfd_vma value;

      value = sym->st_value;
      offset = mips_elf_primary_global_got_index (output_bfd, info, h);
      MIPS_ELF_PUT_WORD (output_bfd, value, sgot->contents + offset);
    }

  if (hmips->global_got_area != GGA_NONE && g->next)
    {
      struct mips_got_entry e, *p;
      bfd_vma entry;
      bfd_vma offset;

      gg = g;

      e.abfd = output_bfd;
      e.symndx = -1;
      e.d.h = hmips;
      e.tls_type = GOT_TLS_NONE;

      for (g = g->next; g->next != gg; g = g->next)
	{
	  if (g->got_entries
	      && (p = (struct mips_got_entry *) htab_find (g->got_entries,
							   &e)))
	    {
	      offset = p->gotidx;
	      BFD_ASSERT (offset > 0 && offset < htab->sgot->size);
	      if (info->shared
		  || (elf_hash_table (info)->dynamic_sections_created
		      && p->d.h != NULL
		      && p->d.h->root.def_dynamic
		      && !p->d.h->root.def_regular))
		{
		  /* Create an R_MIPS_REL32 relocation for this entry.  Due to
		     the various compatibility problems, it's easier to mock
		     up an R_MIPS_32 or R_MIPS_64 relocation and leave
		     mips_elf_create_dynamic_relocation to calculate the
		     appropriate addend.  */
		  Elf_Internal_Rela rel[3];

		  memset (rel, 0, sizeof (rel));
		  if (ABI_64_P (output_bfd))
		    rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_64);
		  else
		    rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_32);
		  rel[0].r_offset = rel[1].r_offset = rel[2].r_offset = offset;

		  entry = 0;
		  if (! (mips_elf_create_dynamic_relocation
			 (output_bfd, info, rel,
			  e.d.h, NULL, sym->st_value, &entry, sgot)))
		    return FALSE;
		}
	      else
		entry = sym->st_value;
	      MIPS_ELF_PUT_WORD (output_bfd, entry, sgot->contents + offset);
	    }
	}
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  name = h->root.root.string;
  if (h == elf_hash_table (info)->hdynamic
      || h == elf_hash_table (info)->hgot)
    sym->st_shndx = SHN_ABS;
  else if (strcmp (name, "_DYNAMIC_LINK") == 0
	   || strcmp (name, "_DYNAMIC_LINKING") == 0)
    {
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = 1;
    }
  else if (strcmp (name, "_gp_disp") == 0 && ! NEWABI_P (output_bfd))
    {
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = elf_gp (output_bfd);
    }
  else if (SGI_COMPAT (output_bfd))
    {
      if (strcmp (name, mips_elf_dynsym_rtproc_names[0]) == 0
	  || strcmp (name, mips_elf_dynsym_rtproc_names[1]) == 0)
	{
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_other = STO_PROTECTED;
	  sym->st_value = 0;
	  sym->st_shndx = SHN_MIPS_DATA;
	}
      else if (strcmp (name, mips_elf_dynsym_rtproc_names[2]) == 0)
	{
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  sym->st_other = STO_PROTECTED;
	  sym->st_value = mips_elf_hash_table (info)->procedure_count;
	  sym->st_shndx = SHN_ABS;
	}
      else if (sym->st_shndx != SHN_UNDEF && sym->st_shndx != SHN_ABS)
	{
	  if (h->type == STT_FUNC)
	    sym->st_shndx = SHN_MIPS_TEXT;
	  else if (h->type == STT_OBJECT)
	    sym->st_shndx = SHN_MIPS_DATA;
	}
    }

  /* Emit a copy reloc, if needed.  */
  if (h->needs_copy)
    {
      asection *s;
      bfd_vma symval;

      BFD_ASSERT (h->dynindx != -1);
      BFD_ASSERT (htab->use_plts_and_copy_relocs);

      s = mips_elf_rel_dyn_section (info, FALSE);
      symval = (h->root.u.def.section->output_section->vma
		+ h->root.u.def.section->output_offset
		+ h->root.u.def.value);
      mips_elf_output_dynamic_relocation (output_bfd, s, s->reloc_count++,
					  h->dynindx, R_MIPS_COPY, symval);
    }

  /* Handle the IRIX6-specific symbols.  */
  if (IRIX_COMPAT (output_bfd) == ict_irix6)
    mips_elf_irix6_finish_dynamic_symbol (output_bfd, name, sym);

  /* Keep dynamic compressed symbols odd.  This allows the dynamic linker
     to treat compressed symbols like any other.  */
  if (ELF_ST_IS_MIPS16 (sym->st_other))
    {
      BFD_ASSERT (sym->st_value & 1);
      sym->st_other -= STO_MIPS16;
    }
  else if (ELF_ST_IS_MICROMIPS (sym->st_other))
    {
      BFD_ASSERT (sym->st_value & 1);
      sym->st_other -= STO_MICROMIPS;
    }

  return TRUE;
}

/* Likewise, for VxWorks.  */

bfd_boolean
_bfd_mips_vxworks_finish_dynamic_symbol (bfd *output_bfd,
					 struct bfd_link_info *info,
					 struct elf_link_hash_entry *h,
					 Elf_Internal_Sym *sym)
{
  bfd *dynobj;
  asection *sgot;
  struct mips_got_info *g;
  struct mips_elf_link_hash_table *htab;
  struct mips_elf_link_hash_entry *hmips;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);
  dynobj = elf_hash_table (info)->dynobj;
  hmips = (struct mips_elf_link_hash_entry *) h;

  if (h->plt.plist != NULL && h->plt.plist->mips_offset != MINUS_ONE)
    {
      bfd_byte *loc;
      bfd_vma plt_address, got_address, got_offset, branch_offset;
      Elf_Internal_Rela rel;
      static const bfd_vma *plt_entry;
      bfd_vma gotplt_index;
      bfd_vma plt_offset;

      plt_offset = htab->plt_header_size + h->plt.plist->mips_offset;
      gotplt_index = h->plt.plist->gotplt_index;

      BFD_ASSERT (h->dynindx != -1);
      BFD_ASSERT (htab->splt != NULL);
      BFD_ASSERT (gotplt_index != MINUS_ONE);
      BFD_ASSERT (plt_offset <= htab->splt->size);

      /* Calculate the address of the .plt entry.  */
      plt_address = (htab->splt->output_section->vma
		     + htab->splt->output_offset
		     + plt_offset);

      /* Calculate the address of the .got.plt entry.  */
      got_address = (htab->sgotplt->output_section->vma
		     + htab->sgotplt->output_offset
		     + gotplt_index * MIPS_ELF_GOT_SIZE (output_bfd));

      /* Calculate the offset of the .got.plt entry from
	 _GLOBAL_OFFSET_TABLE_.  */
      got_offset = mips_elf_gotplt_index (info, h);

      /* Calculate the offset for the branch at the start of the PLT
	 entry.  The branch jumps to the beginning of .plt.  */
      branch_offset = -(plt_offset / 4 + 1) & 0xffff;

      /* Fill in the initial value of the .got.plt entry.  */
      bfd_put_32 (output_bfd, plt_address,
		  (htab->sgotplt->contents
		   + gotplt_index * MIPS_ELF_GOT_SIZE (output_bfd)));

      /* Find out where the .plt entry should go.  */
      loc = htab->splt->contents + plt_offset;

      if (info->shared)
	{
	  plt_entry = mips_vxworks_shared_plt_entry;
	  bfd_put_32 (output_bfd, plt_entry[0] | branch_offset, loc);
	  bfd_put_32 (output_bfd, plt_entry[1] | gotplt_index, loc + 4);
	}
      else
	{
	  bfd_vma got_address_high, got_address_low;

	  plt_entry = mips_vxworks_exec_plt_entry;
	  got_address_high = ((got_address + 0x8000) >> 16) & 0xffff;
	  got_address_low = got_address & 0xffff;

	  bfd_put_32 (output_bfd, plt_entry[0] | branch_offset, loc);
	  bfd_put_32 (output_bfd, plt_entry[1] | gotplt_index, loc + 4);
	  bfd_put_32 (output_bfd, plt_entry[2] | got_address_high, loc + 8);
	  bfd_put_32 (output_bfd, plt_entry[3] | got_address_low, loc + 12);
	  bfd_put_32 (output_bfd, plt_entry[4], loc + 16);
	  bfd_put_32 (output_bfd, plt_entry[5], loc + 20);
	  bfd_put_32 (output_bfd, plt_entry[6], loc + 24);
	  bfd_put_32 (output_bfd, plt_entry[7], loc + 28);

	  loc = (htab->srelplt2->contents
		 + (gotplt_index * 3 + 2) * sizeof (Elf32_External_Rela));

	  /* Emit a relocation for the .got.plt entry.  */
	  rel.r_offset = got_address;
	  rel.r_info = ELF32_R_INFO (htab->root.hplt->indx, R_MIPS_32);
	  rel.r_addend = plt_offset;
	  bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);

	  /* Emit a relocation for the lui of %hi(<.got.plt slot>).  */
	  loc += sizeof (Elf32_External_Rela);
	  rel.r_offset = plt_address + 8;
	  rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_HI16);
	  rel.r_addend = got_offset;
	  bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);

	  /* Emit a relocation for the addiu of %lo(<.got.plt slot>).  */
	  loc += sizeof (Elf32_External_Rela);
	  rel.r_offset += 4;
	  rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_LO16);
	  bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
	}

      /* Emit an R_MIPS_JUMP_SLOT relocation against the .got.plt entry.  */
      loc = (htab->srelplt->contents
	     + gotplt_index * sizeof (Elf32_External_Rela));
      rel.r_offset = got_address;
      rel.r_info = ELF32_R_INFO (h->dynindx, R_MIPS_JUMP_SLOT);
      rel.r_addend = 0;
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);

      if (!h->def_regular)
	sym->st_shndx = SHN_UNDEF;
    }

  BFD_ASSERT (h->dynindx != -1 || h->forced_local);

  sgot = htab->sgot;
  g = htab->got_info;
  BFD_ASSERT (g != NULL);

  /* See if this symbol has an entry in the GOT.  */
  if (hmips->global_got_area != GGA_NONE)
    {
      bfd_vma offset;
      Elf_Internal_Rela outrel;
      bfd_byte *loc;
      asection *s;

      /* Install the symbol value in the GOT.   */
      offset = mips_elf_primary_global_got_index (output_bfd, info, h);
      MIPS_ELF_PUT_WORD (output_bfd, sym->st_value, sgot->contents + offset);

      /* Add a dynamic relocation for it.  */
      s = mips_elf_rel_dyn_section (info, FALSE);
      loc = s->contents + (s->reloc_count++ * sizeof (Elf32_External_Rela));
      outrel.r_offset = (sgot->output_section->vma
			 + sgot->output_offset
			 + offset);
      outrel.r_info = ELF32_R_INFO (h->dynindx, R_MIPS_32);
      outrel.r_addend = 0;
      bfd_elf32_swap_reloca_out (dynobj, &outrel, loc);
    }

  /* Emit a copy reloc, if needed.  */
  if (h->needs_copy)
    {
      Elf_Internal_Rela rel;

      BFD_ASSERT (h->dynindx != -1);

      rel.r_offset = (h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset
		      + h->root.u.def.value);
      rel.r_info = ELF32_R_INFO (h->dynindx, R_MIPS_COPY);
      rel.r_addend = 0;
      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				 htab->srelbss->contents
				 + (htab->srelbss->reloc_count
				    * sizeof (Elf32_External_Rela)));
      ++htab->srelbss->reloc_count;
    }

  /* If this is a mips16/microMIPS symbol, force the value to be even.  */
  if (ELF_ST_IS_COMPRESSED (sym->st_other))
    sym->st_value &= ~1;

  return TRUE;
}

/* Write out a plt0 entry to the beginning of .plt.  */

static bfd_boolean
mips_finish_exec_plt (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd_byte *loc;
  bfd_vma gotplt_value, gotplt_value_high, gotplt_value_low;
  static const bfd_vma *plt_entry;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  if (ABI_64_P (output_bfd))
    plt_entry = mips_n64_exec_plt0_entry;
  else if (ABI_N32_P (output_bfd))
    plt_entry = mips_n32_exec_plt0_entry;
  else if (!htab->plt_header_is_comp)
    plt_entry = mips_o32_exec_plt0_entry;
  else if (htab->insn32)
    plt_entry = micromips_insn32_o32_exec_plt0_entry;
  else
    plt_entry = micromips_o32_exec_plt0_entry;

  /* Calculate the value of .got.plt.  */
  gotplt_value = (htab->sgotplt->output_section->vma
		  + htab->sgotplt->output_offset);
  gotplt_value_high = ((gotplt_value + 0x8000) >> 16) & 0xffff;
  gotplt_value_low = gotplt_value & 0xffff;

  /* The PLT sequence is not safe for N64 if .got.plt's address can
     not be loaded in two instructions.  */
  BFD_ASSERT ((gotplt_value & ~(bfd_vma) 0x7fffffff) == 0
	      || ~(gotplt_value | 0x7fffffff) == 0);

  /* Install the PLT header.  */
  loc = htab->splt->contents;
  if (plt_entry == micromips_o32_exec_plt0_entry)
    {
      bfd_vma gotpc_offset;
      bfd_vma loc_address;
      size_t i;

      BFD_ASSERT (gotplt_value % 4 == 0);

      loc_address = (htab->splt->output_section->vma
		     + htab->splt->output_offset);
      gotpc_offset = gotplt_value - ((loc_address | 3) ^ 3);

      /* ADDIUPC has a span of +/-16MB, check we're in range.  */
      if (gotpc_offset + 0x1000000 >= 0x2000000)
	{
	  (*_bfd_error_handler)
	    (_("%B: `%A' offset of %ld from `%A' beyond the range of ADDIUPC"),
	     output_bfd,
	     htab->sgotplt->output_section,
	     htab->splt->output_section,
	     (long) gotpc_offset);
	  bfd_set_error (bfd_error_no_error);
	  return FALSE;
	}
      bfd_put_16 (output_bfd,
		  plt_entry[0] | ((gotpc_offset >> 18) & 0x7f), loc);
      bfd_put_16 (output_bfd, (gotpc_offset >> 2) & 0xffff, loc + 2);
      for (i = 2; i < ARRAY_SIZE (micromips_o32_exec_plt0_entry); i++)
	bfd_put_16 (output_bfd, plt_entry[i], loc + (i * 2));
    }
  else if (plt_entry == micromips_insn32_o32_exec_plt0_entry)
    {
      size_t i;

      bfd_put_16 (output_bfd, plt_entry[0], loc);
      bfd_put_16 (output_bfd, gotplt_value_high, loc + 2);
      bfd_put_16 (output_bfd, plt_entry[2], loc + 4);
      bfd_put_16 (output_bfd, gotplt_value_low, loc + 6);
      bfd_put_16 (output_bfd, plt_entry[4], loc + 8);
      bfd_put_16 (output_bfd, gotplt_value_low, loc + 10);
      for (i = 6; i < ARRAY_SIZE (micromips_insn32_o32_exec_plt0_entry); i++)
	bfd_put_16 (output_bfd, plt_entry[i], loc + (i * 2));
    }
  else
    {
      bfd_put_32 (output_bfd, plt_entry[0] | gotplt_value_high, loc);
      bfd_put_32 (output_bfd, plt_entry[1] | gotplt_value_low, loc + 4);
      bfd_put_32 (output_bfd, plt_entry[2] | gotplt_value_low, loc + 8);
      bfd_put_32 (output_bfd, plt_entry[3], loc + 12);
      bfd_put_32 (output_bfd, plt_entry[4], loc + 16);
      bfd_put_32 (output_bfd, plt_entry[5], loc + 20);
      bfd_put_32 (output_bfd, plt_entry[6], loc + 24);
      bfd_put_32 (output_bfd, plt_entry[7], loc + 28);
    }

  return TRUE;
}

/* Install the PLT header for a VxWorks executable and finalize the
   contents of .rela.plt.unloaded.  */

static void
mips_vxworks_finish_exec_plt (bfd *output_bfd, struct bfd_link_info *info)
{
  Elf_Internal_Rela rela;
  bfd_byte *loc;
  bfd_vma got_value, got_value_high, got_value_low, plt_address;
  static const bfd_vma *plt_entry;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  plt_entry = mips_vxworks_exec_plt0_entry;

  /* Calculate the value of _GLOBAL_OFFSET_TABLE_.  */
  got_value = (htab->root.hgot->root.u.def.section->output_section->vma
	       + htab->root.hgot->root.u.def.section->output_offset
	       + htab->root.hgot->root.u.def.value);

  got_value_high = ((got_value + 0x8000) >> 16) & 0xffff;
  got_value_low = got_value & 0xffff;

  /* Calculate the address of the PLT header.  */
  plt_address = htab->splt->output_section->vma + htab->splt->output_offset;

  /* Install the PLT header.  */
  loc = htab->splt->contents;
  bfd_put_32 (output_bfd, plt_entry[0] | got_value_high, loc);
  bfd_put_32 (output_bfd, plt_entry[1] | got_value_low, loc + 4);
  bfd_put_32 (output_bfd, plt_entry[2], loc + 8);
  bfd_put_32 (output_bfd, plt_entry[3], loc + 12);
  bfd_put_32 (output_bfd, plt_entry[4], loc + 16);
  bfd_put_32 (output_bfd, plt_entry[5], loc + 20);

  /* Output the relocation for the lui of %hi(_GLOBAL_OFFSET_TABLE_).  */
  loc = htab->srelplt2->contents;
  rela.r_offset = plt_address;
  rela.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_HI16);
  rela.r_addend = 0;
  bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
  loc += sizeof (Elf32_External_Rela);

  /* Output the relocation for the following addiu of
     %lo(_GLOBAL_OFFSET_TABLE_).  */
  rela.r_offset += 4;
  rela.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_LO16);
  bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
  loc += sizeof (Elf32_External_Rela);

  /* Fix up the remaining relocations.  They may have the wrong
     symbol index for _G_O_T_ or _P_L_T_ depending on the order
     in which symbols were output.  */
  while (loc < htab->srelplt2->contents + htab->srelplt2->size)
    {
      Elf_Internal_Rela rel;

      bfd_elf32_swap_reloca_in (output_bfd, loc, &rel);
      rel.r_info = ELF32_R_INFO (htab->root.hplt->indx, R_MIPS_32);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
      loc += sizeof (Elf32_External_Rela);

      bfd_elf32_swap_reloca_in (output_bfd, loc, &rel);
      rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_HI16);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
      loc += sizeof (Elf32_External_Rela);

      bfd_elf32_swap_reloca_in (output_bfd, loc, &rel);
      rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_LO16);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
      loc += sizeof (Elf32_External_Rela);
    }
}

/* Install the PLT header for a VxWorks shared library.  */

static void
mips_vxworks_finish_shared_plt (bfd *output_bfd, struct bfd_link_info *info)
{
  unsigned int i;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  /* We just need to copy the entry byte-by-byte.  */
  for (i = 0; i < ARRAY_SIZE (mips_vxworks_shared_plt0_entry); i++)
    bfd_put_32 (output_bfd, mips_vxworks_shared_plt0_entry[i],
		htab->splt->contents + i * 4);
}

/* Finish up the dynamic sections.  */

bfd_boolean
_bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,
				       struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sdyn;
  asection *sgot;
  struct mips_got_info *gg, *g;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  dynobj = elf_hash_table (info)->dynobj;

  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  sgot = htab->sgot;
  gg = htab->got_info;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_byte *b;
      int dyn_to_skip = 0, dyn_skipped = 0;

      BFD_ASSERT (sdyn != NULL);
      BFD_ASSERT (gg != NULL);

      g = mips_elf_bfd_got (output_bfd, FALSE);
      BFD_ASSERT (g != NULL);

      for (b = sdyn->contents;
	   b < sdyn->contents + sdyn->size;
	   b += MIPS_ELF_DYN_SIZE (dynobj))
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  size_t elemsize;
	  asection *s;
	  bfd_boolean swap_out_p;

	  /* Read in the current dynamic entry.  */
	  (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);

	  /* Assume that we're going to modify it and write it out.  */
	  swap_out_p = TRUE;

	  switch (dyn.d_tag)
	    {
	    case DT_RELENT:
	      dyn.d_un.d_val = MIPS_ELF_REL_SIZE (dynobj);
	      break;

	    case DT_RELAENT:
	      BFD_ASSERT (htab->is_vxworks);
	      dyn.d_un.d_val = MIPS_ELF_RELA_SIZE (dynobj);
	      break;

	    case DT_STRSZ:
	      /* Rewrite DT_STRSZ.  */
	      dyn.d_un.d_val =
		_bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
	      break;

	    case DT_PLTGOT:
	      s = htab->sgot;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    case DT_MIPS_PLTGOT:
	      s = htab->sgotplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    case DT_MIPS_RLD_VERSION:
	      dyn.d_un.d_val = 1; /* XXX */
	      break;

	    case DT_MIPS_FLAGS:
	      dyn.d_un.d_val = RHF_NOTPOT; /* XXX */
	      break;

	    case DT_MIPS_TIME_STAMP:
	      {
		time_t t;
		time (&t);
		dyn.d_un.d_val = t;
	      }
	      break;

	    case DT_MIPS_ICHECKSUM:
	      /* XXX FIXME: */
	      swap_out_p = FALSE;
	      break;

	    case DT_MIPS_IVERSION:
	      /* XXX FIXME: */
	      swap_out_p = FALSE;
	      break;

	    case DT_MIPS_BASE_ADDRESS:
	      s = output_bfd->sections;
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma & ~(bfd_vma) 0xffff;
	      break;

	    case DT_MIPS_LOCAL_GOTNO:
	      dyn.d_un.d_val = g->local_gotno;
	      break;

	    case DT_MIPS_UNREFEXTNO:
	      /* The index into the dynamic symbol table which is the
		 entry of the first external symbol that is not
		 referenced within the same object.  */
	      dyn.d_un.d_val = bfd_count_sections (output_bfd) + 1;
	      break;

	    case DT_MIPS_GOTSYM:
	      if (htab->global_gotsym)
		{
		  dyn.d_un.d_val = htab->global_gotsym->dynindx;
		  break;
		}
	      /* In case if we don't have global got symbols we default
		 to setting DT_MIPS_GOTSYM to the same value as
		 DT_MIPS_SYMTABNO, so we just fall through.  */

	    case DT_MIPS_SYMTABNO:
	      name = ".dynsym";
	      elemsize = MIPS_ELF_SYM_SIZE (output_bfd);
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);

	      dyn.d_un.d_val = s->size / elemsize;
	      break;

	    case DT_MIPS_HIPAGENO:
	      dyn.d_un.d_val = g->local_gotno - htab->reserved_gotno;
	      break;

	    case DT_MIPS_RLD_MAP:
	      {
		struct elf_link_hash_entry *h;
		h = mips_elf_hash_table (info)->rld_symbol;
		if (!h)
		  {
		    dyn_to_skip = MIPS_ELF_DYN_SIZE (dynobj);
		    swap_out_p = FALSE;
		    break;
		  }
		s = h->root.u.def.section;
		dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset
				  + h->root.u.def.value);
	      }
	      break;

	    case DT_MIPS_OPTIONS:
	      s = (bfd_get_section_by_name
		   (output_bfd, MIPS_ELF_OPTIONS_SECTION_NAME (output_bfd)));
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    case DT_RELASZ:
	      BFD_ASSERT (htab->is_vxworks);
	      /* The count does not include the JUMP_SLOT relocations.  */
	      if (htab->srelplt)
		dyn.d_un.d_val -= htab->srelplt->size;
	      break;

	    case DT_PLTREL:
	      BFD_ASSERT (htab->use_plts_and_copy_relocs);
	      if (htab->is_vxworks)
		dyn.d_un.d_val = DT_RELA;
	      else
		dyn.d_un.d_val = DT_REL;
	      break;

	    case DT_PLTRELSZ:
	      BFD_ASSERT (htab->use_plts_and_copy_relocs);
	      dyn.d_un.d_val = htab->srelplt->size;
	      break;

	    case DT_JMPREL:
	      BFD_ASSERT (htab->use_plts_and_copy_relocs);
	      dyn.d_un.d_ptr = (htab->srelplt->output_section->vma
				+ htab->srelplt->output_offset);
	      break;

	    case DT_TEXTREL:
	      /* If we didn't need any text relocations after all, delete
		 the dynamic tag.  */
	      if (!(info->flags & DF_TEXTREL))
		{
		  dyn_to_skip = MIPS_ELF_DYN_SIZE (dynobj);
		  swap_out_p = FALSE;
		}
	      break;

	    case DT_FLAGS:
	      /* If we didn't need any text relocations after all, clear
		 DF_TEXTREL from DT_FLAGS.  */
	      if (!(info->flags & DF_TEXTREL))
		dyn.d_un.d_val &= ~DF_TEXTREL;
	      else
		swap_out_p = FALSE;
	      break;

	    default:
	      swap_out_p = FALSE;
	      if (htab->is_vxworks
		  && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))
		swap_out_p = TRUE;
	      break;
	    }

	  if (swap_out_p || dyn_skipped)
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out)
	      (dynobj, &dyn, b - dyn_skipped);

	  if (dyn_to_skip)
	    {
	      dyn_skipped += dyn_to_skip;
	      dyn_to_skip = 0;
	    }
	}

      /* Wipe out any trailing entries if we shifted down a dynamic tag.  */
      if (dyn_skipped > 0)
	memset (b - dyn_skipped, 0, dyn_skipped);
    }

  if (sgot != NULL && sgot->size > 0
      && !bfd_is_abs_section (sgot->output_section))
    {
      if (htab->is_vxworks)
	{
	  /* The first entry of the global offset table points to the
	     ".dynamic" section.  The second is initialized by the
	     loader and contains the shared library identifier.
	     The third is also initialized by the loader and points
	     to the lazy resolution stub.  */
	  MIPS_ELF_PUT_WORD (output_bfd,
			     sdyn->output_offset + sdyn->output_section->vma,
			     sgot->contents);
	  MIPS_ELF_PUT_WORD (output_bfd, 0,
			     sgot->contents + MIPS_ELF_GOT_SIZE (output_bfd));
	  MIPS_ELF_PUT_WORD (output_bfd, 0,
			     sgot->contents
			     + 2 * MIPS_ELF_GOT_SIZE (output_bfd));
	}
      else
	{
	  /* The first entry of the global offset table will be filled at
	     runtime. The second entry will be used by some runtime loaders.
	     This isn't the case of IRIX rld.  */
	  MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0, sgot->contents);
	  MIPS_ELF_PUT_WORD (output_bfd, MIPS_ELF_GNU_GOT1_MASK (output_bfd),
			     sgot->contents + MIPS_ELF_GOT_SIZE (output_bfd));
	}

      elf_section_data (sgot->output_section)->this_hdr.sh_entsize
	 = MIPS_ELF_GOT_SIZE (output_bfd);
    }

  /* Generate dynamic relocations for the non-primary gots.  */
  if (gg != NULL && gg->next)
    {
      Elf_Internal_Rela rel[3];
      bfd_vma addend = 0;

      memset (rel, 0, sizeof (rel));
      rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_REL32);

      for (g = gg->next; g->next != gg; g = g->next)
	{
	  bfd_vma got_index = g->next->local_gotno + g->next->global_gotno
	    + g->next->tls_gotno;

	  MIPS_ELF_PUT_WORD (output_bfd, 0, sgot->contents
			     + got_index++ * MIPS_ELF_GOT_SIZE (output_bfd));
	  MIPS_ELF_PUT_WORD (output_bfd, MIPS_ELF_GNU_GOT1_MASK (output_bfd),
			     sgot->contents
			     + got_index++ * MIPS_ELF_GOT_SIZE (output_bfd));

	  if (! info->shared)
	    continue;

	  while (got_index < g->assigned_gotno)
	    {
	      rel[0].r_offset = rel[1].r_offset = rel[2].r_offset
		= got_index++ * MIPS_ELF_GOT_SIZE (output_bfd);
	      if (!(mips_elf_create_dynamic_relocation
		    (output_bfd, info, rel, NULL,
		     bfd_abs_section_ptr,
		     0, &addend, sgot)))
		return FALSE;
	      BFD_ASSERT (addend == 0);
	    }
	}
    }

  /* The generation of dynamic relocations for the non-primary gots
     adds more dynamic relocations.  We cannot count them until
     here.  */

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_byte *b;
      bfd_boolean swap_out_p;

      BFD_ASSERT (sdyn != NULL);

      for (b = sdyn->contents;
	   b < sdyn->contents + sdyn->size;
	   b += MIPS_ELF_DYN_SIZE (dynobj))
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  /* Read in the current dynamic entry.  */
	  (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);

	  /* Assume that we're going to modify it and write it out.  */
	  swap_out_p = TRUE;

	  switch (dyn.d_tag)
	    {
	    case DT_RELSZ:
	      /* Reduce DT_RELSZ to account for any relocations we
		 decided not to make.  This is for the n64 irix rld,
		 which doesn't seem to apply any relocations if there
		 are trailing null entries.  */
	      s = mips_elf_rel_dyn_section (info, FALSE);
	      dyn.d_un.d_val = (s->reloc_count
				* (ABI_64_P (output_bfd)
				   ? sizeof (Elf64_Mips_External_Rel)
				   : sizeof (Elf32_External_Rel)));
	      /* Adjust the section size too.  Tools like the prelinker
		 can reasonably expect the values to the same.  */
	      elf_section_data (s->output_section)->this_hdr.sh_size
		= dyn.d_un.d_val;
	      break;

	    default:
	      swap_out_p = FALSE;
	      break;
	    }

	  if (swap_out_p)
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out)
	      (dynobj, &dyn, b);
	}
    }

  {
    asection *s;
    Elf32_compact_rel cpt;

    if (SGI_COMPAT (output_bfd))
      {
	/* Write .compact_rel section out.  */
	s = bfd_get_linker_section (dynobj, ".compact_rel");
	if (s != NULL)
	  {
	    cpt.id1 = 1;
	    cpt.num = s->reloc_count;
	    cpt.id2 = 2;
	    cpt.offset = (s->output_section->filepos
			  + sizeof (Elf32_External_compact_rel));
	    cpt.reserved0 = 0;
	    cpt.reserved1 = 0;
	    bfd_elf32_swap_compact_rel_out (output_bfd, &cpt,
					    ((Elf32_External_compact_rel *)
					     s->contents));

	    /* Clean up a dummy stub function entry in .text.  */
	    if (htab->sstubs != NULL)
	      {
		file_ptr dummy_offset;

		BFD_ASSERT (htab->sstubs->size >= htab->function_stub_size);
		dummy_offset = htab->sstubs->size - htab->function_stub_size;
		memset (htab->sstubs->contents + dummy_offset, 0,
			htab->function_stub_size);
	      }
	  }
      }

    /* The psABI says that the dynamic relocations must be sorted in
       increasing order of r_symndx.  The VxWorks EABI doesn't require
       this, and because the code below handles REL rather than RELA
       relocations, using it for VxWorks would be outright harmful.  */
    if (!htab->is_vxworks)
      {
	s = mips_elf_rel_dyn_section (info, FALSE);
	if (s != NULL
	    && s->size > (bfd_vma)2 * MIPS_ELF_REL_SIZE (output_bfd))
	  {
	    reldyn_sorting_bfd = output_bfd;

	    if (ABI_64_P (output_bfd))
	      qsort ((Elf64_External_Rel *) s->contents + 1,
		     s->reloc_count - 1, sizeof (Elf64_Mips_External_Rel),
		     sort_dynamic_relocs_64);
	    else
	      qsort ((Elf32_External_Rel *) s->contents + 1,
		     s->reloc_count - 1, sizeof (Elf32_External_Rel),
		     sort_dynamic_relocs);
	  }
      }
  }

  if (htab->splt && htab->splt->size > 0)
    {
      if (htab->is_vxworks)
	{
	  if (info->shared)
	    mips_vxworks_finish_shared_plt (output_bfd, info);
	  else
	    mips_vxworks_finish_exec_plt (output_bfd, info);
	}
      else
	{
	  BFD_ASSERT (!info->shared);
	  if (!mips_finish_exec_plt (output_bfd, info))
	    return FALSE;
	}
    }
  return TRUE;
}


/* Set ABFD's EF_MIPS_ARCH and EF_MIPS_MACH flags.  */

static void
mips_set_isa_flags (bfd *abfd)
{
  flagword val;

  switch (bfd_get_mach (abfd))
    {
    default:
    case bfd_mach_mips3000:
      val = E_MIPS_ARCH_1;
      break;

    case bfd_mach_mips3900:
      val = E_MIPS_ARCH_1 | E_MIPS_MACH_3900;
      break;

    case bfd_mach_mips6000:
      val = E_MIPS_ARCH_2;
      break;

    case bfd_mach_mips4000:
    case bfd_mach_mips4300:
    case bfd_mach_mips4400:
    case bfd_mach_mips4600:
      val = E_MIPS_ARCH_3;
      break;

    case bfd_mach_mips4010:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4010;
      break;

    case bfd_mach_mips4100:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4100;
      break;

    case bfd_mach_mips4111:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4111;
      break;

    case bfd_mach_mips4120:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4120;
      break;

    case bfd_mach_mips4650:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4650;
      break;

    case bfd_mach_mips5400:
      val = E_MIPS_ARCH_4 | E_MIPS_MACH_5400;
      break;

    case bfd_mach_mips5500:
      val = E_MIPS_ARCH_4 | E_MIPS_MACH_5500;
      break;

    case bfd_mach_mips5900:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_5900;
      break;

    case bfd_mach_mips9000:
      val = E_MIPS_ARCH_4 | E_MIPS_MACH_9000;
      break;

    case bfd_mach_mips5000:
    case bfd_mach_mips7000:
    case bfd_mach_mips8000:
    case bfd_mach_mips10000:
    case bfd_mach_mips12000:
    case bfd_mach_mips14000:
    case bfd_mach_mips16000:
      val = E_MIPS_ARCH_4;
      break;

    case bfd_mach_mips5:
      val = E_MIPS_ARCH_5;
      break;

    case bfd_mach_mips_loongson_2e:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_LS2E;
      break;

    case bfd_mach_mips_loongson_2f:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_LS2F;
      break;

    case bfd_mach_mips_sb1:
      val = E_MIPS_ARCH_64 | E_MIPS_MACH_SB1;
      break;

    case bfd_mach_mips_loongson_3a:
      val = E_MIPS_ARCH_64 | E_MIPS_MACH_LS3A;
      break;

    case bfd_mach_mips_octeon:
    case bfd_mach_mips_octeonp:
      val = E_MIPS_ARCH_64R2 | E_MIPS_MACH_OCTEON;
      break;

    case bfd_mach_mips_xlr:
      val = E_MIPS_ARCH_64 | E_MIPS_MACH_XLR;
      break;

    case bfd_mach_mips_octeon2:
      val = E_MIPS_ARCH_64R2 | E_MIPS_MACH_OCTEON2;
      break;

    case bfd_mach_mipsisa32:
      val = E_MIPS_ARCH_32;
      break;

    case bfd_mach_mipsisa64:
      val = E_MIPS_ARCH_64;
      break;

    case bfd_mach_mipsisa32r2:
      val = E_MIPS_ARCH_32R2;
      break;

    case bfd_mach_mipsisa64r2:
      val = E_MIPS_ARCH_64R2;
      break;
    }
  elf_elfheader (abfd)->e_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
  elf_elfheader (abfd)->e_flags |= val;

}


/* The final processing done just before writing out a MIPS ELF object
   file.  This gets the MIPS architecture right based on the machine
   number.  This is used by both the 32-bit and the 64-bit ABI.  */

void
_bfd_mips_elf_final_write_processing (bfd *abfd,
				      bfd_boolean linker ATTRIBUTE_UNUSED)
{
  unsigned int i;
  Elf_Internal_Shdr **hdrpp;
  const char *name;
  asection *sec;

  /* Keep the existing EF_MIPS_MACH and EF_MIPS_ARCH flags if the former
     is nonzero.  This is for compatibility with old objects, which used
     a combination of a 32-bit EF_MIPS_ARCH and a 64-bit EF_MIPS_MACH.  */
  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_MACH) == 0)
    mips_set_isa_flags (abfd);

  /* Set the sh_info field for .gptab sections and other appropriate
     info for each special section.  */
  for (i = 1, hdrpp = elf_elfsections (abfd) + 1;
       i < elf_numsections (abfd);
       i++, hdrpp++)
    {
      switch ((*hdrpp)->sh_type)
	{
	case SHT_MIPS_MSYM:
	case SHT_MIPS_LIBLIST:
	  sec = bfd_get_section_by_name (abfd, ".dynstr");
	  if (sec != NULL)
	    (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_GPTAB:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL
		      && CONST_STRNEQ (name, ".gptab."));
	  sec = bfd_get_section_by_name (abfd, name + sizeof ".gptab" - 1);
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_CONTENT:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL
		      && CONST_STRNEQ (name, ".MIPS.content"));
	  sec = bfd_get_section_by_name (abfd,
					 name + sizeof ".MIPS.content" - 1);
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_SYMBOL_LIB:
	  sec = bfd_get_section_by_name (abfd, ".dynsym");
	  if (sec != NULL)
	    (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  sec = bfd_get_section_by_name (abfd, ".liblist");
	  if (sec != NULL)
	    (*hdrpp)->sh_info = elf_section_data (sec)->this_idx;
	  break;

	case SHT_MIPS_EVENTS:
	  BFD_ASSERT ((*hdrpp)->bfd_section != NULL);
	  name = bfd_get_section_name (abfd, (*hdrpp)->bfd_section);
	  BFD_ASSERT (name != NULL);
	  if (CONST_STRNEQ (name, ".MIPS.events"))
	    sec = bfd_get_section_by_name (abfd,
					   name + sizeof ".MIPS.events" - 1);
	  else
	    {
	      BFD_ASSERT (CONST_STRNEQ (name, ".MIPS.post_rel"));
	      sec = bfd_get_section_by_name (abfd,
					     (name
					      + sizeof ".MIPS.post_rel" - 1));
	    }
	  BFD_ASSERT (sec != NULL);
	  (*hdrpp)->sh_link = elf_section_data (sec)->this_idx;
	  break;

	}
    }
}

/* When creating an IRIX5 executable, we need REGINFO and RTPROC
   segments.  */

int
_bfd_mips_elf_additional_program_headers (bfd *abfd,
					  struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  asection *s;
  int ret = 0;

  /* See if we need a PT_MIPS_REGINFO segment.  */
  s = bfd_get_section_by_name (abfd, ".reginfo");
  if (s && (s->flags & SEC_LOAD))
    ++ret;

  /* See if we need a PT_MIPS_OPTIONS segment.  */
  if (IRIX_COMPAT (abfd) == ict_irix6
      && bfd_get_section_by_name (abfd,
				  MIPS_ELF_OPTIONS_SECTION_NAME (abfd)))
    ++ret;

  /* See if we need a PT_MIPS_RTPROC segment.  */
  if (IRIX_COMPAT (abfd) == ict_irix5
      && bfd_get_section_by_name (abfd, ".dynamic")
      && bfd_get_section_by_name (abfd, ".mdebug"))
    ++ret;

  /* Allocate a PT_NULL header in dynamic objects.  See
     _bfd_mips_elf_modify_segment_map for details.  */
  if (!SGI_COMPAT (abfd)
      && bfd_get_section_by_name (abfd, ".dynamic"))
    ++ret;

  return ret;
}

/* Modify the segment map for an IRIX5 executable.  */

bfd_boolean
_bfd_mips_elf_modify_segment_map (bfd *abfd,
				  struct bfd_link_info *info)
{
  asection *s;
  struct elf_segment_map *m, **pm;
  bfd_size_type amt;

  /* If there is a .reginfo section, we need a PT_MIPS_REGINFO
     segment.  */
  s = bfd_get_section_by_name (abfd, ".reginfo");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      for (m = elf_seg_map (abfd); m != NULL; m = m->next)
	if (m->p_type == PT_MIPS_REGINFO)
	  break;
      if (m == NULL)
	{
	  amt = sizeof *m;
	  m = bfd_zalloc (abfd, amt);
	  if (m == NULL)
	    return FALSE;

	  m->p_type = PT_MIPS_REGINFO;
	  m->count = 1;
	  m->sections[0] = s;

	  /* We want to put it after the PHDR and INTERP segments.  */
	  pm = &elf_seg_map (abfd);
	  while (*pm != NULL
		 && ((*pm)->p_type == PT_PHDR
		     || (*pm)->p_type == PT_INTERP))
	    pm = &(*pm)->next;

	  m->next = *pm;
	  *pm = m;
	}
    }

  /* For IRIX 6, we don't have .mdebug sections, nor does anything but
     .dynamic end up in PT_DYNAMIC.  However, we do have to insert a
     PT_MIPS_OPTIONS segment immediately following the program header
     table.  */
  if (NEWABI_P (abfd)
      /* On non-IRIX6 new abi, we'll have already created a segment
	 for this section, so don't create another.  I'm not sure this
	 is not also the case for IRIX 6, but I can't test it right
	 now.  */
      && IRIX_COMPAT (abfd) == ict_irix6)
    {
      for (s = abfd->sections; s; s = s->next)
	if (elf_section_data (s)->this_hdr.sh_type == SHT_MIPS_OPTIONS)
	  break;

      if (s)
	{
	  struct elf_segment_map *options_segment;

	  pm = &elf_seg_map (abfd);
	  while (*pm != NULL
		 && ((*pm)->p_type == PT_PHDR
		     || (*pm)->p_type == PT_INTERP))
	    pm = &(*pm)->next;

	  if (*pm == NULL || (*pm)->p_type != PT_MIPS_OPTIONS)
	    {
	      amt = sizeof (struct elf_segment_map);
	      options_segment = bfd_zalloc (abfd, amt);
	      options_segment->next = *pm;
	      options_segment->p_type = PT_MIPS_OPTIONS;
	      options_segment->p_flags = PF_R;
	      options_segment->p_flags_valid = TRUE;
	      options_segment->count = 1;
	      options_segment->sections[0] = s;
	      *pm = options_segment;
	    }
	}
    }
  else
    {
      if (IRIX_COMPAT (abfd) == ict_irix5)
	{
	  /* If there are .dynamic and .mdebug sections, we make a room
	     for the RTPROC header.  FIXME: Rewrite without section names.  */
	  if (bfd_get_section_by_name (abfd, ".interp") == NULL
	      && bfd_get_section_by_name (abfd, ".dynamic") != NULL
	      && bfd_get_section_by_name (abfd, ".mdebug") != NULL)
	    {
	      for (m = elf_seg_map (abfd); m != NULL; m = m->next)
		if (m->p_type == PT_MIPS_RTPROC)
		  break;
	      if (m == NULL)
		{
		  amt = sizeof *m;
		  m = bfd_zalloc (abfd, amt);
		  if (m == NULL)
		    return FALSE;

		  m->p_type = PT_MIPS_RTPROC;

		  s = bfd_get_section_by_name (abfd, ".rtproc");
		  if (s == NULL)
		    {
		      m->count = 0;
		      m->p_flags = 0;
		      m->p_flags_valid = 1;
		    }
		  else
		    {
		      m->count = 1;
		      m->sections[0] = s;
		    }

		  /* We want to put it after the DYNAMIC segment.  */
		  pm = &elf_seg_map (abfd);
		  while (*pm != NULL && (*pm)->p_type != PT_DYNAMIC)
		    pm = &(*pm)->next;
		  if (*pm != NULL)
		    pm = &(*pm)->next;

		  m->next = *pm;
		  *pm = m;
		}
	    }
	}
      /* On IRIX5, the PT_DYNAMIC segment includes the .dynamic,
	 .dynstr, .dynsym, and .hash sections, and everything in
	 between.  */
      for (pm = &elf_seg_map (abfd); *pm != NULL;
	   pm = &(*pm)->next)
	if ((*pm)->p_type == PT_DYNAMIC)
	  break;
      m = *pm;
      if (m != NULL && IRIX_COMPAT (abfd) == ict_none)
	{
	  /* For a normal mips executable the permissions for the PT_DYNAMIC
	     segment are read, write and execute. We do that here since
	     the code in elf.c sets only the read permission. This matters
	     sometimes for the dynamic linker.  */
	  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL)
	    {
	      m->p_flags = PF_R | PF_W | PF_X;
	      m->p_flags_valid = 1;
	    }
	}
      /* GNU/Linux binaries do not need the extended PT_DYNAMIC section.
	 glibc's dynamic linker has traditionally derived the number of
	 tags from the p_filesz field, and sometimes allocates stack
	 arrays of that size.  An overly-big PT_DYNAMIC segment can
	 be actively harmful in such cases.  Making PT_DYNAMIC contain
	 other sections can also make life hard for the prelinker,
	 which might move one of the other sections to a different
	 PT_LOAD segment.  */
      if (SGI_COMPAT (abfd)
	  && m != NULL
	  && m->count == 1
	  && strcmp (m->sections[0]->name, ".dynamic") == 0)
	{
	  static const char *sec_names[] =
	  {
	    ".dynamic", ".dynstr", ".dynsym", ".hash"
	  };
	  bfd_vma low, high;
	  unsigned int i, c;
	  struct elf_segment_map *n;

	  low = ~(bfd_vma) 0;
	  high = 0;
	  for (i = 0; i < sizeof sec_names / sizeof sec_names[0]; i++)
	    {
	      s = bfd_get_section_by_name (abfd, sec_names[i]);
	      if (s != NULL && (s->flags & SEC_LOAD) != 0)
		{
		  bfd_size_type sz;

		  if (low > s->vma)
		    low = s->vma;
		  sz = s->size;
		  if (high < s->vma + sz)
		    high = s->vma + sz;
		}
	    }

	  c = 0;
	  for (s = abfd->sections; s != NULL; s = s->next)
	    if ((s->flags & SEC_LOAD) != 0
		&& s->vma >= low
		&& s->vma + s->size <= high)
	      ++c;

	  amt = sizeof *n + (bfd_size_type) (c - 1) * sizeof (asection *);
	  n = bfd_zalloc (abfd, amt);
	  if (n == NULL)
	    return FALSE;
	  *n = *m;
	  n->count = c;

	  i = 0;
	  for (s = abfd->sections; s != NULL; s = s->next)
	    {
	      if ((s->flags & SEC_LOAD) != 0
		  && s->vma >= low
		  && s->vma + s->size <= high)
		{
		  n->sections[i] = s;
		  ++i;
		}
	    }

	  *pm = n;
	}
    }

  /* Allocate a spare program header in dynamic objects so that tools
     like the prelinker can add an extra PT_LOAD entry.

     If the prelinker needs to make room for a new PT_LOAD entry, its
     standard procedure is to move the first (read-only) sections into
     the new (writable) segment.  However, the MIPS ABI requires
     .dynamic to be in a read-only segment, and the section will often
     start within sizeof (ElfNN_Phdr) bytes of the last program header.

     Although the prelinker could in principle move .dynamic to a
     writable segment, it seems better to allocate a spare program
     header instead, and avoid the need to move any sections.
     There is a long tradition of allocating spare dynamic tags,
     so allocating a spare program header seems like a natural
     extension.

     If INFO is NULL, we may be copying an already prelinked binary
     with objcopy or strip, so do not add this header.  */
  if (info != NULL
      && !SGI_COMPAT (abfd)
      && bfd_get_section_by_name (abfd, ".dynamic"))
    {
      for (pm = &elf_seg_map (abfd); *pm != NULL; pm = &(*pm)->next)
	if ((*pm)->p_type == PT_NULL)
	  break;
      if (*pm == NULL)
	{
	  m = bfd_zalloc (abfd, sizeof (*m));
	  if (m == NULL)
	    return FALSE;

	  m->p_type = PT_NULL;
	  *pm = m;
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

asection *
_bfd_mips_elf_gc_mark_hook (asection *sec,
			    struct bfd_link_info *info,
			    Elf_Internal_Rela *rel,
			    struct elf_link_hash_entry *h,
			    Elf_Internal_Sym *sym)
{
  /* ??? Do mips16 stub sections need to be handled special?  */

  if (h != NULL)
    switch (ELF_R_TYPE (sec->owner, rel->r_info))
      {
      case R_MIPS_GNU_VTINHERIT:
      case R_MIPS_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update the got entry reference counts for the section being removed.  */

bfd_boolean
_bfd_mips_elf_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			     struct bfd_link_info *info ATTRIBUTE_UNUSED,
			     asection *sec ATTRIBUTE_UNUSED,
			     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
#if 0
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF_R_TYPE (abfd, rel->r_info))
      {
      case R_MIPS16_GOT16:
      case R_MIPS16_CALL16:
      case R_MIPS_GOT16:
      case R_MIPS_CALL16:
      case R_MIPS_CALL_HI16:
      case R_MIPS_CALL_LO16:
      case R_MIPS_GOT_HI16:
      case R_MIPS_GOT_LO16:
      case R_MIPS_GOT_DISP:
      case R_MIPS_GOT_PAGE:
      case R_MIPS_GOT_OFST:
      case R_MICROMIPS_GOT16:
      case R_MICROMIPS_CALL16:
      case R_MICROMIPS_CALL_HI16:
      case R_MICROMIPS_CALL_LO16:
      case R_MICROMIPS_GOT_HI16:
      case R_MICROMIPS_GOT_LO16:
      case R_MICROMIPS_GOT_DISP:
      case R_MICROMIPS_GOT_PAGE:
      case R_MICROMIPS_GOT_OFST:
	/* ??? It would seem that the existing MIPS code does no sort
	   of reference counting or whatnot on its GOT and PLT entries,
	   so it is not possible to garbage collect them at this time.  */
	break;

      default:
	break;
      }
#endif

  return TRUE;
}

/* Copy data from a MIPS ELF indirect symbol to its direct symbol,
   hiding the old indirect symbol.  Process additional relocation
   information.  Also called for weakdefs, in which case we just let
   _bfd_elf_link_hash_copy_indirect copy the flags for us.  */

void
_bfd_mips_elf_copy_indirect_symbol (struct bfd_link_info *info,
				    struct elf_link_hash_entry *dir,
				    struct elf_link_hash_entry *ind)
{
  struct mips_elf_link_hash_entry *dirmips, *indmips;

  _bfd_elf_link_hash_copy_indirect (info, dir, ind);

  dirmips = (struct mips_elf_link_hash_entry *) dir;
  indmips = (struct mips_elf_link_hash_entry *) ind;
  /* Any absolute non-dynamic relocations against an indirect or weak
     definition will be against the target symbol.  */
  if (indmips->has_static_relocs)
    dirmips->has_static_relocs = TRUE;

  if (ind->root.type != bfd_link_hash_indirect)
    return;

  dirmips->possibly_dynamic_relocs += indmips->possibly_dynamic_relocs;
  if (indmips->readonly_reloc)
    dirmips->readonly_reloc = TRUE;
  if (indmips->no_fn_stub)
    dirmips->no_fn_stub = TRUE;
  if (indmips->fn_stub)
    {
      dirmips->fn_stub = indmips->fn_stub;
      indmips->fn_stub = NULL;
    }
  if (indmips->need_fn_stub)
    {
      dirmips->need_fn_stub = TRUE;
      indmips->need_fn_stub = FALSE;
    }
  if (indmips->call_stub)
    {
      dirmips->call_stub = indmips->call_stub;
      indmips->call_stub = NULL;
    }
  if (indmips->call_fp_stub)
    {
      dirmips->call_fp_stub = indmips->call_fp_stub;
      indmips->call_fp_stub = NULL;
    }
  if (indmips->global_got_area < dirmips->global_got_area)
    dirmips->global_got_area = indmips->global_got_area;
  if (indmips->global_got_area < GGA_NONE)
    indmips->global_got_area = GGA_NONE;
  if (indmips->has_nonpic_branches)
    dirmips->has_nonpic_branches = TRUE;
}

#define PDR_SIZE 32

bfd_boolean
_bfd_mips_elf_discard_info (bfd *abfd, struct elf_reloc_cookie *cookie,
			    struct bfd_link_info *info)
{
  asection *o;
  bfd_boolean ret = FALSE;
  unsigned char *tdata;
  size_t i, skip;

  o = bfd_get_section_by_name (abfd, ".pdr");
  if (! o)
    return FALSE;
  if (o->size == 0)
    return FALSE;
  if (o->size % PDR_SIZE != 0)
    return FALSE;
  if (o->output_section != NULL
      && bfd_is_abs_section (o->output_section))
    return FALSE;

  tdata = bfd_zmalloc (o->size / PDR_SIZE);
  if (! tdata)
    return FALSE;

  cookie->rels = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
					    info->keep_memory);
  if (!cookie->rels)
    {
      free (tdata);
      return FALSE;
    }

  cookie->rel = cookie->rels;
  cookie->relend = cookie->rels + o->reloc_count;

  for (i = 0, skip = 0; i < o->size / PDR_SIZE; i ++)
    {
      if (bfd_elf_reloc_symbol_deleted_p (i * PDR_SIZE, cookie))
	{
	  tdata[i] = 1;
	  skip ++;
	}
    }

  if (skip != 0)
    {
      mips_elf_section_data (o)->u.tdata = tdata;
      o->size -= skip * PDR_SIZE;
      ret = TRUE;
    }
  else
    free (tdata);

  if (! info->keep_memory)
    free (cookie->rels);

  return ret;
}

bfd_boolean
_bfd_mips_elf_ignore_discarded_relocs (asection *sec)
{
  if (strcmp (sec->name, ".pdr") == 0)
    return TRUE;
  return FALSE;
}

bfd_boolean
_bfd_mips_elf_write_section (bfd *output_bfd,
			     struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
                             asection *sec, bfd_byte *contents)
{
  bfd_byte *to, *from, *end;
  int i;

  if (strcmp (sec->name, ".pdr") != 0)
    return FALSE;

  if (mips_elf_section_data (sec)->u.tdata == NULL)
    return FALSE;

  to = contents;
  end = contents + sec->size;
  for (from = contents, i = 0;
       from < end;
       from += PDR_SIZE, i++)
    {
      if ((mips_elf_section_data (sec)->u.tdata)[i] == 1)
	continue;
      if (to != from)
	memcpy (to, from, PDR_SIZE);
      to += PDR_SIZE;
    }
  bfd_set_section_contents (output_bfd, sec->output_section, contents,
			    sec->output_offset, sec->size);
  return TRUE;
}

/* microMIPS code retains local labels for linker relaxation.  Omit them
   from output by default for clarity.  */

bfd_boolean
_bfd_mips_elf_is_target_special_symbol (bfd *abfd, asymbol *sym)
{
  return _bfd_elf_is_local_label_name (abfd, sym->name);
}

/* MIPS ELF uses a special find_nearest_line routine in order the
   handle the ECOFF debugging information.  */

struct mips_elf_find_line
{
  struct ecoff_debug_info d;
  struct ecoff_find_line i;
};

bfd_boolean
_bfd_mips_elf_find_nearest_line (bfd *abfd, asection *section,
				 asymbol **symbols, bfd_vma offset,
				 const char **filename_ptr,
				 const char **functionname_ptr,
				 unsigned int *line_ptr)
{
  asection *msec;

  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr))
    return TRUE;

  if (_bfd_dwarf2_find_nearest_line (abfd, dwarf_debug_sections,
                                     section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, NULL, ABI_64_P (abfd) ? 8 : 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    return TRUE;

  msec = bfd_get_section_by_name (abfd, ".mdebug");
  if (msec != NULL)
    {
      flagword origflags;
      struct mips_elf_find_line *fi;
      const struct ecoff_debug_swap * const swap =
	get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;

      /* If we are called during a link, mips_elf_final_link may have
	 cleared the SEC_HAS_CONTENTS field.  We force it back on here
	 if appropriate (which it normally will be).  */
      origflags = msec->flags;
      if (elf_section_data (msec)->this_hdr.sh_type != SHT_NOBITS)
	msec->flags |= SEC_HAS_CONTENTS;

      fi = mips_elf_tdata (abfd)->find_line_info;
      if (fi == NULL)
	{
	  bfd_size_type external_fdr_size;
	  char *fraw_src;
	  char *fraw_end;
	  struct fdr *fdr_ptr;
	  bfd_size_type amt = sizeof (struct mips_elf_find_line);

	  fi = bfd_zalloc (abfd, amt);
	  if (fi == NULL)
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }

	  if (! _bfd_mips_elf_read_ecoff_info (abfd, msec, &fi->d))
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }

	  /* Swap in the FDR information.  */
	  amt = fi->d.symbolic_header.ifdMax * sizeof (struct fdr);
	  fi->d.fdr = bfd_alloc (abfd, amt);
	  if (fi->d.fdr == NULL)
	    {
	      msec->flags = origflags;
	      return FALSE;
	    }
	  external_fdr_size = swap->external_fdr_size;
	  fdr_ptr = fi->d.fdr;
	  fraw_src = (char *) fi->d.external_fdr;
	  fraw_end = (fraw_src
		      + fi->d.symbolic_header.ifdMax * external_fdr_size);
	  for (; fraw_src < fraw_end; fraw_src += external_fdr_size, fdr_ptr++)
	    (*swap->swap_fdr_in) (abfd, fraw_src, fdr_ptr);

	  mips_elf_tdata (abfd)->find_line_info = fi;

	  /* Note that we don't bother to ever free this information.
             find_nearest_line is either called all the time, as in
             objdump -l, so the information should be saved, or it is
             rarely called, as in ld error messages, so the memory
             wasted is unimportant.  Still, it would probably be a
             good idea for free_cached_info to throw it away.  */
	}

      if (_bfd_ecoff_locate_line (abfd, section, offset, &fi->d, swap,
				  &fi->i, filename_ptr, functionname_ptr,
				  line_ptr))
	{
	  msec->flags = origflags;
	  return TRUE;
	}

      msec->flags = origflags;
    }

  /* Fall back on the generic ELF find_nearest_line routine.  */

  return _bfd_elf_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr);
}

bfd_boolean
_bfd_mips_elf_find_inliner_info (bfd *abfd,
				 const char **filename_ptr,
				 const char **functionname_ptr,
				 unsigned int *line_ptr)
{
  bfd_boolean found;
  found = _bfd_dwarf2_find_inliner_info (abfd, filename_ptr,
					 functionname_ptr, line_ptr,
					 & elf_tdata (abfd)->dwarf2_find_line_info);
  return found;
}


/* When are writing out the .options or .MIPS.options section,
   remember the bytes we are writing out, so that we can install the
   GP value in the section_processing routine.  */

bfd_boolean
_bfd_mips_elf_set_section_contents (bfd *abfd, sec_ptr section,
				    const void *location,
				    file_ptr offset, bfd_size_type count)
{
  if (MIPS_ELF_OPTIONS_SECTION_NAME_P (section->name))
    {
      bfd_byte *c;

      if (elf_section_data (section) == NULL)
	{
	  bfd_size_type amt = sizeof (struct bfd_elf_section_data);
	  section->used_by_bfd = bfd_zalloc (abfd, amt);
	  if (elf_section_data (section) == NULL)
	    return FALSE;
	}
      c = mips_elf_section_data (section)->u.tdata;
      if (c == NULL)
	{
	  c = bfd_zalloc (abfd, section->size);
	  if (c == NULL)
	    return FALSE;
	  mips_elf_section_data (section)->u.tdata = c;
	}

      memcpy (c + offset, location, count);
    }

  return _bfd_elf_set_section_contents (abfd, section, location, offset,
					count);
}

/* This is almost identical to bfd_generic_get_... except that some
   MIPS relocations need to be handled specially.  Sigh.  */

bfd_byte *
_bfd_elf_mips_get_relocated_section_contents
  (bfd *abfd,
   struct bfd_link_info *link_info,
   struct bfd_link_order *link_order,
   bfd_byte *data,
   bfd_boolean relocatable,
   asymbol **symbols)
{
  /* Get enough memory to hold the stuff */
  bfd *input_bfd = link_order->u.indirect.section->owner;
  asection *input_section = link_order->u.indirect.section;
  bfd_size_type sz;

  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
  arelent **reloc_vector = NULL;
  long reloc_count;

  if (reloc_size < 0)
    goto error_return;

  reloc_vector = bfd_malloc (reloc_size);
  if (reloc_vector == NULL && reloc_size != 0)
    goto error_return;

  /* read in the section */
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (!bfd_get_section_contents (input_bfd, input_section, data, 0, sz))
    goto error_return;

  reloc_count = bfd_canonicalize_reloc (input_bfd,
					input_section,
					reloc_vector,
					symbols);
  if (reloc_count < 0)
    goto error_return;

  if (reloc_count > 0)
    {
      arelent **parent;
      /* for mips */
      int gp_found;
      bfd_vma gp = 0x12345678;	/* initialize just to shut gcc up */

      {
	struct bfd_hash_entry *h;
	struct bfd_link_hash_entry *lh;
	/* Skip all this stuff if we aren't mixing formats.  */
	if (abfd && input_bfd
	    && abfd->xvec == input_bfd->xvec)
	  lh = 0;
	else
	  {
	    h = bfd_hash_lookup (&link_info->hash->table, "_gp", FALSE, FALSE);
	    lh = (struct bfd_link_hash_entry *) h;
	  }
      lookup:
	if (lh)
	  {
	    switch (lh->type)
	      {
	      case bfd_link_hash_undefined:
	      case bfd_link_hash_undefweak:
	      case bfd_link_hash_common:
		gp_found = 0;
		break;
	      case bfd_link_hash_defined:
	      case bfd_link_hash_defweak:
		gp_found = 1;
		gp = lh->u.def.value;
		break;
	      case bfd_link_hash_indirect:
	      case bfd_link_hash_warning:
		lh = lh->u.i.link;
		/* @@@@FIXME  ignoring warning for now */
		goto lookup;
	      case bfd_link_hash_new:
	      default:
		abort ();
	      }
	  }
	else
	  gp_found = 0;
      }
      /* end mips */
      for (parent = reloc_vector; *parent != NULL; parent++)
	{
	  char *error_message = NULL;
	  bfd_reloc_status_type r;

	  /* Specific to MIPS: Deal with relocation types that require
	     knowing the gp of the output bfd.  */
	  asymbol *sym = *(*parent)->sym_ptr_ptr;

	  /* If we've managed to find the gp and have a special
	     function for the relocation then go ahead, else default
	     to the generic handling.  */
	  if (gp_found
	      && (*parent)->howto->special_function
	      == _bfd_mips_elf32_gprel16_reloc)
	    r = _bfd_mips_elf_gprel16_with_gp (input_bfd, sym, *parent,
					       input_section, relocatable,
					       data, gp);
	  else
	    r = bfd_perform_relocation (input_bfd, *parent, data,
					input_section,
					relocatable ? abfd : NULL,
					&error_message);

	  if (relocatable)
	    {
	      asection *os = input_section->output_section;

	      /* A partial link, so keep the relocs */
	      os->orelocation[os->reloc_count] = *parent;
	      os->reloc_count++;
	    }

	  if (r != bfd_reloc_ok)
	    {
	      switch (r)
		{
		case bfd_reloc_undefined:
		  if (!((*link_info->callbacks->undefined_symbol)
			(link_info, bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
			 input_bfd, input_section, (*parent)->address, TRUE)))
		    goto error_return;
		  break;
		case bfd_reloc_dangerous:
		  BFD_ASSERT (error_message != NULL);
		  if (!((*link_info->callbacks->reloc_dangerous)
			(link_info, error_message, input_bfd, input_section,
			 (*parent)->address)))
		    goto error_return;
		  break;
		case bfd_reloc_overflow:
		  if (!((*link_info->callbacks->reloc_overflow)
			(link_info, NULL,
			 bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
			 (*parent)->howto->name, (*parent)->addend,
			 input_bfd, input_section, (*parent)->address)))
		    goto error_return;
		  break;
		case bfd_reloc_outofrange:
		default:
		  abort ();
		  break;
		}

	    }
	}
    }
  if (reloc_vector != NULL)
    free (reloc_vector);
  return data;

error_return:
  if (reloc_vector != NULL)
    free (reloc_vector);
  return NULL;
}

static bfd_boolean
mips_elf_relax_delete_bytes (bfd *abfd,
			     asection *sec, bfd_vma addr, int count)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  struct elf_link_hash_entry **start_hashes;
  unsigned int symcount;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
  contents = elf_section_data (sec)->this_hdr.contents;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   (size_t) (sec->size - addr - count));
  sec->size -= count;

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    {
      /* Get the new reloc address.  */
      if (irel->r_offset > addr)
	irel->r_offset -= count;
    }

  BFD_ASSERT (addr % 2 == 0);
  BFD_ASSERT (count % 2 == 0);

  /* Adjust the local symbols defined in this section.  */
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  for (isymend = isym + symtab_hdr->sh_info; isym < isymend; isym++)
    if (isym->st_shndx == sec_shndx && isym->st_value > addr)
      isym->st_value -= count;

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = start_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;

  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec)
	{
	  bfd_vma value = sym_hash->root.u.def.value;

	  if (ELF_ST_IS_MICROMIPS (sym_hash->other))
	    value &= MINUS_TWO;
	  if (value > addr)
	    sym_hash->root.u.def.value -= count;
	}
    }

  return TRUE;
}


/* Opcodes needed for microMIPS relaxation as found in
   opcodes/micromips-opc.c.  */

struct opcode_descriptor {
  unsigned long match;
  unsigned long mask;
};

/* The $ra register aka $31.  */

#define RA 31

/* 32-bit instruction format register fields.  */

#define OP32_SREG(opcode) (((opcode) >> 16) & 0x1f)
#define OP32_TREG(opcode) (((opcode) >> 21) & 0x1f)

/* Check if a 5-bit register index can be abbreviated to 3 bits.  */

#define OP16_VALID_REG(r) \
  ((2 <= (r) && (r) <= 7) || (16 <= (r) && (r) <= 17))


/* 32-bit and 16-bit branches.  */

static const struct opcode_descriptor b_insns_32[] = {
  { /* "b",	"p",		*/ 0x40400000, 0xffff0000 }, /* bgez 0 */
  { /* "b",	"p",		*/ 0x94000000, 0xffff0000 }, /* beq 0, 0 */
  { 0, 0 }  /* End marker for find_match().  */
};

static const struct opcode_descriptor bc_insn_32 =
  { /* "bc(1|2)(ft)", "N,p",	*/ 0x42800000, 0xfec30000 };

static const struct opcode_descriptor bz_insn_32 =
  { /* "b(g|l)(e|t)z", "s,p",	*/ 0x40000000, 0xff200000 };

static const struct opcode_descriptor bzal_insn_32 =
  { /* "b(ge|lt)zal", "s,p",	*/ 0x40200000, 0xffa00000 };

static const struct opcode_descriptor beq_insn_32 =
  { /* "b(eq|ne)", "s,t,p",	*/ 0x94000000, 0xdc000000 };

static const struct opcode_descriptor b_insn_16 =
  { /* "b",	"mD",		*/ 0xcc00,     0xfc00 };

static const struct opcode_descriptor bz_insn_16 =
  { /* "b(eq|ne)z", "md,mE",	*/ 0x8c00,     0xdc00 };


/* 32-bit and 16-bit branch EQ and NE zero.  */

/* NOTE: All opcode tables have BEQ/BNE in the same order: first the
   eq and second the ne.  This convention is used when replacing a
   32-bit BEQ/BNE with the 16-bit version.  */

#define BZC32_REG_FIELD(r) (((r) & 0x1f) << 16)

static const struct opcode_descriptor bz_rs_insns_32[] = {
  { /* "beqz",	"s,p",		*/ 0x94000000, 0xffe00000 },
  { /* "bnez",	"s,p",		*/ 0xb4000000, 0xffe00000 },
  { 0, 0 }  /* End marker for find_match().  */
};

static const struct opcode_descriptor bz_rt_insns_32[] = {
  { /* "beqz",	"t,p",		*/ 0x94000000, 0xfc01f000 },
  { /* "bnez",	"t,p",		*/ 0xb4000000, 0xfc01f000 },
  { 0, 0 }  /* End marker for find_match().  */
};

static const struct opcode_descriptor bzc_insns_32[] = {
  { /* "beqzc",	"s,p",		*/ 0x40e00000, 0xffe00000 },
  { /* "bnezc",	"s,p",		*/ 0x40a00000, 0xffe00000 },
  { 0, 0 }  /* End marker for find_match().  */
};

static const struct opcode_descriptor bz_insns_16[] = {
  { /* "beqz",	"md,mE",	*/ 0x8c00,     0xfc00 },
  { /* "bnez",	"md,mE",	*/ 0xac00,     0xfc00 },
  { 0, 0 }  /* End marker for find_match().  */
};

/* Switch between a 5-bit register index and its 3-bit shorthand.  */

#define BZ16_REG(opcode) ((((((opcode) >> 7) & 7) + 0x1e) & 0x17) + 2)
#define BZ16_REG_FIELD(r) \
  (((2 <= (r) && (r) <= 7) ? (r) : ((r) - 16)) << 7)


/* 32-bit instructions with a delay slot.  */

static const struct opcode_descriptor jal_insn_32_bd16 =
  { /* "jals",	"a",		*/ 0x74000000, 0xfc000000 };

static const struct opcode_descriptor jal_insn_32_bd32 =
  { /* "jal",	"a",		*/ 0xf4000000, 0xfc000000 };

static const struct opcode_descriptor jal_x_insn_32_bd32 =
  { /* "jal[x]", "a",		*/ 0xf0000000, 0xf8000000 };

static const struct opcode_descriptor j_insn_32 =
  { /* "j",	"a",		*/ 0xd4000000, 0xfc000000 };

static const struct opcode_descriptor jalr_insn_32 =
  { /* "jalr[.hb]", "t,s",	*/ 0x00000f3c, 0xfc00efff };

/* This table can be compacted, because no opcode replacement is made.  */

static const struct opcode_descriptor ds_insns_32_bd16[] = {
  { /* "jals",	"a",		*/ 0x74000000, 0xfc000000 },

  { /* "jalrs[.hb]", "t,s",	*/ 0x00004f3c, 0xfc00efff },
  { /* "b(ge|lt)zals", "s,p",	*/ 0x42200000, 0xffa00000 },

  { /* "b(g|l)(e|t)z", "s,p",	*/ 0x40000000, 0xff200000 },
  { /* "b(eq|ne)", "s,t,p",	*/ 0x94000000, 0xdc000000 },
  { /* "j",	"a",		*/ 0xd4000000, 0xfc000000 },
  { 0, 0 }  /* End marker for find_match().  */
};

/* This table can be compacted, because no opcode replacement is made.  */

static const struct opcode_descriptor ds_insns_32_bd32[] = {
  { /* "jal[x]", "a",		*/ 0xf0000000, 0xf8000000 },

  { /* "jalr[.hb]", "t,s",	*/ 0x00000f3c, 0xfc00efff },
  { /* "b(ge|lt)zal", "s,p",	*/ 0x40200000, 0xffa00000 },
  { 0, 0 }  /* End marker for find_match().  */
};


/* 16-bit instructions with a delay slot.  */

static const struct opcode_descriptor jalr_insn_16_bd16 =
  { /* "jalrs",	"my,mj",	*/ 0x45e0,     0xffe0 };

static const struct opcode_descriptor jalr_insn_16_bd32 =
  { /* "jalr",	"my,mj",	*/ 0x45c0,     0xffe0 };

static const struct opcode_descriptor jr_insn_16 =
  { /* "jr",	"mj",		*/ 0x4580,     0xffe0 };

#define JR16_REG(opcode) ((opcode) & 0x1f)

/* This table can be compacted, because no opcode replacement is made.  */

static const struct opcode_descriptor ds_insns_16_bd16[] = {
  { /* "jalrs",	"my,mj",	*/ 0x45e0,     0xffe0 },

  { /* "b",	"mD",		*/ 0xcc00,     0xfc00 },
  { /* "b(eq|ne)z", "md,mE",	*/ 0x8c00,     0xdc00 },
  { /* "jr",	"mj",		*/ 0x4580,     0xffe0 },
  { 0, 0 }  /* End marker for find_match().  */
};


/* LUI instruction.  */

static const struct opcode_descriptor lui_insn =
 { /* "lui",	"s,u",		*/ 0x41a00000, 0xffe00000 };


/* ADDIU instruction.  */

static const struct opcode_descriptor addiu_insn =
  { /* "addiu",	"t,r,j",	*/ 0x30000000, 0xfc000000 };

static const struct opcode_descriptor addiupc_insn =
  { /* "addiu",	"mb,$pc,mQ",	*/ 0x78000000, 0xfc000000 };

#define ADDIUPC_REG_FIELD(r) \
  (((2 <= (r) && (r) <= 7) ? (r) : ((r) - 16)) << 23)


/* Relaxable instructions in a JAL delay slot: MOVE.  */

/* The 16-bit move has rd in 9:5 and rs in 4:0.  The 32-bit moves
   (ADDU, OR) have rd in 15:11 and rs in 10:16.  */
#define MOVE32_RD(opcode) (((opcode) >> 11) & 0x1f)
#define MOVE32_RS(opcode) (((opcode) >> 16) & 0x1f)

#define MOVE16_RD_FIELD(r) (((r) & 0x1f) << 5)
#define MOVE16_RS_FIELD(r) (((r) & 0x1f)     )

static const struct opcode_descriptor move_insns_32[] = {
  { /* "move",	"d,s",		*/ 0x00000150, 0xffe007ff }, /* addu d,s,$0 */
  { /* "move",	"d,s",		*/ 0x00000290, 0xffe007ff }, /* or   d,s,$0 */
  { 0, 0 }  /* End marker for find_match().  */
};

static const struct opcode_descriptor move_insn_16 =
  { /* "move",	"mp,mj",	*/ 0x0c00,     0xfc00 };


/* NOP instructions.  */

static const struct opcode_descriptor nop_insn_32 =
  { /* "nop",	"",		*/ 0x00000000, 0xffffffff };

static const struct opcode_descriptor nop_insn_16 =
  { /* "nop",	"",		*/ 0x0c00,     0xffff };


/* Instruction match support.  */

#define MATCH(opcode, insn) ((opcode & insn.mask) == insn.match)

static int
find_match (unsigned long opcode, const struct opcode_descriptor insn[])
{
  unsigned long indx;

  for (indx = 0; insn[indx].mask != 0; indx++)
    if (MATCH (opcode, insn[indx]))
      return indx;

  return -1;
}


/* Branch and delay slot decoding support.  */

/* If PTR points to what *might* be a 16-bit branch or jump, then
   return the minimum length of its delay slot, otherwise return 0.
   Non-zero results are not definitive as we might be checking against
   the second half of another instruction.  */

static int
check_br16_dslot (bfd *abfd, bfd_byte *ptr)
{
  unsigned long opcode;
  int bdsize;

  opcode = bfd_get_16 (abfd, ptr);
  if (MATCH (opcode, jalr_insn_16_bd32) != 0)
    /* 16-bit branch/jump with a 32-bit delay slot.  */
    bdsize = 4;
  else if (MATCH (opcode, jalr_insn_16_bd16) != 0
	   || find_match (opcode, ds_insns_16_bd16) >= 0)
    /* 16-bit branch/jump with a 16-bit delay slot.  */
    bdsize = 2;
  else
    /* No delay slot.  */
    bdsize = 0;

  return bdsize;
}

/* If PTR points to what *might* be a 32-bit branch or jump, then
   return the minimum length of its delay slot, otherwise return 0.
   Non-zero results are not definitive as we might be checking against
   the second half of another instruction.  */

static int
check_br32_dslot (bfd *abfd, bfd_byte *ptr)
{
  unsigned long opcode;
  int bdsize;

  opcode = bfd_get_micromips_32 (abfd, ptr);
  if (find_match (opcode, ds_insns_32_bd32) >= 0)
    /* 32-bit branch/jump with a 32-bit delay slot.  */
    bdsize = 4;
  else if (find_match (opcode, ds_insns_32_bd16) >= 0)
    /* 32-bit branch/jump with a 16-bit delay slot.  */
    bdsize = 2;
  else
    /* No delay slot.  */
    bdsize = 0;

  return bdsize;
}

/* If PTR points to a 16-bit branch or jump with a 32-bit delay slot
   that doesn't fiddle with REG, then return TRUE, otherwise FALSE.  */

static bfd_boolean
check_br16 (bfd *abfd, bfd_byte *ptr, unsigned long reg)
{
  unsigned long opcode;

  opcode = bfd_get_16 (abfd, ptr);
  if (MATCH (opcode, b_insn_16)
						/* B16  */
      || (MATCH (opcode, jr_insn_16) && reg != JR16_REG (opcode))
						/* JR16  */
      || (MATCH (opcode, bz_insn_16) && reg != BZ16_REG (opcode))
						/* BEQZ16, BNEZ16  */
      || (MATCH (opcode, jalr_insn_16_bd32)
						/* JALR16  */
	  && reg != JR16_REG (opcode) && reg != RA))
    return TRUE;

  return FALSE;
}

/* If PTR points to a 32-bit branch or jump that doesn't fiddle with REG,
   then return TRUE, otherwise FALSE.  */

static bfd_boolean
check_br32 (bfd *abfd, bfd_byte *ptr, unsigned long reg)
{
  unsigned long opcode;

  opcode = bfd_get_micromips_32 (abfd, ptr);
  if (MATCH (opcode, j_insn_32)
						/* J  */
      || MATCH (opcode, bc_insn_32)
						/* BC1F, BC1T, BC2F, BC2T  */
      || (MATCH (opcode, jal_x_insn_32_bd32) && reg != RA)
						/* JAL, JALX  */
      || (MATCH (opcode, bz_insn_32) && reg != OP32_SREG (opcode))
						/* BGEZ, BGTZ, BLEZ, BLTZ  */
      || (MATCH (opcode, bzal_insn_32)
						/* BGEZAL, BLTZAL  */
	  && reg != OP32_SREG (opcode) && reg != RA)
      || ((MATCH (opcode, jalr_insn_32) || MATCH (opcode, beq_insn_32))
						/* JALR, JALR.HB, BEQ, BNE  */
	  && reg != OP32_SREG (opcode) && reg != OP32_TREG (opcode)))
    return TRUE;

  return FALSE;
}

/* If the instruction encoding at PTR and relocations [INTERNAL_RELOCS,
   IRELEND) at OFFSET indicate that there must be a compact branch there,
   then return TRUE, otherwise FALSE.  */

static bfd_boolean
check_relocated_bzc (bfd *abfd, const bfd_byte *ptr, bfd_vma offset,
		     const Elf_Internal_Rela *internal_relocs,
		     const Elf_Internal_Rela *irelend)
{
  const Elf_Internal_Rela *irel;
  unsigned long opcode;

  opcode = bfd_get_micromips_32 (abfd, ptr);
  if (find_match (opcode, bzc_insns_32) < 0)
    return FALSE;

  for (irel = internal_relocs; irel < irelend; irel++)
    if (irel->r_offset == offset
	&& ELF32_R_TYPE (irel->r_info) == R_MICROMIPS_PC16_S1)
      return TRUE;

  return FALSE;
}

/* Bitsize checking.  */
#define IS_BITSIZE(val, N)						\
  (((((val) & ((1ULL << (N)) - 1)) ^ (1ULL << ((N) - 1)))		\
    - (1ULL << ((N) - 1))) == (val))


bfd_boolean
_bfd_mips_elf_relax_section (bfd *abfd, asection *sec,
			     struct bfd_link_info *link_info,
			     bfd_boolean *again)
{
  bfd_boolean insn32 = mips_elf_hash_table (link_info)->insn32;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  /* Assume nothing changes.  */
  *again = FALSE;

  /* We don't have to do anything for a relocatable link, if
     this section does not have relocs, or if this is not a
     code section.  */

  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;

  /* Walk through them looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      unsigned long r_symndx = ELF32_R_SYM (irel->r_info);
      unsigned int r_type = ELF32_R_TYPE (irel->r_info);
      bfd_boolean target_is_micromips_code_p;
      unsigned long opcode;
      bfd_vma symval;
      bfd_vma pcrval;
      bfd_byte *ptr;
      int fndopc;

      /* The number of bytes to delete for relaxation and from where
         to delete these bytes starting at irel->r_offset.  */
      int delcnt = 0;
      int deloff = 0;

      /* If this isn't something that can be relaxed, then ignore
         this reloc.  */
      if (r_type != R_MICROMIPS_HI16
	  && r_type != R_MICROMIPS_PC16_S1
	  && r_type != R_MICROMIPS_26_S1)
	continue;

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  /* Go get them off disk.  */
	  else if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	    goto error_return;
	}
      ptr = contents + irel->r_offset;

      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;
	  asection *sym_sec;

	  isym = isymbuf + r_symndx;
	  if (isym->st_shndx == SHN_UNDEF)
	    sym_sec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    sym_sec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    sym_sec = bfd_com_section_ptr;
	  else
	    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
	  target_is_micromips_code_p = ELF_ST_IS_MICROMIPS (isym->st_other);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = r_symndx - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);

	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    /* This appears to be a reference to an undefined
	       symbol.  Just ignore it -- it will be caught by the
	       regular reloc processing.  */
	    continue;

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	  target_is_micromips_code_p = (!h->needs_plt
					&& ELF_ST_IS_MICROMIPS (h->other));
	}


      /* For simplicity of coding, we are going to modify the
         section contents, the section relocs, and the BFD symbol
         table.  We must tell the rest of the code not to free up this
         information.  It would be possible to instead create a table
         of changes which have to be made, as is done in coff-mips.c;
         that would be more work, but would require less memory when
         the linker is run.  */

      /* Only 32-bit instructions relaxed.  */
      if (irel->r_offset + 4 > sec->size)
	continue;

      opcode = bfd_get_micromips_32 (abfd, ptr);

      /* This is the pc-relative distance from the instruction the
         relocation is applied to, to the symbol referred.  */
      pcrval = (symval
		- (sec->output_section->vma + sec->output_offset)
		- irel->r_offset);

      /* R_MICROMIPS_HI16 / LUI relaxation to nil, performing relaxation
         of corresponding R_MICROMIPS_LO16 to R_MICROMIPS_HI0_LO16 or
         R_MICROMIPS_PC23_S2.  The R_MICROMIPS_PC23_S2 condition is

           (symval % 4 == 0 && IS_BITSIZE (pcrval, 25))

         where pcrval has first to be adjusted to apply against the LO16
         location (we make the adjustment later on, when we have figured
         out the offset).  */
      if (r_type == R_MICROMIPS_HI16 && MATCH (opcode, lui_insn))
	{
	  bfd_boolean bzc = FALSE;
	  unsigned long nextopc;
	  unsigned long reg;
	  bfd_vma offset;

	  /* Give up if the previous reloc was a HI16 against this symbol
	     too.  */
	  if (irel > internal_relocs
	      && ELF32_R_TYPE (irel[-1].r_info) == R_MICROMIPS_HI16
	      && ELF32_R_SYM (irel[-1].r_info) == r_symndx)
	    continue;

	  /* Or if the next reloc is not a LO16 against this symbol.  */
	  if (irel + 1 >= irelend
	      || ELF32_R_TYPE (irel[1].r_info) != R_MICROMIPS_LO16
	      || ELF32_R_SYM (irel[1].r_info) != r_symndx)
	    continue;

	  /* Or if the second next reloc is a LO16 against this symbol too.  */
	  if (irel + 2 >= irelend
	      && ELF32_R_TYPE (irel[2].r_info) == R_MICROMIPS_LO16
	      && ELF32_R_SYM (irel[2].r_info) == r_symndx)
	    continue;

	  /* See if the LUI instruction *might* be in a branch delay slot.
	     We check whether what looks like a 16-bit branch or jump is
	     actually an immediate argument to a compact branch, and let
	     it through if so.  */
	  if (irel->r_offset >= 2
	      && check_br16_dslot (abfd, ptr - 2)
	      && !(irel->r_offset >= 4
		   && (bzc = check_relocated_bzc (abfd,
						  ptr - 4, irel->r_offset - 4,
						  internal_relocs, irelend))))
	    continue;
	  if (irel->r_offset >= 4
	      && !bzc
	      && check_br32_dslot (abfd, ptr - 4))
	    continue;

	  reg = OP32_SREG (opcode);

	  /* We only relax adjacent instructions or ones separated with
	     a branch or jump that has a delay slot.  The branch or jump
	     must not fiddle with the register used to hold the address.
	     Subtract 4 for the LUI itself.  */
	  offset = irel[1].r_offset - irel[0].r_offset;
	  switch (offset - 4)
	    {
	    case 0:
	      break;
	    case 2:
	      if (check_br16 (abfd, ptr + 4, reg))
		break;
	      continue;
	    case 4:
	      if (check_br32 (abfd, ptr + 4, reg))
		break;
	      continue;
	    default:
	      continue;
	    }

	  nextopc = bfd_get_micromips_32 (abfd, contents + irel[1].r_offset);

	  /* Give up unless the same register is used with both
	     relocations.  */
	  if (OP32_SREG (nextopc) != reg)
	    continue;

	  /* Now adjust pcrval, subtracting the offset to the LO16 reloc
	     and rounding up to take masking of the two LSBs into account.  */
	  pcrval = ((pcrval - offset + 3) | 3) ^ 3;

	  /* R_MICROMIPS_LO16 relaxation to R_MICROMIPS_HI0_LO16.  */
	  if (IS_BITSIZE (symval, 16))
	    {
	      /* Fix the relocation's type.  */
	      irel[1].r_info = ELF32_R_INFO (r_symndx, R_MICROMIPS_HI0_LO16);

	      /* Instructions using R_MICROMIPS_LO16 have the base or
	         source register in bits 20:16.  This register becomes $0
	         (zero) as the result of the R_MICROMIPS_HI16 being 0.  */
	      nextopc &= ~0x001f0000;
	      bfd_put_16 (abfd, (nextopc >> 16) & 0xffff,
			  contents + irel[1].r_offset);
	    }

	  /* R_MICROMIPS_LO16 / ADDIU relaxation to R_MICROMIPS_PC23_S2.
	     We add 4 to take LUI deletion into account while checking
	     the PC-relative distance.  */
	  else if (symval % 4 == 0
		   && IS_BITSIZE (pcrval + 4, 25)
		   && MATCH (nextopc, addiu_insn)
		   && OP32_TREG (nextopc) == OP32_SREG (nextopc)
		   && OP16_VALID_REG (OP32_TREG (nextopc)))
	    {
	      /* Fix the relocation's type.  */
	      irel[1].r_info = ELF32_R_INFO (r_symndx, R_MICROMIPS_PC23_S2);

	      /* Replace ADDIU with the ADDIUPC version.  */
	      nextopc = (addiupc_insn.match
			 | ADDIUPC_REG_FIELD (OP32_TREG (nextopc)));

	      bfd_put_micromips_32 (abfd, nextopc,
				    contents + irel[1].r_offset);
	    }

	  /* Can't do anything, give up, sigh...  */
	  else
	    continue;

	  /* Fix the relocation's type.  */
	  irel->r_info = ELF32_R_INFO (r_symndx, R_MIPS_NONE);

	  /* Delete the LUI instruction: 4 bytes at irel->r_offset.  */
	  delcnt = 4;
	  deloff = 0;
	}

      /* Compact branch relaxation -- due to the multitude of macros
         employed by the compiler/assembler, compact branches are not
         always generated.  Obviously, this can/will be fixed elsewhere,
         but there is no drawback in double checking it here.  */
      else if (r_type == R_MICROMIPS_PC16_S1
	       && irel->r_offset + 5 < sec->size
	       && ((fndopc = find_match (opcode, bz_rs_insns_32)) >= 0
		   || (fndopc = find_match (opcode, bz_rt_insns_32)) >= 0)
	       && ((!insn32
		    && (delcnt = MATCH (bfd_get_16 (abfd, ptr + 4),
					nop_insn_16) ? 2 : 0))
		   || (irel->r_offset + 7 < sec->size
		       && (delcnt = MATCH (bfd_get_micromips_32 (abfd,
								 ptr + 4),
					   nop_insn_32) ? 4 : 0))))
	{
	  unsigned long reg;

	  reg = OP32_SREG (opcode) ? OP32_SREG (opcode) : OP32_TREG (opcode);

	  /* Replace BEQZ/BNEZ with the compact version.  */
	  opcode = (bzc_insns_32[fndopc].match
		    | BZC32_REG_FIELD (reg)
		    | (opcode & 0xffff));		/* Addend value.  */

	  bfd_put_micromips_32 (abfd, opcode, ptr);

	  /* Delete the delay slot NOP: two or four bytes from
	     irel->offset + 4; delcnt has already been set above.  */
	  deloff = 4;
	}

      /* R_MICROMIPS_PC16_S1 relaxation to R_MICROMIPS_PC10_S1.  We need
         to check the distance from the next instruction, so subtract 2.  */
      else if (!insn32
	       && r_type == R_MICROMIPS_PC16_S1
	       && IS_BITSIZE (pcrval - 2, 11)
	       && find_match (opcode, b_insns_32) >= 0)
	{
	  /* Fix the relocation's type.  */
	  irel->r_info = ELF32_R_INFO (r_symndx, R_MICROMIPS_PC10_S1);

	  /* Replace the 32-bit opcode with a 16-bit opcode.  */
	  bfd_put_16 (abfd,
		      (b_insn_16.match
		       | (opcode & 0x3ff)),		/* Addend value.  */
		      ptr);

	  /* Delete 2 bytes from irel->r_offset + 2.  */
	  delcnt = 2;
	  deloff = 2;
	}

      /* R_MICROMIPS_PC16_S1 relaxation to R_MICROMIPS_PC7_S1.  We need
         to check the distance from the next instruction, so subtract 2.  */
      else if (!insn32
	       && r_type == R_MICROMIPS_PC16_S1
	       && IS_BITSIZE (pcrval - 2, 8)
	       && (((fndopc = find_match (opcode, bz_rs_insns_32)) >= 0
		    && OP16_VALID_REG (OP32_SREG (opcode)))
		   || ((fndopc = find_match (opcode, bz_rt_insns_32)) >= 0
		       && OP16_VALID_REG (OP32_TREG (opcode)))))
	{
	  unsigned long reg;

	  reg = OP32_SREG (opcode) ? OP32_SREG (opcode) : OP32_TREG (opcode);

	  /* Fix the relocation's type.  */
	  irel->r_info = ELF32_R_INFO (r_symndx, R_MICROMIPS_PC7_S1);

	  /* Replace the 32-bit opcode with a 16-bit opcode.  */
	  bfd_put_16 (abfd,
		      (bz_insns_16[fndopc].match
		       | BZ16_REG_FIELD (reg)
		       | (opcode & 0x7f)),		/* Addend value.  */
		      ptr);

	  /* Delete 2 bytes from irel->r_offset + 2.  */
	  delcnt = 2;
	  deloff = 2;
	}

      /* R_MICROMIPS_26_S1 -- JAL to JALS relaxation for microMIPS targets.  */
      else if (!insn32
	       && r_type == R_MICROMIPS_26_S1
	       && target_is_micromips_code_p
	       && irel->r_offset + 7 < sec->size
	       && MATCH (opcode, jal_insn_32_bd32))
	{
	  unsigned long n32opc;
	  bfd_boolean relaxed = FALSE;

	  n32opc = bfd_get_micromips_32 (abfd, ptr + 4);

	  if (MATCH (n32opc, nop_insn_32))
	    {
	      /* Replace delay slot 32-bit NOP with a 16-bit NOP.  */
	      bfd_put_16 (abfd, nop_insn_16.match, ptr + 4);

	      relaxed = TRUE;
	    }
	  else if (find_match (n32opc, move_insns_32) >= 0)
	    {
	      /* Replace delay slot 32-bit MOVE with 16-bit MOVE.  */
	      bfd_put_16 (abfd,
			  (move_insn_16.match
			   | MOVE16_RD_FIELD (MOVE32_RD (n32opc))
			   | MOVE16_RS_FIELD (MOVE32_RS (n32opc))),
			  ptr + 4);

	      relaxed = TRUE;
	    }
	  /* Other 32-bit instructions relaxable to 16-bit
	     instructions will be handled here later.  */

	  if (relaxed)
	    {
	      /* JAL with 32-bit delay slot that is changed to a JALS
	         with 16-bit delay slot.  */
	      bfd_put_micromips_32 (abfd, jal_insn_32_bd16.match, ptr);

	      /* Delete 2 bytes from irel->r_offset + 6.  */
	      delcnt = 2;
	      deloff = 6;
	    }
	}

      if (delcnt != 0)
	{
	  /* Note that we've changed the relocs, section contents, etc.  */
	  elf_section_data (sec)->relocs = internal_relocs;
	  elf_section_data (sec)->this_hdr.contents = contents;
	  symtab_hdr->contents = (unsigned char *) isymbuf;

	  /* Delete bytes depending on the delcnt and deloff.  */
	  if (!mips_elf_relax_delete_bytes (abfd, sec,
					    irel->r_offset + deloff, delcnt))
	    goto error_return;

	  /* That will change things, so we should relax again.
	     Note that this is not required, and it may be slow.  */
	  *again = TRUE;
	}
    }

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (! link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return TRUE;

 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
}

/* Create a MIPS ELF linker hash table.  */

struct bfd_link_hash_table *
_bfd_mips_elf_link_hash_table_create (bfd *abfd)
{
  struct mips_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct mips_elf_link_hash_table);

  ret = bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      mips_elf_link_hash_newfunc,
				      sizeof (struct mips_elf_link_hash_entry),
				      MIPS_ELF_DATA))
    {
      free (ret);
      return NULL;
    }
  ret->root.init_plt_refcount.plist = NULL;
  ret->root.init_plt_offset.plist = NULL;

  return &ret->root.root;
}

/* Likewise, but indicate that the target is VxWorks.  */

struct bfd_link_hash_table *
_bfd_mips_vxworks_link_hash_table_create (bfd *abfd)
{
  struct bfd_link_hash_table *ret;

  ret = _bfd_mips_elf_link_hash_table_create (abfd);
  if (ret)
    {
      struct mips_elf_link_hash_table *htab;

      htab = (struct mips_elf_link_hash_table *) ret;
      htab->use_plts_and_copy_relocs = TRUE;
      htab->is_vxworks = TRUE;
    }
  return ret;
}

/* A function that the linker calls if we are allowed to use PLTs
   and copy relocs.  */

void
_bfd_mips_elf_use_plts_and_copy_relocs (struct bfd_link_info *info)
{
  mips_elf_hash_table (info)->use_plts_and_copy_relocs = TRUE;
}

/* A function that the linker calls to select between all or only
   32-bit microMIPS instructions.  */

void
_bfd_mips_elf_insn32 (struct bfd_link_info *info, bfd_boolean on)
{
  mips_elf_hash_table (info)->insn32 = on;
}

/* We need to use a special link routine to handle the .reginfo and
   the .mdebug sections.  We need to merge all instances of these
   sections together, not write them all out sequentially.  */

bfd_boolean
_bfd_mips_elf_final_link (bfd *abfd, struct bfd_link_info *info)
{
  asection *o;
  struct bfd_link_order *p;
  asection *reginfo_sec, *mdebug_sec, *gptab_data_sec, *gptab_bss_sec;
  asection *rtproc_sec;
  Elf32_RegInfo reginfo;
  struct ecoff_debug_info debug;
  struct mips_htab_traverse_info hti;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  const struct ecoff_debug_swap *swap = bed->elf_backend_ecoff_debug_swap;
  HDRR *symhdr = &debug.symbolic_header;
  void *mdebug_handle = NULL;
  asection *s;
  EXTR esym;
  unsigned int i;
  bfd_size_type amt;
  struct mips_elf_link_hash_table *htab;

  static const char * const secname[] =
  {
    ".text", ".init", ".fini", ".data",
    ".rodata", ".sdata", ".sbss", ".bss"
  };
  static const int sc[] =
  {
    scText, scInit, scFini, scData,
    scRData, scSData, scSBss, scBss
  };

  /* Sort the dynamic symbols so that those with GOT entries come after
     those without.  */
  htab = mips_elf_hash_table (info);
  BFD_ASSERT (htab != NULL);

  if (!mips_elf_sort_hash_table (abfd, info))
    return FALSE;

  /* Create any scheduled LA25 stubs.  */
  hti.info = info;
  hti.output_bfd = abfd;
  hti.error = FALSE;
  htab_traverse (htab->la25_stubs, mips_elf_create_la25_stub, &hti);
  if (hti.error)
    return FALSE;

  /* Get a value for the GP register.  */
  if (elf_gp (abfd) == 0)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
      if (h != NULL && h->type == bfd_link_hash_defined)
	elf_gp (abfd) = (h->u.def.value
			 + h->u.def.section->output_section->vma
			 + h->u.def.section->output_offset);
      else if (htab->is_vxworks
	       && (h = bfd_link_hash_lookup (info->hash,
					     "_GLOBAL_OFFSET_TABLE_",
					     FALSE, FALSE, TRUE))
	       && h->type == bfd_link_hash_defined)
	elf_gp (abfd) = (h->u.def.section->output_section->vma
			 + h->u.def.section->output_offset
			 + h->u.def.value);
      else if (info->relocatable)
	{
	  bfd_vma lo = MINUS_ONE;

	  /* Find the GP-relative section with the lowest offset.  */
	  for (o = abfd->sections; o != NULL; o = o->next)
	    if (o->vma < lo
		&& (elf_section_data (o)->this_hdr.sh_flags & SHF_MIPS_GPREL))
	      lo = o->vma;

	  /* And calculate GP relative to that.  */
	  elf_gp (abfd) = lo + ELF_MIPS_GP_OFFSET (info);
	}
      else
	{
	  /* If the relocate_section function needs to do a reloc
	     involving the GP value, it should make a reloc_dangerous
	     callback to warn that GP is not defined.  */
	}
    }

  /* Go through the sections and collect the .reginfo and .mdebug
     information.  */
  reginfo_sec = NULL;
  mdebug_sec = NULL;
  gptab_data_sec = NULL;
  gptab_bss_sec = NULL;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (strcmp (o->name, ".reginfo") == 0)
	{
	  memset (&reginfo, 0, sizeof reginfo);

	  /* We have found the .reginfo section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  for (p = o->map_head.link_order; p != NULL; p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      Elf32_External_RegInfo ext;
	      Elf32_RegInfo sub;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_data_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      if (! bfd_get_section_contents (input_bfd, input_section,
					      &ext, 0, sizeof ext))
		return FALSE;

	      bfd_mips_elf32_swap_reginfo_in (input_bfd, &ext, &sub);

	      reginfo.ri_gprmask |= sub.ri_gprmask;
	      reginfo.ri_cprmask[0] |= sub.ri_cprmask[0];
	      reginfo.ri_cprmask[1] |= sub.ri_cprmask[1];
	      reginfo.ri_cprmask[2] |= sub.ri_cprmask[2];
	      reginfo.ri_cprmask[3] |= sub.ri_cprmask[3];

	      /* ri_gp_value is set by the function
		 mips_elf32_section_processing when the section is
		 finally written out.  */

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }

	  /* Size has been set in _bfd_mips_elf_always_size_sections.  */
	  BFD_ASSERT(o->size == sizeof (Elf32_External_RegInfo));

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->map_head.link_order = NULL;

	  reginfo_sec = o;
	}

      if (strcmp (o->name, ".mdebug") == 0)
	{
	  struct extsym_info einfo;
	  bfd_vma last;

	  /* We have found the .mdebug section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  symhdr->magic = swap->sym_magic;
	  /* FIXME: What should the version stamp be?  */
	  symhdr->vstamp = 0;
	  symhdr->ilineMax = 0;
	  symhdr->cbLine = 0;
	  symhdr->idnMax = 0;
	  symhdr->ipdMax = 0;
	  symhdr->isymMax = 0;
	  symhdr->ioptMax = 0;
	  symhdr->iauxMax = 0;
	  symhdr->issMax = 0;
	  symhdr->issExtMax = 0;
	  symhdr->ifdMax = 0;
	  symhdr->crfd = 0;
	  symhdr->iextMax = 0;

	  /* We accumulate the debugging information itself in the
	     debug_info structure.  */
	  debug.line = NULL;
	  debug.external_dnr = NULL;
	  debug.external_pdr = NULL;
	  debug.external_sym = NULL;
	  debug.external_opt = NULL;
	  debug.external_aux = NULL;
	  debug.ss = NULL;
	  debug.ssext = debug.ssext_end = NULL;
	  debug.external_fdr = NULL;
	  debug.external_rfd = NULL;
	  debug.external_ext = debug.external_ext_end = NULL;

	  mdebug_handle = bfd_ecoff_debug_init (abfd, &debug, swap, info);
	  if (mdebug_handle == NULL)
	    return FALSE;

	  esym.jmptbl = 0;
	  esym.cobol_main = 0;
	  esym.weakext = 0;
	  esym.reserved = 0;
	  esym.ifd = ifdNil;
	  esym.asym.iss = issNil;
	  esym.asym.st = stLocal;
	  esym.asym.reserved = 0;
	  esym.asym.index = indexNil;
	  last = 0;
	  for (i = 0; i < sizeof (secname) / sizeof (secname[0]); i++)
	    {
	      esym.asym.sc = sc[i];
	      s = bfd_get_section_by_name (abfd, secname[i]);
	      if (s != NULL)
		{
		  esym.asym.value = s->vma;
		  last = s->vma + s->size;
		}
	      else
		esym.asym.value = last;
	      if (!bfd_ecoff_debug_one_external (abfd, &debug, swap,
						 secname[i], &esym))
		return FALSE;
	    }

	  for (p = o->map_head.link_order; p != NULL; p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      const struct ecoff_debug_swap *input_swap;
	      struct ecoff_debug_info input_debug;
	      char *eraw_src;
	      char *eraw_end;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_data_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      if (!is_mips_elf (input_bfd))
		{
		  /* I don't know what a non MIPS ELF bfd would be
		     doing with a .mdebug section, but I don't really
		     want to deal with it.  */
		  continue;
		}

	      input_swap = (get_elf_backend_data (input_bfd)
			    ->elf_backend_ecoff_debug_swap);

	      BFD_ASSERT (p->size == input_section->size);

	      /* The ECOFF linking code expects that we have already
		 read in the debugging information and set up an
		 ecoff_debug_info structure, so we do that now.  */
	      if (! _bfd_mips_elf_read_ecoff_info (input_bfd, input_section,
						   &input_debug))
		return FALSE;

	      if (! (bfd_ecoff_debug_accumulate
		     (mdebug_handle, abfd, &debug, swap, input_bfd,
		      &input_debug, input_swap, info)))
		return FALSE;

	      /* Loop through the external symbols.  For each one with
		 interesting information, try to find the symbol in
		 the linker global hash table and save the information
		 for the output external symbols.  */
	      eraw_src = input_debug.external_ext;
	      eraw_end = (eraw_src
			  + (input_debug.symbolic_header.iextMax
			     * input_swap->external_ext_size));
	      for (;
		   eraw_src < eraw_end;
		   eraw_src += input_swap->external_ext_size)
		{
		  EXTR ext;
		  const char *name;
		  struct mips_elf_link_hash_entry *h;

		  (*input_swap->swap_ext_in) (input_bfd, eraw_src, &ext);
		  if (ext.asym.sc == scNil
		      || ext.asym.sc == scUndefined
		      || ext.asym.sc == scSUndefined)
		    continue;

		  name = input_debug.ssext + ext.asym.iss;
		  h = mips_elf_link_hash_lookup (mips_elf_hash_table (info),
						 name, FALSE, FALSE, TRUE);
		  if (h == NULL || h->esym.ifd != -2)
		    continue;

		  if (ext.ifd != -1)
		    {
		      BFD_ASSERT (ext.ifd
				  < input_debug.symbolic_header.ifdMax);
		      ext.ifd = input_debug.ifdmap[ext.ifd];
		    }

		  h->esym = ext;
		}

	      /* Free up the information we just read.  */
	      free (input_debug.line);
	      free (input_debug.external_dnr);
	      free (input_debug.external_pdr);
	      free (input_debug.external_sym);
	      free (input_debug.external_opt);
	      free (input_debug.external_aux);
	      free (input_debug.ss);
	      free (input_debug.ssext);
	      free (input_debug.external_fdr);
	      free (input_debug.external_rfd);
	      free (input_debug.external_ext);

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }

	  if (SGI_COMPAT (abfd) && info->shared)
	    {
	      /* Create .rtproc section.  */
	      rtproc_sec = bfd_get_linker_section (abfd, ".rtproc");
	      if (rtproc_sec == NULL)
		{
		  flagword flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED | SEC_READONLY);

		  rtproc_sec = bfd_make_section_anyway_with_flags (abfd,
								   ".rtproc",
								   flags);
		  if (rtproc_sec == NULL
		      || ! bfd_set_section_alignment (abfd, rtproc_sec, 4))
		    return FALSE;
		}

	      if (! mips_elf_create_procedure_table (mdebug_handle, abfd,
						     info, rtproc_sec,
						     &debug))
		return FALSE;
	    }

	  /* Build the external symbol information.  */
	  einfo.abfd = abfd;
	  einfo.info = info;
	  einfo.debug = &debug;
	  einfo.swap = swap;
	  einfo.failed = FALSE;
	  mips_elf_link_hash_traverse (mips_elf_hash_table (info),
				       mips_elf_output_extsym, &einfo);
	  if (einfo.failed)
	    return FALSE;

	  /* Set the size of the .mdebug section.  */
	  o->size = bfd_ecoff_debug_size (abfd, &debug, swap);

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->map_head.link_order = NULL;

	  mdebug_sec = o;
	}

      if (CONST_STRNEQ (o->name, ".gptab."))
	{
	  const char *subname;
	  unsigned int c;
	  Elf32_gptab *tab;
	  Elf32_External_gptab *ext_tab;
	  unsigned int j;

	  /* The .gptab.sdata and .gptab.sbss sections hold
	     information describing how the small data area would
	     change depending upon the -G switch.  These sections
	     not used in executables files.  */
	  if (! info->relocatable)
	    {
	      for (p = o->map_head.link_order; p != NULL; p = p->next)
		{
		  asection *input_section;

		  if (p->type != bfd_indirect_link_order)
		    {
		      if (p->type == bfd_data_link_order)
			continue;
		      abort ();
		    }

		  input_section = p->u.indirect.section;

		  /* Hack: reset the SEC_HAS_CONTENTS flag so that
		     elf_link_input_bfd ignores this section.  */
		  input_section->flags &= ~SEC_HAS_CONTENTS;
		}

	      /* Skip this section later on (I don't think this
		 currently matters, but someday it might).  */
	      o->map_head.link_order = NULL;

	      /* Really remove the section.  */
	      bfd_section_list_remove (abfd, o);
	      --abfd->section_count;

	      continue;
	    }

	  /* There is one gptab for initialized data, and one for
	     uninitialized data.  */
	  if (strcmp (o->name, ".gptab.sdata") == 0)
	    gptab_data_sec = o;
	  else if (strcmp (o->name, ".gptab.sbss") == 0)
	    gptab_bss_sec = o;
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: illegal section name `%s'"),
		 bfd_get_filename (abfd), o->name);
	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return FALSE;
	    }

	  /* The linker script always combines .gptab.data and
	     .gptab.sdata into .gptab.sdata, and likewise for
	     .gptab.bss and .gptab.sbss.  It is possible that there is
	     no .sdata or .sbss section in the output file, in which
	     case we must change the name of the output section.  */
	  subname = o->name + sizeof ".gptab" - 1;
	  if (bfd_get_section_by_name (abfd, subname) == NULL)
	    {
	      if (o == gptab_data_sec)
		o->name = ".gptab.data";
	      else
		o->name = ".gptab.bss";
	      subname = o->name + sizeof ".gptab" - 1;
	      BFD_ASSERT (bfd_get_section_by_name (abfd, subname) != NULL);
	    }

	  /* Set up the first entry.  */
	  c = 1;
	  amt = c * sizeof (Elf32_gptab);
	  tab = bfd_malloc (amt);
	  if (tab == NULL)
	    return FALSE;
	  tab[0].gt_header.gt_current_g_value = elf_gp_size (abfd);
	  tab[0].gt_header.gt_unused = 0;

	  /* Combine the input sections.  */
	  for (p = o->map_head.link_order; p != NULL; p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      bfd_size_type size;
	      unsigned long last;
	      bfd_size_type gpentry;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_data_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      /* Combine the gptab entries for this input section one
		 by one.  We know that the input gptab entries are
		 sorted by ascending -G value.  */
	      size = input_section->size;
	      last = 0;
	      for (gpentry = sizeof (Elf32_External_gptab);
		   gpentry < size;
		   gpentry += sizeof (Elf32_External_gptab))
		{
		  Elf32_External_gptab ext_gptab;
		  Elf32_gptab int_gptab;
		  unsigned long val;
		  unsigned long add;
		  bfd_boolean exact;
		  unsigned int look;

		  if (! (bfd_get_section_contents
			 (input_bfd, input_section, &ext_gptab, gpentry,
			  sizeof (Elf32_External_gptab))))
		    {
		      free (tab);
		      return FALSE;
		    }

		  bfd_mips_elf32_swap_gptab_in (input_bfd, &ext_gptab,
						&int_gptab);
		  val = int_gptab.gt_entry.gt_g_value;
		  add = int_gptab.gt_entry.gt_bytes - last;

		  exact = FALSE;
		  for (look = 1; look < c; look++)
		    {
		      if (tab[look].gt_entry.gt_g_value >= val)
			tab[look].gt_entry.gt_bytes += add;

		      if (tab[look].gt_entry.gt_g_value == val)
			exact = TRUE;
		    }

		  if (! exact)
		    {
		      Elf32_gptab *new_tab;
		      unsigned int max;

		      /* We need a new table entry.  */
		      amt = (bfd_size_type) (c + 1) * sizeof (Elf32_gptab);
		      new_tab = bfd_realloc (tab, amt);
		      if (new_tab == NULL)
			{
			  free (tab);
			  return FALSE;
			}
		      tab = new_tab;
		      tab[c].gt_entry.gt_g_value = val;
		      tab[c].gt_entry.gt_bytes = add;

		      /* Merge in the size for the next smallest -G
			 value, since that will be implied by this new
			 value.  */
		      max = 0;
		      for (look = 1; look < c; look++)
			{
			  if (tab[look].gt_entry.gt_g_value < val
			      && (max == 0
				  || (tab[look].gt_entry.gt_g_value
				      > tab[max].gt_entry.gt_g_value)))
			    max = look;
			}
		      if (max != 0)
			tab[c].gt_entry.gt_bytes +=
			  tab[max].gt_entry.gt_bytes;

		      ++c;
		    }

		  last = int_gptab.gt_entry.gt_bytes;
		}

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }

	  /* The table must be sorted by -G value.  */
	  if (c > 2)
	    qsort (tab + 1, c - 1, sizeof (tab[0]), gptab_compare);

	  /* Swap out the table.  */
	  amt = (bfd_size_type) c * sizeof (Elf32_External_gptab);
	  ext_tab = bfd_alloc (abfd, amt);
	  if (ext_tab == NULL)
	    {
	      free (tab);
	      return FALSE;
	    }

	  for (j = 0; j < c; j++)
	    bfd_mips_elf32_swap_gptab_out (abfd, tab + j, ext_tab + j);
	  free (tab);

	  o->size = c * sizeof (Elf32_External_gptab);
	  o->contents = (bfd_byte *) ext_tab;

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->map_head.link_order = NULL;
	}
    }

  /* Invoke the regular ELF backend linker to do all the work.  */
  if (!bfd_elf_final_link (abfd, info))
    return FALSE;

  /* Now write out the computed sections.  */

  if (reginfo_sec != NULL)
    {
      Elf32_External_RegInfo ext;

      bfd_mips_elf32_swap_reginfo_out (abfd, &reginfo, &ext);
      if (! bfd_set_section_contents (abfd, reginfo_sec, &ext, 0, sizeof ext))
	return FALSE;
    }

  if (mdebug_sec != NULL)
    {
      BFD_ASSERT (abfd->output_has_begun);
      if (! bfd_ecoff_write_accumulated_debug (mdebug_handle, abfd, &debug,
					       swap, info,
					       mdebug_sec->filepos))
	return FALSE;

      bfd_ecoff_debug_free (mdebug_handle, abfd, &debug, swap, info);
    }

  if (gptab_data_sec != NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_data_sec,
				      gptab_data_sec->contents,
				      0, gptab_data_sec->size))
	return FALSE;
    }

  if (gptab_bss_sec != NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_bss_sec,
				      gptab_bss_sec->contents,
				      0, gptab_bss_sec->size))
	return FALSE;
    }

  if (SGI_COMPAT (abfd))
    {
      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
      if (rtproc_sec != NULL)
	{
	  if (! bfd_set_section_contents (abfd, rtproc_sec,
					  rtproc_sec->contents,
					  0, rtproc_sec->size))
	    return FALSE;
	}
    }

  return TRUE;
}

/* Structure for saying that BFD machine EXTENSION extends BASE.  */

struct mips_mach_extension
{
  unsigned long extension, base;
};


/* An array describing how BFD machines relate to one another.  The entries
   are ordered topologically with MIPS I extensions listed last.  */

static const struct mips_mach_extension mips_mach_extensions[] =
{
  /* MIPS64r2 extensions.  */
  { bfd_mach_mips_octeon2, bfd_mach_mips_octeonp },
  { bfd_mach_mips_octeonp, bfd_mach_mips_octeon },
  { bfd_mach_mips_octeon, bfd_mach_mipsisa64r2 },

  /* MIPS64 extensions.  */
  { bfd_mach_mipsisa64r2, bfd_mach_mipsisa64 },
  { bfd_mach_mips_sb1, bfd_mach_mipsisa64 },
  { bfd_mach_mips_xlr, bfd_mach_mipsisa64 },
  { bfd_mach_mips_loongson_3a, bfd_mach_mipsisa64 },

  /* MIPS V extensions.  */
  { bfd_mach_mipsisa64, bfd_mach_mips5 },

  /* R10000 extensions.  */
  { bfd_mach_mips12000, bfd_mach_mips10000 },
  { bfd_mach_mips14000, bfd_mach_mips10000 },
  { bfd_mach_mips16000, bfd_mach_mips10000 },

  /* R5000 extensions.  Note: the vr5500 ISA is an extension of the core
     vr5400 ISA, but doesn't include the multimedia stuff.  It seems
     better to allow vr5400 and vr5500 code to be merged anyway, since
     many libraries will just use the core ISA.  Perhaps we could add
     some sort of ASE flag if this ever proves a problem.  */
  { bfd_mach_mips5500, bfd_mach_mips5400 },
  { bfd_mach_mips5400, bfd_mach_mips5000 },

  /* MIPS IV extensions.  */
  { bfd_mach_mips5, bfd_mach_mips8000 },
  { bfd_mach_mips10000, bfd_mach_mips8000 },
  { bfd_mach_mips5000, bfd_mach_mips8000 },
  { bfd_mach_mips7000, bfd_mach_mips8000 },
  { bfd_mach_mips9000, bfd_mach_mips8000 },

  /* VR4100 extensions.  */
  { bfd_mach_mips4120, bfd_mach_mips4100 },
  { bfd_mach_mips4111, bfd_mach_mips4100 },

  /* MIPS III extensions.  */
  { bfd_mach_mips_loongson_2e, bfd_mach_mips4000 },
  { bfd_mach_mips_loongson_2f, bfd_mach_mips4000 },
  { bfd_mach_mips8000, bfd_mach_mips4000 },
  { bfd_mach_mips4650, bfd_mach_mips4000 },
  { bfd_mach_mips4600, bfd_mach_mips4000 },
  { bfd_mach_mips4400, bfd_mach_mips4000 },
  { bfd_mach_mips4300, bfd_mach_mips4000 },
  { bfd_mach_mips4100, bfd_mach_mips4000 },
  { bfd_mach_mips4010, bfd_mach_mips4000 },
  { bfd_mach_mips5900, bfd_mach_mips4000 },

  /* MIPS32 extensions.  */
  { bfd_mach_mipsisa32r2, bfd_mach_mipsisa32 },

  /* MIPS II extensions.  */
  { bfd_mach_mips4000, bfd_mach_mips6000 },
  { bfd_mach_mipsisa32, bfd_mach_mips6000 },

  /* MIPS I extensions.  */
  { bfd_mach_mips6000, bfd_mach_mips3000 },
  { bfd_mach_mips3900, bfd_mach_mips3000 }
};


/* Return true if bfd machine EXTENSION is an extension of machine BASE.  */

static bfd_boolean
mips_mach_extends_p (unsigned long base, unsigned long extension)
{
  size_t i;

  if (extension == base)
    return TRUE;

  if (base == bfd_mach_mipsisa32
      && mips_mach_extends_p (bfd_mach_mipsisa64, extension))
    return TRUE;

  if (base == bfd_mach_mipsisa32r2
      && mips_mach_extends_p (bfd_mach_mipsisa64r2, extension))
    return TRUE;

  for (i = 0; i < ARRAY_SIZE (mips_mach_extensions); i++)
    if (extension == mips_mach_extensions[i].extension)
      {
	extension = mips_mach_extensions[i].base;
	if (extension == base)
	  return TRUE;
      }

  return FALSE;
}


/* Return true if the given ELF header flags describe a 32-bit binary.  */

static bfd_boolean
mips_32bit_flags_p (flagword flags)
{
  return ((flags & EF_MIPS_32BITMODE) != 0
	  || (flags & EF_MIPS_ABI) == E_MIPS_ABI_O32
	  || (flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI32
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_1
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_2
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32R2);
}


/* Merge object attributes from IBFD into OBFD.  Raise an error if
   there are conflicting attributes.  */
static bfd_boolean
mips_elf_merge_obj_attributes (bfd *ibfd, bfd *obfd)
{
  obj_attribute *in_attr;
  obj_attribute *out_attr;
  bfd *abi_fp_bfd;
  bfd *abi_msa_bfd;

  abi_fp_bfd = mips_elf_tdata (obfd)->abi_fp_bfd;
  in_attr = elf_known_obj_attributes (ibfd)[OBJ_ATTR_GNU];
  if (!abi_fp_bfd && in_attr[Tag_GNU_MIPS_ABI_FP].i != Val_GNU_MIPS_ABI_FP_ANY)
    mips_elf_tdata (obfd)->abi_fp_bfd = ibfd;

  abi_msa_bfd = mips_elf_tdata (obfd)->abi_msa_bfd;
  if (!abi_msa_bfd
      && in_attr[Tag_GNU_MIPS_ABI_MSA].i != Val_GNU_MIPS_ABI_MSA_ANY)
    mips_elf_tdata (obfd)->abi_msa_bfd = ibfd;

  if (!elf_known_obj_attributes_proc (obfd)[0].i)
    {
      /* This is the first object.  Copy the attributes.  */
      _bfd_elf_copy_obj_attributes (ibfd, obfd);

      /* Use the Tag_null value to indicate the attributes have been
	 initialized.  */
      elf_known_obj_attributes_proc (obfd)[0].i = 1;

      return TRUE;
    }

  /* Check for conflicting Tag_GNU_MIPS_ABI_FP attributes and merge
     non-conflicting ones.  */
  out_attr = elf_known_obj_attributes (obfd)[OBJ_ATTR_GNU];
  if (in_attr[Tag_GNU_MIPS_ABI_FP].i != out_attr[Tag_GNU_MIPS_ABI_FP].i)
    {
      out_attr[Tag_GNU_MIPS_ABI_FP].type = 1;
      if (out_attr[Tag_GNU_MIPS_ABI_FP].i == Val_GNU_MIPS_ABI_FP_ANY)
	out_attr[Tag_GNU_MIPS_ABI_FP].i = in_attr[Tag_GNU_MIPS_ABI_FP].i;
      else if (in_attr[Tag_GNU_MIPS_ABI_FP].i != Val_GNU_MIPS_ABI_FP_ANY)
	switch (out_attr[Tag_GNU_MIPS_ABI_FP].i)
	  {
	  case Val_GNU_MIPS_ABI_FP_DOUBLE:
	    switch (in_attr[Tag_GNU_MIPS_ABI_FP].i)
	      {
	      case Val_GNU_MIPS_ABI_FP_SINGLE:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd, "-mdouble-float", "-msingle-float");
		break;

	      case Val_GNU_MIPS_ABI_FP_SOFT:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd, "-mhard-float", "-msoft-float");
		break;

	      case Val_GNU_MIPS_ABI_FP_64:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd,
		   "-mdouble-float", "-mips32r2 -mfp64");
		break;

	      default:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), "
		     "%B uses unknown floating point ABI %d"),
		   obfd, abi_fp_bfd, ibfd,
		   "-mdouble-float", in_attr[Tag_GNU_MIPS_ABI_FP].i);
		break;
	      }
	    break;

	  case Val_GNU_MIPS_ABI_FP_SINGLE:
	    switch (in_attr[Tag_GNU_MIPS_ABI_FP].i)
	      {
	      case Val_GNU_MIPS_ABI_FP_DOUBLE:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd, "-msingle-float", "-mdouble-float");
		break;

	      case Val_GNU_MIPS_ABI_FP_SOFT:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd, "-mhard-float", "-msoft-float");
		break;

	      case Val_GNU_MIPS_ABI_FP_64:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd,
		   "-msingle-float", "-mips32r2 -mfp64");
		break;

	      default:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), "
		     "%B uses unknown floating point ABI %d"),
		   obfd, abi_fp_bfd, ibfd,
		   "-msingle-float", in_attr[Tag_GNU_MIPS_ABI_FP].i);
		break;
	      }
	    break;

	  case Val_GNU_MIPS_ABI_FP_SOFT:
	    switch (in_attr[Tag_GNU_MIPS_ABI_FP].i)
	      {
	      case Val_GNU_MIPS_ABI_FP_DOUBLE:
	      case Val_GNU_MIPS_ABI_FP_SINGLE:
	      case Val_GNU_MIPS_ABI_FP_64:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd, "-msoft-float", "-mhard-float");
		break;

	      default:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), "
		     "%B uses unknown floating point ABI %d"),
		   obfd, abi_fp_bfd, ibfd,
		   "-msoft-float", in_attr[Tag_GNU_MIPS_ABI_FP].i);
		break;
	      }
	    break;

	  case Val_GNU_MIPS_ABI_FP_64:
	    switch (in_attr[Tag_GNU_MIPS_ABI_FP].i)
	      {
	      case Val_GNU_MIPS_ABI_FP_DOUBLE:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd,
		   "-mips32r2 -mfp64", "-mdouble-float");
		break;

	      case Val_GNU_MIPS_ABI_FP_SINGLE:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd,
		   "-mips32r2 -mfp64", "-msingle-float");
		break;

	      case Val_GNU_MIPS_ABI_FP_SOFT:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd, "-mhard-float", "-msoft-float");
		break;

	      default:
		_bfd_error_handler
		  (_("Warning: %B uses %s (set by %B), "
		     "%B uses unknown floating point ABI %d"),
		   obfd, abi_fp_bfd, ibfd,
		   "-mips32r2 -mfp64", in_attr[Tag_GNU_MIPS_ABI_FP].i);
		break;
	      }
	    break;

	  default:
	    switch (in_attr[Tag_GNU_MIPS_ABI_FP].i)
	      {
	      case Val_GNU_MIPS_ABI_FP_DOUBLE:
		_bfd_error_handler
		  (_("Warning: %B uses unknown floating point ABI %d "
		     "(set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd,
		   out_attr[Tag_GNU_MIPS_ABI_FP].i, "-mdouble-float");
		break;

	      case Val_GNU_MIPS_ABI_FP_SINGLE:
		_bfd_error_handler
		  (_("Warning: %B uses unknown floating point ABI %d "
		     "(set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd,
		   out_attr[Tag_GNU_MIPS_ABI_FP].i, "-msingle-float");
		break;

	      case Val_GNU_MIPS_ABI_FP_SOFT:
		_bfd_error_handler
		  (_("Warning: %B uses unknown floating point ABI %d "
		     "(set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd,
		   out_attr[Tag_GNU_MIPS_ABI_FP].i, "-msoft-float");
		break;

	      case Val_GNU_MIPS_ABI_FP_64:
		_bfd_error_handler
		  (_("Warning: %B uses unknown floating point ABI %d "
		     "(set by %B), %B uses %s"),
		   obfd, abi_fp_bfd, ibfd,
		   out_attr[Tag_GNU_MIPS_ABI_FP].i, "-mips32r2 -mfp64");
		break;

	      default:
		_bfd_error_handler
		  (_("Warning: %B uses unknown floating point ABI %d "
		     "(set by %B), %B uses unknown floating point ABI %d"),
		   obfd, abi_fp_bfd, ibfd,
		   out_attr[Tag_GNU_MIPS_ABI_FP].i,
		   in_attr[Tag_GNU_MIPS_ABI_FP].i);
		break;
	      }
	    break;
	  }
    }

  /* Check for conflicting Tag_GNU_MIPS_ABI_MSA attributes and merge
     non-conflicting ones.  */
  if (in_attr[Tag_GNU_MIPS_ABI_MSA].i != out_attr[Tag_GNU_MIPS_ABI_MSA].i)
    {
      out_attr[Tag_GNU_MIPS_ABI_MSA].type = 1;
      if (out_attr[Tag_GNU_MIPS_ABI_MSA].i == Val_GNU_MIPS_ABI_MSA_ANY)
	out_attr[Tag_GNU_MIPS_ABI_MSA].i = in_attr[Tag_GNU_MIPS_ABI_MSA].i;
      else if (in_attr[Tag_GNU_MIPS_ABI_MSA].i != Val_GNU_MIPS_ABI_MSA_ANY)
	switch (out_attr[Tag_GNU_MIPS_ABI_MSA].i)
	  {
	  case Val_GNU_MIPS_ABI_MSA_128:
	    _bfd_error_handler
	      (_("Warning: %B uses %s (set by %B), "
		 "%B uses unknown MSA ABI %d"),
	       obfd, abi_msa_bfd, ibfd,
	       "-mmsa", in_attr[Tag_GNU_MIPS_ABI_MSA].i);
	    break;

	  default:
	    switch (in_attr[Tag_GNU_MIPS_ABI_MSA].i)
	      {
	      case Val_GNU_MIPS_ABI_MSA_128:
		_bfd_error_handler
		  (_("Warning: %B uses unknown MSA ABI %d "
		     "(set by %B), %B uses %s"),
		     obfd, abi_msa_bfd, ibfd,
		     out_attr[Tag_GNU_MIPS_ABI_MSA].i, "-mmsa");
		  break;

	      default:
		_bfd_error_handler
		  (_("Warning: %B uses unknown MSA ABI %d "
		     "(set by %B), %B uses unknown MSA ABI %d"),
		   obfd, abi_msa_bfd, ibfd,
		   out_attr[Tag_GNU_MIPS_ABI_MSA].i,
		   in_attr[Tag_GNU_MIPS_ABI_MSA].i);
		break;
	      }
	  }
    }

  /* Merge Tag_compatibility attributes and any common GNU ones.  */
  _bfd_elf_merge_object_attributes (ibfd, obfd);

  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

bfd_boolean
_bfd_mips_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword old_flags;
  flagword new_flags;
  bfd_boolean ok;
  bfd_boolean null_input_bfd = TRUE;
  asection *sec;

  /* Check if we have the same endianness.  */
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    {
      (*_bfd_error_handler)
	(_("%B: endianness incompatible with that of the selected emulation"),
	 ibfd);
      return FALSE;
    }

  if (!is_mips_elf (ibfd) || !is_mips_elf (obfd))
    return TRUE;

  if (strcmp (bfd_get_target (ibfd), bfd_get_target (obfd)) != 0)
    {
      (*_bfd_error_handler)
	(_("%B: ABI is incompatible with that of the selected emulation"),
	 ibfd);
      return FALSE;
    }

  if (!mips_elf_merge_obj_attributes (ibfd, obfd))
    return FALSE;

  new_flags = elf_elfheader (ibfd)->e_flags;
  elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_NOREORDER;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = new_flags;
      elf_elfheader (obfd)->e_ident[EI_CLASS]
	= elf_elfheader (ibfd)->e_ident[EI_CLASS];

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && (bfd_get_arch_info (obfd)->the_default
	      || mips_mach_extends_p (bfd_get_mach (obfd),
				      bfd_get_mach (ibfd))))
	{
	  if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				   bfd_get_mach (ibfd)))
	    return FALSE;
	}

      return TRUE;
    }

  /* Check flag compatibility.  */

  new_flags &= ~EF_MIPS_NOREORDER;
  old_flags &= ~EF_MIPS_NOREORDER;

  /* Some IRIX 6 BSD-compatibility objects have this bit set.  It
     doesn't seem to matter.  */
  new_flags &= ~EF_MIPS_XGOT;
  old_flags &= ~EF_MIPS_XGOT;

  /* MIPSpro generates ucode info in n64 objects.  Again, we should
     just be able to ignore this.  */
  new_flags &= ~EF_MIPS_UCODE;
  old_flags &= ~EF_MIPS_UCODE;

  /* DSOs should only be linked with CPIC code.  */
  if ((ibfd->flags & DYNAMIC) != 0)
    new_flags |= EF_MIPS_PIC | EF_MIPS_CPIC;

  if (new_flags == old_flags)
    return TRUE;

  /* Check to see if the input BFD actually contains any sections.
     If not, its flags may not have been initialised either, but it cannot
     actually cause any incompatibility.  */
  for (sec = ibfd->sections; sec != NULL; sec = sec->next)
    {
      /* Ignore synthetic sections and empty .text, .data and .bss sections
	 which are automatically generated by gas.  Also ignore fake
	 (s)common sections, since merely defining a common symbol does
	 not affect compatibility.  */
      if ((sec->flags & SEC_IS_COMMON) == 0
	  && strcmp (sec->name, ".reginfo")
	  && strcmp (sec->name, ".mdebug")
	  && (sec->size != 0
	      || (strcmp (sec->name, ".text")
		  && strcmp (sec->name, ".data")
		  && strcmp (sec->name, ".bss"))))
	{
	  null_input_bfd = FALSE;
	  break;
	}
    }
  if (null_input_bfd)
    return TRUE;

  ok = TRUE;

  if (((new_flags & (EF_MIPS_PIC | EF_MIPS_CPIC)) != 0)
      != ((old_flags & (EF_MIPS_PIC | EF_MIPS_CPIC)) != 0))
    {
      (*_bfd_error_handler)
	(_("%B: warning: linking abicalls files with non-abicalls files"),
	 ibfd);
      ok = TRUE;
    }

  if (new_flags & (EF_MIPS_PIC | EF_MIPS_CPIC))
    elf_elfheader (obfd)->e_flags |= EF_MIPS_CPIC;
  if (! (new_flags & EF_MIPS_PIC))
    elf_elfheader (obfd)->e_flags &= ~EF_MIPS_PIC;

  new_flags &= ~ (EF_MIPS_PIC | EF_MIPS_CPIC);
  old_flags &= ~ (EF_MIPS_PIC | EF_MIPS_CPIC);

  /* Compare the ISAs.  */
  if (mips_32bit_flags_p (old_flags) != mips_32bit_flags_p (new_flags))
    {
      (*_bfd_error_handler)
	(_("%B: linking 32-bit code with 64-bit code"),
	 ibfd);
      ok = FALSE;
    }
  else if (!mips_mach_extends_p (bfd_get_mach (ibfd), bfd_get_mach (obfd)))
    {
      /* OBFD's ISA isn't the same as, or an extension of, IBFD's.  */
      if (mips_mach_extends_p (bfd_get_mach (obfd), bfd_get_mach (ibfd)))
	{
	  /* Copy the architecture info from IBFD to OBFD.  Also copy
	     the 32-bit flag (if set) so that we continue to recognise
	     OBFD as a 32-bit binary.  */
	  bfd_set_arch_info (obfd, bfd_get_arch_info (ibfd));
	  elf_elfheader (obfd)->e_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
	  elf_elfheader (obfd)->e_flags
	    |= new_flags & (EF_MIPS_ARCH | EF_MIPS_MACH | EF_MIPS_32BITMODE);

	  /* Copy across the ABI flags if OBFD doesn't use them
	     and if that was what caused us to treat IBFD as 32-bit.  */
	  if ((old_flags & EF_MIPS_ABI) == 0
	      && mips_32bit_flags_p (new_flags)
	      && !mips_32bit_flags_p (new_flags & ~EF_MIPS_ABI))
	    elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_ABI;
	}
      else
	{
	  /* The ISAs aren't compatible.  */
	  (*_bfd_error_handler)
	    (_("%B: linking %s module with previous %s modules"),
	     ibfd,
	     bfd_printable_name (ibfd),
	     bfd_printable_name (obfd));
	  ok = FALSE;
	}
    }

  new_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH | EF_MIPS_32BITMODE);
  old_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH | EF_MIPS_32BITMODE);

  /* Compare ABIs.  The 64-bit ABI does not use EF_MIPS_ABI.  But, it
     does set EI_CLASS differently from any 32-bit ABI.  */
  if ((new_flags & EF_MIPS_ABI) != (old_flags & EF_MIPS_ABI)
      || (elf_elfheader (ibfd)->e_ident[EI_CLASS]
	  != elf_elfheader (obfd)->e_ident[EI_CLASS]))
    {
      /* Only error if both are set (to different values).  */
      if (((new_flags & EF_MIPS_ABI) && (old_flags & EF_MIPS_ABI))
	  || (elf_elfheader (ibfd)->e_ident[EI_CLASS]
	      != elf_elfheader (obfd)->e_ident[EI_CLASS]))
	{
	  (*_bfd_error_handler)
	    (_("%B: ABI mismatch: linking %s module with previous %s modules"),
	     ibfd,
	     elf_mips_abi_name (ibfd),
	     elf_mips_abi_name (obfd));
	  ok = FALSE;
	}
      new_flags &= ~EF_MIPS_ABI;
      old_flags &= ~EF_MIPS_ABI;
    }

  /* Compare ASEs.  Forbid linking MIPS16 and microMIPS ASE modules together
     and allow arbitrary mixing of the remaining ASEs (retain the union).  */
  if ((new_flags & EF_MIPS_ARCH_ASE) != (old_flags & EF_MIPS_ARCH_ASE))
    {
      int old_micro = old_flags & EF_MIPS_ARCH_ASE_MICROMIPS;
      int new_micro = new_flags & EF_MIPS_ARCH_ASE_MICROMIPS;
      int old_m16 = old_flags & EF_MIPS_ARCH_ASE_M16;
      int new_m16 = new_flags & EF_MIPS_ARCH_ASE_M16;
      int micro_mis = old_m16 && new_micro;
      int m16_mis = old_micro && new_m16;

      if (m16_mis || micro_mis)
	{
	  (*_bfd_error_handler)
	    (_("%B: ASE mismatch: linking %s module with previous %s modules"),
	     ibfd,
	     m16_mis ? "MIPS16" : "microMIPS",
	     m16_mis ? "microMIPS" : "MIPS16");
	  ok = FALSE;
	}

      elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_ARCH_ASE;

      new_flags &= ~ EF_MIPS_ARCH_ASE;
      old_flags &= ~ EF_MIPS_ARCH_ASE;
    }

  /* Compare NaN encodings.  */
  if ((new_flags & EF_MIPS_NAN2008) != (old_flags & EF_MIPS_NAN2008))
    {
      _bfd_error_handler (_("%B: linking %s module with previous %s modules"),
			  ibfd,
			  (new_flags & EF_MIPS_NAN2008
			   ? "-mnan=2008" : "-mnan=legacy"),
			  (old_flags & EF_MIPS_NAN2008
			   ? "-mnan=2008" : "-mnan=legacy"));
      ok = FALSE;
      new_flags &= ~EF_MIPS_NAN2008;
      old_flags &= ~EF_MIPS_NAN2008;
    }

  /* Warn about any other mismatches */
  if (new_flags != old_flags)
    {
      (*_bfd_error_handler)
	(_("%B: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	 ibfd, (unsigned long) new_flags,
	 (unsigned long) old_flags);
      ok = FALSE;
    }

  if (! ok)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  return TRUE;
}

/* Function to keep MIPS specific file flags like as EF_MIPS_PIC.  */

bfd_boolean
_bfd_mips_elf_set_private_flags (bfd *abfd, flagword flags)
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

char *
_bfd_mips_elf_get_target_dtag (bfd_vma dtag)
{
  switch (dtag)
    {
    default: return "";
    case DT_MIPS_RLD_VERSION:
      return "MIPS_RLD_VERSION";
    case DT_MIPS_TIME_STAMP:
      return "MIPS_TIME_STAMP";
    case DT_MIPS_ICHECKSUM:
      return "MIPS_ICHECKSUM";
    case DT_MIPS_IVERSION:
      return "MIPS_IVERSION";
    case DT_MIPS_FLAGS:
      return "MIPS_FLAGS";
    case DT_MIPS_BASE_ADDRESS:
      return "MIPS_BASE_ADDRESS";
    case DT_MIPS_MSYM:
      return "MIPS_MSYM";
    case DT_MIPS_CONFLICT:
      return "MIPS_CONFLICT";
    case DT_MIPS_LIBLIST:
      return "MIPS_LIBLIST";
    case DT_MIPS_LOCAL_GOTNO:
      return "MIPS_LOCAL_GOTNO";
    case DT_MIPS_CONFLICTNO:
      return "MIPS_CONFLICTNO";
    case DT_MIPS_LIBLISTNO:
      return "MIPS_LIBLISTNO";
    case DT_MIPS_SYMTABNO:
      return "MIPS_SYMTABNO";
    case DT_MIPS_UNREFEXTNO:
      return "MIPS_UNREFEXTNO";
    case DT_MIPS_GOTSYM:
      return "MIPS_GOTSYM";
    case DT_MIPS_HIPAGENO:
      return "MIPS_HIPAGENO";
    case DT_MIPS_RLD_MAP:
      return "MIPS_RLD_MAP";
    case DT_MIPS_DELTA_CLASS:
      return "MIPS_DELTA_CLASS";
    case DT_MIPS_DELTA_CLASS_NO:
      return "MIPS_DELTA_CLASS_NO";
    case DT_MIPS_DELTA_INSTANCE:
      return "MIPS_DELTA_INSTANCE";
    case DT_MIPS_DELTA_INSTANCE_NO:
      return "MIPS_DELTA_INSTANCE_NO";
    case DT_MIPS_DELTA_RELOC:
      return "MIPS_DELTA_RELOC";
    case DT_MIPS_DELTA_RELOC_NO:
      return "MIPS_DELTA_RELOC_NO";
    case DT_MIPS_DELTA_SYM:
      return "MIPS_DELTA_SYM";
    case DT_MIPS_DELTA_SYM_NO:
      return "MIPS_DELTA_SYM_NO";
    case DT_MIPS_DELTA_CLASSSYM:
      return "MIPS_DELTA_CLASSSYM";
    case DT_MIPS_DELTA_CLASSSYM_NO:
      return "MIPS_DELTA_CLASSSYM_NO";
    case DT_MIPS_CXX_FLAGS:
      return "MIPS_CXX_FLAGS";
    case DT_MIPS_PIXIE_INIT:
      return "MIPS_PIXIE_INIT";
    case DT_MIPS_SYMBOL_LIB:
      return "MIPS_SYMBOL_LIB";
    case DT_MIPS_LOCALPAGE_GOTIDX:
      return "MIPS_LOCALPAGE_GOTIDX";
    case DT_MIPS_LOCAL_GOTIDX:
      return "MIPS_LOCAL_GOTIDX";
    case DT_MIPS_HIDDEN_GOTIDX:
      return "MIPS_HIDDEN_GOTIDX";
    case DT_MIPS_PROTECTED_GOTIDX:
      return "MIPS_PROTECTED_GOT_IDX";
    case DT_MIPS_OPTIONS:
      return "MIPS_OPTIONS";
    case DT_MIPS_INTERFACE:
      return "MIPS_INTERFACE";
    case DT_MIPS_DYNSTR_ALIGN:
      return "DT_MIPS_DYNSTR_ALIGN";
    case DT_MIPS_INTERFACE_SIZE:
      return "DT_MIPS_INTERFACE_SIZE";
    case DT_MIPS_RLD_TEXT_RESOLVE_ADDR:
      return "DT_MIPS_RLD_TEXT_RESOLVE_ADDR";
    case DT_MIPS_PERF_SUFFIX:
      return "DT_MIPS_PERF_SUFFIX";
    case DT_MIPS_COMPACT_SIZE:
      return "DT_MIPS_COMPACT_SIZE";
    case DT_MIPS_GP_VALUE:
      return "DT_MIPS_GP_VALUE";
    case DT_MIPS_AUX_DYNAMIC:
      return "DT_MIPS_AUX_DYNAMIC";
    case DT_MIPS_PLTGOT:
      return "DT_MIPS_PLTGOT";
    case DT_MIPS_RWPLT:
      return "DT_MIPS_RWPLT";
    }
}

bfd_boolean
_bfd_mips_elf_print_private_bfd_data (bfd *abfd, void *ptr)
{
  FILE *file = ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_O32)
    fprintf (file, _(" [abi=O32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_O64)
    fprintf (file, _(" [abi=O64]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI32)
    fprintf (file, _(" [abi=EABI32]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64)
    fprintf (file, _(" [abi=EABI64]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ABI))
    fprintf (file, _(" [abi unknown]"));
  else if (ABI_N32_P (abfd))
    fprintf (file, _(" [abi=N32]"));
  else if (ABI_64_P (abfd))
    fprintf (file, _(" [abi=64]"));
  else
    fprintf (file, _(" [no abi set]"));

  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_1)
    fprintf (file, " [mips1]");
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_2)
    fprintf (file, " [mips2]");
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_3)
    fprintf (file, " [mips3]");
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_4)
    fprintf (file, " [mips4]");
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_5)
    fprintf (file, " [mips5]");
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32)
    fprintf (file, " [mips32]");
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_64)
    fprintf (file, " [mips64]");
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32R2)
    fprintf (file, " [mips32r2]");
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_64R2)
    fprintf (file, " [mips64r2]");
  else
    fprintf (file, _(" [unknown ISA]"));

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH_ASE_MDMX)
    fprintf (file, " [mdmx]");

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH_ASE_M16)
    fprintf (file, " [mips16]");

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH_ASE_MICROMIPS)
    fprintf (file, " [micromips]");

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_NAN2008)
    fprintf (file, " [nan2008]");

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_FP64)
    fprintf (file, " [fp64]");

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_32BITMODE)
    fprintf (file, " [32bitmode]");
  else
    fprintf (file, _(" [not 32bitmode]"));

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_NOREORDER)
    fprintf (file, " [noreorder]");

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_PIC)
    fprintf (file, " [PIC]");

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_CPIC)
    fprintf (file, " [CPIC]");

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_XGOT)
    fprintf (file, " [XGOT]");

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_UCODE)
    fprintf (file, " [UCODE]");

  fputc ('\n', file);

  return TRUE;
}

const struct bfd_elf_special_section _bfd_mips_elf_special_sections[] =
{
  { STRING_COMMA_LEN (".lit4"),   0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { STRING_COMMA_LEN (".lit8"),   0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { STRING_COMMA_LEN (".mdebug"), 0, SHT_MIPS_DEBUG, 0 },
  { STRING_COMMA_LEN (".sbss"),  -2, SHT_NOBITS,     SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { STRING_COMMA_LEN (".sdata"), -2, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { STRING_COMMA_LEN (".ucode"),  0, SHT_MIPS_UCODE, 0 },
  { NULL,                     0,  0, 0,              0 }
};

/* Merge non visibility st_other attributes.  Ensure that the
   STO_OPTIONAL flag is copied into h->other, even if this is not a
   definiton of the symbol.  */
void
_bfd_mips_elf_merge_symbol_attribute (struct elf_link_hash_entry *h,
				      const Elf_Internal_Sym *isym,
				      bfd_boolean definition,
				      bfd_boolean dynamic ATTRIBUTE_UNUSED)
{
  if ((isym->st_other & ~ELF_ST_VISIBILITY (-1)) != 0)
    {
      unsigned char other;

      other = (definition ? isym->st_other : h->other);
      other &= ~ELF_ST_VISIBILITY (-1);
      h->other = other | ELF_ST_VISIBILITY (h->other);
    }

  if (!definition
      && ELF_MIPS_IS_OPTIONAL (isym->st_other))
    h->other |= STO_OPTIONAL;
}

/* Decide whether an undefined symbol is special and can be ignored.
   This is the case for OPTIONAL symbols on IRIX.  */
bfd_boolean
_bfd_mips_elf_ignore_undef_symbol (struct elf_link_hash_entry *h)
{
  return ELF_MIPS_IS_OPTIONAL (h->other) ? TRUE : FALSE;
}

bfd_boolean
_bfd_mips_elf_common_definition (Elf_Internal_Sym *sym)
{
  return (sym->st_shndx == SHN_COMMON
	  || sym->st_shndx == SHN_MIPS_ACOMMON
	  || sym->st_shndx == SHN_MIPS_SCOMMON);
}

/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

bfd_vma
_bfd_mips_elf_plt_sym_val (bfd_vma i, const asection *plt,
			   const arelent *rel ATTRIBUTE_UNUSED)
{
  return (plt->vma
	  + 4 * ARRAY_SIZE (mips_o32_exec_plt0_entry)
	  + i * 4 * ARRAY_SIZE (mips_exec_plt_entry));
}

/* Build a table of synthetic symbols to represent the PLT.  As with MIPS16
   and microMIPS PLT slots we may have a many-to-one mapping between .plt
   and .got.plt and also the slots may be of a different size each we walk
   the PLT manually fetching instructions and matching them against known
   patterns.  To make things easier standard MIPS slots, if any, always come
   first.  As we don't create proper ELF symbols we use the UDATA.I member
   of ASYMBOL to carry ISA annotation.  The encoding used is the same as
   with the ST_OTHER member of the ELF symbol.  */

long
_bfd_mips_elf_get_synthetic_symtab (bfd *abfd,
				    long symcount ATTRIBUTE_UNUSED,
				    asymbol **syms ATTRIBUTE_UNUSED,
				    long dynsymcount, asymbol **dynsyms,
				    asymbol **ret)
{
  static const char pltname[] = "_PROCEDURE_LINKAGE_TABLE_";
  static const char microsuffix[] = "@@micromipsplt";
  static const char m16suffix[] = "@@mips16plt";
  static const char mipssuffix[] = "@@plt";

  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_boolean micromips_p = MICROMIPS_P (abfd);
  Elf_Internal_Shdr *hdr;
  bfd_byte *plt_data;
  bfd_vma plt_offset;
  unsigned int other;
  bfd_vma entry_size;
  bfd_vma plt0_size;
  asection *relplt;
  bfd_vma opcode;
  asection *plt;
  asymbol *send;
  size_t size;
  char *names;
  long counti;
  arelent *p;
  asymbol *s;
  char *nend;
  long count;
  long pi;
  long i;
  long n;

  *ret = NULL;

  if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0 || dynsymcount <= 0)
    return 0;

  relplt = bfd_get_section_by_name (abfd, ".rel.plt");
  if (relplt == NULL)
    return 0;

  hdr = &elf_section_data (relplt)->this_hdr;
  if (hdr->sh_link != elf_dynsymtab (abfd) || hdr->sh_type != SHT_REL)
    return 0;

  plt = bfd_get_section_by_name (abfd, ".plt");
  if (plt == NULL)
    return 0;

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  if (!(*slurp_relocs) (abfd, relplt, dynsyms, TRUE))
    return -1;
  p = relplt->relocation;

  /* Calculating the exact amount of space required for symbols would
     require two passes over the PLT, so just pessimise assuming two
     PLT slots per relocation.  */
  count = relplt->size / hdr->sh_entsize;
  counti = count * bed->s->int_rels_per_ext_rel;
  size = 2 * count * sizeof (asymbol);
  size += count * (sizeof (mipssuffix) +
		   (micromips_p ? sizeof (microsuffix) : sizeof (m16suffix)));
  for (pi = 0; pi < counti; pi += bed->s->int_rels_per_ext_rel)
    size += 2 * strlen ((*p[pi].sym_ptr_ptr)->name);

  /* Add the size of "_PROCEDURE_LINKAGE_TABLE_" too.  */
  size += sizeof (asymbol) + sizeof (pltname);

  if (!bfd_malloc_and_get_section (abfd, plt, &plt_data))
    return -1;

  if (plt->size < 16)
    return -1;

  s = *ret = bfd_malloc (size);
  if (s == NULL)
    return -1;
  send = s + 2 * count + 1;

  names = (char *) send;
  nend = (char *) s + size;
  n = 0;

  opcode = bfd_get_micromips_32 (abfd, plt_data + 12);
  if (opcode == 0x3302fffe)
    {
      if (!micromips_p)
	return -1;
      plt0_size = 2 * ARRAY_SIZE (micromips_o32_exec_plt0_entry);
      other = STO_MICROMIPS;
    }
  else if (opcode == 0x0398c1d0)
    {
      if (!micromips_p)
	return -1;
      plt0_size = 2 * ARRAY_SIZE (micromips_insn32_o32_exec_plt0_entry);
      other = STO_MICROMIPS;
    }
  else
    {
      plt0_size = 4 * ARRAY_SIZE (mips_o32_exec_plt0_entry);
      other = 0;
    }

  s->the_bfd = abfd;
  s->flags = BSF_SYNTHETIC | BSF_FUNCTION | BSF_LOCAL;
  s->section = plt;
  s->value = 0;
  s->name = names;
  s->udata.i = other;
  memcpy (names, pltname, sizeof (pltname));
  names += sizeof (pltname);
  ++s, ++n;

  pi = 0;
  for (plt_offset = plt0_size;
       plt_offset + 8 <= plt->size && s < send;
       plt_offset += entry_size)
    {
      bfd_vma gotplt_addr;
      const char *suffix;
      bfd_vma gotplt_hi;
      bfd_vma gotplt_lo;
      size_t suffixlen;

      opcode = bfd_get_micromips_32 (abfd, plt_data + plt_offset + 4);

      /* Check if the second word matches the expected MIPS16 instruction.  */
      if (opcode == 0x651aeb00)
	{
	  if (micromips_p)
	    return -1;
	  /* Truncated table???  */
	  if (plt_offset + 16 > plt->size)
	    break;
	  gotplt_addr = bfd_get_32 (abfd, plt_data + plt_offset + 12);
	  entry_size = 2 * ARRAY_SIZE (mips16_o32_exec_plt_entry);
	  suffixlen = sizeof (m16suffix);
	  suffix = m16suffix;
	  other = STO_MIPS16;
	}
      /* Likewise the expected microMIPS instruction (no insn32 mode).  */
      else if (opcode == 0xff220000)
	{
	  if (!micromips_p)
	    return -1;
	  gotplt_hi = bfd_get_16 (abfd, plt_data + plt_offset) & 0x7f;
	  gotplt_lo = bfd_get_16 (abfd, plt_data + plt_offset + 2) & 0xffff;
	  gotplt_hi = ((gotplt_hi ^ 0x40) - 0x40) << 18;
	  gotplt_lo <<= 2;
	  gotplt_addr = gotplt_hi + gotplt_lo;
	  gotplt_addr += ((plt->vma + plt_offset) | 3) ^ 3;
	  entry_size = 2 * ARRAY_SIZE (micromips_o32_exec_plt_entry);
	  suffixlen = sizeof (microsuffix);
	  suffix = microsuffix;
	  other = STO_MICROMIPS;
	}
      /* Likewise the expected microMIPS instruction (insn32 mode).  */
      else if ((opcode & 0xffff0000) == 0xff2f0000)
	{
	  gotplt_hi = bfd_get_16 (abfd, plt_data + plt_offset + 2) & 0xffff;
	  gotplt_lo = bfd_get_16 (abfd, plt_data + plt_offset + 6) & 0xffff;
	  gotplt_hi = ((gotplt_hi ^ 0x8000) - 0x8000) << 16;
	  gotplt_lo = (gotplt_lo ^ 0x8000) - 0x8000;
	  gotplt_addr = gotplt_hi + gotplt_lo;
	  entry_size = 2 * ARRAY_SIZE (micromips_insn32_o32_exec_plt_entry);
	  suffixlen = sizeof (microsuffix);
	  suffix = microsuffix;
	  other = STO_MICROMIPS;
	}
      /* Otherwise assume standard MIPS code.  */
      else
	{
	  gotplt_hi = bfd_get_32 (abfd, plt_data + plt_offset) & 0xffff;
	  gotplt_lo = bfd_get_32 (abfd, plt_data + plt_offset + 4) & 0xffff;
	  gotplt_hi = ((gotplt_hi ^ 0x8000) - 0x8000) << 16;
	  gotplt_lo = (gotplt_lo ^ 0x8000) - 0x8000;
	  gotplt_addr = gotplt_hi + gotplt_lo;
	  entry_size = 4 * ARRAY_SIZE (mips_exec_plt_entry);
	  suffixlen = sizeof (mipssuffix);
	  suffix = mipssuffix;
	  other = 0;
	}
      /* Truncated table???  */
      if (plt_offset + entry_size > plt->size)
	break;

      for (i = 0;
	   i < count && p[pi].address != gotplt_addr;
	   i++, pi = (pi + bed->s->int_rels_per_ext_rel) % counti);

      if (i < count)
	{
	  size_t namelen;
	  size_t len;

	  *s = **p[pi].sym_ptr_ptr;
	  /* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL set.  Since
	     we are defining a symbol, ensure one of them is set.  */
	  if ((s->flags & BSF_LOCAL) == 0)
	    s->flags |= BSF_GLOBAL;
	  s->flags |= BSF_SYNTHETIC;
	  s->section = plt;
	  s->value = plt_offset;
	  s->name = names;
	  s->udata.i = other;

	  len = strlen ((*p[pi].sym_ptr_ptr)->name);
	  namelen = len + suffixlen;
	  if (names + namelen > nend)
	    break;

	  memcpy (names, (*p[pi].sym_ptr_ptr)->name, len);
	  names += len;
	  memcpy (names, suffix, suffixlen);
	  names += suffixlen;

	  ++s, ++n;
	  pi = (pi + bed->s->int_rels_per_ext_rel) % counti;
	}
    }

  free (plt_data);

  return n;
}

void
_bfd_mips_post_process_headers (bfd *abfd, struct bfd_link_info *link_info)
{
  struct mips_elf_link_hash_table *htab;
  Elf_Internal_Ehdr *i_ehdrp;

  i_ehdrp = elf_elfheader (abfd);
  if (link_info)
    {
      htab = mips_elf_hash_table (link_info);
      BFD_ASSERT (htab != NULL);

      if (htab->use_plts_and_copy_relocs && !htab->is_vxworks)
	i_ehdrp->e_ident[EI_ABIVERSION] = 1;
    }
}
@


1.361
log
@bfd/
	* elfxx-mips.c (mips_use_local_got_p): New function.
	(mips_elf_count_got_symbols, mips_elf_calculate_relocation): Use it.
	(_bfd_mips_elf_check_relocs): Set pointer_equality_needed for
	GOT and absolute references.

ld/testsuite/
	* ld-mips-elf/pic-and-nonpic-6-n32.ad,
	ld-mips-elf/pic-and-nonpic-6-n32.dd,
	ld-mips-elf/pic-and-nonpic-6-n32.gd,
	ld-mips-elf/pic-and-nonpic-6-n32.nd,
	ld-mips-elf/pic-and-nonpic-6-n32.rd,
	ld-mips-elf/pic-and-nonpic-6-n64.ad,
	ld-mips-elf/pic-and-nonpic-6-n64.dd,
	ld-mips-elf/pic-and-nonpic-6-n64.gd,
	ld-mips-elf/pic-and-nonpic-6-n64.nd,
	ld-mips-elf/pic-and-nonpic-6-n64.rd,
	ld-mips-elf/pic-and-nonpic-6-o32.ad,
	ld-mips-elf/pic-and-nonpic-6-o32.dd,
	ld-mips-elf/pic-and-nonpic-6-o32.gd,
	ld-mips-elf/pic-and-nonpic-6-o32.nd,
	ld-mips-elf/pic-and-nonpic-6-o32.rd: Fix symbol value of extf4.
	No longer expect extf3, extf4 and extd2 to be in the global GOT.
@
text
@d545 3
d14334 1
d14341 5
d14535 41
@


1.360
log
@bfd/
2013-09-24  Gregory Fong  <gregory.0xf0@@gmail.com>

	* elfxx-mips.c (mips_elf_create_got_section): Hide
	_GLOBAL_OFFSET_TABLE_.

ld/testsuite/
2013-09-24  Gregory Fong  <gregory.0xf0@@gmail.com>

	* ld-mips-elf/eh-frame5.d, ld-mips-elf/jalx-2.dd,
	ld-mips-elf/mips-elf.exp, ld-mips-elf/mips16-pic-2.ad,
	ld-mips-elf/mips16-pic-2.nd, ld-mips-elf/pic-and-nonpic-3a.dd,
	ld-mips-elf/pic-and-nonpic-3b.ad, ld-mips-elf/pic-and-nonpic-3b.dd,
	ld-mips-elf/pic-and-nonpic-3b.nd, ld-mips-elf/pic-and-nonpic-4b.ad,
	ld-mips-elf/pic-and-nonpic-4b.nd, ld-mips-elf/pic-and-nonpic-4b.rd,
	ld-mips-elf/pic-and-nonpic-5b.ad, ld-mips-elf/pic-and-nonpic-5b.nd,
	ld-mips-elf/pic-and-nonpic-6-n32.ad,
	ld-mips-elf/pic-and-nonpic-6-n32.dd,
	ld-mips-elf/pic-and-nonpic-6-n32.nd,
	ld-mips-elf/pic-and-nonpic-6-n64.ad,
	ld-mips-elf/pic-and-nonpic-6-n64.dd,
	ld-mips-elf/pic-and-nonpic-6-n64.nd,
	ld-mips-elf/pic-and-nonpic-6-o32.ad,
	ld-mips-elf/pic-and-nonpic-6-o32.dd,
	ld-mips-elf/pic-and-nonpic-6-o32.nd, ld-mips-elf/rel32-n32.d,
	ld-mips-elf/rel32-o32.d, ld-mips-elf/rel64.d,
	ld-mips-elf/tls-multi-got-1.got, ld-mips-elf/tls-multi-got-1.r,
	ld-mips-elf/tlsdyn-o32-1.d, ld-mips-elf/tlsdyn-o32-1.got,
	ld-mips-elf/tlsdyn-o32-2.d, ld-mips-elf/tlsdyn-o32-2.got,
	ld-mips-elf/tlsdyn-o32-3.d, ld-mips-elf/tlsdyn-o32-3.got,
	ld-mips-elf/tlsdyn-o32.d, ld-mips-elf/tlsdyn-o32.got,
	ld-mips-elf/tlslib-o32-ver.got, ld-mips-elf/tlslib-o32.got: Update
	for removal of _GLOBAL_OFFSET_TABLE_ from .dynsym.
@
text
@d4302 30
d4351 2
a4352 12
	 local or global GOT.  Symbols that bind locally can (and in the
	 case of forced-local symbols, must) live in the local GOT.
	 Those that are aren't in the dynamic symbol table must also
	 live in the local GOT.

	 Note that the former condition does not always imply the
	 latter: symbols do not bind locally if they are completely
	 undefined.  We'll report undefined symbols later if appropriate.  */
      if (h->root.dynindx == -1
	  || (h->got_only_for_calls
	      ? SYMBOL_CALLS_LOCAL (info, &h->root)
	      : SYMBOL_REFERENCES_LOCAL (info, &h->root)))
d5491 1
a5491 4
  local_p = (h == NULL
	     || (h->got_only_for_calls
		 ? SYMBOL_CALLS_LOCAL (info, &h->root)
		 : SYMBOL_REFERENCES_LOCAL (info, &h->root)));
d7975 2
d8009 11
a8021 1
	case R_MIPS_GOT16:
d8025 8
a8041 1
	case R_MIPS16_CALL16:
a8045 3
	case R_MICROMIPS_CALL16:
	case R_MICROMIPS_CALL_HI16:
	case R_MICROMIPS_CALL_LO16:
d8066 1
d8069 1
a8069 2
	  /* This is just a hint; it can safely be ignored.  Don't set
	     has_static_relocs for the corresponding symbol.  */
d8072 15
a8112 1
	      break;
d8114 1
a8114 27
	  /* For sections that are not SEC_ALLOC a copy reloc would be
	     output if possible (implying questionable semantics for
	     read-only data objects) or otherwise the final link would
	     fail as ld.so will not process them and could not therefore
	     handle any outstanding dynamic relocations.

	     For such sections that are also SEC_DEBUGGING, we can avoid
	     these problems by simply ignoring any relocs as these
	     sections have a predefined use and we know it is safe to do
	     so.

	     This is needed in cases such as a global symbol definition
	     in a shared library causing a common symbol from an object
	     file to be converted to an undefined reference.  If that
	     happens, then all the relocations against this symbol from
	     SEC_DEBUGGING sections in the object file will resolve to
	     nil.  */
	  if ((sec->flags & SEC_DEBUGGING) != 0)
	    break;
	  /* Fall through.  */

	default:
	  /* Most static relocations require pointer equality, except
	     for branches.  */
	  if (h)
	    h->pointer_equality_needed = TRUE;
	  /* Fall through.  */
d8124 1
a8124 2
	  if (h)
	    ((struct mips_elf_link_hash_entry *) h)->has_static_relocs = TRUE;
d8130 16
a8425 22
      /* We must not create a stub for a symbol that has relocations
	 related to taking the function's address.  This doesn't apply to
	 VxWorks, where CALL relocs refer to a .got.plt entry instead of
	 a normal .got entry.  */
      if (!htab->is_vxworks && h != NULL)
	switch (r_type)
	  {
	  default:
	    ((struct mips_elf_link_hash_entry *) h)->no_fn_stub = TRUE;
	    break;
	  case R_MIPS16_CALL16:
	  case R_MIPS_CALL16:
	  case R_MIPS_CALL_HI16:
	  case R_MIPS_CALL_LO16:
	  case R_MIPS_JALR:
	  case R_MICROMIPS_CALL16:
	  case R_MICROMIPS_CALL_HI16:
	  case R_MICROMIPS_CALL_LO16:
	  case R_MICROMIPS_JALR:
	    break;
	  }

@


1.359
log
@2013-09-17  Doug Gilmore  <Doug.Gilmore@@imgtec.com>

	* elfxx-mips.c (_bfd_mips_elf_print_private_bfd_data): Handle
	EF_MIPS_FP64.
@
text
@d5020 1
@


1.359.2.1
log
@bfd/
2013-10-05  Gregory Fong  <gregory.0xf0@@gmail.com>

	* elfxx-mips.c (mips_elf_create_got_section): Hide
	_GLOBAL_OFFSET_TABLE_.

ld/testsuite/
2013-10-05  Gregory Fong  <gregory.0xf0@@gmail.com>

	* ld-mips-elf/eh-frame5.d, ld-mips-elf/jalx-2.dd,
	ld-mips-elf/mips-elf.exp, ld-mips-elf/mips16-pic-2.ad,
	ld-mips-elf/mips16-pic-2.nd, ld-mips-elf/pic-and-nonpic-3a.dd,
	ld-mips-elf/pic-and-nonpic-3b.ad, ld-mips-elf/pic-and-nonpic-3b.dd,
	ld-mips-elf/pic-and-nonpic-3b.nd, ld-mips-elf/pic-and-nonpic-4b.ad,
	ld-mips-elf/pic-and-nonpic-4b.nd, ld-mips-elf/pic-and-nonpic-4b.rd,
	ld-mips-elf/pic-and-nonpic-5b.ad, ld-mips-elf/pic-and-nonpic-5b.nd,
	ld-mips-elf/pic-and-nonpic-6-n32.ad,
	ld-mips-elf/pic-and-nonpic-6-n32.dd,
	ld-mips-elf/pic-and-nonpic-6-n32.nd,
	ld-mips-elf/pic-and-nonpic-6-n64.ad,
	ld-mips-elf/pic-and-nonpic-6-n64.dd,
	ld-mips-elf/pic-and-nonpic-6-n64.nd,
	ld-mips-elf/pic-and-nonpic-6-o32.ad,
	ld-mips-elf/pic-and-nonpic-6-o32.dd,
	ld-mips-elf/pic-and-nonpic-6-o32.nd, ld-mips-elf/rel32-n32.d,
	ld-mips-elf/rel32-o32.d, ld-mips-elf/rel64.d,
	ld-mips-elf/tls-multi-got-1.got, ld-mips-elf/tls-multi-got-1.r,
	ld-mips-elf/tlsdyn-o32-1.d, ld-mips-elf/tlsdyn-o32-1.got,
	ld-mips-elf/tlsdyn-o32-2.d, ld-mips-elf/tlsdyn-o32-2.got,
	ld-mips-elf/tlsdyn-o32-3.d, ld-mips-elf/tlsdyn-o32-3.got,
	ld-mips-elf/tlsdyn-o32.d, ld-mips-elf/tlsdyn-o32.got,
	ld-mips-elf/tlslib-o32-ver.got, ld-mips-elf/tlslib-o32.got: Update
	for removal of _GLOBAL_OFFSET_TABLE_ from .dynsym.
@
text
@a5019 1
  h->other = (h->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;
@


1.358
log
@	include/elf/
	* mips.h (Tag_GNU_MIPS_ABI_FP): Remove comment.
	(Val_GNU_MIPS_ABI_FP_ANY, Val_GNU_MIPS_ABI_FP_DOUBLE,
	Val_GNU_MIPS_ABI_FP_SINGLE, Val_GNU_MIPS_ABI_FP_SOFT,
	Val_GNU_MIPS_ABI_FP_64): New enum.

	bfd/
	* elfxx-mips.c (mips_elf_merge_obj_attributes): Replace hardcoded
	magic numbers with enum values.

	binutils/
	* readelf.c (display_mips_gnu_attribute): Replace hardcoded magic
	numbers with enum values.

	gdb/
	* mips-tdep.c (mips_gdbarch_init): Replace hardcoded magic
	numbers with enum values.
@
text
@d14941 3
@


1.357
log
@	include/elf/
	* mips.h (EF_MIPS_NAN2008): New macro.

	bfd/
	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Handle
	EF_MIPS_NAN2008.
	(_bfd_mips_elf_print_private_bfd_data): Likewise.

	binutils/
	* readelf.c (get_machine_flags): Handle EF_MIPS_NAN2008.

	gas/
	* config/tc-mips.c (mips_flag_nan2008): New variable.
	(options): Add OPTION_NAN enum value.
	(md_longopts): Handle it.
	(md_parse_option): Likewise.
	(s_nan): New function.
	(mips_elf_final_processing): Handle EF_MIPS_NAN2008.
	(md_show_usage): Add -mnan.

	* doc/as.texinfo (Overview): Add -mnan.
	* doc/c-mips.texi (MIPS Opts): Document -mnan.
	(MIPS NaN Encodings): New node.  Document .nan directive.
	(MIPS-Dependent): List the new node.

	gas/testsuite/
	* gas/mips/nan-2008-1.d: New test.
	* gas/mips/nan-2008-2.d: New test.
	* gas/mips/nan-2008-3.d: New test.
	* gas/mips/nan-2008-4.d: New test.
	* gas/mips/nan-legacy-1.d: New test.
	* gas/mips/nan-legacy-2.d: New test.
	* gas/mips/nan-legacy-3.d: New test.
	* gas/mips/nan-legacy-4.d: New test.
	* gas/mips/nan-legacy-5.d: New test.
	* gas/mips/nan-error-1.l: New list test.
	* gas/mips/nan-error-2.l: New list test.
	* gas/mips/nan-2008-override.s: New test source.
	* gas/mips/nan-2008.s: New test source.
	* gas/mips/nan-legacy-override.s: New test source.
	* gas/mips/nan-legacy.s: New test source.
	* gas/mips/nan-error-1.s: New test source.
	* gas/mips/nan-error-2.s: New test source.
	* gas/mips/mips.exp: Run the new tests.

	ld/testsuite/
	* ld-mips-elf/nan-2008.d: New test.
	* ld-mips-elf/nan-legacy.d: New test.
	* ld-mips-elf/nan-mixed-1.d: New test.
	* ld-mips-elf/nan-mixed-2.d: New test.
	* ld-mips-elf/nan-2008.s: New test source.
	* ld-mips-elf/nan-legacy.s: New test source.
@
text
@d14319 1
a14319 1
  if (!abi_fp_bfd && in_attr[Tag_GNU_MIPS_ABI_FP].i != 0)
d14340 1
a14340 1
      if (out_attr[Tag_GNU_MIPS_ABI_FP].i == 0)
d14342 1
a14342 1
      else if (in_attr[Tag_GNU_MIPS_ABI_FP].i != 0)
d14345 1
a14345 1
	  case 1:
d14348 1
a14348 1
	      case 2:
d14354 1
a14354 1
	      case 3:
d14360 1
a14360 1
	      case 4:
d14377 1
a14377 1
	  case 2:
d14380 1
a14380 1
	      case 1:
d14386 1
a14386 1
	      case 3:
d14392 1
a14392 1
	      case 4:
d14409 1
a14409 1
	  case 3:
d14412 3
a14414 3
	      case 1:
	      case 2:
	      case 4:
d14430 1
a14430 1
	  case 4:
d14433 1
a14433 1
	      case 1:
d14440 1
a14440 1
	      case 2:
d14447 1
a14447 1
	      case 3:
d14466 1
a14466 1
	      case 1:
d14474 1
a14474 1
	      case 2:
d14482 1
a14482 1
	      case 3:
d14490 1
a14490 1
	      case 4:
@


1.356
log
@	bfd/
	* elfxx-mips.h (_bfd_mips_elf_insn32): New prototype.
	* elfxx-mips.c (mips_elf_link_hash_table): Add insn32 member.
	(STUB_MOVE32_MICROMIPS, STUB_JALR32_MICROMIPS): New macros.
	(MICROMIPS_INSN32_FUNCTION_STUB_NORMAL_SIZE): Likewise.
	(MICROMIPS_INSN32_FUNCTION_STUB_BIG_SIZE): Likewise.
	(micromips_insn32_o32_exec_plt0_entry): New variable.
	(micromips_insn32_o32_exec_plt_entry): Likewise.
	(_bfd_mips_elf_adjust_dynamic_symbol): Handle insn32 mode.
	(mips_elf_estimate_stub_size): Likewise.
	(_bfd_mips_elf_size_dynamic_sections): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	(mips_finish_exec_plt): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips_elf_insn32): New function.
	(_bfd_mips_elf_get_synthetic_symtab): Handle insn32 PLT.

	gas/
	* config/tc-mips.c (mips_set_options): Add insn32 member.
	(mips_opts): Initialize it.
	(NOP_INSN, NOP_INSN_SIZE): Handle insn32 mode.
	(options): Add OPTION_INSN32 and OPTION_NO_INSN32 enum values.
	(md_longopts): Add "minsn32" and "mno-insn32" options.
	(is_size_valid): Handle insn32 mode.
	(md_assemble): Pass instruction string down to macro.
	(brk_fmt): Add second dimension and insn32 mode initializers.
	(mfhl_fmt): Likewise.
	(BRK_FMT, MFHL_FMT): Handle insn32 mode.
	(macro_build) <'c'>: Handle microMIPS 32-bit BREAK encoding.
	(macro_build_jalr, move_register): Handle insn32 mode.
	(macro_build_branch_rs): Likewise.
	(macro): Handle insn32 mode.
	<M_JRADDIUSP>, <M_JRC>, <M_MOVEP>: New cases.
	(mips_ip): Handle insn32 mode.
	(md_parse_option): Handle OPTION_INSN32 and OPTION_NO_INSN32.
	(s_mipsset): Handle "insn32" and "noinsn32" pseudo-ops.
	(mips_handle_align): Handle insn32 mode.
	(md_show_usage): Add -minsn32 and -mno-insn32.

	* doc/as.texinfo (Target MIPS options): Add -minsn32 and
	-mno-insn32 options.
	(-minsn32, -mno-insn32): New options.
	* doc/c-mips.texi (MIPS Opts): Add -minsn32 and -mno-insn32
	options.
	(MIPS assembly options): New node.  Document .set insn32 and
	.set noinsn32.
	(MIPS-Dependent): List the new node.

	gas/testsuite/
	* gas/mips/micromips-insn32.d: New test.
	* gas/mips/micromips-noinsn32.d: Likewise.
	* gas/mips/micromips.l: Rename to...
	* gas/mips/micromips-warn.l: ... this.
	* gas/mips/micromips.d: Update accordingly.
	* gas/mips/micromips-trap.d: Likewise.
	* gas/mips/micromips.l: New list test.
	* gas/mips/micromips.s: Add conditionals.
	* gas/mips/mips.exp: Run the new tests.

	include/opcode/
	* mips.h: Add M_JRADDIUSP, M_JRC and M_MOVEP anonymous enum
	values.

	ld/
	* emultempl/mipself.em (insn32): New variable.
	(mips_create_output_section_statements): Handle insn32 mode.
	(PARSE_AND_LIST_PROLOGUE): New macro.
	(PARSE_AND_LIST_LONGOPTS): Likewise.
	(PARSE_AND_LIST_OPTIONS): Likewise.

	* gen-doc.texi: Set MIPS.
	* ld.texinfo: Likewise.
	(Options specific to MIPS targets): New section.
	(ld and MIPS family): New node.
	(Top, Machine Dependent): List the new node.

	opcodes/
	* micromips-opc.c (micromips_opcodes): Add "jraddiusp", "jrc"
	and "movep" macros.
@
text
@d14733 14
d14938 3
@


1.355
log
@	bfd/
	* elfxx-mips.h (_bfd_mips_elf_get_synthetic_symtab): New
	prototype.
	* elf32-mips.c (elf_backend_plt_sym_val): Remove macro.
	(bfd_elf32_get_synthetic_symtab): New macro.
	* elfxx-mips.c (plt_entry): New structure.
	(mips_elf_link_hash_entry): Add use_plt_entry member.
	(mips_elf_link_hash_table): Rename plt_entry_size member to
	plt_mips_entry_size.  Add plt_comp_entry_size, plt_mips_offset,
	plt_comp_offset, plt_got_index entries and plt_header_is_comp
	members.
	(STUB_LW_MICROMIPS, STUB_MOVE_MICROMIPS): New macros.
	(STUB_LUI_MICROMIPS, STUB_JALR_MICROMIPS): Likewise.
	(STUB_ORI_MICROMIPS, STUB_LI16U_MICROMIPS): Likewise.
	(STUB_LI16S_MICROMIPS): Likewise.
	(MICROMIPS_FUNCTION_STUB_NORMAL_SIZE): Likewise.
	(MICROMIPS_FUNCTION_STUB_BIG_SIZE): Likewise.
	(micromips_o32_exec_plt0_entry): New variable.
	(mips16_o32_exec_plt_entry): Likewise.
	(micromips_o32_exec_plt_entry): Likewise.
	(mips_elf_link_hash_newfunc): Initialize use_plt_entry.
	(mips_elf_output_extsym): Update to use gotplt_union's plist
	member rather than offset.
	(mips_elf_gotplt_index): Likewise.  Remove the VxWorks
	restriction.  Use MIPS_ELF_GOT_SIZE to calculate GOT address.
	(mips_elf_count_got_symbols): Update to use gotplt_union's plist
	member rather than offset.
	(mips_elf_calculate_relocation): Handle MIPS16/microMIPS PLT
	entries.
	(_bfd_mips_elf_create_dynamic_sections): Don't set PLT sizes
	here.
	(mips_elf_make_plt_record): New function.
	(_bfd_mips_elf_check_relocs): Update comment.  Record occurences
	of JAL relocations that might need a PLT entry.
	(_bfd_mips_elf_adjust_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Set individual
	PLT entry sizes here.  Handle MIPS16/microMIPS PLT entries.
	Don't set the symbol's value in the symbol table for PLT
	references here.  Don't set the PLT or PLT GOT section sizes
	here.
	(mips_elf_estimate_stub_size): Handle microMIPS stubs.
	(mips_elf_allocate_lazy_stub): Likewise.
	(mips_elf_lay_out_lazy_stubs): Likewise.  Define a _MIPS_STUBS_
	magic symbol.
	(mips_elf_set_plt_sym_value): New function.
	(_bfd_mips_elf_size_dynamic_sections): Set PLT header size and
	PLT and PLT GOT section sizes here.  Set the symbol values in
	the symbol table for PLT references here.  Handle microMIPS
	annotation of the _PROCEDURE_LINKAGE_TABLE_ magic symbol.
	(_bfd_mips_elf_finish_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Handle
	MIPS16/microMIPS PLT entries.  Handle microMIPS stubs.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Update to use
	gotplt_union's plist member rather than offset.  Use
	MIPS_ELF_GOT_SIZE to calculate GOT address.
	(mips_finish_exec_plt): Handle microMIPS PLT.  Return status.
	(_bfd_mips_elf_finish_dynamic_sections): Handle result from
	mips_finish_exec_plt.
	(_bfd_mips_elf_link_hash_table_create): Update to use
	gotplt_union's plist member rather than offset.
	(_bfd_mips_elf_get_synthetic_symtab): New function.

	include/elf/
	* mips.h (ELF_ST_IS_MIPS_PLT): Respect STO_MIPS16 setting.
	(ELF_ST_SET_MIPS_PLT): Likewise.

	gdb/
	* mips-tdep.c (mips_elf_make_msymbol_special): Handle MIPS16 and
	microMIPS synthetic symbols.

	ld/
	* emulparams/elf32btsmip.sh: Arrange for .got.plt to be placed
	as close to .plt as possible.
	* scripttempl/elf.sc: Handle $INITIAL_READWRITE_SECTIONS and
	$PLT_NEXT_DATA variables.

	ld/testsuite/
	* ld-mips-elf/jalx-2.dd: Update for microMIPS PLT support.
	* ld-mips-elf/pic-and-nonpic-3a.dd: Update for the _MIPS_STUBS_
	magic symbol.
	* ld-mips-elf/pic-and-nonpic-3b.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-n32.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-n64.dd: Likewise.
	* ld-mips-elf/pic-and-nonpic-6-o32.dd: Likewise.
	* ld-mips-elf/stub-dynsym-1-10000.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-2fe80.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-7fff.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-8000.d: Likewise.
	* ld-mips-elf/stub-dynsym-1-fff0.d: Likewise.
	* ld-mips-elf/tlslib-o32.d: Likewise.

	opcodes/
	* mips-dis.c (is_mips16_plt_tail): New function.
	(print_insn_mips16): Handle MIPS16 PLT entry's GOT slot address
	word.
	(is_compressed_mode_p): Handle MIPS16/microMIPS PLT entries.
@
text
@d440 3
d910 4
d917 1
d931 2
d1063 14
d1110 9
d8838 8
a8845 1
	  else if (micromips_p)
d8850 1
a8850 1
		= 2 * ARRAY_SIZE (micromips_o32_exec_plt_entry);
d8857 1
a8857 1
		= 2 * ARRAY_SIZE (mips16_o32_exec_plt_entry);
d9171 10
a9180 2
     shorter by 4 bytes each too.  */
  if (MICROMIPS_P (output_bfd))
a9183 4
  else
    htab->function_stub_size = (dynsymcount > 0x10000
				? MIPS_FUNCTION_STUB_BIG_SIZE
				: MIPS_FUNCTION_STUB_NORMAL_SIZE);
d9388 2
d10342 26
a10367 1
	  if (MICROMIPS_P (output_bfd))
a10399 12
	  else
	    {
	      const bfd_vma *plt_entry = mips16_o32_exec_plt_entry;

	      bfd_put_16 (output_bfd, plt_entry[0], loc);
	      bfd_put_16 (output_bfd, plt_entry[1], loc + 2);
	      bfd_put_16 (output_bfd, plt_entry[2], loc + 4);
	      bfd_put_16 (output_bfd, plt_entry[3], loc + 6);
	      bfd_put_16 (output_bfd, plt_entry[4], loc + 8);
	      bfd_put_16 (output_bfd, plt_entry[5], loc + 10);
	      bfd_put_32 (output_bfd, got_address, loc + 12);
	    }
d10431 5
a10435 1
      if (micromips_p)
a10436 2
      else
	stub_big_size = MIPS_FUNCTION_STUB_BIG_SIZE;
d10457 12
a10468 2
	  bfd_put_16 (output_bfd, STUB_MOVE_MICROMIPS, stub + idx);
	  idx += 2;
d10478 11
a10488 2
	  bfd_put_16 (output_bfd, STUB_JALR_MICROMIPS, stub + idx);
	  idx += 2;
d10911 5
a10915 1
  else if (htab->plt_header_is_comp)
a10916 2
  else
    plt_entry = mips_o32_exec_plt0_entry;
d10961 13
d13027 1
d13310 7
a13316 1
	       && MATCH (bfd_get_16 (abfd, ptr + 4), nop_insn_16))
d13329 2
a13330 3
	  /* Delete the 16-bit delay slot NOP: two bytes from
	     irel->offset + 4.  */
	  delcnt = 2;
d13336 2
a13337 1
      else if (r_type == R_MICROMIPS_PC16_S1
d13357 2
a13358 1
      else if (r_type == R_MICROMIPS_PC16_S1
d13385 2
a13386 1
      else if (r_type == R_MICROMIPS_26_S1
d13544 9
d15115 7
d15165 1
a15165 1
      /* Likewise the expected microMIPS instruction.  */
d15181 13
@


1.354
log
@	PR binutils/15462
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Warning fix.
@
text
@d320 26
d410 3
d467 14
a480 2
  /* The size of a PLT entry in bytes.  */
  bfd_vma plt_entry_size;
d510 3
d901 18
d921 2
d1034 20
a1053 1
/* The format of subsequent PLT entries.  */
d1062 24
d1224 1
d2839 2
d2850 1
a2850 1
		h->esym.asym.value = (hd->root.plt.offset
d3326 1
a3326 1
  bfd_vma plt_index, got_address, got_value;
d3332 2
a3333 8
  BFD_ASSERT (h->plt.offset != (bfd_vma) -1);

  /* This function only works for VxWorks, because a non-VxWorks .got.plt
     section starts with reserved entries.  */
  BFD_ASSERT (htab->is_vxworks);

  /* Calculate the index of the symbol's PLT entry.  */
  plt_index = (h->plt.offset - htab->plt_header_size) / htab->plt_entry_size;
d3338 2
a3339 1
		 + plt_index * 4);
d4306 1
a4306 1
	       && h->root.plt.offset != MINUS_ONE)
d5285 1
a5285 4
      /* If the output section is the PLT section,
         then the target is not microMIPS.  */
      target_is_micromips_code_p = (htab->splt != sec
				    && ELF_ST_IS_MICROMIPS (h->root.other));
d5336 4
a5339 4
  /* If this is a 16-bit call to a 32- or 64-bit function with a stub, we
     need to redirect the call to the stub.  Note that we specifically
     exclude R_MIPS16_CALL16 from this behavior; indirect calls should
     use an indirect stub instead.  */
d5345 1
a5345 1
	   && !target_is_16_bit_code_p)
d5387 25
d7480 4
a7483 28
  if (htab->is_vxworks)
    {
      /* Do the usual VxWorks handling.  */
      if (!elf_vxworks_create_dynamic_sections (abfd, info, &htab->srelplt2))
	return FALSE;

      /* Work out the PLT sizes.  */
      if (info->shared)
	{
	  htab->plt_header_size
	    = 4 * ARRAY_SIZE (mips_vxworks_shared_plt0_entry);
	  htab->plt_entry_size
	    = 4 * ARRAY_SIZE (mips_vxworks_shared_plt_entry);
	}
      else
	{
	  htab->plt_header_size
	    = 4 * ARRAY_SIZE (mips_vxworks_exec_plt0_entry);
	  htab->plt_entry_size
	    = 4 * ARRAY_SIZE (mips_vxworks_exec_plt_entry);
	}
    }
  else if (!info->shared)
    {
      /* All variants of the plt0 entry are the same size.  */
      htab->plt_header_size = 4 * ARRAY_SIZE (mips_o32_exec_plt0_entry);
      htab->plt_entry_size = 4 * ARRAY_SIZE (mips_exec_plt_entry);
    }
d7611 18
d7630 2
a7631 1
   allocate space in the global offset table.  */
d8334 22
d8758 7
a8764 3
      /* If this is the first symbol to need a PLT entry, allocate room
	 for the header.  */
      if (htab->splt->size == 0)
d8767 1
a8782 2
	  htab->splt->size += htab->plt_header_size;

d8786 3
a8788 2
	    htab->sgotplt->size
	      += get_elf_backend_data (dynobj)->got_header_size;
d8794 25
d8821 49
a8869 3
      /* Assign the next .plt entry to this symbol.  */
      h->plt.offset = htab->splt->size;
      htab->splt->size += htab->plt_entry_size;
d8874 1
a8874 9
	{
	  h->root.u.def.section = htab->splt;
	  h->root.u.def.value = h->plt.offset;
	  /* For VxWorks, point at the PLT load stub rather than the
	     lazy resolution stub; this stub will become the canonical
	     function address.  */
	  if (htab->is_vxworks)
	    h->root.u.def.value += 8;
	}
d8876 1
a8876 3
      /* Make room for the .got.plt entry and the R_MIPS_JUMP_SLOT
	 relocation.  */
      htab->sgotplt->size += MIPS_ELF_GOT_SIZE (dynobj);
d9127 13
a9139 4
  /* Determine the size of one stub entry.  */
  htab->function_stub_size = (dynsymcount > 0x10000
			      ? MIPS_FUNCTION_STUB_BIG_SIZE
			      : MIPS_FUNCTION_STUB_NORMAL_SIZE);
d9144 3
a9146 3
/* A mips_elf_link_hash_traverse callback for which DATA points to the
   MIPS hash table.  If H needs a traditional MIPS lazy-binding stub,
   allocate an entry in the stubs section.  */
d9151 1
d9153 7
a9160 1
  htab = (struct mips_elf_link_hash_table *) data;
d9163 12
d9176 3
a9178 2
      h->root.root.u.def.value = htab->sstubs->size;
      h->root.plt.offset = htab->sstubs->size;
d9187 1
a9187 1
static void
d9190 4
d9195 3
d9203 1
a9203 1
    return;
d9206 6
a9211 1
  mips_elf_link_hash_traverse (htab, mips_elf_allocate_lazy_stub, htab);
d9215 63
d9309 18
a9326 3
      /* Create a symbol for the PLT, if we know that we are using it.  */
      if (htab->splt && htab->splt->size > 0 && htab->root.hplt == NULL)
	{
d9328 1
d9331 2
d9334 35
a9368 5
	  h = _bfd_elf_define_linkage_sym (dynobj, info, htab->splt,
					   "_PROCEDURE_LINKAGE_TABLE_");
	  htab->root.hplt = h;
	  if (h == NULL)
	    return FALSE;
d10207 3
a10209 1
  if (h->plt.offset != MINUS_ONE && hmips->no_fn_stub)
d10213 1
a10213 1
      bfd_vma header_address, plt_index, got_address;
d10215 4
a10218 1
      const bfd_vma *plt_entry;
d10223 1
a10223 1
      BFD_ASSERT (h->plt.offset <= htab->splt->size);
d10227 1
d10229 1
a10229 5
			+ htab->splt->output_offset);

      /* Calculate the index of the entry.  */
      plt_index = ((h->plt.offset - htab->plt_header_size)
		   / htab->plt_entry_size);
d10234 2
a10235 1
		     + (2 + plt_index) * MIPS_ELF_GOT_SIZE (dynobj));
d10240 1
a10240 2
      loc = (htab->sgotplt->contents
	     + (2 + plt_index) * MIPS_ELF_GOT_SIZE (dynobj));
d10246 13
a10258 2
      /* Find out where the .plt entry should go.  */
      loc = htab->splt->contents + h->plt.offset;
d10260 2
a10261 2
      /* Pick the load opcode.  */
      load = MIPS_ELF_LOAD_WORD (output_bfd);
d10263 5
a10267 4
      /* Fill in the PLT entry itself.  */
      plt_entry = mips_exec_plt_entry;
      bfd_put_32 (output_bfd, plt_entry[0] | got_address_high, loc);
      bfd_put_32 (output_bfd, plt_entry[1] | got_address_low | load, loc + 4);
d10269 11
a10279 4
      if (! LOAD_INTERLOCKS_P (output_bfd))
	{
	  bfd_put_32 (output_bfd, plt_entry[2] | got_address_low, loc + 8);
	  bfd_put_32 (output_bfd, plt_entry[3], loc + 12);
d10281 3
a10283 1
      else
d10285 56
a10340 2
	  bfd_put_32 (output_bfd, plt_entry[3], loc + 8);
	  bfd_put_32 (output_bfd, plt_entry[2] | got_address_low, loc + 12);
d10345 1
a10345 1
					  plt_index, h->dynindx,
d10354 1
a10354 1
	sym->st_other = STO_MIPS_PLT;
d10356 4
a10359 1
	sym->st_value = 0;
d10361 2
a10362 1
  else if (h->plt.offset != MINUS_ONE)
d10365 3
d10369 7
d10381 1
a10381 2
      BFD_ASSERT ((htab->function_stub_size == MIPS_FUNCTION_STUB_BIG_SIZE)
                  || (h->dynindx <= 0xffff));
d10390 64
a10453 13
      idx = 0;
      bfd_put_32 (output_bfd, STUB_LW (output_bfd), stub + idx);
      idx += 4;
      bfd_put_32 (output_bfd, STUB_MOVE (output_bfd), stub + idx);
      idx += 4;
      if (htab->function_stub_size == MIPS_FUNCTION_STUB_BIG_SIZE)
        {
          bfd_put_32 (output_bfd, STUB_LUI ((h->dynindx >> 16) & 0x7fff),
                      stub + idx);
          idx += 4;
        }
      bfd_put_32 (output_bfd, STUB_JALR, stub + idx);
      idx += 4;
d10455 3
a10457 13
      /* If a large stub is not required and sign extension is not a
         problem, then use legacy code in the stub.  */
      if (htab->function_stub_size == MIPS_FUNCTION_STUB_BIG_SIZE)
	bfd_put_32 (output_bfd, STUB_ORI (h->dynindx & 0xffff), stub + idx);
      else if (h->dynindx & ~0x7fff)
        bfd_put_32 (output_bfd, STUB_LI16U (h->dynindx & 0xffff), stub + idx);
      else
        bfd_put_32 (output_bfd, STUB_LI16S (output_bfd, h->dynindx),
		    stub + idx);

      BFD_ASSERT (h->plt.offset <= htab->sstubs->size);
      memcpy (htab->sstubs->contents + h->plt.offset,
	      stub, htab->function_stub_size);
d10459 1
a10459 1
      /* Mark the symbol as undefined.  plt.offset != -1 occurs
d10468 3
a10470 1
		       + h->plt.offset);
d10658 1
a10658 1
  if (h->plt.offset != (bfd_vma) -1)
d10661 1
a10661 1
      bfd_vma plt_address, plt_index, got_address, got_offset, branch_offset;
d10664 5
d10672 2
a10673 1
      BFD_ASSERT (h->plt.offset <= htab->splt->size);
d10678 1
a10678 5
		     + h->plt.offset);

      /* Calculate the index of the entry.  */
      plt_index = ((h->plt.offset - htab->plt_header_size)
		   / htab->plt_entry_size);
d10683 1
a10683 1
		     + plt_index * 4);
d10691 1
a10691 1
      branch_offset = -(h->plt.offset / 4 + 1) & 0xffff;
d10695 2
a10696 1
		  htab->sgotplt->contents + plt_index * 4);
d10699 1
a10699 1
      loc = htab->splt->contents + h->plt.offset;
d10705 1
a10705 1
	  bfd_put_32 (output_bfd, plt_entry[1] | plt_index, loc + 4);
d10716 1
a10716 1
	  bfd_put_32 (output_bfd, plt_entry[1] | plt_index, loc + 4);
d10725 1
a10725 1
		 + (plt_index * 3 + 2) * sizeof (Elf32_External_Rela));
d10730 1
a10730 1
	  rel.r_addend = h->plt.offset;
d10748 2
a10749 1
      loc = htab->srelplt->contents + plt_index * sizeof (Elf32_External_Rela);
d10816 1
a10816 1
static void
d10831 2
d10849 43
a10891 8
  bfd_put_32 (output_bfd, plt_entry[0] | gotplt_value_high, loc);
  bfd_put_32 (output_bfd, plt_entry[1] | gotplt_value_low, loc + 4);
  bfd_put_32 (output_bfd, plt_entry[2] | gotplt_value_low, loc + 8);
  bfd_put_32 (output_bfd, plt_entry[3], loc + 12);
  bfd_put_32 (output_bfd, plt_entry[4], loc + 16);
  bfd_put_32 (output_bfd, plt_entry[5], loc + 20);
  bfd_put_32 (output_bfd, plt_entry[6], loc + 24);
  bfd_put_32 (output_bfd, plt_entry[7], loc + 28);
d11413 2
a11414 1
	  mips_finish_exec_plt (output_bfd, info);
d13407 2
d14898 220
@


1.353
log
@	* coffcode.h: Added a cast to void when a bfd_set_section_*()
	macro's return value is ignored.
	* elf32-hppa.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* mach-o.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* peicode.h: Likewise.
	* elf32-m32r.c: Check return value of bfd_set_section_*().
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* vms-alpha.c: Likewise.
@
text
@d9357 1
a9357 1
      bfd_boolean cross_mode_jump_p;
@


1.352
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d2 1
a2 3
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
d7266 2
a7267 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d7270 2
a7271 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d7274 2
a7275 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d7279 2
a7280 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d7283 1
a7283 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d13538 2
a13539 1
struct mips_mach_extension {
d13547 2
a13548 1
static const struct mips_mach_extension mips_mach_extensions[] = {
@


1.351
log
@	* elfxx-mips.c (mips_elf_allocate_lazy_stub): Correct data type.
@
text
@d7817 10
a7826 4
	  while (h != NULL
		 && (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning))
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
@


1.350
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Rename segment_map to seg_map.
	Delete num_locals and num_globals.
	(elf_num_locals, elf_num_globals): Don't define.
	(elf_seg_map, elf_next_file_pos, elf_eh_frame_hdr, elf_linker,
	elf_stack_flags, elf_strtab_sec, elf_shstrtab_sec): Define.
	* bfd.c, * elf-eh-frame.c, * elf-nacl.c, * elf-vxworks.c, * elf.c,
	* elf32-arm.c, * elf32-lm32.c, * elf32-ppc.c, * elf32-rx.c,
	* elf32-spu.c, * elf64-hppa.c, * elfcode.h, * elflink.c,
	* elfnn-ia64.c, * elfxx-mips.c: Use newly defined elf_obj_tdata
	accessor macros.
	* elf.c (elf_map_symbols): Add pnum_locals param.  Return
	number of locals syms via new param.
	(swap_out_syms): Adjust to suit elf_map_symbols change.
ld/
	* emultempl/elf-generic.em: Use newly defined elf_obj_tdata
	accessor macros.
@
text
@d8923 1
a8923 1
mips_elf_allocate_lazy_stub (struct mips_elf_link_hash_entry *h, void **data)
@


1.349
log
@	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Also clear
	STO_MICROMIPS annotation.
@
text
@d11144 1
a11144 1
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
d11159 1
a11159 1
	  pm = &elf_tdata (abfd)->segment_map;
d11189 1
a11189 1
	  pm = &elf_tdata (abfd)->segment_map;
d11219 1
a11219 1
	      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
d11245 1
a11245 1
		  pm = &elf_tdata (abfd)->segment_map;
d11259 1
a11259 1
      for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL;
d11366 1
a11366 1
      for (pm = &elf_tdata (abfd)->segment_map; *pm != NULL; pm = &(*pm)->next)
@


1.348
log
@	* elfxx-mips.c (MICROMIPS_P): New macro.
	(_bfd_mips_elf_symbol_processing): Use it.
@
text
@d10121 2
a10122 2
  /* Keep dynamic MIPS16 symbols odd.  This allows the dynamic linker to
     treat MIPS16 symbols like any other.  */
d10128 5
@


1.347
log
@	* elfxx-mips.c (_bfd_mips_elf_create_dynamic_sections): Clarify
	comment on _PROCEDURE_LINKAGE_TABLE_ creation.
@
text
@d740 4
d6430 1
a6430 1
      if (elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH_ASE_MICROMIPS)
@


1.346
log
@	* elf-bfd.h (struct elf_obj_tdata): Move find_line_info, local_stubs,
	local_call_stubs, elf_data_symbol, elf_text_symbol, elf_data_section,
	and elf_text_section to..
	* elfxx-mips.c (struct mips_elf_obj_tdata): ..here.  Update all refs.
	* elf64-alpha.c (struct mips_elf_find_line): Rename to..
	(struct alpha_elf_find_line): ..this.
	(struct alpha_elf_obj_tdata): Add find_line_info, update refs.
@
text
@d7327 1
a7327 1
     Also create the _PROCEDURE_LINKAGE_TABLE symbol.  */
@


1.345
log
@bfd/
	* elfxx-mips.c (mips_got_page_ref): New structure.
	(mips_got_page_entry): Use a section rather than a (bfd, symndx)
	pair to represent the anchor point.
	(mips_got_info): Add a got_page_refs field.
	(mips_elf_link_hash_table): Add a sym_cache field.
	(mips_got_page_ref_hash, mips_got_page_ref_eq): New functions.
	(mips_got_page_entry_hash, mips_got_page_entry_eq): Update for
	new anchor representation.
	(mips_elf_create_got_info): Create got_page_refs rather than
	got_page_entries.
	(mips_elf_record_got_page_ref): New function.
	(mips_elf_pages_for_range): Move further down file.
	(mips_elf_record_got_page_entry): Likewise.  Take a got as argument.
	Use a section rather than a (bfd, symndx) pair to represent the
	anchor point.
	(mips_elf_resolve_got_page_ref): New function.
	(mips_elf_resolve_final_got_entries): Use it to populate
	got_page_entries.
	(_bfd_mips_elf_check_relocs): Call mips_elf_record_got_page_ref
	rather than mips_elf_record_got_page_entry.  Only nullify h
	afterwards.
	(mips_elf_lay_out_got): Call mips_elf_resolve_final_got_entries
	earlier.

ld/testsuite/
	* ld-mips-elf/mips16-pic-2.dd,
	ld-mips-elf/mips16-pic-2.gd: Remove 3 unused local GOT entries.
	* ld-mips-elf/got-page-4a.s, ld-mips-elf/got-page-4b.s,
	ld-mips-elf/got-page-4a.d, ld-mips-elf/got-page-4a.got,
	ld-mips-elf/got-page-4b.d, ld-mips-elf/got-page-4b.got,
	ld-mips-elf/got-page-5.s, ld-mips-elf/got-page-5.d,
	ld-mips-elf/got-page-5.got, ld-mips-elf/got-page-6.s,
	ld-mips-elf/got-page-6.d, ld-mips-elf/got-page-6.got,
	ld-mips-elf/got-page-7a.s, ld-mips-elf/got-page-7b.s,
	ld-mips-elf/got-page-7c.s, ld-mips-elf/got-page-7d.s,
	ld-mips-elf/got-page-7e.s, ld-mips-elf/got-page-7.d,
	ld-mips-elf/got-page-7.got: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d502 16
d5199 2
a5200 2
	      && elf_tdata (input_bfd)->local_stubs != NULL
	      && elf_tdata (input_bfd)->local_stubs[r_symndx] != NULL))
d5208 1
a5208 1
	  sec = elf_tdata (input_bfd)->local_stubs[r_symndx];
d5239 2
a5240 2
		   && elf_tdata (input_bfd)->local_call_stubs != NULL
		   && elf_tdata (input_bfd)->local_call_stubs[r_symndx] != NULL))
d5244 1
a5244 1
	sec = elf_tdata (input_bfd)->local_call_stubs[r_symndx];
d7028 1
a7028 1
      if (elf_tdata (abfd)->elf_text_section == NULL)
d7045 2
a7046 2
	  elf_tdata (abfd)->elf_text_section = elf_text_section;
	  elf_tdata (abfd)->elf_text_symbol = elf_text_symbol;
d7049 1
a7049 1
	  elf_text_section->symbol_ptr_ptr = &elf_tdata (abfd)->elf_text_symbol;
d7062 1
a7062 1
      *secp = elf_tdata (abfd)->elf_text_section;
d7069 1
a7069 1
      if (elf_tdata (abfd)->elf_data_section == NULL)
d7086 2
a7087 2
	  elf_tdata (abfd)->elf_data_section = elf_data_section;
	  elf_tdata (abfd)->elf_data_symbol = elf_data_symbol;
d7090 1
a7090 1
	  elf_data_section->symbol_ptr_ptr = &elf_tdata (abfd)->elf_data_symbol;
d7103 1
a7103 1
      *secp = elf_tdata (abfd)->elf_data_section;
d7609 1
a7609 1
	  if (elf_tdata (abfd)->local_stubs == NULL)
d7623 1
a7623 1
	      elf_tdata (abfd)->local_stubs = n;
d7627 1
a7627 1
	  elf_tdata (abfd)->local_stubs[r_symndx] = sec;
d7734 1
a7734 1
	  if (elf_tdata (abfd)->local_call_stubs == NULL)
d7748 1
a7748 1
	      elf_tdata (abfd)->local_call_stubs = n;
d7752 1
a7752 1
	  elf_tdata (abfd)->local_call_stubs[r_symndx] = sec;
d11668 1
a11668 1
      fi = elf_tdata (abfd)->find_line_info;
d11706 1
a11706 1
	  elf_tdata (abfd)->find_line_info = fi;
@


1.344
log
@bfd/
	* elfxx-mips.c (mips_elf_lay_out_got): Count VxWorks GOT relocs
	in g->relocs.
@
text
@d111 21
d143 1
a143 1
   relocations against a given symbol.  */
d146 2
a147 4
  /* The input bfd in which the symbol is defined.  */
  bfd *abfd;
  /* The index of the symbol, as stored in the relocation r_info.  */
  long symndx;
d177 2
d468 3
d2798 26
d2829 1
a2829 1
  return entry->abfd->id + entry->symndx;
d2839 1
a2839 1
  return entry1->abfd == entry2->abfd && entry1->symndx == entry2->symndx;
d2858 3
a2860 3
  g->got_page_entries = htab_try_create (1, mips_got_page_entry_hash,
					 mips_got_page_entry_eq, NULL);
  if (g->got_page_entries == NULL)
d2897 3
a2899 1
      htab_delete (tdata->got->got_page_entries);
d3746 3
a3748 14
/* Return the maximum number of GOT page entries required for RANGE.  */

static bfd_vma
mips_elf_pages_for_range (const struct mips_got_page_range *range)
{
  return (range->max_addend - range->min_addend + 0x1ffff) >> 16;
}

/* Record that ABFD has a page relocation against symbol SYMNDX and
   that ADDEND is the addend for that relocation.

   This function creates an upper bound on the number of GOT slots
   required; no attempt is made to combine references to non-overridable
   global symbols across multiple input files.  */
d3751 3
a3753 2
mips_elf_record_got_page_entry (struct bfd_link_info *info, bfd *abfd,
				long symndx, bfd_signed_vma addend)
d3757 1
a3757 3
  struct mips_got_page_entry lookup, *entry;
  struct mips_got_page_range **range_ptr, *range;
  bfd_vma old_pages, new_pages;
d3766 12
a3777 4
  /* Find the mips_got_page_entry hash table entry for this symbol.  */
  lookup.abfd = abfd;
  lookup.symndx = symndx;
  loc = htab_find_slot (g1->got_page_entries, &lookup, INSERT);
d3781 1
a3781 3
  /* Create a mips_got_page_entry if this is the first time we've
     seen the symbol.  */
  entry = (struct mips_got_page_entry *) *loc;
d3788 1
a3788 4
      entry->abfd = abfd;
      entry->symndx = symndx;
      entry->ranges = NULL;
      entry->num_pages = 0;
d3797 1
a3797 1
  bfd_loc = htab_find_slot (g2->got_page_entries, &lookup, INSERT);
a3803 54
  /* Skip over ranges whose maximum extent cannot share a page entry
     with ADDEND.  */
  range_ptr = &entry->ranges;
  while (*range_ptr && addend > (*range_ptr)->max_addend + 0xffff)
    range_ptr = &(*range_ptr)->next;

  /* If we scanned to the end of the list, or found a range whose
     minimum extent cannot share a page entry with ADDEND, create
     a new singleton range.  */
  range = *range_ptr;
  if (!range || addend < range->min_addend - 0xffff)
    {
      range = bfd_alloc (abfd, sizeof (*range));
      if (!range)
	return FALSE;

      range->next = *range_ptr;
      range->min_addend = addend;
      range->max_addend = addend;

      *range_ptr = range;
      entry->num_pages++;
      g1->page_gotno++;
      g2->page_gotno++;
      return TRUE;
    }

  /* Remember how many pages the old range contributed.  */
  old_pages = mips_elf_pages_for_range (range);

  /* Update the ranges.  */
  if (addend < range->min_addend)
    range->min_addend = addend;
  else if (addend > range->max_addend)
    {
      if (range->next && addend >= range->next->min_addend - 0xffff)
	{
	  old_pages += mips_elf_pages_for_range (range->next);
	  range->max_addend = range->next->max_addend;
	  range->next = range->next->next;
	}
      else
	range->max_addend = addend;
    }

  /* Record any change in the total estimate.  */
  new_pages = mips_elf_pages_for_range (range);
  if (old_pages != new_pages)
    {
      entry->num_pages += new_pages - old_pages;
      g1->page_gotno += new_pages - old_pages;
      g2->page_gotno += new_pages - old_pages;
    }

d3922 178
d4101 3
a4103 1
   replace them with entries for the target symbol.  */
d4133 10
a8004 15
	  /* If this is a global, overridable symbol, GOT_PAGE will
	     decay to GOT_DISP, so we'll need a GOT entry for it.  */
	  if (h)
	    {
	      struct mips_elf_link_hash_entry *hmips =
		(struct mips_elf_link_hash_entry *) h;

	      /* This symbol is definitely not overridable.  */
	      if (hmips->root.def_regular
		  && ! (info->shared && ! info->symbolic
			&& ! hmips->root.forced_local))
		h = NULL;
	    }
	  /* Fall through.  */

d8033 2
a8034 2
	      if (!mips_elf_record_got_page_entry (info, abfd, r_symndx,
						   addend))
d8036 12
d8049 2
d8783 3
d8814 1
a8814 1
  /* Choose the smaller of the two estimates; both are intended to be
a8820 5
  /* Replace entries for indirect and warning symbols with entries for
     the target symbol.  Count the number of GOT entries and TLS relocs.  */
  if (!mips_elf_resolve_final_got_entries (info, g))
    return FALSE;

@


1.343
log
@bfd/
	* elfxx-mips.c (mips_elf_count_got_entries): Delete.
	(mips_elf_check_recreate_got, mips_elf_recreate_got): Take a
	mips_elf_traverse_got_arg.  Count GOT entries.
	(mips_elf_resolve_final_got_entries): Take the bfd_link_info
	as argument.  Update after above changes.
	(mips_elf_merge_got, mips_elf_lay_out_got): Don't call
	mips_elf_count_got_entries.  Update the calls to
	mips_elf_resolve_final_got_entries.
@
text
@d8652 1
a8652 14
  if (htab->is_vxworks)
    {
      /* VxWorks executables do not need a GOT.  */
      if (info->shared)
	{
	  /* Each VxWorks GOT entry needs an explicit relocation.  */
	  unsigned int count;

	  count = g->global_gotno + g->local_gotno - htab->reserved_gotno;
	  if (count)
	    mips_elf_allocate_dynamic_relocations (dynobj, info, count);
	}
    }
  else if (s->size > MIPS_ELF_GOT_MAX_SIZE (info))
d8677 4
@


1.342
log
@bfd/
	* elfxx-mips.c (mips_got_tls_type): New enum.
	(mips_got_entry): Add tls_initialized.
	(mips_elf_got_entry_hash, mips_elf_got_entry_eq, mips_tls_got_relocs)
	(mips_elf_count_got_entry, mips_elf_initialize_tls_index): Remove
	GOT_TLS_TYPE masks.
	(mips_elf_reloc_tls_type, mips_tls_got_entries)
	(mips_elf_record_global_got_symbol, mips_elf_initialize_tls_index)
	(_bfd_mips_elf_finish_dynamic_symbol): Use GOT_TLS_NONE rather
	than GOT_NORMAL.
	(mips_elf_initialize_tls_slots): Replace got_offset and tls_type_p
	arguments with a GOT entry.  Remove GOT_TLS_TYPE masks.  Use
	tls_initialized rather than GOT_TLS_DONE.
	(mips_tls_got_index): Delete.
	(mips_elf_local_got_index, mips_elf_global_got_index): Use
	mips_elf_initialize_tls_slots rather than mips_tls_got_index.
	(mips_elf_record_got_entry): Initialize tls_initialized.
@
text
@a2981 17
/* A htab_traverse callback.  Count the number of GOT entries and
   TLS relocations required for the GOT entry in *ENTRYP.  DATA points
   to a mips_elf_traverse_got_arg structure.  */

static int
mips_elf_count_got_entries (void **entryp, void *data)
{
  struct mips_got_entry *entry;
  struct mips_elf_traverse_got_arg *arg;

  entry = (struct mips_got_entry *) *entryp;
  arg = (struct mips_elf_traverse_got_arg *) data;
  mips_elf_count_got_entry (arg->info, arg->g, entry);

  return 1;
}

d3847 4
a3850 2
/* A htab_traverse callback for GOT entries.  Set boolean *DATA to true
   if the GOT entry is for an indirect or warning symbol.  */
d3856 1
a3856 1
  bfd_boolean *must_recreate;
d3859 1
a3859 1
  must_recreate = (bfd_boolean *) data;
d3868 1
a3868 1
	  *must_recreate = TRUE;
d3872 1
d3876 4
a3879 4
/* A htab_traverse callback for GOT entries.  Add all entries to
   hash table *DATA, converting entries for indirect and warning
   symbols into entries for the target symbol.  Set *DATA to null
   on error.  */
a3883 1
  htab_t *new_got;
d3885 1
a3887 1
  new_got = (htab_t *) data;
d3889 1
d3909 1
a3909 1
  slot = htab_find_slot (*new_got, entry, INSERT);
d3912 1
a3912 1
      *new_got = NULL;
d3922 1
a3922 1
	      *new_got = NULL;
d3928 1
d3937 2
a3938 1
mips_elf_resolve_final_got_entries (struct mips_got_info *g)
d3940 17
a3956 2
  bfd_boolean must_recreate;
  htab_t new_got;
d3958 2
a3959 9
  must_recreate = FALSE;
  htab_traverse (g->got_entries, mips_elf_check_recreate_got, &must_recreate);
  if (must_recreate)
    {
      new_got = htab_create (htab_size (g->got_entries),
			     mips_elf_got_entry_hash,
			     mips_elf_got_entry_eq, NULL);
      htab_traverse (g->got_entries, mips_elf_recreate_got, &new_got);
      if (new_got == NULL)
d3962 1
a3962 2
      htab_delete (g->got_entries);
      g->got_entries = new_got;
a4131 1
  struct mips_elf_traverse_got_arg tga;
d4135 1
a4135 1
  if (!mips_elf_resolve_final_got_entries (g))
a4137 4
  tga.info = arg->info;
  tga.g = g;
  htab_traverse (g->got_entries, mips_elf_count_got_entries, &tga);

a8600 5
  /* Replace entries for indirect and warning symbols with entries for
     the target symbol.  */
  if (!mips_elf_resolve_final_got_entries (g))
    return FALSE;

d8640 4
a8643 4
  /* Count the number of GOT entries and TLS relocs.  */
  tga.info = info;
  tga.g = g;
  htab_traverse (g->got_entries, mips_elf_count_got_entries, &tga);
@


1.341
log
@bfd/
	* elfxx-mips.c (mips_got_entry): Remove tls_ldm_offset.
	(mips_elf_link_hash_entry): Remove tls_ie_type, tls_gd_type,
	tls_ie_got_offset and tls_gd_got_offset.
	(mips_elf_link_hash_newfunc): Remove initialization.
	(mips_elf_create_got_info): Likewise.
	(mips_elf_count_local_got_entries, mips_elf_count_global_tls_entries)
	(mips_tls_single_got_index): Delete.
	(mips_elf_local_got_index): Always use the GOT entry to track
	GOT indices.
	(mips_elf_global_got_index): Likewise.
	(mips_elf_create_local_got_entry): Assert that TLS entries have
	already been allocated.
	(mips_elf_record_global_got_symbol): Don't initialize
	tls_ie_type or tls_gd_type.
	(mips_elf_count_got_symbols): Only count reloc-only GOT entries here.
	(mips_elf_initialize_tls_index): Allocate a GOT index for every TLS
	entry.
	(mips_elf_lay_out_got): Use mips_elf_count_got_entries to count
	the GOT entries.
	(_bfd_mips_elf_finish_dynamic_symbol): Assert that TLS GOT offsets
	have been allocated.
	(_bfd_mips_elf_copy_indirect_symbol): Remove handling of
	tls_ie_type and tls_gd_type.
@
text
@d50 8
d97 2
a98 9
  /* The TLS type of this GOT entry: GOT_NORMAL, GOT_TLS_IE, GOT_TLS_GD
     or GOT_TLS_LDM.  An LDM GOT entry will be a local symbol entry with
     r_symndx == 0.  */
#define GOT_NORMAL	0
#define GOT_TLS_GD	1
#define GOT_TLS_LDM	2
#define GOT_TLS_IE	4
#define GOT_TLS_TYPE	7
#define GOT_TLS_DONE    0x80
d101 4
d2750 2
a2751 2
	  + (((entry->tls_type & GOT_TLS_TYPE) == GOT_TLS_LDM) << 18)
	  + ((entry->tls_type & GOT_TLS_TYPE) == GOT_TLS_LDM ? 0
d2765 2
a2766 2
	  && (e1->tls_type & GOT_TLS_TYPE) == (e2->tls_type & GOT_TLS_TYPE)
	  && ((e1->tls_type & GOT_TLS_TYPE) == GOT_TLS_LDM ? TRUE
d2897 1
a2897 1
  return GOT_NORMAL;
d2914 1
a2914 1
    case GOT_NORMAL:
d2945 1
a2945 1
  switch (tls_type & GOT_TLS_TYPE)
d2969 1
a2969 4
  unsigned char tls_type;

  tls_type = entry->tls_type & GOT_TLS_TYPE;
  if (tls_type)
d2971 2
a2972 2
      g->tls_gotno += mips_tls_got_entries (tls_type);
      g->relocs += mips_tls_got_relocs (info, tls_type,
d3033 2
a3034 3
mips_elf_initialize_tls_slots (bfd *abfd, bfd_vma got_offset,
			       unsigned char *tls_type_p,
			       struct bfd_link_info *info,
d3041 1
a3041 1
  bfd_vma got_offset2;
d3060 1
a3060 1
  if (*tls_type_p & GOT_TLS_DONE)
d3077 1
d3079 1
a3079 1
  switch (*tls_type_p & GOT_TLS_TYPE)
d3152 1
a3152 15
  *tls_type_p |= GOT_TLS_DONE;
}

/* Return the GOT index to use for a relocation against H using the
   TLS model in *TLS_TYPE.  The GOT entries for this symbol/model
   combination start at GOT_INDEX into ABFD's GOT.  This function
   initializes the GOT entries and corresponding relocations.  */

static bfd_vma
mips_tls_got_index (bfd *abfd, bfd_vma got_index, unsigned char *tls_type,
		    struct bfd_link_info *info,
		    struct mips_elf_link_hash_entry *h, bfd_vma symbol)
{
  mips_elf_initialize_tls_slots (abfd, got_index, tls_type, info, h, symbol);
  return got_index;
d3213 2
a3214 4
    return mips_tls_got_index (abfd, entry->gotidx, &entry->tls_type,
			       info, h, value);
  else
    return entry->gotidx;
d3290 1
a3290 2
      return mips_tls_got_index (obfd, gotidx, &entry->tls_type,
				 info, lookup.d.h, value);
d3620 1
d3677 1
a3677 1
  if (tls_type == GOT_NORMAL && hmips->global_got_area > GGA_NORMAL)
a4227 1
  unsigned char tls_type;
d4231 1
a4231 2
  tls_type = (entry->tls_type & GOT_TLS_TYPE);
  if (tls_type == 0)
d4242 1
a4242 1
  arg->g->tls_assigned_gotno += mips_tls_got_entries (tls_type);
d9841 1
a9841 1
      e.tls_type = 0;
@


1.340
log
@bfd/
	* elfxx-mips.c (mips_elf_create_local_got_entry): Tidy.  Avoid
	aliasing violation.  Check for htab allocation failures.
@
text
@d92 6
a157 5
  /* This is the GOT index of the TLS LDM entry for the GOT, MINUS_ONE
     for none, or MINUS_TWO for not yet assigned.  This is needed
     because a single-GOT link may have multiple hash table entries
     for the LDM.  It does not get initialized in multi-GOT mode.  */
  bfd_vma tls_ldm_offset;
a324 17
#define GOT_NORMAL	0
#define GOT_TLS_GD	1
#define GOT_TLS_LDM	2
#define GOT_TLS_IE	4
#define GOT_TLS_TYPE	7
#define GOT_TLS_OFFSET_DONE    0x40
#define GOT_TLS_DONE    0x80
  unsigned char tls_ie_type;
  unsigned char tls_gd_type;

  /* These fields are only used in single-GOT mode; in multi-GOT mode there
     is one mips_got_entry per GOT entry, so the offset is stored
     there.  In single-GOT mode there may be many mips_got_entry
     structures all referring to the same GOT slot.  */
  bfd_vma tls_ie_got_offset;
  bfd_vma tls_gd_got_offset;

a1061 2
      ret->tls_ie_type = GOT_NORMAL;
      ret->tls_gd_type = GOT_NORMAL;
a2797 1
  g->tls_ldm_offset = MINUS_ONE;
a2996 57
/* A htab_traverse callback.  If *SLOT describes a GOT entry for a local
   symbol, count the number of GOT entries and TLS relocations that it
   requires.  DATA points to a mips_elf_traverse_got_arg structure.  */

static int
mips_elf_count_local_got_entries (void **entryp, void *data)
{
  struct mips_got_entry *entry;
  struct mips_elf_traverse_got_arg *arg;

  entry = (struct mips_got_entry *) *entryp;
  arg = (struct mips_elf_traverse_got_arg *) data;
  if (entry->abfd != NULL && entry->symndx != -1)
    {
      if ((entry->tls_type & GOT_TLS_TYPE) == GOT_TLS_LDM)
	{
	  if (arg->g->tls_ldm_offset == MINUS_TWO)
	    return 1;
	  arg->g->tls_ldm_offset = MINUS_TWO;
	}
      mips_elf_count_got_entry (arg->info, arg->g, entry);
    }

  return 1;
}

/* Count the number of TLS GOT entries and relocationss required for the
   global (or forced-local) symbol in ARG1.  */

static int
mips_elf_count_global_tls_entries (void *entry, void *data)
{
  struct mips_elf_link_hash_entry *hm;
  struct mips_elf_traverse_got_arg *arg;

  hm = (struct mips_elf_link_hash_entry *) entry;
  if (hm->root.root.type == bfd_link_hash_indirect
      || hm->root.root.type == bfd_link_hash_warning)
    return 1;

  arg = (struct mips_elf_traverse_got_arg *) data;
  if (hm->tls_gd_type)
    {
      arg->g->tls_gotno += 2;
      arg->g->relocs += mips_tls_got_relocs (arg->info, hm->tls_gd_type,
					     &hm->root);
    }
  if (hm->tls_ie_type)
    {
      arg->g->tls_gotno += 1;
      arg->g->relocs += mips_tls_got_relocs (arg->info, hm->tls_ie_type,
					     &hm->root);
    }

  return 1;
}

a3166 16
/* Return the GOT index to use for a relocation of type R_TYPE against H
   in ABFD.  */

static bfd_vma
mips_tls_single_got_index (bfd *abfd, int r_type, struct bfd_link_info *info,
			   struct mips_elf_link_hash_entry *h, bfd_vma symbol)
{
  if (tls_gottprel_reloc_p (r_type))
    return mips_tls_got_index (abfd, h->tls_ie_got_offset, &h->tls_ie_type,
			       info, h, symbol);
  if (tls_gd_reloc_p (r_type))
    return mips_tls_got_index (abfd, h->tls_gd_got_offset, &h->tls_gd_type,
			       info, h, symbol);
  abort ();
}

d3225 2
a3226 9
    {
      if (entry->symndx == -1 && htab->got_info->next == NULL)
	/* A type (3) entry in the single-GOT case.  We use the symbol's
	   hash table entry to track the index.  */
	return mips_tls_single_got_index (abfd, r_type, info, h, value);
      else
	return mips_tls_got_index (abfd, entry->gotidx, &entry->tls_type,
				   info, h, value);
    }
d3270 3
a3272 2
  bfd_vma got_index;
  struct mips_got_info *g, *gg;
d3277 2
a3278 4
  gg = g = htab->got_info;
  if (g->next && ibfd)
    {
      struct mips_got_entry e, *p;
d3280 3
a3282 1
      BFD_ASSERT (h->dynindx >= 0);
d3284 5
a3288 8
      g = mips_elf_bfd_got (ibfd, FALSE);
      BFD_ASSERT (g);
      if (g->next != gg || TLS_RELOC_P (r_type))
	{
	  e.abfd = ibfd;
	  e.symndx = -1;
	  e.d.h = (struct mips_elf_link_hash_entry *)h;
	  e.tls_type = mips_elf_reloc_tls_type (r_type);
d3290 2
a3291 1
	  p = htab_find (g->got_entries, &e);
d3293 1
a3293 21
	  BFD_ASSERT (p && p->gotidx > 0);

	  if (p->tls_type)
	    {
	      bfd_vma value = MINUS_ONE;
	      if ((h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
		  && h->root.u.def.section->output_section)
		value = (h->root.u.def.value
			 + h->root.u.def.section->output_offset
			 + h->root.u.def.section->output_section->vma);

	      return mips_tls_got_index (obfd, p->gotidx, &p->tls_type,
					 info, e.d.h, value);
	    }
	  else
	    return p->gotidx;
	}
    }

  if (TLS_RELOC_P (r_type))
a3294 2
      struct mips_elf_link_hash_entry *hm
	= (struct mips_elf_link_hash_entry *) h;
d3304 2
a3305 1
      got_index = mips_tls_single_got_index (obfd, r_type, info, hm, value);
d3307 1
a3307 5
  else
    got_index = mips_elf_primary_global_got_index (obfd, info, h);
  BFD_ASSERT (got_index < htab->sgot->size);

  return got_index;
d3403 1
d3442 3
a3692 4
  else if (tls_type == GOT_TLS_IE && hmips->tls_ie_type == 0)
    hmips->tls_ie_type = tls_type;
  else if (tls_type == GOT_TLS_GD && hmips->tls_gd_type == 0)
    hmips->tls_gd_type = tls_type;
d3986 5
a3990 3
/* A mips_elf_link_hash_traverse callback for which DATA points
   to the link_info structure.  Count the number of type (3) entries
   in the master GOT.  */
d4017 4
a4020 8
	{
	  /* The symbol belongs in the local GOT.  We no longer need this
	     entry if it was only used for relocations; those relocations
	     will be against the null or section symbol instead of H.  */
	  if (h->global_got_area != GGA_RELOC_ONLY)
	    g->local_gotno++;
	  h->global_got_area = GGA_NONE;
	}
d4028 1
a4028 1
      else
d4030 1
a4031 2
	  if (h->global_got_area == GGA_RELOC_ONLY)
	    g->reloc_only_gotno++;
a4241 2
  struct mips_got_info *g;
  bfd_vma next_index;
d4251 1
a4251 4
  g = arg->g;
  next_index = arg->value * g->tls_assigned_gotno;

  if (entry->symndx == -1 && g->next == NULL)
d4253 2
a4254 37
      /* A type (3) got entry in the single-GOT case.  We use the symbol's
	 hash table entry to track its index.  */
      if (tls_type == GOT_TLS_IE)
	{
	  if (entry->d.h->tls_ie_type & GOT_TLS_OFFSET_DONE)
	    return 1;
	  entry->d.h->tls_ie_type |= GOT_TLS_OFFSET_DONE;
	  entry->d.h->tls_ie_got_offset = next_index;
	}
      else
	{
	  BFD_ASSERT (tls_type == GOT_TLS_GD);
	  if (entry->d.h->tls_gd_type & GOT_TLS_OFFSET_DONE)
	    return 1;
	  entry->d.h->tls_gd_type |= GOT_TLS_OFFSET_DONE;
	  entry->d.h->tls_gd_got_offset = next_index;
	}
    }
  else
    {
      if (tls_type == GOT_TLS_LDM)
	{
	  /* There are separate mips_got_entry objects for each input bfd
	     that requires an LDM entry.  Make sure that all LDM entries in
	     a GOT resolve to the same index.  */
	  if (g->tls_ldm_offset != MINUS_TWO && g->tls_ldm_offset != MINUS_ONE)
	    {
	      entry->gotidx = g->tls_ldm_offset;
	      return 1;
	    }
	  g->tls_ldm_offset = next_index;
	}
      if (!mips_elf_set_gotidx (entryp, next_index))
	{
	  arg->g = NULL;
	  return 0;
	}
d4258 1
a4258 1
  g->tls_assigned_gotno += mips_tls_got_entries (tls_type);
d8632 2
a8633 1
  /* Count the number of GOT symbols.  */
d8671 1
a8671 1
  /* Count the number of local GOT entries and TLS relocs.  */
d8674 1
a8674 8
  htab_traverse (g->got_entries, mips_elf_count_local_got_entries, &tga);

  /* We need to calculate tls_gotno for global symbols at this point
     instead of building it up earlier, to avoid doublecounting
     entries for one global symbol from multiple input files.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  mips_elf_count_global_tls_entries,
			  &tga);
d9866 1
a11359 5

  if (dirmips->tls_ie_type == 0)
    dirmips->tls_ie_type = indmips->tls_ie_type;
  if (dirmips->tls_gd_type == 0)
    dirmips->tls_gd_type = indmips->tls_gd_type;
@


1.339
log
@bfd/
	* elfxx-mips.c (mips_elf_primary_global_got_index): New function,
	split out from...
	(mips_elf_global_got_index): ...here.  Reorder arguments so that
	the output bfd and info come first.
	(mips_elf_calculate_relocation): Update the call to
	mips_elf_global_got_index accordingly.
	(_bfd_mips_elf_finish_dynamic_symbol): Use
	mips_elf_primary_global_got_index rather than
	mips_elf_global_got_index.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
@
text
@d3524 2
a3525 1
  struct mips_got_entry entry, **loc;
a3531 5
  entry.abfd = NULL;
  entry.symndx = -1;
  entry.d.address = value;
  entry.tls_type = mips_elf_reloc_tls_type (r_type);

d3542 3
a3544 1
  if (entry.tls_type)
d3546 1
a3546 3
      struct mips_got_entry *p;

      entry.abfd = ibfd;
d3549 2
a3550 2
	  entry.symndx = 0;
	  entry.d.addend = 0;
d3554 2
a3555 2
	  entry.symndx = r_symndx;
	  entry.d.addend = 0;
d3558 4
a3561 1
	entry.d.h = h;
d3563 2
a3564 2
      p = (struct mips_got_entry *)
	htab_find (g->got_entries, &entry);
d3566 1
a3566 2
      BFD_ASSERT (p);
      return p;
d3569 5
a3573 10
  loc = (struct mips_got_entry **) htab_find_slot (g->got_entries, &entry,
						   INSERT);
  if (*loc)
    return *loc;

  entry.gotidx = MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno++;

  *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);

  if (! *loc)
d3576 3
a3578 1
  memcpy (*loc, &entry, sizeof entry);
d3580 1
a3580 1
  if (g->assigned_gotno > g->local_gotno)
a3581 1
      (*loc)->gotidx = -1;
d3589 9
a3597 2
  MIPS_ELF_PUT_WORD (abfd, value,
		     (htab->sgot->contents + entry.gotidx));
d3610 1
a3610 1
		     + entry.gotidx);
d3619 1
a3619 1
  return *loc;
@


1.338
log
@bfd/
	* elfxx-mips.c (mips_got_entry): Update comments.
	(mips_elf_multi_got_entry_eq): Rename to...
	(mips_elf_got_entry_eq): ...this, deleting the old definition.
	(mips_elf_create_got_info): Remove master_got_p argument.
	Always use mips_elf_got_entry_eq.
	(mips_elf_bfd_got, mips_elf_multi_got, mips_elf_create_got_section):
	Update calls accordingly.

ld/testsuite/
	* ld-mips-elf/tlsdyn-o32-1.d, ld-mips-elf/tlsdyn-o32-1.got,
	ld-mips-elf/tlsdyn-o32-2.d, ld-mips-elf/tlsdyn-o32-2.got,
	ld-mips-elf/tlsdyn-o32-3.d, ld-mips-elf/tlsdyn-o32-3.got,
	ld-mips-elf/tls-hidden3.d, ld-mips-elf/tls-hidden3.got: Update
	for new hash table order.
@
text
@d3330 1
a3330 1
/* Returns the GOT index for the global symbol indicated by H.  */
d3333 34
a3366 2
mips_elf_global_got_index (bfd *abfd, bfd *ibfd, struct elf_link_hash_entry *h,
			   int r_type, struct bfd_link_info *info)
a3370 1
  long global_got_dynindx = 0;
d3405 1
a3405 1
	      return mips_tls_got_index (abfd, p->gotidx, &p->tls_type,
a3412 3
  if (htab->global_gotsym != NULL)
    global_got_dynindx = htab->global_gotsym->dynindx;

d3426 1
a3426 1
      got_index = mips_tls_single_got_index (abfd, r_type, info, hm, value);
d3429 1
a3429 9
    {
      /* Once we determine the global GOT entry with the lowest dynamic
	 symbol table index, we must put all dynamic symbols with greater
	 indices into the GOT.  That makes it easy to calculate the GOT
	 offset.  */
      BFD_ASSERT (h->dynindx >= global_got_dynindx);
      got_index = ((h->dynindx - global_got_dynindx + g->local_gotno)
		   * MIPS_ELF_GOT_SIZE (abfd));
    }
d5382 2
a5383 2
	      g = mips_elf_global_got_index (dynobj, input_bfd,
					     &h->root, r_type, info);
d10015 1
a10015 2
      offset = mips_elf_global_got_index (dynobj, output_bfd, h,
					  R_MIPS_GOT16, info);
d10279 1
a10279 2
      offset = mips_elf_global_got_index (dynobj, output_bfd, h,
					  R_MIPS_GOT16, info);
@


1.337
log
@bfd/
	* elfxx-mips.c (mips_got_info): Remove bfd2got.
	(mips_elf_bfd2got_hash): Delete.
	(mips_elf_got_per_bfd_arg): Remove bfd2got.
	(mips_elf_replace_bfd_got, mips_elf_count_got_entries): New functions.
	(mips_elf_global_got_index, mips_elf_create_local_got_entry): Use
	g->next to test for the multigot case.  Use mips_elf_bfd_got rather
	than mips_elf_got_for_ibfd.
	(mips_elf_bfd2got_entry_hash, mips_elf_bfd2got_entry_eq)
	(mips_elf_got_for_ibfd, mips_elf_get_got_for_bfd): Delete.
	(mips_elf_make_got_per_bfd): Replace with...
	(mips_elf_add_got_entry): ...this new function.
	(mips_elf_make_got_pages_per_bfd): Replace with...
	(mips_elf_add_got_page_entry): ...this new function.
	(mips_elf_merge_got_with): Replace bfd2got argument with separate
	bfd and GOT arguments.  Use mips_elf_add_got_entry and
	mips_elf_add_got_page_entry instead of mips_elf_make_got_per_bfd
	and mips_elf_make_got_pages_per_bfd.  Use mips_elf_replace_bfd_got
	to set the BFD's GOT and free the old table.
	(mips_elf_merge_got): Replace bfd2got argument with separate
	bfd and GOT arguments.  Apply mips_elf_resolve_final_got_entries.
	Use mips_elf_count_got_entries to count the number of entries in
	each GOT.  Update the calls to mips_elf_merge_got_with.
	(mips_elf_adjust_gp): Use g->next to test for the multigot case.
	Use mips_elf_bfd_got rather than mips_elf_got_for_ibfd.
	(mips_elf_multi_got): Don't create the bfd2got hash table.
	Replace hash table traversal with a walk over the input bfds,
	updating the call to mips_elf_merge_got.  Use mips_elf_replace_bfd_got
	to set the output bfd's GOT.
	(mips_elf_lay_out_got): Rename "sub" to "ibfd".  Record that all
	bfds use the master GOT in the single-GOT case.
	(_bfd_mips_elf_finish_dynamic_sections): Use mips_elf_bfd_got
	rather than mips_elf_got_for_ibfd.

ld/testsuite/
	* ld-mips-elf/tls-hidden4.got, ld-mips-elf/tls-multi-got-1.d,
	ld-mips-elf/tls-multi-got-1.got: Update for changes in the order
	that symbols are added to per-bfd GOTs.
@
text
@d51 1
a51 1
   There are three types of entry:
d53 15
a67 30
      (1) absolute addresses
	    (abfd == NULL)
      (2) SYMBOL + OFFSET addresses, where SYMBOL is local to an input bfd
	    (abfd != NULL, symndx >= 0)
      (3) SYMBOL addresses, where SYMBOL is not local to an input bfd
	    (abfd != NULL, symndx == -1)

   Type (3) entries are treated differently for different types of GOT.
   In the "master" GOT -- i.e.  the one that describes every GOT
   reference needed in the link -- the mips_got_entry is keyed on both
   the symbol and the input bfd that references it.  If it turns out
   that we need multiple GOTs, we can then use this information to
   create separate GOTs for each input bfd.

   However, we want each of these separate GOTs to have at most one
   entry for a given symbol, so their type (3) entries are keyed only
   on the symbol.  The input bfd given by the "abfd" field is somewhat
   arbitrary in this case.

   This means that when there are multiple GOTs, each GOT has a unique
   mips_got_entry for every symbol within it.  We can therefore use the
   mips_got_entry fields (tls_type and gotidx) to track the symbol's
   GOT index.

   However, if it turns out that we need only a single GOT, we continue
   to use the master GOT to describe it.  There may therefore be several
   mips_got_entries for the same symbol, each with a different input bfd.
   We want to make sure that each symbol gets a unique GOT entry, so when
   there's a single GOT, we use the symbol's hash entry, not the
   mips_got_entry fields, to track a symbol's GOT index.  */
d70 1
a70 1
  /* The input bfd in which the symbol is defined.  */
d83 1
a83 1
       corresponding to symbol in the GOT.  The symbol's entry
a2756 23
/* got_entries only match if they're identical, except for gotidx, so
   use all fields to compute the hash, and compare the appropriate
   union members.  */

static int
mips_elf_got_entry_eq (const void *entry1, const void *entry2)
{
  const struct mips_got_entry *e1 = (struct mips_got_entry *)entry1;
  const struct mips_got_entry *e2 = (struct mips_got_entry *)entry2;

  return (e1->abfd == e2->abfd
	  && e1->symndx == e2->symndx
	  && (e1->tls_type & GOT_TLS_TYPE) == (e2->tls_type & GOT_TLS_TYPE)
	  && (!e1->abfd ? e1->d.address == e2->d.address
	      : e1->symndx >= 0 ? e1->d.addend == e2->d.addend
	      : e1->d.h == e2->d.h));
}

/* multi_got_entries are still a match in the case of global objects,
   even if the input bfd in which they're referenced differs, so the
   hash computation and compare functions are adjusted
   accordingly.  */

d2772 1
a2772 1
mips_elf_multi_got_entry_eq (const void *entry1, const void *entry2)
d2805 1
a2805 2
/* Create and return a new mips_got_info structure.  MASTER_GOT_P
   is true if this is the master GOT rather than a multigot.  */
d2808 1
a2808 1
mips_elf_create_got_info (bfd *abfd, bfd_boolean master_got_p)
d2817 2
a2818 6
  if (master_got_p)
    g->got_entries = htab_try_create (1, mips_elf_got_entry_hash,
				      mips_elf_got_entry_eq, NULL);
  else
    g->got_entries = htab_try_create (1, mips_elf_got_entry_hash,
				      mips_elf_multi_got_entry_eq, NULL);
d2843 1
a2843 1
    tdata->got = mips_elf_create_got_info (abfd, FALSE);
d4554 1
a4554 1
    g->next = mips_elf_create_got_info (abfd, FALSE);
d4864 1
a4864 1
  htab->got_info = mips_elf_create_got_info (abfd, TRUE);
@


1.336
log
@bfd/
	* elfxx-mips.c (mips_elf_obj_tdata): Add a got field.
	(mips_elf_bfd_got, mips_elf_record_got_entry): New functions.
	(mips_elf_record_global_got_symbol): Update the hash entry before
	adding the mips_got_entry.  Use mips_elf_record_got_entry to do
	the latter.
	(mips_elf_record_local_got_symbol): Use mips_elf_record_got_entry.
	(mips_elf_record_got_page_entry): Record the entry in both the
	master and bfd GOTs.
@
text
@a163 3
  /* A hash table mapping input bfds to other mips_got_info.  NULL
     unless multi-got was necessary.  */
  struct htab *bfd2got;
d174 1
a174 10
/* Map an input bfd to a got in a multi-got link.  */

struct mips_elf_bfd2got_hash
{
  bfd *bfd;
  struct mips_got_info *g;
};

/* Structure passed when traversing the bfd2got hash table, used to
   create and merge bfd's gots.  */
a177 2
  /* A hashtable that maps bfds to gots.  */
  htab_t bfd2got;
a684 2
static struct mips_got_info *mips_elf_got_for_ibfd
  (struct mips_got_info *, bfd *);
d2890 19
d3042 17
d3388 1
a3388 1
  if (g->bfd2got && ibfd)
d3394 2
a3395 1
      g = mips_elf_got_for_ibfd (g, ibfd);
d3559 1
a3559 1
  g = mips_elf_got_for_ibfd (htab->got_info, ibfd);
d3562 1
a3562 1
      g = mips_elf_got_for_ibfd (htab->got_info, abfd);
d4187 2
a4188 12
/* Compute the hash value of the bfd in a bfd2got hash entry.  */

static hashval_t
mips_elf_bfd2got_entry_hash (const void *entry_)
{
  const struct mips_elf_bfd2got_hash *entry
    = (struct mips_elf_bfd2got_hash *)entry_;

  return entry->bfd->id;
}

/* Check whether two hash entries have the same bfd.  */
d4191 1
a4191 1
mips_elf_bfd2got_entry_eq (const void *entry1, const void *entry2)
d4193 3
a4195 4
  const struct mips_elf_bfd2got_hash *e1
    = (const struct mips_elf_bfd2got_hash *)entry1;
  const struct mips_elf_bfd2got_hash *e2
    = (const struct mips_elf_bfd2got_hash *)entry2;
d4197 4
a4200 34
  return e1->bfd == e2->bfd;
}

/* In a multi-got link, determine the GOT to be used for IBFD.  G must
   be the master GOT data.  */

static struct mips_got_info *
mips_elf_got_for_ibfd (struct mips_got_info *g, bfd *ibfd)
{
  struct mips_elf_bfd2got_hash e, *p;

  if (! g->bfd2got)
    return g;

  e.bfd = ibfd;
  p = htab_find (g->bfd2got, &e);
  return p ? p->g : NULL;
}

/* Use BFD2GOT to find ABFD's got entry, creating one if none exists.
   Return NULL if an error occured.  */

static struct mips_got_info *
mips_elf_get_got_for_bfd (struct htab *bfd2got, bfd *output_bfd,
			  bfd *input_bfd)
{
  struct mips_elf_bfd2got_hash bfdgot_entry, *bfdgot;
  void **bfdgotp;

  bfdgot_entry.bfd = input_bfd;
  bfdgotp = htab_find_slot (bfd2got, &bfdgot_entry, INSERT);
  bfdgot = (struct mips_elf_bfd2got_hash *) *bfdgotp;

  if (bfdgot == NULL)
d4202 2
a4203 11
      bfdgot = ((struct mips_elf_bfd2got_hash *)
		bfd_alloc (output_bfd, sizeof (struct mips_elf_bfd2got_hash)));
      if (bfdgot == NULL)
	return NULL;

      *bfdgotp = bfdgot;

      bfdgot->bfd = input_bfd;
      bfdgot->g = mips_elf_create_got_info (input_bfd, FALSE);
      if (bfdgot->g == NULL)
	return NULL;
d4205 1
a4205 18

  return bfdgot->g;
}

/* A htab_traverse callback for the entries in the master got.
   Create one separate got for each bfd that has entries in the global
   got, such that we can tell how many local and global entries each
   bfd requires.  */

static int
mips_elf_make_got_per_bfd (void **entryp, void *p)
{
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  struct mips_elf_got_per_bfd_arg *arg = (struct mips_elf_got_per_bfd_arg *)p;
  struct mips_got_info *g;

  g = mips_elf_get_got_for_bfd (arg->bfd2got, arg->obfd, entry->abfd);
  if (g == NULL)
d4207 2
a4208 2
      arg->obfd = NULL;
      return 0;
a4209 9

  /* Insert the GOT entry in the bfd's got entry hash table.  */
  entryp = htab_find_slot (g->got_entries, entry, INSERT);
  if (*entryp != NULL)
    return 1;

  *entryp = entry;
  mips_elf_count_got_entry (arg->info, g, entry);

d4213 2
a4214 2
/* A htab_traverse callback for the page entries in the master got.
   Associate each page entry with the bfd's got.  */
d4217 1
a4217 1
mips_elf_make_got_pages_per_bfd (void **entryp, void *p)
d4219 3
a4221 3
  struct mips_got_page_entry *entry = (struct mips_got_page_entry *) *entryp;
  struct mips_elf_got_per_bfd_arg *arg = (struct mips_elf_got_per_bfd_arg *) p;
  struct mips_got_info *g;
d4223 4
a4226 2
  g = mips_elf_get_got_for_bfd (arg->bfd2got, arg->obfd, entry->abfd);
  if (g == NULL)
d4228 1
a4228 1
      arg->obfd = NULL;
d4231 5
a4235 8

  /* Insert the GOT entry in the bfd's got entry hash table.  */
  entryp = htab_find_slot (g->got_page_entries, entry, INSERT);
  if (*entryp != NULL)
    return 1;

  *entryp = entry;
  g->page_gotno += entry->num_pages;
d4239 5
a4243 5
/* Consider merging the got described by BFD2GOT with TO, using the
   information given by ARG.  Return -1 if this would lead to overflow,
   1 if they were merged successfully, and 0 if a merge failed due to
   lack of memory.  (These values are chosen so that nonnegative return
   values can be returned by a htab_traverse callback.)  */
d4246 1
a4246 1
mips_elf_merge_got_with (struct mips_elf_bfd2got_hash *bfd2got,
d4250 1
a4250 1
  struct mips_got_info *from = bfd2got->g;
a4274 3
  /* Commit to the merge.  Record that TO is now the bfd for this got.  */
  bfd2got->g = to;

d4276 4
a4279 2
  htab_traverse (from->got_entries, mips_elf_make_got_per_bfd, arg);
  if (arg->obfd == NULL)
d4282 2
a4283 2
  htab_traverse (from->got_page_entries, mips_elf_make_got_pages_per_bfd, arg);
  if (arg->obfd == NULL)
d4286 1
a4286 5
  /* We don't have to worry about releasing memory of the actual
     got entries, since they're all in the master got_entries hash
     table anyway.  */
  htab_delete (from->got_entries);
  htab_delete (from->got_page_entries);
d4290 1
a4290 1
/* Attempt to merge gots of different input bfds.  Try to use as much
d4297 3
a4299 2
static int
mips_elf_merge_gots (void **bfd2got_, void *p)
d4301 1
a4301 4
  struct mips_elf_bfd2got_hash *bfd2got
    = (struct mips_elf_bfd2got_hash *)*bfd2got_;
  struct mips_elf_got_per_bfd_arg *arg = (struct mips_elf_got_per_bfd_arg *)p;
  struct mips_got_info *g;
d4305 6
a4310 1
  g = bfd2got->g;
d4330 2
a4331 2
	  arg->primary = bfd2got->g;
	  return 1;
d4335 1
a4335 1
      result = mips_elf_merge_got_with (bfd2got, arg->primary, arg);
d4343 1
a4343 1
      result = mips_elf_merge_got_with (bfd2got, arg->current, arg);
d4354 1
a4354 1
  return 1;
d4537 1
a4537 1
  if (g->bfd2got == NULL)
d4540 1
a4540 1
  g = mips_elf_got_for_ibfd (g, ibfd);
d4564 1
a4564 1
  bfd *dynobj;
a4570 4
  g->bfd2got = htab_try_create (1, mips_elf_bfd2got_entry_hash,
				mips_elf_bfd2got_entry_eq, NULL);
  if (g->bfd2got == NULL)
    return FALSE;
a4571 1
  got_per_bfd_arg.bfd2got = g->bfd2got;
a4573 13

  /* Count how many GOT entries each input bfd requires, creating a
     map from bfd to got info while at that.  */
  htab_traverse (g->got_entries, mips_elf_make_got_per_bfd, &got_per_bfd_arg);
  if (got_per_bfd_arg.obfd == NULL)
    return FALSE;

  /* Also count how many page entries each input bfd requires.  */
  htab_traverse (g->got_page_entries, mips_elf_make_got_pages_per_bfd,
		 &got_per_bfd_arg);
  if (got_per_bfd_arg.obfd == NULL)
    return FALSE;

d4588 6
a4593 3
  htab_traverse (g->bfd2got, mips_elf_merge_gots, &got_per_bfd_arg);
  if (got_per_bfd_arg.obfd == NULL)
    return FALSE;
d4611 1
a4611 17
  {
    struct mips_elf_bfd2got_hash *bfdgot;
    void **bfdgotp;

    bfdgot = (struct mips_elf_bfd2got_hash *)bfd_alloc
      (abfd, sizeof (struct mips_elf_bfd2got_hash));

    if (bfdgot == NULL)
      return FALSE;

    bfdgot->bfd = abfd;
    bfdgot->g = g;
    bfdgotp = htab_find_slot (gg->bfd2got, bfdgot, INSERT);

    BFD_ASSERT (*bfdgotp == NULL);
    *bfdgotp = bfdgot;
  }
d8793 1
a8793 1
  bfd *sub;
d8828 1
a8828 1
  for (sub = info->input_bfds; sub; sub = sub->link_next)
d8832 1
a8832 1
      for (subsection = sub->sections;
d8899 7
d10510 1
a10510 1
      g = mips_elf_got_for_ibfd (gg, output_bfd);
@


1.335
log
@bfd/
	* elfxx-mips.c (mips_elf_recreate_got): Don't change the entry;
	create another one if necessary.
	(mips_elf_set_gotidx): New function.
	(mips_elf_set_global_gotidx): Use it.
	(mips_elf_initialize_tls_index): Likewise.  Take a
	mips_elf_traverse_got_arg as argument.
	(mips_elf_lay_out_got): Update use of mips_elf_initialize_tls_index.
	(mips_elf_multi_got): Likewise.  Cope with error returns from
	mips_elf_set_global_gotidx.
@
text
@d515 3
d2889 17
d3729 47
d3787 2
a3788 2
  struct mips_got_entry entry, **loc;
  struct mips_got_info *g;
d3812 7
a3818 3
  /* Make sure we have a GOT to put this entry into.  */
  g = htab->got_info;
  BFD_ASSERT (g != NULL);
d3823 2
a3824 27
  entry.tls_type = mips_elf_reloc_tls_type (r_type);

  loc = (struct mips_got_entry **) htab_find_slot (g->got_entries, &entry,
						   INSERT);

  /* If we've already marked this entry as needing GOT space, we don't
     need to do it again.  */
  if (*loc)
    return TRUE;

  *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);

  if (! *loc)
    return FALSE;

  entry.gotidx = -1;

  memcpy (*loc, &entry, sizeof entry);

  if (entry.tls_type == GOT_NORMAL)
    hmips->global_got_area = GGA_NORMAL;
  else if (entry.tls_type == GOT_TLS_IE)
    hmips->tls_ie_type = entry.tls_type;
  else if (entry.tls_type == GOT_TLS_GD)
    hmips->tls_gd_type = entry.tls_type;

  return TRUE;
d3836 1
a3836 1
  struct mips_got_entry entry, **loc;
d3848 1
a3848 16
  loc = (struct mips_got_entry **)
    htab_find_slot (g->got_entries, &entry, INSERT);

  if (*loc)
    return TRUE;

  entry.gotidx = -1;

  *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);

  if (! *loc)
    return FALSE;

  memcpy (*loc, &entry, sizeof entry);

  return TRUE;
d3871 1
a3871 1
  struct mips_got_info *g;
d3875 1
a3875 1
  void **loc;
d3880 2
a3881 2
  g = htab->got_info;
  BFD_ASSERT (g != NULL);
d3886 1
a3886 1
  loc = htab_find_slot (g->got_page_entries, &lookup, INSERT);
d3906 12
d3940 2
a3941 1
      g->page_gotno++;
d3968 2
a3969 1
      g->page_gotno += new_pages - old_pages;
@


1.334
log
@bfd/
	* elfxx-mips.c (mips_got_info): Add relocs field.
	(mips_elf_set_global_got_offset_arg, mips_elf_count_tls_arg): Replace
	with...
	(mips_elf_traverse_got_arg): ...this new structure.
	(mips_elf_count_local_tls_relocs): Delete.
	(mips_elf_count_global_tls_relocs): Likewise.
	(mips_elf_count_got_entry): New function.
	(mips_elf_count_local_got_entries): Likewise.
	(mips_elf_count_global_tls_entries): Take a mips_elf_traverse_got_arg
	rather than a mips_elf_count_tls_arg.  Count both relocs and entries.
	(mips_elf_record_local_got_symbol): Don't count got entries here.
	(mips_elf_make_got_per_bfd): Use mips_elf_count_got_entry.
	(mips_elf_set_global_got_offset): Split into...
	(mips_elf_set_global_got_area, mips_elf_set_global_gotidx): ...these
	new functions.  Take a mips_elf_traverse_got_arg rather than a
	mips_elf_set_global_got_offset_arg.  Don't count TLS relocs here.
	Use g->relocs to record the number of relocs needed for global GOT
	entries.
	(mips_elf_multi_got): Use mips_elf_traverse_got_arg rather than
	mips_elf_set_global_got_offset_arg.  Use the relocs field to count
	relocations.  Update for above function split.
	(mips_elf_lay_out_got): Use mips_elf_count_local_got_entries
	to count both the number of GOT entries and the number of TLS
	relocs required by local entries.  Likewise
	mips_elf_count_global_tls_entries and global entries.
	Remove uses of mips_elf_count_local_tls_relocs and
	mips_elf_count_global_tls_relocs.
@
text
@d3994 1
a3994 1
  struct mips_got_entry *entry;
d3999 4
a4002 1
  if (entry->abfd != NULL && entry->symndx == -1)
d4006 2
d4009 1
a4009 2
      while (h->root.root.type == bfd_link_hash_indirect
	     || h->root.root.type == bfd_link_hash_warning)
d4014 2
d4025 13
a4037 1
    *slot = entry;
d4370 29
a4398 2
/* Set the TLS GOT index for the GOT entry in ENTRYP.  ENTRYP's NEXT field
   is null iff there is just a single GOT.  */
d4401 1
a4401 1
mips_elf_initialize_tls_index (void **entryp, void *p)
d4403 3
a4405 2
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  struct mips_got_info *g = p;
d4410 1
d4415 3
a4417 1
  next_index = MIPS_ELF_GOT_SIZE (entry->abfd) * (long) g->tls_assigned_gotno;
d4453 5
a4457 1
      entry->gotidx = next_index;
d4487 1
a4487 1
   the size of one GOT entry.  */
d4501 7
a4507 1
      entry->gotidx = arg->value * (long) arg->g->assigned_gotno++;
d4708 5
a4712 1
      htab_traverse (g->got_entries, mips_elf_initialize_tls_index, g);
d4740 4
a4743 1
      BFD_ASSERT (g->assigned_gotno - g->local_gotno <= g->global_gotno);
a4744 1
      g->assigned_gotno = save_assign;
d8945 6
a8950 1
      htab_traverse (g->got_entries, mips_elf_initialize_tls_index, g);
@


1.333
log
@bfd/
	* elfxx-mips.c (mips_got_entry): Update comment above tls_type entry
	to say that each structure represents only one type of TLS reference.
	(GOT_TLS_TYPE): New define.
	(mips_elf_link_hash_entry): Temporarily split tls_type and
	tls_got_offset into two variables each.
	(mips_elf_link_hash_newfunc): Update accordingly.
	(mips_elf_got_entry_eq, mips_elf_got_entry_hash)
	(mips_elf_multi_got_entry_eq): Require the tls_type to be the same.
	(mips_elf_reloc_tls_type, mips_tls_got_entries): New functions.
	(mips_tls_got_relocs): Use a switch statement.
	(mips_elf_count_global_tls_entries): Handle the new hash entry fields.
	(mips_elf_initialize_tls_slots): Use a switch statement.  Avoid
	local "offset" variable.
	(mips_tls_got_index): Remove r_type argument and assert.  Remove
	code that handled entries with two TLS types; always use the
	original got_index instead.
	(mips_tls_single_got_index): New function.
	(mips_elf_local_got_index): Use entry->tls_type to check for
	TLS entries.  Use mips_tls_single_got_index.  Update call to
	mips_tls_got_index.
	(mips_elf_global_got_index): Use mips_elf_reloc_tls_type.
	Use p->tls_type to check for TLS entries.  Update call to
	mips_tls_got_index.  Use mips_tls_single_got_index.
	(mips_elf_create_local_got_entry): Use mips_elf_reloc_tls_type.
	Use entry.tls_type to check for TLS entries.
	(mips_elf_record_global_got_symbol): Replace tls_flag argument
	with r_type argument.  Use mips_elf_reloc_tls_type.
	Set up the new hash entry fields.
	(mips_elf_record_local_got_symbol): Replace tls_flag argument
	with r_type argument.  Use mips_elf_reloc_tls_type and
	mips_tls_got_entries.  Remove code that handled entries
	with multiple TLS types.
	(mips_elf_make_got_per_bfd): Use mips_tls_got_entries.
	(mips_elf_initialize_tls_index): Handle new hash entry fields.
	Use equality rather than masks when checking for specific TLS types.
	Use mips_tls_got_entries.  Remove code that handled entries
	with multiple TLS types.
	(mips_elf_calculate_relocation): Use TLS_RELOC_P instead of
	testing the hash table entry.
	(_bfd_mips_elf_check_relocs): Update calls to
	mips_elf_record_global_got_symbol and mips_elf_record_local_got_symbol.
	(_bfd_mips_elf_finish_dynamic_symbol): Don't check h->type.
	(_bfd_mips_elf_copy_indirect_symbol): Handle new hash entry fields.
@
text
@d156 2
d215 2
a216 1
/* Another structure used to pass arguments for got entries traversal.  */
d218 1
a218 1
struct mips_elf_set_global_got_offset_arg
d220 1
a222 11
  unsigned int needed_relocs;
  struct bfd_link_info *info;
};

/* A structure used to count TLS relocations or GOT entries, for GOT
   entry or ELF symbol table traversal.  */

struct mips_elf_count_tls_arg
{
  struct bfd_link_info *info;
  unsigned int needed;
d2995 2
a2996 2
/* Count the number of TLS relocations required for the GOT entry in
   ARG1, if it describes a local symbol.  */
d2998 4
a3001 2
static int
mips_elf_count_local_tls_relocs (void **arg1, void *arg2)
d3003 1
a3003 2
  struct mips_got_entry *entry = * (struct mips_got_entry **) arg1;
  struct mips_elf_count_tls_arg *arg = arg2;
d3005 12
a3016 4
  if (entry->abfd != NULL && entry->symndx != -1)
    arg->needed += mips_tls_got_relocs (arg->info, entry->tls_type, NULL);

  return 1;
d3019 3
a3021 2
/* Count the number of TLS GOT entries required for the global (or
   forced-local) symbol in ARG1.  */
d3024 1
a3024 1
mips_elf_count_global_tls_entries (void *arg1, void *arg2)
d3026 2
a3027 3
  struct mips_elf_link_hash_entry *hm
    = (struct mips_elf_link_hash_entry *) arg1;
  struct mips_elf_count_tls_arg *arg = arg2;
d3029 12
a3040 8
  if (hm->root.root.type == bfd_link_hash_indirect
      || hm->root.root.type == bfd_link_hash_warning)
    return 1;

  if (hm->tls_gd_type)
    arg->needed += 2;
  if (hm->tls_ie_type)
    arg->needed += 1;
d3045 2
a3046 2
/* Count the number of TLS relocations required for the global (or
   forced-local) symbol in ARG1.  */
d3049 1
a3049 1
mips_elf_count_global_tls_relocs (void *arg1, void *arg2)
d3051 2
a3052 3
  struct mips_elf_link_hash_entry *hm
    = (struct mips_elf_link_hash_entry *) arg1;
  struct mips_elf_count_tls_arg *arg = arg2;
d3054 1
d3059 13
a3071 2
  arg->needed += mips_tls_got_relocs (arg->info, hm->tls_ie_type, &hm->root);
  arg->needed += mips_tls_got_relocs (arg->info, hm->tls_gd_type, &hm->root);
a3808 12
  if (entry.tls_type)
    {
      if (entry.tls_type != GOT_TLS_LDM)
	g->tls_gotno += mips_tls_got_entries (entry.tls_type);
      else if (g->tls_ldm_offset == MINUS_ONE)
	{
	  g->tls_ldm_offset = MINUS_TWO;
	  g->tls_gotno += mips_tls_got_entries (entry.tls_type);
	}
    }
  else
    g->local_gotno += 1;
d4200 1
a4200 7

  if (entry->tls_type)
    g->tls_gotno += mips_tls_got_entries (entry->tls_type & GOT_TLS_TYPE);
  else if (entry->symndx >= 0 || entry->d.h->global_got_area == GGA_NONE)
    g->local_gotno += 1;
  else
    g->global_gotno += 1;
d4412 24
a4435 13
/* If passed a NULL mips_got_info in the argument, set the marker used
   to tell whether a global symbol needs a got entry (in the primary
   got) to the given VALUE.

   If passed a pointer G to a mips_got_info in the argument (it must
   not be the primary GOT), compute the offset from the beginning of
   the (primary) GOT section to the entry in G corresponding to the
   global symbol.  G's assigned_gotno must contain the index of the
   first available global GOT entry in G.  VALUE must contain the size
   of a GOT entry in bytes.  For each global GOT entry that requires a
   dynamic relocation, NEEDED_RELOCS is incremented, and the symbol is
   marked as not eligible for lazy resolution through a function
   stub.  */
d4437 1
a4437 1
mips_elf_set_global_got_offset (void **entryp, void *p)
d4439 2
a4440 9
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  struct mips_elf_set_global_got_offset_arg *arg
    = (struct mips_elf_set_global_got_offset_arg *)p;
  struct mips_got_info *g = arg->g;

  if (g && entry->tls_type != GOT_NORMAL)
    arg->needed_relocs +=
      mips_tls_got_relocs (arg->info, entry->tls_type,
			   entry->symndx == -1 ? &entry->d.h->root : NULL);
d4442 2
d4448 6
a4453 11
      if (g)
	{
	  entry->gotidx = arg->value * (long) g->assigned_gotno++;
	  if (arg->info->shared
	      || (elf_hash_table (arg->info)->dynamic_sections_created
		  && entry->d.h->root.def_dynamic
		  && !entry->d.h->root.def_regular))
	    ++arg->needed_relocs;
	}
      else
	entry->d.h->global_got_area = arg->value;
d4515 1
a4515 1
  struct mips_elf_set_global_got_offset_arg set_got_offset_arg;
d4553 1
a4553 1
     See the calls to mips_elf_set_global_got_offset below for more
d4604 5
a4608 7
  set_got_offset_arg.g = NULL;
  set_got_offset_arg.value = GGA_RELOC_ONLY;
  htab_traverse (gg->got_entries, mips_elf_set_global_got_offset,
		 &set_got_offset_arg);
  set_got_offset_arg.value = GGA_NORMAL;
  htab_traverse (g->got_entries, mips_elf_set_global_got_offset,
		 &set_got_offset_arg);
a4664 2
  set_got_offset_arg.value = MIPS_ELF_GOT_SIZE (abfd);
  set_got_offset_arg.info = info;
d4669 2
a4670 1
      /* Assign offsets to global GOT entries.  */
d4673 4
a4676 6
      set_got_offset_arg.g = g;
      set_got_offset_arg.needed_relocs = 0;
      htab_traverse (g->got_entries,
		     mips_elf_set_global_got_offset,
		     &set_got_offset_arg);
      needed_relocs += set_got_offset_arg.needed_relocs;
d4682 1
a4682 1
	  needed_relocs += g->local_gotno - g->assigned_gotno;
d4688 1
d4690 1
d8773 1
a8773 1
  struct mips_elf_count_tls_arg count_tls_arg;
d8838 5
a8842 2
  s->size += g->local_gotno * MIPS_ELF_GOT_SIZE (output_bfd);
  s->size += g->global_gotno * MIPS_ELF_GOT_SIZE (output_bfd);
a8846 2
  count_tls_arg.info = info;
  count_tls_arg.needed = 0;
d8849 4
a8852 2
			  &count_tls_arg);
  g->tls_gotno += count_tls_arg.needed;
a8877 2
      struct mips_elf_count_tls_arg arg;

d8885 2
a8886 8
      arg.info = info;
      arg.needed = 0;
      htab_traverse (g->got_entries, mips_elf_count_local_tls_relocs, &arg);
      elf_link_hash_traverse (elf_hash_table (info),
			      mips_elf_count_global_tls_relocs,
			      &arg);
      if (arg.needed)
	mips_elf_allocate_dynamic_relocations (dynobj, info, arg.needed);
@


1.332
log
@bfd/
	* elfxx-mips.c (mips_elf_multi_got_entry_hash): Rename to...
	(mips_elf_got_entry_hash): ...this, deleting the old version.
	(mips_elf_create_got_info): Use mips_elf_got_entry_hash for
	both types of GOT.

ld/testsuite/
	* ld-mips-elf/tls-hidden3.d, ld-mips-elf/tls-hidden3.got,
	ld-mips-elf/tls-multi-got-1.got, ld-mips-elf/tlsbin-o32.d,
	ld-mips-elf/tlsbin-o32.got, ld-mips-elf/tlsdyn-o32-1.d,
	ld-mips-elf/tlsdyn-o32-1.got, ld-mips-elf/tlsdyn-o32-2.d,
	ld-mips-elf/tlsdyn-o32-2.got, ld-mips-elf/tlsdyn-o32-3.d,
	ld-mips-elf/tlsdyn-o32-3.got, ld-mips-elf/tlsdyn-o32.d,
	ld-mips-elf/tlsdyn-o32.got, ld-mips-elf/tlslib-o32.d,
	ld-mips-elf/tlslib-o32.got, ld-mips-elf/tlslib-o32-hidden.got,
	ld-mips-elf/tlslib-o32-ver.got: Adjust GOT layout for new
	got_entry hash function.
@
text
@d104 3
a106 5
  /* The TLS types included in this GOT entry (specifically, GD and
     IE).  The GD and IE flags can be added as we encounter new
     relocations.  LDM can also be set; it will always be alone, not
     combined with any GD or IE flags.  An LDM GOT entry will be
     a local symbol entry with r_symndx == 0.  */
d364 1
d367 2
a368 1
  unsigned char tls_type;
d370 1
a370 1
  /* This is only used in single-GOT mode; in multi-GOT mode there
d373 3
a375 4
     structures all referring to the same GOT slot.  It might be
     possible to use root.got.offset instead, but that field is
     overloaded already.  */
  bfd_vma tls_got_offset;
d1113 2
a1114 1
      ret->tls_type = GOT_NORMAL;
d2802 6
a2807 8
  /* An LDM entry can only match another LDM entry.  */
  if ((e1->tls_type ^ e2->tls_type) & GOT_TLS_LDM)
    return 0;

  return e1->abfd == e2->abfd && e1->symndx == e2->symndx
    && (! e1->abfd ? e1->d.address == e2->d.address
	: e1->symndx >= 0 ? e1->d.addend == e2->d.addend
	: e1->d.h == e2->d.h);
d2820 7
a2826 9
  return entry->symndx
    + (! entry->abfd
       ? mips_elf_hash_bfd_vma (entry->d.address)
       : entry->symndx >= 0
       ? ((entry->tls_type & GOT_TLS_LDM)
	  ? (GOT_TLS_LDM << 17)
	  : (entry->abfd->id
	     + mips_elf_hash_bfd_vma (entry->d.addend)))
       : entry->d.h->root.root.root.hash);
d2835 7
a2841 13
  /* Any two LDM entries match.  */
  if (e1->tls_type & e2->tls_type & GOT_TLS_LDM)
    return 1;

  /* Nothing else matches an LDM entry.  */
  if ((e1->tls_type ^ e2->tls_type) & GOT_TLS_LDM)
    return 0;

  return e1->symndx == e2->symndx
    && (e1->symndx >= 0 ? e1->abfd == e2->abfd && e1->d.addend == e2->d.addend
	: e1->abfd == NULL || e2->abfd == NULL
	? e1->abfd == e2->abfd && e1->d.address == e2->d.address
	: e1->d.h == e2->d.h);
d2924 37
a2969 1
  int ret = 0;
d2984 1
a2984 1
    return FALSE;
d2986 1
a2986 1
  if (tls_type & GOT_TLS_GD)
d2988 2
a2989 4
      ret++;
      if (indx != 0)
	ret++;
    }
d2991 2
a2992 2
  if (tls_type & GOT_TLS_IE)
    ret++;
d2994 2
a2995 2
  if ((tls_type & GOT_TLS_LDM) && info->shared)
    ret++;
d2997 3
a2999 1
  return ret;
d3031 1
a3031 1
  if (hm->tls_type & GOT_TLS_GD)
d3033 1
a3033 1
  if (hm->tls_type & GOT_TLS_IE)
d3053 2
a3054 1
  arg->needed += mips_tls_got_relocs (arg->info, hm->tls_type, &hm->root);
d3102 1
a3102 1
  bfd_vma offset, offset2;
d3139 1
a3139 2
  /* General Dynamic.  */
  if (*tls_type_p & GOT_TLS_GD)
d3141 3
a3143 2
      offset = got_offset;
      offset2 = offset + MIPS_ELF_GOT_SIZE (abfd);
d3150 1
a3150 1
	     sgot->output_offset + sgot->output_section->vma + offset);
d3156 1
a3156 1
	       sgot->output_offset + sgot->output_section->vma + offset2);
d3159 1
a3159 1
			       sgot->contents + offset2);
d3164 1
a3164 1
			     sgot->contents + offset);
d3166 1
a3166 1
			     sgot->contents + offset2);
d3168 1
d3170 2
a3171 8
      got_offset += 2 * MIPS_ELF_GOT_SIZE (abfd);
    }

  /* Initial Exec model.  */
  if (*tls_type_p & GOT_TLS_IE)
    {
      offset = got_offset;

d3176 1
a3176 1
			       sgot->contents + offset);
d3179 1
a3179 1
			       sgot->contents + offset);
d3184 1
a3184 1
	     sgot->output_offset + sgot->output_section->vma + offset);
d3188 2
a3189 2
			   sgot->contents + offset);
    }
d3191 1
a3191 2
  if (*tls_type_p & GOT_TLS_LDM)
    {
d3206 4
d3215 4
a3218 4
/* Return the GOT index to use for a relocation of type R_TYPE against
   a symbol accessed using TLS_TYPE models.  The GOT entries for this
   symbol in this GOT start at GOT_INDEX.  This function initializes the
   GOT entries and corresponding relocations.  */
d3222 1
a3222 1
		    int r_type, struct bfd_link_info *info,
d3225 3
a3227 3
  BFD_ASSERT (tls_gottprel_reloc_p (r_type)
	      || tls_gd_reloc_p (r_type)
	      || tls_ldm_reloc_p (r_type));
d3229 2
a3230 1
  mips_elf_initialize_tls_slots (abfd, got_index, tls_type, info, h, symbol);
d3232 4
d3237 2
a3238 8
    {
      BFD_ASSERT (*tls_type & GOT_TLS_IE);
      if (*tls_type & GOT_TLS_GD)
	return got_index + 2 * MIPS_ELF_GOT_SIZE (abfd);
      else
	return got_index;
    }

d3240 3
a3242 12
    {
      BFD_ASSERT (*tls_type & GOT_TLS_GD);
      return got_index;
    }

  if (tls_ldm_reloc_p (r_type))
    {
      BFD_ASSERT (*tls_type & GOT_TLS_LDM);
      return got_index;
    }

  return got_index;
d3302 1
a3302 1
  if (TLS_RELOC_P (r_type))
d3307 1
a3307 2
	return mips_tls_got_index (abfd, h->tls_got_offset, &h->tls_type,
				   r_type, info, h, value);
d3310 1
a3310 1
				   r_type, info, h, value);
d3343 1
a3343 1
	  e.tls_type = 0;
d3347 1
a3347 1
	  BFD_ASSERT (p->gotidx > 0);
d3349 1
a3349 1
	  if (TLS_RELOC_P (r_type))
d3359 1
a3359 1
	      return mips_tls_got_index (abfd, p->gotidx, &p->tls_type, r_type,
d3383 1
a3383 2
      got_index = mips_tls_got_index (abfd, hm->tls_got_offset, &hm->tls_type,
				      r_type, info, hm, value);
d3499 1
a3499 1
  entry.tls_type = 0;
d3511 1
a3511 1
  if (TLS_RELOC_P (r_type))
a3517 1
	  entry.tls_type = GOT_TLS_LDM;
a3541 1
  entry.tls_type = 0;
d3692 2
a3693 3
/* If H is a symbol that needs a global GOT entry, but has a dynamic
   symbol table index lower than any we've seen to date, record it for
   posterity.  FOR_CALL is true if the caller is only interested in
d3699 1
a3699 2
				   bfd_boolean for_call,
				   unsigned char tls_flag)
d3735 1
a3735 1
  entry.tls_type = 0;
d3743 1
a3743 4
    {
      (*loc)->tls_type |= tls_flag;
      return TRUE;
    }
a3750 1
  entry.tls_type = tls_flag;
d3754 1
a3754 1
  if (tls_flag == 0)
d3756 4
d3764 2
a3765 2
/* Reserve space in G for a GOT entry containing the value of symbol
   SYMNDX in input bfd ABDF, plus ADDEND.  */
d3769 1
a3769 2
				  struct bfd_link_info *info,
				  unsigned char tls_flag)
d3784 1
a3784 1
  entry.tls_type = tls_flag;
d3789 1
a3789 13
    {
      if (tls_flag == GOT_TLS_GD && !((*loc)->tls_type & GOT_TLS_GD))
	{
	  g->tls_gotno += 2;
	  (*loc)->tls_type |= tls_flag;
	}
      else if (tls_flag == GOT_TLS_IE && !((*loc)->tls_type & GOT_TLS_IE))
	{
	  g->tls_gotno += 1;
	  (*loc)->tls_type |= tls_flag;
	}
      return TRUE;
    }
d3792 1
a3792 1
  if (tls_flag != 0)
d3794 2
a3795 5
      entry.tls_type = tls_flag;
      if (tls_flag == GOT_TLS_IE)
	g->tls_gotno += 1;
      else if (tls_flag == GOT_TLS_GD)
	g->tls_gotno += 2;
d3799 1
a3799 1
	  g->tls_gotno += 2;
d3803 1
a3803 4
    {
      g->local_gotno += 1;
      entry.tls_type = 0;
    }
d4197 1
a4197 6
    {
      if (entry->tls_type & (GOT_TLS_GD | GOT_TLS_LDM))
	g->tls_gotno += 2;
      if (entry->tls_type & GOT_TLS_IE)
	g->tls_gotno += 1;
    }
d4199 1
a4199 1
    ++g->local_gotno;
d4201 1
a4201 1
    ++g->global_gotno;
d4365 2
a4366 1
  if (entry->tls_type == 0)
d4375 15
a4389 5
      if (entry->d.h->tls_type & GOT_TLS_OFFSET_DONE)
	return 1;
      entry->d.h->tls_type |= GOT_TLS_OFFSET_DONE;
      entry->d.h->tls_got_offset = next_index;
      tls_type = entry->d.h->tls_type;
d4393 1
a4393 1
      if (entry->tls_type & GOT_TLS_LDM)
a4405 1
      tls_type = entry->tls_type;
d4409 1
a4409 5
  if (tls_type & (GOT_TLS_GD | GOT_TLS_LDM))
    g->tls_assigned_gotno += 2;
  if (tls_type & GOT_TLS_IE)
    g->tls_assigned_gotno += 1;

d5389 1
a5389 1
	      if (h->tls_type == GOT_NORMAL
d7977 1
a7977 1
						 rel->r_addend, info, 0))
d8010 2
a8011 1
	      if (!mips_elf_record_global_got_symbol (h, abfd, info, TRUE, 0))
d8076 1
a8076 1
						       FALSE, 0))
d8102 13
a8114 26
	  {
	    unsigned char flag;

	    flag = (tls_gd_reloc_p (r_type)
		    ? GOT_TLS_GD
		    : tls_ldm_reloc_p (r_type) ? GOT_TLS_LDM : GOT_TLS_IE);
	    if (h != NULL)
	      {
		struct mips_elf_link_hash_entry *hmips =
		  (struct mips_elf_link_hash_entry *) h;
		hmips->tls_type |= flag;

		if (h && !mips_elf_record_global_got_symbol (h, abfd, info,
							     FALSE, flag))
		  return FALSE;
	      }
	    else
	      {
		BFD_ASSERT (flag == GOT_TLS_LDM || r_symndx != STN_UNDEF);

		if (!mips_elf_record_local_got_symbol (abfd, r_symndx,
						       rel->r_addend,
						       info, flag))
		  return FALSE;
	      }
	  }
d10018 1
a10018 1
  if (hmips->global_got_area != GGA_NONE && g->next && h->type != STT_TLS)
d11533 4
a11536 2
  if (dirmips->tls_type == 0)
    dirmips->tls_type = indmips->tls_type;
@


1.331
log
@bfd/
	* elfxx-mips.c (mips_elf_create_got_info): New function.
	(mips_elf_get_got_for_bfd, mips_elf_multi_got): Use it.
	(mips_elf_create_got_section): Likewise.
@
text
@a701 2
static hashval_t mips_elf_got_entry_hash
  (const void *);
a2795 13
static hashval_t
mips_elf_got_entry_hash (const void *entry_)
{
  const struct mips_got_entry *entry = (struct mips_got_entry *)entry_;

  return entry->symndx
    + ((entry->tls_type & GOT_TLS_LDM) << 17)
    + (! entry->abfd ? mips_elf_hash_bfd_vma (entry->d.address)
       : entry->abfd->id
         + (entry->symndx >= 0 ? mips_elf_hash_bfd_vma (entry->d.addend)
	    : entry->d.h->root.root.root.hash));
}

d2818 1
a2818 1
mips_elf_multi_got_entry_hash (const void *entry_)
d2890 1
a2890 1
    g->got_entries = htab_try_create (1, mips_elf_multi_got_entry_hash,
@


1.330
log
@bfd/
	* elfxx-mips.c (mips_elf_record_local_got_symbol): Always set
	gotidx to -1.
@
text
@d2888 30
a4170 1
  struct mips_got_info *g;
a4185 5
      g = ((struct mips_got_info *)
	   bfd_alloc (output_bfd, sizeof (struct mips_got_info)));
      if (g == NULL)
	return NULL;

d4187 2
a4188 18
      bfdgot->g = g;

      g->global_gotno = 0;
      g->reloc_only_gotno = 0;
      g->local_gotno = 0;
      g->page_gotno = 0;
      g->assigned_gotno = -1;
      g->tls_gotno = 0;
      g->tls_assigned_gotno = 0;
      g->tls_ldm_offset = MINUS_ONE;
      g->got_entries = htab_try_create (1, mips_elf_multi_got_entry_hash,
					mips_elf_multi_got_entry_eq, NULL);
      if (g->got_entries == NULL)
	return NULL;

      g->got_page_entries = htab_try_create (1, mips_got_page_entry_hash,
					     mips_got_page_entry_eq, NULL);
      if (g->got_page_entries == NULL)
a4189 3

      g->bfd2got = NULL;
      g->next = NULL;
d4590 1
a4590 26
    {
      g->next = (struct mips_got_info *)
	bfd_alloc (abfd, sizeof (struct mips_got_info));
      if (g->next == NULL)
	return FALSE;

      g->next->global_gotno = 0;
      g->next->reloc_only_gotno = 0;
      g->next->local_gotno = 0;
      g->next->page_gotno = 0;
      g->next->tls_gotno = 0;
      g->next->assigned_gotno = 0;
      g->next->tls_assigned_gotno = 0;
      g->next->tls_ldm_offset = MINUS_ONE;
      g->next->got_entries = htab_try_create (1, mips_elf_multi_got_entry_hash,
					      mips_elf_multi_got_entry_eq,
					      NULL);
      if (g->next->got_entries == NULL)
	return FALSE;
      g->next->got_page_entries = htab_try_create (1, mips_got_page_entry_hash,
						   mips_got_page_entry_eq,
						   NULL);
      if (g->next->got_page_entries == NULL)
	return FALSE;
      g->next->bfd2got = NULL;
    }
a4873 2
  struct mips_got_info *g;
  bfd_size_type amt;
d4913 1
a4913 22
  amt = sizeof (struct mips_got_info);
  g = bfd_alloc (abfd, amt);
  if (g == NULL)
    return FALSE;
  g->global_gotno = 0;
  g->reloc_only_gotno = 0;
  g->tls_gotno = 0;
  g->local_gotno = 0;
  g->page_gotno = 0;
  g->assigned_gotno = 0;
  g->bfd2got = NULL;
  g->next = NULL;
  g->tls_ldm_offset = MINUS_ONE;
  g->got_entries = htab_try_create (1, mips_elf_got_entry_hash,
				    mips_elf_got_entry_eq, NULL);
  if (g->got_entries == NULL)
    return FALSE;
  g->got_page_entries = htab_try_create (1, mips_got_page_entry_hash,
					 mips_got_page_entry_eq, NULL);
  if (g->got_page_entries == NULL)
    return FALSE;
  htab->got_info = g;
@


1.329
log
@bfd/
	* elfxx-mips.c (mips_elf_multi_got): Simplify size calculation.
@
text
@d3780 1
a3782 1
      entry.gotidx = -1;
d3796 1
a3796 1
      entry.gotidx = g->local_gotno++;
@


1.328
log
@bfd/
	* elfxx-mips.c (mips_got_info): Move global_gotsym to...
	(mips_elf_link_hash_table): ...here.  Update rest of file accordingly.
@
text
@d4708 1
a4708 3
  got->size = (gg->next->local_gotno
	       + gg->next->global_gotno
	       + gg->next->tls_gotno) * MIPS_ELF_GOT_SIZE (abfd);
@


1.327
log
@bfd/
	* elfxx-mips.c (mips_elf_count_global_tls_entries)
	(mips_elf_count_global_tls_relocs): Don't count indirect or
	warning symbols.
	(mips_elf_multi_got, mips_elf_lay_out_got): Assert that the right
	number of TLS entries were allocated.

ld/testsuite/
	* ld-mips-elf/tlsdyn-o32-2.got, ld-mips-elf/tlsdyn-o32-3.got: Remove
	unused GOT entries.
@
text
@a144 3
  /* The global symbol in the GOT with the lowest index in the dynamic
     symbol table.  */
  struct elf_link_hash_entry *global_gotsym;
d460 4
d3338 2
a3339 2
  if (gg->global_gotsym != NULL)
    global_got_dynindx = gg->global_gotsym->dynindx;
d3626 1
a3626 1
  g->global_gotsym = hsd.low;
a4164 1
      g->global_gotsym = NULL;
a4463 2
	  BFD_ASSERT (g->global_gotsym == NULL);

a4590 1
      g->next->global_gotsym = NULL;
a4940 1
  g->global_gotsym = NULL;
d10656 1
a10656 1
	      if (gg->global_gotsym)
d10658 1
a10658 1
		  dyn.d_un.d_val = gg->global_gotsym->dynindx;
@


1.326
log
@bfd/
	* elfxx-mips.c (mips_elf_sort_hash_table_f): Remove asserts.
@
text
@d2985 4
d3007 4
d4699 1
d8968 2
@


1.325
log
@bfd/
	* elfxx-mips.c (mips_elf_merge_got_with): Only use arg->global_count
	if there are TLS relocations.
@
text
@a3642 2
      BFD_ASSERT (h->tls_type == GOT_NORMAL);

a3647 2
      BFD_ASSERT (h->tls_type == GOT_NORMAL);

@


1.324
log
@bfd/
	* elfxx-mips.c (mips_elf_recreate_got): Remove free.
	(mips_elf_resolve_final_got_entries): Remove bogus comment.
@
text
@d4278 2
a4279 2
  /* If we're merging with the primary got, we will always have
     the full set of global entries.  Otherwise estimate those
d4281 1
a4281 1
  if (to == arg->primary)
@


1.323
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@a4004 2
  else
    free (entry);
a4027 2
      /* Each entry in g->got_entries has either been copied to new_got
	 or freed.  Now delete the hash table itself.  */
@


1.322
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@a422 5
#if 0
  /* We no longer use this.  */
  /* String section indices for the dynamic section symbols.  */
  bfd_size_type dynsym_sec_strindex[SIZEOF_MIPS_DYNSYM_SECNAMES];
#endif
d12947 1
a12947 1
  ret = bfd_malloc (amt);
a12959 30
#if 0
  /* We no longer use this.  */
  for (i = 0; i < SIZEOF_MIPS_DYNSYM_SECNAMES; i++)
    ret->dynsym_sec_strindex[i] = (bfd_size_type) -1;
#endif
  ret->procedure_count = 0;
  ret->compact_rel_size = 0;
  ret->use_rld_obj_head = FALSE;
  ret->rld_symbol = NULL;
  ret->mips16_stubs_seen = FALSE;
  ret->use_plts_and_copy_relocs = FALSE;
  ret->is_vxworks = FALSE;
  ret->small_data_overflow_reported = FALSE;
  ret->srelbss = NULL;
  ret->sdynbss = NULL;
  ret->srelplt = NULL;
  ret->srelplt2 = NULL;
  ret->sgotplt = NULL;
  ret->splt = NULL;
  ret->sstubs = NULL;
  ret->sgot = NULL;
  ret->got_info = NULL;
  ret->plt_header_size = 0;
  ret->plt_entry_size = 0;
  ret->lazy_stub_count = 0;
  ret->function_stub_size = 0;
  ret->strampoline = NULL;
  ret->la25_stubs = NULL;
  ret->add_stub_section = NULL;

@


1.321
log
@	* archures.c: Add support for MIPS r5900
	* bfd-in2.h: Add support for MIPS r5900
	* config.bfd: Add support for Sony Playstation 2
	* cpu-mips.c: Add support for MIPS r5900
	* elfxx-mips.c: Add support for MIPS r5900 (extension of r4000)

	* config/tc-mips.c: Add support for MIPS r5900
	Add M_LQ_AB and M_SQ_AB to support large values for instructions lq and sq.
	* config/tc-mips.c (can_swap_branch_p, get_append_method): Detect some conditional short loops to fix a bug on the r5900 by NOP in the branch delay slot.
	* config/tc-mips.c (M_MUL): Support 3 operands in multu on r5900.
	* config/tc-mips.c (M_TRUNCWS): Support trunc.w.s on r5900 in MIPS ISA I.
	* config/tc-mips.c (s_mipsset): Force 32 bit floating point on r5900.
	* configure.in: Detect CPU type when target string contains r5900 (e.g. mips64r5900el-linux-gnu).

	* config/tc-mips.c (mips_ip): Check parameter range of instructions mfps and mtps on r5900.

	* elf/mips.h: Add MIPS machine variant number for r5900 which is compatible with old Playstation 2 software.
	* opcode/mips.h: Add support for r5900 instructions including lq and sq.

	* configure.tgt: Support ELF files for Sony Playstation 2 (for ps2dev and ps2sdk).
	* emulparams/elf32lr5900n32.sh: Create linker script for Sony Playstation 2 ELF files using MIPS ABI n32.
	* emulparams/elf32lr5900.sh: Create linker script for Sony Playstation 2 ELF files using MIPS ABI o32.
	* Makefile.am: Add linker scripts for Sony Playstation 2 ELF files.

	* opcodes/mips-dis.c: Add names for CP0 registers of r5900.
	* opcodes/mips-opc.c: Add M_SQ_AB and M_LQ_AB to support larger range for instructions sq and lq.

	* opcodes/mips-opc.c: Add support for MIPS r5900 CPU.
	Add support for 128 bit MMI (Multimedia Instructions).
	Add support for EE instructions (Emotion Engine).
	Disable unsupported floating point instructions (64 bit and undefined compare operations).
	Enable instructions of MIPS ISA IV which are supported by r5900.
	Disable 64 bit co processor instructions.
	Disable 64 bit multiplication and division instructions.
	Disable instructions for co-processor 2 and 3, because these are not supported (preparation for later VU0 support (Vector Unit)).
	Disable cvt.w.s because this behaves like trunc.w.s and the correct execution can't be ensured on r5900.
	Add trunc.w.s using the opcode encoding of cvt.w.s on r5900. This will confuse less developers and compilers.
@
text
@d5333 1
a5333 1
	      
d5922 1
a5922 1
   relocation applies.  
d7843 1
a7843 1
	  
d7845 1
a7845 1
	  
d7850 1
a7850 1
	  
d14035 1
a14035 1
	      || mips_mach_extends_p (bfd_get_mach (obfd), 
@


1.320
log
@	* elfxx-mips.c (allocate_dynrelocs): Correct test for symbol
	defined in a regular file to include common symbols.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
d6297 3
d11032 4
d13718 1
@


1.319
log
@	PR ld/10629
	* elfxx-mips.c (mips_elf_link_hash_table): Update comment for
	use_rld_obj_head.
	(_bfd_mips_elf_create_dynamic_sections): Always create a
	.rld_map section if no __rld_obj_head symbol has been seen.
@
text
@d8571 1
a8571 1
	  || !h->def_regular
@


1.318
log
@	bfd/
	* elf32-mips.c (bfd_elf32_mkobject): New macro.
	* elf64-mips.c (bfd_elf64_mkobject): Likewise.
	* elfn32-mips.c (bfd_elf32_mkobject): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): New prototype.
	* elfxx-mips.c (mips_elf_obj_tdata): New struct.
	(mips_elf_tdata): New macro.
	(_bfd_mips_elf_mkobject): New function.
	(mips_elf_merge_obj_attributes): Report the originating input BFD
	on attribute conflicts.

	ld/testsuite/
	* ld-mips-elf/attr-gnu-4-12.d: Update the warning message.
	* ld-mips-elf/attr-gnu-4-13.d: Likewise.
	* ld-mips-elf/attr-gnu-4-14.d: Likewise.
	* ld-mips-elf/attr-gnu-4-15.d: Likewise.
	* ld-mips-elf/attr-gnu-4-21.d: Likewise.
	* ld-mips-elf/attr-gnu-4-23.d: Likewise.
	* ld-mips-elf/attr-gnu-4-24.d: Likewise.
	* ld-mips-elf/attr-gnu-4-25.d: Likewise.
	* ld-mips-elf/attr-gnu-4-31.d: Likewise.
	* ld-mips-elf/attr-gnu-4-32.d: Likewise.
	* ld-mips-elf/attr-gnu-4-34.d: Likewise.
	* ld-mips-elf/attr-gnu-4-35.d: Likewise.
	* ld-mips-elf/attr-gnu-4-41.d: Likewise.
	* ld-mips-elf/attr-gnu-4-42.d: Likewise.
	* ld-mips-elf/attr-gnu-4-43.d: Likewise.
	* ld-mips-elf/attr-gnu-4-45.d: Likewise.
	* ld-mips-elf/attr-gnu-4-51.d: Likewise.
@
text
@d435 2
a436 2
  /* This flag indicates that the value of DT_MIPS_RLD_MAP dynamic
     entry is set to the address of __rld_obj_head as in IRIX5.  */
d7296 1
a7296 1
  if ((IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none)
@


1.317
log
@	bfd/
	* elfxx-mips.c (mips_elf_merge_obj_attributes): Correct messages
	for the -mdouble-float and -msingle-float cases throughout; make
	all the messages report the output file consistently on the
	left-hand side.

	ld/testsuite/
	* ld-mips-elf/attr-gnu-4-12.d: Adjust the warning expected
	according to changes to BFD.
	* ld-mips-elf/attr-gnu-4-14.d: Likewise.
	* ld-mips-elf/attr-gnu-4-31.d: Likewise.
	* ld-mips-elf/attr-gnu-4-32.d: Likewise.
	* ld-mips-elf/attr-gnu-4-34.d: Likewise.
	* ld-mips-elf/attr-gnu-4-41.d: Likewise.
@
text
@d518 16
d1134 9
d13777 6
a13797 1
  in_attr = elf_known_obj_attributes (ibfd)[OBJ_ATTR_GNU];
d13804 1
a13804 11
      else if (in_attr[Tag_GNU_MIPS_ABI_FP].i == 0)
	;
      else if (in_attr[Tag_GNU_MIPS_ABI_FP].i > 4)
	_bfd_error_handler
	  (_("Warning: %B uses unknown floating point ABI %d"), ibfd,
	   in_attr[Tag_GNU_MIPS_ABI_FP].i);
      else if (out_attr[Tag_GNU_MIPS_ABI_FP].i > 4)
	_bfd_error_handler
	  (_("Warning: %B uses unknown floating point ABI %d"), obfd,
	   out_attr[Tag_GNU_MIPS_ABI_FP].i);
      else
d13812 2
a13813 2
		  (_("Warning: %B uses -mdouble-float, %B uses -msingle-float"),
		   obfd, ibfd);
d13818 2
a13819 2
		  (_("Warning: %B uses hard float, %B uses soft float"),
		   obfd, ibfd);
d13824 3
a13826 2
		  (_("Warning: %B uses -mdouble-float, %B uses -mips32r2 -mfp64"),
		   obfd, ibfd);
d13830 6
a13835 1
		abort ();
d13844 2
a13845 2
		  (_("Warning: %B uses -msingle-float, %B uses -mdouble-float"),
		   obfd, ibfd);
d13850 2
a13851 2
		  (_("Warning: %B uses hard float, %B uses soft float"),
		   obfd, ibfd);
d13856 3
a13858 2
		  (_("Warning: %B uses -msingle-float, %B uses -mips32r2 -mfp64"),
		   obfd, ibfd);
d13862 6
a13867 1
		abort ();
d13878 2
a13879 2
		  (_("Warning: %B uses soft float, %B uses hard float"),
		   obfd, ibfd);
d13883 6
a13888 1
		abort ();
d13897 3
a13899 2
		  (_("Warning: %B uses -mips32r2 -mfp64, %B uses -mdouble-float"),
		   obfd, ibfd);
d13904 3
a13906 2
		  (_("Warning: %B uses -mips32r2 -mfp64, %B uses -msingle-float"),
		   obfd, ibfd);
d13911 2
a13912 2
		  (_("Warning: %B uses hard float, %B uses soft float"),
		   obfd, ibfd);
d13916 6
a13921 1
		abort ();
d13926 44
a13969 1
	    abort ();
@


1.316
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d13792 1
a13792 1
		  (_("Warning: %B uses -msingle-float, %B uses -mdouble-float"),
d13804 1
a13804 1
		  (_("Warning: %B uses -msingle-float, %B uses -mips32r2 -mfp64"),
d13819 1
a13819 1
		   ibfd, obfd);
d13830 1
a13830 1
		  (_("Warning: %B uses -mdouble-float, %B uses -mips32r2 -mfp64"),
d13846 2
a13847 2
		  (_("Warning: %B uses hard float, %B uses soft float"),
		   ibfd, obfd);
d13860 2
a13861 2
		  (_("Warning: %B uses -msingle-float, %B uses -mips32r2 -mfp64"),
		   ibfd, obfd);
d13866 2
a13867 2
		  (_("Warning: %B uses -mdouble-float, %B uses -mips32r2 -mfp64"),
		   ibfd, obfd);
@


1.315
log
@typo fixes
@
text
@d10132 1
a10132 1
  if (strcmp (name, "_DYNAMIC") == 0
@


1.314
log
@	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Look up
	the options section in the output rather than input BFD to
	decide if to add a DT_MIPS_OPTIONS tag.
@
text
@d12767 1
a12767 1
	  /* Replace the the 32-bit opcode with a 16-bit opcode.  */
d12794 1
a12794 1
	  /* Replace the the 32-bit opcode with a 16-bit opcode.  */
@


1.313
log
@	* elfxx-mips.c (mips_elf_calculate_relocation): Fix the handling
	of protected symbols.
@
text
@d9285 1
a9285 1
		  (dynobj, MIPS_ELF_OPTIONS_SECTION_NAME (dynobj)))
@


1.312
log
@	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.
@
text
@d5363 4
a5366 1
  local_p = h == NULL || SYMBOL_REFERENCES_LOCAL (info, &h->root);
@


1.311
log
@	bfd/
	* elfxx-mips.c (mips_elf_perform_relocation): Update the
	cross-mode jump message.

	ld/testsuite/
	* ld-mips-elf/mode-change-error-1.d: Update the error message.
@
text
@d309 6
a314 6
#define LA25_LUI_MICROMIPS_1(VAL) (0x41b9)	/* lui t9,VAL */
#define LA25_LUI_MICROMIPS_2(VAL) (VAL)
#define LA25_J_MICROMIPS_1(VAL) (0xd400 | (((VAL) >> 17) & 0x3ff)) /* j VAL */
#define LA25_J_MICROMIPS_2(VAL) ((VAL) >> 1)
#define LA25_ADDIU_MICROMIPS_1(VAL) (0x3339)	/* addiu t9,t9,VAL */
#define LA25_ADDIU_MICROMIPS_2(VAL) (VAL)
d1016 17
d9797 6
a9802 8
	  bfd_put_16 (hti->output_bfd, LA25_LUI_MICROMIPS_1 (target_high),
		      loc);
	  bfd_put_16 (hti->output_bfd, LA25_LUI_MICROMIPS_2 (target_high),
		      loc + 2);
	  bfd_put_16 (hti->output_bfd, LA25_ADDIU_MICROMIPS_1 (target_low),
		      loc + 4);
	  bfd_put_16 (hti->output_bfd, LA25_ADDIU_MICROMIPS_2 (target_low),
		      loc + 6);
d9816 6
a9821 10
	  bfd_put_16 (hti->output_bfd, LA25_LUI_MICROMIPS_1 (target_high),
		      loc);
	  bfd_put_16 (hti->output_bfd, LA25_LUI_MICROMIPS_2 (target_high),
		      loc + 2);
	  bfd_put_16 (hti->output_bfd, LA25_J_MICROMIPS_1 (target), loc + 4);
	  bfd_put_16 (hti->output_bfd, LA25_J_MICROMIPS_2 (target), loc + 6);
	  bfd_put_16 (hti->output_bfd, LA25_ADDIU_MICROMIPS_1 (target_low),
		      loc + 8);
	  bfd_put_16 (hti->output_bfd, LA25_ADDIU_MICROMIPS_2 (target_low),
		      loc + 10);
d12354 1
a12354 1
  opcode = (bfd_get_16 (abfd, ptr) << 16) | bfd_get_16 (abfd, ptr + 2);
d12399 1
a12399 1
  opcode = (bfd_get_16 (abfd, ptr) << 16) | bfd_get_16 (abfd, ptr + 2);
d12431 1
a12431 3
  opcode   = bfd_get_16 (abfd, ptr);
  opcode <<= 16;
  opcode  |= bfd_get_16 (abfd, ptr + 2);
d12589 1
a12589 2
      opcode  = bfd_get_16 (abfd, ptr    ) << 16;
      opcode |= bfd_get_16 (abfd, ptr + 2);
d12671 1
a12671 2
	  nextopc  = bfd_get_16 (abfd, contents + irel[1].r_offset    ) << 16;
	  nextopc |= bfd_get_16 (abfd, contents + irel[1].r_offset + 2);
d12712 2
a12713 4
	      bfd_put_16 (abfd, (nextopc >> 16) & 0xffff,
			  contents + irel[1].r_offset);
	      bfd_put_16 (abfd,  nextopc        & 0xffff,
			  contents + irel[1].r_offset + 2);
d12747 1
a12747 2
	  bfd_put_16 (abfd, (opcode >> 16) & 0xffff, ptr);
	  bfd_put_16 (abfd,  opcode        & 0xffff, ptr + 2);
d12812 1
a12812 2
	  n32opc  = bfd_get_16 (abfd, ptr + 4) << 16;
	  n32opc |= bfd_get_16 (abfd, ptr + 6);
d12839 1
a12839 4
	      bfd_put_16 (abfd, (jal_insn_32_bd16.match >> 16) & 0xffff,
			  ptr);
	      bfd_put_16 (abfd,  jal_insn_32_bd16.match        & 0xffff,
			  ptr + 2);
@


1.310
log
@	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Update the
	comment on DT_MIPS_RLD_MAP.
@
text
@d5933 2
a5934 1
      /* If the opcode is not JAL or JALX, there's a problem.  */
d5938 1
a5938 1
	    (_("%B: %A+0x%lx: Direct jumps between ISA modes are not allowed; consider recompiling with interlinking enabled."),
@


1.309
log
@2012-07-24  Teresa Johnson  <tejohnson@@google.com>

bfd/
	* bfd.c (bfd_find_nearest_line_discriminator): New macro.
	* coff-rs6000.c: Init _bfd_find_nearest_line_discriminator.
	* coff64-rs6000.c: Likewise.
	* dwarf2.c (struct line_info): Add discriminator field.
	(add_line_info): Fill in new discriminator field.
	(decode_line_info): Record discriminator information instead
        of ignoring it.
	(lookup_address_in_line_info_table): Return discriminator field if
        requested.
	(comp_unit_find_nearest_line): Add discriminator argument.
	(find_line): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.
	(_bfd_dwarf2_find_line): Likewise.
	* elf-bfd.h (_bfd_elf_find_nearest_line_discriminator): New.
        (_bfd_elf_find_line_discriminator): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): Likewise. Defined.
	* elf.c (_bfd_elf_find_nearest_line): Change to a wrapper
        that invokes _bfd_elf_find_nearest_line_discriminator with correct
        arguments.
	(_bfd_elf_find_nearest_line_discriminator): New.
	(_bfd_elf_find_line): Change to a wrapper
        that invokes _bfd_elf_find_line_discriminator with correct
        arguments.
	(_bfd_elf_find_line_discriminator): New.
	* coffgen.c (coff_find_nearest_line_with_names): Handle
        new discriminator argument.
	* elf32-arm.c (elf32_arm_find_nearest_line): Likewise.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Likewise.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Add discriminator
        argument.
        (_bfd_dwarf2_find_line): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): New.
	* libbfd.c (_bfd_generic_find_nearest_line_discriminator): New.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize
        _bfd_find_nearest_line_discriminator with
        _bfd_generic_find_nearest_line_discriminator.
        (bfd_target): Add _bfd_find_nearest_line_discriminator.

binutils/
	* addr2line.c (find_address_in_section): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator.
	(find_offset_in_section): Likewise.
	(translate_addresses): Print discriminator if it is non-zero.
	* objdump.c (show_line): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator,
        and keep track of prev_discriminator. Print discriminator
        if it is non-zero.
	(disassemble_data): Initialize prev_discriminator.
	(dump_reloc_set): Invoke bfd_find_nearest_line_discriminator
        to get the discriminator, and keep track of last_discriminator.
        Print discriminator if it is non-zero.
@
text
@d9175 2
a9176 2
	 only fills in DT_MIPS_RLD_MAP (not DT_DEBUG) and GDB only
	 looks at the first one it sees.  */
@


1.309.2.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d309 6
a314 6
#define LA25_LUI_MICROMIPS(VAL)						\
  (0x41b90000 | (VAL))				/* lui t9,VAL */
#define LA25_J_MICROMIPS(VAL)						\
  (0xd4000000 | (((VAL) >> 1) & 0x3ffffff))	/* j VAL */
#define LA25_ADDIU_MICROMIPS(VAL)					\
  (0x33390000 | (VAL))				/* addiu t9,t9,VAL */
a1015 17
/* microMIPS 32-bit opcode helper installer.  */

static void
bfd_put_micromips_32 (const bfd *abfd, bfd_vma opcode, bfd_byte *ptr)
{
  bfd_put_16 (abfd, (opcode >> 16) & 0xffff, ptr);
  bfd_put_16 (abfd,  opcode        & 0xffff, ptr + 2);
}

/* microMIPS 32-bit opcode helper retriever.  */

static bfd_vma
bfd_get_micromips_32 (const bfd *abfd, const bfd_byte *ptr)
{
  return (bfd_get_16 (abfd, ptr) << 16) | bfd_get_16 (abfd, ptr + 2);
}

d5346 1
a5346 4
  local_p = (h == NULL
	     || (h->got_only_for_calls
		 ? SYMBOL_CALLS_LOCAL (info, &h->root)
		 : SYMBOL_REFERENCES_LOCAL (info, &h->root)));
d5933 1
a5933 2
      /* If the opcode is not JAL or JALX, there's a problem.  We cannot
         convert J or JALS to JALX.  */
d5937 1
a5937 1
	    (_("%B: %A+0x%lx: Unsupported jump between ISA modes; consider recompiling with interlinking enabled."),
d9264 1
a9264 1
		  (output_bfd, MIPS_ELF_OPTIONS_SECTION_NAME (dynobj)))
d9779 8
a9786 6
	  bfd_put_micromips_32 (hti->output_bfd,
				LA25_LUI_MICROMIPS (target_high),
				loc);
	  bfd_put_micromips_32 (hti->output_bfd,
				LA25_ADDIU_MICROMIPS (target_low),
				loc + 4);
d9800 10
a9809 6
	  bfd_put_micromips_32 (hti->output_bfd,
				LA25_LUI_MICROMIPS (target_high), loc);
	  bfd_put_micromips_32 (hti->output_bfd,
				LA25_J_MICROMIPS (target), loc + 4);
	  bfd_put_micromips_32 (hti->output_bfd,
				LA25_ADDIU_MICROMIPS (target_low), loc + 8);
d12342 1
a12342 1
  opcode = bfd_get_micromips_32 (abfd, ptr);
d12387 1
a12387 1
  opcode = bfd_get_micromips_32 (abfd, ptr);
d12419 3
a12421 1
  opcode = bfd_get_micromips_32 (abfd, ptr);
d12579 2
a12580 1
      opcode = bfd_get_micromips_32 (abfd, ptr);
d12662 2
a12663 1
	  nextopc = bfd_get_micromips_32 (abfd, contents + irel[1].r_offset);
d12704 4
a12707 2
	      bfd_put_micromips_32 (abfd, nextopc,
				    contents + irel[1].r_offset);
d12741 2
a12742 1
	  bfd_put_micromips_32 (abfd, opcode, ptr);
d12807 2
a12808 1
	  n32opc = bfd_get_micromips_32 (abfd, ptr + 4);
d12835 4
a12838 1
	      bfd_put_micromips_32 (abfd, jal_insn_32_bd16.match, ptr);
@


1.309.2.2
log
@bfd/
	* elfxx-mips.c (mips_elf_recreate_got): Remove free.
	(mips_elf_resolve_final_got_entries): Remove bogus comment.
@
text
@d3985 2
d4010 2
@


1.308
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d11712 1
a11712 1
				     line_ptr, ABI_64_P (abfd) ? 8 : 0,
@


1.307
log
@	* elf32-m32c.c (m32c_elf_check_relocs): Use bfd_make_section
	"anyway" variant when creating .plt.
	(m32c_elf_relax_plt_section): Remove redundant test and unused param.
	(m32c_elf_relax_section): Test SEC_LINKER_CREATED before calling
	m32c_elf_relax_plt_section.
	* elfxx-mips.c (mips_elf_create_got_section): Use make anyway variant
	when creating .got and .got.plt.
	(_bfd_mips_elf_final_link): Likewise for .rtproc, and use
	bfd_get_linker_section.
	* sunos.c: Similarly throughout.
@
text
@d9058 1
a9058 1
  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, (PTR) info);
d12467 1
a12467 1
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
@


1.306
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d4877 1
a4877 1
  s = bfd_make_section_with_flags (abfd, ".got", flags);
d4929 5
a4933 3
  s = bfd_make_section_with_flags (abfd, ".got.plt",
				   SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED);
d13314 1
a13314 1
	      rtproc_sec = bfd_get_section_by_name (abfd, ".rtproc");
d13320 3
a13322 3
		  rtproc_sec = bfd_make_section_with_flags (abfd,
							    ".rtproc",
							    flags);
@


1.305
log
@	* elf64-mips.c (elf_backend_got_header_size): Correct definition.
	* elfxx-mips.c (_bfd_mips_elf_adjust_dynamic_symbol): Use the ELF
	backend's GOT header size instead of hardcoding it.
@
text
@d2863 1
a2863 1
  sreloc = bfd_get_section_by_name (dynobj, dname);
d2866 7
a2872 7
      sreloc = bfd_make_section_with_flags (dynobj, dname,
					    (SEC_ALLOC
					     | SEC_LOAD
					     | SEC_HAS_CONTENTS
					     | SEC_IN_MEMORY
					     | SEC_LINKER_CREATED
					     | SEC_READONLY));
d4835 1
a4835 1
  if (bfd_get_section_by_name (abfd, ".compact_rel") == NULL)
d4840 1
a4840 1
      s = bfd_make_section_with_flags (abfd, ".compact_rel", flags);
d6181 1
a6181 1
      asection *scpt = bfd_get_section_by_name (dynobj, ".compact_rel");
d7223 1
a7223 1
      s = bfd_get_section_by_name (abfd, ".dynamic");
d7239 3
a7241 3
  s = bfd_make_section_with_flags (abfd,
				   MIPS_ELF_STUB_SECTION_NAME (abfd),
				   flags | SEC_CODE);
d7250 1
a7250 1
      && bfd_get_section_by_name (abfd, ".rld_map") == NULL)
d7252 2
a7253 2
      s = bfd_make_section_with_flags (abfd, ".rld_map",
				       flags &~ (flagword) SEC_READONLY);
d7291 1
a7291 1
      s = bfd_get_section_by_name (abfd, ".hash");
d7294 1
a7294 1
      s = bfd_get_section_by_name (abfd, ".dynsym");
d7297 1
a7297 1
      s = bfd_get_section_by_name (abfd, ".dynstr");
d7300 1
d7304 1
a7304 1
      s = bfd_get_section_by_name (abfd, ".dynamic");
d7334 1
a7334 1
	  s = bfd_get_section_by_name (abfd, ".rld_map");
d7361 2
a7362 2
  htab->splt = bfd_get_section_by_name (abfd, ".plt");
  htab->sdynbss = bfd_get_section_by_name (abfd, ".dynbss");
d7365 2
a7366 2
      htab->srelbss = bfd_get_section_by_name (abfd, ".rela.bss");
      htab->srelplt = bfd_get_section_by_name (abfd, ".rela.plt");
d7369 1
a7369 1
    htab->srelplt = bfd_get_section_by_name (abfd, ".rel.plt");
d9031 1
a9031 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d10514 1
a10514 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d10860 1
a10860 1
	s = bfd_get_section_by_name (dynobj, ".compact_rel");
@


1.304
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d8668 2
a8669 1
	    htab->sgotplt->size += 2 * MIPS_ELF_GOT_SIZE (dynobj);
@


1.303
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d9327 49
d9442 6
a9447 2
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, relend, howto, contents);
@


1.302
log
@	* elfxx-mips.c (mips16_stub_symndx): Handle n64 compound relocs.
	(_bfd_mips_elf_check_relocs): Update accordingly.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d9392 1
a9392 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.301
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	gas/
	* config/tc-mips.c (mips_pseudo_table): Add tprelword/tpreldword
	entries.
	(mips16_percent_op): Add MIPS16 TLS relocation ops.
	(md_apply_fix): Add BFD_RELOC_MIPS16_TLS_* switch cases.
	(s_tls_rel_directive): Rename from s_dtprel_internal(). Abstract out
	directive string and reloc type as function parameters. Update
	comments.
	(s_dtprelword,s_dtpreldword): Change to use s_tls_rel_directive().
	(s_tprelword,s_tpreldword): New functions.

	include/
	* elf/mips.h (elf_mips_reloc_type): Add R_MIPS16_TLS_* entries.

	bfd/
	* reloc.c (BFD_RELOC_MIPS16_TLS_GD,BFD_RELOC_MIPS16_TLS_LDM,
	BFD_RELOC_MIPS16_TLS_DTPREL_HI16,BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
	BFD_RELOC_MIPS16_TLS_GOTTPREL,BFD_RELOC_MIPS16_TLS_TPREL_HI16,
	BFD_RELOC_MIPS16_TLS_TPREL_LO16): New relocations for MIPS16 TLS.
	* bfd-in2.h (bfd_reloc_code_real): Regenerate.
	* libbfd.h (bfd_reloc_code_real_names): Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Add R_MIPS16_TLS_*
	entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel,
	elf_mips16_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel,
	mips16_elf64_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfxx-mips.c (TLS_RELOC_P,mips16_reloc_p,
	_bfd_mips_elf_check_relocs): Add cases for R_MIPS16_TLS_* relocations.
	(tls_gd_reloc_p): Add R_MIPS16_TLS_GD case.
	(tls_ldm_reloc_p): Add R_MIPS16_TLS_LDM case.
	(tls_gottprel_reloc_p): Add R_MIPS16_TLS_GOTTPREL case.
	(mips_elf_calculate_relocation): Add cases for R_MIPS16_TLS_*,
	R_MIPS_TLS_DTPREL32/64, and R_MIPS_TLS_TPREL32/64 relocations.
@
text
@d1463 2
a1464 1
mips16_stub_symndx (asection *sec ATTRIBUTE_UNUSED,
d1468 1
d1471 3
a1473 2
  /* Trust the first R_MIPS_NONE relocation, if any.  */
  for (rel = relocs; rel < relend; rel++)
d7575 1
a7575 1
      r_symndx = mips16_stub_symndx (sec, relocs, rel_end);
d7700 1
a7700 1
      r_symndx = mips16_stub_symndx (sec, relocs, rel_end);
@


1.300
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Sandra Loosemore  <sandra@@codesourcery.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* elfxx-mips.c (mips_elf_local_pic_function_p): Return true when
	H is a MIPS16 function with a kept 32-bit stub. Update comments.
	(mips_elf_get_la25_target): New function.
	(mips_elf_add_la25_intro): Change to use mips_elf_get_la25_target().
	(mips_elf_add_la25_stub): Move compute of use_trampoline_p down,
	change to use mips_elf_get_la25_target().
	(mips_elf_relocation_needs_la25_stub): Add target_is_16_bit_code_p
	parameter, add switch case for R_MIPS16_26.
	(mips_elf_calculate_relocation): Redirect relocation to point to the
	LA25 stub if it exists, instead of the MIPS16 stub. Update arguments
	of call to mips_elf_relocation_needs_la25_stub(), don't use la25 stub
	for mips16->mips16 calls.
	(_bfd_mips_elf_check_relocs): Update arguments of call to
	mips_elf_relocation_needs_la25_stub().
	(mips_elf_create_la25_stub): Change to use mips_elf_get_la25_target().
@
text
@d532 7
d1895 7
d2029 3
a2031 1
  return r_type == R_MIPS_TLS_GD || r_type == R_MICROMIPS_TLS_GD;
d2037 3
a2039 1
  return r_type == R_MIPS_TLS_LDM || r_type == R_MICROMIPS_TLS_LDM;
d2045 3
a2047 1
  return r_type == R_MIPS_TLS_GOTTPREL || r_type == R_MICROMIPS_TLS_GOTTPREL;
d5384 3
d5556 1
d5565 1
d5571 1
d5578 3
d5713 3
a7848 2
	case R_MIPS16_GOT16:
	case R_MIPS16_CALL16:
d7861 5
d8102 1
d8109 1
d8119 1
@


1.299
log
@2011-12-13  Chung-Lin Tang  <cltang@@codesourcery.com>

	* elfxx-mips.c (mips_elf_calculate_relocation): Correct
	R_MIPS16_HI16/R_MIPS16_LO16 handling of two cleared lower bits,
	update comments.
@
text
@d1578 4
a1581 3
   that it might need $25 to be valid on entry.  Note that MIPS16
   functions never need $25 to be valid on entry; they set up $gp
   using PC-relative instructions instead.  */
d1590 2
a1591 1
	  && !ELF_ST_IS_MIPS16 (h->root.other)
d1596 20
d1640 1
a1640 1
  input_section = stub->h->root.root.u.def.section;
a1713 6
  /* Prefer to use LUI/ADDIU stubs if the function is at the beginning
     of the section and if we would need no more than 2 nops.  */
  s = h->root.root.u.def.section;
  value = h->root.root.u.def.value;
  use_trampoline_p = (value != 0 || s->alignment_power > 4);

d1743 5
d4935 2
a4936 1
mips_elf_relocation_needs_la25_stub (bfd *input_bfd, int r_type)
a4949 1
    case R_MIPS16_26:
d4957 3
d5220 4
a5223 1
	sec = elf_tdata (input_bfd)->local_stubs[r_symndx];
d5227 12
a5238 1
	  sec = h->fn_stub;
d5241 1
a5241 1
      symbol = sec->output_section->vma + sec->output_offset;
d5291 2
a5292 1
	   && mips_elf_relocation_needs_la25_stub (input_bfd, r_type))
d7968 3
a7970 1
      if (h != NULL && mips_elf_relocation_needs_la25_stub (abfd, r_type))
d9667 3
a9669 3
  target = (stub->h->root.root.u.def.section->output_section->vma
	    + stub->h->root.root.u.def.section->output_offset
	    + stub->h->root.root.u.def.value);
@


1.298
log
@2011-12-10  David Daney  <david.daney@@cavium.com>

	* elfxx-mips.c (mips_elf_link_hash_table.rld_value): Remove.
	(mips_elf_link_hash_table.rld_symbol): New field;
	(MIPS_ELF_RLD_MAP_SIZE): New macro.
	(_bfd_mips_elf_add_symbol_hook): Remember __rld_obj_head symbol
	in rld_symbol.
	(_bfd_mips_elf_create_dynamic_sections): Remember __rld_map symbol
	in rld_symbol.
	(_bfd_mips_elf_size_dynamic_sections): Set correct size for .rld_map.
	(_bfd_mips_elf_finish_dynamic_symbol): Remove .rld_map handling.
	(_bfd_mips_elf_finish_dynamic_sections): Use rld_symbol to
	calculate DT_MIPS_RLD_MAP value.
	(_bfd_mips_elf_link_hash_table_create): Initialize rld_symbol,
	quit initializing rld_value.
@
text
@d5534 3
a5536 2
	     $pc is four higher than $t9 would be, so reduce
	     both reloc addends by 4. */
d5538 1
a5538 1
	    value = mips_elf_high (addend + gp - p - 4);
d5561 1
a5561 1
	    value = addend + gp - p;
@


1.297
log
@bfd:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

	* archures.c (bfd_mach_mips_octeon2): New macro
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_mipsocteon2): New enum value.
	(arch_info_struct): Add bfd_mach_mips_octeon2.
	* elfxx-mips.c (_bfd_elf_mips_mach): Support E_MIPS_MACH_OCTEON2.
	(mips_set_isa_flags): Add bfd_mach_mips_octeon2.
	(mips_mach_extensions): Add bfd_mach_mips_octeon2.

gas:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

        * tc-mips.c (CPU_IS_OCTEON): Add Octeon2.
        (mips_cpu_info_table): Add Octeon2.
        * doc/c-mips.texi: Document octeon2 as an acceptable value for -march=.

gas/testsuite:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

        * gas/mips/mips.exp: Add Octeon2 for an architecture.
        Run octeon2 test.
        * gas/mips/octeon2.d: New file.
        * gas/mips/octeon2.s: New file.

include/opcode:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

        * mips.h (INSN_CHIP_MASK): Update according to INSN_OCTEON2.
        (INSN_OCTEON2): New macro.
        (CPU_OCTEON2): New macro.
        (OPCODE_IS_MEMBER): Add Octeon2.

opcodes:
2011-12-08  Andrew Pinski  <apinski@@cavium.com>
            Adam Nemet  <anemet@@caviumnetworks.com>

	* mips-dis.c (mips_arch_choices): Add Octeon2.
	For "octeon+", just include OcteonP for the insn.
	* mips-opc.c (IOCT): Include Octeon2.
	(IOCTP): Include Octeon2.
	(IOCT2): New macro.
	(mips_builtin_opcodes): Add "laa", "laad", "lac", "lacd", "lad",
	"ladd", "lai", "laid", "las", "lasd", "law", "lawd".
	Move "lbux", "ldx", "lhx", "lwx", and "lwux" up to where the standard
	loads are, and add IOCT2 to them.
	Add "lbx" and "lhux".
	Add "qmac.00", "qmac.01", "qmac.02", "qmac.03", "qmacs.00",
	"qmacs.01", "qmacs.01", "qmacs.02" and "qmacs.03".
	Add "zcb" and "zcbt".
@
text
@d439 2
a440 2
  /* This is the value of the __rld_map or __rld_obj_head symbol.  */
  bfd_vma rld_value;
d771 4
d7089 1
d7275 1
d9037 1
a9037 1
	  s->size += 4;
a10039 25
  if (! info->shared)
    {
      if (! mips_elf_hash_table (info)->use_rld_obj_head
	  && (strcmp (name, "__rld_map") == 0
	      || strcmp (name, "__RLD_MAP") == 0))
	{
	  asection *s = bfd_get_section_by_name (dynobj, ".rld_map");
	  BFD_ASSERT (s != NULL);
	  sym->st_value = s->output_section->vma + s->output_offset;
	  bfd_put_32 (output_bfd, 0, s->contents);
	  if (mips_elf_hash_table (info)->rld_value == 0)
	    mips_elf_hash_table (info)->rld_value = sym->st_value;
	}
      else if (mips_elf_hash_table (info)->use_rld_obj_head
	       && strcmp (name, "__rld_obj_head") == 0)
	{
	  /* IRIX6 does not use a .rld_map section.  */
	  if (IRIX_COMPAT (output_bfd) == ict_irix5
              || IRIX_COMPAT (output_bfd) == ict_none)
	    BFD_ASSERT (bfd_get_section_by_name (dynobj, ".rld_map")
			!= NULL);
	  mips_elf_hash_table (info)->rld_value = sym->st_value;
	}
    }

d10502 13
a10514 1
	      dyn.d_un.d_ptr = mips_elf_hash_table (info)->rld_value;
d12797 1
a12797 1
  ret->rld_value = 0;
@


1.296
log
@opcode/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * mips-dis.c (mips_arch_choices): Add Octeon+.
        * mips-opc.c (IOCT): Include Octeon+.
        (IOCTP): New macro.
        (mips_builtin_opcodes): Add "saa" and "saad".
bfd/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * archures.c (bfd_mach_mips_octeonp): New macro.
        * bfd-in2.h: Regenerate.
        * bfd/cpu-mips.c (I_mipsocteonp): New enum value.
        (arch_info_struct): Add bfd_mach_mips_octeonp.
        * elfxx-mips.c (mips_set_isa_flags): Add bfd_mach_mips_octeonp.
        (mips_mach_extensions): Add bfd_mach_mips_octeonp.
include/opcodes/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * mips.h (INSN_CHIP_MASK): Update according to INSN_OCTEONP.
        (INSN_OCTEONP): New macro.
        (CPU_OCTEONP): New macro.
        (OPCODE_IS_MEMBER): Add Octeon+.
        (M_SAA_AB, M_SAAD_AB, M_SAA_OB, M_SAAD_OB): New enum values.
gas/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * config/tc-mips.c (CPU_IS_OCTEON): New macro function.
        (CPU_HAS_SEQ): Change to use CPU_IS_OCTEON.
        (NO_ISA_COP): Likewise.
        (macro) <ld_st>: Add support when off0 is true.
        Add support for M_SAA_AB, M_SAA_OB, M_SAAD_OB and M_SAAD_AB.
        (mips_cpu_info_table): Add octeon+.
        * doc/c-mips.texi: Document octeon+ as an acceptable value for -march=.
gas/testsuite/
2011-11-29  Andrew Pinski  <apinski@@cavium.com>

        * gas/mips/mips.exp: Add octeon+ for an architecture.
        Run octeon-saa-saad test.
        (run_dump_test_arch): For Octeon architectures, also try octeon@@.
        * gas/mips/octeon-pref.d: Remove -march=octeon from command line.
        * gas/mips/octeon.d: Likewise.
        * gas/mips/octeon-saa-saad.d: New file.
        * gas/mips/octeon-saa-saad.s: New file
@
text
@d6185 3
d10899 4
d13502 1
@


1.295
log
@	* elfxx-mips.c (mips_n64_exe_plt0_entry): Use 64-bit move.
@
text
@d10888 1
d13495 1
@


1.294
log
@	* elfxx-mips.c (_bfd_mips_elf_symbol_processing): Remove
	assertions.
@
text
@d920 1
a920 1
  0x03e07821,	/* move $15, $31					*/
d934 1
a934 1
  0x03e07821,	/* move $15, $31					*/
d948 1
a948 1
  0x03e07821,	/* move $15, $31					*/
@


1.293
log
@2011-09-30  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2.c (struct dwarf2_debug): Add field debug_sections.
	(read_section): Add sec argument. Adjust the code to get section
	names from it.
	(read_indirect_string): Adjust call to read_section.
	(read_abbrevs): Ditto.
	(decode_line_info): Ditto.
	(read_debug_ranges): Ditto.
	(DWARF2_DEBUG_INFO, DWARF2_COMPRESSED_DEBUG_INFO): Remove.
	(find_debug_info): Add debug_sections parameter.  Use it instead
	the above macros.
	(place_sections): Get section names from stash.
	(find_line): Add debug_sections argument.  Initialize
	debug_sections field of stash from it.
	Adjust calls to find_debug_info.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	Adjust call to find_line.
	(_bfd_dwarf2_find_line): Adjust call to find_line.
	* libcoff-in.h (struct dwarf_debug_section): New declaration.
	(coff_find_nearest_line_with_names): Likewise.
	* libcoff.h: Regenerate.
	* libbfd-in.h (struct dwarf_debug_section): Move declaration.
	(dwarf_debug_sections): Likewise.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Ditto.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Ditto.
	* elf32-arm.c (elf32_arm_find_nearest_line): Ditto.
	* coffgen.c (coff_find_nearest_line_with_names): New function.
	(coff_find_nearest_line): Calls coff_find_nearest_line_with_names.
	* coff-rs6000.c (xcoff_debug_sections): New constant.
	(xcoff_find_nearest_line): New function.
	(rs6000coff_vec): Use xcoff_find_nearest_line.
	(pmac_xcoff_vec): Ditto.
@
text
@a6339 1
	BFD_ASSERT (SGI_COMPAT (abfd));
a6354 1
	BFD_ASSERT (SGI_COMPAT (abfd));
@


1.292
log
@	* elfxx-mips.c (check_4byte_branch): Remove function.
	(check_relocated_bzc): New function.
	(_bfd_mips_elf_relax_section): Permit the relaxation of LUI
	instructions that immediately follow a compact branch
	instruction.
@
text
@d11570 2
a11571 1
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
@


1.292.2.1
log
@	Backport from mainline:

	2011-11-14  Maxim Kuvyrkov  <maxim@@codesourcery.com>
        * elfxx-mips.c (mips_n64_exe_plt0_entry): Use 64-bit move.
@
text
@d920 1
a920 1
  0x03e07821,	/* move $15, $31	# 32-bit move (addu)		*/
d934 1
a934 1
  0x03e07821,	/* move $15, $31	# 32-bit move (addu)		*/
d948 1
a948 1
  0x03e0782d,	/* move $15, $31	# 64-bit move (daddu)		*/
@


1.292.2.2
log
@Backport from mainline:

	2011-12-10  David Daney  <david.daney@@cavium.com>

	* elfxx-mips.c (mips_elf_link_hash_table.rld_value): Remove.
	(mips_elf_link_hash_table.rld_symbol): New field;
	(MIPS_ELF_RLD_MAP_SIZE): New macro.
	(_bfd_mips_elf_add_symbol_hook): Remember __rld_obj_head symbol
	in rld_symbol.
	(_bfd_mips_elf_create_dynamic_sections): Remember __rld_map symbol
	in rld_symbol.
	(_bfd_mips_elf_size_dynamic_sections): Set correct size for .rld_map.
	(_bfd_mips_elf_finish_dynamic_symbol): Remove .rld_map handling.
	(_bfd_mips_elf_finish_dynamic_sections): Use rld_symbol to
	calculate DT_MIPS_RLD_MAP value.
	(_bfd_mips_elf_link_hash_table_create): Initialize rld_symbol,
	quit initializing rld_value.
@
text
@d439 2
a440 2
  /* The  __rld_map or __rld_obj_head symbol. */
  struct elf_link_hash_entry *rld_symbol;
a770 4
/* The size of the .rld_map section. */
#define MIPS_ELF_RLD_MAP_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->arch_size / 8)

a7083 1
      mips_elf_hash_table (info)->rld_symbol = h;
a7268 1
	  mips_elf_hash_table (info)->rld_symbol = h;
d9030 1
a9030 1
	  s->size += MIPS_ELF_RLD_MAP_SIZE (output_bfd);
d10033 25
d10520 1
a10520 13
	      {
		struct elf_link_hash_entry *h;
		h = mips_elf_hash_table (info)->rld_symbol;
		if (!h)
		  {
		    dyn_to_skip = MIPS_ELF_DYN_SIZE (dynobj);
		    swap_out_p = FALSE;
		    break;
		  }
		s = h->root.u.def.section;
		dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset
				  + h->root.u.def.value);
	      }
d12797 1
a12797 1
  ret->rld_symbol = NULL;
@


1.292.2.3
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	Backport from mainline:

	2011-12-13  Chung-Lin Tang  <cltang@@codesourcery.com>

	* elfxx-mips.c (mips_elf_calculate_relocation): Correct
	R_MIPS16_HI16/R_MIPS16_LO16 handling of two cleared lower bits,
	update comments.
@
text
@d5534 2
a5535 3
	     base $pc is that used by the ADDIUPC instruction at $t9 + 4.
	     ADDIUPC clears the low two bits of the instruction address,
	     so the base is ($t9 + 4) & ~3.  */
d5537 1
a5537 1
	    value = mips_elf_high (addend + gp - ((p + 4) & ~(bfd_vma) 0x3));
d5560 1
a5560 1
	    value = addend + gp - (p & ~(bfd_vma) 0x3);
@


1.292.2.4
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	Backport from mainline:

	2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>
		    Catherine Moore  <clm@@codesourcery.com>
		    Sandra Loosemore  <sandra@@codesourcery.com>
		    Richard Sandiford  <rdsandiford@@googlemail.com>

	* elfxx-mips.c (mips_elf_local_pic_function_p): Return true when
	H is a MIPS16 function with a kept 32-bit stub. Update comments.
	(mips_elf_get_la25_target): New function.
	(mips_elf_add_la25_intro): Change to use mips_elf_get_la25_target().
	(mips_elf_add_la25_stub): Move compute of use_trampoline_p down,
	change to use mips_elf_get_la25_target().
	(mips_elf_relocation_needs_la25_stub): Add target_is_16_bit_code_p
	parameter, add switch case for R_MIPS16_26.
	(mips_elf_calculate_relocation): Redirect relocation to point to the
	LA25 stub if it exists, instead of the MIPS16 stub. Update arguments
	of call to mips_elf_relocation_needs_la25_stub(), don't use la25 stub
	for mips16->mips16 calls.
	(_bfd_mips_elf_check_relocs): Update arguments of call to
	mips_elf_relocation_needs_la25_stub().
	(mips_elf_create_la25_stub): Change to use mips_elf_get_la25_target().
@
text
@d1578 3
a1580 4
   that it or its fn_stub might need $25 to be valid on entry.
   Note that MIPS16 functions set up $gp using PC-relative instructions,
   so they themselves never need $25 to be valid.  Only non-MIPS16
   entry points are of interest here.  */
d1589 1
a1589 2
	  && (!ELF_ST_IS_MIPS16 (h->root.other)
	      || (h->fn_stub && h->need_fn_stub))
a1593 20
/* Set *SEC to the input section that contains the target of STUB.
   Return the offset of the target from the start of that section.  */

static bfd_vma
mips_elf_get_la25_target (struct mips_elf_la25_stub *stub,
			  asection **sec)
{
  if (ELF_ST_IS_MIPS16 (stub->h->root.other))
    {
      BFD_ASSERT (stub->h->need_fn_stub);
      *sec = stub->h->fn_stub;
      return 0;
    }
  else
    {
      *sec = stub->h->root.root.u.def.section;
      return stub->h->root.root.u.def.value;
    }
}

d1618 1
a1618 1
  mips_elf_get_la25_target (stub, &input_section);
d1692 6
a1726 5
  /* Prefer to use LUI/ADDIU stubs if the function is at the beginning
     of the section and if we would need no more than 2 nops.  */
  value = mips_elf_get_la25_target (stub, &s);
  use_trampoline_p = (value != 0 || s->alignment_power > 4);

d4914 1
a4914 2
mips_elf_relocation_needs_la25_stub (bfd *input_bfd, int r_type,
				     bfd_boolean target_is_16_bit_code_p)
d4928 1
a4935 3
    case R_MIPS16_26:
      return !target_is_16_bit_code_p;

d5196 1
a5196 4
	{
	  sec = elf_tdata (input_bfd)->local_stubs[r_symndx];
	  value = 0;
	}
d5200 1
a5200 12
	  if (h->la25_stub)
	    {
	      /* If a LA25 header for the stub itself exists, point to the
		 prepended LUI/ADDIU sequence.  */
	      sec = h->la25_stub->stub_section;
	      value = h->la25_stub->offset;
	    }
	  else
	    {
	      sec = h->fn_stub;
	      value = 0;
	    }
d5203 1
a5203 1
      symbol = sec->output_section->vma + sec->output_offset + value;
d5253 1
a5253 2
	   && mips_elf_relocation_needs_la25_stub (input_bfd, r_type,
						   target_is_16_bit_code_p))
d7928 1
a7928 3
      if (h != NULL
	  && mips_elf_relocation_needs_la25_stub (abfd, r_type,
						  ELF_ST_IS_MIPS16 (h->other)))
d9625 3
a9627 3
  target = mips_elf_get_la25_target (stub, &s);
  target += s->output_section->vma + s->output_offset;

@


1.292.2.5
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	Backport from mainline:

	2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	gas/
	* config/tc-mips.c (mips_pseudo_table): Add tprelword/tpreldword
	entries.
	(mips16_percent_op): Add MIPS16 TLS relocation ops.
	(md_apply_fix): Add BFD_RELOC_MIPS16_TLS_* switch cases.
	(s_tls_rel_directive): Rename from s_dtprel_internal(). Abstract out
	directive string and reloc type as function parameters. Update
	comments.
	(s_dtprelword,s_dtpreldword): Change to use s_tls_rel_directive().
	(s_tprelword,s_tpreldword): New functions.

	include/
	* elf/mips.h (elf_mips_reloc_type): Add R_MIPS16_TLS_* entries.

	bfd/
	* reloc.c (BFD_RELOC_MIPS16_TLS_GD,BFD_RELOC_MIPS16_TLS_LDM,
	BFD_RELOC_MIPS16_TLS_DTPREL_HI16,BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
	BFD_RELOC_MIPS16_TLS_GOTTPREL,BFD_RELOC_MIPS16_TLS_TPREL_HI16,
	BFD_RELOC_MIPS16_TLS_TPREL_LO16): New relocations for MIPS16 TLS.
	* bfd-in2.h (bfd_reloc_code_real): Regenerate.
	* libbfd.h (bfd_reloc_code_real_names): Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Add R_MIPS16_TLS_*
	entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel,
	elf_mips16_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel,
	mips16_elf64_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfxx-mips.c (TLS_RELOC_P,mips16_reloc_p,
	_bfd_mips_elf_check_relocs): Add cases for R_MIPS16_TLS_* relocations.
	(tls_gd_reloc_p): Add R_MIPS16_TLS_GD case.
	(tls_ldm_reloc_p): Add R_MIPS16_TLS_LDM case.
	(tls_gottprel_reloc_p): Add R_MIPS16_TLS_GOTTPREL case.
	(mips_elf_calculate_relocation): Add cases for R_MIPS16_TLS_*,
	R_MIPS_TLS_DTPREL32/64, and R_MIPS_TLS_TPREL32/64 relocations.
@
text
@a531 7
   || r_type == R_MIPS16_TLS_GD			\
   || r_type == R_MIPS16_TLS_LDM		\
   || r_type == R_MIPS16_TLS_DTPREL_HI16	\
   || r_type == R_MIPS16_TLS_DTPREL_LO16	\
   || r_type == R_MIPS16_TLS_GOTTPREL		\
   || r_type == R_MIPS16_TLS_TPREL_HI16		\
   || r_type == R_MIPS16_TLS_TPREL_LO16		\
a1887 7
    case R_MIPS16_TLS_GD:
    case R_MIPS16_TLS_LDM:
    case R_MIPS16_TLS_DTPREL_HI16:
    case R_MIPS16_TLS_DTPREL_LO16:
    case R_MIPS16_TLS_GOTTPREL:
    case R_MIPS16_TLS_TPREL_HI16:
    case R_MIPS16_TLS_TPREL_LO16:
d2015 1
a2015 3
  return (r_type == R_MIPS_TLS_GD
	  || r_type == R_MIPS16_TLS_GD
	  || r_type == R_MICROMIPS_TLS_GD);
d2021 1
a2021 3
  return (r_type == R_MIPS_TLS_LDM
	  || r_type == R_MIPS16_TLS_LDM
	  || r_type == R_MICROMIPS_TLS_LDM);
d2027 1
a2027 3
  return (r_type == R_MIPS_TLS_GOTTPREL
	  || r_type == R_MIPS16_TLS_GOTTPREL
	  || r_type == R_MICROMIPS_TLS_GOTTPREL);
a5363 3
    case R_MIPS16_TLS_GD:
    case R_MIPS16_TLS_GOTTPREL:
    case R_MIPS16_TLS_LDM:
a5532 1
    case R_MIPS16_TLS_DTPREL_HI16:
a5540 1
    case R_MIPS16_TLS_DTPREL_LO16:
a5545 1
    case R_MIPS16_TLS_TPREL_HI16:
a5551 3
    case R_MIPS_TLS_TPREL32:
    case R_MIPS_TLS_TPREL64:
    case R_MIPS16_TLS_TPREL_LO16:
a5683 3
    case R_MIPS16_TLS_GD:
    case R_MIPS16_TLS_GOTTPREL:
    case R_MIPS16_TLS_LDM:
d7816 2
a7829 5
	case R_MIPS16_GOT16:
	case R_MIPS16_CALL16:
	case R_MIPS16_TLS_GOTTPREL:
	case R_MIPS16_TLS_GD:
	case R_MIPS16_TLS_LDM:
a8065 1
	case R_MIPS16_TLS_GOTTPREL:
a8071 1
	case R_MIPS16_TLS_LDM:
a8080 1
	case R_MIPS16_TLS_GD:
@


1.292.2.6
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d9388 1
a9388 1
      if (sec != NULL && discarded_section (sec))
@


1.291
log
@	* elfxx-mips.c (check_br32): Fix return type.
@
text
@d12267 3
a12269 7
/* Bitsize checking.  */
#define IS_BITSIZE(val, N)						\
  (((((val) & ((1ULL << (N)) - 1)) ^ (1ULL << ((N) - 1)))		\
    - (1ULL << ((N) - 1))) == (val))

/* See if relocations [INTERNAL_RELOCS, IRELEND) confirm that there
   is a 4-byte branch at offset OFFSET.  */
d12272 3
a12274 2
check_4byte_branch (Elf_Internal_Rela *internal_relocs,
		    Elf_Internal_Rela *irelend, bfd_vma offset)
d12276 8
a12283 2
  Elf_Internal_Rela *irel;
  unsigned long r_type;
d12286 4
a12289 8
    if (irel->r_offset == offset)
      {
	r_type = ELF32_R_TYPE (irel->r_info);
	if (r_type == R_MICROMIPS_26_S1
	    || r_type == R_MICROMIPS_PC16_S1
	    || r_type == R_MICROMIPS_JALR)
	  return TRUE;
      }
d12292 6
d12459 1
d12483 4
a12486 1
	  /* See if the LUI instruction *might* be in a branch delay slot.  */
d12490 3
a12492 6
		   /* If the instruction is actually a 4-byte branch,
		      the value of check_br16_dslot doesn't matter.
		      We should use check_br32_dslot to check whether
		      the branch has a delay slot.  */
		   && check_4byte_branch (internal_relocs, irelend,
					  irel->r_offset - 4)))
d12495 1
@


1.290
log
@	* elfxx-mips.c (bz_insn_16): Correct opcode mask.
@
text
@d12242 1
a12242 1
static int
@


1.289
log
@	bfd/
	* elfxx-mips.c: Adjust comments throughout.
	(mips_elf_relax_delete_bytes): Reshape code.
	(_bfd_mips_elf_relax_section): Remove check for
	R_MICROMIPS_GPREL16 relocations.  Reshape code.

	gas/
	* config/tc-mips.c: Adjust comments throughout.
	(reglist_lookup): Reshape code.
	(jmp_reloc_p, jalr_reloc_p): Reformat.
	(got16_reloc_p, hi16_reloc_p, lo16_reloc_p): Handle microMIPS
	relocations.
	(gpr_mod_mask): Remove unused variable.
	(gpr_read_mask, gpr_write_mask): Reshape code.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(nops_for_vr4130): Ensure non-microMIPS mode.
	(can_swap_branch_p): Correct pinfo2 reference.  Reshape code.
	(append_insn): Skip Loongson 2F workaround in MIPS16 mode.  Use
	the outermost operator of a compound relocation to determines
	the relocated field.  Fix formatting.
	(md_convert_frag): Reshape code.

	include/opcode/
	* mips.h: Clarify the description of microMIPS instruction
	manipulation macros.
	(MICROMIPSOP_MASK_MAJOR, MICROMIPSOP_SH_MAJOR): Remove macros.
@
text
@d11990 1
a11990 1
  { /* "b(eq|ne)z", "md,mE",	*/ 0x8c00,     0xac00 };
@


1.288
log
@bfd/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Ilie Garbacea  <ilie@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Catherine Moore  <clm@@codesourcery.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* archures.c (bfd_mach_mips_micromips): New macro.
	* cpu-mips.c (I_micromips): New enum value.
	(arch_info_struct): Add bfd_mach_mips_micromips.
	* elfxx-mips.h (_bfd_mips_elf_is_target_special_symbol): New
	prototype.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(gprel16_reloc_p): Handle microMIPS ASE.
	(literal_reloc_p): New function.
	* elf32-mips.c (elf_micromips_howto_table_rel): New variable.
	(_bfd_mips_elf32_gprel16_reloc): Handle microMIPS ASE.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(mips_elf_gprel32_reloc): Update comment.
	(micromips_reloc_map): New variable.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(mips_elf32_rtype_to_howto): Likewise.
	(mips_info_to_howto_rel): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	(bfd_elf32_bfd_relax_section): Likewise.
	* elf64-mips.c (micromips_elf64_howto_table_rel): New variable.
	(micromips_elf64_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf64_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf64_bfd_reloc_name_lookup): Likewise.
	(mips_elf64_rtype_to_howto): Likewise.
	(bfd_elf64_bfd_is_target_special_symbol): Define.
	* elfn32-mips.c (elf_micromips_howto_table_rel): New variable.
	(elf_micromips_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(mips_elf_n32_rtype_to_howto): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	* elfxx-mips.c (LA25_LUI_MICROMIPS_1): New macro.
	(LA25_LUI_MICROMIPS_2): Likewise.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise.
	(TLS_RELOC_P): Handle microMIPS ASE.
	(mips_elf_create_stub_symbol): Adjust value of stub symbol if
	target is a microMIPS function.
	(micromips_reloc_p): New function.
	(micromips_reloc_shuffle_p): Likewise.
	(got16_reloc_p, call16_reloc_p): Handle microMIPS ASE.
	(got_disp_reloc_p, got_page_reloc_p): New functions.
	(got_ofst_reloc_p): Likewise.
	(got_hi16_reloc_p, got_lo16_reloc_p): Likewise.
	(call_hi16_reloc_p, call_lo16_reloc_p): Likewise.
	(hi16_reloc_p, lo16_reloc_p, jal_reloc_p): Handle microMIPS ASE.
	(micromips_branch_reloc_p): New function.
	(tls_gd_reloc_p, tls_ldm_reloc_p): Likewise.
	(tls_gottprel_reloc_p): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(_bfd_mips_elf_lo16_reloc): Handle microMIPS ASE.
	(mips_tls_got_index, mips_elf_got_page): Likewise.
	(mips_elf_create_local_got_entry): Likewise.
	(mips_elf_relocation_needs_la25_stub): Likewise.
	(mips_elf_calculate_relocation): Likewise.
	(mips_elf_perform_relocation): Likewise.
	(_bfd_mips_elf_symbol_processing): Likewise.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_link_output_symbol_hook): Likewise.
	(mips_elf_add_lo16_rel_addend): Likewise.
	(_bfd_mips_elf_check_relocs): Likewise.
	(mips_elf_adjust_addend): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_la25_stub): Likewise.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_gc_sweep_hook): Likewise.
	(_bfd_mips_elf_is_target_special_symbol): New function.
	(mips_elf_relax_delete_bytes): Likewise.
	(opcode_descriptor): New structure.
	(RA): New macro.
	(OP32_SREG, OP32_TREG, OP16_VALID_REG): Likewise.
	(b_insns_32, bc_insn_32, bz_insn_32, bzal_insn_32): New variables.
	(beq_insn_32): Likewise.
	(b_insn_16, bz_insn_16): New variables.
	(BZC32_REG_FIELD): New macro.
	(bz_rs_insns_32, bz_rt_insns_32): New variables.
	(bzc_insns_32, bz_insns_16):Likewise.
	(BZ16_REG, BZ16_REG_FIELD): New macros.
	(jal_insn_32_bd16, jal_insn_32_bd32): New variables.
	(jal_x_insn_32_bd32): Likewise.
	(j_insn_32, jalr_insn_32): Likewise.
	(ds_insns_32_bd16, ds_insns_32_bd32): Likewise.
	(jalr_insn_16_bd16, jalr_insn_16_bd32, jr_insn_16): Likewise.
	(JR16_REG): New macro.
	(ds_insns_16_bd16): New variable.
	(lui_insn): Likewise.
	(addiu_insn, addiupc_insn): Likewise.
	(ADDIUPC_REG_FIELD): New macro.
	(MOVE32_RD, MOVE32_RS): Likewise.
	(MOVE16_RD_FIELD, MOVE16_RS_FIELD): Likewise.
	(move_insns_32, move_insns_16): New variables.
	(nop_insn_32, nop_insn_16): Likewise.
	(MATCH): New macro.
	(find_match): New function.
	(check_br16_dslot, check_br32_dslot): Likewise.
	(check_br16, check_br32): Likewise.
	(IS_BITSIZE): New macro.
	(check_4byte_branch): New function.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips_elf_merge_private_bfd_data): Disallow linking MIPS16
	and microMIPS modules together.
	(_bfd_mips_elf_print_private_bfd_data):	Handle microMIPS ASE.
	* reloc.c (BFD_RELOC_MICROMIPS_7_PCREL_S1): New relocation.
	(BFD_RELOC_MICROMIPS_10_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_16_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_GPREL16): Likewise.
	(BFD_RELOC_MICROMIPS_JMP, BFD_RELOC_MICROMIPS_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_HI16_S): Likewise.
	(BFD_RELOC_MICROMIPS_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_LITERAL): Likewise.
	(BFD_RELOC_MICROMIPS_GOT16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_SUB): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_PAGE): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_OFST): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHEST): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHER): Likewise.
	(BFD_RELOC_MICROMIPS_SCN_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_JALR): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GD): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_LDM): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GOTTPREL): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

binutils/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* readelf.c (get_machine_flags): Handle microMIPS ASE.
	(get_mips_symbol_other): Likewise.

gas/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.h (mips_segment_info): Add one bit for
	microMIPS.
	(TC_LABEL_IS_LOCAL): New macro.
	(mips_label_is_local): New prototype.
	* config/tc-mips.c (S0, S7): New macros.
	(emit_branch_likely_macro): New variable.
	(mips_set_options): Add micromips.
	(mips_opts): Initialise micromips to -1.
	(file_ase_micromips): New variable.
	(CPU_HAS_MICROMIPS): New macro.
	(hilo_interlocks): Set for microMIPS too.
	(gpr_interlocks): Likewise.
	(cop_interlocks): Likewise.
	(cop_mem_interlocks): Likewise.
	(HAVE_CODE_COMPRESSION): New macro.
	(micromips_op_hash): New variable.
	(micromips_nop16_insn, micromips_nop32_insn): New variables.
	(NOP_INSN): Handle microMIPS ASE.
	(mips32_to_micromips_reg_b_map): New macro.
	(mips32_to_micromips_reg_c_map): Likewise.
	(mips32_to_micromips_reg_d_map): Likewise.
	(mips32_to_micromips_reg_e_map): Likewise.
	(mips32_to_micromips_reg_f_map): Likewise.
	(mips32_to_micromips_reg_g_map): Likewise.
	(mips32_to_micromips_reg_l_map): Likewise.
	(mips32_to_micromips_reg_n_map): Likewise.
	(mips32_to_micromips_reg_h_map): New variable.
	(mips32_to_micromips_reg_m_map): Likewise.
	(mips32_to_micromips_reg_q_map): Likewise.
	(micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_to_32_reg_b_map): New macro.
	(micromips_to_32_reg_c_map): Likewise.
	(micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map): Likewise.
	(micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map): Likewise.
	(micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_n_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): New macros.
	(RELAX_DELAY_SLOT_16BIT): New macro.
	(RELAX_DELAY_SLOT_SIZE_FIRST): Likewise.
	(RELAX_DELAY_SLOT_SIZE_SECOND): Likewise.
	(RELAX_MICROMIPS_ENCODE, RELAX_MICROMIPS_P): New macros.
	(RELAX_MICROMIPS_TYPE, RELAX_MICROMIPS_AT): Likewise.
	(RELAX_MICROMIPS_U16BIT, RELAX_MICROMIPS_UNCOND): Likewise.
	(RELAX_MICROMIPS_COMPACT, RELAX_MICROMIPS_LINK): Likewise.
	(RELAX_MICROMIPS_RELAX32, RELAX_MICROMIPS_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR32): Likewise.
	(INSERT_OPERAND, EXTRACT_OPERAND): Handle microMIPS ASE.
	(mips_macro_warning): Add delay_slot_16bit_p, delay_slot_32bit_p,
	fsize and insns.
	(mips_mark_labels): New function.
	(mips16_small, mips16_ext): Remove variables, replacing with...
	(forced_insn_size): ... this.
	(append_insn, mips16_ip): Update accordingly.
	(micromips_insn_length): New function.
	(insn_length): Return the length of microMIPS instructions.
	(mips_record_mips16_mode): Rename to...
	(mips_record_compressed_mode): ... this.  Handle microMIPS ASE.
	(install_insn): Handle microMIPS ASE.
	(reglist_lookup): New function.
	(is_size_valid, is_delay_slot_valid): Likewise.
	(md_begin): Handle microMIPS ASE.
	(md_assemble): Likewise.  Update for append_insn interface change.
	(micromips_reloc_p): New function.
	(got16_reloc_p): Handle microMIPS ASE.
	(hi16_reloc_p): Likewise.
	(lo16_reloc_p): Likewise.
	(jmp_reloc_p): New function.
	(jalr_reloc_p): Likewise.
	(matching_lo_reloc): Handle microMIPS ASE.
	(insn_uses_reg, reg_needs_delay): Likewise.
	(mips_move_labels): Likewise.
	(mips16_mark_labels): Rename to...
	(mips_compressed_mark_labels): ... this.  Handle microMIPS ASE.
	(gpr_mod_mask): New function.
	(gpr_read_mask, gpr_write_mask): Handle microMIPS ASE.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(insns_between, nops_for_vr4130, nops_for_insn): Likewise.
	(fix_loongson2f_nop, fix_loongson2f_jump): Likewise.
	(MICROMIPS_LABEL_CHAR): New macro.
	(micromips_target_label, micromips_target_name): New variables.
	(micromips_label_name, micromips_label_expr): New functions.
	(micromips_label_inc, micromips_add_label): Likewise.
	(mips_label_is_local): Likewise.
	(micromips_map_reloc): Likewise.
	(can_swap_branch_p): Handle microMIPS ASE.
	(append_insn): Add expansionp argument.  Handle microMIPS ASE.
	(start_noreorder, end_noreorder): Handle microMIPS ASE.
	(macro_start, macro_warning, macro_end): Likewise.
	(brk_fmt, cop12_fmt, jalr_fmt, lui_fmt): New variables.
	(mem12_fmt, mfhl_fmt, shft_fmt, trap_fmt): Likewise.
	(BRK_FMT, COP12_FMT, JALR_FMT, LUI_FMT): New macros.
	(MEM12_FMT, MFHL_FMT, SHFT_FMT, TRAP_FMT): Likewise.
	(macro_build): Handle microMIPS ASE.  Update for append_insn
	interface change.
	(mips16_macro_build): Update for append_insn interface change.
	(macro_build_jalr): Handle microMIPS ASE.
	(macro_build_lui): Likewise.  Simplify.
	(load_register): Handle microMIPS ASE.
	(load_address): Likewise.
	(move_register): Likewise.
	(macro_build_branch_likely): New function.
	(macro_build_branch_ccl): Likewise.
	(macro_build_branch_rs): Likewise.
	(macro_build_branch_rsrt): Likewise.
	(macro): Handle microMIPS ASE.
	(validate_micromips_insn): New function.
	(expr_const_in_range): Likewise.
	(mips_ip): Handle microMIPS ASE.
	(options): Add OPTION_MICROMIPS and OPTION_NO_MICROMIPS.
	(md_longopts): Add mmicromips and mno-micromips.
	(md_parse_option): Handle OPTION_MICROMIPS and
	OPTION_NO_MICROMIPS.
	(mips_after_parse_args): Handle microMIPS ASE.
	(md_pcrel_from): Handle microMIPS relocations.
	(mips_force_relocation): Likewise.
	(md_apply_fix): Likewise.
	(mips_align): Handle microMIPS ASE.
	(s_mipsset): Likewise.
	(s_cpload, s_cpsetup, s_cpreturn): Use relocation wrappers.
	(s_dtprel_internal): Likewise.
	(s_gpword, s_gpdword): Likewise.
	(s_insn): Handle microMIPS ASE.
	(s_mips_stab): Likewise.
	(relaxed_micromips_32bit_branch_length): New function.
	(relaxed_micromips_16bit_branch_length): New function.
	(md_estimate_size_before_relax): Handle microMIPS ASE.
	(mips_fix_adjustable): Likewise.
	(tc_gen_reloc): Handle microMIPS relocations.
	(mips_relax_frag): Handle microMIPS ASE.
	(md_convert_frag): Likewise.
	(mips_frob_file_after_relocs): Likewise.
	(mips_elf_final_processing): Likewise.
	(mips_nop_opcode): Likewise.
	(mips_handle_align): Likewise.
	(md_show_usage): Handle microMIPS options.
	* symbols.c (TC_LABEL_IS_LOCAL): New macro.
	(S_IS_LOCAL): Add a TC_LABEL_IS_LOCAL check.

	* doc/as.texinfo (Target MIPS options): Add -mmicromips and
	-mno-micromips.
	(-mmicromips, -mno-micromips): New options.
	* doc/c-mips.texi (-mmicromips, -mno-micromips): New options.
	(MIPS ISA): Document .set micromips and .set nomicromips.
	(MIPS insn): Update for microMIPS support.

gas/testsuite/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/micromips.d: New test.
	* gas/mips/micromips-branch-delay.d: Likewise.
	* gas/mips/micromips-branch-relax.d: Likewise.
	* gas/mips/micromips-branch-relax-pic.d: Likewise.
	* gas/mips/micromips-size-1.d: Likewise.
	* gas/mips/micromips-trap.d: Likewise.
	* gas/mips/micromips.l: New stderr output.
	* gas/mips/micromips-branch-delay.l: Likewise.
	* gas/mips/micromips-branch-relax.l: Likewise.
	* gas/mips/micromips-branch-relax-pic.l: Likewise.
	* gas/mips/micromips-size-0.l: New list test.
	* gas/mips/micromips-size-1.l: New stderr output.
	* gas/mips/micromips.s: New test source.
	* gas/mips/micromips-branch-delay.s: Likewise.
	* gas/mips/micromips-branch-relax.s: Likewise.
	* gas/mips/micromips-size-0.s: Likewise.
	* gas/mips/micromips-size-1.s: Likewise.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/dli.s: Use .p2align.
	* gas/mips/elf_ase_micromips.d: New test.
	* gas/mips/elf_ase_micromips-2.d: Likewise.
	* gas/mips/micromips@@abs.d: Likewise.
	* gas/mips/micromips@@add.d: Likewise.
	* gas/mips/micromips@@alnv_ps-swap.d: Likewise.
	* gas/mips/micromips@@and.d: Likewise.
	* gas/mips/micromips@@beq.d: Likewise.
	* gas/mips/micromips@@bge.d: Likewise.
	* gas/mips/micromips@@bgeu.d: Likewise.
	* gas/mips/micromips@@blt.d: Likewise.
	* gas/mips/micromips@@bltu.d: Likewise.
	* gas/mips/micromips@@branch-likely.d: Likewise.
	* gas/mips/micromips@@branch-misc-1.d: Likewise.
	* gas/mips/micromips@@branch-misc-2-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic.d: Likewise.
	* gas/mips/micromips@@branch-misc-4-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-4.d: Likewise.
	* gas/mips/micromips@@branch-self.d: Likewise.
	* gas/mips/micromips@@cache.d: Likewise.
	* gas/mips/micromips@@daddi.d: Likewise.
	* gas/mips/micromips@@dli.d: Likewise.
	* gas/mips/micromips@@elf-jal.d: Likewise.
	* gas/mips/micromips@@elf-rel2.d: Likewise.
	* gas/mips/micromips@@elfel-rel2.d: Likewise.
	* gas/mips/micromips@@elf-rel4.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic-noreorder.d: Likewise.
	* gas/mips/micromips@@lb-svr4pic-ilocks.d: Likewise.
	* gas/mips/micromips@@li.d: Likewise.
	* gas/mips/micromips@@loc-swap-dis.d: Likewise.
	* gas/mips/micromips@@loc-swap.d: Likewise.
	* gas/mips/micromips@@mips1-fp.d: Likewise.
	* gas/mips/micromips@@mips32-cp2.d: Likewise.
	* gas/mips/micromips@@mips32-imm.d: Likewise.
	* gas/mips/micromips@@mips32-sf32.d: Likewise.
	* gas/mips/micromips@@mips32.d: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.d: Likewise.
	* gas/mips/micromips@@mips32r2-fp32.d: Likewise.
	* gas/mips/micromips@@mips32r2-sync.d: Likewise.
	* gas/mips/micromips@@mips32r2.d: Likewise.
	* gas/mips/micromips@@mips4-branch-likely.d: Likewise.
	* gas/mips/micromips@@mips4-fp.d: Likewise.
	* gas/mips/micromips@@mips4.d: Likewise.
	* gas/mips/micromips@@mips5.d: Likewise.
	* gas/mips/micromips@@mips64-cp2.d: Likewise.
	* gas/mips/micromips@@mips64.d: Likewise.
	* gas/mips/micromips@@mips64r2.d: Likewise.
	* gas/mips/micromips@@pref.d: Likewise.
	* gas/mips/micromips@@relax-at.d: Likewise.
	* gas/mips/micromips@@relax.d: Likewise.
	* gas/mips/micromips@@rol-hw.d: Likewise.
	* gas/mips/micromips@@uld2-eb.d: Likewise.
	* gas/mips/micromips@@uld2-el.d: Likewise.
	* gas/mips/micromips@@ulh2-eb.d: Likewise.
	* gas/mips/micromips@@ulh2-el.d: Likewise.
	* gas/mips/micromips@@ulw2-eb-ilocks.d: Likewise.
	* gas/mips/micromips@@ulw2-el-ilocks.d: Likewise.
	* gas/mips/cache.d: Likewise.
	* gas/mips/daddi.d: Likewise.
	* gas/mips/mips32-imm.d: Likewise.
	* gas/mips/pref.d: Likewise.
	* gas/mips/elf-rel27.d: Handle microMIPS ASE.
	* gas/mips/l_d.d: Likewise.
	* gas/mips/l_d-n32.d: Likewise.
	* gas/mips/l_d-n64.d: Likewise.
	* gas/mips/ld.d: Likewise.
	* gas/mips/ld-n32.d: Likewise.
	* gas/mips/ld-n64.d: Likewise.
	* gas/mips/s_d.d: Likewise.
	* gas/mips/s_d-n32.d: Likewise.
	* gas/mips/s_d-n64.d: Likewise.
	* gas/mips/sd.d: Likewise.
	* gas/mips/sd-n32.d: Likewise.
	* gas/mips/sd-n64.d: Likewise.
	* gas/mips/mips32.d: Update immediates.
	* gas/mips/micromips@@mips32-cp2.s: New test source.
	* gas/mips/micromips@@mips32-imm.s: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.s: Likewise.
	* gas/mips/micromips@@mips64-cp2.s: Likewise.
	* gas/mips/cache.s: Likewise.
	* gas/mips/daddi.s: Likewise.
	* gas/mips/mips32-imm.s: Likewise.
	* gas/mips/elf-rel4.s: Handle microMIPS ASE.
	* gas/mips/lb-pic.s: Likewise.
	* gas/mips/ld.s: Likewise.
	* gas/mips/mips32.s: Likewise.
	* gas/mips/mips.exp: Add the micromips arch.  Exclude mips16e
	from micromips.  Run mips32-imm.

	* gas/mips/jal-mask-11.d: New test.
	* gas/mips/jal-mask-12.d: Likewise.
	* gas/mips/micromips@@jal-mask-11.d: Likewise.
	* gas/mips/jal-mask-1.s: Source for the new tests.
	* gas/mips/jal-mask-21.d: New test.
	* gas/mips/jal-mask-22.d: Likewise.
	* gas/mips/micromips@@jal-mask-12.d: Likewise.
	* gas/mips/jal-mask-2.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/mips16-e.d: Add --special-syms to `objdump'.
	* gas/mips/tmips16-e.d: Likewise.
	* gas/mips/mipsel16-e.d: Likewise.
	* gas/mips/tmipsel16-e.d: Likewise.

	* gas/mips/and.s: Adjust padding.
	* gas/mips/beq.s: Likewise.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.s: Likewise.
	* gas/mips/jal.s: Likewise.
	* gas/mips/li.s: Likewise.
	* gas/mips/mips4.s: Likewise.
	* gas/mips/mips4-fp.s: Likewise.
	* gas/mips/relax.s: Likewise.
	* gas/mips/and.d: Update accordingly.
	* gas/mips/elf-jal.d: Likewise.
	* gas/mips/jal.d: Likewise.
	* gas/mips/li.d: Likewise.
	* gas/mips/relax-at.d: Likewise.
	* gas/mips/relax.d: Likewise.

include/elf/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (R_MICROMIPS_min): New relocations.
	(R_MICROMIPS_26_S1): Likewise.
	(R_MICROMIPS_HI16, R_MICROMIPS_LO16): Likewise.
	(R_MICROMIPS_GPREL16, R_MICROMIPS_LITERAL): Likewise.
	(R_MICROMIPS_GOT16, R_MICROMIPS_PC7_S1): Likewise.
	(R_MICROMIPS_PC10_S1, R_MICROMIPS_PC16_S1): Likewise.
	(R_MICROMIPS_CALL16, R_MICROMIPS_GOT_DISP): Likewise.
	(R_MICROMIPS_GOT_PAGE, R_MICROMIPS_GOT_OFST): Likewise.
	(R_MICROMIPS_GOT_HI16, R_MICROMIPS_GOT_LO16): Likewise.
	(R_MICROMIPS_SUB, R_MICROMIPS_HIGHER): Likewise.
	(R_MICROMIPS_HIGHEST, R_MICROMIPS_CALL_HI16): Likewise.
	(R_MICROMIPS_CALL_LO16, R_MICROMIPS_SCN_DISP): Likewise.
	(R_MICROMIPS_JALR, R_MICROMIPS_HI0_LO16): Likewise.
	(R_MICROMIPS_TLS_GD, R_MICROMIPS_TLS_LDM): Likewise.
	(R_MICROMIPS_TLS_DTPREL_HI, R_MICROMIPS_TLS_DTPREL_LO): Likewise.
	(R_MICROMIPS_TLS_GOTTPREL): Likewise.
	(R_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(R_MICROMIPS_TLS_TPREL_LO16): Likewise.
	(R_MICROMIPS_GPREL7_S2, R_MICROMIPS_PC23_S2): Likewise.
	(R_MICROMIPS_max): Likewise.
	(EF_MIPS_ARCH_ASE_MICROMIPS): New macro.
	(STO_MIPS_ISA, STO_MIPS_FLAGS): Likewise.
	(ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT): Likewise.
	(STO_MICROMIPS): Likewise.
	(ELF_ST_IS_MICROMIPS, ELF_ST_SET_MICROMIPS): Likewise.
	(ELF_ST_IS_COMPRESSED): Likewise.
	(STO_MIPS_PLT, STO_MIPS_PIC): Rework.
	(ELF_ST_IS_MIPS_PIC, ELF_ST_SET_MIPS_PIC): Likewise.
	(STO_MIPS16, ELF_ST_IS_MIPS16, ELF_ST_SET_MIPS16): Likewise.

include/opcode/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (OP_MASK_EXTLSB, OP_SH_EXTLSB): New macros.
	(OP_MASK_STYPE, OP_SH_STYPE): Likewise.
	(OP_MASK_CODE10, OP_SH_CODE10): Likewise.
	(OP_MASK_TRAP, OP_SH_TRAP): Likewise.
	(OP_MASK_OFFSET12, OP_SH_OFFSET12): Likewise.
	(OP_MASK_OFFSET10, OP_SH_OFFSET10): Likewise.
	(OP_MASK_RS3, OP_SH_RS3): Likewise.
	(OP_MASK_MB, OP_SH_MB, OP_MASK_MC, OP_SH_MC): Likewise.
	(OP_MASK_MD, OP_SH_MD, OP_MASK_ME, OP_SH_ME): Likewise.
	(OP_MASK_MF, OP_SH_MF, OP_MASK_MG, OP_SH_MG): Likewise.
	(OP_MASK_MJ, OP_SH_MJ, OP_MASK_ML, OP_SH_ML): Likewise.
	(OP_MASK_MP, OP_SH_MP, OP_MASK_MQ, OP_SH_MQ): Likewise.
	(OP_MASK_IMMA, OP_SH_IMMA, OP_MASK_IMMB, OP_SH_IMMB): Likewise.
	(OP_MASK_IMMC, OP_SH_IMMC, OP_MASK_IMMF, OP_SH_IMMF): Likewise.
	(OP_MASK_IMMG, OP_SH_IMMG, OP_MASK_IMMH, OP_SH_IMMH): Likewise.
	(OP_MASK_IMMI, OP_SH_IMMI, OP_MASK_IMMJ, OP_SH_IMMJ): Likewise.
	(OP_MASK_IMML, OP_SH_IMML, OP_MASK_IMMM, OP_SH_IMMM): Likewise.
	(OP_MASK_IMMN, OP_SH_IMMN, OP_MASK_IMMO, OP_SH_IMMO): Likewise.
	(OP_MASK_IMMP, OP_SH_IMMP, OP_MASK_IMMQ, OP_SH_IMMQ): Likewise.
	(OP_MASK_IMMU, OP_SH_IMMU, OP_MASK_IMMW, OP_SH_IMMW): Likewise.
	(OP_MASK_IMMX, OP_SH_IMMX, OP_MASK_IMMY, OP_SH_IMMY): Likewise.
	(INSN_WRITE_GPR_S): New macro.
	(INSN2_BRANCH_DELAY_16BIT, INSN2_BRANCH_DELAY_32BIT): Likewise.
	(INSN2_READ_FPR_D): Likewise.
	(INSN2_MOD_GPR_MB, INSN2_MOD_GPR_MC): Likewise.
	(INSN2_MOD_GPR_MD, INSN2_MOD_GPR_ME): Likewise.
	(INSN2_MOD_GPR_MF, INSN2_MOD_GPR_MG): Likewise.
	(INSN2_MOD_GPR_MJ, INSN2_MOD_GPR_MP): Likewise.
	(INSN2_MOD_GPR_MQ, INSN2_MOD_SP): Likewise.
	(INSN2_READ_GPR_31, INSN2_READ_GP, INSN2_READ_PC): Likewise.
	(INSN2_UNCOND_BRANCH, INSN2_COND_BRANCH): Likewise.
	(INSN2_MOD_GPR_MHI, INSN2_MOD_GPR_MM, INSN2_MOD_GPR_MN): Likewise.
	(CPU_MICROMIPS): New macro.
	(M_BC1FL, M_BC1TL, M_BC2FL, M_BC2TL): New enum values.
	(M_BEQL, M_BGEZ, M_BGEZL, M_BGEZALL, M_BGTZ, M_BGTZL): Likewise.
	(M_BLEZ, M_BLEZL, M_BLTZ, M_BLTZL, M_BLTZALL, M_BNEL): Likewise.
	(M_CACHE_OB, M_JALS_1, M_JALS_2, M_JALS_A): Likewise.
	(M_LDC2_OB, M_LDL_OB, M_LDM_AB, M_LDM_OB): Likewise.
	(M_LDP_AB, M_LDP_OB, M_LDR_OB, M_LL_OB, M_LLD_OB): Likewise.
	(M_LWC2_OB, M_LWL_OB, M_LWM_AB, M_LWM_OB): Likewise.
	(M_LWP_AB, M_LWP_OB, M_LWR_OB): Likewise.
	(M_LWU_OB, M_PREF_OB, M_SC_OB, M_SCD_OB): Likewise.
	(M_SDC2_OB, M_SDL_OB, M_SDM_AB, M_SDM_OB): Likewise.
	(M_SDP_AB, M_SDP_OB, M_SDR_OB): Likewise.
	(M_SWC2_OB, M_SWL_OB, M_SWM_AB, M_SWM_OB): Likewise.
	(M_SWP_AB, M_SWP_OB, M_SWR_OB): Likewise.
	(MICROMIPSOP_MASK_MAJOR, MICROMIPSOP_SH_MAJOR): New macros.
	(MICROMIPSOP_MASK_IMMEDIATE, MICROMIPSOP_SH_IMMEDIATE): Likewise.
	(MICROMIPSOP_MASK_DELTA, MICROMIPSOP_SH_DELTA): Likewise.
	(MICROMIPSOP_MASK_CODE10, MICROMIPSOP_SH_CODE10): Likewise.
	(MICROMIPSOP_MASK_TRAP, MICROMIPSOP_SH_TRAP): Likewise.
	(MICROMIPSOP_MASK_SHAMT, MICROMIPSOP_SH_SHAMT): Likewise.
	(MICROMIPSOP_MASK_TARGET, MICROMIPSOP_SH_TARGET): Likewise.
	(MICROMIPSOP_MASK_EXTLSB, MICROMIPSOP_SH_EXTLSB): Likewise.
	(MICROMIPSOP_MASK_EXTMSBD, MICROMIPSOP_SH_EXTMSBD): Likewise.
	(MICROMIPSOP_MASK_INSMSB, MICROMIPSOP_SH_INSMSB): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_SEL, MICROMIPSOP_SH_SEL): Likewise.
	(MICROMIPSOP_MASK_OFFSET12, MICROMIPSOP_SH_OFFSET12): Likewise.
	(MICROMIPSOP_MASK_3BITPOS, MICROMIPSOP_SH_3BITPOS): Likewise.
	(MICROMIPSOP_MASK_STYPE, MICROMIPSOP_SH_STYPE): Likewise.
	(MICROMIPSOP_MASK_OFFSET10, MICROMIPSOP_SH_OFFSET10): Likewise.
	(MICROMIPSOP_MASK_RS, MICROMIPSOP_SH_RS): Likewise.
	(MICROMIPSOP_MASK_RT, MICROMIPSOP_SH_RT): Likewise.
	(MICROMIPSOP_MASK_RD, MICROMIPSOP_SH_RD): Likewise.
	(MICROMIPSOP_MASK_FS, MICROMIPSOP_SH_FS): Likewise.
	(MICROMIPSOP_MASK_FT, MICROMIPSOP_SH_FT): Likewise.
	(MICROMIPSOP_MASK_FD, MICROMIPSOP_SH_FD): Likewise.
	(MICROMIPSOP_MASK_FR, MICROMIPSOP_SH_FR): Likewise.
	(MICROMIPSOP_MASK_RS3, MICROMIPSOP_SH_RS3): Likewise.
	(MICROMIPSOP_MASK_PREFX, MICROMIPSOP_SH_PREFX): Likewise.
	(MICROMIPSOP_MASK_BCC, MICROMIPSOP_SH_BCC): Likewise.
	(MICROMIPSOP_MASK_CCC, MICROMIPSOP_SH_CCC): Likewise.
	(MICROMIPSOP_MASK_COPZ, MICROMIPSOP_SH_COPZ): Likewise.
	(MICROMIPSOP_MASK_MB, MICROMIPSOP_SH_MB): Likewise.
	(MICROMIPSOP_MASK_MC, MICROMIPSOP_SH_MC): Likewise.
	(MICROMIPSOP_MASK_MD, MICROMIPSOP_SH_MD): Likewise.
	(MICROMIPSOP_MASK_ME, MICROMIPSOP_SH_ME): Likewise.
	(MICROMIPSOP_MASK_MF, MICROMIPSOP_SH_MF): Likewise.
	(MICROMIPSOP_MASK_MG, MICROMIPSOP_SH_MG): Likewise.
	(MICROMIPSOP_MASK_MH, MICROMIPSOP_SH_MH): Likewise.
	(MICROMIPSOP_MASK_MI, MICROMIPSOP_SH_MI): Likewise.
	(MICROMIPSOP_MASK_MJ, MICROMIPSOP_SH_MJ): Likewise.
	(MICROMIPSOP_MASK_ML, MICROMIPSOP_SH_ML): Likewise.
	(MICROMIPSOP_MASK_MM, MICROMIPSOP_SH_MM): Likewise.
	(MICROMIPSOP_MASK_MN, MICROMIPSOP_SH_MN): Likewise.
	(MICROMIPSOP_MASK_MP, MICROMIPSOP_SH_MP): Likewise.
	(MICROMIPSOP_MASK_MQ, MICROMIPSOP_SH_MQ): Likewise.
	(MICROMIPSOP_MASK_IMMA, MICROMIPSOP_SH_IMMA): Likewise.
	(MICROMIPSOP_MASK_IMMB, MICROMIPSOP_SH_IMMB): Likewise.
	(MICROMIPSOP_MASK_IMMC, MICROMIPSOP_SH_IMMC): Likewise.
	(MICROMIPSOP_MASK_IMMD, MICROMIPSOP_SH_IMMD): Likewise.
	(MICROMIPSOP_MASK_IMME, MICROMIPSOP_SH_IMME): Likewise.
	(MICROMIPSOP_MASK_IMMF, MICROMIPSOP_SH_IMMF): Likewise.
	(MICROMIPSOP_MASK_IMMG, MICROMIPSOP_SH_IMMG): Likewise.
	(MICROMIPSOP_MASK_IMMH, MICROMIPSOP_SH_IMMH): Likewise.
	(MICROMIPSOP_MASK_IMMI, MICROMIPSOP_SH_IMMI): Likewise.
	(MICROMIPSOP_MASK_IMMJ, MICROMIPSOP_SH_IMMJ): Likewise.
	(MICROMIPSOP_MASK_IMML, MICROMIPSOP_SH_IMML): Likewise.
	(MICROMIPSOP_MASK_IMMM, MICROMIPSOP_SH_IMMM): Likewise.
	(MICROMIPSOP_MASK_IMMN, MICROMIPSOP_SH_IMMN): Likewise.
	(MICROMIPSOP_MASK_IMMO, MICROMIPSOP_SH_IMMO): Likewise.
	(MICROMIPSOP_MASK_IMMP, MICROMIPSOP_SH_IMMP): Likewise.
	(MICROMIPSOP_MASK_IMMQ, MICROMIPSOP_SH_IMMQ): Likewise.
	(MICROMIPSOP_MASK_IMMU, MICROMIPSOP_SH_IMMU): Likewise.
	(MICROMIPSOP_MASK_IMMW, MICROMIPSOP_SH_IMMW): Likewise.
	(MICROMIPSOP_MASK_IMMX, MICROMIPSOP_SH_IMMX): Likewise.
	(MICROMIPSOP_MASK_IMMY, MICROMIPSOP_SH_IMMY): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_CODE20, MICROMIPSOP_SH_CODE20): Likewise.
	(MICROMIPSOP_MASK_PERFREG, MICROMIPSOP_SH_PERFREG): Likewise.
	(MICROMIPSOP_MASK_CODE19, MICROMIPSOP_SH_CODE19): Likewise.
	(MICROMIPSOP_MASK_ALN, MICROMIPSOP_SH_ALN): Likewise.
	(MICROMIPSOP_MASK_VECBYTE, MICROMIPSOP_SH_VECBYTE): Likewise.
	(MICROMIPSOP_MASK_VECALIGN, MICROMIPSOP_SH_VECALIGN): Likewise.
	(MICROMIPSOP_MASK_DSPACC, MICROMIPSOP_SH_DSPACC): Likewise.
	(MICROMIPSOP_MASK_DSPACC_S, MICROMIPSOP_SH_DSPACC_S): Likewise.
	(MICROMIPSOP_MASK_DSPSFT, MICROMIPSOP_SH_DSPSFT): Likewise.
	(MICROMIPSOP_MASK_DSPSFT_7, MICROMIPSOP_SH_DSPSFT_7): Likewise.
	(MICROMIPSOP_MASK_SA3, MICROMIPSOP_SH_SA3): Likewise.
	(MICROMIPSOP_MASK_SA4, MICROMIPSOP_SH_SA4): Likewise.
	(MICROMIPSOP_MASK_IMM8, MICROMIPSOP_SH_IMM8): Likewise.
	(MICROMIPSOP_MASK_IMM10, MICROMIPSOP_SH_IMM10): Likewise.
	(MICROMIPSOP_MASK_WRDSP, MICROMIPSOP_SH_WRDSP): Likewise.
	(MICROMIPSOP_MASK_RDDSP, MICROMIPSOP_SH_RDDSP): Likewise.
	(MICROMIPSOP_MASK_BP, MICROMIPSOP_SH_BP): Likewise.
	(MICROMIPSOP_MASK_MT_U, MICROMIPSOP_SH_MT_U): Likewise.
	(MICROMIPSOP_MASK_MT_H, MICROMIPSOP_SH_MT_H): Likewise.
	(MICROMIPSOP_MASK_MTACC_T, MICROMIPSOP_SH_MTACC_T): Likewise.
	(MICROMIPSOP_MASK_MTACC_D, MICROMIPSOP_SH_MTACC_D): Likewise.
	(MICROMIPSOP_MASK_BBITIND, MICROMIPSOP_SH_BBITIND): Likewise.
	(MICROMIPSOP_MASK_CINSPOS, MICROMIPSOP_SH_CINSPOS): Likewise.
	(MICROMIPSOP_MASK_CINSLM1, MICROMIPSOP_SH_CINSLM1): Likewise.
	(MICROMIPSOP_MASK_SEQI, MICROMIPSOP_SH_SEQI): Likewise.
	(micromips_opcodes): New declaration.
	(bfd_micromips_num_opcodes): Likewise.

ld/testsuite/
2011-02-25  Catherine Moore  <clm@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* lib/ld-lib.exp (run_dump_test): Support distinct assembler
	flags for the same source named multiple times.
	* ld-mips-elf/jalx-1.s: New test source.
	* ld-mips-elf/jalx-1.d: New test output.
	* ld-mips-elf/jalx-1.ld: New test linker script.
	* ld-mips-elf/jalx-2-main.s: New test source.
	* ld-mips-elf/jalx-2-ex.s: Likewise.
	* ld-mips-elf/jalx-2-printf.s: Likewise.
	* ld-mips-elf/jalx-2.dd: New test output.
	* ld-mips-elf/jalx-2.ld: New test linker script.
	* ld-mips-elf/mips16-and-micromips.d: New test.
	* ld-mips-elf/mips-elf.exp: Run the new tests

opcodes/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* micromips-opc.c: New file.
	* mips-dis.c (micromips_to_32_reg_b_map): New array.
	(micromips_to_32_reg_c_map, micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map, micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map, micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): Likewise.
	(micromips_ase): New variable.
	(is_micromips): New function.
	(set_default_mips_dis_options): Handle microMIPS ASE.
	(print_insn_micromips): New function.
	(is_compressed_mode_p): Likewise.
	(_print_insn_mips): Handle microMIPS instructions.
	* Makefile.am (CFILES): Add micromips-opc.c.
	* configure.in (bfd_mips_arch): Add micromips-opc.lo.
	* Makefile.in: Regenerate.
	* configure: Regenerate.

	* mips-dis.c (micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_n_map): New macro.
@
text
@d11913 1
a11913 2
    if (isym->st_shndx == sec_shndx
	&& isym->st_value > addr)
d11930 1
a11930 1
	  bfd_vma value;
a11931 1
	  value = sym_hash->root.u.def.value;
d12337 1
d12349 1
a12349 2
	  && r_type != R_MICROMIPS_26_S1
	  && r_type != R_MICROMIPS_GPREL16)
d12362 1
d12434 2
a12435 2
      opcode  = bfd_get_16 (abfd, contents + irel->r_offset    ) << 16;
      opcode |= bfd_get_16 (abfd, contents + irel->r_offset + 2);
d12479 1
a12479 1
	      && check_br16_dslot (abfd, contents + irel->r_offset - 2) > 0
d12489 1
a12489 1
	      && check_br32_dslot (abfd, contents + irel->r_offset - 4) > 0)
d12504 1
a12504 1
	      if (check_br16 (abfd, contents + irel->r_offset + 4, reg))
d12508 1
a12508 1
	      if (check_br32 (abfd, contents + irel->r_offset + 4, reg))
d12583 1
a12583 2
	       && MATCH (bfd_get_16 (abfd, contents + irel->r_offset + 4),
			 nop_insn_16))
d12594 2
a12595 4
	  bfd_put_16 (abfd, (opcode >> 16) & 0xffff,
		      contents + irel->r_offset);
	  bfd_put_16 (abfd,  opcode        & 0xffff,
		      contents + irel->r_offset + 2);
d12616 1
a12616 1
		      contents + irel->r_offset);
d12644 1
a12644 1
		      contents + irel->r_offset);
d12660 2
a12661 2
	  n32opc  = bfd_get_16 (abfd, contents + irel->r_offset + 4) << 16;
	  n32opc |= bfd_get_16 (abfd, contents + irel->r_offset + 6);
d12666 1
a12666 2
	      bfd_put_16 (abfd, nop_insn_16.match,
			  contents + irel->r_offset + 4);
d12677 1
a12677 1
			  contents + irel->r_offset + 4);
d12689 1
a12689 1
			  contents + irel->r_offset);
d12691 1
a12691 1
			  contents + irel->r_offset + 2);
@


1.287
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d309 6
d531 8
a538 1
   || r_type == R_MIPS_TLS_TPREL_LO16)
d1375 3
d1870 20
d1893 3
a1895 1
  return r_type == R_MIPS_GOT16 || r_type == R_MIPS16_GOT16;
d1901 45
a1945 1
  return r_type == R_MIPS_CALL16 || r_type == R_MIPS16_CALL16;
d1951 3
a1953 1
  return r_type == R_MIPS_HI16 || r_type == R_MIPS16_HI16;
d1959 3
a1961 1
  return r_type == R_MIPS_LO16 || r_type == R_MIPS16_LO16;
d1973 30
a2002 1
  return r_type == R_MIPS_26 || r_type == R_MIPS16_26;
d2006 2
a2007 2
_bfd_mips16_elf_reloc_unshuffle (bfd *abfd, int r_type,
				 bfd_boolean jal_shuffle, bfd_byte *data)
d2009 1
a2009 1
  bfd_vma extend, insn, val;
d2011 1
a2011 1
  if (!mips16_reloc_p (r_type))
d2014 8
a2021 11
  /* Pick up the mips16 extend instruction and the real instruction.  */
  extend = bfd_get_16 (abfd, data);
  insn = bfd_get_16 (abfd, data + 2);
  if (r_type == R_MIPS16_26)
    {
      if (jal_shuffle)
	val = ((extend & 0xfc00) << 16) | ((extend & 0x3e0) << 11)
	      | ((extend & 0x1f) << 21) | insn;
      else
	val = extend << 16 | insn;
    }
d2023 2
a2024 2
    val = ((extend & 0xf800) << 16) | ((insn & 0xffe0) << 11)
	  | ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
d2029 2
a2030 2
_bfd_mips16_elf_reloc_shuffle (bfd *abfd, int r_type,
			       bfd_boolean jal_shuffle, bfd_byte *data)
d2032 1
a2032 1
  bfd_vma extend, insn, val;
d2034 1
a2034 1
  if (!mips16_reloc_p (r_type))
d2038 6
a2043 1
  if (r_type == R_MIPS16_26)
d2045 2
a2046 11
      if (jal_shuffle)
	{
	  insn = val & 0xffff;
	  extend = ((val >> 16) & 0xfc00) | ((val >> 11) & 0x3e0)
		   | ((val >> 21) & 0x1f);
	}
      else
	{
	  insn = val & 0xffff;
	  extend = val >> 16;
	}
d2050 3
a2052 2
      insn = ((val >> 11) & 0xffe0) | (val & 0x1f);
      extend = ((val >> 16) & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0);
d2054 2
a2055 2
  bfd_put_16 (abfd, insn, data + 2);
  bfd_put_16 (abfd, extend, data);
d2196 2
a2197 2
  _bfd_mips16_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
				   location);
d2199 2
a2200 2
  _bfd_mips16_elf_reloc_shuffle (abfd, reloc_entry->howto->type, FALSE,
				 location);
d2218 2
d2297 2
a2298 2
      _bfd_mips16_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
				       location);
d2301 2
a2302 2
      _bfd_mips16_elf_reloc_shuffle (abfd, reloc_entry->howto->type, FALSE,
				     location);
d3091 3
a3093 2
  BFD_ASSERT (r_type == R_MIPS_TLS_GOTTPREL || r_type == R_MIPS_TLS_GD
	      || r_type == R_MIPS_TLS_LDM);
d3097 1
a3097 1
  if (r_type == R_MIPS_TLS_GOTTPREL)
d3106 1
a3106 1
  if (r_type == R_MIPS_TLS_GD)
d3112 1
a3112 1
  if (r_type == R_MIPS_TLS_LDM)
d3394 1
a3394 1
      if (r_type == R_MIPS_TLS_LDM)
d4925 5
d4943 1
a4943 1
   is a MIPS16 jump to non-MIPS16 code, or vice versa.
d5000 1
d5053 2
a5054 2
      /* MIPS16 text labels should be treated as odd.  */
      if (ELF_ST_IS_MIPS16 (sym->st_other))
d5065 1
d5163 4
d5254 9
d5264 13
a5276 5
     mode change.  */
  *cross_mode_jump_p = !info->relocatable
		       && ((r_type == R_MIPS16_26 && !target_is_16_bit_code_p)
			   || ((r_type == R_MIPS_26 || r_type == R_MIPS_JALR)
			       && target_is_16_bit_code_p));
d5288 4
a5291 3
  /* Global R_MIPS_GOT_PAGE relocations are equivalent to R_MIPS_GOT_DISP.
     The addend is applied by the corresponding R_MIPS_GOT_OFST.  */
  if (r_type == R_MIPS_GOT_PAGE && !local_p)
d5293 2
a5294 1
      r_type = R_MIPS_GOT_DISP;
d5311 7
d5321 3
d5325 1
a5325 1
      if (r_type == R_MIPS_TLS_LDM)
d5337 2
a5338 2
	      && (r_type == R_MIPS_CALL_HI16
		  || r_type == R_MIPS_CALL_LO16
d5466 21
a5486 9
      if (was_local_p)
	value = ((addend | ((p + 4) & 0xf0000000)) + symbol) >> 2;
      else
	{
	  value = (_bfd_mips_elf_sign_extend (addend, 28) + symbol) >> 2;
	  if (h->root.root.type != bfd_link_hash_undefweak)
	    overflowed_p = (value >> 26) != ((p + 4) >> 28);
	}
      value &= howto->dst_mask;
d5490 1
d5498 1
d5503 1
d5509 1
d5515 1
d5534 5
d5547 2
d5557 3
d5582 1
d5596 2
d5618 2
d5640 4
d5662 28
d5692 2
d5704 2
d5710 1
d5719 1
d5728 1
d5734 1
d5740 1
d5746 1
d5752 1
d5798 1
a5798 1
   is a MIPS16 jump to non-MIPS16 code, or vice versa.
d5817 1
a5817 1
  _bfd_mips16_elf_reloc_unshuffle (input_bfd, r_type, FALSE, location);
d5841 5
d5907 2
a5908 2
  _bfd_mips16_elf_reloc_shuffle(input_bfd, r_type, !info->relocatable,
				location);
d6369 2
a6370 1
  /* If this is an odd-valued function symbol, assume it's a MIPS16 one.  */
d6375 6
a6380 2
      elfsym->internal_elf_sym.st_other
	= ELF_ST_SET_MIPS16 (elfsym->internal_elf_sym.st_other);
d7089 1
a7089 1
  if (ELF_ST_IS_MIPS16 (sym->st_other))
d7112 1
a7112 1
  if (ELF_ST_IS_MIPS16 (sym->st_other))
d7363 1
a7363 1
  _bfd_mips16_elf_reloc_unshuffle (abfd, r_type, FALSE, location);
d7365 1
a7365 1
  _bfd_mips16_elf_reloc_shuffle (abfd, r_type, FALSE, location);
d7390 2
d7784 12
d7813 1
d7873 5
d7903 3
a7905 3
      else if (r_type == R_MIPS_CALL_LO16
	       || r_type == R_MIPS_GOT_LO16
	       || r_type == R_MIPS_GOT_DISP
d7928 1
d7941 2
d7960 1
d7980 4
a7983 1
	  if (!h || r_type == R_MIPS_GOT_PAGE)
d8011 1
d8018 1
d8024 2
a8025 1
	  if (r_type == R_MIPS_TLS_LDM)
d8033 1
d8037 5
a8041 5
	    unsigned char flag = (r_type == R_MIPS_TLS_GD
				  ? GOT_TLS_GD
				  : r_type == R_MIPS_TLS_LDM
				  ? GOT_TLS_LDM
				  : GOT_TLS_IE);
d8122 4
d8166 4
d8200 3
d8222 1
d9213 1
a9213 2
      if (r_type == R_MIPS16_GPREL
	  || r_type == R_MIPS_GPREL16
d9215 1
a9215 1
	  || r_type == R_MIPS_LITERAL)
d9486 1
a9486 1
		      || howto->type == R_MIPS_LITERAL))
d9504 10
d9626 1
a9626 1
      /* This is a simple LUI/ADIDU stub.  Zero out the beginning
d9630 16
a9645 2
      bfd_put_32 (hti->output_bfd, LA25_LUI (target_high), loc);
      bfd_put_32 (hti->output_bfd, LA25_ADDIU (target_low), loc + 4);
d9651 21
a9671 4
      bfd_put_32 (hti->output_bfd, LA25_LUI (target_high), loc);
      bfd_put_32 (hti->output_bfd, LA25_J (target), loc + 4);
      bfd_put_32 (hti->output_bfd, LA25_ADDIU (target_low), loc + 8);
      bfd_put_32 (hti->output_bfd, 0, loc + 12);
d10234 2
a10235 2
  /* If this is a mips16 symbol, force the value to be even.  */
  if (ELF_ST_IS_MIPS16 (sym->st_other))
d11356 9
d11538 9
d11872 894
d13933 2
a13934 1
  /* For now, allow arbitrary mixing of ASEs (retain the union).  */
d13937 17
d14148 3
@


1.286
log
@	PR ld/12845
	* elf.c (_bfd_elf_init_private_section_data): Add an assertion
	that the output section has an allocated bfd_elf_section_data
	structure.
	* elfxx-mips.c (mips_elf_check_symbols): Do not create a stub for
	symbols in sections that have been removed by garbage collection.

	* emultempl/mipself.em (mips_add_stub_section): Do not add stubs
	for sections that have been removed by garbage collection.
@
text
@a1721 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

a2408 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

a3433 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

d8141 3
a8143 4
  /* Ignore indirect and warning symbols.  All relocations against
     such symbols will be redirected to the target symbol.  */
  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
@


1.285
log
@oops - spelling fixes accidentally omitted from previous delta.
@
text
@d1730 5
@


1.284
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Record both local and
	global GOT entries for GOT_PAGE relocations against global symbols.

ld/testsuite/
	* lib/ld-lib.exp (run_ld_link_tests): Simplify pass/fail logic.
	Fail if the link command fails and if no test rules are defined.
	* ld-mips-elf/reloc-6a.s, ld-mips-elf/reloc-6b.s: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d3 2
a4 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d12529 1
a12529 1
  /* Check if we have the same endianess */
@


1.283
log
@bfd/
	PR ld/12637
	* elfxx-mips.c (mips_elf_merge_got_with): Use arg->global_count
	as the number of global entries when merging with the primary GOT.
@
text
@a7745 1
	      break;
@


1.282
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Ignore
	common sections too.

ld/
	* plugin.c (plugin_get_ir_dummy_bfd): Copy across the bfd's
	private data and GP size.
@
text
@d4083 1
a4083 1
  /* And conservatively estimate how many local, global and TLS entries
d4085 10
a4094 6
  estimate += (from->local_gotno
	       + from->global_gotno
	       + from->tls_gotno
	       + to->local_gotno
	       + to->global_gotno
	       + to->tls_gotno);
@


1.281
log
@	* mips.h (INSN_CHIP_MASK): Update according to INSN_LOONGSON_3A.
	(INSN_LOONGSON_3A): Clear bit 31.

	* elfxx-mips.c (mips_set_isa_flags): Move bfd_mach_loongson_3a
	after bfd_mach_mips_sb1.

	* config/tc-mips.c (mips_cpu_info_table): Move loongson3a after sb1.
@
text
@d12600 5
a12604 2
	  which are automatically generated by gas.  */
      if (strcmp (sec->name, ".reginfo")
@


1.280
log
@	bfd/
	* archures.c (bfd_mach_mips_loongson_3a): Defined.
	* bfd-in2.h (bfd_mach_mips_loongson_3a): Defined.
	* cpu-mips.c (I_loongson_3a): New add.
	(arch_info_struct): Add loongson_3a.
	* elfxx-mips.c (_bfd_elf_mips_mach): Add loongson_3a.
	(mips_set_isa_flags): Add loongson_3a.
	(mips_mach_extensions): Add loongson_3a in MIPS64 extensions.

	binutils/
	* readelf.c (get_machine_flags): Add loongson-3a.

	gas/
	* config/tc-mips.c (mips_cpu_info_table): Add loongson3a in MIPS 64.
	* doc/c-mips.texi (MIPS cpu): Add loongson3a.

	include/
	* elf/mips.h (E_MIPS_MACH_LS3A): Defined.
	* opcode/mips.h (INSN_LOONGSON_3A): Defined.
	(CPU_LOONGSON_3A): Defined.
	(OPCODE_IS_MEMBER): Add LOONGSON_3A.

	opcodes/
	* mips-dis.c (mips_arch_choices): Add loongson3a.
	* mips-opc.c (IL3A): Defined as INSN_LOONGSON_3A.
	(mips_builtin_opcodes): Modify some instructions' membership from
	IL2F to IL2F|IL3A, since these instructions are supported by Loongson_3A.
@
text
@d10562 4
a10569 4
    case bfd_mach_mips_sb1:
      val = E_MIPS_ARCH_64 | E_MIPS_MACH_SB1;
      break;

@


1.279
log
@	PR ld/10144
	* elfxx-mips.c (_bfd_mips_elf_check_relocs)
	[R_MIPS_32, R_MIPS_REL32, R_MIPS_64]: Ignore relocs from
	SEC_DEBUGGING sections.
@
text
@d5949 3
d10562 4
d12268 1
@


1.279.2.1
log
@backport from mainline
@
text
@d12592 2
a12593 5
	 which are automatically generated by gas.  Also ignore fake
	 (s)common sections, since merely defining a common symbol does
	 not affect compatibility.  */
      if ((sec->flags & SEC_IS_COMMON) == 0
	  && strcmp (sec->name, ".reginfo")
@


1.279.2.2
log
@bfd/
	PR ld/12637
	* elfxx-mips.c (mips_elf_merge_got_with): Use arg->global_count
	as the number of global entries when merging with the primary GOT.
@
text
@d4083 1
a4083 1
  /* And conservatively estimate how many local and TLS entries
d4085 6
a4090 10
  estimate += from->local_gotno + to->local_gotno;
  estimate += from->tls_gotno + to->tls_gotno;

  /* If we're merging with the primary got, we will always have
     the full set of global entries.  Otherwise estimate those
     conservatively as well.  */
  if (to == arg->primary)
    estimate += arg->global_count;
  else
    estimate += from->global_gotno + to->global_gotno;
@


1.279.2.3
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Record both local and
	global GOT entries for GOT_PAGE relocations against global symbols.

ld/testsuite/
	* lib/ld-lib.exp (run_ld_link_tests): Simplify pass/fail logic.
	Fail if the link command fails and if no test rules are defined.
	* ld-mips-elf/reloc-6a.s, ld-mips-elf/reloc-6b.s: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d7743 1
@


1.278
log
@	* elfxx-mips.c (mips_elf_calculate_relocation): Fix a typo.
@
text
@d7586 19
@


1.277
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d5155 1
a5155 1
  /* If we haven't already determined the GOT offset, oand we're going
@


1.276
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d9003 2
a9004 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.275
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@a785 17
/* Determine whether the internal relocation of index REL_IDX is REL
   (zero) or RELA (non-zero).  The assumption is that, if there are
   two relocation sections for this section, one of them is REL and
   the other is RELA.  If the index of the relocation we're testing is
   in range for the first relocation section, check that the external
   relocation size is that for RELA.  It is also assumed that, if
   rel_idx is not in range for the first section, and this first
   section contains REL relocs, then the relocation is in the second
   section, that is RELA.  */
#define MIPS_RELOC_RELA_P(abfd, sec, rel_idx)				\
  ((NUM_SHDR_ENTRIES (&elf_section_data (sec)->rel_hdr)			\
    * get_elf_backend_data (abfd)->s->int_rels_per_ext_rel		\
    > (bfd_vma)(rel_idx))						\
   == (elf_section_data (sec)->rel_hdr.sh_entsize			\
       == (ABI_64_P (abfd) ? sizeof (Elf64_External_Rela)		\
	   : sizeof (Elf32_External_Rela))))

d7096 5
a7100 3
  /* To determine which flavor or relocation this is, we depend on the
     fact that the INPUT_SECTION's REL_HDR is read before its REL_HDR2.  */
  rel_hdr = &elf_section_data (sec)->rel_hdr;
d7102 2
a7103 4
  if ((size_t) (rel - relocs)
      >= (NUM_SHDR_ENTRIES (rel_hdr) * bed->s->int_rels_per_ext_rel))
    rel_hdr = elf_section_data (sec)->rel_hdr2;
  return rel_hdr->sh_entsize == MIPS_ELF_REL_SIZE (abfd);
d8969 1
d8971 3
d8975 1
a8975 5
      howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, r_type,
				       NEWABI_P (input_bfd)
				       && (MIPS_RELOC_RELA_P
					   (input_bfd, input_section,
					    rel - relocs)));
@


1.274
log
@bfd/
	* elfxx-mips.c (mips_elf_link_hash_entry): Add got_only_for_calls.
	(mips_elf_link_hash_newfunc): Initialize it.
	(mips_elf_record_global_got_symbol): Add a for_call parameter.
	(mips_elf_count_got_symbols): Check SYMBOL_CALLS_LOCAL rather
	than SYMBOL_REFERENCES_LOCAL if the GOT entry is only used for calls.
	Try to remove .got entries in favour of .got.plt entries on VxWorks.
	(_bfd_mips_elf_check_relocs): Do not try to avoid allocating
	a global GOT entry for VxWorks calls.  Update uses of
	mips_elf_record_global_got_symbol.
	(allocate_dynrelocs): Set got_only_for_calls to false if the GOT
	entry is used for dynamic relocations.
@
text
@d5285 1
a5285 1
	  && r_symndx != 0
d7755 1
a7755 1
	      r_symndx = 0;
d7781 1
a7781 1
		BFD_ASSERT (flag == GOT_TLS_LDM || r_symndx != 0);
d7921 1
a7921 1
	      if (r_symndx == 0)
@


1.273
log
@bfd/
	* elfxx-mips.c (mips_got_entry): Adjust commentary.
	(mips_elf_create_local_got_entry): If given a symbol, check that it
	has been assigned to the local part of the GOT.
	(mips_elf_count_got_symbols): Take the bfd_link_info as argument
	instead of the master GOT.  Put all locally-binding symbols in
	the local area.
	(mips_elf_make_got_per_bfd): Use global_got_area to decide whether
	a symbol lives in the local or global area.
	(mips_elf_local_relocation_p): Remove check_forced argument and
	retain only the !check_forced behavior.
	(mips_elf_calculate_relocation): Adjust call accordingly.
	Use global_got_area to decide whether an output relocation
	should be local or global.  Explicitly decay R_MIPS_GOT_PAGE
	into R_MIPS_GOT_DISP where appropriate.  Fix selection of
	local vs. global semantics for R_MIPS*_26.  Remove redundant
	reevaluation of what is stored in was_local_p.
	(mips_elf_create_dynamic_relocation): Use global_got_area to decide
	whether the relocation should be against a global or local symbol.
	(mips_elf_lay_out_got): Update the GOT traversal after the above
	change to mips_elf_count_got_symbols.
	(mips_elf_adjust_addend): Adjust call to mips_elf_local_relocation_p.
	(_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Use global_got_area to decide
	whether the symbol has a global got entry.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.

ld/testsuite/
	* ld-mips-elf/elf-rel-got-n32.d: Swap two local GOT entries
	and remove some duplication between the global and local GOT
	entries.  Adjust GP offsets accordingly.
	* ld-mips-elf/elf-rel-got-n64-linux.d: Likewise.
	* ld-mips-elf/elf-rel-xgot-n32.d: Reorder GOT entries and update
	GP offsets accordingly.
	* ld-mips-elf/elf-rel-xgot-n64-linux.d: Likewise.
	* ld-mips-elf/mips16-pic-1.gd: Move all global GOT entries to
	the local GOT.
	* ld-mips-elf/mips16-pic-1.dd: Update GP offsets accordingly.
	* ld-mips-elf/multi-got-no-shared.d: Adjust GP setup for
	smaller GOT sizes.
@
text
@d377 5
d1081 1
d3486 2
a3487 1
   posterity.  */
d3492 1
d3504 2
d3869 1
d3873 2
a3874 1
  g = mips_elf_hash_table (info)->got_info;
d3886 4
a3889 1
      if (h->root.dynindx == -1 || SYMBOL_REFERENCES_LOCAL (info, &h->root))
d3898 7
d7679 4
a7682 5
	      /* VxWorks call relocations point at the function's .got.plt
		 entry, which will be allocated by adjust_dynamic_symbol.
		 Otherwise, this symbol requires a global GOT entry.  */
	      if ((!htab->is_vxworks || h->forced_local)
		  && !mips_elf_record_global_got_symbol (h, abfd, info, 0))
d7742 2
a7743 1
	  if (h && !mips_elf_record_global_got_symbol (h, abfd, info, 0))
d7775 2
a7776 2
		if (h && !mips_elf_record_global_got_symbol (h, abfd,
							     info, flag))
d8179 6
a8184 2
	  if (!htab->is_vxworks && hmips->global_got_area > GGA_RELOC_ONLY)
	    hmips->global_got_area = GGA_RELOC_ONLY;
@


1.272
log
@bfd/
	* elfxx-mips.c (allocate_dynrelocs): Don't add relocation symbols
	to the global GOT on VxWorks.
@
text
@d56 1
a56 1
      (3) global and forced-local symbols
d97 3
a99 2
       corresponding to a global symbol in the got (or, local, if
       h->forced_local).  */
d3206 2
a3207 2
   EXTERNAL is true if the relocation was against a global symbol
   that has been forced local.  */
d3285 3
a3287 5
  /* We might have a symbol, H, if it has been forced local.  Use the
     global entry then.  It doesn't matter whether an entry is local
     or global for TLS, since the dynamic linker does not
     automatically relocate TLS GOT entries.  */
  BFD_ASSERT (h == NULL || h->root.forced_local);
d3852 2
a3853 1
   to a mips_got_info.  Count the number of type (3) entries.  */
d3858 1
d3861 2
a3862 1
  g = (struct mips_got_info *) data;
d3865 14
a3878 5
      if (h->root.forced_local || h->root.dynindx == -1)
	{
	  /* We no longer need this entry if it was only used for
	     relocations; those relocations will be against the
	     null or section symbol instead of H.  */
d4024 1
a4024 1
  else if (entry->symndx >= 0 || entry->d.h->root.forced_local)
d4571 1
a4571 1
/* Return whether a relocation is against a local symbol.  */
d4576 1
a4576 2
			     asection **local_sections,
			     bfd_boolean check_forced)
a4579 1
  struct mips_elf_link_hash_entry *h;
a4590 14
  if (check_forced)
    {
      /* Look up the hash table to check whether the symbol
 	 was forced local.  */
      h = (struct mips_elf_link_hash_entry *)
	elf_sym_hashes (input_bfd) [r_symndx - extsymoff];
      /* Find the real hash-table entry for this symbol.  */
      while (h->root.root.type == bfd_link_hash_indirect
 	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;
      if (h->root.forced_local)
	return TRUE;
    }

d4898 1
a4898 1
					 local_sections, FALSE);
d5132 1
a5132 2
  local_p = mips_elf_local_relocation_p (input_bfd, relocation,
					 local_sections, TRUE);
d5142 8
a5153 9
    case R_MIPS_GOT_PAGE:
    case R_MIPS_GOT_OFST:
      /* We need to decay to GOT_DISP/addend if the symbol doesn't
	 bind locally.  */
      local_p = local_p || _bfd_elf_symbol_refs_local_p (&h->root, info, 1);
      if (local_p || r_type == R_MIPS_GOT_OFST)
	break;
      /* Fall through.  */

d5189 1
a5189 5
	      /* GOT_PAGE may take a non-zero addend, that is ignored in a
		 GOT_PAGE relocation that decays to GOT_DISP because the
		 symbol turns out to be global.  The addend is then added
		 as GOT_OFST.  */
	      BFD_ASSERT (addend == 0 || r_type == R_MIPS_GOT_PAGE);
d5193 2
a5194 7
		  && (! elf_hash_table(info)->dynamic_sections_created
		      || (info->shared
			  && (info->symbolic || h->root.forced_local)
			  && h->root.def_regular)))
		/* This is a static link or a -Bsymbolic link.  The
		   symbol is defined locally, or was forced to be local.
		   We must initialize this entry in the GOT.  */
d5308 1
a5308 1
      if (local_p)
a5433 4
	  bfd_boolean forced;

	  forced = ! mips_elf_local_relocation_p (input_bfd, relocation,
						  local_sections, FALSE);
d5435 1
a5435 1
					symbol + addend, forced);
a5449 1
    got_disp:
a5483 5
      /* GOT_PAGE relocations that reference non-local symbols decay
	 to GOT_DISP.  The corresponding GOT_OFST relocation decays to
	 0.  */
      if (! local_p)
	goto got_disp;
d5734 1
d8441 1
a8441 1
  mips_elf_link_hash_traverse (htab, mips_elf_count_got_symbols, g);
d8900 1
a8900 1
  if (mips_elf_local_relocation_p (input_bfd, rel, local_sections, FALSE))
d8970 1
a8970 1
      if (mips_elf_local_relocation_p (input_bfd, rel, local_sections, FALSE))
d9035 1
a9035 1
						      local_sections, FALSE)))
d9561 1
a9561 2
  if (g->global_gotsym != NULL
      && h->dynindx >= g->global_gotsym->dynindx)
d9572 1
a9572 1
  if (g->next && h->dynindx != -1 && h->type != STT_TLS)
d9738 1
d9743 1
d9849 1
a9849 2
  if (g->global_gotsym != NULL
      && h->dynindx >= g->global_gotsym->dynindx)
@


1.271
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): On VxWorks,
	exclude __GOTT_BASE__ and __GOTT_INDEX__ from the warning
	about HI/LO relocations in shared objects.
@
text
@d8175 8
a8182 3
	     a symbol must have a dynamic symbol table index greater that
	     DT_MIPS_GOTSYM if there are dynamic relocations against it.  */
	  if (hmips->global_got_area > GGA_RELOC_ONLY)
@


1.270
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d7933 4
@


1.269
log
@2010-08-09  Catherine Moore  <clm@@codesourcery.com>

        * elfxx-mips.c (mips_elf_perform_relocation): Improve
        interlinking error message.

2010-08-09  Catherine Moore  <clm@@codesourcery.com>

        * ld-mips-elf/mode-change-error-1.d: New.
        * ld-mips-elf/mode-change-error-1a.s: New.
        * ld-mips-elf/mode-change-error-1b.s: New.
        * ld-mips-elf/mips-elf.exp: Run new test.
@
text
@a11522 9
/* Allocate ABFD's target-dependent data.  */

bfd_boolean
_bfd_mips_elf_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct elf_obj_tdata),
				  MIPS_ELF_DATA);
}

@


1.268
log
@	* elfxx-mips.h: Include "elf/mips.h".
	(gprel16_reloc_p): New static inline function.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs)
	[R_MIPS16_GOT16, R_MIPS_GOT16, R_MIPS_GOT_HI16, R_MIPS_GOT_LO16]:
	Use got16_reloc_p.
	(_bfd_mips_elf_relocate_section)[bfd_reloc_overflow]: Use
	gprel16_reloc_p.
	* elf32-mips.c (mips_info_to_howto_rel): Likewise.
	* elfn32-mips.c (mips_info_to_howto_rel): Likewise.
@
text
@d5644 1
a5644 1
	    (_("%B: %A+0x%lx: jump to stub routine which is not jal"),
@


1.267
log
@        PR binutils/10858
        * elfxx-mips.c (mips_elf_create_dynamic_relocation): Ise
        SYMBOL_REFERENCES_LOCAL to exclude entries from the dynamic symbol
        table.
@
text
@d7730 1
a7730 1
		  if (r_type == R_MIPS_GOT16)
d9199 1
a9199 1
		  && (howto->type == R_MIPS_GPREL16
@


1.266
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d5758 1
a5758 3
  if (h != NULL
      && (!h->root.def_regular
	  || (info->shared && !info->symbolic && !h->root.forced_local)))
@


1.265
log
@2010-01-13  Chao-ying Fu  <fu@@mips.com>

	* elfxx-mips.c (JR_TO_B_P): New define to transform JR to B.
	It is true for all CPUs.
	(jal_reloc_p): New function.
	(mips_elf_calculate_relocation): Rename require_jalxp to
	cross_mode_jump_p.
	Update comment for CROSS_MODE_JUMP_P.
	Set up cross_mode_jump_p based on the mode change.
	(mips_elf_perform_relocation): Rename require_jalx to cross_mode_jump_p.
	Update comment for CROSS_MODE_JUMP_P.
	Test cross_mode_jump_p and jal_reloc_p to turn jal to jalx.
	Use !cross_mode_jump_p to guard conversion.
	Convert "jr t9" to "b", if possible.
	(_bfd_mips_elf_relocate_section): Rename require_jalx to
	cross_mode_jump_p.
	Pass &cross_mode_jump_p to call mips_elf_calculate_relocation.
	Pass cross_mode_jump_p to call mips_elf_perform_relocation.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d250 1
a250 1
   && elf_object_id (bfd) == MIPS_ELF_TDATA)
d488 6
d495 2
a496 1
struct mips_htab_traverse_info {
a1016 5
/* Get the MIPS ELF linker hash table from a link_info structure.  */

#define mips_elf_hash_table(p) \
  ((struct mips_elf_link_hash_table *) ((p)->hash))

d1554 3
d1597 2
d1642 2
d1694 3
d2869 3
d3031 2
d3069 2
d3103 2
d3244 2
d3270 1
d3406 2
d3494 2
d3562 2
d3646 2
d3739 2
d4280 2
d4329 2
d4705 1
d4887 1
d5723 2
d6914 2
d7252 2
d8127 2
d8205 2
d8401 1
d8434 2
d8561 2
d8614 2
d8620 1
a8620 2
  mips_elf_link_hash_traverse (mips_elf_hash_table (info),
			       mips_elf_allocate_lazy_stub, htab);
d8638 1
d9198 1
d9304 1
d9419 1
d9759 1
d9927 2
d9972 2
d10044 1
d10065 2
d11531 1
a11531 1
				  MIPS_ELF_TDATA);
d11548 2
a11549 1
				      sizeof (struct mips_elf_link_hash_entry)))
d11654 2
d12991 2
@


1.264
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d683 5
d1879 6
d4785 2
a4786 2
   REQUIRE_JALXP indicates whether or not the opcode used with this
   relocation must be JALX.
d4801 2
a4802 1
			       const char **namep, bfd_boolean *require_jalxp,
d5091 5
a5095 4
     special jalx instruction.  */
  *require_jalxp = (!info->relocatable
                    && (((r_type == R_MIPS16_26) && !target_is_16_bit_code_p)
                        || ((r_type == R_MIPS_26) && target_is_16_bit_code_p)));
d5549 3
a5551 3
   relocation applies.  If REQUIRE_JALX is TRUE, then the opcode used
   for the relocation must be either JAL or JALX, and it is
   unconditionally converted to JALX.
d5561 1
a5561 1
			     bfd_boolean require_jalx)
d5582 1
a5582 1
  if (require_jalx)
d5616 2
a5617 1
  /* Try converting JAL and JALR to BAL, if the target is in range.  */
d5619 1
a5619 1
      && !require_jalx
d5625 4
a5628 1
	      && x == 0x0320f809)))	/* jalr t9 */
d5644 6
a5649 1
	x = 0x04110000 | (((bfd_vma) off >> 2) & 0xffff);   /* bal addr */
d8911 1
a8911 1
      bfd_boolean require_jalx;
d9111 1
a9111 1
					     &name, &require_jalx,
d9223 1
a9223 1
					 contents, require_jalx))
@


1.263
log
@	bfd/
	* elfxx-mips.c (mips_elf_calculate_relocation): Correct handling
	of undefined symbols.

	ld/testsuite/
	* ld-mips-elf/undefined.d: New test.
	* ld-mips-elf/undefined.s: Source for the new test.
	* ld-mips-elf/mips-elf.exp: Run the new test.
@
text
@d180 2
a181 1
struct mips_elf_bfd2got_hash {
d3068 1
a3068 1
  bfd_vma index;
d3126 2
a3127 2
      index = mips_tls_got_index (abfd, hm->tls_got_offset, &hm->tls_type,
				  r_type, info, hm, value);
d3136 2
a3137 2
      index = ((h->dynindx - global_got_dynindx + g->local_gotno)
	       * MIPS_ELF_GOT_SIZE (abfd));
d3139 1
a3139 1
  BFD_ASSERT (index < htab->sgot->size);
d3141 1
a3141 1
  return index;
d3154 1
a3154 1
  bfd_vma page, index;
d3164 1
a3164 1
  index = entry->gotidx;
d3169 1
a3169 1
  return index;
d3205 1
a3205 1
				bfd *input_bfd, bfd_vma index)
d3216 1
a3216 1
  return sgot->output_section->vma + sgot->output_offset + index - gp;
d3313 1
a3313 1
      bfd_byte *loc;
d3321 1
a3321 1
      loc = s->contents + (s->reloc_count++ * sizeof (Elf32_External_Rela));
d3325 1
a3325 1
      bfd_elf32_swap_reloca_out (abfd, &outrel, loc);
a8978 2
		      const char *name;

d9124 2
a9125 3
		  const char *msg =
		    _("small-data section exceeds 64KB;"
		      " lower small-data size limit (see option -G)");
d10227 1
a10227 1
	  bfd_vma index = g->next->local_gotno + g->next->global_gotno
d10231 1
a10231 1
			     + index++ * MIPS_ELF_GOT_SIZE (output_bfd));
d10234 1
a10234 1
			     + index++ * MIPS_ELF_GOT_SIZE (output_bfd));
d10239 1
a10239 1
	  while (index < g->assigned_gotno)
d10242 1
a10242 1
		= index++ * MIPS_ELF_GOT_SIZE (output_bfd);
@


1.262
log
@Revert accidental checkin.
@
text
@d4976 8
d4986 1
a4986 7
	  if (! ((*info->callbacks->undefined_symbol)
		 (info, h->root.root.root.string, input_bfd,
		  input_section, relocation->r_offset,
		  (info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
		   || ELF_ST_VISIBILITY (h->root.other))))
	    return bfd_reloc_undefined;
	  symbol = 0;
@


1.261
log
@Updated Spanish and Vietnamese translations
@
text
@d6965 8
a6972 8
	  if (s != NULL)
	    {
	      name = SGI_COMPAT (abfd) ? "__rld_map" : "__RLD_MAP";
	      bh = NULL;
	      if (!(_bfd_generic_link_add_one_symbol
		    (info, abfd, name, BSF_GLOBAL, s, 0, NULL, FALSE,
		     get_elf_backend_data (abfd)->collect, &bh)))
		return FALSE;
d6974 4
a6977 4
	      h = (struct elf_link_hash_entry *) bh;
	      h->non_elf = 0;
	      h->def_regular = 1;
	      h->type = STT_OBJECT;
d6979 2
a6980 3
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
@


1.260
log
@	* elfxx-mips.c (mips_elf_calculate_relocation): Don't relocate
	R_MIPS_JALR unless symbol resolves locally.
@
text
@d6965 8
a6972 1
	  BFD_ASSERT (s != NULL);
d6974 4
a6977 6
	  name = SGI_COMPAT (abfd) ? "__rld_map" : "__RLD_MAP";
	  bh = NULL;
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, name, BSF_GLOBAL, s, 0, NULL, FALSE,
		 get_elf_backend_data (abfd)->collect, &bh)))
	    return FALSE;
d6979 3
a6981 7
	  h = (struct elf_link_hash_entry *) bh;
	  h->non_elf = 0;
	  h->def_regular = 1;
	  h->type = STT_OBJECT;

	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
@


1.259
log
@	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Don't set
	has_static_relocs for R_MIPS_JALR.
@
text
@d5492 2
a5493 2
	 branches to the PLT; that will wind up wasting time.  */
      if (h != NULL && h->root.plt.offset != (bfd_vma) -1)
@


1.258
log
@update copyright dates
@
text
@d7506 5
@


1.257
log
@2009-08-05  Chao-ying Fu  <fu@@mips.com>

	* elf32-mips.c (mips_reloc_map): Add BFD_RELOC_MIPS_JALR.
	* elfxx-mips.c (JAL_TO_BAL_P): New define to transform JAL to BAL
	for CPUs.  It is true for RM9000.
	(JALR_TO_BAL_P): New define to transform JALR to BAL.  It is true
	for all CPUs.
	(mips_elf_perform_relocation): Use JAL_TO_BAL_P and JALR_TO_BAL_P
	to guard the transformation.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.256
log
@        * elfxx-mips.c (LOAD_INTERLOCKS_P): New define.
        (_bfd_mips_elf_size_dynamic_sections): For CPUs without load
        interlocking, the last PLT entry needs a nop in the branch delay slot.
        (_bfd_mips_elf_finish_dynamic_symbol): For CPUs with load itnerlocking,
        output the last two PLT entries in reverse order.

        * ld-mips-elf/pic-and-nonpic-3b.dd,
        ld-mips-elf/pic-and-nonpic-5b.dd,
        ld-mips-elf/pic-and-nonpic-6-o32.dd: Updated to use new PLT entries.
@
text
@d671 11
d5600 2
a5601 6
  /* On the RM9000, bal is faster than jal, because bal uses branch
     prediction hardware.  If we are linking for the RM9000, and we
     see jal, and bal fits, use it instead.  Note that this
     transformation should be safe for all architectures.  */
  if (bfd_get_mach (input_bfd) == bfd_mach_mips9000
      && !info->relocatable
d5603 6
a5608 2
      && ((r_type == R_MIPS_26 && (x >> 26) == 0x3)	    /* jal addr */
	  || (r_type == R_MIPS_JALR && x == 0x0320f809)))   /* jalr t9 */
@


1.255
log
@	* elf-bfd.h (struct elf_backend_data
	<elf_backend_link_output_symbol_hook>): Return an int.
	* elf64-ppc.c (ppc64_elf_output_symbol_hook): Return 2 to drop
	symbols on deleted .opd entries.
	* elflink.c (elf_link_output_sym): Return without outputting sym
	if output_symbol_hook returns 2.
	(elf_link_output_extsym): Don't assign h->indx when symbol discarded.
	Abort if we must not discard sym.
	(elf_link_input_bfd): Similarly, don't set finfo->indices for
	local syms.
	(bfd_elf_final_link): Adjust elf_link_output_sym calls.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Adjust for
	elf_backend_link_output_symbol_hook return type change.
	* elf32-arm.c (output_arch_syminfo): Likewise.
	(elf32_arm_output_map_sym, elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	* elf32-cr16c.c (elf32_cr16c_link_output_symbol_hook): Likewise.
	* elf32-score.c (s3_bfd_score_elf_link_output_symbol_hook): Likewise.
	(bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score.h (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Likewise.
	* elf32-spu.c (spu_elf_output_symbol_hook): Likewise.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
@
text
@d665 6
d887 2
a888 1
static const bfd_vma mips_o32_exec_plt0_entry[] = {
d901 2
a902 1
static const bfd_vma mips_n32_exec_plt0_entry[] = {
d915 2
a916 1
static const bfd_vma mips_n64_exec_plt0_entry[] = {
d928 2
a929 1
static const bfd_vma mips_exec_plt_entry[] = {
d937 2
a938 1
static const bfd_vma mips_vxworks_exec_plt0_entry[] = {
d948 2
a949 1
static const bfd_vma mips_vxworks_exec_plt_entry[] = {
d961 2
a962 1
static const bfd_vma mips_vxworks_shared_plt0_entry[] = {
d972 2
a973 1
static const bfd_vma mips_vxworks_shared_plt_entry[] = {
d8648 4
a8651 2
	     room for an extra nop to fill the delay slot.  */
	  if (!htab->is_vxworks && s->size > 0)
d9374 11
a9384 2
      bfd_put_32 (output_bfd, plt_entry[2] | got_address_low, loc + 8);
      bfd_put_32 (output_bfd, plt_entry[3], loc + 12);
@


1.254
log
@	* elfxx-mips.c (_bfd_mips_elf_section_processing): Remove special
	.sbss handling.
@
text
@d6788 1
a6788 1
bfd_boolean
d6804 1
a6804 1
  return TRUE;
@


1.253
log
@bfd:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* aoutx.h (NAME (aout, machine_type)): Handle bfd_mach_mips_xlr.
	* archures.c (bfd_mach_mips_xlr): Define.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_xlr): Define.
	(arch_info_struct): Add XLR entry.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle E_MIPS_MACH_XLR.
	(mips_set_isa_flags): Handle bfd_mach_mips_xlr
	(mips_mach_extensions): Add XLR entry.

binutils:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_MACH_XLR.

gas:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* config/tc-mips.c (macro): Handle M_MSGSND, M_MSGLD, M_MSGLD_T,
	M_MSGWAIT and M_MSGWAIT_T.
	(mips_cpu_info_table): Add XLR entry.
	* doc/c-mips.texi (-march): Document xlr.

gas/testsuite:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* gas/mips/mips.exp (xlr): New architecture.
	(xlr-ext): Run test.
	* gas/mips/xlr-ext.d, gas/mips/xlr-ext.s: New.

include/elf:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips.h (E_MIPS_MACH_XLR): Define.

include/opcode:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips.h (INSN_XLR): Define.
	(INSN_CHIP_MASK): Update.
	(CPU_XLR): Define.
	(OPCODE_IS_MEMBER): Update.
	(M_MSGSND, M_MSGLD, M_MSGLD_T, M_MSGWAIT, M_MSGWAIT_T): Define.

opcodes:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips-dis.c (mips_cp0_names_xlr, mips_cp0sel_names_xlr): Define.
	(mips_arch_choices): Add XLR entry.
	* mips-opc.c (XLR): Define.
	(mips_builtin_opcodes): Add XLR instructions.
@
text
@d6252 7
a6265 5
      else if (strcmp (name, ".sbss") == 0)
	{
	  hdr->sh_flags |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;
	  hdr->sh_type = SHT_NOBITS;
	}
@


1.252
log
@2009-01-29  Daniel Jacobowitz  <dan@@codesourcery.com>
            Mark Shinwell  <shinwell@@codesourcery.com>
            Catherine Moore  <clm@@codesourcery.com>

	* elf-attrs.c, elflink.c, elfxx-mips.c: Correct typos in comments.
@
text
@d5882 3
d10431 4
d12130 1
@


1.251
log
@	* aoutx.h (NAME): Add case statements for bfd_mach_mips14000,
	bfd_mach_mips16000.
	* archures.c (bfd_architecture): Add .#defines for bfd_mach_mips14000,
	bfd_mach_mips16000.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c: Add enums I_mips14000, I_mips16000.
	(arch_info_struct): Add refs to R14000, R16000.
	* elfxx-mips.c (mips_set_isa_flags): Handle bfd_mach_mips14000,
	bfd_mach_mips16000.
	(mips_mach_extensions): Map R14000, R16000 to R10000.

	* config/tc-mips.c (hilo_interlocks): Handle CPU_R14000, CPU_R16000.
	(mips_cpu_info_table): Add r14000, r16000.
	* doc/c-mips.texi: Add entries for 14000, 16000.

	* mips-dis.c (mips_arch_choices): Add r14000, r16000.

	* mips.h: Define CPU_R14000, CPU_R16000.
        (OPCODE_IS_MEMBER): Include R14000, R16000 in test.
@
text
@d7578 1
a7578 1
	      /* VxWorks call relocations point the function's .got.plt
@


1.250
log
@	* elfxx-mips.c (mips16_stub_symndx) <sec>: Mark argument as
	unused.
@
text
@d10403 2
d12129 2
@


1.249
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Copy MIPS16
	stub information.

ld/testsuite/
	* ld-mips-elf/mips16-pic-4a.s, ld-mips-elf/mips16-pic-4b.s,
	ld-mips-elf/mips16-pic-4.ver, ld-mips-elf/mips16-pic-4a.dd,
	ld-mips-elf/mips16-pic-4a.nd, ld-mips-elf/mips16-pic-4a.gd,
	ld-mips-elf/mips16-pic-4c.s, ld-mips-elf/mips16-pic-4b.dd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d1412 2
a1413 1
mips16_stub_symndx (asection *sec, const Elf_Internal_Rela *relocs,
@


1.248
log
@* elfxx-mips.c (_bfd_mips_elf_check_relocs): Handle the situation
  where the sym_hashes are not available.
@
text
@d10926 20
@


1.247
log
@2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>
	    Maxim Kuvyrkov  <maxim@@codesourcery.com>

	* elf32-mips.c (mips_vxworks_copy_howto_rela): Replace with...
	(elf_mips_copy_howto): ...this howto.  Clear the size fields.
	(mips_vxworks_jump_slot_howto_rela): Replace with...
	(elf_mips_jump_slot_howto): ...this howto.
	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf32_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf32_rtype_to_howto): Handle R_MIPS_COPY and R_MIPS_JUMP_SLOT.
	(elf_backend_plt_readonly): Define.
	(elf_backend_plt_sym_val): Define for non-VxWorks targets.
	(mips_vxworks_bfd_reloc_type_lookup): Delete.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(mips_vxworks_rtype_to_howto): Likewise.
	(elf_backend_want_dynbss): Don't define for VxWorks.
	(elf_backend_plt_readonly): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(elf_backend_mips_rtype_to_howto): Likewise.
	(elf_backend_adjust_dynamic_symbol): Likewise.
	(elf_backend_got_symbol_offset): Don't define.
	* elfn32-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto): New.
	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf32_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf32_n32_rtype_to_howto): Handle R_MIPS_COPY and
	R_MIPS_JUMP_SLOT.
	(elf_backend_rela_plts_and_copies_p, elf_backend_plt_readonly)
	(elf_backend_plt_sym_val): Define.
	* elf64-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto): New.
	(bfd_elf64_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf64_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf64_rtype_to_howto): Handle R_MIPS_COPY and R_MIPS_JUMP_SLOT.
	(elf_backend_rela_plts_and_copies_p, elf_backend_plt_readonly)
	(elf_backend_plt_sym_val): Define.
	* elfxx-mips.h (_bfd_mips_vxworks_adjust_dynamic_symbol): Delete.
	(_bfd_mips_elf_use_plts_and_copy_relocs, _bfd_mips_elf_init_stubs)
	(_bfd_mips_elf_plt_sym_val, _bfd_mips_post_process_headers): Declare.
	* elfxx-mips.c (mips_elf_la25_stub): New structure.
	(LA25_LUI, LA25_J, LA25_ADDIU): New macros.
	(mips_elf_link_hash_entry): Add "la25_stubs", "has_static_relocs"
	and "has_nonpic_branches" fields.  Remove "is_relocation_target" and
	"is_branch_target".
	(mips_elf_link_hash_table): Add blank lines.  Add
	"use_plts_and_copy_relocs", "reserved_gotno", "strampoline",
	"la25_stubs" and "add_stub_section" fields.
	(mips_htab_traverse_info): New structure.
	(PIC_OBJECT_P, MIPS_ELF_LOAD_WORD): New macros.
	(MIPS_RESERVED_GOTNO): Delete.
	(mips_o32_exec_plt0_entry, mips_n32_exec_plt0_entry)
	(mips_n64_exec_plt0_entry, mips_exec_plt_entry): New tables.
	(mips_elf_link_hash_newfunc): Update after the changes to
	mips_elf_link_hash_entry.
	(mips_elf_check_mips16_stubs): Replace the DATA parameter with
	an INFO parameter.  Don't look through warnings symbols here;
	do it in mips_elf_check_symbols instead.
	(mips_elf_create_stub_symbol): New function.
	(mips_elf_la25_stub_hash, mips_elf_la25_stub_eq): New functions.
	(_bfd_mips_elf_init_stubs, mips_elf_local_pic_function_p): Likewise.
	(mips_elf_add_la25_intro, mips_elf_add_la25_trampoline): Likewise.
	(mips_elf_add_la25_stub, mips_elf_check_symbols): New functions.
	(mips_elf_gotplt_index): Check for VxWorks.
	(mips_elf_output_dynamic_relocation): Take the relocation index
	as an extra parameter.  Do not increment reloc_count here.
	(mips_elf_initialize_tls_slots): Update the calls to
	mips_elf_output_dynamic_relocation accordingly.
	(mips_elf_multi_got): Use htab->reserved_gotno instead of
	MIPS_RESERVED_GOTNO.
	(mips_elf_create_got_section): Don't allocate reserved GOT
	entries here.  Unconditionally create .got.plt, but don't
	set its alignment here.
	(mips_elf_relocation_needs_la25_stub): New function.
	(mips_elf_calculate_relocation): Redirect branches and jumps to
	a non-PIC stub if one exists.  Check !h->has_static_relocs instead
	of !htab->is_vxworks when deciding whether to create dynamic
	relocations for R_MIPS_32, R_MIPS_REL32 and R_MIPS_64.
	(_bfd_mips_elf_create_dynamic_sections): Unconditionally call
	_bfd_elf_create_dynamic_sections.  Unconditionally set up
	htab->splt and htab->sdynbss.  Set htab->srelplt to ".rel.plt"
	if !htab->is_vxworks.  Add non-VxWorks values of
	htab->plt_header_size and htab->plt_entry_size.
	(_bfd_mips_elf_check_relocs): Set pointer_equality_needed for
	non-branch static relocations.  Set has_nonpic_branches when an la25
	stub might be required.  Set can_make_dynamic_p to TRUE if R_MIPS_32,
	R_MIPS_REL32 and R_MIPS_64 relocations can be made dynamic,
	rather than duplicating the condition.  Do not make them dynamic
	for read-only sections in non-PIC executable objects.
	Do not protect this code with dynobj == NULL || htab->sgot == NULL;
	handle each group of cases separately.  Add a default case that
	sets has_static_relocs for non-GOT relocations that cannot be
	made dynamic.  Don't set is_relocation_target and is_branch_target.
	Reject non-PIC static relocations in shared objects.
	(_bfd_mips_vxworks_adjust_dynamic_symbol): Fold into...
	(_bfd_mips_elf_adjust_dynamic_symbol): ...here, using
	htab->use_plts_and_copy_relocs instead of htab->is_vxworks
	to select PLT and copy-reloc handling.  Set the alignment of
	.plt and .got.plt when allocating the first entry.  Generalize
	code to handle REL as well as RELA sections and 64-bit as well as
	32-bit GOT entries.  Complain if we find a static-only reloc
	against an externally-defined symbol and if we cannot create
	dynamic relocations for it.  Allocate copy relocs using
	mips_elf_allocate_dynamic_relocations on non-VxWorks targets.
	Set possibly_dynamic_relocs to 0 when using PLTs or copy relocs.
	Skip reserved .got.plt entries.
	(_bfd_mips_elf_always_size_sections): Use mips_elf_check_symbols
	instead of mips_elf_check_mips16_stubs to process each symbol.
	Do the traversal for relocatable objects too.
	(mips_elf_lay_out_got): Use htab->reserved_gotno instead of
	MIPS_RESERVED_GOTNO.
	(_bfd_mips_elf_size_dynamic_sections): Exclude sdynbss if it
	is empty.  Extend the DT_PLTREL, DT_JMPREL and DT_PLTRELSZ handling
	to non-VxWorks targets.  Only add DT_REL{,A}, DT_REL{,A}SZ and
	DT_REL{,A}ENT if .rel.dyn is nonempty.  Create a symbol for the
	PLT.  Allocate a nop at the end of the PLT.  Allocate DT_MIPS_PLTGOT.
	(mips_elf_create_la25_stub_info): New function.
	(_bfd_mips_elf_finish_dynamic_symbol): Write out PLT entries
	and copy relocs where necessary.  Check pointer_equality_needed.
	(mips_finish_exec_plt): New function.
	(_bfd_mips_elf_finish_dynamic_sections): Always set DT_PLTGOT
	to the beginning of htab->sgot.  Use htab->reserved_gotno instead
	of MIPS_RESERVED_GOTNO.  Assert htab->use_plts_and_copy_relocs
	instead of htab->is_vxworks for DT_PLTREL, DT_PLTRELSZ and DT_JMPREL.
	Set DT_PLTREL to DT_REL instead of DT_RELA on non-VxWorks targets.
	Use mips_finish_exec_plt to create non-VxWorks PLT headers.  Set
	DT_MIPS_PLTGOT.
	(_bfd_mips_elf_copy_indirect_symbol): Copy has_static_relocs
	from the indirect symbol to the direct symbol.  Also copy
	has_nonpic_branches for indirect symbols.
	(_bfd_mips_elf_get_target_dtag): Handle DT_MIPS_PLTGOT and
	DT_MIPS_RWPLT.
	(_bfd_mips_elf_link_hash_table_create): Initialize the new
	mips_elf_link_hash_table fields.
	(_bfd_mips_vxworks_link_hash_table_create): Set
	use_plts_and_copy_relocs to TRUE.  Use TRUE rather than 1
	when setting is_vxworks.
	(_bfd_mips_elf_use_plts_and_copy_relocs): New function.
	(_bfd_mips_elf_final_link): Call mips_elf_create_la25_stub for
	each la25_stub.
	(_bfd_mips_elf_merge_private_bfd_data): Treat dynamic objects
	as PIC.  Generalize message about linking PIC and non-PIC.
	(_bfd_mips_elf_plt_sym_val, _bfd_mips_post_process_headers): New
	functions.
	* reloc.c: Update comment near BFD_RELOC_MIPS_JUMP_SLOT.
	* bfd-in2.h: Regenerated.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>

	* readelf.c (get_mips_symbol_other): Handle STO_MIPS_PLT and
	STO_MIPS_PIC.
	(slurp_rela_relocs, slurp_rel_relocs): Handle MIPS ELF64 here.
	(dump_relocations, debug_apply_relocations): Don't handle it here.
	(get_mips_dynamic_type): Handle DT_MIPS_PLTGOT and DT_MIPS_RWPLT.
	(print_mips_pltgot_entry): New function.
	(process_mips_specific): Dump the PLT GOT.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* config/tc-mips.c (OPTION_CALL_NONPIC): New macro.
	(OPTION_NON_SHARED, OPTION_XGOT, OPTION_MABI, OPTION_32)
	(OPTION_N32, OPTION_64, OPTION_MDEBUG, OPTION_NO_MDEBUG)
	(OPTION_PDR, OPTION_NO_PDR, OPTION_MVXWORKS_PIC): Bump by 1.
	(md_longopts): Add -call_nonpic.
	(md_parse_option): Handle OPTION_CALL_NONPIC.
	(md_show_usage): Add -call_nonpic.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/call-nonpic-1.s, gas/mips/call-nonpic-1.d: New test.
	* gas/mips/mips.exp: Run it.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>

	* mips.h (STO_MIPS_PLT, ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT)
	(STO_MIPS_PIC, DT_MIPS_PLTGOT, DT_MIPS_RWPLT): New macros.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* emulparams/elf32bmip.sh (GOT): Define, moving .got.plt to...
	(OTHER_RELRO_SECTIONS, OTHER_READWRITE_SECTIONS): ...one of these
	two variables.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emultempl/mipself.em: Include ldctor.h, elf/mips.h and elfxx-mips.h.
	(is_mips_elf): New macro.
	(stub_file, stub_bfd): New variables.
	(hook_stub_info): New structure.
	(hook_in_stub): New function.
	(mips_add_stub_section): Likewise.
	(mips_create_output_section_statements): Likewise.
	(mips_before_allocation): Likewise.
	(real_func): New variable.
	(mips_for_each_input_file_wrapper): New function.
	(mips_lang_for_each_input_file): Likewise.
	(lang_for_each_input_file): Define.
	(LDEMUL_BEFORE_ALLOCATION): Likewise.
	(LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS): Likewise.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* ld-mips-elf/mips16-pic-3a.s,
	ld-mips-elf/mips16-pic-3b.s,
	ld-mips-elf/mips16-pic-3.dd,
	ld-mips-elf/mips16-pic-3.gd,
	ld-mips-elf/mips16-pic-3.rd,
	ld-mips-elf/mips16-pic-3.inc,
	ld-mips-elf/pic-and-nonpic-1a.s,
	ld-mips-elf/pic-and-nonpic-1b.s,
	ld-mips-elf/pic-and-nonpic-1.ld,
	ld-mips-elf/pic-and-nonpic-1.dd,
	ld-mips-elf/pic-and-nonpic-1.nd,
	ld-mips-elf/pic-and-nonpic-1-rel.dd,
	ld-mips-elf/pic-and-nonpic-1-rel.nd,
	ld-mips-elf/pic-and-nonpic-2a.s,
	ld-mips-elf/pic-and-nonpic-2b.s,
	ld-mips-elf/pic-and-nonpic-2.d,
	ld-mips-elf/pic-and-nonpic-3a.s,
	ld-mips-elf/pic-and-nonpic-3a.ld,
	ld-mips-elf/pic-and-nonpic-3a.dd,
	ld-mips-elf/pic-and-nonpic-3a.gd,
	ld-mips-elf/pic-and-nonpic-3a.sd,
	ld-mips-elf/pic-and-nonpic-3b.s,
	ld-mips-elf/pic-and-nonpic-3b.ld,
	ld-mips-elf/pic-and-nonpic-3b.ad,
	ld-mips-elf/pic-and-nonpic-3b.dd,
	ld-mips-elf/pic-and-nonpic-3b.gd,
	ld-mips-elf/pic-and-nonpic-3b.nd,
	ld-mips-elf/pic-and-nonpic-3b.pd,
	ld-mips-elf/pic-and-nonpic-3b.rd,
	ld-mips-elf/pic-and-nonpic-3b.sd,
	ld-mips-elf/pic-and-nonpic-3-error.d,
	ld-mips-elf/pic-and-nonpic-4a.s,
	ld-mips-elf/pic-and-nonpic-4b.s,
	ld-mips-elf/pic-and-nonpic-4b.ld,
	ld-mips-elf/pic-and-nonpic-4b.ad,
	ld-mips-elf/pic-and-nonpic-4b.dd,
	ld-mips-elf/pic-and-nonpic-4b.gd,
	ld-mips-elf/pic-and-nonpic-4b.nd,
	ld-mips-elf/pic-and-nonpic-4b.rd,
	ld-mips-elf/pic-and-nonpic-4b.sd,
	ld-mips-elf/pic-and-nonpic-4-error.d,
	ld-mips-elf/pic-and-nonpic-5a.s,
	ld-mips-elf/pic-and-nonpic-5b.s,
	ld-mips-elf/pic-and-nonpic-5b.ld,
	ld-mips-elf/pic-and-nonpic-5b.ad,
	ld-mips-elf/pic-and-nonpic-5b.dd,
	ld-mips-elf/pic-and-nonpic-5b.gd,
	ld-mips-elf/pic-and-nonpic-5b.nd,
	ld-mips-elf/pic-and-nonpic-5b.rd,
	ld-mips-elf/pic-and-nonpic-5b.sd,
	ld-mips-elf/pic-and-nonpic-5b.pd,
	ld-mips-elf/pic-and-nonpic-6.ld,
	ld-mips-elf/pic-and-nonpic-6-o32a.s,
	ld-mips-elf/pic-and-nonpic-6-o32b.s,
	ld-mips-elf/pic-and-nonpic-6-o32c.s,
	ld-mips-elf/pic-and-nonpic-6-o32.ad,
	ld-mips-elf/pic-and-nonpic-6-o32.dd,
	ld-mips-elf/pic-and-nonpic-6-o32.gd,
	ld-mips-elf/pic-and-nonpic-6-o32.nd,
	ld-mips-elf/pic-and-nonpic-6-o32.pd,
	ld-mips-elf/pic-and-nonpic-6-o32.rd,
	ld-mips-elf/pic-and-nonpic-6-o32.sd,
	ld-mips-elf/pic-and-nonpic-6-n32a.s,
	ld-mips-elf/pic-and-nonpic-6-n32b.s,
	ld-mips-elf/pic-and-nonpic-6-n32c.s,
	ld-mips-elf/pic-and-nonpic-6-n32.ad,
	ld-mips-elf/pic-and-nonpic-6-n32.dd,
	ld-mips-elf/pic-and-nonpic-6-n32.gd,
	ld-mips-elf/pic-and-nonpic-6-n32.nd,
	ld-mips-elf/pic-and-nonpic-6-n32.pd,
	ld-mips-elf/pic-and-nonpic-6-n32.rd,
	ld-mips-elf/pic-and-nonpic-6-n32.sd,
	ld-mips-elf/pic-and-nonpic-6-n64a.s,
	ld-mips-elf/pic-and-nonpic-6-n64b.s,
	ld-mips-elf/pic-and-nonpic-6-n64c.s,
	ld-mips-elf/pic-and-nonpic-6-n64.ad,
	ld-mips-elf/pic-and-nonpic-6-n64.dd,
	ld-mips-elf/pic-and-nonpic-6-n64.gd,
	ld-mips-elf/pic-and-nonpic-6-n64.nd,
	ld-mips-elf/pic-and-nonpic-6-n64.pd,
	ld-mips-elf/pic-and-nonpic-6-n64.rd,
	ld-mips-elf/pic-and-nonpic-6-n64.sd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d7436 3
a7438 2
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
@


1.246
log
@bfd/
	* elf-bfd.h (MIPS_ELF_TDATA): New elf_object_id.
	* elf32-mips.c (bfd_elf32_mkobject): Define.
	* elf64-mips.c (bfd_elf64_mkobject): Likewise.
	* elfn32-mips.c (bfd_elf32_mkobject): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Declare.
	* elfxx-mips.c (is_mips_elf): New macro.
	(_bfd_mips_elf_mkobject): New function.
	(_bfd_mips_elf_final_link): Use is_mips_elf.
	(_bfd_mips_elf_merge_private_bfd_data): Likewise.
@
text
@d272 35
d337 3
d379 5
d394 4
a397 5
  /* Are we referenced by some kind of relocation?  */
  unsigned int is_relocation_target : 1;

  /* Are we referenced by branch relocations?  */
  unsigned int is_branch_target : 1;
d414 1
d417 1
d420 1
d424 1
d427 1
d430 4
d436 1
d439 1
d450 1
d453 2
a454 1
  /* The size of the PLT header in bytes (VxWorks only).  */
d456 2
a457 1
  /* The size of a PLT entry in bytes (VxWorks only).  */
d459 1
d462 1
d465 30
d665 4
d739 4
a775 4
/* The number of local .got entries we reserve.  */
#define MIPS_RESERVED_GOTNO(INFO) \
  (mips_elf_hash_table (INFO)->is_vxworks ? 3 : 2)

d880 46
d1035 1
d1043 1
d1046 1
a1046 2
      ret->is_relocation_target = FALSE;
      ret->is_branch_target = FALSE;
d1325 29
d1433 3
a1435 2
static bfd_boolean
mips_elf_check_mips16_stubs (struct mips_elf_link_hash_entry *h, void *data)
a1436 6
  struct bfd_link_info *info;

  info = (struct bfd_link_info *) data;
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

d1481 208
d1690 21
d2777 1
d2794 1
a2794 1
	  + sreloc->reloc_count * sizeof (Elf64_Mips_External_Rel)));
d2800 1
a2800 2
	+ sreloc->reloc_count * sizeof (Elf32_External_Rel)));
  ++sreloc->reloc_count;
d2858 1
a2858 1
	    (abfd, sreloc, indx,
d2864 1
a2864 1
	      (abfd, sreloc, indx,
d2897 1
a2897 1
	    (abfd, sreloc, indx,
d2919 1
a2919 1
	  (abfd, sreloc, indx,
d2980 4
d4281 1
a4281 1
			       - MIPS_RESERVED_GOTNO (info));
d4392 1
a4392 1
      assign += MIPS_RESERVED_GOTNO (info);
d4449 1
a4449 1
		      + MIPS_RESERVED_GOTNO (info));
d4672 1
a4672 1
  g->local_gotno = MIPS_RESERVED_GOTNO (info);
d4674 1
a4674 1
  g->assigned_gotno = MIPS_RESERVED_GOTNO (info);
d4690 7
a4696 8
  /* VxWorks also needs a .got.plt section.  */
  if (htab->is_vxworks)
    {
      s = bfd_make_section_with_flags (abfd, ".got.plt",
				       SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      if (s == NULL || !bfd_set_section_alignment (abfd, s, 4))
	return FALSE;
a4697 2
      htab->sgotplt = s;
    }
d4713 28
d5041 7
d5192 1
a5192 2
	   || (!htab->is_vxworks
	       && htab->root.dynamic_sections_created
d5195 2
a5196 1
	       && !h->root.def_regular))
d5203 1
a5203 2
	  /* If we're creating a shared library, or this relocation is
	     against a symbol in a shared library, then we can't know
d5206 3
a5208 5
	     linker.

	     In VxWorks executables, references to external symbols
	     are handled using copy relocs or PLT stubs, so there's
	     no need to add a dynamic relocation here.  */
d6953 8
a6962 7
      /* Create the .plt, .rela.plt, .dynbss and .rela.bss sections.
	 Also create the _PROCEDURE_LINKAGE_TABLE symbol.  */
      if (!_bfd_elf_create_dynamic_sections (abfd, info))
	return FALSE;

      /* Cache the sections created above.  */
      htab->sdynbss = bfd_get_section_by_name (abfd, ".dynbss");
d6965 8
a6972 6
      htab->splt = bfd_get_section_by_name (abfd, ".plt");
      if (!htab->sdynbss
	  || (!htab->srelbss && !info->shared)
	  || !htab->srelplt
	  || !htab->splt)
	abort ();
d6974 2
d6996 6
d7418 1
d7436 4
d7441 24
a7464 2
	  /* This may be an indirect symbol created because of a version.  */
	  if (h != NULL)
d7466 5
a7470 2
	      while (h->root.type == bfd_link_hash_indirect)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
d7472 8
a7479 1
	}
d7481 13
a7493 4
      /* Some relocs require a global offset table.  */
      if (dynobj == NULL || htab->sgot == NULL)
	{
	  switch (r_type)
d7495 1
a7495 14
	    case R_MIPS16_GOT16:
	    case R_MIPS16_CALL16:
	    case R_MIPS_GOT16:
	    case R_MIPS_CALL16:
	    case R_MIPS_CALL_HI16:
	    case R_MIPS_CALL_LO16:
	    case R_MIPS_GOT_HI16:
	    case R_MIPS_GOT_LO16:
	    case R_MIPS_GOT_PAGE:
	    case R_MIPS_GOT_OFST:
	    case R_MIPS_GOT_DISP:
	    case R_MIPS_TLS_GOTTPREL:
	    case R_MIPS_TLS_GD:
	    case R_MIPS_TLS_LDM:
d7498 3
a7500 11
	      if (!mips_elf_create_got_section (dynobj, info))
		return FALSE;
	      if (htab->is_vxworks && !info->shared)
		{
		  (*_bfd_error_handler)
		    (_("%B: GOT reloc at 0x%lx not expected in executables"),
		     abfd, (unsigned long) rel->r_offset);
		  bfd_set_error (bfd_error_bad_value);
		  return FALSE;
		}
	      break;
d7502 6
a7507 11
	    case R_MIPS_32:
	    case R_MIPS_REL32:
	    case R_MIPS_64:
	      /* In VxWorks executables, references to external symbols
		 are handled using copy relocs or PLT stubs, so there's
		 no need to add a dynamic relocation here.  */
	      if (dynobj == NULL
		  && (info->shared || (h != NULL && !htab->is_vxworks))
		  && (sec->flags & SEC_ALLOC) != 0)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	      break;
d7509 6
a7514 3
	    default:
	      break;
	    }
a7518 2
	  ((struct mips_elf_link_hash_entry *) h)->is_relocation_target = TRUE;

d7555 3
a7598 5
	      while (hmips->root.root.type == bfd_link_hash_indirect
		     || hmips->root.root.type == bfd_link_hash_warning)
		hmips = (struct mips_elf_link_hash_entry *)
		  hmips->root.root.u.i.link;

d7694 1
a7694 3
	  if ((info->shared || (h != NULL && !htab->is_vxworks))
	      && !(h && strcmp (h->root.root.string, "__gnu_local_gp") == 0)
	      && (sec->flags & SEC_ALLOC) != 0)
a7741 5
	case R_MIPS_PC16:
	  if (h)
	    ((struct mips_elf_link_hash_entry *) h)->is_branch_target = TRUE;
	  break;

a7742 4
	  if (h)
	    ((struct mips_elf_link_hash_entry *) h)->is_branch_target = TRUE;
	  /* Fall through.  */

d7802 40
d8096 1
d8108 9
a8116 3
  /* For a function, create a stub, if allowed.  */
  if (! hmips->no_fn_stub
      && h->needs_plt)
d8132 2
a8133 8
  else if ((h->type == STT_FUNC)
	   && !h->needs_plt)
    {
      /* This will set the entry for this symbol in the GOT to 0, and
         the dynamic linker will take care of this.  */
      h->root.u.def.value = 0;
      return TRUE;
    }
d8135 13
a8147 4
  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
d8149 5
a8153 6
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }
d8155 7
a8161 2
  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */
d8163 5
a8167 2
  return TRUE;
}
d8169 1
a8169 22
/* Likewise, for VxWorks.  */

bfd_boolean
_bfd_mips_vxworks_adjust_dynamic_symbol (struct bfd_link_info *info,
					 struct elf_link_hash_entry *h)
{
  bfd *dynobj;
  struct mips_elf_link_hash_entry *hmips;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  dynobj = elf_hash_table (info)->dynobj;
  hmips = (struct mips_elf_link_hash_entry *) h;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->needs_copy
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));
d8171 8
a8178 34
  /* If the symbol is defined by a dynamic object, we need a PLT stub if
     either (a) we want to branch to the symbol or (b) we're linking an
     executable that needs a canonical function address.  In the latter
     case, the canonical address will be the address of the executable's
     load stub.  */
  if ((hmips->is_branch_target
       || (!info->shared
	   && h->type == STT_FUNC
	   && hmips->is_relocation_target))
      && h->def_dynamic
      && h->ref_regular
      && !h->def_regular
      && !h->forced_local)
    h->needs_plt = 1;

  /* Locally-binding symbols do not need a PLT stub; we can refer to
     the functions directly.  */
  else if (h->needs_plt
	   && (SYMBOL_CALLS_LOCAL (info, h)
	       || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
		   && h->root.type == bfd_link_hash_undefweak)))
    {
      h->needs_plt = 0;
      return TRUE;
    }

  if (h->needs_plt)
    {
      /* If this is the first symbol to need a PLT entry, allocate room
	 for the header, and for the header's .rela.plt.unloaded entries.  */
      if (htab->splt->size == 0)
	{
	  htab->splt->size += htab->plt_header_size;
	  if (!info->shared)
d8187 1
a8187 3
	 symbol's value to the address of the stub.  Point at the PLT
	 load stub rather than the lazy resolution stub; this stub
	 will become the canonical function address.  */
d8192 5
a8196 1
	  h->root.u.def.value += 8;
d8199 6
a8204 3
      /* Make room for the .got.plt entry and the R_JUMP_SLOT relocation.  */
      htab->sgotplt->size += 4;
      htab->srelplt->size += sizeof (Elf32_External_Rela);
d8207 1
a8207 1
      if (!info->shared)
d8210 3
a8212 2
      return TRUE;
    }
a8213 8
  /* If a function symbol is defined by a dynamic object, and we do not
     need a PLT stub for it, the symbol's value should be zero.  */
  if (h->type == STT_FUNC
      && h->def_dynamic
      && h->ref_regular
      && !h->def_regular)
    {
      h->root.u.def.value = 0;
d8229 3
a8231 3
  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */
  if (info->shared)
d8234 16
d8262 4
a8265 1
      htab->srelbss->size += sizeof (Elf32_External_Rela);
d8269 4
d8286 1
d8295 7
a8301 4
  if (! (info->relocatable
	 || ! mips_elf_hash_table (info)->mips16_stubs_seen))
    mips_elf_link_hash_traverse (mips_elf_hash_table (info),
				 mips_elf_check_mips16_stubs, info);
d8328 10
d8405 1
a8405 1
	  count = g->global_gotno + g->local_gotno - MIPS_RESERVED_GOTNO (info);
d8515 1
a8515 1
  asection *s;
d8535 16
a8550 1
      }
d8624 7
d8634 2
a8635 2
	       && s != htab->splt
	       && s != htab->sstubs)
d8699 1
d8704 1
a8704 1
	  if (mips_elf_rel_dyn_section (info, FALSE))
a8714 11
	  if (htab->splt->size > 0)
	    {
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTREL, 0))
		return FALSE;

	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_JMPREL, 0))
		return FALSE;

	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTRELSZ, 0))
		return FALSE;
	    }
d8718 1
a8718 1
	  if (mips_elf_rel_dyn_section (info, FALSE))
d8761 14
d9169 62
d9302 3
a9304 1
  if (h->plt.offset != MINUS_ONE)
d9306 66
d9558 17
d9785 41
d9981 7
a9987 15
	      name = ".got";
	      if (htab->is_vxworks)
		{
		  /* _GLOBAL_OFFSET_TABLE_ is defined to be the beginning
		     of the ".got" section in DYNOBJ.  */
		  s = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (s != NULL);
		  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
		}
	      else
		{
		  s = bfd_get_section_by_name (output_bfd, name);
		  BFD_ASSERT (s != NULL);
		  dyn.d_un.d_ptr = s->vma;
		}
d10053 1
a10053 1
	      dyn.d_un.d_val = g->local_gotno - MIPS_RESERVED_GOTNO (info);
d10074 5
a10078 2
	      BFD_ASSERT (htab->is_vxworks);
	      dyn.d_un.d_val = DT_RELA;
d10082 1
a10082 1
	      BFD_ASSERT (htab->is_vxworks);
d10087 2
a10088 2
	      BFD_ASSERT (htab->is_vxworks);
	      dyn.d_un.d_val = (htab->srelplt->output_section->vma
d10316 1
a10316 1
  if (htab->is_vxworks && htab->splt->size > 0)
d10318 7
a10324 2
      if (info->shared)
	mips_vxworks_finish_shared_plt (output_bfd, info);
d10326 4
a10329 1
	mips_vxworks_finish_exec_plt (output_bfd, info);
d10910 7
a10919 2
  dirmips = (struct mips_elf_link_hash_entry *) dir;
  indmips = (struct mips_elf_link_hash_entry *) ind;
d10929 2
d11400 1
d11416 3
d11436 2
a11437 1
      htab->is_vxworks = 1;
d11441 9
d11464 1
d11492 8
d12415 3
a12417 5
  /* Don't care about the PIC flags from dynamic objects; they are
     PIC by design.  */
  if ((new_flags & (EF_MIPS_PIC | EF_MIPS_CPIC)) != 0
      && (ibfd->flags & DYNAMIC) != 0)
    new_flags &= ~ (EF_MIPS_PIC | EF_MIPS_CPIC);
d12449 1
a12449 1
	(_("%B: warning: linking PIC files with non-PIC files"),
d12660 4
d12798 27
@


1.245
log
@bfd/
	* elfxx-mips.c (mips_elf_record_relocs): Defer allocation of a
	global GOT entry when deferring allocation of dynamic relocations.
	(allocate_dynrelocs): When allocating deferred dynamic relocations,
	also do the deferred allocation of a GOT entry.
@
text
@d246 5
d10648 9
d10953 1
a10953 3
	      if (bfd_get_flavour (input_bfd) != bfd_target_elf_flavour
		  || (get_elf_backend_data (input_bfd)
		      ->elf_backend_ecoff_debug_swap) == NULL)
d11626 1
a11626 2
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
@


1.244
log
@bfd/
	* elfxx-mips.c (mips_got_info): Add a "reloc_only_gotno" field.
	(mips_elf_got_section): Delete.
	(mips_elf_sort_hash_table): Use g->reloc_only_gotno to decide
	how many reloc-only entries there are.
	(mips_elf_count_got_symbols): Adjust g->reloc_only_gotno as
	well as g->global_gotno.
	(mips_elf_make_got_per_bfd): Initialize reloc_only_gotno.
	(mips_elf_multi_got): Likewise.  Use gg->reloc_only_gotno
	rather than gg->assigned_gotno to store the number of
	reloc-only GOT entries.
	(mips_elf_create_got_section): Remove the MAYBE_EXCLUDE parameter.
	Initialize reloc_only_gotno.
	(mips_elf_calculate_relocation): Check htab->got_info instead of
	dynobj when deciding whether to call mips_elf_adjust_gp,
	(_bfd_mips_elf_create_dynamic_sections): Adjust the call
	to mips_elf_create_got_section.
	(mips_elf_record_relocs): Likewise.  Remove redundant
	"dynobj == NULL" code.  Do not use mips_elf_create_got_section
	or mips_elf_record_global_got_symbol for R_MIPS_32, R_MIPS_REL32
	and R_MIPS_64; limit global_got_area to GGA_RELOC_ONLY instead.
	(_bfd_mips_elf_finish_dynamic_symbol): Use htab->sgot instead
	of mips_elf_got_section.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_finish_dynamic_sections): Likewise.
	Move the initial assignment of G to the block that uses it;
	it is used for an unrelated purpose later.

ld/testsuite/
	* ld-mips-elf/tls-hidden4.got, ld-mips-elf/tls-hidden4.r: We have
	removed an unused GOT entry that was allocated for the R_MIPS_32
	relocation against "undef", so adjust addresses down by 4 bytes.
	* ld-mips-elf/got-dump-1.d, ld-mips-elf/got-dump-2.d: We have
	changed the order of the GOT entries so that reloc-only ones
	come last.  "undef" is only referred to by dynamic relocations,
	so it now comes after "glob".
	* ld-mips-elf/mips16-pic-2.dd, ld-mips-elf/mips16-pic-2.gd,
	ld-mips-elf/mips16-pic-2.nd, ld-mips-elf/mips16-pic-2.rd: We have
	removed two unused local GOT entries that were originally created
	as global entries for the hidden symbols "used2" and "used3".
	"used4" and "used5" are only referred to by relocations, so they
	now come after "used6" and "used7".
@
text
@a7276 15

	      /* Even though we don't directly need a GOT entry for
		 this symbol, a symbol must have a dynamic symbol
		 table index greater that DT_MIPS_GOTSYM if there are
		 dynamic relocations against it.  This does not apply
		 to VxWorks, which does not have the usual coupling
		 between global GOT entries and .dynsym entries.  */
	      if (h != NULL && !htab->is_vxworks)
		{
		  struct mips_elf_link_hash_entry *hmips;

		  hmips = (struct mips_elf_link_hash_entry *) h;
		  if (hmips->global_got_area > GGA_RELOC_ONLY)
		    hmips->global_got_area = GGA_RELOC_ONLY;
		}
d7573 6
@


1.243
log
@bfd/
	* elfxx-mips.c (count_section_dynsyms): Move before the new first use.
	(mips_elf_sort_hash_table): Take the output bfd as a parameter.
	Remove the MAX_LOCAL parameter.  Exit early if there are no
	dynamic symbols, if there is no dynobj, or if there is no
	GOT section.  Use count_section_dynsyms instead of MAX_LOCAL.
	Assert == rather than <= when checking hsd.max_unref_got_dynindx.
	Also assert that g->global_gotno is right.
	(mips_elf_count_forced_local_got_symbols): Rename to...
	(mips_elf_count_got_symbols): ...and count global GOT entries too.
	Set the global_got_area of a forced-local GGA_RELOC_ONLY symbol
	to GGA_NONE.
	(mips_elf_multi_got): Don't sort the symbol table.
	(mips_elf_lay_out_got): Likewise.  Use mips_elf_count_got_symbols
	to count the number of global GOT entries.
	(_bfd_mips_elf_final_link): Unconditionally call
	mips_elf_sort_hash_table.
@
text
@d148 2
a2284 13
/* Returns the GOT section, if it hasn't been excluded.  */

static asection *
mips_elf_got_section (struct bfd_link_info *info)
{
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  if (htab->sgot == NULL || (htab->sgot->flags & SEC_EXCLUDE) != 0)
    return NULL;
  return htab->sgot;
}

d2415 1
d2421 2
a2422 1
  sgot = mips_elf_got_section (info);
d2948 3
a2950 10
  hsd.max_unref_got_dynindx =
  hsd.min_got_dynindx = elf_hash_table (info)->dynsymcount
    /* In the multi-got case, assigned_gotno of the master got_info
       indicate the number of entries that aren't referenced in the
       primary GOT, but that must have entries because there are
       dynamic relocations that reference it.  Since they aren't
       referenced, we move them to the end of the GOT, so that they
       don't prevent other entries that are referenced from getting
       too large offsets.  */
    - (g->next ? g->assigned_gotno : 0);
d3400 5
a3404 1
	g->global_gotno++;
d3483 1
d3904 1
d3957 1
a3957 1
  gg->assigned_gotno = gg->global_gotno - g->global_gotno;
d4217 1
a4217 2
mips_elf_create_got_section (bfd *abfd, struct bfd_link_info *info,
			     bfd_boolean maybe_exclude)
d4230 2
a4231 7
  s = htab->sgot;
  if (s)
    {
      if (! maybe_exclude)
	s->flags &= ~SEC_EXCLUDE;
      return TRUE;
    }
a4235 3
  if (maybe_exclude)
    flags |= SEC_EXCLUDE;

d4269 1
d4627 1
a4627 1
  if (dynobj)
d6402 1
a6402 1
  if (! mips_elf_create_got_section (abfd, info, FALSE))
d7024 1
a7024 1
	      if (! mips_elf_create_got_section (dynobj, info, FALSE))
d7286 5
a7290 6
		  if (dynobj == NULL)
		    elf_hash_table (info)->dynobj = dynobj = abfd;
		  if (! mips_elf_create_got_section (dynobj, info, TRUE))
		    return FALSE;
		  if (!mips_elf_record_global_got_symbol (h, abfd, info, 0))
		    return FALSE;
d8802 1
a8802 2
  sgot = mips_elf_got_section (info);
  BFD_ASSERT (sgot != NULL);
d9072 1
a9072 2
  sgot = mips_elf_got_section (info);
  BFD_ASSERT (sgot != NULL);
d9234 2
a9235 9
  sgot = mips_elf_got_section (info);
  if (sgot == NULL)
    gg = g = NULL;
  else
    {
      gg = htab->got_info;
      g = mips_elf_got_for_ibfd (gg, output_bfd);
      BFD_ASSERT (g != NULL);
    }
d9243 3
@


1.242
log
@bfd/
	* elfxx-mips.c (GGA_NORMAL, GGA_RELOC_ONLY, GGA_NONE): New macros.
	(mips_elf_link_hash_entry): Add a "global_got_area" field.
	(mips_elf_link_hash_newfunc): Initialize it.
	(mips_elf_sort_hash_table_f): Use h->global_got_area instead of
	h->root.got.offset.  Do not handle forced_local symbols specially.
	(mips_elf_record_global_got_symbol): Set h->global_got_area
	instead of h->root.got.offset.
	(mips_elf_recreate_got): Assert that h->global_got_area == GGA_NONE
	for indirect and warning symbols.
	(mips_elf_count_forced_local_got_symbols): Change the argument
	from a "elf_link_hash_entry" to "mips_elf_link_hash_entry".
	Use and set h->global_got_area instead of h->root.got.offset.
	Set it to GGA_NONE for all forced-local symbols.
	(mips_elf_set_global_got_offset): Set h->global_got_area
	instead of h->root.got.offset.  Use g->global_got_area instead
	of a combination of dynindx, forced_local and tls_type.
	(mips_elf_multi_got): Remove disabled code.  Pass GGA_* values to
	mips_elf_set_global_got_offset.
	(mips_elf_lay_out_got): Use mips_elf_link_hash_traverse instead
	of elf_link_hash_traverse.
	(_bfd_mips_elf_copy_indirect_symbol): Copy the indirect symbol's
	global_got_area to the direct symbol if the latter's value is higher.
	Set the indirect symbol's area to GGA_NONE.

ld/testsuite/
	* ld-mips-elf/got-vers-1a.s, ld-mips-elf/got-vers-1b.s,
	ld-mips-elf/got-vers-1.ver, ld-mips-elf/got-vers-1.dd,
	ld-mips-elf/got-vers-1.sd, ld-mips-elf/got-vers-1.rd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d2912 26
d2939 1
a2939 5
   appear towards the end.  This reduces the amount of GOT space
   required.  MAX_LOCAL is used to set the number of local symbols
   known to be in the dynamic symbol table.  During
   _bfd_mips_elf_size_dynamic_sections, this value is 1.  Afterward, the
   section symbols are added and the count is higher.  */
d2942 1
a2942 1
mips_elf_sort_hash_table (struct bfd_link_info *info, unsigned long max_local)
d2948 3
d2953 2
d2967 1
a2967 1
  hsd.max_non_got_dynindx = max_local;
d2976 4
a2979 2
  BFD_ASSERT ((unsigned long)hsd.max_unref_got_dynindx
	      <= elf_hash_table (info)->dynsymcount);
d3396 1
a3396 2
   to a mips_got_info.  Add each forced-local GOT symbol to DATA's
   local_gotno field.  */
d3399 1
a3399 2
mips_elf_count_forced_local_got_symbols (struct mips_elf_link_hash_entry *h,
					 void *data)
d3404 1
a3404 2
  if (h->global_got_area != GGA_NONE
      && (h->root.forced_local || h->root.dynindx == -1))
d3406 11
a3416 6
      /* We no longer need this entry if it was only used for
	 relocations; those relocations will be against the
	 null or section symbol instead of H.  */
      if (h->global_got_area != GGA_RELOC_ONLY)
	g->local_gotno++;
      h->global_got_area = GGA_NONE;
a3976 2
  if (! mips_elf_sort_hash_table (info, 1))
    return FALSE;
a7823 26
/* Return the number of dynamic section symbols required by OUTPUT_BFD.
   The number might be exact or a worst-case estimate, depending on how
   much information is available to elf_backend_omit_section_dynsym at
   the current linking stage.  */

static bfd_size_type
count_section_dynsyms (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd_size_type count;

  count = 0;
  if (info->shared || elf_hash_table (info)->is_relocatable_executable)
    {
      asection *p;
      const struct elf_backend_data *bed;

      bed = get_elf_backend_data (output_bfd);
      for (p = output_bfd->sections; p ; p = p->next)
	if ((p->flags & SEC_EXCLUDE) == 0
	    && (p->flags & SEC_ALLOC) != 0
	    && !(*bed->elf_backend_omit_section_dynsym) (output_bfd, info, p))
	  ++count;
    }
  return count;
}

a7857 1
  int i;
d7877 2
a7878 18
  /* Count the number of forced-local entries.  */
  mips_elf_link_hash_traverse (htab,
			       mips_elf_count_forced_local_got_symbols, g);

  /* There has to be a global GOT entry for every symbol with
     a dynamic symbol table index of DT_MIPS_GOTSYM or
     higher.  Therefore, it make sense to put those symbols
     that need GOT entries at the end of the symbol table.  We
     do that here.  */
  if (! mips_elf_sort_hash_table (info, 1))
    return FALSE;

  if (g->global_gotsym != NULL)
    i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
  else
    /* If there are no global symbols, or none requiring
       relocations, then GLOBAL_GOTSYM will be NULL.  */
    i = 0;
d7915 1
a7915 3

  g->global_gotno = i;
  s->size += i * MIPS_ELF_GOT_SIZE (output_bfd);
d10778 2
a10779 4
  /* We'd carefully arranged the dynamic symbol indices, and then the
     generic size_dynamic_sections renumbered them out from under us.
     Rather than trying somehow to prevent the renumbering, just do
     the sort again.  */
d10781 2
a10782 23
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      struct mips_got_info *g;
      bfd_size_type dynsecsymcount;

      /* When we resort, we must tell mips_elf_sort_hash_table what
	 the lowest index it may use is.  That's the number of section
	 symbols we're going to add.  The generic ELF linker only
	 adds these symbols when building a shared object.  Note that
	 we count the sections after (possibly) removing the .options
	 section above.  */

      dynsecsymcount = count_section_dynsyms (abfd, info);
      if (! mips_elf_sort_hash_table (info, dynsecsymcount + 1))
	return FALSE;

      /* Make sure we didn't grow the global .got region.  */
      g = htab->got_info;
      if (g->global_gotsym != NULL)
	BFD_ASSERT ((elf_hash_table (info)->dynsymcount
		     - g->global_gotsym->dynindx)
		    <= g->global_gotno);
    }
@


1.241
log
@bfd/
	* elf32-mips.c (elf_backend_hide_symbol): Delete.
	* elfn32-mips.c (elf_backend_hide_symbol): Likewise.
	* elf64-mips.c (elf_backend_hide_symbol): Likewise.
	* elfxx-mips.h (elf_backend_hide_symbol): Likewise.
	* elfxx-mips.c (mips_elf_link_hash_entry): Remove "forced_local"
	and add "needs_lazy_stub".
	(mips_elf_link_hash_newfunc): Update accordingly.
	(mips_elf_link_hash_table): Remove "computed_got_sizes" and
	add "lazy_stub_count".
	(_bfd_mips_elf_link_hash_table_create): Update accordingly.
	(mips_elf_output_extsym): Use hd->needs_lazy_stub to detect
	cases where a lazy stub is being used.
	(mips_elf_sort_hash_table_f): Use h->root.forced_local instead
	of h->forced_local.
	(mips_elf_record_global_got_symbol): Use _bfd_elf_link_hash_hide_symbol
	instead of _bfd_mips_elf_hide_symbol.  Do not increment local_gotno
	here.
	(mips_elf_allocate_dynamic_relocations): Move before new first use.
	(mips_elf_check_recreate_got, mips_elf_recreate_got): New functions.
	(mips_elf_resolve_final_got_entries): Move earlier in file.  Make at
	most two passes over the hash table.  Use mips_elf_check_recreate_got
	to see if there are any indirect or warning entries and
	mips_elf_recreate_got to create a new GOT without them.
	Return a boolean success value.
	(mips_elf_count_forced_local_got_entries): New function.
	(mips_elf_make_got_per_bfd): Check h->root.forced_local instead of
	h->forced_local.
	(mips_elf_set_global_got_offset): Likewise.
	(mips_elf_set_no_stub): Replace with...
	(mips_elf_forbid_lazy_stubs): ...this new function.
	(mips_elf_resolve_final_got_entry): Delete.
	(mips_elf_multi_got): Fix formatting.  Use mips_elf_forbid_lazy_stubs
	instead of mips_elf_set_no_stub.  Move the code that sets
	global offsets and allocates dynamic relocations from the main
	_bfd_mips_elf_size_dynamic_sections loop to here.
	(_bfd_mips_elf_adjust_dynamic_symbol): Do not allocate room in
	.MIPS.stubs here; just set hmips->needs_lazy_stub and increment
	htab->lazy_stub_count.
	(_bfd_mips_elf_always_size_sections): Move the stub-estimation
	code to mips_elf_estimate_stub_size and the GOT-sizing code to
	mips_elf_lay_out_got.  Do not call these functions here.
	(mips_elf_estimate_stub_size): New function, split
	out from _bfd_mips_elf_always_size_sections.  Call
	mips_elf_resolve_final_got_entries earlier.  Count the number
	of forced-local entries.  Do not add stub sizes to loadable_size;
	after this patch, the stub sizes are already included in the main
	estimate.  Allocate dynamic relocations here rather than in the
	main _bfd_mips_elf_size_dynamic_sections loop.
	(mips_elf_estimate_stub_size): New function, split out from
	_bfd_mips_elf_always_size_sections.
	(mips_elf_allocate_lazy_stub): New function.
	(mips_elf_lay_out_lazy_stubs): Likewise.
	(_bfd_mips_elf_size_dynamic_sections): Call mips_elf_estimate_stub_size,
	mips_elf_lay_out_got and mips_elf_lay_out_lazy_stubs.  Do not handle
	the allocation of sreldyn specially.
	(_bfd_mips_elf_hide_symbol): Delete.

ld/testsuite/
	* ld-mips-elf/tlsdyn-o32-2.got, ld-mips-elf/tlsdyn-o32-3.got,
	ld-mips-elf/tlsdyn-o32-2.d, ld-mips-elf/tlsdyn-o32-3.d: Change the
	GOT layout as follows:

	         BEFORE                  AFTER
	   +0x08 %call16(__tls_get_addr) %call16(__tls_get_addr)
	   +0x0c %tlsldm(tlsbin_ld)      %gottprel(tlsvar_ie)
	   +0x10   "  "                  %tlsgd(tlsvar_gd)
	   +0x14 %tlsgd(tlsvar_gd)          "  "
	   +0x18   "  "                  %tlsgd(tlsbin_gd)
	   +0x1c %gottprel(tlsvar_ie)       "  "
	   +0x20 %tlsgd(tlsbin_gd)       %tlsldm(tlsbin_ld)
	   +0x24   "  "                     "  "
	   +0x28 %gottprel(tlsbin_ie)    %gottprel(tlsbin_ie)
@
text
@d244 21
d327 3
d895 1
d2976 1
a2976 6
  /* Global symbols that need GOT entries that are not explicitly
     referenced are marked with got offset 2.  Those that are
     referenced get a 1, and those that don't need GOT entries get
     -1.  Forced local symbols may also be marked with got offset 1,
     but are never given global GOT entries.  */
  if (h->root.got.offset == 2)
d2978 12
d2995 1
a2995 9
    }
  else if (h->root.got.offset != 1 || h->root.forced_local)
    h->root.dynindx = hsd->max_non_got_dynindx++;
  else
    {
      BFD_ASSERT (h->tls_type == GOT_NORMAL);

      h->root.dynindx = --hsd->min_got_dynindx;
      hsd->low = (struct elf_link_hash_entry *) h;
d3011 1
d3016 1
a3062 3
  if (h->got.offset != MINUS_ONE)
    return TRUE;

d3064 1
a3064 4
    /* By setting this to a value other than -1, we are indicating that
       there needs to be a GOT entry for H.  Avoid using zero, as the
       generic ELF copy_indirect_symbol tests for <= 0.  */
    h->got.offset = 1;
d3319 4
a3322 1
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;
d3366 3
a3368 2
/* An elf_link_hash_traverse callback for which DATA points to a mips_got_info.
   Add each forced-local GOT symbol to DATA's local_gotno field.  */
d3371 1
a3371 1
mips_elf_count_forced_local_got_symbols (struct elf_link_hash_entry *h,
d3377 2
a3378 2
  if (h->got.offset != MINUS_ONE
      && (h->forced_local || h->dynindx == -1))
d3383 1
a3383 3
      if (h->got.offset == 2)
	h->got.offset = MINUS_ONE;
      else
d3385 1
d3751 3
a3753 4
  if (entry->abfd != NULL && entry->symndx == -1
      && entry->d.h->root.dynindx != -1
      && !entry->d.h->root.forced_local
      && entry->d.h->tls_type == GOT_NORMAL)
d3767 1
a3767 1
	entry->d.h->root.got.offset = arg->value;
d3933 5
a3937 34
  /* The IRIX dynamic linker requires every symbol that is referenced
     in a dynamic relocation to be present in the primary GOT, so
     arrange for them to appear after those that are actually
     referenced.

     GNU/Linux could very well do without it, but it would slow down
     the dynamic linker, since it would have to resolve every dynamic
     symbol referenced in other GOTs more than once, without help from
     the cache.  Also, knowing that every external symbol has a GOT
     helps speed up the resolution of local symbols too, so GNU/Linux
     follows IRIX's practice.

     The number 2 is used by mips_elf_sort_hash_table_f to count
     global GOT symbols that are unreferenced in the primary GOT, with
     an initial dynamic index computed from gg->assigned_gotno, where
     the number of unreferenced global entries in the primary GOT is
     preserved.  */
  if (1)
    {
      gg->assigned_gotno = gg->global_gotno - g->global_gotno;
      g->global_gotno = gg->global_gotno;
      set_got_offset_arg.value = 2;
    }
  else
    {
      /* This could be used for dynamic linkers that don't optimize
	 symbol resolution while applying relocations so as to use
	 primary GOT entries or assuming the symbol is locally-defined.
	 With this code, we assign lower dynamic indices to global
	 symbols that are not referenced in the primary GOT, so that
	 their entries can be omitted.  */
      gg->assigned_gotno = 0;
      set_got_offset_arg.value = -1;
    }
a3938 2
  /* Reorder dynamic symbols as described above (which behavior
     depends on the setting of VALUE).  */
d3940 1
d3943 1
a3943 1
  set_got_offset_arg.value = 1;
d7876 2
a7877 2
  elf_link_hash_traverse (elf_hash_table (info),
			  mips_elf_count_forced_local_got_symbols, g);
d10259 4
@


1.240
log
@bfd/
	* elfxx-mips.c (allocate_dynrelocs): Ignore indirect and warning
	symbols.

ld/testsuite/
	* ld-mips-elf/reloc-estimate-1.d, ld-mips-elf/reloc-estimate-1.ld,
	ld-mips-elf/reloc-estimate-1a.s, ld-mips-elf/reloc-estimate-1b.s:
	New test.
	* ld-mips-elf/mips-elf.exp: Run it.
@
text
@a319 4
  /* Are we forced local?  This will only be set if we have converted
     the initial global GOT entry to a local GOT entry.  */
  unsigned int forced_local : 1;

d325 4
a351 2
  /* True if we've computed the size of the GOT.  */
  bfd_boolean computed_got_sizes;
d372 2
a873 1
      ret->forced_local = FALSE;
d876 1
d2069 1
a2069 1
  else if (h->root.needs_plt)
a2071 1
      bfd_boolean no_fn_stub = h->no_fn_stub;
d2074 1
a2074 4
	{
	  hd = (struct mips_elf_link_hash_entry *)h->root.root.u.i.link;
	  no_fn_stub = no_fn_stub || hd->no_fn_stub;
	}
d2076 1
a2076 1
      if (!no_fn_stub)
d2964 1
a2964 1
  else if (h->root.got.offset != 1 || h->forced_local)
d3000 1
a3000 1
	  _bfd_mips_elf_hide_symbol (info, h, TRUE);
d3041 4
a3044 8
    {
      /* By setting this to a value other than -1, we are indicating that
	 there needs to be a GOT entry for H.  Avoid using zero, as the
	 generic ELF copy_indirect_symbol tests for <= 0.  */
      h->got.offset = 1;
      if (h->forced_local)
	g->local_gotno++;
    }
d3224 142
d3497 1
a3497 1
  else if (entry->symndx >= 0 || entry->d.h->forced_local)
d3730 1
a3730 1
      && !entry->d.h->forced_local
d3751 4
a3754 2
/* Mark any global symbols referenced in the GOT we are iterating over
   as inelligible for lazy resolution stubs.  */
d3756 1
a3756 1
mips_elf_set_no_stub (void **entryp, void *p ATTRIBUTE_UNUSED)
d3758 3
a3760 1
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
d3762 3
d3767 1
a3767 19
      && entry->d.h->root.dynindx != -1)
    entry->d.h->no_fn_stub = TRUE;

  return 1;
}

/* Follow indirect and warning hash entries so that each got entry
   points to the final symbol definition.  P must point to a pointer
   to the hash table we're traversing.  Since this traversal may
   modify the hash table, we set this pointer to NULL to indicate
   we've made a potentially-destructive change to the hash table, so
   the traversal must be restarted.  */
static int
mips_elf_resolve_final_got_entry (void **entryp, void *p)
{
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  htab_t got_entries = *(htab_t *)p;

  if (entry->abfd != NULL && entry->symndx == -1)
d3769 2
a3770 27
      struct mips_elf_link_hash_entry *h = entry->d.h;

      while (h->root.root.type == bfd_link_hash_indirect
 	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

      if (entry->d.h == h)
	return 1;

      entry->d.h = h;

      /* If we can't find this entry with the new bfd hash, re-insert
	 it, and get the traversal restarted.  */
      if (! htab_find (got_entries, entry))
	{
	  htab_clear_slot (got_entries, entryp);
	  entryp = htab_find_slot (got_entries, entry, INSERT);
	  if (! *entryp)
	    *entryp = entry;
	  /* Abort the traversal, since the whole table may have
	     moved, and leave it up to the parent to restart the
	     process.  */
	  *(htab_t *)p = NULL;
	  return 0;
	}
      /* We might want to decrement the global_gotno count, but it's
	 either too early or too late for that at this point.  */
a3775 18
/* Turn indirect got entries in a got_entries table into their final
   locations.  */
static void
mips_elf_resolve_final_got_entries (struct mips_got_info *g)
{
  htab_t got_entries;

  do
    {
      got_entries = g->got_entries;

      htab_traverse (got_entries,
		     mips_elf_resolve_final_got_entry,
		     &got_entries);
    }
  while (got_entries == NULL);
}

d3807 2
a3808 1
  unsigned int assign;
d3810 1
d4001 2
a4002 2
      /* Mark global symbols in every non-primary GOT as ineligible for
	 stubs.  */
d4004 1
a4004 1
	htab_traverse (g->got_entries, mips_elf_set_no_stub, NULL);
d4009 35
a4043 2
		    + gg->next->global_gotno
		    + gg->next->tls_gotno) * MIPS_ELF_GOT_SIZE (abfd);
a5176 27
/* Add room for N relocations to the .rel(a).dyn section in ABFD.  */

static void
mips_elf_allocate_dynamic_relocations (bfd *abfd, struct bfd_link_info *info,
				       unsigned int n)
{
  asection *s;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  s = mips_elf_rel_dyn_section (info, FALSE);
  BFD_ASSERT (s != NULL);

  if (htab->is_vxworks)
    s->size += n * MIPS_ELF_RELA_SIZE (abfd);
  else
    {
      if (s->size == 0)
	{
	  /* Make room for a null element.  */
	  s->size += MIPS_ELF_REL_SIZE (abfd);
	  ++s->reloc_count;
	}
      s->size += n * MIPS_ELF_REL_SIZE (abfd);
    }
}

d7638 2
a7639 12
	  /* We need .stub section.  */
	  h->root.u.def.section = htab->sstubs;
	  h->root.u.def.value = htab->sstubs->size;

	  /* XXX Write this stub address somewhere.  */
	  h->plt.offset = htab->sstubs->size;

	  /* Make room for this stub code.  */
	  htab->sstubs->size += htab->function_stub_size;

	  /* The last half word of the stub will be filled with the index
	     of this symbol in .dynsym section.  */
a7837 9

  asection *s;
  struct mips_got_info *g;
  int i;
  bfd_size_type loadable_size = 0;
  bfd_size_type page_gotno;
  bfd_size_type dynsymcount;
  bfd *sub;
  struct mips_elf_count_tls_arg count_tls_arg;
d7852 19
d7875 1
d7878 4
a7881 6
  /* Calculate the total loadable size of the output.  That
     will give us the maximum number of GOT_PAGE entries
     required.  */
  for (sub = info->input_bfds; sub; sub = sub->link_next)
    {
      asection *subsection;
d7883 3
a7885 10
      for (subsection = sub->sections;
	   subsection;
	   subsection = subsection->next)
	{
	  if ((subsection->flags & SEC_ALLOC) == 0)
	    continue;
	  loadable_size += ((subsection->size + 0xf)
			    &~ (bfd_size_type) 0xf);
	}
    }
d7902 6
a7907 6
  /* Get a worst-case estimate of the number of dynamic symbols needed.
     At this point, dynsymcount does not account for section symbols
     and count_section_dynsyms may overestimate the number that will
     be needed.  */
  dynsymcount = (elf_hash_table (info)->dynsymcount
		 + count_section_dynsyms (output_bfd, info));
d7909 10
a7918 9
  /* Determine the size of one stub entry.  */
  htab->function_stub_size = (dynsymcount > 0x10000
			      ? MIPS_FUNCTION_STUB_BIG_SIZE
			      : MIPS_FUNCTION_STUB_NORMAL_SIZE);

  /* In the worst case, we'll get one stub per dynamic symbol, plus
     one to account for the dummy entry at the end required by IRIX
     rld.  */
  loadable_size += htab->function_stub_size * (i + 1);
a7951 2
  mips_elf_resolve_final_got_entries (g);

d7955 14
a7968 1
  if (!htab->is_vxworks && s->size > MIPS_ELF_GOT_MAX_SIZE (info))
d7975 3
a7977 1
      /* Set up TLS entries for the first GOT.  */
d7980 10
a7990 1
  htab->computed_got_sizes = TRUE;
d7995 71
d8073 1
a8073 1
  asection *s, *sreldyn;
a8094 5
  /* IRIX rld assumes that the function stub isn't at the end
     of the .text section, so add a dummy entry to the end.  */
  if (htab->sstubs && htab->sstubs->size > 0)
    htab->sstubs->size += htab->function_stub_size;

d8098 7
a8108 1
  sreldyn = NULL;
a8155 82
      else if (htab->is_vxworks && strcmp (name, ".got") == 0)
	{
	  /* Executables do not need a GOT.  */
	  if (info->shared)
	    {
	      /* Allocate relocations for all but the reserved entries.  */
	      unsigned int count;

	      count = (htab->got_info->global_gotno
		       + htab->got_info->local_gotno
		       - MIPS_RESERVED_GOTNO (info));
	      mips_elf_allocate_dynamic_relocations (dynobj, info, count);
	    }
	}
      else if (!htab->is_vxworks && CONST_STRNEQ (name, ".got"))
	{
	  /* _bfd_mips_elf_always_size_sections() has already done
	     most of the work, but some symbols may have been mapped
	     to versions that we must now resolve in the got_entries
	     hash tables.  */
	  struct mips_got_info *gg = htab->got_info;
	  struct mips_got_info *g = gg;
	  struct mips_elf_set_global_got_offset_arg set_got_offset_arg;
	  unsigned int needed_relocs = 0;

	  if (gg->next)
	    {
	      set_got_offset_arg.value = MIPS_ELF_GOT_SIZE (output_bfd);
	      set_got_offset_arg.info = info;

	      /* NOTE 2005-02-03: How can this call, or the next, ever
		 find any indirect entries to resolve?  They were all
		 resolved in mips_elf_multi_got.  */
	      mips_elf_resolve_final_got_entries (gg);
	      for (g = gg->next; g && g->next != gg; g = g->next)
		{
		  unsigned int save_assign;

		  mips_elf_resolve_final_got_entries (g);

		  /* Assign offsets to global GOT entries.  */
		  save_assign = g->assigned_gotno;
		  g->assigned_gotno = g->local_gotno;
		  set_got_offset_arg.g = g;
		  set_got_offset_arg.needed_relocs = 0;
		  htab_traverse (g->got_entries,
				 mips_elf_set_global_got_offset,
				 &set_got_offset_arg);
		  needed_relocs += set_got_offset_arg.needed_relocs;
		  BFD_ASSERT (g->assigned_gotno - g->local_gotno
			      <= g->global_gotno);

		  g->assigned_gotno = save_assign;
		  if (info->shared)
		    {
		      needed_relocs += g->local_gotno - g->assigned_gotno;
		      BFD_ASSERT (g->assigned_gotno == g->next->local_gotno
				  + g->next->global_gotno
				  + g->next->tls_gotno
				  + MIPS_RESERVED_GOTNO (info));
		    }
		}
	    }
	  else
	    {
	      struct mips_elf_count_tls_arg arg;
	      arg.info = info;
	      arg.needed = 0;

	      htab_traverse (gg->got_entries, mips_elf_count_local_tls_relocs,
			     &arg);
	      elf_link_hash_traverse (elf_hash_table (info),
				      mips_elf_count_global_tls_relocs,
				      &arg);

	      needed_relocs += arg.needed;
	    }

	  if (needed_relocs)
	    mips_elf_allocate_dynamic_relocations (dynobj, info,
						   needed_relocs);
	}
d8168 1
a8185 8
      /* Allocate memory for this section last, since we may increase its
	 size above.  */
      if (strcmp (name, MIPS_ELF_REL_DYN_NAME (info)) == 0)
	{
	  sreldyn = s;
	  continue;
	}

a8194 11
  /* Allocate memory for the .rel(a).dyn section.  */
  if (sreldyn != NULL)
    {
      sreldyn->contents = bfd_zalloc (dynobj, sreldyn->size);
      if (sreldyn->contents == NULL)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return FALSE;
	}
    }

a10270 85

void
_bfd_mips_elf_hide_symbol (struct bfd_link_info *info,
			   struct elf_link_hash_entry *entry,
			   bfd_boolean force_local)
{
  bfd *dynobj;
  struct mips_got_info *g;
  struct mips_elf_link_hash_entry *h;
  struct mips_elf_link_hash_table *htab;

  h = (struct mips_elf_link_hash_entry *) entry;
  if (h->forced_local)
    return;
  h->forced_local = force_local;

  dynobj = elf_hash_table (info)->dynobj;
  htab = mips_elf_hash_table (info);
  if (dynobj != NULL
      && force_local
      && h->root.type != STT_TLS
      && htab->got_info != NULL)
    {
      g = htab->got_info;
      if (g->next)
	{
	  struct mips_got_entry e;
	  struct mips_got_info *gg = g;

	  /* Since we're turning what used to be a global symbol into a
	     local one, bump up the number of local entries of each GOT
	     that had an entry for it.  This will automatically decrease
	     the number of global entries, since global_gotno is actually
	     the upper limit of global entries.  */
	  e.abfd = dynobj;
	  e.symndx = -1;
	  e.d.h = h;
	  e.tls_type = 0;

	  for (g = g->next; g != gg; g = g->next)
	    if (htab_find (g->got_entries, &e))
	      {
		BFD_ASSERT (g->global_gotno > 0);
		g->local_gotno++;
		g->global_gotno--;
	      }

	  /* If this was a global symbol forced into the primary GOT, we
	     no longer need an entry for it.  We can't release the entry
	     at this point, but we must at least stop counting it as one
	     of the symbols that required a forced got entry.  */
	  if (h->root.got.offset == 2)
	    {
	      BFD_ASSERT (gg->assigned_gotno > 0);
	      gg->assigned_gotno--;
	    }
	}
      else if (h->root.got.offset == 1)
	{
	  /* check_relocs didn't know that this symbol would be
	     forced-local, so add an extra local got entry.  */
	  g->local_gotno++;
	  if (htab->computed_got_sizes)
	    {
	      /* We'll have treated this symbol as global rather
		 than local.  */
	      BFD_ASSERT (g->global_gotno > 0);
	      g->global_gotno--;
	    }
	}
      else if (htab->is_vxworks && h->root.needs_plt)
	{
	  /* check_relocs didn't know that this symbol would be
	     forced-local, so add an extra local got entry.  */
	  g->local_gotno++;
	  if (htab->computed_got_sizes)
	    /* The symbol is only used in call relocations, so we'll
	       have assumed it only needs a .got.plt entry.  Increase
	       the size of .got accordingly.  */
	    htab->sgot->size += MIPS_ELF_GOT_SIZE (dynobj);
        }
    }

  _bfd_elf_link_hash_hide_symbol (info, &h->root, force_local);
}
a10726 1
  ret->computed_got_sizes = FALSE;
d10740 1
@


1.239
log
@bfd/
	* elfxx-mips.c (mips_elf_link_hash_entry): Move bfd_boolean
	fields to the end of the structure and make them single-bit
	bitfields.
	(mips_elf_link_hash_newfunc): Make the initialization statements
	follow the new field order.
@
text
@d7463 6
@


1.238
log
@bfd/
	* elfxx-mips.c (_mips_elf_section_data): Remove the "u.got_info" field.
	(mips_elf_link_hash_table): Add "sgot" and "got_info" fields.
	(_bfd_mips_elf_link_hash_table_create): Initialize them.
	(mips_elf_got_section): Always apply the !maybe_excluded behavior.
	(mips_elf_got_info): Delete.
	(mips_elf_initialize_tls_slots): Remove the DYNOBJ local variable.
	Adjust the call to mips_elf_got_section.
	(mips_elf_local_got_index): Don't call mips_elf_got_info.
	Update the call to mips_elf_create_local_got_entry.
	Use htab->got_info.
	(mips_elf_global_got_index): Don't call mips_elf_got_info;
	use htab->got_info and htab->sgot instead.
	(mips_elf_got_page): Don't call mips_elf_got_info.  Update the
	call to mips_elf_create_local_got_entry.
	(mips_elf_got16_entry): Likewise.
	(mips_elf_got_offset_from_index): Replace with DYNOBJ parameter
	with an INFO parameter.  Don't call mips_elf_got_info; use htab->sgot
	and htab->got_info instead.
	(mips_elf_create_local_got_entry): Remove the GG and SGOT parameters.
	Use htab->sgot and htab->got_info.
	(mips_elf_sort_hash_table): Remove the DYNOBJ local variable.
	Don't call mips_elf_got_info; use htab->got_info instead.
	(mips_elf_record_global_got_symbol): Turn G from a paramter to
	a local variable and read it from htab->got_info.
	(mips_elf_record_local_got_symbol): Replace the G parameter with
	an INFO parameter.  Make G a local variable and read it from
	htab->got_info instead.
	(mips_elf_record_got_page_entry): Likewise.
	(mips_elf_multi_got): Remove the G parameter and make it a local
	variable instead.  Read it from htab->got_info.
	(mips_elf_create_got_section): Cache the GOT section in htab->sgot.
	Store the GOT information in htab->got_info.
	(mips_elf_calculate_relocation): Don't call mips_elf_got_section
	and mips_elf_got_info; use htab->sgot and htab->got_info instead.
	Adjust the calls to mips_elf_got_offset_from_index and
	mips_elf_adjust_gp.
	(_bfd_mips_elf_check_relocs): Remove the G and SGOT local variables.
	Adjust the calls to mips_elf_record_local_got_symbol,
	mips_elf_record_global_got_symbol and mips_elf_record_got_page_entry.
	Use htab->sgot.
	(_bfd_mips_elf_always_size_sections): Remove the DYNOBJ local variable.
	Don't call mips_elf_got_info; use htab->sgot and htab->got_info instead.
	Update the call to mips_elf_multi_got.
	(_bfd_mips_elf_size_dynamic_sections): Don't call mips_elf_got_info;
	use htab->got_info instead.
	(_bfd_mips_elf_finish_dynamic_symbol): Update the call to
	mips_elf_got_section.  Get the got_info from the hash table
	rather than the GOT section.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_finish_dynamic_sections): Likewise.
	(_bfd_mips_elf_hide_symbol): Don't call mips_elf_got_section;
	get the got_info from the hash table instead.  Remove the GOT
	local variable.
	(_bfd_mips_elf_final_link): Likewise.  Also remove the DYNOBJ
	local variable.
@
text
@a277 10
  /* If the R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 reloc is against
     a readonly section.  */
  bfd_boolean readonly_reloc;

  /* We must not create a stub for a symbol that has relocations
     related to taking the function's address, i.e. any but
     R_MIPS_CALL*16 ones -- see "MIPS ABI Supplement, 3rd Edition",
     p. 4-20.  */
  bfd_boolean no_fn_stub;

a281 4
  /* Whether we need the fn_stub; this is set if this symbol appears
     in any relocs other than a 16 bit call.  */
  bfd_boolean need_fn_stub;

a289 10
  /* Are we forced local?  This will only be set if we have converted
     the initial global GOT entry to a local GOT entry.  */
  bfd_boolean forced_local;

  /* Are we referenced by some kind of relocation?  */
  bfd_boolean is_relocation_target;

  /* Are we referenced by branch relocations?  */
  bfd_boolean is_branch_target;

d297 1
d305 24
d867 4
a872 1
      ret->fn_stub = NULL;
a873 2
      ret->call_stub = NULL;
      ret->call_fp_stub = NULL;
d875 1
a876 2
      ret->is_relocation_target = FALSE;
      ret->tls_type = GOT_NORMAL;
@


1.237
log
@bfd/
	* elfxx-mips.c (mips_elf_link_hash_table): Add an "sstubs" field.
	(_bfd_mips_elf_create_dynamic_sections): Use it to cache the stubs
	section.  Don't check whether the section already exists.
	(_bfd_mips_elf_adjust_dynamic_symbol): Use htab->sstubs.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_finish_dynamic_sections): Likewise.
	(_bfd_mips_elf_size_dynamic_sections): Likewise.  Don't add the
	dummy stub to an empty section.
	(_bfd_mips_elf_link_hash_table_create): Initialize the "sstubs" field.

ld/testsuite/
	* ld-mips-elf/tls-hidden3.ld: Remove the unused .MIPS.stubs section.
	Keep the text start address the same.
	* ld-mips-elf/tls-multi-got-1.got: We have removed a .MIPS.stubs
	section that contained only a 16-byte dummy stub.  Subtract 16
	from addresses to account for the change.
	* ld-mips-elf/tls-multi-got-1.r: Likewise.  Adjust MIPS_UNREFEXTNO
	to account the removed section symbol.
	* ld-mips-elf/tlsdyn-o32-1.d: We have deleted a .MIPS.stubs
	section that contained only a 16-byte dummy stub.  Remove it
	from the disassembly.
	* ld-mips-elf/tlsdyn-o32-2.d: Likewise.
	* ld-mips-elf/tlsdyn-o32-3.d: Likewise.
	* ld-mips-elf/tlsdyn-o32.d: Likewise.
	* ld-mips-elf/relax-jalr-n32-shared.d: Likewise.
	* ld-mips-elf/relax-jalr-n64-shared.d: Likewise.
@
text
@a236 1
    struct mips_got_info *got_info;
d366 3
d525 2
a526 2
  (bfd *, struct bfd_link_info *, bfd *, struct mips_got_info *, asection *,
   bfd_vma, unsigned long, struct mips_elf_link_hash_entry *, int);
d2261 1
a2261 1
/* Returns the GOT section for ABFD.  */
d2264 1
a2264 1
mips_elf_got_section (bfd *abfd, bfd_boolean maybe_excluded)
d2266 4
a2269 3
  asection *sgot = bfd_get_section_by_name (abfd, ".got");
  if (sgot == NULL
      || (! maybe_excluded && (sgot->flags & SEC_EXCLUDE) != 0))
d2271 1
a2271 23
  return sgot;
}

/* Returns the GOT information associated with the link indicated by
   INFO.  If SGOTP is non-NULL, it is filled in with the GOT
   section.  */

static struct mips_got_info *
mips_elf_got_info (bfd *abfd, asection **sgotp)
{
  asection *sgot;
  struct mips_got_info *g;

  sgot = mips_elf_got_section (abfd, TRUE);
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
  g = mips_elf_section_data (sgot)->u.got_info;
  BFD_ASSERT (g != NULL);

  if (sgotp)
    *sgotp = (sgot->flags & SEC_EXCLUDE) == 0 ? sgot : NULL;

  return g;
a2406 1
  bfd *dynobj;
d2409 1
a2409 2
  dynobj = elf_hash_table (info)->dynobj;
  sgot = mips_elf_got_section (dynobj, FALSE);
d2596 1
a2596 2
  asection *sgot;
  struct mips_got_info *g;
d2599 3
a2601 4
  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

  entry = mips_elf_create_local_got_entry (abfd, info, ibfd, g, sgot,
					   value, r_symndx, h, r_type);
d2607 1
a2607 1
      if (entry->symndx == -1 && g->next == NULL)
d2626 1
a2627 1
  asection *sgot;
d2631 2
a2632 1
  gg = g = mips_elf_got_info (abfd, &sgot);
d2698 1
a2698 1
  BFD_ASSERT (index < sgot->size);
a2712 2
  asection *sgot;
  struct mips_got_info *g;
a2715 2
  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

d2717 2
a2718 2
  entry = mips_elf_create_local_got_entry (abfd, info, ibfd, g, sgot,
					   page, 0, NULL, R_MIPS_GOT_PAGE);
a2738 2
  asection *sgot;
  struct mips_got_info *g;
a2747 2
  g = mips_elf_got_info (elf_hash_table (info)->dynobj, &sgot);

d2751 2
a2752 2
  entry = mips_elf_create_local_got_entry (abfd, info, ibfd, g, sgot,
					   value, 0, NULL, R_MIPS_GOT16);
d2763 1
a2763 1
mips_elf_got_offset_from_index (bfd *dynobj, bfd *output_bfd,
d2766 1
a2768 1
  struct mips_got_info *g;
d2770 2
a2771 1
  g = mips_elf_got_info (dynobj, &sgot);
d2773 1
a2773 1
    + mips_elf_adjust_gp (output_bfd, g, input_bfd);
d2785 1
a2785 2
				 bfd *ibfd, struct mips_got_info *gg,
				 asection *sgot, bfd_vma value,
d2801 1
a2801 1
  g = mips_elf_got_for_ibfd (gg, ibfd);
d2804 1
a2804 1
      g = mips_elf_got_for_ibfd (gg, abfd);
d2865 1
a2865 1
		     (sgot->contents + entry.gotidx));
d2876 2
a2877 2
      got_address = (sgot->output_section->vma
		     + sgot->output_offset
d2900 1
a2902 1
  bfd *dynobj;
d2904 2
a2905 3
  dynobj = elf_hash_table (info)->dynobj;

  g = mips_elf_got_info (dynobj, NULL);
a2986 1
				   struct mips_got_info *g,
d2989 1
d2991 3
d3011 1
d3061 1
a3061 1
				  struct mips_got_info *g,
d3064 2
d3068 4
d3133 5
a3137 4
   that ADDEND is the addend for that relocation.  G is the GOT
   information.  This function creates an upper bound on the number of
   GOT slots required; no attempt is made to combine references to
   non-overridable global symbols across multiple input files.  */
d3140 2
a3141 2
mips_elf_record_got_page_entry (bfd *abfd, long symndx, bfd_signed_vma addend,
				struct mips_got_info *g)
d3143 2
d3150 4
d3720 1
a3720 2
		    struct mips_got_info *g, asection *got,
		    bfd_size_type pages)
d3722 1
d3725 1
a3725 1
  struct mips_got_info *gg;
d3728 2
d4104 1
a4104 1
  s = mips_elf_got_section (abfd, TRUE);
d4124 1
d4166 1
a4166 1
  mips_elf_section_data (s)->u.got_info = g;
d4509 1
a4509 2
    gp += mips_elf_adjust_gp (abfd, mips_elf_got_info (dynobj, NULL),
			      input_bfd);
d4574 4
a4577 7
		{
		  /* This is a static link or a -Bsymbolic link.  The
		     symbol is defined locally, or was forced to be local.
		     We must initialize this entry in the GOT.  */
		  asection *sgot = mips_elf_got_section (dynobj, FALSE);
		  MIPS_ELF_PUT_WORD (dynobj, symbol, sgot->contents + g);
		}
d4593 1
a4593 1
      g = mips_elf_got_offset_from_index (dynobj, abfd, input_bfd, g);
d4828 1
a4828 1
	    = mips_elf_got_offset_from_index (dynobj, abfd, input_bfd, value);
d4882 1
a4882 1
      value = mips_elf_got_offset_from_index (dynobj, abfd, input_bfd, value);
a6604 1
  struct mips_got_info *g;
a6607 1
  asection *sgot;
a6877 18
  if (dynobj == NULL)
    {
      sgot = NULL;
      g = NULL;
    }
  else
    {
      sgot = mips_elf_got_section (dynobj, FALSE);
      if (sgot == NULL)
	g = NULL;
      else
	{
	  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
	  g = mips_elf_section_data (sgot)->u.got_info;
	  BFD_ASSERT (g != NULL);
	}
    }

d6912 1
a6912 1
      if (dynobj == NULL || sgot == NULL)
a6933 1
	      g = mips_elf_got_info (dynobj, &sgot);
d6996 2
a6997 2
	  if (! mips_elf_record_local_got_symbol (abfd, r_symndx,
						  rel->r_addend, g, 0))
d7023 1
a7023 1
		  && !mips_elf_record_global_got_symbol (h, abfd, info, g, 0))
d7080 2
a7081 1
	      if (!mips_elf_record_got_page_entry (abfd, r_symndx, addend, g))
d7088 1
a7088 1
	  if (h && ! mips_elf_record_global_got_symbol (h, abfd, info, g, 0))
d7120 2
a7121 1
		if (h && ! mips_elf_record_global_got_symbol (h, abfd, info, g, flag))
d7128 3
a7130 2
		if (! mips_elf_record_local_got_symbol (abfd, r_symndx,
							rel->r_addend, g, flag))
d7198 1
a7198 2
		  g = mips_elf_got_info (dynobj, &sgot);
		  if (! mips_elf_record_global_got_symbol (h, abfd, info, g, 0))
a7753 1
  bfd *dynobj;
d7776 2
a7777 3
  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    /* Relocatable links don't have it.  */
d7780 1
a7780 3
  g = mips_elf_got_info (dynobj, &s);
  if (s == NULL)
    return TRUE;
d7871 1
a7871 1
      if (! mips_elf_multi_got (output_bfd, info, g, s, page_gotno))
a7979 1
	      struct mips_got_info *g;
d7982 2
a7983 3
	      g = mips_elf_got_info (dynobj, NULL);
	      count = (g->global_gotno
		       + g->local_gotno
d7994 1
a7994 1
	  struct mips_got_info *gg = mips_elf_got_info (dynobj, NULL);
d8763 1
a8763 1
  sgot = mips_elf_got_section (dynobj, FALSE);
d8765 1
a8765 2
  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
  g = mips_elf_section_data (sgot)->u.got_info;
d9034 1
a9034 1
  sgot = mips_elf_got_section (dynobj, FALSE);
d9036 1
a9036 2
  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
  g = mips_elf_section_data (sgot)->u.got_info;
d9197 1
a9197 1
  sgot = mips_elf_got_section (dynobj, FALSE);
d9202 1
a9202 3
      BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
      gg = mips_elf_section_data (sgot)->u.got_info;
      BFD_ASSERT (gg != NULL);
a10195 1
  asection *got;
d10207 4
a10210 3
  if (dynobj != NULL && force_local && h->root.type != STT_TLS
      && (got = mips_elf_got_section (dynobj, TRUE)) != NULL
      && (g = mips_elf_section_data (got)->u.got_info) != NULL)
d10212 1
d10268 1
a10268 1
	    got->size += MIPS_ELF_GOT_SIZE (dynobj);
d10740 2
a10807 2
      bfd *dynobj;
      asection *got;
d10823 1
a10823 4
      dynobj = elf_hash_table (info)->dynobj;
      got = mips_elf_got_section (dynobj, FALSE);
      g = mips_elf_section_data (got)->u.got_info;

@


1.236
log
@bfd/
	* reloc.c (BFD_RELOC_MIPS16_GOT16, BFD_RELOC_MIPS16_CALL16): Declare.
	* libbfd.h, bfd-in2.h: Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(mips16_reloc_map): Add mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(mips16_elf64_howto_table_rela): Likewise.
	(mips16_reloc_map): Add mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(elf_mips16_howto_table_rela): Likewise.
	(mips16_reloc_map): Add mappings.
	* elfxx-mips.c (mips_elf_create_shadow_symbol): New function.
	(section_allows_mips16_refs_p): Likewise.
	(mips16_stub_symndx): Likewise.
	(mips_elf_check_mips16_stubs): Treat the data argument as a
	bfd_link_info.  Mark every dynamic symbol as needing MIPS16 stubs
	and create a "shadow" symbol for the original MIPS16 definition.
	(mips16_reloc_p, got16_reloc_p, call16_reloc_p, hi16_reloc_p)
	(lo16_reloc_p, mips16_call_reloc_p): New functions.
	(_bfd_mips16_elf_reloc_unshuffle): Use mips16_reloc_p to generalize
	relocation checks.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	(_bfd_mips_elf_lo16_reloc): Handle R_MIPS16_GOT16.
	(mips_elf_got16_entry): Add comment.
	(mips_elf_calculate_relocation): Use hi16_reloc_p,
	lo16_reloc_p, mips16_call_reloc_p, call16_reloc_p and got16_reloc_p
	to generalize relocation checks.  Use section_allows_mips16_refs_p
	instead of mips16_stub_section_p.   Handle R_MIPS16_CALL16 and
	R_MIPS16_GOT16, allowing the former to refer directly to a
	MIPS16 function if its stub is not needed.
	(mips16_stub_section_p): Delete.
	(_bfd_mips_elf_symbol_processing): Convert odd-valued function
	symbols into even MIPS16 symbols.
	(mips_elf_add_lo16_rel_addend): Use mips16_reloc_p to generalize
	a relocation check.
	(_bfd_mips_elf_check_relocs): Calculate "bed" and "rel_end"
	earlier in the function.  Use mips16_stub_symndx to identify
	the target function.  Avoid out-of-bounds accesses when the
	stub has no relocations; report an error instead.  Use
	section_allows_mips16_refs_p instead of mips16_stub_section_p.
	Use mips16_call_reloc_p and got16_reloc_p to generalize relocation
	checks.  Handle R_MIPS16_CALL16 and R_MIPS16_GOT16.  Don't create
	dynamic relocations for absolute references to __gnu_local_gp.
	(_bfd_mips_elf_always_size_sections): Pass a bfd_link_info as
	the argument to mips_elf_check_mips16_stubs.  Generalize comment.
	(_bfd_mips_elf_relocate_section): Use hi16_reloc_p and got16_reloc_p
	to generalize relocation checks.
	(_bfd_mips_elf_finish_dynamic_symbol): If a dynamic MIPS16 function
	symbol has a non-MIPS16 stub, redirect the symbol to the stub.
	Fix an overly long line.  Don't give dynamic symbols type STO_MIPS16.
	(_bfd_mips_elf_gc_sweep_hook): Handle R_MIPS16_CALL16 and
	R_MIPS16_GOT16.

gas/
	* config/tc-mips.c (mips16_reloc_p, got16_reloc_p, hi16_reloc_p)
	(lo16_reloc_p): New functions.
	(reloc_needs_lo_p): Use hi16_reloc_p and got16_reloc_p to
	generalize relocation checks.
	(matching_lo_reloc): New function.
	(fixup_has_matching_lo_p): Use it.
	(mips16_mark_labels): Don't clobber a symbol's visibility.
	(append_insn): Use hi16_reloc_p and lo16_reloc_p.
	(mips16_ip): Handle BFD_RELOC_MIPS16_GOT16 and BFD_RELOC_MIPS16_CALL16.
	(md_apply_fix): Likewise.
	(mips16_percent_op): Add %got and %call16.
	(mips_frob_file): Use got16_reloc_p to generalize relocation checks.
	Use matching_lo_reloc.
	(mips_force_relocation): Use hi16_reloc_p and lo16_reloc_p to
	generalize relocation checks.
	(mips_fix_adjustable): Use lo16_reloc_p to generalize relocation
	checks.

gas/testsuite/
	* gas/mips/elf-rel8-mips16.d, gas/mips/elf-rel8-mips16.s,
	* gas/mips/elf-rel9-mips16.d, gas/mips/elf-rel9-mips16.s,
	* gas/mips/elf-rel13-mips16.d, gas/mips/elf-rel13-mips16.s: New tests.
	* gas/mips/mips.exp: Run them.

ld/testsuite/
	* ld-mips-elf/mips16-local-stubs-1.d: Remove stub_for_h3,
	which was only referenced by the .pdr section, and was not
	actually needed by code.
	* ld-mips-elf/mips16-intermix.d: Remove unused static function stubs.
	* ld-mips-elf/mips16-pic-1a.s,
	ld-mips-elf/mips16-pic-1b.s,
	ld-mips-elf/mips16-pic-1-dummy.s,
	ld-mips-elf/mips16-pic-1.dd,
	ld-mips-elf/mips16-pic-1.gd,
	ld-mips-elf/mips16-pic-1.inc,
	ld-mips-elf/mips16-pic-1.ld,
	ld-mips-elf/mips16-pic-2a.s,
	ld-mips-elf/mips16-pic-2b.s,
	ld-mips-elf/mips16-pic-2.ad,
	ld-mips-elf/mips16-pic-2.dd,
	ld-mips-elf/mips16-pic-2.gd,
	ld-mips-elf/mips16-pic-2.nd,
	ld-mips-elf/mips16-pic-2.rd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d366 1
d6332 8
a6339 11
  if (bfd_get_section_by_name (abfd,
			       MIPS_ELF_STUB_SECTION_NAME (abfd)) == NULL)
    {
      s = bfd_make_section_with_flags (abfd,
				       MIPS_ELF_STUB_SECTION_NAME (abfd),
				       flags | SEC_CODE);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s,
					  MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return FALSE;
    }
a7548 1
  asection *s;
d7578 2
a7579 6
	  s = bfd_get_section_by_name (dynobj,
				       MIPS_ELF_STUB_SECTION_NAME (dynobj));
	  BFD_ASSERT (s != NULL);

	  h->root.u.def.section = s;
	  h->root.u.def.value = s->size;
d7582 1
a7582 1
	  h->plt.offset = s->size;
d7585 1
a7585 1
	  s->size += htab->function_stub_size;
d7950 6
a7955 1
    }
a8095 6
      else if (strcmp (name, MIPS_ELF_STUB_SECTION_NAME (output_bfd)) == 0)
	{
	  /* IRIX rld assumes that the function stub isn't at the end
	     of .text section.  So put a dummy.  XXX  */
	  s->size += htab->function_stub_size;
	}
d8109 2
a8110 1
	       && s != htab->splt)
a8731 1
      asection *s;
a8737 4
      s = bfd_get_section_by_name (dynobj,
				   MIPS_ELF_STUB_SECTION_NAME (dynobj));
      BFD_ASSERT (s != NULL);

d8772 3
a8774 2
      BFD_ASSERT (h->plt.offset <= s->size);
      memcpy (s->contents + h->plt.offset, stub, htab->function_stub_size);
d8783 2
a8784 1
      sym->st_value = (s->output_section->vma + s->output_offset
d9597 1
a9597 3
	    s = bfd_get_section_by_name (dynobj,
					 MIPS_ELF_STUB_SECTION_NAME (dynobj));
	    if (s != NULL)
d9601 3
a9603 3
		BFD_ASSERT (s->size >= htab->function_stub_size);
		dummy_offset = s->size - htab->function_stub_size;
		memset (s->contents + dummy_offset, 0,
d10782 1
@


1.235
log
@	* elfxx-mips.c (mips_elf_calculate_relocation): Avoid generating
	relocations for undefined weak symbols with non-default visibility.
	(_bfd_mips_elf_check_relocs): Use possibly_dynamic_relocs for
	global symbols in shared libraries.
	(allocate_dynrelocs): New function.
	(_bfd_mips_elf_adjust_dynamic_symbol): Do not handle
	possibly_dynamic_relocs here.
	(_bfd_mips_elf_size_dynamic_sections): Call allocate_dynrelocs.
@
text
@a527 2
static bfd_boolean mips16_stub_section_p
  (bfd *, asection *);
d1149 76
d1230 1
a1230 2
mips_elf_check_mips16_stubs (struct mips_elf_link_hash_entry *h,
			     void *data ATTRIBUTE_UNUSED)
d1232 3
d1238 9
d1345 12
a1356 2
   R_MIPS16_GPREL is used for GP-relative addressing in mips16
   mode.  A typical instruction will have a format like this:
d1367 52
a1418 14
   This is handled exactly like R_MIPS_GPREL16, except that the
   addend is retrieved and stored as shown in this diagram; that
   is, the Imm fields above replace the V-rel16 field.

   All we need to do here is shuffle the bits appropriately.  As
   above, the two 16-bit halves must be swapped on a
   little-endian system.

   R_MIPS16_HI16 and R_MIPS16_LO16 are used in mips16 mode to
   access data when neither GP-relative nor PC-relative addressing
   can be used.  They are handled like R_MIPS_HI16 and R_MIPS_LO16,
   except that the addend is retrieved and stored as shown above
   for R_MIPS16_GPREL.
  */
d1425 1
a1425 2
  if (r_type != R_MIPS16_26 && r_type != R_MIPS16_GPREL
      && r_type != R_MIPS16_HI16 && r_type != R_MIPS16_LO16)
d1451 1
a1451 2
  if (r_type != R_MIPS16_26 && r_type != R_MIPS16_GPREL
      && r_type != R_MIPS16_HI16 && r_type != R_MIPS16_LO16)
d1580 1
a1580 1
/* A howto special_function for REL R_MIPS_GOT16 relocations.  This is just
d1629 2
a1630 2
      /* R_MIPS_GOT16 relocations are something of a special case.  We
	 want to install the addend in the same way as for a R_MIPS_HI16
d1636 2
d2756 1
a2756 1
/* Find a local GOT entry for an R_MIPS_GOT16 relocation against VALUE.
d2777 3
d4355 1
a4355 2
	  if (r_type != R_MIPS_HI16 && r_type != R_MIPS_LO16
	      && r_type != R_MIPS16_HI16 && r_type != R_MIPS16_LO16)
d4429 14
a4442 5
  /* If this is a 32- or 64-bit call to a 16-bit function with a stub, we
     need to redirect the call to the stub, unless we're already *in*
     a stub.  */
  if (r_type != R_MIPS16_26 && !info->relocatable
      && ((h != NULL && h->fn_stub != NULL)
d4446 1
a4446 1
      && !mips16_stub_section_p (input_bfd, input_section))
d4464 3
a4466 1
     need to redirect the call to the stub.  */
d4538 2
d4565 1
a4565 1
		  || r_type == R_MIPS_CALL16))
d4595 1
a4595 1
	       && (r_type == R_MIPS_CALL16 || (r_type == R_MIPS_GOT16)))
d4825 2
d4830 1
a4830 1
	 R_MIPS_GOT16; every relocation evaluates to "G".  */
a5073 10

/* Returns TRUE if SECTION is a MIPS16 stub section.  */

static bfd_boolean
mips16_stub_section_p (bfd *abfd ATTRIBUTE_UNUSED, asection *section)
{
  const char *name = bfd_get_section_name (abfd, section);

  return FN_STUB_P (name) || CALL_STUB_P (name) || CALL_FP_STUB_P (name);
}
d5455 1
a5455 2
/* Handle the special MIPS section numbers that a symbol may use.
   This is used for both the 32-bit and the 64-bit ABI.  */
d5462 1
d5550 9
d6553 1
a6553 1
  if (r_type == R_MIPS16_HI16)
d6643 3
d6656 10
a6665 1
      r_symndx = ELF_R_SYM (abfd, relocs->r_info);
d6683 1
a6683 1
		  || mips16_stub_section_p (abfd, o))
d6695 1
a6695 1
		    && ELF_R_TYPE (abfd, r->r_info) != R_MIPS16_26)
d6781 10
a6790 1
      r_symndx = ELF_R_SYM (abfd, relocs->r_info);
d6808 1
a6808 1
		  || mips16_stub_section_p (abfd, o))
a6915 2
  bed = get_elf_backend_data (abfd);
  rel_end = relocs + sec->reloc_count * bed->s->int_rels_per_ext_rel;
d6953 2
d7024 1
a7024 1
	       || (r_type == R_MIPS_GOT16 && htab->is_vxworks))
d7029 2
a7030 2
	     the segment.  Similar comments apply to R_MIPS_GOT16 and
	     R_MIPS_CALL16, except on VxWorks, where GOT relocations
d7042 1
d7093 1
d7178 1
d7292 1
d7300 4
a7303 3
      /* If this reloc is not a 16 bit call, and it has a global
         symbol, then we will need the fn_stub if there is one.
         References from a stub section do not count.  */
d7305 2
a7306 2
	  && r_type != R_MIPS16_26
	  && !mips16_stub_section_p (abfd, sec))
d7816 1
a7816 1
				 mips_elf_check_mips16_stubs, NULL);
d7878 1
a7878 1
    /* There's no need to allocate page entries for VxWorks; R_MIPS_GOT16
d8426 2
a8427 3
	      if (r_type == R_MIPS_HI16
		  || r_type == R_MIPS16_HI16
		  || (r_type == R_MIPS_GOT16
d8466 1
a8466 2
	      if (r_type == R_MIPS_HI16
		  || r_type == R_MIPS_GOT16)
d8731 1
d8735 1
d8798 12
d8828 2
a8829 1
      offset = mips_elf_global_got_index (dynobj, output_bfd, h, R_MIPS_GOT16, info);
d8843 1
a8843 1
      e.d.h = (struct mips_elf_link_hash_entry *)h;
d8959 2
a8960 1
  /* If this is a mips16 symbol, force the value to be even.  */
d8962 4
a8965 1
    sym->st_value &= ~1;
d10193 2
@


1.234
log
@bfd/
	* elfxx-mips.c (mips_elf_calculate_relocation): Calculate GP and GP0
	for all relocation types.  Allow any type of relocation to refer to
	__gnu_local_gp.

ld/testsuite/
	* ld-mips-elf/no-shared-1-o32.s,
	ld-mips-elf/no-shared-1-o32.d,
	ld-mips-elf/no-shared-1-n32.d,
	ld-mips-elf/no-shared-1-n64.s,
	ld-mips-elf/no-shared-1-n64.d,
	ld-mips-elf/no-shared-1.ld: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d4512 3
d7014 1
a7014 1
	      if (info->shared)
d7029 11
a7039 2
		  /* We only need to copy this reloc if the symbol is
                     defined in a dynamic object.  */
d7304 60
a7389 3
  /* If this symbol is defined in a dynamic object, we need to copy
     any R_MIPS_32 or R_MIPS_REL32 relocs against it into the output
     file.  */
a7390 12
  if (! info->relocatable
      && hmips->possibly_dynamic_relocs != 0
      && (h->root.type == bfd_link_hash_defweak
	  || !h->def_regular))
    {
      mips_elf_allocate_dynamic_relocations
	(dynobj, info, hmips->possibly_dynamic_relocs);
      if (hmips->readonly_reloc)
	/* We tell the dynamic linker that there are relocations
	   against the text segment.  */
	info->flags |= DF_TEXTREL;
    }
d7784 3
@


1.233
log
@include/elf/
	* mips.h (ELF_ST_IS_MIPS16, ELF_ST_SET_MIPS16): New macros.

bfd/
	* elfxx-mips.c (mips_elf_check_mips16_stubs): Use ELF_ST_IS_MIPS16.
	(mips_elf_calculate_relocation): Likewise.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.

opcodes/
	* mips-dis.c (_print_insn_mips): Use ELF_ST_IS_MIPS16.

gas/
	* config/tc-mips.c (mips16_mark_labels): Use ELF_ST_SET_MIPS16.
	(mips_fix_adjustable): Likewise.
	(mips_frob_file_after_relocs): Likewise.

gas/testsuite/
	* gas/mips/mips16-vis-1.d, gas/mips/mips16-vis-1.s: New tests.
	* gas/mips/mips.exp: Run them.
@
text
@d4102 1
a4102 1
  bfd_vma gp = MINUS_ONE;
d4107 1
a4107 1
  bfd_vma gp0 = MINUS_ONE;
d4370 11
a4380 2
  /* If we haven't already determined the GOT offset, or the GP value,
     and we're going to need it, get it now.  */
a4460 18

    case R_MIPS_HI16:
    case R_MIPS_LO16:
    case R_MIPS_GPREL16:
    case R_MIPS_GPREL32:
    case R_MIPS_LITERAL:
    case R_MIPS16_HI16:
    case R_MIPS16_LO16:
    case R_MIPS16_GPREL:
      gp0 = _bfd_get_gp_value (input_bfd);
      gp = _bfd_get_gp_value (abfd);
      if (dynobj)
	gp += mips_elf_adjust_gp (abfd, mips_elf_got_info (dynobj, NULL),
				  input_bfd);
      break;

    default:
      break;
a4462 3
  if (gnu_local_gp_p)
    symbol = gp;

@


1.232
log
@(_bfd_mips_elf_section_from_shdr): Add missing
paren.
@
text
@d1175 1
a1175 1
      && h->root.other == STO_MIPS16)
d1187 1
a1187 1
      && h->root.other == STO_MIPS16)
d4185 1
a4185 1
      if (sym->st_other == STO_MIPS16)
d4195 1
a4195 1
      target_is_16_bit_code_p = (sym->st_other == STO_MIPS16);
d4291 1
a4291 1
      target_is_16_bit_code_p = (h->root.other == STO_MIPS16);
d6124 1
a6124 1
  if (sym->st_other == STO_MIPS16)
d6147 1
a6147 1
  if (sym->st_other == STO_MIPS16)
d8724 1
a8724 1
  if (sym->st_other == STO_MIPS16)
d8896 1
a8896 1
  if (sym->st_other == STO_MIPS16)
@


1.231
log
@bfd/
	* Makefile.am (BFD32_LIBS): Add compress.lo.
	(BFD32_LIBS_CFILES): Add compress.c.
	(BFD_H_FILES): Likewise.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf2.c (read_section): New function.
	(read_indirect_string): Call new function read_section.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Call new function read_section when just one
	.zdebug_info section is found, otherwise read and compress
	multiple sections.
	(_bfd_dwarf2_cleanup_debug_info): Free sec_info_ptr.
	* elf.c (_bfd_elf_make_section_from_shdr): Add zdebug prefix.
	(special_sections_z): New struct.
	(special_sections): Refer to special_sections_z.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Recognize
	sections named .zdebug_*.
	(_bfd_mips_elf_fake_sections): Likewise.
	* compress.c: New file.
	(bfd_uncompress_section_contents): New function.
bfd/doc/
	* Makefile.am (BFD_H_DEP): Add ../compress.c.
	* Makefile.in: Regenerate.
binutils/
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf.c (debug_displays): Add .zdebug_* strings.
	* dwarf.h (struct dwarf_section): Add fields uncompressed_namd
	and compressed_name.
	* objdump.c (load_debug_section): Call
	bfd_uncompress_section_contents when loading a compressed
	section.
	(dump_dwarf_section): Recognize compressed section name.
	(mach_o_dwarf_sections): Rename as
	mach_o_uncompressed_dwarf_sections.
	(mach_o_compressed_dwarf_sections): New variable.
	(generic_dwarf_section): Rename as
	generic_uncompressed_dwarf_sections.
	(generic_compressed_dwarf_sections): New variable.
	(check_mach_o_dwarf): Save and restore
	mach_o_compressed_dwarf_sections.
	* readelf.c: Add #include for config.h and zlib.h
	(process_section_headers): Recognize compressed section name.
	(uncompress_section_contents): New function.
	(load_debug_section): Call uncompress_section_contents when
	loading a compressed section.
	(display_debug_section): Recognize compressed section name.
binutils/testsuite:
	* binutils-all/objdump.exp: Add test for objdump -s on a file
	with a compressed debug section.  Add test for objdump -W on a
	file that contains a compressed debug section.
	* binutils-all/readelf.exp: Call readelf_compressed_wa_test.
	(readelf_compressed_wa_test): New function.
	* binutils-all/dw2-compressed.S: New file.
	* binutils-all/objdump.W: New file.
	* binutils-all/objdump.s: New file.
	* binutils-all/readelf.wa: New file.
@
text
@d5705 1
a5705 1
          && ! CONST_STRNEQ (name, ".zdebug_")
@


1.230
log
@bfd/
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Don't
	set the value of undefined symbols in shared objects.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Clear value for
	undefined symbols unless pointer equality is needed.
ld/testsuite/
	* ld-vxworks/plt-mips1.s: New.
	* ld-vxworks/plt-mips1.d: New.
@
text
@d5704 2
a5705 1
      if (! CONST_STRNEQ (name, ".debug_"))
d5899 2
a5900 1
  else if (CONST_STRNEQ (name, ".debug_"))
@


1.229
log
@	* elfxx-mips.c (mips_elf_record_got_page_entry): Update comment.
	(_bfd_mips_elf_check_relocs): Update comments.  Always call
	mips_elf_record_got_page_entry for R_MIPS_GOT_PAGE.
@
text
@d7469 4
a7472 4
	 symbol's value to the address of the stub.  For executables,
	 point at the PLT load stub rather than the lazy resolution stub;
	 this stub will become the canonical function address.  */
      if (!h->def_regular)
d7476 1
a7476 2
	  if (!info->shared)
	    h->root.u.def.value += 8;
@


1.228
log
@bfd/
	* elfxx-mips.c (MIPS_ELF_GNU_GOT1_MASK): New macro.
	(_bfd_mips_elf_finish_dynamic_sections): Use it instead of 0x80000000.

ld/testsuite/
	* ld-mips-elf/elf-rel-got-n64-linux.d: Expect bit 63 rather than
	bit 31 of the second GOT entry to be set.
	* ld-mips-elf/elf-rel-got-n64.d: Likewise.
	* ld-mips-elf/elf-rel-xgot-n64-linux.d: Likewise.
	* ld-mips-elf/elf-rel-xgot-n64.d: Likewise.
@
text
@d3016 5
a3020 2
/* Record that ABFD has a page relocation against symbol SYMNDX and that
   ADDEND is the addend for that relocation.  G is the GOT information.  */
d6921 1
d6932 1
a6932 1
	  if (!h)
d6934 4
a6937 1
	      /* This relocation needs a page entry in the GOT.  */
@


1.227
log
@        * elf.c ( _bfd_elf_print_private_bfd_data): Call
        elf_backend_get_target_dtag if defined.
        * elf32-mips.c (elf_backend_get_target_dtag): Define.
        * elf64-mips.c: Likewise.
        * elfn32-mips.c: Likewise.
        * elfxx-mips.c (_bfd_mips_elf_get_target_dtag): New.
        * elfxx-mips.h (_bfd_mips_elf_get_target_dtag): Declare.
        * elf-bfd.h (elf_backend_get_target_dtag): Add prototype.
        * elfxx-target.h (elf_backend_get_target_dtag): Add default.
        (elf_backend_data): Add elf_backend_get_target_dtag.
@
text
@d651 6
d9239 1
a9239 1
	  MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000,
d9263 2
a9264 1
	  MIPS_ELF_PUT_WORD (output_bfd, 0x80000000, sgot->contents
@


1.226
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d11703 95
@


1.225
log
@	* archures.c: Update copyright.
	(bfd_mach_mips_octeon): New macro.
	* bfd-in2.h: Regenerate.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle Octeon.
	(mips_set_isa_flags): Likewise.
	(mips_mach_extensions): Add Octeon.
	* cpu-mips.c: Update copyright.
	(I_mipsocteon): New enum constant.
	(arch_info_struct): Add Octeon.
@
text
@d6086 1
a6086 1
      && info->hash->creator == abfd->xvec
@


1.224
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d5230 3
d9486 4
d11225 3
@


1.223
log
@	bfd/
	* archures.c (bfd_mach_mips_loongson_2e): New.
	(bfd_mach_mips_loongson_2f): New.
	* bfd-in2.h (bfd_mach_mips_loongson_2e): New.
	(bfd_mach_mips_loongson_2f): New.
	* cpu-mips.c: Add I_loongson_2e and I_loongson_2f to
	anonymous enum.
	(arch_info_struct): Add Loongson-2E and Loongson-2F entries.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle Loongson-2E
	and Loongson-2F flags.
	(mips_set_isa_flags): Likewise.
	(mips_mach_extensions): Add Loongson-2E and Loongson-2F
	entries.

	binutils/
	* readelf.c (get_machine_flags): Handle Loongson-2E and -2F
	flags.

	gas/
	* config/tc-mips.c (mips_cpu_info_table): Add loongson2e
	and loongson2f entries.
	* doc/c-mips.texi: Document -march=loongson{2e,2f} options.

	gas/testsuite/
	* gas/mips/mips.exp: Add loongson-2e and -2f tests.
	* gas/mips/loongson-2e.d: New.
	* gas/mips/loongson-2e.s: New.
	* gas/mips/loongson-2f.d: New.
	* gas/mips/loongson-2f.s: New.

	include/elf/
	* mips.h (E_MIPS_MACH_LS2E): New.
	(E_MIPS_MACH_LS2F): New.

	include/opcode/
	* mips.h (INSN_LOONGSON_2E): New.
	(INSN_LOONGSON_2F): New.
	(CPU_LOONGSON_2E): New.
	(CPU_LOONGSON_2F): New.
	(OPCODE_IS_MEMBER): Update for Loongson-2E and -2F flags.

	opcodes/
	* mips-dis.c (mips_arch_choices): Add Loongson-2E and -2F
	entries.
	* mips-opc.c (IL2E): New.
	(IL2F): New.
	(mips_builtin_opcodes): Add Loongson-2E and -2F instructions.
	Allow movz and movn for Loongson-2E and -2F.  Add movnz entry.
	Move coprocessor encodings to the end of the table.  Allow
	certain MIPS V .ps instructions on the Loongson-2E and -2F.
@
text
@d9920 3
@


1.222
log
@	[ld/testsuite/ChangeLog]
	* ld-mips-elf/attr-gnu-4-14.d, ld-mips-elf/attr-gnu-4-41.d:
	Adjust warning message for -mfp64 flag.
	* ld-mips-elf/attr-gnu-4-5.s, ld-mips-elf/attr-gnu-4-04.d,
	ld-mips-elf/attr-gnu-4-51.d, ld-mips-elf/attr-gnu-4-05.d,
	ld-mips-elf/attr-gnu-4-15.d, ld-mips-elf/attr-gnu-4-24.d,
	ld-mips-elf/attr-gnu-4-25.d, ld-mips-elf/attr-gnu-4-34.d,
	ld-mips-elf/attr-gnu-4-35.d, ld-mips-elf/attr-gnu-4-42.d,
	ld-mips-elf/attr-gnu-4-43.d, ld-mips-elf/attr-gnu-4-44.d,
	ld-mips-elf/attr-gnu-4-45.d, ld-mips-elf/attr-gnu-4-40.d,
	ld-mips-elf/attr-gnu-4-14.d: New testcases files.
	* ld-mips-elf/mips-elf.exp: Run new testcases.

	[binutils/ChangeLog]
	* readelf.c (display_mips_gnu_attribute): Recognize -mips32r2 -mfp64
	objects.

	[include/ChangeLog]
	* elf/mips.h (Tag_GNU_MIPS_ABI_FP): Mention -mips32r2 -mfp64 variant
	in comment.

	[bfd/ChangeLog]
	* elfxx-mips.c (mips_elf_merge_obj_attributes): Handle -mips32r2
	-mfp64 attribute.

	[gas/ChangeLog]
	* doc/as.texinfo: Document the new attribute value.
@
text
@d5224 6
d9471 8
d11245 2
@


1.221
log
@bfd/
2007-09-18  Richard Sandiford  <richard@@codesourcery.com>

	* elfxx-mips.c (mips_got_page_range): New structure.
	(mips_got_page_entry): Likewise.
	(mips_got_info): Add page_gotno and got_page_entries fields.
	(mips_elf_got_per_bfd_arg): Add max_pages field.  Delete
	primary_count and current_count fields.
	(mips_got_page_entry_hash, mips_got_page_entry_eq): New functions.
	(mips_elf_pages_for_range, mips_elf_record_got_page_entry): Likewise.
	(mips_elf_get_got_for_bfd): New function, split out from
	mips_elf_make_got_per_bfd.  Initialize the page_gotno and
	got_page_entries fields when creating a new GOT structure.
	(mips_elf_make_got_pages_per_bfd): New function.
	(mips_elf_merge_got_with): New function, split out from
	mips_elf_make_got_per_bfd.  Merge page entries as well as
	non-page entries.  Use the minimum of max_pages and the sum
	of the page_gotnos to estimate the number of page entries.
	(mips_elf_merge_gots): Use the minimum of max_pages and the
	bfd's page_gotno to estimate the number of page entries.
	Use the above functions.
	(mips_elf_multi_got): Add page entries as well as non-page entries
	to the individual per-bfd GOTs.  Initialize got_per_bfd_arg.max_pages.
	Initialize the page_gotno and got_page_entries fields when creating
	a new primary GOT.  Use the minimum of pages and page_gotno when
	adding the number of pages entries to local_gotno.
	(mips_elf_create_got_section): Initialize the page_gotno and
	got_page_entries fields of the GOT structure.
	(mips_elf_rel_relocation_p, mips_elf_read_rel_addend)
	(mips_elf_add_lo16_rel_addend, mips_elf_get_section_contents): New
	functions, split out from...
	(_bfd_mips_elf_relocate_section): ...here.
	(_bfd_mips_elf_check_relocs): Record GOT page entries too.
	(_bfd_mips_relax_section): Use mips_elf_get_section_contents.
	(_bfd_mips_elf_always_size_sections): Use the smaller of the
	loadable_size- and page_gotno-derived estimates.

ld/testsuite/
2007-09-18  Richard Sandiford  <richard@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* ld-mips-elf/got-page-1.d, ld-mips-elf/got-page-1.s,
	* ld-mips-elf/got-page-2.d, ld-mips-elf/got-page-2.s,
	* ld-mips-elf/got-page-3.d, ld-mips-elf/got-page-3a.s,
	* ld-mips-elf/got-page-3b.s, ld-mips-elf/got-page-3c.s,
	* ld-mips-elf/got-page-1.ld: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
	* ld-mips-elf/multi-got-1.d, ld-mips-elf/multi-got-no-shared.d,
	* ld-mips-elf/tls-hidden2-got.d, ld-mips-elf/tls-hidden2.d,
	* ld-mips-elf/tls-hidden3.d, ld-mips-elf/tls-hidden3.got,
	* ld-mips-elf/tls-hidden3.r, ld-mips-elf/tls-hidden4.got,
	* ld-mips-elf/tls-hidden4.r, ld-mips-elf/tls-multi-got-1.d,
	* ld-mips-elf/tls-multi-got-1.got, ld-mips-elf/tls-multi-got-1.r,
	* ld-mips-elf/tlsbin-o32.d, ld-mips-elf/tlsbin-o32.got,
	* ld-mips-elf/tlsdyn-o32-1.d, ld-mips-elf/tlsdyn-o32-1.got,
	* ld-mips-elf/tlsdyn-o32-2.d, ld-mips-elf/tlsdyn-o32-2.got,
	* ld-mips-elf/tlsdyn-o32-3.d, ld-mips-elf/tlsdyn-o32-3.got,
	* ld-mips-elf/tlsdyn-o32.d, ld-mips-elf/tlsdyn-o32.got,
	* ld-mips-elf/tlslib-o32-hidden.got, ld-mips-elf/tlslib-o32-ver.got,
	* ld-mips-elf/tlslib-o32.d, ld-mips-elf/tlslib-o32.got: Update for
	GOT allocation changes.
@
text
@d11328 1
a11328 1
      else if (in_attr[Tag_GNU_MIPS_ABI_FP].i > 3)
d11332 1
a11332 1
      else if (out_attr[Tag_GNU_MIPS_ABI_FP].i > 3)
d11354 6
d11380 6
d11396 1
d11407 26
@


1.220
log
@	* elfxx-mips.c (mips_elf_merge_obj_attributes): Prevent
	unwanted fallthroughs in case statement.
@
text
@d115 24
d153 1
a153 1
  /* The number of local .got entries.  */
d155 2
d161 2
d204 2
a205 4
  /* The number of local and global entries in the primary got.  */
  unsigned int primary_count;
  /* The number of local and global entries in the current got.  */
  unsigned int current_count;
d2068 19
d3001 98
d3140 2
a3141 3
/* Create one separate got for each bfd that has entries in the global
   got, such that we can tell how many local and global entries each
   bfd requires.  */
d3143 3
a3145 2
static int
mips_elf_make_got_per_bfd (void **entryp, void *p)
d3147 1
a3147 3
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  struct mips_elf_got_per_bfd_arg *arg = (struct mips_elf_got_per_bfd_arg *)p;
  htab_t bfd2got = arg->bfd2got;
a3148 1
  struct mips_elf_bfd2got_hash bfdgot_entry, *bfdgot;
d3151 1
a3151 3
  /* Find the got_info for this GOT entry's input bfd.  Create one if
     none exists.  */
  bfdgot_entry.bfd = entry->abfd;
d3153 1
a3153 1
  bfdgot = (struct mips_elf_bfd2got_hash *)*bfdgotp;
d3155 1
a3155 3
  if (bfdgot != NULL)
    g = bfdgot->g;
  else
d3157 2
a3158 3
      bfdgot = (struct mips_elf_bfd2got_hash *)bfd_alloc
	(arg->obfd, sizeof (struct mips_elf_bfd2got_hash));

d3160 1
a3160 4
	{
	  arg->obfd = 0;
	  return 0;
	}
d3164 2
a3165 3
      bfdgot->bfd = entry->abfd;
      bfdgot->g = g = (struct mips_got_info *)
	bfd_alloc (arg->obfd, sizeof (struct mips_got_info));
d3167 4
a3170 4
	{
	  arg->obfd = 0;
	  return 0;
	}
d3175 1
d3183 6
a3188 4
	{
	  arg->obfd = 0;
	  return 0;
	}
d3194 22
d3238 79
d3330 11
a3340 5
  unsigned int lcount = bfd2got->g->local_gotno;
  unsigned int gcount = bfd2got->g->global_gotno;
  unsigned int tcount = bfd2got->g->tls_gotno;
  unsigned int maxcnt = arg->max_count;
  bfd_boolean too_many_for_tls = FALSE;
d3346 3
a3348 1
  if (tcount > 0)
d3350 7
a3356 31
      unsigned int primary_total = lcount + tcount + arg->global_count;
      if (primary_total > maxcnt)
	too_many_for_tls = TRUE;
    }

  /* If we don't have a primary GOT and this is not too big, use it as
     a starting point for the primary GOT.  */
  if (! arg->primary && lcount + gcount + tcount <= maxcnt
      && ! too_many_for_tls)
    {
      arg->primary = bfd2got->g;
      arg->primary_count = lcount + gcount;
    }
  /* If it looks like we can merge this bfd's entries with those of
     the primary, merge them.  The heuristics is conservative, but we
     don't have to squeeze it too hard.  */
  else if (arg->primary && ! too_many_for_tls
	   && (arg->primary_count + lcount + gcount + tcount) <= maxcnt)
    {
      struct mips_got_info *g = bfd2got->g;
      int old_lcount = arg->primary->local_gotno;
      int old_gcount = arg->primary->global_gotno;
      int old_tcount = arg->primary->tls_gotno;

      bfd2got->g = arg->primary;

      htab_traverse (g->got_entries,
		     mips_elf_make_got_per_bfd,
		     arg);
      if (arg->obfd == NULL)
	return 0;
d3358 5
a3362 8
      htab_delete (g->got_entries);
      /* We don't have to worry about releasing memory of the actual
	 got entries, since they're all in the master got_entries hash
	 table anyway.  */

      BFD_ASSERT (old_lcount + lcount >= arg->primary->local_gotno);
      BFD_ASSERT (old_gcount + gcount >= arg->primary->global_gotno);
      BFD_ASSERT (old_tcount + tcount >= arg->primary->tls_gotno);
a3363 3
      arg->primary_count = arg->primary->local_gotno
	+ arg->primary->global_gotno + arg->primary->tls_gotno;
    }
d3365 1
a3365 2
  else if (arg->current
	   && arg->current_count + lcount + gcount + tcount <= maxcnt)
d3367 4
a3370 14
      struct mips_got_info *g = bfd2got->g;
      int old_lcount = arg->current->local_gotno;
      int old_gcount = arg->current->global_gotno;
      int old_tcount = arg->current->tls_gotno;

      bfd2got->g = arg->current;

      htab_traverse (g->got_entries,
		     mips_elf_make_got_per_bfd,
		     arg);
      if (arg->obfd == NULL)
	return 0;

      htab_delete (g->got_entries);
a3371 7
      BFD_ASSERT (old_lcount + lcount >= arg->current->local_gotno);
      BFD_ASSERT (old_gcount + gcount >= arg->current->global_gotno);
      BFD_ASSERT (old_tcount + tcount >= arg->current->tls_gotno);

      arg->current_count = arg->current->local_gotno
	+ arg->current->global_gotno + arg->current->tls_gotno;
    }
d3375 2
a3376 7
  else
    {
      bfd2got->g->next = arg->current;
      arg->current = bfd2got->g;

      arg->current_count = lcount + gcount + 2 * tcount;
    }
d3611 6
a3618 3
  /* Taking out PAGES entries is a worst-case estimate.  We could
     compute the maximum number of pages that each separate input bfd
     uses, but it's probably not worth it.  */
d3621 2
a3622 1
			       - MIPS_RESERVED_GOTNO (info) - pages);
d3646 1
d3656 5
d3765 2
a3766 1
      g->local_gotno += assign + pages;
d4018 1
d4027 4
d6330 121
d6470 3
d6737 1
d6893 1
a6893 3
	  if (h == NULL)
	    break;
	  else
d6906 1
a6906 1
		break;
d6913 24
d7241 2
a7242 11
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
		goto relax_return;
	    }
	}
d7557 1
a7557 1
  bfd_size_type local_gotno;
d7638 1
a7638 1
    local_gotno = 0;
d7642 6
a7647 1
    local_gotno = (loadable_size >> 16) + 5;
d7649 1
a7649 1
  g->local_gotno += local_gotno;
d7673 1
a7673 1
      if (! mips_elf_multi_got (output_bfd, info, g, s, local_gotno))
a8169 2
	  Elf_Internal_Shdr *rel_hdr;

d8173 3
a8175 8
	     RELA relocation.  To determine which flavor or relocation
	     this is, we depend on the fact that the INPUT_SECTION's
	     REL_HDR is read before its REL_HDR2.  */
	  rel_hdr = &elf_section_data (input_section)->rel_hdr;
	  if ((size_t) (rel - relocs)
	      >= (NUM_SHDR_ENTRIES (rel_hdr) * bed->s->int_rels_per_ext_rel))
	    rel_hdr = elf_section_data (input_section)->rel_hdr2;
	  if (rel_hdr->sh_entsize == MIPS_ELF_REL_SIZE (input_bfd))
a8176 3
	      bfd_byte *location = contents + rel->r_offset;

	      /* Note that this is a REL relocation.  */
d8178 4
a8181 15

	      /* Get the addend, which is stored in the input file.  */
	      _bfd_mips16_elf_reloc_unshuffle (input_bfd, r_type, FALSE,
					       location);
	      addend = mips_elf_obtain_contents (howto, rel, input_bfd,
						 contents);
	      _bfd_mips16_elf_reloc_shuffle(input_bfd, r_type, FALSE,
					    location);

	      addend &= howto->src_mask;

	      /* For some kinds of relocations, the ADDEND is a
		 combination of the addend stored in two different
		 relocations.   */
	      if (r_type == R_MIPS_HI16 || r_type == R_MIPS16_HI16
d8186 2
a8187 34
		  const Elf_Internal_Rela *lo16_relocation;
		  reloc_howto_type *lo16_howto;
		  int lo16_type;

		  if (r_type == R_MIPS16_HI16)
		    lo16_type = R_MIPS16_LO16;
		  else
		    lo16_type = R_MIPS_LO16;

		  /* The combined value is the sum of the HI16 addend,
		     left-shifted by sixteen bits, and the LO16
		     addend, sign extended.  (Usually, the code does
		     a `lui' of the HI16 value, and then an `addiu' of
		     the LO16 value.)

		     Scan ahead to find a matching LO16 relocation.

		     According to the MIPS ELF ABI, the R_MIPS_LO16
		     relocation must be immediately following.
		     However, for the IRIX6 ABI, the next relocation
		     may be a composed relocation consisting of
		     several relocations for the same address.  In
		     that case, the R_MIPS_LO16 relocation may occur
		     as one of these.  We permit a similar extension
		     in general, as that is useful for GCC.

		     In some cases GCC dead code elimination removes
		     the LO16 but keeps the corresponding HI16.  This
		     is strictly speaking a violation of the ABI but
		     not immediately harmful.  */
		  lo16_relocation = mips_elf_next_relocation (input_bfd,
							      lo16_type,
							      rel, relend);
		  if (lo16_relocation == NULL)
a8201 26
		  else
		    {
		      bfd_byte *lo16_location;
		      bfd_vma l;

		      lo16_location = contents + lo16_relocation->r_offset;

		      /* Obtain the addend kept there.  */
		      lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd,
							    lo16_type, FALSE);
		      _bfd_mips16_elf_reloc_unshuffle (input_bfd, lo16_type,
						       FALSE, lo16_location);
		      l = mips_elf_obtain_contents (lo16_howto,
						    lo16_relocation,
						    input_bfd, contents);
		      _bfd_mips16_elf_reloc_shuffle (input_bfd, lo16_type,
						     FALSE, lo16_location);
		      l &= lo16_howto->src_mask;
		      l <<= lo16_howto->rightshift;
		      l = _bfd_mips_elf_sign_extend (l, 16);

		      addend <<= 16;

		      /* Compute the combined addend.  */
		      addend += l;
		    }
@


1.219
log
@	include/elf/
	* vxworks.h: New.

	bfd/
	* elf-vxworks.h (elf_vxworks_add_dynamic_entries): Declare.
	(elf_vxworks_finish_dynamic_entry): Declare.
	* elf-vxworks.c: Include elf/vxworks.h.
	(elf_vxworks_add_dynamic_entries): New.
	(elf_vxworks_finish_dynamic_entry): New.
	* Makefile.am (elf-vxworks.lo): Add dependency.
	* Makefile.in (elf-vxworks.lo): Add dependency.
	* elf32-i386.c (elf_i386_size_dynamic_sections,
	elf_i386_finish_dynamic_sections): Call
	elf_vxworks_add_dynamic_entries and
	elf_vxworks_finish_dynamic_entry.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections,
	sparc_finish_dyn): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections,
	sh_elf_finish_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elf32-arm.c (elf32_arm_size_dynamic_sections,
	elf32_arm_finish_dynamic_sections): Likewise.

	ld/
	* ld-vxworks/tls-2.d: New.
	* ld-vxworks/tls-2.s: New.
@
text
@d11076 1
d11096 1
@


1.218
log
@* bfd/elfxx-mips.c (_bfd_mips_elf_fake_sections): Force SHF_MIPS_NOSTRIP on
   .debug_frame for Irix.
@
text
@d7677 3
d8907 3
@


1.217
log
@	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Do not add
	PT_NULL header when not linking.
@
text
@d5675 9
a5683 1
    hdr->sh_type = SHT_MIPS_DWARF;
@


1.216
log
@	* elfxx-mips.c (mips_elf_sort_hash_table_f): Handle forced
	local symbols specially.
	(mips_elf_set_global_got_offset): Skip forced local symbols.
@
text
@d9333 1
a9333 1
				  struct bfd_link_info *info ATTRIBUTE_UNUSED)
d9558 6
a9563 2
     extension.  */
  if (!SGI_COMPAT (abfd)
@


1.215
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d2800 2
a2801 1
     -1.  */
d2810 1
a2810 1
  else if (h->root.got.offset != 1)
d3273 1
@


1.214
log
@	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Make sure .got
	will be output.
@
text
@d6712 3
a6714 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
@


1.213
log
@bfd/
	* elfxx-mips.c (mips_elf_link_hash_table): Add computed_got_sizes.
	(mips_elf_record_global_got_symbol): Increment local_gotno for
	each forced-local symbol.
	(_bfd_mips_elf_check_relocs): Pass forced-local call symbols to
	mips_elf_record_global_got_symbol for VxWorks too.
	(_bfd_mips_elf_always_size_sections): Set computed_got_sizes
	to true after computing the GOT size.
	(_bfd_mips_elf_hide_symbol): Increase local_gotno whenever
	got.offset == 1.  Only adjust global_gotno if computed_got_sizes.
	For VxWorks, add a local entry when hiding a symbol that needs a
	plt but has not been marked as needing a global got entry.
	(_bfd_mips_elf_link_hash_table_create): Set computed_got_sizes to
	false.

ld/testsuite/
	* ld-mips-elf/vxworks-forced-local-1.d,
	* ld-mips-elf/vxworks-forced-local-1.s,
	* ld-mips-elf/vxworks-forced-local-1.ver: New test.
	* ld-mips-elf/mips-elf.exp: Run it.
	* ld-mips-elf/tlsdyn-o32-2.d: Adjust for removal of unnecessary
	local GOT entry.
	* ld-mips-elf/tlsdyn-o32-2.got: Likewise.
	* ld-mips-elf/tlsdyn-o32-3.d: Likewise.
	* ld-mips-elf/tlsdyn-o32-3.got: Likewise.
	* ld-mips-elf/vxworks1-lib.dd: Likewise.
	* ld-mips-elf/vxworks1-lib.rd: Likewise.
@
text
@d8911 2
a8912 1
  if (sgot != NULL && sgot->size > 0)
@


1.212
log
@	* elfxx-mips.c (struct mips_elf_link_hash_table): Add new field
	small_data_overflow_reported.
	(_bfd_mips_elf_link_hash_table_create): Initialize it.
	(_bfd_mips_elf_relocate_section) <bfd_reloc_overflow>: Report
	small-data section overflow.
@
text
@d326 2
d2696 1
a2696 1
  if (g->assigned_gotno >= g->local_gotno)
a2880 3
  /* By setting this to a value other than -1, we are indicating that
     there needs to be a GOT entry for H.  Avoid using zero, as the
     generic ELF copy_indirect_symbol tests for <= 0.  */
d2882 8
a2889 1
    h->got.offset = 1;
d6537 1
a6537 1
	      if (!htab->is_vxworks
d7321 1
d9681 1
d9689 1
a9726 5
      else if (g->global_gotno == 0 && g->global_gotsym == NULL)
	/* If we haven't got through GOT allocation yet, just bump up the
	   number of local entries, as this symbol won't be counted as
	   global.  */
	g->local_gotno++;
d9729 2
a9730 4
	  /* If we're past non-multi-GOT allocation and this symbol had
	     been marked for a global got entry, give it a local entry
	     instead.  */
	  BFD_ASSERT (g->global_gotno > 0);
d9732 7
a9738 1
	  g->global_gotno--;
d9740 11
d10211 1
@


1.212.2.1
log
@bfd/
	* elfxx-mips.c (mips_elf_link_hash_table): Add computed_got_sizes.
	(mips_elf_record_global_got_symbol): Increment local_gotno for
	each forced-local symbol.
	(_bfd_mips_elf_check_relocs): Pass forced-local call symbols to
	mips_elf_record_global_got_symbol for VxWorks too.
	(_bfd_mips_elf_always_size_sections): Set computed_got_sizes
	to true after computing the GOT size.
	(_bfd_mips_elf_hide_symbol): Increase local_gotno whenever
	got.offset == 1.  Only adjust global_gotno if computed_got_sizes.
	For VxWorks, add a local entry when hiding a symbol that needs a
	plt but has not been marked as needing a global got entry.
	(_bfd_mips_elf_link_hash_table_create): Set computed_got_sizes to
	false.

ld/testsuite/
	* ld-mips-elf/vxworks-forced-local-1.d,
	* ld-mips-elf/vxworks-forced-local-1.s,
	* ld-mips-elf/vxworks-forced-local-1.ver: New test.
	* ld-mips-elf/mips-elf.exp: Run it.
	* ld-mips-elf/tlsdyn-o32-2.d: Adjust for removal of unnecessary
	local GOT entry.
	* ld-mips-elf/tlsdyn-o32-2.got: Likewise.
	* ld-mips-elf/tlsdyn-o32-3.d: Likewise.
	* ld-mips-elf/tlsdyn-o32-3.got: Likewise.
	* ld-mips-elf/vxworks1-lib.dd: Likewise.
	* ld-mips-elf/vxworks1-lib.rd: Likewise.
@
text
@a325 2
  /* True if we've computed the size of the GOT.  */
  bfd_boolean computed_got_sizes;
d2694 1
a2694 1
  if (g->assigned_gotno > g->local_gotno)
d2879 3
d2883 1
a2883 8
    {
      /* By setting this to a value other than -1, we are indicating that
	 there needs to be a GOT entry for H.  Avoid using zero, as the
	 generic ELF copy_indirect_symbol tests for <= 0.  */
      h->got.offset = 1;
      if (h->forced_local)
	g->local_gotno++;
    }
d6531 1
a6531 1
	      if ((!htab->is_vxworks || h->forced_local)
a7314 1
  htab->computed_got_sizes = TRUE;
a9673 1
  struct mips_elf_link_hash_table *htab;
a9680 1
  htab = mips_elf_hash_table (info);
d9718 5
d9725 4
a9728 2
	  /* check_relocs didn't know that this symbol would be
	     forced-local, so add an extra local got entry.  */
d9730 1
a9730 7
	  if (htab->computed_got_sizes)
	    {
	      /* We'll have treated this symbol as global rather
		 than local.  */
	      BFD_ASSERT (g->global_gotno > 0);
	      g->global_gotno--;
	    }
a9731 11
      else if (htab->is_vxworks && h->root.needs_plt)
	{
	  /* check_relocs didn't know that this symbol would be
	     forced-local, so add an extra local got entry.  */
	  g->local_gotno++;
	  if (htab->computed_got_sizes)
	    /* The symbol is only used in call relocations, so we'll
	       have assumed it only needs a .got.plt entry.  Increase
	       the size of .got accordingly.  */
	    got->size += MIPS_ELF_GOT_SIZE (dynobj);
        }
a10191 1
  ret->computed_got_sizes = FALSE;
@


1.212.2.2
log
@	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Do not add
	PT_NULL header when not linking.
@
text
@d9328 1
a9328 1
				  struct bfd_link_info *info)
d9553 2
a9554 6
     extension.

     If INFO is NULL, we may be copying an already prelinked binary
     with objcopy or strip, so do not add this header.  */
  if (info != NULL
      && !SGI_COMPAT (abfd)
@


1.212.2.3
log
@	* elfxx-mips.c (mips_elf_sort_hash_table_f): Handle forced
	local symbols specially.
	(mips_elf_set_global_got_offset): Skip forced local symbols.
@
text
@d2800 1
a2800 2
     -1.  Forced local symbols may also be marked with got offset 1,
     but are never given global GOT entries.  */
d2809 1
a2809 1
  else if (h->root.got.offset != 1 || h->forced_local)
a3271 1
      && !entry->d.h->forced_local
@


1.211
log
@Switch sources over to use the GPL version 3
@
text
@d328 2
d8037 3
d8041 11
d10193 1
@


1.210
log
@bfd:
	* elfxx-mips.c (mips_elf_calculate_relocation): Handle
	R_MIPS_TLS_DTPREL32 and R_MIPS_TLS_DTPREL64.
	* elf64-mips.c (mips_elf64_howto_table_rela): Support
	R_MIPS_TLS_DTPREL64.

gas:
	* config/tc-mips.c (s_dtprelword, s_dtpreldword,
	s_dtprel_internal): New.
	(mips_pseudo_table): Add .dtprelword and .dtpreldword.
	(md_apply_fix): Handle BFD_RELOC_MIPS_TLS_DTPREL32 and
	BFD_RELOC_MIPS_TLS_DTPREL64.
@
text
@d16 1
a16 1
   the Free Software Foundation; either version 2 of the License, or
d26 3
a28 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.209
log
@bfd:
	* elfxx-mips.c (mips_elf_merge_obj_attributes): New.
	(_bfd_mips_elf_merge_private_bfd_data): Call it.

binutils:
	* readelf.c (display_mips_gnu_attribute): New.
	(process_mips_specific): Call process_attributes.

include/elf:
	* mips.h (Tag_GNU_MIPS_ABI_FP): Define.

ld/testsuite:
	* ld-mips-elf/attr-gnu-4-0.s, ld-mips-elf/attr-gnu-4-00.d,
	ld-mips-elf/attr-gnu-4-01.d, ld-mips-elf/attr-gnu-4-02.d,
	ld-mips-elf/attr-gnu-4-03.d, ld-mips-elf/attr-gnu-4-1.s,
	ld-mips-elf/attr-gnu-4-10.d, ld-mips-elf/attr-gnu-4-11.d,
	ld-mips-elf/attr-gnu-4-12.d, ld-mips-elf/attr-gnu-4-13.d,
	ld-mips-elf/attr-gnu-4-14.d, ld-mips-elf/attr-gnu-4-2.s,
	ld-mips-elf/attr-gnu-4-20.d, ld-mips-elf/attr-gnu-4-21.d,
	ld-mips-elf/attr-gnu-4-22.d, ld-mips-elf/attr-gnu-4-23.d,
	ld-mips-elf/attr-gnu-4-3.s, ld-mips-elf/attr-gnu-4-30.d,
	ld-mips-elf/attr-gnu-4-31.d, ld-mips-elf/attr-gnu-4-32.d,
	ld-mips-elf/attr-gnu-4-33.d, ld-mips-elf/attr-gnu-4-4.s,
	ld-mips-elf/attr-gnu-4-41.d: New.
	* ld-mips-elf/mips-elf.exp: Run these new tests.
@
text
@d4358 2
@


1.208
log
@bfd/
	* elfxx-mips.c (mips_elf_calculate_relocation): Allow local stubs
	to be used for calls from MIPS16 code.

gas/
	* config/tc-mips.h (TC_SYMFIELD_TYPE): New.
	* config/tc-mips.c (append_insn): Record which symbols have
	R_MIPS16_26 relocations against them.
	(mips_fix_adjustable): Don't reduce relocations against such symbols.

ld/testsuite/
	* ld-mips-elf/mips16-local-stubs-1.s,
	* ld-mips-elf/mips16-local-stubs-1.d: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d10963 106
d11102 3
@


1.207
log
@bfd/
	* elfxx-mips.c (mips_elf_initialize_tls_index): When processing a
	type (3) single-GOT entry, read tls_type from the hash table entry
	rather than the GOT entry.
@
text
@d4095 1
a4095 2
	   && h != NULL
	   && ((h->call_stub != NULL || h->call_fp_stub != NULL)
@


1.206
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d3189 1
d3205 1
d3222 1
d3226 1
a3226 1
  if (entry->tls_type & (GOT_TLS_GD | GOT_TLS_LDM))
d3228 1
a3228 1
  if (entry->tls_type & GOT_TLS_IE)
@


1.205
log
@bfd/
	* elfxx-mips.c (mips_elf_create_local_got_entry): Remove
	input_section argument.  Create .rela.dyn relocations against
	symbol 0 rather than the section symbol.
	(mips_elf_local_got_index): Remove input_section argument.
	Update call to mips_elf_create_local_got_entry.
	(mips_elf_got_page, mips_elf_got16_entry): Likewise.
	(mips_elf_calculate_relocation): Update calls to
	mips_elf_local_got_index, mips_elf_got16_entry and mips_elf_got_page.

ld/testsuite/
	* ld-mips-elf/vxworks1-lib.rd: Expect the GOT relocation to be
	against symbol 0.
@
text
@a7020 1
  unsigned int power_of_two;
d7143 1
a7143 20
  /* We need to figure out the alignment required for this symbol.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 4)
    power_of_two = 4;

  /* Apply the required alignment.  */
  htab->sdynbss->size = BFD_ALIGN (htab->sdynbss->size,
				   (bfd_size_type) 1 << power_of_two);
  if (power_of_two > bfd_get_section_alignment (dynobj, htab->sdynbss)
      && !bfd_set_section_alignment (dynobj, htab->sdynbss, power_of_two))
    return FALSE;

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = htab->sdynbss;
  h->root.u.def.value = htab->sdynbss->size;

  /* Increment the section size to make room for the symbol.  */
  htab->sdynbss->size += h->size;

  return TRUE;
@


1.204
log
@	PR 4479
	* elf.c (elf_fake_sections): Don't allow backend to change
	SHT_NOBITS if called for strip/objcopy --only-keep-debug.
	* elfxx-mips.c (_bfd_mips_elf_fake_sections): Remove similar
	fix from here.
@
text
@d491 1
a491 1
   asection *, bfd_vma, unsigned long, struct mips_elf_link_hash_entry *, int);
d2416 1
a2416 2
/* Return the GOT offset for address VALUE, which was derived from
   a symbol belonging to INPUT_SECTION.   If there is not yet a GOT
d2423 1
a2423 2
			  asection *input_section, bfd_vma value,
			  unsigned long r_symndx,
d2433 1
a2433 2
					   input_section, value,
					   r_symndx, h, r_type);
d2534 4
a2537 5
/* Find a GOT page entry that points to within 32KB of VALUE, which was
   calculated from a symbol belonging to INPUT_SECTION.  These entries
   are supposed to be placed at small offsets in the GOT, i.e., within
   32KB of GP.  Return the index of the GOT entry, or -1 if no entry
   could be created.  If OFFSETP is nonnull, use it to return the
d2542 1
a2542 1
		   asection *input_section, bfd_vma value, bfd_vma *offsetp)
d2553 1
a2553 2
					   input_section, page, 0,
					   NULL, R_MIPS_GOT_PAGE);
d2566 1
a2566 2
/* Find a local GOT entry for an R_MIPS_GOT16 relocation against VALUE,
   which was calculated from a symbol belonging to INPUT_SECTION.
d2572 1
a2572 2
		      asection *input_section, bfd_vma value,
		      bfd_boolean external)
d2588 1
a2588 2
					   input_section, value, 0,
					   NULL, R_MIPS_GOT16);
d2621 2
a2622 2
				 asection *sgot, asection *input_section,
				 bfd_vma value, unsigned long r_symndx,
d2703 1
a2703 5
  /* These GOT entries need a dynamic relocation on VxWorks.  Because
     the offset between segments is not fixed, the relocation must be
     against a symbol in the same segment as the original symbol.
     The easiest way to do this is to take INPUT_SECTION's output
     section and emit a relocation against its section symbol.  */
d2707 1
a2707 1
      asection *s, *output_section;
a2709 1
      int dynindx;
a2711 2
      output_section = input_section->output_section;
      dynindx = elf_section_data (output_section)->dynindx;
d2718 2
a2719 2
      outrel.r_info = ELF32_R_INFO (dynindx, R_MIPS_32);
      outrel.r_addend = value - output_section->vma;
d4168 1
a4168 1
					sec, 0, 0, NULL, r_type);
d4214 1
a4214 1
	  g = mips_elf_local_got_index (abfd, input_bfd, info, sec,
d4465 1
a4465 1
	  value = mips_elf_got16_entry (abfd, input_bfd, info, sec,
d4521 1
a4521 2
      value = mips_elf_got_page (abfd, input_bfd, info, sec,
				 symbol + addend, NULL);
d4530 1
a4530 2
	mips_elf_got_page (abfd, input_bfd, info, sec,
			   symbol + addend, &value);
@


1.203
log
@	* elfxx-mips.c (mips_elf_create_dynamic_relocation): Don't access
	memory which we might not own.
@
text
@d5596 1
a5596 5
  register const char *name;
  unsigned int sh_type;

  name = bfd_get_section_name (abfd, sec);
  sh_type = hdr->sh_type;
a5696 6
  /* In the unlikely event a special section is empty it has to lose its
     special meaning.  This may happen e.g. when using `strip' with the
     "--only-keep-debug" option.  */
  if (sec->size > 0 && !(sec->flags & SEC_HAS_CONTENTS))
    hdr->sh_type = sh_type;

@


1.202
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d4789 7
a4795 4
  outrel[1].r_offset =
    _bfd_elf_section_offset (output_bfd, info, input_section, rel[1].r_offset);
  outrel[2].r_offset =
    _bfd_elf_section_offset (output_bfd, info, input_section, rel[2].r_offset);
@


1.201
log
@	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Put
	DT_MIPS_RLD_MAP before DT_DEBUG again.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d30 1
a31 1
#include "sysdep.h"
@


1.200
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Don't add
	DT_MIPS_RTLD_MAP for PIEs.
@
text
@d7587 1
a7587 6
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (info->executable
	  && !SGI_COMPAT (output_bfd)
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
	return FALSE;
d7590 3
a7592 1
	 DT_MIPS_RLD_MAP entry.  */
d7597 7
@


1.199
log
@bfd/
	* elfxx-mips.c (mips_elf_calculate_relocation): Set DT_TEXTREL
	when creating a __GOTT_BASE__ or __GOTT_INDEX__ relocation
	in a read-only section.
	(_bfd_mips_elf_check_relocs): Likewise.

ld/testsuite/
	* ld-mips-elf/vxworks1-lib.td: New test.
	* ld-mips-elf/mips-elf.exp: Run it.
@
text
@d7589 10
a7598 12
      if (info->executable)
	{
	  /* SGI object has the equivalence of DT_DEBUG in the
	     DT_MIPS_RLD_MAP entry.  */
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_MAP, 0))
	    return FALSE;
	  if (!SGI_COMPAT (output_bfd))
	    {
	      if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
		return FALSE;
	    }
	}
@


1.198
log
@	* elfxx-mips.c (mips_elf_next_relocation): Don't signal an error if no
	matching relocation is found.
	(_bfd_mips_elf_relocate_section): Only warn about missing relocations.
@
text
@d4278 7
d6503 4
@


1.197
log
@2003-03-19  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4208
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Report missing
	matching LO16 relocation for HI16 relocation.
@
text
@a3617 1
  bfd_set_error (bfd_error_bad_value);
a7858 1
		  bfd_vma l;
a7860 1
		  bfd_byte *lo16_location;
d7883 6
a7888 1
		     in general, as that is useful for GCC.  */
a7905 1
		      return FALSE;
d7907 4
d7912 1
a7912 1
		  lo16_location = contents + lo16_relocation->r_offset;
d7914 13
a7926 12
		  /* Obtain the addend kept there.  */
		  lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd,
							lo16_type, FALSE);
		  _bfd_mips16_elf_reloc_unshuffle (input_bfd, lo16_type, FALSE,
						   lo16_location);
		  l = mips_elf_obtain_contents (lo16_howto, lo16_relocation,
						input_bfd, contents);
		  _bfd_mips16_elf_reloc_shuffle (input_bfd, lo16_type, FALSE,
						 lo16_location);
		  l &= lo16_howto->src_mask;
		  l <<= lo16_howto->rightshift;
		  l = _bfd_mips_elf_sign_extend (l, 16);
d7928 1
a7928 1
		  addend <<= 16;
d7930 3
a7932 2
		  /* Compute the combined addend.  */
		  addend += l;
@


1.196
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d7759 2
d7770 1
d7772 4
a7775 1
	sec = local_sections[r_symndx];
a7777 1
	  Elf_Internal_Shdr *symtab_hdr;
a7778 1
	  struct elf_link_hash_entry *h;
a7779 1
	  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d7891 15
a7905 1
		    return FALSE;
@


1.195
log
@	* elfxx-mips.c (_bfd_mips_elf_print_private_bfd_data): Remove
	translation marker from untranslatable strings.
@
text
@a4325 5
      else if (r_symndx == 0)
	/* r_symndx will be zero only for relocs against symbols
	   from removed linkonce sections, or sections discarded by
	   a linker script.  */
	value = 0;
d7757 2
d7761 41
a7816 7
      else
	/* NewABI defaults to RELA relocations.  */
	howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, r_type,
					 NEWABI_P (input_bfd)
					 && (MIPS_RELOC_RELA_P
					     (input_bfd, input_section,
					      rel - relocs)));
@


1.194
log
@bfd/

2007-02-16  Carlos O'Donell  <carlos@@codesourcery.com>

	* elfxx-mips.c (_bfd_mips_elf_print_private_bfd_data):
	Print EF_MIPS_NOREORDER, EF_MIPS_PIC, EF_MIPS_CPIC, EF_MIPS_XGOT
	and EF_MIPS_UCODE.
@
text
@d11195 1
a11195 1
    fprintf (file, _(" [mips1]"));
d11197 1
a11197 1
    fprintf (file, _(" [mips2]"));
d11199 1
a11199 1
    fprintf (file, _(" [mips3]"));
d11201 1
a11201 1
    fprintf (file, _(" [mips4]"));
d11203 1
a11203 1
    fprintf (file, _(" [mips5]"));
d11205 1
a11205 1
    fprintf (file, _(" [mips32]"));
d11207 1
a11207 1
    fprintf (file, _(" [mips64]"));
d11209 1
a11209 1
    fprintf (file, _(" [mips32r2]"));
d11211 1
a11211 1
    fprintf (file, _(" [mips64r2]"));
d11216 1
a11216 1
    fprintf (file, _(" [mdmx]"));
d11219 1
a11219 1
    fprintf (file, _(" [mips16]"));
d11222 1
a11222 1
    fprintf (file, _(" [32bitmode]"));
d11227 1
a11227 1
    fprintf (file, _(" [noreorder]"));
d11230 1
a11230 1
    fprintf (file, _(" [PIC]"));
d11233 1
a11233 1
    fprintf (file, _(" [CPIC]"));
d11236 1
a11236 1
    fprintf (file, _(" [XGOT]"));
d11239 1
a11239 1
    fprintf (file, _(" [UCODE]"));
@


1.193
log
@	* bfd-in2.h: Regenerate.
	* bfd-in.h (bfd_arm_vfp11_fix): New enum. Specify how VFP11
	instruction scanning should be done.
	(bfd_elf32_arm_init_maps, bfd_elf32_arm_vfp11_erratum_scan)
	(bfd_elf32_arm_vfp11_fix_veneer_locations): Add prototypes.
	(bfd_elf32_arm_set_target_relocs): Add vfp11 fix type argument to
	prototype.
	* elf-bfd.h (elf_backend_write_section): Add struct bfd_link_info
	argument.
	* elf32-arm.c (VFP11_ERRATUM_VENEER_SECTION_NAME)
	(VFP11_ERRATUM_VENEER_ENTRY_NAME): Define macros.
	(elf32_vfp11_erratum_type): New enum.
	(elf32_vfp11_erratum_list): New struct. List of veneers or jumps to
	veneers.
	(_arm_elf_section_data): Add mapsize, erratumcount, erratumlist.
	(elf32_arm_link_hash_table): Add vfp11_erratum_glue_size,
	vfp11_fix and num_vfp11_fixes fields.
	(elf32_arm_link_hash_table_create): Initialise vfp11_fix,
	vfp11_erratum_glue_size, num_vfp11_fixes fields.
	(VFP11_ERRATUM_VENEER_SIZE): Define. Size of an (ARM) veneer.
	(bfd_elf32_arm_allocate_interworking_sections): Initialise erratum
	glue section.
	(elf32_arm_section_map_add): Add an code/data mapping symbol entry
	to a section's map.
	(record_vfp11_erratum_veneer): Create a single veneer, and its
	associated symbols.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Add vfp11 erratum glue.
	(bfd_elf32_arm_init_maps): Initialise mapping symbol table for input
	BFDs.
	(bfd_elf32_arm_set_vfp11_fix): Set the type of erratum workaround
	required.
	(bfd_arm_vfp11_pipe): Define VFP11 instruction pipes.
	(bfd_arm_vfp11_regno): Recode a register number from a VFP11 insn.
	(bfd_arm_vfp11_write_mask): Update write mask according to coded
	register number.
	(bfd_arm_vfp11_antidependency): New function.
	(bfd_arm_vfp11_insn_decode): Decode a VFP11 insn.
	(elf32_arm_compare_mapping): Declare.
	(bfd_elf32_arm_vfp11_erratum_scan): Scan the sections of an input
	BFD for potential erratum-triggering insns. Record results.
	(bfd_elf32_arm_vfp11_fix_veneer_locations): Find out where veneers
	and branches to veneers have been placed in virtual memory after
	layout.
	(bfd_elf32_arm_set_target_relocs): Set vfp11_fix field in global
	hash table.
	(elf32_arm_output_symbol_hook): Remove.
	(elf32_arm_write_section): Output veneers, and branches to veneers.
	Use maps from input sections, not output sections, for code
	byte-swapping.
	* elf32-ppc.c (ppc_elf_write_section): Add dummy link_info argument.
	* elf32-score.c (_bfd_score_elf_write_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_write_section): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_write_section): Likewise.
@
text
@d11226 15
@


1.192
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d9761 3
a9763 2
_bfd_mips_elf_write_section (bfd *output_bfd, asection *sec,
			     bfd_byte *contents)
@


1.191
log
@	[ bfd/ChangeLog ]
	* elf-bfd.h (local_call_stubs): New member.
	* elfxx-mips.c (FN_STUB_P, CALL_STUB_P, CALL_FP_STUB_P): New macros.
	(mips_elf_calculate_relocation): Handle local mips16 call stubs.
	(mips16_stub_section_p): Rename from mips_elf_stub_section_p, use
	the new stub macros.
	(_bfd_mips_elf_check_relocs): Handle call stubs for code which
	mixes mips16 and mips32 functions. Use mips16_stub_section_p. Mark
	used stubs with SEC_KEEP. Use the new stub macros.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/mips16-intermix.d, gas/mips/mips16-intermix.s: New
	testcase.
	* gas/mips/mips.exp: Run new testcase.

	[ ld/testsuite/ChangeLog ]
	* ld-mips-elf/mips16-intermix-1.s, ld-mips-elf/mips16-intermix-2.s,
	ld-mips-elf/mips16-intermix.d: New testcase.
	* ld-mips-elf/mips-elf.exp (mips16_intermix_test): Run new testcases.
@
text
@d4326 5
@


1.190
log
@	* elfxx-mips.c (mips_elf_merge_gots): Always use maxcnt.
@
text
@d496 1
a496 1
static bfd_boolean mips_elf_stub_section_p
d712 4
d4085 2
a4086 1
	  || (local_p && elf_tdata (input_bfd)->local_stubs != NULL
d4088 1
a4088 1
      && !mips_elf_stub_section_p (input_bfd, input_section))
d4109 4
a4112 1
	   && (h->call_stub != NULL || h->call_fp_stub != NULL)
d4115 3
a4117 4
      /* If both call_stub and call_fp_stub are defined, we can figure
	 out which one to use by seeing which one appears in the input
	 file.  */
      if (h->call_stub != NULL && h->call_fp_stub != NULL)
d4119 9
a4127 7
	  asection *o;

	  sec = NULL;
	  for (o = input_bfd->sections; o != NULL; o = o->next)
	    {
	      if (CONST_STRNEQ (bfd_get_section_name (input_bfd, o),
				CALL_FP_STUB))
d4129 5
a4133 2
		  sec = h->call_fp_stub;
		  break;
d4135 2
d4138 1
a4138 1
	  if (sec == NULL)
d4140 3
a4142 5
	}
      else if (h->call_stub != NULL)
	sec = h->call_stub;
      else
	sec = h->call_fp_stub;
d4717 1
a4717 1
mips_elf_stub_section_p (bfd *abfd ATTRIBUTE_UNUSED, asection *section)
d4721 1
a4721 3
  return (CONST_STRNEQ (name, FN_STUB)
	  || CONST_STRNEQ (name, CALL_STUB)
	  || CONST_STRNEQ (name, CALL_FP_STUB));
d6150 1
a6150 1
  if (CONST_STRNEQ (name, FN_STUB))
d6175 1
a6175 3
		  || CONST_STRNEQ (bfd_get_section_name (abfd, o), FN_STUB)
		  || CONST_STRNEQ (bfd_get_section_name (abfd, o), CALL_STUB)
		  || CONST_STRNEQ (bfd_get_section_name (abfd, o), CALL_FP_STUB))
d6227 1
d6248 12
d6264 1
a6264 2
  else if (CONST_STRNEQ (name, CALL_STUB)
	   || CONST_STRNEQ (name, CALL_FP_STUB))
d6278 53
a6330 9
	  /* This stub was actually built for a static symbol defined
	     in the same file.  We assume that all static symbols in
	     mips16 code are themselves mips16, so we can simply
	     discard this stub.  Since this function is called before
	     the linker maps input sections to output sections, we can
	     easily discard it by setting the SEC_EXCLUDE flag.  */
	  sec->flags |= SEC_EXCLUDE;
	  return TRUE;
	}
d6332 10
a6341 2
      h = ((struct mips_elf_link_hash_entry *)
	   sym_hashes[r_symndx - extsymoff]);
d6343 2
a6344 1
      /* H is the symbol this stub is for.  */
d6346 5
a6350 2
      if (CONST_STRNEQ (name, CALL_FP_STUB))
	loc = &h->call_fp_stub;
d6352 21
a6372 1
	loc = &h->call_stub;
d6374 3
a6376 12
      /* If we already have an appropriate stub for this function, we
	 don't need another one, so we can discard this one.  Since
	 this function is called before the linker maps input sections
	 to output sections, we can easily discard it by setting the
	 SEC_EXCLUDE flag.  We can also discard this section if we
	 happen to already know that this is a mips16 function; it is
	 not necessary to check this here, as it is checked later, but
	 it is slightly faster to check now.  */
      if (*loc != NULL || h->root.other == STO_MIPS16)
	{
	  sec->flags |= SEC_EXCLUDE;
	  return TRUE;
a6377 3

      *loc = sec;
      mips_elf_hash_table (info)->mips16_stubs_seen = TRUE;
d6742 1
a6742 3
	  && ! CONST_STRNEQ (bfd_get_section_name (abfd, sec), FN_STUB)
	  && ! CONST_STRNEQ (bfd_get_section_name (abfd, sec), CALL_STUB)
	  && ! CONST_STRNEQ (bfd_get_section_name (abfd, sec), CALL_FP_STUB))
@


1.189
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Don't extend
	PT_DYNAMIC on GNU/Linux targets.
@
text
@d3108 1
a3108 2
      if (primary_total * MIPS_ELF_GOT_SIZE (bfd2got->bfd)
	  >= MIPS_ELF_GOT_MAX_SIZE (arg->info))
@


1.188
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Make the
	size of .rel.dyn reflect the value of DT_RELSZ.

ld/testsuite/
	* ld-mips-elf/multi-got-1.d: Remove trailing R_MIPS_NONE entries.
	* ld-mips-elf/tls-multi-got-1.got: Likewise.
	* ld-mips-elf/tls-multi-got-1.r: Likewise.
@
text
@d9332 12
a9343 2
      if (m != NULL
	  && m->count == 1 && strcmp (m->sections[0]->name, ".dynamic") == 0)
@


1.187
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Allocate
	a PT_NULL header for dynamic objects.
	(_bfd_mips_elf_modify_segment_map): Add it.

ld/testsuite/
	* ld-mips-elf/multi-got-1.d: Do not expect a particular address
	for DT_HASH.
	* ld-mips-elf/rel32-o32.d: Bump addresses by 0x20 to account for
	the extra program header.
	* ld-mips-elf/rel32-n32.d: Likewise.
	* ld-mips-elf/tlslib-o32.got: Likewise.
	* ld-mips-elf/tlslib-o32-hidden.got: Likewise.
	* ld-mips-elf/tlslib-o32-ver.got: Likewise.
	* ld-mips-elf/tls-multi-got-1.got: Likewise.
	* ld-mips-elf/tls-multi-got-1.r: Likewise.
	* ld-mips-elf/rel64.d: Bump addresses by 0x30 to account for the
	extra program header.
	* ld-mips-elf/tlsdyn-o32.d: Reduce the GOT offset by 32 to account
	for the extra program header, and thus the shorter gap between the
	text and data segments.
	* ld-mips-elf/tlsdyn-o32-1.d: Likewise.
	* ld-mips-elf/tlsdyn-o32-2.d: Likewise.
	* ld-mips-elf/tlsdyn-o32-3.d: Likewise.
	* ld-mips-elf/tlsdyn-o32.got: Bump GOT text addresses by 0x20
	to account for the extra program header.
	* ld-mips-elf/tlsdyn-o32-1.got: Likewise.
	* ld-mips-elf/tlsdyn-o32-2.got: Likewise.
	* ld-mips-elf/tlsdyn-o32-3.got: Likewise.
@
text
@d8876 4
@


1.186
log
@bfd/
	* elfxx-mips.c (sort_dynamic_relocs): Sort relocations against the
	same symbol by increasing r_offset.
	(sort_dynamic_relocs_64): Likewise.  Fix comparisons between very
	large and very small symbol indexes.

ld/testsuite/
	* ld-mips-elf/tlslib-o32-hidden.got: Sort relocations against the
	same symbol in order of increasing r_offset.
	* ld-mips-elf/tls-multi-got-1.got: Likewise.
	* ld-mips-elf/tls-hidden3.r: Likewise.
	* ld-mips-elf/tls-hidden4.r: Likewise.
@
text
@d9172 6
d9386 32
@


1.185
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Add DT_DEBUG
	and DT_MIPS_RLD_MAP tags for position-independent executables.
	Do not add DT_DEBUG to shared libraries for any MIPS target.

ld/testsuite/
	* ld-mips-elf/multi-got-1.d: Remove DT_DEBUG tag.  Do not require
	a specific file offset for .dynamic.  Reduce DT_HASH by 8 to account
	for removed tag.
	* ld-mips-elf/tls-multi-got-1.r: Likewise.  Also reduce DT_REL by 8.
	Reduce PLTGOT and symbol values by 16 to account for the removed tag.
	* ld-mips-elf/textrel-1.d: Remove DT_DEBUG tag.
	* ld-mips-elf/rel32-n32.d: Reduce addresses by 16 to account for
	removed DT_DEBUG tag.
	* ld-mips-elf/rel64.d: Likewise.
	* ld-mips-elf/tls-multi-got-1.got: Likewise.
	* ld-mips-elf/tlslib-o32-hidden.got: Likewise.
@
text
@d1695 1
d1700 9
a1708 1
  return ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info);
d1726 10
a1735 2
  return (ELF64_R_SYM (int_reloc1[0].r_info)
	  - ELF64_R_SYM (int_reloc2[0].r_info));
@


1.184
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d7481 1
a7481 1
      if (! info->shared)
a7492 9
      else
	{
	  /* Shared libraries on traditional mips have DT_DEBUG.  */
	  if (!SGI_COMPAT (output_bfd))
	    {
	      if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))
		return FALSE;
	    }
	}
@


1.183
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d4804 5
@


1.182
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d9375 1
a9375 1
			    struct bfd_link_info *info ATTRIBUTE_UNUSED,
d9383 6
a9388 13
    {
      switch (ELF_R_TYPE (sec->owner, rel->r_info))
	{
	case R_MIPS_GNU_VTINHERIT:
	case R_MIPS_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
d9390 1
a9390 12
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
@


1.181
log
@	* elf32-mips.c, elf64-mips.c, elfn32-mips.c
	(elf_backend_merge_symbol_attribute): Define.
	* elflink.c (elf_link_add_object_symbols): Merge only the ELF
	visibility flags.
	* elfxx-mips.c (_bfd_mips_elf_merge_symbol_attribute): New function.
@
text
@d4101 2
a4102 2
	      if (strncmp (bfd_get_section_name (input_bfd, o),
			   CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
d4693 3
a4695 3
  return (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0
	  || strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
	  || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0);
d5410 1
a5410 1
      if (strncmp (name, ".gptab.", sizeof ".gptab." - 1) != 0)
d5433 1
a5433 1
      if (strncmp (name, ".MIPS.content", sizeof ".MIPS.content" - 1) != 0)
d5441 1
a5441 1
      if (strncmp (name, ".debug_", sizeof ".debug_" - 1) != 0)
d5449 2
a5450 3
      if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) != 0
	  && strncmp (name, ".MIPS.post_rel",
		      sizeof ".MIPS.post_rel" - 1) != 0)
d5570 1
a5570 1
  else if (strncmp (name, ".gptab.", sizeof ".gptab." - 1) == 0)
d5627 1
a5627 1
  else if (strncmp (name, ".MIPS.content", strlen (".MIPS.content")) == 0)
d5639 1
a5639 1
  else if (strncmp (name, ".debug_", sizeof ".debug_" - 1) == 0)
d5647 2
a5648 3
  else if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) == 0
	   || strncmp (name, ".MIPS.post_rel",
		       sizeof ".MIPS.post_rel" - 1) == 0)
d6119 1
a6119 1
  if (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0)
d6144 3
a6146 6
		  || strncmp (bfd_get_section_name (abfd, o), FN_STUB,
			      sizeof FN_STUB - 1) == 0
		  || strncmp (bfd_get_section_name (abfd, o), CALL_STUB,
			      sizeof CALL_STUB - 1) == 0
		  || strncmp (bfd_get_section_name (abfd, o), CALL_FP_STUB,
			      sizeof CALL_FP_STUB - 1) == 0)
d6222 2
a6223 2
  else if (strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
	   || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
d6252 1
a6252 1
      if (strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
d6637 3
a6639 6
	  && strncmp (bfd_get_section_name (abfd, sec), FN_STUB,
		      sizeof FN_STUB - 1) != 0
	  && strncmp (bfd_get_section_name (abfd, sec), CALL_STUB,
		      sizeof CALL_STUB - 1) != 0
	  && strncmp (bfd_get_section_name (abfd, sec), CALL_FP_STUB,
		      sizeof CALL_FP_STUB - 1) != 0)
d7287 1
a7287 1
      if (strncmp (name, ".rel", 4) == 0)
d7339 1
a7339 1
      else if (!htab->is_vxworks && strncmp (name, ".got", 4) == 0)
d7415 1
a7415 1
	       && strncmp (name, ".rld_map", 8) == 0)
d7422 1
a7422 1
	       && strncmp (name, ".compact_rel", 12) == 0)
d7424 1
a7424 1
      else if (strncmp (name, ".init", 5) != 0
d9084 1
a9084 1
		      && strncmp (name, ".gptab.", sizeof ".gptab." - 1) == 0);
d9094 1
a9094 2
		      && strncmp (name, ".MIPS.content",
				  sizeof ".MIPS.content" - 1) == 0);
d9114 1
a9114 1
	  if (strncmp (name, ".MIPS.events", sizeof ".MIPS.events" - 1) == 0)
d9119 1
a9119 2
	      BFD_ASSERT (strncmp (name, ".MIPS.post_rel",
				   sizeof ".MIPS.post_rel" - 1) == 0);
d10428 1
a10428 1
      if (strncmp (o->name, ".gptab.", sizeof ".gptab." - 1) == 0)
d11099 7
a11105 7
  { ".lit4",   5,  0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".lit8",   5,  0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".mdebug", 7,  0, SHT_MIPS_DEBUG, 0 },
  { ".sbss",   5, -2, SHT_NOBITS,     SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".sdata",  6, -2, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".ucode",  6,  0, SHT_MIPS_UCODE, 0 },
  { NULL,      0,  0, 0,              0 }
@


1.180
log
@	* elfxx-mips.c (_bfd_mips_elf_symbol_processing,
	_bfd_mips_elf_add_symbol_hook): Don't try to place small common TLS
	symbols in .scommon.
@
text
@d11118 3
a11120 2
/* Ensure that the STO_OPTIONAL flag is copied into h->other,
   even if this is not a defintion of the symbol.  */
d11127 10
a11136 1
  if (! definition
@


1.179
log
@	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Set
	sh_entsize only when sgot was already initialized.
@
text
@d5098 1
d5739 1
@


1.178
log
@	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Allow
	linking of objects for compatible machine types.
@
text
@d8792 3
a8796 4
  if (sgot != NULL)
    elf_section_data (sgot->output_section)->this_hdr.sh_entsize
      = MIPS_ELF_GOT_SIZE (output_bfd);

@


1.177
log
@	* elfxx-mips.c (mips_elf_next_relocation): Tighten check to test
	also for same symbol.
@
text
@d10857 3
a10859 1
	  && bfd_get_arch_info (obfd)->the_default)
@


1.176
log
@	* elfxx-mips.c (mips_elf_calculate_relocation): Remove magic constant.
@
text
@d3586 2
d3590 2
a3591 1
      if (ELF_R_TYPE (abfd, relocation->r_info) == r_type)
@


1.175
log
@* elfxx-mips.c (_bfd_mips_elf_common_definition): New function.
  Consider SHN_MIPS_ACOMMON and SHN_MIPS_SCOMMON as being common sections.
* elfxx-mips.h  (_bfd_mips_elf_common_definition): Prototype.
@
text
@d4474 2
a4475 1
      value = (value >> 2) & howto->dst_mask;
@


1.174
log
@bfd/
	* elf-bfd.h: Formatting.
	(_bfd_elf_map_sections_to_segments): Declare.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame_hdr): Don't
	clear program_header_size.
	* elf.c (get_program_header_size): Move.  Don't use or set saved
	program_header_size here.
	(elf_modify_segment_map): New function.  Split out from..
	(assign_file_positions_for_load_sections): ..here.  Assert
	header size is correct.  Remove dead code.
	(_bfd_elf_map_sections_to_segments): Rename from
	map_sections_to_segments.  Make global.  Use get_program_header_size
	when we need estimate of header size.  Call elf_modify_segment_map.
	Set program_header_size.
	(print_segment_map): Delete.
	(_bfd_elf_sizeof_headers): If segment_map available, get the
	actual size.
	* elf32-arm.c (elf32_arm_symbian_modify_segment_map): Make safe
	for calling more than once.
	* elf32-bfin.c (elf32_bfinfdpic_modify_segment_map): Likewise.
	* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
	* elf32-i370.c (elf_backend_add_symbol_hook): Delete.
	(elf_backend_additional_program_headers): Delete.
	(elf_backend_modify_segment_map): Delete.
	* elf64-hppa.c (elf64_hppa_modify_segment_map): Convert to ISO C.
	* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
	* doc/bfdint.texi: Delete SIZEOF_HEADERS difficulties.
ld/
	* Makefile.am (ELF_DEPS): Define.  Use in emul file deps.  Fix
	many ELF emul file deps that incorrectly said they needed elf32.em
	instead of generic.em.  Add genelf.em as required.
	* Makefile.in: Regenerate.
	* ldlang.c (lang_process): Call ldemul_finish before
	lang_check_section_addresses.
	* emulparams/arcelf.sh: Generic elf target needs genelf.
	* emulparams/d30v_e.sh: Likewise.
	* emulparams/d30v_o.sh: Likewise.
	* emulparams/d30velf.sh: Likewise.
	* emulparams/elf32_dlx.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32fr30.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32iq10.sh: Likewise.
	* emulparams/elf32iq2000.sh: Likewise.
	* emulparams/elf32mt.sh: Likewise.
	* emulparams/mn10200.sh: Likewise.
	* emulparams/or32.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/msp430all.sh: Likewise.  Extract common entries.
	* emulparams/pjlelf.sh: Include pjelf.sh.
	* emulparams/elf32frvfd.sh (EXTRA_EM_FILE): Unset.
	* emulparams/mn10300.sh (EXTRA_EM_FILE): Unset.
	* emultempl/elf-generic.em: New file.
	* emultempl/genelf.em: New file.
	* emultempl/elf32.em: Include elf-generic.em.
	(gld${EMULATION_NAME}_layout_sections_again): Delete.
	(gld${EMULATION_NAME}_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/hppaelf.em (hppaelf_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from hppaelf_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
	* emultempl/mmo.em: Correct comment.  Include elf-bfd.h and
	source elf-generic.em.
	(mmo_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from ppc_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
ld/testsuite/
	* ld-elf/eh1.d: Update for fewer program headers.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
@
text
@d11131 8
@


1.173
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d9233 12
a9244 9
	  amt = sizeof (struct elf_segment_map);
	  options_segment = bfd_zalloc (abfd, amt);
	  options_segment->next = *pm;
	  options_segment->p_type = PT_MIPS_OPTIONS;
	  options_segment->p_flags = PF_R;
	  options_segment->p_flags_valid = TRUE;
	  options_segment->count = 1;
	  options_segment->sections[0] = s;
	  *pm = options_segment;
@


1.172
log
@bfd/
	* elfxx-mips.c (mips_elf_link_hash_table): Add function_stub_size.
	(STUB_ORI): New macro.
	(STUB_LI16U): Fix formatting.
	(MIPS_FUNCTION_STUB_SIZE): Delete.
	(MIPS_FUNCTION_STUB_MAX_SIZE): Likewise.
	(MIPS_FUNCTION_STUB_NORMAL_SIZE): New macro.
	(MIPS_FUNCTION_STUB_BIG_SIZE): Likewise.
	(_bfd_mips_elf_adjust_dynamic_symbol): Use htab->function_stub_size
	instead of MIPS_FUNCTION_STUB_SIZE.
	(count_section_dynsyms): New function, split out from
	_bfd_mips_elf_final_link.
	(_bfd_mips_elf_always_size_sections): Get a worst-case estimate
	of the number of dynamic symbols needed and use it to set up
	function_stub_size.  Use function_stub_size rather than
	MIPS_FUNCTION_STUB_SIZE to determine the size of the stub section.
	Use 16-byte stubs for 0x10000 dynamic symbols.
	(_bfd_mips_elf_size_dynamic_sections): Use htab->function_stub_size
	instead of MIPS_FUNCTION_STUB_SIZE.  Fix formatting.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.  Change the
	size of the stub buffer from MIPS_FUNCTION_STUB_MAX_SIZE to
	MIPS_FUNCTION_STUB_BIG_SIZE.  Tweak the check for unhandled dynindxes.
	Use MIPS_FUNCTION_STUB_BIG_SIZE rather than a hard-coded 20.
	Use STUB_ORI rather than STUB_LI16U for big stubs.
	(_bfd_mips_elf_link_hash_table_create): Initialize function_stub_size.
	(_bfd_mips_elf_final_link): Use count_section_dynsyms.

ld/testsuite/
	* ld-mips-elf/stub-dynsym-1.s,
	* ld-mips-elf/stub-dynsym-1.ld,
	* ld-mips-elf/stub-dynsym-1-7fff.d,
	* ld-mips-elf/stub-dynsym-1-8000.d,
	* ld-mips-elf/stub-dynsym-1-fff0.d,
	* ld-mips-elf/stub-dynsym-1-10000.d,
	* ld-mips-elf/stub-dynsym-1-2fe80.d: New test.
	* ld-mips-elf/mips-elf.exp: Run it.
@
text
@d9141 2
a9142 1
_bfd_mips_elf_additional_program_headers (bfd *abfd)
@


1.171
log
@	* bfd/elfxx-mips.c (mips_elf_calculate_relocation): Fix mode for stub
	calling relocations.
@
text
@d338 2
d638 2
a639 1
#define STUB_LI16U(VAL) (0x34180000 + (VAL))	/* ori t8,zero,VAL unsigned*/
d645 2
a646 4
#define MIPS_FUNCTION_STUB_SIZE(INFO) \
  (elf_hash_table (INFO)->dynsymcount > 65536 ? 20 : 16)

#define MIPS_FUNCTION_STUB_MAX_SIZE 20
d6836 1
d6838 1
d6891 1
a6891 1
	  s->size += MIPS_FUNCTION_STUB_SIZE (info);
d7079 26
d7121 1
d7180 12
d7195 1
a7195 1
  loadable_size += MIPS_FUNCTION_STUB_SIZE (info) * (i + 1);
d7412 2
a7413 2
	     of .text section. So put a dummy. XXX  */
	  s->size += MIPS_FUNCTION_STUB_SIZE (info);
d7419 1
a7419 1
	  /* We add a room for __rld_map. It will be filled in by the
d8051 1
d8053 1
d8059 1
a8059 1
      bfd_byte stub[MIPS_FUNCTION_STUB_MAX_SIZE];
d8069 2
a8070 2
      BFD_ASSERT ((MIPS_FUNCTION_STUB_SIZE (info) == 20)
                  || (h->dynindx <= 65536));
d8073 3
a8075 3
         sign extension at runtime in the stub, resulting in a
         negative index value.  */
      if (h->dynindx & 0x80000000)
d8084 1
a8084 1
      if (MIPS_FUNCTION_STUB_SIZE (info) == 20)
d8086 1
a8086 1
          bfd_put_32 (output_bfd, STUB_LUI ((h->dynindx >> 16 ) & 0xffff),
d8095 3
a8097 1
      if ((MIPS_FUNCTION_STUB_SIZE (info) == 20) || (h->dynindx & 0xffff8000))
d8100 3
a8102 3
        bfd_put_32 (output_bfd,
                    STUB_LI16S (output_bfd, h->dynindx & 0xffff), stub + idx);
        
d8104 1
a8104 2
      memcpy (s->contents + h->plt.offset,
              stub, MIPS_FUNCTION_STUB_SIZE (info));
d8907 2
a8908 2
		BFD_ASSERT (s->size >= MIPS_FUNCTION_STUB_SIZE (info));
		dummy_offset = s->size - MIPS_FUNCTION_STUB_SIZE (info);
d8910 1
a8910 1
			MIPS_FUNCTION_STUB_SIZE (info));
d10022 1
d10098 1
a10098 12
      dynsecsymcount = 0;
      if (info->shared)
	{
	  asection * p;

	  for (p = abfd->sections; p ; p = p->next)
	    if ((p->flags & SEC_EXCLUDE) == 0
		&& (p->flags & SEC_ALLOC) != 0
		&& !(*bed->elf_backend_omit_section_dynsym) (abfd, info, p))
	      ++ dynsecsymcount;
	}

@


1.170
log
@	* elfxx-mips.c (STUB_LI16): Removed.
	(STUB_LUI): New macro.
	(STUB_LI16U): Ditto.
	(STUB_LI16S): Ditto.
	(MIPS_FUNCTION_STUB_SIZE): Rewrote to take info parameter.
	(_bfd_mips_elf_adjust_dynamic_symbol): Pass info parameter to
	MIPS_FUNCTION_STUB_SIZE.
	(_bfd_mips_elf_always_size_sections): Ditto.
	(_bfd_mips_elf_size_dynamic_sections): Ditto.
	(_bfd_mips_elf_finish_dynamic_sections): Ditto.
	(_bfd_mips_elf_finish_dynamic_symbol): Rewrote stub generation
	to allow larger symbol table indexes.
@
text
@d4077 2
@


1.169
log
@bfd/
	* elflink.c (_bfd_elf_add_dynamic_entry): Remove DT_TEXTREL
	check.
	(bfd_elf_final_link): Add a late DT_TEXTREL check.
	* elfxx-mips.c (MIPS_ELF_READONLY_SECTION): Define.
	(mips_elf_create_dynamic_relocation): Set DF_TEXTREL.
	(_bfd_mips_elf_check_relocs): Delete MIPS_READONLY_SECTION.
	Use MIPS_ELF_READONLY_SECTION.
	(_bfd_mips_elf_size_dynamic_sections): Clear DF_TEXTREL after
	creating DT_TEXTREL.
	(_bfd_mips_elf_finish_dynamic_sections): Clear textrel markers
	if no text relocations were generated.
ld/testsuite/
	* ld-mips-elf/textrel-1.d: Relax some patterns.
@
text
@d626 20
a645 14
#define STUB_LW(abfd)						\
  ((ABI_64_P (abfd)  						\
    ? 0xdf998010		/* ld t9,0x8010(gp) */		\
    : 0x8f998010))              /* lw t9,0x8010(gp) */
#define STUB_MOVE(abfd)                                         \
   ((ABI_64_P (abfd)						\
     ? 0x03e0782d		/* daddu t7,ra */		\
     : 0x03e07821))		/* addu t7,ra */
#define STUB_JALR 0x0320f809	/* jalr t9,ra */
#define STUB_LI16(abfd)                                         \
  ((ABI_64_P (abfd)						\
   ? 0x64180000			/* daddiu t8,zero,0 */		\
   : 0x24180000))		/* addiu t8,zero,0 */
#define MIPS_FUNCTION_STUB_SIZE (16)
d6886 1
a6886 1
	  s->size += MIPS_FUNCTION_STUB_SIZE;
d7151 1
a7151 1
  loadable_size += MIPS_FUNCTION_STUB_SIZE * (i + 1);
d7369 1
a7369 1
	  s->size += MIPS_FUNCTION_STUB_SIZE;
d8006 1
d8013 1
a8013 1
      bfd_byte stub[MIPS_FUNCTION_STUB_SIZE];
d8023 7
a8029 2
      /* FIXME: Can h->dynindx be more than 64K?  */
      if (h->dynindx & 0xffff0000)
d8033 13
a8045 4
      bfd_put_32 (output_bfd, STUB_LW (output_bfd), stub);
      bfd_put_32 (output_bfd, STUB_MOVE (output_bfd), stub + 4);
      bfd_put_32 (output_bfd, STUB_JALR, stub + 8);
      bfd_put_32 (output_bfd, STUB_LI16 (output_bfd) + h->dynindx, stub + 12);
d8047 8
d8056 2
a8057 1
      memcpy (s->contents + h->plt.offset, stub, MIPS_FUNCTION_STUB_SIZE);
d8860 2
a8861 2
		BFD_ASSERT (s->size >= MIPS_FUNCTION_STUB_SIZE);
		dummy_offset = s->size - MIPS_FUNCTION_STUB_SIZE;
d8863 1
a8863 1
			MIPS_FUNCTION_STUB_SIZE);
@


1.168
log
@	* elfxx-mips.c (_bfd_mips_elf_hide_symbol): Adjust handling
	for missing GOTs.
@
text
@d538 5
d4920 6
a6520 1
#define MIPS_READONLY_SECTION (SEC_ALLOC | SEC_LOAD | SEC_READONLY)
d6527 1
a6527 2
		  if ((sec->flags & MIPS_READONLY_SECTION)
		      == MIPS_READONLY_SECTION)
d6540 1
a6540 2
		  if ((sec->flags & MIPS_READONLY_SECTION)
		      == MIPS_READONLY_SECTION)
d7457 6
d8489 1
d8644 19
d8668 1
a8668 1
	  if (swap_out_p)
d8670 7
a8676 1
	      (dynobj, &dyn, b);
d8678 4
@


1.167
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d9383 1
a9383 1
      && (got = mips_elf_got_section (dynobj, FALSE)) != NULL
@


1.166
log
@	* archive.c (bfd_generic_archive_p): Remove unused local variable
	`fail'.
	* dwarf2.c (decode_line_info): Remove unused local variable
	`basic_block'.
	* elfcode.h (elf_slurp_reloc_table_from_section): Remove unsed
	local varibale `s'.
	* tekhex.c (tekhex_write_object_contents): Remove unused local
	variable `bytes_written'.
	* aout-ns32k.c (MY_swap_std_reloc_out): Remove unused local
	variable `r_addend'.
	* elf32-dlx.c (dlx_rtype_to_howto): Remove breaks after returns.
	* elfxx-mips.c (_bfd_elf_mips_mach): Remove breaks after returns.
	(_bfd_ns32k_relocate_contents): Remove break after return.
	* elf.c (bfd_section_from_shdr): Remove breaks after returns.
@
text
@d829 4
a832 2
  struct _mips_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);
d834 5
a838 4
  sdata = bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = sdata;
@


1.165
log
@	* elfxx-mips.c (mips_got_entry): Add more commentary.
	(mips_elf_local_got_index): Use the hash table entry to record
	the GOT index of forced-local symbols.
	(mips_elf_initialize_tls_index): Rearrange code.  Store the index
	in either the hash table entry or the mips_got_entry, not both.
	Add more commentary.
	(mips_elf_multi_got): Make sure the g->next is nonnull when calling
	mips_elf_initialize_tls_index.

	* ld-mips-elf/tls-hidden3a.s, ld-mips-elf/tls-hidden3b.s,
	* ld-mips-elf/tls-hidden3.d, ld-mips-elf/tls-hidden3.got,
	* ld-mips-elf/tls-hidden3.ld, ld-mips-elf/tls-hidden3.r,
	* ld-mips-elf/tls-hidden4a.s, ld-mips-elf/tls-hidden4b.s,
	* ld-mips-elf/tls-hidden4.got, ld-mips-elf/tls-hidden4.r: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@a4957 1
	  break;
a4960 1
	  break;
a4963 1
	  break;
a4966 1
	  break;
a4969 1
	  break;
a4972 1
	  break;
a4975 1
	  break;
a4978 1
	  break;
a4981 1
	  break;
@


1.165.4.1
log
@bfd/
	* elflink.c (_bfd_elf_add_dynamic_entry): Remove DT_TEXTREL
	check.
	(bfd_elf_final_link): Add a late DT_TEXTREL check.
	* elfxx-mips.c (MIPS_ELF_READONLY_SECTION): Define.
	(mips_elf_create_dynamic_relocation): Set DF_TEXTREL.
	(_bfd_mips_elf_check_relocs): Delete MIPS_READONLY_SECTION.
	Use MIPS_ELF_READONLY_SECTION.
	(_bfd_mips_elf_size_dynamic_sections): Clear DF_TEXTREL after
	creating DT_TEXTREL.
	(_bfd_mips_elf_finish_dynamic_sections): Clear textrel markers
	if no text relocations were generated.
ld/testsuite/
	* ld-mips-elf/textrel-1.d: Relax some patterns.
@
text
@a537 5
/* Whether the section is readonly.  */
#define MIPS_ELF_READONLY_SECTION(sec) \
  ((sec->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))		\
   == (SEC_ALLOC | SEC_LOAD | SEC_READONLY))

a4911 6
  /* If we've written this relocation for a readonly section,
     we need to set DF_TEXTREL again, so that we do not delete the
     DT_TEXTREL tag.  */
  if (MIPS_ELF_READONLY_SECTION (input_section))
    info->flags |= DF_TEXTREL;

d6516 1
d6523 2
a6524 1
		  if (MIPS_ELF_READONLY_SECTION (sec))
d6537 2
a6538 1
		  if (MIPS_ELF_READONLY_SECTION (sec))
a7454 6

	  /* Clear the DF_TEXTREL flag.  It will be set again if we
	     write out an actual text relocation; we may not, because
	     at this point we do not know whether e.g. any .eh_frame
	     absolute relocations have been converted to PC-relative.  */
	  info->flags &= ~DF_TEXTREL;
a8480 1
      int dyn_to_skip = 0, dyn_skipped = 0;
a8634 19
	    case DT_TEXTREL:
	      /* If we didn't need any text relocations after all, delete
		 the dynamic tag.  */
	      if (!(info->flags & DF_TEXTREL))
		{
		  dyn_to_skip = MIPS_ELF_DYN_SIZE (dynobj);
		  swap_out_p = FALSE;
		}
	      break;

	    case DT_FLAGS:
	      /* If we didn't need any text relocations after all, clear
		 DF_TEXTREL from DT_FLAGS.  */
	      if (!(info->flags & DF_TEXTREL))
		dyn.d_un.d_val &= ~DF_TEXTREL;
	      else
		swap_out_p = FALSE;
	      break;

d8640 1
a8640 1
	  if (swap_out_p || dyn_skipped)
d8642 1
a8642 7
	      (dynobj, &dyn, b - dyn_skipped);

	  if (dyn_to_skip)
	    {
	      dyn_skipped += dyn_to_skip;
	      dyn_to_skip = 0;
	    }
a8643 4

      /* Wipe out any trailing entries if we shifted down a dynamic tag.  */
      if (dyn_skipped > 0)
	memset (b - dyn_skipped, 0, dyn_skipped);
@


1.165.4.2
log
@	* elfxx-mips.c (STUB_LI16): Removed.
	(STUB_LUI): New macro.
	(STUB_LI16U): Ditto.
	(STUB_LI16S): Ditto.
	(MIPS_FUNCTION_STUB_SIZE): Rewrote to take info parameter.
	(_bfd_mips_elf_adjust_dynamic_symbol): Pass info parameter to
	MIPS_FUNCTION_STUB_SIZE.
	(_bfd_mips_elf_always_size_sections): Ditto.
	(_bfd_mips_elf_size_dynamic_sections): Ditto.
	(_bfd_mips_elf_finish_dynamic_sections): Ditto.
	(_bfd_mips_elf_finish_dynamic_symbol): Rewrote stub generation
	to allow larger symbol table indexes.
@
text
@d626 14
a639 20
#define STUB_LW(abfd)							\
  ((ABI_64_P (abfd)							\
    ? 0xdf998010				/* ld t9,0x8010(gp) */	\
    : 0x8f998010))              		/* lw t9,0x8010(gp) */
#define STUB_MOVE(abfd)							\
   ((ABI_64_P (abfd)							\
     ? 0x03e0782d				/* daddu t7,ra */	\
     : 0x03e07821))				/* addu t7,ra */
#define STUB_LUI(VAL) (0x3c180000 + (VAL))	/* lui t8,VAL */
#define STUB_JALR 0x0320f809			/* jalr t9,ra */
#define STUB_LI16U(VAL) (0x34180000 + (VAL))	/* ori t8,zero,VAL unsigned*/
#define STUB_LI16S(abfd, VAL)						\
   ((ABI_64_P (abfd)							\
    ? (0x64180000 + (VAL))	/* daddiu t8,zero,VAL sign extended */	\
    : (0x24180000 + (VAL))))	/* addiu t8,zero,VAL sign extended */

#define MIPS_FUNCTION_STUB_SIZE(INFO) \
  (elf_hash_table (INFO)->dynsymcount > 65536 ? 20 : 16)

#define MIPS_FUNCTION_STUB_MAX_SIZE 20
d6886 1
a6886 1
	  s->size += MIPS_FUNCTION_STUB_SIZE (info);
d7151 1
a7151 1
  loadable_size += MIPS_FUNCTION_STUB_SIZE (info) * (i + 1);
d7369 1
a7369 1
	  s->size += MIPS_FUNCTION_STUB_SIZE (info);
a8005 1
  int idx;
d8012 1
a8012 1
      bfd_byte stub[MIPS_FUNCTION_STUB_MAX_SIZE];
d8022 2
a8023 7
      BFD_ASSERT ((MIPS_FUNCTION_STUB_SIZE (info) == 20)
                  || (h->dynindx <= 65536));

      /* Values up to 2^31 - 1 are allowed.  Larger values would cause
         sign extension at runtime in the stub, resulting in a
         negative index value.  */
      if (h->dynindx & 0x80000000)
d8027 4
a8030 13
      idx = 0;
      bfd_put_32 (output_bfd, STUB_LW (output_bfd), stub + idx);
      idx += 4;
      bfd_put_32 (output_bfd, STUB_MOVE (output_bfd), stub + idx);
      idx += 4;
      if (MIPS_FUNCTION_STUB_SIZE (info) == 20)
        {
          bfd_put_32 (output_bfd, STUB_LUI ((h->dynindx >> 16 ) & 0xffff),
                      stub + idx);
          idx += 4;
        }
      bfd_put_32 (output_bfd, STUB_JALR, stub + idx);
      idx += 4;
a8031 8
      /* If a large stub is not required and sign extension is not a
         problem, then use legacy code in the stub.  */
      if ((MIPS_FUNCTION_STUB_SIZE (info) == 20) || (h->dynindx & 0xffff8000))
        bfd_put_32 (output_bfd, STUB_LI16U (h->dynindx & 0xffff), stub + idx);
      else
        bfd_put_32 (output_bfd,
                    STUB_LI16S (output_bfd, h->dynindx & 0xffff), stub + idx);
        
d8033 1
a8033 2
      memcpy (s->contents + h->plt.offset,
              stub, MIPS_FUNCTION_STUB_SIZE (info));
d8836 2
a8837 2
		BFD_ASSERT (s->size >= MIPS_FUNCTION_STUB_SIZE (info));
		dummy_offset = s->size - MIPS_FUNCTION_STUB_SIZE (info);
d8839 1
a8839 1
			MIPS_FUNCTION_STUB_SIZE (info));
@


1.165.4.3
log
@bfd/
	* elfxx-mips.c (mips_elf_link_hash_table): Add function_stub_size.
	(STUB_ORI): New macro.
	(STUB_LI16U): Fix formatting.
	(MIPS_FUNCTION_STUB_SIZE): Delete.
	(MIPS_FUNCTION_STUB_MAX_SIZE): Likewise.
	(MIPS_FUNCTION_STUB_NORMAL_SIZE): New macro.
	(MIPS_FUNCTION_STUB_BIG_SIZE): Likewise.
	(_bfd_mips_elf_adjust_dynamic_symbol): Use htab->function_stub_size
	instead of MIPS_FUNCTION_STUB_SIZE.
	(count_section_dynsyms): New function, split out from
	_bfd_mips_elf_final_link.
	(_bfd_mips_elf_always_size_sections): Get a worst-case estimate
	of the number of dynamic symbols needed and use it to set up
	function_stub_size.  Use function_stub_size rather than
	MIPS_FUNCTION_STUB_SIZE to determine the size of the stub section.
	Use 16-byte stubs for 0x10000 dynamic symbols.
	(_bfd_mips_elf_size_dynamic_sections): Use htab->function_stub_size
	instead of MIPS_FUNCTION_STUB_SIZE.  Fix formatting.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.  Change the
	size of the stub buffer from MIPS_FUNCTION_STUB_MAX_SIZE to
	MIPS_FUNCTION_STUB_BIG_SIZE.  Tweak the check for unhandled dynindxes.
	Use MIPS_FUNCTION_STUB_BIG_SIZE rather than a hard-coded 20.
	Use STUB_ORI rather than STUB_LI16U for big stubs.
	(_bfd_mips_elf_link_hash_table_create): Initialize function_stub_size.
	(_bfd_mips_elf_final_link): Use count_section_dynsyms.

ld/testsuite/
	* ld-mips-elf/stub-dynsym-1.s,
	* ld-mips-elf/stub-dynsym-1.ld,
	* ld-mips-elf/stub-dynsym-1-7fff.d,
	* ld-mips-elf/stub-dynsym-1-8000.d,
	* ld-mips-elf/stub-dynsym-1-fff0.d,
	* ld-mips-elf/stub-dynsym-1-10000.d,
	* ld-mips-elf/stub-dynsym-1-2fe80.d: New test.
	* ld-mips-elf/mips-elf.exp: Run it.
@
text
@a337 2
  /* The size of a function stub entry in bytes.  */
  bfd_vma function_stub_size;
d636 1
a636 2
#define STUB_ORI(VAL) (0x37180000 + (VAL))	/* ori t8,t8,VAL */
#define STUB_LI16U(VAL) (0x34180000 + (VAL))	/* ori t8,zero,VAL unsigned */
d642 4
a645 2
#define MIPS_FUNCTION_STUB_NORMAL_SIZE 16
#define MIPS_FUNCTION_STUB_BIG_SIZE 20
a6838 1
  struct mips_elf_link_hash_table *htab;
a6839 1
  htab = mips_elf_hash_table (info);
d6892 1
a6892 1
	  s->size += htab->function_stub_size;
a7079 26
/* Return the number of dynamic section symbols required by OUTPUT_BFD.
   The number might be exact or a worst-case estimate, depending on how
   much information is available to elf_backend_omit_section_dynsym at
   the current linking stage.  */

static bfd_size_type
count_section_dynsyms (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd_size_type count;

  count = 0;
  if (info->shared)
    {
      asection *p;
      const struct elf_backend_data *bed;

      bed = get_elf_backend_data (output_bfd);
      for (p = output_bfd->sections; p ; p = p->next)
	if ((p->flags & SEC_EXCLUDE) == 0
	    && (p->flags & SEC_ALLOC) != 0
	    && !(*bed->elf_backend_omit_section_dynsym) (output_bfd, info, p))
	  ++count;
    }
  return count;
}

a7095 1
  bfd_size_type dynsymcount;
a7153 12
  /* Get a worst-case estimate of the number of dynamic symbols needed.
     At this point, dynsymcount does not account for section symbols
     and count_section_dynsyms may overestimate the number that will
     be needed.  */
  dynsymcount = (elf_hash_table (info)->dynsymcount
		 + count_section_dynsyms (output_bfd, info));

  /* Determine the size of one stub entry.  */
  htab->function_stub_size = (dynsymcount > 0x10000
			      ? MIPS_FUNCTION_STUB_BIG_SIZE
			      : MIPS_FUNCTION_STUB_NORMAL_SIZE);

d7157 1
a7157 1
  loadable_size += htab->function_stub_size * (i + 1);
d7374 2
a7375 2
	     of .text section.  So put a dummy.  XXX  */
	  s->size += htab->function_stub_size;
d7381 1
a7381 1
	  /* We add a room for __rld_map.  It will be filled in by the
a8012 1
  struct mips_elf_link_hash_table *htab;
a8013 1
  htab = mips_elf_hash_table (info);
d8019 1
a8019 1
      bfd_byte stub[MIPS_FUNCTION_STUB_BIG_SIZE];
d8029 2
a8030 2
      BFD_ASSERT ((htab->function_stub_size == MIPS_FUNCTION_STUB_BIG_SIZE)
                  || (h->dynindx <= 0xffff));
d8033 3
a8035 3
	 sign extension at runtime in the stub, resulting in a negative
	 index value.  */
      if (h->dynindx & ~0x7fffffff)
d8044 1
a8044 1
      if (htab->function_stub_size == MIPS_FUNCTION_STUB_BIG_SIZE)
d8046 1
a8046 1
          bfd_put_32 (output_bfd, STUB_LUI ((h->dynindx >> 16) & 0x7fff),
d8055 1
a8055 3
      if (htab->function_stub_size == MIPS_FUNCTION_STUB_BIG_SIZE)
	bfd_put_32 (output_bfd, STUB_ORI (h->dynindx & 0xffff), stub + idx);
      else if (h->dynindx & ~0x7fff)
d8058 3
a8060 3
        bfd_put_32 (output_bfd, STUB_LI16S (output_bfd, h->dynindx),
		    stub + idx);

d8062 2
a8063 1
      memcpy (s->contents + h->plt.offset, stub, htab->function_stub_size);
d8866 2
a8867 2
		BFD_ASSERT (s->size >= htab->function_stub_size);
		dummy_offset = s->size - htab->function_stub_size;
d8869 1
a8869 1
			htab->function_stub_size);
a9980 1
  ret->function_stub_size = 0;
d10056 12
a10067 1
      dynsecsymcount = count_section_dynsyms (abfd, info);
@


1.164
log
@	* elfxx-mips.c (_bfd_mips_vxworks_finish_dynamic_symbol): Fix type
	of "loc".
@
text
@d47 33
a79 2
/* This structure is used to hold .got entries while estimating got
   sizes.  */
d2405 10
a2414 2
    return mips_tls_got_index (abfd, entry->gotidx, &entry->tls_type, r_type,
			       info, h, value);
d3160 2
a3161 1
/* Set the TLS GOT index for the GOT entry in ENTRYP.  */
d3168 1
d3174 3
a3176 1
  if (entry->symndx == -1)
d3178 10
a3187 3
      /* There may be multiple mips_got_entry structs for a global variable
	 if there is just one GOT.  Just do this once.  */
      if (g->next == NULL)
d3189 4
a3192 1
	  if (entry->d.h->tls_type & GOT_TLS_OFFSET_DONE)
d3194 1
a3194 1
	      entry->gotidx = entry->d.h->tls_got_offset;
d3197 1
a3197 1
	  entry->d.h->tls_type |= GOT_TLS_OFFSET_DONE;
d3199 1
a3200 14
  else if (entry->tls_type & GOT_TLS_LDM)
    {
      /* Similarly, there may be multiple structs for the LDM entry.  */
      if (g->tls_ldm_offset != MINUS_TWO && g->tls_ldm_offset != MINUS_ONE)
	{
	  entry->gotidx = g->tls_ldm_offset;
	  return 1;
	}
    }

  /* Initialize the GOT offset.  */
  entry->gotidx = MIPS_ELF_GOT_SIZE (entry->abfd) * (long) g->tls_assigned_gotno;
  if (g->next == NULL && entry->symndx == -1)
    entry->d.h->tls_got_offset = entry->gotidx;
d3202 1
a3207 3
  if (entry->tls_type & GOT_TLS_LDM)
    g->tls_ldm_offset = entry->gotidx;

d3533 7
d3545 1
a3545 5
      /* Take g out of the direct list, and push it onto the reversed
	 list that gg points to.  */
      gn = g->next;
      g->next = gg->next;
      gg->next = g;
@


1.163
log
@	Richard Sandiford  <richard@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>
	Phil Edwards  <phil@@codesourcery.com>
	Zack Weinberg  <zack@@codesourcery.com>
	Mark Mitchell  <mark@@codesourcery.com>
	Nathan Sidwell  <nathan@@codesourcery.com>

bfd/
	* bfd-in2.h: Regenerate.
	* config.bfd (mips*-*-vxworks*, mips*el-*-vxworks*): New stanzas.
	* configure.in (bfd_elf32_bigmips_vxworks_vec): New stanza.
	(bfd_elf32_littlemips_vxworks_vec): Likewise.
	(bfd_elf32_bigmips_vec): Add elf-vxworks.lo.
	(bfd_elf32_littlemips_vec): Likewise.
	(bfd_elf32_nbigmips_vec): Likewise.
	(bfd_elf32_nlittlemips_vec): Likewise.
	(bfd_elf32_ntradbigmips_vec): Likewise.
	(bfd_elf32_ntradlittlemips_vec): Likewise.
	(bfd_elf32_tradbigmips_vec): Likewise.
	(bfd_elf32_tradlittlemips_vec): Likewise.
	(bfd_elf64_bigmips_vec): Likewise.
	(bfd_elf64_littlemips_vec): Likewise.
	(bfd_elf64_tradbigmips_vec): Likewise.
	(bfd_elf64_tradlittlemips_vec): Likewise.
	* elf32-mips.c: Include elf-vxworks.h.
	(mips_info_to_howto_rel): Use elf_backend_mips_rtype_to_howto
	instead of calling mips_elf32_rtype_to_howto directly.
	(mips_vxworks_copy_howto_rela): New reloc howto.
	(mips_vxworks_jump_slot_howto_rela): Likewise.
	(mips_vxworks_bfd_reloc_type_lookup): New function.
	(mips_vxworks_rtype_to_howto): Likewise.
	(mips_vxworks_final_write_processing): Likewise.
	(TARGET_LITTLE_SYM, TARGET_LITTLE_NAME): Override for VxWorks.
	(TARGET_BIG_SYM, TARGET_BIG_NAME, elf_bed, ELF_MAXPAGESIZE): Likewise.
	(elf_backend_want_got_plt): Likewise.
	(elf_backend_want_plt_sym): Likewise.
	(elf_backend_got_symbol_offset): Likewise.
	(elf_backend_want_dynbss): Likewise.
	(elf_backend_may_use_rel_p): Likewise.
	(elf_backend_may_use_rela_p): Likewise.
	(elf_backend_default_use_rela_p): Likewise.
	(elf_backend_got_header_size: Likewise.
	(elf_backend_plt_readonly): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Likewise.
	(elf_backend_mips_rtype_to_howto): Likewise.
	(elf_backend_adjust_dynamic_symbol): Likewise.
	(elf_backend_finish_dynamic_symbol): Likewise.
	(bfd_elf32_bfd_link_hash_table_create): Likewise.
	(elf_backend_add_symbol_hook): Likewise.
	(elf_backend_link_output_symbol_hook): Likewise.
	(elf_backend_emit_relocs): Likewise.
	(elf_backend_final_write_processing: Likewise.
	(elf_backend_additional_program_headers): Likewise.
	(elf_backend_modify_segment_map): Likewise.
	(elf_backend_symbol_processing): Likewise.
	* elfxx-mips.c: Include elf-vxworks.h.
	(mips_elf_link_hash_entry): Add is_relocation_target and
	is_branch_target fields.
	(mips_elf_link_hash_table): Add is_vxworks, srelbss, sdynbss, srelplt,
	srelplt2, sgotplt, splt, plt_header_size and plt_entry_size fields.
	(MIPS_ELF_RELA_SIZE, MIPS_ELF_REL_DYN_NAME): New macros.
	(MIPS_RESERVED_GOTNO): Take a mips_elf_link_hash_table argument.
	Return 3 for VxWorks.
	(ELF_MIPS_GP_OFFSET): Change the argument from a bfd to a
	mips_elf_link_hash_table.  Return 0 for VxWorks.
	(MIPS_ELF_GOT_MAX_SIZE): Change the argument from a bfd to a
	mips_elf_link_hash_table.  Update the call to ELF_MIPS_GP_OFFSET.
	(mips_vxworks_exec_plt0_entry): New variable.
	(mips_vxworks_exec_plt_entry): Likewise.
	(mips_vxworks_shared_plt0_entry): Likewise.
	(mips_vxworks_shared_plt_entry): Likewise.
	(mips_elf_link_hash_newfunc): Initialize the new hash_entry fields.
	(mips_elf_rel_dyn_section): Change the bfd argument to a
	mips_elf_link_hash_table.  Use MIPS_ELF_REL_DYN_NAME to get
	the name of the section.
	(mips_elf_initialize_tls_slots): Update the call to
	mips_elf_rel_dyn_section.
	(mips_elf_gotplt_index): New function.
	(mips_elf_local_got_index): Add an input_section argument.
	Update the call to mips_elf_create_local_got_entry.
	(mips_elf_got_page): Likewise.
	(mips_elf_got16_entry): Likewise.
	(mips_elf_create_local_got_entry): Add bfd_link_info and input_section
	arguments.  Create dynamic relocations for each entry on VxWorks.
	(mips_elf_merge_gots): Update the use of MIPS_ELF_GOT_MAX_SIZE.
	(mips_elf_multi_got): Update the uses of MIPS_ELF_GOT_MAX_SIZE
	and MIPS_RESERVED_GOTNO.
	(mips_elf_create_got_section): Update the uses of
	MIPS_ELF_GOT_MAX_SIZE.  Create .got.plt on VxWorks.
	(is_gott_symbol): New function.
	(mips_elf_calculate_relocation): Use a dynobj local variable.
	Update the calls to mips_elf_local_got_index, mips_elf_got16_entry and
	mips_elf_got_page_entry.  Set G to the .got.plt entry when calculating
	VxWorks R_MIPS_CALL* relocations.  Calculate and use G for all GOT
	relocations on VxWorks.  Add dynamic relocations for references
	to the VxWorks __GOTT_BASE__ and __GOTT_INDEX__ symbols.  Don't
	create dynamic relocations for R_MIPS_32, R_MIPS_REL32 or R_MIPS_64
	in VxWorks executables.
	(mips_elf_allocate_dynamic_relocations): Add a bfd_link_info argument.
	Use MIPS_ELF_RELA_SIZE to calculate the size of a VxWorks entry.
	Don't allocate a null entry on VxWorks.
	(mips_elf_create_dynamic_relocation): Update the call to
	mips_elf_rel_dyn_section.  Use absolute rather than relative
	relocations for VxWorks, and make them RELA rather than REL.
	(_bfd_mips_elf_create_dynamic_sections): Don't make .dynamic
	read-only on VxWorks.  Update the call to mips_elf_rel_dyn_section.
	Create the .plt, .rela.plt, .dynbss and .rela.bss sections on
	VxWorks.  Likewise create the _PROCEDURE_LINKAGE_TABLE symbol.
	Call elf_vxworks_create_dynamic_sections for VxWorks and
	initialize the plt_header_size and plt_entry_size fields.
	(_bfd_mips_elf_check_relocs): Don't allow GOT relocations to be
	used in VxWorks executables.  Don't allocate dynamic relocations
	for R_MIPS_32, R_MIPS_REL32 or R_MIPS_64 in VxWorks executables.
	Set is_relocation_target for each symbol referenced by a relocation.
	Allocate .rela.dyn entries for relocations against the special
	VxWorks __GOTT_BASE__ and __GOTT_INDEX__ symbols.  Create GOT
	entries for all VxWorks R_MIPS_GOT16 relocations.  Don't allocate
	a global GOT entry for symbols mentioned in VxWorks R_MIPS_CALL*,
	R_MIPS_32, R_MIPS_REL32 or R_MIPS_64 relocations.  Update the calls
	to mips_elf_rel_dyn_section and mips_elf_allocate_dynamic_relocations.
	Set is_branch_target for symbols mentioned in R_MIPS_PC16 or R_MIPS_26
	relocations.  Don't set no_fn_stub on VxWorks.
	(_bfd_mips_elf_adjust_dynamic_symbol): Update the call to
	mips_elf_allocate_dynamic_relocations.
	(_bfd_mips_vxworks_adjust_dynamic_symbol): New function.
	(_bfd_mips_elf_always_size_sections): Do not allocate GOT page
	entries for VxWorks, and do not create multiple GOTs.
	(_bfd_mips_elf_size_dynamic_sections): Use MIPS_ELF_REL_DYN_NAME.
	Handle .got specially for VxWorks.  Update the uses of
	MIPS_RESERVED_GOTNO and mips_elf_allocate_dynamic_relocations.
	Check for sgotplt and splt.  Allocate the .rel(a).dyn contents last,
	once its final size is known.  Set DF_TEXTREL for VxWorks.  Add
	DT_RELA, DT_RELASZ, DT_RELAENT, DT_PLTREL, DT_PLTRELSZ and DT_JMPREL
	tags on VxWorks.  Do not add the MIPS-specific tags for VxWorks.
	(_bfd_mips_vxworks_finish_dynamic_symbol): New function.
	(mips_vxworks_finish_exec_plt): Likewise.
	(mips_vxworks_finish_shared_plt): Likewise.
	(_bfd_mips_elf_finish_dynamic_sections): Remove an unncessary call
	to mips_elf_rel_dyn_section.  Use a VxWorks-specific value of
	DT_PLTGOT.  Handle DT_RELA, DT_RELASZ, DT_RELAENT, DT_PLTREL,
	DT_PLTRELSZ and DT_JMPREL.  Update the uses of MIPS_RESERVED_GOTNO
	and mips_elf_rel_dyn_section.  Use a different GOT header for
	VxWorks.  Don't sort .rela.dyn on VxWorks.  Finish the PLT on VxWorks.
	(_bfd_mips_elf_link_hash_table_create): Initialize the new
	mips_elf_link_hash_table fields.
	(_bfd_mips_vxworks_link_hash_table_create): New function.
	(_bfd_mips_elf_final_link): Set the GP value to _GLOBAL_OFFSET_TABLE_
	on VxWorks.  Update the call to ELF_MIPS_GP_OFFSET.
	* elfxx-mips.h (_bfd_mips_vxworks_adjust_dynamic_symbol): Declare.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_vxworks_link_hash_table_create): Likewise.
	* libbfd.h: Regenerate.
	* Makefile.am (elfxx-mips.lo): Depend on elf-vxworks.h.
	(elf32-mips.lo): Likewise.
	* Makefile.in: Regenerate.
	* reloc.c (BFD_RELOC_MIPS_COPY, BFD_RELOC_MIPS_JUMP_SLOT): Declare.
	* targets.c (bfd_elf32_bigmips_vxworks_vec): Declare.
	(bfd_elf32_littlemips_vxworks_vec): Likewise.
	(_bfd_target_vector): Add entries for them.

gas/
	* config/tc-mips.c (mips_target_format): Handle vxworks targets.
	(md_begin): Complain about -G being used for PIC.  Don't change
	the text, data and bss alignments on VxWorks.
	(reloc_needs_lo_p): Don't return true for R_MIPS_GOT16 when
	generating VxWorks PIC.
	(load_address): Extend SVR4_PIC handling to VXWORKS_PIC.
	(macro): Likewise, but do not treat la $25 specially for
	VxWorks PIC, and do not handle jal.
	(OPTION_MVXWORKS_PIC): New macro.
	(md_longopts): Add -mvxworks-pic.
	(md_parse_option): Don't complain about using PIC and -G together here.
	Handle OPTION_MVXWORKS_PIC.
	(md_estimate_size_before_relax): Always use the first relaxation
	sequence on VxWorks.
	* config/tc-mips.h (VXWORKS_PIC): New.

gas/testsuite/
	* gas/mips/vxworks1.s, gas/mips/vxworks1.d,
	* gas/mips/vxworks1-xgot.d: New tests.
	* gas/mips/mips.exp: Run them.  Do not run other tests on VxWorks.

include/elf/
	* mips.h (R_MIPS_COPY, R_MIPS_JUMP_SLOT): New relocs.

ld/
	* configure.tgt (mips*el-*-vxworks*, mips*-*-vxworks*): Use
	separate VxWorks emulations.
	* emulparams/elf32ebmipvxworks.sh: New file.
	* emulparams/elf32elmipvxworks.sh: New file.
	* Makefile.am (ALL_EMULATIONS): Add eelf32ebmipvxworks.o and
	eelf32elmipvxworks.o.
	(eelf32ebmipvxworks.c, eelf32elmipvxworks.c): New rules.
	* Makefile.in: Regenerate.

ld/testsuite/
	* ld-mips/vxworks1.dd, ld-mips/vxworks1.ld, ld-mips/vxworks1-lib.dd,
	* ld-mips/vxworks1-lib.nd, ld-mips/vxworks1-lib.rd,
	* ld-mips/vxworks1-lib.s, ld-mips/vxworks1.rd, ld-mips/vxworks1.s,
	* ld-mips/vxworks1-static.d, ld-mips/vxworks2.s, ld-mips/vxworks2.sd,
	* ld-mips/vxworks2-static.sd: New tests.
	* ld-mips/mips-elf.exp: Run them.
@
text
@d8164 1
a8164 1
      char *loc;
@


1.162
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d37 1
d250 6
d293 14
d457 2
a458 2
  (bfd *, bfd *, struct mips_got_info *, asection *, bfd_vma, unsigned long,
   struct mips_elf_link_hash_entry *, int);
d514 4
d568 4
d578 2
a579 1
#define MIPS_RESERVED_GOTNO (2)
d582 2
a583 1
#define ELF_MIPS_GP_OFFSET(abfd) (0x7ff0)
d587 1
a587 1
#define MIPS_ELF_GOT_MAX_SIZE(abfd) (ELF_MIPS_GP_OFFSET(abfd) + 0x7fff)
d670 38
d787 2
d1970 3
a1972 1
/* Returns the dynamic relocation section for DYNOBJ.  */
d1975 1
a1975 1
mips_elf_rel_dyn_section (bfd *dynobj, bfd_boolean create_p)
d1977 1
a1977 1
  static const char dname[] = ".rel.dyn";
d1979 1
d1981 2
d2200 1
a2200 1
  sreloc = mips_elf_rel_dyn_section (dynobj, FALSE);
d2319 35
a2353 4
/* Returns the GOT offset at which the indicated address can be found.
   If there is not yet a GOT entry for this value, create one.  If
   R_SYMNDX refers to a TLS symbol, create a TLS GOT entry instead.
   Returns -1 if no satisfactory GOT offset can be found.  */
d2357 2
a2358 1
			  bfd_vma value, unsigned long r_symndx,
d2367 2
a2368 1
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot, value,
d2462 6
a2467 5
/* Find a GOT entry that is within 32KB of the VALUE.  These entries
   are supposed to be placed at small offsets in the GOT, i.e.,
   within 32KB of GP.  Return the index into the GOT for this page,
   and store the offset from this entry to the desired address in
   OFFSETP, if it is non-NULL.  */
d2471 1
a2471 1
		   bfd_vma value, bfd_vma *offsetp)
d2475 1
a2475 1
  bfd_vma index;
d2480 3
a2482 3
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot,
					   (value + 0x8000)
					   & (~(bfd_vma)0xffff), 0,
d2496 4
a2499 2
/* Find a GOT entry whose higher-order 16 bits are the same as those
   for value.  Return the index into the GOT for this entry.  */
d2503 2
a2504 1
		      bfd_vma value, bfd_boolean external)
d2510 4
d2515 1
a2515 7
    {
      /* Although the ABI says that it is "the high-order 16 bits" that we
	 want, it is really the %high value.  The complete value is
	 calculated with a `addiu' of a LO16 relocation, just as with a
	 HI16/LO16 pair.  */
      value = mips_elf_high (value) << 16;
    }
d2519 3
a2521 2
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot, value, 0, NULL,
					   R_MIPS_GOT16);
d2546 4
a2549 3
/* Create a local GOT entry for VALUE.  Return the index of the entry,
   or -1 if it could not be created.  If R_SYMNDX refers to a TLS symbol,
   create a TLS entry instead.  */
d2552 4
a2555 4
mips_elf_create_local_got_entry (bfd *abfd, bfd *ibfd,
				 struct mips_got_info *gg,
				 asection *sgot, bfd_vma value,
				 unsigned long r_symndx,
d2561 3
d2636 27
d3038 1
a3038 1
	   >= MIPS_ELF_GOT_MAX_SIZE (bfd2got->bfd))
d3353 1
a3353 1
  got_per_bfd_arg.max_count = ((MIPS_ELF_GOT_MAX_SIZE (abfd)
d3355 1
a3355 1
			       - MIPS_RESERVED_GOTNO - pages);
d3490 1
a3490 1
      assign += MIPS_RESERVED_GOTNO;
d3686 3
d3738 2
a3739 2
  g->local_gotno = MIPS_RESERVED_GOTNO;
  g->assigned_gotno = MIPS_RESERVED_GOTNO;
d3751 11
d3765 13
d3840 5
d4094 2
a4095 2
	  g = mips_elf_local_got_index (abfd, input_bfd, info, 0, 0, NULL,
					r_type);
d4101 37
a4137 26
	  /* GOT_PAGE may take a non-zero addend, that is ignored in a
	     GOT_PAGE relocation that decays to GOT_DISP because the
	     symbol turns out to be global.  The addend is then added
	     as GOT_OFST.  */
	  BFD_ASSERT (addend == 0 || r_type == R_MIPS_GOT_PAGE);
	  g = mips_elf_global_got_index (elf_hash_table (info)->dynobj,
					 input_bfd,
					 (struct elf_link_hash_entry *) h,
					 r_type, info);
	  if (h->tls_type == GOT_NORMAL
	      && (! elf_hash_table(info)->dynamic_sections_created
		  || (info->shared
		      && (info->symbolic || h->root.forced_local)
		      && h->root.def_regular)))
	    {
	      /* This is a static link or a -Bsymbolic link.  The
		 symbol is defined locally, or was forced to be local.
		 We must initialize this entry in the GOT.  */
	      bfd *tmpbfd = elf_hash_table (info)->dynobj;
	      asection *sgot = mips_elf_got_section (tmpbfd, FALSE);
	      MIPS_ELF_PUT_WORD (tmpbfd, symbol, sgot->contents + g);
	    }
	}
      else if (r_type == R_MIPS_GOT16 || r_type == R_MIPS_CALL16)
	/* There's no need to create a local GOT entry here; the
	   calculation for a local GOT16 entry does not involve G.  */
d4141 2
a4142 3
	  g = mips_elf_local_got_index (abfd, input_bfd,
					info, symbol + addend, r_symndx, h,
					r_type);
d4148 1
a4148 2
      g = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					  abfd, input_bfd, g);
d4161 2
a4162 4
      if (elf_hash_table (info)->dynobj)
	gp += mips_elf_adjust_gp (abfd,
				  mips_elf_got_info
				  (elf_hash_table (info)->dynobj, NULL),
d4173 21
d4209 2
a4210 1
	   || (elf_hash_table (info)->dynamic_sections_created
d4221 5
a4225 1
	     linker.  */
d4377 3
a4379 1
      if (local_p)
a4382 3
	  /* The special case is when the symbol is forced to be local.  We
	     need the full address in the GOT since no R_MIPS_LO16 relocation
	     follows.  */
d4385 1
a4385 1
	  value = mips_elf_got16_entry (abfd, input_bfd, info,
d4390 1
a4390 2
	    = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					      abfd, input_bfd, value);
d4440 2
a4441 1
      value = mips_elf_got_page (abfd, input_bfd, info, symbol + addend, NULL);
d4444 1
a4444 2
      value = mips_elf_got_offset_from_index (elf_hash_table (info)->dynobj,
					      abfd, input_bfd, value);
d4450 2
a4451 1
	mips_elf_got_page (abfd, input_bfd, info, symbol + addend, &value);
d4636 1
a4636 1
/* Add room for N relocations to the .rel.dyn section in ABFD.  */
d4639 2
a4640 1
mips_elf_allocate_dynamic_relocations (bfd *abfd, unsigned int n)
d4643 1
d4645 2
a4646 1
  s = mips_elf_rel_dyn_section (abfd, FALSE);
d4649 3
a4651 1
  if (s->size == 0)
d4653 7
a4659 3
      /* Make room for a null element.  */
      s->size += MIPS_ELF_REL_SIZE (abfd);
      ++s->reloc_count;
a4660 1
  s->size += n * MIPS_ELF_REL_SIZE (abfd);
d4682 1
d4684 1
d4687 1
a4687 1
  sreloc = mips_elf_rel_dyn_section (dynobj, FALSE);
d4772 9
a4780 4
  /* The relocation is always an REL32 relocation because we don't
     know where the shared library will wind up at load-time.  */
  outrel[0].r_info = ELF_R_INFO (output_bfd, (unsigned long) indx,
				 R_MIPS_REL32);
d4818 9
d5843 1
d5845 1
d5849 3
a5851 3
  /* Mips ABI requests the .dynamic section to be read only.  */
  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s != NULL)
d5853 6
a5858 2
      if (! bfd_set_section_flags (abfd, s, flags))
	return FALSE;
d5865 1
a5865 1
  if (! mips_elf_rel_dyn_section (elf_hash_table (info)->dynobj, TRUE))
d5986 39
d6046 1
d6051 1
d6293 8
d6306 3
d6310 1
a6310 1
		  && (info->shared || h != NULL)
d6320 22
a6341 3
      if (!h && (r_type == R_MIPS_CALL_LO16
		 || r_type == R_MIPS_GOT_LO16
		 || r_type == R_MIPS_GOT_DISP))
d6347 2
a6348 1
	     R_MIPS_CALL16.  We don't count R_MIPS_GOT_HI16, or
d6373 5
a6377 2
	      /* This symbol requires a global offset table entry.  */
	      if (! mips_elf_record_global_got_symbol (h, abfd, info, g, 0))
d6463 4
a6466 1
	  if ((info->shared || h != NULL)
d6471 1
a6471 1
		  sreloc = mips_elf_rel_dyn_section (dynobj, TRUE);
d6480 2
a6481 3
		     relocs.  We make room for this reloc in the
		     .rel.dyn reloc section.  */
		  mips_elf_allocate_dynamic_relocations (dynobj, 1);
d6506 4
a6509 2
		 dynamic relocations against it.  */
	      if (h != NULL)
d6526 5
d6532 4
d6563 15
a6577 18
         related to taking the function's address.  */
      switch (r_type)
	{
	default:
	  if (h != NULL)
	    {
	      struct mips_elf_link_hash_entry *mh;

	      mh = (struct mips_elf_link_hash_entry *) h;
	      mh->no_fn_stub = TRUE;
	    }
	  break;
	case R_MIPS_CALL16:
	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	case R_MIPS_JALR:
	  break;
	}
d6804 2
a6805 2
      mips_elf_allocate_dynamic_relocations (dynobj,
					     hmips->possibly_dynamic_relocs);
d6870 154
d7043 3
d7104 9
a7112 3
  /* Assume there are two loadable segments consisting of
     contiguous sections.  Is 5 enough?  */
  local_gotno = (loadable_size >> 16) + 5;
d7133 4
a7136 1
  if (s->size > MIPS_ELF_GOT_MAX_SIZE (output_bfd))
d7158 1
a7158 1
  asection *s;
d7160 1
d7162 1
d7184 1
d7205 1
a7205 1
                 If the relocation section is .rel.dyn, we always
d7215 1
a7215 1
		  || strcmp (outname, ".rel.dyn") == 0)
d7220 1
a7220 1
	      if (strcmp (name, ".rel.dyn") != 0)
d7232 17
a7248 1
      else if (strncmp (name, ".got", 4) == 0)
d7293 1
a7293 1
				  + MIPS_RESERVED_GOTNO);
d7313 2
a7314 1
	    mips_elf_allocate_dynamic_relocations (dynobj, needed_relocs);
d7333 3
a7335 1
      else if (strncmp (name, ".init", 5) != 0)
d7350 8
d7367 11
d7407 1
a7407 1
      if (reltext && SGI_COMPAT (output_bfd))
d7419 1
a7419 1
      if (mips_elf_rel_dyn_section (dynobj, FALSE))
d7421 17
a7437 2
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_REL, 0))
	    return FALSE;
d7439 2
a7440 2
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELSZ, 0))
	    return FALSE;
d7442 3
a7444 2
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELENT, 0))
	    return FALSE;
d7446 6
d7453 9
a7461 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_VERSION, 0))
	return FALSE;
d7463 2
a7464 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_FLAGS, 0))
	return FALSE;
d7466 2
a7467 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_BASE_ADDRESS, 0))
	return FALSE;
d7469 2
a7470 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LOCAL_GOTNO, 0))
	return FALSE;
d7472 2
a7473 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_SYMTABNO, 0))
	return FALSE;
d7475 2
a7476 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_UNREFEXTNO, 0))
	return FALSE;
d7478 2
a7479 2
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_GOTSYM, 0))
	return FALSE;
d7481 3
a7483 3
      if (IRIX_COMPAT (dynobj) == ict_irix5
	  && ! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_HIPAGENO, 0))
	return FALSE;
d7485 6
a7490 5
      if (IRIX_COMPAT (dynobj) == ict_irix6
	  && (bfd_get_section_by_name
	      (dynobj, MIPS_ELF_OPTIONS_SECTION_NAME (dynobj)))
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_OPTIONS, 0))
	return FALSE;
d8146 262
d8418 1
d8420 1
a8462 2
	      s = mips_elf_rel_dyn_section (dynobj, FALSE);
	      BFD_ASSERT (s != NULL);
d8466 5
d8479 14
a8492 3
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
d8558 1
a8558 1
	      dyn.d_un.d_val = g->local_gotno - MIPS_RESERVED_GOTNO;
d8571 23
a8604 3
  /* The first entry of the global offset table will be filled at
     runtime. The second entry will be used by some runtime loaders.
     This isn't the case of IRIX rld.  */
d8607 25
a8631 3
      MIPS_ELF_PUT_WORD (output_bfd, 0, sgot->contents);
      MIPS_ELF_PUT_WORD (output_bfd, 0x80000000,
			 sgot->contents + MIPS_ELF_GOT_SIZE (output_bfd));
d8705 1
a8705 1
	      s = mips_elf_rel_dyn_section (dynobj, FALSE);
d8759 5
a8763 6
    /* We need to sort the entries of the dynamic relocation section.  */

    s = mips_elf_rel_dyn_section (dynobj, FALSE);

    if (s != NULL
	&& s->size > (bfd_vma)2 * MIPS_ELF_REL_SIZE (output_bfd))
d8765 5
a8769 1
	reldyn_sorting_bfd = output_bfd;
d8771 9
a8779 6
	if (ABI_64_P (output_bfd))
	  qsort ((Elf64_External_Rel *) s->contents + 1, s->reloc_count - 1,
		 sizeof (Elf64_Mips_External_Rel), sort_dynamic_relocs_64);
	else
	  qsort ((Elf32_External_Rel *) s->contents + 1, s->reloc_count - 1,
		 sizeof (Elf32_External_Rel), sort_dynamic_relocs);
d8783 7
d9857 9
d9869 18
d9909 1
d9926 1
d9977 8
d9996 1
a9996 1
	  elf_gp (abfd) = lo + ELF_MIPS_GP_OFFSET (abfd);
d10728 6
@


1.162.2.1
log
@
2006-07-27  Carlos O'Donell  <carlos@@codesourcery.com>

	bfd/
	* elfxx-mips.c (_bfd_mips_elf_print_private_bfd_data):
	Print EF_MIPS_NOREORDER, EF_MIPS_PIC, EF_MIPS_CPIC, EF_MIPS_XGOT
	and EF_MIPS_UCODE.
@
text
@a10009 15
  if (elf_elfheader (abfd)->e_flags & EF_MIPS_NOREORDER)
    fprintf (file, _(" [.noreorder]"));

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_PIC)
    fprintf (file, _(" [PIC]"));

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_CPIC)
    fprintf (file, _(" [CPIC]"));

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_XGOT)
    fprintf (file, _(" [XGOT]"));

  if (elf_elfheader (abfd)->e_flags & EF_MIPS_UCODE)
    fprintf (file, _(" [UCODE]"));

@


1.162.2.2
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a36 1
#include "elf-vxworks.h"
d46 2
a47 33
/* This structure is used to hold information about one GOT entry.
   There are three types of entry:

      (1) absolute addresses
	    (abfd == NULL)
      (2) SYMBOL + OFFSET addresses, where SYMBOL is local to an input bfd
	    (abfd != NULL, symndx >= 0)
      (3) global and forced-local symbols
	    (abfd != NULL, symndx == -1)

   Type (3) entries are treated differently for different types of GOT.
   In the "master" GOT -- i.e.  the one that describes every GOT
   reference needed in the link -- the mips_got_entry is keyed on both
   the symbol and the input bfd that references it.  If it turns out
   that we need multiple GOTs, we can then use this information to
   create separate GOTs for each input bfd.

   However, we want each of these separate GOTs to have at most one
   entry for a given symbol, so their type (3) entries are keyed only
   on the symbol.  The input bfd given by the "abfd" field is somewhat
   arbitrary in this case.

   This means that when there are multiple GOTs, each GOT has a unique
   mips_got_entry for every symbol within it.  We can therefore use the
   mips_got_entry fields (tls_type and gotidx) to track the symbol's
   GOT index.

   However, if it turns out that we need only a single GOT, we continue
   to use the master GOT to describe it.  There may therefore be several
   mips_got_entries for the same symbol, each with a different input bfd.
   We want to make sure that each symbol gets a unique GOT entry, so when
   there's a single GOT, we use the symbol's hash entry, not the
   mips_got_entry fields, to track a symbol's GOT index.  */
a248 6
  /* Are we referenced by some kind of relocation?  */
  bfd_boolean is_relocation_target;

  /* Are we referenced by branch relocations?  */
  bfd_boolean is_branch_target;

a285 16
  /* True if we're generating code for VxWorks.  */
  bfd_boolean is_vxworks;
  /* Shortcuts to some dynamic sections, or NULL if they are not
     being used.  */
  asection *srelbss;
  asection *sdynbss;
  asection *srelplt;
  asection *srelplt2;
  asection *sgotplt;
  asection *splt;
  /* The size of the PLT header in bytes (VxWorks only).  */
  bfd_vma plt_header_size;
  /* The size of a PLT entry in bytes (VxWorks only).  */
  bfd_vma plt_entry_size;
  /* The size of a function stub entry in bytes.  */
  bfd_vma function_stub_size;
d436 2
a437 2
  (bfd *, struct bfd_link_info *, bfd *, struct mips_got_info *, asection *,
   asection *, bfd_vma, unsigned long, struct mips_elf_link_hash_entry *, int);
a485 5
/* Whether the section is readonly.  */
#define MIPS_ELF_READONLY_SECTION(sec) \
  ((sec->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))		\
   == (SEC_ALLOC | SEC_LOAD | SEC_READONLY))

a492 4
/* The size of an external RELA relocation.  */
#define MIPS_ELF_RELA_SIZE(abfd) \
  (get_elf_backend_data (abfd)->s->sizeof_rela)

a542 4
/* The name of the dynamic relocation section.  */
#define MIPS_ELF_REL_DYN_NAME(INFO) \
  (mips_elf_hash_table (INFO)->is_vxworks ? ".rela.dyn" : ".rel.dyn")

d549 1
a549 2
#define MIPS_RESERVED_GOTNO(INFO) \
  (mips_elf_hash_table (INFO)->is_vxworks ? 3 : 2)
d552 1
a552 2
#define ELF_MIPS_GP_OFFSET(INFO) \
  (mips_elf_hash_table (INFO)->is_vxworks ? 0x0 : 0x7ff0)
d556 1
a556 1
#define MIPS_ELF_GOT_MAX_SIZE(INFO) (ELF_MIPS_GP_OFFSET (INFO) + 0x7fff)
d559 14
a572 19
#define STUB_LW(abfd)							\
  ((ABI_64_P (abfd)							\
    ? 0xdf998010				/* ld t9,0x8010(gp) */	\
    : 0x8f998010))              		/* lw t9,0x8010(gp) */
#define STUB_MOVE(abfd)							\
   ((ABI_64_P (abfd)							\
     ? 0x03e0782d				/* daddu t7,ra */	\
     : 0x03e07821))				/* addu t7,ra */
#define STUB_LUI(VAL) (0x3c180000 + (VAL))	/* lui t8,VAL */
#define STUB_JALR 0x0320f809			/* jalr t9,ra */
#define STUB_ORI(VAL) (0x37180000 + (VAL))	/* ori t8,t8,VAL */
#define STUB_LI16U(VAL) (0x34180000 + (VAL))	/* ori t8,zero,VAL unsigned */
#define STUB_LI16S(abfd, VAL)						\
   ((ABI_64_P (abfd)							\
    ? (0x64180000 + (VAL))	/* daddiu t8,zero,VAL sign extended */	\
    : (0x24180000 + (VAL))))	/* addiu t8,zero,VAL sign extended */

#define MIPS_FUNCTION_STUB_NORMAL_SIZE 16
#define MIPS_FUNCTION_STUB_BIG_SIZE 20
a638 38
/* The format of the first PLT entry in a VxWorks executable.  */
static const bfd_vma mips_vxworks_exec_plt0_entry[] = {
  0x3c190000,	/* lui t9, %hi(_GLOBAL_OFFSET_TABLE_)		*/
  0x27390000,	/* addiu t9, t9, %lo(_GLOBAL_OFFSET_TABLE_)	*/
  0x8f390008,	/* lw t9, 8(t9)					*/
  0x00000000,	/* nop						*/
  0x03200008,	/* jr t9					*/
  0x00000000	/* nop						*/
};

/* The format of subsequent PLT entries.  */
static const bfd_vma mips_vxworks_exec_plt_entry[] = {
  0x10000000,	/* b .PLT_resolver			*/
  0x24180000,	/* li t8, <pltindex>			*/
  0x3c190000,	/* lui t9, %hi(<.got.plt slot>)		*/
  0x27390000,	/* addiu t9, t9, %lo(<.got.plt slot>)	*/
  0x8f390000,	/* lw t9, 0(t9)				*/
  0x00000000,	/* nop					*/
  0x03200008,	/* jr t9				*/
  0x00000000	/* nop					*/
};

/* The format of the first PLT entry in a VxWorks shared object.  */
static const bfd_vma mips_vxworks_shared_plt0_entry[] = {
  0x8f990008,	/* lw t9, 8(gp)		*/
  0x00000000,	/* nop			*/
  0x03200008,	/* jr t9		*/
  0x00000000,	/* nop			*/
  0x00000000,	/* nop			*/
  0x00000000	/* nop			*/
};

/* The format of subsequent PLT entries.  */
static const bfd_vma mips_vxworks_shared_plt_entry[] = {
  0x10000000,	/* b .PLT_resolver	*/
  0x24180000	/* li t8, <pltindex>	*/
};

a717 2
      ret->is_branch_target = FALSE;
      ret->is_relocation_target = FALSE;
d1899 1
a1899 3
/* Return the dynamic relocation section.  If it doesn't exist, try to
   create a new it if CREATE_P, otherwise return NULL.  Also return NULL
   if creation fails.  */
d1902 1
a1902 1
mips_elf_rel_dyn_section (struct bfd_link_info *info, bfd_boolean create_p)
d1904 1
a1904 1
  const char *dname;
a1905 1
  bfd *dynobj;
a1906 2
  dname = MIPS_ELF_REL_DYN_NAME (info);
  dynobj = elf_hash_table (info)->dynobj;
d2124 1
a2124 1
  sreloc = mips_elf_rel_dyn_section (info, FALSE);
d2243 4
a2246 35
/* Return the offset from _GLOBAL_OFFSET_TABLE_ of the .got.plt entry
   for global symbol H.  .got.plt comes before the GOT, so the offset
   will be negative.  */

static bfd_vma
mips_elf_gotplt_index (struct bfd_link_info *info,
		       struct elf_link_hash_entry *h)
{
  bfd_vma plt_index, got_address, got_value;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  BFD_ASSERT (h->plt.offset != (bfd_vma) -1);

  /* Calculate the index of the symbol's PLT entry.  */
  plt_index = (h->plt.offset - htab->plt_header_size) / htab->plt_entry_size;

  /* Calculate the address of the associated .got.plt entry.  */
  got_address = (htab->sgotplt->output_section->vma
		 + htab->sgotplt->output_offset
		 + plt_index * 4);

  /* Calculate the value of _GLOBAL_OFFSET_TABLE_.  */
  got_value = (htab->root.hgot->root.u.def.section->output_section->vma
	       + htab->root.hgot->root.u.def.section->output_offset
	       + htab->root.hgot->root.u.def.value);

  return got_address - got_value;
}

/* Return the GOT offset for address VALUE, which was derived from
   a symbol belonging to INPUT_SECTION.   If there is not yet a GOT
   entry for this value, create one.  If R_SYMNDX refers to a TLS symbol,
   create a TLS GOT entry instead.  Return -1 if no satisfactory GOT
   offset can be found.  */
d2250 1
a2250 2
			  asection *input_section, bfd_vma value,
			  unsigned long r_symndx,
d2259 1
a2259 2
  entry = mips_elf_create_local_got_entry (abfd, info, ibfd, g, sgot,
					   input_section, value,
d2265 2
a2266 10
    {
      if (entry->symndx == -1 && g->next == NULL)
	/* A type (3) entry in the single-GOT case.  We use the symbol's
	   hash table entry to track the index.  */
	return mips_tls_got_index (abfd, h->tls_got_offset, &h->tls_type,
				   r_type, info, h, value);
      else
	return mips_tls_got_index (abfd, entry->gotidx, &entry->tls_type,
				   r_type, info, h, value);
    }
d2353 5
a2357 6
/* Find a GOT page entry that points to within 32KB of VALUE, which was
   calculated from a symbol belonging to INPUT_SECTION.  These entries
   are supposed to be placed at small offsets in the GOT, i.e., within
   32KB of GP.  Return the index of the GOT entry, or -1 if no entry
   could be created.  If OFFSETP is nonnull, use it to return the
   offset of the GOT entry from VALUE.  */
d2361 1
a2361 1
		   asection *input_section, bfd_vma value, bfd_vma *offsetp)
d2365 1
a2365 1
  bfd_vma page, index;
d2370 3
a2372 3
  page = (value + 0x8000) & ~(bfd_vma) 0xffff;
  entry = mips_elf_create_local_got_entry (abfd, info, ibfd, g, sgot,
					   input_section, page, 0,
d2386 2
a2387 4
/* Find a local GOT entry for an R_MIPS_GOT16 relocation against VALUE,
   which was calculated from a symbol belonging to INPUT_SECTION.
   EXTERNAL is true if the relocation was against a global symbol
   that has been forced local.  */
d2391 1
a2391 2
		      asection *input_section, bfd_vma value,
		      bfd_boolean external)
a2396 4
  /* GOT16 relocations against local symbols are followed by a LO16
     relocation; those against global symbols are not.  Thus if the
     symbol was originally local, the GOT16 relocation should load the
     equivalent of %hi(VALUE), otherwise it should load VALUE itself.  */
d2398 7
a2404 1
    value = mips_elf_high (value) << 16;
d2408 2
a2409 3
  entry = mips_elf_create_local_got_entry (abfd, info, ibfd, g, sgot,
					   input_section, value, 0,
					   NULL, R_MIPS_GOT16);
d2434 3
a2436 4
/* Create and return a local GOT entry for VALUE, which was calculated
   from a symbol belonging to INPUT_SECTON.  Return NULL if it could not
   be created.  If R_SYMNDX refers to a TLS symbol, create a TLS entry
   instead.  */
d2439 4
a2442 4
mips_elf_create_local_got_entry (bfd *abfd, struct bfd_link_info *info,
				 bfd *ibfd, struct mips_got_info *gg,
				 asection *sgot, asection *input_section,
				 bfd_vma value, unsigned long r_symndx,
a2447 3
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
a2519 27
  /* These GOT entries need a dynamic relocation on VxWorks.  Because
     the offset between segments is not fixed, the relocation must be
     against a symbol in the same segment as the original symbol.
     The easiest way to do this is to take INPUT_SECTION's output
     section and emit a relocation against its section symbol.  */
  if (htab->is_vxworks)
    {
      Elf_Internal_Rela outrel;
      asection *s, *output_section;
      bfd_byte *loc;
      bfd_vma got_address;
      int dynindx;

      s = mips_elf_rel_dyn_section (info, FALSE);
      output_section = input_section->output_section;
      dynindx = elf_section_data (output_section)->dynindx;
      got_address = (sgot->output_section->vma
		     + sgot->output_offset
		     + entry.gotidx);

      loc = s->contents + (s->reloc_count++ * sizeof (Elf32_External_Rela));
      outrel.r_offset = got_address;
      outrel.r_info = ELF32_R_INFO (dynindx, R_MIPS_32);
      outrel.r_addend = value - output_section->vma;
      bfd_elf32_swap_reloca_out (abfd, &outrel, loc);
    }

d2895 1
a2895 1
	  >= MIPS_ELF_GOT_MAX_SIZE (arg->info))
d2978 1
a2978 2
/* Set the TLS GOT index for the GOT entry in ENTRYP.  ENTRYP's NEXT field
   is null iff there is just a single GOT.  */
a2984 1
  bfd_vma next_index;
d2990 1
a2990 3
  next_index = MIPS_ELF_GOT_SIZE (entry->abfd) * (long) g->tls_assigned_gotno;

  if (entry->symndx == -1 && g->next == NULL)
d2992 3
a2994 10
      /* A type (3) got entry in the single-GOT case.  We use the symbol's
	 hash table entry to track its index.  */
      if (entry->d.h->tls_type & GOT_TLS_OFFSET_DONE)
	return 1;
      entry->d.h->tls_type |= GOT_TLS_OFFSET_DONE;
      entry->d.h->tls_got_offset = next_index;
    }
  else
    {
      if (entry->tls_type & GOT_TLS_LDM)
d2996 1
a2996 4
	  /* There are separate mips_got_entry objects for each input bfd
	     that requires an LDM entry.  Make sure that all LDM entries in
	     a GOT resolve to the same index.  */
	  if (g->tls_ldm_offset != MINUS_TWO && g->tls_ldm_offset != MINUS_ONE)
d2998 1
a2998 1
	      entry->gotidx = g->tls_ldm_offset;
d3001 1
a3001 1
	  g->tls_ldm_offset = next_index;
a3002 1
      entry->gotidx = next_index;
d3004 14
a3018 1
  /* Account for the entries we've just allocated.  */
d3024 3
d3210 1
a3210 1
  got_per_bfd_arg.max_count = ((MIPS_ELF_GOT_MAX_SIZE (info)
d3212 1
a3212 1
			       - MIPS_RESERVED_GOTNO (info) - pages);
d3347 1
a3347 1
      assign += MIPS_RESERVED_GOTNO (info);
a3351 7
      /* Take g out of the direct list, and push it onto the reversed
	 list that gg points to.  g->next is guaranteed to be nonnull after
	 this operation, as required by mips_elf_initialize_tls_index. */
      gn = g->next;
      g->next = gg->next;
      gg->next = g;

d3357 5
a3361 1
      /* Move onto the next GOT.  It will be a secondary GOT if nonull.  */
a3542 3
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
d3592 2
a3593 2
  g->local_gotno = MIPS_RESERVED_GOTNO (info);
  g->assigned_gotno = MIPS_RESERVED_GOTNO (info);
a3604 11
  /* VxWorks also needs a .got.plt section.  */
  if (htab->is_vxworks)
    {
      s = bfd_make_section_with_flags (abfd, ".got.plt",
				       SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      if (s == NULL || !bfd_set_section_alignment (abfd, s, 4))
	return FALSE;

      htab->sgotplt = s;
    }
a3607 13
/* Return true if H refers to the special VxWorks __GOTT_BASE__ or
   __GOTT_INDEX__ symbols.  These symbols are only special for
   shared objects; they are not used in executables.  */

static bfd_boolean
is_gott_symbol (struct bfd_link_info *info, struct elf_link_hash_entry *h)
{
  return (mips_elf_hash_table (info)->is_vxworks
	  && info->shared
	  && (strcmp (h->root.root.string, "__GOTT_BASE__") == 0
	      || strcmp (h->root.root.string, "__GOTT_INDEX__") == 0));
}

a3669 5
  struct mips_elf_link_hash_table *htab;
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;
  htab = mips_elf_hash_table (info);
d3919 2
a3920 2
	  g = mips_elf_local_got_index (abfd, input_bfd, info,
					sec, 0, 0, NULL, r_type);
d3926 26
a3951 37
	  /* On VxWorks, CALL relocations should refer to the .got.plt
	     entry, which is initialized to point at the PLT stub.  */
	  if (htab->is_vxworks
	      && (r_type == R_MIPS_CALL_HI16
		  || r_type == R_MIPS_CALL_LO16
		  || r_type == R_MIPS_CALL16))
	    {
	      BFD_ASSERT (addend == 0);
	      BFD_ASSERT (h->root.needs_plt);
	      g = mips_elf_gotplt_index (info, &h->root);
	    }
	  else
	    {
	      /* GOT_PAGE may take a non-zero addend, that is ignored in a
		 GOT_PAGE relocation that decays to GOT_DISP because the
		 symbol turns out to be global.  The addend is then added
		 as GOT_OFST.  */
	      BFD_ASSERT (addend == 0 || r_type == R_MIPS_GOT_PAGE);
	      g = mips_elf_global_got_index (dynobj, input_bfd,
					     &h->root, r_type, info);
	      if (h->tls_type == GOT_NORMAL
		  && (! elf_hash_table(info)->dynamic_sections_created
		      || (info->shared
			  && (info->symbolic || h->root.forced_local)
			  && h->root.def_regular)))
		{
		  /* This is a static link or a -Bsymbolic link.  The
		     symbol is defined locally, or was forced to be local.
		     We must initialize this entry in the GOT.  */
		  asection *sgot = mips_elf_got_section (dynobj, FALSE);
		  MIPS_ELF_PUT_WORD (dynobj, symbol, sgot->contents + g);
		}
	    }
	}
      else if (!htab->is_vxworks
	       && (r_type == R_MIPS_CALL16 || (r_type == R_MIPS_GOT16)))
	/* The calculation below does not involve "g".  */
d3955 3
a3957 2
	  g = mips_elf_local_got_index (abfd, input_bfd, info, sec,
					symbol + addend, r_symndx, h, r_type);
d3963 2
a3964 1
      g = mips_elf_got_offset_from_index (dynobj, abfd, input_bfd, g);
d3977 4
a3980 2
      if (dynobj)
	gp += mips_elf_adjust_gp (abfd, mips_elf_got_info (dynobj, NULL),
a3990 21
  /* Relocations against the VxWorks __GOTT_BASE__ and __GOTT_INDEX__
     symbols are resolved by the loader.  Add them to .rela.dyn.  */
  if (h != NULL && is_gott_symbol (info, &h->root))
    {
      Elf_Internal_Rela outrel;
      bfd_byte *loc;
      asection *s;

      s = mips_elf_rel_dyn_section (info, FALSE);
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);

      outrel.r_offset = (input_section->output_section->vma
			 + input_section->output_offset
			 + relocation->r_offset);
      outrel.r_info = ELF32_R_INFO (h->root.dynindx, r_type);
      outrel.r_addend = addend;
      bfd_elf32_swap_reloca_out (abfd, &outrel, loc);
      *valuep = 0;
      return bfd_reloc_ok;
    }

d4006 1
a4006 2
	   || (!htab->is_vxworks
	       && htab->root.dynamic_sections_created
d4017 1
a4017 5
	     linker.

	     In VxWorks executables, references to external symbols
	     are handled using copy relocs or PLT stubs, so there's
	     no need to add a dynamic relocation here.  */
d4169 1
a4169 3
      /* VxWorks does not have separate local and global semantics for
	 R_MIPS_GOT16; every relocation evaluates to "G".  */
      if (!htab->is_vxworks && local_p)
d4173 3
d4178 1
a4178 1
	  value = mips_elf_got16_entry (abfd, input_bfd, info, sec,
d4183 2
a4184 1
	    = mips_elf_got_offset_from_index (dynobj, abfd, input_bfd, value);
d4234 1
a4234 2
      value = mips_elf_got_page (abfd, input_bfd, info, sec,
				 symbol + addend, NULL);
d4237 2
a4238 1
      value = mips_elf_got_offset_from_index (dynobj, abfd, input_bfd, value);
d4244 1
a4244 2
	mips_elf_got_page (abfd, input_bfd, info, sec,
			   symbol + addend, &value);
d4429 1
a4429 1
/* Add room for N relocations to the .rel(a).dyn section in ABFD.  */
d4432 1
a4432 2
mips_elf_allocate_dynamic_relocations (bfd *abfd, struct bfd_link_info *info,
				       unsigned int n)
a4434 1
  struct mips_elf_link_hash_table *htab;
d4436 1
a4436 2
  htab = mips_elf_hash_table (info);
  s = mips_elf_rel_dyn_section (info, FALSE);
d4439 1
a4439 3
  if (htab->is_vxworks)
    s->size += n * MIPS_ELF_RELA_SIZE (abfd);
  else
d4441 3
a4443 7
      if (s->size == 0)
	{
	  /* Make room for a null element.  */
	  s->size += MIPS_ELF_REL_SIZE (abfd);
	  ++s->reloc_count;
	}
      s->size += n * MIPS_ELF_REL_SIZE (abfd);
d4445 1
a4466 1
  struct mips_elf_link_hash_table *htab;
a4467 1
  htab = mips_elf_hash_table (info);
d4470 1
a4470 1
  sreloc = mips_elf_rel_dyn_section (info, FALSE);
d4555 4
a4558 9
  if (htab->is_vxworks)
    /* VxWorks uses non-relative relocations for this.  */
    outrel[0].r_info = ELF32_R_INFO (indx, R_MIPS_32);
  else
    /* The relocation is always an REL32 relocation because we don't
       know where the shared library will wind up at load-time.  */
    outrel[0].r_info = ELF_R_INFO (output_bfd, (unsigned long) indx,
				   R_MIPS_REL32);

a4595 9
  else if (htab->is_vxworks)
    {
      /* VxWorks uses RELA rather than REL dynamic relocations.  */
      outrel[0].r_addend = *addendp;
      bfd_elf32_swap_reloca_out
	(output_bfd, &outrel[0],
	 (sreloc->contents
	  + sreloc->reloc_count * sizeof (Elf32_External_Rela)));
    }
a4639 6
  /* If we've written this relocation for a readonly section,
     we need to set DF_TEXTREL again, so that we do not delete the
     DT_TEXTREL tag.  */
  if (MIPS_ELF_READONLY_SECTION (input_section))
    info->flags |= DF_TEXTREL;

a5611 1
  struct mips_elf_link_hash_table *htab;
a5612 1
  htab = mips_elf_hash_table (info);
d5616 3
a5618 3
  /* The psABI requires a read-only .dynamic section, but the VxWorks
     EABI doesn't.  */
  if (!htab->is_vxworks)
d5620 2
a5621 6
      s = bfd_get_section_by_name (abfd, ".dynamic");
      if (s != NULL)
	{
	  if (! bfd_set_section_flags (abfd, s, flags))
	    return FALSE;
	}
d5628 1
a5628 1
  if (! mips_elf_rel_dyn_section (info, TRUE))
a5748 39
  if (htab->is_vxworks)
    {
      /* Create the .plt, .rela.plt, .dynbss and .rela.bss sections.
	 Also create the _PROCEDURE_LINKAGE_TABLE symbol.  */
      if (!_bfd_elf_create_dynamic_sections (abfd, info))
	return FALSE;

      /* Cache the sections created above.  */
      htab->sdynbss = bfd_get_section_by_name (abfd, ".dynbss");
      htab->srelbss = bfd_get_section_by_name (abfd, ".rela.bss");
      htab->srelplt = bfd_get_section_by_name (abfd, ".rela.plt");
      htab->splt = bfd_get_section_by_name (abfd, ".plt");
      if (!htab->sdynbss
	  || (!htab->srelbss && !info->shared)
	  || !htab->srelplt
	  || !htab->splt)
	abort ();

      /* Do the usual VxWorks handling.  */
      if (!elf_vxworks_create_dynamic_sections (abfd, info, &htab->srelplt2))
	return FALSE;

      /* Work out the PLT sizes.  */
      if (info->shared)
	{
	  htab->plt_header_size
	    = 4 * ARRAY_SIZE (mips_vxworks_shared_plt0_entry);
	  htab->plt_entry_size
	    = 4 * ARRAY_SIZE (mips_vxworks_shared_plt_entry);
	}
      else
	{
	  htab->plt_header_size
	    = 4 * ARRAY_SIZE (mips_vxworks_exec_plt0_entry);
	  htab->plt_entry_size
	    = 4 * ARRAY_SIZE (mips_vxworks_exec_plt_entry);
	}
    }

a5769 1
  struct mips_elf_link_hash_table *htab;
a5773 1
  htab = mips_elf_hash_table (info);
a6014 8
	      if (htab->is_vxworks && !info->shared)
		{
		  (*_bfd_error_handler)
		    (_("%B: GOT reloc at 0x%lx not expected in executables"),
		     abfd, (unsigned long) rel->r_offset);
		  bfd_set_error (bfd_error_bad_value);
		  return FALSE;
		}
a6019 3
	      /* In VxWorks executables, references to external symbols
		 are handled using copy relocs or PLT stubs, so there's
		 no need to add a dynamic relocation here.  */
d6021 1
a6021 1
		  && (info->shared || (h != NULL && !htab->is_vxworks))
d6031 3
a6033 22
      if (h)
	{
	  ((struct mips_elf_link_hash_entry *) h)->is_relocation_target = TRUE;

	  /* Relocations against the special VxWorks __GOTT_BASE__ and
	     __GOTT_INDEX__ symbols must be left to the loader.  Allocate
	     room for them in .rela.dyn.  */
	  if (is_gott_symbol (info, h))
	    {
	      if (sreloc == NULL)
		{
		  sreloc = mips_elf_rel_dyn_section (info, TRUE);
		  if (sreloc == NULL)
		    return FALSE;
		}
	      mips_elf_allocate_dynamic_relocations (dynobj, info, 1);
	    }
	}
      else if (r_type == R_MIPS_CALL_LO16
	       || r_type == R_MIPS_GOT_LO16
	       || r_type == R_MIPS_GOT_DISP
	       || (r_type == R_MIPS_GOT16 && htab->is_vxworks))
d6039 1
a6039 2
	     R_MIPS_CALL16, except on VxWorks, where GOT relocations
	     always evaluate to "G".  We don't count R_MIPS_GOT_HI16, or
d6064 2
a6065 5
	      /* VxWorks call relocations point the function's .got.plt
		 entry, which will be allocated by adjust_dynamic_symbol.
		 Otherwise, this symbol requires a global GOT entry.  */
	      if (!htab->is_vxworks
		  && !mips_elf_record_global_got_symbol (h, abfd, info, g, 0))
d6151 1
a6151 4
	  /* In VxWorks executables, references to external symbols
	     are handled using copy relocs or PLT stubs, so there's
	     no need to add a .rela.dyn entry for this relocation.  */
	  if ((info->shared || (h != NULL && !htab->is_vxworks))
d6156 1
a6156 1
		  sreloc = mips_elf_rel_dyn_section (info, TRUE);
d6160 1
d6165 5
a6169 3
		     relocs.  Make room for this reloc in .rel(a).dyn.  */
		  mips_elf_allocate_dynamic_relocations (dynobj, info, 1);
		  if (MIPS_ELF_READONLY_SECTION (sec))
d6182 2
a6183 1
		  if (MIPS_ELF_READONLY_SECTION (sec))
d6192 2
a6193 4
		 dynamic relocations against it.  This does not apply
		 to VxWorks, which does not have the usual coupling
		 between global GOT entries and .dynsym entries.  */
	      if (h != NULL && !htab->is_vxworks)
a6209 5
	case R_MIPS_PC16:
	  if (h)
	    ((struct mips_elf_link_hash_entry *) h)->is_branch_target = TRUE;
	  break;

a6210 4
	  if (h)
	    ((struct mips_elf_link_hash_entry *) h)->is_branch_target = TRUE;
	  /* Fall through.  */

d6238 18
a6255 15
	 related to taking the function's address.  This doesn't apply to
	 VxWorks, where CALL relocs refer to a .got.plt entry instead of
	 a normal .got entry.  */
      if (!htab->is_vxworks && h != NULL)
	switch (r_type)
	  {
	  default:
	    ((struct mips_elf_link_hash_entry *) h)->no_fn_stub = TRUE;
	    break;
	  case R_MIPS_CALL16:
	  case R_MIPS_CALL_HI16:
	  case R_MIPS_CALL_LO16:
	  case R_MIPS_JALR:
	    break;
	  }
a6461 1
  struct mips_elf_link_hash_table *htab;
a6462 1
  htab = mips_elf_hash_table (info);
d6482 2
a6483 2
      mips_elf_allocate_dynamic_relocations
	(dynobj, info, hmips->possibly_dynamic_relocs);
d6515 1
a6515 1
	  s->size += htab->function_stub_size;
a6547 154

/* Likewise, for VxWorks.  */

bfd_boolean
_bfd_mips_vxworks_adjust_dynamic_symbol (struct bfd_link_info *info,
					 struct elf_link_hash_entry *h)
{
  bfd *dynobj;
  struct mips_elf_link_hash_entry *hmips;
  struct mips_elf_link_hash_table *htab;
  unsigned int power_of_two;

  htab = mips_elf_hash_table (info);
  dynobj = elf_hash_table (info)->dynobj;
  hmips = (struct mips_elf_link_hash_entry *) h;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->needs_copy
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* If the symbol is defined by a dynamic object, we need a PLT stub if
     either (a) we want to branch to the symbol or (b) we're linking an
     executable that needs a canonical function address.  In the latter
     case, the canonical address will be the address of the executable's
     load stub.  */
  if ((hmips->is_branch_target
       || (!info->shared
	   && h->type == STT_FUNC
	   && hmips->is_relocation_target))
      && h->def_dynamic
      && h->ref_regular
      && !h->def_regular
      && !h->forced_local)
    h->needs_plt = 1;

  /* Locally-binding symbols do not need a PLT stub; we can refer to
     the functions directly.  */
  else if (h->needs_plt
	   && (SYMBOL_CALLS_LOCAL (info, h)
	       || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
		   && h->root.type == bfd_link_hash_undefweak)))
    {
      h->needs_plt = 0;
      return TRUE;
    }

  if (h->needs_plt)
    {
      /* If this is the first symbol to need a PLT entry, allocate room
	 for the header, and for the header's .rela.plt.unloaded entries.  */
      if (htab->splt->size == 0)
	{
	  htab->splt->size += htab->plt_header_size;
	  if (!info->shared)
	    htab->srelplt2->size += 2 * sizeof (Elf32_External_Rela);
	}

      /* Assign the next .plt entry to this symbol.  */
      h->plt.offset = htab->splt->size;
      htab->splt->size += htab->plt_entry_size;

      /* If the output file has no definition of the symbol, set the
	 symbol's value to the address of the stub.  For executables,
	 point at the PLT load stub rather than the lazy resolution stub;
	 this stub will become the canonical function address.  */
      if (!h->def_regular)
	{
	  h->root.u.def.section = htab->splt;
	  h->root.u.def.value = h->plt.offset;
	  if (!info->shared)
	    h->root.u.def.value += 8;
	}

      /* Make room for the .got.plt entry and the R_JUMP_SLOT relocation.  */
      htab->sgotplt->size += 4;
      htab->srelplt->size += sizeof (Elf32_External_Rela);

      /* Make room for the .rela.plt.unloaded relocations.  */
      if (!info->shared)
	htab->srelplt2->size += 3 * sizeof (Elf32_External_Rela);

      return TRUE;
    }

  /* If a function symbol is defined by a dynamic object, and we do not
     need a PLT stub for it, the symbol's value should be zero.  */
  if (h->type == STT_FUNC
      && h->def_dynamic
      && h->ref_regular
      && !h->def_regular)
    {
      h->root.u.def.value = 0;
      return TRUE;
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */
  if (info->shared)
    return TRUE;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      htab->srelbss->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }

  /* We need to figure out the alignment required for this symbol.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 4)
    power_of_two = 4;

  /* Apply the required alignment.  */
  htab->sdynbss->size = BFD_ALIGN (htab->sdynbss->size,
				   (bfd_size_type) 1 << power_of_two);
  if (power_of_two > bfd_get_section_alignment (dynobj, htab->sdynbss)
      && !bfd_set_section_alignment (dynobj, htab->sdynbss, power_of_two))
    return FALSE;

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = htab->sdynbss;
  h->root.u.def.value = htab->sdynbss->size;

  /* Increment the section size to make room for the symbol.  */
  htab->sdynbss->size += h->size;

  return TRUE;
}
a6548 26
/* Return the number of dynamic section symbols required by OUTPUT_BFD.
   The number might be exact or a worst-case estimate, depending on how
   much information is available to elf_backend_omit_section_dynsym at
   the current linking stage.  */

static bfd_size_type
count_section_dynsyms (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd_size_type count;

  count = 0;
  if (info->shared)
    {
      asection *p;
      const struct elf_backend_data *bed;

      bed = get_elf_backend_data (output_bfd);
      for (p = output_bfd->sections; p ; p = p->next)
	if ((p->flags & SEC_EXCLUDE) == 0
	    && (p->flags & SEC_ALLOC) != 0
	    && !(*bed->elf_backend_omit_section_dynsym) (output_bfd, info, p))
	  ++count;
    }
  return count;
}

a6564 1
  bfd_size_type dynsymcount;
a6566 3
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
a6619 12
  /* Get a worst-case estimate of the number of dynamic symbols needed.
     At this point, dynsymcount does not account for section symbols
     and count_section_dynsyms may overestimate the number that will
     be needed.  */
  dynsymcount = (elf_hash_table (info)->dynsymcount
		 + count_section_dynsyms (output_bfd, info));

  /* Determine the size of one stub entry.  */
  htab->function_stub_size = (dynsymcount > 0x10000
			      ? MIPS_FUNCTION_STUB_BIG_SIZE
			      : MIPS_FUNCTION_STUB_NORMAL_SIZE);

d6623 1
a6623 1
  loadable_size += htab->function_stub_size * (i + 1);
d6625 3
a6627 9
  if (htab->is_vxworks)
    /* There's no need to allocate page entries for VxWorks; R_MIPS_GOT16
       relocations against local symbols evaluate to "G", and the EABI does
       not include R_MIPS_GOT_PAGE.  */
    local_gotno = 0;
  else
    /* Assume there are two loadable segments consisting of contiguous
       sections.  Is 5 enough?  */
    local_gotno = (loadable_size >> 16) + 5;
d6648 1
a6648 4
  /* VxWorks does not support multiple GOTs.  It initializes $gp to
     __GOTT_BASE__[__GOTT_INDEX__], the value of which is set by the
     dynamic loader.  */
  if (!htab->is_vxworks && s->size > MIPS_ELF_GOT_MAX_SIZE (info))
d6670 1
a6670 1
  asection *s, *sreldyn;
a6671 1
  struct mips_elf_link_hash_table *htab;
a6672 1
  htab = mips_elf_hash_table (info);
a6693 1
  sreldyn = NULL;
d6714 1
a6714 1
                 If the relocation section is .rel(a).dyn, we always
d6724 1
a6724 1
		  || strcmp (outname, MIPS_ELF_REL_DYN_NAME (info)) == 0)
d6729 1
a6729 1
	      if (strcmp (name, MIPS_ELF_REL_DYN_NAME (info)) != 0)
d6741 1
a6741 17
      else if (htab->is_vxworks && strcmp (name, ".got") == 0)
	{
	  /* Executables do not need a GOT.  */
	  if (info->shared)
	    {
	      /* Allocate relocations for all but the reserved entries.  */
	      struct mips_got_info *g;
	      unsigned int count;

	      g = mips_elf_got_info (dynobj, NULL);
	      count = (g->global_gotno
		       + g->local_gotno
		       - MIPS_RESERVED_GOTNO (info));
	      mips_elf_allocate_dynamic_relocations (dynobj, info, count);
	    }
	}
      else if (!htab->is_vxworks && strncmp (name, ".got", 4) == 0)
d6786 1
a6786 1
				  + MIPS_RESERVED_GOTNO (info));
d6806 1
a6806 2
	    mips_elf_allocate_dynamic_relocations (dynobj, info,
						   needed_relocs);
d6811 2
a6812 2
	     of .text section.  So put a dummy.  XXX  */
	  s->size += htab->function_stub_size;
d6818 1
a6818 1
	  /* We add a room for __rld_map.  It will be filled in by the
d6825 1
a6825 3
      else if (strncmp (name, ".init", 5) != 0
	       && s != htab->sgotplt
	       && s != htab->splt)
a6839 8
      /* Allocate memory for this section last, since we may increase its
	 size above.  */
      if (strcmp (name, MIPS_ELF_REL_DYN_NAME (info)) == 0)
	{
	  sreldyn = s;
	  continue;
	}

a6848 11
  /* Allocate memory for the .rel(a).dyn section.  */
  if (sreldyn != NULL)
    {
      sreldyn->contents = bfd_zalloc (dynobj, sreldyn->size);
      if (sreldyn->contents == NULL)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return FALSE;
	}
    }

d6878 1
a6878 1
      if (reltext && (SGI_COMPAT (output_bfd) || htab->is_vxworks))
a6884 6

	  /* Clear the DF_TEXTREL flag.  It will be set again if we
	     write out an actual text relocation; we may not, because
	     at this point we do not know whether e.g. any .eh_frame
	     absolute relocations have been converted to PC-relative.  */
	  info->flags &= ~DF_TEXTREL;
d6890 1
a6890 1
      if (htab->is_vxworks)
d6892 2
a6893 6
	  /* VxWorks uses .rela.dyn instead of .rel.dyn.  It does not
	     use any of the DT_MIPS_* tags.  */
	  if (mips_elf_rel_dyn_section (info, FALSE))
	    {
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELA, 0))
		return FALSE;
d6895 2
a6896 2
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELASZ, 0))
		return FALSE;
d6898 2
a6899 14
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELAENT, 0))
		return FALSE;
	    }
	  if (htab->splt->size > 0)
	    {
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTREL, 0))
		return FALSE;

	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_JMPREL, 0))
		return FALSE;

	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_PLTRELSZ, 0))
		return FALSE;
	    }
a6900 6
      else
	{
	  if (mips_elf_rel_dyn_section (info, FALSE))
	    {
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_REL, 0))
		return FALSE;
d6902 2
a6903 2
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELSZ, 0))
		return FALSE;
d6905 2
a6906 3
	      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_RELENT, 0))
		return FALSE;
	    }
d6908 2
a6909 2
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_RLD_VERSION, 0))
	    return FALSE;
d6911 2
a6912 2
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_FLAGS, 0))
	    return FALSE;
d6914 2
a6915 2
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_BASE_ADDRESS, 0))
	    return FALSE;
d6917 2
a6918 2
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LOCAL_GOTNO, 0))
	    return FALSE;
d6920 2
a6921 2
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_SYMTABNO, 0))
	    return FALSE;
d6923 3
a6925 2
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_UNREFEXTNO, 0))
	    return FALSE;
d6927 5
a6931 13
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_GOTSYM, 0))
	    return FALSE;

	  if (IRIX_COMPAT (dynobj) == ict_irix5
	      && ! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_HIPAGENO, 0))
	    return FALSE;

	  if (IRIX_COMPAT (dynobj) == ict_irix6
	      && (bfd_get_section_by_name
		  (dynobj, MIPS_ELF_OPTIONS_SECTION_NAME (dynobj)))
	      && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_OPTIONS, 0))
	    return FALSE;
	}
a7391 2
  int idx;
  struct mips_elf_link_hash_table *htab;
a7392 1
  htab = mips_elf_hash_table (info);
d7398 1
a7398 1
      bfd_byte stub[MIPS_FUNCTION_STUB_BIG_SIZE];
d7408 2
a7409 7
      BFD_ASSERT ((htab->function_stub_size == MIPS_FUNCTION_STUB_BIG_SIZE)
                  || (h->dynindx <= 0xffff));

      /* Values up to 2^31 - 1 are allowed.  Larger values would cause
	 sign extension at runtime in the stub, resulting in a negative
	 index value.  */
      if (h->dynindx & ~0x7fffffff)
d7413 4
a7416 23
      idx = 0;
      bfd_put_32 (output_bfd, STUB_LW (output_bfd), stub + idx);
      idx += 4;
      bfd_put_32 (output_bfd, STUB_MOVE (output_bfd), stub + idx);
      idx += 4;
      if (htab->function_stub_size == MIPS_FUNCTION_STUB_BIG_SIZE)
        {
          bfd_put_32 (output_bfd, STUB_LUI ((h->dynindx >> 16) & 0x7fff),
                      stub + idx);
          idx += 4;
        }
      bfd_put_32 (output_bfd, STUB_JALR, stub + idx);
      idx += 4;

      /* If a large stub is not required and sign extension is not a
         problem, then use legacy code in the stub.  */
      if (htab->function_stub_size == MIPS_FUNCTION_STUB_BIG_SIZE)
	bfd_put_32 (output_bfd, STUB_ORI (h->dynindx & 0xffff), stub + idx);
      else if (h->dynindx & ~0x7fff)
        bfd_put_32 (output_bfd, STUB_LI16U (h->dynindx & 0xffff), stub + idx);
      else
        bfd_put_32 (output_bfd, STUB_LI16S (output_bfd, h->dynindx),
		    stub + idx);
d7419 1
a7419 1
      memcpy (s->contents + h->plt.offset, stub, htab->function_stub_size);
a7586 262
/* Likewise, for VxWorks.  */

bfd_boolean
_bfd_mips_vxworks_finish_dynamic_symbol (bfd *output_bfd,
					 struct bfd_link_info *info,
					 struct elf_link_hash_entry *h,
					 Elf_Internal_Sym *sym)
{
  bfd *dynobj;
  asection *sgot;
  struct mips_got_info *g;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  dynobj = elf_hash_table (info)->dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      bfd_byte *loc;
      bfd_vma plt_address, plt_index, got_address, got_offset, branch_offset;
      Elf_Internal_Rela rel;
      static const bfd_vma *plt_entry;

      BFD_ASSERT (h->dynindx != -1);
      BFD_ASSERT (htab->splt != NULL);
      BFD_ASSERT (h->plt.offset <= htab->splt->size);

      /* Calculate the address of the .plt entry.  */
      plt_address = (htab->splt->output_section->vma
		     + htab->splt->output_offset
		     + h->plt.offset);

      /* Calculate the index of the entry.  */
      plt_index = ((h->plt.offset - htab->plt_header_size)
		   / htab->plt_entry_size);

      /* Calculate the address of the .got.plt entry.  */
      got_address = (htab->sgotplt->output_section->vma
		     + htab->sgotplt->output_offset
		     + plt_index * 4);

      /* Calculate the offset of the .got.plt entry from
	 _GLOBAL_OFFSET_TABLE_.  */
      got_offset = mips_elf_gotplt_index (info, h);

      /* Calculate the offset for the branch at the start of the PLT
	 entry.  The branch jumps to the beginning of .plt.  */
      branch_offset = -(h->plt.offset / 4 + 1) & 0xffff;

      /* Fill in the initial value of the .got.plt entry.  */
      bfd_put_32 (output_bfd, plt_address,
		  htab->sgotplt->contents + plt_index * 4);

      /* Find out where the .plt entry should go.  */
      loc = htab->splt->contents + h->plt.offset;

      if (info->shared)
	{
	  plt_entry = mips_vxworks_shared_plt_entry;
	  bfd_put_32 (output_bfd, plt_entry[0] | branch_offset, loc);
	  bfd_put_32 (output_bfd, plt_entry[1] | plt_index, loc + 4);
	}
      else
	{
	  bfd_vma got_address_high, got_address_low;

	  plt_entry = mips_vxworks_exec_plt_entry;
	  got_address_high = ((got_address + 0x8000) >> 16) & 0xffff;
	  got_address_low = got_address & 0xffff;

	  bfd_put_32 (output_bfd, plt_entry[0] | branch_offset, loc);
	  bfd_put_32 (output_bfd, plt_entry[1] | plt_index, loc + 4);
	  bfd_put_32 (output_bfd, plt_entry[2] | got_address_high, loc + 8);
	  bfd_put_32 (output_bfd, plt_entry[3] | got_address_low, loc + 12);
	  bfd_put_32 (output_bfd, plt_entry[4], loc + 16);
	  bfd_put_32 (output_bfd, plt_entry[5], loc + 20);
	  bfd_put_32 (output_bfd, plt_entry[6], loc + 24);
	  bfd_put_32 (output_bfd, plt_entry[7], loc + 28);

	  loc = (htab->srelplt2->contents
		 + (plt_index * 3 + 2) * sizeof (Elf32_External_Rela));

	  /* Emit a relocation for the .got.plt entry.  */
	  rel.r_offset = got_address;
	  rel.r_info = ELF32_R_INFO (htab->root.hplt->indx, R_MIPS_32);
	  rel.r_addend = h->plt.offset;
	  bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);

	  /* Emit a relocation for the lui of %hi(<.got.plt slot>).  */
	  loc += sizeof (Elf32_External_Rela);
	  rel.r_offset = plt_address + 8;
	  rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_HI16);
	  rel.r_addend = got_offset;
	  bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);

	  /* Emit a relocation for the addiu of %lo(<.got.plt slot>).  */
	  loc += sizeof (Elf32_External_Rela);
	  rel.r_offset += 4;
	  rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_LO16);
	  bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
	}

      /* Emit an R_MIPS_JUMP_SLOT relocation against the .got.plt entry.  */
      loc = htab->srelplt->contents + plt_index * sizeof (Elf32_External_Rela);
      rel.r_offset = got_address;
      rel.r_info = ELF32_R_INFO (h->dynindx, R_MIPS_JUMP_SLOT);
      rel.r_addend = 0;
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);

      if (!h->def_regular)
	sym->st_shndx = SHN_UNDEF;
    }

  BFD_ASSERT (h->dynindx != -1 || h->forced_local);

  sgot = mips_elf_got_section (dynobj, FALSE);
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
  g = mips_elf_section_data (sgot)->u.got_info;
  BFD_ASSERT (g != NULL);

  /* See if this symbol has an entry in the GOT.  */
  if (g->global_gotsym != NULL
      && h->dynindx >= g->global_gotsym->dynindx)
    {
      bfd_vma offset;
      Elf_Internal_Rela outrel;
      bfd_byte *loc;
      asection *s;

      /* Install the symbol value in the GOT.   */
      offset = mips_elf_global_got_index (dynobj, output_bfd, h,
					  R_MIPS_GOT16, info);
      MIPS_ELF_PUT_WORD (output_bfd, sym->st_value, sgot->contents + offset);

      /* Add a dynamic relocation for it.  */
      s = mips_elf_rel_dyn_section (info, FALSE);
      loc = s->contents + (s->reloc_count++ * sizeof (Elf32_External_Rela));
      outrel.r_offset = (sgot->output_section->vma
			 + sgot->output_offset
			 + offset);
      outrel.r_info = ELF32_R_INFO (h->dynindx, R_MIPS_32);
      outrel.r_addend = 0;
      bfd_elf32_swap_reloca_out (dynobj, &outrel, loc);
    }

  /* Emit a copy reloc, if needed.  */
  if (h->needs_copy)
    {
      Elf_Internal_Rela rel;

      BFD_ASSERT (h->dynindx != -1);

      rel.r_offset = (h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset
		      + h->root.u.def.value);
      rel.r_info = ELF32_R_INFO (h->dynindx, R_MIPS_COPY);
      rel.r_addend = 0;
      bfd_elf32_swap_reloca_out (output_bfd, &rel,
				 htab->srelbss->contents
				 + (htab->srelbss->reloc_count
				    * sizeof (Elf32_External_Rela)));
      ++htab->srelbss->reloc_count;
    }

  /* If this is a mips16 symbol, force the value to be even.  */
  if (sym->st_other == STO_MIPS16)
    sym->st_value &= ~1;

  return TRUE;
}

/* Install the PLT header for a VxWorks executable and finalize the
   contents of .rela.plt.unloaded.  */

static void
mips_vxworks_finish_exec_plt (bfd *output_bfd, struct bfd_link_info *info)
{
  Elf_Internal_Rela rela;
  bfd_byte *loc;
  bfd_vma got_value, got_value_high, got_value_low, plt_address;
  static const bfd_vma *plt_entry;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);
  plt_entry = mips_vxworks_exec_plt0_entry;

  /* Calculate the value of _GLOBAL_OFFSET_TABLE_.  */
  got_value = (htab->root.hgot->root.u.def.section->output_section->vma
	       + htab->root.hgot->root.u.def.section->output_offset
	       + htab->root.hgot->root.u.def.value);

  got_value_high = ((got_value + 0x8000) >> 16) & 0xffff;
  got_value_low = got_value & 0xffff;

  /* Calculate the address of the PLT header.  */
  plt_address = htab->splt->output_section->vma + htab->splt->output_offset;

  /* Install the PLT header.  */
  loc = htab->splt->contents;
  bfd_put_32 (output_bfd, plt_entry[0] | got_value_high, loc);
  bfd_put_32 (output_bfd, plt_entry[1] | got_value_low, loc + 4);
  bfd_put_32 (output_bfd, plt_entry[2], loc + 8);
  bfd_put_32 (output_bfd, plt_entry[3], loc + 12);
  bfd_put_32 (output_bfd, plt_entry[4], loc + 16);
  bfd_put_32 (output_bfd, plt_entry[5], loc + 20);

  /* Output the relocation for the lui of %hi(_GLOBAL_OFFSET_TABLE_).  */
  loc = htab->srelplt2->contents;
  rela.r_offset = plt_address;
  rela.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_HI16);
  rela.r_addend = 0;
  bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
  loc += sizeof (Elf32_External_Rela);

  /* Output the relocation for the following addiu of
     %lo(_GLOBAL_OFFSET_TABLE_).  */
  rela.r_offset += 4;
  rela.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_LO16);
  bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
  loc += sizeof (Elf32_External_Rela);

  /* Fix up the remaining relocations.  They may have the wrong
     symbol index for _G_O_T_ or _P_L_T_ depending on the order
     in which symbols were output.  */
  while (loc < htab->srelplt2->contents + htab->srelplt2->size)
    {
      Elf_Internal_Rela rel;

      bfd_elf32_swap_reloca_in (output_bfd, loc, &rel);
      rel.r_info = ELF32_R_INFO (htab->root.hplt->indx, R_MIPS_32);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
      loc += sizeof (Elf32_External_Rela);

      bfd_elf32_swap_reloca_in (output_bfd, loc, &rel);
      rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_HI16);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
      loc += sizeof (Elf32_External_Rela);

      bfd_elf32_swap_reloca_in (output_bfd, loc, &rel);
      rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_MIPS_LO16);
      bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);
      loc += sizeof (Elf32_External_Rela);
    }
}

/* Install the PLT header for a VxWorks shared library.  */

static void
mips_vxworks_finish_shared_plt (bfd *output_bfd, struct bfd_link_info *info)
{
  unsigned int i;
  struct mips_elf_link_hash_table *htab;

  htab = mips_elf_hash_table (info);

  /* We just need to copy the entry byte-by-byte.  */
  for (i = 0; i < ARRAY_SIZE (mips_vxworks_shared_plt0_entry); i++)
    bfd_put_32 (output_bfd, mips_vxworks_shared_plt0_entry[i],
		htab->splt->contents + i * 4);
}

a7596 1
  struct mips_elf_link_hash_table *htab;
a7597 1
  htab = mips_elf_hash_table (info);
a7616 1
      int dyn_to_skip = 0, dyn_skipped = 0;
d7640 2
a7644 5
	    case DT_RELAENT:
	      BFD_ASSERT (htab->is_vxworks);
	      dyn.d_un.d_val = MIPS_ELF_RELA_SIZE (dynobj);
	      break;

d7653 3
a7655 14
	      if (htab->is_vxworks)
		{
		  /* _GLOBAL_OFFSET_TABLE_ is defined to be the beginning
		     of the ".got" section in DYNOBJ.  */
		  s = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (s != NULL);
		  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
		}
	      else
		{
		  s = bfd_get_section_by_name (output_bfd, name);
		  BFD_ASSERT (s != NULL);
		  dyn.d_un.d_ptr = s->vma;
		}
d7721 1
a7721 1
	      dyn.d_un.d_val = g->local_gotno - MIPS_RESERVED_GOTNO (info);
a7733 42
	    case DT_RELASZ:
	      BFD_ASSERT (htab->is_vxworks);
	      /* The count does not include the JUMP_SLOT relocations.  */
	      if (htab->srelplt)
		dyn.d_un.d_val -= htab->srelplt->size;
	      break;

	    case DT_PLTREL:
	      BFD_ASSERT (htab->is_vxworks);
	      dyn.d_un.d_val = DT_RELA;
	      break;

	    case DT_PLTRELSZ:
	      BFD_ASSERT (htab->is_vxworks);
	      dyn.d_un.d_val = htab->srelplt->size;
	      break;

	    case DT_JMPREL:
	      BFD_ASSERT (htab->is_vxworks);
	      dyn.d_un.d_val = (htab->srelplt->output_section->vma
				+ htab->srelplt->output_offset);
	      break;

	    case DT_TEXTREL:
	      /* If we didn't need any text relocations after all, delete
		 the dynamic tag.  */
	      if (!(info->flags & DF_TEXTREL))
		{
		  dyn_to_skip = MIPS_ELF_DYN_SIZE (dynobj);
		  swap_out_p = FALSE;
		}
	      break;

	    case DT_FLAGS:
	      /* If we didn't need any text relocations after all, clear
		 DF_TEXTREL from DT_FLAGS.  */
	      if (!(info->flags & DF_TEXTREL))
		dyn.d_un.d_val &= ~DF_TEXTREL;
	      else
		swap_out_p = FALSE;
	      break;

d7739 1
a7739 1
	  if (swap_out_p || dyn_skipped)
d7741 1
a7741 7
	      (dynobj, &dyn, b - dyn_skipped);

	  if (dyn_to_skip)
	    {
	      dyn_skipped += dyn_to_skip;
	      dyn_to_skip = 0;
	    }
a7742 4

      /* Wipe out any trailing entries if we shifted down a dynamic tag.  */
      if (dyn_skipped > 0)
	memset (b - dyn_skipped, 0, dyn_skipped);
d7745 3
d7750 3
a7752 25
      if (htab->is_vxworks)
	{
	  /* The first entry of the global offset table points to the
	     ".dynamic" section.  The second is initialized by the
	     loader and contains the shared library identifier.
	     The third is also initialized by the loader and points
	     to the lazy resolution stub.  */
	  MIPS_ELF_PUT_WORD (output_bfd,
			     sdyn->output_offset + sdyn->output_section->vma,
			     sgot->contents);
	  MIPS_ELF_PUT_WORD (output_bfd, 0,
			     sgot->contents + MIPS_ELF_GOT_SIZE (output_bfd));
	  MIPS_ELF_PUT_WORD (output_bfd, 0,
			     sgot->contents
			     + 2 * MIPS_ELF_GOT_SIZE (output_bfd));
	}
      else
	{
	  /* The first entry of the global offset table will be filled at
	     runtime. The second entry will be used by some runtime loaders.
	     This isn't the case of IRIX rld.  */
	  MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0, sgot->contents);
	  MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000,
			     sgot->contents + MIPS_ELF_GOT_SIZE (output_bfd));
	}
d7826 1
a7826 1
	      s = mips_elf_rel_dyn_section (info, FALSE);
d7872 2
a7873 2
		BFD_ASSERT (s->size >= htab->function_stub_size);
		dummy_offset = s->size - htab->function_stub_size;
d7875 1
a7875 1
			htab->function_stub_size);
d7880 6
a7885 5
    /* The psABI says that the dynamic relocations must be sorted in
       increasing order of r_symndx.  The VxWorks EABI doesn't require
       this, and because the code below handles REL rather than RELA
       relocations, using it for VxWorks would be outright harmful.  */
    if (!htab->is_vxworks)
d7887 1
a7887 5
	s = mips_elf_rel_dyn_section (info, FALSE);
	if (s != NULL
	    && s->size > (bfd_vma)2 * MIPS_ELF_REL_SIZE (output_bfd))
	  {
	    reldyn_sorting_bfd = output_bfd;
d7889 6
a7894 9
	    if (ABI_64_P (output_bfd))
	      qsort ((Elf64_External_Rel *) s->contents + 1,
		     s->reloc_count - 1, sizeof (Elf64_Mips_External_Rel),
		     sort_dynamic_relocs_64);
	    else
	      qsort ((Elf32_External_Rel *) s->contents + 1,
		     s->reloc_count - 1, sizeof (Elf32_External_Rel),
		     sort_dynamic_relocs);
	  }
a7897 7
  if (htab->is_vxworks && htab->splt->size > 0)
    {
      if (info->shared)
	mips_vxworks_finish_shared_plt (output_bfd, info);
      else
	mips_vxworks_finish_exec_plt (output_bfd, info);
    }
a8964 10
  ret->is_vxworks = FALSE;
  ret->srelbss = NULL;
  ret->sdynbss = NULL;
  ret->srelplt = NULL;
  ret->srelplt2 = NULL;
  ret->sgotplt = NULL;
  ret->splt = NULL;
  ret->plt_header_size = 0;
  ret->plt_entry_size = 0;
  ret->function_stub_size = 0;
a8967 18

/* Likewise, but indicate that the target is VxWorks.  */

struct bfd_link_hash_table *
_bfd_mips_vxworks_link_hash_table_create (bfd *abfd)
{
  struct bfd_link_hash_table *ret;

  ret = _bfd_mips_elf_link_hash_table_create (abfd);
  if (ret)
    {
      struct mips_elf_link_hash_table *htab;

      htab = (struct mips_elf_link_hash_table *) ret;
      htab->is_vxworks = 1;
    }
  return ret;
}
a8989 1
  struct mips_elf_link_hash_table *htab;
a9005 1
  htab = mips_elf_hash_table (info);
d9020 12
a9031 1
      dynsecsymcount = count_section_dynsyms (abfd, info);
a9055 8
      else if (htab->is_vxworks
	       && (h = bfd_link_hash_lookup (info->hash,
					     "_GLOBAL_OFFSET_TABLE_",
					     FALSE, FALSE, TRUE))
	       && h->type == bfd_link_hash_defined)
	elf_gp (abfd) = (h->u.def.section->output_section->vma
			 + h->u.def.section->output_offset
			 + h->u.def.value);
d9067 1
a9067 1
	  elf_gp (abfd) = lo + ELF_MIPS_GP_OFFSET (info);
a9798 6
  /* Don't care about the PIC flags from dynamic objects; they are
     PIC by design.  */
  if ((new_flags & (EF_MIPS_PIC | EF_MIPS_CPIC)) != 0
      && (ibfd->flags & DYNAMIC) != 0)
    new_flags &= ~ (EF_MIPS_PIC | EF_MIPS_CPIC);

@


1.161
log
@bfd/
	* elf32-mips.c (mips_elf_adjust_addend): New function, mostly split
	out from...
	(_bfd_mips_elf_relocate_section): ...here.  Use it to adjust r_addend
	for final links too.

ld/testsuite/
	* ld-mips/emit-relocs-1a.s, ld-mips/emit-relocs-1b.s,
	* ld-mips/emit-relocs-1.ld, ld-mips/emit-relocs-1.d: New test.
	* ld-mips/mips-elf.exp: Run it.
@
text
@d3 1
a3 1
   2003, 2004, 2005 Free Software Foundation, Inc.
d8947 3
a8949 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       mips_elf_link_hash_newfunc))
@


1.160
log
@bfd/
	* elfxx-mips.c (mips_elf_create_got_section): Initialize hgot.
@
text
@d6937 42
d7129 2
a7134 3
	  Elf_Internal_Sym *sym;
	  unsigned long r_symndx;

d7139 1
a7139 29
	  /* Since we're just relocating, all we need to do is copy
	     the relocations back out to the object file, unless
	     they're against a section symbol, in which case we need
	     to adjust by the section offset, or unless they're GP
	     relative in which case we need to adjust by the amount
	     that we're adjusting GP in this relocatable object.  */

	  if (! mips_elf_local_relocation_p (input_bfd, rel, local_sections,
					     FALSE))
	    /* There's nothing to do for non-local relocations.  */
	    continue;

	  if (r_type == R_MIPS16_GPREL
	      || r_type == R_MIPS_GPREL16
	      || r_type == R_MIPS_GPREL32
	      || r_type == R_MIPS_LITERAL)
	    addend -= (_bfd_get_gp_value (output_bfd)
		       - _bfd_get_gp_value (input_bfd));

	  r_symndx = ELF_R_SYM (output_bfd, rel->r_info);
	  sym = local_syms + r_symndx;
	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    /* Adjust the addend appropriately.  */
	    addend += local_sections[r_symndx]->output_offset;

	  if (rela_relocation_p)
	    /* If this is a RELA relocation, just update the addend.  */
	    rel->r_addend = addend;
	  else
d7141 1
@


1.159
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d3579 1
@


1.158
log
@bfd/
	* elfxx-mips.c (mips_elf_initialize_tls_index): If a TLS symbol
	has already been assigned a GOT index, copy that index to the
	current hash table entry.

ld/testsuite/
	* ld-mips-elf/tls-hidden2a.s, ld-mips-elf/tls-hidden2b.s,
	* ld/testsuite/ld-mips-elf/tls-hidden2.d,
	* ld/testsuite/ld-mips-elf/tls-hidden2-got.d: New test.
	* ld-mips-elf/mips-elf.exp: Run it.
@
text
@d7495 1
a7495 1
      || strcmp (name, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.157
log
@2005-12-30  Eric Christopher  <echristo@@apple.com>

	* elfxx-mips.c (mips_elf_record_global_got_symbol): Add assert
	to verify we have a got.
	(_bfd_mips_elf_check_relocs): Add R_MIPS_TLS_GOTTPREL to relocs
	needing a GOT.
@
text
@d2997 4
a3000 1
	    return 1;
@


1.156
log
@PR 1150
* elf-bfd.h (struct elf_backend_data): New field 'elf_backend_ignore_undef_symbol'.
* elfxx-target.h (elf_backend_ignore_undef_symbol): Define to NULL if not
  already defined.
  (elfNN_bed): Initialise the elf_backend_ignore_undef_symbol field.
* elfxx-mips.c (_bfd_mips_elf_ignore_undef_symbol): New function.
* elfxx-mips.h (elf_backend_ignore_undef_symbol): Define and prototype.
* elflink.c (elf_link_output_extsym): Check elf_backend_ignore_undef_symbol
  before reporting an undefined symbol in a shared library.
@
text
@d2640 3
d3986 1
a3986 1
  
d6003 1
d8859 1
a8859 1
	    r = bfd_perform_relocation (input_bfd, *parent, data, 
d9012 1
a9012 1
      
@


1.155
log
@bfd/
	* elf32-mips.c (elf_mips_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf32_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elf64-mips.c (mips_elf64_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(mips_elf64_howto_table_rela): Likewise.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf64_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elfn32-mips.c (elf_mips_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(elf_mips_howto_table_rela): Likewise.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf32_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elfxx-mips.c: Formatting fixes.
	(mips_elf_calculate_relocation): Handle R_MIPS_GNU_REL16_S2
	and R_MIPS_PC16 identically.
gas/
	* config/tc-mips.c (append_insn): Handle BFD_RELOC_16_PCREL_S2.
	(macro_build): Complain for invalid branch displacements.
	(mips_validate_fix): Delete.
	(md_apply_fix): Re-add pcrel support for branches.  Use consistent
	text for misaligned branch targets.
	(tc_gen_reloc: Re-add pcrel support for branches.  Handle strange
	BFD pcrel processing.  Remove error for unresolved branches.
	* config/tc-mips.h (TC_VALIDATE_FIX, mips_validate_fix): Delete.
gas/testsuite/
	* gas/mips/bge.d, gas/mips/bge.s, gas/mips/bgeu.d, gas/mips/bgeu.s,
	gas/mips/blt.d, gas/mips/blt.s, gas/mips/bltu.d,
	gas/mips/bltu.s: Reactivate external branch tests.
	* gas/mips/branch-misc-2.d, gas/mips/branch-misc-2pic.d,
	gas/mips/branch-misc-2-64.d, gas/mips/branch-misc-2pic-64.d: New
	tests.
	* gas/mips/branch-misc-2.l, gas/mips/branch-misc-2pic.l,
	gas/testsuite/gas/mips/branch-misc-2pic.s: Remove.
	* gas/mips/mips.exp: Adjust branch-misc-2 tests.  Add 64-bit
	variants.
@
text
@d10015 8
@


1.154
log
@PR 1150
* readelf.c (get_mips_symbol_other): New function.
  (get_symbol_other): New function.
  (process_symbol_table): Call get_symbol_other() to get a description of the
    st_other field if it contains more information than just the visibility.
* elfxx-mips.c (mips_elf_calculate_relocation): Ignore an undefined symbol if
    it is optional.
  (_bfd_mips_elf_merge_symbol_attribute): Make sure that the optional flag is
    merged as well as the visibility.
* elfxx-mips.h (_bfd_mips_elf_merge_symbol_attribute): Prototype.
  (elf_backend_merge_symbol_attribute): Define.
* mips.h (STO_OPTIONAL): Define.
  (ELF_MIPS_IS_OPTIONAL): Define.
@
text
@a458 1

d2764 1
a2764 1
/* In a multi-got link, determine the GOT to be used for IBDF.  G must
a4036 6
    case R_MIPS_GNU_REL16_S2:
      value = symbol + _bfd_mips_elf_sign_extend (addend, 18) - p;
      overflowed_p = mips_elf_overflow_p (value, 18);
      value = (value >> 2) & howto->dst_mask;
      break;

d4200 4
a4203 2
      value = _bfd_mips_elf_sign_extend (addend, 16) + symbol - p;
      overflowed_p = mips_elf_overflow_p (value, 16);
@


1.153
log
@	* elfxx-mips.c (mips_elf_calculate_relocation): Handle only
	forced local symbols here.
	(mips_elf_create_dynamic_relocation): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Fix typo in comment.
@
text
@d3795 11
d8881 1
a8881 2
			 input_bfd, input_section, (*parent)->address,
			 TRUE)))
d10007 13
@


1.152
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d3921 1
a3921 1
		      && (info->symbolic || h->root.dynindx == -1)
d4486 2
a4487 4
      && (! info->symbolic || !h->root.def_regular)
      /* h->root.dynindx may be -1 if this symbol was marked to
	 become local.  */
      && h->root.dynindx != -1)
d7380 1
a7380 1
      /* FIXME: Can h->dynindex be more than 64K?  */
@


1.151
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d8390 1
a8390 1
_bfd_mips_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
d8396 1
a8396 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
a8410 2
  else
    BFD_ASSERT (indmips->tls_type == 0);
@


1.150
log
@(_bfd_mips_elf_relocate_section): Initialise 'value' to avoid compile time
warning message.
@
text
@d7641 5
a7645 1
	      time ((time_t *) &dyn.d_un.d_val);
@


1.149
log
@bfd/
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Move assert later.
	* elfxx-mips.c (_bfd_mips_elf_hide_symbol): Cope with being called
	without any got section.

ld/testsuite/
	* ld-alpha/tlsbin.rd: Update.
	* ld-alpha/tlsbinr.rd: Update.
	* ld-cris/locref1.d: Update.
	* ld-cris/locref2.d: Update.
	* ld-i386/tlsbin.rd: Update.
	* ld-ia64/tlsbin.rd: Update.
	* ld-powerpc/tlsexe.r: Update.
	* ld-powerpc/tlsexe32.r: Update.
	* ld-powerpc/tlsexetoc.r: Update.
	* ld-s390/tlsbin.rd: Update.
	* ld-s390/tlsbin_64.rd: Update.
	* ld-sparc/tlssunbin32.rd: Update.
	* ld-sparc/tlssunbin64.rd: Update.
	* ld-x86-64/tlsbin.rd: Update.
@
text
@d6945 1
a6945 1
      bfd_vma value;
@


1.148
log
@	* elfxx-mips.c (mips_mach_extends_p): Treat MIPS64 as an extension
	of MIPS32 and MIPS64r2 as an extension of MIPS32r2.
@
text
@d8427 3
a8429 1
  if (dynobj != NULL && force_local && h->root.type != STT_TLS)
a8430 3
      got = mips_elf_got_section (dynobj, FALSE);
      g = mips_elf_section_data (got)->u.got_info;

@


1.147
log
@	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook):  Ignore _gp_disp
	if it is in the *ABS* section.
@
text
@d9664 12
a9675 1
  for (i = 0; extension != base && i < ARRAY_SIZE (mips_mach_extensions); i++)
d9677 5
a9681 1
      extension = mips_mach_extensions[i].base;
d9683 1
a9683 1
  return extension == base;
@


1.146
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d5417 14
@


1.145
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@a6670 1
      bfd_boolean strip;
a6678 2
      strip = FALSE;

d6681 1
a6681 14
	  if (s->size == 0)
	    {
	      /* We only strip the section if the output section name
                 has the same name.  Otherwise, there might be several
                 input sections for this output section.  FIXME: This
                 code is probably not needed these days anyhow, since
                 the linker now does not create empty output sections.  */
	      if (s->output_section != NULL
		  && strcmp (name,
			     bfd_get_section_name (s->output_section->owner,
						   s->output_section)) == 0)
		strip = TRUE;
	    }
	  else
d6805 1
a6805 1
      if (strip)
d6811 3
d6816 1
a6816 1
      if (s->contents == NULL && s->size != 0)
@


1.144
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@a9981 18

const struct bfd_elf_special_section *
_bfd_mips_elf_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					_bfd_mips_elf_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}
@


1.143
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d9972 1
a9972 1
struct bfd_elf_special_section const _bfd_mips_elf_special_sections[] =
d9986 1
a9986 1
  const struct bfd_elf_special_section const *ssect;
@


1.142
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d9972 1
a9972 2
static struct bfd_elf_special_section const
  mips_special_sections_l[]=
d9976 4
d9983 2
a9984 2
static struct bfd_elf_special_section const
  mips_special_sections_m[]=
d9986 1
a9986 3
  { ".mdebug", 7,  0, SHT_MIPS_DEBUG, 0 },
  { NULL,      0,  0, 0,              0 }
};
d9988 3
a9990 6
static struct bfd_elf_special_section const
  mips_special_sections_s[]=
{
  { ".sdata",  6, -2, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".sbss",   5, -2, SHT_NOBITS,     SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
};
d9992 5
a9996 6
static struct bfd_elf_special_section const
  mips_special_sections_u[]=
{
  { ".ucode",  6,  0, SHT_MIPS_UCODE, 0 },
  { NULL,      0,  0, 0,              0 }
};
d9998 2
a9999 31
struct bfd_elf_special_section const *
  _bfd_mips_elf_special_sections[27] =
{
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  mips_special_sections_l,	/* 'l' */
  mips_special_sections_m,	/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  NULL,				/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  mips_special_sections_s,	/* 'm' */
  NULL,				/* 't' */
  mips_special_sections_u,	/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
@


1.141
log
@2005-05-28  David Daney  <ddaney@@avtrex.com>

	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections):  Move
	calculation of DT_RELSZ to occur after all dynamic relocations
	are created.
@
text
@d5853 4
@


1.140
log
@* elfxx-mips.c (_bfd_mips_elf_section_processing): Warn and
stop processing of options if one of invalid size is
encountered.
(_bfd_mips_elf_section_from_shdr): Likewise.
(_bfd_mips_elf_fake_sections): Reset the type of empty special
sections.
@
text
@a7698 12
	    case DT_RELSZ:
	      /* Reduce DT_RELSZ to account for any relocations we
		 decided not to make.  This is for the n64 irix rld,
		 which doesn't seem to apply any relocations if there
		 are trailing null entries.  */
	      s = mips_elf_rel_dyn_section (dynobj, FALSE);
	      dyn.d_un.d_val = (s->reloc_count
				* (ABI_64_P (output_bfd)
				   ? sizeof (Elf64_Mips_External_Rel)
				   : sizeof (Elf32_External_Rel)));
	      break;

d7760 49
@


1.139
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d4990 7
d5211 7
d5256 1
d5259 1
d5361 6
@


1.138
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d8628 14
@


1.137
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d9895 17
a9911 1
struct bfd_elf_special_section const _bfd_mips_elf_special_sections[]=
d9915 5
a9919 2
  { ".lit4",   5,  0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".lit8",   5,  0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
a9920 1
  { ".mdebug", 7,  0, SHT_MIPS_DEBUG, 0 },
d9923 32
@


1.136
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1911 7
a1917 1
      sreloc = bfd_make_section (dynobj, dname);
a1918 7
	  || ! bfd_set_section_flags (dynobj, sreloc,
				      (SEC_ALLOC
				       | SEC_LOAD
				       | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY
				       | SEC_LINKER_CREATED
				       | SEC_READONLY))
d3514 1
a3514 1
      s = bfd_make_section (abfd, ".compact_rel");
a3515 1
	  || ! bfd_set_section_flags (abfd, s, flags)
d3556 1
a3556 1
  s = bfd_make_section (abfd, ".got");
a3557 1
      || ! bfd_set_section_flags (abfd, s, flags)
d5588 3
a5590 1
      s = bfd_make_section (abfd, MIPS_ELF_STUB_SECTION_NAME (abfd));
a5591 1
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_CODE)
d5601 2
a5602 1
      s = bfd_make_section (abfd, ".rld_map");
a5603 1
	  || ! bfd_set_section_flags (abfd, s, flags &~ (flagword) SEC_READONLY)
d9214 3
a9216 1
		  rtproc_sec = bfd_make_section (abfd, ".rtproc");
a9217 1
		      || ! bfd_set_section_flags (abfd, rtproc_sec, flags)
@


1.135
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d26 1
a26 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.134
log
@Update the FSF address in the copyright/GPL notice
@
text
@d965 1
a965 1
  s->link_order_head = NULL;
d6799 1
a6799 1
	  _bfd_strip_section_from_output (info, s);
d8989 1
a8989 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d9032 1
a9032 1
	  o->link_order_head = NULL;
d9105 1
a9105 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d9245 1
a9245 1
	  o->link_order_head = NULL;
d9264 1
a9264 1
	      for (p = o->link_order_head; p != NULL; p = p->next)
d9284 1
a9284 1
	      o->link_order_head = NULL;
d9334 1
a9334 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d9457 1
a9457 1
	  o->link_order_head = NULL;
@


1.133
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@d26 1
a26 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.132
log
@	* elfxx-mips.c (struct mips_elf_link_hash_entry): Update comment.
	(mips_elf_create_local_got_entry): Check h->root.forced_local.
@
text
@a8872 1
  asection **secpp;
d9287 1
a9287 5
	      for (secpp = &abfd->sections;
		   *secpp != o;
		   secpp = &(*secpp)->next)
		;
	      bfd_section_list_remove (abfd, secpp);
@


1.131
log
@	* elfxx-mips.c (MIPS_ELF_OPTIONS_SECTION_NAME_P): New macro.
	(_bfd_mips_elf_section_from_shdr): Use it to check for recognized
	SHT_MIPS_OPTIONS names.  Allow all sections with unrecognised
	section flags.
	(_bfd_mips_elf_fake_sections): Use MIPS_ELF_OPTIONS_SECTION_NAME_P
	to check for SHT_MIPS_OPTIONS sections.
	(_bfd_mips_elf_set_section_contents): Likewise.
@
text
@d245 2
a246 1
  /* Are we forced local?  .*/
d2467 1
a2467 1
  BFD_ASSERT (h == NULL || h->forced_local);
@


1.130
log
@2005-04-04  Eric Christopher  <echristo@@redhat.com>

	* elfxx-mips.c (_bfd_elf_mips_get_relocated_section_contents):
	Clean up gp handling code.
@
text
@d481 5
d5130 1
a5130 1
      if (strcmp (name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) != 0)
d5148 1
a5148 1
      return FALSE;
d5318 1
a5318 1
  else if (strcmp (name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
d8639 1
a8639 1
  if (strcmp (section->name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
@


1.129
log
@2005-03-24  Eric Christopher  <echristo@@redhat.com>

	* elfxx-mips.c: Revert previous patch.

2005-03-24  Eric Christopher  <echristo@@redhat.com>

	* ld-mips-elf/rel32-n32.d: Revert changes.
	* ld-mips-elf/rel32-o32.d: Ditto.
	* ld-mips-elf/rel64.d: Ditto.
@
text
@a8756 19
	  if (bfd_is_abs_section (sym->section) && abfd)
	    {
	      /* The special_function wouldn't get called anyway.  */
	    }
	  else if (!gp_found)
	    {
	      /* The gp isn't there; let the special function code
		 fall over on its own.  */
	    }
	  else if ((*parent)->howto->special_function
		   == _bfd_mips_elf32_gprel16_reloc)
	    {
	      /* bypass special_function call */
	      r = _bfd_mips_elf_gprel16_with_gp (input_bfd, sym, *parent,
						 input_section, relocatable,
						 data, gp);
	      goto skip_bfd_perform_relocation;
	    }
	  /* end mips specific stuff */
d8758 14
a8771 4
	  r = bfd_perform_relocation (input_bfd, *parent, data, input_section,
				      relocatable ? abfd : NULL,
				      &error_message);
	skip_bfd_perform_relocation:
@


1.128
log
@bfd/ChangeLog:

2005-03-23  Eric Christopher  <echristo@@redhat.com>

	* elfxx-mips.c (MIPS_ELF_READONLY_SECTION): New.
	(mips_elf_calculate_relocation): Use. Define DF_TEXTREL
	after emitting relocation.
	(_bfd_mips_elf_adjust_dynamic_symbol): Ditto.
	(_bfd_mips_elf_check_relocs): Remove code to set DF_TEXTREL
	and readonly_reloc.

ld/testsuite/ChangeLog:

2005-03-23  Eric Christopher  <echristo@@redhat.com>

	* ld-mips-elf/textrel-1.s, ld-mips-elf/textrel-1.d: New
	test.
	* ld-mips-elf/mips-elf.exp: Call it.
	* ld-mips-elf/rel32-n32.d: Update for DF_TEXTREL removal.
	* ld-mips-elf/rel32-o32.d: Ditto.
	* ld-mips-elf/rel64.d: Ditto.
@
text
@a480 5
/* Whether the section is readonly.  */
#define MIPS_ELF_READONLY_SECTION(sec)			\
  ((sec->flags & (SEC_ALLOC | SEC_LOAD | SEC_READONLY))	\
   == (SEC_ALLOC | SEC_LOAD | SEC_READONLY))

a4007 4

	  /* If we've written this we need to set DF_TEXTREL here.  */
	  if (MIPS_ELF_READONLY_SECTION (input_section))
	    info->flags |= DF_TEXTREL;
d6104 1
a6104 1

d6106 12
a6117 5
		/* When creating a shared object, we must copy these
		   reloc types into the output file as R_MIPS_REL32
		   relocs.  We make room for this reloc in the
		   .rel.dyn reloc section.  */
		mips_elf_allocate_dynamic_relocations (dynobj, 1);
d6121 1
a6121 1
		  
d6126 5
a6425 2
      asection *sec;
      sec = mips_elf_rel_dyn_section (dynobj, FALSE);
d6428 1
a6428 2

      if (MIPS_ELF_READONLY_SECTION (sec))
@


1.127
log
@2005-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add int to
	elf_backend_section_from_shdr.
	(bfd_elf_section_data): Update comment for this_idx.
	(_bfd_elf_make_section_from_shdr): Add int.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.

	* elf.c (_bfd_elf_make_section_from_shdr): Take section index
	and use it to set this_idx in bfd_elf_section_data.
	(bfd_section_from_shdr): Pass shindex to
	_bfd_elf_make_section_from_shdr.
	(_bfd_elf_section_from_bfd_section): Use this_idx in
	bfd_elf_section_data to find section index.

	* elf32-arm.c (elf32_arm_section_from_shdr): Take section
	index and pass it to _bfd_elf_make_section_from_shdr.
	* elf32-i370.c(i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d481 5
d4013 4
d6113 1
a6113 1
#define MIPS_READONLY_SECTION (SEC_ALLOC | SEC_LOAD | SEC_READONLY)
d6115 5
a6119 12
		{
		  /* When creating a shared object, we must copy these
		     reloc types into the output file as R_MIPS_REL32
		     relocs.  We make room for this reloc in the
		     .rel.dyn reloc section.  */
		  mips_elf_allocate_dynamic_relocations (dynobj, 1);
		  if ((sec->flags & MIPS_READONLY_SECTION)
		      == MIPS_READONLY_SECTION)
		    /* We tell the dynamic linker that there are
		       relocations against the text segment.  */
		    info->flags |= DF_TEXTREL;
		}
d6123 1
a6123 1

a6127 5
		  if ((sec->flags & MIPS_READONLY_SECTION)
		      == MIPS_READONLY_SECTION)
		    /* We need it to tell the dynamic linker if there
		       are relocations against the text segment.  */
		    hmips->readonly_reloc = TRUE;
d6423 2
d6427 2
a6428 1
      if (hmips->readonly_reloc)
@


1.126
log
@	bfd/ChangeLog
	* elfxx-mips.c (mips_elf_calculate_relocation): Handle special
	'__gnu_local_gp' symbol used by gas -mno-shared.

	gas/ChangeLog
	* config/tc-mips.c (macro_build_lui): Use '__gnu_local_gp'
	instead of '_gp' for -mno-shared optimization.
	(s_cpload): Ditto.
	(s_abicalls): Document it in the comment.
	(md_show_usage): Document the -mno-shared option.

	gas/testsuite/ChangeLog
	* gas/mips/elf-rel23b.d: Use '__gnu_local_gp' instead of '_gp'
	for -mno-shared optimization.
	* gas/mips/elf-rel25a.d: Ditto.

	ld/testsuite/ChangeLog
	* ld-mips-elf/multi-got-no-shared-1.s,
	ld-mips-elf/multi-got-no-shared-2.s,
	ld-mips-elf/multi-got-no-shared.d: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d5071 4
a5074 2
_bfd_mips_elf_section_from_shdr (bfd *abfd, Elf_Internal_Shdr *hdr,
				 const char *name)
d5146 1
a5146 1
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
@


1.126.2.1
log
@	* elfxx-mips.c (MIPS_ELF_OPTIONS_SECTION_NAME_P): New macro.
	(_bfd_mips_elf_section_from_shdr): Use it to check for recognized
	SHT_MIPS_OPTIONS names.  Allow all sections with unrecognised
	section flags.
	(_bfd_mips_elf_fake_sections): Use MIPS_ELF_OPTIONS_SECTION_NAME_P
	to check for SHT_MIPS_OPTIONS sections.
	(_bfd_mips_elf_set_section_contents): Likewise.
@
text
@a480 5
/* True if NAME is the recognized name of any SHT_MIPS_OPTIONS section.
   Some IRIX system files do not use MIPS_ELF_OPTIONS_SECTION_NAME.  */
#define MIPS_ELF_OPTIONS_SECTION_NAME_P(NAME) \
  (strcmp (NAME, ".MIPS.options") == 0 || strcmp (NAME, ".options") == 0)

d5123 1
a5123 1
      if (!MIPS_ELF_OPTIONS_SECTION_NAME_P (name))
d5141 1
a5141 1
      break;
d5311 1
a5311 1
  else if (MIPS_ELF_OPTIONS_SECTION_NAME_P (name))
d8632 1
a8632 1
  if (MIPS_ELF_OPTIONS_SECTION_NAME_P (section->name))
@


1.126.2.2
log
@	* elfxx-mips.c (struct mips_elf_link_hash_entry): Update comment.
	(mips_elf_create_local_got_entry): Check h->root.forced_local.
@
text
@d245 1
a245 2
  /* Are we forced local?  This will only be set if we have converted
     the initial global GOT entry to a local GOT entry.  */
d2466 1
a2466 1
  BFD_ASSERT (h == NULL || h->root.forced_local);
@


1.126.2.3
log
@* elfxx-mips.c (_bfd_mips_elf_section_processing): Warn and
stop processing of options if one of invalid size is
encountered.
(_bfd_mips_elf_section_from_shdr): Likewise.
(_bfd_mips_elf_fake_sections): Reset the type of empty special
sections.
@
text
@a4992 7
	  if (intopt.size < sizeof (Elf_External_Options))
	    {
	      (*_bfd_error_handler)
		(_("%B: Warning: bad `%s' option size %u smaller than its header"),
		abfd, MIPS_ELF_OPTIONS_SECTION_NAME (abfd), intopt.size);
	      break;
	    }
a5204 7
	  if (intopt.size < sizeof (Elf_External_Options))
	    {
	      (*_bfd_error_handler)
		(_("%B: Warning: bad `%s' option size %u smaller than its header"),
		abfd, MIPS_ELF_OPTIONS_SECTION_NAME (abfd), intopt.size);
	      break;
	    }
a5242 1
  unsigned int sh_type;
a5244 1
  sh_type = hdr->sh_type;
a5345 6
  /* In the unlikely event a special section is empty it has to lose its
     special meaning.  This may happen e.g. when using `strip' with the
     "--only-keep-debug" option.  */
  if (sec->size > 0 && !(sec->flags & SEC_HAS_CONTENTS))
    hdr->sh_type = sh_type;

@


1.126.2.4
log
@2005-05-28  David Daney  <ddaney@@avtrex.com>

	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections):  Move
	calculation of DT_RELSZ to occur after all dynamic relocations
	are created.
@
text
@d7699 12
a7771 49
  /* The generation of dynamic relocations for the non-primary gots
     adds more dynamic relocations.  We cannot count them until
     here.  */

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_byte *b;
      bfd_boolean swap_out_p;

      BFD_ASSERT (sdyn != NULL);

      for (b = sdyn->contents;
	   b < sdyn->contents + sdyn->size;
	   b += MIPS_ELF_DYN_SIZE (dynobj))
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  /* Read in the current dynamic entry.  */
	  (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);

	  /* Assume that we're going to modify it and write it out.  */
	  swap_out_p = TRUE;

	  switch (dyn.d_tag)
	    {
	    case DT_RELSZ:
	      /* Reduce DT_RELSZ to account for any relocations we
		 decided not to make.  This is for the n64 irix rld,
		 which doesn't seem to apply any relocations if there
		 are trailing null entries.  */
	      s = mips_elf_rel_dyn_section (dynobj, FALSE);
	      dyn.d_un.d_val = (s->reloc_count
				* (ABI_64_P (output_bfd)
				   ? sizeof (Elf64_Mips_External_Rel)
				   : sizeof (Elf32_External_Rel)));
	      break;

	    default:
	      swap_out_p = FALSE;
	      break;
	    }

	  if (swap_out_p)
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out)
	      (dynobj, &dyn, b);
	}
    }

@


1.125
log
@	* elfxx-mips.c (struct mips_got_entry): Add tls_type.
	(struct mips_got_info): Add tls_gotno, tls_assigned_gotno,
	and tls_ldm_offset.
	(struct mips_elf_got_per_bfd_arg): Add global_count.
	(struct mips_elf_count_tls_arg): New.
	(struct mips_elf_hash_sort_data): Update comment for min_got_dynindx.
	(struct mips_elf_link_hash_entry): Add tls_type and tls_got_offset.
	(GOT_NORMAL, GOT_TLS_GD, GOT_TLS_LDM, GOT_TLS_IE)
	(GOT_TLS_OFFSET_DONE, GOT_TLS_DONE): Define.
	(TLS_RELOC_P): Define.
	(TP_OFFSET, DTP_OFFSET): Define.
	(dtprel_base, tprel_base): New functions.
	(mips_elf_link_hash_newfunc): Initialize tls_type.
	(mips_elf_got_entry_hash, mips_elf_got_entry_eq)
	(mips_elf_multi_got_entry_hash, mips_elf_multi_got_entry_eq): Handle
	TLS entries.
	(mips_tls_got_relocs, mips_elf_count_local_tls_relocs)
	(mips_elf_count_global_tls_entries, mips_elf_count_global_tls_relocs)
	(mips_elf_output_dynamic_relocation, mips_elf_initialize_tls_slots)
	(mips_tls_got_index): New functions.
	(mips_elf_local_got_index): Add new R_SYMNDX, H, and R_TYPE
	arguments.  Pass them to mips_elf_create_local_got_entry.  Use
	mips_tls_got_index.
	(mips_elf_global_got_index): Add new R_TYPE and INFO arguments.
	Handle TLS entries.
	(mips_elf_got_page, mips_elf_got16_entry): Update calls to
	mips_elf_create_local_got_entry.
	(mips_elf_create_local_got_entry): Add new R_SYMNDX, H, and R_TYPE
	arguments.  Handle TLS entries.
	(mips_elf_sort_hash_table_f): Add non-TLS assertions.
	(mips_elf_record_local_got_symbol): Add new TLS_FLAG argument.  Handle
	TLS entries.
	(mips_elf_record_global_got_symbol): Likewise.
	(mips_elf_make_got_per_bfd): Initialize new mips_got_info members.
	Count TLS entries.
	(mips_elf_merge_gots): Handle TLS entries when merging.
	(mips_elf_initialize_tls_index): New function.
	(mips_elf_set_global_got_offset): Handle TLS entries.
	(mips_elf_adjust_gp): Handle TLS.
	(mips_elf_multi_got): Remove redundant call to
	mips_elf_resolve_final_got_entries.  Initialize global_count.
	Correct a comment.  Initialize new TLS members of mips_got_info.
	Assign TLS GOT indexes for new GOTs.
	(mips_elf_create_got_section): Initialize new TLS members of
	mips_got_info.
	(mips_elf_calculate_relocation): Handle TLS relocs.
	(_bfd_mips_elf_check_relocs): Likewise.  Update calls to changed
	functions.
	(_bfd_mips_elf_always_size_sections): Handle TLS.
	(_bfd_mips_elf_size_dynamic_sections): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.  Update calls to
	changed functions.
	(_bfd_mips_elf_copy_indirect_symbol): Copy tls_type.
	(_bfd_mips_elf_hide_symbol): Handle TLS.
	* elfn32-mips.c (elf_mips_howto_table_rel, elf_mips_howto_table_rela)
	(mips_reloc_map): Add TLS relocs.
	* elf32-mips.c (elf_mips_howto_table_rel, mips_reloc_map): Likewise.
	* elf64-mips.c (mips_elf64_howto_table_rel)
	(mips_elf64_howto_table_rela, mips_reloc_map): Likewise.
	* reloc.c: Define new MIPS TLS relocations.
	* libbfd.h, bfd-in2.h: Regenerated.
@
text
@d3649 3
d3748 6
d3968 3
@


1.124
log
@Initialise bitfield.
@
text
@d67 8
d90 5
d107 5
d146 5
d163 9
d193 2
a194 2
  /* The least dynamic symbol table index corresponding to a symbol
     with a GOT entry.  */
d247 15
d287 15
d435 2
a436 1
  (bfd *, bfd *, struct mips_got_info *, asection *, bfd_vma);
d654 24
d713 1
d1829 1
d1842 4
d1866 4
a1869 2
       ? (entry->abfd->id
	  + mips_elf_hash_bfd_vma (entry->d.addend))
d1879 8
d1955 284
d2240 3
a2242 2
   If there is not yet a GOT entry for this value, create one.  Returns
   -1 if no satisfactory GOT offset can be found.  */
d2246 2
a2247 1
			  bfd_vma value)
d2255 9
a2263 2
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot, value);
  if (entry)
a2264 2
  else
    return MINUS_ONE;
d2270 2
a2271 1
mips_elf_global_got_index (bfd *abfd, bfd *ibfd, struct elf_link_hash_entry *h)
d2286 1
a2286 1
      if (g->next != gg)
d2291 1
d2296 16
a2311 1
	  return p->gotidx;
d2318 26
a2343 7
  /* Once we determine the global GOT entry with the lowest dynamic
     symbol table index, we must put all dynamic symbols with greater
     indices into the GOT.  That makes it easy to calculate the GOT
     offset.  */
  BFD_ASSERT (h->dynindx >= global_got_dynindx);
  index = ((h->dynindx - global_got_dynindx + g->local_gotno)
	   * MIPS_ELF_GOT_SIZE (abfd));
d2368 2
a2369 1
					   & (~(bfd_vma)0xffff));
d2404 2
a2405 1
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot, value);
d2431 2
a2432 1
   or -1 if it could not be created.  */
d2437 4
a2440 1
				 asection *sgot, bfd_vma value)
d2448 1
d2457 31
d2494 1
d2590 2
d2600 2
d2616 2
a2617 1
				   struct mips_got_info *g)
d2639 1
d2647 4
a2650 1
    return TRUE;
d2658 2
d2668 2
a2669 1
  h->got.offset = 1;
d2679 2
a2680 1
				  struct mips_got_info *g)
d2687 1
d2692 13
a2704 1
    return TRUE;
d2706 19
a2724 1
  entry.gotidx = g->local_gotno++;
d2824 3
d2846 8
a2853 1
  if (entry->symndx >= 0 || entry->d.h->forced_local)
d2876 1
d2878 13
d2894 2
a2895 1
  if (! arg->primary && lcount + gcount <= maxcnt)
d2903 2
a2904 2
  else if (arg->primary
	   && (arg->primary_count + lcount + gcount) <= maxcnt)
d2909 1
d2926 1
d2929 1
a2929 1
	+ arg->primary->global_gotno;
d2933 1
a2933 1
	   && arg->current_count + lcount + gcount <= maxcnt)
d2938 1
d2952 1
d2955 1
a2955 1
	+ arg->current->global_gotno;
d2965 1
a2965 1
      arg->current_count = lcount + gcount;
d2971 49
d3041 5
d3047 2
a3048 1
      && entry->d.h->root.dynindx != -1)
d3163 2
a3164 1
  return (g->local_gotno + g->global_gotno) * MIPS_ELF_GOT_SIZE (abfd);
a3190 1
  mips_elf_resolve_final_got_entries (g);
d3203 4
d3215 1
a3215 1
  /* If we find any suitable primary GOT, create an empty one.  */
d3226 1
d3228 2
d3329 1
d3340 6
a3345 1
      assign = g->local_gotno + g->global_gotno;
d3362 2
a3363 1
		    + gg->next->global_gotno) * MIPS_ELF_GOT_SIZE (abfd);
d3582 1
d3587 1
d3884 3
d3888 8
a3895 1
      if (!local_p)
d3904 7
a3910 5
					 (struct elf_link_hash_entry *) h);
	  if (! elf_hash_table(info)->dynamic_sections_created
	      || (info->shared
		  && (info->symbolic || h->root.dynindx == -1)
		  && h->root.def_regular))
d3927 2
a3928 1
					info, symbol + addend);
d4036 18
d4165 3
d5938 2
d5973 1
a5973 1
						  rel->r_addend, g))
d5995 1
a5995 1
	      if (! mips_elf_record_global_got_symbol (h, abfd, info, g))
d6032 1
a6032 2
	  /* This symbol requires a global offset table entry.  */
	  if (h && ! mips_elf_record_global_got_symbol (h, abfd, info, g))
d6036 42
d6130 1
a6130 1
		  if (! mips_elf_record_global_got_symbol (h, abfd, info, g))
d6496 1
d6565 24
a6588 3
  if (s->size > MIPS_ELF_GOT_MAX_SIZE (output_bfd)
      && ! mips_elf_multi_got (output_bfd, info, g, s, local_gotno))
    return FALSE;
d6703 3
d6731 1
d6735 6
d6742 7
a6748 2
	      if (needed_relocs)
		mips_elf_allocate_dynamic_relocations (dynobj, needed_relocs);
d6750 3
d7379 1
a7379 1
      offset = mips_elf_global_got_index (dynobj, output_bfd, h);
d7383 1
a7383 1
  if (g->next && h->dynindx != -1)
d7394 1
d7707 2
a7708 1
	  bfd_vma index = g->next->local_gotno + g->next->global_gotno;
d8322 5
d8345 1
a8345 1
  if (dynobj != NULL && force_local)
d8363 1
@


1.123
log
@	* elfxx-mips.c (ecoff_swap_rpdr_out, mips_elf_output_extsym,
	mips_elf_create_dynamic_relocation,
	_bfd_mips_elf_size_dynamic_sections, _bfd_mips_elf_final_link):
	Remove #if 0'd code.
@
text
@d3959 1
@


1.122
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@a747 3
#if 0 /* FIXME */
  H_PUT_S32 (abfd, in->exception_info, ex->p_exception_info);
#endif
a1690 3
#if 0 /* FIXME?  */
	  h->esym.ifd = 0;
#endif
a3807 24
#if 0
  /* We begin by assuming that the offset for the dynamic relocation
     is the same as for the original relocation.  We'll adjust this
     later to reflect the correct output offsets.  */
  if (input_section->sec_info_type != ELF_INFO_TYPE_STABS)
    {
      outrel[1].r_offset = rel[1].r_offset;
      outrel[2].r_offset = rel[2].r_offset;
    }
  else
    {
      /* Except that in a stab section things are more complex.
	 Because we compress stab information, the offset given in the
	 relocation may not be the one we want; we must let the stabs
	 machinery tell us the offset.  */
      outrel[1].r_offset = outrel[0].r_offset;
      outrel[2].r_offset = outrel[0].r_offset;
      /* If we didn't need the relocation at all, this value will be
	 -1.  */
      if (outrel[0].r_offset == MINUS_ONE)
	skip = TRUE;
    }
#endif

a6119 16
#if 0
      /* Time stamps in executable files are a bad idea.  */
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_TIME_STAMP, 0))
	return FALSE;
#endif

#if 0 /* FIXME  */
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_ICHECKSUM, 0))
	return FALSE;
#endif

#if 0 /* FIXME  */
      if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_IVERSION, 0))
	return FALSE;
#endif

a8193 41
#if 0
  /* We want to set the GP value for ld -r.  */
  /* On IRIX5, we omit the .options section.  On IRIX6, however, we
     include it, even though we don't process it quite right.  (Some
     entries are supposed to be merged.)  Empirically, we seem to be
     better off including it then not.  */
  if (IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none)
    for (secpp = &abfd->sections; *secpp != NULL; secpp = &(*secpp)->next)
      {
	if (strcmp ((*secpp)->name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0)
	  {
	    for (p = (*secpp)->link_order_head; p != NULL; p = p->next)
	      if (p->type == bfd_indirect_link_order)
		p->u.indirect.section->flags &= ~SEC_HAS_CONTENTS;
	    (*secpp)->link_order_head = NULL;
	    bfd_section_list_remove (abfd, secpp);
	    --abfd->section_count;

	    break;
	  }
      }

  /* We include .MIPS.options, even though we don't process it quite right.
     (Some entries are supposed to be merged.)  At IRIX6 empirically we seem
     to be better off including it than not.  */
  for (secpp = &abfd->sections; *secpp != NULL; secpp = &(*secpp)->next)
    {
      if (strcmp ((*secpp)->name, ".MIPS.options") == 0)
	{
	  for (p = (*secpp)->link_order_head; p != NULL; p = p->next)
	    if (p->type == bfd_indirect_link_order)
	      p->u.indirect.section->flags &=~ SEC_HAS_CONTENTS;
	  (*secpp)->link_order_head = NULL;
	  bfd_section_list_remove (abfd, secpp);
	  --abfd->section_count;

	  break;
	}
    }
#endif

@


1.121
log
@	* mach-o.c (bfd_mach_o_scan): Don't ignore return value of
	bfd_mach_o_scan_start_address.
	* elfxx-ia64.c (elfNN_ia64_relax_brl): Rewrite for 32-bit bfd_vma.
	* elfxx-mips.c: Remove unnecessary prototypes.
	(sort_dynamic_relocs_64): Abort if not BFD64.
@
text
@d821 1
a821 1
      if (! _bfd_ecoff_get_accumulated_ss (handle, ss))
@


1.120
log
@bfd/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* elf32-mips.c (elf_mips16_howto_table_rel): New array for MIPS16
	reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16 relocs and
	R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into elf_mips16_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf32_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf32_rtype_to_howto): Fetch MIPS16 howtos from
	elf_mips16_howto_table_rel.
	* elf64-mips.c (mips16_elf64_howto_table_rel): New array for
	MIPS16 REL reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16
	relocs and R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into mips16_elf64_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_elf64_howto_table_rela): New array for MIPS16 RELA
	reloc howtos.  Add R_MIPS16_26, R_MIPS16_GPREL, R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs and R_MIPS16_GOT16 and R_MIPS16_CALL16
	placeholders.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf64_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf64_rtype_to_howto): Fetch MIPS16 howtos from
	mips16_elf64_howto_table_rela or mips16_elf64_howto_table_rel.
	* elfn32-mips.c (elf_mips16_howto_table_rel): New array for MIPS16
	REL reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16 relocs and
	R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into elf_mips16_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf32_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf_n32_rtype_to_howto): Fetch MIPS16 howtos from
	elf_mips16_howto_table_rela or elf_mips16_howto_table_rel.
	* elfxx-mips.c (_bfd_mips16_elf_reloc_unshuffle): New function to
	handle bit shuffling for MIPS16 relocs.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	(_bfd_mips_elf_lo16_reloc): Use _bfd_mips16_elf_reloc_unshuffle()
	and _bfd_mips16_elf_reloc_shuffle().
	(_bfd_mips_elf_generic_reloc): Likewise.
	(mips_elf_calculate_relocation): Likewise.  Handle R_MIPS16_HI16
	and R_MIPS16_LO16.
	(mips_elf_obtain_contents): Remove bit shuffling.
	(mips_elf_perform_relocation): Likewise; call
	_bfd_mips16_elf_reloc_unshuffle() and _bfd_mips16_elf_reloc_shuffle()
	instead.
	(_bfd_mips_elf_relocate_section): Likewise.  Handle R_MIPS16_HI16
	and R_MIPS16_LO16.
	* elfxx-mips.h (_bfd_mips16_elf_reloc_unshuffle): Declare.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	* reloc.c (BFD_RELOC_MIPS16_HI16): New reloc.
	(BFD_RELOC_MIPS16_HI16_S): Likewise.
	(BFD_RELOC_MIPS16_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

gas/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* config/tc-mips.c (reloc_needs_lo_p): Handle
	BFD_RELOC_MIPS16_HI16_S.
	(fixup_has_matching_lo_p): Handle BFD_RELOC_MIPS16_LO16.
	(append_insn): Add BFD_RELOC_MIPS16_GPREL, BFD_RELOC_MIPS16_HI16_S
	and BFD_RELOC_MIPS16_LO16 to relocs to suppress overflow
	complaints on.
	(mips16_ip): Resolve BFD_RELOC_MIPS16_HI16_S,
	BFD_RELOC_MIPS16_HI16 and BFD_RELOC_MIPS16_LO16 for constants.
	Call my_getSmallExpression() to parse percent operators.
	(percent_op_match, mips_percent_op): Separate definitions.
	(mips16_percent_op): Define percent operators for the MIPS16 mode.
	(parse_relocation): Handle the MIPS16 mode using
	mips16_percent_op.
	(md_apply_fix3): Handle BFD_RELOC_MIPS16_HI16,
	BFD_RELOC_MIPS16_HI16_S and BFD_RELOC_MIPS16_LO16.

gas/testsuite/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* gas/mips/mips16-hilo.d: New test for the R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs.
	* gas/mips/mips16-hilo-n32.d: Likewise, for the n32 ABI.
	* gas/mips/mips16-hilo.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

include/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* elf/mips.h (R_MIPS16_GOT16): New reloc code.
	(R_MIPS16_CALL16): Likewise.
	(R_MIPS16_HI16): Likewise.
	(R_MIPS16_LO16): Likewise.
	(R_MIPS16_min): New fake reloc code.
	(R_MIPS16_max): Likewise.

ld/testsuite/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* ld-mips-elf/mips16-hilo.d: New test for the R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs.
	* ld-mips-elf/mips16-hilo-n32.d: Likewise, for the n32 ABI.
	* ld-mips-elf/mips16-hilo.s: Auxiliary source for the new tests.
	* ld-mips-elf/mips-elf.exp: Run the new tests.
@
text
@a371 41
static struct bfd_hash_entry *mips_elf_link_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
static void ecoff_swap_rpdr_out
  (bfd *, const RPDR *, struct rpdr_ext *);
static bfd_boolean mips_elf_create_procedure_table
  (void *, bfd *, struct bfd_link_info *, asection *,
   struct ecoff_debug_info *);
static bfd_boolean mips_elf_check_mips16_stubs
  (struct mips_elf_link_hash_entry *, void *);
static void bfd_mips_elf32_swap_gptab_in
  (bfd *, const Elf32_External_gptab *, Elf32_gptab *);
static void bfd_mips_elf32_swap_gptab_out
  (bfd *, const Elf32_gptab *, Elf32_External_gptab *);
static void bfd_elf32_swap_compact_rel_out
  (bfd *, const Elf32_compact_rel *, Elf32_External_compact_rel *);
static void bfd_elf32_swap_crinfo_out
  (bfd *, const Elf32_crinfo *, Elf32_External_crinfo *);
static int sort_dynamic_relocs
  (const void *, const void *);
static int sort_dynamic_relocs_64
  (const void *, const void *);
static bfd_boolean mips_elf_output_extsym
  (struct mips_elf_link_hash_entry *, void *);
static int gptab_compare
  (const void *, const void *);
static asection *mips_elf_rel_dyn_section
  (bfd *, bfd_boolean);
static asection *mips_elf_got_section
  (bfd *, bfd_boolean);
static struct mips_got_info *mips_elf_got_info
  (bfd *, asection **);
static bfd_vma mips_elf_local_got_index
  (bfd *, bfd *, struct bfd_link_info *, bfd_vma);
static bfd_vma mips_elf_global_got_index
  (bfd *, bfd *, struct elf_link_hash_entry *);
static bfd_vma mips_elf_got_page
  (bfd *, bfd *, struct bfd_link_info *, bfd_vma, bfd_vma *);
static bfd_vma mips_elf_got16_entry
  (bfd *, bfd *, struct bfd_link_info *, bfd_vma, bfd_boolean);
static bfd_vma mips_elf_got_offset_from_index
  (bfd *, bfd *, bfd *, bfd_vma);
a373 2
static bfd_boolean mips_elf_sort_hash_table
  (struct bfd_link_info *, unsigned long);
a375 11
static bfd_boolean mips_elf_record_local_got_symbol
  (bfd *, long, bfd_vma, struct mips_got_info *);
static bfd_boolean mips_elf_record_global_got_symbol
  (struct elf_link_hash_entry *, bfd *, struct bfd_link_info *,
   struct mips_got_info *);
static const Elf_Internal_Rela *mips_elf_next_relocation
  (bfd *, unsigned int, const Elf_Internal_Rela *, const Elf_Internal_Rela *);
static bfd_boolean mips_elf_local_relocation_p
  (bfd *, const Elf_Internal_Rela *, asection **, bfd_boolean);
static bfd_boolean mips_elf_overflow_p
  (bfd_vma, int);
a377 18
static bfd_vma mips_elf_higher
  (bfd_vma);
static bfd_vma mips_elf_highest
  (bfd_vma);
static bfd_boolean mips_elf_create_compact_rel_section
  (bfd *, struct bfd_link_info *);
static bfd_boolean mips_elf_create_got_section
  (bfd *, struct bfd_link_info *, bfd_boolean);
static bfd_reloc_status_type mips_elf_calculate_relocation
  (bfd *, bfd *, asection *, struct bfd_link_info *,
   const Elf_Internal_Rela *, bfd_vma, reloc_howto_type *,
   Elf_Internal_Sym *, asection **, bfd_vma *, const char **,
   bfd_boolean *, bfd_boolean);
static bfd_vma mips_elf_obtain_contents
  (reloc_howto_type *, const Elf_Internal_Rela *, bfd *, bfd_byte *);
static bfd_boolean mips_elf_perform_relocation
  (struct bfd_link_info *, reloc_howto_type *, const Elf_Internal_Rela *,
   bfd_vma, bfd *, asection *, bfd_byte *, bfd_boolean);
a379 2
static void mips_elf_allocate_dynamic_relocations
  (bfd *, unsigned int);
a383 12
static void mips_set_isa_flags
  (bfd *);
static INLINE char *elf_mips_abi_name
  (bfd *);
static void mips_elf_irix6_finish_dynamic_symbol
  (bfd *, const char *, Elf_Internal_Sym *);
static bfd_boolean mips_mach_extends_p
  (unsigned long, unsigned long);
static bfd_boolean mips_32bit_flags_p
  (flagword);
static INLINE hashval_t mips_elf_hash_bfd_vma
  (bfd_vma);
a385 26
static int mips_elf_got_entry_eq
  (const void *, const void *);

static bfd_boolean mips_elf_multi_got
  (bfd *, struct bfd_link_info *, struct mips_got_info *,
   asection *, bfd_size_type);
static hashval_t mips_elf_multi_got_entry_hash
  (const void *);
static int mips_elf_multi_got_entry_eq
  (const void *, const void *);
static hashval_t mips_elf_bfd2got_entry_hash
  (const void *);
static int mips_elf_bfd2got_entry_eq
  (const void *, const void *);
static int mips_elf_make_got_per_bfd
  (void **, void *);
static int mips_elf_merge_gots
  (void **, void *);
static int mips_elf_set_global_got_offset
  (void **, void *);
static int mips_elf_set_no_stub
  (void **, void *);
static int mips_elf_resolve_final_got_entry
  (void **, void *);
static void mips_elf_resolve_final_got_entries
  (struct mips_got_info *);
d1498 2
a1499 1
sort_dynamic_relocs_64 (const void *arg1, const void *arg2)
d1501 1
d1512 3
@


1.119
log
@include/
	* bfdlink.h (bfd_link_repair_undef_list): Declare.
bfd/
	* elf64-ppc.c (ppc64_elf_check_directives): Move undefs list fixup..
	* linker.c (bfd_link_repair_undef_list): ..to new function, but don't
	remove anything but new and undefweak.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Override any
	existing _DYNAMIC.
	(_bfd_elf_create_dynamic_sections): Formatting.
	(bfd_elf_record_link_assignment): Call bfd_link_repair_undef_list.
	(_bfd_elf_merge_symbol): Don't handle as-needed syms here.
	(struct elf_smash_data): New.
	(elf_smash_syms): New function.
	(elf_link_add_object_symbols): Call elf_smash_syms.  Don't add
	unneeded dynamic objects to loaded list.
	(elf_link_output_extsym): Don't handle as-needed here.  Strip
	bfd_link_hash_new symbols.
	* elf32-cris.c (elf_cris_discard_excess_program_dynamics): Don't
	delref when dynindx is already -1.
	* elf64-alpha.c (elf64_alpha_output_extsym): Strip bfd_link_hash_new
	symbols.
	* elfxx-mips.c (mips_elf_output_extsym): Likewise.
ld/
	* ld.texinfo: Clarify --as-needed operation.
@
text
@d1064 146
d1343 1
d1348 6
a1353 1
  vallo = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1439 2
d1445 2
d1448 4
a1451 2
				       (bfd_byte *) data
				       + reloc_entry->address);
d3239 2
a3240 1
	  if (r_type != R_MIPS_HI16 && r_type != R_MIPS_LO16)
a3426 1
    case R_MIPS16_GPREL:
d3430 3
d3524 1
d3532 13
a3544 1
	  value = mips_elf_high (addend + gp - p);
d3550 1
d3555 6
a3560 1
	  value = addend + gp - p + 4;
a3745 7
  if ((ELF_R_TYPE (input_bfd, relocation->r_info) == R_MIPS16_26
       || ELF_R_TYPE (input_bfd, relocation->r_info) == R_MIPS16_GPREL)
      && bfd_little_endian (input_bfd))
    /* The two 16-bit words will be reversed on a little-endian system.
       See mips_elf_perform_relocation for more details.  */
    x = (((x & 0xffff) << 16) | ((x & 0xffff0000) >> 16));

d3773 2
a3780 95
  /* If this is the R_MIPS16_26 relocation, we must store the
     value in a funny way.  */
  if (r_type == R_MIPS16_26)
    {
      /* R_MIPS16_26 is used for the mips16 jal and jalx instructions.
	 Most mips16 instructions are 16 bits, but these instructions
	 are 32 bits.

	 The format of these instructions is:

	 +--------------+--------------------------------+
	 !     JALX     ! X!   Imm 20:16  !   Imm 25:21  !
	 +--------------+--------------------------------+
	 !	  	  Immediate  15:0		    !
	 +-----------------------------------------------+

	 JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx.
	 Note that the immediate value in the first word is swapped.

	 When producing a relocatable object file, R_MIPS16_26 is
	 handled mostly like R_MIPS_26.  In particular, the addend is
	 stored as a straight 26-bit value in a 32-bit instruction.
	 (gas makes life simpler for itself by never adjusting a
	 R_MIPS16_26 reloc to be against a section, so the addend is
	 always zero).  However, the 32 bit instruction is stored as 2
	 16-bit values, rather than a single 32-bit value.  In a
	 big-endian file, the result is the same; in a little-endian
	 file, the two 16-bit halves of the 32 bit value are swapped.
	 This is so that a disassembler can recognize the jal
	 instruction.

	 When doing a final link, R_MIPS16_26 is treated as a 32 bit
	 instruction stored as two 16-bit values.  The addend A is the
	 contents of the targ26 field.  The calculation is the same as
	 R_MIPS_26.  When storing the calculated value, reorder the
	 immediate value as shown above, and don't forget to store the
	 value as two 16-bit values.

	 To put it in MIPS ABI terms, the relocation field is T-targ26-16,
	 defined as

	 big-endian:
	 +--------+----------------------+
	 |        |                      |
	 |        |    targ26-16         |
	 |31    26|25                   0|
	 +--------+----------------------+

	 little-endian:
	 +----------+------+-------------+
	 |          |      |             |
	 |  sub1    |      |     sub2    |
	 |0        9|10  15|16         31|
	 +----------+--------------------+
	 where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is
	 ((sub1 << 16) | sub2)).

	 When producing a relocatable object file, the calculation is
	 (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
	 When producing a fully linked file, the calculation is
	 let R = (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
	 ((R & 0x1f0000) << 5) | ((R & 0x3e00000) >> 5) | (R & 0xffff)  */

      if (!info->relocatable)
	/* Shuffle the bits according to the formula above.  */
	value = (((value & 0x1f0000) << 5)
		 | ((value & 0x3e00000) >> 5)
		 | (value & 0xffff));
    }
  else if (r_type == R_MIPS16_GPREL)
    {
      /* R_MIPS16_GPREL is used for GP-relative addressing in mips16
	 mode.  A typical instruction will have a format like this:

	 +--------------+--------------------------------+
	 !    EXTEND    !     Imm 10:5    !   Imm 15:11  !
	 +--------------+--------------------------------+
	 !    Major     !   rx   !   ry   !   Imm  4:0   !
	 +--------------+--------------------------------+

	 EXTEND is the five bit value 11110.  Major is the instruction
	 opcode.

	 This is handled exactly like R_MIPS_GPREL16, except that the
	 addend is retrieved and stored as shown in this diagram; that
	 is, the Imm fields above replace the V-rel16 field.

         All we need to do here is shuffle the bits appropriately.  As
	 above, the two 16-bit halves must be swapped on a
	 little-endian system.  */
      value = (((value & 0x7e0) << 16)
	       | ((value & 0xf800) << 5)
	       | (value & 0x1f));
    }

a3845 6
  /* Swap the high- and low-order 16 bits on little-endian systems
     when doing a MIPS16 relocation.  */
  if ((r_type == R_MIPS16_GPREL || r_type == R_MIPS16_26)
      && bfd_little_endian (input_bfd))
    x = (((x & 0xffff) << 16) | ((x & 0xffff0000) >> 16));

d3848 4
d6371 2
d6377 2
d6381 3
d6389 1
a6389 1
	      if (r_type == R_MIPS_HI16
d6397 7
d6422 1
a6422 1
							      R_MIPS_LO16,
d6427 2
d6431 3
a6433 1
							R_MIPS_LO16, FALSE);
d6436 2
a6446 9
	      else if (r_type == R_MIPS16_GPREL)
		{
		  /* The addend is scrambled in the object file.  See
		     mips_elf_perform_relocation for details on the
		     format.  */
		  addend = (((addend & 0x1f0000) >> 5)
			    | ((addend & 0x7e00000) >> 16)
			    | (addend & 0x1f));
		}
@


1.118
log
@	* elf-bfd.h (elf_backend_data): Add elf_backend_eh_frame_address_size.
	(_bfd_elf_eh_frame_address_size): Declare.
	* elfxx-target.h (elf_backend_eh_frame_address_size): Define a default.
	(elfNN_bed): Initialize elf_backend_eh_frame_address_size.
	* elfxx-mips.h (_bfd_mips_elf_eh_frame_address_size): Declare.
	(elf_backend_eh_frame_address_size): Define.
	* elfxx-mips.c (_bfd_mips_elf_eh_frame_address_size): New function.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Get the address
	size from the new backend hook.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_eh_frame_address_size): New function.
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
d1494 2
a1495 1
	    || h->root.ref_dynamic)
@


1.117
log
@	* elfxx-mips.c (mips_elf_calculate_relocation): Don't report an
	overflow for calls to undefined weak symbols.
@
text
@d4251 66
@


1.116
log
@	* elfxx-mips.c (mips_elf_calculate_relocation): For R_MIPS_JALR,
	return a real value, unless it is a PLT symbol.
	(mips_elf_perform_relocation): On the RM9000, turn a jal into a
	bal if possible.
@
text
@d3355 2
a3356 1
	  overflowed_p = (value >> 26) != ((p + 4) >> 28);
@


1.115
log
@	* archures.c: Define bfd_mach_mips9000.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle E_MIPS_MACH_9000.
	(mips_set_isa_flags): Handle bfd_mach_mips9000.
	* cpu-mips.c (I_mips9000): Define.
	(arch_info_struct): Add case for bfd_mach_mips9000.
	* aoutx.h (NAME(aout,machine_type)): Handle bfd_mach_mips9000.
	* bfd-in2.h: Regenerate.
@
text
@a3525 1
    case R_MIPS_PJUMP:
d3527 7
a3533 3
      /* Both of these may be ignored.  R_MIPS_JALR is an optimization
	 hint; we could improve performance by honoring that hint.  */
      return bfd_reloc_continue;
d3535 1
d3737 27
@


1.114
log
@	* elfxx-mips.c (mips_elf_calculate_relocation): Test for R_MIPS_26
	overflow.
@
text
@d4026 3
d7079 4
d8813 1
@


1.113
log
@	* elfxx-mips.c (mips_elf_create_dynamic_relocation): Return early
	for discard relocations; don't add an R_MIPS_NONE to the main body
	of .rel.dyn.
@
text
@d3353 4
a3356 1
	value = (_bfd_mips_elf_sign_extend (addend, 28) + symbol) >> 2;
@


1.112
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@a3785 1
  bfd_boolean skip;
d3789 2
a3799 1
  skip = FALSE;
d3833 3
a3835 2
    skip = TRUE;
  else if (outrel[0].r_offset == MINUS_TWO)
a3839 1
      skip = TRUE;
d3841 1
d3844 18
a3861 5
  /* If we've decided to skip this relocation, just output an empty
     record.  Note that R_MIPS_NONE == 0, so that this call to memset
     is a way of setting R_TYPE to R_MIPS_NONE.  */
  if (skip)
    memset (outrel, 0, sizeof (Elf_Internal_Rela) * 3);
d3864 6
a3869 20
      long indx;
      bfd_boolean defined_p;

      /* We must now calculate the dynamic symbol table index to use
	 in the relocation.  */
      if (h != NULL
	  && (! info->symbolic || !h->root.def_regular)
	  /* h->root.dynindx may be -1 if this symbol was marked to
	     become local.  */
	  && h->root.dynindx != -1)
	{
	  indx = h->root.dynindx;
	  if (SGI_COMPAT (output_bfd))
	    defined_p = h->root.def_regular;
	  else
	    /* ??? glibc's ld.so just adds the final GOT entry to the
	       relocation field.  It therefore treats relocs against
	       defined symbols in the same way as relocs against
	       undefined symbols.  */
	    defined_p = FALSE;
d3873 62
a3934 72
	  if (sec != NULL && bfd_is_abs_section (sec))
	    indx = 0;
	  else if (sec == NULL || sec->owner == NULL)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  else
	    {
	      indx = elf_section_data (sec->output_section)->dynindx;
	      if (indx == 0)
		abort ();
	    }

	  /* Instead of generating a relocation using the section
	     symbol, we may as well make it a fully relative
	     relocation.  We want to avoid generating relocations to
	     local symbols because we used to generate them
	     incorrectly, without adding the original symbol value,
	     which is mandated by the ABI for section symbols.  In
	     order to give dynamic loaders and applications time to
	     phase out the incorrect use, we refrain from emitting
	     section-relative relocations.  It's not like they're
	     useful, after all.  This should be a bit more efficient
	     as well.  */
	  /* ??? Although this behavior is compatible with glibc's ld.so,
	     the ABI says that relocations against STN_UNDEF should have
	     a symbol value of 0.  Irix rld honors this, so relocations
	     against STN_UNDEF have no effect.  */
	  if (!SGI_COMPAT (output_bfd))
	    indx = 0;
	  defined_p = TRUE;
	}

      /* If the relocation was previously an absolute relocation and
	 this symbol will not be referred to by the relocation, we must
	 adjust it by the value we give it in the dynamic symbol table.
	 Otherwise leave the job up to the dynamic linker.  */
      if (defined_p && r_type != R_MIPS_REL32)
	*addendp += symbol;

      /* The relocation is always an REL32 relocation because we don't
	 know where the shared library will wind up at load-time.  */
      outrel[0].r_info = ELF_R_INFO (output_bfd, (unsigned long) indx,
				     R_MIPS_REL32);
      /* For strict adherence to the ABI specification, we should
	 generate a R_MIPS_64 relocation record by itself before the
	 _REL32/_64 record as well, such that the addend is read in as
	 a 64-bit value (REL32 is a 32-bit relocation, after all).
	 However, since none of the existing ELF64 MIPS dynamic
	 loaders seems to care, we don't waste space with these
	 artificial relocations.  If this turns out to not be true,
	 mips_elf_allocate_dynamic_relocation() should be tweaked so
	 as to make room for a pair of dynamic relocations per
	 invocation if ABI_64_P, and here we should generate an
	 additional relocation record with R_MIPS_64 by itself for a
	 NULL symbol before this relocation record.  */
      outrel[1].r_info = ELF_R_INFO (output_bfd, 0,
				     ABI_64_P (output_bfd)
				     ? R_MIPS_64
				     : R_MIPS_NONE);
      outrel[2].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_NONE);

      /* Adjust the output offset of the relocation to reference the
	 correct location in the output file.  */
      outrel[0].r_offset += (input_section->output_section->vma
			     + input_section->output_offset);
      outrel[1].r_offset += (input_section->output_section->vma
			     + input_section->output_offset);
      outrel[2].r_offset += (input_section->output_section->vma
			     + input_section->output_offset);
    }
d3960 1
a3960 1
  if (! skip && IRIX_COMPAT (output_bfd) == ict_irix5)
@


1.111
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d6419 1
a6419 1
		     (info, name, howto->name, 0,
d8023 2
a8024 1
			(link_info, bfd_asymbol_name (*(*parent)->sym_ptr_ptr),
@


1.110
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d5671 1
a5671 1
		  || h->weakdef != NULL
d5737 1
a5737 1
  if (h->weakdef != NULL)
d5739 4
a5742 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.109
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d1493 4
a1496 4
  else if (((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	    || (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
d1614 1
a1614 1
  else if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d2414 2
a2415 4
		  && ((entry->d.h->root.elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
		  && ((entry->d.h->root.elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d2765 1
a2765 1
      if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
d2911 2
a2912 2
  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d3238 1
a3238 1
		  && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d3301 2
a3302 4
	       && ((h->root.elf_link_hash_flags
		    & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
	       && ((h->root.elf_link_hash_flags
		    & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d3856 1
a3856 2
	  && (! info->symbolic || (h->root.elf_link_hash_flags
				   & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3863 1
a3863 2
	    defined_p = ((h->root.elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) != 0);
d4810 2
a4811 2
      h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d4922 2
a4923 2
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d4967 2
a4968 2
      h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d4991 2
a4992 2
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d5315 1
a5315 1
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d5335 1
a5335 1
	      if ((hmips->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
d5337 1
a5337 2
			&& ! (hmips->root.elf_link_hash_flags
			      & ELF_LINK_FORCED_LOCAL)))
d5546 1
a5546 1
		  && ! (h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)))
d5670 1
a5670 1
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
d5672 3
a5674 6
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));
d5683 1
a5683 2
	  || (h->elf_link_hash_flags
	      & ELF_LINK_HASH_DEF_REGULAR) == 0))
d5695 1
a5695 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d5704 1
a5704 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d5726 1
a5726 1
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
d6600 1
a6600 1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0);
d6643 2
a6644 4
		      && ((p->d.h->root.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
		      && ((p->d.h->root.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)))
@


1.108
log
@* elfxx-mips.c (mips_elf_calculate_relocation): Test only for
the dynamic link symbol actually in use.
@
text
@d3722 3
a3724 3
	    (_("%s: %s+0x%lx: jump to stub routine which is not jal"),
	     bfd_archive_filename (input_bfd),
	     input_section->name,
d5229 2
a5230 2
	    (_("%s: Malformed reloc detected for section %s"),
	     bfd_archive_filename (abfd), name);
d5303 2
a5304 2
		(_("%s: CALL16 reloc at 0x%lx not against global symbol"),
		 bfd_archive_filename (abfd), (unsigned long) rel->r_offset);
d8898 2
a8899 2
	(_("%s: endianness incompatible with that of the selected emulation"),
	 bfd_archive_filename (ibfd));
d8910 2
a8911 2
	(_("%s: ABI is incompatible with that of the selected emulation"),
	 bfd_archive_filename (ibfd));
d8982 2
a8983 2
	(_("%s: warning: linking PIC files with non-PIC files"),
	 bfd_archive_filename (ibfd));
d8999 2
a9000 2
	(_("%s: linking 32-bit code with 64-bit code"),
	 bfd_archive_filename (ibfd));
d9027 2
a9028 2
	    (_("%s: linking %s module with previous %s modules"),
	     bfd_archive_filename (ibfd),
d9050 2
a9051 2
	    (_("%s: ABI mismatch: linking %s module with previous %s modules"),
	     bfd_archive_filename (ibfd),
d9073 2
a9074 2
	(_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	 bfd_archive_filename (ibfd), (unsigned long) new_flags,
@


1.107
log
@* elfxx-mips.c (_bfd_mips_elf_symbol_processing): Handle
SHN_MIPS_TEXT and SHN_MIPS_DATA.
@
text
@d3112 2
a3113 2
      else if (strcmp (*namep, "_DYNAMIC_LINK") == 0 ||
              strcmp (*namep, "_DYNAMIC_LINKING") == 0)
@


1.106
log
@(_bfd_mips_elf_final_link): Pass the correct number of section symbols to
mips_elf_sort_hash_table ().
@
text
@a4194 1
#if 0 /* for SGI_COMPAT */
d4196 13
a4208 1
      asym->section = mips_elf_text_section_ptr;
d4212 13
a4224 1
      asym->section = mips_elf_data_section_ptr;
a4225 1
#endif
@


1.106.2.1
log
@        * elfxx-mips.c (_bfd_mips_elf_symbol_processing): Handle
        SHN_MIPS_TEXT and SHN_MIPS_DATA.
@
text
@d4195 1
d4197 1
a4197 13
      {
	asection *section = bfd_get_section_by_name (abfd, ".text");

	BFD_ASSERT (SGI_COMPAT (abfd));
	if (section != NULL)
	  {
	    asym->section = section;
	    /* MIPS_TEXT is a bit special, the address is not an offset
	       to the base of the .text section.  So substract the section
	       base address to make it an offset.  */
	    asym->value -= section->vma;
	  }
      }
d4201 1
a4201 13
      {
	asection *section = bfd_get_section_by_name (abfd, ".data");

	BFD_ASSERT (SGI_COMPAT (abfd));
	if (section != NULL)
	  {
	    asym->section = section;
	    /* MIPS_DATA is a bit special, the address is not an offset
	       to the base of the .data section.  So substract the section
	       base address to make it an offset.  */
	    asym->value -= section->vma;
	  }
      }
d4203 1
@


1.105
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d8085 2
a8086 2
  const struct ecoff_debug_swap *swap
    = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
d8114 1
d8122 14
a8135 3
      if (! mips_elf_sort_hash_table (info, (info->shared
					     ? bfd_count_sections (abfd) + 1
					     : 1)))
@


1.104
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a1070 1
  bfd_size_type sz;
d1081 1
a1081 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
a1145 1
  bfd_size_type sz;
d1147 1
a1147 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
a1196 1
  bfd_size_type sz;
d1198 1
a1198 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
a1246 1
  bfd_size_type sz;
d1252 1
a1252 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
@


1.103
log
@	* section.c (struct sec): Remove usused flags.  Reorganize a little.
	(bfd_get_section_size_before_reloc): Delete.
	(bfd_get_section_size_after_reloc): Delete.
	(STD_SECTION): Update.
	(bfd_get_section_size_now): Delete.
	(bfd_set_section_contents): Don't referece reloc_done.
	(bfd_get_section_contents): Remove reloc_done comment.
	* bout.c (b_out_bfd_get_relocated_section_contents): Don't set
	reloc_done.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents): Likewise.
	* ecoff.c (bfd_debug_section): Update initializer.
	* elfxx-mips.c (_bfd_elf_mips_get_relocated_section_contents): Ditto.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* bfd-in.h (bfd_section_size): Expand.
	(bfd_get_section_size): New macro.
	* bfd-in2.h: Regenerate.
	* coff64-rs6000.c (xcoff64_write_object_contents): Replace
	bfd_get_section_size_before_reloc with bfd_get_section_size.
	* coffcode.h (coff_write_object_contents): Likewise.
	* coffgen.c (build_debug_section): Likewise.
	* dwarf1.c (parse_line_table): Likewise.
	(_bfd_dwarf1_find_nearest_line): Likewise.
	* ecoff.c (_bfd_ecoff_write_object_contents): Likewise.
	* i386msdos.c (msdos_write_object_contents): Likewise.
	* pdp11.c (squirt_out_relocs): Likewise.
	* elf32-sh64.c (sh64_find_section_for_address): Remove comment.
	* elf64-mmix.c (mmix_elf_final_link): Update comment.
@
text
@d981 1
a981 1
  s->_raw_size = size;
d1031 1
a1031 2
      h->fn_stub->_raw_size = 0;
      h->fn_stub->_cooked_size = 0;
d1043 1
a1043 2
      h->call_stub->_raw_size = 0;
      h->call_stub->_cooked_size = 0;
d1055 1
a1055 2
      h->call_fp_stub->_raw_size = 0;
      h->call_fp_stub->_cooked_size = 0;
d1071 1
d1082 2
a1083 1
  if (reloc_entry->address > input_section->_cooked_size)
d1148 1
d1150 2
a1151 1
  if (reloc_entry->address > input_section->_cooked_size)
d1201 1
d1203 2
a1204 1
  if (reloc_entry->address > input_section->_cooked_size)
d1253 1
d1259 2
a1260 1
  if (reloc_entry->address > input_section->_cooked_size)
d1876 1
a1876 1
  BFD_ASSERT (index < sgot->_raw_size);
d2715 1
a2715 1
  got->_raw_size = (gg->next->local_gotno
d2869 1
a2869 1
      s->_raw_size = sizeof (Elf32_External_compact_rel);
d3201 1
a3201 1
      BFD_ASSERT (sec->_raw_size > 0);
d3775 1
a3775 1
  if (s->_raw_size == 0)
d3778 1
a3778 1
      s->_raw_size += MIPS_ELF_REL_SIZE (abfd);
d3781 1
a3781 1
  s->_raw_size += n * MIPS_ELF_REL_SIZE (abfd);
d3809 1
a3809 1
	      < sreloc->_raw_size);
d4539 1
a4539 1
      hdr->sh_info = sec->_raw_size / sizeof (Elf32_Lib);
a5483 1
  bfd_byte *free_contents = NULL;
d5604 1
a5604 7
	      contents = bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto relax_return;

	      free_contents = contents;
	      if (! bfd_get_section_contents (abfd, sec, contents,
					      0, sec->_raw_size))
d5639 3
a5641 2
  if (free_contents != NULL)
    free (free_contents);
d5709 1
a5709 1
	  h->root.u.def.value = s->_raw_size;
d5712 1
a5712 1
	  h->plt.offset = s->_raw_size;
d5715 1
a5715 1
	  s->_raw_size += MIPS_FUNCTION_STUB_SIZE;
d5799 1
a5799 1
	  loadable_size += ((subsection->_raw_size + 0xf)
d5829 1
a5829 1
  s->_raw_size += g->local_gotno * MIPS_ELF_GOT_SIZE (output_bfd);
d5832 1
a5832 1
  s->_raw_size += i * MIPS_ELF_GOT_SIZE (output_bfd);
d5834 1
a5834 1
  if (s->_raw_size > MIPS_ELF_GOT_MAX_SIZE (output_bfd)
d5861 1
a5861 1
	  s->_raw_size
d5888 1
a5888 1
	  if (s->_raw_size == 0)
d5988 1
a5988 1
	  s->_raw_size += MIPS_FUNCTION_STUB_SIZE;
d5996 1
a5996 1
	  s->_raw_size += 4;
d6000 1
a6000 1
	s->_raw_size += mips_elf_hash_table (info)->compact_rel_size;
d6014 2
a6015 2
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d6582 1
a6582 1
      BFD_ASSERT (h->plt.offset <= s->_raw_size);
d6787 1
a6787 1
	   b < sdyn->contents + sdyn->_raw_size;
d6878 1
a6878 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size / elemsize;
	      else
		dyn.d_un.d_val = s->_raw_size / elemsize;
d6921 1
a6921 1
  if (sgot != NULL && sgot->_raw_size > 0)
d6995 2
a6996 2
		BFD_ASSERT (s->_raw_size >= MIPS_FUNCTION_STUB_SIZE);
		dummy_offset = s->_raw_size - MIPS_FUNCTION_STUB_SIZE;
d7008 1
a7008 1
	&& s->_raw_size > (bfd_vma)2 * MIPS_ELF_REL_SIZE (output_bfd))
d7403 1
a7403 3
		  sz = s->_cooked_size;
		  if (sz == 0)
		    sz = s->_raw_size;
d7413 1
a7413 3
		&& ((s->vma
		     + (s->_cooked_size !=
			0 ? s->_cooked_size : s->_raw_size)) <= high))
d7428 1
a7428 3
		  && ((s->vma
		       + (s->_cooked_size != 0 ?
			  s->_cooked_size : s->_raw_size)) <= high))
d7641 1
a7641 1
  if (o->_raw_size == 0)
d7643 1
a7643 1
  if (o->_raw_size % PDR_SIZE != 0)
d7649 1
a7649 1
  tdata = bfd_zmalloc (o->_raw_size / PDR_SIZE);
d7664 1
a7664 1
  for (i = 0, skip = 0; i < o->_raw_size / PDR_SIZE; i ++)
d7676 1
a7676 1
      o->_cooked_size = o->_raw_size - skip * PDR_SIZE;
d7710 1
a7710 1
  end = contents + sec->_raw_size;
d7722 1
a7722 1
			    sec->output_offset, sec->_cooked_size);
d7859 1
a7859 7
	  bfd_size_type size;

	  if (section->_cooked_size != 0)
	    size = section->_cooked_size;
	  else
	    size = section->_raw_size;
	  c = bfd_zalloc (abfd, size);
d7887 1
d7901 2
a7902 2
  if (!bfd_get_section_contents (input_bfd, input_section, data, 0,
				 input_section->_raw_size))
a7904 3
  /* We're not relaxing the section, so just copy the size info */
  input_section->_cooked_size = input_section->_raw_size;

a8248 5
	      /* The linker emulation code has probably clobbered the
                 size to be zero bytes.  */
	      if (input_section->_raw_size == 0)
		input_section->_raw_size = sizeof (Elf32_External_RegInfo);

d8271 1
a8271 1
	  BFD_ASSERT(o->_raw_size == sizeof (Elf32_External_RegInfo));
d8339 1
a8339 1
		  last = s->vma + s->_raw_size;
d8380 1
a8380 1
	      BFD_ASSERT (p->size == input_section->_raw_size);
d8484 1
a8484 1
	  o->_raw_size = bfd_ecoff_debug_size (abfd, &debug, swap);
d8602 1
a8602 1
	      size = bfd_section_size (input_bfd, input_section);
d8699 1
a8699 1
	  o->_raw_size = c * sizeof (Elf32_External_gptab);
d8738 1
a8738 1
				      0, gptab_data_sec->_raw_size))
d8746 1
a8746 1
				      0, gptab_bss_sec->_raw_size))
d8757 1
a8757 1
					  0, rtproc_sec->_raw_size))
d8938 1
a8938 1
	  && (sec->_raw_size != 0
@


1.102
log
@[ bfd/ChangeLog ]
2004-06-14  Chris Demetriou  <cgd@@broadcom.com>

        * elf32-mips.c (elf_mips_gnu_pcrel32): Add (undoing 2004-04-24
        removal) with updated comment.
        (bfd_elf32_bfd_reloc_type_lookup): Add back case for
        BFD_RELOC_32_PCREL.
        (mips_elf32_rtype_to_howto): Add back case for R_MIPS_PC32.
        * elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

[ include/elf/ChangeLog ]
2004-06-14  Chris Demetriou  <cgd@@broadcom.com>

        * mips.h (R_MIPS_PC32): Add back (undoing removal on 2004-04-24),
        with an updated comment.
@
text
@a7921 1
  input_section->reloc_done = TRUE;
@


1.101
log
@	* elfxx-mips.c (MINUS_TWO): Define.
	(mips_elf_higher, mips_elf_highest,
	mips_elf_create_dynamic_relocation): Use MINUS_ONE and MINUS_TWO for
	some bfd_vma values.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise. Code cleanup.
@
text
@d3339 5
@


1.100
log
@[ bfd/ChangeLog ]
2004-04-24  Chris Demetriou  <cgd@@broadcom.com>

	* elf32-mips.c (elf_mips_gnu_rel_hi16, elf_mips_gnu_rel_lo16)
	(elf_mips_gnu_pcrel64, elf_mips_gnu_pcrel32): Remove.
	(bfd_elf32_bfd_reloc_type_lookup): Remove cases for
	BFD_RELOC_PCREL_HI16_S, BFD_RELOC_PCREL_LO16, BFD_RELOC_64_PCREL,
	and BFD_RELOC_32_PCREL.
	(mips_elf32_rtype_to_howto): Remove cases for R_MIPS_GNU_REL_HI16,
	R_MIPS_GNU_REL_LO16, R_MIPS_PC64, R_MIPS_PC32.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
	(_bfd_mips_elf_lo16_reloc): Remove handling for R_MIPS_GNU_REL_HI16.
	(mips_elf_next_relocation): Move comment about matching HI/LO
	relocations to...
	(_bfd_mips_elf_relocate_section): Here.  Remove handling for
	R_MIPS_GNU_REL_HI16.

[ include/elf/ChangeLog ]
2004-04-24  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (R_MIPS_PC32, R_MIPS_PC64, R_MIPS_GNU_REL_LO16)
	(R_MIPS_GNU_REL_HI16): Remove.
	(R_MIPS_GNU_REL16_S2): Update comment.

[ ld/testsuite/ChangeLog ]
2004-04-24  Chris Demetriou  <cgd@@broadcom.com>

	* ld-elf/merge.d: XFAIL on all MIPS targets.
@
text
@d590 1
d2826 1
a2826 1
  return (bfd_vma) -1;
d2839 1
a2839 1
  return (bfd_vma) -1;
d3828 1
a3828 1
      if (outrel[0].r_offset == (bfd_vma) -1)
d3833 1
a3833 1
  if (outrel[0].r_offset == (bfd_vma) -1)
d3836 1
a3836 1
  else if (outrel[0].r_offset == (bfd_vma) -2)
a6548 1
  bfd_vma gval;
a6553 1
  gval = sym->st_value;
d6555 1
a6555 1
  if (h->plt.offset != (bfd_vma) -1)
d6588 2
a6589 2
      gval = s->output_section->vma + s->output_offset + h->plt.offset;
      sym->st_value = gval;
@


1.99
log
@[ bfd/ChangeLog ]
2004-04-23  Chris Demetriou  <cgd@@broadcom.com>

        * coff-mips.c (mips_relhi_reloc, mips_rello_reloc)
        (mips_switch_reloc, mips_read_relocs, mips_relax_section)
        (mips_relax_pcrel16, PCREL16_EXPANSION_ADJUSTMENT): Remove.
        (mips_relocate_hi): Remove now-unused 'adjust' and 'pcrel' arguments,
        and update comments to reflect current usage.
        (mips_howto_table): Remove entries for MIPS_R_RELHI, MIPS_R_RELLO,
        and MIPS_R_SWITCH, as well as several empty entries.  Update comment
        for MIPS_R_PCREL16.
        (mips_ecoff_swap_reloc_in, mips_ecoff_swap_reloc_out)
        (mips_adjust_reloc_out, mips_bfd_reloc_type_lookup): Remove support
        for MIPS_R_SWITCH, MIPS_R_RELLO, and MIPS_R_RELHI relocations.
        (mips_adjust_reloc_in): Likewise, adjust maximum accepted relocation
        type number to be MIPS_R_PCREL16.
        (mips_relocate_section): Remove support for link-time relaxation
        of branches used by embedded-PIC.  Remove support for MIPS_R_SWITCH,
        MIPS_R_RELLO, and MIPS_R_RELHI relocations.
        (_bfd_ecoff_bfd_relax_section): Redefine to bfd_generic_relax_section.
        * ecoff.c (ecoff_indirect_link_order): Remove support for link-time
        relaxation of branches used by embedded-PIC.
        * ecofflink.c (bfd_ecoff_debug_accumulate): Likewise.
        * libecoff.h (struct ecoff_section_tdata): Remove embedded-PIC
        related members, update comment.
        * pe-mips.c: Remove disabled (commented-out and #if 0'd)
        code related to embedded-PIC.
        * elfxx-mips.c (_bfd_mips_elf_read_ecoff_info): Remove
        initialization of now-removed 'adjust' member of
        'struct ecoff_debug_info'.

[ include/coff/ChangeLog ]
2004-04-23  Chris Demetriou  <cgd@@broadcom.com>

        * mips.h (MIPS_R_RELHI, MIPS_R_RELLO, MIPS_R_SWITCH): Remove
        (MIPS_R_PCREL16): Update comment.
        * ecoff.h (struct ecoff_value_adjust): Remove structure.
        (struct ecoff_debug_info): Remove 'adjust' member.
@
text
@a1222 7
      /* R_MIPS_GNU_REL_HI16 relocations are relative to the address of the
	 lo16 relocation, not their own address.  If we're calculating the
	 final value, and hence subtracting the "PC", subtract the offset
	 of the lo16 relocation from here.  */
      if (output_bfd == NULL && hi->rel.howto->type == R_MIPS_GNU_REL_HI16)
	hi->rel.addend -= reloc_entry->address - hi->rel.address;

a2723 6
  /* According to the MIPS ELF ABI, the R_MIPS_LO16 relocation must be
     immediately following.  However, for the IRIX6 ABI, the next
     relocation may be a composed relocation consisting of several
     relocations for the same address.  In that case, the R_MIPS_LO16
     relocation may occur as one of these.  We permit a similar
     extension in general, as that is useful for GCC.  */
a3337 7
    case R_MIPS_PC32:
    case R_MIPS_PC64:
    case R_MIPS_GNU_REL_LO16:
      value = symbol + addend - p;
      value &= howto->dst_mask;
      break;

a3343 10
    case R_MIPS_GNU_REL_HI16:
      /* Instead of subtracting 'p' here, we should be subtracting the
	 equivalent value for the LO part of the reloc, since the value
	 here is relative to that address.  Because that's not easy to do,
	 we adjust 'addend' in _bfd_mips_elf_relocate_section().  See also
	 the comment there for more information.  */
      value = mips_elf_high (addend + symbol - p);
      value &= howto->dst_mask;
      break;

a6201 1
		  || r_type == R_MIPS_GNU_REL_HI16
a6208 1
		  unsigned int lo;
d6216 12
a6227 6
		     Scan ahead to find a matching LO16 relocation.  */
		  if (r_type == R_MIPS_GNU_REL_HI16)
		    lo = R_MIPS_GNU_REL_LO16;
		  else
		    lo = R_MIPS_LO16;
		  lo16_relocation = mips_elf_next_relocation (input_bfd, lo,
d6233 2
a6234 1
		  lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, lo, FALSE);
a6244 10

		  /* If PC-relative, subtract the difference between the
		     address of the LO part of the reloc and the address of
		     the HI part.  The relocation is relative to the LO
		     part, but mips_elf_calculate_relocation() doesn't
		     know its address or the difference from the HI part, so
		     we subtract that difference here.  See also the
		     comment in mips_elf_calculate_relocation().  */
		  if (r_type == R_MIPS_GNU_REL_HI16)
		    addend -= (lo16_relocation->r_offset - rel->r_offset);
d6302 1
a6302 2
		  || r_type == R_MIPS_GOT16
		  || r_type == R_MIPS_GNU_REL_HI16)
@


1.98
log
@2004-04-22  Chris Demetriou  <cgd@@broadcom.com>

        * elfxx-mips.c (mips_elf_get_global_gotsym_index): Remove.
@
text
@a811 1
  debug->adjust = NULL;
@


1.97
log
@	* elfxx-mips.c (MIPS_ELF_STUB_SECTION_NAME): Always use
	".MIPS.stubs".
@
text
@a402 2
static long mips_elf_get_global_gotsym_index
  (bfd *abfd);
a1813 22
}

/* Obtain the lowest dynamic index of a symbol that was assigned a
   global GOT entry.  */
static long
mips_elf_get_global_gotsym_index (bfd *abfd)
{
  asection *sgot;
  struct mips_got_info *g;

  if (abfd == NULL)
    return 0;

  sgot = mips_elf_got_section (abfd, TRUE);
  if (sgot == NULL || mips_elf_section_data (sgot) == NULL)
    return 0;

  g = mips_elf_section_data (sgot)->u.got_info;
  if (g == NULL || g->global_gotsym == NULL)
    return 0;

  return g->global_gotsym->dynindx;
@


1.96
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d533 1
a533 2
#define MIPS_ELF_STUB_SECTION_NAME(abfd) \
  (NEWABI_P (abfd) ? ".MIPS.stubs" : ".stub")
@


1.95
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d2147 1
a2147 1
      if (!bfd_elf32_link_record_dynamic_symbol (info, h))
d2959 1
a2959 1
      && ! bfd_elf32_link_record_dynamic_symbol (info, h))
d4851 1
a4851 1
      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d4963 1
a4963 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d5008 1
a5008 1
      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d5032 1
a5032 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d5351 1
a5351 1
		 elf_adjust_dynamic_symbol in elflink.h.  */
d5463 1
a5463 1
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d5470 1
a5470 1
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d7734 1
a7734 1
      if (MNAME(abfd,_bfd_elf,reloc_symbol_deleted_p) (i * PDR_SIZE, cookie))
d8791 1
a8791 1
  if (!MNAME(abfd,bfd_elf,bfd_final_link) (abfd, info))
@


1.94
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d4718 1
a4718 1
			       const Elf_Internal_Sym *sym, const char **namep,
@


1.93
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@a566 1
#ifdef BFD64
d568 1
a568 9
  (ABI_64_P (elf_hash_table (info)->dynobj)		\
   ? bfd_elf64_add_dynamic_entry (info, tag, val)	\
   : bfd_elf32_add_dynamic_entry (info, tag, val))
#else
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)	\
  (ABI_64_P (elf_hash_table (info)->dynobj)		\
   ? (abort (), FALSE)					\
   : bfd_elf32_add_dynamic_entry (info, tag, val))
#endif
@


1.92
log
@	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Correct
	logic for null_input_bfd detection.
@
text
@d3159 1
a3159 2
      else if (info->shared
	       && info->unresolved_syms_in_objects == RM_IGNORE
d3180 2
a3181 3
		  ((info->shared && info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)
		   || (!info->shared && info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
		   || ELF_ST_VISIBILITY (h->root.other)))))
@


1.91
log
@Reviewed and approved by Alan Modra <amodra@@bigpond.net.au>

	2004-03-05  Fred Fish  <fnf@@redhat.com>
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Just force
	mips16 symbols to be even rather than testing first for even/odd.
	(_bfd_mips_elf_link_output_symbol_hook): Ditto.
@
text
@d9031 4
a9034 4
	  && ((!strcmp (sec->name, ".text")
	       || !strcmp (sec->name, ".data")
	       || !strcmp (sec->name, ".bss"))
	      && sec->_raw_size != 0))
@


1.91.2.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d3159 2
a3160 1
      else if (info->unresolved_syms_in_objects == RM_IGNORE
d3181 3
a3183 2
		  (info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
		   || ELF_ST_VISIBILITY (h->root.other))))
d9031 4
a9034 4
	  && (sec->_raw_size != 0
	      || (strcmp (sec->name, ".text")
		  && strcmp (sec->name, ".data")
		  && strcmp (sec->name, ".bss"))))
@


1.90
log
@bfd/
	* elfxx-mips.c (mips_elf_calculate_relocation): Use
	_bfd_elf_symbol_refs_local_p to decide whether to decay
	a GOT_PAGE/GOT_OFST pair to GOT_DISP/addend.
	(_bfd_mips_elf_check_relocs): Add a global GOT entry for GOT_PAGE
	relocs if the symbol wasn't defined by a regular object file.
	Don't check the symbol's dynindx.

ld/testsuite/
	* ld-mips/elf/elf-rel-xgot-{n32,n64-linux}.d: Update after 2004-02-02
	changes to the way large constants are added.
	* ld-mips/elf/elf-rel-got-{n32,n64-linux}.d: Likewise.  Adjust order
	of GOT entries after today's change to the handling of GOT_PAGE
	relocations.
@
text
@d3 1
a3 1
   2003 Free Software Foundation, Inc.
d4894 2
a4895 3
  if (sym->st_other == STO_MIPS16
      && (sym->st_value & 1) != 0)
    --sym->st_value;
d6816 2
a6817 3
  if (sym->st_other == STO_MIPS16
      && (sym->st_value & 1) != 0)
    --sym->st_value;
@


1.90.2.1
log
@Merge from mainline
@
text
@d567 6
d574 4
a577 1
  _bfd_elf_add_dynamic_entry (info, tag, val)
d2156 1
a2156 1
      if (!bfd_elf_link_record_dynamic_symbol (info, h))
d2968 1
a2968 1
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d3159 2
a3160 1
      else if (info->unresolved_syms_in_objects == RM_IGNORE
d3181 3
a3183 2
		  (info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
		   || ELF_ST_VISIBILITY (h->root.other))))
d4729 1
a4729 1
			       Elf_Internal_Sym *sym, const char **namep,
d4862 1
a4862 1
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d4975 1
a4975 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d5020 1
a5020 1
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d5044 1
a5044 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d5363 1
a5363 1
		 _bfd_elf_adjust_dynamic_symbol.  */
d5475 1
a5475 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d5482 1
a5482 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d7747 1
a7747 1
      if (bfd_elf_reloc_symbol_deleted_p (i * PDR_SIZE, cookie))
d8804 1
a8804 1
  if (!bfd_elf_final_link (abfd, info))
@


1.90.2.2
log
@Merge to 2.15 branch.
@
text
@d533 2
a534 1
#define MIPS_ELF_STUB_SECTION_NAME(abfd) ".MIPS.stubs"
d9022 4
a9025 4
	  && (sec->_raw_size != 0
	      || (strcmp (sec->name, ".text")
		  && strcmp (sec->name, ".data")
		  && strcmp (sec->name, ".bss"))))
@


1.90.4.1
log
@Merge mainline to intercu branch.
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
d567 6
d574 4
a577 1
  _bfd_elf_add_dynamic_entry (info, tag, val)
d3159 2
a3160 1
      else if (info->unresolved_syms_in_objects == RM_IGNORE
d3181 3
a3183 2
		  (info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
		   || ELF_ST_VISIBILITY (h->root.other))))
d4729 1
a4729 1
			       Elf_Internal_Sym *sym, const char **namep,
d4894 3
a4896 2
  if (sym->st_other == STO_MIPS16)
    sym->st_value &= ~1;
d6817 3
a6819 2
  if (sym->st_other == STO_MIPS16)
    sym->st_value &= ~1;
d9033 4
a9036 4
	  && (sec->_raw_size != 0
	      || (strcmp (sec->name, ".text")
		  && strcmp (sec->name, ".data")
		  && strcmp (sec->name, ".bss"))))
@


1.90.4.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d2147 1
a2147 1
      if (!bfd_elf_link_record_dynamic_symbol (info, h))
d2959 1
a2959 1
      && ! bfd_elf_link_record_dynamic_symbol (info, h))
d4851 1
a4851 1
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d4963 1
a4963 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d5008 1
a5008 1
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d5032 1
a5032 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d5351 1
a5351 1
		 _bfd_elf_adjust_dynamic_symbol.  */
d5463 1
a5463 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d5470 1
a5470 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d7734 1
a7734 1
      if (bfd_elf_reloc_symbol_deleted_p (i * PDR_SIZE, cookie))
d8791 1
a8791 1
  if (!bfd_elf_final_link (abfd, info))
@


1.90.4.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d403 2
d533 2
a534 1
#define MIPS_ELF_STUB_SECTION_NAME(abfd) ".MIPS.stubs"
a592 1
#define MINUS_TWO	(((bfd_vma)0) - 2)
d815 1
d984 1
a984 1
  s->size = size;
d1034 2
a1035 1
      h->fn_stub->size = 0;
d1047 2
a1048 1
      h->call_stub->size = 0;
d1060 2
a1061 1
      h->call_fp_stub->size = 0;
d1087 1
a1087 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1153 1
a1153 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1204 1
a1204 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1227 7
d1265 1
a1265 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1819 22
d1903 1
a1903 1
  BFD_ASSERT (index < sgot->size);
d2742 1
a2742 1
  got->size = (gg->next->local_gotno
d2757 6
d2864 1
a2864 1
  return MINUS_ONE;
d2877 1
a2877 1
  return MINUS_ONE;
d2902 1
a2902 1
      s->size = sizeof (Elf32_External_compact_rel);
d3153 2
a3154 2
      else if (strcmp (*namep, SGI_COMPAT (input_bfd)
		       ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING") == 0)
d3234 1
a3234 1
      BFD_ASSERT (sec->size > 0);
d3378 2
d3390 10
d3775 3
a3777 3
	    (_("%B: %A+0x%lx: jump to stub routine which is not jal"),
	     input_bfd,
	     input_section,
d3820 1
a3820 1
  if (s->size == 0)
d3823 1
a3823 1
      s->size += MIPS_ELF_REL_SIZE (abfd);
d3826 1
a3826 1
  s->size += n * MIPS_ELF_REL_SIZE (abfd);
d3854 1
a3854 1
	      < sreloc->size);
d3883 1
a3883 1
      if (outrel[0].r_offset == MINUS_ONE)
d3888 1
a3888 1
  if (outrel[0].r_offset == MINUS_ONE)
d3891 1
a3891 1
  else if (outrel[0].r_offset == MINUS_TWO)
d4248 1
d4250 1
a4250 13
      {
	asection *section = bfd_get_section_by_name (abfd, ".text");

	BFD_ASSERT (SGI_COMPAT (abfd));
	if (section != NULL)
	  {
	    asym->section = section;
	    /* MIPS_TEXT is a bit special, the address is not an offset
	       to the base of the .text section.  So substract the section
	       base address to make it an offset.  */
	    asym->value -= section->vma;
	  }
      }
d4254 1
a4254 13
      {
	asection *section = bfd_get_section_by_name (abfd, ".data");

	BFD_ASSERT (SGI_COMPAT (abfd));
	if (section != NULL)
	  {
	    asym->section = section;
	    /* MIPS_DATA is a bit special, the address is not an offset
	       to the base of the .data section.  So substract the section
	       base address to make it an offset.  */
	    asym->value -= section->vma;
	  }
      }
d4256 1
d4584 1
a4584 1
      hdr->sh_info = sec->size / sizeof (Elf32_Lib);
d5260 2
a5261 2
	    (_("%B: Malformed reloc detected for section %s"),
	     abfd, name);
d5334 2
a5335 2
		(_("%B: CALL16 reloc at 0x%lx not against global symbol"),
		 abfd, (unsigned long) rel->r_offset);
d5529 1
d5650 7
a5656 1
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d5691 2
a5692 3
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
d5760 1
a5760 1
	  h->root.u.def.value = s->size;
d5763 1
a5763 1
	  h->plt.offset = s->size;
d5766 1
a5766 1
	  s->size += MIPS_FUNCTION_STUB_SIZE;
d5850 1
a5850 1
	  loadable_size += ((subsection->size + 0xf)
d5880 1
a5880 1
  s->size += g->local_gotno * MIPS_ELF_GOT_SIZE (output_bfd);
d5883 1
a5883 1
  s->size += i * MIPS_ELF_GOT_SIZE (output_bfd);
d5885 1
a5885 1
  if (s->size > MIPS_ELF_GOT_MAX_SIZE (output_bfd)
d5912 1
a5912 1
	  s->size
d5939 1
a5939 1
	  if (s->size == 0)
d6039 1
a6039 1
	  s->size += MIPS_FUNCTION_STUB_SIZE;
d6047 1
a6047 1
	  s->size += 4;
d6051 1
a6051 1
	s->size += mips_elf_hash_table (info)->compact_rel_size;
d6065 2
a6066 2
      s->contents = bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
d6258 1
d6266 1
d6274 6
a6279 12
		     Scan ahead to find a matching LO16 relocation.

		     According to the MIPS ELF ABI, the R_MIPS_LO16
		     relocation must be immediately following.
		     However, for the IRIX6 ABI, the next relocation
		     may be a composed relocation consisting of
		     several relocations for the same address.  In
		     that case, the R_MIPS_LO16 relocation may occur
		     as one of these.  We permit a similar extension
		     in general, as that is useful for GCC.  */
		  lo16_relocation = mips_elf_next_relocation (input_bfd,
							      R_MIPS_LO16,
d6285 1
a6285 2
		  lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd,
							R_MIPS_LO16, FALSE);
d6296 10
d6363 2
a6364 1
		  || r_type == R_MIPS_GOT16)
d6610 1
d6616 1
d6618 1
a6618 1
  if (h->plt.offset != MINUS_ONE)
d6641 1
a6641 1
      BFD_ASSERT (h->plt.offset <= s->size);
d6651 2
a6652 2
      sym->st_value = (s->output_section->vma + s->output_offset
		       + h->plt.offset);
d6846 1
a6846 1
	   b < sdyn->contents + sdyn->size;
d6937 4
a6940 1
	      dyn.d_un.d_val = s->size / elemsize;
d6983 1
a6983 1
  if (sgot != NULL && sgot->size > 0)
d7057 2
a7058 2
		BFD_ASSERT (s->size >= MIPS_FUNCTION_STUB_SIZE);
		dummy_offset = s->size - MIPS_FUNCTION_STUB_SIZE;
d7070 1
a7070 1
	&& s->size > (bfd_vma)2 * MIPS_ELF_REL_SIZE (output_bfd))
d7465 3
a7467 1
		  sz = s->size;
d7477 3
a7479 1
		&& s->vma + s->size <= high)
d7494 3
a7496 1
		  && s->vma + s->size <= high)
d7709 1
a7709 1
  if (o->size == 0)
d7711 1
a7711 1
  if (o->size % PDR_SIZE != 0)
d7717 1
a7717 1
  tdata = bfd_zmalloc (o->size / PDR_SIZE);
d7732 1
a7732 1
  for (i = 0, skip = 0; i < o->size / PDR_SIZE; i ++)
d7744 1
a7744 1
      o->size -= skip * PDR_SIZE;
d7778 1
a7778 1
  end = contents + sec->size;
d7790 1
a7790 1
			    sec->output_offset, sec->size);
d7927 7
a7933 1
	  c = bfd_zalloc (abfd, section->size);
a7960 1
  bfd_size_type sz;
d7974 2
a7975 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (!bfd_get_section_contents (input_bfd, input_section, data, 0, sz))
d7978 4
d8170 2
a8171 2
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  const struct ecoff_debug_swap *swap = bed->elf_backend_ecoff_debug_swap;
a8198 1
      bfd_size_type dynsecsymcount;
d8206 3
a8208 14

      dynsecsymcount = 0;
      if (info->shared)
	{
	  asection * p;

	  for (p = abfd->sections; p ; p = p->next)
	    if ((p->flags & SEC_EXCLUDE) == 0
		&& (p->flags & SEC_ALLOC) != 0
		&& !(*bed->elf_backend_omit_section_dynsym) (abfd, info, p))
	      ++ dynsecsymcount;
	}
      
      if (! mips_elf_sort_hash_table (info, dynsecsymcount + 1))
d8326 5
d8353 1
a8353 1
	  BFD_ASSERT(o->size == sizeof (Elf32_External_RegInfo));
d8421 1
a8421 1
		  last = s->vma + s->size;
d8462 1
a8462 1
	      BFD_ASSERT (p->size == input_section->size);
d8566 1
a8566 1
	  o->size = bfd_ecoff_debug_size (abfd, &debug, swap);
d8684 1
a8684 1
	      size = input_section->size;
d8781 1
a8781 1
	  o->size = c * sizeof (Elf32_External_gptab);
d8820 1
a8820 1
				      0, gptab_data_sec->size))
d8828 1
a8828 1
				      0, gptab_bss_sec->size))
d8839 1
a8839 1
					  0, rtproc_sec->size))
d8954 2
a8955 2
	(_("%B: endianness incompatible with that of the selected emulation"),
	 ibfd);
d8966 2
a8967 2
	(_("%B: ABI is incompatible with that of the selected emulation"),
	 ibfd);
d9020 1
a9020 1
	  && (sec->size != 0
d9038 2
a9039 2
	(_("%B: warning: linking PIC files with non-PIC files"),
	 ibfd);
d9055 2
a9056 2
	(_("%B: linking 32-bit code with 64-bit code"),
	 ibfd);
d9083 2
a9084 2
	    (_("%B: linking %s module with previous %s modules"),
	     ibfd,
d9106 2
a9107 2
	    (_("%B: ABI mismatch: linking %s module with previous %s modules"),
	     ibfd,
d9129 2
a9130 2
	(_("%B: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	 ibfd, (unsigned long) new_flags,
@


1.90.4.4
log
@Merge from mainline.
@
text
@d1493 4
a1496 4
  else if ((h->root.def_dynamic
	    || h->root.ref_dynamic)
	   && !h->root.def_regular
	   && !h->root.ref_regular)
d1614 1
a1614 1
  else if (h->root.needs_plt)
d2414 4
a2417 2
		  && entry->d.h->root.def_dynamic
		  && !entry->d.h->root.def_regular))
d2767 1
a2767 1
      if (h->root.forced_local)
d2913 2
a2914 2
  h->non_elf = 0;
  h->def_regular = 1;
d3240 1
a3240 1
		  && h->root.def_regular))
d3303 4
a3306 2
	       && h->root.def_dynamic
	       && !h->root.def_regular))
d3860 2
a3861 1
	  && (! info->symbolic || !h->root.def_regular)
d3868 2
a3869 1
	    defined_p = h->root.def_regular;
d4816 2
a4817 2
      h->non_elf = 0;
      h->def_regular = 1;
d4928 2
a4929 2
	  h->non_elf = 0;
	  h->def_regular = 1;
d4973 2
a4974 2
      h->non_elf = 0;
      h->def_regular = 1;
d4997 2
a4998 2
	  h->non_elf = 0;
	  h->def_regular = 1;
d5321 1
a5321 1
	      h->needs_plt = 1;
d5341 1
a5341 1
	      if (hmips->root.def_regular
d5343 2
a5344 1
			&& ! hmips->root.forced_local))
d5553 1
a5553 1
		  && !h->root.forced_local))
d5677 8
a5684 5
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));
d5693 2
a5694 1
	  || !h->def_regular))
d5706 1
a5706 1
      && h->needs_plt)
d5715 1
a5715 1
      if (!h->def_regular)
d5737 1
a5737 1
	   && !h->needs_plt)
d5748 1
a5748 1
  if (h->u.weakdef != NULL)
d5750 4
a5753 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d6611 1
a6611 1
	      || h->forced_local);
d6654 4
a6657 2
		      && p->d.h->root.def_dynamic
		      && !p->d.h->root.def_regular))
@


1.89
log
@	* bfd-elf.h (elf_backend_name_local_section_symbols): New hook.
	* elf.c (swap_out_syms): Use it to decide whether local section
	symbols should be named.
	* elfxx-target.h (elf_backend_name_local_section_symbols): New macro.
	* elfxx-mips.h (_bfd_mips_elf_name_local_section_symbols): Declare.
	(elf_backend_name_local_section_symbols): Define.
	* elfxx-mips.c (_bfd_mips_elf_name_local_section_symbols): New.
@
text
@d3264 3
a3266 6
      /* If this symbol got a global GOT entry, we have to decay
	 GOT_PAGE/GOT_OFST to GOT_DISP/addend.  */
      local_p = local_p || ! h
	|| (h->root.dynindx
	    < mips_elf_get_global_gotsym_index (elf_hash_table (info)
						->dynobj));
d5384 1
a5384 3
	      if ((hmips->root.root.type == bfd_link_hash_defined
		   || hmips->root.root.type == bfd_link_hash_defweak)
		  && hmips->root.root.u.def.section
d5387 1
a5387 14
			      & ELF_LINK_FORCED_LOCAL))
		  /* If we've encountered any other relocation
		     referencing the symbol, we'll have marked it as
		     dynamic, and, even though we might be able to get
		     rid of the GOT entry should we know for sure all
		     previous relocations were GOT_PAGE ones, at this
		     point we can't tell, so just keep using the
		     symbol as dynamic.  This is very important in the
		     multi-got case, since we don't decide whether to
		     decay GOT_PAGE to GOT_DISP on a per-GOT basis: if
		     the symbol is dynamic, we'll need a GOT entry for
		     every GOT in which the symbol is referenced with
		     a GOT_PAGE relocation.  */
		  && hmips->root.dynindx == -1)
@


1.88
log
@bfd/
	* elf32-mips.c (elf_mips_howto_table_rel): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.  Use
	_bfd_mips_elf_hi16_reloc for R_MIPS_HI16 and R_MIPS_GNU_REL_HI16,
	_bfd_mips_elf_lo16_reloc for R_MIPS_LO16 and R_MIPS_GNU_REL_LO16,
	and _bfd_mips_elf_got16_reloc for R_MIPS_GOT16.  Change rightshift
	to 16 for R_MIPS_HI16 and R_MIPS_GNU_REL_HI16.
	(mips_elf_generic_reloc, struct mips_hi16, mips_elf_hi16_reloc)
	(mips_elf_lo16_reloc, mips_elf_got16_reloc): Delete.
	(_bfd_mips_elf32_gprel16_reloc): Remove special case.
	(mips_elf_gprel32_reloc, mips32_64bit_reloc): Likewise.

	* elf64-mips.c (mips_elf64_howto_table_rel): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.  Use
	_bfd_mips_elf_hi16_reloc for R_MIPS_HI16, _bfd_mips_elf_lo16_reloc
	for R_MIPS_LO16 and _bfd_mips_elf_got16_reloc for R_MIPS_GOT16.
	Change R_MIPS_HI16's rightshift to 16.
	(mips_elf64_howto_table_rela): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.
	Use _bfd_mips_elf_generic_reloc for R_MIPS_GOT16 as well.
	(mips_elf64_hi16_reloc, mips_elf64_got16_reloc): Delete.
	(mips_elf64_shift6_reloc): Remove special case.  Use
	_bfd_mips_elf_generic_reloc instead of returning bfd_reloc_continue.

	* elfn32-mips.c (prev_reloc_section): Delete.
	(prev_reloc_address, prev_reloc_addend): Delete.
	(elf_mips_howto_table_rel, elf_mips_howto_table_rela): As for
	elf64-mips.c
	(GET_RELOC_ADDEND, SET_RELOC_ADDEND): Delete.
	(mips_elf_generic_reloc, struct mips_hi16, mips_elf_hi16_reloc)
	(mips_elf_lo16_reloc, mips_elf_got16_reloc): Delete.
	(mips_elf_gprel16_reloc): Delete use of GET_RELOC_ADDEND.
	(mips_elf_literal_reloc, mips_elf_gprel32_reloc): Likewise.
	(mips16_jump_reloc, mips16_gprel_reloc): Likewise.
	(mips_elf_shift6_reloc): Likewise.  Delete use of SET_RELOC_ADDEND.

	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp): Use
	_bfd_relocate_contents to install an in-place addend.
	(mips_hi16): New structure.
	(mips_hi16_list): Moved from elf32-mips.c.
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_got16_reloc): New functions.
	(_bfd_mips_elf_lo16_reloc, _bfd_mips_elf_generic_reloc): New functions.
	(mips_elf_calculate_relocation): Assume addend is unshifted.
	(_bfd_mips_elf_relocate_section): Don't apply the howto rightshift
	on top of the usual high-part shift.  Don't shift the addend right
	before calling mips_elf_calculate_relocation.

	* elfxx-mips.h (_bfd_mips_elf_hi16_reloc): Declare.
	(_bfd_mips_elf_got16_reloc, _bfd_mips_elf_lo16_reloc): Declare.
	(_bfd_mips_elf_generic_reloc): Declare.

gas/
	* config/tc-mips.c (mips_need_elf_addend_fixup): Delete.
	(md_apply_fix3): Remove bfd_install_relocation workarounds.
	(tc_gen_reloc): Likewise. Factor handling of pc-relative relocations
	and treat fx_addnumber as relative to the relocation address.

gas/testsuite/
	* gas/mips/mips16-jalx.d: Use -mabi=o64.
	* gas/mips/mips16.d: Likewise.
	* gas/mips/elf-rel17.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d4274 20
@


1.87
log
@	* elfxx-mips.h, elfxx-mips.c, cpu-mips.c: Convert prototypes.
	Remove casts that were only needed for K&R compatibility.
@
text
@a1084 1
  unsigned long insn = 0;
d1086 1
d1102 1
a1102 7
  if (reloc_entry->howto->partial_inplace)
    {
      insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
      val += insn & 0xffff;
    }

  _bfd_mips_elf_sign_extend(val, 16);
d1113 5
a1117 2
      insn = (insn & ~0xffff) | (val & 0xffff);
      bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);
d1124 198
a1321 2
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;
d3399 1
a3399 1
      value = symbol + _bfd_mips_elf_sign_extend (addend << 2, 18) - p;
d3422 1
a3422 1
	value = (((addend << 2) | ((p + 4) & 0xf0000000)) + symbol) >> 2;
d3424 1
a3424 1
	value = (_bfd_mips_elf_sign_extend (addend << 2, 28) + symbol) >> 2;
a6262 1
	      addend <<= howto->rightshift;
d6326 2
d6367 4
a6370 1
	  if (howto->partial_inplace)
d6372 2
a6373 5
	      /* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16,
		 then we only want to write out the high-order 16 bits.
		 The subsequent R_MIPS_LO16 will handle the low-order bits.
	       */
	      if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16
d6380 2
a6381 1
	    }
d6383 3
a6385 12
	  if (rela_relocation_p)
	    /* If this is a RELA relocation, just update the addend.
	       We have to cast away constness for REL.  */
	    rel->r_addend = addend;
	  else
	    {
	      /* Otherwise, we have to write the value back out.  Note
		 that we use the source mask, rather than the
		 destination mask because the place to which we are
		 writing will be source of the addend in the final
		 link.  */
	      addend >>= howto->rightshift;
a6447 2

      addend >>= howto->rightshift;
@


1.86
log
@	* elf-bfd.h (struct elf_backend_data): Remove "bfd *" and add
	"elflink_hash_entry *" param to elf_backend_link_output_symbol_hook.
	Add "elflink_hash_entry *" param to elf_backend_output_arch_syms.
	* elflink.h (elf_link_output_sym): Add "elflink_hash_entry *" param,
	and pass to output_symbol_hook.
	(elf_bfd_final_link): Adjust elf_link_output_sym calls.
	(elf_link_output_extsym): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_output_arch_syms): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	Validate dynh->h against h.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add adjust_done bitfield.
	(link_hash_newfunc): Init it.
	(adjust_opd_syms): New function.
	(ppc64_elf_edit_opd): Set adjust_done when global .opd sym adjusted.
	Set opd.adjust for all .opd relocs.  Call adjust_opd_syms.
	(ppc64_elf_tls_optimize): Adjust possible .opd sym values here.
	(ppc64_elf_relocate_section): Also adjust syms not a multiple of 24.
	(ppc64_elf_output_symbol_hook): New function.
	(elf_backend_link_output_symbol_hook): Define.
@
text
@d373 1
a373 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d375 1
a375 1
  PARAMS ((bfd *, const RPDR *, struct rpdr_ext *));
d377 2
a378 2
  PARAMS ((PTR, bfd *, struct bfd_link_info *, asection *,
	   struct ecoff_debug_info *));
d380 1
a380 1
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));
d382 1
a382 1
  PARAMS ((bfd *, const Elf32_External_gptab *, Elf32_gptab *));
d384 1
a384 1
  PARAMS ((bfd *, const Elf32_gptab *, Elf32_External_gptab *));
d386 1
a386 1
  PARAMS ((bfd *, const Elf32_compact_rel *, Elf32_External_compact_rel *));
d388 1
a388 1
  PARAMS ((bfd *, const Elf32_crinfo *, Elf32_External_crinfo *));
d390 1
a390 1
  PARAMS ((const void *, const void *));
d392 1
a392 1
  PARAMS ((const void *, const void *));
d394 7
a400 4
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));
static int gptab_compare PARAMS ((const void *, const void *));
static asection * mips_elf_rel_dyn_section PARAMS ((bfd *, bfd_boolean));
static asection * mips_elf_got_section PARAMS ((bfd *, bfd_boolean));
d402 3
a404 2
  PARAMS ((bfd *, asection **));
static long mips_elf_get_global_gotsym_index PARAMS ((bfd *abfd));
d406 1
a406 1
  PARAMS ((bfd *, bfd *, struct bfd_link_info *, bfd_vma));
d408 1
a408 1
  PARAMS ((bfd *, bfd *, struct elf_link_hash_entry *));
d410 1
a410 1
  PARAMS ((bfd *, bfd *, struct bfd_link_info *, bfd_vma, bfd_vma *));
d412 1
a412 1
  PARAMS ((bfd *, bfd *, struct bfd_link_info *, bfd_vma, bfd_boolean));
d414 1
a414 1
  PARAMS ((bfd *, bfd *, bfd *, bfd_vma));
d416 1
a416 1
  PARAMS ((bfd *, bfd *, struct mips_got_info *, asection *, bfd_vma));
d418 1
a418 1
  PARAMS ((struct bfd_link_info *, unsigned long));
d420 1
a420 1
  PARAMS ((struct mips_elf_link_hash_entry *, PTR));
d422 1
a422 1
  PARAMS ((bfd *, long, bfd_vma, struct mips_got_info *));
d424 2
a425 2
  PARAMS ((struct elf_link_hash_entry *, bfd *, struct bfd_link_info *,
	   struct mips_got_info *));
d427 1
a427 2
  PARAMS ((bfd *, unsigned int, const Elf_Internal_Rela *,
	   const Elf_Internal_Rela *));
d429 9
a437 5
  PARAMS ((bfd *, const Elf_Internal_Rela *, asection **, bfd_boolean));
static bfd_boolean mips_elf_overflow_p PARAMS ((bfd_vma, int));
static bfd_vma mips_elf_high PARAMS ((bfd_vma));
static bfd_vma mips_elf_higher PARAMS ((bfd_vma));
static bfd_vma mips_elf_highest PARAMS ((bfd_vma));
d439 1
a439 1
  PARAMS ((bfd *, struct bfd_link_info *));
d441 1
a441 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean));
d443 4
a446 4
  PARAMS ((bfd *, bfd *, asection *, struct bfd_link_info *,
	   const Elf_Internal_Rela *, bfd_vma, reloc_howto_type *,
	   Elf_Internal_Sym *, asection **, bfd_vma *, const char **,
	   bfd_boolean *, bfd_boolean));
d448 1
a448 1
  PARAMS ((reloc_howto_type *, const Elf_Internal_Rela *, bfd *, bfd_byte *));
d450 2
a451 3
  PARAMS ((struct bfd_link_info *, reloc_howto_type *,
	   const Elf_Internal_Rela *, bfd_vma, bfd *, asection *, bfd_byte *,
	   bfd_boolean));
d453 1
a453 1
  PARAMS ((bfd *, asection *));
d455 1
a455 1
  PARAMS ((bfd *, unsigned int));
d457 7
a463 5
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Rela *,
	   struct mips_elf_link_hash_entry *, asection *,
	   bfd_vma, bfd_vma *, asection *));
static void mips_set_isa_flags PARAMS ((bfd *));
static INLINE char* elf_mips_abi_name PARAMS ((bfd *));
d465 11
a475 6
  PARAMS ((bfd *, const char *, Elf_Internal_Sym *));
static bfd_boolean mips_mach_extends_p PARAMS ((unsigned long, unsigned long));
static bfd_boolean mips_32bit_flags_p PARAMS ((flagword));
static INLINE hashval_t mips_elf_hash_bfd_vma PARAMS ((bfd_vma));
static hashval_t mips_elf_got_entry_hash PARAMS ((const PTR));
static int mips_elf_got_entry_eq PARAMS ((const PTR, const PTR));
d478 20
a497 11
  PARAMS ((bfd *, struct bfd_link_info *, struct mips_got_info *,
	   asection *, bfd_size_type));
static hashval_t mips_elf_multi_got_entry_hash PARAMS ((const PTR));
static int mips_elf_multi_got_entry_eq PARAMS ((const PTR, const PTR));
static hashval_t mips_elf_bfd2got_entry_hash PARAMS ((const PTR));
static int mips_elf_bfd2got_entry_eq PARAMS ((const PTR, const PTR));
static int mips_elf_make_got_per_bfd PARAMS ((void **, void *));
static int mips_elf_merge_gots PARAMS ((void **, void *));
static int mips_elf_set_global_got_offset PARAMS ((void**, void *));
static int mips_elf_set_no_stub PARAMS ((void **, void *));
static int mips_elf_resolve_final_got_entry PARAMS ((void**, void *));
d499 1
a499 1
  PARAMS ((struct mips_got_info *));
d501 1
a501 1
  PARAMS ((bfd *, struct mips_got_info *, bfd *));
d503 1
a503 1
  PARAMS ((struct mips_got_info *, bfd *));
d568 4
a571 4
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)			\
  (ABI_64_P (elf_hash_table (info)->dynobj)				\
   ? bfd_elf64_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val)	\
   : bfd_elf32_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val))
d573 4
a576 4
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)			\
  (ABI_64_P (elf_hash_table (info)->dynobj)				\
   ? (abort (), FALSE)							\
   : bfd_elf32_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val))
d706 1
a706 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d717 2
a718 4
mips_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d725 3
a727 5
  if (ret == (struct mips_elf_link_hash_entry *) NULL)
    ret = ((struct mips_elf_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct mips_elf_link_hash_entry)));
  if (ret == (struct mips_elf_link_hash_entry *) NULL)
d734 1
a734 1
  if (ret != (struct mips_elf_link_hash_entry *) NULL)
d755 1
a755 3
_bfd_mips_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
d760 1
a760 1
  sdata = (struct _mips_elf_section_data *) bfd_zalloc (abfd, amt);
d763 1
a763 1
  sec->used_by_bfd = (PTR) sdata;
d772 2
a773 4
_bfd_mips_elf_read_ecoff_info (abfd, section, debug)
     bfd *abfd;
     asection *section;
     struct ecoff_debug_info *debug;
d777 1
a777 1
  char *ext_hdr = NULL;
d782 1
a782 1
  ext_hdr = (char *) bfd_malloc (swap->external_hdr_size);
d786 1
a786 1
  if (! bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
d801 1
a801 1
      debug->ptr = (type) bfd_malloc (amt);				\
d804 1
a804 1
      if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0	\
d810 4
a813 4
  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, PTR);
  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, PTR);
  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, PTR);
  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, PTR);
d818 3
a820 3
  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, PTR);
  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, PTR);
  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, PTR);
d859 1
a859 4
ecoff_swap_rpdr_out (abfd, in, ex)
     bfd *abfd;
     const RPDR *in;
     struct rpdr_ext *ex;
d880 3
a882 6
mips_elf_create_procedure_table (handle, abfd, info, s, debug)
     PTR handle;
     bfd *abfd;
     struct bfd_link_info *info;
     asection *s;
     struct ecoff_debug_info *debug;
d888 1
a888 1
  PTR rtproc;
d915 1
a915 1
      epdr = (struct pdr_ext *) bfd_malloc (size * count);
d919 1
a919 1
      if (! _bfd_ecoff_get_accumulated_pdr (handle, (PTR) epdr))
d923 1
a923 1
      rp = rpdr = (RPDR *) bfd_malloc (size * count);
d928 1
a928 1
      sv = (char **) bfd_malloc (size * count);
d934 1
a934 1
      esym = (struct sym_ext *) bfd_malloc (size * count);
d938 1
a938 1
      if (! _bfd_ecoff_get_accumulated_sym (handle, (PTR) esym))
d942 1
a942 1
      ss = (char *) bfd_malloc (count);
d945 1
a945 1
      if (! _bfd_ecoff_get_accumulated_ss (handle, (PTR) ss))
d951 2
a952 2
	  (*swap->swap_pdr_in) (abfd, (PTR) (epdr + i), &pdr);
	  (*swap->swap_sym_in) (abfd, (PTR) &esym[pdr.isym], &sym);
d969 1
a969 1
  rtproc = (PTR) bfd_alloc (abfd, size);
d978 1
a978 1
  erp = (struct rpdr_ext *) rtproc;
d994 1
a994 1
  s->contents = (bfd_byte *) rtproc;
d998 1
a998 1
  s->link_order_head = (struct bfd_link_order *) NULL;
d1031 2
a1032 3
mips_elf_check_mips16_stubs (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data ATTRIBUTE_UNUSED;
d1080 3
a1082 9
_bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry, input_section,
			       relocatable, data, gp)
     bfd *abfd;
     asymbol *symbol;
     arelent *reloc_entry;
     asection *input_section;
     bfd_boolean relocatable;
     PTR data;
     bfd_vma gp;
d1120 1
a1120 2
      bfd_put_32 (abfd, (bfd_vma) insn,
		  (bfd_byte *) data + reloc_entry->address);
d1137 2
a1138 4
bfd_mips_elf32_swap_gptab_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_gptab *ex;
     Elf32_gptab *in;
d1145 2
a1146 4
bfd_mips_elf32_swap_gptab_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_gptab *in;
     Elf32_External_gptab *ex;
d1153 2
a1154 4
bfd_elf32_swap_compact_rel_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_compact_rel *in;
     Elf32_External_compact_rel *ex;
d1165 2
a1166 4
bfd_elf32_swap_crinfo_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_crinfo *in;
     Elf32_External_crinfo *ex;
d1184 2
a1185 4
bfd_mips_elf32_swap_reginfo_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_RegInfo *ex;
     Elf32_RegInfo *in;
d1196 2
a1197 4
bfd_mips_elf32_swap_reginfo_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_RegInfo *in;
     Elf32_External_RegInfo *ex;
d1214 2
a1215 4
bfd_mips_elf64_swap_reginfo_in (abfd, ex, in)
     bfd *abfd;
     const Elf64_External_RegInfo *ex;
     Elf64_Internal_RegInfo *in;
d1227 2
a1228 4
bfd_mips_elf64_swap_reginfo_out (abfd, in, ex)
     bfd *abfd;
     const Elf64_Internal_RegInfo *in;
     Elf64_External_RegInfo *ex;
d1242 2
a1243 4
bfd_mips_elf_swap_options_in (abfd, ex, in)
     bfd *abfd;
     const Elf_External_Options *ex;
     Elf_Internal_Options *in;
d1254 2
a1255 4
bfd_mips_elf_swap_options_out (abfd, in, ex)
     bfd *abfd;
     const Elf_Internal_Options *in;
     Elf_External_Options *ex;
d1267 1
a1267 3
sort_dynamic_relocs (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d1281 1
a1281 3
sort_dynamic_relocs_64 (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d1311 1
a1311 3
mips_elf_output_extsym (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data;
d1313 1
a1313 1
  struct extsym_info *einfo = (struct extsym_info *) data;
d1491 1
a1491 3
gptab_compare (p1, p2)
     const PTR p1;
     const PTR p2;
d1493 2
a1494 2
  const Elf32_gptab *a1 = (const Elf32_gptab *) p1;
  const Elf32_gptab *a2 = (const Elf32_gptab *) p2;
d1505 1
a1505 2
mips_elf_hash_bfd_vma (addr)
     bfd_vma addr;
d1519 1
a1519 2
mips_elf_got_entry_hash (entry_)
     const PTR entry_;
d1531 1
a1531 3
mips_elf_got_entry_eq (entry1, entry2)
     const PTR entry1;
     const PTR entry2;
d1548 1
a1548 2
mips_elf_multi_got_entry_hash (entry_)
     const PTR entry_;
d1562 1
a1562 3
mips_elf_multi_got_entry_eq (entry1, entry2)
     const PTR entry1;
     const PTR entry2;
d1577 1
a1577 3
mips_elf_rel_dyn_section (dynobj, create_p)
     bfd *dynobj;
     bfd_boolean create_p;
d1604 1
a1604 3
mips_elf_got_section (abfd, maybe_excluded)
     bfd *abfd;
     bfd_boolean maybe_excluded;
d1618 1
a1618 3
mips_elf_got_info (abfd, sgotp)
     bfd *abfd;
     asection **sgotp;
d1638 1
a1638 2
mips_elf_get_global_gotsym_index (abfd)
     bfd *abfd;
d1662 2
a1663 4
mips_elf_local_got_index (abfd, ibfd, info, value)
     bfd *abfd, *ibfd;
     struct bfd_link_info *info;
     bfd_vma value;
d1681 1
a1681 3
mips_elf_global_got_index (abfd, ibfd, h)
     bfd *abfd, *ibfd;
     struct elf_link_hash_entry *h;
d1702 1
a1702 1
	  p = (struct mips_got_entry *) htab_find (g->got_entries, &e);
d1731 2
a1732 5
mips_elf_got_page (abfd, ibfd, info, value, offsetp)
     bfd *abfd, *ibfd;
     struct bfd_link_info *info;
     bfd_vma value;
     bfd_vma *offsetp;
d1760 2
a1761 5
mips_elf_got16_entry (abfd, ibfd, info, value, external)
     bfd *abfd, *ibfd;
     struct bfd_link_info *info;
     bfd_vma value;
     bfd_boolean external;
d1789 2
a1790 5
mips_elf_got_offset_from_index (dynobj, output_bfd, input_bfd, index)
     bfd *dynobj;
     bfd *output_bfd;
     bfd *input_bfd;
     bfd_vma index;
d1807 3
a1809 5
mips_elf_create_local_got_entry (abfd, ibfd, gg, sgot, value)
     bfd *abfd, *ibfd;
     struct mips_got_info *gg;
     asection *sgot;
     bfd_vma value;
d1863 1
a1863 3
mips_elf_sort_hash_table (info, max_local)
     struct bfd_link_info *info;
     unsigned long max_local;
d1908 1
a1908 3
mips_elf_sort_hash_table_f (h, data)
     struct mips_elf_link_hash_entry *h;
     PTR data;
d1910 1
a1910 2
  struct mips_elf_hash_sort_data *hsd
    = (struct mips_elf_hash_sort_data *) data;
d1946 3
a1948 5
mips_elf_record_global_got_symbol (h, abfd, info, g)
     struct elf_link_hash_entry *h;
     bfd *abfd;
     struct bfd_link_info *info;
     struct mips_got_info *g;
d2002 2
a2003 5
mips_elf_record_local_got_symbol (abfd, symndx, addend, g)
     bfd *abfd;
     long symndx;
     bfd_vma addend;
     struct mips_got_info *g;
d2031 1
a2031 2
mips_elf_bfd2got_entry_hash (entry_)
     const PTR entry_;
d2042 1
a2042 3
mips_elf_bfd2got_entry_eq (entry1, entry2)
     const PTR entry1;
     const PTR entry2;
d2056 1
a2056 3
mips_elf_got_for_ibfd (g, ibfd)
     struct mips_got_info *g;
     bfd *ibfd;
d2064 1
a2064 1
  p = (struct mips_elf_bfd2got_hash *) htab_find (g->bfd2got, &e);
d2073 1
a2073 3
mips_elf_make_got_per_bfd (entryp, p)
     void **entryp;
     void *p;
d2117 1
a2117 2
					mips_elf_multi_got_entry_eq,
					(htab_del) NULL);
d2151 1
a2151 3
mips_elf_merge_gots (bfd2got_, p)
     void **bfd2got_;
     void *p;
d2248 1
a2248 3
mips_elf_set_global_got_offset (entryp, p)
     void **entryp;
     void *p;
d2281 1
a2281 3
mips_elf_set_no_stub (entryp, p)
     void **entryp;
     void *p ATTRIBUTE_UNUSED;
d2300 1
a2300 3
mips_elf_resolve_final_got_entry (entryp, p)
     void **entryp;
     void *p;
d2342 1
a2342 2
mips_elf_resolve_final_got_entries (g)
     struct mips_got_info *g;
d2360 1
a2360 4
mips_elf_adjust_gp (abfd, g, ibfd)
     bfd *abfd;
     struct mips_got_info *g;
     bfd *ibfd;
d2380 3
a2382 6
mips_elf_multi_got (abfd, info, g, got, pages)
     bfd *abfd;
     struct bfd_link_info *info;
     struct mips_got_info *g;
     asection *got;
     bfd_size_type pages;
d2390 1
a2390 2
				mips_elf_bfd2got_entry_eq,
				(htab_del) NULL);
d2435 1
a2435 1
					      (htab_del) NULL);
d2569 3
a2571 5
mips_elf_next_relocation (abfd, r_type, relocation, relend)
     bfd *abfd ATTRIBUTE_UNUSED;
     unsigned int r_type;
     const Elf_Internal_Rela *relocation;
     const Elf_Internal_Rela *relend;
d2595 4
a2598 6
mips_elf_local_relocation_p (input_bfd, relocation, local_sections,
			     check_forced)
     bfd *input_bfd;
     const Elf_Internal_Rela *relocation;
     asection **local_sections;
     bfd_boolean check_forced;
d2634 1
a2634 3
_bfd_mips_elf_sign_extend (value, bits)
     bfd_vma value;
     int bits;
d2648 1
a2648 3
mips_elf_overflow_p (value, bits)
     bfd_vma value;
     int bits;
d2666 1
a2666 2
mips_elf_high (value)
     bfd_vma value;
d2674 1
a2674 2
mips_elf_higher (value)
     bfd_vma value ATTRIBUTE_UNUSED;
d2687 1
a2687 2
mips_elf_highest (value)
     bfd_vma value ATTRIBUTE_UNUSED;
d2700 2
a2701 3
mips_elf_create_compact_rel_section (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d2727 2
a2728 4
mips_elf_create_got_section (abfd, info, maybe_exclude)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean maybe_exclude;
d2766 1
a2766 2
	  (bfd_vma) 0, (const char *) NULL, FALSE,
	  get_elf_backend_data (abfd)->collect, &bh)))
d2779 1
a2779 1
  g = (struct mips_got_info *) bfd_alloc (abfd, amt);
d2789 1
a2789 2
				    mips_elf_got_entry_eq,
				    (htab_del) NULL);
d2813 9
a2821 17
mips_elf_calculate_relocation (abfd, input_bfd, input_section, info,
			       relocation, addend, howto, local_syms,
			       local_sections, valuep, namep,
			       require_jalxp, save_addend)
     bfd *abfd;
     bfd *input_bfd;
     asection *input_section;
     struct bfd_link_info *info;
     const Elf_Internal_Rela *relocation;
     bfd_vma addend;
     reloc_howto_type *howto;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
     bfd_vma *valuep;
     const char **namep;
     bfd_boolean *require_jalxp;
     bfd_boolean save_addend;
d3425 3
a3427 5
mips_elf_obtain_contents (howto, relocation, input_bfd, contents)
     reloc_howto_type *howto;
     const Elf_Internal_Rela *relocation;
     bfd *input_bfd;
     bfd_byte *contents;
d3455 6
a3460 10
mips_elf_perform_relocation (info, howto, relocation, value, input_bfd,
			     input_section, contents, require_jalx)
     struct bfd_link_info *info;
     reloc_howto_type *howto;
     const Elf_Internal_Rela *relocation;
     bfd_vma value;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     bfd_boolean require_jalx;
d3622 1
a3622 3
mips_elf_stub_section_p (abfd, section)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
d3634 1
a3634 3
mips_elf_allocate_dynamic_relocations (abfd, n)
     bfd *abfd;
     unsigned int n;
d3656 6
a3661 10
mips_elf_create_dynamic_relocation (output_bfd, info, rel, h, sec,
				    symbol, addendp, input_section)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const Elf_Internal_Rela *rel;
     struct mips_elf_link_hash_entry *h;
     asection *sec;
     bfd_vma symbol;
     bfd_vma *addendp;
     asection *input_section;
d3810 1
a3810 1
      outrel[1].r_info = ELF_R_INFO (output_bfd, (unsigned long) 0,
d3814 1
a3814 2
      outrel[2].r_info = ELF_R_INFO (output_bfd, (unsigned long) 0,
				     R_MIPS_NONE);
d3885 1
a3885 2
_bfd_elf_mips_mach (flags)
     flagword flags;
d3964 1
a3964 2
elf_mips_abi_name (abfd)
     bfd *abfd;
d4011 1
a4011 3
_bfd_mips_elf_symbol_processing (abfd, asym)
     bfd *abfd;
     asymbol *asym;
d4087 1
a4087 3
_bfd_mips_elf_section_processing (abfd, hdr)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
d4102 1
a4102 1
      if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
d4141 1
a4141 1
	      if (bfd_bwrite (buf, (bfd_size_type) 8, abfd) != 8)
d4156 1
a4156 1
	      if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)
d4213 2
a4214 4
_bfd_mips_elf_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
d4309 2
a4310 3
      if (! bfd_get_section_contents (abfd, hdr->bfd_section, (PTR) &ext,
				      (file_ptr) 0,
				      (bfd_size_type) sizeof ext))
d4324 1
a4324 1
      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
d4328 1
a4328 1
				      (file_ptr) 0, hdr->sh_size))
d4376 1
a4376 4
_bfd_mips_elf_fake_sections (abfd, hdr, sec)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     asection *sec;
d4498 2
a4499 4
_bfd_mips_elf_section_from_bfd_section (abfd, sec, retval)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     int *retval;
d4518 4
a4521 8
_bfd_mips_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
d4643 1
a4643 2
	     (info, abfd, *namep, BSF_GLOBAL, *secp,
	      (bfd_vma) *valp, (const char *) NULL, FALSE,
d4672 4
a4675 6
_bfd_mips_elf_link_output_symbol_hook (info, name, sym, input_sec, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
     Elf_Internal_Sym *sym;
     asection *input_sec;
     struct elf_link_hash_entry *h ATTRIBUTE_UNUSED;
d4696 1
a4696 3
_bfd_mips_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d4756 2
a4757 3
		 (info, abfd, *namep, BSF_GLOBAL, bfd_und_section_ptr,
		  (bfd_vma) 0, (const char *) NULL, FALSE,
		  get_elf_backend_data (abfd)->collect, &bh)))
d4801 2
a4802 3
	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr,
	     (bfd_vma) 0, (const char *) NULL, FALSE,
	     get_elf_backend_data (abfd)->collect, &bh)))
d4825 1
a4825 2
		(info, abfd, name, BSF_GLOBAL, s,
		 (bfd_vma) 0, (const char *) NULL, FALSE,
d4846 2
a4847 5
_bfd_mips_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d4906 1
a4906 2
		= _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
					     (Elf_Internal_Rela *) NULL,
d4948 1
a4948 1
	      n = (asection **) bfd_zalloc (abfd, amt);
d5338 3
a5340 5
_bfd_mips_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d5358 1
a5358 2
  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
					       (Elf_Internal_Rela *) NULL,
d5467 1
a5467 1
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
d5473 1
a5473 1
					      (file_ptr) 0, sec->_raw_size))
d5520 2
a5521 3
_bfd_mips_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d5622 2
a5623 3
_bfd_mips_elf_always_size_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d5638 1
a5638 2
    bfd_set_section_size (output_bfd, ri,
			  (bfd_size_type) sizeof (Elf32_External_RegInfo));
d5643 1
a5643 2
				 mips_elf_check_mips16_stubs,
				 (PTR) NULL);
d5712 2
a5713 3
_bfd_mips_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d5882 1
a5882 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d5997 5
a6001 10
_bfd_mips_elf_relocate_section (output_bfd, info, input_bfd, input_section,
				contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d6021 1
a6021 1
      const char * msg = (const char *) NULL;
d6299 1
a6299 1
		     (info, name, howto->name, (bfd_vma) 0,
d6380 2
a6381 4
mips_elf_irix6_finish_dynamic_symbol (abfd, name, sym)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
     Elf_Internal_Sym *sym;
d6430 4
a6433 5
_bfd_mips_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d6614 1
a6614 1
	  bfd_put_32 (output_bfd, (bfd_vma) 0, s->contents);
d6641 2
a6642 3
_bfd_mips_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d6812 2
a6813 2
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0, sgot->contents);
      MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000,
d6834 1
a6834 1
	  MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0, sgot->contents
d6836 1
a6836 1
	  MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000, sgot->contents
d6902 1
a6902 2
	  qsort ((Elf64_External_Rel *) s->contents + 1,
		 (size_t) s->reloc_count - 1,
d6905 1
a6905 2
	  qsort ((Elf32_External_Rel *) s->contents + 1,
		 (size_t) s->reloc_count - 1,
d6917 1
a6917 2
mips_set_isa_flags (abfd)
     bfd *abfd;
d7014 2
a7015 3
_bfd_mips_elf_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d7101 1
a7101 2
_bfd_mips_elf_additional_program_headers (abfd)
     bfd *abfd;
d7129 2
a7130 3
_bfd_mips_elf_modify_segment_map (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d7147 1
a7147 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d7219 1
a7219 1
		  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d7310 1
a7310 1
	  n = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d7341 5
a7345 6
_bfd_mips_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d7381 4
a7384 5
_bfd_mips_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d7430 3
a7432 3
_bfd_mips_elf_copy_indirect_symbol (bed, dir, ind)
     const struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
d7451 3
a7453 4
_bfd_mips_elf_hide_symbol (info, entry, force_local)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *entry;
     bfd_boolean force_local;
d7525 2
a7526 4
_bfd_mips_elf_discard_info (abfd, cookie, info)
     bfd *abfd;
     struct elf_reloc_cookie *cookie;
     struct bfd_link_info *info;
d7548 1
a7548 2
  cookie->rels = _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
					    (Elf_Internal_Rela *) NULL,
d7584 1
a7584 2
_bfd_mips_elf_ignore_discarded_relocs (sec)
     asection *sec;
d7592 2
a7593 4
_bfd_mips_elf_write_section (output_bfd, sec, contents)
     bfd *output_bfd;
     asection *sec;
     bfd_byte *contents;
d7617 1
a7617 2
			    (file_ptr) sec->output_offset,
			    sec->_cooked_size);
d7631 5
a7635 9
_bfd_mips_elf_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
				 functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
d7646 1
a7646 2
				     line_ptr,
				     (unsigned) (ABI_64_P (abfd) ? 8 : 0),
d7674 1
a7674 1
	  fi = (struct mips_elf_find_line *) bfd_zalloc (abfd, amt);
d7689 1
a7689 1
	  fi->d.fdr = (struct fdr *) bfd_alloc (abfd, amt);
d7701 1
a7701 1
	    (*swap->swap_fdr_in) (abfd, (PTR) fraw_src, fdr_ptr);
d7736 3
a7738 6
_bfd_mips_elf_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
d7747 1
a7747 1
	  section->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d7760 1
a7760 1
	  c = (bfd_byte *) bfd_zalloc (abfd, size);
d7766 1
a7766 1
      memcpy (c + offset, location, (size_t) count);
d7777 7
a7783 8
_bfd_elf_mips_get_relocated_section_contents (abfd, link_info, link_order,
					      data, relocatable, symbols)
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocatable;
     asymbol **symbols;
d7796 1
a7796 1
  reloc_vector = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
d7801 1
a7801 4
  if (!bfd_get_section_contents (input_bfd,
				 input_section,
				 (PTR) data,
				 (file_ptr) 0,
d7864 1
a7864 2
      for (parent = reloc_vector; *parent != (arelent *) NULL;
	   parent++)
d7866 1
a7866 1
	  char *error_message = (char *) NULL;
d7887 1
a7887 1
						 (PTR) data, gp);
d7892 2
a7893 5
	  r = bfd_perform_relocation (input_bfd,
				      *parent,
				      (PTR) data,
				      input_section,
				      relocatable ? abfd : (bfd *) NULL,
d7918 1
a7918 1
		  BFD_ASSERT (error_message != (char *) NULL);
d7953 1
a7953 2
_bfd_mips_elf_link_hash_table_create (abfd)
     bfd *abfd;
d7958 2
a7959 2
  ret = (struct mips_elf_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct mips_elf_link_hash_table *) NULL)
d7988 1
a7988 3
_bfd_mips_elf_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d8000 1
a8000 1
  PTR mdebug_handle = NULL;
d8096 1
a8096 2
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
d8105 1
a8105 1
	  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
d8127 1
a8127 1
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
d8136 1
a8136 3
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
d8159 1
a8159 3
					      (PTR) &ext,
					      (file_ptr) 0,
					      (bfd_size_type) sizeof ext))
d8184 1
a8184 1
	  o->link_order_head = (struct bfd_link_order *) NULL;
d8228 1
a8228 1
	  if (mdebug_handle == (PTR) NULL)
d8257 1
a8257 3
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
d8319 1
a8319 1
		  (*input_swap->swap_ext_in) (input_bfd, (PTR) eraw_src, &ext);
d8388 1
a8388 2
				       mips_elf_output_extsym,
				       (PTR) &einfo);
d8397 1
a8397 1
	  o->link_order_head = (struct bfd_link_order *) NULL;
d8416 1
a8416 3
	      for (p = o->link_order_head;
		   p != (struct bfd_link_order *) NULL;
		   p = p->next)
d8436 1
a8436 1
	      o->link_order_head = (struct bfd_link_order *) NULL;
d8483 1
a8483 1
	  tab = (Elf32_gptab *) bfd_malloc (amt);
d8490 1
a8490 3
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
d8525 2
a8526 3
			 (input_bfd, input_section, (PTR) &ext_gptab,
			  (file_ptr) gpentry,
			  (bfd_size_type) sizeof (Elf32_External_gptab))))
d8554 1
a8554 1
		      new_tab = (Elf32_gptab *) bfd_realloc ((PTR) tab, amt);
d8597 1
a8597 1
	  ext_tab = (Elf32_External_gptab *) bfd_alloc (abfd, amt);
d8613 1
a8613 1
	  o->link_order_head = (struct bfd_link_order *) NULL;
d8623 1
a8623 1
  if (reginfo_sec != (asection *) NULL)
d8628 1
a8628 3
      if (! bfd_set_section_contents (abfd, reginfo_sec, (PTR) &ext,
				      (file_ptr) 0,
				      (bfd_size_type) sizeof ext))
d8632 1
a8632 1
  if (mdebug_sec != (asection *) NULL)
d8643 1
a8643 1
  if (gptab_data_sec != (asection *) NULL)
d8647 1
a8647 2
				      (file_ptr) 0,
				      gptab_data_sec->_raw_size))
d8651 1
a8651 1
  if (gptab_bss_sec != (asection *) NULL)
d8655 1
a8655 2
				      (file_ptr) 0,
				      gptab_bss_sec->_raw_size))
d8666 1
a8666 2
					  (file_ptr) 0,
					  rtproc_sec->_raw_size))
d8738 1
a8738 2
mips_mach_extends_p (base, extension)
     unsigned long base, extension;
d8753 1
a8753 2
mips_32bit_flags_p (flags)
     flagword flags;
d8769 1
a8769 3
_bfd_mips_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d8974 1
a8974 3
_bfd_mips_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d8985 1
a8985 3
_bfd_mips_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
d8987 1
a8987 1
  FILE *file = (FILE *) ptr;
@


1.85
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d4821 1
a4821 2
_bfd_mips_elf_link_output_symbol_hook (abfd, info, name, sym, input_sec)
     bfd *abfd ATTRIBUTE_UNUSED;
d4826 1
@


1.84
log
@* elf-bfd.h (elf_backend_data::elf_backend_modify_segment_map):
Add link info argument.
* elf32-i370.c (elf_backend_modify_segment_map): Likewise.
* elf32-ppc.c (ppc_elf_modify_segment_map): Likewise.
* elf32-xtensa.c (elf_xtensa_modify_segment_map): Likewise.
* elf64-hppa.c (elf64_hppa_modify_segment_map): Likewise.
* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
* elfxx-mips.h (_bfd_mips_elf_modify_segment_map): Likewise.
* elf.c (assign_file_positions_except_relocs,
assign_file_positions_for_segments): Likewise.  Adjust calls.
@
text
@d2322 1
a2322 1
   marked as not elligible for lazy resolution through a function
d2741 1
a2741 1
   range expressable by a signed number with the indicated number of
@


1.83
log
@	* elfxx-mips.c (mips_elf_set_global_got_offset): Don't set no_fn_stub.
	(mips_elf_set_no_stub): New function.
	(mips_elf_multi_got): Call it.
	(_bfd_mips_elf_finish_dynamic_symbol): If a relocation is needed for
	a secondary GOT entry, create an R_MIPS_32 or R_MIPS_64 relocation and
	use mips_elf_create_dynamic_relocation to deal with any compatibility
	issues.  Store the adjusted addend in the GOT slot.
@
text
@d7311 1
a7311 1
_bfd_mips_elf_modify_segment_map (abfd)
d7313 1
@


1.82
log
@	* elfxx-mips.c (mips_elf_merge_gots): Weaken assert for local
	GOT entries.
@
text
@d474 1
a2341 4
	  /* We can't do lazy update of GOT entries for
	     non-primary GOTs since the PLT entries don't use the
	     right offsets, so punt at it for now.  */
	  entry->d.h->no_fn_stub = TRUE;
d2357 17
d2641 5
d6682 1
a6683 3
      bfd_vma value;
      Elf_Internal_Rela rel[3];
      bfd_vma addend = 0;
a6690 12
      if (info->shared
	  || h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
	value = 0;
      else if (sym->st_value)
	value = sym->st_value;
      else
	value = h->root.u.def.value;

      memset (rel, 0, sizeof (rel));
      rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_REL32);

d6698 21
a6718 1
	      rel[0].r_offset = rel[1].r_offset = rel[2].r_offset = offset;
d6720 9
a6728 14
	      MIPS_ELF_PUT_WORD (output_bfd, value, sgot->contents + offset);

	      if ((info->shared
		   || (elf_hash_table (info)->dynamic_sections_created
		       && p->d.h != NULL
		       && ((p->d.h->root.elf_link_hash_flags
			    & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
		       && ((p->d.h->root.elf_link_hash_flags
			    & ELF_LINK_HASH_DEF_REGULAR) == 0)))
		  && ! (mips_elf_create_dynamic_relocation
			(output_bfd, info, rel,
			 e.d.h, NULL, value, &addend, sgot)))
		return FALSE;
	      BFD_ASSERT (addend == 0);
@


1.81
log
@Fix decision about when a .interp section should exist
@
text
@d2266 1
a2266 1
      BFD_ASSERT (old_lcount + lcount == arg->primary->local_gotno);
d2290 1
a2290 1
      BFD_ASSERT (old_lcount + lcount == arg->current->local_gotno);
@


1.80
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d5874 1
a5874 1
      if (! info->shared)
@


1.79
log
@	* elfxx-mips.c (mips_elf_create_got_section): Initialize global_gotno.
@
text
@d7916 1
a7916 1
     PTR location;
@


1.78
log
@	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Don't add
	DT_MIPS_LIBLIST or DT_MIPS_CONFLICT entries.
	(_bfd_mips_elf_finish_dynamic_symbol): Don't handle them.  Don't
	handle DT_MIPS_MSYM.  Set DT_RELSZ based on the number of relocations
	that were needed.
	(_bfd_mips_elf_modify_segment_map): Fix placement of PT_MIPS_OPTIONS.
	(_bfd_mips_elf_merge_private_bfd_data): Ignore EF_MIPS_UCODE.
@
text
@d2870 1
@


1.77
log
@	* elfxx-mips.c (STUB_MOVE,STUB_LI16): Fix stub code
	for non-SGI N64 ABI. Improve code consitency.
@
text
@a6090 24
      if (SGI_COMPAT (output_bfd))
	{
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICTNO, 0))
	    return FALSE;
	}

      if (SGI_COMPAT (output_bfd))
	{
	  if (!MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLISTNO, 0))
	    return FALSE;
	}

      if (bfd_get_section_by_name (dynobj, ".conflict") != NULL)
	{
	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_CONFLICT, 0))
	    return FALSE;

	  s = bfd_get_section_by_name (dynobj, ".liblist");
	  BFD_ASSERT (s != NULL);

	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_LIBLIST, 0))
	    return FALSE;
	}

a6859 7
	      goto get_vma;
	    case DT_MIPS_CONFLICT:
	      name = ".conflict";
	      goto get_vma;
	    case DT_MIPS_LIBLIST:
	      name = ".liblist";
	    get_vma:
a6872 21
	    case DT_MIPS_CONFLICTNO:
	      name = ".conflict";
	      elemsize = sizeof (Elf32_Conflict);
	      goto set_elemno;

	    case DT_MIPS_LIBLISTNO:
	      name = ".liblist";
	      elemsize = sizeof (Elf32_Lib);
	    set_elemno:
	      s = bfd_get_section_by_name (output_bfd, name);
	      if (s != NULL)
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val = s->_cooked_size / elemsize;
		  else
		    dyn.d_un.d_val = s->_raw_size / elemsize;
		}
	      else
		dyn.d_un.d_val = 0;
	      break;

d6940 10
a6949 3
	    case DT_MIPS_MSYM:
	      s = (bfd_get_section_by_name (output_bfd, ".msym"));
	      dyn.d_un.d_ptr = s->vma;
d7330 1
a7330 1
     PT_OPTIONS segment immediately following the program header
d7347 5
a7351 9
	  /* Usually, there's a program header table.  But, sometimes
	     there's not (like when running the `ld' testsuite).  So,
	     if there's no program header table, we just put the
	     options segment at the end.  */
	  for (pm = &elf_tdata (abfd)->segment_map;
	       *pm != NULL;
	       pm = &(*pm)->next)
	    if ((*pm)->p_type == PT_PHDR)
	      break;
d9041 5
@


1.76
log
@[ bfd/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* archures.c (bfd_mach_mipsisa64r2): New define.
	* bfd-in2.h: Regenerate.
	* aoutx.h (NAME(aout,machine_type)): Handle bfd_mach_mipsisa64r2.
	* cpu-mips.c (I_mipsisa64r2): New enum value.
	(arch_info_struct): Add entry for I_mipsisa64r2.
	* elfxx-mips.c (_bfd_elf_mips_mach)
	(_bfd_mips_elf_print_private_bfd_data): Handle E_MIPS_ARCH_64R2.
	(mips_set_isa_flags): Add bfd_mach_mipsisa64r2 case.
	(mips_mach_extensions): Add entry for bfd_mach_mipsisa64r2.

[ binutils/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_ARCH_64R2.

[ gas/Changelog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* configure.in (mipsisa64r2, mipsisa64r2el, mipsisa64r2*): New CPUs.
	* configure: Regenerate.
	* config/tc-mips.c (imm2_expr): New variable.
	(md_assemble, mips16_ip): Initialize imm2_expr.
	(ISA_HAS_64BIT_REGS, ISA_HAS_DROR, ISA_HAS_ROR): Add ISA_MIPS64R2.
	(macro_build): Handle +A, +B, +C, +E, +F, +G, and +H format operands.
	(macro): Handle M_DEXT and M_DINS.
	(validate_mips_insn): Handle +E, +F, +G, +H, and +I format operands.
	(mips_ip): Likewise.
	(OPTION_MIPS64R2): New define.
	(md_longopts): New entry for -mips64r2 (OPTION_MIPS64R2).
	OPTION_ASE_BASE): Increase to compensate for OPTION_MIPS64R2.
	(md_parse_option): Handle OPTION_MIPS64R2.
	(s_mipsset): Handle setting "mips64r2" ISA.
	(mips_cpu_info_table): Add mips64r2.
	(md_show_usage): Document -mips64r2 option.
	* doc/as.texinfo: Docuemnt -mips64r2 option.
	* doc/c-mips.texi: Likewise.

[ gas/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0-names-mips64r2.d: New file.
	* gas/mips/cp0sel-names-mips64r2.d: New file.
	* gas/mips/elf_arch_mips64r2.d: New file.
	* gas/mips/hwr-names-mips64r2.d: New file.
	* gas/mips/mips32r2-ill-fp64.l: New file.
	* gas/mips/mips32r2-ill-fp64.s: New file.
	* gas/mips/mips64r2-ill.l: New file.
	* gas/mips/mips64r2-ill.s: New file.
	* gas/mips/mips64r2.d: New file.
	* gas/mips/mips64r2.s: New file.
	* gas/mips/mips.exp: Define "mips64r2" arch, and run new tests.

[ include/elf/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (E_MIPS_ARCH_64R2): New define.

[ include/opcode/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Document +E, +F, +G, +H, and +I operand types.
	Update documentation of I, +B and +C operand types.
	(INSN_ISA64R2, ISA_MIPS64R2, CPU_MIPS64R2): New defines.
	(M_DEXT, M_DINS): New enum values.

[ ld/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* ldmain.c (get_emulation): Ignore "-mips64r2".

[ ld/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* ld-mips-elf/mips-elf-flags.exp: Add tests for combinations
	with MIPS64r2.

[ opcodes/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_arch_choices): Add entry for "mips64r2"
	(print_insn_args): Add handing for +E, +F, +G, and +H.
	* mips-opc.c (I65): New define for MIPS64r2.
	(mips_builtin_opcodes): Add "dext", "dextm", "dextu", "dins",
	"dinsm", "dinsu", "drotl", "drotr", "drotr32", "drotrv", "dsbh",
	and "dshd" for MIPS64r2.  Adjust "dror", "dror32", and "drorv" to
	be supported on MIPS64r2.
@
text
@d590 1
a590 2
/* Instructions which appear in a stub.  For some reason the stub is
   slightly different on an SGI system.  */
d596 4
a599 2
  (SGI_COMPAT (abfd) ? 0x03e07825 : 0x03e07821)         /* move t7,ra */
#define STUB_JALR 0x0320f809				/* jal t9 */
d601 3
a603 1
  (SGI_COMPAT (abfd) ? 0x34180000 : 0x24180000)         /* ori t8,zero,0 */
@


1.75
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@d4059 4
d7199 4
d8940 1
d9287 2
@


1.74
log
@Better handking for unresolved symbols
@
text
@d9299 7
a9305 14
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".lit4",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".lit8",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".ucode",		0,	NULL,	0,
    SHT_MIPS_UCODE,	0 },
  { ".mdebug",		0,	NULL,	0,
    SHT_MIPS_DEBUG,	0 },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.73
log
@	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Fix PT_DYNAMIC
	code to work with 64-bit bfds.
@
text
@d3011 2
d3026 1
a3026 1
      if (strcmp (h->root.root.root.string, "_gp_disp") == 0
d3059 1
a3059 1
	       && !info->no_undefined
d3062 2
a3063 2
      else if (strcmp (h->root.root.root.string, "_DYNAMIC_LINK") == 0 ||
              strcmp (h->root.root.root.string, "_DYNAMIC_LINKING") == 0)
d3080 2
a3081 1
		  (!info->shared || info->no_undefined
@


1.72
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d7477 1
a7477 1
	  low = 0xffffffff;
@


1.71
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d4988 1
a4988 1
  struct elf_backend_data *bed;
d6174 1
a6174 1
  struct elf_backend_data *bed;
d7629 1
a7629 1
     struct elf_backend_data *bed;
@


1.70
log
@include/opcode/
	* mips.h (CPU_RM7000): New macro.
	(OPCODE_IS_MEMBER): Match CPU_RM7000 against 4650 insns.

bfd/
	* archures.c (bfd_mach_mips7000): New.
	* bfd-in2.h: Regenerated.
	* cpu-mips.c (arch_info_struct): Add an entry for mips:7000.
	* elfxx-mips.c (mips_set_isa_flags): Handle bfd_mach_mips7000.
	(mips_mach_extensions): Add an entry for it.

opcodes/
	* mips-dis.c (mips_arch_choices): Add rm7000 and rm9000 entries.

gas/
	* config/tc-mips.c (hilo_interlocks): True for CPU_RM7000.
	(mips_cpu_info_table): Add rm7000 and rm9000 entries.

gas/testsuite/
	* gas/mips/rm7000.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d9293 18
@


1.69
log
@	* elfxx-mips.c (mips_elf_link_hash_entry): Remove min_dyn_reloc_index.
	(bfd_mips_elf_swap_msym_in, bfd_mips_elf_swap_msym_out): Delete.
	(mips_elf_create_msym_section): Delete.
	(mips_elf_create_dynamic_relocation): Don't set min_dyn_reloc_index.
	(_bfd_mips_elf_copy_indirect_symbol): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Don't create .msym.
	(_bfd_mips_elf_size_dynamic_sections): Don't calculate its size.
	(_bfd_mips_elf_size_dynamic_sections): Don't add DT_MIPS_MSYM.
	(_bfd_mips_elf_finish_dynamic_symbol): Don't add symbols to .msym.
	(_bfd_mips_elf_finish_dynamic_sections): Likewise.
@
text
@d7166 1
d8949 1
@


1.68
log
@	* elfxx-mips.c (mips_elf_irix6_finish_dynamic_symbol): Make the
	symbols protected.
@
text
@a190 4
  /* The index of the first dynamic relocation (in the .rel.dyn
     section) against this symbol.  */
  unsigned int min_dyn_reloc_index;

a388 6
#if 0
static void bfd_mips_elf_swap_msym_in
  PARAMS ((bfd *, const Elf32_External_Msym *, Elf32_Internal_Msym *));
#endif
static void bfd_mips_elf_swap_msym_out
  PARAMS ((bfd *, const Elf32_Internal_Msym *, Elf32_External_Msym *));
a434 2
static asection *mips_elf_create_msym_section
  PARAMS ((bfd *));
a720 1
      ret->min_dyn_reloc_index = 0;
a1181 25

#if 0
/* Swap in an MSYM entry.  */

static void
bfd_mips_elf_swap_msym_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_Msym *ex;
     Elf32_Internal_Msym *in;
{
  in->ms_hash_value = H_GET_32 (abfd, ex->ms_hash_value);
  in->ms_info = H_GET_32 (abfd, ex->ms_info);
}
#endif
/* Swap out an MSYM entry.  */

static void
bfd_mips_elf_swap_msym_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_Internal_Msym *in;
     Elf32_External_Msym *ex;
{
  H_PUT_32 (abfd, in->ms_hash_value, ex->ms_hash_value);
  H_PUT_32 (abfd, in->ms_info, ex->ms_info);
}
a2881 28

/* Returns the .msym section for ABFD, creating it if it does not
   already exist.  Returns NULL to indicate error.  */

static asection *
mips_elf_create_msym_section (abfd)
     bfd *abfd;
{
  asection *s;

  s = bfd_get_section_by_name (abfd, ".msym");
  if (!s)
    {
      s = bfd_make_section (abfd, ".msym");
      if (!s
	  || !bfd_set_section_flags (abfd, s,
				     SEC_ALLOC
				     | SEC_LOAD
				     | SEC_HAS_CONTENTS
				     | SEC_LINKER_CREATED
				     | SEC_READONLY)
	  || !bfd_set_section_alignment (abfd, s,
					 MIPS_ELF_LOG_FILE_ALIGN (abfd)))
	return NULL;
    }

  return s;
}
a3944 7
  /* Record the index of the first relocation referencing H.  This
     information is later emitted in the .msym section.  */
  if (h != NULL
      && (h->min_dyn_reloc_index == 0
	  || sreloc->reloc_count < h->min_dyn_reloc_index))
    h->min_dyn_reloc_index = sreloc->reloc_count;

a4844 7
  /* Create the .msym section on IRIX6.  It is used by the dynamic
     linker to speed up dynamic relocations, and to avoid computing
     the ELF hash for symbols.  */
  if (IRIX_COMPAT (abfd) == ict_irix6
      && !mips_elf_create_msym_section (abfd))
    return FALSE;

a6006 4
      else if (strcmp (name, ".msym") == 0)
	s->_raw_size = (sizeof (Elf32_External_Msym)
			* (elf_hash_table (info)->dynsymcount
			   + bfd_count_sections (output_bfd)));
a6150 4

      if (bfd_get_section_by_name (dynobj, ".msym")
	  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_MSYM, 0))
	return FALSE;
a6607 1
  asection *smsym;
a6609 1
  struct mips_elf_link_hash_entry *mh;
a6612 1
  mh = (struct mips_elf_link_hash_entry *) h;
a6725 15
  /* Create a .msym entry, if appropriate.  */
  smsym = bfd_get_section_by_name (dynobj, ".msym");
  if (smsym)
    {
      Elf32_Internal_Msym msym;

      msym.ms_hash_value = bfd_elf_hash (h->root.root.string);
      /* It is undocumented what the `1' indicates, but IRIX6 uses
	 this value.  */
      msym.ms_info = ELF32_MS_INFO (mh->min_dyn_reloc_index, 1);
      bfd_mips_elf_swap_msym_out
	(dynobj, &msym,
	 ((Elf32_External_Msym *) smsym->contents) + h->dynindx);
    }

a7047 1
    asection *smsym;
a7050 23
    /* ??? The section symbols for the output sections were set up in
       _bfd_elf_final_link.  SGI sets the STT_NOTYPE attribute for these
       symbols.  Should we do so?  */

    smsym = bfd_get_section_by_name (dynobj, ".msym");
    if (smsym != NULL)
      {
	Elf32_Internal_Msym msym;

	msym.ms_hash_value = 0;
	msym.ms_info = ELF32_MS_INFO (0, 1);

	for (s = output_bfd->sections; s != NULL; s = s->next)
	  {
	    long dynindx = elf_section_data (s)->dynindx;

	    bfd_mips_elf_swap_msym_out
	      (output_bfd, &msym,
	       (((Elf32_External_Msym *) smsym->contents)
		+ dynindx));
	  }
      }

a7642 4
  if (dirmips->min_dyn_reloc_index == 0
      || (indmips->min_dyn_reloc_index != 0
	  && indmips->min_dyn_reloc_index < dirmips->min_dyn_reloc_index))
    dirmips->min_dyn_reloc_index = indmips->min_dyn_reloc_index;
@


1.67
log
@	* elfxx-mips.c (mips_elf_create_dynamic_relocation): Fix handling
	of relocations whose offset is -2.
@
text
@d6671 1
@


1.66
log
@	* bfd/elfxx-mips.c (mips_elf_create_dynamic_relocation): Treat
	forced-local symbols like other locals.  Don't create relocations
	against STN_UNDEF in irix objects.
@
text
@d3878 2
a3879 2
  if (outrel[0].r_offset == (bfd_vma) -1
      || outrel[0].r_offset == (bfd_vma) -2)
d3881 8
@


1.65
log
@	* bfd/elfxx-mips.c (mips_elf_create_dynamic_relocation): In SGI-
	compatible objects, add the values of defined external symbols
	to the addend.
@
text
@d3896 4
a3899 1
				   & ELF_LINK_HASH_DEF_REGULAR) == 0))
a3901 4
	  /* h->root.dynindx may be -1 if this symbol was marked to
	     become local.  */
	  if (indx == -1)
	    indx = 0;
d3939 6
a3944 1
	  indx = 0;
@


1.64
log
@	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Always
	initialize a GOT entry to the symbol's st_value.
@
text
@d3890 1
d3903 9
d3941 1
d3948 1
a3948 1
      if (!indx && r_type != R_MIPS_REL32)
@


1.63
log
@	* elfxx-mips.c: Allow lazy binding for R_MIPS_JALR.
@
text
@d6735 1
a6735 16
      if (sym->st_value)
	value = sym->st_value;
      else
	{
	  /* For an entity defined in a shared object, this will be
	     NULL.  (For functions in shared objects for
	     which we have created stubs, ST_VALUE will be non-NULL.
	     That's because such the functions are now no longer defined
	     in a shared object.)  */

	  if ((info->shared && h->root.type == bfd_link_hash_undefined)
	      || h->root.type == bfd_link_hash_undefweak)
	    value = 0;
	  else
	    value = h->root.u.def.value;
	}
@


1.62
log
@	* elfxx-mips.c: Revert .got alignment to 2**4.
@
text
@d5498 1
@


1.61
log
@	* elfxx-mips.c (_bfd_mips_elf_fake_sections): Remove non-default
	relocation header setup.
	* binutils-all/readelf.ss-tmips: Adjust symbol indices.
@
text
@d2873 2
d2878 1
a2878 1
      || ! bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd)))
@


1.60
log
@Correct spelling of "relocatable".
@
text
@d4642 5
a4646 24
  /* The generic elf_fake_sections will set up REL_HDR using the
     default kind of relocations.  But, we may actually need both
     kinds of relocations, so we set up the second header here.

     This is not necessary for the O32 ABI since that only uses Elf32_Rel
     relocations (cf. System V ABI, MIPS RISC Processor Supplement,
     3rd Edition, p. 4-17).  It breaks the IRIX 5/6 32-bit ld, since one
     of the resulting empty .rela.<section> sections starts with
     sh_offset == object size, and ld doesn't allow that.  While the check
     is arguably bogus for empty or SHT_NOBITS sections, it can easily be
     avoided by not emitting those useless sections in the first place.  */
  if (! SGI_COMPAT (abfd) && ! NEWABI_P(abfd)
      && (sec->flags & SEC_RELOC) != 0)
    {
      struct bfd_elf_section_data *esd;
      bfd_size_type amt = sizeof (Elf_Internal_Shdr);

      esd = elf_section_data (sec);
      BFD_ASSERT (esd->rel_hdr2 == NULL);
      esd->rel_hdr2 = (Elf_Internal_Shdr *) bfd_zalloc (abfd, amt);
      if (!esd->rel_hdr2)
	return FALSE;
      _bfd_elf_init_reloc_shdr (abfd, esd->rel_hdr2, sec, !sec->use_rela_p);
    }
@


1.59
log
@	* elfxx-mips.c (MIPS_ELF_OPTIONS_SECTION_NAME): Use .MIPS.options
	for n32, too.
	(MIPS_ELF_STUB_SECTION_NAME): Use .MIPS.stubs for n32, too.
	(mips_elf_rel_dyn_section): Use appropriate section alignment.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* ld-mips-elf/multi-got-1.d: Adjust addresses.
	* ld-mips-elf/rel32-n32.d: Likewise.
@
text
@d1083 1
a1083 1
			       relocateable, data, gp)
d1088 1
a1088 1
     bfd_boolean relocateable;
d1119 1
a1119 1
     are producing relocateable output, we don't want to do this for
d1121 1
a1121 1
  if (! relocateable
d1134 1
a1134 1
  if (relocateable)
d3154 1
a3154 1
  if (r_type != R_MIPS16_26 && !info->relocateable
d3175 1
a3175 1
  else if (r_type == R_MIPS16_26 && !info->relocateable
d3211 1
a3211 1
  *require_jalxp = (!info->relocateable
d3653 1
a3653 1
	 When producing a relocateable object file, R_MIPS16_26 is
d3691 1
a3691 1
	 When producing a relocateable object file, the calculation is
d3697 1
a3697 1
      if (!info->relocateable)
d5064 1
a5064 1
  if (info->relocateable)
d5560 1
a5560 1
  if (link_info->relocateable)
d5751 1
a5751 1
  if (! info->relocateable
d5849 1
a5849 1
  if (! (info->relocateable
d6387 1
a6387 1
      if (info->relocateable)
d6401 1
a6401 1
	     that we're adjusting GP in this relocateable object.  */
d8132 1
a8132 1
					      data, relocateable, symbols)
d8137 1
a8137 1
     bfd_boolean relocateable;
d8245 1
a8245 1
						 input_section, relocateable,
d8255 1
a8255 1
				      relocateable ? abfd : (bfd *) NULL,
d8259 1
a8259 1
	  if (relocateable)
d8466 1
a8466 1
      else if (info->relocateable)
d8787 1
a8787 1
	  if (! info->relocateable)
@


1.58
log
@	* elf32-mips.c (mips_elf_generic_reloc): New Function.
	(elf_mips_howto_table_rel): Use it.
	(gprel32_with_gp): Move prototype.
	(mips_elf_hi16_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Use mips_elf_generic_reloc.
	(mips_elf_got16_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Code cleanup.
	(_bfd_mips_elf32_gprel16_reloc): Check for ! BSF_LOCAL instead of
	zero addend.
	(mips_elf_gprel32_reloc): Likewise. Use the same GP assignment logic
	as in the other *_gprel*_reloc functions.
	(gprel32_with_gp): Handle partial_inplace properly.
	(mips32_64bit_reloc): Use mips_elf_generic_reloc.
	(mips16_gprel_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Do addend handling directly instead of calling
	_bfd_mips_elf_gprel16_with_gp. Handle partial_inplace properly.
	* elf64-mips.c (mips_elf64_hi16_reloc): Check for ! BSF_LOCAL instead
	of zero addend. Handle partial_inplace properly.
	(mips_elf64_got16_reloc): Check for ! BSF_LOCAL instead of zero
	addend.
	(mips_elf64_gprel16_reloc): Likewise.
	(mips_elf64_literal_reloc): Likewise.
	(mips_elf64_gprel32_reloc): Likewise. Use the same GP assignment
	logic as in the other *_gprel*_reloc functions. Handle
	partial_inplace properly.
	(mips_elf64_shift6_reloc): Check for ! BSF_LOCAL instead of zero
	addend. Handle partial_inplace properly.
	(mips16_gprel_reloc): Likewise. Do addend handling directly instead
	of calling _bfd_mips_elf_gprel16_with_gp.
	* elfn32-mips.c (mips_elf_got16_reloc): Check for BSF_LOCAL.
	(mips_elf_gprel32_reloc): Check for ! BSF_LOCAL instead
	of zero addend.
	(mips_elf_shift6_reloc): Handle partial_inplace properly.
	(mips16_gprel_reloc): Likewise. Do addend handling directly instead
	of calling _bfd_mips_elf_gprel16_with_gp.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp): Handle
	partial_inplace properly. Fix wrong addend handling. Fix overflow
	check.
	(_bfd_mips_elf_sign_extend): Renamed from mips_elf_sign_extend and
	exported.
	(mips_elf_calculate_relocation): Use _bfd_mips_elf_sign_extend.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_dynamic_relocation): Update sec_info_type access.
	* elfxx-mips.h (_bfd_mips_relax_section): Fix prototype declaration.
	(_bfd_mips_elf_sign_extend): New prototype.
	* config/tc-mips.c (md_pcrel_from): Return actual pcrel address.
	(md_apply_fix3): Ignore non-special relocations. Remove superfluous
	exceptions from size assert. Remove most of the addend fixup
	specialcasing. Remove value, use valP directly. simplify fx_addnumber
	handling. Remove zero addend specialcases.
	(tc_gen_reloc): Use appropriate value for reloc2 addend. Remove
	the addend fixup specialcase.
	* config/tc-mips.h (MD_APPLY_SYM_VALUE): Define as 0.
@
text
@d519 1
a519 1
  (ABI_64_P (abfd) ? ".MIPS.options" : ".options")
d523 1
a523 1
  (ABI_64_P (abfd) ? ".MIPS.stubs" : ".stub")
d1666 1
a1666 1
					  4))
d2876 1
a2876 1
      || ! bfd_set_section_alignment (abfd, s, 4))
d4977 1
a4977 1
	bfd_set_section_alignment (abfd, s, 4);
d4980 1
a4980 1
	bfd_set_section_alignment (abfd, s, 4);
d4983 1
a4983 1
	bfd_set_section_alignment (abfd, s, 4);
d4986 1
a4986 1
	bfd_set_section_alignment (abfd, s, 4);
d4989 1
a4989 1
	bfd_set_section_alignment (abfd, s, 4);
@


1.57
log
@	* elfxx-mips.c (_bfd_mips_elf_discard_info): Correct loop index.
	Reported by Ken Faiczak <kfaiczak@@SANDVINE.com>.
@
text
@a436 1
static bfd_vma mips_elf_sign_extend PARAMS ((bfd_vma, int));
d1093 2
a1094 2
  unsigned long insn;
  unsigned long val;
d1107 2
a1108 1
  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1110 1
a1110 2
  /* Set val to the offset into the section or symbol.  */
  if (reloc_entry->howto->src_mask == 0)
d1112 2
a1113 8
      /* This case occurs with the 64-bit MIPS ELF ABI.  */
      val = reloc_entry->addend;
    }
  else
    {
      val = ((insn & 0xffff) + reloc_entry->addend) & 0xffff;
      if (val & 0x8000)
	val -= 0x10000;
d1115 2
d1125 8
a1132 2
  insn = (insn & ~0xffff) | (val & 0xffff);
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);
d1136 1
a1136 2

  else if ((long) val >= 0x8000 || (long) val < -0x8000)
d2744 2
a2745 2
static bfd_vma
mips_elf_sign_extend (value, bits)
d3308 1
a3308 1
      value = symbol + mips_elf_sign_extend (addend, 16);
d3359 1
a3359 1
      value = symbol + mips_elf_sign_extend (addend << 2, 18) - p;
d3384 1
a3384 1
	value = (mips_elf_sign_extend (addend << 2, 28) + symbol) >> 2;
d3444 1
a3444 1
	addend = mips_elf_sign_extend (addend, 16);
d3493 1
a3493 1
      value = mips_elf_sign_extend (addend, 16) + symbol - p;
d3856 1
a3856 1
  if (elf_section_data (input_section)->sec_info_type != ELF_INFO_TYPE_STABS)
d6356 1
a6356 1
		  l = mips_elf_sign_extend (l, 16);
@


1.56
log
@	* elfxx-mips.c: Don't force symbols local unconditionally.
@
text
@d7901 1
a7901 1
  for (i = 0, skip = 0; i < o->_raw_size; i ++)
@


1.55
log
@	* elfxx-mips.c (mips_elf_hash_sort_data): Fix formattting.
	(mips_elf_link_hash_table): Likewise.
@
text
@d7802 1
a7802 1
  h->forced_local = TRUE;
d7805 1
a7805 1
  if (dynobj != NULL)
@


1.54
log
@2003-05-07  Eric Christopher  <echristo@@redhat.com>
	    Alexandre Oliva   <aoliva@@redhat.com>

	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Adjust
	pic tests, change to warning.
	(_bfd_mips_elf_final_link): Remove EF_MIPS_CPIC flag setting.

2003-05-07  Eric Christopher  <echristo@@redhat.com>

        * config/tc-mips.c (mips_abicalls): New variable.
        (md_parse_option): Use.
        (s_option): Ditto.
        (s_abicalls): Ditto.
        (mips_elf_final_processing): Set EF_MIPS_PIC and
        EF_MIPS_CPIC dependent on above.
@
text
@d166 1
a166 1
     with dynamic relocations pointing to it from non-primary     GOTs).  */
d248 2
a249 1
  bfd *abfd;  struct bfd_link_info *info;
@


1.53
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d166 1
a166 2
     with dynamic relocations pointing to it from non-primary
     GOTs).  */
d248 1
a248 2
  bfd *abfd;
  struct bfd_link_info *info;
d1720 1
a1720 1
  
d1724 1
a1724 1
  
d1728 1
a1728 1
    
d1771 1
a1771 1
      
d1829 1
a1829 1
  
d1887 1
a1887 1
  
d1919 1
a1919 1
      
d1926 1
a1926 1
	      
d1966 1
a1966 1
  hsd.max_unref_got_dynindx = 
d2080 1
a2080 1
	      
d2122 1
a2122 1
	      
d2188 1
a2188 1
  
d2240 1
a2240 1
  
d2269 1
a2269 1
  
d2337 1
a2337 1
      
d2418 1
a2418 1
      
d2438 1
a2438 1
  
d2479 1
a2479 1
  
d2567 1
a2567 1
  
d2593 1
a2593 1
     
d2666 1
a2666 1
  
d2669 1
a2669 1
     
d5371 1
a5371 1
	      
d5376 1
a5376 1
	  
d5600 1
a5600 1
	  
d5663 1
a5663 1
      
d5712 1
a5712 1
 relax_return:  
d5858 1
a5858 1
  
d6023 1
a6023 1
	  
d6783 1
a6783 1
      
a8380 11
  /* If all the things we linked together were PIC, but we're
     producing an executable (rather than a shared object), then the
     resulting file is CPIC (i.e., it calls PIC code.)  */
  if (!info->shared
      && !info->relocateable
      && elf_elfheader (abfd)->e_flags & EF_MIPS_PIC)
    {
      elf_elfheader (abfd)->e_flags &= ~EF_MIPS_PIC;
      elf_elfheader (abfd)->e_flags |= EF_MIPS_CPIC;
    }

d9240 2
a9241 1
  if ((new_flags & EF_MIPS_PIC) != (old_flags & EF_MIPS_PIC))
a9242 2
      new_flags &= ~EF_MIPS_PIC;
      old_flags &= ~EF_MIPS_PIC;
d9244 1
a9244 1
	(_("%s: linking PIC files with non-PIC files"),
d9246 1
a9246 1
      ok = FALSE;
d9249 7
a9255 9
  if ((new_flags & EF_MIPS_CPIC) != (old_flags & EF_MIPS_CPIC))
    {
      new_flags &= ~EF_MIPS_CPIC;
      old_flags &= ~EF_MIPS_CPIC;
      (*_bfd_error_handler)
	(_("%s: linking abicalls files with non-abicalls files"),
	 bfd_archive_filename (ibfd));
      ok = FALSE;
    }
@


1.52
log
@* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Improve
error message for mixing different-endian files.  Check for ABI
compatibility of input files with the selected emulation.
@
text
@d545 1
a545 1
  (get_elf_backend_data (abfd)->s->file_align == 8 ? 3 : 2)
d5109 4
a5112 4
	      sec_relocs = (MNAME(abfd,_bfd_elf,link_read_relocs)
			    (abfd, o, (PTR) NULL,
			     (Elf_Internal_Rela *) NULL,
			     info->keep_memory));
d5564 3
a5566 3
  internal_relocs = (MNAME(abfd,_bfd_elf,link_read_relocs)
                     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
                      link_info->keep_memory));
d7890 3
a7892 4
  cookie->rels = (MNAME(abfd,_bfd_elf,link_read_relocs)
		  (abfd, o, (PTR) NULL,
		   (Elf_Internal_Rela *) NULL,
		   info->keep_memory));
@


1.51
log
@* elfxx-mips.c (mips_elf_calculate_relocation): Adjust two other
occurrences of the same test changed in the previous patch.
Optimize.
@
text
@d9177 6
a9182 1
    return FALSE;
d9187 8
@


1.51.2.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d545 1
a545 1
  (get_elf_backend_data (abfd)->s->log_file_align)
d5109 4
a5112 4
	      sec_relocs
		= _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
					     (Elf_Internal_Rela *) NULL,
					     info->keep_memory);
d5564 3
a5566 3
  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
					       (Elf_Internal_Rela *) NULL,
					       link_info->keep_memory);
d7890 4
a7893 3
  cookie->rels = _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
					    (Elf_Internal_Rela *) NULL,
					    info->keep_memory);
d9177 1
a9177 6
    {
      (*_bfd_error_handler)
	(_("%s: endianness incompatible with that of the selected emulation"),
	 bfd_archive_filename (ibfd));
      return FALSE;
    }
a9181 8

  if (strcmp (bfd_get_target (ibfd), bfd_get_target (obfd)) != 0)
    {
      (*_bfd_error_handler)
	(_("%s: ABI is incompatible with that of the selected emulation"),
	 bfd_archive_filename (ibfd));
      return FALSE;
    }
@


1.51.4.1
log
@	Merge from mainline:

	2003-05-09  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* elf32-s390.c (ELIMINATE_COPY_RELOCS): Define as one.
	(elf_s390_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
	(elf_s390_copy_indirect_symbol): Test whether the weakdef sym has
	already been adjusted before treating it specially.
	* el64-s390.c: Likwise.

	2003-05-08  H.J. Lu <hongjiu.lu@@intel.com>
	* elflink.h (elf_add_default_symbol): After skipping the
	unversioned symbol, go to non-default one.

	2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>
	* elflink.h (elf_link_check_versioned_symbol): Also handle the
	case that a DSO references a hidden symbol which may be
	satisfied by a versioned symbol in another DSO.
	(elf_link_output_extsym): Check versioned definition for hidden
	symbol referenced by a DSO.

	2003-05-06  Alexandre Oliva  <aoliva@@redhat.com>
	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Improve
	error message for mixing different-endian files.  Check for ABI
	compatibility of input files with the selected emulation.
@
text
@d9177 1
a9177 6
    {
      (*_bfd_error_handler)
	(_("%s: endianness incompatible with that of the selected emulation"),
	 bfd_archive_filename (ibfd));
      return FALSE;
    }
a9181 8

  if (strcmp (bfd_get_target (ibfd), bfd_get_target (obfd)) != 0)
    {
      (*_bfd_error_handler)
	(_("%s: ABI is incompatible with that of the selected emulation"),
	 bfd_archive_filename (ibfd));
      return FALSE;
    }
@


1.51.4.2
log
@	* elfxx-mips.c: Don't force symbols local unconditionally.
@
text
@d7803 1
a7803 1
  h->forced_local = force_local;
d7806 1
a7806 1
  if (dynobj != NULL && force_local)
@


1.51.4.3
log
@	* elfxx-mips.c (_bfd_mips_elf_discard_info): Correct loop index.
	Reported by Ken Faiczak <kfaiczak@@SANDVINE.com>.
@
text
@d7903 1
a7903 1
  for (i = 0, skip = 0; i < o->_raw_size / PDR_SIZE; i ++)
@


1.50
log
@* elfxx-mips.c (mips_elf_get_global_gotsym_index): New.
(mips_elf_calculate_relocation): Decay GOT_PAGE/GOT_OFST to
GOT_DISP/addend only if the symbol got a global GOT entry.
@
text
@d3224 1
d3227 5
a3231 4
      if (local_p || ! h
	  || (h->root.dynindx
	      < mips_elf_get_global_gotsym_index (elf_hash_table (info)
						  ->dynobj)))
d3517 1
a3517 1
      if (! (local_p || ! h || h->root.dynindx < 0))
d3528 1
a3528 1
      if (local_p || ! h || h->root.dynindx < 0)
@


1.49
log
@* elfxx-mips.c (mips_elf_calculate_relocation): Decay
GOT_PAGE/GOT_OFST referencing overridable symbol to
GOT_DISP/addend.
(_bfd_mips_elf_check_relocs): Handle GOT_PAGE referencing
global symbol as GOT_DISP.
@
text
@d411 1
d1711 23
d3224 6
a3229 3
      /* If we didn't create a dynamic index for this symbol, it can
	 be regarded as local.  */
      if (local_p || ! h || h->root.dynindx < 0)
@


1.48
log
@	* elfxx-mips.c (_bfd_mips_elf_hide_symbol): Test for NULL dynobj.
@
text
@d3199 7
d3216 5
a3220 1
	  BFD_ASSERT (addend == 0);
d3234 1
a3234 1
	      MIPS_ELF_PUT_WORD (tmpbfd, symbol + addend, sgot->contents + g);
d3453 1
d3485 5
d3499 4
a3502 1
      mips_elf_got_page (abfd, input_bfd, info, symbol + addend, &value);
d5334 38
@


1.47
log
@* elfxx-mips.c (_bfd_mips_relax_section): New function.
* elfxx-mips.h (_bfd_mips_relax_section): Declare.
* elfn32-mips.c, elf64-mips.c: Use it.
@
text
@d7719 4
a7722 2
  got = mips_elf_got_section (dynobj, FALSE);
  g = mips_elf_section_data (got)->u.got_info;
d7724 4
a7727 4
  if (g->next)
    {
      struct mips_got_entry e;
      struct mips_got_info *gg = g;
d7729 8
a7736 8
      /* Since we're turning what used to be a global symbol into a
	 local one, bump up the number of local entries of each GOT
	 that had an entry for it.  This will automatically decrease
	 the number of global entries, since global_gotno is actually
	 the upper limit of global entries.  */
      e.abfd = dynobj;
      e.symndx = -1;
      e.d.h = h;
d7738 7
a7744 7
      for (g = g->next; g != gg; g = g->next)
	if (htab_find (g->got_entries, &e))
	  {
	    BFD_ASSERT (g->global_gotno > 0);
	    g->local_gotno++;
	    g->global_gotno--;
	  }
d7746 16
a7761 5
      /* If this was a global symbol forced into the primary GOT, we
	 no longer need an entry for it.  We can't release the entry
	 at this point, but we must at least stop counting it as one
	 of the symbols that required a forced got entry.  */
      if (h->root.got.offset == 2)
d7763 6
a7768 2
	  BFD_ASSERT (gg->assigned_gotno > 0);
	  gg->assigned_gotno--;
a7769 14
    }
  else if (g->global_gotno == 0 && g->global_gotsym == NULL)
    /* If we haven't got through GOT allocation yet, just bump up the
       number of local entries, as this symbol won't be counted as
       global.  */
    g->local_gotno++;
  else if (h->root.got.offset == 1)
    {
      /* If we're past non-multi-GOT allocation and this symbol had
	 been marked for a global got entry, give it a local entry
	 instead.  */
      BFD_ASSERT (g->global_gotno > 0);
      g->local_gotno++;
      g->global_gotno--;
@


1.46
log
@* Reverted 2003-03-02's patch.
@
text
@d5454 179
@


1.45
log
@* elfxx-mips.c (mips_elf_create_dynamic_relocation): Do not create
dynamic relocations pointing to local or section symbols, use the
NULL symbol instead.  Document the choice to not emit an
additional R_MIPS_64 relocation.
@
text
@d499 1
d2133 1
a2133 1
/* In a multi-got link, determine the GOT to be used for IBFD.  G must
d3319 6
d3453 2
a3454 4
    case R_MIPS_GNU_REL16_S2:
      value = mips_elf_sign_extend (addend << 2, 18) + symbol - p;
      overflowed_p = mips_elf_overflow_p (value, 18);
      value = (value >> 2) & howto->dst_mask;
@


1.44
log
@	* elf32-mips.c (elf_mips_howto_table_rel): Change definition of
	R_MIPS_PC16 to rightshift 2.
	(elf_reloc_map mips_reloc_map): Map to rightshifted BFD reloc.
	(bfd_elf32_bfd_reloc_type_lookup): Support
	BFD_RELOC_MIPSEMB_16_PCREL_S2.
	* elf64-mips.c (mips_elf64_howto_table_rel): Change definition of
	R_MIPS_PC16 to rightshift 2.
	(mips_elf64_howto_table_rela): Likewise.
	(mips_reloc_map): Map to rightshifted BFD reloc.
	* elfn32-mips.c: The same as in elf64-mips.c.
	* elfxx-mips.c (mips_elf_got_for_ibfd): Typo in comment.
	(mips_elf_calculate_relocation): Handle rightshifted addends for
	R_MIPS_PC16.
	* reloc.c (BFD_RELOC_MIPSEMB_16_PCREL_S2): New BFD relocation for
	MIPS Embedded PIC. Remove superfluous empty COMMENT.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* config/tc-mips.c (append_insn): Add handling of
	BFD_RELOC_MIPSEMB_16_PCREL_S2. Avoid emitting unneeded
	BFD_RELOC_16_PCREL_S2 relocs and add earlier warnings about
	misaligned address and reange overflow.
	(macro_build): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2. Add
	earlier warnings about misaligned address and reange overflow.
	(mips_ip): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	(md_apply_fix): Likewise. Fix warning output.
	(tc_gen_reloc): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	Allow BFD_RELOC_16_PCREL_S2 for all ABIs.
	(md_convert_frag): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	* gas/mips/bge.d: Reactivate external branch tests.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.d: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.d: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.d: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.d: New File.
	* gas/mips/branch-misc-2.l: Remove.
	* gas/mips/mips.exp: Adjust branch-misc-2 test.
@
text
@a3834 1
      bfd_vma section_offset;
d3864 12
a3875 9
	  /* Figure out how far the target of the relocation is from
	     the beginning of its section.  */
	  section_offset = symbol - sec->output_section->vma;
	  /* The relocation we're building is section-relative.
	     Therefore, the original addend must be adjusted by the
	     section offset.  */
	  *addendp += section_offset;
	  /* Now, the relocation is just against the section.  */
	  symbol = sec->output_section->vma;
d3889 12
@


1.44.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@a498 1

d2132 1
a2132 1
/* In a multi-got link, determine the GOT to be used for IBDF.  G must
a3317 6
    case R_MIPS_GNU_REL16_S2:
      value = symbol + mips_elf_sign_extend (addend << 2, 18) - p;
      overflowed_p = mips_elf_overflow_p (value, 18);
      value = (value >> 2) & howto->dst_mask;
      break;

d3446 4
a3449 2
      value = mips_elf_sign_extend (addend, 16) + symbol - p;
      overflowed_p = mips_elf_overflow_p (value, 16);
d3835 1
d3865 9
a3873 12
	  /* Instead of generating a relocation using the section
	     symbol, we may as well make it a fully relative
	     relocation.  We want to avoid generating relocations to
	     local symbols because we used to generate them
	     incorrectly, without adding the original symbol value,
	     which is mandated by the ABI for section symbols.  In
	     order to give dynamic loaders and applications time to
	     phase out the incorrect use, we refrain from emitting
	     section-relative relocations.  It's not like they're
	     useful, after all.  This should be a bit more efficient
	     as well.  */
	  indx = 0;
a3886 12
      /* For strict adherence to the ABI specification, we should
	 generate a R_MIPS_64 relocation record by itself before the
	 _REL32/_64 record as well, such that the addend is read in as
	 a 64-bit value (REL32 is a 32-bit relocation, after all).
	 However, since none of the existing ELF64 MIPS dynamic
	 loaders seems to care, we don't waste space with these
	 artificial relocations.  If this turns out to not be true,
	 mips_elf_allocate_dynamic_relocation() should be tweaked so
	 as to make room for a pair of dynamic relocations per
	 invocation if ABI_64_P, and here we should generate an
	 additional relocation record with R_MIPS_64 by itself for a
	 NULL symbol before this relocation record.  */
@


1.43
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@a498 1

d2132 1
a2132 1
/* In a multi-got link, determine the GOT to be used for IBDF.  G must
a3317 6
    case R_MIPS_GNU_REL16_S2:
      value = symbol + mips_elf_sign_extend (addend << 2, 18) - p;
      overflowed_p = mips_elf_overflow_p (value, 18);
      value = (value >> 2) & howto->dst_mask;
      break;

d3446 4
a3449 2
      value = mips_elf_sign_extend (addend, 16) + symbol - p;
      overflowed_p = mips_elf_overflow_p (value, 16);
@


1.42
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d12 1
a12 1
This file is part of BFD, the Binary File Descriptor library.
d14 13
a26 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d362 9
a370 9
	bfd_vma	adr;		/* memory address of start of procedure */
	long	regmask;	/* save register mask */
	long	regoffset;	/* save register offset */
	long	fregmask;	/* save floating point register mask */
	long	fregoffset;	/* save floating point register offset */
	long	frameoffset;	/* frame size */
	short	framereg;	/* frame pointer register */
	short	pcreg;		/* offset or reg of return pc */
	long	irpss;		/* index into the runtime string table */
d372 1
a372 1
	struct exception_info *exception_info;/* pointer to exception array */
a3097 1
	       && (!info->symbolic || info->allow_shlib_undefined)
@


1.41
log
@* elfxx-mips.c (mips_elf_got_entry_hash): Don't dereference
entry->abfd when it's NULL.
@
text
@d151 1
a151 1
  ((struct _mips_elf_section_data *) (sec)->used_by_bfd)
d4603 1
a4603 2
      _bfd_elf_init_reloc_shdr (abfd, esd->rel_hdr2, sec,
				!elf_section_data (sec)->use_rela_p);
@


1.40
log
@* elfxx-mips.c (mips_elf_create_dynamic_relocation): Handle
_bfd_elf_section_offset returning -2 the same way as -1.
@
text
@d1587 1
a1587 1
  return entry->abfd->id + entry->symndx
d1589 3
a1591 2
       : entry->symndx >= 0 ? mips_elf_hash_bfd_vma (entry->d.addend)
       : entry->d.h->root.root.root.hash);
@


1.39
log
@* elfxx-mips.c (mips_elf_multi_got): New function.
(struct mips_got_entry): Make symndx and gotidx signed.  Moved
addend into union along with address and link hash entry.
(struct mips_got_info): Added bfd2got and next.
(struct mips_elf_hash_sort_data): Added max_unref_got_dynindx.
(mips_elf_got_section, mips_elf_create_got_section): Use
SEC_EXCLUDE bit to tell whether we really need the got
section.  Take boolean arguments to disregard an excluded
section, or to create it as excluded.  Adjust all callers.
Use mips_elf_got_section all over.
(mips_elf_local_got_index, mips_elf_got_page,
mips_elf_got16_entry): Take input bfd as argument, and pass it
on to mips_elf_create_local_got_entry.
(mips_elf_global_got_index, mips_elf_create_local_got_entry):
Take input bfd as argument, and manage entries in the
appropriate GOT.
(mips_elf_got_offset_from_index): Take input bfd as argument,
and use it to adjust the GP offset of the bfd.
(mips_elf_sort_hash_table, mips_elf_sort_hash_table_f): Move
unreferenced GOT entries of global symbols to the end.
(mips_elf_record_global_got_symbol): Take input bfd as
argument.  Add entries to the master GOT hash table.
(struct mips_elf_bfd2got_hash): New.
(struct mips_elf_got_per_bfd_arg): New.
(struct mips_elf_set_global_got_offset_arg): New.
(mips_elf_hash_bfd_vma, mips_elf_multi_got_entry_hash,
mips_elf_multi_got_entry_eq, mips_elf_bfd2got_entry_hash,
mips_elf_bfd2got_entry_eq, mips_elf_make_got_per_bfd,
mips_elf_merge_gots, mips_elf_set_global_got_offset,
mips_elf_resolve_final_got_entry,
mips_elf_resolve_final_got_entries, mips_elf_adjust_gp,
mips_elf_got_for_ibfd): New functions.
(ELF_MIPS_GP_OFFSET): Don't depend on SGI_COMPAT.
(MIPS_ELF_GOT_MAX_SIZE): New macro.
(STUB_LW): Generate 64-bit stub regardless of SGI_COMPAT.
(mips_elf_got_entry_hash): Take new fields into account.  Use
mips_elf_hash_bfd_vma.
(mips_elf_got_entry_eq): Take new fields into account.
(mips_elf_create_got_section): Initialize new fields.
(mips_elf_calculate_relocation): Pass input_bfd to functions
that now take it.  Adjust gp for the input_bfd.
(mips_elf_allocate_dynamic_relocation,
mips_elf_create_dynamic_relocation,
_bfd_mips_elf_create_dynamic_sections): Use...
(mips_elf_rel_dyn_section): New function.  Borrow code from...
(_bfd_mips_elf_check_relocs): Pass input_bfd to functions that
now take it.  Create the got section if needed, even if
excluded, before recording a global got symbol.  Move some
code to...
(mips_elf_record_local_got_symbol): New fn.
(_bfd_mips_elf_size_dynamic_sections): Disable combreloc.
Compute multi-got global entries offsets.  Move GOT code to...
(_bfd_mips_elf_always_size_sections): Call mips_elf_multi_got
if the GOT is too big.
(_bfd_mips_elf_finish_dynamic_symbol): Set got entry of
undefweak symbol to zero.  Generate dynamic relocations for
non-primary GOT entries for global symbols.
(_bfd_mips_elf_finish_dynamic_sections): Handle multi-got
case.  Generate dynamic relocations for local got entries.
Sort dynamic relocations on N64 too, using...
(sort_dynamic_relocs_64): New fns.
(_bfd_mips_elf_hide_symbol): Adjust multi-got counters.
(_bfd_mips_elf_merge_private_bfd_data): Ignore EF_MIPS_XGOT.
@
text
@d3828 2
a3829 1
  if (outrel[0].r_offset == (bfd_vma) -1)
a3830 3
  /* FIXME: For -2 runtime relocation needs to be skipped, but
     properly resolved statically and installed.  */
  BFD_ASSERT (outrel[0].r_offset != (bfd_vma) -2);
@


1.38
log
@include/elf/ChangeLog
	* sh.h: Split out various bits to bfd/elf32-sh64.h.

include/opcode/ChangeLog
	* m68hc11.h (cpu6812s): Define.

bfd/ChangeLog
	* elf-bfd.h (struct bfd_elf_section_data): Remove tdata.  Change
	dynindx to an int.  Rearrange for better packing.
	* elf.c (_bfd_elf_new_section_hook): Don't alloc if already done.
	* elf32-mips.c (bfd_elf32_new_section_hook): Define.
	* elf32-sh64.h: New.  Split out from include/elf/sh.h.
	(struct _sh64_elf_section_data): New struct.
	(sh64_elf_section_data): Don't dereference sh64_info (was tdata).
	* elf32-sh64-com.c: Include elf32-sh64.h.
	* elf32-sh64.c: Likewise.
	(sh64_elf_new_section_hook): New function.
	(bfd_elf32_new_section_hook): Define.
	(sh64_elf_fake_sections): Adjust for sh64_elf_section_data change.
	(sh64_bfd_elf_copy_private_section_data): Likewise.
	(sh64_elf_final_write_processing): Likewise.
	* elf32-sparc.c (struct elf32_sparc_section_data): New.
	(elf32_sparc_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(elf32_sparc_relax_section): Adjust to use sec_do_relax.
	(elf32_sparc_relocate_section): Likewise.
	* elf64-mips.c (bfd_elf64_new_section_hook): Define.
	* elf64-mmix.c (struct _mmix_elf_section_data): New.
	(mmix_elf_section_data): Define.  Use throughout file.
	(mmix_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-ppc.c (struct _ppc64_elf_section_data): New.
	(ppc64_elf_section_data): Define.  Use throughout.
	(ppc64_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-sparc.c (struct sparc64_elf_section_data): New.
	(sparc64_elf_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(sparc64_elf_relax_section): Adjust to use sec_do_relax.
	(sparc64_elf_relocate_section): Likewise.
	(bfd_elf64_new_section_hook): Define.
	* elfn32-mips.c (bfd_elf32_new_section_hook): Define.
	* elfxx-mips.c (struct _mips_elf_section_data): New.
	(mips_elf_section_data): Define.  Use throughout.
	(_bfd_mips_elf_new_section_hook): New function.
	(mips_elf_create_got_section): Don't alloc used_by_bfd.
	* elfxx-mips.h (_bfd_mips_elf_new_section_hook): Declare.
	* elfxx-target.h (bfd_elfNN_new_section_hook): Add #ifndef.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

opcodes/ChangeLog
	* sh64-dis.c: Include elf32-sh64.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

gas/ChangeLog
	* config/tc-sh64.c (shmedia_frob_section_type): Adjust for changed
	sh64_elf_section_data.
	* config/tc-sh64.h: Include elf32-sh64.h.
	* config/tc-m68hc11.c: Don't include stdio.h.
	(md_show_usage): Fix missing continuation.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

ld/ChangeLog
	* emultempl/sh64elf.em: Include elf32-sh64.h.
	(sh64_elf_${EMULATION_NAME}_before_allocation): Adjust for changed
	sh64_elf_section_data.
	(sh64_elf_${EMULATION_NAME}_after_allocation): Likewise.
@
text
@d52 15
a66 7
  /* The index of the symbol, as stored in the relocation r_info.  If
     it's -1, the addend is a complete address into the
     executable/shared library.  */
  unsigned long symndx;
  /* The addend of the relocation that should be added to the symbol
     value.  */
  bfd_vma addend;
d68 3
a70 2
     corresponding to this symbol+addend.  */
  unsigned long gotidx;
d88 50
d164 5
d402 2
d407 2
a408 1
static asection * mips_elf_got_section PARAMS ((bfd *));
d412 1
a412 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma));
d414 1
a414 1
  PARAMS ((bfd *, struct elf_link_hash_entry *));
d416 1
a416 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, bfd_vma *));
d418 1
a418 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, bfd_boolean));
d420 1
a420 1
  PARAMS ((bfd *, bfd *, bfd_vma));
d422 1
a422 1
  PARAMS ((bfd *, struct mips_got_info *, asection *, bfd_vma));
d427 2
d430 1
a430 1
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *,
d445 1
a445 1
  PARAMS ((bfd *, struct bfd_link_info *));
d473 1
d477 18
d596 7
a604 1
#define ELF_MIPS_GP_OFFSET(abfd) (SGI_COMPAT (abfd) ? 0x7ff0 : 0x8000)
d606 3
a608 5
  (SGI_COMPAT (abfd)						\
   ? (ABI_64_P (abfd)  						\
      ? 0xdf998010		/* ld t9,0x8010(gp) */		\
      : 0x8f998010)             /* lw t9,0x8010(gp) */		\
   : 0x8f998010)		/* lw t9,0x8000(gp) */
d1334 20
d1562 19
d1587 4
a1590 5
  return htab_hash_pointer (entry->abfd) + entry->symndx
#ifdef BFD64
    + (entry->addend >> 32)
#endif
    + entry->addend;
d1602 38
a1639 1
    && e1->addend == e2->addend;
d1642 29
d1674 1
a1674 1
mips_elf_got_section (abfd)
d1676 1
d1678 5
a1682 1
  return bfd_get_section_by_name (abfd, ".got");
d1697 1
a1697 1
  sgot = mips_elf_got_section (abfd);
d1704 2
a1705 1
    *sgotp = sgot;
d1714 2
a1715 2
mips_elf_local_got_index (abfd, info, value)
     bfd *abfd;
d1725 1
a1725 1
  entry = mips_elf_create_local_got_entry (abfd, g, sgot, value);
d1735 2
a1736 2
mips_elf_global_got_index (abfd, h)
     bfd *abfd;
d1741 1
a1741 1
  struct mips_got_info *g;
d1744 23
a1766 3
  g = mips_elf_got_info (abfd, &sgot);
  if (g->global_gotsym != NULL)
    global_got_dynindx = g->global_gotsym->dynindx;
d1787 2
a1788 2
mips_elf_got_page (abfd, info, value, offsetp)
     bfd *abfd;
d1800 1
a1800 1
  entry = mips_elf_create_local_got_entry (abfd, g, sgot,
d1810 1
a1810 1
    *offsetp = value - entry->addend;
d1819 2
a1820 2
mips_elf_got16_entry (abfd, info, value, external)
     bfd *abfd;
d1840 1
a1840 1
  entry = mips_elf_create_local_got_entry (abfd, g, sgot, value);
d1851 1
a1851 1
mips_elf_got_offset_from_index (dynobj, output_bfd, index)
d1854 1
d1859 1
d1861 5
a1865 4
  sgot = mips_elf_got_section (dynobj);
  gp = _bfd_get_gp_value (output_bfd);
  return (sgot->output_section->vma + sgot->output_offset + index -
	  gp);
d1872 3
a1874 3
mips_elf_create_local_got_entry (abfd, g, sgot, value)
     bfd *abfd;
     struct mips_got_info *g;
d1879 5
d1885 6
a1890 3
  entry.abfd = abfd;
  entry.symndx = (unsigned long)-1;
  entry.addend = value;
d1908 1
a1908 1
      (*loc)->gotidx = (unsigned long)-1;
d1940 2
d1943 10
a1952 1
  hsd.min_got_dynindx = elf_hash_table (info)->dynsymcount;
d1962 2
a1966 1
  g = mips_elf_got_info (dynobj, NULL);
d1992 11
a2002 1
  if (h->root.got.offset != 1)
d2018 1
a2018 1
mips_elf_record_global_got_symbol (h, info, g)
d2020 1
d2022 1
a2022 1
     struct mips_got_info *g ATTRIBUTE_UNUSED;
d2024 2
d2041 7
d2050 11
d2071 576
d2822 1
a2822 1
mips_elf_create_got_section (abfd, info)
d2825 1
d2835 7
a2841 2
  if (mips_elf_got_section (abfd))
    return TRUE;
d2846 3
a2873 3
  /* The first several global offset table entries are reserved.  */
  s->_raw_size = MIPS_RESERVED_GOTNO * MIPS_ELF_GOT_SIZE (abfd);

d2881 2
d3211 1
d3222 1
a3222 1
	      asection *sgot = mips_elf_got_section(tmpbfd);
d3232 2
a3233 1
	  g = mips_elf_local_got_index (abfd, info, symbol + addend);
d3240 1
a3240 1
					  abfd, g);
d3251 5
d3428 2
a3429 1
	  value = mips_elf_got16_entry (abfd, info, symbol + addend, forced);
d3434 1
a3434 1
					      abfd, value);
d3473 1
a3473 1
      value = mips_elf_got_page (abfd, info, symbol + addend, NULL);
d3477 1
a3477 1
					      abfd, value);
d3482 1
a3482 1
      mips_elf_got_page (abfd, info, symbol + addend, &value);
d3753 1
a3753 1
  s = bfd_get_section_by_name (abfd, ".rel.dyn");
d3790 1
a3790 1
  sreloc = bfd_get_section_by_name (dynobj, ".rel.dyn");
d4847 4
a4850 1
  if (! mips_elf_create_got_section (abfd, info))
d5179 1
a5179 1
      sgot = mips_elf_got_section (dynobj);
d5240 1
a5240 1
	      if (! mips_elf_create_got_section (dynobj, info))
a5262 2
	  struct mips_got_entry entry, **loc;

d5270 3
a5272 20

	  entry.abfd = abfd;
	  entry.symndx = r_symndx;
	  entry.addend = rel->r_addend;
	  loc = (struct mips_got_entry **)
	    htab_find_slot (g->got_entries, &entry, INSERT);

	  if (*loc == NULL)
	    {
	      entry.gotidx = g->local_gotno++;

	      *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);

	      if (! *loc)
		return FALSE;
	      
	      memcpy (*loc, &entry, sizeof entry);

	      sgot->_raw_size += MIPS_ELF_GOT_SIZE (dynobj);
	    }
d5293 1
a5293 1
	      if (! mips_elf_record_global_got_symbol (h, info, g))
d5309 1
a5309 1
	  if (h && ! mips_elf_record_global_got_symbol (h, info, g))
d5321 1
a5321 3
		  const char *dname = ".rel.dyn";

		  sreloc = bfd_get_section_by_name (dynobj, dname);
d5323 1
a5323 14
		    {
		      sreloc = bfd_make_section (dynobj, dname);
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc,
						      (SEC_ALLOC
						       | SEC_LOAD
						       | SEC_HAS_CONTENTS
						       | SEC_IN_MEMORY
						       | SEC_LINKER_CREATED
						       | SEC_READONLY))
			  || ! bfd_set_section_alignment (dynobj, sreloc,
							  4))
			return FALSE;
		    }
d5358 10
a5367 3
	      if (h != NULL
		  && ! mips_elf_record_global_got_symbol (h, info, g))
		return FALSE;
d5559 8
d5573 13
a5585 2
  if (info->relocateable
      || ! mips_elf_hash_table (info)->mips16_stubs_seen)
d5588 51
a5638 3
  mips_elf_link_hash_traverse (mips_elf_hash_table (info),
			       mips_elf_check_mips16_stubs,
			       (PTR) NULL);
a5652 1
  struct mips_got_info *g = NULL;
d5728 8
d5740 18
a5757 4
	  int i;
	  bfd_size_type loadable_size = 0;
	  bfd_size_type local_gotno;
	  bfd *sub;
d5759 13
a5771 3
	  BFD_ASSERT (mips_elf_section_data (s) != NULL);
	  g = mips_elf_section_data (s)->u.got_info;
	  BFD_ASSERT (g != NULL);
d5773 8
a5780 15
	  /* Calculate the total loadable size of the output.  That
	     will give us the maximum number of GOT_PAGE entries
	     required.  */
	  for (sub = info->input_bfds; sub; sub = sub->link_next)
	    {
	      asection *subsection;

	      for (subsection = sub->sections;
		   subsection;
		   subsection = subsection->next)
		{
		  if ((subsection->flags & SEC_ALLOC) == 0)
		    continue;
		  loadable_size += ((subsection->_raw_size + 0xf)
				    &~ (bfd_size_type) 0xf);
d5782 3
a5785 25
	  loadable_size += MIPS_FUNCTION_STUB_SIZE;

	  /* Assume there are two loadable segments consisting of
	     contiguous sections.  Is 5 enough?  */
	  local_gotno = (loadable_size >> 16) + 5;

	  g->local_gotno += local_gotno;
	  s->_raw_size += local_gotno * MIPS_ELF_GOT_SIZE (dynobj);

	  /* There has to be a global GOT entry for every symbol with
	     a dynamic symbol table index of DT_MIPS_GOTSYM or
	     higher.  Therefore, it make sense to put those symbols
	     that need GOT entries at the end of the symbol table.  We
	     do that here.  */
 	  if (! mips_elf_sort_hash_table (info, 1))
 	    return FALSE;

	  if (g->global_gotsym != NULL)
	    i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
	  else
	    /* If there are no global symbols, or none requiring
	       relocations, then GLOBAL_GOTSYM will be NULL.  */
	    i = 0;
	  g->global_gotno = i;
	  s->_raw_size += i * MIPS_ELF_GOT_SIZE (dynobj);
d5870 1
a5870 1
      if (bfd_get_section_by_name (dynobj, ".rel.dyn"))
d6413 1
a6413 1
  struct mips_got_info *g;
d6461 1
a6461 1
  sgot = mips_elf_got_section (dynobj);
d6463 1
a6463 1
  BFD_ASSERT (elf_section_data (sgot) != NULL);
d6485 2
a6486 1
	  if (info->shared && h->root.type == bfd_link_hash_undefined)
d6491 1
a6491 1
      offset = mips_elf_global_got_index (dynobj, h);
d6495 53
d6654 1
a6654 1
  struct mips_got_info *g;
d6660 1
a6660 1
  sgot = bfd_get_section_by_name (dynobj, ".got");
d6662 1
a6662 1
    g = NULL;
d6665 4
a6668 2
      BFD_ASSERT (elf_section_data (sgot) != NULL);
      g = mips_elf_section_data (sgot)->u.got_info;
d6698 1
a6698 1
	      s = (bfd_get_section_by_name (dynobj, ".rel.dyn"));
d6784 1
a6784 1
	      if (g->global_gotsym)
d6786 1
a6786 1
		  dyn.d_un.d_val = g->global_gotsym->dynindx;
d6849 35
d6946 4
a6949 1
    if (!ABI_64_P (output_bfd))
d6951 1
a6951 1
	asection *reldyn;
d6953 8
a6960 8
	reldyn = bfd_get_section_by_name (dynobj, ".rel.dyn");
	if (reldyn != NULL && reldyn->reloc_count > 2)
	  {
	    reldyn_sorting_bfd = output_bfd;
	    qsort ((Elf32_External_Rel *) reldyn->contents + 1,
		   (size_t) reldyn->reloc_count - 1,
		   sizeof (Elf32_External_Rel), sort_dynamic_relocs);
	  }
a6961 5

    /* Clean up a first relocation in .rel.dyn.  */
    s = bfd_get_section_by_name (dynobj, ".rel.dyn");
    if (s != NULL && s->_raw_size > 0)
      memset (s->contents, 0, MIPS_ELF_REL_SIZE (dynobj));
d7529 1
a7529 1
  got = bfd_get_section_by_name (dynobj, ".got");
d7532 47
a7579 4

  /* FIXME: Do we allocate too much GOT space here?  */
  g->local_gotno++;
  got->_raw_size += MIPS_ELF_GOT_SIZE (dynobj);
d8138 1
a8138 1
      got = bfd_get_section_by_name (dynobj, ".got");
d8929 5
@


1.37
log
@bfd/
	* elfxx-mips.c: Include libiberty.h.
	(elf_mips_isa, _bfd_mips_elf_mach_extends_p): Remove.
	(mips_set_isa_flags): New function, split out from...
	(_bfd_mips_elf_final_write_processing): ...here.  Only call
	mips_set_isa_flags if the EF_MIPS_MACH bits are clear.
	(mips_mach_extensions): New array.
	(mips_32bit_flags_p): New function.
	(_bfd_mips_elf_merge_private_bfd_data): Rework architecture checks.
	Use mips_32bit_flags_p to check if one binary is 32-bit and the
	other is 64-bit.  When adopting IBFD's architecture, adopt the
	bfd_mach as well as the flags.

ld/testsuite/
	* ld-mips-elf/jr.s: New file.
	* ld-mips-elf/mips-elf-flags.exp: New test.
@
text
@d64 1
a64 2
/* This structure is used to hold .got information when linking.  It
   is stored in the tdata field of the bfd_elf_section_data structure.  */
d81 13
d653 16
d1498 2
a1499 2
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
d2028 2
a2029 9
  if (elf_section_data (s) == NULL)
    {
      amt = sizeof (struct bfd_elf_section_data);
      s->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
      if (elf_section_data (s) == NULL)
	return FALSE;
    }
  elf_section_data (s)->tdata = (PTR) g;
  elf_section_data (s)->this_hdr.sh_flags
d3334 2
a3335 2
      && elf_section_data (hdr->bfd_section) != NULL
      && elf_section_data (hdr->bfd_section)->tdata != NULL)
d3339 3
a3341 3
      /* We stored the section contents in the elf_section_data tdata
	 field in the set_section_contents routine.  We save the
	 section contents so that we don't have to read them again.
d3346 1
a3346 1
      contents = (bfd_byte *) elf_section_data (hdr->bfd_section)->tdata;
d4313 2
a4314 2
	  BFD_ASSERT (elf_section_data (sgot) != NULL);
	  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
d4827 2
a4828 2
	  BFD_ASSERT (elf_section_data (s) != NULL);
	  g = (struct mips_got_info *) elf_section_data (s)->tdata;
d5551 1
a5551 1
  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
d5699 1
a5699 1
      g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
d6528 1
a6528 1
  g = (struct mips_got_info *) elf_section_data (got)->tdata;
d6589 1
a6589 1
      elf_section_data (o)->tdata = tdata;
d6623 1
a6623 1
  if (elf_section_data (sec)->tdata == NULL)
d6632 1
a6632 1
      if (((unsigned char *) elf_section_data (sec)->tdata)[i] == 1)
d6782 1
a6782 1
      c = (bfd_byte *) elf_section_data (section)->tdata;
d6794 1
a6794 1
	  elf_section_data (section)->tdata = (PTR) c;
d7094 1
a7094 1
      g = (struct mips_got_info *) elf_section_data (got)->tdata;
@


1.36
log
@[ bfd/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* aoutx.h (NAME(aout,machine_type)): Add bfd_mach_mipsisa32r2 case.
	* archures.c (bfd_mach_mipsisa32r2): New define.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_mipsisa32r2): New enum value.
	(arch_info_struct): Add entry for I_mipsisa32r2.
	* elfxx-mips.c (elf_mips_isa, _bfd_elf_mips_mach)
	(_bfd_mips_elf_print_private_bfd_data): Handle E_MIPS_ARCH_32R2.
	(_bfd_mips_elf_final_write_processing): Add
	bfd_mach_mipsisa32r2 case.
	(_bfd_mips_elf_merge_private_bfd_data): Handle merging of
	binaries marked as using MIPS32 Release 2.

[ binutils/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* doc/binutils.texi (objdump): Note MIPS HWR (Hardware Register)
	changes in MIPS -M options.

[ gas/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* configure.in: Recognize mipsisa32r2, mipsisa32r2el, and
	CPU variants.
	* configure: Regenerate.
	* config/tc-mips.c (ISA_HAS_DROR, ISA_HAS_ROR): New defines.
	(macro_build): Handle "K" operand.
	(macro2): Use ISA_HAS_DROR and ISA_HAS_ROR in the places where
	CPU_HAS_DROR and CPU_HAS_ROR are currently used.
	(mips_ip): New variable "lastpos", and implement "+A", "+B",
	and "+C" operands for MIPS32 Release 2 ins/ext instructions.
	Implement "K" operand for MIPS32 Release 2 rdhwr instruction.
	(validate_mips_insn): Implement "+" as a way to extend the
	allowed operands, and implement "K", "+A", "+B", and "+C"
	operands.
	(OPTION_MIPS32R2): New define.
	(md_longopts): Add entry for OPTION_MIPS32R2.
	(OPTION_ELF_BASE): Adjust to accomodate OPTIONS_MIPS32R2.
	(md_parse_option): Handle OPTION_MIPS32R2.
	(s_mipsset): Reimplement handling of ".set mipsN" options
	and add support for ".set mips32r2".
	(mips_cpu_info_table): Add entry for "mips32r2" (MIPS32 Release 2).
	(md_show_usage): Document "-mips32r2" option.
	* doc/as.texinfo: Document "-mips32r2" option.
	* doc/c-mips.texi: Likewise.

[ gas/testsuite/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0-names-mips32r2.d: New test.
	* gas/mips/hwr-names-mips32r2.d: New test.
	* gas/mips/hwr-names-numeric.d: New test.
	* gas/mips/hwr-names.s: New test source file.
	* gas/mips/mips32r2.d: New test.
	* gas/mips/mips32r2.s: New test source file.
	* gas/mips/mips32r2-ill.l: New test.
	* gas/mips/mips32r2-ill.s: New test source file.
	* gas/mips/mips.exp: Add mips32r2 architecture data array
	entry.  Run new tests mentioned above.

[ include/elf/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (E_MIPS_ARCH_32R2): New define.

[ include/opcode/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Document "+" as the start of two-character operand
	type names, and add new "K", "+A", "+B", and "+C" operand types.
	(OP_MASK_INSMSB, OP_SH_INSMSB, OP_MASK_EXTMSB)
	(OP_SH_EXTMSB, INSN_ISA32R2, ISA_MIPS32R2, CPU_MIPS32R2): New
	defines.

[ opcodes/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_cp0_names_mips3264r2, mips_hwr_names_numeric)
	(mips_hwr_names_mips3264r2): New arrays.
	(mips_arch_choice): New "hwr_names" member.
	(mips_arch_choices): Adjust for structure change, and add a new
	entry for "mips32r2" ISA.
	(mips_hwr_names): New variable.
	(set_default_mips_dis_options): Set mips_hwr_names.
	(parse_mips_dis_option): New "hwr-names" option which sets
	mips_hwr_names, and adjust "reg-names=ARCH" to set mips_hwr_names.
	(print_insn_arg): Change return type to "int"
	and use that to indicate number of characters consumed.
	Add support for "+" operand extension character, "+A", "+B",
	"+C", and "K" operands.
	(print_insn_mips): Adjust for changes to print_insn_arg.
	(print_mips_disassembler_options): Adjust for "hwr-names"
	addition and "reg-names" change.
	* mips-opc (I33): New define (shorthand for INSN_ISA32R2).
	(mips_builtin_opcodes): Note that "nop" and "ssnop" are special
	forms of "sll".  Add new MIPS32 Release 2 instructions: ehb,
	di, ei, ext, ins, jr.hb, jalr.hb, mfhc1, mfhc2, mthc1, mthc2,
	rdhwr, rdpgpr, seb, seh, synci, wrpgpr, wsbh.
	Note that hardware rotate instructions (ror, rorv) can be
	used on MIPS32 Release 2, and add the official mnemonics
	for them (rotr, rotrv) and the similar "rotl" mnemonic for
	left-rotate.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d33 1
d386 1
a386 1
static INLINE int elf_mips_isa PARAMS ((flagword));
d390 2
a391 1
static bfd_boolean _bfd_mips_elf_mach_extends_p PARAMS ((flagword, flagword));
a3084 28
/* Return the ISA for a MIPS e_flags value.  */

static INLINE int
elf_mips_isa (flags)
     flagword flags;
{
  switch (flags & EF_MIPS_ARCH)
    {
    case E_MIPS_ARCH_1:
      return 1;
    case E_MIPS_ARCH_2:
      return 2;
    case E_MIPS_ARCH_3:
      return 3;
    case E_MIPS_ARCH_4:
      return 4;
    case E_MIPS_ARCH_5:
      return 5;
    case E_MIPS_ARCH_32:
      return 32;
    case E_MIPS_ARCH_64:
      return 64;
    case E_MIPS_ARCH_32R2:
      return 33;
    }
  return 4;
}

a5943 3
/* The final processing done just before writing out a MIPS ELF object
   file.  This gets the MIPS architecture right based on the machine
   number.  This is used by both the 32-bit and the 64-bit ABI.  */
d5945 4
a5948 2
void
_bfd_mips_elf_final_write_processing (abfd, linker)
a5949 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d5951 1
a5951 5
  unsigned long val;
  unsigned int i;
  Elf_Internal_Shdr **hdrpp;
  const char *name;
  asection *sec;
a6029 1

d6033 23
d7724 60
a7783 4
/* Return TRUE if machine EXTENSION is an extension of machine BASE,
   meaning that it should be safe to link code for the two machines
   and set the output machine to EXTENSION.  EXTENSION and BASE are
   both submasks of EF_MIPS_MACH.  */
d7786 2
a7787 2
_bfd_mips_elf_mach_extends_p (base, extension)
     flagword base, extension;
d7789 7
a7795 9
  /* The vr5500 ISA is an extension of the core vr5400 ISA, but doesn't
     include the multimedia stuff.  It seems better to allow vr5400
     and vr5500 code to be merged anyway, since many libraries will
     just use the core ISA.  Perhaps we could add some sort of ASE
     flag if this ever proves a problem.  */
  return (base == 0
	  || (base == E_MIPS_MACH_5400 && extension == E_MIPS_MACH_5500)
	  || (base == E_MIPS_MACH_4100 && extension == E_MIPS_MACH_4111)
	  || (base == E_MIPS_MACH_4100 && extension == E_MIPS_MACH_4120));
d7798 17
d7910 27
a7936 46
  /* Compare the ISA's.  */
  if ((new_flags & (EF_MIPS_ARCH | EF_MIPS_MACH))
      != (old_flags & (EF_MIPS_ARCH | EF_MIPS_MACH)))
    {
      int new_mach = new_flags & EF_MIPS_MACH;
      int old_mach = old_flags & EF_MIPS_MACH;
      int new_isa = elf_mips_isa (new_flags);
      int old_isa = elf_mips_isa (old_flags);

      /* If either has no machine specified, just compare the general isa's.
	 Some combinations of machines are ok, if the isa's match.  */
      if (new_mach == old_mach
	  || _bfd_mips_elf_mach_extends_p (new_mach, old_mach)
	  || _bfd_mips_elf_mach_extends_p (old_mach, new_mach))
	{
	  /* Don't warn about mixing code using 32-bit ISAs, or mixing code
	     using 64-bit ISAs.  They will normally use the same data sizes
	     and calling conventions.  */

	  if ((  (new_isa == 1 || new_isa == 2 || new_isa == 32
		  || new_isa == 33)
	       ^ (old_isa == 1 || old_isa == 2 || old_isa == 32
		  || old_isa == 33)) != 0)
	    {
	      (*_bfd_error_handler)
	       (_("%s: ISA mismatch (-mips%d) with previous modules (-mips%d)"),
		bfd_archive_filename (ibfd), new_isa, old_isa);
	      ok = FALSE;
	    }
	  else
	    {
	      /* Do we need to update the mach field?  */
	      if (_bfd_mips_elf_mach_extends_p (old_mach, new_mach))
		{
		  elf_elfheader (obfd)->e_flags &= ~EF_MIPS_MACH;
		  elf_elfheader (obfd)->e_flags |= new_mach;
		}

	      /* Do we need to update the ISA field?  */
	      if (new_isa > old_isa)
		{
		  elf_elfheader (obfd)->e_flags &= ~EF_MIPS_ARCH;
		  elf_elfheader (obfd)->e_flags
		    |= new_flags & EF_MIPS_ARCH;
		}
	    }
d7940 1
d7942 1
a7942 1
	    (_("%s: ISA mismatch (%d) with previous modules (%d)"),
d7944 2
a7945 2
	     _bfd_elf_mips_mach (new_flags),
	     _bfd_elf_mips_mach (old_flags));
d7948 1
d7950 2
a7951 3
      new_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
      old_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
    }
d7953 1
a7953 1
  /* Compare ABI's.  The 64-bit ABI does not use EF_MIPS_ABI.  But, it
@


1.35
log
@* elfxx-mips.c (mips_elf_calculate_relocation): Don't divide
addend by 4.
@
text
@d3105 2
d3177 4
d6056 5
d7868 4
a7871 2
	  if ((  (new_isa == 1 || new_isa == 2 || new_isa == 32)
	       ^ (old_isa == 1 || old_isa == 2 || old_isa == 32)) != 0)
d8021 2
@


1.34
log
@* elfxx-mips.c (struct mips_got_entry): New.
(struct mips_got_info): Added got_entries field.
(mips_elf_got_entry_hash, mips_elf_got_entry_eq): New functions.
(mips_elf_local_got_index, mips_elf_got_page,
mips_elf_got16_entry): Re-implement in terms of new...
(mips_elf_create_local_got_entry): Rewrite to use got_entries.
Change return type.
(mips_elf_highest): Warning clean-up.
(mips_elf_create_got_section): Initialize got_entries.
(_bfd_mips_elf_check_relocs): Use got_entries to estimate
local got size.
(_bfd_mips_elf_size_dynamic_sections): Do not account for
GOT_PAGE entries, since we now reuse GOT16 entries.
@
text
@a2563 1
      value = (bfd_vma) ((bfd_signed_vma) value / 4);
@


1.33
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d43 20
d77 2
d341 1
a341 1
static bfd_vma mips_elf_create_local_got_entry
d390 2
d1419 26
d1489 1
a1489 1
  bfd_byte *entry;
d1493 5
a1497 12
  /* Look to see if we already have an appropriate entry.  */
  for (entry = (sgot->contents
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      bfd_vma address = MIPS_ELF_GET_WORD (abfd, entry);
      if (address == value)
	return entry - sgot->contents;
    }

  return mips_elf_create_local_got_entry (abfd, g, sgot, value);
d1543 2
a1544 4
  bfd_byte *entry;
  bfd_byte *last_entry;
  bfd_vma index = 0;
  bfd_vma address;
d1548 8
a1555 21
  /* Look to see if we already have an appropriate entry.  */
  last_entry = sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
  for (entry = (sgot->contents
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != last_entry;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);

      if (!mips_elf_overflow_p (value - address, 16))
	{
	  /* This entry will serve as the page pointer.  We can add a
	     16-bit number to it to get the actual address.  */
	  index = entry - sgot->contents;
	  break;
	}
    }

  /* If we didn't have an appropriate entry, we create one now.  */
  if (entry == last_entry)
    index = mips_elf_create_local_got_entry (abfd, g, sgot, value);
d1558 1
a1558 4
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);
      *offsetp = value - address;
    }
d1575 1
a1575 4
  bfd_byte *entry;
  bfd_byte *last_entry;
  bfd_vma index = 0;
  bfd_vma address;
d1588 5
a1592 22
  /* Look to see if we already have an appropriate entry.  */
  last_entry = sgot->contents + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno;
  for (entry = (sgot->contents
		+ MIPS_ELF_GOT_SIZE (abfd) * MIPS_RESERVED_GOTNO);
       entry != last_entry;
       entry += MIPS_ELF_GOT_SIZE (abfd))
    {
      address = MIPS_ELF_GET_WORD (abfd, entry);
      if (address == value)
	{
	  /* This entry has the right high-order 16 bits, and the low-order
	     16 bits are set to zero.  */
	  index = entry - sgot->contents;
	  break;
	}
    }

  /* If we didn't have an appropriate entry, we create one now.  */
  if (entry == last_entry)
    index = mips_elf_create_local_got_entry (abfd, g, sgot, value);

  return index;
d1616 1
a1616 1
static bfd_vma
d1623 20
d1645 1
d1650 1
a1650 1
      return (bfd_vma) -1;
d1654 3
a1656 3
		     (sgot->contents
		      + MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno));
  return MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno++;
d1902 1
a1902 1
  return ((value + (bfd_vma) 0x800080008000) >> 48) & 0xffff;
d1993 5
d4392 2
d4400 7
a4406 1
	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.
d4408 13
a4420 6
	     This estimation is very conservative since we can merge
	     duplicate entries in the GOT.  In order to be less
	     conservative, we could actually build the GOT here,
	     rather than in relocate_section.  */
	  g->local_gotno++;
	  sgot->_raw_size += MIPS_ELF_GOT_SIZE (dynobj);
a4852 5
	  if (NEWABI_P (output_bfd))
	    /* It's possible we will need GOT_PAGE entries as well as
	       GOT16 entries.  Often, these will be able to share GOT
	       entries, but not always.  */
	    local_gotno *= 2;
@


1.32
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d91 1
a91 1
  boolean readonly_reloc;
d101 1
a101 1
  boolean no_fn_stub;
d109 1
a109 1
  boolean need_fn_stub;
d120 1
a120 1
  boolean forced_local;
d139 1
a139 1
  boolean use_rld_obj_head;
d143 1
a143 1
  boolean mips16_stubs_seen;
d154 1
a154 1
  boolean failed;
d282 1
a282 1
static boolean mips_elf_create_procedure_table
d285 1
a285 1
static boolean mips_elf_check_mips16_stubs
d303 1
a303 1
static boolean mips_elf_output_extsym
d316 1
a316 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, boolean));
d321 1
a321 1
static boolean mips_elf_sort_hash_table
d323 1
a323 1
static boolean mips_elf_sort_hash_table_f
d325 1
a325 1
static boolean mips_elf_record_global_got_symbol
d331 2
a332 2
static boolean mips_elf_local_relocation_p
  PARAMS ((bfd *, const Elf_Internal_Rela *, asection **, boolean));
d334 1
a334 1
static boolean mips_elf_overflow_p PARAMS ((bfd_vma, int));
d338 1
a338 1
static boolean mips_elf_create_compact_rel_section
d340 1
a340 1
static boolean mips_elf_create_got_section
d348 1
a348 1
	   boolean *, boolean));
d351 1
a351 1
static boolean mips_elf_perform_relocation
d354 2
a355 2
	   boolean));
static boolean mips_elf_stub_section_p
d359 1
a359 1
static boolean mips_elf_create_dynamic_relocation
d367 1
a367 1
static boolean _bfd_mips_elf_mach_extends_p PARAMS ((flagword, flagword));
d439 1
a439 1
   ? (boolean) (abort (), false)					\
d563 1
a563 1
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
d603 1
a603 1
      ret->readonly_reloc = false;
d605 1
a605 1
      ret->no_fn_stub = false;
d607 1
a607 1
      ret->need_fn_stub = false;
d610 1
a610 1
      ret->forced_local = false;
d619 1
a619 1
boolean
d676 1
a676 1
  return true;
d703 1
a703 1
  return false;
d732 1
a732 1
static boolean
d867 1
a867 1
  return true;
d880 1
a880 1
  return false;
d886 1
a886 1
static boolean
d933 1
a933 1
  return true;
d943 1
a943 1
     boolean relocateable;
d1202 1
a1202 1
static boolean
d1208 1
a1208 1
  boolean strip;
d1215 1
a1215 1
    strip = false;
d1220 1
a1220 1
    strip = true;
d1225 2
a1226 2
				   false, false) == NULL))
    strip = true;
d1228 1
a1228 1
    strip = false;
d1231 1
a1231 1
    return true;
d1340 1
a1340 1
      boolean no_fn_stub = h->no_fn_stub;
d1375 2
a1376 2
      einfo->failed = true;
      return false;
d1379 1
a1379 1
  return true;
d1546 1
a1546 1
     boolean external;
d1640 1
a1640 1
static boolean
d1668 1
a1668 1
  return true;
d1675 1
a1675 1
static boolean
d1689 1
a1689 1
    return true;
d1699 1
a1699 1
  return true;
d1706 1
a1706 1
static boolean
d1720 1
a1720 1
	  _bfd_mips_elf_hide_symbol (info, h, true);
d1724 1
a1724 1
	return false;
d1730 1
a1730 1
    return true;
d1737 1
a1737 1
  return true;
d1771 1
a1771 1
static boolean
d1777 1
a1777 1
     boolean check_forced;
d1789 1
a1789 1
    return true;
d1791 1
a1791 1
    return true;
d1804 1
a1804 1
	return true;
d1807 1
a1807 1
  return false;
d1828 1
a1828 1
static boolean
d1837 1
a1837 1
    return true;
d1840 1
a1840 1
    return true;
d1843 1
a1843 1
  return false;
d1885 1
a1885 1
static boolean
d1903 1
a1903 1
	return false;
d1908 1
a1908 1
  return true;
d1913 1
a1913 1
static boolean
d1927 1
a1927 1
    return true;
d1936 1
a1936 1
    return false;
d1944 1
a1944 1
	  (bfd_vma) 0, (const char *) NULL, false,
d1946 1
a1946 1
    return false;
d1955 1
a1955 1
    return false;
d1963 1
a1963 1
    return false;
d1972 1
a1972 1
	return false;
d1978 1
a1978 1
  return true;
d2038 2
a2039 2
     boolean *require_jalxp;
     boolean save_addend;
d2062 1
a2062 1
  /* True if the symbol referred to by this relocation is a local
d2064 3
a2066 3
  boolean local_p, was_local_p;
  /* True if the symbol referred to by this relocation is "_gp_disp".  */
  boolean gp_disp_p = false;
d2071 1
a2071 1
  /* True if overflow occurred during the calculation of the
d2073 3
a2075 3
  boolean overflowed_p;
  /* True if this relocation refers to a MIPS16 function.  */
  boolean target_is_16_bit_code_p = false;
d2085 1
a2085 1
  overflowed_p = false;
d2091 1
a2091 1
					 local_sections, false);
d2158 1
a2158 1
	  gp_disp_p = true;
d2279 1
a2279 1
					 local_sections, true);
d2500 1
a2500 1
	  boolean forced;
d2506 1
a2506 1
						  local_sections, false);
d2634 1
a2634 1
   relocation applies.  If REQUIRE_JALX is true, then the opcode used
d2638 1
a2638 1
   Returns false if anything goes wrong.  */
d2640 1
a2640 1
static boolean
d2650 1
a2650 1
     boolean require_jalx;
d2766 1
a2766 1
      boolean ok;
d2791 1
a2791 1
	  return false;
d2806 1
a2806 1
  return true;
d2809 1
a2809 1
/* Returns true if SECTION is a MIPS16 stub section.  */
d2811 1
a2811 1
static boolean
d2849 1
a2849 1
static boolean
d2862 1
a2862 1
  boolean skip;
d2875 1
a2875 1
  skip = false;
d2903 1
a2903 1
	skip = true;
d2908 1
a2908 1
    skip = true;
d2942 1
a2942 1
	      return false;
d3050 1
a3050 1
  return true;
d3279 1
a3279 1
boolean
d3295 1
a3295 1
	return false;
d3298 1
a3298 1
	return false;
d3334 1
a3334 1
		return false;
d3337 1
a3337 1
		return false;
d3349 1
a3349 1
		return false;
d3352 1
a3352 1
		return false;
d3397 1
a3397 1
  return true;
d3407 1
a3407 1
boolean
d3424 1
a3424 1
	return false;
d3428 1
a3428 1
	return false;
d3432 1
a3432 1
	return false;
d3436 1
a3436 1
	return false;
d3440 1
a3440 1
	return false;
d3444 1
a3444 1
	return false;
d3450 1
a3450 1
	return false;
d3455 1
a3455 1
	return false;
d3459 1
a3459 1
	return false;
d3463 1
a3463 1
	return false;
d3467 1
a3467 1
	return false;
d3471 1
a3471 1
	return false;
d3477 1
a3477 1
	return false;
d3480 1
a3480 1
      return false;
d3484 1
a3484 1
    return false;
d3492 1
a3492 1
	return false;
d3509 1
a3509 1
	return false;
d3524 1
a3524 1
	return false;
d3529 1
a3529 1
	  return false;
d3566 1
a3566 1
  return true;
d3573 1
a3573 1
boolean
d3704 1
a3704 1
	return false;
d3709 1
a3709 1
  return true;
d3718 1
a3718 1
boolean
d3727 1
a3727 1
      return true;
d3732 1
a3732 1
      return true;
d3734 1
a3734 1
  return false;
d3740 1
a3740 1
boolean
d3756 1
a3756 1
      return true;
d3784 1
a3784 1
	    return false;
d3789 1
a3789 1
	    return false;
d3825 1
a3825 1
	    return false;
d3830 1
a3830 1
	    return false;
d3871 1
a3871 1
	      (bfd_vma) *valp, (const char *) NULL, false,
d3873 1
a3873 1
	return false;
d3881 1
a3881 1
	return false;
d3883 1
a3883 1
      mips_elf_hash_table (info)->use_rld_obj_head = true;
d3892 1
a3892 1
  return true;
d3899 1
a3899 1
boolean
d3918 1
a3918 1
  return true;
d3925 1
a3925 1
boolean
d3944 1
a3944 1
	return false;
d3949 1
a3949 1
    return false;
d3956 1
a3956 1
    return false;
d3967 1
a3967 1
	return false;
d3979 1
a3979 1
	return false;
d3993 1
a3993 1
		  (bfd_vma) 0, (const char *) NULL, false,
d3995 1
a3995 1
	    return false;
d4003 1
a4003 1
	    return false;
d4010 1
a4010 1
	    return false;
d4039 1
a4039 1
	     (bfd_vma) 0, (const char *) NULL, false,
d4041 1
a4041 1
	return false;
d4049 1
a4049 1
	return false;
d4064 1
a4064 1
		 (bfd_vma) 0, (const char *) NULL, false,
d4066 1
a4066 1
	    return false;
d4074 1
a4074 1
	    return false;
d4078 1
a4078 1
  return true;
d4084 1
a4084 1
boolean
d4104 1
a4104 1
    return true;
d4152 1
a4152 1
		return false;
d4175 1
a4175 1
	      return true;
d4193 1
a4193 1
		return false;
d4214 1
a4214 1
	  mips_elf_hash_table (info)->mips16_stubs_seen = true;
d4239 1
a4239 1
	  return true;
d4263 1
a4263 1
	  return true;
d4267 1
a4267 1
      mips_elf_hash_table (info)->mips16_stubs_seen = true;
d4308 1
a4308 1
	  return false;
d4339 1
a4339 1
		return false;
d4386 1
a4386 1
	      return false;
d4396 1
a4396 1
		return false;
d4412 1
a4412 1
	    return false;
d4439 1
a4439 1
			return false;
d4468 1
a4468 1
		    hmips->readonly_reloc = true;
d4477 1
a4477 1
		return false;
d4498 1
a4498 1
	    return false;
d4505 1
a4505 1
	    return false;
d4522 1
a4522 1
	      mh->no_fn_stub = true;
d4546 1
a4546 1
	  mh->need_fn_stub = true;
d4550 1
a4550 1
  return true;
d4559 1
a4559 1
boolean
d4604 1
a4604 1
	return true;
d4628 1
a4628 1
	  return true;
d4637 1
a4637 1
      return true;
d4649 1
a4649 1
      return true;
d4655 1
a4655 1
  return true;
d4662 1
a4662 1
boolean
d4677 1
a4677 1
    return true;
d4683 1
a4683 1
  return true;
d4688 1
a4688 1
boolean
d4695 1
a4695 1
  boolean reltext;
d4718 1
a4718 1
  reltext = false;
d4722 1
a4722 1
      boolean strip;
d4731 1
a4731 1
      strip = false;
d4746 1
a4746 1
		strip = true;
d4766 1
a4766 1
		reltext = true;
d4822 1
a4822 1
 	    return false;
d4871 1
a4871 1
	  return false;
d4887 1
a4887 1
	    return false;
d4891 1
a4891 1
		return false;
d4900 1
a4900 1
		return false;
d4910 1
a4910 1
	    return false;
d4914 1
a4914 1
	return false;
d4919 1
a4919 1
	    return false;
d4922 1
a4922 1
	    return false;
d4925 1
a4925 1
	    return false;
d4931 1
a4931 1
	    return false;
d4937 1
a4937 1
	    return false;
d4943 1
a4943 1
	    return false;
d4949 1
a4949 1
	    return false;
d4953 1
a4953 1
	return false;
d4956 1
a4956 1
	return false;
d4961 1
a4961 1
	return false;
d4966 1
a4966 1
	return false;
d4971 1
a4971 1
	return false;
d4975 1
a4975 1
	return false;
d4978 1
a4978 1
	return false;
d4981 1
a4981 1
	return false;
d4984 1
a4984 1
	return false;
d4987 1
a4987 1
	return false;
d4991 1
a4991 1
	return false;
d4997 1
a4997 1
	return false;
d5001 1
a5001 1
	return false;
d5004 1
a5004 1
  return true;
d5009 1
a5009 1
boolean
d5024 1
a5024 1
  boolean use_saved_addend_p = false;
d5034 2
a5035 2
      boolean require_jalx;
      /* True if the relocation is a RELA relocation, rather than a
d5037 1
a5037 1
      boolean rela_relocation_p = true;
d5050 1
a5050 1
	  howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, R_MIPS_32, false);
d5082 1
a5082 1
	      rela_relocation_p = false;
d5097 1
a5097 1
						      local_sections, false)))
d5118 1
a5118 1
		    return false;
d5121 1
a5121 1
		  lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, lo, false);
d5174 1
a5174 1
					     false))
d5262 2
a5263 2
						 contents, false))
		return false;
d5277 1
a5277 1
	use_saved_addend_p = true;
d5279 1
a5279 1
	use_saved_addend_p = false;
d5306 1
a5306 1
	  return false;
d5319 1
a5319 1
		return false;
d5388 1
a5388 1
	return false;
d5391 1
a5391 1
  return true;
d5448 1
a5448 1
boolean
d5482 1
a5482 1
	return false;
d5633 1
a5633 1
  return true;
d5638 1
a5638 1
boolean
d5677 1
a5677 1
	  boolean swap_out_p;
d5683 1
a5683 1
	  swap_out_p = true;
d5748 1
a5748 1
	      swap_out_p = false;
d5753 1
a5753 1
	      swap_out_p = false;
d5815 1
a5815 1
	      swap_out_p = false;
d5921 1
a5921 1
  return true;
d5931 1
a5931 1
     boolean linker ATTRIBUTE_UNUSED;
d6116 1
a6116 1
boolean
d6137 1
a6137 1
	    return false;
d6189 1
a6189 1
	  options_segment->p_flags_valid = true;
d6213 1
a6213 1
		    return false;
d6304 1
a6304 1
	    return false;
d6326 1
a6326 1
  return true;
d6373 1
a6373 1
boolean
d6415 1
a6415 1
  return true;
d6439 1
a6439 1
    dirmips->readonly_reloc = true;
d6445 1
a6445 1
    dirmips->no_fn_stub = true;
d6452 1
a6452 1
     boolean force_local;
d6462 1
a6462 1
  h->forced_local = true;
d6477 1
a6477 1
boolean
d6484 1
a6484 1
  boolean ret = false;
d6490 1
a6490 1
    return false;
d6492 1
a6492 1
    return false;
d6494 1
a6494 1
    return false;
d6497 1
a6497 1
    return false;
d6501 1
a6501 1
    return false;
d6510 1
a6510 1
      return false;
d6529 1
a6529 1
      ret = true;
d6540 1
a6540 1
boolean
d6545 2
a6546 2
    return true;
  return false;
d6549 1
a6549 1
boolean
d6559 1
a6559 1
    return false;
d6562 1
a6562 1
    return false;
d6579 1
a6579 1
  return true;
d6591 1
a6591 1
boolean
d6607 1
a6607 1
    return true;
d6614 1
a6614 1
    return true;
d6644 1
a6644 1
	      return false;
d6650 1
a6650 1
	      return false;
d6659 1
a6659 1
	      return false;
d6684 1
a6684 1
	  return true;
d6701 1
a6701 1
boolean
d6718 1
a6718 1
	    return false;
d6731 1
a6731 1
	    return false;
d6752 1
a6752 1
     boolean relocateable;
d6780 1
a6780 1
  input_section->reloc_done = true;
d6805 1
a6805 1
	    h = bfd_hash_lookup (&link_info->hash->table, "_gp", false, false);
d6891 1
a6891 1
			 true)))
d6954 1
a6954 1
  ret->use_rld_obj_head = false;
d6956 1
a6956 1
  ret->mips16_stubs_seen = false;
d6965 1
a6965 1
boolean
d7027 1
a7027 1
	return false;
d7075 1
a7075 1
	    
d7086 1
a7086 1
      h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
d7156 1
a7156 1
		return false;
d7225 1
a7225 1
	    return false;
d7250 1
a7250 1
		return false;
d7294 1
a7294 1
		return false;
d7299 1
a7299 1
		return false;
d7325 1
a7325 1
						 name, false, false, true);
d7370 1
a7370 1
		    return false;
d7376 1
a7376 1
		return false;
d7384 1
a7384 1
	  einfo.failed = false;
d7389 1
a7389 1
	    return false;
d7462 1
a7462 1
	      return false;
d7486 1
a7486 1
	    return false;
d7524 1
a7524 1
		  boolean exact;
d7533 1
a7533 1
		      return false;
d7541 1
a7541 1
		  exact = false;
d7548 1
a7548 1
			exact = true;
d7562 1
a7562 1
			  return false;
d7605 1
a7605 1
	      return false;
d7623 1
a7623 1
    return false;
d7635 1
a7635 1
	return false;
d7644 1
a7644 1
	return false;
d7655 1
a7655 1
	return false;
d7664 1
a7664 1
	return false;
d7676 1
a7676 1
	    return false;
d7680 1
a7680 1
  return true;
d7683 1
a7683 1
/* Return true if machine EXTENSION is an extension of machine BASE,
d7688 1
a7688 1
static boolean
d7706 1
a7706 1
boolean
d7713 2
a7714 2
  boolean ok;
  boolean null_input_bfd = true;
d7719 1
a7719 1
    return false;
d7723 1
a7723 1
    return true;
d7731 1
a7731 1
      elf_flags_init (obfd) = true;
d7741 1
a7741 1
	    return false;
d7744 1
a7744 1
      return true;
d7753 1
a7753 1
    return true;
d7769 1
a7769 1
	  null_input_bfd = false;
d7774 1
a7774 1
    return true;
d7776 1
a7776 1
  ok = true;
d7785 1
a7785 1
      ok = false;
d7795 1
a7795 1
      ok = false;
d7823 1
a7823 1
	      ok = false;
d7850 1
a7850 1
	  ok = false;
d7873 1
a7873 1
	  ok = false;
d7895 1
a7895 1
      ok = false;
d7901 1
a7901 1
      return false;
d7904 1
a7904 1
  return true;
d7909 1
a7909 1
boolean
d7918 2
a7919 2
  elf_flags_init (abfd) = true;
  return true;
d7922 1
a7922 1
boolean
d7984 1
a7984 1
  return true;
@


1.31
log
@* elfxx-mips.c (MIPS_RELOC_RELA_P): New macro.
(_bfd_mips_elf_relocate_section): Use it.
@
text
@d1179 2
a1180 2
  const Elf32_External_Rel *ext_reloc1 = (const Elf32_External_Rel *) arg1;
  const Elf32_External_Rel *ext_reloc2 = (const Elf32_External_Rel *) arg2;
d1182 2
a1183 2
  Elf_Internal_Rel int_reloc1;
  Elf_Internal_Rel int_reloc2;
d1185 1
a1185 4
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, ext_reloc1, &int_reloc1);
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, ext_reloc2, &int_reloc2);

  return (ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info));
d2861 1
a2861 1
  Elf_Internal_Rel outrel[3];
d2917 1
a2917 1
    memset (outrel, 0, sizeof (Elf_Internal_Rel) * 3);
d3001 3
a3003 4
    bfd_elf32_swap_reloc_out (output_bfd, &outrel[0],
			      (((Elf32_External_Rel *)
				sreloc->contents)
			       + sreloc->reloc_count));
d3576 1
a3576 1
     Elf32_Internal_Shdr *hdr;
@


1.30
log
@* elfxx-mips.c (MNAME): New macro.
(_bfd_mips_elf_check_relocs): Use it.
(_bfd_mips_elf_discard_info): Likewise.
(_bfd_mips_elf_final_link): Likewise.
@
text
@d446 17
d5064 4
a5067 1
					 NEWABI_P (input_bfd));
@


1.29
log
@* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Don't move
the options section into a separate section unless IRIX 6
compatibility is enabled.
@
text
@d478 2
d487 1
d4134 1
a4134 1
	      sec_relocs = (_bfd_elf32_link_read_relocs
d6487 4
a6490 3
  cookie->rels = _bfd_elf32_link_read_relocs (abfd, o, (PTR) NULL,
					      (Elf_Internal_Rela *) NULL,
					      info->keep_memory);
d6502 1
a6502 1
      if (_bfd_elf32_reloc_symbol_deleted_p (i * PDR_SIZE, cookie))
d7606 1
a7606 11
  if (ABI_64_P (abfd))
    {
#ifdef BFD64
      if (!bfd_elf64_bfd_final_link (abfd, info))
	return false;
#else
      abort ();
      return false;
#endif /* BFD64 */
    }
  else if (!bfd_elf32_bfd_final_link (abfd, info))
@


1.28
log
@* elflink.h (struct elf_link_sort_rela): Turn rel and rela
into arrays.
(elf_link_sort_cmp1, elf_link_sort_cmp2): Adjust.
(elf_link_sort_relocs): Likewise.  Take int_rels_per_ext_rel
into account.
* elfxx-mips.c (mips_elf_create_dynamic_relocation): Compose
R_MIPS_REL32 with R_MIPS64 if ABI_64_P.
@
text
@d6140 6
a6145 1
  if (NEWABI_P (abfd))
@


1.27
log
@* elfxx-mips.c (mips_elf_calculate_relocation): Take
save_addend argument.  Don't apply the 32-bit mask to a
GPREL32 value if it's to be used in another relocation.  Don't
use forced-check computation of local_p to decide whether to
add gp0 to GPREL16 value.  Don't use only the lowest 16 bits
of the addend of a non-in-place GPREL16 relocation.
(_bfd_mips_elf_relocate_section): Pass use_saved_addend_p to
mips_elf_calculate_relocation().
@
text
@d2957 3
a2959 1
				     R_MIPS_NONE);
@


1.26
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d348 1
a348 1
	   boolean *));
d2009 1
a2009 1
			       require_jalxp)
d2022 1
d2047 1
a2047 1
  boolean local_p;
d2075 1
d2463 13
a2475 4
      if (local_p)
	value = mips_elf_sign_extend (addend, 16) + symbol + gp0 - gp;
      else
	value = mips_elf_sign_extend (addend, 16) + symbol - gp;
d2508 3
a2510 1
      value = (addend + symbol + gp0 - gp) & howto->dst_mask;
d5267 2
a5268 1
					     &name, &require_jalx))
@


1.25
log
@* elfxx-mips.c (mips_elf_create_dynamic_relocation): Set the type
of the other two relocations packed with a REL32 to NONE.
@
text
@d1904 1
d1924 1
a1924 1
  h = NULL;
d1928 1
a1928 2
	  get_elf_backend_data (abfd)->collect,
	  (struct bfd_link_hash_entry **) &h)))
d1930 2
d3834 1
d3837 1
a3837 1
      h = NULL;
d3841 1
a3841 2
	      get_elf_backend_data (abfd)->collect,
	      (struct bfd_link_hash_entry **) &h)))
d3843 2
d3900 1
d3959 1
a3959 1
	  h = NULL;
d3963 1
a3963 2
		  get_elf_backend_data (abfd)->collect,
		  (struct bfd_link_hash_entry **) &h)))
d3965 2
d4002 11
a4012 20
      h = NULL;
      if (SGI_COMPAT (abfd))
	{
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, "_DYNAMIC_LINK", BSF_GLOBAL, bfd_abs_section_ptr,
		 (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect,
		 (struct bfd_link_hash_entry **) &h)))
	    return false;
	}
      else
	{
	  /* For normal mips it is _DYNAMIC_LINKING.  */
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, "_DYNAMIC_LINKING", BSF_GLOBAL,
		 bfd_abs_section_ptr, (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect,
		 (struct bfd_link_hash_entry **) &h)))
	    return false;
	}
d4029 9
a4037 20
	  h = NULL;
	  if (SGI_COMPAT (abfd))
	    {
	      if (!(_bfd_generic_link_add_one_symbol
		    (info, abfd, "__rld_map", BSF_GLOBAL, s,
		     (bfd_vma) 0, (const char *) NULL, false,
		     get_elf_backend_data (abfd)->collect,
		     (struct bfd_link_hash_entry **) &h)))
		return false;
	    }
	  else
	    {
	      /* For normal mips the symbol is __RLD_MAP.  */
	      if (!(_bfd_generic_link_add_one_symbol
		    (info, abfd, "__RLD_MAP", BSF_GLOBAL, s,
		     (bfd_vma) 0, (const char *) NULL, false,
		     get_elf_backend_data (abfd)->collect,
		     (struct bfd_link_hash_entry **) &h)))
		return false;
	    }
@


1.24
log
@[include/elf]
	* mips.h (E_MIPS_MACH_4120, E_MIPS_MACH_5400, E_MIPS_MACH_5500): New.

[bfd/]
	* archures.c (bfd_mach_mips4120, bfd_mach_mips5400): New.
	(bfd_mach_mips5500): New.
	* cpu-mips.c (I_mips4120, I_mips5400, I_mips5500): New.
	(arch_info_struct): Add corresponding entries here.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle E_MIPS_MACH_4120,
	E_MIPS_MACH_5400 and E_MIPS_MACH_5500.
	(_bfd_mips_elf_final_write_processing): Handle bfd_mach_mips4120,
	bfd_mach_mips5400 and bfd_mach_mips5500.
	(_bfd_mips_elf_mach_extends_p): New function.
	(_bfd_mips_elf_merge_private_bfd_data): Use it to help merge
	the EF_MIPS_MACH flags.
	* bfd-in2.h: Regenerate.
@
text
@d2941 4
@


1.24.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d348 1
a348 1
	   boolean *, boolean));
a1903 1
  struct bfd_link_hash_entry *bh;
d1923 1
a1923 1
  bh = NULL;
d1927 2
a1928 1
	  get_elf_backend_data (abfd)->collect, &bh)))
a1929 2

  h = (struct elf_link_hash_entry *) bh;
d2007 1
a2007 1
			       require_jalxp, save_addend)
a2019 1
     boolean save_addend;
d2044 1
a2044 1
  boolean local_p, was_local_p;
a2071 1
  was_local_p = local_p;
d2459 4
a2462 13
      /* Only sign-extend the addend if it was extracted from the
	 instruction.  If the addend was separate, leave it alone,
	 otherwise we may lose significant bits.  */
      if (howto->partial_inplace)
	addend = mips_elf_sign_extend (addend, 16);
      value = symbol + addend - gp;
      /* If the symbol was local, any earlier relocatable links will
	 have adjusted its addend with the gp offset, so compensate
	 for that now.  Don't do it for symbols forced local in this
	 link, though, since they won't have had the gp offset applied
	 to them before.  */
      if (was_local_p)
	value += gp0;
d2495 1
a2495 3
      value = (addend + symbol + gp0 - gp);
      if (!save_addend)
	value &= howto->dst_mask;
a2940 6
      outrel[1].r_info = ELF_R_INFO (output_bfd, (unsigned long) 0,
				     ABI_64_P (output_bfd)
				     ? R_MIPS_64
				     : R_MIPS_NONE);
      outrel[2].r_info = ELF_R_INFO (output_bfd, (unsigned long) 0,
				     R_MIPS_NONE);
a3827 1
      struct bfd_link_hash_entry *bh;
d3830 1
a3830 1
      bh = NULL;
d3834 2
a3835 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a3836 2

      h = (struct elf_link_hash_entry *) bh;
a3891 1
  struct bfd_link_hash_entry *bh;
d3950 1
a3950 1
	  bh = NULL;
d3954 2
a3955 1
		  get_elf_backend_data (abfd)->collect, &bh)))
a3956 2

	  h = (struct elf_link_hash_entry *) bh;
d3992 20
a4011 11
      const char *name;

      name = SGI_COMPAT (abfd) ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING";
      bh = NULL;
      if (!(_bfd_generic_link_add_one_symbol
	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr,
	     (bfd_vma) 0, (const char *) NULL, false,
	     get_elf_backend_data (abfd)->collect, &bh)))
	return false;

      h = (struct elf_link_hash_entry *) bh;
d4028 20
a4047 9
	  name = SGI_COMPAT (abfd) ? "__rld_map" : "__RLD_MAP";
	  bh = NULL;
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, name, BSF_GLOBAL, s,
		 (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect, &bh)))
	    return false;

	  h = (struct elf_link_hash_entry *) bh;
d5264 1
a5264 2
					     &name, &require_jalx,
					     use_saved_addend_p))
d6134 1
a6134 6
  if (NEWABI_P (abfd)
      /* On non-IRIX6 new abi, we'll have already created a segment
	 for this section, so don't create another.  I'm not sure this
	 is not also the case for IRIX 6, but I can't test it right
	 now.  */
      && IRIX_COMPAT (abfd) == ict_irix6)
@


1.24.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
d12 1
a12 1
   This file is part of BFD, the Binary File Descriptor library.
d14 13
a26 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a32 1
#include "libiberty.h"
d43 2
a44 30
#include "hashtab.h"

/* This structure is used to hold .got entries while estimating got
   sizes.  */
struct mips_got_entry
{
  /* The input bfd in which the symbol is defined.  */
  bfd *abfd;
  /* The index of the symbol, as stored in the relocation r_info, if
     we have a local symbol; -1 otherwise.  */
  long symndx;
  union
  {
    /* If abfd == NULL, an address that must be stored in the got.  */
    bfd_vma address;
    /* If abfd != NULL && symndx != -1, the addend of the relocation
       that should be added to the symbol value.  */
    bfd_vma addend;
    /* If abfd != NULL && symndx == -1, the hash table entry
       corresponding to a global symbol in the got (or, local, if
       h->forced_local).  */
    struct mips_elf_link_hash_entry *h;
  } d;
  /* The offset from the beginning of the .got section to the entry
     corresponding to this symbol+addend.  If it's a global symbol
     whose offset is yet to be decided, it's going to be -1.  */
  long gotidx;
};

/* This structure is used to hold .got information when linking.  */
a56 62
  /* A hash table holding members of the got.  */
  struct htab *got_entries;
  /* A hash table mapping input bfds to other mips_got_info.  NULL
     unless multi-got was necessary.  */
  struct htab *bfd2got;
  /* In multi-got links, a pointer to the next got (err, rather, most
     of the time, it points to the previous got).  */
  struct mips_got_info *next;
};

/* Map an input bfd to a got in a multi-got link.  */

struct mips_elf_bfd2got_hash {
  bfd *bfd;
  struct mips_got_info *g;
};

/* Structure passed when traversing the bfd2got hash table, used to
   create and merge bfd's gots.  */

struct mips_elf_got_per_bfd_arg
{
  /* A hashtable that maps bfds to gots.  */
  htab_t bfd2got;
  /* The output bfd.  */
  bfd *obfd;
  /* The link information.  */
  struct bfd_link_info *info;
  /* A pointer to the primary got, i.e., the one that's going to get
     the implicit relocations from DT_MIPS_LOCAL_GOTNO and
     DT_MIPS_GOTSYM.  */
  struct mips_got_info *primary;
  /* A non-primary got we're trying to merge with other input bfd's
     gots.  */
  struct mips_got_info *current;
  /* The maximum number of got entries that can be addressed with a
     16-bit offset.  */
  unsigned int max_count;
  /* The number of local and global entries in the primary got.  */
  unsigned int primary_count;
  /* The number of local and global entries in the current got.  */
  unsigned int current_count;
};

/* Another structure used to pass arguments for got entries traversal.  */

struct mips_elf_set_global_got_offset_arg
{
  struct mips_got_info *g;
  int value;
  unsigned int needed_relocs;
  struct bfd_link_info *info;
};

struct _mips_elf_section_data
{
  struct bfd_elf_section_data elf;
  union
  {
    struct mips_got_info *got_info;
    bfd_byte *tdata;
  } u;
a58 3
#define mips_elf_section_data(sec) \
  ((struct _mips_elf_section_data *) elf_section_data (sec))

a69 4
  /* The greatest dynamic symbol table index corresponding to a symbol
     with a GOT entry that is not referenced (e.g., a dynamic symbol
     with dynamic relocations pointing to it from non-primary GOTs).  */
  long max_unref_got_dynindx;
d91 5
a95 1
  bfd_boolean readonly_reloc;
d101 1
a101 1
  bfd_boolean no_fn_stub;
d109 1
a109 1
  bfd_boolean need_fn_stub;
d120 1
a120 1
  bfd_boolean forced_local;
d139 1
a139 1
  bfd_boolean use_rld_obj_head;
d143 1
a143 1
  bfd_boolean mips16_stubs_seen;
d154 1
a154 1
  bfd_boolean failed;
d263 9
a271 9
	bfd_vma	adr;		/* Memory address of start of procedure.  */
	long	regmask;	/* Save register mask.  */
	long	regoffset;	/* Save register offset.  */
	long	fregmask;	/* Save floating point register mask.  */
	long	fregoffset;	/* Save floating point register offset.  */
	long	frameoffset;	/* Frame size.  */
	short	framereg;	/* Frame pointer register.  */
	short	pcreg;		/* Offset or reg of return pc.  */
	long	irpss;		/* Index into the runtime string table.  */
d273 1
a273 1
	struct exception_info *exception_info;/* Pointer to exception array.  */
d279 1
a279 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d281 6
a286 6
  (bfd *, const RPDR *, struct rpdr_ext *);
static bfd_boolean mips_elf_create_procedure_table
  (void *, bfd *, struct bfd_link_info *, asection *,
   struct ecoff_debug_info *);
static bfd_boolean mips_elf_check_mips16_stubs
  (struct mips_elf_link_hash_entry *, void *);
d288 1
a288 1
  (bfd *, const Elf32_External_gptab *, Elf32_gptab *);
d290 1
a290 1
  (bfd *, const Elf32_gptab *, Elf32_External_gptab *);
d292 1
a292 1
  (bfd *, const Elf32_compact_rel *, Elf32_External_compact_rel *);
d294 7
a300 1
  (bfd *, const Elf32_crinfo *, Elf32_External_crinfo *);
d302 5
a306 11
  (const void *, const void *);
static int sort_dynamic_relocs_64
  (const void *, const void *);
static bfd_boolean mips_elf_output_extsym
  (struct mips_elf_link_hash_entry *, void *);
static int gptab_compare
  (const void *, const void *);
static asection *mips_elf_rel_dyn_section
  (bfd *, bfd_boolean);
static asection *mips_elf_got_section
  (bfd *, bfd_boolean);
d308 1
a308 3
  (bfd *, asection **);
static long mips_elf_get_global_gotsym_index
  (bfd *abfd);
d310 1
a310 1
  (bfd *, bfd *, struct bfd_link_info *, bfd_vma);
d312 1
a312 1
  (bfd *, bfd *, struct elf_link_hash_entry *);
d314 1
a314 1
  (bfd *, bfd *, struct bfd_link_info *, bfd_vma, bfd_vma *);
d316 1
a316 1
  (bfd *, bfd *, struct bfd_link_info *, bfd_vma, bfd_boolean);
d318 10
a327 12
  (bfd *, bfd *, bfd *, bfd_vma);
static struct mips_got_entry *mips_elf_create_local_got_entry
  (bfd *, bfd *, struct mips_got_info *, asection *, bfd_vma);
static bfd_boolean mips_elf_sort_hash_table
  (struct bfd_link_info *, unsigned long);
static bfd_boolean mips_elf_sort_hash_table_f
  (struct mips_elf_link_hash_entry *, void *);
static bfd_boolean mips_elf_record_local_got_symbol
  (bfd *, long, bfd_vma, struct mips_got_info *);
static bfd_boolean mips_elf_record_global_got_symbol
  (struct elf_link_hash_entry *, bfd *, struct bfd_link_info *,
   struct mips_got_info *);
d329 15
a343 15
  (bfd *, unsigned int, const Elf_Internal_Rela *, const Elf_Internal_Rela *);
static bfd_boolean mips_elf_local_relocation_p
  (bfd *, const Elf_Internal_Rela *, asection **, bfd_boolean);
static bfd_boolean mips_elf_overflow_p
  (bfd_vma, int);
static bfd_vma mips_elf_high
  (bfd_vma);
static bfd_vma mips_elf_higher
  (bfd_vma);
static bfd_vma mips_elf_highest
  (bfd_vma);
static bfd_boolean mips_elf_create_compact_rel_section
  (bfd *, struct bfd_link_info *);
static bfd_boolean mips_elf_create_got_section
  (bfd *, struct bfd_link_info *, bfd_boolean);
d345 4
a348 4
  (bfd *, bfd *, asection *, struct bfd_link_info *,
   const Elf_Internal_Rela *, bfd_vma, reloc_howto_type *,
   Elf_Internal_Sym *, asection **, bfd_vma *, const char **,
   bfd_boolean *, bfd_boolean);
d350 7
a356 6
  (reloc_howto_type *, const Elf_Internal_Rela *, bfd *, bfd_byte *);
static bfd_boolean mips_elf_perform_relocation
  (struct bfd_link_info *, reloc_howto_type *, const Elf_Internal_Rela *,
   bfd_vma, bfd *, asection *, bfd_byte *, bfd_boolean);
static bfd_boolean mips_elf_stub_section_p
  (bfd *, asection *);
d358 7
a364 9
  (bfd *, unsigned int);
static bfd_boolean mips_elf_create_dynamic_relocation
  (bfd *, struct bfd_link_info *, const Elf_Internal_Rela *,
   struct mips_elf_link_hash_entry *, asection *, bfd_vma,
   bfd_vma *, asection *);
static void mips_set_isa_flags
  (bfd *);
static INLINE char *elf_mips_abi_name
  (bfd *);
d366 2
a367 39
  (bfd *, const char *, Elf_Internal_Sym *);
static bfd_boolean mips_mach_extends_p
  (unsigned long, unsigned long);
static bfd_boolean mips_32bit_flags_p
  (flagword);
static INLINE hashval_t mips_elf_hash_bfd_vma
  (bfd_vma);
static hashval_t mips_elf_got_entry_hash
  (const void *);
static int mips_elf_got_entry_eq
  (const void *, const void *);

static bfd_boolean mips_elf_multi_got
  (bfd *, struct bfd_link_info *, struct mips_got_info *,
   asection *, bfd_size_type);
static hashval_t mips_elf_multi_got_entry_hash
  (const void *);
static int mips_elf_multi_got_entry_eq
  (const void *, const void *);
static hashval_t mips_elf_bfd2got_entry_hash
  (const void *);
static int mips_elf_bfd2got_entry_eq
  (const void *, const void *);
static int mips_elf_make_got_per_bfd
  (void **, void *);
static int mips_elf_merge_gots
  (void **, void *);
static int mips_elf_set_global_got_offset
  (void **, void *);
static int mips_elf_set_no_stub
  (void **, void *);
static int mips_elf_resolve_final_got_entry
  (void **, void *);
static void mips_elf_resolve_final_got_entries
  (struct mips_got_info *);
static bfd_vma mips_elf_adjust_gp
  (bfd *, struct mips_got_info *, bfd *);
static struct mips_got_info *mips_elf_got_for_ibfd
  (struct mips_got_info *, bfd *);
d394 1
a394 1
  (NEWABI_P (abfd) ? ".MIPS.options" : ".options")
d398 1
a398 1
  (NEWABI_P (abfd) ? ".MIPS.stubs" : ".stub")
d418 1
a418 1
  (get_elf_backend_data (abfd)->s->log_file_align)
d432 4
a435 4
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)	\
  (ABI_64_P (elf_hash_table (info)->dynobj)		\
   ? bfd_elf64_add_dynamic_entry (info, tag, val)	\
   : bfd_elf32_add_dynamic_entry (info, tag, val))
d437 4
a440 4
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)	\
  (ABI_64_P (elf_hash_table (info)->dynobj)		\
   ? (abort (), FALSE)					\
   : bfd_elf32_add_dynamic_entry (info, tag, val))
a445 17
/* Determine whether the internal relocation of index REL_IDX is REL
   (zero) or RELA (non-zero).  The assumption is that, if there are
   two relocation sections for this section, one of them is REL and
   the other is RELA.  If the index of the relocation we're testing is
   in range for the first relocation section, check that the external
   relocation size is that for RELA.  It is also assumed that, if
   rel_idx is not in range for the first section, and this first
   section contains REL relocs, then the relocation is in the second
   section, that is RELA.  */
#define MIPS_RELOC_RELA_P(abfd, sec, rel_idx)				\
  ((NUM_SHDR_ENTRIES (&elf_section_data (sec)->rel_hdr)			\
    * get_elf_backend_data (abfd)->s->int_rels_per_ext_rel		\
    > (bfd_vma)(rel_idx))						\
   == (elf_section_data (sec)->rel_hdr.sh_entsize			\
       == (ABI_64_P (abfd) ? sizeof (Elf64_External_Rela)		\
	   : sizeof (Elf32_External_Rela))))

d453 3
a455 8
/* The offset of $gp from the beginning of the .got section.  */
#define ELF_MIPS_GP_OFFSET(abfd) (0x7ff0)

/* The maximum size of the GOT for it to be addressable using 16-bit
   offsets from $gp.  */
#define MIPS_ELF_GOT_MAX_SIZE(abfd) (ELF_MIPS_GP_OFFSET(abfd) + 0x7fff)

/* Instructions which appear in a stub.  */
d457 5
a461 3
  ((ABI_64_P (abfd)  						\
    ? 0xdf998010		/* ld t9,0x8010(gp) */		\
    : 0x8f998010))              /* lw t9,0x8010(gp) */
d463 2
a464 4
   ((ABI_64_P (abfd)						\
     ? 0x03e0782d		/* daddu t7,ra */		\
     : 0x03e07821))		/* addu t7,ra */
#define STUB_JALR 0x0320f809	/* jalr t9,ra */
d466 1
a466 3
  ((ABI_64_P (abfd)						\
   ? 0x64180000			/* daddiu t8,zero,0 */		\
   : 0x24180000))		/* addiu t8,zero,0 */
a477 2
#define MNAME(bfd,pre,pos) \
  (ABI_64_P (bfd) ? CONCAT4 (pre,64,_,pos) : CONCAT4 (pre,32,_,pos))
a484 1
#define MNAME(bfd,pre,pos) CONCAT4 (pre,32,_,pos)
d543 1
a543 1
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\
d554 4
a557 2
mips_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table, const char *string)
d564 5
a568 3
  if (ret == NULL)
    ret = bfd_hash_allocate (table, sizeof (struct mips_elf_link_hash_entry));
  if (ret == NULL)
d575 1
a575 1
  if (ret != NULL)
d583 3
a585 2
      ret->readonly_reloc = FALSE;
      ret->no_fn_stub = FALSE;
d587 1
a587 1
      ret->need_fn_stub = FALSE;
d590 1
a590 1
      ret->forced_local = FALSE;
a594 14

bfd_boolean
_bfd_mips_elf_new_section_hook (bfd *abfd, asection *sec)
{
  struct _mips_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
}
d599 5
a603 3
bfd_boolean
_bfd_mips_elf_read_ecoff_info (bfd *abfd, asection *section,
			       struct ecoff_debug_info *debug)
d607 1
a607 1
  char *ext_hdr;
d612 1
a612 1
  ext_hdr = bfd_malloc (swap->external_hdr_size);
d616 1
a616 1
  if (! bfd_get_section_contents (abfd, section, ext_hdr, 0,
d631 1
a631 1
      debug->ptr = bfd_malloc (amt);					\
d634 1
a634 1
      if (bfd_seek (abfd, symhdr->offset, SEEK_SET) != 0		\
d640 4
a643 4
  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, void *);
  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, void *);
  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, void *);
  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, void *);
d648 3
a650 3
  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, void *);
  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, void *);
  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, void *);
d656 1
a656 1
  return TRUE;
d683 1
a683 1
  return FALSE;
d689 4
a692 1
ecoff_swap_rpdr_out (bfd *abfd, const RPDR *in, struct rpdr_ext *ex)
d712 7
a718 4
static bfd_boolean
mips_elf_create_procedure_table (void *handle, bfd *abfd,
				 struct bfd_link_info *info, asection *s,
				 struct ecoff_debug_info *debug)
d724 1
a724 1
  void *rtproc;
d751 1
a751 1
      epdr = bfd_malloc (size * count);
d755 1
a755 1
      if (! _bfd_ecoff_get_accumulated_pdr (handle, (bfd_byte *) epdr))
d759 1
a759 1
      rp = rpdr = bfd_malloc (size * count);
d764 1
a764 1
      sv = bfd_malloc (size * count);
d770 1
a770 1
      esym = bfd_malloc (size * count);
d774 1
a774 1
      if (! _bfd_ecoff_get_accumulated_sym (handle, (bfd_byte *) esym))
d778 1
a778 1
      ss = bfd_malloc (count);
d781 1
a781 1
      if (! _bfd_ecoff_get_accumulated_ss (handle, ss))
d787 2
a788 2
	  (*swap->swap_pdr_in) (abfd, epdr + i, &pdr);
	  (*swap->swap_sym_in) (abfd, &esym[pdr.isym], &sym);
d805 1
a805 1
  rtproc = bfd_alloc (abfd, size);
d814 1
a814 1
  erp = rtproc;
d830 1
a830 1
  s->contents = rtproc;
d834 1
a834 1
  s->link_order_head = NULL;
d847 1
a847 1
  return TRUE;
d860 1
a860 1
  return FALSE;
d866 4
a869 3
static bfd_boolean
mips_elf_check_mips16_stubs (struct mips_elf_link_hash_entry *h,
			     void *data ATTRIBUTE_UNUSED)
d913 1
a913 1
  return TRUE;
d917 9
a925 3
_bfd_mips_elf_gprel16_with_gp (bfd *abfd, asymbol *symbol,
			       arelent *reloc_entry, asection *input_section,
			       bfd_boolean relocatable, void *data, bfd_vma gp)
d928 2
a929 2
  unsigned long insn = 0;
  bfd_signed_vma val;
d942 2
d945 6
a950 3
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
d952 3
a954 2
      insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
      val += insn & 0xffff;
a956 2
  _bfd_mips_elf_sign_extend(val, 16);

d958 1
a958 1
     are producing relocatable output, we don't want to do this for
d960 1
a960 1
  if (! relocatable
d964 2
a965 7
  if (reloc_entry->howto->partial_inplace)
    {
      insn = (insn & ~0xffff) | (val & 0xffff);
      bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);
    }
  else
    reloc_entry->addend = val;
d967 1
a967 1
  if (relocatable)
d969 2
a970 1
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
d980 4
a983 2
bfd_mips_elf32_swap_gptab_in (bfd *abfd, const Elf32_External_gptab *ex,
			      Elf32_gptab *in)
d990 4
a993 2
bfd_mips_elf32_swap_gptab_out (bfd *abfd, const Elf32_gptab *in,
			       Elf32_External_gptab *ex)
d1000 4
a1003 2
bfd_elf32_swap_compact_rel_out (bfd *abfd, const Elf32_compact_rel *in,
				Elf32_External_compact_rel *ex)
d1014 4
a1017 2
bfd_elf32_swap_crinfo_out (bfd *abfd, const Elf32_crinfo *in,
			   Elf32_External_crinfo *ex)
d1029 25
d1060 4
a1063 2
bfd_mips_elf32_swap_reginfo_in (bfd *abfd, const Elf32_External_RegInfo *ex,
				Elf32_RegInfo *in)
d1074 4
a1077 2
bfd_mips_elf32_swap_reginfo_out (bfd *abfd, const Elf32_RegInfo *in,
				 Elf32_External_RegInfo *ex)
d1094 4
a1097 2
bfd_mips_elf64_swap_reginfo_in (bfd *abfd, const Elf64_External_RegInfo *ex,
				Elf64_Internal_RegInfo *in)
d1109 4
a1112 2
bfd_mips_elf64_swap_reginfo_out (bfd *abfd, const Elf64_Internal_RegInfo *in,
				 Elf64_External_RegInfo *ex)
d1126 4
a1129 2
bfd_mips_elf_swap_options_in (bfd *abfd, const Elf_External_Options *ex,
			      Elf_Internal_Options *in)
d1140 4
a1143 2
bfd_mips_elf_swap_options_out (bfd *abfd, const Elf_Internal_Options *in,
			       Elf_External_Options *ex)
d1155 3
a1157 1
sort_dynamic_relocs (const void *arg1, const void *arg2)
d1159 2
a1160 2
  Elf_Internal_Rela int_reloc1;
  Elf_Internal_Rela int_reloc2;
d1162 2
a1163 2
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg1, &int_reloc1);
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg2, &int_reloc2);
d1165 2
a1166 4
  return ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info);
}

/* Like sort_dynamic_relocs, but used for elf64 relocations.  */
d1168 1
a1168 13
static int
sort_dynamic_relocs_64 (const void *arg1, const void *arg2)
{
  Elf_Internal_Rela int_reloc1[3];
  Elf_Internal_Rela int_reloc2[3];

  (*get_elf_backend_data (reldyn_sorting_bfd)->s->swap_reloc_in)
    (reldyn_sorting_bfd, arg1, int_reloc1);
  (*get_elf_backend_data (reldyn_sorting_bfd)->s->swap_reloc_in)
    (reldyn_sorting_bfd, arg2, int_reloc2);

  return (ELF64_R_SYM (int_reloc1[0].r_info)
	  - ELF64_R_SYM (int_reloc2[0].r_info));
a1170 1

d1185 4
a1188 2
static bfd_boolean
mips_elf_output_extsym (struct mips_elf_link_hash_entry *h, void *data)
d1190 2
a1191 2
  struct extsym_info *einfo = data;
  bfd_boolean strip;
d1198 1
a1198 1
    strip = FALSE;
d1203 1
a1203 1
    strip = TRUE;
d1208 2
a1209 2
				   FALSE, FALSE) == NULL))
    strip = TRUE;
d1211 1
a1211 1
    strip = FALSE;
d1214 1
a1214 1
    return TRUE;
d1323 1
a1323 1
      bfd_boolean no_fn_stub = h->no_fn_stub;
d1358 2
a1359 2
      einfo->failed = TRUE;
      return FALSE;
d1362 1
a1362 1
  return TRUE;
d1368 3
a1370 1
gptab_compare (const void *p1, const void *p2)
d1372 2
a1373 2
  const Elf32_gptab *a1 = p1;
  const Elf32_gptab *a2 = p2;
a1377 102
/* Functions to manage the got entry hash table.  */

/* Use all 64 bits of a bfd_vma for the computation of a 32-bit
   hash number.  */

static INLINE hashval_t
mips_elf_hash_bfd_vma (bfd_vma addr)
{
#ifdef BFD64
  return addr + (addr >> 32);
#else
  return addr;
#endif
}

/* got_entries only match if they're identical, except for gotidx, so
   use all fields to compute the hash, and compare the appropriate
   union members.  */

static hashval_t
mips_elf_got_entry_hash (const void *entry_)
{
  const struct mips_got_entry *entry = (struct mips_got_entry *)entry_;

  return entry->symndx
    + (! entry->abfd ? mips_elf_hash_bfd_vma (entry->d.address)
       : entry->abfd->id
         + (entry->symndx >= 0 ? mips_elf_hash_bfd_vma (entry->d.addend)
	    : entry->d.h->root.root.root.hash));
}

static int
mips_elf_got_entry_eq (const void *entry1, const void *entry2)
{
  const struct mips_got_entry *e1 = (struct mips_got_entry *)entry1;
  const struct mips_got_entry *e2 = (struct mips_got_entry *)entry2;

  return e1->abfd == e2->abfd && e1->symndx == e2->symndx
    && (! e1->abfd ? e1->d.address == e2->d.address
	: e1->symndx >= 0 ? e1->d.addend == e2->d.addend
	: e1->d.h == e2->d.h);
}

/* multi_got_entries are still a match in the case of global objects,
   even if the input bfd in which they're referenced differs, so the
   hash computation and compare functions are adjusted
   accordingly.  */

static hashval_t
mips_elf_multi_got_entry_hash (const void *entry_)
{
  const struct mips_got_entry *entry = (struct mips_got_entry *)entry_;

  return entry->symndx
    + (! entry->abfd
       ? mips_elf_hash_bfd_vma (entry->d.address)
       : entry->symndx >= 0
       ? (entry->abfd->id
	  + mips_elf_hash_bfd_vma (entry->d.addend))
       : entry->d.h->root.root.root.hash);
}

static int
mips_elf_multi_got_entry_eq (const void *entry1, const void *entry2)
{
  const struct mips_got_entry *e1 = (struct mips_got_entry *)entry1;
  const struct mips_got_entry *e2 = (struct mips_got_entry *)entry2;

  return e1->symndx == e2->symndx
    && (e1->symndx >= 0 ? e1->abfd == e2->abfd && e1->d.addend == e2->d.addend
	: e1->abfd == NULL || e2->abfd == NULL
	? e1->abfd == e2->abfd && e1->d.address == e2->d.address
	: e1->d.h == e2->d.h);
}

/* Returns the dynamic relocation section for DYNOBJ.  */

static asection *
mips_elf_rel_dyn_section (bfd *dynobj, bfd_boolean create_p)
{
  static const char dname[] = ".rel.dyn";
  asection *sreloc;

  sreloc = bfd_get_section_by_name (dynobj, dname);
  if (sreloc == NULL && create_p)
    {
      sreloc = bfd_make_section (dynobj, dname);
      if (sreloc == NULL
	  || ! bfd_set_section_flags (dynobj, sreloc,
				      (SEC_ALLOC
				       | SEC_LOAD
				       | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY
				       | SEC_LINKER_CREATED
				       | SEC_READONLY))
	  || ! bfd_set_section_alignment (dynobj, sreloc,
					  MIPS_ELF_LOG_FILE_ALIGN (dynobj)))
	return NULL;
    }
  return sreloc;
}

d1381 2
a1382 1
mips_elf_got_section (bfd *abfd, bfd_boolean maybe_excluded)
d1384 1
a1384 5
  asection *sgot = bfd_get_section_by_name (abfd, ".got");
  if (sgot == NULL
      || (! maybe_excluded && (sgot->flags & SEC_EXCLUDE) != 0))
    return NULL;
  return sgot;
d1392 3
a1394 1
mips_elf_got_info (bfd *abfd, asection **sgotp)
d1399 1
a1399 1
  sgot = mips_elf_got_section (abfd, TRUE);
d1401 2
a1402 2
  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
  g = mips_elf_section_data (sgot)->u.got_info;
d1406 1
a1406 2
    *sgotp = (sgot->flags & SEC_EXCLUDE) == 0 ? sgot : NULL;

a1409 22
/* Obtain the lowest dynamic index of a symbol that was assigned a
   global GOT entry.  */
static long
mips_elf_get_global_gotsym_index (bfd *abfd)
{
  asection *sgot;
  struct mips_got_info *g;

  if (abfd == NULL)
    return 0;

  sgot = mips_elf_got_section (abfd, TRUE);
  if (sgot == NULL || mips_elf_section_data (sgot) == NULL)
    return 0;

  g = mips_elf_section_data (sgot)->u.got_info;
  if (g == NULL || g->global_gotsym == NULL)
    return 0;

  return g->global_gotsym->dynindx;
}

d1415 4
a1418 2
mips_elf_local_got_index (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
			  bfd_vma value)
d1422 1
a1422 1
  struct mips_got_entry *entry;
d1426 12
a1437 5
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot, value);
  if (entry)
    return entry->gotidx;
  else
    return MINUS_ONE;
d1443 3
a1445 1
mips_elf_global_got_index (bfd *abfd, bfd *ibfd, struct elf_link_hash_entry *h)
d1449 1
a1449 1
  struct mips_got_info *g, *gg;
d1452 3
a1454 23
  gg = g = mips_elf_got_info (abfd, &sgot);
  if (g->bfd2got && ibfd)
    {
      struct mips_got_entry e, *p;

      BFD_ASSERT (h->dynindx >= 0);

      g = mips_elf_got_for_ibfd (g, ibfd);
      if (g->next != gg)
	{
	  e.abfd = ibfd;
	  e.symndx = -1;
	  e.d.h = (struct mips_elf_link_hash_entry *)h;

	  p = htab_find (g->got_entries, &e);

	  BFD_ASSERT (p->gotidx > 0);
	  return p->gotidx;
	}
    }

  if (gg->global_gotsym != NULL)
    global_got_dynindx = gg->global_gotsym->dynindx;
d1475 5
a1479 2
mips_elf_got_page (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
		   bfd_vma value, bfd_vma *offsetp)
d1483 4
a1486 2
  bfd_vma index;
  struct mips_got_entry *entry;
d1490 17
a1506 6
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot,
					   (value + 0x8000)
					   & (~(bfd_vma)0xffff));

  if (!entry)
    return MINUS_ONE;
d1508 3
a1510 1
  index = entry->gotidx;
d1513 4
a1516 1
    *offsetp = value - entry->d.address;
d1525 5
a1529 2
mips_elf_got16_entry (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
		      bfd_vma value, bfd_boolean external)
d1533 4
a1536 1
  struct mips_got_entry *entry;
d1549 22
a1570 5
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot, value);
  if (entry)
    return entry->gotidx;
  else
    return MINUS_ONE;
d1577 4
a1580 2
mips_elf_got_offset_from_index (bfd *dynobj, bfd *output_bfd,
				bfd *input_bfd, bfd_vma index)
a1583 5
  struct mips_got_info *g;

  g = mips_elf_got_info (dynobj, &sgot);
  gp = _bfd_get_gp_value (output_bfd)
    + mips_elf_adjust_gp (output_bfd, g, input_bfd);
d1585 4
a1588 1
  return sgot->output_section->vma + sgot->output_offset + index - gp;
d1594 6
a1599 4
static struct mips_got_entry *
mips_elf_create_local_got_entry (bfd *abfd, bfd *ibfd,
				 struct mips_got_info *gg,
				 asection *sgot, bfd_vma value)
a1600 28
  struct mips_got_entry entry, **loc;
  struct mips_got_info *g;

  entry.abfd = NULL;
  entry.symndx = -1;
  entry.d.address = value;

  g = mips_elf_got_for_ibfd (gg, ibfd);
  if (g == NULL)
    {
      g = mips_elf_got_for_ibfd (gg, abfd);
      BFD_ASSERT (g != NULL);
    }

  loc = (struct mips_got_entry **) htab_find_slot (g->got_entries, &entry,
						   INSERT);
  if (*loc)
    return *loc;

  entry.gotidx = MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno++;

  *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);

  if (! *loc)
    return NULL;

  memcpy (*loc, &entry, sizeof entry);

a1602 1
      (*loc)->gotidx = -1;
d1607 1
a1607 1
      return NULL;
d1611 3
a1613 3
		     (sgot->contents + entry.gotidx));

  return *loc;
d1623 4
a1626 2
static bfd_boolean
mips_elf_sort_hash_table (struct bfd_link_info *info, unsigned long max_local)
a1633 2
  g = mips_elf_got_info (dynobj, NULL);

d1635 1
a1635 10
  hsd.max_unref_got_dynindx =
  hsd.min_got_dynindx = elf_hash_table (info)->dynsymcount
    /* In the multi-got case, assigned_gotno of the master got_info
       indicate the number of entries that aren't referenced in the
       primary GOT, but that must have entries because there are
       dynamic relocations that reference it.  Since they aren't
       referenced, we move them to the end of the GOT, so that they
       don't prevent other entries that are referenced from getting
       too large offsets.  */
    - (g->next ? g->assigned_gotno : 0);
a1644 2
  BFD_ASSERT ((unsigned long)hsd.max_unref_got_dynindx
	      <= elf_hash_table (info)->dynsymcount);
d1648 1
d1651 1
a1651 1
  return TRUE;
d1658 4
a1661 2
static bfd_boolean
mips_elf_sort_hash_table_f (struct mips_elf_link_hash_entry *h, void *data)
d1663 2
a1664 1
  struct mips_elf_hash_sort_data *hsd = data;
d1672 1
a1672 1
    return TRUE;
d1674 1
a1674 11
  /* Global symbols that need GOT entries that are not explicitly
     referenced are marked with got offset 2.  Those that are
     referenced get a 1, and those that don't need GOT entries get
     -1.  */
  if (h->root.got.offset == 2)
    {
      if (hsd->max_unref_got_dynindx == hsd->min_got_dynindx)
	hsd->low = (struct elf_link_hash_entry *) h;
      h->root.dynindx = hsd->max_unref_got_dynindx++;
    }
  else if (h->root.got.offset != 1)
d1682 1
a1682 1
  return TRUE;
d1689 5
a1693 4
static bfd_boolean
mips_elf_record_global_got_symbol (struct elf_link_hash_entry *h,
				   bfd *abfd, struct bfd_link_info *info,
				   struct mips_got_info *g)
a1694 2
  struct mips_got_entry entry, **loc;

d1703 1
a1703 1
	  _bfd_mips_elf_hide_symbol (info, h, TRUE);
d1707 1
a1707 1
	return FALSE;
a1709 7
  entry.abfd = abfd;
  entry.symndx = -1;
  entry.d.h = (struct mips_elf_link_hash_entry *) h;

  loc = (struct mips_got_entry **) htab_find_slot (g->got_entries, &entry,
						   INSERT);

a1711 11
  if (*loc)
    return TRUE;

  *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);

  if (! *loc)
    return FALSE;

  entry.gotidx = -1;
  memcpy (*loc, &entry, sizeof entry);

d1713 1
a1713 1
    return TRUE;
d1720 1
a1720 567
  return TRUE;
}

/* Reserve space in G for a GOT entry containing the value of symbol
   SYMNDX in input bfd ABDF, plus ADDEND.  */

static bfd_boolean
mips_elf_record_local_got_symbol (bfd *abfd, long symndx, bfd_vma addend,
				  struct mips_got_info *g)
{
  struct mips_got_entry entry, **loc;

  entry.abfd = abfd;
  entry.symndx = symndx;
  entry.d.addend = addend;
  loc = (struct mips_got_entry **)
    htab_find_slot (g->got_entries, &entry, INSERT);

  if (*loc)
    return TRUE;

  entry.gotidx = g->local_gotno++;

  *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);

  if (! *loc)
    return FALSE;

  memcpy (*loc, &entry, sizeof entry);

  return TRUE;
}

/* Compute the hash value of the bfd in a bfd2got hash entry.  */

static hashval_t
mips_elf_bfd2got_entry_hash (const void *entry_)
{
  const struct mips_elf_bfd2got_hash *entry
    = (struct mips_elf_bfd2got_hash *)entry_;

  return entry->bfd->id;
}

/* Check whether two hash entries have the same bfd.  */

static int
mips_elf_bfd2got_entry_eq (const void *entry1, const void *entry2)
{
  const struct mips_elf_bfd2got_hash *e1
    = (const struct mips_elf_bfd2got_hash *)entry1;
  const struct mips_elf_bfd2got_hash *e2
    = (const struct mips_elf_bfd2got_hash *)entry2;

  return e1->bfd == e2->bfd;
}

/* In a multi-got link, determine the GOT to be used for IBDF.  G must
   be the master GOT data.  */

static struct mips_got_info *
mips_elf_got_for_ibfd (struct mips_got_info *g, bfd *ibfd)
{
  struct mips_elf_bfd2got_hash e, *p;

  if (! g->bfd2got)
    return g;

  e.bfd = ibfd;
  p = htab_find (g->bfd2got, &e);
  return p ? p->g : NULL;
}

/* Create one separate got for each bfd that has entries in the global
   got, such that we can tell how many local and global entries each
   bfd requires.  */

static int
mips_elf_make_got_per_bfd (void **entryp, void *p)
{
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  struct mips_elf_got_per_bfd_arg *arg = (struct mips_elf_got_per_bfd_arg *)p;
  htab_t bfd2got = arg->bfd2got;
  struct mips_got_info *g;
  struct mips_elf_bfd2got_hash bfdgot_entry, *bfdgot;
  void **bfdgotp;

  /* Find the got_info for this GOT entry's input bfd.  Create one if
     none exists.  */
  bfdgot_entry.bfd = entry->abfd;
  bfdgotp = htab_find_slot (bfd2got, &bfdgot_entry, INSERT);
  bfdgot = (struct mips_elf_bfd2got_hash *)*bfdgotp;

  if (bfdgot != NULL)
    g = bfdgot->g;
  else
    {
      bfdgot = (struct mips_elf_bfd2got_hash *)bfd_alloc
	(arg->obfd, sizeof (struct mips_elf_bfd2got_hash));

      if (bfdgot == NULL)
	{
	  arg->obfd = 0;
	  return 0;
	}

      *bfdgotp = bfdgot;

      bfdgot->bfd = entry->abfd;
      bfdgot->g = g = (struct mips_got_info *)
	bfd_alloc (arg->obfd, sizeof (struct mips_got_info));
      if (g == NULL)
	{
	  arg->obfd = 0;
	  return 0;
	}

      g->global_gotsym = NULL;
      g->global_gotno = 0;
      g->local_gotno = 0;
      g->assigned_gotno = -1;
      g->got_entries = htab_try_create (1, mips_elf_multi_got_entry_hash,
					mips_elf_multi_got_entry_eq, NULL);
      if (g->got_entries == NULL)
	{
	  arg->obfd = 0;
	  return 0;
	}

      g->bfd2got = NULL;
      g->next = NULL;
    }

  /* Insert the GOT entry in the bfd's got entry hash table.  */
  entryp = htab_find_slot (g->got_entries, entry, INSERT);
  if (*entryp != NULL)
    return 1;

  *entryp = entry;

  if (entry->symndx >= 0 || entry->d.h->forced_local)
    ++g->local_gotno;
  else
    ++g->global_gotno;

  return 1;
}

/* Attempt to merge gots of different input bfds.  Try to use as much
   as possible of the primary got, since it doesn't require explicit
   dynamic relocations, but don't use bfds that would reference global
   symbols out of the addressable range.  Failing the primary got,
   attempt to merge with the current got, or finish the current got
   and then make make the new got current.  */

static int
mips_elf_merge_gots (void **bfd2got_, void *p)
{
  struct mips_elf_bfd2got_hash *bfd2got
    = (struct mips_elf_bfd2got_hash *)*bfd2got_;
  struct mips_elf_got_per_bfd_arg *arg = (struct mips_elf_got_per_bfd_arg *)p;
  unsigned int lcount = bfd2got->g->local_gotno;
  unsigned int gcount = bfd2got->g->global_gotno;
  unsigned int maxcnt = arg->max_count;

  /* If we don't have a primary GOT and this is not too big, use it as
     a starting point for the primary GOT.  */
  if (! arg->primary && lcount + gcount <= maxcnt)
    {
      arg->primary = bfd2got->g;
      arg->primary_count = lcount + gcount;
    }
  /* If it looks like we can merge this bfd's entries with those of
     the primary, merge them.  The heuristics is conservative, but we
     don't have to squeeze it too hard.  */
  else if (arg->primary
	   && (arg->primary_count + lcount + gcount) <= maxcnt)
    {
      struct mips_got_info *g = bfd2got->g;
      int old_lcount = arg->primary->local_gotno;
      int old_gcount = arg->primary->global_gotno;

      bfd2got->g = arg->primary;

      htab_traverse (g->got_entries,
		     mips_elf_make_got_per_bfd,
		     arg);
      if (arg->obfd == NULL)
	return 0;

      htab_delete (g->got_entries);
      /* We don't have to worry about releasing memory of the actual
	 got entries, since they're all in the master got_entries hash
	 table anyway.  */

      BFD_ASSERT (old_lcount + lcount >= arg->primary->local_gotno);
      BFD_ASSERT (old_gcount + gcount >= arg->primary->global_gotno);

      arg->primary_count = arg->primary->local_gotno
	+ arg->primary->global_gotno;
    }
  /* If we can merge with the last-created got, do it.  */
  else if (arg->current
	   && arg->current_count + lcount + gcount <= maxcnt)
    {
      struct mips_got_info *g = bfd2got->g;
      int old_lcount = arg->current->local_gotno;
      int old_gcount = arg->current->global_gotno;

      bfd2got->g = arg->current;

      htab_traverse (g->got_entries,
		     mips_elf_make_got_per_bfd,
		     arg);
      if (arg->obfd == NULL)
	return 0;

      htab_delete (g->got_entries);

      BFD_ASSERT (old_lcount + lcount >= arg->current->local_gotno);
      BFD_ASSERT (old_gcount + gcount >= arg->current->global_gotno);

      arg->current_count = arg->current->local_gotno
	+ arg->current->global_gotno;
    }
  /* Well, we couldn't merge, so create a new GOT.  Don't check if it
     fits; if it turns out that it doesn't, we'll get relocation
     overflows anyway.  */
  else
    {
      bfd2got->g->next = arg->current;
      arg->current = bfd2got->g;

      arg->current_count = lcount + gcount;
    }

  return 1;
}

/* If passed a NULL mips_got_info in the argument, set the marker used
   to tell whether a global symbol needs a got entry (in the primary
   got) to the given VALUE.

   If passed a pointer G to a mips_got_info in the argument (it must
   not be the primary GOT), compute the offset from the beginning of
   the (primary) GOT section to the entry in G corresponding to the
   global symbol.  G's assigned_gotno must contain the index of the
   first available global GOT entry in G.  VALUE must contain the size
   of a GOT entry in bytes.  For each global GOT entry that requires a
   dynamic relocation, NEEDED_RELOCS is incremented, and the symbol is
   marked as not eligible for lazy resolution through a function
   stub.  */
static int
mips_elf_set_global_got_offset (void **entryp, void *p)
{
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  struct mips_elf_set_global_got_offset_arg *arg
    = (struct mips_elf_set_global_got_offset_arg *)p;
  struct mips_got_info *g = arg->g;

  if (entry->abfd != NULL && entry->symndx == -1
      && entry->d.h->root.dynindx != -1)
    {
      if (g)
	{
	  BFD_ASSERT (g->global_gotsym == NULL);

	  entry->gotidx = arg->value * (long) g->assigned_gotno++;
	  if (arg->info->shared
	      || (elf_hash_table (arg->info)->dynamic_sections_created
		  && ((entry->d.h->root.elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
		  && ((entry->d.h->root.elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_REGULAR) == 0)))
	    ++arg->needed_relocs;
	}
      else
	entry->d.h->root.got.offset = arg->value;
    }

  return 1;
}

/* Mark any global symbols referenced in the GOT we are iterating over
   as inelligible for lazy resolution stubs.  */
static int
mips_elf_set_no_stub (void **entryp, void *p ATTRIBUTE_UNUSED)
{
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;

  if (entry->abfd != NULL
      && entry->symndx == -1
      && entry->d.h->root.dynindx != -1)
    entry->d.h->no_fn_stub = TRUE;

  return 1;
}

/* Follow indirect and warning hash entries so that each got entry
   points to the final symbol definition.  P must point to a pointer
   to the hash table we're traversing.  Since this traversal may
   modify the hash table, we set this pointer to NULL to indicate
   we've made a potentially-destructive change to the hash table, so
   the traversal must be restarted.  */
static int
mips_elf_resolve_final_got_entry (void **entryp, void *p)
{
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  htab_t got_entries = *(htab_t *)p;

  if (entry->abfd != NULL && entry->symndx == -1)
    {
      struct mips_elf_link_hash_entry *h = entry->d.h;

      while (h->root.root.type == bfd_link_hash_indirect
 	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

      if (entry->d.h == h)
	return 1;

      entry->d.h = h;

      /* If we can't find this entry with the new bfd hash, re-insert
	 it, and get the traversal restarted.  */
      if (! htab_find (got_entries, entry))
	{
	  htab_clear_slot (got_entries, entryp);
	  entryp = htab_find_slot (got_entries, entry, INSERT);
	  if (! *entryp)
	    *entryp = entry;
	  /* Abort the traversal, since the whole table may have
	     moved, and leave it up to the parent to restart the
	     process.  */
	  *(htab_t *)p = NULL;
	  return 0;
	}
      /* We might want to decrement the global_gotno count, but it's
	 either too early or too late for that at this point.  */
    }

  return 1;
}

/* Turn indirect got entries in a got_entries table into their final
   locations.  */
static void
mips_elf_resolve_final_got_entries (struct mips_got_info *g)
{
  htab_t got_entries;

  do
    {
      got_entries = g->got_entries;

      htab_traverse (got_entries,
		     mips_elf_resolve_final_got_entry,
		     &got_entries);
    }
  while (got_entries == NULL);
}

/* Return the offset of an input bfd IBFD's GOT from the beginning of
   the primary GOT.  */
static bfd_vma
mips_elf_adjust_gp (bfd *abfd, struct mips_got_info *g, bfd *ibfd)
{
  if (g->bfd2got == NULL)
    return 0;

  g = mips_elf_got_for_ibfd (g, ibfd);
  if (! g)
    return 0;

  BFD_ASSERT (g->next);

  g = g->next;

  return (g->local_gotno + g->global_gotno) * MIPS_ELF_GOT_SIZE (abfd);
}

/* Turn a single GOT that is too big for 16-bit addressing into
   a sequence of GOTs, each one 16-bit addressable.  */

static bfd_boolean
mips_elf_multi_got (bfd *abfd, struct bfd_link_info *info,
		    struct mips_got_info *g, asection *got,
		    bfd_size_type pages)
{
  struct mips_elf_got_per_bfd_arg got_per_bfd_arg;
  struct mips_elf_set_global_got_offset_arg set_got_offset_arg;
  struct mips_got_info *gg;
  unsigned int assign;

  g->bfd2got = htab_try_create (1, mips_elf_bfd2got_entry_hash,
				mips_elf_bfd2got_entry_eq, NULL);
  if (g->bfd2got == NULL)
    return FALSE;

  got_per_bfd_arg.bfd2got = g->bfd2got;
  got_per_bfd_arg.obfd = abfd;
  got_per_bfd_arg.info = info;

  /* Count how many GOT entries each input bfd requires, creating a
     map from bfd to got info while at that.  */
  mips_elf_resolve_final_got_entries (g);
  htab_traverse (g->got_entries, mips_elf_make_got_per_bfd, &got_per_bfd_arg);
  if (got_per_bfd_arg.obfd == NULL)
    return FALSE;

  got_per_bfd_arg.current = NULL;
  got_per_bfd_arg.primary = NULL;
  /* Taking out PAGES entries is a worst-case estimate.  We could
     compute the maximum number of pages that each separate input bfd
     uses, but it's probably not worth it.  */
  got_per_bfd_arg.max_count = ((MIPS_ELF_GOT_MAX_SIZE (abfd)
				/ MIPS_ELF_GOT_SIZE (abfd))
			       - MIPS_RESERVED_GOTNO - pages);

  /* Try to merge the GOTs of input bfds together, as long as they
     don't seem to exceed the maximum GOT size, choosing one of them
     to be the primary GOT.  */
  htab_traverse (g->bfd2got, mips_elf_merge_gots, &got_per_bfd_arg);
  if (got_per_bfd_arg.obfd == NULL)
    return FALSE;

  /* If we find any suitable primary GOT, create an empty one.  */
  if (got_per_bfd_arg.primary == NULL)
    {
      g->next = (struct mips_got_info *)
	bfd_alloc (abfd, sizeof (struct mips_got_info));
      if (g->next == NULL)
	return FALSE;

      g->next->global_gotsym = NULL;
      g->next->global_gotno = 0;
      g->next->local_gotno = 0;
      g->next->assigned_gotno = 0;
      g->next->got_entries = htab_try_create (1, mips_elf_multi_got_entry_hash,
					      mips_elf_multi_got_entry_eq,
					      NULL);
      if (g->next->got_entries == NULL)
	return FALSE;
      g->next->bfd2got = NULL;
    }
  else
    g->next = got_per_bfd_arg.primary;
  g->next->next = got_per_bfd_arg.current;

  /* GG is now the master GOT, and G is the primary GOT.  */
  gg = g;
  g = g->next;

  /* Map the output bfd to the primary got.  That's what we're going
     to use for bfds that use GOT16 or GOT_PAGE relocations that we
     didn't mark in check_relocs, and we want a quick way to find it.
     We can't just use gg->next because we're going to reverse the
     list.  */
  {
    struct mips_elf_bfd2got_hash *bfdgot;
    void **bfdgotp;

    bfdgot = (struct mips_elf_bfd2got_hash *)bfd_alloc
      (abfd, sizeof (struct mips_elf_bfd2got_hash));

    if (bfdgot == NULL)
      return FALSE;

    bfdgot->bfd = abfd;
    bfdgot->g = g;
    bfdgotp = htab_find_slot (gg->bfd2got, bfdgot, INSERT);

    BFD_ASSERT (*bfdgotp == NULL);
    *bfdgotp = bfdgot;
  }

  /* The IRIX dynamic linker requires every symbol that is referenced
     in a dynamic relocation to be present in the primary GOT, so
     arrange for them to appear after those that are actually
     referenced.

     GNU/Linux could very well do without it, but it would slow down
     the dynamic linker, since it would have to resolve every dynamic
     symbol referenced in other GOTs more than once, without help from
     the cache.  Also, knowing that every external symbol has a GOT
     helps speed up the resolution of local symbols too, so GNU/Linux
     follows IRIX's practice.

     The number 2 is used by mips_elf_sort_hash_table_f to count
     global GOT symbols that are unreferenced in the primary GOT, with
     an initial dynamic index computed from gg->assigned_gotno, where
     the number of unreferenced global entries in the primary GOT is
     preserved.  */
  if (1)
    {
      gg->assigned_gotno = gg->global_gotno - g->global_gotno;
      g->global_gotno = gg->global_gotno;
      set_got_offset_arg.value = 2;
    }
  else
    {
      /* This could be used for dynamic linkers that don't optimize
	 symbol resolution while applying relocations so as to use
	 primary GOT entries or assuming the symbol is locally-defined.
	 With this code, we assign lower dynamic indices to global
	 symbols that are not referenced in the primary GOT, so that
	 their entries can be omitted.  */
      gg->assigned_gotno = 0;
      set_got_offset_arg.value = -1;
    }

  /* Reorder dynamic symbols as described above (which behavior
     depends on the setting of VALUE).  */
  set_got_offset_arg.g = NULL;
  htab_traverse (gg->got_entries, mips_elf_set_global_got_offset,
		 &set_got_offset_arg);
  set_got_offset_arg.value = 1;
  htab_traverse (g->got_entries, mips_elf_set_global_got_offset,
		 &set_got_offset_arg);
  if (! mips_elf_sort_hash_table (info, 1))
    return FALSE;

  /* Now go through the GOTs assigning them offset ranges.
     [assigned_gotno, local_gotno[ will be set to the range of local
     entries in each GOT.  We can then compute the end of a GOT by
     adding local_gotno to global_gotno.  We reverse the list and make
     it circular since then we'll be able to quickly compute the
     beginning of a GOT, by computing the end of its predecessor.  To
     avoid special cases for the primary GOT, while still preserving
     assertions that are valid for both single- and multi-got links,
     we arrange for the main got struct to have the right number of
     global entries, but set its local_gotno such that the initial
     offset of the primary GOT is zero.  Remember that the primary GOT
     will become the last item in the circular linked list, so it
     points back to the master GOT.  */
  gg->local_gotno = -g->global_gotno;
  gg->global_gotno = g->global_gotno;
  assign = 0;
  gg->next = gg;

  do
    {
      struct mips_got_info *gn;

      assign += MIPS_RESERVED_GOTNO;
      g->assigned_gotno = assign;
      g->local_gotno += assign + pages;
      assign = g->local_gotno + g->global_gotno;

      /* Take g out of the direct list, and push it onto the reversed
	 list that gg points to.  */
      gn = g->next;
      g->next = gg->next;
      gg->next = g;
      g = gn;

      /* Mark global symbols in every non-primary GOT as ineligible for
	 stubs.  */
      if (g)
	htab_traverse (g->got_entries, mips_elf_set_no_stub, NULL);
    }
  while (g);

  got->_raw_size = (gg->next->local_gotno
		    + gg->next->global_gotno) * MIPS_ELF_GOT_SIZE (abfd);

  return TRUE;
a1721 1

d1727 5
a1731 3
mips_elf_next_relocation (bfd *abfd ATTRIBUTE_UNUSED, unsigned int r_type,
			  const Elf_Internal_Rela *relocation,
			  const Elf_Internal_Rela *relend)
d1754 7
a1760 5
static bfd_boolean
mips_elf_local_relocation_p (bfd *input_bfd,
			     const Elf_Internal_Rela *relocation,
			     asection **local_sections,
			     bfd_boolean check_forced)
d1772 1
a1772 1
    return TRUE;
d1774 1
a1774 1
    return TRUE;
d1787 1
a1787 1
	return TRUE;
d1790 1
a1790 1
  return FALSE;
d1795 4
a1798 2
bfd_vma
_bfd_mips_elf_sign_extend (bfd_vma value, int bits)
d1808 1
a1808 1
   range expressible by a signed number with the indicated number of
d1811 4
a1814 2
static bfd_boolean
mips_elf_overflow_p (bfd_vma value, int bits)
d1820 1
a1820 1
    return TRUE;
d1823 1
a1823 1
    return TRUE;
d1826 1
a1826 1
  return FALSE;
d1832 2
a1833 1
mips_elf_high (bfd_vma value)
d1841 2
a1842 1
mips_elf_higher (bfd_vma value ATTRIBUTE_UNUSED)
d1855 2
a1856 1
mips_elf_highest (bfd_vma value ATTRIBUTE_UNUSED)
d1859 1
a1859 1
  return ((value + (((bfd_vma) 0x8000 << 32) | 0x80008000)) >> 48) & 0xffff;
d1868 4
a1871 3
static bfd_boolean
mips_elf_create_compact_rel_section
  (bfd *abfd, struct bfd_link_info *info ATTRIBUTE_UNUSED)
d1886 1
a1886 1
	return FALSE;
d1891 1
a1891 1
  return TRUE;
d1896 4
a1899 3
static bfd_boolean
mips_elf_create_got_section (bfd *abfd, struct bfd_link_info *info,
			     bfd_boolean maybe_exclude)
d1909 2
a1910 7
  s = mips_elf_got_section (abfd, TRUE);
  if (s)
    {
      if (! maybe_exclude)
	s->flags &= ~SEC_EXCLUDE;
      return TRUE;
    }
a1914 5
  if (maybe_exclude)
    flags |= SEC_EXCLUDE;

  /* We have to use an alignment of 2**4 here because this is hardcoded
     in the function stub generation and in the linker script.  */
d1919 1
a1919 1
    return FALSE;
d1927 3
a1929 2
	  0, NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
    return FALSE;
d1938 4
a1941 1
    return FALSE;
d1944 1
a1944 1
  g = bfd_alloc (abfd, amt);
d1946 1
a1946 1
    return FALSE;
a1947 1
  g->global_gotno = 0;
d1950 9
a1958 8
  g->bfd2got = NULL;
  g->next = NULL;
  g->got_entries = htab_try_create (1, mips_elf_got_entry_hash,
				    mips_elf_got_entry_eq, NULL);
  if (g->got_entries == NULL)
    return FALSE;
  mips_elf_section_data (s)->u.got_info = g;
  mips_elf_section_data (s)->elf.this_hdr.sh_flags
d1961 29
a1989 1
  return TRUE;
d2006 17
a2022 9
mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
			       asection *input_section,
			       struct bfd_link_info *info,
			       const Elf_Internal_Rela *relocation,
			       bfd_vma addend, reloc_howto_type *howto,
			       Elf_Internal_Sym *local_syms,
			       asection **local_sections, bfd_vma *valuep,
			       const char **namep, bfd_boolean *require_jalxp,
			       bfd_boolean save_addend)
d2045 1
a2045 1
  /* TRUE if the symbol referred to by this relocation is a local
d2047 3
a2049 3
  bfd_boolean local_p, was_local_p;
  /* TRUE if the symbol referred to by this relocation is "_gp_disp".  */
  bfd_boolean gp_disp_p = FALSE;
d2054 1
a2054 1
  /* TRUE if overflow occurred during the calculation of the
d2056 3
a2058 3
  bfd_boolean overflowed_p;
  /* TRUE if this relocation refers to a MIPS16 function.  */
  bfd_boolean target_is_16_bit_code_p = FALSE;
d2068 1
a2068 1
  overflowed_p = FALSE;
d2074 1
a2074 1
					 local_sections, FALSE);
a2119 2
      /* ??? Could we use RELOC_FOR_GLOBAL_SYMBOL here ?  */

d2133 1
a2133 1
      if (strcmp (*namep, "_gp_disp") == 0
d2141 1
a2141 1
	  gp_disp_p = TRUE;
d2166 2
a2167 1
	       && info->unresolved_syms_in_objects == RM_IGNORE
d2170 2
a2171 2
      else if (strcmp (*namep, "_DYNAMIC_LINK") == 0 ||
              strcmp (*namep, "_DYNAMIC_LINKING") == 0)
d2188 1
a2188 2
		  ((info->shared && info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)
		   || (!info->shared && info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
d2200 1
a2200 1
  if (r_type != R_MIPS16_26 && !info->relocatable
d2221 1
a2221 1
  else if (r_type == R_MIPS16_26 && !info->relocatable
d2257 1
a2257 1
  *require_jalxp = (!info->relocatable
d2262 1
a2262 1
					 local_sections, TRUE);
a2267 12
    case R_MIPS_GOT_PAGE:
    case R_MIPS_GOT_OFST:
      /* If this symbol got a global GOT entry, we have to decay
	 GOT_PAGE/GOT_OFST to GOT_DISP/addend.  */
      local_p = local_p || ! h
	|| (h->root.dynindx
	    < mips_elf_get_global_gotsym_index (elf_hash_table (info)
						->dynobj));
      if (local_p || r_type == R_MIPS_GOT_OFST)
	break;
      /* Fall through.  */

d2278 1
a2278 5
	  /* GOT_PAGE may take a non-zero addend, that is ignored in a
	     GOT_PAGE relocation that decays to GOT_DISP because the
	     symbol turns out to be global.  The addend is then added
	     as GOT_OFST.  */
	  BFD_ASSERT (addend == 0 || r_type == R_MIPS_GOT_PAGE);
a2279 1
					 input_bfd,
d2290 2
a2291 2
	      asection *sgot = mips_elf_got_section (tmpbfd, FALSE);
	      MIPS_ELF_PUT_WORD (tmpbfd, symbol, sgot->contents + g);
d2300 1
a2300 2
	  g = mips_elf_local_got_index (abfd, input_bfd,
					info, symbol + addend);
d2307 1
a2307 1
					  abfd, input_bfd, g);
a2317 5
      if (elf_hash_table (info)->dynobj)
	gp += mips_elf_adjust_gp (abfd,
				  mips_elf_got_info
				  (elf_hash_table (info)->dynobj, NULL),
				  input_bfd);
d2331 1
a2331 1
      value = symbol + _bfd_mips_elf_sign_extend (addend, 16);
d2382 1
a2382 1
      value = symbol + _bfd_mips_elf_sign_extend (addend << 2, 18) - p;
d2407 1
a2407 1
	value = (_bfd_mips_elf_sign_extend (addend << 2, 28) + symbol) >> 2;
d2467 1
a2467 1
	addend = _bfd_mips_elf_sign_extend (addend, 16);
d2483 1
a2483 1
	  bfd_boolean forced;
d2489 2
a2490 3
						  local_sections, FALSE);
	  value = mips_elf_got16_entry (abfd, input_bfd, info,
					symbol + addend, forced);
d2495 1
a2495 1
					      abfd, input_bfd, value);
a2502 1
    got_disp:
d2514 1
a2514 1
      value = _bfd_mips_elf_sign_extend (addend, 16) + symbol - p;
d2516 1
d2535 1
a2535 6
      /* GOT_PAGE relocations that reference non-local symbols decay
	 to GOT_DISP.  The corresponding GOT_OFST relocation decays to
	 0.  */
      if (! local_p)
	goto got_disp;
      value = mips_elf_got_page (abfd, input_bfd, info, symbol + addend, NULL);
d2539 1
a2539 1
					      abfd, input_bfd, value);
d2544 1
a2544 4
      if (local_p)
	mips_elf_got_page (abfd, input_bfd, info, symbol + addend, &value);
      else
	value = addend;
d2592 5
a2596 3
mips_elf_obtain_contents (reloc_howto_type *howto,
			  const Elf_Internal_Rela *relocation,
			  bfd *input_bfd, bfd_byte *contents)
d2617 1
a2617 1
   relocation applies.  If REQUIRE_JALX is TRUE, then the opcode used
d2621 1
a2621 1
   Returns FALSE if anything goes wrong.  */
d2623 11
a2633 7
static bfd_boolean
mips_elf_perform_relocation (struct bfd_link_info *info,
			     reloc_howto_type *howto,
			     const Elf_Internal_Rela *relocation,
			     bfd_vma value, bfd *input_bfd,
			     asection *input_section, bfd_byte *contents,
			     bfd_boolean require_jalx)
d2667 1
a2667 1
	 When producing a relocatable object file, R_MIPS16_26 is
d2705 1
a2705 1
	 When producing a relocatable object file, the calculation is
d2711 1
a2711 1
      if (!info->relocatable)
d2749 1
a2749 1
      bfd_boolean ok;
d2774 1
a2774 1
	  return FALSE;
d2789 1
a2789 1
  return TRUE;
d2792 1
a2792 1
/* Returns TRUE if SECTION is a MIPS16 stub section.  */
d2794 4
a2797 2
static bfd_boolean
mips_elf_stub_section_p (bfd *abfd ATTRIBUTE_UNUSED, asection *section)
d2809 3
a2811 1
mips_elf_allocate_dynamic_relocations (bfd *abfd, unsigned int n)
d2815 1
a2815 1
  s = mips_elf_rel_dyn_section (abfd, FALSE);
d2832 11
a2842 7
static bfd_boolean
mips_elf_create_dynamic_relocation (bfd *output_bfd,
				    struct bfd_link_info *info,
				    const Elf_Internal_Rela *rel,
				    struct mips_elf_link_hash_entry *h,
				    asection *sec, bfd_vma symbol,
				    bfd_vma *addendp, asection *input_section)
d2844 2
a2845 2
  Elf_Internal_Rela outrel[3];
  bfd_boolean skip;
d2852 1
a2852 1
  sreloc = mips_elf_rel_dyn_section (dynobj, FALSE);
d2858 1
a2858 1
  skip = FALSE;
d2870 1
a2870 1
  if (input_section->sec_info_type != ELF_INFO_TYPE_STABS)
d2886 1
a2886 1
	skip = TRUE;
d2891 4
a2894 10
    /* The relocation field has been deleted.  */
    skip = TRUE;
  else if (outrel[0].r_offset == (bfd_vma) -2)
    {
      /* The relocation field has been converted into a relative value of
	 some sort.  Functions like _bfd_elf_write_section_eh_frame expect
	 the field to be fully relocated, so add in the symbol's value.  */
      skip = TRUE;
      *addendp += symbol;
    }
d2900 1
a2900 1
    memset (outrel, 0, sizeof (Elf_Internal_Rela) * 3);
d2904 1
a2904 1
      bfd_boolean defined_p;
d2910 3
a2912 1
				   & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2915 2
a2916 12
	  && h->root.dynindx != -1)
	{
	  indx = h->root.dynindx;
	  if (SGI_COMPAT (output_bfd))
	    defined_p = ((h->root.elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) != 0);
	  else
	    /* ??? glibc's ld.so just adds the final GOT entry to the
	       relocation field.  It therefore treats relocs against
	       defined symbols in the same way as relocs against
	       undefined symbols.  */
	    defined_p = FALSE;
d2925 1
a2925 1
	      return FALSE;
d2934 9
a2942 18
	  /* Instead of generating a relocation using the section
	     symbol, we may as well make it a fully relative
	     relocation.  We want to avoid generating relocations to
	     local symbols because we used to generate them
	     incorrectly, without adding the original symbol value,
	     which is mandated by the ABI for section symbols.  In
	     order to give dynamic loaders and applications time to
	     phase out the incorrect use, we refrain from emitting
	     section-relative relocations.  It's not like they're
	     useful, after all.  This should be a bit more efficient
	     as well.  */
	  /* ??? Although this behavior is compatible with glibc's ld.so,
	     the ABI says that relocations against STN_UNDEF should have
	     a symbol value of 0.  Irix rld honors this, so relocations
	     against STN_UNDEF have no effect.  */
	  if (!SGI_COMPAT (output_bfd))
	    indx = 0;
	  defined_p = TRUE;
d2949 1
a2949 1
      if (defined_p && r_type != R_MIPS_REL32)
d2956 1
a2956 13
      /* For strict adherence to the ABI specification, we should
	 generate a R_MIPS_64 relocation record by itself before the
	 _REL32/_64 record as well, such that the addend is read in as
	 a 64-bit value (REL32 is a 32-bit relocation, after all).
	 However, since none of the existing ELF64 MIPS dynamic
	 loaders seems to care, we don't waste space with these
	 artificial relocations.  If this turns out to not be true,
	 mips_elf_allocate_dynamic_relocation() should be tweaked so
	 as to make room for a pair of dynamic relocations per
	 invocation if ABI_64_P, and here we should generate an
	 additional relocation record with R_MIPS_64 by itself for a
	 NULL symbol before this relocation record.  */
      outrel[1].r_info = ELF_R_INFO (output_bfd, 0,
d2960 2
a2961 1
      outrel[2].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_NONE);
d2984 11
a2994 3
    bfd_elf32_swap_reloc_out
      (output_bfd, &outrel[0],
       (sreloc->contents + sreloc->reloc_count * sizeof (Elf32_External_Rel)));
d3034 1
a3034 1
  return TRUE;
d3037 26
d3066 2
a3067 1
_bfd_elf_mips_mach (flagword flags)
a3128 8

	case E_MIPS_ARCH_32R2:
	  return bfd_mach_mipsisa32r2;
	  break;

	case E_MIPS_ARCH_64R2:
	  return bfd_mach_mipsisa64r2;
	  break;
d3138 2
a3139 1
elf_mips_abi_name (bfd *abfd)
d3186 3
a3188 1
_bfd_mips_elf_symbol_processing (bfd *abfd, asymbol *asym)
d3263 4
a3266 2
bfd_boolean
_bfd_mips_elf_section_processing (bfd *abfd, Elf_Internal_Shdr *hdr)
d3279 1
a3279 1
	return FALSE;
d3281 2
a3282 2
      if (bfd_bwrite (buf, 4, abfd) != 4)
	return FALSE;
d3287 2
a3288 2
      && mips_elf_section_data (hdr->bfd_section) != NULL
      && mips_elf_section_data (hdr->bfd_section)->u.tdata != NULL)
d3292 3
a3294 3
      /* We stored the section contents in the tdata field in the
	 set_section_contents routine.  We save the section contents
	 so that we don't have to read them again.
d3299 1
a3299 1
      contents = mips_elf_section_data (hdr->bfd_section)->u.tdata;
d3318 1
a3318 1
		return FALSE;
d3320 2
a3321 2
	      if (bfd_bwrite (buf, 8, abfd) != 8)
		return FALSE;
d3333 1
a3333 1
		return FALSE;
d3335 2
a3336 2
	      if (bfd_bwrite (buf, 4, abfd) != 4)
		return FALSE;
d3381 1
a3381 1
  return TRUE;
d3391 5
a3395 3
bfd_boolean
_bfd_mips_elf_section_from_shdr (bfd *abfd, Elf_Internal_Shdr *hdr,
				 const char *name)
d3408 1
a3408 1
	return FALSE;
d3412 1
a3412 1
	return FALSE;
d3416 1
a3416 1
	return FALSE;
d3420 1
a3420 1
	return FALSE;
d3424 1
a3424 1
	return FALSE;
d3428 1
a3428 1
	return FALSE;
d3434 1
a3434 1
	return FALSE;
d3439 1
a3439 1
	return FALSE;
d3443 1
a3443 1
	return FALSE;
d3447 1
a3447 1
	return FALSE;
d3451 1
a3451 1
	return FALSE;
d3455 1
a3455 1
	return FALSE;
d3461 1
a3461 1
	return FALSE;
d3464 1
a3464 1
      return FALSE;
d3468 1
a3468 1
    return FALSE;
d3476 1
a3476 1
	return FALSE;
d3490 4
a3493 3
      if (! bfd_get_section_contents (abfd, hdr->bfd_section,
				      &ext, 0, sizeof ext))
	return FALSE;
d3506 1
a3506 1
      contents = bfd_malloc (hdr->sh_size);
d3508 1
a3508 1
	return FALSE;
d3510 1
a3510 1
				      0, hdr->sh_size))
d3513 1
a3513 1
	  return FALSE;
d3550 1
a3550 1
  return TRUE;
d3557 5
a3561 2
bfd_boolean
_bfd_mips_elf_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec)
d3667 25
a3691 5
  /* The generic elf_fake_sections will set up REL_HDR using the default
   kind of relocations.  We used to set up a second header for the
   non-default kind of relocations here, but only NewABI would use
   these, and the IRIX ld doesn't like resulting empty RELA sections.
   Thus we create those header only on demand now.  */
d3693 1
a3693 1
  return TRUE;
d3702 5
a3706 3
bfd_boolean
_bfd_mips_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
					asection *sec, int *retval)
d3711 1
a3711 1
      return TRUE;
d3716 1
a3716 1
      return TRUE;
d3718 1
a3718 1
  return FALSE;
d3724 9
a3732 5
bfd_boolean
_bfd_mips_elf_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
			       const Elf_Internal_Sym *sym, const char **namep,
			       flagword *flagsp ATTRIBUTE_UNUSED,
			       asection **secp, bfd_vma *valp)
d3740 1
a3740 1
      return TRUE;
d3768 1
a3768 1
	    return FALSE;
d3773 1
a3773 1
	    return FALSE;
d3809 1
a3809 1
	    return FALSE;
d3814 1
a3814 1
	    return FALSE;
d3854 2
a3855 1
	     (info, abfd, *namep, BSF_GLOBAL, *secp, *valp, NULL, FALSE,
d3857 1
a3857 1
	return FALSE;
d3865 1
a3865 1
	return FALSE;
d3867 1
a3867 1
      mips_elf_hash_table (info)->use_rld_obj_head = TRUE;
d3876 1
a3876 1
  return TRUE;
d3883 7
a3889 5
bfd_boolean
_bfd_mips_elf_link_output_symbol_hook
  (struct bfd_link_info *info ATTRIBUTE_UNUSED,
   const char *name ATTRIBUTE_UNUSED, Elf_Internal_Sym *sym,
   asection *input_sec, struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d3902 1
a3902 1
  return TRUE;
d3909 4
a3912 2
bfd_boolean
_bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d3928 1
a3928 1
	return FALSE;
d3932 2
a3933 2
  if (! mips_elf_create_got_section (abfd, info, FALSE))
    return FALSE;
d3935 6
a3940 2
  if (! mips_elf_rel_dyn_section (elf_hash_table (info)->dynobj, TRUE))
    return FALSE;
d3951 1
a3951 1
	return FALSE;
d3963 1
a3963 1
	return FALSE;
d3976 4
a3979 3
		 (info, abfd, *namep, BSF_GLOBAL, bfd_und_section_ptr, 0,
		  NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	    return FALSE;
d3987 1
a3987 1
	    return FALSE;
d3994 1
a3994 1
	    return FALSE;
d4000 1
a4000 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d4003 1
a4003 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d4006 1
a4006 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d4009 1
a4009 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d4012 1
a4012 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d4022 4
a4025 3
	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr, 0,
	     NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;
d4033 1
a4033 1
	return FALSE;
d4047 2
a4048 1
		(info, abfd, name, BSF_GLOBAL, s, 0, NULL, FALSE,
d4050 1
a4050 1
	    return FALSE;
d4058 1
a4058 1
	    return FALSE;
d4062 1
a4062 1
  return TRUE;
d4068 6
a4073 3
bfd_boolean
_bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
			    asection *sec, const Elf_Internal_Rela *relocs)
d4085 1
a4085 1
  const struct elf_backend_data *bed;
d4087 2
a4088 2
  if (info->relocatable)
    return TRUE;
d4131 4
a4134 3
	      sec_relocs
		= _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
					     info->keep_memory);
d4136 1
a4136 1
		return FALSE;
d4159 1
a4159 1
	      return TRUE;
d4175 1
a4175 1
	      n = bfd_zalloc (abfd, amt);
d4177 1
a4177 1
		return FALSE;
d4198 1
a4198 1
	  mips_elf_hash_table (info)->mips16_stubs_seen = TRUE;
d4223 1
a4223 1
	  return TRUE;
d4247 1
a4247 1
	  return TRUE;
d4251 1
a4251 1
      mips_elf_hash_table (info)->mips16_stubs_seen = TRUE;
d4261 1
a4261 1
      sgot = mips_elf_got_section (dynobj, FALSE);
d4266 2
a4267 2
	  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
	  g = mips_elf_section_data (sgot)->u.got_info;
d4292 1
a4292 1
	  return FALSE;
d4322 2
a4323 2
	      if (! mips_elf_create_got_section (dynobj, info, FALSE))
		return FALSE;
d4351 8
a4358 4
	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.  */
	  if (! mips_elf_record_local_got_symbol (abfd, r_symndx,
						  rel->r_addend, g))
	    return FALSE;
d4370 1
a4370 1
	      return FALSE;
d4379 2
a4380 2
	      if (! mips_elf_record_global_got_symbol (h, abfd, info, g))
		return FALSE;
a4389 38
	case R_MIPS_GOT_PAGE:
	  /* If this is a global, overridable symbol, GOT_PAGE will
	     decay to GOT_DISP, so we'll need a GOT entry for it.  */
	  if (h == NULL)
	    break;
	  else
	    {
	      struct mips_elf_link_hash_entry *hmips =
		(struct mips_elf_link_hash_entry *) h;

	      while (hmips->root.root.type == bfd_link_hash_indirect
		     || hmips->root.root.type == bfd_link_hash_warning)
		hmips = (struct mips_elf_link_hash_entry *)
		  hmips->root.root.u.i.link;

	      if ((hmips->root.root.type == bfd_link_hash_defined
		   || hmips->root.root.type == bfd_link_hash_defweak)
		  && hmips->root.root.u.def.section
		  && ! (info->shared && ! info->symbolic
			&& ! (hmips->root.elf_link_hash_flags
			      & ELF_LINK_FORCED_LOCAL))
		  /* If we've encountered any other relocation
		     referencing the symbol, we'll have marked it as
		     dynamic, and, even though we might be able to get
		     rid of the GOT entry should we know for sure all
		     previous relocations were GOT_PAGE ones, at this
		     point we can't tell, so just keep using the
		     symbol as dynamic.  This is very important in the
		     multi-got case, since we don't decide whether to
		     decay GOT_PAGE to GOT_DISP on a per-GOT basis: if
		     the symbol is dynamic, we'll need a GOT entry for
		     every GOT in which the symbol is referenced with
		     a GOT_PAGE relocation.  */
		  && hmips->root.dynindx == -1)
		break;
	    }
	  /* Fall through.  */

d4395 2
a4396 2
	  if (h && ! mips_elf_record_global_got_symbol (h, abfd, info, g))
	    return FALSE;
d4407 3
a4409 1
		  sreloc = mips_elf_rel_dyn_section (dynobj, TRUE);
d4411 14
a4424 1
		    return FALSE;
d4452 1
a4452 1
		    hmips->readonly_reloc = TRUE;
d4459 3
a4461 10
	      if (h != NULL)
		{
		  if (dynobj == NULL)
		    elf_hash_table (info)->dynobj = dynobj = abfd;
		  if (! mips_elf_create_got_section (dynobj, info, TRUE))
		    return FALSE;
		  g = mips_elf_got_info (dynobj, &sgot);
		  if (! mips_elf_record_global_got_symbol (h, abfd, info, g))
		    return FALSE;
		}
d4482 1
a4482 1
	    return FALSE;
d4489 1
a4489 1
	    return FALSE;
d4506 1
a4506 1
	      mh->no_fn_stub = TRUE;
a4511 1
	case R_MIPS_JALR:
d4530 1
a4530 1
	  mh->need_fn_stub = TRUE;
d4534 1
a4534 177
  return TRUE;
}

bfd_boolean
_bfd_mips_relax_section (bfd *abfd, asection *sec,
			 struct bfd_link_info *link_info,
			 bfd_boolean *again)
{
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Shdr *symtab_hdr;
  bfd_byte *contents = NULL;
  bfd_byte *free_contents = NULL;
  size_t extsymoff;
  bfd_boolean changed_contents = FALSE;
  bfd_vma sec_start = sec->output_section->vma + sec->output_offset;
  Elf_Internal_Sym *isymbuf = NULL;

  /* We are not currently changing any sizes, so only one pass.  */
  *again = FALSE;

  if (link_info->relocatable)
    return TRUE;

  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
					       link_info->keep_memory);
  if (internal_relocs == NULL)
    return TRUE;

  irelend = internal_relocs + sec->reloc_count
    * get_elf_backend_data (abfd)->s->int_rels_per_ext_rel;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      bfd_signed_vma sym_offset;
      unsigned int r_type;
      unsigned long r_symndx;
      asection *sym_sec;
      unsigned long instruction;

      /* Turn jalr into bgezal, and jr into beq, if they're marked
	 with a JALR relocation, that indicate where they jump to.
	 This saves some pipeline bubbles.  */
      r_type = ELF_R_TYPE (abfd, irel->r_info);
      if (r_type != R_MIPS_JALR)
	continue;

      r_symndx = ELF_R_SYM (abfd, irel->r_info);
      /* Compute the address of the jump target.  */
      if (r_symndx >= extsymoff)
	{
	  struct mips_elf_link_hash_entry *h
	    = ((struct mips_elf_link_hash_entry *)
	       elf_sym_hashes (abfd) [r_symndx - extsymoff]);

	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

	  /* If a symbol is undefined, or if it may be overridden,
	     skip it.  */
	  if (! ((h->root.root.type == bfd_link_hash_defined
		  || h->root.root.type == bfd_link_hash_defweak)
		 && h->root.root.u.def.section)
	      || (link_info->shared && ! link_info->symbolic
		  && ! (h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)))
	    continue;

	  sym_sec = h->root.root.u.def.section;
	  if (sym_sec->output_section)
	    symval = (h->root.root.u.def.value
		      + sym_sec->output_section->vma
		      + sym_sec->output_offset);
	  else
	    symval = h->root.root.u.def.value;
	}
      else
	{
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's symbols if we haven't done so already.  */
	  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto relax_return;
	    }

	  isym = isymbuf + r_symndx;
	  if (isym->st_shndx == SHN_UNDEF)
	    continue;
	  else if (isym->st_shndx == SHN_ABS)
	    sym_sec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    sym_sec = bfd_com_section_ptr;
	  else
	    sym_sec
	      = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = isym->st_value
	    + sym_sec->output_section->vma
	    + sym_sec->output_offset;
	}

      /* Compute branch offset, from delay slot of the jump to the
	 branch target.  */
      sym_offset = (symval + irel->r_addend)
	- (sec_start + irel->r_offset + 4);

      /* Branch offset must be properly aligned.  */
      if ((sym_offset & 3) != 0)
	continue;

      sym_offset >>= 2;

      /* Check that it's in range.  */
      if (sym_offset < -0x8000 || sym_offset >= 0x8000)
	continue;

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      contents = bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto relax_return;

	      free_contents = contents;
	      if (! bfd_get_section_contents (abfd, sec, contents,
					      0, sec->_raw_size))
		goto relax_return;
	    }
	}

      instruction = bfd_get_32 (abfd, contents + irel->r_offset);

      /* If it was jalr <reg>, turn it into bgezal $zero, <target>.  */
      if ((instruction & 0xfc1fffff) == 0x0000f809)
	instruction = 0x04110000;
      /* If it was jr <reg>, turn it into b <target>.  */
      else if ((instruction & 0xfc1fffff) == 0x00000008)
	instruction = 0x10000000;
      else
	continue;

      instruction |= (sym_offset & 0xffff);
      bfd_put_32 (abfd, instruction, contents + irel->r_offset);
      changed_contents = TRUE;
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (!changed_contents && !link_info->keep_memory)
        free (contents);
      else
        {
          /* Cache the section contents for elf_link_input_bfd.  */
          elf_section_data (sec)->this_hdr.contents = contents;
        }
    }
  return TRUE;

 relax_return:
  if (free_contents != NULL)
    free (free_contents);
  return FALSE;
d4543 4
a4546 3
bfd_boolean
_bfd_mips_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
				     struct elf_link_hash_entry *h)
d4569 1
a4569 1
  if (! info->relocatable
d4588 1
a4588 1
	return TRUE;
d4612 1
a4612 1
	  return TRUE;
d4621 1
a4621 1
      return TRUE;
d4633 1
a4633 1
      return TRUE;
d4639 1
a4639 1
  return TRUE;
d4646 4
a4649 3
bfd_boolean
_bfd_mips_elf_always_size_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
a4652 8
  bfd *dynobj;
  asection *s;
  struct mips_got_info *g;
  int i;
  bfd_size_type loadable_size = 0;
  bfd_size_type local_gotno;
  bfd *sub;

d4656 2
a4657 33
    bfd_set_section_size (output_bfd, ri, sizeof (Elf32_External_RegInfo));

  if (! (info->relocatable
	 || ! mips_elf_hash_table (info)->mips16_stubs_seen))
    mips_elf_link_hash_traverse (mips_elf_hash_table (info),
				 mips_elf_check_mips16_stubs, NULL);

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    /* Relocatable links don't have it.  */
    return TRUE;

  g = mips_elf_got_info (dynobj, &s);
  if (s == NULL)
    return TRUE;

  /* Calculate the total loadable size of the output.  That
     will give us the maximum number of GOT_PAGE entries
     required.  */
  for (sub = info->input_bfds; sub; sub = sub->link_next)
    {
      asection *subsection;

      for (subsection = sub->sections;
	   subsection;
	   subsection = subsection->next)
	{
	  if ((subsection->flags & SEC_ALLOC) == 0)
	    continue;
	  loadable_size += ((subsection->_raw_size + 0xf)
			    &~ (bfd_size_type) 0xf);
	}
    }
d4659 7
a4665 7
  /* There has to be a global GOT entry for every symbol with
     a dynamic symbol table index of DT_MIPS_GOTSYM or
     higher.  Therefore, it make sense to put those symbols
     that need GOT entries at the end of the symbol table.  We
     do that here.  */
  if (! mips_elf_sort_hash_table (info, 1))
    return FALSE;
d4667 1
a4667 27
  if (g->global_gotsym != NULL)
    i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
  else
    /* If there are no global symbols, or none requiring
       relocations, then GLOBAL_GOTSYM will be NULL.  */
    i = 0;

  /* In the worst case, we'll get one stub per dynamic symbol, plus
     one to account for the dummy entry at the end required by IRIX
     rld.  */
  loadable_size += MIPS_FUNCTION_STUB_SIZE * (i + 1);

  /* Assume there are two loadable segments consisting of
     contiguous sections.  Is 5 enough?  */
  local_gotno = (loadable_size >> 16) + 5;

  g->local_gotno += local_gotno;
  s->_raw_size += g->local_gotno * MIPS_ELF_GOT_SIZE (output_bfd);

  g->global_gotno = i;
  s->_raw_size += i * MIPS_ELF_GOT_SIZE (output_bfd);

  if (s->_raw_size > MIPS_ELF_GOT_MAX_SIZE (output_bfd)
      && ! mips_elf_multi_got (output_bfd, info, g, s, local_gotno))
    return FALSE;

  return TRUE;
d4672 4
a4675 3
bfd_boolean
_bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,
				     struct bfd_link_info *info)
d4679 2
a4680 1
  bfd_boolean reltext;
d4688 1
a4688 1
      if (info->executable)
d4702 1
a4702 1
  reltext = FALSE;
d4706 1
a4706 1
      bfd_boolean strip;
d4715 1
a4715 1
      strip = FALSE;
d4730 1
a4730 1
		strip = TRUE;
d4750 1
a4750 1
		reltext = TRUE;
a4755 8

	      /* If combreloc is enabled, elf_link_sort_relocs() will
		 sort relocations, but in a different way than we do,
		 and before we're done creating relocations.  Also, it
		 will move them around between input sections'
		 relocation's contents, so our sorting would be
		 broken, so don't let it run.  */
	      info->combreloc = 0;
d4760 4
a4763 8
	  /* _bfd_mips_elf_always_size_sections() has already done
	     most of the work, but some symbols may have been mapped
	     to versions that we must now resolve in the got_entries
	     hash tables.  */
	  struct mips_got_info *gg = mips_elf_got_info (dynobj, NULL);
	  struct mips_got_info *g = gg;
	  struct mips_elf_set_global_got_offset_arg set_got_offset_arg;
	  unsigned int needed_relocs = 0;
d4765 3
a4767 4
	  if (gg->next)
	    {
	      set_got_offset_arg.value = MIPS_ELF_GOT_SIZE (output_bfd);
	      set_got_offset_arg.info = info;
d4769 10
a4778 2
	      mips_elf_resolve_final_got_entries (gg);
	      for (g = gg->next; g && g->next != gg; g = g->next)
d4780 7
a4786 1
		  unsigned int save_assign;
d4788 19
a4806 1
		  mips_elf_resolve_final_got_entries (g);
d4808 8
a4815 25
		  /* Assign offsets to global GOT entries.  */
		  save_assign = g->assigned_gotno;
		  g->assigned_gotno = g->local_gotno;
		  set_got_offset_arg.g = g;
		  set_got_offset_arg.needed_relocs = 0;
		  htab_traverse (g->got_entries,
				 mips_elf_set_global_got_offset,
				 &set_got_offset_arg);
		  needed_relocs += set_got_offset_arg.needed_relocs;
		  BFD_ASSERT (g->assigned_gotno - g->local_gotno
			      <= g->global_gotno);

		  g->assigned_gotno = save_assign;
		  if (info->shared)
		    {
		      needed_relocs += g->local_gotno - g->assigned_gotno;
		      BFD_ASSERT (g->assigned_gotno == g->next->local_gotno
				  + g->next->global_gotno
				  + MIPS_RESERVED_GOTNO);
		    }
		}

	      if (needed_relocs)
		mips_elf_allocate_dynamic_relocations (dynobj, needed_relocs);
	    }
d4834 4
d4851 1
a4851 1
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
d4855 1
a4855 1
	  return FALSE;
d4871 1
a4871 1
	    return FALSE;
d4875 1
a4875 1
		return FALSE;
d4884 1
a4884 1
		return FALSE;
d4894 1
a4894 1
	    return FALSE;
d4898 1
a4898 1
	return FALSE;
d4900 1
a4900 1
      if (mips_elf_rel_dyn_section (dynobj, FALSE))
d4903 1
a4903 1
	    return FALSE;
d4906 1
a4906 1
	    return FALSE;
d4909 25
a4933 1
	    return FALSE;
d4937 1
a4937 1
	return FALSE;
d4940 1
a4940 1
	return FALSE;
d4945 1
a4945 1
	return FALSE;
d4950 1
a4950 1
	return FALSE;
d4955 1
a4955 1
	return FALSE;
d4959 1
a4959 1
	return FALSE;
d4962 1
a4962 1
	return FALSE;
d4965 1
a4965 1
	return FALSE;
d4968 1
a4968 1
	return FALSE;
d4971 1
a4971 1
	return FALSE;
d4975 1
a4975 1
	return FALSE;
d4981 5
a4985 1
	return FALSE;
d4988 1
a4988 1
  return TRUE;
d4993 11
a5003 6
bfd_boolean
_bfd_mips_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
				bfd *input_bfd, asection *input_section,
				bfd_byte *contents, Elf_Internal_Rela *relocs,
				Elf_Internal_Sym *local_syms,
				asection **local_sections)
d5008 2
a5009 2
  bfd_boolean use_saved_addend_p = FALSE;
  const struct elf_backend_data *bed;
d5018 2
a5019 2
      bfd_boolean require_jalx;
      /* TRUE if the relocation is a RELA relocation, rather than a
d5021 1
a5021 1
      bfd_boolean rela_relocation_p = TRUE;
d5023 1
a5023 1
      const char *msg;
d5034 1
a5034 1
	  howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, R_MIPS_32, FALSE);
d5044 1
a5044 4
					 NEWABI_P (input_bfd)
					 && (MIPS_RELOC_RELA_P
					     (input_bfd, input_section,
					      rel - relocs)));
d5063 1
a5063 1
	      rela_relocation_p = FALSE;
d5078 1
a5078 1
						      local_sections, FALSE)))
d5099 1
a5099 1
		    return FALSE;
d5102 1
a5102 1
		  lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, lo, FALSE);
d5107 1
a5107 1
		  l = _bfd_mips_elf_sign_extend (l, 16);
d5138 1
a5138 1
      if (info->relocatable)
d5152 1
a5152 1
	     that we're adjusting GP in this relocatable object.  */
d5155 1
a5155 1
					     FALSE))
d5243 2
a5244 2
						 contents, FALSE))
		return FALSE;
d5258 1
a5258 1
	use_saved_addend_p = TRUE;
d5260 1
a5260 1
	use_saved_addend_p = FALSE;
d5287 1
a5287 1
	  return FALSE;
d5298 1
a5298 1
		     (info, name, howto->name, 0,
d5300 1
a5300 1
		return FALSE;
d5369 1
a5369 1
	return FALSE;
d5372 1
a5372 1
  return TRUE;
d5379 4
a5382 2
mips_elf_irix6_finish_dynamic_symbol (bfd *abfd ATTRIBUTE_UNUSED,
				      const char *name, Elf_Internal_Sym *sym)
a5414 1
	  sym->st_other = STO_PROTECTED;
d5429 6
a5434 5
bfd_boolean
_bfd_mips_elf_finish_dynamic_symbol (bfd *output_bfd,
				     struct bfd_link_info *info,
				     struct elf_link_hash_entry *h,
				     Elf_Internal_Sym *sym)
d5439 2
a5440 1
  struct mips_got_info *g, *gg;
d5442 1
d5446 1
d5463 1
a5463 1
	return FALSE;
d5488 1
a5488 1
  sgot = mips_elf_got_section (dynobj, FALSE);
d5490 2
a5491 2
  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
  g = mips_elf_section_data (sgot)->u.got_info;
d5502 16
a5517 2
      value = sym->st_value;
      offset = mips_elf_global_got_index (dynobj, output_bfd, h);
d5521 13
a5533 52
  if (g->next && h->dynindx != -1)
    {
      struct mips_got_entry e, *p;
      bfd_vma entry;
      bfd_vma offset;

      gg = g;

      e.abfd = output_bfd;
      e.symndx = -1;
      e.d.h = (struct mips_elf_link_hash_entry *)h;

      for (g = g->next; g->next != gg; g = g->next)
	{
	  if (g->got_entries
	      && (p = (struct mips_got_entry *) htab_find (g->got_entries,
							   &e)))
	    {
	      offset = p->gotidx;
	      if (info->shared
		  || (elf_hash_table (info)->dynamic_sections_created
		      && p->d.h != NULL
		      && ((p->d.h->root.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
		      && ((p->d.h->root.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)))
		{
		  /* Create an R_MIPS_REL32 relocation for this entry.  Due to
		     the various compatibility problems, it's easier to mock
		     up an R_MIPS_32 or R_MIPS_64 relocation and leave
		     mips_elf_create_dynamic_relocation to calculate the
		     appropriate addend.  */
		  Elf_Internal_Rela rel[3];

		  memset (rel, 0, sizeof (rel));
		  if (ABI_64_P (output_bfd))
		    rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_64);
		  else
		    rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_32);
		  rel[0].r_offset = rel[1].r_offset = rel[2].r_offset = offset;

		  entry = 0;
		  if (! (mips_elf_create_dynamic_relocation
			 (output_bfd, info, rel,
			  e.d.h, NULL, sym->st_value, &entry, sgot)))
		    return FALSE;
		}
	      else
		entry = sym->st_value;
	      MIPS_ELF_PUT_WORD (output_bfd, entry, sgot->contents + offset);
	    }
	}
d5593 1
a5593 1
	  bfd_put_32 (output_bfd, 0, s->contents);
d5614 1
a5614 1
  return TRUE;
d5619 4
a5622 3
bfd_boolean
_bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,
				       struct bfd_link_info *info)
d5627 1
a5627 1
  struct mips_got_info *gg, *g;
d5633 1
a5633 1
  sgot = mips_elf_got_section (dynobj, FALSE);
d5635 1
a5635 1
    gg = g = NULL;
d5638 2
a5639 4
      BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
      gg = mips_elf_section_data (sgot)->u.got_info;
      BFD_ASSERT (gg != NULL);
      g = mips_elf_got_for_ibfd (gg, output_bfd);
d5658 1
a5658 1
	  bfd_boolean swap_out_p;
d5664 1
a5664 1
	  swap_out_p = TRUE;
d5669 1
a5669 1
	      s = mips_elf_rel_dyn_section (dynobj, FALSE);
d5682 7
d5702 21
d5729 1
a5729 1
	      swap_out_p = FALSE;
d5734 1
a5734 1
	      swap_out_p = FALSE;
d5755 1
a5755 1
	      if (gg->global_gotsym)
d5757 1
a5757 1
		  dyn.d_un.d_val = gg->global_gotsym->dynindx;
d5790 3
a5792 10
	    case DT_RELSZ:
	      /* Reduce DT_RELSZ to account for any relocations we
		 decided not to make.  This is for the n64 irix rld,
		 which doesn't seem to apply any relocations if there
		 are trailing null entries.  */
	      s = mips_elf_rel_dyn_section (dynobj, FALSE);
	      dyn.d_un.d_val = (s->reloc_count
				* (ABI_64_P (output_bfd)
				   ? sizeof (Elf64_Mips_External_Rel)
				   : sizeof (Elf32_External_Rel)));
d5796 1
a5796 1
	      swap_out_p = FALSE;
d5811 2
a5812 2
      MIPS_ELF_PUT_WORD (output_bfd, 0, sgot->contents);
      MIPS_ELF_PUT_WORD (output_bfd, 0x80000000,
d5820 4
a5823 5
  /* Generate dynamic relocations for the non-primary gots.  */
  if (gg != NULL && gg->next)
    {
      Elf_Internal_Rela rel[3];
      bfd_vma addend = 0;
d5825 3
a5827 2
      memset (rel, 0, sizeof (rel));
      rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_REL32);
d5829 4
a5832 3
      for (g = gg->next; g->next != gg; g = g->next)
	{
	  bfd_vma index = g->next->local_gotno + g->next->global_gotno;
d5834 2
a5835 4
	  MIPS_ELF_PUT_WORD (output_bfd, 0, sgot->contents
			     + index++ * MIPS_ELF_GOT_SIZE (output_bfd));
	  MIPS_ELF_PUT_WORD (output_bfd, 0x80000000, sgot->contents
			     + index++ * MIPS_ELF_GOT_SIZE (output_bfd));
d5837 3
a5839 2
	  if (! info->shared)
	    continue;
d5841 6
a5846 17
	  while (index < g->assigned_gotno)
	    {
	      rel[0].r_offset = rel[1].r_offset = rel[2].r_offset
		= index++ * MIPS_ELF_GOT_SIZE (output_bfd);
	      if (!(mips_elf_create_dynamic_relocation
		    (output_bfd, info, rel, NULL,
		     bfd_abs_section_ptr,
		     0, &addend, sgot)))
		return FALSE;
	      BFD_ASSERT (addend == 0);
	    }
	}
    }

  {
    asection *s;
    Elf32_compact_rel cpt;
d5882 1
a5882 4
    s = mips_elf_rel_dyn_section (dynobj, FALSE);

    if (s != NULL
	&& s->_raw_size > (bfd_vma)2 * MIPS_ELF_REL_SIZE (output_bfd))
d5884 1
a5884 1
	reldyn_sorting_bfd = output_bfd;
d5886 8
a5893 6
	if (ABI_64_P (output_bfd))
	  qsort ((Elf64_External_Rel *) s->contents + 1, s->reloc_count - 1,
		 sizeof (Elf64_Mips_External_Rel), sort_dynamic_relocs_64);
	else
	  qsort ((Elf32_External_Rel *) s->contents + 1, s->reloc_count - 1,
		 sizeof (Elf32_External_Rel), sort_dynamic_relocs);
d5895 5
d5902 1
a5902 1
  return TRUE;
d5905 3
d5909 4
a5912 4
/* Set ABFD's EF_MIPS_ARCH and EF_MIPS_MACH flags.  */

static void
mips_set_isa_flags (bfd *abfd)
d5914 5
a5918 1
  flagword val;
a5970 1
    case bfd_mach_mips7000:
d5991 1
a5991 5
      break;

    case bfd_mach_mipsisa32r2:
      val = E_MIPS_ARCH_32R2;
      break;
a5992 4
    case bfd_mach_mipsisa64r2:
      val = E_MIPS_ARCH_64R2;
      break;
    }
a5995 22
}


/* The final processing done just before writing out a MIPS ELF object
   file.  This gets the MIPS architecture right based on the machine
   number.  This is used by both the 32-bit and the 64-bit ABI.  */

void
_bfd_mips_elf_final_write_processing (bfd *abfd,
				      bfd_boolean linker ATTRIBUTE_UNUSED)
{
  unsigned int i;
  Elf_Internal_Shdr **hdrpp;
  const char *name;
  asection *sec;

  /* Keep the existing EF_MIPS_MACH and EF_MIPS_ARCH flags if the former
     is nonzero.  This is for compatibility with old objects, which used
     a combination of a 32-bit EF_MIPS_ARCH and a 64-bit EF_MIPS_MACH.  */
  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_MACH) == 0)
    mips_set_isa_flags (abfd);

d6069 2
a6070 1
_bfd_mips_elf_additional_program_headers (bfd *abfd)
d6097 3
a6099 3
bfd_boolean
_bfd_mips_elf_modify_segment_map (bfd *abfd,
				  struct bfd_link_info *info ATTRIBUTE_UNUSED)
d6116 1
a6116 1
	  m = bfd_zalloc (abfd, amt);
d6118 1
a6118 1
	    return FALSE;
d6138 1
a6138 1
     PT_MIPS_OPTIONS segment immediately following the program header
d6155 9
a6163 5
	  pm = &elf_tdata (abfd)->segment_map;
	  while (*pm != NULL
		 && ((*pm)->p_type == PT_PHDR
		     || (*pm)->p_type == PT_INTERP))
	    pm = &(*pm)->next;
d6170 1
a6170 1
	  options_segment->p_flags_valid = TRUE;
d6192 1
a6192 1
		  m = bfd_zalloc (abfd, amt);
d6194 1
a6194 1
		    return FALSE;
d6254 1
a6254 1
	  low = ~(bfd_vma) 0;
d6283 1
a6283 1
	  n = bfd_zalloc (abfd, amt);
d6285 1
a6285 1
	    return FALSE;
d6307 1
a6307 1
  return TRUE;
d6314 6
a6319 5
_bfd_mips_elf_gc_mark_hook (asection *sec,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED,
			    Elf_Internal_Rela *rel,
			    struct elf_link_hash_entry *h,
			    Elf_Internal_Sym *sym)
d6354 6
a6359 5
bfd_boolean
_bfd_mips_elf_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			     struct bfd_link_info *info ATTRIBUTE_UNUSED,
			     asection *sec ATTRIBUTE_UNUSED,
			     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
d6396 1
a6396 1
  return TRUE;
d6405 3
a6407 3
_bfd_mips_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
				    struct elf_link_hash_entry *dir,
				    struct elf_link_hash_entry *ind)
d6420 5
a6424 1
    dirmips->readonly_reloc = TRUE;
d6426 1
a6426 1
    dirmips->no_fn_stub = TRUE;
d6430 4
a6433 3
_bfd_mips_elf_hide_symbol (struct bfd_link_info *info,
			   struct elf_link_hash_entry *entry,
			   bfd_boolean force_local)
d6443 1
a6443 1
  h->forced_local = force_local;
d6446 2
a6447 4
  if (dynobj != NULL && force_local)
    {
      got = mips_elf_got_section (dynobj, FALSE);
      g = mips_elf_section_data (got)->u.got_info;
d6449 1
a6449 21
      if (g->next)
	{
	  struct mips_got_entry e;
	  struct mips_got_info *gg = g;

	  /* Since we're turning what used to be a global symbol into a
	     local one, bump up the number of local entries of each GOT
	     that had an entry for it.  This will automatically decrease
	     the number of global entries, since global_gotno is actually
	     the upper limit of global entries.  */
	  e.abfd = dynobj;
	  e.symndx = -1;
	  e.d.h = h;

	  for (g = g->next; g != gg; g = g->next)
	    if (htab_find (g->got_entries, &e))
	      {
		BFD_ASSERT (g->global_gotno > 0);
		g->local_gotno++;
		g->global_gotno--;
	      }
d6451 3
a6453 27
	  /* If this was a global symbol forced into the primary GOT, we
	     no longer need an entry for it.  We can't release the entry
	     at this point, but we must at least stop counting it as one
	     of the symbols that required a forced got entry.  */
	  if (h->root.got.offset == 2)
	    {
	      BFD_ASSERT (gg->assigned_gotno > 0);
	      gg->assigned_gotno--;
	    }
	}
      else if (g->global_gotno == 0 && g->global_gotsym == NULL)
	/* If we haven't got through GOT allocation yet, just bump up the
	   number of local entries, as this symbol won't be counted as
	   global.  */
	g->local_gotno++;
      else if (h->root.got.offset == 1)
	{
	  /* If we're past non-multi-GOT allocation and this symbol had
	     been marked for a global got entry, give it a local entry
	     instead.  */
	  BFD_ASSERT (g->global_gotno > 0);
	  g->local_gotno++;
	  g->global_gotno--;
	}
    }

  _bfd_elf_link_hash_hide_symbol (info, &h->root, force_local);
d6458 5
a6462 3
bfd_boolean
_bfd_mips_elf_discard_info (bfd *abfd, struct elf_reloc_cookie *cookie,
			    struct bfd_link_info *info)
d6465 1
a6465 1
  bfd_boolean ret = FALSE;
d6471 1
a6471 1
    return FALSE;
d6473 1
a6473 1
    return FALSE;
d6475 1
a6475 1
    return FALSE;
d6478 1
a6478 1
    return FALSE;
d6482 1
a6482 1
    return FALSE;
d6484 3
a6486 2
  cookie->rels = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
					    info->keep_memory);
d6490 1
a6490 1
      return FALSE;
d6496 1
a6496 1
  for (i = 0, skip = 0; i < o->_raw_size / PDR_SIZE; i ++)
d6498 1
a6498 1
      if (MNAME(abfd,_bfd_elf,reloc_symbol_deleted_p) (i * PDR_SIZE, cookie))
d6507 1
a6507 1
      mips_elf_section_data (o)->u.tdata = tdata;
d6509 1
a6509 1
      ret = TRUE;
d6520 3
a6522 2
bfd_boolean
_bfd_mips_elf_ignore_discarded_relocs (asection *sec)
d6525 2
a6526 2
    return TRUE;
  return FALSE;
d6529 5
a6533 3
bfd_boolean
_bfd_mips_elf_write_section (bfd *output_bfd, asection *sec,
			     bfd_byte *contents)
d6539 1
a6539 1
    return FALSE;
d6541 2
a6542 2
  if (mips_elf_section_data (sec)->u.tdata == NULL)
    return FALSE;
d6550 1
a6550 1
      if ((mips_elf_section_data (sec)->u.tdata)[i] == 1)
d6557 3
a6559 2
			    sec->output_offset, sec->_cooked_size);
  return TRUE;
d6571 10
a6580 6
bfd_boolean
_bfd_mips_elf_find_nearest_line (bfd *abfd, asection *section,
				 asymbol **symbols, bfd_vma offset,
				 const char **filename_ptr,
				 const char **functionname_ptr,
				 unsigned int *line_ptr)
d6587 1
a6587 1
    return TRUE;
d6591 2
a6592 1
				     line_ptr, ABI_64_P (abfd) ? 8 : 0,
d6594 1
a6594 1
    return TRUE;
d6620 1
a6620 1
	  fi = bfd_zalloc (abfd, amt);
d6624 1
a6624 1
	      return FALSE;
d6630 1
a6630 1
	      return FALSE;
d6635 1
a6635 1
	  fi->d.fdr = bfd_alloc (abfd, amt);
d6639 1
a6639 1
	      return FALSE;
d6647 1
a6647 1
	    (*swap->swap_fdr_in) (abfd, fraw_src, fdr_ptr);
d6664 1
a6664 1
	  return TRUE;
d6681 7
a6687 4
bfd_boolean
_bfd_mips_elf_set_section_contents (bfd *abfd, sec_ptr section,
				    const void *location,
				    file_ptr offset, bfd_size_type count)
d6696 1
a6696 1
	  section->used_by_bfd = bfd_zalloc (abfd, amt);
d6698 1
a6698 1
	    return FALSE;
d6700 1
a6700 1
      c = mips_elf_section_data (section)->u.tdata;
d6709 1
a6709 1
	  c = bfd_zalloc (abfd, size);
d6711 2
a6712 2
	    return FALSE;
	  mips_elf_section_data (section)->u.tdata = c;
d6715 1
a6715 1
      memcpy (c + offset, location, count);
d6726 8
a6733 7
_bfd_elf_mips_get_relocated_section_contents
  (bfd *abfd,
   struct bfd_link_info *link_info,
   struct bfd_link_order *link_order,
   bfd_byte *data,
   bfd_boolean relocatable,
   asymbol **symbols)
d6746 1
a6746 1
  reloc_vector = bfd_malloc (reloc_size);
d6751 4
a6754 1
  if (!bfd_get_section_contents (input_bfd, input_section, data, 0,
d6760 1
a6760 1
  input_section->reloc_done = TRUE;
d6785 1
a6785 1
	    h = bfd_hash_lookup (&link_info->hash->table, "_gp", FALSE, FALSE);
d6817 2
a6818 1
      for (parent = reloc_vector; *parent != NULL; parent++)
d6820 1
a6820 1
	  char *error_message = NULL;
d6840 2
a6841 2
						 input_section, relocatable,
						 data, gp);
d6846 5
a6850 2
	  r = bfd_perform_relocation (input_bfd, *parent, data, input_section,
				      relocatable ? abfd : NULL,
d6854 1
a6854 1
	  if (relocatable)
d6871 1
a6871 1
			 TRUE)))
d6875 1
a6875 1
		  BFD_ASSERT (error_message != NULL);
d6910 2
a6911 1
_bfd_mips_elf_link_hash_table_create (bfd *abfd)
d6916 2
a6917 2
  ret = bfd_malloc (amt);
  if (ret == NULL)
d6934 1
a6934 1
  ret->use_rld_obj_head = FALSE;
d6936 1
a6936 1
  ret->mips16_stubs_seen = FALSE;
d6945 4
a6948 2
bfd_boolean
_bfd_mips_elf_final_link (bfd *abfd, struct bfd_link_info *info)
d6960 1
a6960 1
  void *mdebug_handle = NULL;
d6977 11
d7007 1
a7007 1
	return FALSE;
d7011 2
a7012 2
      got = mips_elf_got_section (dynobj, FALSE);
      g = mips_elf_section_data (got)->u.got_info;
d7055 1
a7055 1

d7066 3
a7068 2
      h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
      if (h != NULL && h->type == bfd_link_hash_defined)
d7072 1
a7072 1
      else if (info->relocatable)
d7077 1
a7077 1
	  for (o = abfd->sections; o != NULL; o = o->next)
d7099 1
a7099 1
  for (o = abfd->sections; o != NULL; o = o->next)
d7108 3
a7110 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d7133 4
a7136 2
					      &ext, 0, sizeof ext))
		return FALSE;
d7160 1
a7160 1
	  o->link_order_head = NULL;
d7204 2
a7205 2
	  if (mdebug_handle == NULL)
	    return FALSE;
d7230 1
a7230 1
		return FALSE;
d7233 3
a7235 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d7274 1
a7274 1
		return FALSE;
d7279 1
a7279 1
		return FALSE;
d7297 1
a7297 1
		  (*input_swap->swap_ext_in) (input_bfd, eraw_src, &ext);
d7305 1
a7305 1
						 name, FALSE, FALSE, TRUE);
d7350 1
a7350 1
		    return FALSE;
d7356 1
a7356 1
		return FALSE;
d7364 1
a7364 1
	  einfo.failed = FALSE;
d7366 2
a7367 1
				       mips_elf_output_extsym, &einfo);
d7369 1
a7369 1
	    return FALSE;
d7376 1
a7376 1
	  o->link_order_head = NULL;
d7393 1
a7393 1
	  if (! info->relocatable)
d7395 3
a7397 1
	      for (p = o->link_order_head; p != NULL; p = p->next)
d7417 1
a7417 1
	      o->link_order_head = NULL;
d7442 1
a7442 1
	      return FALSE;
d7464 1
a7464 1
	  tab = bfd_malloc (amt);
d7466 1
a7466 1
	    return FALSE;
d7471 3
a7473 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d7504 1
a7504 1
		  bfd_boolean exact;
d7508 3
a7510 2
			 (input_bfd, input_section, &ext_gptab, gpentry,
			  sizeof (Elf32_External_gptab))))
d7513 1
a7513 1
		      return FALSE;
d7521 1
a7521 1
		  exact = FALSE;
d7528 1
a7528 1
			exact = TRUE;
d7538 1
a7538 1
		      new_tab = bfd_realloc (tab, amt);
d7542 1
a7542 1
			  return FALSE;
d7581 1
a7581 1
	  ext_tab = bfd_alloc (abfd, amt);
d7585 1
a7585 1
	      return FALSE;
d7597 1
a7597 1
	  o->link_order_head = NULL;
d7602 12
a7613 2
  if (!MNAME(abfd,bfd_elf,bfd_final_link) (abfd, info))
    return FALSE;
d7617 1
a7617 1
  if (reginfo_sec != NULL)
d7622 4
a7625 2
      if (! bfd_set_section_contents (abfd, reginfo_sec, &ext, 0, sizeof ext))
	return FALSE;
d7628 1
a7628 1
  if (mdebug_sec != NULL)
d7634 1
a7634 1
	return FALSE;
d7639 1
a7639 1
  if (gptab_data_sec != NULL)
d7643 3
a7645 2
				      0, gptab_data_sec->_raw_size))
	return FALSE;
d7648 1
a7648 1
  if (gptab_bss_sec != NULL)
d7652 3
a7654 2
				      0, gptab_bss_sec->_raw_size))
	return FALSE;
d7664 3
a7666 2
					  0, rtproc_sec->_raw_size))
	    return FALSE;
d7670 1
a7670 1
  return TRUE;
d7673 18
a7690 88
/* Structure for saying that BFD machine EXTENSION extends BASE.  */

struct mips_mach_extension {
  unsigned long extension, base;
};


/* An array describing how BFD machines relate to one another.  The entries
   are ordered topologically with MIPS I extensions listed last.  */

static const struct mips_mach_extension mips_mach_extensions[] = {
  /* MIPS64 extensions.  */
  { bfd_mach_mipsisa64r2, bfd_mach_mipsisa64 },
  { bfd_mach_mips_sb1, bfd_mach_mipsisa64 },

  /* MIPS V extensions.  */
  { bfd_mach_mipsisa64, bfd_mach_mips5 },

  /* R10000 extensions.  */
  { bfd_mach_mips12000, bfd_mach_mips10000 },

  /* R5000 extensions.  Note: the vr5500 ISA is an extension of the core
     vr5400 ISA, but doesn't include the multimedia stuff.  It seems
     better to allow vr5400 and vr5500 code to be merged anyway, since
     many libraries will just use the core ISA.  Perhaps we could add
     some sort of ASE flag if this ever proves a problem.  */
  { bfd_mach_mips5500, bfd_mach_mips5400 },
  { bfd_mach_mips5400, bfd_mach_mips5000 },

  /* MIPS IV extensions.  */
  { bfd_mach_mips5, bfd_mach_mips8000 },
  { bfd_mach_mips10000, bfd_mach_mips8000 },
  { bfd_mach_mips5000, bfd_mach_mips8000 },
  { bfd_mach_mips7000, bfd_mach_mips8000 },

  /* VR4100 extensions.  */
  { bfd_mach_mips4120, bfd_mach_mips4100 },
  { bfd_mach_mips4111, bfd_mach_mips4100 },

  /* MIPS III extensions.  */
  { bfd_mach_mips8000, bfd_mach_mips4000 },
  { bfd_mach_mips4650, bfd_mach_mips4000 },
  { bfd_mach_mips4600, bfd_mach_mips4000 },
  { bfd_mach_mips4400, bfd_mach_mips4000 },
  { bfd_mach_mips4300, bfd_mach_mips4000 },
  { bfd_mach_mips4100, bfd_mach_mips4000 },
  { bfd_mach_mips4010, bfd_mach_mips4000 },

  /* MIPS32 extensions.  */
  { bfd_mach_mipsisa32r2, bfd_mach_mipsisa32 },

  /* MIPS II extensions.  */
  { bfd_mach_mips4000, bfd_mach_mips6000 },
  { bfd_mach_mipsisa32, bfd_mach_mips6000 },

  /* MIPS I extensions.  */
  { bfd_mach_mips6000, bfd_mach_mips3000 },
  { bfd_mach_mips3900, bfd_mach_mips3000 }
};


/* Return true if bfd machine EXTENSION is an extension of machine BASE.  */

static bfd_boolean
mips_mach_extends_p (unsigned long base, unsigned long extension)
{
  size_t i;

  for (i = 0; extension != base && i < ARRAY_SIZE (mips_mach_extensions); i++)
    if (extension == mips_mach_extensions[i].extension)
      extension = mips_mach_extensions[i].base;

  return extension == base;
}


/* Return true if the given ELF header flags describe a 32-bit binary.  */

static bfd_boolean
mips_32bit_flags_p (flagword flags)
{
  return ((flags & EF_MIPS_32BITMODE) != 0
	  || (flags & EF_MIPS_ABI) == E_MIPS_ABI_O32
	  || (flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI32
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_1
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_2
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32R2);
a7692 1

d7696 4
a7699 2
bfd_boolean
_bfd_mips_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
d7703 2
a7704 2
  bfd_boolean ok;
  bfd_boolean null_input_bfd = TRUE;
d7709 1
a7709 6
    {
      (*_bfd_error_handler)
	(_("%s: endianness incompatible with that of the selected emulation"),
	 bfd_archive_filename (ibfd));
      return FALSE;
    }
d7713 1
a7713 9
    return TRUE;

  if (strcmp (bfd_get_target (ibfd), bfd_get_target (obfd)) != 0)
    {
      (*_bfd_error_handler)
	(_("%s: ABI is incompatible with that of the selected emulation"),
	 bfd_archive_filename (ibfd));
      return FALSE;
    }
d7721 1
a7721 1
      elf_flags_init (obfd) = TRUE;
d7731 1
a7731 1
	    return FALSE;
d7734 1
a7734 1
      return TRUE;
a7741 10
  /* Some IRIX 6 BSD-compatibility objects have this bit set.  It
     doesn't seem to matter.  */
  new_flags &= ~EF_MIPS_XGOT;
  old_flags &= ~EF_MIPS_XGOT;

  /* MIPSpro generates ucode info in n64 objects.  Again, we should
     just be able to ignore this.  */
  new_flags &= ~EF_MIPS_UCODE;
  old_flags &= ~EF_MIPS_UCODE;

d7743 1
a7743 1
    return TRUE;
d7759 1
a7759 1
	  null_input_bfd = FALSE;
d7764 1
a7764 1
    return TRUE;
d7766 1
a7766 1
  ok = TRUE;
d7768 1
a7768 2
  if (((new_flags & (EF_MIPS_PIC | EF_MIPS_CPIC)) != 0)
      != ((old_flags & (EF_MIPS_PIC | EF_MIPS_CPIC)) != 0))
d7770 2
d7773 1
a7773 1
	(_("%s: warning: linking PIC files with non-PIC files"),
d7775 1
a7775 1
      ok = TRUE;
d7778 1
a7778 10
  if (new_flags & (EF_MIPS_PIC | EF_MIPS_CPIC))
    elf_elfheader (obfd)->e_flags |= EF_MIPS_CPIC;
  if (! (new_flags & EF_MIPS_PIC))
    elf_elfheader (obfd)->e_flags &= ~EF_MIPS_PIC;

  new_flags &= ~ (EF_MIPS_PIC | EF_MIPS_CPIC);
  old_flags &= ~ (EF_MIPS_PIC | EF_MIPS_CPIC);

  /* Compare the ISAs.  */
  if (mips_32bit_flags_p (old_flags) != mips_32bit_flags_p (new_flags))
d7780 2
d7783 1
a7783 1
	(_("%s: linking 32-bit code with 64-bit code"),
d7785 1
a7785 1
      ok = FALSE;
d7787 45
a7831 19
  else if (!mips_mach_extends_p (bfd_get_mach (ibfd), bfd_get_mach (obfd)))
    {
      /* OBFD's ISA isn't the same as, or an extension of, IBFD's.  */
      if (mips_mach_extends_p (bfd_get_mach (obfd), bfd_get_mach (ibfd)))
	{
	  /* Copy the architecture info from IBFD to OBFD.  Also copy
	     the 32-bit flag (if set) so that we continue to recognise
	     OBFD as a 32-bit binary.  */
	  bfd_set_arch_info (obfd, bfd_get_arch_info (ibfd));
	  elf_elfheader (obfd)->e_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
	  elf_elfheader (obfd)->e_flags
	    |= new_flags & (EF_MIPS_ARCH | EF_MIPS_MACH | EF_MIPS_32BITMODE);

	  /* Copy across the ABI flags if OBFD doesn't use them
	     and if that was what caused us to treat IBFD as 32-bit.  */
	  if ((old_flags & EF_MIPS_ABI) == 0
	      && mips_32bit_flags_p (new_flags)
	      && !mips_32bit_flags_p (new_flags & ~EF_MIPS_ABI))
	    elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_ABI;
a7834 1
	  /* The ISAs aren't compatible.  */
d7836 1
a7836 1
	    (_("%s: linking %s module with previous %s modules"),
d7838 3
a7840 3
	     bfd_printable_name (ibfd),
	     bfd_printable_name (obfd));
	  ok = FALSE;
d7842 3
d7847 1
a7847 4
  new_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH | EF_MIPS_32BITMODE);
  old_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH | EF_MIPS_32BITMODE);

  /* Compare ABIs.  The 64-bit ABI does not use EF_MIPS_ABI.  But, it
d7863 1
a7863 1
	  ok = FALSE;
d7885 1
a7885 1
      ok = FALSE;
d7891 1
a7891 1
      return FALSE;
d7894 1
a7894 1
  return TRUE;
d7899 4
a7902 2
bfd_boolean
_bfd_mips_elf_set_private_flags (bfd *abfd, flagword flags)
d7908 2
a7909 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d7912 4
a7915 2
bfd_boolean
_bfd_mips_elf_print_private_bfd_data (bfd *abfd, void *ptr)
d7917 1
a7917 1
  FILE *file = ptr;
a7957 4
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32R2)
    fprintf (file, _(" [mips32r2]"));
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_64R2)
    fprintf (file, _(" [mips64r2]"));
d7974 1
a7974 1
  return TRUE;
a7975 11

struct bfd_elf_special_section const _bfd_mips_elf_special_sections[]=
{
  { ".sdata",  6, -2, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".sbss",   5, -2, SHT_NOBITS,     SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".lit4",   5,  0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".lit8",   5,  0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".ucode",  6,  0, SHT_MIPS_UCODE, 0 },
  { ".mdebug", 7,  0, SHT_MIPS_DEBUG, 0 },
  { NULL,      0,  0, 0,              0 }
};
@


1.24.2.3
log
@Merge from mainline.
@
text
@d1085 1
a1086 1
  bfd_reloc_status_type status;
d1102 7
a1108 1
  _bfd_mips_elf_sign_extend (val, 16);
d1119 2
a1120 5
      status = _bfd_relocate_contents (reloc_entry->howto, abfd, val,
				       (bfd_byte *) data
				       + reloc_entry->address);
      if (status != bfd_reloc_ok)
	return status;
d1127 2
a1128 198

  return bfd_reloc_ok;
}

/* Used to store a REL high-part relocation such as R_MIPS_HI16 or
   R_MIPS_GOT16.  REL is the relocation, INPUT_SECTION is the section
   that contains the relocation field and DATA points to the start of
   INPUT_SECTION.  */

struct mips_hi16
{
  struct mips_hi16 *next;
  bfd_byte *data;
  asection *input_section;
  arelent rel;
};

/* FIXME: This should not be a static variable.  */

static struct mips_hi16 *mips_hi16_list;

/* A howto special_function for REL *HI16 relocations.  We can only
   calculate the correct value once we've seen the partnering
   *LO16 relocation, so just save the information for later.

   The ABI requires that the *LO16 immediately follow the *HI16.
   However, as a GNU extension, we permit an arbitrary number of
   *HI16s to be associated with a single *LO16.  This significantly
   simplies the relocation handling in gcc.  */

bfd_reloc_status_type
_bfd_mips_elf_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			  asymbol *symbol ATTRIBUTE_UNUSED, void *data,
			  asection *input_section, bfd *output_bfd,
			  char **error_message ATTRIBUTE_UNUSED)
{
  struct mips_hi16 *n;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  n = bfd_malloc (sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;

  n->next = mips_hi16_list;
  n->data = data;
  n->input_section = input_section;
  n->rel = *reloc_entry;
  mips_hi16_list = n;

  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* A howto special_function for REL R_MIPS_GOT16 relocations.  This is just
   like any other 16-bit relocation when applied to global symbols, but is
   treated in the same as R_MIPS_HI16 when applied to local symbols.  */

bfd_reloc_status_type
_bfd_mips_elf_got16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			   void *data, asection *input_section,
			   bfd *output_bfd, char **error_message)
{
  if ((symbol->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
      || bfd_is_und_section (bfd_get_section (symbol))
      || bfd_is_com_section (bfd_get_section (symbol)))
    /* The relocation is against a global symbol.  */
    return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
					input_section, output_bfd,
					error_message);

  return _bfd_mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
				   input_section, output_bfd, error_message);
}

/* A howto special_function for REL *LO16 relocations.  The *LO16 itself
   is a straightforward 16 bit inplace relocation, but we must deal with
   any partnering high-part relocations as well.  */

bfd_reloc_status_type
_bfd_mips_elf_lo16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section,
			  bfd *output_bfd, char **error_message)
{
  bfd_vma vallo;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  vallo = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  while (mips_hi16_list != NULL)
    {
      bfd_reloc_status_type ret;
      struct mips_hi16 *hi;

      hi = mips_hi16_list;

      /* R_MIPS_GOT16 relocations are something of a special case.  We
	 want to install the addend in the same way as for a R_MIPS_HI16
	 relocation (with a rightshift of 16).  However, since GOT16
	 relocations can also be used with global symbols, their howto
	 has a rightshift of 0.  */
      if (hi->rel.howto->type == R_MIPS_GOT16)
	hi->rel.howto = MIPS_ELF_RTYPE_TO_HOWTO (abfd, R_MIPS_HI16, FALSE);

      /* VALLO is a signed 16-bit number.  Bias it by 0x8000 so that any
	 carry or borrow will induce a change of +1 or -1 in the high part.  */
      hi->rel.addend += (vallo + 0x8000) & 0xffff;

      /* R_MIPS_GNU_REL_HI16 relocations are relative to the address of the
	 lo16 relocation, not their own address.  If we're calculating the
	 final value, and hence subtracting the "PC", subtract the offset
	 of the lo16 relocation from here.  */
      if (output_bfd == NULL && hi->rel.howto->type == R_MIPS_GNU_REL_HI16)
	hi->rel.addend -= reloc_entry->address - hi->rel.address;

      ret = _bfd_mips_elf_generic_reloc (abfd, &hi->rel, symbol, hi->data,
					 hi->input_section, output_bfd,
					 error_message);
      if (ret != bfd_reloc_ok)
	return ret;

      mips_hi16_list = hi->next;
      free (hi);
    }

  return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				      input_section, output_bfd,
				      error_message);
}

/* A generic howto special_function.  This calculates and installs the
   relocation itself, thus avoiding the oft-discussed problems in
   bfd_perform_relocation and bfd_install_relocation.  */

bfd_reloc_status_type
_bfd_mips_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			     asymbol *symbol, void *data ATTRIBUTE_UNUSED,
			     asection *input_section, bfd *output_bfd,
			     char **error_message ATTRIBUTE_UNUSED)
{
  bfd_signed_vma val;
  bfd_reloc_status_type status;
  bfd_boolean relocatable;

  relocatable = (output_bfd != NULL);

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Build up the field adjustment in VAL.  */
  val = 0;
  if (!relocatable || (symbol->flags & BSF_SECTION_SYM) != 0)
    {
      /* Either we're calculating the final field value or we have a
	 relocation against a section symbol.  Add in the section's
	 offset or address.  */
      val += symbol->section->output_section->vma;
      val += symbol->section->output_offset;
    }

  if (!relocatable)
    {
      /* We're calculating the final field value.  Add in the symbol's value
	 and, if pc-relative, subtract the address of the field itself.  */
      val += symbol->value;
      if (reloc_entry->howto->pc_relative)
	{
	  val -= input_section->output_section->vma;
	  val -= input_section->output_offset;
	  val -= reloc_entry->address;
	}
    }

  /* VAL is now the final adjustment.  If we're keeping this relocation
     in the output file, and if the relocation uses a separate addend,
     we just need to add VAL to that addend.  Otherwise we need to add
     VAL to the relocation field itself.  */
  if (relocatable && !reloc_entry->howto->partial_inplace)
    reloc_entry->addend += val;
  else
    {
      /* Add in the separate addend, if any.  */
      val += reloc_entry->addend;

      /* Add VAL to the relocation field.  */
      status = _bfd_relocate_contents (reloc_entry->howto, abfd, val,
				       (bfd_byte *) data
				       + reloc_entry->address);
      if (status != bfd_reloc_ok)
	return status;
    }

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
d3206 1
a3206 1
      value = symbol + _bfd_mips_elf_sign_extend (addend, 18) - p;
d3229 1
a3229 1
	value = ((addend | ((p + 4) & 0xf0000000)) + symbol) >> 2;
d3231 1
a3231 1
	value = (_bfd_mips_elf_sign_extend (addend, 28) + symbol) >> 2;
d6070 1
a6133 2
	      else
		addend <<= howto->rightshift;
d6173 1
a6173 4
	  if (rela_relocation_p)
	    /* If this is a RELA relocation, just update the addend.  */
	    rel->r_addend = addend;
	  else
d6175 5
a6179 2
	      if (r_type == R_MIPS_HI16
		  || r_type == R_MIPS_GOT16
d6186 1
a6186 2
	      else
		addend >>= howto->rightshift;
d6188 12
a6199 3
	      /* We use the source mask, rather than the destination
		 mask because the place to which we are writing will be
		 source of the addend in the final link.  */
d6262 2
@


1.23
log
@	* elfxx-mips.c (_bfd_mips_elf_fake_sections): Don't emit unneeded
	empty relocation sections.
@
text
@d367 1
d3062 3
d3068 6
d5948 4
d5956 8
d7662 20
d7788 3
a7790 4
      if (! new_mach
	  || ! old_mach
	  || new_mach == old_mach
	  )
d7807 5
a7811 2
	      if (old_mach == 0 && new_mach != 0) 
		elf_elfheader (obfd)->e_flags |= new_mach;
@


1.22
log
@	* elf64-mips.c (mips_elf64_be_swap_reloca_out): Handle type2 and type3.
	(mips_elf64_final_gp): Don't make up gp value.
	* elfn32-mips.c (mips_elf_final_gp): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_final_link): Always create
	.MIPS.options/.options section.
@
text
@d3647 1
a3647 1
  if ((IRIX_COMPAT (abfd) != ict_irix5 && (IRIX_COMPAT (abfd) != ict_irix6))
@


1.22.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d3647 1
a3647 1
  if (! SGI_COMPAT (abfd) && ! NEWABI_P(abfd)
@


1.22.2.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a366 1
static boolean _bfd_mips_elf_mach_extends_p PARAMS ((flagword, flagword));
a1902 1
  struct bfd_link_hash_entry *bh;
d1922 1
a1922 1
  bh = NULL;
d1926 2
a1927 1
	  get_elf_backend_data (abfd)->collect, &bh)))
a1928 2

  h = (struct elf_link_hash_entry *) bh;
a2939 4
      outrel[1].r_info = ELF_R_INFO (output_bfd, (unsigned long) 0,
				     R_MIPS_NONE);
      outrel[2].r_info = ELF_R_INFO (output_bfd, (unsigned long) 0,
				     R_MIPS_NONE);
a3060 3
    case E_MIPS_MACH_4120:
      return bfd_mach_mips4120;

a3063 6
    case E_MIPS_MACH_5400:
      return bfd_mach_mips5400;

    case E_MIPS_MACH_5500:
      return bfd_mach_mips5500;

a3817 1
      struct bfd_link_hash_entry *bh;
d3820 1
a3820 1
      bh = NULL;
d3824 2
a3825 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a3826 2

      h = (struct elf_link_hash_entry *) bh;
a3881 1
  struct bfd_link_hash_entry *bh;
d3940 1
a3940 1
	  bh = NULL;
d3944 2
a3945 1
		  get_elf_backend_data (abfd)->collect, &bh)))
a3946 2

	  h = (struct elf_link_hash_entry *) bh;
d3982 20
a4001 11
      const char *name;

      name = SGI_COMPAT (abfd) ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING";
      bh = NULL;
      if (!(_bfd_generic_link_add_one_symbol
	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr,
	     (bfd_vma) 0, (const char *) NULL, false,
	     get_elf_backend_data (abfd)->collect, &bh)))
	return false;

      h = (struct elf_link_hash_entry *) bh;
d4018 20
a4037 9
	  name = SGI_COMPAT (abfd) ? "__rld_map" : "__RLD_MAP";
	  bh = NULL;
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, name, BSF_GLOBAL, s,
		 (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect, &bh)))
	    return false;

	  h = (struct elf_link_hash_entry *) bh;
a5937 4
    case bfd_mach_mips4120:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4120;
      break;

a5941 8
    case bfd_mach_mips5400:
      val = E_MIPS_ARCH_4 | E_MIPS_MACH_5400;
      break;

    case bfd_mach_mips5500:
      val = E_MIPS_ARCH_4 | E_MIPS_MACH_5500;
      break;

a7639 20
/* Return true if machine EXTENSION is an extension of machine BASE,
   meaning that it should be safe to link code for the two machines
   and set the output machine to EXTENSION.  EXTENSION and BASE are
   both submasks of EF_MIPS_MACH.  */

static boolean
_bfd_mips_elf_mach_extends_p (base, extension)
     flagword base, extension;
{
  /* The vr5500 ISA is an extension of the core vr5400 ISA, but doesn't
     include the multimedia stuff.  It seems better to allow vr5400
     and vr5500 code to be merged anyway, since many libraries will
     just use the core ISA.  Perhaps we could add some sort of ASE
     flag if this ever proves a problem.  */
  return (base == 0
	  || (base == E_MIPS_MACH_5400 && extension == E_MIPS_MACH_5500)
	  || (base == E_MIPS_MACH_4100 && extension == E_MIPS_MACH_4111)
	  || (base == E_MIPS_MACH_4100 && extension == E_MIPS_MACH_4120));
}

d7746 4
a7749 3
      if (new_mach == old_mach
	  || _bfd_mips_elf_mach_extends_p (new_mach, old_mach)
	  || _bfd_mips_elf_mach_extends_p (old_mach, new_mach))
d7766 2
a7767 5
	      if (_bfd_mips_elf_mach_extends_p (old_mach, new_mach))
		{
		  elf_elfheader (obfd)->e_flags &= ~EF_MIPS_MACH;
		  elf_elfheader (obfd)->e_flags |= new_mach;
		}
@


1.22.2.3
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d348 1
a348 1
	   boolean *, boolean));
d2009 1
a2009 1
			       require_jalxp, save_addend)
a2021 1
     boolean save_addend;
d2046 1
a2046 1
  boolean local_p, was_local_p;
a2073 1
  was_local_p = local_p;
d2461 4
a2464 13
      /* Only sign-extend the addend if it was extracted from the
	 instruction.  If the addend was separate, leave it alone,
	 otherwise we may lose significant bits.  */
      if (howto->partial_inplace)
	addend = mips_elf_sign_extend (addend, 16);
      value = symbol + addend - gp;
      /* If the symbol was local, any earlier relocatable links will
	 have adjusted its addend with the gp offset, so compensate
	 for that now.  Don't do it for symbols forced local in this
	 link, though, since they won't have had the gp offset applied
	 to them before.  */
      if (was_local_p)
	value += gp0;
d2497 1
a2497 3
      value = (addend + symbol + gp0 - gp);
      if (!save_addend)
	value &= howto->dst_mask;
d2944 1
a2944 3
				     ABI_64_P (output_bfd)
				     ? R_MIPS_64
				     : R_MIPS_NONE);
d5254 1
a5254 2
					     &name, &require_jalx,
					     use_saved_addend_p))
d6124 1
a6124 6
  if (NEWABI_P (abfd)
      /* On non-IRIX6 new abi, we'll have already created a segment
	 for this section, so don't create another.  I'm not sure this
	 is not also the case for IRIX 6, but I can't test it right
	 now.  */
      && IRIX_COMPAT (abfd) == ict_irix6)
@


1.22.2.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a42 20
#include "hashtab.h"

/* This structure is used to hold .got entries while estimating got
   sizes.  */
struct mips_got_entry
{
  /* The input bfd in which the symbol is defined.  */
  bfd *abfd;
  /* The index of the symbol, as stored in the relocation r_info.  If
     it's -1, the addend is a complete address into the
     executable/shared library.  */
  unsigned long symndx;
  /* The addend of the relocation that should be added to the symbol
     value.  */
  bfd_vma addend;
  /* The offset from the beginning of the .got section to the entry
     corresponding to this symbol+addend.  */
  unsigned long gotidx;
};

a56 2
  /* A hash table holding members of the got.  */
  struct htab *got_entries;
d91 1
a91 1
  bfd_boolean readonly_reloc;
d101 1
a101 1
  bfd_boolean no_fn_stub;
d109 1
a109 1
  bfd_boolean need_fn_stub;
d120 1
a120 1
  bfd_boolean forced_local;
d139 1
a139 1
  bfd_boolean use_rld_obj_head;
d143 1
a143 1
  bfd_boolean mips16_stubs_seen;
d154 1
a154 1
  bfd_boolean failed;
d282 1
a282 1
static bfd_boolean mips_elf_create_procedure_table
d285 1
a285 1
static bfd_boolean mips_elf_check_mips16_stubs
d303 1
a303 1
static bfd_boolean mips_elf_output_extsym
d316 1
a316 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, bfd_boolean));
d319 1
a319 1
static struct mips_got_entry *mips_elf_create_local_got_entry
d321 1
a321 1
static bfd_boolean mips_elf_sort_hash_table
d323 1
a323 1
static bfd_boolean mips_elf_sort_hash_table_f
d325 1
a325 1
static bfd_boolean mips_elf_record_global_got_symbol
d331 2
a332 2
static bfd_boolean mips_elf_local_relocation_p
  PARAMS ((bfd *, const Elf_Internal_Rela *, asection **, bfd_boolean));
d334 1
a334 1
static bfd_boolean mips_elf_overflow_p PARAMS ((bfd_vma, int));
d338 1
a338 1
static bfd_boolean mips_elf_create_compact_rel_section
d340 1
a340 1
static bfd_boolean mips_elf_create_got_section
d348 1
a348 1
	   bfd_boolean *, bfd_boolean));
d351 1
a351 1
static bfd_boolean mips_elf_perform_relocation
d354 2
a355 2
	   bfd_boolean));
static bfd_boolean mips_elf_stub_section_p
d359 1
a359 1
static bfd_boolean mips_elf_create_dynamic_relocation
d367 1
a367 3
static bfd_boolean _bfd_mips_elf_mach_extends_p PARAMS ((flagword, flagword));
static hashval_t mips_elf_got_entry_hash PARAMS ((const PTR));
static int mips_elf_got_entry_eq PARAMS ((const PTR, const PTR));
d439 1
a439 1
   ? (abort (), FALSE)							\
a445 17
/* Determine whether the internal relocation of index REL_IDX is REL
   (zero) or RELA (non-zero).  The assumption is that, if there are
   two relocation sections for this section, one of them is REL and
   the other is RELA.  If the index of the relocation we're testing is
   in range for the first relocation section, check that the external
   relocation size is that for RELA.  It is also assumed that, if
   rel_idx is not in range for the first section, and this first
   section contains REL relocs, then the relocation is in the second
   section, that is RELA.  */
#define MIPS_RELOC_RELA_P(abfd, sec, rel_idx)				\
  ((NUM_SHDR_ENTRIES (&elf_section_data (sec)->rel_hdr)			\
    * get_elf_backend_data (abfd)->s->int_rels_per_ext_rel		\
    > (bfd_vma)(rel_idx))						\
   == (elf_section_data (sec)->rel_hdr.sh_entsize			\
       == (ABI_64_P (abfd) ? sizeof (Elf64_External_Rela)		\
	   : sizeof (Elf32_External_Rela))))

a477 2
#define MNAME(bfd,pre,pos) \
  (ABI_64_P (bfd) ? CONCAT4 (pre,64,_,pos) : CONCAT4 (pre,32,_,pos))
a484 1
#define MNAME(bfd,pre,pos) CONCAT4 (pre,32,_,pos)
d543 1
a543 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d583 1
a583 1
      ret->readonly_reloc = FALSE;
d585 1
a585 1
      ret->no_fn_stub = FALSE;
d587 1
a587 1
      ret->need_fn_stub = FALSE;
d590 1
a590 1
      ret->forced_local = FALSE;
d599 1
a599 1
bfd_boolean
d656 1
a656 1
  return TRUE;
d683 1
a683 1
  return FALSE;
d712 1
a712 1
static bfd_boolean
d847 1
a847 1
  return TRUE;
d860 1
a860 1
  return FALSE;
d866 1
a866 1
static bfd_boolean
d913 1
a913 1
  return TRUE;
d923 1
a923 1
     bfd_boolean relocateable;
d1159 5
a1163 2
  Elf_Internal_Rela int_reloc1;
  Elf_Internal_Rela int_reloc2;
d1165 2
a1166 2
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg1, &int_reloc1);
  bfd_elf32_swap_reloc_in (reldyn_sorting_bfd, arg2, &int_reloc2);
d1168 1
a1168 1
  return ELF32_R_SYM (int_reloc1.r_info) - ELF32_R_SYM (int_reloc2.r_info);
d1185 1
a1185 1
static bfd_boolean
d1191 1
a1191 1
  bfd_boolean strip;
d1198 1
a1198 1
    strip = FALSE;
d1203 1
a1203 1
    strip = TRUE;
d1208 2
a1209 2
				   FALSE, FALSE) == NULL))
    strip = TRUE;
d1211 1
a1211 1
    strip = FALSE;
d1214 1
a1214 1
    return TRUE;
d1323 1
a1323 1
      bfd_boolean no_fn_stub = h->no_fn_stub;
d1358 2
a1359 2
      einfo->failed = TRUE;
      return FALSE;
d1362 1
a1362 1
  return TRUE;
a1377 26
/* Functions to manage the got entry hash table.  */
static hashval_t
mips_elf_got_entry_hash (entry_)
     const PTR entry_;
{
  const struct mips_got_entry *entry = (struct mips_got_entry *)entry_;

  return htab_hash_pointer (entry->abfd) + entry->symndx
#ifdef BFD64
    + (entry->addend >> 32)
#endif
    + entry->addend;
}

static int
mips_elf_got_entry_eq (entry1, entry2)
     const PTR entry1;
     const PTR entry2;
{
  const struct mips_got_entry *e1 = (struct mips_got_entry *)entry1;
  const struct mips_got_entry *e2 = (struct mips_got_entry *)entry2;

  return e1->abfd == e2->abfd && e1->symndx == e2->symndx
    && e1->addend == e2->addend;
}

d1422 1
a1422 1
  struct mips_got_entry *entry;
d1426 12
a1437 5
  entry = mips_elf_create_local_got_entry (abfd, g, sgot, value);
  if (entry)
    return entry->gotidx;
  else
    return MINUS_ONE;
d1483 4
a1486 2
  bfd_vma index;
  struct mips_got_entry *entry;
d1490 21
a1510 8
  entry = mips_elf_create_local_got_entry (abfd, g, sgot,
					   (value + 0x8000)
					   & (~(bfd_vma)0xffff));

  if (!entry)
    return MINUS_ONE;
  
  index = entry->gotidx;
d1513 4
a1516 1
    *offsetp = value - entry->addend;
d1529 1
a1529 1
     bfd_boolean external;
d1533 4
a1536 1
  struct mips_got_entry *entry;
d1549 22
a1570 5
  entry = mips_elf_create_local_got_entry (abfd, g, sgot, value);
  if (entry)
    return entry->gotidx;
  else
    return MINUS_ONE;
d1594 1
a1594 1
static struct mips_got_entry *
a1600 20
  struct mips_got_entry entry, **loc;

  entry.abfd = abfd;
  entry.symndx = (unsigned long)-1;
  entry.addend = value;

  loc = (struct mips_got_entry **) htab_find_slot (g->got_entries, &entry,
						   INSERT);
  if (*loc)
    return *loc;
      
  entry.gotidx = MIPS_ELF_GOT_SIZE (abfd) * g->assigned_gotno++;

  *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);

  if (! *loc)
    return NULL;
	      
  memcpy (*loc, &entry, sizeof entry);

a1602 1
      (*loc)->gotidx = (unsigned long)-1;
d1607 1
a1607 1
      return NULL;
d1611 3
a1613 3
		     (sgot->contents + entry.gotidx));

  return *loc;
d1623 1
a1623 1
static bfd_boolean
d1651 1
a1651 1
  return TRUE;
d1658 1
a1658 1
static bfd_boolean
d1672 1
a1672 1
    return TRUE;
d1682 1
a1682 1
  return TRUE;
d1689 1
a1689 1
static bfd_boolean
d1703 1
a1703 1
	  _bfd_mips_elf_hide_symbol (info, h, TRUE);
d1707 1
a1707 1
	return FALSE;
d1713 1
a1713 1
    return TRUE;
d1720 1
a1720 1
  return TRUE;
d1754 1
a1754 1
static bfd_boolean
d1760 1
a1760 1
     bfd_boolean check_forced;
d1772 1
a1772 1
    return TRUE;
d1774 1
a1774 1
    return TRUE;
d1787 1
a1787 1
	return TRUE;
d1790 1
a1790 1
  return FALSE;
d1811 1
a1811 1
static bfd_boolean
d1820 1
a1820 1
    return TRUE;
d1823 1
a1823 1
    return TRUE;
d1826 1
a1826 1
  return FALSE;
d1859 1
a1859 1
  return ((value + (((bfd_vma) 0x8000 << 32) | 0x80008000)) >> 48) & 0xffff;
d1868 1
a1868 1
static bfd_boolean
d1886 1
a1886 1
	return FALSE;
d1891 1
a1891 1
  return TRUE;
d1896 1
a1896 1
static bfd_boolean
d1910 1
a1910 1
    return TRUE;
d1919 1
a1919 1
    return FALSE;
d1927 1
a1927 1
	  (bfd_vma) 0, (const char *) NULL, FALSE,
d1929 1
a1929 1
    return FALSE;
d1938 1
a1938 1
    return FALSE;
d1946 1
a1946 1
    return FALSE;
a1949 5
  g->got_entries = htab_try_create (1, mips_elf_got_entry_hash,
				    mips_elf_got_entry_eq,
				    (htab_del) NULL);
  if (g->got_entries == NULL)
    return FALSE;
d1955 1
a1955 1
	return FALSE;
d1961 1
a1961 1
  return TRUE;
d2021 2
a2022 2
     bfd_boolean *require_jalxp;
     bfd_boolean save_addend;
d2045 1
a2045 1
  /* TRUE if the symbol referred to by this relocation is a local
d2047 3
a2049 3
  bfd_boolean local_p, was_local_p;
  /* TRUE if the symbol referred to by this relocation is "_gp_disp".  */
  bfd_boolean gp_disp_p = FALSE;
d2054 1
a2054 1
  /* TRUE if overflow occurred during the calculation of the
d2056 3
a2058 3
  bfd_boolean overflowed_p;
  /* TRUE if this relocation refers to a MIPS16 function.  */
  bfd_boolean target_is_16_bit_code_p = FALSE;
d2068 1
a2068 1
  overflowed_p = FALSE;
d2074 1
a2074 1
					 local_sections, FALSE);
d2141 1
a2141 1
	  gp_disp_p = TRUE;
d2262 1
a2262 1
					 local_sections, TRUE);
d2483 1
a2483 1
	  bfd_boolean forced;
d2489 1
a2489 1
						  local_sections, FALSE);
d2516 1
d2617 1
a2617 1
   relocation applies.  If REQUIRE_JALX is TRUE, then the opcode used
d2621 1
a2621 1
   Returns FALSE if anything goes wrong.  */
d2623 1
a2623 1
static bfd_boolean
d2633 1
a2633 1
     bfd_boolean require_jalx;
d2749 1
a2749 1
      bfd_boolean ok;
d2774 1
a2774 1
	  return FALSE;
d2789 1
a2789 1
  return TRUE;
d2792 1
a2792 1
/* Returns TRUE if SECTION is a MIPS16 stub section.  */
d2794 1
a2794 1
static bfd_boolean
d2832 1
a2832 1
static bfd_boolean
d2844 2
a2845 2
  Elf_Internal_Rela outrel[3];
  bfd_boolean skip;
d2858 1
a2858 1
  skip = FALSE;
d2886 1
a2886 1
	skip = TRUE;
d2891 1
a2891 1
    skip = TRUE;
d2900 1
a2900 1
    memset (outrel, 0, sizeof (Elf_Internal_Rela) * 3);
d2925 1
a2925 1
	      return FALSE;
d2984 4
a2987 3
    bfd_elf32_swap_reloc_out
      (output_bfd, &outrel[0],
       (sreloc->contents + sreloc->reloc_count * sizeof (Elf32_External_Rel)));
d3034 1
a3034 1
  return TRUE;
d3263 1
a3263 1
bfd_boolean
d3279 1
a3279 1
	return FALSE;
d3282 1
a3282 1
	return FALSE;
d3318 1
a3318 1
		return FALSE;
d3321 1
a3321 1
		return FALSE;
d3333 1
a3333 1
		return FALSE;
d3336 1
a3336 1
		return FALSE;
d3381 1
a3381 1
  return TRUE;
d3391 1
a3391 1
bfd_boolean
d3408 1
a3408 1
	return FALSE;
d3412 1
a3412 1
	return FALSE;
d3416 1
a3416 1
	return FALSE;
d3420 1
a3420 1
	return FALSE;
d3424 1
a3424 1
	return FALSE;
d3428 1
a3428 1
	return FALSE;
d3434 1
a3434 1
	return FALSE;
d3439 1
a3439 1
	return FALSE;
d3443 1
a3443 1
	return FALSE;
d3447 1
a3447 1
	return FALSE;
d3451 1
a3451 1
	return FALSE;
d3455 1
a3455 1
	return FALSE;
d3461 1
a3461 1
	return FALSE;
d3464 1
a3464 1
      return FALSE;
d3468 1
a3468 1
    return FALSE;
d3476 1
a3476 1
	return FALSE;
d3493 1
a3493 1
	return FALSE;
d3508 1
a3508 1
	return FALSE;
d3513 1
a3513 1
	  return FALSE;
d3550 1
a3550 1
  return TRUE;
d3557 1
a3557 1
bfd_boolean
d3560 1
a3560 1
     Elf_Internal_Shdr *hdr;
d3688 1
a3688 1
	return FALSE;
d3693 1
a3693 1
  return TRUE;
d3702 1
a3702 1
bfd_boolean
d3711 1
a3711 1
      return TRUE;
d3716 1
a3716 1
      return TRUE;
d3718 1
a3718 1
  return FALSE;
d3724 1
a3724 1
bfd_boolean
d3740 1
a3740 1
      return TRUE;
d3768 1
a3768 1
	    return FALSE;
d3773 1
a3773 1
	    return FALSE;
d3809 1
a3809 1
	    return FALSE;
d3814 1
a3814 1
	    return FALSE;
d3855 1
a3855 1
	      (bfd_vma) *valp, (const char *) NULL, FALSE,
d3857 1
a3857 1
	return FALSE;
d3865 1
a3865 1
	return FALSE;
d3867 1
a3867 1
      mips_elf_hash_table (info)->use_rld_obj_head = TRUE;
d3876 1
a3876 1
  return TRUE;
d3883 1
a3883 1
bfd_boolean
d3902 1
a3902 1
  return TRUE;
d3909 1
a3909 1
bfd_boolean
d3928 1
a3928 1
	return FALSE;
d3933 1
a3933 1
    return FALSE;
d3940 1
a3940 1
    return FALSE;
d3951 1
a3951 1
	return FALSE;
d3963 1
a3963 1
	return FALSE;
d3977 1
a3977 1
		  (bfd_vma) 0, (const char *) NULL, FALSE,
d3979 1
a3979 1
	    return FALSE;
d3987 1
a3987 1
	    return FALSE;
d3994 1
a3994 1
	    return FALSE;
d4023 1
a4023 1
	     (bfd_vma) 0, (const char *) NULL, FALSE,
d4025 1
a4025 1
	return FALSE;
d4033 1
a4033 1
	return FALSE;
d4048 1
a4048 1
		 (bfd_vma) 0, (const char *) NULL, FALSE,
d4050 1
a4050 1
	    return FALSE;
d4058 1
a4058 1
	    return FALSE;
d4062 1
a4062 1
  return TRUE;
d4068 1
a4068 1
bfd_boolean
d4088 1
a4088 1
    return TRUE;
d4131 1
a4131 1
	      sec_relocs = (MNAME(abfd,_bfd_elf,link_read_relocs)
d4136 1
a4136 1
		return FALSE;
d4159 1
a4159 1
	      return TRUE;
d4177 1
a4177 1
		return FALSE;
d4198 1
a4198 1
	  mips_elf_hash_table (info)->mips16_stubs_seen = TRUE;
d4223 1
a4223 1
	  return TRUE;
d4247 1
a4247 1
	  return TRUE;
d4251 1
a4251 1
      mips_elf_hash_table (info)->mips16_stubs_seen = TRUE;
d4292 1
a4292 1
	  return FALSE;
d4323 1
a4323 1
		return FALSE;
a4344 2
	  struct mips_got_entry entry, **loc;

d4351 1
a4351 13
	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.  */

	  entry.abfd = abfd;
	  entry.symndx = r_symndx;
	  entry.addend = rel->r_addend;
	  loc = (struct mips_got_entry **)
	    htab_find_slot (g->got_entries, &entry, INSERT);

	  if (*loc == NULL)
	    {
	      entry.gotidx = g->local_gotno++;

	      *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);
d4353 6
a4358 7
	      if (! *loc)
		return FALSE;
	      
	      memcpy (*loc, &entry, sizeof entry);

	      sgot->_raw_size += MIPS_ELF_GOT_SIZE (dynobj);
	    }
d4370 1
a4370 1
	      return FALSE;
d4380 1
a4380 1
		return FALSE;
d4396 1
a4396 1
	    return FALSE;
d4423 1
a4423 1
			return FALSE;
d4452 1
a4452 1
		    hmips->readonly_reloc = TRUE;
d4461 1
a4461 1
		return FALSE;
d4482 1
a4482 1
	    return FALSE;
d4489 1
a4489 1
	    return FALSE;
d4506 1
a4506 1
	      mh->no_fn_stub = TRUE;
d4530 1
a4530 1
	  mh->need_fn_stub = TRUE;
d4534 1
a4534 1
  return TRUE;
d4543 1
a4543 1
bfd_boolean
d4588 1
a4588 1
	return TRUE;
d4612 1
a4612 1
	  return TRUE;
d4621 1
a4621 1
      return TRUE;
d4633 1
a4633 1
      return TRUE;
d4639 1
a4639 1
  return TRUE;
d4646 1
a4646 1
bfd_boolean
d4661 1
a4661 1
    return TRUE;
d4667 1
a4667 1
  return TRUE;
d4672 1
a4672 1
bfd_boolean
d4679 1
a4679 1
  bfd_boolean reltext;
d4702 1
a4702 1
  reltext = FALSE;
d4706 1
a4706 1
      bfd_boolean strip;
d4715 1
a4715 1
      strip = FALSE;
d4730 1
a4730 1
		strip = TRUE;
d4750 1
a4750 1
		reltext = TRUE;
d4791 5
d4806 1
a4806 1
 	    return FALSE;
d4855 1
a4855 1
	  return FALSE;
d4871 1
a4871 1
	    return FALSE;
d4875 1
a4875 1
		return FALSE;
d4884 1
a4884 1
		return FALSE;
d4894 1
a4894 1
	    return FALSE;
d4898 1
a4898 1
	return FALSE;
d4903 1
a4903 1
	    return FALSE;
d4906 1
a4906 1
	    return FALSE;
d4909 1
a4909 1
	    return FALSE;
d4915 1
a4915 1
	    return FALSE;
d4921 1
a4921 1
	    return FALSE;
d4927 1
a4927 1
	    return FALSE;
d4933 1
a4933 1
	    return FALSE;
d4937 1
a4937 1
	return FALSE;
d4940 1
a4940 1
	return FALSE;
d4945 1
a4945 1
	return FALSE;
d4950 1
a4950 1
	return FALSE;
d4955 1
a4955 1
	return FALSE;
d4959 1
a4959 1
	return FALSE;
d4962 1
a4962 1
	return FALSE;
d4965 1
a4965 1
	return FALSE;
d4968 1
a4968 1
	return FALSE;
d4971 1
a4971 1
	return FALSE;
d4975 1
a4975 1
	return FALSE;
d4981 1
a4981 1
	return FALSE;
d4985 1
a4985 1
	return FALSE;
d4988 1
a4988 1
  return TRUE;
d4993 1
a4993 1
bfd_boolean
d5008 1
a5008 1
  bfd_boolean use_saved_addend_p = FALSE;
d5018 2
a5019 2
      bfd_boolean require_jalx;
      /* TRUE if the relocation is a RELA relocation, rather than a
d5021 1
a5021 1
      bfd_boolean rela_relocation_p = TRUE;
d5034 1
a5034 1
	  howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, R_MIPS_32, FALSE);
d5044 1
a5044 4
					 NEWABI_P (input_bfd)
					 && (MIPS_RELOC_RELA_P
					     (input_bfd, input_section,
					      rel - relocs)));
d5063 1
a5063 1
	      rela_relocation_p = FALSE;
d5078 1
a5078 1
						      local_sections, FALSE)))
d5099 1
a5099 1
		    return FALSE;
d5102 1
a5102 1
		  lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, lo, FALSE);
d5155 1
a5155 1
					     FALSE))
d5243 2
a5244 2
						 contents, FALSE))
		return FALSE;
d5258 1
a5258 1
	use_saved_addend_p = TRUE;
d5260 1
a5260 1
	use_saved_addend_p = FALSE;
d5287 1
a5287 1
	  return FALSE;
d5300 1
a5300 1
		return FALSE;
d5369 1
a5369 1
	return FALSE;
d5372 1
a5372 1
  return TRUE;
d5429 1
a5429 1
bfd_boolean
d5463 1
a5463 1
	return FALSE;
d5614 1
a5614 1
  return TRUE;
d5619 1
a5619 1
bfd_boolean
d5658 1
a5658 1
	  bfd_boolean swap_out_p;
d5664 1
a5664 1
	  swap_out_p = TRUE;
d5729 1
a5729 1
	      swap_out_p = FALSE;
d5734 1
a5734 1
	      swap_out_p = FALSE;
d5796 1
a5796 1
	      swap_out_p = FALSE;
d5902 1
a5902 1
  return TRUE;
d5912 1
a5912 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d6097 1
a6097 1
bfd_boolean
d6118 1
a6118 1
	    return FALSE;
d6170 1
a6170 1
	  options_segment->p_flags_valid = TRUE;
d6194 1
a6194 1
		    return FALSE;
d6285 1
a6285 1
	    return FALSE;
d6307 1
a6307 1
  return TRUE;
d6354 1
a6354 1
bfd_boolean
d6396 1
a6396 1
  return TRUE;
d6420 1
a6420 1
    dirmips->readonly_reloc = TRUE;
d6426 1
a6426 1
    dirmips->no_fn_stub = TRUE;
d6433 1
a6433 1
     bfd_boolean force_local;
d6443 1
a6443 1
  h->forced_local = TRUE;
d6458 1
a6458 1
bfd_boolean
d6465 1
a6465 1
  bfd_boolean ret = FALSE;
d6471 1
a6471 1
    return FALSE;
d6473 1
a6473 1
    return FALSE;
d6475 1
a6475 1
    return FALSE;
d6478 1
a6478 1
    return FALSE;
d6482 1
a6482 1
    return FALSE;
d6484 3
a6486 4
  cookie->rels = (MNAME(abfd,_bfd_elf,link_read_relocs)
		  (abfd, o, (PTR) NULL,
		   (Elf_Internal_Rela *) NULL,
		   info->keep_memory));
d6490 1
a6490 1
      return FALSE;
d6498 1
a6498 1
      if (MNAME(abfd,_bfd_elf,reloc_symbol_deleted_p) (i * PDR_SIZE, cookie))
d6509 1
a6509 1
      ret = TRUE;
d6520 1
a6520 1
bfd_boolean
d6525 2
a6526 2
    return TRUE;
  return FALSE;
d6529 1
a6529 1
bfd_boolean
d6539 1
a6539 1
    return FALSE;
d6542 1
a6542 1
    return FALSE;
d6559 1
a6559 1
  return TRUE;
d6571 1
a6571 1
bfd_boolean
d6587 1
a6587 1
    return TRUE;
d6594 1
a6594 1
    return TRUE;
d6624 1
a6624 1
	      return FALSE;
d6630 1
a6630 1
	      return FALSE;
d6639 1
a6639 1
	      return FALSE;
d6664 1
a6664 1
	  return TRUE;
d6681 1
a6681 1
bfd_boolean
d6698 1
a6698 1
	    return FALSE;
d6711 1
a6711 1
	    return FALSE;
d6732 1
a6732 1
     bfd_boolean relocateable;
d6760 1
a6760 1
  input_section->reloc_done = TRUE;
d6785 1
a6785 1
	    h = bfd_hash_lookup (&link_info->hash->table, "_gp", FALSE, FALSE);
d6871 1
a6871 1
			 TRUE)))
d6934 1
a6934 1
  ret->use_rld_obj_head = FALSE;
d6936 1
a6936 1
  ret->mips16_stubs_seen = FALSE;
d6945 1
a6945 1
bfd_boolean
d7007 1
a7007 1
	return FALSE;
d7055 1
a7055 1

d7066 1
a7066 1
      h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d7136 1
a7136 1
		return FALSE;
d7205 1
a7205 1
	    return FALSE;
d7230 1
a7230 1
		return FALSE;
d7274 1
a7274 1
		return FALSE;
d7279 1
a7279 1
		return FALSE;
d7305 1
a7305 1
						 name, FALSE, FALSE, TRUE);
d7350 1
a7350 1
		    return FALSE;
d7356 1
a7356 1
		return FALSE;
d7364 1
a7364 1
	  einfo.failed = FALSE;
d7369 1
a7369 1
	    return FALSE;
d7442 1
a7442 1
	      return FALSE;
d7466 1
a7466 1
	    return FALSE;
d7504 1
a7504 1
		  bfd_boolean exact;
d7513 1
a7513 1
		      return FALSE;
d7521 1
a7521 1
		  exact = FALSE;
d7528 1
a7528 1
			exact = TRUE;
d7542 1
a7542 1
			  return FALSE;
d7585 1
a7585 1
	      return FALSE;
d7602 12
a7613 2
  if (!MNAME(abfd,bfd_elf,bfd_final_link) (abfd, info))
    return FALSE;
d7625 1
a7625 1
	return FALSE;
d7634 1
a7634 1
	return FALSE;
d7645 1
a7645 1
	return FALSE;
d7654 1
a7654 1
	return FALSE;
d7666 1
a7666 1
	    return FALSE;
d7670 1
a7670 1
  return TRUE;
d7673 1
a7673 1
/* Return TRUE if machine EXTENSION is an extension of machine BASE,
d7678 1
a7678 1
static bfd_boolean
d7696 1
a7696 1
bfd_boolean
d7703 2
a7704 2
  bfd_boolean ok;
  bfd_boolean null_input_bfd = TRUE;
d7709 1
a7709 1
    return FALSE;
d7713 1
a7713 1
    return TRUE;
d7721 1
a7721 1
      elf_flags_init (obfd) = TRUE;
d7731 1
a7731 1
	    return FALSE;
d7734 1
a7734 1
      return TRUE;
d7743 1
a7743 1
    return TRUE;
d7759 1
a7759 1
	  null_input_bfd = FALSE;
d7764 1
a7764 1
    return TRUE;
d7766 1
a7766 1
  ok = TRUE;
d7775 1
a7775 1
      ok = FALSE;
d7785 1
a7785 1
      ok = FALSE;
d7813 1
a7813 1
	      ok = FALSE;
d7840 1
a7840 1
	  ok = FALSE;
d7863 1
a7863 1
	  ok = FALSE;
d7885 1
a7885 1
      ok = FALSE;
d7891 1
a7891 1
      return FALSE;
d7894 1
a7894 1
  return TRUE;
d7899 1
a7899 1
bfd_boolean
d7908 2
a7909 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d7912 1
a7912 1
bfd_boolean
d7974 1
a7974 1
  return TRUE;
@


1.22.2.5
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
a32 1
#include "libiberty.h"
d51 7
a57 15
  /* The index of the symbol, as stored in the relocation r_info, if
     we have a local symbol; -1 otherwise.  */
  long symndx;
  union
  {
    /* If abfd == NULL, an address that must be stored in the got.  */
    bfd_vma address;
    /* If abfd != NULL && symndx != -1, the addend of the relocation
       that should be added to the symbol value.  */
    bfd_vma addend;
    /* If abfd != NULL && symndx == -1, the hash table entry
       corresponding to a global symbol in the got (or, local, if
       h->forced_local).  */
    struct mips_elf_link_hash_entry *h;
  } d;
d59 2
a60 3
     corresponding to this symbol+addend.  If it's a global symbol
     whose offset is yet to be decided, it's going to be -1.  */
  long gotidx;
d63 2
a64 1
/* This structure is used to hold .got information when linking.  */
a78 13
  /* A hash table mapping input bfds to other mips_got_info.  NULL
     unless multi-got was necessary.  */
  struct htab *bfd2got;
  /* In multi-got links, a pointer to the next got (err, rather, most
     of the time, it points to the previous got).  */
  struct mips_got_info *next;
};

/* Map an input bfd to a got in a multi-got link.  */

struct mips_elf_bfd2got_hash {
  bfd *bfd;
  struct mips_got_info *g;
a80 50
/* Structure passed when traversing the bfd2got hash table, used to
   create and merge bfd's gots.  */

struct mips_elf_got_per_bfd_arg
{
  /* A hashtable that maps bfds to gots.  */
  htab_t bfd2got;
  /* The output bfd.  */
  bfd *obfd;
  /* The link information.  */
  struct bfd_link_info *info;
  /* A pointer to the primary got, i.e., the one that's going to get
     the implicit relocations from DT_MIPS_LOCAL_GOTNO and
     DT_MIPS_GOTSYM.  */
  struct mips_got_info *primary;
  /* A non-primary got we're trying to merge with other input bfd's
     gots.  */
  struct mips_got_info *current;
  /* The maximum number of got entries that can be addressed with a
     16-bit offset.  */
  unsigned int max_count;
  /* The number of local and global entries in the primary got.  */
  unsigned int primary_count;
  /* The number of local and global entries in the current got.  */
  unsigned int current_count;
};

/* Another structure used to pass arguments for got entries traversal.  */

struct mips_elf_set_global_got_offset_arg
{
  struct mips_got_info *g;
  int value;
  unsigned int needed_relocs;
  struct bfd_link_info *info;
};

struct _mips_elf_section_data
{
  struct bfd_elf_section_data elf;
  union
  {
    struct mips_got_info *got_info;
    bfd_byte *tdata;
  } u;
};

#define mips_elf_section_data(sec) \
  ((struct _mips_elf_section_data *) elf_section_data (sec))

a91 5
  /* The greatest dynamic symbol table index corresponding to a symbol
     with a GOT entry that is not referenced (e.g., a dynamic symbol
     with dynamic relocations pointing to it from non-primary
     GOTs).  */
  long max_unref_got_dynindx;
a324 2
static int sort_dynamic_relocs_64
  PARAMS ((const void *, const void *));
d328 1
a328 2
static asection * mips_elf_rel_dyn_section PARAMS ((bfd *, bfd_boolean));
static asection * mips_elf_got_section PARAMS ((bfd *, bfd_boolean));
d332 1
a332 1
  PARAMS ((bfd *, bfd *, struct bfd_link_info *, bfd_vma));
d334 1
a334 1
  PARAMS ((bfd *, bfd *, struct elf_link_hash_entry *));
d336 1
a336 1
  PARAMS ((bfd *, bfd *, struct bfd_link_info *, bfd_vma, bfd_vma *));
d338 1
a338 1
  PARAMS ((bfd *, bfd *, struct bfd_link_info *, bfd_vma, bfd_boolean));
d340 1
a340 1
  PARAMS ((bfd *, bfd *, bfd *, bfd_vma));
d342 1
a342 1
  PARAMS ((bfd *, bfd *, struct mips_got_info *, asection *, bfd_vma));
a346 2
static bfd_boolean mips_elf_record_local_got_symbol
  PARAMS ((bfd *, long, bfd_vma, struct mips_got_info *));
d348 1
a348 1
  PARAMS ((struct elf_link_hash_entry *, bfd *, struct bfd_link_info *,
d363 1
a363 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean));
d385 1
a385 1
static void mips_set_isa_flags PARAMS ((bfd *));
d389 1
a389 3
static bfd_boolean mips_mach_extends_p PARAMS ((unsigned long, unsigned long));
static bfd_boolean mips_32bit_flags_p PARAMS ((flagword));
static INLINE hashval_t mips_elf_hash_bfd_vma PARAMS ((bfd_vma));
a392 18
static bfd_boolean mips_elf_multi_got
  PARAMS ((bfd *, struct bfd_link_info *, struct mips_got_info *,
	   asection *, bfd_size_type));
static hashval_t mips_elf_multi_got_entry_hash PARAMS ((const PTR));
static int mips_elf_multi_got_entry_eq PARAMS ((const PTR, const PTR));
static hashval_t mips_elf_bfd2got_entry_hash PARAMS ((const PTR));
static int mips_elf_bfd2got_entry_eq PARAMS ((const PTR, const PTR));
static int mips_elf_make_got_per_bfd PARAMS ((void **, void *));
static int mips_elf_merge_gots PARAMS ((void **, void *));
static int mips_elf_set_global_got_offset PARAMS ((void**, void *));
static int mips_elf_resolve_final_got_entry PARAMS ((void**, void *));
static void mips_elf_resolve_final_got_entries
  PARAMS ((struct mips_got_info *));
static bfd_vma mips_elf_adjust_gp
  PARAMS ((bfd *, struct mips_got_info *, bfd *));
static struct mips_got_info *mips_elf_got_for_ibfd
  PARAMS ((struct mips_got_info *, bfd *));

a493 7
/* The offset of $gp from the beginning of the .got section.  */
#define ELF_MIPS_GP_OFFSET(abfd) (0x7ff0)

/* The maximum size of the GOT for it to be addressable using 16-bit
   offsets from $gp.  */
#define MIPS_ELF_GOT_MAX_SIZE(abfd) (ELF_MIPS_GP_OFFSET(abfd) + 0x7fff)

d496 1
d498 5
a502 3
  ((ABI_64_P (abfd)  						\
    ? 0xdf998010		/* ld t9,0x8010(gp) */		\
    : 0x8f998010))              /* lw t9,0x8010(gp) */
a638 16

bfd_boolean
_bfd_mips_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
{
  struct _mips_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = (struct _mips_elf_section_data *) bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = (PTR) sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
}
a1211 20
/* Like sort_dynamic_relocs, but used for elf64 relocations.  */

static int
sort_dynamic_relocs_64 (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
{
  Elf_Internal_Rela int_reloc1[3];
  Elf_Internal_Rela int_reloc2[3];

  (*get_elf_backend_data (reldyn_sorting_bfd)->s->swap_reloc_in)
    (reldyn_sorting_bfd, arg1, int_reloc1);
  (*get_elf_backend_data (reldyn_sorting_bfd)->s->swap_reloc_in)
    (reldyn_sorting_bfd, arg2, int_reloc2);

  return (ELF64_R_SYM (int_reloc1[0].r_info)
	  - ELF64_R_SYM (int_reloc2[0].r_info));
}


a1419 19

/* Use all 64 bits of a bfd_vma for the computation of a 32-bit
   hash number.  */

static INLINE hashval_t
mips_elf_hash_bfd_vma (addr)
     bfd_vma addr;
{
#ifdef BFD64
  return addr + (addr >> 32);
#else
  return addr;
#endif
}

/* got_entries only match if they're identical, except for gotidx, so
   use all fields to compute the hash, and compare the appropriate
   union members.  */

d1426 5
a1430 5
  return entry->symndx
    + (! entry->abfd ? mips_elf_hash_bfd_vma (entry->d.address)
       : entry->abfd->id
         + (entry->symndx >= 0 ? mips_elf_hash_bfd_vma (entry->d.addend)
	    : entry->d.h->root.root.root.hash));
d1442 1
a1442 38
    && (! e1->abfd ? e1->d.address == e2->d.address
	: e1->symndx >= 0 ? e1->d.addend == e2->d.addend
	: e1->d.h == e2->d.h);
}

/* multi_got_entries are still a match in the case of global objects,
   even if the input bfd in which they're referenced differs, so the
   hash computation and compare functions are adjusted
   accordingly.  */

static hashval_t
mips_elf_multi_got_entry_hash (entry_)
     const PTR entry_;
{
  const struct mips_got_entry *entry = (struct mips_got_entry *)entry_;

  return entry->symndx
    + (! entry->abfd
       ? mips_elf_hash_bfd_vma (entry->d.address)
       : entry->symndx >= 0
       ? (entry->abfd->id
	  + mips_elf_hash_bfd_vma (entry->d.addend))
       : entry->d.h->root.root.root.hash);
}

static int
mips_elf_multi_got_entry_eq (entry1, entry2)
     const PTR entry1;
     const PTR entry2;
{
  const struct mips_got_entry *e1 = (struct mips_got_entry *)entry1;
  const struct mips_got_entry *e2 = (struct mips_got_entry *)entry2;

  return e1->symndx == e2->symndx
    && (e1->symndx >= 0 ? e1->abfd == e2->abfd && e1->d.addend == e2->d.addend
	: e1->abfd == NULL || e2->abfd == NULL
	? e1->abfd == e2->abfd && e1->d.address == e2->d.address
	: e1->d.h == e2->d.h);
a1444 29
/* Returns the dynamic relocation section for DYNOBJ.  */

static asection *
mips_elf_rel_dyn_section (dynobj, create_p)
     bfd *dynobj;
     bfd_boolean create_p;
{
  static const char dname[] = ".rel.dyn";
  asection *sreloc;

  sreloc = bfd_get_section_by_name (dynobj, dname);
  if (sreloc == NULL && create_p)
    {
      sreloc = bfd_make_section (dynobj, dname);
      if (sreloc == NULL
	  || ! bfd_set_section_flags (dynobj, sreloc,
				      (SEC_ALLOC
				       | SEC_LOAD
				       | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY
				       | SEC_LINKER_CREATED
				       | SEC_READONLY))
	  || ! bfd_set_section_alignment (dynobj, sreloc,
					  4))
	return NULL;
    }
  return sreloc;
}

d1448 1
a1448 1
mips_elf_got_section (abfd, maybe_excluded)
a1449 1
     bfd_boolean maybe_excluded;
d1451 1
a1451 5
  asection *sgot = bfd_get_section_by_name (abfd, ".got");
  if (sgot == NULL
      || (! maybe_excluded && (sgot->flags & SEC_EXCLUDE) != 0))
    return NULL;
  return sgot;
d1466 1
a1466 1
  sgot = mips_elf_got_section (abfd, TRUE);
d1468 2
a1469 2
  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
  g = mips_elf_section_data (sgot)->u.got_info;
d1473 1
a1473 2
    *sgotp = (sgot->flags & SEC_EXCLUDE) == 0 ? sgot : NULL;

d1482 2
a1483 2
mips_elf_local_got_index (abfd, ibfd, info, value)
     bfd *abfd, *ibfd;
d1493 1
a1493 1
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot, value);
d1503 2
a1504 2
mips_elf_global_got_index (abfd, ibfd, h)
     bfd *abfd, *ibfd;
d1509 1
a1509 1
  struct mips_got_info *g, *gg;
d1512 3
a1514 23
  gg = g = mips_elf_got_info (abfd, &sgot);
  if (g->bfd2got && ibfd)
    {
      struct mips_got_entry e, *p;
      
      BFD_ASSERT (h->dynindx >= 0);

      g = mips_elf_got_for_ibfd (g, ibfd);
      if (g->next != gg)
	{
	  e.abfd = ibfd;
	  e.symndx = -1;
	  e.d.h = (struct mips_elf_link_hash_entry *)h;

	  p = (struct mips_got_entry *) htab_find (g->got_entries, &e);

	  BFD_ASSERT (p->gotidx > 0);
	  return p->gotidx;
	}
    }

  if (gg->global_gotsym != NULL)
    global_got_dynindx = gg->global_gotsym->dynindx;
d1535 2
a1536 2
mips_elf_got_page (abfd, ibfd, info, value, offsetp)
     bfd *abfd, *ibfd;
d1548 1
a1548 1
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot,
d1558 1
a1558 1
    *offsetp = value - entry->d.address;
d1567 2
a1568 2
mips_elf_got16_entry (abfd, ibfd, info, value, external)
     bfd *abfd, *ibfd;
d1588 1
a1588 1
  entry = mips_elf_create_local_got_entry (abfd, ibfd, g, sgot, value);
d1599 1
a1599 1
mips_elf_got_offset_from_index (dynobj, output_bfd, input_bfd, index)
a1601 1
     bfd *input_bfd;
a1605 1
  struct mips_got_info *g;
d1607 4
a1610 5
  g = mips_elf_got_info (dynobj, &sgot);
  gp = _bfd_get_gp_value (output_bfd)
    + mips_elf_adjust_gp (output_bfd, g, input_bfd);
  
  return sgot->output_section->vma + sgot->output_offset + index - gp;
d1617 3
a1619 3
mips_elf_create_local_got_entry (abfd, ibfd, gg, sgot, value)
     bfd *abfd, *ibfd;
     struct mips_got_info *gg;
a1623 1
  struct mips_got_info *g;
d1625 3
a1627 10
  entry.abfd = NULL;
  entry.symndx = -1;
  entry.d.address = value;

  g = mips_elf_got_for_ibfd (gg, ibfd);
  if (g == NULL)
    {
      g = mips_elf_got_for_ibfd (gg, abfd);
      BFD_ASSERT (g != NULL);
    }
d1645 1
a1645 1
      (*loc)->gotidx = -1;
a1676 2
  g = mips_elf_got_info (dynobj, NULL);

d1678 1
a1678 10
  hsd.max_unref_got_dynindx = 
  hsd.min_got_dynindx = elf_hash_table (info)->dynsymcount
    /* In the multi-got case, assigned_gotno of the master got_info
       indicate the number of entries that aren't referenced in the
       primary GOT, but that must have entries because there are
       dynamic relocations that reference it.  Since they aren't
       referenced, we move them to the end of the GOT, so that they
       don't prevent other entries that are referenced from getting
       too large offsets.  */
    - (g->next ? g->assigned_gotno : 0);
a1687 2
  BFD_ASSERT ((unsigned long)hsd.max_unref_got_dynindx
	      <= elf_hash_table (info)->dynsymcount);
d1691 1
d1712 4
a1715 465
  /* Symbols without dynamic symbol table entries aren't interesting
     at all.  */
  if (h->root.dynindx == -1)
    return TRUE;

  /* Global symbols that need GOT entries that are not explicitly
     referenced are marked with got offset 2.  Those that are
     referenced get a 1, and those that don't need GOT entries get
     -1.  */
  if (h->root.got.offset == 2)
    {
      if (hsd->max_unref_got_dynindx == hsd->min_got_dynindx)
	hsd->low = (struct elf_link_hash_entry *) h;
      h->root.dynindx = hsd->max_unref_got_dynindx++;
    }
  else if (h->root.got.offset != 1)
    h->root.dynindx = hsd->max_non_got_dynindx++;
  else
    {
      h->root.dynindx = --hsd->min_got_dynindx;
      hsd->low = (struct elf_link_hash_entry *) h;
    }

  return TRUE;
}

/* If H is a symbol that needs a global GOT entry, but has a dynamic
   symbol table index lower than any we've seen to date, record it for
   posterity.  */

static bfd_boolean
mips_elf_record_global_got_symbol (h, abfd, info, g)
     struct elf_link_hash_entry *h;
     bfd *abfd;
     struct bfd_link_info *info;
     struct mips_got_info *g;
{
  struct mips_got_entry entry, **loc;

  /* A global symbol in the GOT must also be in the dynamic symbol
     table.  */
  if (h->dynindx == -1)
    {
      switch (ELF_ST_VISIBILITY (h->other))
	{
	case STV_INTERNAL:
	case STV_HIDDEN:
	  _bfd_mips_elf_hide_symbol (info, h, TRUE);
	  break;
	}
      if (!bfd_elf32_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  entry.abfd = abfd;
  entry.symndx = -1;
  entry.d.h = (struct mips_elf_link_hash_entry *) h;

  loc = (struct mips_got_entry **) htab_find_slot (g->got_entries, &entry,
						   INSERT);

  /* If we've already marked this entry as needing GOT space, we don't
     need to do it again.  */
  if (*loc)
    return TRUE;

  *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);

  if (! *loc)
    return FALSE;
	      
  entry.gotidx = -1;
  memcpy (*loc, &entry, sizeof entry);

  if (h->got.offset != MINUS_ONE)
    return TRUE;

  /* By setting this to a value other than -1, we are indicating that
     there needs to be a GOT entry for H.  Avoid using zero, as the
     generic ELF copy_indirect_symbol tests for <= 0.  */
  h->got.offset = 1;

  return TRUE;
}

/* Reserve space in G for a GOT entry containing the value of symbol
   SYMNDX in input bfd ABDF, plus ADDEND.  */

static bfd_boolean
mips_elf_record_local_got_symbol (abfd, symndx, addend, g)
     bfd *abfd;
     long symndx;
     bfd_vma addend;
     struct mips_got_info *g;
{
  struct mips_got_entry entry, **loc;

  entry.abfd = abfd;
  entry.symndx = symndx;
  entry.d.addend = addend;
  loc = (struct mips_got_entry **)
    htab_find_slot (g->got_entries, &entry, INSERT);

  if (*loc)
    return TRUE;

  entry.gotidx = g->local_gotno++;

  *loc = (struct mips_got_entry *)bfd_alloc (abfd, sizeof entry);

  if (! *loc)
    return FALSE;
	      
  memcpy (*loc, &entry, sizeof entry);

  return TRUE;
}

/* Compute the hash value of the bfd in a bfd2got hash entry.  */

static hashval_t
mips_elf_bfd2got_entry_hash (entry_)
     const PTR entry_;
{
  const struct mips_elf_bfd2got_hash *entry
    = (struct mips_elf_bfd2got_hash *)entry_;

  return entry->bfd->id;
}

/* Check whether two hash entries have the same bfd.  */

static int
mips_elf_bfd2got_entry_eq (entry1, entry2)
     const PTR entry1;
     const PTR entry2;
{
  const struct mips_elf_bfd2got_hash *e1
    = (const struct mips_elf_bfd2got_hash *)entry1;
  const struct mips_elf_bfd2got_hash *e2
    = (const struct mips_elf_bfd2got_hash *)entry2;

  return e1->bfd == e2->bfd;
}

/* In a multi-got link, determine the GOT to be used for IBDF.  G must
   be the master GOT data.  */

static struct mips_got_info *
mips_elf_got_for_ibfd (g, ibfd)
     struct mips_got_info *g;
     bfd *ibfd;
{
  struct mips_elf_bfd2got_hash e, *p;

  if (! g->bfd2got)
    return g;

  e.bfd = ibfd;
  p = (struct mips_elf_bfd2got_hash *) htab_find (g->bfd2got, &e);
  return p ? p->g : NULL;
}

/* Create one separate got for each bfd that has entries in the global
   got, such that we can tell how many local and global entries each
   bfd requires.  */

static int
mips_elf_make_got_per_bfd (entryp, p)
     void **entryp;
     void *p;
{
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  struct mips_elf_got_per_bfd_arg *arg = (struct mips_elf_got_per_bfd_arg *)p;
  htab_t bfd2got = arg->bfd2got;
  struct mips_got_info *g;
  struct mips_elf_bfd2got_hash bfdgot_entry, *bfdgot;
  void **bfdgotp;
  
  /* Find the got_info for this GOT entry's input bfd.  Create one if
     none exists.  */
  bfdgot_entry.bfd = entry->abfd;
  bfdgotp = htab_find_slot (bfd2got, &bfdgot_entry, INSERT);
  bfdgot = (struct mips_elf_bfd2got_hash *)*bfdgotp;

  if (bfdgot != NULL)
    g = bfdgot->g;
  else
    {
      bfdgot = (struct mips_elf_bfd2got_hash *)bfd_alloc
	(arg->obfd, sizeof (struct mips_elf_bfd2got_hash));

      if (bfdgot == NULL)
	{
	  arg->obfd = 0;
	  return 0;
	}

      *bfdgotp = bfdgot;

      bfdgot->bfd = entry->abfd;
      bfdgot->g = g = (struct mips_got_info *)
	bfd_alloc (arg->obfd, sizeof (struct mips_got_info));
      if (g == NULL)
	{
	  arg->obfd = 0;
	  return 0;
	}

      g->global_gotsym = NULL;
      g->global_gotno = 0;
      g->local_gotno = 0;
      g->assigned_gotno = -1;
      g->got_entries = htab_try_create (1, mips_elf_multi_got_entry_hash,
					mips_elf_multi_got_entry_eq,
					(htab_del) NULL);
      if (g->got_entries == NULL)
	{
	  arg->obfd = 0;
	  return 0;
	}

      g->bfd2got = NULL;
      g->next = NULL;
    }

  /* Insert the GOT entry in the bfd's got entry hash table.  */
  entryp = htab_find_slot (g->got_entries, entry, INSERT);
  if (*entryp != NULL)
    return 1;
  
  *entryp = entry;

  if (entry->symndx >= 0 || entry->d.h->forced_local)
    ++g->local_gotno;
  else
    ++g->global_gotno;

  return 1;
}

/* Attempt to merge gots of different input bfds.  Try to use as much
   as possible of the primary got, since it doesn't require explicit
   dynamic relocations, but don't use bfds that would reference global
   symbols out of the addressable range.  Failing the primary got,
   attempt to merge with the current got, or finish the current got
   and then make make the new got current.  */

static int
mips_elf_merge_gots (bfd2got_, p)
     void **bfd2got_;
     void *p;
{
  struct mips_elf_bfd2got_hash *bfd2got
    = (struct mips_elf_bfd2got_hash *)*bfd2got_;
  struct mips_elf_got_per_bfd_arg *arg = (struct mips_elf_got_per_bfd_arg *)p;
  unsigned int lcount = bfd2got->g->local_gotno;
  unsigned int gcount = bfd2got->g->global_gotno;
  unsigned int maxcnt = arg->max_count;
  
  /* If we don't have a primary GOT and this is not too big, use it as
     a starting point for the primary GOT.  */
  if (! arg->primary && lcount + gcount <= maxcnt)
    {
      arg->primary = bfd2got->g;
      arg->primary_count = lcount + gcount;
    }
  /* If it looks like we can merge this bfd's entries with those of
     the primary, merge them.  The heuristics is conservative, but we
     don't have to squeeze it too hard.  */
  else if (arg->primary
	   && (arg->primary_count + lcount + gcount) <= maxcnt)
    {
      struct mips_got_info *g = bfd2got->g;
      int old_lcount = arg->primary->local_gotno;
      int old_gcount = arg->primary->global_gotno;

      bfd2got->g = arg->primary;

      htab_traverse (g->got_entries,
		     mips_elf_make_got_per_bfd,
		     arg);
      if (arg->obfd == NULL)
	return 0;

      htab_delete (g->got_entries);
      /* We don't have to worry about releasing memory of the actual
	 got entries, since they're all in the master got_entries hash
	 table anyway.  */

      BFD_ASSERT (old_lcount + lcount == arg->primary->local_gotno);
      BFD_ASSERT (old_gcount + gcount >= arg->primary->global_gotno);

      arg->primary_count = arg->primary->local_gotno
	+ arg->primary->global_gotno;
    }
  /* If we can merge with the last-created got, do it.  */
  else if (arg->current
	   && arg->current_count + lcount + gcount <= maxcnt)
    {
      struct mips_got_info *g = bfd2got->g;
      int old_lcount = arg->current->local_gotno;
      int old_gcount = arg->current->global_gotno;

      bfd2got->g = arg->current;

      htab_traverse (g->got_entries,
		     mips_elf_make_got_per_bfd,
		     arg);
      if (arg->obfd == NULL)
	return 0;

      htab_delete (g->got_entries);

      BFD_ASSERT (old_lcount + lcount == arg->current->local_gotno);
      BFD_ASSERT (old_gcount + gcount >= arg->current->global_gotno);

      arg->current_count = arg->current->local_gotno
	+ arg->current->global_gotno;
    }
  /* Well, we couldn't merge, so create a new GOT.  Don't check if it
     fits; if it turns out that it doesn't, we'll get relocation
     overflows anyway.  */
  else
    {
      bfd2got->g->next = arg->current;
      arg->current = bfd2got->g;
      
      arg->current_count = lcount + gcount;
    }

  return 1;
}

/* If passed a NULL mips_got_info in the argument, set the marker used
   to tell whether a global symbol needs a got entry (in the primary
   got) to the given VALUE.

   If passed a pointer G to a mips_got_info in the argument (it must
   not be the primary GOT), compute the offset from the beginning of
   the (primary) GOT section to the entry in G corresponding to the
   global symbol.  G's assigned_gotno must contain the index of the
   first available global GOT entry in G.  VALUE must contain the size
   of a GOT entry in bytes.  For each global GOT entry that requires a
   dynamic relocation, NEEDED_RELOCS is incremented, and the symbol is
   marked as not elligible for lazy resolution through a function
   stub.  */
static int
mips_elf_set_global_got_offset (entryp, p)
     void **entryp;
     void *p;
{
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  struct mips_elf_set_global_got_offset_arg *arg
    = (struct mips_elf_set_global_got_offset_arg *)p;
  struct mips_got_info *g = arg->g;

  if (entry->abfd != NULL && entry->symndx == -1
      && entry->d.h->root.dynindx != -1)
    {
      if (g)
	{
	  BFD_ASSERT (g->global_gotsym == NULL);

	  entry->gotidx = arg->value * (long) g->assigned_gotno++;
	  /* We can't do lazy update of GOT entries for
	     non-primary GOTs since the PLT entries don't use the
	     right offsets, so punt at it for now.  */
	  entry->d.h->no_fn_stub = TRUE;
	  if (arg->info->shared
	      || (elf_hash_table (arg->info)->dynamic_sections_created
		  && ((entry->d.h->root.elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
		  && ((entry->d.h->root.elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_REGULAR) == 0)))
	    ++arg->needed_relocs;
	}
      else
	entry->d.h->root.got.offset = arg->value;
    }

  return 1;
}

/* Follow indirect and warning hash entries so that each got entry
   points to the final symbol definition.  P must point to a pointer
   to the hash table we're traversing.  Since this traversal may
   modify the hash table, we set this pointer to NULL to indicate
   we've made a potentially-destructive change to the hash table, so
   the traversal must be restarted.  */
static int
mips_elf_resolve_final_got_entry (entryp, p)
     void **entryp;
     void *p;
{
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;
  htab_t got_entries = *(htab_t *)p;

  if (entry->abfd != NULL && entry->symndx == -1)
    {
      struct mips_elf_link_hash_entry *h = entry->d.h;

      while (h->root.root.type == bfd_link_hash_indirect
 	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;

      if (entry->d.h == h)
	return 1;
      
      entry->d.h = h;

      /* If we can't find this entry with the new bfd hash, re-insert
	 it, and get the traversal restarted.  */
      if (! htab_find (got_entries, entry))
	{
	  htab_clear_slot (got_entries, entryp);
	  entryp = htab_find_slot (got_entries, entry, INSERT);
	  if (! *entryp)
	    *entryp = entry;
	  /* Abort the traversal, since the whole table may have
	     moved, and leave it up to the parent to restart the
	     process.  */
	  *(htab_t *)p = NULL;
	  return 0;
	}
      /* We might want to decrement the global_gotno count, but it's
	 either too early or too late for that at this point.  */
    }
  
  return 1;
}

/* Turn indirect got entries in a got_entries table into their final
   locations.  */
static void
mips_elf_resolve_final_got_entries (g)
     struct mips_got_info *g;
{
  htab_t got_entries;

  do
    {
      got_entries = g->got_entries;

      htab_traverse (got_entries,
		     mips_elf_resolve_final_got_entry,
		     &got_entries);
    }
  while (got_entries == NULL);
}

/* Return the offset of an input bfd IBFD's GOT from the beginning of
   the primary GOT.  */
static bfd_vma
mips_elf_adjust_gp (abfd, g, ibfd)
     bfd *abfd;
     struct mips_got_info *g;
     bfd *ibfd;
{
  if (g->bfd2got == NULL)
    return 0;

  g = mips_elf_got_for_ibfd (g, ibfd);
  if (! g)
    return 0;
d1717 7
a1723 1
  BFD_ASSERT (g->next);
d1725 1
a1725 3
  g = g->next;
  
  return (g->local_gotno + g->global_gotno) * MIPS_ELF_GOT_SIZE (abfd);
d1728 3
a1730 2
/* Turn a single GOT that is too big for 16-bit addressing into
   a sequence of GOTs, each one 16-bit addressable.  */
d1733 2
a1734 2
mips_elf_multi_got (abfd, info, g, got, pages)
     bfd *abfd;
d1736 1
a1736 3
     struct mips_got_info *g;
     asection *got;
     bfd_size_type pages;
d1738 3
a1740 40
  struct mips_elf_got_per_bfd_arg got_per_bfd_arg;
  struct mips_elf_set_global_got_offset_arg set_got_offset_arg;
  struct mips_got_info *gg;
  unsigned int assign;

  g->bfd2got = htab_try_create (1, mips_elf_bfd2got_entry_hash,
				mips_elf_bfd2got_entry_eq,
				(htab_del) NULL);
  if (g->bfd2got == NULL)
    return FALSE;

  got_per_bfd_arg.bfd2got = g->bfd2got;
  got_per_bfd_arg.obfd = abfd;
  got_per_bfd_arg.info = info;

  /* Count how many GOT entries each input bfd requires, creating a
     map from bfd to got info while at that.  */
  mips_elf_resolve_final_got_entries (g);
  htab_traverse (g->got_entries, mips_elf_make_got_per_bfd, &got_per_bfd_arg);
  if (got_per_bfd_arg.obfd == NULL)
    return FALSE;

  got_per_bfd_arg.current = NULL;
  got_per_bfd_arg.primary = NULL;
  /* Taking out PAGES entries is a worst-case estimate.  We could
     compute the maximum number of pages that each separate input bfd
     uses, but it's probably not worth it.  */
  got_per_bfd_arg.max_count = ((MIPS_ELF_GOT_MAX_SIZE (abfd)
				/ MIPS_ELF_GOT_SIZE (abfd))
			       - MIPS_RESERVED_GOTNO - pages);

  /* Try to merge the GOTs of input bfds together, as long as they
     don't seem to exceed the maximum GOT size, choosing one of them
     to be the primary GOT.  */
  htab_traverse (g->bfd2got, mips_elf_merge_gots, &got_per_bfd_arg);
  if (got_per_bfd_arg.obfd == NULL)
    return FALSE;

  /* If we find any suitable primary GOT, create an empty one.  */
  if (got_per_bfd_arg.primary == NULL)
d1742 8
a1749 13
      g->next = (struct mips_got_info *)
	bfd_alloc (abfd, sizeof (struct mips_got_info));
      if (g->next == NULL)
	return FALSE;

      g->next->global_gotsym = NULL;
      g->next->global_gotno = 0;
      g->next->local_gotno = 0;
      g->next->assigned_gotno = 0;
      g->next->got_entries = htab_try_create (1, mips_elf_multi_got_entry_hash,
					      mips_elf_multi_got_entry_eq,
					      (htab_del) NULL);
      if (g->next->got_entries == NULL)
a1750 1
      g->next->bfd2got = NULL;
a1751 3
  else
    g->next = got_per_bfd_arg.primary;
  g->next->next = got_per_bfd_arg.current;
d1753 4
a1756 15
  /* GG is now the master GOT, and G is the primary GOT.  */
  gg = g;
  g = g->next;

  /* Map the output bfd to the primary got.  That's what we're going
     to use for bfds that use GOT16 or GOT_PAGE relocations that we
     didn't mark in check_relocs, and we want a quick way to find it.
     We can't just use gg->next because we're going to reverse the
     list.  */
  {
    struct mips_elf_bfd2got_hash *bfdgot;
    void **bfdgotp;
  
    bfdgot = (struct mips_elf_bfd2got_hash *)bfd_alloc
      (abfd, sizeof (struct mips_elf_bfd2got_hash));
d1758 4
a1761 6
    if (bfdgot == NULL)
      return FALSE;

    bfdgot->bfd = abfd;
    bfdgot->g = g;
    bfdgotp = htab_find_slot (gg->bfd2got, bfdgot, INSERT);
a1762 89
    BFD_ASSERT (*bfdgotp == NULL);
    *bfdgotp = bfdgot;
  }

  /* The IRIX dynamic linker requires every symbol that is referenced
     in a dynamic relocation to be present in the primary GOT, so
     arrange for them to appear after those that are actually
     referenced.

     GNU/Linux could very well do without it, but it would slow down
     the dynamic linker, since it would have to resolve every dynamic
     symbol referenced in other GOTs more than once, without help from
     the cache.  Also, knowing that every external symbol has a GOT
     helps speed up the resolution of local symbols too, so GNU/Linux
     follows IRIX's practice.
     
     The number 2 is used by mips_elf_sort_hash_table_f to count
     global GOT symbols that are unreferenced in the primary GOT, with
     an initial dynamic index computed from gg->assigned_gotno, where
     the number of unreferenced global entries in the primary GOT is
     preserved.  */
  if (1)
    {
      gg->assigned_gotno = gg->global_gotno - g->global_gotno;
      g->global_gotno = gg->global_gotno;
      set_got_offset_arg.value = 2;
    }
  else
    {
      /* This could be used for dynamic linkers that don't optimize
	 symbol resolution while applying relocations so as to use
	 primary GOT entries or assuming the symbol is locally-defined.
	 With this code, we assign lower dynamic indices to global
	 symbols that are not referenced in the primary GOT, so that
	 their entries can be omitted.  */
      gg->assigned_gotno = 0;
      set_got_offset_arg.value = -1;
    }

  /* Reorder dynamic symbols as described above (which behavior
     depends on the setting of VALUE).  */
  set_got_offset_arg.g = NULL;
  htab_traverse (gg->got_entries, mips_elf_set_global_got_offset,
		 &set_got_offset_arg);
  set_got_offset_arg.value = 1;
  htab_traverse (g->got_entries, mips_elf_set_global_got_offset,
		 &set_got_offset_arg);
  if (! mips_elf_sort_hash_table (info, 1))
    return FALSE;

  /* Now go through the GOTs assigning them offset ranges.
     [assigned_gotno, local_gotno[ will be set to the range of local
     entries in each GOT.  We can then compute the end of a GOT by
     adding local_gotno to global_gotno.  We reverse the list and make
     it circular since then we'll be able to quickly compute the
     beginning of a GOT, by computing the end of its predecessor.  To
     avoid special cases for the primary GOT, while still preserving
     assertions that are valid for both single- and multi-got links,
     we arrange for the main got struct to have the right number of
     global entries, but set its local_gotno such that the initial
     offset of the primary GOT is zero.  Remember that the primary GOT
     will become the last item in the circular linked list, so it
     points back to the master GOT.  */
  gg->local_gotno = -g->global_gotno;
  gg->global_gotno = g->global_gotno;
  assign = 0;
  gg->next = gg;

  do
    {
      struct mips_got_info *gn;

      assign += MIPS_RESERVED_GOTNO;
      g->assigned_gotno = assign;
      g->local_gotno += assign + pages;
      assign = g->local_gotno + g->global_gotno;

      /* Take g out of the direct list, and push it onto the reversed
	 list that gg points to.  */
      gn = g->next;
      g->next = gg->next;
      gg->next = g;
      g = gn;
    }
  while (g);

  got->_raw_size = (gg->next->local_gotno
		    + gg->next->global_gotno) * MIPS_ELF_GOT_SIZE (abfd);
  
a1764 1
     
d1940 1
a1940 1
mips_elf_create_got_section (abfd, info, maybe_exclude)
a1942 1
     bfd_boolean maybe_exclude;
d1952 2
a1953 7
  s = mips_elf_got_section (abfd, TRUE);
  if (s)
    {
      if (! maybe_exclude)
	s->flags &= ~SEC_EXCLUDE;
      return TRUE;
    }
a1957 3
  if (maybe_exclude)
    flags |= SEC_EXCLUDE;

d1983 3
a1992 2
  g->bfd2got = NULL;
  g->next = NULL;
d1998 9
a2006 2
  mips_elf_section_data (s)->u.got_info = g;
  mips_elf_section_data (s)->elf.this_hdr.sh_flags
a2327 1
					 input_bfd,
d2338 1
a2338 1
	      asection *sgot = mips_elf_got_section (tmpbfd, FALSE);
d2348 1
a2348 2
	  g = mips_elf_local_got_index (abfd, input_bfd,
					info, symbol + addend);
d2355 1
a2355 1
					  abfd, input_bfd, g);
a2365 5
      if (elf_hash_table (info)->dynobj)
	gp += mips_elf_adjust_gp (abfd,
				  mips_elf_got_info
				  (elf_hash_table (info)->dynobj, NULL),
				  input_bfd);
d2538 1
a2538 2
	  value = mips_elf_got16_entry (abfd, input_bfd, info,
					symbol + addend, forced);
d2543 1
a2543 1
					      abfd, input_bfd, value);
d2582 1
a2582 1
      value = mips_elf_got_page (abfd, input_bfd, info, symbol + addend, NULL);
d2586 1
a2586 1
					      abfd, input_bfd, value);
d2591 1
a2591 1
      mips_elf_got_page (abfd, input_bfd, info, symbol + addend, &value);
d2862 1
a2862 1
  s = mips_elf_rel_dyn_section (abfd, FALSE);
d2899 1
a2899 1
  sreloc = mips_elf_rel_dyn_section (dynobj, FALSE);
d2937 1
a2937 2
  if (outrel[0].r_offset == (bfd_vma) -1
      || outrel[0].r_offset == (bfd_vma) -2)
d2939 3
d3083 26
a3174 4

	case E_MIPS_ARCH_32R2:
	  return bfd_mach_mipsisa32r2;
	  break;
d3333 2
a3334 2
      && mips_elf_section_data (hdr->bfd_section) != NULL
      && mips_elf_section_data (hdr->bfd_section)->u.tdata != NULL)
d3338 3
a3340 3
      /* We stored the section contents in the tdata field in the
	 set_section_contents routine.  We save the section contents
	 so that we don't have to read them again.
d3345 1
a3345 1
      contents = mips_elf_section_data (hdr->bfd_section)->u.tdata;
d3735 2
a3736 1
      _bfd_elf_init_reloc_shdr (abfd, esd->rel_hdr2, sec, !sec->use_rela_p);
d3978 1
a3978 4
  if (! mips_elf_create_got_section (abfd, info, FALSE))
    return FALSE;

  if (! mips_elf_rel_dyn_section (elf_hash_table (info)->dynobj, TRUE))
d4307 1
a4307 1
      sgot = mips_elf_got_section (dynobj, FALSE);
d4312 2
a4313 2
	  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
	  g = mips_elf_section_data (sgot)->u.got_info;
d4368 1
a4368 1
	      if (! mips_elf_create_got_section (dynobj, info, FALSE))
d4391 2
d4400 20
a4419 3
	  if (! mips_elf_record_local_got_symbol (abfd, r_symndx,
						  rel->r_addend, g))
	    return FALSE;
d4440 1
a4440 1
	      if (! mips_elf_record_global_got_symbol (h, abfd, info, g))
d4456 1
a4456 1
	  if (h && ! mips_elf_record_global_got_symbol (h, abfd, info, g))
d4468 3
a4470 1
		  sreloc = mips_elf_rel_dyn_section (dynobj, TRUE);
d4472 14
a4485 1
		    return FALSE;
d4520 3
a4522 10
	      if (h != NULL)
		{
		  if (dynobj == NULL)
		    elf_hash_table (info)->dynobj = dynobj = abfd;
		  if (! mips_elf_create_got_section (dynobj, info, TRUE))
		    return FALSE;
		  g = mips_elf_got_info (dynobj, &sgot);
		  if (! mips_elf_record_global_got_symbol (h, abfd, info, g))
		    return FALSE;
		}
a4713 8
  bfd *dynobj;
  asection *s;
  struct mips_got_info *g;
  int i;
  bfd_size_type loadable_size = 0;
  bfd_size_type local_gotno;
  bfd *sub;

d4720 2
a4721 13
  if (! (info->relocateable
	 || ! mips_elf_hash_table (info)->mips16_stubs_seen))
    mips_elf_link_hash_traverse (mips_elf_hash_table (info),
				 mips_elf_check_mips16_stubs,
				 (PTR) NULL);

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    /* Relocatable links don't have it.  */
    return TRUE;
  
  g = mips_elf_got_info (dynobj, &s);
  if (s == NULL)
d4724 3
a4726 51
  /* Calculate the total loadable size of the output.  That
     will give us the maximum number of GOT_PAGE entries
     required.  */
  for (sub = info->input_bfds; sub; sub = sub->link_next)
    {
      asection *subsection;

      for (subsection = sub->sections;
	   subsection;
	   subsection = subsection->next)
	{
	  if ((subsection->flags & SEC_ALLOC) == 0)
	    continue;
	  loadable_size += ((subsection->_raw_size + 0xf)
			    &~ (bfd_size_type) 0xf);
	}
    }

  /* There has to be a global GOT entry for every symbol with
     a dynamic symbol table index of DT_MIPS_GOTSYM or
     higher.  Therefore, it make sense to put those symbols
     that need GOT entries at the end of the symbol table.  We
     do that here.  */
  if (! mips_elf_sort_hash_table (info, 1))
    return FALSE;

  if (g->global_gotsym != NULL)
    i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
  else
    /* If there are no global symbols, or none requiring
       relocations, then GLOBAL_GOTSYM will be NULL.  */
    i = 0;

  /* In the worst case, we'll get one stub per dynamic symbol, plus
     one to account for the dummy entry at the end required by IRIX
     rld.  */
  loadable_size += MIPS_FUNCTION_STUB_SIZE * (i + 1);

  /* Assume there are two loadable segments consisting of
     contiguous sections.  Is 5 enough?  */
  local_gotno = (loadable_size >> 16) + 5;

  g->local_gotno += local_gotno;
  s->_raw_size += g->local_gotno * MIPS_ELF_GOT_SIZE (output_bfd);

  g->global_gotno = i;
  s->_raw_size += i * MIPS_ELF_GOT_SIZE (output_bfd);

  if (s->_raw_size > MIPS_ELF_GOT_MAX_SIZE (output_bfd)
      && ! mips_elf_multi_got (output_bfd, info, g, s, local_gotno))
    return FALSE;
d4741 1
a4816 8

	      /* If combreloc is enabled, elf_link_sort_relocs() will
		 sort relocations, but in a different way than we do,
		 and before we're done creating relocations.  Also, it
		 will move them around between input sections'
		 relocation's contents, so our sorting would be
		 broken, so don't let it run.  */
	      info->combreloc = 0;
d4821 8
a4828 13
	  /* _bfd_mips_elf_always_size_sections() has already done
	     most of the work, but some symbols may have been mapped
	     to versions that we must now resolve in the got_entries
	     hash tables.  */
	  struct mips_got_info *gg = mips_elf_got_info (dynobj, NULL);
	  struct mips_got_info *g = gg;
	  struct mips_elf_set_global_got_offset_arg set_got_offset_arg;
	  unsigned int needed_relocs = 0;
	  
	  if (gg->next)
	    {
	      set_got_offset_arg.value = MIPS_ELF_GOT_SIZE (output_bfd);
	      set_got_offset_arg.info = info;
d4830 10
a4839 2
	      mips_elf_resolve_final_got_entries (gg);
	      for (g = gg->next; g && g->next != gg; g = g->next)
d4841 7
a4847 1
		  unsigned int save_assign;
d4849 14
a4862 1
		  mips_elf_resolve_final_got_entries (g);
d4864 8
a4871 25
		  /* Assign offsets to global GOT entries.  */
		  save_assign = g->assigned_gotno;
		  g->assigned_gotno = g->local_gotno;
		  set_got_offset_arg.g = g;
		  set_got_offset_arg.needed_relocs = 0;
		  htab_traverse (g->got_entries,
				 mips_elf_set_global_got_offset,
				 &set_got_offset_arg);
		  needed_relocs += set_got_offset_arg.needed_relocs;
		  BFD_ASSERT (g->assigned_gotno - g->local_gotno
			      <= g->global_gotno);

		  g->assigned_gotno = save_assign;
		  if (info->shared)
		    {
		      needed_relocs += g->local_gotno - g->assigned_gotno;
		      BFD_ASSERT (g->assigned_gotno == g->next->local_gotno
				  + g->next->global_gotno
				  + MIPS_RESERVED_GOTNO);
		    }
		}

	      if (needed_relocs)
		mips_elf_allocate_dynamic_relocations (dynobj, needed_relocs);
	    }
d4956 1
a4956 1
      if (mips_elf_rel_dyn_section (dynobj, FALSE))
d5499 1
a5499 1
  struct mips_got_info *g, *gg;
d5547 1
a5547 1
  sgot = mips_elf_got_section (dynobj, FALSE);
d5549 2
a5550 2
  BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
  g = mips_elf_section_data (sgot)->u.got_info;
d5571 1
a5571 2
	  if ((info->shared && h->root.type == bfd_link_hash_undefined)
	      || h->root.type == bfd_link_hash_undefweak)
d5576 1
a5576 1
      offset = mips_elf_global_got_index (dynobj, output_bfd, h);
a5579 53
  if (g->next && h->dynindx != -1)
    {
      struct mips_got_entry e, *p;
      bfd_vma offset;
      bfd_vma value;
      Elf_Internal_Rela rel[3];
      bfd_vma addend = 0;

      gg = g;

      e.abfd = output_bfd;
      e.symndx = -1;
      e.d.h = (struct mips_elf_link_hash_entry *)h;
      
      if (info->shared
	  || h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
	value = 0;
      else if (sym->st_value)
	value = sym->st_value;
      else
	value = h->root.u.def.value;

      memset (rel, 0, sizeof (rel));
      rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_REL32);

      for (g = g->next; g->next != gg; g = g->next)
	{
	  if (g->got_entries
	      && (p = (struct mips_got_entry *) htab_find (g->got_entries,
							   &e)))
	    {
	      offset = p->gotidx;
	      rel[0].r_offset = rel[1].r_offset = rel[2].r_offset = offset;

	      MIPS_ELF_PUT_WORD (output_bfd, value, sgot->contents + offset);

	      if ((info->shared
		   || (elf_hash_table (info)->dynamic_sections_created
		       && p->d.h != NULL
		       && ((p->d.h->root.elf_link_hash_flags
			    & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
		       && ((p->d.h->root.elf_link_hash_flags
			    & ELF_LINK_HASH_DEF_REGULAR) == 0)))
		  && ! (mips_elf_create_dynamic_relocation
			(output_bfd, info, rel,
			 e.d.h, NULL, value, &addend, sgot)))
		return FALSE;
	      BFD_ASSERT (addend == 0);
	    }
	}
    }

d5686 1
a5686 1
  struct mips_got_info *gg, *g;
d5692 1
a5692 1
  sgot = mips_elf_got_section (dynobj, FALSE);
d5694 1
a5694 1
    gg = g = NULL;
d5697 2
a5698 4
      BFD_ASSERT (mips_elf_section_data (sgot) != NULL);
      gg = mips_elf_section_data (sgot)->u.got_info;
      BFD_ASSERT (gg != NULL);
      g = mips_elf_got_for_ibfd (gg, output_bfd);
d5728 1
a5728 1
	      s = mips_elf_rel_dyn_section (dynobj, FALSE);
d5814 1
a5814 1
	      if (gg->global_gotsym)
d5816 1
a5816 1
		  dyn.d_un.d_val = gg->global_gotsym->dynindx;
a5878 35
  /* Generate dynamic relocations for the non-primary gots.  */
  if (gg != NULL && gg->next)
    {
      Elf_Internal_Rela rel[3];
      bfd_vma addend = 0;

      memset (rel, 0, sizeof (rel));
      rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_REL32);

      for (g = gg->next; g->next != gg; g = g->next)
	{
	  bfd_vma index = g->next->local_gotno + g->next->global_gotno;

	  MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0, sgot->contents
			     + index++ * MIPS_ELF_GOT_SIZE (output_bfd));
	  MIPS_ELF_PUT_WORD (output_bfd, (bfd_vma) 0x80000000, sgot->contents
			     + index++ * MIPS_ELF_GOT_SIZE (output_bfd));

	  if (! info->shared)
	    continue;

	  while (index < g->assigned_gotno)
	    {
	      rel[0].r_offset = rel[1].r_offset = rel[2].r_offset
		= index++ * MIPS_ELF_GOT_SIZE (output_bfd);
	      if (!(mips_elf_create_dynamic_relocation
		    (output_bfd, info, rel, NULL,
		     bfd_abs_section_ptr,
		     0, &addend, sgot)))
		return FALSE;
	      BFD_ASSERT (addend == 0);
	    }
	}
    }

d5941 1
a5941 4
    s = mips_elf_rel_dyn_section (dynobj, FALSE);

    if (s != NULL
	&& s->_raw_size > (bfd_vma)2 * MIPS_ELF_REL_SIZE (output_bfd))
d5943 1
a5943 1
	reldyn_sorting_bfd = output_bfd;
d5945 8
a5952 8
	if (ABI_64_P (output_bfd))
	  qsort ((Elf64_External_Rel *) s->contents + 1,
		 (size_t) s->reloc_count - 1,
		 sizeof (Elf64_Mips_External_Rel), sort_dynamic_relocs_64);
	else
	  qsort ((Elf32_External_Rel *) s->contents + 1,
		 (size_t) s->reloc_count - 1,
		 sizeof (Elf32_External_Rel), sort_dynamic_relocs);
d5954 5
d5964 3
d5968 2
a5969 4
/* Set ABFD's EF_MIPS_ARCH and EF_MIPS_MACH flags.  */

static void
mips_set_isa_flags (abfd)
d5971 1
d5973 5
a5977 1
  flagword val;
d6050 1
a6050 1
      break;
a6051 4
    case bfd_mach_mipsisa32r2:
      val = E_MIPS_ARCH_32R2;
      break;
    }
a6054 23
}


/* The final processing done just before writing out a MIPS ELF object
   file.  This gets the MIPS architecture right based on the machine
   number.  This is used by both the 32-bit and the 64-bit ABI.  */

void
_bfd_mips_elf_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
{
  unsigned int i;
  Elf_Internal_Shdr **hdrpp;
  const char *name;
  asection *sec;

  /* Keep the existing EF_MIPS_MACH and EF_MIPS_ARCH flags if the former
     is nonzero.  This is for compatibility with old objects, which used
     a combination of a 32-bit EF_MIPS_ARCH and a 64-bit EF_MIPS_MACH.  */
  if ((elf_elfheader (abfd)->e_flags & EF_MIPS_MACH) == 0)
    mips_set_isa_flags (abfd);

d6505 2
a6506 2
  got = mips_elf_got_section (dynobj, FALSE);
  g = mips_elf_section_data (got)->u.got_info;
d6508 1
a6508 46
  if (g->next)
    {
      struct mips_got_entry e;
      struct mips_got_info *gg = g;

      /* Since we're turning what used to be a global symbol into a
	 local one, bump up the number of local entries of each GOT
	 that had an entry for it.  This will automatically decrease
	 the number of global entries, since global_gotno is actually
	 the upper limit of global entries.  */
      e.abfd = dynobj;
      e.symndx = -1;
      e.d.h = h;

      for (g = g->next; g != gg; g = g->next)
	if (htab_find (g->got_entries, &e))
	  {
	    BFD_ASSERT (g->global_gotno > 0);
	    g->local_gotno++;
	    g->global_gotno--;
	  }

      /* If this was a global symbol forced into the primary GOT, we
	 no longer need an entry for it.  We can't release the entry
	 at this point, but we must at least stop counting it as one
	 of the symbols that required a forced got entry.  */
      if (h->root.got.offset == 2)
	{
	  BFD_ASSERT (gg->assigned_gotno > 0);
	  gg->assigned_gotno--;
	}
    }
  else if (g->global_gotno == 0 && g->global_gotsym == NULL)
    /* If we haven't got through GOT allocation yet, just bump up the
       number of local entries, as this symbol won't be counted as
       global.  */
    g->local_gotno++;
  else if (h->root.got.offset == 1)
    {
      /* If we're past non-multi-GOT allocation and this symbol had
	 been marked for a global got entry, give it a local entry
	 instead.  */
      BFD_ASSERT (g->global_gotno > 0);
      g->local_gotno++;
      g->global_gotno--;
    }
d6510 3
a6512 1
  _bfd_elf_link_hash_hide_symbol (info, &h->root, force_local);
d6567 1
a6567 1
      mips_elf_section_data (o)->u.tdata = tdata;
d6601 1
a6601 1
  if (mips_elf_section_data (sec)->u.tdata == NULL)
d6610 1
a6610 1
      if ((mips_elf_section_data (sec)->u.tdata)[i] == 1)
d6760 1
a6760 1
      c = mips_elf_section_data (section)->u.tdata;
d6772 1
a6772 1
	  mips_elf_section_data (section)->u.tdata = c;
d7071 2
a7072 2
      got = mips_elf_got_section (dynobj, FALSE);
      g = mips_elf_section_data (got)->u.got_info;
d7723 4
a7726 60
/* Structure for saying that BFD machine EXTENSION extends BASE.  */

struct mips_mach_extension {
  unsigned long extension, base;
};


/* An array describing how BFD machines relate to one another.  The entries
   are ordered topologically with MIPS I extensions listed last.  */

static const struct mips_mach_extension mips_mach_extensions[] = {
  /* MIPS64 extensions.  */
  { bfd_mach_mips_sb1, bfd_mach_mipsisa64 },

  /* MIPS V extensions.  */
  { bfd_mach_mipsisa64, bfd_mach_mips5 },

  /* R10000 extensions.  */
  { bfd_mach_mips12000, bfd_mach_mips10000 },

  /* R5000 extensions.  Note: the vr5500 ISA is an extension of the core
     vr5400 ISA, but doesn't include the multimedia stuff.  It seems
     better to allow vr5400 and vr5500 code to be merged anyway, since
     many libraries will just use the core ISA.  Perhaps we could add
     some sort of ASE flag if this ever proves a problem.  */
  { bfd_mach_mips5500, bfd_mach_mips5400 },
  { bfd_mach_mips5400, bfd_mach_mips5000 },

  /* MIPS IV extensions.  */
  { bfd_mach_mips5, bfd_mach_mips8000 },
  { bfd_mach_mips10000, bfd_mach_mips8000 },
  { bfd_mach_mips5000, bfd_mach_mips8000 },

  /* VR4100 extensions.  */
  { bfd_mach_mips4120, bfd_mach_mips4100 },
  { bfd_mach_mips4111, bfd_mach_mips4100 },

  /* MIPS III extensions.  */
  { bfd_mach_mips8000, bfd_mach_mips4000 },
  { bfd_mach_mips4650, bfd_mach_mips4000 },
  { bfd_mach_mips4600, bfd_mach_mips4000 },
  { bfd_mach_mips4400, bfd_mach_mips4000 },
  { bfd_mach_mips4300, bfd_mach_mips4000 },
  { bfd_mach_mips4100, bfd_mach_mips4000 },
  { bfd_mach_mips4010, bfd_mach_mips4000 },

  /* MIPS32 extensions.  */
  { bfd_mach_mipsisa32r2, bfd_mach_mipsisa32 },

  /* MIPS II extensions.  */
  { bfd_mach_mips4000, bfd_mach_mips6000 },
  { bfd_mach_mipsisa32, bfd_mach_mips6000 },

  /* MIPS I extensions.  */
  { bfd_mach_mips6000, bfd_mach_mips3000 },
  { bfd_mach_mips3900, bfd_mach_mips3000 }
};


/* Return true if bfd machine EXTENSION is an extension of machine BASE.  */
d7729 2
a7730 2
mips_mach_extends_p (base, extension)
     unsigned long base, extension;
d7732 9
a7740 23
  size_t i;

  for (i = 0; extension != base && i < ARRAY_SIZE (mips_mach_extensions); i++)
    if (extension == mips_mach_extensions[i].extension)
      extension = mips_mach_extensions[i].base;

  return extension == base;
}


/* Return true if the given ELF header flags describe a 32-bit binary.  */

static bfd_boolean
mips_32bit_flags_p (flags)
     flagword flags;
{
  return ((flags & EF_MIPS_32BITMODE) != 0
	  || (flags & EF_MIPS_ABI) == E_MIPS_ABI_O32
	  || (flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI32
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_1
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_2
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32
	  || (flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32R2);
a7742 1

a7791 5
  /* Some IRIX 6 BSD-compatibility objects have this bit set.  It
     doesn't seem to matter.  */
  new_flags &= ~EF_MIPS_XGOT;
  old_flags &= ~EF_MIPS_XGOT;

d7838 44
a7881 27
  /* Compare the ISAs.  */
  if (mips_32bit_flags_p (old_flags) != mips_32bit_flags_p (new_flags))
    {
      (*_bfd_error_handler)
	(_("%s: linking 32-bit code with 64-bit code"),
	 bfd_archive_filename (ibfd));
      ok = FALSE;
    }
  else if (!mips_mach_extends_p (bfd_get_mach (ibfd), bfd_get_mach (obfd)))
    {
      /* OBFD's ISA isn't the same as, or an extension of, IBFD's.  */
      if (mips_mach_extends_p (bfd_get_mach (obfd), bfd_get_mach (ibfd)))
	{
	  /* Copy the architecture info from IBFD to OBFD.  Also copy
	     the 32-bit flag (if set) so that we continue to recognise
	     OBFD as a 32-bit binary.  */
	  bfd_set_arch_info (obfd, bfd_get_arch_info (ibfd));
	  elf_elfheader (obfd)->e_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH);
	  elf_elfheader (obfd)->e_flags
	    |= new_flags & (EF_MIPS_ARCH | EF_MIPS_MACH | EF_MIPS_32BITMODE);

	  /* Copy across the ABI flags if OBFD doesn't use them
	     and if that was what caused us to treat IBFD as 32-bit.  */
	  if ((old_flags & EF_MIPS_ABI) == 0
	      && mips_32bit_flags_p (new_flags)
	      && !mips_32bit_flags_p (new_flags & ~EF_MIPS_ABI))
	    elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_ABI;
a7884 1
	  /* The ISAs aren't compatible.  */
d7886 1
a7886 1
	    (_("%s: linking %s module with previous %s modules"),
d7888 2
a7889 2
	     bfd_printable_name (ibfd),
	     bfd_printable_name (obfd));
d7892 3
d7897 1
a7897 4
  new_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH | EF_MIPS_32BITMODE);
  old_flags &= ~(EF_MIPS_ARCH | EF_MIPS_MACH | EF_MIPS_32BITMODE);

  /* Compare ABIs.  The 64-bit ABI does not use EF_MIPS_ABI.  But, it
a8007 2
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32R2)
    fprintf (file, _(" [mips32r2]"));
@


1.22.2.6
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d12 1
a12 1
   This file is part of BFD, the Binary File Descriptor library.
d14 13
a26 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d362 9
a370 9
	bfd_vma	adr;		/* Memory address of start of procedure.  */
	long	regmask;	/* Save register mask.  */
	long	regoffset;	/* Save register offset.  */
	long	fregmask;	/* Save floating point register mask.  */
	long	fregoffset;	/* Save floating point register offset.  */
	long	frameoffset;	/* Frame size.  */
	short	framereg;	/* Frame pointer register.  */
	short	pcreg;		/* Offset or reg of return pc.  */
	long	irpss;		/* Index into the runtime string table.  */
d372 1
a372 1
	struct exception_info *exception_info;/* Pointer to exception array.  */
d499 1
d2133 1
a2133 1
/* In a multi-got link, determine the GOT to be used for IBFD.  G must
d3098 1
d3320 6
d3454 2
a3455 4
    case R_MIPS_GNU_REL16_S2:
      value = mips_elf_sign_extend (addend << 2, 18) + symbol - p;
      overflowed_p = mips_elf_overflow_p (value, 18);
      value = (value >> 2) & howto->dst_mask;
@


1.22.2.7
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a410 1
static long mips_elf_get_global_gotsym_index PARAMS ((bfd *abfd));
a498 1

a1708 23
/* Obtain the lowest dynamic index of a symbol that was assigned a
   global GOT entry.  */
static long
mips_elf_get_global_gotsym_index (abfd)
     bfd *abfd;
{
  asection *sgot;
  struct mips_got_info *g;

  if (abfd == NULL)
    return 0;
  
  sgot = mips_elf_got_section (abfd, TRUE);
  if (sgot == NULL || mips_elf_section_data (sgot) == NULL)
    return 0;
  
  g = mips_elf_section_data (sgot)->u.got_info;
  if (g == NULL || g->global_gotsym == NULL)
    return 0;
    
  return g->global_gotsym->dynindx;
}

d2132 1
a2132 1
/* In a multi-got link, determine the GOT to be used for IBDF.  G must
a3197 12
    case R_MIPS_GOT_PAGE:
    case R_MIPS_GOT_OFST:
      /* If this symbol got a global GOT entry, we have to decay
	 GOT_PAGE/GOT_OFST to GOT_DISP/addend.  */
      local_p = local_p || ! h
	|| (h->root.dynindx
	    < mips_elf_get_global_gotsym_index (elf_hash_table (info)
						->dynobj));
      if (local_p || r_type == R_MIPS_GOT_OFST)
	break;
      /* Fall through.  */

d3208 1
a3208 5
	  /* GOT_PAGE may take a non-zero addend, that is ignored in a
	     GOT_PAGE relocation that decays to GOT_DISP because the
	     symbol turns out to be global.  The addend is then added
	     as GOT_OFST.  */
	  BFD_ASSERT (addend == 0 || r_type == R_MIPS_GOT_PAGE);
d3222 1
a3222 1
	      MIPS_ELF_PUT_WORD (tmpbfd, symbol, sgot->contents + g);
a3317 6
    case R_MIPS_GNU_REL16_S2:
      value = symbol + mips_elf_sign_extend (addend << 2, 18) - p;
      overflowed_p = mips_elf_overflow_p (value, 18);
      value = (value >> 2) & howto->dst_mask;
      break;

a3434 1
    got_disp:
d3446 4
a3449 2
      value = mips_elf_sign_extend (addend, 16) + symbol - p;
      overflowed_p = mips_elf_overflow_p (value, 16);
a3467 5
      /* GOT_PAGE relocations that reference non-local symbols decay
	 to GOT_DISP.  The corresponding GOT_OFST relocation decays to
	 0.  */
      if (! local_p)
	goto got_disp;
d3477 1
a3477 4
      if (local_p)
	mips_elf_got_page (abfd, input_bfd, info, symbol + addend, &value);
      else
	value = addend;
d3835 1
d3865 9
a3873 12
	  /* Instead of generating a relocation using the section
	     symbol, we may as well make it a fully relative
	     relocation.  We want to avoid generating relocations to
	     local symbols because we used to generate them
	     incorrectly, without adding the original symbol value,
	     which is mandated by the ABI for section symbols.  In
	     order to give dynamic loaders and applications time to
	     phase out the incorrect use, we refrain from emitting
	     section-relative relocations.  It's not like they're
	     useful, after all.  This should be a bit more efficient
	     as well.  */
	  indx = 0;
a3886 12
      /* For strict adherence to the ABI specification, we should
	 generate a R_MIPS_64 relocation record by itself before the
	 _REL32/_64 record as well, such that the addend is read in as
	 a 64-bit value (REL32 is a 32-bit relocation, after all).
	 However, since none of the existing ELF64 MIPS dynamic
	 loaders seems to care, we don't waste space with these
	 artificial relocations.  If this turns out to not be true,
	 mips_elf_allocate_dynamic_relocation() should be tweaked so
	 as to make room for a pair of dynamic relocations per
	 invocation if ABI_64_P, and here we should generate an
	 additional relocation record with R_MIPS_64 by itself for a
	 NULL symbol before this relocation record.  */
a5295 38
	case R_MIPS_GOT_PAGE:
	  /* If this is a global, overridable symbol, GOT_PAGE will
	     decay to GOT_DISP, so we'll need a GOT entry for it.  */
	  if (h == NULL)
	    break;
	  else
	    {
	      struct mips_elf_link_hash_entry *hmips =
		(struct mips_elf_link_hash_entry *) h;
	      
	      while (hmips->root.root.type == bfd_link_hash_indirect
		     || hmips->root.root.type == bfd_link_hash_warning)
		hmips = (struct mips_elf_link_hash_entry *)
		  hmips->root.root.u.i.link;
	  
	      if ((hmips->root.root.type == bfd_link_hash_defined
		   || hmips->root.root.type == bfd_link_hash_defweak)
		  && hmips->root.root.u.def.section
		  && ! (info->shared && ! info->symbolic
			&& ! (hmips->root.elf_link_hash_flags
			      & ELF_LINK_FORCED_LOCAL))
		  /* If we've encountered any other relocation
		     referencing the symbol, we'll have marked it as
		     dynamic, and, even though we might be able to get
		     rid of the GOT entry should we know for sure all
		     previous relocations were GOT_PAGE ones, at this
		     point we can't tell, so just keep using the
		     symbol as dynamic.  This is very important in the
		     multi-got case, since we don't decide whether to
		     decay GOT_PAGE to GOT_DISP on a per-GOT basis: if
		     the symbol is dynamic, we'll need a GOT entry for
		     every GOT in which the symbol is referenced with
		     a GOT_PAGE relocation.  */
		  && hmips->root.dynindx == -1)
		break;
	    }
	  /* Fall through.  */

a5434 179
bfd_boolean
_bfd_mips_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
{
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Shdr *symtab_hdr;
  bfd_byte *contents = NULL;
  bfd_byte *free_contents = NULL;
  size_t extsymoff;
  bfd_boolean changed_contents = FALSE;
  bfd_vma sec_start = sec->output_section->vma + sec->output_offset;
  Elf_Internal_Sym *isymbuf = NULL;

  /* We are not currently changing any sizes, so only one pass.  */
  *again = FALSE;

  if (link_info->relocateable)
    return TRUE;

  internal_relocs = (MNAME(abfd,_bfd_elf,link_read_relocs)
                     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
                      link_info->keep_memory));
  if (internal_relocs == NULL)
    return TRUE;

  irelend = internal_relocs + sec->reloc_count
    * get_elf_backend_data (abfd)->s->int_rels_per_ext_rel;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      bfd_signed_vma sym_offset;
      unsigned int r_type;
      unsigned long r_symndx;
      asection *sym_sec;
      unsigned long instruction;

      /* Turn jalr into bgezal, and jr into beq, if they're marked
	 with a JALR relocation, that indicate where they jump to.
	 This saves some pipeline bubbles.  */
      r_type = ELF_R_TYPE (abfd, irel->r_info);
      if (r_type != R_MIPS_JALR)
	continue;

      r_symndx = ELF_R_SYM (abfd, irel->r_info);
      /* Compute the address of the jump target.  */
      if (r_symndx >= extsymoff)
	{
	  struct mips_elf_link_hash_entry *h
	    = ((struct mips_elf_link_hash_entry *)
	       elf_sym_hashes (abfd) [r_symndx - extsymoff]);

	  while (h->root.root.type == bfd_link_hash_indirect
		 || h->root.root.type == bfd_link_hash_warning)
	    h = (struct mips_elf_link_hash_entry *) h->root.root.u.i.link;
	  
	  /* If a symbol is undefined, or if it may be overridden,
	     skip it.  */
	  if (! ((h->root.root.type == bfd_link_hash_defined
		  || h->root.root.type == bfd_link_hash_defweak)
		 && h->root.root.u.def.section)
	      || (link_info->shared && ! link_info->symbolic
		  && ! (h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL)))
	    continue;

	  sym_sec = h->root.root.u.def.section;
	  if (sym_sec->output_section)
	    symval = (h->root.root.u.def.value
		      + sym_sec->output_section->vma
		      + sym_sec->output_offset);
	  else
	    symval = h->root.root.u.def.value;
	}
      else
	{
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's symbols if we haven't done so already.  */
	  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto relax_return;
	    }

	  isym = isymbuf + r_symndx;
	  if (isym->st_shndx == SHN_UNDEF)
	    continue;
	  else if (isym->st_shndx == SHN_ABS)
	    sym_sec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    sym_sec = bfd_com_section_ptr;
	  else
	    sym_sec
	      = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = isym->st_value
	    + sym_sec->output_section->vma
	    + sym_sec->output_offset;
	}

      /* Compute branch offset, from delay slot of the jump to the
	 branch target.  */
      sym_offset = (symval + irel->r_addend)
	- (sec_start + irel->r_offset + 4);

      /* Branch offset must be properly aligned.  */
      if ((sym_offset & 3) != 0)
	continue;

      sym_offset >>= 2;

      /* Check that it's in range.  */
      if (sym_offset < -0x8000 || sym_offset >= 0x8000)
	continue;
      
      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto relax_return;

	      free_contents = contents;
	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
		goto relax_return;
	    }
	}

      instruction = bfd_get_32 (abfd, contents + irel->r_offset);

      /* If it was jalr <reg>, turn it into bgezal $zero, <target>.  */
      if ((instruction & 0xfc1fffff) == 0x0000f809)
	instruction = 0x04110000;
      /* If it was jr <reg>, turn it into b <target>.  */
      else if ((instruction & 0xfc1fffff) == 0x00000008)
	instruction = 0x10000000;
      else
	continue;

      instruction |= (sym_offset & 0xffff);
      bfd_put_32 (abfd, instruction, contents + irel->r_offset);
      changed_contents = TRUE;
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (!changed_contents && !link_info->keep_memory)
        free (contents);
      else
        {
          /* Cache the section contents for elf_link_input_bfd.  */
          elf_section_data (sec)->this_hdr.contents = contents;
        }
    }
  return TRUE;

 relax_return:  
  if (free_contents != NULL)
    free (free_contents);
  return FALSE;
}

d7521 4
a7524 1
  if (dynobj != NULL)
d7526 2
a7527 2
      got = mips_elf_got_section (dynobj, FALSE);
      g = mips_elf_section_data (got)->u.got_info;
d7529 8
a7536 13
      if (g->next)
	{
	  struct mips_got_entry e;
	  struct mips_got_info *gg = g;

	  /* Since we're turning what used to be a global symbol into a
	     local one, bump up the number of local entries of each GOT
	     that had an entry for it.  This will automatically decrease
	     the number of global entries, since global_gotno is actually
	     the upper limit of global entries.  */
	  e.abfd = dynobj;
	  e.symndx = -1;
	  e.d.h = h;
d7538 7
a7544 7
	  for (g = g->next; g != gg; g = g->next)
	    if (htab_find (g->got_entries, &e))
	      {
		BFD_ASSERT (g->global_gotno > 0);
		g->local_gotno++;
		g->global_gotno--;
	      }
d7546 23
a7568 24
	  /* If this was a global symbol forced into the primary GOT, we
	     no longer need an entry for it.  We can't release the entry
	     at this point, but we must at least stop counting it as one
	     of the symbols that required a forced got entry.  */
	  if (h->root.got.offset == 2)
	    {
	      BFD_ASSERT (gg->assigned_gotno > 0);
	      gg->assigned_gotno--;
	    }
	}
      else if (g->global_gotno == 0 && g->global_gotsym == NULL)
	/* If we haven't got through GOT allocation yet, just bump up the
	   number of local entries, as this symbol won't be counted as
	   global.  */
	g->local_gotno++;
      else if (h->root.got.offset == 1)
	{
	  /* If we're past non-multi-GOT allocation and this symbol had
	     been marked for a global got entry, give it a local entry
	     instead.  */
	  BFD_ASSERT (g->global_gotno > 0);
	  g->local_gotno++;
	  g->global_gotno--;
	}
@


1.22.2.8
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d166 2
a167 1
     with dynamic relocations pointing to it from non-primary     GOTs).  */
d249 2
a250 1
  bfd *abfd;  struct bfd_link_info *info;
d545 1
a545 1
  (get_elf_backend_data (abfd)->s->log_file_align)
d1722 1
a1722 1

d1726 1
a1726 1

d1730 1
a1730 1

d1773 1
a1773 1

d1831 1
a1831 1

d1889 1
a1889 1

d1921 1
a1921 1

d1928 1
a1928 1

d1968 1
a1968 1
  hsd.max_unref_got_dynindx =
d2082 1
a2082 1

d2124 1
a2124 1

d2190 1
a2190 1

d2242 1
a2242 1

d2271 1
a2271 1

d2339 1
a2339 1

d2420 1
a2420 1

d2440 1
a2440 1

d2481 1
a2481 1

d2569 1
a2569 1

d2595 1
a2595 1

d2668 1
a2668 1

d2671 1
a2671 1

d5109 4
a5112 4
	      sec_relocs
		= _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
					     (Elf_Internal_Rela *) NULL,
					     info->keep_memory);
d5373 1
a5373 1

d5378 1
a5378 1

d5564 3
a5566 3
  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
					       (Elf_Internal_Rela *) NULL,
					       link_info->keep_memory);
d5602 1
a5602 1

d5665 1
a5665 1

d5714 1
a5714 1
 relax_return:
d5860 1
a5860 1

d6025 1
a6025 1

d6785 1
a6785 1

d7890 4
a7893 3
  cookie->rels = _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
					    (Elf_Internal_Rela *) NULL,
					    info->keep_memory);
d8384 11
d9177 1
a9177 6
    {
      (*_bfd_error_handler)
	(_("%s: endianness incompatible with that of the selected emulation"),
	 bfd_archive_filename (ibfd));
      return FALSE;
    }
a9182 8
  if (strcmp (bfd_get_target (ibfd), bfd_get_target (obfd)) != 0)
    {
      (*_bfd_error_handler)
	(_("%s: ABI is incompatible with that of the selected emulation"),
	 bfd_archive_filename (ibfd));
      return FALSE;
    }

d9241 1
a9241 2
  if (((new_flags & (EF_MIPS_PIC | EF_MIPS_CPIC)) != 0)
      != ((old_flags & (EF_MIPS_PIC | EF_MIPS_CPIC)) != 0))
d9243 2
d9246 1
a9246 1
	(_("%s: warning: linking PIC files with non-PIC files"),
d9248 1
a9248 1
      ok = TRUE;
d9251 9
a9259 7
  if (new_flags & (EF_MIPS_PIC | EF_MIPS_CPIC))
    elf_elfheader (obfd)->e_flags |= EF_MIPS_CPIC;
  if (! (new_flags & EF_MIPS_PIC))
    elf_elfheader (obfd)->e_flags &= ~EF_MIPS_PIC;

  new_flags &= ~ (EF_MIPS_PIC | EF_MIPS_CPIC);
  old_flags &= ~ (EF_MIPS_PIC | EF_MIPS_CPIC);
@


1.22.2.9
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d166 1
a166 1
     with dynamic relocations pointing to it from non-primary GOTs).  */
d248 1
a248 2
  bfd *abfd;
  struct bfd_link_info *info;
d436 1
d519 1
a519 1
  (NEWABI_P (abfd) ? ".MIPS.options" : ".options")
d523 1
a523 1
  (NEWABI_P (abfd) ? ".MIPS.stubs" : ".stub")
d1083 1
a1083 1
			       relocatable, data, gp)
d1088 1
a1088 1
     bfd_boolean relocatable;
d1093 2
a1094 2
  unsigned long insn = 0;
  bfd_signed_vma val;
d1107 2
d1110 6
a1115 3
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
d1117 3
a1119 2
      insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
      val += insn & 0xffff;
a1121 2
  _bfd_mips_elf_sign_extend(val, 16);

d1123 1
a1123 1
     are producing relocatable output, we don't want to do this for
d1125 1
a1125 1
  if (! relocatable
d1129 2
a1130 8
  if (reloc_entry->howto->partial_inplace)
    {
      insn = (insn & ~0xffff) | (val & 0xffff);
      bfd_put_32 (abfd, (bfd_vma) insn,
		  (bfd_byte *) data + reloc_entry->address);
    }
  else
    reloc_entry->addend = val;
d1132 1
a1132 1
  if (relocatable)
d1134 2
a1135 1
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
d1665 1
a1665 1
					  MIPS_ELF_LOG_FILE_ALIGN (dynobj)))
d2743 2
a2744 2
bfd_vma
_bfd_mips_elf_sign_extend (value, bits)
a2871 2
  /* We have to use an alignment of 2**4 here because this is hardcoded
     in the function stub generation and in the linker script.  */
d3153 1
a3153 1
  if (r_type != R_MIPS16_26 && !info->relocatable
d3174 1
a3174 1
  else if (r_type == R_MIPS16_26 && !info->relocatable
d3210 1
a3210 1
  *require_jalxp = (!info->relocatable
d3307 1
a3307 1
      value = symbol + _bfd_mips_elf_sign_extend (addend, 16);
d3358 1
a3358 1
      value = symbol + _bfd_mips_elf_sign_extend (addend << 2, 18) - p;
d3383 1
a3383 1
	value = (_bfd_mips_elf_sign_extend (addend << 2, 28) + symbol) >> 2;
d3443 1
a3443 1
	addend = _bfd_mips_elf_sign_extend (addend, 16);
d3492 1
a3492 1
      value = _bfd_mips_elf_sign_extend (addend, 16) + symbol - p;
d3652 1
a3652 1
	 When producing a relocatable object file, R_MIPS16_26 is
d3690 1
a3690 1
	 When producing a relocatable object file, the calculation is
d3696 1
a3696 1
      if (!info->relocatable)
d3855 1
a3855 1
  if (input_section->sec_info_type != ELF_INFO_TYPE_STABS)
d4641 24
a4664 5
  /* The generic elf_fake_sections will set up REL_HDR using the default
   kind of relocations.  We used to set up a second header for the
   non-default kind of relocations here, but only NewABI would use
   these, and the IRIX ld doesn't like resulting empty RELA sections.
   Thus we create those header only on demand now.  */
d4976 1
a4976 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d4979 1
a4979 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d4982 1
a4982 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d4985 1
a4985 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d4988 1
a4988 1
	bfd_set_section_alignment (abfd, s, MIPS_ELF_LOG_FILE_ALIGN (abfd));
d5063 1
a5063 1
  if (info->relocatable)
d5559 1
a5559 1
  if (link_info->relocatable)
d5750 1
a5750 1
  if (! info->relocatable
d5848 1
a5848 1
  if (! (info->relocatable
d6355 1
a6355 1
		  l = _bfd_mips_elf_sign_extend (l, 16);
d6386 1
a6386 1
      if (info->relocatable)
d6400 1
a6400 1
	     that we're adjusting GP in this relocatable object.  */
d7801 1
a7801 1
  h->forced_local = force_local;
d7804 1
a7804 1
  if (dynobj != NULL && force_local)
d7900 1
a7900 1
  for (i = 0, skip = 0; i < o->_raw_size / PDR_SIZE; i ++)
d8131 1
a8131 1
					      data, relocatable, symbols)
d8136 1
a8136 1
     bfd_boolean relocatable;
d8244 1
a8244 1
						 input_section, relocatable,
d8254 1
a8254 1
				      relocatable ? abfd : (bfd *) NULL,
d8258 1
a8258 1
	  if (relocatable)
d8465 1
a8465 1
      else if (info->relocatable)
d8786 1
a8786 1
	  if (! info->relocatable)
@


1.22.2.10
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d191 4
d393 6
d445 2
d733 1
d1195 25
d2920 28
d3878 2
a3879 2
  if (outrel[0].r_offset == (bfd_vma) -1)
    /* The relocation field has been deleted.  */
a3880 8
  else if (outrel[0].r_offset == (bfd_vma) -2)
    {
      /* The relocation field has been converted into a relative value of
	 some sort.  Functions like _bfd_elf_write_section_eh_frame expect
	 the field to be fully relocated, so add in the symbol's value.  */
      skip = TRUE;
      *addendp += symbol;
    }
a3889 1
      bfd_boolean defined_p;
d3895 3
a3897 1
				   & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3900 2
a3901 12
	  && h->root.dynindx != -1)
	{
	  indx = h->root.dynindx;
	  if (SGI_COMPAT (output_bfd))
	    defined_p = ((h->root.elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) != 0);
	  else
	    /* ??? glibc's ld.so just adds the final GOT entry to the
	       relocation field.  It therefore treats relocs against
	       defined symbols in the same way as relocs against
	       undefined symbols.  */
	    defined_p = FALSE;
d3930 1
a3930 7
	  /* ??? Although this behavior is compatible with glibc's ld.so,
	     the ABI says that relocations against STN_UNDEF should have
	     a symbol value of 0.  Irix rld honors this, so relocations
	     against STN_UNDEF have no effect.  */
	  if (!SGI_COMPAT (output_bfd))
	    indx = 0;
	  defined_p = TRUE;
d3937 1
a3937 1
      if (defined_p && r_type != R_MIPS_REL32)
d3988 7
d4895 7
a5497 1
	case R_MIPS_JALR:
d6063 4
d6211 4
a6646 1
	  sym->st_other = STO_PROTECTED;
d6671 1
d6674 1
d6678 1
d6734 16
a6749 1
      value = sym->st_value;
d6807 15
d7144 1
d7148 23
a7285 1
    case bfd_mach_mips7000:
d7763 4
a9071 1
  { bfd_mach_mips7000, bfd_mach_mips8000 },
a9414 18

struct bfd_elf_special_section const _bfd_mips_elf_special_sections[]=
{
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".lit4",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".lit8",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".ucode",		0,	NULL,	0,
    SHT_MIPS_UCODE,	0 },
  { ".mdebug",		0,	NULL,	0,
    SHT_MIPS_DEBUG,	0 },
  { NULL,		0,	NULL,	0,
    0,			0 }
};
@


1.22.2.11
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a3010 2
      /* ??? Could we use RELOC_FOR_GLOBAL_SYMBOL here ?  */

d3024 1
a3024 1
      if (strcmp (*namep, "_gp_disp") == 0
d3057 1
a3057 1
	       && info->unresolved_syms_in_objects == RM_IGNORE
d3060 2
a3061 2
      else if (strcmp (*namep, "_DYNAMIC_LINK") == 0 ||
              strcmp (*namep, "_DYNAMIC_LINKING") == 0)
d3078 1
a3078 2
		  ((info->shared && info->unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)
		   || (!info->shared && info->unresolved_syms_in_objects == RM_GENERATE_ERROR)
d4988 1
a4988 1
  const struct elf_backend_data *bed;
d6174 1
a6174 1
  const struct elf_backend_data *bed;
d7477 1
a7477 1
	  low = ~(bfd_vma) 0;
d7629 1
a7629 1
     const struct elf_backend_data *bed;
@


1.22.2.12
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d590 2
a591 1
/* Instructions which appear in a stub.  */
d597 2
a598 4
   ((ABI_64_P (abfd)						\
     ? 0x03e0782d		/* daddu t7,ra */		\
     : 0x03e07821))		/* addu t7,ra */
#define STUB_JALR 0x0320f809	/* jalr t9,ra */
d600 1
a600 3
  ((ABI_64_P (abfd)						\
   ? 0x64180000			/* daddiu t8,zero,0 */		\
   : 0x24180000))		/* addiu t8,zero,0 */
a2866 1
  g->global_gotno = 0;
a4058 4

	case E_MIPS_ARCH_64R2:
	  return bfd_mach_mipsisa64r2;
	  break;
d5866 1
a5866 1
      if (info->executable)
d6084 24
d6877 7
d6897 21
d6985 3
a6987 10
	    case DT_RELSZ:
	      /* Reduce DT_RELSZ to account for any relocations we
		 decided not to make.  This is for the n64 irix rld,
		 which doesn't seem to apply any relocations if there
		 are trailing null entries.  */
	      s = mips_elf_rel_dyn_section (dynobj, FALSE);
	      dyn.d_un.d_val = (s->reloc_count
				* (ABI_64_P (output_bfd)
				   ? sizeof (Elf64_Mips_External_Rel)
				   : sizeof (Elf32_External_Rel)));
a7194 4

    case bfd_mach_mipsisa64r2:
      val = E_MIPS_ARCH_64R2;
      break;
d7364 1
a7364 1
     PT_MIPS_OPTIONS segment immediately following the program header
d7381 9
a7389 5
	  pm = &elf_tdata (abfd)->segment_map;
	  while (*pm != NULL
		 && ((*pm)->p_type == PT_PHDR
		     || (*pm)->p_type == PT_INTERP))
	    pm = &(*pm)->next;
d7953 1
a7953 1
     const PTR location;
a8931 1
  { bfd_mach_mipsisa64r2, bfd_mach_mipsisa64 },
a9078 5
  /* MIPSpro generates ucode info in n64 objects.  Again, we should
     just be able to ignore this.  */
  new_flags &= ~EF_MIPS_UCODE;
  old_flags &= ~EF_MIPS_UCODE;

a9277 2
  else if ((elf_elfheader (abfd)->e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_64R2)
    fprintf (file, _(" [mips64r2]"));
d9299 14
a9312 7
  { ".sdata",  6, -2, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".sbss",   5, -2, SHT_NOBITS,     SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".lit4",   5,  0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".lit8",   5,  0, SHT_PROGBITS,   SHF_ALLOC + SHF_WRITE + SHF_MIPS_GPREL },
  { ".ucode",  6,  0, SHT_MIPS_UCODE, 0 },
  { ".mdebug", 7,  0, SHT_MIPS_DEBUG, 0 },
  { NULL,      0,  0, 0,              0 }
@


1.22.2.13
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d373 1
a373 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d375 1
a375 1
  (bfd *, const RPDR *, struct rpdr_ext *);
d377 2
a378 2
  (void *, bfd *, struct bfd_link_info *, asection *,
   struct ecoff_debug_info *);
d380 1
a380 1
  (struct mips_elf_link_hash_entry *, void *);
d382 1
a382 1
  (bfd *, const Elf32_External_gptab *, Elf32_gptab *);
d384 1
a384 1
  (bfd *, const Elf32_gptab *, Elf32_External_gptab *);
d386 1
a386 1
  (bfd *, const Elf32_compact_rel *, Elf32_External_compact_rel *);
d388 1
a388 1
  (bfd *, const Elf32_crinfo *, Elf32_External_crinfo *);
d390 1
a390 1
  (const void *, const void *);
d392 1
a392 1
  (const void *, const void *);
d394 4
a397 7
  (struct mips_elf_link_hash_entry *, void *);
static int gptab_compare
  (const void *, const void *);
static asection *mips_elf_rel_dyn_section
  (bfd *, bfd_boolean);
static asection *mips_elf_got_section
  (bfd *, bfd_boolean);
d399 2
a400 3
  (bfd *, asection **);
static long mips_elf_get_global_gotsym_index
  (bfd *abfd);
d402 1
a402 1
  (bfd *, bfd *, struct bfd_link_info *, bfd_vma);
d404 1
a404 1
  (bfd *, bfd *, struct elf_link_hash_entry *);
d406 1
a406 1
  (bfd *, bfd *, struct bfd_link_info *, bfd_vma, bfd_vma *);
d408 1
a408 1
  (bfd *, bfd *, struct bfd_link_info *, bfd_vma, bfd_boolean);
d410 1
a410 1
  (bfd *, bfd *, bfd *, bfd_vma);
d412 1
a412 1
  (bfd *, bfd *, struct mips_got_info *, asection *, bfd_vma);
d414 1
a414 1
  (struct bfd_link_info *, unsigned long);
d416 1
a416 1
  (struct mips_elf_link_hash_entry *, void *);
d418 1
a418 1
  (bfd *, long, bfd_vma, struct mips_got_info *);
d420 2
a421 2
  (struct elf_link_hash_entry *, bfd *, struct bfd_link_info *,
   struct mips_got_info *);
d423 2
a424 1
  (bfd *, unsigned int, const Elf_Internal_Rela *, const Elf_Internal_Rela *);
d426 5
a430 9
  (bfd *, const Elf_Internal_Rela *, asection **, bfd_boolean);
static bfd_boolean mips_elf_overflow_p
  (bfd_vma, int);
static bfd_vma mips_elf_high
  (bfd_vma);
static bfd_vma mips_elf_higher
  (bfd_vma);
static bfd_vma mips_elf_highest
  (bfd_vma);
d432 1
a432 1
  (bfd *, struct bfd_link_info *);
d434 1
a434 1
  (bfd *, struct bfd_link_info *, bfd_boolean);
d436 4
a439 4
  (bfd *, bfd *, asection *, struct bfd_link_info *,
   const Elf_Internal_Rela *, bfd_vma, reloc_howto_type *,
   Elf_Internal_Sym *, asection **, bfd_vma *, const char **,
   bfd_boolean *, bfd_boolean);
d441 1
a441 1
  (reloc_howto_type *, const Elf_Internal_Rela *, bfd *, bfd_byte *);
d443 3
a445 2
  (struct bfd_link_info *, reloc_howto_type *, const Elf_Internal_Rela *,
   bfd_vma, bfd *, asection *, bfd_byte *, bfd_boolean);
d447 1
a447 1
  (bfd *, asection *);
d449 1
a449 1
  (bfd *, unsigned int);
d451 5
a455 7
  (bfd *, struct bfd_link_info *, const Elf_Internal_Rela *,
   struct mips_elf_link_hash_entry *, asection *, bfd_vma,
   bfd_vma *, asection *);
static void mips_set_isa_flags
  (bfd *);
static INLINE char *elf_mips_abi_name
  (bfd *);
d457 6
a462 11
  (bfd *, const char *, Elf_Internal_Sym *);
static bfd_boolean mips_mach_extends_p
  (unsigned long, unsigned long);
static bfd_boolean mips_32bit_flags_p
  (flagword);
static INLINE hashval_t mips_elf_hash_bfd_vma
  (bfd_vma);
static hashval_t mips_elf_got_entry_hash
  (const void *);
static int mips_elf_got_entry_eq
  (const void *, const void *);
d465 10
a474 20
  (bfd *, struct bfd_link_info *, struct mips_got_info *,
   asection *, bfd_size_type);
static hashval_t mips_elf_multi_got_entry_hash
  (const void *);
static int mips_elf_multi_got_entry_eq
  (const void *, const void *);
static hashval_t mips_elf_bfd2got_entry_hash
  (const void *);
static int mips_elf_bfd2got_entry_eq
  (const void *, const void *);
static int mips_elf_make_got_per_bfd
  (void **, void *);
static int mips_elf_merge_gots
  (void **, void *);
static int mips_elf_set_global_got_offset
  (void **, void *);
static int mips_elf_set_no_stub
  (void **, void *);
static int mips_elf_resolve_final_got_entry
  (void **, void *);
d476 1
a476 1
  (struct mips_got_info *);
d478 1
a478 1
  (bfd *, struct mips_got_info *, bfd *);
d480 1
a480 1
  (struct mips_got_info *, bfd *);
d545 4
a548 4
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)	\
  (ABI_64_P (elf_hash_table (info)->dynobj)		\
   ? bfd_elf64_add_dynamic_entry (info, tag, val)	\
   : bfd_elf32_add_dynamic_entry (info, tag, val))
d550 4
a553 4
#define MIPS_ELF_ADD_DYNAMIC_ENTRY(info, tag, val)	\
  (ABI_64_P (elf_hash_table (info)->dynobj)		\
   ? (abort (), FALSE)					\
   : bfd_elf32_add_dynamic_entry (info, tag, val))
d683 1
a683 1
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\
d694 4
a697 2
mips_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table, const char *string)
d704 5
a708 3
  if (ret == NULL)
    ret = bfd_hash_allocate (table, sizeof (struct mips_elf_link_hash_entry));
  if (ret == NULL)
d715 1
a715 1
  if (ret != NULL)
d736 3
a738 1
_bfd_mips_elf_new_section_hook (bfd *abfd, asection *sec)
d743 1
a743 1
  sdata = bfd_zalloc (abfd, amt);
d746 1
a746 1
  sec->used_by_bfd = sdata;
d755 4
a758 2
_bfd_mips_elf_read_ecoff_info (bfd *abfd, asection *section,
			       struct ecoff_debug_info *debug)
d762 1
a762 1
  char *ext_hdr;
d767 1
a767 1
  ext_hdr = bfd_malloc (swap->external_hdr_size);
d771 1
a771 1
  if (! bfd_get_section_contents (abfd, section, ext_hdr, 0,
d786 1
a786 1
      debug->ptr = bfd_malloc (amt);					\
d789 1
a789 1
      if (bfd_seek (abfd, symhdr->offset, SEEK_SET) != 0		\
d795 4
a798 4
  READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, void *);
  READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, void *);
  READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, void *);
  READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, void *);
d803 3
a805 3
  READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, void *);
  READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, void *);
  READ (external_ext, cbExtOffset, iextMax, swap->external_ext_size, void *);
d844 4
a847 1
ecoff_swap_rpdr_out (bfd *abfd, const RPDR *in, struct rpdr_ext *ex)
d868 6
a873 3
mips_elf_create_procedure_table (void *handle, bfd *abfd,
				 struct bfd_link_info *info, asection *s,
				 struct ecoff_debug_info *debug)
d879 1
a879 1
  void *rtproc;
d906 1
a906 1
      epdr = bfd_malloc (size * count);
d910 1
a910 1
      if (! _bfd_ecoff_get_accumulated_pdr (handle, (bfd_byte *) epdr))
d914 1
a914 1
      rp = rpdr = bfd_malloc (size * count);
d919 1
a919 1
      sv = bfd_malloc (size * count);
d925 1
a925 1
      esym = bfd_malloc (size * count);
d929 1
a929 1
      if (! _bfd_ecoff_get_accumulated_sym (handle, (bfd_byte *) esym))
d933 1
a933 1
      ss = bfd_malloc (count);
d936 1
a936 1
      if (! _bfd_ecoff_get_accumulated_ss (handle, ss))
d942 2
a943 2
	  (*swap->swap_pdr_in) (abfd, epdr + i, &pdr);
	  (*swap->swap_sym_in) (abfd, &esym[pdr.isym], &sym);
d960 1
a960 1
  rtproc = bfd_alloc (abfd, size);
d969 1
a969 1
  erp = rtproc;
d985 1
a985 1
  s->contents = rtproc;
d989 1
a989 1
  s->link_order_head = NULL;
d1022 3
a1024 2
mips_elf_check_mips16_stubs (struct mips_elf_link_hash_entry *h,
			     void *data ATTRIBUTE_UNUSED)
d1072 9
a1080 3
_bfd_mips_elf_gprel16_with_gp (bfd *abfd, asymbol *symbol,
			       arelent *reloc_entry, asection *input_section,
			       bfd_boolean relocatable, void *data, bfd_vma gp)
d1118 2
a1119 1
      bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);
d1136 4
a1139 2
bfd_mips_elf32_swap_gptab_in (bfd *abfd, const Elf32_External_gptab *ex,
			      Elf32_gptab *in)
d1146 4
a1149 2
bfd_mips_elf32_swap_gptab_out (bfd *abfd, const Elf32_gptab *in,
			       Elf32_External_gptab *ex)
d1156 4
a1159 2
bfd_elf32_swap_compact_rel_out (bfd *abfd, const Elf32_compact_rel *in,
				Elf32_External_compact_rel *ex)
d1170 4
a1173 2
bfd_elf32_swap_crinfo_out (bfd *abfd, const Elf32_crinfo *in,
			   Elf32_External_crinfo *ex)
d1191 4
a1194 2
bfd_mips_elf32_swap_reginfo_in (bfd *abfd, const Elf32_External_RegInfo *ex,
				Elf32_RegInfo *in)
d1205 4
a1208 2
bfd_mips_elf32_swap_reginfo_out (bfd *abfd, const Elf32_RegInfo *in,
				 Elf32_External_RegInfo *ex)
d1225 4
a1228 2
bfd_mips_elf64_swap_reginfo_in (bfd *abfd, const Elf64_External_RegInfo *ex,
				Elf64_Internal_RegInfo *in)
d1240 4
a1243 2
bfd_mips_elf64_swap_reginfo_out (bfd *abfd, const Elf64_Internal_RegInfo *in,
				 Elf64_External_RegInfo *ex)
d1257 4
a1260 2
bfd_mips_elf_swap_options_in (bfd *abfd, const Elf_External_Options *ex,
			      Elf_Internal_Options *in)
d1271 4
a1274 2
bfd_mips_elf_swap_options_out (bfd *abfd, const Elf_Internal_Options *in,
			       Elf_External_Options *ex)
d1286 3
a1288 1
sort_dynamic_relocs (const void *arg1, const void *arg2)
d1302 3
a1304 1
sort_dynamic_relocs_64 (const void *arg1, const void *arg2)
d1334 3
a1336 1
mips_elf_output_extsym (struct mips_elf_link_hash_entry *h, void *data)
d1338 1
a1338 1
  struct extsym_info *einfo = data;
d1516 3
a1518 1
gptab_compare (const void *p1, const void *p2)
d1520 2
a1521 2
  const Elf32_gptab *a1 = p1;
  const Elf32_gptab *a2 = p2;
d1532 2
a1533 1
mips_elf_hash_bfd_vma (bfd_vma addr)
d1547 2
a1548 1
mips_elf_got_entry_hash (const void *entry_)
d1560 3
a1562 1
mips_elf_got_entry_eq (const void *entry1, const void *entry2)
d1579 2
a1580 1
mips_elf_multi_got_entry_hash (const void *entry_)
d1594 3
a1596 1
mips_elf_multi_got_entry_eq (const void *entry1, const void *entry2)
d1611 3
a1613 1
mips_elf_rel_dyn_section (bfd *dynobj, bfd_boolean create_p)
d1640 3
a1642 1
mips_elf_got_section (bfd *abfd, bfd_boolean maybe_excluded)
d1656 3
a1658 1
mips_elf_got_info (bfd *abfd, asection **sgotp)
d1678 2
a1679 1
mips_elf_get_global_gotsym_index (bfd *abfd)
d1703 4
a1706 2
mips_elf_local_got_index (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
			  bfd_vma value)
d1724 3
a1726 1
mips_elf_global_got_index (bfd *abfd, bfd *ibfd, struct elf_link_hash_entry *h)
d1747 1
a1747 1
	  p = htab_find (g->got_entries, &e);
d1776 5
a1780 2
mips_elf_got_page (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
		   bfd_vma value, bfd_vma *offsetp)
d1808 5
a1812 2
mips_elf_got16_entry (bfd *abfd, bfd *ibfd, struct bfd_link_info *info,
		      bfd_vma value, bfd_boolean external)
d1840 5
a1844 2
mips_elf_got_offset_from_index (bfd *dynobj, bfd *output_bfd,
				bfd *input_bfd, bfd_vma index)
d1861 5
a1865 3
mips_elf_create_local_got_entry (bfd *abfd, bfd *ibfd,
				 struct mips_got_info *gg,
				 asection *sgot, bfd_vma value)
d1919 3
a1921 1
mips_elf_sort_hash_table (struct bfd_link_info *info, unsigned long max_local)
d1966 3
a1968 1
mips_elf_sort_hash_table_f (struct mips_elf_link_hash_entry *h, void *data)
d1970 2
a1971 1
  struct mips_elf_hash_sort_data *hsd = data;
d2007 5
a2011 3
mips_elf_record_global_got_symbol (struct elf_link_hash_entry *h,
				   bfd *abfd, struct bfd_link_info *info,
				   struct mips_got_info *g)
d2065 5
a2069 2
mips_elf_record_local_got_symbol (bfd *abfd, long symndx, bfd_vma addend,
				  struct mips_got_info *g)
d2097 2
a2098 1
mips_elf_bfd2got_entry_hash (const void *entry_)
d2109 3
a2111 1
mips_elf_bfd2got_entry_eq (const void *entry1, const void *entry2)
d2125 3
a2127 1
mips_elf_got_for_ibfd (struct mips_got_info *g, bfd *ibfd)
d2135 1
a2135 1
  p = htab_find (g->bfd2got, &e);
d2144 3
a2146 1
mips_elf_make_got_per_bfd (void **entryp, void *p)
d2190 2
a2191 1
					mips_elf_multi_got_entry_eq, NULL);
d2225 3
a2227 1
mips_elf_merge_gots (void **bfd2got_, void *p)
d2266 1
a2266 1
      BFD_ASSERT (old_lcount + lcount >= arg->primary->local_gotno);
d2290 1
a2290 1
      BFD_ASSERT (old_lcount + lcount >= arg->current->local_gotno);
d2321 1
a2321 1
   marked as not eligible for lazy resolution through a function
d2324 3
a2326 1
mips_elf_set_global_got_offset (void **entryp, void *p)
d2341 4
a2359 15
/* Mark any global symbols referenced in the GOT we are iterating over
   as inelligible for lazy resolution stubs.  */
static int
mips_elf_set_no_stub (void **entryp, void *p ATTRIBUTE_UNUSED)
{
  struct mips_got_entry *entry = (struct mips_got_entry *)*entryp;

  if (entry->abfd != NULL
      && entry->symndx == -1
      && entry->d.h->root.dynindx != -1)
    entry->d.h->no_fn_stub = TRUE;

  return 1;
}

d2367 3
a2369 1
mips_elf_resolve_final_got_entry (void **entryp, void *p)
d2411 2
a2412 1
mips_elf_resolve_final_got_entries (struct mips_got_info *g)
d2430 4
a2433 1
mips_elf_adjust_gp (bfd *abfd, struct mips_got_info *g, bfd *ibfd)
d2453 6
a2458 3
mips_elf_multi_got (bfd *abfd, struct bfd_link_info *info,
		    struct mips_got_info *g, asection *got,
		    bfd_size_type pages)
d2466 2
a2467 1
				mips_elf_bfd2got_entry_eq, NULL);
d2512 1
a2512 1
					      NULL);
a2626 5

      /* Mark global symbols in every non-primary GOT as ineligible for
	 stubs.  */
      if (g)
	htab_traverse (g->got_entries, mips_elf_set_no_stub, NULL);
d2641 5
a2645 3
mips_elf_next_relocation (bfd *abfd ATTRIBUTE_UNUSED, unsigned int r_type,
			  const Elf_Internal_Rela *relocation,
			  const Elf_Internal_Rela *relend)
d2669 6
a2674 4
mips_elf_local_relocation_p (bfd *input_bfd,
			     const Elf_Internal_Rela *relocation,
			     asection **local_sections,
			     bfd_boolean check_forced)
d2710 3
a2712 1
_bfd_mips_elf_sign_extend (bfd_vma value, int bits)
d2722 1
a2722 1
   range expressible by a signed number with the indicated number of
d2726 3
a2728 1
mips_elf_overflow_p (bfd_vma value, int bits)
d2746 2
a2747 1
mips_elf_high (bfd_vma value)
d2755 2
a2756 1
mips_elf_higher (bfd_vma value ATTRIBUTE_UNUSED)
d2769 2
a2770 1
mips_elf_highest (bfd_vma value ATTRIBUTE_UNUSED)
d2783 3
a2785 2
mips_elf_create_compact_rel_section
  (bfd *abfd, struct bfd_link_info *info ATTRIBUTE_UNUSED)
d2811 4
a2814 2
mips_elf_create_got_section (bfd *abfd, struct bfd_link_info *info,
			     bfd_boolean maybe_exclude)
d2852 2
a2853 1
	  0, NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
d2866 1
a2866 1
  g = bfd_alloc (abfd, amt);
d2876 2
a2877 1
				    mips_elf_got_entry_eq, NULL);
d2901 17
a2917 9
mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
			       asection *input_section,
			       struct bfd_link_info *info,
			       const Elf_Internal_Rela *relocation,
			       bfd_vma addend, reloc_howto_type *howto,
			       Elf_Internal_Sym *local_syms,
			       asection **local_sections, bfd_vma *valuep,
			       const char **namep, bfd_boolean *require_jalxp,
			       bfd_boolean save_addend)
d3521 5
a3525 3
mips_elf_obtain_contents (reloc_howto_type *howto,
			  const Elf_Internal_Rela *relocation,
			  bfd *input_bfd, bfd_byte *contents)
d3553 10
a3562 6
mips_elf_perform_relocation (struct bfd_link_info *info,
			     reloc_howto_type *howto,
			     const Elf_Internal_Rela *relocation,
			     bfd_vma value, bfd *input_bfd,
			     asection *input_section, bfd_byte *contents,
			     bfd_boolean require_jalx)
d3724 3
a3726 1
mips_elf_stub_section_p (bfd *abfd ATTRIBUTE_UNUSED, asection *section)
d3738 3
a3740 1
mips_elf_allocate_dynamic_relocations (bfd *abfd, unsigned int n)
d3762 10
a3771 6
mips_elf_create_dynamic_relocation (bfd *output_bfd,
				    struct bfd_link_info *info,
				    const Elf_Internal_Rela *rel,
				    struct mips_elf_link_hash_entry *h,
				    asection *sec, bfd_vma symbol,
				    bfd_vma *addendp, asection *input_section)
d3920 1
a3920 1
      outrel[1].r_info = ELF_R_INFO (output_bfd, 0,
d3924 2
a3925 1
      outrel[2].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_NONE);
d3996 2
a3997 1
_bfd_elf_mips_mach (flagword flags)
d4076 2
a4077 1
elf_mips_abi_name (bfd *abfd)
d4124 3
a4126 1
_bfd_mips_elf_symbol_processing (bfd *abfd, asymbol *asym)
d4202 3
a4204 1
_bfd_mips_elf_section_processing (bfd *abfd, Elf_Internal_Shdr *hdr)
d4219 1
a4219 1
      if (bfd_bwrite (buf, 4, abfd) != 4)
d4258 1
a4258 1
	      if (bfd_bwrite (buf, 8, abfd) != 8)
d4273 1
a4273 1
	      if (bfd_bwrite (buf, 4, abfd) != 4)
d4330 4
a4333 2
_bfd_mips_elf_section_from_shdr (bfd *abfd, Elf_Internal_Shdr *hdr,
				 const char *name)
d4428 3
a4430 2
      if (! bfd_get_section_contents (abfd, hdr->bfd_section,
				      &ext, 0, sizeof ext))
d4444 1
a4444 1
      contents = bfd_malloc (hdr->sh_size);
d4448 1
a4448 1
				      0, hdr->sh_size))
d4496 4
a4499 1
_bfd_mips_elf_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec)
d4621 4
a4624 2
_bfd_mips_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
					asection *sec, int *retval)
d4643 8
a4650 4
_bfd_mips_elf_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
			       const Elf_Internal_Sym *sym, const char **namep,
			       flagword *flagsp ATTRIBUTE_UNUSED,
			       asection **secp, bfd_vma *valp)
d4772 2
a4773 1
	     (info, abfd, *namep, BSF_GLOBAL, *secp, *valp, NULL, FALSE,
d4802 6
a4807 4
_bfd_mips_elf_link_output_symbol_hook
  (struct bfd_link_info *info ATTRIBUTE_UNUSED,
   const char *name ATTRIBUTE_UNUSED, Elf_Internal_Sym *sym,
   asection *input_sec, struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d4828 3
a4830 1
_bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d4890 3
a4892 2
		 (info, abfd, *namep, BSF_GLOBAL, bfd_und_section_ptr, 0,
		  NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
d4936 3
a4938 2
	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr, 0,
	     NULL, FALSE, get_elf_backend_data (abfd)->collect, &bh)))
d4961 2
a4962 1
		(info, abfd, name, BSF_GLOBAL, s, 0, NULL, FALSE,
d4983 5
a4987 2
_bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
			    asection *sec, const Elf_Internal_Rela *relocs)
d5046 2
a5047 1
		= _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
d5089 1
a5089 1
	      n = bfd_zalloc (abfd, amt);
d5479 5
a5483 3
_bfd_mips_relax_section (bfd *abfd, asection *sec,
			 struct bfd_link_info *link_info,
			 bfd_boolean *again)
d5501 2
a5502 1
  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
d5611 1
a5611 1
	      contents = bfd_malloc (sec->_raw_size);
d5617 1
a5617 1
					      0, sec->_raw_size))
d5664 3
a5666 2
_bfd_mips_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
				     struct elf_link_hash_entry *h)
d5767 3
a5769 2
_bfd_mips_elf_always_size_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
d5784 2
a5785 1
    bfd_set_section_size (output_bfd, ri, sizeof (Elf32_External_RegInfo));
d5790 2
a5791 1
				 mips_elf_check_mips16_stubs, NULL);
d5860 3
a5862 2
_bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,
				     struct bfd_link_info *info)
d6031 1
a6031 1
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
d6146 10
a6155 5
_bfd_mips_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
				bfd *input_bfd, asection *input_section,
				bfd_byte *contents, Elf_Internal_Rela *relocs,
				Elf_Internal_Sym *local_syms,
				asection **local_sections)
d6175 1
a6175 1
      const char *msg;
d6453 1
a6453 1
		     (info, name, howto->name, 0,
d6534 4
a6537 2
mips_elf_irix6_finish_dynamic_symbol (bfd *abfd ATTRIBUTE_UNUSED,
				      const char *name, Elf_Internal_Sym *sym)
d6586 5
a6590 4
_bfd_mips_elf_finish_dynamic_symbol (bfd *output_bfd,
				     struct bfd_link_info *info,
				     struct elf_link_hash_entry *h,
				     Elf_Internal_Sym *sym)
a6662 1
      bfd_vma entry;
d6664 3
d6674 12
d6693 3
a6695 21
	      if (info->shared
		  || (elf_hash_table (info)->dynamic_sections_created
		      && p->d.h != NULL
		      && ((p->d.h->root.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
		      && ((p->d.h->root.elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)))
		{
		  /* Create an R_MIPS_REL32 relocation for this entry.  Due to
		     the various compatibility problems, it's easier to mock
		     up an R_MIPS_32 or R_MIPS_64 relocation and leave
		     mips_elf_create_dynamic_relocation to calculate the
		     appropriate addend.  */
		  Elf_Internal_Rela rel[3];

		  memset (rel, 0, sizeof (rel));
		  if (ABI_64_P (output_bfd))
		    rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_64);
		  else
		    rel[0].r_info = ELF_R_INFO (output_bfd, 0, R_MIPS_32);
		  rel[0].r_offset = rel[1].r_offset = rel[2].r_offset = offset;
d6697 12
a6708 9
		  entry = 0;
		  if (! (mips_elf_create_dynamic_relocation
			 (output_bfd, info, rel,
			  e.d.h, NULL, sym->st_value, &entry, sgot)))
		    return FALSE;
		}
	      else
		entry = sym->st_value;
	      MIPS_ELF_PUT_WORD (output_bfd, entry, sgot->contents + offset);
d6770 1
a6770 1
	  bfd_put_32 (output_bfd, 0, s->contents);
d6797 3
a6799 2
_bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,
				       struct bfd_link_info *info)
d6969 2
a6970 2
      MIPS_ELF_PUT_WORD (output_bfd, 0, sgot->contents);
      MIPS_ELF_PUT_WORD (output_bfd, 0x80000000,
d6991 1
a6991 1
	  MIPS_ELF_PUT_WORD (output_bfd, 0, sgot->contents
d6993 1
a6993 1
	  MIPS_ELF_PUT_WORD (output_bfd, 0x80000000, sgot->contents
d7059 2
a7060 1
	  qsort ((Elf64_External_Rel *) s->contents + 1, s->reloc_count - 1,
d7063 2
a7064 1
	  qsort ((Elf32_External_Rel *) s->contents + 1, s->reloc_count - 1,
d7076 2
a7077 1
mips_set_isa_flags (bfd *abfd)
d7174 3
a7176 2
_bfd_mips_elf_final_write_processing (bfd *abfd,
				      bfd_boolean linker ATTRIBUTE_UNUSED)
d7262 2
a7263 1
_bfd_mips_elf_additional_program_headers (bfd *abfd)
d7291 2
a7292 2
_bfd_mips_elf_modify_segment_map (bfd *abfd,
				  struct bfd_link_info *info ATTRIBUTE_UNUSED)
d7309 1
a7309 1
	  m = bfd_zalloc (abfd, amt);
d7381 1
a7381 1
		  m = bfd_zalloc (abfd, amt);
d7472 1
a7472 1
	  n = bfd_zalloc (abfd, amt);
d7503 6
a7508 5
_bfd_mips_elf_gc_mark_hook (asection *sec,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED,
			    Elf_Internal_Rela *rel,
			    struct elf_link_hash_entry *h,
			    Elf_Internal_Sym *sym)
d7544 5
a7548 4
_bfd_mips_elf_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			     struct bfd_link_info *info ATTRIBUTE_UNUSED,
			     asection *sec ATTRIBUTE_UNUSED,
			     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
d7594 3
a7596 3
_bfd_mips_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
				    struct elf_link_hash_entry *dir,
				    struct elf_link_hash_entry *ind)
d7615 4
a7618 3
_bfd_mips_elf_hide_symbol (struct bfd_link_info *info,
			   struct elf_link_hash_entry *entry,
			   bfd_boolean force_local)
d7690 4
a7693 2
_bfd_mips_elf_discard_info (bfd *abfd, struct elf_reloc_cookie *cookie,
			    struct bfd_link_info *info)
d7715 2
a7716 1
  cookie->rels = _bfd_elf_link_read_relocs (abfd, o, NULL, NULL,
d7752 2
a7753 1
_bfd_mips_elf_ignore_discarded_relocs (asection *sec)
d7761 4
a7764 2
_bfd_mips_elf_write_section (bfd *output_bfd, asection *sec,
			     bfd_byte *contents)
d7788 2
a7789 1
			    sec->output_offset, sec->_cooked_size);
d7803 9
a7811 5
_bfd_mips_elf_find_nearest_line (bfd *abfd, asection *section,
				 asymbol **symbols, bfd_vma offset,
				 const char **filename_ptr,
				 const char **functionname_ptr,
				 unsigned int *line_ptr)
d7822 2
a7823 1
				     line_ptr, ABI_64_P (abfd) ? 8 : 0,
d7851 1
a7851 1
	  fi = bfd_zalloc (abfd, amt);
d7866 1
a7866 1
	  fi->d.fdr = bfd_alloc (abfd, amt);
d7878 1
a7878 1
	    (*swap->swap_fdr_in) (abfd, fraw_src, fdr_ptr);
d7913 6
a7918 3
_bfd_mips_elf_set_section_contents (bfd *abfd, sec_ptr section,
				    const void *location,
				    file_ptr offset, bfd_size_type count)
d7927 1
a7927 1
	  section->used_by_bfd = bfd_zalloc (abfd, amt);
d7940 1
a7940 1
	  c = bfd_zalloc (abfd, size);
d7946 1
a7946 1
      memcpy (c + offset, location, count);
d7957 8
a7964 7
_bfd_elf_mips_get_relocated_section_contents
  (bfd *abfd,
   struct bfd_link_info *link_info,
   struct bfd_link_order *link_order,
   bfd_byte *data,
   bfd_boolean relocatable,
   asymbol **symbols)
d7977 1
a7977 1
  reloc_vector = bfd_malloc (reloc_size);
d7982 4
a7985 1
  if (!bfd_get_section_contents (input_bfd, input_section, data, 0,
d8048 2
a8049 1
      for (parent = reloc_vector; *parent != NULL; parent++)
d8051 1
a8051 1
	  char *error_message = NULL;
d8072 1
a8072 1
						 data, gp);
d8077 5
a8081 2
	  r = bfd_perform_relocation (input_bfd, *parent, data, input_section,
				      relocatable ? abfd : NULL,
d8106 1
a8106 1
		  BFD_ASSERT (error_message != NULL);
d8141 2
a8142 1
_bfd_mips_elf_link_hash_table_create (bfd *abfd)
d8147 2
a8148 2
  ret = bfd_malloc (amt);
  if (ret == NULL)
d8177 3
a8179 1
_bfd_mips_elf_final_link (bfd *abfd, struct bfd_link_info *info)
d8191 1
a8191 1
  void *mdebug_handle = NULL;
d8287 2
a8288 1
      if (h != NULL && h->type == bfd_link_hash_defined)
d8297 1
a8297 1
	  for (o = abfd->sections; o != NULL; o = o->next)
d8319 1
a8319 1
  for (o = abfd->sections; o != NULL; o = o->next)
d8328 3
a8330 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d8353 3
a8355 1
					      &ext, 0, sizeof ext))
d8380 1
a8380 1
	  o->link_order_head = NULL;
d8424 1
a8424 1
	  if (mdebug_handle == NULL)
d8453 3
a8455 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d8517 1
a8517 1
		  (*input_swap->swap_ext_in) (input_bfd, eraw_src, &ext);
d8586 2
a8587 1
				       mips_elf_output_extsym, &einfo);
d8596 1
a8596 1
	  o->link_order_head = NULL;
d8615 3
a8617 1
	      for (p = o->link_order_head; p != NULL; p = p->next)
d8637 1
a8637 1
	      o->link_order_head = NULL;
d8684 1
a8684 1
	  tab = bfd_malloc (amt);
d8691 3
a8693 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d8728 3
a8730 2
			 (input_bfd, input_section, &ext_gptab, gpentry,
			  sizeof (Elf32_External_gptab))))
d8758 1
a8758 1
		      new_tab = bfd_realloc (tab, amt);
d8801 1
a8801 1
	  ext_tab = bfd_alloc (abfd, amt);
d8817 1
a8817 1
	  o->link_order_head = NULL;
d8827 1
a8827 1
  if (reginfo_sec != NULL)
d8832 3
a8834 1
      if (! bfd_set_section_contents (abfd, reginfo_sec, &ext, 0, sizeof ext))
d8838 1
a8838 1
  if (mdebug_sec != NULL)
d8849 1
a8849 1
  if (gptab_data_sec != NULL)
d8853 2
a8854 1
				      0, gptab_data_sec->_raw_size))
d8858 1
a8858 1
  if (gptab_bss_sec != NULL)
d8862 2
a8863 1
				      0, gptab_bss_sec->_raw_size))
d8874 2
a8875 1
					  0, rtproc_sec->_raw_size))
d8947 2
a8948 1
mips_mach_extends_p (unsigned long base, unsigned long extension)
d8963 2
a8964 1
mips_32bit_flags_p (flagword flags)
d8980 3
a8982 1
_bfd_mips_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
d9187 3
a9189 1
_bfd_mips_elf_set_private_flags (bfd *abfd, flagword flags)
d9200 3
a9202 1
_bfd_mips_elf_print_private_bfd_data (bfd *abfd, void *ptr)
d9204 1
a9204 1
  FILE *file = ptr;
@


1.22.2.14
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1085 1
a1086 1
  bfd_reloc_status_type status;
d1102 7
a1108 1
  _bfd_mips_elf_sign_extend (val, 16);
d1119 2
a1120 5
      status = _bfd_relocate_contents (reloc_entry->howto, abfd, val,
				       (bfd_byte *) data
				       + reloc_entry->address);
      if (status != bfd_reloc_ok)
	return status;
d1127 2
a1128 198

  return bfd_reloc_ok;
}

/* Used to store a REL high-part relocation such as R_MIPS_HI16 or
   R_MIPS_GOT16.  REL is the relocation, INPUT_SECTION is the section
   that contains the relocation field and DATA points to the start of
   INPUT_SECTION.  */

struct mips_hi16
{
  struct mips_hi16 *next;
  bfd_byte *data;
  asection *input_section;
  arelent rel;
};

/* FIXME: This should not be a static variable.  */

static struct mips_hi16 *mips_hi16_list;

/* A howto special_function for REL *HI16 relocations.  We can only
   calculate the correct value once we've seen the partnering
   *LO16 relocation, so just save the information for later.

   The ABI requires that the *LO16 immediately follow the *HI16.
   However, as a GNU extension, we permit an arbitrary number of
   *HI16s to be associated with a single *LO16.  This significantly
   simplies the relocation handling in gcc.  */

bfd_reloc_status_type
_bfd_mips_elf_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			  asymbol *symbol ATTRIBUTE_UNUSED, void *data,
			  asection *input_section, bfd *output_bfd,
			  char **error_message ATTRIBUTE_UNUSED)
{
  struct mips_hi16 *n;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  n = bfd_malloc (sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;

  n->next = mips_hi16_list;
  n->data = data;
  n->input_section = input_section;
  n->rel = *reloc_entry;
  mips_hi16_list = n;

  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* A howto special_function for REL R_MIPS_GOT16 relocations.  This is just
   like any other 16-bit relocation when applied to global symbols, but is
   treated in the same as R_MIPS_HI16 when applied to local symbols.  */

bfd_reloc_status_type
_bfd_mips_elf_got16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			   void *data, asection *input_section,
			   bfd *output_bfd, char **error_message)
{
  if ((symbol->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
      || bfd_is_und_section (bfd_get_section (symbol))
      || bfd_is_com_section (bfd_get_section (symbol)))
    /* The relocation is against a global symbol.  */
    return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
					input_section, output_bfd,
					error_message);

  return _bfd_mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
				   input_section, output_bfd, error_message);
}

/* A howto special_function for REL *LO16 relocations.  The *LO16 itself
   is a straightforward 16 bit inplace relocation, but we must deal with
   any partnering high-part relocations as well.  */

bfd_reloc_status_type
_bfd_mips_elf_lo16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section,
			  bfd *output_bfd, char **error_message)
{
  bfd_vma vallo;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  vallo = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  while (mips_hi16_list != NULL)
    {
      bfd_reloc_status_type ret;
      struct mips_hi16 *hi;

      hi = mips_hi16_list;

      /* R_MIPS_GOT16 relocations are something of a special case.  We
	 want to install the addend in the same way as for a R_MIPS_HI16
	 relocation (with a rightshift of 16).  However, since GOT16
	 relocations can also be used with global symbols, their howto
	 has a rightshift of 0.  */
      if (hi->rel.howto->type == R_MIPS_GOT16)
	hi->rel.howto = MIPS_ELF_RTYPE_TO_HOWTO (abfd, R_MIPS_HI16, FALSE);

      /* VALLO is a signed 16-bit number.  Bias it by 0x8000 so that any
	 carry or borrow will induce a change of +1 or -1 in the high part.  */
      hi->rel.addend += (vallo + 0x8000) & 0xffff;

      /* R_MIPS_GNU_REL_HI16 relocations are relative to the address of the
	 lo16 relocation, not their own address.  If we're calculating the
	 final value, and hence subtracting the "PC", subtract the offset
	 of the lo16 relocation from here.  */
      if (output_bfd == NULL && hi->rel.howto->type == R_MIPS_GNU_REL_HI16)
	hi->rel.addend -= reloc_entry->address - hi->rel.address;

      ret = _bfd_mips_elf_generic_reloc (abfd, &hi->rel, symbol, hi->data,
					 hi->input_section, output_bfd,
					 error_message);
      if (ret != bfd_reloc_ok)
	return ret;

      mips_hi16_list = hi->next;
      free (hi);
    }

  return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				      input_section, output_bfd,
				      error_message);
}

/* A generic howto special_function.  This calculates and installs the
   relocation itself, thus avoiding the oft-discussed problems in
   bfd_perform_relocation and bfd_install_relocation.  */

bfd_reloc_status_type
_bfd_mips_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			     asymbol *symbol, void *data ATTRIBUTE_UNUSED,
			     asection *input_section, bfd *output_bfd,
			     char **error_message ATTRIBUTE_UNUSED)
{
  bfd_signed_vma val;
  bfd_reloc_status_type status;
  bfd_boolean relocatable;

  relocatable = (output_bfd != NULL);

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Build up the field adjustment in VAL.  */
  val = 0;
  if (!relocatable || (symbol->flags & BSF_SECTION_SYM) != 0)
    {
      /* Either we're calculating the final field value or we have a
	 relocation against a section symbol.  Add in the section's
	 offset or address.  */
      val += symbol->section->output_section->vma;
      val += symbol->section->output_offset;
    }

  if (!relocatable)
    {
      /* We're calculating the final field value.  Add in the symbol's value
	 and, if pc-relative, subtract the address of the field itself.  */
      val += symbol->value;
      if (reloc_entry->howto->pc_relative)
	{
	  val -= input_section->output_section->vma;
	  val -= input_section->output_offset;
	  val -= reloc_entry->address;
	}
    }

  /* VAL is now the final adjustment.  If we're keeping this relocation
     in the output file, and if the relocation uses a separate addend,
     we just need to add VAL to that addend.  Otherwise we need to add
     VAL to the relocation field itself.  */
  if (relocatable && !reloc_entry->howto->partial_inplace)
    reloc_entry->addend += val;
  else
    {
      /* Add in the separate addend, if any.  */
      val += reloc_entry->addend;

      /* Add VAL to the relocation field.  */
      status = _bfd_relocate_contents (reloc_entry->howto, abfd, val,
				       (bfd_byte *) data
				       + reloc_entry->address);
      if (status != bfd_reloc_ok)
	return status;
    }

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
d3206 1
a3206 1
      value = symbol + _bfd_mips_elf_sign_extend (addend, 18) - p;
d3229 1
a3229 1
	value = ((addend | ((p + 4) & 0xf0000000)) + symbol) >> 2;
d3231 1
a3231 1
	value = (_bfd_mips_elf_sign_extend (addend, 28) + symbol) >> 2;
d6070 1
a6133 2
	      else
		addend <<= howto->rightshift;
d6173 1
a6173 4
	  if (rela_relocation_p)
	    /* If this is a RELA relocation, just update the addend.  */
	    rel->r_addend = addend;
	  else
d6175 5
a6179 2
	      if (r_type == R_MIPS_HI16
		  || r_type == R_MIPS_GOT16
d6186 1
a6186 2
	      else
		addend >>= howto->rightshift;
d6188 12
a6199 3
	      /* We use the source mask, rather than the destination
		 mask because the place to which we are writing will be
		 source of the addend in the final link.  */
d6262 2
@


1.21
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d6987 2
d7026 1
@


1.20
log
@	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Use the
	IRIX 6 segment layout for NEWABI.
@
text
@d6372 2
a6373 1
_bfd_mips_elf_copy_indirect_symbol (dir, ind)
d6378 1
a6378 1
  _bfd_elf_link_hash_copy_indirect (dir, ind);
@


1.19
log
@	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.
@
text
@d1489 1
a1489 1
  /* Look to see if we aleady have an appropriate entry.  */
d1642 1
a1642 1
     accomodate both the GOT and non-GOT symbols.  */
d3962 1
a3962 1
      /* Change aligments of some sections.  */
d6110 1
a6110 1
     PT_OPTIONS segement immediately following the program header
d6112 1
a6112 1
  if (ABI_64_P (abfd))
d6125 1
a6125 1
	     options segement at the end.  */
d6794 1
a6794 1
	      /* The special_function wouldn't get called anyways.  */
@


1.18
log
@	* elfxx-mips.c (mips_elf_create_dynamic_relocation): Cast signedness
	mismatch.
@
text
@d1449 1
d1452 2
d1459 2
a1460 2
  BFD_ASSERT (h->dynindx >= g->global_gotsym->dynindx);
  index = ((h->dynindx - g->global_gotsym->dynindx + g->local_gotno)
@


1.17
log
@	* elfxx-mips.c (ABI_64_P): Remove superfluous check.
@
text
@d2935 2
a2936 1
      outrel[0].r_info = ELF_R_INFO (output_bfd, indx, R_MIPS_REL32);
@


1.16
log
@[bfd/]
	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Merge ASE
	flags into resulting BFD.

[ld/testsuite/]
	* ld-mips-elf/mips16-1.d,
	* ld-mips-elf/mips16-1[ab].s: New test.
	* ld-mips-elf/mips-elf.exp: Run it.
@
text
@d378 1
a378 1
  ((get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64) != 0)
@


1.15
log
@	* elfxx-mips.c (_bfd_mips_elf_discard_info): New function, code from
	elf32-mips.c.
	(_bfd_mips_elf_write_section): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_discard_info): New prototype.
	(_bfd_mips_elf_write_section): Likewise.
	* elf32-mips.c (elf32_mips_discard_info): Move to elfxx-mips.c.
	(elf32_mips_write_section): Likewise.
	* elf64-mips.c (_bfd_mips_elf_ignore_discarded_relocs): Use it.
	(_bfd_mips_elf_write_section): Likewise.
@
text
@d7806 9
@


1.14
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d6418 64
d6489 33
@


1.14.2.1
log
@        Merge from mainline:
        2002-07-30  Nick Clifton  <nickc@@redhat.com>
        * po/sv.po: Updated Swedish translation.

        2002-07-30  Jakub Jelinek  <jakub@@redhat.com>
        * elf.c (elf_fake_sections): Fix up .tbss sh_size and sh_type.

        2002-07-26  Chris Demetriou  <cgd@@broadcom.com>
        * elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Merge ASE
        flags into resulting BFD.

        2002-07-25  Alan Modra  <amodra@@bigpond.net.au>
        * elf-bfd.h (_bfd_elf32_link_record_local_dynamic_symbol): Define
        as elf_link_record_local_dynamic_symbol.
        (_bfd_elf64_link_record_local_dynamic_symbol): Likewise.
        (elf_link_record_local_dynamic_symbol): Declare.  Now returns int.
        * elflink.h (elf_link_record_local_dynamic_symbol): Move to..
        * elflink.c: .. here.  Use bfd_elf_get_elf_syms.  Check whether an
        attempt is made to record a symbol in a discarded section, and
        return `2' in that case.
@
text
@a7708 9
  /* For now, allow arbitrary mixing of ASEs (retain the union).  */
  if ((new_flags & EF_MIPS_ARCH_ASE) != (old_flags & EF_MIPS_ARCH_ASE))
    {
      elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_ARCH_ASE;

      new_flags &= ~ EF_MIPS_ARCH_ASE;
      old_flags &= ~ EF_MIPS_ARCH_ASE;
    }

@


1.14.2.2
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d6368 1
a6368 2
_bfd_mips_elf_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d6373 1
a6373 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.14.2.3
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@a1448 1
  long global_got_dynindx = 0;
a1450 2
  if (g->global_gotsym != NULL)
    global_got_dynindx = g->global_gotsym->dynindx;
d1456 2
a1457 2
  BFD_ASSERT (h->dynindx >= global_got_dynindx);
  index = ((h->dynindx - global_got_dynindx + g->local_gotno)
@


1.14.2.4
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a1902 1
  struct bfd_link_hash_entry *bh;
d1922 1
a1922 1
  bh = NULL;
d1926 2
a1927 1
	  get_elf_backend_data (abfd)->collect, &bh)))
a1928 2

  h = (struct elf_link_hash_entry *) bh;
a3816 1
      struct bfd_link_hash_entry *bh;
d3819 1
a3819 1
      bh = NULL;
d3823 2
a3824 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a3825 2

      h = (struct elf_link_hash_entry *) bh;
a3880 1
  struct bfd_link_hash_entry *bh;
d3939 1
a3939 1
	  bh = NULL;
d3943 2
a3944 1
		  get_elf_backend_data (abfd)->collect, &bh)))
a3945 2

	  h = (struct elf_link_hash_entry *) bh;
d3981 20
a4000 11
      const char *name;

      name = SGI_COMPAT (abfd) ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING";
      bh = NULL;
      if (!(_bfd_generic_link_add_one_symbol
	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr,
	     (bfd_vma) 0, (const char *) NULL, false,
	     get_elf_backend_data (abfd)->collect, &bh)))
	return false;

      h = (struct elf_link_hash_entry *) bh;
d4017 20
a4036 9
	  name = SGI_COMPAT (abfd) ? "__rld_map" : "__RLD_MAP";
	  bh = NULL;
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, name, BSF_GLOBAL, s,
		 (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect, &bh)))
	    return false;

	  h = (struct elf_link_hash_entry *) bh;
@


1.14.2.5
log
@Merge from mainline.
@
text
@d2940 1
a2940 6
      outrel[0].r_info = ELF_R_INFO (output_bfd, (unsigned long) indx,
				     R_MIPS_REL32);
      outrel[1].r_info = ELF_R_INFO (output_bfd, (unsigned long) 0,
				     R_MIPS_NONE);
      outrel[2].r_info = ELF_R_INFO (output_bfd, (unsigned long) 0,
				     R_MIPS_NONE);
@


1.13
log
@	* elfxx-mips.c (ABI_64_P): Fix comment.
	(MIPS_ELF_OPTIONS_SECTION_NAME,MIPS_ELF_STUB_SECTION_NAME): Use the
	new section names for N64 ABI.
	(mips_elf_output_extsym): No special _gp_disp handling for NewABI.
	(mips_elf_calculate_relocation): Code formatting.
	(mips_elf_create_dynamic_relocation): Likewise.
	(_bfd_mips_elf_fake_sections): IRIX6 needs this hack, too.
	(_bfd_mips_elf_size_dynamic_sections): Handle GOT_PAGE for any NewABI.
	(_bfd_mips_elf_relocate_section): No special handling for R_MIPS_64
	in any NewABI.
	(_bfd_mips_elf_finish_dynamic_symbol): No special _gp_disp handling
	for NewABI.
	(_bfd_mips_elf_modify_segment_map): Handle any N64 ABI.
	(_bfd_mips_elf_gc_sweep_hook): NewABI GOT relocs should be handled
	here, too.
@
text
@d4125 1
a4125 1
	      if (! info->keep_memory)
@


1.12
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@d376 1
a376 1
/* Nonzero if ABFD is using the 64-bit ABI. */
d380 4
a386 2
#define NEWABI_P(abfd) (ABI_N32_P(abfd) || ABI_64_P(abfd))

d393 1
a393 1
  (IRIX_COMPAT (abfd) == ict_irix6 ? ".MIPS.options" : ".options")
d397 1
a397 1
  (IRIX_COMPAT (abfd) == ict_irix6 ? ".MIPS.stubs" : ".stub")
d1247 1
a1247 1
	  else if (strcmp (name, "_gp_disp") == 0)
d2478 1
a2478 2
					      abfd,
					      value);
d2520 1
a2520 2
					      abfd,
					      value);
d2833 1
a2833 2
  sreloc
    = bfd_get_section_by_name (dynobj, ".rel.dyn");
d3643 2
a3644 1
  if (IRIX_COMPAT (abfd) != ict_irix5 && (sec->flags & SEC_RELOC) != 0)
d4772 1
a4772 1
	  if (IRIX_COMPAT (output_bfd) == ict_irix6)
d5007 1
a5007 1
      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
d5124 1
a5124 1
	  if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd)
d5300 1
a5300 1
      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
d5528 1
a5528 1
  else if (strcmp (name, "_gp_disp") == 0)
d6108 1
a6108 1
  if (IRIX_COMPAT (abfd) == ict_irix6)
d6346 3
@


1.11
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d6277 2
a6278 2
_bfd_mips_elf_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d6288 1
a6288 1
      switch (ELF_R_TYPE (abfd, rel->r_info))
d6310 1
a6310 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.10
log
@	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Simplify code.
	Fix RELA addends to get not shifted in the result. Don't do special
	handling of R_MIPS_64 for NewABI.
@
text
@d613 2
a614 3
  if (bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				swap->external_hdr_size)
      == false)
d7549 1
a7549 1
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
@


1.9
log
@* elf32-mips.c (elf32_mips_ignore_discarded_relocs): Move to...
elfxx-mips.c (_bfd_mips_elf_ignore_discarded_relocs): ... here.
elf64-mips.c (elf_backend_ignore_discarded_relocs): Use
_bfd_mips_elf_ignore_discarded_relocs.
elfxx-mips.h (_bfd_mips_elf_ignore_discarded_relocs): Declare.
@
text
@d5016 1
a5016 2
	  howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, R_MIPS_32,
					   NEWABI_P (input_bfd));
d5051 1
d5084 1
a5084 2
		  lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, lo,
							rela_relocation_p);
d5088 1
a5146 7
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS16_26
		   || r_type == R_MIPS_GNU_REL16_S2)
	    /* The addend is stored without its two least
	       significant bits (which are always zero.)  In a
	       non-relocateable link, calculate_relocation will do
	       this shift; here, we must do it ourselves.  */
	    addend <<= 2;
d5154 14
a5167 17
	  /* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16,
	     then we only want to write out the high-order 16 bits.
	     The subsequent R_MIPS_LO16 will handle the low-order bits.  */
	  if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16
	      || r_type == R_MIPS_GNU_REL_HI16)
	    addend = mips_elf_high (addend);
	  else if (r_type == R_MIPS_HIGHER)
	    addend = mips_elf_higher (addend);
	  else if (r_type == R_MIPS_HIGHEST)
	    addend = mips_elf_highest (addend);

	  /* If the relocation is for an R_MIPS_26 relocation, then
	     the two low-order bits are not stored in the object file;
	     they are implicitly zero.  */
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS16_26
		   || r_type == R_MIPS_GNU_REL16_S2)
	    addend >>= 2;
d5180 1
d5183 1
a5183 1
	      if (r_type == R_MIPS_64 && !ABI_64_P (output_bfd))
d5243 2
@


1.8
log
@2002-06-05  H.J. Lu <hjl@@gnu.org>

	* elfxx-mips.c (mips_elf_calculate_relocation): Call
	_bfd_elf_rel_local_sym for STT_SECTION relocations against
	the SEC_MERGE section.
@
text
@d6425 9
@


1.7
log
@	* elf.c (bfd_section_from_shdr): Make "name" const.
	* elf-bfd.h (elf_backend_section_from_shdr): Likewise.
	* elf32-i370.c (i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-ppc.c (ppc64_elf_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d2085 2
a2086 1
      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
d2088 7
@


1.6
log
@* elfxx-mips.c (ABI_64_P): Use backend's data to determine the
ABI.
@
text
@d3354 1
a3354 1
     char *name;
@


1.5
log
@	* elfxx-mips.c: Call it IRIX, not Irix in comments.
@
text
@d378 1
a378 1
  ((elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64) != 0)
@


1.5.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d378 1
a378 1
  ((get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64) != 0)
d2085 1
a2085 2
      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION
	  || (sec->flags & SEC_MERGE))
a2086 7
      if ((sec->flags & SEC_MERGE)
	  && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	{
	  addend = _bfd_elf_rel_local_sym (abfd, sym, &sec, addend);
	  addend -= symbol;
	  addend += sec->output_section->vma + sec->output_offset;
	}
d3354 1
a3354 1
     const char *name;
d5008 2
a5009 1
	  howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, R_MIPS_32, false);
a5043 1
	      addend <<= howto->rightshift;
d5076 2
a5077 1
		  lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, lo, false);
a5080 1
		  l <<= lo16_howto->rightshift;
d5139 7
d5153 17
a5169 14
	  if (howto->partial_inplace)
	    {
	      /* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16,
		 then we only want to write out the high-order 16 bits.
		 The subsequent R_MIPS_LO16 will handle the low-order bits.
	       */
	      if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16
		  || r_type == R_MIPS_GNU_REL_HI16)
		addend = mips_elf_high (addend);
	      else if (r_type == R_MIPS_HIGHER)
		addend = mips_elf_higher (addend);
	      else if (r_type == R_MIPS_HIGHEST)
		addend = mips_elf_highest (addend);
	    }
a5181 1
	      addend >>= howto->rightshift;
d5184 1
a5184 1
	      if (r_type == R_MIPS_64 && ! NEWABI_P (output_bfd))
a5244 2
      addend >>= howto->rightshift;

a6414 9
}

boolean
_bfd_mips_elf_ignore_discarded_relocs (sec)
     asection *sec;
{
  if (strcmp (sec->name, ".pdr") == 0)
    return true;
  return false;
@


1.5.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d376 1
a376 1
/* Nonzero if ABFD is using the N64 ABI.  */
a379 4
/* Nonzero if ABFD is using NewABI conventions.  */
#define NEWABI_P(abfd) (ABI_N32_P (abfd) || ABI_64_P (abfd))

/* The IRIX compatibility level we are striving for.  */
d383 2
d391 1
a391 1
  (ABI_64_P (abfd) ? ".MIPS.options" : ".options")
d395 1
a395 1
  (ABI_64_P (abfd) ? ".MIPS.stubs" : ".stub")
d613 3
a615 2
  if (! bfd_get_section_contents (abfd, section, ext_hdr, (file_ptr) 0,
				  swap->external_hdr_size))
d1246 1
a1246 1
	  else if (strcmp (name, "_gp_disp") == 0 && ! NEWABI_P (einfo->abfd))
d2477 2
a2478 1
					      abfd, value);
d2520 2
a2521 1
					      abfd, value);
d2834 2
a2835 1
  sreloc = bfd_get_section_by_name (dynobj, ".rel.dyn");
d3645 1
a3645 2
  if ((IRIX_COMPAT (abfd) != ict_irix5 && (IRIX_COMPAT (abfd) != ict_irix6))
      && (sec->flags & SEC_RELOC) != 0)
d4126 1
a4126 1
	      if (elf_section_data (o)->relocs != sec_relocs)
d4773 1
a4773 1
	  if (NEWABI_P (output_bfd))
d5008 1
a5008 1
      if (r_type == R_MIPS_64 && ! NEWABI_P (input_bfd))
d5125 1
a5125 1
	  if (r_type == R_MIPS_64 && ! NEWABI_P (output_bfd)
d5301 1
a5301 1
      if (r_type == R_MIPS_64 && ! NEWABI_P (output_bfd))
d5529 1
a5529 1
  else if (strcmp (name, "_gp_disp") == 0 && ! NEWABI_P (output_bfd))
d6109 1
a6109 1
  if (ABI_64_P (abfd))
d6278 2
a6279 2
_bfd_mips_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d6289 1
a6289 1
      switch (ELF_R_TYPE (sec->owner, rel->r_info))
d6311 3
a6313 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
a6348 3
      case R_MIPS_GOT_DISP:
      case R_MIPS_GOT_PAGE:
      case R_MIPS_GOT_OFST:
a6417 64
#define PDR_SIZE 32

boolean
_bfd_mips_elf_discard_info (abfd, cookie, info)
     bfd *abfd;
     struct elf_reloc_cookie *cookie;
     struct bfd_link_info *info;
{
  asection *o;
  boolean ret = false;
  unsigned char *tdata;
  size_t i, skip;

  o = bfd_get_section_by_name (abfd, ".pdr");
  if (! o)
    return false;
  if (o->_raw_size == 0)
    return false;
  if (o->_raw_size % PDR_SIZE != 0)
    return false;
  if (o->output_section != NULL
      && bfd_is_abs_section (o->output_section))
    return false;

  tdata = bfd_zmalloc (o->_raw_size / PDR_SIZE);
  if (! tdata)
    return false;

  cookie->rels = _bfd_elf32_link_read_relocs (abfd, o, (PTR) NULL,
					      (Elf_Internal_Rela *) NULL,
					      info->keep_memory);
  if (!cookie->rels)
    {
      free (tdata);
      return false;
    }

  cookie->rel = cookie->rels;
  cookie->relend = cookie->rels + o->reloc_count;

  for (i = 0, skip = 0; i < o->_raw_size; i ++)
    {
      if (_bfd_elf32_reloc_symbol_deleted_p (i * PDR_SIZE, cookie))
	{
	  tdata[i] = 1;
	  skip ++;
	}
    }

  if (skip != 0)
    {
      elf_section_data (o)->tdata = tdata;
      o->_cooked_size = o->_raw_size - skip * PDR_SIZE;
      ret = true;
    }
  else
    free (tdata);

  if (! info->keep_memory)
    free (cookie->rels);

  return ret;
}

a6425 33

boolean
_bfd_mips_elf_write_section (output_bfd, sec, contents)
     bfd *output_bfd;
     asection *sec;
     bfd_byte *contents;
{
  bfd_byte *to, *from, *end;
  int i;

  if (strcmp (sec->name, ".pdr") != 0)
    return false;

  if (elf_section_data (sec)->tdata == NULL)
    return false;

  to = contents;
  end = contents + sec->_raw_size;
  for (from = contents, i = 0;
       from < end;
       from += PDR_SIZE, i++)
    {
      if (((unsigned char *) elf_section_data (sec)->tdata)[i] == 1)
	continue;
      if (to != from)
	memcpy (to, from, PDR_SIZE);
      to += PDR_SIZE;
    }
  bfd_set_section_contents (output_bfd, sec->output_section, contents,
			    (file_ptr) sec->output_offset,
			    sec->_cooked_size);
  return true;
}
d7550 1
a7550 1
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
@


1.5.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d378 1
a378 1
  (get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64)
a1448 1
  long global_got_dynindx = 0;
a1450 2
  if (g->global_gotsym != NULL)
    global_got_dynindx = g->global_gotsym->dynindx;
d1456 2
a1457 2
  BFD_ASSERT (h->dynindx >= global_got_dynindx);
  index = ((h->dynindx - global_got_dynindx + g->local_gotno)
d2935 1
a2935 2
      outrel[0].r_info = ELF_R_INFO (output_bfd, (unsigned long) indx,
				     R_MIPS_REL32);
a7803 9
    }

  /* For now, allow arbitrary mixing of ASEs (retain the union).  */
  if ((new_flags & EF_MIPS_ARCH_ASE) != (old_flags & EF_MIPS_ARCH_ASE))
    {
      elf_elfheader (obfd)->e_flags |= new_flags & EF_MIPS_ARCH_ASE;

      new_flags &= ~ EF_MIPS_ARCH_ASE;
      old_flags &= ~ EF_MIPS_ARCH_ASE;
@


1.5.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1489 1
a1489 1
  /* Look to see if we already have an appropriate entry.  */
d1642 1
a1642 1
     accommodate both the GOT and non-GOT symbols.  */
d3962 1
a3962 1
      /* Change alignments of some sections.  */
d6110 1
a6110 1
     PT_OPTIONS segment immediately following the program header
d6112 1
a6112 1
  if (NEWABI_P (abfd))
d6125 1
a6125 1
	     options segment at the end.  */
d6372 1
a6372 2
_bfd_mips_elf_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d6377 1
a6377 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d6794 1
a6794 1
	      /* The special_function wouldn't get called anyway.  */
@


1.5.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a366 1
static boolean _bfd_mips_elf_mach_extends_p PARAMS ((flagword, flagword));
a3060 3
    case E_MIPS_MACH_4120:
      return bfd_mach_mips4120;

a3063 6
    case E_MIPS_MACH_5400:
      return bfd_mach_mips5400;

    case E_MIPS_MACH_5500:
      return bfd_mach_mips5500;

d3647 1
a3647 1
  if (! SGI_COMPAT (abfd) && ! NEWABI_P(abfd)
a5937 4
    case bfd_mach_mips4120:
      val = E_MIPS_ARCH_3 | E_MIPS_MACH_4120;
      break;

a5941 8
    case bfd_mach_mips5400:
      val = E_MIPS_ARCH_4 | E_MIPS_MACH_5400;
      break;

    case bfd_mach_mips5500:
      val = E_MIPS_ARCH_4 | E_MIPS_MACH_5500;
      break;

a6986 2
#if 0
  /* We want to set the GP value for ld -r.  */
a7023 1
#endif
a7636 20
/* Return true if machine EXTENSION is an extension of machine BASE,
   meaning that it should be safe to link code for the two machines
   and set the output machine to EXTENSION.  EXTENSION and BASE are
   both submasks of EF_MIPS_MACH.  */

static boolean
_bfd_mips_elf_mach_extends_p (base, extension)
     flagword base, extension;
{
  /* The vr5500 ISA is an extension of the core vr5400 ISA, but doesn't
     include the multimedia stuff.  It seems better to allow vr5400
     and vr5500 code to be merged anyway, since many libraries will
     just use the core ISA.  Perhaps we could add some sort of ASE
     flag if this ever proves a problem.  */
  return (base == 0
	  || (base == E_MIPS_MACH_5400 && extension == E_MIPS_MACH_5500)
	  || (base == E_MIPS_MACH_4100 && extension == E_MIPS_MACH_4111)
	  || (base == E_MIPS_MACH_4100 && extension == E_MIPS_MACH_4120));
}

d7743 4
a7746 3
      if (new_mach == old_mach
	  || _bfd_mips_elf_mach_extends_p (new_mach, old_mach)
	  || _bfd_mips_elf_mach_extends_p (old_mach, new_mach))
d7763 2
a7764 5
	      if (_bfd_mips_elf_mach_extends_p (old_mach, new_mach))
		{
		  elf_elfheader (obfd)->e_flags &= ~EF_MIPS_MACH;
		  elf_elfheader (obfd)->e_flags |= new_mach;
		}
@


1.5.2.6
log
@merge from mainline
@
text
@d348 1
a348 1
	   boolean *, boolean));
a1903 1
  struct bfd_link_hash_entry *bh;
d1923 1
a1923 1
  bh = NULL;
d1927 2
a1928 1
	  get_elf_backend_data (abfd)->collect, &bh)))
a1929 2

  h = (struct elf_link_hash_entry *) bh;
d2007 1
a2007 1
			       require_jalxp, save_addend)
a2019 1
     boolean save_addend;
d2044 1
a2044 1
  boolean local_p, was_local_p;
a2071 1
  was_local_p = local_p;
d2459 4
a2462 13
      /* Only sign-extend the addend if it was extracted from the
	 instruction.  If the addend was separate, leave it alone,
	 otherwise we may lose significant bits.  */
      if (howto->partial_inplace)
	addend = mips_elf_sign_extend (addend, 16);
      value = symbol + addend - gp;
      /* If the symbol was local, any earlier relocatable links will
	 have adjusted its addend with the gp offset, so compensate
	 for that now.  Don't do it for symbols forced local in this
	 link, though, since they won't have had the gp offset applied
	 to them before.  */
      if (was_local_p)
	value += gp0;
d2495 1
a2495 3
      value = (addend + symbol + gp0 - gp);
      if (!save_addend)
	value &= howto->dst_mask;
a2940 6
      outrel[1].r_info = ELF_R_INFO (output_bfd, (unsigned long) 0,
				     ABI_64_P (output_bfd)
				     ? R_MIPS_64
				     : R_MIPS_NONE);
      outrel[2].r_info = ELF_R_INFO (output_bfd, (unsigned long) 0,
				     R_MIPS_NONE);
a3827 1
      struct bfd_link_hash_entry *bh;
d3830 1
a3830 1
      bh = NULL;
d3834 2
a3835 1
	      get_elf_backend_data (abfd)->collect, &bh)))
a3836 2

      h = (struct elf_link_hash_entry *) bh;
a3891 1
  struct bfd_link_hash_entry *bh;
d3950 1
a3950 1
	  bh = NULL;
d3954 2
a3955 1
		  get_elf_backend_data (abfd)->collect, &bh)))
a3956 2

	  h = (struct elf_link_hash_entry *) bh;
d3992 20
a4011 11
      const char *name;

      name = SGI_COMPAT (abfd) ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING";
      bh = NULL;
      if (!(_bfd_generic_link_add_one_symbol
	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr,
	     (bfd_vma) 0, (const char *) NULL, false,
	     get_elf_backend_data (abfd)->collect, &bh)))
	return false;

      h = (struct elf_link_hash_entry *) bh;
d4028 20
a4047 9
	  name = SGI_COMPAT (abfd) ? "__rld_map" : "__RLD_MAP";
	  bh = NULL;
	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, name, BSF_GLOBAL, s,
		 (bfd_vma) 0, (const char *) NULL, false,
		 get_elf_backend_data (abfd)->collect, &bh)))
	    return false;

	  h = (struct elf_link_hash_entry *) bh;
d5264 1
a5264 2
					     &name, &require_jalx,
					     use_saved_addend_p))
d6134 1
a6134 6
  if (NEWABI_P (abfd)
      /* On non-IRIX6 new abi, we'll have already created a segment
	 for this section, so don't create another.  I'm not sure this
	 is not also the case for IRIX 6, but I can't test it right
	 now.  */
      && IRIX_COMPAT (abfd) == ict_irix6)
@


1.4
log
@2002-05-03  H.J. Lu  (hjl@@gnu.org)

	* elfxx-mips.c (mips_elf_link_hash_entry): Add forced_local.
	(mips_elf_link_hash_newfunc): Initialize forced_local to false.
	(mips_elf_record_global_got_symbol): Call _bfd_mips_elf_hide_symbol
	to hide a global symbol.
	(_bfd_mips_elf_hide_symbol): Return if forced_local is true. Set
	forced_local to true.
@
text
@d138 1
a138 1
     entry is set to the address of __rld_obj_head as in Irix 5.  */
d157 1
a157 1
/* The names of the runtime procedure table symbols used on Irix 5.  */
d168 1
a168 1
   Irix 5.  */
d2414 1
a2414 1
	     for overflow.  But, on, say, Irix 5, relocations against
d3545 1
a3545 1
      /* In a shared object on Irix 5.3, the .mdebug section has an
d3555 1
a3555 1
      /* In a shared object on Irix 5.3, the .reginfo section has an
d3575 1
a3575 1
      /* This isn't how the Irix 6 linker behaves.  */
d3696 1
a3696 1
      /* Skip Irix 5 rld entry name.  */
d4793 1
a4793 1
	  /* Irix rld assumes that the function stub isn't at the end
d5788 1
a5788 1
     This isn't the case of Irix rld.  */
d6033 1
a6033 1
/* When creating an Irix 5 executable, we need REGINFO and RTPROC
d6063 1
a6063 1
/* Modify the segment map for an Irix 5 executable.  */
d6186 1
a6186 1
      /* On Irix 5, the PT_DYNAMIC segment includes the .dynamic,
@


1.4.4.1
log
@merge from trunk
@
text
@d138 1
a138 1
     entry is set to the address of __rld_obj_head as in IRIX5.  */
d157 1
a157 1
/* The names of the runtime procedure table symbols used on IRIX5.  */
d168 1
a168 1
   IRIX5.  */
d378 1
a378 1
  ((get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64) != 0)
d2085 1
a2085 2
      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION
	  || (sec->flags & SEC_MERGE))
a2086 7
      if ((sec->flags & SEC_MERGE)
	  && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	{
	  addend = _bfd_elf_rel_local_sym (abfd, sym, &sec, addend);
	  addend -= symbol;
	  addend += sec->output_section->vma + sec->output_offset;
	}
d2414 1
a2414 1
	     for overflow.  But, on, say, IRIX5, relocations against
d3354 1
a3354 1
     const char *name;
d3545 1
a3545 1
      /* In a shared object on IRIX 5.3, the .mdebug section has an
d3555 1
a3555 1
      /* In a shared object on IRIX 5.3, the .reginfo section has an
d3575 1
a3575 1
      /* This isn't how the IRIX6 linker behaves.  */
d3696 1
a3696 1
      /* Skip IRIX5 rld entry name.  */
d4793 1
a4793 1
	  /* IRIX rld assumes that the function stub isn't at the end
d5008 2
a5009 1
	  howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, R_MIPS_32, false);
a5043 1
	      addend <<= howto->rightshift;
d5076 2
a5077 1
		  lo16_howto = MIPS_ELF_RTYPE_TO_HOWTO (input_bfd, lo, false);
a5080 1
		  l <<= lo16_howto->rightshift;
d5139 7
d5153 17
a5169 14
	  if (howto->partial_inplace)
	    {
	      /* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16,
		 then we only want to write out the high-order 16 bits.
		 The subsequent R_MIPS_LO16 will handle the low-order bits.
	       */
	      if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16
		  || r_type == R_MIPS_GNU_REL_HI16)
		addend = mips_elf_high (addend);
	      else if (r_type == R_MIPS_HIGHER)
		addend = mips_elf_higher (addend);
	      else if (r_type == R_MIPS_HIGHEST)
		addend = mips_elf_highest (addend);
	    }
a5181 1
	      addend >>= howto->rightshift;
d5184 1
a5184 1
	      if (r_type == R_MIPS_64 && ! NEWABI_P (output_bfd))
a5244 2
      addend >>= howto->rightshift;

d5788 1
a5788 1
     This isn't the case of IRIX rld.  */
d6033 1
a6033 1
/* When creating an IRIX5 executable, we need REGINFO and RTPROC
d6063 1
a6063 1
/* Modify the segment map for an IRIX5 executable.  */
d6186 1
a6186 1
      /* On IRIX5, the PT_DYNAMIC segment includes the .dynamic,
a6414 9
}

boolean
_bfd_mips_elf_ignore_discarded_relocs (sec)
     asection *sec;
{
  if (strcmp (sec->name, ".pdr") == 0)
    return true;
  return false;
@


1.3
log
@2002-04-24  Chris G. Demetriou  <cgd@@broadcom.com>

        * elfxx-mips.c (_bfd_mips_elf_print_private_bfd_data): If MDMX or
        MIPS-16 ASE flags are set, print something to indicate that.
@
text
@d118 3
d587 1
d1692 12
a1703 3
  if (h->dynindx == -1
      && !bfd_elf32_link_record_dynamic_symbol (info, h))
    return false;
d6400 1
d6402 4
@


1.2
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d7764 6
@


1.1
log
@
Actually commit the new files ommitted before.
@
text
@d6753 1
a6753 1
  ret = (struct mips_elf_link_hash_table *) bfd_alloc (abfd, amt);
d6760 1
a6760 1
      bfd_release (abfd, ret);
@

