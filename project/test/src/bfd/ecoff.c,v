head	1.79;
access;
symbols
	sid-snapshot-20180601:1.79
	sid-snapshot-20180501:1.79
	sid-snapshot-20180401:1.79
	sid-snapshot-20180301:1.79
	sid-snapshot-20180201:1.79
	sid-snapshot-20180101:1.79
	sid-snapshot-20171201:1.79
	sid-snapshot-20171101:1.79
	sid-snapshot-20171001:1.79
	sid-snapshot-20170901:1.79
	sid-snapshot-20170801:1.79
	sid-snapshot-20170701:1.79
	sid-snapshot-20170601:1.79
	sid-snapshot-20170501:1.79
	sid-snapshot-20170401:1.79
	sid-snapshot-20170301:1.79
	sid-snapshot-20170201:1.79
	sid-snapshot-20170101:1.79
	sid-snapshot-20161201:1.79
	sid-snapshot-20161101:1.79
	sid-snapshot-20160901:1.79
	sid-snapshot-20160801:1.79
	sid-snapshot-20160701:1.79
	sid-snapshot-20160601:1.79
	sid-snapshot-20160501:1.79
	sid-snapshot-20160401:1.79
	sid-snapshot-20160301:1.79
	sid-snapshot-20160201:1.79
	sid-snapshot-20160101:1.79
	sid-snapshot-20151201:1.79
	sid-snapshot-20151101:1.79
	sid-snapshot-20151001:1.79
	sid-snapshot-20150901:1.79
	sid-snapshot-20150801:1.79
	sid-snapshot-20150701:1.79
	sid-snapshot-20150601:1.79
	sid-snapshot-20150501:1.79
	sid-snapshot-20150401:1.79
	sid-snapshot-20150301:1.79
	sid-snapshot-20150201:1.79
	sid-snapshot-20150101:1.79
	sid-snapshot-20141201:1.79
	sid-snapshot-20141101:1.79
	sid-snapshot-20141001:1.79
	sid-snapshot-20140901:1.79
	sid-snapshot-20140801:1.79
	sid-snapshot-20140701:1.79
	sid-snapshot-20140601:1.79
	sid-snapshot-20140501:1.79
	sid-snapshot-20140401:1.79
	sid-snapshot-20140301:1.79
	sid-snapshot-20140201:1.79
	sid-snapshot-20140101:1.79
	sid-snapshot-20131201:1.79
	sid-snapshot-20131101:1.79
	sid-snapshot-20131001:1.79
	binutils-2_24-branch:1.79.0.2
	binutils-2_24-branchpoint:1.79
	binutils-2_21_1:1.71.2.1
	sid-snapshot-20130901:1.79
	gdb_7_6_1-2013-08-30-release:1.77
	sid-snapshot-20130801:1.79
	sid-snapshot-20130701:1.79
	sid-snapshot-20130601:1.79
	sid-snapshot-20130501:1.78
	gdb_7_6-2013-04-26-release:1.77
	sid-snapshot-20130401:1.77
	binutils-2_23_2:1.76
	gdb_7_6-branch:1.77.0.2
	gdb_7_6-2013-03-12-branchpoint:1.77
	sid-snapshot-20130301:1.77
	sid-snapshot-20130201:1.77
	sid-snapshot-20130101:1.77
	sid-snapshot-20121201:1.77
	gdb_7_5_1-2012-11-29-release:1.76
	binutils-2_23_1:1.76
	sid-snapshot-20121101:1.77
	binutils-2_23:1.76
	sid-snapshot-20121001:1.77
	sid-snapshot-20120901:1.77
	gdb_7_5-2012-08-17-release:1.76
	sid-snapshot-20120801:1.76
	binutils-2_23-branch:1.76.0.4
	binutils-2_23-branchpoint:1.76
	gdb_7_5-branch:1.76.0.2
	gdb_7_5-2012-07-18-branchpoint:1.76
	sid-snapshot-20120701:1.75
	sid-snapshot-20120601:1.75
	sid-snapshot-20120501:1.74
	binutils-2_22_branch:1.74.0.6
	gdb_7_4_1-2012-04-26-release:1.74
	sid-snapshot-20120401:1.74
	sid-snapshot-20120301:1.74
	sid-snapshot-20120201:1.74
	gdb_7_4-2012-01-24-release:1.74
	sid-snapshot-20120101:1.74
	gdb_7_4-branch:1.74.0.4
	gdb_7_4-2011-12-13-branchpoint:1.74
	sid-snapshot-20111201:1.74
	binutils-2_22:1.74
	sid-snapshot-20111101:1.74
	sid-snapshot-20111001:1.74
	binutils-2_22-branch:1.74.0.2
	binutils-2_22-branchpoint:1.74
	gdb_7_3_1-2011-09-04-release:1.72
	sid-snapshot-20110901:1.74
	sid-snapshot-20110801:1.74
	gdb_7_3-2011-07-26-release:1.72
	sid-snapshot-20110701:1.73
	sid-snapshot-20110601:1.72
	sid-snapshot-20110501:1.72
	gdb_7_3-branch:1.72.0.2
	gdb_7_3-2011-04-01-branchpoint:1.72
	sid-snapshot-20110401:1.72
	sid-snapshot-20110301:1.72
	sid-snapshot-20110201:1.72
	sid-snapshot-20110101:1.72
	binutils-2_21:1.71
	sid-snapshot-20101201:1.71
	binutils-2_21-branch:1.71.0.2
	binutils-2_21-branchpoint:1.71
	sid-snapshot-20101101:1.71
	sid-snapshot-20101001:1.69
	binutils-2_20_1:1.65
	gdb_7_2-2010-09-02-release:1.68
	sid-snapshot-20100901:1.69
	sid-snapshot-20100801:1.69
	gdb_7_2-branch:1.68.0.4
	gdb_7_2-2010-07-07-branchpoint:1.68
	sid-snapshot-20100701:1.68
	sid-snapshot-20100601:1.68
	sid-snapshot-20100501:1.68
	sid-snapshot-20100401:1.68
	gdb_7_1-2010-03-18-release:1.68
	sid-snapshot-20100301:1.68
	gdb_7_1-branch:1.68.0.2
	gdb_7_1-2010-02-18-branchpoint:1.68
	sid-snapshot-20100201:1.67
	sid-snapshot-20100101:1.67
	gdb_7_0_1-2009-12-22-release:1.65
	sid-snapshot-20091201:1.66
	sid-snapshot-20091101:1.66
	binutils-2_20:1.65
	gdb_7_0-2009-10-06-release:1.65
	sid-snapshot-20091001:1.66
	gdb_7_0-branch:1.65.0.4
	gdb_7_0-2009-09-16-branchpoint:1.65
	arc-sim-20090309:1.60
	binutils-arc-20081103-branch:1.61.0.12
	binutils-arc-20081103-branchpoint:1.61
	binutils-2_20-branch:1.65.0.2
	binutils-2_20-branchpoint:1.65
	sid-snapshot-20090901:1.65
	sid-snapshot-20090801:1.63
	msnyder-checkpoint-072509-branch:1.63.0.4
	msnyder-checkpoint-072509-branchpoint:1.63
	sid-snapshot-20090701:1.63
	dje-cgen-play1-branch:1.63.0.2
	dje-cgen-play1-branchpoint:1.63
	sid-snapshot-20090601:1.63
	sid-snapshot-20090501:1.63
	sid-snapshot-20090401:1.63
	arc-20081103-branch:1.61.0.10
	arc-20081103-branchpoint:1.61
	arc-insight_6_8-branch:1.60.0.10
	arc-insight_6_8-branchpoint:1.60
	insight_6_8-branch:1.60.0.8
	insight_6_8-branchpoint:1.60
	sid-snapshot-20090301:1.62
	binutils-2_19_1:1.61
	sid-snapshot-20090201:1.61
	sid-snapshot-20090101:1.61
	reverse-20081226-branch:1.61.0.8
	reverse-20081226-branchpoint:1.61
	sid-snapshot-20081201:1.61
	multiprocess-20081120-branch:1.61.0.6
	multiprocess-20081120-branchpoint:1.61
	sid-snapshot-20081101:1.61
	binutils-2_19:1.61
	sid-snapshot-20081001:1.61
	reverse-20080930-branch:1.61.0.4
	reverse-20080930-branchpoint:1.61
	binutils-2_19-branch:1.61.0.2
	binutils-2_19-branchpoint:1.61
	sid-snapshot-20080901:1.61
	sid-snapshot-20080801:1.61
	reverse-20080717-branch:1.60.0.6
	reverse-20080717-branchpoint:1.60
	sid-snapshot-20080701:1.60
	msnyder-reverse-20080609-branch:1.60.0.4
	msnyder-reverse-20080609-branchpoint:1.60
	drow-reverse-20070409-branch:1.53.0.4
	drow-reverse-20070409-branchpoint:1.53
	sid-snapshot-20080601:1.60
	sid-snapshot-20080501:1.60
	sid-snapshot-20080403:1.60
	sid-snapshot-20080401:1.60
	gdb_6_8-2008-03-27-release:1.60
	sid-snapshot-20080301:1.60
	gdb_6_8-branch:1.60.0.2
	gdb_6_8-2008-02-26-branchpoint:1.60
	sid-snapshot-20080201:1.59
	sid-snapshot-20080101:1.58
	sid-snapshot-20071201:1.57
	sid-snapshot-20071101:1.57
	gdb_6_7_1-2007-10-29-release:1.57
	gdb_6_7-2007-10-10-release:1.57
	sid-snapshot-20071001:1.57
	gdb_6_7-branch:1.57.0.4
	gdb_6_7-2007-09-07-branchpoint:1.57
	binutils-2_18:1.57
	binutils-2_18-branch:1.57.0.2
	binutils-2_18-branchpoint:1.57
	insight_6_6-20070208-release:1.53
	binutils-csl-coldfire-4_1-32:1.50
	binutils-csl-sourcerygxx-4_1-32:1.50
	gdb_6_6-2006-12-18-release:1.53
	binutils-csl-innovasic-fido-3_4_4-33:1.50
	binutils-csl-sourcerygxx-3_4_4-32:1.40
	binutils-csl-coldfire-4_1-30:1.50
	binutils-csl-sourcerygxx-4_1-30:1.50
	binutils-csl-coldfire-4_1-28:1.50
	binutils-csl-sourcerygxx-4_1-29:1.50
	binutils-csl-sourcerygxx-4_1-28:1.50
	gdb_6_6-branch:1.53.0.2
	gdb_6_6-2006-11-15-branchpoint:1.53
	binutils-csl-arm-2006q3-27:1.50
	binutils-csl-sourcerygxx-4_1-27:1.50
	binutils-csl-arm-2006q3-26:1.50
	binutils-csl-sourcerygxx-4_1-26:1.50
	binutils-csl-sourcerygxx-4_1-25:1.50
	binutils-csl-sourcerygxx-4_1-24:1.50
	binutils-csl-sourcerygxx-4_1-23:1.50
	insight_6_5-20061003-release:1.51
	gdb-csl-symbian-6_4_50_20060226-12:1.49
	binutils-csl-sourcerygxx-4_1-21:1.50
	binutils-csl-arm-2006q3-21:1.50
	binutils-csl-sourcerygxx-4_1-22:1.50
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.50
	binutils-csl-sourcerygxx-4_1-20:1.50
	binutils-csl-arm-2006q3-19:1.50
	binutils-csl-sourcerygxx-4_1-19:1.50
	binutils-csl-sourcerygxx-4_1-18:1.50
	binutils-csl-renesas-4_1-9:1.50
	gdb-csl-sourcerygxx-3_4_4-25:1.48
	binutils-csl-sourcerygxx-3_4_4-25:1.40
	nickrob-async-20060828-mergepoint:1.52
	gdb-csl-symbian-6_4_50_20060226-11:1.49
	binutils-csl-renesas-4_1-8:1.50
	binutils-csl-renesas-4_1-7:1.50
	binutils-csl-renesas-4_1-6:1.50
	gdb-csl-sourcerygxx-4_1-17:1.49
	binutils-csl-sourcerygxx-4_1-17:1.50
	gdb-csl-20060226-branch-local-2:1.49
	gdb-csl-sourcerygxx-4_1-14:1.49
	binutils-csl-sourcerygxx-4_1-14:1.50
	binutils-csl-sourcerygxx-4_1-15:1.50
	gdb-csl-sourcerygxx-4_1-13:1.49
	binutils-csl-sourcerygxx-4_1-13:1.50
	binutils-2_17:1.50
	gdb-csl-sourcerygxx-4_1-12:1.49
	binutils-csl-sourcerygxx-4_1-12:1.50
	gdb-csl-sourcerygxx-3_4_4-21:1.49
	binutils-csl-sourcerygxx-3_4_4-21:1.50
	gdb_6_5-20060621-release:1.51
	binutils-csl-wrs-linux-3_4_4-24:1.40
	binutils-csl-wrs-linux-3_4_4-23:1.40
	gdb-csl-sourcerygxx-4_1-9:1.49
	binutils-csl-sourcerygxx-4_1-9:1.50
	gdb-csl-sourcerygxx-4_1-8:1.49
	binutils-csl-sourcerygxx-4_1-8:1.50
	gdb-csl-sourcerygxx-4_1-7:1.49
	binutils-csl-sourcerygxx-4_1-7:1.50
	gdb-csl-arm-2006q1-6:1.49
	binutils-csl-arm-2006q1-6:1.50
	gdb-csl-sourcerygxx-4_1-6:1.49
	binutils-csl-sourcerygxx-4_1-6:1.50
	binutils-csl-wrs-linux-3_4_4-22:1.40
	gdb-csl-symbian-6_4_50_20060226-10:1.49
	gdb-csl-symbian-6_4_50_20060226-9:1.49
	gdb-csl-symbian-6_4_50_20060226-8:1.49
	gdb-csl-coldfire-4_1-11:1.49
	binutils-csl-coldfire-4_1-11:1.50
	gdb-csl-sourcerygxx-3_4_4-19:1.49
	binutils-csl-sourcerygxx-3_4_4-19:1.50
	gdb-csl-coldfire-4_1-10:1.49
	gdb_6_5-branch:1.51.0.4
	gdb_6_5-2006-05-14-branchpoint:1.51
	binutils-csl-coldfire-4_1-10:1.50
	gdb-csl-sourcerygxx-4_1-5:1.49
	binutils-csl-sourcerygxx-4_1-5:1.50
	nickrob-async-20060513-branch:1.51.0.2
	nickrob-async-20060513-branchpoint:1.51
	gdb-csl-sourcerygxx-4_1-4:1.49
	binutils-csl-sourcerygxx-4_1-4:1.50
	msnyder-reverse-20060502-branch:1.50.0.10
	msnyder-reverse-20060502-branchpoint:1.50
	binutils-csl-wrs-linux-3_4_4-21:1.40
	gdb-csl-morpho-4_1-4:1.49
	binutils-csl-morpho-4_1-4:1.50
	gdb-csl-sourcerygxx-3_4_4-17:1.49
	binutils-csl-sourcerygxx-3_4_4-17:1.50
	binutils-csl-wrs-linux-3_4_4-20:1.40
	readline_5_1-import-branch:1.50.0.8
	readline_5_1-import-branchpoint:1.50
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.49
	binutils-2_17-branch:1.50.0.6
	binutils-2_17-branchpoint:1.50
	gdb-csl-symbian-20060226-branch:1.49.0.6
	gdb-csl-symbian-20060226-branchpoint:1.49
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.49
	msnyder-reverse-20060331-branch:1.50.0.4
	msnyder-reverse-20060331-branchpoint:1.50
	binutils-csl-2_17-branch:1.50.0.2
	binutils-csl-2_17-branchpoint:1.50
	gdb-csl-available-20060303-branch:1.49.0.4
	gdb-csl-available-20060303-branchpoint:1.49
	gdb-csl-20060226-branch:1.49.0.2
	gdb-csl-20060226-branchpoint:1.49
	gdb_6_4-20051202-release:1.48
	msnyder-fork-checkpoint-branch:1.48.0.8
	msnyder-fork-checkpoint-branchpoint:1.48
	gdb-csl-gxxpro-6_3-branch:1.48.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.48
	gdb_6_4-branch:1.48.0.4
	gdb_6_4-2005-11-01-branchpoint:1.48
	gdb-csl-arm-20051020-branch:1.48.0.2
	gdb-csl-arm-20051020-branchpoint:1.48
	binutils-csl-gxxpro-3_4-branch:1.40.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.40
	binutils-2_16_1:1.40
	msnyder-tracepoint-checkpoint-branch:1.45.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.45
	gdb-csl-arm-20050325-2005-q1b:1.41
	binutils-csl-arm-2005q1b:1.40
	binutils-2_16:1.40
	gdb-csl-arm-20050325-2005-q1a:1.41
	binutils-csl-arm-2005q1a:1.40
	csl-arm-20050325-branch:1.41.0.2
	csl-arm-20050325-branchpoint:1.41
	binutils-csl-arm-2005q1-branch:1.40.0.4
	binutils-csl-arm-2005q1-branchpoint:1.40
	binutils-2_16-branch:1.40.0.2
	binutils-2_16-branchpoint:1.40
	csl-arm-2004-q3d:1.38
	gdb_6_3-20041109-release:1.37
	gdb_6_3-branch:1.37.0.2
	gdb_6_3-20041019-branchpoint:1.37
	csl-arm-2004-q3:1.37
	drow_intercu-merge-20040921:1.37
	drow_intercu-merge-20040915:1.36
	jimb-gdb_6_2-e500-branch:1.35.0.6
	jimb-gdb_6_2-e500-branchpoint:1.35
	gdb_6_2-20040730-release:1.35
	gdb_6_2-branch:1.35.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.35
	gdb_6_1_1-20040616-release:1.32
	binutils-2_15:1.32
	binutils-2_15-branchpoint:1.32
	csl-arm-2004-q1a:1.33
	csl-arm-2004-q1:1.32
	gdb_6_1-2004-04-05-release:1.32
	drow_intercu-merge-20040402:1.32
	drow_intercu-merge-20040327:1.32
	ezannoni_pie-20040323-branch:1.32.0.14
	ezannoni_pie-20040323-branchpoint:1.32
	cagney_tramp-20040321-mergepoint:1.32
	cagney_tramp-20040309-branch:1.32.0.12
	cagney_tramp-20040309-branchpoint:1.32
	gdb_6_1-branch:1.32.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.32
	drow_intercu-20040221-branch:1.32.0.8
	drow_intercu-20040221-branchpoint:1.32
	binutils-2_15-branch:1.32.0.6
	cagney_bfdfile-20040213-branch:1.32.0.4
	cagney_bfdfile-20040213-branchpoint:1.32
	drow-cplus-merge-20040208:1.32
	carlton_dictionary-20040126-merge:1.32
	cagney_bigcore-20040122-branch:1.32.0.2
	cagney_bigcore-20040122-branchpoint:1.32
	drow-cplus-merge-20040113:1.32
	csl-arm-2003-q4:1.32
	drow-cplus-merge-20031224:1.32
	drow-cplus-merge-20031220:1.32
	carlton_dictionary-20031215-merge:1.32
	drow-cplus-merge-20031214:1.32
	carlton-dictionary-20031111-merge:1.30
	gdb_6_0-2003-10-04-release:1.25
	kettenis_sparc-20030918-branch:1.27.0.6
	kettenis_sparc-20030918-branchpoint:1.27
	carlton_dictionary-20030917-merge:1.27
	ezannoni_pie-20030916-branchpoint:1.27
	ezannoni_pie-20030916-branch:1.27.0.4
	cagney_x86i386-20030821-branch:1.27.0.2
	cagney_x86i386-20030821-branchpoint:1.27
	carlton_dictionary-20030805-merge:1.27
	carlton_dictionary-20030627-merge:1.26
	gdb_6_0-branch:1.25.0.4
	gdb_6_0-2003-06-23-branchpoint:1.25
	jimb-ppc64-linux-20030613-branch:1.25.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.25
	binutils-2_14:1.24
	cagney_convert-20030606-branch:1.24.0.28
	cagney_convert-20030606-branchpoint:1.24
	cagney_writestrings-20030508-branch:1.24.0.26
	cagney_writestrings-20030508-branchpoint:1.24
	jimb-ppc64-linux-20030528-branch:1.24.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.24
	carlton_dictionary-20030523-merge:1.24
	cagney_fileio-20030521-branch:1.24.0.22
	cagney_fileio-20030521-branchpoint:1.24
	kettenis_i386newframe-20030517-mergepoint:1.24
	jimb-ppc64-linux-20030509-branch:1.24.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.24
	kettenis_i386newframe-20030504-mergepoint:1.24
	carlton_dictionary-20030430-merge:1.24
	binutils-2_14-branch:1.24.0.18
	binutils-2_14-branchpoint:1.24
	kettenis_i386newframe-20030419-branch:1.24.0.16
	kettenis_i386newframe-20030419-branchpoint:1.24
	carlton_dictionary-20030416-merge:1.24
	cagney_frameaddr-20030409-mergepoint:1.24
	kettenis_i386newframe-20030406-branch:1.24.0.14
	kettenis_i386newframe-20030406-branchpoint:1.24
	cagney_frameaddr-20030403-branchpoint:1.24
	cagney_frameaddr-20030403-branch:1.24.0.12
	cagney_framebase-20030330-mergepoint:1.24
	cagney_framebase-20030326-branch:1.24.0.10
	cagney_framebase-20030326-branchpoint:1.24
	cagney_lazyid-20030317-branch:1.24.0.8
	cagney_lazyid-20030317-branchpoint:1.24
	kettenis-i386newframe-20030316-mergepoint:1.24
	offbyone-20030313-branch:1.24.0.6
	offbyone-20030313-branchpoint:1.24
	kettenis-i386newframe-20030308-branch:1.24.0.4
	kettenis-i386newframe-20030308-branchpoint:1.24
	carlton_dictionary-20030305-merge:1.24
	cagney_offbyone-20030303-branch:1.24.0.2
	cagney_offbyone-20030303-branchpoint:1.24
	carlton_dictionary-20030207-merge:1.24
	interps-20030202-branch:1.23.0.4
	interps-20030202-branchpoint:1.23
	cagney-unwind-20030108-branch:1.23.0.2
	cagney-unwind-20030108-branchpoint:1.23
	binutils-2_13_2_1:1.18.2.2
	binutils-2_13_2:1.18.2.2
	carlton_dictionary-20021223-merge:1.23
	gdb_5_3-2002-12-12-release:1.20
	carlton_dictionary-20021115-merge:1.22
	binutils-2_13_1:1.18.2.2
	kseitz_interps-20021105-merge:1.22
	kseitz_interps-20021103-merge:1.22
	drow-cplus-merge-20021020:1.22
	drow-cplus-merge-20021025:1.22
	carlton_dictionary-20021025-merge:1.22
	carlton_dictionary-20021011-merge:1.22
	drow-cplus-branch:1.21.0.4
	drow-cplus-branchpoint:1.21
	kseitz_interps-20020930-merge:1.21
	carlton_dictionary-20020927-merge:1.21
	carlton_dictionary-branch:1.21.0.2
	carlton_dictionary-20020920-branchpoint:1.21
	sid-20020905-branchpoint:1.20
	sid-20020905-branch:1.20.0.4
	gdb_5_3-branch:1.20.0.2
	gdb_5_3-2002-09-04-branchpoint:1.20
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.4
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.2
	readline_4_3-import-branchpoint:1.19
	binutils-2_13:1.18
	gdb_5_2_1-2002-07-23-release:1.13
	binutils-2_13-branchpoint:1.18
	binutils-2_13-branch:1.18.0.2
	kseitz_interps-20020528-branch:1.15.0.6
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.15.0.4
	cagney_regbuf-20020515-branchpoint:1.15
	binutils-2_12_1:1.13.2.1
	jimb-macro-020506-branch:1.15.0.2
	jimb-macro-020506-branchpoint:1.15
	gdb_5_2-2002-04-29-release:1.13
	binutils-2_12:1.13
	gdb_5_2-branch:1.13.0.4
	gdb_5_2-2002-03-03-branchpoint:1.13
	binutils-2_12-branch:1.13.0.2
	binutils-2_12-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	binutils-2_11_2:1.5.2.1
	binutils-2_11_1:1.5.2.1
	binutils-2_11:1.5
	x86_64versiong3:1.6
	binutils-2_11-branch:1.5.0.2
	insight-precleanup-2001-01-01:1.5
	binutils-2_10_1:1.4
	binutils-2_10:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.4
	gdb_5_0-2000-04-10-branchpoint:1.4
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.79
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.3
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.79
date	2013.05.16.16.34.51;	author ccoutant;	state Exp;
branches;
next	1.78;

1.78
date	2013.04.24.13.19.27;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2012.08.20.14.32.31;	author tromey;	state Exp;
branches;
next	1.76;

1.76
date	2012.07.13.14.22.45;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2012.05.14.19.45.17;	author jwlemke;	state Exp;
branches;
next	1.74;

1.74
date	2011.07.11.15.03.04;	author clm;	state Exp;
branches;
next	1.73;

1.73
date	2011.06.13.00.59.09;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2010.12.13.01.06.16;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2010.10.29.12.10.24;	author hjl;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2010.10.14.01.31.26;	author davek;	state Exp;
branches;
next	1.69;

1.69
date	2010.07.22.14.29.15;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2010.02.08.13.16.24;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2009.12.11.13.42.02;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2009.09.25.19.13.26;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2009.08.06.17.38.00;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2009.03.04.05.50.49;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2009.02.18.18.23.06;	author davek;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2008.01.21.03.48.10;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.15.09.34.48;	author rsandifo;	state Exp;
branches;
next	1.57;

1.57
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.27.11.54.09;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.21.07.49.29;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2005.12.27.03.06.27;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.06.10.35.41;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.05.09.45.54;	author jakub;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.29.14.05.19;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.04.15.53.07;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.04.11.00.09;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.04.07.19.21;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.03.01.05.00;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.16.14.37.15;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.03.11.40.59;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.31.23.13.17;	author bje;	state Exp;
branches;
next	1.38;

1.38
date	2004.10.21.15.28.19;	author hjl;	state Exp;
branches;
next	1.37;

1.37
date	2004.09.17.07.14.25;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.24.04.46.17;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.15.01.24.22;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.24.06.12.24;	author cgd;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.02.22.59.59;	author amodra;	state Exp;
branches
	1.32.8.1;
next	1.31;

1.31
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.04.10.41.51;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.31.05.32.45;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.16.04.11.05;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.29.10.06.39;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.25.06.40.19;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.08.14.06.38;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.04.12.34.07;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.30.08.39.36;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.19.15.38.36;	author nickc;	state Exp;
branches
	1.21.2.1
	1.21.4.1;
next	1.20;

1.20
date	2002.09.02.11.47.42;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.30.05.49.24;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.25.08.47.31;	author nickc;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2002.06.25.06.21.50;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.07.15.04.47;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.04.19.53.35;	author drow;	state Exp;
branches
	1.15.4.1
	1.15.6.1;
next	1.14;

1.14
date	2002.03.28.03.27.42;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.10.12.08.28;	author kazu;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.09.29.12.07.00;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.18.09.57.22;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.15.09.03.13;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.17.03.58.45;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.07.09.15.25;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.21.03.58;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.14.19.37.05;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.22.00.56.55;	author kazu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.09.10.23.25.51;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.07.12.10.29.01;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.11.21.05.43;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.71.2.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	;

1.32.8.1
date	2004.09.16.17.00.19;	author drow;	state Exp;
branches;
next	1.32.8.2;

1.32.8.2
date	2004.09.21.20.44.00;	author drow;	state Exp;
branches;
next	;

1.21.2.1
date	2002.10.11.22.22.47;	author carlton;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.12.23.19.37.35;	author carlton;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2003.02.07.19.17.37;	author carlton;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2003.06.27.21.49.10;	author carlton;	state Exp;
branches;
next	1.21.2.5;

1.21.2.5
date	2003.08.05.17.12.45;	author carlton;	state Exp;
branches;
next	1.21.2.6;

1.21.2.6
date	2003.11.11.23.50.11;	author carlton;	state Exp;
branches;
next	1.21.2.7;

1.21.2.7
date	2003.12.15.23.59.17;	author carlton;	state Exp;
branches;
next	;

1.21.4.1
date	2002.10.26.17.11.57;	author drow;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2003.12.14.20.26.37;	author drow;	state Exp;
branches;
next	;

1.18.2.1
date	2002.09.23.22.12.39;	author drow;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.10.11.08.56.13;	author amodra;	state Exp;
branches;
next	;

1.15.4.1
date	2002.06.15.16.42.35;	author cagney;	state Exp;
branches;
next	;

1.15.6.1
date	2002.06.20.01.29.56;	author kseitz;	state Exp;
branches;
next	1.15.6.2;

1.15.6.2
date	2002.07.22.21.46.41;	author kseitz;	state Exp;
branches;
next	1.15.6.3;

1.15.6.3
date	2002.08.09.18.34.11;	author kseitz;	state Exp;
branches;
next	1.15.6.4;

1.15.6.4
date	2002.10.01.00.45.44;	author kseitz;	state Exp;
branches;
next	1.15.6.5;

1.15.6.5
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	;

1.13.2.1
date	2002.04.04.14.52.56;	author amodra;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.23.03.41.08;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.79
log
@bfd/
	* ecoff.c (ecoff_link_check_archive_element): Add initializers for
	external_ext_size and esize.
@
text
@/* Generic ECOFF (Extended-COFF) routines.
   Copyright 1990-2013 Free Software Foundation, Inc.
   Original version by Per Bothner.
   Full support added by Ian Lance Taylor, ian@@cygnus.com.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "aout/ar.h"
#include "aout/stab_gnu.h"

/* FIXME: We need the definitions of N_SET[ADTB], but aout64.h defines
   some other stuff which we don't want and which conflicts with stuff
   we do want.  */
#include "libaout.h"
#include "aout/aout64.h"
#undef N_ABS
#undef exec_hdr
#undef obj_sym_filepos

#include "coff/internal.h"
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/ecoff.h"
#include "libcoff.h"
#include "libecoff.h"
#include "libiberty.h"

#define streq(a, b)	(strcmp ((a), (b)) == 0)
#define strneq(a, b, n)	(strncmp ((a), (b), (n)) == 0)


/* This stuff is somewhat copied from coffcode.h.  */
static asection bfd_debug_section =
{
  /* name,      id,  index, next, prev, flags, user_set_vma,       */
     "*DEBUG*", 0,   0,     NULL, NULL, 0,     0,
  /* linker_mark, linker_has_input, gc_mark, compress_status,      */
     0,           0,                1,       0,
  /* segment_mark, sec_info_type, use_rela_p,                      */
     0,            0,             0,
  /* sec_flg0, sec_flg1, sec_flg2, sec_flg3, sec_flg4, sec_flg5,   */
     0,        0,        0,        0,        0,        0,
  /* vma, lma, size, rawsize, compressed_size, relax, relax_count, */
     0,   0,   0,    0,       0,               0,     0,
  /* output_offset, output_section, alignment_power,               */
     0,             NULL,           0,
  /* relocation, orelocation, reloc_count, filepos, rel_filepos,   */
     NULL,       NULL,        0,           0,       0,
  /* line_filepos, userdata, contents, lineno, lineno_count,       */
     0,            NULL,     NULL,     NULL,   0,
  /* entsize, kept_section, moving_line_filepos,                   */
     0,       NULL,         0,
  /* target_index, used_by_bfd, constructor_chain, owner,          */
     0,            NULL,        NULL,              NULL,
  /* symbol,                                                       */
     NULL,
  /* symbol_ptr_ptr,                                               */
     NULL,
  /* map_head, map_tail                                            */
     { NULL }, { NULL }
};

/* Create an ECOFF object.  */

bfd_boolean
_bfd_ecoff_mkobject (bfd *abfd)
{
  bfd_size_type amt = sizeof (ecoff_data_type);

  abfd->tdata.ecoff_obj_data = (struct ecoff_tdata *) bfd_zalloc (abfd, amt);
  if (abfd->tdata.ecoff_obj_data == NULL)
    return FALSE;

  return TRUE;
}

/* This is a hook called by coff_real_object_p to create any backend
   specific information.  */

void *
_bfd_ecoff_mkobject_hook (bfd *abfd, void * filehdr, void * aouthdr)
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
  struct internal_aouthdr *internal_a = (struct internal_aouthdr *) aouthdr;
  ecoff_data_type *ecoff;

  if (! _bfd_ecoff_mkobject (abfd))
    return NULL;

  ecoff = ecoff_data (abfd);
  ecoff->gp_size = 8;
  ecoff->sym_filepos = internal_f->f_symptr;

  if (internal_a != NULL)
    {
      int i;

      ecoff->text_start = internal_a->text_start;
      ecoff->text_end = internal_a->text_start + internal_a->tsize;
      ecoff->gp = internal_a->gp_value;
      ecoff->gprmask = internal_a->gprmask;
      for (i = 0; i < 4; i++)
	ecoff->cprmask[i] = internal_a->cprmask[i];
      ecoff->fprmask = internal_a->fprmask;
      if (internal_a->magic == ECOFF_AOUT_ZMAGIC)
	abfd->flags |= D_PAGED;
      else
	abfd->flags &=~ D_PAGED;
    }

  /* It turns out that no special action is required by the MIPS or
     Alpha ECOFF backends.  They have different information in the
     a.out header, but we just copy it all (e.g., gprmask, cprmask and
     fprmask) and let the swapping routines ensure that only relevant
     information is written out.  */

  return (void *) ecoff;
}

/* Initialize a new section.  */

bfd_boolean
_bfd_ecoff_new_section_hook (bfd *abfd, asection *section)
{
  unsigned int i;
  static struct
  {
    const char * name;
    flagword flags;
  }
  section_flags [] =
  {
    { _TEXT,   SEC_ALLOC | SEC_CODE | SEC_LOAD },
    { _INIT,   SEC_ALLOC | SEC_CODE | SEC_LOAD },
    { _FINI,   SEC_ALLOC | SEC_CODE | SEC_LOAD },
    { _DATA,   SEC_ALLOC | SEC_DATA | SEC_LOAD },
    { _SDATA,  SEC_ALLOC | SEC_DATA | SEC_LOAD },
    { _RDATA,  SEC_ALLOC | SEC_DATA | SEC_LOAD | SEC_READONLY},
    { _LIT8,   SEC_ALLOC | SEC_DATA | SEC_LOAD | SEC_READONLY},
    { _LIT4,   SEC_ALLOC | SEC_DATA | SEC_LOAD | SEC_READONLY},
    { _RCONST, SEC_ALLOC | SEC_DATA | SEC_LOAD | SEC_READONLY},
    { _PDATA,  SEC_ALLOC | SEC_DATA | SEC_LOAD | SEC_READONLY},
    { _BSS,    SEC_ALLOC},
    { _SBSS,   SEC_ALLOC},
    /* An Irix 4 shared libary.  */
    { _LIB,    SEC_COFF_SHARED_LIBRARY}
  };

  section->alignment_power = 4;

  for (i = 0; i < ARRAY_SIZE (section_flags); i++)
    if (streq (section->name, section_flags[i].name))
      {
	section->flags |= section_flags[i].flags;
	break;
      }


  /* Probably any other section name is SEC_NEVER_LOAD, but I'm
     uncertain about .init on some systems and I don't know how shared
     libraries work.  */

  return _bfd_generic_new_section_hook (abfd, section);
}

/* Determine the machine architecture and type.  This is called from
   the generic COFF routines.  It is the inverse of ecoff_get_magic,
   below.  This could be an ECOFF backend routine, with one version
   for each target, but there aren't all that many ECOFF targets.  */

bfd_boolean
_bfd_ecoff_set_arch_mach_hook (bfd *abfd, void * filehdr)
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
  enum bfd_architecture arch;
  unsigned long mach;

  switch (internal_f->f_magic)
    {
    case MIPS_MAGIC_1:
    case MIPS_MAGIC_LITTLE:
    case MIPS_MAGIC_BIG:
      arch = bfd_arch_mips;
      mach = bfd_mach_mips3000;
      break;

    case MIPS_MAGIC_LITTLE2:
    case MIPS_MAGIC_BIG2:
      /* MIPS ISA level 2: the r6000.  */
      arch = bfd_arch_mips;
      mach = bfd_mach_mips6000;
      break;

    case MIPS_MAGIC_LITTLE3:
    case MIPS_MAGIC_BIG3:
      /* MIPS ISA level 3: the r4000.  */
      arch = bfd_arch_mips;
      mach = bfd_mach_mips4000;
      break;

    case ALPHA_MAGIC:
      arch = bfd_arch_alpha;
      mach = 0;
      break;

    default:
      arch = bfd_arch_obscure;
      mach = 0;
      break;
    }

  return bfd_default_set_arch_mach (abfd, arch, mach);
}

bfd_boolean
_bfd_ecoff_no_long_sections (bfd *abfd, int enable)
{
  (void) abfd;
  (void) enable;
  return FALSE;
}

/* Get the magic number to use based on the architecture and machine.
   This is the inverse of _bfd_ecoff_set_arch_mach_hook, above.  */

static int
ecoff_get_magic (bfd *abfd)
{
  int big, little;

  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_mips:
      switch (bfd_get_mach (abfd))
	{
	default:
	case 0:
	case bfd_mach_mips3000:
	  big = MIPS_MAGIC_BIG;
	  little = MIPS_MAGIC_LITTLE;
	  break;

	case bfd_mach_mips6000:
	  big = MIPS_MAGIC_BIG2;
	  little = MIPS_MAGIC_LITTLE2;
	  break;

	case bfd_mach_mips4000:
	  big = MIPS_MAGIC_BIG3;
	  little = MIPS_MAGIC_LITTLE3;
	  break;
	}

      return bfd_big_endian (abfd) ? big : little;

    case bfd_arch_alpha:
      return ALPHA_MAGIC;

    default:
      abort ();
      return 0;
    }
}

/* Get the section s_flags to use for a section.  */

static long
ecoff_sec_to_styp_flags (const char *name, flagword flags)
{
  unsigned int i;
  static struct
  {
    const char * name;
    long flags;
  }
  styp_flags [] =
  {
    { _TEXT,    STYP_TEXT       },
    { _DATA,    STYP_DATA       },
    { _SDATA,   STYP_SDATA      },
    { _RDATA,   STYP_RDATA      },
    { _LITA,    STYP_LITA       },
    { _LIT8,    STYP_LIT8       },
    { _LIT4,    STYP_LIT4       },
    { _BSS,     STYP_BSS        },
    { _SBSS,    STYP_SBSS       },
    { _INIT,    STYP_ECOFF_INIT },
    { _FINI,    STYP_ECOFF_FINI },
    { _PDATA,   STYP_PDATA      },
    { _XDATA,   STYP_XDATA      },
    { _LIB,     STYP_ECOFF_LIB  },
    { _GOT,     STYP_GOT        },
    { _HASH,    STYP_HASH       },
    { _DYNAMIC, STYP_DYNAMIC    },
    { _LIBLIST, STYP_LIBLIST    },
    { _RELDYN,  STYP_RELDYN     },
    { _CONFLIC, STYP_CONFLIC    },
    { _DYNSTR,  STYP_DYNSTR     },
    { _DYNSYM,  STYP_DYNSYM     },
    { _RCONST,  STYP_RCONST     }
  };
  long styp = 0;

  for (i = 0; i < ARRAY_SIZE (styp_flags); i++)
    if (streq (name, styp_flags[i].name))
      {
	styp = styp_flags[i].flags;
	break;
      }

  if (styp == 0)
    {
      if (streq (name, _COMMENT))
	{
	  styp = STYP_COMMENT;
	  flags &=~ SEC_NEVER_LOAD;
	}
      else if (flags & SEC_CODE)
	styp = STYP_TEXT;
      else if (flags & SEC_DATA)
	styp = STYP_DATA;
      else if (flags & SEC_READONLY)
	styp = STYP_RDATA;
      else if (flags & SEC_LOAD)
	styp = STYP_REG;
      else
	styp = STYP_BSS;
    }

  if (flags & SEC_NEVER_LOAD)
    styp |= STYP_NOLOAD;

  return styp;
}

/* Get the BFD flags to use for a section.  */

bfd_boolean
_bfd_ecoff_styp_to_sec_flags (bfd *abfd ATTRIBUTE_UNUSED,
			      void * hdr,
			      const char *name ATTRIBUTE_UNUSED,
			      asection *section ATTRIBUTE_UNUSED,
			      flagword * flags_ptr)
{
  struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
  long styp_flags = internal_s->s_flags;
  flagword sec_flags = 0;

  if (styp_flags & STYP_NOLOAD)
    sec_flags |= SEC_NEVER_LOAD;

  /* For 386 COFF, at least, an unloadable text or data section is
     actually a shared library section.  */
  if ((styp_flags & STYP_TEXT)
      || (styp_flags & STYP_ECOFF_INIT)
      || (styp_flags & STYP_ECOFF_FINI)
      || (styp_flags & STYP_DYNAMIC)
      || (styp_flags & STYP_LIBLIST)
      || (styp_flags & STYP_RELDYN)
      || styp_flags == STYP_CONFLIC
      || (styp_flags & STYP_DYNSTR)
      || (styp_flags & STYP_DYNSYM)
      || (styp_flags & STYP_HASH))
    {
      if (sec_flags & SEC_NEVER_LOAD)
	sec_flags |= SEC_CODE | SEC_COFF_SHARED_LIBRARY;
      else
	sec_flags |= SEC_CODE | SEC_LOAD | SEC_ALLOC;
    }
  else if ((styp_flags & STYP_DATA)
	   || (styp_flags & STYP_RDATA)
	   || (styp_flags & STYP_SDATA)
	   || styp_flags == STYP_PDATA
	   || styp_flags == STYP_XDATA
	   || (styp_flags & STYP_GOT)
	   || styp_flags == STYP_RCONST)
    {
      if (sec_flags & SEC_NEVER_LOAD)
	sec_flags |= SEC_DATA | SEC_COFF_SHARED_LIBRARY;
      else
	sec_flags |= SEC_DATA | SEC_LOAD | SEC_ALLOC;
      if ((styp_flags & STYP_RDATA)
	  || styp_flags == STYP_PDATA
	  || styp_flags == STYP_RCONST)
	sec_flags |= SEC_READONLY;
    }
  else if ((styp_flags & STYP_BSS)
	   || (styp_flags & STYP_SBSS))
    sec_flags |= SEC_ALLOC;
  else if ((styp_flags & STYP_INFO) || styp_flags == STYP_COMMENT)
    sec_flags |= SEC_NEVER_LOAD;
  else if ((styp_flags & STYP_LITA)
	   || (styp_flags & STYP_LIT8)
	   || (styp_flags & STYP_LIT4))
    sec_flags |= SEC_DATA | SEC_LOAD | SEC_ALLOC | SEC_READONLY;
  else if (styp_flags & STYP_ECOFF_LIB)
    sec_flags |= SEC_COFF_SHARED_LIBRARY;
  else
    sec_flags |= SEC_ALLOC | SEC_LOAD;

  * flags_ptr = sec_flags;
  return TRUE;
}

/* Read in the symbolic header for an ECOFF object file.  */

static bfd_boolean
ecoff_slurp_symbolic_header (bfd *abfd)
{
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  bfd_size_type external_hdr_size;
  void * raw = NULL;
  HDRR *internal_symhdr;

  /* See if we've already read it in.  */
  if (ecoff_data (abfd)->debug_info.symbolic_header.magic ==
      backend->debug_swap.sym_magic)
    return TRUE;

  /* See whether there is a symbolic header.  */
  if (ecoff_data (abfd)->sym_filepos == 0)
    {
      bfd_get_symcount (abfd) = 0;
      return TRUE;
    }

  /* At this point bfd_get_symcount (abfd) holds the number of symbols
     as read from the file header, but on ECOFF this is always the
     size of the symbolic information header.  It would be cleaner to
     handle this when we first read the file in coffgen.c.  */
  external_hdr_size = backend->debug_swap.external_hdr_size;
  if (bfd_get_symcount (abfd) != external_hdr_size)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  /* Read the symbolic information header.  */
  raw = bfd_malloc (external_hdr_size);
  if (raw == NULL)
    goto error_return;

  if (bfd_seek (abfd, ecoff_data (abfd)->sym_filepos, SEEK_SET) != 0
      || bfd_bread (raw, external_hdr_size, abfd) != external_hdr_size)
    goto error_return;
  internal_symhdr = &ecoff_data (abfd)->debug_info.symbolic_header;
  (*backend->debug_swap.swap_hdr_in) (abfd, raw, internal_symhdr);

  if (internal_symhdr->magic != backend->debug_swap.sym_magic)
    {
      bfd_set_error (bfd_error_bad_value);
      goto error_return;
    }

  /* Now we can get the correct number of symbols.  */
  bfd_get_symcount (abfd) = (internal_symhdr->isymMax
			     + internal_symhdr->iextMax);

  if (raw != NULL)
    free (raw);
  return TRUE;
 error_return:
  if (raw != NULL)
    free (raw);
  return FALSE;
}

/* Read in and swap the important symbolic information for an ECOFF
   object file.  This is called by gdb via the read_debug_info entry
   point in the backend structure.  */

bfd_boolean
_bfd_ecoff_slurp_symbolic_info (bfd *abfd,
				asection *ignore ATTRIBUTE_UNUSED,
				struct ecoff_debug_info *debug)
{
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  HDRR *internal_symhdr;
  bfd_size_type raw_base;
  bfd_size_type raw_size;
  void * raw;
  bfd_size_type external_fdr_size;
  char *fraw_src;
  char *fraw_end;
  struct fdr *fdr_ptr;
  bfd_size_type raw_end;
  bfd_size_type cb_end;
  bfd_size_type amt;
  file_ptr pos;

  BFD_ASSERT (debug == &ecoff_data (abfd)->debug_info);

  /* Check whether we've already gotten it, and whether there's any to
     get.  */
  if (ecoff_data (abfd)->raw_syments != NULL)
    return TRUE;
  if (ecoff_data (abfd)->sym_filepos == 0)
    {
      bfd_get_symcount (abfd) = 0;
      return TRUE;
    }

  if (! ecoff_slurp_symbolic_header (abfd))
    return FALSE;

  internal_symhdr = &debug->symbolic_header;

  /* Read all the symbolic information at once.  */
  raw_base = (ecoff_data (abfd)->sym_filepos
	      + backend->debug_swap.external_hdr_size);

  /* Alpha ecoff makes the determination of raw_size difficult. It has
     an undocumented debug data section between the symhdr and the first
     documented section. And the ordering of the sections varies between
     statically and dynamically linked executables.
     If bfd supports SEEK_END someday, this code could be simplified.  */
  raw_end = 0;

#define UPDATE_RAW_END(start, count, size) \
  cb_end = internal_symhdr->start + internal_symhdr->count * (size); \
  if (cb_end > raw_end) \
    raw_end = cb_end

  UPDATE_RAW_END (cbLineOffset, cbLine, sizeof (unsigned char));
  UPDATE_RAW_END (cbDnOffset, idnMax, backend->debug_swap.external_dnr_size);
  UPDATE_RAW_END (cbPdOffset, ipdMax, backend->debug_swap.external_pdr_size);
  UPDATE_RAW_END (cbSymOffset, isymMax, backend->debug_swap.external_sym_size);
  /* eraxxon@@alumni.rice.edu: ioptMax refers to the size of the
     optimization symtab, not the number of entries.  */
  UPDATE_RAW_END (cbOptOffset, ioptMax, sizeof (char));
  UPDATE_RAW_END (cbAuxOffset, iauxMax, sizeof (union aux_ext));
  UPDATE_RAW_END (cbSsOffset, issMax, sizeof (char));
  UPDATE_RAW_END (cbSsExtOffset, issExtMax, sizeof (char));
  UPDATE_RAW_END (cbFdOffset, ifdMax, backend->debug_swap.external_fdr_size);
  UPDATE_RAW_END (cbRfdOffset, crfd, backend->debug_swap.external_rfd_size);
  UPDATE_RAW_END (cbExtOffset, iextMax, backend->debug_swap.external_ext_size);

#undef UPDATE_RAW_END

  raw_size = raw_end - raw_base;
  if (raw_size == 0)
    {
      ecoff_data (abfd)->sym_filepos = 0;
      return TRUE;
    }
  raw = bfd_alloc (abfd, raw_size);
  if (raw == NULL)
    return FALSE;

  pos = ecoff_data (abfd)->sym_filepos;
  pos += backend->debug_swap.external_hdr_size;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bread (raw, raw_size, abfd) != raw_size)
    {
      bfd_release (abfd, raw);
      return FALSE;
    }

  ecoff_data (abfd)->raw_syments = raw;

  /* Get pointers for the numeric offsets in the HDRR structure.  */
#define FIX(off1, off2, type)				\
  if (internal_symhdr->off1 == 0)			\
    debug->off2 = NULL;					\
  else							\
    debug->off2 = (type) ((char *) raw			\
			  + (internal_symhdr->off1	\
			     - raw_base))

  FIX (cbLineOffset, line, unsigned char *);
  FIX (cbDnOffset, external_dnr, void *);
  FIX (cbPdOffset, external_pdr, void *);
  FIX (cbSymOffset, external_sym, void *);
  FIX (cbOptOffset, external_opt, void *);
  FIX (cbAuxOffset, external_aux, union aux_ext *);
  FIX (cbSsOffset, ss, char *);
  FIX (cbSsExtOffset, ssext, char *);
  FIX (cbFdOffset, external_fdr, void *);
  FIX (cbRfdOffset, external_rfd, void *);
  FIX (cbExtOffset, external_ext, void *);
#undef FIX

  /* I don't want to always swap all the data, because it will just
     waste time and most programs will never look at it.  The only
     time the linker needs most of the debugging information swapped
     is when linking big-endian and little-endian MIPS object files
     together, which is not a common occurrence.

     We need to look at the fdr to deal with a lot of information in
     the symbols, so we swap them here.  */
  amt = internal_symhdr->ifdMax;
  amt *= sizeof (struct fdr);
  debug->fdr = (FDR *) bfd_alloc (abfd, amt);
  if (debug->fdr == NULL)
    return FALSE;
  external_fdr_size = backend->debug_swap.external_fdr_size;
  fdr_ptr = debug->fdr;
  fraw_src = (char *) debug->external_fdr;
  fraw_end = fraw_src + internal_symhdr->ifdMax * external_fdr_size;
  for (; fraw_src < fraw_end; fraw_src += external_fdr_size, fdr_ptr++)
    (*backend->debug_swap.swap_fdr_in) (abfd, (void *) fraw_src, fdr_ptr);

  return TRUE;
}

/* ECOFF symbol table routines.  The ECOFF symbol table is described
   in gcc/mips-tfile.c.  */

/* ECOFF uses two common sections.  One is the usual one, and the
   other is for small objects.  All the small objects are kept
   together, and then referenced via the gp pointer, which yields
   faster assembler code.  This is what we use for the small common
   section.  */
static asection ecoff_scom_section;
static asymbol ecoff_scom_symbol;
static asymbol *ecoff_scom_symbol_ptr;

/* Create an empty symbol.  */

asymbol *
_bfd_ecoff_make_empty_symbol (bfd *abfd)
{
  ecoff_symbol_type *new_symbol;
  bfd_size_type amt = sizeof (ecoff_symbol_type);

  new_symbol = (ecoff_symbol_type *) bfd_zalloc (abfd, amt);
  if (new_symbol == NULL)
    return NULL;
  new_symbol->symbol.section = NULL;
  new_symbol->fdr = NULL;
  new_symbol->local = FALSE;
  new_symbol->native = NULL;
  new_symbol->symbol.the_bfd = abfd;
  return &new_symbol->symbol;
}

/* Set the BFD flags and section for an ECOFF symbol.  */

static bfd_boolean
ecoff_set_symbol_info (bfd *abfd,
		       SYMR *ecoff_sym,
		       asymbol *asym,
		       int ext,
		       int weak)
{
  asym->the_bfd = abfd;
  asym->value = ecoff_sym->value;
  asym->section = &bfd_debug_section;
  asym->udata.i = 0;

  /* Most symbol types are just for debugging.  */
  switch (ecoff_sym->st)
    {
    case stGlobal:
    case stStatic:
    case stLabel:
    case stProc:
    case stStaticProc:
      break;
    case stNil:
      if (ECOFF_IS_STAB (ecoff_sym))
	{
	  asym->flags = BSF_DEBUGGING;
	  return TRUE;
	}
      break;
    default:
      asym->flags = BSF_DEBUGGING;
      return TRUE;
    }

  if (weak)
    asym->flags = BSF_EXPORT | BSF_WEAK;
  else if (ext)
    asym->flags = BSF_EXPORT | BSF_GLOBAL;
  else
    {
      asym->flags = BSF_LOCAL;
      /* Normally, a local stProc symbol will have a corresponding
         external symbol.  We mark the local symbol as a debugging
         symbol, in order to prevent nm from printing both out.
         Similarly, we mark stLabel and stabs symbols as debugging
         symbols.  In both cases, we do want to set the value
         correctly based on the symbol class.  */
      if (ecoff_sym->st == stProc
	  || ecoff_sym->st == stLabel
	  || ECOFF_IS_STAB (ecoff_sym))
	asym->flags |= BSF_DEBUGGING;
    }

  if (ecoff_sym->st == stProc || ecoff_sym->st == stStaticProc)
    asym->flags |= BSF_FUNCTION;

  switch (ecoff_sym->sc)
    {
    case scNil:
      /* Used for compiler generated labels.  Leave them in the
	 debugging section, and mark them as local.  If BSF_DEBUGGING
	 is set, then nm does not display them for some reason.  If no
	 flags are set then the linker whines about them.  */
      asym->flags = BSF_LOCAL;
      break;
    case scText:
      asym->section = bfd_make_section_old_way (abfd, _TEXT);
      asym->value -= asym->section->vma;
      break;
    case scData:
      asym->section = bfd_make_section_old_way (abfd, _DATA);
      asym->value -= asym->section->vma;
      break;
    case scBss:
      asym->section = bfd_make_section_old_way (abfd, _BSS);
      asym->value -= asym->section->vma;
      break;
    case scRegister:
      asym->flags = BSF_DEBUGGING;
      break;
    case scAbs:
      asym->section = bfd_abs_section_ptr;
      break;
    case scUndefined:
      asym->section = bfd_und_section_ptr;
      asym->flags = 0;
      asym->value = 0;
      break;
    case scCdbLocal:
    case scBits:
    case scCdbSystem:
    case scRegImage:
    case scInfo:
    case scUserStruct:
      asym->flags = BSF_DEBUGGING;
      break;
    case scSData:
      asym->section = bfd_make_section_old_way (abfd, ".sdata");
      asym->value -= asym->section->vma;
      break;
    case scSBss:
      asym->section = bfd_make_section_old_way (abfd, ".sbss");
      asym->value -= asym->section->vma;
      break;
    case scRData:
      asym->section = bfd_make_section_old_way (abfd, ".rdata");
      asym->value -= asym->section->vma;
      break;
    case scVar:
      asym->flags = BSF_DEBUGGING;
      break;
    case scCommon:
      if (asym->value > ecoff_data (abfd)->gp_size)
	{
	  asym->section = bfd_com_section_ptr;
	  asym->flags = 0;
	  break;
	}
      /* Fall through.  */
    case scSCommon:
      if (ecoff_scom_section.name == NULL)
	{
	  /* Initialize the small common section.  */
	  ecoff_scom_section.name = SCOMMON;
	  ecoff_scom_section.flags = SEC_IS_COMMON;
	  ecoff_scom_section.output_section = &ecoff_scom_section;
	  ecoff_scom_section.symbol = &ecoff_scom_symbol;
	  ecoff_scom_section.symbol_ptr_ptr = &ecoff_scom_symbol_ptr;
	  ecoff_scom_symbol.name = SCOMMON;
	  ecoff_scom_symbol.flags = BSF_SECTION_SYM;
	  ecoff_scom_symbol.section = &ecoff_scom_section;
	  ecoff_scom_symbol_ptr = &ecoff_scom_symbol;
	}
      asym->section = &ecoff_scom_section;
      asym->flags = 0;
      break;
    case scVarRegister:
    case scVariant:
      asym->flags = BSF_DEBUGGING;
      break;
    case scSUndefined:
      asym->section = bfd_und_section_ptr;
      asym->flags = 0;
      asym->value = 0;
      break;
    case scInit:
      asym->section = bfd_make_section_old_way (abfd, ".init");
      asym->value -= asym->section->vma;
      break;
    case scBasedVar:
    case scXData:
    case scPData:
      asym->flags = BSF_DEBUGGING;
      break;
    case scFini:
      asym->section = bfd_make_section_old_way (abfd, ".fini");
      asym->value -= asym->section->vma;
      break;
    case scRConst:
      asym->section = bfd_make_section_old_way (abfd, ".rconst");
      asym->value -= asym->section->vma;
      break;
    default:
      break;
    }

  /* Look for special constructors symbols and make relocation entries
     in a special construction section.  These are produced by the
     -fgnu-linker argument to g++.  */
  if (ECOFF_IS_STAB (ecoff_sym))
    {
      switch (ECOFF_UNMARK_STAB (ecoff_sym->index))
	{
	default:
	  break;

	case N_SETA:
	case N_SETT:
	case N_SETD:
	case N_SETB:
	  /* Mark the symbol as a constructor.  */
	  asym->flags |= BSF_CONSTRUCTOR;
	  break;
	}
    }
  return TRUE;
}

/* Read an ECOFF symbol table.  */

bfd_boolean
_bfd_ecoff_slurp_symbol_table (bfd *abfd)
{
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  const bfd_size_type external_ext_size
    = backend->debug_swap.external_ext_size;
  const bfd_size_type external_sym_size
    = backend->debug_swap.external_sym_size;
  void (* const swap_ext_in) (bfd *, void *, EXTR *)
    = backend->debug_swap.swap_ext_in;
  void (* const swap_sym_in) (bfd *, void *, SYMR *)
    = backend->debug_swap.swap_sym_in;
  bfd_size_type internal_size;
  ecoff_symbol_type *internal;
  ecoff_symbol_type *internal_ptr;
  char *eraw_src;
  char *eraw_end;
  FDR *fdr_ptr;
  FDR *fdr_end;

  /* If we've already read in the symbol table, do nothing.  */
  if (ecoff_data (abfd)->canonical_symbols != NULL)
    return TRUE;

  /* Get the symbolic information.  */
  if (! _bfd_ecoff_slurp_symbolic_info (abfd, NULL,
					&ecoff_data (abfd)->debug_info))
    return FALSE;
  if (bfd_get_symcount (abfd) == 0)
    return TRUE;

  internal_size = bfd_get_symcount (abfd);
  internal_size *= sizeof (ecoff_symbol_type);
  internal = (ecoff_symbol_type *) bfd_alloc (abfd, internal_size);
  if (internal == NULL)
    return FALSE;

  internal_ptr = internal;
  eraw_src = (char *) ecoff_data (abfd)->debug_info.external_ext;
  eraw_end = (eraw_src
	      + (ecoff_data (abfd)->debug_info.symbolic_header.iextMax
		 * external_ext_size));
  for (; eraw_src < eraw_end; eraw_src += external_ext_size, internal_ptr++)
    {
      EXTR internal_esym;

      (*swap_ext_in) (abfd, (void *) eraw_src, &internal_esym);
      internal_ptr->symbol.name = (ecoff_data (abfd)->debug_info.ssext
				   + internal_esym.asym.iss);
      if (!ecoff_set_symbol_info (abfd, &internal_esym.asym,
				  &internal_ptr->symbol, 1,
				  internal_esym.weakext))
	return FALSE;
      /* The alpha uses a negative ifd field for section symbols.  */
      if (internal_esym.ifd >= 0)
	internal_ptr->fdr = (ecoff_data (abfd)->debug_info.fdr
			     + internal_esym.ifd);
      else
	internal_ptr->fdr = NULL;
      internal_ptr->local = FALSE;
      internal_ptr->native = (void *) eraw_src;
    }

  /* The local symbols must be accessed via the fdr's, because the
     string and aux indices are relative to the fdr information.  */
  fdr_ptr = ecoff_data (abfd)->debug_info.fdr;
  fdr_end = fdr_ptr + ecoff_data (abfd)->debug_info.symbolic_header.ifdMax;
  for (; fdr_ptr < fdr_end; fdr_ptr++)
    {
      char *lraw_src;
      char *lraw_end;

      lraw_src = ((char *) ecoff_data (abfd)->debug_info.external_sym
		  + fdr_ptr->isymBase * external_sym_size);
      lraw_end = lraw_src + fdr_ptr->csym * external_sym_size;
      for (;
	   lraw_src < lraw_end;
	   lraw_src += external_sym_size, internal_ptr++)
	{
	  SYMR internal_sym;

	  (*swap_sym_in) (abfd, (void *) lraw_src, &internal_sym);
	  internal_ptr->symbol.name = (ecoff_data (abfd)->debug_info.ss
				       + fdr_ptr->issBase
				       + internal_sym.iss);
	  if (!ecoff_set_symbol_info (abfd, &internal_sym,
				      &internal_ptr->symbol, 0, 0))
	    return FALSE;
	  internal_ptr->fdr = fdr_ptr;
	  internal_ptr->local = TRUE;
	  internal_ptr->native = (void *) lraw_src;
	}
    }

  ecoff_data (abfd)->canonical_symbols = internal;

  return TRUE;
}

/* Return the amount of space needed for the canonical symbols.  */

long
_bfd_ecoff_get_symtab_upper_bound (bfd *abfd)
{
  if (! _bfd_ecoff_slurp_symbolic_info (abfd, NULL,
					&ecoff_data (abfd)->debug_info))
    return -1;

  if (bfd_get_symcount (abfd) == 0)
    return 0;

  return (bfd_get_symcount (abfd) + 1) * (sizeof (ecoff_symbol_type *));
}

/* Get the canonical symbols.  */

long
_bfd_ecoff_canonicalize_symtab (bfd *abfd, asymbol **alocation)
{
  unsigned int counter = 0;
  ecoff_symbol_type *symbase;
  ecoff_symbol_type **location = (ecoff_symbol_type **) alocation;

  if (! _bfd_ecoff_slurp_symbol_table (abfd))
    return -1;
  if (bfd_get_symcount (abfd) == 0)
    return 0;

  symbase = ecoff_data (abfd)->canonical_symbols;
  while (counter < bfd_get_symcount (abfd))
    {
      *(location++) = symbase++;
      counter++;
    }
  *location++ = NULL;
  return bfd_get_symcount (abfd);
}

/* Turn ECOFF type information into a printable string.
   ecoff_emit_aggregate and ecoff_type_to_string are from
   gcc/mips-tdump.c, with swapping added and used_ptr removed.  */

/* Write aggregate information to a string.  */

static void
ecoff_emit_aggregate (bfd *abfd,
		      FDR *fdr,
		      char *string,
		      RNDXR *rndx,
		      long isym,
		      const char *which)
{
  const struct ecoff_debug_swap * const debug_swap =
    &ecoff_backend (abfd)->debug_swap;
  struct ecoff_debug_info * const debug_info = &ecoff_data (abfd)->debug_info;
  unsigned int ifd = rndx->rfd;
  unsigned int indx = rndx->index;
  const char *name;

  if (ifd == 0xfff)
    ifd = isym;

  /* An ifd of -1 is an opaque type.  An escaped index of 0 is a
     struct return type of a procedure compiled without -g.  */
  if (ifd == 0xffffffff
      || (rndx->rfd == 0xfff && indx == 0))
    name = "<undefined>";
  else if (indx == indexNil)
    name = "<no name>";
  else
    {
      SYMR sym;

      if (debug_info->external_rfd == NULL)
	fdr = debug_info->fdr + ifd;
      else
	{
	  RFDT rfd;

	  (*debug_swap->swap_rfd_in) (abfd,
				      ((char *) debug_info->external_rfd
				       + ((fdr->rfdBase + ifd)
					  * debug_swap->external_rfd_size)),
				      &rfd);
	  fdr = debug_info->fdr + rfd;
	}

      indx += fdr->isymBase;

      (*debug_swap->swap_sym_in) (abfd,
				  ((char *) debug_info->external_sym
				   + indx * debug_swap->external_sym_size),
				  &sym);

      name = debug_info->ss + fdr->issBase + sym.iss;
    }

  sprintf (string,
	   "%s %s { ifd = %u, index = %lu }",
	   which, name, ifd,
	   ((unsigned long) indx
	    + debug_info->symbolic_header.iextMax));
}

/* Convert the type information to string format.  */

static char *
ecoff_type_to_string (bfd *abfd, FDR *fdr, unsigned int indx)
{
  union aux_ext *aux_ptr;
  int bigendian;
  AUXU u;
  struct qual
  {
    unsigned int  type;
    int  low_bound;
    int  high_bound;
    int  stride;
  } qualifiers[7];
  unsigned int basic_type;
  int i;
  char buffer1[1024];
  static char buffer2[1024];
  char *p1 = buffer1;
  char *p2 = buffer2;
  RNDXR rndx;

  aux_ptr = ecoff_data (abfd)->debug_info.external_aux + fdr->iauxBase;
  bigendian = fdr->fBigendian;

  for (i = 0; i < 7; i++)
    {
      qualifiers[i].low_bound = 0;
      qualifiers[i].high_bound = 0;
      qualifiers[i].stride = 0;
    }

  if (AUX_GET_ISYM (bigendian, &aux_ptr[indx]) == (bfd_vma) -1)
    return "-1 (no type)";
  _bfd_ecoff_swap_tir_in (bigendian, &aux_ptr[indx++].a_ti, &u.ti);

  basic_type = u.ti.bt;
  qualifiers[0].type = u.ti.tq0;
  qualifiers[1].type = u.ti.tq1;
  qualifiers[2].type = u.ti.tq2;
  qualifiers[3].type = u.ti.tq3;
  qualifiers[4].type = u.ti.tq4;
  qualifiers[5].type = u.ti.tq5;
  qualifiers[6].type = tqNil;

  /* Go get the basic type.  */
  switch (basic_type)
    {
    case btNil:			/* Undefined.  */
      strcpy (p1, "nil");
      break;

    case btAdr:			/* Address - integer same size as pointer.  */
      strcpy (p1, "address");
      break;

    case btChar:		/* Character.  */
      strcpy (p1, "char");
      break;

    case btUChar:		/* Unsigned character.  */
      strcpy (p1, "unsigned char");
      break;

    case btShort:		/* Short.  */
      strcpy (p1, "short");
      break;

    case btUShort:		/* Unsigned short.  */
      strcpy (p1, "unsigned short");
      break;

    case btInt:			/* Int.  */
      strcpy (p1, "int");
      break;

    case btUInt:		/* Unsigned int.  */
      strcpy (p1, "unsigned int");
      break;

    case btLong:		/* Long.  */
      strcpy (p1, "long");
      break;

    case btULong:		/* Unsigned long.  */
      strcpy (p1, "unsigned long");
      break;

    case btFloat:		/* Float (real).  */
      strcpy (p1, "float");
      break;

    case btDouble:		/* Double (real).  */
      strcpy (p1, "double");
      break;

      /* Structures add 1-2 aux words:
	 1st word is [ST_RFDESCAPE, offset] pointer to struct def;
	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */

    case btStruct:		/* Structure (Record).  */
      _bfd_ecoff_swap_rndx_in (bigendian, &aux_ptr[indx].a_rndx, &rndx);
      ecoff_emit_aggregate (abfd, fdr, p1, &rndx,
			    (long) AUX_GET_ISYM (bigendian, &aux_ptr[indx+1]),
			    "struct");
      indx++;			/* Skip aux words.  */
      break;

      /* Unions add 1-2 aux words:
	 1st word is [ST_RFDESCAPE, offset] pointer to union def;
	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */

    case btUnion:		/* Union.  */
      _bfd_ecoff_swap_rndx_in (bigendian, &aux_ptr[indx].a_rndx, &rndx);
      ecoff_emit_aggregate (abfd, fdr, p1, &rndx,
			    (long) AUX_GET_ISYM (bigendian, &aux_ptr[indx+1]),
			    "union");
      indx++;			/* Skip aux words.  */
      break;

      /* Enumerations add 1-2 aux words:
	 1st word is [ST_RFDESCAPE, offset] pointer to enum def;
	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */

    case btEnum:		/* Enumeration.  */
      _bfd_ecoff_swap_rndx_in (bigendian, &aux_ptr[indx].a_rndx, &rndx);
      ecoff_emit_aggregate (abfd, fdr, p1, &rndx,
			    (long) AUX_GET_ISYM (bigendian, &aux_ptr[indx+1]),
			    "enum");
      indx++;			/* Skip aux words.  */
      break;

    case btTypedef:		/* Defined via a typedef, isymRef points.  */
      strcpy (p1, "typedef");
      break;

    case btRange:		/* Subrange of int.  */
      strcpy (p1, "subrange");
      break;

    case btSet:			/* Pascal sets.  */
      strcpy (p1, "set");
      break;

    case btComplex:		/* Fortran complex.  */
      strcpy (p1, "complex");
      break;

    case btDComplex:		/* Fortran double complex.  */
      strcpy (p1, "double complex");
      break;

    case btIndirect:		/* Forward or unnamed typedef.  */
      strcpy (p1, "forward/unamed typedef");
      break;

    case btFixedDec:		/* Fixed Decimal.  */
      strcpy (p1, "fixed decimal");
      break;

    case btFloatDec:		/* Float Decimal.  */
      strcpy (p1, "float decimal");
      break;

    case btString:		/* Varying Length Character String.  */
      strcpy (p1, "string");
      break;

    case btBit:			/* Aligned Bit String.  */
      strcpy (p1, "bit");
      break;

    case btPicture:		/* Picture.  */
      strcpy (p1, "picture");
      break;

    case btVoid:		/* Void.  */
      strcpy (p1, "void");
      break;

    default:
      sprintf (p1, _("Unknown basic type %d"), (int) basic_type);
      break;
    }

  p1 += strlen (buffer1);

  /* If this is a bitfield, get the bitsize.  */
  if (u.ti.fBitfield)
    {
      int bitsize;

      bitsize = AUX_GET_WIDTH (bigendian, &aux_ptr[indx++]);
      sprintf (p1, " : %d", bitsize);
      p1 += strlen (buffer1);
    }

  /* Deal with any qualifiers.  */
  if (qualifiers[0].type != tqNil)
    {
      /* Snarf up any array bounds in the correct order.  Arrays
         store 5 successive words in the aux. table:
        	word 0	RNDXR to type of the bounds (ie, int)
        	word 1	Current file descriptor index
        	word 2	low bound
        	word 3	high bound (or -1 if [])
        	word 4	stride size in bits.  */
      for (i = 0; i < 7; i++)
	{
	  if (qualifiers[i].type == tqArray)
	    {
	      qualifiers[i].low_bound =
		AUX_GET_DNLOW (bigendian, &aux_ptr[indx+2]);
	      qualifiers[i].high_bound =
		AUX_GET_DNHIGH (bigendian, &aux_ptr[indx+3]);
	      qualifiers[i].stride =
		AUX_GET_WIDTH (bigendian, &aux_ptr[indx+4]);
	      indx += 5;
	    }
	}

      /* Now print out the qualifiers.  */
      for (i = 0; i < 6; i++)
	{
	  switch (qualifiers[i].type)
	    {
	    case tqNil:
	    case tqMax:
	      break;

	    case tqPtr:
	      strcpy (p2, "ptr to ");
	      p2 += sizeof ("ptr to ")-1;
	      break;

	    case tqVol:
	      strcpy (p2, "volatile ");
	      p2 += sizeof ("volatile ")-1;
	      break;

	    case tqFar:
	      strcpy (p2, "far ");
	      p2 += sizeof ("far ")-1;
	      break;

	    case tqProc:
	      strcpy (p2, "func. ret. ");
	      p2 += sizeof ("func. ret. ");
	      break;

	    case tqArray:
	      {
		int first_array = i;
		int j;

		/* Print array bounds reversed (ie, in the order the C
		   programmer writes them).  C is such a fun language....  */
		while (i < 5 && qualifiers[i+1].type == tqArray)
		  i++;

		for (j = i; j >= first_array; j--)
		  {
		    strcpy (p2, "array [");
		    p2 += sizeof ("array [")-1;
		    if (qualifiers[j].low_bound != 0)
		      sprintf (p2,
			       "%ld:%ld {%ld bits}",
			       (long) qualifiers[j].low_bound,
			       (long) qualifiers[j].high_bound,
			       (long) qualifiers[j].stride);

		    else if (qualifiers[j].high_bound != -1)
		      sprintf (p2,
			       "%ld {%ld bits}",
			       (long) (qualifiers[j].high_bound + 1),
			       (long) (qualifiers[j].stride));

		    else
		      sprintf (p2, " {%ld bits}", (long) (qualifiers[j].stride));

		    p2 += strlen (p2);
		    strcpy (p2, "] of ");
		    p2 += sizeof ("] of ")-1;
		  }
	      }
	      break;
	    }
	}
    }

  strcpy (p2, buffer1);
  return buffer2;
}

/* Return information about ECOFF symbol SYMBOL in RET.  */

void
_bfd_ecoff_get_symbol_info (bfd *abfd ATTRIBUTE_UNUSED,
			    asymbol *symbol,
			    symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);
}

/* Return whether this is a local label.  */

bfd_boolean
_bfd_ecoff_bfd_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,
				    const char *name)
{
  return name[0] == '$';
}

/* Print information about an ECOFF symbol.  */

void
_bfd_ecoff_print_symbol (bfd *abfd,
			 void * filep,
			 asymbol *symbol,
			 bfd_print_symbol_type how)
{
  const struct ecoff_debug_swap * const debug_swap
    = &ecoff_backend (abfd)->debug_swap;
  FILE *file = (FILE *)filep;

  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_more:
      if (ecoffsymbol (symbol)->local)
	{
	  SYMR ecoff_sym;

	  (*debug_swap->swap_sym_in) (abfd, ecoffsymbol (symbol)->native,
				      &ecoff_sym);
	  fprintf (file, "ecoff local ");
	  fprintf_vma (file, (bfd_vma) ecoff_sym.value);
	  fprintf (file, " %x %x", (unsigned) ecoff_sym.st,
		   (unsigned) ecoff_sym.sc);
	}
      else
	{
	  EXTR ecoff_ext;

	  (*debug_swap->swap_ext_in) (abfd, ecoffsymbol (symbol)->native,
				      &ecoff_ext);
	  fprintf (file, "ecoff extern ");
	  fprintf_vma (file, (bfd_vma) ecoff_ext.asym.value);
	  fprintf (file, " %x %x", (unsigned) ecoff_ext.asym.st,
		   (unsigned) ecoff_ext.asym.sc);
	}
      break;
    case bfd_print_symbol_all:
      /* Print out the symbols in a reasonable way.  */
      {
	char type;
	int pos;
	EXTR ecoff_ext;
	char jmptbl;
	char cobol_main;
	char weakext;

	if (ecoffsymbol (symbol)->local)
	  {
	    (*debug_swap->swap_sym_in) (abfd, ecoffsymbol (symbol)->native,
					&ecoff_ext.asym);
	    type = 'l';
	    pos = ((((char *) ecoffsymbol (symbol)->native
		     - (char *) ecoff_data (abfd)->debug_info.external_sym)
		    / debug_swap->external_sym_size)
		   + ecoff_data (abfd)->debug_info.symbolic_header.iextMax);
	    jmptbl = ' ';
	    cobol_main = ' ';
	    weakext = ' ';
	  }
	else
	  {
	    (*debug_swap->swap_ext_in) (abfd, ecoffsymbol (symbol)->native,
					&ecoff_ext);
	    type = 'e';
	    pos = (((char *) ecoffsymbol (symbol)->native
		    - (char *) ecoff_data (abfd)->debug_info.external_ext)
		   / debug_swap->external_ext_size);
	    jmptbl = ecoff_ext.jmptbl ? 'j' : ' ';
	    cobol_main = ecoff_ext.cobol_main ? 'c' : ' ';
	    weakext = ecoff_ext.weakext ? 'w' : ' ';
	  }

	fprintf (file, "[%3d] %c ",
		 pos, type);
	fprintf_vma (file, (bfd_vma) ecoff_ext.asym.value);
	fprintf (file, " st %x sc %x indx %x %c%c%c %s",
		 (unsigned) ecoff_ext.asym.st,
		 (unsigned) ecoff_ext.asym.sc,
		 (unsigned) ecoff_ext.asym.index,
		 jmptbl, cobol_main, weakext,
		 symbol->name);

	if (ecoffsymbol (symbol)->fdr != NULL
	    && ecoff_ext.asym.index != indexNil)
	  {
	    FDR *fdr;
	    unsigned int indx;
	    int bigendian;
	    bfd_size_type sym_base;
	    union aux_ext *aux_base;

	    fdr = ecoffsymbol (symbol)->fdr;
	    indx = ecoff_ext.asym.index;

	    /* sym_base is used to map the fdr relative indices which
	       appear in the file to the position number which we are
	       using.  */
	    sym_base = fdr->isymBase;
	    if (ecoffsymbol (symbol)->local)
	      sym_base +=
		ecoff_data (abfd)->debug_info.symbolic_header.iextMax;

	    /* aux_base is the start of the aux entries for this file;
	       asym.index is an offset from this.  */
	    aux_base = (ecoff_data (abfd)->debug_info.external_aux
			+ fdr->iauxBase);

	    /* The aux entries are stored in host byte order; the
	       order is indicated by a bit in the fdr.  */
	    bigendian = fdr->fBigendian;

	    /* This switch is basically from gcc/mips-tdump.c.  */
	    switch (ecoff_ext.asym.st)
	      {
	      case stNil:
	      case stLabel:
		break;

	      case stFile:
	      case stBlock:
		fprintf (file, _("\n      End+1 symbol: %ld"),
			 (long) (indx + sym_base));
		break;

	      case stEnd:
		if (ecoff_ext.asym.sc == scText
		    || ecoff_ext.asym.sc == scInfo)
		  fprintf (file, _("\n      First symbol: %ld"),
			   (long) (indx + sym_base));
		else
		  fprintf (file, _("\n      First symbol: %ld"),
			   ((long)
			    (AUX_GET_ISYM (bigendian,
					   &aux_base[ecoff_ext.asym.index])
			     + sym_base)));
		break;

	      case stProc:
	      case stStaticProc:
		if (ECOFF_IS_STAB (&ecoff_ext.asym))
		  ;
		else if (ecoffsymbol (symbol)->local)
		  fprintf (file, _("\n      End+1 symbol: %-7ld   Type:  %s"),
			   ((long)
			    (AUX_GET_ISYM (bigendian,
					   &aux_base[ecoff_ext.asym.index])
			     + sym_base)),
			   ecoff_type_to_string (abfd, fdr, indx + 1));
		else
		  fprintf (file, _("\n      Local symbol: %ld"),
			   ((long) indx
			    + (long) sym_base
			    + (ecoff_data (abfd)
			       ->debug_info.symbolic_header.iextMax)));
		break;

	      case stStruct:
		fprintf (file, _("\n      struct; End+1 symbol: %ld"),
			 (long) (indx + sym_base));
		break;

	      case stUnion:
		fprintf (file, _("\n      union; End+1 symbol: %ld"),
			 (long) (indx + sym_base));
		break;

	      case stEnum:
		fprintf (file, _("\n      enum; End+1 symbol: %ld"),
			 (long) (indx + sym_base));
		break;

	      default:
		if (! ECOFF_IS_STAB (&ecoff_ext.asym))
		  fprintf (file, _("\n      Type: %s"),
			   ecoff_type_to_string (abfd, fdr, indx));
		break;
	      }
	  }
      }
      break;
    }
}

/* Read in the relocs for a section.  */

static bfd_boolean
ecoff_slurp_reloc_table (bfd *abfd,
			 asection *section,
			 asymbol **symbols)
{
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  arelent *internal_relocs;
  bfd_size_type external_reloc_size;
  bfd_size_type amt;
  char *external_relocs;
  arelent *rptr;
  unsigned int i;

  if (section->relocation != NULL
      || section->reloc_count == 0
      || (section->flags & SEC_CONSTRUCTOR) != 0)
    return TRUE;

  if (! _bfd_ecoff_slurp_symbol_table (abfd))
    return FALSE;

  amt = section->reloc_count;
  amt *= sizeof (arelent);
  internal_relocs = (arelent *) bfd_alloc (abfd, amt);

  external_reloc_size = backend->external_reloc_size;
  amt = external_reloc_size * section->reloc_count;
  external_relocs = (char *) bfd_alloc (abfd, amt);
  if (internal_relocs == NULL || external_relocs == NULL)
    return FALSE;
  if (bfd_seek (abfd, section->rel_filepos, SEEK_SET) != 0)
    return FALSE;
  if (bfd_bread (external_relocs, amt, abfd) != amt)
    return FALSE;

  for (i = 0, rptr = internal_relocs; i < section->reloc_count; i++, rptr++)
    {
      struct internal_reloc intern;

      (*backend->swap_reloc_in) (abfd,
				 external_relocs + i * external_reloc_size,
				 &intern);

      if (intern.r_extern)
	{
	  /* r_symndx is an index into the external symbols.  */
	  BFD_ASSERT (intern.r_symndx >= 0
		      && (intern.r_symndx
			  < (ecoff_data (abfd)
			     ->debug_info.symbolic_header.iextMax)));
	  rptr->sym_ptr_ptr = symbols + intern.r_symndx;
	  rptr->addend = 0;
	}
      else if (intern.r_symndx == RELOC_SECTION_NONE
	       || intern.r_symndx == RELOC_SECTION_ABS)
	{
	  rptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	  rptr->addend = 0;
	}
      else
	{
	  const char *sec_name;
	  asection *sec;

	  /* r_symndx is a section key.  */
	  switch (intern.r_symndx)
	    {
	    case RELOC_SECTION_TEXT:  sec_name = _TEXT;  break;
	    case RELOC_SECTION_RDATA: sec_name = _RDATA; break;
	    case RELOC_SECTION_DATA:  sec_name = _DATA;  break;
	    case RELOC_SECTION_SDATA: sec_name = _SDATA; break;
	    case RELOC_SECTION_SBSS:  sec_name = _SBSS;  break;
	    case RELOC_SECTION_BSS:   sec_name = _BSS;   break;
	    case RELOC_SECTION_INIT:  sec_name = _INIT;  break;
	    case RELOC_SECTION_LIT8:  sec_name = _LIT8;  break;
	    case RELOC_SECTION_LIT4:  sec_name = _LIT4;  break;
	    case RELOC_SECTION_XDATA: sec_name = _XDATA; break;
	    case RELOC_SECTION_PDATA: sec_name = _PDATA; break;
	    case RELOC_SECTION_FINI:  sec_name = _FINI;  break;
	    case RELOC_SECTION_LITA:  sec_name = _LITA;  break;
	    case RELOC_SECTION_RCONST: sec_name = _RCONST; break;
	    default: abort ();
	    }

	  sec = bfd_get_section_by_name (abfd, sec_name);
	  if (sec == NULL)
	    abort ();
	  rptr->sym_ptr_ptr = sec->symbol_ptr_ptr;

	  rptr->addend = - bfd_get_section_vma (abfd, sec);
	}

      rptr->address = intern.r_vaddr - bfd_get_section_vma (abfd, section);

      /* Let the backend select the howto field and do any other
	 required processing.  */
      (*backend->adjust_reloc_in) (abfd, &intern, rptr);
    }

  bfd_release (abfd, external_relocs);

  section->relocation = internal_relocs;

  return TRUE;
}

/* Get a canonical list of relocs.  */

long
_bfd_ecoff_canonicalize_reloc (bfd *abfd,
			       asection *section,
			       arelent **relptr,
			       asymbol **symbols)
{
  unsigned int count;

  if (section->flags & SEC_CONSTRUCTOR)
    {
      arelent_chain *chain;

      /* This section has relocs made up by us, not the file, so take
	 them out of their chain and place them into the data area
	 provided.  */
      for (count = 0, chain = section->constructor_chain;
	   count < section->reloc_count;
	   count++, chain = chain->next)
	*relptr++ = &chain->relent;
    }
  else
    {
      arelent *tblptr;

      if (! ecoff_slurp_reloc_table (abfd, section, symbols))
	return -1;

      tblptr = section->relocation;

      for (count = 0; count < section->reloc_count; count++)
	*relptr++ = tblptr++;
    }

  *relptr = NULL;

  return section->reloc_count;
}

/* Provided a BFD, a section and an offset into the section, calculate
   and return the name of the source file and the line nearest to the
   wanted location.  */

bfd_boolean
_bfd_ecoff_find_nearest_line (bfd *abfd,
			      asection *section,
			      asymbol **ignore_symbols ATTRIBUTE_UNUSED,
			      bfd_vma offset,
			      const char **filename_ptr,
			      const char **functionname_ptr,
			      unsigned int *retline_ptr)
{
  const struct ecoff_debug_swap * const debug_swap
    = &ecoff_backend (abfd)->debug_swap;
  struct ecoff_debug_info * const debug_info = &ecoff_data (abfd)->debug_info;
  struct ecoff_find_line *line_info;

  /* Make sure we have the FDR's.  */
  if (! _bfd_ecoff_slurp_symbolic_info (abfd, NULL, debug_info)
      || bfd_get_symcount (abfd) == 0)
    return FALSE;

  if (ecoff_data (abfd)->find_line_info == NULL)
    {
      bfd_size_type amt = sizeof (struct ecoff_find_line);

      ecoff_data (abfd)->find_line_info =
          (struct ecoff_find_line *) bfd_zalloc (abfd, amt);
      if (ecoff_data (abfd)->find_line_info == NULL)
	return FALSE;
    }
  line_info = ecoff_data (abfd)->find_line_info;

  return _bfd_ecoff_locate_line (abfd, section, offset, debug_info,
				 debug_swap, line_info, filename_ptr,
				 functionname_ptr, retline_ptr);
}

/* Copy private BFD data.  This is called by objcopy and strip.  We
   use it to copy the ECOFF debugging information from one BFD to the
   other.  It would be theoretically possible to represent the ECOFF
   debugging information in the symbol table.  However, it would be a
   lot of work, and there would be little gain (gas, gdb, and ld
   already access the ECOFF debugging information via the
   ecoff_debug_info structure, and that structure would have to be
   retained in order to support ECOFF debugging in MIPS ELF).

   The debugging information for the ECOFF external symbols comes from
   the symbol table, so this function only handles the other debugging
   information.  */

bfd_boolean
_bfd_ecoff_bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  struct ecoff_debug_info *iinfo = &ecoff_data (ibfd)->debug_info;
  struct ecoff_debug_info *oinfo = &ecoff_data (obfd)->debug_info;
  int i;
  asymbol **sym_ptr_ptr;
  size_t c;
  bfd_boolean local;

  /* We only want to copy information over if both BFD's use ECOFF
     format.  */
  if (bfd_get_flavour (ibfd) != bfd_target_ecoff_flavour
      || bfd_get_flavour (obfd) != bfd_target_ecoff_flavour)
    return TRUE;

  /* Copy the GP value and the register masks.  */
  ecoff_data (obfd)->gp = ecoff_data (ibfd)->gp;
  ecoff_data (obfd)->gprmask = ecoff_data (ibfd)->gprmask;
  ecoff_data (obfd)->fprmask = ecoff_data (ibfd)->fprmask;
  for (i = 0; i < 3; i++)
    ecoff_data (obfd)->cprmask[i] = ecoff_data (ibfd)->cprmask[i];

  /* Copy the version stamp.  */
  oinfo->symbolic_header.vstamp = iinfo->symbolic_header.vstamp;

  /* If there are no symbols, don't copy any debugging information.  */
  c = bfd_get_symcount (obfd);
  sym_ptr_ptr = bfd_get_outsymbols (obfd);
  if (c == 0 || sym_ptr_ptr == NULL)
    return TRUE;

  /* See if there are any local symbols.  */
  local = FALSE;
  for (; c > 0; c--, sym_ptr_ptr++)
    {
      if (ecoffsymbol (*sym_ptr_ptr)->local)
	{
	  local = TRUE;
	  break;
	}
    }

  if (local)
    {
      /* There are some local symbols.  We just bring over all the
	 debugging information.  FIXME: This is not quite the right
	 thing to do.  If the user has asked us to discard all
	 debugging information, then we are probably going to wind up
	 keeping it because there will probably be some local symbol
	 which objcopy did not discard.  We should actually break
	 apart the debugging information and only keep that which
	 applies to the symbols we want to keep.  */
      oinfo->symbolic_header.ilineMax = iinfo->symbolic_header.ilineMax;
      oinfo->symbolic_header.cbLine = iinfo->symbolic_header.cbLine;
      oinfo->line = iinfo->line;

      oinfo->symbolic_header.idnMax = iinfo->symbolic_header.idnMax;
      oinfo->external_dnr = iinfo->external_dnr;

      oinfo->symbolic_header.ipdMax = iinfo->symbolic_header.ipdMax;
      oinfo->external_pdr = iinfo->external_pdr;

      oinfo->symbolic_header.isymMax = iinfo->symbolic_header.isymMax;
      oinfo->external_sym = iinfo->external_sym;

      oinfo->symbolic_header.ioptMax = iinfo->symbolic_header.ioptMax;
      oinfo->external_opt = iinfo->external_opt;

      oinfo->symbolic_header.iauxMax = iinfo->symbolic_header.iauxMax;
      oinfo->external_aux = iinfo->external_aux;

      oinfo->symbolic_header.issMax = iinfo->symbolic_header.issMax;
      oinfo->ss = iinfo->ss;

      oinfo->symbolic_header.ifdMax = iinfo->symbolic_header.ifdMax;
      oinfo->external_fdr = iinfo->external_fdr;

      oinfo->symbolic_header.crfd = iinfo->symbolic_header.crfd;
      oinfo->external_rfd = iinfo->external_rfd;
    }
  else
    {
      /* We are discarding all the local symbol information.  Look
	 through the external symbols and remove all references to FDR
	 or aux information.  */
      c = bfd_get_symcount (obfd);
      sym_ptr_ptr = bfd_get_outsymbols (obfd);
      for (; c > 0; c--, sym_ptr_ptr++)
	{
	  EXTR esym;

	  (*(ecoff_backend (obfd)->debug_swap.swap_ext_in))
	    (obfd, ecoffsymbol (*sym_ptr_ptr)->native, &esym);
	  esym.ifd = ifdNil;
	  esym.asym.index = indexNil;
	  (*(ecoff_backend (obfd)->debug_swap.swap_ext_out))
	    (obfd, &esym, ecoffsymbol (*sym_ptr_ptr)->native);
	}
    }

  return TRUE;
}

/* Set the architecture.  The supported architecture is stored in the
   backend pointer.  We always set the architecture anyhow, since many
   callers ignore the return value.  */

bfd_boolean
_bfd_ecoff_set_arch_mach (bfd *abfd,
			  enum bfd_architecture arch,
			  unsigned long machine)
{
  bfd_default_set_arch_mach (abfd, arch, machine);
  return arch == ecoff_backend (abfd)->arch;
}

/* Get the size of the section headers.  */

int
_bfd_ecoff_sizeof_headers (bfd *abfd,
			   struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  asection *current;
  int c;
  int ret;

  c = 0;
  for (current = abfd->sections;
       current != NULL;
       current = current->next)
    ++c;

  ret = (bfd_coff_filhsz (abfd)
	 + bfd_coff_aoutsz (abfd)
	 + c * bfd_coff_scnhsz (abfd));
  return (int) BFD_ALIGN (ret, 16);
}

/* Get the contents of a section.  */

bfd_boolean
_bfd_ecoff_get_section_contents (bfd *abfd,
				 asection *section,
				 void * location,
				 file_ptr offset,
				 bfd_size_type count)
{
  return _bfd_generic_get_section_contents (abfd, section, location,
					    offset, count);
}

/* Sort sections by VMA, but put SEC_ALLOC sections first.  This is
   called via qsort.  */

static int
ecoff_sort_hdrs (const void * arg1, const void * arg2)
{
  const asection *hdr1 = *(const asection **) arg1;
  const asection *hdr2 = *(const asection **) arg2;

  if ((hdr1->flags & SEC_ALLOC) != 0)
    {
      if ((hdr2->flags & SEC_ALLOC) == 0)
	return -1;
    }
  else
    {
      if ((hdr2->flags & SEC_ALLOC) != 0)
	return 1;
    }
  if (hdr1->vma < hdr2->vma)
    return -1;
  else if (hdr1->vma > hdr2->vma)
    return 1;
  else
    return 0;
}

/* Calculate the file position for each section, and set
   reloc_filepos.  */

static bfd_boolean
ecoff_compute_section_file_positions (bfd *abfd)
{
  file_ptr sofar, file_sofar;
  asection **sorted_hdrs;
  asection *current;
  unsigned int i;
  file_ptr old_sofar;
  bfd_boolean rdata_in_text;
  bfd_boolean first_data, first_nonalloc;
  const bfd_vma round = ecoff_backend (abfd)->round;
  bfd_size_type amt;

  sofar = _bfd_ecoff_sizeof_headers (abfd, NULL);
  file_sofar = sofar;

  /* Sort the sections by VMA.  */
  amt = abfd->section_count;
  amt *= sizeof (asection *);
  sorted_hdrs = (asection **) bfd_malloc (amt);
  if (sorted_hdrs == NULL)
    return FALSE;
  for (current = abfd->sections, i = 0;
       current != NULL;
       current = current->next, i++)
    sorted_hdrs[i] = current;
  BFD_ASSERT (i == abfd->section_count);

  qsort (sorted_hdrs, abfd->section_count, sizeof (asection *),
	 ecoff_sort_hdrs);

  /* Some versions of the OSF linker put the .rdata section in the
     text segment, and some do not.  */
  rdata_in_text = ecoff_backend (abfd)->rdata_in_text;
  if (rdata_in_text)
    {
      for (i = 0; i < abfd->section_count; i++)
	{
	  current = sorted_hdrs[i];
	  if (streq (current->name, _RDATA))
	    break;
	  if ((current->flags & SEC_CODE) == 0
	      && ! streq (current->name, _PDATA)
	      && ! streq (current->name, _RCONST))
	    {
	      rdata_in_text = FALSE;
	      break;
	    }
	}
    }
  ecoff_data (abfd)->rdata_in_text = rdata_in_text;

  first_data = TRUE;
  first_nonalloc = TRUE;
  for (i = 0; i < abfd->section_count; i++)
    {
      unsigned int alignment_power;

      current = sorted_hdrs[i];

      /* For the Alpha ECOFF .pdata section the lnnoptr field is
	 supposed to indicate the number of .pdata entries that are
	 really in the section.  Each entry is 8 bytes.  We store this
	 away in line_filepos before increasing the section size.  */
      if (streq (current->name, _PDATA))
	current->line_filepos = current->size / 8;

      alignment_power = current->alignment_power;

      /* On Ultrix, the data sections in an executable file must be
	 aligned to a page boundary within the file.  This does not
	 affect the section size, though.  FIXME: Does this work for
	 other platforms?  It requires some modification for the
	 Alpha, because .rdata on the Alpha goes with the text, not
	 the data.  */
      if ((abfd->flags & EXEC_P) != 0
	  && (abfd->flags & D_PAGED) != 0
	  && ! first_data
	  && (current->flags & SEC_CODE) == 0
	  && (! rdata_in_text
	      || ! streq (current->name, _RDATA))
	  && ! streq (current->name, _PDATA)
	  && ! streq (current->name, _RCONST))
	{
	  sofar = (sofar + round - 1) &~ (round - 1);
	  file_sofar = (file_sofar + round - 1) &~ (round - 1);
	  first_data = FALSE;
	}
      else if (streq (current->name, _LIB))
	{
	  /* On Irix 4, the location of contents of the .lib section
	     from a shared library section is also rounded up to a
	     page boundary.  */

	  sofar = (sofar + round - 1) &~ (round - 1);
	  file_sofar = (file_sofar + round - 1) &~ (round - 1);
	}
      else if (first_nonalloc
	       && (current->flags & SEC_ALLOC) == 0
	       && (abfd->flags & D_PAGED) != 0)
	{
	  /* Skip up to the next page for an unallocated section, such
             as the .comment section on the Alpha.  This leaves room
             for the .bss section.  */
	  first_nonalloc = FALSE;
	  sofar = (sofar + round - 1) &~ (round - 1);
	  file_sofar = (file_sofar + round - 1) &~ (round - 1);
	}

      /* Align the sections in the file to the same boundary on
	 which they are aligned in virtual memory.  */
      sofar = BFD_ALIGN (sofar, 1 << alignment_power);
      if ((current->flags & SEC_HAS_CONTENTS) != 0)
	file_sofar = BFD_ALIGN (file_sofar, 1 << alignment_power);

      if ((abfd->flags & D_PAGED) != 0
	  && (current->flags & SEC_ALLOC) != 0)
	{
	  sofar += (current->vma - sofar) % round;
	  if ((current->flags & SEC_HAS_CONTENTS) != 0)
	    file_sofar += (current->vma - file_sofar) % round;
	}

      if ((current->flags & (SEC_HAS_CONTENTS | SEC_LOAD)) != 0)
	current->filepos = file_sofar;

      sofar += current->size;
      if ((current->flags & SEC_HAS_CONTENTS) != 0)
	file_sofar += current->size;

      /* Make sure that this section is of the right size too.  */
      old_sofar = sofar;
      sofar = BFD_ALIGN (sofar, 1 << alignment_power);
      if ((current->flags & SEC_HAS_CONTENTS) != 0)
	file_sofar = BFD_ALIGN (file_sofar, 1 << alignment_power);
      current->size += sofar - old_sofar;
    }

  free (sorted_hdrs);
  sorted_hdrs = NULL;

  ecoff_data (abfd)->reloc_filepos = file_sofar;

  return TRUE;
}

/* Determine the location of the relocs for all the sections in the
   output file, as well as the location of the symbolic debugging
   information.  */

static bfd_size_type
ecoff_compute_reloc_file_positions (bfd *abfd)
{
  const bfd_size_type external_reloc_size =
    ecoff_backend (abfd)->external_reloc_size;
  file_ptr reloc_base;
  bfd_size_type reloc_size;
  asection *current;
  file_ptr sym_base;

  if (! abfd->output_has_begun)
    {
      if (! ecoff_compute_section_file_positions (abfd))
	abort ();
      abfd->output_has_begun = TRUE;
    }

  reloc_base = ecoff_data (abfd)->reloc_filepos;

  reloc_size = 0;
  for (current = abfd->sections;
       current != NULL;
       current = current->next)
    {
      if (current->reloc_count == 0)
	current->rel_filepos = 0;
      else
	{
	  bfd_size_type relsize;

	  current->rel_filepos = reloc_base;
	  relsize = current->reloc_count * external_reloc_size;
	  reloc_size += relsize;
	  reloc_base += relsize;
	}
    }

  sym_base = ecoff_data (abfd)->reloc_filepos + reloc_size;

  /* At least on Ultrix, the symbol table of an executable file must
     be aligned to a page boundary.  FIXME: Is this true on other
     platforms?  */
  if ((abfd->flags & EXEC_P) != 0
      && (abfd->flags & D_PAGED) != 0)
    sym_base = ((sym_base + ecoff_backend (abfd)->round - 1)
		&~ (ecoff_backend (abfd)->round - 1));

  ecoff_data (abfd)->sym_filepos = sym_base;

  return reloc_size;
}

/* Set the contents of a section.  */

bfd_boolean
_bfd_ecoff_set_section_contents (bfd *abfd,
				 asection *section,
				 const void * location,
				 file_ptr offset,
				 bfd_size_type count)
{
  file_ptr pos;

  /* This must be done first, because bfd_set_section_contents is
     going to set output_has_begun to TRUE.  */
  if (! abfd->output_has_begun
      && ! ecoff_compute_section_file_positions (abfd))
    return FALSE;

  /* Handle the .lib section specially so that Irix 4 shared libraries
     work out.  See coff_set_section_contents in coffcode.h.  */
  if (streq (section->name, _LIB))
    {
      bfd_byte *rec, *recend;

      rec = (bfd_byte *) location;
      recend = rec + count;
      while (rec < recend)
	{
	  ++section->lma;
	  rec += bfd_get_32 (abfd, rec) * 4;
	}

      BFD_ASSERT (rec == recend);
    }

  if (count == 0)
    return TRUE;

  pos = section->filepos + offset;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bwrite (location, count, abfd) != count)
    return FALSE;

  return TRUE;
}

/* Get the GP value for an ECOFF file.  This is a hook used by
   nlmconv.  */

bfd_vma
bfd_ecoff_get_gp_value (bfd *abfd)
{
  if (bfd_get_flavour (abfd) != bfd_target_ecoff_flavour
      || bfd_get_format (abfd) != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return 0;
    }

  return ecoff_data (abfd)->gp;
}

/* Set the GP value for an ECOFF file.  This is a hook used by the
   assembler.  */

bfd_boolean
bfd_ecoff_set_gp_value (bfd *abfd, bfd_vma gp_value)
{
  if (bfd_get_flavour (abfd) != bfd_target_ecoff_flavour
      || bfd_get_format (abfd) != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  ecoff_data (abfd)->gp = gp_value;

  return TRUE;
}

/* Set the register masks for an ECOFF file.  This is a hook used by
   the assembler.  */

bfd_boolean
bfd_ecoff_set_regmasks (bfd *abfd,
			unsigned long gprmask,
			unsigned long fprmask,
			unsigned long *cprmask)
{
  ecoff_data_type *tdata;

  if (bfd_get_flavour (abfd) != bfd_target_ecoff_flavour
      || bfd_get_format (abfd) != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  tdata = ecoff_data (abfd);
  tdata->gprmask = gprmask;
  tdata->fprmask = fprmask;
  if (cprmask != NULL)
    {
      int i;

      for (i = 0; i < 3; i++)
	tdata->cprmask[i] = cprmask[i];
    }

  return TRUE;
}

/* Get ECOFF EXTR information for an external symbol.  This function
   is passed to bfd_ecoff_debug_externals.  */

static bfd_boolean
ecoff_get_extr (asymbol *sym, EXTR *esym)
{
  ecoff_symbol_type *ecoff_sym_ptr;
  bfd *input_bfd;

  if (bfd_asymbol_flavour (sym) != bfd_target_ecoff_flavour
      || ecoffsymbol (sym)->native == NULL)
    {
      /* Don't include debugging, local, or section symbols.  */
      if ((sym->flags & BSF_DEBUGGING) != 0
	  || (sym->flags & BSF_LOCAL) != 0
	  || (sym->flags & BSF_SECTION_SYM) != 0)
	return FALSE;

      esym->jmptbl = 0;
      esym->cobol_main = 0;
      esym->weakext = (sym->flags & BSF_WEAK) != 0;
      esym->reserved = 0;
      esym->ifd = ifdNil;
      /* FIXME: we can do better than this for st and sc.  */
      esym->asym.st = stGlobal;
      esym->asym.sc = scAbs;
      esym->asym.reserved = 0;
      esym->asym.index = indexNil;
      return TRUE;
    }

  ecoff_sym_ptr = ecoffsymbol (sym);

  if (ecoff_sym_ptr->local)
    return FALSE;

  input_bfd = bfd_asymbol_bfd (sym);
  (*(ecoff_backend (input_bfd)->debug_swap.swap_ext_in))
    (input_bfd, ecoff_sym_ptr->native, esym);

  /* If the symbol was defined by the linker, then esym will be
     undefined but sym will not be.  Get a better class for such a
     symbol.  */
  if ((esym->asym.sc == scUndefined
       || esym->asym.sc == scSUndefined)
      && ! bfd_is_und_section (bfd_get_section (sym)))
    esym->asym.sc = scAbs;

  /* Adjust the FDR index for the symbol by that used for the input
     BFD.  */
  if (esym->ifd != -1)
    {
      struct ecoff_debug_info *input_debug;

      input_debug = &ecoff_data (input_bfd)->debug_info;
      BFD_ASSERT (esym->ifd < input_debug->symbolic_header.ifdMax);
      if (input_debug->ifdmap != NULL)
	esym->ifd = input_debug->ifdmap[esym->ifd];
    }

  return TRUE;
}

/* Set the external symbol index.  This routine is passed to
   bfd_ecoff_debug_externals.  */

static void
ecoff_set_index (asymbol *sym, bfd_size_type indx)
{
  ecoff_set_sym_index (sym, indx);
}

/* Write out an ECOFF file.  */

bfd_boolean
_bfd_ecoff_write_object_contents (bfd *abfd)
{
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  const bfd_vma round = backend->round;
  const bfd_size_type filhsz = bfd_coff_filhsz (abfd);
  const bfd_size_type aoutsz = bfd_coff_aoutsz (abfd);
  const bfd_size_type scnhsz = bfd_coff_scnhsz (abfd);
  const bfd_size_type external_hdr_size
    = backend->debug_swap.external_hdr_size;
  const bfd_size_type external_reloc_size = backend->external_reloc_size;
  void (* const adjust_reloc_out) (bfd *, const arelent *, struct internal_reloc *)
    = backend->adjust_reloc_out;
  void (* const swap_reloc_out) (bfd *, const struct internal_reloc *, void *)
    = backend->swap_reloc_out;
  struct ecoff_debug_info * const debug = &ecoff_data (abfd)->debug_info;
  HDRR * const symhdr = &debug->symbolic_header;
  asection *current;
  unsigned int count;
  bfd_size_type reloc_size;
  bfd_size_type text_size;
  bfd_vma text_start;
  bfd_boolean set_text_start;
  bfd_size_type data_size;
  bfd_vma data_start;
  bfd_boolean set_data_start;
  bfd_size_type bss_size;
  void * buff = NULL;
  void * reloc_buff = NULL;
  struct internal_filehdr internal_f;
  struct internal_aouthdr internal_a;
  int i;

  /* Determine where the sections and relocs will go in the output
     file.  */
  reloc_size = ecoff_compute_reloc_file_positions (abfd);

  count = 1;
  for (current = abfd->sections;
       current != NULL;
       current = current->next)
    {
      current->target_index = count;
      ++count;
    }

  if ((abfd->flags & D_PAGED) != 0)
    text_size = _bfd_ecoff_sizeof_headers (abfd, NULL);
  else
    text_size = 0;
  text_start = 0;
  set_text_start = FALSE;
  data_size = 0;
  data_start = 0;
  set_data_start = FALSE;
  bss_size = 0;

  /* Write section headers to the file.  */

  /* Allocate buff big enough to hold a section header,
     file header, or a.out header.  */
  {
    bfd_size_type siz;

    siz = scnhsz;
    if (siz < filhsz)
      siz = filhsz;
    if (siz < aoutsz)
      siz = aoutsz;
    buff = bfd_malloc (siz);
    if (buff == NULL)
      goto error_return;
  }

  internal_f.f_nscns = 0;
  if (bfd_seek (abfd, (file_ptr) (filhsz + aoutsz), SEEK_SET) != 0)
    goto error_return;

  for (current = abfd->sections;
       current != NULL;
       current = current->next)
    {
      struct internal_scnhdr section;
      bfd_vma vma;

      ++internal_f.f_nscns;

      strncpy (section.s_name, current->name, sizeof section.s_name);

      /* This seems to be correct for Irix 4 shared libraries.  */
      vma = bfd_get_section_vma (abfd, current);
      if (streq (current->name, _LIB))
	section.s_vaddr = 0;
      else
	section.s_vaddr = vma;

      section.s_paddr = current->lma;
      section.s_size = current->size;

      /* If this section is unloadable then the scnptr will be 0.  */
      if ((current->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	section.s_scnptr = 0;
      else
	section.s_scnptr = current->filepos;
      section.s_relptr = current->rel_filepos;

      /* FIXME: the lnnoptr of the .sbss or .sdata section of an
	 object file produced by the assembler is supposed to point to
	 information about how much room is required by objects of
	 various different sizes.  I think this only matters if we
	 want the linker to compute the best size to use, or
	 something.  I don't know what happens if the information is
	 not present.  */
      if (! streq (current->name, _PDATA))
	section.s_lnnoptr = 0;
      else
	{
	  /* The Alpha ECOFF .pdata section uses the lnnoptr field to
	     hold the number of entries in the section (each entry is
	     8 bytes).  We stored this in the line_filepos field in
	     ecoff_compute_section_file_positions.  */
	  section.s_lnnoptr = current->line_filepos;
	}

      section.s_nreloc = current->reloc_count;
      section.s_nlnno = 0;
      section.s_flags = ecoff_sec_to_styp_flags (current->name,
						 current->flags);

      if (bfd_coff_swap_scnhdr_out (abfd, (void *) &section, buff) == 0
	  || bfd_bwrite (buff, scnhsz, abfd) != scnhsz)
	goto error_return;

      if ((section.s_flags & STYP_TEXT) != 0
	  || ((section.s_flags & STYP_RDATA) != 0
	      && ecoff_data (abfd)->rdata_in_text)
	  || section.s_flags == STYP_PDATA
	  || (section.s_flags & STYP_DYNAMIC) != 0
	  || (section.s_flags & STYP_LIBLIST) != 0
	  || (section.s_flags & STYP_RELDYN) != 0
	  || section.s_flags == STYP_CONFLIC
	  || (section.s_flags & STYP_DYNSTR) != 0
	  || (section.s_flags & STYP_DYNSYM) != 0
	  || (section.s_flags & STYP_HASH) != 0
	  || (section.s_flags & STYP_ECOFF_INIT) != 0
	  || (section.s_flags & STYP_ECOFF_FINI) != 0
	  || section.s_flags == STYP_RCONST)
	{
	  text_size += current->size;
	  if (! set_text_start || text_start > vma)
	    {
	      text_start = vma;
	      set_text_start = TRUE;
	    }
	}
      else if ((section.s_flags & STYP_RDATA) != 0
	       || (section.s_flags & STYP_DATA) != 0
	       || (section.s_flags & STYP_LITA) != 0
	       || (section.s_flags & STYP_LIT8) != 0
	       || (section.s_flags & STYP_LIT4) != 0
	       || (section.s_flags & STYP_SDATA) != 0
	       || section.s_flags == STYP_XDATA
	       || (section.s_flags & STYP_GOT) != 0)
	{
	  data_size += current->size;
	  if (! set_data_start || data_start > vma)
	    {
	      data_start = vma;
	      set_data_start = TRUE;
	    }
	}
      else if ((section.s_flags & STYP_BSS) != 0
	       || (section.s_flags & STYP_SBSS) != 0)
	bss_size += current->size;
      else if (section.s_flags == 0
	       || (section.s_flags & STYP_ECOFF_LIB) != 0
	       || section.s_flags == STYP_COMMENT)
	/* Do nothing.  */ ;
      else
	abort ();
    }

  /* Set up the file header.  */
  internal_f.f_magic = ecoff_get_magic (abfd);

  /* We will NOT put a fucking timestamp in the header here. Every
     time you put it back, I will come in and take it out again.  I'm
     sorry.  This field does not belong here.  We fill it with a 0 so
     it compares the same but is not a reasonable time. --
     gnu@@cygnus.com.  */
  internal_f.f_timdat = 0;

  if (bfd_get_symcount (abfd) != 0)
    {
      /* The ECOFF f_nsyms field is not actually the number of
	 symbols, it's the size of symbolic information header.  */
      internal_f.f_nsyms = external_hdr_size;
      internal_f.f_symptr = ecoff_data (abfd)->sym_filepos;
    }
  else
    {
      internal_f.f_nsyms = 0;
      internal_f.f_symptr = 0;
    }

  internal_f.f_opthdr = aoutsz;

  internal_f.f_flags = F_LNNO;
  if (reloc_size == 0)
    internal_f.f_flags |= F_RELFLG;
  if (bfd_get_symcount (abfd) == 0)
    internal_f.f_flags |= F_LSYMS;
  if (abfd->flags & EXEC_P)
    internal_f.f_flags |= F_EXEC;

  if (bfd_little_endian (abfd))
    internal_f.f_flags |= F_AR32WR;
  else
    internal_f.f_flags |= F_AR32W;

  /* Set up the ``optional'' header.  */
  if ((abfd->flags & D_PAGED) != 0)
    internal_a.magic = ECOFF_AOUT_ZMAGIC;
  else
    internal_a.magic = ECOFF_AOUT_OMAGIC;

  /* FIXME: Is this really correct?  */
  internal_a.vstamp = symhdr->vstamp;

  /* At least on Ultrix, these have to be rounded to page boundaries.
     FIXME: Is this true on other platforms?  */
  if ((abfd->flags & D_PAGED) != 0)
    {
      internal_a.tsize = (text_size + round - 1) &~ (round - 1);
      internal_a.text_start = text_start &~ (round - 1);
      internal_a.dsize = (data_size + round - 1) &~ (round - 1);
      internal_a.data_start = data_start &~ (round - 1);
    }
  else
    {
      internal_a.tsize = text_size;
      internal_a.text_start = text_start;
      internal_a.dsize = data_size;
      internal_a.data_start = data_start;
    }

  /* On Ultrix, the initial portions of the .sbss and .bss segments
     are at the end of the data section.  The bsize field in the
     optional header records how many bss bytes are required beyond
     those in the data section.  The value is not rounded to a page
     boundary.  */
  if (bss_size < internal_a.dsize - data_size)
    bss_size = 0;
  else
    bss_size -= internal_a.dsize - data_size;
  internal_a.bsize = bss_size;
  internal_a.bss_start = internal_a.data_start + internal_a.dsize;

  internal_a.entry = bfd_get_start_address (abfd);

  internal_a.gp_value = ecoff_data (abfd)->gp;

  internal_a.gprmask = ecoff_data (abfd)->gprmask;
  internal_a.fprmask = ecoff_data (abfd)->fprmask;
  for (i = 0; i < 4; i++)
    internal_a.cprmask[i] = ecoff_data (abfd)->cprmask[i];

  /* Let the backend adjust the headers if necessary.  */
  if (backend->adjust_headers)
    {
      if (! (*backend->adjust_headers) (abfd, &internal_f, &internal_a))
	goto error_return;
    }

  /* Write out the file header and the optional header.  */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto error_return;

  bfd_coff_swap_filehdr_out (abfd, (void *) &internal_f, buff);
  if (bfd_bwrite (buff, filhsz, abfd) != filhsz)
    goto error_return;

  bfd_coff_swap_aouthdr_out (abfd, (void *) &internal_a, buff);
  if (bfd_bwrite (buff, aoutsz, abfd) != aoutsz)
    goto error_return;

  /* Build the external symbol information.  This must be done before
     writing out the relocs so that we know the symbol indices.  We
     don't do this if this BFD was created by the backend linker,
     since it will have already handled the symbols and relocs.  */
  if (! ecoff_data (abfd)->linker)
    {
      symhdr->iextMax = 0;
      symhdr->issExtMax = 0;
      debug->external_ext = debug->external_ext_end = NULL;
      debug->ssext = debug->ssext_end = NULL;
      if (! bfd_ecoff_debug_externals (abfd, debug, &backend->debug_swap,
				       (abfd->flags & EXEC_P) == 0,
				       ecoff_get_extr, ecoff_set_index))
	goto error_return;

      /* Write out the relocs.  */
      for (current = abfd->sections;
	   current != NULL;
	   current = current->next)
	{
	  arelent **reloc_ptr_ptr;
	  arelent **reloc_end;
	  char *out_ptr;
	  bfd_size_type amt;

	  if (current->reloc_count == 0)
	    continue;

	  amt = current->reloc_count * external_reloc_size;
	  reloc_buff = bfd_alloc (abfd, amt);
	  if (reloc_buff == NULL)
	    goto error_return;

	  reloc_ptr_ptr = current->orelocation;
	  reloc_end = reloc_ptr_ptr + current->reloc_count;
	  out_ptr = (char *) reloc_buff;

	  for (;
	       reloc_ptr_ptr < reloc_end;
	       reloc_ptr_ptr++, out_ptr += external_reloc_size)
	    {
	      arelent *reloc;
	      asymbol *sym;
	      struct internal_reloc in;

	      memset ((void *) &in, 0, sizeof in);

	      reloc = *reloc_ptr_ptr;
	      sym = *reloc->sym_ptr_ptr;

	      /* If the howto field has not been initialised then skip this reloc.
		 This assumes that an error message has been issued elsewhere.  */
	      if (reloc->howto == NULL)
		continue;

	      in.r_vaddr = (reloc->address
			    + bfd_get_section_vma (abfd, current));
	      in.r_type = reloc->howto->type;

	      if ((sym->flags & BSF_SECTION_SYM) == 0)
		{
		  in.r_symndx = ecoff_get_sym_index (*reloc->sym_ptr_ptr);
		  in.r_extern = 1;
		}
	      else
		{
		  const char *name;
		  unsigned int j;
		  static struct
		  {
		    const char * name;
		    long r_symndx;
		  }
		  section_symndx [] =
		  {
		    { _TEXT,   RELOC_SECTION_TEXT   },
		    { _RDATA,  RELOC_SECTION_RDATA  },
		    { _DATA,   RELOC_SECTION_DATA   },
		    { _SDATA,  RELOC_SECTION_SDATA  },
		    { _SBSS,   RELOC_SECTION_SBSS   },
		    { _BSS,    RELOC_SECTION_BSS    },
		    { _INIT,   RELOC_SECTION_INIT   },
		    { _LIT8,   RELOC_SECTION_LIT8   },
		    { _LIT4,   RELOC_SECTION_LIT4   },
		    { _XDATA,  RELOC_SECTION_XDATA  },
		    { _PDATA,  RELOC_SECTION_PDATA  },
		    { _FINI,   RELOC_SECTION_FINI   },
		    { _LITA,   RELOC_SECTION_LITA   },
		    { "*ABS*", RELOC_SECTION_ABS    },
		    { _RCONST, RELOC_SECTION_RCONST }
		  };

		  name = bfd_get_section_name (abfd, bfd_get_section (sym));

		  for (j = 0; j < ARRAY_SIZE (section_symndx); j++)
		    if (streq (name, section_symndx[j].name))
		      {
			in.r_symndx = section_symndx[j].r_symndx;
			break;
		      }

		  if (j == ARRAY_SIZE (section_symndx))
		    abort ();
		  in.r_extern = 0;
		}

	      (*adjust_reloc_out) (abfd, reloc, &in);

	      (*swap_reloc_out) (abfd, &in, (void *) out_ptr);
	    }

	  if (bfd_seek (abfd, current->rel_filepos, SEEK_SET) != 0)
	    goto error_return;
	  amt = current->reloc_count * external_reloc_size;
	  if (bfd_bwrite (reloc_buff, amt, abfd) != amt)
	    goto error_return;
	  bfd_release (abfd, reloc_buff);
	  reloc_buff = NULL;
	}

      /* Write out the symbolic debugging information.  */
      if (bfd_get_symcount (abfd) > 0)
	{
	  /* Write out the debugging information.  */
	  if (! bfd_ecoff_write_debug (abfd, debug, &backend->debug_swap,
				       ecoff_data (abfd)->sym_filepos))
	    goto error_return;
	}
    }

  /* The .bss section of a demand paged executable must receive an
     entire page.  If there are symbols, the symbols will start on the
     next page.  If there are no symbols, we must fill out the page by
     hand.  */
  if (bfd_get_symcount (abfd) == 0
      && (abfd->flags & EXEC_P) != 0
      && (abfd->flags & D_PAGED) != 0)
    {
      char c;

      if (bfd_seek (abfd, (file_ptr) ecoff_data (abfd)->sym_filepos - 1,
		    SEEK_SET) != 0)
	goto error_return;
      if (bfd_bread (&c, (bfd_size_type) 1, abfd) == 0)
	c = 0;
      if (bfd_seek (abfd, (file_ptr) ecoff_data (abfd)->sym_filepos - 1,
		    SEEK_SET) != 0)
	goto error_return;
      if (bfd_bwrite (&c, (bfd_size_type) 1, abfd) != 1)
	goto error_return;
    }

  if (reloc_buff != NULL)
    bfd_release (abfd, reloc_buff);
  if (buff != NULL)
    free (buff);
  return TRUE;
 error_return:
  if (reloc_buff != NULL)
    bfd_release (abfd, reloc_buff);
  if (buff != NULL)
    free (buff);
  return FALSE;
}

/* Archive handling.  ECOFF uses what appears to be a unique type of
   archive header (armap).  The byte ordering of the armap and the
   contents are encoded in the name of the armap itself.  At least for
   now, we only support archives with the same byte ordering in the
   armap and the contents.

   The first four bytes in the armap are the number of symbol
   definitions.  This is always a power of two.

   This is followed by the symbol definitions.  Each symbol definition
   occupies 8 bytes.  The first four bytes are the offset from the
   start of the armap strings to the null-terminated string naming
   this symbol.  The second four bytes are the file offset to the
   archive member which defines this symbol.  If the second four bytes
   are 0, then this is not actually a symbol definition, and it should
   be ignored.

   The symbols are hashed into the armap with a closed hashing scheme.
   See the functions below for the details of the algorithm.

   After the symbol definitions comes four bytes holding the size of
   the string table, followed by the string table itself.  */

/* The name of an archive headers looks like this:
   __________E[BL]E[BL]_ (with a trailing space).
   The trailing space is changed to an X if the archive is changed to
   indicate that the armap is out of date.

   The Alpha seems to use ________64E[BL]E[BL]_.  */

#define ARMAP_BIG_ENDIAN 		'B'
#define ARMAP_LITTLE_ENDIAN 		'L'
#define ARMAP_MARKER 			'E'
#define ARMAP_START_LENGTH 		10
#define ARMAP_HEADER_MARKER_INDEX	10
#define ARMAP_HEADER_ENDIAN_INDEX 	11
#define ARMAP_OBJECT_MARKER_INDEX 	12
#define ARMAP_OBJECT_ENDIAN_INDEX 	13
#define ARMAP_END_INDEX 		14
#define ARMAP_END 			"_ "

/* This is a magic number used in the hashing algorithm.  */
#define ARMAP_HASH_MAGIC 		0x9dd68ab5

/* This returns the hash value to use for a string.  It also sets
   *REHASH to the rehash adjustment if the first slot is taken.  SIZE
   is the number of entries in the hash table, and HLOG is the log
   base 2 of SIZE.  */

static unsigned int
ecoff_armap_hash (const char *s,
		  unsigned int *rehash,
		  unsigned int size,
		  unsigned int hlog)
{
  unsigned int hash;

  if (hlog == 0)
    return 0;
  hash = *s++;
  while (*s != '\0')
    hash = ((hash >> 27) | (hash << 5)) + *s++;
  hash *= ARMAP_HASH_MAGIC;
  *rehash = (hash & (size - 1)) | 1;
  return hash >> (32 - hlog);
}

/* Read in the armap.  */

bfd_boolean
_bfd_ecoff_slurp_armap (bfd *abfd)
{
  char nextname[17];
  unsigned int i;
  struct areltdata *mapdata;
  bfd_size_type parsed_size;
  char *raw_armap;
  struct artdata *ardata;
  unsigned int count;
  char *raw_ptr;
  carsym *symdef_ptr;
  char *stringbase;
  bfd_size_type amt;

  /* Get the name of the first element.  */
  i = bfd_bread ((void *) nextname, (bfd_size_type) 16, abfd);
  if (i == 0)
      return TRUE;
  if (i != 16)
      return FALSE;

  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return FALSE;

  /* Irix 4.0.5F apparently can use either an ECOFF armap or a
     standard COFF armap.  We could move the ECOFF armap stuff into
     bfd_slurp_armap, but that seems inappropriate since no other
     target uses this format.  Instead, we check directly for a COFF
     armap.  */
  if (CONST_STRNEQ (nextname, "/               "))
    return bfd_slurp_armap (abfd);

  /* See if the first element is an armap.  */
  if (! strneq (nextname, ecoff_backend (abfd)->armap_start, ARMAP_START_LENGTH)
      || nextname[ARMAP_HEADER_MARKER_INDEX] != ARMAP_MARKER
      || (nextname[ARMAP_HEADER_ENDIAN_INDEX] != ARMAP_BIG_ENDIAN
	  && nextname[ARMAP_HEADER_ENDIAN_INDEX] != ARMAP_LITTLE_ENDIAN)
      || nextname[ARMAP_OBJECT_MARKER_INDEX] != ARMAP_MARKER
      || (nextname[ARMAP_OBJECT_ENDIAN_INDEX] != ARMAP_BIG_ENDIAN
	  && nextname[ARMAP_OBJECT_ENDIAN_INDEX] != ARMAP_LITTLE_ENDIAN)
      || ! strneq (nextname + ARMAP_END_INDEX, ARMAP_END, sizeof ARMAP_END - 1))
    {
      bfd_has_map (abfd) = FALSE;
      return TRUE;
    }

  /* Make sure we have the right byte ordering.  */
  if (((nextname[ARMAP_HEADER_ENDIAN_INDEX] == ARMAP_BIG_ENDIAN)
       ^ (bfd_header_big_endian (abfd)))
      || ((nextname[ARMAP_OBJECT_ENDIAN_INDEX] == ARMAP_BIG_ENDIAN)
	  ^ (bfd_big_endian (abfd))))
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  /* Read in the armap.  */
  ardata = bfd_ardata (abfd);
  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
  if (mapdata == NULL)
    return FALSE;
  parsed_size = mapdata->parsed_size;
  free (mapdata);

  raw_armap = (char *) bfd_alloc (abfd, parsed_size);
  if (raw_armap == NULL)
    return FALSE;

  if (bfd_bread ((void *) raw_armap, parsed_size, abfd) != parsed_size)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      bfd_release (abfd, (void *) raw_armap);
      return FALSE;
    }

  ardata->tdata = (void *) raw_armap;

  count = H_GET_32 (abfd, raw_armap);

  ardata->symdef_count = 0;
  ardata->cache = NULL;

  /* This code used to overlay the symdefs over the raw archive data,
     but that doesn't work on a 64 bit host.  */
  stringbase = raw_armap + count * 8 + 8;

#ifdef CHECK_ARMAP_HASH
  {
    unsigned int hlog;

    /* Double check that I have the hashing algorithm right by making
       sure that every symbol can be looked up successfully.  */
    hlog = 0;
    for (i = 1; i < count; i <<= 1)
      hlog++;
    BFD_ASSERT (i == count);

    raw_ptr = raw_armap + 4;
    for (i = 0; i < count; i++, raw_ptr += 8)
      {
	unsigned int name_offset, file_offset;
	unsigned int hash, rehash, srch;

	name_offset = H_GET_32 (abfd, raw_ptr);
	file_offset = H_GET_32 (abfd, (raw_ptr + 4));
	if (file_offset == 0)
	  continue;
	hash = ecoff_armap_hash (stringbase + name_offset, &rehash, count,
				 hlog);
	if (hash == i)
	  continue;

	/* See if we can rehash to this location.  */
	for (srch = (hash + rehash) & (count - 1);
	     srch != hash && srch != i;
	     srch = (srch + rehash) & (count - 1))
	  BFD_ASSERT (H_GET_32 (abfd, (raw_armap + 8 + srch * 8)) != 0);
	BFD_ASSERT (srch == i);
      }
  }

#endif /* CHECK_ARMAP_HASH */

  raw_ptr = raw_armap + 4;
  for (i = 0; i < count; i++, raw_ptr += 8)
    if (H_GET_32 (abfd, (raw_ptr + 4)) != 0)
      ++ardata->symdef_count;

  amt = ardata->symdef_count;
  amt *= sizeof (carsym);
  symdef_ptr = (carsym *) bfd_alloc (abfd, amt);
  if (!symdef_ptr)
    return FALSE;

  ardata->symdefs = symdef_ptr;

  raw_ptr = raw_armap + 4;
  for (i = 0; i < count; i++, raw_ptr += 8)
    {
      unsigned int name_offset, file_offset;

      file_offset = H_GET_32 (abfd, (raw_ptr + 4));
      if (file_offset == 0)
	continue;
      name_offset = H_GET_32 (abfd, raw_ptr);
      symdef_ptr->name = stringbase + name_offset;
      symdef_ptr->file_offset = file_offset;
      ++symdef_ptr;
    }

  ardata->first_file_filepos = bfd_tell (abfd);
  /* Pad to an even boundary.  */
  ardata->first_file_filepos += ardata->first_file_filepos % 2;

  bfd_has_map (abfd) = TRUE;

  return TRUE;
}

/* Write out an armap.  */

bfd_boolean
_bfd_ecoff_write_armap (bfd *abfd,
			unsigned int elength,
			struct orl *map,
			unsigned int orl_count,
			int stridx)
{
  unsigned int hashsize, hashlog;
  bfd_size_type symdefsize;
  int padit;
  unsigned int stringsize;
  unsigned int mapsize;
  file_ptr firstreal;
  struct ar_hdr hdr;
  struct stat statbuf;
  unsigned int i;
  bfd_byte temp[4];
  bfd_byte *hashtable;
  bfd *current;
  bfd *last_elt;

  /* Ultrix appears to use as a hash table size the least power of two
     greater than twice the number of entries.  */
  for (hashlog = 0; ((unsigned int) 1 << hashlog) <= 2 * orl_count; hashlog++)
    ;
  hashsize = 1 << hashlog;

  symdefsize = hashsize * 8;
  padit = stridx % 2;
  stringsize = stridx + padit;

  /* Include 8 bytes to store symdefsize and stringsize in output.  */
  mapsize = symdefsize + stringsize + 8;

  firstreal = SARMAG + sizeof (struct ar_hdr) + mapsize + elength;

  memset ((void *) &hdr, 0, sizeof hdr);

  /* Work out the ECOFF armap name.  */
  strcpy (hdr.ar_name, ecoff_backend (abfd)->armap_start);
  hdr.ar_name[ARMAP_HEADER_MARKER_INDEX] = ARMAP_MARKER;
  hdr.ar_name[ARMAP_HEADER_ENDIAN_INDEX] =
    (bfd_header_big_endian (abfd)
     ? ARMAP_BIG_ENDIAN
     : ARMAP_LITTLE_ENDIAN);
  hdr.ar_name[ARMAP_OBJECT_MARKER_INDEX] = ARMAP_MARKER;
  hdr.ar_name[ARMAP_OBJECT_ENDIAN_INDEX] =
    bfd_big_endian (abfd) ? ARMAP_BIG_ENDIAN : ARMAP_LITTLE_ENDIAN;
  memcpy (hdr.ar_name + ARMAP_END_INDEX, ARMAP_END, sizeof ARMAP_END - 1);

  /* Write the timestamp of the archive header to be just a little bit
     later than the timestamp of the file, otherwise the linker will
     complain that the index is out of date.  Actually, the Ultrix
     linker just checks the archive name; the GNU linker may check the
     date.  */
  stat (abfd->filename, &statbuf);
  _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), "%ld",
		    (long) (statbuf.st_mtime + 60));

  /* The DECstation uses zeroes for the uid, gid and mode of the
     armap.  */
  hdr.ar_uid[0] = '0';
  hdr.ar_gid[0] = '0';
  /* Building gcc ends up extracting the armap as a file - twice.  */
  hdr.ar_mode[0] = '6';
  hdr.ar_mode[1] = '4';
  hdr.ar_mode[2] = '4';

  _bfd_ar_spacepad (hdr.ar_size, sizeof (hdr.ar_size), "%-10ld", mapsize);

  hdr.ar_fmag[0] = '`';
  hdr.ar_fmag[1] = '\012';

  /* Turn all null bytes in the header into spaces.  */
  for (i = 0; i < sizeof (struct ar_hdr); i++)
   if (((char *) (&hdr))[i] == '\0')
     (((char *) (&hdr))[i]) = ' ';

  if (bfd_bwrite ((void *) &hdr, (bfd_size_type) sizeof (struct ar_hdr), abfd)
      != sizeof (struct ar_hdr))
    return FALSE;

  H_PUT_32 (abfd, hashsize, temp);
  if (bfd_bwrite ((void *) temp, (bfd_size_type) 4, abfd) != 4)
    return FALSE;

  hashtable = (bfd_byte *) bfd_zalloc (abfd, symdefsize);
  if (!hashtable)
    return FALSE;

  current = abfd->archive_head;
  last_elt = current;
  for (i = 0; i < orl_count; i++)
    {
      unsigned int hash, rehash = 0;

      /* Advance firstreal to the file position of this archive
	 element.  */
      if (map[i].u.abfd != last_elt)
	{
	  do
	    {
	      firstreal += arelt_size (current) + sizeof (struct ar_hdr);
	      firstreal += firstreal % 2;
	      current = current->archive_next;
	    }
	  while (current != map[i].u.abfd);
	}

      last_elt = current;

      hash = ecoff_armap_hash (*map[i].name, &rehash, hashsize, hashlog);
      if (H_GET_32 (abfd, (hashtable + (hash * 8) + 4)) != 0)
	{
	  unsigned int srch;

	  /* The desired slot is already taken.  */
	  for (srch = (hash + rehash) & (hashsize - 1);
	       srch != hash;
	       srch = (srch + rehash) & (hashsize - 1))
	    if (H_GET_32 (abfd, (hashtable + (srch * 8) + 4)) == 0)
	      break;

	  BFD_ASSERT (srch != hash);

	  hash = srch;
	}

      H_PUT_32 (abfd, map[i].namidx, (hashtable + hash * 8));
      H_PUT_32 (abfd, firstreal, (hashtable + hash * 8 + 4));
    }

  if (bfd_bwrite ((void *) hashtable, symdefsize, abfd) != symdefsize)
    return FALSE;

  bfd_release (abfd, hashtable);

  /* Now write the strings.  */
  H_PUT_32 (abfd, stringsize, temp);
  if (bfd_bwrite ((void *) temp, (bfd_size_type) 4, abfd) != 4)
    return FALSE;
  for (i = 0; i < orl_count; i++)
    {
      bfd_size_type len;

      len = strlen (*map[i].name) + 1;
      if (bfd_bwrite ((void *) (*map[i].name), len, abfd) != len)
	return FALSE;
    }

  /* The spec sez this should be a newline.  But in order to be
     bug-compatible for DECstation ar we use a null.  */
  if (padit)
    {
      if (bfd_bwrite ("", (bfd_size_type) 1, abfd) != 1)
	return FALSE;
    }

  return TRUE;
}

/* ECOFF linker code.  */

/* Routine to create an entry in an ECOFF link hash table.  */

static struct bfd_hash_entry *
ecoff_link_hash_newfunc (struct bfd_hash_entry *entry,
			 struct bfd_hash_table *table,
			 const char *string)
{
  struct ecoff_link_hash_entry *ret = (struct ecoff_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = ((struct ecoff_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct ecoff_link_hash_entry)));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct ecoff_link_hash_entry *)
	 _bfd_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				 table, string));

  if (ret)
    {
      /* Set local fields.  */
      ret->indx = -1;
      ret->abfd = NULL;
      ret->written = 0;
      ret->small = 0;
    }
  memset ((void *) &ret->esym, 0, sizeof ret->esym);

  return (struct bfd_hash_entry *) ret;
}

/* Create an ECOFF link hash table.  */

struct bfd_link_hash_table *
_bfd_ecoff_bfd_link_hash_table_create (bfd *abfd)
{
  struct ecoff_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct ecoff_link_hash_table);

  ret = (struct ecoff_link_hash_table *) bfd_malloc (amt);
  if (ret == NULL)
    return NULL;
  if (!_bfd_link_hash_table_init (&ret->root, abfd,
				  ecoff_link_hash_newfunc,
				  sizeof (struct ecoff_link_hash_entry)))
    {
      free (ret);
      return NULL;
    }
  return &ret->root;
}

/* Look up an entry in an ECOFF link hash table.  */

#define ecoff_link_hash_lookup(table, string, create, copy, follow) \
  ((struct ecoff_link_hash_entry *) \
   bfd_link_hash_lookup (&(table)->root, (string), (create), (copy), (follow)))

/* Get the ECOFF link hash table from the info structure.  This is
   just a cast.  */

#define ecoff_hash_table(p) ((struct ecoff_link_hash_table *) ((p)->hash))

/* Add the external symbols of an object file to the global linker
   hash table.  The external symbols and strings we are passed are
   just allocated on the stack, and will be discarded.  We must
   explicitly save any information we may need later on in the link.
   We do not want to read the external symbol information again.  */

static bfd_boolean
ecoff_link_add_externals (bfd *abfd,
			  struct bfd_link_info *info,
			  void * external_ext,
			  char *ssext)
{
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  void (* const swap_ext_in) (bfd *, void *, EXTR *)
    = backend->debug_swap.swap_ext_in;
  bfd_size_type external_ext_size = backend->debug_swap.external_ext_size;
  unsigned long ext_count;
  struct bfd_link_hash_entry **sym_hash;
  char *ext_ptr;
  char *ext_end;
  bfd_size_type amt;

  ext_count = ecoff_data (abfd)->debug_info.symbolic_header.iextMax;

  amt = ext_count;
  amt *= sizeof (struct bfd_link_hash_entry *);
  sym_hash = (struct bfd_link_hash_entry **) bfd_alloc (abfd, amt);
  if (!sym_hash)
    return FALSE;
  ecoff_data (abfd)->sym_hashes = (struct ecoff_link_hash_entry **) sym_hash;

  ext_ptr = (char *) external_ext;
  ext_end = ext_ptr + ext_count * external_ext_size;
  for (; ext_ptr < ext_end; ext_ptr += external_ext_size, sym_hash++)
    {
      EXTR esym;
      bfd_boolean skip;
      bfd_vma value;
      asection *section;
      const char *name;
      struct ecoff_link_hash_entry *h;

      *sym_hash = NULL;

      (*swap_ext_in) (abfd, (void *) ext_ptr, &esym);

      /* Skip debugging symbols.  */
      skip = FALSE;
      switch (esym.asym.st)
	{
	case stGlobal:
	case stStatic:
	case stLabel:
	case stProc:
	case stStaticProc:
	  break;
	default:
	  skip = TRUE;
	  break;
	}

      if (skip)
	continue;

      /* Get the information for this symbol.  */
      value = esym.asym.value;
      switch (esym.asym.sc)
	{
	default:
	case scNil:
	case scRegister:
	case scCdbLocal:
	case scBits:
	case scCdbSystem:
	case scRegImage:
	case scInfo:
	case scUserStruct:
	case scVar:
	case scVarRegister:
	case scVariant:
	case scBasedVar:
	case scXData:
	case scPData:
	  section = NULL;
	  break;
	case scText:
	  section = bfd_make_section_old_way (abfd, _TEXT);
	  value -= section->vma;
	  break;
	case scData:
	  section = bfd_make_section_old_way (abfd, _DATA);
	  value -= section->vma;
	  break;
	case scBss:
	  section = bfd_make_section_old_way (abfd, _BSS);
	  value -= section->vma;
	  break;
	case scAbs:
	  section = bfd_abs_section_ptr;
	  break;
	case scUndefined:
	  section = bfd_und_section_ptr;
	  break;
	case scSData:
	  section = bfd_make_section_old_way (abfd, _SDATA);
	  value -= section->vma;
	  break;
	case scSBss:
	  section = bfd_make_section_old_way (abfd, _SBSS);
	  value -= section->vma;
	  break;
	case scRData:
	  section = bfd_make_section_old_way (abfd, _RDATA);
	  value -= section->vma;
	  break;
	case scCommon:
	  if (value > ecoff_data (abfd)->gp_size)
	    {
	      section = bfd_com_section_ptr;
	      break;
	    }
	  /* Fall through.  */
	case scSCommon:
	  if (ecoff_scom_section.name == NULL)
	    {
	      /* Initialize the small common section.  */
	      ecoff_scom_section.name = SCOMMON;
	      ecoff_scom_section.flags = SEC_IS_COMMON;
	      ecoff_scom_section.output_section = &ecoff_scom_section;
	      ecoff_scom_section.symbol = &ecoff_scom_symbol;
	      ecoff_scom_section.symbol_ptr_ptr = &ecoff_scom_symbol_ptr;
	      ecoff_scom_symbol.name = SCOMMON;
	      ecoff_scom_symbol.flags = BSF_SECTION_SYM;
	      ecoff_scom_symbol.section = &ecoff_scom_section;
	      ecoff_scom_symbol_ptr = &ecoff_scom_symbol;
	    }
	  section = &ecoff_scom_section;
	  break;
	case scSUndefined:
	  section = bfd_und_section_ptr;
	  break;
	case scInit:
	  section = bfd_make_section_old_way (abfd, _INIT);
	  value -= section->vma;
	  break;
	case scFini:
	  section = bfd_make_section_old_way (abfd, _FINI);
	  value -= section->vma;
	  break;
	case scRConst:
	  section = bfd_make_section_old_way (abfd, _RCONST);
	  value -= section->vma;
	  break;
	}

      if (section == NULL)
	continue;

      name = ssext + esym.asym.iss;

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, name,
	      (flagword) (esym.weakext ? BSF_WEAK : BSF_GLOBAL),
	      section, value, NULL, TRUE, TRUE, sym_hash)))
	return FALSE;

      h = (struct ecoff_link_hash_entry *) *sym_hash;

      /* If we are building an ECOFF hash table, save the external
	 symbol information.  */
      if (bfd_get_flavour (info->output_bfd) == bfd_get_flavour (abfd))
	{
	  if (h->abfd == NULL
	      || (! bfd_is_und_section (section)
		  && (! bfd_is_com_section (section)
		      || (h->root.type != bfd_link_hash_defined
			  && h->root.type != bfd_link_hash_defweak))))
	    {
	      h->abfd = abfd;
	      h->esym = esym;
	    }

	  /* Remember whether this symbol was small undefined.  */
	  if (esym.asym.sc == scSUndefined)
	    h->small = 1;

	  /* If this symbol was ever small undefined, it needs to wind
	     up in a GP relative section.  We can't control the
	     section of a defined symbol, but we can control the
	     section of a common symbol.  This case is actually needed
	     on Ultrix 4.2 to handle the symbol cred in -lckrb.  */
	  if (h->small
	      && h->root.type == bfd_link_hash_common
	      && streq (h->root.u.c.p->section->name, SCOMMON))
	    {
	      h->root.u.c.p->section = bfd_make_section_old_way (abfd,
								 SCOMMON);
	      h->root.u.c.p->section->flags = SEC_ALLOC;
	      if (h->esym.asym.sc == scCommon)
		h->esym.asym.sc = scSCommon;
	    }
	}
    }

  return TRUE;
}

/* Add symbols from an ECOFF object file to the global linker hash
   table.  */

static bfd_boolean
ecoff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
{
  HDRR *symhdr;
  bfd_size_type external_ext_size;
  void * external_ext = NULL;
  bfd_size_type esize;
  char *ssext = NULL;
  bfd_boolean result;

  if (! ecoff_slurp_symbolic_header (abfd))
    return FALSE;

  /* If there are no symbols, we don't want it.  */
  if (bfd_get_symcount (abfd) == 0)
    return TRUE;

  symhdr = &ecoff_data (abfd)->debug_info.symbolic_header;

  /* Read in the external symbols and external strings.  */
  external_ext_size = ecoff_backend (abfd)->debug_swap.external_ext_size;
  esize = symhdr->iextMax * external_ext_size;
  external_ext = bfd_malloc (esize);
  if (external_ext == NULL && esize != 0)
    goto error_return;

  if (bfd_seek (abfd, (file_ptr) symhdr->cbExtOffset, SEEK_SET) != 0
      || bfd_bread (external_ext, esize, abfd) != esize)
    goto error_return;

  ssext = (char *) bfd_malloc ((bfd_size_type) symhdr->issExtMax);
  if (ssext == NULL && symhdr->issExtMax != 0)
    goto error_return;

  if (bfd_seek (abfd, (file_ptr) symhdr->cbSsExtOffset, SEEK_SET) != 0
      || (bfd_bread (ssext, (bfd_size_type) symhdr->issExtMax, abfd)
	  != (bfd_size_type) symhdr->issExtMax))
    goto error_return;

  result = ecoff_link_add_externals (abfd, info, external_ext, ssext);

  if (ssext != NULL)
    free (ssext);
  if (external_ext != NULL)
    free (external_ext);
  return result;

 error_return:
  if (ssext != NULL)
    free (ssext);
  if (external_ext != NULL)
    free (external_ext);
  return FALSE;
}

/* Factored out from ecoff_link_check_archive_element.  */

static bfd_boolean
read_ext_syms_and_strs (HDRR **symhdr, bfd_size_type *external_ext_size,
	bfd_size_type *esize, void **external_ext, char **ssext, bfd *abfd,
	const struct ecoff_backend_data * const backend)
{
  if (! ecoff_slurp_symbolic_header (abfd))
    return FALSE;

  /* If there are no symbols, we don't want it.  */
  if (bfd_get_symcount (abfd) == 0)
    return TRUE;

  *symhdr = &ecoff_data (abfd)->debug_info.symbolic_header;

  *external_ext_size = backend->debug_swap.external_ext_size;
  *esize = (*symhdr)->iextMax * *external_ext_size;
  *external_ext = bfd_malloc (*esize);
  if (*external_ext == NULL && *esize != 0)
    return FALSE;

  if (bfd_seek (abfd, (file_ptr) (*symhdr)->cbExtOffset, SEEK_SET) != 0
      || bfd_bread (*external_ext, *esize, abfd) != *esize)
    return FALSE;

  *ssext = (char *) bfd_malloc ((bfd_size_type) (*symhdr)->issExtMax);
  if (*ssext == NULL && (*symhdr)->issExtMax != 0)
    return FALSE;

  if (bfd_seek (abfd, (file_ptr) (*symhdr)->cbSsExtOffset, SEEK_SET) != 0
      || (bfd_bread (*ssext, (bfd_size_type) (*symhdr)->issExtMax, abfd)
	  != (bfd_size_type) (*symhdr)->issExtMax))
    return FALSE;
  return TRUE;
}

static bfd_boolean
reread_ext_syms_and_strs (HDRR **symhdr, bfd_size_type *external_ext_size,
	bfd_size_type *esize, void **external_ext, char **ssext, bfd *abfd,
	const struct ecoff_backend_data * const backend)
{
  if (*external_ext != NULL)
    free (*external_ext);
  *external_ext = NULL;
  if (*ssext != NULL)
    free (*ssext);
  *ssext = NULL;
  return read_ext_syms_and_strs (symhdr, external_ext_size, esize,
				external_ext, ssext, abfd, backend);
}

/* This is called if we used _bfd_generic_link_add_archive_symbols
   because we were not dealing with an ECOFF archive.  */

static bfd_boolean
ecoff_link_check_archive_element (bfd *abfd,
				  struct bfd_link_info *info,
				  bfd_boolean *pneeded)
{
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  void (* const swap_ext_in) (bfd *, void *, EXTR *)
    = backend->debug_swap.swap_ext_in;
  HDRR *symhdr;
  bfd_size_type external_ext_size = 0;
  void * external_ext = NULL;
  bfd_size_type esize = 0;
  char *ssext = NULL;
  char *ext_ptr;
  char *ext_end;

  *pneeded = FALSE;

  /* Read in the external symbols and external strings.  */
  if (!read_ext_syms_and_strs (&symhdr, &external_ext_size, &esize,
	&external_ext, &ssext, abfd, backend))
    goto error_return;

  /* If there are no symbols, we don't want it.  */
  if (bfd_get_symcount (abfd) == 0)
    goto successful_return;

  /* Look through the external symbols to see if they define some
     symbol that is currently undefined.  */
  ext_ptr = (char *) external_ext;
  ext_end = ext_ptr + esize;
  for (; ext_ptr < ext_end; ext_ptr += external_ext_size)
    {
      EXTR esym;
      bfd_boolean def;
      const char *name;
      bfd *oldbfd;
      struct bfd_link_hash_entry *h;

      (*swap_ext_in) (abfd, (void *) ext_ptr, &esym);

      /* See if this symbol defines something.  */
      if (esym.asym.st != stGlobal
	  && esym.asym.st != stLabel
	  && esym.asym.st != stProc)
	continue;

      switch (esym.asym.sc)
	{
	case scText:
	case scData:
	case scBss:
	case scAbs:
	case scSData:
	case scSBss:
	case scRData:
	case scCommon:
	case scSCommon:
	case scInit:
	case scFini:
	case scRConst:
	  def = TRUE;
	  break;
	default:
	  def = FALSE;
	  break;
	}

      if (! def)
	continue;

      name = ssext + esym.asym.iss;
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

      /* Unlike the generic linker, we do not pull in elements because
	 of common symbols.  */
      if (h == NULL
	  || h->type != bfd_link_hash_undefined)
	continue;

      /* Include this element.  */
      oldbfd = abfd;
      if (!(*info->callbacks
	    ->add_archive_element) (info, abfd, name, &abfd))
	goto error_return;
      /* Potentially, the add_archive_element hook may have set a
	 substitute BFD for us.  */
      if (abfd != oldbfd
	  && !reread_ext_syms_and_strs (&symhdr, &external_ext_size, &esize,
					&external_ext, &ssext, abfd, backend))
	goto error_return;
      if (! ecoff_link_add_externals (abfd, info, external_ext, ssext))
	goto error_return;

      *pneeded = TRUE;
      goto successful_return;
    }

 successful_return:
  if (external_ext != NULL)
    free (external_ext);
  if (ssext != NULL)
    free (ssext);
  return TRUE;
 error_return:
  if (external_ext != NULL)
    free (external_ext);
  if (ssext != NULL)
    free (ssext);
  return FALSE;
}

/* Add the symbols from an archive file to the global hash table.
   This looks through the undefined symbols, looks each one up in the
   archive hash table, and adds any associated object file.  We do not
   use _bfd_generic_link_add_archive_symbols because ECOFF archives
   already have a hash table, so there is no reason to construct
   another one.  */

static bfd_boolean
ecoff_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
{
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  const bfd_byte *raw_armap;
  struct bfd_link_hash_entry **pundef;
  unsigned int armap_count;
  unsigned int armap_log;
  unsigned int i;
  const bfd_byte *hashtable;
  const char *stringbase;

  if (! bfd_has_map (abfd))
    {
      /* An empty archive is a special case.  */
      if (bfd_openr_next_archived_file (abfd, NULL) == NULL)
	return TRUE;
      bfd_set_error (bfd_error_no_armap);
      return FALSE;
    }

  /* If we don't have any raw data for this archive, as can happen on
     Irix 4.0.5F, we call the generic routine.
     FIXME: We should be more clever about this, since someday tdata
     may get to something for a generic archive.  */
  raw_armap = (const bfd_byte *) bfd_ardata (abfd)->tdata;
  if (raw_armap == NULL)
    return (_bfd_generic_link_add_archive_symbols
	    (abfd, info, ecoff_link_check_archive_element));

  armap_count = H_GET_32 (abfd, raw_armap);

  armap_log = 0;
  for (i = 1; i < armap_count; i <<= 1)
    armap_log++;
  BFD_ASSERT (i == armap_count);

  hashtable = raw_armap + 4;
  stringbase = (const char *) raw_armap + armap_count * 8 + 8;

  /* Look through the list of undefined symbols.  */
  pundef = &info->hash->undefs;
  while (*pundef != NULL)
    {
      struct bfd_link_hash_entry *h;
      unsigned int hash, rehash = 0;
      unsigned int file_offset;
      const char *name;
      bfd *element;

      h = *pundef;

      /* When a symbol is defined, it is not necessarily removed from
	 the list.  */
      if (h->type != bfd_link_hash_undefined
	  && h->type != bfd_link_hash_common)
	{
	  /* Remove this entry from the list, for general cleanliness
	     and because we are going to look through the list again
	     if we search any more libraries.  We can't remove the
	     entry if it is the tail, because that would lose any
	     entries we add to the list later on.  */
	  if (*pundef != info->hash->undefs_tail)
	    *pundef = (*pundef)->u.undef.next;
	  else
	    pundef = &(*pundef)->u.undef.next;
	  continue;
	}

      /* Native ECOFF linkers do not pull in archive elements merely
	 to satisfy common definitions, so neither do we.  We leave
	 them on the list, though, in case we are linking against some
	 other object format.  */
      if (h->type != bfd_link_hash_undefined)
	{
	  pundef = &(*pundef)->u.undef.next;
	  continue;
	}

      /* Look for this symbol in the archive hash table.  */
      hash = ecoff_armap_hash (h->root.string, &rehash, armap_count,
			       armap_log);

      file_offset = H_GET_32 (abfd, hashtable + (hash * 8) + 4);
      if (file_offset == 0)
	{
	  /* Nothing in this slot.  */
	  pundef = &(*pundef)->u.undef.next;
	  continue;
	}

      name = stringbase + H_GET_32 (abfd, hashtable + (hash * 8));
      if (name[0] != h->root.string[0]
	  || ! streq (name, h->root.string))
	{
	  unsigned int srch;
	  bfd_boolean found;

	  /* That was the wrong symbol.  Try rehashing.  */
	  found = FALSE;
	  for (srch = (hash + rehash) & (armap_count - 1);
	       srch != hash;
	       srch = (srch + rehash) & (armap_count - 1))
	    {
	      file_offset = H_GET_32 (abfd, hashtable + (srch * 8) + 4);
	      if (file_offset == 0)
		break;
	      name = stringbase + H_GET_32 (abfd, hashtable + (srch * 8));
	      if (name[0] == h->root.string[0]
		  && streq (name, h->root.string))
		{
		  found = TRUE;
		  break;
		}
	    }

	  if (! found)
	    {
	      pundef = &(*pundef)->u.undef.next;
	      continue;
	    }

	  hash = srch;
	}

      element = (*backend->get_elt_at_filepos) (abfd, (file_ptr) file_offset);
      if (element == NULL)
	return FALSE;

      if (! bfd_check_format (element, bfd_object))
	return FALSE;

      /* Unlike the generic linker, we know that this element provides
	 a definition for an undefined symbol and we know that we want
	 to include it.  We don't need to check anything.  */
      if (!(*info->callbacks
	    ->add_archive_element) (info, element, name, &element))
	return FALSE;
      if (! ecoff_link_add_object_symbols (element, info))
	return FALSE;

      pundef = &(*pundef)->u.undef.next;
    }

  return TRUE;
}

/* Given an ECOFF BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
_bfd_ecoff_bfd_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return ecoff_link_add_object_symbols (abfd, info);
    case bfd_archive:
      return ecoff_link_add_archive_symbols (abfd, info);
    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}


/* ECOFF final link routines.  */

/* Structure used to pass information to ecoff_link_write_external.  */

struct extsym_info
{
  bfd *abfd;
  struct bfd_link_info *info;
};

/* Accumulate the debugging information for an input BFD into the
   output BFD.  This must read in the symbolic information of the
   input BFD.  */

static bfd_boolean
ecoff_final_link_debug_accumulate (bfd *output_bfd,
				   bfd *input_bfd,
				   struct bfd_link_info *info,
				   void * handle)
{
  struct ecoff_debug_info * const debug = &ecoff_data (input_bfd)->debug_info;
  const struct ecoff_debug_swap * const swap =
    &ecoff_backend (input_bfd)->debug_swap;
  HDRR *symhdr = &debug->symbolic_header;
  bfd_boolean ret;

#define READ(ptr, offset, count, size, type)				 \
  if (symhdr->count == 0)						 \
    debug->ptr = NULL;							 \
  else									 \
    {									 \
      bfd_size_type amt = (bfd_size_type) size * symhdr->count;		 \
      debug->ptr = (type) bfd_malloc (amt);                              \
      if (debug->ptr == NULL)						 \
	{								 \
          ret = FALSE;							 \
          goto return_something;					 \
	}								 \
      if (bfd_seek (input_bfd, (file_ptr) symhdr->offset, SEEK_SET) != 0 \
	  || bfd_bread (debug->ptr, amt, input_bfd) != amt)		 \
	{								 \
          ret = FALSE;							 \
          goto return_something;					 \
	}								 \
    }

  /* If raw_syments is not NULL, then the data was already by read by
     _bfd_ecoff_slurp_symbolic_info.  */
  if (ecoff_data (input_bfd)->raw_syments == NULL)
    {
      READ (line, cbLineOffset, cbLine, sizeof (unsigned char),
	    unsigned char *);
      READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, void *);
      READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, void *);
      READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, void *);
      READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, void *);
      READ (external_aux, cbAuxOffset, iauxMax, sizeof (union aux_ext),
	    union aux_ext *);
      READ (ss, cbSsOffset, issMax, sizeof (char), char *);
      READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, void *);
      READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, void *);
    }
#undef READ

  /* We do not read the external strings or the external symbols.  */

  ret = (bfd_ecoff_debug_accumulate
	 (handle, output_bfd, &ecoff_data (output_bfd)->debug_info,
	  &ecoff_backend (output_bfd)->debug_swap,
	  input_bfd, debug, swap, info));

 return_something:
  if (ecoff_data (input_bfd)->raw_syments == NULL)
    {
      if (debug->line != NULL)
	free (debug->line);
      if (debug->external_dnr != NULL)
	free (debug->external_dnr);
      if (debug->external_pdr != NULL)
	free (debug->external_pdr);
      if (debug->external_sym != NULL)
	free (debug->external_sym);
      if (debug->external_opt != NULL)
	free (debug->external_opt);
      if (debug->external_aux != NULL)
	free (debug->external_aux);
      if (debug->ss != NULL)
	free (debug->ss);
      if (debug->external_fdr != NULL)
	free (debug->external_fdr);
      if (debug->external_rfd != NULL)
	free (debug->external_rfd);

      /* Make sure we don't accidentally follow one of these pointers
	 into freed memory.  */
      debug->line = NULL;
      debug->external_dnr = NULL;
      debug->external_pdr = NULL;
      debug->external_sym = NULL;
      debug->external_opt = NULL;
      debug->external_aux = NULL;
      debug->ss = NULL;
      debug->external_fdr = NULL;
      debug->external_rfd = NULL;
    }

  return ret;
}

/* Relocate and write an ECOFF section into an ECOFF output file.  */

static bfd_boolean
ecoff_indirect_link_order (bfd *output_bfd,
			   struct bfd_link_info *info,
			   asection *output_section,
			   struct bfd_link_order *link_order)
{
  asection *input_section;
  bfd *input_bfd;
  bfd_byte *contents = NULL;
  bfd_size_type external_reloc_size;
  bfd_size_type external_relocs_size;
  void * external_relocs = NULL;

  BFD_ASSERT ((output_section->flags & SEC_HAS_CONTENTS) != 0);

  input_section = link_order->u.indirect.section;
  input_bfd = input_section->owner;
  if (input_section->size == 0)
    return TRUE;

  BFD_ASSERT (input_section->output_section == output_section);
  BFD_ASSERT (input_section->output_offset == link_order->offset);
  BFD_ASSERT (input_section->size == link_order->size);

  /* Get the section contents.  */
  if (!bfd_malloc_and_get_section (input_bfd, input_section, &contents))
    goto error_return;

  /* Get the relocs.  If we are relaxing MIPS code, they will already
     have been read in.  Otherwise, we read them in now.  */
  external_reloc_size = ecoff_backend (input_bfd)->external_reloc_size;
  external_relocs_size = external_reloc_size * input_section->reloc_count;

  external_relocs = bfd_malloc (external_relocs_size);
  if (external_relocs == NULL && external_relocs_size != 0)
    goto error_return;

  if (bfd_seek (input_bfd, input_section->rel_filepos, SEEK_SET) != 0
      || (bfd_bread (external_relocs, external_relocs_size, input_bfd)
	  != external_relocs_size))
    goto error_return;

  /* Relocate the section contents.  */
  if (! ((*ecoff_backend (input_bfd)->relocate_section)
	 (output_bfd, info, input_bfd, input_section, contents,
	  external_relocs)))
    goto error_return;

  /* Write out the relocated section.  */
  if (! bfd_set_section_contents (output_bfd,
				  output_section,
				  contents,
				  input_section->output_offset,
				  input_section->size))
    goto error_return;

  /* If we are producing relocatable output, the relocs were
     modified, and we write them out now.  We use the reloc_count
     field of output_section to keep track of the number of relocs we
     have output so far.  */
  if (info->relocatable)
    {
      file_ptr pos = (output_section->rel_filepos
		      + output_section->reloc_count * external_reloc_size);
      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
	  || (bfd_bwrite (external_relocs, external_relocs_size, output_bfd)
	      != external_relocs_size))
	goto error_return;
      output_section->reloc_count += input_section->reloc_count;
    }

  if (contents != NULL)
    free (contents);
  if (external_relocs != NULL)
    free (external_relocs);
  return TRUE;

 error_return:
  if (contents != NULL)
    free (contents);
  if (external_relocs != NULL)
    free (external_relocs);
  return FALSE;
}

/* Generate a reloc when linking an ECOFF file.  This is a reloc
   requested by the linker, and does come from any input file.  This
   is used to build constructor and destructor tables when linking
   with -Ur.  */

static bfd_boolean
ecoff_reloc_link_order (bfd *output_bfd,
			struct bfd_link_info *info,
			asection *output_section,
			struct bfd_link_order *link_order)
{
  enum bfd_link_order_type type;
  asection *section;
  bfd_vma addend;
  arelent rel;
  struct internal_reloc in;
  bfd_size_type external_reloc_size;
  bfd_byte *rbuf;
  bfd_boolean ok;
  file_ptr pos;

  type = link_order->type;
  section = NULL;
  addend = link_order->u.reloc.p->addend;

  /* We set up an arelent to pass to the backend adjust_reloc_out
     routine.  */
  rel.address = link_order->offset;

  rel.howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (rel.howto == 0)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  if (type == bfd_section_reloc_link_order)
    {
      section = link_order->u.reloc.p->u.section;
      rel.sym_ptr_ptr = section->symbol_ptr_ptr;
    }
  else
    {
      struct bfd_link_hash_entry *h;

      /* Treat a reloc against a defined symbol as though it were
         actually against the section.  */
      h = bfd_wrapped_link_hash_lookup (output_bfd, info,
					link_order->u.reloc.p->u.name,
					FALSE, FALSE, FALSE);
      if (h != NULL
	  && (h->type == bfd_link_hash_defined
	      || h->type == bfd_link_hash_defweak))
	{
	  type = bfd_section_reloc_link_order;
	  section = h->u.def.section->output_section;
	  /* It seems that we ought to add the symbol value to the
             addend here, but in practice it has already been added
             because it was passed to constructor_callback.  */
	  addend += section->vma + h->u.def.section->output_offset;
	}
      else
	{
	  /* We can't set up a reloc against a symbol correctly,
	     because we have no asymbol structure.  Currently no
	     adjust_reloc_out routine cares.  */
	  rel.sym_ptr_ptr = NULL;
	}
    }

  /* All ECOFF relocs are in-place.  Put the addend into the object
     file.  */

  BFD_ASSERT (rel.howto->partial_inplace);
  if (addend != 0)
    {
      bfd_size_type size;
      bfd_reloc_status_type rstat;
      bfd_byte *buf;

      size = bfd_get_reloc_size (rel.howto);
      buf = (bfd_byte *) bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;
      rstat = _bfd_relocate_contents (rel.howto, output_bfd,
				      (bfd_vma) addend, buf);
      switch (rstat)
	{
	case bfd_reloc_ok:
	  break;
	default:
	case bfd_reloc_outofrange:
	  abort ();
	case bfd_reloc_overflow:
	  if (! ((*info->callbacks->reloc_overflow)
		 (info, NULL,
		  (link_order->type == bfd_section_reloc_link_order
		   ? bfd_section_name (output_bfd, section)
		   : link_order->u.reloc.p->u.name),
		  rel.howto->name, addend, NULL,
		  NULL, (bfd_vma) 0)))
	    {
	      free (buf);
	      return FALSE;
	    }
	  break;
	}
      ok = bfd_set_section_contents (output_bfd, output_section, (void *) buf,
				     (file_ptr) link_order->offset, size);
      free (buf);
      if (! ok)
	return FALSE;
    }

  rel.addend = 0;

  /* Move the information into an internal_reloc structure.  */
  in.r_vaddr = (rel.address
		+ bfd_get_section_vma (output_bfd, output_section));
  in.r_type = rel.howto->type;

  if (type == bfd_symbol_reloc_link_order)
    {
      struct ecoff_link_hash_entry *h;

      h = ((struct ecoff_link_hash_entry *)
	   bfd_wrapped_link_hash_lookup (output_bfd, info,
					 link_order->u.reloc.p->u.name,
					 FALSE, FALSE, TRUE));
      if (h != NULL
	  && h->indx != -1)
	in.r_symndx = h->indx;
      else
	{
	  if (! ((*info->callbacks->unattached_reloc)
		 (info, link_order->u.reloc.p->u.name, NULL,
		  NULL, (bfd_vma) 0)))
	    return FALSE;
	  in.r_symndx = 0;
	}
      in.r_extern = 1;
    }
  else
    {
      const char *name;
      unsigned int i;
      static struct
      {
	const char * name;
	long r_symndx;
      }
      section_symndx [] =
      {
	{ _TEXT,   RELOC_SECTION_TEXT   },
	{ _RDATA,  RELOC_SECTION_RDATA  },
	{ _DATA,   RELOC_SECTION_DATA   },
	{ _SDATA,  RELOC_SECTION_SDATA  },
	{ _SBSS,   RELOC_SECTION_SBSS   },
	{ _BSS,    RELOC_SECTION_BSS    },
	{ _INIT,   RELOC_SECTION_INIT   },
	{ _LIT8,   RELOC_SECTION_LIT8   },
	{ _LIT4,   RELOC_SECTION_LIT4   },
	{ _XDATA,  RELOC_SECTION_XDATA  },
	{ _PDATA,  RELOC_SECTION_PDATA  },
	{ _FINI,   RELOC_SECTION_FINI   },
	{ _LITA,   RELOC_SECTION_LITA   },
	{ "*ABS*", RELOC_SECTION_ABS    },
	{ _RCONST, RELOC_SECTION_RCONST }
      };

      name = bfd_get_section_name (output_bfd, section);

      for (i = 0; i < ARRAY_SIZE (section_symndx); i++)
	if (streq (name, section_symndx[i].name))
	  {
	    in.r_symndx = section_symndx[i].r_symndx;
	    break;
	  }

      if (i == ARRAY_SIZE (section_symndx))
	abort ();

      in.r_extern = 0;
    }

  /* Let the BFD backend adjust the reloc.  */
  (*ecoff_backend (output_bfd)->adjust_reloc_out) (output_bfd, &rel, &in);

  /* Get some memory and swap out the reloc.  */
  external_reloc_size = ecoff_backend (output_bfd)->external_reloc_size;
  rbuf = (bfd_byte *) bfd_malloc (external_reloc_size);
  if (rbuf == NULL)
    return FALSE;

  (*ecoff_backend (output_bfd)->swap_reloc_out) (output_bfd, &in, (void *) rbuf);

  pos = (output_section->rel_filepos
	 + output_section->reloc_count * external_reloc_size);
  ok = (bfd_seek (output_bfd, pos, SEEK_SET) == 0
	&& (bfd_bwrite ((void *) rbuf, external_reloc_size, output_bfd)
	    == external_reloc_size));

  if (ok)
    ++output_section->reloc_count;

  free (rbuf);

  return ok;
}

/* Put out information for an external symbol.  These come only from
   the hash table.  */

static bfd_boolean
ecoff_link_write_external (struct bfd_hash_entry *bh, void * data)
{
  struct ecoff_link_hash_entry *h = (struct ecoff_link_hash_entry *) bh;
  struct extsym_info *einfo = (struct extsym_info *) data;
  bfd *output_bfd = einfo->abfd;
  bfd_boolean strip;

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct ecoff_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }

  /* We need to check if this symbol is being stripped.  */
  if (h->root.type == bfd_link_hash_undefined
      || h->root.type == bfd_link_hash_undefweak)
    strip = FALSE;
  else if (einfo->info->strip == strip_all
	   || (einfo->info->strip == strip_some
	       && bfd_hash_lookup (einfo->info->keep_hash,
				   h->root.root.string,
				   FALSE, FALSE) == NULL))
    strip = TRUE;
  else
    strip = FALSE;

  if (strip || h->written)
    return TRUE;

  if (h->abfd == NULL)
    {
      h->esym.jmptbl = 0;
      h->esym.cobol_main = 0;
      h->esym.weakext = 0;
      h->esym.reserved = 0;
      h->esym.ifd = ifdNil;
      h->esym.asym.value = 0;
      h->esym.asym.st = stGlobal;

      if (h->root.type != bfd_link_hash_defined
	  && h->root.type != bfd_link_hash_defweak)
	h->esym.asym.sc = scAbs;
      else
	{
	  asection *output_section;
	  const char *name;
	  unsigned int i;
	  static struct
	  {
	    const char * name;
	    int sc;
	  }
	  section_storage_classes [] =
	  {
	    { _TEXT,   scText   },
	    { _DATA,   scData   },
	    { _SDATA,  scSData  },
	    { _RDATA,  scRData  },
	    { _BSS,    scBss    },
	    { _SBSS,   scSBss   },
	    { _INIT,   scInit   },
	    { _FINI,   scFini   },
	    { _PDATA,  scPData  },
	    { _XDATA,  scXData  },
	    { _RCONST, scRConst }
	  };

	  output_section = h->root.u.def.section->output_section;
	  name = bfd_section_name (output_section->owner, output_section);

	  for (i = 0; i < ARRAY_SIZE (section_storage_classes); i++)
	    if (streq (name, section_storage_classes[i].name))
	      {
		h->esym.asym.sc = section_storage_classes[i].sc;
		break;
	      }

	  if (i == ARRAY_SIZE (section_storage_classes))
	    h->esym.asym.sc = scAbs;
	}

      h->esym.asym.reserved = 0;
      h->esym.asym.index = indexNil;
    }
  else if (h->esym.ifd != -1)
    {
      struct ecoff_debug_info *debug;

      /* Adjust the FDR index for the symbol by that used for the
	 input BFD.  */
      debug = &ecoff_data (h->abfd)->debug_info;
      BFD_ASSERT (h->esym.ifd >= 0
		  && h->esym.ifd < debug->symbolic_header.ifdMax);
      h->esym.ifd = debug->ifdmap[h->esym.ifd];
    }

  switch (h->root.type)
    {
    default:
    case bfd_link_hash_warning:
    case bfd_link_hash_new:
      abort ();
    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      if (h->esym.asym.sc != scUndefined
	  && h->esym.asym.sc != scSUndefined)
	h->esym.asym.sc = scUndefined;
      break;
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      if (h->esym.asym.sc == scUndefined
	  || h->esym.asym.sc == scSUndefined)
	h->esym.asym.sc = scAbs;
      else if (h->esym.asym.sc == scCommon)
	h->esym.asym.sc = scBss;
      else if (h->esym.asym.sc == scSCommon)
	h->esym.asym.sc = scSBss;
      h->esym.asym.value = (h->root.u.def.value
			    + h->root.u.def.section->output_section->vma
			    + h->root.u.def.section->output_offset);
      break;
    case bfd_link_hash_common:
      if (h->esym.asym.sc != scCommon
	  && h->esym.asym.sc != scSCommon)
	h->esym.asym.sc = scCommon;
      h->esym.asym.value = h->root.u.c.size;
      break;
    case bfd_link_hash_indirect:
      /* We ignore these symbols, since the indirected symbol is
	 already in the hash table.  */
      return TRUE;
    }

  /* bfd_ecoff_debug_one_external uses iextMax to keep track of the
     symbol number.  */
  h->indx = ecoff_data (output_bfd)->debug_info.symbolic_header.iextMax;
  h->written = 1;

  return (bfd_ecoff_debug_one_external
	  (output_bfd, &ecoff_data (output_bfd)->debug_info,
	   &ecoff_backend (output_bfd)->debug_swap, h->root.root.string,
	   &h->esym));
}

/* ECOFF final link routine.  This looks through all the input BFDs
   and gathers together all the debugging information, and then
   processes all the link order information.  This may cause it to
   close and reopen some input BFDs; I'll see how bad this is.  */

bfd_boolean
_bfd_ecoff_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
{
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  struct ecoff_debug_info * const debug = &ecoff_data (abfd)->debug_info;
  HDRR *symhdr;
  void * handle;
  bfd *input_bfd;
  asection *o;
  struct bfd_link_order *p;
  struct extsym_info einfo;

  /* We accumulate the debugging information counts in the symbolic
     header.  */
  symhdr = &debug->symbolic_header;
  symhdr->vstamp = 0;
  symhdr->ilineMax = 0;
  symhdr->cbLine = 0;
  symhdr->idnMax = 0;
  symhdr->ipdMax = 0;
  symhdr->isymMax = 0;
  symhdr->ioptMax = 0;
  symhdr->iauxMax = 0;
  symhdr->issMax = 0;
  symhdr->issExtMax = 0;
  symhdr->ifdMax = 0;
  symhdr->crfd = 0;
  symhdr->iextMax = 0;

  /* We accumulate the debugging information itself in the debug_info
     structure.  */
  debug->line = NULL;
  debug->external_dnr = NULL;
  debug->external_pdr = NULL;
  debug->external_sym = NULL;
  debug->external_opt = NULL;
  debug->external_aux = NULL;
  debug->ss = NULL;
  debug->ssext = debug->ssext_end = NULL;
  debug->external_fdr = NULL;
  debug->external_rfd = NULL;
  debug->external_ext = debug->external_ext_end = NULL;

  handle = bfd_ecoff_debug_init (abfd, debug, &backend->debug_swap, info);
  if (handle == NULL)
    return FALSE;

  /* Accumulate the debugging symbols from each input BFD.  */
  for (input_bfd = info->input_bfds;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
    {
      bfd_boolean ret;

      if (bfd_get_flavour (input_bfd) == bfd_target_ecoff_flavour)
	{
	  /* Arbitrarily set the symbolic header vstamp to the vstamp
	     of the first object file in the link.  */
	  if (symhdr->vstamp == 0)
	    symhdr->vstamp
	      = ecoff_data (input_bfd)->debug_info.symbolic_header.vstamp;
	  ret = ecoff_final_link_debug_accumulate (abfd, input_bfd, info,
						   handle);
	}
      else
	ret = bfd_ecoff_debug_accumulate_other (handle, abfd,
						debug, &backend->debug_swap,
						input_bfd, info);
      if (! ret)
	return FALSE;

      /* Combine the register masks.  */
      ecoff_data (abfd)->gprmask |= ecoff_data (input_bfd)->gprmask;
      ecoff_data (abfd)->fprmask |= ecoff_data (input_bfd)->fprmask;
      ecoff_data (abfd)->cprmask[0] |= ecoff_data (input_bfd)->cprmask[0];
      ecoff_data (abfd)->cprmask[1] |= ecoff_data (input_bfd)->cprmask[1];
      ecoff_data (abfd)->cprmask[2] |= ecoff_data (input_bfd)->cprmask[2];
      ecoff_data (abfd)->cprmask[3] |= ecoff_data (input_bfd)->cprmask[3];
    }

  /* Write out the external symbols.  */
  einfo.abfd = abfd;
  einfo.info = info;
  bfd_hash_traverse (&info->hash->table, ecoff_link_write_external, &einfo);

  if (info->relocatable)
    {
      /* We need to make a pass over the link_orders to count up the
	 number of relocations we will need to output, so that we know
	 how much space they will take up.  */
      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  o->reloc_count = 0;
	  for (p = o->map_head.link_order;
	       p != NULL;
	       p = p->next)
	    if (p->type == bfd_indirect_link_order)
	      o->reloc_count += p->u.indirect.section->reloc_count;
	    else if (p->type == bfd_section_reloc_link_order
		     || p->type == bfd_symbol_reloc_link_order)
	      ++o->reloc_count;
	}
    }

  /* Compute the reloc and symbol file positions.  */
  ecoff_compute_reloc_file_positions (abfd);

  /* Write out the debugging information.  */
  if (! bfd_ecoff_write_accumulated_debug (handle, abfd, debug,
					   &backend->debug_swap, info,
					   ecoff_data (abfd)->sym_filepos))
    return FALSE;

  bfd_ecoff_debug_free (handle, abfd, debug, &backend->debug_swap, info);

  if (info->relocatable)
    {
      /* Now reset the reloc_count field of the sections in the output
	 BFD to 0, so that we can use them to keep track of how many
	 relocs we have output thus far.  */
      for (o = abfd->sections; o != NULL; o = o->next)
	o->reloc_count = 0;
    }

  /* Get a value for the GP register.  */
  if (ecoff_data (abfd)->gp == 0)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
      if (h != NULL
	  && h->type == bfd_link_hash_defined)
	ecoff_data (abfd)->gp = (h->u.def.value
				 + h->u.def.section->output_section->vma
				 + h->u.def.section->output_offset);
      else if (info->relocatable)
	{
	  bfd_vma lo;

	  /* Make up a value.  */
	  lo = (bfd_vma) -1;
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      if (o->vma < lo
		  && (streq (o->name, _SBSS)
		      || streq (o->name, _SDATA)
		      || streq (o->name, _LIT4)
		      || streq (o->name, _LIT8)
		      || streq (o->name, _LITA)))
		lo = o->vma;
	    }
	  ecoff_data (abfd)->gp = lo + 0x8000;
	}
      else
	{
	  /* If the relocate_section function needs to do a reloc
	     involving the GP value, it should make a reloc_dangerous
	     callback to warn that GP is not defined.  */
	}
    }

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->map_head.link_order;
	   p != NULL;
	   p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour (p->u.indirect.section->owner)
		  == bfd_target_ecoff_flavour))
	    {
	      if (! ecoff_indirect_link_order (abfd, info, o, p))
		return FALSE;
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! ecoff_reloc_link_order (abfd, info, o, p))
		return FALSE;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		return FALSE;
	    }
	}
    }

  bfd_get_symcount (abfd) = symhdr->iextMax + symhdr->isymMax;

  ecoff_data (abfd)->linker = TRUE;

  return TRUE;
}
@


1.78
log
@	* ecoff.c: casting the return value of BFD_ALIGN to int
	* elf32-tic6x.c: removing unused variables
	* elf32-v850.c: redefine the type of a variable (int -> bfd_vma)
	* vms-alpha.c: initialize a variable
@
text
@d3564 1
a3564 1
  bfd_size_type external_ext_size;
d3566 1
a3566 1
  bfd_size_type esize;
@


1.77
log
@	* vms-lib.c (_bfd_vms_lib_get_module): Use bfd_zmalloc for
	areltdata.
	* opncls.c (_bfd_delete_bfd): Free arelt_data.
	* mach-o.c (bfd_mach_o_fat_member_init): Use bfd_zmalloc for
	areltdata.
	* ecoff.c (_bfd_ecoff_slurp_armap): Use free for mapdata.
	* coff-rs6000.c (_bfd_xcoff_read_ar_hdr): Use bfd_zmalloc for
	areltdata.
	(xcoff_write_archive_contents_old): Likewise.
	(xcoff_write_archive_contents_big): Likewise.
	* archive64.c (bfd_elf64_archive_slurp_armap): Use free for
	areltdata.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Use bfd_zmalloc and
	free for areltdata.
	(_bfd_get_elt_at_filepos): Likewise.  Clear n_nfd->arelt_data on
	failure.
	(do_slurp_bsd_armap): Use bfd_zmalloc and free for areltdata.
	(do_slurp_coff_armap): Likewise.
	(_bfd_slurp_extended_name_table): Likewise.
	(bfd_slurp_bsd_armap_f2): Likewise.  Don't leak 'mapdata'.
@
text
@d2 1
a2 3
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
d1889 1
a1889 1
  return BFD_ALIGN (ret, 16);
@


1.76
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d2907 1
a2907 1
  bfd_release (abfd, (void *) mapdata);
@


1.75
log
@
Add support for PowerPC VLE.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	* NEWS:  Mention PowerPC VLE port.

2012-05-14  James Lemke <jwlemke@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* bfd.c (bfd_lookup_section_flags): Add section parm.
	* ecoff.c (bfd_debug_section): Remove flag_info initializer.
	* elf-bfd.h (bfd_elf_section_data): Move in section_flag_info.
	(bfd_elf_lookup_section_flags): Add section parm.
	* elf32-ppc.c (is_ppc_vle): New function.
	(ppc_elf_modify_segment_map): New function.
	(elf_backend_modify_segment_map): Define.
	(has_vle_insns): New define.
	* elf32-ppc.h (ppc_elf_modify_segment_map): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): Add return value & parm.
	Move in logic to omit / include a section.
	* libbfd-in.h (bfd_link_info): Add section parm.
	(bfd_generic_lookup_section_flags): Likewise.
	* reloc.c (bfd_generic_lookup_section_flags): Likewise.
	* section.c (bfd_section): Move out section_flag_info.
	(BFD_FAKE_SECTION): Remove flag_info initializer.
	* targets.c (_bfd_lookup_section_flags): Add section parm.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* archures.c (bfd_mach_ppc_vle): New.
	* bfd-in2.h: Regenerated.
	* cpu-powerpc.c (bfd_powerpc_archs): New entry for vle.
	* elf32-ppc.c (split16_format_type): New enumeration.
	(ppc_elf_vle_split16): New function.
	(HOWTO): Add entries for R_PPC_VLE relocations.
	(ppc_elf_reloc_type_lookup): Handle PPC_VLE relocations.
	(ppc_elf_section_flags): New function.
	(ppc_elf_lookup_section_flags): New function.
	(ppc_elf_section_processing): New function.
	(ppc_elf_check_relocs): Handle PPC_VLE relocations.
	(ppc_elf_relocation_section): Likewise.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_section_flags): Define.
	(elf_backend_section_processing): Define.
	* elf32-ppc.h (ppc_elf_section_processing): Declare.
	* libbfd.h: Regenerated.
	* reloc.c (BFD_RELOC_PPC_VLE_REL8, BFD_RELOC_PPC_VLE_REL15,
	BFD_RELOC_PPC_VLE_REL24, BFD_RELOC_PPC_VLE_LO16A,
	BFD_RELOC_PPC_VLE_LO16D, BFD_RELOC_PPC_VLE_HI16A,
	BFD_RELOC_PPC_VLE_HI16D, BFD_RELOC_PPC_VLE_HA16A,
	BFD_RELOC_PPC_VLE_HA16D, BFD_RELOC_PPC_VLE_SDA21,
	BFD_RELOC_PPC_VLE_SDA21_LO, BFD_RELOC_PPC_VLE_SDAREL_LO16A,
	BFD_RELOC_PPC_VLE_SDAREL_LO16D, BFD_RELOC_PPC_VLE_SDAREL_HI16A,
	BFD_RELOC_PPC_VLE_SDAREL_HI16D, BFD_RELOC_PPC_VLE_SDAREL_HA16A,
	BFD_RELOC_PPC_VLE_SDAREL_HA16D): New bfd relocations.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (insn_validate): New func of existing code to call..
	(ppc_setup_opcodes): ..from 2 places here.
	Revise for second (VLE) opcode table.
	Add #ifdef'd code to print opcode tables.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Allow out-of-order
	for the VLE conditional branches.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/
	* config/tc-ppc.c (PPC_VLE_SPLIT16A): New macro.
	(PPC_VLE_SPLIT16D): New macro.
	(PPC_VLE_LO16A): New macro.
	(PPC_VLE_LO16D): New macro.
	(PPC_VLE_HI16A): New macro.
	(PPC_VLE_HI16D): New macro.
	(PPC_VLE_HA16A): New macro.
	(PPC_VLE_HA16D): New macro.
	(PPC_APUINFO_VLE): New definition.
	(md_chars_to_number): New function.
	(md_parse_option): Check for combinations of little
	endian and -mvle.
	(md_show_usage): Document -mvle.
	(ppc_arch): Recognize VLE.
	(ppc_mach): Recognize bfd_mach_ppc_vle.
	(ppc_setup_opcodes): Print the opcode table if
	* config/tc-ppc.h (ppc_frag_check): Declare.
	* doc/c-ppc.texi: Document -mvle.
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	gas/
	* config/tc-ppc.h (ppc_dw2_line_min_insn_length): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH): Redefine.
	* config/tc-ppc.c (ppc_dw2_line_min_insn_length): New.
	* dwarf2dbg.c (scale_addr_delta): Handle values of 1
	for DWARF2_LINE_MIN_INSN_LENGTH.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/testsuite/
	* gas/ppc/ppc.exp: Run new tests.
	* gas/ppc/vle-reloc.d: New test.
	* gas/ppc/vle-reloc.s: New test.
	* gas/ppc/vle-simple-1.d: New test.
	* gas/ppc/vle-simple-1.s: New test.
	* gas/ppc/vle-simple-2.d: New test.
	* gas/ppc/vle-simple-2.s: New test.
	* gas/ppc/vle-simple-3.d: New test.
	* gas/ppc/vle-simple-3.s: New test.
	* gas/ppc/vle-simple-4.d: New test.
	* gas/ppc/vle-simple-4.s: New test.
	* gas/ppc/vle-simple-5.d: New test.
	* gas/ppc/vle-simple-5.s: New test.
	* gas/ppc/vle-simple-6.d: New test.
	* gas/ppc/vle-simple-6.s: New test.
	* gas/ppc/vle.d: New test.
	* gas/ppc/vle.s: New test.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>
	include/elf/
	* ppc.h (SEC_PPC_VLE): Remove.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
	    James Lemke  <jwlemke@@codesourcery.com>

	include/elf/
	* ppc.h (R_PPC_VLE_REL8): New reloction.
	(R_PPC_VLE_REL15): Likewise.
	(R_PPC_VLE_REL24): Likewise.
	(R_PPC_VLE_LO16A): Likewise.
	(R_PPC_VLE_LO16D): Likewise.
	(R_PPC_VLE_HI16A): Likewise.
	(R_PPC_VLE_HI16D): Likewise.
	(R_PPC_VLE_HA16A): Likewise.
	(R_PPC_VLE_HA16D): Likewise.
	(R_PPC_VLE_SDA21): Likewise.
	(R_PPC_VLE_SDA21_LO): Likewise.
	(R_PPC_VLE_SDAREL_LO16A): Likewise.
	(R_PPC_VLE_SDAREL_LO16D): Likewise.
	(R_PPC_VLE_SDAREL_HI16A): Likewise.
	(R_PPC_VLE_SDAREL_HI16D): Likewise.
	(R_PPC_VLE_SDAREL_HA16A): Likewise.
	(R_PPC_VLE_SDAREL_HA16D): Likewise.
	(SEC_PPC_VLE): Remove.
	(PF_PPC_VLE): New program header flag.
	(SHF_PPC_VLE): New section header flag.
	(vle_opcodes, vle_num_opcodes): New.
	(VLE_OP): New macro.
	(VLE_OP_TO_SEG): New macro.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	include/opcode/
	* ppc.h (PPC_OPCODE_VLE): New definition.
	(PPC_OP_SA): New macro.
	(PPC_OP_SE_VLE): New macro.
	(PPC_OP): Use a variable shift amount.
	(powerpc_operand): Update comments.
	(PPC_OPSHIFT_INV): New macro.
	(PPC_OPERAND_CR): Replace with...
	(PPC_OPERAND_CR_BIT): ...this and
	(PPC_OPERAND_CR_REG): ...this.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/
	* ldlang.c (walk_wild_consider_section): Don't copy section_flag_list.
	Pass it to callback.
	(walk_wild_section_general): Pass section_flag_list to callback.
	(lang_add_section): Add sflag_list parm.
	Move out logic to keep / omit a section & call bfd_lookup_section_flags.
	(output_section_callback_fast): Add sflag_list parm.
	Add new parm to lang_add_section calls.
	(output_section_callback): Likewise.
	(check_section_callback): Add sflag_list parm.
	(lang_place_orphans): Add new parm to lang_add_section calls.
	(gc_section_callback): Add sflag_list parm.
	(find_relro_section_callback): Likewise.
	* ldlang.h (callback_t): Add flag_info parm.
	(lang_add_section): Add sflag_list parm.
	* emultempl/armelf.em (elf32_arm_add_stub_section):
	Add lang_add_section parm.
	* emultempl/beos.em (gld*_place_orphan): Likewise.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/mipself.em (mips_add_stub_section): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_*_place_orphan): Likewise.
	* emultempl/pep.em (gld_*_place_orphan): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/vms.em (vms_place_orphan): Likewise.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/powerpc.exp: Create ppceabitests.
	* ld-powerpc/vle-multiseg.s: New.
	* ld-powerpc/vle-multiseg-1.d: New.
	* ld-powerpc/vle-multiseg-1.ld: New.
	* ld-powerpc/vle-multiseg-2.d: New.
	* ld-powerpc/vle-multiseg-2.ld: New.
	* ld-powerpc/vle-multiseg-3.d: New.
	* ld-powerpc/vle-multiseg-3.ld: New.
	* ld-powerpc/vle-multiseg-4.d: New.
	* ld-powerpc/vle-multiseg-4.ld: New.
	* ld-powerpc/vle-multiseg-5.d: New.
	* ld-powerpc/vle-multiseg-5.ld: New.
	* ld-powerpc/vle-multiseg-6.d: New.
	* ld-powerpc/vle-multiseg-6.ld: New.
	* ld-powerpc/vle-multiseg-6a.s: New.
	* ld-powerpc/vle-multiseg-6b.s: New.
	* ld-powerpc/vle-multiseg-6c.s: New.
	* ld-powerpc/vle-multiseg-6d.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/apuinfo.rd: Update for VLE.
	* ld-powerpc/vle-reloc-1.d: New.
	* ld-powerpc/vle-reloc-1.s: New.
	* ld-powerpc/vle-reloc-2.d: New.
	* ld-powerpc/vle-reloc-2.s: New.
	* ld-powerpc/vle-reloc-3.d: New.
	* ld-powerpc/vle-reloc-3.s: New.
	* ld-powerpc/vle-reloc-def-1.s: New.
	* ld-powerpc/vle-reloc-def-2.s: New.
	* ld-powerpc/vle-reloc-def-3.s: New.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	opcodes/
	* ppc-dis.c (get_powerpc_dialect): Use is_ppc_vle.
	(PPC_OPCD_SEGS, VLE_OPCD_SEGS): New defines.
	(vle_opcd_indices): New array.
	(lookup_vle): New function.
	(disassemble_init_powerpc): Revise for second (VLE) opcode table.
	(print_insn_powerpc): Likewise.
	* ppc-opc.c: Likewise.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>
	    Nathan Froyd <froydnj@@codesourcery.com>

	opcodes/
	* ppc-opc.c (insert_arx, extract_arx): New functions.
	(insert_ary, extract_ary): New functions.
	(insert_li20, extract_li20): New functions.
	(insert_rx, extract_rx): New functions.
	(insert_ry, extract_ry): New functions.
	(insert_sci8, extract_sci8): New functions.
	(insert_sci8n, extract_sci8n): New functions.
	(insert_sd4h, extract_sd4h): New functions.
	(insert_sd4w, extract_sd4w): New functions.
	(insert_vlesi, extract_vlesi): New functions.
	(insert_vlensi, extract_vlensi): New functions.
	(insert_vleui, extract_vleui): New functions.
	(insert_vleil, extract_vleil): New functions.
 	(BI_MASK, BB_MASK, BT): Use PPC_OPERAND_CR_BIT.
 	(BI16, BI32, BO32, B8): New.
	(B15, B24, CRD32, CRS): New.
 	(CRD, OBF, BFA, CR, CRFS): Use PPC_OPERAND_CR_REG.
	(DB, IMM20, RD, Rx, ARX, RY, RZ): New.
	(ARY, SCLSCI8, SCLSCI8N, SE_SD, SE_SDH): New.
	(SH6_MASK): Use PPC_OPSHIFT_INV.
	(SI8, UI5, OIMM5, UI7, BO16): New.
	(VLESIMM, VLENSIMM, VLEUIMM, VLEUIMML): New.
	(XT6, XA6, XB6, XB6S, XC6): Use PPC_OPSHIFT_INV.
	(ALLOW8_SPRG): New.
	(insert_sprg, extract_sprg): Check ALLOW8_SPRG.
	(OPVUP, OPVUP_MASK OPVUP): New
	(BD8, BD8_MASK, BD8IO, BD8IO_MASK): New.
	(EBD8IO, EBD8IO1_MASK, EBD8IO2_MASK, EBD8IO3_MASK): New.
	(BD15, BD15_MASK, EBD15, EBD15_MASK, EBD15BI, EBD15BI_MASK): New.
	(BD24,BD24_MASK, C_LK, C_LK_MASK, C, C_MASK): New.
 	(IA16, IA16_MASK, I16A, I16A_MASK, I16L, I16L_MASK): New.
	(IM7, IM7_MASK, LI20, LI20_MASK, SCI8, SCI8_MASK): New.
	(SCI8BF, SCI8BF_MASK, SD4, SD4_MASK): New.
	(SE_IM5, SE_IM5_MASK): New.
	(SE_R, SE_R_MASK, SE_RR, SE_RR_MASK): New.
	(EX, EX_MASK, BO16F, BO16T, BO32F, BO32T): New.
	(BO32DNZ, BO32DZ): New.
	(NO371, PPCSPE, PPCISEL, PPCEFS, MULHW): Include PPC_OPCODE_VLE.
	(PPCVLE): New.
	(powerpc_opcodes): Add new VLE instructions.  Update existing
	instruction to include PPCVLE if supported.
	* ppc-dis.c (ppc_opts): Add vle entry.
	(get_powerpc_dialect): New function.
	(powerpc_init_dialect): VLE support.
	(print_insn_big_powerpc): Call get_powerpc_dialect.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Handle negative shift counts.
	(print_insn_powerpc): Handle 2-byte instruction lengths.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d237 1
a237 3
_bfd_ecoff_no_long_sections (abfd, enable)
     bfd *abfd;
     int enable;
@


1.74
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@a75 2
  /* flag_info,                                                    */
     NULL,
@


1.73
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d76 2
@


1.72
log
@	* aoutx.h (aout_link_check_ar_symbols): Formatting.
	* cofflink.c (coff_link_check_ar_symbols): Likewise.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols,
	xcoff_link_check_dynamic_ar_symbols): Likewise.

	* aoutx.h (aout_link_check_archive_element): Simplify code dealing
	with add_archive_element substitute BFD.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* ecoff.c (ecoff_link_check_archive_element): Likewise.
	(ecoff_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.

	* aoutx.h (aout_link_check_archive_element): Free symbols from old
	bfd if !keep_memory.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
a3233 8
/* Traverse an ECOFF link hash table.  */

#define ecoff_link_hash_traverse(table, func, info)			\
  (bfd_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct bfd_link_hash_entry *, void *)) (func),	\
    (info)))

d4254 1
a4254 1
ecoff_link_write_external (struct ecoff_link_hash_entry *h, void * data)
d4256 1
d4487 1
a4487 3
  ecoff_link_hash_traverse (ecoff_hash_table (info),
			    ecoff_link_write_external,
			    (void *) &einfo);
@


1.71
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d3603 1
a3603 1
      bfd *subsbfd;
d3648 3
a3650 3
      subsbfd = NULL;
      if (! (*info->callbacks->add_archive_element)
					(info, abfd, name, &subsbfd))
d3654 1
a3654 1
      if (subsbfd
d3656 1
a3656 1
				&external_ext, &ssext, subsbfd, backend))
d3658 1
a3658 2
      if (! ecoff_link_add_externals (subsbfd ? subsbfd : abfd, info,
				external_ext, ssext))
a3734 1
      bfd *subsbfd;
d3821 2
a3822 3
      subsbfd = NULL;
      if (! (*info->callbacks->add_archive_element)
					(info, element, name, &subsbfd))
d3824 1
a3824 3
      /* Potentially, the add_archive_element hook may have set a
	 substitute BFD for us.  */
      if (! ecoff_link_add_object_symbols (subsbfd ? subsbfd : element, info))
@


1.71.2.1
log
@backport from mainline
@
text
@d3603 1
a3603 1
      bfd *oldbfd;
d3648 3
a3650 3
      oldbfd = abfd;
      if (!(*info->callbacks
	    ->add_archive_element) (info, abfd, name, &abfd))
d3654 1
a3654 1
      if (abfd != oldbfd
d3656 1
a3656 1
					&external_ext, &ssext, abfd, backend))
d3658 2
a3659 1
      if (! ecoff_link_add_externals (abfd, info, external_ext, ssext))
d3736 1
d3823 3
a3825 2
      if (!(*info->callbacks
	    ->add_archive_element) (info, element, name, &element))
d3827 3
a3829 1
      if (! ecoff_link_add_object_symbols (element, info))
@


1.70
log
@Applied patch series for LD plugin interface (six parts).

[PATCH] Add infrastructure for plugin API; functionality to follow.

    include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* plugin-api.h (LDPT_GNU_LD_VERSION): New ld_plugin_tag enum member.

    ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* configure.in: Add AC_CHECKs for file io and dlfcn headers and
	functions and AC_SEARCH for -ldl.
	(enable_plugins): New shell variable set if above tests find dlopen
	functionality.
	(ENABLE_PLUGINS): Add related automake conditional.
	* configure: Regenerate.
	* config.in: Likewise.
	* Makefile.am (PLUGIN_C): Declare plugin C source file, conditional
	on ENABLE_PLUGINS being defined.
	(PLUGIN_H): Likewise for header file.
	(PLUGIN_OBJECT): Likewise for object file.
	(PLUGIN_CFLAGS): Likewise -D flag required to compile plugin support.
	(AM_CPPFLAGS): Use PLUGIN_CFLAGS.
	(CFILES): Use PLUGIN_C.
	(HFILES): Use PLUGIN_H.
	(OFILES): Use PLUGIN_OBJECT.
	(ld_new_SOURCES): Use PLUGIN_C.
	(noinst_LTLIBRARIES)[ENABLE_PLUGINS]: Declare test plugin.
	(libldtestplug_la_SOURCES)[ENABLE_PLUGINS]: Add automake definition
	for test plugin.
	(libldtestplug_la_CFLAGS)[ENABLE_PLUGINS]: Likewise.
	(libldtestplug_la_LDFLAGS)[ENABLE_PLUGINS]: Likewise.
	* Makefile.in: Regenerate.
	* sysdep.h: Include stdarg.h, unistd.h and one of fcntl.h or
	sys/file.h where available.  Include dlfcn.h when ENABLE_PLUGINS.
	(O_RDONLY): Supply default definition likewise to bfd's sysdep.h
	(O_WRONLY): Likewise.
	(O_RDWR): Likewise.
	(O_ACCMODE): Likewise.
	(O_BINARY): Likewise.
	(SEEK_SET): Likewise.
	(SEEK_CUR): Likewise.
	(SEEK_END): Likewise.
	* ldmisc.c (vfinfo): Make non-static.  Add %p format char.
	* ldmisc.h (vfinfo): Declare extern prototype.
	* lexsup.c (enum option_values)[ENABLE_PLUGINS]: Add new entries for
	OPTION_PLUGIN and OPTION_PLUGIN_OPT.
	(ld_options[])[ENABLE_PLUGINS]: Add option data for the above two.
	(parse_args)[ENABLE_PLUGINS]: Handle them, and load all plugins once
	option parsing is complete.
	* ldmain.c (main)[ENABLE_PLUGINS]: Call plugin cleanup hooks just
	after lang_finish.
	* plugin.c: New source file.
	* plugin.h: Likewise new header.
	* testplug.c: New source file.

    ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* ld-bootstrap/bootstrap.exp: Skip static tests also if LD plugins
	are enabled.
	* lib/ld-lib.exp (proc regexp_diff): Extend verbose debug output.
	(proc set_file_contents): Write a file with the supplied content.
	(run_ld_link_tests): Add new 'ld' action to test linker output.
	(proc check_plugin_api_available): Return true if linker under test
	supports the plugin API.
	* ld-plugin/func.c: New test source file.
	* ld-plugin/main.c: Likewise.
	* ld-plugin/text.c: Likewise.
	* ld-plugin/plugin-1.d: New dump test output pattern script.
	* ld-plugin/plugin-2.d: Likewise.
	* ld-plugin/plugin-3.d: Likewise.
	* ld-plugin/plugin-4.d: Likewise.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin.exp: New test control script.
---
[PATCH] Implement claim file and all symbols read hooks and add symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ldfile.c (ldfile_try_open_bfd)[ENABLE_PLUGINS]: Don't return early
	during compat checks if they pass, instead offer any successfully
	opened and accepted file to the plugin claim file hooks chain.  Create
	a dummy bfd to accept symbols added by the plugin, if the plugin
	claims the file.
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Call plugin all symbols
	read hook chain before ldemul_after_open.
	* ldlang.h (struct lang_input_statement_struct): Add new single-bit
	'claimed' flag.
	* plugin.c (IRONLY_SUFFIX): New macro for dummy bfd file suffix.
	(IRONLY_SUFFIX_LEN): Length of the above string.
	(plugin_get_ir_dummy_bfd): New function to create the dummy bfd used
	to store symbols for ir-only files.
	(is_ir_dummy_bfd): New function to check if a bfd is ir-only.
	(asymbol_from_plugin_symbol): New function converts symbol formats.
	(add_symbols): Call it to convert plugin syms to bfd syms and add
	them to the dummy bfd.
	* plugin.h: Add missing include guards.
	(plugin_get_ir_dummy_bfd): Add prototype.
	(is_ir_dummy_bfd): Likewise.
	* testplug.c (TV_MESSAGE): New helper macro.
	(struct claim_file): New struct.
	(claim_file_t): New typedef.
	(tag_names[]): Make static and const.
	(claimfiles_list): New variable.
	(claimfiles_tail_chain_ptr): Likewise.
	(last_claimfile): Likewise.
	(record_claim_file): Record a file to claim on a singly-linked list.
	(parse_symdefstr): Parse an ASCII representation of a symbol from a
	plugin option into the fields of a struct ld_plugin_symbol.
	(record_claimed_file_symbol):  Use it to parse plugin option for
	adding a symbol.
	(parse_option): Parse claim file and add symbol options.
	(dump_tv_tag): Use TV_MESSAGE.
	(onload): Likewise.
	(onclaim_file): Make static.  Use TV_MESSAGE.  Scan list of files to
	claim and claim this file if required, adding any symbols specified.
	(onall_symbols_read): Make static and use TV_MESSAGE.
	(oncleanup): Likewise.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ld-plugin/plugin-3.d: Enable regexes for new functionality.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin-6.d: New testcase.
	* ld-plugin/plugin-7.d: Likewise.
	* ld-plugin/plugin.exp: Use 'nm' on compiled test objects to determine
	whether symbols in plugin arguments need an underscore prefix.  Add
	new plugin-6.d and plugin-7.d testcases.
---
[PATCH] Implement get symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ldmain.c (notice)[ENABLE_PLUGINS]: Call plugin_notice.
	* plugin.c (non_ironly_hash): Add new bfd hash table.
	(plugin_load_plugins): Exit early if no plugins to load.  If plugins
	do load successfully, set notice_all flag in link info.
	(get_symbols): Implement.
	(plugin_load_plugins): Exit early if no plugins to load, else after
	loading plugins successfully enable notice_all mode.
	(init_non_ironly_hash): Lazily init non_ironly_hash table.
	(plugin_notice): Record symbols referenced from non-IR files in the
	non_ironly_hash.  Suppress tracing, cref generation and nocrossrefs
	tracking for symbols from dummy IR bfds.
	* plugin.h: Fix formatting.
	(plugin_notice): Add prototype.
	* testplug.c (dumpresolutions): New global var.
	(parse_options): Accept "dumpresolutions".
	(onall_symbols_read): Get syms and dump resolutions if it was given.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ld-plugin/plugin-8.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Implement add input file, add input lib and set extra lib path callbacks.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Move invocation of
	plugin_call_all_symbols_read to before setting of gc_sym_list, and
	open any new input files that may have been added during it.
	* ldmain.c (multiple_definition)[ENABLE_PLUGINS]: Call out to
	plugin_multiple_definition and let it have first say over what to do
	with the clashing definitions.
	* plugin.c (no_more_claiming): New boolean variable.
	(plugin_cached_allow_multiple_defs): Likewise.
	(add_input_file): Implement.
	(add_input_library): Likewise.
	(set_extra_library_path): Likewise.
	(plugin_call_claim_file): Don't do anything when no_more_claiming set.
	(plugin_call_all_symbols_read): Set it.  Disable link info
	"allow_multiple_definition" flag, but cache its value.
	(plugin_multiple_definition): New function.
	* plugin.h (plugin_multiple_definition): Add prototype.
	* testplug.c (addfile_enum_t): New enumerated typedef.
	(add_file_t): New struct typedef.
	(addfiles_list): New variable.
	(addfiles_tail_chain_ptr): Likewise.
	(record_add_file): New function.
	(parse_option): Parse "add:", "lib:" and "dir:" options and call it.
	(onall_symbols_read): Iterate the list of new files, libs and dirs,
	adding them.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ld-plugin/plugin-9.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Add ELF symbol visibility support to plugin interface.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* plugin.c (asymbol_from_plugin_symbol): If the bfd is an ELF bfd,
	find the elf symbol data and set the visibility in the st_other field.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* ld-plugin/plugin-ignore.d: New dump test control script.
	* ld-plugin/plugin-vis-1.d: Likewise.
	* ld-plugin/plugin.exp: Add list of ELF-only tests and run them if
	testing on an ELF target.
---
[PATCH] Add archive support to plugin interface.

  bfd/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* aoutx.h (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* cofflink.c (coff_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(coff_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* ecoff.c (read_ext_syms_and_strs): New function holds symbol-reading
	code factored-out from ecoff_link_check_archive_element.
	(reread_ext_syms_and_strs): Clear old symbols and call it.
	(ecoff_link_check_archive_element):  Use the above.  Handle substitute
	BFD if one is set by add_archive_element callback.
	(ecoff_link_add_archive_symbols): Likewise allow bfd substitution.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it was
	set during add_archive_element callback in the above.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Handle substitute
	BFD if one is set by add_archive_element callback.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols): Take new "subsbfd"
	reference parameter and pass it when invoking add_archive_element
	callback.
	(xcoff_link_check_ar_symbols): Likewise.
	(xcoff_link_check_archive_element): Handle bfd substitution if it was
	set by callback in the above.

  include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* bfdlink.h (struct_bfd_link_callbacks): Document new argument
	to add_archive_element callback used to return a replacement bfd which
	is to be added to the hash table in place of the original element.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ldlang.c (load_symbols): Handle bfd subsitution when calling the
	add_archive_element callback.
	* ldmain.c (add_archive_element)[ENABLE_PLUGINS]: Offer the archive
	member to the plugins and if claimed set "subsbfd" output parameter to
	point to the dummy IR-only BFD.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ld-plugin/plugin-10.d: New dump test control script.
	* ld-plugin/plugin-11.d: Likewise.
	* ld-plugin/plugin.exp: Run them.
---
@
text
@d58 1
a58 1
  /* linker_mark, linker_has_input, gc_mark, segment_mark,         */
d60 2
a61 2
  /* sec_info_type, use_rela_p,                                    */
     0,             0,
d64 2
a65 2
  /* vma, lma, size, rawsize, relax, relax_count,                  */
     0,   0,   0,    0,       0,     0,
@


1.69
log
@	* ecoff.c: Don't include aout/ranlib.h.
	(_bfd_ecoff_slurp_armap): Use correct struct for ardata->symdefs.
	(_bfd_ecoff_write_armap): Output ar_date and ar_size using
	_bfd_ar_spacepad.
@
text
@d3512 52
d3585 3
a3587 1
  if (! ecoff_slurp_symbolic_header (abfd))
a3593 22
  symhdr = &ecoff_data (abfd)->debug_info.symbolic_header;

  /* Read in the external symbols and external strings.  */
  external_ext_size = backend->debug_swap.external_ext_size;
  esize = symhdr->iextMax * external_ext_size;
  external_ext = bfd_malloc (esize);
  if (external_ext == NULL && esize != 0)
    goto error_return;

  if (bfd_seek (abfd, (file_ptr) symhdr->cbExtOffset, SEEK_SET) != 0
      || bfd_bread (external_ext, esize, abfd) != esize)
    goto error_return;

  ssext = (char *) bfd_malloc ((bfd_size_type) symhdr->issExtMax);
  if (ssext == NULL && symhdr->issExtMax != 0)
    goto error_return;

  if (bfd_seek (abfd, (file_ptr) symhdr->cbSsExtOffset, SEEK_SET) != 0
      || (bfd_bread (ssext, (bfd_size_type) symhdr->issExtMax, abfd)
	  != (bfd_size_type) symhdr->issExtMax))
    goto error_return;

d3603 1
d3648 9
a3656 1
      if (! (*info->callbacks->add_archive_element) (info, abfd, name))
d3658 2
a3659 1
      if (! ecoff_link_add_externals (abfd, info, external_ext, ssext))
d3736 1
d3823 3
a3825 1
      if (! (*info->callbacks->add_archive_element) (info, element, name))
d3827 3
a3829 1
      if (! ecoff_link_add_object_symbols (element, info))
@


1.68
log
@	* section.c (struct bfd_section): Delete has_tls_reloc,
	has_tls_get_addr_call, has_gp_reloc, need_finalize_relax, reloc_done.
	Add sec_flg0 thru sec_flg5.
	(BFD_FAKE_SECTION): Update for changed flags.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf32-ppc.c (has_tls_reloc, has_tls_get_addr_call): Define.
	* elf64-ppc.c (has_tls_reloc, has_tls_get_addr_call): Define.
	(has_toc_reloc, makes_toc_func_call, call_check_in_progress): Update.
	* elf32-xtensa.c (reloc_done): Define.
	* elfxx-ia64.c (skip_relax_pass_0, skip_relax_pass_1): Update.
	* bfd-in2.h: Regenerate.
@
text
@a29 1
#include "aout/ranlib.h"
d2857 1
a2857 1
  struct symdef *symdef_ptr;
d2977 2
a2978 2
  amt *= sizeof (struct symdef);
  symdef_ptr = (struct symdef *) bfd_alloc (abfd, amt);
d2982 1
a2982 1
  ardata->symdefs = (carsym *) symdef_ptr;
d2993 1
a2993 1
      symdef_ptr->s.name = stringbase + name_offset;
d3065 2
a3066 1
  sprintf (hdr.ar_date, "%ld", (long) (statbuf.st_mtime + 60));
d3077 1
a3077 1
  sprintf (hdr.ar_size, "%-10d", (int) mapsize);
@


1.67
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d59 8
a66 8
  /* linker_mark, linker_has_input, gc_mark,                       */
     0,           0,                1,
  /* segment_mark, sec_info_type, use_rela_p, has_tls_reloc,       */
     0,            0,             0,          0,
  /* has_tls_get_addr_call, has_gp_reloc, need_finalize_relax,     */
     0,                     0,            0,
  /* reloc_done, vma, lma, size, rawsize, relax, relax_count,      */
     0,          0,   0,   0,    0,       0,     0,
@


1.66
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@d2680 1
a2680 1
		  unsigned int i;
d2707 2
a2708 2
		  for (i = 0; i < ARRAY_SIZE (section_symndx); i++)
		    if (streq (name, section_symndx[i].name))
d2710 1
a2710 1
			in.r_symndx = section_symndx[i].r_symndx;
d2714 1
a2714 1
		  if (i == ARRAY_SIZE (section_symndx))
@


1.65
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d92 1
a92 1
  abfd->tdata.ecoff_obj_data = bfd_zalloc (abfd, amt);
d196 1
a196 1
  struct internal_filehdr *internal_f = filehdr;
d369 1
a369 1
  struct internal_scnhdr *internal_s = hdr;
d617 1
a617 1
  debug->fdr = bfd_alloc (abfd, amt);
d885 1
a885 1
  internal = bfd_alloc (abfd, internal_size);
d1583 1
a1583 1
  internal_relocs = bfd_alloc (abfd, amt);
d1587 1
a1587 1
  external_relocs = bfd_alloc (abfd, amt);
d1733 2
a1734 1
      ecoff_data (abfd)->find_line_info = bfd_zalloc (abfd, amt);
d1959 1
a1959 1
  sorted_hdrs = bfd_malloc (amt);
d2912 1
a2912 1
  raw_armap = bfd_alloc (abfd, parsed_size);
d2979 1
a2979 1
  symdef_ptr = bfd_alloc (abfd, amt);
d3095 1
a3095 1
  hashtable = bfd_zalloc (abfd, symdefsize);
d3215 1
a3215 1
  ret = bfd_malloc (amt);
d3273 1
a3273 1
  sym_hash = bfd_alloc (abfd, amt);
d3487 1
a3487 1
  ssext = bfd_malloc ((bfd_size_type) symhdr->issExtMax);
d3553 1
a3553 1
  ssext = bfd_malloc ((bfd_size_type) symhdr->issExtMax);
d3842 1
a3842 1
      debug->ptr = bfd_malloc (amt);					 \
d4087 1
a4087 1
      buf = bfd_zmalloc (size);
d4196 1
a4196 1
  rbuf = bfd_malloc (external_reloc_size);
@


1.64
log
@        Add support for Xilinx MicroBlaze processor.

        * bfd/Makefile.am: Add cpu-microblaze.{lo,c}, elf32-microblaze.{lo,c}.
        * bfd/Makefile.in: Same.
        * bfd/archures.c: Add bfd_arch_microblaze.
        * bfd/bfd-in2.h: Regenerate.
        * bfd/config.bfd: Add microblaze target.
        * bfd/configure: Add bfd_elf32_microblaze_vec target.
        * bfd/configure.in: Same.
        * bfd/cpu-microblaze.c: New.
        * bfd/elf32-microblaze.c: New.
        * bfd/libbfd-in.h: Add prototype _bfd_dwarf2_fixup_section_debug_loc().
        * bfd/libbfd.h: Regenerate.
        * bfd/reloc.c: Add MICROBLAZE relocations.
        * bfd/section.c: Add struct relax_table and relax_count to section.
        * bfd/targets.c: Add bfd_elf32_microblaze_vec.
        * binutils/MAINTAINERS: Add self as maintainer.
        * binutils/readelf.c: Include elf/microblaze.h, add EM_MICROBLAZE &
        EM_MICROBLAZE_OLD to guess_is_rela(), dump_relocations(),
        get_machine_name().
        * config.sub: Add microblaze target.
        * configure: Same.
        * configure.ac: Same.
        * gas/Makefile.am: add microblaze to CPU_TYPES, config/tc-microblaze.c to
        TARGET_CPU_CFILES, config/tc-microblaze.h to TARGET_CPU_HFILES, add
        DEP_microblaze_elf target.
        * gas/Makefile.in: Same.
        * gas/config/tc-microblaze.c: Add MicroBlaze assembler.
        * gas/config/tc-microblaze.h: Add header for tc-microblaze.c.
        * gas/configure: Add microblaze target.
        * gas/configure.in: Same.
        * gas/configure.tgt: Same.
        * gas/doc/Makefile.am: Add c-microblaze.texi to CPU_DOCS.
        * gas/doc/Makefile.in: Same.
        * gas/doc/all.texi: Set MICROBLAZE.
        * gas/doc/as.texinfo: Add MicroBlaze doc links.
        * gas/doc/c-microblaze.texi: New MicroBlaze docs.
        * include/dis-asm.h: Decl print_insn_microblaze().
        * include/elf/common.h: Define EM_MICROBLAZE & EM_MICROBLAZE_OLD.
        * include/elf/microblaze.h: New reloc definitions.
        * ld/Makefile.am: Add eelf32mb_linux.o, eelf32microblaze.o to
        ALL_EMULATIONS, targets.
        * ld/Makefile.in: Same.
        * ld/configure.tgt: Add microblaze*-linux*, microblaze* targets.
        * ld/emulparams/elf32mb_linux.sh: New.
        * ld/emulparams/elf32microblaze.sh. New.
        * ld/scripttempl/elfmicroblaze.sc: New.
        * opcodes/Makefile.am: Add microblaze-opc.h to HFILES, microblaze-dis.c to
        CFILES, microblaze-dis.lo to ALL_MACHINES, targets.
        * opcodes/Makefile.in: Same.
        * opcodes/configure: Add bfd_microblaze_arch target.
        * opcodes/configure.in: Same.
        * opcodes/disassemble.c: Define ARCH_microblaze, return
        print_insn_microblaze().
        * opcodes/microblaze-dis.c: New MicroBlaze disassembler.
        * opcodes/microblaze-opc.h: New MicroBlaze opcode definitions.
        * opcodes/microblaze-opcm.h: New MicroBlaze opcode types.
@
text
@d647 1
a647 1
  ecoff_symbol_type *new;
d650 2
a651 2
  new = bfd_zalloc (abfd, amt);
  if (new == NULL)
d653 6
a658 6
  new->symbol.section = NULL;
  new->fdr = NULL;
  new->local = FALSE;
  new->native = NULL;
  new->symbol.the_bfd = abfd;
  return &new->symbol;
@


1.63
log
@include/elf/
	* ppc.h (R_PPC_TLSGD, R_PPC_TLSLD): Add new relocs.
	* ppc64.h (R_PPC64_TLSGD, R_PPC64_TLSLD): Add new relocs.
bfd/
	* reloc.c (BFD_RELOC_PPC_TLSGD, BFD_RELOC_PPC_TLSLD): New.
	* section.c (struct bfd_section): Add has_tls_get_addr_call.
	(BFD_FAKE_SECTION): Init new flag.
	* ecoff.c (bfd_debug_section): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* elf32-ppc.c (ppc_elf_howto_raw): Add R_PPC_TLSGD and R_PPC_TLSLD.
	(ppc_elf_reloc_type_lookup): Handle new relocs.
	(ppc_elf_check_relocs): Set has_tls_get_addr_call on finding such
	without marker relocs.
	(ppc_elf_tls_optimize): Allow out-of-order __tls_get_addr relocs
	if section has no old-style calls.
	(ppc_elf_relocate_section): Set tls_mask for non-tls relocs too.
	Don't try to optimize new-style __tls_get_addr call when handling
	arg setup relocs.  Instead do so for R_PPC_TLSGD and R_PPC_TLSLD
	relocs.
	* elf64-ppc.c (ppc64_elf_howto_raw): Add R_PPC64_TLSGD, R_PPC64_TLSLD.
	(ppc64_elf_reloc_type_lookup): Handle new relocs.
	(ppc64_elf_check_relocs): Set has_tls_get_addr_call on finding such
	without marker relocs.
	(ppc64_elf_tls_optimize): Allow out-of-order __tls_get_addr relocs
	if section has no old-style calls.  Set toc_ref for new relocs as
	appropriate.
	(ppc64_elf_relocate_section): Set tls_mask for non-tls relocs too.
	Don't try to optimize new-style __tls_get_addr call when handling
	arg setup relocs.  Instead do so for R_PPC_TLSGD and R_PPC_TLSLD
	relocs.
gas/
	* config/tc-ppc.c (ppc_elf_suffix): Error if ppc32 tls got relocs
	have non-zero addend.
	(md_assemble): Parse args of __tls_get_addr calls.
	(md_apply_fix): Handle BFD_RELOC_PPC_TLSGD and BFD_RELOC_PPC_TLSLD.
ld/testsuite/
	* ld-powerpc/tlsmark.s, * ld-powerpc/tlsmark.d: New test.
	* ld-powerpc/tlsmark32.s, * ld-powerpc/tlsmark32.d: New test.
	* ld-powerpc/powerpc.exp: Run them.
@
text
@d65 2
a66 2
  /* reloc_done, vma, lma, size, rawsize,                          */
     0,          0,   0,   0,    0,
@


1.62
log
@bfd/ChangeLog

	* coff-alpha.c (alpha_ecoff_backend_data):  Initialise fields which
	control long section name handling with ECOFF_NO_LONG_SECTION_NAMES.
	* coff-mips.c (mips_ecoff_backend_data):  Likewise.
	* coff-rs6000.c (bfd_xcoff_backend_data):  Initialise fields which
	control long section name handling with XCOFF_NO_LONG_SECTION_NAMES.
	(bfd_pmac_xcoff_backend_data):  Likewise.
	* coff64-rs6000.c (bfd_xcoff_backend_data):  Likewise.
	(bfd_xcoff_aix5_backend_data):  Likewise.
	(xcoff64_write_object_contents):  Delete unused long_section_names
	local variable.
	* coff-sh.c (bfd_coff_small_swap_table):  Initialise long section
	name members using COFF_DEFAULT_LONG_SECTION_NAMES and make entire
	struct non-const.
	* coffcode.h (documentation):  Update to describe long section names.
	(COFFLONGSECTIONCATHELPER):  New helper macro.
	(BLANKOR1TOODD):  Likewise.
	(COFF_ENABLE_LONG_SECTION_NAMES):  Likewise.
	(COFF_LONG_SECTION_NAMES_SETTER):  Likewise.
	(COFF_DEFAULT_LONG_SECTION_NAMES):  Likewise.
	(bfd_coff_set_long_section_names_allowed):  New function.
	(bfd_coff_set_long_section_names_disallowed):  Likewise.
	(struct bfd_coff_backend_data):  Add new backend hook function
	pointer _bfd_coff_set_long_section_names.
	(bfd_coff_set_long_section_names):  New backend hook.
	(coff_write_object_contents):  Only generate long section names if
	bfd_coff_long_section_names() indicates they are currently enabled.
	(bfd_coff_std_swap_table):  Make non-const, and initialise long
	section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff0_swap_table):  Likewise to both.
	(ticoff1_swap_table):  Again, likewise to both.
	* coffgen.c (make_a_section_from_file):  Allow long section names
	as inputs even if not currently allowed for outputs.
	* ecoff.c (_bfd_ecoff_no_long_sections):  New function.
	* efi-app-ia32.c (COFF_LONG_SECTION_NAMES):  Define to 0, not blank.
	* efi-app-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-app-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-arm.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-i386.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mcore.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mips.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-ppc.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-sh.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* libcoff-in.h:  Update copyright year to cause updated copyright
	year in generated libcoff.h, and fix typo.
	* libcoff.h:  Regenerated.
	* libecoff.h (ECOFF_NO_LONG_SECTION_NAMES):  New macro.
	(_bfd_ecoff_no_long_sections):  Add prototype.
	* libxcoff.h (XCOFF_NO_LONG_SECTION_NAMES):  New macro.
	* pe-mips.c (COFF_LONG_SECTION_NAMES):  Define empty if not already
	defined by an including .c file.
	* ticoff.h (ticoff0_swap_table):  Make non-const, and initialise
	long section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff1_swap_table):  Likewise to both.

ld/ChangeLog

	* ld.texinfo:  Update to mention long section name options.
	* NEWS:  Mention new behaviour and command-line options.
	* pe-dll.c (pe_use_coff_long_section_names):  New global variable.
	(pe_output_file_set_long_section_names):  New function.
	(pe_dll_build_sections):  Call it on output BFDs.
	(pe_exe_build_sections):  Likewise.
	(pe_dll_fill_sections):  Likewise.
	(pe_exe_fill_sections):  Likewise.
	* pe-dll.h (pe_use_coff_long_section_names):  Declare extern.
	(pe_output_file_set_long_section_names):  Add prototype.
	* pep-dll.c (pe_use_coff_long_section_names):  Define pep_ alias.
	(pe_output_file_set_long_section_names):  Likewise.
	* pep-dll.h (pep_use_coff_long_section_names):  Declare extern.
	(pep_output_file_set_long_section_names):  Add prototype.
	* pe.em (OPTION_ENABLE_LONG_SECTION_NAMES):  New getopt value macro.
	(OPTION_DISABLE_LONG_SECTION_NAMES):  Likewise.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pe_output_file_set_long_section_names.
	* pep.em (enum options):  Extend enum with new getopt option values.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pep_output_file_set_long_section_names.

ld/testsuite/ChangeLog

	* ld-pe/longsecn-1.d:  New test file.
	* ld-pe/longsecn-2.d:  Likewise.
	* ld-pe/longsecn-3.d:  Likewise.
	* ld-pe/longsecn-4.d:  Likewise.
	* ld-pe/longsecn-5.d:  Likewise.
	* ld-pe/longsecn.d:  Likewise.
	* ld-pe/longsecn.exp:  New test control script.
	* ld-pe/longsecn.s:  New test source file.
@
text
@d3 2
a4 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d63 4
a66 4
  /* has_gp_reloc, need_finalize_relax, reloc_done,                */
     0,            0,                   0,
  /* vma, lma, size, rawsize,                                      */
     0,   0,   0,    0,
@


1.61
log
@Silence gcc printf warnings
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d236 10
@


1.60
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d1041 1
a1041 1
	   ((long) indx
@


1.59
log
@	* ecoff.c (_bfd_ecoff_archive_p): Delete.
	* libecoff.h (_bfd_ecoff_archive_p): Delete.
	* coff-alpha.c (ecoffalpha_little_vec): Use bfd_generic_archive_p.
	* coff-mips.c (ecoff_little_vec, ecoff_big_vec): Likewise.
	(ecoff_biglittle_vec): Likewise.
@
text
@d3405 1
a3405 1
      if (info->hash->creator->flavour == bfd_get_flavour (abfd))
@


1.58
log
@bfd/
	* elf-bfd.h (eh_cie_fde): Add u.fde.next_for_section and
	u.cie.gc_mark.
	(bfd_elf_section_data): Add fde_list.
	(elf_fde_list): New macro.
	(elf_obj_tdata): Add eh_frame_section.
	(elf_eh_frame_section): New macro.
	(_bfd_elf_gc_mark_reloc): Remove last parameter.
	(_bfd_elf_gc_mark_fdes): Declare.
	* elf-eh-frame.c (_bfd_elf_get_eh_frame_sec_info): Chain the FDEs
	for each input section.
	(mark_entry, _bfd_elf_gc_mark_fdes): New functions.
	* elflink.c (_bfd_elf_gc_mark_reloc): Remove is_eh parameter.
	(_bfd_elf_gc_mark): Update call accordingly.  Mark the relocations
	againts the section's FDEs.  Don't mark the bfd's elf_eh_frame_section.
	(bfd_elf_gc_sections): Parse each input bfd's .eh_frame before
	marking any input sections.  Remove the current EH handling.
	* section.c (bfd_section): Remove gc_mark_from_eh.
	* ecoff.c (bfd_debug_section): Update initializer accordingly.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
a3156 83

/* See whether this BFD is an archive.  If it is, read in the armap
   and the extended name table.  */

const bfd_target *
_bfd_ecoff_archive_p (bfd *abfd)
{
  struct artdata *tdata_hold;
  char armag[SARMAG + 1];
  bfd_size_type amt;

  if (bfd_bread ((void *) armag, (bfd_size_type) SARMAG, abfd) != SARMAG)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  if (! strneq (armag, ARMAG, SARMAG))
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  tdata_hold = bfd_ardata (abfd);

  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = bfd_zalloc (abfd, amt);
  if (bfd_ardata (abfd) == NULL)
    {
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }

  bfd_ardata (abfd)->first_file_filepos = SARMAG;
  /* Already cleared by bfd_zalloc above.
     bfd_ardata (abfd)->cache = NULL;
     bfd_ardata (abfd)->archive_head = NULL;
     bfd_ardata (abfd)->symdefs = NULL;
     bfd_ardata (abfd)->extended_names = NULL;
     bfd_ardata (abfd)->extended_names_size = 0;
     bfd_ardata (abfd)->tdata = NULL;  */

  if (! _bfd_ecoff_slurp_armap (abfd)
      || ! _bfd_ecoff_slurp_extended_name_table (abfd))
    {
      bfd_release (abfd, bfd_ardata (abfd));
      bfd_ardata (abfd) = tdata_hold;
      return NULL;
    }

  if (bfd_has_map (abfd))
    {
      bfd *first;

      /* This archive has a map, so we may presume that the contents
	 are object files.  Make sure that if the first file in the
	 archive can be recognized as an object file, it is for this
	 target.  If not, assume that this is the wrong format.  If
	 the first file is not an object file, somebody is doing
	 something weird, and we permit it so that ar -t will work.  */

      first = bfd_openr_next_archived_file (abfd, NULL);
      if (first != NULL)
	{
	  first->target_defaulted = FALSE;
	  if (bfd_check_format (first, bfd_object)
	      && first->xvec != abfd->xvec)
	    {
	      /* We ought to close `first' here, but we can't, because
		 we have no way to remove it from the archive cache.
		 It's almost impossible to figure out when we can
		 release bfd_ardata.  FIXME.  */
	      bfd_set_error (bfd_error_wrong_object_format);
	      bfd_ardata (abfd) = tdata_hold;
	      return NULL;
	    }
	  /* And we ought to close `first' here too.  */
	}
    }

  return abfd->xvec;
}
@


1.57
log
@Switch sources over to use the GPL version 3
@
text
@d58 2
a59 2
  /* linker_mark, linker_has_input, gc_mark, gc_mark_from_eh,      */
     0,           0,                1,       0,
@


1.56
log
@bfd/
	* bfd.c (struct bfd): Rename "next" to "archive_next".
	* archive.c: Rename uses throughout file.
	* archive64.c: Likewise.
	* coff-rs6000.c: Likewise.
	* ecoff.c: Likewise.
	* som.c: Likewise.
	* bfd-in2.h: Regenerate.
binutils/
	* ar.c: Rename uses of bfd.next to bfd.archive_next throughout.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* objcopy.c: Likewise.
	* dlltool.c: Likewise.
ld/
	* pe-dll.c: Rename uses of bfd.next to bfd.archive_next throughout.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.55
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d3100 1
a3100 1
	      current = current->next;
@


1.54
log
@* ecoff.c (_bfd_ecoff_write_armap): Initialise rehash.
  (ecoff_link_add_archive_symbols): Likewise.
* coff-m68k.c (m68kcoff_common_addend_rtype_to_howto): Initialise relent.howto.
* ieee.c (parse_int): Initialise x.
  (must_parse_int): Initialise result.
  (ieee_slurp_external_symbols): Initialise value.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d23 1
a24 1
#include "sysdep.h"
@


1.53
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3090 1
a3090 1
      unsigned int hash, rehash;
d3760 1
a3760 1
      unsigned int hash, rehash;
@


1.52
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d2864 1
a2864 1
  if (strneq (nextname, "/               ", 16))
@


1.51
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d1865 2
a1866 1
_bfd_ecoff_sizeof_headers (bfd *abfd, bfd_boolean reloc ATTRIBUTE_UNUSED)
d1940 1
a1940 1
  sofar = _bfd_ecoff_sizeof_headers (abfd, FALSE);
d2361 1
a2361 1
    text_size = _bfd_ecoff_sizeof_headers (abfd, FALSE);
@


1.50
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d143 1
a143 2
_bfd_ecoff_new_section_hook (bfd *abfd ATTRIBUTE_UNUSED,
			     asection *section)
d183 1
a183 1
  return TRUE;
@


1.49
log
@	* coff-h8300.c (h8300_reloc16_extra_cases): Use input section
	"output_offset" instead of link order "offset".
	* coff-h8500.c (extra_case): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z80.c (extra_case): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* linker.c (default_indirect_link_order): Likewise, "size" too.
	* ecoff.c (ecoff_indirect_link_order): Likewise.
@
text
@d3 1
a3 1
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d3288 3
a3290 2
  if (! _bfd_link_hash_table_init (&ret->root, abfd,
				   ecoff_link_hash_newfunc))
@


1.48
log
@coff-alpha.c (alpha_adjust_reloc_in): Issue an informative error message if an
  unknown reloc is encountered.
  (alpha_relocate_section): Likewise.
ecoff.c (_bfd_ecoff_write_object_contents): Cope with a reloc with a missing
  howto field.
@
text
@a4004 3
  if (link_order->size == 0)
    return TRUE;

d4007 2
@


1.47
log
@	* libbfd-in.h (struct artdata): Add extended_names_size field.
	* libbfd.h: Rebuilt.
	* coff-rs600.c (_bfd_xcoff_archive_p): Don't clear fields in freshly
	allocated object by bfd_zalloc.
	* coff64-rs6000.c (xcoff64_archive_p): Likewise.
	* ecoff.c (_bfd_ecoff_archive_p): Likewise.
	* archive.c (_bfd_generic_mkarchive, bfd_generic_archive_p): Likewise.
	(get_extended_arelt_filename): Fail if index is bigger or equal to
	extended_names_size.
	(_bfd_generic_read_ar_hdr_mag): Don't set bfd_error_malformed_archive,
	get_extended_arelt_filename already did that.
	(_bfd_slurp_extended_name_table): Initialize extended_names_size field.
	Allocate one extra byte and clear it, in case extended names table
	is not terminated.
@
text
@d2636 1
d2650 5
@


1.46
log
@	* elflink.c (_bfd_elf_gc_mark): Mark sections referenced by
	.eh_frame specially..
	(bfd_elf_gc_sections): ..rather than totally ignoring .eh_frame.
	Don't recheck sections we have already marked.
	(elf_gc_sweep): Keep non-code sections referenced from .eh_frame.
	* section.c (struct bfd_section): Add gc_mark_from_eh.
	(STD_SECTION): Adjust.
	* ecoff.c (bfd_debug_section): Adjust.
	* bfd-in2.h: Regenerate.
@
text
@d3185 7
a3191 5
  bfd_ardata (abfd)->cache = NULL;
  bfd_ardata (abfd)->archive_head = NULL;
  bfd_ardata (abfd)->symdefs = NULL;
  bfd_ardata (abfd)->extended_names = NULL;
  bfd_ardata (abfd)->tdata = NULL;
@


1.45
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d57 6
a62 6
  /* linker_mark, linker_has_input, gc_mark, segment_mark,         */
     0,           0,                0,       0,
  /* sec_info_type, use_rela_p, has_tls_reloc, has_gp_reloc,       */
     0,		    0,		0,	       0,
  /* need_finalize_relax, reloc_done,                              */
     0,			  0,
d71 1
a71 1
  /* entsize, kept_section, moving_line_filepos,	           */
@


1.44
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.43
log
@Update the FSF address in the copyright/GPL notice
@
text
@d79 2
a80 2
  /* link_order_head, link_order_tail                              */
     NULL,            NULL
d4526 1
a4526 1
	  for (p = o->link_order_head;
d4596 1
a4596 1
      for (p = o->link_order_head;
@


1.42
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.41
log
@Convert to ISO C90 formatting.
@
text
@d55 2
a56 2
  /* name,      id,  index, next, flags, user_set_vma,             */
     "*DEBUG*", 0,   0,     NULL, 0,     0,
@


1.40
log
@update copyright dates
@
text
@d46 4
a49 2

/* Prototypes for static functions.  */
a50 26
static int ecoff_get_magic
  PARAMS ((bfd *));
static long ecoff_sec_to_styp_flags
  PARAMS ((const char *, flagword));
static bfd_boolean ecoff_slurp_symbolic_header
  PARAMS ((bfd *));
static bfd_boolean ecoff_set_symbol_info
  PARAMS ((bfd *, SYMR *, asymbol *, int, int));
static void ecoff_emit_aggregate
  PARAMS ((bfd *, FDR *, char *, RNDXR *, long, const char *));
static char *ecoff_type_to_string
  PARAMS ((bfd *, FDR *, unsigned int));
static bfd_boolean ecoff_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **));
static int ecoff_sort_hdrs
  PARAMS ((const PTR, const PTR));
static bfd_boolean ecoff_compute_section_file_positions
  PARAMS ((bfd *));
static bfd_size_type ecoff_compute_reloc_file_positions
  PARAMS ((bfd *));
static bfd_boolean ecoff_get_extr
  PARAMS ((asymbol *, EXTR *));
static void ecoff_set_index
  PARAMS ((asymbol *, bfd_size_type));
static unsigned int ecoff_armap_hash
  PARAMS ((const char *, unsigned int *, unsigned int, unsigned int));
d76 1
a76 1
     (struct bfd_symbol *) NULL,
d78 1
a78 1
     (struct bfd_symbol **) NULL,
d86 1
a86 2
_bfd_ecoff_mkobject (abfd)
     bfd *abfd;
d90 1
a90 1
  abfd->tdata.ecoff_obj_data = (struct ecoff_tdata *) bfd_zalloc (abfd, amt);
d100 2
a101 5
PTR
_bfd_ecoff_mkobject_hook (abfd, filehdr, aouthdr)
     bfd *abfd;
     PTR filehdr;
     PTR aouthdr;
d114 1
a114 1
  if (internal_a != (struct internal_aouthdr *) NULL)
d137 1
a137 1
  return (PTR) ecoff;
d143 2
a144 3
_bfd_ecoff_new_section_hook (abfd, section)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
d146 24
d172 7
a178 19
  if (strcmp (section->name, _TEXT) == 0
      || strcmp (section->name, _INIT) == 0
      || strcmp (section->name, _FINI) == 0)
    section->flags |= SEC_CODE | SEC_LOAD | SEC_ALLOC;
  else if (strcmp (section->name, _DATA) == 0
	   || strcmp (section->name, _SDATA) == 0)
    section->flags |= SEC_DATA | SEC_LOAD | SEC_ALLOC;
  else if (strcmp (section->name, _RDATA) == 0
	   || strcmp (section->name, _LIT8) == 0
	   || strcmp (section->name, _LIT4) == 0
	   || strcmp (section->name, _RCONST) == 0
	   || strcmp (section->name, _PDATA) == 0)
    section->flags |= SEC_DATA | SEC_LOAD | SEC_ALLOC | SEC_READONLY;
  else if (strcmp (section->name, _BSS) == 0
	   || strcmp (section->name, _SBSS) == 0)
    section->flags |= SEC_ALLOC;
  else if (strcmp (section->name, _LIB) == 0)
    /* An Irix 4 shared libary.  */
    section->flags |= SEC_COFF_SHARED_LIBRARY;
d193 1
a193 3
_bfd_ecoff_set_arch_mach_hook (abfd, filehdr)
     bfd *abfd;
     PTR filehdr;
d195 1
a195 1
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
d240 1
a240 2
ecoff_get_magic (abfd)
     bfd *abfd;
d281 61
a341 69
ecoff_sec_to_styp_flags (name, flags)
     const char *name;
     flagword flags;
{
  long styp;

  styp = 0;

  if (strcmp (name, _TEXT) == 0)
    styp = STYP_TEXT;
  else if (strcmp (name, _DATA) == 0)
    styp = STYP_DATA;
  else if (strcmp (name, _SDATA) == 0)
    styp = STYP_SDATA;
  else if (strcmp (name, _RDATA) == 0)
    styp = STYP_RDATA;
  else if (strcmp (name, _LITA) == 0)
    styp = STYP_LITA;
  else if (strcmp (name, _LIT8) == 0)
    styp = STYP_LIT8;
  else if (strcmp (name, _LIT4) == 0)
    styp = STYP_LIT4;
  else if (strcmp (name, _BSS) == 0)
    styp = STYP_BSS;
  else if (strcmp (name, _SBSS) == 0)
    styp = STYP_SBSS;
  else if (strcmp (name, _INIT) == 0)
    styp = STYP_ECOFF_INIT;
  else if (strcmp (name, _FINI) == 0)
    styp = STYP_ECOFF_FINI;
  else if (strcmp (name, _PDATA) == 0)
    styp = STYP_PDATA;
  else if (strcmp (name, _XDATA) == 0)
    styp = STYP_XDATA;
  else if (strcmp (name, _LIB) == 0)
    styp = STYP_ECOFF_LIB;
  else if (strcmp (name, _GOT) == 0)
    styp = STYP_GOT;
  else if (strcmp (name, _HASH) == 0)
    styp = STYP_HASH;
  else if (strcmp (name, _DYNAMIC) == 0)
    styp = STYP_DYNAMIC;
  else if (strcmp (name, _LIBLIST) == 0)
    styp = STYP_LIBLIST;
  else if (strcmp (name, _RELDYN) == 0)
    styp = STYP_RELDYN;
  else if (strcmp (name, _CONFLIC) == 0)
    styp = STYP_CONFLIC;
  else if (strcmp (name, _DYNSTR) == 0)
    styp = STYP_DYNSTR;
  else if (strcmp (name, _DYNSYM) == 0)
    styp = STYP_DYNSYM;
  else if (strcmp (name, _COMMENT) == 0)
    {
      styp = STYP_COMMENT;
      flags &=~ SEC_NEVER_LOAD;
    }
  else if (strcmp (name, _RCONST) == 0)
    styp = STYP_RCONST;
  else if (flags & SEC_CODE)
    styp = STYP_TEXT;
  else if (flags & SEC_DATA)
    styp = STYP_DATA;
  else if (flags & SEC_READONLY)
    styp = STYP_RDATA;
  else if (flags & SEC_LOAD)
    styp = STYP_REG;
  else
    styp = STYP_BSS;
d352 5
a356 6
_bfd_ecoff_styp_to_sec_flags (abfd, hdr, name, section, flags_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR hdr;
     const char *name ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     flagword * flags_ptr;
d358 1
a358 1
  struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
d421 1
a421 2
ecoff_slurp_symbolic_header (abfd)
     bfd *abfd;
d425 1
a425 1
  PTR raw = NULL;
d452 1
a452 1
  raw = (PTR) bfd_malloc (external_hdr_size);
d486 3
a488 4
_bfd_ecoff_slurp_symbolic_info (abfd, ignore, debug)
     bfd *abfd;
     asection *ignore ATTRIBUTE_UNUSED;
     struct ecoff_debug_info *debug;
d494 1
a494 1
  PTR raw;
d508 1
a508 1
  if (ecoff_data (abfd)->raw_syments != (PTR) NULL)
d542 1
a542 1
     optimization symtab, not the number of entries */
d559 1
a559 1
  raw = (PTR) bfd_alloc (abfd, raw_size);
d575 6
a580 6
#define FIX(off1, off2, type) \
  if (internal_symhdr->off1 == 0) \
    debug->off2 = (type) NULL; \
  else \
    debug->off2 = (type) ((char *) raw \
			  + (internal_symhdr->off1 \
d584 4
a587 4
  FIX (cbDnOffset, external_dnr, PTR);
  FIX (cbPdOffset, external_pdr, PTR);
  FIX (cbSymOffset, external_sym, PTR);
  FIX (cbOptOffset, external_opt, PTR);
d591 3
a593 3
  FIX (cbFdOffset, external_fdr, PTR);
  FIX (cbRfdOffset, external_rfd, PTR);
  FIX (cbExtOffset, external_ext, PTR);
d606 1
a606 1
  debug->fdr = (struct fdr *) bfd_alloc (abfd, amt);
d614 1
a614 1
    (*backend->debug_swap.swap_fdr_in) (abfd, (PTR) fraw_src, fdr_ptr);
d634 1
a634 2
_bfd_ecoff_make_empty_symbol (abfd)
     bfd *abfd;
d639 5
a643 5
  new = (ecoff_symbol_type *) bfd_zalloc (abfd, amt);
  if (new == (ecoff_symbol_type *) NULL)
    return (asymbol *) NULL;
  new->symbol.section = (asection *) NULL;
  new->fdr = (FDR *) NULL;
d653 5
a657 6
ecoff_set_symbol_info (abfd, ecoff_sym, asym, ext, weak)
     bfd *abfd;
     SYMR *ecoff_sym;
     asymbol *asym;
     int ext;
     int weak;
d717 1
a717 1
      asym->section = bfd_make_section_old_way (abfd, ".text");
d721 1
a721 1
      asym->section = bfd_make_section_old_way (abfd, ".data");
d725 1
a725 1
      asym->section = bfd_make_section_old_way (abfd, ".bss");
d831 2
a832 4
	  {
	    /* Mark the symbol as a constructor.  */
	    asym->flags |= BSF_CONSTRUCTOR;
	  }
d842 1
a842 2
_bfd_ecoff_slurp_symbol_table (abfd)
     bfd *abfd;
d849 1
a849 1
  void (* const swap_ext_in) PARAMS ((bfd *, PTR, EXTR *))
d851 1
a851 1
  void (* const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *))
d866 1
a866 1
  if (! _bfd_ecoff_slurp_symbolic_info (abfd, (asection *) NULL,
d874 1
a874 1
  internal = (ecoff_symbol_type *) bfd_alloc (abfd, internal_size);
d887 1
a887 1
      (*swap_ext_in) (abfd, (PTR) eraw_src, &internal_esym);
d901 1
a901 1
      internal_ptr->native = (PTR) eraw_src;
d922 1
a922 1
	  (*swap_sym_in) (abfd, (PTR) lraw_src, &internal_sym);
d931 1
a931 1
	  internal_ptr->native = (PTR) lraw_src;
d943 1
a943 2
_bfd_ecoff_get_symtab_upper_bound (abfd)
     bfd *abfd;
d945 1
a945 1
  if (! _bfd_ecoff_slurp_symbolic_info (abfd, (asection *) NULL,
d958 1
a958 3
_bfd_ecoff_canonicalize_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
d975 1
a975 1
  *location++ = (ecoff_symbol_type *) NULL;
d986 6
a991 7
ecoff_emit_aggregate (abfd, fdr, string, rndx, isym, which)
     bfd *abfd;
     FDR *fdr;
     char *string;
     RNDXR *rndx;
     long isym;
     const char *which;
d1048 1
a1048 4
ecoff_type_to_string (abfd, fdr, indx)
     bfd *abfd;
     FDR *fdr;
     unsigned int indx;
d1053 2
a1054 1
  struct qual {
d1343 3
a1345 4
_bfd_ecoff_get_symbol_info (abfd, symbol, ret)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
d1353 2
a1354 3
_bfd_ecoff_bfd_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
d1362 4
a1365 5
_bfd_ecoff_print_symbol (abfd, filep, symbol, how)
     bfd *abfd;
     PTR filep;
     asymbol *symbol;
     bfd_print_symbol_type how;
d1550 3
a1552 4
ecoff_slurp_reloc_table (abfd, section, symbols)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
d1562 1
a1562 1
  if (section->relocation != (arelent *) NULL
d1572 1
a1572 1
  internal_relocs = (arelent *) bfd_alloc (abfd, amt);
d1576 2
a1577 3
  external_relocs = (char *) bfd_alloc (abfd, amt);
  if (internal_relocs == (arelent *) NULL
      || external_relocs == (char *) NULL)
d1616 14
a1629 14
	    case RELOC_SECTION_TEXT:  sec_name = ".text";  break;
	    case RELOC_SECTION_RDATA: sec_name = ".rdata"; break;
	    case RELOC_SECTION_DATA:  sec_name = ".data";  break;
	    case RELOC_SECTION_SDATA: sec_name = ".sdata"; break;
	    case RELOC_SECTION_SBSS:  sec_name = ".sbss";  break;
	    case RELOC_SECTION_BSS:   sec_name = ".bss";   break;
	    case RELOC_SECTION_INIT:  sec_name = ".init";  break;
	    case RELOC_SECTION_LIT8:  sec_name = ".lit8";  break;
	    case RELOC_SECTION_LIT4:  sec_name = ".lit4";  break;
	    case RELOC_SECTION_XDATA: sec_name = ".xdata"; break;
	    case RELOC_SECTION_PDATA: sec_name = ".pdata"; break;
	    case RELOC_SECTION_FINI:  sec_name = ".fini"; break;
	    case RELOC_SECTION_LITA:  sec_name = ".lita";  break;
	    case RELOC_SECTION_RCONST: sec_name = ".rconst"; break;
d1634 1
a1634 1
	  if (sec == (asection *) NULL)
d1658 4
a1661 5
_bfd_ecoff_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     asection *section;
     arelent **relptr;
     asymbol **symbols;
d1690 1
a1690 1
  *relptr = (arelent *) NULL;
d1700 7
a1706 9
_bfd_ecoff_find_nearest_line (abfd, section, ignore_symbols, offset,
			      filename_ptr, functionname_ptr, retline_ptr)
     bfd *abfd;
     asection *section;
     asymbol **ignore_symbols ATTRIBUTE_UNUSED;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *retline_ptr;
d1714 1
a1714 1
  if (! _bfd_ecoff_slurp_symbolic_info (abfd, (asection *) NULL, debug_info)
d1721 2
a1722 2
      ecoff_data (abfd)->find_line_info
	= (struct ecoff_find_line *) bfd_zalloc (abfd, amt);
d1747 1
a1747 3
_bfd_ecoff_bfd_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d1751 1
a1751 1
  register int i;
d1775 1
a1775 1
  if (c == 0 || sym_ptr_ptr == (asymbol **) NULL)
d1855 3
a1857 4
_bfd_ecoff_set_arch_mach (abfd, arch, machine)
     bfd *abfd;
     enum bfd_architecture arch;
     unsigned long machine;
d1866 1
a1866 3
_bfd_ecoff_sizeof_headers (abfd, reloc)
     bfd *abfd;
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d1874 1
a1874 1
       current != (asection *)NULL;
d1887 5
a1891 6
_bfd_ecoff_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     asection *section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
d1901 1
a1901 3
ecoff_sort_hdrs (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d1928 1
a1928 2
ecoff_compute_section_file_positions (abfd)
     bfd *abfd;
d1946 1
a1946 1
  sorted_hdrs = (asection **) bfd_malloc (amt);
d1966 1
a1966 1
	  if (strcmp (current->name, _RDATA) == 0)
d1969 2
a1970 2
	      && strcmp (current->name, _PDATA) != 0
	      && strcmp (current->name, _RCONST) != 0)
d1991 1
a1991 1
      if (strcmp (current->name, _PDATA) == 0)
d2007 3
a2009 3
	      || strcmp (current->name, _RDATA) != 0)
	  && strcmp (current->name, _PDATA) != 0
	  && strcmp (current->name, _RCONST) != 0)
d2015 1
a2015 1
      else if (strcmp (current->name, _LIB) == 0)
d2078 1
a2078 2
ecoff_compute_reloc_file_positions (abfd)
     bfd *abfd;
d2098 1
a2098 1
       current != (asection *)NULL;
d2132 5
a2136 6
_bfd_ecoff_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     asection *section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
d2142 3
a2144 5
  if (! abfd->output_has_begun)
    {
      if (! ecoff_compute_section_file_positions (abfd))
	return FALSE;
    }
d2148 1
a2148 1
  if (strcmp (section->name, _LIB) == 0)
d2178 1
a2178 2
bfd_ecoff_get_gp_value (abfd)
     bfd *abfd;
d2194 1
a2194 3
bfd_ecoff_set_gp_value (abfd, gp_value)
     bfd *abfd;
     bfd_vma gp_value;
d2212 4
a2215 5
bfd_ecoff_set_regmasks (abfd, gprmask, fprmask, cprmask)
     bfd *abfd;
     unsigned long gprmask;
     unsigned long fprmask;
     unsigned long *cprmask;
d2229 1
a2229 1
  if (cprmask != (unsigned long *) NULL)
d2244 1
a2244 3
ecoff_get_extr (sym, esym)
     asymbol *sym;
     EXTR *esym;
d2296 1
a2296 1
      if (input_debug->ifdmap != (RFDT *) NULL)
d2307 1
a2307 3
ecoff_set_index (sym, indx)
     asymbol *sym;
     bfd_size_type indx;
d2315 1
a2315 2
_bfd_ecoff_write_object_contents (abfd)
     bfd *abfd;
d2325 1
a2325 2
  void (* const adjust_reloc_out)
  PARAMS ((bfd *, const arelent *, struct internal_reloc *))
d2327 1
a2327 2
  void (* const swap_reloc_out)
  PARAMS ((bfd *, const struct internal_reloc *, PTR))
d2341 2
a2342 2
  PTR buff = NULL;
  PTR reloc_buff = NULL;
d2353 1
a2353 1
       current != (asection *)NULL;
d2377 1
d2383 1
a2383 1
    buff = (PTR) bfd_malloc (siz);
d2391 1
d2393 1
a2393 1
       current != (asection *) NULL;
d2405 1
a2405 1
      if (strcmp (current->name, _LIB) == 0)
d2427 1
a2427 1
      if (strcmp (current->name, _PDATA) != 0)
d2443 1
a2443 1
      if (bfd_coff_swap_scnhdr_out (abfd, (PTR) &section, buff) == 0
d2592 1
a2592 1
  bfd_coff_swap_filehdr_out (abfd, (PTR) &internal_f, buff);
d2596 1
a2596 1
  bfd_coff_swap_aouthdr_out (abfd, (PTR) &internal_a, buff);
d2617 1
a2617 1
	   current != (asection *) NULL;
d2644 1
a2644 1
	      memset ((PTR) &in, 0, sizeof in);
d2661 24
d2687 9
a2695 31
		  if (strcmp (name, ".text") == 0)
		    in.r_symndx = RELOC_SECTION_TEXT;
		  else if (strcmp (name, ".rdata") == 0)
		    in.r_symndx = RELOC_SECTION_RDATA;
		  else if (strcmp (name, ".data") == 0)
		    in.r_symndx = RELOC_SECTION_DATA;
		  else if (strcmp (name, ".sdata") == 0)
		    in.r_symndx = RELOC_SECTION_SDATA;
		  else if (strcmp (name, ".sbss") == 0)
		    in.r_symndx = RELOC_SECTION_SBSS;
		  else if (strcmp (name, ".bss") == 0)
		    in.r_symndx = RELOC_SECTION_BSS;
		  else if (strcmp (name, ".init") == 0)
		    in.r_symndx = RELOC_SECTION_INIT;
		  else if (strcmp (name, ".lit8") == 0)
		    in.r_symndx = RELOC_SECTION_LIT8;
		  else if (strcmp (name, ".lit4") == 0)
		    in.r_symndx = RELOC_SECTION_LIT4;
		  else if (strcmp (name, ".xdata") == 0)
		    in.r_symndx = RELOC_SECTION_XDATA;
		  else if (strcmp (name, ".pdata") == 0)
		    in.r_symndx = RELOC_SECTION_PDATA;
		  else if (strcmp (name, ".fini") == 0)
		    in.r_symndx = RELOC_SECTION_FINI;
		  else if (strcmp (name, ".lita") == 0)
		    in.r_symndx = RELOC_SECTION_LITA;
		  else if (strcmp (name, "*ABS*") == 0)
		    in.r_symndx = RELOC_SECTION_ABS;
		  else if (strcmp (name, ".rconst") == 0)
		    in.r_symndx = RELOC_SECTION_RCONST;
		  else
d2702 1
a2702 1
	      (*swap_reloc_out) (abfd, &in, (PTR) out_ptr);
d2789 10
a2798 10
#define ARMAP_BIG_ENDIAN 'B'
#define ARMAP_LITTLE_ENDIAN 'L'
#define ARMAP_MARKER 'E'
#define ARMAP_START_LENGTH 10
#define ARMAP_HEADER_MARKER_INDEX 10
#define ARMAP_HEADER_ENDIAN_INDEX 11
#define ARMAP_OBJECT_MARKER_INDEX 12
#define ARMAP_OBJECT_ENDIAN_INDEX 13
#define ARMAP_END_INDEX 14
#define ARMAP_END "_ "
d2801 1
a2801 1
#define ARMAP_HASH_MAGIC 0x9dd68ab5
d2809 4
a2812 5
ecoff_armap_hash (s, rehash, size, hlog)
     const char *s;
     unsigned int *rehash;
     unsigned int size;
     unsigned int hlog;
d2829 1
a2829 2
_bfd_ecoff_slurp_armap (abfd)
     bfd *abfd;
d2844 1
a2844 1
  i = bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd);
d2858 1
a2858 1
  if (strncmp (nextname, "/               ", 16) == 0)
d2862 1
a2862 2
  if (strncmp (nextname, ecoff_backend (abfd)->armap_start,
	       ARMAP_START_LENGTH) != 0
d2869 1
a2869 2
      || strncmp (nextname + ARMAP_END_INDEX,
		  ARMAP_END, sizeof ARMAP_END - 1) != 0)
d2888 1
a2888 1
  if (mapdata == (struct areltdata *) NULL)
d2891 1
a2891 1
  bfd_release (abfd, (PTR) mapdata);
d2893 2
a2894 2
  raw_armap = (char *) bfd_alloc (abfd, parsed_size);
  if (raw_armap == (char *) NULL)
d2897 1
a2897 1
  if (bfd_bread ((PTR) raw_armap, parsed_size, abfd) != parsed_size)
d2901 1
a2901 1
      bfd_release (abfd, (PTR) raw_armap);
d2905 1
a2905 1
  ardata->tdata = (PTR) raw_armap;
d2910 1
a2910 1
  ardata->cache = (struct ar_cache *) NULL;
d2960 1
a2960 1
  symdef_ptr = (struct symdef *) bfd_alloc (abfd, amt);
d2992 5
a2996 6
_bfd_ecoff_write_armap (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength;
     struct orl *map;
     unsigned int orl_count;
     int stridx;
d3027 1
a3027 1
  memset ((PTR) &hdr, 0, sizeof hdr);
d3068 1
a3068 1
  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), abfd)
d3073 1
a3073 1
  if (bfd_bwrite ((PTR) temp, (bfd_size_type) 4, abfd) != 4)
d3076 1
a3076 1
  hashtable = (bfd_byte *) bfd_zalloc (abfd, symdefsize);
d3122 1
a3122 1
  if (bfd_bwrite ((PTR) hashtable, symdefsize, abfd) != symdefsize)
d3129 1
a3129 1
  if (bfd_bwrite ((PTR) temp, (bfd_size_type) 4, abfd) != 4)
d3136 1
a3136 1
      if (bfd_bwrite ((PTR) (*map[i].name), len, abfd) != len)
d3155 1
a3155 2
_bfd_ecoff_archive_p (abfd)
     bfd *abfd;
d3161 1
a3161 1
  if (bfd_bread ((PTR) armag, (bfd_size_type) SARMAG, abfd) != SARMAG)
d3165 1
a3165 1
      return (const bfd_target *) NULL;
d3168 1
a3168 1
  if (strncmp (armag, ARMAG, SARMAG) != 0)
d3177 2
a3178 2
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
  if (bfd_ardata (abfd) == (struct artdata *) NULL)
d3181 1
a3181 1
      return (const bfd_target *) NULL;
d3196 1
a3196 1
      return (const bfd_target *) NULL;
d3210 1
a3210 1
      first = bfd_openr_next_archived_file (abfd, (bfd *) NULL);
a3233 13
static struct bfd_hash_entry *ecoff_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *entry,
	   struct bfd_hash_table *table,
	   const char *string));
static bfd_boolean ecoff_link_add_archive_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean ecoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
static bfd_boolean ecoff_link_add_object_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean ecoff_link_add_externals
  PARAMS ((bfd *, struct bfd_link_info *, PTR, char *));

d3237 3
a3239 4
ecoff_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d3245 1
a3245 1
  if (ret == (struct ecoff_link_hash_entry *) NULL)
d3248 1
a3248 1
  if (ret == (struct ecoff_link_hash_entry *) NULL)
d3264 1
a3264 1
  memset ((PTR) &ret->esym, 0, sizeof ret->esym);
d3272 1
a3272 2
_bfd_ecoff_bfd_link_hash_table_create (abfd)
     bfd *abfd;
d3277 1
a3277 1
  ret = (struct ecoff_link_hash_table *) bfd_malloc (amt);
d3284 1
a3284 1
      return (struct bfd_link_hash_table *) NULL;
d3300 1
a3300 1
    (bfd_boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func), \
d3308 5
a3312 26
/* Given an ECOFF BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
_bfd_ecoff_bfd_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return ecoff_link_add_object_symbols (abfd, info);
    case bfd_archive:
      return ecoff_link_add_archive_symbols (abfd, info);
    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}

/* Add the symbols from an archive file to the global hash table.
   This looks through the undefined symbols, looks each one up in the
   archive hash table, and adds any associated object file.  We do not
   use _bfd_generic_link_add_archive_symbols because ECOFF archives
   already have a hash table, so there is no reason to construct
   another one.  */
d3315 4
a3318 3
ecoff_link_add_archive_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d3321 8
a3328 7
  const bfd_byte *raw_armap;
  struct bfd_link_hash_entry **pundef;
  unsigned int armap_count;
  unsigned int armap_log;
  unsigned int i;
  const bfd_byte *hashtable;
  const char *stringbase;
d3330 1
a3330 8
  if (! bfd_has_map (abfd))
    {
      /* An empty archive is a special case.  */
      if (bfd_openr_next_archived_file (abfd, (bfd *) NULL) == NULL)
	return TRUE;
      bfd_set_error (bfd_error_no_armap);
      return FALSE;
    }
d3332 6
a3337 8
  /* If we don't have any raw data for this archive, as can happen on
     Irix 4.0.5F, we call the generic routine.
     FIXME: We should be more clever about this, since someday tdata
     may get to something for a generic archive.  */
  raw_armap = (const bfd_byte *) bfd_ardata (abfd)->tdata;
  if (raw_armap == (bfd_byte *) NULL)
    return (_bfd_generic_link_add_archive_symbols
	    (abfd, info, ecoff_link_check_archive_element));
d3339 3
a3341 13
  armap_count = H_GET_32 (abfd, raw_armap);

  armap_log = 0;
  for (i = 1; i < armap_count; i <<= 1)
    armap_log++;
  BFD_ASSERT (i == armap_count);

  hashtable = raw_armap + 4;
  stringbase = (const char *) raw_armap + armap_count * 8 + 8;

  /* Look through the list of undefined symbols.  */
  pundef = &info->hash->undefs;
  while (*pundef != (struct bfd_link_hash_entry *) NULL)
d3343 4
a3346 3
      struct bfd_link_hash_entry *h;
      unsigned int hash, rehash;
      unsigned int file_offset;
d3348 1
a3348 1
      bfd *element;
d3350 1
a3350 1
      h = *pundef;
d3352 1
a3352 16
      /* When a symbol is defined, it is not necessarily removed from
	 the list.  */
      if (h->type != bfd_link_hash_undefined
	  && h->type != bfd_link_hash_common)
	{
	  /* Remove this entry from the list, for general cleanliness
	     and because we are going to look through the list again
	     if we search any more libraries.  We can't remove the
	     entry if it is the tail, because that would lose any
	     entries we add to the list later on.  */
	  if (*pundef != info->hash->undefs_tail)
	    *pundef = (*pundef)->u.undef.next;
	  else
	    pundef = &(*pundef)->u.undef.next;
	  continue;
	}
d3354 3
a3356 5
      /* Native ECOFF linkers do not pull in archive elements merely
	 to satisfy common definitions, so neither do we.  We leave
	 them on the list, though, in case we are linking against some
	 other object format.  */
      if (h->type != bfd_link_hash_undefined)
d3358 9
a3366 2
	  pundef = &(*pundef)->u.undef.next;
	  continue;
d3369 2
a3370 3
      /* Look for this symbol in the archive hash table.  */
      hash = ecoff_armap_hash (h->root.string, &rehash, armap_count,
			       armap_log);
d3372 3
a3374 2
      file_offset = H_GET_32 (abfd, hashtable + (hash * 8) + 4);
      if (file_offset == 0)
d3376 49
a3424 17
	  /* Nothing in this slot.  */
	  pundef = &(*pundef)->u.undef.next;
	  continue;
	}

      name = stringbase + H_GET_32 (abfd, hashtable + (hash * 8));
      if (name[0] != h->root.string[0]
	  || strcmp (name, h->root.string) != 0)
	{
	  unsigned int srch;
	  bfd_boolean found;

	  /* That was the wrong symbol.  Try rehashing.  */
	  found = FALSE;
	  for (srch = (hash + rehash) & (armap_count - 1);
	       srch != hash;
	       srch = (srch + rehash) & (armap_count - 1))
d3426 17
a3442 10
	      file_offset = H_GET_32 (abfd, hashtable + (srch * 8) + 4);
	      if (file_offset == 0)
		break;
	      name = stringbase + H_GET_32 (abfd, hashtable + (srch * 8));
	      if (name[0] == h->root.string[0]
		  && strcmp (name, h->root.string) == 0)
		{
		  found = TRUE;
		  break;
		}
d3444 29
d3474 11
a3484 1
	  if (! found)
d3486 2
a3487 2
	      pundef = &(*pundef)->u.undef.next;
	      continue;
d3490 19
a3508 1
	  hash = srch;
d3510 20
d3531 20
a3550 3
      element = (*backend->get_elt_at_filepos) (abfd, (file_ptr) file_offset);
      if (element == (bfd *) NULL)
	return FALSE;
d3552 4
a3555 2
      if (! bfd_check_format (element, bfd_object))
	return FALSE;
d3557 1
a3557 7
      /* Unlike the generic linker, we know that this element provides
	 a definition for an undefined symbol and we know that we want
	 to include it.  We don't need to check anything.  */
      if (! (*info->callbacks->add_archive_element) (info, element, name))
	return FALSE;
      if (! ecoff_link_add_object_symbols (element, info))
	return FALSE;
d3559 5
a3563 2
      pundef = &(*pundef)->u.undef.next;
    }
d3565 6
a3570 1
  return TRUE;
d3577 3
a3579 4
ecoff_link_check_archive_element (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
d3582 1
a3582 1
  void (* const swap_ext_in) PARAMS ((bfd *, PTR, EXTR *))
d3586 1
a3586 1
  PTR external_ext = NULL;
d3606 1
a3606 1
  external_ext = (PTR) bfd_malloc (esize);
d3614 1
a3614 1
  ssext = (char *) bfd_malloc ((bfd_size_type) symhdr->issExtMax);
d3634 1
a3634 1
      (*swap_ext_in) (abfd, (PTR) ext_ptr, &esym);
d3671 1
a3671 1
      if (h == (struct bfd_link_hash_entry *) NULL
d3699 6
a3704 2
/* Add symbols from an ECOFF object file to the global linker hash
   table.  */
d3707 1
a3707 3
ecoff_link_add_object_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d3709 8
a3716 6
  HDRR *symhdr;
  bfd_size_type external_ext_size;
  PTR external_ext = NULL;
  bfd_size_type esize;
  char *ssext = NULL;
  bfd_boolean result;
d3718 8
a3725 2
  if (! ecoff_slurp_symbolic_header (abfd))
    return FALSE;
d3727 8
a3734 3
  /* If there are no symbols, we don't want it.  */
  if (bfd_get_symcount (abfd) == 0)
    return TRUE;
d3736 1
a3736 1
  symhdr = &ecoff_data (abfd)->debug_info.symbolic_header;
d3738 4
a3741 6
  /* Read in the external symbols and external strings.  */
  external_ext_size = ecoff_backend (abfd)->debug_swap.external_ext_size;
  esize = symhdr->iextMax * external_ext_size;
  external_ext = (PTR) bfd_malloc (esize);
  if (external_ext == NULL && esize != 0)
    goto error_return;
d3743 2
a3744 3
  if (bfd_seek (abfd, (file_ptr) symhdr->cbExtOffset, SEEK_SET) != 0
      || bfd_bread (external_ext, esize, abfd) != esize)
    goto error_return;
d3746 9
a3754 3
  ssext = (char *) bfd_malloc ((bfd_size_type) symhdr->issExtMax);
  if (ssext == NULL && symhdr->issExtMax != 0)
    goto error_return;
d3756 1
a3756 4
  if (bfd_seek (abfd, (file_ptr) symhdr->cbSsExtOffset, SEEK_SET) != 0
      || (bfd_bread (ssext, (bfd_size_type) symhdr->issExtMax, abfd)
	  != (bfd_size_type) symhdr->issExtMax))
    goto error_return;
d3758 16
a3773 1
  result = ecoff_link_add_externals (abfd, info, external_ext, ssext);
d3775 9
a3783 5
  if (ssext != NULL)
    free (ssext);
  if (external_ext != NULL)
    free (external_ext);
  return result;
d3785 3
a3787 7
 error_return:
  if (ssext != NULL)
    free (ssext);
  if (external_ext != NULL)
    free (external_ext);
  return FALSE;
}
d3789 2
a3790 50
/* Add the external symbols of an object file to the global linker
   hash table.  The external symbols and strings we are passed are
   just allocated on the stack, and will be discarded.  We must
   explicitly save any information we may need later on in the link.
   We do not want to read the external symbol information again.  */

static bfd_boolean
ecoff_link_add_externals (abfd, info, external_ext, ssext)
     bfd *abfd;
     struct bfd_link_info *info;
     PTR external_ext;
     char *ssext;
{
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  void (* const swap_ext_in) PARAMS ((bfd *, PTR, EXTR *))
    = backend->debug_swap.swap_ext_in;
  bfd_size_type external_ext_size = backend->debug_swap.external_ext_size;
  unsigned long ext_count;
  struct bfd_link_hash_entry **sym_hash;
  char *ext_ptr;
  char *ext_end;
  bfd_size_type amt;

  ext_count = ecoff_data (abfd)->debug_info.symbolic_header.iextMax;

  amt = ext_count;
  amt *= sizeof (struct bfd_link_hash_entry *);
  sym_hash = (struct bfd_link_hash_entry **) bfd_alloc (abfd, amt);
  if (!sym_hash)
    return FALSE;
  ecoff_data (abfd)->sym_hashes = (struct ecoff_link_hash_entry **) sym_hash;

  ext_ptr = (char *) external_ext;
  ext_end = ext_ptr + ext_count * external_ext_size;
  for (; ext_ptr < ext_end; ext_ptr += external_ext_size, sym_hash++)
    {
      EXTR esym;
      bfd_boolean skip;
      bfd_vma value;
      asection *section;
      const char *name;
      struct ecoff_link_hash_entry *h;

      *sym_hash = NULL;

      (*swap_ext_in) (abfd, (PTR) ext_ptr, &esym);

      /* Skip debugging symbols.  */
      skip = FALSE;
      switch (esym.asym.st)
d3792 3
a3794 9
	case stGlobal:
	case stStatic:
	case stLabel:
	case stProc:
	case stStaticProc:
	  break;
	default:
	  skip = TRUE;
	  break;
d3797 6
a3802 2
      if (skip)
	continue;
d3804 5
a3808 53
      /* Get the information for this symbol.  */
      value = esym.asym.value;
      switch (esym.asym.sc)
	{
	default:
	case scNil:
	case scRegister:
	case scCdbLocal:
	case scBits:
	case scCdbSystem:
	case scRegImage:
	case scInfo:
	case scUserStruct:
	case scVar:
	case scVarRegister:
	case scVariant:
	case scBasedVar:
	case scXData:
	case scPData:
	  section = NULL;
	  break;
	case scText:
	  section = bfd_make_section_old_way (abfd, ".text");
	  value -= section->vma;
	  break;
	case scData:
	  section = bfd_make_section_old_way (abfd, ".data");
	  value -= section->vma;
	  break;
	case scBss:
	  section = bfd_make_section_old_way (abfd, ".bss");
	  value -= section->vma;
	  break;
	case scAbs:
	  section = bfd_abs_section_ptr;
	  break;
	case scUndefined:
	  section = bfd_und_section_ptr;
	  break;
	case scSData:
	  section = bfd_make_section_old_way (abfd, ".sdata");
	  value -= section->vma;
	  break;
	case scSBss:
	  section = bfd_make_section_old_way (abfd, ".sbss");
	  value -= section->vma;
	  break;
	case scRData:
	  section = bfd_make_section_old_way (abfd, ".rdata");
	  value -= section->vma;
	  break;
	case scCommon:
	  if (value > ecoff_data (abfd)->gp_size)
d3810 10
a3819 2
	      section = bfd_com_section_ptr;
	      break;
d3821 2
a3822 3
	  /* Fall through.  */
	case scSCommon:
	  if (ecoff_scom_section.name == NULL)
d3824 2
a3825 10
	      /* Initialize the small common section.  */
	      ecoff_scom_section.name = SCOMMON;
	      ecoff_scom_section.flags = SEC_IS_COMMON;
	      ecoff_scom_section.output_section = &ecoff_scom_section;
	      ecoff_scom_section.symbol = &ecoff_scom_symbol;
	      ecoff_scom_section.symbol_ptr_ptr = &ecoff_scom_symbol_ptr;
	      ecoff_scom_symbol.name = SCOMMON;
	      ecoff_scom_symbol.flags = BSF_SECTION_SYM;
	      ecoff_scom_symbol.section = &ecoff_scom_section;
	      ecoff_scom_symbol_ptr = &ecoff_scom_symbol;
d3827 2
a3828 17
	  section = &ecoff_scom_section;
	  break;
	case scSUndefined:
	  section = bfd_und_section_ptr;
	  break;
	case scInit:
	  section = bfd_make_section_old_way (abfd, ".init");
	  value -= section->vma;
	  break;
	case scFini:
	  section = bfd_make_section_old_way (abfd, ".fini");
	  value -= section->vma;
	  break;
	case scRConst:
	  section = bfd_make_section_old_way (abfd, ".rconst");
	  value -= section->vma;
	  break;
d3831 3
a3833 2
      if (section == (asection *) NULL)
	continue;
d3835 2
a3836 1
      name = ssext + esym.asym.iss;
d3838 6
a3843 4
      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, name,
	      (flagword) (esym.weakext ? BSF_WEAK : BSF_GLOBAL),
	      section, value, (const char *) NULL, TRUE, TRUE, sym_hash)))
d3846 2
a3847 1
      h = (struct ecoff_link_hash_entry *) *sym_hash;
d3849 2
a3850 13
      /* If we are building an ECOFF hash table, save the external
	 symbol information.  */
      if (info->hash->creator->flavour == bfd_get_flavour (abfd))
	{
	  if (h->abfd == (bfd *) NULL
	      || (! bfd_is_und_section (section)
		  && (! bfd_is_com_section (section)
		      || (h->root.type != bfd_link_hash_defined
			  && h->root.type != bfd_link_hash_defweak))))
	    {
	      h->abfd = abfd;
	      h->esym = esym;
	    }
d3852 2
a3853 3
	  /* Remember whether this symbol was small undefined.  */
	  if (esym.asym.sc == scSUndefined)
	    h->small = 1;
d3855 12
a3866 16
	  /* If this symbol was ever small undefined, it needs to wind
	     up in a GP relative section.  We can't control the
	     section of a defined symbol, but we can control the
	     section of a common symbol.  This case is actually needed
	     on Ultrix 4.2 to handle the symbol cred in -lckrb.  */
	  if (h->small
	      && h->root.type == bfd_link_hash_common
	      && strcmp (h->root.u.c.p->section->name, SCOMMON) != 0)
	    {
	      h->root.u.c.p->section = bfd_make_section_old_way (abfd,
								 SCOMMON);
	      h->root.u.c.p->section->flags = SEC_ALLOC;
	      if (h->esym.asym.sc == scCommon)
		h->esym.asym.sc = scSCommon;
	    }
	}
d3868 1
a3869 2
  return TRUE;
}
a3872 12
static bfd_boolean ecoff_final_link_debug_accumulate
  PARAMS ((bfd *output_bfd, bfd *input_bfd, struct bfd_link_info *,
	   PTR handle));
static bfd_boolean ecoff_link_write_external
  PARAMS ((struct ecoff_link_hash_entry *, PTR));
static bfd_boolean ecoff_indirect_link_order
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   struct bfd_link_order *));
static bfd_boolean ecoff_reloc_link_order
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   struct bfd_link_order *));

d3881 3
a3883 4
/* ECOFF final link routine.  This looks through all the input BFDs
   and gathers together all the debugging information, and then
   processes all the link order information.  This may cause it to
   close and reopen some input BFDs; I'll see how bad this is.  */
d3885 5
a3889 4
bfd_boolean
_bfd_ecoff_bfd_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d3891 5
a3895 8
  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);
  struct ecoff_debug_info * const debug = &ecoff_data (abfd)->debug_info;
  HDRR *symhdr;
  PTR handle;
  register bfd *input_bfd;
  asection *o;
  struct bfd_link_order *p;
  struct extsym_info einfo;
d3897 37
a3933 16
  /* We accumulate the debugging information counts in the symbolic
     header.  */
  symhdr = &debug->symbolic_header;
  symhdr->vstamp = 0;
  symhdr->ilineMax = 0;
  symhdr->cbLine = 0;
  symhdr->idnMax = 0;
  symhdr->ipdMax = 0;
  symhdr->isymMax = 0;
  symhdr->ioptMax = 0;
  symhdr->iauxMax = 0;
  symhdr->issMax = 0;
  symhdr->issExtMax = 0;
  symhdr->ifdMax = 0;
  symhdr->crfd = 0;
  symhdr->iextMax = 0;
d3935 1
a3935 13
  /* We accumulate the debugging information itself in the debug_info
     structure.  */
  debug->line = NULL;
  debug->external_dnr = NULL;
  debug->external_pdr = NULL;
  debug->external_sym = NULL;
  debug->external_opt = NULL;
  debug->external_aux = NULL;
  debug->ss = NULL;
  debug->ssext = debug->ssext_end = NULL;
  debug->external_fdr = NULL;
  debug->external_rfd = NULL;
  debug->external_ext = debug->external_ext_end = NULL;
d3937 4
a3940 3
  handle = bfd_ecoff_debug_init (abfd, debug, &backend->debug_swap, info);
  if (handle == (PTR) NULL)
    return FALSE;
d3942 2
a3943 4
  /* Accumulate the debugging symbols from each input BFD.  */
  for (input_bfd = info->input_bfds;
       input_bfd != (bfd *) NULL;
       input_bfd = input_bfd->link_next)
d3945 74
a4018 1
      bfd_boolean ret;
d4020 4
a4023 16
      if (bfd_get_flavour (input_bfd) == bfd_target_ecoff_flavour)
	{
	  /* Arbitrarily set the symbolic header vstamp to the vstamp
	     of the first object file in the link.  */
	  if (symhdr->vstamp == 0)
	    symhdr->vstamp
	      = ecoff_data (input_bfd)->debug_info.symbolic_header.vstamp;
	  ret = ecoff_final_link_debug_accumulate (abfd, input_bfd, info,
						   handle);
	}
      else
	ret = bfd_ecoff_debug_accumulate_other (handle, abfd,
						debug, &backend->debug_swap,
						input_bfd, info);
      if (! ret)
	return FALSE;
d4025 5
a4029 8
      /* Combine the register masks.  */
      ecoff_data (abfd)->gprmask |= ecoff_data (input_bfd)->gprmask;
      ecoff_data (abfd)->fprmask |= ecoff_data (input_bfd)->fprmask;
      ecoff_data (abfd)->cprmask[0] |= ecoff_data (input_bfd)->cprmask[0];
      ecoff_data (abfd)->cprmask[1] |= ecoff_data (input_bfd)->cprmask[1];
      ecoff_data (abfd)->cprmask[2] |= ecoff_data (input_bfd)->cprmask[2];
      ecoff_data (abfd)->cprmask[3] |= ecoff_data (input_bfd)->cprmask[3];
    }
d4031 7
a4037 6
  /* Write out the external symbols.  */
  einfo.abfd = abfd;
  einfo.info = info;
  ecoff_link_hash_traverse (ecoff_hash_table (info),
			    ecoff_link_write_external,
			    (PTR) &einfo);
d4039 4
d4045 7
a4051 15
      /* We need to make a pass over the link_orders to count up the
	 number of relocations we will need to output, so that we know
	 how much space they will take up.  */
      for (o = abfd->sections; o != (asection *) NULL; o = o->next)
	{
	  o->reloc_count = 0;
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    if (p->type == bfd_indirect_link_order)
	      o->reloc_count += p->u.indirect.section->reloc_count;
	    else if (p->type == bfd_section_reloc_link_order
		     || p->type == bfd_symbol_reloc_link_order)
	      ++o->reloc_count;
	}
d4054 34
a4087 2
  /* Compute the reloc and symbol file positions.  */
  ecoff_compute_reloc_file_positions (abfd);
d4089 3
a4091 5
  /* Write out the debugging information.  */
  if (! bfd_ecoff_write_accumulated_debug (handle, abfd, debug,
					   &backend->debug_swap, info,
					   ecoff_data (abfd)->sym_filepos))
    return FALSE;
d4093 3
a4095 1
  bfd_ecoff_debug_free (handle, abfd, debug, &backend->debug_swap, info);
d4097 2
a4098 1
  if (info->relocatable)
d4100 2
a4101 5
      /* Now reset the reloc_count field of the sections in the output
	 BFD to 0, so that we can use them to keep track of how many
	 relocs we have output thus far.  */
      for (o = abfd->sections; o != (asection *) NULL; o = o->next)
	o->reloc_count = 0;
d4104 6
a4109 2
  /* Get a value for the GP register.  */
  if (ecoff_data (abfd)->gp == 0)
d4113 17
a4129 7
      h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
	ecoff_data (abfd)->gp = (h->u.def.value
				 + h->u.def.section->output_section->vma
				 + h->u.def.section->output_offset);
      else if (info->relocatable)
d4131 16
a4146 1
	  bfd_vma lo;
d4148 21
a4168 3
	  /* Make up a value.  */
	  lo = (bfd_vma) -1;
	  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
d4170 2
a4171 7
	      if (o->vma < lo
		  && (strcmp (o->name, _SBSS) == 0
		      || strcmp (o->name, _SDATA) == 0
		      || strcmp (o->name, _LIT4) == 0
		      || strcmp (o->name, _LIT8) == 0
		      || strcmp (o->name, _LITA) == 0))
		lo = o->vma;
d4173 1
a4173 7
	  ecoff_data (abfd)->gp = lo + 0x8000;
	}
      else
	{
	  /* If the relocate_section function needs to do a reloc
	     involving the GP value, it should make a reloc_dangerous
	     callback to warn that GP is not defined.  */
d4175 5
d4182 8
a4189 1
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
d4191 10
a4200 3
      for (p = o->link_order_head;
	   p != (struct bfd_link_order *) NULL;
	   p = p->next)
d4202 5
a4206 18
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour (p->u.indirect.section->owner)
		  == bfd_target_ecoff_flavour))
	    {
	      if (! ecoff_indirect_link_order (abfd, info, o, p))
		return FALSE;
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! ecoff_reloc_link_order (abfd, info, o, p))
		return FALSE;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		return FALSE;
	    }
d4208 1
d4210 27
d4238 1
a4238 1
  bfd_get_symcount (abfd) = symhdr->iextMax + symhdr->isymMax;
d4240 6
a4245 1
  ecoff_data (abfd)->linker = TRUE;
d4247 2
a4248 2
  return TRUE;
}
d4250 2
a4251 3
/* Accumulate the debugging information for an input BFD into the
   output BFD.  This must read in the symbolic information of the
   input BFD.  */
d4253 2
a4254 12
static bfd_boolean
ecoff_final_link_debug_accumulate (output_bfd, input_bfd, info, handle)
     bfd *output_bfd;
     bfd *input_bfd;
     struct bfd_link_info *info;
     PTR handle;
{
  struct ecoff_debug_info * const debug = &ecoff_data (input_bfd)->debug_info;
  const struct ecoff_debug_swap * const swap =
    &ecoff_backend (input_bfd)->debug_swap;
  HDRR *symhdr = &debug->symbolic_header;
  bfd_boolean ret;
d4256 5
a4260 19
#define READ(ptr, offset, count, size, type)				 \
  if (symhdr->count == 0)						 \
    debug->ptr = NULL;							 \
  else									 \
    {									 \
      bfd_size_type amt = (bfd_size_type) size * symhdr->count;		 \
      debug->ptr = (type) bfd_malloc (amt);				 \
      if (debug->ptr == NULL)						 \
	{								 \
          ret = FALSE;							 \
          goto return_something;					 \
	}								 \
      if (bfd_seek (input_bfd, (file_ptr) symhdr->offset, SEEK_SET) != 0 \
	  || bfd_bread (debug->ptr, amt, input_bfd) != amt)		 \
	{								 \
          ret = FALSE;							 \
          goto return_something;					 \
	}								 \
    }
d4262 1
a4262 17
  /* If raw_syments is not NULL, then the data was already by read by
     _bfd_ecoff_slurp_symbolic_info.  */
  if (ecoff_data (input_bfd)->raw_syments == NULL)
    {
      READ (line, cbLineOffset, cbLine, sizeof (unsigned char),
	    unsigned char *);
      READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, PTR);
      READ (external_pdr, cbPdOffset, ipdMax, swap->external_pdr_size, PTR);
      READ (external_sym, cbSymOffset, isymMax, swap->external_sym_size, PTR);
      READ (external_opt, cbOptOffset, ioptMax, swap->external_opt_size, PTR);
      READ (external_aux, cbAuxOffset, iauxMax, sizeof (union aux_ext),
	    union aux_ext *);
      READ (ss, cbSsOffset, issMax, sizeof (char), char *);
      READ (external_fdr, cbFdOffset, ifdMax, swap->external_fdr_size, PTR);
      READ (external_rfd, cbRfdOffset, crfd, swap->external_rfd_size, PTR);
    }
#undef READ
d4264 5
a4268 1
  /* We do not read the external strings or the external symbols.  */
d4270 2
a4271 4
  ret = (bfd_ecoff_debug_accumulate
	 (handle, output_bfd, &ecoff_data (output_bfd)->debug_info,
	  &ecoff_backend (output_bfd)->debug_swap,
	  input_bfd, debug, swap, info));
d4273 1
a4273 21
 return_something:
  if (ecoff_data (input_bfd)->raw_syments == NULL)
    {
      if (debug->line != NULL)
	free (debug->line);
      if (debug->external_dnr != NULL)
	free (debug->external_dnr);
      if (debug->external_pdr != NULL)
	free (debug->external_pdr);
      if (debug->external_sym != NULL)
	free (debug->external_sym);
      if (debug->external_opt != NULL)
	free (debug->external_opt);
      if (debug->external_aux != NULL)
	free (debug->external_aux);
      if (debug->ss != NULL)
	free (debug->ss);
      if (debug->external_fdr != NULL)
	free (debug->external_fdr);
      if (debug->external_rfd != NULL)
	free (debug->external_rfd);
d4275 1
a4275 14
      /* Make sure we don't accidentally follow one of these pointers
	 into freed memory.  */
      debug->line = NULL;
      debug->external_dnr = NULL;
      debug->external_pdr = NULL;
      debug->external_sym = NULL;
      debug->external_opt = NULL;
      debug->external_aux = NULL;
      debug->ss = NULL;
      debug->external_fdr = NULL;
      debug->external_rfd = NULL;
    }

  return ret;
d4282 1
a4282 3
ecoff_link_write_external (h, data)
     struct ecoff_link_hash_entry *h;
     PTR data;
d4311 1
a4311 1
  if (h->abfd == (bfd *) NULL)
d4328 20
d4352 8
a4359 23
	  if (strcmp (name, _TEXT) == 0)
	    h->esym.asym.sc = scText;
	  else if (strcmp (name, _DATA) == 0)
	    h->esym.asym.sc = scData;
	  else if (strcmp (name, _SDATA) == 0)
	    h->esym.asym.sc = scSData;
	  else if (strcmp (name, _RDATA) == 0)
	    h->esym.asym.sc = scRData;
	  else if (strcmp (name, _BSS) == 0)
	    h->esym.asym.sc = scBss;
	  else if (strcmp (name, _SBSS) == 0)
	    h->esym.asym.sc = scSBss;
	  else if (strcmp (name, _INIT) == 0)
	    h->esym.asym.sc = scInit;
	  else if (strcmp (name, _FINI) == 0)
	    h->esym.asym.sc = scFini;
	  else if (strcmp (name, _PDATA) == 0)
	    h->esym.asym.sc = scPData;
	  else if (strcmp (name, _XDATA) == 0)
	    h->esym.asym.sc = scXData;
	  else if (strcmp (name, _RCONST) == 0)
	    h->esym.asym.sc = scRConst;
	  else
d4426 4
a4429 1
/* Relocate and write an ECOFF section into an ECOFF output file.  */
d4431 2
a4432 6
static bfd_boolean
ecoff_indirect_link_order (output_bfd, info, output_section, link_order)
     bfd *output_bfd;
     struct bfd_link_info *info;
     asection *output_section;
     struct bfd_link_order *link_order;
d4434 4
a4437 1
  asection *input_section;
d4439 3
a4441 4
  bfd_byte *contents = NULL;
  bfd_size_type external_reloc_size;
  bfd_size_type external_relocs_size;
  PTR external_relocs = NULL;
d4443 16
a4458 1
  BFD_ASSERT ((output_section->flags & SEC_HAS_CONTENTS) != 0);
d4460 13
a4472 2
  if (link_order->size == 0)
    return TRUE;
d4474 3
a4476 2
  input_section = link_order->u.indirect.section;
  input_bfd = input_section->owner;
d4478 6
a4483 3
  BFD_ASSERT (input_section->output_section == output_section);
  BFD_ASSERT (input_section->output_offset == link_order->offset);
  BFD_ASSERT (input_section->size == link_order->size);
d4485 16
a4500 12
  /* Get the section contents.  */
  if (!bfd_malloc_and_get_section (input_bfd, input_section, &contents))
    goto error_return;

  /* Get the relocs.  If we are relaxing MIPS code, they will already
     have been read in.  Otherwise, we read them in now.  */
  external_reloc_size = ecoff_backend (input_bfd)->external_reloc_size;
  external_relocs_size = external_reloc_size * input_section->reloc_count;

  external_relocs = (PTR) bfd_malloc (external_relocs_size);
  if (external_relocs == NULL && external_relocs_size != 0)
    goto error_return;
d4502 8
a4509 4
  if (bfd_seek (input_bfd, input_section->rel_filepos, SEEK_SET) != 0
      || (bfd_bread (external_relocs, external_relocs_size, input_bfd)
	  != external_relocs_size))
    goto error_return;
d4511 6
a4516 13
  /* Relocate the section contents.  */
  if (! ((*ecoff_backend (input_bfd)->relocate_section)
	 (output_bfd, info, input_bfd, input_section, contents,
	  external_relocs)))
    goto error_return;

  /* Write out the relocated section.  */
  if (! bfd_set_section_contents (output_bfd,
				  output_section,
				  contents,
				  input_section->output_offset,
				  input_section->size))
    goto error_return;
a4517 4
  /* If we are producing relocatable output, the relocs were
     modified, and we write them out now.  We use the reloc_count
     field of output_section to keep track of the number of relocs we
     have output so far.  */
d4520 15
a4534 7
      file_ptr pos = (output_section->rel_filepos
		      + output_section->reloc_count * external_reloc_size);
      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
	  || (bfd_bwrite (external_relocs, external_relocs_size, output_bfd)
	      != external_relocs_size))
	goto error_return;
      output_section->reloc_count += input_section->reloc_count;
d4537 2
a4538 5
  if (contents != NULL)
    free (contents);
  if (external_relocs != NULL)
    free (external_relocs);
  return TRUE;
d4540 5
a4544 7
 error_return:
  if (contents != NULL)
    free (contents);
  if (external_relocs != NULL)
    free (external_relocs);
  return FALSE;
}
d4546 1
a4546 4
/* Generate a reloc when linking an ECOFF file.  This is a reloc
   requested by the linker, and does come from any input file.  This
   is used to build constructor and destructor tables when linking
   with -Ur.  */
d4548 1
a4548 27
static bfd_boolean
ecoff_reloc_link_order (output_bfd, info, output_section, link_order)
     bfd *output_bfd;
     struct bfd_link_info *info;
     asection *output_section;
     struct bfd_link_order *link_order;
{
  enum bfd_link_order_type type;
  asection *section;
  bfd_vma addend;
  arelent rel;
  struct internal_reloc in;
  bfd_size_type external_reloc_size;
  bfd_byte *rbuf;
  bfd_boolean ok;
  file_ptr pos;

  type = link_order->type;
  section = NULL;
  addend = link_order->u.reloc.p->addend;

  /* We set up an arelent to pass to the backend adjust_reloc_out
     routine.  */
  rel.address = link_order->offset;

  rel.howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (rel.howto == 0)
d4550 5
a4554 2
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
d4557 2
a4558 6
  if (type == bfd_section_reloc_link_order)
    {
      section = link_order->u.reloc.p->u.section;
      rel.sym_ptr_ptr = section->symbol_ptr_ptr;
    }
  else
d4562 1
a4562 5
      /* Treat a reloc against a defined symbol as though it were
         actually against the section.  */
      h = bfd_wrapped_link_hash_lookup (output_bfd, info,
					link_order->u.reloc.p->u.name,
					FALSE, FALSE, FALSE);
d4564 5
a4568 2
	  && (h->type == bfd_link_hash_defined
	      || h->type == bfd_link_hash_defweak))
d4570 15
a4584 6
	  type = bfd_section_reloc_link_order;
	  section = h->u.def.section->output_section;
	  /* It seems that we ought to add the symbol value to the
             addend here, but in practice it has already been added
             because it was passed to constructor_callback.  */
	  addend += section->vma + h->u.def.section->output_offset;
d4588 3
a4590 4
	  /* We can't set up a reloc against a symbol correctly,
	     because we have no asymbol structure.  Currently no
	     adjust_reloc_out routine cares.  */
	  rel.sym_ptr_ptr = (asymbol **) NULL;
d4594 1
a4594 5
  /* All ECOFF relocs are in-place.  Put the addend into the object
     file.  */

  BFD_ASSERT (rel.howto->partial_inplace);
  if (addend != 0)
d4596 3
a4598 11
      bfd_size_type size;
      bfd_reloc_status_type rstat;
      bfd_byte *buf;

      size = bfd_get_reloc_size (rel.howto);
      buf = (bfd_byte *) bfd_zmalloc (size);
      if (buf == (bfd_byte *) NULL)
	return FALSE;
      rstat = _bfd_relocate_contents (rel.howto, output_bfd,
				      (bfd_vma) addend, buf);
      switch (rstat)
d4600 14
a4613 13
	case bfd_reloc_ok:
	  break;
	default:
	case bfd_reloc_outofrange:
	  abort ();
	case bfd_reloc_overflow:
	  if (! ((*info->callbacks->reloc_overflow)
		 (info, NULL,
		  (link_order->type == bfd_section_reloc_link_order
		   ? bfd_section_name (output_bfd, section)
		   : link_order->u.reloc.p->u.name),
		  rel.howto->name, addend, (bfd *) NULL,
		  (asection *) NULL, (bfd_vma) 0)))
d4615 2
a4616 2
	      free (buf);
	      return FALSE;
a4617 1
	  break;
a4618 5
      ok = bfd_set_section_contents (output_bfd, output_section, (PTR) buf,
				     (file_ptr) link_order->offset, size);
      free (buf);
      if (! ok)
	return FALSE;
d4621 1
a4621 1
  rel.addend = 0;
d4623 1
a4623 4
  /* Move the information into an internal_reloc structure.  */
  in.r_vaddr = (rel.address
		+ bfd_get_section_vma (output_bfd, output_section));
  in.r_type = rel.howto->type;
d4625 1
a4625 84
  if (type == bfd_symbol_reloc_link_order)
    {
      struct ecoff_link_hash_entry *h;

      h = ((struct ecoff_link_hash_entry *)
	   bfd_wrapped_link_hash_lookup (output_bfd, info,
					 link_order->u.reloc.p->u.name,
					 FALSE, FALSE, TRUE));
      if (h != (struct ecoff_link_hash_entry *) NULL
	  && h->indx != -1)
	in.r_symndx = h->indx;
      else
	{
	  if (! ((*info->callbacks->unattached_reloc)
		 (info, link_order->u.reloc.p->u.name, (bfd *) NULL,
		  (asection *) NULL, (bfd_vma) 0)))
	    return FALSE;
	  in.r_symndx = 0;
	}
      in.r_extern = 1;
    }
  else
    {
      const char *name;

      name = bfd_get_section_name (output_bfd, section);
      if (strcmp (name, ".text") == 0)
	in.r_symndx = RELOC_SECTION_TEXT;
      else if (strcmp (name, ".rdata") == 0)
	in.r_symndx = RELOC_SECTION_RDATA;
      else if (strcmp (name, ".data") == 0)
	in.r_symndx = RELOC_SECTION_DATA;
      else if (strcmp (name, ".sdata") == 0)
	in.r_symndx = RELOC_SECTION_SDATA;
      else if (strcmp (name, ".sbss") == 0)
	in.r_symndx = RELOC_SECTION_SBSS;
      else if (strcmp (name, ".bss") == 0)
	in.r_symndx = RELOC_SECTION_BSS;
      else if (strcmp (name, ".init") == 0)
	in.r_symndx = RELOC_SECTION_INIT;
      else if (strcmp (name, ".lit8") == 0)
	in.r_symndx = RELOC_SECTION_LIT8;
      else if (strcmp (name, ".lit4") == 0)
	in.r_symndx = RELOC_SECTION_LIT4;
      else if (strcmp (name, ".xdata") == 0)
	in.r_symndx = RELOC_SECTION_XDATA;
      else if (strcmp (name, ".pdata") == 0)
	in.r_symndx = RELOC_SECTION_PDATA;
      else if (strcmp (name, ".fini") == 0)
	in.r_symndx = RELOC_SECTION_FINI;
      else if (strcmp (name, ".lita") == 0)
	in.r_symndx = RELOC_SECTION_LITA;
      else if (strcmp (name, "*ABS*") == 0)
	in.r_symndx = RELOC_SECTION_ABS;
      else if (strcmp (name, ".rconst") == 0)
	in.r_symndx = RELOC_SECTION_RCONST;
      else
	abort ();
      in.r_extern = 0;
    }

  /* Let the BFD backend adjust the reloc.  */
  (*ecoff_backend (output_bfd)->adjust_reloc_out) (output_bfd, &rel, &in);

  /* Get some memory and swap out the reloc.  */
  external_reloc_size = ecoff_backend (output_bfd)->external_reloc_size;
  rbuf = (bfd_byte *) bfd_malloc (external_reloc_size);
  if (rbuf == (bfd_byte *) NULL)
    return FALSE;

  (*ecoff_backend (output_bfd)->swap_reloc_out) (output_bfd, &in, (PTR) rbuf);

  pos = (output_section->rel_filepos
	 + output_section->reloc_count * external_reloc_size);
  ok = (bfd_seek (output_bfd, pos, SEEK_SET) == 0
	&& (bfd_bwrite ((PTR) rbuf, external_reloc_size, output_bfd)
	    == external_reloc_size));

  if (ok)
    ++output_section->reloc_count;

  free (rbuf);

  return ok;
@


1.39
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
@


1.38
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@a864 67
	    /* This code is no longer needed.  It used to be used to
	       make the linker handle set symbols, but they are now
	       handled in the add_symbols routine instead.  */
#if 0
	    const char *name;
	    asection *section;
	    arelent_chain *reloc_chain;
	    unsigned int bitsize;
	    bfd_size_type amt;

	    /* Get a section with the same name as the symbol (usually
	       __CTOR_LIST__ or __DTOR_LIST__).  FIXME: gcc uses the
	       name ___CTOR_LIST (three underscores).  We need
	       __CTOR_LIST (two underscores), since ECOFF doesn't use
	       a leading underscore.  This should be handled by gcc,
	       but instead we do it here.  Actually, this should all
	       be done differently anyhow.  */
	    name = bfd_asymbol_name (asym);
	    if (name[0] == '_' && name[1] == '_' && name[2] == '_')
	      {
		++name;
		asym->name = name;
	      }
	    section = bfd_get_section_by_name (abfd, name);
	    if (section == (asection *) NULL)
	      {
		char *copy;

		amt = strlen (name) + 1;
		copy = (char *) bfd_alloc (abfd, amt);
		if (!copy)
		  return FALSE;
		strcpy (copy, name);
		section = bfd_make_section (abfd, copy);
	      }

	    /* Build a reloc pointing to this constructor.  */
	    amt = sizeof (arelent_chain);
	    reloc_chain = (arelent_chain *) bfd_alloc (abfd, amt);
	    if (!reloc_chain)
	      return FALSE;
	    reloc_chain->relent.sym_ptr_ptr =
	      bfd_get_section (asym)->symbol_ptr_ptr;
	    reloc_chain->relent.address = section->size;
	    reloc_chain->relent.addend = asym->value;
	    reloc_chain->relent.howto =
	      ecoff_backend (abfd)->constructor_reloc;

	    /* Set up the constructor section to hold the reloc.  */
	    section->flags = SEC_CONSTRUCTOR;
	    ++section->reloc_count;

	    /* Constructor sections must be rounded to a boundary
	       based on the bitsize.  These are not real sections--
	       they are handled specially by the linker--so the ECOFF
	       16 byte alignment restriction does not apply.  */
	    bitsize = ecoff_backend (abfd)->constructor_bitsize;
	    section->alignment_power = 1;
	    while ((1 << section->alignment_power) < bitsize / 8)
	      ++section->alignment_power;

	    reloc_chain->next = section->constructor_chain;
	    section->constructor_chain = reloc_chain;
	    section->size += bitsize / 8;

#endif /* 0 */

a3127 3
#if 0
  hdr.ar_mode[0] = '0';
#else
a3131 1
#endif
a3292 1
#if 0
d3295 1
a3295 1
		 It's close to impossible to figure out when we can
a3296 3
	      (void) bfd_close (first);
	      bfd_release (abfd, bfd_ardata (abfd));
#endif
@


1.37
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d4700 1
a4700 1
		 (info,
@


1.36
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d3566 1
a3566 1
	    *pundef = (*pundef)->und_next;
d3568 1
a3568 1
	    pundef = &(*pundef)->und_next;
d3578 1
a3578 1
	  pundef = &(*pundef)->und_next;
d3590 1
a3590 1
	  pundef = &(*pundef)->und_next;
d3621 1
a3621 1
	      pundef = &(*pundef)->und_next;
d3643 1
a3643 1
      pundef = &(*pundef)->und_next;
@


1.35
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d95 2
a96 2
  /* entsize, comdat, kept_section, moving_line_filepos,           */
     0,       NULL,   NULL,         0,
@


1.34
log
@	* section.c (struct sec): Remove usused flags.  Reorganize a little.
	(bfd_get_section_size_before_reloc): Delete.
	(bfd_get_section_size_after_reloc): Delete.
	(STD_SECTION): Update.
	(bfd_get_section_size_now): Delete.
	(bfd_set_section_contents): Don't referece reloc_done.
	(bfd_get_section_contents): Remove reloc_done comment.
	* bout.c (b_out_bfd_get_relocated_section_contents): Don't set
	reloc_done.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents): Likewise.
	* ecoff.c (bfd_debug_section): Update initializer.
	* elfxx-mips.c (_bfd_elf_mips_get_relocated_section_contents): Ditto.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* bfd-in.h (bfd_section_size): Expand.
	(bfd_get_section_size): New macro.
	* bfd-in2.h: Regenerate.
	* coff64-rs6000.c (xcoff64_write_object_contents): Replace
	bfd_get_section_size_before_reloc with bfd_get_section_size.
	* coffcode.h (coff_write_object_contents): Likewise.
	* coffgen.c (build_debug_section): Likewise.
	* dwarf1.c (parse_line_table): Likewise.
	(_bfd_dwarf1_find_nearest_line): Likewise.
	* ecoff.c (_bfd_ecoff_write_object_contents): Likewise.
	* i386msdos.c (msdos_write_object_contents): Likewise.
	* pdp11.c (squirt_out_relocs): Likewise.
	* elf32-sh64.c (sh64_find_section_for_address): Remove comment.
	* elf64-mmix.c (mmix_elf_final_link): Update comment.
@
text
@a76 1

d79 2
a80 2
  /* name,   id,  index, next, flags, user_set_vma,                */
  "*DEBUG*", 0,   0,     NULL, 0,     0,
d87 2
a88 2
  /* vma, lma, _cooked_size, _raw_size,                            */
     0,   0,   0,            0,
d908 1
a908 1
	    reloc_chain->relent.address = section->_raw_size;
d928 1
a928 1
	    section->_raw_size += bitsize / 8;
d2118 1
a2118 1
	current->line_filepos = current->_raw_size / 8;
d2179 1
a2179 1
      sofar += current->_raw_size;
d2181 1
a2181 1
	file_sofar += current->_raw_size;
d2188 1
a2188 1
      current->_raw_size += sofar - old_sofar;
d2550 1
a2550 1
      section.s_size = bfd_get_section_size (current);
d2601 1
a2601 1
	  text_size += bfd_get_section_size (current);
d2617 1
a2617 1
	  data_size += bfd_get_section_size (current);
d2626 1
a2626 1
	bss_size += bfd_get_section_size (current);
a4525 2
  bfd_size_type raw_size;
  bfd_size_type cooked_size;
a4529 1
  bfd_size_type amt;
a4538 5
  raw_size = input_section->_raw_size;
  cooked_size = input_section->_cooked_size;
  if (cooked_size == 0)
    cooked_size = raw_size;

d4541 1
a4541 8
  BFD_ASSERT (cooked_size == link_order->size);

  /* Get the section contents.  We allocate memory for the larger of
     the size before relocating and the size after relocating.  */
  amt = raw_size >= cooked_size ? raw_size : cooked_size;
  contents = (bfd_byte *) bfd_malloc (amt);
  if (contents == NULL && amt != 0)
    goto error_return;
d4543 2
a4544 3
  if (! bfd_get_section_contents (input_bfd, input_section,
				  (PTR) contents,
				  (file_ptr) 0, raw_size))
d4570 3
a4572 3
				  (PTR) contents,
				  (file_ptr) input_section->output_offset,
				  cooked_size))
@


1.33
log
@[ bfd/ChangeLog ]
2004-04-23  Chris Demetriou  <cgd@@broadcom.com>

        * coff-mips.c (mips_relhi_reloc, mips_rello_reloc)
        (mips_switch_reloc, mips_read_relocs, mips_relax_section)
        (mips_relax_pcrel16, PCREL16_EXPANSION_ADJUSTMENT): Remove.
        (mips_relocate_hi): Remove now-unused 'adjust' and 'pcrel' arguments,
        and update comments to reflect current usage.
        (mips_howto_table): Remove entries for MIPS_R_RELHI, MIPS_R_RELLO,
        and MIPS_R_SWITCH, as well as several empty entries.  Update comment
        for MIPS_R_PCREL16.
        (mips_ecoff_swap_reloc_in, mips_ecoff_swap_reloc_out)
        (mips_adjust_reloc_out, mips_bfd_reloc_type_lookup): Remove support
        for MIPS_R_SWITCH, MIPS_R_RELLO, and MIPS_R_RELHI relocations.
        (mips_adjust_reloc_in): Likewise, adjust maximum accepted relocation
        type number to be MIPS_R_PCREL16.
        (mips_relocate_section): Remove support for link-time relaxation
        of branches used by embedded-PIC.  Remove support for MIPS_R_SWITCH,
        MIPS_R_RELLO, and MIPS_R_RELHI relocations.
        (_bfd_ecoff_bfd_relax_section): Redefine to bfd_generic_relax_section.
        * ecoff.c (ecoff_indirect_link_order): Remove support for link-time
        relaxation of branches used by embedded-PIC.
        * ecofflink.c (bfd_ecoff_debug_accumulate): Likewise.
        * libecoff.h (struct ecoff_section_tdata): Remove embedded-PIC
        related members, update comment.
        * pe-mips.c: Remove disabled (commented-out and #if 0'd)
        code related to embedded-PIC.
        * elfxx-mips.c (_bfd_mips_elf_read_ecoff_info): Remove
        initialization of now-removed 'adjust' member of
        'struct ecoff_debug_info'.

[ include/coff/ChangeLog ]
2004-04-23  Chris Demetriou  <cgd@@broadcom.com>

        * mips.h (MIPS_R_RELHI, MIPS_R_RELLO, MIPS_R_SWITCH): Remove
        (MIPS_R_PCREL16): Update comment.
        * ecoff.h (struct ecoff_value_adjust): Remove structure.
        (struct ecoff_debug_info): Remove 'adjust' member.
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d80 2
a81 2
  /* name,   id,  index, next, flags, user_set_vma, reloc_done,    */
  "*DEBUG*", 0,   0,     NULL, 0,     0,            0,
d84 3
a86 3
  /* sec_info_type, use_rela_p, has_tls_reloc,                     */
     0,		    0,		0,
  /* need_finalize_relax, has_gp_reloc,                            */
a87 2
  /* flag13, flag14, flag15, flag16, flag20, flag24,               */
     0,      0,      0,      0,      0,	     0,
d2551 1
a2551 1
      section.s_size = bfd_get_section_size_before_reloc (current);
d2602 1
a2602 1
	  text_size += bfd_get_section_size_before_reloc (current);
d2618 1
a2618 1
	  data_size += bfd_get_section_size_before_reloc (current);
d2627 1
a2627 1
	bss_size += bfd_get_section_size_before_reloc (current);
@


1.32
log
@Rename bfd_link_hash_entry field "next" -> "und_next".
@
text
@a4528 1
  struct ecoff_section_tdata *section_tdata;
a4543 1
  section_tdata = ecoff_section_data (input_bfd, input_section);
d4561 4
a4564 13
  /* If we are relaxing, the contents may have already been read into
     memory, in which case we copy them into our new buffer.  We don't
     simply reuse the old buffer in case cooked_size > raw_size.  */
  if (section_tdata != (struct ecoff_section_tdata *) NULL
      && section_tdata->contents != (bfd_byte *) NULL)
    memcpy (contents, section_tdata->contents, (size_t) raw_size);
  else
    {
      if (! bfd_get_section_contents (input_bfd, input_section,
				      (PTR) contents,
				      (file_ptr) 0, raw_size))
	goto error_return;
    }
d4571 3
a4573 8
  if (section_tdata != (struct ecoff_section_tdata *) NULL
      && section_tdata->external_relocs != NULL)
    external_relocs = section_tdata->external_relocs;
  else
    {
      external_relocs = (PTR) bfd_malloc (external_relocs_size);
      if (external_relocs == NULL && external_relocs_size != 0)
	goto error_return;
d4575 4
a4578 5
      if (bfd_seek (input_bfd, input_section->rel_filepos, SEEK_SET) != 0
	  || (bfd_bread (external_relocs, external_relocs_size, input_bfd)
	      != external_relocs_size))
	goto error_return;
    }
d4611 1
a4611 1
  if (external_relocs != NULL && section_tdata == NULL)
d4618 1
a4618 1
  if (external_relocs != NULL && section_tdata == NULL)
@


1.32.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d77 1
d80 2
a81 2
  /* name,      id,  index, next, flags, user_set_vma,             */
     "*DEBUG*", 0,   0,     NULL, 0,     0,
d84 3
a86 3
  /* sec_info_type, use_rela_p, has_tls_reloc, has_gp_reloc,       */
     0,		    0,		0,	       0,
  /* need_finalize_relax, reloc_done,                              */
d88 4
a91 2
  /* vma, lma, size, rawsize,                                      */
     0,   0,   0,    0,
d98 2
a99 2
  /* entsize, kept_section, moving_line_filepos,	           */
     0,       NULL,         0,
d911 1
a911 1
	    reloc_chain->relent.address = section->size;
d931 1
a931 1
	    section->size += bitsize / 8;
d2121 1
a2121 1
	current->line_filepos = current->size / 8;
d2182 1
a2182 1
      sofar += current->size;
d2184 1
a2184 1
	file_sofar += current->size;
d2191 1
a2191 1
      current->size += sofar - old_sofar;
d2553 1
a2553 1
      section.s_size = current->size;
d2604 1
a2604 1
	  text_size += current->size;
d2620 1
a2620 1
	  data_size += current->size;
d2629 1
a2629 1
	bss_size += current->size;
d4529 3
d4536 1
d4545 6
d4554 1
a4554 1
  BFD_ASSERT (input_section->size == link_order->size);
d4556 5
a4560 2
  /* Get the section contents.  */
  if (!bfd_malloc_and_get_section (input_bfd, input_section, &contents))
d4563 14
d4582 8
a4589 3
  external_relocs = (PTR) bfd_malloc (external_relocs_size);
  if (external_relocs == NULL && external_relocs_size != 0)
    goto error_return;
d4591 5
a4595 4
  if (bfd_seek (input_bfd, input_section->rel_filepos, SEEK_SET) != 0
      || (bfd_bread (external_relocs, external_relocs_size, input_bfd)
	  != external_relocs_size))
    goto error_return;
d4606 3
a4608 3
				  contents,
				  input_section->output_offset,
				  input_section->size))
d4628 1
a4628 1
  if (external_relocs != NULL)
d4635 1
a4635 1
  if (external_relocs != NULL)
@


1.32.8.2
log
@Merge from mainline.
@
text
@d3566 1
a3566 1
	    *pundef = (*pundef)->u.undef.next;
d3568 1
a3568 1
	    pundef = &(*pundef)->u.undef.next;
d3578 1
a3578 1
	  pundef = &(*pundef)->u.undef.next;
d3590 1
a3590 1
	  pundef = &(*pundef)->u.undef.next;
d3621 1
a3621 1
	      pundef = &(*pundef)->u.undef.next;
d3643 1
a3643 1
      pundef = &(*pundef)->u.undef.next;
@


1.31
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d3569 1
a3569 1
	    *pundef = (*pundef)->next;
d3571 1
a3571 1
	    pundef = &(*pundef)->next;
d3581 1
a3581 1
	  pundef = &(*pundef)->next;
d3593 1
a3593 1
	  pundef = &(*pundef)->next;
d3624 1
a3624 1
	      pundef = &(*pundef)->next;
d3646 1
a3646 1
      pundef = &(*pundef)->next;
@


1.30
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d4132 1
a4132 1
	  /* Abitrarily set the symbolic header vstamp to the vstamp
@


1.29
log
@Index: sim/frv/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* traps.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/d10v/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* simops.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/common/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* sim-trace.c, sim-base.h: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: ld/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* emultempl/pe.em, pe-dll.c: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: bfd/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* syms.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".
	* vms.h, targets.c, section.c, reloc.c, peicode.h: Ditto.
	* mipsbsd.c, elf.c, linker.c, elf-bfd.h, ecoff.c: Ditto.
	* cpu-z8k.c, cpu-ns32k.c, cpu-h8500.c, bfd.c, bfd-in.h: Ditto.
	* bfd-in2.h: Re-generate.
@
text
@d2265 1
a2265 1
     PTR location;
@


1.28
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d103 1
a103 1
     (struct symbol_cache_entry *) NULL,
d105 1
a105 1
     (struct symbol_cache_entry **) NULL,
@


1.27
log
@Convert to C90 and a few tweaks.
@
text
@d1065 1
a1065 1
_bfd_ecoff_get_symtab (abfd, alocation)
@


1.26
log
@Correct spelling of "relocatable".
@
text
@d98 2
a99 2
  /* entsize, comdat, moving_line_filepos,                         */
     0,       NULL,   0,
@


1.25
log
@	* elf64-ppc.c: Move TARGET_LITTLE_SYM and other macros used by
	elfxx-target.h so that we can use elf_backend_got_header_size.
	(ELF_MACHINE_ALT1, ELF_MACHINE_ALT2): Delete.
	(GLINK_CALL_STUB_SIZE): Modify.  Define new glink call stub and
	associated macros.
	(ppc64_elf_howto_raw <GOT_TPREL16_DS, GOT_TPREL16_LO_DS>): Correct
	dst_mask.
	(enum ppc_stub_type): Add ppc_stub_long_branch_r2off and
	ppc_stub_plt_branch_r2off.
	(struct ppc_stub_hash_entry): Reorganize.
	(struct ppc_link_hash_table): Add no_multi_toc, multi_toc_needed,
	toc_curr, toc_off and emit_stub_syms.
	(ppc64_elf_link_hash_table_create): Init them.
	(ppc_stub_name): Correct string size.
	(ppc64_elf_check_relocs): Set has_gp_reloc on GOT and TOC relocs.
	(ppc64_elf_size_dynamic_sections): Set no_multi_toc if GOT entries
	used.
	(ppc_type_of_stub): Tweak root.type test.
	(build_plt_stub): Remove glink code.  Adjust for insn macro changes.
	(ppc_size_one_stub): Handle ppc_stub_long_branch_r2off and
	ppc_stub_plt_branch_r2off.
	(ppc_build_one_stub): Likewise.  Fix var shadowing.  Correct addis,addi
	range test.  Use toc_off to calculte r2 values.  Handle emit_stub_syms.
	(ppc64_elf_setup_section_lists): Remove htab creator flavour test.
	Initialize elf_gp and toc_curr.
	(ppc64_elf_next_toc_section, ppc64_elf_reinit_toc): New functions.
	(ppc64_elf_next_input_section): Set toc_off.
	(group_sections): Ensure groups have the same TOC.
	(ppc64_elf_size_stubs): Check whether we need a TOC adjusting stub.
	(ppc64_elf_build_stubs): Add emit_stub_syms param, and stash in htab.
	Build new glink stub.
	(ppc64_elf_relocate_section): Handle multiple TOCs.  Fix comments.
	(ppc64_elf_finish_dynamic_sections): Adjust DT_PPC64_GLINK.
	* elf64-ppc.h (ppc64_elf_build_stubs): Update prototype.
	(ppc64_elf_next_toc_section, ppc64_elf_reinit_toc): Declare.
	* section.c (struct sec): Rename flag12 to has_gp_reloc.
	(STD_SECTION): Update.
	* ecoff.c (bfd_debug_section): Update comment.
	* bfd-in2.h: Regenerate.
@
text
@d4163 1
a4163 1
  if (info->relocateable)
d4193 1
a4193 1
  if (info->relocateable)
d4213 1
a4213 1
      else if (info->relocateable)
d4611 1
a4611 1
  /* If we are producing relocateable output, the relocs were
d4615 1
a4615 1
  if (info->relocateable)
@


1.24
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d84 4
a87 2
  /* sec_info_type, use_rela_p, has_tls_reloc, flag11, flag12,     */
     0,		    0,		0,	       0,      0,
@


1.23
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
d84 4
@


1.22
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d49 26
a74 13
static int ecoff_get_magic PARAMS ((bfd *));
static long ecoff_sec_to_styp_flags PARAMS ((const char *, flagword));
static boolean ecoff_slurp_symbolic_header PARAMS ((bfd *));
static boolean ecoff_set_symbol_info PARAMS ((bfd *, SYMR *, asymbol *, int, int));
static void ecoff_emit_aggregate PARAMS ((bfd *, FDR *, char *, RNDXR *, long, const char *));
static char *ecoff_type_to_string PARAMS ((bfd *, FDR *, unsigned int));
static boolean ecoff_slurp_reloc_table PARAMS ((bfd *, asection *, asymbol **));
static int ecoff_sort_hdrs PARAMS ((const PTR, const PTR));
static boolean ecoff_compute_section_file_positions PARAMS ((bfd *));
static bfd_size_type ecoff_compute_reloc_file_positions PARAMS ((bfd *));
static boolean ecoff_get_extr PARAMS ((asymbol *, EXTR *));
static void ecoff_set_index PARAMS ((asymbol *, bfd_size_type));
static unsigned int ecoff_armap_hash PARAMS ((const char *, unsigned int *, unsigned int, unsigned int));
d106 1
a106 1
boolean
d114 1
a114 1
    return false;
d116 1
a116 1
  return true;
d167 1
a167 1
boolean
d198 1
a198 1
  return true;
d206 1
a206 1
boolean
d376 1
a376 1
boolean
d441 1
a441 1
  return true;
d446 1
a446 1
static boolean
d458 1
a458 1
    return true;
d464 1
a464 1
      return true;
d475 1
a475 1
      return false;
d501 1
a501 1
  return true;
d505 1
a505 1
  return false;
d512 1
a512 1
boolean
d537 1
a537 1
    return true;
d541 1
a541 1
      return true;
d545 1
a545 1
    return false;
d585 1
a585 1
      return true;
d589 1
a589 1
    return false;
d597 1
a597 1
      return false;
d636 1
a636 1
    return false;
d644 1
a644 1
  return true;
d673 1
a673 1
  new->local = false;
d681 1
a681 1
static boolean
d707 1
a707 1
	  return true;
d712 1
a712 1
      return true;
d893 1
a893 1
		  return false;
d902 1
a902 1
	      return false;
d935 1
a935 1
  return true;
d940 1
a940 1
boolean
d963 1
a963 1
    return true;
d968 1
a968 1
    return false;
d970 1
a970 1
    return true;
d976 1
a976 1
    return false;
d993 1
a993 1
	return false;
d1000 1
a1000 1
      internal_ptr->local = false;
d1028 1
a1028 1
	    return false;
d1030 1
a1030 1
	  internal_ptr->local = true;
d1037 1
a1037 1
  return true;
d1459 1
a1459 1
boolean
d1658 1
a1658 1
static boolean
d1675 1
a1675 1
    return true;
d1678 1
a1678 1
    return false;
d1689 1
a1689 1
    return false;
d1691 1
a1691 1
    return false;
d1693 1
a1693 1
    return false;
d1763 1
a1763 1
  return true;
d1811 1
a1811 1
boolean
d1830 1
a1830 1
    return false;
d1838 1
a1838 1
	return false;
d1860 1
a1860 1
boolean
d1870 1
a1870 1
  boolean local;
d1876 1
a1876 1
    return true;
d1892 1
a1892 1
    return true;
d1895 1
a1895 1
  local = false;
d1900 1
a1900 1
	  local = true;
d1963 1
a1963 1
  return true;
d1970 1
a1970 1
boolean
d1985 1
a1985 1
     boolean reloc ATTRIBUTE_UNUSED;
d2005 1
a2005 1
boolean
d2049 1
a2049 1
static boolean
d2058 2
a2059 2
  boolean rdata_in_text;
  boolean first_data, first_nonalloc;
d2063 1
a2063 1
  sofar = _bfd_ecoff_sizeof_headers (abfd, false);
d2071 1
a2071 1
    return false;
d2095 1
a2095 1
	      rdata_in_text = false;
d2102 2
a2103 2
  first_data = true;
  first_nonalloc = true;
d2136 1
a2136 1
	  first_data = false;
d2154 1
a2154 1
	  first_nonalloc = false;
d2193 1
a2193 1
  return true;
d2215 1
a2215 1
      abfd->output_has_begun = true;
d2255 1
a2255 1
boolean
d2266 1
a2266 1
     going to set output_has_begun to true.  */
d2270 1
a2270 1
	return false;
d2291 1
a2291 1
    return true;
d2296 1
a2296 1
    return false;
d2298 1
a2298 1
  return true;
d2321 1
a2321 1
boolean
d2330 1
a2330 1
      return false;
d2335 1
a2335 1
  return true;
d2341 1
a2341 1
boolean
d2354 1
a2354 1
      return false;
d2368 1
a2368 1
  return true;
d2374 1
a2374 1
static boolean
d2389 1
a2389 1
	return false;
d2401 1
a2401 1
      return true;
d2407 1
a2407 1
    return false;
d2433 1
a2433 1
  return true;
d2449 1
a2449 1
boolean
d2461 2
a2462 3
  void (* const adjust_reloc_out) PARAMS ((bfd *,
					   const arelent *,
					   struct internal_reloc *))
d2464 2
a2465 3
  void (* const swap_reloc_out) PARAMS ((bfd *,
					 const struct internal_reloc *,
					 PTR))
d2474 1
a2474 1
  boolean set_text_start;
d2477 1
a2477 1
  boolean set_data_start;
d2499 1
a2499 1
    text_size = _bfd_ecoff_sizeof_headers (abfd, false);
d2503 1
a2503 1
  set_text_start = false;
d2506 1
a2506 1
  set_data_start = false;
d2602 1
a2602 1
	      set_text_start = true;
d2618 1
a2618 1
	      set_data_start = true;
d2884 1
a2884 1
  return true;
d2890 1
a2890 1
  return false;
d2963 1
a2963 1
boolean
d2982 1
a2982 1
      return true;
d2984 1
a2984 1
      return false;
d2987 1
a2987 1
    return false;
d3009 2
a3010 2
      bfd_has_map (abfd) = false;
      return true;
d3020 1
a3020 1
      return false;
d3027 1
a3027 1
    return false;
d3033 1
a3033 1
    return false;
d3040 1
a3040 1
      return false;
d3100 1
a3100 1
    return false;
d3122 1
a3122 1
  bfd_has_map (abfd) = true;
d3124 1
a3124 1
  return true;
d3129 1
a3129 1
boolean
d3213 1
a3213 1
    return false;
d3217 1
a3217 1
    return false;
d3221 1
a3221 1
    return false;
d3266 1
a3266 1
    return false;
d3273 1
a3273 1
    return false;
d3280 1
a3280 1
	return false;
d3288 1
a3288 1
	return false;
d3291 1
a3291 1
  return true;
d3357 1
a3357 1
	  first->target_defaulted = false;
d3386 1
a3386 1
static boolean ecoff_link_add_archive_symbols
d3388 3
a3390 3
static boolean ecoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, boolean *pneeded));
static boolean ecoff_link_add_object_symbols
d3392 1
a3392 1
static boolean ecoff_link_add_externals
d3463 1
a3463 1
    (boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func),	\
d3474 1
a3474 1
boolean
d3487 1
a3487 1
      return false;
d3498 1
a3498 1
static boolean
d3516 1
a3516 1
	return true;
d3518 1
a3518 1
      return false;
d3596 1
a3596 1
	  boolean found;
d3599 1
a3599 1
	  found = false;
d3611 1
a3611 1
		  found = true;
d3627 1
a3627 1
	return false;
d3630 1
a3630 1
	return false;
d3636 1
a3636 1
	return false;
d3638 1
a3638 1
	return false;
d3643 1
a3643 1
  return true;
d3649 1
a3649 1
static boolean
d3653 1
a3653 1
     boolean *pneeded;
d3666 1
a3666 1
  *pneeded = false;
d3704 1
a3704 1
      boolean def;
d3730 1
a3730 1
	  def = true;
d3733 1
a3733 1
	  def = false;
d3741 1
a3741 1
      h = bfd_link_hash_lookup (info->hash, name, false, false, true);
d3755 1
a3755 1
      *pneeded = true;
d3764 1
a3764 1
  return true;
d3770 1
a3770 1
  return false;
d3776 1
a3776 1
static boolean
d3786 1
a3786 1
  boolean result;
d3789 1
a3789 1
    return false;
d3793 1
a3793 1
    return true;
d3830 1
a3830 1
  return false;
d3839 1
a3839 1
static boolean
d3862 1
a3862 1
    return false;
d3870 1
a3870 1
      boolean skip;
d3881 1
a3881 1
      skip = false;
d3891 1
a3891 1
	  skip = true;
d3997 2
a3998 2
	      section, value, (const char *) NULL, true, true, sym_hash)))
	return false;
d4038 1
a4038 1
  return true;
d4043 1
a4043 1
static boolean ecoff_final_link_debug_accumulate
d4046 1
a4046 1
static boolean ecoff_link_write_external
d4048 1
a4048 1
static boolean ecoff_indirect_link_order
d4051 1
a4051 1
static boolean ecoff_reloc_link_order
d4068 1
a4068 1
boolean
d4115 1
a4115 1
    return false;
d4122 1
a4122 1
      boolean ret;
d4139 1
a4139 1
	return false;
d4183 1
a4183 1
    return false;
d4201 1
a4201 1
      h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
d4244 1
a4244 1
		return false;
d4250 1
a4250 1
		return false;
d4255 1
a4255 1
		return false;
d4262 1
a4262 1
  ecoff_data (abfd)->linker = true;
d4264 1
a4264 1
  return true;
d4271 1
a4271 1
static boolean
d4282 1
a4282 1
  boolean ret;
d4293 1
a4293 1
          ret = false;							 \
d4299 1
a4299 1
          ret = false;							 \
d4370 1
a4370 1
static boolean
d4377 1
a4377 1
  boolean strip;
d4383 1
a4383 1
	return true;
d4389 1
a4389 1
    strip = false;
d4394 2
a4395 2
				   false, false) == NULL))
    strip = true;
d4397 1
a4397 1
    strip = false;
d4400 1
a4400 1
    return true;
d4498 1
a4498 1
      return true;
d4514 1
a4514 1
static boolean
d4535 1
a4535 1
    return true;
d4624 1
a4624 1
  return true;
d4631 1
a4631 1
  return false;
d4639 1
a4639 1
static boolean
d4653 1
a4653 1
  boolean ok;
d4668 1
a4668 1
      return false;
d4684 1
a4684 1
					false, false, false);
d4718 1
a4718 1
	return false;
d4738 1
a4738 1
	      return false;
d4746 1
a4746 1
	return false;
d4763 1
a4763 1
					 false, false, true));
d4772 1
a4772 1
	    return false;
d4824 1
a4824 1
    return false;
@


1.21
log
@Fix error reading ECOFF information: 'ioptMax' refers to the actual *size*
of the optimization symtab, not the number of entries.
@
text
@d3840 1
a3840 1
  struct ecoff_link_hash_entry **sym_hash;
d3849 1
a3849 1
  sym_hash = (struct ecoff_link_hash_entry **) bfd_alloc (abfd, amt);
d3852 1
a3852 1
  ecoff_data (abfd)->sym_hashes = sym_hash;
a3982 1
      h = NULL;
d3986 1
a3986 2
	      section, value, (const char *) NULL, true, true,
	      (struct bfd_link_hash_entry **) &h)))
d3989 1
a3989 1
      *sym_hash = h;
@


1.21.4.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d3840 1
a3840 1
  struct bfd_link_hash_entry **sym_hash;
d3849 1
a3849 1
  sym_hash = (struct bfd_link_hash_entry **) bfd_alloc (abfd, amt);
d3852 1
a3852 1
  ecoff_data (abfd)->sym_hashes = (struct ecoff_link_hash_entry **) sym_hash;
d3983 1
d3987 2
a3988 1
	      section, value, (const char *) NULL, true, true, sym_hash)))
d3991 1
a3991 1
      h = (struct ecoff_link_hash_entry *) *sym_hash;
@


1.21.4.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.
d49 13
a61 26
static int ecoff_get_magic
  PARAMS ((bfd *));
static long ecoff_sec_to_styp_flags
  PARAMS ((const char *, flagword));
static bfd_boolean ecoff_slurp_symbolic_header
  PARAMS ((bfd *));
static bfd_boolean ecoff_set_symbol_info
  PARAMS ((bfd *, SYMR *, asymbol *, int, int));
static void ecoff_emit_aggregate
  PARAMS ((bfd *, FDR *, char *, RNDXR *, long, const char *));
static char *ecoff_type_to_string
  PARAMS ((bfd *, FDR *, unsigned int));
static bfd_boolean ecoff_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **));
static int ecoff_sort_hdrs
  PARAMS ((const PTR, const PTR));
static bfd_boolean ecoff_compute_section_file_positions
  PARAMS ((bfd *));
static bfd_size_type ecoff_compute_reloc_file_positions
  PARAMS ((bfd *));
static bfd_boolean ecoff_get_extr
  PARAMS ((asymbol *, EXTR *));
static void ecoff_set_index
  PARAMS ((asymbol *, bfd_size_type));
static unsigned int ecoff_armap_hash
  PARAMS ((const char *, unsigned int *, unsigned int, unsigned int));
a70 6
  /* sec_info_type, use_rela_p, has_tls_reloc,                     */
     0,		    0,		0,
  /* need_finalize_relax, has_gp_reloc,                            */
     0,			  0,
  /* flag13, flag14, flag15, flag16, flag20, flag24,               */
     0,      0,      0,      0,      0,	     0,
d79 2
a80 2
  /* entsize, comdat, kept_section, moving_line_filepos,           */
     0,       NULL,   NULL,         0,
d84 1
a84 1
     (struct bfd_symbol *) NULL,
d86 1
a86 1
     (struct bfd_symbol **) NULL,
d93 1
a93 1
bfd_boolean
d101 1
a101 1
    return FALSE;
d103 1
a103 1
  return TRUE;
d154 1
a154 1
bfd_boolean
d185 1
a185 1
  return TRUE;
d193 1
a193 1
bfd_boolean
d363 1
a363 1
bfd_boolean
d428 1
a428 1
  return TRUE;
d433 1
a433 1
static bfd_boolean
d445 1
a445 1
    return TRUE;
d451 1
a451 1
      return TRUE;
d462 1
a462 1
      return FALSE;
d488 1
a488 1
  return TRUE;
d492 1
a492 1
  return FALSE;
d499 1
a499 1
bfd_boolean
d524 1
a524 1
    return TRUE;
d528 1
a528 1
      return TRUE;
d532 1
a532 1
    return FALSE;
d572 1
a572 1
      return TRUE;
d576 1
a576 1
    return FALSE;
d584 1
a584 1
      return FALSE;
d623 1
a623 1
    return FALSE;
d631 1
a631 1
  return TRUE;
d660 1
a660 1
  new->local = FALSE;
d668 1
a668 1
static bfd_boolean
d694 1
a694 1
	  return TRUE;
d699 1
a699 1
      return TRUE;
d880 1
a880 1
		  return FALSE;
d889 1
a889 1
	      return FALSE;
d922 1
a922 1
  return TRUE;
d927 1
a927 1
bfd_boolean
d950 1
a950 1
    return TRUE;
d955 1
a955 1
    return FALSE;
d957 1
a957 1
    return TRUE;
d963 1
a963 1
    return FALSE;
d980 1
a980 1
	return FALSE;
d987 1
a987 1
      internal_ptr->local = FALSE;
d1015 1
a1015 1
	    return FALSE;
d1017 1
a1017 1
	  internal_ptr->local = TRUE;
d1024 1
a1024 1
  return TRUE;
d1046 1
a1046 1
_bfd_ecoff_canonicalize_symtab (abfd, alocation)
d1446 1
a1446 1
bfd_boolean
d1645 1
a1645 1
static bfd_boolean
d1662 1
a1662 1
    return TRUE;
d1665 1
a1665 1
    return FALSE;
d1676 1
a1676 1
    return FALSE;
d1678 1
a1678 1
    return FALSE;
d1680 1
a1680 1
    return FALSE;
d1750 1
a1750 1
  return TRUE;
d1798 1
a1798 1
bfd_boolean
d1817 1
a1817 1
    return FALSE;
d1825 1
a1825 1
	return FALSE;
d1847 1
a1847 1
bfd_boolean
d1857 1
a1857 1
  bfd_boolean local;
d1863 1
a1863 1
    return TRUE;
d1879 1
a1879 1
    return TRUE;
d1882 1
a1882 1
  local = FALSE;
d1887 1
a1887 1
	  local = TRUE;
d1950 1
a1950 1
  return TRUE;
d1957 1
a1957 1
bfd_boolean
d1972 1
a1972 1
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d1992 1
a1992 1
bfd_boolean
d2036 1
a2036 1
static bfd_boolean
d2045 2
a2046 2
  bfd_boolean rdata_in_text;
  bfd_boolean first_data, first_nonalloc;
d2050 1
a2050 1
  sofar = _bfd_ecoff_sizeof_headers (abfd, FALSE);
d2058 1
a2058 1
    return FALSE;
d2082 1
a2082 1
	      rdata_in_text = FALSE;
d2089 2
a2090 2
  first_data = TRUE;
  first_nonalloc = TRUE;
d2123 1
a2123 1
	  first_data = FALSE;
d2141 1
a2141 1
	  first_nonalloc = FALSE;
d2180 1
a2180 1
  return TRUE;
d2202 1
a2202 1
      abfd->output_has_begun = TRUE;
d2242 1
a2242 1
bfd_boolean
d2246 1
a2246 1
     const PTR location;
d2253 1
a2253 1
     going to set output_has_begun to TRUE.  */
d2257 1
a2257 1
	return FALSE;
d2278 1
a2278 1
    return TRUE;
d2283 1
a2283 1
    return FALSE;
d2285 1
a2285 1
  return TRUE;
d2308 1
a2308 1
bfd_boolean
d2317 1
a2317 1
      return FALSE;
d2322 1
a2322 1
  return TRUE;
d2328 1
a2328 1
bfd_boolean
d2341 1
a2341 1
      return FALSE;
d2355 1
a2355 1
  return TRUE;
d2361 1
a2361 1
static bfd_boolean
d2376 1
a2376 1
	return FALSE;
d2388 1
a2388 1
      return TRUE;
d2394 1
a2394 1
    return FALSE;
d2420 1
a2420 1
  return TRUE;
d2436 1
a2436 1
bfd_boolean
d2448 3
a2450 2
  void (* const adjust_reloc_out)
  PARAMS ((bfd *, const arelent *, struct internal_reloc *))
d2452 3
a2454 2
  void (* const swap_reloc_out)
  PARAMS ((bfd *, const struct internal_reloc *, PTR))
d2463 1
a2463 1
  bfd_boolean set_text_start;
d2466 1
a2466 1
  bfd_boolean set_data_start;
d2488 1
a2488 1
    text_size = _bfd_ecoff_sizeof_headers (abfd, FALSE);
d2492 1
a2492 1
  set_text_start = FALSE;
d2495 1
a2495 1
  set_data_start = FALSE;
d2591 1
a2591 1
	      set_text_start = TRUE;
d2607 1
a2607 1
	      set_data_start = TRUE;
d2873 1
a2873 1
  return TRUE;
d2879 1
a2879 1
  return FALSE;
d2952 1
a2952 1
bfd_boolean
d2971 1
a2971 1
      return TRUE;
d2973 1
a2973 1
      return FALSE;
d2976 1
a2976 1
    return FALSE;
d2998 2
a2999 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d3009 1
a3009 1
      return FALSE;
d3016 1
a3016 1
    return FALSE;
d3022 1
a3022 1
    return FALSE;
d3029 1
a3029 1
      return FALSE;
d3089 1
a3089 1
    return FALSE;
d3111 1
a3111 1
  bfd_has_map (abfd) = TRUE;
d3113 1
a3113 1
  return TRUE;
d3118 1
a3118 1
bfd_boolean
d3202 1
a3202 1
    return FALSE;
d3206 1
a3206 1
    return FALSE;
d3210 1
a3210 1
    return FALSE;
d3255 1
a3255 1
    return FALSE;
d3262 1
a3262 1
    return FALSE;
d3269 1
a3269 1
	return FALSE;
d3277 1
a3277 1
	return FALSE;
d3280 1
a3280 1
  return TRUE;
d3346 1
a3346 1
	  first->target_defaulted = FALSE;
d3375 1
a3375 1
static bfd_boolean ecoff_link_add_archive_symbols
d3377 3
a3379 3
static bfd_boolean ecoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
static bfd_boolean ecoff_link_add_object_symbols
d3381 1
a3381 1
static bfd_boolean ecoff_link_add_externals
d3452 1
a3452 1
    (bfd_boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func), \
d3463 1
a3463 1
bfd_boolean
d3476 1
a3476 1
      return FALSE;
d3487 1
a3487 1
static bfd_boolean
d3505 1
a3505 1
	return TRUE;
d3507 1
a3507 1
      return FALSE;
d3552 1
a3552 1
	    *pundef = (*pundef)->und_next;
d3554 1
a3554 1
	    pundef = &(*pundef)->und_next;
d3564 1
a3564 1
	  pundef = &(*pundef)->und_next;
d3576 1
a3576 1
	  pundef = &(*pundef)->und_next;
d3585 1
a3585 1
	  bfd_boolean found;
d3588 1
a3588 1
	  found = FALSE;
d3600 1
a3600 1
		  found = TRUE;
d3607 1
a3607 1
	      pundef = &(*pundef)->und_next;
d3616 1
a3616 1
	return FALSE;
d3619 1
a3619 1
	return FALSE;
d3625 1
a3625 1
	return FALSE;
d3627 1
a3627 1
	return FALSE;
d3629 1
a3629 1
      pundef = &(*pundef)->und_next;
d3632 1
a3632 1
  return TRUE;
d3638 1
a3638 1
static bfd_boolean
d3642 1
a3642 1
     bfd_boolean *pneeded;
d3655 1
a3655 1
  *pneeded = FALSE;
d3693 1
a3693 1
      bfd_boolean def;
d3719 1
a3719 1
	  def = TRUE;
d3722 1
a3722 1
	  def = FALSE;
d3730 1
a3730 1
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d3744 1
a3744 1
      *pneeded = TRUE;
d3753 1
a3753 1
  return TRUE;
d3759 1
a3759 1
  return FALSE;
d3765 1
a3765 1
static bfd_boolean
d3775 1
a3775 1
  bfd_boolean result;
d3778 1
a3778 1
    return FALSE;
d3782 1
a3782 1
    return TRUE;
d3819 1
a3819 1
  return FALSE;
d3828 1
a3828 1
static bfd_boolean
d3851 1
a3851 1
    return FALSE;
d3859 1
a3859 1
      bfd_boolean skip;
d3870 1
a3870 1
      skip = FALSE;
d3880 1
a3880 1
	  skip = TRUE;
d3986 2
a3987 2
	      section, value, (const char *) NULL, TRUE, TRUE, sym_hash)))
	return FALSE;
d4027 1
a4027 1
  return TRUE;
d4032 1
a4032 1
static bfd_boolean ecoff_final_link_debug_accumulate
d4035 1
a4035 1
static bfd_boolean ecoff_link_write_external
d4037 1
a4037 1
static bfd_boolean ecoff_indirect_link_order
d4040 1
a4040 1
static bfd_boolean ecoff_reloc_link_order
d4057 1
a4057 1
bfd_boolean
d4104 1
a4104 1
    return FALSE;
d4111 1
a4111 1
      bfd_boolean ret;
d4115 1
a4115 1
	  /* Arbitrarily set the symbolic header vstamp to the vstamp
d4128 1
a4128 1
	return FALSE;
d4146 1
a4146 1
  if (info->relocatable)
d4172 1
a4172 1
    return FALSE;
d4176 1
a4176 1
  if (info->relocatable)
d4190 1
a4190 1
      h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d4196 1
a4196 1
      else if (info->relocatable)
d4233 1
a4233 1
		return FALSE;
d4239 1
a4239 1
		return FALSE;
d4244 1
a4244 1
		return FALSE;
d4251 1
a4251 1
  ecoff_data (abfd)->linker = TRUE;
d4253 1
a4253 1
  return TRUE;
d4260 1
a4260 1
static bfd_boolean
d4271 1
a4271 1
  bfd_boolean ret;
d4282 1
a4282 1
          ret = FALSE;							 \
d4288 1
a4288 1
          ret = FALSE;							 \
d4359 1
a4359 1
static bfd_boolean
d4366 1
a4366 1
  bfd_boolean strip;
d4372 1
a4372 1
	return TRUE;
d4378 1
a4378 1
    strip = FALSE;
d4383 2
a4384 2
				   FALSE, FALSE) == NULL))
    strip = TRUE;
d4386 1
a4386 1
    strip = FALSE;
d4389 1
a4389 1
    return TRUE;
d4487 1
a4487 1
      return TRUE;
d4503 1
a4503 1
static bfd_boolean
d4524 1
a4524 1
    return TRUE;
d4594 1
a4594 1
  /* If we are producing relocatable output, the relocs were
d4598 1
a4598 1
  if (info->relocatable)
d4613 1
a4613 1
  return TRUE;
d4620 1
a4620 1
  return FALSE;
d4628 1
a4628 1
static bfd_boolean
d4642 1
a4642 1
  bfd_boolean ok;
d4657 1
a4657 1
      return FALSE;
d4673 1
a4673 1
					FALSE, FALSE, FALSE);
d4707 1
a4707 1
	return FALSE;
d4727 1
a4727 1
	      return FALSE;
d4735 1
a4735 1
	return FALSE;
d4752 1
a4752 1
					 FALSE, FALSE, TRUE));
d4761 1
a4761 1
	    return FALSE;
d4813 1
a4813 1
    return FALSE;
@


1.21.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d3840 1
a3840 1
  struct bfd_link_hash_entry **sym_hash;
d3849 1
a3849 1
  sym_hash = (struct bfd_link_hash_entry **) bfd_alloc (abfd, amt);
d3852 1
a3852 1
  ecoff_data (abfd)->sym_hashes = (struct ecoff_link_hash_entry **) sym_hash;
d3983 1
d3987 2
a3988 1
	      section, value, (const char *) NULL, true, true, sym_hash)))
d3991 1
a3991 1
      h = (struct ecoff_link_hash_entry *) *sym_hash;
@


1.21.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d49 13
a61 26
static int ecoff_get_magic
  PARAMS ((bfd *));
static long ecoff_sec_to_styp_flags
  PARAMS ((const char *, flagword));
static bfd_boolean ecoff_slurp_symbolic_header
  PARAMS ((bfd *));
static bfd_boolean ecoff_set_symbol_info
  PARAMS ((bfd *, SYMR *, asymbol *, int, int));
static void ecoff_emit_aggregate
  PARAMS ((bfd *, FDR *, char *, RNDXR *, long, const char *));
static char *ecoff_type_to_string
  PARAMS ((bfd *, FDR *, unsigned int));
static bfd_boolean ecoff_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **));
static int ecoff_sort_hdrs
  PARAMS ((const PTR, const PTR));
static bfd_boolean ecoff_compute_section_file_positions
  PARAMS ((bfd *));
static bfd_size_type ecoff_compute_reloc_file_positions
  PARAMS ((bfd *));
static bfd_boolean ecoff_get_extr
  PARAMS ((asymbol *, EXTR *));
static void ecoff_set_index
  PARAMS ((asymbol *, bfd_size_type));
static unsigned int ecoff_armap_hash
  PARAMS ((const char *, unsigned int *, unsigned int, unsigned int));
d93 1
a93 1
bfd_boolean
d101 1
a101 1
    return FALSE;
d103 1
a103 1
  return TRUE;
d154 1
a154 1
bfd_boolean
d185 1
a185 1
  return TRUE;
d193 1
a193 1
bfd_boolean
d363 1
a363 1
bfd_boolean
d428 1
a428 1
  return TRUE;
d433 1
a433 1
static bfd_boolean
d445 1
a445 1
    return TRUE;
d451 1
a451 1
      return TRUE;
d462 1
a462 1
      return FALSE;
d488 1
a488 1
  return TRUE;
d492 1
a492 1
  return FALSE;
d499 1
a499 1
bfd_boolean
d524 1
a524 1
    return TRUE;
d528 1
a528 1
      return TRUE;
d532 1
a532 1
    return FALSE;
d572 1
a572 1
      return TRUE;
d576 1
a576 1
    return FALSE;
d584 1
a584 1
      return FALSE;
d623 1
a623 1
    return FALSE;
d631 1
a631 1
  return TRUE;
d660 1
a660 1
  new->local = FALSE;
d668 1
a668 1
static bfd_boolean
d694 1
a694 1
	  return TRUE;
d699 1
a699 1
      return TRUE;
d880 1
a880 1
		  return FALSE;
d889 1
a889 1
	      return FALSE;
d922 1
a922 1
  return TRUE;
d927 1
a927 1
bfd_boolean
d950 1
a950 1
    return TRUE;
d955 1
a955 1
    return FALSE;
d957 1
a957 1
    return TRUE;
d963 1
a963 1
    return FALSE;
d980 1
a980 1
	return FALSE;
d987 1
a987 1
      internal_ptr->local = FALSE;
d1015 1
a1015 1
	    return FALSE;
d1017 1
a1017 1
	  internal_ptr->local = TRUE;
d1024 1
a1024 1
  return TRUE;
d1446 1
a1446 1
bfd_boolean
d1645 1
a1645 1
static bfd_boolean
d1662 1
a1662 1
    return TRUE;
d1665 1
a1665 1
    return FALSE;
d1676 1
a1676 1
    return FALSE;
d1678 1
a1678 1
    return FALSE;
d1680 1
a1680 1
    return FALSE;
d1750 1
a1750 1
  return TRUE;
d1798 1
a1798 1
bfd_boolean
d1817 1
a1817 1
    return FALSE;
d1825 1
a1825 1
	return FALSE;
d1847 1
a1847 1
bfd_boolean
d1857 1
a1857 1
  bfd_boolean local;
d1863 1
a1863 1
    return TRUE;
d1879 1
a1879 1
    return TRUE;
d1882 1
a1882 1
  local = FALSE;
d1887 1
a1887 1
	  local = TRUE;
d1950 1
a1950 1
  return TRUE;
d1957 1
a1957 1
bfd_boolean
d1972 1
a1972 1
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d1992 1
a1992 1
bfd_boolean
d2036 1
a2036 1
static bfd_boolean
d2045 2
a2046 2
  bfd_boolean rdata_in_text;
  bfd_boolean first_data, first_nonalloc;
d2050 1
a2050 1
  sofar = _bfd_ecoff_sizeof_headers (abfd, FALSE);
d2058 1
a2058 1
    return FALSE;
d2082 1
a2082 1
	      rdata_in_text = FALSE;
d2089 2
a2090 2
  first_data = TRUE;
  first_nonalloc = TRUE;
d2123 1
a2123 1
	  first_data = FALSE;
d2141 1
a2141 1
	  first_nonalloc = FALSE;
d2180 1
a2180 1
  return TRUE;
d2202 1
a2202 1
      abfd->output_has_begun = TRUE;
d2242 1
a2242 1
bfd_boolean
d2253 1
a2253 1
     going to set output_has_begun to TRUE.  */
d2257 1
a2257 1
	return FALSE;
d2278 1
a2278 1
    return TRUE;
d2283 1
a2283 1
    return FALSE;
d2285 1
a2285 1
  return TRUE;
d2308 1
a2308 1
bfd_boolean
d2317 1
a2317 1
      return FALSE;
d2322 1
a2322 1
  return TRUE;
d2328 1
a2328 1
bfd_boolean
d2341 1
a2341 1
      return FALSE;
d2355 1
a2355 1
  return TRUE;
d2361 1
a2361 1
static bfd_boolean
d2376 1
a2376 1
	return FALSE;
d2388 1
a2388 1
      return TRUE;
d2394 1
a2394 1
    return FALSE;
d2420 1
a2420 1
  return TRUE;
d2436 1
a2436 1
bfd_boolean
d2448 3
a2450 2
  void (* const adjust_reloc_out)
  PARAMS ((bfd *, const arelent *, struct internal_reloc *))
d2452 3
a2454 2
  void (* const swap_reloc_out)
  PARAMS ((bfd *, const struct internal_reloc *, PTR))
d2463 1
a2463 1
  bfd_boolean set_text_start;
d2466 1
a2466 1
  bfd_boolean set_data_start;
d2488 1
a2488 1
    text_size = _bfd_ecoff_sizeof_headers (abfd, FALSE);
d2492 1
a2492 1
  set_text_start = FALSE;
d2495 1
a2495 1
  set_data_start = FALSE;
d2591 1
a2591 1
	      set_text_start = TRUE;
d2607 1
a2607 1
	      set_data_start = TRUE;
d2873 1
a2873 1
  return TRUE;
d2879 1
a2879 1
  return FALSE;
d2952 1
a2952 1
bfd_boolean
d2971 1
a2971 1
      return TRUE;
d2973 1
a2973 1
      return FALSE;
d2976 1
a2976 1
    return FALSE;
d2998 2
a2999 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d3009 1
a3009 1
      return FALSE;
d3016 1
a3016 1
    return FALSE;
d3022 1
a3022 1
    return FALSE;
d3029 1
a3029 1
      return FALSE;
d3089 1
a3089 1
    return FALSE;
d3111 1
a3111 1
  bfd_has_map (abfd) = TRUE;
d3113 1
a3113 1
  return TRUE;
d3118 1
a3118 1
bfd_boolean
d3202 1
a3202 1
    return FALSE;
d3206 1
a3206 1
    return FALSE;
d3210 1
a3210 1
    return FALSE;
d3255 1
a3255 1
    return FALSE;
d3262 1
a3262 1
    return FALSE;
d3269 1
a3269 1
	return FALSE;
d3277 1
a3277 1
	return FALSE;
d3280 1
a3280 1
  return TRUE;
d3346 1
a3346 1
	  first->target_defaulted = FALSE;
d3375 1
a3375 1
static bfd_boolean ecoff_link_add_archive_symbols
d3377 3
a3379 3
static bfd_boolean ecoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
static bfd_boolean ecoff_link_add_object_symbols
d3381 1
a3381 1
static bfd_boolean ecoff_link_add_externals
d3452 1
a3452 1
    (bfd_boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func), \
d3463 1
a3463 1
bfd_boolean
d3476 1
a3476 1
      return FALSE;
d3487 1
a3487 1
static bfd_boolean
d3505 1
a3505 1
	return TRUE;
d3507 1
a3507 1
      return FALSE;
d3585 1
a3585 1
	  bfd_boolean found;
d3588 1
a3588 1
	  found = FALSE;
d3600 1
a3600 1
		  found = TRUE;
d3616 1
a3616 1
	return FALSE;
d3619 1
a3619 1
	return FALSE;
d3625 1
a3625 1
	return FALSE;
d3627 1
a3627 1
	return FALSE;
d3632 1
a3632 1
  return TRUE;
d3638 1
a3638 1
static bfd_boolean
d3642 1
a3642 1
     bfd_boolean *pneeded;
d3655 1
a3655 1
  *pneeded = FALSE;
d3693 1
a3693 1
      bfd_boolean def;
d3719 1
a3719 1
	  def = TRUE;
d3722 1
a3722 1
	  def = FALSE;
d3730 1
a3730 1
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d3744 1
a3744 1
      *pneeded = TRUE;
d3753 1
a3753 1
  return TRUE;
d3759 1
a3759 1
  return FALSE;
d3765 1
a3765 1
static bfd_boolean
d3775 1
a3775 1
  bfd_boolean result;
d3778 1
a3778 1
    return FALSE;
d3782 1
a3782 1
    return TRUE;
d3819 1
a3819 1
  return FALSE;
d3828 1
a3828 1
static bfd_boolean
d3851 1
a3851 1
    return FALSE;
d3859 1
a3859 1
      bfd_boolean skip;
d3870 1
a3870 1
      skip = FALSE;
d3880 1
a3880 1
	  skip = TRUE;
d3986 2
a3987 2
	      section, value, (const char *) NULL, TRUE, TRUE, sym_hash)))
	return FALSE;
d4027 1
a4027 1
  return TRUE;
d4032 1
a4032 1
static bfd_boolean ecoff_final_link_debug_accumulate
d4035 1
a4035 1
static bfd_boolean ecoff_link_write_external
d4037 1
a4037 1
static bfd_boolean ecoff_indirect_link_order
d4040 1
a4040 1
static bfd_boolean ecoff_reloc_link_order
d4057 1
a4057 1
bfd_boolean
d4104 1
a4104 1
    return FALSE;
d4111 1
a4111 1
      bfd_boolean ret;
d4128 1
a4128 1
	return FALSE;
d4172 1
a4172 1
    return FALSE;
d4190 1
a4190 1
      h = bfd_link_hash_lookup (info->hash, "_gp", FALSE, FALSE, TRUE);
d4233 1
a4233 1
		return FALSE;
d4239 1
a4239 1
		return FALSE;
d4244 1
a4244 1
		return FALSE;
d4251 1
a4251 1
  ecoff_data (abfd)->linker = TRUE;
d4253 1
a4253 1
  return TRUE;
d4260 1
a4260 1
static bfd_boolean
d4271 1
a4271 1
  bfd_boolean ret;
d4282 1
a4282 1
          ret = FALSE;							 \
d4288 1
a4288 1
          ret = FALSE;							 \
d4359 1
a4359 1
static bfd_boolean
d4366 1
a4366 1
  bfd_boolean strip;
d4372 1
a4372 1
	return TRUE;
d4378 1
a4378 1
    strip = FALSE;
d4383 2
a4384 2
				   FALSE, FALSE) == NULL))
    strip = TRUE;
d4386 1
a4386 1
    strip = FALSE;
d4389 1
a4389 1
    return TRUE;
d4487 1
a4487 1
      return TRUE;
d4503 1
a4503 1
static bfd_boolean
d4524 1
a4524 1
    return TRUE;
d4613 1
a4613 1
  return TRUE;
d4620 1
a4620 1
  return FALSE;
d4628 1
a4628 1
static bfd_boolean
d4642 1
a4642 1
  bfd_boolean ok;
d4657 1
a4657 1
      return FALSE;
d4673 1
a4673 1
					FALSE, FALSE, FALSE);
d4707 1
a4707 1
	return FALSE;
d4727 1
a4727 1
	      return FALSE;
d4735 1
a4735 1
	return FALSE;
d4752 1
a4752 1
					 FALSE, FALSE, TRUE));
d4761 1
a4761 1
	    return FALSE;
d4813 1
a4813 1
    return FALSE;
@


1.21.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2002, 2003 Free Software Foundation, Inc.
a83 4
  /* sec_info_type, use_rela_p, has_tls_reloc, flag11, flag12,     */
     0,		    0,		0,	       0,      0,
  /* flag13, flag14, flag15, flag16, flag20, flag24,               */
     0,      0,      0,      0,      0,	     0,
@


1.21.2.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d84 2
a85 4
  /* sec_info_type, use_rela_p, has_tls_reloc,                     */
     0,		    0,		0,
  /* need_finalize_relax, has_gp_reloc,                            */
     0,			  0,
d4161 1
a4161 1
  if (info->relocatable)
d4191 1
a4191 1
  if (info->relocatable)
d4211 1
a4211 1
      else if (info->relocatable)
d4609 1
a4609 1
  /* If we are producing relocatable output, the relocs were
d4613 1
a4613 1
  if (info->relocatable)
@


1.21.2.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d98 2
a99 2
  /* entsize, comdat, kept_section, moving_line_filepos,           */
     0,       NULL,   NULL,         0,
@


1.21.2.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d103 1
a103 1
     (struct bfd_symbol *) NULL,
d105 1
a105 1
     (struct bfd_symbol **) NULL,
d1065 1
a1065 1
_bfd_ecoff_canonicalize_symtab (abfd, alocation)
d2265 1
a2265 1
     const PTR location;
@


1.21.2.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d3569 1
a3569 1
	    *pundef = (*pundef)->und_next;
d3571 1
a3571 1
	    pundef = &(*pundef)->und_next;
d3581 1
a3581 1
	  pundef = &(*pundef)->und_next;
d3593 1
a3593 1
	  pundef = &(*pundef)->und_next;
d3624 1
a3624 1
	      pundef = &(*pundef)->und_next;
d3646 1
a3646 1
      pundef = &(*pundef)->und_next;
d4132 1
a4132 1
	  /* Arbitrarily set the symbolic header vstamp to the vstamp
@


1.20
log
@	* ecoff.c (_bfd_ecoff_set_arch_mach_hook): Don't use hard-coded
	bfd_mach constants.
	(ecoff_get_magic): Likewise.
	* elf32-v850.c (v850_elf_object_p): Likewise.
	(v850_elf_final_write_processing): Likewise.
	* mipsbsd.c (MY(set_arch_mach)): Likewise.
	(MY(write_object_contents)): Likewise.
	* coff64-rs6000.c (xcoff64_write_object_contents): Likewise.
	* coffcode.h (coff_write_object_contents): Likewise.
	(coff_set_arch_mach_hook): Add comment describing machine == 0.
	Remove unnecessary "machine" assignments.
	(coff_write_relocs): Test for the absolute section sym by testing
	section and flags.

	* pdp11.c (NAME(aout,machine_type)): Like aoutx.h.
@
text
@d556 3
a558 1
  UPDATE_RAW_END (cbOptOffset, ioptMax, backend->debug_swap.external_opt_size);
@


1.19
log
@	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.
@
text
@d208 1
a208 1
      mach = 3000;
d215 1
a215 1
      mach = 6000;
d222 1
a222 1
      mach = 4000;
d255 1
a255 1
	case 3000:
d260 1
a260 1
	case 6000:
d265 1
a265 1
	case 4000:
@


1.18
log
@Set BSF_FUNCTION for symbols of type stProc and stStaticProc.
Formatting tidy ups.
@
text
@a3291 2
  tdata_hold = abfd->tdata.aout_ar_data;

d3305 2
a3306 3
  /* We are setting bfd_ardata(abfd) here, but since bfd_ardata
     involves a cast, we can't do it as the left operand of
     assignment.  */
d3308 1
a3308 2
  abfd->tdata.aout_ar_data = (struct artdata *) bfd_zalloc (abfd, amt);

d3311 1
a3311 1
      abfd->tdata.aout_ar_data = tdata_hold;
d3326 1
a3326 1
      abfd->tdata.aout_ar_data = tdata_hold;
a3343 2
	  boolean fail;

a3344 1
	  fail = false;
d3348 5
d3355 3
a3357 2
	      abfd->tdata.aout_ar_data = tdata_hold;
	      bfd_set_error (bfd_error_wrong_format);
d3360 1
a3360 3

	  /* We ought to close first here, but we can't, because we
             have no way to remove it from the archive cache.  FIXME.  */
@


1.18.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d556 1
a556 3
  /* eraxxon@@alumni.rice.edu: ioptMax refers to the size of the
     optimization symtab, not the number of entries */
  UPDATE_RAW_END (cbOptOffset, ioptMax, sizeof (char));
d3292 2
d3307 5
a3311 1
  tdata_hold = bfd_ardata (abfd);
a3312 2
  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d3315 1
a3315 1
      bfd_ardata (abfd) = tdata_hold;
d3330 1
a3330 1
      bfd_ardata (abfd) = tdata_hold;
d3348 2
d3351 1
a3354 5
#if 0
	      /* We ought to close `first' here, but we can't, because
		 we have no way to remove it from the archive cache.
		 It's close to impossible to figure out when we can
		 release bfd_ardata.  FIXME.  */
d3357 2
a3358 3
#endif
	      bfd_set_error (bfd_error_wrong_object_format);
	      bfd_ardata (abfd) = tdata_hold;
d3361 3
a3363 1
	  /* And we ought to close `first' here too.  */
@


1.18.2.2
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d3840 1
a3840 1
  struct bfd_link_hash_entry **sym_hash;
d3849 1
a3849 1
  sym_hash = (struct bfd_link_hash_entry **) bfd_alloc (abfd, amt);
d3852 1
a3852 1
  ecoff_data (abfd)->sym_hashes = (struct ecoff_link_hash_entry **) sym_hash;
d3983 1
d3987 2
a3988 1
	      section, value, (const char *) NULL, true, true, sym_hash)))
d3991 1
a3991 1
      h = (struct ecoff_link_hash_entry *) *sym_hash;
@


1.17
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 7
a55 14
static int ecoff_get_magic PARAMS ((bfd *abfd));
static long ecoff_sec_to_styp_flags PARAMS ((const char *name,
					     flagword flags));
static boolean ecoff_slurp_symbolic_header PARAMS ((bfd *abfd));
static boolean ecoff_set_symbol_info PARAMS ((bfd *abfd, SYMR *ecoff_sym,
					   asymbol *asym, int ext, int weak));
static void ecoff_emit_aggregate PARAMS ((bfd *abfd, FDR *fdr,
					  char *string,
					  RNDXR *rndx, long isym,
					  const char *which));
static char *ecoff_type_to_string PARAMS ((bfd *abfd, FDR *fdr,
					   unsigned int indx));
static boolean ecoff_slurp_reloc_table PARAMS ((bfd *abfd, asection *section,
						asymbol **symbols));
d57 2
a58 2
static boolean ecoff_compute_section_file_positions PARAMS ((bfd *abfd));
static bfd_size_type ecoff_compute_reloc_file_positions PARAMS ((bfd *abfd));
d61 1
a61 4
static unsigned int ecoff_armap_hash PARAMS ((const char *s,
					      unsigned int *rehash,
					      unsigned int size,
					      unsigned int hlog));
d98 1
d178 2
a179 4
    {
      /* An Irix 4 shared libary.  */
      section->flags |= SEC_COFF_SHARED_LIBRARY;
    }
d213 1
a213 1
      /* MIPS ISA level 2: the r6000 */
d220 1
a220 1
      /* MIPS ISA level 3: the r4000 */
a544 1

d595 1
d718 4
d1182 1
a1182 3
  /*
   * Go get the basic type.
   */
d1185 1
a1185 1
    case btNil:			/* undefined */
d1189 1
a1189 1
    case btAdr:			/* address - integer same size as pointer */
d1193 1
a1193 1
    case btChar:		/* character */
d1197 1
a1197 1
    case btUChar:		/* unsigned character */
d1201 1
a1201 1
    case btShort:		/* short */
d1205 1
a1205 1
    case btUShort:		/* unsigned short */
d1209 1
a1209 1
    case btInt:			/* int */
d1213 1
a1213 1
    case btUInt:		/* unsigned int */
d1217 1
a1217 1
    case btLong:		/* long */
d1221 1
a1221 1
    case btULong:		/* unsigned long */
d1225 1
a1225 1
    case btFloat:		/* float (real) */
d1229 1
a1229 1
    case btDouble:		/* Double (real) */
d1237 1
a1237 1
    case btStruct:		/* Structure (Record) */
d1242 1
a1242 1
      indx++;			/* skip aux words */
d1249 1
a1249 1
    case btUnion:		/* Union */
d1254 1
a1254 1
      indx++;			/* skip aux words */
d1261 1
a1261 1
    case btEnum:		/* Enumeration */
d1266 1
a1266 1
      indx++;			/* skip aux words */
d1269 1
a1269 1
    case btTypedef:		/* defined via a typedef, isymRef points */
d1273 1
a1273 1
    case btRange:		/* subrange of int */
d1277 1
a1277 1
    case btSet:			/* pascal sets */
d1281 1
a1281 1
    case btComplex:		/* fortran complex */
d1285 1
a1285 1
    case btDComplex:		/* fortran double complex */
d1289 1
a1289 1
    case btIndirect:		/* forward or unnamed typedef */
d1293 1
a1293 1
    case btFixedDec:		/* Fixed Decimal */
d1297 1
a1297 1
    case btFloatDec:		/* Float Decimal */
d1301 1
a1301 1
    case btString:		/* Varying Length Character String */
d1305 1
a1305 1
    case btBit:			/* Aligned Bit String */
d1309 1
a1309 1
    case btPicture:		/* Picture */
d1313 1
a1313 1
    case btVoid:		/* Void */
d1324 1
a1324 3
  /*
   * If this is a bitfield, get the bitsize.
   */
d1334 1
a1334 3
  /*
   * Deal with any qualifiers.
   */
d1337 7
a1343 9
      /*
       * Snarf up any array bounds in the correct order.  Arrays
       * store 5 successive words in the aux. table:
       *	word 0	RNDXR to type of the bounds (ie, int)
       *	word 1	Current file descriptor index
       *	word 2	low bound
       *	word 3	high bound (or -1 if [])
       *	word 4	stride size in bits
       */
d1358 1
a1358 3
      /*
       * Now print out the qualifiers.
       */
a1393 1

d1495 1
a1495 1
      /* Print out the symbols in a reasonable way */
d1569 1
a1569 1
	    /* This switch is basically from gcc/mips-tdump.c  */
d2165 1
a2165 1
      /* make sure that this section is of the right size too */
d2347 1
a2347 1
      register int i;
d2614 1
a2614 1
	/* Do nothing */ ;
a2619 1

a2711 1

a3038 1

@


1.16
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d128 1
a128 1
  if (_bfd_ecoff_mkobject (abfd) == false)
d1059 1
a1059 1
  if (_bfd_ecoff_slurp_symbol_table (abfd) == false)
d1680 1
a1680 1
  if (_bfd_ecoff_slurp_symbol_table (abfd) == false)
d1796 1
a1796 1
      if (ecoff_slurp_reloc_table (abfd, section, symbols) == false)
d2270 1
a2270 1
  if (abfd->output_has_begun == false)
d2753 3
a2755 5
      if (bfd_ecoff_debug_externals (abfd, debug, &backend->debug_swap,
				     (((abfd->flags & EXEC_P) == 0)
				      ? true : false),
				     ecoff_get_extr, ecoff_set_index)
	  == false)
d2859 2
a2860 3
	  if (bfd_ecoff_write_debug (abfd, debug, &backend->debug_swap,
				     ecoff_data (abfd)->sym_filepos)
	      == false)
d3347 2
a3348 2
  if (_bfd_ecoff_slurp_armap (abfd) == false
      || _bfd_ecoff_slurp_extended_name_table (abfd) == false)
@


1.15
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d664 1
a664 1
  new = (ecoff_symbol_type *) bfd_alloc (abfd, amt);
a666 1
  memset ((PTR) new, 0, sizeof *new);
@


1.15.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d664 1
a664 1
  new = (ecoff_symbol_type *) bfd_zalloc (abfd, amt);
d667 1
@


1.15.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d49 14
a62 7
static int ecoff_get_magic PARAMS ((bfd *));
static long ecoff_sec_to_styp_flags PARAMS ((const char *, flagword));
static boolean ecoff_slurp_symbolic_header PARAMS ((bfd *));
static boolean ecoff_set_symbol_info PARAMS ((bfd *, SYMR *, asymbol *, int, int));
static void ecoff_emit_aggregate PARAMS ((bfd *, FDR *, char *, RNDXR *, long, const char *));
static char *ecoff_type_to_string PARAMS ((bfd *, FDR *, unsigned int));
static boolean ecoff_slurp_reloc_table PARAMS ((bfd *, asection *, asymbol **));
d64 2
a65 2
static boolean ecoff_compute_section_file_positions PARAMS ((bfd *));
static bfd_size_type ecoff_compute_reloc_file_positions PARAMS ((bfd *));
d68 4
a71 1
static unsigned int ecoff_armap_hash PARAMS ((const char *, unsigned int *, unsigned int, unsigned int));
a107 1

d128 1
a128 1
  if (! _bfd_ecoff_mkobject (abfd))
d187 4
a190 2
    /* An Irix 4 shared libary.  */
    section->flags |= SEC_COFF_SHARED_LIBRARY;
d224 1
a224 1
      /* MIPS ISA level 2: the r6000.  */
d231 1
a231 1
      /* MIPS ISA level 3: the r4000.  */
d556 1
a606 1

a728 4

  if (ecoff_sym->st == stProc || ecoff_sym->st == stStaticProc)
    asym->flags |= BSF_FUNCTION;

d1059 1
a1059 1
  if (! _bfd_ecoff_slurp_symbol_table (abfd))
d1189 3
a1191 1
  /* Go get the basic type.  */
d1194 1
a1194 1
    case btNil:			/* Undefined.  */
d1198 1
a1198 1
    case btAdr:			/* Address - integer same size as pointer.  */
d1202 1
a1202 1
    case btChar:		/* Character.  */
d1206 1
a1206 1
    case btUChar:		/* Unsigned character.  */
d1210 1
a1210 1
    case btShort:		/* Short.  */
d1214 1
a1214 1
    case btUShort:		/* Unsigned short.  */
d1218 1
a1218 1
    case btInt:			/* Int.  */
d1222 1
a1222 1
    case btUInt:		/* Unsigned int.  */
d1226 1
a1226 1
    case btLong:		/* Long.  */
d1230 1
a1230 1
    case btULong:		/* Unsigned long.  */
d1234 1
a1234 1
    case btFloat:		/* Float (real).  */
d1238 1
a1238 1
    case btDouble:		/* Double (real).  */
d1246 1
a1246 1
    case btStruct:		/* Structure (Record).  */
d1251 1
a1251 1
      indx++;			/* Skip aux words.  */
d1258 1
a1258 1
    case btUnion:		/* Union.  */
d1263 1
a1263 1
      indx++;			/* Skip aux words.  */
d1270 1
a1270 1
    case btEnum:		/* Enumeration.  */
d1275 1
a1275 1
      indx++;			/* Skip aux words.  */
d1278 1
a1278 1
    case btTypedef:		/* Defined via a typedef, isymRef points.  */
d1282 1
a1282 1
    case btRange:		/* Subrange of int.  */
d1286 1
a1286 1
    case btSet:			/* Pascal sets.  */
d1290 1
a1290 1
    case btComplex:		/* Fortran complex.  */
d1294 1
a1294 1
    case btDComplex:		/* Fortran double complex.  */
d1298 1
a1298 1
    case btIndirect:		/* Forward or unnamed typedef.  */
d1302 1
a1302 1
    case btFixedDec:		/* Fixed Decimal.  */
d1306 1
a1306 1
    case btFloatDec:		/* Float Decimal.  */
d1310 1
a1310 1
    case btString:		/* Varying Length Character String.  */
d1314 1
a1314 1
    case btBit:			/* Aligned Bit String.  */
d1318 1
a1318 1
    case btPicture:		/* Picture.  */
d1322 1
a1322 1
    case btVoid:		/* Void.  */
d1333 3
a1335 1
  /* If this is a bitfield, get the bitsize.  */
d1345 3
a1347 1
  /* Deal with any qualifiers.  */
d1350 9
a1358 7
      /* Snarf up any array bounds in the correct order.  Arrays
         store 5 successive words in the aux. table:
        	word 0	RNDXR to type of the bounds (ie, int)
        	word 1	Current file descriptor index
        	word 2	low bound
        	word 3	high bound (or -1 if [])
        	word 4	stride size in bits.  */
d1373 3
a1375 1
      /* Now print out the qualifiers.  */
d1411 1
d1513 1
a1513 1
      /* Print out the symbols in a reasonable way.  */
d1587 1
a1587 1
	    /* This switch is basically from gcc/mips-tdump.c.  */
d1680 1
a1680 1
  if (! _bfd_ecoff_slurp_symbol_table (abfd))
d1796 1
a1796 1
      if (! ecoff_slurp_reloc_table (abfd, section, symbols))
d2183 1
a2183 1
      /* Make sure that this section is of the right size too.  */
d2270 1
a2270 1
  if (! abfd->output_has_begun)
d2365 1
a2365 1
      int i;
d2632 1
a2632 1
	/* Do nothing.  */ ;
d2638 1
d2731 1
d2753 5
a2757 3
      if (! bfd_ecoff_debug_externals (abfd, debug, &backend->debug_swap,
				       (abfd->flags & EXEC_P) == 0,
				       ecoff_get_extr, ecoff_set_index))
d2861 3
a2863 2
	  if (! bfd_ecoff_write_debug (abfd, debug, &backend->debug_swap,
				       ecoff_data (abfd)->sym_filepos))
d3062 1
d3350 2
a3351 2
  if (! _bfd_ecoff_slurp_armap (abfd)
      || ! _bfd_ecoff_slurp_extended_name_table (abfd))
@


1.15.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d3292 2
d3307 5
a3311 1
  tdata_hold = bfd_ardata (abfd);
a3312 2
  amt = sizeof (struct artdata);
  bfd_ardata (abfd) = (struct artdata *) bfd_zalloc (abfd, amt);
d3315 1
a3315 1
      bfd_ardata (abfd) = tdata_hold;
d3330 1
a3330 1
      bfd_ardata (abfd) = tdata_hold;
d3348 2
d3351 1
a3354 5
#if 0
	      /* We ought to close `first' here, but we can't, because
		 we have no way to remove it from the archive cache.
		 It's close to impossible to figure out when we can
		 release bfd_ardata.  FIXME.  */
d3357 2
a3358 3
#endif
	      bfd_set_error (bfd_error_wrong_object_format);
	      bfd_ardata (abfd) = tdata_hold;
d3361 3
a3363 1
	  /* And we ought to close `first' here too.  */
@


1.15.6.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d208 1
a208 1
      mach = bfd_mach_mips3000;
d215 1
a215 1
      mach = bfd_mach_mips6000;
d222 1
a222 1
      mach = bfd_mach_mips4000;
d255 1
a255 1
	case bfd_mach_mips3000:
d260 1
a260 1
	case bfd_mach_mips6000:
d265 1
a265 1
	case bfd_mach_mips4000:
d556 1
a556 3
  /* eraxxon@@alumni.rice.edu: ioptMax refers to the size of the
     optimization symtab, not the number of entries */
  UPDATE_RAW_END (cbOptOffset, ioptMax, sizeof (char));
@


1.15.6.5
log
@merge from mainline
@
text
@d3840 1
a3840 1
  struct bfd_link_hash_entry **sym_hash;
d3849 1
a3849 1
  sym_hash = (struct bfd_link_hash_entry **) bfd_alloc (abfd, amt);
d3852 1
a3852 1
  ecoff_data (abfd)->sym_hashes = (struct ecoff_link_hash_entry **) sym_hash;
d3983 1
d3987 2
a3988 1
	      section, value, (const char *) NULL, true, true, sym_hash)))
d3991 1
a3991 1
      h = (struct ecoff_link_hash_entry *) *sym_hash;
@


1.15.4.1
log
@merge from trunk
@
text
@d664 1
a664 1
  new = (ecoff_symbol_type *) bfd_zalloc (abfd, amt);
d667 1
@


1.14
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d3455 1
a3455 1
  ret = (struct ecoff_link_hash_table *) bfd_alloc (abfd, amt);
@


1.13
log
@	* aout-encap.c: Fix comment typos.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mips.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m32r.c: Likewise.
	* libcoff-in.h: Likewise.
	* libecoff.h: Likewise.
	* libxcoff.h: Likewise.
	* nlm32-i386.c: Likewise.
	* pdp11.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libcoff.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
d4396 7
d4484 1
d4513 2
a4514 3
    case bfd_link_hash_warning:
      /* FIXME: Ignore these for now.  The circumstances under which
	 they should be written out are not clear to me.  */
@


1.13.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
a4395 7
  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct ecoff_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return true;
    }

a4476 1
    case bfd_link_hash_warning:
d4505 3
a4507 2
      /* We ignore these symbols, since the indirected symbol is
	 already in the hash table.  */
@


1.12
log
@	* section.c (struct sec): Remove kept_section.
	(STD_SECTION): Remove kept_section initialisation.
	(bfd_make_section_anyway): Here too.
	* ecoff.c (bfd_debug_section): Remove kept_section initialisation.
	* cofflink.c (_bfd_coff_link_input_bfd): Don't test kept_section.
	* elflink.h (elf_link_input_bfd): Set discarded link-once section
	symbols to zero, and remove all code involved with kept_section
	and tracking section symbol values.
	* bfd-in2.h: Regenerate.
	* configure.in: Bump version number.
	* configure: Regenerate.

	* ldlang.c (section_already_linked): Remove assignment to kept_section.
@
text
@d4761 1
a4761 1
  /* Move the information into a internal_reloc structure.  */
@


1.11
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d89 2
a90 2
  /* entsize, comdat, kept_section, moving_line_filepos,           */
     0,       NULL,   NULL,         0,
@


1.10
log
@Chnage styp_flags_to_sec_flags() to a boolean function
@
text
@d68 1
a68 1
static unsigned int ecoff_armap_hash PARAMS ((CONST char *s,
d81 1
a81 1
  /* vma, lma, _cooked_size, _raw_size,                            */ 
d107 2
a108 2
  abfd->tdata.ecoff_obj_data = ((struct ecoff_tdata *)
				bfd_zalloc (abfd, sizeof (ecoff_data_type)));
d477 1
a477 1
  raw = (PTR) bfd_malloc ((size_t) external_hdr_size);
d481 2
a482 3
  if (bfd_seek (abfd, ecoff_data (abfd)->sym_filepos, SEEK_SET) == -1
      || (bfd_read (raw, external_hdr_size, 1, abfd)
	  != external_hdr_size))
d527 2
d587 5
a591 5
  if (bfd_seek (abfd,
		(ecoff_data (abfd)->sym_filepos
		 + backend->debug_swap.external_hdr_size),
		SEEK_SET) != 0
      || bfd_read (raw, raw_size, 1, abfd) != raw_size)
d628 3
a630 3
  debug->fdr = (struct fdr *) bfd_alloc (abfd,
					 (internal_symhdr->ifdMax *
					  sizeof (struct fdr)));
d662 1
d664 1
a664 1
  new = (ecoff_symbol_type *) bfd_alloc (abfd, sizeof (ecoff_symbol_type));
d863 1
d883 2
a884 1
		copy = (char *) bfd_alloc (abfd, strlen (name) + 1);
d892 2
a893 2
	    reloc_chain =
	      (arelent_chain *) bfd_alloc (abfd, sizeof (arelent_chain));
d965 2
a966 1
  internal_size = bfd_get_symcount (abfd) * sizeof (ecoff_symbol_type);
d1671 1
a1671 1
  bfd_size_type external_relocs_size;
d1684 4
a1687 3
  internal_relocs = (arelent *) bfd_alloc (abfd,
					   (sizeof (arelent)
					    * section->reloc_count));
d1689 2
a1690 2
  external_relocs_size = external_reloc_size * section->reloc_count;
  external_relocs = (char *) bfd_alloc (abfd, external_relocs_size);
d1696 1
a1696 2
  if (bfd_read (external_relocs, 1, external_relocs_size, abfd)
      != external_relocs_size)
d1725 1
a1725 1
	  CONST char *sec_name;
d1822 2
a1823 2
     CONST char **filename_ptr;
     CONST char **functionname_ptr;
d1838 3
a1840 3
      ecoff_data (abfd)->find_line_info =
	((struct ecoff_find_line *)
	 bfd_zalloc (abfd, sizeof (struct ecoff_find_line)));
d2065 1
d2071 3
a2073 2
  sorted_hdrs = (asection **) bfd_malloc (abfd->section_count
					  * sizeof (asection *));
d2267 2
d2297 3
a2299 2
  if (bfd_seek (abfd, (file_ptr) (section->filepos + offset), SEEK_SET) != 0
      || bfd_write (location, 1, count, abfd) != count)
d2526 1
a2526 1
    buff = (PTR) bfd_malloc ((size_t) siz);
d2586 1
a2586 1
	  || bfd_write (buff, 1, scnhsz, abfd) != scnhsz)
d2737 1
a2737 1
  if (bfd_write (buff, 1, filhsz, abfd) != filhsz)
d2741 1
a2741 1
  if (bfd_write (buff, 1, aoutsz, abfd) != aoutsz)
d2769 1
d2774 2
a2775 2
	  reloc_buff =
	    bfd_alloc (abfd, current->reloc_count * external_reloc_size);
d2806 1
a2806 1
		  CONST char *name;
d2851 2
a2852 3
	  if (bfd_write (reloc_buff,
			 external_reloc_size, current->reloc_count, abfd)
	      != external_reloc_size * current->reloc_count)
d2882 1
a2882 1
      if (bfd_read (&c, 1, 1, abfd) == 0)
d2887 1
a2887 1
      if (bfd_write (&c, 1, 1, abfd) != 1)
d2955 1
a2955 1
     CONST char *s;
d2988 1
d2991 1
a2991 1
  i = bfd_read ((PTR) nextname, 1, 16, abfd);
d3046 1
a3046 1
  if (bfd_read ((PTR) raw_armap, 1, parsed_size, abfd) != parsed_size)
d3056 1
a3056 1
  count = bfd_h_get_32 (abfd, (PTR) raw_armap);
d3083 2
a3084 2
	name_offset = bfd_h_get_32 (abfd, (PTR) raw_ptr);
	file_offset = bfd_h_get_32 (abfd, (PTR) (raw_ptr + 4));
d3096 1
a3096 2
	  BFD_ASSERT (bfd_h_get_32 (abfd, (PTR) (raw_armap + 8 + srch * 8))
		      != 0);
d3105 1
a3105 1
    if (bfd_h_get_32 (abfd, (PTR) (raw_ptr + 4)) != 0)
d3108 3
a3110 3
  symdef_ptr = ((struct symdef *)
		bfd_alloc (abfd,
			   ardata->symdef_count * sizeof (struct symdef)));
d3121 1
a3121 1
      file_offset = bfd_h_get_32 (abfd, (PTR) (raw_ptr + 4));
d3124 1
a3124 1
      name_offset = bfd_h_get_32 (abfd, (PTR) raw_ptr);
d3150 1
a3150 1
  unsigned int symdefsize;
d3223 1
a3223 1
  if (bfd_write ((PTR) &hdr, 1, sizeof (struct ar_hdr), abfd)
d3227 2
a3228 2
  bfd_h_put_32 (abfd, (bfd_vma) hashsize, temp);
  if (bfd_write ((PTR) temp, 1, 4, abfd) != 4)
d3243 1
a3243 1
      if (((bfd *) map[i].pos) != last_elt)
d3251 1
a3251 1
	  while (current != (bfd *) map[i].pos);
d3257 1
a3257 1
      if (bfd_h_get_32 (abfd, (PTR) (hashtable + (hash * 8) + 4)) != 0)
d3265 1
a3265 1
	    if (bfd_h_get_32 (abfd, (PTR) (hashtable + (srch * 8) + 4)) == 0)
d3273 2
a3274 4
      bfd_h_put_32 (abfd, (bfd_vma) map[i].namidx,
		    (PTR) (hashtable + hash * 8));
      bfd_h_put_32 (abfd, (bfd_vma) firstreal,
		    (PTR) (hashtable + hash * 8 + 4));
d3277 1
a3277 1
  if (bfd_write ((PTR) hashtable, 1, symdefsize, abfd) != symdefsize)
d3283 2
a3284 2
  bfd_h_put_32 (abfd, (bfd_vma) stringsize, temp);
  if (bfd_write ((PTR) temp, 1, 4, abfd) != 4)
d3291 1
a3291 1
      if (bfd_write ((PTR) (*map[i].name), 1, len, abfd) != len)
d3299 1
a3299 1
      if (bfd_write ("", 1, 1, abfd) != 1)
d3315 1
d3319 1
a3319 1
  if (bfd_read ((PTR) armag, 1, SARMAG, abfd) != SARMAG)
d3335 2
a3336 2
  abfd->tdata.aout_ar_data =
    (struct artdata *) bfd_zalloc (abfd, sizeof (struct artdata));
d3453 1
d3455 1
a3455 2
  ret = ((struct ecoff_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct ecoff_link_hash_table)));
d3545 1
a3545 1
  armap_count = bfd_h_get_32 (abfd, raw_armap);
d3598 1
a3598 1
      file_offset = bfd_h_get_32 (abfd, hashtable + (hash * 8) + 4);
d3606 1
a3606 1
      name = stringbase + bfd_h_get_32 (abfd, hashtable + (hash * 8));
d3619 1
a3619 1
	      file_offset = bfd_h_get_32 (abfd, hashtable + (srch * 8) + 4);
d3622 1
a3622 1
	      name = stringbase + bfd_h_get_32 (abfd, hashtable + (srch * 8));
d3640 1
a3640 1
      element = (*backend->get_elt_at_filepos) (abfd, file_offset);
d3676 1
a3676 1
  size_t esize;
d3699 2
a3700 2
  if (bfd_seek (abfd, symhdr->cbExtOffset, SEEK_SET) != 0
      || bfd_read (external_ext, 1, esize, abfd) != esize)
d3703 1
a3703 1
  ssext = (char *) bfd_malloc (symhdr->issExtMax);
d3707 3
a3709 3
  if (bfd_seek (abfd, symhdr->cbSsExtOffset, SEEK_SET) != 0
      || (bfd_read (ssext, 1, symhdr->issExtMax, abfd) !=
	  (bfd_size_type) symhdr->issExtMax))
d3799 1
a3799 1
  size_t esize;
d3819 2
a3820 2
  if (bfd_seek (abfd, symhdr->cbExtOffset, SEEK_SET) != 0
      || bfd_read (external_ext, 1, esize, abfd) != esize)
d3823 1
a3823 1
  ssext = (char *) bfd_malloc (symhdr->issExtMax);
d3827 2
a3828 2
  if (bfd_seek (abfd, symhdr->cbSsExtOffset, SEEK_SET) != 0
      || (bfd_read (ssext, 1, symhdr->issExtMax, abfd)
d3869 1
d3873 3
a3875 3
  sym_hash = ((struct ecoff_link_hash_entry **)
	      bfd_alloc (abfd,
			 ext_count * sizeof (struct bfd_link_hash_entry *)));
d4012 1
a4012 1
	      esym.weakext ? BSF_WEAK : BSF_GLOBAL,
d4301 18
a4318 19
#define READ(ptr, offset, count, size, type)				\
  if (symhdr->count == 0)						\
    debug->ptr = NULL;							\
  else									\
    {									\
      debug->ptr = (type) bfd_malloc ((size_t) (size * symhdr->count));	\
      if (debug->ptr == NULL)						\
	{								\
          ret = false;							\
          goto return_something;					\
	}								\
      if ((bfd_seek (input_bfd, (file_ptr) symhdr->offset, SEEK_SET)	\
	   != 0)							\
	  || (bfd_read (debug->ptr, size, symhdr->count,		\
			input_bfd) != size * symhdr->count))		\
	{								\
          ret = false;							\
          goto return_something;					\
	}								\
d4540 1
d4562 3
a4564 4
  contents = (bfd_byte *) bfd_malloc (raw_size >= cooked_size
				      ? (size_t) raw_size
				      : (size_t) cooked_size);
  if (contents == NULL && raw_size != 0)
d4591 1
a4591 1
      external_relocs = (PTR) bfd_malloc ((size_t) external_relocs_size);
d4596 1
a4596 1
	  || (bfd_read (external_relocs, 1, external_relocs_size, input_bfd)
d4611 1
a4611 1
				  input_section->output_offset,
d4621 4
a4624 5
      if (bfd_seek (output_bfd,
		    (output_section->rel_filepos +
		     output_section->reloc_count * external_reloc_size),
		    SEEK_SET) != 0
	  || (bfd_write (external_relocs, 1, external_relocs_size, output_bfd)
d4664 1
a4723 1
      boolean ok;
d4729 2
a4730 1
      rstat = _bfd_relocate_contents (rel.howto, output_bfd, addend, buf);
d4789 1
a4789 1
      CONST char *name;
d4832 1
a4832 1
  rbuf = (bfd_byte *) bfd_malloc ((size_t) external_reloc_size);
d4838 4
a4841 5
  ok = (bfd_seek (output_bfd,
		  (output_section->rel_filepos +
		   output_section->reloc_count * external_reloc_size),
		  SEEK_SET) == 0
	&& (bfd_write ((PTR) rbuf, 1, external_reloc_size, output_bfd)
@


1.9
log
@Add a flag to asection, linker_has_input, and use it to reliably
determine whether an input section is the first one assigned to
an output section.
@
text
@d374 2
a375 2
flagword
_bfd_ecoff_styp_to_sec_flags (abfd, hdr, name, section)
d380 1
d384 1
a384 1
  flagword sec_flags=0;
d426 1
a426 3
    {
      sec_flags |= SEC_ALLOC;
    }
d428 1
a428 3
    {
      sec_flags |= SEC_NEVER_LOAD;
    }
d432 1
a432 3
    {
      sec_flags |= SEC_DATA | SEC_LOAD | SEC_ALLOC | SEC_READONLY;
    }
d434 1
a434 3
    {
      sec_flags |= SEC_COFF_SHARED_LIBRARY;
    }
d436 1
a436 3
    {
      sec_flags |= SEC_ALLOC | SEC_LOAD;
    }
d438 2
a439 1
  return sec_flags;
@


1.8
log
@	* ecoff.c (bfd_debug_section): Fix initialization.
	* elf.c (_bfd_elf_slurp_version_tables): Change maxidx to unsigned, it
	is always a positive integer. Cast away sign mismatch.
	* elf32-mips.c: Fix misleading comment and typo.
	(_bfd_mips_elf_section_from_bfd_section): Remove unused attribute, use
	correct data type.
	* elflink.c: Fix typo.
	(_bfd_elf_create_dynamic_sections): Remove superfluous initialization.
	* ecoffswap.h (ecoff_swap_fdr_in): Cast away sign mismatch.
@
text
@d77 8
a84 6
  /* name,   id,  index, next, flags, user_set_vma, reloc_done,    */ 
  "*DEBUG*", 0,   0,     NULL, 0,     0,            0,        
  /* linker_mark, gc_mark, segment_mark, vma, lma, _cooked_size,   */ 
     0,           0,       0,            0,   0,   0,
  /* _raw_size, output_offset, output_section, alignment_power,    */
     0,         0,             NULL,           0,
@


1.7
log
@Update copyright notices
@
text
@d78 1
a78 1
  "*DEBUG*", 0,    0,    0,     0,    0,            0,        
d84 1
a84 1
     0,          0,           0,           0,       0,
d87 4
a90 4
  /* comdat, kept_section, moving_line_filepos, target_index,      */
     NULL,   NULL,         0,                   0,
  /* used_by_bfd, constructor_chain, owner,                        */
     NULL,        NULL,              NULL,
@


1.6
log
@Fix initialisation of asection structure
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.5
log
@2000-11-21  Kazu Hirata  <kazu@@hxi.com>

	* ecoff.c: Fix formatting.
	* ecofflink.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d77 20
a96 14
  /* name,   index, next, flags, set_vma, reloc_done, linker_mark, gc_mark */
  "*DEBUG*", 0,     0,    0,     0,       0,          0,           0,
  /* vma, lma, _cooked_size, _raw_size, output_offset, output_section, */
  0,      0,   0,            0,         0,             NULL,
  /* alig, reloc..., orel..., reloc_count, filepos, rel_..., line_... */
  0,       0,        0,       0,           0,       0, 	   0,
  /* userdata, contents, lineno, lineno_count */
  0,           0,        0,      0,
  /* comdat_info, moving_line_filepos, target_index, used_by_bfd,  */
  NULL,           0,                   0,            0,
  /* cons, owner, symbol */
  0,       0,     (struct symbol_cache_entry *) NULL,
  /* symbol_ptr_ptr,                   link_order_head, ..._tail */
  (struct symbol_cache_entry **) NULL, NULL,            NULL
@


1.5.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
d77 14
a90 22
  /* name,   id,  index, next, flags, user_set_vma, reloc_done,    */
  "*DEBUG*", 0,   0,     NULL, 0,     0,            0,
  /* linker_mark, linker_has_input, gc_mark, segment_mark,         */
     0,           0,                0,       0,
  /* vma, lma, _cooked_size, _raw_size,                            */ 
     0,   0,   0,            0,
  /* output_offset, output_section, alignment_power,               */
     0,             NULL,           0,
  /* relocation, orelocation, reloc_count, filepos, rel_filepos,   */
     NULL,       NULL,        0,           0,       0,
  /* line_filepos, userdata, contents, lineno, lineno_count,       */
     0,            NULL,     NULL,     NULL,   0,
  /* comdat, kept_section, moving_line_filepos,                    */
     NULL,   NULL,         0,
  /* target_index, used_by_bfd, constructor_chain, owner,          */
     0,            NULL,        NULL,              NULL,
  /* symbol,                                                       */
     (struct symbol_cache_entry *) NULL,
  /* symbol_ptr_ptr,                                               */
     (struct symbol_cache_entry **) NULL,
  /* link_order_head, link_order_tail                              */
     NULL,            NULL
@


1.4
log
@	* ecoff.c (bfd_debug_section): Update initialization for new
	comdat_info field.
	(_bfd_ecoff_styp_to_sec_flags): Add section parameter.
	* libecoff.h (_bfd_ecoff_styp_to_sec_flags): Update declaration.

1999-09-10  H.J. Lu  <hjl@@gnu.org>

	* coff-alpha.c (alpha_ecoff_backend_data): Initialize the new
	_bfd_filnmlen field.
	* coff-mips.c (mips_ecoff_backend_data): Likewise.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d347 1
a347 1
  else if (flags & SEC_CODE) 
d349 1
a349 1
  else if (flags & SEC_DATA) 
a365 1
/*ARGSUSED*/
d454 1
a454 1
  if (ecoff_data (abfd)->debug_info.symbolic_header.magic == 
a510 1
/*ARGSUSED*/
d1091 1
a1091 1
  
a1340 1

d1406 1
a1406 1
		   programmer writes them).  C is such a fun language.... */
a1446 1
/*ARGSUSED*/
a1457 1
/*ARGSUSED*/
d1488 1
a1488 1
	
d1602 1
a1602 1
		  fprintf (file, _("\n      First symbol: %ld"), 
d1678 1
a1678 1
  
d1776 1
a1776 1
  if (section->flags & SEC_CONSTRUCTOR) 
d1789 1
a1789 1
    { 
a1809 1
/*ARGSUSED*/
a1980 1
/*ARGSUSED*/
d1992 2
a1993 2
       current != (asection *)NULL; 
       current = current->next) 
d2214 1
a2214 1
  
d2219 2
a2220 2
       current != (asection *)NULL; 
       current = current->next) 
d2308 1
a2308 1
  
d2487 2
a2488 2
       current != (asection *)NULL; 
       current = current->next) 
d2626 1
a2626 1
    }	
d2778 1
a2778 1
	  
d2978 1
a2978 1
  
d3030 1
a3030 1
    
d3034 1
a3034 1
    
d3042 1
a3042 1
    
d3071 1
a3071 1
      
d3163 1
a3163 1
  /* Include 8 bytes to store symdefsize and stringsize in output. */
d3197 1
a3197 1
  /* Building gcc ends up extracting the armap as a file - twice. */
d3210 2
a3211 2
   if (((char *)(&hdr))[i] == '\0')
     (((char *)(&hdr))[i]) = ' ';
d3220 1
a3220 1
  
d3262 1
a3262 1
	
d3341 1
a3341 1
  
d3349 1
a3349 1
  
d4387 1
a4387 1
  /* We need to check if this symbol is being stripped. */
d4423 1
a4423 1
	
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d77 14
a90 3
  "*DEBUG*", 0, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, 0, NULL, NULL,
   0, 0, 0, 0, NULL, NULL, NULL, 0, 0, 0, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL
d368 1
a368 1
_bfd_ecoff_styp_to_sec_flags (abfd, hdr, name)
d372 1
@


1.2
log
@	* ecoff.c (_bfd_ecoff_write_armap): give the symtab element a
	reasonable mode until "ar x" is smart enough to skip it (fixes
	gcc/libgcc.a builds on mips-ecoff targets
	* coffcode.h (styp_to_sec_flags): Explain how COMDATs are supposed
	to work.  Hack to support MS import libraries, which use different
	COMDAT types than GNU.
	(coff_slurp_symbol_table): C_SECTION symbols are local; they refer
	to implied zero-length sections (see peicode below)
	* coffgen.c (coff_get_normalized_symtab): Properly read long MS
	filename symbols, which use one *or more* auxents.
	* coffswap.h (coff_swap_aux_in): ditto
	* peicode.h (coff_swap_sym_in): Build the implied zero-length
	sections
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d75 6
a80 1
static asection bfd_debug_section = { "*DEBUG*" };
d146 1
a146 1
     bfd *abfd;
d358 1
a358 1
     bfd *abfd;
d360 1
a360 1
     const char *name;
d504 1
a504 1
     asection *ignore;
d1441 1
a1441 1
     bfd *abfd;			/* Ignored.  */
d1453 1
a1453 1
     bfd *abfd;
d1809 1
a1809 1
     asymbol **ignore_symbols;
d1979 1
a1979 1
     boolean reloc;
@


1.1
log
@Initial revision
@
text
@d3184 1
d3186 6
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

