head	1.233;
access;
symbols
	sid-snapshot-20180601:1.233
	sid-snapshot-20180501:1.233
	sid-snapshot-20180401:1.233
	sid-snapshot-20180301:1.233
	sid-snapshot-20180201:1.233
	sid-snapshot-20180101:1.233
	sid-snapshot-20171201:1.233
	sid-snapshot-20171101:1.233
	sid-snapshot-20171001:1.233
	sid-snapshot-20170901:1.233
	sid-snapshot-20170801:1.233
	sid-snapshot-20170701:1.233
	sid-snapshot-20170601:1.233
	sid-snapshot-20170501:1.233
	sid-snapshot-20170401:1.233
	sid-snapshot-20170301:1.233
	sid-snapshot-20170201:1.233
	sid-snapshot-20170101:1.233
	sid-snapshot-20161201:1.233
	sid-snapshot-20161101:1.233
	sid-snapshot-20160901:1.233
	sid-snapshot-20160801:1.233
	sid-snapshot-20160701:1.233
	sid-snapshot-20160601:1.233
	sid-snapshot-20160501:1.233
	sid-snapshot-20160401:1.233
	sid-snapshot-20160301:1.233
	sid-snapshot-20160201:1.233
	sid-snapshot-20160101:1.233
	sid-snapshot-20151201:1.233
	sid-snapshot-20151101:1.233
	sid-snapshot-20151001:1.233
	sid-snapshot-20150901:1.233
	sid-snapshot-20150801:1.233
	sid-snapshot-20150701:1.233
	sid-snapshot-20150601:1.233
	sid-snapshot-20150501:1.233
	sid-snapshot-20150401:1.233
	sid-snapshot-20150301:1.233
	sid-snapshot-20150201:1.233
	sid-snapshot-20150101:1.233
	sid-snapshot-20141201:1.233
	sid-snapshot-20141101:1.233
	sid-snapshot-20141001:1.233
	sid-snapshot-20140901:1.233
	sid-snapshot-20140801:1.233
	sid-snapshot-20140701:1.233
	sid-snapshot-20140601:1.233
	sid-snapshot-20140501:1.233
	sid-snapshot-20140401:1.233
	sid-snapshot-20140301:1.233
	sid-snapshot-20140201:1.233
	sid-snapshot-20140101:1.233
	sid-snapshot-20131201:1.233
	sid-snapshot-20131101:1.233
	sid-snapshot-20131001:1.233
	binutils-2_24-branch:1.233.0.14
	binutils-2_24-branchpoint:1.233
	binutils-2_21_1:1.228.2.2
	sid-snapshot-20130901:1.233
	gdb_7_6_1-2013-08-30-release:1.233
	sid-snapshot-20130801:1.233
	sid-snapshot-20130701:1.233
	sid-snapshot-20130601:1.233
	sid-snapshot-20130501:1.233
	gdb_7_6-2013-04-26-release:1.233
	sid-snapshot-20130401:1.233
	binutils-2_23_2:1.233
	gdb_7_6-branch:1.233.0.12
	gdb_7_6-2013-03-12-branchpoint:1.233
	sid-snapshot-20130301:1.233
	sid-snapshot-20130201:1.233
	sid-snapshot-20130101:1.233
	sid-snapshot-20121201:1.233
	gdb_7_5_1-2012-11-29-release:1.233
	binutils-2_23_1:1.233
	sid-snapshot-20121101:1.233
	binutils-2_23:1.233
	sid-snapshot-20121001:1.233
	sid-snapshot-20120901:1.233
	gdb_7_5-2012-08-17-release:1.233
	sid-snapshot-20120801:1.233
	binutils-2_23-branch:1.233.0.10
	binutils-2_23-branchpoint:1.233
	gdb_7_5-branch:1.233.0.8
	gdb_7_5-2012-07-18-branchpoint:1.233
	sid-snapshot-20120701:1.233
	sid-snapshot-20120601:1.233
	sid-snapshot-20120501:1.233
	binutils-2_22_branch:1.233.0.6
	gdb_7_4_1-2012-04-26-release:1.233
	sid-snapshot-20120401:1.233
	sid-snapshot-20120301:1.233
	sid-snapshot-20120201:1.233
	gdb_7_4-2012-01-24-release:1.233
	sid-snapshot-20120101:1.233
	gdb_7_4-branch:1.233.0.4
	gdb_7_4-2011-12-13-branchpoint:1.233
	sid-snapshot-20111201:1.233
	binutils-2_22:1.233
	sid-snapshot-20111101:1.233
	sid-snapshot-20111001:1.233
	binutils-2_22-branch:1.233.0.2
	binutils-2_22-branchpoint:1.233
	gdb_7_3_1-2011-09-04-release:1.230.2.1
	sid-snapshot-20110901:1.233
	sid-snapshot-20110801:1.233
	gdb_7_3-2011-07-26-release:1.230.2.1
	sid-snapshot-20110701:1.233
	sid-snapshot-20110601:1.233
	sid-snapshot-20110501:1.232
	gdb_7_3-branch:1.230.0.2
	gdb_7_3-2011-04-01-branchpoint:1.230
	sid-snapshot-20110401:1.231
	sid-snapshot-20110301:1.230
	sid-snapshot-20110201:1.230
	sid-snapshot-20110101:1.229
	binutils-2_21:1.228
	sid-snapshot-20101201:1.229
	binutils-2_21-branch:1.228.0.2
	binutils-2_21-branchpoint:1.228
	sid-snapshot-20101101:1.228
	sid-snapshot-20101001:1.226
	binutils-2_20_1:1.215
	gdb_7_2-2010-09-02-release:1.224
	sid-snapshot-20100901:1.225
	sid-snapshot-20100801:1.224
	gdb_7_2-branch:1.224.0.2
	gdb_7_2-2010-07-07-branchpoint:1.224
	sid-snapshot-20100701:1.224
	sid-snapshot-20100601:1.222
	sid-snapshot-20100501:1.221
	sid-snapshot-20100401:1.221
	gdb_7_1-2010-03-18-release:1.221
	sid-snapshot-20100301:1.221
	gdb_7_1-branch:1.221.0.2
	gdb_7_1-2010-02-18-branchpoint:1.221
	sid-snapshot-20100201:1.219
	sid-snapshot-20100101:1.219
	gdb_7_0_1-2009-12-22-release:1.215
	sid-snapshot-20091201:1.218
	sid-snapshot-20091101:1.215
	binutils-2_20:1.215
	gdb_7_0-2009-10-06-release:1.215
	sid-snapshot-20091001:1.215
	gdb_7_0-branch:1.215.0.4
	gdb_7_0-2009-09-16-branchpoint:1.215
	arc-sim-20090309:1.206
	binutils-arc-20081103-branch:1.207.0.14
	binutils-arc-20081103-branchpoint:1.207
	binutils-2_20-branch:1.215.0.2
	binutils-2_20-branchpoint:1.215
	sid-snapshot-20090901:1.214
	sid-snapshot-20090801:1.212
	msnyder-checkpoint-072509-branch:1.212.0.4
	msnyder-checkpoint-072509-branchpoint:1.212
	sid-snapshot-20090701:1.212
	dje-cgen-play1-branch:1.212.0.2
	dje-cgen-play1-branchpoint:1.212
	sid-snapshot-20090601:1.210
	sid-snapshot-20090501:1.209
	sid-snapshot-20090401:1.209
	arc-20081103-branch:1.207.0.12
	arc-20081103-branchpoint:1.207
	arc-insight_6_8-branch:1.206.0.6
	arc-insight_6_8-branchpoint:1.206
	insight_6_8-branch:1.206.0.4
	insight_6_8-branchpoint:1.206
	sid-snapshot-20090301:1.209
	binutils-2_19_1:1.207
	sid-snapshot-20090201:1.209
	sid-snapshot-20090101:1.208
	reverse-20081226-branch:1.208.0.2
	reverse-20081226-branchpoint:1.208
	sid-snapshot-20081201:1.207
	multiprocess-20081120-branch:1.207.0.10
	multiprocess-20081120-branchpoint:1.207
	sid-snapshot-20081101:1.207
	binutils-2_19:1.207
	sid-snapshot-20081001:1.207
	reverse-20080930-branch:1.207.0.8
	reverse-20080930-branchpoint:1.207
	binutils-2_19-branch:1.207.0.6
	binutils-2_19-branchpoint:1.207
	sid-snapshot-20080901:1.207
	sid-snapshot-20080801:1.207
	reverse-20080717-branch:1.207.0.4
	reverse-20080717-branchpoint:1.207
	sid-snapshot-20080701:1.207
	msnyder-reverse-20080609-branch:1.207.0.2
	msnyder-reverse-20080609-branchpoint:1.207
	drow-reverse-20070409-branch:1.197.0.2
	drow-reverse-20070409-branchpoint:1.197
	sid-snapshot-20080601:1.207
	sid-snapshot-20080501:1.207
	sid-snapshot-20080403:1.207
	sid-snapshot-20080401:1.207
	gdb_6_8-2008-03-27-release:1.206
	sid-snapshot-20080301:1.206
	gdb_6_8-branch:1.206.0.2
	gdb_6_8-2008-02-26-branchpoint:1.206
	sid-snapshot-20080201:1.206
	sid-snapshot-20080101:1.206
	sid-snapshot-20071201:1.203
	sid-snapshot-20071101:1.203
	gdb_6_7_1-2007-10-29-release:1.203
	gdb_6_7-2007-10-10-release:1.203
	sid-snapshot-20071001:1.203
	gdb_6_7-branch:1.203.0.2
	gdb_6_7-2007-09-07-branchpoint:1.203
	binutils-2_18:1.200
	binutils-2_18-branch:1.200.0.2
	binutils-2_18-branchpoint:1.200
	insight_6_6-20070208-release:1.193
	binutils-csl-coldfire-4_1-32:1.180.2.1
	binutils-csl-sourcerygxx-4_1-32:1.180.2.1
	gdb_6_6-2006-12-18-release:1.193
	binutils-csl-innovasic-fido-3_4_4-33:1.180.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.148
	binutils-csl-coldfire-4_1-30:1.180.2.1
	binutils-csl-sourcerygxx-4_1-30:1.180.2.1
	binutils-csl-coldfire-4_1-28:1.180.2.1
	binutils-csl-sourcerygxx-4_1-29:1.180.2.1
	binutils-csl-sourcerygxx-4_1-28:1.180.2.1
	gdb_6_6-branch:1.193.0.2
	gdb_6_6-2006-11-15-branchpoint:1.193
	binutils-csl-arm-2006q3-27:1.180.2.1
	binutils-csl-sourcerygxx-4_1-27:1.180.2.1
	binutils-csl-arm-2006q3-26:1.180.2.1
	binutils-csl-sourcerygxx-4_1-26:1.180.2.1
	binutils-csl-sourcerygxx-4_1-25:1.180.2.1
	binutils-csl-sourcerygxx-4_1-24:1.180.2.1
	binutils-csl-sourcerygxx-4_1-23:1.180.2.1
	insight_6_5-20061003-release:1.182
	gdb-csl-symbian-6_4_50_20060226-12:1.177
	binutils-csl-sourcerygxx-4_1-21:1.180.2.1
	binutils-csl-arm-2006q3-21:1.180.2.1
	binutils-csl-sourcerygxx-4_1-22:1.180.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.180.2.1
	binutils-csl-sourcerygxx-4_1-20:1.180.2.1
	binutils-csl-arm-2006q3-19:1.180.2.1
	binutils-csl-sourcerygxx-4_1-19:1.180.2.1
	binutils-csl-sourcerygxx-4_1-18:1.180.2.1
	binutils-csl-renesas-4_1-9:1.180.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.175
	binutils-csl-sourcerygxx-3_4_4-25:1.148
	nickrob-async-20060828-mergepoint:1.188
	gdb-csl-symbian-6_4_50_20060226-11:1.177
	binutils-csl-renesas-4_1-8:1.180
	binutils-csl-renesas-4_1-7:1.180
	binutils-csl-renesas-4_1-6:1.180
	gdb-csl-sourcerygxx-4_1-17:1.177
	binutils-csl-sourcerygxx-4_1-17:1.180
	gdb-csl-20060226-branch-local-2:1.177
	gdb-csl-sourcerygxx-4_1-14:1.177
	binutils-csl-sourcerygxx-4_1-14:1.180
	binutils-csl-sourcerygxx-4_1-15:1.180
	gdb-csl-sourcerygxx-4_1-13:1.177
	binutils-csl-sourcerygxx-4_1-13:1.180
	binutils-2_17:1.182
	gdb-csl-sourcerygxx-4_1-12:1.177
	binutils-csl-sourcerygxx-4_1-12:1.180
	gdb-csl-sourcerygxx-3_4_4-21:1.177
	binutils-csl-sourcerygxx-3_4_4-21:1.180
	gdb_6_5-20060621-release:1.182
	binutils-csl-wrs-linux-3_4_4-24:1.148
	binutils-csl-wrs-linux-3_4_4-23:1.148
	gdb-csl-sourcerygxx-4_1-9:1.177
	binutils-csl-sourcerygxx-4_1-9:1.180
	gdb-csl-sourcerygxx-4_1-8:1.177
	binutils-csl-sourcerygxx-4_1-8:1.180
	gdb-csl-sourcerygxx-4_1-7:1.177
	binutils-csl-sourcerygxx-4_1-7:1.180
	gdb-csl-arm-2006q1-6:1.177
	binutils-csl-arm-2006q1-6:1.180
	gdb-csl-sourcerygxx-4_1-6:1.177
	binutils-csl-sourcerygxx-4_1-6:1.180
	binutils-csl-wrs-linux-3_4_4-22:1.148
	gdb-csl-symbian-6_4_50_20060226-10:1.177
	gdb-csl-symbian-6_4_50_20060226-9:1.177
	gdb-csl-symbian-6_4_50_20060226-8:1.177
	gdb-csl-coldfire-4_1-11:1.177
	binutils-csl-coldfire-4_1-11:1.180
	gdb-csl-sourcerygxx-3_4_4-19:1.177
	binutils-csl-sourcerygxx-3_4_4-19:1.180
	gdb-csl-coldfire-4_1-10:1.177
	gdb_6_5-branch:1.182.0.10
	gdb_6_5-2006-05-14-branchpoint:1.182
	binutils-csl-coldfire-4_1-10:1.180
	gdb-csl-sourcerygxx-4_1-5:1.177
	binutils-csl-sourcerygxx-4_1-5:1.180
	nickrob-async-20060513-branch:1.182.0.8
	nickrob-async-20060513-branchpoint:1.182
	gdb-csl-sourcerygxx-4_1-4:1.177
	binutils-csl-sourcerygxx-4_1-4:1.180
	msnyder-reverse-20060502-branch:1.182.0.6
	msnyder-reverse-20060502-branchpoint:1.182
	binutils-csl-wrs-linux-3_4_4-21:1.148
	gdb-csl-morpho-4_1-4:1.177
	binutils-csl-morpho-4_1-4:1.180
	gdb-csl-sourcerygxx-3_4_4-17:1.177
	binutils-csl-sourcerygxx-3_4_4-17:1.180
	binutils-csl-wrs-linux-3_4_4-20:1.148
	readline_5_1-import-branch:1.182.0.4
	readline_5_1-import-branchpoint:1.182
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.177
	binutils-2_17-branch:1.182.0.2
	binutils-2_17-branchpoint:1.182
	gdb-csl-symbian-20060226-branch:1.177.0.4
	gdb-csl-symbian-20060226-branchpoint:1.177
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.177
	msnyder-reverse-20060331-branch:1.180.0.4
	msnyder-reverse-20060331-branchpoint:1.180
	binutils-csl-2_17-branch:1.180.0.2
	binutils-csl-2_17-branchpoint:1.180
	gdb-csl-available-20060303-branch:1.178.0.2
	gdb-csl-available-20060303-branchpoint:1.178
	gdb-csl-20060226-branch:1.177.0.2
	gdb-csl-20060226-branchpoint:1.177
	gdb_6_4-20051202-release:1.175
	msnyder-fork-checkpoint-branch:1.175.0.6
	msnyder-fork-checkpoint-branchpoint:1.175
	gdb-csl-gxxpro-6_3-branch:1.175.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.175
	gdb_6_4-branch:1.175.0.2
	gdb_6_4-2005-11-01-branchpoint:1.175
	gdb-csl-arm-20051020-branch:1.174.0.2
	gdb-csl-arm-20051020-branchpoint:1.174
	binutils-csl-gxxpro-3_4-branch:1.148.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.148
	binutils-2_16_1:1.148
	msnyder-tracepoint-checkpoint-branch:1.164.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.164
	gdb-csl-arm-20050325-2005-q1b:1.151
	binutils-csl-arm-2005q1b:1.148
	binutils-2_16:1.148
	gdb-csl-arm-20050325-2005-q1a:1.151
	binutils-csl-arm-2005q1a:1.148
	csl-arm-20050325-branch:1.151.0.2
	csl-arm-20050325-branchpoint:1.151
	binutils-csl-arm-2005q1-branch:1.148.0.4
	binutils-csl-arm-2005q1-branchpoint:1.148
	binutils-2_16-branch:1.148.0.2
	binutils-2_16-branchpoint:1.148
	csl-arm-2004-q3d:1.144
	gdb_6_3-20041109-release:1.141
	gdb_6_3-branch:1.141.0.2
	gdb_6_3-20041019-branchpoint:1.141
	csl-arm-2004-q3:1.140
	drow_intercu-merge-20040921:1.140
	drow_intercu-merge-20040915:1.138
	jimb-gdb_6_2-e500-branch:1.134.0.6
	jimb-gdb_6_2-e500-branchpoint:1.134
	gdb_6_2-20040730-release:1.134
	gdb_6_2-branch:1.134.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.134
	gdb_6_1_1-20040616-release:1.119
	binutils-2_15:1.117.4.3
	binutils-2_15-branchpoint:1.117
	csl-arm-2004-q1a:1.126
	csl-arm-2004-q1:1.125
	gdb_6_1-2004-04-05-release:1.119
	drow_intercu-merge-20040402:1.124
	drow_intercu-merge-20040327:1.123
	ezannoni_pie-20040323-branch:1.121.0.2
	ezannoni_pie-20040323-branchpoint:1.121
	cagney_tramp-20040321-mergepoint:1.120
	cagney_tramp-20040309-branch:1.120.0.2
	cagney_tramp-20040309-branchpoint:1.120
	gdb_6_1-branch:1.119.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.119
	drow_intercu-20040221-branch:1.117.0.6
	drow_intercu-20040221-branchpoint:1.117
	binutils-2_15-branch:1.117.0.4
	cagney_bfdfile-20040213-branch:1.117.0.2
	cagney_bfdfile-20040213-branchpoint:1.117
	drow-cplus-merge-20040208:1.117
	carlton_dictionary-20040126-merge:1.115
	cagney_bigcore-20040122-branch:1.115.0.2
	cagney_bigcore-20040122-branchpoint:1.115
	drow-cplus-merge-20040113:1.115
	csl-arm-2003-q4:1.114
	drow-cplus-merge-20031224:1.114
	drow-cplus-merge-20031220:1.114
	carlton_dictionary-20031215-merge:1.114
	drow-cplus-merge-20031214:1.114
	carlton-dictionary-20031111-merge:1.108
	gdb_6_0-2003-10-04-release:1.84
	kettenis_sparc-20030918-branch:1.100.0.4
	kettenis_sparc-20030918-branchpoint:1.100
	carlton_dictionary-20030917-merge:1.100
	ezannoni_pie-20030916-branchpoint:1.100
	ezannoni_pie-20030916-branch:1.100.0.2
	cagney_x86i386-20030821-branch:1.98.0.2
	cagney_x86i386-20030821-branchpoint:1.98
	carlton_dictionary-20030805-merge:1.95
	carlton_dictionary-20030627-merge:1.85
	gdb_6_0-branch:1.84.0.2
	gdb_6_0-2003-06-23-branchpoint:1.84
	jimb-ppc64-linux-20030613-branch:1.83.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.83
	binutils-2_14:1.77.4.2
	cagney_convert-20030606-branch:1.83.0.2
	cagney_convert-20030606-branchpoint:1.83
	cagney_writestrings-20030508-branch:1.82.0.8
	cagney_writestrings-20030508-branchpoint:1.82
	jimb-ppc64-linux-20030528-branch:1.82.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.82
	carlton_dictionary-20030523-merge:1.82
	cagney_fileio-20030521-branch:1.82.0.4
	cagney_fileio-20030521-branchpoint:1.82
	kettenis_i386newframe-20030517-mergepoint:1.82
	jimb-ppc64-linux-20030509-branch:1.82.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.82
	kettenis_i386newframe-20030504-mergepoint:1.78
	carlton_dictionary-20030430-merge:1.78
	binutils-2_14-branch:1.77.0.4
	binutils-2_14-branchpoint:1.77
	kettenis_i386newframe-20030419-branch:1.77.0.2
	kettenis_i386newframe-20030419-branchpoint:1.77
	carlton_dictionary-20030416-merge:1.77
	cagney_frameaddr-20030409-mergepoint:1.77
	kettenis_i386newframe-20030406-branch:1.76.0.4
	kettenis_i386newframe-20030406-branchpoint:1.76
	cagney_frameaddr-20030403-branchpoint:1.76
	cagney_frameaddr-20030403-branch:1.76.0.2
	cagney_framebase-20030330-mergepoint:1.75
	cagney_framebase-20030326-branch:1.74.0.2
	cagney_framebase-20030326-branchpoint:1.74
	cagney_lazyid-20030317-branch:1.71.0.6
	cagney_lazyid-20030317-branchpoint:1.71
	kettenis-i386newframe-20030316-mergepoint:1.71
	offbyone-20030313-branch:1.71.0.4
	offbyone-20030313-branchpoint:1.71
	kettenis-i386newframe-20030308-branch:1.71.0.2
	kettenis-i386newframe-20030308-branchpoint:1.71
	carlton_dictionary-20030305-merge:1.71
	cagney_offbyone-20030303-branch:1.70.0.2
	cagney_offbyone-20030303-branchpoint:1.70
	carlton_dictionary-20030207-merge:1.67
	interps-20030202-branch:1.66.0.2
	interps-20030202-branchpoint:1.66
	cagney-unwind-20030108-branch:1.64.0.2
	cagney-unwind-20030108-branchpoint:1.64
	binutils-2_13_2_1:1.52.2.4
	binutils-2_13_2:1.52.2.4
	carlton_dictionary-20021223-merge:1.64
	gdb_5_3-2002-12-12-release:1.57
	carlton_dictionary-20021115-merge:1.60
	binutils-2_13_1:1.52.2.4
	kseitz_interps-20021105-merge:1.59
	kseitz_interps-20021103-merge:1.59
	drow-cplus-merge-20021020:1.59
	drow-cplus-merge-20021025:1.59
	carlton_dictionary-20021025-merge:1.59
	carlton_dictionary-20021011-merge:1.59
	drow-cplus-branch:1.58.0.4
	drow-cplus-branchpoint:1.58
	kseitz_interps-20020930-merge:1.58
	carlton_dictionary-20020927-merge:1.58
	carlton_dictionary-branch:1.58.0.2
	carlton_dictionary-20020920-branchpoint:1.58
	sid-20020905-branchpoint:1.57
	sid-20020905-branch:1.57.0.8
	gdb_5_3-branch:1.57.0.6
	gdb_5_3-2002-09-04-branchpoint:1.57
	kseitz_interps-20020829-merge:1.57
	cagney_sysregs-20020825-branch:1.57.0.4
	cagney_sysregs-20020825-branchpoint:1.57
	readline_4_3-import-branch:1.57.0.2
	readline_4_3-import-branchpoint:1.57
	binutils-2_13:1.52.2.2
	gdb_5_2_1-2002-07-23-release:1.44
	binutils-2_13-branchpoint:1.52
	binutils-2_13-branch:1.52.0.2
	kseitz_interps-20020528-branch:1.48.0.2
	kseitz_interps-20020528-branchpoint:1.48
	cagney_regbuf-20020515-branch:1.47.0.2
	cagney_regbuf-20020515-branchpoint:1.47
	binutils-2_12_1:1.43.2.4
	jimb-macro-020506-branch:1.46.0.2
	jimb-macro-020506-branchpoint:1.46
	gdb_5_2-2002-04-29-release:1.44
	binutils-2_12:1.43.2.1
	gdb_5_2-branch:1.44.0.2
	gdb_5_2-2002-03-03-branchpoint:1.44
	binutils-2_12-branch:1.43.0.2
	binutils-2_12-branchpoint:1.43
	gdb_5_1_1-2002-01-24-release:1.18
	gdb_5_1_0_1-2002-01-03-release:1.18
	cygnus_cvs_20020108_pre:1.40
	gdb_5_1_0_1-2002-01-03-branch:1.18.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.18
	gdb_5_1-2001-11-21-release:1.18
	gdb_s390-2001-09-26-branch:1.18.0.4
	gdb_s390-2001-09-26-branchpoint:1.18
	gdb_5_1-2001-07-29-branch:1.18.0.2
	gdb_5_1-2001-07-29-branchpoint:1.18
	binutils-2_11_2:1.9.2.3
	binutils-2_11_1:1.9.2.3
	binutils-2_11:1.9.2.2
	x86_64versiong3:1.14
	binutils-2_11-branch:1.9.0.2
	insight-precleanup-2001-01-01:1.6
	binutils_latest_snapshot:1.233;
locks; strict;
comment	@ * @;


1.233
date	2011.05.25.12.02.16;	author gingold;	state Exp;
branches;
next	1.232;

1.232
date	2011.04.11.04.08.12;	author amodra;	state Exp;
branches;
next	1.231;

1.231
date	2011.04.01.08.38.55;	author gingold;	state Exp;
branches;
next	1.230;

1.230
date	2011.01.18.14.13.43;	author nickc;	state Exp;
branches
	1.230.2.1;
next	1.229;

1.229
date	2010.11.08.02.48.56;	author amodra;	state Exp;
branches;
next	1.228;

1.228
date	2010.10.25.15.54.16;	author drow;	state Exp;
branches
	1.228.2.1;
next	1.227;

1.227
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches;
next	1.226;

1.226
date	2010.09.24.12.14.25;	author tschwinge;	state Exp;
branches;
next	1.225;

1.225
date	2010.08.25.14.53.45;	author hjl;	state Exp;
branches;
next	1.224;

1.224
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches;
next	1.223;

1.223
date	2010.06.08.08.26.01;	author gingold;	state Exp;
branches;
next	1.222;

1.222
date	2010.05.14.07.18.39;	author gingold;	state Exp;
branches;
next	1.221;

1.221
date	2010.02.08.13.16.24;	author amodra;	state Exp;
branches;
next	1.220;

1.220
date	2010.02.04.09.16.41;	author nickc;	state Exp;
branches;
next	1.219;

1.219
date	2009.12.11.13.42.03;	author nickc;	state Exp;
branches;
next	1.218;

1.218
date	2009.11.17.22.31.40;	author hjl;	state Exp;
branches;
next	1.217;

1.217
date	2009.11.17.20.57.21;	author hjl;	state Exp;
branches;
next	1.216;

1.216
date	2009.11.17.19.21.53;	author hjl;	state Exp;
branches;
next	1.215;

1.215
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.214;

1.214
date	2009.09.01.13.10.45;	author gingold;	state Exp;
branches;
next	1.213;

1.213
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.212;

1.212
date	2009.06.16.17.45.08;	author hjl;	state Exp;
branches;
next	1.211;

1.211
date	2009.06.16.15.52.41;	author hjl;	state Exp;
branches;
next	1.210;

1.210
date	2009.05.27.13.31.23;	author nathan;	state Exp;
branches;
next	1.209;

1.209
date	2009.01.15.12.42.52;	author nickc;	state Exp;
branches;
next	1.208;

1.208
date	2008.12.23.14.36.40;	author hjl;	state Exp;
branches;
next	1.207;

1.207
date	2008.03.14.16.40.09;	author hjl;	state Exp;
branches;
next	1.206;

1.206
date	2007.12.31.19.23.07;	author hjl;	state Exp;
branches;
next	1.205;

1.205
date	2007.12.31.11.01.54;	author nickc;	state Exp;
branches;
next	1.204;

1.204
date	2007.12.24.16.55.39;	author hjl;	state Exp;
branches;
next	1.203;

1.203
date	2007.08.24.04.31.24;	author amodra;	state Exp;
branches;
next	1.202;

1.202
date	2007.08.22.16.01.12;	author hjl;	state Exp;
branches;
next	1.201;

1.201
date	2007.08.22.13.44.37;	author hjl;	state Exp;
branches;
next	1.200;

1.200
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.199;

1.199
date	2007.06.19.13.05.55;	author hjl;	state Exp;
branches;
next	1.198;

1.198
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.197;

1.197
date	2007.03.26.23.35.34;	author schwab;	state Exp;
branches;
next	1.196;

1.196
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.195;

1.195
date	2007.03.14.02.56.45;	author hjl;	state Exp;
branches;
next	1.194;

1.194
date	2007.03.07.08.54.35;	author amodra;	state Exp;
branches;
next	1.193;

1.193
date	2006.11.03.00.58.10;	author drow;	state Exp;
branches;
next	1.192;

1.192
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.191;

1.191
date	2006.10.16.17.21.44;	author schwab;	state Exp;
branches;
next	1.190;

1.190
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.189;

1.189
date	2006.09.07.17.16.31;	author hjl;	state Exp;
branches;
next	1.188;

1.188
date	2006.07.26.19.56.16;	author schwab;	state Exp;
branches;
next	1.187;

1.187
date	2006.06.20.14.34.08;	author amodra;	state Exp;
branches;
next	1.186;

1.186
date	2006.06.20.02.22.13;	author amodra;	state Exp;
branches;
next	1.185;

1.185
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.184;

1.184
date	2006.05.30.16.45.31;	author hjl;	state Exp;
branches;
next	1.183;

1.183
date	2006.05.19.14.08.02;	author hjl;	state Exp;
branches;
next	1.182;

1.182
date	2006.04.06.18.52.46;	author hjl;	state Exp;
branches;
next	1.181;

1.181
date	2006.04.05.21.12.06;	author hjl;	state Exp;
branches;
next	1.180;

1.180
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches
	1.180.2.1;
next	1.179;

1.179
date	2006.03.08.21.24.22;	author hjl;	state Exp;
branches;
next	1.178;

1.178
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.177;

1.177
date	2006.02.24.15.47.24;	author hjl;	state Exp;
branches;
next	1.176;

1.176
date	2006.02.06.21.55.39;	author sje;	state Exp;
branches;
next	1.175;

1.175
date	2005.10.25.16.19.08;	author amodra;	state Exp;
branches;
next	1.174;

1.174
date	2005.09.09.05.11.51;	author hjl;	state Exp;
branches;
next	1.173;

1.173
date	2005.08.29.22.25.04;	author hjl;	state Exp;
branches;
next	1.172;

1.172
date	2005.08.10.04.32.49;	author hjl;	state Exp;
branches;
next	1.171;

1.171
date	2005.08.04.00.39.02;	author hjl;	state Exp;
branches;
next	1.170;

1.170
date	2005.08.02.19.58.11;	author schwab;	state Exp;
branches;
next	1.169;

1.169
date	2005.07.08.00.26.52;	author hjl;	state Exp;
branches;
next	1.168;

1.168
date	2005.07.05.09.44.19;	author jakub;	state Exp;
branches;
next	1.167;

1.167
date	2005.07.05.06.23.37;	author amodra;	state Exp;
branches;
next	1.166;

1.166
date	2005.07.04.01.53.40;	author amodra;	state Exp;
branches;
next	1.165;

1.165
date	2005.06.27.21.08.10;	author hjl;	state Exp;
branches;
next	1.164;

1.164
date	2005.05.17.17.26.27;	author hjl;	state Exp;
branches;
next	1.163;

1.163
date	2005.05.17.17.23.37;	author hjl;	state Exp;
branches;
next	1.162;

1.162
date	2005.05.16.17.55.55;	author hjl;	state Exp;
branches;
next	1.161;

1.161
date	2005.05.07.13.22.54;	author hjl;	state Exp;
branches;
next	1.160;

1.160
date	2005.05.05.14.34.02;	author hjl;	state Exp;
branches;
next	1.159;

1.159
date	2005.05.04.22.20.25;	author hjl;	state Exp;
branches;
next	1.158;

1.158
date	2005.05.04.15.53.29;	author nickc;	state Exp;
branches;
next	1.157;

1.157
date	2005.05.04.11.00.21;	author amodra;	state Exp;
branches;
next	1.156;

1.156
date	2005.05.04.07.19.25;	author nickc;	state Exp;
branches;
next	1.155;

1.155
date	2005.05.03.17.05.50;	author amodra;	state Exp;
branches;
next	1.154;

1.154
date	2005.05.03.01.05.01;	author hjl;	state Exp;
branches;
next	1.153;

1.153
date	2005.04.27.20.16.08;	author hjl;	state Exp;
branches;
next	1.152;

1.152
date	2005.04.05.04.01.09;	author hjl;	state Exp;
branches;
next	1.151;

1.151
date	2005.03.20.23.36.18;	author hjl;	state Exp;
branches;
next	1.150;

1.150
date	2005.03.18.21.31.31;	author schwab;	state Exp;
branches;
next	1.149;

1.149
date	2005.03.14.18.55.44;	author hjl;	state Exp;
branches;
next	1.148;

1.148
date	2005.02.16.04.45.23;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2005.02.15.07.37.10;	author jbeulich;	state Exp;
branches;
next	1.146;

1.146
date	2005.02.15.01.54.58;	author hjl;	state Exp;
branches;
next	1.145;

1.145
date	2005.02.02.01.16.36;	author amodra;	state Exp;
branches;
next	1.144;

1.144
date	2004.10.28.14.55.41;	author hjl;	state Exp;
branches;
next	1.143;

1.143
date	2004.10.27.00.46.05;	author hjl;	state Exp;
branches;
next	1.142;

1.142
date	2004.10.21.15.28.29;	author hjl;	state Exp;
branches;
next	1.141;

1.141
date	2004.10.10.13.58.05;	author amodra;	state Exp;
branches;
next	1.140;

1.140
date	2004.09.17.07.14.30;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2004.09.16.14.52.08;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2004.08.13.03.15.59;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2004.07.30.15.37.04;	author hjl;	state Exp;
branches;
next	1.136;

1.136
date	2004.07.26.21.01.15;	author hjl;	state Exp;
branches;
next	1.135;

1.135
date	2004.07.11.03.15.29;	author wilson;	state Exp;
branches;
next	1.134;

1.134
date	2004.07.09.19.27.15;	author hjl;	state Exp;
branches;
next	1.133;

1.133
date	2004.06.30.20.23.23;	author wilson;	state Exp;
branches;
next	1.132;

1.132
date	2004.06.30.03.51.25;	author hjl;	state Exp;
branches;
next	1.131;

1.131
date	2004.06.24.04.46.23;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2004.06.22.06.03.07;	author hjl;	state Exp;
branches;
next	1.129;

1.129
date	2004.05.29.19.25.54;	author hjl;	state Exp;
branches;
next	1.128;

1.128
date	2004.05.28.20.30.29;	author hjl;	state Exp;
branches;
next	1.127;

1.127
date	2004.05.22.01.56.31;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2004.04.27.03.13.15;	author amodra;	state Exp;
branches;
next	1.125;

1.125
date	2004.04.06.00.59.22;	author hjl;	state Exp;
branches;
next	1.124;

1.124
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2004.03.26.06.13.40;	author amodra;	state Exp;
branches;
next	1.122;

1.122
date	2004.03.25.12.48.42;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2004.03.22.02.28.17;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2004.03.09.20.50.56;	author wilson;	state Exp;
branches;
next	1.119;

1.119
date	2004.02.26.17.45.19;	author hjl;	state Exp;
branches;
next	1.118;

1.118
date	2004.02.26.03.54.06;	author hjl;	state Exp;
branches;
next	1.117;

1.117
date	2004.01.30.23.13.28;	author hjl;	state Exp;
branches
	1.117.4.1
	1.117.6.1;
next	1.116;

1.116
date	2004.01.26.20.32.08;	author hjl;	state Exp;
branches;
next	1.115;

1.115
date	2004.01.07.21.34.24;	author hjl;	state Exp;
branches;
next	1.114;

1.114
date	2003.12.04.22.43.35;	author hjl;	state Exp;
branches;
next	1.113;

1.113
date	2003.12.01.06.28.24;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2003.11.27.18.49.39;	author kazu;	state Exp;
branches;
next	1.111;

1.111
date	2003.11.27.16.43.24;	author aoliva;	state Exp;
branches;
next	1.110;

1.110
date	2003.11.19.01.06.10;	author wilson;	state Exp;
branches;
next	1.109;

1.109
date	2003.11.17.21.31.11;	author drow;	state Exp;
branches;
next	1.108;

1.108
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2003.11.04.06.16.35;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2003.11.03.15.17.40;	author drow;	state Exp;
branches;
next	1.105;

1.105
date	2003.10.30.14.41.37;	author jakub;	state Exp;
branches;
next	1.104;

1.104
date	2003.10.13.15.55.51;	author hjl;	state Exp;
branches;
next	1.103;

1.103
date	2003.09.30.21.18.46;	author jakub;	state Exp;
branches;
next	1.102;

1.102
date	2003.09.29.23.25.08;	author hjl;	state Exp;
branches;
next	1.101;

1.101
date	2003.09.23.00.40.49;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2003.09.10.20.48.32;	author hjl;	state Exp;
branches;
next	1.99;

1.99
date	2003.08.22.23.35.59;	author hjl;	state Exp;
branches;
next	1.98;

1.98
date	2003.08.20.08.37.18;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2003.08.11.14.26.11;	author jakub;	state Exp;
branches;
next	1.96;

1.96
date	2003.08.07.08.38.10;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2003.08.01.22.46.16;	author hjl;	state Exp;
branches;
next	1.94;

1.94
date	2003.08.01.22.42.26;	author hjl;	state Exp;
branches;
next	1.93;

1.93
date	2003.07.25.14.35.56;	author hjl;	state Exp;
branches;
next	1.92;

1.92
date	2003.07.21.23.00.22;	author hjl;	state Exp;
branches;
next	1.91;

1.91
date	2003.07.18.21.09.28;	author rth;	state Exp;
branches;
next	1.90;

1.90
date	2003.07.16.22.48.58;	author rth;	state Exp;
branches;
next	1.89;

1.89
date	2003.07.16.21.47.36;	author rth;	state Exp;
branches;
next	1.88;

1.88
date	2003.07.10.14.22.15;	author hjl;	state Exp;
branches;
next	1.87;

1.87
date	2003.07.10.01.30.16;	author hjl;	state Exp;
branches;
next	1.86;

1.86
date	2003.07.04.13.53.37;	author jakub;	state Exp;
branches;
next	1.85;

1.85
date	2003.06.25.06.40.23;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2003.06.17.23.43.18;	author hjl;	state Exp;
branches;
next	1.83;

1.83
date	2003.05.30.15.50.10;	author jakub;	state Exp;
branches;
next	1.82;

1.82
date	2003.05.09.11.35.35;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2003.05.09.02.27.09;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2003.05.08.13.55.27;	author hjl;	state Exp;
branches;
next	1.79;

1.79
date	2003.05.05.05.46.52;	author hjl;	state Exp;
branches;
next	1.78;

1.78
date	2003.04.29.01.53.45;	author hjl;	state Exp;
branches;
next	1.77;

1.77
date	2003.04.09.16.19.52;	author hjl;	state Exp;
branches
	1.77.2.1
	1.77.4.1;
next	1.76;

1.76
date	2003.04.01.00.12.12;	author drow;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2003.03.27.22.52.12;	author jakub;	state Exp;
branches;
next	1.74;

1.74
date	2003.03.20.16.04.18;	author hjl;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2003.03.18.23.14.35;	author jakub;	state Exp;
branches;
next	1.72;

1.72
date	2003.03.18.18.57.40;	author rth;	state Exp;
branches;
next	1.71;

1.71
date	2003.03.03.23.19.19;	author hjl;	state Exp;
branches;
next	1.70;

1.70
date	2003.03.01.02.44.45;	author rth;	state Exp;
branches;
next	1.69;

1.69
date	2003.02.28.00.22.46;	author rth;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.17.18.24.40;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2003.01.17.23.27.55;	author jakub;	state Exp;
branches;
next	1.65;

1.65
date	2003.01.16.21.31.16;	author jakub;	state Exp;
branches;
next	1.64;

1.64
date	2002.12.06.01.48.24;	author rth;	state Exp;
branches;
next	1.63;

1.63
date	2002.12.04.23.59.27;	author hjl;	state Exp;
branches;
next	1.62;

1.62
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2002.11.28.11.55.43;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2002.11.12.06.21.05;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2002.09.09.17.34.07;	author rth;	state Exp;
branches
	1.58.2.1
	1.58.4.1;
next	1.57;

1.57
date	2002.08.22.01.27.20;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2002.07.30.05.40.20;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2002.07.23.12.29.33;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2002.07.23.11.15.06;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2002.07.19.01.10.28;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.07.09.10.40;	author amodra;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2002.06.06.00.29.22;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.05.13.32.02;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.04.00.51.07;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.23.13.12.46;	author jakub;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2002.05.07.00.16.53;	author amodra;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2002.03.28.03.27.45;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2002.03.04.20.41.55;	author hjl;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.19.12.40.29;	author jakub;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.25.16.41.37;	author nickc;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2002.01.21.10.29.09;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2002.01.17.13.02.40;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2002.01.06.11.14.19;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.19.02.14.37;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.18.17.59.59;	author hjl;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2001.12.13.11.09.29;	author jakub;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.07.11.12.18;	author jakub;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.28.19.15.11;	author jakub;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.23.12.17.18;	author jakub;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.21.14.58.26;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.17.12.01.05;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.15.09.45.48;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.03.13.16.18;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.10.03.08.33.18;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.21.14.25.09;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.20.23.30.36;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.23.15.14.16;	author jakub;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.17.15.56.58;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.17.08.57.42;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.12.01.24.14;	author wilson;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.25.12.42.26;	author twall;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.11.12.36.46;	author jakub;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.30.16.13.26;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.27.03.26.47;	author twall;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.22.16.38.46;	author twall;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.13.23.08.09;	author rth;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.10.01.41.06;	author rth;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.07.06.19.58;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.27.00.04.09;	author rth;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.03.22.53.38;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.12.22.56.35;	author wilson;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.22.21.25.36;	author wilson;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.18.00.41.35;	author wilson;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.16.22.44.07;	author rth;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.08.07.54.31;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.07.00.43.26;	author wilson;	state Exp;
branches;
next	;

1.230.2.1
date	2011.05.17.21.23.00;	author brobecke;	state Exp;
branches;
next	;

1.228.2.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	1.228.2.2;

1.228.2.2
date	2011.05.29.04.51.17;	author amodra;	state Exp;
branches;
next	;

1.180.2.1
date	2006.08.22.15.08.29;	author jsm28;	state Exp;
branches;
next	;

1.117.4.1
date	2004.03.09.21.51.38;	author wilson;	state Exp;
branches;
next	1.117.4.2;

1.117.4.2
date	2004.04.08.12.41.46;	author amodra;	state Exp;
branches;
next	1.117.4.3;

1.117.4.3
date	2004.04.09.18.28.02;	author drow;	state Exp;
branches;
next	;

1.117.6.1
date	2004.03.27.17.37.36;	author drow;	state Exp;
branches;
next	1.117.6.2;

1.117.6.2
date	2004.04.02.16.47.37;	author drow;	state Exp;
branches;
next	1.117.6.3;

1.117.6.3
date	2004.09.16.17.00.33;	author drow;	state Exp;
branches;
next	1.117.6.4;

1.117.6.4
date	2004.09.21.20.44.04;	author drow;	state Exp;
branches;
next	;

1.77.2.1
date	2003.05.04.11.37.37;	author kettenis;	state Exp;
branches;
next	1.77.2.2;

1.77.2.2
date	2003.05.18.09.43.48;	author kettenis;	state Exp;
branches;
next	;

1.77.4.1
date	2003.05.03.16.01.00;	author drow;	state Exp;
branches;
next	1.77.4.2;

1.77.4.2
date	2003.05.09.11.38.06;	author amodra;	state Exp;
branches;
next	;

1.76.2.1
date	2003.04.10.21.33.45;	author cagney;	state Exp;
branches;
next	;

1.74.2.1
date	2003.03.30.16.35.17;	author cagney;	state Exp;
branches;
next	;

1.58.2.1
date	2002.10.11.22.22.49;	author carlton;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2002.11.15.19.18.28;	author carlton;	state Exp;
branches;
next	1.58.2.3;

1.58.2.3
date	2002.12.23.19.37.51;	author carlton;	state Exp;
branches;
next	1.58.2.4;

1.58.2.4
date	2003.02.07.19.17.40;	author carlton;	state Exp;
branches;
next	1.58.2.5;

1.58.2.5
date	2003.03.06.00.56.17;	author carlton;	state Exp;
branches;
next	1.58.2.6;

1.58.2.6
date	2003.04.16.19.56.45;	author carlton;	state Exp;
branches;
next	1.58.2.7;

1.58.2.7
date	2003.05.01.00.46.42;	author carlton;	state Exp;
branches;
next	1.58.2.8;

1.58.2.8
date	2003.05.23.18.40.28;	author carlton;	state Exp;
branches;
next	1.58.2.9;

1.58.2.9
date	2003.06.27.21.49.26;	author carlton;	state Exp;
branches;
next	1.58.2.10;

1.58.2.10
date	2003.08.05.17.12.54;	author carlton;	state Exp;
branches;
next	1.58.2.11;

1.58.2.11
date	2003.09.17.21.27.56;	author carlton;	state Exp;
branches;
next	1.58.2.12;

1.58.2.12
date	2003.11.11.23.50.26;	author carlton;	state Exp;
branches;
next	1.58.2.13;

1.58.2.13
date	2003.12.15.23.59.48;	author carlton;	state Exp;
branches;
next	1.58.2.14;

1.58.2.14
date	2004.01.26.19.11.06;	author carlton;	state Exp;
branches;
next	;

1.58.4.1
date	2002.10.26.17.11.59;	author drow;	state Exp;
branches;
next	1.58.4.2;

1.58.4.2
date	2003.12.14.20.26.45;	author drow;	state Exp;
branches;
next	1.58.4.3;

1.58.4.3
date	2004.01.13.16.11.38;	author drow;	state Exp;
branches;
next	1.58.4.4;

1.58.4.4
date	2004.02.09.19.43.25;	author drow;	state Exp;
branches;
next	;

1.52.2.1
date	2002.07.19.01.11.18;	author amodra;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2002.07.23.18.01.58;	author nickc;	state Exp;
branches;
next	1.52.2.3;

1.52.2.3
date	2002.08.22.01.34.15;	author amodra;	state Exp;
branches;
next	1.52.2.4;

1.52.2.4
date	2002.10.11.08.56.14;	author amodra;	state Exp;
branches;
next	;

1.48.2.1
date	2002.06.20.01.30.50;	author kseitz;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2002.07.22.21.46.47;	author kseitz;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	2002.08.09.18.34.17;	author kseitz;	state Exp;
branches;
next	1.48.2.4;

1.48.2.4
date	2002.08.30.22.52.38;	author kseitz;	state Exp;
branches;
next	1.48.2.5;

1.48.2.5
date	2002.10.01.00.45.49;	author kseitz;	state Exp;
branches;
next	1.48.2.6;

1.48.2.6
date	2002.11.03.22.01.37;	author ezannoni;	state Exp;
branches;
next	;

1.47.2.1
date	2002.06.15.16.42.39;	author cagney;	state Exp;
branches;
next	;

1.43.2.1
date	2002.02.19.13.10.29;	author jakub;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2002.03.28.06.20.03;	author amodra;	state Exp;
branches;
next	1.43.2.3;

1.43.2.3
date	2002.04.04.14.53.00;	author amodra;	state Exp;
branches;
next	1.43.2.4;

1.43.2.4
date	2002.05.09.11.50.32;	author amodra;	state Exp;
branches;
next	;

1.9.2.1
date	2001.02.10.01.49.49;	author rth;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.02.13.23.11.09;	author rth;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.06.11.10.04.16;	author amodra;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.10.25.06.32.29;	author rth;	state Exp;
branches;
next	;


desc
@@


1.233
log
@2011-05-25  Tristan Gingold  <gingold@@adacore.com>

	* configure.in (bfd_elf32_ia64_big_vec, bfd_elf32_ia64_hpux_big_vec)
	(bfd_elf64_ia64_big_vec, bfd_elf64_ia64_hpux_big_vec)
	(bfd_elf64_ia64_little_vec, bfd_elf64_ia64_vms_vec): Add elfxx-ia64.lo
	* Makefile.am (BFD64_BACKENDS): Add elfxx-ia64.lo
	(BFD64_BACKENDS_CFILES): Add elfxx-ia64.c
	(elf32-ia64.c): Created from elfnn-ia64.c
	(elf64-ia64.c): Likewise.
	* elfxx-ia64.h: New file.
	* elfxx-ia64.c: Split with elfnn-ia64.c.  Keep only the following
	functions.Includes elfxx-ia64.h.
	(elfNN_ia64_reloc): Renames to ia64_elf_reloc.  Adjust error message.
	(IA64_HOWTO): Adjust.
	(lookup_howto): Renames to ia64_elf_lookup_howto.  Make it public.
	(elfNN_ia64_reloc_type_lookup): Renames to
	ia64_elf_reloc_type_lookup. Make it public. Adjust calls.
	(elfNN_ia64_reloc_name_lookup): Renames to
	ia64_elf_reloc_name_lookup. Make it public.
	(elfNN_ia64_relax_br): Renames to ia64_elf_relax_br.  Make it public.
	(elfNN_ia64_relax_brl): Renames to ia64_elf_relax_brl. Make it
	public.
	(elfNN_ia64_relax_ldxmov): Renames to ia64_elf_relax_ldxmov.
	Move it and make it public.  Move prototype to elfxx-ia64.h
	(elfNN_ia64_install_value): Renames to ia64_elf_install_value.
	Move prototype to elfxx-ia64.h
	* elfnn-ia64.c: New file, split from elfxx-ia64.c.
	(elfNN_ia64_info_to_howto): Adjust calls.
	(elfNN_ia64_relax_section): Adjust calls.
	(count_dyn_reloc): Fix typo.
	(elfNN_ia64_relocate_section): Adjust calls.
	(elfNN_ia64_finish_dynamic_symbol): Likewise.
	(bfd_elfNN_bfd_reloc_type_lookup)
	(bfd_elfNN_bfd_reloc_name_lookup): Adjust macros.
@
text
@/* IA-64 support for 64-bit ELF
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011  Free Software Foundation, Inc.
   Contributed by David Mosberger-Tang <davidm@@hpl.hp.com>

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "opcode/ia64.h"
#include "elf/ia64.h"
#include "objalloc.h"
#include "hashtab.h"
#include "bfd_stdint.h"
#include "elfxx-ia64.h"

/* THE RULES for all the stuff the linker creates --

  GOT		Entries created in response to LTOFF or LTOFF_FPTR
 		relocations.  Dynamic relocs created for dynamic
 		symbols in an application; REL relocs for locals
 		in a shared library.

  FPTR		The canonical function descriptor.  Created for local
 		symbols in applications.  Descriptors for dynamic symbols
 		and local symbols in shared libraries are created by
 		ld.so.  Thus there are no dynamic relocs against these
 		objects.  The FPTR relocs for such _are_ passed through
 		to the dynamic relocation tables.

  FULL_PLT	Created for a PCREL21B relocation against a dynamic symbol.
 		Requires the creation of a PLTOFF entry.  This does not
 		require any dynamic relocations.

  PLTOFF	Created by PLTOFF relocations.  For local symbols, this
 		is an alternate function descriptor, and in shared libraries
 		requires two REL relocations.  Note that this cannot be
 		transformed into an FPTR relocation, since it must be in
 		range of the GP.  For dynamic symbols, this is a function
 		descriptor for a MIN_PLT entry, and requires one IPLT reloc.

  MIN_PLT	Created by PLTOFF entries against dynamic symbols.  This
 		does not require dynamic relocations.  */

/* ia64-specific relocation.  */

#define NELEMS(a)	((int) (sizeof (a) / sizeof ((a)[0])))

/* Perform a relocation.  Not much to do here as all the hard work is
   done in elfNN_ia64_final_link_relocate.  */
static bfd_reloc_status_type
ia64_elf_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc,
                asymbol *sym ATTRIBUTE_UNUSED,
                PTR data ATTRIBUTE_UNUSED, asection *input_section,
                bfd *output_bfd, char **error_message)
{
  if (output_bfd)
    {
      reloc->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (input_section->flags & SEC_DEBUGGING)
    return bfd_reloc_continue;

  *error_message = "Unsupported call to ia64_elf_reloc";
  return bfd_reloc_notsupported;
}

#define IA64_HOWTO(TYPE, NAME, SIZE, PCREL, IN)			\
  HOWTO (TYPE, 0, SIZE, 0, PCREL, 0, complain_overflow_signed,	\
	 ia64_elf_reloc, NAME, FALSE, 0, -1, IN)

/* This table has to be sorted according to increasing number of the
   TYPE field.  */
static reloc_howto_type ia64_howto_table[] =
  {
    IA64_HOWTO (R_IA64_NONE,	    "NONE",	   0, FALSE, TRUE),

    IA64_HOWTO (R_IA64_IMM14,	    "IMM14",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_IMM22,	    "IMM22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_IMM64,	    "IMM64",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR32MSB,    "DIR32MSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR32LSB,    "DIR32LSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR64MSB,    "DIR64MSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR64LSB,    "DIR64LSB",	   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_GPREL22,	    "GPREL22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL64I,    "GPREL64I",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL32MSB,  "GPREL32MSB",  2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL32LSB,  "GPREL32LSB",  2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL64MSB,  "GPREL64MSB",  4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL64LSB,  "GPREL64LSB",  4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_LTOFF22,	    "LTOFF22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF64I,    "LTOFF64I",	   0, FALSE, TRUE),

    IA64_HOWTO (R_IA64_PLTOFF22,    "PLTOFF22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_PLTOFF64I,   "PLTOFF64I",   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_PLTOFF64MSB, "PLTOFF64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_PLTOFF64LSB, "PLTOFF64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_FPTR64I,	    "FPTR64I",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR32MSB,   "FPTR32MSB",   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR32LSB,   "FPTR32LSB",   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR64MSB,   "FPTR64MSB",   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR64LSB,   "FPTR64LSB",   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_PCREL60B,    "PCREL60B",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL21B,    "PCREL21B",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL21M,    "PCREL21M",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL21F,    "PCREL21F",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL32MSB,  "PCREL32MSB",  2, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL32LSB,  "PCREL32LSB",  2, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL64MSB,  "PCREL64MSB",  4, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL64LSB,  "PCREL64LSB",  4, TRUE, TRUE),

    IA64_HOWTO (R_IA64_LTOFF_FPTR22, "LTOFF_FPTR22", 0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64I, "LTOFF_FPTR64I", 0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR32MSB, "LTOFF_FPTR32MSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR32LSB, "LTOFF_FPTR32LSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64MSB, "LTOFF_FPTR64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64LSB, "LTOFF_FPTR64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_SEGREL32MSB, "SEGREL32MSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SEGREL32LSB, "SEGREL32LSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SEGREL64MSB, "SEGREL64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SEGREL64LSB, "SEGREL64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_SECREL32MSB, "SECREL32MSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SECREL32LSB, "SECREL32LSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SECREL64MSB, "SECREL64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SECREL64LSB, "SECREL64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_REL32MSB,    "REL32MSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_REL32LSB,    "REL32LSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_REL64MSB,    "REL64MSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_REL64LSB,    "REL64LSB",	   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_LTV32MSB,    "LTV32MSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTV32LSB,    "LTV32LSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTV64MSB,    "LTV64MSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTV64LSB,    "LTV64LSB",	   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_PCREL21BI,   "PCREL21BI",   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL22,     "PCREL22",     0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL64I,    "PCREL64I",    0, TRUE, TRUE),

    IA64_HOWTO (R_IA64_IPLTMSB,	    "IPLTMSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_IPLTLSB,	    "IPLTLSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_COPY,	    "COPY",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF22X,    "LTOFF22X",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LDXMOV,	    "LDXMOV",	   0, FALSE, TRUE),

    IA64_HOWTO (R_IA64_TPREL14,	    "TPREL14",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL22,	    "TPREL22",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64I,    "TPREL64I",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64MSB,  "TPREL64MSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64LSB,  "TPREL64LSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_LTOFF_TPREL22, "LTOFF_TPREL22",  0, FALSE, FALSE),

    IA64_HOWTO (R_IA64_DTPMOD64MSB, "DTPMOD64MSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPMOD64LSB, "DTPMOD64LSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_LTOFF_DTPMOD22, "LTOFF_DTPMOD22", 0, FALSE, FALSE),

    IA64_HOWTO (R_IA64_DTPREL14,    "DTPREL14",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL22,    "DTPREL22",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64I,   "DTPREL64I",   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL32MSB, "DTPREL32MSB", 2, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL32LSB, "DTPREL32LSB", 2, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64MSB, "DTPREL64MSB", 4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64LSB, "DTPREL64LSB", 4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_LTOFF_DTPREL22, "LTOFF_DTPREL22", 0, FALSE, FALSE),
  };

static unsigned char elf_code_to_howto_index[R_IA64_MAX_RELOC_CODE + 1];

/* Given a BFD reloc type, return the matching HOWTO structure.  */

reloc_howto_type *
ia64_elf_lookup_howto (unsigned int rtype)
{
  static int inited = 0;
  int i;

  if (!inited)
    {
      inited = 1;

      memset (elf_code_to_howto_index, 0xff, sizeof (elf_code_to_howto_index));
      for (i = 0; i < NELEMS (ia64_howto_table); ++i)
	elf_code_to_howto_index[ia64_howto_table[i].type] = i;
    }

  if (rtype > R_IA64_MAX_RELOC_CODE)
    return 0;
  i = elf_code_to_howto_index[rtype];
  if (i >= NELEMS (ia64_howto_table))
    return 0;
  return ia64_howto_table + i;
}

reloc_howto_type*
ia64_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                            bfd_reloc_code_real_type bfd_code)
{
  unsigned int rtype;

  switch (bfd_code)
    {
    case BFD_RELOC_NONE:		rtype = R_IA64_NONE; break;

    case BFD_RELOC_IA64_IMM14:		rtype = R_IA64_IMM14; break;
    case BFD_RELOC_IA64_IMM22:		rtype = R_IA64_IMM22; break;
    case BFD_RELOC_IA64_IMM64:		rtype = R_IA64_IMM64; break;

    case BFD_RELOC_IA64_DIR32MSB:	rtype = R_IA64_DIR32MSB; break;
    case BFD_RELOC_IA64_DIR32LSB:	rtype = R_IA64_DIR32LSB; break;
    case BFD_RELOC_IA64_DIR64MSB:	rtype = R_IA64_DIR64MSB; break;
    case BFD_RELOC_IA64_DIR64LSB:	rtype = R_IA64_DIR64LSB; break;

    case BFD_RELOC_IA64_GPREL22:	rtype = R_IA64_GPREL22; break;
    case BFD_RELOC_IA64_GPREL64I:	rtype = R_IA64_GPREL64I; break;
    case BFD_RELOC_IA64_GPREL32MSB:	rtype = R_IA64_GPREL32MSB; break;
    case BFD_RELOC_IA64_GPREL32LSB:	rtype = R_IA64_GPREL32LSB; break;
    case BFD_RELOC_IA64_GPREL64MSB:	rtype = R_IA64_GPREL64MSB; break;
    case BFD_RELOC_IA64_GPREL64LSB:	rtype = R_IA64_GPREL64LSB; break;

    case BFD_RELOC_IA64_LTOFF22:	rtype = R_IA64_LTOFF22; break;
    case BFD_RELOC_IA64_LTOFF64I:	rtype = R_IA64_LTOFF64I; break;

    case BFD_RELOC_IA64_PLTOFF22:	rtype = R_IA64_PLTOFF22; break;
    case BFD_RELOC_IA64_PLTOFF64I:	rtype = R_IA64_PLTOFF64I; break;
    case BFD_RELOC_IA64_PLTOFF64MSB:	rtype = R_IA64_PLTOFF64MSB; break;
    case BFD_RELOC_IA64_PLTOFF64LSB:	rtype = R_IA64_PLTOFF64LSB; break;
    case BFD_RELOC_IA64_FPTR64I:	rtype = R_IA64_FPTR64I; break;
    case BFD_RELOC_IA64_FPTR32MSB:	rtype = R_IA64_FPTR32MSB; break;
    case BFD_RELOC_IA64_FPTR32LSB:	rtype = R_IA64_FPTR32LSB; break;
    case BFD_RELOC_IA64_FPTR64MSB:	rtype = R_IA64_FPTR64MSB; break;
    case BFD_RELOC_IA64_FPTR64LSB:	rtype = R_IA64_FPTR64LSB; break;

    case BFD_RELOC_IA64_PCREL21B:	rtype = R_IA64_PCREL21B; break;
    case BFD_RELOC_IA64_PCREL21BI:	rtype = R_IA64_PCREL21BI; break;
    case BFD_RELOC_IA64_PCREL21M:	rtype = R_IA64_PCREL21M; break;
    case BFD_RELOC_IA64_PCREL21F:	rtype = R_IA64_PCREL21F; break;
    case BFD_RELOC_IA64_PCREL22:	rtype = R_IA64_PCREL22; break;
    case BFD_RELOC_IA64_PCREL60B:	rtype = R_IA64_PCREL60B; break;
    case BFD_RELOC_IA64_PCREL64I:	rtype = R_IA64_PCREL64I; break;
    case BFD_RELOC_IA64_PCREL32MSB:	rtype = R_IA64_PCREL32MSB; break;
    case BFD_RELOC_IA64_PCREL32LSB:	rtype = R_IA64_PCREL32LSB; break;
    case BFD_RELOC_IA64_PCREL64MSB:	rtype = R_IA64_PCREL64MSB; break;
    case BFD_RELOC_IA64_PCREL64LSB:	rtype = R_IA64_PCREL64LSB; break;

    case BFD_RELOC_IA64_LTOFF_FPTR22:	rtype = R_IA64_LTOFF_FPTR22; break;
    case BFD_RELOC_IA64_LTOFF_FPTR64I:	rtype = R_IA64_LTOFF_FPTR64I; break;
    case BFD_RELOC_IA64_LTOFF_FPTR32MSB: rtype = R_IA64_LTOFF_FPTR32MSB; break;
    case BFD_RELOC_IA64_LTOFF_FPTR32LSB: rtype = R_IA64_LTOFF_FPTR32LSB; break;
    case BFD_RELOC_IA64_LTOFF_FPTR64MSB: rtype = R_IA64_LTOFF_FPTR64MSB; break;
    case BFD_RELOC_IA64_LTOFF_FPTR64LSB: rtype = R_IA64_LTOFF_FPTR64LSB; break;

    case BFD_RELOC_IA64_SEGREL32MSB:	rtype = R_IA64_SEGREL32MSB; break;
    case BFD_RELOC_IA64_SEGREL32LSB:	rtype = R_IA64_SEGREL32LSB; break;
    case BFD_RELOC_IA64_SEGREL64MSB:	rtype = R_IA64_SEGREL64MSB; break;
    case BFD_RELOC_IA64_SEGREL64LSB:	rtype = R_IA64_SEGREL64LSB; break;

    case BFD_RELOC_IA64_SECREL32MSB:	rtype = R_IA64_SECREL32MSB; break;
    case BFD_RELOC_IA64_SECREL32LSB:	rtype = R_IA64_SECREL32LSB; break;
    case BFD_RELOC_IA64_SECREL64MSB:	rtype = R_IA64_SECREL64MSB; break;
    case BFD_RELOC_IA64_SECREL64LSB:	rtype = R_IA64_SECREL64LSB; break;

    case BFD_RELOC_IA64_REL32MSB:	rtype = R_IA64_REL32MSB; break;
    case BFD_RELOC_IA64_REL32LSB:	rtype = R_IA64_REL32LSB; break;
    case BFD_RELOC_IA64_REL64MSB:	rtype = R_IA64_REL64MSB; break;
    case BFD_RELOC_IA64_REL64LSB:	rtype = R_IA64_REL64LSB; break;

    case BFD_RELOC_IA64_LTV32MSB:	rtype = R_IA64_LTV32MSB; break;
    case BFD_RELOC_IA64_LTV32LSB:	rtype = R_IA64_LTV32LSB; break;
    case BFD_RELOC_IA64_LTV64MSB:	rtype = R_IA64_LTV64MSB; break;
    case BFD_RELOC_IA64_LTV64LSB:	rtype = R_IA64_LTV64LSB; break;

    case BFD_RELOC_IA64_IPLTMSB:	rtype = R_IA64_IPLTMSB; break;
    case BFD_RELOC_IA64_IPLTLSB:	rtype = R_IA64_IPLTLSB; break;
    case BFD_RELOC_IA64_COPY:		rtype = R_IA64_COPY; break;
    case BFD_RELOC_IA64_LTOFF22X:	rtype = R_IA64_LTOFF22X; break;
    case BFD_RELOC_IA64_LDXMOV:		rtype = R_IA64_LDXMOV; break;

    case BFD_RELOC_IA64_TPREL14:	rtype = R_IA64_TPREL14; break;
    case BFD_RELOC_IA64_TPREL22:	rtype = R_IA64_TPREL22; break;
    case BFD_RELOC_IA64_TPREL64I:	rtype = R_IA64_TPREL64I; break;
    case BFD_RELOC_IA64_TPREL64MSB:	rtype = R_IA64_TPREL64MSB; break;
    case BFD_RELOC_IA64_TPREL64LSB:	rtype = R_IA64_TPREL64LSB; break;
    case BFD_RELOC_IA64_LTOFF_TPREL22:	rtype = R_IA64_LTOFF_TPREL22; break;

    case BFD_RELOC_IA64_DTPMOD64MSB:	rtype = R_IA64_DTPMOD64MSB; break;
    case BFD_RELOC_IA64_DTPMOD64LSB:	rtype = R_IA64_DTPMOD64LSB; break;
    case BFD_RELOC_IA64_LTOFF_DTPMOD22:	rtype = R_IA64_LTOFF_DTPMOD22; break;

    case BFD_RELOC_IA64_DTPREL14:	rtype = R_IA64_DTPREL14; break;
    case BFD_RELOC_IA64_DTPREL22:	rtype = R_IA64_DTPREL22; break;
    case BFD_RELOC_IA64_DTPREL64I:	rtype = R_IA64_DTPREL64I; break;
    case BFD_RELOC_IA64_DTPREL32MSB:	rtype = R_IA64_DTPREL32MSB; break;
    case BFD_RELOC_IA64_DTPREL32LSB:	rtype = R_IA64_DTPREL32LSB; break;
    case BFD_RELOC_IA64_DTPREL64MSB:	rtype = R_IA64_DTPREL64MSB; break;
    case BFD_RELOC_IA64_DTPREL64LSB:	rtype = R_IA64_DTPREL64LSB; break;
    case BFD_RELOC_IA64_LTOFF_DTPREL22:	rtype = R_IA64_LTOFF_DTPREL22; break;

    default: return 0;
    }
  return ia64_elf_lookup_howto (rtype);
}

reloc_howto_type *
ia64_elf_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                            const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (ia64_howto_table) / sizeof (ia64_howto_table[0]);
       i++)
    if (ia64_howto_table[i].name != NULL
	&& strcasecmp (ia64_howto_table[i].name, r_name) == 0)
      return &ia64_howto_table[i];

  return NULL;
}

#define BTYPE_SHIFT	6
#define Y_SHIFT		26
#define X6_SHIFT	27
#define X4_SHIFT	27
#define X3_SHIFT	33
#define X2_SHIFT	31
#define X_SHIFT		33
#define OPCODE_SHIFT	37

#define OPCODE_BITS	(0xfLL << OPCODE_SHIFT)
#define X6_BITS		(0x3fLL << X6_SHIFT)
#define X4_BITS		(0xfLL << X4_SHIFT)
#define X3_BITS		(0x7LL << X3_SHIFT)
#define X2_BITS		(0x3LL << X2_SHIFT)
#define X_BITS		(0x1LL << X_SHIFT)
#define Y_BITS		(0x1LL << Y_SHIFT)
#define BTYPE_BITS	(0x7LL << BTYPE_SHIFT)
#define PREDICATE_BITS	(0x3fLL)

#define IS_NOP_B(i) \
  (((i) & (OPCODE_BITS | X6_BITS)) == (2LL << OPCODE_SHIFT))
#define IS_NOP_F(i) \
  (((i) & (OPCODE_BITS | X_BITS | X6_BITS | Y_BITS)) \
   == (0x1LL << X6_SHIFT))
#define IS_NOP_I(i) \
  (((i) & (OPCODE_BITS | X3_BITS | X6_BITS | Y_BITS)) \
   == (0x1LL << X6_SHIFT))
#define IS_NOP_M(i) \
  (((i) & (OPCODE_BITS | X3_BITS | X2_BITS | X4_BITS | Y_BITS)) \
   == (0x1LL << X4_SHIFT))
#define IS_BR_COND(i) \
  (((i) & (OPCODE_BITS | BTYPE_BITS)) == (0x4LL << OPCODE_SHIFT))
#define IS_BR_CALL(i) \
  (((i) & OPCODE_BITS) == (0x5LL << OPCODE_SHIFT))

bfd_boolean
ia64_elf_relax_br (bfd_byte *contents, bfd_vma off)
{
  unsigned int template_val, mlx;
  bfd_vma t0, t1, s0, s1, s2, br_code;
  long br_slot;
  bfd_byte *hit_addr;

  hit_addr = (bfd_byte *) (contents + off);
  br_slot = (intptr_t) hit_addr & 0x3;
  hit_addr -= br_slot;
  t0 = bfd_getl64 (hit_addr + 0);
  t1 = bfd_getl64 (hit_addr + 8);

  /* Check if we can turn br into brl.  A label is always at the start
     of the bundle.  Even if there are predicates on NOPs, we still
     perform this optimization.  */
  template_val = t0 & 0x1e;
  s0 = (t0 >> 5) & 0x1ffffffffffLL;
  s1 = ((t0 >> 46) | (t1 << 18)) & 0x1ffffffffffLL;
  s2 = (t1 >> 23) & 0x1ffffffffffLL;
  switch (br_slot)
    {
    case 0:
      /* Check if slot 1 and slot 2 are NOPs. Possible template is
         BBB.  We only need to check nop.b.  */
      if (!(IS_NOP_B (s1) && IS_NOP_B (s2)))
	return FALSE;
      br_code = s0;
      break;
    case 1:
      /* Check if slot 2 is NOP. Possible templates are MBB and BBB.
	 For BBB, slot 0 also has to be nop.b.  */
      if (!((template_val == 0x12				/* MBB */
	     && IS_NOP_B (s2))
	    || (template_val == 0x16			/* BBB */
		&& IS_NOP_B (s0)
		&& IS_NOP_B (s2))))
	return FALSE;
      br_code = s1;
      break;
    case 2:
      /* Check if slot 1 is NOP. Possible templates are MIB, MBB, BBB,
	 MMB and MFB. For BBB, slot 0 also has to be nop.b.  */
      if (!((template_val == 0x10				/* MIB */
	     && IS_NOP_I (s1))
	    || (template_val == 0x12			/* MBB */
		&& IS_NOP_B (s1))
	    || (template_val == 0x16			/* BBB */
		&& IS_NOP_B (s0)
		&& IS_NOP_B (s1))
	    || (template_val == 0x18			/* MMB */
		&& IS_NOP_M (s1))
	    || (template_val == 0x1c			/* MFB */
		&& IS_NOP_F (s1))))
	return FALSE;
      br_code = s2;
      break;
    default:
      /* It should never happen.  */
      abort ();
    }

  /* We can turn br.cond/br.call into brl.cond/brl.call.  */
  if (!(IS_BR_COND (br_code) || IS_BR_CALL (br_code)))
    return FALSE;

  /* Turn br into brl by setting bit 40.  */
  br_code |= 0x1LL << 40;

  /* Turn the old bundle into a MLX bundle with the same stop-bit
     variety.  */
  if (t0 & 0x1)
    mlx = 0x5;
  else
    mlx = 0x4;

  if (template_val == 0x16)
    {
      /* For BBB, we need to put nop.m in slot 0.  We keep the original
	 predicate only if slot 0 isn't br.  */
      if (br_slot == 0)
	t0 = 0LL;
      else
	t0 &= PREDICATE_BITS << 5;
      t0 |= 0x1LL << (X4_SHIFT + 5);
    }
  else
    {
      /* Keep the original instruction in slot 0.  */
      t0 &= 0x1ffffffffffLL << 5;
    }

  t0 |= mlx;

  /* Put brl in slot 1.  */
  t1 = br_code << 23;

  bfd_putl64 (t0, hit_addr);
  bfd_putl64 (t1, hit_addr + 8);
  return TRUE;
}

void
ia64_elf_relax_brl (bfd_byte *contents, bfd_vma off)
{
  int template_val;
  bfd_byte *hit_addr;
  bfd_vma t0, t1, i0, i1, i2;

  hit_addr = (bfd_byte *) (contents + off);
  hit_addr -= (intptr_t) hit_addr & 0x3;
  t0 = bfd_getl64 (hit_addr);
  t1 = bfd_getl64 (hit_addr + 8);

  /* Keep the instruction in slot 0. */
  i0 = (t0 >> 5) & 0x1ffffffffffLL;
  /* Use nop.b for slot 1. */
  i1 = 0x4000000000LL;
  /* For slot 2, turn brl into br by masking out bit 40.  */
  i2 = (t1 >> 23) & 0x0ffffffffffLL;

  /* Turn a MLX bundle into a MBB bundle with the same stop-bit
     variety.  */
  if (t0 & 0x1)
    template_val = 0x13;
  else
    template_val = 0x12;
  t0 = (i1 << 46) | (i0 << 5) | template_val;
  t1 = (i2 << 23) | (i1 >> 18);

  bfd_putl64 (t0, hit_addr);
  bfd_putl64 (t1, hit_addr + 8);
}

void
ia64_elf_relax_ldxmov (bfd_byte *contents, bfd_vma off)
{
  int shift, r1, r3;
  bfd_vma dword, insn;

  switch ((int)off & 0x3)
    {
    case 0: shift =  5; break;
    case 1: shift = 14; off += 3; break;
    case 2: shift = 23; off += 6; break;
    default:
      abort ();
    }

  dword = bfd_getl64 (contents + off);
  insn = (dword >> shift) & 0x1ffffffffffLL;

  r1 = (insn >> 6) & 127;
  r3 = (insn >> 20) & 127;
  if (r1 == r3)
    insn = 0x8000000;				   /* nop */
  else
    insn = (insn & 0x7f01fff) | 0x10800000000LL;   /* (qp) mov r1 = r3 */

  dword &= ~(0x1ffffffffffLL << shift);
  dword |= (insn << shift);
  bfd_putl64 (dword, contents + off);
}

bfd_reloc_status_type
ia64_elf_install_value (bfd_byte *hit_addr, bfd_vma v, unsigned int r_type)
{
  const struct ia64_operand *op;
  int bigendian = 0, shift = 0;
  bfd_vma t0, t1, dword;
  ia64_insn insn;
  enum ia64_opnd opnd;
  const char *err;
  size_t size = 8;
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT val = (BFD_HOST_U_64_BIT) v;
#else
  bfd_vma val = v;
#endif

  opnd = IA64_OPND_NIL;
  switch (r_type)
    {
    case R_IA64_NONE:
    case R_IA64_LDXMOV:
      return bfd_reloc_ok;

      /* Instruction relocations.  */

    case R_IA64_IMM14:
    case R_IA64_TPREL14:
    case R_IA64_DTPREL14:
      opnd = IA64_OPND_IMM14;
      break;

    case R_IA64_PCREL21F:	opnd = IA64_OPND_TGT25; break;
    case R_IA64_PCREL21M:	opnd = IA64_OPND_TGT25b; break;
    case R_IA64_PCREL60B:	opnd = IA64_OPND_TGT64; break;
    case R_IA64_PCREL21B:
    case R_IA64_PCREL21BI:
      opnd = IA64_OPND_TGT25c;
      break;

    case R_IA64_IMM22:
    case R_IA64_GPREL22:
    case R_IA64_LTOFF22:
    case R_IA64_LTOFF22X:
    case R_IA64_PLTOFF22:
    case R_IA64_PCREL22:
    case R_IA64_LTOFF_FPTR22:
    case R_IA64_TPREL22:
    case R_IA64_DTPREL22:
    case R_IA64_LTOFF_TPREL22:
    case R_IA64_LTOFF_DTPMOD22:
    case R_IA64_LTOFF_DTPREL22:
      opnd = IA64_OPND_IMM22;
      break;

    case R_IA64_IMM64:
    case R_IA64_GPREL64I:
    case R_IA64_LTOFF64I:
    case R_IA64_PLTOFF64I:
    case R_IA64_PCREL64I:
    case R_IA64_FPTR64I:
    case R_IA64_LTOFF_FPTR64I:
    case R_IA64_TPREL64I:
    case R_IA64_DTPREL64I:
      opnd = IA64_OPND_IMMU64;
      break;

      /* Data relocations.  */

    case R_IA64_DIR32MSB:
    case R_IA64_GPREL32MSB:
    case R_IA64_FPTR32MSB:
    case R_IA64_PCREL32MSB:
    case R_IA64_LTOFF_FPTR32MSB:
    case R_IA64_SEGREL32MSB:
    case R_IA64_SECREL32MSB:
    case R_IA64_LTV32MSB:
    case R_IA64_DTPREL32MSB:
      size = 4; bigendian = 1;
      break;

    case R_IA64_DIR32LSB:
    case R_IA64_GPREL32LSB:
    case R_IA64_FPTR32LSB:
    case R_IA64_PCREL32LSB:
    case R_IA64_LTOFF_FPTR32LSB:
    case R_IA64_SEGREL32LSB:
    case R_IA64_SECREL32LSB:
    case R_IA64_LTV32LSB:
    case R_IA64_DTPREL32LSB:
      size = 4; bigendian = 0;
      break;

    case R_IA64_DIR64MSB:
    case R_IA64_GPREL64MSB:
    case R_IA64_PLTOFF64MSB:
    case R_IA64_FPTR64MSB:
    case R_IA64_PCREL64MSB:
    case R_IA64_LTOFF_FPTR64MSB:
    case R_IA64_SEGREL64MSB:
    case R_IA64_SECREL64MSB:
    case R_IA64_LTV64MSB:
    case R_IA64_TPREL64MSB:
    case R_IA64_DTPMOD64MSB:
    case R_IA64_DTPREL64MSB:
      size = 8; bigendian = 1;
      break;

    case R_IA64_DIR64LSB:
    case R_IA64_GPREL64LSB:
    case R_IA64_PLTOFF64LSB:
    case R_IA64_FPTR64LSB:
    case R_IA64_PCREL64LSB:
    case R_IA64_LTOFF_FPTR64LSB:
    case R_IA64_SEGREL64LSB:
    case R_IA64_SECREL64LSB:
    case R_IA64_LTV64LSB:
    case R_IA64_TPREL64LSB:
    case R_IA64_DTPMOD64LSB:
    case R_IA64_DTPREL64LSB:
      size = 8; bigendian = 0;
      break;

      /* Unsupported / Dynamic relocations.  */
    default:
      return bfd_reloc_notsupported;
    }

  switch (opnd)
    {
    case IA64_OPND_IMMU64:
      hit_addr -= (intptr_t) hit_addr & 0x3;
      t0 = bfd_getl64 (hit_addr);
      t1 = bfd_getl64 (hit_addr + 8);

      /* tmpl/s: bits  0.. 5 in t0
	 slot 0: bits  5..45 in t0
	 slot 1: bits 46..63 in t0, bits 0..22 in t1
	 slot 2: bits 23..63 in t1 */

      /* First, clear the bits that form the 64 bit constant.  */
      t0 &= ~(0x3ffffLL << 46);
      t1 &= ~(0x7fffffLL
	      | ((  (0x07fLL << 13) | (0x1ffLL << 27)
		    | (0x01fLL << 22) | (0x001LL << 21)
		    | (0x001LL << 36)) << 23));

      t0 |= ((val >> 22) & 0x03ffffLL) << 46;		/* 18 lsbs of imm41 */
      t1 |= ((val >> 40) & 0x7fffffLL) <<  0;		/* 23 msbs of imm41 */
      t1 |= (  (((val >>  0) & 0x07f) << 13)		/* imm7b */
	       | (((val >>  7) & 0x1ff) << 27)		/* imm9d */
	       | (((val >> 16) & 0x01f) << 22)		/* imm5c */
	       | (((val >> 21) & 0x001) << 21)		/* ic */
	       | (((val >> 63) & 0x001) << 36)) << 23;	/* i */

      bfd_putl64 (t0, hit_addr);
      bfd_putl64 (t1, hit_addr + 8);
      break;

    case IA64_OPND_TGT64:
      hit_addr -= (intptr_t) hit_addr & 0x3;
      t0 = bfd_getl64 (hit_addr);
      t1 = bfd_getl64 (hit_addr + 8);

      /* tmpl/s: bits  0.. 5 in t0
	 slot 0: bits  5..45 in t0
	 slot 1: bits 46..63 in t0, bits 0..22 in t1
	 slot 2: bits 23..63 in t1 */

      /* First, clear the bits that form the 64 bit constant.  */
      t0 &= ~(0x3ffffLL << 46);
      t1 &= ~(0x7fffffLL
	      | ((1LL << 36 | 0xfffffLL << 13) << 23));

      val >>= 4;
      t0 |= ((val >> 20) & 0xffffLL) << 2 << 46;	/* 16 lsbs of imm39 */
      t1 |= ((val >> 36) & 0x7fffffLL) << 0;		/* 23 msbs of imm39 */
      t1 |= ((((val >> 0) & 0xfffffLL) << 13)		/* imm20b */
	      | (((val >> 59) & 0x1LL) << 36)) << 23;	/* i */

      bfd_putl64 (t0, hit_addr);
      bfd_putl64 (t1, hit_addr + 8);
      break;

    default:
      switch ((intptr_t) hit_addr & 0x3)
	{
	case 0: shift =  5; break;
	case 1: shift = 14; hit_addr += 3; break;
	case 2: shift = 23; hit_addr += 6; break;
	case 3: return bfd_reloc_notsupported; /* shouldn't happen...  */
	}
      dword = bfd_getl64 (hit_addr);
      insn = (dword >> shift) & 0x1ffffffffffLL;

      op = elf64_ia64_operands + opnd;
      err = (*op->insert) (op, val, &insn);
      if (err)
	return bfd_reloc_overflow;

      dword &= ~(0x1ffffffffffLL << shift);
      dword |= (insn << shift);
      bfd_putl64 (dword, hit_addr);
      break;

    case IA64_OPND_NIL:
      /* A data relocation.  */
      if (bigendian)
	if (size == 4)
	  bfd_putb32 (val, hit_addr);
	else
	  bfd_putb64 (val, hit_addr);
      else
	if (size == 4)
	  bfd_putl32 (val, hit_addr);
	else
	  bfd_putl64 (val, hit_addr);
      break;
    }

  return bfd_reloc_ok;
}
@


1.232
log
@	* bfd-in.h (bfd_get_section_limit): Don't use rawsize with output
	sections.
	* libbfd.c (_bfd_generic_get_section_contents): Likewise.
	(_bfd_generic_get_section_contents_in_window): Likewise.
	* section.c (bfd_get_section_contents): Likewise.
	* compress.c (bfd_get_full_section_contents): Likewise.
	* elf32-rx.c (rx_final_link): Ignore rawsize.
	* elf32-microblaze.c (microblaze_elf_relocate_section): Use correct
	bfd with bfd_get_section_limit.
	* elfxx-ia64.c (elfNN_ia64_choose_gp): Add "final" parameter.  Use
	os->size during final link.  Update callers.
	* bfd-in2.h: Regenerate.
@
text
@d32 1
a32 10

#define ARCH_SIZE	NN

#if ARCH_SIZE == 64
#define	LOG_SECTION_ALIGN	3
#endif

#if ARCH_SIZE == 32
#define	LOG_SECTION_ALIGN	2
#endif
d62 1
a62 8
/* Only add code for vms when the vms target is enabled.  This is required
   because it depends on vms-lib.c for its archive format and we don't want
   to compile that code if it is not used.  */
#if ARCH_SIZE == 64 && \
  (defined (HAVE_bfd_elf64_ia64_vms_vec) || defined (HAVE_all_vecs))
#define INCLUDE_IA64_VMS
#endif

a65 159
typedef struct bfd_hash_entry *(*new_hash_entry_func)
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);

/* In dynamically (linker-) created sections, we generally need to keep track
   of the place a symbol or expression got allocated to. This is done via hash
   tables that store entries of the following type.  */

struct elfNN_ia64_dyn_sym_info
{
  /* The addend for which this entry is relevant.  */
  bfd_vma addend;

  bfd_vma got_offset;
  bfd_vma fptr_offset;
  bfd_vma pltoff_offset;
  bfd_vma plt_offset;
  bfd_vma plt2_offset;
  bfd_vma tprel_offset;
  bfd_vma dtpmod_offset;
  bfd_vma dtprel_offset;

  /* The symbol table entry, if any, that this was derived from.  */
  struct elf_link_hash_entry *h;

  /* Used to count non-got, non-plt relocations for delayed sizing
     of relocation sections.  */
  struct elfNN_ia64_dyn_reloc_entry
  {
    struct elfNN_ia64_dyn_reloc_entry *next;
    asection *srel;
    int type;
    int count;

    /* Is this reloc against readonly section? */
    bfd_boolean reltext;
  } *reloc_entries;

  /* TRUE when the section contents have been updated.  */
  unsigned got_done : 1;
  unsigned fptr_done : 1;
  unsigned pltoff_done : 1;
  unsigned tprel_done : 1;
  unsigned dtpmod_done : 1;
  unsigned dtprel_done : 1;

  /* TRUE for the different kinds of linker data we want created.  */
  unsigned want_got : 1;
  unsigned want_gotx : 1;
  unsigned want_fptr : 1;
  unsigned want_ltoff_fptr : 1;
  unsigned want_plt : 1;
  unsigned want_plt2 : 1;
  unsigned want_pltoff : 1;
  unsigned want_tprel : 1;
  unsigned want_dtpmod : 1;
  unsigned want_dtprel : 1;
};

struct elfNN_ia64_local_hash_entry
{
  int id;
  unsigned int r_sym;
  /* The number of elements in elfNN_ia64_dyn_sym_info array.  */
  unsigned int count;
  /* The number of sorted elements in elfNN_ia64_dyn_sym_info array.  */
  unsigned int sorted_count;
  /* The size of elfNN_ia64_dyn_sym_info array.  */
  unsigned int size;
  /* The array of elfNN_ia64_dyn_sym_info.  */
  struct elfNN_ia64_dyn_sym_info *info;

  /* TRUE if this hash entry's addends was translated for
     SHF_MERGE optimization.  */
  unsigned sec_merge_done : 1;
};

struct elfNN_ia64_link_hash_entry
{
  struct elf_link_hash_entry root;
  /* The number of elements in elfNN_ia64_dyn_sym_info array.  */
  unsigned int count;
  /* The number of sorted elements in elfNN_ia64_dyn_sym_info array.  */
  unsigned int sorted_count;
  /* The size of elfNN_ia64_dyn_sym_info array.  */
  unsigned int size;
  /* The array of elfNN_ia64_dyn_sym_info.  */
  struct elfNN_ia64_dyn_sym_info *info;
};

struct elfNN_ia64_link_hash_table
{
  /* The main hash table.  */
  struct elf_link_hash_table root;

  asection *fptr_sec;		/* Function descriptor table (or NULL).  */
  asection *rel_fptr_sec;	/* Dynamic relocation section for same.  */
  asection *pltoff_sec;		/* Private descriptors for plt (or NULL).  */
  asection *rel_pltoff_sec;	/* Dynamic relocation section for same.  */

  bfd_size_type minplt_entries;	/* Number of minplt entries.  */
  unsigned reltext : 1;		/* Are there relocs against readonly sections?  */
  unsigned self_dtpmod_done : 1;/* Has self DTPMOD entry been finished?  */
  bfd_vma self_dtpmod_offset;	/* .got offset to self DTPMOD entry.  */
  /* There are maybe R_IA64_GPREL22 relocations, including those
     optimized from R_IA64_LTOFF22X, against non-SHF_IA_64_SHORT
     sections.  We need to record those sections so that we can choose
     a proper GP to cover all R_IA64_GPREL22 relocations.  */
  asection *max_short_sec;	/* Maximum short output section.  */
  bfd_vma max_short_offset;	/* Maximum short offset.  */
  asection *min_short_sec;	/* Minimum short output section.  */
  bfd_vma min_short_offset;	/* Minimum short offset.  */

  htab_t loc_hash_table;
  void *loc_hash_memory;
};

struct elfNN_ia64_allocate_data
{
  struct bfd_link_info *info;
  bfd_size_type ofs;
  bfd_boolean only_got;
};

#define elfNN_ia64_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == IA64_ELF_DATA ? ((struct elfNN_ia64_link_hash_table *) ((p)->hash)) : NULL)

static struct elfNN_ia64_dyn_sym_info * get_dyn_sym_info
  (struct elfNN_ia64_link_hash_table *ia64_info,
   struct elf_link_hash_entry *h,
   bfd *abfd, const Elf_Internal_Rela *rel, bfd_boolean create);
static bfd_boolean elfNN_ia64_dynamic_symbol_p
  (struct elf_link_hash_entry *h, struct bfd_link_info *info, int);
static bfd_reloc_status_type elfNN_ia64_install_value
  (bfd_byte *hit_addr, bfd_vma val, unsigned int r_type);
static bfd_boolean elfNN_ia64_choose_gp
  (bfd *abfd, struct bfd_link_info *info, bfd_boolean final);
static void elfNN_ia64_relax_ldxmov
  (bfd_byte *contents, bfd_vma off);
static void elfNN_ia64_dyn_sym_traverse
  (struct elfNN_ia64_link_hash_table *ia64_info,
   bfd_boolean (*func) (struct elfNN_ia64_dyn_sym_info *, PTR),
   PTR info);
static bfd_boolean allocate_global_data_got
  (struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data);
static bfd_boolean allocate_global_fptr_got
  (struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data);
static bfd_boolean allocate_local_got
  (struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data);
static bfd_boolean elfNN_ia64_hpux_vec
  (const bfd_target *vec);
static bfd_boolean allocate_dynrel_entries
  (struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data);
static asection *get_pltoff
  (bfd *abfd, struct bfd_link_info *info,
   struct elfNN_ia64_link_hash_table *ia64_info);

/* ia64-specific relocation.  */

d69 4
a72 4
elfNN_ia64_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc,
		  asymbol *sym ATTRIBUTE_UNUSED,
		  PTR data ATTRIBUTE_UNUSED, asection *input_section,
		  bfd *output_bfd, char **error_message)
d83 1
a83 1
  *error_message = "Unsupported call to elfNN_ia64_reloc";
d89 1
a89 1
	 elfNN_ia64_reloc, NAME, FALSE, 0, -1, IN)
d197 2
a198 2
static reloc_howto_type *
lookup_howto (unsigned int rtype)
d220 3
a222 3
static reloc_howto_type*
elfNN_ia64_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			      bfd_reloc_code_real_type bfd_code)
d326 1
a326 1
  return lookup_howto (rtype);
d329 3
a331 3
static reloc_howto_type *
elfNN_ia64_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			      const char *r_name)
a344 76
/* Given a ELF reloc, return the matching HOWTO structure.  */

static void
elfNN_ia64_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			  arelent *bfd_reloc,
			  Elf_Internal_Rela *elf_reloc)
{
  bfd_reloc->howto
    = lookup_howto ((unsigned int) ELFNN_R_TYPE (elf_reloc->r_info));
}

#define PLT_HEADER_SIZE		(3 * 16)
#define PLT_MIN_ENTRY_SIZE	(1 * 16)
#define PLT_FULL_ENTRY_SIZE	(2 * 16)
#define PLT_RESERVED_WORDS	3

static const bfd_byte plt_header[PLT_HEADER_SIZE] =
{
  0x0b, 0x10, 0x00, 0x1c, 0x00, 0x21,  /*   [MMI]       mov r2=r14;;       */
  0xe0, 0x00, 0x08, 0x00, 0x48, 0x00,  /*               addl r14=0,r2      */
  0x00, 0x00, 0x04, 0x00,              /*               nop.i 0x0;;        */
  0x0b, 0x80, 0x20, 0x1c, 0x18, 0x14,  /*   [MMI]       ld8 r16=[r14],8;;  */
  0x10, 0x41, 0x38, 0x30, 0x28, 0x00,  /*               ld8 r17=[r14],8    */
  0x00, 0x00, 0x04, 0x00,              /*               nop.i 0x0;;        */
  0x11, 0x08, 0x00, 0x1c, 0x18, 0x10,  /*   [MIB]       ld8 r1=[r14]       */
  0x60, 0x88, 0x04, 0x80, 0x03, 0x00,  /*               mov b6=r17         */
  0x60, 0x00, 0x80, 0x00               /*               br.few b6;;        */
};

static const bfd_byte plt_min_entry[PLT_MIN_ENTRY_SIZE] =
{
  0x11, 0x78, 0x00, 0x00, 0x00, 0x24,  /*   [MIB]       mov r15=0          */
  0x00, 0x00, 0x00, 0x02, 0x00, 0x00,  /*               nop.i 0x0          */
  0x00, 0x00, 0x00, 0x40               /*               br.few 0 <PLT0>;;  */
};

static const bfd_byte plt_full_entry[PLT_FULL_ENTRY_SIZE] =
{
  0x0b, 0x78, 0x00, 0x02, 0x00, 0x24,  /*   [MMI]       addl r15=0,r1;;    */
  0x00, 0x41, 0x3c, 0x70, 0x29, 0xc0,  /*               ld8.acq r16=[r15],8*/
  0x01, 0x08, 0x00, 0x84,              /*               mov r14=r1;;       */
  0x11, 0x08, 0x00, 0x1e, 0x18, 0x10,  /*   [MIB]       ld8 r1=[r15]       */
  0x60, 0x80, 0x04, 0x80, 0x03, 0x00,  /*               mov b6=r16         */
  0x60, 0x00, 0x80, 0x00               /*               br.few b6;;        */
};

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so.1"

static const bfd_byte oor_brl[16] =
{
  0x05, 0x00, 0x00, 0x00, 0x01, 0x00,  /*  [MLX]        nop.m 0            */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /*               brl.sptk.few tgt;; */
  0x00, 0x00, 0x00, 0xc0
};

static const bfd_byte oor_ip[48] =
{
  0x04, 0x00, 0x00, 0x00, 0x01, 0x00,  /*  [MLX]        nop.m 0            */
  0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,  /*               movl r15=0         */
  0x01, 0x00, 0x00, 0x60,
  0x03, 0x00, 0x00, 0x00, 0x01, 0x00,  /*  [MII]        nop.m 0            */
  0x00, 0x01, 0x00, 0x60, 0x00, 0x00,  /*               mov r16=ip;;       */
  0xf2, 0x80, 0x00, 0x80,              /*               add r16=r15,r16;;  */
  0x11, 0x00, 0x00, 0x00, 0x01, 0x00,  /*  [MIB]        nop.m 0            */
  0x60, 0x80, 0x04, 0x80, 0x03, 0x00,  /*               mov b6=r16         */
  0x60, 0x00, 0x80, 0x00               /*               br b6;;            */
};

static size_t oor_branch_size = sizeof (oor_brl);

void
bfd_elfNN_ia64_after_parse (int itanium)
{
  oor_branch_size = itanium ? sizeof (oor_ip) : sizeof (oor_brl);
}

d380 2
a381 2
static bfd_boolean
elfNN_ia64_relax_br (bfd_byte *contents, bfd_vma off)
d483 2
a484 2
static void
elfNN_ia64_relax_brl (bfd_byte *contents, bfd_vma off)
d515 2
a516 595
/* Rename some of the generic section flags to better document how they
   are used here.  */
#define skip_relax_pass_0 sec_flg0
#define skip_relax_pass_1 sec_flg1


/* These functions do relaxation for IA-64 ELF.  */

static void
elfNN_ia64_update_short_info (asection *sec, bfd_vma offset,
			      struct elfNN_ia64_link_hash_table *ia64_info)
{
  /* Skip ABS and SHF_IA_64_SHORT sections.  */
  if (sec == bfd_abs_section_ptr
      || (sec->flags & SEC_SMALL_DATA) != 0)
    return;

  if (!ia64_info->min_short_sec)
    {
      ia64_info->max_short_sec = sec;
      ia64_info->max_short_offset = offset;
      ia64_info->min_short_sec = sec;
      ia64_info->min_short_offset = offset;
    }
  else if (sec == ia64_info->max_short_sec
	   && offset > ia64_info->max_short_offset)
    ia64_info->max_short_offset = offset;
  else if (sec == ia64_info->min_short_sec
	   && offset < ia64_info->min_short_offset)
    ia64_info->min_short_offset = offset;
  else if (sec->output_section->vma
	   > ia64_info->max_short_sec->vma)
    {
      ia64_info->max_short_sec = sec;
      ia64_info->max_short_offset = offset;
    }
  else if (sec->output_section->vma
	   < ia64_info->min_short_sec->vma)
    {
      ia64_info->min_short_sec = sec;
      ia64_info->min_short_offset = offset;
    }
}

static bfd_boolean
elfNN_ia64_relax_section (bfd *abfd, asection *sec,
			  struct bfd_link_info *link_info,
			  bfd_boolean *again)
{
  struct one_fixup
    {
      struct one_fixup *next;
      asection *tsec;
      bfd_vma toff;
      bfd_vma trampoff;
    };

  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents;
  Elf_Internal_Sym *isymbuf = NULL;
  struct elfNN_ia64_link_hash_table *ia64_info;
  struct one_fixup *fixups = NULL;
  bfd_boolean changed_contents = FALSE;
  bfd_boolean changed_relocs = FALSE;
  bfd_boolean changed_got = FALSE;
  bfd_boolean skip_relax_pass_0 = TRUE;
  bfd_boolean skip_relax_pass_1 = TRUE;
  bfd_vma gp = 0;

  /* Assume we're not going to change any sizes, and we'll only need
     one pass.  */
  *again = FALSE;

  if (link_info->relocatable)
    (*link_info->callbacks->einfo)
      (_("%P%F: --relax and -r may not be used together\n"));

  /* Don't even try to relax for non-ELF outputs.  */
  if (!is_elf_hash_table (link_info->hash))
    return FALSE;

  /* Nothing to do if there are no relocations or there is no need for
     the current pass.  */
  if ((sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (link_info->relax_pass == 0 && sec->skip_relax_pass_0)
      || (link_info->relax_pass == 1 && sec->skip_relax_pass_1))
    return TRUE;

  ia64_info = elfNN_ia64_hash_table (link_info);
  if (ia64_info == NULL)
    return FALSE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Load the relocations for this section.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    return FALSE;

  irelend = internal_relocs + sec->reloc_count;

  /* Get the section contents.  */
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    contents = elf_section_data (sec)->this_hdr.contents;
  else
    {
      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	goto error_return;
    }

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      unsigned long r_type = ELFNN_R_TYPE (irel->r_info);
      bfd_vma symaddr, reladdr, trampoff, toff, roff;
      asection *tsec;
      struct one_fixup *f;
      bfd_size_type amt;
      bfd_boolean is_branch;
      struct elfNN_ia64_dyn_sym_info *dyn_i;
      char symtype;

      switch (r_type)
	{
	case R_IA64_PCREL21B:
	case R_IA64_PCREL21BI:
	case R_IA64_PCREL21M:
	case R_IA64_PCREL21F:
	  /* In pass 1, all br relaxations are done. We can skip it. */
	  if (link_info->relax_pass == 1)
	    continue;
	  skip_relax_pass_0 = FALSE;
	  is_branch = TRUE;
	  break;

	case R_IA64_PCREL60B:
	  /* We can't optimize brl to br in pass 0 since br relaxations
	     will increase the code size. Defer it to pass 1.  */
	  if (link_info->relax_pass == 0)
	    {
	      skip_relax_pass_1 = FALSE;
	      continue;
	    }
	  is_branch = TRUE;
	  break;

	case R_IA64_GPREL22:
	  /* Update max_short_sec/min_short_sec.  */

	case R_IA64_LTOFF22X:
	case R_IA64_LDXMOV:
	  /* We can't relax ldx/mov in pass 0 since br relaxations will
	     increase the code size. Defer it to pass 1.  */
	  if (link_info->relax_pass == 0)
	    {
	      skip_relax_pass_1 = FALSE;
	      continue;
	    }
	  is_branch = FALSE;
	  break;

	default:
	  continue;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELFNN_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == 0)
		goto error_return;
	    }

	  isym = isymbuf + ELFNN_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    continue;	/* We can't do anything with undefined symbols.  */
	  else if (isym->st_shndx == SHN_ABS)
	    tsec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    tsec = bfd_com_section_ptr;
	  else if (isym->st_shndx == SHN_IA_64_ANSI_COMMON)
	    tsec = bfd_com_section_ptr;
	  else
	    tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);

	  toff = isym->st_value;
	  dyn_i = get_dyn_sym_info (ia64_info, NULL, abfd, irel, FALSE);
	  symtype = ELF_ST_TYPE (isym->st_info);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  indx = ELFNN_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  dyn_i = get_dyn_sym_info (ia64_info, h, abfd, irel, FALSE);

	  /* For branches to dynamic symbols, we're interested instead
	     in a branch to the PLT entry.  */
	  if (is_branch && dyn_i && dyn_i->want_plt2)
	    {
	      /* Internal branches shouldn't be sent to the PLT.
		 Leave this for now and we'll give an error later.  */
	      if (r_type != R_IA64_PCREL21B)
		continue;

	      tsec = ia64_info->root.splt;
	      toff = dyn_i->plt2_offset;
	      BFD_ASSERT (irel->r_addend == 0);
	    }

	  /* Can't do anything else with dynamic symbols.  */
	  else if (elfNN_ia64_dynamic_symbol_p (h, link_info, r_type))
	    continue;

	  else
	    {
	      /* We can't do anything with undefined symbols.  */
	      if (h->root.type == bfd_link_hash_undefined
		  || h->root.type == bfd_link_hash_undefweak)
		continue;

	      tsec = h->root.u.def.section;
	      toff = h->root.u.def.value;
	    }

	  symtype = h->type;
	}

      if (tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	{
	  /* At this stage in linking, no SEC_MERGE symbol has been
	     adjusted, so all references to such symbols need to be
	     passed through _bfd_merged_section_offset.  (Later, in
	     relocate_section, all SEC_MERGE symbols *except* for
	     section symbols have been adjusted.)

	     gas may reduce relocations against symbols in SEC_MERGE
	     sections to a relocation against the section symbol when
	     the original addend was zero.  When the reloc is against
	     a section symbol we should include the addend in the
	     offset passed to _bfd_merged_section_offset, since the
	     location of interest is the original symbol.  On the
	     other hand, an access to "sym+addend" where "sym" is not
	     a section symbol should not include the addend;  Such an
	     access is presumed to be an offset from "sym";  The
	     location of interest is just "sym".  */
	   if (symtype == STT_SECTION)
	     toff += irel->r_addend;

	   toff = _bfd_merged_section_offset (abfd, &tsec,
					      elf_section_data (tsec)->sec_info,
					      toff);

	   if (symtype != STT_SECTION)
	     toff += irel->r_addend;
	}
      else
	toff += irel->r_addend;

      symaddr = tsec->output_section->vma + tsec->output_offset + toff;

      roff = irel->r_offset;

      if (is_branch)
	{
	  bfd_signed_vma offset;

	  reladdr = (sec->output_section->vma
		     + sec->output_offset
		     + roff) & (bfd_vma) -4;

	  /* The .plt section is aligned at 32byte and the .text section
	     is aligned at 64byte. The .text section is right after the
	     .plt section.  After the first relaxation pass, linker may
	     increase the gap between the .plt and .text sections up
	     to 32byte.  We assume linker will always insert 32byte
	     between the .plt and .text sections after the the first
	     relaxation pass.  */
	  if (tsec == ia64_info->root.splt)
	    offset = -0x1000000 + 32;
	  else
	    offset = -0x1000000;

	  /* If the branch is in range, no need to do anything.  */
	  if ((bfd_signed_vma) (symaddr - reladdr) >= offset 
	      && (bfd_signed_vma) (symaddr - reladdr) <= 0x0FFFFF0)
	    {
	      /* If the 60-bit branch is in 21-bit range, optimize it. */
	      if (r_type == R_IA64_PCREL60B)
		{
		  elfNN_ia64_relax_brl (contents, roff);

		  irel->r_info
		    = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
				    R_IA64_PCREL21B);

		  /* If the original relocation offset points to slot
		     1, change it to slot 2.  */
		  if ((irel->r_offset & 3) == 1)
		    irel->r_offset += 1;
		}

	      continue;
	    }
	  else if (r_type == R_IA64_PCREL60B)
	    continue;
	  else if (elfNN_ia64_relax_br (contents, roff))
	    {
	      irel->r_info
		= ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
				R_IA64_PCREL60B);

	      /* Make the relocation offset point to slot 1.  */
	      irel->r_offset = (irel->r_offset & ~((bfd_vma) 0x3)) + 1;
	      continue;
	    }

	  /* We can't put a trampoline in a .init/.fini section. Issue
	     an error.  */
	  if (strcmp (sec->output_section->name, ".init") == 0
	      || strcmp (sec->output_section->name, ".fini") == 0)
	    {
	      (*_bfd_error_handler)
		(_("%B: Can't relax br at 0x%lx in section `%A'. Please use brl or indirect branch."),
		 sec->owner, sec, (unsigned long) roff);
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }

	  /* If the branch and target are in the same section, you've
	     got one honking big section and we can't help you unless
	     you are branching backwards.  You'll get an error message
	     later.  */
	  if (tsec == sec && toff > roff)
	    continue;

	  /* Look for an existing fixup to this address.  */
	  for (f = fixups; f ; f = f->next)
	    if (f->tsec == tsec && f->toff == toff)
	      break;

	  if (f == NULL)
	    {
	      /* Two alternatives: If it's a branch to a PLT entry, we can
		 make a copy of the FULL_PLT entry.  Otherwise, we'll have
		 to use a `brl' insn to get where we're going.  */

	      size_t size;

	      if (tsec == ia64_info->root.splt)
		size = sizeof (plt_full_entry);
	      else
		size = oor_branch_size;

	      /* Resize the current section to make room for the new branch. */
	      trampoff = (sec->size + 15) & (bfd_vma) -16;

	      /* If trampoline is out of range, there is nothing we
		 can do.  */
	      offset = trampoff - (roff & (bfd_vma) -4);
	      if (offset < -0x1000000 || offset > 0x0FFFFF0)
		continue;

	      amt = trampoff + size;
	      contents = (bfd_byte *) bfd_realloc (contents, amt);
	      if (contents == NULL)
		goto error_return;
	      sec->size = amt;

	      if (tsec == ia64_info->root.splt)
		{
		  memcpy (contents + trampoff, plt_full_entry, size);

		  /* Hijack the old relocation for use as the PLTOFF reloc.  */
		  irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
					       R_IA64_PLTOFF22);
		  irel->r_offset = trampoff;
		}
	      else
		{
		  if (size == sizeof (oor_ip))
		    {
		      memcpy (contents + trampoff, oor_ip, size);
		      irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
						   R_IA64_PCREL64I);
		      irel->r_addend -= 16;
		      irel->r_offset = trampoff + 2;
		    }
		  else
		    {
		      memcpy (contents + trampoff, oor_brl, size);
		      irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
						   R_IA64_PCREL60B);
		      irel->r_offset = trampoff + 2;
		    }

		}

	      /* Record the fixup so we don't do it again this section.  */
	      f = (struct one_fixup *)
		bfd_malloc ((bfd_size_type) sizeof (*f));
	      f->next = fixups;
	      f->tsec = tsec;
	      f->toff = toff;
	      f->trampoff = trampoff;
	      fixups = f;
	    }
	  else
	    {
	      /* If trampoline is out of range, there is nothing we
		 can do.  */
	      offset = f->trampoff - (roff & (bfd_vma) -4);
	      if (offset < -0x1000000 || offset > 0x0FFFFF0)
		continue;

	      /* Nop out the reloc, since we're finalizing things here.  */
	      irel->r_info = ELFNN_R_INFO (0, R_IA64_NONE);
	    }

	  /* Fix up the existing branch to hit the trampoline.  */
	  if (elfNN_ia64_install_value (contents + roff, offset, r_type)
	      != bfd_reloc_ok)
	    goto error_return;

	  changed_contents = TRUE;
	  changed_relocs = TRUE;
	}
      else
	{
	  /* Fetch the gp.  */
	  if (gp == 0)
	    {
	      bfd *obfd = sec->output_section->owner;
	      gp = _bfd_get_gp_value (obfd);
	      if (gp == 0)
		{
		  if (!elfNN_ia64_choose_gp (obfd, link_info, FALSE))
		    goto error_return;
		  gp = _bfd_get_gp_value (obfd);
		}
	    }

	  /* If the data is out of range, do nothing.  */
	  if ((bfd_signed_vma) (symaddr - gp) >= 0x200000
	      ||(bfd_signed_vma) (symaddr - gp) < -0x200000)
	    continue;

	  if (r_type == R_IA64_GPREL22)
	    elfNN_ia64_update_short_info (tsec->output_section,
					  tsec->output_offset + toff,
					  ia64_info);
	  else if (r_type == R_IA64_LTOFF22X)
	    {
	      irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
					   R_IA64_GPREL22);
	      changed_relocs = TRUE;
	      if (dyn_i->want_gotx)
		{
		  dyn_i->want_gotx = 0;
		  changed_got |= !dyn_i->want_got;
		}

	      elfNN_ia64_update_short_info (tsec->output_section,
					    tsec->output_offset + toff,
					    ia64_info);
	    }
	  else
	    {
	      elfNN_ia64_relax_ldxmov (contents, roff);
	      irel->r_info = ELFNN_R_INFO (0, R_IA64_NONE);
	      changed_contents = TRUE;
	      changed_relocs = TRUE;
	    }
	}
    }

  /* ??? If we created fixups, this may push the code segment large
     enough that the data segment moves, which will change the GP.
     Reset the GP so that we re-calculate next round.  We need to
     do this at the _beginning_ of the next round; now will not do.  */

  /* Clean up and go home.  */
  while (fixups)
    {
      struct one_fixup *f = fixups;
      fixups = fixups->next;
      free (f);
    }

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (!changed_contents && !link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  if (elf_section_data (sec)->relocs != internal_relocs)
    {
      if (!changed_relocs)
	free (internal_relocs);
      else
	elf_section_data (sec)->relocs = internal_relocs;
    }

  if (changed_got)
    {
      struct elfNN_ia64_allocate_data data;
      data.info = link_info;
      data.ofs = 0;
      ia64_info->self_dtpmod_offset = (bfd_vma) -1;

      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_global_data_got, &data);
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_global_fptr_got, &data);
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_local_got, &data);
      ia64_info->root.sgot->size = data.ofs;

      if (ia64_info->root.dynamic_sections_created
	  && ia64_info->root.srelgot != NULL)
	{
	  /* Resize .rela.got.  */
	  ia64_info->root.srelgot->size = 0;
	  if (link_info->shared
	      && ia64_info->self_dtpmod_offset != (bfd_vma) -1)
	    ia64_info->root.srelgot->size += sizeof (ElfNN_External_Rela);
	  data.only_got = TRUE;
	  elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_dynrel_entries,
				       &data);
	}
    }

  if (link_info->relax_pass == 0)
    {
      /* Pass 0 is only needed to relax br.  */
      sec->skip_relax_pass_0 = skip_relax_pass_0;
      sec->skip_relax_pass_1 = skip_relax_pass_1;
    }

  *again = changed_contents || changed_relocs;
  return TRUE;

 error_return:
  if (isymbuf != NULL && (unsigned char *) isymbuf != symtab_hdr->contents)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}
#undef skip_relax_pass_0
#undef skip_relax_pass_1

static void
elfNN_ia64_relax_ldxmov (bfd_byte *contents, bfd_vma off)
d545 15
a559 1
/* Return TRUE if NAME is an unwind table section name.  */
d561 6
a566 6
static inline bfd_boolean
is_unwind_section_name (bfd *abfd, const char *name)
{
  if (elfNN_ia64_hpux_vec (abfd->xvec)
      && !strcmp (name, ELF_STRING_ia64_unwind_hdr))
    return FALSE;
d568 1
a568 4
  return ((CONST_STRNEQ (name, ELF_STRING_ia64_unwind)
	   && ! CONST_STRNEQ (name, ELF_STRING_ia64_unwind_info))
	  || CONST_STRNEQ (name, ELF_STRING_ia64_unwind_once));
}
d570 4
a573 19
/* Handle an IA-64 specific section when reading an object file.  This
   is called when bfd_section_from_shdr finds a section with an unknown
   type.  */

static bfd_boolean
elfNN_ia64_section_from_shdr (bfd *abfd,
			      Elf_Internal_Shdr *hdr,
			      const char *name,
			      int shindex)
{
  /* There ought to be a place to keep ELF backend specific flags, but
     at the moment there isn't one.  We just keep track of the
     sections by their name, instead.  Fortunately, the ABI gives
     suggested names for all the MIPS specific sections, so we will
     probably get away with this.  */
  switch (hdr->sh_type)
    {
    case SHT_IA_64_UNWIND:
    case SHT_IA_64_HP_OPT_ANOT:
d576 6
a581 3
    case SHT_IA_64_EXT:
      if (strcmp (name, ELF_STRING_ia64_archext) != 0)
	return FALSE;
d584 14
a597 3
    default:
      return FALSE;
    }
d599 11
a609 2
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
    return FALSE;
d611 1
a611 2
  return TRUE;
}
d613 11
a623 1
/* Convert IA-64 specific section flags to bfd internal section flags.  */
d625 11
a635 2
/* ??? There is no bfd internal flag equivalent to the SHF_IA_64_NORECOV
   flag.  */
d637 14
a650 6
static bfd_boolean
elfNN_ia64_section_flags (flagword *flags,
			  const Elf_Internal_Shdr *hdr)
{
  if (hdr->sh_flags & SHF_IA_64_SHORT)
    *flags |= SEC_SMALL_DATA;
d652 11
a662 2591
  return TRUE;
}

/* Set the correct type for an IA-64 ELF section.  We do this by the
   section name, which is a hack, but ought to work.  */

static bfd_boolean
elfNN_ia64_fake_sections (bfd *abfd, Elf_Internal_Shdr *hdr,
			  asection *sec)
{
  const char *name;

  name = bfd_get_section_name (abfd, sec);

  if (is_unwind_section_name (abfd, name))
    {
      /* We don't have the sections numbered at this point, so sh_info
	 is set later, in elfNN_ia64_final_write_processing.  */
      hdr->sh_type = SHT_IA_64_UNWIND;
      hdr->sh_flags |= SHF_LINK_ORDER;
    }
  else if (strcmp (name, ELF_STRING_ia64_archext) == 0)
    hdr->sh_type = SHT_IA_64_EXT;
  else if (strcmp (name, ".HP.opt_annot") == 0)
    hdr->sh_type = SHT_IA_64_HP_OPT_ANOT;
  else if (strcmp (name, ".reloc") == 0)
    /* This is an ugly, but unfortunately necessary hack that is
       needed when producing EFI binaries on IA-64. It tells
       elf.c:elf_fake_sections() not to consider ".reloc" as a section
       containing ELF relocation info.  We need this hack in order to
       be able to generate ELF binaries that can be translated into
       EFI applications (which are essentially COFF objects).  Those
       files contain a COFF ".reloc" section inside an ELFNN object,
       which would normally cause BFD to segfault because it would
       attempt to interpret this section as containing relocation
       entries for section "oc".  With this hack enabled, ".reloc"
       will be treated as a normal data section, which will avoid the
       segfault.  However, you won't be able to create an ELFNN binary
       with a section named "oc" that needs relocations, but that's
       the kind of ugly side-effects you get when detecting section
       types based on their names...  In practice, this limitation is
       unlikely to bite.  */
    hdr->sh_type = SHT_PROGBITS;

  if (sec->flags & SEC_SMALL_DATA)
    hdr->sh_flags |= SHF_IA_64_SHORT;

  /* Some HP linkers look for the SHF_IA_64_HP_TLS flag instead of SHF_TLS. */

  if (elfNN_ia64_hpux_vec (abfd->xvec) && (sec->flags & SHF_TLS))
    hdr->sh_flags |= SHF_IA_64_HP_TLS;

  return TRUE;
}

/* The final processing done just before writing out an IA-64 ELF
   object file.  */

static void
elfNN_ia64_final_write_processing (bfd *abfd,
				   bfd_boolean linker ATTRIBUTE_UNUSED)
{
  Elf_Internal_Shdr *hdr;
  asection *s;

  for (s = abfd->sections; s; s = s->next)
    {
      hdr = &elf_section_data (s)->this_hdr;
      switch (hdr->sh_type)
	{
	case SHT_IA_64_UNWIND:
	  /* The IA-64 processor-specific ABI requires setting sh_link
	     to the unwind section, whereas HP-UX requires sh_info to
	     do so.  For maximum compatibility, we'll set both for
	     now... */
	  hdr->sh_info = hdr->sh_link;
	  break;
	}
    }

  if (! elf_flags_init (abfd))
    {
      unsigned long flags = 0;

      if (abfd->xvec->byteorder == BFD_ENDIAN_BIG)
	flags |= EF_IA_64_BE;
      if (bfd_get_mach (abfd) == bfd_mach_ia64_elf64)
	flags |= EF_IA_64_ABI64;

      elf_elfheader(abfd)->e_flags = flags;
      elf_flags_init (abfd) = TRUE;
    }
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .sbss, and not .bss.  */

static bfd_boolean
elfNN_ia64_add_symbol_hook (bfd *abfd,
			    struct bfd_link_info *info,
			    Elf_Internal_Sym *sym,
			    const char **namep ATTRIBUTE_UNUSED,
			    flagword *flagsp ATTRIBUTE_UNUSED,
			    asection **secp,
			    bfd_vma *valp)
{
  if (sym->st_shndx == SHN_COMMON
      && !info->relocatable
      && sym->st_size <= elf_gp_size (abfd))
    {
      /* Common symbols less than or equal to -G nn bytes are
	 automatically put into .sbss.  */

      asection *scomm = bfd_get_section_by_name (abfd, ".scommon");

      if (scomm == NULL)
	{
	  scomm = bfd_make_section_with_flags (abfd, ".scommon",
					       (SEC_ALLOC
						| SEC_IS_COMMON
						| SEC_LINKER_CREATED));
	  if (scomm == NULL)
	    return FALSE;
	}

      *secp = scomm;
      *valp = sym->st_size;
    }

  return TRUE;
}

/* Return the number of additional phdrs we will need.  */

static int
elfNN_ia64_additional_program_headers (bfd *abfd,
				       struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  asection *s;
  int ret = 0;

  /* See if we need a PT_IA_64_ARCHEXT segment.  */
  s = bfd_get_section_by_name (abfd, ELF_STRING_ia64_archext);
  if (s && (s->flags & SEC_LOAD))
    ++ret;

  /* Count how many PT_IA_64_UNWIND segments we need.  */
  for (s = abfd->sections; s; s = s->next)
    if (is_unwind_section_name (abfd, s->name) && (s->flags & SEC_LOAD))
      ++ret;

  return ret;
}

static bfd_boolean
elfNN_ia64_modify_segment_map (bfd *abfd,
			       struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  struct elf_segment_map *m, **pm;
  Elf_Internal_Shdr *hdr;
  asection *s;

  /* If we need a PT_IA_64_ARCHEXT segment, it must come before
     all PT_LOAD segments.  */
  s = bfd_get_section_by_name (abfd, ELF_STRING_ia64_archext);
  if (s && (s->flags & SEC_LOAD))
    {
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_IA_64_ARCHEXT)
	  break;
      if (m == NULL)
	{
	  m = ((struct elf_segment_map *)
	       bfd_zalloc (abfd, (bfd_size_type) sizeof *m));
	  if (m == NULL)
	    return FALSE;

	  m->p_type = PT_IA_64_ARCHEXT;
	  m->count = 1;
	  m->sections[0] = s;

	  /* We want to put it after the PHDR and INTERP segments.  */
	  pm = &elf_tdata (abfd)->segment_map;
	  while (*pm != NULL
		 && ((*pm)->p_type == PT_PHDR
		     || (*pm)->p_type == PT_INTERP))
	    pm = &(*pm)->next;

	  m->next = *pm;
	  *pm = m;
	}
    }

  /* Install PT_IA_64_UNWIND segments, if needed.  */
  for (s = abfd->sections; s; s = s->next)
    {
      hdr = &elf_section_data (s)->this_hdr;
      if (hdr->sh_type != SHT_IA_64_UNWIND)
	continue;

      if (s && (s->flags & SEC_LOAD))
	{
	  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	    if (m->p_type == PT_IA_64_UNWIND)
	      {
		int i;

		/* Look through all sections in the unwind segment
		   for a match since there may be multiple sections
		   to a segment.  */
		for (i = m->count - 1; i >= 0; --i)
		  if (m->sections[i] == s)
		    break;

		if (i >= 0)
		  break;
	      }

	  if (m == NULL)
	    {
	      m = ((struct elf_segment_map *)
		   bfd_zalloc (abfd, (bfd_size_type) sizeof *m));
	      if (m == NULL)
		return FALSE;

	      m->p_type = PT_IA_64_UNWIND;
	      m->count = 1;
	      m->sections[0] = s;
	      m->next = NULL;

	      /* We want to put it last.  */
	      pm = &elf_tdata (abfd)->segment_map;
	      while (*pm != NULL)
		pm = &(*pm)->next;
	      *pm = m;
	    }
	}
    }

  return TRUE;
}

/* Turn on PF_IA_64_NORECOV if needed.  This involves traversing all of
   the input sections for each output section in the segment and testing
   for SHF_IA_64_NORECOV on each.  */

static bfd_boolean
elfNN_ia64_modify_program_headers (bfd *abfd,
				   struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  struct elf_obj_tdata *tdata = elf_tdata (abfd);
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  for (p = tdata->phdr, m = tdata->segment_map; m != NULL; m = m->next, p++)
    if (m->p_type == PT_LOAD)
      {
	int i;
	for (i = m->count - 1; i >= 0; --i)
	  {
	    struct bfd_link_order *order = m->sections[i]->map_head.link_order;

	    while (order != NULL)
	      {
		if (order->type == bfd_indirect_link_order)
		  {
		    asection *is = order->u.indirect.section;
		    bfd_vma flags = elf_section_data(is)->this_hdr.sh_flags;
		    if (flags & SHF_IA_64_NORECOV)
		      {
			p->p_flags |= PF_IA_64_NORECOV;
			goto found;
		      }
		  }
		order = order->next;
	      }
	  }
      found:;
      }

  return TRUE;
}

/* According to the Tahoe assembler spec, all labels starting with a
   '.' are local.  */

static bfd_boolean
elfNN_ia64_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,
				const char *name)
{
  return name[0] == '.';
}

/* Should we do dynamic things to this symbol?  */

static bfd_boolean
elfNN_ia64_dynamic_symbol_p (struct elf_link_hash_entry *h,
			     struct bfd_link_info *info, int r_type)
{
  bfd_boolean ignore_protected
    = ((r_type & 0xf8) == 0x40		/* FPTR relocs */
       || (r_type & 0xf8) == 0x50);	/* LTOFF_FPTR relocs */

  return _bfd_elf_dynamic_symbol_p (h, info, ignore_protected);
}

static struct bfd_hash_entry*
elfNN_ia64_new_elf_hash_entry (struct bfd_hash_entry *entry,
			       struct bfd_hash_table *table,
			       const char *string)
{
  struct elfNN_ia64_link_hash_entry *ret;
  ret = (struct elfNN_ia64_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (!ret)
    ret = bfd_hash_allocate (table, sizeof (*ret));

  if (!ret)
    return 0;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elfNN_ia64_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));

  ret->info = NULL;
  ret->count = 0;
  ret->sorted_count = 0;
  ret->size = 0;
  return (struct bfd_hash_entry *) ret;
}

static void
elfNN_ia64_hash_copy_indirect (struct bfd_link_info *info,
			       struct elf_link_hash_entry *xdir,
			       struct elf_link_hash_entry *xind)
{
  struct elfNN_ia64_link_hash_entry *dir, *ind;

  dir = (struct elfNN_ia64_link_hash_entry *) xdir;
  ind = (struct elfNN_ia64_link_hash_entry *) xind;

  /* Copy down any references that we may have already seen to the
     symbol which just became indirect.  */

  dir->root.ref_dynamic |= ind->root.ref_dynamic;
  dir->root.ref_regular |= ind->root.ref_regular;
  dir->root.ref_regular_nonweak |= ind->root.ref_regular_nonweak;
  dir->root.needs_plt |= ind->root.needs_plt;

  if (ind->root.root.type != bfd_link_hash_indirect)
    return;

  /* Copy over the got and plt data.  This would have been done
     by check_relocs.  */

  if (ind->info != NULL)
    {
      struct elfNN_ia64_dyn_sym_info *dyn_i;
      unsigned int count;

      if (dir->info)
	free (dir->info);

      dir->info = ind->info;
      dir->count = ind->count;
      dir->sorted_count = ind->sorted_count;
      dir->size = ind->size;

      ind->info = NULL;
      ind->count = 0;
      ind->sorted_count = 0;
      ind->size = 0;

      /* Fix up the dyn_sym_info pointers to the global symbol.  */
      for (count = dir->count, dyn_i = dir->info;
	   count != 0;
	   count--, dyn_i++)
	dyn_i->h = &dir->root;
    }

  /* Copy over the dynindx.  */

  if (ind->root.dynindx != -1)
    {
      if (dir->root.dynindx != -1)
	_bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				dir->root.dynstr_index);
      dir->root.dynindx = ind->root.dynindx;
      dir->root.dynstr_index = ind->root.dynstr_index;
      ind->root.dynindx = -1;
      ind->root.dynstr_index = 0;
    }
}

static void
elfNN_ia64_hash_hide_symbol (struct bfd_link_info *info,
			     struct elf_link_hash_entry *xh,
			     bfd_boolean force_local)
{
  struct elfNN_ia64_link_hash_entry *h;
  struct elfNN_ia64_dyn_sym_info *dyn_i;
  unsigned int count;

  h = (struct elfNN_ia64_link_hash_entry *)xh;

  _bfd_elf_link_hash_hide_symbol (info, &h->root, force_local);

  for (count = h->count, dyn_i = h->info;
       count != 0;
       count--, dyn_i++)
    {
      dyn_i->want_plt2 = 0;
      dyn_i->want_plt = 0;
    }
}

/* Compute a hash of a local hash entry.  */

static hashval_t
elfNN_ia64_local_htab_hash (const void *ptr)
{
  struct elfNN_ia64_local_hash_entry *entry
    = (struct elfNN_ia64_local_hash_entry *) ptr;

  return ELF_LOCAL_SYMBOL_HASH (entry->id, entry->r_sym);
}

/* Compare local hash entries.  */

static int
elfNN_ia64_local_htab_eq (const void *ptr1, const void *ptr2)
{
  struct elfNN_ia64_local_hash_entry *entry1
    = (struct elfNN_ia64_local_hash_entry *) ptr1;
  struct elfNN_ia64_local_hash_entry *entry2
    = (struct elfNN_ia64_local_hash_entry *) ptr2;

  return entry1->id == entry2->id && entry1->r_sym == entry2->r_sym;
}

/* Create the derived linker hash table.  The IA-64 ELF port uses this
   derived hash table to keep information specific to the IA-64 ElF
   linker (without using static variables).  */

static struct bfd_link_hash_table *
elfNN_ia64_hash_table_create (bfd *abfd)
{
  struct elfNN_ia64_link_hash_table *ret;

  ret = bfd_zmalloc ((bfd_size_type) sizeof (*ret));
  if (!ret)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      elfNN_ia64_new_elf_hash_entry,
				      sizeof (struct elfNN_ia64_link_hash_entry),
				      IA64_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  ret->loc_hash_table = htab_try_create (1024, elfNN_ia64_local_htab_hash,
					 elfNN_ia64_local_htab_eq, NULL);
  ret->loc_hash_memory = objalloc_create ();
  if (!ret->loc_hash_table || !ret->loc_hash_memory)
    {
      free (ret);
      return NULL;
    }

  return &ret->root.root;
}

/* Free the global elfNN_ia64_dyn_sym_info array.  */

static bfd_boolean
elfNN_ia64_global_dyn_info_free (void **xentry,
				PTR unused ATTRIBUTE_UNUSED)
{
  struct elfNN_ia64_link_hash_entry *entry
    = (struct elfNN_ia64_link_hash_entry *) xentry;

  if (entry->root.root.type == bfd_link_hash_warning)
    entry = (struct elfNN_ia64_link_hash_entry *) entry->root.root.u.i.link;

  if (entry->info)
    {
      free (entry->info);
      entry->info = NULL;
      entry->count = 0;
      entry->sorted_count = 0;
      entry->size = 0;
    }

  return TRUE;
}

/* Free the local elfNN_ia64_dyn_sym_info array.  */

static bfd_boolean
elfNN_ia64_local_dyn_info_free (void **slot,
				PTR unused ATTRIBUTE_UNUSED)
{
  struct elfNN_ia64_local_hash_entry *entry
    = (struct elfNN_ia64_local_hash_entry *) *slot;

  if (entry->info)
    {
      free (entry->info);
      entry->info = NULL;
      entry->count = 0;
      entry->sorted_count = 0;
      entry->size = 0;
    }

  return TRUE;
}

/* Destroy IA-64 linker hash table.  */

static void
elfNN_ia64_hash_table_free (struct bfd_link_hash_table *hash)
{
  struct elfNN_ia64_link_hash_table *ia64_info
    = (struct elfNN_ia64_link_hash_table *) hash;
  if (ia64_info->loc_hash_table)
    {
      htab_traverse (ia64_info->loc_hash_table,
		     elfNN_ia64_local_dyn_info_free, NULL);
      htab_delete (ia64_info->loc_hash_table);
    }
  if (ia64_info->loc_hash_memory)
    objalloc_free ((struct objalloc *) ia64_info->loc_hash_memory);
  elf_link_hash_traverse (&ia64_info->root,
			  elfNN_ia64_global_dyn_info_free, NULL);
  _bfd_generic_link_hash_table_free (hash);
}

/* Traverse both local and global hash tables.  */

struct elfNN_ia64_dyn_sym_traverse_data
{
  bfd_boolean (*func) (struct elfNN_ia64_dyn_sym_info *, PTR);
  PTR data;
};

static bfd_boolean
elfNN_ia64_global_dyn_sym_thunk (struct bfd_hash_entry *xentry,
				 PTR xdata)
{
  struct elfNN_ia64_link_hash_entry *entry
    = (struct elfNN_ia64_link_hash_entry *) xentry;
  struct elfNN_ia64_dyn_sym_traverse_data *data
    = (struct elfNN_ia64_dyn_sym_traverse_data *) xdata;
  struct elfNN_ia64_dyn_sym_info *dyn_i;
  unsigned int count;

  if (entry->root.root.type == bfd_link_hash_warning)
    entry = (struct elfNN_ia64_link_hash_entry *) entry->root.root.u.i.link;

  for (count = entry->count, dyn_i = entry->info;
       count != 0;
       count--, dyn_i++)
    if (! (*data->func) (dyn_i, data->data))
      return FALSE;
  return TRUE;
}

static bfd_boolean
elfNN_ia64_local_dyn_sym_thunk (void **slot, PTR xdata)
{
  struct elfNN_ia64_local_hash_entry *entry
    = (struct elfNN_ia64_local_hash_entry *) *slot;
  struct elfNN_ia64_dyn_sym_traverse_data *data
    = (struct elfNN_ia64_dyn_sym_traverse_data *) xdata;
  struct elfNN_ia64_dyn_sym_info *dyn_i;
  unsigned int count;

  for (count = entry->count, dyn_i = entry->info;
       count != 0;
       count--, dyn_i++)
    if (! (*data->func) (dyn_i, data->data))
      return FALSE;
  return TRUE;
}

static void
elfNN_ia64_dyn_sym_traverse (struct elfNN_ia64_link_hash_table *ia64_info,
			     bfd_boolean (*func) (struct elfNN_ia64_dyn_sym_info *, PTR),
			     PTR data)
{
  struct elfNN_ia64_dyn_sym_traverse_data xdata;

  xdata.func = func;
  xdata.data = data;

  elf_link_hash_traverse (&ia64_info->root,
			  elfNN_ia64_global_dyn_sym_thunk, &xdata);
  htab_traverse (ia64_info->loc_hash_table,
		 elfNN_ia64_local_dyn_sym_thunk, &xdata);
}

static bfd_boolean
elfNN_ia64_create_dynamic_sections (bfd *abfd,
				    struct bfd_link_info *info)
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  asection *s;

  if (! _bfd_elf_create_dynamic_sections (abfd, info))
    return FALSE;

  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return FALSE;

  {
    flagword flags = bfd_get_section_flags (abfd, ia64_info->root.sgot);
    bfd_set_section_flags (abfd, ia64_info->root.sgot,
			   SEC_SMALL_DATA | flags);
    /* The .got section is always aligned at 8 bytes.  */
    bfd_set_section_alignment (abfd, ia64_info->root.sgot, 3);
  }

  if (!get_pltoff (abfd, info, ia64_info))
    return FALSE;

  s = bfd_make_section_with_flags (abfd, ".rela.IA_64.pltoff",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
				    | SEC_READONLY));
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, LOG_SECTION_ALIGN))
    return FALSE;
  ia64_info->rel_pltoff_sec = s;

  return TRUE;
}

/* Find and/or create a hash entry for local symbol.  */
static struct elfNN_ia64_local_hash_entry *
get_local_sym_hash (struct elfNN_ia64_link_hash_table *ia64_info,
		    bfd *abfd, const Elf_Internal_Rela *rel,
		    bfd_boolean create)
{
  struct elfNN_ia64_local_hash_entry e, *ret;
  asection *sec = abfd->sections;
  hashval_t h = ELF_LOCAL_SYMBOL_HASH (sec->id,
				       ELFNN_R_SYM (rel->r_info));
  void **slot;

  e.id = sec->id;
  e.r_sym = ELFNN_R_SYM (rel->r_info);
  slot = htab_find_slot_with_hash (ia64_info->loc_hash_table, &e, h,
				   create ? INSERT : NO_INSERT);

  if (!slot)
    return NULL;

  if (*slot)
    return (struct elfNN_ia64_local_hash_entry *) *slot;

  ret = (struct elfNN_ia64_local_hash_entry *)
	objalloc_alloc ((struct objalloc *) ia64_info->loc_hash_memory,
			sizeof (struct elfNN_ia64_local_hash_entry));
  if (ret)
    {
      memset (ret, 0, sizeof (*ret));
      ret->id = sec->id;
      ret->r_sym = ELFNN_R_SYM (rel->r_info);
      *slot = ret;
    }
  return ret;
}

/* Used to sort elfNN_ia64_dyn_sym_info array.  */

static int
addend_compare (const void *xp, const void *yp)
{
  const struct elfNN_ia64_dyn_sym_info *x
    = (const struct elfNN_ia64_dyn_sym_info *) xp;
  const struct elfNN_ia64_dyn_sym_info *y
    = (const struct elfNN_ia64_dyn_sym_info *) yp;

  return x->addend < y->addend ? -1 : x->addend > y->addend ? 1 : 0;
}

/* Sort elfNN_ia64_dyn_sym_info array and remove duplicates.  */

static unsigned int
sort_dyn_sym_info (struct elfNN_ia64_dyn_sym_info *info,
		   unsigned int count)
{
  bfd_vma curr, prev, got_offset;
  unsigned int i, kept, dupes, diff, dest, src, len;

  qsort (info, count, sizeof (*info), addend_compare);

  /* Find the first duplicate.  */
  prev = info [0].addend;
  got_offset = info [0].got_offset;
  for (i = 1; i < count; i++)
    {
      curr = info [i].addend;
      if (curr == prev)
	{
	  /* For duplicates, make sure that GOT_OFFSET is valid.  */
	  if (got_offset == (bfd_vma) -1)
	    got_offset = info [i].got_offset;
	  break;
	}
      got_offset = info [i].got_offset;
      prev = curr;
    }

  /* We may move a block of elements to here.  */
  dest = i++;

  /* Remove duplicates.  */
  if (i < count)
    {
      while (i < count)
	{
	  /* For duplicates, make sure that the kept one has a valid
	     got_offset.  */
	  kept = dest - 1;
	  if (got_offset != (bfd_vma) -1)
	    info [kept].got_offset = got_offset;

	  curr = info [i].addend;
	  got_offset = info [i].got_offset;

	  /* Move a block of elements whose first one is different from
	     the previous.  */
	  if (curr == prev)
	    {
	      for (src = i + 1; src < count; src++)
		{
		  if (info [src].addend != curr)
		    break;
		  /* For duplicates, make sure that GOT_OFFSET is
		     valid.  */
		  if (got_offset == (bfd_vma) -1)
		    got_offset = info [src].got_offset;
		}

	      /* Make sure that the kept one has a valid got_offset.  */
	      if (got_offset != (bfd_vma) -1)
		info [kept].got_offset = got_offset;
	    }
	  else
	    src = i;

	  if (src >= count)
	    break;

	  /* Find the next duplicate.  SRC will be kept.  */
	  prev = info [src].addend;
	  got_offset = info [src].got_offset;
	  for (dupes = src + 1; dupes < count; dupes ++)
	    {
	      curr = info [dupes].addend;
	      if (curr == prev)
		{
		  /* Make sure that got_offset is valid.  */
		  if (got_offset == (bfd_vma) -1)
		    got_offset = info [dupes].got_offset;

		  /* For duplicates, make sure that the kept one has
		     a valid got_offset.  */
		  if (got_offset != (bfd_vma) -1)
		    info [dupes - 1].got_offset = got_offset;
		  break;
		}
	      got_offset = info [dupes].got_offset;
	      prev = curr;
	    }

	  /* How much to move.  */
	  len = dupes - src;
	  i = dupes + 1;

	  if (len == 1 && dupes < count)
	    {
	      /* If we only move 1 element, we combine it with the next
		 one.  There must be at least a duplicate.  Find the
		 next different one.  */
	      for (diff = dupes + 1, src++; diff < count; diff++, src++)
		{
		  if (info [diff].addend != curr)
		    break;
		  /* Make sure that got_offset is valid.  */
		  if (got_offset == (bfd_vma) -1)
		    got_offset = info [diff].got_offset;
		}

	      /* Makre sure that the last duplicated one has an valid
		 offset.  */
	      BFD_ASSERT (curr == prev);
	      if (got_offset != (bfd_vma) -1)
		info [diff - 1].got_offset = got_offset;

	      if (diff < count)
		{
		  /* Find the next duplicate.  Track the current valid
		     offset.  */
		  prev = info [diff].addend;
		  got_offset = info [diff].got_offset;
		  for (dupes = diff + 1; dupes < count; dupes ++)
		    {
		      curr = info [dupes].addend;
		      if (curr == prev)
			{
			  /* For duplicates, make sure that GOT_OFFSET
			     is valid.  */
			  if (got_offset == (bfd_vma) -1)
			    got_offset = info [dupes].got_offset;
			  break;
			}
		      got_offset = info [dupes].got_offset;
		      prev = curr;
		      diff++;
		    }

		  len = diff - src + 1;
		  i = diff + 1;
		}
	    }

	  memmove (&info [dest], &info [src], len * sizeof (*info));

	  dest += len;
	}

      count = dest;
    }
  else
    {
      /* When we get here, either there is no duplicate at all or
	 the only duplicate is the last element.  */
      if (dest < count)
	{
	  /* If the last element is a duplicate, make sure that the
	     kept one has a valid got_offset.  We also update count.  */
	  if (got_offset != (bfd_vma) -1)
	    info [dest - 1].got_offset = got_offset;
	  count = dest;
	}
    }

  return count;
}

/* Find and/or create a descriptor for dynamic symbol info.  This will
   vary based on global or local symbol, and the addend to the reloc.

   We don't sort when inserting.  Also, we sort and eliminate
   duplicates if there is an unsorted section.  Typically, this will
   only happen once, because we do all insertions before lookups.  We
   then use bsearch to do a lookup.  This also allows lookups to be
   fast.  So we have fast insertion (O(log N) due to duplicate check),
   fast lookup (O(log N)) and one sort (O(N log N) expected time).
   Previously, all lookups were O(N) because of the use of the linked
   list and also all insertions were O(N) because of the check for
   duplicates.  There are some complications here because the array
   size grows occasionally, which may add an O(N) factor, but this
   should be rare.  Also,  we free the excess array allocation, which
   requires a copy which is O(N), but this only happens once.  */

static struct elfNN_ia64_dyn_sym_info *
get_dyn_sym_info (struct elfNN_ia64_link_hash_table *ia64_info,
		  struct elf_link_hash_entry *h, bfd *abfd,
		  const Elf_Internal_Rela *rel, bfd_boolean create)
{
  struct elfNN_ia64_dyn_sym_info **info_p, *info, *dyn_i, key;
  unsigned int *count_p, *sorted_count_p, *size_p;
  unsigned int count, sorted_count, size;
  bfd_vma addend = rel ? rel->r_addend : 0;
  bfd_size_type amt;

  if (h)
    {
      struct elfNN_ia64_link_hash_entry *global_h;

      global_h = (struct elfNN_ia64_link_hash_entry *) h;
      info_p = &global_h->info;
      count_p = &global_h->count;
      sorted_count_p = &global_h->sorted_count;
      size_p = &global_h->size;
    }
  else
    {
      struct elfNN_ia64_local_hash_entry *loc_h;

      loc_h = get_local_sym_hash (ia64_info, abfd, rel, create);
      if (!loc_h)
	{
	  BFD_ASSERT (!create);
	  return NULL;
	}

      info_p = &loc_h->info;
      count_p = &loc_h->count;
      sorted_count_p = &loc_h->sorted_count;
      size_p = &loc_h->size;
    }

  count = *count_p;
  sorted_count = *sorted_count_p;
  size = *size_p;
  info = *info_p;
  if (create)
    {
      /* When we create the array, we don't check for duplicates,
         except in the previously sorted section if one exists, and
	 against the last inserted entry.  This allows insertions to
	 be fast.  */
      if (info)
	{
	  if (sorted_count)
	    {
	      /* Try bsearch first on the sorted section.  */
	      key.addend = addend;
	      dyn_i = bsearch (&key, info, sorted_count,
			       sizeof (*info), addend_compare);

	      if (dyn_i)
		{
		  return dyn_i;
		}
	    }

	  /* Do a quick check for the last inserted entry.  */
	  dyn_i = info + count - 1;
	  if (dyn_i->addend == addend)
	    {
	      return dyn_i;
	    }
	}

      if (size == 0)
	{
	  /* It is the very first element. We create the array of size
	     1.  */
	  size = 1;
	  amt = size * sizeof (*info);
	  info = bfd_malloc (amt);
	}
      else if (size <= count)
	{
	  /* We double the array size every time when we reach the
	     size limit.  */
	  size += size;
	  amt = size * sizeof (*info);
	  info = bfd_realloc (info, amt);
	}
      else
	goto has_space;

      if (info == NULL)
	return NULL;
      *size_p = size;
      *info_p = info;

has_space:
      /* Append the new one to the array.  */
      dyn_i = info + count;
      memset (dyn_i, 0, sizeof (*dyn_i));
      dyn_i->got_offset = (bfd_vma) -1;
      dyn_i->addend = addend;

      /* We increment count only since the new ones are unsorted and
	 may have duplicate.  */
      (*count_p)++;
    }
  else
    {
      /* It is a lookup without insertion.  Sort array if part of the
	 array isn't sorted.  */
      if (count != sorted_count)
	{
	  count = sort_dyn_sym_info (info, count);
	  *count_p = count;
	  *sorted_count_p = count;
	}

      /* Free unused memory.  */
      if (size != count)
	{
	  amt = count * sizeof (*info);
	  info = bfd_malloc (amt);
	  if (info != NULL)
	    {
	      memcpy (info, *info_p, amt);
	      free (*info_p);
	      *size_p = count;
	      *info_p = info;
	    }
	}

      key.addend = addend;
      dyn_i = bsearch (&key, info, count,
		       sizeof (*info), addend_compare);
    }

  return dyn_i;
}

static asection *
get_got (bfd *abfd, struct bfd_link_info *info,
	 struct elfNN_ia64_link_hash_table *ia64_info)
{
  asection *got;
  bfd *dynobj;

  got = ia64_info->root.sgot;
  if (!got)
    {
      flagword flags;

      dynobj = ia64_info->root.dynobj;
      if (!dynobj)
	ia64_info->root.dynobj = dynobj = abfd;
      if (!_bfd_elf_create_got_section (dynobj, info))
	return 0;

      got = ia64_info->root.sgot;

      /* The .got section is always aligned at 8 bytes.  */
      if (!bfd_set_section_alignment (abfd, got, 3))
	return 0;

      flags = bfd_get_section_flags (abfd, got);
      bfd_set_section_flags (abfd, got, SEC_SMALL_DATA | flags);
    }

  return got;
}

/* Create function descriptor section (.opd).  This section is called .opd
   because it contains "official procedure descriptors".  The "official"
   refers to the fact that these descriptors are used when taking the address
   of a procedure, thus ensuring a unique address for each procedure.  */

static asection *
get_fptr (bfd *abfd, struct bfd_link_info *info,
	  struct elfNN_ia64_link_hash_table *ia64_info)
{
  asection *fptr;
  bfd *dynobj;

  fptr = ia64_info->fptr_sec;
  if (!fptr)
    {
      dynobj = ia64_info->root.dynobj;
      if (!dynobj)
	ia64_info->root.dynobj = dynobj = abfd;

      fptr = bfd_make_section_with_flags (dynobj, ".opd",
					  (SEC_ALLOC
					   | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | (info->pie ? 0 : SEC_READONLY)
					   | SEC_LINKER_CREATED));
      if (!fptr
	  || !bfd_set_section_alignment (abfd, fptr, 4))
	{
	  BFD_ASSERT (0);
	  return NULL;
	}

      ia64_info->fptr_sec = fptr;

      if (info->pie)
	{
	  asection *fptr_rel;
	  fptr_rel = bfd_make_section_with_flags (dynobj, ".rela.opd",
						  (SEC_ALLOC | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY));
	  if (fptr_rel == NULL
	      || !bfd_set_section_alignment (abfd, fptr_rel,
					     LOG_SECTION_ALIGN))
	    {
	      BFD_ASSERT (0);
	      return NULL;
	    }

	  ia64_info->rel_fptr_sec = fptr_rel;
	}
    }

  return fptr;
}

static asection *
get_pltoff (bfd *abfd, struct bfd_link_info *info ATTRIBUTE_UNUSED,
	    struct elfNN_ia64_link_hash_table *ia64_info)
{
  asection *pltoff;
  bfd *dynobj;

  pltoff = ia64_info->pltoff_sec;
  if (!pltoff)
    {
      dynobj = ia64_info->root.dynobj;
      if (!dynobj)
	ia64_info->root.dynobj = dynobj = abfd;

      pltoff = bfd_make_section_with_flags (dynobj,
					    ELF_STRING_ia64_pltoff,
					    (SEC_ALLOC
					     | SEC_LOAD
					     | SEC_HAS_CONTENTS
					     | SEC_IN_MEMORY
					     | SEC_SMALL_DATA
					     | SEC_LINKER_CREATED));
      if (!pltoff
	  || !bfd_set_section_alignment (abfd, pltoff, 4))
	{
	  BFD_ASSERT (0);
	  return NULL;
	}

      ia64_info->pltoff_sec = pltoff;
    }

  return pltoff;
}

static asection *
get_reloc_section (bfd *abfd,
		   struct elfNN_ia64_link_hash_table *ia64_info,
		   asection *sec, bfd_boolean create)
{
  const char *srel_name;
  asection *srel;
  bfd *dynobj;

  srel_name = (bfd_elf_string_from_elf_section
	       (abfd, elf_elfheader(abfd)->e_shstrndx,
		_bfd_elf_single_rel_hdr (sec)->sh_name));
  if (srel_name == NULL)
    return NULL;

  dynobj = ia64_info->root.dynobj;
  if (!dynobj)
    ia64_info->root.dynobj = dynobj = abfd;

  srel = bfd_get_section_by_name (dynobj, srel_name);
  if (srel == NULL && create)
    {
      srel = bfd_make_section_with_flags (dynobj, srel_name,
					  (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED
					   | SEC_READONLY));
      if (srel == NULL
	  || !bfd_set_section_alignment (dynobj, srel,
					 LOG_SECTION_ALIGN))
	return NULL;
    }

  return srel;
}

static bfd_boolean
count_dyn_reloc (bfd *abfd, struct elfNN_ia64_dyn_sym_info *dyn_i,
		 asection *srel, int type, bfd_boolean reltext)
{
  struct elfNN_ia64_dyn_reloc_entry *rent;

  for (rent = dyn_i->reloc_entries; rent; rent = rent->next)
    if (rent->srel == srel && rent->type == type)
      break;

  if (!rent)
    {
      rent = ((struct elfNN_ia64_dyn_reloc_entry *)
	      bfd_alloc (abfd, (bfd_size_type) sizeof (*rent)));
      if (!rent)
	return FALSE;

      rent->next = dyn_i->reloc_entries;
      rent->srel = srel;
      rent->type = type;
      rent->count = 0;
      dyn_i->reloc_entries = rent;
    }
  rent->reltext = reltext;
  rent->count++;

  return TRUE;
}

static bfd_boolean
elfNN_ia64_check_relocs (bfd *abfd, struct bfd_link_info *info,
			 asection *sec,
			 const Elf_Internal_Rela *relocs)
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  const Elf_Internal_Rela *relend;
  Elf_Internal_Shdr *symtab_hdr;
  const Elf_Internal_Rela *rel;
  asection *got, *fptr, *srel, *pltoff;
  enum {
    NEED_GOT = 1,
    NEED_GOTX = 2,
    NEED_FPTR = 4,
    NEED_PLTOFF = 8,
    NEED_MIN_PLT = 16,
    NEED_FULL_PLT = 32,
    NEED_DYNREL = 64,
    NEED_LTOFF_FPTR = 128,
    NEED_TPREL = 256,
    NEED_DTPMOD = 512,
    NEED_DTPREL = 1024
  };
  int need_entry;
  struct elf_link_hash_entry *h;
  unsigned long r_symndx;
  bfd_boolean maybe_dynamic;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return FALSE;

  got = fptr = srel = pltoff = NULL;

  relend = relocs + sec->reloc_count;

  /* We scan relocations first to create dynamic relocation arrays.  We
     modified get_dyn_sym_info to allow fast insertion and support fast
     lookup in the next loop.  */
  for (rel = relocs; rel < relend; ++rel)
    {
      r_symndx = ELFNN_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  long indx = r_symndx - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	}
      else
	h = NULL;

      /* We can only get preliminary data on whether a symbol is
	 locally or externally defined, as not all of the input files
	 have yet been processed.  Do something with what we know, as
	 this may help reduce memory usage and processing time later.  */
      maybe_dynamic = (h && ((!info->executable
			      && (!SYMBOLIC_BIND (info, h)
				  || info->unresolved_syms_in_shared_libs == RM_IGNORE))
			     || !h->def_regular
			     || h->root.type == bfd_link_hash_defweak));

      need_entry = 0;
      switch (ELFNN_R_TYPE (rel->r_info))
	{
	case R_IA64_TPREL64MSB:
	case R_IA64_TPREL64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;

	case R_IA64_LTOFF_TPREL22:
	  need_entry = NEED_TPREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;

	case R_IA64_DTPREL32MSB:
	case R_IA64_DTPREL32LSB:
	case R_IA64_DTPREL64MSB:
	case R_IA64_DTPREL64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;

	case R_IA64_LTOFF_DTPREL22:
	  need_entry = NEED_DTPREL;
	  break;

	case R_IA64_DTPMOD64MSB:
	case R_IA64_DTPMOD64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;

	case R_IA64_LTOFF_DTPMOD22:
	  need_entry = NEED_DTPMOD;
	  break;

	case R_IA64_LTOFF_FPTR22:
	case R_IA64_LTOFF_FPTR64I:
	case R_IA64_LTOFF_FPTR32MSB:
	case R_IA64_LTOFF_FPTR32LSB:
	case R_IA64_LTOFF_FPTR64MSB:
	case R_IA64_LTOFF_FPTR64LSB:
	  need_entry = NEED_FPTR | NEED_GOT | NEED_LTOFF_FPTR;
	  break;

	case R_IA64_FPTR64I:
	case R_IA64_FPTR32MSB:
	case R_IA64_FPTR32LSB:
	case R_IA64_FPTR64MSB:
	case R_IA64_FPTR64LSB:
	  if (info->shared || h)
	    need_entry = NEED_FPTR | NEED_DYNREL;
	  else
	    need_entry = NEED_FPTR;
	  break;

	case R_IA64_LTOFF22:
	case R_IA64_LTOFF64I:
	  need_entry = NEED_GOT;
	  break;

	case R_IA64_LTOFF22X:
	  need_entry = NEED_GOTX;
	  break;

	case R_IA64_PLTOFF22:
	case R_IA64_PLTOFF64I:
	case R_IA64_PLTOFF64MSB:
	case R_IA64_PLTOFF64LSB:
	  need_entry = NEED_PLTOFF;
	  if (h)
	    {
	      if (maybe_dynamic)
		need_entry |= NEED_MIN_PLT;
	    }
	  else
	    {
	      (*info->callbacks->warning)
		(info, _("@@pltoff reloc against local symbol"), 0,
		 abfd, 0, (bfd_vma) 0);
	    }
	  break;

	case R_IA64_PCREL21B:
        case R_IA64_PCREL60B:
	  /* Depending on where this symbol is defined, we may or may not
	     need a full plt entry.  Only skip if we know we'll not need
	     the entry -- static or symbolic, and the symbol definition
	     has already been seen.  */
	  if (maybe_dynamic && rel->r_addend == 0)
	    need_entry = NEED_FULL_PLT;
	  break;

	case R_IA64_IMM14:
	case R_IA64_IMM22:
	case R_IA64_IMM64:
	case R_IA64_DIR32MSB:
	case R_IA64_DIR32LSB:
	case R_IA64_DIR64MSB:
	case R_IA64_DIR64LSB:
	  /* Shared objects will always need at least a REL relocation.  */
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;

	case R_IA64_IPLTMSB:
	case R_IA64_IPLTLSB:
	  /* Shared objects will always need at least a REL relocation.  */
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;

	case R_IA64_PCREL22:
	case R_IA64_PCREL64I:
	case R_IA64_PCREL32MSB:
	case R_IA64_PCREL32LSB:
	case R_IA64_PCREL64MSB:
	case R_IA64_PCREL64LSB:
	  if (maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;
	}

      if (!need_entry)
	continue;

      if ((need_entry & NEED_FPTR) != 0
	  && rel->r_addend)
	{
	  (*info->callbacks->warning)
	    (info, _("non-zero addend in @@fptr reloc"), 0,
	     abfd, 0, (bfd_vma) 0);
	}

      if (get_dyn_sym_info (ia64_info, h, abfd, rel, TRUE) == NULL)
	return FALSE;
    }

  /* Now, we only do lookup without insertion, which is very fast
     with the modified get_dyn_sym_info.  */
  for (rel = relocs; rel < relend; ++rel)
    {
      struct elfNN_ia64_dyn_sym_info *dyn_i;
      int dynrel_type = R_IA64_NONE;

      r_symndx = ELFNN_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  /* We're dealing with a global symbol -- find its hash entry
	     and mark it as being referenced.  */
	  long indx = r_symndx - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  h->ref_regular = 1;
	}
      else
	h = NULL;

      /* We can only get preliminary data on whether a symbol is
	 locally or externally defined, as not all of the input files
	 have yet been processed.  Do something with what we know, as
	 this may help reduce memory usage and processing time later.  */
      maybe_dynamic = (h && ((!info->executable
			      && (!SYMBOLIC_BIND (info, h)
				  || info->unresolved_syms_in_shared_libs == RM_IGNORE))
			     || !h->def_regular
			     || h->root.type == bfd_link_hash_defweak));

      need_entry = 0;
      switch (ELFNN_R_TYPE (rel->r_info))
	{
	case R_IA64_TPREL64MSB:
	case R_IA64_TPREL64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  dynrel_type = R_IA64_TPREL64LSB;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;

	case R_IA64_LTOFF_TPREL22:
	  need_entry = NEED_TPREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;

	case R_IA64_DTPREL32MSB:
	case R_IA64_DTPREL32LSB:
	case R_IA64_DTPREL64MSB:
	case R_IA64_DTPREL64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  dynrel_type = R_IA64_DTPRELNNLSB;
	  break;

	case R_IA64_LTOFF_DTPREL22:
	  need_entry = NEED_DTPREL;
	  break;

	case R_IA64_DTPMOD64MSB:
	case R_IA64_DTPMOD64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  dynrel_type = R_IA64_DTPMOD64LSB;
	  break;

	case R_IA64_LTOFF_DTPMOD22:
	  need_entry = NEED_DTPMOD;
	  break;

	case R_IA64_LTOFF_FPTR22:
	case R_IA64_LTOFF_FPTR64I:
	case R_IA64_LTOFF_FPTR32MSB:
	case R_IA64_LTOFF_FPTR32LSB:
	case R_IA64_LTOFF_FPTR64MSB:
	case R_IA64_LTOFF_FPTR64LSB:
	  need_entry = NEED_FPTR | NEED_GOT | NEED_LTOFF_FPTR;
	  break;

	case R_IA64_FPTR64I:
	case R_IA64_FPTR32MSB:
	case R_IA64_FPTR32LSB:
	case R_IA64_FPTR64MSB:
	case R_IA64_FPTR64LSB:
	  if (info->shared || h)
	    need_entry = NEED_FPTR | NEED_DYNREL;
	  else
	    need_entry = NEED_FPTR;
	  dynrel_type = R_IA64_FPTRNNLSB;
	  break;

	case R_IA64_LTOFF22:
	case R_IA64_LTOFF64I:
	  need_entry = NEED_GOT;
	  break;

	case R_IA64_LTOFF22X:
	  need_entry = NEED_GOTX;
	  break;

	case R_IA64_PLTOFF22:
	case R_IA64_PLTOFF64I:
	case R_IA64_PLTOFF64MSB:
	case R_IA64_PLTOFF64LSB:
	  need_entry = NEED_PLTOFF;
	  if (h)
	    {
	      if (maybe_dynamic)
		need_entry |= NEED_MIN_PLT;
	    }
	  break;

	case R_IA64_PCREL21B:
        case R_IA64_PCREL60B:
	  /* Depending on where this symbol is defined, we may or may not
	     need a full plt entry.  Only skip if we know we'll not need
	     the entry -- static or symbolic, and the symbol definition
	     has already been seen.  */
	  if (maybe_dynamic && rel->r_addend == 0)
	    need_entry = NEED_FULL_PLT;
	  break;

	case R_IA64_IMM14:
	case R_IA64_IMM22:
	case R_IA64_IMM64:
	case R_IA64_DIR32MSB:
	case R_IA64_DIR32LSB:
	case R_IA64_DIR64MSB:
	case R_IA64_DIR64LSB:
	  /* Shared objects will always need at least a REL relocation.  */
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  dynrel_type = R_IA64_DIRNNLSB;
	  break;

	case R_IA64_IPLTMSB:
	case R_IA64_IPLTLSB:
	  /* Shared objects will always need at least a REL relocation.  */
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  dynrel_type = R_IA64_IPLTLSB;
	  break;

	case R_IA64_PCREL22:
	case R_IA64_PCREL64I:
	case R_IA64_PCREL32MSB:
	case R_IA64_PCREL32LSB:
	case R_IA64_PCREL64MSB:
	case R_IA64_PCREL64LSB:
	  if (maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  dynrel_type = R_IA64_PCRELNNLSB;
	  break;
	}

      if (!need_entry)
	continue;

      dyn_i = get_dyn_sym_info (ia64_info, h, abfd, rel, FALSE);

      /* Record whether or not this is a local symbol.  */
      dyn_i->h = h;

      /* Create what's needed.  */
      if (need_entry & (NEED_GOT | NEED_GOTX | NEED_TPREL
			| NEED_DTPMOD | NEED_DTPREL))
	{
	  if (!got)
	    {
	      got = get_got (abfd, info, ia64_info);
	      if (!got)
		return FALSE;
	    }
	  if (need_entry & NEED_GOT)
	    dyn_i->want_got = 1;
	  if (need_entry & NEED_GOTX)
	    dyn_i->want_gotx = 1;
	  if (need_entry & NEED_TPREL)
	    dyn_i->want_tprel = 1;
	  if (need_entry & NEED_DTPMOD)
	    dyn_i->want_dtpmod = 1;
	  if (need_entry & NEED_DTPREL)
	    dyn_i->want_dtprel = 1;
	}
      if (need_entry & NEED_FPTR)
	{
	  if (!fptr)
	    {
	      fptr = get_fptr (abfd, info, ia64_info);
	      if (!fptr)
		return FALSE;
	    }

	  /* FPTRs for shared libraries are allocated by the dynamic
	     linker.  Make sure this local symbol will appear in the
	     dynamic symbol table.  */
	  if (!h && info->shared)
	    {
	      if (! (bfd_elf_link_record_local_dynamic_symbol
		     (info, abfd, (long) r_symndx)))
		return FALSE;
	    }

	  dyn_i->want_fptr = 1;
	}
      if (need_entry & NEED_LTOFF_FPTR)
	dyn_i->want_ltoff_fptr = 1;
      if (need_entry & (NEED_MIN_PLT | NEED_FULL_PLT))
	{
          if (!ia64_info->root.dynobj)
	    ia64_info->root.dynobj = abfd;
	  h->needs_plt = 1;
	  dyn_i->want_plt = 1;
	}
      if (need_entry & NEED_FULL_PLT)
	dyn_i->want_plt2 = 1;
      if (need_entry & NEED_PLTOFF)
	{
	  /* This is needed here, in case @@pltoff is used in a non-shared
	     link.  */
	  if (!pltoff)
	    {
	      pltoff = get_pltoff (abfd, info, ia64_info);
	      if (!pltoff)
		return FALSE;
	    }

	  dyn_i->want_pltoff = 1;
	}
      if ((need_entry & NEED_DYNREL) && (sec->flags & SEC_ALLOC))
	{
	  if (!srel)
	    {
	      srel = get_reloc_section (abfd, ia64_info, sec, TRUE);
	      if (!srel)
		return FALSE;
	    }
	  if (!count_dyn_reloc (abfd, dyn_i, srel, dynrel_type,
				(sec->flags & SEC_READONLY) != 0))
	    return FALSE;
	}
    }

  return TRUE;
}

/* For cleanliness, and potentially faster dynamic loading, allocate
   external GOT entries first.  */

static bfd_boolean
allocate_global_data_got (struct elfNN_ia64_dyn_sym_info *dyn_i,
			  void * data)
{
  struct elfNN_ia64_allocate_data *x = (struct elfNN_ia64_allocate_data *)data;

  if ((dyn_i->want_got || dyn_i->want_gotx)
      && ! dyn_i->want_fptr
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0))
     {
       dyn_i->got_offset = x->ofs;
       x->ofs += 8;
     }
  if (dyn_i->want_tprel)
    {
      dyn_i->tprel_offset = x->ofs;
      x->ofs += 8;
    }
  if (dyn_i->want_dtpmod)
    {
      if (elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0))
	{
	  dyn_i->dtpmod_offset = x->ofs;
	  x->ofs += 8;
	}
      else
	{
	  struct elfNN_ia64_link_hash_table *ia64_info;

	  ia64_info = elfNN_ia64_hash_table (x->info);
	  if (ia64_info == NULL)
	    return FALSE;

	  if (ia64_info->self_dtpmod_offset == (bfd_vma) -1)
	    {
	      ia64_info->self_dtpmod_offset = x->ofs;
	      x->ofs += 8;
	    }
	  dyn_i->dtpmod_offset = ia64_info->self_dtpmod_offset;
	}
    }
  if (dyn_i->want_dtprel)
    {
      dyn_i->dtprel_offset = x->ofs;
      x->ofs += 8;
    }
  return TRUE;
}

/* Next, allocate all the GOT entries used by LTOFF_FPTR relocs.  */

static bfd_boolean
allocate_global_fptr_got (struct elfNN_ia64_dyn_sym_info *dyn_i,
			  void * data)
{
  struct elfNN_ia64_allocate_data *x = (struct elfNN_ia64_allocate_data *)data;

  if (dyn_i->want_got
      && dyn_i->want_fptr
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, R_IA64_FPTRNNLSB))
    {
      dyn_i->got_offset = x->ofs;
      x->ofs += 8;
    }
  return TRUE;
}

/* Lastly, allocate all the GOT entries for local data.  */

static bfd_boolean
allocate_local_got (struct elfNN_ia64_dyn_sym_info *dyn_i,
		    PTR data)
{
  struct elfNN_ia64_allocate_data *x = (struct elfNN_ia64_allocate_data *)data;

  if ((dyn_i->want_got || dyn_i->want_gotx)
      && !elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0))
    {
      dyn_i->got_offset = x->ofs;
      x->ofs += 8;
    }
  return TRUE;
}

/* Search for the index of a global symbol in it's defining object file.  */

static long
global_sym_index (struct elf_link_hash_entry *h)
{
  struct elf_link_hash_entry **p;
  bfd *obj;

  BFD_ASSERT (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak);

  obj = h->root.u.def.section->owner;
  for (p = elf_sym_hashes (obj); *p != h; ++p)
    continue;

  return p - elf_sym_hashes (obj) + elf_tdata (obj)->symtab_hdr.sh_info;
}

/* Allocate function descriptors.  We can do these for every function
   in a main executable that is not exported.  */

static bfd_boolean
allocate_fptr (struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data)
{
  struct elfNN_ia64_allocate_data *x = (struct elfNN_ia64_allocate_data *)data;

  if (dyn_i->want_fptr)
    {
      struct elf_link_hash_entry *h = dyn_i->h;

      if (h)
	while (h->root.type == bfd_link_hash_indirect
	       || h->root.type == bfd_link_hash_warning)
	  h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if (!x->info->executable
	  && (!h
	      || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	      || (h->root.type != bfd_link_hash_undefweak
		  && h->root.type != bfd_link_hash_undefined)))
	{
	  if (h && h->dynindx == -1)
	    {
	      BFD_ASSERT ((h->root.type == bfd_link_hash_defined)
			  || (h->root.type == bfd_link_hash_defweak));

	      if (!bfd_elf_link_record_local_dynamic_symbol
		    (x->info, h->root.u.def.section->owner,
		     global_sym_index (h)))
		return FALSE;
	    }

	  dyn_i->want_fptr = 0;
	}
      else if (h == NULL || h->dynindx == -1)
	{
	  dyn_i->fptr_offset = x->ofs;
	  x->ofs += 16;
	}
      else
	dyn_i->want_fptr = 0;
    }
  return TRUE;
}

/* Allocate all the minimal PLT entries.  */

static bfd_boolean
allocate_plt_entries (struct elfNN_ia64_dyn_sym_info *dyn_i,
		      PTR data)
{
  struct elfNN_ia64_allocate_data *x = (struct elfNN_ia64_allocate_data *)data;

  if (dyn_i->want_plt)
    {
      struct elf_link_hash_entry *h = dyn_i->h;

      if (h)
	while (h->root.type == bfd_link_hash_indirect
	       || h->root.type == bfd_link_hash_warning)
	  h = (struct elf_link_hash_entry *) h->root.u.i.link;

      /* ??? Versioned symbols seem to lose NEEDS_PLT.  */
      if (elfNN_ia64_dynamic_symbol_p (h, x->info, 0))
	{
	  bfd_size_type offset = x->ofs;
	  if (offset == 0)
	    offset = PLT_HEADER_SIZE;
	  dyn_i->plt_offset = offset;
	  x->ofs = offset + PLT_MIN_ENTRY_SIZE;

	  dyn_i->want_pltoff = 1;
	}
      else
	{
	  dyn_i->want_plt = 0;
	  dyn_i->want_plt2 = 0;
	}
    }
  return TRUE;
}

/* Allocate all the full PLT entries.  */

static bfd_boolean
allocate_plt2_entries (struct elfNN_ia64_dyn_sym_info *dyn_i,
		       PTR data)
{
  struct elfNN_ia64_allocate_data *x = (struct elfNN_ia64_allocate_data *)data;

  if (dyn_i->want_plt2)
    {
      struct elf_link_hash_entry *h = dyn_i->h;
      bfd_size_type ofs = x->ofs;

      dyn_i->plt2_offset = ofs;
      x->ofs = ofs + PLT_FULL_ENTRY_SIZE;

      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
      dyn_i->h->plt.offset = ofs;
    }
  return TRUE;
}

/* Allocate all the PLTOFF entries requested by relocations and
   plt entries.  We can't share space with allocated FPTR entries,
   because the latter are not necessarily addressable by the GP.
   ??? Relaxation might be able to determine that they are.  */

static bfd_boolean
allocate_pltoff_entries (struct elfNN_ia64_dyn_sym_info *dyn_i,
			 PTR data)
{
  struct elfNN_ia64_allocate_data *x = (struct elfNN_ia64_allocate_data *)data;

  if (dyn_i->want_pltoff)
    {
      dyn_i->pltoff_offset = x->ofs;
      x->ofs += 16;
    }
  return TRUE;
}

/* Allocate dynamic relocations for those symbols that turned out
   to be dynamic.  */

static bfd_boolean
allocate_dynrel_entries (struct elfNN_ia64_dyn_sym_info *dyn_i,
			 PTR data)
{
  struct elfNN_ia64_allocate_data *x = (struct elfNN_ia64_allocate_data *)data;
  struct elfNN_ia64_link_hash_table *ia64_info;
  struct elfNN_ia64_dyn_reloc_entry *rent;
  bfd_boolean dynamic_symbol, shared, resolved_zero;

  ia64_info = elfNN_ia64_hash_table (x->info);
  if (ia64_info == NULL)
    return FALSE;

  /* Note that this can't be used in relation to FPTR relocs below.  */
  dynamic_symbol = elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0);

  shared = x->info->shared;
  resolved_zero = (dyn_i->h
		   && ELF_ST_VISIBILITY (dyn_i->h->other)
		   && dyn_i->h->root.type == bfd_link_hash_undefweak);

  /* Take care of the GOT and PLT relocations.  */

  if ((!resolved_zero
       && (dynamic_symbol || shared)
       && (dyn_i->want_got || dyn_i->want_gotx))
      || (dyn_i->want_ltoff_fptr
	  && dyn_i->h
	  && dyn_i->h->dynindx != -1))
    {
      if (!dyn_i->want_ltoff_fptr
	  || !x->info->pie
	  || dyn_i->h == NULL
	  || dyn_i->h->root.type != bfd_link_hash_undefweak)
	ia64_info->root.srelgot->size += sizeof (ElfNN_External_Rela);
    }
  if ((dynamic_symbol || shared) && dyn_i->want_tprel)
    ia64_info->root.srelgot->size += sizeof (ElfNN_External_Rela);
  if (dynamic_symbol && dyn_i->want_dtpmod)
    ia64_info->root.srelgot->size += sizeof (ElfNN_External_Rela);
  if (dynamic_symbol && dyn_i->want_dtprel)
    ia64_info->root.srelgot->size += sizeof (ElfNN_External_Rela);

  if (x->only_got)
    return TRUE;

  if (ia64_info->rel_fptr_sec && dyn_i->want_fptr)
    {
      if (dyn_i->h == NULL || dyn_i->h->root.type != bfd_link_hash_undefweak)
	ia64_info->rel_fptr_sec->size += sizeof (ElfNN_External_Rela);
    }

  if (!resolved_zero && dyn_i->want_pltoff)
    {
      bfd_size_type t = 0;

      /* Dynamic symbols get one IPLT relocation.  Local symbols in
	 shared libraries get two REL relocations.  Local symbols in
	 main applications get nothing.  */
      if (dynamic_symbol)
	t = sizeof (ElfNN_External_Rela);
      else if (shared)
	t = 2 * sizeof (ElfNN_External_Rela);

      ia64_info->rel_pltoff_sec->size += t;
    }

  /* Take care of the normal data relocations.  */

  for (rent = dyn_i->reloc_entries; rent; rent = rent->next)
    {
      int count = rent->count;

      switch (rent->type)
	{
	case R_IA64_FPTR32LSB:
	case R_IA64_FPTR64LSB:
	  /* Allocate one iff !want_fptr and not PIE, which by this point
	     will be true only if we're actually allocating one statically
	     in the main executable.  Position independent executables
	     need a relative reloc.  */
	  if (dyn_i->want_fptr && !x->info->pie)
	    continue;
	  break;
	case R_IA64_PCREL32LSB:
	case R_IA64_PCREL64LSB:
	  if (!dynamic_symbol)
	    continue;
	  break;
	case R_IA64_DIR32LSB:
	case R_IA64_DIR64LSB:
	  if (!dynamic_symbol && !shared)
	    continue;
	  break;
	case R_IA64_IPLTLSB:
	  if (!dynamic_symbol && !shared)
	    continue;
	  /* Use two REL relocations for IPLT relocations
	     against local symbols.  */
	  if (!dynamic_symbol)
	    count *= 2;
	  break;
	case R_IA64_DTPREL32LSB:
	case R_IA64_TPREL64LSB:
	case R_IA64_DTPREL64LSB:
	case R_IA64_DTPMOD64LSB:
	  break;
	default:
	  abort ();
	}
      if (rent->reltext)
	ia64_info->reltext = 1;
      rent->srel->size += sizeof (ElfNN_External_Rela) * count;
    }

  return TRUE;
}

static bfd_boolean
elfNN_ia64_adjust_dynamic_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
				  struct elf_link_hash_entry *h)
{
  /* ??? Undefined symbols with PLT entries should be re-defined
     to be the PLT entry.  */

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
                  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* If this is a reference to a symbol defined by a dynamic object which
     is not a function, we might allocate the symbol in our .dynbss section
     and allocate a COPY dynamic relocation.

     But IA-64 code is canonically PIC, so as a rule we can avoid this sort
     of hackery.  */

  return TRUE;
}

static bfd_boolean
elfNN_ia64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *info)
{
  struct elfNN_ia64_allocate_data data;
  struct elfNN_ia64_link_hash_table *ia64_info;
  asection *sec;
  bfd *dynobj;
  bfd_boolean relplt = FALSE;

  dynobj = elf_hash_table(info)->dynobj;
  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return FALSE;
  ia64_info->self_dtpmod_offset = (bfd_vma) -1;
  BFD_ASSERT(dynobj != NULL);
  data.info = info;

  /* Set the contents of the .interp section to the interpreter.  */
  if (ia64_info->root.dynamic_sections_created
      && info->executable)
    {
      sec = bfd_get_section_by_name (dynobj, ".interp");
      BFD_ASSERT (sec != NULL);
      sec->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
      sec->size = strlen (ELF_DYNAMIC_INTERPRETER) + 1;
    }

  /* Allocate the GOT entries.  */

  if (ia64_info->root.sgot)
    {
      data.ofs = 0;
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_global_data_got, &data);
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_global_fptr_got, &data);
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_local_got, &data);
      ia64_info->root.sgot->size = data.ofs;
    }

  /* Allocate the FPTR entries.  */

  if (ia64_info->fptr_sec)
    {
      data.ofs = 0;
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_fptr, &data);
      ia64_info->fptr_sec->size = data.ofs;
    }

  /* Now that we've seen all of the input files, we can decide which
     symbols need plt entries.  Allocate the minimal PLT entries first.
     We do this even though dynamic_sections_created may be FALSE, because
     this has the side-effect of clearing want_plt and want_plt2.  */

  data.ofs = 0;
  elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_plt_entries, &data);

  ia64_info->minplt_entries = 0;
  if (data.ofs)
    {
      ia64_info->minplt_entries
	= (data.ofs - PLT_HEADER_SIZE) / PLT_MIN_ENTRY_SIZE;
    }

  /* Align the pointer for the plt2 entries.  */
  data.ofs = (data.ofs + 31) & (bfd_vma) -32;

  elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_plt2_entries, &data);
  if (data.ofs != 0 || ia64_info->root.dynamic_sections_created)
    {
      /* FIXME: we always reserve the memory for dynamic linker even if
	 there are no PLT entries since dynamic linker may assume the
	 reserved memory always exists.  */

      BFD_ASSERT (ia64_info->root.dynamic_sections_created);

      ia64_info->root.splt->size = data.ofs;

      /* If we've got a .plt, we need some extra memory for the dynamic
	 linker.  We stuff these in .got.plt.  */
      sec = bfd_get_section_by_name (dynobj, ".got.plt");
      sec->size = 8 * PLT_RESERVED_WORDS;
    }

  /* Allocate the PLTOFF entries.  */

  if (ia64_info->pltoff_sec)
    {
      data.ofs = 0;
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_pltoff_entries, &data);
      ia64_info->pltoff_sec->size = data.ofs;
    }

  if (ia64_info->root.dynamic_sections_created)
    {
      /* Allocate space for the dynamic relocations that turned out to be
	 required.  */

      if (info->shared && ia64_info->self_dtpmod_offset != (bfd_vma) -1)
	ia64_info->root.srelgot->size += sizeof (ElfNN_External_Rela);
      data.only_got = FALSE;
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_dynrel_entries, &data);
    }

  /* We have now determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  for (sec = dynobj->sections; sec != NULL; sec = sec->next)
    {
      bfd_boolean strip;

      if (!(sec->flags & SEC_LINKER_CREATED))
	continue;

      /* If we don't need this section, strip it from the output file.
	 There were several sections primarily related to dynamic
	 linking that must be create before the linker maps input
	 sections to output sections.  The linker does that before
	 bfd_elf_size_dynamic_sections is called, and it is that
	 function which decides whether anything needs to go into
	 these sections.  */

      strip = (sec->size == 0);

      if (sec == ia64_info->root.sgot)
	strip = FALSE;
      else if (sec == ia64_info->root.srelgot)
	{
	  if (strip)
	    ia64_info->root.srelgot = NULL;
	  else
	    /* We use the reloc_count field as a counter if we need to
	       copy relocs into the output file.  */
	    sec->reloc_count = 0;
	}
      else if (sec == ia64_info->fptr_sec)
	{
	  if (strip)
	    ia64_info->fptr_sec = NULL;
	}
      else if (sec == ia64_info->rel_fptr_sec)
	{
	  if (strip)
	    ia64_info->rel_fptr_sec = NULL;
	  else
	    /* We use the reloc_count field as a counter if we need to
	       copy relocs into the output file.  */
	    sec->reloc_count = 0;
	}
      else if (sec == ia64_info->root.splt)
	{
	  if (strip)
	    ia64_info->root.splt = NULL;
	}
      else if (sec == ia64_info->pltoff_sec)
	{
	  if (strip)
	    ia64_info->pltoff_sec = NULL;
	}
      else if (sec == ia64_info->rel_pltoff_sec)
	{
	  if (strip)
	    ia64_info->rel_pltoff_sec = NULL;
	  else
	    {
	      relplt = TRUE;
	      /* We use the reloc_count field as a counter if we need to
		 copy relocs into the output file.  */
	      sec->reloc_count = 0;
	    }
	}
      else
	{
	  const char *name;

	  /* It's OK to base decisions on the section name, because none
	     of the dynobj section names depend upon the input files.  */
	  name = bfd_get_section_name (dynobj, sec);

	  if (strcmp (name, ".got.plt") == 0)
	    strip = FALSE;
	  else if (CONST_STRNEQ (name, ".rel"))
	    {
	      if (!strip)
		{
		  /* We use the reloc_count field as a counter if we need to
		     copy relocs into the output file.  */
		  sec->reloc_count = 0;
		}
	    }
	  else
	    continue;
	}

      if (strip)
	sec->flags |= SEC_EXCLUDE;
      else
	{
	  /* Allocate memory for the section contents.  */
	  sec->contents = (bfd_byte *) bfd_zalloc (dynobj, sec->size);
	  if (sec->contents == NULL && sec->size != 0)
	    return FALSE;
	}
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the values
	 later (in finish_dynamic_sections) but we must add the entries now
	 so that we get the correct size for the .dynamic section.  */

      if (info->executable)
	{
	  /* The DT_DEBUG entry is filled in by the dynamic linker and used
	     by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (!add_dynamic_entry (DT_IA_64_PLT_RESERVE, 0))
	return FALSE;
      if (!add_dynamic_entry (DT_PLTGOT, 0))
	return FALSE;

      if (relplt)
	{
	  if (!add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (!add_dynamic_entry (DT_RELA, 0)
	  || !add_dynamic_entry (DT_RELASZ, 0)
	  || !add_dynamic_entry (DT_RELAENT, sizeof (ElfNN_External_Rela)))
	return FALSE;

      if (ia64_info->reltext)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	  info->flags |= DF_TEXTREL;
	}
    }

  /* ??? Perhaps force __gp local.  */

  return TRUE;
}

static bfd_reloc_status_type
elfNN_ia64_install_value (bfd_byte *hit_addr, bfd_vma v,
			  unsigned int r_type)
{
  const struct ia64_operand *op;
  int bigendian = 0, shift = 0;
  bfd_vma t0, t1, dword;
  ia64_insn insn;
  enum ia64_opnd opnd;
  const char *err;
  size_t size = 8;
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT val = (BFD_HOST_U_64_BIT) v;
#else
  bfd_vma val = v;
#endif

  opnd = IA64_OPND_NIL;
  switch (r_type)
    {
    case R_IA64_NONE:
    case R_IA64_LDXMOV:
      return bfd_reloc_ok;

      /* Instruction relocations.  */

    case R_IA64_IMM14:
    case R_IA64_TPREL14:
    case R_IA64_DTPREL14:
      opnd = IA64_OPND_IMM14;
      break;

    case R_IA64_PCREL21F:	opnd = IA64_OPND_TGT25; break;
    case R_IA64_PCREL21M:	opnd = IA64_OPND_TGT25b; break;
    case R_IA64_PCREL60B:	opnd = IA64_OPND_TGT64; break;
    case R_IA64_PCREL21B:
    case R_IA64_PCREL21BI:
      opnd = IA64_OPND_TGT25c;
      break;

    case R_IA64_IMM22:
    case R_IA64_GPREL22:
    case R_IA64_LTOFF22:
    case R_IA64_LTOFF22X:
    case R_IA64_PLTOFF22:
    case R_IA64_PCREL22:
    case R_IA64_LTOFF_FPTR22:
    case R_IA64_TPREL22:
    case R_IA64_DTPREL22:
    case R_IA64_LTOFF_TPREL22:
    case R_IA64_LTOFF_DTPMOD22:
    case R_IA64_LTOFF_DTPREL22:
      opnd = IA64_OPND_IMM22;
      break;

    case R_IA64_IMM64:
    case R_IA64_GPREL64I:
    case R_IA64_LTOFF64I:
    case R_IA64_PLTOFF64I:
    case R_IA64_PCREL64I:
    case R_IA64_FPTR64I:
    case R_IA64_LTOFF_FPTR64I:
    case R_IA64_TPREL64I:
    case R_IA64_DTPREL64I:
      opnd = IA64_OPND_IMMU64;
      break;

      /* Data relocations.  */

    case R_IA64_DIR32MSB:
    case R_IA64_GPREL32MSB:
    case R_IA64_FPTR32MSB:
    case R_IA64_PCREL32MSB:
    case R_IA64_LTOFF_FPTR32MSB:
    case R_IA64_SEGREL32MSB:
    case R_IA64_SECREL32MSB:
    case R_IA64_LTV32MSB:
    case R_IA64_DTPREL32MSB:
      size = 4; bigendian = 1;
      break;

    case R_IA64_DIR32LSB:
    case R_IA64_GPREL32LSB:
    case R_IA64_FPTR32LSB:
    case R_IA64_PCREL32LSB:
    case R_IA64_LTOFF_FPTR32LSB:
    case R_IA64_SEGREL32LSB:
    case R_IA64_SECREL32LSB:
    case R_IA64_LTV32LSB:
    case R_IA64_DTPREL32LSB:
      size = 4; bigendian = 0;
      break;

    case R_IA64_DIR64MSB:
    case R_IA64_GPREL64MSB:
    case R_IA64_PLTOFF64MSB:
    case R_IA64_FPTR64MSB:
    case R_IA64_PCREL64MSB:
    case R_IA64_LTOFF_FPTR64MSB:
    case R_IA64_SEGREL64MSB:
    case R_IA64_SECREL64MSB:
    case R_IA64_LTV64MSB:
    case R_IA64_TPREL64MSB:
    case R_IA64_DTPMOD64MSB:
    case R_IA64_DTPREL64MSB:
      size = 8; bigendian = 1;
      break;

    case R_IA64_DIR64LSB:
    case R_IA64_GPREL64LSB:
    case R_IA64_PLTOFF64LSB:
    case R_IA64_FPTR64LSB:
    case R_IA64_PCREL64LSB:
    case R_IA64_LTOFF_FPTR64LSB:
    case R_IA64_SEGREL64LSB:
    case R_IA64_SECREL64LSB:
    case R_IA64_LTV64LSB:
    case R_IA64_TPREL64LSB:
    case R_IA64_DTPMOD64LSB:
    case R_IA64_DTPREL64LSB:
      size = 8; bigendian = 0;
      break;

      /* Unsupported / Dynamic relocations.  */
    default:
      return bfd_reloc_notsupported;
    }

  switch (opnd)
    {
    case IA64_OPND_IMMU64:
      hit_addr -= (intptr_t) hit_addr & 0x3;
      t0 = bfd_getl64 (hit_addr);
      t1 = bfd_getl64 (hit_addr + 8);

      /* tmpl/s: bits  0.. 5 in t0
	 slot 0: bits  5..45 in t0
	 slot 1: bits 46..63 in t0, bits 0..22 in t1
	 slot 2: bits 23..63 in t1 */

      /* First, clear the bits that form the 64 bit constant.  */
      t0 &= ~(0x3ffffLL << 46);
      t1 &= ~(0x7fffffLL
	      | ((  (0x07fLL << 13) | (0x1ffLL << 27)
		    | (0x01fLL << 22) | (0x001LL << 21)
		    | (0x001LL << 36)) << 23));

      t0 |= ((val >> 22) & 0x03ffffLL) << 46;		/* 18 lsbs of imm41 */
      t1 |= ((val >> 40) & 0x7fffffLL) <<  0;		/* 23 msbs of imm41 */
      t1 |= (  (((val >>  0) & 0x07f) << 13)		/* imm7b */
	       | (((val >>  7) & 0x1ff) << 27)		/* imm9d */
	       | (((val >> 16) & 0x01f) << 22)		/* imm5c */
	       | (((val >> 21) & 0x001) << 21)		/* ic */
	       | (((val >> 63) & 0x001) << 36)) << 23;	/* i */

      bfd_putl64 (t0, hit_addr);
      bfd_putl64 (t1, hit_addr + 8);
      break;

    case IA64_OPND_TGT64:
      hit_addr -= (intptr_t) hit_addr & 0x3;
      t0 = bfd_getl64 (hit_addr);
      t1 = bfd_getl64 (hit_addr + 8);

      /* tmpl/s: bits  0.. 5 in t0
	 slot 0: bits  5..45 in t0
	 slot 1: bits 46..63 in t0, bits 0..22 in t1
	 slot 2: bits 23..63 in t1 */

      /* First, clear the bits that form the 64 bit constant.  */
      t0 &= ~(0x3ffffLL << 46);
      t1 &= ~(0x7fffffLL
	      | ((1LL << 36 | 0xfffffLL << 13) << 23));

      val >>= 4;
      t0 |= ((val >> 20) & 0xffffLL) << 2 << 46;	/* 16 lsbs of imm39 */
      t1 |= ((val >> 36) & 0x7fffffLL) << 0;		/* 23 msbs of imm39 */
      t1 |= ((((val >> 0) & 0xfffffLL) << 13)		/* imm20b */
	      | (((val >> 59) & 0x1LL) << 36)) << 23;	/* i */

      bfd_putl64 (t0, hit_addr);
      bfd_putl64 (t1, hit_addr + 8);
      break;

    default:
      switch ((intptr_t) hit_addr & 0x3)
	{
	case 0: shift =  5; break;
	case 1: shift = 14; hit_addr += 3; break;
	case 2: shift = 23; hit_addr += 6; break;
	case 3: return bfd_reloc_notsupported; /* shouldn't happen...  */
	}
      dword = bfd_getl64 (hit_addr);
      insn = (dword >> shift) & 0x1ffffffffffLL;

      op = elf64_ia64_operands + opnd;
      err = (*op->insert) (op, val, &insn);
      if (err)
	return bfd_reloc_overflow;

      dword &= ~(0x1ffffffffffLL << shift);
      dword |= (insn << shift);
      bfd_putl64 (dword, hit_addr);
      break;

    case IA64_OPND_NIL:
      /* A data relocation.  */
      if (bigendian)
	if (size == 4)
	  bfd_putb32 (val, hit_addr);
	else
	  bfd_putb64 (val, hit_addr);
      else
	if (size == 4)
	  bfd_putl32 (val, hit_addr);
	else
	  bfd_putl64 (val, hit_addr);
      break;
    }

  return bfd_reloc_ok;
}

static void
elfNN_ia64_install_dyn_reloc (bfd *abfd, struct bfd_link_info *info,
			      asection *sec, asection *srel,
			      bfd_vma offset, unsigned int type,
			      long dynindx, bfd_vma addend)
{
  Elf_Internal_Rela outrel;
  bfd_byte *loc;

  BFD_ASSERT (dynindx != -1);
  outrel.r_info = ELFNN_R_INFO (dynindx, type);
  outrel.r_addend = addend;
  outrel.r_offset = _bfd_elf_section_offset (abfd, info, sec, offset);
  if (outrel.r_offset >= (bfd_vma) -2)
    {
      /* Run for the hills.  We shouldn't be outputting a relocation
	 for this.  So do what everyone else does and output a no-op.  */
      outrel.r_info = ELFNN_R_INFO (0, R_IA64_NONE);
      outrel.r_addend = 0;
      outrel.r_offset = 0;
    }
  else
    outrel.r_offset += sec->output_section->vma + sec->output_offset;

  loc = srel->contents;
  loc += srel->reloc_count++ * sizeof (ElfNN_External_Rela);
  bfd_elfNN_swap_reloca_out (abfd, &outrel, loc);
  BFD_ASSERT (sizeof (ElfNN_External_Rela) * srel->reloc_count <= srel->size);
}

/* Store an entry for target address TARGET_ADDR in the linkage table
   and return the gp-relative address of the linkage table entry.  */

static bfd_vma
set_got_entry (bfd *abfd, struct bfd_link_info *info,
	       struct elfNN_ia64_dyn_sym_info *dyn_i,
	       long dynindx, bfd_vma addend, bfd_vma value,
	       unsigned int dyn_r_type)
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  asection *got_sec;
  bfd_boolean done;
  bfd_vma got_offset;

  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return 0;

  got_sec = ia64_info->root.sgot;

  switch (dyn_r_type)
    {
    case R_IA64_TPREL64LSB:
      done = dyn_i->tprel_done;
      dyn_i->tprel_done = TRUE;
      got_offset = dyn_i->tprel_offset;
      break;
    case R_IA64_DTPMOD64LSB:
      if (dyn_i->dtpmod_offset != ia64_info->self_dtpmod_offset)
	{
	  done = dyn_i->dtpmod_done;
	  dyn_i->dtpmod_done = TRUE;
	}
      else
	{
	  done = ia64_info->self_dtpmod_done;
	  ia64_info->self_dtpmod_done = TRUE;
	  dynindx = 0;
	}
      got_offset = dyn_i->dtpmod_offset;
      break;
    case R_IA64_DTPREL32LSB:
d664 1
a664 8
      done = dyn_i->dtprel_done;
      dyn_i->dtprel_done = TRUE;
      got_offset = dyn_i->dtprel_offset;
      break;
    default:
      done = dyn_i->got_done;
      dyn_i->got_done = TRUE;
      got_offset = dyn_i->got_offset;
a665 611
    }

  BFD_ASSERT ((got_offset & 7) == 0);

  if (! done)
    {
      /* Store the target address in the linkage table entry.  */
      bfd_put_64 (abfd, value, got_sec->contents + got_offset);

      /* Install a dynamic relocation if needed.  */
      if (((info->shared
	    && (!dyn_i->h
		|| ELF_ST_VISIBILITY (dyn_i->h->other) == STV_DEFAULT
		|| dyn_i->h->root.type != bfd_link_hash_undefweak)
	    && dyn_r_type != R_IA64_DTPREL32LSB
	    && dyn_r_type != R_IA64_DTPREL64LSB)
           || elfNN_ia64_dynamic_symbol_p (dyn_i->h, info, dyn_r_type)
	   || (dynindx != -1
	       && (dyn_r_type == R_IA64_FPTR32LSB
		   || dyn_r_type == R_IA64_FPTR64LSB)))
	  && (!dyn_i->want_ltoff_fptr
	      || !info->pie
	      || !dyn_i->h
	      || dyn_i->h->root.type != bfd_link_hash_undefweak))
	{
	  if (dynindx == -1
	      && dyn_r_type != R_IA64_TPREL64LSB
	      && dyn_r_type != R_IA64_DTPMOD64LSB
	      && dyn_r_type != R_IA64_DTPREL32LSB
	      && dyn_r_type != R_IA64_DTPREL64LSB)
	    {
	      dyn_r_type = R_IA64_RELNNLSB;
	      dynindx = 0;
	      addend = value;
	    }

	  if (bfd_big_endian (abfd))
	    {
	      switch (dyn_r_type)
		{
		case R_IA64_REL32LSB:
		  dyn_r_type = R_IA64_REL32MSB;
		  break;
		case R_IA64_DIR32LSB:
		  dyn_r_type = R_IA64_DIR32MSB;
		  break;
		case R_IA64_FPTR32LSB:
		  dyn_r_type = R_IA64_FPTR32MSB;
		  break;
		case R_IA64_DTPREL32LSB:
		  dyn_r_type = R_IA64_DTPREL32MSB;
		  break;
		case R_IA64_REL64LSB:
		  dyn_r_type = R_IA64_REL64MSB;
		  break;
		case R_IA64_DIR64LSB:
		  dyn_r_type = R_IA64_DIR64MSB;
		  break;
		case R_IA64_FPTR64LSB:
		  dyn_r_type = R_IA64_FPTR64MSB;
		  break;
		case R_IA64_TPREL64LSB:
		  dyn_r_type = R_IA64_TPREL64MSB;
		  break;
		case R_IA64_DTPMOD64LSB:
		  dyn_r_type = R_IA64_DTPMOD64MSB;
		  break;
		case R_IA64_DTPREL64LSB:
		  dyn_r_type = R_IA64_DTPREL64MSB;
		  break;
		default:
		  BFD_ASSERT (FALSE);
		  break;
		}
	    }

	  elfNN_ia64_install_dyn_reloc (abfd, NULL, got_sec,
					ia64_info->root.srelgot,
					got_offset, dyn_r_type,
					dynindx, addend);
	}
    }

  /* Return the address of the linkage table entry.  */
  value = (got_sec->output_section->vma
	   + got_sec->output_offset
	   + got_offset);

  return value;
}

/* Fill in a function descriptor consisting of the function's code
   address and its global pointer.  Return the descriptor's address.  */

static bfd_vma
set_fptr_entry (bfd *abfd, struct bfd_link_info *info,
		struct elfNN_ia64_dyn_sym_info *dyn_i,
		bfd_vma value)
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  asection *fptr_sec;

  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return 0;

  fptr_sec = ia64_info->fptr_sec;

  if (!dyn_i->fptr_done)
    {
      dyn_i->fptr_done = 1;

      /* Fill in the function descriptor.  */
      bfd_put_64 (abfd, value, fptr_sec->contents + dyn_i->fptr_offset);
      bfd_put_64 (abfd, _bfd_get_gp_value (abfd),
		  fptr_sec->contents + dyn_i->fptr_offset + 8);
      if (ia64_info->rel_fptr_sec)
	{
	  Elf_Internal_Rela outrel;
	  bfd_byte *loc;

	  if (bfd_little_endian (abfd))
	    outrel.r_info = ELFNN_R_INFO (0, R_IA64_IPLTLSB);
	  else
	    outrel.r_info = ELFNN_R_INFO (0, R_IA64_IPLTMSB);
	  outrel.r_addend = value;
	  outrel.r_offset = (fptr_sec->output_section->vma
			     + fptr_sec->output_offset
			     + dyn_i->fptr_offset);
	  loc = ia64_info->rel_fptr_sec->contents;
	  loc += ia64_info->rel_fptr_sec->reloc_count++
		 * sizeof (ElfNN_External_Rela);
	  bfd_elfNN_swap_reloca_out (abfd, &outrel, loc);
	}
    }

  /* Return the descriptor's address.  */
  value = (fptr_sec->output_section->vma
	   + fptr_sec->output_offset
	   + dyn_i->fptr_offset);

  return value;
}

/* Fill in a PLTOFF entry consisting of the function's code address
   and its global pointer.  Return the descriptor's address.  */

static bfd_vma
set_pltoff_entry (bfd *abfd, struct bfd_link_info *info,
		  struct elfNN_ia64_dyn_sym_info *dyn_i,
		  bfd_vma value, bfd_boolean is_plt)
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  asection *pltoff_sec;

  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return 0;

  pltoff_sec = ia64_info->pltoff_sec;

  /* Don't do anything if this symbol uses a real PLT entry.  In
     that case, we'll fill this in during finish_dynamic_symbol.  */
  if ((! dyn_i->want_plt || is_plt)
      && !dyn_i->pltoff_done)
    {
      bfd_vma gp = _bfd_get_gp_value (abfd);

      /* Fill in the function descriptor.  */
      bfd_put_64 (abfd, value, pltoff_sec->contents + dyn_i->pltoff_offset);
      bfd_put_64 (abfd, gp, pltoff_sec->contents + dyn_i->pltoff_offset + 8);

      /* Install dynamic relocations if needed.  */
      if (!is_plt
	  && info->shared
	  && (!dyn_i->h
	      || ELF_ST_VISIBILITY (dyn_i->h->other) == STV_DEFAULT
	      || dyn_i->h->root.type != bfd_link_hash_undefweak))
	{
	  unsigned int dyn_r_type;

	  if (bfd_big_endian (abfd))
	    dyn_r_type = R_IA64_RELNNMSB;
	  else
	    dyn_r_type = R_IA64_RELNNLSB;

	  elfNN_ia64_install_dyn_reloc (abfd, NULL, pltoff_sec,
					ia64_info->rel_pltoff_sec,
					dyn_i->pltoff_offset,
					dyn_r_type, 0, value);
	  elfNN_ia64_install_dyn_reloc (abfd, NULL, pltoff_sec,
					ia64_info->rel_pltoff_sec,
					dyn_i->pltoff_offset + ARCH_SIZE / 8,
					dyn_r_type, 0, gp);
	}

      dyn_i->pltoff_done = 1;
    }

  /* Return the descriptor's address.  */
  value = (pltoff_sec->output_section->vma
	   + pltoff_sec->output_offset
	   + dyn_i->pltoff_offset);

  return value;
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@tprel() relocation.
   Main program TLS (whose template starts at PT_TLS p_vaddr)
   is assigned offset round(2 * size of pointer, PT_TLS p_align).  */

static bfd_vma
elfNN_ia64_tprel_base (struct bfd_link_info *info)
{
  asection *tls_sec = elf_hash_table (info)->tls_sec;
  return tls_sec->vma - align_power ((bfd_vma) ARCH_SIZE / 4,
				     tls_sec->alignment_power);
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtprel() relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
elfNN_ia64_dtprel_base (struct bfd_link_info *info)
{
  return elf_hash_table (info)->tls_sec->vma;
}

/* Called through qsort to sort the .IA_64.unwind section during a
   non-relocatable link.  Set elfNN_ia64_unwind_entry_compare_bfd
   to the output bfd so we can do proper endianness frobbing.  */

static bfd *elfNN_ia64_unwind_entry_compare_bfd;

static int
elfNN_ia64_unwind_entry_compare (const PTR a, const PTR b)
{
  bfd_vma av, bv;

  av = bfd_get_64 (elfNN_ia64_unwind_entry_compare_bfd, a);
  bv = bfd_get_64 (elfNN_ia64_unwind_entry_compare_bfd, b);

  return (av < bv ? -1 : av > bv ? 1 : 0);
}

/* Make sure we've got ourselves a nice fat __gp value.  */
static bfd_boolean
elfNN_ia64_choose_gp (bfd *abfd, struct bfd_link_info *info, bfd_boolean final)
{
  bfd_vma min_vma = (bfd_vma) -1, max_vma = 0;
  bfd_vma min_short_vma = min_vma, max_short_vma = 0;
  struct elf_link_hash_entry *gp;
  bfd_vma gp_val;
  asection *os;
  struct elfNN_ia64_link_hash_table *ia64_info;

  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return FALSE;

  /* Find the min and max vma of all sections marked short.  Also collect
     min and max vma of any type, for use in selecting a nice gp.  */
  for (os = abfd->sections; os ; os = os->next)
    {
      bfd_vma lo, hi;

      if ((os->flags & SEC_ALLOC) == 0)
	continue;

      lo = os->vma;
      /* When this function is called from elfNN_ia64_final_link
	 the correct value to use is os->size.  When called from
	 elfNN_ia64_relax_section we are in the middle of section
	 sizing; some sections will already have os->size set, others
	 will have os->size zero and os->rawsize the previous size.  */
      hi = os->vma + (!final && os->rawsize ? os->rawsize : os->size);
      if (hi < lo)
	hi = (bfd_vma) -1;

      if (min_vma > lo)
	min_vma = lo;
      if (max_vma < hi)
	max_vma = hi;
      if (os->flags & SEC_SMALL_DATA)
	{
	  if (min_short_vma > lo)
	    min_short_vma = lo;
	  if (max_short_vma < hi)
	    max_short_vma = hi;
	}
    }

  if (ia64_info->min_short_sec)
    {
      if (min_short_vma 
	  > (ia64_info->min_short_sec->vma
	     + ia64_info->min_short_offset))
	min_short_vma = (ia64_info->min_short_sec->vma
			 + ia64_info->min_short_offset);
      if (max_short_vma
	  < (ia64_info->max_short_sec->vma
	     + ia64_info->max_short_offset))
	max_short_vma = (ia64_info->max_short_sec->vma
			 + ia64_info->max_short_offset);
    }

  /* See if the user wants to force a value.  */
  gp = elf_link_hash_lookup (elf_hash_table (info), "__gp", FALSE,
			     FALSE, FALSE);

  if (gp
      && (gp->root.type == bfd_link_hash_defined
	  || gp->root.type == bfd_link_hash_defweak))
    {
      asection *gp_sec = gp->root.u.def.section;
      gp_val = (gp->root.u.def.value
		+ gp_sec->output_section->vma
		+ gp_sec->output_offset);
    }
  else
    {
      /* Pick a sensible value.  */

      if (ia64_info->min_short_sec)
	{
	  bfd_vma short_range = max_short_vma - min_short_vma;

	  /* If min_short_sec is set, pick one in the middle bewteen
	     min_short_vma and max_short_vma.  */
	  if (short_range >= 0x400000)
	    goto overflow;
	  gp_val = min_short_vma + short_range / 2;
	}
      else
	{
	  asection *got_sec = ia64_info->root.sgot;

	  /* Start with just the address of the .got.  */
	  if (got_sec)
	    gp_val = got_sec->output_section->vma;
	  else if (max_short_vma != 0)
	    gp_val = min_short_vma;
	  else if (max_vma - min_vma < 0x200000)
	    gp_val = min_vma;
	  else
	    gp_val = max_vma - 0x200000 + 8;
	}

      /* If it is possible to address the entire image, but we
	 don't with the choice above, adjust.  */
      if (max_vma - min_vma < 0x400000
	  && (max_vma - gp_val >= 0x200000
	      || gp_val - min_vma > 0x200000))
	gp_val = min_vma + 0x200000;
      else if (max_short_vma != 0)
	{
	  /* If we don't cover all the short data, adjust.  */
	  if (max_short_vma - gp_val >= 0x200000)
	    gp_val = min_short_vma + 0x200000;

	  /* If we're addressing stuff past the end, adjust back.  */
	  if (gp_val > max_vma)
	    gp_val = max_vma - 0x200000 + 8;
	}
    }

  /* Validate whether all SHF_IA_64_SHORT sections are within
     range of the chosen GP.  */

  if (max_short_vma != 0)
    {
      if (max_short_vma - min_short_vma >= 0x400000)
	{
overflow:
	  (*_bfd_error_handler)
	    (_("%s: short data segment overflowed (0x%lx >= 0x400000)"),
	     bfd_get_filename (abfd),
	     (unsigned long) (max_short_vma - min_short_vma));
	  return FALSE;
	}
      else if ((gp_val > min_short_vma
		&& gp_val - min_short_vma > 0x200000)
	       || (gp_val < max_short_vma
		   && max_short_vma - gp_val >= 0x200000))
	{
	  (*_bfd_error_handler)
	    (_("%s: __gp does not cover short data segment"),
	     bfd_get_filename (abfd));
	  return FALSE;
	}
    }

  _bfd_set_gp_value (abfd, gp_val);

  return TRUE;
}

static bfd_boolean
elfNN_ia64_final_link (bfd *abfd, struct bfd_link_info *info)
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  asection *unwind_output_sec;

  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return FALSE;

  /* Make sure we've got ourselves a nice fat __gp value.  */
  if (!info->relocatable)
    {
      bfd_vma gp_val;
      struct elf_link_hash_entry *gp;

      /* We assume after gp is set, section size will only decrease. We
	 need to adjust gp for it.  */
      _bfd_set_gp_value (abfd, 0);
      if (! elfNN_ia64_choose_gp (abfd, info, TRUE))
	return FALSE;
      gp_val = _bfd_get_gp_value (abfd);

      gp = elf_link_hash_lookup (elf_hash_table (info), "__gp", FALSE,
			         FALSE, FALSE);
      if (gp)
	{
	  gp->root.type = bfd_link_hash_defined;
	  gp->root.u.def.value = gp_val;
	  gp->root.u.def.section = bfd_abs_section_ptr;
	}
    }

  /* If we're producing a final executable, we need to sort the contents
     of the .IA_64.unwind section.  Force this section to be relocated
     into memory rather than written immediately to the output file.  */
  unwind_output_sec = NULL;
  if (!info->relocatable)
    {
      asection *s = bfd_get_section_by_name (abfd, ELF_STRING_ia64_unwind);
      if (s)
	{
	  unwind_output_sec = s->output_section;
	  unwind_output_sec->contents
	    = bfd_malloc (unwind_output_sec->size);
	  if (unwind_output_sec->contents == NULL)
	    return FALSE;
	}
    }

  /* Invoke the regular ELF backend linker to do all the work.  */
  if (!bfd_elf_final_link (abfd, info))
    return FALSE;

  if (unwind_output_sec)
    {
      elfNN_ia64_unwind_entry_compare_bfd = abfd;
      qsort (unwind_output_sec->contents,
	     (size_t) (unwind_output_sec->size / 24),
	     24,
	     elfNN_ia64_unwind_entry_compare);

      if (! bfd_set_section_contents (abfd, unwind_output_sec,
				      unwind_output_sec->contents, (bfd_vma) 0,
				      unwind_output_sec->size))
	return FALSE;
    }

  return TRUE;
}

static bfd_boolean
elfNN_ia64_relocate_section (bfd *output_bfd,
			     struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents,
			     Elf_Internal_Rela *relocs,
			     Elf_Internal_Sym *local_syms,
			     asection **local_sections)
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  asection *srel;
  bfd_boolean ret_val = TRUE;	/* for non-fatal errors */
  bfd_vma gp_val;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return FALSE;

  /* Infect various flags from the input section to the output section.  */
  if (info->relocatable)
    {
      bfd_vma flags;

      flags = elf_section_data(input_section)->this_hdr.sh_flags;
      flags &= SHF_IA_64_NORECOV;

      elf_section_data(input_section->output_section)
	->this_hdr.sh_flags |= flags;
    }

  gp_val = _bfd_get_gp_value (output_bfd);
  srel = get_reloc_section (input_bfd, ia64_info, input_section, FALSE);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; ++rel)
    {
      struct elf_link_hash_entry *h;
      struct elfNN_ia64_dyn_sym_info *dyn_i;
      bfd_reloc_status_type r;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      unsigned int r_type;
      bfd_vma value;
      asection *sym_sec;
      bfd_byte *hit_addr;
      bfd_boolean dynamic_symbol_p;
      bfd_boolean undef_weak_ref;

      r_type = ELFNN_R_TYPE (rel->r_info);
      if (r_type > R_IA64_MAX_RELOC_CODE)
	{
	  (*_bfd_error_handler)
	    (_("%B: unknown relocation type %d"),
	     input_bfd, (int) r_type);
	  bfd_set_error (bfd_error_bad_value);
	  ret_val = FALSE;
	  continue;
	}

      howto = lookup_howto (r_type);
      r_symndx = ELFNN_R_SYM (rel->r_info);
      h = NULL;
      sym = NULL;
      sym_sec = NULL;
      undef_weak_ref = FALSE;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* Reloc against local symbol.  */
	  asection *msec;
	  sym = local_syms + r_symndx;
	  sym_sec = local_sections[r_symndx];
	  msec = sym_sec;
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, &msec, rel);
	  if (!info->relocatable
	      && (sym_sec->flags & SEC_MERGE) != 0
	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
	      && sym_sec->sec_info_type == ELF_INFO_TYPE_MERGE)
 	    {
	      struct elfNN_ia64_local_hash_entry *loc_h;

	      loc_h = get_local_sym_hash (ia64_info, input_bfd, rel, FALSE);
	      if (loc_h && ! loc_h->sec_merge_done)
		{
		  struct elfNN_ia64_dyn_sym_info *dynent;
		  unsigned int count;

		  for (count = loc_h->count, dynent = loc_h->info;
		       count != 0;
		       count--, dynent++)
		    {
		      msec = sym_sec;
		      dynent->addend =
			_bfd_merged_section_offset (output_bfd, &msec,
						    elf_section_data (msec)->
						    sec_info,
						    sym->st_value
						    + dynent->addend);
		      dynent->addend -= sym->st_value;
		      dynent->addend += msec->output_section->vma
					+ msec->output_offset
					- sym_sec->output_section->vma
					- sym_sec->output_offset;
		    }

		  /* We may have introduced duplicated entries. We need
		     to remove them properly.  */
		  count = sort_dyn_sym_info (loc_h->info, loc_h->count);
		  if (count != loc_h->count)
		    {
		      loc_h->count = count;
		      loc_h->sorted_count = count;
		    }

		  loc_h->sec_merge_done = 1;
		}
	    }
	}
      else
	{
	  bfd_boolean unresolved_reloc;
	  bfd_boolean warned;
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sym_sec, value,
				   unresolved_reloc, warned);

	  if (h->root.type == bfd_link_hash_undefweak)
	    undef_weak_ref = TRUE;
	  else if (warned)
	    continue;
	}
d667 3
a669 586
      if (sym_sec != NULL && elf_discarded_section (sym_sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, relend, howto, contents);

      if (info->relocatable)
	continue;

      hit_addr = contents + rel->r_offset;
      value += rel->r_addend;
      dynamic_symbol_p = elfNN_ia64_dynamic_symbol_p (h, info, r_type);

      switch (r_type)
	{
	case R_IA64_NONE:
	case R_IA64_LDXMOV:
	  continue;

	case R_IA64_IMM14:
	case R_IA64_IMM22:
	case R_IA64_IMM64:
	case R_IA64_DIR32MSB:
	case R_IA64_DIR32LSB:
	case R_IA64_DIR64MSB:
	case R_IA64_DIR64LSB:
	  /* Install a dynamic relocation for this reloc.  */
	  if ((dynamic_symbol_p || info->shared)
	      && r_symndx != STN_UNDEF
	      && (input_section->flags & SEC_ALLOC) != 0)
	    {
	      unsigned int dyn_r_type;
	      long dynindx;
	      bfd_vma addend;

	      BFD_ASSERT (srel != NULL);

	      switch (r_type)
		{
		case R_IA64_IMM14:
		case R_IA64_IMM22:
		case R_IA64_IMM64:
		  /* ??? People shouldn't be doing non-pic code in
		     shared libraries nor dynamic executables.  */
		  (*_bfd_error_handler)
		    (_("%B: non-pic code with imm relocation against dynamic symbol `%s'"),
		     input_bfd,
		     h ? h->root.root.string
		       : bfd_elf_sym_name (input_bfd, symtab_hdr, sym,
					   sym_sec));
		  ret_val = FALSE;
		  continue;

		default:
		  break;
		}

	      /* If we don't need dynamic symbol lookup, find a
		 matching RELATIVE relocation.  */
	      dyn_r_type = r_type;
	      if (dynamic_symbol_p)
		{
		  dynindx = h->dynindx;
		  addend = rel->r_addend;
		  value = 0;
		}
	      else
		{
		  switch (r_type)
		    {
		    case R_IA64_DIR32MSB:
		      dyn_r_type = R_IA64_REL32MSB;
		      break;
		    case R_IA64_DIR32LSB:
		      dyn_r_type = R_IA64_REL32LSB;
		      break;
		    case R_IA64_DIR64MSB:
		      dyn_r_type = R_IA64_REL64MSB;
		      break;
		    case R_IA64_DIR64LSB:
		      dyn_r_type = R_IA64_REL64LSB;
		      break;

		    default:
		      break;
		    }
		  dynindx = 0;
		  addend = value;
		}

	      elfNN_ia64_install_dyn_reloc (output_bfd, info, input_section,
					    srel, rel->r_offset, dyn_r_type,
					    dynindx, addend);
	    }
	  /* Fall through.  */

	case R_IA64_LTV32MSB:
	case R_IA64_LTV32LSB:
	case R_IA64_LTV64MSB:
	case R_IA64_LTV64LSB:
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  break;

	case R_IA64_GPREL22:
	case R_IA64_GPREL64I:
	case R_IA64_GPREL32MSB:
	case R_IA64_GPREL32LSB:
	case R_IA64_GPREL64MSB:
	case R_IA64_GPREL64LSB:
	  if (dynamic_symbol_p)
	    {
	      (*_bfd_error_handler)
		(_("%B: @@gprel relocation against dynamic symbol %s"),
		 input_bfd,
		 h ? h->root.root.string
		   : bfd_elf_sym_name (input_bfd, symtab_hdr, sym,
				       sym_sec));
	      ret_val = FALSE;
	      continue;
	    }
	  value -= gp_val;
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  break;

	case R_IA64_LTOFF22:
	case R_IA64_LTOFF22X:
	case R_IA64_LTOFF64I:
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
	  value = set_got_entry (input_bfd, info, dyn_i, (h ? h->dynindx : -1),
				 rel->r_addend, value, R_IA64_DIRNNLSB);
	  value -= gp_val;
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  break;

	case R_IA64_PLTOFF22:
	case R_IA64_PLTOFF64I:
	case R_IA64_PLTOFF64MSB:
	case R_IA64_PLTOFF64LSB:
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
	  value = set_pltoff_entry (output_bfd, info, dyn_i, value, FALSE);
	  value -= gp_val;
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  break;

	case R_IA64_FPTR64I:
	case R_IA64_FPTR32MSB:
	case R_IA64_FPTR32LSB:
	case R_IA64_FPTR64MSB:
	case R_IA64_FPTR64LSB:
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
	  if (dyn_i->want_fptr)
	    {
	      if (!undef_weak_ref)
		value = set_fptr_entry (output_bfd, info, dyn_i, value);
	    }
	  if (!dyn_i->want_fptr || info->pie)
	    {
	      long dynindx;
	      unsigned int dyn_r_type = r_type;
	      bfd_vma addend = rel->r_addend;

	      /* Otherwise, we expect the dynamic linker to create
		 the entry.  */

	      if (dyn_i->want_fptr)
		{
		  if (r_type == R_IA64_FPTR64I)
		    {
		      /* We can't represent this without a dynamic symbol.
			 Adjust the relocation to be against an output
			 section symbol, which are always present in the
			 dynamic symbol table.  */
		      /* ??? People shouldn't be doing non-pic code in
			 shared libraries.  Hork.  */
		      (*_bfd_error_handler)
			(_("%B: linking non-pic code in a position independent executable"),
			 input_bfd);
		      ret_val = FALSE;
		      continue;
		    }
		  dynindx = 0;
		  addend = value;
		  dyn_r_type = r_type + R_IA64_RELNNLSB - R_IA64_FPTRNNLSB;
		}
	      else if (h)
		{
		  if (h->dynindx != -1)
		    dynindx = h->dynindx;
		  else
		    dynindx = (_bfd_elf_link_lookup_local_dynindx
			       (info, h->root.u.def.section->owner,
				global_sym_index (h)));
		  value = 0;
		}
	      else
		{
		  dynindx = (_bfd_elf_link_lookup_local_dynindx
			     (info, input_bfd, (long) r_symndx));
		  value = 0;
		}

	      elfNN_ia64_install_dyn_reloc (output_bfd, info, input_section,
					    srel, rel->r_offset, dyn_r_type,
					    dynindx, addend);
	    }

	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  break;

	case R_IA64_LTOFF_FPTR22:
	case R_IA64_LTOFF_FPTR64I:
	case R_IA64_LTOFF_FPTR32MSB:
	case R_IA64_LTOFF_FPTR32LSB:
	case R_IA64_LTOFF_FPTR64MSB:
	case R_IA64_LTOFF_FPTR64LSB:
	  {
	    long dynindx;

	    dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
	    if (dyn_i->want_fptr)
	      {
		BFD_ASSERT (h == NULL || h->dynindx == -1);
	        if (!undef_weak_ref)
	          value = set_fptr_entry (output_bfd, info, dyn_i, value);
		dynindx = -1;
	      }
	    else
	      {
	        /* Otherwise, we expect the dynamic linker to create
		   the entry.  */
	        if (h)
		  {
		    if (h->dynindx != -1)
		      dynindx = h->dynindx;
		    else
		      dynindx = (_bfd_elf_link_lookup_local_dynindx
				 (info, h->root.u.def.section->owner,
				  global_sym_index (h)));
		  }
		else
		  dynindx = (_bfd_elf_link_lookup_local_dynindx
			     (info, input_bfd, (long) r_symndx));
		value = 0;
	      }

	    value = set_got_entry (output_bfd, info, dyn_i, dynindx,
				   rel->r_addend, value, R_IA64_FPTRNNLSB);
	    value -= gp_val;
	    r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  }
	  break;

	case R_IA64_PCREL32MSB:
	case R_IA64_PCREL32LSB:
	case R_IA64_PCREL64MSB:
	case R_IA64_PCREL64LSB:
	  /* Install a dynamic relocation for this reloc.  */
	  if (dynamic_symbol_p && r_symndx != STN_UNDEF)
	    {
	      BFD_ASSERT (srel != NULL);

	      elfNN_ia64_install_dyn_reloc (output_bfd, info, input_section,
					    srel, rel->r_offset, r_type,
					    h->dynindx, rel->r_addend);
	    }
	  goto finish_pcrel;

	case R_IA64_PCREL21B:
	case R_IA64_PCREL60B:
	  /* We should have created a PLT entry for any dynamic symbol.  */
	  dyn_i = NULL;
	  if (h)
	    dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, FALSE);

	  if (dyn_i && dyn_i->want_plt2)
	    {
	      /* Should have caught this earlier.  */
	      BFD_ASSERT (rel->r_addend == 0);

	      value = (ia64_info->root.splt->output_section->vma
		       + ia64_info->root.splt->output_offset
		       + dyn_i->plt2_offset);
	    }
	  else
	    {
	      /* Since there's no PLT entry, Validate that this is
		 locally defined.  */
	      BFD_ASSERT (undef_weak_ref || sym_sec->output_section != NULL);

	      /* If the symbol is undef_weak, we shouldn't be trying
		 to call it.  There's every chance that we'd wind up
		 with an out-of-range fixup here.  Don't bother setting
		 any value at all.  */
	      if (undef_weak_ref)
		continue;
	    }
	  goto finish_pcrel;

	case R_IA64_PCREL21BI:
	case R_IA64_PCREL21F:
	case R_IA64_PCREL21M:
	case R_IA64_PCREL22:
	case R_IA64_PCREL64I:
	  /* The PCREL21BI reloc is specifically not intended for use with
	     dynamic relocs.  PCREL21F and PCREL21M are used for speculation
	     fixup code, and thus probably ought not be dynamic.  The
	     PCREL22 and PCREL64I relocs aren't emitted as dynamic relocs.  */
	  if (dynamic_symbol_p)
	    {
	      const char *msg;

	      if (r_type == R_IA64_PCREL21BI)
		msg = _("%B: @@internal branch to dynamic symbol %s");
	      else if (r_type == R_IA64_PCREL21F || r_type == R_IA64_PCREL21M)
		msg = _("%B: speculation fixup to dynamic symbol %s");
	      else
		msg = _("%B: @@pcrel relocation against dynamic symbol %s");
	      (*_bfd_error_handler) (msg, input_bfd,
				     h ? h->root.root.string
				       : bfd_elf_sym_name (input_bfd,
							   symtab_hdr,
							   sym,
							   sym_sec));
	      ret_val = FALSE;
	      continue;
	    }
	  goto finish_pcrel;

	finish_pcrel:
	  /* Make pc-relative.  */
	  value -= (input_section->output_section->vma
		    + input_section->output_offset
		    + rel->r_offset) & ~ (bfd_vma) 0x3;
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  break;

	case R_IA64_SEGREL32MSB:
	case R_IA64_SEGREL32LSB:
	case R_IA64_SEGREL64MSB:
	case R_IA64_SEGREL64LSB:
	    {
	      /* Find the segment that contains the output_section.  */
	      Elf_Internal_Phdr *p = _bfd_elf_find_segment_containing_section
		(output_bfd, input_section->output_section);

	      if (p == NULL)
		{
		  r = bfd_reloc_notsupported;
		}
	      else
		{
		  /* The VMA of the segment is the vaddr of the associated
		     program header.  */
		  if (value > p->p_vaddr)
		    value -= p->p_vaddr;
		  else
		    value = 0;
		  r = elfNN_ia64_install_value (hit_addr, value, r_type);
		}
	      break;
	    }

	case R_IA64_SECREL32MSB:
	case R_IA64_SECREL32LSB:
	case R_IA64_SECREL64MSB:
	case R_IA64_SECREL64LSB:
	  /* Make output-section relative to section where the symbol
	     is defined. PR 475  */
	  if (sym_sec)
	    value -= sym_sec->output_section->vma;
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  break;

	case R_IA64_IPLTMSB:
	case R_IA64_IPLTLSB:
	  /* Install a dynamic relocation for this reloc.  */
	  if ((dynamic_symbol_p || info->shared)
	      && (input_section->flags & SEC_ALLOC) != 0)
	    {
	      BFD_ASSERT (srel != NULL);

	      /* If we don't need dynamic symbol lookup, install two
		 RELATIVE relocations.  */
	      if (!dynamic_symbol_p)
		{
		  unsigned int dyn_r_type;

		  if (r_type == R_IA64_IPLTMSB)
		    dyn_r_type = R_IA64_REL64MSB;
		  else
		    dyn_r_type = R_IA64_REL64LSB;

		  elfNN_ia64_install_dyn_reloc (output_bfd, info,
						input_section,
						srel, rel->r_offset,
						dyn_r_type, 0, value);
		  elfNN_ia64_install_dyn_reloc (output_bfd, info,
						input_section,
						srel, rel->r_offset + 8,
						dyn_r_type, 0, gp_val);
		}
	      else
		elfNN_ia64_install_dyn_reloc (output_bfd, info, input_section,
					      srel, rel->r_offset, r_type,
					      h->dynindx, rel->r_addend);
	    }

	  if (r_type == R_IA64_IPLTMSB)
	    r_type = R_IA64_DIR64MSB;
	  else
	    r_type = R_IA64_DIR64LSB;
	  elfNN_ia64_install_value (hit_addr, value, r_type);
	  r = elfNN_ia64_install_value (hit_addr + 8, gp_val, r_type);
	  break;

	case R_IA64_TPREL14:
	case R_IA64_TPREL22:
	case R_IA64_TPREL64I:
	  if (elf_hash_table (info)->tls_sec == NULL)
	    goto missing_tls_sec;
	  value -= elfNN_ia64_tprel_base (info);
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  break;

	case R_IA64_DTPREL14:
	case R_IA64_DTPREL22:
	case R_IA64_DTPREL64I:
	case R_IA64_DTPREL32LSB:
	case R_IA64_DTPREL32MSB:
	case R_IA64_DTPREL64LSB:
	case R_IA64_DTPREL64MSB:
	  if (elf_hash_table (info)->tls_sec == NULL)
	    goto missing_tls_sec;
	  value -= elfNN_ia64_dtprel_base (info);
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  break;

	case R_IA64_LTOFF_TPREL22:
	case R_IA64_LTOFF_DTPMOD22:
	case R_IA64_LTOFF_DTPREL22:
	  {
	    int got_r_type;
	    long dynindx = h ? h->dynindx : -1;
	    bfd_vma r_addend = rel->r_addend;

	    switch (r_type)
	      {
	      default:
	      case R_IA64_LTOFF_TPREL22:
		if (!dynamic_symbol_p)
		  {
		    if (elf_hash_table (info)->tls_sec == NULL)
		      goto missing_tls_sec;
		    if (!info->shared)
		      value -= elfNN_ia64_tprel_base (info);
		    else
		      {
			r_addend += value - elfNN_ia64_dtprel_base (info);
			dynindx = 0;
		      }
		  }
		got_r_type = R_IA64_TPREL64LSB;
		break;
	      case R_IA64_LTOFF_DTPMOD22:
		if (!dynamic_symbol_p && !info->shared)
		  value = 1;
		got_r_type = R_IA64_DTPMOD64LSB;
		break;
	      case R_IA64_LTOFF_DTPREL22:
		if (!dynamic_symbol_p)
		  {
		    if (elf_hash_table (info)->tls_sec == NULL)
		      goto missing_tls_sec;
		    value -= elfNN_ia64_dtprel_base (info);
		  }
		got_r_type = R_IA64_DTPRELNNLSB;
		break;
	      }
	    dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
	    value = set_got_entry (input_bfd, info, dyn_i, dynindx, r_addend,
				   value, got_r_type);
	    value -= gp_val;
	    r = elfNN_ia64_install_value (hit_addr, value, r_type);
	  }
	  break;

	default:
	  r = bfd_reloc_notsupported;
	  break;
	}

      switch (r)
	{
	case bfd_reloc_ok:
	  break;

	case bfd_reloc_undefined:
	  /* This can happen for global table relative relocs if
	     __gp is undefined.  This is a panic situation so we
	     don't try to continue.  */
	  (*info->callbacks->undefined_symbol)
	    (info, "__gp", input_bfd, input_section, rel->r_offset, 1);
	  return FALSE;

	case bfd_reloc_notsupported:
	  {
	    const char *name;

	    if (h)
	      name = h->root.root.string;
	    else
	      name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym,
				       sym_sec);
	    if (!(*info->callbacks->warning) (info, _("unsupported reloc"),
					      name, input_bfd,
					      input_section, rel->r_offset))
	      return FALSE;
	    ret_val = FALSE;
	  }
	  break;

	case bfd_reloc_dangerous:
	case bfd_reloc_outofrange:
	case bfd_reloc_overflow:
	default:
missing_tls_sec:
	  {
	    const char *name;

	    if (h)
	      name = h->root.root.string;
	    else
	      name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym,
				       sym_sec);

	    switch (r_type)
	      {
	      case R_IA64_TPREL14:
	      case R_IA64_TPREL22:
	      case R_IA64_TPREL64I:
	      case R_IA64_DTPREL14:
	      case R_IA64_DTPREL22:
	      case R_IA64_DTPREL64I:
	      case R_IA64_DTPREL32LSB:
	      case R_IA64_DTPREL32MSB:
	      case R_IA64_DTPREL64LSB:
	      case R_IA64_DTPREL64MSB:
	      case R_IA64_LTOFF_TPREL22:
	      case R_IA64_LTOFF_DTPMOD22:
	      case R_IA64_LTOFF_DTPREL22:
		(*_bfd_error_handler)
		  (_("%B: missing TLS section for relocation %s against `%s' at 0x%lx in section `%A'."),
		   input_bfd, input_section, howto->name, name,
		   rel->r_offset);
		break;

	      case R_IA64_PCREL21B:
	      case R_IA64_PCREL21BI:
	      case R_IA64_PCREL21M:
	      case R_IA64_PCREL21F:
		if (is_elf_hash_table (info->hash))
		  {
		    /* Relaxtion is always performed for ELF output.
		       Overflow failures for those relocations mean
		       that the section is too big to relax.  */
		    (*_bfd_error_handler)
		      (_("%B: Can't relax br (%s) to `%s' at 0x%lx in section `%A' with size 0x%lx (> 0x1000000)."),
		       input_bfd, input_section, howto->name, name,
		       rel->r_offset, input_section->size);
		    break;
		  }
	      default:
		if (!(*info->callbacks->reloc_overflow) (info,
							 &h->root,
							 name,
							 howto->name,
							 (bfd_vma) 0,
							 input_bfd,
							 input_section,
							 rel->r_offset))
		  return FALSE;
		break;
	      }

	    ret_val = FALSE;
	  }
	  break;
	}
d672 1
a672 20
  return ret_val;
}

static bfd_boolean
elfNN_ia64_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym)
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  struct elfNN_ia64_dyn_sym_info *dyn_i;

  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return FALSE;

  dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, FALSE);

  /* Fill in the PLT data, if required.  */
  if (dyn_i && dyn_i->want_plt)
d674 4
a677 21
      Elf_Internal_Rela outrel;
      bfd_byte *loc;
      asection *plt_sec;
      bfd_vma plt_addr, pltoff_addr, gp_val, plt_index;

      gp_val = _bfd_get_gp_value (output_bfd);

      /* Initialize the minimal PLT entry.  */

      plt_index = (dyn_i->plt_offset - PLT_HEADER_SIZE) / PLT_MIN_ENTRY_SIZE;
      plt_sec = ia64_info->root.splt;
      loc = plt_sec->contents + dyn_i->plt_offset;

      memcpy (loc, plt_min_entry, PLT_MIN_ENTRY_SIZE);
      elfNN_ia64_install_value (loc, plt_index, R_IA64_IMM22);
      elfNN_ia64_install_value (loc+2, -dyn_i->plt_offset, R_IA64_PCREL21B);

      plt_addr = (plt_sec->output_section->vma
		  + plt_sec->output_offset
		  + dyn_i->plt_offset);
      pltoff_addr = set_pltoff_entry (output_bfd, info, dyn_i, plt_addr, TRUE);
d679 4
a682 4
      /* Initialize the FULL PLT entry, if needed.  */
      if (dyn_i->want_plt2)
	{
	  loc = plt_sec->contents + dyn_i->plt2_offset;
d684 6
a689 2
	  memcpy (loc, plt_full_entry, PLT_FULL_ENTRY_SIZE);
	  elfNN_ia64_install_value (loc, pltoff_addr - gp_val, R_IA64_IMM22);
d691 7
a697 7
	  /* Mark the symbol as undefined, rather than as defined in the
	     plt section.  Leave the value alone.  */
	  /* ??? We didn't redefine it in adjust_dynamic_symbol in the
	     first place.  But perhaps elflink.c did some for us.  */
	  if (!h->def_regular)
	    sym->st_shndx = SHN_UNDEF;
	}
d699 3
a701 7
      /* Create the dynamic relocation.  */
      outrel.r_offset = pltoff_addr;
      if (bfd_little_endian (output_bfd))
	outrel.r_info = ELFNN_R_INFO (h->dynindx, R_IA64_IPLTLSB);
      else
	outrel.r_info = ELFNN_R_INFO (h->dynindx, R_IA64_IPLTMSB);
      outrel.r_addend = 0;
d703 4
a706 17
      /* This is fun.  In the .IA_64.pltoff section, we've got entries
	 that correspond both to real PLT entries, and those that
	 happened to resolve to local symbols but need to be created
	 to satisfy @@pltoff relocations.  The .rela.IA_64.pltoff
	 relocations for the real PLT should come at the end of the
	 section, so that they can be indexed by plt entry at runtime.

	 We emitted all of the relocations for the non-PLT @@pltoff
	 entries during relocate_section.  So we can consider the
	 existing sec->reloc_count to be the base of the array of
	 PLT relocations.  */

      loc = ia64_info->rel_pltoff_sec->contents;
      loc += ((ia64_info->rel_pltoff_sec->reloc_count + plt_index)
	      * sizeof (ElfNN_External_Rela));
      bfd_elfNN_swap_reloca_out (output_bfd, &outrel, loc);
    }
d708 4
a711 5
  /* Mark some specially defined symbols as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || h == ia64_info->root.hgot
      || h == ia64_info->root.hplt)
    sym->st_shndx = SHN_ABS;
d713 4
a716 2
  return TRUE;
}
d718 5
a722 6
static bfd_boolean
elfNN_ia64_finish_dynamic_sections (bfd *abfd,
				    struct bfd_link_info *info)
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  bfd *dynobj;
d724 3
a726 183
  ia64_info = elfNN_ia64_hash_table (info);
  if (ia64_info == NULL)
    return FALSE;

  dynobj = ia64_info->root.dynobj;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      ElfNN_External_Dyn *dyncon, *dynconend;
      asection *sdyn, *sgotplt;
      bfd_vma gp_val;

      sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
      sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
      BFD_ASSERT (sdyn != NULL);
      dyncon = (ElfNN_External_Dyn *) sdyn->contents;
      dynconend = (ElfNN_External_Dyn *) (sdyn->contents + sdyn->size);

      gp_val = _bfd_get_gp_value (abfd);

      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;

	  bfd_elfNN_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    case DT_PLTGOT:
	      dyn.d_un.d_ptr = gp_val;
	      break;

	    case DT_PLTRELSZ:
	      dyn.d_un.d_val = (ia64_info->minplt_entries
				* sizeof (ElfNN_External_Rela));
	      break;

	    case DT_JMPREL:
	      /* See the comment above in finish_dynamic_symbol.  */
	      dyn.d_un.d_ptr = (ia64_info->rel_pltoff_sec->output_section->vma
				+ ia64_info->rel_pltoff_sec->output_offset
				+ (ia64_info->rel_pltoff_sec->reloc_count
				   * sizeof (ElfNN_External_Rela)));
	      break;

	    case DT_IA_64_PLT_RESERVE:
	      dyn.d_un.d_ptr = (sgotplt->output_section->vma
				+ sgotplt->output_offset);
	      break;

	    case DT_RELASZ:
	      /* Do not have RELASZ include JMPREL.  This makes things
		 easier on ld.so.  This is not what the rest of BFD set up.  */
	      dyn.d_un.d_val -= (ia64_info->minplt_entries
				 * sizeof (ElfNN_External_Rela));
	      break;
	    }

	  bfd_elfNN_swap_dyn_out (abfd, &dyn, dyncon);
	}

      /* Initialize the PLT0 entry.  */
      if (ia64_info->root.splt)
	{
	  bfd_byte *loc = ia64_info->root.splt->contents;
	  bfd_vma pltres;

	  memcpy (loc, plt_header, PLT_HEADER_SIZE);

	  pltres = (sgotplt->output_section->vma
		    + sgotplt->output_offset
		    - gp_val);

	  elfNN_ia64_install_value (loc+1, pltres, R_IA64_GPREL22);
	}
    }

  return TRUE;
}

/* ELF file flag handling:  */

/* Function to keep IA-64 specific file flags.  */
static bfd_boolean
elfNN_ia64_set_private_flags (bfd *abfd, flagword flags)
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */
static bfd_boolean
elfNN_ia64_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword out_flags;
  flagword in_flags;
  bfd_boolean ok = TRUE;

  /* Don't even pretend to support mixed-format linking.  */
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return FALSE;

  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flags;

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	{
	  return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				    bfd_get_mach (ibfd));
	}

      return TRUE;
    }

  /* Check flag compatibility.  */
  if (in_flags == out_flags)
    return TRUE;

  /* Output has EF_IA_64_REDUCEDFP set only if all inputs have it set.  */
  if (!(in_flags & EF_IA_64_REDUCEDFP) && (out_flags & EF_IA_64_REDUCEDFP))
    elf_elfheader (obfd)->e_flags &= ~EF_IA_64_REDUCEDFP;

  if ((in_flags & EF_IA_64_TRAPNIL) != (out_flags & EF_IA_64_TRAPNIL))
    {
      (*_bfd_error_handler)
	(_("%B: linking trap-on-NULL-dereference with non-trapping files"),
	 ibfd);

      bfd_set_error (bfd_error_bad_value);
      ok = FALSE;
    }
  if ((in_flags & EF_IA_64_BE) != (out_flags & EF_IA_64_BE))
    {
      (*_bfd_error_handler)
	(_("%B: linking big-endian files with little-endian files"),
	 ibfd);

      bfd_set_error (bfd_error_bad_value);
      ok = FALSE;
    }
  if ((in_flags & EF_IA_64_ABI64) != (out_flags & EF_IA_64_ABI64))
    {
      (*_bfd_error_handler)
	(_("%B: linking 64-bit files with 32-bit files"),
	 ibfd);

      bfd_set_error (bfd_error_bad_value);
      ok = FALSE;
    }
  if ((in_flags & EF_IA_64_CONS_GP) != (out_flags & EF_IA_64_CONS_GP))
    {
      (*_bfd_error_handler)
	(_("%B: linking constant-gp files with non-constant-gp files"),
	 ibfd);

      bfd_set_error (bfd_error_bad_value);
      ok = FALSE;
    }
  if ((in_flags & EF_IA_64_NOFUNCDESC_CONS_GP)
      != (out_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
    {
      (*_bfd_error_handler)
	(_("%B: linking auto-pic files with non-auto-pic files"),
	 ibfd);

      bfd_set_error (bfd_error_bad_value);
      ok = FALSE;
    }

  return ok;
}
a727 37
static bfd_boolean
elfNN_ia64_print_private_bfd_data (bfd *abfd, PTR ptr)
{
  FILE *file = (FILE *) ptr;
  flagword flags = elf_elfheader (abfd)->e_flags;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  fprintf (file, "private flags = %s%s%s%s%s%s%s%s\n",
	   (flags & EF_IA_64_TRAPNIL) ? "TRAPNIL, " : "",
	   (flags & EF_IA_64_EXT) ? "EXT, " : "",
	   (flags & EF_IA_64_BE) ? "BE, " : "LE, ",
	   (flags & EF_IA_64_REDUCEDFP) ? "REDUCEDFP, " : "",
	   (flags & EF_IA_64_CONS_GP) ? "CONS_GP, " : "",
	   (flags & EF_IA_64_NOFUNCDESC_CONS_GP) ? "NOFUNCDESC_CONS_GP, " : "",
	   (flags & EF_IA_64_ABSOLUTE) ? "ABSOLUTE, " : "",
	   (flags & EF_IA_64_ABI64) ? "ABI64" : "ABI32");

  _bfd_elf_print_private_bfd_data (abfd, ptr);
  return TRUE;
}

static enum elf_reloc_type_class
elfNN_ia64_reloc_type_class (const Elf_Internal_Rela *rela)
{
  switch ((int) ELFNN_R_TYPE (rela->r_info))
    {
    case R_IA64_REL32MSB:
    case R_IA64_REL32LSB:
    case R_IA64_REL64MSB:
    case R_IA64_REL64LSB:
      return reloc_class_relative;
    case R_IA64_IPLTMSB:
    case R_IA64_IPLTLSB:
      return reloc_class_plt;
    case R_IA64_COPY:
      return reloc_class_copy;
d729 1
a729 36
      return reloc_class_normal;
    }
}

static const struct bfd_elf_special_section elfNN_ia64_special_sections[] =
{
  { STRING_COMMA_LEN (".sbss"),  -1, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { STRING_COMMA_LEN (".sdata"), -1, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { NULL,                    0,   0, 0,            0 }
};

static bfd_boolean
elfNN_ia64_object_p (bfd *abfd)
{
  asection *sec;
  asection *group, *unwi, *unw;
  flagword flags;
  const char *name;
  char *unwi_name, *unw_name;
  bfd_size_type amt;

  if (abfd->flags & DYNAMIC)
    return TRUE;

  /* Flags for fake group section.  */
  flags = (SEC_LINKER_CREATED | SEC_GROUP | SEC_LINK_ONCE
	   | SEC_EXCLUDE);

  /* We add a fake section group for each .gnu.linkonce.t.* section,
     which isn't in a section group, and its unwind sections.  */
  for (sec = abfd->sections; sec != NULL; sec = sec->next)
    {
      if (elf_sec_group (sec) == NULL
	  && ((sec->flags & (SEC_LINK_ONCE | SEC_CODE | SEC_GROUP))
	      == (SEC_LINK_ONCE | SEC_CODE))
	  && CONST_STRNEQ (sec->name, ".gnu.linkonce.t."))
d731 4
a734 62
	  name = sec->name + 16;

	  amt = strlen (name) + sizeof (".gnu.linkonce.ia64unwi.");
	  unwi_name = bfd_alloc (abfd, amt);
	  if (!unwi_name)
	    return FALSE;

	  strcpy (stpcpy (unwi_name, ".gnu.linkonce.ia64unwi."), name);
	  unwi = bfd_get_section_by_name (abfd, unwi_name);

	  amt = strlen (name) + sizeof (".gnu.linkonce.ia64unw.");
	  unw_name = bfd_alloc (abfd, amt);
	  if (!unw_name)
	    return FALSE;

	  strcpy (stpcpy (unw_name, ".gnu.linkonce.ia64unw."), name);
	  unw = bfd_get_section_by_name (abfd, unw_name);

	  /* We need to create a fake group section for it and its
	     unwind sections.  */
	  group = bfd_make_section_anyway_with_flags (abfd, name,
						      flags);
	  if (group == NULL)
	    return FALSE;

	  /* Move the fake group section to the beginning.  */
	  bfd_section_list_remove (abfd, group);
	  bfd_section_list_prepend (abfd, group);

	  elf_next_in_group (group) = sec;

	  elf_group_name (sec) = name;
	  elf_next_in_group (sec) = sec;
	  elf_sec_group (sec) = group;

	  if (unwi)
	    {
	      elf_group_name (unwi) = name;
	      elf_next_in_group (unwi) = sec;
	      elf_next_in_group (sec) = unwi;
	      elf_sec_group (unwi) = group;
	    }

	   if (unw)
	     {
	       elf_group_name (unw) = name;
	       if (unwi)
		 {
		   elf_next_in_group (unw) = elf_next_in_group (unwi);
		   elf_next_in_group (unwi) = unw;
		 }
	       else
		 {
		   elf_next_in_group (unw) = sec;
		   elf_next_in_group (sec) = unw;
		 }
	       elf_sec_group (unw) = group;
	     }

	   /* Fake SHT_GROUP section header.  */
	  elf_section_data (group)->this_hdr.bfd_section = group;
	  elf_section_data (group)->this_hdr.sh_type = SHT_GROUP;
d736 2
a737 3
    }
  return TRUE;
}
d739 4
a742 6
static bfd_boolean
elfNN_ia64_hpux_vec (const bfd_target *vec)
{
  extern const bfd_target bfd_elfNN_ia64_hpux_big_vec;
  return (vec == & bfd_elfNN_ia64_hpux_big_vec);
}
d744 3
a746 34
static void
elfNN_hpux_post_process_headers (bfd *abfd,
				 struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr *i_ehdrp = elf_elfheader (abfd);

  i_ehdrp->e_ident[EI_OSABI] = get_elf_backend_data (abfd)->elf_osabi;
  i_ehdrp->e_ident[EI_ABIVERSION] = 1;
}

static bfd_boolean
elfNN_hpux_backend_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
					     asection *sec, int *retval)
{
  if (bfd_is_com_section (sec))
    {
      *retval = SHN_IA_64_ANSI_COMMON;
      return TRUE;
    }
  return FALSE;
}

static void
elfNN_hpux_backend_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED,
				      asymbol *asym)
{
  elf_symbol_type *elfsym = (elf_symbol_type *) asym;

  switch (elfsym->internal_elf_sym.st_shndx)
    {
    case SHN_IA_64_ANSI_COMMON:
      asym->section = bfd_com_section_ptr;
      asym->value = elfsym->internal_elf_sym.st_size;
      asym->flags &= ~BSF_GLOBAL;
a747 2
    }
}
d749 12
a760 13
#ifdef INCLUDE_IA64_VMS

static bfd_boolean
elfNN_vms_section_from_shdr (bfd *abfd,
			     Elf_Internal_Shdr *hdr,
			     const char *name,
			     int shindex)
{
  switch (hdr->sh_type)
    {
    case SHT_IA_64_VMS_TRACE:
    case SHT_IA_64_VMS_DEBUG:
    case SHT_IA_64_VMS_DEBUG_STR:
a761 3

    default:
      return elfNN_ia64_section_from_shdr (abfd, hdr, name, shindex);
d764 1
a764 240
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
    return FALSE;

  return TRUE;
}

static bfd_boolean
elfNN_vms_object_p (bfd *abfd)
{
  Elf_Internal_Ehdr *i_ehdrp = elf_elfheader (abfd);
  Elf_Internal_Phdr *i_phdr = elf_tdata (abfd)->phdr;
  unsigned int i;
  unsigned int num_text = 0;
  unsigned int num_data = 0;
  unsigned int num_rodata = 0;
  char name[16];

  if (!elfNN_ia64_object_p (abfd))
    return FALSE;

  for (i = 0; i < i_ehdrp->e_phnum; i++, i_phdr++)
    {
      /* Is there a section for this segment?  */
      bfd_vma base_vma = i_phdr->p_vaddr;
      bfd_vma limit_vma = base_vma + i_phdr->p_filesz;

      if (i_phdr->p_type != PT_LOAD)
	continue;

    again:
      while (base_vma < limit_vma)
	{
	  bfd_vma next_vma = limit_vma;
	  asection *nsec;
	  asection *sec;
	  flagword flags;
	  char *nname = NULL;

	  /* Find a section covering base_vma.  */
	  for (sec = abfd->sections; sec != NULL; sec = sec->next)
	    {
	      if ((sec->flags & (SEC_ALLOC | SEC_LOAD)) == 0)
		continue;
	      if (sec->vma <= base_vma && sec->vma + sec->size > base_vma)
		{
		  base_vma = sec->vma + sec->size;
		  goto again;
		}
	      if (sec->vma < next_vma && sec->vma + sec->size >= base_vma)
		next_vma = sec->vma;
	    }

	  /* No section covering [base_vma; next_vma).  Create a fake one.  */
	  flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS;
	  if (i_phdr->p_flags & PF_X)
	    {
	      flags |= SEC_CODE;
	      if (num_text++ == 0)
		nname = ".text";
	      else
		sprintf (name, ".text$%u", num_text);
	    }
	  else if ((i_phdr->p_flags & (PF_R | PF_W)) == PF_R)
	    {
	      flags |= SEC_READONLY;
	      sprintf (name, ".rodata$%u", num_rodata++);
	    }
	  else
	    {
	      flags |= SEC_DATA;
	      sprintf (name, ".data$%u", num_data++);
	    }

	  /* Allocate name.  */
	  if (nname == NULL)
	    {
	      size_t name_len = strlen (name) + 1;
	      nname = bfd_alloc (abfd, name_len);
	      if (nname == NULL)
		return FALSE;
	      memcpy (nname, name, name_len);
	    }

	  /* Create and fill new section.  */
	  nsec = bfd_make_section_anyway_with_flags (abfd, nname, flags);
	  if (nsec == NULL)
	    return FALSE;
	  nsec->vma = base_vma;
	  nsec->size = next_vma - base_vma;
	  nsec->filepos = i_phdr->p_offset + (base_vma - i_phdr->p_vaddr);
	  
	  base_vma = next_vma;
	}
    }
  return TRUE;
}

static void
elfNN_vms_post_process_headers (bfd *abfd,
				struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr *i_ehdrp = elf_elfheader (abfd);

  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_OPENVMS;
  i_ehdrp->e_ident[EI_ABIVERSION] = 2;
}

static bfd_boolean
elfNN_vms_section_processing (bfd *abfd ATTRIBUTE_UNUSED,
			      Elf_Internal_Shdr *hdr)
{
  if (hdr->bfd_section != NULL)
    {
      const char *name = bfd_get_section_name (abfd, hdr->bfd_section);

      if (strcmp (name, ".text") == 0)
	hdr->sh_flags |= SHF_IA_64_VMS_SHARED;
      else if ((strcmp (name, ".debug") == 0)
	    || (strcmp (name, ".debug_abbrev") == 0)
	    || (strcmp (name, ".debug_aranges") == 0)
	    || (strcmp (name, ".debug_frame") == 0)
	    || (strcmp (name, ".debug_info") == 0)
	    || (strcmp (name, ".debug_loc") == 0)
	    || (strcmp (name, ".debug_macinfo") == 0)
	    || (strcmp (name, ".debug_pubnames") == 0)
	    || (strcmp (name, ".debug_pubtypes") == 0))
	hdr->sh_type = SHT_IA_64_VMS_DEBUG;
      else if ((strcmp (name, ".debug_line") == 0)
	    || (strcmp (name, ".debug_ranges") == 0))
	hdr->sh_type = SHT_IA_64_VMS_TRACE;
      else if (strcmp (name, ".debug_str") == 0)
	hdr->sh_type = SHT_IA_64_VMS_DEBUG_STR;
      else if (strcmp (name, ".vms_display_name_info") == 0)
	{
	  int idx, symcount;
	  asymbol **syms;
	  struct elf_obj_tdata *t = elf_tdata (abfd);
	  int buf[2];
	  int demangler_sym_idx = -1;

	  symcount = bfd_get_symcount (abfd);
	  syms = bfd_get_outsymbols (abfd);
	  for (idx = 0; idx < symcount; idx++)
	    {
	      asymbol *sym;
	      sym = syms[idx];
	      if ((sym->flags & (BSF_DEBUGGING | BSF_DYNAMIC))
	          && strchr (sym->name, '@@')
		  && (strcmp (sym->section->name, BFD_ABS_SECTION_NAME) == 0))
		{
		  demangler_sym_idx = sym->udata.i;
		  break;
		}
	    }

	  hdr->sh_type = SHT_IA_64_VMS_DISPLAY_NAME_INFO;
	  hdr->sh_entsize = 4;
	  hdr->sh_addralign = 0;
	  hdr->sh_link = t->symtab_section;

	  /* Find symtab index of demangler routine and stuff it in
	     the second long word of section data.  */

	  if (demangler_sym_idx > -1)
	    {
	      bfd_seek (abfd, hdr->sh_offset, SEEK_SET);
	      bfd_bread (buf, hdr->sh_size, abfd);
	      buf [1] = demangler_sym_idx;
	      bfd_seek (abfd, hdr->sh_offset, SEEK_SET);
	      bfd_bwrite (buf, hdr->sh_size, abfd);
	    }
	}
    }

  return TRUE;
}

/* The final processing done just before writing out a VMS IA-64 ELF
   object file.  */

static void
elfNN_vms_final_write_processing (bfd *abfd,
				  bfd_boolean linker ATTRIBUTE_UNUSED)
{
  Elf_Internal_Shdr *hdr;
  asection *s;
  int unwind_info_sect_idx = 0;

  for (s = abfd->sections; s; s = s->next)
    {
      hdr = &elf_section_data (s)->this_hdr;

      if (strcmp (bfd_get_section_name (abfd, hdr->bfd_section),
		  ".IA_64.unwind_info") == 0)
	unwind_info_sect_idx = elf_section_data (s)->this_idx;

      switch (hdr->sh_type)
	{
	case SHT_IA_64_UNWIND:
	  /* VMS requires sh_info to point to the unwind info section.  */
          hdr->sh_info = unwind_info_sect_idx;
	  break;
	}
    }

  if (! elf_flags_init (abfd))
    {
      unsigned long flags = 0;

      if (abfd->xvec->byteorder == BFD_ENDIAN_BIG)
	flags |= EF_IA_64_BE;
      if (bfd_get_mach (abfd) == bfd_mach_ia64_elf64)
	flags |= EF_IA_64_ABI64;

      elf_elfheader(abfd)->e_flags = flags;
      elf_flags_init (abfd) = TRUE;
    }
}

static bfd_boolean
elfNN_vms_close_and_cleanup (bfd *abfd)
{
  if (bfd_get_format (abfd) == bfd_object)
    {
      long isize, irsize;

      if (elf_shstrtab (abfd) != NULL)
	_bfd_elf_strtab_free (elf_shstrtab (abfd));

      /* Pad to 8 byte boundary for IPF/VMS.  */
      isize = bfd_get_size (abfd);
      if ((irsize = isize/8*8) < isize)
	{
	  int ishort = (irsize + 8) - isize;
	  bfd_seek (abfd, isize, SEEK_SET);
	  bfd_bwrite (bfd_zmalloc (ishort), ishort, abfd);
	}
    }

  return _bfd_generic_close_and_cleanup (abfd);
a765 216
#endif /* INCLUDE_IA64_VMS */

#define TARGET_LITTLE_SYM		bfd_elfNN_ia64_little_vec
#define TARGET_LITTLE_NAME		"elfNN-ia64-little"
#define TARGET_BIG_SYM			bfd_elfNN_ia64_big_vec
#define TARGET_BIG_NAME			"elfNN-ia64-big"
#define ELF_ARCH			bfd_arch_ia64
#define ELF_TARGET_ID			IA64_ELF_DATA
#define ELF_MACHINE_CODE		EM_IA_64
#define ELF_MACHINE_ALT1		1999	/* EAS2.3 */
#define ELF_MACHINE_ALT2		1998	/* EAS2.2 */
#define ELF_MAXPAGESIZE			0x10000	/* 64KB */
#define ELF_COMMONPAGESIZE		0x4000	/* 16KB */

#define elf_backend_section_from_shdr \
	elfNN_ia64_section_from_shdr
#define elf_backend_section_flags \
	elfNN_ia64_section_flags
#define elf_backend_fake_sections \
	elfNN_ia64_fake_sections
#define elf_backend_final_write_processing \
	elfNN_ia64_final_write_processing
#define elf_backend_add_symbol_hook \
	elfNN_ia64_add_symbol_hook
#define elf_backend_additional_program_headers \
	elfNN_ia64_additional_program_headers
#define elf_backend_modify_segment_map \
	elfNN_ia64_modify_segment_map
#define elf_backend_modify_program_headers \
	elfNN_ia64_modify_program_headers
#define elf_info_to_howto \
	elfNN_ia64_info_to_howto

#define bfd_elfNN_bfd_reloc_type_lookup \
	elfNN_ia64_reloc_type_lookup
#define bfd_elfNN_bfd_reloc_name_lookup \
	elfNN_ia64_reloc_name_lookup
#define bfd_elfNN_bfd_is_local_label_name \
	elfNN_ia64_is_local_label_name
#define bfd_elfNN_bfd_relax_section \
	elfNN_ia64_relax_section

#define elf_backend_object_p \
	elfNN_ia64_object_p

/* Stuff for the BFD linker: */
#define bfd_elfNN_bfd_link_hash_table_create \
	elfNN_ia64_hash_table_create
#define bfd_elfNN_bfd_link_hash_table_free \
	elfNN_ia64_hash_table_free
#define elf_backend_create_dynamic_sections \
	elfNN_ia64_create_dynamic_sections
#define elf_backend_check_relocs \
	elfNN_ia64_check_relocs
#define elf_backend_adjust_dynamic_symbol \
	elfNN_ia64_adjust_dynamic_symbol
#define elf_backend_size_dynamic_sections \
	elfNN_ia64_size_dynamic_sections
#define elf_backend_omit_section_dynsym \
  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
#define elf_backend_relocate_section \
	elfNN_ia64_relocate_section
#define elf_backend_finish_dynamic_symbol \
	elfNN_ia64_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
	elfNN_ia64_finish_dynamic_sections
#define bfd_elfNN_bfd_final_link \
	elfNN_ia64_final_link

#define bfd_elfNN_bfd_merge_private_bfd_data \
	elfNN_ia64_merge_private_bfd_data
#define bfd_elfNN_bfd_set_private_flags \
	elfNN_ia64_set_private_flags
#define bfd_elfNN_bfd_print_private_bfd_data \
	elfNN_ia64_print_private_bfd_data

#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_plt_alignment	5
#define elf_backend_got_header_size	0
#define elf_backend_want_got_plt	1
#define elf_backend_may_use_rel_p	1
#define elf_backend_may_use_rela_p	1
#define elf_backend_default_use_rela_p	1
#define elf_backend_want_dynbss		0
#define elf_backend_copy_indirect_symbol elfNN_ia64_hash_copy_indirect
#define elf_backend_hide_symbol		elfNN_ia64_hash_hide_symbol
#define elf_backend_fixup_symbol	_bfd_elf_link_hash_fixup_symbol
#define elf_backend_reloc_type_class	elfNN_ia64_reloc_type_class
#define elf_backend_rela_normal		1
#define elf_backend_special_sections	elfNN_ia64_special_sections
#define elf_backend_default_execstack	0

/* FIXME: PR 290: The Intel C compiler generates SHT_IA_64_UNWIND with
   SHF_LINK_ORDER. But it doesn't set the sh_link or sh_info fields.
   We don't want to flood users with so many error messages. We turn
   off the warning for now. It will be turned on later when the Intel
   compiler is fixed.   */
#define elf_backend_link_order_error_handler NULL

#include "elfNN-target.h"

/* HPUX-specific vectors.  */

#undef  TARGET_LITTLE_SYM
#undef  TARGET_LITTLE_NAME
#undef  TARGET_BIG_SYM
#define TARGET_BIG_SYM                  bfd_elfNN_ia64_hpux_big_vec
#undef  TARGET_BIG_NAME
#define TARGET_BIG_NAME                 "elfNN-ia64-hpux-big"

/* These are HP-UX specific functions.  */

#undef  elf_backend_post_process_headers
#define elf_backend_post_process_headers elfNN_hpux_post_process_headers

#undef  elf_backend_section_from_bfd_section
#define elf_backend_section_from_bfd_section elfNN_hpux_backend_section_from_bfd_section

#undef elf_backend_symbol_processing
#define elf_backend_symbol_processing elfNN_hpux_backend_symbol_processing

#undef  elf_backend_want_p_paddr_set_to_zero
#define elf_backend_want_p_paddr_set_to_zero 1

#undef ELF_COMMONPAGESIZE
#undef ELF_OSABI
#define ELF_OSABI			ELFOSABI_HPUX

#undef  elfNN_bed
#define elfNN_bed elfNN_ia64_hpux_bed

#include "elfNN-target.h"

/* VMS-specific vectors.  */
#ifdef INCLUDE_IA64_VMS

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		bfd_elfNN_ia64_vms_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		"elfNN-ia64-vms"
#undef  TARGET_BIG_SYM
#undef  TARGET_BIG_NAME

/* These are VMS specific functions.  */

#undef  elf_backend_object_p
#define elf_backend_object_p elfNN_vms_object_p

#undef  elf_backend_section_from_shdr
#define elf_backend_section_from_shdr elfNN_vms_section_from_shdr

#undef  elf_backend_post_process_headers
#define elf_backend_post_process_headers elfNN_vms_post_process_headers

#undef  elf_backend_section_processing
#define elf_backend_section_processing elfNN_vms_section_processing

#undef  elf_backend_final_write_processing
#define elf_backend_final_write_processing elfNN_vms_final_write_processing

#undef  bfd_elfNN_close_and_cleanup
#define bfd_elfNN_close_and_cleanup elfNN_vms_close_and_cleanup

#undef  elf_backend_section_from_bfd_section

#undef  elf_backend_symbol_processing

#undef  elf_backend_want_p_paddr_set_to_zero

#undef ELF_OSABI
#define ELF_OSABI			ELFOSABI_OPENVMS

#undef  ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE			0x10000	/* 64KB */

#undef  elfNN_bed
#define elfNN_bed elfNN_ia64_vms_bed

/* Use VMS-style archives (in particular, don't use the standard coff
   archive format).  */
#define bfd_elfNN_archive_functions

#undef bfd_elfNN_archive_p
#define bfd_elfNN_archive_p _bfd_vms_lib_ia64_archive_p
#undef bfd_elfNN_write_archive_contents
#define bfd_elfNN_write_archive_contents _bfd_vms_lib_write_archive_contents
#undef bfd_elfNN_mkarchive
#define bfd_elfNN_mkarchive _bfd_vms_lib_ia64_mkarchive

#define bfd_elfNN_archive_slurp_armap \
  _bfd_vms_lib_slurp_armap
#define bfd_elfNN_archive_slurp_extended_name_table \
  _bfd_vms_lib_slurp_extended_name_table
#define bfd_elfNN_archive_construct_extended_name_table \
  _bfd_vms_lib_construct_extended_name_table
#define bfd_elfNN_archive_truncate_arname \
  _bfd_vms_lib_truncate_arname
#define bfd_elfNN_archive_write_armap \
  _bfd_vms_lib_write_armap
#define bfd_elfNN_archive_read_ar_hdr \
  _bfd_vms_lib_read_ar_hdr
#define bfd_elfNN_archive_write_ar_hdr \
  _bfd_vms_lib_write_ar_hdr
#define bfd_elfNN_archive_openr_next_archived_file \
  _bfd_vms_lib_openr_next_archived_file
#define bfd_elfNN_archive_get_elt_at_index \
  _bfd_vms_lib_get_elt_at_index
#define bfd_elfNN_archive_generic_stat_arch_elt \
  _bfd_vms_lib_generic_stat_arch_elt
#define bfd_elfNN_archive_update_armap_timestamp \
  _bfd_vms_lib_update_armap_timestamp

#include "elfNN-target.h"

#endif /* INCLUDE_IA64_VMS */
@


1.231
log
@2011-04-01  Tristan Gingold  <gingold@@adacore.com>

	* elfxx-ia64.c: include bfd_stdint.h
@
text
@d3 1
a3 1
   2008, 2009, 2010  Free Software Foundation, Inc.
d218 1
a218 1
  (bfd *abfd, struct bfd_link_info *info);
d1224 1
a1224 1
		  if (!elfNN_ia64_choose_gp (obfd, link_info))
d4301 1
a4301 1
elfNN_ia64_choose_gp (bfd *abfd, struct bfd_link_info *info)
d4324 6
a4329 1
      hi = os->vma + (os->rawsize ? os->rawsize : os->size);
d4470 1
a4470 1
      if (! elfNN_ia64_choose_gp (abfd, info))
@


1.230
log
@	Fix compilation for mingw64.
	* coffcode.h (coff_slurp_symbol_table): Add intptr_t intermediate
	typecast to avoid warning.
	* elf32-rx.c: Add "bfd_stdint.h" include required for int32_t type
	usage.
	* elfxx-ia64.c (elfNN_ia64_relax_br): Use intptr_t typeacast instead
	of long for pointer to avoid warning.
	(elfNN_ia64_relax_brl): Idem.
	(elfNN_ia64_install_value): Idem.
	* vms-alpha.c (_bfd_vms_slurp_etir): Idem.
@
text
@d31 1
@


1.230.2.1
log
@2011-04-01  Tristan Gingold  <gingold@@adacore.com>

	* elfxx-ia64.c: include bfd_stdint.h
@
text
@a30 1
#include "bfd_stdint.h"
@


1.229
log
@bfd/
	* hash.c (bfd_hash_hash): Extract from..
	(bfd_hash_lookup): ..here.
	(bfd_hash_rename): New function.
	* section.c (bfd_rename_section): New function.
	* bfd-in.h (bfd_hash_rename): Declare.
	* bfd-in2.h: Regenerate.
	* elf.c (_bfd_elf_make_section_from_shdr): Rename input sections
	when compressing or decompressing.  Don't assert name match.
	* elf64-hppa.c (get_reloc_section): Don't assert name match.
	* elfxx-ia64.c (get_reloc_section): Likewise.
binutils/
	* objcopy.c (copy_main): No need to rename sections when compressing
	or decompressing.
binutils/testsuite/
	* binutils-all/objdump.W: Adjust expected result for debug section
	rename.
@
text
@d639 1
a639 1
  br_slot = (long) hit_addr & 0x3;
d741 1
a741 1
  hit_addr -= (long) hit_addr & 0x3;
d3877 1
a3877 1
      hit_addr -= (long) hit_addr & 0x3;
d3906 1
a3906 1
      hit_addr -= (long) hit_addr & 0x3;
d3931 1
a3931 1
      switch ((long) hit_addr & 0x3)
@


1.228
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@a2604 7
  BFD_ASSERT ((CONST_STRNEQ (srel_name, ".rela")
	       && strcmp (bfd_get_section_name (abfd, sec),
			  srel_name+5) == 0)
	      || (CONST_STRNEQ (srel_name, ".rel")
		  && strcmp (bfd_get_section_name (abfd, sec),
			     srel_name+4) == 0));

@


1.228.2.1
log
@backport from mainline
@
text
@d2605 7
@


1.228.2.2
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d639 1
a639 1
  br_slot = (intptr_t) hit_addr & 0x3;
d741 1
a741 1
  hit_addr -= (intptr_t) hit_addr & 0x3;
d3877 1
a3877 1
      hit_addr -= (intptr_t) hit_addr & 0x3;
d3906 1
a3906 1
      hit_addr -= (intptr_t) hit_addr & 0x3;
d3931 1
a3931 1
      switch ((intptr_t) hit_addr & 0x3)
@


1.227
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@a4664 3
      /* For relocs against symbols from removed linkonce sections,
	 or sections discarded by a linker script, we just want the
	 section contents zeroed.  Avoid any special processing.  */
d4666 2
a4667 6
	{
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.226
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d2601 1
a2601 1
		elf_section_data(sec)->rel_hdr.sh_name));
@


1.225
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d4698 1
a4698 1
	      && r_symndx != 0
d4927 1
a4927 1
	  if (dynamic_symbol_p && r_symndx != 0)
@


1.224
log
@fix set but unused variable warnings
@
text
@d5999 1
@


1.223
log
@2010-06-08  Tristan Gingold  <gingold@@adacore.com>

	* vms-lib.c (_bfd_vms_lib_ia64_mkarchive): New function.
	* libbfd-in.h (_bfd_vms_lib_ia64_mkarchive): Declare.
	* libbfd.h: Regenerate.
	* elfxx-ia64.c (bfd_elfNN_write_archive_contents): Redefine for VMS.
	(bfd_elfNN_mkarchive): Ditto.
@
text
@a1411 2
  asection *newsect;

a1433 1
  newsect = hdr->bfd_section;
a5739 2
  asection *newsect;

a5752 1
  newsect = hdr->bfd_section;
@


1.222
log
@2010-05-14  Tristan Gingold  <gingold@@adacore.com>

	* vms-lib.c (_bfd_vms_lib_ia64_archive_p): New function.
	* libbfd-in.h (_bfd_vms_lib_ia64_archive_p): Add prototype.
	* libbfd.h: Regenerate.
	* configure.in (havevecs): Define HAVE_all_vecs when
	--enable-targets=all is set.  Use AC_SUBST on it.
	(tdefaults): Do not add havevecs.
	(bfd_elf64_ia64_vms_vec): Add vms-lib.lo and vms-misc.lo
	* configure: Regenerate.
	* Makefile.am (HAVEVECS): New variable.
	(INCLUDES): Add HAVEVECS.
	* Makefile.in: Regenerate.
	* elfxx-ia64.c (INCLUDE_IA64_VMS): New macro, defined if vms
	target is selected.  Add #ifdef/#endif around vms specific code.
	(bfd_elfNN_archive_p, bfd_elfNN_archive_slurp_armap,
	bfd_elfNN_archive_slurp_extended_name_table,
	bfd_elfNN_archive_construct_extended_name_table,
	bfd_elfNN_archive_truncate_arname,
	bfd_elfNN_archive_write_armap,
	bfd_elfNN_archive_read_ar_hdr,
	bfd_elfNN_archive_write_ar_hdr,
	bfd_elfNN_archive_openr_next_archived_file,
	bfd_elfNN_archive_get_elt_at_index,
	bfd_elfNN_archive_generic_stat_arch_elt,
	bfd_elfNN_archive_update_armap_timestamp): Define to use vms archives.
@
text
@d6182 4
@


1.221
log
@	* section.c (struct bfd_section): Delete has_tls_reloc,
	has_tls_get_addr_call, has_gp_reloc, need_finalize_relax, reloc_done.
	Add sec_flg0 thru sec_flg5.
	(BFD_FAKE_SECTION): Update for changed flags.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf32-ppc.c (has_tls_reloc, has_tls_get_addr_call): Define.
	* elf64-ppc.c (has_tls_reloc, has_tls_get_addr_call): Define.
	(has_toc_reloc, makes_toc_func_call, call_check_in_progress): Update.
	* elf32-xtensa.c (reloc_done): Define.
	* elfxx-ia64.c (skip_relax_pass_0, skip_relax_pass_1): Update.
	* bfd-in2.h: Regenerate.
@
text
@d70 9
d5735 2
d5998 1
d6132 1
d6176 30
d6207 2
@


1.220
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d758 2
a759 2
#define skip_relax_pass_0 need_finalize_relax
#define skip_relax_pass_1 has_gp_reloc
@


1.219
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2008, 2009  Free Software Foundation, Inc.
d73 1
a73 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d166 9
a174 9
  asection *fptr_sec;		/* function descriptor table (or NULL) */
  asection *rel_fptr_sec;	/* dynamic relocation section for same */
  asection *pltoff_sec;		/* private descriptors for plt (or NULL) */
  asection *rel_pltoff_sec;	/* dynamic relocation section for same */

  bfd_size_type minplt_entries;	/* number of minplt entries */
  unsigned reltext : 1;		/* are there relocs against readonly sections? */
  unsigned self_dtpmod_done : 1;/* has self DTPMOD entry been finished? */
  bfd_vma self_dtpmod_offset;	/* .got offset to self DTPMOD entry */
d179 4
a182 4
  asection *max_short_sec;	/* maximum short output section */
  bfd_vma max_short_offset;	/* maximum short offset */
  asection *min_short_sec;	/* minimum short output section */
  bfd_vma min_short_offset;	/* minimum short offset */
d196 2
a197 1
  ((struct elfNN_ia64_link_hash_table *) ((p)->hash))
d847 4
d855 1
a855 1
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
a859 1
  ia64_info = elfNN_ia64_hash_table (link_info);
d1891 1
a1891 1
static struct bfd_link_hash_table*
d1898 1
a1898 1
    return 0;
d1902 2
a1903 1
				      sizeof (struct elfNN_ia64_link_hash_entry)))
d1906 1
a1906 1
      return 0;
d1915 1
a1915 1
      return 0;
d2061 2
d2690 2
d3119 1
a3119 1
			  PTR data)
d3147 3
d3170 1
a3170 1
			  PTR data)
d3359 2
d3508 2
d4015 3
d4155 3
d4208 3
d4311 2
d4453 2
d4537 2
d5267 3
d5356 3
@


1.218
log
@2009-11-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10955
	* elfxx-ia64.c (elfNN_ia64_update_short_info): Also skip ABS
	sections.
@
text
@d1450 1
a1450 1
  register const char *name;
d2138 1
a2138 1
  unsigned int i, kept, dup, diff, dest, src, len;
d2203 1
a2203 1
	  for (dup = src + 1; dup < count; dup++)
d2205 1
a2205 1
	      curr = info [dup].addend;
d2210 1
a2210 1
		    got_offset = info [dup].got_offset;
d2215 1
a2215 1
		    info [dup - 1].got_offset = got_offset;
d2218 1
a2218 1
	      got_offset = info [dup].got_offset;
d2223 2
a2224 2
	  len = dup - src;
	  i = dup + 1;
d2226 1
a2226 1
	  if (len == 1 && dup < count)
d2231 1
a2231 1
	      for (diff = dup + 1, src++; diff < count; diff++, src++)
d2252 1
a2252 1
		  for (dup = diff + 1; dup < count; dup++)
d2254 1
a2254 1
		      curr = info [dup].addend;
d2260 1
a2260 1
			    got_offset = info [dup].got_offset;
d2263 1
a2263 1
		      got_offset = info [dup].got_offset;
d5244 1
a5244 1
      bfd_vma plt_addr, pltoff_addr, gp_val, index;
d5250 1
a5250 1
      index = (dyn_i->plt_offset - PLT_HEADER_SIZE) / PLT_MIN_ENTRY_SIZE;
d5255 1
a5255 1
      elfNN_ia64_install_value (loc, index, R_IA64_IMM22);
d5300 1
a5300 1
      loc += ((ia64_info->rel_pltoff_sec->reloc_count + index)
@


1.217
log
@2009-11-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10955
	* elfxx-ia64.c (elfNN_ia64_link_hash_table): Update comments.
	(elfNN_ia64_update_short_info): Remove "->output_section" from
	ia64_info->max_short_sec and ia64_info->min_short_sec.
	(elfNN_ia64_choose_gp): Likewise.
	(elfNN_ia64_relax_section): Pass tsec->output_section to
	elfNN_ia64_update_short_info.
@
text
@d767 3
a769 2
  /* Skip SHF_IA_64_SHORT sections.  */
  if (sec->flags & SEC_SMALL_DATA)
@


1.216
log
@2009-11-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10955
	* elfxx-ia64.c (elfNN_ia64_link_hash_table): Add max_short_sec,
	max_short_offset, min_short_sec and min_short_offset.
	(elfNN_ia64_update_short_info): New.
	(elfNN_ia64_relax_section): Update max_short_sec,
	max_short_offset, min_short_sec and min_short_offset.
	(elfNN_ia64_choose_gp): Use min_short_sec/max_short_sec if
	they are set.
@
text
@d179 1
a179 1
  asection *max_short_sec;	/* maximum short section */
d181 1
a181 1
  asection *min_short_sec;	/* minimum short section */
d785 1
a785 1
	   > ia64_info->max_short_sec->output_section->vma)
d791 1
a791 1
	   < ia64_info->min_short_sec->output_section->vma)
d1221 1
a1221 1
	    elfNN_ia64_update_short_info (tsec,
d1235 1
a1235 1
	      elfNN_ia64_update_short_info (tsec,
d4316 1
a4316 1
	  > (ia64_info->min_short_sec->output_section->vma
d4318 1
a4318 1
	min_short_vma = (ia64_info->min_short_sec->output_section->vma
d4321 1
a4321 1
	  < (ia64_info->max_short_sec->output_section->vma
d4323 1
a4323 1
	max_short_vma = (ia64_info->max_short_sec->output_section->vma
@


1.215
log
@update copyright dates
@
text
@d175 8
d763 35
d901 3
d1220 5
a1224 1
	  if (r_type == R_IA64_LTOFF22X)
d1234 4
d4313 14
d4344 3
a4346 1
      asection *got_sec = ia64_info->root.sgot;
d4348 6
a4353 7
      /* Start with just the address of the .got.  */
      if (got_sec)
	gp_val = got_sec->output_section->vma;
      else if (max_short_vma != 0)
	gp_val = min_short_vma;
      else if (max_vma - min_vma < 0x200000)
	gp_val = min_vma;
d4355 13
a4367 1
	gp_val = max_vma - 0x200000 + 8;
d4394 1
@


1.214
log
@2009-09-01  Tristan Gingold  <gingold@@adacore.com>

	* makefile.vms: Ported to Itanium VMS.  Remove useless variable and
	dependencies.  Reindent.
	* configure.com: Ported to Itanium VMS.  Now generates a build.com
	to build without make.  Add messages but make edit silent.
	* hosts/alphavms.h: Add a prototype for stpcpy.
	* vms.c: Add a missing include for Alpha VMS.
	* elfxx-ia64.c (ELF_OSABI): Define for OpenVMS.
@
text
@d3 1
a3 1
   2009  Free Software Foundation, Inc.
@


1.213
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d6034 3
@


1.212
log
@2009-06-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (ELF_LOCAL_SYMBOL_HASH): New.

	* elf32-i386.c (elf_i386_local_hash): Removed.
	(elf_i386_local_htab_hash): Use ELF_LOCAL_SYMBOL_HASH.
	(elf_i386_get_local_sym_hash): Likewise.

	* elf64-x86-64.c (elf64_x86_64_local_hash): Removed.
	(elf64_x86_64_local_htab_hash): Use ELF_LOCAL_SYMBOL_HASH.
	(elf64_x86_64_get_local_sym_hash): Likewise.
	* elfxx-ia64.c (elfNN_ia64_local_htab_hash): Likewise.
	(get_local_sym_hash): Likewise.
@
text
@d615 1
a615 1
  unsigned int template, mlx;
d629 1
a629 1
  template = t0 & 0x1e;
d645 1
a645 1
      if (!((template == 0x12				/* MBB */
d647 1
a647 1
	    || (template == 0x16			/* BBB */
d656 1
a656 1
      if (!((template == 0x10				/* MIB */
d658 1
a658 1
	    || (template == 0x12			/* MBB */
d660 1
a660 1
	    || (template == 0x16			/* BBB */
d663 1
a663 1
	    || (template == 0x18			/* MMB */
d665 1
a665 1
	    || (template == 0x1c			/* MFB */
d689 1
a689 1
  if (template == 0x16)
d718 1
a718 1
  int template;
d737 1
a737 1
    template = 0x13;
d739 2
a740 2
    template = 0x12;
  t0 = (i1 << 46) | (i0 << 5) | template;
@


1.211
log
@2009-06-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_link_hash_table): Remove got_sec,
	rel_got_sec and plt_sec.
	(elfNN_ia64_relax_section): Updated.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_got): Likewise.
	(allocate_dynrel_entries): Likewise.
	(elfNN_ia64_size_dynamic_sections): Likewise.
	(set_got_entry): Likewise.
	(elfNN_ia64_choose_gp): Likewise.
	(elfNN_ia64_relocate_section): Likewise.
	(elfNN_ia64_finish_dynamic_symbol): Likewise.
	(elfNN_ia64_finish_dynamic_sections): Likewise.
@
text
@d1812 1
a1812 2
  return (((entry->id & 0xff) << 24) | ((entry->id & 0xff00) << 8))
	  ^ entry->r_sym ^ (entry->id >> 16);
d2035 2
a2036 2
  hashval_t h = (((sec->id & 0xff) << 24) | ((sec->id & 0xff00) << 8))
		^ ELFNN_R_SYM (rel->r_info) ^ (sec->id >> 16);
@


1.210
log
@	bfd/
	* elf32-ppc.c (ppc_elf_relax_section): Work with a partial
	link.
	* bout.c (b_out_bfd_relax_section): Reject relocatable links.
	* elf32-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-avr.c (elf32_avr_relax_section): Likewise.
	* elf32-frv.c (elf32_avr_relax_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relax_section): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relax_section): Likewise.
	* reloc.c (bfd_generic_relax_section): Likewise.
	* reloc16.c (bfd_coff_reloc16_relax_section): Likewise.
	* vms.c (vms_bfd_relax_section): Likewise.

	ld/
	* ldmain.c (main): Don't reject --relax -r.
	* ld.texinfo (PowerPC ELF32): Document behaviour of relaxing
	partial links.

	ld/testsuite/
	* ld-powerpc/vxworks-relax-2.s: New.
	* ld-powerpc/vxworks-relax-2.rd: New.
	* ld-powerpc/powerpc.exp: Add it.
@
text
@a165 2
  asection *got_sec;		/* the linkage table section (or NULL) */
  asection *rel_got_sec;	/* dynamic relocation section for same */
a167 1
  asection *plt_sec;		/* the primary plt section (or NULL) */
d932 1
a932 1
	      tsec = ia64_info->plt_sec;
d1005 1
a1005 1
	  if (tsec == ia64_info->plt_sec)
d1076 1
a1076 1
	      if (tsec == ia64_info->plt_sec)
d1096 1
a1096 1
	      if (tsec == ia64_info->plt_sec)
d1250 1
a1250 1
      ia64_info->got_sec->size = data.ofs;
d1253 1
a1253 1
	  && ia64_info->rel_got_sec != NULL)
d1256 1
a1256 1
	  ia64_info->rel_got_sec->size = 0;
d1259 1
a1259 1
	    ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
a2002 3
  ia64_info->plt_sec = bfd_get_section_by_name (abfd, ".plt");
  ia64_info->got_sec = bfd_get_section_by_name (abfd, ".got");

d2004 3
a2006 2
    flagword flags = bfd_get_section_flags (abfd, ia64_info->got_sec);
    bfd_set_section_flags (abfd, ia64_info->got_sec, SEC_SMALL_DATA | flags);
d2008 1
a2008 1
    bfd_set_section_alignment (abfd, ia64_info->got_sec, 3);
a2024 11
  s = bfd_make_section_with_flags (abfd, ".rela.got",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_LINKER_CREATED
				    | SEC_READONLY));
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, LOG_SECTION_ALIGN))
    return FALSE;
  ia64_info->rel_got_sec = s;

d2405 1
a2405 1
  got = ia64_info->got_sec;
d2416 1
a2416 3
      got = bfd_get_section_by_name (dynobj, ".got");
      BFD_ASSERT (got);
      ia64_info->got_sec = got;
d3315 1
a3315 1
	ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
d3318 1
a3318 1
    ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
d3320 1
a3320 1
    ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
d3322 1
a3322 1
    ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
d3456 1
a3456 1
  if (ia64_info->got_sec)
d3462 1
a3462 1
      ia64_info->got_sec->size = data.ofs;
d3501 1
a3501 1
      ia64_info->plt_sec->size = data.ofs;
d3524 1
a3524 1
	ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
d3548 1
a3548 1
      if (sec == ia64_info->got_sec)
d3550 1
a3550 1
      else if (sec == ia64_info->rel_got_sec)
d3553 1
a3553 1
	    ia64_info->rel_got_sec = NULL;
d3573 1
a3573 1
      else if (sec == ia64_info->plt_sec)
d3576 1
a3576 1
	    ia64_info->plt_sec = NULL;
d3945 1
a3945 1
  got_sec = ia64_info->got_sec;
d4056 1
a4056 1
					ia64_info->rel_got_sec,
d4277 1
a4277 1
      asection *got_sec = ia64_info->got_sec;
d4830 2
a4831 2
	      value = (ia64_info->plt_sec->output_section->vma
		       + ia64_info->plt_sec->output_offset
d5169 1
a5169 1
      plt_sec = ia64_info->plt_sec;
d5298 1
a5298 1
      if (ia64_info->plt_sec)
d5300 1
a5300 1
	  bfd_byte *loc = ia64_info->plt_sec->contents;
@


1.209
log
@        * include/elf/ia64.h (SHT_IA_64_VMS_DISPLAY_NAME_INFO,
        EF_IA_64_ARCHVER_1): New macros. Minor reformatting.

        * bfd/Makefile.am (BFD32_BACKENDS): Add new object vmsutil.lo
        (BFD32_BACKENDS_CFILES): Add new file vmsutil.c
        (vmsutil.lo): Add dependency rule
        * bfd/Makefile.in: Regenerate
        * bfd/config.bfd (ia64*-*-*vms*): Add case.
        * bfd/configure.in (bfd_elf64_ia64_vms_vec): Add case.
        * bfd/configure: Regenerate
        * bfd/vmsutil.[ch]: New files
        * bfd/elf-bfd.h (struct bfd_elf_special_section): Change type of
        attr to bfd_vma.
        * bfd/elfxx-ia64.c (elfNN_vms_post_process_headers,
        elfNN_vms_section_processing, elfNN_vms_final_write_processing,
        elfNN_vms_close_and_cleanup, elfNN_vms_section_from_shdr,
        elfNN_vms_object_p): New functions
        * bfd/targets.c (bfd_elf64_ia64_vms_vec): New target.

        * gas/configure.tgt(ia64-*-*vms*): New target.
        * gas/dwarf2dbg.h (dwarf2_loc_mark_labels): Make extern.
        * gas/tc.h (md_number_to_chars): Declare iff undefined.
        * gas/config/obj-elf.c (obj_elf_change_section): Change type of
        arg attr to bfd_vma.
        (obj_elf_parse_section_letters): Return a bfd_vma. Change type of
        variables attr, md_attr to bfd_vma.
        (obj_elf_section_word): Likewise.
        (obj_elf_section): Change type of variable attr to bfd_vma
        * gas/config/obj-elf.h (obj_elf_change_section): Change type of
        arg attr to bfd_vma
        * gas/config/tc-ia64.c (bfdver.h,time.h): Include.
        (ia64_elf_section_letter): Now returns a bfd_vma.
        Handle VMS specific attributes.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (ia64_init): Don't turn on dependency checking for VMS.
        (ia64_target_format): Check for VMS flag bit.
        (do_alias): Hande decc$ functions.
        (get_vms_time): New function.
        (ia64_vms_note): New function.
        * gas/config/tc-ia64.h (ia64_elf_section_letter): Now returns a bfd_vma.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (tc_init_after_args): Define for VMS.
        * gas/config/tc-alpha.c (alpha_elf_section_letter): Return a bfd_vma.
        (alpha_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-alpha.h: Likewise.
        * gas/config/tc-i386.c (x86_64_section_letter): Return a bfd_vma.
        (x86_64_section_word): Return a bfd_vma.
        * gas/config/tc-i386.h: Likewise.
        * gas/config/tc-ip2k.c (ip2k_elf_section_flags): Change type of arg
        attr to bfd_vma.
        * gas/config/tc-ip2k.h: Likewise.
        * gas/config/tc-mep.c (mep_elf_section_letter): Return a bfd_vma.
        (mep_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-mep.h: Likewise.
        * gas/config/tc-ppc.c  (ppc_section_letter): Return a bfd_vma.
        (ppc_section_word): Return a bfd_vma.
        (ppc_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-ppc.h: Likewise.
        * gas/config/te-vms.h (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,
        DWAR2_FILE_TIME_NAME, DWARF2_FILE_SIZE_NAME, DWARF2_FILEN_NAME):
        New file with new macros
        * gas/dwarf2dbg.c (get_filenum, out_file_list): Default and call new
        macros.
@
text
@d789 4
@


1.208
log
@2008-12-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/7036
	* elfxx-ia64.c (elfNN_ia64_relax_section): Assume linker will
	always insert 32byte between the .plt and .text sections after
	the the first relaxation pass.
@
text
@d2 2
a3 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
d5621 261
d6014 33
d6048 8
@


1.207
log
@2008-03-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/5913
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Remove BFD_ASSERT.
	(elfNN_ia64_dtprel_base): Likewise.
	(elfNN_ia64_relocate_section): Go to missing_tls_sec if
	tls_sec is NULL before calling elfNN_ia64_tprel_base or
	elfNN_ia64_dtprel_base.  Report unsupported TLS relocations.
@
text
@d997 12
d1010 1
a1010 1
	  if ((bfd_signed_vma) (symaddr - reladdr) >= -0x1000000
@


1.206
log
@2007-12-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/5530
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Call
	_bfd_elf_find_segment_containing_section with output_bfd,
	instead of input_bfd.
@
text
@a4190 2

  BFD_ASSERT (tls_sec != NULL);
a4201 1
  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
d4971 2
d4984 2
d5004 2
d5023 5
a5027 1
		  value -= elfNN_ia64_dtprel_base (info);
d5078 1
d5090 19
@


1.205
log
@* elf.c (_bfd_elf_find_segment_containing_section): New function:
  Scan the segment map looking for the segment containing a
  specified function.
* elf-bfd.h: Prototype the new function.
* elf-hppa.h (elf_hppa_osec_to_segment): Delete.
  (elf_hppa_record_segment_addrs): Use new function.
* elf32-bfin.c (_bfdfdpic_osec_to_segment): Use new function.
* elf32-frv.c (_frvfdpic_osec_to_segment): Use new function.
* elf32-hppa.c (hppa_record_segment_addr): Use new function.
* elfxx-ia64.c (elfNN_ia64_relocate_section): Use new function.
@
text
@d4899 1
a4899 1
		(input_bfd, input_section->output_section);
@


1.204
log
@2007-12-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/5449
	* elf.c (rewrite_elf_program_header): Don't adjust p_paddr if
	p_paddr is set to 0.
	(copy_private_bfd_data): Call rewrite_elf_program_header if
	p_paddr is set to 0.

	* elfcode.h (elf_swap_phdr_out): Set p_paddr to 0 if needed.

	* elfxx-ia64.c (ELF_MAXPAGESIZE): Don't redefine it for HPUX.
@
text
@a4896 3
	      struct elf_segment_map *m;
	      Elf_Internal_Phdr *p;

d4898 2
a4899 12
	      for (m = elf_tdata (output_bfd)->segment_map,
		     p = elf_tdata (output_bfd)->phdr;
		   m != NULL;
		   m = m->next, p++)
		{
		  int i;
		  for (i = m->count - 1; i >= 0; i--)
		    if (m->sections[i] == input_section->output_section)
		      break;
		  if (i >= 0)
		    break;
		}
d4901 1
a4901 1
	      if (m == NULL)
@


1.203
log
@	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Warning fix.
@
text
@a5717 2
#undef  ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE                 0x1000  /* 4K */
@


1.202
log
@2007-08-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c: Convert to ISO C90 prototypes.
	(elfNN_hpux_backend_section_from_bfd_section): Make it static.
@
text
@d1470 2
a1471 1
elfNN_ia64_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
d1473 4
a1476 2
			    const char **namep, flagword *flagsp,
			    asection **secp, bfd_vma *valp)
@


1.201
log
@2007-08-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c: Remove trailing whitespace.
	* elfxx-ia64.c: Likewise.
@
text
@d193 10
a202 12
static bfd_reloc_status_type elfNN_ia64_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *sym, PTR data,
	   asection *input_section, bfd *output_bfd, char **error_message));
static reloc_howto_type * lookup_howto
  PARAMS ((unsigned int rtype));
static reloc_howto_type *elfNN_ia64_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type bfd_code));
static void elfNN_ia64_info_to_howto
  PARAMS ((bfd *abfd, arelent *bfd_reloc, Elf_Internal_Rela *elf_reloc));
static bfd_boolean elfNN_ia64_relax_section
  PARAMS((bfd *abfd, asection *sec, struct bfd_link_info *link_info,
	  bfd_boolean *again));
d204 1
a204 36
  PARAMS((bfd_byte *contents, bfd_vma off));
static bfd_boolean is_unwind_section_name
  PARAMS ((bfd *abfd, const char *));
static bfd_boolean elfNN_ia64_section_flags
  PARAMS ((flagword *, const Elf_Internal_Shdr *));
static bfd_boolean elfNN_ia64_fake_sections
  PARAMS ((bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec));
static void elfNN_ia64_final_write_processing
  PARAMS ((bfd *abfd, bfd_boolean linker));
static bfd_boolean elfNN_ia64_add_symbol_hook
  PARAMS ((bfd *abfd, struct bfd_link_info *info, Elf_Internal_Sym *sym,
	   const char **namep, flagword *flagsp, asection **secp,
	   bfd_vma *valp));
static bfd_boolean elfNN_ia64_is_local_label_name
  PARAMS ((bfd *abfd, const char *name));
static bfd_boolean elfNN_ia64_dynamic_symbol_p
  PARAMS ((struct elf_link_hash_entry *h, struct bfd_link_info *info, int));
static struct bfd_hash_entry *elfNN_ia64_new_elf_hash_entry
  PARAMS ((struct bfd_hash_entry *entry, struct bfd_hash_table *table,
	   const char *string));
static void elfNN_ia64_hash_copy_indirect
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
static void elfNN_ia64_hash_hide_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
static hashval_t elfNN_ia64_local_htab_hash PARAMS ((const void *));
static int elfNN_ia64_local_htab_eq PARAMS ((const void *ptr1,
					     const void *ptr2));
static struct bfd_link_hash_table *elfNN_ia64_hash_table_create
  PARAMS ((bfd *abfd));
static void elfNN_ia64_hash_table_free
  PARAMS ((struct bfd_link_hash_table *hash));
static bfd_boolean elfNN_ia64_global_dyn_sym_thunk
  PARAMS ((struct bfd_hash_entry *, PTR));
static int elfNN_ia64_local_dyn_sym_thunk
  PARAMS ((void **, PTR));
d206 3
a208 33
  PARAMS ((struct elfNN_ia64_link_hash_table *ia64_info,
	   bfd_boolean (*func) (struct elfNN_ia64_dyn_sym_info *, PTR),
	   PTR info));
static bfd_boolean elfNN_ia64_create_dynamic_sections
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
static struct elfNN_ia64_local_hash_entry * get_local_sym_hash
  PARAMS ((struct elfNN_ia64_link_hash_table *ia64_info,
	   bfd *abfd, const Elf_Internal_Rela *rel, bfd_boolean create));
static struct elfNN_ia64_dyn_sym_info * get_dyn_sym_info
  PARAMS ((struct elfNN_ia64_link_hash_table *ia64_info,
	   struct elf_link_hash_entry *h,
	   bfd *abfd, const Elf_Internal_Rela *rel, bfd_boolean create));
static asection *get_got
  PARAMS ((bfd *abfd, struct bfd_link_info *info,
	   struct elfNN_ia64_link_hash_table *ia64_info));
static asection *get_fptr
  PARAMS ((bfd *abfd, struct bfd_link_info *info,
	   struct elfNN_ia64_link_hash_table *ia64_info));
static asection *get_pltoff
  PARAMS ((bfd *abfd, struct bfd_link_info *info,
	   struct elfNN_ia64_link_hash_table *ia64_info));
static asection *get_reloc_section
  PARAMS ((bfd *abfd, struct elfNN_ia64_link_hash_table *ia64_info,
	   asection *sec, bfd_boolean create));
static bfd_boolean elfNN_ia64_check_relocs
  PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *sec,
	   const Elf_Internal_Rela *relocs));
static bfd_boolean elfNN_ia64_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *info, struct elf_link_hash_entry *h));
static long global_sym_index
  PARAMS ((struct elf_link_hash_entry *h));
static bfd_boolean allocate_fptr
  PARAMS ((struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data));
d210 1
a210 1
  PARAMS ((struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data));
d212 1
a212 1
  PARAMS ((struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data));
d214 3
a216 7
  PARAMS ((struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data));
static bfd_boolean allocate_pltoff_entries
  PARAMS ((struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data));
static bfd_boolean allocate_plt_entries
  PARAMS ((struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data));
static bfd_boolean allocate_plt2_entries
  PARAMS ((struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data));
d218 4
a221 55
  PARAMS ((struct elfNN_ia64_dyn_sym_info *dyn_i, PTR data));
static bfd_boolean elfNN_ia64_size_dynamic_sections
  PARAMS ((bfd *output_bfd, struct bfd_link_info *info));
static bfd_reloc_status_type elfNN_ia64_install_value
  PARAMS ((bfd_byte *hit_addr, bfd_vma val, unsigned int r_type));
static void elfNN_ia64_install_dyn_reloc
  PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *sec,
	   asection *srel, bfd_vma offset, unsigned int type,
	   long dynindx, bfd_vma addend));
static bfd_vma set_got_entry
  PARAMS ((bfd *abfd, struct bfd_link_info *info,
	   struct elfNN_ia64_dyn_sym_info *dyn_i, long dynindx,
	   bfd_vma addend, bfd_vma value, unsigned int dyn_r_type));
static bfd_vma set_fptr_entry
  PARAMS ((bfd *abfd, struct bfd_link_info *info,
	   struct elfNN_ia64_dyn_sym_info *dyn_i,
	   bfd_vma value));
static bfd_vma set_pltoff_entry
  PARAMS ((bfd *abfd, struct bfd_link_info *info,
	   struct elfNN_ia64_dyn_sym_info *dyn_i,
	   bfd_vma value, bfd_boolean));
static bfd_vma elfNN_ia64_tprel_base
  PARAMS ((struct bfd_link_info *info));
static bfd_vma elfNN_ia64_dtprel_base
  PARAMS ((struct bfd_link_info *info));
static int elfNN_ia64_unwind_entry_compare
  PARAMS ((const PTR, const PTR));
static bfd_boolean elfNN_ia64_choose_gp
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
static bfd_boolean elfNN_ia64_final_link
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
static bfd_boolean elfNN_ia64_relocate_section
  PARAMS ((bfd *output_bfd, struct bfd_link_info *info, bfd *input_bfd,
	   asection *input_section, bfd_byte *contents,
	   Elf_Internal_Rela *relocs, Elf_Internal_Sym *local_syms,
	   asection **local_sections));
static bfd_boolean elfNN_ia64_finish_dynamic_symbol
  PARAMS ((bfd *output_bfd, struct bfd_link_info *info,
	   struct elf_link_hash_entry *h, Elf_Internal_Sym *sym));
static bfd_boolean elfNN_ia64_finish_dynamic_sections
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
static bfd_boolean elfNN_ia64_set_private_flags
  PARAMS ((bfd *abfd, flagword flags));
static bfd_boolean elfNN_ia64_merge_private_bfd_data
  PARAMS ((bfd *ibfd, bfd *obfd));
static bfd_boolean elfNN_ia64_print_private_bfd_data
  PARAMS ((bfd *abfd, PTR ptr));
static enum elf_reloc_type_class elfNN_ia64_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean elfNN_ia64_hpux_vec
  PARAMS ((const bfd_target *vec));
static void elfNN_hpux_post_process_headers
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
bfd_boolean elfNN_hpux_backend_section_from_bfd_section
  PARAMS ((bfd *abfd, asection *sec, int *retval));
d228 4
a231 9
elfNN_ia64_reloc (abfd, reloc, sym, data, input_section,
		  output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc;
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d357 1
a357 2
lookup_howto (rtype)
     unsigned int rtype;
d380 2
a381 3
elfNN_ia64_reloc_type_lookup (abfd, bfd_code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type bfd_code;
d507 3
a509 4
elfNN_ia64_info_to_howto (abfd, bfd_reloc, elf_reloc)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *bfd_reloc;
     Elf_Internal_Rela *elf_reloc;
d759 3
a761 5
elfNN_ia64_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d1278 1
a1278 3
elfNN_ia64_relax_ldxmov (contents, off)
     bfd_byte *contents;
     bfd_vma off;
d1366 2
a1367 3
elfNN_ia64_section_flags (flags, hdr)
     flagword *flags;
     const Elf_Internal_Shdr *hdr;
d1379 2
a1380 4
elfNN_ia64_fake_sections (abfd, hdr, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf_Internal_Shdr *hdr;
     asection *sec;
d1431 2
a1432 3
elfNN_ia64_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d1470 4
a1473 8
elfNN_ia64_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
d1656 2
a1657 3
elfNN_ia64_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
d1665 2
a1666 4
elfNN_ia64_dynamic_symbol_p (h, info, r_type)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
     int r_type;
d1676 3
a1678 4
elfNN_ia64_new_elf_hash_entry (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d1704 3
a1706 3
elfNN_ia64_hash_copy_indirect (info, xdir, xind)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *xdir, *xind;
d1767 3
a1769 4
elfNN_ia64_hash_hide_symbol (info, xh, force_local)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *xh;
     bfd_boolean force_local;
d1791 1
a1791 2
elfNN_ia64_local_htab_hash (ptr)
     const void *ptr;
d1803 1
a1803 2
elfNN_ia64_local_htab_eq (ptr1, ptr2)
     const void *ptr1, *ptr2;
d1818 1
a1818 2
elfNN_ia64_hash_table_create (abfd)
     bfd *abfd;
d1894 1
a1894 2
elfNN_ia64_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
d1915 1
a1915 1
  bfd_boolean (*func) PARAMS ((struct elfNN_ia64_dyn_sym_info *, PTR));
d1920 2
a1921 3
elfNN_ia64_global_dyn_sym_thunk (xentry, xdata)
     struct bfd_hash_entry *xentry;
     PTR xdata;
d1942 1
a1942 3
elfNN_ia64_local_dyn_sym_thunk (slot, xdata)
     void **slot;
     PTR xdata;
d1960 3
a1962 4
elfNN_ia64_dyn_sym_traverse (ia64_info, func, data)
     struct elfNN_ia64_link_hash_table *ia64_info;
     bfd_boolean (*func) PARAMS ((struct elfNN_ia64_dyn_sym_info *, PTR));
     PTR data;
d1976 2
a1977 3
elfNN_ia64_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2027 3
a2029 5
get_local_sym_hash (ia64_info, abfd, rel, create)
     struct elfNN_ia64_link_hash_table *ia64_info;
     bfd *abfd;
     const Elf_Internal_Rela *rel;
     bfd_boolean create;
d2257 3
a2259 6
get_dyn_sym_info (ia64_info, h, abfd, rel, create)
     struct elfNN_ia64_link_hash_table *ia64_info;
     struct elf_link_hash_entry *h;
     bfd *abfd;
     const Elf_Internal_Rela *rel;
     bfd_boolean create;
d2396 2
a2397 4
get_got (abfd, info, ia64_info)
     bfd *abfd;
     struct bfd_link_info *info;
     struct elfNN_ia64_link_hash_table *ia64_info;
d2434 2
a2435 4
get_fptr (abfd, info, ia64_info)
     bfd *abfd;
     struct bfd_link_info *info;
     struct elfNN_ia64_link_hash_table *ia64_info;
d2488 2
a2489 4
get_pltoff (abfd, info, ia64_info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct elfNN_ia64_link_hash_table *ia64_info;
d2523 3
a2525 5
get_reloc_section (abfd, ia64_info, sec, create)
     bfd *abfd;
     struct elfNN_ia64_link_hash_table *ia64_info;
     asection *sec;
     bfd_boolean create;
d2596 3
a2598 5
elfNN_ia64_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d3054 2
a3055 3
allocate_global_data_got (dyn_i, data)
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     PTR data;
d3102 2
a3103 3
allocate_global_fptr_got (dyn_i, data)
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     PTR data;
d3120 2
a3121 3
allocate_local_got (dyn_i, data)
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     PTR data;
d3137 1
a3137 2
global_sym_index (h)
     struct elf_link_hash_entry *h;
d3156 1
a3156 3
allocate_fptr (dyn_i, data)
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     PTR data;
d3202 2
a3203 3
allocate_plt_entries (dyn_i, data)
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     PTR data;
d3239 2
a3240 3
allocate_plt2_entries (dyn_i, data)
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     PTR data;
d3266 2
a3267 3
allocate_pltoff_entries (dyn_i, data)
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     PTR data;
d3283 2
a3284 3
allocate_dynrel_entries (dyn_i, data)
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     PTR data;
d3399 2
a3400 3
elfNN_ia64_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct elf_link_hash_entry *h;
d3428 2
a3429 3
elfNN_ia64_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d3677 2
a3678 4
elfNN_ia64_install_value (hit_addr, v, r_type)
     bfd_byte *hit_addr;
     bfd_vma v;
     unsigned int r_type;
d3900 4
a3903 10
elfNN_ia64_install_dyn_reloc (abfd, info, sec, srel, offset, type,
			      dynindx, addend)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     asection *srel;
     bfd_vma offset;
     unsigned int type;
     long dynindx;
     bfd_vma addend;
d3933 4
a3936 8
set_got_entry (abfd, info, dyn_i, dynindx, addend, value, dyn_r_type)
     bfd *abfd;
     struct bfd_link_info *info;
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     long dynindx;
     bfd_vma addend;
     bfd_vma value;
     unsigned int dyn_r_type;
d4073 3
a4075 5
set_fptr_entry (abfd, info, dyn_i, value)
     bfd *abfd;
     struct bfd_link_info *info;
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     bfd_vma value;
d4123 3
a4125 6
set_pltoff_entry (abfd, info, dyn_i, value, is_plt)
     bfd *abfd;
     struct bfd_link_info *info;
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     bfd_vma value;
     bfd_boolean is_plt;
d4185 1
a4185 2
elfNN_ia64_tprel_base (info)
     struct bfd_link_info *info;
d4199 1
a4199 2
elfNN_ia64_dtprel_base (info)
     struct bfd_link_info *info;
d4212 1
a4212 3
elfNN_ia64_unwind_entry_compare (a, b)
     const PTR a;
     const PTR b;
d4224 1
a4224 3
elfNN_ia64_choose_gp (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d4340 1
a4340 3
elfNN_ia64_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d4409 8
a4416 10
elfNN_ia64_relocate_section (output_bfd, info, input_bfd, input_section,
			     contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d5130 4
a5133 5
elfNN_ia64_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d5218 2
a5219 3
elfNN_ia64_finish_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d5305 1
a5305 3
elfNN_ia64_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d5318 1
a5318 2
elfNN_ia64_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
d5406 1
a5406 3
elfNN_ia64_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
d5428 1
a5428 2
elfNN_ia64_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d5555 2
a5556 3
elfNN_hpux_post_process_headers (abfd, info)
	bfd *abfd;
	struct bfd_link_info *info ATTRIBUTE_UNUSED;
d5564 3
a5566 5
bfd_boolean
elfNN_hpux_backend_section_from_bfd_section (abfd, sec, retval)
	bfd *abfd ATTRIBUTE_UNUSED;
	asection *sec;
	int *retval;
@


1.200
log
@Switch sources over to use the GPL version 3
@
text
@d807 1
a807 1
  
d2518 1
a2518 1
      
d2971 1
a2971 1
     with the modified get_dyn_sym_info.  */ 
@


1.199
log
@bfd/

2007-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4590
	* elfxx-ia64.c (sort_dyn_sym_info): Keep the valid got_offset
	when removing duplicated entries.
	(get_dyn_sym_info): Initialize the got_offset field to -1.
	Update call to sort_dyn_sym_info.
	(elfNN_ia64_relocate_section): Call sort_dyn_sym_info to sort
	array of addend and remove duplicates.

ld/testsuite/

2007-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4590
	* ld-ia64/merge1.d: New.
	* ld-ia64/merge1.s: Likewise.
	* ld-ia64/merge2.d: Likewise.
	* ld-ia64/merge2.s: Likewise.
	* ld-ia64/merge3.d: Likewise.
	* ld-ia64/merge3.s: Likewise.
	* ld-ia64/merge4.d: Likewise.
	* ld-ia64/merge4.s: Likewise.
	* ld-ia64/merge5.d: Likewise.
	* ld-ia64/merge5.s: Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.198
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d2237 2
a2238 2
  bfd_vma curr, prev;
  unsigned int i, dup, diff, dest, src, len;
d2244 1
d2249 7
a2255 1
	break;
d2259 3
a2264 2
      /* We need to move a block of elements to here.  */
      dest = i++;
d2267 6
d2274 1
d2281 12
a2292 2
		if (info [src].addend != curr)
		  break;
d2300 1
a2300 1
	  /* Find the next duplicate.  */
d2302 1
d2307 12
a2318 1
		break;
d2329 2
a2330 1
		 one.  Find the next different one.  */
d2332 13
a2344 2
		if (info [diff].addend != curr)
		  break;
d2348 2
a2349 1
		  /* Find the next duplicate.  */
d2351 1
d2356 8
a2363 1
			break;
d2380 13
d2515 1
d4726 9
a4734 3
		  
		  qsort (loc_h->info, loc_h->count,
			 sizeof (*loc_h->info), addend_compare);
@


1.197
log
@	* elfxx-ia64.c (elf_backend_default_execstack): Define to 0.
@
text
@d22 1
a23 1
#include "sysdep.h"
@


1.196
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d5823 1
@


1.195
log
@2007-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3826
	* elf-bfd.h (elf_backend_data): Add elf_osabi.
	(_bfd_elf_set_osabi): New.

	* elf.c (_bfd_elf_set_osabi): New.

	* elf32-hppa.c (elf32_hppa_post_process_headers): Removed.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.
	(ELF_OSABI): Properly defined for each target.

	* elf32-i370.c (i370_elf_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf32-i386.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf_i386_post_process_headers): Set EI_OSABI with elf_osabi.

	* elf32-msp430.c (elf32_msp430_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-alpha.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf64_alpha_fbsd_post_process_headers): Set EI_OSABI with
	elf_osabi.

	* elf64-hppa.c (elf64_hppa_post_process_headers): Set EI_OSABI
	with elf_osabi.
	(ELF_OSABI): Properly defined for each target.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi for Linux.

	* elf64-sparc.c (elf64_sparc_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-x86-64.c (elf64_x86_64_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elfcode.h (elf_object_p): Match the ELFOSABI_NONE ELF target
	with any ELF target of the compatible machine for which we do not
	have a specific backend.

	* elfxx-ia64.c (elfNN_hpux_post_process_headers): Set EI_OSABI
	with elf_osabi.

	* elfxx-target.h (ELF_OSABI): Default to ELFOSABI_NONE.
	(elfNN_bed): Initialize elf_osabi with ELF_OSABI.
@
text
@d616 16
d5767 2
@


1.194
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d5684 1
a5684 1
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_HPUX;
d5841 2
@


1.193
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
a4559 1
      return TRUE;
d4608 2
a4609 1
	  if ((sym_sec->flags & SEC_MERGE)
d4663 14
a4767 6
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	  if (r_symndx == 0)
	    value = 0;

a5007 7
	  if (r_symndx == 0)
	    {
	      /* If the input section was discarded from the output, then
		 do nothing.  */
	      r = bfd_reloc_ok;
	    }
	  else
@


1.192
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d4754 6
@


1.191
log
@	* elfxx-ia64.c (addend_compare): Properly compute return value.
@
text
@d5765 2
@


1.190
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2212 1
a2212 1
  return x->addend - y->addend;
@


1.189
log
@bfd/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_link_hash_entry): Add a dynamic field.
	(bfd_elf_link_mark_dynamic_symbol): New.
	(SYMBOLIC_BIND): New.

	* elf32-i386.c (elf_i386_check_relocs): Replace info->symbolic
	with SYMBOLIC_BIND (info, h).
	(elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_check_relocs): Likewise.

	* elflink.c (bfd_elf_link_mark_dynamic_symbol): New.
	(bfd_elf_record_link_assignment): Call
	bfd_elf_link_mark_dynamic_symbol on new entry.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_export_symbol): Return if the symbol isn't exported.
	(_bfd_elf_fix_symbol_flags): Replace info->symbolic with
	SYMBOLIC_BIND (info, h).
	(_bfd_elf_dynamic_symbol_p): Likewise.
	(_bfd_elf_symbol_refs_local_p): Likewise.
	(bfd_elf_size_dynamic_sections): Updated.

include/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_elf_dynamic_list): New.
	(bfd_link_info): Add a dynamic field.

ld/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (CXX): Set to g++.
	(CXX_FOR_TARGET): Likewise.
	* Makefile.in: Regenerated.

	* NEWS: Mention --dynamic-list.

	* ld.texinfo: Document --dynamic-list.

	* ldgram.y: Support dynamic list.

	* ldlang.c (lang_process): Call lang_finalize_version_expr_head
	on link_info.dynamic if needed.
	(lang_append_dynamic_list): New.
	(lang_append_dynamic_list_cpp_typeinfo): New.
	* ldlang.h (lang_append_dynamic_list): Likewise.
	* ldlang.h (lang_append_dynamic_list_cpp_typeinfo): Likewise.

	* ldlex.h (input_enum): Add input_dynamic_list.
	* ldlex.l: Handle it.

	* ldmain.c (main): Initialize link_info.dynamic.

	* lexsup.c (option_values): Add OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.
	(ld_options): Add entries for OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.
	(parse_args): Handle OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.

ld/testsuite/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/dl1.c: New file.
	* ld-elf/dl1.list: Likewise.
	* ld-elf/dl1.out: Likewise.
	* ld-elf/dl1main.c: Likewise.
	* ld-elf/dl2.c: Likewise.
	* ld-elf/dl2.list: Likewise.
	* ld-elf/dl2a.out: Likewise.
	* ld-elf/dl2b.out: Likewise.
	* ld-elf/dl2main.c: Likewise.
	* ld-elf/dl2xxx.c: Likewise.
	* ld-elf/dl2xxx.list: Likewise.
	* ld-elf/dl3.cc: Likewise.
	* ld-elf/dl3.list: Likewise.
	* ld-elf/dl3a.out: Likewise.
	* ld-elf/dl3b.out: Likewise.
	* ld-elf/dl3header.h: Likewise.
	* ld-elf/dl3main.cc: Likewise.

	* ld-elf/shared.exp: Updated.

	* lib/ld-lib.exp (run_ld_link_exec_tests): Take an optional
	argument for source language. Use CC/CXX for link, depending
	on source language.
	(run_cc_link_tests): Likewise.
@
text
@d1427 1
a1427 3
is_unwind_section_name (abfd, name)
	bfd *abfd;
	const char *name;
a1428 2
  size_t len1, len2, len3;

d1433 3
a1435 6
  len1 = sizeof (ELF_STRING_ia64_unwind) - 1;
  len2 = sizeof (ELF_STRING_ia64_unwind_info) - 1;
  len3 = sizeof (ELF_STRING_ia64_unwind_once) - 1;
  return ((strncmp (name, ELF_STRING_ia64_unwind, len1) == 0
	   && strncmp (name, ELF_STRING_ia64_unwind_info, len2) != 0)
	  || strncmp (name, ELF_STRING_ia64_unwind_once, len3) == 0);
d2617 1
a2617 1
  BFD_ASSERT ((strncmp (srel_name, ".rela", 5) == 0
d2620 1
a2620 1
	      || (strncmp (srel_name, ".rel", 4) == 0
d3698 1
a3698 1
	  else if (strncmp (name, ".rel", 4) == 0)
d5565 3
a5567 3
  { ".sbss",  5, -1, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { ".sdata", 6, -1, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { NULL,        0, 0, 0,            0 }
d5594 1
a5594 1
	  && strncmp (sec->name, ".gnu.linkonce.t.", 16) == 0)
@


1.188
log
@	* elfxx-ia64.c (elfNN_ia64_choose_gp): Use rawsize if set.
@
text
@d2744 1
a2744 1
			      && (!info->symbolic
d2916 1
a2916 1
			      && (!info->symbolic
@


1.187
log
@	* elf-bfd.h (struct elf_backend_data): Add
	elf_backend_modify_program_headers.
	* elfxx-target.h (elf_backend_modify_program_headers): Define.
	(elfNN_bed): Init new field.
	* elf.c (elf_modify_segment_map): Remove comment.
	(assign_file_positions_for_load_sections): Only call
	elf_modify_segment_map for objcopy/strip.
	(assign_file_positions_except_relocs): Call
	elf_backend_modify_program_headers.
	* elf32-frv.c (elf32_frvfdpic_always_size_sections): Don't make
	.stack section.
	(elf32_frvfdpic_modify_segment_map): Delete.
	(elf32_frvfdpic_modify_program_headers): New.
	(elf_backend_modify_segment_map): Don't define.
	(elf_backend_modify_program_headers): Define.
	* elf32-bfin.c (elf32_bfinfdpic_always_size_sections): Don't make
	.stack section.
	(elf32_bfinfdpic_modify_segment_map): Delete.
	(elf32_bfinfdpic_modify_program_headers): New.
	(elf_backend_modify_segment_map): Don't define.
	(elf_backend_modify_program_headers): Define.
	* elfxx-ia64.c (elfNN_ia64_modify_program_headers): New function.
	Split out from..
	(elfNN_ia64_modify_segment_map): ..here.
	(elf_backend_modify_program_headers): Define.
@
text
@d4369 1
a4369 1
      hi = os->vma + os->size;
@


1.186
log
@bfd/
	* elf-bfd.h: Formatting.
	(_bfd_elf_map_sections_to_segments): Declare.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame_hdr): Don't
	clear program_header_size.
	* elf.c (get_program_header_size): Move.  Don't use or set saved
	program_header_size here.
	(elf_modify_segment_map): New function.  Split out from..
	(assign_file_positions_for_load_sections): ..here.  Assert
	header size is correct.  Remove dead code.
	(_bfd_elf_map_sections_to_segments): Rename from
	map_sections_to_segments.  Make global.  Use get_program_header_size
	when we need estimate of header size.  Call elf_modify_segment_map.
	Set program_header_size.
	(print_segment_map): Delete.
	(_bfd_elf_sizeof_headers): If segment_map available, get the
	actual size.
	* elf32-arm.c (elf32_arm_symbian_modify_segment_map): Make safe
	for calling more than once.
	* elf32-bfin.c (elf32_bfinfdpic_modify_segment_map): Likewise.
	* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
	* elf32-i370.c (elf_backend_add_symbol_hook): Delete.
	(elf_backend_additional_program_headers): Delete.
	(elf_backend_modify_segment_map): Delete.
	* elf64-hppa.c (elf64_hppa_modify_segment_map): Convert to ISO C.
	* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
	* doc/bfdint.texi: Delete SIZEOF_HEADERS difficulties.
ld/
	* Makefile.am (ELF_DEPS): Define.  Use in emul file deps.  Fix
	many ELF emul file deps that incorrectly said they needed elf32.em
	instead of generic.em.  Add genelf.em as required.
	* Makefile.in: Regenerate.
	* ldlang.c (lang_process): Call ldemul_finish before
	lang_check_section_addresses.
	* emulparams/arcelf.sh: Generic elf target needs genelf.
	* emulparams/d30v_e.sh: Likewise.
	* emulparams/d30v_o.sh: Likewise.
	* emulparams/d30velf.sh: Likewise.
	* emulparams/elf32_dlx.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32fr30.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32iq10.sh: Likewise.
	* emulparams/elf32iq2000.sh: Likewise.
	* emulparams/elf32mt.sh: Likewise.
	* emulparams/mn10200.sh: Likewise.
	* emulparams/or32.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/msp430all.sh: Likewise.  Extract common entries.
	* emulparams/pjlelf.sh: Include pjelf.sh.
	* emulparams/elf32frvfd.sh (EXTRA_EM_FILE): Unset.
	* emulparams/mn10300.sh (EXTRA_EM_FILE): Unset.
	* emultempl/elf-generic.em: New file.
	* emultempl/genelf.em: New file.
	* emultempl/elf32.em: Include elf-generic.em.
	(gld${EMULATION_NAME}_layout_sections_again): Delete.
	(gld${EMULATION_NAME}_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/hppaelf.em (hppaelf_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from hppaelf_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
	* emultempl/mmo.em: Correct comment.  Include elf-bfd.h and
	source elf-generic.em.
	(mmo_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from ppc_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
ld/testsuite/
	* ld-elf/eh1.d: Update for fewer program headers.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
@
text
@d1740 16
a1755 4
  /* Turn on PF_IA_64_NORECOV if needed.  This involves traversing all of
     the input sections for each output section in the segment and testing
     for SHF_IA_64_NORECOV on each.  */
  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
d1762 2
a1763 1
	    while (order)
d1771 1
a1771 1
			m->p_flags |= PF_IA_64_NORECOV;
d5744 2
@


1.185
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@a217 2
static bfd_boolean elfNN_ia64_modify_segment_map
  PARAMS ((bfd *, struct bfd_link_info *));
d1656 2
a1657 3
elfNN_ia64_modify_segment_map (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
@


1.184
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@a217 2
static int elfNN_ia64_additional_program_headers
  PARAMS ((bfd *abfd));
d1638 2
a1639 2
elfNN_ia64_additional_program_headers (abfd)
     bfd *abfd;
@


1.183
log
@2006-05-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (ELF_MAXPAGESIZE): Fix a typo in comment.
@
text
@d5720 1
d5828 1
@


1.182
log
@bfd/

2006-04-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Skip unneeded passes
	with the skip_relax_pass_0 and skip_relax_pass_1 bits in the
	section structure.

include/

2006-04-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Replace need_relax_finalize with
	relax_pass.

ld/

2006-04-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/ia64elf.em: Set link_info.relax_pass to 2. Remove
	link_info.need_relax_finalize.

	* ldlang.c (relax_sections): New.
	(lang_process): Use. Call relax_sections link_info.relax_pass
	times.

	* ldmain.c (main): Set link_info.relax_pass to 1. Remove
	link_info.need_relax_finalize.
@
text
@d5826 1
a5826 1
#define ELF_MAXPAGESIZE                 0x1000  /* 1K */
@


1.181
log
@2006-04-05  H.J. Lu  <hongjiu.lu@@intel.com>
	    James E Wilson  <wilson@@specifixinc.com>

	PR ld/2442
	* elfxx-ia64.c (elfNN_ia64_dyn_sym_info): Remove next.
	(elfNN_ia64_local_hash_entry): Add count, sorted_count and
	size.
	(elfNN_ia64_link_hash_entry): Likewise.
	(elfNN_ia64_new_elf_hash_entry): Initialize count, sorted_count
	and size.
	(elfNN_ia64_hash_copy_indirect): Updated elfNN_ia64_dyn_sym_info
	processing.
	(elfNN_ia64_hash_hide_symbol): Likewise.
	(elfNN_ia64_global_dyn_sym_thunk): Likewise.
	(elfNN_ia64_local_dyn_sym_thunk): Likewise.
	(elfNN_ia64_global_dyn_info_free): New function.
	(elfNN_ia64_local_dyn_info_free): Likewise.
	(elfNN_ia64_hash_table_free): Free local and global
	elfNN_ia64_dyn_sym_info.
	(addend_compare): New function.
	(sort_dyn_sym_info): Likewise.
	(get_dyn_sym_info): Updated to use binary search for addend.
	(elfNN_ia64_check_relocs): Scan relocations to create dynamic
	relocation arrays first.
@
text
@d866 6
d900 2
d913 1
a913 1
     the relax finalize pass.  */
d916 2
a917 2
      || (!link_info->need_relax_finalize
	  && sec->need_finalize_relax == 0))
d958 2
a959 3
	  /* In the finalize pass, all br relaxations are done. We can
	     skip it. */
	  if (!link_info->need_relax_finalize)
d961 1
d966 3
a968 4
	  /* We can't optimize brl to br before the finalize pass since
	     br relaxations will increase the code size. Defer it to
	     the finalize pass.  */
	  if (link_info->need_relax_finalize)
d970 1
a970 1
	      sec->need_finalize_relax = 1;
d978 3
a980 4
	  /* We can't relax ldx/mov before the finalize pass since
	     br relaxations will increase the code size. Defer it to
	     the finalize pass.  */
	  if (link_info->need_relax_finalize)
d982 1
a982 1
	      sec->need_finalize_relax = 1;
d1372 6
a1377 2
  if (!link_info->need_relax_finalize)
    sec->need_finalize_relax = 0;
d1393 2
@


1.180
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@a82 3
  /* Next addend in the list.  */
  struct elfNN_ia64_dyn_sym_info *next;

d133 7
d150 7
d1813 3
d1846 9
a1854 1
      struct elfNN_ia64_dyn_sym_info **pdyn;
a1855 4
      pdyn = &dir->info;
      while ((dyn_i = *pdyn) != NULL)
	pdyn = &dyn_i->next;
      *pdyn = dyn_i = ind->info;
d1857 3
d1862 3
a1864 1
      for (; dyn_i; dyn_i = dyn_i->next)
d1890 1
d1896 3
a1898 1
  for (dyn_i = h->info; dyn_i; dyn_i = dyn_i->next)
d1966 45
d2020 5
a2024 1
    htab_delete (ia64_info->loc_hash_table);
d2027 2
d2050 1
d2055 3
a2057 1
  for (dyn_i = entry->info; dyn_i; dyn_i = dyn_i->next)
d2073 1
d2075 3
a2077 1
  for (dyn_i = entry->info; dyn_i; dyn_i = dyn_i->next)
d2079 2
a2080 2
      return 0;
  return 1;
d2189 108
d2298 14
a2311 1
   vary based on global or local symbol, and the addend to the reloc.  */
d2321 3
a2323 2
  struct elfNN_ia64_dyn_sym_info **pp;
  struct elfNN_ia64_dyn_sym_info *dyn_i;
d2325 1
d2328 9
a2336 1
    pp = &((struct elfNN_ia64_link_hash_entry *)h)->info;
d2348 72
a2419 1
      pp = &loc_h->info;
d2421 10
d2432 13
a2444 2
  for (dyn_i = *pp; dyn_i && dyn_i->addend != addend; dyn_i = *pp)
    pp = &dyn_i->next;
d2446 3
a2448 6
  if (dyn_i == NULL && create)
    {
      dyn_i = ((struct elfNN_ia64_dyn_sym_info *)
	       bfd_zalloc (abfd, (bfd_size_type) sizeof *dyn_i));
      *pp = dyn_i;
      dyn_i->addend = addend;
d2674 17
d2701 4
d2707 11
a2717 13
      enum {
	NEED_GOT = 1,
	NEED_GOTX = 2,
	NEED_FPTR = 4,
	NEED_PLTOFF = 8,
	NEED_MIN_PLT = 16,
	NEED_FULL_PLT = 32,
	NEED_DYNREL = 64,
	NEED_LTOFF_FPTR = 128,
	NEED_TPREL = 256,
	NEED_DTPMOD = 512,
	NEED_DTPREL = 1024
      };
d2719 153
a2871 2
      struct elf_link_hash_entry *h = NULL;
      unsigned long r_symndx = ELFNN_R_SYM (rel->r_info);
a2872 2
      int need_entry;
      bfd_boolean maybe_dynamic;
d2875 1
d2888 2
d2895 5
a2899 7
      maybe_dynamic = FALSE;
      if (h && ((!info->executable
		 && (!info->symbolic
		     || info->unresolved_syms_in_shared_libs == RM_IGNORE))
		|| !h->def_regular
		|| h->root.type == bfd_link_hash_defweak))
	maybe_dynamic = TRUE;
a2982 6
	  else
	    {
	      (*info->callbacks->warning)
		(info, _("@@pltoff reloc against local symbol"), 0,
		 abfd, 0, (bfd_vma) 0);
	    }
d3031 1
a3031 9
      if ((need_entry & NEED_FPTR) != 0
	  && rel->r_addend)
	{
	  (*info->callbacks->warning)
	    (info, _("non-zero addend in @@fptr reloc"), 0,
	     abfd, 0, (bfd_vma) 0);
	}

      dyn_i = get_dyn_sym_info (ia64_info, h, abfd, rel, TRUE);
d4606 1
d4608 3
a4610 1
		  for (dynent = loc_h->info; dynent; dynent = dynent->next)
d4625 4
@


1.180.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d83 3
a135 7
  /* The number of elements in elfNN_ia64_dyn_sym_info array.  */
  unsigned int count;
  /* The number of sorted elements in elfNN_ia64_dyn_sym_info array.  */
  unsigned int sorted_count;
  /* The size of elfNN_ia64_dyn_sym_info array.  */
  unsigned int size;
  /* The array of elfNN_ia64_dyn_sym_info.  */
a145 7
  /* The number of elements in elfNN_ia64_dyn_sym_info array.  */
  unsigned int count;
  /* The number of sorted elements in elfNN_ia64_dyn_sym_info array.  */
  unsigned int sorted_count;
  /* The size of elfNN_ia64_dyn_sym_info array.  */
  unsigned int size;
  /* The array of elfNN_ia64_dyn_sym_info.  */
a854 6

/* Rename some of the generic section flags to better document how they
   are used here.  */
#define skip_relax_pass_0 need_finalize_relax
#define skip_relax_pass_1 has_gp_reloc

a882 2
  bfd_boolean skip_relax_pass_0 = TRUE;
  bfd_boolean skip_relax_pass_1 = TRUE;
d894 1
a894 1
     the current pass.  */
d897 2
a898 2
      || (link_info->relax_pass == 0 && sec->skip_relax_pass_0)
      || (link_info->relax_pass == 1 && sec->skip_relax_pass_1))
d939 3
a941 2
	  /* In pass 1, all br relaxations are done. We can skip it. */
	  if (link_info->relax_pass == 1)
a942 1
	  skip_relax_pass_0 = FALSE;
d947 4
a950 3
	  /* We can't optimize brl to br in pass 0 since br relaxations
	     will increase the code size. Defer it to pass 1.  */
	  if (link_info->relax_pass == 0)
d952 1
a952 1
	      skip_relax_pass_1 = FALSE;
d960 4
a963 3
	  /* We can't relax ldx/mov in pass 0 since br relaxations will
	     increase the code size. Defer it to pass 1.  */
	  if (link_info->relax_pass == 0)
d965 1
a965 1
	      skip_relax_pass_1 = FALSE;
d1355 2
a1356 6
  if (link_info->relax_pass == 0)
    {
      /* Pass 0 is only needed to relax br.  */
      sec->skip_relax_pass_0 = skip_relax_pass_0;
      sec->skip_relax_pass_1 = skip_relax_pass_1;
    }
a1371 2
#undef skip_relax_pass_0
#undef skip_relax_pass_1
a1801 3
  ret->count = 0;
  ret->sorted_count = 0;
  ret->size = 0;
d1832 1
a1832 9
      unsigned int count;

      if (dir->info)
	free (dir->info);

      dir->info = ind->info;
      dir->count = ind->count;
      dir->sorted_count = ind->sorted_count;
      dir->size = ind->size;
d1834 4
a1838 3
      ind->count = 0;
      ind->sorted_count = 0;
      ind->size = 0;
d1841 1
a1841 3
      for (count = dir->count, dyn_i = dir->info;
	   count != 0;
	   count--, dyn_i++)
a1866 1
  unsigned int count;
d1872 1
a1872 3
  for (count = h->count, dyn_i = h->info;
       count != 0;
       count--, dyn_i++)
a1939 45
/* Free the global elfNN_ia64_dyn_sym_info array.  */

static bfd_boolean
elfNN_ia64_global_dyn_info_free (void **xentry,
				PTR unused ATTRIBUTE_UNUSED)
{
  struct elfNN_ia64_link_hash_entry *entry
    = (struct elfNN_ia64_link_hash_entry *) xentry;

  if (entry->root.root.type == bfd_link_hash_warning)
    entry = (struct elfNN_ia64_link_hash_entry *) entry->root.root.u.i.link;

  if (entry->info)
    {
      free (entry->info);
      entry->info = NULL;
      entry->count = 0;
      entry->sorted_count = 0;
      entry->size = 0;
    }

  return TRUE;
}

/* Free the local elfNN_ia64_dyn_sym_info array.  */

static bfd_boolean
elfNN_ia64_local_dyn_info_free (void **slot,
				PTR unused ATTRIBUTE_UNUSED)
{
  struct elfNN_ia64_local_hash_entry *entry
    = (struct elfNN_ia64_local_hash_entry *) *slot;

  if (entry->info)
    {
      free (entry->info);
      entry->info = NULL;
      entry->count = 0;
      entry->sorted_count = 0;
      entry->size = 0;
    }

  return TRUE;
}

d1949 1
a1949 5
    {
      htab_traverse (ia64_info->loc_hash_table,
		     elfNN_ia64_local_dyn_info_free, NULL);
      htab_delete (ia64_info->loc_hash_table);
    }
a1951 2
  elf_link_hash_traverse (&ia64_info->root,
			  elfNN_ia64_global_dyn_info_free, NULL);
a1972 1
  unsigned int count;
d1977 1
a1977 3
  for (count = entry->count, dyn_i = entry->info;
       count != 0;
       count--, dyn_i++)
a1992 1
  unsigned int count;
d1994 1
a1994 3
  for (count = entry->count, dyn_i = entry->info;
       count != 0;
       count--, dyn_i++)
d1996 2
a1997 2
      return FALSE;
  return TRUE;
a2105 108
/* Used to sort elfNN_ia64_dyn_sym_info array.  */

static int
addend_compare (const void *xp, const void *yp)
{
  const struct elfNN_ia64_dyn_sym_info *x
    = (const struct elfNN_ia64_dyn_sym_info *) xp;
  const struct elfNN_ia64_dyn_sym_info *y
    = (const struct elfNN_ia64_dyn_sym_info *) yp;

  return x->addend - y->addend;
}

/* Sort elfNN_ia64_dyn_sym_info array and remove duplicates.  */

static unsigned int
sort_dyn_sym_info (struct elfNN_ia64_dyn_sym_info *info,
		   unsigned int count)
{
  bfd_vma curr, prev;
  unsigned int i, dup, diff, dest, src, len;

  qsort (info, count, sizeof (*info), addend_compare);

  /* Find the first duplicate.  */
  prev = info [0].addend;
  for (i = 1; i < count; i++)
    {
      curr = info [i].addend;
      if (curr == prev)
	break;
      prev = curr;
    }

  /* Remove duplicates.  */
  if (i < count)
    {
      /* We need to move a block of elements to here.  */
      dest = i++;
      while (i < count)
	{
	  curr = info [i].addend;

	  /* Move a block of elements whose first one is different from
	     the previous.  */
	  if (curr == prev)
	    {
	      for (src = i + 1; src < count; src++)
		if (info [src].addend != curr)
		  break;
	    }
	  else
	    src = i;

	  if (src >= count)
	    break;

	  /* Find the next duplicate.  */
	  prev = info [src].addend;
	  for (dup = src + 1; dup < count; dup++)
	    {
	      curr = info [dup].addend;
	      if (curr == prev)
		break;
	      prev = curr;
	    }

	  /* How much to move.  */
	  len = dup - src;
	  i = dup + 1;

	  if (len == 1 && dup < count)
	    {
	      /* If we only move 1 element, we combine it with the next
		 one.  Find the next different one.  */
	      for (diff = dup + 1, src++; diff < count; diff++, src++)
		if (info [diff].addend != curr)
		  break;

	      if (diff < count)
		{
		  /* Find the next duplicate.  */
		  prev = info [diff].addend;
		  for (dup = diff + 1; dup < count; dup++)
		    {
		      curr = info [dup].addend;
		      if (curr == prev)
			break;
		      prev = curr;
		      diff++;
		    }

		  len = diff - src + 1;
		  i = diff + 1;
		}
	    }

	  memmove (&info [dest], &info [src], len * sizeof (*info));

	  dest += len;
	}

      count = dest;
    }

  return count;
}

d2107 1
a2107 14
   vary based on global or local symbol, and the addend to the reloc.

   We don't sort when inserting.  Also, we sort and eliminate
   duplicates if there is an unsorted section.  Typically, this will
   only happen once, because we do all insertions before lookups.  We
   then use bsearch to do a lookup.  This also allows lookups to be
   fast.  So we have fast insertion (O(log N) due to duplicate check),
   fast lookup (O(log N)) and one sort (O(N log N) expected time).
   Previously, all lookups were O(N) because of the use of the linked
   list and also all insertions were O(N) because of the check for
   duplicates.  There are some complications here because the array
   size grows occasionally, which may add an O(N) factor, but this
   should be rare.  Also,  we free the excess array allocation, which
   requires a copy which is O(N), but this only happens once.  */
d2117 2
a2118 3
  struct elfNN_ia64_dyn_sym_info **info_p, *info, *dyn_i, key;
  unsigned int *count_p, *sorted_count_p, *size_p;
  unsigned int count, sorted_count, size;
a2119 1
  bfd_size_type amt;
d2122 1
a2122 9
    {
      struct elfNN_ia64_link_hash_entry *global_h;

      global_h = (struct elfNN_ia64_link_hash_entry *) h;
      info_p = &global_h->info;
      count_p = &global_h->count;
      sorted_count_p = &global_h->sorted_count;
      size_p = &global_h->size;
    }
d2134 2
a2135 24
      info_p = &loc_h->info;
      count_p = &loc_h->count;
      sorted_count_p = &loc_h->sorted_count;
      size_p = &loc_h->size;
    }

  count = *count_p;
  sorted_count = *sorted_count_p;
  size = *size_p;
  info = *info_p;
  if (create)
    {
      /* When we create the array, we don't check for duplicates,
         except in the previously sorted section if one exists, and
	 against the last inserted entry.  This allows insertions to
	 be fast.  */
      if (info)
	{
	  if (sorted_count)
	    {
	      /* Try bsearch first on the sorted section.  */
	      key.addend = addend;
	      dyn_i = bsearch (&key, info, sorted_count,
			       sizeof (*info), addend_compare);
d2137 2
a2138 5
	      if (dyn_i)
		{
		  return dyn_i;
		}
	    }
d2140 5
a2144 36
	  /* Do a quick check for the last inserted entry.  */
	  dyn_i = info + count - 1;
	  if (dyn_i->addend == addend)
	    {
	      return dyn_i;
	    }
	}

      if (size == 0)
	{
	  /* It is the very first element. We create the array of size
	     1.  */
	  size = 1;
	  amt = size * sizeof (*info);
	  info = bfd_malloc (amt);
	}
      else if (size <= count)
	{
	  /* We double the array size every time when we reach the
	     size limit.  */
	  size += size;
	  amt = size * sizeof (*info);
	  info = bfd_realloc (info, amt);
	}
      else
	goto has_space;

      if (info == NULL)
	return NULL;
      *size_p = size;
      *info_p = info;

has_space:
      /* Append the new one to the array.  */
      dyn_i = info + count;
      memset (dyn_i, 0, sizeof (*dyn_i));
a2145 33
      
      /* We increment count only since the new ones are unsorted and
	 may have duplicate.  */
      (*count_p)++;
    }
  else
    {
      /* It is a lookup without insertion.  Sort array if part of the
	 array isn't sorted.  */
      if (count != sorted_count)
	{
	  count = sort_dyn_sym_info (info, count);
	  *count_p = count;
	  *sorted_count_p = count;
	}

      /* Free unused memory.  */
      if (size != count)
	{
	  amt = count * sizeof (*info);
	  info = bfd_malloc (amt);
	  if (info != NULL)
	    {
	      memcpy (info, *info_p, amt);
	      free (*info_p);
	      *size_p = count;
	      *info_p = info;
	    }
	}

      key.addend = addend;
      dyn_i = bsearch (&key, info, count,
		       sizeof (*info), addend_compare);
a2370 17
  enum {
    NEED_GOT = 1,
    NEED_GOTX = 2,
    NEED_FPTR = 4,
    NEED_PLTOFF = 8,
    NEED_MIN_PLT = 16,
    NEED_FULL_PLT = 32,
    NEED_DYNREL = 64,
    NEED_LTOFF_FPTR = 128,
    NEED_TPREL = 256,
    NEED_DTPMOD = 512,
    NEED_DTPREL = 1024
  };
  int need_entry;
  struct elf_link_hash_entry *h;
  unsigned long r_symndx;
  bfd_boolean maybe_dynamic;
a2380 4

  /* We scan relocations first to create dynamic relocation arrays.  We
     modified get_dyn_sym_info to allow fast insertion and support fast
     lookup in the next loop.  */
d2383 13
a2395 30
      r_symndx = ELFNN_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  long indx = r_symndx - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	}
      else
	h = NULL;

      /* We can only get preliminary data on whether a symbol is
	 locally or externally defined, as not all of the input files
	 have yet been processed.  Do something with what we know, as
	 this may help reduce memory usage and processing time later.  */
      maybe_dynamic = (h && ((!info->executable
			      && (!info->symbolic
				  || info->unresolved_syms_in_shared_libs == RM_IGNORE))
			     || !h->def_regular
			     || h->root.type == bfd_link_hash_defweak));

      need_entry = 0;
      switch (ELFNN_R_TYPE (rel->r_info))
	{
	case R_IA64_TPREL64MSB:
	case R_IA64_TPREL64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;
d2397 2
a2398 134
	case R_IA64_LTOFF_TPREL22:
	  need_entry = NEED_TPREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;

	case R_IA64_DTPREL32MSB:
	case R_IA64_DTPREL32LSB:
	case R_IA64_DTPREL64MSB:
	case R_IA64_DTPREL64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;

	case R_IA64_LTOFF_DTPREL22:
	  need_entry = NEED_DTPREL;
	  break;

	case R_IA64_DTPMOD64MSB:
	case R_IA64_DTPMOD64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;

	case R_IA64_LTOFF_DTPMOD22:
	  need_entry = NEED_DTPMOD;
	  break;

	case R_IA64_LTOFF_FPTR22:
	case R_IA64_LTOFF_FPTR64I:
	case R_IA64_LTOFF_FPTR32MSB:
	case R_IA64_LTOFF_FPTR32LSB:
	case R_IA64_LTOFF_FPTR64MSB:
	case R_IA64_LTOFF_FPTR64LSB:
	  need_entry = NEED_FPTR | NEED_GOT | NEED_LTOFF_FPTR;
	  break;

	case R_IA64_FPTR64I:
	case R_IA64_FPTR32MSB:
	case R_IA64_FPTR32LSB:
	case R_IA64_FPTR64MSB:
	case R_IA64_FPTR64LSB:
	  if (info->shared || h)
	    need_entry = NEED_FPTR | NEED_DYNREL;
	  else
	    need_entry = NEED_FPTR;
	  break;

	case R_IA64_LTOFF22:
	case R_IA64_LTOFF64I:
	  need_entry = NEED_GOT;
	  break;

	case R_IA64_LTOFF22X:
	  need_entry = NEED_GOTX;
	  break;

	case R_IA64_PLTOFF22:
	case R_IA64_PLTOFF64I:
	case R_IA64_PLTOFF64MSB:
	case R_IA64_PLTOFF64LSB:
	  need_entry = NEED_PLTOFF;
	  if (h)
	    {
	      if (maybe_dynamic)
		need_entry |= NEED_MIN_PLT;
	    }
	  else
	    {
	      (*info->callbacks->warning)
		(info, _("@@pltoff reloc against local symbol"), 0,
		 abfd, 0, (bfd_vma) 0);
	    }
	  break;

	case R_IA64_PCREL21B:
        case R_IA64_PCREL60B:
	  /* Depending on where this symbol is defined, we may or may not
	     need a full plt entry.  Only skip if we know we'll not need
	     the entry -- static or symbolic, and the symbol definition
	     has already been seen.  */
	  if (maybe_dynamic && rel->r_addend == 0)
	    need_entry = NEED_FULL_PLT;
	  break;

	case R_IA64_IMM14:
	case R_IA64_IMM22:
	case R_IA64_IMM64:
	case R_IA64_DIR32MSB:
	case R_IA64_DIR32LSB:
	case R_IA64_DIR64MSB:
	case R_IA64_DIR64LSB:
	  /* Shared objects will always need at least a REL relocation.  */
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;

	case R_IA64_IPLTMSB:
	case R_IA64_IPLTLSB:
	  /* Shared objects will always need at least a REL relocation.  */
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;

	case R_IA64_PCREL22:
	case R_IA64_PCREL64I:
	case R_IA64_PCREL32MSB:
	case R_IA64_PCREL32LSB:
	case R_IA64_PCREL64MSB:
	case R_IA64_PCREL64LSB:
	  if (maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  break;
	}

      if (!need_entry)
	continue;

      if ((need_entry & NEED_FPTR) != 0
	  && rel->r_addend)
	{
	  (*info->callbacks->warning)
	    (info, _("non-zero addend in @@fptr reloc"), 0,
	     abfd, 0, (bfd_vma) 0);
	}

      if (get_dyn_sym_info (ia64_info, h, abfd, rel, TRUE) == NULL)
	return FALSE;
    }

  /* Now, we only do lookup without insertion, which is very fast
     with the modified get_dyn_sym_info.  */ 
  for (rel = relocs; rel < relend; ++rel)
    {
d2400 2
a2403 1
      r_symndx = ELFNN_R_SYM (rel->r_info);
a2415 2
      else
	h = NULL;
d2421 7
a2427 5
      maybe_dynamic = (h && ((!info->executable
			      && (!info->symbolic
				  || info->unresolved_syms_in_shared_libs == RM_IGNORE))
			     || !h->def_regular
			     || h->root.type == bfd_link_hash_defweak));
d2511 6
d2565 9
a2573 1
      dyn_i = get_dyn_sym_info (ia64_info, h, abfd, rel, FALSE);
a4147 1
		  unsigned int count;
d4149 1
a4149 3
		  for (count = loc_h->count, dynent = loc_h->info;
		       count != 0;
		       count--, dynent++)
a4163 4
		  
		  qsort (loc_h->info, loc_h->count,
			 sizeof (*loc_h->info), addend_compare);

@


1.179
log
@2006-03-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_choose_gp): Properly choose gp.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d1921 2
a1922 1
				      elfNN_ia64_new_elf_hash_entry))
@


1.178
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d3931 2
d3934 1
a3934 1
	gp_val = min_vma;
d3939 2
a3940 2
	  && max_vma - gp_val <= 0x200000
	  && gp_val - min_vma > 0x200000)
@


1.177
log
@2006-02-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2218
	* elf-bfd.h (elf_backend_data): Add elf_backend_fixup_symbol.
	(_bfd_elf_link_hash_fixup_symbol): New.

	* elflink.c (_bfd_elf_link_hash_fixup_symbol): New.
	(_bfd_elf_fix_symbol_flags): Call elf_backend_fixup_symbol if
	it isn't NULL.

	* elfxx-ia64.c (elf_backend_fixup_symbol): Defined.

	* elfxx-target.h (elf_backend_fixup_symbol): New.
	(elfNN_bed): Initialize elf_backend_fixup_symbol.
@
text
@d4838 2
a4839 2
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
      || strcmp (h->root.root.string, "_PROCEDURE_LINKAGE_TABLE_") == 0)
@


1.176
log
@	* elfxx-ia64.c (elfNN_ia64_fake_sections): Set SHF_IA_64_HP_TLS
	if SHF_TLS is set.
@
text
@d5308 1
@


1.175
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d1527 5
@


1.174
log
@2005-09-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_get_linked_section_vma): Fix a typo in comment.
	* elfxx-ia64.c (elf_backend_link_order_error_handler): Likewise.
@
text
@d219 1
a219 1
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
d1801 2
a1802 2
elfNN_ia64_hash_copy_indirect (bed, xdir, xind)
     const struct elf_backend_data *bed ATTRIBUTE_UNUSED;
d1824 1
a1824 1
  if (dir->info == NULL)
d1827 1
d1829 4
a1832 1
      dir->info = dyn_i = ind->info;
a1838 1
  BFD_ASSERT (ind->info == NULL);
d1842 1
a1842 1
  if (dir->root.dynindx == -1)
d1844 3
a1851 1
  BFD_ASSERT (ind->root.dynindx == -1);
@


1.173
log
@2005-08-29  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1247
	* elfxx-ia64.c (allocate_fptr): Check undefined symbol.
@
text
@d5303 1
a5303 1
   SHF_LINK_ORDER. But it doesn't set theh sh_link or sh_info fields.
@


1.172
log
@2005-08-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_final_link): Reset gp.
@
text
@d2778 2
a2779 1
	      || h->root.type != bfd_link_hash_undefweak))
@


1.171
log
@2005-08-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Resize .rela.got
	only if it isn't NULL.
@
text
@d3984 1
a3984 1
      bfd_vma gp_val = _bfd_get_gp_value (abfd);
d3987 6
a3992 6
      if (gp_val == 0)
	{
	  if (! elfNN_ia64_choose_gp (abfd, info))
	    return FALSE;
	  gp_val = _bfd_get_gp_value (abfd);
	}
@


1.170
log
@	* elfxx-ia64.c (struct elfNN_ia64_allocate_data): Add only_got.
	(elfNN_ia64_relax_section): Reallocate .rela.got when .got has
	changed.
	(allocate_dynrel_entries): Look only at GOT relocations when
	only_got is true.
	(elfNN_ia64_size_dynamic_sections): Set only_got to false before
	calling allocate_dynrel_entries.
@
text
@d1341 2
a1342 1
      if (ia64_info->root.dynamic_sections_created)
@


1.169
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@d175 1
d1341 11
a1351 1
      /* ??? Resize .rela.got too.  */
d2909 46
a3002 42
  /* Take care of the GOT and PLT relocations.  */

  if ((!resolved_zero
       && (dynamic_symbol || shared)
       && (dyn_i->want_got || dyn_i->want_gotx))
      || (dyn_i->want_ltoff_fptr
	  && dyn_i->h
	  && dyn_i->h->dynindx != -1))
    {
      if (!dyn_i->want_ltoff_fptr
	  || !x->info->pie
	  || dyn_i->h == NULL
	  || dyn_i->h->root.type != bfd_link_hash_undefweak)
	ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
    }
  if ((dynamic_symbol || shared) && dyn_i->want_tprel)
    ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
  if (dynamic_symbol && dyn_i->want_dtpmod)
    ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
  if (dynamic_symbol && dyn_i->want_dtprel)
    ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
  if (ia64_info->rel_fptr_sec && dyn_i->want_fptr)
    {
      if (dyn_i->h == NULL || dyn_i->h->root.type != bfd_link_hash_undefweak)
	ia64_info->rel_fptr_sec->size += sizeof (ElfNN_External_Rela);
    }

  if (!resolved_zero && dyn_i->want_pltoff)
    {
      bfd_size_type t = 0;

      /* Dynamic symbols get one IPLT relocation.  Local symbols in
	 shared libraries get two REL relocations.  Local symbols in
	 main applications get nothing.  */
      if (dynamic_symbol)
	t = sizeof (ElfNN_External_Rela);
      else if (shared)
	t = 2 * sizeof (ElfNN_External_Rela);

      ia64_info->rel_pltoff_sec->size += t;
    }

d3134 1
@


1.168
log
@	* libbfd-in.h (bfd_malloc2, bfd_realloc2, bfd_zmalloc2, bfd_alloc2,
	bfd_zalloc2): New prototypes.
	* bfd-in.h (HALF_BFD_SIZE_TYPE): Define.
	* libbfd.c (bfd_malloc2, bfd_realloc2, bfd_zmalloc2): New functions.
	* opncls.c (bfd_alloc2, bfd_zalloc2): New functions.
	* elf.c (bfd_elf_get_elf_syms, setup_group, assign_section_numbers,
	elf_map_symbols, map_sections_to_segments,
	assign_file_positions_for_segments, copy_private_bfd_data,
	swap_out_syms, _bfd_elf_slurp_version_tables): Use bfd_*alloc2
	where appropriate.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.

	* elf.c (_bfd_elf_print_private_bfd_data): Don't crash on bogus
	verdef or verneed section.
	(_bfd_elf_slurp_version_tables): Handle corrupt verdef and/or
	verneed sections gracefully.
	* elfxx-sparc.c (_bfd_sparc_elf_info_to_howto_ptr): Don't crash on
	bogus relocation values.
	* elf64-ppc.c (ppc64_elf_info_to_howto): Likewise.
	* elf64-s390.c (elf_s390_info_to_howto): Likewise.
	* elf32-s390.c (elf_s390_info_to_howto): Likewise.
	* elf64-x86-64.c (elf64_x86_64_info_to_howto): Likewise.
	* elfxx-ia64.c (lookup_howto): Likewise.
@
text
@a5060 18
static const struct bfd_elf_special_section *
elfNN_ia64_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					elfNN_ia64_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}

d5282 1
a5282 1
#define elf_backend_get_sec_type_attr	elfNN_ia64_get_sec_type_attr
@


1.167
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@d490 2
a491 1
  BFD_ASSERT (rtype <= R_IA64_MAX_RELOC_CODE);
@


1.166
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d5053 1
a5053 1
static struct bfd_elf_special_section const elfNN_ia64_special_sections[] =
d5063 1
a5063 1
  const struct bfd_elf_special_section const *ssect;
@


1.165
log
@2005-06-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_hpux_backend_symbol_processing): Remove
	the extra `;'.
@
text
@d5053 1
a5053 2
static struct bfd_elf_special_section const
  ia64_special_sections_s[]=
d5060 2
a5061 2
static struct bfd_elf_special_section const *
  elfNN_ia64_special_sections[27] =
d5063 14
a5076 28
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  NULL,				/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  ia64_special_sections_s,	/* 's' */
  NULL,				/* 't' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
d5299 1
a5299 1
#define elf_backend_special_sections	elfNN_ia64_special_sections
@


1.164
log
@2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_brl): Undo the change made on
	2005-02-16.
@
text
@d5222 1
a5222 1
  elf_symbol_type *elfsym = (elf_symbol_type *) asym;;
@


1.163
log
@2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_br): Keep the original
	predicate on slot 0 only if slot 0 isn't br.
@
text
@d825 1
a825 1
  unsigned int template, t0, t1, t2, t3;
d827 1
d831 2
a832 10
  t0 = bfd_getl32 (hit_addr + 0);
  t1 = bfd_getl32 (hit_addr + 4);
  t2 = bfd_getl32 (hit_addr + 8);
  t3 = bfd_getl32 (hit_addr + 12);

  /* Turn a MLX bundle into a MBB bundle with the same stop-bit
     variety.  */
  template = 0x12;
  if ((t0 & 0x1f) == 5)
    template += 1;
d835 3
a837 5
  t0 &= 0xffffffe0;
  t1 &= 0x3fff;

  t0 |= template;

d839 1
a839 2
  t2 &= 0xff800000;
  t3 &= 0x7fffffff;
d841 8
a848 2
  /* Use nop.b for slot 1. */
  t2 |= 0x100000;
d850 2
a851 4
  bfd_putl32 (t0, hit_addr);
  bfd_putl32 (t1, hit_addr + 4);
  bfd_putl32 (t2, hit_addr + 8);
  bfd_putl32 (t3, hit_addr + 12);
@


1.162
log
@2005-05-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 834
	* elfxx-ia64.c (elfNN_ia64_relax_br): New.
	(elfNN_ia64_relax_section): Use it.
@
text
@d798 6
a803 3
      /* For BBB, we need to put nop.m in slot 0 and keep the original
	 predicate.  */
      t0 &= PREDICATE_BITS << 5;
@


1.161
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d684 135
d1123 10
@


1.160
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d4911 2
a4912 1
static struct bfd_elf_special_section const elfNN_ia64_special_sections[]=
d4916 33
a4948 1
  { NULL,     0,  0, 0,            0 }
@


1.159
log
@2005-05-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (ARCH_SIZE): New.
	(LOG_SECTION_ALIGN): Likewise.
	(elfNN_ia64_create_dynamic_sections): Use LOG_SECTION_ALIGN to
	align relocation sections.
	(get_fptr): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_check_relocs): Support 32bit relocations.
	(allocate_global_fptr_got): Likewise.
	(allocate_dynrel_entries): Likewise.
	(set_got_entry): Likewise.
	(set_pltoff_entry): Likewise.
	(elfNN_ia64_relocate_section): Likewise.
@
text
@d1439 5
a1443 5
	  scomm = bfd_make_section (abfd, ".scommon");
	  if (scomm == NULL
	      || !bfd_set_section_flags (abfd, scomm, (SEC_ALLOC
						       | SEC_IS_COMMON
						       | SEC_LINKER_CREATED)))
d1877 6
a1882 1
  s = bfd_make_section(abfd, ".rela.IA_64.pltoff");
a1883 5
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED
					   | SEC_READONLY))
d1888 6
a1893 1
  s = bfd_make_section(abfd, ".rela.got");
a1894 5
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED
					   | SEC_READONLY))
d2041 7
a2047 1
      fptr = bfd_make_section (dynobj, ".opd");
a2048 7
	  || !bfd_set_section_flags (dynobj, fptr,
				     (SEC_ALLOC
				      | SEC_LOAD
				      | SEC_HAS_CONTENTS
				      | SEC_IN_MEMORY
				      | (info->pie ? 0 : SEC_READONLY)
				      | SEC_LINKER_CREATED))
d2060 6
a2065 1
	  fptr_rel = bfd_make_section(dynobj, ".rela.opd");
a2066 6
	      || !bfd_set_section_flags (dynobj, fptr_rel,
					 (SEC_ALLOC | SEC_LOAD
					  | SEC_HAS_CONTENTS
					  | SEC_IN_MEMORY
					  | SEC_LINKER_CREATED
					  | SEC_READONLY))
d2097 8
a2104 1
      pltoff = bfd_make_section (dynobj, ELF_STRING_ia64_pltoff);
a2105 7
	  || !bfd_set_section_flags (dynobj, pltoff,
				     (SEC_ALLOC
				      | SEC_LOAD
				      | SEC_HAS_CONTENTS
				      | SEC_IN_MEMORY
				      | SEC_SMALL_DATA
				      | SEC_LINKER_CREATED))
d2149 6
a2154 1
      srel = bfd_make_section (dynobj, srel_name);
a2155 7
	  || !bfd_set_section_flags (dynobj, srel,
				     (SEC_ALLOC
				      | SEC_LOAD
				      | SEC_HAS_CONTENTS
				      | SEC_IN_MEMORY
				      | SEC_LINKER_CREATED
				      | SEC_READONLY))
d4964 3
a4966 3
	  group = bfd_make_section_anyway (abfd, name);
	  if (group == NULL
	      || ! bfd_set_section_flags (abfd, group, flags))
@


1.158
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d31 10
d1884 1
a1884 1
      || !bfd_set_section_alignment (abfd, s, 3))
d1895 1
a1895 1
      || !bfd_set_section_alignment (abfd, s, 3))
d2069 2
a2070 1
	      || !bfd_set_section_alignment (abfd, fptr_rel, 3))
d2160 2
a2161 1
	  || !bfd_set_section_alignment (dynobj, srel, 3))
d2285 2
d2291 1
a2291 1
	  dynrel_type = R_IA64_DTPREL64LSB;
d2327 1
a2327 1
	  dynrel_type = R_IA64_FPTR64LSB;
d2377 1
a2377 1
	  dynrel_type = R_IA64_DIR64LSB;
d2396 1
a2396 1
	  dynrel_type = R_IA64_PCREL64LSB;
d2560 1
a2560 1
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, R_IA64_FPTR64LSB))
d2767 1
d2776 1
d2781 1
d2794 1
d3434 1
d3459 1
d3462 3
a3464 1
	   || (dynindx != -1 && dyn_r_type == R_IA64_FPTR64LSB))
d3473 1
d3476 1
a3476 1
	      dyn_r_type = R_IA64_REL64LSB;
d3485 12
d3626 1
a3626 1
	    dyn_r_type = R_IA64_REL64MSB;
d3628 1
a3628 1
	    dyn_r_type = R_IA64_REL64LSB;
d3636 1
a3636 1
					dyn_i->pltoff_offset + 8,
d3654 1
a3654 1
   is assigned offset round(16, PT_TLS p_align).  */
d3663 2
a3664 1
  return tls_sec->vma - align_power ((bfd_vma) 16, tls_sec->alignment_power);
d4135 1
a4135 1
				 rel->r_addend, value, R_IA64_DIR64LSB);
d4188 1
a4188 1
		  dyn_r_type = r_type + R_IA64_REL64LSB - R_IA64_FPTR64LSB;
d4252 1
a4252 1
				   rel->r_addend, value, R_IA64_FPTR64LSB);
d4451 2
d4491 1
a4491 1
		got_r_type = R_IA64_DTPREL64LSB;
@


1.157
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.156
log
@Update the FSF address in the copyright/GPL notice
@
text
@d1561 1
a1561 1
	    struct bfd_link_order *order = m->sections[i]->link_order_head;
d3055 1
a3055 1
	_bfd_strip_section_from_output (info, sec);
@


1.155
log
@	* section.c (bfd_section_list_remove): Don't clear s->next.
	(bfd_section_list_append): Always init s->prev.
	(bfd_section_list_prepend): Define.
	(bfd_section_list_insert_after): Minor optimization.
	(bfd_section_removed_from_list): Rewrite.
	* elf.c (assign_section_numbers): Simplify list traversal now that
	bfd_section_list_remove doesn't destroy removed section next ptr.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Use bfd_section_list_prepend.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Simplify list traversal.
	* bfd-in2.h: Regenerate.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.154
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@d4937 1
a4937 1
	  bfd_section_list_insert_before (abfd, abfd->sections, group);
@


1.153
log
@2005-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_sym_name): Also take "asection *".

	* elf.c (bfd_elf_sym_name): Updated.
	(group_signature): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(ppc64_elf_relocate_section): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.c (elf_link_input_bfd): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Call
	bfd_elf_sym_name to get local symbol name when reporting errors.
@
text
@a4887 1
  asection **tail;
a4927 2
	  tail = abfd->section_tail;

d4936 2
a4937 3
	  BFD_ASSERT (*tail == group);
	  bfd_section_list_remove (abfd, tail);
	  bfd_section_list_insert (abfd, &abfd->sections, group);
@


1.152
log
@bfd/

2005-04-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (bfd_elf_set_group_contents): Ignore linker created
	group section.
	(assign_section_numbers): Accept link_info. Check SHT_GROUP
	sections for relocatable files only. Remove the linker created
	group sections.
	(_bfd_elf_compute_section_file_positions): Pass link_info to
	assign_section_numbers.

	* elfxx-ia64.c (elfNN_ia64_object_p): New.
	(elf_backend_object_p): Defined.

gas/

2005-04-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (start_unwind_section): Undo the change
	of 2004-08-18.
	(generate_unwind_image, dot_endp): Likewise.
@
text
@d4017 3
a4019 1
		     h->root.root.string);
d4083 4
a4086 1
		 input_bfd, h->root.root.string);
d4287 6
a4292 1
	      (*_bfd_error_handler) (msg, input_bfd, h->root.root.string);
d4489 2
a4490 9
	      {
		name = bfd_elf_string_from_elf_section (input_bfd,
							symtab_hdr->sh_link,
							sym->st_name);
		if (name == NULL)
		  return FALSE;
		if (*name == '\0')
		  name = bfd_section_name (input_bfd, input_section);
	      }
d4509 2
a4510 9
	      {
		name = bfd_elf_string_from_elf_section (input_bfd,
							symtab_hdr->sh_link,
							sym->st_name);
		if (name == NULL)
		  return FALSE;
		if (*name == '\0')
		  name = bfd_section_name (input_bfd, sym_sec);
	      }
@


1.151
log
@2005-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add int to
	elf_backend_section_from_shdr.
	(bfd_elf_section_data): Update comment for this_idx.
	(_bfd_elf_make_section_from_shdr): Add int.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.

	* elf.c (_bfd_elf_make_section_from_shdr): Take section index
	and use it to set this_idx in bfd_elf_section_data.
	(bfd_section_from_shdr): Pass shindex to
	_bfd_elf_make_section_from_shdr.
	(_bfd_elf_section_from_bfd_section): Use this_idx in
	bfd_elf_section_data to find section index.

	* elf32-arm.c (elf32_arm_section_from_shdr): Take section
	index and pass it to _bfd_elf_make_section_from_shdr.
	* elf32-i370.c(i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d4889 97
d5068 3
@


1.150
log
@	* elfxx-ia64.c (elfNN_ia64_install_value): Change type of insn
	from bfd_vma to ia64_insn, remove broken cast.
@
text
@a185 2
static bfd_boolean elfNN_ia64_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d1262 2
a1263 1
   is called when elfcode.h finds a section with an unknown type.  */
d1266 4
a1269 4
elfNN_ia64_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
d1293 1
a1293 1
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
@


1.149
log
@2005-03-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set symbo name
	for global symbol when reporting overflow.
@
text
@d3122 2
a3123 1
  bfd_vma t0, t1, insn, dword;
d3312 1
a3312 1
      err = (*op->insert) (op, val, (ia64_insn *)& insn);
@


1.148
log
@	* mach-o.c (bfd_mach_o_scan): Don't ignore return value of
	bfd_mach_o_scan_start_address.
	* elfxx-ia64.c (elfNN_ia64_relax_brl): Rewrite for 32-bit bfd_vma.
	* elfxx-mips.c: Remove unnecessary prototypes.
	(sort_dynamic_relocs_64): Abort if not BFD64.
@
text
@d4504 1
a4504 1
	      name = NULL;
@


1.147
log
@bfd/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* elfxx-ia64.c (ia64_howto_table): Correct strings for
	R_IA64_DTPMOD64[LM]SB.

gas/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (ia64_gen_real_reloc_type): Define and initialize
	new variables type, suffix, and width. Handle
	BFD_RELOC_IA64_DIR(32|64)[LM]SB in FUNC_LT_FPTR_RELATIVE case.
	Handle BFD_RELOC_IA64_DIR64[LM]SB in FUNC_TP_RELATIVE case. Add
	FUNC_DTP_MODULE case. Handle BFD_RELOC_IA64_DIR32[LM]SB in
	FUNC_DTP_RELATIVE case. Return incoming relocation type if
	BFD_RELOC_IA64_IPLT[LM]SB in FUNC_IPLT_RELOC case. Generate warning
	if unable to translate relocation type, using the new variables.

gas/testsuite/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/reloc.[ds]: New.
	* gas/ia64/reloc-bad.[ls]: New.
	* gas/ia64/ia64.exp: Run new tests.
@
text
@d679 1
a679 1
  int template;
a680 1
  bfd_vma t0, t1, i0, i1, i2;
d684 4
a687 9
  t0 = bfd_getl64 (hit_addr);
  t1 = bfd_getl64 (hit_addr + 8);

  /* Keep the instruction in slot 0. */
  i0 = (t0 >> 5) & 0x1ffffffffffLL;
  /* Use nop.b for slot 1. */
  i1 = 0x4000000000LL;
  /* For slot 2, turn brl into br by masking out bit 40.  */
  i2 = (t1 >> 23) & 0x0ffffffffffLL;
d692 1
a692 1
  if ((t0 & 0x1fLL) == 5)
a693 2
  t0 = (i1 << 46) | (i0 << 5) | template;
  t1 = (i2 << 23) | (i1 >> 18);
d695 17
a711 2
  bfd_putl64 (t0, hit_addr);
  bfd_putl64 (t1, hit_addr + 8);
d967 1
a967 1
		    = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
@


1.146
log
@2005-02-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Allow relax
	backward branch in the same section.
	(elfNN_ia64_relocate_section): Inform users that the input
	section is too big to relax br instruction when overflow
	happens to R_IA64_PCREL21B, R_IA64_PCREL21BI, R_IA64_PCREL21M
	and R_IA64_PCREL21F.
@
text
@d448 2
a449 2
    IA64_HOWTO (R_IA64_DTPMOD64MSB, "TPREL64MSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPMOD64LSB, "TPREL64LSB",  4, FALSE, FALSE),
@


1.145
log
@	* elfxx-ia64.c (elfNN_ia64_new_elf_hash_entry): Don't clear
	everything, just the field specific to ia64.
@
text
@d987 4
a990 3
	     got one honking big section and we can't help you.  You'll
	     get an error message later.  */
	  if (tsec == sec)
d4508 31
a4538 7
	    if (!(*info->callbacks->reloc_overflow) (info, &h->root,
						     name, howto->name,
						     (bfd_vma) 0,
						     input_bfd,
						     input_section,
						     rel->r_offset))
	      return FALSE;
@


1.144
log
@2004-10-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Handle weak
	undefined symbols for R_IA64_SECREL32MSB, R_IA64_SECREL32LSB,
	R_IA64_SECREL64MSB and R_IA64_SECREL64LSB.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
a1618 4
  /* Initialize our local data.  All zeros, and definitely easier
     than setting a handful of bit fields.  */
  memset (ret, 0, sizeof (*ret));

d1624 1
@


1.143
log
@2004-10-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 475
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Correct
	R_IA64_SECREL32MSB, R_IA64_SECREL32LSB, R_IA64_SECREL64MSB
	and R_IA64_SECREL64LSB.
@
text
@d4343 2
a4344 1
	  value -= sym_sec->output_section->vma;
@


1.142
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d4341 3
a4343 5
	  /* Make output-section relative.  */
	  if (value > input_section->output_section->vma)
	    value -= input_section->output_section->vma;
	  else
	    value = 0;
@


1.141
log
@	* libbfd-in.h (BFD_ASSERT, BFD_FAIL): Wrap macro body in do while.
	* libbfd.h: Regnerate.
	* elf32-cris.c: Add missing semicolon to BFD_ASSERTs.
	* elf32-frv.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* opncls.c: Likewise.
@
text
@d4500 1
a4500 1
	      name = h->root.root.string;
d4509 1
a4509 1
		  name = bfd_section_name (input_bfd, input_section);
d4511 2
a4512 2
	    if (!(*info->callbacks->reloc_overflow) (info, name,
						     howto->name,
@


1.140
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d927 1
a927 1
	   
d1128 1
a1128 1
      
d2461 1
a2461 1
	  
d4181 1
a4181 1
		BFD_ASSERT (h == NULL || h->dynindx == -1)
d4265 1
a4265 1
	     fixup code, and thus probably ought not be dynamic.  The 
@


1.139
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d2841 1
a2841 1
  if (h->weakdef != NULL)
d2843 4
a2846 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
                  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.138
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d1644 4
a1647 6
  dir->root.elf_link_hash_flags |=
    (ind->root.elf_link_hash_flags
     & (ELF_LINK_HASH_REF_DYNAMIC
        | ELF_LINK_HASH_REF_REGULAR
        | ELF_LINK_HASH_REF_REGULAR_NONWEAK
        | ELF_LINK_HASH_NEEDS_PLT));
d2236 1
a2236 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
d2245 3
a2247 2
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
		|| ! (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
d2446 1
a2446 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d2653 1
a2653 1
      /* ??? Versioned symbols seem to lose ELF_LINK_HASH_NEEDS_PLT.  */
d4577 1
a4577 1
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
@


1.137
log
@2004-07-30  H.J. Lu  <hongjiu.lu@@intel.com>
	    Nick Clifton  <nickc@@redhat.com>

	PR 290
	* bfd.c (_bfd_default_error_handler): Make it global.

	* elf-bfd.h (elf_backend_data): Add link_order_error_handler.

	* elf.c (assign_section_numbers): Cope gracefully with sections
	which have SHF_LINK_ORDER set but no sh_link set up.
	* elflink.c (elf_get_linked_section_vma): Likewise.

	* elfxx-ia64.c (elf_backend_link_order_error_handler): New. Set
	it to NULL.

	* elfxx-target.h (elf_backend_link_order_error_handler): New.
	Set it to _bfd_default_error_handler.
	(elfNN_bed): Add elf_backend_link_order_error_handler.

	* libbfd-in.h (_bfd_default_error_handler): New.

	* libbfd.h: Regenerated.
@
text
@d980 2
a981 3
		(_("%s: Can't relax br at 0x%lx in section `%s'. Please use brl or indirect branch."),
		 bfd_archive_filename (sec->owner),
		 (unsigned long) roff, sec->name);
d3906 2
a3907 2
	    (_("%s: unknown relocation type %d"),
	     bfd_archive_filename (input_bfd), (int)r_type);
d4011 2
a4012 2
		    (_("%s: non-pic code with imm relocation against dynamic symbol `%s'"),
		     bfd_archive_filename (input_bfd),
d4076 2
a4077 2
		(_("%s: @@gprel relocation against dynamic symbol %s"),
		 bfd_archive_filename (input_bfd), h->root.root.string);
d4136 2
a4137 2
			(_("%s: linking non-pic code in a position independent executable"),
			 bfd_archive_filename (input_bfd));
d4273 1
a4273 1
		msg = _("%s: @@internal branch to dynamic symbol %s");
d4275 1
a4275 1
		msg = _("%s: speculation fixup to dynamic symbol %s");
d4277 2
a4278 3
		msg = _("%s: @@pcrel relocation against dynamic symbol %s");
	      (*_bfd_error_handler) (msg, bfd_archive_filename (input_bfd),
				     h->root.root.string);
d4762 2
a4763 2
	(_("%s: linking trap-on-NULL-dereference with non-trapping files"),
	 bfd_archive_filename (ibfd));
d4771 2
a4772 2
	(_("%s: linking big-endian files with little-endian files"),
	 bfd_archive_filename (ibfd));
d4780 2
a4781 2
	(_("%s: linking 64-bit files with 32-bit files"),
	 bfd_archive_filename (ibfd));
d4789 2
a4790 2
	(_("%s: linking constant-gp files with non-constant-gp files"),
	 bfd_archive_filename (ibfd));
d4799 2
a4800 2
	(_("%s: linking auto-pic files with non-auto-pic files"),
	 bfd_archive_filename (ibfd));
@


1.136
log
@bfd/

2004-07-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_section_data): Add a pointer for the
	linked-to section.
	(elf_linked_to_section): New.

	* elf.c (assign_section_numbers): Set up sh_link for
	SHF_LINK_ORDER.

	* elfxx-ia64.c (elfNN_ia64_final_write_processing): Set sh_info
	to sh_link for SHT_IA_64_UNWIND sections.

gas/

2004-07-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (start_unwind_section): Set the linked-to
	section.
	(ia64_elf_section_change_hook): Set the linked-to section for
	SHT_IA_64_UNWIND.
@
text
@d4990 7
@


1.135
log
@Fix linker big-endian support.
* elfxx-ia64.c (elfNN_ia64_relax_ldxmov): Remove abfd parameter.
(elfNN_ia64_install_value, elfNN_ia64_relax_brl): Likewise.
(elfNN_ia64_relax_section, elfNN_ia64_relocate_section,
elfNN_ia64_finish_dynamic_symbol, elfNN_ia64_finish_dynamic_sections):
Fix callers.
(elfNN_ia64_relax_brl): Change bfd_get_64 to bfd_getl64.  Change
bfd_put_64 to bfd_putl64.
(elfNN_ia64_relax_ldxmov, elfNN_ia64_install_value): Likewise.
@
text
@d1368 1
a1368 3
  const char *sname;
  asection *text_sect, *s;
  size_t len;
d1376 5
a1380 58
	  /* See comments in gas/config/tc-ia64.c:dot_endp on why we
	     have to do this.  */
	  sname = bfd_get_section_name (abfd, s);
	  len = sizeof (ELF_STRING_ia64_unwind) - 1;
	  if (sname && strncmp (sname, ELF_STRING_ia64_unwind, len) == 0)
	    {
	      sname += len;

	      if (sname[0] == '\0')
		/* .IA_64.unwind -> .text */
		text_sect = bfd_get_section_by_name (abfd, ".text");
	      else
		/* .IA_64.unwindFOO -> FOO */
		text_sect = bfd_get_section_by_name (abfd, sname);
	    }
	  else if (sname
		   && (len = sizeof (ELF_STRING_ia64_unwind_once) - 1,
		       strncmp (sname, ELF_STRING_ia64_unwind_once, len)) == 0)
	    {
	      /* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.t.FOO */
	      size_t len2 = sizeof (".gnu.linkonce.t.") - 1;
	      char *once_name = bfd_malloc (len2 + strlen (sname + len) + 1);

	      if (once_name != NULL)
		{
		  memcpy (once_name, ".gnu.linkonce.t.", len2);
		  strcpy (once_name + len2, sname + len);
		  text_sect = bfd_get_section_by_name (abfd, once_name);
		  free (once_name);
		}
	      else
		/* Should only happen if we run out of memory, in
		   which case we're probably toast anyway.  Try to
		   cope by finding the section the slow way.  */
		for (text_sect = abfd->sections;
		     text_sect != NULL;
		     text_sect = text_sect->next)
		  {
		    if (strncmp (bfd_section_name (abfd, text_sect),
				 ".gnu.linkonce.t.", len2) == 0
			&& strcmp (bfd_section_name (abfd, text_sect) + len2,
				   sname + len) == 0)
		      break;
		  }
	    }
	  else
	    /* last resort: fall back on .text */
	    text_sect = bfd_get_section_by_name (abfd, ".text");

	  if (text_sect)
	    {
	      /* The IA-64 processor-specific ABI requires setting
		 sh_link to the unwind section, whereas HP-UX requires
		 sh_info to do so.  For maximum compatibility, we'll
		 set both for now... */
	      hdr->sh_link = elf_section_data (text_sect)->this_idx;
	      hdr->sh_info = elf_section_data (text_sect)->this_idx;
	    }
@


1.134
log
@2004-07-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 240
	* elfxx-ia64.c (elfNN_ia64_relax_section): Only warn br in
	.init/.fini sections when trying to relax it.
@
text
@d183 1
a183 1
  PARAMS((bfd *abfd, bfd_byte *contents, bfd_vma off));
d276 1
a276 1
  PARAMS ((bfd *abfd, bfd_byte *hit_addr, bfd_vma val, unsigned int r_type));
d677 1
a677 1
elfNN_ia64_relax_brl (bfd *abfd, bfd_byte *contents, bfd_vma off)
d685 2
a686 2
  t0 = bfd_get_64 (abfd, hit_addr);
  t1 = bfd_get_64 (abfd, hit_addr + 8);
d703 2
a704 2
  bfd_put_64 (abfd, t0, hit_addr);
  bfd_put_64 (abfd, t1, hit_addr + 8);
d957 1
a957 1
		  elfNN_ia64_relax_brl (abfd, contents, roff);
d1077 2
a1078 2
	  if (elfNN_ia64_install_value (abfd, contents + roff, offset,
					r_type) != bfd_reloc_ok)
d1117 1
a1117 1
	      elfNN_ia64_relax_ldxmov (abfd, contents, roff);
d1204 1
a1204 2
elfNN_ia64_relax_ldxmov (abfd, contents, off)
     bfd *abfd;
d1220 1
a1220 1
  dword = bfd_get_64 (abfd, contents + off);
d1232 1
a1232 1
  bfd_put_64 (abfd, dword, contents + off);
d3167 1
a3167 2
elfNN_ia64_install_value (abfd, hit_addr, v, r_type)
     bfd *abfd;
d3299 2
a3300 2
      t0 = bfd_get_64 (abfd, hit_addr);
      t1 = bfd_get_64 (abfd, hit_addr + 8);
d3322 2
a3323 2
      bfd_put_64 (abfd, t0, hit_addr);
      bfd_put_64 (abfd, t1, hit_addr + 8);
d3328 2
a3329 2
      t0 = bfd_get_64 (abfd, hit_addr);
      t1 = bfd_get_64 (abfd, hit_addr + 8);
d3347 2
a3348 2
      bfd_put_64 (abfd, t0, hit_addr);
      bfd_put_64 (abfd, t1, hit_addr + 8);
d3359 1
a3359 1
      dword = bfd_get_64 (abfd, hit_addr);
d3369 1
a3369 1
      bfd_put_64 (abfd, dword, hit_addr);
d4120 1
a4120 1
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
d4138 1
a4138 1
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
d4148 1
a4148 1
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
d4158 1
a4158 1
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
d4223 1
a4223 1
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
d4265 1
a4265 1
	    r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
d4346 1
a4346 1
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
d4390 1
a4390 2
		  r = elfNN_ia64_install_value (output_bfd, hit_addr, value,
						r_type);
d4404 1
a4404 1
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
d4445 2
a4446 3
	  elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
	  r = elfNN_ia64_install_value (output_bfd, hit_addr + 8, gp_val,
					r_type);
d4453 1
a4453 1
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
d4462 1
a4462 1
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
d4504 1
a4504 2
	    r = elfNN_ia64_install_value (output_bfd, hit_addr, value,
					  r_type);
d4615 2
a4616 3
      elfNN_ia64_install_value (output_bfd, loc, index, R_IA64_IMM22);
      elfNN_ia64_install_value (output_bfd, loc+2, -dyn_i->plt_offset,
				R_IA64_PCREL21B);
d4629 1
a4629 2
	  elfNN_ia64_install_value (output_bfd, loc, pltoff_addr - gp_val,
				    R_IA64_IMM22);
d4752 1
a4752 1
	  elfNN_ia64_install_value (abfd, loc+1, pltres, R_IA64_GPREL22);
@


1.133
log
@Fix @@pltoff linker segfault for non-shared link.
* elfxx-ia64.c (elfNN_ia64_check_relocs): New local pltoff.  Initialize
to NULL.  Call get_pltoff if NULL and NEED_PLTOFF is true.
@
text
@a945 13
	  /* We can't put a trampoline in a .init/.fini section. Issue
	     an error.  */
	  if (strcmp (sec->output_section->name, ".init") == 0
	      || strcmp (sec->output_section->name, ".fini") == 0)
	    {
	      (*_bfd_error_handler)
		(_("%s: Can't relax br at 0x%lx in section `%s'. Please use brl or indirect branch."),
		 bfd_archive_filename (sec->owner),
		 (unsigned long) roff, sec->name);
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }

d974 13
@


1.132
log
@2004-06-29  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 240
	* elfxx-ia64.c (elfNN_ia64_relax_section): Don't relax branch
	in .init/.fini sections.
@
text
@d2251 1
a2251 1
  asection *got, *fptr, *srel;
d2259 1
a2259 1
  got = fptr = srel = NULL;
d2510 12
a2521 1
	dyn_i->want_pltoff = 1;
@


1.131
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d946 13
@


1.130
log
@2004-06-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Add addend when
	calling _bfd_merged_section_offset only for section symbols.
@
text
@a751 5
  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

d769 1
a769 6
      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
      if (contents == NULL)
	goto error_return;

      if (! bfd_get_section_contents (abfd, sec, contents,
				      (file_ptr) 0, sec->_raw_size))
d999 1
a999 1
	      trampoff = (sec->_cooked_size + 15) & (bfd_vma) -16;
d1011 1
a1011 1
	      sec->_cooked_size = amt;
d1167 1
a1167 2
      ia64_info->got_sec->_raw_size = data.ofs;
      ia64_info->got_sec->_cooked_size = data.ofs;
d2816 1
a2816 1
      rent->srel->_raw_size += sizeof (ElfNN_External_Rela) * count;
d2832 1
a2832 1
	ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
d2835 1
a2835 1
    ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
d2837 1
a2837 1
    ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
d2839 1
a2839 1
    ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
d2843 1
a2843 1
	ia64_info->rel_fptr_sec->_raw_size += sizeof (ElfNN_External_Rela);
d2858 1
a2858 1
      ia64_info->rel_pltoff_sec->_raw_size += t;
d2918 1
a2918 1
      sec->_raw_size = strlen (ELF_DYNAMIC_INTERPRETER) + 1;
d2929 1
a2929 1
      ia64_info->got_sec->_raw_size = data.ofs;
d2938 1
a2938 1
      ia64_info->fptr_sec->_raw_size = data.ofs;
d2968 1
a2968 1
      ia64_info->plt_sec->_raw_size = data.ofs;
d2973 1
a2973 1
      sec->_raw_size = 8 * PLT_RESERVED_WORDS;
d2982 1
a2982 1
      ia64_info->pltoff_sec->_raw_size = data.ofs;
d2991 1
a2991 1
	ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
d3012 1
a3012 1
      strip = (sec->_raw_size == 0);
d3089 2
a3090 2
	  sec->contents = (bfd_byte *) bfd_zalloc (dynobj, sec->_raw_size);
	  if (sec->contents == NULL && sec->_raw_size != 0)
d3401 1
a3401 2
  BFD_ASSERT (sizeof (ElfNN_External_Rela) * srel->reloc_count
	      <= srel->_cooked_size);
d3717 1
a3717 1
      hi = os->vma + os->_raw_size;
d3853 1
a3853 1
	    = bfd_malloc (unwind_output_sec->_raw_size);
d3867 1
a3867 1
	     (size_t) (unwind_output_sec->_raw_size / 24),
d3873 1
a3873 1
				      unwind_output_sec->_raw_size))
d4678 1
a4678 1
      dynconend = (ElfNN_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
@


1.129
log
@2004-05-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Undo the last
	change.
@
text
@d792 1
d868 1
d913 2
d918 27
a944 3
	toff = _bfd_merged_section_offset (abfd, &tsec,
					   elf_section_data (tsec)->sec_info,
					   toff + irel->r_addend);
@


1.128
log
@2004-05-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Properly call
	_bfd_merged_section_offset for local symbols.
@
text
@a866 9
	  
	  if ((tsec->flags & SEC_MERGE)
	      && ELF_ST_TYPE (isym->st_info) == STT_SECTION
	      && tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	    toff = _bfd_merged_section_offset (abfd, &tsec,
					       elf_section_data (tsec)->sec_info,
					       toff + irel->r_addend);
	  else
	    toff += irel->r_addend;
d911 1
d913 6
a918 7
	  if (tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	    toff = _bfd_merged_section_offset (abfd, &tsec,
					       elf_section_data (tsec)->sec_info,
					       toff + irel->r_addend);
	  else
	    toff += irel->r_addend;
	}
@


1.127
log
@	* merge.c (_bfd_merged_section_offset): Remove "addend" param.
	* libbfd-in.h (_bfd_merged_section_offset): Adjust prototype.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_rela_local_sym): Adjust call.
	(_bfd_elf_rel_local_sym): Likewise.
	* elflink.c (_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_relocate_section): Likewise.
@
text
@d867 9
d920 7
a928 7
      if (tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	toff = _bfd_merged_section_offset (abfd, &tsec,
					   elf_section_data (tsec)->sec_info,
					   toff + irel->r_addend);
      else
	toff += irel->r_addend;

@


1.126
log
@	* elf64-alpha.c (elf64_alpha_read_ecoff_info): Don't assign
	structure field removed in 2004-04-24 patch.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): Warning fix.

	* elf-bfd.h (struct elf_backend_data <elf_backend_section_flags>):
	Constify hdr arg.
	* elf32-arm.h (elf32_arm_section_flags): Likewise.
	* elf64-alpha.c (elf64_alpha_section_flags): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_flags): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set the bfd_section
	field before calling elf_backend_section_flags.
@
text
@d916 1
a916 2
					   toff + irel->r_addend,
					   (bfd_vma) 0);
d3965 1
a3965 2
						    + dynent->addend,
						    (bfd_vma) 0);
@


1.125
log
@2004-04-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections): Always
	reserve the memory for dynamic linker
@
text
@d189 1
a189 1
  PARAMS ((flagword *, Elf_Internal_Shdr *));
d1274 1
a1274 1
     Elf_Internal_Shdr *hdr;
@


1.124
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d2944 1
a2944 1
  if (data.ofs != 0)
d2946 4
@


1.123
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d2462 1
a2462 1
	      if (! (_bfd_elfNN_link_record_local_dynamic_symbol
d2634 1
a2634 1
	      if (!_bfd_elfNN_link_record_local_dynamic_symbol
d3841 1
a3841 1
  if (!bfd_elfNN_bfd_final_link (abfd, info))
d4599 1
a4599 1
	     first place.  But perhaps elflink.h did some for us.  */
@


1.122
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d195 1
a195 1
  PARAMS ((bfd *abfd, struct bfd_link_info *info, const Elf_Internal_Sym *sym,
d1433 1
a1433 1
     const Elf_Internal_Sym *sym;
@


1.121
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d3086 1
a3086 1
  bfd_elfNN_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.120
log
@Patch from Steve Ellcey for potential race condition.
	* elfxx-ia64.c (plt_full_entry): Change ld8 to ld8.acq.
@
text
@d2 2
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d3978 1
d3980 4
a3983 5
	  RELOC_FOR_GLOBAL_SYMBOL (h, elf_sym_hashes (input_bfd),
				   r_symndx,
				   symtab_hdr, value, sym_sec,
				   unresolved_reloc, info,
				   warned);
@


1.119
log
@2004-02-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_check_relocs): Fix call to
	count_dyn_reloc.
@
text
@d638 1
a638 1
  0x00, 0x41, 0x3c, 0x30, 0x28, 0xc0,  /*               ld8 r16=[r15],8    */
@


1.118
log
@2004-02-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_dyn_reloc_entry): Add the reltext.
	field to track if a relocation is against readonly section.
	(count_dyn_reloc): Take a new argument for rent->reltext.
	(elfNN_ia64_check_relocs): Adjust call to count_dyn_reloc.
	(get_reloc_section): Don't set ia64_info->reltext here.
	(allocate_dynrel_entries): Set ia64_info->reltext here.
@
text
@d2490 1
a2490 1
				(sec->flags & SEC_READONLY)))
@


1.117
log
@2004-01-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_brl): New function.
	(elfNN_ia64_relax_section): Optimize brl to br during the relax
	finalize pass.
@
text
@d95 3
a248 3
static bfd_boolean count_dyn_reloc
  PARAMS ((bfd *abfd, struct elfNN_ia64_dyn_sym_info *dyn_i,
	   asection *srel, int type));
a2177 3
  if (sec->flags & SEC_READONLY)
    ia64_info->reltext = 1;

d2182 2
a2183 5
count_dyn_reloc (abfd, dyn_i, srel, type)
     bfd *abfd;
     struct elfNN_ia64_dyn_sym_info *dyn_i;
     asection *srel;
     int type;
d2204 1
d2489 2
a2490 1
	  if (!count_dyn_reloc (abfd, dyn_i, srel, dynrel_type))
d2797 2
@


1.117.6.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
a94 3

    /* Is this reloc against readonly section? */
    bfd_boolean reltext;
d191 1
a191 1
  PARAMS ((bfd *abfd, struct bfd_link_info *info, Elf_Internal_Sym *sym,
d246 3
d638 1
a638 1
  0x00, 0x41, 0x3c, 0x70, 0x29, 0xc0,  /*               ld8.acq r16=[r15],8*/
d1432 1
a1432 1
     Elf_Internal_Sym *sym;
d2178 3
d2185 5
a2189 2
count_dyn_reloc (bfd *abfd, struct elfNN_ia64_dyn_sym_info *dyn_i,
		 asection *srel, int type, bfd_boolean reltext)
a2209 1
  rent->reltext = reltext;
d2494 1
a2494 2
	  if (!count_dyn_reloc (abfd, dyn_i, srel, dynrel_type,
				(sec->flags & SEC_READONLY) != 0))
a2800 2
      if (rent->reltext)
	ia64_info->reltext = 1;
d3087 1
a3087 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
a3978 1
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
d3980 5
a3984 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sym_sec, value,
				   unresolved_reloc, warned);
@


1.117.6.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d2462 1
a2462 1
	      if (! (bfd_elf_link_record_local_dynamic_symbol
d2634 1
a2634 1
	      if (!bfd_elf_link_record_local_dynamic_symbol
d3841 1
a3841 1
  if (!bfd_elf_final_link (abfd, info))
d4599 1
a4599 1
	     first place.  But perhaps elflink.c did some for us.  */
@


1.117.6.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d183 1
a183 1
  PARAMS((bfd_byte *contents, bfd_vma off));
d189 1
a189 1
  PARAMS ((flagword *, const Elf_Internal_Shdr *));
d276 1
a276 1
  PARAMS ((bfd_byte *hit_addr, bfd_vma val, unsigned int r_type));
d677 1
a677 1
elfNN_ia64_relax_brl (bfd_byte *contents, bfd_vma off)
d685 2
a686 2
  t0 = bfd_getl64 (hit_addr);
  t1 = bfd_getl64 (hit_addr + 8);
d703 2
a704 2
  bfd_putl64 (t0, hit_addr);
  bfd_putl64 (t1, hit_addr + 8);
d752 5
d774 6
a779 1
      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
a791 1
      char symtype;
a866 1
	  symtype = ELF_ST_TYPE (isym->st_info);
a910 2

	  symtype = h->type;
d914 4
a917 27
	{
	  /* At this stage in linking, no SEC_MERGE symbol has been
	     adjusted, so all references to such symbols need to be
	     passed through _bfd_merged_section_offset.  (Later, in
	     relocate_section, all SEC_MERGE symbols *except* for
	     section symbols have been adjusted.)

	     gas may reduce relocations against symbols in SEC_MERGE
	     sections to a relocation against the section symbol when
	     the original addend was zero.  When the reloc is against
	     a section symbol we should include the addend in the
	     offset passed to _bfd_merged_section_offset, since the
	     location of interest is the original symbol.  On the
	     other hand, an access to "sym+addend" where "sym" is not
	     a section symbol should not include the addend;  Such an
	     access is presumed to be an offset from "sym";  The
	     location of interest is just "sym".  */
	   if (symtype == STT_SECTION)
	     toff += irel->r_addend;
	   
	   toff = _bfd_merged_section_offset (abfd, &tsec,
					      elf_section_data (tsec)->sec_info,
					      toff);

	   if (symtype != STT_SECTION)
	     toff += irel->r_addend;
	}
d940 1
a940 1
		  elfNN_ia64_relax_brl (contents, roff);
a956 12
	  /* We can't put a trampoline in a .init/.fini section. Issue
	     an error.  */
	  if (strcmp (sec->output_section->name, ".init") == 0
	      || strcmp (sec->output_section->name, ".fini") == 0)
	    {
	      (*_bfd_error_handler)
		(_("%B: Can't relax br at 0x%lx in section `%A'. Please use brl or indirect branch."),
		 sec->owner, sec, (unsigned long) roff);
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }

d982 1
a982 1
	      trampoff = (sec->size + 15) & (bfd_vma) -16;
d994 1
a994 1
	      sec->size = amt;
d1047 2
a1048 2
	  if (elfNN_ia64_install_value (contents + roff, offset, r_type)
	      != bfd_reloc_ok)
d1087 1
a1087 1
	      elfNN_ia64_relax_ldxmov (contents, roff);
d1150 2
a1151 1
      ia64_info->got_sec->size = data.ofs;
d1175 2
a1176 1
elfNN_ia64_relax_ldxmov (contents, off)
d1192 1
a1192 1
  dword = bfd_getl64 (contents + off);
d1204 1
a1204 1
  bfd_putl64 (dword, contents + off);
d1274 1
a1274 1
     const Elf_Internal_Shdr *hdr;
d1340 3
a1342 1
  asection *s;
d1350 58
a1407 5
	  /* The IA-64 processor-specific ABI requires setting sh_link
	     to the unwind section, whereas HP-UX requires sh_info to
	     do so.  For maximum compatibility, we'll set both for
	     now... */
	  hdr->sh_info = hdr->sh_link;
d2222 1
a2222 1
  asection *got, *fptr, *srel, *pltoff;
d2230 1
a2230 1
  got = fptr = srel = pltoff = NULL;
d2481 1
a2481 12
	{
	  /* This is needed here, in case @@pltoff is used in a non-shared
	     link.  */
	  if (!pltoff)
	    {
	      pltoff = get_pltoff (abfd, info, ia64_info);
	      if (!pltoff)
		return FALSE;
	    }
	  
	  dyn_i->want_pltoff = 1;
	}
d2800 1
a2800 1
      rent->srel->size += sizeof (ElfNN_External_Rela) * count;
d2816 1
a2816 1
	ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
d2819 1
a2819 1
    ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
d2821 1
a2821 1
    ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
d2823 1
a2823 1
    ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
d2827 1
a2827 1
	ia64_info->rel_fptr_sec->size += sizeof (ElfNN_External_Rela);
d2842 1
a2842 1
      ia64_info->rel_pltoff_sec->size += t;
d2902 1
a2902 1
      sec->size = strlen (ELF_DYNAMIC_INTERPRETER) + 1;
d2913 1
a2913 1
      ia64_info->got_sec->size = data.ofs;
d2922 1
a2922 1
      ia64_info->fptr_sec->size = data.ofs;
d2944 1
a2944 1
  if (data.ofs != 0 || ia64_info->root.dynamic_sections_created)
a2945 4
      /* FIXME: we always reserve the memory for dynamic linker even if
	 there are no PLT entries since dynamic linker may assume the
	 reserved memory always exists.  */

d2948 1
a2948 1
      ia64_info->plt_sec->size = data.ofs;
d2953 1
a2953 1
      sec->size = 8 * PLT_RESERVED_WORDS;
d2962 1
a2962 1
      ia64_info->pltoff_sec->size = data.ofs;
d2971 1
a2971 1
	ia64_info->rel_got_sec->size += sizeof (ElfNN_External_Rela);
d2992 1
a2992 1
      strip = (sec->size == 0);
d3069 2
a3070 2
	  sec->contents = (bfd_byte *) bfd_zalloc (dynobj, sec->size);
	  if (sec->contents == NULL && sec->size != 0)
d3124 2
a3125 1
elfNN_ia64_install_value (hit_addr, v, r_type)
d3257 2
a3258 2
      t0 = bfd_getl64 (hit_addr);
      t1 = bfd_getl64 (hit_addr + 8);
d3280 2
a3281 2
      bfd_putl64 (t0, hit_addr);
      bfd_putl64 (t1, hit_addr + 8);
d3286 2
a3287 2
      t0 = bfd_getl64 (hit_addr);
      t1 = bfd_getl64 (hit_addr + 8);
d3305 2
a3306 2
      bfd_putl64 (t0, hit_addr);
      bfd_putl64 (t1, hit_addr + 8);
d3317 1
a3317 1
      dword = bfd_getl64 (hit_addr);
d3327 1
a3327 1
      bfd_putl64 (dword, hit_addr);
d3381 2
a3382 1
  BFD_ASSERT (sizeof (ElfNN_External_Rela) * srel->reloc_count <= srel->size);
d3698 1
a3698 1
      hi = os->vma + os->size;
d3834 1
a3834 1
	    = bfd_malloc (unwind_output_sec->size);
d3848 1
a3848 1
	     (size_t) (unwind_output_sec->size / 24),
d3854 1
a3854 1
				      unwind_output_sec->size))
d3921 2
a3922 2
	    (_("%B: unknown relocation type %d"),
	     input_bfd, (int) r_type);
d3962 2
a3963 1
						    + dynent->addend);
d4027 2
a4028 2
		    (_("%B: non-pic code with imm relocation against dynamic symbol `%s'"),
		     input_bfd,
d4080 1
a4080 1
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4092 2
a4093 2
		(_("%B: @@gprel relocation against dynamic symbol %s"),
		 input_bfd, h->root.root.string);
d4098 1
a4098 1
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4108 1
a4108 1
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4118 1
a4118 1
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4152 2
a4153 2
			(_("%B: linking non-pic code in a position independent executable"),
			 input_bfd);
d4183 1
a4183 1
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4225 1
a4225 1
	    r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4289 1
a4289 1
		msg = _("%B: @@internal branch to dynamic symbol %s");
d4291 1
a4291 1
		msg = _("%B: speculation fixup to dynamic symbol %s");
d4293 3
a4295 2
		msg = _("%B: @@pcrel relocation against dynamic symbol %s");
	      (*_bfd_error_handler) (msg, input_bfd, h->root.root.string);
d4306 1
a4306 1
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4350 2
a4351 1
		  r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4365 1
a4365 1
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4406 3
a4408 2
	  elfNN_ia64_install_value (hit_addr, value, r_type);
	  r = elfNN_ia64_install_value (hit_addr + 8, gp_val, r_type);
d4415 1
a4415 1
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4424 1
a4424 1
	  r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4466 2
a4467 1
	    r = elfNN_ia64_install_value (hit_addr, value, r_type);
d4578 3
a4580 2
      elfNN_ia64_install_value (loc, index, R_IA64_IMM22);
      elfNN_ia64_install_value (loc+2, -dyn_i->plt_offset, R_IA64_PCREL21B);
d4593 2
a4594 1
	  elfNN_ia64_install_value (loc, pltoff_addr - gp_val, R_IA64_IMM22);
d4660 1
a4660 1
      dynconend = (ElfNN_External_Dyn *) (sdyn->contents + sdyn->size);
d4717 1
a4717 1
	  elfNN_ia64_install_value (loc+1, pltres, R_IA64_GPREL22);
d4784 2
a4785 2
	(_("%B: linking trap-on-NULL-dereference with non-trapping files"),
	 ibfd);
d4793 2
a4794 2
	(_("%B: linking big-endian files with little-endian files"),
	 ibfd);
d4802 2
a4803 2
	(_("%B: linking 64-bit files with 32-bit files"),
	 ibfd);
d4811 2
a4812 2
	(_("%B: linking constant-gp files with non-constant-gp files"),
	 ibfd);
d4821 2
a4822 2
	(_("%B: linking auto-pic files with non-auto-pic files"),
	 ibfd);
a5009 7
/* FIXME: PR 290: The Intel C compiler generates SHT_IA_64_UNWIND with
   SHF_LINK_ORDER. But it doesn't set theh sh_link or sh_info fields.
   We don't want to flood users with so many error messages. We turn
   off the warning for now. It will be turned on later when the Intel
   compiler is fixed.   */
#define elf_backend_link_order_error_handler NULL

@


1.117.6.4
log
@Merge from mainline.
@
text
@d1644 6
a1649 4
  dir->root.ref_dynamic |= ind->root.ref_dynamic;
  dir->root.ref_regular |= ind->root.ref_regular;
  dir->root.ref_regular_nonweak |= ind->root.ref_regular_nonweak;
  dir->root.needs_plt |= ind->root.needs_plt;
d2238 1
a2238 1
	  h->ref_regular = 1;
d2247 2
a2248 3
		 && (!info->symbolic
		     || info->unresolved_syms_in_shared_libs == RM_IGNORE))
		|| !h->def_regular
d2447 1
a2447 1
	  h->needs_plt = 1;
d2654 1
a2654 1
      /* ??? Versioned symbols seem to lose NEEDS_PLT.  */
d2842 1
a2842 1
  if (h->u.weakdef != NULL)
d2844 4
a2847 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
                  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d4578 1
a4578 1
	  if (!h->def_regular)
@


1.117.4.1
log
@Patch from Steve Ellcey to eliminate race condition.
	* elfxx-ia64.c (plt_full_entry): Change ld8 to ld8.acq.
@
text
@d638 1
a638 1
  0x00, 0x41, 0x3c, 0x70, 0x29, 0xc0,  /*               ld8.acq r16=[r15],8*/
@


1.117.4.2
log
@Merge from mainline
@
text
@d2 1
a2 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d191 1
a191 1
  PARAMS ((bfd *abfd, struct bfd_link_info *info, Elf_Internal_Sym *sym,
d1432 1
a1432 1
     Elf_Internal_Sym *sym;
d2466 1
a2466 1
	      if (! (bfd_elf_link_record_local_dynamic_symbol
d2637 1
a2637 1
	      if (!bfd_elf_link_record_local_dynamic_symbol
d3087 1
a3087 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d3842 1
a3842 1
  if (!bfd_elf_final_link (abfd, info))
a3978 1
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
d3980 5
a3984 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sym_sec, value,
				   unresolved_reloc, warned);
d4600 1
a4600 1
	     first place.  But perhaps elflink.c did some for us.  */
@


1.117.4.3
log
@Merge to 2.15 branch.
@
text
@a95 3

    /* Is this reloc against readonly section? */
    bfd_boolean reltext;
d247 3
d2179 3
d2186 5
a2190 2
count_dyn_reloc (bfd *abfd, struct elfNN_ia64_dyn_sym_info *dyn_i,
		 asection *srel, int type, bfd_boolean reltext)
a2210 1
  rent->reltext = reltext;
d2495 1
a2495 2
	  if (!count_dyn_reloc (abfd, dyn_i, srel, dynrel_type,
				(sec->flags & SEC_READONLY) != 0))
a2801 2
      if (rent->reltext)
	ia64_info->reltext = 1;
d2946 1
a2946 1
  if (data.ofs != 0 || ia64_info->root.dynamic_sections_created)
a2947 4
      /* FIXME: we always reserve the memory for dynamic linker even if
	 there are no PLT entries since dynamic linker may assume the
	 reserved memory always exists.  */

@


1.116
log
@2004-01-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Disallow imm
	relocations against dynamic symbols.
@
text
@d675 30
d798 2
d805 12
d819 3
d935 19
@


1.115
log
@2004-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Don't install
	trampoline if it is known out of range.
@
text
@d3954 18
d3999 1
a3999 11
		      /* We can't represent this without a dynamic symbol.
			 Adjust the relocation to be against an output
			 section symbol, which are always present in the
			 dynamic symbol table.  */
		      /* ??? People shouldn't be doing non-pic code in
			 shared libraries.  Hork.  */
		      (*_bfd_error_handler)
			(_("%s: linking non-pic code in a shared library"),
			 bfd_archive_filename (input_bfd));
		      ret_val = FALSE;
		      continue;
@


1.114
log
@bfd/

2003-12-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Use the
	need_relax_finalize field in link_info instead of
	relax_finalizing to check if the relax finalize pass is being
	done.

include/

2003-12-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Change relax_finalizing to
	need_relax_finalize.

ld/

2003-12-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/ia64elf.em (gld${EMULATION_NAME}_after_parse): Set
	link_info.need_relax_finalize to TRUE.

	* ldlang.c (lang_process): Use link_info.need_relax_finalize
	instead of link_info.relax_finalizing.
	* ldmain.c (main): Likewise.
@
text
@d879 2
d916 7
d969 6
d979 2
a980 4
	  /* Fix up the existing branch to hit the trampoline.  Hope like
	     hell this doesn't overflow too.  */
	  if (elfNN_ia64_install_value (abfd, contents + roff,
					f->trampoff - (roff & (bfd_vma) -4),
@


1.113
log
@	* elf-bfd.h (is_elf_hash_table): Take hash tab rather than info arg.
	* elf.c (_bfd_elf_merge_sections): Adjust to suit.
	(_bfd_elf_link_just_syms): Likewise.
	(bfd_elf_get_needed_list): Likewise.
	(bfd_elf_get_runpath_list): Likewise.
	(_bfd_elf_link_hash_copy_indirect): Remove unneeded parens.
	* elf32-hppa.c (elf32_hppa_setup_section_lists): Don't check hash tab
	creator flavour.
	(elf32_hppa_set_gp): Look up output sections rather than using htab.
	* elf32-i960.c: Comment fix.  Formatting.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Use is_elf_hash_table
	rather than testing creator flavour.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Adjust for
	is_elf_hash_table change.  Remove redundant test.
	(bfd_elf_record_link_assignment): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_link_record_local_dynamic_symbol): Adjust for is_elf_hash_table.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Likewise.  Remove redundant
	checks.  Use is_elf_hash_table rather than testing creator flavour.
	Use hash_table throughout in place of info->hash.
	(elf_add_dynamic_entry): Adjust for is_elf_hash_table change.
	(NAME(bfd_elf,size_dynamic_sections)): Likewise.  Remove redundant
	check.
	(elf_bfd_final_link): Adjust for is_elf_hash_table change.
	(elf_link_check_versioned_symbol): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_gc_sections): Add is_elf_hash_table check.
	(elf_gc_common_finalize_got_offsets): Likewise.
	(elf_bfd_discard_info): Adjust for is_elf_hash_table change.  Remove
	redundant check.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use is_elf_hash_table
	rather than testing creator flavour.
@
text
@d717 1
a717 1
      || (link_info->relax_finalizing
d768 1
a768 1
	  if (link_info->relax_finalizing)
d775 1
a775 1
	  if (!link_info->relax_finalizing)
d1076 1
a1076 1
  if (link_info->relax_finalizing)
@


1.112
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d710 1
a710 1
  if (link_info->hash->creator->flavour != bfd_target_elf_flavour)
@


1.111
log
@* elf-bfd.h (elf_backend_data::elf_backend_modify_segment_map):
Add link info argument.
* elf32-i370.c (elf_backend_modify_segment_map): Likewise.
* elf32-ppc.c (ppc_elf_modify_segment_map): Likewise.
* elf32-xtensa.c (elf_xtensa_modify_segment_map): Likewise.
* elf64-hppa.c (elf64_hppa_modify_segment_map): Likewise.
* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
* elfxx-mips.h (_bfd_mips_elf_modify_segment_map): Likewise.
* elf.c (assign_file_positions_except_relocs,
assign_file_positions_for_segments): Likewise.  Adjust calls.
@
text
@d56 1
a56 1
 		does not reqire dynamic relocations.  */
d84 1
a84 1
  /* The symbol table entry, if any, that this was derrived from.  */
d807 1
a807 1
	    continue;	/* We can't do anthing with undefined symbols.  */
d855 1
a855 1
	      /* We can't do anthing with undefined symbols.  */
d1957 1
a1957 1
   because it contains "official prodecure descriptors".  The "official"
@


1.110
log
@Fix -pie core dump  with .rela.opd section.
bfd/ChangeLog
	* elfxx-ia64.c (get_fptr): For fptr_rel, use dynobj not abfd.
	(elfNN_ia64_size_dynamic_sections): When stripping sections, check
	for ia64_info->rel_fptr_sec.
ld/ChangeLog
	* emulparams/elf64_ia64.sh (OTHER_PLT_RELOC_SECTIONS): Include
	.rela.opd if -pie.
@
text
@d197 1
a197 1
  PARAMS ((bfd *));
d1408 1
a1408 1
elfNN_ia64_modify_segment_map (abfd)
d1410 1
@


1.109
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy
	ELF_LINK_HASH_NEEDS_PLT.  Fix formatting.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elf32-xtensa.c (elf_xtensa_copy_indirect_symbol): Remove.
	(elf_backend_copy_indirect_symbol): Don't define.
@
text
@d1996 1
a1996 1
	  fptr_rel = bfd_make_section(abfd, ".rela.opd");
d1998 1
a1998 1
	      || !bfd_set_section_flags (abfd, fptr_rel,
d2930 9
@


1.108
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d1595 2
a1596 1
        | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
@


1.107
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d3849 1
d3852 2
a3853 1
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, sym_sec, rel);
a3863 1
		  asection *msec;
@


1.106
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d3547 1
a3547 2
  struct elf_link_tls_segment *tls_segment
    = elf_hash_table (info)->tls_segment;
d3549 2
a3550 3
  BFD_ASSERT (tls_segment != NULL);
  return (tls_segment->start
	  - align_power ((bfd_vma) 16, tls_segment->align));
d3561 2
a3562 2
  BFD_ASSERT (elf_hash_table (info)->tls_segment != NULL);
  return elf_hash_table (info)->tls_segment->start;
@


1.105
log
@	* elfxx-ia64.c: Include objalloc.h, hashtab.h.
	(struct elfNN_ia64_local_hash_entry): Remove root. Add id and r_sym
	fields.
	(struct elfNN_ia64_local_hash_table): Remove.
	(struct elfNN_ia64_link_hash_table): Change loc_hash_table's type
	to htab_t.  Add loc_hash_memory field.
	(elfNN_ia64_local_hash_table_init, elfNN_ia64_new_loc_hash_entry):
	Removed.
	(elfNN_ia64_local_htab_hash, elfNN_ia64_local_htab_eq): New
	functions.
	(elfNN_ia64_hash_table_create): Use hashtab.h hashtable for
	loc_hash_table.  Initialize loc_hash_memory.
	(elfNN_ia64_hash_table_free): New function.
	(elfNN_ia64_local_hash_lookup): Remove.
	(elfNN_ia64_local_dyn_sym_thunk): Change into htab_traverse
	callback.
	(elfNN_ia64_dyn_sym_traverse): Use htab_traverse.
	(get_local_sym_hash): Use hashtab.h hashtable for loc_hash_table.
	(bfd_elfNN_bfd_link_hash_table_free): Define.
@
text
@a4902 1
#define elf_backend_plt_header_size	PLT_HEADER_SIZE
@


1.104
log
@bfd/

2003-10-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd-in.h (bfd_elf32_ia64_after_parse): New prototype.
	(bfd_elf64_ia64_after_parse): Likewise.
	* bfd-in2.h: Regenerated.

	* elfxx-ia64.c (oor_ip): New.
	(oor_branch_size): Likewise.
	(bfd_elfNN_ia64_after_parse): Likewise.
	(elfNN_ia64_relax_section): Use oor_ip if oor_branch_size
	equals sizeof (oor_ip).

ld/

2003-10-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (eelf64_ia64.c): Also depend on
	$(srcdir)/emultempl/ia64elf.em.
	* Makefile.in: Regenerated.

	* emulparams/elf64_ia64.sh (EXTRA_EM_FILE): Set to ia64elf.

	* emultempl/ia64elf.em: New.
@
text
@d27 2
d120 2
a121 1
  struct bfd_hash_entry root;
a128 6
struct elfNN_ia64_local_hash_table
{
  struct bfd_hash_table root;
  /* No additional fields for now.  */
};

d153 2
a154 1
  struct elfNN_ia64_local_hash_table loc_hash_table;
a201 6
static bfd_boolean elfNN_ia64_local_hash_table_init
  PARAMS ((struct elfNN_ia64_local_hash_table *ht, bfd *abfd,
	   new_hash_entry_func new));
static struct bfd_hash_entry *elfNN_ia64_new_loc_hash_entry
  PARAMS ((struct bfd_hash_entry *entry, struct bfd_hash_table *table,
	   const char *string));
d210 3
d215 2
a216 3
static struct elfNN_ia64_local_hash_entry *elfNN_ia64_local_hash_lookup
  PARAMS ((struct elfNN_ia64_local_hash_table *table, const char *string,
	   bfd_boolean create, bfd_boolean copy));
d219 2
a220 2
static bfd_boolean elfNN_ia64_local_dyn_sym_thunk
  PARAMS ((struct bfd_hash_entry *, PTR));
a1548 38
static bfd_boolean
elfNN_ia64_local_hash_table_init (ht, abfd, new)
     struct elfNN_ia64_local_hash_table *ht;
     bfd *abfd ATTRIBUTE_UNUSED;
     new_hash_entry_func new;
{
  memset (ht, 0, sizeof (*ht));
  return bfd_hash_table_init (&ht->root, new);
}

static struct bfd_hash_entry*
elfNN_ia64_new_loc_hash_entry (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct elfNN_ia64_local_hash_entry *ret;
  ret = (struct elfNN_ia64_local_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (!ret)
    ret = bfd_hash_allocate (table, sizeof (*ret));

  if (!ret)
    return 0;

  /* Initialize our local data.  All zeros, and definitely easier
     than setting a handful of bit fields.  */
  memset (ret, 0, sizeof (*ret));

  /* Call the allocation method of the superclass.  */
  ret = ((struct elfNN_ia64_local_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));

  return (struct bfd_hash_entry *) ret;
}

d1648 27
d1696 4
a1699 2
  if (!elfNN_ia64_local_hash_table_init (&ret->loc_hash_table, abfd,
				         elfNN_ia64_new_loc_hash_entry))
d1708 1
a1708 1
/* Look up an entry in a Alpha ELF linker hash table.  */
d1710 3
a1712 5
static INLINE struct elfNN_ia64_local_hash_entry *
elfNN_ia64_local_hash_lookup(table, string, create, copy)
     struct elfNN_ia64_local_hash_table *table;
     const char *string;
     bfd_boolean create, copy;
d1714 7
a1720 2
  return ((struct elfNN_ia64_local_hash_entry *)
	  bfd_hash_lookup (&table->root, string, create, copy));
d1752 2
a1753 2
elfNN_ia64_local_dyn_sym_thunk (xentry, xdata)
     struct bfd_hash_entry *xentry;
d1757 1
a1757 1
    = (struct elfNN_ia64_local_hash_entry *) xentry;
d1764 2
a1765 2
      return FALSE;
  return TRUE;
d1781 2
a1782 2
  bfd_hash_traverse (&ia64_info->loc_hash_table.root,
		     elfNN_ia64_local_dyn_sym_thunk, &xdata);
d1844 1
a1844 1
  struct elfNN_ia64_local_hash_entry *ret;
d1846 8
a1853 1
  char addr_name [34];
d1855 2
a1856 2
  BFD_ASSERT ((sizeof (sec->id)*2 + 1 + sizeof (unsigned long)*2 + 1) <= 34);
  BFD_ASSERT (sec);
d1858 2
a1859 2
  /* Construct a string for use in the elfNN_ia64_local_hash_table.
     name describes what was once anonymous memory.  */
d1861 10
a1870 6
  sprintf (addr_name, "%x:%lx",
	   sec->id, (unsigned long) ELFNN_R_SYM (rel->r_info));

  /* Collect the canonical entry data for this address.  */
  ret = elfNN_ia64_local_hash_lookup (&ia64_info->loc_hash_table,
				      addr_name, create, create);
d4873 2
@


1.103
log
@	* elfxx-ia64.c (ia64_howto_table): Fix size of R_IA64_TPREL64[LM]SB,
	R_IA64_DTPREL{32,64}[LM]SB and R_IA64_DTPMOD64[LM]SB.
@
text
@d659 22
d916 1
a916 3
		{
		  size = sizeof (oor_brl);
		}
d937 16
a952 4
		  memcpy (contents + trampoff, oor_brl, size);
		  irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
					       R_IA64_PCREL60B);
		  irel->r_offset = trampoff + 2;
@


1.102
log
@2003-09-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_hpux_backend_symbol_processing): New.
	Handle SHN_IA_64_ANSI_COMMON.
	(elf_backend_section_from_bfd_section): Defined.
@
text
@d449 2
a450 2
    IA64_HOWTO (R_IA64_TPREL64MSB,  "TPREL64MSB",  8, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64LSB,  "TPREL64LSB",  8, FALSE, FALSE),
d453 2
a454 2
    IA64_HOWTO (R_IA64_DTPMOD64MSB, "TPREL64MSB",  8, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPMOD64LSB, "TPREL64LSB",  8, FALSE, FALSE),
d460 4
a463 4
    IA64_HOWTO (R_IA64_DTPREL32MSB, "DTPREL32MSB", 4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL32LSB, "DTPREL32LSB", 4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64MSB, "DTPREL64MSB", 8, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64LSB, "DTPREL64LSB", 8, FALSE, FALSE),
@


1.101
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@d4787 17
d4900 3
@


1.100
log
@2003-09-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_special_sections): Mark all sections
	started with ".sbss" or "".sdata" as SHF_IA_64_SHORT.
@
text
@d4751 3
a4753 6
  { ".sbss",		5,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { ".sdata",		6,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.99
log
@2003-08-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_create_dynamic_sections): Align the
	.got section at 8 bytes.
@
text
@d4751 1
a4751 1
  { ".sbss",		0,	NULL,	0,
d4753 1
a4753 1
  { ".sdata",		0,	NULL,	0,
@


1.98
log
@Better handking for unresolved symbols
@
text
@d1784 2
@


1.97
log
@	* elf32-i386.c (elf_i386_relocate_section): Make undefined symbols
	fatal if -pie.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(ppc_elf_relocate_section) <case R_PPC_RELAX32>: Issue fatal error
	on undefined symbols if -pie.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
@
text
@d2165 1
a2165 1
		      && (!info->symbolic || info->allow_shlib_undefined))
d3855 2
a3856 1
	  long indx;
d3858 5
a3862 20
	  /* Reloc against global symbol.  */
	  indx = r_symndx - symtab_hdr->sh_info;
	  h = elf_sym_hashes (input_bfd)[indx];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  value = 0;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sym_sec = h->root.u.def.section;

	      /* Detect the cases that sym_sec->output_section is
		 expected to be NULL -- all cases in which the symbol
		 is defined in another shared module.  This includes
		 PLT relocs for which we've created a PLT entry and
		 other relocs for which we're prepared to create
		 dynamic relocations.  */
	      /* ??? Just accept it NULL and continue.  */
d3864 1
a3864 8
	      if (sym_sec->output_section != NULL)
		{
		  value = (h->root.u.def.value
			   + sym_sec->output_section->vma
			   + sym_sec->output_offset);
		}
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
d3866 2
a3867 14
	  else if (! info->executable
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    ;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (info->executable || info->no_undefined
		       || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	      continue;
	    }
@


1.96
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d3896 1
a3896 1
		      (!info->shared || info->no_undefined
@


1.95
log
@2003-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (get_got): Align the .got section at 8 bytes.
@
text
@d214 1
a214 1
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
d1592 1
a1592 1
     struct elf_backend_data *bed ATTRIBUTE_UNUSED;
@


1.94
log
@2003-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Use
	ElfNN_External_Rela instead of Elf64_External_Rela.
@
text
@d1910 4
@


1.93
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d4526 1
a4526 1
	      * sizeof (Elf64_External_Rela));
@


1.92
log
@2003-07-21  H.J. Lu <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections): Mark
	output_bfd unused to silence gcc.
@
text
@d4776 10
d4893 1
@


1.91
log
@        * elflink.c (_bfd_elf_dynamic_symbol_p): New.
        * elf-bfd.h (_bfd_elf_dynamic_symbol_p): Declare it.
        (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Use it.
        * elf32-xtensa.c (xtensa_elf_dynamic_symbol_p): Likewise.
        * elf64-alpha.c (alpha_elf_dynamic_symbol_p): Likewise.
        * elf64-hppa.c (elf64_hppa_dynamic_symbol_p): Likewise.
        * elfxx-ia64.c (elfNN_ia64_dynamic_symbol_p): Likewise.
        Update all callers to provide the relocation being resolved.
@
text
@d2763 1
a2763 1
     bfd *output_bfd;
@


1.90
log
@        * config.bfd, configure.host, configure.in: Remove ia64-aix support.
        * elfxx-ia64.c, targets.c: Likewise.
@
text
@d203 1
a203 1
  PARAMS ((struct elf_link_hash_entry *h, struct bfd_link_info *info));
d834 1
a834 1
	  else if (elfNN_ia64_dynamic_symbol_p (h, link_info))
d1511 1
a1511 1
elfNN_ia64_dynamic_symbol_p (h, info)
d1514 1
d1516 3
a1518 6
  if (h == NULL)
    return FALSE;

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1520 1
a1520 21
  if (h->dynindx == -1)
    return FALSE;
  switch (ELF_ST_VISIBILITY (h->other))
    {
    case STV_INTERNAL:
    case STV_HIDDEN:
      return FALSE;
    default:
      break;
    }

  if (h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_defweak)
    return TRUE;

  /* If it isn't defined locally, then clearly it's dynamic.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
    return TRUE;

  /* Identify the cases where name binding rules say it resolves local.  */
  return !(info->executable || info->symbolic);
d2396 1
a2396 1
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info))
d2408 1
a2408 1
      if (elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info))
d2445 1
a2445 1
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info))
d2463 1
a2463 1
      && !elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info))
d2557 1
a2557 1
      if (elfNN_ia64_dynamic_symbol_p (h, x->info))
d2635 4
a2638 1
  dynamic_symbol = elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info);
d3326 1
a3326 1
           || elfNN_ia64_dynamic_symbol_p (dyn_i->h, info)
a3790 1
      bfd_boolean local_symbol_p;
d3901 1
a3901 6
      dynamic_symbol_p = elfNN_ia64_dynamic_symbol_p (h, info);
      /* Is this symbol locally defined? A protected symbol is locallly
	 defined. But its function descriptor may not. Use it with
	 caution.  */
      local_symbol_p = (! dynamic_symbol_p
			|| ELF_ST_VISIBILITY (h->other) != STV_DEFAULT);
d3930 1
a3930 1
	      if (! local_symbol_p)
d4278 1
a4278 1
	      if (local_symbol_p)
@


1.89
log
@        * elfxx-ia64.c (elfNN_ia64_dynamic_symbol_p): Properly return false
        for symbols defined locally plus -Bsymbolic.  Tidy logic.
@
text
@a195 8
static bfd_boolean elfNN_ia64_aix_vec
  PARAMS ((const bfd_target *vec));
static bfd_boolean elfNN_ia64_aix_add_symbol_hook
  PARAMS ((bfd *abfd, struct bfd_link_info *info, const Elf_Internal_Sym *sym,
	   const char **namep, flagword *flagsp, asection **secp,
	   bfd_vma *valp));
static bfd_boolean elfNN_ia64_aix_link_add_symbols
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
a651 3
#define AIX_DYNAMIC_INTERPRETER "/usr/lib/ia64l64/libc.so.1"
#define DYNAMIC_INTERPRETER(abfd) \
  (elfNN_ia64_aix_vec (abfd->xvec) ? AIX_DYNAMIC_INTERPRETER : ELF_DYNAMIC_INTERPRETER)
a1358 108
static bfd_boolean
elfNN_ia64_aix_vec (const bfd_target *vec)
{
  extern const bfd_target bfd_elfNN_ia64_aix_little_vec;
  extern const bfd_target bfd_elfNN_ia64_aix_big_vec;

  return (/**/vec == & bfd_elfNN_ia64_aix_little_vec
	  ||  vec == & bfd_elfNN_ia64_aix_big_vec);
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to handle OS-specific symbols.  */

static bfd_boolean
elfNN_ia64_aix_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp;
     asection **secp;
     bfd_vma *valp;
{
  if (strcmp (*namep, "__GLOB_DATA_PTR") == 0)
    {
      /* Define __GLOB_DATA_PTR when it is encountered.  This is expected to
	 be a linker-defined symbol by the Aix C runtime startup code. IBM sez
	 no one else should use it b/c it is undocumented.  */
      struct elf_link_hash_entry *h;

      h = elf_link_hash_lookup (elf_hash_table (info), *namep,
				FALSE, FALSE, FALSE);
      if (h == NULL)
	{
	  struct elf_backend_data *bed;
	  struct elfNN_ia64_link_hash_table *ia64_info;
	  struct bfd_link_hash_entry *bh = NULL;

	  bed = get_elf_backend_data (abfd);
	  ia64_info = elfNN_ia64_hash_table (info);

	  if (!(_bfd_generic_link_add_one_symbol
		(info, abfd, *namep, BSF_GLOBAL,
		 bfd_get_section_by_name (abfd, ".bss"),
		 bed->got_symbol_offset, (const char *) NULL, FALSE,
		 bed->collect, &bh)))
	    return FALSE;

	  h = (struct elf_link_hash_entry *) bh;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  h->type = STT_OBJECT;

	  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      return TRUE;
    }
  else if (sym->st_shndx == SHN_LOOS)
    {
      unsigned int i;

      /* SHN_AIX_SYSCALL: Treat this as any other symbol.  The special symbol
	 is only relevant when compiling code for extended system calls.
	 Replace the "special" section with .text, if possible.
	 Note that these symbols are always assumed to be in .text. */
      for (i = 1; i < elf_numsections (abfd); i++)
	{
	  asection * sec = bfd_section_from_elf_index (abfd, i);

	  if (sec && strcmp (sec->name, ".text") == 0)
	    {
	      *secp = sec;
	      break;
	    }
	}

      if (*secp == NULL)
	*secp = bfd_abs_section_ptr;

      *valp = sym->st_size;

      return TRUE;
    }
  else
    {
      return elfNN_ia64_add_symbol_hook (abfd, info, sym,
					 namep, flagsp, secp, valp);
    }
}

bfd_boolean
elfNN_ia64_aix_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  /* Make sure dynamic sections are always created.  */
  if (! elf_hash_table (info)->dynamic_sections_created
      && abfd->xvec == info->hash->creator)
    {
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	return FALSE;
    }

  /* Now do the standard call.  */
  return bfd_elfNN_bfd_link_add_symbols (abfd, info);
}

d2185 1
a2185 2
		|| h->root.type == bfd_link_hash_defweak
		|| elfNN_ia64_aix_vec (abfd->xvec)))
d2242 1
a2242 1
	  if (info->shared || h || elfNN_ia64_aix_vec (abfd->xvec))
d2294 1
a2294 4
	  if (info->shared || maybe_dynamic
	      || (elfNN_ia64_aix_vec (abfd->xvec)
		  && (!h || strcmp (h->root.root.string,
				    "__GLOB_DATA_PTR") != 0)))
d2368 1
a2368 3
	  if (!h && (info->shared
		     /* AIX also needs one */
		     || elfNN_ia64_aix_vec (abfd->xvec)))
d2418 1
a2418 4
      && (elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info)
	  || (elfNN_ia64_aix_vec (x->info->hash->creator)
	      && (!dyn_i->h || strcmp (dyn_i->h->root.root.string,
				       "__GLOB_DATA_PTR") != 0))))
d2467 1
a2467 2
      && (elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info)
	  || elfNN_ia64_aix_vec (x->info->hash->creator)))
d2485 1
a2485 2
      && ! (elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info)
	    || elfNN_ia64_aix_vec (x->info->hash->creator)))
d2531 4
a2534 9
      if ((!x->info->executable
	   && (!h
	       || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
	  /* AIX needs an FPTR in this case. */
	  || (elfNN_ia64_aix_vec (x->info->hash->creator)
	      && (!h
		  || h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)))
d2657 1
a2657 5
  dynamic_symbol = elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info)
    || (elfNN_ia64_aix_vec (x->info->hash->creator)
	/* Don't allocate an entry for __GLOB_DATA_PTR */
	&& (!dyn_i->h || strcmp (dyn_i->h->root.root.string,
				 "__GLOB_DATA_PTR") != 0));
d2803 2
a2804 2
      sec->contents = (bfd_byte *) DYNAMIC_INTERPRETER (output_bfd);
      sec->_raw_size = strlen (DYNAMIC_INTERPRETER (output_bfd)) + 1;
a3345 1
	   || elfNN_ia64_aix_vec (abfd->xvec)
d3942 1
a3942 5
	  if ((dynamic_symbol_p || info->shared
	       || (elfNN_ia64_aix_vec (info->hash->creator)
		   /* Don't emit relocs for __GLOB_DATA_PTR on AIX. */
		   && (!h || strcmp (h->root.root.string,
				     "__GLOB_DATA_PTR") != 0)))
a3994 2
	      if (elfNN_ia64_aix_vec (info->hash->creator))
		rel->r_addend = value;
d4159 1
a4159 3
	  if ((dynamic_symbol_p
	       || elfNN_ia64_aix_vec (info->hash->creator))
	      && r_symndx != 0)
a4910 21
/* AIX-specific vectors.  */

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		bfd_elfNN_ia64_aix_little_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		"elfNN-ia64-aix-little"
#undef  TARGET_BIG_SYM
#define TARGET_BIG_SYM			bfd_elfNN_ia64_aix_big_vec
#undef  TARGET_BIG_NAME
#define TARGET_BIG_NAME			"elfNN-ia64-aix-big"

#undef  elf_backend_add_symbol_hook
#define elf_backend_add_symbol_hook 	elfNN_ia64_aix_add_symbol_hook

#undef  bfd_elfNN_bfd_link_add_symbols
#define bfd_elfNN_bfd_link_add_symbols 	elfNN_ia64_aix_link_add_symbols

#define elfNN_bed elfNN_ia64_aix_bed

#include "elfNN-target.h"

a4918 8

/* We need to undo the AIX specific functions.  */

#undef  elf_backend_add_symbol_hook
#define elf_backend_add_symbol_hook	elfNN_ia64_add_symbol_hook

#undef  bfd_elfNN_bfd_link_add_symbols
#define bfd_elfNN_bfd_link_add_symbols	_bfd_generic_link_add_symbols
@


1.88
log
@2003-07-10  H.J. Lu <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (IA64_HOWTO): Set dst_mask to -1 instead of
	-1LL.
@
text
@d1656 2
a1657 4
  if ((!info->executable && (!info->symbolic || info->allow_shlib_undefined))
      || ((h->elf_link_hash_flags
	   & (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))
	  == (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR)))
d1660 2
a1661 1
  return FALSE;
@


1.87
log
@2003-07-09  H.J. Lu <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (IA64_HOWTO): Set dst_mask to -1LL.
@
text
@d371 1
a371 1
	 elfNN_ia64_reloc, NAME, FALSE, 0, -1LL, IN)
@


1.86
log
@bfd/
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add rel_fptr_sec.
	(elfNN_ia64_dynamic_symbol_p): Change info->shared into
	!info->executable.
	(get_fptr): For -pie create .opd as writable section and create
	.rela.opd as well.
	(elfNN_ia64_check_relocs): Change info->shared into
	!info->executable.
	(allocate_fptr): Likewise.
	(allocate_dynrel_entries): Account for a relative reloc for -pie
	@@fptr().  Don't account for a relative reloc if -pie want_ltoff_fptr
	for undefweak symbol.  Account for an IPLT reloc in .rela.opd
	section if -pie.
	(set_got_entry): Don't create a relative reloc if -pie
	want_ltoff_fptr for undefweak symbol.
	(set_fptr_entry): Emit an IPLT reloc in .rela.opd for -pie.
	(elfNN_ia64_relocate_section): Emit a relative reloc for -pie
	@@fptr().

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Issue undefined_symbol
	even if -pie.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
ld/
	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Don't include
	.opd if -pie.
	(OTHER_READWRITE_SECTIONS): Include .opd if -pie.
	* scripttempl/elf.sc: Use SHLIB_DATA_ADDR instead of DATA_ADDR
	if -pie.
@
text
@d371 1
a371 1
	 elfNN_ia64_reloc, NAME, FALSE, 0, 0, IN)
@


1.85
log
@Correct spelling of "relocatable".
@
text
@d146 1
d1656 1
a1656 1
  if ((info->shared && (!info->symbolic || info->allow_shlib_undefined))
d2067 1
a2067 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d2087 1
a2087 1
				      | SEC_READONLY
d2096 20
d2302 1
a2302 1
      if (h && ((info->shared
d2662 1
a2662 1
      if ((x->info->shared
d2812 5
a2816 4
	  /* Allocate one iff !want_fptr, which by this point will
	     be true only if we're actually allocating one statically
	     in the main executable.  */
	  if (dyn_i->want_fptr)
d2853 7
a2859 1
    ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
d2866 5
d3480 12
a3491 8
      if ((info->shared
	   && (!dyn_i->h
	       || ELF_ST_VISIBILITY (dyn_i->h->other) == STV_DEFAULT
	       || dyn_i->h->root.type != bfd_link_hash_undefweak)
	   && dyn_r_type != R_IA64_DTPREL64LSB)
          || elfNN_ia64_dynamic_symbol_p (dyn_i->h, info)
	  || elfNN_ia64_aix_vec (abfd->xvec)
	  || (dynindx != -1 && dyn_r_type == R_IA64_FPTR64LSB))
d3570 18
d4044 1
a4044 1
	  else if (info->shared
d4204 1
a4204 1
	  else
d4207 2
d4213 21
a4233 1
	      if (h)
d4241 1
d4247 1
d4251 2
a4252 3
					    srel, rel->r_offset, r_type,
					    dynindx, rel->r_addend);
	      value = 0;
@


1.84
log
@2003-06-17  Roland McGrath  <roland@@redhat.com>

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Support
	segment-relative relocation between different segments.
@
text
@d1344 1
a1344 1
      && !info->relocateable
d2231 1
a2231 1
  if (info->relocateable)
d3782 1
a3782 1
  if (!info->relocateable)
d3808 1
a3808 1
  if (!info->relocateable)
d3866 1
a3866 1
  if (info->relocateable)
@


1.83
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@d4328 1
a4328 1
		    if (m->sections[i] == sym_sec->output_section)
@


1.82
log
@	* cpu-arm.c (arm_check_note): Warning fix.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Warning fixes.  Arrange
	to keep relocs if edited.
	(iq2000_elf_print_private_bfd_data): Return TRUE.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use ELFNN_R_SYM, not
	ELF64_R_SYM.
	(elfNN_ia64_relax_ldxmov): Warning fix.
	* xtensa-isa.c (xtensa_add_isa): Warning fix.
	* xtensa-modules.c (get_num_opcodes): Warning fix.
@
text
@d2906 1
a2906 1
      && !info->shared)
d3081 1
a3081 1
      if (!info->shared)
@


1.81
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d799 1
a799 1
	  isym = isymbuf + ELF64_R_SYM (irel->r_info);
d1092 1
a1092 1
    case 3:
@


1.80
log
@2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (_bfd_elf_link_hash_hide_symbol): Also clear the
	want_plt field.
	(elfNN_ia64_relocate_section): Don't do dynamic symbol lookup
	for symbols with non-default visibility.
@
text
@d723 1
a723 1
  internal_relocs = (_bfd_elfNN_link_read_relocs
d1469 1
a1469 1
      if (! bfd_elfNN_link_create_dynamic_sections (abfd, info))
@


1.79
log
@bfd/

2003-05-04  H.J. Lu <hjl@@gnu.org>

	* elf32-i386.c (allocate_dynrelocs): Don't allocate dynamic
	relocation entries for weak undefined symbols with non-default
	visibility.
	(elf_i386_relocate_section): Initialize the GOT entries and
	skip R_386_32/R_386_PC32 for weak undefined symbols with
	non-default visibility.

	* elfxx-ia64.c (allocate_fptr): Don't allocate function
	descriptors for weak undefined symbols with non-default
	visibility.
	(allocate_dynrel_entries): Don't allocate relocation entries
	for symbols resolved to 0.
	(set_got_entry): Don't install dynamic relocation for weak
	undefined symbols with non-default visibility.
	(set_pltoff_entry): Likewise.

	* elflink.h (elf_fix_symbol_flags): Hide weak undefined symbols
	with non-default visibility.
	(elf_link_output_extsym): Don't make weak undefined symbols
	with non-default visibility dynamic.

ld/testsuite/

2003-05-04  H.J. Lu <hjl@@gnu.org>

	* ld-elfvsb/main.c: Updated.
	* ld-elfvsb/sh1.c: Likewise.
@
text
@d1795 4
a1798 1
    dyn_i->want_plt2 = 0;
d3896 1
d4008 5
d4045 1
a4045 1
	      if (dynamic_symbol_p)
d4374 1
a4374 1
	      if (! dynamic_symbol_p)
@


1.78
log
@bfd/

2003-04-28  H.J. Lu <hjl@@gnu.org>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Relax ldxmov during
	the relax finalize pass.

	* section.c (struct sec): Add need_finalize_relax and remove
	flag11.
	(STD_SECTION): Update struct sec initializer.
	* bfd-in2.h: Regenerated.

include/

2003-04-28  H.J. Lu <hjl@@gnu.org>

	* bfdlink.h (bfd_link_info): Add relax_finalizing.

ld/

2003-04-28  H.J. Lu <hjl@@gnu.org>

	* ldlang.c (lang_process): Add the relax finalize pass.

	* ldmain.c (main): Initialize link_info.relax_finalizing to
	FALSE.
@
text
@d2638 4
a2641 1
      if (x->info->shared
d2766 1
a2766 1
  bfd_boolean dynamic_symbol, shared;
d2773 1
a2773 1
	  "__GLOB_DATA_PTR") != 0));
d2775 3
d2822 6
a2827 2
  if (((dynamic_symbol || shared) && (dyn_i->want_got || dyn_i->want_gotx))
      || (dyn_i->want_ltoff_fptr && dyn_i->h && dyn_i->h->dynindx != -1))
d2836 1
a2836 1
  if (dyn_i->want_pltoff)
d3444 5
a3448 1
      if ((info->shared && dyn_r_type != R_IA64_DTPREL64LSB)
d3569 5
a3573 1
      if (!is_plt && info->shared)
@


1.77
log
@2003-04-09  H.J. Lu <hjl@@gnu.org>

	* elf64-alpha.c (elf64_alpha_relocate_section): Don't return
	FALSE for undefined symbols.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
@
text
@d707 2
a708 1
  /* Nothing to do if there are no relocations.  */
d710 3
a712 1
      || sec->reloc_count == 0)
d762 2
d769 5
d1059 3
@


1.77.2.1
log
@Merge from mainline.
@
text
@d707 1
a707 2
  /* Nothing to do if there are no relocations or there is no need for
     the relax finalize pass.  */
d709 1
a709 3
      || sec->reloc_count == 0
      || (link_info->relax_finalizing
	  && sec->need_finalize_relax == 0))
a758 2
	  if (link_info->relax_finalizing)
	    continue;
a763 5
	  if (!link_info->relax_finalizing)
	    {
	      sec->need_finalize_relax = 1;
	      continue;
	    }
a1048 3

  if (link_info->relax_finalizing)
    sec->need_finalize_relax = 0;
@


1.77.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d723 1
a723 1
  internal_relocs = (_bfd_elf_link_read_relocs
d799 1
a799 1
	  isym = isymbuf + ELFNN_R_SYM (irel->r_info);
d1092 1
a1092 1
    default:
d1469 1
a1469 1
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
d1795 1
a1795 4
    {
      dyn_i->want_plt2 = 0;
      dyn_i->want_plt = 0;
    }
d2638 1
a2638 4
      if ((x->info->shared
	   && (!h
	       || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
d2763 1
a2763 1
  bfd_boolean dynamic_symbol, shared, resolved_zero;
d2770 1
a2770 1
				 "__GLOB_DATA_PTR") != 0));
a2771 3
  resolved_zero = (dyn_i->h
		   && ELF_ST_VISIBILITY (dyn_i->h->other)
		   && dyn_i->h->root.type == bfd_link_hash_undefweak);
d2816 2
a2817 6
  if ((!resolved_zero
       && (dynamic_symbol || shared)
       && (dyn_i->want_got || dyn_i->want_gotx))
      || (dyn_i->want_ltoff_fptr
	  && dyn_i->h
	  && dyn_i->h->dynindx != -1))
d2826 1
a2826 1
  if (!resolved_zero && dyn_i->want_pltoff)
d3434 1
a3434 5
      if ((info->shared
	   && (!dyn_i->h
	       || ELF_ST_VISIBILITY (dyn_i->h->other) == STV_DEFAULT
	       || dyn_i->h->root.type != bfd_link_hash_undefweak)
	   && dyn_r_type != R_IA64_DTPREL64LSB)
d3555 1
a3555 5
      if (!is_plt
	  && info->shared
	  && (!dyn_i->h
	      || ELF_ST_VISIBILITY (dyn_i->h->other) == STV_DEFAULT
	      || dyn_i->h->root.type != bfd_link_hash_undefweak))
a3874 1
      bfd_boolean local_symbol_p;
a3985 5
      /* Is this symbol locally defined? A protected symbol is locallly
	 defined. But its function descriptor may not. Use it with
	 caution.  */
      local_symbol_p = (! dynamic_symbol_p
			|| ELF_ST_VISIBILITY (h->other) != STV_DEFAULT);
d4018 1
a4018 1
	      if (! local_symbol_p)
d4347 1
a4347 1
	      if (local_symbol_p)
@


1.77.4.1
log
@	Merge from mainline:
	2003-04-28  H.J. Lu <hjl@@gnu.org>
	* elfxx-ia64.c (elfNN_ia64_relax_section): Relax ldxmov during
	the relax finalize pass.

	* section.c (struct sec): Add need_finalize_relax and remove
	flag11.
	(STD_SECTION): Update struct sec initializer.
	* bfd-in2.h: Regenerated.

	2003-04-28  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_merge_symbol): Call elf_backend_copy_indirect_symbol
	to copy any information related to dynamic linking when we flip
	the indirection.

	2003-04-27  H.J. Lu <hjl@@gnu.org>
	* elf-bfd.h (ELF_LINK_DYNAMIC_DEF): New.
	(ELF_LINK_DYNAMIC_WEAK): New.

	* elflink.h (elf_merge_symbol): Add one argument to indicate if
	a symbol should be skipped. Ignore definitions in dynamic
	objects for symbols with non-default visibility.
	(elf_add_default_symbol): Adjusted.
	(elf_link_add_object_symbols): Check if a symbol should be
	skipped. Don't merge the visibility field with the one from
	a dynamic object.
	(elf_link_check_versioned_symbol): Use undef_bfd.
	(elf_link_output_extsym): Warn if a forced local symbol is
	referenced from dynamic objects. Make non-weak undefined symbol
	with non-default visibility a fatal error.
@
text
@d707 1
a707 2
  /* Nothing to do if there are no relocations or there is no need for
     the relax finalize pass.  */
d709 1
a709 3
      || sec->reloc_count == 0
      || (link_info->relax_finalizing
	  && sec->need_finalize_relax == 0))
a758 2
	  if (link_info->relax_finalizing)
	    continue;
a763 5
	  if (!link_info->relax_finalizing)
	    {
	      sec->need_finalize_relax = 1;
	      continue;
	    }
a1048 3

  if (link_info->relax_finalizing)
    sec->need_finalize_relax = 0;
@


1.77.4.2
log
@	* cpu-arm.c (arm_check_note): Warning fix.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Warning fixes.  Arrange
	to keep relocs if edited.
	(iq2000_elf_print_private_bfd_data): Return TRUE.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use ELFNN_R_SYM, not
	ELF64_R_SYM.
	(elfNN_ia64_relax_ldxmov): Warning fix.
	* xtensa-isa.c (xtensa_add_isa): Warning fix.
	* xtensa-modules.c (get_num_opcodes): Warning fix.
	* elf.c (elf_fake_sections): Use correct cast for sh_name.
@
text
@d799 1
a799 1
	  isym = isymbuf + ELFNN_R_SYM (irel->r_info);
d1092 1
a1092 1
    default:
@


1.76
log
@	* simple.c (bfd_simple_get_relocated_section_contents): Add
	parameter symbol_table.  Optionally use it instead of the symbol
	table from the bfd.  Save and restore output offsets and output
	sections  around bfd_get_relocated_section_contents.  Fix a memory
	leak.
	(simple_save_output_info, simple_restore_output_info): New
	functions.
	* bfd-in2.h: Regenerate.
	* dwarf2.c (read_abbrevs): Use
	bfd_simple_get_relocated_section_contents instead of
	bfd_get_section_contents.
	(decode_line_info): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.  Don't call
	find_rela_addend.
	(find_rela_addend): Remove.
	* elfxx-ia64.c (elfNN_ia64_reloc): Weaken sanity check for
	debugging sections.
	(elfNN_ia64_hash_table_create): Create the hash table with malloc,
	not bfd_zalloc.
@
text
@a3965 1
	      ret_val = FALSE;
@


1.76.2.1
log
@Merge with mainline.
@
text
@d3966 1
@


1.75
log
@	* elfxx-ia64.c (elfNN_ia64_relax_section): Reset self_dtpmod_offset
	to -1 before recomputing got offsets.
@
text
@d360 4
d1795 1
a1795 1
  ret = bfd_zalloc (abfd, (bfd_size_type) sizeof (*ret));
d1798 1
d1802 1
a1802 1
      bfd_release (abfd, ret);
d1808 5
a1812 1
    return 0;
@


1.74
log
@2003-03-20  H.J. Lu <hjl@@gnu.org>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Don't try relax for
	non-ELF outputs.
@
text
@d1035 1
@


1.74.2.1
log
@Merge with mainline.
@
text
@a1034 1
      ia64_info->self_dtpmod_offset = (bfd_vma) -1;
@


1.73
log
@	* elfxx-ia64.c (elfNN_ia64_relax_section): Handle relaxation
	againt mergeable sections.  Take r_addend into account when caching
	trampolines.
@
text
@d699 4
@


1.72
log
@        * elfxx-ia64.c (get_dyn_sym_info): Return NULL gracefully for
        local symbols that have no dyninfo.
@
text
@d822 1
d841 9
a849 4
      symaddr = (tsec->output_section->vma
		 + tsec->output_offset
		 + toff
		 + irel->r_addend);
@


1.71
log
@2003-03-03  H.J. Lu <hjl@@gnu.org>

	* elfxx-ia64.c (USE_BRL): Removed.
	(oor_ip): Removed.
@
text
@d1968 5
a1972 1
      BFD_ASSERT (loc_h);
@


1.70
log
@        * elfxx-ia64.c (elfNN_ia64_relax_section): Correct bounds
        for ltoff22x relaxation.
@
text
@a658 5
/* Select out of range branch fixup type.  Note that Itanium does
   not support brl, and so it gets emulated by the kernel.  */
#undef USE_BRL

#ifdef USE_BRL
a664 14
#else
static const bfd_byte oor_ip[48] =
{
  0x04, 0x00, 0x00, 0x00, 0x01, 0x00,  /*  [MLX]        nop.m 0            */
  0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,  /*               movl r15=0         */
  0x01, 0x00, 0x00, 0x60,
  0x03, 0x00, 0x00, 0x00, 0x01, 0x00,  /*  [MII]        nop.m 0            */
  0x00, 0x01, 0x00, 0x60, 0x00, 0x00,  /*               mov r16=ip;;       */
  0xf2, 0x80, 0x00, 0x80,              /*               add r16=r15,r16;;  */
  0x11, 0x00, 0x00, 0x00, 0x01, 0x00,  /*  [MIB]        nop.m 0            */
  0x60, 0x80, 0x04, 0x80, 0x03, 0x00,  /*               mov b6=r16         */
  0x60, 0x00, 0x80, 0x00               /*               br b6;;            */
};
#endif
a880 1
#ifdef USE_BRL
a881 3
#else
		  size = sizeof (oor_ip);
#endif
a902 1
#ifdef USE_BRL
a906 7
#else
		  memcpy (contents + trampoff, oor_ip, size);
		  irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
					       R_IA64_PCREL64I);
		  irel->r_addend -= 16;
		  irel->r_offset = trampoff + 2;
#endif
@


1.69
log
@        * elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add want_gotx;
        (elfNN_ia64_check_relocs): Set it.
        (allocate_global_data_got): Check it.
        (allocate_local_got): Likewise.
        (allocate_dynrel_entries): Likewise.
        (elfNN_ia64_relax_ldxmov): New.
        (elfNN_ia64_relax_section): Handle LTOFF22X, LDXMOV.
        (elfNN_ia64_choose_gp): Split out from ...
        (elfNN_ia64_final_link): ... here.
@
text
@d981 2
a982 2
	  if ((bfd_signed_vma) (symaddr - gp) >= 0x400000
	      ||(bfd_signed_vma) (symaddr - gp) < -0x400000)
@


1.68
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@d105 1
d158 6
d179 2
d311 2
d685 1
a685 5
/* These functions do relaxation for IA-64 ELF.

   This is primarily to support branches to targets out of range;
   relaxation of R_IA64_LTOFF22X and R_IA64_LDXMOV is handled in
   relocate_section directly.  */
d711 2
a739 18
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      unsigned long r_type = ELFNN_R_TYPE (irel->r_info);
      if (r_type == R_IA64_PCREL21B
	  || r_type == R_IA64_PCREL21BI
	  || r_type == R_IA64_PCREL21M
	  || r_type == R_IA64_PCREL21F)
	break;
    }

  /* No branch-type relocations.  */
  if (irel == irelend)
    {
      if (elf_section_data (sec)->relocs != internal_relocs)
	free (internal_relocs);
      return TRUE;
    }

d754 1
a754 1
  for (; irel < irelend; irel++)
d761 2
d764 17
a780 5
      if (r_type != R_IA64_PCREL21B
	  && r_type != R_IA64_PCREL21BI
	  && r_type != R_IA64_PCREL21M
	  && r_type != R_IA64_PCREL21F)
	continue;
d813 1
a818 1
          struct elfNN_ia64_dyn_sym_info *dyn_i;
d832 1
a832 1
	  if (dyn_i && dyn_i->want_plt2)
d842 5
a864 8
      reladdr = (sec->output_section->vma
		 + sec->output_offset
		 + roff) & (bfd_vma) -4;

      /* If the branch is in range, no need to do anything.  */
      if ((bfd_signed_vma) (symaddr - reladdr) >= -0x1000000
	  && (bfd_signed_vma) (symaddr - reladdr) <= 0x0FFFFF0)
	continue;
d866 16
a881 5
      /* If the branch and target are in the same section, you've
	 got one honking big section and we can't help you.  You'll
	 get an error message later.  */
      if (tsec == sec)
	continue;
d883 4
a886 4
      /* Look for an existing fixup to this address.  */
      for (f = fixups; f ; f = f->next)
	if (f->tsec == tsec && f->toff == toff)
	  break;
d888 5
a892 5
      if (f == NULL)
	{
	  /* Two alternatives: If it's a branch to a PLT entry, we can
	     make a copy of the FULL_PLT entry.  Otherwise, we'll have
	     to use a `brl' insn to get where we're going.  */
d894 1
a894 1
	  size_t size;
d896 4
a899 4
	  if (tsec == ia64_info->plt_sec)
	    size = sizeof (plt_full_entry);
	  else
	    {
d901 1
a901 1
	      size = sizeof (oor_brl);
d903 1
a903 1
	      size = sizeof (oor_ip);
d905 9
a913 1
	    }
d915 3
a917 7
	  /* Resize the current section to make room for the new branch.  */
	  trampoff = (sec->_cooked_size + 15) & (bfd_vma) -16;
	  amt = trampoff + size;
	  contents = (bfd_byte *) bfd_realloc (contents, amt);
	  if (contents == NULL)
	    goto error_return;
	  sec->_cooked_size = amt;
d919 20
a938 3
	  if (tsec == ia64_info->plt_sec)
	    {
	      memcpy (contents + trampoff, plt_full_entry, size);
d940 8
a947 4
	      /* Hijack the old relocation for use as the PLTOFF reloc.  */
	      irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
					   R_IA64_PLTOFF22);
	      irel->r_offset = trampoff;
d951 2
a952 12
#ifdef USE_BRL
	      memcpy (contents + trampoff, oor_brl, size);
	      irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
					   R_IA64_PCREL60B);
	      irel->r_offset = trampoff + 2;
#else
	      memcpy (contents + trampoff, oor_ip, size);
	      irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
					   R_IA64_PCREL64I);
	      irel->r_addend -= 16;
	      irel->r_offset = trampoff + 2;
#endif
d955 9
a963 7
	  /* Record the fixup so we don't do it again this section.  */
	  f = (struct one_fixup *) bfd_malloc ((bfd_size_type) sizeof (*f));
	  f->next = fixups;
	  f->tsec = tsec;
	  f->toff = toff;
	  f->trampoff = trampoff;
	  fixups = f;
d967 12
a978 3
	  /* Nop out the reloc, since we're finalizing things here.  */
	  irel->r_info = ELFNN_R_INFO (0, R_IA64_NONE);
	}
d980 4
a983 6
      /* Fix up the existing branch to hit the trampoline.  Hope like
	 hell this doesn't overflow too.  */
      if (elfNN_ia64_install_value (abfd, contents + roff,
				    f->trampoff - (roff & (bfd_vma) -4),
				    r_type) != bfd_reloc_ok)
	goto error_return;
d985 19
a1003 2
      changed_contents = TRUE;
      changed_relocs = TRUE;
d1006 5
d1051 15
d1080 33
d2235 10
a2244 9
	NEED_FPTR = 2,
	NEED_PLTOFF = 4,
	NEED_MIN_PLT = 8,
	NEED_FULL_PLT = 16,
	NEED_DYNREL = 32,
	NEED_LTOFF_FPTR = 64,
	NEED_TPREL = 128,
	NEED_DTPMOD = 256,
	NEED_DTPREL = 512
a2340 1
	case R_IA64_LTOFF22X:
d2345 4
d2430 2
a2431 1
      if (need_entry & (NEED_GOT | NEED_TPREL | NEED_DTPMOD | NEED_DTPREL))
d2441 2
a2501 6
struct elfNN_ia64_allocate_data
{
  struct bfd_link_info *info;
  bfd_size_type ofs;
};

d2512 1
a2512 1
  if (dyn_i->want_got
d2584 1
a2584 1
  if (dyn_i->want_got
d2810 1
a2810 1
  if (((dynamic_symbol || shared) && dyn_i->want_got)
d3627 1
d3629 1
a3629 1
elfNN_ia64_final_link (abfd, info)
d3633 5
a3638 1
  asection *unwind_output_sec;
d3642 41
a3682 2
  /* Make sure we've got ourselves a nice fat __gp value.  */
  if (!info->relocateable)
d3684 1
a3684 5
      bfd_vma min_vma = (bfd_vma) -1, max_vma = 0;
      bfd_vma min_short_vma = min_vma, max_short_vma = 0;
      struct elf_link_hash_entry *gp;
      bfd_vma gp_val;
      asection *os;
d3686 1
a3686 6
      /* Find the min and max vma of all sections marked short.  Also
	 collect min and max vma of any type, for use in selecting a
	 nice gp.  */
      for (os = abfd->sections; os ; os = os->next)
	{
	  bfd_vma lo, hi;
d3688 7
a3694 2
	  if ((os->flags & SEC_ALLOC) == 0)
	    continue;
d3696 11
a3706 4
	  lo = os->vma;
	  hi = os->vma + os->_raw_size;
	  if (hi < lo)
	    hi = (bfd_vma) -1;
d3708 3
a3710 11
	  if (min_vma > lo)
	    min_vma = lo;
	  if (max_vma < hi)
	    max_vma = hi;
	  if (os->flags & SEC_SMALL_DATA)
	    {
	      if (min_short_vma > lo)
		min_short_vma = lo;
	      if (max_short_vma < hi)
		max_short_vma = hi;
	    }
d3712 1
d3714 2
a3715 3
      /* See if the user wants to force a value.  */
      gp = elf_link_hash_lookup (elf_hash_table (info), "__gp", FALSE,
				 FALSE, FALSE);
d3717 9
a3725 8
      if (gp
	  && (gp->root.type == bfd_link_hash_defined
	      || gp->root.type == bfd_link_hash_defweak))
	{
	  asection *gp_sec = gp->root.u.def.section;
	  gp_val = (gp->root.u.def.value
		    + gp_sec->output_section->vma
		    + gp_sec->output_offset);
d3727 4
a3730 1
      else
d3732 6
a3737 1
	  /* Pick a sensible value.  */
d3739 1
a3739 1
	  asection *got_sec = ia64_info->got_sec;
d3741 2
a3742 7
	  /* Start with just the address of the .got.  */
	  if (got_sec)
	    gp_val = got_sec->output_section->vma;
	  else if (max_short_vma != 0)
	    gp_val = min_short_vma;
	  else
	    gp_val = min_vma;
d3744 7
a3750 11
	  /* If it is possible to address the entire image, but we
	     don't with the choice above, adjust.  */
	  if (max_vma - min_vma < 0x400000
	      && max_vma - gp_val <= 0x200000
	      && gp_val - min_vma > 0x200000)
	    gp_val = min_vma + 0x200000;
	  else if (max_short_vma != 0)
	    {
	      /* If we don't cover all the short data, adjust.  */
	      if (max_short_vma - gp_val >= 0x200000)
		gp_val = min_short_vma + 0x200000;
d3752 1
a3752 5
	      /* If we're addressing stuff past the end, adjust back.  */
	      if (gp_val > max_vma)
		gp_val = max_vma - 0x200000 + 8;
	    }
	}
d3754 5
a3758 2
      /* Validate whether all SHF_IA_64_SHORT sections are within
	 range of the chosen GP.  */
d3760 1
a3760 1
      if (max_short_vma != 0)
d3762 3
a3764 18
	  if (max_short_vma - min_short_vma >= 0x400000)
	    {
	      (*_bfd_error_handler)
		(_("%s: short data segment overflowed (0x%lx >= 0x400000)"),
		 bfd_get_filename (abfd),
		 (unsigned long) (max_short_vma - min_short_vma));
	      return FALSE;
	    }
	  else if ((gp_val > min_short_vma
		    && gp_val - min_short_vma > 0x200000)
		   || (gp_val < max_short_vma
		       && max_short_vma - gp_val >= 0x200000))
	    {
	      (*_bfd_error_handler)
		(_("%s: __gp does not cover short data segment"),
		 bfd_get_filename (abfd));
	      return FALSE;
	    }
d3767 2
a3768 2
      _bfd_set_gp_value (abfd, gp_val);

@


1.67
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@a3830 1
		   && (!info->symbolic || info->allow_shlib_undefined)
d3928 1
a3928 1
	  /* FALLTHRU */
d4538 1
a4538 1
      /* Initialize the PLT0 entry */
d4557 1
a4557 1
/* ELF file flag handling: */
@


1.66
log
@	* elfxx-ia64.c (elfNN_ia64_relocate_section): Handle
	R_IA64_TPREL64[LM]SB against non-global symbol properly.

	* ld-ia64/tlspic1.s: Add tests for IE in shared libraries.
	* ld-ia64/tlspic.rd: Adjust.
	* ld-ia64/tlspic.dd: Adjust.
	* ld-ia64/tlspic.sd: Adjust.
@
text
@d3766 1
a3766 2
	      && (elf_section_data (sym_sec)->sec_info_type
		  == ELF_INFO_TYPE_MERGE))
@


1.65
log
@	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add
	self_dtpmod_done and self_dtpmod_offset.
	(allocate_global_data_got): Only use one got entry for all
	dtpmod relocs against local symbols.
	(allocate_dynrel_entries): Only need .rela.got entry for
	dtpmod against global symbol.
	(elfNN_ia64_size_dynamic_sections): Initialize self_dtpmod_offset.
	Reserve space in .rela.got for the local dtpmod entry.
	(set_got_entry): Initialize the common local dtpmod .got entry.
	(elfNN_ia64_relocate_section): Handle R_IA_64_DTPREL64LSB
	and R_IA_64_DTPREL64MSB.

	* config/tc-ia64.c (ia64_cons_fix_new): Handle @@dtprel() in data.

	* ld-ia64/ia64.exp: New.
	* ld-ia64/tlsbin.dd: New test.
	* ld-ia64/tlsbinpic.s: New test.
	* ld-ia64/tlsbin.rd: New test.
	* ld-ia64/tlsbin.s: New test.
	* ld-ia64/tlsbin.sd: New test.
	* ld-ia64/tlsbin.td: New test.
	* ld-ia64/tlsg.s: New test.
	* ld-ia64/tlsg.sd: New test.
	* ld-ia64/tlslib.s: New test.
	* ld-ia64/tlspic1.s: New test.
	* ld-ia64/tlspic2.s: New test.
	* ld-ia64/tlspic.dd: New test.
	* ld-ia64/tlspic.rd: New test.
	* ld-ia64/tlspic.sd: New test.
	* ld-ia64/tlspic.td: New test.
@
text
@d4267 2
d4274 10
a4283 2
		if (!dynamic_symbol_p && !info->shared)
		  value -= elfNN_ia64_tprel_base (info);
d4298 1
a4298 2
	    value = set_got_entry (input_bfd, info, dyn_i,
				   (h ? h->dynindx : -1), rel->r_addend,
@


1.64
log
@        * elfxx-ia64.c (elfNN_ia64_relax_section): Handle PCREL21BI.
        Only send PCREL21B though the plt.  Fix installed reloc type.
        (elfNN_ia64_relocate_section): Give error for dynamic reloc
        against PCREL22 or PCREL64I; clean up error messages for
        branch relocs.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d151 2
d2421 17
a2437 2
      dyn_i->dtpmod_offset = x->ofs;
      x->ofs += 8;
d2707 1
a2707 1
  if ((dynamic_symbol || shared) && dyn_i->want_dtpmod)
d2773 1
d2852 2
d3287 11
a3297 2
      done = dyn_i->dtpmod_done;
      dyn_i->dtpmod_done = TRUE;
d4256 2
@


1.63
log
@2002-12-04  H.J. Lu <hjl@@gnu.org>

	* elfxx-ia64.c (get_local_sym_hash): Use section ID instead of
	BFD address when constructing local name.
@
text
@d675 2
a676 1
   relaxation of R_IA64_LTOFF22X and R_IA64_LDXMOV not yet supported.  */
d730 8
a737 4
    if (ELFNN_R_TYPE (irel->r_info) == (int) R_IA64_PCREL21B
	|| ELFNN_R_TYPE (irel->r_info) == (int) R_IA64_PCREL21M
	|| ELFNN_R_TYPE (irel->r_info) == (int) R_IA64_PCREL21F)
      break;
d763 1
d769 4
a772 3
      if (ELFNN_R_TYPE (irel->r_info) != (int) R_IA64_PCREL21B
	  && ELFNN_R_TYPE (irel->r_info) != (int) R_IA64_PCREL21M
	  && ELFNN_R_TYPE (irel->r_info) != (int) R_IA64_PCREL21F)
d827 5
d943 1
a943 1
				    R_IA64_PCREL21B) != bfd_reloc_ok)
a4049 23
	case R_IA64_PCREL21BI:
	case R_IA64_PCREL21F:
	case R_IA64_PCREL21M:
	  /* ??? These two are only used for speculation fixup code.
	     They should never be dynamic.  */
	  if (dynamic_symbol_p)
	    {
	      (*_bfd_error_handler)
		(_("%s: dynamic relocation against speculation fixup"),
		 bfd_archive_filename (input_bfd));
	      ret_val = FALSE;
	      continue;
	    }
	  if (undef_weak_ref)
	    {
	      (*_bfd_error_handler)
		(_("%s: speculation fixup against undefined weak symbol"),
		 bfd_archive_filename (input_bfd));
	      ret_val = FALSE;
	      continue;
	    }
	  goto finish_pcrel;

d4081 3
d4086 21
@


1.62
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@a1836 2
  char *addr_name;
  size_t len;
d1838 5
d1847 2
a1848 8
  len = sizeof (void*)*2 + 1 + sizeof (bfd_vma)*4 + 1 + 1;
  len += 10;	/* %p slop */

  addr_name = bfd_malloc (len);
  if (addr_name == NULL)
    return 0;
  sprintf (addr_name, "%p:%lx",
	   (void *) abfd, (unsigned long) ELFNN_R_SYM (rel->r_info));
a1852 1
  free (addr_name);
@


1.61
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d29 1
a29 1
 
d34 1
a34 1
 
d41 1
a41 1
 
d45 1
a45 1
 
d52 1
a52 1
 
d95 1
a95 1
  /* True when the section contents have been updated.  */
d103 1
a103 1
  /* True for the different kinds of linker data we want created.  */
d120 1
a120 1
  /* True if this hash entry's addends was translated for
d167 1
a167 1
static boolean elfNN_ia64_relax_section
d169 2
a170 2
	  boolean *again));
static boolean is_unwind_section_name
d172 1
a172 1
static boolean elfNN_ia64_section_from_shdr
d174 1
a174 1
static boolean elfNN_ia64_section_flags
d176 1
a176 1
static boolean elfNN_ia64_fake_sections
d179 2
a180 2
  PARAMS ((bfd *abfd, boolean linker));
static boolean elfNN_ia64_add_symbol_hook
d184 1
a184 1
static boolean elfNN_ia64_aix_vec
d186 1
a186 1
static boolean elfNN_ia64_aix_add_symbol_hook
d190 1
a190 1
static boolean elfNN_ia64_aix_link_add_symbols
d194 1
a194 1
static boolean elfNN_ia64_modify_segment_map
d196 1
a196 1
static boolean elfNN_ia64_is_local_label_name
d198 1
a198 1
static boolean elfNN_ia64_dynamic_symbol_p
d200 1
a200 1
static boolean elfNN_ia64_local_hash_table_init
d213 1
a213 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, boolean));
d218 2
a219 2
	   boolean create, boolean copy));
static boolean elfNN_ia64_global_dyn_sym_thunk
d221 1
a221 1
static boolean elfNN_ia64_local_dyn_sym_thunk
d225 1
a225 1
	   boolean (*func) (struct elfNN_ia64_dyn_sym_info *, PTR),
d227 1
a227 1
static boolean elfNN_ia64_create_dynamic_sections
d231 1
a231 1
	   bfd *abfd, const Elf_Internal_Rela *rel, boolean create));
d235 1
a235 1
	   bfd *abfd, const Elf_Internal_Rela *rel, boolean create));
d247 2
a248 2
	   asection *sec, boolean create));
static boolean count_dyn_reloc
d251 1
a251 1
static boolean elfNN_ia64_check_relocs
d254 1
a254 1
static boolean elfNN_ia64_adjust_dynamic_symbol
d258 1
a258 1
static boolean allocate_fptr
d260 1
a260 1
static boolean allocate_global_data_got
d262 1
a262 1
static boolean allocate_global_fptr_got
d264 1
a264 1
static boolean allocate_local_got
d266 1
a266 1
static boolean allocate_pltoff_entries
d268 1
a268 1
static boolean allocate_plt_entries
d270 1
a270 1
static boolean allocate_plt2_entries
d272 1
a272 1
static boolean allocate_dynrel_entries
d274 1
a274 1
static boolean elfNN_ia64_size_dynamic_sections
d293 1
a293 1
	   bfd_vma value, boolean));
d300 1
a300 1
static boolean elfNN_ia64_final_link
d302 1
a302 1
static boolean elfNN_ia64_relocate_section
d307 1
a307 1
static boolean elfNN_ia64_finish_dynamic_symbol
d310 1
a310 1
static boolean elfNN_ia64_finish_dynamic_sections
d312 1
a312 1
static boolean elfNN_ia64_set_private_flags
d314 1
a314 1
static boolean elfNN_ia64_merge_private_bfd_data
d316 1
a316 1
static boolean elfNN_ia64_print_private_bfd_data
d320 1
a320 1
static boolean elfNN_ia64_hpux_vec
d324 1
a324 1
boolean elfNN_hpux_backend_section_from_bfd_section
d353 1
a353 1
	 elfNN_ia64_reloc, NAME, false, 0, 0, IN)
d359 1
a359 1
    IA64_HOWTO (R_IA64_NONE,	    "NONE",	   0, false, true),
d361 94
a454 94
    IA64_HOWTO (R_IA64_IMM14,	    "IMM14",	   0, false, true),
    IA64_HOWTO (R_IA64_IMM22,	    "IMM22",	   0, false, true),
    IA64_HOWTO (R_IA64_IMM64,	    "IMM64",	   0, false, true),
    IA64_HOWTO (R_IA64_DIR32MSB,    "DIR32MSB",	   2, false, true),
    IA64_HOWTO (R_IA64_DIR32LSB,    "DIR32LSB",	   2, false, true),
    IA64_HOWTO (R_IA64_DIR64MSB,    "DIR64MSB",	   4, false, true),
    IA64_HOWTO (R_IA64_DIR64LSB,    "DIR64LSB",	   4, false, true),

    IA64_HOWTO (R_IA64_GPREL22,	    "GPREL22",	   0, false, true),
    IA64_HOWTO (R_IA64_GPREL64I,    "GPREL64I",	   0, false, true),
    IA64_HOWTO (R_IA64_GPREL32MSB,  "GPREL32MSB",  2, false, true),
    IA64_HOWTO (R_IA64_GPREL32LSB,  "GPREL32LSB",  2, false, true),
    IA64_HOWTO (R_IA64_GPREL64MSB,  "GPREL64MSB",  4, false, true),
    IA64_HOWTO (R_IA64_GPREL64LSB,  "GPREL64LSB",  4, false, true),

    IA64_HOWTO (R_IA64_LTOFF22,	    "LTOFF22",	   0, false, true),
    IA64_HOWTO (R_IA64_LTOFF64I,    "LTOFF64I",	   0, false, true),

    IA64_HOWTO (R_IA64_PLTOFF22,    "PLTOFF22",	   0, false, true),
    IA64_HOWTO (R_IA64_PLTOFF64I,   "PLTOFF64I",   0, false, true),
    IA64_HOWTO (R_IA64_PLTOFF64MSB, "PLTOFF64MSB", 4, false, true),
    IA64_HOWTO (R_IA64_PLTOFF64LSB, "PLTOFF64LSB", 4, false, true),

    IA64_HOWTO (R_IA64_FPTR64I,	    "FPTR64I",	   0, false, true),
    IA64_HOWTO (R_IA64_FPTR32MSB,   "FPTR32MSB",   2, false, true),
    IA64_HOWTO (R_IA64_FPTR32LSB,   "FPTR32LSB",   2, false, true),
    IA64_HOWTO (R_IA64_FPTR64MSB,   "FPTR64MSB",   4, false, true),
    IA64_HOWTO (R_IA64_FPTR64LSB,   "FPTR64LSB",   4, false, true),

    IA64_HOWTO (R_IA64_PCREL60B,    "PCREL60B",	   0, true, true),
    IA64_HOWTO (R_IA64_PCREL21B,    "PCREL21B",	   0, true, true),
    IA64_HOWTO (R_IA64_PCREL21M,    "PCREL21M",	   0, true, true),
    IA64_HOWTO (R_IA64_PCREL21F,    "PCREL21F",	   0, true, true),
    IA64_HOWTO (R_IA64_PCREL32MSB,  "PCREL32MSB",  2, true, true),
    IA64_HOWTO (R_IA64_PCREL32LSB,  "PCREL32LSB",  2, true, true),
    IA64_HOWTO (R_IA64_PCREL64MSB,  "PCREL64MSB",  4, true, true),
    IA64_HOWTO (R_IA64_PCREL64LSB,  "PCREL64LSB",  4, true, true),

    IA64_HOWTO (R_IA64_LTOFF_FPTR22, "LTOFF_FPTR22", 0, false, true),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64I, "LTOFF_FPTR64I", 0, false, true),
    IA64_HOWTO (R_IA64_LTOFF_FPTR32MSB, "LTOFF_FPTR32MSB", 2, false, true),
    IA64_HOWTO (R_IA64_LTOFF_FPTR32LSB, "LTOFF_FPTR32LSB", 2, false, true),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64MSB, "LTOFF_FPTR64MSB", 4, false, true),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64LSB, "LTOFF_FPTR64LSB", 4, false, true),

    IA64_HOWTO (R_IA64_SEGREL32MSB, "SEGREL32MSB", 2, false, true),
    IA64_HOWTO (R_IA64_SEGREL32LSB, "SEGREL32LSB", 2, false, true),
    IA64_HOWTO (R_IA64_SEGREL64MSB, "SEGREL64MSB", 4, false, true),
    IA64_HOWTO (R_IA64_SEGREL64LSB, "SEGREL64LSB", 4, false, true),

    IA64_HOWTO (R_IA64_SECREL32MSB, "SECREL32MSB", 2, false, true),
    IA64_HOWTO (R_IA64_SECREL32LSB, "SECREL32LSB", 2, false, true),
    IA64_HOWTO (R_IA64_SECREL64MSB, "SECREL64MSB", 4, false, true),
    IA64_HOWTO (R_IA64_SECREL64LSB, "SECREL64LSB", 4, false, true),

    IA64_HOWTO (R_IA64_REL32MSB,    "REL32MSB",	   2, false, true),
    IA64_HOWTO (R_IA64_REL32LSB,    "REL32LSB",	   2, false, true),
    IA64_HOWTO (R_IA64_REL64MSB,    "REL64MSB",	   4, false, true),
    IA64_HOWTO (R_IA64_REL64LSB,    "REL64LSB",	   4, false, true),

    IA64_HOWTO (R_IA64_LTV32MSB,    "LTV32MSB",	   2, false, true),
    IA64_HOWTO (R_IA64_LTV32LSB,    "LTV32LSB",	   2, false, true),
    IA64_HOWTO (R_IA64_LTV64MSB,    "LTV64MSB",	   4, false, true),
    IA64_HOWTO (R_IA64_LTV64LSB,    "LTV64LSB",	   4, false, true),

    IA64_HOWTO (R_IA64_PCREL21BI,   "PCREL21BI",   0, true, true),
    IA64_HOWTO (R_IA64_PCREL22,     "PCREL22",     0, true, true),
    IA64_HOWTO (R_IA64_PCREL64I,    "PCREL64I",    0, true, true),

    IA64_HOWTO (R_IA64_IPLTMSB,	    "IPLTMSB",	   4, false, true),
    IA64_HOWTO (R_IA64_IPLTLSB,	    "IPLTLSB",	   4, false, true),
    IA64_HOWTO (R_IA64_COPY,	    "COPY",	   4, false, true),
    IA64_HOWTO (R_IA64_LTOFF22X,    "LTOFF22X",	   0, false, true),
    IA64_HOWTO (R_IA64_LDXMOV,	    "LDXMOV",	   0, false, true),

    IA64_HOWTO (R_IA64_TPREL14,	    "TPREL14",	   0, false, false),
    IA64_HOWTO (R_IA64_TPREL22,	    "TPREL22",	   0, false, false),
    IA64_HOWTO (R_IA64_TPREL64I,    "TPREL64I",	   0, false, false),
    IA64_HOWTO (R_IA64_TPREL64MSB,  "TPREL64MSB",  8, false, false),
    IA64_HOWTO (R_IA64_TPREL64LSB,  "TPREL64LSB",  8, false, false),
    IA64_HOWTO (R_IA64_LTOFF_TPREL22, "LTOFF_TPREL22",  0, false, false),

    IA64_HOWTO (R_IA64_DTPMOD64MSB, "TPREL64MSB",  8, false, false),
    IA64_HOWTO (R_IA64_DTPMOD64LSB, "TPREL64LSB",  8, false, false),
    IA64_HOWTO (R_IA64_LTOFF_DTPMOD22, "LTOFF_DTPMOD22", 0, false, false),

    IA64_HOWTO (R_IA64_DTPREL14,    "DTPREL14",	   0, false, false),
    IA64_HOWTO (R_IA64_DTPREL22,    "DTPREL22",	   0, false, false),
    IA64_HOWTO (R_IA64_DTPREL64I,   "DTPREL64I",   0, false, false),
    IA64_HOWTO (R_IA64_DTPREL32MSB, "DTPREL32MSB", 4, false, false),
    IA64_HOWTO (R_IA64_DTPREL32LSB, "DTPREL32LSB", 4, false, false),
    IA64_HOWTO (R_IA64_DTPREL64MSB, "DTPREL64MSB", 8, false, false),
    IA64_HOWTO (R_IA64_DTPREL64LSB, "DTPREL64LSB", 8, false, false),
    IA64_HOWTO (R_IA64_LTOFF_DTPREL22, "LTOFF_DTPREL22", 0, false, false),
d677 1
a677 1
static boolean
d682 1
a682 1
     boolean *again;
d699 2
a700 2
  boolean changed_contents = false;
  boolean changed_relocs = false;
d704 1
a704 1
  *again = false;
d709 1
a709 1
    return true;
d723 1
a723 1
    return false;
d739 1
a739 1
      return true;
d814 1
a814 1
	  dyn_i = get_dyn_sym_info (ia64_info, h, abfd, irel, false);
d934 2
a935 2
      changed_contents = true;
      changed_relocs = true;
d979 1
a979 1
  return true;
d990 1
a990 1
  return false;
d993 1
a993 1
/* Return true if NAME is an unwind table section name.  */
d995 1
a995 1
static inline boolean
d1004 1
a1004 1
    return false;
d1017 1
a1017 1
static boolean
d1038 1
a1038 1
	return false;
d1042 1
a1042 1
      return false;
d1046 1
a1046 1
    return false;
d1049 1
a1049 1
  return true;
d1057 1
a1057 1
static boolean
d1065 1
a1065 1
  return true;
d1071 1
a1071 1
static boolean
d1114 1
a1114 1
  return true;
d1123 1
a1123 1
     boolean linker ATTRIBUTE_UNUSED;
d1208 1
a1208 1
      elf_flags_init (abfd) = true;
d1215 1
a1215 1
static boolean
d1241 1
a1241 1
	    return false;
d1248 1
a1248 1
  return true;
d1251 1
a1251 1
static boolean
d1264 1
a1264 1
static boolean
d1282 1
a1282 1
				false, false, false);
d1295 1
a1295 1
		 bed->got_symbol_offset, (const char *) NULL, false,
d1297 1
a1297 1
	    return false;
d1304 1
a1304 1
	    return false;
d1307 1
a1307 1
      return true;
d1333 1
a1333 1
      return true;
d1342 1
a1342 1
boolean
d1352 1
a1352 1
	return false;
d1381 1
a1381 1
static boolean
d1402 1
a1402 1
	    return false;
d1450 1
a1450 1
		return false;
d1494 1
a1494 1
  return true;
d1500 1
a1500 1
static boolean
d1510 1
a1510 1
static boolean
d1516 1
a1516 1
    return false;
d1523 1
a1523 1
    return false;
d1528 1
a1528 1
      return false;
d1535 1
a1535 1
    return true;
d1541 1
a1541 1
    return true;
d1543 1
a1543 1
  return false;
d1546 1
a1546 1
static boolean
d1667 1
a1667 1
     boolean force_local;
d1712 1
a1712 1
     boolean create, copy;
d1722 1
a1722 1
  boolean (*func) PARAMS ((struct elfNN_ia64_dyn_sym_info *, PTR));
d1726 1
a1726 1
static boolean
d1742 2
a1743 2
      return false;
  return true;
d1746 1
a1746 1
static boolean
d1759 2
a1760 2
      return false;
  return true;
d1766 1
a1766 1
     boolean (*func) PARAMS ((struct elfNN_ia64_dyn_sym_info *, PTR));
d1780 1
a1780 1
static boolean
d1789 1
a1789 1
    return false;
d1802 1
a1802 1
    return false;
d1812 1
a1812 1
    return false;
d1823 1
a1823 1
    return false;
d1826 1
a1826 1
  return true;
d1835 1
a1835 1
     boolean create;
d1869 1
a1869 1
     boolean create;
d2016 1
a2016 1
     boolean create;
d2061 1
a2061 1
static boolean
d2079 1
a2079 1
	return false;
d2089 1
a2089 1
  return true;
d2092 1
a2092 1
static boolean
d2106 1
a2106 1
    return true;
d2133 1
a2133 1
      boolean maybe_dynamic;
d2153 1
a2153 1
      maybe_dynamic = false;
d2159 1
a2159 1
	maybe_dynamic = true;
d2303 1
a2303 1
      dyn_i = get_dyn_sym_info (ia64_info, h, abfd, rel, true);
d2315 1
a2315 1
		return false;
d2332 1
a2332 1
		return false;
d2344 1
a2344 1
		return false;
d2366 1
a2366 1
	      srel = get_reloc_section (abfd, ia64_info, sec, true);
d2368 1
a2368 1
		return false;
d2371 1
a2371 1
	    return false;
d2375 1
a2375 1
  return true;
d2387 1
a2387 1
static boolean
d2419 1
a2419 1
  return true;
d2424 1
a2424 1
static boolean
d2439 1
a2439 1
  return true;
d2444 1
a2444 1
static boolean
d2458 1
a2458 1
  return true;
d2483 1
a2483 1
static boolean
d2514 1
a2514 1
		return false;
d2527 1
a2527 1
  return true;
d2532 1
a2532 1
static boolean
d2565 1
a2565 1
  return true;
d2570 1
a2570 1
static boolean
d2590 1
a2590 1
  return true;
d2598 1
a2598 1
static boolean
d2610 1
a2610 1
  return true;
d2616 1
a2616 1
static boolean
d2624 1
a2624 1
  boolean dynamic_symbol, shared;
d2702 1
a2702 1
  return true;
d2705 1
a2705 1
static boolean
d2722 1
a2722 1
      return true;
d2732 1
a2732 1
  return true;
d2735 1
a2735 1
static boolean
d2744 1
a2744 1
  boolean relplt = false;
d2783 1
a2783 1
     We do this even though dynamic_sections_created may be false, because
d2833 1
a2833 1
      boolean strip;
d2849 1
a2849 1
	strip = false;
d2880 1
a2880 1
	      relplt = true;
d2895 1
a2895 1
	    strip = false;
d2916 1
a2916 1
	    return false;
d2934 1
a2934 1
	    return false;
d2938 1
a2938 1
	return false;
d2940 1
a2940 1
	return false;
d2947 1
a2947 1
	    return false;
d2953 1
a2953 1
	return false;
d2958 1
a2958 1
	    return false;
d2965 1
a2965 1
  return true;
d3245 1
a3245 1
  boolean done;
d3255 1
a3255 1
      dyn_i->tprel_done = true;
d3260 1
a3260 1
      dyn_i->dtpmod_done = true;
d3265 1
a3265 1
      dyn_i->dtprel_done = true;
d3270 1
a3270 1
      dyn_i->got_done = true;
d3321 1
a3321 1
		  BFD_ASSERT (false);
d3384 1
a3384 1
     boolean is_plt;
d3482 1
a3482 1
static boolean
d3530 2
a3531 2
      gp = elf_link_hash_lookup (elf_hash_table (info), "__gp", false,
				 false, false);
d3585 1
a3585 1
	      return false;
d3595 1
a3595 1
	      return false;
d3622 1
a3622 1
	    return false;
d3628 1
a3628 1
    return false;
d3641 1
a3641 1
	return false;
d3644 1
a3644 1
  return true;
d3647 1
a3647 1
static boolean
d3664 1
a3664 1
  boolean ret_val = true;	/* for non-fatal errors */
d3680 1
a3680 1
      return true;
d3684 1
a3684 1
  srel = get_reloc_section (input_bfd, ia64_info, input_section, false);
d3700 2
a3701 2
      boolean dynamic_symbol_p;
      boolean undef_weak_ref;
d3710 1
a3710 1
	  ret_val = false;
d3719 1
a3719 1
      undef_weak_ref = false;
d3733 2
a3734 2
      
	      loc_h = get_local_sym_hash (ia64_info, input_bfd, rel, false);
d3793 1
a3793 1
	    undef_weak_ref = true;
d3806 2
a3807 2
		return false;
	      ret_val = false;
d3880 1
a3880 1
		      ret_val = false;
d3913 1
a3913 1
	      ret_val = false;
d3923 1
a3923 1
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, false);
d3934 2
a3935 2
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, false);
	  value = set_pltoff_entry (output_bfd, info, dyn_i, value, false);
d3945 1
a3945 1
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, false);
d3991 1
a3991 1
	    dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, false);
d4052 1
a4052 1
	      ret_val = false;
d4060 1
a4060 1
	      ret_val = false;
d4070 1
a4070 1
	    dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, false);
d4247 1
a4247 1
	    dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, false);
d4273 1
a4273 1
	  return false;
d4287 1
a4287 1
		  return false;
d4294 2
a4295 2
	      return false;
	    ret_val = false;
d4314 1
a4314 1
		  return false;
d4324 2
a4325 2
	      return false;
	    ret_val = false;
d4334 1
a4334 1
static boolean
d4345 1
a4345 1
  dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, false);
d4371 1
a4371 1
      pltoff_addr = set_pltoff_entry (output_bfd, info, dyn_i, plt_addr, true);
d4422 1
a4422 1
  return true;
d4425 1
a4425 1
static boolean
d4507 1
a4507 1
  return true;
d4513 1
a4513 1
static boolean
d4522 2
a4523 2
  elf_flags_init (abfd) = true;
  return true;
d4528 1
a4528 1
static boolean
d4534 1
a4534 1
  boolean ok = true;
d4539 1
a4539 1
    return false;
d4546 1
a4546 1
      elf_flags_init (obfd) = true;
d4556 1
a4556 1
      return true;
d4561 1
a4561 1
    return true;
d4574 1
a4574 1
      ok = false;
d4583 1
a4583 1
      ok = false;
d4592 1
a4592 1
      ok = false;
d4601 1
a4601 1
      ok = false;
d4611 1
a4611 1
      ok = false;
d4617 1
a4617 1
static boolean
d4638 1
a4638 1
  return true;
d4662 1
a4662 1
static boolean
d4680 1
a4680 1
boolean
d4689 1
a4689 1
      return true;
d4691 1
a4691 1
  return false;
@


1.60
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't zero
	relocs for discarded FDEs.  Remove dead code.
	(_bfd_elf_write_section_eh_frame_hdr): Remove dead code.
	* elflink.h (elf_bfd_discard_info): Don't save edited relocs.
	Tidy conditions under which stabs are edited.  Formatting.
	* elf64-sparc.c (sparc64_elf_relocate_section): Ignore overflows
	from discarded relocs.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Add reloc output
	section adjustments after testing magic values.
@
text
@d166 1
a166 1
  PARAMS ((bfd *abfd, arelent *bfd_reloc, ElfNN_Internal_Rela *elf_reloc));
d173 1
a173 1
  PARAMS ((bfd *, ElfNN_Internal_Shdr *, const char *));
d175 1
a175 1
  PARAMS ((flagword *, ElfNN_Internal_Shdr *));
d177 1
a177 1
  PARAMS ((bfd *abfd, ElfNN_Internal_Shdr *hdr, asection *sec));
d600 1
a600 1
     ElfNN_Internal_Rela *elf_reloc;
d1020 1
a1020 1
     ElfNN_Internal_Shdr *hdr;
d1060 1
a1060 1
     ElfNN_Internal_Shdr *hdr;
d1074 1
a1074 1
     ElfNN_Internal_Shdr *hdr;
d3206 1
d3223 3
a3225 3
  bfd_elfNN_swap_reloca_out (abfd, &outrel,
			     ((ElfNN_External_Rela *) srel->contents
			      + srel->reloc_count++));
a4353 1
      ElfNN_External_Rela *rel;
d4410 4
a4413 4
      rel = (ElfNN_External_Rela *)ia64_info->rel_pltoff_sec->contents;
      rel += ia64_info->rel_pltoff_sec->reloc_count;

      bfd_elfNN_swap_reloca_out (output_bfd, &outrel, rel + index);
@


1.59
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a3206 2
  offset += sec->output_section->vma + sec->output_offset;

d3211 1
a3211 1
  if ((outrel.r_offset | 1) == (bfd_vma) -1)
d3219 2
@


1.58
log
@        * elfxx-ia64.c (elfNN_ia64_relax_section): Handle PCREL21M
        and PCREL21F like PCREL21B.
@
text
@d650 1
d657 1
a657 1

d670 1
d1287 1
d1296 1
a1296 1
		 bed->collect, (struct bfd_link_hash_entry **) &h)))
d1299 1
@


1.58.4.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a649 1
#ifdef USE_BRL
d656 1
a656 1
#else
a668 1
#endif
a1284 1
	  struct bfd_link_hash_entry *bh = NULL;
d1293 1
a1293 1
		 bed->collect, &bh)))
a1295 1
	  h = (struct elf_link_hash_entry *) bh;
@


1.58.4.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a26 2
#include "objalloc.h"
#include "hashtab.h"
d29 1
a29 1

d34 1
a34 1

d41 1
a41 1

d45 1
a45 1

d52 1
a52 1

d54 1
a54 1
 		does not require dynamic relocations.  */
d82 1
a82 1
  /* The symbol table entry, if any, that this was derived from.  */
d95 1
a95 1
  /* TRUE when the section contents have been updated.  */
d103 1
a103 1
  /* TRUE for the different kinds of linker data we want created.  */
a104 1
  unsigned want_gotx : 1;
d117 1
a117 2
  int id;
  unsigned int r_sym;
d120 1
a120 1
  /* TRUE if this hash entry's addends was translated for
d125 6
a144 1
  asection *rel_fptr_sec;	/* dynamic relocation section for same */
a150 2
  unsigned self_dtpmod_done : 1;/* has self DTPMOD entry been finished? */
  bfd_vma self_dtpmod_offset;	/* .got offset to self DTPMOD entry */
d152 1
a152 8
  htab_t loc_hash_table;
  void *loc_hash_memory;
};

struct elfNN_ia64_allocate_data
{
  struct bfd_link_info *info;
  bfd_size_type ofs;
d166 2
a167 2
  PARAMS ((bfd *abfd, arelent *bfd_reloc, Elf_Internal_Rela *elf_reloc));
static bfd_boolean elfNN_ia64_relax_section
d169 2
a170 4
	  bfd_boolean *again));
static void elfNN_ia64_relax_ldxmov
  PARAMS((bfd *abfd, bfd_byte *contents, bfd_vma off));
static bfd_boolean is_unwind_section_name
d172 6
a177 6
static bfd_boolean elfNN_ia64_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
static bfd_boolean elfNN_ia64_section_flags
  PARAMS ((flagword *, Elf_Internal_Shdr *));
static bfd_boolean elfNN_ia64_fake_sections
  PARAMS ((bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec));
d179 8
a186 2
  PARAMS ((bfd *abfd, bfd_boolean linker));
static bfd_boolean elfNN_ia64_add_symbol_hook
d190 2
d194 3
a196 3
static bfd_boolean elfNN_ia64_modify_segment_map
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elfNN_ia64_is_local_label_name
d198 8
a205 2
static bfd_boolean elfNN_ia64_dynamic_symbol_p
  PARAMS ((struct elf_link_hash_entry *h, struct bfd_link_info *info, int));
d210 1
a210 1
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
d213 1
a213 4
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
static hashval_t elfNN_ia64_local_htab_hash PARAMS ((const void *));
static int elfNN_ia64_local_htab_eq PARAMS ((const void *ptr1,
					     const void *ptr2));
d216 6
a221 3
static void elfNN_ia64_hash_table_free
  PARAMS ((struct bfd_link_hash_table *hash));
static bfd_boolean elfNN_ia64_global_dyn_sym_thunk
a222 2
static int elfNN_ia64_local_dyn_sym_thunk
  PARAMS ((void **, PTR));
d225 1
a225 1
	   bfd_boolean (*func) (struct elfNN_ia64_dyn_sym_info *, PTR),
d227 1
a227 1
static bfd_boolean elfNN_ia64_create_dynamic_sections
d231 1
a231 1
	   bfd *abfd, const Elf_Internal_Rela *rel, bfd_boolean create));
d235 1
a235 1
	   bfd *abfd, const Elf_Internal_Rela *rel, bfd_boolean create));
d247 2
a248 2
	   asection *sec, bfd_boolean create));
static bfd_boolean count_dyn_reloc
d251 1
a251 1
static bfd_boolean elfNN_ia64_check_relocs
d254 1
a254 1
static bfd_boolean elfNN_ia64_adjust_dynamic_symbol
d258 1
a258 1
static bfd_boolean allocate_fptr
d260 1
a260 1
static bfd_boolean allocate_global_data_got
d262 1
a262 1
static bfd_boolean allocate_global_fptr_got
d264 1
a264 1
static bfd_boolean allocate_local_got
d266 1
a266 1
static bfd_boolean allocate_pltoff_entries
d268 1
a268 1
static bfd_boolean allocate_plt_entries
d270 1
a270 1
static bfd_boolean allocate_plt2_entries
d272 1
a272 1
static bfd_boolean allocate_dynrel_entries
d274 1
a274 1
static bfd_boolean elfNN_ia64_size_dynamic_sections
d293 1
a293 1
	   bfd_vma value, bfd_boolean));
d300 1
a300 3
static bfd_boolean elfNN_ia64_choose_gp
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
static bfd_boolean elfNN_ia64_final_link
d302 1
a302 1
static bfd_boolean elfNN_ia64_relocate_section
d307 1
a307 1
static bfd_boolean elfNN_ia64_finish_dynamic_symbol
d310 1
a310 1
static bfd_boolean elfNN_ia64_finish_dynamic_sections
d312 1
a312 1
static bfd_boolean elfNN_ia64_set_private_flags
d314 1
a314 1
static bfd_boolean elfNN_ia64_merge_private_bfd_data
d316 1
a316 1
static bfd_boolean elfNN_ia64_print_private_bfd_data
d320 1
a320 1
static bfd_boolean elfNN_ia64_hpux_vec
d324 1
a324 1
bfd_boolean elfNN_hpux_backend_section_from_bfd_section
a346 4

  if (input_section->flags & SEC_DEBUGGING)
    return bfd_reloc_continue;

d353 1
a353 1
	 elfNN_ia64_reloc, NAME, FALSE, 0, -1, IN)
d359 1
a359 1
    IA64_HOWTO (R_IA64_NONE,	    "NONE",	   0, FALSE, TRUE),
d361 94
a454 94
    IA64_HOWTO (R_IA64_IMM14,	    "IMM14",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_IMM22,	    "IMM22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_IMM64,	    "IMM64",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR32MSB,    "DIR32MSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR32LSB,    "DIR32LSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR64MSB,    "DIR64MSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR64LSB,    "DIR64LSB",	   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_GPREL22,	    "GPREL22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL64I,    "GPREL64I",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL32MSB,  "GPREL32MSB",  2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL32LSB,  "GPREL32LSB",  2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL64MSB,  "GPREL64MSB",  4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL64LSB,  "GPREL64LSB",  4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_LTOFF22,	    "LTOFF22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF64I,    "LTOFF64I",	   0, FALSE, TRUE),

    IA64_HOWTO (R_IA64_PLTOFF22,    "PLTOFF22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_PLTOFF64I,   "PLTOFF64I",   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_PLTOFF64MSB, "PLTOFF64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_PLTOFF64LSB, "PLTOFF64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_FPTR64I,	    "FPTR64I",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR32MSB,   "FPTR32MSB",   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR32LSB,   "FPTR32LSB",   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR64MSB,   "FPTR64MSB",   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR64LSB,   "FPTR64LSB",   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_PCREL60B,    "PCREL60B",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL21B,    "PCREL21B",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL21M,    "PCREL21M",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL21F,    "PCREL21F",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL32MSB,  "PCREL32MSB",  2, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL32LSB,  "PCREL32LSB",  2, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL64MSB,  "PCREL64MSB",  4, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL64LSB,  "PCREL64LSB",  4, TRUE, TRUE),

    IA64_HOWTO (R_IA64_LTOFF_FPTR22, "LTOFF_FPTR22", 0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64I, "LTOFF_FPTR64I", 0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR32MSB, "LTOFF_FPTR32MSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR32LSB, "LTOFF_FPTR32LSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64MSB, "LTOFF_FPTR64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64LSB, "LTOFF_FPTR64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_SEGREL32MSB, "SEGREL32MSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SEGREL32LSB, "SEGREL32LSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SEGREL64MSB, "SEGREL64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SEGREL64LSB, "SEGREL64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_SECREL32MSB, "SECREL32MSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SECREL32LSB, "SECREL32LSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SECREL64MSB, "SECREL64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SECREL64LSB, "SECREL64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_REL32MSB,    "REL32MSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_REL32LSB,    "REL32LSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_REL64MSB,    "REL64MSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_REL64LSB,    "REL64LSB",	   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_LTV32MSB,    "LTV32MSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTV32LSB,    "LTV32LSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTV64MSB,    "LTV64MSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTV64LSB,    "LTV64LSB",	   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_PCREL21BI,   "PCREL21BI",   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL22,     "PCREL22",     0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL64I,    "PCREL64I",    0, TRUE, TRUE),

    IA64_HOWTO (R_IA64_IPLTMSB,	    "IPLTMSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_IPLTLSB,	    "IPLTLSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_COPY,	    "COPY",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF22X,    "LTOFF22X",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LDXMOV,	    "LDXMOV",	   0, FALSE, TRUE),

    IA64_HOWTO (R_IA64_TPREL14,	    "TPREL14",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL22,	    "TPREL22",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64I,    "TPREL64I",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64MSB,  "TPREL64MSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64LSB,  "TPREL64LSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_LTOFF_TPREL22, "LTOFF_TPREL22",  0, FALSE, FALSE),

    IA64_HOWTO (R_IA64_DTPMOD64MSB, "TPREL64MSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPMOD64LSB, "TPREL64LSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_LTOFF_DTPMOD22, "LTOFF_DTPMOD22", 0, FALSE, FALSE),

    IA64_HOWTO (R_IA64_DTPREL14,    "DTPREL14",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL22,    "DTPREL22",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64I,   "DTPREL64I",   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL32MSB, "DTPREL32MSB", 2, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL32LSB, "DTPREL32LSB", 2, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64MSB, "DTPREL64MSB", 4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64LSB, "DTPREL64LSB", 4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_LTOFF_DTPREL22, "LTOFF_DTPREL22", 0, FALSE, FALSE),
d600 1
a600 1
     Elf_Internal_Rela *elf_reloc;
d642 7
d650 1
d657 1
a657 1

d670 3
d674 2
a675 10
static size_t oor_branch_size = sizeof (oor_brl);

void
bfd_elfNN_ia64_after_parse (int itanium)
{
  oor_branch_size = itanium ? sizeof (oor_ip) : sizeof (oor_brl);
}


/* These functions do relaxation for IA-64 ELF.  */
d677 1
a677 1
static bfd_boolean
d682 1
a682 1
     bfd_boolean *again;
d699 2
a700 4
  bfd_boolean changed_contents = FALSE;
  bfd_boolean changed_relocs = FALSE;
  bfd_boolean changed_got = FALSE;
  bfd_vma gp = 0;
d704 1
a704 1
  *again = FALSE;
d706 1
a706 6
  /* Don't even try to relax for non-ELF outputs.  */
  if (!is_elf_hash_table (link_info->hash))
    return FALSE;

  /* Nothing to do if there are no relocations or there is no need for
     the relax finalize pass.  */
d708 2
a709 4
      || sec->reloc_count == 0
      || (!link_info->need_relax_finalize
	  && sec->need_finalize_relax == 0))
    return TRUE;
d719 1
a719 1
  internal_relocs = (_bfd_elf_link_read_relocs
d723 1
a723 1
    return FALSE;
d728 14
d756 1
a756 1
  for (irel = internal_relocs; irel < irelend; irel++)
a757 1
      unsigned long r_type = ELFNN_R_TYPE (irel->r_info);
a761 2
      bfd_boolean is_branch;
      struct elfNN_ia64_dyn_sym_info *dyn_i;
d763 4
a766 24
      switch (r_type)
	{
	case R_IA64_PCREL21B:
	case R_IA64_PCREL21BI:
	case R_IA64_PCREL21M:
	case R_IA64_PCREL21F:
	  if (!link_info->need_relax_finalize)
	    continue;
	  is_branch = TRUE;
	  break;

	case R_IA64_LTOFF22X:
	case R_IA64_LDXMOV:
	  if (link_info->need_relax_finalize)
	    {
	      sec->need_finalize_relax = 1;
	      continue;
	    }
	  is_branch = FALSE;
	  break;

	default:
	  continue;
	}
d786 1
a786 1
	  isym = isymbuf + ELFNN_R_SYM (irel->r_info);
d788 1
a788 1
	    continue;	/* We can't do anything with undefined symbols.  */
a798 1
	  dyn_i = get_dyn_sym_info (ia64_info, NULL, abfd, irel, FALSE);
d804 1
d814 1
a814 1
	  dyn_i = get_dyn_sym_info (ia64_info, h, abfd, irel, FALSE);
d818 1
a818 1
	  if (is_branch && dyn_i && dyn_i->want_plt2)
a819 5
	      /* Internal branches shouldn't be sent to the PLT.
		 Leave this for now and we'll give an error later.  */
	      if (r_type != R_IA64_PCREL21B)
		continue;

a821 1
	      BFD_ASSERT (irel->r_addend == 0);
a822 5

	  /* Can't do anything else with dynamic symbols.  */
	  else if (elfNN_ia64_dynamic_symbol_p (h, link_info, r_type))
	    continue;

d825 1
a825 1
	      /* We can't do anything with undefined symbols.  */
d835 4
a838 9
      if (tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	toff = _bfd_merged_section_offset (abfd, &tsec,
					   elf_section_data (tsec)->sec_info,
					   toff + irel->r_addend,
					   (bfd_vma) 0);
      else
	toff += irel->r_addend;

      symaddr = tsec->output_section->vma + tsec->output_offset + toff;
d841 8
d850 5
a854 10
      if (is_branch)
	{
	  reladdr = (sec->output_section->vma
		     + sec->output_offset
		     + roff) & (bfd_vma) -4;

	  /* If the branch is in range, no need to do anything.  */
	  if ((bfd_signed_vma) (symaddr - reladdr) >= -0x1000000
	      && (bfd_signed_vma) (symaddr - reladdr) <= 0x0FFFFF0)
	    continue;
d856 4
a859 5
	  /* If the branch and target are in the same section, you've
	     got one honking big section and we can't help you.  You'll
	     get an error message later.  */
	  if (tsec == sec)
	    continue;
d861 5
a865 52
	  /* Look for an existing fixup to this address.  */
	  for (f = fixups; f ; f = f->next)
	    if (f->tsec == tsec && f->toff == toff)
	      break;

	  if (f == NULL)
	    {
	      /* Two alternatives: If it's a branch to a PLT entry, we can
		 make a copy of the FULL_PLT entry.  Otherwise, we'll have
		 to use a `brl' insn to get where we're going.  */

	      size_t size;

	      if (tsec == ia64_info->plt_sec)
		size = sizeof (plt_full_entry);
	      else
		size = oor_branch_size;

	      /* Resize the current section to make room for the new branch. */
	      trampoff = (sec->_cooked_size + 15) & (bfd_vma) -16;
	      amt = trampoff + size;
	      contents = (bfd_byte *) bfd_realloc (contents, amt);
	      if (contents == NULL)
		goto error_return;
	      sec->_cooked_size = amt;

	      if (tsec == ia64_info->plt_sec)
		{
		  memcpy (contents + trampoff, plt_full_entry, size);

		  /* Hijack the old relocation for use as the PLTOFF reloc.  */
		  irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
					       R_IA64_PLTOFF22);
		  irel->r_offset = trampoff;
		}
	      else
		{
		  if (size == sizeof (oor_ip))
		    {
		      memcpy (contents + trampoff, oor_ip, size);
		      irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
						   R_IA64_PCREL64I);
		      irel->r_addend -= 16;
		      irel->r_offset = trampoff + 2;
		    }
		  else
		    {
		      memcpy (contents + trampoff, oor_brl, size);
		      irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
						   R_IA64_PCREL60B);
		      irel->r_offset = trampoff + 2;
		    }
d867 1
a867 1
		}
d869 2
a870 9
	      /* Record the fixup so we don't do it again this section.  */
	      f = (struct one_fixup *)
		bfd_malloc ((bfd_size_type) sizeof (*f));
	      f->next = fixups;
	      f->tsec = tsec;
	      f->toff = toff;
	      f->trampoff = trampoff;
	      fixups = f;
	    }
d873 5
a877 2
	      /* Nop out the reloc, since we're finalizing things here.  */
	      irel->r_info = ELFNN_R_INFO (0, R_IA64_NONE);
d880 5
a884 5
	  /* Fix up the existing branch to hit the trampoline.  Hope like
	     hell this doesn't overflow too.  */
	  if (elfNN_ia64_install_value (abfd, contents + roff,
					f->trampoff - (roff & (bfd_vma) -4),
					r_type) != bfd_reloc_ok)
d886 1
d888 1
a888 7
	  changed_contents = TRUE;
	  changed_relocs = TRUE;
	}
      else
	{
	  /* Fetch the gp.  */
	  if (gp == 0)
d890 1
a890 14
	      bfd *obfd = sec->output_section->owner;
	      gp = _bfd_get_gp_value (obfd);
	      if (gp == 0)
		{
		  if (!elfNN_ia64_choose_gp (obfd, link_info))
		    goto error_return;
		  gp = _bfd_get_gp_value (obfd);
		}
	    }

	  /* If the data is out of range, do nothing.  */
	  if ((bfd_signed_vma) (symaddr - gp) >= 0x200000
	      ||(bfd_signed_vma) (symaddr - gp) < -0x200000)
	    continue;
d892 1
a892 2
	  if (r_type == R_IA64_LTOFF22X)
	    {
d894 2
a895 7
					   R_IA64_GPREL22);
	      changed_relocs = TRUE;
	      if (dyn_i->want_gotx)
		{
		  dyn_i->want_gotx = 0;
		  changed_got |= !dyn_i->want_got;
		}
d899 12
a910 4
	      elfNN_ia64_relax_ldxmov (abfd, contents, roff);
	      irel->r_info = ELFNN_R_INFO (0, R_IA64_NONE);
	      changed_contents = TRUE;
	      changed_relocs = TRUE;
d912 13
d926 10
a937 5
  /* ??? If we created fixups, this may push the code segment large
     enough that the data segment moves, which will change the GP.
     Reset the GP so that we re-calculate next round.  We need to
     do this at the _beginning_ of the next round; now will not do.  */
      
a977 19
  if (changed_got)
    {
      struct elfNN_ia64_allocate_data data;
      data.info = link_info;
      data.ofs = 0;
      ia64_info->self_dtpmod_offset = (bfd_vma) -1;

      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_global_data_got, &data);
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_global_fptr_got, &data);
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_local_got, &data);
      ia64_info->got_sec->_raw_size = data.ofs;
      ia64_info->got_sec->_cooked_size = data.ofs;

      /* ??? Resize .rela.got too.  */
    }

  if (!link_info->need_relax_finalize)
    sec->need_finalize_relax = 0;

d979 1
a979 1
  return TRUE;
d990 1
a990 34
  return FALSE;
}

static void
elfNN_ia64_relax_ldxmov (abfd, contents, off)
     bfd *abfd;
     bfd_byte *contents;
     bfd_vma off;
{
  int shift, r1, r3;
  bfd_vma dword, insn;

  switch ((int)off & 0x3)
    {
    case 0: shift =  5; break;
    case 1: shift = 14; off += 3; break;
    case 2: shift = 23; off += 6; break;
    default:
      abort ();
    }

  dword = bfd_get_64 (abfd, contents + off);
  insn = (dword >> shift) & 0x1ffffffffffLL;

  r1 = (insn >> 6) & 127;
  r3 = (insn >> 20) & 127;
  if (r1 == r3)
    insn = 0x8000000;				   /* nop */
  else
    insn = (insn & 0x7f01fff) | 0x10800000000LL;   /* (qp) mov r1 = r3 */

  dword &= ~(0x1ffffffffffLL << shift);
  dword |= (insn << shift);
  bfd_put_64 (abfd, dword, contents + off);
d993 1
a993 1
/* Return TRUE if NAME is an unwind table section name.  */
d995 1
a995 1
static inline bfd_boolean
d1004 1
a1004 1
    return FALSE;
d1017 1
a1017 1
static bfd_boolean
d1020 1
a1020 1
     Elf_Internal_Shdr *hdr;
d1038 1
a1038 1
	return FALSE;
d1042 1
a1042 1
      return FALSE;
d1046 1
a1046 1
    return FALSE;
d1049 1
a1049 1
  return TRUE;
d1057 1
a1057 1
static bfd_boolean
d1060 1
a1060 1
     Elf_Internal_Shdr *hdr;
d1065 1
a1065 1
  return TRUE;
d1071 1
a1071 1
static bfd_boolean
d1074 1
a1074 1
     Elf_Internal_Shdr *hdr;
d1114 1
a1114 1
  return TRUE;
d1123 1
a1123 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d1208 1
a1208 1
      elf_flags_init (abfd) = TRUE;
d1215 1
a1215 1
static bfd_boolean
d1226 1
a1226 1
      && !info->relocatable
d1241 1
a1241 1
	    return FALSE;
d1248 109
a1356 1
  return TRUE;
d1381 2
a1382 2
static bfd_boolean
elfNN_ia64_modify_segment_map (abfd, info)
a1383 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1402 1
a1402 1
	    return FALSE;
d1450 1
a1450 1
		return FALSE;
d1494 1
a1494 1
  return TRUE;
d1500 1
a1500 1
static bfd_boolean
d1510 2
a1511 2
static bfd_boolean
elfNN_ia64_dynamic_symbol_p (h, info, r_type)
a1513 1
     int r_type;
d1515 2
a1516 3
  bfd_boolean ignore_protected
    = ((r_type & 0xf8) == 0x40		/* FPTR relocs */
       || (r_type & 0xf8) == 0x50);	/* LTOFF_FPTR relocs */
d1518 26
a1543 1
  return _bfd_elf_dynamic_symbol_p (h, info, ignore_protected);
d1546 38
d1615 1
a1615 1
     const struct elf_backend_data *bed ATTRIBUTE_UNUSED;
d1630 1
a1630 2
        | ELF_LINK_HASH_REF_REGULAR_NONWEAK
        | ELF_LINK_HASH_NEEDS_PLT));
d1667 1
a1667 1
     bfd_boolean force_local;
d1677 1
a1677 31
    {
      dyn_i->want_plt2 = 0;
      dyn_i->want_plt = 0;
    }
}

/* Compute a hash of a local hash entry.  */

static hashval_t
elfNN_ia64_local_htab_hash (ptr)
     const void *ptr;
{
  struct elfNN_ia64_local_hash_entry *entry
    = (struct elfNN_ia64_local_hash_entry *) ptr;

  return (((entry->id & 0xff) << 24) | ((entry->id & 0xff00) << 8))
	  ^ entry->r_sym ^ (entry->id >> 16);
}

/* Compare local hash entries.  */

static int
elfNN_ia64_local_htab_eq (ptr1, ptr2)
     const void *ptr1, *ptr2;
{
  struct elfNN_ia64_local_hash_entry *entry1
    = (struct elfNN_ia64_local_hash_entry *) ptr1;
  struct elfNN_ia64_local_hash_entry *entry2
    = (struct elfNN_ia64_local_hash_entry *) ptr2;

  return entry1->id == entry2->id && entry1->r_sym == entry2->r_sym;
d1690 1
a1690 1
  ret = bfd_zmalloc ((bfd_size_type) sizeof (*ret));
a1692 1

d1696 1
a1696 10
      free (ret);
      return 0;
    }

  ret->loc_hash_table = htab_try_create (1024, elfNN_ia64_local_htab_hash,
					 elfNN_ia64_local_htab_eq, NULL);
  ret->loc_hash_memory = objalloc_create ();
  if (!ret->loc_hash_table || !ret->loc_hash_memory)
    {
      free (ret);
d1700 3
d1706 1
a1706 1
/* Destroy IA-64 linker hash table.  */
d1708 5
a1712 3
static void
elfNN_ia64_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
d1714 2
a1715 7
  struct elfNN_ia64_link_hash_table *ia64_info
    = (struct elfNN_ia64_link_hash_table *) hash;
  if (ia64_info->loc_hash_table)
    htab_delete (ia64_info->loc_hash_table);
  if (ia64_info->loc_hash_memory)
    objalloc_free ((struct objalloc *) ia64_info->loc_hash_memory);
  _bfd_generic_link_hash_table_free (hash);
d1722 1
a1722 1
  bfd_boolean (*func) PARAMS ((struct elfNN_ia64_dyn_sym_info *, PTR));
d1726 1
a1726 1
static bfd_boolean
d1742 2
a1743 2
      return FALSE;
  return TRUE;
d1746 3
a1748 3
static bfd_boolean
elfNN_ia64_local_dyn_sym_thunk (slot, xdata)
     void **slot;
d1752 1
a1752 1
    = (struct elfNN_ia64_local_hash_entry *) *slot;
d1759 2
a1760 2
      return 0;
  return 1;
d1766 1
a1766 1
     bfd_boolean (*func) PARAMS ((struct elfNN_ia64_dyn_sym_info *, PTR));
d1776 2
a1777 2
  htab_traverse (ia64_info->loc_hash_table,
		 elfNN_ia64_local_dyn_sym_thunk, &xdata);
d1780 1
a1780 1
static bfd_boolean
d1789 1
a1789 1
    return FALSE;
a1798 2
    /* The .got section is always aligned at 8 bytes.  */
    bfd_set_section_alignment (abfd, ia64_info->got_sec, 3);
d1802 1
a1802 1
    return FALSE;
d1812 1
a1812 1
    return FALSE;
d1823 1
a1823 1
    return FALSE;
d1826 1
a1826 1
  return TRUE;
d1835 1
a1835 1
     bfd_boolean create;
d1837 6
a1842 10
  struct elfNN_ia64_local_hash_entry e, *ret;
  asection *sec = abfd->sections;
  hashval_t h = (((sec->id & 0xff) << 24) | ((sec->id & 0xff00) << 8))
		^ ELFNN_R_SYM (rel->r_info) ^ (sec->id >> 16);
  void **slot;

  e.id = sec->id;
  e.r_sym = ELFNN_R_SYM (rel->r_info);
  slot = htab_find_slot_with_hash (ia64_info->loc_hash_table, &e, h,
				   create ? INSERT : NO_INSERT);
d1844 2
a1845 2
  if (!slot)
    return NULL;
d1847 5
a1851 2
  if (*slot)
    return (struct elfNN_ia64_local_hash_entry *) *slot;
d1853 4
a1856 10
  ret = (struct elfNN_ia64_local_hash_entry *)
	objalloc_alloc ((struct objalloc *) ia64_info->loc_hash_memory,
			sizeof (struct elfNN_ia64_local_hash_entry));
  if (ret)
    {
      memset (ret, 0, sizeof (*ret));
      ret->id = sec->id;
      ret->r_sym = ELFNN_R_SYM (rel->r_info);
      *slot = ret;
    }
d1869 1
a1869 1
     bfd_boolean create;
d1882 1
a1882 5
      if (!loc_h)
	{
	  BFD_ASSERT (!create);
	  return NULL;
	}
a1924 4
      /* The .got section is always aligned at 8 bytes.  */
      if (!bfd_set_section_alignment (abfd, got, 3))
	return 0;

d1933 1
a1933 1
   because it contains "official procedure descriptors".  The "official"
d1940 1
a1940 1
     struct bfd_link_info *info;
d1960 1
a1960 1
				      | (info->pie ? 0 : SEC_READONLY)
a1968 20

      if (info->pie)
	{
	  asection *fptr_rel;
	  fptr_rel = bfd_make_section(dynobj, ".rela.opd");
	  if (fptr_rel == NULL
	      || !bfd_set_section_flags (dynobj, fptr_rel,
					 (SEC_ALLOC | SEC_LOAD
					  | SEC_HAS_CONTENTS
					  | SEC_IN_MEMORY
					  | SEC_LINKER_CREATED
					  | SEC_READONLY))
	      || !bfd_set_section_alignment (abfd, fptr_rel, 3))
	    {
	      BFD_ASSERT (0);
	      return NULL;
	    }

	  ia64_info->rel_fptr_sec = fptr_rel;
	}
d2016 1
a2016 1
     bfd_boolean create;
d2061 1
a2061 1
static bfd_boolean
d2079 1
a2079 1
	return FALSE;
d2089 1
a2089 1
  return TRUE;
d2092 1
a2092 1
static bfd_boolean
d2105 2
a2106 2
  if (info->relocatable)
    return TRUE;
d2118 9
a2126 10
	NEED_GOTX = 2,
	NEED_FPTR = 4,
	NEED_PLTOFF = 8,
	NEED_MIN_PLT = 16,
	NEED_FULL_PLT = 32,
	NEED_DYNREL = 64,
	NEED_LTOFF_FPTR = 128,
	NEED_TPREL = 256,
	NEED_DTPMOD = 512,
	NEED_DTPREL = 1024
d2133 1
a2133 1
      bfd_boolean maybe_dynamic;
d2153 3
a2155 3
      maybe_dynamic = FALSE;
      if (h && ((!info->executable
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
d2157 3
a2159 2
		|| h->root.type == bfd_link_hash_defweak))
	maybe_dynamic = TRUE;
d2215 1
a2215 1
	  if (info->shared || h)
d2223 1
a2227 4
	case R_IA64_LTOFF22X:
	  need_entry = NEED_GOTX;
	  break;

d2264 4
a2267 1
	  if (info->shared || maybe_dynamic)
d2303 1
a2303 1
      dyn_i = get_dyn_sym_info (ia64_info, h, abfd, rel, TRUE);
d2309 1
a2309 2
      if (need_entry & (NEED_GOT | NEED_GOTX | NEED_TPREL
			| NEED_DTPMOD | NEED_DTPREL))
d2315 1
a2315 1
		return FALSE;
a2318 2
	  if (need_entry & NEED_GOTX)
	    dyn_i->want_gotx = 1;
d2332 1
a2332 1
		return FALSE;
d2338 3
a2340 1
	  if (!h && info->shared)
d2344 1
a2344 1
		return FALSE;
d2366 1
a2366 1
	      srel = get_reloc_section (abfd, ia64_info, sec, TRUE);
d2368 1
a2368 1
		return FALSE;
d2371 1
a2371 1
	    return FALSE;
d2375 1
a2375 1
  return TRUE;
d2378 6
d2387 1
a2387 1
static bfd_boolean
d2394 1
a2394 1
  if ((dyn_i->want_got || dyn_i->want_gotx)
d2396 4
a2399 1
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0))
d2411 2
a2412 17
      if (elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0))
	{
	  dyn_i->dtpmod_offset = x->ofs;
	  x->ofs += 8;
	}
      else
	{
	  struct elfNN_ia64_link_hash_table *ia64_info;

	  ia64_info = elfNN_ia64_hash_table (x->info);
	  if (ia64_info->self_dtpmod_offset == (bfd_vma) -1)
	    {
	      ia64_info->self_dtpmod_offset = x->ofs;
	      x->ofs += 8;
	    }
	  dyn_i->dtpmod_offset = ia64_info->self_dtpmod_offset;
	}
d2419 1
a2419 1
  return TRUE;
d2424 1
a2424 1
static bfd_boolean
d2433 2
a2434 1
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, R_IA64_FPTR64LSB))
d2439 1
a2439 1
  return TRUE;
d2444 1
a2444 1
static bfd_boolean
d2451 3
a2453 2
  if ((dyn_i->want_got || dyn_i->want_gotx)
      && !elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0))
d2458 1
a2458 1
  return TRUE;
d2483 1
a2483 1
static bfd_boolean
d2499 6
a2504 4
      if (!x->info->executable
	  && (!h
	      || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	      || h->root.type != bfd_link_hash_undefweak))
d2514 1
a2514 1
		return FALSE;
d2527 1
a2527 1
  return TRUE;
d2532 1
a2532 1
static bfd_boolean
d2549 1
a2549 1
      if (elfNN_ia64_dynamic_symbol_p (h, x->info, 0))
d2565 1
a2565 1
  return TRUE;
d2570 1
a2570 1
static bfd_boolean
d2590 1
a2590 1
  return TRUE;
d2598 1
a2598 1
static bfd_boolean
d2610 1
a2610 1
  return TRUE;
d2616 1
a2616 1
static bfd_boolean
d2624 1
a2624 1
  bfd_boolean dynamic_symbol, shared, resolved_zero;
d2627 5
a2631 4

  /* Note that this can't be used in relation to FPTR relocs below.  */
  dynamic_symbol = elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0);

a2632 3
  resolved_zero = (dyn_i->h
		   && ELF_ST_VISIBILITY (dyn_i->h->other)
		   && dyn_i->h->root.type == bfd_link_hash_undefweak);
d2643 4
a2646 5
	  /* Allocate one iff !want_fptr and not PIE, which by this point
	     will be true only if we're actually allocating one statically
	     in the main executable.  Position independent executables
	     need a relative reloc.  */
	  if (dyn_i->want_fptr && !x->info->pie)
d2677 3
a2679 13
  if ((!resolved_zero
       && (dynamic_symbol || shared)
       && (dyn_i->want_got || dyn_i->want_gotx))
      || (dyn_i->want_ltoff_fptr
	  && dyn_i->h
	  && dyn_i->h->dynindx != -1))
    {
      if (!dyn_i->want_ltoff_fptr
	  || !x->info->pie
	  || dyn_i->h == NULL
	  || dyn_i->h->root.type != bfd_link_hash_undefweak)
	ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
    }
d2682 1
a2682 1
  if (dynamic_symbol && dyn_i->want_dtpmod)
a2685 5
  if (ia64_info->rel_fptr_sec && dyn_i->want_fptr)
    {
      if (dyn_i->h == NULL || dyn_i->h->root.type != bfd_link_hash_undefweak)
	ia64_info->rel_fptr_sec->_raw_size += sizeof (ElfNN_External_Rela);
    }
d2687 1
a2687 1
  if (!resolved_zero && dyn_i->want_pltoff)
d2702 1
a2702 1
  return TRUE;
d2705 1
a2705 1
static bfd_boolean
d2722 1
a2722 1
      return TRUE;
d2732 1
a2732 1
  return TRUE;
d2735 1
a2735 1
static bfd_boolean
d2737 1
a2737 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d2744 1
a2744 1
  bfd_boolean relplt = FALSE;
a2747 1
  ia64_info->self_dtpmod_offset = (bfd_vma) -1;
d2753 1
a2753 1
      && info->executable)
d2757 2
a2758 2
      sec->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
      sec->_raw_size = strlen (ELF_DYNAMIC_INTERPRETER) + 1;
d2783 1
a2783 1
     We do this even though dynamic_sections_created may be FALSE, because
a2825 2
      if (info->shared && ia64_info->self_dtpmod_offset != (bfd_vma) -1)
	ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
d2833 1
a2833 1
      bfd_boolean strip;
d2849 1
a2849 1
	strip = FALSE;
a2863 9
      else if (sec == ia64_info->rel_fptr_sec)
	{
	  if (strip)
	    ia64_info->rel_fptr_sec = NULL;
	  else
	    /* We use the reloc_count field as a counter if we need to
	       copy relocs into the output file.  */
	    sec->reloc_count = 0;
	}
d2880 1
a2880 1
	      relplt = TRUE;
d2895 1
a2895 1
	    strip = FALSE;
d2916 1
a2916 1
	    return FALSE;
d2926 1
a2926 1
      if (info->executable)
d2934 1
a2934 1
	    return FALSE;
d2938 1
a2938 1
	return FALSE;
d2940 1
a2940 1
	return FALSE;
d2947 1
a2947 1
	    return FALSE;
d2953 1
a2953 1
	return FALSE;
d2958 1
a2958 1
	    return FALSE;
d2965 1
a2965 1
  return TRUE;
d3206 2
a3207 1
  bfd_byte *loc;
d3213 1
a3213 1
  if (outrel.r_offset >= (bfd_vma) -2)
a3220 2
  else
    outrel.r_offset += sec->output_section->vma + sec->output_offset;
d3222 3
a3224 3
  loc = srel->contents;
  loc += srel->reloc_count++ * sizeof (ElfNN_External_Rela);
  bfd_elfNN_swap_reloca_out (abfd, &outrel, loc);
d3244 1
a3244 1
  bfd_boolean done;
d3254 1
a3254 1
      dyn_i->tprel_done = TRUE;
d3258 2
a3259 11
      if (dyn_i->dtpmod_offset != ia64_info->self_dtpmod_offset)
	{
	  done = dyn_i->dtpmod_done;
	  dyn_i->dtpmod_done = TRUE;
	}
      else
	{
	  done = ia64_info->self_dtpmod_done;
	  ia64_info->self_dtpmod_done = TRUE;
	  dynindx = 0;
	}
d3264 1
a3264 1
      dyn_i->dtprel_done = TRUE;
d3269 1
a3269 1
      dyn_i->got_done = TRUE;
d3282 4
a3285 11
      if (((info->shared
	    && (!dyn_i->h
		|| ELF_ST_VISIBILITY (dyn_i->h->other) == STV_DEFAULT
		|| dyn_i->h->root.type != bfd_link_hash_undefweak)
	    && dyn_r_type != R_IA64_DTPREL64LSB)
           || elfNN_ia64_dynamic_symbol_p (dyn_i->h, info, dyn_r_type)
	   || (dynindx != -1 && dyn_r_type == R_IA64_FPTR64LSB))
	  && (!dyn_i->want_ltoff_fptr
	      || !info->pie
	      || !dyn_i->h
	      || dyn_i->h->root.type != bfd_link_hash_undefweak))
d3320 1
a3320 1
		  BFD_ASSERT (FALSE);
a3363 18
      if (ia64_info->rel_fptr_sec)
	{
	  Elf_Internal_Rela outrel;
	  bfd_byte *loc;

	  if (bfd_little_endian (abfd))
	    outrel.r_info = ELFNN_R_INFO (0, R_IA64_IPLTLSB);
	  else
	    outrel.r_info = ELFNN_R_INFO (0, R_IA64_IPLTMSB);
	  outrel.r_addend = value;
	  outrel.r_offset = (fptr_sec->output_section->vma
			     + fptr_sec->output_offset
			     + dyn_i->fptr_offset);
	  loc = ia64_info->rel_fptr_sec->contents;
	  loc += ia64_info->rel_fptr_sec->reloc_count++
		 * sizeof (ElfNN_External_Rela);
	  bfd_elfNN_swap_reloca_out (abfd, &outrel, loc);
	}
d3383 1
a3383 1
     bfd_boolean is_plt;
d3403 1
a3403 5
      if (!is_plt
	  && info->shared
	  && (!dyn_i->h
	      || ELF_ST_VISIBILITY (dyn_i->h->other) == STV_DEFAULT
	      || dyn_i->h->root.type != bfd_link_hash_undefweak))
d3442 2
a3443 1
  asection *tls_sec = elf_hash_table (info)->tls_sec;
d3445 3
a3447 2
  BFD_ASSERT (tls_sec != NULL);
  return tls_sec->vma - align_power ((bfd_vma) 16, tls_sec->alignment_power);
d3458 2
a3459 2
  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
  return elf_hash_table (info)->tls_sec->vma;
d3481 2
a3482 3
/* Make sure we've got ourselves a nice fat __gp value.  */
static bfd_boolean
elfNN_ia64_choose_gp (abfd, info)
a3485 5
  bfd_vma min_vma = (bfd_vma) -1, max_vma = 0;
  bfd_vma min_short_vma = min_vma, max_short_vma = 0;
  struct elf_link_hash_entry *gp;
  bfd_vma gp_val;
  asection *os;
d3487 1
d3491 2
a3492 3
  /* Find the min and max vma of all sections marked short.  Also collect
     min and max vma of any type, for use in selecting a nice gp.  */
  for (os = abfd->sections; os ; os = os->next)
d3494 12
a3505 1
      bfd_vma lo, hi;
d3507 2
a3508 2
      if ((os->flags & SEC_ALLOC) == 0)
	continue;
d3510 16
a3525 15
      lo = os->vma;
      hi = os->vma + os->_raw_size;
      if (hi < lo)
	hi = (bfd_vma) -1;

      if (min_vma > lo)
	min_vma = lo;
      if (max_vma < hi)
	max_vma = hi;
      if (os->flags & SEC_SMALL_DATA)
	{
	  if (min_short_vma > lo)
	    min_short_vma = lo;
	  if (max_short_vma < hi)
	    max_short_vma = hi;
a3526 1
    }
d3528 13
a3540 24
  /* See if the user wants to force a value.  */
  gp = elf_link_hash_lookup (elf_hash_table (info), "__gp", FALSE,
			     FALSE, FALSE);

  if (gp
      && (gp->root.type == bfd_link_hash_defined
	  || gp->root.type == bfd_link_hash_defweak))
    {
      asection *gp_sec = gp->root.u.def.section;
      gp_val = (gp->root.u.def.value
		+ gp_sec->output_section->vma
		+ gp_sec->output_offset);
    }
  else
    {
      /* Pick a sensible value.  */

      asection *got_sec = ia64_info->got_sec;

      /* Start with just the address of the .got.  */
      if (got_sec)
	gp_val = got_sec->output_section->vma;
      else if (max_short_vma != 0)
	gp_val = min_short_vma;
a3541 9
	gp_val = min_vma;

      /* If it is possible to address the entire image, but we
	 don't with the choice above, adjust.  */
      if (max_vma - min_vma < 0x400000
	  && max_vma - gp_val <= 0x200000
	  && gp_val - min_vma > 0x200000)
	gp_val = min_vma + 0x200000;
      else if (max_short_vma != 0)
d3543 1
a3543 3
	  /* If we don't cover all the short data, adjust.  */
	  if (max_short_vma - gp_val >= 0x200000)
	    gp_val = min_short_vma + 0x200000;
d3545 1
a3545 5
	  /* If we're addressing stuff past the end, adjust back.  */
	  if (gp_val > max_vma)
	    gp_val = max_vma - 0x200000 + 8;
	}
    }
d3547 7
a3553 2
  /* Validate whether all SHF_IA_64_SHORT sections are within
     range of the chosen GP.  */
d3555 16
a3570 19
  if (max_short_vma != 0)
    {
      if (max_short_vma - min_short_vma >= 0x400000)
	{
	  (*_bfd_error_handler)
	    (_("%s: short data segment overflowed (0x%lx >= 0x400000)"),
	     bfd_get_filename (abfd),
	     (unsigned long) (max_short_vma - min_short_vma));
	  return FALSE;
	}
      else if ((gp_val > min_short_vma
		&& gp_val - min_short_vma > 0x200000)
	       || (gp_val < max_short_vma
		   && max_short_vma - gp_val >= 0x200000))
	{
	  (*_bfd_error_handler)
	    (_("%s: __gp does not cover short data segment"),
	     bfd_get_filename (abfd));
	  return FALSE;
a3571 1
    }
d3573 2
a3574 1
  _bfd_set_gp_value (abfd, gp_val);
d3576 1
a3576 20
  return TRUE;
}

static bfd_boolean
elfNN_ia64_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  asection *unwind_output_sec;

  ia64_info = elfNN_ia64_hash_table (info);

  /* Make sure we've got ourselves a nice fat __gp value.  */
  if (!info->relocatable)
    {
      bfd_vma gp_val = _bfd_get_gp_value (abfd);
      struct elf_link_hash_entry *gp;

      if (gp_val == 0)
d3578 18
a3595 3
	  if (! elfNN_ia64_choose_gp (abfd, info))
	    return FALSE;
	  gp_val = _bfd_get_gp_value (abfd);
d3598 2
a3599 2
      gp = elf_link_hash_lookup (elf_hash_table (info), "__gp", FALSE,
			         FALSE, FALSE);
d3612 1
a3612 1
  if (!info->relocatable)
d3621 1
a3621 1
	    return FALSE;
d3627 1
a3627 1
    return FALSE;
d3640 1
a3640 1
	return FALSE;
d3643 1
a3643 1
  return TRUE;
d3646 1
a3646 1
static bfd_boolean
d3663 1
a3663 1
  bfd_boolean ret_val = TRUE;	/* for non-fatal errors */
d3670 1
a3670 1
  if (info->relocatable)
d3679 1
a3679 1
      return TRUE;
d3683 1
a3683 1
  srel = get_reloc_section (input_bfd, ia64_info, input_section, FALSE);
d3699 2
a3700 2
      bfd_boolean dynamic_symbol_p;
      bfd_boolean undef_weak_ref;
d3709 1
a3709 1
	  ret_val = FALSE;
d3718 1
a3718 1
      undef_weak_ref = FALSE;
a3722 1
	  asection *msec;
d3725 1
a3725 2
	  msec = sym_sec;
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, &msec, rel);
d3728 2
a3729 1
	      && sym_sec->sec_info_type == ELF_INFO_TYPE_MERGE)
d3732 2
a3733 2

	      loc_h = get_local_sym_hash (ia64_info, input_bfd, rel, FALSE);
d3737 1
d3761 1
a3761 2
	  bfd_boolean unresolved_reloc;
	  bfd_boolean warned;
d3763 46
a3808 10
	  RELOC_FOR_GLOBAL_SYMBOL (h, elf_sym_hashes (input_bfd),
				   r_symndx,
				   symtab_hdr, value, sym_sec,
				   unresolved_reloc, info,
				   warned);

	  if (h->root.type == bfd_link_hash_undefweak)
	    undef_weak_ref = TRUE;
	  else if (warned)
	    continue;
d3813 1
a3813 1
      dynamic_symbol_p = elfNN_ia64_dynamic_symbol_p (h, info, r_type);
d3829 5
a3833 1
	  if ((dynamic_symbol_p || info->shared)
d3879 1
a3879 1
		      ret_val = FALSE;
d3886 2
d3892 1
a3892 1
	  /* Fall through.  */
d3912 1
a3912 1
	      ret_val = FALSE;
d3922 1
a3922 1
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
d3933 2
a3934 2
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
	  value = set_pltoff_entry (output_bfd, info, dyn_i, value, FALSE);
d3944 1
a3944 1
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
d3950 1
a3950 1
	  if (!dyn_i->want_fptr || info->pie)
a3952 2
	      unsigned int dyn_r_type = r_type;
	      bfd_vma addend = rel->r_addend;
d3957 1
a3957 21
	      if (dyn_i->want_fptr)
		{
		  if (r_type == R_IA64_FPTR64I)
		    {
		      /* We can't represent this without a dynamic symbol.
			 Adjust the relocation to be against an output
			 section symbol, which are always present in the
			 dynamic symbol table.  */
		      /* ??? People shouldn't be doing non-pic code in
			 shared libraries.  Hork.  */
		      (*_bfd_error_handler)
			(_("%s: linking non-pic code in a position independent executable"),
			 bfd_archive_filename (input_bfd));
		      ret_val = FALSE;
		      continue;
		    }
		  dynindx = 0;
		  addend = value;
		  dyn_r_type = r_type + R_IA64_REL64LSB - R_IA64_FPTR64LSB;
		}
	      else if (h)
a3964 1
		  value = 0;
a3969 1
		  value = 0;
d3973 3
a3975 2
					    srel, rel->r_offset, dyn_r_type,
					    dynindx, addend);
d3990 1
a3990 1
	    dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
d4029 3
a4031 1
	  if (dynamic_symbol_p && r_symndx != 0)
d4041 23
d4069 1
a4069 1
	    dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, FALSE);
a4094 3
	case R_IA64_PCREL21BI:
	case R_IA64_PCREL21F:
	case R_IA64_PCREL21M:
a4096 21
	  /* The PCREL21BI reloc is specifically not intended for use with
	     dynamic relocs.  PCREL21F and PCREL21M are used for speculation
	     fixup code, and thus probably ought not be dynamic.  The 
	     PCREL22 and PCREL64I relocs aren't emitted as dynamic relocs.  */
	  if (dynamic_symbol_p)
	    {
	      const char *msg;

	      if (r_type == R_IA64_PCREL21BI)
		msg = _("%s: @@internal branch to dynamic symbol %s");
	      else if (r_type == R_IA64_PCREL21F || r_type == R_IA64_PCREL21M)
		msg = _("%s: speculation fixup to dynamic symbol %s");
	      else
		msg = _("%s: @@pcrel relocation against dynamic symbol %s");
	      (*_bfd_error_handler) (msg, bfd_archive_filename (input_bfd),
				     h->root.root.string);
	      ret_val = FALSE;
	      continue;
	    }
	  goto finish_pcrel;

d4128 1
a4128 1
		    if (m->sections[i] == input_section->output_section)
d4174 1
a4174 1
	      if (!dynamic_symbol_p)
a4216 2
	case R_IA64_DTPREL64LSB:
	case R_IA64_DTPREL64MSB:
a4225 2
	    long dynindx = h ? h->dynindx : -1;
	    bfd_vma r_addend = rel->r_addend;
d4231 2
a4232 10
		if (!dynamic_symbol_p)
		  {
		    if (!info->shared)
		      value -= elfNN_ia64_tprel_base (info);
		    else
		      {
			r_addend += value - elfNN_ia64_dtprel_base (info);
			dynindx = 0;
		      }
		  }
d4246 3
a4248 2
	    dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
	    value = set_got_entry (input_bfd, info, dyn_i, dynindx, r_addend,
d4272 1
a4272 1
	  return FALSE;
d4286 1
a4286 1
		  return FALSE;
d4293 2
a4294 2
	      return FALSE;
	    ret_val = FALSE;
d4313 1
a4313 1
		  return FALSE;
d4323 2
a4324 2
	      return FALSE;
	    ret_val = FALSE;
d4333 1
a4333 1
static bfd_boolean
d4344 1
a4344 1
  dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, FALSE);
d4353 1
d4371 1
a4371 1
      pltoff_addr = set_pltoff_entry (output_bfd, info, dyn_i, plt_addr, TRUE);
d4410 4
a4413 4
      loc = ia64_info->rel_pltoff_sec->contents;
      loc += ((ia64_info->rel_pltoff_sec->reloc_count + index)
	      * sizeof (ElfNN_External_Rela));
      bfd_elfNN_swap_reloca_out (output_bfd, &outrel, loc);
d4422 1
a4422 1
  return TRUE;
d4425 1
a4425 1
static bfd_boolean
d4491 1
a4491 1
      /* Initialize the PLT0 entry.  */
d4507 1
a4507 1
  return TRUE;
d4510 1
a4510 1
/* ELF file flag handling:  */
d4513 1
a4513 1
static bfd_boolean
d4522 2
a4523 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d4528 1
a4528 1
static bfd_boolean
d4534 1
a4534 1
  bfd_boolean ok = TRUE;
d4539 1
a4539 1
    return FALSE;
d4546 1
a4546 1
      elf_flags_init (obfd) = TRUE;
d4556 1
a4556 1
      return TRUE;
d4561 1
a4561 1
    return TRUE;
d4574 1
a4574 1
      ok = FALSE;
d4583 1
a4583 1
      ok = FALSE;
d4592 1
a4592 1
      ok = FALSE;
d4601 1
a4601 1
      ok = FALSE;
d4611 1
a4611 1
      ok = FALSE;
d4617 1
a4617 1
static bfd_boolean
d4638 1
a4638 1
  return TRUE;
d4662 1
a4662 8
static struct bfd_elf_special_section const elfNN_ia64_special_sections[]=
{
  { ".sbss",  5, -1, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { ".sdata", 6, -1, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { NULL,     0,  0, 0,            0 }
};

static bfd_boolean
d4680 1
a4680 1
bfd_boolean
d4689 1
a4689 1
      return TRUE;
d4691 1
a4691 1
  return FALSE;
a4692 17

static void
elfNN_hpux_backend_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED,
				      asymbol *asym)
{
  elf_symbol_type *elfsym = (elf_symbol_type *) asym;;

  switch (elfsym->internal_elf_sym.st_shndx)
    {
    case SHN_IA_64_ANSI_COMMON:
      asym->section = bfd_com_section_ptr;
      asym->value = elfsym->internal_elf_sym.st_size;
      asym->flags &= ~BSF_GLOBAL;
      break;
    }
}

a4730 2
#define bfd_elfNN_bfd_link_hash_table_free \
	elfNN_ia64_hash_table_free
d4759 1
d4769 21
a4789 1
#define elf_backend_special_sections	elfNN_ia64_special_sections
d4802 8
a4816 3

#undef elf_backend_symbol_processing
#define elf_backend_symbol_processing elfNN_hpux_backend_symbol_processing
@


1.58.4.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@a878 2
	  bfd_signed_vma offset;

a913 7

	      /* If trampoline is out of range, there is nothing we
		 can do.  */
	      offset = trampoff - (roff & (bfd_vma) -4);
	      if (offset < -0x1000000 || offset > 0x0FFFFF0)
		continue;

a959 6
	      /* If trampoline is out of range, there is nothing we
		 can do.  */
	      offset = f->trampoff - (roff & (bfd_vma) -4);
	      if (offset < -0x1000000 || offset > 0x0FFFFF0)
		continue;

d964 4
a967 2
	  /* Fix up the existing branch to hit the trampoline.  */
	  if (elfNN_ia64_install_value (abfd, contents + roff, offset,
@


1.58.4.4
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@a674 30
static void
elfNN_ia64_relax_brl (bfd *abfd, bfd_byte *contents, bfd_vma off)
{
  int template;
  bfd_byte *hit_addr;
  bfd_vma t0, t1, i0, i1, i2;

  hit_addr = (bfd_byte *) (contents + off);
  hit_addr -= (long) hit_addr & 0x3;
  t0 = bfd_get_64 (abfd, hit_addr);
  t1 = bfd_get_64 (abfd, hit_addr + 8);

  /* Keep the instruction in slot 0. */
  i0 = (t0 >> 5) & 0x1ffffffffffLL;
  /* Use nop.b for slot 1. */
  i1 = 0x4000000000LL;
  /* For slot 2, turn brl into br by masking out bit 40.  */
  i2 = (t1 >> 23) & 0x0ffffffffffLL;

  /* Turn a MLX bundle into a MBB bundle with the same stop-bit
     variety.  */
  template = 0x12;
  if ((t0 & 0x1fLL) == 5)
    template += 1;
  t0 = (i1 << 46) | (i0 << 5) | template;
  t1 = (i2 << 23) | (i1 >> 18);

  bfd_put_64 (abfd, t0, hit_addr);
  bfd_put_64 (abfd, t1, hit_addr + 8);
}
a767 2
	  /* In the finalize pass, all br relaxations are done. We can
	     skip it. */
a772 12
	case R_IA64_PCREL60B:
	  /* We can't optimize brl to br before the finalize pass since
	     br relaxations will increase the code size. Defer it to
	     the finalize pass.  */
	  if (link_info->need_relax_finalize)
	    {
	      sec->need_finalize_relax = 1;
	      continue;
	    }
	  is_branch = TRUE;
	  break;

a774 3
	  /* We can't relax ldx/mov before the finalize pass since
	     br relaxations will increase the code size. Defer it to
	     the finalize pass.  */
a887 19
	    {
	      /* If the 60-bit branch is in 21-bit range, optimize it. */
	      if (r_type == R_IA64_PCREL60B)
		{
		  elfNN_ia64_relax_brl (abfd, contents, roff);

		  irel->r_info
		    = ELF64_R_INFO (ELF64_R_SYM (irel->r_info),
				    R_IA64_PCREL21B);

		  /* If the original relocation offset points to slot
		     1, change it to slot 2.  */
		  if ((irel->r_offset & 3) == 1)
		    irel->r_offset += 1;
		}

	      continue;
	    }
	  else if (r_type == R_IA64_PCREL60B)
a3953 18
	      switch (r_type)
		{
		case R_IA64_IMM14:
		case R_IA64_IMM22:
		case R_IA64_IMM64:
		  /* ??? People shouldn't be doing non-pic code in
		     shared libraries nor dynamic executables.  */
		  (*_bfd_error_handler)
		    (_("%s: non-pic code with imm relocation against dynamic symbol `%s'"),
		     bfd_archive_filename (input_bfd),
		     h->root.root.string);
		  ret_val = FALSE;
		  continue;

		default:
		  break;
		}

d3981 11
a3991 1
		      break;
@


1.58.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a649 1
#ifdef USE_BRL
d656 1
a656 1
#else
a668 1
#endif
a1284 1
	  struct bfd_link_hash_entry *bh = NULL;
d1293 1
a1293 1
		 bed->collect, &bh)))
a1295 1
	  h = (struct elf_link_hash_entry *) bh;
@


1.58.2.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d3207 2
d3213 1
a3213 1
  if (outrel.r_offset >= (bfd_vma) -2)
a3220 2
  else
    outrel.r_offset += sec->output_section->vma + sec->output_offset;
@


1.58.2.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d29 1
a29 1

d34 1
a34 1

d41 1
a41 1

d45 1
a45 1

d52 1
a52 1

d95 1
a95 1
  /* TRUE when the section contents have been updated.  */
d103 1
a103 1
  /* TRUE for the different kinds of linker data we want created.  */
d120 1
a120 1
  /* TRUE if this hash entry's addends was translated for
d166 2
a167 2
  PARAMS ((bfd *abfd, arelent *bfd_reloc, Elf_Internal_Rela *elf_reloc));
static bfd_boolean elfNN_ia64_relax_section
d169 2
a170 2
	  bfd_boolean *again));
static bfd_boolean is_unwind_section_name
d172 6
a177 6
static bfd_boolean elfNN_ia64_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
static bfd_boolean elfNN_ia64_section_flags
  PARAMS ((flagword *, Elf_Internal_Shdr *));
static bfd_boolean elfNN_ia64_fake_sections
  PARAMS ((bfd *abfd, Elf_Internal_Shdr *hdr, asection *sec));
d179 2
a180 2
  PARAMS ((bfd *abfd, bfd_boolean linker));
static bfd_boolean elfNN_ia64_add_symbol_hook
d184 1
a184 1
static bfd_boolean elfNN_ia64_aix_vec
d186 1
a186 1
static bfd_boolean elfNN_ia64_aix_add_symbol_hook
d190 1
a190 1
static bfd_boolean elfNN_ia64_aix_link_add_symbols
d194 1
a194 1
static bfd_boolean elfNN_ia64_modify_segment_map
d196 1
a196 1
static bfd_boolean elfNN_ia64_is_local_label_name
d198 1
a198 1
static bfd_boolean elfNN_ia64_dynamic_symbol_p
d200 1
a200 1
static bfd_boolean elfNN_ia64_local_hash_table_init
d213 1
a213 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
d218 2
a219 2
	   bfd_boolean create, bfd_boolean copy));
static bfd_boolean elfNN_ia64_global_dyn_sym_thunk
d221 1
a221 1
static bfd_boolean elfNN_ia64_local_dyn_sym_thunk
d225 1
a225 1
	   bfd_boolean (*func) (struct elfNN_ia64_dyn_sym_info *, PTR),
d227 1
a227 1
static bfd_boolean elfNN_ia64_create_dynamic_sections
d231 1
a231 1
	   bfd *abfd, const Elf_Internal_Rela *rel, bfd_boolean create));
d235 1
a235 1
	   bfd *abfd, const Elf_Internal_Rela *rel, bfd_boolean create));
d247 2
a248 2
	   asection *sec, bfd_boolean create));
static bfd_boolean count_dyn_reloc
d251 1
a251 1
static bfd_boolean elfNN_ia64_check_relocs
d254 1
a254 1
static bfd_boolean elfNN_ia64_adjust_dynamic_symbol
d258 1
a258 1
static bfd_boolean allocate_fptr
d260 1
a260 1
static bfd_boolean allocate_global_data_got
d262 1
a262 1
static bfd_boolean allocate_global_fptr_got
d264 1
a264 1
static bfd_boolean allocate_local_got
d266 1
a266 1
static bfd_boolean allocate_pltoff_entries
d268 1
a268 1
static bfd_boolean allocate_plt_entries
d270 1
a270 1
static bfd_boolean allocate_plt2_entries
d272 1
a272 1
static bfd_boolean allocate_dynrel_entries
d274 1
a274 1
static bfd_boolean elfNN_ia64_size_dynamic_sections
d293 1
a293 1
	   bfd_vma value, bfd_boolean));
d300 1
a300 1
static bfd_boolean elfNN_ia64_final_link
d302 1
a302 1
static bfd_boolean elfNN_ia64_relocate_section
d307 1
a307 1
static bfd_boolean elfNN_ia64_finish_dynamic_symbol
d310 1
a310 1
static bfd_boolean elfNN_ia64_finish_dynamic_sections
d312 1
a312 1
static bfd_boolean elfNN_ia64_set_private_flags
d314 1
a314 1
static bfd_boolean elfNN_ia64_merge_private_bfd_data
d316 1
a316 1
static bfd_boolean elfNN_ia64_print_private_bfd_data
d320 1
a320 1
static bfd_boolean elfNN_ia64_hpux_vec
d324 1
a324 1
bfd_boolean elfNN_hpux_backend_section_from_bfd_section
d353 1
a353 1
	 elfNN_ia64_reloc, NAME, FALSE, 0, 0, IN)
d359 1
a359 1
    IA64_HOWTO (R_IA64_NONE,	    "NONE",	   0, FALSE, TRUE),
d361 94
a454 94
    IA64_HOWTO (R_IA64_IMM14,	    "IMM14",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_IMM22,	    "IMM22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_IMM64,	    "IMM64",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR32MSB,    "DIR32MSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR32LSB,    "DIR32LSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR64MSB,    "DIR64MSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_DIR64LSB,    "DIR64LSB",	   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_GPREL22,	    "GPREL22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL64I,    "GPREL64I",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL32MSB,  "GPREL32MSB",  2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL32LSB,  "GPREL32LSB",  2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL64MSB,  "GPREL64MSB",  4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_GPREL64LSB,  "GPREL64LSB",  4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_LTOFF22,	    "LTOFF22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF64I,    "LTOFF64I",	   0, FALSE, TRUE),

    IA64_HOWTO (R_IA64_PLTOFF22,    "PLTOFF22",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_PLTOFF64I,   "PLTOFF64I",   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_PLTOFF64MSB, "PLTOFF64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_PLTOFF64LSB, "PLTOFF64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_FPTR64I,	    "FPTR64I",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR32MSB,   "FPTR32MSB",   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR32LSB,   "FPTR32LSB",   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR64MSB,   "FPTR64MSB",   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_FPTR64LSB,   "FPTR64LSB",   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_PCREL60B,    "PCREL60B",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL21B,    "PCREL21B",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL21M,    "PCREL21M",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL21F,    "PCREL21F",	   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL32MSB,  "PCREL32MSB",  2, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL32LSB,  "PCREL32LSB",  2, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL64MSB,  "PCREL64MSB",  4, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL64LSB,  "PCREL64LSB",  4, TRUE, TRUE),

    IA64_HOWTO (R_IA64_LTOFF_FPTR22, "LTOFF_FPTR22", 0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64I, "LTOFF_FPTR64I", 0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR32MSB, "LTOFF_FPTR32MSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR32LSB, "LTOFF_FPTR32LSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64MSB, "LTOFF_FPTR64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF_FPTR64LSB, "LTOFF_FPTR64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_SEGREL32MSB, "SEGREL32MSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SEGREL32LSB, "SEGREL32LSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SEGREL64MSB, "SEGREL64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SEGREL64LSB, "SEGREL64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_SECREL32MSB, "SECREL32MSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SECREL32LSB, "SECREL32LSB", 2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SECREL64MSB, "SECREL64MSB", 4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_SECREL64LSB, "SECREL64LSB", 4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_REL32MSB,    "REL32MSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_REL32LSB,    "REL32LSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_REL64MSB,    "REL64MSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_REL64LSB,    "REL64LSB",	   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_LTV32MSB,    "LTV32MSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTV32LSB,    "LTV32LSB",	   2, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTV64MSB,    "LTV64MSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTV64LSB,    "LTV64LSB",	   4, FALSE, TRUE),

    IA64_HOWTO (R_IA64_PCREL21BI,   "PCREL21BI",   0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL22,     "PCREL22",     0, TRUE, TRUE),
    IA64_HOWTO (R_IA64_PCREL64I,    "PCREL64I",    0, TRUE, TRUE),

    IA64_HOWTO (R_IA64_IPLTMSB,	    "IPLTMSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_IPLTLSB,	    "IPLTLSB",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_COPY,	    "COPY",	   4, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LTOFF22X,    "LTOFF22X",	   0, FALSE, TRUE),
    IA64_HOWTO (R_IA64_LDXMOV,	    "LDXMOV",	   0, FALSE, TRUE),

    IA64_HOWTO (R_IA64_TPREL14,	    "TPREL14",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL22,	    "TPREL22",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64I,    "TPREL64I",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64MSB,  "TPREL64MSB",  8, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64LSB,  "TPREL64LSB",  8, FALSE, FALSE),
    IA64_HOWTO (R_IA64_LTOFF_TPREL22, "LTOFF_TPREL22",  0, FALSE, FALSE),

    IA64_HOWTO (R_IA64_DTPMOD64MSB, "TPREL64MSB",  8, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPMOD64LSB, "TPREL64LSB",  8, FALSE, FALSE),
    IA64_HOWTO (R_IA64_LTOFF_DTPMOD22, "LTOFF_DTPMOD22", 0, FALSE, FALSE),

    IA64_HOWTO (R_IA64_DTPREL14,    "DTPREL14",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL22,    "DTPREL22",	   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64I,   "DTPREL64I",   0, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL32MSB, "DTPREL32MSB", 4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL32LSB, "DTPREL32LSB", 4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64MSB, "DTPREL64MSB", 8, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64LSB, "DTPREL64LSB", 8, FALSE, FALSE),
    IA64_HOWTO (R_IA64_LTOFF_DTPREL22, "LTOFF_DTPREL22", 0, FALSE, FALSE),
d600 1
a600 1
     Elf_Internal_Rela *elf_reloc;
d675 1
a675 2
   relaxation of R_IA64_LTOFF22X and R_IA64_LDXMOV is handled in
   relocate_section directly.  */
d677 1
a677 1
static bfd_boolean
d682 1
a682 1
     bfd_boolean *again;
d699 2
a700 2
  bfd_boolean changed_contents = FALSE;
  bfd_boolean changed_relocs = FALSE;
d704 1
a704 1
  *again = FALSE;
d709 1
a709 1
    return TRUE;
d723 1
a723 1
    return FALSE;
d729 4
a732 8
    {
      unsigned long r_type = ELFNN_R_TYPE (irel->r_info);
      if (r_type == R_IA64_PCREL21B
	  || r_type == R_IA64_PCREL21BI
	  || r_type == R_IA64_PCREL21M
	  || r_type == R_IA64_PCREL21F)
	break;
    }
d739 1
a739 1
      return TRUE;
a757 1
      unsigned long r_type = ELFNN_R_TYPE (irel->r_info);
d763 3
a765 4
      if (r_type != R_IA64_PCREL21B
	  && r_type != R_IA64_PCREL21BI
	  && r_type != R_IA64_PCREL21M
	  && r_type != R_IA64_PCREL21F)
d814 1
a814 1
	  dyn_i = get_dyn_sym_info (ia64_info, h, abfd, irel, FALSE);
a819 5
	      /* Internal branches shouldn't be sent to the PLT.
		 Leave this for now and we'll give an error later.  */
	      if (r_type != R_IA64_PCREL21B)
		continue;

d931 1
a931 1
				    r_type) != bfd_reloc_ok)
d934 2
a935 2
      changed_contents = TRUE;
      changed_relocs = TRUE;
d979 1
a979 1
  return TRUE;
d990 1
a990 1
  return FALSE;
d993 1
a993 1
/* Return TRUE if NAME is an unwind table section name.  */
d995 1
a995 1
static inline bfd_boolean
d1004 1
a1004 1
    return FALSE;
d1017 1
a1017 1
static bfd_boolean
d1020 1
a1020 1
     Elf_Internal_Shdr *hdr;
d1038 1
a1038 1
	return FALSE;
d1042 1
a1042 1
      return FALSE;
d1046 1
a1046 1
    return FALSE;
d1049 1
a1049 1
  return TRUE;
d1057 1
a1057 1
static bfd_boolean
d1060 1
a1060 1
     Elf_Internal_Shdr *hdr;
d1065 1
a1065 1
  return TRUE;
d1071 1
a1071 1
static bfd_boolean
d1074 1
a1074 1
     Elf_Internal_Shdr *hdr;
d1114 1
a1114 1
  return TRUE;
d1123 1
a1123 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d1208 1
a1208 1
      elf_flags_init (abfd) = TRUE;
d1215 1
a1215 1
static bfd_boolean
d1241 1
a1241 1
	    return FALSE;
d1248 1
a1248 1
  return TRUE;
d1251 1
a1251 1
static bfd_boolean
d1264 1
a1264 1
static bfd_boolean
d1282 1
a1282 1
				FALSE, FALSE, FALSE);
d1295 1
a1295 1
		 bed->got_symbol_offset, (const char *) NULL, FALSE,
d1297 1
a1297 1
	    return FALSE;
d1304 1
a1304 1
	    return FALSE;
d1307 1
a1307 1
      return TRUE;
d1333 1
a1333 1
      return TRUE;
d1342 1
a1342 1
bfd_boolean
d1352 1
a1352 1
	return FALSE;
d1381 1
a1381 1
static bfd_boolean
d1402 1
a1402 1
	    return FALSE;
d1450 1
a1450 1
		return FALSE;
d1494 1
a1494 1
  return TRUE;
d1500 1
a1500 1
static bfd_boolean
d1510 1
a1510 1
static bfd_boolean
d1516 1
a1516 1
    return FALSE;
d1523 1
a1523 1
    return FALSE;
d1528 1
a1528 1
      return FALSE;
d1535 1
a1535 1
    return TRUE;
d1541 1
a1541 1
    return TRUE;
d1543 1
a1543 1
  return FALSE;
d1546 1
a1546 1
static bfd_boolean
d1667 1
a1667 1
     bfd_boolean force_local;
d1712 1
a1712 1
     bfd_boolean create, copy;
d1722 1
a1722 1
  bfd_boolean (*func) PARAMS ((struct elfNN_ia64_dyn_sym_info *, PTR));
d1726 1
a1726 1
static bfd_boolean
d1742 2
a1743 2
      return FALSE;
  return TRUE;
d1746 1
a1746 1
static bfd_boolean
d1759 2
a1760 2
      return FALSE;
  return TRUE;
d1766 1
a1766 1
     bfd_boolean (*func) PARAMS ((struct elfNN_ia64_dyn_sym_info *, PTR));
d1780 1
a1780 1
static bfd_boolean
d1789 1
a1789 1
    return FALSE;
d1802 1
a1802 1
    return FALSE;
d1812 1
a1812 1
    return FALSE;
d1823 1
a1823 1
    return FALSE;
d1826 1
a1826 1
  return TRUE;
d1835 1
a1835 1
     bfd_boolean create;
d1837 2
a1839 5
  asection *sec = abfd->sections;
  char addr_name [34];

  BFD_ASSERT ((sizeof (sec->id)*2 + 1 + sizeof (unsigned long)*2 + 1) <= 34);
  BFD_ASSERT (sec);
d1844 8
a1851 2
  sprintf (addr_name, "%x:%lx",
	   sec->id, (unsigned long) ELFNN_R_SYM (rel->r_info));
d1856 1
d1869 1
a1869 1
     bfd_boolean create;
d2016 1
a2016 1
     bfd_boolean create;
d2061 1
a2061 1
static bfd_boolean
d2079 1
a2079 1
	return FALSE;
d2089 1
a2089 1
  return TRUE;
d2092 1
a2092 1
static bfd_boolean
d2106 1
a2106 1
    return TRUE;
d2133 1
a2133 1
      bfd_boolean maybe_dynamic;
d2153 1
a2153 1
      maybe_dynamic = FALSE;
d2159 1
a2159 1
	maybe_dynamic = TRUE;
d2303 1
a2303 1
      dyn_i = get_dyn_sym_info (ia64_info, h, abfd, rel, TRUE);
d2315 1
a2315 1
		return FALSE;
d2332 1
a2332 1
		return FALSE;
d2344 1
a2344 1
		return FALSE;
d2366 1
a2366 1
	      srel = get_reloc_section (abfd, ia64_info, sec, TRUE);
d2368 1
a2368 1
		return FALSE;
d2371 1
a2371 1
	    return FALSE;
d2375 1
a2375 1
  return TRUE;
d2387 1
a2387 1
static bfd_boolean
d2419 1
a2419 1
  return TRUE;
d2424 1
a2424 1
static bfd_boolean
d2439 1
a2439 1
  return TRUE;
d2444 1
a2444 1
static bfd_boolean
d2458 1
a2458 1
  return TRUE;
d2483 1
a2483 1
static bfd_boolean
d2514 1
a2514 1
		return FALSE;
d2527 1
a2527 1
  return TRUE;
d2532 1
a2532 1
static bfd_boolean
d2565 1
a2565 1
  return TRUE;
d2570 1
a2570 1
static bfd_boolean
d2590 1
a2590 1
  return TRUE;
d2598 1
a2598 1
static bfd_boolean
d2610 1
a2610 1
  return TRUE;
d2616 1
a2616 1
static bfd_boolean
d2624 1
a2624 1
  bfd_boolean dynamic_symbol, shared;
d2702 1
a2702 1
  return TRUE;
d2705 1
a2705 1
static bfd_boolean
d2722 1
a2722 1
      return TRUE;
d2732 1
a2732 1
  return TRUE;
d2735 1
a2735 1
static bfd_boolean
d2744 1
a2744 1
  bfd_boolean relplt = FALSE;
d2783 1
a2783 1
     We do this even though dynamic_sections_created may be FALSE, because
d2833 1
a2833 1
      bfd_boolean strip;
d2849 1
a2849 1
	strip = FALSE;
d2880 1
a2880 1
	      relplt = TRUE;
d2895 1
a2895 1
	    strip = FALSE;
d2916 1
a2916 1
	    return FALSE;
d2934 1
a2934 1
	    return FALSE;
d2938 1
a2938 1
	return FALSE;
d2940 1
a2940 1
	return FALSE;
d2947 1
a2947 1
	    return FALSE;
d2953 1
a2953 1
	return FALSE;
d2958 1
a2958 1
	    return FALSE;
d2965 1
a2965 1
  return TRUE;
a3205 1
  bfd_byte *loc;
d3222 3
a3224 3
  loc = srel->contents;
  loc += srel->reloc_count++ * sizeof (ElfNN_External_Rela);
  bfd_elfNN_swap_reloca_out (abfd, &outrel, loc);
d3244 1
a3244 1
  bfd_boolean done;
d3254 1
a3254 1
      dyn_i->tprel_done = TRUE;
d3259 1
a3259 1
      dyn_i->dtpmod_done = TRUE;
d3264 1
a3264 1
      dyn_i->dtprel_done = TRUE;
d3269 1
a3269 1
      dyn_i->got_done = TRUE;
d3320 1
a3320 1
		  BFD_ASSERT (FALSE);
d3383 1
a3383 1
     bfd_boolean is_plt;
d3481 1
a3481 1
static bfd_boolean
d3529 2
a3530 2
      gp = elf_link_hash_lookup (elf_hash_table (info), "__gp", FALSE,
				 FALSE, FALSE);
d3584 1
a3584 1
	      return FALSE;
d3594 1
a3594 1
	      return FALSE;
d3621 1
a3621 1
	    return FALSE;
d3627 1
a3627 1
    return FALSE;
d3640 1
a3640 1
	return FALSE;
d3643 1
a3643 1
  return TRUE;
d3646 1
a3646 1
static bfd_boolean
d3663 1
a3663 1
  bfd_boolean ret_val = TRUE;	/* for non-fatal errors */
d3679 1
a3679 1
      return TRUE;
d3683 1
a3683 1
  srel = get_reloc_section (input_bfd, ia64_info, input_section, FALSE);
d3699 2
a3700 2
      bfd_boolean dynamic_symbol_p;
      bfd_boolean undef_weak_ref;
d3709 1
a3709 1
	  ret_val = FALSE;
d3718 1
a3718 1
      undef_weak_ref = FALSE;
d3732 2
a3733 2

	      loc_h = get_local_sym_hash (ia64_info, input_bfd, rel, FALSE);
d3792 1
a3792 1
	    undef_weak_ref = TRUE;
d3805 2
a3806 2
		return FALSE;
	      ret_val = FALSE;
d3879 1
a3879 1
		      ret_val = FALSE;
d3912 1
a3912 1
	      ret_val = FALSE;
d3922 1
a3922 1
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
d3933 2
a3934 2
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
	  value = set_pltoff_entry (output_bfd, info, dyn_i, value, FALSE);
d3944 1
a3944 1
          dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
d3990 1
a3990 1
	    dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
d4041 23
d4069 1
a4069 1
	    dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, FALSE);
a4094 3
	case R_IA64_PCREL21BI:
	case R_IA64_PCREL21F:
	case R_IA64_PCREL21M:
a4096 21
	  /* The PCREL21BI reloc is specifically not intended for use with
	     dynamic relocs.  PCREL21F and PCREL21M are used for speculation
	     fixup code, and thus probably ought not be dynamic.  The 
	     PCREL22 and PCREL64I relocs aren't emitted as dynamic relocs.  */
	  if (dynamic_symbol_p)
	    {
	      const char *msg;

	      if (r_type == R_IA64_PCREL21BI)
		msg = _("%s: @@internal branch to dynamic symbol %s");
	      else if (r_type == R_IA64_PCREL21F || r_type == R_IA64_PCREL21M)
		msg = _("%s: speculation fixup to dynamic symbol %s");
	      else
		msg = _("%s: @@pcrel relocation against dynamic symbol %s");
	      (*_bfd_error_handler) (msg, bfd_archive_filename (input_bfd),
				     h->root.root.string);
	      ret_val = FALSE;
	      continue;
	    }
	  goto finish_pcrel;

d4246 1
a4246 1
	    dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, FALSE);
d4272 1
a4272 1
	  return FALSE;
d4286 1
a4286 1
		  return FALSE;
d4293 2
a4294 2
	      return FALSE;
	    ret_val = FALSE;
d4313 1
a4313 1
		  return FALSE;
d4323 2
a4324 2
	      return FALSE;
	    ret_val = FALSE;
d4333 1
a4333 1
static bfd_boolean
d4344 1
a4344 1
  dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, FALSE);
d4353 1
d4371 1
a4371 1
      pltoff_addr = set_pltoff_entry (output_bfd, info, dyn_i, plt_addr, TRUE);
d4410 4
a4413 4
      loc = ia64_info->rel_pltoff_sec->contents;
      loc += ((ia64_info->rel_pltoff_sec->reloc_count + index)
	      * sizeof (Elf64_External_Rela));
      bfd_elfNN_swap_reloca_out (output_bfd, &outrel, loc);
d4422 1
a4422 1
  return TRUE;
d4425 1
a4425 1
static bfd_boolean
d4507 1
a4507 1
  return TRUE;
d4513 1
a4513 1
static bfd_boolean
d4522 2
a4523 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d4528 1
a4528 1
static bfd_boolean
d4534 1
a4534 1
  bfd_boolean ok = TRUE;
d4539 1
a4539 1
    return FALSE;
d4546 1
a4546 1
      elf_flags_init (obfd) = TRUE;
d4556 1
a4556 1
      return TRUE;
d4561 1
a4561 1
    return TRUE;
d4574 1
a4574 1
      ok = FALSE;
d4583 1
a4583 1
      ok = FALSE;
d4592 1
a4592 1
      ok = FALSE;
d4601 1
a4601 1
      ok = FALSE;
d4611 1
a4611 1
      ok = FALSE;
d4617 1
a4617 1
static bfd_boolean
d4638 1
a4638 1
  return TRUE;
d4662 1
a4662 1
static bfd_boolean
d4680 1
a4680 1
bfd_boolean
d4689 1
a4689 1
      return TRUE;
d4691 1
a4691 1
  return FALSE;
@


1.58.2.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a150 2
  unsigned self_dtpmod_done : 1;/* has self DTPMOD entry been finished? */
  bfd_vma self_dtpmod_offset;	/* .got offset to self DTPMOD entry */
d2419 2
a2420 17
      if (elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info))
	{
	  dyn_i->dtpmod_offset = x->ofs;
	  x->ofs += 8;
	}
      else
	{
	  struct elfNN_ia64_link_hash_table *ia64_info;

	  ia64_info = elfNN_ia64_hash_table (x->info);
	  if (ia64_info->self_dtpmod_offset == (bfd_vma) -1)
	    {
	      ia64_info->self_dtpmod_offset = x->ofs;
	      x->ofs += 8;
	    }
	  dyn_i->dtpmod_offset = ia64_info->self_dtpmod_offset;
	}
d2690 1
a2690 1
  if (dynamic_symbol && dyn_i->want_dtpmod)
a2755 1
  ia64_info->self_dtpmod_offset = (bfd_vma) -1;
a2833 2
      if (info->shared && ia64_info->self_dtpmod_offset != (bfd_vma) -1)
	ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
d3267 2
a3268 11
      if (dyn_i->dtpmod_offset != ia64_info->self_dtpmod_offset)
	{
	  done = dyn_i->dtpmod_done;
	  dyn_i->dtpmod_done = TRUE;
	}
      else
	{
	  done = ia64_info->self_dtpmod_done;
	  ia64_info->self_dtpmod_done = TRUE;
	  dynindx = 0;
	}
d3737 2
a3738 1
	      && sym_sec->sec_info_type == ELF_INFO_TYPE_MERGE)
a4226 2
	case R_IA64_DTPREL64LSB:
	case R_IA64_DTPREL64MSB:
a4235 2
	    long dynindx = h ? h->dynindx : -1;
	    bfd_vma r_addend = rel->r_addend;
d4241 2
a4242 10
		if (!dynamic_symbol_p)
		  {
		    if (!info->shared)
		      value -= elfNN_ia64_tprel_base (info);
		    else
		      {
			r_addend += value - elfNN_ia64_dtprel_base (info);
			dynindx = 0;
		      }
		  }
d4257 2
a4258 1
	    value = set_got_entry (input_bfd, info, dyn_i, dynindx, r_addend,
@


1.58.2.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@a104 1
  unsigned want_gotx : 1;
a156 6
struct elfNN_ia64_allocate_data
{
  struct bfd_link_info *info;
  bfd_size_type ofs;
};

a171 2
static void elfNN_ia64_relax_ldxmov
  PARAMS((bfd *abfd, bfd_byte *contents, bfd_vma off));
a301 2
static bfd_boolean elfNN_ia64_choose_gp
  PARAMS ((bfd *abfd, struct bfd_link_info *info));
d648 5
d659 14
d674 5
a678 1
/* These functions do relaxation for IA-64 ELF.  */
a703 2
  bfd_boolean changed_got = FALSE;
  bfd_vma gp = 0;
d731 18
d763 1
a763 1
  for (irel = internal_relocs; irel < irelend; irel++)
a769 2
      bfd_boolean is_branch;
      struct elfNN_ia64_dyn_sym_info *dyn_i;
d771 5
a775 17
      switch (r_type)
	{
	case R_IA64_PCREL21B:
	case R_IA64_PCREL21BI:
	case R_IA64_PCREL21M:
	case R_IA64_PCREL21F:
	  is_branch = TRUE;
	  break;

	case R_IA64_LTOFF22X:
	case R_IA64_LDXMOV:
	  is_branch = FALSE;
	  break;

	default:
	  continue;
	}
a807 1
	  dyn_i = get_dyn_sym_info (ia64_info, NULL, abfd, irel, FALSE);
d813 1
d827 1
a827 1
	  if (is_branch && dyn_i && dyn_i->want_plt2)
a836 5

	  /* Can't do anything else with dynamic symbols.  */
	  else if (elfNN_ia64_dynamic_symbol_p (h, link_info))
	    continue;

d855 8
d864 5
a868 10
      if (is_branch)
	{
	  reladdr = (sec->output_section->vma
		     + sec->output_offset
		     + roff) & (bfd_vma) -4;

	  /* If the branch is in range, no need to do anything.  */
	  if ((bfd_signed_vma) (symaddr - reladdr) >= -0x1000000
	      && (bfd_signed_vma) (symaddr - reladdr) <= 0x0FFFFF0)
	    continue;
d870 4
a873 5
	  /* If the branch and target are in the same section, you've
	     got one honking big section and we can't help you.  You'll
	     get an error message later.  */
	  if (tsec == sec)
	    continue;
d875 5
a879 19
	  /* Look for an existing fixup to this address.  */
	  for (f = fixups; f ; f = f->next)
	    if (f->tsec == tsec && f->toff == toff)
	      break;

	  if (f == NULL)
	    {
	      /* Two alternatives: If it's a branch to a PLT entry, we can
		 make a copy of the FULL_PLT entry.  Otherwise, we'll have
		 to use a `brl' insn to get where we're going.  */

	      size_t size;

	      if (tsec == ia64_info->plt_sec)
		size = sizeof (plt_full_entry);
	      else
		{
		  size = sizeof (oor_brl);
		}
d881 1
a881 24
	      /* Resize the current section to make room for the new branch. */
	      trampoff = (sec->_cooked_size + 15) & (bfd_vma) -16;
	      amt = trampoff + size;
	      contents = (bfd_byte *) bfd_realloc (contents, amt);
	      if (contents == NULL)
		goto error_return;
	      sec->_cooked_size = amt;

	      if (tsec == ia64_info->plt_sec)
		{
		  memcpy (contents + trampoff, plt_full_entry, size);

		  /* Hijack the old relocation for use as the PLTOFF reloc.  */
		  irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
					       R_IA64_PLTOFF22);
		  irel->r_offset = trampoff;
		}
	      else
		{
		  memcpy (contents + trampoff, oor_brl, size);
		  irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
					       R_IA64_PCREL60B);
		  irel->r_offset = trampoff + 2;
		}
d883 2
a884 9
	      /* Record the fixup so we don't do it again this section.  */
	      f = (struct one_fixup *)
		bfd_malloc ((bfd_size_type) sizeof (*f));
	      f->next = fixups;
	      f->tsec = tsec;
	      f->toff = toff;
	      f->trampoff = trampoff;
	      fixups = f;
	    }
d887 5
a891 2
	      /* Nop out the reloc, since we're finalizing things here.  */
	      irel->r_info = ELFNN_R_INFO (0, R_IA64_NONE);
d894 5
a898 5
	  /* Fix up the existing branch to hit the trampoline.  Hope like
	     hell this doesn't overflow too.  */
	  if (elfNN_ia64_install_value (abfd, contents + roff,
					f->trampoff - (roff & (bfd_vma) -4),
					r_type) != bfd_reloc_ok)
d900 1
d902 1
a902 7
	  changed_contents = TRUE;
	  changed_relocs = TRUE;
	}
      else
	{
	  /* Fetch the gp.  */
	  if (gp == 0)
d904 1
a904 14
	      bfd *obfd = sec->output_section->owner;
	      gp = _bfd_get_gp_value (obfd);
	      if (gp == 0)
		{
		  if (!elfNN_ia64_choose_gp (obfd, link_info))
		    goto error_return;
		  gp = _bfd_get_gp_value (obfd);
		}
	    }

	  /* If the data is out of range, do nothing.  */
	  if ((bfd_signed_vma) (symaddr - gp) >= 0x200000
	      ||(bfd_signed_vma) (symaddr - gp) < -0x200000)
	    continue;
d906 1
a906 2
	  if (r_type == R_IA64_LTOFF22X)
	    {
d908 2
a909 7
					   R_IA64_GPREL22);
	      changed_relocs = TRUE;
	      if (dyn_i->want_gotx)
		{
		  dyn_i->want_gotx = 0;
		  changed_got |= !dyn_i->want_got;
		}
d913 12
a924 4
	      elfNN_ia64_relax_ldxmov (abfd, contents, roff);
	      irel->r_info = ELFNN_R_INFO (0, R_IA64_NONE);
	      changed_contents = TRUE;
	      changed_relocs = TRUE;
d926 13
d940 10
a951 5
  /* ??? If we created fixups, this may push the code segment large
     enough that the data segment moves, which will change the GP.
     Reset the GP so that we re-calculate next round.  We need to
     do this at the _beginning_ of the next round; now will not do.  */
      
a991 15
  if (changed_got)
    {
      struct elfNN_ia64_allocate_data data;
      data.info = link_info;
      data.ofs = 0;

      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_global_data_got, &data);
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_global_fptr_got, &data);
      elfNN_ia64_dyn_sym_traverse (ia64_info, allocate_local_got, &data);
      ia64_info->got_sec->_raw_size = data.ofs;
      ia64_info->got_sec->_cooked_size = data.ofs;

      /* ??? Resize .rela.got too.  */
    }

a1005 33

static void
elfNN_ia64_relax_ldxmov (abfd, contents, off)
     bfd *abfd;
     bfd_byte *contents;
     bfd_vma off;
{
  int shift, r1, r3;
  bfd_vma dword, insn;

  switch ((int)off & 0x3)
    {
    case 0: shift =  5; break;
    case 1: shift = 14; off += 3; break;
    case 2: shift = 23; off += 6; break;
    case 3:
      abort ();
    }

  dword = bfd_get_64 (abfd, contents + off);
  insn = (dword >> shift) & 0x1ffffffffffLL;

  r1 = (insn >> 6) & 127;
  r3 = (insn >> 20) & 127;
  if (r1 == r3)
    insn = 0x8000000;				   /* nop */
  else
    insn = (insn & 0x7f01fff) | 0x10800000000LL;   /* (qp) mov r1 = r3 */

  dword &= ~(0x1ffffffffffLL << shift);
  dword |= (insn << shift);
  bfd_put_64 (abfd, dword, contents + off);
}
d2128 9
a2136 10
	NEED_GOTX = 2,
	NEED_FPTR = 4,
	NEED_PLTOFF = 8,
	NEED_MIN_PLT = 16,
	NEED_FULL_PLT = 32,
	NEED_DYNREL = 64,
	NEED_LTOFF_FPTR = 128,
	NEED_TPREL = 256,
	NEED_DTPMOD = 512,
	NEED_DTPREL = 1024
d2233 1
a2237 4
	case R_IA64_LTOFF22X:
	  need_entry = NEED_GOTX;
	  break;

d2319 1
a2319 2
      if (need_entry & (NEED_GOT | NEED_GOTX | NEED_TPREL
			| NEED_DTPMOD | NEED_DTPREL))
a2328 2
	  if (need_entry & NEED_GOTX)
	    dyn_i->want_gotx = 1;
d2388 6
d2404 1
a2404 1
  if ((dyn_i->want_got || dyn_i->want_gotx)
d2476 1
a2476 1
  if ((dyn_i->want_got || dyn_i->want_gotx)
d2702 1
a2702 1
  if (((dynamic_symbol || shared) && (dyn_i->want_got || dyn_i->want_gotx))
a3518 1
/* Make sure we've got ourselves a nice fat __gp value.  */
d3520 1
a3520 1
elfNN_ia64_choose_gp (abfd, info)
a3523 5
  bfd_vma min_vma = (bfd_vma) -1, max_vma = 0;
  bfd_vma min_short_vma = min_vma, max_short_vma = 0;
  struct elf_link_hash_entry *gp;
  bfd_vma gp_val;
  asection *os;
d3525 1
d3529 2
a3530 3
  /* Find the min and max vma of all sections marked short.  Also collect
     min and max vma of any type, for use in selecting a nice gp.  */
  for (os = abfd->sections; os ; os = os->next)
d3532 5
a3536 1
      bfd_vma lo, hi;
d3538 9
a3546 2
      if ((os->flags & SEC_ALLOC) == 0)
	continue;
d3548 16
a3563 15
      lo = os->vma;
      hi = os->vma + os->_raw_size;
      if (hi < lo)
	hi = (bfd_vma) -1;

      if (min_vma > lo)
	min_vma = lo;
      if (max_vma < hi)
	max_vma = hi;
      if (os->flags & SEC_SMALL_DATA)
	{
	  if (min_short_vma > lo)
	    min_short_vma = lo;
	  if (max_short_vma < hi)
	    max_short_vma = hi;
a3564 1
    }
d3566 3
a3568 16
  /* See if the user wants to force a value.  */
  gp = elf_link_hash_lookup (elf_hash_table (info), "__gp", FALSE,
			     FALSE, FALSE);

  if (gp
      && (gp->root.type == bfd_link_hash_defined
	  || gp->root.type == bfd_link_hash_defweak))
    {
      asection *gp_sec = gp->root.u.def.section;
      gp_val = (gp->root.u.def.value
		+ gp_sec->output_section->vma
		+ gp_sec->output_offset);
    }
  else
    {
      /* Pick a sensible value.  */
d3570 9
a3578 7
      asection *got_sec = ia64_info->got_sec;

      /* Start with just the address of the .got.  */
      if (got_sec)
	gp_val = got_sec->output_section->vma;
      else if (max_short_vma != 0)
	gp_val = min_short_vma;
a3579 9
	gp_val = min_vma;

      /* If it is possible to address the entire image, but we
	 don't with the choice above, adjust.  */
      if (max_vma - min_vma < 0x400000
	  && max_vma - gp_val <= 0x200000
	  && gp_val - min_vma > 0x200000)
	gp_val = min_vma + 0x200000;
      else if (max_short_vma != 0)
d3581 1
a3581 3
	  /* If we don't cover all the short data, adjust.  */
	  if (max_short_vma - gp_val >= 0x200000)
	    gp_val = min_short_vma + 0x200000;
d3583 1
a3583 5
	  /* If we're addressing stuff past the end, adjust back.  */
	  if (gp_val > max_vma)
	    gp_val = max_vma - 0x200000 + 8;
	}
    }
d3585 7
a3591 2
  /* Validate whether all SHF_IA_64_SHORT sections are within
     range of the chosen GP.  */
d3593 16
a3608 19
  if (max_short_vma != 0)
    {
      if (max_short_vma - min_short_vma >= 0x400000)
	{
	  (*_bfd_error_handler)
	    (_("%s: short data segment overflowed (0x%lx >= 0x400000)"),
	     bfd_get_filename (abfd),
	     (unsigned long) (max_short_vma - min_short_vma));
	  return FALSE;
	}
      else if ((gp_val > min_short_vma
		&& gp_val - min_short_vma > 0x200000)
	       || (gp_val < max_short_vma
		   && max_short_vma - gp_val >= 0x200000))
	{
	  (*_bfd_error_handler)
	    (_("%s: __gp does not cover short data segment"),
	     bfd_get_filename (abfd));
	  return FALSE;
a3609 16
    }

  _bfd_set_gp_value (abfd, gp_val);

  return TRUE;
}

static bfd_boolean
elfNN_ia64_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  struct elfNN_ia64_link_hash_table *ia64_info;
  asection *unwind_output_sec;

  ia64_info = elfNN_ia64_hash_table (info);
d3611 2
a3612 5
  /* Make sure we've got ourselves a nice fat __gp value.  */
  if (!info->relocateable)
    {
      bfd_vma gp_val = _bfd_get_gp_value (abfd);
      struct elf_link_hash_entry *gp;
d3614 1
a3614 1
      if (gp_val == 0)
d3616 18
a3633 3
	  if (! elfNN_ia64_choose_gp (abfd, info))
	    return FALSE;
	  gp_val = _bfd_get_gp_value (abfd);
d3636 2
a3637 2
      gp = elf_link_hash_lookup (elf_hash_table (info), "__gp", FALSE,
			         FALSE, FALSE);
d3831 1
d3929 1
a3929 1
	  /* Fall through.  */
d4539 1
a4539 1
      /* Initialize the PLT0 entry.  */
d4558 1
a4558 1
/* ELF file flag handling:  */
@


1.58.2.6
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a359 4

  if (input_section->flags & SEC_DEBUGGING)
    return bfd_reloc_continue;

a698 4
  /* Don't even try to relax for non-ELF outputs.  */
  if (link_info->hash->creator->flavour != bfd_target_elf_flavour)
    return FALSE;

a821 1
	      BFD_ASSERT (irel->r_addend == 0);
d840 4
a843 9
      if (tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	toff = _bfd_merged_section_offset (abfd, &tsec,
					   elf_section_data (tsec)->sec_info,
					   toff + irel->r_addend,
					   (bfd_vma) 0);
      else
	toff += irel->r_addend;

      symaddr = tsec->output_section->vma + tsec->output_offset + toff;
a1024 1
      ia64_info->self_dtpmod_offset = (bfd_vma) -1;
d1780 1
a1780 1
  ret = bfd_zmalloc ((bfd_size_type) sizeof (*ret));
a1782 1

d1786 1
a1786 1
      free (ret);
d1792 1
a1792 5
    {
      free (ret);
      return 0;
    }

d1968 1
a1968 5
      if (!loc_h)
	{
	  BFD_ASSERT (!create);
	  return NULL;
	}
d3942 1
@


1.58.2.7
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d707 1
a707 2
  /* Nothing to do if there are no relocations or there is no need for
     the relax finalize pass.  */
d709 1
a709 3
      || sec->reloc_count == 0
      || (link_info->relax_finalizing
	  && sec->need_finalize_relax == 0))
a758 2
	  if (link_info->relax_finalizing)
	    continue;
a763 5
	  if (!link_info->relax_finalizing)
	    {
	      sec->need_finalize_relax = 1;
	      continue;
	    }
a1048 3

  if (link_info->relax_finalizing)
    sec->need_finalize_relax = 0;
@


1.58.2.8
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d723 1
a723 1
  internal_relocs = (_bfd_elf_link_read_relocs
d799 1
a799 1
	  isym = isymbuf + ELFNN_R_SYM (irel->r_info);
d1092 1
a1092 1
    default:
d1469 1
a1469 1
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
d1795 1
a1795 4
    {
      dyn_i->want_plt2 = 0;
      dyn_i->want_plt = 0;
    }
d2638 1
a2638 4
      if ((x->info->shared
	   && (!h
	       || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
d2763 1
a2763 1
  bfd_boolean dynamic_symbol, shared, resolved_zero;
d2770 1
a2770 1
				 "__GLOB_DATA_PTR") != 0));
a2771 3
  resolved_zero = (dyn_i->h
		   && ELF_ST_VISIBILITY (dyn_i->h->other)
		   && dyn_i->h->root.type == bfd_link_hash_undefweak);
d2816 2
a2817 6
  if ((!resolved_zero
       && (dynamic_symbol || shared)
       && (dyn_i->want_got || dyn_i->want_gotx))
      || (dyn_i->want_ltoff_fptr
	  && dyn_i->h
	  && dyn_i->h->dynindx != -1))
d2826 1
a2826 1
  if (!resolved_zero && dyn_i->want_pltoff)
d3434 1
a3434 5
      if ((info->shared
	   && (!dyn_i->h
	       || ELF_ST_VISIBILITY (dyn_i->h->other) == STV_DEFAULT
	       || dyn_i->h->root.type != bfd_link_hash_undefweak)
	   && dyn_r_type != R_IA64_DTPREL64LSB)
d3555 1
a3555 5
      if (!is_plt
	  && info->shared
	  && (!dyn_i->h
	      || ELF_ST_VISIBILITY (dyn_i->h->other) == STV_DEFAULT
	      || dyn_i->h->root.type != bfd_link_hash_undefweak))
a3874 1
      bfd_boolean local_symbol_p;
a3985 5
      /* Is this symbol locally defined? A protected symbol is locallly
	 defined. But its function descriptor may not. Use it with
	 caution.  */
      local_symbol_p = (! dynamic_symbol_p
			|| ELF_ST_VISIBILITY (h->other) != STV_DEFAULT);
d4018 1
a4018 1
	      if (! local_symbol_p)
d4347 1
a4347 1
	      if (local_symbol_p)
@


1.58.2.9
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1344 1
a1344 1
      && !info->relocatable
d2231 1
a2231 1
  if (info->relocatable)
d2906 1
a2906 1
      && info->executable)
d3081 1
a3081 1
      if (info->executable)
d3782 1
a3782 1
  if (!info->relocatable)
d3808 1
a3808 1
  if (!info->relocatable)
d3866 1
a3866 1
  if (info->relocatable)
d4328 1
a4328 1
		    if (m->sections[i] == input_section->output_section)
@


1.58.2.10
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a145 1
  asection *rel_fptr_sec;	/* dynamic relocation section for same */
d195 8
d210 1
a210 1
  PARAMS ((struct elf_link_hash_entry *h, struct bfd_link_info *info, int));
d370 1
a370 1
	 elfNN_ia64_reloc, NAME, FALSE, 0, -1, IN)
d659 3
d844 1
a844 1
	  else if (elfNN_ia64_dynamic_symbol_p (h, link_info, r_type))
d1369 108
d1629 1
a1629 1
elfNN_ia64_dynamic_symbol_p (h, info, r_type)
a1631 1
     int r_type;
d1633 17
a1649 3
  bfd_boolean ignore_protected
    = ((r_type & 0xf8) == 0x40		/* FPTR relocs */
       || (r_type & 0xf8) == 0x50);	/* LTOFF_FPTR relocs */
d1651 11
a1661 1
  return _bfd_elf_dynamic_symbol_p (h, info, ignore_protected);
a2050 4
      /* The .got section is always aligned at 8 bytes.  */
      if (!bfd_set_section_alignment (abfd, got, 3))
	return 0;

d2066 1
a2066 1
     struct bfd_link_info *info;
d2086 1
a2086 1
				      | (info->pie ? 0 : SEC_READONLY)
a2094 20

      if (info->pie)
	{
	  asection *fptr_rel;
	  fptr_rel = bfd_make_section(abfd, ".rela.opd");
	  if (fptr_rel == NULL
	      || !bfd_set_section_flags (abfd, fptr_rel,
					 (SEC_ALLOC | SEC_LOAD
					  | SEC_HAS_CONTENTS
					  | SEC_IN_MEMORY
					  | SEC_LINKER_CREATED
					  | SEC_READONLY))
	      || !bfd_set_section_alignment (abfd, fptr_rel, 3))
	    {
	      BFD_ASSERT (0);
	      return NULL;
	    }

	  ia64_info->rel_fptr_sec = fptr_rel;
	}
d2281 1
a2281 1
      if (h && ((!info->executable
d2284 2
a2285 1
		|| h->root.type == bfd_link_hash_defweak))
d2342 1
a2342 1
	  if (info->shared || h)
d2394 4
a2397 1
	  if (info->shared || maybe_dynamic)
d2471 3
a2473 1
	  if (!h && info->shared)
d2523 4
a2526 1
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0))
d2538 1
a2538 1
      if (elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0))
d2575 2
a2576 1
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, R_IA64_FPTR64LSB))
d2594 2
a2595 1
      && !elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0))
d2641 9
a2649 4
      if (!x->info->executable
	  && (!h
	      || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	      || h->root.type != bfd_link_hash_undefweak))
d2694 1
a2694 1
      if (elfNN_ia64_dynamic_symbol_p (h, x->info, 0))
d2772 5
a2776 4

  /* Note that this can't be used in relation to FPTR relocs below.  */
  dynamic_symbol = elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info, 0);

d2791 4
a2794 5
	  /* Allocate one iff !want_fptr and not PIE, which by this point
	     will be true only if we're actually allocating one statically
	     in the main executable.  Position independent executables
	     need a relative reloc.  */
	  if (dyn_i->want_fptr && !x->info->pie)
d2831 1
a2831 7
    {
      if (!dyn_i->want_ltoff_fptr
	  || !x->info->pie
	  || dyn_i->h == NULL
	  || dyn_i->h->root.type != bfd_link_hash_undefweak)
	ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
    }
a2837 5
  if (ia64_info->rel_fptr_sec && dyn_i->want_fptr)
    {
      if (dyn_i->h == NULL || dyn_i->h->root.type != bfd_link_hash_undefweak)
	ia64_info->rel_fptr_sec->_raw_size += sizeof (ElfNN_External_Rela);
    }
d2889 1
a2889 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d2910 2
a2911 2
      sec->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
      sec->_raw_size = strlen (ELF_DYNAMIC_INTERPRETER) + 1;
d3447 8
a3454 11
      if (((info->shared
	    && (!dyn_i->h
		|| ELF_ST_VISIBILITY (dyn_i->h->other) == STV_DEFAULT
		|| dyn_i->h->root.type != bfd_link_hash_undefweak)
	    && dyn_r_type != R_IA64_DTPREL64LSB)
           || elfNN_ia64_dynamic_symbol_p (dyn_i->h, info, dyn_r_type)
	   || (dynindx != -1 && dyn_r_type == R_IA64_FPTR64LSB))
	  && (!dyn_i->want_ltoff_fptr
	      || !info->pie
	      || !dyn_i->h
	      || dyn_i->h->root.type != bfd_link_hash_undefweak))
a3532 18
      if (ia64_info->rel_fptr_sec)
	{
	  Elf_Internal_Rela outrel;
	  bfd_byte *loc;

	  if (bfd_little_endian (abfd))
	    outrel.r_info = ELFNN_R_INFO (0, R_IA64_IPLTLSB);
	  else
	    outrel.r_info = ELFNN_R_INFO (0, R_IA64_IPLTMSB);
	  outrel.r_addend = value;
	  outrel.r_offset = (fptr_sec->output_section->vma
			     + fptr_sec->output_offset
			     + dyn_i->fptr_offset);
	  loc = ia64_info->rel_fptr_sec->contents;
	  loc += ia64_info->rel_fptr_sec->reloc_count++
		 * sizeof (ElfNN_External_Rela);
	  bfd_elfNN_swap_reloca_out (abfd, &outrel, loc);
	}
d3896 1
d3989 1
a3989 1
	  else if (! info->executable
d4007 6
a4012 1
      dynamic_symbol_p = elfNN_ia64_dynamic_symbol_p (h, info, r_type);
d4028 5
a4032 1
	  if ((dynamic_symbol_p || info->shared)
d4045 1
a4045 1
	      if (dynamic_symbol_p)
d4085 2
d4149 1
a4149 1
	  if (!dyn_i->want_fptr || info->pie)
a4151 2
	      unsigned int dyn_r_type = r_type;
	      bfd_vma addend = rel->r_addend;
d4156 1
a4156 21
	      if (dyn_i->want_fptr)
		{
		  if (r_type == R_IA64_FPTR64I)
		    {
		      /* We can't represent this without a dynamic symbol.
			 Adjust the relocation to be against an output
			 section symbol, which are always present in the
			 dynamic symbol table.  */
		      /* ??? People shouldn't be doing non-pic code in
			 shared libraries.  Hork.  */
		      (*_bfd_error_handler)
			(_("%s: linking non-pic code in a position independent executable"),
			 bfd_archive_filename (input_bfd));
		      ret_val = FALSE;
		      continue;
		    }
		  dynindx = 0;
		  addend = value;
		  dyn_r_type = r_type + R_IA64_REL64LSB - R_IA64_FPTR64LSB;
		}
	      else if (h)
a4163 1
		  value = 0;
a4168 1
		  value = 0;
d4172 3
a4174 2
					    srel, rel->r_offset, dyn_r_type,
					    dynindx, addend);
d4228 3
a4230 1
	  if (dynamic_symbol_p && r_symndx != 0)
d4374 1
a4374 1
	      if (!dynamic_symbol_p)
d4622 1
a4622 1
	      * sizeof (ElfNN_External_Rela));
a4871 10
static struct bfd_elf_special_section const elfNN_ia64_special_sections[]=
{
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { NULL,		0,	NULL,	0,
    0,			0 }
};

d4979 21
a4999 1
#define elf_backend_special_sections	elfNN_ia64_special_sections
d5011 8
@


1.58.2.11
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d214 1
a214 1
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
d1592 1
a1592 1
     const struct elf_backend_data *bed ATTRIBUTE_UNUSED;
a1783 2
    /* The .got section is always aligned at 8 bytes.  */
    bfd_set_section_alignment (abfd, ia64_info->got_sec, 3);
d2165 1
a2165 1
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
d3855 1
a3855 2
	  bfd_boolean unresolved_reloc;
	  bfd_boolean warned;
d3857 20
a3876 5
	  RELOC_FOR_GLOBAL_SYMBOL (h, elf_sym_hashes (input_bfd),
				   r_symndx,
				   symtab_hdr, value, sym_sec,
				   unresolved_reloc, info,
				   warned);
d3878 8
a3885 1
	  if (h->root.type == bfd_link_hash_undefweak)
d3887 14
a3900 2
	  else if (warned)
	    continue;
d4782 1
a4782 1
  { ".sbss",		5,	NULL,	0,
d4784 1
a4784 1
  { ".sdata",		6,	NULL,	0,
@


1.58.2.12
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a26 2
#include "objalloc.h"
#include "hashtab.h"
d118 1
a118 2
  int id;
  unsigned int r_sym;
d126 6
d156 1
a156 2
  htab_t loc_hash_table;
  void *loc_hash_memory;
d204 6
a217 3
static hashval_t elfNN_ia64_local_htab_hash PARAMS ((const void *));
static int elfNN_ia64_local_htab_eq PARAMS ((const void *ptr1,
					     const void *ptr2));
d220 3
a222 2
static void elfNN_ia64_hash_table_free
  PARAMS ((struct bfd_link_hash_table *hash));
d225 2
a226 2
static int elfNN_ia64_local_dyn_sym_thunk
  PARAMS ((void **, PTR));
d449 2
a450 2
    IA64_HOWTO (R_IA64_TPREL64MSB,  "TPREL64MSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_TPREL64LSB,  "TPREL64LSB",  4, FALSE, FALSE),
d453 2
a454 2
    IA64_HOWTO (R_IA64_DTPMOD64MSB, "TPREL64MSB",  4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPMOD64LSB, "TPREL64LSB",  4, FALSE, FALSE),
d460 4
a463 4
    IA64_HOWTO (R_IA64_DTPREL32MSB, "DTPREL32MSB", 2, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL32LSB, "DTPREL32LSB", 2, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64MSB, "DTPREL64MSB", 4, FALSE, FALSE),
    IA64_HOWTO (R_IA64_DTPREL64LSB, "DTPREL64LSB", 4, FALSE, FALSE),
a658 22

static const bfd_byte oor_ip[48] =
{
  0x04, 0x00, 0x00, 0x00, 0x01, 0x00,  /*  [MLX]        nop.m 0            */
  0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,  /*               movl r15=0         */
  0x01, 0x00, 0x00, 0x60,
  0x03, 0x00, 0x00, 0x00, 0x01, 0x00,  /*  [MII]        nop.m 0            */
  0x00, 0x01, 0x00, 0x60, 0x00, 0x00,  /*               mov r16=ip;;       */
  0xf2, 0x80, 0x00, 0x80,              /*               add r16=r15,r16;;  */
  0x11, 0x00, 0x00, 0x00, 0x01, 0x00,  /*  [MIB]        nop.m 0            */
  0x60, 0x80, 0x04, 0x80, 0x03, 0x00,  /*               mov b6=r16         */
  0x60, 0x00, 0x80, 0x00               /*               br b6;;            */
};

static size_t oor_branch_size = sizeof (oor_brl);

void
bfd_elfNN_ia64_after_parse (int itanium)
{
  oor_branch_size = itanium ? sizeof (oor_ip) : sizeof (oor_brl);
}

d894 3
a896 1
		size = oor_branch_size;
d917 4
a920 16
		  if (size == sizeof (oor_ip))
		    {
		      memcpy (contents + trampoff, oor_ip, size);
		      irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
						   R_IA64_PCREL64I);
		      irel->r_addend -= 16;
		      irel->r_offset = trampoff + 2;
		    }
		  else
		    {
		      memcpy (contents + trampoff, oor_brl, size);
		      irel->r_info = ELFNN_R_INFO (ELFNN_R_SYM (irel->r_info),
						   R_IA64_PCREL60B);
		      irel->r_offset = trampoff + 2;
		    }

d1523 38
a1659 27
/* Compute a hash of a local hash entry.  */

static hashval_t
elfNN_ia64_local_htab_hash (ptr)
     const void *ptr;
{
  struct elfNN_ia64_local_hash_entry *entry
    = (struct elfNN_ia64_local_hash_entry *) ptr;

  return (((entry->id & 0xff) << 24) | ((entry->id & 0xff00) << 8))
	  ^ entry->r_sym ^ (entry->id >> 16);
}

/* Compare local hash entries.  */

static int
elfNN_ia64_local_htab_eq (ptr1, ptr2)
     const void *ptr1, *ptr2;
{
  struct elfNN_ia64_local_hash_entry *entry1
    = (struct elfNN_ia64_local_hash_entry *) ptr1;
  struct elfNN_ia64_local_hash_entry *entry2
    = (struct elfNN_ia64_local_hash_entry *) ptr2;

  return entry1->id == entry2->id && entry1->r_sym == entry2->r_sym;
}

d1681 2
a1682 4
  ret->loc_hash_table = htab_try_create (1024, elfNN_ia64_local_htab_hash,
					 elfNN_ia64_local_htab_eq, NULL);
  ret->loc_hash_memory = objalloc_create ();
  if (!ret->loc_hash_table || !ret->loc_hash_memory)
d1691 1
a1691 1
/* Destroy IA-64 linker hash table.  */
d1693 5
a1697 3
static void
elfNN_ia64_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
d1699 2
a1700 7
  struct elfNN_ia64_link_hash_table *ia64_info
    = (struct elfNN_ia64_link_hash_table *) hash;
  if (ia64_info->loc_hash_table)
    htab_delete (ia64_info->loc_hash_table);
  if (ia64_info->loc_hash_memory)
    objalloc_free ((struct objalloc *) ia64_info->loc_hash_memory);
  _bfd_generic_link_hash_table_free (hash);
d1732 2
a1733 2
elfNN_ia64_local_dyn_sym_thunk (slot, xdata)
     void **slot;
d1737 1
a1737 1
    = (struct elfNN_ia64_local_hash_entry *) *slot;
d1744 2
a1745 2
      return 0;
  return 1;
d1761 2
a1762 2
  htab_traverse (ia64_info->loc_hash_table,
		 elfNN_ia64_local_dyn_sym_thunk, &xdata);
d1824 1
a1824 1
  struct elfNN_ia64_local_hash_entry e, *ret;
d1826 4
a1829 8
  hashval_t h = (((sec->id & 0xff) << 24) | ((sec->id & 0xff00) << 8))
		^ ELFNN_R_SYM (rel->r_info) ^ (sec->id >> 16);
  void **slot;

  e.id = sec->id;
  e.r_sym = ELFNN_R_SYM (rel->r_info);
  slot = htab_find_slot_with_hash (ia64_info->loc_hash_table, &e, h,
				   create ? INSERT : NO_INSERT);
d1831 2
a1832 2
  if (!slot)
    return NULL;
d1834 2
a1835 2
  if (*slot)
    return (struct elfNN_ia64_local_hash_entry *) *slot;
d1837 3
a1839 10
  ret = (struct elfNN_ia64_local_hash_entry *)
	objalloc_alloc ((struct objalloc *) ia64_info->loc_hash_memory,
			sizeof (struct elfNN_ia64_local_hash_entry));
  if (ret)
    {
      memset (ret, 0, sizeof (*ret));
      ret->id = sec->id;
      ret->r_sym = ELFNN_R_SYM (rel->r_info);
      *slot = ret;
    }
d3516 2
a3517 1
  asection *tls_sec = elf_hash_table (info)->tls_sec;
d3519 3
a3521 2
  BFD_ASSERT (tls_sec != NULL);
  return tls_sec->vma - align_power ((bfd_vma) 16, tls_sec->alignment_power);
d3532 2
a3533 2
  BFD_ASSERT (elf_hash_table (info)->tls_sec != NULL);
  return elf_hash_table (info)->tls_sec->vma;
a3819 1
	  asection *msec;
d3822 1
a3822 2
	  msec = sym_sec;
	  value = _bfd_elf_rela_local_sym (output_bfd, sym, &msec, rel);
d3833 1
d4751 6
a4756 3
  { ".sbss",  5, -1, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { ".sdata", 6, -1, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_IA_64_SHORT },
  { NULL,     0,  0, 0,            0 }
a4789 17

static void
elfNN_hpux_backend_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED,
				      asymbol *asym)
{
  elf_symbol_type *elfsym = (elf_symbol_type *) asym;;

  switch (elfsym->internal_elf_sym.st_shndx)
    {
    case SHN_IA_64_ANSI_COMMON:
      asym->section = bfd_com_section_ptr;
      asym->value = elfsym->internal_elf_sym.st_size;
      asym->flags &= ~BSF_GLOBAL;
      break;
    }
}

a4827 2
#define bfd_elfNN_bfd_link_hash_table_free \
	elfNN_ia64_hash_table_free
d4856 1
a4885 3

#undef elf_backend_symbol_processing
#define elf_backend_symbol_processing elfNN_hpux_backend_symbol_processing
@


1.58.2.13
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d56 1
a56 1
 		does not require dynamic relocations.  */
d84 1
a84 1
  /* The symbol table entry, if any, that this was derived from.  */
d197 1
a197 1
  PARAMS ((bfd *, struct bfd_link_info *));
d710 1
a710 1
  if (!is_elf_hash_table (link_info->hash))
d717 1
a717 1
      || (!link_info->need_relax_finalize
d768 1
a768 1
	  if (!link_info->need_relax_finalize)
d775 1
a775 1
	  if (link_info->need_relax_finalize)
d807 1
a807 1
	    continue;	/* We can't do anything with undefined symbols.  */
d855 1
a855 1
	      /* We can't do anything with undefined symbols.  */
d1076 1
a1076 1
  if (!link_info->need_relax_finalize)
d1408 1
a1408 1
elfNN_ia64_modify_segment_map (abfd, info)
a1409 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1595 1
a1595 2
        | ELF_LINK_HASH_REF_REGULAR_NONWEAK
        | ELF_LINK_HASH_NEEDS_PLT));
d1955 1
a1955 1
   because it contains "official procedure descriptors".  The "official"
d1995 1
a1995 1
	  fptr_rel = bfd_make_section(dynobj, ".rela.opd");
d1997 1
a1997 1
	      || !bfd_set_section_flags (dynobj, fptr_rel,
a2928 9
	}
      else if (sec == ia64_info->rel_fptr_sec)
	{
	  if (strip)
	    ia64_info->rel_fptr_sec = NULL;
	  else
	    /* We use the reloc_count field as a counter if we need to
	       copy relocs into the output file.  */
	    sec->reloc_count = 0;
@


1.58.2.14
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@a878 2
	  bfd_signed_vma offset;

a913 7

	      /* If trampoline is out of range, there is nothing we
		 can do.  */
	      offset = trampoff - (roff & (bfd_vma) -4);
	      if (offset < -0x1000000 || offset > 0x0FFFFF0)
		continue;

a959 6
	      /* If trampoline is out of range, there is nothing we
		 can do.  */
	      offset = f->trampoff - (roff & (bfd_vma) -4);
	      if (offset < -0x1000000 || offset > 0x0FFFFF0)
		continue;

d964 4
a967 2
	  /* Fix up the existing branch to hit the trampoline.  */
	  if (elfNN_ia64_install_value (abfd, contents + roff, offset,
@


1.57
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d727 3
a729 1
    if (ELFNN_R_TYPE (irel->r_info) == (int) R_IA64_PCREL21B)
d761 3
a763 1
      if (ELFNN_R_TYPE (irel->r_info) != (int) R_IA64_PCREL21B)
@


1.56
log
@	* elfxx-ia64.c (elfNN_ia64_final_write_processing): Set e_flags.
@
text
@d210 2
a211 1
  PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
d1606 2
a1607 1
elfNN_ia64_hash_copy_indirect (xdir, xind)
@


1.55
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d1190 13
@


1.54
log
@Add new bitfield 'want_p_paddr_set_to_zero'.
Set this field for HPUX IA64 port.
Test this field when setting p_paddr.
@
text
@a55 2
#define USE_RELA		/* we want RELA relocs, not REL */

@


1.53
log
@	* elfxx-ia64.c: (elfNN_ia64_modify_segment_map): Properly scan
	PT_IA_64_UNWIND segments for a given section.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 27
a54 29
/*
 * THE RULES for all the stuff the linker creates --
 *
 * GOT		Entries created in response to LTOFF or LTOFF_FPTR
 *		relocations.  Dynamic relocs created for dynamic
 *		symbols in an application; REL relocs for locals
 *		in a shared library.
 *
 * FPTR		The canonical function descriptor.  Created for local
 *		symbols in applications.  Descriptors for dynamic symbols
 *		and local symbols in shared libraries are created by
 *		ld.so.  Thus there are no dynamic relocs against these
 *		objects.  The FPTR relocs for such _are_ passed through
 *		to the dynamic relocation tables.
 *
 * FULL_PLT	Created for a PCREL21B relocation against a dynamic symbol.
 *		Requires the creation of a PLTOFF entry.  This does not
 *		require any dynamic relocations.
 *
 * PLTOFF	Created by PLTOFF relocations.  For local symbols, this
 *		is an alternate function descriptor, and in shared libraries
 *		requires two REL relocations.  Note that this cannot be
 *		transformed into an FPTR relocation, since it must be in
 *		range of the GP.  For dynamic symbols, this is a function
 *		descriptor for a MIN_PLT entry, and requires one IPLT reloc.
 *
 * MIN_PLT	Created by PLTOFF entries against dynamic symbols.  This
 *		does not reqire dynamic relocations.
 */
d141 1
a141 1
  /* The main hash table */
d328 1
a328 1
/* ia64-specific relocation */
d462 1
a462 1
static reloc_howto_type*
d1088 16
a1103 18
    /*
     * This is an ugly, but unfortunately necessary hack that is
     * needed when producing EFI binaries on IA-64. It tells
     * elf.c:elf_fake_sections() not to consider ".reloc" as a section
     * containing ELF relocation info.  We need this hack in order to
     * be able to generate ELF binaries that can be translated into
     * EFI applications (which are essentially COFF objects).  Those
     * files contain a COFF ".reloc" section inside an ELFNN object,
     * which would normally cause BFD to segfault because it would
     * attempt to interpret this section as containing relocation
     * entries for section "oc".  With this hack enabled, ".reloc"
     * will be treated as a normal data section, which will avoid the
     * segfault.  However, you won't be able to create an ELFNN binary
     * with a section named "oc" that needs relocations, but that's
     * the kind of ugly side-effects you get when detecting section
     * types based on their names...  In practice, this limitation is
     * unlikely to bite.
     */
d1509 2
d4797 3
d4807 2
@


1.52
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@a1371 2
  boolean unwind_found;
  asection *unwind_sec;
d1416 2
d1421 3
d1425 1
a1425 10
		unwind_sec = m->sections[0];
		unwind_found = false;
		while (unwind_sec != NULL && !unwind_found)
		  {
		    if (unwind_sec == s)
		      unwind_found = true;
		    else
		      unwind_sec = unwind_sec -> next;
		  }
		if (unwind_found)
@


1.52.2.1
log
@	* elfxx-ia64.c: (elfNN_ia64_modify_segment_map): Properly scan
	PT_IA_64_UNWIND segments for a given section.
@
text
@d1372 2
a1417 2
		int i;

a1420 3
		for (i = m->count - 1; i >= 0; --i)
		  if (m->sections[i] == s)
		    break;
d1422 10
a1431 1
		if (i >= 0)
@


1.52.2.2
log
@Add support for targets which need p_paddr set to zero.
Enable this feature for the HP-UX IA-64 target.
@
text
@a4798 3
#undef  elf_backend_want_p_paddr_set_to_zero
#define elf_backend_want_p_paddr_set_to_zero 1

a4805 2

#undef  elf_backend_want_p_paddr_set_to_zero
@


1.52.2.3
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d214 1
a214 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d1596 1
a1596 2
elfNN_ia64_hash_copy_indirect (bed, xdir, xind)
     struct elf_backend_data *bed ATTRIBUTE_UNUSED;
@


1.52.2.4
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a653 1
#ifdef USE_BRL
d660 1
a660 1
#else
a672 1
#endif
a1273 1
	  struct bfd_link_hash_entry *bh = NULL;
d1282 1
a1282 1
		 bed->collect, &bh)))
a1284 1
	  h = (struct elf_link_hash_entry *) bh;
@


1.51
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@a693 1
  Elf_Internal_Shdr *shndx_hdr;
a694 1
  Elf_Internal_Rela *free_relocs = NULL;
d697 1
a697 4
  bfd_byte *free_contents = NULL;
  ElfNN_External_Sym *extsyms;
  ElfNN_External_Sym *free_extsyms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
d724 1
a724 4
    goto error_return;

  if (! link_info->keep_memory)
    free_relocs = internal_relocs;
d736 2
a737 2
      if (free_relocs != NULL)
	free (free_relocs);
a748 1
      free_contents = contents;
a754 31
  /* Read this BFD's local symbols.  */
  if (symtab_hdr->contents != NULL)
    extsyms = (ElfNN_External_Sym *) symtab_hdr->contents;
  else
    {
      bfd_size_type amt;

      amt = symtab_hdr->sh_info * sizeof (ElfNN_External_Sym);
      extsyms = (ElfNN_External_Sym *) bfd_malloc (amt);
      if (extsyms == NULL)
	goto error_return;
      free_extsyms = extsyms;
      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (extsyms, amt, abfd) != amt)
	goto error_return;
    }

  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (shndx_hdr->sh_size != 0)
    {
      bfd_size_type amt;

      amt = symtab_hdr->sh_info * sizeof (Elf_External_Sym_Shndx);
      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (shndx_buf == NULL)
	goto error_return;
      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (shndx_buf, amt, abfd) != amt)
	goto error_return;
    }

a757 1
      Elf_Internal_Sym isym;
d768 2
a769 2
	  ElfNN_External_Sym *esym;
	  Elf_External_Sym_Shndx *shndx;
d771 14
a784 6
	  /* A local symbol.  */
	  esym = extsyms + ELFNN_R_SYM (irel->r_info);
	  shndx = shndx_buf + (shndx_buf ? ELFNN_R_SYM (irel->r_info) : 0);
	  bfd_elfNN_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
	  if (isym.st_shndx == SHN_UNDEF)
d786 1
a786 1
	  else if (isym.st_shndx == SHN_ABS)
d788 1
a788 1
	  else if (isym.st_shndx == SHN_COMMON)
d790 1
a790 1
	  else if (isym.st_shndx == SHN_IA_64_ANSI_COMMON)
d793 1
a793 1
	    tsec = bfd_section_from_elf_index (abfd, isym.st_shndx);
d795 1
a795 1
	  toff = isym.st_value;
d943 2
a944 8
  if (changed_relocs)
    elf_section_data (sec)->relocs = internal_relocs;
  else if (free_relocs != NULL)
    free (free_relocs);

  if (changed_contents)
    elf_section_data (sec)->this_hdr.contents = contents;
  else if (free_contents != NULL)
d947 13
a959 1
	free (free_contents);
d967 1
a967 4
  if (shndx_buf != NULL)
    free (shndx_buf);

  if (free_extsyms != NULL)
d969 2
a970 2
      if (! link_info->keep_memory)
	free (free_extsyms);
d972 1
a972 4
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) extsyms;
	}
d979 8
a986 8
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (shndx_buf != NULL)
    free (shndx_buf);
  if (free_extsyms != NULL)
    free (free_extsyms);
@


1.50
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d815 2
a816 2
	  bfd_elfNN_swap_symbol_in (abfd, (const PTR *) esym,
				    (const PTR *) shndx, &isym);
@


1.49
log
@	* elf.c (bfd_section_from_shdr): Make "name" const.
	* elf-bfd.h (elf_backend_section_from_shdr): Likewise.
	* elf32-i370.c (i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-ppc.c (ppc64_elf_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d815 2
a816 1
	  bfd_elfNN_swap_symbol_in (abfd, esym, shndx, &isym);
@


1.48
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d177 1
a177 1
  PARAMS ((bfd *, ElfNN_Internal_Shdr *, char *));
d1050 1
a1050 1
     char *name;
@


1.48.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d177 1
a177 1
  PARAMS ((bfd *, ElfNN_Internal_Shdr *, const char *));
d815 1
a815 2
	  bfd_elfNN_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d1050 1
a1050 1
     const char *name;
@


1.48.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d694 1
d696 1
d699 4
a702 1
  Elf_Internal_Sym *isymbuf = NULL;
d729 4
a732 1
    return false;
d744 2
a745 2
      if (elf_section_data (sec)->relocs != internal_relocs)
	free (internal_relocs);
d757 1
d764 31
d798 1
d809 3
d813 5
a817 16
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == 0)
		goto error_return;
	    }

	  isym = isymbuf + ELF64_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
d819 1
a819 1
	  else if (isym->st_shndx == SHN_ABS)
d821 1
a821 1
	  else if (isym->st_shndx == SHN_COMMON)
d823 1
a823 1
	  else if (isym->st_shndx == SHN_IA_64_ANSI_COMMON)
d826 1
a826 1
	    tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d828 1
a828 1
	  toff = isym->st_value;
d976 8
a983 2
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
d986 1
a986 1
	free (isymbuf);
d989 2
a990 2
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d994 4
a997 2
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
d999 2
a1000 2
      if (!changed_contents && !link_info->keep_memory)
	free (contents);
d1003 2
a1004 2
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
a1007 8
  if (elf_section_data (sec)->relocs != internal_relocs)
    {
      if (!changed_relocs)
	free (internal_relocs);
      else
	elf_section_data (sec)->relocs = internal_relocs;
    }

d1012 8
a1019 8
  if (isymbuf != NULL && (unsigned char *) isymbuf != symtab_hdr->contents)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
d1405 2
a1450 2
		int i;

a1453 3
		for (i = m->count - 1; i >= 0; --i)
		  if (m->sections[i] == s)
		    break;
d1455 10
a1464 1
		if (i >= 0)
@


1.48.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 31
a58 27
/* THE RULES for all the stuff the linker creates --
 
  GOT		Entries created in response to LTOFF or LTOFF_FPTR
 		relocations.  Dynamic relocs created for dynamic
 		symbols in an application; REL relocs for locals
 		in a shared library.
 
  FPTR		The canonical function descriptor.  Created for local
 		symbols in applications.  Descriptors for dynamic symbols
 		and local symbols in shared libraries are created by
 		ld.so.  Thus there are no dynamic relocs against these
 		objects.  The FPTR relocs for such _are_ passed through
 		to the dynamic relocation tables.
 
  FULL_PLT	Created for a PCREL21B relocation against a dynamic symbol.
 		Requires the creation of a PLTOFF entry.  This does not
 		require any dynamic relocations.
 
  PLTOFF	Created by PLTOFF relocations.  For local symbols, this
 		is an alternate function descriptor, and in shared libraries
 		requires two REL relocations.  Note that this cannot be
 		transformed into an FPTR relocation, since it must be in
 		range of the GP.  For dynamic symbols, this is a function
 		descriptor for a MIN_PLT entry, and requires one IPLT reloc.
 
  MIN_PLT	Created by PLTOFF entries against dynamic symbols.  This
 		does not reqire dynamic relocations.  */
d143 1
a143 1
  /* The main hash table.  */
d330 1
a330 1
/* ia64-specific relocation.  */
d464 1
a464 1
static reloc_howto_type *
d1090 18
a1107 16
    /* This is an ugly, but unfortunately necessary hack that is
       needed when producing EFI binaries on IA-64. It tells
       elf.c:elf_fake_sections() not to consider ".reloc" as a section
       containing ELF relocation info.  We need this hack in order to
       be able to generate ELF binaries that can be translated into
       EFI applications (which are essentially COFF objects).  Those
       files contain a COFF ".reloc" section inside an ELFNN object,
       which would normally cause BFD to segfault because it would
       attempt to interpret this section as containing relocation
       entries for section "oc".  With this hack enabled, ".reloc"
       will be treated as a normal data section, which will avoid the
       segfault.  However, you won't be able to create an ELFNN binary
       with a section named "oc" that needs relocations, but that's
       the kind of ugly side-effects you get when detecting section
       types based on their names...  In practice, this limitation is
       unlikely to bite.  */
a1195 13

  if (! elf_flags_init (abfd))
    {
      unsigned long flags = 0;

      if (abfd->xvec->byteorder == BFD_ENDIAN_BIG)
	flags |= EF_IA_64_BE;
      if (bfd_get_mach (abfd) == bfd_mach_ia64_elf64)
	flags |= EF_IA_64_ABI64;

      elf_elfheader(abfd)->e_flags = flags;
      elf_flags_init (abfd) = true;
    }
a1512 2
    default:
      break;
a4798 3
#undef  elf_backend_want_p_paddr_set_to_zero
#define elf_backend_want_p_paddr_set_to_zero 1

a4805 2

#undef  elf_backend_want_p_paddr_set_to_zero
@


1.48.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d210 1
a210 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d1605 1
a1605 2
elfNN_ia64_hash_copy_indirect (bed, xdir, xind)
     struct elf_backend_data *bed ATTRIBUTE_UNUSED;
@


1.48.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d727 1
a727 3
    if (ELFNN_R_TYPE (irel->r_info) == (int) R_IA64_PCREL21B
	|| ELFNN_R_TYPE (irel->r_info) == (int) R_IA64_PCREL21M
	|| ELFNN_R_TYPE (irel->r_info) == (int) R_IA64_PCREL21F)
d759 1
a759 3
      if (ELFNN_R_TYPE (irel->r_info) != (int) R_IA64_PCREL21B
	  && ELFNN_R_TYPE (irel->r_info) != (int) R_IA64_PCREL21M
	  && ELFNN_R_TYPE (irel->r_info) != (int) R_IA64_PCREL21F)
@


1.48.2.6
log
@merge from mainline
@
text
@a649 1
#ifdef USE_BRL
d656 1
a656 1
#else
a668 1
#endif
a1284 1
	  struct bfd_link_hash_entry *bh = NULL;
d1293 1
a1293 1
		 bed->collect, &bh)))
a1295 1
	  h = (struct elf_link_hash_entry *) bh;
@


1.47
log
@	* elf-bfd.h (struct elf_backend_data): Add rela_normal.
	* elfxx-target.h (elf_backend_rela_normal): Define.
	(elfNN_bed): Init rela_normal.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Handle adjustment
	for section symbols here if rela_normal.  Simplify abs section test.
	* elf-m10200.c (mn10200_elf_relocate_section): If relocatable,
	return immediately.  Remove code handling relocatable linking.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise #ifndef USE_REL.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf-m10200.c (elf_backend_rela_normal): Define.
	* elf-m10300.c (elf_backend_rela_normal): Define.
	* elf32-fr30.c (elf_backend_rela_normal): Define.
	* elf32-i370.c (elf_backend_rela_normal): Define.
	* elf32-i860.c (elf_backend_rela_normal): Define.
	* elf32-m68k.c (elf_backend_rela_normal): Define.
	* elf32-mcore.c (elf_backend_rela_normal): Define.
	* elf32-openrisc.c (elf_backend_rela_normal): Define.
	* elf32-ppc.c (elf_backend_rela_normal): Define.
	* elf32-s390.c (elf_backend_rela_normal): Define.
	* elf32-xstormy16.c (elf_backend_rela_normal): Define.
	* elf64-ppc.c (elf_backend_rela_normal): Define.
	* elf64-s390.c (elf_backend_rela_normal): Define.
	* elf64-x86-64.c (elf_backend_rela_normal): Define.
	* elfxx-ia64.c (elf_backend_rela_normal): Define.
	* elf32-arm.h (elf_backend_rela_normal): Define #ifndef USE_REL.
	* elf32-m32r.c (elf_backend_rela_normal): Likewise.
@
text
@d82 3
d103 3
d114 3
d297 4
d439 1
d441 1
d444 14
a457 1
    IA64_HOWTO (R_IA64_LTOFF_TP22,  "LTOFF_TP22",  0, false, false),
d572 1
d574 1
d577 14
a590 1
    case BFD_RELOC_IA64_LTOFF_TP22:	rtype = R_IA64_LTOFF_TP22; break;
d2143 3
a2182 1
	case R_IA64_TPREL22:
d2185 34
a2218 2
	case R_IA64_LTOFF_TP22:
	  return false;
d2328 1
a2328 1
      if (need_entry & NEED_GOT)
d2336 8
a2343 1
	  dyn_i->want_got = 1;
d2423 15
d2684 4
d2699 6
d3015 5
a3019 1
    case R_IA64_IMM14:		opnd = IA64_OPND_IMM14; break;
d3036 5
d3051 2
d3066 1
d3078 1
d3091 3
d3106 3
d3263 2
d3269 1
a3269 3
  BFD_ASSERT ((dyn_i->got_offset & 7) == 0);

  if (! dyn_i->got_done)
d3271 17
d3289 5
d3295 2
d3298 1
a3298 1
      bfd_put_64 (abfd, value, got_sec->contents + dyn_i->got_offset);
d3301 1
a3301 1
      if (info->shared
d3306 4
a3309 1
	  if (dynindx == -1)
d3329 9
d3346 1
a3346 1
					dyn_i->got_offset, dyn_r_type,
d3354 1
a3354 1
	   + dyn_i->got_offset);
d3452 29
d4224 49
@


1.47.2.1
log
@merge from trunk
@
text
@a81 3
  bfd_vma tprel_offset;
  bfd_vma dtpmod_offset;
  bfd_vma dtprel_offset;
a99 3
  unsigned tprel_done : 1;
  unsigned dtpmod_done : 1;
  unsigned dtprel_done : 1;
a107 3
  unsigned want_tprel : 1;
  unsigned want_dtpmod : 1;
  unsigned want_dtprel : 1;
d168 1
a168 1
  PARAMS ((bfd *, ElfNN_Internal_Shdr *, const char *));
a287 4
static bfd_vma elfNN_ia64_tprel_base
  PARAMS ((struct bfd_link_info *info));
static bfd_vma elfNN_ia64_dtprel_base
  PARAMS ((struct bfd_link_info *info));
a425 1
    IA64_HOWTO (R_IA64_TPREL14,	    "TPREL14",	   0, false, false),
a426 1
    IA64_HOWTO (R_IA64_TPREL64I,    "TPREL64I",	   0, false, false),
d429 1
a429 14
    IA64_HOWTO (R_IA64_LTOFF_TPREL22, "LTOFF_TPREL22",  0, false, false),

    IA64_HOWTO (R_IA64_DTPMOD64MSB, "TPREL64MSB",  8, false, false),
    IA64_HOWTO (R_IA64_DTPMOD64LSB, "TPREL64LSB",  8, false, false),
    IA64_HOWTO (R_IA64_LTOFF_DTPMOD22, "LTOFF_DTPMOD22", 0, false, false),

    IA64_HOWTO (R_IA64_DTPREL14,    "DTPREL14",	   0, false, false),
    IA64_HOWTO (R_IA64_DTPREL22,    "DTPREL22",	   0, false, false),
    IA64_HOWTO (R_IA64_DTPREL64I,   "DTPREL64I",   0, false, false),
    IA64_HOWTO (R_IA64_DTPREL32MSB, "DTPREL32MSB", 4, false, false),
    IA64_HOWTO (R_IA64_DTPREL32LSB, "DTPREL32LSB", 4, false, false),
    IA64_HOWTO (R_IA64_DTPREL64MSB, "DTPREL64MSB", 8, false, false),
    IA64_HOWTO (R_IA64_DTPREL64LSB, "DTPREL64LSB", 8, false, false),
    IA64_HOWTO (R_IA64_LTOFF_DTPREL22, "LTOFF_DTPREL22", 0, false, false),
a543 1
    case BFD_RELOC_IA64_TPREL14:	rtype = R_IA64_TPREL14; break;
a544 1
    case BFD_RELOC_IA64_TPREL64I:	rtype = R_IA64_TPREL64I; break;
d547 1
a547 14
    case BFD_RELOC_IA64_LTOFF_TPREL22:	rtype = R_IA64_LTOFF_TPREL22; break;

    case BFD_RELOC_IA64_DTPMOD64MSB:	rtype = R_IA64_DTPMOD64MSB; break;
    case BFD_RELOC_IA64_DTPMOD64LSB:	rtype = R_IA64_DTPMOD64LSB; break;
    case BFD_RELOC_IA64_LTOFF_DTPMOD22:	rtype = R_IA64_LTOFF_DTPMOD22; break;

    case BFD_RELOC_IA64_DTPREL14:	rtype = R_IA64_DTPREL14; break;
    case BFD_RELOC_IA64_DTPREL22:	rtype = R_IA64_DTPREL22; break;
    case BFD_RELOC_IA64_DTPREL64I:	rtype = R_IA64_DTPREL64I; break;
    case BFD_RELOC_IA64_DTPREL32MSB:	rtype = R_IA64_DTPREL32MSB; break;
    case BFD_RELOC_IA64_DTPREL32LSB:	rtype = R_IA64_DTPREL32LSB; break;
    case BFD_RELOC_IA64_DTPREL64MSB:	rtype = R_IA64_DTPREL64MSB; break;
    case BFD_RELOC_IA64_DTPREL64LSB:	rtype = R_IA64_DTPREL64LSB; break;
    case BFD_RELOC_IA64_LTOFF_DTPREL22:	rtype = R_IA64_LTOFF_DTPREL22; break;
d772 1
a772 2
	  bfd_elfNN_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d1007 1
a1007 1
     const char *name;
a2099 3
	NEED_TPREL = 128,
	NEED_DTPMOD = 256,
	NEED_DTPREL = 512
d2137 1
d2140 2
a2141 34
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  dynrel_type = R_IA64_TPREL64LSB;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;

	case R_IA64_LTOFF_TPREL22:
	  need_entry = NEED_TPREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  break;

	case R_IA64_DTPREL64MSB:
	case R_IA64_DTPREL64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  dynrel_type = R_IA64_DTPREL64LSB;
	  break;

	case R_IA64_LTOFF_DTPREL22:
	  need_entry = NEED_DTPREL;
	  break;

	case R_IA64_DTPMOD64MSB:
	case R_IA64_DTPMOD64LSB:
	  if (info->shared || maybe_dynamic)
	    need_entry = NEED_DYNREL;
	  dynrel_type = R_IA64_DTPMOD64LSB;
	  break;

	case R_IA64_LTOFF_DTPMOD22:
	  need_entry = NEED_DTPMOD;
	  break;
d2251 1
a2251 1
      if (need_entry & (NEED_GOT | NEED_TPREL | NEED_DTPMOD | NEED_DTPREL))
d2259 1
a2259 8
	  if (need_entry & NEED_GOT)
	    dyn_i->want_got = 1;
	  if (need_entry & NEED_TPREL)
	    dyn_i->want_tprel = 1;
	  if (need_entry & NEED_DTPMOD)
	    dyn_i->want_dtpmod = 1;
	  if (need_entry & NEED_DTPREL)
	    dyn_i->want_dtprel = 1;
a2338 15
  if (dyn_i->want_tprel)
    {
      dyn_i->tprel_offset = x->ofs;
      x->ofs += 8;
    }
  if (dyn_i->want_dtpmod)
    {
      dyn_i->dtpmod_offset = x->ofs;
      x->ofs += 8;
    }
  if (dyn_i->want_dtprel)
    {
      dyn_i->dtprel_offset = x->ofs;
      x->ofs += 8;
    }
a2584 4
	case R_IA64_TPREL64LSB:
	case R_IA64_DTPREL64LSB:
	case R_IA64_DTPMOD64LSB:
	  break;
a2595 6
  if ((dynamic_symbol || shared) && dyn_i->want_tprel)
    ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
  if ((dynamic_symbol || shared) && dyn_i->want_dtpmod)
    ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
  if (dynamic_symbol && dyn_i->want_dtprel)
    ia64_info->rel_got_sec->_raw_size += sizeof (ElfNN_External_Rela);
d2906 1
a2906 5
    case R_IA64_IMM14:
    case R_IA64_TPREL14:
    case R_IA64_DTPREL14:
      opnd = IA64_OPND_IMM14;
      break;
a2922 5
    case R_IA64_TPREL22:
    case R_IA64_DTPREL22:
    case R_IA64_LTOFF_TPREL22:
    case R_IA64_LTOFF_DTPMOD22:
    case R_IA64_LTOFF_DTPREL22:
a2932 2
    case R_IA64_TPREL64I:
    case R_IA64_DTPREL64I:
a2945 1
    case R_IA64_DTPREL32MSB:
a2956 1
    case R_IA64_DTPREL32LSB:
a2968 3
    case R_IA64_TPREL64MSB:
    case R_IA64_DTPMOD64MSB:
    case R_IA64_DTPREL64MSB:
a2980 3
    case R_IA64_TPREL64LSB:
    case R_IA64_DTPMOD64LSB:
    case R_IA64_DTPREL64LSB:
a3134 2
  boolean done;
  bfd_vma got_offset;
d3139 3
a3141 1
  switch (dyn_r_type)
a3142 17
    case R_IA64_TPREL64LSB:
      done = dyn_i->tprel_done;
      dyn_i->tprel_done = true;
      got_offset = dyn_i->tprel_offset;
      break;
    case R_IA64_DTPMOD64LSB:
      done = dyn_i->dtpmod_done;
      dyn_i->dtpmod_done = true;
      got_offset = dyn_i->dtpmod_offset;
      break;
    case R_IA64_DTPREL64LSB:
      done = dyn_i->dtprel_done;
      dyn_i->dtprel_done = true;
      got_offset = dyn_i->dtprel_offset;
      break;
    default:
      done = dyn_i->got_done;
a3143 5
      got_offset = dyn_i->got_offset;
      break;
    }

  BFD_ASSERT ((got_offset & 7) == 0);
a3144 2
  if (! done)
    {
d3146 1
a3146 1
      bfd_put_64 (abfd, value, got_sec->contents + got_offset);
d3149 1
a3149 1
      if ((info->shared && dyn_r_type != R_IA64_DTPREL64LSB)
d3154 1
a3154 4
	  if (dynindx == -1
	      && dyn_r_type != R_IA64_TPREL64LSB
	      && dyn_r_type != R_IA64_DTPMOD64LSB
	      && dyn_r_type != R_IA64_DTPREL64LSB)
a3173 9
		case R_IA64_TPREL64LSB:
		  dyn_r_type = R_IA64_TPREL64MSB;
		  break;
		case R_IA64_DTPMOD64LSB:
		  dyn_r_type = R_IA64_DTPMOD64MSB;
		  break;
		case R_IA64_DTPREL64LSB:
		  dyn_r_type = R_IA64_DTPREL64MSB;
		  break;
d3182 1
a3182 1
					got_offset, dyn_r_type,
d3190 1
a3190 1
	   + got_offset);
a3287 29
/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@tprel() relocation.
   Main program TLS (whose template starts at PT_TLS p_vaddr)
   is assigned offset round(16, PT_TLS p_align).  */

static bfd_vma
elfNN_ia64_tprel_base (info)
     struct bfd_link_info *info;
{
  struct elf_link_tls_segment *tls_segment
    = elf_hash_table (info)->tls_segment;

  BFD_ASSERT (tls_segment != NULL);
  return (tls_segment->start
	  - align_power ((bfd_vma) 16, tls_segment->align));
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtprel() relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
elfNN_ia64_dtprel_base (info)
     struct bfd_link_info *info;
{
  BFD_ASSERT (elf_hash_table (info)->tls_segment != NULL);
  return elf_hash_table (info)->tls_segment->start;
}

a4030 49
	  break;

	case R_IA64_TPREL14:
	case R_IA64_TPREL22:
	case R_IA64_TPREL64I:
	  value -= elfNN_ia64_tprel_base (info);
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
	  break;

	case R_IA64_DTPREL14:
	case R_IA64_DTPREL22:
	case R_IA64_DTPREL64I:
	  value -= elfNN_ia64_dtprel_base (info);
	  r = elfNN_ia64_install_value (output_bfd, hit_addr, value, r_type);
	  break;

	case R_IA64_LTOFF_TPREL22:
	case R_IA64_LTOFF_DTPMOD22:
	case R_IA64_LTOFF_DTPREL22:
	  {
	    int got_r_type;

	    switch (r_type)
	      {
	      default:
	      case R_IA64_LTOFF_TPREL22:
		if (!dynamic_symbol_p && !info->shared)
		  value -= elfNN_ia64_tprel_base (info);
		got_r_type = R_IA64_TPREL64LSB;
		break;
	      case R_IA64_LTOFF_DTPMOD22:
		if (!dynamic_symbol_p && !info->shared)
		  value = 1;
		got_r_type = R_IA64_DTPMOD64LSB;
		break;
	      case R_IA64_LTOFF_DTPREL22:
		if (!dynamic_symbol_p)
		  value -= elfNN_ia64_dtprel_base (info);
		got_r_type = R_IA64_DTPREL64LSB;
		break;
	      }
	    dyn_i = get_dyn_sym_info (ia64_info, h, input_bfd, rel, false);
	    value = set_got_entry (input_bfd, info, dyn_i,
				   (h ? h->dynindx : -1), rel->r_addend,
				   value, got_r_type);
	    value -= gp_val;
	    r = elfNN_ia64_install_value (output_bfd, hit_addr, value,
					  r_type);
	  }
@


1.46
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d3505 1
d3538 1
a3540 21

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sym_sec = local_sections[r_symndx];
		  rel->r_addend += sym_sec->output_offset;
		}
	    }
	  continue;
	}

      /* This is a final link.  */

d4545 1
@


1.45
log
@2002-03-04  H.J. Lu <hjl@@gnu.org>

	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.

	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.
@
text
@d1713 3
@


1.44
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a1018 3
    case SHT_INIT_ARRAY:
    case SHT_FINI_ARRAY:
    case SHT_PREINIT_ARRAY:
a1075 6
  else if (strcmp (name, ".init_array") == 0)
    hdr->sh_type = SHT_INIT_ARRAY;
  else if (strcmp (name, ".fini_array") == 0)
    hdr->sh_type = SHT_FINI_ARRAY;
  else if (strcmp (name, ".preinit_array") == 0)
    hdr->sh_type = SHT_PREINIT_ARRAY;
@


1.43
log
@Reset AIX vector function overrides for HP-UX.
@
text
@d3110 1
a3110 1
  if (outrel.r_offset == (bfd_vma) -1)
@


1.43.2.1
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d3110 1
a3110 1
  if ((outrel.r_offset | 1) == (bfd_vma) -1)
@


1.43.2.2
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d1019 3
d1079 6
@


1.43.2.3
log
@Merge from mainline.
@
text
@a1712 3
  if (entry->root.root.type == bfd_link_hash_warning)
    entry = (struct elfNN_ia64_link_hash_entry *) entry->root.root.u.i.link;

@


1.43.2.4
log
@Merge from mainline
@
text
@a3504 1
      return true;
a3536 1

d3539 21
a4563 1
#define elf_backend_rela_normal		1
@


1.42
log
@	* elf-bfd.h (elf_backend_data <elf_backend_hide_symbol>): Add
	boolean param.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Adjust call to
	elf_backend_hide_symbol.
	(elf_fix_symbol_flags): Likewise.
	(elf_link_assign_sym_version): Likewise. Use bfd_malloc rather
	than bfd_alloc.
	* elf.c (_bfd_elf_link_hash_hide_symbol): Add "force_local" param.
	Set ELF_LINK_FORCED_LOCAL and call _bfd_elf_strtab_delref.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	(clobber_millicode_symbols): Adjust to suit new hide_symbol.
	* elf32-cris.c (elf_cris_hide_symbol): Add "force_local" param
	and adjust to suit.
	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Likewise, and call
	_bfd_elf_link_hash_hide_symbol rather than duplicating code.
	* elfxx-ia64.c (elfNN_ia64_hash_hide_symbol): Likewise.
@
text
@d4603 10
@


1.41
log
@	* elf-bfd.h (elf_backend_data <elf_backend_section_from_bfd_section>):
	Remove "Elf_Internal_Shdr *" param.
	(_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-mips.c (_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-m32r.c (_bfd_m32r_elf_section_from_bfd_section): Ditto.
	* elf32-v850.c (v850_elf_section_from_bfd_section): Ditto.
	* elf64-mmix.c (mmix_elf_section_from_bfd_section): Ditto.
	* elfxx-ia64.c (elfNN_hpux_backend_section_from_bfd_section): Ditto.
	* elf.c (_bfd_elf_section_from_bfd_section): Allow backend
	function to override special sections.  Remove hdr arg from
	backend call, and don't loop.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d207 1
a207 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d1649 2
a1650 2
elfNN_ia64_hash_hide_symbol (info, xh)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1652 1
d1659 1
a1659 3
  h->root.elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
  if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->root.dynindx = -1;
@


1.40
log
@	* elfxx-ia64.c (is_unwind_section_name): Add target vector as
	argument so we can handle HP-UX specially.
	(elfNN_ia64_hpux_vec): New for use in is_unwind_section_name.
	(elfNN_hpux_backend_section_from_bfd_section): New for support
	of SHN_IA_64_ANSI_COMMON.
	(elfNN_ia64_relax_section): Add support for SHN_IA_64_ANSI_COMMON.
	(is_unwind_section_name): Add special HP-UX support.
	(elfNN_ia64_section_from_shdr): Add support for more sections.
	(elfNN_ia64_fake_sections): Modify is_unwind_section_name call and
	add support for more sections.
	(elfNN_ia64_additional_program_headers): Modify
	is_unwind_section_name call.
	(elfNN_ia64_modify_segment_map): Remove assumption that there is
	only one unwind section in segment.
@
text
@d315 1
a315 1
  PARAMS ((bfd *abfd, ElfNN_Internal_Shdr *hdr, asection *sec, int *retval));
d4484 1
a4484 1
elfNN_hpux_backend_section_from_bfd_section (abfd, hdr, sec, retval)
a4485 1
	Elf32_Internal_Shdr *hdr ATTRIBUTE_UNUSED;
@


1.39
log
@*** empty log message ***
@
text
@d166 1
a166 1
  PARAMS ((const char *));
d310 2
d314 2
d779 2
d982 2
a983 1
is_unwind_section_name (name)
d988 4
d1019 4
d1070 1
a1070 1
  if (is_unwind_section_name (name))
d1079 8
d1357 1
a1357 1
    if (is_unwind_section_name(s->name) && (s->flags & SEC_LOAD))
d1370 2
d1414 18
a1431 2
	    if (m->p_type == PT_IA_64_UNWIND && m->sections[0] == s)
	      break;
d4465 7
d4482 15
d4607 3
@


1.38
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (_bfd_elf_copy_private_bfd_data): New. Prototype.
	(_bfd_mips_elf_copy_private_bfd_data): Removed.

	* elf.c (_bfd_elf_copy_private_bfd_data): New. Copy e_flags in
	the ELF header.

	* elf32-i370.c (??_elf_copy_private_bfd_data): Removed.
	(bfd_elf??_bfd_copy_private_bfd_data): Removed.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-ia64.c: Likewise.

	* elf64-mips.c (bfd_elf64_bfd_copy_private_bfd_data): Removed.

	* elfxx-target.h (bfd_elfNN_bfd_copy_private_bfd_data): Defined
	to _bfd_elf_copy_private_bfd_data.
@
text
@d310 2
d1131 1
a1131 1
	      char *once_name = alloca (len2 + strlen (sname) - len + 1);
d1133 21
a1153 3
	      memcpy (once_name, ".gnu.linkonce.t.", len2);
	      strcpy (once_name + len2, sname + len);
	      text_sect = bfd_get_section_by_name (abfd, once_name);
d1781 1
d1789 3
a1791 1
  addr_name = alloca (len);
d1796 4
a1799 2
  return elfNN_ia64_local_hash_lookup (&ia64_info->loc_hash_table,
				       addr_name, create, create);
d4423 11
d4530 20
@


1.37
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@a303 2
static boolean elfNN_ia64_copy_private_bfd_data
  PARAMS ((bfd *ibfd, bfd *obfd));
a4262 18
/* Copy backend specific data from one object module to another */
static boolean
elfNN_ia64_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
{
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || (elf_elfheader (obfd)->e_flags
		  == elf_elfheader (ibfd)->e_flags));

  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = true;
  return true;
}

a4452 2
#define bfd_elfNN_bfd_copy_private_bfd_data \
	elfNN_ia64_copy_private_bfd_data
@


1.36
log
@	* elf-bfd.h (enum elf_link_info_type): New.
	(struct bfd_elf_section_data): Remove stab_info and merge_info
	fields, add sec_info and sec_info_type.
	(struct elf_obj_tdata): Add eh_frame_hdr field.
	(_bfd_elf_discard_section_eh_frame): New prototype.
	(_bfd_elf_discard_section_eh_frame_hdr): Likewise.
	(_bfd_elf_eh_frame_section_offset): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_write_section_eh_frame_hdr): Likewise.
	* Makefile.am (BFD32_BACKENDS): Add elf-eh-frame.lo.
	(BFD32_BACKENDS_CFILES): Add elf-eh-frame.c.
	(elf-eh-frame.lo): New.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-eh-frame.lo.
	* configure: Rebuilt.
	* elf.c (_bfd_elf_print_private_bfd_data): Support PT_GNU_EH_FRAME.
	(map_sections_to_segments): Create PT_GNU_EH_FRAME if requested.
	(get_program_header_size): Take into account PT_GNU_EH_FRAME
	segment.
	(_bfd_elf_rela_local_sym): Use sec_info_type and sec_info.
	(_bfd_elf_rel_local_sym): Likewise.
	(_bfd_elf_section_offset): Likewise.  Call
	_bfd_elf_eh_frame_section_offset too.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Use sec_info_type and
	sec_info.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf-eh-frame.c: New file.
	* elflink.h (elf_link_add_object_symbols): Don't optimize SHF_MERGE
	.stab sections.  Set sec_info_type, use sec_info instead
	of merge_info and stab_info.
	(elf_link_create_dynamic_sections): Create .eh_frame_hdr section
	if --eh-frame-hdr.
	(elf_bfd_final_link): Write .eh_frame_hdr section.
	(elf_link_sec_merge_syms): Use sec_info_type and sec_info.
	(elf_link_input_bfd): Likewise.
	Call _bfd_elf_write_section_eh_frame to write .eh_frame sections.
	(elf_bfd_discard_info): Add output_bfd argument.
	Call _bfd_elf_discard_section_eh_frame and
	_bfd_elf_discard_section_eh_frame_hdr.
	(elf_section_ignore_discarded_relocs): Use sec_info_type, not section
	names.
	* bfd-in.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Adjust
	prototypes.
	* bfd-in2.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Likewise.

	* elf/common.h (PT_GNU_EH_FRAME): Define.
	* bfdlink.h (struct bfd_link_info): Add eh_frame_hdr field.

	* emultempl/elf32.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	(OPTION_EH_FRAME_HDR): Define.
	(longopts): Add --eh-frame-hdr.
	(parse_args): Handle it.
	(list_options): Add --eh-frame-hdr to help.
	* emultempl/hppaelf.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	* scripttempl/elf.sc (.eh_frame_hdr): Add.

	* readelf.c (get_segment_type): Support PT_GNU_EH_FRAME.
@
text
@d647 1
d655 1
d717 1
a717 1
  /* Read this BFD's symbols.  */
d722 4
a725 1
      extsyms = (ElfNN_External_Sym *) bfd_malloc (symtab_hdr->sh_size);
d730 15
a744 2
	  || (bfd_bread (extsyms, symtab_hdr->sh_size, abfd)
	      != symtab_hdr->sh_size))
d762 3
d766 3
a768 3
	  bfd_elfNN_swap_symbol_in (abfd,
				    extsyms + ELFNN_R_SYM (irel->r_info),
				    &isym);
d775 1
a775 1
	  else if (isym.st_shndx > 0 && isym.st_shndx < SHN_LORESERVE)
a776 2
	  else
	    continue;	/* who knows.  */
d944 3
d966 2
d1252 1
a1252 1
      int i;
d1258 1
a1258 1
      for (i = 1; i < elf_elfheader (abfd)->e_shnum; i++)
d1260 1
a1260 1
	  asection * sec = bfd_section_from_elf_index (abfd, (unsigned) i);
@


1.35
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d3492 2
a3493 1
	      && elf_section_data (sym_sec)->merge_info)
d3509 1
a3509 1
						    merge_info,
@


1.34
log
@	* elf64-alpha.c (ALPHA_ELF_GOT_ENTRY_RELOCS_XLATED): Defined.
	(elf64_alpha_relocate_section): Translate local_got_entries
	for STT_SECTION symbol to SHF_MERGE section the first time
	we see it.
	* elfxx-ia64.c (struct elfNN_ia64_local_hash_entry): Add
	sec_merge_done.
	(get_local_sym_hash): New, extracted from get_dyn_sym_info.
	(get_dyn_sym_info): Use it.
	(elfNN_ia64_relocate_section): Translate local dyn entries
	for STT_SECTION symbol to SHF_MERGE section the first time
	we see it.

        * write.c (adjust_reloc_syms): Mark SEC_MERGE symbols as used
        in reloc if it has non-zero addend.
        * config/tc-alpha.c (tc_gen_reloc): Reinstall SEC_MERGE check.
        * config/tc-sparc.c (md_apply_fix3): Likewise.
@
text
@d3017 1
a3017 3
  outrel.r_offset = (sec->output_section->vma
		     + sec->output_offset
		     + offset);
d3022 2
a3023 2

  if (elf_section_data (sec)->stab_info != NULL)
d3025 5
a3029 17
      /* This may be NULL for linker-generated relocations, as it is
	 inconvenient to pass all the bits around.  And this shouldn't
	 happen.  */
      BFD_ASSERT (info != NULL);

      offset = (_bfd_stab_section_offset
		(abfd, &elf_hash_table (info)->stab_info, sec,
		 &elf_section_data (sec)->stab_info, offset));
      if (offset == (bfd_vma) -1)
	{
	  /* Run for the hills.  We shouldn't be outputting a relocation
	     for this.  So do what everyone else does and output a no-op.  */
	  outrel.r_info = ELFNN_R_INFO (0, R_IA64_NONE);
	  outrel.r_addend = 0;
	  offset = 0;
	}
      outrel.r_offset = offset;
@


1.33
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d114 4
d223 3
d1729 26
a1774 5
      char *addr_name;
      size_t len;

      /* Construct a string for use in the elfNN_ia64_local_hash_table.
         The name describes what was once anonymous memory.  */
d1776 1
a1776 10
      len = sizeof (void*)*2 + 1 + sizeof (bfd_vma)*4 + 1 + 1;
      len += 10;	/* %p slop */

      addr_name = alloca (len);
      sprintf (addr_name, "%p:%lx",
	       (void *) abfd, (unsigned long) ELFNN_R_SYM (rel->r_info));

      /* Collect the canonical entry data for this address.  */
      loc_h = elfNN_ia64_local_hash_lookup (&ia64_info->loc_hash_table,
					    addr_name, create, create);
d3504 31
@


1.32
log
@	* elfxx-ia64.c (elfNN_ia64_relocate_section): Test r_symndx rather
	than sym_sec->output_section to detect relocs against discarded
	sections.
@
text
@d3484 1
a3484 3
	  value  = (sym_sec->output_section->vma
		    + sym_sec->output_offset
		    + sym->st_value);
@


1.31
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d3838 10
a3847 3
	  {
	    struct elf_segment_map *m;
	    Elf_Internal_Phdr *p;
d3849 11
a3859 9
	    /* Find the segment that contains the output_section.  */
	    for (m = elf_tdata (output_bfd)->segment_map,
		   p = elf_tdata (output_bfd)->phdr;
		 m != NULL;
		 m = m->next, p++)
	      {
		int i;
		for (i = m->count - 1; i >= 0; i--)
		  if (m->sections[i] == sym_sec->output_section)
d3861 1
a3861 3
		if (i >= 0)
		  break;
	      }
d3863 2
a3864 8
	    if (m == NULL)
	      {
		/* If the input section was discarded from the output, then
		   do nothing.  */

		if (bfd_is_abs_section (sym_sec->output_section))
		  r = bfd_reloc_ok;
		else
d3866 14
a3879 14
	      }
	    else
	      {
		/* The VMA of the segment is the vaddr of the associated
		   program header.  */
		if (value > p->p_vaddr)
		  value -= p->p_vaddr;
		else
		  value = 0;
		r = elfNN_ia64_install_value (output_bfd, hit_addr, value,
					      r_type);
	      }
	    break;
	  }
@


1.30
log
@	* elf-m10200.c (mn10200_elf_relax_section): Cast assignment to
	Elf_Internal_Shdr.contents now that it's no longer a PTR.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elf.c (setup_group): Warning fixes.
	* elflink.h (elf_link_sort_relocs): Likewise.
	* pdp11.c (slurp_reloc_table): Likewise.
@
text
@d3563 1
d3758 3
a3760 2
	  if (dynamic_symbol_p
	      || elfNN_ia64_aix_vec (info->hash->creator))
@


1.29
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Test ind->root.type
	rather than ind->weakdef.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
@
text
@d925 1
a925 1
	  symtab_hdr->contents = extsyms;
@


1.28
log
@	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Fix typos in last
	change.
@
text
@d1527 1
a1527 1
  if (xdir == xind->weakdef)
@


1.27
log
@	* elflink.h (elf_fix_symbol_flags): Copy flags to weakdef using
	elf_backend_copy_indirect_symbol so that backend has a chance to
	copy other necessary fields.
	* elf-bfd.h (struct elf_backend_data): Update description of
	elf_backend_copy_indirect_symbol.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Bail out after
	copying flags if this is a weakdef.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_link_hash_lookup rather
	than bfd_link_hash_lookup.
	* elf32-i386 (elf_i386_adjust_dynamic_symbol): Don't do copy
	reloc processing for weakdefs.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
@
text
@d1515 2
a1516 2
  dir = (struct elfNN_ia64_link_hash_entry *)xdir;
  ind = (struct elfNN_ia64_link_hash_entry *)xind;
d1527 1
a1527 1
  if (dir == ind->weakdef)
@


1.26
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d1193 2
a1194 1
      h = (struct elf_link_hash_entry *) bfd_link_hash_lookup (info->hash, *namep, false, false, false);
d1526 3
@


1.25
log
@Fix compile time warnings
@
text
@d304 1
a304 1
  PARAMS ((int));
d4333 2
a4334 2
elfNN_ia64_reloc_type_class (type)
     int type;
d4336 1
a4336 1
  switch (type)
@


1.24
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d2775 1
a2775 1
elfNN_ia64_install_value (abfd, hit_addr, val, r_type)
d2778 1
a2778 1
     bfd_vma val;
d2787 5
d2953 1
a2953 1
      err = (*op->insert) (op, val, &insn);
@


1.23
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d3437 1
a3437 1
	     bfd_get_filename (input_bfd), (int)r_type);
d3597 1
a3597 1
			 bfd_get_filename (input_bfd));
d3630 1
a3630 1
		 bfd_get_filename (input_bfd), h->root.root.string);
d3768 1
a3768 1
		 bfd_get_filename (input_bfd));
d3776 1
a3776 1
		 bfd_get_filename (input_bfd));
d4257 1
a4257 1
	 bfd_get_filename (ibfd));
d4266 1
a4266 1
	 bfd_get_filename (ibfd));
d4275 1
a4275 1
	 bfd_get_filename (ibfd));
d4284 1
a4284 1
	 bfd_get_filename (ibfd));
d4294 1
a4294 1
	 bfd_get_filename (ibfd));
@


1.22
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1432 1
a1432 1
  if ((info->shared && !info->symbolic)
d2023 2
a2024 1
      if (h && ((info->shared && ! info->symbolic)
d3513 2
a3514 1
	  else if (info->shared && !info->symbolic
@


1.21
log
@	* elf-bfd.h (enum elf_reloc_type_class): New.
	(struct elf_backend_data): Add elf_backend_reloc_type_class.
	(_bfd_elf_reloc_type_class): New.
	* elfxx-target.h (elf_backend_reloc_type_class): Define.
	(elfNN_bed): Add elf_backend_reloc_type_class.
	* elf.c (_bfd_elf_reloc_type_class): New.
	* elf32-i386.c (elf_i386_check_relocs): Set DF_TEXTREL if the reloc
	is against read-only section.
	(elf_i386_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_i386_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elf32-sparc.c (elf32_sparc_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf32_sparc_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf32_sparc_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elf64-sparc.c (sparc64_elf_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(sparc64_elf_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(sparc64_elf_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add reltext field.
	(elfNN_ia64_hash_table_create): Clear ia64_info.
	(get_reloc_section): Set DF_TEXTREL if the reloc is against read-only
	section.
	(elfNN_ia64_size_dynamic_sections): Use ia64_info->reltext flag
	instead of looking up section names for DT_TEXTREL.
	(elfNN_ia64_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elflink.h (size_dynamic_sections): Add spare DT_NULL tags.
	(struct elf_link_sort_rela): New.
	(elf_link_sort_cmp1, elf_link_sort_cmp2, elf_link_sort_relocs): New.
	(elf_bfd_final_link): Call elf_link_sort_relocs.
	Convert one spare DT_NULL into DT_RELCOUNT resp. DT_RELACOUNT if
	necessary.

	* bfdlink.h (struct bfd_link_info): Add combreloc and
	spare_dynamic_tags fields.

	* emultempl/elf32.em (place_orphan): Place orphan .rel* sections
	into .rel.dyn resp. .rela.dyn if combreloc.
	(get_script): If .x linker script is equal to .xn, only put it
	once into the binary.
	Add .xc and .xsc scripts.
	(parse_args): Handle -z combreloc and -z nocombreloc.
	* scripttempl/elf.sc (.rela.sbss): Fix a typo.
	For .xc and .xsc scripts put all .rel* or .rela* input sections
	but .rel*.plt and PLT-like sections into .rel.dyn resp. .rela.dyn.
	* genscripts.sh (GENERATE_COMBRELOC_SCRIPT): Set if SCRIPT_NAME
	is elf.
	Strip trailing whitespace from script.
	Generate .xc and .xsc scripts if requested.
	* ldmain.c (main): Initialize link_info.combreloc and
	link_info.spare_dynamic_tags.
	* lexsup.c (OPTION_SPARE_DYNAMIC_TAGS): Define.
	(ld_options): Add --spare-dynamic-tags option.
	(parse_args): Likewise.
	* ld.texinfo: Document -z combreloc and -z nocombreloc.
	* ldint.texinfo: Document .xc and .xsc linker scripts.
	* NEWS: Add notes about -z combreloc and SHF_MERGE.
@
text
@d175 1
a175 1
static boolean elfNN_ia64_aix_vec 
d243 1
a243 1
static unsigned long global_sym_index
d551 2
a552 1
  bfd_reloc->howto = lookup_howto (ELFNN_R_TYPE (elf_reloc->r_info));
d718 1
a718 1
	  || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
d729 1
d797 1
a797 1
		 + roff) & -4;
d821 1
a821 1
	  int size;
d835 3
a837 2
	  trampoff = (sec->_cooked_size + 15) & -16;
	  contents = (bfd_byte *) bfd_realloc (contents, trampoff + size);
d840 1
a840 1
	  sec->_cooked_size = trampoff + size;
d868 1
a868 1
	  f = (struct one_fixup *) bfd_malloc (sizeof (*f));
d884 1
a884 1
				    f->trampoff - (roff & -4),
d1169 1
a1169 1
  return (/**/vec == & bfd_elfNN_ia64_aix_little_vec 
d1194 1
a1194 1
      if (h == NULL) 
d1201 1
a1201 1
	  
d1203 1
a1203 1
		(info, abfd, *namep, BSF_GLOBAL, 
d1208 1
a1208 1
	  
d1211 1
a1211 1
	  
d1221 1
a1221 1
      
d1224 1
a1224 1
	 Replace the "special" section with .text, if possible. 
d1228 2
a1229 2
	  asection * sec = bfd_section_from_elf_index (abfd, i);
	  
d1239 1
a1239 1
      
d1241 1
a1241 1
      
d1244 1
a1244 1
  else 
d1246 1
a1246 1
      return elfNN_ia64_add_symbol_hook (abfd, info, sym, 
d1308 2
a1309 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
d1344 2
a1345 1
	      m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
d1582 1
a1582 1
  ret = bfd_zalloc (abfd, sizeof (*ret));
d1764 2
a1765 2
      dyn_i = (struct elfNN_ia64_dyn_sym_info *)
	bfd_zalloc (abfd, sizeof *dyn_i);
d1948 2
a1949 2
      rent = (struct elfNN_ia64_dyn_reloc_entry *)
	bfd_alloc (abfd, sizeof (*rent));
d2079 1
a2079 1
		 abfd, 0, 0);
d2137 1
a2137 1
	     abfd, 0, 0);
d2173 1
a2173 1
		     (info, abfd, r_symndx)))
d2278 1
a2278 1
static unsigned long
d2602 1
a2602 1
  data.ofs = (data.ofs + 31) & -32;
d2719 1
a2719 1
	  sec->contents = (bfd_byte *) bfd_zalloc(dynobj, sec->_raw_size);
d2735 4
a2738 1
	  if (!bfd_elfNN_add_dynamic_entry (info, DT_DEBUG, 0))
d2742 1
a2742 1
      if (! bfd_elfNN_add_dynamic_entry (info, DT_IA_64_PLT_RESERVE, 0))
d2744 1
a2744 1
      if (! bfd_elfNN_add_dynamic_entry (info, DT_PLTGOT, 0))
d2749 3
a2751 3
	  if (! bfd_elfNN_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elfNN_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elfNN_add_dynamic_entry (info, DT_JMPREL, 0))
d2755 3
a2757 4
      if (! bfd_elfNN_add_dynamic_entry (info, DT_RELA, 0)
	  || ! bfd_elfNN_add_dynamic_entry (info, DT_RELASZ, 0)
	  || ! bfd_elfNN_add_dynamic_entry (info, DT_RELAENT,
					    sizeof (ElfNN_External_Rela)))
d2762 1
a2762 1
	  if (! bfd_elfNN_add_dynamic_entry (info, DT_TEXTREL, 0))
d3362 4
a3365 2
      qsort (unwind_output_sec->contents, unwind_output_sec->_raw_size / 24,
	     24, elfNN_ia64_unwind_entry_compare);
d3368 1
a3368 1
				      unwind_output_sec->contents, 0,
d3550 1
a3550 1
		   && (!h || strcmp (h->root.root.string, 
d3686 1
a3686 1
			     (info, input_bfd, r_symndx));
d3730 1
a3730 1
			     (info, input_bfd, r_symndx));
d3984 2
a3985 1
						     howto->name, 0,
@


1.20
log
@	* bfd.c (bfd_get_gp_size): Return an unsigned int.
	(bfd_set_gp_size): Make param unsigned.
	* bfd-in2.h: Regenerate.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Use elf_gp_size rather
	than calling bfd_get_gp_size.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
@
text
@d141 1
d303 2
d1577 1
a1577 1
  ret = bfd_alloc (abfd, sizeof (*ret));
d1922 3
a2543 1
  boolean reltext = false;
a2699 18
		  const char *outname;
		  asection *target;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL entry.  */
		  outname = bfd_get_section_name (output_bfd,
						  sec->output_section);
		  if (outname[4] == 'a')
		    outname += 5;
		  else
		    outname += 4;

		  target = bfd_get_section_by_name (output_bfd, outname);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = true;

d2753 1
a2753 1
      if (reltext)
d4314 21
d4411 1
@


1.19
log
@	* coffcode.h (coff_write_object_contents): Add ATTRIBUTE_UNUSED to
	silence warning.
	* coffgen.c (coff_print_symbol): Fix warnings.
	(coff_find_nearest_line): Likewise.
	* cofflink.c (_bfd_coff_link_input_bfd): Likewise.
	* coff-alpha.c (alpha_convert_external_reloc): Likewise.
	* format.c (bfd_check_format_matches): Likewise.
	(bfd_set_format): Likewise.
	* coff-ia64.c: Add missing prototypes.
	* elf64-alpha.c (struct alpha_elf_link_hash_entry): Make addend
	signed to silence warnings.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_find_reloc_at_ofs): Fix warnings.
	(elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_final_link): Likewise.
	(elf64_alpha_relax_section): Remove redundant assign to info.gotent.
	(elf64_alpha_merge_gots): Add ATTRIBUTE_UNUSED to unused args.
	(elf64_alpha_size_got_sections): Likewise.
	* elfxx-ia64.c: Add missing prototypes.
	(elfNN_ia64_relocate_section): Fix warning.
	(elfNN_ia64_unwind_entry_compare): Make params const.
@
text
@d1133 1
a1133 1
      && sym->st_size <= (unsigned) bfd_get_gp_size (abfd))
@


1.18
log
@sje patch for 32-bit IA-64 ELF relocs for HPUX
	* reloc.c (bfd_reloc_code_type): Add IA64 relocs
	BFD_RELOC_IA64_LTOFF_FPTR32MSB and BFD_RELOC_IA64_LTOFF_FPTR32LSB
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* elfxx-ia64.c (ia64_howto_table): Define how to handle
	new relocations.
	(elfNN_ia64_reloc_type_lookup): Handle new relocations.
	(elfNN_ia64_check_relocs): Likewise.
	(elfNN_ia64_install_value): Likewise.
	(elfNN_ia64_relocate_section): Likewise.
@
text
@d164 2
d184 2
d199 4
d208 4
d280 2
d1740 2
a1741 1
      sprintf (addr_name, "%p:%lx", (void *) abfd, ELFNN_R_SYM (rel->r_info));
d3206 2
a3207 2
     PTR a;
     PTR b;
@


1.17
log
@monterey updates
@
text
@d363 2
d485 2
d2014 2
d2823 1
d2834 1
d3689 2
@


1.16
log
@	* elfxx-ia64.c (is_unwind_section_name): Consider linkonce unwind
	sections as well.
	(elfNN_ia64_final_write_processing): Map .gnu.linkonce.ia64unw.FOO
	to .gnu.linkonce.t.FOO text section.

	* readelf.c (process_unwind): Print all unwind sections, not just
	one.

	* config/tc-ia64.c (special_linkonce_name): New.
	(make_unw_section): Map .gnu.linkonce.t.FOO text section into
	.gnu.linkonce.ia64unw{,i}.FOO.
	(ia64_elf_section_type): Handle .gnu.linkonce.ia64unw{,i}.FOO.
	(dot_endp): Add comment about it.

	* elf/ia64.h (ELF_STRING_ia64_unwind_once): Define.
	(ELF_STRING_ia64_unwind_info_once): Define.

	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Put
	.gnu.linkonce.ia64unw{,i} sections into corresponding .IA_64.unwind*
	output sections.
	* emulparams/elf64_aix.sh (OTHER_READONLY_SECTIONS): Likewise.
@
text
@d1164 3
a1166 4
      /* Define __GLOB_DATA_PTR.  This is expected to be a linker-defined
	 symbol by the Aix C runtime startup code.  Define the symbol
	 when it is encountered.  IBM sez no one else should use it b/c it is
	 undocumented.  */
d1179 2
a1180 1
		(info, abfd, *namep, BSF_GLOBAL, ia64_info->got_sec,
d1188 1
a1188 2
	  if (info->shared
	      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
d1200 2
a1201 3
	 Replace the "special" section with .text, if possible. */
      /* FIXME need to determine the proper section instead of defaulting to
	 .text.  */
d2020 1
a2020 3
	  if (elfNN_ia64_aix_vec (abfd->xvec))
	    need_entry = NEED_FPTR | NEED_DYNREL;
	  else if (info->shared || h)
a2069 2
	      /* On AIX, we always need a relocation, but make sure
		 __GLOB_DATA_PTR doesn't get an entry.  */ 
d2071 1
a2071 1
		  && (!h || strcmp (h->root.root.string, 
d2195 3
a2197 1
	  || elfNN_ia64_aix_vec (x->info->hash->creator)))
d2411 4
a2414 1
    || elfNN_ia64_aix_vec (x->info->hash->creator);
d3530 3
a3532 5
		   /* We want REL relocation for _GLOB_DATA_PTR, which would
		      otherwise be an IMM64, which isn't handled below.  The
		      symbol comes from the C runtime.  */
		   && (!h || 
		       strcmp (h->root.root.string, "__GLOB_DATA_PTR") != 0)))
@


1.15
log
@2000-04-27  H.J. Lu  <hjl@@gnu.org>

	* elf.c (_bfd_elf_link_hash_hide_symbol): Set dynindx to -1
	only for ELF_LINK_FORCED_LOCAL.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_hide_symbol): Likewise.

	* elflink.h (elf_fix_symbol_flags): Set ELF_LINK_FORCED_LOCAL
	if the symbol has hidden or internal visibility.
@
text
@d924 1
a924 1
  size_t len1, len2;
d928 4
a931 2
  return (strncmp (name, ELF_STRING_ia64_unwind, len1) == 0
	  && strncmp (name, ELF_STRING_ia64_unwind_info, len2) != 0);
d1069 12
@


1.14
log
@Update elf64 aix5 comments.
@
text
@d1527 2
a1528 1
  h->root.dynindx = -1;
@


1.13
log
@ia64-*-aix* support.
@
text
@d1185 5
a1189 14
      /* SHN_MONTEREY_SYSCALL (Description from IBM):
	 Special symbols on AIX; if the value is non-zero, the value
         should be put in the gp member of the function descriptor.  the
         function address member should be set to the address of the entry
         point of the user-space portion of the system call (epc insn in a
         priviledged page).  If the symbol value is zero, look in the special
         table for extended system calls.  The number for extended system
         calls will come from that table.  The index is set when the linker
         sees an export file that contains the syscall attribute after an
         exported symbol.  Kernel extensions indicate extended system calls
         they define by having STO_MONTEREY_SYSCALL in their st_other symbol
         table member. This is used by the system loader to add extended
         system calls to its table, which is subsequently provided to the
         runtime linker at each process startup.  */
a1200 2
      /* FIXME need to determine the proper section instead of defaulting to
	 .text.  */
@


1.12
log
@        * elfxx-ia64.c (elfNN_ia64_final_link): Set __gp if required
        and not user provided.
@
text
@d172 8
d569 3
d1125 118
d1993 2
a1994 1
		|| h->root.type == bfd_link_hash_defweak))
d2018 3
a2020 1
	  if (info->shared || h)
d2069 6
a2074 1
	  if (info->shared || maybe_dynamic)
d2138 3
a2140 1
	  if (!h && info->shared)
d2196 2
a2197 1
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info))
d2216 2
a2217 1
      && elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info))
d2235 2
a2236 1
      && ! elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info))
d2282 6
a2287 1
      if (x->info->shared)
d2410 2
a2411 1
  dynamic_symbol = elfNN_ia64_dynamic_symbol_p (dyn_i->h, x->info);
d2528 2
a2529 2
      sec->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
      sec->_raw_size = strlen (ELF_DYNAMIC_INTERPRETER) + 1;
d3035 1
d3525 7
a3531 1
	  if ((dynamic_symbol_p || info->shared)
d3583 2
d3724 2
a3725 1
	  if (dynamic_symbol_p)
d4377 21
@


1.11
log
@        * elfxx-ia64.c (is_unwind_section_name): New function.  Returns
        true if section name is an unwind table section name.
        (elfNN_ia64_additional_program_headers): Count each unwind section
        separately.
        (elfNN_ia64_modify_segment_map): Install one unwind program header
        for each unwind separate section.  Note: normally the linker
        script merges the unwind sections that go into a single segment,
        so this still generates at most one unwind program header per
        segment.

        * elfxx-ia64.c (elfNN_ia64_section_from_shdr): Accept any section
        name for SHT_IA_64_UNWIND, not just .IA_64.unwind.
        (elfNN_ia64_fake_sections): Mark sections with names that start
        with .IA_64.unwind but not with .IA_64.unwind_info as an IA-64
        unwind section.

        * elfxx-ia64.c (elfNN_ia64_final_write_processing): New function.
        Use it to make sh_info in unwind section point to the text section
        it applies to.
@
text
@d3160 7
@


1.10
log
@2001-02-06  H.J. Lu  <hjl@@gnu.org>

	* elfxx-ia64.c (elfNN_ia64_dynamic_symbol_p): Only hidden and
	internal symbols are not dynamic.
	* elf64-alpha.c (alpha_elf_dynamic_symbol_p): Likewise.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000 Free Software Foundation, Inc.
d160 2
d166 2
d907 14
a939 2
      if (strcmp (name, ELF_STRING_ia64_unwind) != 0)
	return false;
d987 7
a993 2
  if (strcmp (name, ELF_STRING_ia64_unwind) == 0)
    hdr->sh_type = SHT_IA_64_UNWIND;
d1023 52
d1128 4
a1131 4
  /* See if we need a PT_IA_64_UNWIND segment.  */
  s = bfd_get_section_by_name (abfd, ELF_STRING_ia64_unwind);
  if (s && (s->flags & SEC_LOAD))
    ++ret;
d1141 1
d1174 2
a1175 3
  /* Install the PT_IA_64_UNWIND segment, if needed.  */
  s = bfd_get_section_by_name (abfd, ELF_STRING_ia64_unwind);
  if (s && (s->flags & SEC_LOAD))
d1177 5
a1181 4
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	if (m->p_type == PT_IA_64_UNWIND)
	  break;
      if (m == NULL)
d1183 4
a1186 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
d1188 4
a1191 1
	    return false;
d1193 11
a1203 10
	  m->p_type = PT_IA_64_UNWIND;
	  m->count = 1;
	  m->sections[0] = s;
	  m->next = NULL;

	  /* We want to put it last.  */
	  pm = &elf_tdata (abfd)->segment_map;
	  while (*pm != NULL)
	    pm = &(*pm)->next;
	  *pm = m;
d4153 2
@


1.9
log
@        * elfxx-ia64.c (elfNN_ia64_dynamic_symbol_p): Return false
        for non-default visibility.
        * elf64-alpha.c (alpha_elf_dynamic_symbol_p): Likewise, but
        delete ugly macro and replace with pretty function.
@
text
@d1184 6
a1189 2
  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
    return false;
@


1.9.2.1
log
@Multiple IA-64 unwind section support.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
a159 2
static boolean is_unwind_section_name
  PARAMS ((const char *));
a163 2
static void elfNN_ia64_final_write_processing
  PARAMS ((bfd *abfd, boolean linker));
a902 14
/* Return true if NAME is an unwind table section name.  */

static inline boolean
is_unwind_section_name (name)
	const char *name;
{
  size_t len1, len2;

  len1 = sizeof (ELF_STRING_ia64_unwind) - 1;
  len2 = sizeof (ELF_STRING_ia64_unwind_info) - 1;
  return (strncmp (name, ELF_STRING_ia64_unwind, len1) == 0
	  && strncmp (name, ELF_STRING_ia64_unwind_info, len2) != 0);
}

d922 2
d971 2
a972 7
  if (is_unwind_section_name (name))
    {
      /* We don't have the sections numbered at this point, so sh_info
	 is set later, in elfNN_ia64_final_write_processing.  */
      hdr->sh_type = SHT_IA_64_UNWIND;
      hdr->sh_flags |= SHF_LINK_ORDER;
    }
a1001 52
/* The final processing done just before writing out an IA-64 ELF
   object file.  */

static void
elfNN_ia64_final_write_processing (abfd, linker)
     bfd *abfd;
     boolean linker ATTRIBUTE_UNUSED;
{
  Elf_Internal_Shdr *hdr;
  const char *sname;
  asection *text_sect, *s;
  size_t len;

  for (s = abfd->sections; s; s = s->next)
    {
      hdr = &elf_section_data (s)->this_hdr;
      switch (hdr->sh_type)
	{
	case SHT_IA_64_UNWIND:
	  /* See comments in gas/config/tc-ia64.c:dot_endp on why we
	     have to do this.  */
	  sname = bfd_get_section_name (abfd, s);
	  len = sizeof (ELF_STRING_ia64_unwind) - 1;
	  if (sname && strncmp (sname, ELF_STRING_ia64_unwind, len) == 0)
	    {
	      sname += len;

	      if (sname[0] == '\0')
		/* .IA_64.unwind -> .text */
		text_sect = bfd_get_section_by_name (abfd, ".text");
	      else
		/* .IA_64.unwindFOO -> FOO */
		text_sect = bfd_get_section_by_name (abfd, sname);
	    }
	  else
	    /* last resort: fall back on .text */
	    text_sect = bfd_get_section_by_name (abfd, ".text");

	  if (text_sect)
	    {
	      /* The IA-64 processor-specific ABI requires setting
		 sh_link to the unwind section, whereas HP-UX requires
		 sh_info to do so.  For maximum compatibility, we'll
		 set both for now... */
	      hdr->sh_link = elf_section_data (text_sect)->this_idx;
	      hdr->sh_info = elf_section_data (text_sect)->this_idx;
	    }
	  break;
	}
    }
}

d1055 4
a1058 4
  /* Count how many PT_IA_64_UNWIND segments we need.  */
  for (s = abfd->sections; s; s = s->next)
    if (is_unwind_section_name(s->name) && (s->flags & SEC_LOAD))
      ++ret;
a1067 1
  Elf_Internal_Shdr *hdr;
d1100 3
a1102 2
  /* Install PT_IA_64_UNWIND segments, if needed.  */
  for (s = abfd->sections; s; s = s->next)
d1104 4
a1107 5
      hdr = &elf_section_data (s)->this_hdr;
      if (hdr->sh_type != SHT_IA_64_UNWIND)
	continue;

      if (s && (s->flags & SEC_LOAD))
d1109 3
a1111 3
	  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	    if (m->p_type == PT_IA_64_UNWIND && m->sections[0] == s)
	      break;
d1113 4
a1116 5
	  if (m == NULL)
	    {
	      m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
	      if (m == NULL)
		return false;
d1118 5
a1122 11
	      m->p_type = PT_IA_64_UNWIND;
	      m->count = 1;
	      m->sections[0] = s;
	      m->next = NULL;

	      /* We want to put it last.  */
	      pm = &elf_tdata (abfd)->segment_map;
	      while (*pm != NULL)
		pm = &(*pm)->next;
	      *pm = m;
	    }
a4067 2
#define elf_backend_final_write_processing \
	elfNN_ia64_final_write_processing
@


1.9.2.2
log
@        * elfxx-ia64.c (elfNN_ia64_final_link): Set __gp if required
        and not user provided.
@
text
@a3155 7

      if (gp)
	{
	  gp->root.type = bfd_link_hash_defined;
	  gp->root.u.def.value = gp_val;
	  gp->root.u.def.section = bfd_abs_section_ptr;
	}
@


1.9.2.3
log
@Merge from mainline.
@
text
@d913 1
a913 1
  size_t len1, len2, len3;
d917 2
a918 4
  len3 = sizeof (ELF_STRING_ia64_unwind_once) - 1;
  return ((strncmp (name, ELF_STRING_ia64_unwind, len1) == 0
	   && strncmp (name, ELF_STRING_ia64_unwind_info, len2) != 0)
	  || strncmp (name, ELF_STRING_ia64_unwind_once, len3) == 0);
a1056 12
	  else if (sname
		   && (len = sizeof (ELF_STRING_ia64_unwind_once) - 1,
		       strncmp (sname, ELF_STRING_ia64_unwind_once, len)) == 0)
	    {
	      /* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.t.FOO */
	      size_t len2 = sizeof (".gnu.linkonce.t.") - 1;
	      char *once_name = alloca (len2 + strlen (sname) - len + 1);

	      memcpy (once_name, ".gnu.linkonce.t.", len2);
	      strcpy (once_name + len2, sname + len);
	      text_sect = bfd_get_section_by_name (abfd, once_name);
	    }
d1265 2
a1266 6
  switch (ELF_ST_VISIBILITY (h->other))
    {
    case STV_INTERNAL:
    case STV_HIDDEN:
      return false;
    }
d1405 1
a1405 2
  if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->root.dynindx = -1;
@


1.9.2.4
log
@        2001-08-23  Jakub Jelinek  <jakub@@redhat.com>
        * elfxx-ia64.c (elfNN_ia64_hash_table_create): Clear ia64_info.
@
text
@d1440 1
a1440 1
  ret = bfd_zalloc (abfd, sizeof (*ret));
@


1.8
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d1184 2
@


1.7
log
@2001-01-03  Kazu Hirata  <kazu@@hxi.com>

	* ecoffswap.h: Fix formatting.
	* elf-bfd.h: Likewise.
	* elfarm-nabi.c: Likewise.
	* elfarm-oabi.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-target.h: Likewise.
@
text
@a275 1

@


1.6
log
@Eliminate ia64 compiler warnings.  Fix ia64 gas testsuite again.
	*  elfxx-ia64.c (get_dyn_sym_info): Cast %p argument to void *.
	* config/tc-ia64.h (ia64_init): Add prototype.
	* gas/ia64/dv-imply.d, gas/ia64/dv-mutex.d, gas/ia64/dv-safe.d,
	gas/ia64/dv-srlz.d, gas/ia64/opc-m.d: Update.
	* ia64-dis.c (print_insn_ia64): Cast away const on ia64_free_opcode
	argument.
	* ia64_gen.c (insert_deplist): Cast sizeof result to int.
	(print_dependency_table): Print NULL if semantics field not set.
	(insert_opcode_dependencies): Mark cmp parameter as unused.
	(print_main_table): Use fprintf_vma to print long long fields.
	(main): Mark argv paramter as unused.  Convert to old style definition.
	* ia64-opc.c (ia64_find_dependency): Cast sizeof result to int.
	* ia64-asmtab.c: Regnerate.
@
text
@a27 1

d85 1
a85 1
  
d190 1
a190 1
	   boolean (*func)(struct elfNN_ia64_dyn_sym_info *, PTR),
d712 2
a713 2
	  else 
	    continue;	/* who knows. */
a1157 1

d1205 1
a1205 1
  memset (ht, 0, sizeof(*ht));
d1228 1
a1228 1
  memset (ret, 0, sizeof(*ret));
d1256 1
a1256 1
  memset (ret, 0, sizeof(*ret));
d1275 1
a1275 1
  /* Copy down any references that we may have already seen to the 
d1489 1
a1489 1
  
d1501 1
a1501 1
      len = sizeof(void*)*2 + 1 + sizeof(bfd_vma)*4 + 1 + 1;
d1513 1
a1513 1
    }    
d2048 1
a2048 1
      
d2505 1
a2505 1
					    sizeof(ElfNN_External_Rela)))
d2542 1
a2542 1
      /* Instruction relocations. */
d2687 1
a2687 1
	case 3: return bfd_reloc_notsupported; /* shouldn't happen... */
d2766 1
a2766 1
  BFD_ASSERT (sizeof(ElfNN_External_Rela) * srel->reloc_count
d3058 1
a3058 1
		 (unsigned long)(max_short_vma - min_short_vma));
d3619 1
a3619 1
		
d3874 1
a3874 1
		 easier on ld.so.  This is not what the rest of BFD set up. */
d3904 1
a3904 1
/* Function to keep IA-64 specific file flags. */
d4046 1
a4046 1
  
@


1.5
log
@Eliminate compiler warnings from IA-64 port.
	* coff-ia64.c (howto_table): Use EMPTY_HOWTO.
	(in_reloc_p): Add ATTRIBUTE_UNUSED to unused parameters.
	* cpu-ia64-opc.c (ins_rsvd, ext_rsvd, ins_const, ext_const): Likewise.
	(ins_imms_scaled): Initialize sign_bit at function entry.
	(elf64_ia64_operands): Add missing initializers.
	* elfxx-ia64.c (elfNN_ia64_reloc, elfNN_ia64_reloc_type_lookup,
	elfNN_ia64_info_to_howto, elfNN_ia64_fake_sections,
	elfNN_ia64_add_symbol_hook, elfNN_ia64_is_local_label_name,
	elfNN_ia64_local_hash_table_init, get_fptr, get_pltoff,
	elfNN_ia64_adjust_dynamic_symbol): Add ATTRIBUTE_UNUSED for unused
	parameters.
	(elfNN_ia64_info_to_howto): Initialize free_relocs, free_contents,
	and free_extsyms at function entry.
	(elfNN_add_symbol_hook): Add unsigned cast to bfd_get_gp_size result.
	(elfNN_ia64_create_dynamic_sections): Delete unused local h.
	(get_got): Delete unused local srel.
	(elfNN_ia64_check_relocs): Initialize dynrel_type when declared.
	(elfNN_ia64_relocate_section): Delete unused local dynindx.
@
text
@d1507 1
a1507 1
      sprintf (addr_name, "%p:%lx", abfd, ELFNN_R_SYM (rel->r_info));
@


1.4
log
@Fix DT_INIT ABI violation, it is an offset not a function pointer.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections): Don't create
	pltoff entries for DT_INIT and DT_FINI.
	(elfNN_ia64_final_link): Don't set DT_INIT/FINI entries.
	(elfNN_ia64_finish_dynamic_sections): Don't fill in DT_INIT/FINI
	entries.
@
text
@d286 1
a286 1
     bfd *abfd;
d288 2
a289 2
     asymbol *sym;
     PTR data;
d421 1
a421 1
     bfd *abfd;
d516 1
a516 1
     bfd *abfd;
d606 1
a606 1
  Elf_Internal_Rela *free_relocs;
d609 1
a609 1
  bfd_byte *free_contents;
d611 1
a611 1
  ElfNN_External_Sym *free_extsyms;
d639 1
a639 1
  free_relocs = NULL;
a658 1
  free_contents = NULL;
a673 1
  free_extsyms = NULL;
d965 1
a965 1
     bfd *abfd;
d1012 2
a1013 2
     const char **namep;
     flagword *flagsp;
d1019 1
a1019 1
      && sym->st_size <= bfd_get_gp_size (abfd))
d1165 1
a1165 1
     bfd *abfd;
d1204 1
a1204 1
     bfd *abfd;
a1433 1
  struct elf_link_hash_entry *h;
d1537 1
a1537 1
  asection *got, *srel;
d1570 1
a1570 1
     struct bfd_link_info *info;
d1607 1
a1607 1
     struct bfd_link_info *info;
d1758 1
a1758 1
      int dynrel_type;
d2245 1
a2245 1
     struct bfd_link_info *info;
a3613 2
	      long dynindx;

@


1.3
log
@        * elfxx-ia64.c (elfNN_ia64_check_relocs): Handle IPLT relocs.
        (allocate_dynrel_entries): Likewise.
        (elfNN_ia64_relocate_section): Likewise.  Set REL addends correctly.
        (set_pltoff_entry): Likewise.
        (ia64_howto_table): Remove R_IA64_SEGBASE, and R_IA64_EPLT[ML]SB
        (elfNN_ia64_reloc_type_lookup): Likewise.
        (elfNN_ia64_install_value): Likewise.
        (elfNN_ia64_relocate_section): Likewise.
        * reloc.c (BFD_RELOC_IA64_SEGBASE): Remove.
        (BFD_RELOC_IA64_EPLTMSB, BFD_RELOC_IA64_EPLTLSB): Remove.
@
text
@a2302 30
  /* DT_INIT and DT_FINI get function descriptors not raw code addresses.
     Force their symbols to have pltoff entries so we can use those.  */
  if (ia64_info->root.dynamic_sections_created)
    {
      struct elf_link_hash_entry *h;
      struct elfNN_ia64_dyn_sym_info *dyn_i;
 
      if (info->init_function
	  && (h = elf_link_hash_lookup (elf_hash_table (info), 
					info->init_function, false,
					false, false))
          && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
                                        | ELF_LINK_HASH_DEF_REGULAR)) != 0)
        {
	  dyn_i = get_dyn_sym_info (ia64_info, h, output_bfd, NULL, true);
	  dyn_i->want_pltoff = 1;
        }

      if (info->fini_function
	  && (h = elf_link_hash_lookup (elf_hash_table (info), 
					info->fini_function, false,
					false, false))
          && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
                                        | ELF_LINK_HASH_DEF_REGULAR)) != 0)
        {
	  dyn_i = get_dyn_sym_info (ia64_info, h, output_bfd, NULL, true);
	  dyn_i->want_pltoff = 1;
        }
    }

a3080 42
  /* Tricky bits.  DT_INIT and DT_FINI use a pltoff entry, which is
     normally initialized in finish_dynamic_sections.  Except that
     we need all non-plt pltoff entries to be initialized before
     finish_dynamic_symbols.  This because the array of relocations
     used for plt entries (aka DT_JMPREL) begins after all the 
     non-plt pltoff relocations.  If the order gets confused, we
     munge either the array or the array base.  */
  if (ia64_info->root.dynamic_sections_created)
    {
      struct elf_link_hash_entry *h;
      struct elfNN_ia64_dyn_sym_info *dyn_i;
      bfd_vma addr;
 
      if (info->init_function
	  && (h = elf_link_hash_lookup (elf_hash_table (info), 
					info->init_function, false,
					false, false))
          && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
                                        | ELF_LINK_HASH_DEF_REGULAR)) != 0)
        {
	  dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, false);
	  addr = (h->root.u.def.section->output_section->vma
		  + h->root.u.def.section->output_offset
		  + h->root.u.def.value);
	  (void) set_pltoff_entry (abfd, info, dyn_i, addr, false);
        }

      if (info->fini_function
	  && (h = elf_link_hash_lookup (elf_hash_table (info), 
					info->fini_function, false,
					false, false))
          && (h->elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
                                        | ELF_LINK_HASH_DEF_REGULAR)) != 0)
        {
	  dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, false);
	  addr = (h->root.u.def.section->output_section->vma
		  + h->root.u.def.section->output_offset
		  + h->root.u.def.value);
	  (void) set_pltoff_entry (abfd, info, dyn_i, addr, false);
        }
    }

a3884 19

	    case DT_INIT:
	    case DT_FINI:
	      {
		struct elf_link_hash_entry *h;
		struct elfNN_ia64_dyn_sym_info *dyn_i;
		const char *which;
 
		if (dyn.d_tag == DT_INIT)
		  which = info->init_function;
		else
		  which = info->fini_function;

		h = elf_link_hash_lookup (elf_hash_table (info), which,
					  false, false, false);
		dyn_i = get_dyn_sym_info (ia64_info, h, NULL, NULL, false);
		dyn.d_un.d_ptr = set_pltoff_entry (abfd, info, dyn_i,
						   dyn.d_un.d_ptr, 0);
	      }
@


1.2
log
@        * elf64-ia64.c (elf64_ia64_final_link): New local unwind_output_sec.
        Set it before bfd_elf64_bfd_final_link call.  Use it after the call.
        * section.c (bfd_set_section_contents): Call memcpy if
        section->contents set and location not equal to contents plus offset.
@
text
@a355 1
    IA64_HOWTO (R_IA64_SEGBASE,	    "SEGBASE",	   4, false, true),
a381 2
    IA64_HOWTO (R_IA64_EPLTMSB,	    "EPLTMSB",	   4, false, true),
    IA64_HOWTO (R_IA64_EPLTLSB,	    "EPLTLSB",	   4, false, true),
a475 1
    case BFD_RELOC_IA64_SEGBASE:	rtype = R_IA64_SEGBASE; break;
a497 2
    case BFD_RELOC_IA64_EPLTMSB:	rtype = R_IA64_EPLTMSB; break;
    case BFD_RELOC_IA64_EPLTLSB:	rtype = R_IA64_EPLTLSB; break;
d1861 8
d2189 2
d2208 10
d2219 1
a2219 1
      rent->srel->_raw_size += sizeof (ElfNN_External_Rela) * rent->count;
a2655 19

    case R_IA64_REL32MSB:
    case R_IA64_REL32LSB:
    case R_IA64_REL64MSB:
    case R_IA64_REL64LSB:

    case R_IA64_IPLTMSB:
    case R_IA64_IPLTLSB:
    case R_IA64_EPLTMSB:
    case R_IA64_EPLTLSB:
    case R_IA64_COPY:

    case R_IA64_SEGBASE:

    case R_IA64_TPREL22:
    case R_IA64_TPREL64MSB:
    case R_IA64_TPREL64LSB:
    case R_IA64_LTOFF_TP22:

d2935 2
d2939 1
a2939 2
      bfd_put_64 (abfd, _bfd_get_gp_value (abfd),
		  pltoff_sec->contents + dyn_i->pltoff_offset + 8);
d2954 1
a2954 1
					dyn_r_type, 0, 0);
d2958 1
a2958 1
					dyn_r_type, 0, 0);
d3365 1
d3373 5
a3377 1
		dynindx = h->dynindx;
d3409 1
d3414 1
a3414 1
					    dynindx, rel->r_addend);
d3683 20
a3702 1
	case R_IA64_SEGBASE:
d3704 14
a3717 4
	case R_IA64_REL32MSB:
	case R_IA64_REL32LSB:
	case R_IA64_REL64MSB:
	case R_IA64_REL64LSB:
d3719 8
a3726 5
	case R_IA64_IPLTMSB:
	case R_IA64_IPLTLSB:
	case R_IA64_EPLTMSB:
	case R_IA64_EPLTLSB:
	case R_IA64_COPY:
a3727 4
	case R_IA64_TPREL22:
	case R_IA64_TPREL64MSB:
	case R_IA64_TPREL64LSB:
	case R_IA64_LTOFF_TP22:
@


1.1
log
@ia64-hpux patches from Steve Ellcey.
	* archures.c: (bfd_mach_ia64_elf64, bfd_mach_ia64_elf32) Add defines
	to differentiate elf32 and elf64 on ia64.
	* bfd-in2.h: Regenerate.
	* config.bfd: Add target for "ia64*-*-hpux*".
	* configure.in: Add bfd_elf32_ia64_big_vec to selvecs switch.
	* configure: Regenerate.
	* cpu-ia64.c (bfd_ia64_elf32_arch) Add elf32 arch info structure.
	* targets.c: Add bfd_target bfd_elf32_ia64_big_vec.
	* Makefile.am: Make elf32-ia64.c and elf64-ia64.c derived objects
	from elfxx-ia64.c.  Add depenency rules for making elf32-ia64.lo.
	* Makefile.in: Regnerate.
	* elf64-ia64.c: Deleted
	* elfxx-ia64.c: New file, paramaterized version of elf64-ia64.c.
@
text
@d3001 2
a3156 4
  /* Invoke the regular ELF backend linker to do all the work.  */
  if (!bfd_elfNN_bfd_final_link (abfd, info))
    return false;

d3158 3
a3160 1
     of the .IA_64.unwind section.  */
d3166 4
a3169 7
	  bfd_size_type size = s->output_section->_raw_size;
	  char *contents = bfd_malloc (size);

	  if (contents == NULL)
	    return false;
	  if (! bfd_get_section_contents (abfd, s->output_section,
					  contents, (file_ptr) 0, size))
d3171 2
d3174 3
a3176 2
	  elfNN_ia64_unwind_entry_compare_bfd = abfd;
	  qsort (contents, size / 24, 24, elfNN_ia64_unwind_entry_compare);
d3178 10
a3187 4
	  if (! bfd_set_section_contents (abfd, s->output_section,
					  contents, (file_ptr) 0, size))
	    return false;
	}
a3893 2
	  const char *name;
	  asection *s;
@

