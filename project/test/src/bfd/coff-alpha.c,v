head	1.50;
access;
symbols
	sid-snapshot-20180601:1.50
	sid-snapshot-20180501:1.50
	sid-snapshot-20180401:1.50
	sid-snapshot-20180301:1.50
	sid-snapshot-20180201:1.50
	sid-snapshot-20180101:1.50
	sid-snapshot-20171201:1.50
	sid-snapshot-20171101:1.50
	sid-snapshot-20171001:1.50
	sid-snapshot-20170901:1.50
	sid-snapshot-20170801:1.50
	sid-snapshot-20170701:1.50
	sid-snapshot-20170601:1.50
	sid-snapshot-20170501:1.50
	sid-snapshot-20170401:1.50
	sid-snapshot-20170301:1.50
	sid-snapshot-20170201:1.50
	sid-snapshot-20170101:1.50
	sid-snapshot-20161201:1.50
	sid-snapshot-20161101:1.50
	sid-snapshot-20160901:1.50
	sid-snapshot-20160801:1.50
	sid-snapshot-20160701:1.50
	sid-snapshot-20160601:1.50
	sid-snapshot-20160501:1.50
	sid-snapshot-20160401:1.50
	sid-snapshot-20160301:1.50
	sid-snapshot-20160201:1.50
	sid-snapshot-20160101:1.50
	sid-snapshot-20151201:1.50
	sid-snapshot-20151101:1.50
	sid-snapshot-20151001:1.50
	sid-snapshot-20150901:1.50
	sid-snapshot-20150801:1.50
	sid-snapshot-20150701:1.50
	sid-snapshot-20150601:1.50
	sid-snapshot-20150501:1.50
	sid-snapshot-20150401:1.50
	sid-snapshot-20150301:1.50
	sid-snapshot-20150201:1.50
	sid-snapshot-20150101:1.50
	sid-snapshot-20141201:1.50
	sid-snapshot-20141101:1.50
	sid-snapshot-20141001:1.50
	sid-snapshot-20140901:1.50
	sid-snapshot-20140801:1.50
	sid-snapshot-20140701:1.50
	sid-snapshot-20140601:1.50
	sid-snapshot-20140501:1.50
	sid-snapshot-20140401:1.50
	sid-snapshot-20140301:1.50
	sid-snapshot-20140201:1.50
	sid-snapshot-20140101:1.50
	sid-snapshot-20131201:1.50
	sid-snapshot-20131101:1.50
	sid-snapshot-20131001:1.50
	binutils-2_24-branch:1.50.0.4
	binutils-2_24-branchpoint:1.50
	binutils-2_21_1:1.45
	sid-snapshot-20130901:1.50
	gdb_7_6_1-2013-08-30-release:1.50
	sid-snapshot-20130801:1.50
	sid-snapshot-20130701:1.50
	sid-snapshot-20130601:1.50
	sid-snapshot-20130501:1.50
	gdb_7_6-2013-04-26-release:1.50
	sid-snapshot-20130401:1.50
	binutils-2_23_2:1.49
	gdb_7_6-branch:1.50.0.2
	gdb_7_6-2013-03-12-branchpoint:1.50
	sid-snapshot-20130301:1.50
	sid-snapshot-20130201:1.50
	sid-snapshot-20130101:1.49
	sid-snapshot-20121201:1.49
	gdb_7_5_1-2012-11-29-release:1.49
	binutils-2_23_1:1.49
	sid-snapshot-20121101:1.49
	binutils-2_23:1.49
	sid-snapshot-20121001:1.49
	sid-snapshot-20120901:1.49
	gdb_7_5-2012-08-17-release:1.49
	sid-snapshot-20120801:1.49
	binutils-2_23-branch:1.49.0.4
	binutils-2_23-branchpoint:1.49
	gdb_7_5-branch:1.49.0.2
	gdb_7_5-2012-07-18-branchpoint:1.49
	sid-snapshot-20120701:1.48
	sid-snapshot-20120601:1.48
	sid-snapshot-20120501:1.48
	binutils-2_22_branch:1.48.0.6
	gdb_7_4_1-2012-04-26-release:1.48
	sid-snapshot-20120401:1.48
	sid-snapshot-20120301:1.48
	sid-snapshot-20120201:1.48
	gdb_7_4-2012-01-24-release:1.48
	sid-snapshot-20120101:1.48
	gdb_7_4-branch:1.48.0.4
	gdb_7_4-2011-12-13-branchpoint:1.48
	sid-snapshot-20111201:1.48
	binutils-2_22:1.48
	sid-snapshot-20111101:1.48
	sid-snapshot-20111001:1.48
	binutils-2_22-branch:1.48.0.2
	binutils-2_22-branchpoint:1.48
	gdb_7_3_1-2011-09-04-release:1.45
	sid-snapshot-20110901:1.48
	sid-snapshot-20110801:1.47
	gdb_7_3-2011-07-26-release:1.45
	sid-snapshot-20110701:1.46
	sid-snapshot-20110601:1.45
	sid-snapshot-20110501:1.45
	gdb_7_3-branch:1.45.0.6
	gdb_7_3-2011-04-01-branchpoint:1.45
	sid-snapshot-20110401:1.45
	sid-snapshot-20110301:1.45
	sid-snapshot-20110201:1.45
	sid-snapshot-20110101:1.45
	binutils-2_21:1.45
	sid-snapshot-20101201:1.45
	binutils-2_21-branch:1.45.0.4
	binutils-2_21-branchpoint:1.45
	sid-snapshot-20101101:1.45
	sid-snapshot-20101001:1.45
	binutils-2_20_1:1.40.6.1
	gdb_7_2-2010-09-02-release:1.45
	sid-snapshot-20100901:1.45
	sid-snapshot-20100801:1.45
	gdb_7_2-branch:1.45.0.2
	gdb_7_2-2010-07-07-branchpoint:1.45
	sid-snapshot-20100701:1.45
	sid-snapshot-20100601:1.45
	sid-snapshot-20100501:1.44
	sid-snapshot-20100401:1.44
	gdb_7_1-2010-03-18-release:1.43
	sid-snapshot-20100301:1.43
	gdb_7_1-branch:1.43.0.2
	gdb_7_1-2010-02-18-branchpoint:1.43
	sid-snapshot-20100201:1.43
	sid-snapshot-20100101:1.42
	gdb_7_0_1-2009-12-22-release:1.40
	sid-snapshot-20091201:1.41
	sid-snapshot-20091101:1.41
	binutils-2_20:1.40.6.1
	gdb_7_0-2009-10-06-release:1.40
	sid-snapshot-20091001:1.40
	gdb_7_0-branch:1.40.0.8
	gdb_7_0-2009-09-16-branchpoint:1.40
	arc-sim-20090309:1.37
	binutils-arc-20081103-branch:1.38.0.12
	binutils-arc-20081103-branchpoint:1.38
	binutils-2_20-branch:1.40.0.6
	binutils-2_20-branchpoint:1.40
	sid-snapshot-20090901:1.40
	sid-snapshot-20090801:1.40
	msnyder-checkpoint-072509-branch:1.40.0.4
	msnyder-checkpoint-072509-branchpoint:1.40
	sid-snapshot-20090701:1.40
	dje-cgen-play1-branch:1.40.0.2
	dje-cgen-play1-branchpoint:1.40
	sid-snapshot-20090601:1.40
	sid-snapshot-20090501:1.40
	sid-snapshot-20090401:1.39
	arc-20081103-branch:1.38.0.10
	arc-20081103-branchpoint:1.38
	arc-insight_6_8-branch:1.37.0.10
	arc-insight_6_8-branchpoint:1.37
	insight_6_8-branch:1.37.0.8
	insight_6_8-branchpoint:1.37
	sid-snapshot-20090301:1.39
	binutils-2_19_1:1.38
	sid-snapshot-20090201:1.38
	sid-snapshot-20090101:1.38
	reverse-20081226-branch:1.38.0.8
	reverse-20081226-branchpoint:1.38
	sid-snapshot-20081201:1.38
	multiprocess-20081120-branch:1.38.0.6
	multiprocess-20081120-branchpoint:1.38
	sid-snapshot-20081101:1.38
	binutils-2_19:1.38
	sid-snapshot-20081001:1.38
	reverse-20080930-branch:1.38.0.4
	reverse-20080930-branchpoint:1.38
	binutils-2_19-branch:1.38.0.2
	binutils-2_19-branchpoint:1.38
	sid-snapshot-20080901:1.38
	sid-snapshot-20080801:1.38
	reverse-20080717-branch:1.37.0.6
	reverse-20080717-branchpoint:1.37
	sid-snapshot-20080701:1.37
	msnyder-reverse-20080609-branch:1.37.0.4
	msnyder-reverse-20080609-branchpoint:1.37
	drow-reverse-20070409-branch:1.34.0.2
	drow-reverse-20070409-branchpoint:1.34
	sid-snapshot-20080601:1.37
	sid-snapshot-20080501:1.37
	sid-snapshot-20080403:1.37
	sid-snapshot-20080401:1.37
	gdb_6_8-2008-03-27-release:1.37
	sid-snapshot-20080301:1.37
	gdb_6_8-branch:1.37.0.2
	gdb_6_8-2008-02-26-branchpoint:1.37
	sid-snapshot-20080201:1.37
	sid-snapshot-20080101:1.36
	sid-snapshot-20071201:1.36
	sid-snapshot-20071101:1.36
	gdb_6_7_1-2007-10-29-release:1.36
	gdb_6_7-2007-10-10-release:1.36
	sid-snapshot-20071001:1.36
	gdb_6_7-branch:1.36.0.4
	gdb_6_7-2007-09-07-branchpoint:1.36
	binutils-2_18:1.36
	binutils-2_18-branch:1.36.0.2
	binutils-2_18-branchpoint:1.36
	insight_6_6-20070208-release:1.33
	binutils-csl-coldfire-4_1-32:1.33
	binutils-csl-sourcerygxx-4_1-32:1.33
	gdb_6_6-2006-12-18-release:1.33
	binutils-csl-innovasic-fido-3_4_4-33:1.33
	binutils-csl-sourcerygxx-3_4_4-32:1.28
	binutils-csl-coldfire-4_1-30:1.33
	binutils-csl-sourcerygxx-4_1-30:1.33
	binutils-csl-coldfire-4_1-28:1.33
	binutils-csl-sourcerygxx-4_1-29:1.33
	binutils-csl-sourcerygxx-4_1-28:1.33
	gdb_6_6-branch:1.33.0.30
	gdb_6_6-2006-11-15-branchpoint:1.33
	binutils-csl-arm-2006q3-27:1.33
	binutils-csl-sourcerygxx-4_1-27:1.33
	binutils-csl-arm-2006q3-26:1.33
	binutils-csl-sourcerygxx-4_1-26:1.33
	binutils-csl-sourcerygxx-4_1-25:1.33
	binutils-csl-sourcerygxx-4_1-24:1.33
	binutils-csl-sourcerygxx-4_1-23:1.33
	insight_6_5-20061003-release:1.33
	gdb-csl-symbian-6_4_50_20060226-12:1.33
	binutils-csl-sourcerygxx-4_1-21:1.33
	binutils-csl-arm-2006q3-21:1.33
	binutils-csl-sourcerygxx-4_1-22:1.33
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.33
	binutils-csl-sourcerygxx-4_1-20:1.33
	binutils-csl-arm-2006q3-19:1.33
	binutils-csl-sourcerygxx-4_1-19:1.33
	binutils-csl-sourcerygxx-4_1-18:1.33
	binutils-csl-renesas-4_1-9:1.33
	gdb-csl-sourcerygxx-3_4_4-25:1.33
	binutils-csl-sourcerygxx-3_4_4-25:1.28
	nickrob-async-20060828-mergepoint:1.33
	gdb-csl-symbian-6_4_50_20060226-11:1.33
	binutils-csl-renesas-4_1-8:1.33
	binutils-csl-renesas-4_1-7:1.33
	binutils-csl-renesas-4_1-6:1.33
	gdb-csl-sourcerygxx-4_1-17:1.33
	binutils-csl-sourcerygxx-4_1-17:1.33
	gdb-csl-20060226-branch-local-2:1.33
	gdb-csl-sourcerygxx-4_1-14:1.33
	binutils-csl-sourcerygxx-4_1-14:1.33
	binutils-csl-sourcerygxx-4_1-15:1.33
	gdb-csl-sourcerygxx-4_1-13:1.33
	binutils-csl-sourcerygxx-4_1-13:1.33
	binutils-2_17:1.33
	gdb-csl-sourcerygxx-4_1-12:1.33
	binutils-csl-sourcerygxx-4_1-12:1.33
	gdb-csl-sourcerygxx-3_4_4-21:1.33
	binutils-csl-sourcerygxx-3_4_4-21:1.33
	gdb_6_5-20060621-release:1.33
	binutils-csl-wrs-linux-3_4_4-24:1.28
	binutils-csl-wrs-linux-3_4_4-23:1.28
	gdb-csl-sourcerygxx-4_1-9:1.33
	binutils-csl-sourcerygxx-4_1-9:1.33
	gdb-csl-sourcerygxx-4_1-8:1.33
	binutils-csl-sourcerygxx-4_1-8:1.33
	gdb-csl-sourcerygxx-4_1-7:1.33
	binutils-csl-sourcerygxx-4_1-7:1.33
	gdb-csl-arm-2006q1-6:1.33
	binutils-csl-arm-2006q1-6:1.33
	gdb-csl-sourcerygxx-4_1-6:1.33
	binutils-csl-sourcerygxx-4_1-6:1.33
	binutils-csl-wrs-linux-3_4_4-22:1.28
	gdb-csl-symbian-6_4_50_20060226-10:1.33
	gdb-csl-symbian-6_4_50_20060226-9:1.33
	gdb-csl-symbian-6_4_50_20060226-8:1.33
	gdb-csl-coldfire-4_1-11:1.33
	binutils-csl-coldfire-4_1-11:1.33
	gdb-csl-sourcerygxx-3_4_4-19:1.33
	binutils-csl-sourcerygxx-3_4_4-19:1.33
	gdb-csl-coldfire-4_1-10:1.33
	gdb_6_5-branch:1.33.0.28
	gdb_6_5-2006-05-14-branchpoint:1.33
	binutils-csl-coldfire-4_1-10:1.33
	gdb-csl-sourcerygxx-4_1-5:1.33
	binutils-csl-sourcerygxx-4_1-5:1.33
	nickrob-async-20060513-branch:1.33.0.26
	nickrob-async-20060513-branchpoint:1.33
	gdb-csl-sourcerygxx-4_1-4:1.33
	binutils-csl-sourcerygxx-4_1-4:1.33
	msnyder-reverse-20060502-branch:1.33.0.24
	msnyder-reverse-20060502-branchpoint:1.33
	binutils-csl-wrs-linux-3_4_4-21:1.28
	gdb-csl-morpho-4_1-4:1.33
	binutils-csl-morpho-4_1-4:1.33
	gdb-csl-sourcerygxx-3_4_4-17:1.33
	binutils-csl-sourcerygxx-3_4_4-17:1.33
	binutils-csl-wrs-linux-3_4_4-20:1.28
	readline_5_1-import-branch:1.33.0.22
	readline_5_1-import-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.33
	binutils-2_17-branch:1.33.0.20
	binutils-2_17-branchpoint:1.33
	gdb-csl-symbian-20060226-branch:1.33.0.18
	gdb-csl-symbian-20060226-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.33
	msnyder-reverse-20060331-branch:1.33.0.16
	msnyder-reverse-20060331-branchpoint:1.33
	binutils-csl-2_17-branch:1.33.0.14
	binutils-csl-2_17-branchpoint:1.33
	gdb-csl-available-20060303-branch:1.33.0.12
	gdb-csl-available-20060303-branchpoint:1.33
	gdb-csl-20060226-branch:1.33.0.10
	gdb-csl-20060226-branchpoint:1.33
	gdb_6_4-20051202-release:1.33
	msnyder-fork-checkpoint-branch:1.33.0.8
	msnyder-fork-checkpoint-branchpoint:1.33
	gdb-csl-gxxpro-6_3-branch:1.33.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.33
	gdb_6_4-branch:1.33.0.4
	gdb_6_4-2005-11-01-branchpoint:1.33
	gdb-csl-arm-20051020-branch:1.33.0.2
	gdb-csl-arm-20051020-branchpoint:1.33
	binutils-csl-gxxpro-3_4-branch:1.28.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.28
	binutils-2_16_1:1.28
	msnyder-tracepoint-checkpoint-branch:1.30.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.30
	gdb-csl-arm-20050325-2005-q1b:1.28
	binutils-csl-arm-2005q1b:1.28
	binutils-2_16:1.28
	gdb-csl-arm-20050325-2005-q1a:1.28
	binutils-csl-arm-2005q1a:1.28
	csl-arm-20050325-branch:1.28.0.6
	csl-arm-20050325-branchpoint:1.28
	binutils-csl-arm-2005q1-branch:1.28.0.4
	binutils-csl-arm-2005q1-branchpoint:1.28
	binutils-2_16-branch:1.28.0.2
	binutils-2_16-branchpoint:1.28
	csl-arm-2004-q3d:1.25
	gdb_6_3-20041109-release:1.24
	gdb_6_3-branch:1.24.0.2
	gdb_6_3-20041019-branchpoint:1.24
	csl-arm-2004-q3:1.24
	drow_intercu-merge-20040921:1.24
	drow_intercu-merge-20040915:1.24
	jimb-gdb_6_2-e500-branch:1.23.0.6
	jimb-gdb_6_2-e500-branchpoint:1.23
	gdb_6_2-20040730-release:1.23
	gdb_6_2-branch:1.23.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.23
	gdb_6_1_1-20040616-release:1.19
	binutils-2_15:1.19
	binutils-2_15-branchpoint:1.19
	csl-arm-2004-q1a:1.20
	csl-arm-2004-q1:1.19
	gdb_6_1-2004-04-05-release:1.19
	drow_intercu-merge-20040402:1.19
	drow_intercu-merge-20040327:1.19
	ezannoni_pie-20040323-branch:1.19.0.20
	ezannoni_pie-20040323-branchpoint:1.19
	cagney_tramp-20040321-mergepoint:1.19
	cagney_tramp-20040309-branch:1.19.0.18
	cagney_tramp-20040309-branchpoint:1.19
	gdb_6_1-branch:1.19.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.19
	drow_intercu-20040221-branch:1.19.0.14
	drow_intercu-20040221-branchpoint:1.19
	binutils-2_15-branch:1.19.0.12
	cagney_bfdfile-20040213-branch:1.19.0.10
	cagney_bfdfile-20040213-branchpoint:1.19
	drow-cplus-merge-20040208:1.19
	carlton_dictionary-20040126-merge:1.19
	cagney_bigcore-20040122-branch:1.19.0.8
	cagney_bigcore-20040122-branchpoint:1.19
	drow-cplus-merge-20040113:1.19
	csl-arm-2003-q4:1.19
	drow-cplus-merge-20031224:1.19
	drow-cplus-merge-20031220:1.19
	carlton_dictionary-20031215-merge:1.19
	drow-cplus-merge-20031214:1.19
	carlton-dictionary-20031111-merge:1.19
	gdb_6_0-2003-10-04-release:1.18
	kettenis_sparc-20030918-branch:1.19.0.6
	kettenis_sparc-20030918-branchpoint:1.19
	carlton_dictionary-20030917-merge:1.19
	ezannoni_pie-20030916-branchpoint:1.19
	ezannoni_pie-20030916-branch:1.19.0.4
	cagney_x86i386-20030821-branch:1.19.0.2
	cagney_x86i386-20030821-branchpoint:1.19
	carlton_dictionary-20030805-merge:1.19
	carlton_dictionary-20030627-merge:1.19
	gdb_6_0-branch:1.18.0.36
	gdb_6_0-2003-06-23-branchpoint:1.18
	jimb-ppc64-linux-20030613-branch:1.18.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.18
	binutils-2_14:1.18
	cagney_convert-20030606-branch:1.18.0.32
	cagney_convert-20030606-branchpoint:1.18
	cagney_writestrings-20030508-branch:1.18.0.30
	cagney_writestrings-20030508-branchpoint:1.18
	jimb-ppc64-linux-20030528-branch:1.18.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.18
	carlton_dictionary-20030523-merge:1.18
	cagney_fileio-20030521-branch:1.18.0.26
	cagney_fileio-20030521-branchpoint:1.18
	kettenis_i386newframe-20030517-mergepoint:1.18
	jimb-ppc64-linux-20030509-branch:1.18.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.18
	kettenis_i386newframe-20030504-mergepoint:1.18
	carlton_dictionary-20030430-merge:1.18
	binutils-2_14-branch:1.18.0.22
	binutils-2_14-branchpoint:1.18
	kettenis_i386newframe-20030419-branch:1.18.0.20
	kettenis_i386newframe-20030419-branchpoint:1.18
	carlton_dictionary-20030416-merge:1.18
	cagney_frameaddr-20030409-mergepoint:1.18
	kettenis_i386newframe-20030406-branch:1.18.0.18
	kettenis_i386newframe-20030406-branchpoint:1.18
	cagney_frameaddr-20030403-branchpoint:1.18
	cagney_frameaddr-20030403-branch:1.18.0.16
	cagney_framebase-20030330-mergepoint:1.18
	cagney_framebase-20030326-branch:1.18.0.14
	cagney_framebase-20030326-branchpoint:1.18
	cagney_lazyid-20030317-branch:1.18.0.12
	cagney_lazyid-20030317-branchpoint:1.18
	kettenis-i386newframe-20030316-mergepoint:1.18
	offbyone-20030313-branch:1.18.0.10
	offbyone-20030313-branchpoint:1.18
	kettenis-i386newframe-20030308-branch:1.18.0.8
	kettenis-i386newframe-20030308-branchpoint:1.18
	carlton_dictionary-20030305-merge:1.18
	cagney_offbyone-20030303-branch:1.18.0.6
	cagney_offbyone-20030303-branchpoint:1.18
	carlton_dictionary-20030207-merge:1.18
	interps-20030202-branch:1.18.0.4
	interps-20030202-branchpoint:1.18
	cagney-unwind-20030108-branch:1.18.0.2
	cagney-unwind-20030108-branchpoint:1.18
	binutils-2_13_2_1:1.17
	binutils-2_13_2:1.17
	carlton_dictionary-20021223-merge:1.18
	gdb_5_3-2002-12-12-release:1.17
	carlton_dictionary-20021115-merge:1.17
	binutils-2_13_1:1.17
	kseitz_interps-20021105-merge:1.17
	kseitz_interps-20021103-merge:1.17
	drow-cplus-merge-20021020:1.17
	drow-cplus-merge-20021025:1.17
	carlton_dictionary-20021025-merge:1.17
	carlton_dictionary-20021011-merge:1.17
	drow-cplus-branch:1.17.0.14
	drow-cplus-branchpoint:1.17
	kseitz_interps-20020930-merge:1.17
	carlton_dictionary-20020927-merge:1.17
	carlton_dictionary-branch:1.17.0.12
	carlton_dictionary-20020920-branchpoint:1.17
	sid-20020905-branchpoint:1.17
	sid-20020905-branch:1.17.0.10
	gdb_5_3-branch:1.17.0.8
	gdb_5_3-2002-09-04-branchpoint:1.17
	kseitz_interps-20020829-merge:1.17
	cagney_sysregs-20020825-branch:1.17.0.6
	cagney_sysregs-20020825-branchpoint:1.17
	readline_4_3-import-branch:1.17.0.4
	readline_4_3-import-branchpoint:1.17
	binutils-2_13:1.17
	gdb_5_2_1-2002-07-23-release:1.14
	binutils-2_13-branchpoint:1.17
	binutils-2_13-branch:1.17.0.2
	kseitz_interps-20020528-branch:1.14.0.10
	kseitz_interps-20020528-branchpoint:1.14
	cagney_regbuf-20020515-branch:1.14.0.8
	cagney_regbuf-20020515-branchpoint:1.14
	binutils-2_12_1:1.14
	jimb-macro-020506-branch:1.14.0.6
	jimb-macro-020506-branchpoint:1.14
	gdb_5_2-2002-04-29-release:1.14
	binutils-2_12:1.14
	gdb_5_2-branch:1.14.0.4
	gdb_5_2-2002-03-03-branchpoint:1.14
	binutils-2_12-branch:1.14.0.2
	binutils-2_12-branchpoint:1.14
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.4
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.2
	gdb_5_1-2001-07-29-branchpoint:1.11
	binutils-2_11_2:1.8.2.2
	binutils-2_11_1:1.8.2.2
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	insight-precleanup-2001-01-01:1.8
	binutils-2_10_1:1.6
	binutils-2_10:1.6
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb_5_0-2000-05-19-release:1.6
	gdb_4_18_2-2000-05-18-release:1.6
	gdb_4_95_1-2000-05-11-snapshot:1.6
	gdb_4_95_0-2000-04-27-snapshot:1.6
	gdb_5_0-2000-04-10-branch:1.6.0.4
	gdb_5_0-2000-04-10-branchpoint:1.6
	binutils-2_10-branch:1.6.0.2
	binutils-2_10-branchpoint:1.6
	binutils_latest_snapshot:1.50
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.49;

1.49
date	2012.07.13.14.22.42;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2011.08.17.00.39.38;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.11.15.03.04;	author clm;	state Exp;
branches;
next	1.46;

1.46
date	2011.06.06.01.26.01;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.26.07.37.36;	author gingold;	state Exp;
branches;
next	1.44;

1.44
date	2010.03.24.15.41.58;	author hjl;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.26.13.42.26;	author gingold;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.11.13.42.00;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.16.07.14.43;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2009.04.16.23.06.58;	author rsandifo;	state Exp;
branches
	1.40.6.1;
next	1.39;

1.39
date	2009.02.18.18.23.06;	author davek;	state Exp;
branches;
next	1.38;

1.38
date	2008.07.18.11.30.22;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2008.01.21.03.48.10;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.26.12.22.59;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.14.07.48.28;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.14.07.07.44;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.06.10.35.41;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.04.15.53.01;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.03.11.40.56;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.11.15.57.10;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.31.23.13.15;	author bje;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.21.15.28.15;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.24.04.46.15;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.15.01.24.22;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.11.14.19.32;	author macro;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.30.14.23.39;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.25.06.40.18;	author amodra;	state Exp;
branches
	1.19.14.1;
next	1.18;

1.18
date	2002.11.30.08.39.35;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.25.06.21.47;	author amodra;	state Exp;
branches
	1.17.12.1
	1.17.14.1;
next	1.16;

1.16
date	2002.06.05.04.22.27;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.05.03.43.09;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.25.12.12.23;	author amodra;	state Exp;
branches
	1.14.8.1
	1.14.10.1;
next	1.13;

1.13
date	2001.09.18.09.57.21;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.17.08.57.42;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.11.12.23.47;	author jakub;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.03.05.08.17;	author aj;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.09.01.37.44;	author kazu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.04.28.13.17.26;	author cpopetz;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	99.12.10.18.51.34;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	99.12.10.01.41.21;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.09.10.23.25.50;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.19.14.55.15;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.40.6.1
date	2009.10.16.10.02.44;	author gingold;	state Exp;
branches;
next	;

1.19.14.1
date	2004.09.16.17.00.13;	author drow;	state Exp;
branches;
next	;

1.17.12.1
date	2002.12.23.19.37.25;	author carlton;	state Exp;
branches;
next	1.17.12.2;

1.17.12.2
date	2003.06.27.21.49.06;	author carlton;	state Exp;
branches;
next	;

1.17.14.1
date	2003.12.14.20.26.34;	author drow;	state Exp;
branches;
next	;

1.14.8.1
date	2002.06.15.16.42.34;	author cagney;	state Exp;
branches;
next	;

1.14.10.1
date	2002.06.20.01.29.43;	author kseitz;	state Exp;
branches;
next	1.14.10.2;

1.14.10.2
date	2002.07.22.21.46.38;	author kseitz;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.06.11.10.03.59;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* BFD back-end for ALPHA Extended-Coff files.
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
   Modified from coff-mips.c by Steve Chamberlain <sac@@cygnus.com> and
   Ian Lance Taylor <ian@@cygnus.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/ecoff.h"
#include "coff/alpha.h"
#include "aout/ar.h"
#include "libcoff.h"
#include "libecoff.h"

/* Prototypes for static functions.  */



/* ECOFF has COFF sections, but the debugging information is stored in
   a completely different format.  ECOFF targets use some of the
   swapping routines from coffswap.h, and some of the generic COFF
   routines in coffgen.c, but, unlike the real COFF targets, do not
   use coffcode.h itself.

   Get the generic COFF swapping routines, except for the reloc,
   symbol, and lineno ones.  Give them ecoff names.  Define some
   accessor macros for the large sizes used for Alpha ECOFF.  */

#define GET_FILEHDR_SYMPTR H_GET_64
#define PUT_FILEHDR_SYMPTR H_PUT_64
#define GET_AOUTHDR_TSIZE H_GET_64
#define PUT_AOUTHDR_TSIZE H_PUT_64
#define GET_AOUTHDR_DSIZE H_GET_64
#define PUT_AOUTHDR_DSIZE H_PUT_64
#define GET_AOUTHDR_BSIZE H_GET_64
#define PUT_AOUTHDR_BSIZE H_PUT_64
#define GET_AOUTHDR_ENTRY H_GET_64
#define PUT_AOUTHDR_ENTRY H_PUT_64
#define GET_AOUTHDR_TEXT_START H_GET_64
#define PUT_AOUTHDR_TEXT_START H_PUT_64
#define GET_AOUTHDR_DATA_START H_GET_64
#define PUT_AOUTHDR_DATA_START H_PUT_64
#define GET_SCNHDR_PADDR H_GET_64
#define PUT_SCNHDR_PADDR H_PUT_64
#define GET_SCNHDR_VADDR H_GET_64
#define PUT_SCNHDR_VADDR H_PUT_64
#define GET_SCNHDR_SIZE H_GET_64
#define PUT_SCNHDR_SIZE H_PUT_64
#define GET_SCNHDR_SCNPTR H_GET_64
#define PUT_SCNHDR_SCNPTR H_PUT_64
#define GET_SCNHDR_RELPTR H_GET_64
#define PUT_SCNHDR_RELPTR H_PUT_64
#define GET_SCNHDR_LNNOPTR H_GET_64
#define PUT_SCNHDR_LNNOPTR H_PUT_64

#define ALPHAECOFF

#define NO_COFF_RELOCS
#define NO_COFF_SYMBOLS
#define NO_COFF_LINENOS
#define coff_swap_filehdr_in alpha_ecoff_swap_filehdr_in
#define coff_swap_filehdr_out alpha_ecoff_swap_filehdr_out
#define coff_swap_aouthdr_in alpha_ecoff_swap_aouthdr_in
#define coff_swap_aouthdr_out alpha_ecoff_swap_aouthdr_out
#define coff_swap_scnhdr_in alpha_ecoff_swap_scnhdr_in
#define coff_swap_scnhdr_out alpha_ecoff_swap_scnhdr_out
#include "coffswap.h"

/* Get the ECOFF swapping routines.  */
#define ECOFF_64
#include "ecoffswap.h"

/* How to process the various reloc types.  */

static bfd_reloc_status_type
reloc_nil (bfd *abfd ATTRIBUTE_UNUSED,
	   arelent *reloc ATTRIBUTE_UNUSED,
	   asymbol *sym ATTRIBUTE_UNUSED,
	   void * data ATTRIBUTE_UNUSED,
	   asection *sec ATTRIBUTE_UNUSED,
	   bfd *output_bfd ATTRIBUTE_UNUSED,
	   char **error_message ATTRIBUTE_UNUSED)
{
  return bfd_reloc_ok;
}

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)

static reloc_howto_type alpha_howto_table[] =
{
  /* Reloc type 0 is ignored by itself.  However, it appears after a
     GPDISP reloc to identify the location where the low order 16 bits
     of the gp register are loaded.  */
  HOWTO (ALPHA_R_IGNORE,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "IGNORE",		/* name */
	 TRUE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 32 bit reference to a symbol.  */
  HOWTO (ALPHA_R_REFLONG,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "REFLONG",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 64 bit reference to a symbol.  */
  HOWTO (ALPHA_R_REFQUAD,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "REFQUAD",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit GP relative offset.  This is just like REFLONG except
     that when the value is used the value of the gp register will be
     added in.  */
  HOWTO (ALPHA_R_GPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,			/* special_function */
	 "GPREL32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used for an instruction that refers to memory off the GP
     register.  The offset is 16 bits of the 32 bit instruction.  This
     reloc always seems to be against the .lita section.  */
  HOWTO (ALPHA_R_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "LITERAL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* This reloc only appears immediately following a LITERAL reloc.
     It identifies a use of the literal.  It seems that the linker can
     use this to eliminate a portion of the .lita section.  The symbol
     index is special: 1 means the literal address is in the base
     register of a memory format instruction; 2 means the literal
     address is in the byte offset register of a byte-manipulation
     instruction; 3 means the literal address is in the target
     register of a jsr instruction.  This does not actually do any
     relocation.  */
  HOWTO (ALPHA_R_LITUSE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "LITUSE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Load the gp register.  This is always used for a ldah instruction
     which loads the upper 16 bits of the gp register.  The next reloc
     will be an IGNORE reloc which identifies the location of the lda
     instruction which loads the lower 16 bits.  The symbol index of
     the GPDISP instruction appears to actually be the number of bytes
     between the ldah and lda instructions.  This gives two different
     ways to determine where the lda instruction is; I don't know why
     both are used.  The value to use for the relocation is the
     difference between the GP value and the current location; the
     load will always be done against a register holding the current
     address.  */
  HOWTO (ALPHA_R_GPDISP,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 reloc_nil,		/* special_function */
	 "GPDISP",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 21 bit branch.  The native assembler generates these for
     branches within the text segment, and also fills in the PC
     relative offset in the instruction.  */
  HOWTO (ALPHA_R_BRADDR,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 21,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "BRADDR",		/* name */
	 TRUE,			/* partial_inplace */
	 0x1fffff,		/* src_mask */
	 0x1fffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A hint for a jump to a register.  */
  HOWTO (ALPHA_R_HINT,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 14,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "HINT",		/* name */
	 TRUE,			/* partial_inplace */
	 0x3fff,		/* src_mask */
	 0x3fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit PC relative offset.  */
  HOWTO (ALPHA_R_SREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "SREL16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit PC relative offset.  */
  HOWTO (ALPHA_R_SREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "SREL32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 64 bit PC relative offset.  */
  HOWTO (ALPHA_R_SREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "SREL64",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Push a value on the reloc evaluation stack.  */
  HOWTO (ALPHA_R_OP_PUSH,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "OP_PUSH",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Store the value from the stack at the given address.  Store it in
     a bitfield of size r_size starting at bit position r_offset.  */
  HOWTO (ALPHA_R_OP_STORE,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "OP_STORE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Subtract the reloc address from the value on the top of the
     relocation stack.  */
  HOWTO (ALPHA_R_OP_PSUB,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "OP_PSUB",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Shift the value on the top of the relocation stack right by the
     given value.  */
  HOWTO (ALPHA_R_OP_PRSHIFT,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "OP_PRSHIFT",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Adjust the GP value for a new range in the object file.  */
  HOWTO (ALPHA_R_GPVALUE,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "GPVALUE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE)			/* pcrel_offset */
};

/* Recognize an Alpha ECOFF file.  */

static const bfd_target *
alpha_ecoff_object_p (bfd *abfd)
{
  static const bfd_target *ret;

  ret = coff_object_p (abfd);

  if (ret != NULL)
    {
      asection *sec;

      /* Alpha ECOFF has a .pdata section.  The lnnoptr field of the
	 .pdata section is the number of entries it contains.  Each
	 entry takes up 8 bytes.  The number of entries is required
	 since the section is aligned to a 16 byte boundary.  When we
	 link .pdata sections together, we do not want to include the
	 alignment bytes.  We handle this on input by faking the size
	 of the .pdata section to remove the unwanted alignment bytes.
	 On output we will set the lnnoptr field and force the
	 alignment.  */
      sec = bfd_get_section_by_name (abfd, _PDATA);
      if (sec != (asection *) NULL)
	{
	  bfd_size_type size;

	  size = sec->line_filepos * 8;
	  BFD_ASSERT (size == sec->size
		      || size + 8 == sec->size);
	  if (! bfd_set_section_size (abfd, sec, size))
	    return NULL;
	}
    }

  return ret;
}

/* See whether the magic number matches.  */

static bfd_boolean
alpha_ecoff_bad_format_hook (bfd *abfd ATTRIBUTE_UNUSED,
			     void * filehdr)
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

  if (! ALPHA_ECOFF_BADMAG (*internal_f))
    return TRUE;

  if (ALPHA_ECOFF_COMPRESSEDMAG (*internal_f))
    (*_bfd_error_handler)
      (_("%B: Cannot handle compressed Alpha binaries.\n"
	 "   Use compiler flags, or objZ, to generate uncompressed binaries."),
       abfd);

  return FALSE;
}

/* This is a hook called by coff_real_object_p to create any backend
   specific information.  */

static void *
alpha_ecoff_mkobject_hook (bfd *abfd, void * filehdr, void * aouthdr)
{
  void * ecoff;

  ecoff = _bfd_ecoff_mkobject_hook (abfd, filehdr, aouthdr);

  if (ecoff != NULL)
    {
      struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

      /* Set additional BFD flags according to the object type from the
	 machine specific file header flags.  */
      switch (internal_f->f_flags & F_ALPHA_OBJECT_TYPE_MASK)
	{
	case F_ALPHA_SHARABLE:
	  abfd->flags |= DYNAMIC;
	  break;
	case F_ALPHA_CALL_SHARED:
	  /* Always executable if using shared libraries as the run time
	     loader might resolve undefined references.  */
	  abfd->flags |= (DYNAMIC | EXEC_P);
	  break;
	}
    }
  return ecoff;
}

/* Reloc handling.  */

/* Swap a reloc in.  */

static void
alpha_ecoff_swap_reloc_in (bfd *abfd,
			   void * ext_ptr,
			   struct internal_reloc *intern)
{
  const RELOC *ext = (RELOC *) ext_ptr;

  intern->r_vaddr = H_GET_64 (abfd, ext->r_vaddr);
  intern->r_symndx = H_GET_32 (abfd, ext->r_symndx);

  BFD_ASSERT (bfd_header_little_endian (abfd));

  intern->r_type = ((ext->r_bits[0] & RELOC_BITS0_TYPE_LITTLE)
		    >> RELOC_BITS0_TYPE_SH_LITTLE);
  intern->r_extern = (ext->r_bits[1] & RELOC_BITS1_EXTERN_LITTLE) != 0;
  intern->r_offset = ((ext->r_bits[1] & RELOC_BITS1_OFFSET_LITTLE)
		      >> RELOC_BITS1_OFFSET_SH_LITTLE);
  /* Ignored the reserved bits.  */
  intern->r_size = ((ext->r_bits[3] & RELOC_BITS3_SIZE_LITTLE)
		    >> RELOC_BITS3_SIZE_SH_LITTLE);

  if (intern->r_type == ALPHA_R_LITUSE
      || intern->r_type == ALPHA_R_GPDISP)
    {
      /* Handle the LITUSE and GPDISP relocs specially.  Its symndx
	 value is not actually a symbol index, but is instead a
	 special code.  We put the code in the r_size field, and
	 clobber the symndx.  */
      if (intern->r_size != 0)
	abort ();
      intern->r_size = intern->r_symndx;
      intern->r_symndx = RELOC_SECTION_NONE;
    }
  else if (intern->r_type == ALPHA_R_IGNORE)
    {
      /* The IGNORE reloc generally follows a GPDISP reloc, and is
	 against the .lita section.  The section is irrelevant.  */
      if (! intern->r_extern &&
	  intern->r_symndx == RELOC_SECTION_ABS)
	abort ();
      if (! intern->r_extern && intern->r_symndx == RELOC_SECTION_LITA)
	intern->r_symndx = RELOC_SECTION_ABS;
    }
}

/* Swap a reloc out.  */

static void
alpha_ecoff_swap_reloc_out (bfd *abfd,
			    const struct internal_reloc *intern,
			    void * dst)
{
  RELOC *ext = (RELOC *) dst;
  long symndx;
  unsigned char size;

  /* Undo the hackery done in swap_reloc_in.  */
  if (intern->r_type == ALPHA_R_LITUSE
      || intern->r_type == ALPHA_R_GPDISP)
    {
      symndx = intern->r_size;
      size = 0;
    }
  else if (intern->r_type == ALPHA_R_IGNORE
	   && ! intern->r_extern
	   && intern->r_symndx == RELOC_SECTION_ABS)
    {
      symndx = RELOC_SECTION_LITA;
      size = intern->r_size;
    }
  else
    {
      symndx = intern->r_symndx;
      size = intern->r_size;
    }

  /* XXX FIXME:  The maximum symndx value used to be 14 but this
     fails with object files produced by DEC's C++ compiler.
     Where does the value 14 (or 15) come from anyway ?  */
  BFD_ASSERT (intern->r_extern
	      || (intern->r_symndx >= 0 && intern->r_symndx <= 15));

  H_PUT_64 (abfd, intern->r_vaddr, ext->r_vaddr);
  H_PUT_32 (abfd, symndx, ext->r_symndx);

  BFD_ASSERT (bfd_header_little_endian (abfd));

  ext->r_bits[0] = ((intern->r_type << RELOC_BITS0_TYPE_SH_LITTLE)
		    & RELOC_BITS0_TYPE_LITTLE);
  ext->r_bits[1] = ((intern->r_extern ? RELOC_BITS1_EXTERN_LITTLE : 0)
		    | ((intern->r_offset << RELOC_BITS1_OFFSET_SH_LITTLE)
		       & RELOC_BITS1_OFFSET_LITTLE));
  ext->r_bits[2] = 0;
  ext->r_bits[3] = ((size << RELOC_BITS3_SIZE_SH_LITTLE)
		    & RELOC_BITS3_SIZE_LITTLE);
}

/* Finish canonicalizing a reloc.  Part of this is generic to all
   ECOFF targets, and that part is in ecoff.c.  The rest is done in
   this backend routine.  It must fill in the howto field.  */

static void
alpha_adjust_reloc_in (bfd *abfd,
		       const struct internal_reloc *intern,
		       arelent *rptr)
{
  if (intern->r_type > ALPHA_R_GPVALUE)
    {
      (*_bfd_error_handler)
	(_("%B: unknown/unsupported relocation type %d"),
	 abfd, intern->r_type);
      bfd_set_error (bfd_error_bad_value);
      rptr->addend = 0;
      rptr->howto  = NULL;
      return;
    }

  switch (intern->r_type)
    {
    case ALPHA_R_BRADDR:
    case ALPHA_R_SREL16:
    case ALPHA_R_SREL32:
    case ALPHA_R_SREL64:
      /* This relocs appear to be fully resolved when they are against
         internal symbols.  Against external symbols, BRADDR at least
         appears to be resolved against the next instruction.  */
      if (! intern->r_extern)
	rptr->addend = 0;
      else
	rptr->addend = - (intern->r_vaddr + 4);
      break;

    case ALPHA_R_GPREL32:
    case ALPHA_R_LITERAL:
      /* Copy the gp value for this object file into the addend, to
	 ensure that we are not confused by the linker.  */
      if (! intern->r_extern)
	rptr->addend += ecoff_data (abfd)->gp;
      break;

    case ALPHA_R_LITUSE:
    case ALPHA_R_GPDISP:
      /* The LITUSE and GPDISP relocs do not use a symbol, or an
	 addend, but they do use a special code.  Put this code in the
	 addend field.  */
      rptr->addend = intern->r_size;
      break;

    case ALPHA_R_OP_STORE:
      /* The STORE reloc needs the size and offset fields.  We store
	 them in the addend.  */
      BFD_ASSERT (intern->r_offset <= 256);
      rptr->addend = (intern->r_offset << 8) + intern->r_size;
      break;

    case ALPHA_R_OP_PUSH:
    case ALPHA_R_OP_PSUB:
    case ALPHA_R_OP_PRSHIFT:
      /* The PUSH, PSUB and PRSHIFT relocs do not actually use an
	 address.  I believe that the address supplied is really an
	 addend.  */
      rptr->addend = intern->r_vaddr;
      break;

    case ALPHA_R_GPVALUE:
      /* Set the addend field to the new GP value.  */
      rptr->addend = intern->r_symndx + ecoff_data (abfd)->gp;
      break;

    case ALPHA_R_IGNORE:
      /* If the type is ALPHA_R_IGNORE, make sure this is a reference
	 to the absolute section so that the reloc is ignored.  For
	 some reason the address of this reloc type is not adjusted by
	 the section vma.  We record the gp value for this object file
	 here, for convenience when doing the GPDISP relocation.  */
      rptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
      rptr->address = intern->r_vaddr;
      rptr->addend = ecoff_data (abfd)->gp;
      break;

    default:
      break;
    }

  rptr->howto = &alpha_howto_table[intern->r_type];
}

/* When writing out a reloc we need to pull some values back out of
   the addend field into the reloc.  This is roughly the reverse of
   alpha_adjust_reloc_in, except that there are several changes we do
   not need to undo.  */

static void
alpha_adjust_reloc_out (bfd *abfd ATTRIBUTE_UNUSED,
			const arelent *rel,
			struct internal_reloc *intern)
{
  switch (intern->r_type)
    {
    case ALPHA_R_LITUSE:
    case ALPHA_R_GPDISP:
      intern->r_size = rel->addend;
      break;

    case ALPHA_R_OP_STORE:
      intern->r_size = rel->addend & 0xff;
      intern->r_offset = (rel->addend >> 8) & 0xff;
      break;

    case ALPHA_R_OP_PUSH:
    case ALPHA_R_OP_PSUB:
    case ALPHA_R_OP_PRSHIFT:
      intern->r_vaddr = rel->addend;
      break;

    case ALPHA_R_IGNORE:
      intern->r_vaddr = rel->address;
      break;

    default:
      break;
    }
}

/* The size of the stack for the relocation evaluator.  */
#define RELOC_STACKSIZE (10)

/* Alpha ECOFF relocs have a built in expression evaluator as well as
   other interdependencies.  Rather than use a bunch of special
   functions and global variables, we use a single routine to do all
   the relocation for a section.  I haven't yet worked out how the
   assembler is going to handle this.  */

static bfd_byte *
alpha_ecoff_get_relocated_section_contents (bfd *abfd,
					    struct bfd_link_info *link_info,
					    struct bfd_link_order *link_order,
					    bfd_byte *data,
					    bfd_boolean relocatable,
					    asymbol **symbols)
{
  bfd *input_bfd = link_order->u.indirect.section->owner;
  asection *input_section = link_order->u.indirect.section;
  long reloc_size = bfd_get_reloc_upper_bound (input_bfd, input_section);
  arelent **reloc_vector = NULL;
  long reloc_count;
  bfd *output_bfd = relocatable ? abfd : (bfd *) NULL;
  bfd_vma gp;
  bfd_size_type sz;
  bfd_boolean gp_undefined;
  bfd_vma stack[RELOC_STACKSIZE];
  int tos = 0;

  if (reloc_size < 0)
    goto error_return;
  reloc_vector = (arelent **) bfd_malloc ((bfd_size_type) reloc_size);
  if (reloc_vector == NULL && reloc_size != 0)
    goto error_return;

  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (! bfd_get_section_contents (input_bfd, input_section, data, 0, sz))
    goto error_return;

  reloc_count = bfd_canonicalize_reloc (input_bfd, input_section,
					reloc_vector, symbols);
  if (reloc_count < 0)
    goto error_return;
  if (reloc_count == 0)
    goto successful_return;

  /* Get the GP value for the output BFD.  */
  gp_undefined = FALSE;
  gp = _bfd_get_gp_value (abfd);
  if (gp == 0)
    {
      if (relocatable)
	{
	  asection *sec;
	  bfd_vma lo;

	  /* Make up a value.  */
	  lo = (bfd_vma) -1;
	  for (sec = abfd->sections; sec != NULL; sec = sec->next)
	    {
	      if (sec->vma < lo
		  && (strcmp (sec->name, ".sbss") == 0
		      || strcmp (sec->name, ".sdata") == 0
		      || strcmp (sec->name, ".lit4") == 0
		      || strcmp (sec->name, ".lit8") == 0
		      || strcmp (sec->name, ".lita") == 0))
		lo = sec->vma;
	    }
	  gp = lo + 0x8000;
	  _bfd_set_gp_value (abfd, gp);
	}
      else
	{
	  struct bfd_link_hash_entry *h;

	  h = bfd_link_hash_lookup (link_info->hash, "_gp", FALSE, FALSE,
				    TRUE);
	  if (h == (struct bfd_link_hash_entry *) NULL
	      || h->type != bfd_link_hash_defined)
	    gp_undefined = TRUE;
	  else
	    {
	      gp = (h->u.def.value
		    + h->u.def.section->output_section->vma
		    + h->u.def.section->output_offset);
	      _bfd_set_gp_value (abfd, gp);
	    }
	}
    }

  for (; *reloc_vector != (arelent *) NULL; reloc_vector++)
    {
      arelent *rel;
      bfd_reloc_status_type r;
      char *err;

      rel = *reloc_vector;
      r = bfd_reloc_ok;
      switch (rel->howto->type)
	{
	case ALPHA_R_IGNORE:
	  rel->address += input_section->output_offset;
	  break;

	case ALPHA_R_REFLONG:
	case ALPHA_R_REFQUAD:
	case ALPHA_R_BRADDR:
	case ALPHA_R_HINT:
	case ALPHA_R_SREL16:
	case ALPHA_R_SREL32:
	case ALPHA_R_SREL64:
	  if (relocatable
	      && ((*rel->sym_ptr_ptr)->flags & BSF_SECTION_SYM) == 0)
	    {
	      rel->address += input_section->output_offset;
	      break;
	    }
	  r = bfd_perform_relocation (input_bfd, rel, data, input_section,
				      output_bfd, &err);
	  break;

	case ALPHA_R_GPREL32:
	  /* This relocation is used in a switch table.  It is a 32
	     bit offset from the current GP value.  We must adjust it
	     by the different between the original GP value and the
	     current GP value.  The original GP value is stored in the
	     addend.  We adjust the addend and let
	     bfd_perform_relocation finish the job.  */
	  rel->addend -= gp;
	  r = bfd_perform_relocation (input_bfd, rel, data, input_section,
				      output_bfd, &err);
	  if (r == bfd_reloc_ok && gp_undefined)
	    {
	      r = bfd_reloc_dangerous;
	      err = (char *) _("GP relative relocation used when GP not defined");
	    }
	  break;

	case ALPHA_R_LITERAL:
	  /* This is a reference to a literal value, generally
	     (always?) in the .lita section.  This is a 16 bit GP
	     relative relocation.  Sometimes the subsequent reloc is a
	     LITUSE reloc, which indicates how this reloc is used.
	     This sometimes permits rewriting the two instructions
	     referred to by the LITERAL and the LITUSE into different
	     instructions which do not refer to .lita.  This can save
	     a memory reference, and permits removing a value from
	     .lita thus saving GP relative space.

	     We do not these optimizations.  To do them we would need
	     to arrange to link the .lita section first, so that by
	     the time we got here we would know the final values to
	     use.  This would not be particularly difficult, but it is
	     not currently implemented.  */

	  {
	    unsigned long insn;

	    /* I believe that the LITERAL reloc will only apply to a
	       ldq or ldl instruction, so check my assumption.  */
	    insn = bfd_get_32 (input_bfd, data + rel->address);
	    BFD_ASSERT (((insn >> 26) & 0x3f) == 0x29
			|| ((insn >> 26) & 0x3f) == 0x28);

	    rel->addend -= gp;
	    r = bfd_perform_relocation (input_bfd, rel, data, input_section,
					output_bfd, &err);
	    if (r == bfd_reloc_ok && gp_undefined)
	      {
		r = bfd_reloc_dangerous;
		err =
		  (char *) _("GP relative relocation used when GP not defined");
	      }
	  }
	  break;

	case ALPHA_R_LITUSE:
	  /* See ALPHA_R_LITERAL above for the uses of this reloc.  It
	     does not cause anything to happen, itself.  */
	  rel->address += input_section->output_offset;
	  break;

	case ALPHA_R_GPDISP:
	  /* This marks the ldah of an ldah/lda pair which loads the
	     gp register with the difference of the gp value and the
	     current location.  The second of the pair is r_size bytes
	     ahead; it used to be marked with an ALPHA_R_IGNORE reloc,
	     but that no longer happens in OSF/1 3.2.  */
	  {
	    unsigned long insn1, insn2;
	    bfd_vma addend;

	    /* Get the two instructions.  */
	    insn1 = bfd_get_32 (input_bfd, data + rel->address);
	    insn2 = bfd_get_32 (input_bfd, data + rel->address + rel->addend);

	    BFD_ASSERT (((insn1 >> 26) & 0x3f) == 0x09); /* ldah */
	    BFD_ASSERT (((insn2 >> 26) & 0x3f) == 0x08); /* lda */

	    /* Get the existing addend.  We must account for the sign
	       extension done by lda and ldah.  */
	    addend = ((insn1 & 0xffff) << 16) + (insn2 & 0xffff);
	    if (insn1 & 0x8000)
	      {
		addend -= 0x80000000;
		addend -= 0x80000000;
	      }
	    if (insn2 & 0x8000)
	      addend -= 0x10000;

	    /* The existing addend includes the different between the
	       gp of the input BFD and the address in the input BFD.
	       Subtract this out.  */
	    addend -= (ecoff_data (input_bfd)->gp
		       - (input_section->vma + rel->address));

	    /* Now add in the final gp value, and subtract out the
	       final address.  */
	    addend += (gp
		       - (input_section->output_section->vma
			  + input_section->output_offset
			  + rel->address));

	    /* Change the instructions, accounting for the sign
	       extension, and write them out.  */
	    if (addend & 0x8000)
	      addend += 0x10000;
	    insn1 = (insn1 & 0xffff0000) | ((addend >> 16) & 0xffff);
	    insn2 = (insn2 & 0xffff0000) | (addend & 0xffff);

	    bfd_put_32 (input_bfd, (bfd_vma) insn1, data + rel->address);
	    bfd_put_32 (input_bfd, (bfd_vma) insn2,
			data + rel->address + rel->addend);

	    rel->address += input_section->output_offset;
	  }
	  break;

	case ALPHA_R_OP_PUSH:
	  /* Push a value on the reloc evaluation stack.  */
	  {
	    asymbol *symbol;
	    bfd_vma relocation;

	    if (relocatable)
	      {
		rel->address += input_section->output_offset;
		break;
	      }

	    /* Figure out the relocation of this symbol.  */
	    symbol = *rel->sym_ptr_ptr;

	    if (bfd_is_und_section (symbol->section))
	      r = bfd_reloc_undefined;

	    if (bfd_is_com_section (symbol->section))
	      relocation = 0;
	    else
	      relocation = symbol->value;
	    relocation += symbol->section->output_section->vma;
	    relocation += symbol->section->output_offset;
	    relocation += rel->addend;

	    if (tos >= RELOC_STACKSIZE)
	      abort ();

	    stack[tos++] = relocation;
	  }
	  break;

	case ALPHA_R_OP_STORE:
	  /* Store a value from the reloc stack into a bitfield.  */
	  {
	    bfd_vma val;
	    int offset, size;

	    if (relocatable)
	      {
		rel->address += input_section->output_offset;
		break;
	      }

	    if (tos == 0)
	      abort ();

	    /* The offset and size for this reloc are encoded into the
	       addend field by alpha_adjust_reloc_in.  */
	    offset = (rel->addend >> 8) & 0xff;
	    size = rel->addend & 0xff;

	    val = bfd_get_64 (abfd, data + rel->address);
	    val &=~ (((1 << size) - 1) << offset);
	    val |= (stack[--tos] & ((1 << size) - 1)) << offset;
	    bfd_put_64 (abfd, val, data + rel->address);
	  }
	  break;

	case ALPHA_R_OP_PSUB:
	  /* Subtract a value from the top of the stack.  */
	  {
	    asymbol *symbol;
	    bfd_vma relocation;

	    if (relocatable)
	      {
		rel->address += input_section->output_offset;
		break;
	      }

	    /* Figure out the relocation of this symbol.  */
	    symbol = *rel->sym_ptr_ptr;

	    if (bfd_is_und_section (symbol->section))
	      r = bfd_reloc_undefined;

	    if (bfd_is_com_section (symbol->section))
	      relocation = 0;
	    else
	      relocation = symbol->value;
	    relocation += symbol->section->output_section->vma;
	    relocation += symbol->section->output_offset;
	    relocation += rel->addend;

	    if (tos == 0)
	      abort ();

	    stack[tos - 1] -= relocation;
	  }
	  break;

	case ALPHA_R_OP_PRSHIFT:
	  /* Shift the value on the top of the stack.  */
	  {
	    asymbol *symbol;
	    bfd_vma relocation;

	    if (relocatable)
	      {
		rel->address += input_section->output_offset;
		break;
	      }

	    /* Figure out the relocation of this symbol.  */
	    symbol = *rel->sym_ptr_ptr;

	    if (bfd_is_und_section (symbol->section))
	      r = bfd_reloc_undefined;

	    if (bfd_is_com_section (symbol->section))
	      relocation = 0;
	    else
	      relocation = symbol->value;
	    relocation += symbol->section->output_section->vma;
	    relocation += symbol->section->output_offset;
	    relocation += rel->addend;

	    if (tos == 0)
	      abort ();

	    stack[tos - 1] >>= relocation;
	  }
	  break;

	case ALPHA_R_GPVALUE:
	  /* I really don't know if this does the right thing.  */
	  gp = rel->addend;
	  gp_undefined = FALSE;
	  break;

	default:
	  abort ();
	}

      if (relocatable)
	{
	  asection *os = input_section->output_section;

	  /* A partial link, so keep the relocs.  */
	  os->orelocation[os->reloc_count] = rel;
	  os->reloc_count++;
	}

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    case bfd_reloc_undefined:
	      if (! ((*link_info->callbacks->undefined_symbol)
		     (link_info, bfd_asymbol_name (*rel->sym_ptr_ptr),
		      input_bfd, input_section, rel->address, TRUE)))
		goto error_return;
	      break;
	    case bfd_reloc_dangerous:
	      if (! ((*link_info->callbacks->reloc_dangerous)
		     (link_info, err, input_bfd, input_section,
		      rel->address)))
		goto error_return;
	      break;
	    case bfd_reloc_overflow:
	      if (! ((*link_info->callbacks->reloc_overflow)
		     (link_info, NULL,
		      bfd_asymbol_name (*rel->sym_ptr_ptr),
		      rel->howto->name, rel->addend, input_bfd,
		      input_section, rel->address)))
		goto error_return;
	      break;
	    case bfd_reloc_outofrange:
	    default:
	      abort ();
	      break;
	    }
	}
    }

  if (tos != 0)
    abort ();

 successful_return:
  if (reloc_vector != NULL)
    free (reloc_vector);
  return data;

 error_return:
  if (reloc_vector != NULL)
    free (reloc_vector);
  return NULL;
}

/* Get the howto structure for a generic reloc type.  */

static reloc_howto_type *
alpha_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			     bfd_reloc_code_real_type code)
{
  int alpha_type;

  switch (code)
    {
    case BFD_RELOC_32:
      alpha_type = ALPHA_R_REFLONG;
      break;
    case BFD_RELOC_64:
    case BFD_RELOC_CTOR:
      alpha_type = ALPHA_R_REFQUAD;
      break;
    case BFD_RELOC_GPREL32:
      alpha_type = ALPHA_R_GPREL32;
      break;
    case BFD_RELOC_ALPHA_LITERAL:
      alpha_type = ALPHA_R_LITERAL;
      break;
    case BFD_RELOC_ALPHA_LITUSE:
      alpha_type = ALPHA_R_LITUSE;
      break;
    case BFD_RELOC_ALPHA_GPDISP_HI16:
      alpha_type = ALPHA_R_GPDISP;
      break;
    case BFD_RELOC_ALPHA_GPDISP_LO16:
      alpha_type = ALPHA_R_IGNORE;
      break;
    case BFD_RELOC_23_PCREL_S2:
      alpha_type = ALPHA_R_BRADDR;
      break;
    case BFD_RELOC_ALPHA_HINT:
      alpha_type = ALPHA_R_HINT;
      break;
    case BFD_RELOC_16_PCREL:
      alpha_type = ALPHA_R_SREL16;
      break;
    case BFD_RELOC_32_PCREL:
      alpha_type = ALPHA_R_SREL32;
      break;
    case BFD_RELOC_64_PCREL:
      alpha_type = ALPHA_R_SREL64;
      break;
    default:
      return (reloc_howto_type *) NULL;
    }

  return &alpha_howto_table[alpha_type];
}

static reloc_howto_type *
alpha_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			     const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (alpha_howto_table) / sizeof (alpha_howto_table[0]);
       i++)
    if (alpha_howto_table[i].name != NULL
	&& strcasecmp (alpha_howto_table[i].name, r_name) == 0)
      return &alpha_howto_table[i];

  return NULL;
}

/* A helper routine for alpha_relocate_section which converts an
   external reloc when generating relocatable output.  Returns the
   relocation amount.  */

static bfd_vma
alpha_convert_external_reloc (bfd *output_bfd ATTRIBUTE_UNUSED,
			      struct bfd_link_info *info,
			      bfd *input_bfd,
			      struct external_reloc *ext_rel,
			      struct ecoff_link_hash_entry *h)
{
  unsigned long r_symndx;
  bfd_vma relocation;

  BFD_ASSERT (info->relocatable);

  if (h->root.type == bfd_link_hash_defined
      || h->root.type == bfd_link_hash_defweak)
    {
      asection *hsec;
      const char *name;

      /* This symbol is defined in the output.  Convert the reloc from
	 being against the symbol to being against the section.  */

      /* Clear the r_extern bit.  */
      ext_rel->r_bits[1] &=~ RELOC_BITS1_EXTERN_LITTLE;

      /* Compute a new r_symndx value.  */
      hsec = h->root.u.def.section;
      name = bfd_get_section_name (output_bfd, hsec->output_section);

      r_symndx = (unsigned long) -1;
      switch (name[1])
	{
	case 'A':
	  if (strcmp (name, "*ABS*") == 0)
	    r_symndx = RELOC_SECTION_ABS;
	  break;
	case 'b':
	  if (strcmp (name, ".bss") == 0)
	    r_symndx = RELOC_SECTION_BSS;
	  break;
	case 'd':
	  if (strcmp (name, ".data") == 0)
	    r_symndx = RELOC_SECTION_DATA;
	  break;
	case 'f':
	  if (strcmp (name, ".fini") == 0)
	    r_symndx = RELOC_SECTION_FINI;
	  break;
	case 'i':
	  if (strcmp (name, ".init") == 0)
	    r_symndx = RELOC_SECTION_INIT;
	  break;
	case 'l':
	  if (strcmp (name, ".lita") == 0)
	    r_symndx = RELOC_SECTION_LITA;
	  else if (strcmp (name, ".lit8") == 0)
	    r_symndx = RELOC_SECTION_LIT8;
	  else if (strcmp (name, ".lit4") == 0)
	    r_symndx = RELOC_SECTION_LIT4;
	  break;
	case 'p':
	  if (strcmp (name, ".pdata") == 0)
	    r_symndx = RELOC_SECTION_PDATA;
	  break;
	case 'r':
	  if (strcmp (name, ".rdata") == 0)
	    r_symndx = RELOC_SECTION_RDATA;
	  else if (strcmp (name, ".rconst") == 0)
	    r_symndx = RELOC_SECTION_RCONST;
	  break;
	case 's':
	  if (strcmp (name, ".sdata") == 0)
	    r_symndx = RELOC_SECTION_SDATA;
	  else if (strcmp (name, ".sbss") == 0)
	    r_symndx = RELOC_SECTION_SBSS;
	  break;
	case 't':
	  if (strcmp (name, ".text") == 0)
	    r_symndx = RELOC_SECTION_TEXT;
	  break;
	case 'x':
	  if (strcmp (name, ".xdata") == 0)
	    r_symndx = RELOC_SECTION_XDATA;
	  break;
	}

      if (r_symndx == (unsigned long) -1)
	abort ();

      /* Add the section VMA and the symbol value.  */
      relocation = (h->root.u.def.value
		    + hsec->output_section->vma
		    + hsec->output_offset);
    }
  else
    {
      /* Change the symndx value to the right one for
	 the output BFD.  */
      r_symndx = h->indx;
      if (r_symndx == (unsigned long) -1)
	{
	  /* Caller must give an error.  */
	  r_symndx = 0;
	}
      relocation = 0;
    }

  /* Write out the new r_symndx value.  */
  H_PUT_32 (input_bfd, r_symndx, ext_rel->r_symndx);

  return relocation;
}

/* Relocate a section while linking an Alpha ECOFF file.  This is
   quite similar to get_relocated_section_contents.  Perhaps they
   could be combined somehow.  */

static bfd_boolean
alpha_relocate_section (bfd *output_bfd,
			struct bfd_link_info *info,
			bfd *input_bfd,
			asection *input_section,
			bfd_byte *contents,
			void * external_relocs)
{
  asection **symndx_to_section, *lita_sec;
  struct ecoff_link_hash_entry **sym_hashes;
  bfd_vma gp;
  bfd_boolean gp_undefined;
  bfd_vma stack[RELOC_STACKSIZE];
  int tos = 0;
  struct external_reloc *ext_rel;
  struct external_reloc *ext_rel_end;
  bfd_size_type amt;

  /* We keep a table mapping the symndx found in an internal reloc to
     the appropriate section.  This is faster than looking up the
     section by name each time.  */
  symndx_to_section = ecoff_data (input_bfd)->symndx_to_section;
  if (symndx_to_section == (asection **) NULL)
    {
      amt = NUM_RELOC_SECTIONS * sizeof (asection *);
      symndx_to_section = (asection **) bfd_alloc (input_bfd, amt);
      if (!symndx_to_section)
	return FALSE;

      symndx_to_section[RELOC_SECTION_NONE] = NULL;
      symndx_to_section[RELOC_SECTION_TEXT] =
	bfd_get_section_by_name (input_bfd, ".text");
      symndx_to_section[RELOC_SECTION_RDATA] =
	bfd_get_section_by_name (input_bfd, ".rdata");
      symndx_to_section[RELOC_SECTION_DATA] =
	bfd_get_section_by_name (input_bfd, ".data");
      symndx_to_section[RELOC_SECTION_SDATA] =
	bfd_get_section_by_name (input_bfd, ".sdata");
      symndx_to_section[RELOC_SECTION_SBSS] =
	bfd_get_section_by_name (input_bfd, ".sbss");
      symndx_to_section[RELOC_SECTION_BSS] =
	bfd_get_section_by_name (input_bfd, ".bss");
      symndx_to_section[RELOC_SECTION_INIT] =
	bfd_get_section_by_name (input_bfd, ".init");
      symndx_to_section[RELOC_SECTION_LIT8] =
	bfd_get_section_by_name (input_bfd, ".lit8");
      symndx_to_section[RELOC_SECTION_LIT4] =
	bfd_get_section_by_name (input_bfd, ".lit4");
      symndx_to_section[RELOC_SECTION_XDATA] =
	bfd_get_section_by_name (input_bfd, ".xdata");
      symndx_to_section[RELOC_SECTION_PDATA] =
	bfd_get_section_by_name (input_bfd, ".pdata");
      symndx_to_section[RELOC_SECTION_FINI] =
	bfd_get_section_by_name (input_bfd, ".fini");
      symndx_to_section[RELOC_SECTION_LITA] =
	bfd_get_section_by_name (input_bfd, ".lita");
      symndx_to_section[RELOC_SECTION_ABS] = bfd_abs_section_ptr;
      symndx_to_section[RELOC_SECTION_RCONST] =
	bfd_get_section_by_name (input_bfd, ".rconst");

      ecoff_data (input_bfd)->symndx_to_section = symndx_to_section;
    }

  sym_hashes = ecoff_data (input_bfd)->sym_hashes;

  /* On the Alpha, the .lita section must be addressable by the global
     pointer.  To support large programs, we need to allow multiple
     global pointers.  This works as long as each input .lita section
     is <64KB big.  This implies that when producing relocatable
     output, the .lita section is limited to 64KB. .  */

  lita_sec = symndx_to_section[RELOC_SECTION_LITA];
  gp = _bfd_get_gp_value (output_bfd);
  if (! info->relocatable && lita_sec != NULL)
    {
      struct ecoff_section_tdata *lita_sec_data;

      /* Make sure we have a section data structure to which we can
	 hang on to the gp value we pick for the section.  */
      lita_sec_data = ecoff_section_data (input_bfd, lita_sec);
      if (lita_sec_data == NULL)
	{
	  amt = sizeof (struct ecoff_section_tdata);
	  lita_sec_data = ((struct ecoff_section_tdata *)
			   bfd_zalloc (input_bfd, amt));
	  lita_sec->used_by_bfd = lita_sec_data;
	}

      if (lita_sec_data->gp != 0)
	{
	  /* If we already assigned a gp to this section, we better
	     stick with that value.  */
	  gp = lita_sec_data->gp;
	}
      else
	{
	  bfd_vma lita_vma;
	  bfd_size_type lita_size;

	  lita_vma = lita_sec->output_offset + lita_sec->output_section->vma;
	  lita_size = lita_sec->size;

	  if (gp == 0
	      || lita_vma <  gp - 0x8000
	      || lita_vma + lita_size >= gp + 0x8000)
	    {
	      /* Either gp hasn't been set at all or the current gp
		 cannot address this .lita section.  In both cases we
		 reset the gp to point into the "middle" of the
		 current input .lita section.  */
	      if (gp && !ecoff_data (output_bfd)->issued_multiple_gp_warning)
		{
		  (*info->callbacks->warning) (info,
					       _("using multiple gp values"),
					       (char *) NULL, output_bfd,
					       (asection *) NULL, (bfd_vma) 0);
		  ecoff_data (output_bfd)->issued_multiple_gp_warning = TRUE;
		}
	      if (lita_vma < gp - 0x8000)
		gp = lita_vma + lita_size - 0x8000;
	      else
		gp = lita_vma + 0x8000;

	    }

	  lita_sec_data->gp = gp;
	}

      _bfd_set_gp_value (output_bfd, gp);
    }

  gp_undefined = (gp == 0);

  BFD_ASSERT (bfd_header_little_endian (output_bfd));
  BFD_ASSERT (bfd_header_little_endian (input_bfd));

  ext_rel = (struct external_reloc *) external_relocs;
  ext_rel_end = ext_rel + input_section->reloc_count;
  for (; ext_rel < ext_rel_end; ext_rel++)
    {
      bfd_vma r_vaddr;
      unsigned long r_symndx;
      int r_type;
      int r_extern;
      int r_offset;
      int r_size;
      bfd_boolean relocatep;
      bfd_boolean adjust_addrp;
      bfd_boolean gp_usedp;
      bfd_vma addend;

      r_vaddr = H_GET_64 (input_bfd, ext_rel->r_vaddr);
      r_symndx = H_GET_32 (input_bfd, ext_rel->r_symndx);

      r_type = ((ext_rel->r_bits[0] & RELOC_BITS0_TYPE_LITTLE)
		>> RELOC_BITS0_TYPE_SH_LITTLE);
      r_extern = (ext_rel->r_bits[1] & RELOC_BITS1_EXTERN_LITTLE) != 0;
      r_offset = ((ext_rel->r_bits[1] & RELOC_BITS1_OFFSET_LITTLE)
		  >> RELOC_BITS1_OFFSET_SH_LITTLE);
      /* Ignored the reserved bits.  */
      r_size = ((ext_rel->r_bits[3] & RELOC_BITS3_SIZE_LITTLE)
		>> RELOC_BITS3_SIZE_SH_LITTLE);

      relocatep = FALSE;
      adjust_addrp = TRUE;
      gp_usedp = FALSE;
      addend = 0;

      switch (r_type)
	{
	case ALPHA_R_GPRELHIGH:
	  (*_bfd_error_handler)
	    (_("%B: unsupported relocation: ALPHA_R_GPRELHIGH"),
	     input_bfd);
	  bfd_set_error (bfd_error_bad_value);
	  continue;

	case ALPHA_R_GPRELLOW:
	  (*_bfd_error_handler)
	    (_("%B: unsupported relocation: ALPHA_R_GPRELLOW"),
	     input_bfd);
	  bfd_set_error (bfd_error_bad_value);
	  continue;

	default:
	  (*_bfd_error_handler)
	    (_("%B: unknown relocation type %d"),
	     input_bfd, (int) r_type);
	  bfd_set_error (bfd_error_bad_value);
	  continue;

	case ALPHA_R_IGNORE:
	  /* This reloc appears after a GPDISP reloc.  On earlier
	     versions of OSF/1, It marked the position of the second
	     instruction to be altered by the GPDISP reloc, but it is
	     not otherwise used for anything.  For some reason, the
	     address of the relocation does not appear to include the
	     section VMA, unlike the other relocation types.  */
	  if (info->relocatable)
	    H_PUT_64 (input_bfd, input_section->output_offset + r_vaddr,
		      ext_rel->r_vaddr);
	  adjust_addrp = FALSE;
	  break;

	case ALPHA_R_REFLONG:
	case ALPHA_R_REFQUAD:
	case ALPHA_R_HINT:
	  relocatep = TRUE;
	  break;

	case ALPHA_R_BRADDR:
	case ALPHA_R_SREL16:
	case ALPHA_R_SREL32:
	case ALPHA_R_SREL64:
	  if (r_extern)
	    addend += - (r_vaddr + 4);
	  relocatep = TRUE;
	  break;

	case ALPHA_R_GPREL32:
	  /* This relocation is used in a switch table.  It is a 32
	     bit offset from the current GP value.  We must adjust it
	     by the different between the original GP value and the
	     current GP value.  */
	  relocatep = TRUE;
	  addend = ecoff_data (input_bfd)->gp - gp;
	  gp_usedp = TRUE;
	  break;

	case ALPHA_R_LITERAL:
	  /* This is a reference to a literal value, generally
	     (always?) in the .lita section.  This is a 16 bit GP
	     relative relocation.  Sometimes the subsequent reloc is a
	     LITUSE reloc, which indicates how this reloc is used.
	     This sometimes permits rewriting the two instructions
	     referred to by the LITERAL and the LITUSE into different
	     instructions which do not refer to .lita.  This can save
	     a memory reference, and permits removing a value from
	     .lita thus saving GP relative space.

	     We do not these optimizations.  To do them we would need
	     to arrange to link the .lita section first, so that by
	     the time we got here we would know the final values to
	     use.  This would not be particularly difficult, but it is
	     not currently implemented.  */

	  /* I believe that the LITERAL reloc will only apply to a ldq
	     or ldl instruction, so check my assumption.  */
	  {
	    unsigned long insn;

	    insn = bfd_get_32 (input_bfd,
			       contents + r_vaddr - input_section->vma);
	    BFD_ASSERT (((insn >> 26) & 0x3f) == 0x29
			|| ((insn >> 26) & 0x3f) == 0x28);
	  }

	  relocatep = TRUE;
	  addend = ecoff_data (input_bfd)->gp - gp;
	  gp_usedp = TRUE;
	  break;

	case ALPHA_R_LITUSE:
	  /* See ALPHA_R_LITERAL above for the uses of this reloc.  It
	     does not cause anything to happen, itself.  */
	  break;

	case ALPHA_R_GPDISP:
	  /* This marks the ldah of an ldah/lda pair which loads the
	     gp register with the difference of the gp value and the
	     current location.  The second of the pair is r_symndx
	     bytes ahead.  It used to be marked with an ALPHA_R_IGNORE
	     reloc, but OSF/1 3.2 no longer does that.  */
	  {
	    unsigned long insn1, insn2;

	    /* Get the two instructions.  */
	    insn1 = bfd_get_32 (input_bfd,
				contents + r_vaddr - input_section->vma);
	    insn2 = bfd_get_32 (input_bfd,
				(contents
				 + r_vaddr
				 - input_section->vma
				 + r_symndx));

	    BFD_ASSERT (((insn1 >> 26) & 0x3f) == 0x09); /* ldah */
	    BFD_ASSERT (((insn2 >> 26) & 0x3f) == 0x08); /* lda */

	    /* Get the existing addend.  We must account for the sign
	       extension done by lda and ldah.  */
	    addend = ((insn1 & 0xffff) << 16) + (insn2 & 0xffff);
	    if (insn1 & 0x8000)
	      {
		/* This is addend -= 0x100000000 without causing an
		   integer overflow on a 32 bit host.  */
		addend -= 0x80000000;
		addend -= 0x80000000;
	      }
	    if (insn2 & 0x8000)
	      addend -= 0x10000;

	    /* The existing addend includes the difference between the
	       gp of the input BFD and the address in the input BFD.
	       We want to change this to the difference between the
	       final GP and the final address.  */
	    addend += (gp
		       - ecoff_data (input_bfd)->gp
		       + input_section->vma
		       - (input_section->output_section->vma
			  + input_section->output_offset));

	    /* Change the instructions, accounting for the sign
	       extension, and write them out.  */
	    if (addend & 0x8000)
	      addend += 0x10000;
	    insn1 = (insn1 & 0xffff0000) | ((addend >> 16) & 0xffff);
	    insn2 = (insn2 & 0xffff0000) | (addend & 0xffff);

	    bfd_put_32 (input_bfd, (bfd_vma) insn1,
			contents + r_vaddr - input_section->vma);
	    bfd_put_32 (input_bfd, (bfd_vma) insn2,
			contents + r_vaddr - input_section->vma + r_symndx);

	    gp_usedp = TRUE;
	  }
	  break;

	case ALPHA_R_OP_PUSH:
	case ALPHA_R_OP_PSUB:
	case ALPHA_R_OP_PRSHIFT:
	  /* Manipulate values on the reloc evaluation stack.  The
	     r_vaddr field is not an address in input_section, it is
	     the current value (including any addend) of the object
	     being used.  */
	  if (! r_extern)
	    {
	      asection *s;

	      s = symndx_to_section[r_symndx];
	      if (s == (asection *) NULL)
		abort ();
	      addend = s->output_section->vma + s->output_offset - s->vma;
	    }
	  else
	    {
	      struct ecoff_link_hash_entry *h;

	      h = sym_hashes[r_symndx];
	      if (h == (struct ecoff_link_hash_entry *) NULL)
		abort ();

	      if (! info->relocatable)
		{
		  if (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak)
		    addend = (h->root.u.def.value
			      + h->root.u.def.section->output_section->vma
			      + h->root.u.def.section->output_offset);
		  else
		    {
		      /* Note that we pass the address as 0, since we
			 do not have a meaningful number for the
			 location within the section that is being
			 relocated.  */
		      if (! ((*info->callbacks->undefined_symbol)
			     (info, h->root.root.string, input_bfd,
			      input_section, (bfd_vma) 0, TRUE)))
			return FALSE;
		      addend = 0;
		    }
		}
	      else
		{
		  if (h->root.type != bfd_link_hash_defined
		      && h->root.type != bfd_link_hash_defweak
		      && h->indx == -1)
		    {
		      /* This symbol is not being written out.  Pass
			 the address as 0, as with undefined_symbol,
			 above.  */
		      if (! ((*info->callbacks->unattached_reloc)
			     (info, h->root.root.string, input_bfd,
			      input_section, (bfd_vma) 0)))
			return FALSE;
		    }

		  addend = alpha_convert_external_reloc (output_bfd, info,
							 input_bfd,
							 ext_rel, h);
		}
	    }

	  addend += r_vaddr;

	  if (info->relocatable)
	    {
	      /* Adjust r_vaddr by the addend.  */
	      H_PUT_64 (input_bfd, addend, ext_rel->r_vaddr);
	    }
	  else
	    {
	      switch (r_type)
		{
		case ALPHA_R_OP_PUSH:
		  if (tos >= RELOC_STACKSIZE)
		    abort ();
		  stack[tos++] = addend;
		  break;

		case ALPHA_R_OP_PSUB:
		  if (tos == 0)
		    abort ();
		  stack[tos - 1] -= addend;
		  break;

		case ALPHA_R_OP_PRSHIFT:
		  if (tos == 0)
		    abort ();
		  stack[tos - 1] >>= addend;
		  break;
		}
	    }

	  adjust_addrp = FALSE;
	  break;

	case ALPHA_R_OP_STORE:
	  /* Store a value from the reloc stack into a bitfield.  If
	     we are generating relocatable output, all we do is
	     adjust the address of the reloc.  */
	  if (! info->relocatable)
	    {
	      bfd_vma mask;
	      bfd_vma val;

	      if (tos == 0)
		abort ();

	      /* Get the relocation mask.  The separate steps and the
		 casts to bfd_vma are attempts to avoid a bug in the
		 Alpha OSF 1.3 C compiler.  See reloc.c for more
		 details.  */
	      mask = 1;
	      mask <<= (bfd_vma) r_size;
	      mask -= 1;

	      /* FIXME: I don't know what kind of overflow checking,
		 if any, should be done here.  */
	      val = bfd_get_64 (input_bfd,
				contents + r_vaddr - input_section->vma);
	      val &=~ mask << (bfd_vma) r_offset;
	      val |= (stack[--tos] & mask) << (bfd_vma) r_offset;
	      bfd_put_64 (input_bfd, val,
			  contents + r_vaddr - input_section->vma);
	    }
	  break;

	case ALPHA_R_GPVALUE:
	  /* I really don't know if this does the right thing.  */
	  gp = ecoff_data (input_bfd)->gp + r_symndx;
	  gp_undefined = FALSE;
	  break;
	}

      if (relocatep)
	{
	  reloc_howto_type *howto;
	  struct ecoff_link_hash_entry *h = NULL;
	  asection *s = NULL;
	  bfd_vma relocation;
	  bfd_reloc_status_type r;

	  /* Perform a relocation.  */

	  howto = &alpha_howto_table[r_type];

	  if (r_extern)
	    {
	      h = sym_hashes[r_symndx];
	      /* If h is NULL, that means that there is a reloc
		 against an external symbol which we thought was just
		 a debugging symbol.  This should not happen.  */
	      if (h == (struct ecoff_link_hash_entry *) NULL)
		abort ();
	    }
	  else
	    {
	      if (r_symndx >= NUM_RELOC_SECTIONS)
		s = NULL;
	      else
		s = symndx_to_section[r_symndx];

	      if (s == (asection *) NULL)
		abort ();
	    }

	  if (info->relocatable)
	    {
	      /* We are generating relocatable output, and must
		 convert the existing reloc.  */
	      if (r_extern)
		{
		  if (h->root.type != bfd_link_hash_defined
		      && h->root.type != bfd_link_hash_defweak
		      && h->indx == -1)
		    {
		      /* This symbol is not being written out.  */
		      if (! ((*info->callbacks->unattached_reloc)
			     (info, h->root.root.string, input_bfd,
			      input_section, r_vaddr - input_section->vma)))
			return FALSE;
		    }

		  relocation = alpha_convert_external_reloc (output_bfd,
							     info,
							     input_bfd,
							     ext_rel,
							     h);
		}
	      else
		{
		  /* This is a relocation against a section.  Adjust
		     the value by the amount the section moved.  */
		  relocation = (s->output_section->vma
				+ s->output_offset
				- s->vma);
		}

	      /* If this is PC relative, the existing object file
		 appears to already have the reloc worked out.  We
		 must subtract out the old value and add in the new
		 one.  */
	      if (howto->pc_relative)
		relocation -= (input_section->output_section->vma
			       + input_section->output_offset
			       - input_section->vma);

	      /* Put in any addend.  */
	      relocation += addend;

	      /* Adjust the contents.  */
	      r = _bfd_relocate_contents (howto, input_bfd, relocation,
					  (contents
					   + r_vaddr
					   - input_section->vma));
	    }
	  else
	    {
	      /* We are producing a final executable.  */
	      if (r_extern)
		{
		  /* This is a reloc against a symbol.  */
		  if (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak)
		    {
		      asection *hsec;

		      hsec = h->root.u.def.section;
		      relocation = (h->root.u.def.value
				    + hsec->output_section->vma
				    + hsec->output_offset);
		    }
		  else
		    {
		      if (! ((*info->callbacks->undefined_symbol)
			     (info, h->root.root.string, input_bfd,
			      input_section,
			      r_vaddr - input_section->vma, TRUE)))
			return FALSE;
		      relocation = 0;
		    }
		}
	      else
		{
		  /* This is a reloc against a section.  */
		  relocation = (s->output_section->vma
				+ s->output_offset
				- s->vma);

		  /* Adjust a PC relative relocation by removing the
		     reference to the original source section.  */
		  if (howto->pc_relative)
		    relocation += input_section->vma;
		}

	      r = _bfd_final_link_relocate (howto,
					    input_bfd,
					    input_section,
					    contents,
					    r_vaddr - input_section->vma,
					    relocation,
					    addend);
	    }

	  if (r != bfd_reloc_ok)
	    {
	      switch (r)
		{
		default:
		case bfd_reloc_outofrange:
		  abort ();
		case bfd_reloc_overflow:
		  {
		    const char *name;

		    if (r_extern)
		      name = sym_hashes[r_symndx]->root.root.string;
		    else
		      name = bfd_section_name (input_bfd,
					       symndx_to_section[r_symndx]);
		    if (! ((*info->callbacks->reloc_overflow)
			   (info, NULL, name,
			    alpha_howto_table[r_type].name,
			    (bfd_vma) 0, input_bfd, input_section,
			    r_vaddr - input_section->vma)))
		      return FALSE;
		  }
		  break;
		}
	    }
	}

      if (info->relocatable && adjust_addrp)
	{
	  /* Change the address of the relocation.  */
	  H_PUT_64 (input_bfd,
		    (input_section->output_section->vma
		     + input_section->output_offset
		     - input_section->vma
		     + r_vaddr),
		    ext_rel->r_vaddr);
	}

      if (gp_usedp && gp_undefined)
	{
	  if (! ((*info->callbacks->reloc_dangerous)
		 (info, _("GP relative relocation used when GP not defined"),
		  input_bfd, input_section, r_vaddr - input_section->vma)))
	    return FALSE;
	  /* Only give the error once per link.  */
	  gp = 4;
	  _bfd_set_gp_value (output_bfd, gp);
	  gp_undefined = FALSE;
	}
    }

  if (tos != 0)
    abort ();

  return TRUE;
}

/* Do final adjustments to the filehdr and the aouthdr.  This routine
   sets the dynamic bits in the file header.  */

static bfd_boolean
alpha_adjust_headers (bfd *abfd,
		      struct internal_filehdr *fhdr,
		      struct internal_aouthdr *ahdr ATTRIBUTE_UNUSED)
{
  if ((abfd->flags & (DYNAMIC | EXEC_P)) == (DYNAMIC | EXEC_P))
    fhdr->f_flags |= F_ALPHA_CALL_SHARED;
  else if ((abfd->flags & DYNAMIC) != 0)
    fhdr->f_flags |= F_ALPHA_SHARABLE;
  return TRUE;
}

/* Archive handling.  In OSF/1 (or Digital Unix) v3.2, Digital
   introduced archive packing, in which the elements in an archive are
   optionally compressed using a simple dictionary scheme.  We know
   how to read such archives, but we don't write them.  */

#define alpha_ecoff_slurp_armap _bfd_ecoff_slurp_armap
#define alpha_ecoff_slurp_extended_name_table \
  _bfd_ecoff_slurp_extended_name_table
#define alpha_ecoff_construct_extended_name_table \
  _bfd_ecoff_construct_extended_name_table
#define alpha_ecoff_truncate_arname _bfd_ecoff_truncate_arname
#define alpha_ecoff_write_armap _bfd_ecoff_write_armap
#define alpha_ecoff_write_ar_hdr _bfd_generic_write_ar_hdr
#define alpha_ecoff_generic_stat_arch_elt _bfd_ecoff_generic_stat_arch_elt
#define alpha_ecoff_update_armap_timestamp _bfd_ecoff_update_armap_timestamp

/* A compressed file uses this instead of ARFMAG.  */

#define ARFZMAG "Z\012"

/* Read an archive header.  This is like the standard routine, but it
   also accepts ARFZMAG.  */

static void *
alpha_ecoff_read_ar_hdr (bfd *abfd)
{
  struct areltdata *ret;
  struct ar_hdr *h;

  ret = (struct areltdata *) _bfd_generic_read_ar_hdr_mag (abfd, ARFZMAG);
  if (ret == NULL)
    return NULL;

  h = (struct ar_hdr *) ret->arch_header;
  if (strncmp (h->ar_fmag, ARFZMAG, 2) == 0)
    {
      bfd_byte ab[8];

      /* This is a compressed file.  We must set the size correctly.
         The size is the eight bytes after the dummy file header.  */
      if (bfd_seek (abfd, (file_ptr) FILHSZ, SEEK_CUR) != 0
	  || bfd_bread (ab, (bfd_size_type) 8, abfd) != 8
	  || bfd_seek (abfd, (file_ptr) (- (FILHSZ + 8)), SEEK_CUR) != 0)
	return NULL;

      ret->parsed_size = H_GET_64 (abfd, ab);
    }

  return ret;
}

/* Get an archive element at a specified file position.  This is where
   we uncompress the archive element if necessary.  */

static bfd *
alpha_ecoff_get_elt_at_filepos (bfd *archive, file_ptr filepos)
{
  bfd *nbfd = NULL;
  struct areltdata *tdata;
  struct ar_hdr *hdr;
  bfd_byte ab[8];
  bfd_size_type size;
  bfd_byte *buf, *p;
  struct bfd_in_memory *bim;

  buf = NULL;
  nbfd = _bfd_get_elt_at_filepos (archive, filepos);
  if (nbfd == NULL)
    goto error_return;

  if ((nbfd->flags & BFD_IN_MEMORY) != 0)
    {
      /* We have already expanded this BFD.  */
      return nbfd;
    }

  tdata = (struct areltdata *) nbfd->arelt_data;
  hdr = (struct ar_hdr *) tdata->arch_header;
  if (strncmp (hdr->ar_fmag, ARFZMAG, 2) != 0)
    return nbfd;

  /* We must uncompress this element.  We do this by copying it into a
     memory buffer, and making bfd_bread and bfd_seek use that buffer.
     This can use a lot of memory, but it's simpler than getting a
     temporary file, making that work with the file descriptor caching
     code, and making sure that it is deleted at all appropriate
     times.  It can be changed if it ever becomes important.  */

  /* The compressed file starts with a dummy ECOFF file header.  */
  if (bfd_seek (nbfd, (file_ptr) FILHSZ, SEEK_SET) != 0)
    goto error_return;

  /* The next eight bytes are the real file size.  */
  if (bfd_bread (ab, (bfd_size_type) 8, nbfd) != 8)
    goto error_return;
  size = H_GET_64 (nbfd, ab);

  if (size != 0)
    {
      bfd_size_type left;
      bfd_byte dict[4096];
      unsigned int h;
      bfd_byte b;

      buf = (bfd_byte *) bfd_malloc (size);
      if (buf == NULL)
	goto error_return;
      p = buf;

      left = size;

      /* I don't know what the next eight bytes are for.  */
      if (bfd_bread (ab, (bfd_size_type) 8, nbfd) != 8)
	goto error_return;

      /* This is the uncompression algorithm.  It's a simple
	 dictionary based scheme in which each character is predicted
	 by a hash of the previous three characters.  A control byte
	 indicates whether the character is predicted or whether it
	 appears in the input stream; each control byte manages the
	 next eight bytes in the output stream.  */
      memset (dict, 0, sizeof dict);
      h = 0;
      while (bfd_bread (&b, (bfd_size_type) 1, nbfd) == 1)
	{
	  unsigned int i;

	  for (i = 0; i < 8; i++, b >>= 1)
	    {
	      bfd_byte n;

	      if ((b & 1) == 0)
		n = dict[h];
	      else
		{
		  if (! bfd_bread (&n, (bfd_size_type) 1, nbfd))
		    goto error_return;
		  dict[h] = n;
		}

	      *p++ = n;

	      --left;
	      if (left == 0)
		break;

	      h <<= 4;
	      h ^= n;
	      h &= sizeof dict - 1;
	    }

	  if (left == 0)
	    break;
	}
    }

  /* Now the uncompressed file contents are in buf.  */
  bim = ((struct bfd_in_memory *)
	 bfd_malloc ((bfd_size_type) sizeof (struct bfd_in_memory)));
  if (bim == NULL)
    goto error_return;
  bim->size = size;
  bim->buffer = buf;

  nbfd->mtime_set = TRUE;
  nbfd->mtime = strtol (hdr->ar_date, (char **) NULL, 10);

  nbfd->flags |= BFD_IN_MEMORY;
  nbfd->iostream = bim;
  nbfd->iovec = &_bfd_memory_iovec;
  nbfd->origin = 0;
  BFD_ASSERT (! nbfd->cacheable);

  return nbfd;

 error_return:
  if (buf != NULL)
    free (buf);
  if (nbfd != NULL)
    bfd_close (nbfd);
  return NULL;
}

/* Open the next archived file.  */

static bfd *
alpha_ecoff_openr_next_archived_file (bfd *archive, bfd *last_file)
{
  file_ptr filestart;

  if (last_file == NULL)
    filestart = bfd_ardata (archive)->first_file_filepos;
  else
    {
      struct areltdata *t;
      struct ar_hdr *h;
      bfd_size_type size;

      /* We can't use arelt_size here, because that uses parsed_size,
         which is the uncompressed size.  We need the compressed size.  */
      t = (struct areltdata *) last_file->arelt_data;
      h = (struct ar_hdr *) t->arch_header;
      size = strtol (h->ar_size, (char **) NULL, 10);

      /* Pad to an even boundary...
	 Note that last_file->origin can be odd in the case of
	 BSD-4.4-style element with a long odd size.  */
      filestart = last_file->proxy_origin + size;
      filestart += filestart % 2;
    }

  return alpha_ecoff_get_elt_at_filepos (archive, filestart);
}

/* Open the archive file given an index into the armap.  */

static bfd *
alpha_ecoff_get_elt_at_index (bfd *abfd, symindex sym_index)
{
  carsym *entry;

  entry = bfd_ardata (abfd)->symdefs + sym_index;
  return alpha_ecoff_get_elt_at_filepos (abfd, entry->file_offset);
}

/* This is the ECOFF backend structure.  The backend field of the
   target vector points to this.  */

static const struct ecoff_backend_data alpha_ecoff_backend_data =
{
  /* COFF backend structure.  */
  {
    (void (*) (bfd *,void *,int,int,int,int,void *)) bfd_void, /* aux_in */
    (void (*) (bfd *,void *,void *)) bfd_void, /* sym_in */
    (void (*) (bfd *,void *,void *)) bfd_void, /* lineno_in */
    (unsigned (*) (bfd *,void *,int,int,int,int,void *)) bfd_void,/*aux_out*/
    (unsigned (*) (bfd *,void *,void *)) bfd_void, /* sym_out */
    (unsigned (*) (bfd *,void *,void *)) bfd_void, /* lineno_out */
    (unsigned (*) (bfd *,void *,void *)) bfd_void, /* reloc_out */
    alpha_ecoff_swap_filehdr_out, alpha_ecoff_swap_aouthdr_out,
    alpha_ecoff_swap_scnhdr_out,
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE,
    ECOFF_NO_LONG_SECTION_NAMES, 4, FALSE, 2,
    alpha_ecoff_swap_filehdr_in, alpha_ecoff_swap_aouthdr_in,
    alpha_ecoff_swap_scnhdr_in, NULL,
    alpha_ecoff_bad_format_hook, _bfd_ecoff_set_arch_mach_hook,
    alpha_ecoff_mkobject_hook, _bfd_ecoff_styp_to_sec_flags,
    _bfd_ecoff_set_alignment_hook, _bfd_ecoff_slurp_symbol_table,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL
  },
  /* Supported architecture.  */
  bfd_arch_alpha,
  /* Initial portion of armap string.  */
  "________64",
  /* The page boundary used to align sections in a demand-paged
     executable file.  E.g., 0x1000.  */
  0x2000,
  /* TRUE if the .rdata section is part of the text segment, as on the
     Alpha.  FALSE if .rdata is part of the data segment, as on the
     MIPS.  */
  TRUE,
  /* Bitsize of constructor entries.  */
  64,
  /* Reloc to use for constructor entries.  */
  &alpha_howto_table[ALPHA_R_REFQUAD],
  {
    /* Symbol table magic number.  */
    magicSym2,
    /* Alignment of debugging information.  E.g., 4.  */
    8,
    /* Sizes of external symbolic information.  */
    sizeof (struct hdr_ext),
    sizeof (struct dnr_ext),
    sizeof (struct pdr_ext),
    sizeof (struct sym_ext),
    sizeof (struct opt_ext),
    sizeof (struct fdr_ext),
    sizeof (struct rfd_ext),
    sizeof (struct ext_ext),
    /* Functions to swap in external symbolic data.  */
    ecoff_swap_hdr_in,
    ecoff_swap_dnr_in,
    ecoff_swap_pdr_in,
    ecoff_swap_sym_in,
    ecoff_swap_opt_in,
    ecoff_swap_fdr_in,
    ecoff_swap_rfd_in,
    ecoff_swap_ext_in,
    _bfd_ecoff_swap_tir_in,
    _bfd_ecoff_swap_rndx_in,
    /* Functions to swap out external symbolic data.  */
    ecoff_swap_hdr_out,
    ecoff_swap_dnr_out,
    ecoff_swap_pdr_out,
    ecoff_swap_sym_out,
    ecoff_swap_opt_out,
    ecoff_swap_fdr_out,
    ecoff_swap_rfd_out,
    ecoff_swap_ext_out,
    _bfd_ecoff_swap_tir_out,
    _bfd_ecoff_swap_rndx_out,
    /* Function to read in symbolic data.  */
    _bfd_ecoff_slurp_symbolic_info
  },
  /* External reloc size.  */
  RELSZ,
  /* Reloc swapping functions.  */
  alpha_ecoff_swap_reloc_in,
  alpha_ecoff_swap_reloc_out,
  /* Backend reloc tweaking.  */
  alpha_adjust_reloc_in,
  alpha_adjust_reloc_out,
  /* Relocate section contents while linking.  */
  alpha_relocate_section,
  /* Do final adjustments to filehdr and aouthdr.  */
  alpha_adjust_headers,
  /* Read an element from an archive at a given file position.  */
  alpha_ecoff_get_elt_at_filepos
};

/* Looking up a reloc type is Alpha specific.  */
#define _bfd_ecoff_bfd_reloc_type_lookup alpha_bfd_reloc_type_lookup
#define _bfd_ecoff_bfd_reloc_name_lookup \
  alpha_bfd_reloc_name_lookup

/* So is getting relocated section contents.  */
#define _bfd_ecoff_bfd_get_relocated_section_contents \
  alpha_ecoff_get_relocated_section_contents

/* Handling file windows is generic.  */
#define _bfd_ecoff_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window

/* Input section flag lookup is generic.  */
#define _bfd_ecoff_bfd_lookup_section_flags bfd_generic_lookup_section_flags

/* Relaxing sections is generic.  */
#define _bfd_ecoff_bfd_relax_section bfd_generic_relax_section
#define _bfd_ecoff_bfd_gc_sections bfd_generic_gc_sections
#define _bfd_ecoff_bfd_merge_sections bfd_generic_merge_sections
#define _bfd_ecoff_bfd_is_group_section bfd_generic_is_group_section
#define _bfd_ecoff_bfd_discard_group bfd_generic_discard_group
#define _bfd_ecoff_section_already_linked \
  _bfd_coff_section_already_linked
#define _bfd_ecoff_bfd_define_common_symbol bfd_generic_define_common_symbol

const bfd_target ecoffalpha_little_vec =
{
  "ecoff-littlealpha",		/* name */
  bfd_target_ecoff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | DYNAMIC | WP_TEXT | D_PAGED),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
  0,				/* leading underscore */
  ' ',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  0,				/* match priority.  */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

  {_bfd_dummy_target, alpha_ecoff_object_p, /* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, _bfd_ecoff_mkobject,  /* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
  {bfd_false, _bfd_ecoff_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (_bfd_ecoff),
     BFD_JUMP_TABLE_COPY (_bfd_ecoff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (alpha_ecoff),
     BFD_JUMP_TABLE_SYMBOLS (_bfd_ecoff),
     BFD_JUMP_TABLE_RELOCS (_bfd_ecoff),
     BFD_JUMP_TABLE_WRITE (_bfd_ecoff),
     BFD_JUMP_TABLE_LINK (_bfd_ecoff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  & alpha_ecoff_backend_data
};
@


1.49
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d1513 1
a1513 1
	  
d1520 1
a1520 1
	  
d2245 1
a2245 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE, 
@


1.48
log
@	PR ld/12762
bfd/
	* bfd-in.h (struct bfd_section_already_linked): Forward declare.
	(_bfd_handle_already_linked): Declare.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Define as
	_bfd_coff_section_already_linked.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* cofflink.c (coff_link_add_symbols): Revert 2011-07-09 changes.
	* elf-bfd.h: Likewise.
	* libbfd-in.h: Likewise.
	* targets.c: Likewise.
	* linker.c (bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(_bfd_generic_section_already_linked): Likewise.  Call
	_bfd_handle_already_linked.
	(_bfd_handle_already_linked): New function, split out from..
	* elflink.c (_bfd_elf_section_already_linked): ..here.  Revert
	2011-07-09 changes.  Avoid unnecessary strcmp when matching
	already_linked_list entries.  Match plugin linkonce section.
	(section_signature): Delete.
	* coffgen.c (_bfd_coff_section_already_linked): New function.
	* libcoff-in.h (_bfd_coff_section_already_linked): Declare.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (section_already_linked): Revert 2011-07-09 changes.
	* plugin.c: Likewise.
	(asymbol_from_plugin_symbol): Create linkonce section for syms
	with comdat_key.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
d40 1
a40 34
static const bfd_target *alpha_ecoff_object_p
  PARAMS ((bfd *));
static bfd_boolean alpha_ecoff_bad_format_hook
  PARAMS ((bfd *abfd, PTR filehdr));
static PTR alpha_ecoff_mkobject_hook
  PARAMS ((bfd *, PTR filehdr, PTR aouthdr));
static void alpha_ecoff_swap_reloc_in
  PARAMS ((bfd *, PTR, struct internal_reloc *));
static void alpha_ecoff_swap_reloc_out
  PARAMS ((bfd *, const struct internal_reloc *, PTR));
static void alpha_adjust_reloc_in
  PARAMS ((bfd *, const struct internal_reloc *, arelent *));
static void alpha_adjust_reloc_out
  PARAMS ((bfd *, const arelent *, struct internal_reloc *));
static reloc_howto_type *alpha_bfd_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static bfd_byte *alpha_ecoff_get_relocated_section_contents
  PARAMS ((bfd *abfd, struct bfd_link_info *, struct bfd_link_order *,
	   bfd_byte *data, bfd_boolean relocatable, asymbol **symbols));
static bfd_vma alpha_convert_external_reloc
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, struct external_reloc *,
	   struct ecoff_link_hash_entry *));
static bfd_boolean alpha_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, PTR));
static bfd_boolean alpha_adjust_headers
  PARAMS ((bfd *, struct internal_filehdr *, struct internal_aouthdr *));
static PTR alpha_ecoff_read_ar_hdr
  PARAMS ((bfd *));
static bfd *alpha_ecoff_get_elt_at_filepos
  PARAMS ((bfd *, file_ptr));
static bfd *alpha_ecoff_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd *alpha_ecoff_get_elt_at_index
  PARAMS ((bfd *, symindex));
a97 3
static bfd_reloc_status_type reloc_nil
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

d99 7
a105 8
reloc_nil (abfd, reloc, sym, data, sec, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc ATTRIBUTE_UNUSED;
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
d404 1
a404 2
alpha_ecoff_object_p (abfd)
     bfd *abfd;
d442 2
a443 3
alpha_ecoff_bad_format_hook (abfd, filehdr)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR filehdr;
d462 2
a463 5
static PTR
alpha_ecoff_mkobject_hook (abfd, filehdr, aouthdr)
     bfd *abfd;
     PTR filehdr;
     PTR aouthdr;
d465 1
a465 1
  PTR ecoff;
d495 3
a497 4
alpha_ecoff_swap_reloc_in (abfd, ext_ptr, intern)
     bfd *abfd;
     PTR ext_ptr;
     struct internal_reloc *intern;
d542 3
a544 4
alpha_ecoff_swap_reloc_out (abfd, intern, dst)
     bfd *abfd;
     const struct internal_reloc *intern;
     PTR dst;
d596 3
a598 4
alpha_adjust_reloc_in (abfd, intern, rptr)
     bfd *abfd;
     const struct internal_reloc *intern;
     arelent *rptr;
d687 3
a689 4
alpha_adjust_reloc_out (abfd, rel, intern)
     bfd *abfd ATTRIBUTE_UNUSED;
     const arelent *rel;
     struct internal_reloc *intern;
d728 6
a733 8
alpha_ecoff_get_relocated_section_contents (abfd, link_info, link_order,
					    data, relocatable, symbols)
     bfd *abfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocatable;
     asymbol **symbols;
d1150 2
a1151 3
alpha_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1222 5
a1226 6
alpha_convert_external_reloc (output_bfd, info, input_bfd, ext_rel, h)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     struct external_reloc *ext_rel;
     struct ecoff_link_hash_entry *h;
d1338 6
a1343 8
alpha_relocate_section (output_bfd, info, input_bfd, input_section,
			contents, external_relocs)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     PTR external_relocs;
d1993 3
a1995 4
alpha_adjust_headers (abfd, fhdr, ahdr)
     bfd *abfd;
     struct internal_filehdr *fhdr;
     struct internal_aouthdr *ahdr ATTRIBUTE_UNUSED;
d2027 2
a2028 3
static PTR
alpha_ecoff_read_ar_hdr (abfd)
     bfd *abfd;
d2052 1
a2052 1
  return (PTR) ret;
d2059 1
a2059 3
alpha_ecoff_get_elt_at_filepos (archive, filepos)
     bfd *archive;
     file_ptr filepos;
d2172 1
a2172 1
  nbfd->iostream = (PTR) bim;
d2190 1
a2190 3
alpha_ecoff_openr_next_archived_file (archive, last_file)
     bfd *archive;
     bfd *last_file;
d2236 7
a2242 7
    (void (*) PARAMS ((bfd *,PTR,int,int,int,int,PTR))) bfd_void, /* aux_in */
    (void (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* sym_in */
    (void (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* lineno_in */
    (unsigned (*) PARAMS ((bfd *,PTR,int,int,int,int,PTR)))bfd_void,/*aux_out*/
    (unsigned (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* sym_out */
    (unsigned (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* lineno_out */
    (unsigned (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* reloc_out */
d2393 1
a2393 1
  (PTR) &alpha_ecoff_backend_data
@


1.47
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d2406 1
a2406 1
  _bfd_generic_section_already_linked
@


1.46
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d2396 3
@


1.45
log
@2010-05-25  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c: Declare and define _bfd_memory_iovec.
	(bfd_bread): Move code for BFD_IN_MEMORY...
	(bfd_bwrite): ... Ditto ...
	(bfd_tell): ... Ditto ...
	(bfd_flush): ... Ditto ...
	(bfd_stat): ... Ditto ...
	(bfd_seek): ... Ditto ...
	(bfd_get_size): ... Ditto ...
	(bfd_mmap): ... Ditto ...
	(memory_bread): ... to these new functions.
	(memory_bwrite): Ditto.
	(memory_btell): Ditto.
	(memory_bseek): Ditto.
	(memory_bflush): Ditto.
	(memory_bstat): Ditto.
	(memory_bmmap): Ditto.
	(memory_bclose): New function.
	* peicode.h (pe_ILF_build_a_bfd): Use BFD_IN_MEMORY.
	* xcofflink.c (bfd_xcoff_link_generate_rtinit): Ditto.
	* opncls.c (bfd_close): Do not handle BFD_IN_MEMORY case.
	(bfd_make_writable): Use _bfd_memory_iovec.
	* elfcode.h (bfd_from_remote_memory): Use _bfd_memory_iovec.
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Use
	_bfd_memory_iovec.
	(alpha_ecoff_openr_next_archived_file): Use proxy_origin
	instead of origin.
	* libbfd.h: Regenerate.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2007, 2008, 2009, 2010
d2421 1
@


1.44
log
@Update copyright year.

2010-03-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-target.h: Update copyright year.
	* aout-tic30.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* elf64-mips.c: Likewise.
	* ieee.c: Likewise.
	* libecoff.h: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* oasys.c: Likewise.
	* targets.c: Likewise.
@
text
@d2229 2
d2269 1
a2269 1
      filestart = last_file->origin + size;
@


1.43
log
@2010-01-26  Tristan Gingold  <gingold@@adacore.com>

	* targets.c (BFD_JUMP_TABLE_ARCHIVE): Add initializer for write_ar_hdr.
	(bfd_target): Add _bfd_write_ar_hdr_fn field.
	* archive.c (is_bsd44_extended_name): New macro.
	(_bfd_generic_read_ar_hdr_mag): Use it.  Add extra_size.
	(bfd_slurp_armap): Also check for "__.SYMDEF" as a BSD4.4 extended
	name.
	(_bfd_archive_bsd44_construct_extended_name_table): New function.
	(_bfd_generic_write_ar_hdr): Ditto.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_archive_contents): Call _bfd_write_ar_hdr.
	(bsd_write_armap): Adjust firstreal computation.
	* libbfd-in.h (struct areltdata): Add extra_size field.
	(_bfd_generic_write_ar_hdr): Add prototype.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_ar_hdr): Define.
	(_bfd_noarchive_write_ar_hdr): Ditto.
	(_bfd_archive_bsd_write_ar_hdr): Ditto.
	(_bfd_archive_coff_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_slurp_armap): Ditto.
	(_bfd_archive_bsd44_slurp_extended_name_table): Ditto.
	(_bfd_archive_bsd44_construct_extended_name_table): New prototype.
	(_bfd_archive_bsd44_truncate_arname): Ditto.
	(_bfd_archive_bsd44_write_armap): Ditto.
	(_bfd_archive_bsd44_read_ar_hdr): Ditto.
	(_bfd_archive_bsd44_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_openr_next_archived_file): Ditto.
	(_bfd_archive_bsd44_get_elt_at_index): Ditto.
	(_bfd_archive_bsd44_generic_stat_arch_elt): Ditto.
	(_bfd_archive_bsd44_update_armap_timestamp): Ditto.
	* libbfd.h: Regenerate.
	* oasys.c (oasys_write_ar_hdr): Define.
	* libecoff.h (_bfd_ecoff_write_ar_hdr): Define.
	* ieee.c (ieee_write_ar_hdr): Define.
	* elf64-mips.c (bfd_elf64_archive_write_ar_hdr): Define.
	* coff-rs6000.c (rs6000coff_vec): Adjust for write_ar_hdr field.
	(bfd_pmac_xcoff_backend_data): Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(bfd_xcoff_aix5_backend_data): Ditto.
	* coff-alpha.c (alpha_ecoff_write_ar_hdr): Define.
	* aout-target.h (MY_write_ar_hdr): Define it if not defined.
	* aout-tic30.c (MY_write_ar_hdr): Ditto.
	* mach-o-target.c (TARGET_NAME): Use _bfd_archive_bsd44 archive.
	(bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved to mach-o.c
	* mach-o.c (bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved from mach-o-target.c
	* bfd-in2.h: Regenerate.
@
text
@d3 2
a4 1
   2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.42
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2068 1
@


1.41
log
@	PR binutils/10785
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Don't bfd_alloc
	bim and bim->buffer.  bfd_malloc instead.
	* peicode.h (pe_ILF_build_a_bfd): Similarly.
	(ILF_DATA_SIZE): Don't include bim.
	* opncls.c (bfd_close): Test bim->buffer non-NULL before freeing.
@
text
@d2275 1
a2275 3
alpha_ecoff_get_elt_at_index (abfd, index)
     bfd *abfd;
     symindex index;
d2279 1
a2279 1
  entry = bfd_ardata (abfd)->symdefs + index;
@


1.40
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d2123 1
d2155 1
a2155 3
  if (size == 0)
    buf = NULL;
  else
d2162 1
a2162 1
      buf = (bfd_byte *) bfd_alloc (nbfd, size);
d2216 1
a2216 1
	 bfd_alloc (nbfd, (bfd_size_type) sizeof (struct bfd_in_memory)));
d2232 2
@


1.40.6.1
log
@2009-10-16  Alan Modra  <amodra@@bigpond.net.au>

	PR binutils/10785
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Don't bfd_alloc
	bim and bim->buffer.  bfd_malloc instead.
	* peicode.h (pe_ILF_build_a_bfd): Similarly.
	(ILF_DATA_SIZE): Don't include bim.
	* opncls.c (bfd_close): Test bim->buffer non-NULL before freeing.
@
text
@a2122 1
  buf = NULL;
d2154 3
a2156 1
  if (size != 0)
d2163 1
a2163 1
      buf = (bfd_byte *) bfd_malloc (size);
d2217 1
a2217 1
	 bfd_malloc ((bfd_size_type) sizeof (struct bfd_in_memory)));
a2232 2
  if (buf != NULL)
    free (buf);
@


1.39
log
@bfd/ChangeLog

	* coff-alpha.c (alpha_ecoff_backend_data):  Initialise fields which
	control long section name handling with ECOFF_NO_LONG_SECTION_NAMES.
	* coff-mips.c (mips_ecoff_backend_data):  Likewise.
	* coff-rs6000.c (bfd_xcoff_backend_data):  Initialise fields which
	control long section name handling with XCOFF_NO_LONG_SECTION_NAMES.
	(bfd_pmac_xcoff_backend_data):  Likewise.
	* coff64-rs6000.c (bfd_xcoff_backend_data):  Likewise.
	(bfd_xcoff_aix5_backend_data):  Likewise.
	(xcoff64_write_object_contents):  Delete unused long_section_names
	local variable.
	* coff-sh.c (bfd_coff_small_swap_table):  Initialise long section
	name members using COFF_DEFAULT_LONG_SECTION_NAMES and make entire
	struct non-const.
	* coffcode.h (documentation):  Update to describe long section names.
	(COFFLONGSECTIONCATHELPER):  New helper macro.
	(BLANKOR1TOODD):  Likewise.
	(COFF_ENABLE_LONG_SECTION_NAMES):  Likewise.
	(COFF_LONG_SECTION_NAMES_SETTER):  Likewise.
	(COFF_DEFAULT_LONG_SECTION_NAMES):  Likewise.
	(bfd_coff_set_long_section_names_allowed):  New function.
	(bfd_coff_set_long_section_names_disallowed):  Likewise.
	(struct bfd_coff_backend_data):  Add new backend hook function
	pointer _bfd_coff_set_long_section_names.
	(bfd_coff_set_long_section_names):  New backend hook.
	(coff_write_object_contents):  Only generate long section names if
	bfd_coff_long_section_names() indicates they are currently enabled.
	(bfd_coff_std_swap_table):  Make non-const, and initialise long
	section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff0_swap_table):  Likewise to both.
	(ticoff1_swap_table):  Again, likewise to both.
	* coffgen.c (make_a_section_from_file):  Allow long section names
	as inputs even if not currently allowed for outputs.
	* ecoff.c (_bfd_ecoff_no_long_sections):  New function.
	* efi-app-ia32.c (COFF_LONG_SECTION_NAMES):  Define to 0, not blank.
	* efi-app-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-app-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-arm.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-i386.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mcore.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mips.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-ppc.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-sh.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* libcoff-in.h:  Update copyright year to cause updated copyright
	year in generated libcoff.h, and fix typo.
	* libcoff.h:  Regenerated.
	* libecoff.h (ECOFF_NO_LONG_SECTION_NAMES):  New macro.
	(_bfd_ecoff_no_long_sections):  Add prototype.
	* libxcoff.h (XCOFF_NO_LONG_SECTION_NAMES):  New macro.
	* pe-mips.c (COFF_LONG_SECTION_NAMES):  Define empty if not already
	defined by an including .c file.
	* ticoff.h (ticoff0_swap_table):  Make non-const, and initialise
	long section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff1_swap_table):  Likewise to both.

ld/ChangeLog

	* ld.texinfo:  Update to mention long section name options.
	* NEWS:  Mention new behaviour and command-line options.
	* pe-dll.c (pe_use_coff_long_section_names):  New global variable.
	(pe_output_file_set_long_section_names):  New function.
	(pe_dll_build_sections):  Call it on output BFDs.
	(pe_exe_build_sections):  Likewise.
	(pe_dll_fill_sections):  Likewise.
	(pe_exe_fill_sections):  Likewise.
	* pe-dll.h (pe_use_coff_long_section_names):  Declare extern.
	(pe_output_file_set_long_section_names):  Add prototype.
	* pep-dll.c (pe_use_coff_long_section_names):  Define pep_ alias.
	(pe_output_file_set_long_section_names):  Likewise.
	* pep-dll.h (pep_use_coff_long_section_names):  Declare extern.
	(pep_output_file_set_long_section_names):  Add prototype.
	* pe.em (OPTION_ENABLE_LONG_SECTION_NAMES):  New getopt value macro.
	(OPTION_DISABLE_LONG_SECTION_NAMES):  Likewise.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pe_output_file_set_long_section_names.
	* pep.em (enum options):  Extend enum with new getopt option values.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pep_output_file_set_long_section_names.

ld/testsuite/ChangeLog

	* ld-pe/longsecn-1.d:  New test file.
	* ld-pe/longsecn-2.d:  Likewise.
	* ld-pe/longsecn-3.d:  Likewise.
	* ld-pe/longsecn-4.d:  Likewise.
	* ld-pe/longsecn-5.d:  Likewise.
	* ld-pe/longsecn.d:  Likewise.
	* ld-pe/longsecn.exp:  New test control script.
	* ld-pe/longsecn.s:  New test source file.
@
text
@d2401 1
@


1.38
log
@        * pe-arm-wince.c (pe_print_compressed_pdata): Define new function to
        print compressed pdata structure as described on MSDN. This only
        applies to a limited set of architectures (ARM, SH4).
        (slurp_symtab, my_symbol_for_address): Define static helper
        functions for pe_print_compressed_pdata.
        * coffcode.h (bfd_coff_backend_data): Add _bfd_coff_print_pdata field.
        (bfd_coff_have_print_pdata, bfd_coff_print_pdata): Define.
        * bfd/peXXigen.c (_bfd_XX_print_private_bfd_data_common): Add check on
        bfd_coff_backend_data, call the function if non-null.
        * pei-mcore.c: Add target dependent initialisation for
        bfd_coff_backend_data.
        * coff-sh.c: Likewise.
        * coff64-rs6000.c: Likewise.
        * coff-rs6000.c: Likewise.
        * libcoff-in.h: Likewise.
        * cf-i386lynx.c: Likewise.
        * coff-alpha.c: Likewise.
        * coff-apollo.c: Likewise.
        * coff-arm.c: Likewise.
        * coff-aux.c: Likewise.
        * coff-h8300.c: Likewise.
        * coff-h8500.c: Likewise.
        * coff-i386.c: Likewise.
        * coff-i860.c: Likewise.
        * coff-i960.c: Likewise.
        * coff-ia64.c: Likewise.
        * coff-m68k.c: Likewise.
        * coff-m88k.c: Likewise.
        * coff-maxq.c: Likewise.
        * coff-mips.c: Likewise.
        * coff-or32.c: Likewise.
        * coff-sparc.c: Likewise.
        * coff-tic30.c: Likewise.
        * coff-tic4x.c: Likewise.
        * coff-tic54x.c: Likewise.
        * coff-tic80.c: Likewise.
        * coff-w65.c: Likewise.
        * coff-we32k.c: Likewise.
        * coff-x86_64.c: Likewise.
        * coff-z80.c: Likewise.
        * coff-z8k.c: Likewise.
        * pe-mcore.c: Likewise.
        * pe-mips.c: Likewise.
        * pe-ppc.c: Likewise.
        * peXXigen.c: Likewise.
        * pei-ppc.c: Likewise.
        * libcoff.h: Regenerate.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
d2300 2
a2301 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE, FALSE, 4, FALSE, 2,
@


1.37
log
@	* ecoff.c (_bfd_ecoff_archive_p): Delete.
	* libecoff.h (_bfd_ecoff_archive_p): Delete.
	* coff-alpha.c (ecoffalpha_little_vec): Use bfd_generic_archive_p.
	* coff-mips.c (ecoff_little_vec, ecoff_big_vec): Likewise.
	(ecoff_biglittle_vec): Likewise.
@
text
@d2307 1
a2307 1
    NULL, NULL, NULL
@


1.36
log
@Switch sources over to use the GPL version 3
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2007 Free Software Foundation, Inc.
d2424 1
a2424 1
     _bfd_ecoff_archive_p, _bfd_dummy_target},
@


1.35
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.34
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.33
log
@Fix spelling typo in comment
@
text
@d3 1
a3 1
   2003, 2004, 2005 Free Software Foundation, Inc.
d1247 16
d2380 2
@


1.32
log
@Add code to detect and either handle or issue an error message for binaries
created by the DEC ALPHA compilers.
@
text
@d613 1
a613 1
     fails with object files prodiced by DEC's C++ compiler.
@


1.31
log
@coff-alpha.c (alpha_adjust_reloc_in): Issue an informative error message if an
  unknown reloc is encountered.
  (alpha_relocate_section): Likewise.
ecoff.c (_bfd_ecoff_write_object_contents): Cope with a reloc with a missing
  howto field.
@
text
@d484 2
a485 2
  if (ALPHA_ECOFF_BADMAG (*internal_f))
    return FALSE;
d487 7
a493 1
  return TRUE;
d612 3
d616 1
a616 1
	      || (intern->r_symndx >= 0 && intern->r_symndx <= 14));
@


1.30
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d635 9
a643 1
    abort ();
d1532 14
d1547 5
a1551 1
	  abort ();
@


1.29
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.28
log
@update copyright dates
@
text
@d21 1
a21 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.27
log
@Remove redundant test in BFD_ASSERT
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
@


1.26
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d671 1
a671 1
      BFD_ASSERT (intern->r_offset <= 256 && intern->r_size <= 256);
@


1.25
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@a1223 17
#if 0
    case ???:
      alpha_type = ALPHA_R_OP_PUSH;
      break;
    case ???:
      alpha_type = ALPHA_R_OP_STORE;
      break;
    case ???:
      alpha_type = ALPHA_R_OP_PSUB;
      break;
    case ???:
      alpha_type = ALPHA_R_OP_PRSHIFT;
      break;
    case ???:
      alpha_type = ALPHA_R_GPVALUE;
      break;
#endif
@


1.24
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d1148 2
a1149 1
		     (link_info, bfd_asymbol_name (*rel->sym_ptr_ptr),
d1964 2
a1965 1
			   (info, name, alpha_howto_table[r_type].name,
@


1.23
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d2359 2
@


1.22
log
@	* section.c (struct sec): Remove usused flags.  Reorganize a little.
	(bfd_get_section_size_before_reloc): Delete.
	(bfd_get_section_size_after_reloc): Delete.
	(STD_SECTION): Update.
	(bfd_get_section_size_now): Delete.
	(bfd_set_section_contents): Don't referece reloc_done.
	(bfd_get_section_contents): Remove reloc_done comment.
	* bout.c (b_out_bfd_get_relocated_section_contents): Don't set
	reloc_done.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents): Likewise.
	* ecoff.c (bfd_debug_section): Update initializer.
	* elfxx-mips.c (_bfd_elf_mips_get_relocated_section_contents): Ditto.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* bfd-in.h (bfd_section_size): Expand.
	(bfd_get_section_size): New macro.
	* bfd-in2.h: Regenerate.
	* coff64-rs6000.c (xcoff64_write_object_contents): Replace
	bfd_get_section_size_before_reloc with bfd_get_section_size.
	* coffcode.h (coff_write_object_contents): Likewise.
	* coffgen.c (build_debug_section): Likewise.
	* dwarf1.c (parse_line_table): Likewise.
	(_bfd_dwarf1_find_nearest_line): Likewise.
	* ecoff.c (_bfd_ecoff_write_object_contents): Likewise.
	* i386msdos.c (msdos_write_object_contents): Likewise.
	* pdp11.c (squirt_out_relocs): Likewise.
	* elf32-sh64.c (sh64_find_section_for_address): Remove comment.
	* elf64-mmix.c (mmix_elf_final_link): Update comment.
@
text
@d465 2
a466 2
	  BFD_ASSERT (size == bfd_section_size (abfd, sec)
		      || size + 8 == bfd_section_size (abfd, sec));
d771 1
d782 2
a783 2
  if (! bfd_get_section_contents (input_bfd, input_section, data,
				  (file_ptr) 0, input_section->_raw_size))
a785 3
  /* The section size is not going to change.  */
  input_section->_cooked_size = input_section->_raw_size;

d1470 1
a1470 3
	  lita_size = lita_sec->_cooked_size;
	  if (lita_size == 0)
	    lita_size = lita_sec->_raw_size;
@


1.21
log
@* coff-alpha.c (alpha_relocate_section): Set used_by_bfd directly
as ecoff_section_data() does not return a valid lvalue.
@
text
@a786 1
  input_section->reloc_done = TRUE;
@


1.20
log
@	* section.c (bfd_make_section_anyway): Add all sections to hash tab.

	* elf-bfd.h (bfd_elf_is_group_section): Declare.
	* elf.c (bfd_elf_is_group_section): New function.
	* elfxx-target.h (bfd_elfNN_bfd_is_group_section
	* section.c (bfd_generic_is_group_section): New function.
	* targets.c (struct bfd_target): Add _bfd_is_group_section field.
	(BFD_JUMP_TABLE_LINK): Adjust.
	* aout-adobe.c (aout_32_bfd_is_group_section): Define.
	* aout-target.h (MY_bfd_is_group_section): Define.
	* aout-tic30.c (MY_bfd_is_group_section): Define.
	* bfd.c (bfd_is_group_section): Define.
	* binary.c (binary_bfd_is_group_section): Define.
	* bout.c (b_out_bfd_is_group_section): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-mips.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Adjust.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Adjust.
	* coffcode.h (coff_bfd_is_group_section): Define.
	* i386msdos.c (msdos_bfd_is_group_section): Define.
	* i386os9k.c (os9k_bfd_is_group_section): Define.
	* ieee.c (ieee_bfd_is_group_section): Define.
	* ihex.c (ihex_bfd_is_group_section): Define.
	* libbfd-in.h (_bfd_nolink_bfd_is_group_section): Define.
	* mach-o.c (bfd_mach_o_bfd_is_group_section): Define.
	* mmo.c (mmo_bfd_is_group_section): Define.
	* nlm-target.h (nlm_bfd_is_group_section): Define.
	* oasys.c (oasys_bfd_is_group_section): Define.
	* pef.c (bfd_pef_bfd_is_group_section): Define.
	* ppcboot.c (ppcboot_bfd_is_group_section): Define.
	* srec.c (srec_bfd_is_group_section): Define.
	* tekhex.c (tekhex_bfd_is_group_section): Define.
	* versados.c (versados_bfd_is_group_section): Define.
	* vms.c (vms_bfd_is_group_section): Define.
	* xsym.c (bfd_sym_bfd_is_group_section): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d1458 1
a1458 1
	  ecoff_section_data (input_bfd, lita_sec) = lita_sec_data;
@


1.19
log
@Correct spelling of "relocatable".
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d2362 1
@


1.19.14.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004 Free Software Foundation, Inc.
d465 2
a466 2
	  BFD_ASSERT (size == sec->size
		      || size + 8 == sec->size);
a770 1
  bfd_size_type sz;
d781 2
a782 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (! bfd_get_section_contents (input_bfd, input_section, data, 0, sz))
d785 4
d1458 1
a1458 1
	  lita_sec->used_by_bfd = lita_sec_data;
d1473 3
a1475 1
	  lita_size = lita_sec->size;
a2361 1
#define _bfd_ecoff_bfd_is_group_section bfd_generic_is_group_section
a2362 2
#define _bfd_ecoff_section_already_linked \
  _bfd_generic_section_already_linked
@


1.18
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d56 1
a56 1
	   bfd_byte *data, bfd_boolean relocateable, asymbol **symbols));
d756 1
a756 1
					    data, relocateable, symbols)
d761 1
a761 1
     bfd_boolean relocateable;
d769 1
a769 1
  bfd *output_bfd = relocateable ? abfd : (bfd *) NULL;
d801 1
a801 1
      if (relocateable)
d861 1
a861 1
	  if (relocateable
d994 1
a994 1
	    if (relocateable)
d1027 1
a1027 1
	    if (relocateable)
d1054 1
a1054 1
	    if (relocateable)
d1087 1
a1087 1
	    if (relocateable)
d1124 1
a1124 1
      if (relocateable)
d1251 1
a1251 1
   external reloc when generating relocateable output.  Returns the
d1265 1
a1265 1
  BFD_ASSERT (info->relocateable);
d1446 1
a1446 1
  if (! info->relocateable && lita_sec != NULL)
d1555 1
a1555 1
	  if (info->relocateable)
d1708 1
a1708 1
	      if (! info->relocateable)
d1751 1
a1751 1
	  if (info->relocateable)
d1785 1
a1785 1
	     we are generating relocateable output, all we do is
d1787 1
a1787 1
	  if (! info->relocateable)
d1853 1
a1853 1
	  if (info->relocateable)
d1855 1
a1855 1
	      /* We are generating relocateable output, and must
d1978 1
a1978 1
      if (info->relocateable && adjust_addrp)
@


1.17
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d38 14
a51 13
static const bfd_target *alpha_ecoff_object_p PARAMS ((bfd *));
static boolean alpha_ecoff_bad_format_hook PARAMS ((bfd *abfd, PTR filehdr));
static PTR alpha_ecoff_mkobject_hook PARAMS ((bfd *, PTR filehdr, PTR aouthdr));
static void alpha_ecoff_swap_reloc_in PARAMS ((bfd *, PTR,
					      struct internal_reloc *));
static void alpha_ecoff_swap_reloc_out PARAMS ((bfd *,
					       const struct internal_reloc *,
					       PTR));
static void alpha_adjust_reloc_in PARAMS ((bfd *,
					   const struct internal_reloc *,
					   arelent *));
static void alpha_adjust_reloc_out PARAMS ((bfd *, const arelent *,
					    struct internal_reloc *));
d53 1
a53 1
 PARAMS ((bfd *, bfd_reloc_code_real_type));
d56 1
a56 1
	   bfd_byte *data, boolean relocateable, asymbol **symbols));
d60 3
a62 4
static boolean alpha_relocate_section PARAMS ((bfd *, struct bfd_link_info *,
					       bfd *, asection *,
					       bfd_byte *, PTR));
static boolean alpha_adjust_headers
d64 8
a71 4
static PTR alpha_ecoff_read_ar_hdr PARAMS ((bfd *));
static bfd *alpha_ecoff_get_elt_at_filepos PARAMS ((bfd *, file_ptr));
static bfd *alpha_ecoff_openr_next_archived_file PARAMS ((bfd *, bfd *));
static bfd *alpha_ecoff_get_elt_at_index PARAMS ((bfd *, symindex));
d129 2
a130 3
static bfd_reloc_status_type
reloc_nil PARAMS ((bfd *, arelent *, asymbol *, PTR,
		   asection *, bfd *, char **));
d158 1
a158 1
	 true,			/* pc_relative */
d163 1
a163 1
	 true,			/* partial_inplace */
d166 1
a166 1
	 true),			/* pcrel_offset */
d173 1
a173 1
	 false,			/* pc_relative */
d178 1
a178 1
	 true,			/* partial_inplace */
d181 1
a181 1
	 false),		/* pcrel_offset */
d188 1
a188 1
	 false,			/* pc_relative */
d193 1
a193 1
	 true,			/* partial_inplace */
d196 1
a196 1
	 false),		/* pcrel_offset */
d205 1
a205 1
	 false,			/* pc_relative */
d210 1
a210 1
	 true,			/* partial_inplace */
d213 1
a213 1
	 false),		/* pcrel_offset */
d222 1
a222 1
	 false,			/* pc_relative */
d227 1
a227 1
	 true,			/* partial_inplace */
d230 1
a230 1
	 false),		/* pcrel_offset */
d245 1
a245 1
	 false,			/* pc_relative */
d250 1
a250 1
	 false,			/* partial_inplace */
d253 1
a253 1
	 false),		/* pcrel_offset */
d270 1
a270 1
	 true,			/* pc_relative */
d275 1
a275 1
	 true,			/* partial_inplace */
d278 1
a278 1
	 true),			/* pcrel_offset */
d287 1
a287 1
	 true,			/* pc_relative */
d292 1
a292 1
	 true,			/* partial_inplace */
d295 1
a295 1
	 false),		/* pcrel_offset */
d302 1
a302 1
	 true,			/* pc_relative */
d307 1
a307 1
	 true,			/* partial_inplace */
d310 1
a310 1
	 false),		/* pcrel_offset */
d317 1
a317 1
	 true,			/* pc_relative */
d322 1
a322 1
	 true,			/* partial_inplace */
d325 1
a325 1
	 false),		/* pcrel_offset */
d332 1
a332 1
	 true,			/* pc_relative */
d337 1
a337 1
	 true,			/* partial_inplace */
d340 1
a340 1
	 false),		/* pcrel_offset */
d347 1
a347 1
	 true,			/* pc_relative */
d352 1
a352 1
	 true,			/* partial_inplace */
d355 1
a355 1
	 false),		/* pcrel_offset */
d362 1
a362 1
	 false,			/* pc_relative */
d367 1
a367 1
	 false,			/* partial_inplace */
d370 1
a370 1
	 false),		/* pcrel_offset */
d378 1
a378 1
	 false,			/* pc_relative */
d383 1
a383 1
	 false,			/* partial_inplace */
d386 1
a386 1
	 false),		/* pcrel_offset */
d394 1
a394 1
	 false,			/* pc_relative */
d399 1
a399 1
	 false,			/* partial_inplace */
d402 1
a402 1
	 false),		/* pcrel_offset */
d410 1
a410 1
	 false,			/* pc_relative */
d415 1
a415 1
	 false,			/* partial_inplace */
d418 1
a418 1
	 false),		/* pcrel_offset */
d425 1
a425 1
	 false,			/* pc_relative */
d430 1
a430 1
	 false,			/* partial_inplace */
d433 1
a433 1
	 false)			/* pcrel_offset */
d477 1
a477 1
static boolean
d485 1
a485 1
    return false;
d487 1
a487 1
  return true;
d761 1
a761 1
     boolean relocateable;
d771 1
a771 1
  boolean gp_undefined;
d787 1
a787 1
  input_section->reloc_done = true;
d797 1
a797 1
  gp_undefined = false;
d825 2
a826 2
	  h = bfd_link_hash_lookup (link_info->hash, "_gp", false, false,
				    true);
d829 1
a829 1
	    gp_undefined = true;
d1117 1
a1117 1
	  gp_undefined = false;
d1140 1
a1140 1
		      input_bfd, input_section, rel->address, true)))
d1371 1
a1371 1
static boolean
d1384 1
a1384 1
  boolean gp_undefined;
d1400 1
a1400 1
	return false;
d1491 1
a1491 1
		  ecoff_data (output_bfd)->issued_multiple_gp_warning = true;
d1521 3
a1523 3
      boolean relocatep;
      boolean adjust_addrp;
      boolean gp_usedp;
d1538 3
a1540 3
      relocatep = false;
      adjust_addrp = true;
      gp_usedp = false;
d1558 1
a1558 1
	  adjust_addrp = false;
d1564 1
a1564 1
	  relocatep = true;
d1573 1
a1573 1
	  relocatep = true;
d1581 1
a1581 1
	  relocatep = true;
d1583 1
a1583 1
	  gp_usedp = true;
d1614 1
a1614 1
	  relocatep = true;
d1616 1
a1616 1
	  gp_usedp = true;
d1680 1
a1680 1
	    gp_usedp = true;
d1723 2
a1724 2
			      input_section, (bfd_vma) 0, true)))
			return false;
d1740 1
a1740 1
			return false;
d1780 1
a1780 1
	  adjust_addrp = false;
d1817 1
a1817 1
	  gp_undefined = false;
d1867 1
a1867 1
			return false;
d1924 2
a1925 2
			      r_vaddr - input_section->vma, true)))
			return false;
d1971 1
a1971 1
		      return false;
d1994 1
a1994 1
	    return false;
d1998 1
a1998 1
	  gp_undefined = false;
d2005 1
a2005 1
  return true;
d2011 1
a2011 1
static boolean
d2021 1
a2021 1
  return true;
d2191 1
a2191 1
  nbfd->mtime_set = true;
d2268 1
a2268 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, true, false, 4, false, 2,
d2284 2
a2285 2
  /* True if the .rdata section is part of the text segment, as on the
     Alpha.  False if .rdata is part of the data segment, as on the
d2287 1
a2287 1
  true,
@


1.17.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d38 13
a50 14
static const bfd_target *alpha_ecoff_object_p
  PARAMS ((bfd *));
static bfd_boolean alpha_ecoff_bad_format_hook
  PARAMS ((bfd *abfd, PTR filehdr));
static PTR alpha_ecoff_mkobject_hook
  PARAMS ((bfd *, PTR filehdr, PTR aouthdr));
static void alpha_ecoff_swap_reloc_in
  PARAMS ((bfd *, PTR, struct internal_reloc *));
static void alpha_ecoff_swap_reloc_out
  PARAMS ((bfd *, const struct internal_reloc *, PTR));
static void alpha_adjust_reloc_in
  PARAMS ((bfd *, const struct internal_reloc *, arelent *));
static void alpha_adjust_reloc_out
  PARAMS ((bfd *, const arelent *, struct internal_reloc *));
d52 1
a52 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d55 1
a55 1
	   bfd_byte *data, bfd_boolean relocatable, asymbol **symbols));
d59 4
a62 3
static bfd_boolean alpha_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, PTR));
static bfd_boolean alpha_adjust_headers
d64 4
a67 8
static PTR alpha_ecoff_read_ar_hdr
  PARAMS ((bfd *));
static bfd *alpha_ecoff_get_elt_at_filepos
  PARAMS ((bfd *, file_ptr));
static bfd *alpha_ecoff_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd *alpha_ecoff_get_elt_at_index
  PARAMS ((bfd *, symindex));
d125 3
a127 2
static bfd_reloc_status_type reloc_nil
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d155 1
a155 1
	 TRUE,			/* pc_relative */
d160 1
a160 1
	 TRUE,			/* partial_inplace */
d163 1
a163 1
	 TRUE),			/* pcrel_offset */
d170 1
a170 1
	 FALSE,			/* pc_relative */
d175 1
a175 1
	 TRUE,			/* partial_inplace */
d178 1
a178 1
	 FALSE),		/* pcrel_offset */
d185 1
a185 1
	 FALSE,			/* pc_relative */
d190 1
a190 1
	 TRUE,			/* partial_inplace */
d193 1
a193 1
	 FALSE),		/* pcrel_offset */
d202 1
a202 1
	 FALSE,			/* pc_relative */
d207 1
a207 1
	 TRUE,			/* partial_inplace */
d210 1
a210 1
	 FALSE),		/* pcrel_offset */
d219 1
a219 1
	 FALSE,			/* pc_relative */
d224 1
a224 1
	 TRUE,			/* partial_inplace */
d227 1
a227 1
	 FALSE),		/* pcrel_offset */
d242 1
a242 1
	 FALSE,			/* pc_relative */
d247 1
a247 1
	 FALSE,			/* partial_inplace */
d250 1
a250 1
	 FALSE),		/* pcrel_offset */
d267 1
a267 1
	 TRUE,			/* pc_relative */
d272 1
a272 1
	 TRUE,			/* partial_inplace */
d275 1
a275 1
	 TRUE),			/* pcrel_offset */
d284 1
a284 1
	 TRUE,			/* pc_relative */
d289 1
a289 1
	 TRUE,			/* partial_inplace */
d292 1
a292 1
	 FALSE),		/* pcrel_offset */
d299 1
a299 1
	 TRUE,			/* pc_relative */
d304 1
a304 1
	 TRUE,			/* partial_inplace */
d307 1
a307 1
	 FALSE),		/* pcrel_offset */
d314 1
a314 1
	 TRUE,			/* pc_relative */
d319 1
a319 1
	 TRUE,			/* partial_inplace */
d322 1
a322 1
	 FALSE),		/* pcrel_offset */
d329 1
a329 1
	 TRUE,			/* pc_relative */
d334 1
a334 1
	 TRUE,			/* partial_inplace */
d337 1
a337 1
	 FALSE),		/* pcrel_offset */
d344 1
a344 1
	 TRUE,			/* pc_relative */
d349 1
a349 1
	 TRUE,			/* partial_inplace */
d352 1
a352 1
	 FALSE),		/* pcrel_offset */
d359 1
a359 1
	 FALSE,			/* pc_relative */
d364 1
a364 1
	 FALSE,			/* partial_inplace */
d367 1
a367 1
	 FALSE),		/* pcrel_offset */
d375 1
a375 1
	 FALSE,			/* pc_relative */
d380 1
a380 1
	 FALSE,			/* partial_inplace */
d383 1
a383 1
	 FALSE),		/* pcrel_offset */
d391 1
a391 1
	 FALSE,			/* pc_relative */
d396 1
a396 1
	 FALSE,			/* partial_inplace */
d399 1
a399 1
	 FALSE),		/* pcrel_offset */
d407 1
a407 1
	 FALSE,			/* pc_relative */
d412 1
a412 1
	 FALSE,			/* partial_inplace */
d415 1
a415 1
	 FALSE),		/* pcrel_offset */
d422 1
a422 1
	 FALSE,			/* pc_relative */
d427 1
a427 1
	 FALSE,			/* partial_inplace */
d430 1
a430 1
	 FALSE)			/* pcrel_offset */
d474 1
a474 1
static bfd_boolean
d482 1
a482 1
    return FALSE;
d484 1
a484 1
  return TRUE;
d753 1
a753 1
					    data, relocatable, symbols)
d758 1
a758 1
     bfd_boolean relocatable;
d766 1
a766 1
  bfd *output_bfd = relocatable ? abfd : (bfd *) NULL;
d768 1
a768 1
  bfd_boolean gp_undefined;
d784 1
a784 1
  input_section->reloc_done = TRUE;
d794 1
a794 1
  gp_undefined = FALSE;
d798 1
a798 1
      if (relocatable)
d822 2
a823 2
	  h = bfd_link_hash_lookup (link_info->hash, "_gp", FALSE, FALSE,
				    TRUE);
d826 1
a826 1
	    gp_undefined = TRUE;
d858 1
a858 1
	  if (relocatable
d991 1
a991 1
	    if (relocatable)
d1024 1
a1024 1
	    if (relocatable)
d1051 1
a1051 1
	    if (relocatable)
d1084 1
a1084 1
	    if (relocatable)
d1114 1
a1114 1
	  gp_undefined = FALSE;
d1121 1
a1121 1
      if (relocatable)
d1137 1
a1137 1
		      input_bfd, input_section, rel->address, TRUE)))
d1248 1
a1248 1
   external reloc when generating relocatable output.  Returns the
d1262 1
a1262 1
  BFD_ASSERT (info->relocatable);
d1368 1
a1368 1
static bfd_boolean
d1381 1
a1381 1
  bfd_boolean gp_undefined;
d1397 1
a1397 1
	return FALSE;
d1443 1
a1443 1
  if (! info->relocatable && lita_sec != NULL)
d1488 1
a1488 1
		  ecoff_data (output_bfd)->issued_multiple_gp_warning = TRUE;
d1518 3
a1520 3
      bfd_boolean relocatep;
      bfd_boolean adjust_addrp;
      bfd_boolean gp_usedp;
d1535 3
a1537 3
      relocatep = FALSE;
      adjust_addrp = TRUE;
      gp_usedp = FALSE;
d1552 1
a1552 1
	  if (info->relocatable)
d1555 1
a1555 1
	  adjust_addrp = FALSE;
d1561 1
a1561 1
	  relocatep = TRUE;
d1570 1
a1570 1
	  relocatep = TRUE;
d1578 1
a1578 1
	  relocatep = TRUE;
d1580 1
a1580 1
	  gp_usedp = TRUE;
d1611 1
a1611 1
	  relocatep = TRUE;
d1613 1
a1613 1
	  gp_usedp = TRUE;
d1677 1
a1677 1
	    gp_usedp = TRUE;
d1705 1
a1705 1
	      if (! info->relocatable)
d1720 2
a1721 2
			      input_section, (bfd_vma) 0, TRUE)))
			return FALSE;
d1737 1
a1737 1
			return FALSE;
d1748 1
a1748 1
	  if (info->relocatable)
d1777 1
a1777 1
	  adjust_addrp = FALSE;
d1782 1
a1782 1
	     we are generating relocatable output, all we do is
d1784 1
a1784 1
	  if (! info->relocatable)
d1814 1
a1814 1
	  gp_undefined = FALSE;
d1850 1
a1850 1
	  if (info->relocatable)
d1852 1
a1852 1
	      /* We are generating relocatable output, and must
d1864 1
a1864 1
			return FALSE;
d1921 2
a1922 2
			      r_vaddr - input_section->vma, TRUE)))
			return FALSE;
d1968 1
a1968 1
		      return FALSE;
d1975 1
a1975 1
      if (info->relocatable && adjust_addrp)
d1991 1
a1991 1
	    return FALSE;
d1995 1
a1995 1
	  gp_undefined = FALSE;
d2002 1
a2002 1
  return TRUE;
d2008 1
a2008 1
static bfd_boolean
d2018 1
a2018 1
  return TRUE;
d2188 1
a2188 1
  nbfd->mtime_set = TRUE;
d2265 1
a2265 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE, FALSE, 4, FALSE, 2,
d2281 2
a2282 2
  /* TRUE if the .rdata section is part of the text segment, as on the
     Alpha.  FALSE if .rdata is part of the data segment, as on the
d2284 1
a2284 1
  TRUE,
@


1.17.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d38 13
a50 14
static const bfd_target *alpha_ecoff_object_p
  PARAMS ((bfd *));
static bfd_boolean alpha_ecoff_bad_format_hook
  PARAMS ((bfd *abfd, PTR filehdr));
static PTR alpha_ecoff_mkobject_hook
  PARAMS ((bfd *, PTR filehdr, PTR aouthdr));
static void alpha_ecoff_swap_reloc_in
  PARAMS ((bfd *, PTR, struct internal_reloc *));
static void alpha_ecoff_swap_reloc_out
  PARAMS ((bfd *, const struct internal_reloc *, PTR));
static void alpha_adjust_reloc_in
  PARAMS ((bfd *, const struct internal_reloc *, arelent *));
static void alpha_adjust_reloc_out
  PARAMS ((bfd *, const arelent *, struct internal_reloc *));
d52 1
a52 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d55 1
a55 1
	   bfd_byte *data, bfd_boolean relocateable, asymbol **symbols));
d59 4
a62 3
static bfd_boolean alpha_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, PTR));
static bfd_boolean alpha_adjust_headers
d64 4
a67 8
static PTR alpha_ecoff_read_ar_hdr
  PARAMS ((bfd *));
static bfd *alpha_ecoff_get_elt_at_filepos
  PARAMS ((bfd *, file_ptr));
static bfd *alpha_ecoff_openr_next_archived_file
  PARAMS ((bfd *, bfd *));
static bfd *alpha_ecoff_get_elt_at_index
  PARAMS ((bfd *, symindex));
d125 3
a127 2
static bfd_reloc_status_type reloc_nil
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d155 1
a155 1
	 TRUE,			/* pc_relative */
d160 1
a160 1
	 TRUE,			/* partial_inplace */
d163 1
a163 1
	 TRUE),			/* pcrel_offset */
d170 1
a170 1
	 FALSE,			/* pc_relative */
d175 1
a175 1
	 TRUE,			/* partial_inplace */
d178 1
a178 1
	 FALSE),		/* pcrel_offset */
d185 1
a185 1
	 FALSE,			/* pc_relative */
d190 1
a190 1
	 TRUE,			/* partial_inplace */
d193 1
a193 1
	 FALSE),		/* pcrel_offset */
d202 1
a202 1
	 FALSE,			/* pc_relative */
d207 1
a207 1
	 TRUE,			/* partial_inplace */
d210 1
a210 1
	 FALSE),		/* pcrel_offset */
d219 1
a219 1
	 FALSE,			/* pc_relative */
d224 1
a224 1
	 TRUE,			/* partial_inplace */
d227 1
a227 1
	 FALSE),		/* pcrel_offset */
d242 1
a242 1
	 FALSE,			/* pc_relative */
d247 1
a247 1
	 FALSE,			/* partial_inplace */
d250 1
a250 1
	 FALSE),		/* pcrel_offset */
d267 1
a267 1
	 TRUE,			/* pc_relative */
d272 1
a272 1
	 TRUE,			/* partial_inplace */
d275 1
a275 1
	 TRUE),			/* pcrel_offset */
d284 1
a284 1
	 TRUE,			/* pc_relative */
d289 1
a289 1
	 TRUE,			/* partial_inplace */
d292 1
a292 1
	 FALSE),		/* pcrel_offset */
d299 1
a299 1
	 TRUE,			/* pc_relative */
d304 1
a304 1
	 TRUE,			/* partial_inplace */
d307 1
a307 1
	 FALSE),		/* pcrel_offset */
d314 1
a314 1
	 TRUE,			/* pc_relative */
d319 1
a319 1
	 TRUE,			/* partial_inplace */
d322 1
a322 1
	 FALSE),		/* pcrel_offset */
d329 1
a329 1
	 TRUE,			/* pc_relative */
d334 1
a334 1
	 TRUE,			/* partial_inplace */
d337 1
a337 1
	 FALSE),		/* pcrel_offset */
d344 1
a344 1
	 TRUE,			/* pc_relative */
d349 1
a349 1
	 TRUE,			/* partial_inplace */
d352 1
a352 1
	 FALSE),		/* pcrel_offset */
d359 1
a359 1
	 FALSE,			/* pc_relative */
d364 1
a364 1
	 FALSE,			/* partial_inplace */
d367 1
a367 1
	 FALSE),		/* pcrel_offset */
d375 1
a375 1
	 FALSE,			/* pc_relative */
d380 1
a380 1
	 FALSE,			/* partial_inplace */
d383 1
a383 1
	 FALSE),		/* pcrel_offset */
d391 1
a391 1
	 FALSE,			/* pc_relative */
d396 1
a396 1
	 FALSE,			/* partial_inplace */
d399 1
a399 1
	 FALSE),		/* pcrel_offset */
d407 1
a407 1
	 FALSE,			/* pc_relative */
d412 1
a412 1
	 FALSE,			/* partial_inplace */
d415 1
a415 1
	 FALSE),		/* pcrel_offset */
d422 1
a422 1
	 FALSE,			/* pc_relative */
d427 1
a427 1
	 FALSE,			/* partial_inplace */
d430 1
a430 1
	 FALSE)			/* pcrel_offset */
d474 1
a474 1
static bfd_boolean
d482 1
a482 1
    return FALSE;
d484 1
a484 1
  return TRUE;
d758 1
a758 1
     bfd_boolean relocateable;
d768 1
a768 1
  bfd_boolean gp_undefined;
d784 1
a784 1
  input_section->reloc_done = TRUE;
d794 1
a794 1
  gp_undefined = FALSE;
d822 2
a823 2
	  h = bfd_link_hash_lookup (link_info->hash, "_gp", FALSE, FALSE,
				    TRUE);
d826 1
a826 1
	    gp_undefined = TRUE;
d1114 1
a1114 1
	  gp_undefined = FALSE;
d1137 1
a1137 1
		      input_bfd, input_section, rel->address, TRUE)))
d1368 1
a1368 1
static bfd_boolean
d1381 1
a1381 1
  bfd_boolean gp_undefined;
d1397 1
a1397 1
	return FALSE;
d1488 1
a1488 1
		  ecoff_data (output_bfd)->issued_multiple_gp_warning = TRUE;
d1518 3
a1520 3
      bfd_boolean relocatep;
      bfd_boolean adjust_addrp;
      bfd_boolean gp_usedp;
d1535 3
a1537 3
      relocatep = FALSE;
      adjust_addrp = TRUE;
      gp_usedp = FALSE;
d1555 1
a1555 1
	  adjust_addrp = FALSE;
d1561 1
a1561 1
	  relocatep = TRUE;
d1570 1
a1570 1
	  relocatep = TRUE;
d1578 1
a1578 1
	  relocatep = TRUE;
d1580 1
a1580 1
	  gp_usedp = TRUE;
d1611 1
a1611 1
	  relocatep = TRUE;
d1613 1
a1613 1
	  gp_usedp = TRUE;
d1677 1
a1677 1
	    gp_usedp = TRUE;
d1720 2
a1721 2
			      input_section, (bfd_vma) 0, TRUE)))
			return FALSE;
d1737 1
a1737 1
			return FALSE;
d1777 1
a1777 1
	  adjust_addrp = FALSE;
d1814 1
a1814 1
	  gp_undefined = FALSE;
d1864 1
a1864 1
			return FALSE;
d1921 2
a1922 2
			      r_vaddr - input_section->vma, TRUE)))
			return FALSE;
d1968 1
a1968 1
		      return FALSE;
d1991 1
a1991 1
	    return FALSE;
d1995 1
a1995 1
	  gp_undefined = FALSE;
d2002 1
a2002 1
  return TRUE;
d2008 1
a2008 1
static bfd_boolean
d2018 1
a2018 1
  return TRUE;
d2188 1
a2188 1
  nbfd->mtime_set = TRUE;
d2265 1
a2265 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE, FALSE, 4, FALSE, 2,
d2281 2
a2282 2
  /* TRUE if the .rdata section is part of the text segment, as on the
     Alpha.  FALSE if .rdata is part of the data segment, as on the
d2284 1
a2284 1
  TRUE,
@


1.17.12.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d56 1
a56 1
	   bfd_byte *data, bfd_boolean relocatable, asymbol **symbols));
d756 1
a756 1
					    data, relocatable, symbols)
d761 1
a761 1
     bfd_boolean relocatable;
d769 1
a769 1
  bfd *output_bfd = relocatable ? abfd : (bfd *) NULL;
d801 1
a801 1
      if (relocatable)
d861 1
a861 1
	  if (relocatable
d994 1
a994 1
	    if (relocatable)
d1027 1
a1027 1
	    if (relocatable)
d1054 1
a1054 1
	    if (relocatable)
d1087 1
a1087 1
	    if (relocatable)
d1124 1
a1124 1
      if (relocatable)
d1251 1
a1251 1
   external reloc when generating relocatable output.  Returns the
d1265 1
a1265 1
  BFD_ASSERT (info->relocatable);
d1446 1
a1446 1
  if (! info->relocatable && lita_sec != NULL)
d1555 1
a1555 1
	  if (info->relocatable)
d1708 1
a1708 1
	      if (! info->relocatable)
d1751 1
a1751 1
	  if (info->relocatable)
d1785 1
a1785 1
	     we are generating relocatable output, all we do is
d1787 1
a1787 1
	  if (! info->relocatable)
d1853 1
a1853 1
	  if (info->relocatable)
d1855 1
a1855 1
	      /* We are generating relocatable output, and must
d1978 1
a1978 1
      if (info->relocatable && adjust_addrp)
@


1.16
log
@	* coff-alpha.c: Update copyright date.
	* coff-mips.c: Likewise.
	* xcoff-target.h: Likewise.
@
text
@d798 1
a798 1
      if (relocateable != false)
@


1.15
log
@	* bfd-in.h: Remove "taken from the source" comment.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	* elf.c (bfd_elf_discard_group): Return true.
	* elf-bfd.h (bfd_elf_discard_group): Declare.
	* bfd-in.h (bfd_elf_discard_group): Don't declare here.
	* section.c (bfd_discard_group): Rename to bfd_generic_discard_group.
	* bfd.c (bfd_discard_group): Define.
	* targets.c (struct bfd_target): Add _bfd_discard_group.
	(BFD_JUMP_TABLE_LINK): Here too.
	* libbfd-in.h (_bfd_nolink_bfd_discard_group): Define.
	* aout-adobe.c (aout_32_bfd_discard_group): Define.
	* aout-target.h (MY_bfd_discard_group): Define.
	* aout-tic30.c (MY_bfd_discard_group): Define.
	* binary.c (binary_bfd_discard_group): Define.
	* bout.c (b_out_bfd_discard_group): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_discard_group): Define.
	* coffcode.h (coff_bfd_discard_group): Define.
	* coff-mips.c (_bfd_ecoff_bfd_discard_group): Define.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Define.
	* i386msdos.c (msdos_bfd_discard_group): Define.
	* i386os9k.c (os9k_bfd_discard_group): Define.
	* ieee.c (ieee_bfd_discard_group): Define.
	* ihex.c (ihex_bfd_discard_group): Define.
	* mmo.c (mmo_bfd_discard_group): Define.
	* nlm-target.h (nlm_bfd_discard_group): Define.
	* oasys.c (oasys_bfd_discard_group): Define.
	* ppcboot.c (ppcboot_bfd_discard_group): Define.
	* som.c (som_bfd_discard_group): Define.
	* srec.c (srec_bfd_discard_group): Define.
	* tekhex.c (tekhex_bfd_discard_group): Define.
	* versados.c (versados_bfd_discard_group): Define.
	* vms.c (vms_bfd_discard_group): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_discard_group): Define.
	* coff64-rs6000.c (rs6000coff64_vec): Update initialiser.
	(aix5coff64_vec): Likewise.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
@


1.14
log
@	* coff-alpha.c (alpha_relocate_section): Unify warning message
	for GP relative relocations without GP defined.
	* coff-mips.c (mips_relocate_section): Likewise.
@
text
@d2359 1
@


1.14.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
a2358 1
#define _bfd_ecoff_bfd_discard_group bfd_generic_discard_group
@


1.14.10.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d798 1
a798 1
      if (relocateable)
@


1.14.8.1
log
@merge from trunk
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
a2358 1
#define _bfd_ecoff_bfd_discard_group bfd_generic_discard_group
@


1.13
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1989 1
a1989 1
		 (info, _("GP relative relocation when GP not defined"),
@


1.12
log
@	* coffcode.h (coff_write_object_contents): Add ATTRIBUTE_UNUSED to
	silence warning.
	* coffgen.c (coff_print_symbol): Fix warnings.
	(coff_find_nearest_line): Likewise.
	* cofflink.c (_bfd_coff_link_input_bfd): Likewise.
	* coff-alpha.c (alpha_convert_external_reloc): Likewise.
	* format.c (bfd_check_format_matches): Likewise.
	(bfd_set_format): Likewise.
	* coff-ia64.c: Add missing prototypes.
	* elf64-alpha.c (struct alpha_elf_link_hash_entry): Make addend
	signed to silence warnings.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_find_reloc_at_ofs): Fix warnings.
	(elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_final_link): Likewise.
	(elf64_alpha_relax_section): Remove redundant assign to info.gotent.
	(elf64_alpha_merge_gots): Add ATTRIBUTE_UNUSED to unused args.
	(elf64_alpha_size_got_sections): Likewise.
	* elfxx-ia64.c: Add missing prototypes.
	(elfNN_ia64_relocate_section): Fix warning.
	(elfNN_ia64_unwind_entry_compare): Make params const.
@
text
@d79 26
a104 26
#define GET_FILEHDR_SYMPTR bfd_h_get_64
#define PUT_FILEHDR_SYMPTR bfd_h_put_64
#define GET_AOUTHDR_TSIZE bfd_h_get_64
#define PUT_AOUTHDR_TSIZE bfd_h_put_64
#define GET_AOUTHDR_DSIZE bfd_h_get_64
#define PUT_AOUTHDR_DSIZE bfd_h_put_64
#define GET_AOUTHDR_BSIZE bfd_h_get_64
#define PUT_AOUTHDR_BSIZE bfd_h_put_64
#define GET_AOUTHDR_ENTRY bfd_h_get_64
#define PUT_AOUTHDR_ENTRY bfd_h_put_64
#define GET_AOUTHDR_TEXT_START bfd_h_get_64
#define PUT_AOUTHDR_TEXT_START bfd_h_put_64
#define GET_AOUTHDR_DATA_START bfd_h_get_64
#define PUT_AOUTHDR_DATA_START bfd_h_put_64
#define GET_SCNHDR_PADDR bfd_h_get_64
#define PUT_SCNHDR_PADDR bfd_h_put_64
#define GET_SCNHDR_VADDR bfd_h_get_64
#define PUT_SCNHDR_VADDR bfd_h_put_64
#define GET_SCNHDR_SIZE bfd_h_get_64
#define PUT_SCNHDR_SIZE bfd_h_put_64
#define GET_SCNHDR_SCNPTR bfd_h_get_64
#define PUT_SCNHDR_SCNPTR bfd_h_put_64
#define GET_SCNHDR_RELPTR bfd_h_get_64
#define PUT_SCNHDR_RELPTR bfd_h_put_64
#define GET_SCNHDR_LNNOPTR bfd_h_get_64
#define PUT_SCNHDR_LNNOPTR bfd_h_put_64
d533 2
a534 2
  intern->r_vaddr = bfd_h_get_64 (abfd, (bfd_byte *) ext->r_vaddr);
  intern->r_symndx = bfd_h_get_32 (abfd, (bfd_byte *) ext->r_symndx);
d606 2
a607 2
  bfd_h_put_64 (abfd, intern->r_vaddr, (bfd_byte *) ext->r_vaddr);
  bfd_h_put_32 (abfd, symndx, (bfd_byte *) ext->r_symndx);
d774 1
a774 1
  reloc_vector = (arelent **) bfd_malloc (reloc_size);
d1280 1
a1280 1
      r_symndx = -1;
d1359 1
a1359 2
  bfd_h_put_32 (input_bfd, (bfd_vma) r_symndx,
		(bfd_byte *) ext_rel->r_symndx);
d1386 1
d1394 2
a1395 4
      symndx_to_section = ((asection **)
			   bfd_alloc (input_bfd,
				      (NUM_RELOC_SECTIONS
				       * sizeof (asection *))));
d1452 1
d1454 1
a1454 2
			   bfd_zalloc (input_bfd,
				       sizeof (struct ecoff_section_tdata)));
d1523 2
a1524 2
      r_vaddr = bfd_h_get_64 (input_bfd, (bfd_byte *) ext_rel->r_vaddr);
      r_symndx = bfd_h_get_32 (input_bfd, (bfd_byte *) ext_rel->r_symndx);
d1553 2
a1554 3
	    bfd_h_put_64 (input_bfd,
			  input_section->output_offset + r_vaddr,
			  (bfd_byte *) ext_rel->r_vaddr);
d1751 1
a1751 2
	      bfd_h_put_64 (input_bfd, addend,
			    (bfd_byte *) ext_rel->r_vaddr);
d1978 6
a1983 6
	  bfd_h_put_64 (input_bfd,
			(input_section->output_section->vma
			 + input_section->output_offset
			 - input_section->vma
			 + r_vaddr),
			(bfd_byte *) ext_rel->r_vaddr);
d2061 3
a2063 3
      if (bfd_seek (abfd, FILHSZ, SEEK_CUR) != 0
	  || bfd_read (ab, 1, 8, abfd) != 8
	  || bfd_seek (abfd, - (FILHSZ + 8), SEEK_CUR) != 0)
d2066 1
a2066 1
      ret->parsed_size = bfd_h_get_64 (abfd, ab);
d2104 1
a2104 1
     memory buffer, and making bfd_read and bfd_seek use that buffer.
d2111 1
a2111 1
  if (bfd_seek (nbfd, FILHSZ, SEEK_SET) != 0)
d2115 1
a2115 1
  if (bfd_read (ab, 1, 8, nbfd) != 8)
d2117 1
a2117 1
  size = bfd_h_get_64 (nbfd, ab);
d2136 1
a2136 1
      if (bfd_read (ab, 1, 8, nbfd) != 8)
d2147 1
a2147 1
      while (bfd_read (&b, 1, 1, nbfd) == 1)
d2159 1
a2159 1
		  if (! bfd_read (&n, 1, 1, nbfd))
d2182 1
a2182 1
	 bfd_alloc (nbfd, sizeof (struct bfd_in_memory)));
@


1.11
log
@	* merge.c (struct sec_merge_hash_entry): Add u.entsize and u.suffix
	fields, change sec into secinfo.
	(struct sec_merge_info): Add chain, remove last fields.
	(struct sec_merge_sec_info): Add next, sec, psecinfo fields.
	(sec_merge_hash_lookup): If lookup could not use a string only
	because it has bad alignment, mark the old string for deletion.
	(sec_merge_add): Add secinfo argument. Don't compute entry's
	position, instead record the section.
	(sec_merge_emit): Update for the sec into secinfo change in
	struct sec_merge_hash_entry.
	(_bfd_merge_section): Only record the section for merging, defer
	putting strings into the hash table.
	(cmplengthentry, last4_eq, last_eq, record_section, merge_strings,
	_bfd_merge_sections): New functions.
	(_bfd_merged_section_offset): Update for the sec_merge_hash_entry
	changes.
	* libbfd-in.h (_bfd_merge_sections): Add prototype.
	(_bfd_nolink_bfd_merge_sections): Define.
	* libbfd.h: Likewise.
	(bfd_generic_merge_sections): Add prototype.
	* targets.c (BFD_JUMP_TABLE_LINK): Add _bfd_merge_sections.
	(struct bfd_target): Likewise.
	* bfd.c (bfd_merge_sections): Define.
	* bfd-in2.h: Rebuilt.
	* elf.c (_bfd_elf_merge_sections): New function.
	* elf-bfd.h (_bfd_elf_merge_sections): Add prototype.
	* elfxx-target.h (bfd_elfNN_bfd_merge_sections): Define.
	* reloc.c (bfd_generic_merge_sections): New function.
	* vms.c (vms_bfd_merge_sections): New function.
	* aout-adobe.c (aout_32_bfd_merge_sections): Define.
	* aout-target.h (MY_bfd_merge_sections): Define.
	* aout-tic30.c (MY_bfd_merge_sections): Define.
	* binary.c (binary_bfd_merge_sections): Define.
	* bout.c (b_out_bfd_merge_sections): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_merge_sections): Define.
	* coffcode.c (coff_bfd_merge_sections): Define.
	* coff-mips.c (_bfd_ecoff_bfd_merge_sections): Define.
	* i386msdos.c (msdos_bfd_merge_sections): Define.
	* i386os9k.c (os9k_bfd_merge_sections): Define.
	* ieee.c (ieee_bfd_merge_sections): Define.
	* ihex.c (ihex_bfd_merge_sections): Define.
	* nlm-target.h (nlm_bfd_merge_sections): Define.
	* oasys.c (oasys_bfd_merge_sections): Define.
	* ppcboot.c (ppcboot_bfd_merge_sections): Define.
	* som.c (som_bfd_merge_sections): Define.
	* srec.c (srec_bfd_merge_sections): Define.
	* tekhex.c (tekhex_bfd_merge_sections): Define.
	* versados.c (versados_bfd_merge_sections): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_merge_sections): Define.

	* ldlang.c (lang_process): Call bfd_merge_sections.
@
text
@d1337 1
a1337 1
      if (r_symndx == -1)
d1350 1
a1350 1
      if (r_symndx == -1)
@


1.10
log
@        * coff-alpha.c (reloc_nil): Likewise.
        (alpha_ecoff_bad_format_hook): Likewise.
        (alpha_adjust_reloc_out): Likewise.
        (alpha_bfd_reloc_type_lookup): Likewise.
        (alpha_convert_external_reloc): Likewise.
@
text
@d2362 1
@


1.9
log
@Update copyright notices
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d131 7
a137 7
     bfd *abfd;
     arelent *reloc;
     asymbol *sym;
     PTR data;
     asection *sec;
     bfd *output_bfd;
     char **error_message;
d476 1
a476 1
     bfd *abfd;
d711 1
a711 1
     bfd *abfd;
d1179 1
a1179 1
     bfd *abfd;
d1253 1
a1253 1
     bfd *output_bfd;
d2016 1
a2016 1
     struct internal_aouthdr *ahdr;
@


1.8
log
@2000-11-08  Kazu Hirata  <kazu@@hxi.com>

	* coff-a29k.c: Fix formatting.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1993, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.8.2.2
log
@Merge from mainline.
@
text
@d131 7
a137 7
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc ATTRIBUTE_UNUSED;
     asymbol *sym ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
d476 1
a476 1
     bfd *abfd ATTRIBUTE_UNUSED;
d711 1
a711 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1179 1
a1179 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1253 1
a1253 1
     bfd *output_bfd ATTRIBUTE_UNUSED;
d2016 1
a2016 1
     struct internal_aouthdr *ahdr ATTRIBUTE_UNUSED;
@


1.7
log
@	* coff-alpha.c (alpha_ecoff_backend_data): Add initialization of
	_bfd_coff_force_symnames in strings and
	_bfd_coff_debug_string_prefix_length to their default values.
@
text
@d927 1
a927 1
	    
d983 1
a983 1
	  
d1109 1
a1109 1
	    
d1129 1
a1129 1
      if (r != bfd_reloc_ok) 
d1139 1
a1139 1
	    case bfd_reloc_dangerous: 
d1335 1
a1335 1
		      
d1440 1
a1440 1
     output, the .lita section is limited to 64KB. . */
d1622 1
a1622 1
	    
d1682 1
a1682 1
	  
a2010 1
/*ARGSUSED*/
d2138 1
a2138 1
      /* I don't know what the next eight bytes are for. */
d2203 1
a2203 1
  return NULL;  
d2231 1
a2231 1
	 BSD-4.4-style element with a long odd size. */
d2402 1
a2402 1
  
@


1.6
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d2269 1
a2269 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, true, false, 4,
@


1.5
log
@Revert previous patch.
@
text
@d1136 1
a1136 1
		      input_bfd, input_section, rel->address)))
d1722 1
a1722 1
			      input_section, (bfd_vma) 0)))
d1924 1
a1924 1
			      r_vaddr - input_section->vma)))
@


1.4
log
@Change AR for ELF so that common symbols are not included in archive map.
Change LD for ELF so that archive elements whoes archive map contains a
 reference to a common symbol will get linkled in.
Add new field to bfd_target structure and initialise it for all bfd targets.
@
text
@a2038 2
#define alpha_ecoff_allow_commons_in_armap _bfd_true

@


1.3
log
@	* ecoff.c (bfd_debug_section): Update initialization for new
	comdat_info field.
	(_bfd_ecoff_styp_to_sec_flags): Add section parameter.
	* libecoff.h (_bfd_ecoff_styp_to_sec_flags): Update declaration.

1999-09-10  H.J. Lu  <hjl@@gnu.org>

	* coff-alpha.c (alpha_ecoff_backend_data): Initialize the new
	_bfd_filnmlen field.
	* coff-mips.c (mips_ecoff_backend_data): Likewise.
@
text
@d2039 2
@


1.2
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 1997 Free Software Foundation, Inc.
d2269 1
a2269 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, true, false, 4,
d2275 2
a2276 1
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
@


1.1
log
@Initial revision
@
text
@d2401 2
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

